<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_UT_Dallas_turn_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:UT_Dallas/turn.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:UT_Dallas/turn.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:UT_Dallas/turn.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:UT_Dallas/turn.js&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:UT_Dallas/turn.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:UT Dallas/turn.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2012.igem.org</H3><P>/**
</P><PRE>* turn.js 3rd release
* www.turnjs.com
*
* Copyright (C) 2012, Emmanuel Garcia.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* 1. Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
*
* 2. Any redistribution, use, or modification is done solely for personal 
* benefit and not for any commercial purpose or for monetary gain.
* 
**/
</PRE><P>(function($) {
</P><P>'use strict';
</P><P>var has3d,
</P><P>	vendor =<I>,</I></P><P>	PI = Math.PI,
</P><P>	A90 = PI/2,
</P><P>	isTouch = 'ontouchstart' in window,
</P><P>	events = (isTouch) ? {start: 'touchstart', move: 'touchmove', end: 'touchend'}
			: {start: 'mousedown', move: 'mousemove', end: 'mouseup'},
</P><P>	// Contansts used for each corner
	// tl * tr
	// *     *
	// bl * br
</P><P>	corners = {
		backward: ['bl', 'tl'],
		forward: ['br', 'tr'],
		all: ['tl', 'bl', 'tr', 'br']
	},
</P><P>	displays = ['single', 'double'],
</P><P>	// Default options
</P><P>	turnOptions = {
</P><P>		// First page
</P><P>		page: 1,
</P><P>		// Enables gradients
</P><P>		gradients: true,
</P><P>		// Duration of transition in milliseconds
</P><P>		duration: 600,
</P><P>		// Enables hardware acceleration
</P><P>		acceleration: true,
</P><P>		// Display
</P><P>		display: 'double',
</P><P>		// Events
</P><P>		when: null
	},
</P><P>	flipOptions = {
</P><P>		// Back page
</P><P>		folding: null,
</P><P>		// Corners
		// backward: Activates both tl and bl corners
		// forward: Activates both tr and br corners
		// all: Activates all the corners
</P><P>		corners: 'forward',
</P><P>		// Size of the active zone of each corner
</P><P>		cornerSize: 100,
</P><P>		// Enables gradients
</P><P>		gradients: true,
</P><P>		// Duration of transition in milliseconds
</P><P>		duration: 600,
</P><P>		// Enables hardware acceleration
</P><P>		acceleration: true
	},
</P><P>	// Number of pages in the DOM, minimum value: 6
</P><P>	pagesInDOM = 6,
</P><P>	pagePosition = {0: {top: 0, left: 0, right: 'auto', bottom: 'auto'},
					1: {top: 0, right: 0, left: 'auto', bottom: 'auto'}},
</P><P>	// Gets basic attributes for a layer
</P><P>	divAtt = function(top, left, zIndex, overf) {
		return {'css': {
					position: 'absolute',
					top: top,
					left: left,
					'overflow': overf || 'hidden',
					'z-index': zIndex || 'auto'
					}
			};
	},
</P><P>	// Gets a 2D point from a bezier curve of four points
</P><P>	bezier = function(p1, p2, p3, p4, t) {
		var mum1 = 1 - t,
			mum13 = mum1 * mum1 * mum1,
			mu3 = t * t * t;
</P><P>		return point2D(Math.round(mum13*p1.x + 3*t*mum1*mum1*p2.x + 3*t*t*mum1*p3.x + mu3*p4.x),
						Math.round(mum13*p1.y + 3*t*mum1*mum1*p2.y + 3*t*t*mum1*p3.y + mu3*p4.y));
	},
</P><P>	// Converts an angle from degrees to radians
</P><P>	rad = function(degrees) {
		return degrees/180*PI;
	},
</P><P>	// Converts an angle from radians to degrees
</P><P>	deg = function(radians) {
		return radians/PI*180;
	},
</P><P>	// Gets a 2D point
</P><P>	point2D = function(x, y) {
		return {x: x, y: y};
	},
</P><P>	// Returns the traslate value
</P><P>	translate = function(x, y, use3d) {
		return (has3d &amp;&amp; use3d) ? ' translate3d(' + x + 'px,' + y + 'px, 0px) ' : ' translate(' + x + 'px, ' + y + 'px) ';
	},
</P><P>	// Returns the rotation value
</P><P>	rotate = function(degrees) {
		return ' rotate(' + degrees + 'deg) ';
	},
</P><P>	// Checks if a property belongs to an object
</P><P>	has = function(property, object) {
		return Object.prototype.hasOwnProperty.call(object, property);
	},
</P><P>	// Gets the CSS3 vendor prefix
</P><P>	getPrefix = function() {
		var vendorPrefixes = ['Moz','Webkit','Khtml','O','ms'],
			len = vendorPrefixes.length,
			vendor = <I>;</I></P><P>		while (len--)
			if ((vendorPrefixes[len] + 'Transform') in document.body.style)
				vendor='-'+vendorPrefixes[len].toLowerCase()+'-';
</P><P>		return vendor;
	},
</P><P>	// Adds gradients
</P><P>	gradient = function(obj, p0, p1, colors, numColors) {
</P><P>		var j, cols = [];
</P><P>		if (vendor=='-webkit-') {
</P><P>			for (j = 0; j&lt;numColors; j++)
					cols.push('color-stop('+colors[j][0]+', '+colors[j][1]+')');
</P><P>			obj.css({'background-image': '-webkit-gradient(linear, '+p0.x+'% '+p0.y+'%,  '+p1.x+'% '+p1.y+'%, '+ cols.join(',') +' )'});
</P><P>		} else {
</P><P>			// This procedure makes the gradients for non-webkit browsers
			// It will be reduced to one unique way for gradients in next versions
</P><P>			p0 = {x:p0.x/100 * obj.width(), y:p0.y/100 * obj.height()};
			p1 = {x:p1.x/100 * obj.width(), y:p1.y/100 * obj.height()};
</P><P>			var dx = p1.x-p0.x,
				dy = p1.y-p0.y,
				angle = Math.atan2(dy, dx),
				angle2 = angle - Math.PI/2,
				diagonal = Math.abs(obj.width()*Math.sin(angle2)) + Math.abs(obj.height()*Math.cos(angle2)),
				gradientDiagonal = Math.sqrt(dy*dy + dx*dx),
				corner = point2D((p1.x&lt;p0.x) ? obj.width() : 0, (p1.y&lt;p0.y) ? obj.height() : 0),
				slope = Math.tan(angle),
				inverse = -1/slope,
				x = (inverse*corner.x - corner.y - slope*p0.x + p0.y) / (inverse-slope),
				c = {x: x, y: inverse*x - inverse*corner.x + corner.y},
				segA = (Math.sqrt( Math.pow(c.x-p0.x,2) + Math.pow(c.y-p0.y,2)));
</P><P>				for (j = 0; j&lt;numColors; j++)
					cols.push(' '+colors[j][1]+' '+(( segA + gradientDiagonal*colors[j][0] )*100/diagonal)+'%');
</P><P>				obj.css({'background-image': vendor+'linear-gradient(' + (-angle) + 'rad,' + cols.join(',') + ')'});
		}
	},
</P><P>turnMethods = {
</P><P>	// Singleton constructor
	// $('#selector').turn([options]);
</P><P>	init: function(opts) {
</P><P>		// Define constants
		if (has3d===undefined) {
			has3d = 'WebKitCSSMatrix' in window || 'MozPerspective' in document.body.style;
			vendor = getPrefix();
		}
</P><P>		var i, data = this.data(), ch = this.children();
</P><P>		opts = $.extend({width: this.width(), height: this.height()}, turnOptions, opts);
		data.opts = opts;
		data.pageObjs = {};
		data.pages = {};
		data.pageWrap = {};
		data.pagePlace = {};
		data.pageMv = [];
		data.totalPages = opts.pages || 0;
</P><P>		if (opts.when)
			for (i in opts.when)
				if (has(i, opts.when))
					this.bind(i, opts.when[i]);
</P><P>
		this.css({position: 'relative', width: opts.width, height: opts.height});
</P><P>		this.turn('display', opts.display);
</P><P>		if (has3d &amp;&amp; !isTouch &amp;&amp; opts.acceleration)
			this.transform(translate(0, 0, true));
</P><P>		for (i = 0; i&lt;ch.length; i++)
			this.turn('addPage', ch[i], i+1);
</P><P>		this.turn('page', opts.page);
</P><PRE>       // allow setting active corners as an option
       corners = $.extend({}, corners, opts.corners);
</PRE><P>		// Event listeners
</P><P>		$(this).bind(events.start, function(e) {
			for (var page in data.pages)
				if (has(page, data.pages) &amp;&amp; flipMethods._eventStart.call(data.pages[page], e)===false)
					return false;
		});
</P><P>		$(document).bind(events.move, function(e) {
			for (var page in data.pages)
				if (has(page, data.pages))
					flipMethods._eventMove.call(data.pages[page], e);
		}).
		bind(events.end, function(e) {
			for (var page in data.pages)
				if (has(page, data.pages))
					flipMethods._eventEnd.call(data.pages[page], e);
</P><P>		});
</P><P>		data.done = true;
</P><P>		return this;
	},
</P><P>	// Adds a page from external data
</P><P>	addPage: function(element, page) {
</P><P>		var incPages = false,
			data = this.data(),
			lastPage = data.totalPages+1;
</P><P>		if (page) {
			if (page==lastPage) {
				page = lastPage;
				incPages = true;
			} else if (page&gt;lastPage)
				throw new Error ('It is impossible to add the page &quot;'+page+'&quot;, the maximum value is: &quot;'+lastPage+'&quot;');
</P><P>		} else {
			page = lastPage;
			incPages = true;
		}
</P><P>		if (page&gt;=1 &amp;&amp; page&lt;=lastPage) {
</P><P>			// Stop animations
			if (data.done) this.turn('stop');
</P><P>			// Move pages if it's necessary
			if (page in data.pageObjs)
				turnMethods._movePages.call(this, page, 1);
</P><P>			// Update number of pages
			if (incPages)
				data.totalPages = lastPage;
</P><P>			// Add element
			data.pageObjs[page] = $(element).addClass('turn-page p' + page);
</P><P>			// Add page
			turnMethods._addPage.call(this, page);
</P><P>			// Update view
			if (data.done)
				this.turn('update');
</P><P>			turnMethods._removeFromDOM.call(this);
		}
</P><P>		return this;
	},
</P><P>	// Adds a page from internal data
</P><P>	_addPage: function(page) {
</P><P>		var data = this.data(),
			element = data.pageObjs[page];
</P><P>		if (element)
			if (turnMethods._necessPage.call(this, page)) {
</P><P>				if (!data.pageWrap[page]) {
</P><P>					var pageWidth = (data.display=='double') ? this.width()/2 : this.width(),
						pageHeight = this.height();
</P><P>					element.css({width:pageWidth, height:pageHeight});
</P><P>					// Place
					data.pagePlace[page] = page;
</P><P>					// Wrapper
					data.pageWrap[page] = $('&lt;div/&gt;', {'class': 'turn-page-wrapper',
													page: page,
													css: {position: 'absolute',
													overflow: 'hidden',
													width: pageWidth,
													height: pageHeight}}).
													css(pagePosition[(data.display=='double') ? page%2 : 0]);
</P><P>					// Append to this
					this.append(data.pageWrap[page]);
</P><P>					// Move data.pageObjs[page] (element) to wrapper
					data.pageWrap[page].prepend(data.pageObjs[page]);
				}
</P><P>				// If the page is in the current view, create the flip effect
				if (!page || turnMethods._setPageLoc.call(this, page)==1)
					turnMethods._makeFlip.call(this, page);
</P><P>			} else {
</P><P>				// Place
				data.pagePlace[page] = 0;
</P><P>				// Remove element from the DOM
				if (data.pageObjs[page])
					data.pageObjs[page].remove();
</P><P>			}
</P><P>	},
</P><P>	// Checks if a page is in memory
</P><P>	hasPage: function(page) {
</P><P>		return page in this.data().pageObjs;
</P><P>	},
</P><P>	// Prepares the flip effect for a page
</P><P>	_makeFlip: function(page) {
</P><P>		var data = this.data();
</P><P>		if (!data.pages[page] &amp;&amp; data.pagePlace[page]==page) {
</P><P>			var single = data.display=='single',
				even = page%2;
</P><P>			data.pages[page] = data.pageObjs[page].
								css({width: (single) ? this.width() : this.width()/2, height: this.height()}).
								flip({page: page,
									next: (single &amp;&amp; page === data.totalPages) ? page -1 : ((even || single) ? page+1 : page-1),
									turn: this,
									duration: data.opts.duration,
									acceleration : data.opts.acceleration,
									corners: (single) ? 'all' : ((even) ? 'forward' : 'backward'),
									backGradient: data.opts.gradients,
									frontGradient: data.opts.gradients
									}).
									flip('disable', data.disabled).
									bind('pressed', turnMethods._pressed).
									bind('released', turnMethods._released).
									bind('start', turnMethods._start).
									bind('end', turnMethods._end).
									bind('flip', turnMethods._flip);
		}
		return data.pages[page];
	},
</P><P>	// Makes pages within a range
</P><P>	_makeRange: function() {
</P><P>		var page,
			data = this.data(),
			range = this.turn('range');
</P><P>			for (page = range[0]; page&lt;=range[1]; page++)
				turnMethods._addPage.call(this, page);
</P><P>	},
</P><P>	// Returns a range of `pagesInDOM` pages that should be in the DOM
	// Example:
	// - page of the current view, return true
	// * page is in the range, return true
	// 0 page is not in the range, return false
	//
	// 1 2-3 4-5 6-7 8-9 10-11 12-13
	//    **  **  --   **  **
</P><P>	range: function(page) {
</P><P>		var remainingPages, left, right,
			data = this.data();
			page = page || data.tpage || data.page;
			var view = turnMethods._view.call(this, page);
</P><P>			if (page&lt;1 || page&gt;data.totalPages)
				throw new Error ('&quot;'+page+'&quot; is not a page for range');
</P><P>			view[1] = view[1] || view[0];
</P><P>			if (view[0]&gt;=1 &amp;&amp; view[1]&lt;=data.totalPages) {
</P><P>				remainingPages = Math.floor((pagesInDOM-2)/2);
</P><P>				if (data.totalPages-view[1] &gt; view[0]) {
					left = Math.min(view[0]-1, remainingPages);
					right = 2*remainingPages-left;
				} else {
					right = Math.min(data.totalPages-view[1], remainingPages);
					left = 2*remainingPages-right;
				}
</P><P>			} else {
				left = pagesInDOM-1;
				right = pagesInDOM-1;
			}
</P><P>			return [Math.max(1, view[0]-left), Math.min(data.totalPages, view[1]+right)];
</P><P>	},
</P><P>	// Detects if a page is within the range of `pagesInDOM` from the current view
</P><P>	_necessPage: function(page) {
</P><P>		if (page===0)
			return true;
</P><P>		var range = this.turn('range');
</P><P>		return page&gt;=range[0] &amp;&amp; page&lt;=range[1];
</P><P>	},
</P><P>	// Releases memory by removing pages from the DOM
</P><P>	_removeFromDOM: function() {
</P><P>		var page, data = this.data();
</P><P>		for (page in data.pageWrap)
			if (has(page, data.pageWrap) &amp;&amp; !turnMethods._necessPage.call(this, page))
				turnMethods._removePageFromDOM.call(this, page);
</P><P>
	},
</P><P>	// Removes a page from DOM and its internal references
</P><P>	_removePageFromDOM: function(page) {
</P><P>		var data = this.data();
</P><P>		if (data.pages[page]) {
			var dd = data.pages[page].data();
			if (dd.f &amp;&amp; dd.f.fwrapper)
				dd.f.fwrapper.remove();
			data.pages[page].remove();
			delete data.pages[page];
		}
</P><P>		if (data.pageObjs[page])
			data.pageObjs[page].remove();
</P><P>		if (data.pageWrap[page]) {
			data.pageWrap[page].remove();
			delete data.pageWrap[page];
		}
</P><P>		delete data.pagePlace[page];
</P><P>	},
</P><P>	// Removes a page
</P><P>	removePage: function(page) {
</P><P>		var data = this.data();
</P><P>		if (data.pageObjs[page]) {
			// Stop animations
			this.turn('stop');
</P><P>			// Remove `page`
			turnMethods._removePageFromDOM.call(this, page);
			delete data.pageObjs[page];
</P><P>			// Move the pages behind `page`
			turnMethods._movePages.call(this, page, -1);
</P><P>			// Resize the size of this magazine
			data.totalPages = data.totalPages-1;
			turnMethods._makeRange.call(this);
</P><P>			// Check the current view
			if (data.page&gt;data.totalPages)
				this.turn('page', data.totalPages);
		}
</P><P>		return this;
</P><P>	},
</P><P>	// Moves pages
</P><P>	_movePages: function(from, change) {
</P><P>		var page,
			data = this.data(),
			single = data.display=='single',
			move = function(page) {
</P><P>				var next = page + change,
					odd = next%2;
</P><P>				if (data.pageObjs[page])
					data.pageObjs[next] = data.pageObjs[page].removeClass('page' + page).addClass('page' + next);
</P><P>				if (data.pagePlace[page] &amp;&amp; data.pageWrap[page]) {
					data.pagePlace[next] = next;
					data.pageWrap[next] = data.pageWrap[page].css(pagePosition[(single) ? 0 : odd]).attr('page', next);
</P><P>					if (data.pages[page])
						data.pages[next] = data.pages[page].flip('options', {
							page: next,
							next: (single || odd) ? next+1 : next-1,
							corners: (single) ? 'all' : ((odd) ? 'forward' : 'backward')
						});
</P><P>					if (change) {
						delete data.pages[page];
						delete data.pagePlace[page];
						delete data.pageObjs[page];
						delete data.pageWrap[page];
						delete data.pageObjs[page];
					}
			}
		};
</P><P>		if (change&gt;0)
			for (page=data.totalPages; page&gt;=from; page--) move(page);
		else
			for (page=from; page&lt;=data.totalPages; page++) move(page);
</P><P>	},
</P><P>	// Sets or Gets the display mode
</P><P>	display: function(display) {
</P><P>		var data = this.data(),
			currentDisplay = data.display;
</P><P>		if (display) {
</P><P>			if ($.inArray(display, displays)==-1)
				throw new Error ('&quot;'+display + '&quot; is not a value for display');
</P><P>			if (display=='single') {
				if (!data.pageObjs[0]) {
					this.turn('stop').
						css({'overflow': 'hidden'});
					data.pageObjs[0] = $('&lt;div /&gt;', {'class': 'turn-page p-temporal'}).
									css({width: this.width(), height: this.height()}).
										appendTo(this);
				}
			} else {
				if (data.pageObjs[0]) {
					this.turn('stop').
						css({'overflow': <I>});</I>
					data.pageObjs[0].remove();
					delete data.pageObjs[0];
				}
			}
</P><P>			data.display = display;
</P><P>			if (currentDisplay) {
				var size = this.turn('size');
				turnMethods._movePages.call(this, 1, 0);
				this.turn('size', size.width, size.height).
						turn('update');
			}
</P><P>			return this;
</P><P>		} else
			return currentDisplay;
</P><P>	},
</P><P>	// Detects if the pages are being animated
</P><P>	animating: function() {
</P><P>		return this.data().pageMv.length&gt;0;
</P><P>	},
</P><P>	// Disables and enables the effect
</P><P>	disable: function(bool) {
</P><P>		var page,
			data = this.data(),
			view = this.turn('view');
</P><P>			data.disabled = bool===undefined || bool===true;
</P><P>		for (page in data.pages)
			if (has(page, data.pages))
				data.pages[page].flip('disable', bool ? $.inArray(page, view) : false );
</P><P>		return this;
</P><P>	},
</P><P>	// Gets and sets the size
</P><P>	size: function(width, height) {
</P><P>		if (width &amp;&amp; height) {
</P><P>			var data = this.data(), pageWidth = (data.display=='double') ? width/2 : width, page;
</P><P>			this.css({width: width, height: height});
</P><P>			if (data.pageObjs[0])
				data.pageObjs[0].css({width: pageWidth, height: height});
</P><P>			for (page in data.pageWrap) {
				if (!has(page, data.pageWrap)) continue;
				data.pageObjs[page].css({width: pageWidth, height: height});
				data.pageWrap[page].css({width: pageWidth, height: height});
				if (data.pages[page])
					data.pages[page].css({width: pageWidth, height: height});
			}
</P><P>			this.turn('resize');
</P><P>			return this;
</P><P>		} else {
</P><P>			return {width: this.width(), height: this.height()};
</P><P>		}
	},
</P><P>	// Resizes each page
</P><P>	resize: function() {
</P><P>		var page, data = this.data();
</P><P>		if (data.pages[0]) {
			data.pageWrap[0].css({left: -this.width()});
			data.pages[0].flip('resize', true);
		}
</P><P>		for (page = 1; page &lt;= data.totalPages; page++)
			if (data.pages[page])
				data.pages[page].flip('resize', true);
</P><P>
	},
</P><P>	// Removes an animation from the cache
</P><P>	_removeMv: function(page) {
</P><P>		var i, data = this.data();
</P><P>		for (i=0; i&lt;data.pageMv.length; i++)
			if (data.pageMv[i]==page) {
				data.pageMv.splice(i, 1);
				return true;
			}
</P><P>		return false;
</P><P>	},
</P><P>	// Adds an animation to the cache
</P><P>	_addMv: function(page) {
</P><P>		var data = this.data();
</P><P>		turnMethods._removeMv.call(this, page);
		data.pageMv.push(page);
</P><P>	},
</P><P>	// Gets indexes for a view
</P><P>	_view: function(page) {
</P><P>		var data = this.data();
		page = page || data.page;
</P><P>		if (data.display=='double')
			return (page%2) ? [page-1, page] : [page, page+1];
		else
			return [page];
</P><P>	},
</P><P>	// Gets a view
</P><P>	view: function(page) {
</P><P>		var data = this.data(), view = turnMethods._view.call(this, page);
</P><P>		return (data.display=='double') ? [(view[0]&gt;0) ? view[0] : 0, (view[1]&lt;=data.totalPages) ? view[1] : 0]
				: [(view[0]&gt;0 &amp;&amp; view[0]&lt;=data.totalPages) ? view[0] : 0];
</P><P>	},
</P><P>	// Stops animations
</P><P>	stop: function(ok) {
</P><P>		var i, opts, data = this.data(), pages = data.pageMv;
</P><P>		data.pageMv = [];
</P><P>		if (data.tpage) {
			data.page = data.tpage;
			delete data['tpage'];
		}
</P><P>		for (i in pages) {
			if (!has(i, pages)) continue;
			opts = data.pages[pages[i]].data().f.opts;
			flipMethods._moveFoldingPage.call(data.pages[pages[i]], null);
			data.pages[pages[i]].flip('hideFoldedPage');
			data.pagePlace[opts.next] = opts.next;
</P><P>			if (opts.force) {
				opts.next = (opts.page%2===0) ? opts.page-1 : opts.page+1;
				delete opts['force'];
			}
</P><P>		}
</P><P>		this.turn('update');
</P><P>		return this;
	},
</P><P>	// Gets and sets the number of pages
</P><P>	pages: function(pages) {
</P><P>		var data = this.data();
</P><P>		if (pages) {
			if (pages&lt;data.totalPages) {
</P><P>				for (var page = pages+1; page&lt;=data.totalPages; page++)
					this.turn('removePage', page);
</P><P>				if (this.turn('page')&gt;pages)
					this.turn('page', pages);
			}
</P><P>			data.totalPages = pages;
</P><P>			return this;
		} else
			return data.totalPages;
</P><P>	},
</P><P>	// Sets a page without effect
</P><P>	_fitPage: function(page, ok) {
</P><P>		var data = this.data(), newView = this.turn('view', page);
</P><P>		if (data.page!=page) {
			this.trigger('turning', [page, newView]);
			if ($.inArray(1, newView)!=-1) this.trigger('first');
			if ($.inArray(data.totalPages, newView)!=-1) this.trigger('last');
		}
</P><P>		if (!data.pageObjs[page])
			return;
</P><P>		data.tpage = page;
</P><P>		this.turn('stop', ok);
		turnMethods._removeFromDOM.call(this);
		turnMethods._makeRange.call(this);
		this.trigger('turned', [page, newView]);
</P><P>	},
</P><P>	// Turns to a page
</P><P>	_turnPage: function(page) {
</P><P>		var current, next,
			data = this.data(),
			view = this.turn('view'),
			newView = this.turn('view', page);
</P><P>		if (data.page!=page) {
			this.trigger('turning', [page, newView]);
			if ($.inArray(1, newView)!=-1) this.trigger('first');
			if ($.inArray(data.totalPages, newView)!=-1) this.trigger('last');
		}
</P><P>		if (!data.pageObjs[page])
			return;
</P><P>		data.tpage = page;
</P><P>		this.turn('stop');
</P><P>		turnMethods._makeRange.call(this);
</P><P>		if (data.display=='single') {
			current = view[0];
			next = newView[0];
		} else if (view[1] &amp;&amp; page&gt;view[1]) {
			current = view[1];
			next = newView[0];
		} else if (view[0] &amp;&amp; page&lt;view[0]) {
			current = view[0];
			next = newView[1];
		}
</P><P>		if (data.pages[current]) {
</P><P>			var opts = data.pages[current].data().f.opts;
			data.tpage = next;
</P><P>			if (opts.next!=next) {
				opts.next = next;
				data.pagePlace[next] = opts.page;
				opts.force = true;
			}
</P><P>			if (data.display=='single')
				data.pages[current].flip('turnPage', (newView[0] &gt; view[0]) ? 'br' : 'bl');
			else
				data.pages[current].flip('turnPage');
		}
</P><P>	},
</P><P>	// Gets and sets a page
</P><P>	page: function(page) {
</P><P>		page = parseInt(page, 10);
</P><P>		var data = this.data();
</P><P>		if (page&gt;0 &amp;&amp; page&lt;=data.totalPages) {
			if (!data.done || $.inArray(page, this.turn('view'))!=-1)
				turnMethods._fitPage.call(this, page);
			else
				turnMethods._turnPage.call(this, page);
</P><P>			return this;
</P><P>		} else
			return data.page;
</P><P>	},
</P><P>	// Turns to the next view
</P><P>	next: function() {
</P><P>		var data = this.data();
		return this.turn('page', turnMethods._view.call(this, data.page).pop() + 1);
</P><P>	},
</P><P>	// Turns to the previous view
</P><P>	previous: function() {
</P><P>		var data = this.data();
		return this.turn('page', turnMethods._view.call(this, data.page).shift() - 1);
</P><P>	},
</P><P>	// Adds a motion to the internal list
</P><P>	_addMotionPage: function() {
</P><P>		var opts = $(this).data().f.opts,
			turn = opts.turn,
			dd = turn.data();
</P><P>		opts.pageMv = opts.page;
		turnMethods._addMv.call(turn, opts.pageMv);
		dd.pagePlace[opts.next] = opts.page;
		turn.turn('update');
</P><P>	},
</P><P>	// This event is called in context of flip
</P><P>	_start: function(e, opts, corner) {
</P><P>			var data = opts.turn.data(),
				event = $.Event('start');
</P><P>			e.stopPropagation();
</P><P>			opts.turn.trigger(event, [opts, corner]);
</P><P>			if (event.isDefaultPrevented()) {
				e.preventDefault();
				return;
			}
</P><P>		if (data.display=='single') {
</P><P>			var left = corner.charAt(1)=='l';
			if ((opts.page==1 &amp;&amp; left) || (opts.page==data.totalPages &amp;&amp; !left))
				e.preventDefault();
			else {
				if (left) {
					opts.next = (opts.next&lt;opts.page) ? opts.next : opts.page-1;
					opts.force = true;
				} else
					opts.next = (opts.next&gt;opts.page) ? opts.next : opts.page+1;
			}
</P><P>		}
</P><P>		turnMethods._addMotionPage.call(this);
	},
</P><P>	// This event is called in context of flip
</P><P>	_end: function(e, turned) {
</P><P>		var that = $(this),
			data = that.data().f,
			opts = data.opts,
			turn = opts.turn,
			dd = turn.data();
</P><P>		e.stopPropagation();
</P><P>		if (turned || dd.tpage) {
</P><P>			if (dd.tpage==opts.next || dd.tpage==opts.page) {
				delete dd['tpage'];
				turnMethods._fitPage.call(turn, dd.tpage || opts.next, true);
			}
</P><P>		} else {
			turnMethods._removeMv.call(turn, opts.pageMv);
			turn.turn('update');
		}
</P><P>	},
</P><P>	// This event is called in context of flip
</P><P>	_pressed: function() {
</P><P>		var page,
			that = $(this),
			data = that.data().f,
			turn = data.opts.turn,
			pages = turn.data().pages;
</P><P>		for (page in pages)
			if (page!=data.opts.page)
				pages[page].flip('disable', true);
</P><P>		return data.time = new Date().getTime();
</P><P>	},
</P><P>	// This event is called in context of flip
</P><P>	_released: function(e, point) {
</P><P>		var that = $(this),
			data = that.data().f;
</P><P>			e.stopPropagation();
</P><P>		if ((new Date().getTime())-data.time&lt;200 || point.x&lt;0 || point.x&gt;$(this).width()) {
			e.preventDefault();
			data.opts.turn.data().tpage = data.opts.next;
			data.opts.turn.turn('update');
			$(that).flip('turnPage');
		}
</P><P>	},
</P><P>	// This event is called in context of flip
</P><P>	_flip: function() {
</P><P>		var opts = $(this).data().f.opts;
</P><P>		opts.turn.trigger('turn', [opts.next]);
</P><P>	},
</P><P>	// Calculate the z-index value for pages during the animation
</P><P>	calculateZ: function(mv) {
</P><P>		var i, page, nextPage, placePage, dpage,
			that = this,
			data = this.data(),
			view = this.turn('view'),
			currentPage = view[0] || view[1],
			r = {pageZ: {}, partZ: {}, pageV: {}},
</P><P>			addView = function(page) {
				var view = that.turn('view', page);
				if (view[0]) r.pageV[view[0]] = true;
				if (view[1]) r.pageV[view[1]] = true;
			};
</P><P>			for (i = 0; i&lt;mv.length; i++) {
				page = mv[i];
				nextPage = data.pages[page].data().f.opts.next;
				placePage = data.pagePlace[page];
				addView(page);
				addView(nextPage);
				dpage = (data.pagePlace[nextPage]==nextPage) ? nextPage : page;
				r.pageZ[dpage] = data.totalPages - Math.abs(currentPage-dpage);
				r.partZ[placePage] = data.totalPages*2 + Math.abs(currentPage-dpage);
			}
</P><P>		return r;
	},
</P><P>	// Updates the z-index and display property of every page
</P><P>	update: function() {
</P><P>		var page,
			data = this.data();
</P><P>		if (data.pageMv.length &amp;&amp; data.pageMv[0]!==0) {
</P><P>			// Update motion
</P><P>			var apage,
				pos = this.turn('calculateZ', data.pageMv),
				view = this.turn('view', data.tpage);
</P><P>			if (data.pagePlace[view[0]]==view[0]) apage = view[0];
			else if (data.pagePlace[view[1]]==view[1]) apage = view[1];
</P><P>			for (page in data.pageWrap) {
</P><P>				if (!has(page, data.pageWrap)) continue;
</P><P>				data.pageWrap[page].css({display: (pos.pageV[page]) ? <I> : 'none', 'z-index': pos.pageZ[page] || 0});</I></P><P>				if (data.pages[page]) {
					data.pages[page].flip('z', pos.partZ[page] || null);
</P><P>					if (pos.pageV[page])
						data.pages[page].flip('resize');
</P><P>					if (data.tpage)
						data.pages[page].flip('disable', true); // data.disabled || page!=apage
				}
			}
</P><P>		} else {
</P><P>			// Update static pages
</P><P>			for (page in data.pageWrap) {
				if (!has(page, data.pageWrap)) continue;
					var pageLocation = turnMethods._setPageLoc.call(this, page);
					if (data.pages[page])
						data.pages[page].flip('disable', data.disabled || pageLocation!=1).flip('z', null);
			}
		}
	},
</P><P>	// Sets the z-index and display property of a page
	// It depends on the current view
</P><P>	_setPageLoc: function(page) {
</P><P>		var data = this.data(),
			view = this.turn('view');
</P><P>		if (page==view[0] || page==view[1]) {
			data.pageWrap[page].css({'z-index': data.totalPages, display: <I>});</I>
			return 1;
		} else if ((data.display=='single' &amp;&amp; page==view[0]+1) || (data.display=='double' &amp;&amp; page==view[0]-2 || page==view[1]+2)) {
			data.pageWrap[page].css({'z-index': data.totalPages-1, display: <I>});</I>
			return 2;
		} else {
			data.pageWrap[page].css({'z-index': 0, display: 'none'});
			return 0;
		}
	}
},
</P><P>// Methods and properties for the flip page effect
</P><P>flipMethods = {
</P><P>	// Constructor
</P><P>	init: function(opts) {
</P><P>		if (opts.gradients) {
			opts.frontGradient = true;
			opts.backGradient = true;
		}
</P><P>		this.data({f: {}});
		this.flip('options', opts);
</P><P>		flipMethods._addPageWrapper.call(this);
</P><P>		return this;
	},
</P><P>	setData: function(d) {
</P><P>		var data = this.data();
</P><P>		data.f = $.extend(data.f, d);
</P><P>		return this;
	},
</P><P>	options: function(opts) {
</P><P>		var data = this.data().f;
</P><P>		if (opts) {
			flipMethods.setData.call(this, {opts: $.extend({}, data.opts || flipOptions, opts) });
			return this;
		} else
			return data.opts;
</P><P>	},
</P><P>	z: function(z) {
</P><P>		var data = this.data().f;
		data.opts['z-index'] = z;
		data.fwrapper.css({'z-index': z || parseInt(data.parent.css('z-index'), 10) || 0});
</P><P>		return this;
	},
</P><P>	_cAllowed: function() {
</P><P>		return corners[this.data().f.opts.corners] || this.data().f.opts.corners;
</P><P>	},
</P><P>	_cornerActivated: function(e) {
		if (e.originalEvent === undefined) {
			return false;
		}		
</P><P>		e = (isTouch) ? e.originalEvent.touches : [e];
</P><P>		var data = this.data().f,
			pos = data.parent.offset(),
			width = this.width(),
			height = this.height(),
			c = {x: Math.max(0, e[0].pageX-pos.left), y: Math.max(0, e[0].pageY-pos.top)},
			csz = data.opts.cornerSize,
			allowedCorners = flipMethods._cAllowed.call(this);
</P><P>			if (c.x&lt;=0 || c.y&lt;=0 || c.x&gt;=width || c.y&gt;=height) return false;
</P><P>			if (c.y&lt;csz) c.corner = 't';
			else if (c.y&gt;=height-csz) c.corner = 'b';
			else return false;
</P><P>			if (c.x&lt;=csz) c.corner+= 'l';
			else if (c.x&gt;=width-csz) c.corner+= 'r';
			else return false;
</P><P>		return ($.inArray(c.corner, allowedCorners)==-1) ? false : c;
</P><P>	},
</P><P>	_c: function(corner, opts) {
</P><P>		opts = opts || 0;
		return ({tl: point2D(opts, opts),
				tr: point2D(this.width()-opts, opts),
				bl: point2D(opts, this.height()-opts),
				br: point2D(this.width()-opts, this.height()-opts)})[corner];
</P><P>	},
</P><P>	_c2: function(corner) {
</P><P>		return {tl: point2D(this.width()*2, 0),
				tr: point2D(-this.width(), 0),
				bl: point2D(this.width()*2, this.height()),
				br: point2D(-this.width(), this.height())}[corner];
</P><P>	},
</P><P>	_foldingPage: function(corner) {
</P><P>		var opts = this.data().f.opts;
</P><P>		if (opts.folding) return opts.folding;
		else if(opts.turn) {
			var data = opts.turn.data();
			if (data.display == 'single')
				return (data.pageObjs[opts.next]) ? data.pageObjs[0] : null;
			else
				return data.pageObjs[opts.next];
		}
</P><P>	},
</P><P>	_backGradient: function() {
</P><P>		var data =	this.data().f,
			turn = data.opts.turn,
			gradient = data.opts.backGradient &amp;&amp;
						(!turn || turn.data().display=='single' || (data.opts.page!=2 &amp;&amp; data.opts.page!=turn.data().totalPages-1) );
</P><P>
		if (gradient &amp;&amp; !data.bshadow)
			data.bshadow = $('&lt;div/&gt;', divAtt(0, 0, 1)).
				css({'position': <I>, width: this.width(), height: this.height()}).</I>
					appendTo(data.parent);
</P><P>		return gradient;
</P><P>	},
</P><P>	resize: function(full) {
</P><P>		var data = this.data().f,
			width = this.width(),
			height = this.height(),
			size = Math.round(Math.sqrt(Math.pow(width, 2)+Math.pow(height, 2)));
</P><P>		if (full) {
			data.wrapper.css({width: size, height: size});
			data.fwrapper.css({width: size, height: size}).
				children(':first-child').
					css({width: width, height: height});
</P><P>			data.fpage.css({width: height, height: width});
</P><P>			if (data.opts.frontGradient)
				data.ashadow.css({width: height, height: width});
</P><P>			if (flipMethods._backGradient.call(this))
				data.bshadow.css({width: width, height: height});
		}
</P><P>		if (data.parent.is(':visible')) {
			data.fwrapper.css({top: data.parent.offset().top,
				left: data.parent.offset().left});
</P><P>			if (data.opts.turn)
				data.fparent.css({top: -data.opts.turn.offset().top, left: -data.opts.turn.offset().left});
		}
</P><P>		this.flip('z', data.opts['z-index']);
</P><P>	},
</P><P>	// Prepares the page by adding a general wrapper and another objects
</P><P>	_addPageWrapper: function() {
</P><P>		var att,
			data = this.data().f,
			parent = this.parent();
</P><P>		if (!data.wrapper) {
</P><P>			var left = this.css('left'),
				top = this.css('top'),
				width = this.width(),
				height = this.height(),
				size = Math.round(Math.sqrt(Math.pow(width, 2)+Math.pow(height, 2)));
</P><P>			data.parent = parent;
			data.fparent = (data.opts.turn) ? data.opts.turn.data().fparent : $('#turn-fwrappers');
</P><P>			if (!data.fparent) {
				var fparent = $('&lt;div/&gt;', {css: {'pointer-events': 'none'}}).hide();
					fparent.data().flips = 0;
</P><P>				if (data.opts.turn) {
					fparent.css(divAtt(-data.opts.turn.offset().top, -data.opts.turn.offset().left, 'auto', 'visible').css).
							appendTo(data.opts.turn);
</P><P>					data.opts.turn.data().fparent = fparent;
				} else {
					fparent.css(divAtt(0, 0, 'auto', 'visible').css).
						attr('id', 'turn-fwrappers').
							appendTo($('body'));
				}
</P><P>				data.fparent = fparent;
			}
</P><P>			this.css({position: 'absolute', top: 0, left: 0, bottom: 'auto', right: 'auto'});
</P><P>			data.wrapper = $('&lt;div/&gt;', divAtt(0, 0, this.css('z-index'))).
								appendTo(parent).
									prepend(this);
</P><P>			data.fwrapper = $('&lt;div/&gt;', divAtt(parent.offset().top, parent.offset().left)).
								hide().
									appendTo(data.fparent);
</P><P>			data.fpage = $('&lt;div/&gt;', {css: {cursor: 'default'}}).
					appendTo($('&lt;div/&gt;', divAtt(0, 0, 0, 'visible')).
								appendTo(data.fwrapper));
</P><P>			if (data.opts.frontGradient)
				data.ashadow = $('&lt;div/&gt;', divAtt(0, 0,  1)).
					appendTo(data.fpage);
</P><P>			// Save data
</P><P>			flipMethods.setData.call(this, data);
</P><P>			// Set size
			flipMethods.resize.call(this, true);
		}
</P><P>	},
</P><P>	// Takes a 2P point from the screen and applies the transformation
</P><P>	_fold: function(point) {
</P><P>		var that = this,
			a = 0,
			alpha = 0,
			beta,
			px,
			gradientEndPointA,
			gradientEndPointB,
			gradientStartV,
			gradientSize,
			gradientOpacity,
			mv = point2D(0, 0),
			df = point2D(0, 0),
			tr = point2D(0, 0),
			width = this.width(),
			height = this.height(),
			folding = flipMethods._foldingPage.call(this),
			tan = Math.tan(alpha),
			data = this.data().f,
			ac = data.opts.acceleration,
			h = data.wrapper.height(),
			o = flipMethods._c.call(this, point.corner),
			top = point.corner.substr(0, 1) == 't',
			left = point.corner.substr(1, 1) == 'l',
</P><P>			compute = function() {
				var rel = point2D((o.x) ? o.x - point.x : point.x, (o.y) ? o.y - point.y : point.y),
					tan = (Math.atan2(rel.y, rel.x)),
					middle;
</P><P>				alpha = A90 - tan;
				a = deg(alpha);
				middle = point2D((left) ? width - rel.x/2 : point.x + rel.x/2, rel.y/2);
</P><P>				var gamma = alpha - Math.atan2(middle.y, middle.x),
					distance =  Math.max(0, Math.sin(gamma) * Math.sqrt(Math.pow(middle.x, 2) + Math.pow(middle.y, 2)));
</P><P>					tr = point2D(distance * Math.sin(alpha), distance * Math.cos(alpha));
</P><P>					if (alpha &gt; A90) {
</P><P>						tr.x = tr.x + Math.abs(tr.y * Math.tan(tan));
						tr.y = 0;
</P><P>						if (Math.round(tr.x*Math.tan(PI-alpha)) &lt; height) {
</P><P>							point.y = Math.sqrt(Math.pow(height, 2)+2 * middle.x * rel.x);
							if (top) point.y =  height - point.y;
							return compute();
</P><P>						}
					}
</P><P>				if (alpha&gt;A90) {
					var beta = PI-alpha, dd = h - height/Math.sin(beta);
					mv = point2D(Math.round(dd*Math.cos(beta)), Math.round(dd*Math.sin(beta)));
					if (left) mv.x = - mv.x;
					if (top) mv.y = - mv.y;
				}
</P><P>				px = Math.round(tr.y/Math.tan(alpha) + tr.x);
</P><P>				var side = width - px,
					sideX = side*Math.cos(alpha*2),
					sideY = side*Math.sin(alpha*2);
					df = point2D(Math.round( (left ? side -sideX : px+sideX)), Math.round((top) ? sideY : height - sideY));
</P><P>				
				// GRADIENTS
</P><P>					gradientSize = side*Math.sin(alpha);
						var endingPoint = flipMethods._c2.call(that, point.corner),
						far = Math.sqrt(Math.pow(endingPoint.x-point.x, 2)+Math.pow(endingPoint.y-point.y, 2));
</P><P>					gradientOpacity = (far&lt;width) ? far/width : 1;
</P><P>
				if (data.opts.frontGradient) {
</P><P>					gradientStartV = gradientSize&gt;100 ? (gradientSize-100)/gradientSize : 0;
					gradientEndPointA = point2D(gradientSize*Math.sin(A90-alpha)/height*100, gradientSize*Math.cos(A90-alpha)/width*100);
</P><P>					if (top) gradientEndPointA.y = 100-gradientEndPointA.y;
					if (left) gradientEndPointA.x = 100-gradientEndPointA.x;
				}
</P><P>				if (flipMethods._backGradient.call(that)) {
</P><P>					gradientEndPointB = point2D(gradientSize*Math.sin(alpha)/width*100, gradientSize*Math.cos(alpha)/height*100);
					if (!left) gradientEndPointB.x = 100-gradientEndPointB.x;
					if (!top) gradientEndPointB.y = 100-gradientEndPointB.y;
				}
				//
</P><P>				tr.x = Math.round(tr.x);
				tr.y = Math.round(tr.y);
</P><P>				return true;
			},
</P><P>			transform = function(tr, c, x, a) {
</P><P>				var f = ['0', 'auto'], mvW = (width-h)*x[0]/100, mvH = (height-h)*x[1]/100,
					v = {left: f[c[0]], top: f[c[1]], right: f[c[2]], bottom: f[c[3]]},
					aliasingFk = (a!=90 &amp;&amp; a!=-90) ? (left ? -1 : 1) : 0;
</P><P>					x = x[0] + '% ' + x[1] + '%';
</P><P>				that.css(v).transform(rotate(a) + translate(tr.x + aliasingFk, tr.y, ac), x);
</P><P>				data.fpage.parent().css(v);
				data.wrapper.transform(translate(-tr.x + mvW-aliasingFk, -tr.y + mvH, ac) + rotate(-a), x);
</P><P>				data.fwrapper.transform(translate(-tr.x + mv.x + mvW, -tr.y + mv.y + mvH, ac) + rotate(-a), x);
				data.fpage.parent().transform(rotate(a) + translate(tr.x + df.x - mv.x, tr.y + df.y - mv.y, ac), x);
</P><P>				if (data.opts.frontGradient)
					gradient(data.ashadow,
							point2D(left?100:0, top?100:0),
							point2D(gradientEndPointA.x, gradientEndPointA.y),
							[[gradientStartV, 'rgba(0,0,0,0)'],
							[((1-gradientStartV)*0.8)+gradientStartV, 'rgba(0,0,0,'+(0.2*gradientOpacity)+')'],
							[1, 'rgba(255,255,255,'+(0.2*gradientOpacity)+')']],
							3,
							alpha);
</P><P>				if (flipMethods._backGradient.call(that))
					gradient(data.bshadow,
							point2D(left?0:100, top?0:100),
							point2D(gradientEndPointB.x, gradientEndPointB.y),
							[[0.8, 'rgba(0,0,0,0)'],
							[1, 'rgba(0,0,0,'+(0.3*gradientOpacity)+')'],
							[1, 'rgba(0,0,0,0)']],
							3);
</P><P>			};
</P><P>		switch (point.corner) {
			case 'tl' :
				point.x = Math.max(point.x, 1);
				compute();
				transform(tr, [1,0,0,1], [100, 0], a);
				data.fpage.transform(translate(-height, -width, ac) + rotate(90-a*2) , '100% 100%');
				folding.transform(rotate(90) + translate(0, -height, ac), '0% 0%');
			break;
			case 'tr' :
				point.x = Math.min(point.x, width-1);
				compute();
				transform(point2D(-tr.x, tr.y), [0,0,0,1], [0, 0], -a);
				data.fpage.transform(translate(0, -width, ac) + rotate(-90+a*2) , '0% 100%');
				folding.transform(rotate(270) + translate(-width, 0, ac), '0% 0%');
			break;
			case 'bl' :
				point.x = Math.max(point.x, 1);
				compute();
				transform(point2D(tr.x, -tr.y), [1,1,0,0], [100, 100], -a);
				data.fpage.transform(translate(-height, 0, ac) + rotate(-90+a*2), '100% 0%');
				folding.transform(rotate(270) + translate(-width, 0, ac), '0% 0%');
			break;
			case 'br' :
				point.x = Math.min(point.x, width-1);
				compute();
				transform(point2D(-tr.x, -tr.y), [0,1,1,0], [0, 100], a);
				data.fpage.transform(rotate(90-a*2), '0% 0%');
				folding.transform(rotate(90) + translate(0, -height, ac), '0% 0%');
</P><P>			break;
		}
</P><P>		data.point = point;
</P><P>	},
</P><P>	_moveFoldingPage: function(bool) {
</P><P>		var data = this.data().f,
			folding = flipMethods._foldingPage.call(this);
</P><P>		if (folding) {
			if (bool) {
				if (!data.fpage.children()[data.ashadow? '1' : '0']) {
					flipMethods.setData.call(this, {backParent: folding.parent()});
					data.fpage.prepend(folding);
				}
			} else {
				if (data.backParent)
					data.backParent.prepend(folding);
</P><P>			}
		}
</P><P>	},
</P><P>	_showFoldedPage: function(c, animate) {
</P><P>		var folding = flipMethods._foldingPage.call(this),
			dd = this.data(),
			data = dd.f;
</P><P>		if (!data.point || data.point.corner!=c.corner) {
			var event = $.Event('start');
			this.trigger(event, [data.opts, c.corner]);
</P><P>			if (event.isDefaultPrevented())
				return false;
		}
</P><P>
		if (folding) {
</P><P>			if (animate) {
</P><P>				var that = this, point = (data.point &amp;&amp; data.point.corner==c.corner) ? data.point : flipMethods._c.call(this, c.corner, 1);
</P><P>				this.animatef({from: [point.x, point.y], to:[c.x, c.y], duration: 500, frame: function(v) {
					c.x = Math.round(v[0]);
					c.y = Math.round(v[1]);
					flipMethods._fold.call(that, c);
				}});
</P><P>			} else	{
</P><P>				flipMethods._fold.call(this, c);
				if (dd.effect &amp;&amp; !dd.effect.turning)
					this.animatef(false);
</P><P>			}
</P><P>			if (!data.fwrapper.is(':visible')) {
				data.fparent.show().data().flips++;
				flipMethods._moveFoldingPage.call(this, true);
				data.fwrapper.show();
</P><P>				if (data.bshadow)
					data.bshadow.show();
			}
</P><P>			return true;
		}
</P><P>		return false;
	},
</P><P>	hide: function() {
</P><P>		var data = this.data().f,
			folding = flipMethods._foldingPage.call(this);
</P><P>		if ((--data.fparent.data().flips)===0)
			data.fparent.hide();
</P><P>		this.css({left: 0, top: 0, right: 'auto', bottom: 'auto'}).transform(<I>, '0% 100%');</I></P><P>		data.wrapper.transform(<I>, '0% 100%');</I></P><P>		data.fwrapper.hide();
</P><P>		if (data.bshadow)
			data.bshadow.hide();
</P><P>		folding.transform(<I>, '0% 0%');</I></P><P>		return this;
	},
</P><P>	hideFoldedPage: function(animate) {
</P><P>		var data = this.data().f;
</P><P>		if (!data.point) return;
</P><P>		var that = this,
			p1 = data.point,
			hide = function() {
				data.point = null;
				that.flip('hide');
				that.trigger('end', [false]);
			};
</P><P>		if (animate) {
			var p4 = flipMethods._c.call(this, p1.corner),
				top = (p1.corner.substr(0,1)=='t'),
				delta = (top) ? Math.min(0, p1.y-p4.y)/2 : Math.max(0, p1.y-p4.y)/2,
				p2 = point2D(p1.x, p1.y+delta),
				p3 = point2D(p4.x, p4.y-delta);
</P><P>			this.animatef({
				from: 0,
				to: 1,
				frame: function(v) {
					var np = bezier(p1, p2, p3, p4, v);
					p1.x = np.x;
					p1.y = np.y;
					flipMethods._fold.call(that, p1);
				},
				complete: hide,
				duration: 800,
				hiding: true
				});
</P><P>		} else {
			this.animatef(false);
			hide();
		}
	},
</P><P>	turnPage: function(corner) {
</P><P>		var that = this,
			data = this.data().f;
</P><P>		corner = {corner: (data.corner) ? data.corner.corner : corner || flipMethods._cAllowed.call(this)[0]};
</P><P>		var p1 = data.point || flipMethods._c.call(this, corner.corner, (data.opts.turn) ? data.opts.turn.data().opts.elevation : 0),
			p4 = flipMethods._c2.call(this, corner.corner);
</P><P>			this.trigger('flip').
				animatef({
					from: 0,
					to: 1,
					frame: function(v) {
						var np = bezier(p1, p1, p4, p4, v);
						corner.x = np.x;
						corner.y = np.y;
						flipMethods._showFoldedPage.call(that, corner);
					},
</P><P>					complete: function() {
						that.trigger('end', [true]);
					},
					duration: data.opts.duration,
					turning: true
				});
</P><P>			data.corner = null;
	},
</P><P>	moving: function() {
</P><P>		return 'effect' in this.data();
</P><P>	},
</P><P>	isTurning: function() {
</P><P>		return this.flip('moving') &amp;&amp; this.data().effect.turning;
</P><P>	},
</P><P>	_eventStart: function(e) {
</P><P>		var data = this.data().f;
</P><P>		if (!data.disabled &amp;&amp; !this.flip('isTurning')) {
			data.corner = flipMethods._cornerActivated.call(this, e);
			if (data.corner &amp;&amp; flipMethods._foldingPage.call(this, data.corner)) {
				flipMethods._moveFoldingPage.call(this, true);
				this.trigger('pressed', [data.point]);
				return false;
			} else
				data.corner = null;
		}
</P><P>	},
</P><P>	_eventMove: function(e) {
</P><P>		var data = this.data().f;
</P><P>		if (!data.disabled) {
			e = (isTouch) ? e.originalEvent.touches : [e];
</P><P>			if (data.corner) {
</P><P>				var pos = data.parent.offset();
</P><P>				data.corner.x = e[0].pageX-pos.left;
				data.corner.y = e[0].pageY-pos.top;
</P><P>				flipMethods._showFoldedPage.call(this, data.corner);
</P><P>			} else if (!this.data().effect &amp;&amp; this.is(':visible')) { // roll over
</P><P>				var corner = flipMethods._cornerActivated.call(this, e[0]);
				if (corner) {
					var origin = flipMethods._c.call(this, corner.corner, data.opts.cornerSize/2);
					corner.x = origin.x;
					corner.y = origin.y;
					flipMethods._showFoldedPage.call(this, corner, true);
				} else
					flipMethods.hideFoldedPage.call(this, true);
</P><P>			}
		}
	},
</P><P>	_eventEnd: function() {
</P><P>		var data = this.data().f;
</P><P>		if (!data.disabled &amp;&amp; data.point) {
			var event = $.Event('released');
			this.trigger(event, [data.point]);
			if (!event.isDefaultPrevented())
				flipMethods.hideFoldedPage.call(this, true);
		}
</P><P>		data.corner = null;
</P><P>	},
</P><P>	disable: function(disable) {
</P><P>		flipMethods.setData.call(this, {'disabled': disable});
		return this;
</P><P>	}
},
</P><P>cla = function(that, methods, args) {
</P><P>	if (!args[0] || typeof(args[0])=='object')
		return methods.init.apply(that, args);
	else if(methods[args[0]] &amp;&amp; args[0].toString().substr(0, 1)!='_')
		return methods[args[0]].apply(that, Array.prototype.slice.call(args, 1));
	else
		throw args[0] + ' is an invalid value';
};
</P><P>$.extend($.fn, {
</P><P>	flip: function(req, opts) {
		return cla(this, flipMethods, arguments);
	},
</P><P>	turn: function(req) {
		return cla(this, turnMethods, arguments);
	},
</P><P>	transform: function(transform, origin) {
</P><P>		var properties = {};
</P><P>		if (origin)
			properties[vendor+'transform-origin'] = origin;
</P><P>		properties[vendor+'transform'] = transform;
</P><P>		return this.css(properties);
</P><P>	},
</P><P>	animatef: function(point) {
</P><P>		var data = this.data();
</P><P>		if (data.effect)
			clearInterval(data.effect.handle);
</P><P>		if (point) {
</P><P>			if (!point.to.length) point.to = [point.to];
			if (!point.from.length) point.from = [point.from];
			if (!point.easing) point.easing = function (x, t, b, c, data) { return c * Math.sqrt(1 - (t=t/data-1)*t) + b; };
</P><P>			var j, diff = [],
				len = point.to.length,
				that = this,
				fps = point.fps || 30,
				time = - fps,
				f = function() {
					var j, v = [];
					time = Math.min(point.duration, time + fps);
</P><P>					for (j = 0; j &lt; len; j++)
						v.push(point.easing(1, time, point.from[j], diff[j], point.duration));
</P><P>					point.frame((len==1) ? v[0] : v);
</P><P>					if (time==point.duration) {
						clearInterval(data.effect.handle);
						delete data['effect'];
						that.data(data);
						if (point.complete)
							point.complete();
						}
					};
</P><P>			for (j = 0; j &lt; len; j++)
				diff.push(point.to[j] - point.from[j]);
</P><P>			data.effect = point;
			data.effect.handle = setInterval(f, fps);
			this.data(data);
			f();
		} else {
			delete data['effect'];
		}
	}
});
</P><P>
$.isTouch = isTouch;
</P><P>})(jQuery);
</P><P>	$(window).bind('keydown', function(e){
</P><P>		if (e.target &amp;&amp; e.target.tagName.toLowerCase()!='input')
			if (e.keyCode==37)
				$('#book').turn('previous');
			else if (e.keyCode==39)
				$('#book').turn('next');
</P><P>	});
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2012.igem.org/Team:UT_Dallas/turn.js">http://2012.igem.org/Team:UT_Dallas/turn.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:UT_Dallas/turn.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:UT_Dallas/turn.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:UT_Dallas/turn.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:UT_Dallas/turn.js&amp;oldid=210923" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2012.igem.org:Privacy_policy" title="2012.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2012.igem.org:General_disclaimer" title="2012.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
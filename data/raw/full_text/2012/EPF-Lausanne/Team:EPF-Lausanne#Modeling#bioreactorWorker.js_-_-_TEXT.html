"
Page
Discussion
View source
History
teams
Log in
 
Team:EPF-Lausanne/Modeling/bioreactorWorker.js
From 2012.igem.org
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }; self.cancel = false; self.started = false; self.Work = {
rays: 0,  totalRays: 0,  lostEnergy: 0,  totalEnergy: 0,  totalLEDs: 0,  finished: 0,  lastProgress: -2000,  data: [],  workQueue: [],  "do": function(_arg) {    var absorbance, angle, angleBias, angle_zero, attributedLights, c, directed, endAngle, i, j, leds, lightAngle, n, nLights, nRings, position, power, r, radius, rays, reflective, reflectiveAmount, remainingLeds, resolution, ringIncrement, rings, startAngle, totalCircumference, x, y, _ref, _ref2;    radius = _arg.radius, power = _arg.power, reflective = _arg.reflective, reflectiveAmount = _arg.reflectiveAmount, absorbance = _arg.absorbance, directed = _arg.directed, lightAngle = _arg.lightAngle, rays = _arg.rays, resolution = _arg.resolution, nLights = _arg.nLights, nRings = _arg.nRings;    this.data = [];    for (x = 0; 0 <= resolution ? x < resolution : x > resolution; 0 <= resolution ? x++ : x--) {      this.data[x] = [];      for (y = 0; 0 <= resolution ? y < resolution : y > resolution; 0 <= resolution ? y++ : y--) {        this.data[x][y] = Math.pow(x / resolution * 2 - 1, 2) + Math.pow(y / resolution * 2 - 1, 2) <= 1 ? 0.0000000000001 : 0;      }    }    if (!reflective) {      reflectiveAmount = 0;    }    angle = lightAngle * Math.PI / 180;    leds = [];    angle_zero = [];    if (nLights === 1) {      leds.push([0, 0]);      angle_zero.push(0);    } else {      ringIncrement = 1.0 / (nRings + 1);      rings = [];      totalCircumference = 0;      for (i = 0; 0 <= nRings ? i < nRings : i > nRings; 0 <= nRings ? i++ : i--) {        r = (i + 1) * ringIncrement;        c = 2 * Math.PI * r;        totalCircumference += c;        rings.push({          n: i,          radius: r,          circumference: c        });      }      for (i = 0; 0 <= nRings ? i < nRings : i > nRings; 0 <= nRings ? i++ : i--) {        rings[i].ratio = rings[i].circumference / totalCircumference;      }      remainingLeds = nLights;      for (i = 0; 0 <= nRings ? i < nRings : i > nRings; 0 <= nRings ? i++ : i--) {        attributedLights = Math.min(remainingLeds, Math.round(rings[i].ratio * nLights));        if (i >= nRings - 1) {          attributedLights = remainingLeds;        }        rings[i].lights = attributedLights;        remainingLeds -= attributedLights;      }      for (i = 0; 0 <= nRings ? i < nRings : i > nRings; 0 <= nRings ? i++ : i--) {        angleBias = Math.PI / 5 * i;        for (j = 0, _ref = rings[i].lights; 0 <= _ref ? j < _ref : j > _ref; 0 <= _ref ? j++ : j--) {          leds.push([rings[i].radius * Math.cos(2 * Math.PI * j / rings[i].lights + angleBias), rings[i].radius * Math.sin(2 * Math.PI * j / rings[i].lights + angleBias)]);          angle_zero.push(2 * Math.PI * j / rings[i].lights + Math.PI);        }      }    }    this.totalLEDs = nLights;    this.totalRays = rays * nLights;    this.totalSurface = resolution * resolution;    this.totalEnergy = power;    n = reflective ? 2 : 50;    for (i = 0, _ref2 = leds.length; 0 <= _ref2 ? i < _ref2 : i > _ref2; 0 <= _ref2 ? i++ : i--) {      position = leds[i];      startAngle = directed ? -angle / 2 : 0;      endAngle = directed ? angle / 2 : 2 * Math.PI;      startAngle += angle_zero[i];      endAngle += angle_zero[i];      this.workQueue.push([position, startAngle, endAngle, 0, n, radius, power / nLights, reflective, reflectiveAmount, absorbance, directed, angle, rays, resolution]);    }    return this.start();  },  start: function() {    if (!this.hasNext()) {      return this.finish();    } else {      return this.next();    }  },  hasNext: function() {    return this.workQueue.length > 0;  },  next: function() {    if (this.hasNext()) {      return this.calcRays.apply(this, this.workQueue.shift());    }  },  calcRays: function(position, startAngle, endAngle, from, n, radius, power, reflective, reflectiveAmount, absorbance, directed, lightAngle, rays, resolution) {    var angle, ray, reportStep, _ref;    if (from > rays || self.cancel) {      return this.finish();    } else {      reportStep = Math.round(rays / 100);      for (ray = from, _ref = Math.min(from + n, rays); from <= _ref ? ray < _ref : ray > _ref; from <= _ref ? ray++ : ray--) {        this.rays++;        angle = (endAngle - startAngle) * ray / rays + startAngle;        this.calcRay(position, angle, radius, power, reflective, reflectiveAmount, absorbance, directed, lightAngle, rays, resolution);        if (ray % reportStep === 0 || reportStep <= 1) {          this.post();        }      }      return setTimeout((__bind(function() {        return this.calcRays(position, startAngle, endAngle, from + n, n, radius, power, reflective, reflectiveAmount, absorbance, directed, lightAngle, rays, resolution);      }, this)), 1);    }  },  calcRay: function(position, angle, radius, power, reflective, reflectiveAmount, absorbance, directed, lightAngle, rays, resolution) {    var absorbed, b_x, b_y, direction, dot, energy, length, normal_dir, pos, squaredLength, stepSize, transmitance_step, tx, ty, virtualStepSize, x, y;    pos = [position[0], position[1]];    direction = [Math.cos(angle), Math.sin(angle)];    energy = power / rays;    virtualStepSize = 0.00001;    stepSize = radius * virtualStepSize;    transmitance_step = Math.pow(10, -absorbance * 1000 * stepSize);    while (energy > 0.0000001) {      squaredLength = pos[0] * pos[0] + pos[1] * pos[1];      if (squaredLength > 1) {        length = Math.sqrt(squaredLength);        normal_dir = [pos[0] / length, pos[1] / length];        dot = -2 * (normal_dir[0] * direction[0] + normal_dir[1] * direction[1]);        direction = [dot * normal_dir[0] + direction[0], dot * normal_dir[1] + direction[1]];        this.lostEnergy += energy * (1 - reflectiveAmount);        energy = energy * reflectiveAmount;      }      pos = [pos[0] + virtualStepSize * direction[0], pos[1] + virtualStepSize * direction[1]];      absorbed = energy * (1 - transmitance_step);      energy -= absorbed;      x = (pos[0] + 1) / 2 * (resolution - 1);      y = (pos[1] + 1) / 2 * (resolution - 1);      x = Math.min(Math.max(0, x), resolution - 1);      y = Math.min(Math.max(0, y), resolution - 1);      b_x = Math.floor(x);      b_y = Math.floor(y);      tx = x - b_x;      ty = y - b_y;      this.data[b_x][b_y] += absorbed * (1 - tx) * (1 - ty);      if (b_x < resolution - 1) {        this.data[b_x + 1][b_y] += absorbed * tx * (1 - ty);      }      if (b_y < resolution - 1) {        this.data[b_x][b_y + 1] += absorbed * (1 - tx) * ty;      }      if (b_x < resolution - 1 && b_y < resolution - 1) {        this.data[b_x + 1][b_y + 1] += absorbed * tx * ty;      }    }  },  post: function() {    var progress;    progress = this.rays / this.totalRays;    if (progress >= 1) {      progress = 0.9999999;    }    if (progress - this.lastProgress < 0.1 / 100) {      return self.postMessage(JSON.stringify({        progress: Math.floor(progress * 10000) / 100,        lost: progress < 0.01 ? 0 : Math.round(this.lostEnergy / this.totalEnergy / progress * 10000) / 100,        data: void 0      }));    } else {      self.postMessage(JSON.stringify({        progress: Math.floor(progress * 10000) / 100,        lost: progress < 0.01 ? 0 : Math.round(this.lostEnergy / this.totalEnergy / progress * 10000) / 100,        data: this.data      }));      return this.lastProgress = progress;    }  },  finish: function() {    var progress;    this.finished++;    if (this.finished >= this.totalLEDs || true) {      progress = 1;      self.postMessage(JSON.stringify({        progress: Math.floor(progress * 10000) / 100,        lost: progress < 0.01 ? 0 : Math.round(this.lostEnergy / this.totalEnergy / progress * 10000) / 100,        data: this.data      }));    } else {      this.post();    }    return setTimeout((__bind(function() {      if (this.hasNext()) {        return this.next();      }    }, this)), 1);  }
}; self.addEventListener('message', function(e) {
if (e.data === "STOP") {    return self.cancel = true;  } else {    if (!self.started) {      self.started = true;      return self.Work["do"](JSON.parse(e.data));    } else {      throw new Exception(e);    }  }
}, false);
Retrieved from " http://2012.igem.org/Team:EPF-Lausanne/Modeling/bioreactorWorker.js "
Recent changes
What links here
Related changes
Special pages
My preferences
Printable version
Permanent link
Privacy policy
Disclaimers

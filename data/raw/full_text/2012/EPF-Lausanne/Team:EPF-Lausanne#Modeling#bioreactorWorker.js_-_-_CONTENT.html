<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_EPF-Lausanne_Modeling_bioreactorWorker_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:EPF-Lausanne/Modeling/bioreactorWorker.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:EPF-Lausanne/Modeling/bioreactorWorker.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:EPF-Lausanne/Modeling/bioreactorWorker.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:EPF-Lausanne/Modeling/bioreactorWorker.js&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:EPF-Lausanne/Modeling/bioreactorWorker.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:EPF-Lausanne/Modeling/bioreactorWorker.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2012.igem.org</H3><P>var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
self.cancel = false;
self.started = false;
self.Work = {
</P><PRE> rays: 0,
 totalRays: 0,
 lostEnergy: 0,
 totalEnergy: 0,
 totalLEDs: 0,
 finished: 0,
 lastProgress: -2000,
 data: [],
 workQueue: [],
 &quot;do&quot;: function(_arg) {
   var absorbance, angle, angleBias, angle_zero, attributedLights, c, directed, endAngle, i, j, leds, lightAngle, n, nLights, nRings, position, power, r, radius, rays, reflective, reflectiveAmount, remainingLeds, resolution, ringIncrement, rings, startAngle, totalCircumference, x, y, _ref, _ref2;
   radius = _arg.radius, power = _arg.power, reflective = _arg.reflective, reflectiveAmount = _arg.reflectiveAmount, absorbance = _arg.absorbance, directed = _arg.directed, lightAngle = _arg.lightAngle, rays = _arg.rays, resolution = _arg.resolution, nLights = _arg.nLights, nRings = _arg.nRings;
   this.data = [];
   for (x = 0; 0 &lt;= resolution ? x &lt; resolution : x &gt; resolution; 0 &lt;= resolution ? x++ : x--) {
     this.data[x] = [];
     for (y = 0; 0 &lt;= resolution ? y &lt; resolution : y &gt; resolution; 0 &lt;= resolution ? y++ : y--) {
       this.data[x][y] = Math.pow(x / resolution * 2 - 1, 2) + Math.pow(y / resolution * 2 - 1, 2) &lt;= 1 ? 0.0000000000001 : 0;
     }
   }
   if (!reflective) {
     reflectiveAmount = 0;
   }
   angle = lightAngle * Math.PI / 180;
   leds = [];
   angle_zero = [];
   if (nLights === 1) {
     leds.push([0, 0]);
     angle_zero.push(0);
   } else {
     ringIncrement = 1.0 / (nRings + 1);
     rings = [];
     totalCircumference = 0;
     for (i = 0; 0 &lt;= nRings ? i &lt; nRings : i &gt; nRings; 0 &lt;= nRings ? i++ : i--) {
       r = (i + 1) * ringIncrement;
       c = 2 * Math.PI * r;
       totalCircumference += c;
       rings.push({
         n: i,
         radius: r,
         circumference: c
       });
     }
     for (i = 0; 0 &lt;= nRings ? i &lt; nRings : i &gt; nRings; 0 &lt;= nRings ? i++ : i--) {
       rings[i].ratio = rings[i].circumference / totalCircumference;
     }
     remainingLeds = nLights;
     for (i = 0; 0 &lt;= nRings ? i &lt; nRings : i &gt; nRings; 0 &lt;= nRings ? i++ : i--) {
       attributedLights = Math.min(remainingLeds, Math.round(rings[i].ratio * nLights));
       if (i &gt;= nRings - 1) {
         attributedLights = remainingLeds;
       }
       rings[i].lights = attributedLights;
       remainingLeds -= attributedLights;
     }
     for (i = 0; 0 &lt;= nRings ? i &lt; nRings : i &gt; nRings; 0 &lt;= nRings ? i++ : i--) {
       angleBias = Math.PI / 5 * i;
       for (j = 0, _ref = rings[i].lights; 0 &lt;= _ref ? j &lt; _ref : j &gt; _ref; 0 &lt;= _ref ? j++ : j--) {
         leds.push([rings[i].radius * Math.cos(2 * Math.PI * j / rings[i].lights + angleBias), rings[i].radius * Math.sin(2 * Math.PI * j / rings[i].lights + angleBias)]);
         angle_zero.push(2 * Math.PI * j / rings[i].lights + Math.PI);
       }
     }
   }
   this.totalLEDs = nLights;
   this.totalRays = rays * nLights;
   this.totalSurface = resolution * resolution;
   this.totalEnergy = power;
   n = reflective ? 2 : 50;
   for (i = 0, _ref2 = leds.length; 0 &lt;= _ref2 ? i &lt; _ref2 : i &gt; _ref2; 0 &lt;= _ref2 ? i++ : i--) {
     position = leds[i];
     startAngle = directed ? -angle / 2 : 0;
     endAngle = directed ? angle / 2 : 2 * Math.PI;
     startAngle += angle_zero[i];
     endAngle += angle_zero[i];
     this.workQueue.push([position, startAngle, endAngle, 0, n, radius, power / nLights, reflective, reflectiveAmount, absorbance, directed, angle, rays, resolution]);
   }
   return this.start();
 },
 start: function() {
   if (!this.hasNext()) {
     return this.finish();
   } else {
     return this.next();
   }
 },
 hasNext: function() {
   return this.workQueue.length &gt; 0;
 },
 next: function() {
   if (this.hasNext()) {
     return this.calcRays.apply(this, this.workQueue.shift());
   }
 },
 calcRays: function(position, startAngle, endAngle, from, n, radius, power, reflective, reflectiveAmount, absorbance, directed, lightAngle, rays, resolution) {
   var angle, ray, reportStep, _ref;
   if (from &gt; rays || self.cancel) {
     return this.finish();
   } else {
     reportStep = Math.round(rays / 100);
     for (ray = from, _ref = Math.min(from + n, rays); from &lt;= _ref ? ray &lt; _ref : ray &gt; _ref; from &lt;= _ref ? ray++ : ray--) {
       this.rays++;
       angle = (endAngle - startAngle) * ray / rays + startAngle;
       this.calcRay(position, angle, radius, power, reflective, reflectiveAmount, absorbance, directed, lightAngle, rays, resolution);
       if (ray % reportStep === 0 || reportStep &lt;= 1) {
         this.post();
       }
     }
     return setTimeout((__bind(function() {
       return this.calcRays(position, startAngle, endAngle, from + n, n, radius, power, reflective, reflectiveAmount, absorbance, directed, lightAngle, rays, resolution);
     }, this)), 1);
   }
 },
 calcRay: function(position, angle, radius, power, reflective, reflectiveAmount, absorbance, directed, lightAngle, rays, resolution) {
   var absorbed, b_x, b_y, direction, dot, energy, length, normal_dir, pos, squaredLength, stepSize, transmitance_step, tx, ty, virtualStepSize, x, y;
   pos = [position[0], position[1]];
   direction = [Math.cos(angle), Math.sin(angle)];
   energy = power / rays;
   virtualStepSize = 0.00001;
   stepSize = radius * virtualStepSize;
   transmitance_step = Math.pow(10, -absorbance * 1000 * stepSize);
   while (energy &gt; 0.0000001) {
     squaredLength = pos[0] * pos[0] + pos[1] * pos[1];
     if (squaredLength &gt; 1) {
       length = Math.sqrt(squaredLength);
       normal_dir = [pos[0] / length, pos[1] / length];
       dot = -2 * (normal_dir[0] * direction[0] + normal_dir[1] * direction[1]);
       direction = [dot * normal_dir[0] + direction[0], dot * normal_dir[1] + direction[1]];
       this.lostEnergy += energy * (1 - reflectiveAmount);
       energy = energy * reflectiveAmount;
     }
     pos = [pos[0] + virtualStepSize * direction[0], pos[1] + virtualStepSize * direction[1]];
     absorbed = energy * (1 - transmitance_step);
     energy -= absorbed;
     x = (pos[0] + 1) / 2 * (resolution - 1);
     y = (pos[1] + 1) / 2 * (resolution - 1);
     x = Math.min(Math.max(0, x), resolution - 1);
     y = Math.min(Math.max(0, y), resolution - 1);
     b_x = Math.floor(x);
     b_y = Math.floor(y);
     tx = x - b_x;
     ty = y - b_y;
     this.data[b_x][b_y] += absorbed * (1 - tx) * (1 - ty);
     if (b_x &lt; resolution - 1) {
       this.data[b_x + 1][b_y] += absorbed * tx * (1 - ty);
     }
     if (b_y &lt; resolution - 1) {
       this.data[b_x][b_y + 1] += absorbed * (1 - tx) * ty;
     }
     if (b_x &lt; resolution - 1 &amp;&amp; b_y &lt; resolution - 1) {
       this.data[b_x + 1][b_y + 1] += absorbed * tx * ty;
     }
   }
 },
 post: function() {
   var progress;
   progress = this.rays / this.totalRays;
   if (progress &gt;= 1) {
     progress = 0.9999999;
   }
   if (progress - this.lastProgress &lt; 0.1 / 100) {
     return self.postMessage(JSON.stringify({
       progress: Math.floor(progress * 10000) / 100,
       lost: progress &lt; 0.01 ? 0 : Math.round(this.lostEnergy / this.totalEnergy / progress * 10000) / 100,
       data: void 0
     }));
   } else {
     self.postMessage(JSON.stringify({
       progress: Math.floor(progress * 10000) / 100,
       lost: progress &lt; 0.01 ? 0 : Math.round(this.lostEnergy / this.totalEnergy / progress * 10000) / 100,
       data: this.data
     }));
     return this.lastProgress = progress;
   }
 },
 finish: function() {
   var progress;
   this.finished++;
   if (this.finished &gt;= this.totalLEDs || true) {
     progress = 1;
     self.postMessage(JSON.stringify({
       progress: Math.floor(progress * 10000) / 100,
       lost: progress &lt; 0.01 ? 0 : Math.round(this.lostEnergy / this.totalEnergy / progress * 10000) / 100,
       data: this.data
     }));
   } else {
     this.post();
   }
   return setTimeout((__bind(function() {
     if (this.hasNext()) {
       return this.next();
     }
   }, this)), 1);
 }
</PRE><P>};
self.addEventListener('message', function(e) {
</P><PRE> if (e.data === &quot;STOP&quot;) {
   return self.cancel = true;
 } else {
   if (!self.started) {
     self.started = true;
     return self.Work[&quot;do&quot;](JSON.parse(e.data));
   } else {
     throw new Exception(e);
   }
 }
</PRE><P>}, false);
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2012.igem.org/Team:EPF-Lausanne/Modeling/bioreactorWorker.js">http://2012.igem.org/Team:EPF-Lausanne/Modeling/bioreactorWorker.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:EPF-Lausanne/Modeling/bioreactorWorker.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:EPF-Lausanne/Modeling/bioreactorWorker.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:EPF-Lausanne/Modeling/bioreactorWorker.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:EPF-Lausanne/Modeling/bioreactorWorker.js&amp;oldid=132420" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2012.igem.org:Privacy_policy" title="2012.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2012.igem.org:General_disclaimer" title="2012.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
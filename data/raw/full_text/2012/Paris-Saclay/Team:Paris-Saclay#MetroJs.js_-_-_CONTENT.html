<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Paris-Saclay_MetroJs_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:Paris-Saclay/MetroJs.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Paris-Saclay/MetroJs.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Paris-Saclay/MetroJs.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Paris-Saclay/MetroJs.js&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Paris-Saclay/MetroJs.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Paris-Saclay/MetroJs.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2012.igem.org</H3><P>/*
</P><UL><LI> Metro JS for jQuery
</LI><LI><A href="http://drewgreenwell.com/" class="external free" rel="nofollow">http://drewgreenwell.com/</A></LI><LI> For details and usage info see: <A href="http://drewgreenwell.com/projects/metrojs" class="external free" rel="nofollow">http://drewgreenwell.com/projects/metrojs</A></LI></UL><P>Copyright (C) 2012, Drew Greenwell
</P><P>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), 
to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
</P><P>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
</P><P>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</P><UL><LI>/
</LI></UL><P>$.fn.metrojs = {};
</P><P>/* Preload Images */
// Usage: $(['img1.jpg','img2.jpg']).metrojs.preloadImages(function(){ ... });
// Callback function gets called after all images are preloaded
$.fn.metrojs.preloadImages = function (callback) {
</P><PRE>   var checklist = $(this).toArray();
   var $img = $(&quot;&lt;img style='display:none;'&gt;&quot;).appendTo(&quot;body&quot;);
   $(this).each(function () {
       $img.attr({ src: this }).load(function () {
           var src = $(this).attr('src');
           for (var i = 0; i &lt; checklist.length; i++) {
               if (checklist[i] == element) { checklist.splice(i, 1); }
           }
           if (checklist.length == 0) { callback(); }
       });
   });
   $img.remove();
</PRE><P>};
</P><P>(function ($) {
</P><PRE>   $.fn.liveTile = function (method) {
       if (pubMethods[method]) {
           var args = [];
           for (var i = 1; i &lt;= arguments.length; i++) {
               args[i - 1] = arguments[i];
           }
           return pubMethods[method].apply(this, args);
       } else if (typeof method === 'object' || !method) {
           return pubMethods.init.apply(this, arguments);
       } else {
           $.error('Method ' + method + ' does not exist on jQuery.liveTile');
       }
   };
   $.fn.liveTile.State = {
       RUNNING: &quot;running&quot;,
       STOPPED: &quot;stopped&quot;
   };
   $.fn.liveTile.defaults = {
       mode: 'slide',                          // 'slide', 'flip', 'flip-list'
       speed: 500,                             // how fast should animations be performed, in milliseconds
       initDelay: -1,                          // how long to wait before the initial animation
       delay: 5000,                            // how long to wait between animations 
       stops: &quot;100%&quot;,                          // how much of the back tile should 'slide' reveal before starting a delay
       stack: false,                           // should tiles in slide mode appear stacked (e.g Me tile) 
       direction: 'vertical',                  // which direction should animations be performed(horizontal | vertical)
       tileCssSelector: '&gt;div,&gt;li',            // The selector used by slide, flip, and flip-list mode to choose the front and back containers
       listTileCssSelector: '&gt;div,&gt;p,&gt;img,&gt;a', // The selector used by flip-tile mode to choose the front and back containers.2
       imageCssSelector: '&gt;img,&gt;a&gt;img',        // the selector used to choose a an image to apply a src or background to
       ignoreDataAttributes: false,            // should data attributes be ignored
       pauseOnHover: false,                    // should tile animations be paused on hover in and restarted on hover out
       repeatCount: -1,                        // number of times to repeat the animation
       animationComplete: function (tileData, $front, $back) {
       },
       preloadImages: false,                   // should the images arrays be preloaded
       fadeSlideSwap: false,                   // fade any image swaps on slides (e.g. mode: 'slide', stops:'50%', frontImages: ['img1.jpg', 'img2.jpg'])
       appendBack: true,                       // appends the .last tile if one doesnt exist (slide and flip only)
       triggerDelay: function (idx) {          // used by flip-list to decide how random the tile flipping should be
           return Math.random() * 3000;
       },
       alwaysTrigger: false,                   // used by flip-list to decide if all tiles are triggered every time
       frontImages: null,                      // a list of images to use for the front
       frontIsRandom: true,                    // should images be chosen at random or in order
       frontIsBackgroundImage: false,          // set the src attribute or css background-image property
       frontIsInGrid: false,                   // only chooses one item for each iteration in flip-list
       backImages: null,                       // a list of images to use for the back
       backIsRandom: true,                     // should images be chosen at random or in order
       backIsBackgroundImage: false,           // set the src attribute or css background-image property
       backIsInInGrid: false,                  // only chooses one item for each iteration in flip-list
       flipListOnHover: false,                 // should items in flip-list flip and stop when hovered
       useModernizr: (typeof (window.Modernizr) != &quot;undefined&quot;), // checks to see if modernizer is already in use
       useHardwareAccel: true,                 // should css animations, transitions and transforms be used when available
       $front: null,                           // the jQuery element to use as the front face of the tile; this will bypass tileCssSelector
       $back: null,                            // the jQuery element to use as the back face of the tile; this will bypass tileCssSelector
   };
</PRE><PRE>   var privMethods = {
       //a shuffle method to provide more randomness than sort
       //credit: <A href="http://javascript.about.com/library/blshuffle.htm" class="external free" rel="nofollow">http://javascript.about.com/library/blshuffle.htm</A>
       //*avoiding prototype for sharepoint compatability
       shuffleArray: function (array) {
           var s = [];
           while (array.length) s.push(array.splice(Math.random() * array.length, 1));
           while (s.length) array.push(s.pop());
           return array;
       },
       setTimer: function (func, interval) {
           return setInterval(func, interval);
       },
       stopTimer: function (handle) {
           clearInterval(handle);
           return null;
       },
       setExtraProperties: function ($ele, imageObj) {
           if (typeof (imageObj.alt) != &quot;undefined&quot;)
               $ele.attr(&quot;alt&quot;, imageObj.alt);
           var $parent = $ele.parent();
           if (typeof (imageObj.href) != &quot;undefined&quot; &amp;&amp; $parent[0].tagName == &quot;A&quot;) {
               $parent.attr(&quot;href&quot;, imageObj.href);
               if (typeof (imageObj.target) != &quot;undefined&quot;)
                   $parent.attr(&quot;target&quot;, imageObj.target);
               if (typeof (imageObj.onclick) != &quot;undefined&quot;) {
                   $parent.attr(&quot;onclick&quot;, imageObj.onclick);
                   $ele.attr(&quot;onclick&quot;, &quot;&quot;);
               }
           } else {
               if (typeof (imageObj.onclick) != &quot;undefined&quot;)
                   $ele.attr(&quot;onclick&quot;, imageObj.onclick);
           }
       },
       // changes the src or background image property of an image in a flip-list
       handleListItemSwap: function ($cont, image, isBgroundImg, stgs) {
           var $img = $cont.find(stgs.imageCssSelector);
           if (!isBgroundImg) {
               $img.attr(&quot;src&quot;, image.src);
           } else {
               $img.css({ backgroundImage: &quot;url('&quot; + image.src + &quot;')&quot; });
           }
           privMethods.setExtraProperties($img, image);
       },
       handleSlide: function (isSlidingUp, $cont, swapFrontSource, stgs, index) {
           if (!isSlidingUp &amp;&amp; swapFrontSource) {
               var image;
               var $img = $cont.find(stgs.imageCssSelector);
               image = stgs.frontImages[index];
               if (stgs.fadeSlideSwap == true) {
                   $img.fadeOut(function () {
                       $img.attr(&quot;src&quot;, image.src);
                       privMethods.setExtraProperties($img, image);
                       $img.fadeIn();
                   });
               } else {
                   $img.attr(&quot;src&quot;, image.src);
                   privMethods.setExtraProperties($img, image);
               }
           }
</PRE><PRE>       },
       // fired if an image swap is needed. gets the image and applies properties
       handleSwap: function ($cont, isFront, stgs, index) {
           var image = privMethods.getImage(isFront, stgs, index);
           var $img = $cont.find(stgs.imageCssSelector);
           $img.attr(&quot;src&quot;, image.src);
           privMethods.setExtraProperties($img, image);
       },
       // get an image from the frontImages or backImages array
       getImage: function (isFront, stgs, index) {
           var imgs = (isFront) ? stgs.frontImages : stgs.backImages;
           var image;
           image = imgs[Math.min(index, imgs.length - 1)];
           return image;
       }
   };
   var pubMethods = {
       init: function (options) {
           // Setup the public options for the livetile
           var stgs = {};
           $.extend(stgs, $.fn.liveTile.defaults, options);
</PRE><PRE>           //is there at least one item in the front images list?
           var swapFrontSource = (typeof (stgs.frontImages) == 'object' &amp;&amp; (stgs.frontImages instanceof Array) &amp;&amp; stgs.frontImages.length &gt; 0);
           //is there at least one item in the back images list?
           var swapBackSource = (typeof (stgs.backImages) == 'object' &amp;&amp; (stgs.backImages instanceof Array) &amp;&amp; stgs.backImages.length &gt; 0);
           var canTransform = false;
           var canTransition = false;
           var canTransform3d = false;
           var canAnimate = false;
           var canFlip3d = stgs.useHardwareAccel;
           if (stgs.useHardwareAccel == true) {
               if (stgs.useModernizr == false) {
                   //determine if the browser supports the neccessary accelerated features
                   if (typeof (window.MetroModernizr) != &quot;undefined&quot;) {
                       canTransform = window.MetroModernizr.canTransform;
                       canTransition = window.MetroModernizr.canTransition;
                       canTransform3d = window.MetroModernizr.canTransform3d;
                       canAnimate = window.MetroModernizr.canAnimate;
                   } else {
                       window.MetroModernizr = {};
                       /***** check for browser capabilities credit: modernizr-1.7 *****/
                       var mod = 'metromodernizr';
                       var docElement = document.documentElement;
                       var docHead = document.head || document.getElementsByTagName('head')[0];
                       var modElem = document.createElement(mod);
                       var m_style = modElem.style;
                       var prefixes = ' -webkit- -moz- -o- -ms- -khtml- '.split(' ');
                       var domPrefixes = 'Webkit Moz O ms Khtml'.split(' ');
                       var test_props = function (props, callback) {
                           for (var i in props) {
                               if (m_style[props[i]] !== undefined &amp;&amp; (!callback || callback(props[i], modElem))) {
                                   return true;
                               }
                           }
                       };
                       var test_props_all = function (prop, callback) {
</PRE><PRE>                           var uc_prop = prop.charAt(0).toUpperCase() + prop.substr(1),
</PRE><P>							props = (prop + ' ' + domPrefixes.join(uc_prop + ' ') + uc_prop).split(' ');
</P><PRE>                           return !!test_props(props, callback);
                       };
                       var test_3d = function () {
                           var ret = !!test_props(['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective']);
                           if (ret &amp;&amp; 'webkitPerspective' in docElement.style) {
                               // Webkit allows this media query to succeed only if the feature is enabled.    
                               // '@media (transform-3d),(-o-transform-3d),(-moz-transform-3d),(-ms-transform-3d),(-webkit-transform-3d),(modernizr){ ... }'
                               ret = testMediaQuery('@media (' + prefixes.join('transform-3d),(') + 'metromodernizr)');
                           }
                           return ret;
                       };
                       var testMediaQuery = function (mq) {
                           var st = document.createElement('style'),
</PRE><P>						div = document.createElement('div'),
						ret;
</P><PRE>                           st.textContent = mq + '{#metromodernizr{height:3px}}';
                           docHead.appendChild(st);
                           div.id = 'metromodernizr';
                           docElement.appendChild(div);
                           ret = div.offsetHeight === 3;
                           st.parentNode.removeChild(st);
                           div.parentNode.removeChild(div);
                           return !!ret;
                       };
                       canTransform = !!test_props(['transformProperty', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform']);
                       canTransition = test_props_all('transitionProperty');
                       canTransform3d = test_3d();
                       canAnimate = test_props_all('animationName');
                       window.MetroModernizr.canTransform = canTransform;
                       window.MetroModernizr.canTransition = canTransition;
                       window.MetroModernizr.canTransform3d = canTransform3d;
                       window.MetroModernizr.canAnimate = canAnimate;
                       docElement = null;
                       docHead = null;
                       modElem = null;
                       m_style = null;
                   }
               } else {
                   canTransform = $(&quot;html&quot;).hasClass(&quot;csstransforms&quot;);
                   canTransition = $(&quot;html&quot;).hasClass(&quot;csstransitions&quot;);
                   canTransform3d = $(&quot;html&quot;).hasClass(&quot;csstransforms3d&quot;);
                   canAnimate = $(&quot;html&quot;).hasClass(&quot;cssanimations&quot;);
               }
           }
           canFlip3d = canFlip3d &amp;&amp; canAnimate &amp;&amp; canTransform &amp;&amp; canTransform3d;
           /****** end capabilities check ******/
           if (stgs.preloadImages) {
               if (swapFrontSource)
                   $(stgs.frontImages).metrojs.preloadImages(function () { });
               if (swapBackSource)
                   $(stgs.backImages).metrojs.preloadImages(function () { });
           }
           return $(this).each(function (tileIndex) {
               var $this = $(this);
               $this.slideTimer = null;
               var tdata = {}; //an object to store settings for later access
               tdata.state = $this.slideTimer == null ? $.fn.liveTile.State.STOPPED : $.fn.liveTile.State.RUNNING;
               tdata.speed = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($this.data(&quot;speed&quot;)) != &quot;undefined&quot;) ? $this.data(&quot;speed&quot;) : stgs.speed;
               tdata.delay = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($this.data(&quot;delay&quot;)) != &quot;undefined&quot;) ? $this.data(&quot;delay&quot;) : stgs.delay;
               if (tdata.delay &lt; -1)
                   tdata.delay = stgs.triggerDelay(tileIndex);
               else if (tdata.delay &lt; 0)
                   tdata.delay = 3500 + (Math.random() * 4501);
               tdata.stops = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($this.data(&quot;stops&quot;)) != &quot;undefined&quot;) ? $this.data(&quot;stops&quot;) : stgs.stops;
               tdata.stack = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($this.data(&quot;stack&quot;)) != &quot;undefined&quot;) ? $this.data(&quot;stack&quot;) : stgs.mode;
               tdata.mode = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($this.data(&quot;mode&quot;)) != &quot;undefined&quot;) ? $this.data(&quot;mode&quot;) : stgs.mode;
               tdata.direction = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($this.data(&quot;direction&quot;)) != &quot;undefined&quot;) ? $this.data(&quot;direction&quot;) : stgs.direction;
               tdata.useHwAccel = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($this.data(&quot;ha&quot;)) != &quot;undefined&quot;) ? $this.data(&quot;ha&quot;) : stgs.useHardwareAccel;
               tdata.initDelay = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($this.data(&quot;initdelay&quot;)) != &quot;undefined&quot;) ? $this.data(&quot;initdelay&quot;) : (stgs.initDelay &lt; 0) ? tdata.delay : stgs.initDelay;
               tdata.repeatCount = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($this.data(&quot;repeat&quot;)) != &quot;undefined&quot;) ? $this.data(&quot;repeat&quot;) : stgs.repeatCount;
               tdata.hasRun = false; // init delay flag
               tdata.loopCount = 0;
               tdata.slideIndex = 0;
               //convert stops if needed
               tdata.stops = (typeof (stgs.stops) == 'object' &amp;&amp; (stgs.stops instanceof Array)) ? stgs.stops : (<I> + tdata.stops).split(',');</I>
               //add the mode to the tile if it's not already there.
               $this.addClass(tdata.mode);
               var $tileContainer = $this.find(stgs.tileCssSelector);
               var $firstContainer = null;
               if(stgs.$front != null &amp;&amp; stgs.$front.length &gt; 0){
                   $firstContainer = (tdata.mode == &quot;flip-list&quot;) ? null : (tdata.mode == 'slide') ?
</PRE><P>									    stgs.$front.addClass('slide-front') :
									    stgs.$front.addClass('flip-front');
</P><PRE>               }else{
                   $firstContainer = (tdata.mode == &quot;flip-list&quot;) ? null : (tdata.mode == 'slide') ?
</PRE><P>									    $tileContainer.first().addClass('slide-front') :
									    $tileContainer.first().addClass('flip-front');
</P><PRE>               }
               var lClass = (tdata.mode == 'slide') ? 'slide-back' : 'flip-back';
               var $scndContainer = null;
               if(stgs.$back != null &amp;&amp; stgs.$back.length &gt; 0){
                   $scndContainer = (tdata.mode == &quot;flip-list&quot;) ? null : stgs.$back.addClass(lClass);								
               }else{
               $scndContainer = (tdata.mode == &quot;flip-list&quot;) ? null : ($tileContainer.length &gt; 1) ?
</PRE><P>								$tileContainer.last().addClass(lClass) :
								(stgs.appendBack == true) ?
</P>
								$('').appendTo($this) :
								$('');
<PRE>               }
               var height = $this.height();
               var width = $this.width();
               var margin = (tdata.direction == &quot;vertical&quot;) ? height / 2 : width / 2;
               var isReversed = false;
               
               var staticCount = 0;
               var staticIndexBack = 0;
               var staticIndexFront = 0;
               var doAnimations = false;
               var flistData = []; // an array to cache flip list selectors
               var frontRandomBag = [];
               var prevFrontIndex = -1;
               var backRandomBag = [];
               var prevBackIndex = -1;
               /* Mouse over and out functions*/
</PRE><PRE>               if (stgs.pauseOnHover) {
                   $this.find(stgs.tileCssSelector).hover(
</PRE><P>					function () {
					    tdata.stopTimer(false);
					},
					function () {
					    tdata.setTimer();
					});
</P><PRE>               }
               // prep tiles
               if (tdata.mode == 'flip-list') {
                   $this.find(stgs.tileCssSelector).each(function () {
                       var $li = $(this);
                       var $front = stgs.$front != null ? stgs.$front : $li.find(stgs.listTileCssSelector).first().addClass(&quot;flip-front&quot;);
                       if ($li.find(stgs.listTileCssSelector).length == 1 &amp;&amp; stgs.appendBack == true) {
</PRE>
                            $li.append(&quot;&quot;);
<PRE>                       }
                       var $back = stgs.$back != null ? stgs.$back : $li.find(stgs.listTileCssSelector).last().addClass(&quot;flip-back&quot;).css({ marginTop: &quot;0px&quot; });
                       if (canFlip3d &amp;&amp; tdata.useHwAccel) {
                           $li.addClass(&quot;ha&quot;);
                           $front.addClass(&quot;ha&quot;).data(&quot;tile&quot;, { animating: false });
                           $back.addClass(&quot;ha&quot;).data(&quot;tile&quot;, { animating: false });
                           if (stgs.flipListOnHover == true) {
                               $front.bind(&quot;mouseout.liveTile&quot;, null, function () {
                                   $this.flipListItem(false, $li, $back, $front);
                               });
                               $back.bind(&quot;mouseout.liveTile&quot;, null, function () {
                                   $this.flipListItem(true, $li, $front, $back);
                               });
                           }
                       } else {
                           if (stgs.flipListOnHover == true) {
                               $front.bind(&quot;mouseout.liveTile&quot;, function () {
                                   $this.flipListItem(true, $li, $front, $back);
                               });
                               $back.bind(&quot;mouseout.liveTile&quot;, function () {
                                   $this.flipListItem(false, $li, $back, $front);
                               });
                           }
                       }
                   });
               } else if (tdata.mode == 'slide') {
                   if (tdata.stack == true) {
                       if (tdata.direction == &quot;vertical&quot;) {
                           $scndContainer.css({ top: -height + 'px' });
                       } else {
                           $scndContainer.css({ left: -width + 'px' });
                       }
                   }
                   if (canTransition &amp;&amp; tdata.useHwAccel) {
                       $this.addClass(&quot;ha&quot;);
                       $firstContainer.addClass(&quot;ha&quot;).data(&quot;tile&quot;, { animating: false });
                   }
               } else if (tdata.mode == 'flip') {
                   if (canFlip3d &amp;&amp; tdata.useHwAccel) {
                       $this.addClass(&quot;ha&quot;);
                       $firstContainer.addClass(&quot;ha&quot;).data(&quot;tile&quot;, { animating: false });
                       $scndContainer.addClass(&quot;ha&quot;).data(&quot;tile&quot;, { animating: false });
                   } else {
                       var fCss = (tdata.direction == &quot;vertical&quot;) ?
</PRE><P>							   { height: '0px', width: width + 'px', marginTop: margin + 'px', opacity: '0'} :
							   { height: '100%', width: '0px !important', marginLeft: margin + 'px', opacity: '0' };
</P><PRE>                       var fCss2 = (tdata.direction == &quot;vertical&quot;) ?
</PRE><P>								{ height: '100%', width: '100%', marginTop: '0px', opacity: '1'} :
								{ height: '100%', width: '100%', marginLeft: '0px', opacity: '1' };
</P><PRE>                       $scndContainer.css(fCss);
                       $firstContainer.css(fCss2);
                       //temp fix                       
                       // TODO: debug and remove instances of $.browser for compatibility with jq 1.8+
                       if (tdata.repeatCount &gt; -1 &amp;&amp; $.browser.msie) {
                           tdata.repeatCount += 1;
                       }
                       //                        if (tdata.direction == &quot;horizontal&quot;)
                       //                            $scndContainer.css({ marginLeft: $scndContainer.width() / 2 + 'px', width: '0px' });
                       //                        else
                       //                            $scndContainer.css({ marginTop: $scndContainer.height() / 2 + 'px', height: '0px' });
                   }
               }
</PRE><PRE>               //slide animation
               $this.slide = function (callback) {
                   if (typeof (callback) == &quot;undefined&quot; || callback == null)
                       callback = null;
                   if (tdata.repeatCount &gt; -1) {
                       if (tdata.loopCount&gt; tdata.repeatCount) {
                           tdata.stopTimer(false);
                           tdata.loopCount = 0;
                           tdata.hasRun = false;
                           $this.data(&quot;LiveTile&quot;, tdata);
                           return;
                       }
                   }
                   if (!doAnimations)
                       return;
                   var clojIsReversed = isReversed;
                   var fData = $firstContainer.data(&quot;tile&quot;);
                   var stop = $.trim(tdata.stops[tdata.slideIndex]);
                   var pxIdx = stop.indexOf('px');
                   var offset = 0;
                   var amount = 0
                   var metric = (tdata.direction == &quot;vertical&quot;) ? height : width;
                   var prop = (tdata.direction == &quot;vertical&quot;) ? &quot;top&quot; : &quot;left&quot;;
                   if (pxIdx &gt; 0) {
                       amount = parseInt(stop.substring(0, pxIdx));
                       offset = (amount - metric) + 'px';
                   } else {
                       //is a percentage
                       amount = parseInt(stop.replace('%', <I>));</I>
                       offset = (amount - 100) + '%';
                   }
                   if (canTransition &amp;&amp; tdata.useHwAccel) {
                       if (typeof (fData.animated) != &quot;undefined&quot; &amp;&amp; fData.animated == true)
                           return;
                       fData.animated = true;
                       var css = {
                           WebkitTransitionProperty: prop, WebkitTransitionDuration: tdata.speed + 'ms',
                           MozTransitionProperty: prop, MozTransitionDuration: tdata.speed + 'ms',
                           OTransitionProperty: prop, OTransitionDuration: tdata.speed + 'ms',
                           msTransitionProperty: prop, msTransitionDuration: tdata.speed + 'ms',
                           KhtmlTransitionProperty: prop, KhtmlTransitionDuration: tdata.speed + 'ms',
                           TransitionProperty: prop, TransitionDuration: tdata.speed + 'ms'
                       };
                       if (tdata.direction == &quot;vertical&quot;) {
                           css.top = (clojIsReversed &amp;&amp; tdata.stops.length == 1) ? &quot;0px&quot; : stop;
                       } else {
                           css.left = (clojIsReversed &amp;&amp; tdata.stops.length == 1) ? &quot;0px&quot; : stop;
                       }
                       $firstContainer.css(css);
                       if (tdata.stack == true) {
                           if (tdata.direction == &quot;vertical&quot;) {
                               css.top = (clojIsReversed &amp;&amp; tdata.stops.length == 1) ? -metric + 'px' : offset;
                           } else {
                               css.left = (clojIsReversed &amp;&amp; tdata.stops.length == 1) ? -metric + 'px' : offset;
                           }
                           $scndContainer.css(css);
                       }
                       window.setTimeout(function () {
                           var index = staticCount;
                           if (swapFrontSource &amp;&amp; stgs.frontIsRandom) {
                               //make sure the random bag is ready
                               if (frontRandomBag.length == 0) {
                                   for (var i = 0; i &lt; stgs.frontImages.length; i++) {
                                       //make sure there's not an immediate repeat
                                       if (i != prevBackIndex || stgs.frontImages.length == 1)
                                           frontRandomBag[i] = i;
                                   }
                                   frontRandomBag = privMethods.shuffleArray(frontRandomBag);
                               }
                               index = frontRandomBag.pop();
                               prevFrontIndex = index;
                           }
                           privMethods.handleSlide(clojIsReversed, $firstContainer, swapFrontSource, stgs, index);
                           fData.animated = false;
                           $firstContainer.data(&quot;tile&quot;, fData);
                           if (!clojIsReversed &amp;&amp; swapFrontSource) {
                               staticCount += 1;
                               if (staticCount &gt;= stgs.frontImages.length)
                                   staticCount = 0;
                           }
                           stgs.animationComplete(tdata, $firstContainer, $scndContainer);
                           if (callback != null)
                               callback();
                       }, tdata.speed);
                   } else {
                       if ($firstContainer.is(':animated')) {
                           return;
                       }
                       var uCss = (tdata.direction == &quot;vertical&quot;) ?
</PRE><P>									{ top: (clojIsReversed &amp;&amp; tdata.stops.length == 1) ? &quot;0px&quot; : stop} :
									{ left: (clojIsReversed &amp;&amp; tdata.stops.length == 1) ? &quot;0px&quot; : stop };
</P><PRE>                       var dCss = (tdata.direction == &quot;vertical&quot;) ?
</PRE><P>									{ top: (clojIsReversed &amp;&amp; tdata.stops.length == 1) ? -metric + 'px' : offset} :
									{ left: (clojIsReversed &amp;&amp; tdata.stops.length == 1) ? -metric + 'px' : offset };
</P><PRE>                       $firstContainer.animate(uCss, tdata.speed, function () {
                           var index = staticCount;
                           if (swapFrontSource &amp;&amp; stgs.frontIsRandom) {
                               //make sure the random bag is ready
                               if (frontRandomBag.length == 0) {
                                   for (var i = 0; i &lt; stgs.frontImages.length; i++) {
                                       //make sure there's not an immediate repeat
                                       if (i != prevBackIndex || stgs.frontImages.length == 1)
                                           frontRandomBag[i] = i;
                                   }
                                   frontRandomBag = privMethods.shuffleArray(frontRandomBag);
                               }
                               index = frontRandomBag.pop();
                               prevFrontIndex = index;
                           }
                           privMethods.handleSlide(clojIsReversed, $firstContainer, swapFrontSource, stgs, index);
                           if (!clojIsReversed &amp;&amp; swapFrontSource) {
                               staticCount += 1;
                               if (staticCount &gt;= stgs.frontImages.length)
                                   staticCount = 0;
                           }
                           stgs.animationComplete(tdata, $firstContainer, $scndContainer);
                           if (callback != null)
                               callback();
                       });
                       if (tdata.stack == true) {
                           $scndContainer.animate(dCss, tdata.speed, function () { });
                       }
                   }
                   //increment slide count
                   tdata.slideIndex += 1;
                   if (tdata.slideIndex &gt;= tdata.stops.length) {
                       tdata.slideIndex = 0;
                       isReversed = !isReversed;
                       tdata.loopCount += 1;
                   }
               };
</PRE><PRE>               //flip mode
               $this.flip = function (callback) {
                   if (typeof (callback) == &quot;undefined&quot; || callback == null)
                       callback = null;
                   if (tdata.repeatCount &gt; -1) {
                       if (tdata.loopCount &gt; tdata.repeatCount) {
                           tdata.stopTimer(false);
                           tdata.loopCount = 0;
                           // TODO: debug and remove instances of $.browser for compatibility with jq 1.8+
                           if ($.browser.msie) /* straighten out issue with loopcount in IE */
                               tdata.loopCount += 1;
                           tdata.hasRun = false;
                           $this.data(&quot;LiveTile&quot;, tdata);
                           return;
                       } else {
                           tdata.loopCount += 1;
                       }
                   }
                   if (canFlip3d &amp;&amp; tdata.useHwAccel) {
                       var spd = (tdata.speed * 2); // accelerated flip speeds are calculated on 1/2 rotation rather than 1/4 rotation like jQuery animate
                       var duration = spd + 'ms';
                       var aniFName = (tdata.direction == &quot;vertical&quot;) ? 'flipfront180' : 'flipfrontY180';
                       var aniBName = (tdata.direction == &quot;vertical&quot;) ? 'flipback180' : 'flipbackY180';
                       var data = $firstContainer.data(&quot;tile&quot;);
                       if (typeof (data.animated) != &quot;undefined&quot; &amp;&amp; data.animated == true) {
                           return;
                       }
                       data.animated = true;
                       if (doAnimations) {
                           if (isReversed) {
                               var uCss = {
                                   WebkitAnimationPlayState: 'running', WebkitAnimationName: aniBName, WebkitAnimationDuration: duration,
                                   MozAnimationPlayState: 'running', MozAnimationName: aniBName, MozAnimationDuration: duration,
                                   OAnimationPlayState: 'running', OAnimationName: aniBName, OAnimationDuration: duration,
                                   msAnimationPlayState: 'running', msAnimationName: aniBName, msAnimationDuration: duration,
                                   AnimationPlayState: 'running', AnimationName: aniBName, AnimationDuration: duration
                               };
                               $firstContainer.css(uCss).data(&quot;tile&quot;, data);
                               uCss.WebkitAnimationName = aniFName;
                               uCss.MozAnimationName = aniFName;
                               uCss.msAnimationName = aniFName;
                               uCss.OAnimationName = aniFName;
                               uCss.AnimationName = aniFName;
                               $scndContainer.css(uCss).data(&quot;tile&quot;, data);
                               window.setTimeout(function () {
                                   if (swapBackSource) { // change the source image when the animation is finished
                                       var isRandom = stgs.backIsRandom;
                                       var index = staticIndexBack;
                                       if (isRandom) {
                                           //make sure the random bag is ready
                                           if (backRandomBag.length == 0) {
                                               for (var i = 0; i &lt; stgs.backImages.length; i++) {
                                                   //make sure there's not an immediate repeat
                                                   if (i != prevBackIndex || stgs.backImages.length == 1)
                                                       backRandomBag[i] = i;
                                               }
                                               backRandomBag = privMethods.shuffleArray(backRandomBag);
                                           }
                                           index = backRandomBag.pop();
                                           prevBackIndex = index;
                                       }
                                       privMethods.handleSwap($scndContainer, false, stgs, index);
                                       staticIndexBack += 1;
                                       if (staticIndexBack &gt;= stgs.backImages.length) {
                                           staticIndexBack = 0;
                                       }
                                   }
                                   stgs.animationComplete(tdata, $firstContainer, $scndContainer);
                                   if (callback != null)
                                       callback();
                                   data.animated = false;
                                   $firstContainer.data(&quot;tile&quot;, data);
                                   $scndContainer.data(&quot;tile&quot;, data);
                               }, spd);
                           } else {
                               var dCss = { WebkitAnimationPlayState: 'running', WebkitAnimationName: aniFName, WebkitAnimationDuration: duration,
                                   MozAnimationPlayState: 'running', MozAnimationName: aniFName, MozAnimationDuration: duration,
                                   OAnimationPlayState: 'running', OAnimationName: aniFName, OAnimationDuration: duration,
                                   msAnimationPlayState: 'running', msAnimationName: aniFName, msAnimationDuration: duration,
                                   AnimationPlayState: 'running', AnimationName: aniFName, AnimationDuration: duration
                               };
                               $firstContainer.css(dCss).data(&quot;tile&quot;, data);
                               dCss.WebkitAnimationName = aniBName;
                               dCss.MozAnimationName = aniBName;
                               dCss.msAnimationName = aniBName;
                               dCss.OAnimationName = aniBName;
                               dCss.AnimationName = aniBName;
                               $scndContainer.css(dCss).data(&quot;tile&quot;, data);
                               window.setTimeout(function () {
                                   if (swapFrontSource) {
                                       // change the source image when the animation is finished
                                       var isRandom = stgs.frontIsRandom;
                                       var index = staticIndexFront;
                                       if (isRandom) {
                                           //make sure the random bag is ready
                                           if (frontRandomBag.length == 0) {
                                               for (var i = 0; i &lt; stgs.frontImages.length; i++) {
                                                   //make sure there's not an immediate repeat
                                                   if (i != prevBackIndex || stgs.frontImages.length == 1)
                                                       frontRandomBag[i] = i;
                                               }
                                               frontRandomBag = privMethods.shuffleArray(frontRandomBag);
                                           }
                                           index = frontRandomBag.pop();
                                           prevFrontIndex = index;
                                       }
                                       privMethods.handleSwap($firstContainer, true, stgs, index);
                                       staticIndexFront += 1;
                                       if (staticIndexFront &gt;= stgs.frontImages.length) {
                                           staticIndexFront = 0;
                                       }
                                   }
                                   stgs.animationComplete(tdata, $scndContainer, $firstContainer);
                                   if (callback != null) {
                                       callback();
                                   }
                                   data.animated = false;
                                   $firstContainer.data(&quot;tile&quot;, data);
                                   $scndContainer.data(&quot;tile&quot;, data);
                               }, spd);
                           }
                       }
                       //an interval isnt needed
                       isReversed = !isReversed;
                   } else {
</PRE><PRE>                       //crossbrowser single tile flip illusion (works best with images)
                       if (isReversed) {
                           var upCss = (tdata.direction == &quot;vertical&quot;) ?
</PRE><P>							   { height: '0px', width: '100%', marginTop: margin + 'px', opacity: '0'} :
							   { height: '100%', width: '0px', marginLeft: margin + 'px', opacity: '0' };
</P><PRE>                           var upCss2 = (tdata.direction == &quot;vertical&quot;) ?
</PRE><P>								{ height: '100%', width: '100%', marginTop: '0px', opacity: '1'} :
								{ height: '100%', width: '100%', marginLeft: '0px', opacity: '1' };
</P><PRE>                           $firstContainer.stop().animate(upCss, { duration: tdata.speed });
                           window.setTimeout(function () {
                               $scndContainer.stop().animate(upCss2, { duration: tdata.speed });
                               if (swapFrontSource) {
                                   var isRandom = stgs.frontIsRandom;
                                   var index = staticIndexFront;
                                   if (isRandom) {
                                       //make sure the random bag is ready
                                       if (frontRandomBag.length == 0) {
                                           for (var i = 0; i &lt; stgs.frontImages.length; i++) {
                                               //make sure there's not an immediate repeat
                                               if (i != prevFrontIndex || stgs.frontImages.length == 1)
                                                   frontRandomBag[i] = i;
                                           }
                                           frontRandomBag = privMethods.shuffleArray(frontRandomBag);
                                       }
                                       index = frontRandomBag.pop();
                                       prevFrontIndex = index;
                                   }
                                   privMethods.handleSwap($firstContainer, true, stgs, index);
                                   staticIndexFront += 1;
                                   if (staticIndexFront &gt;= stgs.frontImages.length) {
                                       staticIndexFront = 0;
                                   }
                               }
                               isReversed = !isReversed;
                               stgs.animationComplete(tdata, $scndContainer, $firstContainer);
                               if (callback != null)
                                   callback();
                           }, tdata.speed);
                       } else {
                           var dwnCss = (tdata.direction == &quot;vertical&quot;) ?
</PRE><P>							   { height: '0px', width: '100%', marginTop: margin + 'px', opacity: '0'} :
							   { height: '100%', width: '0px', marginLeft: margin + 'px', opacity: '0' };
</P><PRE>                           var dwnCss2 = (tdata.direction == &quot;vertical&quot;) ?
</PRE><P>								{ height: '100%', width: '100%', marginTop: '0px', opacity: '1'} :
								{ height: '100%', width: '100%', marginLeft: '0px', opacity: '1' };
</P><PRE>                           $scndContainer.stop().animate(dwnCss, { duration: tdata.speed });
                           window.setTimeout(function () {
                               $firstContainer.stop().animate(dwnCss2, { duration: tdata.speed });
                               if (swapBackSource) {
                                   var isRandom = stgs.backIsRandom;
                                   var index = staticIndexBack;
                                   if (isRandom) {
                                       //make sure the random bag is ready
                                       if (backRandomBag.length == 0) {
                                           for (var i = 0; i &lt; stgs.backImages.length; i++) {
                                               //make sure there's not an immediate repeat
                                               if (i != prevBackIndex || stgs.backImages.length == 1)
                                                   backRandomBag[i] = i;
                                           }
                                           backRandomBag = privMethods.shuffleArray(backRandomBag);
                                       }
                                       index = backRandomBag.pop();
                                       prevBackIndex = index;
                                   }
                                   privMethods.handleSwap($scndContainer, false, stgs, index);
                                   staticIndexBack += 1;
                                   if (staticIndexBack &gt;= stgs.backImages.length) {
                                       staticIndexBack = 0;
                                   }
                               }
                               isReversed = !isReversed;
                               stgs.animationComplete(tdata, $firstContainer, $scndContainer);
                               if (callback != null)
                                   callback();
                           }, tdata.speed);
                       }
                   }
               };
               // flip arbitrary number of items and swap sources accordingly
               $this.flipList = function (callback) {
                   if (typeof (callback) == &quot;undefined&quot; || callback == null)
                       callback = null;
                   if (tdata.repeatCount &gt; -1) {
                       if (tdata.loopCount &gt; tdata.repeatCount) {
                           tdata.stopTimer(false);
                           tdata.loopCount = 0;
                           tdata.hasRun = false;
                           $this.data(&quot;LiveTile&quot;, tdata);
                           return;
                       } else {
                           tdata.loopCount += 1;
                       }
                   }
                   var fBag = [];  // two bags to make sure we don't duplicate images
                   var bBag = [];
                   var $tiles = $this.find(stgs.tileCssSelector);
                   //in case we want to pick one image per loop
                   var fStaticRndm = 0;
                   if (swapFrontSource) {
                       if (frontRandomBag.length == 0) {
                           for (var i = 0; i &lt; stgs.frontImages.length; i++) {
                               if (i != prevFrontIndex || stgs.frontImages.length == 1)
                                   frontRandomBag[i] = i;
                           }
                           frontRandomBag = privMethods.shuffleArray(frontRandomBag);
                       }
                       fStaticRndm = frontRandomBag.pop();
                       prevFrontIndex = fStaticRndm;
                   }
                   var bStaticRndm = 0;
                   if (swapBackSource) {
                       if (backRandomBag.length == 0) {
                           for (var i = 0; i &lt; stgs.backImages.length; i++) {
                               if (i != prevBackIndex || stgs.backImages.length == 1)
                                   backRandomBag[i] = i;
                           }
                           backRandomBag = privMethods.shuffleArray(backRandomBag);
                       }
                       bStaticRndm = backRandomBag.pop();
                       prevBackIndex = bStaticRndm;
                   }
                   $tiles.each(function (idx) {
                       var $t = $(this);
                       if (flistData.length &lt; idx + 1) {
                           // cache the selector
                           var data = {};
                           data.$front = $t.find(stgs.listTileCssSelector).first();
                           data.$back = $t.find(stgs.listTileCssSelector).last();
                           data.isReversed = false;
                           flistData[idx] = data;
                       }
                       var $front = flistData[idx].$front;
                       var $back = flistData[idx].$back;
</PRE><PRE>                       var tDelay = stgs.triggerDelay(idx);
                       var triggerSpeed = (tDelay &gt; 0) ? (tdata.speed + tDelay) : tdata.speed;
                       var trigger = (stgs.alwaysTrigger == false) ? ((Math.random() * 351) &gt; 150 ? true : false) : true;
                       var newImage;
                       if (flistData[idx].isReversed) {
                           if (trigger) {
                               window.setTimeout(function () {
                                   flistData[idx].isReversed = false;
                                   if (!swapFrontSource) {
                                       $this.flipListItem(true, $t, $front, $back);
                                   } else {
                                       var isRandom = stgs.frontIsRandom;
                                       var isInGrid = stgs.frontIsInGrid;
                                       var isBground = stgs.frontIsBackgroundImage;
                                       var frontImages = stgs.frontImages;
                                       if (isRandom &amp;&amp; !isInGrid) {
                                           //make sure the random bag is ready
                                           if (fBag.length == 0) {
                                               for (var i = 0; i &lt; stgs.frontImages.length; i++) {
                                                   fBag[i] = i;
                                               }
                                               fBag = privMethods.shuffleArray(fBag);
                                           }
                                           newImage = frontImages[fBag.pop()];
                                       } else {
                                           if (!isInGrid) {
                                               newImage = frontImages[Math.min(idx, frontImages.length)];
                                           } else {
                                               newImage = frontImages[Math.min(fStaticRndm, frontImages.length)];
                                           }
                                       }
                                       $this.flipListItem(true, $t, $front, $back, newImage, isBground);
                                   }
                               }, triggerSpeed);
                           }
                       } else {
                           if (trigger) {
                               window.setTimeout(function () {
                                   flistData[idx].isReversed = true;
                                   if (!swapBackSource) {
                                       $this.flipListItem(false, $t, $back, $front);
                                   } else {
                                       var isRandom = stgs.backIsRandom;
                                       var isInGrid = stgs.backIsInGrid;
                                       var isBground = stgs.backIsBackgroundImage;
                                       var backImages = stgs.backImages;
                                       if (isRandom &amp;&amp; !isInGrid) {
                                           //make sure the random bag is ready
                                           if (bBag.length == 0) {
                                               for (var i = 0; i &lt; stgs.backImages.length; i++) {
                                                   bBag[i] = i;
                                               }
                                               bBag = privMethods.shuffleArray(bBag);
                                           }
                                           newImage = backImages[bBag.pop()];
                                       } else {
                                           if (!isInGrid) {
                                               newImage = backImages[Math.min(idx, backImages.length)];
                                           } else {
                                               newImage = backImages[Math.min(bStaticRndm, backImages.length)];
                                           }
                                       }
                                       $this.flipListItem(false, $t, $back, $front, newImage, isBground);
                                   }
                               }, triggerSpeed);
                           }
                       }
                   });
                   window.setTimeout(function () {
                       isReversed = !isReversed;
                   }, tdata.speed);
</PRE><PRE>               };
</PRE><PRE>               //does the actual animation of a flip list item 
               $this.flipListItem = function (isFront, $itm, $front, $back, newSrc, isBgroundImg) {
</PRE><PRE>                   var dir = (!stgs.ignoreDataAttributes &amp;&amp; typeof ($itm.data(&quot;direction&quot;)) != &quot;undefined&quot;) ? $itm.data(&quot;direction&quot;) : tdata.direction;
                   if (canFlip3d &amp;&amp; tdata.useHwAccel) {
                       // avoid any z-index flickering from reversing an animation too early                
                       isBgroundImg = isFront ? stgs.frontIsBackgroundImage : stgs.backIsBackgroundImage;
                       var animating = isFront ? $front.data(&quot;tile&quot;).animating : $back.data(&quot;tile&quot;).animating;
                       if (animating == true) {
                           return;
                       }
                       var spd = (tdata.speed * 2);
                       var duration = spd + 'ms';
                       var aniFName = (dir == &quot;vertical&quot;) ? 'flipfront180' : 'flipfrontY180';
                       var aniBName = (dir == &quot;vertical&quot;) ? 'flipback180' : 'flipbackY180';
                       var fCss = {
                           WebkitAnimationPlayState: 'running', WebkitAnimationName: aniBName, WebkitAnimationDuration: duration,
                           MozAnimationPlayState: 'running', MozAnimationName: aniBName, MozAnimationDuration: duration,
                           msAnimationPlayState: 'running', msAnimationName: aniBName, msAnimationDuration: duration,
                           OAnimationPlayState: 'running', OAnimationName: aniBName, OAnimationDuration: duration,
                           AnimationPlayState: 'running', AnimationName: aniBName, AnimationDuration: duration
                       };
                       var bCss = {
                           WebkitAnimationPlayState: 'running', WebkitAnimationName: aniFName, WebkitAnimationDuration: duration,
                           MozAnimationPlayState: 'running', MozAnimationName: aniFName, MozAnimationDuration: duration,
                           msAnimationPlayState: 'running', msAnimationName: aniFName, msAnimationDuration: duration,
                           OAnimationPlayState: 'running', OAnimationName: aniFName, OAnimationDuration: duration,
                           AnimationPlayState: 'running', AnimationName: aniFName, AnimationDuration: duration
                       };
                       $front.css(fCss).data(&quot;tile&quot;).animating = true;
                       $back.css(bCss).data(&quot;tile&quot;).animating = true;
                       window.setTimeout(function () {
                           if (typeof (newSrc) != &quot;undefined&quot;) {
                               privMethods.handleListItemSwap($front, newSrc, isBgroundImg, stgs);
                           }
                           $front.data(&quot;tile&quot;).animating = false;
                           $back.data(&quot;tile&quot;).animating = false;
                       }, 0); // once the animation is half through it can be reversed
</PRE><PRE>                   } else {
                       var height = $itm.height();
                       var width = $itm.width();
                       var margin = (dir == &quot;vertical&quot;) ? height / 2 : width / 2;
                       var uCss = (dir == &quot;vertical&quot;) ?
</PRE><P>							{ height: '0px', width: '100%', marginTop: margin + 'px', opacity: 0} :
							{ height: '100%', width: '0px', marginLeft: margin + 'px', opacity: 0 };
</P><PRE>                       var dCss = (dir == &quot;vertical&quot;) ?
</PRE><P>							{ height: '100%', width: '100%', marginTop: '0px', opacity: 1} :
							{ height: '100%', width: '100%', marginLeft: '0px', opacity: 1 };
</P><PRE>                       $front.stop().animate(uCss, { duration: tdata.speed });
                       window.setTimeout(function () {
                           $back.stop().animate(dCss, { duration: tdata.speed });
                           if (typeof (newSrc) != &quot;undefined&quot;) {
                               privMethods.handleListItemSwap($front, newSrc, isBgroundImg, stgs);
                           }
                       }, tdata.speed);
                   }
               };
</PRE><PRE>               /* Delay the tile action*/
               tdata.doAction = function () {
                   var action = null;
                   tdata.stopTimer(false);
                   switch (tdata.mode) {
                       case 'slide':
                           action = $this.slide;
                           break;
                       case 'flip':
                           action = $this.flip;
                           break;
                       case 'flip-list':
                           action = $this.flipList;
                           break;
                   }
                   var callBack = function () {
                       tdata.setTimer();
                   };
                   if (action != null) {
                       doAnimations = true;
                       action(callBack);
                   }
               };
               tdata.setTimer = function () {
                   var action = null;
                   switch (tdata.mode) {
                       case 'slide':
                           action = $this.slide;
                           break;
                       case 'flip':
                           action = $this.flip;
                           break;
                       case 'flip-list':
                           action = $this.flipList;
                           break;
                   }
</PRE><PRE>                   if (action != null) {
                       if (tdata.hasRun == false) {
                           window.setTimeout(function () {
                               doAnimations = true;
                               action();
                               tdata.setTimer();
                           }, tdata.initDelay);
                       } else {
                           if ($this.slideTimer != null)
                               $this.slideTimer = privMethods.stopTimer($this.slideTimer);
                           $this.slideTimer = privMethods.setTimer(function () { doAnimations = true; action(); }, tdata.speed + tdata.delay);
                       }
                   }
                   tdata.hasRun = true;
               };
</PRE><PRE>               tdata.stopTimer = function (restart) {
                   $this.slideTimer = privMethods.stopTimer($this.slideTimer);
                   doAnimations = false;
</PRE><PRE>                   if (typeof (restart) != &quot;undefined&quot; &amp;&amp; restart == true) {
                       tdata.setTimer();
                   }
               };
               $this.data(&quot;LiveTile&quot;, tdata);
               tdata.setTimer();
           });
       },
       animate: function () {
           $(this).each(function () {
               var tData = $(this).data(&quot;LiveTile&quot;);
               tData.doAction();
           });
       },
       destroy: function () {
           $(this).each(function () {
               var $t = $(this);
               $t.unbind(&quot;.liveTile&quot;);
               var $tile = $(this).data(&quot;LiveTile&quot;);
               if ($tile != null) {
                   $tile.stopTimer(false);
                   $t.removeData(&quot;LiveTile&quot;);
                   $t.removeData(&quot;ha&quot;);
                   $t.removeData(&quot;tile&quot;);
                   delete $tile;
                   delete $t.slide;
                   delete $t.flip;
                   delete $t.flipList;
                   delete $t.liveTile;
               }
</PRE><PRE>           });
       },
       stop: function (restart) {
           $(this).each(function () {
               var $tile = $(this).data(&quot;LiveTile&quot;);
               $tile.stopTimer(restart);
               $tile.loopCount = 0;
               $tile.hasRun = false;
           });
       },
       pause: function () {
           $(this).each(function () {
               $(this).data(&quot;LiveTile&quot;).stopTimer();
           });
       },
       play: function () {
           $(this).each(function () {
               $(this).data(&quot;LiveTile&quot;).setTimer();
           });
       }
   };
</PRE><P>})(jQuery);
</P><P>$.fn.metrojs.theme = {};
$.fn.metrojs.theme.loadDefaultTheme = function (stgs) {
</P><PRE>   if (typeof (stgs) == &quot;undefined&quot; || stgs == null) {
       stgs = $.fn.metrojs.theme.defaults;
   } else {
       var stg = $.fn.metrojs.theme.defaults;
       $.extend(stg, stgs);
       stgs = stg;
   }
   //get theme from local storage or set base theme
   var hasLocalStorage = typeof (window.localStorage) != &quot;undefined&quot;;
   var hasKeyAndValue = function (key) {
       return (typeof (window.localStorage[key]) != &quot;undefined&quot; &amp;&amp; window.localStorage[key] != null);
   };
   if (stgs.applyTheme == true) {
       if (hasLocalStorage &amp;&amp; (!hasKeyAndValue(&quot;Metro.JS.AccentColor&quot;) || !hasKeyAndValue(&quot;Metro.JS.BaseAccentColor&quot;))) {
           //base theme
           window.localStorage[&quot;Metro.JS.AccentColor&quot;] = stgs.accentColor;
           window.localStorage[&quot;Metro.JS.BaseAccentColor&quot;] = stgs.baseTheme;
           $(stgs.accentCssSelector).addClass(stgs.accentColor).data(&quot;accent&quot;, stgs.accentColor);
           $(stgs.baseThemeCssSelector).addClass(stgs.baseTheme);
           if (typeof (stgs.loaded == &quot;function&quot;))
               stgs.loaded(stgs.baseTheme, stgs.accentColor);
           //preload light theme image
           if (typeof (stgs.preloadAltBaseTheme) != &quot;undefined&quot; &amp;&amp; stgs.preloadAltBaseTheme)
               $([(stgs.baseTheme == 'dark') ? stgs.metroLightUrl : stgs.metroDarkUrl]).metrojs.preloadImages(function () { });
       } else {
           if (hasLocalStorage) {
               stgs.accentColor = window.localStorage[&quot;Metro.JS.AccentColor&quot;];
               stgs.baseTheme = window.localStorage[&quot;Metro.JS.BaseAccentColor&quot;];
               $(stgs.accentCssSelector).addClass(stgs.accentColor).data(&quot;accent&quot;, stgs.accentColor);
               $(stgs.baseThemeCssSelector).addClass(stgs.baseTheme);
               if (typeof (stgs.loaded == &quot;function&quot;))
                   stgs.loaded(stgs.baseTheme, stgs.accentColor);
           } else {
               $(stgs.accentCssSelector).addClass(stgs.accentColor).data(&quot;accent&quot;, stgs.accentColor);
               $(stgs.baseThemeCssSelector).addClass(stgs.baseTheme);
               if (typeof (stgs.loaded == &quot;function&quot;))
                   stgs.loaded(stgs.baseTheme, stgs.accentColor);
               //preload light theme image
               if (typeof (stgs.preloadAltBaseTheme) != &quot;undefined&quot; &amp;&amp; stgs.preloadAltBaseTheme)
                   $([(stgs.baseTheme == 'dark') ? stgs.metroLightUrl : stgs.metroDarkUrl]).metrojs.preloadImages(function () { });
           }
       }
   }
</PRE><P>};
$.fn.metrojs.theme.applyTheme = function (tColor, aColor, stgs) {
</P><PRE>   if (typeof (stgs) == &quot;undefined&quot; || stgs == null) {
       stgs = $.fn.metrojs.theme.defaults;
   } else {
       var stg = $.fn.metrojs.theme.defaults;
       $.extend(stg, stgs);
       stgs = stg;
   }
</PRE><PRE>   if (typeof (tColor) != &quot;undefined&quot; &amp;&amp; tColor != null) {
       if (typeof (window.localStorage) != &quot;undefined&quot;) {
           window.localStorage[&quot;Metro.JS.BaseAccentColor&quot;] = tColor;
       }
       var $theme = $(stgs.baseThemeCssSelector);
       if ($theme.length &gt; 0) {
           if (tColor == &quot;dark&quot;)
               $theme.addClass(&quot;dark&quot;).removeClass(&quot;light&quot;);
           else if (tColor == &quot;light&quot;)
               $theme.addClass(&quot;light&quot;).removeClass(&quot;dark&quot;);
       }
   }
   if (typeof (aColor) != &quot;undefined&quot; &amp;&amp; aColor != null) {
       if (typeof (window.localStorage) != &quot;undefined&quot;) {
           window.localStorage[&quot;Metro.JS.AccentColor&quot;] = aColor;
       }
       var $accent = $(stgs.accentCssSelector);
       if ($accent.length &gt; 0) {
           var themeset = false;
           $accent.each(function () {
               $(this).addClass(aColor);
               var dAccent = $(this).data(&quot;accent&quot;);
               if (dAccent != aColor) {
                   var cleanClass = $(this).attr(&quot;class&quot;).replace(dAccent, &quot;&quot;);
                   cleanClass = cleanClass.replace(/(\s)+/, ' ');
                   $(this).attr(&quot;class&quot;, cleanClass);
                   $(this).data(&quot;accent&quot;, aColor);
                   themeset = true;
               }
           });
           if (themeset &amp;&amp; typeof (stgs.accentPicked) == &quot;function&quot;)
               stgs.accentPicked(aColor);
       }
   }
</PRE><P>};
</P><P>// default options for theme
$.fn.metrojs.theme.defaults = {
</P><PRE>   baseThemeCssSelector: 'body',                           // selector to place dark or light class after load or selection
   accentCssSelector: '.tiles',                            // selector to place accent color class after load or selection
   accentColor: 'blue',                                    // the default accent color. options are blue, brown, green, lime, magenta, mango, pink, purple, red, teal
   baseTheme: 'dark'                                      // the default theme color. options are dark, light
</PRE><P>};
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2012.igem.org/Team:Paris-Saclay/MetroJs.js">http://2012.igem.org/Team:Paris-Saclay/MetroJs.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Paris-Saclay/MetroJs.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Paris-Saclay/MetroJs.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Paris-Saclay/MetroJs.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Paris-Saclay/MetroJs.js&amp;oldid=40680" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2012.igem.org:Privacy_policy" title="2012.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2012.igem.org:General_disclaimer" title="2012.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
"
Page
Discussion
View source
History
teams
Log in
 
Team:UC Chile/Templates/js/finaljs
From 2012.igem.org
/********************* //* jQuery Drop Line Menu- By Dynamic Drive: http://www.dynamicdrive.com/ //* Last updated: May 9th, 11' //* Menu avaiable at DD CSS Library: http://www.dynamicdrive.com/style/
/
var droplinemenu={
/*arrowimage: {classname: 'downarrowclass', src: , leftpadding: 5}, //customize down arrow image*/ animateduration: {over: 80, out: 50}, //duration of slide in/ out animation, in milliseconds
buildmenu:function(menuid){  jQuery(document).ready(function($){   var $mainmenu=$("#"+menuid+">ul")   var $headers=$mainmenu.find("ul").parent()   $headers.each(function(i){    var $curobj=$(this)    var $subul=$(this).find('ul:eq(0)')    this._dimensions={h:$curobj.find('a:eq(0)').outerHeight()}    this.istopheader=$curobj.parents("ul").length==1? true : false    if (!this.istopheader)     $subul.css({left:0, top:this._dimensions.h})    var $innerheader=$curobj.children('a').eq(0)    $innerheader=($innerheader.children().eq(0).is('span'))? $innerheader.children().eq(0) : $innerheader //if header contains inner SPAN, use that /*   $innerheader.append(     '<img src="'+ droplinemenu.arrowimage.src     +'" class="' + droplinemenu.arrowimage.classname     + '" style="border:0; padding-left: '+droplinemenu.arrowimage.leftpadding+'px" />'    )*/    $curobj.hoverIntent(     function(e){      var $targetul=$(this).children("ul:eq(0)")      if ($targetul.queue().length<=1) //if 1 or less queued animations       if (this.istopheader)        $targetul.css({left: $mainmenu.position().left, top: $mainmenu.position().top+this._dimensions.h})       if (document.all && !window.XMLHttpRequest) //detect IE6 or less, fix issue with overflow        $mainmenu.find('ul').css({overflow: (this.istopheader)? 'hidden' : 'visible'})       $targetul.dequeue().slideDown(droplinemenu.animateduration.over)     },     function(e){      var $targetul=$(this).children("ul:eq(0)")      $targetul.dequeue().slideUp(droplinemenu.animateduration.out)     }    ) //end hover   }) //end $headers.each()   $mainmenu.find("ul").css({display:'none', visibility:'visible', width:$mainmenu.width()})  }) //end document.ready } }
* jQuery Nivo Slider v2.6 * http://nivo.dev7studios.com * * Copyright 2011, Gilbert Pellegrom * Free to use and abuse under the MIT license. * http://www.opensource.org/licenses/mit-license.php *  * March 2010 */
(function($){var NivoSlider=function(element,options){var settings=$.extend({},$.fn.nivoSlider.defaults,options);var vars={currentSlide:0,currentImage:,totalSlides:0,randAnim:,running:false,paused:false,stop:false};var slider=$(element);slider.data('nivo:vars',vars);slider.css('position','relative');slider.addClass('nivoSlider');var kids=slider.children();kids.each(function(){var child=$(this);var link=;if(!child.is('img')){if(child.is('a')){child.addClass('nivo-imageLink');link=child;} child=child.find('img:first');} var childWidth=child.width();if(childWidth==0)childWidth=child.attr('width');var childHeight=child.height();if(childHeight==0)childHeight=child.attr('height');if(childWidth>slider.width()){slider.width(childWidth);} if(childHeight>slider.height()){slider.height(childHeight);} if(link!=){link.css('display','none');} child.css('display','none');vars.totalSlides++;});if(settings.startSlide>0){if(settings.startSlide>=vars.totalSlides)settings.startSlide=vars.totalSlides-1;vars.currentSlide=settings.startSlide;} if($(kids[vars.currentSlide]).is('img')){vars.currentImage=$(kids[vars.currentSlide]);}else{vars.currentImage=$(kids[vars.currentSlide]).find('img:first');} if($(kids[vars.currentSlide]).is('a')){$(kids[vars.currentSlide]).css('display','block');}
slider.css('background','url("'+vars.currentImage.attr('src')+'") no-repeat');slider.append($('
').css({display:'none',opacity:settings.captionOpacity}));var processCaption=function(settings){var nivoCaption=$('.nivo-caption',slider);if(vars.currentImage.attr('title')!=&&vars.currentImage.attr('title')!=undefined){var title=vars.currentImage.attr('title');if(title.substr(0,1)=='#')title=$(title).html();if(nivoCaption.css('display')=='block'){nivoCaption.find('p').fadeOut(settings.animSpeed,function(){$(this).html(title);$(this).fadeIn(settings.animSpeed);});}else{nivoCaption.find('p').html(title);}
nivoCaption.fadeIn(settings.animSpeed);}else{nivoCaption.fadeOut(settings.animSpeed);}} processCaption(settings);var timer=0;if(!settings.manualAdvance&&kids.length>1){timer=setInterval(function(){nivoRun(slider,kids,settings,false);},settings.pauseTime);}
if(settings.directionNav){slider.append('
<a class="nivo-prevNav">'+settings.prevText+'</a><a class="nivo-nextNav">'+settings.nextText+'</a>
');if(settings.directionNavHide){$('.nivo-directionNav',slider).hide();slider.hover(function(){$('.nivo-directionNav',slider).show();},function(){$('.nivo-directionNav',slider).hide();});}
$('a.nivo-prevNav',slider).live('click',function(){if(vars.running)return false;clearInterval(timer);timer=;vars.currentSlide-=2;nivoRun(slider,kids,settings,'prev');});$('a.nivo-nextNav',slider).live('click',function(){if(vars.running)return false;clearInterval(timer);timer=;nivoRun(slider,kids,settings,'next');});}
if(settings.controlNav){var nivoControl=$('
');slider.append(nivoControl);for(var i=0;i<kids.length;i++){if(settings.controlNavThumbs){var child=kids.eq(i);if(!child.is('img')){child=child.find('img:first');}
if(settings.controlNavThumbsFromRel){nivoControl.append('<a class="nivo-control" rel="'+i+'"><img src="'+child.attr('rel')+'" alt="" /></a>');}else{nivoControl.append('<a class="nivo-control" rel="'+i+'"><img src="'+child.attr('src').replace(settings.controlNavThumbsSearch,settings.controlNavThumbsReplace)+'" alt="" /></a>');}}else{nivoControl.append('<a class="nivo-control" rel="'+i+'">'+(i+1)+'</a>');}} $('.nivo-controlNav a:eq('+vars.currentSlide+')',slider).addClass('active');$('.nivo-controlNav a',slider).live('click',function(){if(vars.running)return false;if($(this).hasClass('active'))return false;clearInterval(timer);timer=;slider.css('background','url("'+vars.currentImage.attr('src')+'") no-repeat');vars.currentSlide=$(this).attr('rel')-1;nivoRun(slider,kids,settings,'control');});} if(settings.keyboardNav){$(window).keypress(function(event){if(event.keyCode=='37'){if(vars.running)return false;clearInterval(timer);timer=;vars.currentSlide-=2;nivoRun(slider,kids,settings,'prev');} if(event.keyCode=='39'){if(vars.running)return false;clearInterval(timer);timer=;nivoRun(slider,kids,settings,'next');}});} if(settings.pauseOnHover){slider.hover(function(){vars.paused=true;clearInterval(timer);timer=;},function(){vars.paused=false;if(timer==&&!settings.manualAdvance){timer=setInterval(function(){nivoRun(slider,kids,settings,false);},settings.pauseTime);}});} slider.bind('nivo:animFinished',function(){vars.running=false;$(kids).each(function(){if($(this).is('a')){$(this).css('display','none');}});if($(kids[vars.currentSlide]).is('a')){$(kids[vars.currentSlide]).css('display','block');} if(timer==&&!vars.paused&&!settings.manualAdvance){timer=setInterval(function(){nivoRun(slider,kids,settings,false);},settings.pauseTime);}
settings.afterChange.call(this);});var createSlices=function(slider,settings,vars){for(var i=0;i<settings.slices;i++){var sliceWidth=Math.round(slider.width()/settings.slices);if(i==settings.slices-1){slider.append($('
').css({left:(sliceWidth*i)+'px',width:(slider.width()-(sliceWidth*i))+'px',height:'0px',opacity:'0',background:'url("'+vars.currentImage.attr('src')+'") no-repeat -'+((sliceWidth+(i*sliceWidth))-sliceWidth)+'px 0%'}));}else{slider.append($('
').css({left:(sliceWidth*i)+'px',width:sliceWidth+'px',height:'0px',opacity:'0',background:'url("'+vars.currentImage.attr('src')+'") no-repeat -'+((sliceWidth+(i*sliceWidth))-sliceWidth)+'px 0%'}));}}} var createBoxes=function(slider,settings,vars){var boxWidth=Math.round(slider.width()/settings.boxCols);var boxHeight=Math.round(slider.height()/settings.boxRows);for(var rows=0;rows<settings.boxRows;rows++){for(var cols=0;cols<settings.boxCols;cols++){if(cols==settings.boxCols-1){slider.append($('
').css({opacity:0,left:(boxWidth*cols)+'px',top:(boxHeight*rows)+'px',width:(slider.width()-(boxWidth*cols))+'px',height:boxHeight+'px',background:'url("'+vars.currentImage.attr('src')+'") no-repeat -'+((boxWidth+(cols*boxWidth))-boxWidth)+'px -'+((boxHeight+(rows*boxHeight))-boxHeight)+'px'}));}else{slider.append($('
').css({opacity:0,left:(boxWidth*cols)+'px',top:(boxHeight*rows)+'px',width:boxWidth+'px',height:boxHeight+'px',background:'url("'+vars.currentImage.attr('src')+'") no-repeat -'+((boxWidth+(cols*boxWidth))-boxWidth)+'px -'+((boxHeight+(rows*boxHeight))-boxHeight)+'px'}));}}}}
var nivoRun=function(slider,kids,settings,nudge){var vars=slider.data('nivo:vars');if(vars&&(vars.currentSlide==vars.totalSlides-1)){settings.lastSlide.call(this);} if((!vars||vars.stop)&&!nudge)return false;settings.beforeChange.call(this);if(!nudge){slider.css('background','url("'+vars.currentImage.attr('src')+'") no-repeat');}else{if(nudge=='prev'){slider.css('background','url("'+vars.currentImage.attr('src')+'") no-repeat');} if(nudge=='next'){slider.css('background','url("'+vars.currentImage.attr('src')+'") no-repeat');}} vars.currentSlide++;if(vars.currentSlide==vars.totalSlides){vars.currentSlide=0;settings.slideshowEnd.call(this);} if(vars.currentSlide<0)vars.currentSlide=(vars.totalSlides-1);if($(kids[vars.currentSlide]).is('img')){vars.currentImage=$(kids[vars.currentSlide]);}else{vars.currentImage=$(kids[vars.currentSlide]).find('img:first');} if(settings.controlNav){$('.nivo-controlNav a',slider).removeClass('active');$('.nivo-controlNav a:eq('+vars.currentSlide+')',slider).addClass('active');} processCaption(settings);$('.nivo-slice',slider).remove();$('.nivo-box',slider).remove();if(settings.effect=='random'){var anims=new Array('sliceDownRight','sliceDownLeft','sliceUpRight','sliceUpLeft','sliceUpDown','sliceUpDownLeft','fold','fade','boxRandom','boxRain','boxRainReverse','boxRainGrow','boxRainGrowReverse');vars.randAnim=anims[Math.floor(Math.random()*(anims.length+1))];if(vars.randAnim==undefined)vars.randAnim='fade';} if(settings.effect.indexOf(',')!=-1){var anims=settings.effect.split(',');vars.randAnim=anims[Math.floor(Math.random()*(anims.length))];if(vars.randAnim==undefined)vars.randAnim='fade';} vars.running=true;if(settings.effect=='sliceDown'||settings.effect=='sliceDownRight'||vars.randAnim=='sliceDownRight'||settings.effect=='sliceDownLeft'||vars.randAnim=='sliceDownLeft'){createSlices(slider,settings,vars);var timeBuff=0;var i=0;var slices=$('.nivo-slice',slider);if(settings.effect=='sliceDownLeft'||vars.randAnim=='sliceDownLeft')slices=$('.nivo-slice',slider)._reverse();slices.each(function(){var slice=$(this);slice.css({'top':'0px'});if(i==settings.slices-1){setTimeout(function(){slice.animate({height:'100%',opacity:'1.0'},settings.animSpeed,,function(){slider.trigger('nivo:animFinished');});},(100+timeBuff));}else{setTimeout(function(){slice.animate({height:'100%',opacity:'1.0'},settings.animSpeed);},(100+timeBuff));} timeBuff+=50;i++;});} else if(settings.effect=='sliceUp'||settings.effect=='sliceUpRight'||vars.randAnim=='sliceUpRight'||settings.effect=='sliceUpLeft'||vars.randAnim=='sliceUpLeft'){createSlices(slider,settings,vars);var timeBuff=0;var i=0;var slices=$('.nivo-slice',slider);if(settings.effect=='sliceUpLeft'||vars.randAnim=='sliceUpLeft')slices=$('.nivo-slice',slider)._reverse();slices.each(function(){var slice=$(this);slice.css({'bottom':'0px'});if(i==settings.slices-1){setTimeout(function(){slice.animate({height:'100%',opacity:'1.0'},settings.animSpeed,,function(){slider.trigger('nivo:animFinished');});},(100+timeBuff));}else{setTimeout(function(){slice.animate({height:'100%',opacity:'1.0'},settings.animSpeed);},(100+timeBuff));} timeBuff+=50;i++;});} else if(settings.effect=='sliceUpDown'||settings.effect=='sliceUpDownRight'||vars.randAnim=='sliceUpDown'||settings.effect=='sliceUpDownLeft'||vars.randAnim=='sliceUpDownLeft'){createSlices(slider,settings,vars);var timeBuff=0;var i=0;var v=0;var slices=$('.nivo-slice',slider);if(settings.effect=='sliceUpDownLeft'||vars.randAnim=='sliceUpDownLeft')slices=$('.nivo-slice',slider)._reverse();slices.each(function(){var slice=$(this);if(i==0){slice.css('top','0px');i++;}else{slice.css('bottom','0px');i=0;} if(v==settings.slices-1){setTimeout(function(){slice.animate({height:'100%',opacity:'1.0'},settings.animSpeed,,function(){slider.trigger('nivo:animFinished');});},(100+timeBuff));}else{setTimeout(function(){slice.animate({height:'100%',opacity:'1.0'},settings.animSpeed);},(100+timeBuff));} timeBuff+=50;v++;});} else if(settings.effect=='fold'||vars.randAnim=='fold'){createSlices(slider,settings,vars);var timeBuff=0;var i=0;$('.nivo-slice',slider).each(function(){var slice=$(this);var origWidth=slice.width();slice.css({top:'0px',height:'100%',width:'0px'});if(i==settings.slices-1){setTimeout(function(){slice.animate({width:origWidth,opacity:'1.0'},settings.animSpeed,,function(){slider.trigger('nivo:animFinished');});},(100+timeBuff));}else{setTimeout(function(){slice.animate({width:origWidth,opacity:'1.0'},settings.animSpeed);},(100+timeBuff));} timeBuff+=50;i++;});} else if(settings.effect=='fade'||vars.randAnim=='fade'){createSlices(slider,settings,vars);var firstSlice=$('.nivo-slice:first',slider);firstSlice.css({'height':'100%','width':slider.width()+'px'});firstSlice.animate({opacity:'1.0'},(settings.animSpeed*2),,function(){slider.trigger('nivo:animFinished');});} else if(settings.effect=='slideInRight'||vars.randAnim=='slideInRight'){createSlices(slider,settings,vars);var firstSlice=$('.nivo-slice:first',slider);firstSlice.css({'height':'100%','width':'0px','opacity':'1'});firstSlice.animate({width:slider.width()+'px'},(settings.animSpeed*2),,function(){slider.trigger('nivo:animFinished');});} else if(settings.effect=='slideInLeft'||vars.randAnim=='slideInLeft'){createSlices(slider,settings,vars);var firstSlice=$('.nivo-slice:first',slider);firstSlice.css({'height':'100%','width':'0px','opacity':'1','left':,'right':'0px'});firstSlice.animate({width:slider.width()+'px'},(settings.animSpeed*2),,function(){firstSlice.css({'left':'0px','right':});slider.trigger('nivo:animFinished');});} else if(settings.effect=='boxRandom'||vars.randAnim=='boxRandom'){createBoxes(slider,settings,vars);var totalBoxes=settings.boxCols*settings.boxRows;var i=0;var timeBuff=0;var boxes=shuffle($('.nivo-box',slider));boxes.each(function(){var box=$(this);if(i==totalBoxes-1){setTimeout(function(){box.animate({opacity:'1'},settings.animSpeed,,function(){slider.trigger('nivo:animFinished');});},(100+timeBuff));}else{setTimeout(function(){box.animate({opacity:'1'},settings.animSpeed);},(100+timeBuff));} timeBuff+=20;i++;});} else if(settings.effect=='boxRain'||vars.randAnim=='boxRain'||settings.effect=='boxRainReverse'||vars.randAnim=='boxRainReverse'||settings.effect=='boxRainGrow'||vars.randAnim=='boxRainGrow'||settings.effect=='boxRainGrowReverse'||vars.randAnim=='boxRainGrowReverse'){createBoxes(slider,settings,vars);var totalBoxes=settings.boxCols*settings.boxRows;var i=0;var timeBuff=0;var rowIndex=0;var colIndex=0;var box2Darr=new Array();box2Darr[rowIndex]=new Array();var boxes=$('.nivo-box',slider);if(settings.effect=='boxRainReverse'||vars.randAnim=='boxRainReverse'||settings.effect=='boxRainGrowReverse'||vars.randAnim=='boxRainGrowReverse'){boxes=$('.nivo-box',slider)._reverse();} boxes.each(function(){box2Darr[rowIndex][colIndex]=$(this);colIndex++;if(colIndex==settings.boxCols){rowIndex++;colIndex=0;box2Darr[rowIndex]=new Array();}});for(var cols=0;cols<(settings.boxCols*2);cols++){var prevCol=cols;for(var rows=0;rows<settings.boxRows;rows++){if(prevCol>=0&&prevCol<settings.boxCols){(function(row,col,time,i,totalBoxes){var box=$(box2Darr[row][col]);var w=box.width();var h=box.height();if(settings.effect=='boxRainGrow'||vars.randAnim=='boxRainGrow'||settings.effect=='boxRainGrowReverse'||vars.randAnim=='boxRainGrowReverse'){box.width(0).height(0);} if(i==totalBoxes-1){setTimeout(function(){box.animate({opacity:'1',width:w,height:h},settings.animSpeed/1.3,,function(){slider.trigger('nivo:animFinished');});},(100+time));}else{setTimeout(function(){box.animate({opacity:'1',width:w,height:h},settings.animSpeed/1.3);},(100+time));}})(rows,prevCol,timeBuff,i,totalBoxes);i++;} prevCol--;} timeBuff+=100;}}} var shuffle=function(arr){for(var j,x,i=arr.length;i;j=parseInt(Math.random()*i),x=arr[--i],arr[i]=arr[j],arr[j]=x);return arr;} var trace=function(msg){if(this.console&&typeof console.log!="undefined") console.log(msg);} this.stop=function(){if(!$(element).data('nivo:vars').stop){$(element).data('nivo:vars').stop=true;trace('Stop Slider');}} this.start=function(){if($(element).data('nivo:vars').stop){$(element).data('nivo:vars').stop=false;trace('Start Slider');}} settings.afterLoad.call(this);return this;};$.fn.nivoSlider=function(options){return this.each(function(key,value){var element=$(this);if(element.data('nivoslider'))return element.data('nivoslider');var nivoslider=new NivoSlider(this,options);element.data('nivoslider',nivoslider);});};$.fn.nivoSlider.defaults={effect:'random',slices:15,boxCols:8,boxRows:4,animSpeed:500,pauseTime:3000,startSlide:0,directionNav:true,directionNavHide:true,controlNav:true,controlNavThumbs:false,controlNavThumbsFromRel:false,controlNavThumbsSearch:'.jpg',controlNavThumbsReplace:'_thumb.jpg',keyboardNav:true,pauseOnHover:true,manualAdvance:false,captionOpacity:0.8,prevText:'Prev',nextText:'Next',beforeChange:function(){},afterChange:function(){},slideshowEnd:function(){},lastSlide:function(){},afterLoad:function(){}};$.fn._reverse=[].reverse;})(jQuery);
/**
hoverIntent r6 // 2011.02.26 // jQuery 1.5.1+
< http://cherne.net/brian/resources/jquery.hoverIntent.html >
@param  f  onMouseOver function || An object with configuration options
@param  g  onMouseOut function  || Nothing (use configuration options object)
@author    Brian Cherne brian(at)cherne(dot)net
/
(function($){$.fn.hoverIntent=function(f,g){var cfg={sensitivity:7,interval:100,timeout:400};cfg=$.extend(cfg,g?{over:f,out:g}:f);var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if((Math.abs(pX-cX)+Math.abs(pY-cY))<cfg.sensitivity){$(ob).unbind("mousemove",track);ob.hoverIntent_s=1;return cfg.over.apply(ob,[ev])}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=0;return cfg.out.apply(ob,[ev])};var handleHover=function(e){var ev=jQuery.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t)}if(e.type=="mouseenter"){pX=ev.pageX;pY=ev.pageY;$(ob).bind("mousemove",track);if(ob.hoverIntent_s!=1){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}}else{$(ob).unbind("mousemove",track);if(ob.hoverIntent_s==1){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob)},cfg.timeout)}}};return this.bind('mouseenter',handleHover).bind('mouseleave',handleHover)}})(jQuery);
/**
* jQuery Galleriffic plugin * * Copyright (c) 2008 Trent Foley ( http://trentacular.com ) * Licensed under the MIT License: * http://www.opensource.org/licenses/mit-license.php * * Much thanks to primary contributer Ponticlaro ( http://www.ponticlaro.com ) */
(function($) {
// Globally keep track of all images by their unique hash.  Each item is an image data object.  var allImages = {};  var imageCounter = 0;
// Galleriffic static class  $.galleriffic = {   version: '2.0.1',
// Strips invalid characters and any leading # characters   normalizeHash: function(hash) {    return hash.replace(/^.*#/, ).replace(/\?.*$/, );   },
getImage: function(hash) {    if (!hash)     return undefined;
hash = $.galleriffic.normalizeHash(hash);    return allImages[hash];   },
// Global function that looks up an image by its hash and displays the image.   // Returns false when an image is not found for the specified hash.   // @param {String} hash This is the unique hash value assigned to an image.   gotoImage: function(hash) {    var imageData = $.galleriffic.getImage(hash);    if (!imageData)     return false;
var gallery = imageData.gallery;    gallery.gotoImage(imageData);
return true;   },
// Removes an image from its respective gallery by its hash.   // Returns false when an image is not found for the specified hash or the   // specified owner gallery does match the located images gallery.   // @param {String} hash This is the unique hash value assigned to an image.   // @param {Object} ownerGallery (Optional) When supplied, the located images   // gallery is verified to be the same as the specified owning gallery before   // performing the remove operation.   removeImageByHash: function(hash, ownerGallery) {    var imageData = $.galleriffic.getImage(hash);    if (!imageData)     return false;
var gallery = imageData.gallery;    if (ownerGallery && ownerGallery != gallery)     return false;
return gallery.removeImageByIndex(imageData.index);   }  };
var defaults = {   delay:                     3000,   numThumbs:                 20,   preloadAhead:              40, // Set to -1 to preload all images   enableTopPager:            false,   enableBottomPager: true,   maxPagesToShow:            7,   imageContainerSel: , captionContainerSel: , controlsContainerSel: , loadingContainerSel: , renderSSControls:          true,   renderNavControls:         true,   playLinkText:              'Play',   pauseLinkText:             'Pause',   prevLinkText:              'Previous',   nextLinkText:              'Next',   nextPageLinkText:          'Next ›',   prevPageLinkText:          '‹ Prev',   enableHistory:             false,   enableKeyboardNavigation:  true,   autoStart:                 false,   syncTransitions:           false,   defaultTransitionDuration: 1000,   onSlideChange:             undefined, // accepts a delegate like such: function(prevIndex, nextIndex) { ... }   onTransitionOut:           undefined, // accepts a delegate like such: function(slide, caption, isSync, callback) { ... }   onTransitionIn:            undefined, // accepts a delegate like such: function(slide, caption, isSync) { ... }   onPageTransitionOut:       undefined, // accepts a delegate like such: function(callback) { ... }   onPageTransitionIn:        undefined, // accepts a delegate like such: function() { ... }   onImageAdded:              undefined, // accepts a delegate like such: function(imageData, $li) { ... }   onImageRemoved:            undefined  // accepts a delegate like such: function(imageData, $li) { ... }  };
// Primary Galleriffic initialization function that should be called on the thumbnail container.  $.fn.galleriffic = function(settings) {   //  Extend Gallery Object   $.extend(this, {    // Returns the version of the script    version: $.galleriffic.version,
// Current state of the slideshow    isSlideshowRunning: false,    slideshowTimeout: undefined,
// This function is attached to the click event of generated hyperlinks within the gallery    clickHandler: function(e, link) {     this.pause();
if (!this.enableHistory) {      // The href attribute holds the unique hash for an image      var hash = $.galleriffic.normalizeHash($(link).attr('href'));      $.galleriffic.gotoImage(hash);      e.preventDefault();     }    },
// Appends an image to the end of the set of images.  Argument listItem can be either a jQuery DOM element or arbitrary html.    // @param listItem Either a jQuery object or a string of html of the list item that is to be added to the gallery.    appendImage: function(listItem) {     this.addImage(listItem, false, false);     return this;    },
// Inserts an image into the set of images.  Argument listItem can be either a jQuery DOM element or arbitrary html.    // @param listItem Either a jQuery object or a string of html of the list item that is to be added to the gallery.    // @param {Integer} position The index within the gallery where the item shouold be added.    insertImage: function(listItem, position) {     this.addImage(listItem, false, true, position);     return this;    },
// Adds an image to the gallery and optionally inserts/appends it to the DOM (thumbExists)    // @param listItem Either a jQuery object or a string of html of the list item that is to be added to the gallery.    // @param {Boolean} thumbExists Specifies whether the thumbnail already exists in the DOM or if it needs to be added.    // @param {Boolean} insert Specifies whether the the image is appended to the end or inserted into the gallery.    // @param {Integer} position The index within the gallery where the item shouold be added.    addImage: function(listItem, thumbExists, insert, position) {     var $li = ( typeof listItem === "string" ) ? $(listItem) : listItem;         var $aThumb = $li.find('a.thumb');     var slideUrl = $aThumb.attr('href');     var title = $aThumb.attr('title');     var $caption = $li.find('.caption').remove();     var hash = $aThumb.attr('name');
// Increment the image counter     imageCounter++;
// Autogenerate a hash value if none is present or if it is a duplicate     if (!hash || allImages[+hash]) { hash = imageCounter;     }
// Set position to end when not specified     if (!insert)      position = this.data.length;
var imageData = {      title:title,      slideUrl:slideUrl,      caption:$caption,      hash:hash,      gallery:this,      index:position     };
// Add the imageData to this gallery's array of images     if (insert) {      this.data.splice(position, 0, imageData);
// Reset index value on all imageData objects      this.updateIndices(position);     }     else {      this.data.push(imageData);     }
var gallery = this;
// Add the element to the DOM     if (!thumbExists) {      // Update thumbs passing in addition post transition out handler      this.updateThumbs(function() {       var $thumbsUl = gallery.find('ul.thumbs');       if (insert)        $thumbsUl.children(':eq('+position+')').before($li);       else        $thumbsUl.append($li);
if (gallery.onImageAdded)        gallery.onImageAdded(imageData, $li);      });     }
// Register the image globally     allImages[+hash] = imageData;
// Setup attributes and click handler     $aThumb.attr('rel', 'history')      .attr('href', '#'+hash)      .removeAttr('name')      .click(function(e) {       gallery.clickHandler(e, this);      });
return this;    },
// Removes an image from the gallery based on its index.    // Returns false when the index is out of range.    removeImageByIndex: function(index) {     if (index < 0 || index >= this.data.length)      return false;
var imageData = this.data[index];     if (!imageData)      return false;
this.removeImage(imageData);
return true;    },
// Convenience method that simply calls the global removeImageByHash method.    removeImageByHash: function(hash) {     return $.galleriffic.removeImageByHash(hash, this);    },
// Removes an image from the gallery.    removeImage: function(imageData) {     var index = imageData.index;
// Remove the image from the gallery data array     this.data.splice(index, 1);
// Remove the global registration     delete allImages[+imageData.hash];
// Remove the image's list item from the DOM     this.updateThumbs(function() {      var $li = gallery.find('ul.thumbs')       .children(':eq('+index+')')       .remove();
if (gallery.onImageRemoved)       gallery.onImageRemoved(imageData, $li);     });
// Update each image objects index value     this.updateIndices(index);
return this;    },
// Updates the index values of the each of the images in the gallery after the specified index    updateIndices: function(startIndex) {     for (i = startIndex; i < this.data.length; i++) {      this.data[i].index = i;     }
return this;    },
// Scraped the thumbnail container for thumbs and adds each to the gallery    initializeThumbs: function() {     this.data = [];     var gallery = this;
this.find('ul.thumbs > li').each(function(i) {      gallery.addImage($(this), true, false);     });
return this;    },
isPreloadComplete: false,
// Initalizes the image preloader    preloadInit: function() {     if (this.preloadAhead == 0) return this;
this.preloadStartIndex = this.currentImage.index;     var nextIndex = this.getNextIndex(this.preloadStartIndex);     return this.preloadRecursive(this.preloadStartIndex, nextIndex);    },
// Changes the location in the gallery the preloader should work    // @param {Integer} index The index of the image where the preloader should restart at.    preloadRelocate: function(index) {     // By changing this startIndex, the current preload script will restart     this.preloadStartIndex = index;     return this;    },
// Recursive function that performs the image preloading    // @param {Integer} startIndex The index of the first image the current preloader started on.    // @param {Integer} currentIndex The index of the current image to preload.    preloadRecursive: function(startIndex, currentIndex) {     // Check if startIndex has been relocated     if (startIndex != this.preloadStartIndex) {      var nextIndex = this.getNextIndex(this.preloadStartIndex);      return this.preloadRecursive(this.preloadStartIndex, nextIndex);     }
var gallery = this;
// Now check for preloadAhead count     var preloadCount = currentIndex - startIndex;     if (preloadCount < 0)      preloadCount = this.data.length-1-startIndex+currentIndex;     if (this.preloadAhead >= 0 && preloadCount > this.preloadAhead) {      // Do this in order to keep checking for relocated start index      setTimeout(function() { gallery.preloadRecursive(startIndex, currentIndex); }, 500);      return this;     }
var imageData = this.data[currentIndex];     if (!imageData)      return this;
// If already loaded, continue     if (imageData.image)      return this.preloadNext(startIndex, currentIndex);
// Preload the image     var image = new Image();
image.onload = function() {      imageData.image = this;      gallery.preloadNext(startIndex, currentIndex);     };
image.alt = imageData.title;     image.src = imageData.slideUrl;
return this;    },
// Called by preloadRecursive in order to preload the next image after the previous has loaded.    // @param {Integer} startIndex The index of the first image the current preloader started on.    // @param {Integer} currentIndex The index of the current image to preload.    preloadNext: function(startIndex, currentIndex) {     var nextIndex = this.getNextIndex(currentIndex);     if (nextIndex == startIndex) {      this.isPreloadComplete = true;     } else {      // Use setTimeout to free up thread      var gallery = this;      setTimeout(function() { gallery.preloadRecursive(startIndex, nextIndex); }, 100);     }
return this;    },
// Safe way to get the next image index relative to the current image.    // If the current image is the last, returns 0    getNextIndex: function(index) {     var nextIndex = index+1;     if (nextIndex >= this.data.length)      nextIndex = 0;     return nextIndex;    },
// Safe way to get the previous image index relative to the current image.    // If the current image is the first, return the index of the last image in the gallery.    getPrevIndex: function(index) {     var prevIndex = index-1;     if (prevIndex < 0)      prevIndex = this.data.length-1;     return prevIndex;    },
// Pauses the slideshow    pause: function() {     this.isSlideshowRunning = false;     if (this.slideshowTimeout) {      clearTimeout(this.slideshowTimeout);      this.slideshowTimeout = undefined;     }
if (this.$controlsContainer) {      this.$controlsContainer       .find('div.ss-controls a').removeClass().addClass('play')       .attr('title', this.playLinkText)       .attr('href', '#play')       .html(this.playLinkText);     }
return this;    },
// Plays the slideshow    play: function() {     this.isSlideshowRunning = true;
if (this.$controlsContainer) {      this.$controlsContainer       .find('div.ss-controls a').removeClass().addClass('pause')       .attr('title', this.pauseLinkText)       .attr('href', '#pause')       .html(this.pauseLinkText);     }
if (!this.slideshowTimeout) {      var gallery = this;      this.slideshowTimeout = setTimeout(function() { gallery.ssAdvance(); }, this.delay);     }
return this;    },
// Toggles the state of the slideshow (playing/paused)    toggleSlideshow: function() {     if (this.isSlideshowRunning)      this.pause();     else      this.play();
return this;    },
// Advances the slideshow to the next image and delegates navigation to the    // history plugin when history is enabled    // enableHistory is true    ssAdvance: function() {     if (this.isSlideshowRunning)      this.next(true);
return this;    },
// Advances the gallery to the next image.    // @param {Boolean} dontPause Specifies whether to pause the slideshow.    // @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.      next: function(dontPause, bypassHistory) {     this.gotoIndex(this.getNextIndex(this.currentImage.index), dontPause, bypassHistory);     return this;    },
// Navigates to the previous image in the gallery.    // @param {Boolean} dontPause Specifies whether to pause the slideshow.    // @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.    previous: function(dontPause, bypassHistory) {     this.gotoIndex(this.getPrevIndex(this.currentImage.index), dontPause, bypassHistory);     return this;    },
// Navigates to the next page in the gallery.    // @param {Boolean} dontPause Specifies whether to pause the slideshow.    // @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.    nextPage: function(dontPause, bypassHistory) {     var page = this.getCurrentPage();     var lastPage = this.getNumPages() - 1;     if (page < lastPage) {      var startIndex = page * this.numThumbs;      var nextPage = startIndex + this.numThumbs;      this.gotoIndex(nextPage, dontPause, bypassHistory);     }
return this;    },
// Navigates to the previous page in the gallery.    // @param {Boolean} dontPause Specifies whether to pause the slideshow.    // @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.    previousPage: function(dontPause, bypassHistory) {     var page = this.getCurrentPage();     if (page > 0) {      var startIndex = page * this.numThumbs;      var prevPage = startIndex - this.numThumbs;          this.gotoIndex(prevPage, dontPause, bypassHistory);     }
return this;    },
// Navigates to the image at the specified index in the gallery    // @param {Integer} index The index of the image in the gallery to display.    // @param {Boolean} dontPause Specifies whether to pause the slideshow.    // @param {Boolean} bypassHistory Specifies whether to delegate navigation to the history plugin when history is enabled.    gotoIndex: function(index, dontPause, bypassHistory) {     if (!dontPause)      this.pause();
if (index < 0) index = 0;     else if (index >= this.data.length) index = this.data.length-1;
var imageData = this.data[index];
if (!bypassHistory && this.enableHistory)      $.historyLoad(String(imageData.hash));  // At the moment, historyLoad only accepts string arguments     else      this.gotoImage(imageData);
return this;    },
// This function is garaunteed to be called anytime a gallery slide changes.    // @param {Object} imageData An object holding the image metadata of the image to navigate to.    gotoImage: function(imageData) {     var index = imageData.index;
if (this.onSlideChange)      this.onSlideChange(this.currentImage.index, index);
this.currentImage = imageData;     this.preloadRelocate(index);
this.refresh();
return this;    },
// Returns the default transition duration value.  The value is halved when not    // performing a synchronized transition.    // @param {Boolean} isSync Specifies whether the transitions are synchronized.    getDefaultTransitionDuration: function(isSync) {     if (isSync)      return this.defaultTransitionDuration;     return this.defaultTransitionDuration / 2;    },
// Rebuilds the slideshow image and controls and performs transitions    refresh: function() {     var imageData = this.currentImage;     if (!imageData)      return this;
var index = imageData.index;
// Update Controls     if (this.$controlsContainer) {      this.$controlsContainer       .find('div.nav-controls a.prev').attr('href', '#'+this.data[this.getPrevIndex(index)].hash).end()       .find('div.nav-controls a.next').attr('href', '#'+this.data[this.getNextIndex(index)].hash);     }
var previousSlide = this.$imageContainer.find('span.current').addClass('previous').removeClass('current');     var previousCaption = 0;
if (this.$captionContainer) {      previousCaption = this.$captionContainer.find('span.current').addClass('previous').removeClass('current');     }
// Perform transitions simultaneously if syncTransitions is true and the next image is already preloaded     var isSync = this.syncTransitions && imageData.image;
// Flag we are transitioning     var isTransitioning = true;     var gallery = this;
var transitionOutCallback = function() {      // Flag that the transition has completed      isTransitioning = false;
// Remove the old slide      previousSlide.remove();
// Remove old caption      if (previousCaption)       previousCaption.remove();
if (!isSync) {       if (imageData.image && imageData.hash == gallery.data[gallery.currentImage.index].hash) {        gallery.buildImage(imageData, isSync);       } else {        // Show loading container        if (gallery.$loadingContainer) {         gallery.$loadingContainer.show();        }       }      }     };
if (previousSlide.length == 0) {      // For the first slide, the previous slide will be empty, so we will call the callback immediately      transitionOutCallback();     } else {      if (this.onTransitionOut) {       this.onTransitionOut(previousSlide, previousCaption, isSync, transitionOutCallback);      } else {       previousSlide.fadeTo(this.getDefaultTransitionDuration(isSync), 0.0, transitionOutCallback);       if (previousCaption)        previousCaption.fadeTo(this.getDefaultTransitionDuration(isSync), 0.0);      }     }
// Go ahead and begin transitioning in of next image     if (isSync)      this.buildImage(imageData, isSync);
if (!imageData.image) {      var image = new Image();
// Wire up mainImage onload event      image.onload = function() {       imageData.image = this;
// Only build image if the out transition has completed and we are still on the same image hash       if (!isTransitioning && imageData.hash == gallery.data[gallery.currentImage.index].hash) {        gallery.buildImage(imageData, isSync);       }      };
// set alt and src      image.alt = imageData.title;      image.src = imageData.slideUrl;     }
// This causes the preloader (if still running) to relocate out from the currentIndex     this.relocatePreload = true;
return this.syncThumbs();    },
// Called by the refresh method after the previous image has been transitioned out or at the same time    // as the out transition when performing a synchronous transition.    // @param {Object} imageData An object holding the image metadata of the image to build.    // @param {Boolean} isSync Specifies whether the transitions are synchronized.    buildImage: function(imageData, isSync) {     var gallery = this;     var nextIndex = this.getNextIndex(imageData.index);
// Construct new hidden span for the image     var newSlide = this.$imageContainer      .append('<a class="advance-link" rel="history" href="#'+this.data[nextIndex].hash+'" title="'+imageData.title+'"> </a>')      .find('span.current').css('opacity', '0');
newSlide.find('a')      .append(imageData.image)      .click(function(e) {       gallery.clickHandler(e, this);      });
var newCaption = 0;     if (this.$captionContainer) {      // Construct new hidden caption for the image      newCaption = this.$captionContainer       .append('')       .find('span.current').css('opacity', '0')       .append(imageData.caption);     }
// Hide the loading conatiner     if (this.$loadingContainer) {      this.$loadingContainer.hide();     }
// Transition in the new image     if (this.onTransitionIn) {      this.onTransitionIn(newSlide, newCaption, isSync);     } else {      newSlide.fadeTo(this.getDefaultTransitionDuration(isSync), 1.0);      if (newCaption)       newCaption.fadeTo(this.getDefaultTransitionDuration(isSync), 1.0);     }
if (this.isSlideshowRunning) {      if (this.slideshowTimeout)       clearTimeout(this.slideshowTimeout);
this.slideshowTimeout = setTimeout(function() { gallery.ssAdvance(); }, this.delay);     }
return this;    },
// Returns the current page index that should be shown for the currentImage    getCurrentPage: function() {     return Math.floor(this.currentImage.index / this.numThumbs);    },
// Applies the selected class to the current image's corresponding thumbnail.    // Also checks if the current page has changed and updates the displayed page of thumbnails if necessary.    syncThumbs: function() {     var page = this.getCurrentPage();     if (page != this.displayedPage)      this.updateThumbs();
// Remove existing selected class and add selected class to new thumb     var $thumbs = this.find('ul.thumbs').children();     $thumbs.filter('.selected').removeClass('selected');     $thumbs.eq(this.currentImage.index).addClass('selected');
return this;    },
// Performs transitions on the thumbnails container and updates the set of    // thumbnails that are to be displayed and the navigation controls.    // @param {Delegate} postTransitionOutHandler An optional delegate that is called after    // the thumbnails container has transitioned out and before the thumbnails are rebuilt.    updateThumbs: function(postTransitionOutHandler) {     var gallery = this;     var transitionOutCallback = function() {      // Call the Post-transition Out Handler      if (postTransitionOutHandler)       postTransitionOutHandler();
gallery.rebuildThumbs();
// Transition In the thumbsContainer      if (gallery.onPageTransitionIn)       gallery.onPageTransitionIn();      else       gallery.show();     };
// Transition Out the thumbsContainer     if (this.onPageTransitionOut) {      this.onPageTransitionOut(transitionOutCallback);     } else {      this.hide();      transitionOutCallback();     }
return this;    },
// Updates the set of thumbnails that are to be displayed and the navigation controls.    rebuildThumbs: function() {     var needsPagination = this.data.length > this.numThumbs;
// Rebuild top pager     if (this.enableTopPager) {      var $topPager = this.find('div.top');      if ($topPager.length == 0)
$topPager = this.prepend('
').find('div.top');
else       $topPager.empty();
if (needsPagination)       this.buildPager($topPager);     }
// Rebuild bottom pager     if (this.enableBottomPager) {      var $bottomPager = this.find('div.bottom');      if ($bottomPager.length == 0)
$bottomPager = this.append('
').find('div.bottom');
else       $bottomPager.empty();
if (needsPagination)       this.buildPager($bottomPager);     }
var page = this.getCurrentPage();     var startIndex = page*this.numThumbs;     var stopIndex = startIndex+this.numThumbs-1;     if (stopIndex >= this.data.length)      stopIndex = this.data.length-1;
// Show/Hide thumbs     var $thumbsUl = this.find('ul.thumbs');     $thumbsUl.find('li').each(function(i) {      var $li = $(this);      if (i >= startIndex && i <= stopIndex) {       $li.show();      } else {       $li.hide();      }     });
this.displayedPage = page;
// Remove the noscript class from the thumbs container ul     $thumbsUl.removeClass('noscript');
return this;    },
// Returns the total number of pages required to display all the thumbnails.    getNumPages: function() {     return Math.ceil(this.data.length/this.numThumbs);    },
// Rebuilds the pager control in the specified matched element.    // @param {jQuery} pager A jQuery element set matching the particular pager to be rebuilt.    buildPager: function(pager) {     var gallery = this;     var numPages = this.getNumPages();     var page = this.getCurrentPage();     var startIndex = page * this.numThumbs;     var pagesRemaining = this.maxPagesToShow - 1;
var pageNum = page - Math.floor((this.maxPagesToShow - 1) / 2) + 1;     if (pageNum > 0) {      var remainingPageCount = numPages - pageNum;      if (remainingPageCount < pagesRemaining) {       pageNum = pageNum - (pagesRemaining - remainingPageCount);      }     }
if (pageNum < 0) {      pageNum = 0;     }
// Prev Page Link     if (page > 0) {      var prevPage = startIndex - this.numThumbs;      pager.append('<a rel="history" href="#'+this.data[prevPage].hash+'" title="'+this.prevPageLinkText+'">'+this.prevPageLinkText+'</a>');     }
// Create First Page link if needed     if (pageNum > 0) {      this.buildPageLink(pager, 0, numPages);      if (pageNum > 1)       pager.append('…');
pagesRemaining--;     }
// Page Index Links     while (pagesRemaining > 0) {      this.buildPageLink(pager, pageNum, numPages);      pagesRemaining--;      pageNum++;     }
// Create Last Page link if needed     if (pageNum < numPages) {      var lastPageNum = numPages - 1;      if (pageNum < lastPageNum)       pager.append('…');
this.buildPageLink(pager, lastPageNum, numPages);     }
// Next Page Link     var nextPage = startIndex + this.numThumbs;     if (nextPage < this.data.length) {      pager.append('<a rel="history" href="#'+this.data[nextPage].hash+'" title="'+this.nextPageLinkText+'">'+this.nextPageLinkText+'</a>');     }
pager.find('a').click(function(e) {      gallery.clickHandler(e, this);     });
return this;    },
// Builds a single page link within a pager.  This function is called by buildPager    // @param {jQuery} pager A jQuery element set matching the particular pager to be rebuilt.    // @param {Integer} pageNum The page number of the page link to build.    // @param {Integer} numPages The total number of pages required to display all thumbnails.    buildPageLink: function(pager, pageNum, numPages) {     var pageLabel = pageNum + 1;     var currentPage = this.getCurrentPage();     if (pageNum == currentPage)      pager.append(''+pageLabel+'');     else if (pageNum < numPages) {      var imageIndex = pageNum*this.numThumbs;      pager.append('<a rel="history" href="#'+this.data[imageIndex].hash+'" title="'+pageLabel+'">'+pageLabel+'</a>');     }
return this;    }   });
// Now initialize the gallery   $.extend(this, defaults, settings);
// Verify the history plugin is available   if (this.enableHistory && !$.historyInit)    this.enableHistory = false;
// Select containers   if (this.imageContainerSel) this.$imageContainer = $(this.imageContainerSel);   if (this.captionContainerSel) this.$captionContainer = $(this.captionContainerSel);   if (this.loadingContainerSel) this.$loadingContainer = $(this.loadingContainerSel);
// Initialize the thumbails   this.initializeThumbs();
if (this.maxPagesToShow < 3)    this.maxPagesToShow = 3;
this.displayedPage = -1;   this.currentImage = this.data[0];   var gallery = this;
// Hide the loadingContainer   if (this.$loadingContainer)    this.$loadingContainer.hide();
// Setup controls   if (this.controlsContainerSel) {    this.$controlsContainer = $(this.controlsContainerSel).empty();
if (this.renderSSControls) {     if (this.autoStart) {      this.$controlsContainer
.append('
<a href="#pause" class="pause" title="'+this.pauseLinkText+'">'+this.pauseLinkText+'</a>
');
} else {      this.$controlsContainer
.append('
<a href="#play" class="play" title="'+this.playLinkText+'">'+this.playLinkText+'</a>
');
}
this.$controlsContainer.find('div.ss-controls a')      .click(function(e) {       gallery.toggleSlideshow();       e.preventDefault();       return false;      });    }
if (this.renderNavControls) {     this.$controlsContainer
.append('
<a class="prev" rel="history" title="'+this.prevLinkText+'">'+this.prevLinkText+'</a><a class="next" rel="history" title="'+this.nextLinkText+'">'+this.nextLinkText+'</a>
')
.find('div.nav-controls a')      .click(function(e) {       gallery.clickHandler(e, this);      });    }   }
var initFirstImage = !this.enableHistory || !location.hash;   if (this.enableHistory && location.hash) {    var hash = $.galleriffic.normalizeHash(location.hash);    var imageData = allImages[hash];    if (!imageData)     initFirstImage = true;   }
// Setup gallery to show the first image   if (initFirstImage)    this.gotoIndex(0, false, true);
// Setup Keyboard Navigation   if (this.enableKeyboardNavigation) {    $(document).keydown(function(e) {     var key = e.charCode ? e.charCode : e.keyCode ? e.keyCode : 0;     switch(key) {      case 32: // space       gallery.next();       e.preventDefault();       break;      case 33: // Page Up       gallery.previousPage();       e.preventDefault();       break;      case 34: // Page Down       gallery.nextPage();       e.preventDefault();       break;      case 35: // End       gallery.gotoIndex(gallery.data.length-1);       e.preventDefault();       break;      case 36: // Home       gallery.gotoIndex(0);       e.preventDefault();       break;      case 37: // left arrow       gallery.previous();       e.preventDefault();       break;      case 39: // right arrow       gallery.next();       e.preventDefault();       break;     }    });   }
// Auto start the slideshow   if (this.autoStart)    this.play();
// Kickoff Image Preloader after 1 second   setTimeout(function() { gallery.preloadInit(); }, 1000);
return this;  }; })(jQuery);
/**
* jQuery Opacity Rollover plugin * * Copyright (c) 2009 Trent Foley ( http://trentacular.com ) * Licensed under the MIT License: * http://www.opensource.org/licenses/mit-license.php */
(function($) {
var defaults = {   mouseOutOpacity:   0.67,   mouseOverOpacity:  1.0,   fadeSpeed:         'fast',   exemptionSelector: '.selected'  };
$.fn.opacityrollover = function(settings) {   // Initialize the effect   $.extend(this, defaults, settings);
var config = this;
function fadeTo(element, opacity) {    var $target = $(element);
if (config.exemptionSelector)     $target = $target.not(config.exemptionSelector);
$target.fadeTo(config.fadeSpeed, opacity);   }
this.css('opacity', this.mouseOutOpacity)    .hover(     function () {      fadeTo(this, config.mouseOverOpacity);     },     function () {      fadeTo(this, config.mouseOutOpacity);     });
return this;  }; })(jQuery);
/*
* jQuery history plugin *  * sample page: http://www.mikage.to/jquery/jquery_history.html * * Copyright (c) 2006-2009 Taku Sano (Mikage Sawatari) * Licensed under the MIT License: * http://www.opensource.org/licenses/mit-license.php * * Modified by Lincoln Cooper to add Safari support and only call the callback once during initialization * for msie when no initial hash supplied. */
jQuery.extend({  historyCurrentHash: undefined,  historyCallback: undefined,  historyIframeSrc: undefined,
historyInit: function(callback, src){   jQuery.historyCallback = callback;   if (src) jQuery.historyIframeSrc = src;   var current_hash = location.hash.replace(/\?.*$/, );
jQuery.historyCurrentHash = current_hash;   // if ((jQuery.browser.msie) && (jQuery.browser.version < 8)) {   if (jQuery.browser.msie) {    // To stop the callback firing twice during initilization if no hash present    if (jQuery.historyCurrentHash == ) { jQuery.historyCurrentHash = '#';   }
// add hidden iframe for IE    jQuery("body").prepend('<iframe id="jQuery_history" style="display: none;"'+     (jQuery.historyIframeSrc ? ' src="'+jQuery.historyIframeSrc+'"' : ) +'></iframe>'    );    var ihistory = jQuery("#jQuery_history")[0];    var iframe = ihistory.contentWindow.document;    iframe.open();    iframe.close();    iframe.location.hash = current_hash;   }   else if (jQuery.browser.safari) {    // etablish back/forward stacks    jQuery.historyBackStack = [];    jQuery.historyBackStack.length = history.length;    jQuery.historyForwardStack = [];    jQuery.lastHistoryLength = history.length;
jQuery.isFirst = true;   }   if(current_hash)    jQuery.historyCallback(current_hash.replace(/^#/, )); setInterval(jQuery.historyCheck, 100);  },
historyAddHistory: function(hash) {   // This makes the looping function do something   jQuery.historyBackStack.push(hash);
jQuery.historyForwardStack.length = 0; // clear forwardStack (true click occured)   this.isFirst = true;  },
historyCheck: function(){   // if ((jQuery.browser.msie) && (jQuery.browser.version < 8)) {   if (jQuery.browser.msie) {    // On IE, check for location.hash of iframe    var ihistory = jQuery("#jQuery_history")[0];    var iframe = ihistory.contentDocument || ihistory.contentWindow.document;    var current_hash = iframe.location.hash.replace(/\?.*$/, ); if(current_hash != jQuery.historyCurrentHash) {
location.hash = current_hash;     jQuery.historyCurrentHash = current_hash;     jQuery.historyCallback(current_hash.replace(/^#/, ));
}   } else if (jQuery.browser.safari) {    if(jQuery.lastHistoryLength == history.length && jQuery.historyBackStack.length > jQuery.lastHistoryLength) {     jQuery.historyBackStack.shift();    }    if (!jQuery.dontCheck) {     var historyDelta = history.length - jQuery.historyBackStack.length;     jQuery.lastHistoryLength = history.length;
if (historyDelta) { // back or forward button has been pushed      jQuery.isFirst = false;      if (historyDelta < 0) { // back button has been pushed       // move items to forward stack       for (var i = 0; i < Math.abs(historyDelta); i++) jQuery.historyForwardStack.unshift(jQuery.historyBackStack.pop());      } else { // forward button has been pushed       // move items to back stack       for (var i = 0; i < historyDelta; i++) jQuery.historyBackStack.push(jQuery.historyForwardStack.shift());      }      var cachedHash = jQuery.historyBackStack[jQuery.historyBackStack.length - 1];      if (cachedHash != undefined) {       jQuery.historyCurrentHash = location.hash.replace(/\?.*$/, ); jQuery.historyCallback(cachedHash);      }     } else if (jQuery.historyBackStack[jQuery.historyBackStack.length - 1] == undefined && !jQuery.isFirst) {      // back button has been pushed to beginning and URL already pointed to hash (e.g. a bookmark)      // document.URL doesn't change in Safari      if (location.hash) {       var current_hash = location.hash;       jQuery.historyCallback(location.hash.replace(/^#/, )); } else {       var current_hash = ; jQuery.historyCallback(); }      jQuery.isFirst = true;     }    }   } else { // otherwise, check for location.hash    var current_hash = location.hash.replace(/\?.*$/, ); if(current_hash != jQuery.historyCurrentHash) {     jQuery.historyCurrentHash = current_hash;     jQuery.historyCallback(current_hash.replace(/^#/, )); }   }  },  historyLoad: function(hash){   var newhash;   hash = decodeURIComponent(hash.replace(/\?.*$/, ));
if (jQuery.browser.safari) {    newhash = hash;   }   else {    newhash = '#' + hash;    location.hash = newhash;   }   jQuery.historyCurrentHash = newhash;
// if ((jQuery.browser.msie) && (jQuery.browser.version < 8)) {   if (jQuery.browser.msie) {    var ihistory = jQuery("#jQuery_history")[0];    var iframe = ihistory.contentWindow.document;    iframe.open();    iframe.close();    iframe.location.hash = newhash;    jQuery.lastHistoryLength = history.length;    jQuery.historyCallback(hash);   }   else if (jQuery.browser.safari) {    jQuery.dontCheck = true;    // Manually keep track of the history values for Safari    this.historyAddHistory(hash);
// Wait a while before allowing checking so that Safari has time to update the "history" object    // correctly (otherwise the check loop would detect a false change in hash).    var fn = function() {jQuery.dontCheck = false;};    window.setTimeout(fn, 200);    jQuery.historyCallback(hash);    // N.B. "location.hash=" must be the last line of code for Safari as execution stops afterwards.    //      By explicitly using the "location.hash" command (instead of using a variable set to "location.hash") the    //      URL in the browser and the "history" object are both updated correctly.    location.hash = newhash;   }   else {     jQuery.historyCallback(hash);   }  } });
//build menu with DIV ID="myslidemenu" on page: droplinemenu.buildmenu("mydroplinemenu")
//Nivoslider
$(window).load(function() {        $('#slider').nivoSlider({
effect:'fade',    pauseOnHover:true   });
});
//Profile script from http://www.willmaster.com/library/web-development/replace-div-content.php function ReplaceContentInContainer(id,content) { var container = document.getElementById(id); container.innerHTML = content;
}
/*
* Superfish v1.4.8 - jQuery menu widget * Copyright (c) 2008 Joel Birch * * Dual licensed under the MIT and GPL licenses: * http://www.opensource.org/licenses/mit-license.php * http://www.gnu.org/licenses/gpl.html * * CHANGELOG: http://users.tpg.com.au/j_birch/plugins/superfish/changelog.txt */
(function($){
$.fn.superfish = function(op){
var sf = $.fn.superfish,    c = sf.c,    $arrow = $([' »'].join()), over = function(){     var $$ = $(this), menu = getMenu($$);     clearTimeout(menu.sfTimer);     $$.showSuperfishUl().siblings().hideSuperfishUl();    },    out = function(){     var $$ = $(this), menu = getMenu($$), o = sf.op;     clearTimeout(menu.sfTimer);     menu.sfTimer=setTimeout(function(){      o.retainPath=($.inArray($$[0],o.$path)>-1);      $$.hideSuperfishUl();      if (o.$path.length && $$.parents(['li.',o.hoverClass].join()).length<1){over.call(o.$path);} },o.delay);     },    getMenu = function($menu){     var menu = $menu.parents(['ul.',c.menuClass,':first'].join())[0]; sf.op = sf.o[menu.serial];     return menu;    },    addArrow = function($a){ $a.addClass(c.anchorClass).append($arrow.clone()); };
return this.each(function() {    var s = this.serial = sf.o.length;    var o = $.extend({},sf.defaults,op);    o.$path = $('li.'+o.pathClass,this).slice(0,o.pathLevels).each(function(){     $(this).addClass([o.hoverClass,c.bcClass].join(' '))      .filter('li:has(ul)').removeClass(o.pathClass);    });    sf.o[s] = sf.op = o;
$('li:has(ul)',this)[($.fn.hoverIntent && !o.disableHI) ? 'hoverIntent' : 'hover'](over,out).each(function() {     if (o.autoArrows) addArrow( $('>a:first-child',this) );    })    .not('.'+c.bcClass)     .hideSuperfishUl();
var $a = $('a',this);    $a.each(function(i){     var $li = $a.eq(i).parents('li');     $a.eq(i).focus(function(){over.call($li);}).blur(function(){out.call($li);});    });    o.onInit.call(this);
}).each(function() {    var menuClasses = [c.menuClass];    if (sf.op.dropShadows && !($.browser.msie && $.browser.version < 7)) menuClasses.push(c.shadowClass);    $(this).addClass(menuClasses.join(' '));   });  };
var sf = $.fn.superfish;  sf.o = [];  sf.op = {};  sf.IE7fix = function(){   var o = sf.op;   if ($.browser.msie && $.browser.version > 6 && o.dropShadows && o.animation.opacity!=undefined)    this.toggleClass(sf.c.shadowClass+'-off');   };  sf.c = {   bcClass  : 'sf-breadcrumb',   menuClass  : 'sf-js-enabled',   anchorClass : 'sf-with-ul',   arrowClass  : 'sf-sub-indicator',   shadowClass : 'sf-shadow'  };  sf.defaults = {   hoverClass : 'sfHover',   pathClass : 'overideThisToUse',   pathLevels : 1,   delay  : 800,   animation : {opacity:'show'},   speed  : 'normal',   autoArrows : true,   dropShadows : true,   disableHI : false,  // true disables hoverIntent detection   onInit  : function(){}, // callback functions   onBeforeShow: function(){},   onShow  : function(){},   onHide  : function(){}  };  $.fn.extend({   hideSuperfishUl : function(){    var o = sf.op,     not = (o.retainPath===true) ? o.$path : ; o.retainPath = false;    var $ul = $(['li.',o.hoverClass].join(),this).add(this).not(not).removeClass(o.hoverClass) .find('>ul').hide().css('visibility','hidden');    o.onHide.call($ul);    return this;   },   showSuperfishUl : function(){    var o = sf.op,     sh = sf.c.shadowClass+'-off',     $ul = this.addClass(o.hoverClass)      .find('>ul:hidden').css('visibility','visible');    sf.IE7fix.call($ul);    o.onBeforeShow.call($ul);    $ul.animate(o.animation,o.speed,function(){ sf.IE7fix.call($ul); o.onShow.call($ul); });    return this;   }  });
})(jQuery);
/* jQuery Image Magnify script v1.1
This notice must stay intact for usage
Author: Dynamic Drive at http://www.dynamicdrive.com/
Visit http://www.dynamicdrive.com/ for full source code
Nov 16th, 09 (v1.1): Adds ability to dynamically apply/reapply magnify effect to an image, plus magnify to a specific width in pixels.
Feb 8th, 11 (v1.11): Fixed bug that caused script to not work in newever versions of jQuery (ie: v1.4.4)
/
jQuery.imageMagnify={  dsettings: {   magnifyby: 3, //default increase factor of enlarged image   duration: 500, //default duration of animation, in millisec   imgopacity: 0.2 //opacify of original image when enlarged image overlays it
},
cursorcss: 'url( http://www.dynamicdrive.com/dynamicindex4/magnify.cur ), -moz-zoom-in', //Value for CSS's 'cursor' attribute, added to original image  zIndexcounter: 100,
refreshoffsets:function($window, $target, warpshell){   var $offsets=$target.offset()   var winattrs={x:$window.scrollLeft(), y:$window.scrollTop(), w:$window.width(), h:$window.height()}   warpshell.attrs.x=$offsets.left //update x position of original image relative to page   warpshell.attrs.y=$offsets.top   warpshell.newattrs.x=winattrs.x+winattrs.w/2-warpshell.newattrs.w/2   warpshell.newattrs.y=winattrs.y+winattrs.h/2-warpshell.newattrs.h/2   if (warpshell.newattrs.x<winattrs.x+5){ //no space to the left?    warpshell.newattrs.x=winattrs.x+5    }   else if (warpshell.newattrs.x+warpshell.newattrs.w > winattrs.x+winattrs.w){//no space to the right?    warpshell.newattrs.x=winattrs.x+5   }   if (warpshell.newattrs.y<winattrs.y+5){ //no space at the top?    warpshell.newattrs.y=winattrs.y+5   }  },
magnify:function($, $target, options){   var setting={} //create blank object to store combined settings   var setting=jQuery.extend(setting, this.dsettings, options)   var attrs=(options.thumbdimensions)? {w:options.thumbdimensions[0], h:options.thumbdimensions[1]} : {w:$target.outerWidth(), h:$target.outerHeight()}   var newattrs={}   newattrs.w=(setting.magnifyto)? setting.magnifyto : Math.round(attrs.w*setting.magnifyby)   newattrs.h=(setting.magnifyto)? Math.round(attrs.h*newattrs.w/attrs.w) : Math.round(attrs.h*setting.magnifyby)   $target.css('cursor', jQuery.imageMagnify.cursorcss)   if ($target.data('imgshell')){    $target.data('imgshell').$clone.remove()    $target.css({opacity:1}).unbind('click.magnify')   }    var $clone=$target.clone().css({position:'absolute', left:0, top:0, visibility:'hidden', border:'1px solid gray', cursor:'pointer'}).appendTo(document.body)   $clone.data('$relatedtarget', $target) //save $target image this enlarged image is associated with   $target.data('imgshell', {$clone:$clone, attrs:attrs, newattrs:newattrs})   $target.bind('click.magnify', function(e){ //action when original image is clicked on    var $this=$(this).css({opacity:setting.imgopacity})    var imageinfo=$this.data('imgshell')    jQuery.imageMagnify.refreshoffsets($(window), $this, imageinfo) //refresh offset positions of original and warped images    var $clone=imageinfo.$clone    $clone.stop().css({zIndex:++jQuery.imageMagnify.zIndexcounter, left:imageinfo.attrs.x, top:imageinfo.attrs.y, width:imageinfo.attrs.w, height:imageinfo.attrs.h, opacity:0, visibility:'visible', display:'block'})    .animate({opacity:1, left:imageinfo.newattrs.x, top:imageinfo.newattrs.y, width:imageinfo.newattrs.w, height:imageinfo.newattrs.h}, setting.duration,    function(){ //callback function after warping is complete     //none added      }) //end animate   }) //end click   $clone.click(function(e){ //action when magnified image is clicked on    var $this=$(this)    var imageinfo=$this.data('$relatedtarget').data('imgshell')    jQuery.imageMagnify.refreshoffsets($(window), $this.data('$relatedtarget'), imageinfo) //refresh offset positions of original and warped images    $this.stop().animate({opacity:0, left:imageinfo.attrs.x, top:imageinfo.attrs.y, width:imageinfo.attrs.w, height:imageinfo.attrs.h},  setting.duration,    function(){     $this.hide()     $this.data('$relatedtarget').css({opacity:1}) //reveal original image    }) //end animate   }) //end click  } };
jQuery.fn.imageMagnify=function(options){  var $=jQuery  return this.each(function(){ //return jQuery obj   var $imgref=$(this)   if (this.tagName!="IMG")    return true //skip to next matched element   if (parseInt($imgref.css('width'))>0 && parseInt($imgref.css('height'))>0 || options.thumbdimensions){ //if image has explicit width/height attrs defined    jQuery.imageMagnify.magnify($, $imgref, options)   }   else if (this.complete){ //account for IE not firing image.onload    jQuery.imageMagnify.magnify($, $imgref, options)   }   else{    $(this).bind('load', function(){     jQuery.imageMagnify.magnify($, $imgref, options)    })   }  }) };
jQuery.fn.applyMagnifier=function(options){ //dynamic version of imageMagnify() to apply magnify effect to an image dynamically  var $=jQuery  return this.each(function(){ //return jQuery obj   var $imgref=$(this)   if (this.tagName!="IMG")    return true //skip to next matched element
})
};
//** The following applies the magnify effect to images with class="magnify" and optional "data-magnifyby" and "data-magnifyduration" attrs //** It also looks for links with attr rel="magnify[targetimageid]" and makes them togglers for that image
jQuery(document).ready(function($){  var $targets=$('.magnify')  $targets.each(function(i){   var $target=$(this)   var options={}   if ($target.attr('data-magnifyto'))    options.magnifyto=parseFloat($target.attr('data-magnifyto'))   if ($target.attr('data-magnifyby'))    options.magnifyby=parseFloat($target.attr('data-magnifyby'))   if ($target.attr('data-magnifyduration'))    options.duration=parseInt($target.attr('data-magnifyduration'))   $target.imageMagnify(options)  })  var $triggers=$('a[rel^="magnify["]')  $triggers.each(function(i){   var $trigger=$(this)   var targetid=$trigger.attr('rel').match(/\[.+\]/)[0].replace(/[\[\]']/g, ) //parse 'id' from rel='magnify[id]' $trigger.data('magnifyimageid', targetid)   $trigger.click(function(e){    $('#'+$(this).data('magnifyimageid')).trigger('click.magnify')    e.preventDefault()   })  }) })
Retrieved from " http://2012.igem.org/Team:UC_Chile/Templates/js/finaljs "
Recent changes
What links here
Related changes
Special pages
My preferences
Printable version
Permanent link
Privacy policy
Disclaimers

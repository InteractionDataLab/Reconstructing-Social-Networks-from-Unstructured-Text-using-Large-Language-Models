<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Groningen_Modeling_Supporting_material skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Groningen/Modeling/Supporting material</SPAN></H1><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><DIV class="container default screen p1080 details black" id="697ba9800bfd490ea793813ca64040cd"><DIV class="entry header"><DIV class="logo"> </DIV><DIV class="title">Blue Bio Energy</DIV><DIV class="menu"><DIV class="item active"><A class="title" href="https://2015.igem.org/Team:Groningen">Home</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Team">Team</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Description">Project</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Results">Results</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Modeling">Modeling</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Notebook">Notebook</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Parts">Parts</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Attributions">Attributions</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Collaborations">Collaborations</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Design">Design</A></DIV><DIV class="wrapper"><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Human_Practices">Human Practices</A></DIV><DIV class="group"><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Regulations">Regulations</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Media_Coverage">Media Coverage</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Events">Events</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Card_Game">Card Game</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Future">Future</A></DIV></DIV></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Safety">Safety</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Measurement">Measurement</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Supervisors">Supervisors</A></DIV></DIV><DIV class="menu secondary"><DIV class="button"><DIV class="title">Menu</DIV></DIV><DIV class="group"><DIV class="item active"><A class="title" href="https://2015.igem.org/Team:Groningen">Home</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Team">Team</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Description">Project</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Results">Results</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Modeling">Modeling</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Notebook">Notebook</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Parts">Parts</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Attributions">Attributions</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Collaborations">Collaborations</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Design">Design</A></DIV><DIV class="wrapper"><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Human_Practices">Human Practices</A></DIV><DIV class="group"><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Regulations">Regulations</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Media_Coverage">Media Coverage</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Events">Events</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Card_Game">Card Game</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Future">Future</A></DIV></DIV></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Safety">Safety</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Measurement">Measurement</A></DIV><DIV class="item"><A class="title" href="https://2015.igem.org/Team:Groningen/Supervisors">Supervisors</A></DIV></DIV></DIV></DIV><DIV class="entry main"><DIV class="title">Supporting material</DIV><DIV class="module content"><DIV class="title" id="mdintro">Introduction to molecular dynamics</DIV><DIV class="text">
Molecular dynamics is used to simulate the the physical motion of atoms and molecules. It can for example be used to simulate how lipids of a cell membrane behave, how a fictitious material would perform, if a protein would denaturalize in water or how a liposome fuses with a membrane. The simulation itself is based on Newton's laws of motion, that define classical mechanics, and force fields. These laws are as follows:
</DIV><DIV class="listing"><DIV class="item">If no force is applied, the object continues at it current speed.</DIV><DIV class="item">The acceleration of the object is equal to its mass and the sum of the forces applied to the object.</DIV><DIV class="item">When an object influences another object then the force on the second object is equal to the exerted force, but in the opposite direction.</DIV></DIV><DIV class="text">
These laws by themselves are not enough to simulate the motions of atoms and molecules. The forces that are mention in these laws have to be defined. The forces are defined by force fields in molecular dynamics simulations. Depending on the contents of the simulation some may be better than others, because one could model electrostatic interactions well while others are good for studying phase separations. Often these force fields are based on experimental data and have certain trade offs, therefore even for something as common as water different force fields exist.
</DIV><DIV class="text">
There are however a few limitations to keep in mind. First of all, because these simulations are build from small elements, the simulations grows very fast. This in turn means that the simulations can take a long time even though the systems dimensions are usually on the scale of nanometers.
Not only can the systems take long because they contain a lot of elements, but the effect of interest happens after a long time (the nanoseconds and microseconds range). Secondly because classical molecular dynamics is based on Newton’s laws of motion, it does not have chemical reactions. Lastly the behavior the simulations exhibit strongly depend on the input and the settings. For example the initial position might cause excessive forces and thus crashes the program.
</DIV><DIV class="title" id="vmd">Visualization with VMD</DIV><DIV class="text">
To view the results of a simulation VMD is a great tool (version 1.9.2 was used in this text). While it has many advanced features, not many need to be known to effectively use it. Before one can use VMD one has to load the system topology and optionally the trajectory in it. This is usually done with the following command: “vmd -f topology trajectory”. With the “-f” option in the command one specifies that the following files belong together. Now that the topology and trajectory is loaded, one can visualize the data.  Sometimes it is also useful to see the periodic boundary conditions. To show them one has to enter “pbc box” into VMD's console and to hide them “pbc box -off”.
</DIV><DIV class="text">
Firstly one can change how groups of atoms/beads (selections) are represented. The current rules are shown in the Graphics -&gt; Representations menu. The most useful drawing styles with the MARTINI systems are the VDW and the QuickSurf options. With VDW VMD shows the van der waals radii for each atom/bead and with QuickSurf shows the surface of the selection. The selected atoms/beads can be changed by typing a selection “string” in the Selected Atoms field or by clicking in the Selection tab. For more details one could consult the documentation of VMD or do some tutorials. Some starting keywords are “resname”, “index”, “name” and “within of”.
</DIV><DIV class="text">
Secondly it is possible to orientate the system differently. This is done by dragging on the output screen of VMD after pressing one of the hotkeys mentioned in Table <A href="#torien" class="link">1</A>. 
</DIV><DIV class="object data" id="torien"><DIV class="wrapper"><DIV class="header"><DIV class="field fw1">Key</DIV><DIV class="field fw7">Description</DIV></DIV><DIV class="record"><DIV class="field fw1">r</DIV><DIV class="field fw7">rotate the system</DIV></DIV><DIV class="record"><DIV class="field fw1">t</DIV><DIV class="field fw7">translate the system</DIV></DIV><DIV class="record"><DIV class="field fw1">s</DIV><DIV class="field fw7">scale the system</DIV></DIV><DIV class="record"><DIV class="field fw1">=</DIV><DIV class="field fw7">reset the system orientation</DIV></DIV></DIV><DIV class="caption">Hotkeys related to the orientation of the system. When VMD is started, it is in the rotation mode.</DIV></DIV><DIV class="text">
Thirdly it is possible to label particles and measure things. An overview of some useful hotkeys are given in Table <A href="#tlmes" class="link">2</A>. The information VMD shows in these cases can be changed in the Graphics -&gt; Labels menu. For example in the properties tab of a label one can change the format to “%1i”, so that VMD shows the atom index starts from one, like the numbering in the Gromacs topology files. Also note that VMD shows distances in ångström.
</DIV><DIV class="object data" id="tlmes"><DIV class="wrapper"><DIV class="header"><DIV class="field fw1">Key</DIV><DIV class="field fw7">Description</DIV></DIV><DIV class="record"><DIV class="field fw1">1</DIV><DIV class="field fw7">label the atom/bead</DIV></DIV><DIV class="record"><DIV class="field fw1">2</DIV><DIV class="field fw7">measure the distance between two particles</DIV></DIV><DIV class="record"><DIV class="field fw1">3</DIV><DIV class="field fw7">measure the angle between three particles</DIV></DIV><DIV class="record"><DIV class="field fw1">4</DIV><DIV class="field fw7">measure the dihedral between four particles</DIV></DIV></DIV><DIV class="caption">Hotkeys related to the label and measurement modes.</DIV></DIV><DIV class="text">
Lastly sometimes it is useful to have the bond information in VMD, so that it can show the bonds between the coarse grained molecules. This can be done with the cg_bonds script provided on the MARTINI homepage (<A href="http://www.cgmartini.nl/" class="link">link</A>, 2015).
</DIV><DIV class="text">
Sometimes one needs better looking images than just screenshots from the program. This is possible with the rendering options in VMD. One has to edit the representation, change some options and then one can options to get a nice picture.
</DIV><DIV class="text">
In general there are a three things that make the final image look a lot better. Firstly enabling shadows and ambient occlusion in the ray tracing options in the Display -&gt; Display Settings menu. Secondly using a nice material for the selections like ''AOChalky''. And lastly using a ray tracer to render the image. VMD comes with the Tachyon ray tracer. This renderer can be selected in the the File -&gt; Render menu, before rendering the picture by hitting the start rendering button in the same menu. Note that movies can also be made in a similar matter with the movie maker extension.
</DIV><DIV class="title" id="scripts">Scripts</DIV><DIV class="text">
All the python scripts are made for python 2.7. There are scripts for the following things:
</DIV><DIV class="listing"><DIV class="item">PGA topology creation (<A href="#scpga" class="link">link</A>)</DIV><DIV class="item">Cellulose topology creation (<A href="#sccell" class="link">link</A>)</DIV><DIV class="item">Cellulose phosphate topology creation (<A href="#sccellp" class="link">link</A>)</DIV><DIV class="item">Changing the concentration and preparing the membranes (<A href="#scchmem" class="link">link</A>)</DIV><DIV class="item">Calculating the flow of ions through the membranes (<A href="#scnaclw" class="link">link</A>)</DIV></DIV><DIV class="subtitle" id="scpga">PGA topology creation</DIV><DIV class="object code"><DIV class="caption">This script can be used to generate a PGA topology file.</DIV><DIV class="raw"><CODE class="python">
#/usr/bin/python

namef = 'pga{}.itp'
num = 100

def outputLine(f, line):
	def p(*args):
		f.write(line.format(*args))
	return p

def printAtoms(f, num):
	f.write(';nr\ttype\tresnr\tresidu\tatom\tcgnr\tcharge\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\t{0}\t{5: d}\n')

	pa(1, 'Qd', 1, 'PGATN', 'NCC', 1)
	pa(2, 'Qa', 1, 'PGATN', 'OCO', -1)
	pa(3, 'Na', 1, 'PGATN', 'CCO', 0)

	for x in range(0, num - 2):
		i = 3 * x + 4
		pa(i, 'Nd', x + 2, 'PGAM', 'NCHC', 0)
		pa(i + 1, 'Qa', x + 2, 'PGAM', 'OCO', -1)
		pa(i + 2, 'Na', x + 2, 'PGAM', 'CCO', 0)

	i = 3 * num - 2
	pa(i, 'Nd', num, 'PGATO', 'NCHC', 0)
	pa(i + 1, 'Qa', num, 'PGATO', 'OCO', -1)
	pa(i + 2, 'Qa', num, 'PGATO', 'OCO', -1)


def printBonds(f, num):
	f.write(&quot;;i\tj\tfunct\tlength\tforce.c.\n&quot;)
	pb = outputLine(f, '{0}\t{1}\t1\t{2}\t{3}\n')
	
	pb(1, 2, 0.23, 18000)
	pb(1, 3, 0.33, 4000)
	
	for x in range(0, num - 2):
		i = 3 * x + 3
		pb(i, i + 1, 0.28, 12000)
		pb(i + 1, i + 2, 0.24, 22000)
		pb(i + 1, i + 3, 0.32, 2000)

	i = 3 * num - 2
	pb(i - 1, i, 0.28, 12000)
	pb(i, i + 1, 0.24, 18000)
	pb(i, i + 2, 0.36, 4000)


def printAngles(f, num):
	f.write(';i\tj\tk\tfunct\tangle\tforce.c.\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t2\t{3}\t{4}\n')
	pa(2, 1, 3, 111.013, 100)
	pa(1, 3, 4, 141.237, 55)

	for x in range(0, num - 2):
		i = 3 * x + 3
		# next one is the same as the first one of the terminal end
		pa(i, i + 1, i + 2, 114.646, 25)
		pa(i, i + 1, i + 3, 124.643, 250)
		pa(i + 1, i + 3, i + 4, 133.794, 250)
		pa(i + 2, i + 1, i + 3, 113.393, 40)
	i = 3 * num - 3
	pa(i, i + 1, i + 2, 114.646, 25)
	pa(i, i + 1, i + 3, 127.488, 100)
	pa(i + 2, i + 1, i + 3, 116.572, 45)

def main():
	with open(namef.format(num), 'w') as f:
		f.write('[ moleculetype ]\n;molname\tnrexcl\nPGA{}\t\t1\n'.format(num))
		f.write('\n[ atoms ]\n')
		printAtoms(f, num)
		f.write('\n[ bonds ]\n')
		printBonds(f, num)
		f.write('\n[ angles ]\n')
		printAngles(f, num)

if __name__ == &quot;__main__&quot;:
    main()
</CODE></DIV></DIV><DIV class="subtitle" id="sccell">Cellulose topology creation</DIV><DIV class="object code"><DIV class="caption">This script can be used to generate a cellulose topology file and a initial coordinates file.</DIV><DIV class="raw"><CODE class="python">
#!/usr/bin/python

import math

namef = 'cellulose{}.{}'
name = 'CELL{}'
num = 2
monomer = {&quot;atoms&quot;: [(&quot;P1&quot;, &quot;CELL&quot;, &quot;B1&quot;, 0.0, 44.0534),
		     (&quot;P2&quot;, &quot;CELL&quot;, &quot;B2&quot;, 0.0, 75.0442),
		     (&quot;P4&quot;, &quot;CELL&quot;, &quot;B3&quot;, 0.0, 60.0528),
		     (&quot;P2&quot;, &quot;CELL&quot;, &quot;B4&quot;, 0.0, 58.0368),
		     (&quot;P1&quot;, &quot;CELL&quot;, &quot;B5&quot;, 0.0, 44.0534),
		     (&quot;P4&quot;, &quot;CELL&quot;, &quot;B6&quot;, 0.0, 60.0528)],
	  &quot;bonds&quot;: [(1, 2, 1, 0.242, 30000),
		    (2, 3, 1, 0.284, 30000),
		    (2, 4, 1, 0.518, 30000),
		    (4, 5, 1, 0.234, 30000),
		    (4, 6, 1, 0.278, 30000)],
	  &quot;constraints&quot;: [],
	  &quot;angles&quot;: [(1, 2, 4, 2, 126, 50),
		     (3, 2, 4, 2, 120, 50),
		     (5, 4, 2, 2, 60, 100),
		     (6, 4, 2, 2, 65, 25)],
	  &quot;dihedrals&quot;: [(1, 2, 4, 5, 1, 30, 8, 1),
			(1, 2, 4, 6, 1, -150, 5, 1),
			(3, 2, 4, 5, 1, -150, 5, 1)]}

def outputLine(f, line):
	def p(*args):
		f.write(line.format(*args))
	return p

def printAtoms(f, num):
	f.write('\n[ atoms ]\n')
	f.write(';nr\ttype\tresnr\tresidu\tatom\tcgnr\tcharge\tmass\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\t{0}\t{5: .4f}\t{6: .4f}\n')
	
	monolen = len(monomer[&quot;atoms&quot;])
	atomcnt = num * monolen
	atoms = num * monomer[&quot;atoms&quot;]
	resnr = 1
	for x in range(0, atomcnt):
		atype, res, atom, charge, mass = atoms[x]
		pa(x + 1, atype, resnr, res, atom, charge, mass)
		if x % monolen == monolen - 1:
			resnr += 1

def printBonds(f, num):
	f.write('\n[ bonds ]\n')
	f.write(';i\tj\tfunct\tlength\tforce.c.\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\n')

	numatoms = len(monomer[&quot;atoms&quot;])
	numbonds = len(monomer[&quot;bonds&quot;])
	if numbonds &gt; 0:
		for x in range(0, num):
			for bond in monomer[&quot;bonds&quot;]:
				i, j, funct, leng, forc = bond
				i = i + x * numatoms
				j = j + x * numatoms
				pa(i, j, funct, leng, forc)
		f.write(';inter monomer bonds\n')
		for x in range(0, num - 1):
			i, j, funct, leng, forc = monomer[&quot;bonds&quot;][2]
	 		i = i + 2 + x * numatoms
			j = j + 4 + x * numatoms
			pa(i, j, funct, leng, forc)
		
def printConstraints(f, num):
	f.write('\n[ constraints ]\n')
	f.write(&quot;;i\tj\tfunct\tlength\tforce.c.\n&quot;)
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\n')

	numatoms = len(monomer[&quot;atoms&quot;])
	numconstraints = len(monomer[&quot;constraints&quot;])
	if numconstraints &gt; 0:
		for x in range(0, num):
			for bond in monomer[&quot;constraints&quot;]:
				i, j, funct, leng, forc = bond
				i = i + x * numatoms
				j = j + x * numatoms
				pa(i, j, funct, leng, forc)
		f.write(';inter monomer constraints\n')
		for x in range(0, num - 1):
			i, j, funct, leng, forc = monomer[&quot;constraints&quot;][2]
			i = i + 2 + x * numatoms
			j = j + 4 + x * numatoms
			pa(i, j, funct, leng, forc)

def printAngles(f, num):
	f.write('\n[ angles ]\n')
	f.write(';i\tj\tk\tfunct\tangle\tforce.c.\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\t{5}\n')

	numatoms = len(monomer[&quot;atoms&quot;])
	for x in range(0, num):
		for angle in monomer[&quot;angles&quot;]:
			i, j, k, funct, leng, forc = angle
			i = i + x * numatoms
			j = j + x * numatoms
			k = k + x * numatoms
			pa(i, j, k, funct, leng, forc)
	f.write(';backbone angles between monomers\n')
	angles = [(2, 4, 8, 2, 168, 50),
		  (4, 8, 10, 2, 168, 50)]
	for x in range(0, num - 1):
		for angle in angles:
			i, j, k, funct, leng, forc = angle
			i = i + x * numatoms
			j = j + x * numatoms
			k = k + x * numatoms
			pa(i, j, k, funct, leng, forc)

def printDihedrals(f, num):
	f.write('\n[ dihedrals ]\n')
	f.write(';i\tj\tk\tl\tfunct\tangle\tforce.c.\tmultiplic.\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\t{7}\n')

	numatoms = len(monomer[&quot;atoms&quot;])
	for x in range(0, num):
		for dihedral in monomer[&quot;dihedrals&quot;]:
			i, j, k, l, funct, leng, forc, multi = dihedral
			i = i + x * numatoms
			j = j + x * numatoms
			k = k + x * numatoms
			l = l + x * numatoms
			pa(i, j, k, l, funct, leng, forc, multi)
	f.write(';inter monomer dihedrals\n')
	dihedrals = [(7, 8, 4, 5, 1, 30, 5, 1),
		    (7, 8, 4, 6, 1, -150, 5, 1),
		    (9, 8, 4, 5, 1, -150, 5, 1)]
	for x in range(0, num - 1):
		for dihedral in dihedrals:
			i, j, k, l, funct, leng, forc, multi = dihedral
			i = i + x * numatoms
			j = j + x * numatoms
			k = k + x * numatoms
			l = l + x * numatoms
			pa(i, j, k, l, funct, leng, forc, multi)

def main():
        with open(namef.format(num, 'itp'), 'w') as f:
                f.write('[ moleculetype ]\n;molname\tnrexcl\n' + name.format(num) + '\t\t1\n')
                printAtoms(f, num)
                printBonds(f, num)
                printConstraints(f, num)
                printAngles(f, num)
                printDihedrals(f, num)

        with open(namef.format(num, 'gro'), 'w') as f:
                f.write('cellulose\n{}\n'.format(num * len(monomer[&quot;atoms&quot;])))
                y, z = (1, 1)
                for i in range(0, num):
                        x = 0.23 + i * 2 * 0.518 * math.cos(math.radians(6))
                        andx = 1 + i * 6
                        resnr = 1 + i * 2
                        x1 = x - 0.242 * math.cos(math.radians(48))
                        y1 = y + 0.242 * math.sin(math.radians(48))
                        x3 = x - 0.284 * math.sin(math.radians(54))
                        y3 = y - 0.284 * math.cos(math.radians(54))
                        x4 = x + 0.518 * math.cos(math.radians(6))
                        y4 = y + 0.518 * math.sin(math.radians(6))
                        a5 = 0.234 * math.cos(math.radians(60))
                        s5 = 0.234 * math.sin(math.radians(60))
                        x5 = x4 - a5 * math.cos(math.radians(6))
                        y5 = y4 - a5 * math.sin(math.radians(6)) + s5 * math.cos(math.radians(30))
                        z5 = z + s5 * math.sin(math.radians(30))
                        a6 = 0.278 * math.cos(math.radians(65))
                        s6 = 0.278 * math.sin(math.radians(65))
                        x6 = x4 - a6 * math.cos(math.radians(6))
                        y6 = y4 + a6 * math.sin(math.radians(6)) + s6 * math.cos(math.radians(-150))
                        z6 = z + s6 * math.sin(math.radians(-150))
                        f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr, &quot;CELL&quot;, &quot;B1&quot;, andx, x1, y1, z))
                        f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr, &quot;CELL&quot;, &quot;B2&quot;, andx + 1, x, y, z))
                        f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr, &quot;CELL&quot;, &quot;B3&quot;, andx + 2, x3, y3, z))
                        f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr + 1, &quot;CELL&quot;, &quot;B4&quot;, andx + 3, x4, y4, z))
                        f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr + 1, &quot;CELL&quot;, &quot;B5&quot;, andx + 4, x5, y5, z5))
                        f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr + 1, &quot;CELL&quot;, &quot;B6&quot;, andx + 5, x6, y6, z6))
                f.write(&quot;%10.5f%10.5f%10.5f\n&quot; % (x * 2, y * 2, z * 2))
                
if __name__ == &quot;__main__&quot;:
    main()
</CODE></DIV></DIV><DIV class="subtitle" id="sccellp">Cellulose phosphate topology creation</DIV><DIV class="object code"><DIV class="caption">This script can be used to generate a cellulose phosphate topology file and a initial coordinates file.</DIV><DIV class="raw"><CODE class="python">
#!/usr/bin/python

import math

namef = 'cellulosephos{}.{}'
name = 'CELLP{}'
num = 10
monomer = {&quot;atoms&quot;: [(&quot;Qa&quot;, &quot;CELLP&quot;, &quot;B1&quot;, -2.0, 44.0534),
		     (&quot;P2&quot;, &quot;CELLP&quot;, &quot;B2&quot;, 0.0, 75.0442),
		     (&quot;P4&quot;, &quot;CELLP&quot;, &quot;B3&quot;, 0.0, 60.0528),
		     (&quot;P2&quot;, &quot;CELLP&quot;, &quot;B4&quot;, 0.0, 58.0368),
		     (&quot;Qa&quot;, &quot;CELLP&quot;, &quot;B5&quot;, -2.0, 44.0534),
		     (&quot;P4&quot;, &quot;CELLP&quot;, &quot;B6&quot;, 0.0, 60.0528)],
	  &quot;bonds&quot;: [(1, 2, 1, 0.242, 30000),
		    (2, 3, 1, 0.284, 30000),
		    (2, 4, 1, 0.518, 30000),
		    (4, 5, 1, 0.234, 30000),
		    (4, 6, 1, 0.278, 30000)],
	  &quot;constraints&quot;: [],
	  &quot;angles&quot;: [(1, 2, 4, 2, 126, 50),
		     (3, 2, 4, 2, 120, 50),
		     (5, 4, 2, 2, 60, 100),
		     (6, 4, 2, 2, 65, 25)],
	  &quot;dihedrals&quot;: [(1, 2, 4, 5, 1, 30, 8, 1),
			(1, 2, 4, 6, 1, -150, 5, 1),
			(3, 2, 4, 5, 1, -150, 5, 1)]}

def outputLine(f, line):
	def p(*args):
		f.write(line.format(*args))
	return p

def printAtoms(f, num):
	f.write('\n[ atoms ]\n')
	f.write(';nr\ttype\tresnr\tresidu\tatom\tcgnr\tcharge\tmass\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\t{0}\t{5: .4f}\t{6: .4f}\n')
	
	monolen = len(monomer[&quot;atoms&quot;])
	atomcnt = num * monolen
	atoms = num * monomer[&quot;atoms&quot;]
	resnr = 1
	for x in range(0, atomcnt):
		atype, res, atom, charge, mass = atoms[x]
		pa(x + 1, atype, resnr, res, atom, charge, mass)
		if x % monolen == monolen - 1:
			resnr += 1

def printBonds(f, num):
	f.write('\n[ bonds ]\n')
	f.write(';i\tj\tfunct\tlength\tforce.c.\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\n')

	numatoms = len(monomer[&quot;atoms&quot;])
	numbonds = len(monomer[&quot;bonds&quot;])
	if numbonds &gt; 0:
		for x in range(0, num):
			for bond in monomer[&quot;bonds&quot;]:
				i, j, funct, leng, forc = bond
				i = i + x * numatoms
				j = j + x * numatoms
				pa(i, j, funct, leng, forc)
		f.write(';inter monomer bonds\n')
		for x in range(0, num - 1):
			i, j, funct, leng, forc = monomer[&quot;bonds&quot;][2]
	 		i = i + 2 + x * numatoms
			j = j + 4 + x * numatoms
			pa(i, j, funct, leng, forc)
		
def printConstraints(f, num):
	f.write('\n[ constraints ]\n')
	f.write(&quot;;i\tj\tfunct\tlength\tforce.c.\n&quot;)
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\n')

	numatoms = len(monomer[&quot;atoms&quot;])
	numconstraints = len(monomer[&quot;constraints&quot;])
	if numconstraints &gt; 0:
		for x in range(0, num):
			for bond in monomer[&quot;constraints&quot;]:
				i, j, funct, leng, forc = bond
				i = i + x * numatoms
				j = j + x * numatoms
				pa(i, j, funct, leng, forc)
		f.write(';inter monomer constraints\n')
		for x in range(0, num - 1):
			i, j, funct, leng, forc = monomer[&quot;constraints&quot;][2]
			i = i + 2 + x * numatoms
			j = j + 4 + x * numatoms
			pa(i, j, funct, leng, forc)

def printAngles(f, num):
	f.write('\n[ angles ]\n')
	f.write(';i\tj\tk\tfunct\tangle\tforce.c.\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\t{5}\n')

	numatoms = len(monomer[&quot;atoms&quot;])
	for x in range(0, num):
		for angle in monomer[&quot;angles&quot;]:
			i, j, k, funct, leng, forc = angle
			i = i + x * numatoms
			j = j + x * numatoms
			k = k + x * numatoms
			pa(i, j, k, funct, leng, forc)
	f.write(';backbone angles between monomers\n')
	angles = [(2, 4, 8, 2, 168, 50),
		  (4, 8, 10, 2, 168, 50)]
	for x in range(0, num - 1):
		for angle in angles:
			i, j, k, funct, leng, forc = angle
			i = i + x * numatoms
			j = j + x * numatoms
			k = k + x * numatoms
			pa(i, j, k, funct, leng, forc)

def printDihedrals(f, num):
	f.write('\n[ dihedrals ]\n')
	f.write(';i\tj\tk\tl\tfunct\tangle\tforce.c.\tmultiplic.\n')
	pa = outputLine(f, '{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t{6}\t{7}\n')

	numatoms = len(monomer[&quot;atoms&quot;])
	for x in range(0, num):
		for dihedral in monomer[&quot;dihedrals&quot;]:
			i, j, k, l, funct, leng, forc, multi = dihedral
			i = i + x * numatoms
			j = j + x * numatoms
			k = k + x * numatoms
			l = l + x * numatoms
			pa(i, j, k, l, funct, leng, forc, multi)
	f.write(';inter monomer dihedrals\n')
	dihedrals = [(7, 8, 4, 5, 1, 30, 5, 1),
                    (7, 8, 4, 6, 1, -150, 5, 1),
                    (9, 8, 4, 5, 1, -150, 5, 1)]
	for x in range(0, num - 1):
		for dihedral in dihedrals:
			i, j, k, l, funct, leng, forc, multi = dihedral
			i = i + x * numatoms
			j = j + x * numatoms
			k = k + x * numatoms
			l = l + x * numatoms
			pa(i, j, k, l, funct, leng, forc, multi)

def main():
	with open(namef.format(num, 'itp'), 'w') as f:
		f.write('[ moleculetype ]\n;molname\tnrexcl\n' + name.format(num) + '\t\t1\n')
		printAtoms(f, num)
		printBonds(f, num)
		printConstraints(f, num)
		printAngles(f, num)
		printDihedrals(f, num)

	with open(namef.format(num, 'gro'), 'w') as f:
		f.write('cellulose\n{}\n'.format(num * len(monomer[&quot;atoms&quot;])))
		y, z = (1, 1)
		for i in range(0, num):
			x = 0.23 + i * 2 * 0.518 * math.cos(math.radians(6))
			andx = 1 + i * 6
			resnr = 1 + i * 2
			x1 = x - 0.242 * math.cos(math.radians(48))
			y1 = y + 0.242 * math.sin(math.radians(48))
			x3 = x - 0.284 * math.sin(math.radians(54))
			y3 = y - 0.284 * math.cos(math.radians(54))
			x4 = x + 0.518 * math.cos(math.radians(6))
			y4 = y + 0.518 * math.sin(math.radians(6))
			x5 = x4 - 0.234 * math.cos(math.radians(54))
			y5 = y4 + 0.234 * math.sin(math.radians(54))
			z5 = z + 0.234 * math.sin(math.radians(60))
			x6 = x4 - 0.278 * math.sin(math.radians(19)) 
			y6 = y4 - 0.278 * math.cos(math.radians(19))
			z6 = z - 0.278 * math.sin(math.radians(30))
			f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr, &quot;CELLP&quot;, &quot;B1&quot;, andx, x1, y1, z))
			f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr, &quot;CELLP&quot;, &quot;B2&quot;, andx + 1, x, y, z))
			f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr, &quot;CELLP&quot;, &quot;B3&quot;, andx + 2, x3, y3, z))
			f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr + 1, &quot;CELLP&quot;, &quot;B4&quot;, andx + 3, x4, y4, z))
			f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr + 1, &quot;CELLP&quot;, &quot;B5&quot;, andx + 4, x5, y5, z5))
			f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnr + 1, &quot;CELLP&quot;, &quot;B6&quot;, andx + 5, x6, y6, z6))
		f.write(&quot;%10.5f%10.5f%10.5f\n&quot; % (x * 2, y * 2, z * 2))
		
if __name__ == &quot;__main__&quot;:
    main()
</CODE></DIV></DIV><DIV class="subtitle" id="scchmem">Changing ion concentrations in membranes</DIV><DIV class="object code"><DIV class="caption">This script can be used to prepare a system with two membranes for simualtions.</DIV><DIV class="raw"><CODE class="python">
#!/usr/bin/python2
import sys
import argparse
import re

def calcAtomNumConc(conc, vol):
	return int(conc*vol*0.6)

def minmaxz(sel, box):
	zmin, zmax = (box[2], 0)
	for elem in sel:
		z = elem[6]
		zmin = min(zmin, z)
		zmax = max(zmax, z)
	return (zmin, zmax)

def calcConc(sel):
	vol = calcVol(sel)
	na, cl = countNaCl(sel)
	print(&quot;conc: {} NA+ and {} CL-&quot;.format(na/(vol*0.6), cl/(vol*0.6)))

def ispoly(elem):
	resname = elem[1]
	return resname in [&quot;PGATN&quot;, &quot;PGATO&quot;, &quot;PGAM&quot;, &quot;CELL&quot;, &quot;CELLP&quot;]

def isw(elem):
	resname = elem[1]
	return resname in [&quot;W&quot;, &quot;PW&quot;]

def change_ion_to_w(sel, diff, data):
	for elem in sel[0:diff]:
		elem[1] = &quot;W&quot;
		elem[2] = &quot;W&quot;

def change_w_to_ion(sel, diff, name, data):
	for elem in sel[0:diff]:
		elem[1] = &quot;ION&quot;
		elem[2] = name
	
def change_ion_to_pw(sel, diff, data):
	ions = sel[0:diff]
	for ion in ions:
	    i = data.index(ion)
	    ion[1] = &quot;PW&quot;
	    ion[2] = &quot;W&quot;
            if data[i + 1][1] == data[i + 2][1] == &quot;RM&quot;:
                data[i + 1][1] = &quot;PW&quot;
                data[i + 2][1] = &quot;PW&quot;
            else:
                data.insert(i + 1, [ion[0], &quot;PW&quot;, &quot;WP&quot;, 0, ion[4] + 0.06, ion[5] + 0.09, ion[6] + 0.09])
	        data.insert(i + 2, [ion[0], &quot;PW&quot;, &quot;WM&quot;, 0, ion[4] + 0.07, ion[5] + 0.07, ion[6] + 0.10])

def change_pw_to_ion(sel, diff, name, data):
	replaced = 0
	for i in range(2, len(sel)):
	    if replaced == diff:
		break
	    if sel[i][0] == sel[i - 1][0] == sel[i - 2][0]:
		ndx = data.index(sel[i])
                data[ndx - 2][1] = &quot;RM&quot;
                data[ndx - 1][1] = &quot;RM&quot;
		sel[i][1] = &quot;ION&quot;
		sel[i][2] = name
		replaced += 1

def countNaCl(sel):
	na = len([x for x in sel if x[2] == &quot;NA+&quot;])
	cl = len([x for x in sel if x[2] == &quot;CL-&quot;])
	return (na, cl)

def changeTopology(data, box, chItoW, chWtoI, midConc, outerConc):
	# select the ions between the two bounding boxes of the membranes
	mid = box[2] / 2
	membba = minmaxz([x for x in data if ispoly(x) and x[6] &lt; mid], box)
	membbb = minmaxz([x for x in data if ispoly(x) and x[6] &gt; mid], box)
	volmid = box[0] * box[1] * (membbb[0] - membba[1])
	volouter = box[0] * box[1] * (membba[0] + box[2] - membbb[1])

	# remove ions between mid membrane to bounding box of pga
	memmida = (membba[1] - membba[0]) / 2 + membba[0]
	memmidb = (membbb[1] - membbb[0]) / 2 + membbb[0]
	ionsa = [x for x in data if x[1] == &quot;ION&quot; and memmida &lt; x[6] and x[6] &lt; membba[1]]
	ionsb = [x for x in data if x[1] == &quot;ION&quot; and membbb[0] &lt; x[6] and x[6] &lt; memmidb]
	rna, rcl = countNaCl(ionsa)
	na, cl = countNaCl(ionsb)
	rna += na
	rcl += cl
	print(&quot;removed {} na and {} cl from membrane\n&quot;.format(rna, rcl))
	chItoW(ionsa, len(ionsa), data)
	chItoW(ionsb, len(ionsb), data)

	# function to correct the difference atom numbers
	def correctdiff(diff, name, sel):
		if diff &gt; 0:
			print(&quot;removing {} {}&quot;.format(diff, name))
			chItoW([x for x in sel if x[2] == name], diff, data)
		elif diff &lt; 0:
			print(&quot;adding {} {}&quot;.format(-diff, name))
			chWtoI([x for x in sel if isw(x) or x[1] == &quot;RM&quot;], -diff, name, data)

	# change the concentration in the middle
	selmid = [x for x in data if membba[1] &lt; x[6] and x[6] &lt; membbb[0]]
	na, cl = countNaCl(selmid)
	target = calcAtomNumConc(midConc, volmid)
	print(&quot;\nmiddle target ion number: {}&quot;.format(target))
	print(&quot;middle has {} na and {} cl&quot;.format(na, cl))
	cldiff = cl - target
	nadiff = na - target
	correctdiff(cldiff, &quot;CL-&quot;, selmid)
	correctdiff(nadiff, &quot;NA+&quot;, selmid)
	rna += nadiff
	rcl += cldiff
	
	# change the concentration in the outer part
	selouter = [x for x in data if x[6] &lt; membba[0] or membbb[1] &lt; x[6]]
	na, cl = countNaCl(selouter)
	target = calcAtomNumConc(outerConc, volouter)
	print(&quot;\nouter target ion number: {}&quot;.format(target))
	print(&quot;outer has {} na and {} cl&quot;.format(na, cl))
	cldiff = cl - target
	nadiff = na - target
	correctdiff(cldiff, &quot;CL-&quot;, selouter)
	correctdiff(nadiff, &quot;NA+&quot;, selouter)
	rna += nadiff
	rcl += cldiff

	# correct charge
	diff = rcl - rna
	print(&quot;\ncorrecting charge with {} na&quot;.format(diff))
	hdiff = int(diff / 2)
	correctdiff(hdiff, &quot;NA+&quot;, [x for x in selouter if x[6] &lt; mid])
	correctdiff(diff - hdiff, &quot;NA+&quot;, [x for x in selouter if x[6] &gt; mid])
        data[:] = [x for x in data if not x[1] == &quot;RM&quot;]


def readGro(file):
	alist = []
	linere = re.compile(&quot;(.{5})(.{5})(.{5})(.{5})(.{8})(.{8})(.{8})(?:(.{8})(.{8})(.{8}))?$&quot;)
	floatre = '(\S+)'
	sre = floatre + &quot;\s*&quot; + floatre  + &quot;\s*&quot; + floatre
	boxre = re.compile(&quot;\s*&quot; + sre + &quot;(?:\s*&quot; + sre + &quot;\s*&quot; + sre + &quot;)?$&quot;)
	with open(file) as file:
		name = file.next()
		numatoms = int(file.next())
		for i in range(numatoms):
			line = file.next()
			data = list(linere.match(line).groups())
			data = data[:7]
			alist.append([int(data[0]), data[1].strip(), data[2].strip(), int(data[3]), float(data[4]), float(data[5]), float(data[6])])
			
		# only works with cubic boxes
		box = map(float, boxre.match(file.next()).groups()[:3])
	return (name, numatoms, alist, box)

def resnamecmp(x, y):
	if ispoly(x) and ispoly(y):
		return 0
	if x[1] == &quot;ION&quot; and y[1] == &quot;ION&quot;:
		return cmp(x[2], y[2])
	return cmp(x[1], y[1])

def writeGro(file, name, data, box):
	data.sort(cmp=resnamecmp)
	with open(file, &quot;w&quot;) as f:
		f.write(name)
		f.write(str(len(data)) + &quot;\n&quot;)
		resnum, andx = (1, 1)
		resname = data[0][1]
		for elem in data:
			if elem[1] != resname:
				resname = elem[1]
				resnum = 1
			f.write(&quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n&quot; % (resnum, elem[1], elem[2], andx, elem[4], elem[5], elem[6]))
			andx += 1
			resnum += 1
		f.write(&quot;%10.5f%10.5f%10.5f\n&quot; % tuple(box))
		
def printTopology(data):
	print(&quot;change your topology to:&quot;)
	text = [(&quot;PGA&quot;, &quot;PGA20\t{}&quot;.format(len([x for x in data if ispoly(x)])/60)),
			(&quot;W&quot;, &quot;W\t{}&quot;.format(len([x for x in data if isw(x)]))),
			(&quot;WF&quot;, &quot;WF\t{}&quot;.format(len([x for x in data if x[2] == &quot;WF&quot;]))),
			(&quot;NA+&quot;, &quot;NA+\t{}&quot;.format(len([x for x in data if x[2] == &quot;NA+&quot;]))),
			(&quot;CL-&quot;, &quot;CL-\t{}&quot;.format(len([x for x in data if x[2] == &quot;CL-&quot;])))]
	text.sort(resnamecmp)
        for line in text:
            print(line[1])

def printPolTopology(data):
	print(&quot;change your topology to:&quot;)
	text = [(&quot;PGA&quot;, &quot;PGA20\t{}&quot;.format(len([x for x in data if ispoly(x)])/60)),
		(&quot;PW&quot;, &quot;PW\t{}&quot;.format(len([x for x in data if isw(x)])/3)),
		(&quot;NA+&quot;, &quot;NA+\t{}&quot;.format(len([x for x in data if x[2] == &quot;NA+&quot;]))),
		(&quot;CL-&quot;, &quot;CL-\t{}&quot;.format(len([x for x in data if x[2] == &quot;CL-&quot;])))]
	text.sort(resnamecmp)
	for line in text:
	    print(line[1])

def main():
	parser = argparse.ArgumentParser()
	parser.add_argument(&quot;-p&quot;, &quot;--polarizable&quot;, help=&quot;use polarizable water&quot;, action=&quot;store_true&quot;)
	parser.add_argument(&quot;-d&quot;, &quot;--double&quot;, help=&quot;double the universe (MDAnalysis 0.10 is required)&quot;, action=&quot;store_true&quot;)
	parser.add_argument(&quot;-f&quot;, &quot;--file&quot;, type=str, help=&quot;the input topology&quot;, default=&quot;zbox.gro&quot;)
	parser.add_argument(&quot;-o&quot;, &quot;--output&quot;, type=str, help=&quot;the output topology&quot;, default=&quot;sbox.gro&quot;)
	parser.add_argument(&quot;-cm&quot;, &quot;--concmid&quot;, type=float, help=&quot;the target concentration for the middle part of the box&quot;, default=0.017)
	parser.add_argument(&quot;-co&quot;, &quot;--concouter&quot;, type=float, help=&quot;the target concentration for the outer part of the box&quot;, default=0.51)
	args = parser.parse_args()
	
	name, a, data, box = readGro(args.file)
	
	if args.polarizable:
		changeTopology(data, box, change_ion_to_pw, change_pw_to_ion, args.concmid, args.concouter)
		printPolTopology(data)
	else:
		changeTopology(data, box, change_ion_to_w, change_w_to_ion, args.concmid, args.concouter)
		printTopology(data)

	writeGro(args.output, name, data, box)

if __name__ == &quot;__main__&quot;:
    main()
</CODE></DIV></DIV><DIV class="subtitle" id="scnaclw">Calculating the flow through membranes</DIV><DIV class="object code"><DIV class="caption">This script can be used to calculate the flow of ions and water.</DIV><DIV class="raw"><CODE class="python">
#!/usr/bin/python2
from __future__ import division

import MDAnalysis
import numpy
import sys
import math

def getZBounds(mem1, mem2):
	bbox1 = mem1.bbox()
	bbox2 =	mem2.bbox()  
	return (bbox1[0][2], bbox1[1][2], bbox2[0][2], bbox2[1][2])

def partition(zcoord, bounds):
	m1min, m1max, m2min, m2max = bounds
	if zcoord &lt; m1min:
		return &quot;outer&quot;
	if zcoord &lt; m1max:
		return &quot;mem&quot;
	if zcoord &lt; m2min:
		return &quot;mid&quot;
	if zcoord &lt; m2max:
		return &quot;mem&quot;
	if m2max &lt; zcoord:
		return &quot;outer&quot;

def direction(frompart, topart):
	dir = (0, &quot;none&quot;)
	if frompart == &quot;mem&quot; and topart == &quot;mid&quot;:
		dir = (1, &quot;mem&quot;)
	if frompart == &quot;mem&quot; and topart == &quot;outer&quot;:
		dir = (-1, &quot;mem&quot;)
	if frompart == &quot;mid&quot; and topart == &quot;outer&quot;:
		dir = (-1, &quot;pass&quot;)
	if frompart == &quot;outer&quot; and topart == &quot;mid&quot;:
		dir = (1, &quot;pass&quot;)
	return dir
			
def count(ind, orig, num, ts, bounds):
	f, b, fm, bm = (0, 0, 0, 0)
	if orig[0] == &quot;init&quot;:
		orig[:] = [partition(ts[ind[i]][2], bounds) for i in xrange(0, len(ind))]
		return (f, b, fm, bm)

	for offset in xrange(0, len(orig), num):
		inds = [ind[i] for i in xrange(offset, offset + num)]
		loc = [partition(ts[i][2], bounds) for i in inds]
		if loc.count(loc[0]) != len(loc) or loc[0] == &quot;mem&quot;:
			continue
		dire = [direction(orig[j], loc[i]) for i, j in enumerate(xrange(offset, offset + num))]
		direp = sum([x[0] for x in dire if x[1] == &quot;pass&quot;])
		if direp &gt; 0:
			f += 1
		if direp &lt; 0:
			b += 1
		direm = sum([x[0] for x in dire if x[1] == &quot;mem&quot;])
		if direm &gt; 0:
			fm += 1
		if direm &lt; 0:
			bm += 1
		orig[offset:(offset + num)] = loc
			
	return (f, b, fm, bm)

def norm(a, b, c):
	return (a - b) / c 

def main():
	u = MDAnalysis.Universe(sys.argv[1], sys.argv[2])
	prefix = sys.argv[3]
	nai = u.selectAtoms(&quot;name NA+&quot;).indices()
	nao = [&quot;init&quot;]
	cli = u.selectAtoms(&quot;name CL-&quot;).indices()
	clo = [&quot;init&quot;]
	wi = u.selectAtoms(&quot;resname W or resname PW or resname WF&quot;).indices()
	wo = [&quot;init&quot;]
	middle = u.dimensions[2] / 2
	mem = &quot;not (resname W or resname WF or resname PW or name CL- or name NA+)&quot;
	mem1 = u.selectAtoms(mem + &quot; and prop z &lt; {}&quot;.format(middle))
	mem2 = u.selectAtoms(mem + &quot; and prop z &gt; {}&quot;.format(middle))
	nadc = [0, 0, 0, 0]
	cldc = [0, 0, 0, 0]
	wdc = [0, 0, 0, 0]
	nal = len(nai)
	cll = len(cli)
	wl = len(wi)
	with open(prefix + &quot;_naclwflow.txt&quot;, &quot;w&quot;) as f:
		f.write(&quot;frame\tfna\tbna\tfnam\tbnam\tfcl\tbcl\tfclm\tbclm\tfw\tbw\tfwm\tbwm\t&quot; +
			&quot;flna\tflnam\tflcl\tflclm\tflw\tflwm\t&quot; +
			&quot;cflna\tcflnam\tcflcl\tcflclm\tcflw\tcflwm\n&quot;)
		for ts in u.trajectory:
			bounds = getZBounds(mem1, mem2)
			nad = count(nai, nao, 1, ts, bounds)
			cld = count(cli, clo, 1, ts, bounds)
			if u.atoms[wi[0]].resname == &quot;PW&quot;:
				wd = count(wi, wo, 3, ts, bounds)
				wlcor = wl/3
			else:
				wd = count(wi, wo, 1, ts, bounds)
				wlcor = wl

			flna = norm(nad[0], nad[1], nal)
			flnam = norm(nad[2], nad[3], nal)
			flcl = norm(cld[0], cld[1], cll)
			flclm = norm(cld[2], cld[3], cll)
			flw = norm(wd[0], wd[1], wlcor)
			flwm = norm(wd[2], wd[3], wlcor)
			nadc[:] = [x + y for x, y in zip(nadc, nad)]
			cldc[:] = [x + y for x, y in zip(cldc, cld)]
			wdc[:] = [x + y for x, y in zip(wdc, wd)]
			cflna = norm(nadc[0], nadc[1], nal)
			cflnam = norm(nadc[2], nadc[3], nal)
			cflcl = norm(cldc[0], cldc[1], cll)
			cflclm = norm(cldc[2], cldc[3], cll)
			cflw = norm(wdc[0], wdc[1], wlcor)
			cflwm = norm(wdc[2], wdc[3], wlcor)

			f.write(&quot;{0}\t&quot;.format(ts.frame) +
				&quot;\t&quot;.join([str(x) for x in nad]) + &quot;\t&quot; +
				&quot;\t&quot;.join([str(x) for x in cld]) + &quot;\t&quot; +
				&quot;\t&quot;.join([str(x) for x in wd]) + &quot;\t&quot; +
				&quot;{0}\t{1}\t{2}\t{3}\t{4}\t{5}\t&quot;.format(flna, flnam, flcl, flclm, flw, flwm) +
				&quot;{0}\t{1}\t{2}\t{3}\t{4}\t{5}\n&quot;.format(cflna, cflnam, cflcl, cflclm, cflw, cflwm))

if __name__ == &quot;__main__&quot;:
    main()
</CODE></DIV></DIV><DIV class="object code"><DIV class="caption">This script can be used to graph the flow of ions and water.</DIV><DIV class="raw"><CODE>
#!/usr/bin/gnuplot
set terminal pngcairo size 2666,776 enhanced font 'Verdana,20'

# define axis
# remove border on top and right and set color to gray
set style line 11 lc rgb '#808080' lt 1
set border 3 back ls 11
set tics nomirror
# define grid
set style line 12 lc rgb '#808080' lt 0 lw 1
set grid back ls 12

set ylabel &quot;Proportion&quot;
set xlabel &quot;Time (ns)&quot;
set key off

set output 'naclwflow.png'
set multiplot layout 1,3
set yrange [-0.05:0.5]
set autoscale x

set title &quot;Net cumulative Na^{+} flow&quot;
plot &quot;cel_naclwflow.txt&quot; u (20 * (column(&quot;frame&quot;) - 1) / 1000):((column(&quot;fna&quot;) + column(&quot;fnam&quot;) - column(&quot;bna&quot;)) / 293) smooth cumulative with lines lt rgb &quot;red&quot; lw 2 title &quot;Cellulose&quot;,\
        &quot;pga_naclwflow.txt&quot; u (20 * (column(&quot;frame&quot;) - 1) / 1000):((column(&quot;fna&quot;) + column(&quot;fnam&quot;) - column(&quot;bna&quot;)) / 1582) smooth cumulative with lines lt rgb &quot;green&quot; lw 2 title &quot;Poly-γ-glutamic acid&quot;,\
        &quot;celp_naclwflow.txt&quot; u (20 * (column(&quot;frame&quot;) - 1) / 1000):((column(&quot;fna&quot;) + column(&quot;fnam&quot;) - column(&quot;bna&quot;)) / 3099) smooth cumulative with lines lt rgb &quot;blue&quot; lw 2 title &quot;Cellulose phosphate&quot;

set title &quot;Net cumulative Cl^{-} flow&quot;
plot &quot;cel_naclwflow.txt&quot; u (20 * (column(&quot;frame&quot;) - 1) / 1000):((column(&quot;fcl&quot;) + column(&quot;fclm&quot;) - column(&quot;bcl&quot;)) / 293) smooth cumulative with lines lt rgb &quot;red&quot; lw 2 title &quot;Cellulose&quot;,\
        &quot;pga_naclwflow.txt&quot; u (20 * (column(&quot;frame&quot;) - 1) / 1000):((column(&quot;fcl&quot;) + column(&quot;fclm&quot;) - column(&quot;bcl&quot;)) / 182) smooth cumulative with lines lt rgb &quot;green&quot; lw 2 title &quot;Poly-γ-glutamic acid&quot;,\
        &quot;celp_naclwflow.txt&quot; u (20 * (column(&quot;frame&quot;) - 1) / 1000):((column(&quot;fcl&quot;) + column(&quot;fclm&quot;) - column(&quot;bcl&quot;)) / 299) smooth cumulative with lines lt rgb &quot;blue&quot; lw 2 title &quot;Cellulose phosphate&quot;

set autoscale y
set ylabel &quot;Water count&quot;
set title &quot;Net cumulative water flow&quot;
plot &quot;cel_naclwflow.txt&quot; u (20 * (column(&quot;frame&quot;) - 1) / 1000):(column(&quot;fw&quot;) - column(&quot;bw&quot;)) smooth cumulative with lines lt rgb &quot;red&quot; lw 2 title &quot;Cellulose&quot;,\
        &quot;pga_naclwflow.txt&quot; u (20 * (column(&quot;frame&quot;) - 1) / 1000):(column(&quot;fw&quot;) - column(&quot;bw&quot;)) smooth cumulative with lines lt rgb &quot;green&quot; lw 2 title &quot;Poly-γ-glutamic acid&quot;,\
        &quot;celp_naclwflow.txt&quot; u (20 * (column(&quot;frame&quot;) - 1) / 1000):(column(&quot;fw&quot;) - column(&quot;bw&quot;)) smooth cumulative with lines lt rgb &quot;blue&quot; lw 2 title &quot;Cellulose phosphate&quot;

unset multiplot
</CODE></DIV></DIV></DIV></DIV><DIV class="entry footer"><DIV class="copyright">2015 iGEM Groningen</DIV></DIV></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_UCSC_Software skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:UCSC/Software</SPAN></H1><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><DIV class="container-fluid"><DIV><UL class="nav navbar-nav bernick_swag"><LI class="active"><A href="https://2015.igem.org/Team:UCSC">Home</A></LI><LI class="dropdown"><A class="dropdown-toggle" data-toggle="dropdown" href="#">Team </A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Team">Meet the Team</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Breakdown">Breakdown</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Fermentation">Fermentation</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Field">Field</A></LI></UL><LI><A href="https://2015.igem.org/Team:UCSC/Description">Project</A></LI><LI class="dropdown"><A class="dropdown-toggle" data-toggle="dropdown" href="#">Human Practices</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Outreach">Outreach</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Practices">Bioethics</A></LI><LI class="dropdown"><A class="dropdown-toggle" data-toggle="dropdown" href="#">Notebook</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Logs">Logs</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Protocols">Protocols</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Safety">Safety</A></LI><LI class="dropdown"><A class="dropdown-toggle" data-toggle="dropdown" href="#">Achievements</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Parts">Parts</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Medal_Fulfillment">Medal Fulfillment</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Results">Results</A></LI><LI><A href="https://2015.igem.org/Team:UCSC/Software">Software</A></LI></DIV></DIV><DIV id="our_content"><H1> Software at UCSC </H1><H4>Our Software Tools can be found in the <A href="https://github.com/igemsoftware/UCSC-2015">iGEM GitHub</A></H4><DIV class="col-md-12"><H2>F.O.C.U.S</H2><DIV class="panel-group" id="accordion" role="tablist" aria-multiselectable="true"><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingOne"><H4 class="panel-title"><A role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
          Introduction
        </A></H4></DIV><DIV id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne"><DIV class="panel-body"><P>Codon optimization is a technique often used by molecular biologists to increase protein expression yields by augmenting the rate translation for a specific gene of interest. Each organism has a codon usage bias where it prefers to use certain codons to encode for a specific amino acid. Current methods of codon optimization work by substituting less frequent codons for a particular amino acid to a more commonly used codon.</P><P>While this method of codon optimization results in increased protein yields, recent evidence suggests that it alters protein function. We hypothesize that codon frequencies in ORFs model translational speed, are non-trivial to protein folding, and therefore play a major role in codon optimization. Because of this, we created our <STRONG>F</STRONG>requency <STRONG>O</STRONG>ptimized <STRONG>C</STRONG>odon <STRONG>U</STRONG>sage <STRONG>S</STRONG>trategy (FOCUS).</P><P>FOCUS provides the end user with a foundation to visualize the rate of protein synthesis as the nascent polypeptide exits the ribosome, granting potential insight to the underlying mechanics of protein folding. We plan to apply FOCUS accordingly to better understand the nature of misfolded proteins and the diseases associated, such as cancer and Alzheimers. FOCUS has the potential to identify detrimental single nucleotide polymorphisms that may be pivotal to the encoded protein's fold and serves as an extremely useful tool for protein engineering.</P><P style=" text-align: center;"><B>Figure 2</B><I style="font-size: 12px;">Secondary structure diagram of the Zymomonas mobilis pyruvate decarboxylase with rare codons indicated as gold stars. The three domains are labelled with Roman numerals starting from the N-terminus. Helicies are indicated by red and strands in blue.</I></P><P>We wanted our FOCUS program to codon optimize a protein sequence by matching the translational speed a much as possible. We wanted the genetic sequence to induce 'stalls' during translation by using a rare codon from the target organism's codon bias at specific locations. To achieve these stalls at the correct locations, we looked at the nucleotide sequence for the protein of interest from the native organism.</P></DIV></DIV></DIV><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingTwo"><H4 class="panel-title"><A class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
          Usage
        </A></H4></DIV><DIV id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo"><DIV class="panel-body"><UL><LI>This program has been tested to work on Unix based operating systems (Mac OS, Linux)</LI></UL><UL><LI>When using IDLE, the script needs to be altered and the input file names need to be explicitly written. Variables that need to be hardcoded are commented in the FOCUS script.</LI><LI>The following program files <STRONG>need</STRONG> to be in the same directory for the FOCUS to work:
</LI><LI>commandLine.py</LI><LI>fastaReader.py</LI><LI>FOCUS.py</LI><LI>GNUplot.py</LI><LI>parseTasser.py</LI></UL><UL><LI>The input files need to be in the same directory as the FOCUS script.</LI></UL><UL><LI>Codon bias table is generated using <STRONG>CodonBiasGenerator</STRONG>. However, you may use another tool to create the table, as long as it is a <STRONG>GCG codon bias table</STRONG>.</LI><LI>Secondary structure prediction should be in I-TASSER format. Our team used the tool <STRONG>PSSpred </STRONG>to generate secondary structure predictions.</LI></UL></DIV></DIV></DIV><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingThree"><H4 class="panel-title"><A class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
          Documentation
        </A></H4></DIV><DIV id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree"><DIV class="panel-body"><P><STRONG><U>Class F.O.C.U.S</U></STRONG></P><P><STRONG>Attributes</STRONG></P><UL><LI>rnaCodonTable: Dictionary with RNA codons as keys and the single letter amino acid as the value.</LI><LI>DnaCodonTable: Dicionary with DNA codons as keys and the single letter amino acid as the value.</LI><LI>GCG: File name for the codon bias table given to the FOCUS object.</LI><LI>CodonMap: Dictionary with the amino acid as the key and a list of lists as the value. The entries in the inner list are codon, relative frequency, and percent per thousand.</LI></UL><P><STRONG>Functions</STRONG></P><UL><LI>OpenFile(seqFile): Opens a file and raises an error if it does not exist.</LI></UL><P style="text-indent: 75px;">seqFile is the name of the text file</P><UL><LI>CodonToAmino(codon): Converts a DNA codon to the encoding amino acid. The single amino acid letter is then returned</LI><LI>MakeDict(): Fills CodonMap dictionary using the codon bias table.</LI><LI>SortDict(dictionary) : For each amino acid in the CodonMap dictionary, the list of lists is sorted by the relative codon frequency, with the highest frequency being first.</LI><LI>getScore(codon): Returns the relative codon score for a particular codon.</LI><LI>printer(protien, values): Returns a string that has been formatted for printing to a file or terminal, where protein is a protein sequence string and values is a FOCUS score string for the same protein.</LI><LI>SSprinter(protein, values, SSlist): Returns a string that has been formatted for printing to a file or terminal, much like printer() but with the addition of secondary structure prediction.</LI></UL><P><STRONG><U>Class parseTasser</U></STRONG></P><P><STRONG>Attributes</STRONG></P><UL><LI>TASSER: filename for the secondary structure prediction in I-TASSER format.</LI><LI>trans: Dictionary to translate the number for secondary structure to the corresponding character. ie. '1' corresponds to a coil, '2' corresponds to a helix, and '4' corresponds to a sheet.</LI></UL><P><STRONG>Functions</STRONG></P><UL><LI>OpenFile(file): Opens the file and prints an error message if the file is not found.</LI><LI>returnList(): Returns a list with the first entry being the secondary structure string and the second entry being the confidence for the secondary structure prediction.</LI></UL><P><STRONG><U>Class GNUplot</U></STRONG></P><P><STRONG>Attributes</STRONG></P><UL><LI>proteinSeq: Protein sequence string</LI><LI>freqSeq: FOCUS score string</LI><LI>SSpred: List with a string for the Secondary structure prediction as the first entry.</LI><LI>Thousand: List with entries correspoding to the percent per thousand. The first character in proteinSeq corresponds to the first entry in the Thousand list.</LI><LI>reverseTrans: Dictionary to convert between Secondary Structure character to a number which can be used in GNUplot.</LI></UL><P><STRONG>Functions</STRONG></P><UL><LI>makeTable(): Prints a table that can be used in GNUplot.</LI></UL></DIV></DIV></DIV></DIV></DIV><DIV class="col-md-12"><H2>sequenceAnalysis</H2><DIV class="panel-group" id="accordion" role="tablist" aria-multiselectable="true"><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingFour"><H4 class="panel-title"><A role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseFour" aria-expanded="true" aria-controls="collapseFour">
          General Overview
        </A></H4></DIV><DIV id="collapseFour" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingFour"><DIV class="panel-body"><P><STRONG>1.1 What is it for? </STRONG></P><P> The sequenceAnalysis program is a tool for providing efficient, large scale analysis of amino acid sequences. It works very much like the software ProtParam designed by ExPASy. However, unlike ProtParam, this program has the advantage of reading and computing the physical and chemical properties of multiple proteins all at once.</P><P><STRONG>1.2 Program Specifications </STRONG></P><P> This program was written using the most recent version of the Python programming language, Python 3.4.3. It is designed to work as module, which can be imported to any program to access all or specific functions that the user requires. An added benefit of the modular design is that it can be easily edited to provide further functionality. At this point, this program is made up of two classes: ProteinParam and FastAReader. </P></DIV></DIV></DIV><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingFive"><H4 class="panel-title"><A class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseFive" aria-expanded="false" aria-controls="collapseFive">
          Class ProteinParam
        </A></H4></DIV><DIV id="collapseFive" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingFive"><DIV class="panel-body"><P> This class was written by UCSC iGEM team members Cristian Camacho, Jairo Navarro, and Raymond Bryan. It was developed in the course BME 160: Research Programming in the Life Sciences, and serves as the backbone for two other programs that are being submitted: CodonBiasGenerator and FOCUS. </P><P><STRONG>2.1 Attributes</STRONG></P><UL><LI>aa2mw : A dictionary of the molecular weights of all 20 amino acids </LI><LI>mwH20 : A float value corresponding to the molecular weight of water </LI><LI>aa2abs280 : Dictionary of the absorbance values of Tyrosine, Tryptophan and Cysteine at a wavelength of 280 nm.</LI><LI>aa2chargePos : Dictionary of the positive charge values of Lysine, Arginine and Histidine</LI><LI>aa2chargeNeg : Dictionary of the negative charge value of Aspartic Acid, Glutamic Acid, Cysteine and Tyrosine. </LI><LI>aaNterm : Float value of the charge </LI><LI>aaCterm : Float value of </LI><LI>validAA : An empty dictionary which will contain the counts of valid amino acids in a specific protein sequence. </LI></UL><P><STRONG>2.2 Methods </STRONG></P><UL><LI>aaCount( ) : Iterates through the amino acid sequence and returns a single integer count of valid amino acid characters found. </LI><LI>aaComposition ( ) : Returns the validAA dictionary with the valid amino acids and their counts for a specific protein. </LI><LI>pI ( ) : Estimates the theoretical isoelectric point of a protein by iterating through every pH value until it finds the one that results in a net charge that is closest to zero. </LI><LI>charge ( ) : Calculate the net charge at a particular pH, using the pKa of each charged Amino acid and the Nterminus and Cterminus</LI><LI>molarExtinction ( ) : Estimates the molar extinction coefficient based on the number and extinction coefficients of tyrosines, tryptophans, and cysteines.</LI><LI>massExtinction ( ) : Calculates the mass extinction by dividing the molar extinction value by the molecular weight of the corresponding protein. </LI><LI>molecularWeight ( ) : Calculates a proteins molecular weight by summing the weights of the individual Amino acids and excluding the waters that are released with peptide bond formation.</LI></UL></DIV></DIV></DIV><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingSix"><H4 class="panel-title"><A class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseSix" aria-expanded="false" aria-controls="collapseSix">
          Class FastAreader
        </A></H4></DIV><DIV id="collapseSix" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingSix"><DIV class="panel-body"><P><STRONG>Class FastAreader</STRONG></P><P>This program was developed by Professor David Bernick of UC Santa Cruz, for the upper- division course BME 160: Research Programming in the Life Sciences. This class is what allows the sequenceAnalysis module to read and calculate the characteristics of multiple protein sequences at the same time, as long as they are in the FASTA format.</P><P><STRONG>3.1 Attributes </STRONG></P><UL><LI>fname : The initial file name to be ready by FastAreader.</LI></UL><P><STRONG>3.2 Methods </STRONG></P><UL><LI>doOpen ( ) : Checks if a file name is given to FastAreader, and if not, waits for a file to be given through system.in. This function provides command line usability.</LI><LI>readFasta ( ) : Using filename given in init, returns each included FastA record as 2 strings - header and sequence. If a filename is not provided, std.in is used. Whitespace is removed, no adjustment is made to sequence contents. The initial '&gt;' is removed from the header.</LI></UL></DIV></DIV></DIV><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingTen"><H4 class="panel-title"><A class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseTen" aria-expanded="false" aria-controls="collapseTen">
          Importing the Module for Use
        </A></H4></DIV><DIV id="collapseTen" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTen"><DIV class="panel-body"><P>The use of the sequenceAnalysis module is fairly simple. Here are the following steps for making use of it in your programs:</P><OL><LI>Download the file named sequenceAnalysis from either the UCSC iGEM 2015 wiki, or the 2015 iGEM GitHub.</LI><LI>Important, save the file in the same directory as the script that you are writing.</LI><LI>Make sure to include the following line “import sequenceAnalysis” before writing any code for your new program.</LI><LI>In order to use a function from either the ProteinParam class or FastAreader class, you must create an object for that class.</LI><LI>Then you can use that object to access any of the available function from that class.</LI></OL><P>Below is an example program which illustrates the above steps and explains how to access one or more of the functions from ProteinParam.</P><P><STRONG>4.1 Ex) pIFinder.py</STRONG></P><P>Figure 1: This program is known as pIFinder, which specifically utilizes the pI ( ) method of the class ProteinParam and the FastAreader class to calculate and print the isoelectric point of given protein sequences with their respective headers.</P><P>Notice that in the red box there is the line “import sequenceAnalysis”, which signifies that the capabilities of sequenceAnalysis are now available to your program. Also, notice that the lines that which the two arrows are pointing to are responsible for creating a FastAreader object and a ProteinParam object.</P><P> </P></DIV></DIV></DIV><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingEleven"><H4 class="panel-title"><A class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseEleven" aria-expanded="false" aria-controls="collapseEleven">
          Test Files and Results 
        </A></H4></DIV><DIV id="collapseEleven" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingEleven"><DIV class="panel-body"><P>In order to test whether your program is working correctly, we have provided a test file that includes eleven FASTA formatted protein sequences. This test file can be found on the 2015 UCSC iGEM wiki under the name “sequenceAnalysisTest.txt”. Make sure that this file is also saved in the same directory as sequenceAnalysis and the program that you are writing. Furthermore, also make sure that whether you are hardcoding the file name into your code, or submitting it via the command line, that the file name matches exactly the way it is written.</P><P>Figure 2: The results for the test file.</P></DIV></DIV></DIV><DIV class="col-md-12"><H2>Codon Bias Generator</H2><DIV class="panel-group" id="accordion" role="tablist" aria-multiselectable="true"><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingSeven"><H4 class="panel-title"><A role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseSeven" aria-expanded="true" aria-controls="collapseSeven">
          General Overview
        </A></H4></DIV><DIV id="collapseSeven" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingSeven"><DIV class="panel-body"><P><STRONG>1.1 What is it for?</STRONG></P><P>The CodonBiasGenerator program is a tool for providing an easy, parseable Codon Bias Table that can be read, analyzed, and manipulated according to the user needs. It works very much like the Codon Usage Frequency Table's found on GenScrpit and Kazusa. However, unlike the competitors the CodonBiasGenerator gives the user the option of any gene sequenced input while returning a better output in the form of a dictionary file. This file is then able to be used as a stardard text file capable of string and data manipulation.</P><P><STRONG>1.2 Program Specifications </STRONG></P><P>This program was written using the most recent version of the Python programming language, Python 3.4.3. It is designed to work with the sequenceAnalysis.py as an imported module using the FastAReader class as a sequence reader. The class of the program is CodonFreq, with three separate defining methods for easy access and variability, each corresponding to its own calculated/documented variable.</P></DIV></DIV></DIV><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingEight"><H4 class="panel-title"><A class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseEight" aria-expanded="false" aria-controls="collapseEight">
          Class CodonFreq
        </A></H4></DIV><DIV id="collapseEight" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingEight"><DIV class="panel-body"><P>This class was written by UCSC iGEM team members Raymond Bryan, Jairo Navarro, and Cristian Camacho. It was developed in the course BME 188A/B: Synthetic Biology Lab, and provides functionality congruently with sequenceAnalysis.py.</P><P><STRONG>2.1 Attributes</STRONG></P><UL><LI>rnaCodonTable: a common dictionary used as a codon to AminoAcid(AA) key table</LI><LI>dnaCodonTable: a revised rnaCodonTable dictionary using the translated RNA to DNA codons</LI><LI>CodonCount: a listed dictionary organized as AA→ codon→ Value, where the value is the number of time the codon is accounted for within the Genome inputed.</LI><LI>CodonFrequen: a listed dictionary organized as AA→ codon→ Value, where the value is the float usage Frequency of the codon in question calculated as codonCount/ total # AA is called</LI><LI>CodonPerThou: a listed dictionary organized as AA→ codon→ Value, where the value is the codon Frequency per Thousand calculated as (codonCount/ Total # of codons)*1000</LI></UL><P><STRONG>2.2 Methods</STRONG></P><UL><LI>readSeq(): This allows the each sequence read to be analysed of all codons and append their count to a master list dictionary by matching the codon at hand to the possible codons listed in the dictionary and finally consolidating the total number of times called into a single value as a dictionary output.</LI><LI>TableMaker(): This allows the counted value gather by readSeq() to be accessed and used to determine the total amount of time the AA is called in the sequence by various possible codons into a separate dictionary . This new dictionary is then used to to calculate the Codon Usage Frequency, also stored as a dictionary output.</LI><LI>PercentPerThou(): This allows the counted value gather by readSeq() to be accessed and used to determine the total amount codons called in the genome. This new value in conjuction with the individual codon counts, is then used to to calculate the Codon Percent per Thousand, also stored as a dictionary output.</LI></UL></DIV></DIV></DIV><DIV class="panel panel-default"><DIV class="panel-heading" role="tab" id="headingNine"><H4 class="panel-title"><A class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseNine" aria-expanded="false" aria-controls="collapseNine">
          Using the CodonBiasGenerator Program 
        </A></H4></DIV><DIV id="collapseNine" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingNine"><DIV class="panel-body"><P>The use of the CodonBiasGenerator can be done in either IDLE or CMD. Here are the following steps for making use of it in your system:</P><OL><LI>Download both files named sequenceAnalysis.py and CodonBiasGenerator.py from either the UCSC iGEM 2015 wiki, or the 2015 iGEM GitHub.</LI><LI>Important, save both files in the same directory you currently work with in python3.4</LI><LI>Open your favorite commandline and change to your working python directory</LI><LI>Type/ Run CodonBiasGenerator.py and enter your gene Fasta file</LI><LI>Witness python sorcery magic.</LI></OL><P>Below is an example program which illustrates the above steps and explains how to move further.
</P></DIV></DIV></DIV></DIV></DIV></DIV><DIV id="foot" class="center foot">  <A href="https://2015.igem.org/Team:UCSC">Home</A> | <A href="https://2015.igem.org/Team:UCSC/Team">Teams</A> | <A href="https://2015.igem.org/Team:UCSC/Description">Project</A> | <A href="https://2015.igem.org/Team:UCSC/Practices">Human Practices</A> | <A href="https://2015.igem.org/Team:UCSC/Logs">Notebook</A> | <A href="https://2015.igem.org/Team:UCSC/Safety">Safety</A> | <A href="https://2015.igem.org/Team:UCSC/Parts">Parts</A> | <A href="https://2015.igem.org/Team:UCSC/Software">F.O.C.U.S</A>  </DIV></DIV></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
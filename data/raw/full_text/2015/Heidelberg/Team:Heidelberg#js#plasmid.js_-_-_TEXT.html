Team:Heidelberg/js/plasmid.js
function Plasmid(canvas, infobox, inserts, diameter, legendWidth, insertWidth, defaultText, insertBoxAttr, fontSize, spacing, startAngle) {
// Are all required parameters given?    if (canvas == undefined || infobox == undefined || inserts == undefined || diameter == undefined) {        console.log("Error: Not alle required parameters (canvas, inserts, infobox, diameter) given!");    }    this.canvas = canvas;    this.inserts = inserts;    this.diameter = diameter;    this.infobox = infobox;
// Set sane defaults for optional parameters    this.legendWidth = legendWidth || 500;    this.radiusOfInsertBox = insertWidth || diameter / 13;    this.defaultText = defaultText || "Hover over an insert to get more information!";    this.fontSize = fontSize || 20;    this.spacing = spacing || 25;    this.startAngle = startAngle || -40;    this.insertBoxAttr = insertBoxAttr || {        stroke: "#666",        opacity: 0.7,        "stroke-width": 1,        "stroke-linejoin": "round"    };
// Other stuff    this.radiusOfPlasmid = this.diameter * 0.5;    this.center = {x: this.spacing + this.radiusOfPlasmid, y: this.spacing + this.radiusOfPlasmid};
}
Plasmid.prototype = {
constructor: Plasmid,
// Checks list of inserts for completeness and applies sane defaults    checkInserts: function () {        for (i in this.inserts) {            insert = this.inserts[i];            if ( !("size" in insert) || !("color" in insert) || !("description" in insert) || !("label" in insert)) {                console.log("Error parsing inserts array, insert no.", i, "misses one or more required fields (size, color, description, label).");                return false;            } else {                if (!("gap" in insert)) {                    insert.gap = true;                }                if (!("promoter" in insert)) {                    insert.promoter = false;                }                if (insert.promoter && insert.size < 10) {                    console.log("Warning, Insert is to small to be a promoter!");                    insert.promoter = false;                }            }        }
// Everythin is alright        return true;    },
// Converts polar coordinates to carthesian coordinates, will assume this.center as center    polarToCartesian: function (radius, angleInDegrees) {        var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
return {            x: this.center.x + (radius * Math.cos(angleInRadians)),            y: this.center.y + (radius * Math.sin(angleInRadians))        };    },
// Returns the the describtion for an arc, will use the shortest arc path    // Arcs starts at the current position    describeArc: function (radius, arcSweep, end) {        return [            "A", this.radiusOfPlasmid, this.radiusOfPlasmid, 0, 0, arcSweep, end.x, end.y        ];    },
// Describes a line, line starts at current position    describeLine: function(end) {        return [            "L", end.x, end.y        ];    },
// Describes the box for an insert    describeInsertBox: function(startAngle, size, promoter) {        var SWEEP_FWD = 1;        var SWEEP_RWD = 0;        var endAngle = startAngle + size;
var topLeft             = this.polarToCartesian(this.radiusOfPlasmid, startAngle);        var bottomLeft          = this.polarToCartesian(this.radiusOfPlasmid - this.radiusOfInsertBox, startAngle);        if (promoter) {            var topRight        = this.polarToCartesian(this.radiusOfPlasmid, endAngle - 10);            var bottomRight     = this.polarToCartesian(this.radiusOfPlasmid - this.radiusOfInsertBox, endAngle - 10);            var arrowbodyOuter  = this.polarToCartesian(this.radiusOfPlasmid + 10, endAngle - 10);            var arrowbodyInner  = this.polarToCartesian(this.radiusOfPlasmid - this.radiusOfInsertBox - 10, endAngle - 10);            var arrowhead       = this.polarToCartesian(this.radiusOfPlasmid - this.radiusOfInsertBox * 0.5, endAngle)        } else {            var topRight        = this.polarToCartesian(this.radiusOfPlasmid, endAngle);            var bottomRight     = this.polarToCartesian(this.radiusOfPlasmid - this.radiusOfInsertBox, endAngle);        }
if (promoter) {            var d = [].concat(                ["M", topLeft.x, topLeft.y],                this.describeArc(this.radiusOfPlasmid, SWEEP_FWD, topRight),                this.describeLine(arrowbodyOuter),                this.describeLine(arrowhead),                this.describeLine(arrowbodyInner),                this.describeLine(bottomRight),                this.describeArc(this.radiusOfPlasmid - this.radiusOfInsertBox, SWEEP_RWD, bottomLeft),                ["Z"]            );        } else {            var d = [].concat(                ["M", topLeft.x, topLeft.y],                this.describeArc(this.radiusOfPlasmid, SWEEP_FWD, topRight),                this.describeLine(bottomRight),                this.describeArc(this.radiusOfPlasmid - this.radiusOfInsertBox, SWEEP_RWD, bottomLeft),                ["Z"]            );        }
return d.join(" ");    },
// Draws an arrow from from to to, used to connect legend to insert    describeArrow: function(from, to) {        // We do not want an arrow to go through the graph        // There are four possible positions relative to us        // from.x > from.y is always true        var start = [].concat(            ["M", from.x, from.y],            ["L", from.x - 20, from.y]        );
// to is right of center        if(to.x > this.center.x) {            // to is higher            if (to.y < from.y) {                d = start.concat(                    ["L", from.x - 20, this.center.y - this.radiusOfPlasmid - 20],                    ["L", to.x, this.center.y - this.radiusOfPlasmid - 20],                    ["L", to.x, to.y]                );            // to is lower or same height            } else {                d = start.concat(                    ["L", from.x - 20, to.y],                    ["L", to.x, to.y]                );            }        // to is left or directy above/beneath center        } else {            // to is above center            if (to.y < this.center.y) {                d = start.concat(                    ["L", from.x - 20, this.center.y - this.radiusOfPlasmid - 20],                    ["L", to.x, this.center.y - this.radiusOfPlasmid - 20],                    ["L", to.x, to.y]                );            // to is below center            } else {                d = start.concat(                    ["L", from.x - 20, this.center.y + this.radiusOfPlasmid + 20],                    ["L", to.x, this.center.y + this.radiusOfPlasmid + 20],                    ["L", to.x, to.y]                );            }        }
return d.join(" ");    },
calculateGapSize: function () {        // First, compute how many blocks of inserts there are and how many space is taken up by blocks        blockSpace = 0; // in degrees        insertBlocks = 0;        for (i in this.inserts) {            insert = this.inserts[i];            blockSpace += insert.size;            if (insert.gap == true) {                insertBlocks++;            }        }
// Now calculate how big each gap has to be        gapSize = (360 - blockSpace) / insertBlocks;
// Return        return gapSize;    },
// Registers mouseeventhandlers to the drawn box    registerEventHandlers: function(box, arrow, hoverText) {        box.mouseover(function() {            $("#info").html(hoverText);            box.attr({"stroke-width": 2, opacity: 1.0});            arrow.show();        });        box.mouseout(function() {            $("#" + this.infobox).html(this.defaultText);            box.attr({"stroke-width": 1, opacity: 0.7});            arrow.hide();        });    },
// Draws the plasmid    draw: function() {
$("#" + this.infobox).html = this.defaultText;
// Check Inserts, this HAS to be done first to provide sane defaults for non-given values!        this.checkInserts();
var paper = Raphael(this.canvas, this.diameter + this.legendWidth + 3 * this.spacing, this.diameter + 2 * this.spacing);        var legendPos = { x: this.diameter + 2 * this.spacing, y: this.spacing };        var legendBubbleRadius = 5;        var gapSize = this.calculateGapSize(this.inserts);
// Draw the rope        var ropeDiameter = (this.diameter - this.radiusOfInsertBox) * 1.037;        paper.image("
", this.center.x - ropeDiameter * 0.5, this.center.y - ropeDiameter * 0.5, ropeDiameter, ropeDiameter);
// Draw the inserts        var legendIdx = 0;        angle = this.startAngle;        for (i in this.inserts) {            insert = this.inserts[i];
// Draw the legend entry            legendRowY = legendPos.y + this.fontSize * 1.2 * legendIdx;            var text = paper.text(legendPos.x + legendBubbleRadius * 3, legendRowY, insert.label);            text.attr({"font-size": this.fontSize, "text-anchor": "start"});            var bubble = paper.circle(legendPos.x + legendBubbleRadius, legendRowY, legendBubbleRadius);            bubble.attr({fill: insert.color, stroke: "#CCC"});            legendIdx++;
// Draw the arrow from the legend entry to center of the outer arc of the box            var arrowFrom = {x: legendPos.x, y: legendRowY};            if (insert.promoter) {                var midAngle = angle + (insert.size - 10) * 0.5;            } else {                var midAngle = angle + insert.size * 0.5;            }            var arrowTo = this.polarToCartesian(this.radiusOfPlasmid, midAngle);            var arrow = paper.path(this.describeArrow(arrowFrom, arrowTo));            arrow.hide();
// Draw the box and a white box as background for opacity to work correctly            // This is easier than computing the fill color appropreately            paper.path(this.describeInsertBox(angle, insert.size, insert.promoter)).attr({fill: "#FFF"});            var box = paper.path(this.describeInsertBox(angle, insert.size, insert.promoter));            box.attr(this.insertBoxAttr);            box.attr({fill: insert.color});            angle += insert.size;
// Register mouseevent handlers            this.registerEventHandlers(box, arrow, insert.description);
// Draw the connector line            if (insert.gap) { //paper.path(describeConnector(angle, gapSize, center, radius, radiusOfInsertBox));                angle += gapSize;            }        }    }
}

<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_SPSingapore_home_moment_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:SPSingapore/home/moment.js</SPAN></H1><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>// JavaScript Document
//! moment.js
//! version : 2.10.3
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
</P><P>(function (global, factory) {
</P><PRE>   typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' &amp;&amp; define.amd ? define(factory) :
   global.moment = factory()
</PRE><P>}(this, function () { 'use strict';
</P><PRE>   var hookCallback;
</PRE><PRE>   function utils_hooks__hooks () {
       return hookCallback.apply(null, arguments);
   }
</PRE><PRE>   // This is done to register the method called with moment()
   // without creating circular dependencies.
   function setHookCallback (callback) {
       hookCallback = callback;
   }
</PRE><PRE>   function isArray(input) {
       return Object.prototype.toString.call(input) === '[object Array]';
   }
</PRE><PRE>   function isDate(input) {
       return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
   }
</PRE><PRE>   function map(arr, fn) {
       var res = [], i;
       for (i = 0; i &lt; arr.length; ++i) {
           res.push(fn(arr[i], i));
       }
       return res;
   }
</PRE><PRE>   function hasOwnProp(a, b) {
       return Object.prototype.hasOwnProperty.call(a, b);
   }
</PRE><PRE>   function extend(a, b) {
       for (var i in b) {
           if (hasOwnProp(b, i)) {
               a[i] = b[i];
           }
       }
</PRE><PRE>       if (hasOwnProp(b, 'toString')) {
           a.toString = b.toString;
       }
</PRE><PRE>       if (hasOwnProp(b, 'valueOf')) {
           a.valueOf = b.valueOf;
       }
</PRE><PRE>       return a;
   }
</PRE><PRE>   function create_utc__createUTC (input, format, locale, strict) {
       return createLocalOrUTC(input, format, locale, strict, true).utc();
   }
</PRE><PRE>   function defaultParsingFlags() {
       // We need to deep clone this object.
       return {
           empty           : false,
           unusedTokens    : [],
           unusedInput     : [],
           overflow        : -2,
           charsLeftOver   : 0,
           nullInput       : false,
           invalidMonth    : null,
           invalidFormat   : false,
           userInvalidated : false,
           iso             : false
       };
   }
</PRE><PRE>   function getParsingFlags(m) {
       if (m._pf == null) {
           m._pf = defaultParsingFlags();
       }
       return m._pf;
   }
</PRE><PRE>   function valid__isValid(m) {
       if (m._isValid == null) {
           var flags = getParsingFlags(m);
           m._isValid = !isNaN(m._d.getTime()) &amp;&amp;
               flags.overflow &lt; 0 &amp;&amp; !flags.empty &amp;&amp; !flags.invalidMonth &amp;&amp; !flags.nullInput &amp;&amp; !flags.invalidFormat &amp;&amp; !flags.userInvalidated;
</PRE><PRE>           if (m._strict) {
               m._isValid = m._isValid &amp;&amp;
                   flags.charsLeftOver === 0 &amp;&amp;
                   flags.unusedTokens.length === 0 &amp;&amp;
                   flags.bigHour === undefined;
           }
       }
       return m._isValid;
   }
</PRE><PRE>   function valid__createInvalid (flags) {
       var m = create_utc__createUTC(NaN);
       if (flags != null) {
           extend(getParsingFlags(m), flags);
       }
       else {
           getParsingFlags(m).userInvalidated = true;
       }
</PRE><PRE>       return m;
   }
</PRE><PRE>   var momentProperties = utils_hooks__hooks.momentProperties = [];
</PRE><PRE>   function copyConfig(to, from) {
       var i, prop, val;
</PRE><PRE>       if (typeof from._isAMomentObject !== 'undefined') {
           to._isAMomentObject = from._isAMomentObject;
       }
       if (typeof from._i !== 'undefined') {
           to._i = from._i;
       }
       if (typeof from._f !== 'undefined') {
           to._f = from._f;
       }
       if (typeof from._l !== 'undefined') {
           to._l = from._l;
       }
       if (typeof from._strict !== 'undefined') {
           to._strict = from._strict;
       }
       if (typeof from._tzm !== 'undefined') {
           to._tzm = from._tzm;
       }
       if (typeof from._isUTC !== 'undefined') {
           to._isUTC = from._isUTC;
       }
       if (typeof from._offset !== 'undefined') {
           to._offset = from._offset;
       }
       if (typeof from._pf !== 'undefined') {
           to._pf = getParsingFlags(from);
       }
       if (typeof from._locale !== 'undefined') {
           to._locale = from._locale;
       }
</PRE><PRE>       if (momentProperties.length &gt; 0) {
           for (i in momentProperties) {
               prop = momentProperties[i];
               val = from[prop];
               if (typeof val !== 'undefined') {
                   to[prop] = val;
               }
           }
       }
</PRE><PRE>       return to;
   }
</PRE><PRE>   var updateInProgress = false;
</PRE><PRE>   // Moment prototype object
   function Moment(config) {
       copyConfig(this, config);
       this._d = new Date(+config._d);
       // Prevent infinite loop in case updateOffset creates new moment
       // objects.
       if (updateInProgress === false) {
           updateInProgress = true;
           utils_hooks__hooks.updateOffset(this);
           updateInProgress = false;
       }
   }
</PRE><PRE>   function isMoment (obj) {
       return obj instanceof Moment || (obj != null &amp;&amp; obj._isAMomentObject != null);
   }
</PRE><PRE>   function toInt(argumentForCoercion) {
       var coercedNumber = +argumentForCoercion,
           value = 0;
</PRE><PRE>       if (coercedNumber !== 0 &amp;&amp; isFinite(coercedNumber)) {
           if (coercedNumber &gt;= 0) {
               value = Math.floor(coercedNumber);
           } else {
               value = Math.ceil(coercedNumber);
           }
       }
</PRE><PRE>       return value;
   }
</PRE><PRE>   function compareArrays(array1, array2, dontConvert) {
       var len = Math.min(array1.length, array2.length),
           lengthDiff = Math.abs(array1.length - array2.length),
           diffs = 0,
           i;
       for (i = 0; i &lt; len; i++) {
           if ((dontConvert &amp;&amp; array1[i] !== array2[i]) ||
               (!dontConvert &amp;&amp; toInt(array1[i]) !== toInt(array2[i]))) {
               diffs++;
           }
       }
       return diffs + lengthDiff;
   }
</PRE><PRE>   function Locale() {
   }
</PRE><PRE>   var locales = {};
   var globalLocale;
</PRE><PRE>   function normalizeLocale(key) {
       return key ? key.toLowerCase().replace('_', '-') : key;
   }
</PRE><PRE>   // pick the locale from the array
   // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
   // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
   function chooseLocale(names) {
       var i = 0, j, next, locale, split;
</PRE><PRE>       while (i &lt; names.length) {
           split = normalizeLocale(names[i]).split('-');
           j = split.length;
           next = normalizeLocale(names[i + 1]);
           next = next ? next.split('-') : null;
           while (j &gt; 0) {
               locale = loadLocale(split.slice(0, j).join('-'));
               if (locale) {
                   return locale;
               }
               if (next &amp;&amp; next.length &gt;= j &amp;&amp; compareArrays(split, next, true) &gt;= j - 1) {
                   //the next array item is better than a shallower substring of this one
                   break;
               }
               j--;
           }
           i++;
       }
       return null;
   }
</PRE><PRE>   function loadLocale(name) {
       var oldLocale = null;
       // TODO: Find a better way to register and load all the locales in Node
       if (!locales[name] &amp;&amp; typeof module !== 'undefined' &amp;&amp;
               module &amp;&amp; module.exports) {
           try {
               oldLocale = globalLocale._abbr;
               require('./locale/' + name);
               // because defineLocale currently also sets the global locale, we
               // want to undo that for lazy loaded locales
               locale_locales__getSetGlobalLocale(oldLocale);
           } catch (e) { }
       }
       return locales[name];
   }
</PRE><PRE>   // This function will load locale and then set the global locale.  If
   // no arguments are passed in, it will simply return the current global
   // locale key.
   function locale_locales__getSetGlobalLocale (key, values) {
       var data;
       if (key) {
           if (typeof values === 'undefined') {
               data = locale_locales__getLocale(key);
           }
           else {
               data = defineLocale(key, values);
           }
</PRE><PRE>           if (data) {
               // moment.duration._locale = moment._locale = data;
               globalLocale = data;
           }
       }
</PRE><PRE>       return globalLocale._abbr;
   }
</PRE><PRE>   function defineLocale (name, values) {
       if (values !== null) {
           values.abbr = name;
           if (!locales[name]) {
               locales[name] = new Locale();
           }
           locales[name].set(values);
</PRE><PRE>           // backwards compat for now: also set the locale
           locale_locales__getSetGlobalLocale(name);
</PRE><PRE>           return locales[name];
       } else {
           // useful for testing
           delete locales[name];
           return null;
       }
   }
</PRE><PRE>   // returns locale data
   function locale_locales__getLocale (key) {
       var locale;
</PRE><PRE>       if (key &amp;&amp; key._locale &amp;&amp; key._locale._abbr) {
           key = key._locale._abbr;
       }
</PRE><PRE>       if (!key) {
           return globalLocale;
       }
</PRE><PRE>       if (!isArray(key)) {
           //short-circuit everything else
           locale = loadLocale(key);
           if (locale) {
               return locale;
           }
           key = [key];
       }
</PRE><PRE>       return chooseLocale(key);
   }
</PRE><PRE>   var aliases = {};
</PRE><PRE>   function addUnitAlias (unit, shorthand) {
       var lowerCase = unit.toLowerCase();
       aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
   }
</PRE><PRE>   function normalizeUnits(units) {
       return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
   }
</PRE><PRE>   function normalizeObjectUnits(inputObject) {
       var normalizedInput = {},
           normalizedProp,
           prop;
</PRE><PRE>       for (prop in inputObject) {
           if (hasOwnProp(inputObject, prop)) {
               normalizedProp = normalizeUnits(prop);
               if (normalizedProp) {
                   normalizedInput[normalizedProp] = inputObject[prop];
               }
           }
       }
</PRE><PRE>       return normalizedInput;
   }
</PRE><PRE>   function makeGetSet (unit, keepTime) {
       return function (value) {
           if (value != null) {
               get_set__set(this, unit, value);
               utils_hooks__hooks.updateOffset(this, keepTime);
               return this;
           } else {
               return get_set__get(this, unit);
           }
       };
   }
</PRE><PRE>   function get_set__get (mom, unit) {
       return mom._d['get' + (mom._isUTC ? 'UTC' : <I>) + unit]();</I>
   }
</PRE><PRE>   function get_set__set (mom, unit, value) {
       return mom._d['set' + (mom._isUTC ? 'UTC' : <I>) + unit](value);</I>
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSet (units, value) {
       var unit;
       if (typeof units === 'object') {
           for (unit in units) {
               this.set(unit, units[unit]);
           }
       } else {
           units = normalizeUnits(units);
           if (typeof this[units] === 'function') {
               return this[units](value);
           }
       }
       return this;
   }
</PRE><PRE>   function zeroFill(number, targetLength, forceSign) {
       var output = <I> + Math.abs(number),</I>
           sign = number &gt;= 0;
</PRE><PRE>       while (output.length &lt; targetLength) {
           output = '0' + output;
       }
       return (sign ? (forceSign ? '+' : <I>) : '-') + output;</I>
   }
</PRE><PRE>   var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g;
</PRE><PRE>   var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
</PRE><PRE>   var formatFunctions = {};
</PRE><PRE>   var formatTokenFunctions = {};
</PRE><PRE>   // token:    'M'
   // padded:   ['MM', 2]
   // ordinal:  'Mo'
   // callback: function () { this.month() + 1 }
   function addFormatToken (token, padded, ordinal, callback) {
       var func = callback;
       if (typeof callback === 'string') {
           func = function () {
               return this[callback]();
           };
       }
       if (token) {
           formatTokenFunctions[token] = func;
       }
       if (padded) {
           formatTokenFunctions[padded[0]] = function () {
               return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
           };
       }
       if (ordinal) {
           formatTokenFunctions[ordinal] = function () {
               return this.localeData().ordinal(func.apply(this, arguments), token);
           };
       }
   }
</PRE><PRE>   function removeFormattingTokens(input) {
       if (input.match(/\[[\s\S]/)) {
           return input.replace(/^\[|\]$/g, <I>);</I>
       }
       return input.replace(/\\/g, <I>);</I>
   }
</PRE><PRE>   function makeFormatFunction(format) {
       var array = format.match(formattingTokens), i, length;
</PRE><PRE>       for (i = 0, length = array.length; i &lt; length; i++) {
           if (formatTokenFunctions[array[i]]) {
               array[i] = formatTokenFunctions[array[i]];
           } else {
               array[i] = removeFormattingTokens(array[i]);
           }
       }
</PRE><PRE>       return function (mom) {
           var output = <I>;</I>
           for (i = 0; i &lt; length; i++) {
               output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
           }
           return output;
       };
   }
</PRE><PRE>   // format date using native date object
   function formatMoment(m, format) {
       if (!m.isValid()) {
           return m.localeData().invalidDate();
       }
</PRE><PRE>       format = expandFormat(format, m.localeData());
</PRE><PRE>       if (!formatFunctions[format]) {
           formatFunctions[format] = makeFormatFunction(format);
       }
</PRE><PRE>       return formatFunctions[format](m);
   }
</PRE><PRE>   function expandFormat(format, locale) {
       var i = 5;
</PRE><PRE>       function replaceLongDateFormatTokens(input) {
           return locale.longDateFormat(input) || input;
       }
</PRE><PRE>       localFormattingTokens.lastIndex = 0;
       while (i &gt;= 0 &amp;&amp; localFormattingTokens.test(format)) {
           format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
           localFormattingTokens.lastIndex = 0;
           i -= 1;
       }
</PRE><PRE>       return format;
   }
</PRE><PRE>   var match1         = /\d/;            //       0 - 9
   var match2         = /\d\d/;          //      00 - 99
   var match3         = /\d{3}/;         //     000 - 999
   var match4         = /\d{4}/;         //    0000 - 9999
   var match6         = /[+-]?\d{6}/;    // -999999 - 999999
   var match1to2      = /\d\d?/;         //       0 - 99
   var match1to3      = /\d{1,3}/;       //       0 - 999
   var match1to4      = /\d{1,4}/;       //       0 - 9999
   var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
</PRE><PRE>   var matchUnsigned  = /\d+/;           //       0 - inf
   var matchSigned    = /[+-]?\d+/;      //    -inf - inf
</PRE><PRE>   var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
</PRE><PRE>   var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
</PRE><PRE>   // any word (or two) characters or numbers including two/three word month in arabic.
   var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
</PRE><PRE>   var regexes = {};
</PRE><PRE>   function addRegexToken (token, regex, strictRegex) {
       regexes[token] = typeof regex === 'function' ? regex : function (isStrict) {
           return (isStrict &amp;&amp; strictRegex) ? strictRegex : regex;
       };
   }
</PRE><PRE>   function getParseRegexForToken (token, config) {
       if (!hasOwnProp(regexes, token)) {
           return new RegExp(unescapeFormat(token));
       }
</PRE><PRE>       return regexes[token](config._strict, config._locale);
   }
</PRE><PRE>   // Code from <A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript">http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript</A>
   function unescapeFormat(s) {
       return s.replace('\\', <I>).replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {</I>
           return p1 || p2 || p3 || p4;
       }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&amp;');
   }
</PRE><PRE>   var tokens = {};
</PRE><PRE>   function addParseToken (token, callback) {
       var i, func = callback;
       if (typeof token === 'string') {
           token = [token];
       }
       if (typeof callback === 'number') {
           func = function (input, array) {
               array[callback] = toInt(input);
           };
       }
       for (i = 0; i &lt; token.length; i++) {
           tokens[token[i]] = func;
       }
   }
</PRE><PRE>   function addWeekParseToken (token, callback) {
       addParseToken(token, function (input, array, config, token) {
           config._w = config._w || {};
           callback(input, config._w, config, token);
       });
   }
</PRE><PRE>   function addTimeToArrayFromToken(token, input, config) {
       if (input != null &amp;&amp; hasOwnProp(tokens, token)) {
           tokens[token](input, config._a, config, token);
       }
   }
</PRE><PRE>   var YEAR = 0;
   var MONTH = 1;
   var DATE = 2;
   var HOUR = 3;
   var MINUTE = 4;
   var SECOND = 5;
   var MILLISECOND = 6;
</PRE><PRE>   function daysInMonth(year, month) {
       return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('M', ['MM', 2], 'Mo', function () {
       return this.month() + 1;
   });
</PRE><PRE>   addFormatToken('MMM', 0, 0, function (format) {
       return this.localeData().monthsShort(this, format);
   });
</PRE><PRE>   addFormatToken('MMMM', 0, 0, function (format) {
       return this.localeData().months(this, format);
   });
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('month', 'M');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('M',    match1to2);
   addRegexToken('MM',   match1to2, match2);
   addRegexToken('MMM',  matchWord);
   addRegexToken('MMMM', matchWord);
</PRE><PRE>   addParseToken(['M', 'MM'], function (input, array) {
       array[MONTH] = toInt(input) - 1;
   });
</PRE><PRE>   addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
       var month = config._locale.monthsParse(input, token, config._strict);
       // if we didn't find a month name, mark the date as invalid.
       if (month != null) {
           array[MONTH] = month;
       } else {
           getParsingFlags(config).invalidMonth = input;
       }
   });
</PRE><PRE>   // LOCALES
</PRE><PRE>   var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
   function localeMonths (m) {
       return this._months[m.month()];
   }
</PRE><PRE>   var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
   function localeMonthsShort (m) {
       return this._monthsShort[m.month()];
   }
</PRE><PRE>   function localeMonthsParse (monthName, format, strict) {
       var i, mom, regex;
</PRE><PRE>       if (!this._monthsParse) {
           this._monthsParse = [];
           this._longMonthsParse = [];
           this._shortMonthsParse = [];
       }
</PRE><PRE>       for (i = 0; i &lt; 12; i++) {
           // make the regex if we don't have it already
           mom = create_utc__createUTC([2000, i]);
           if (strict &amp;&amp; !this._longMonthsParse[i]) {
               this._longMonthsParse[i] = new RegExp('^' + this.months(mom, <I>).replace('.', </I>) + '$', 'i');
               this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, <I>).replace('.', </I>) + '$', 'i');
           }
           if (!strict &amp;&amp; !this._monthsParse[i]) {
               regex = '^' + this.months(mom, <I>) + '|^' + this.monthsShort(mom, </I>);
               this._monthsParse[i] = new RegExp(regex.replace('.', <I>), 'i');</I>
           }
           // test the regex
           if (strict &amp;&amp; format === 'MMMM' &amp;&amp; this._longMonthsParse[i].test(monthName)) {
               return i;
           } else if (strict &amp;&amp; format === 'MMM' &amp;&amp; this._shortMonthsParse[i].test(monthName)) {
               return i;
           } else if (!strict &amp;&amp; this._monthsParse[i].test(monthName)) {
               return i;
           }
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function setMonth (mom, value) {
       var dayOfMonth;
</PRE><PRE>       // TODO: Move this out of here!
       if (typeof value === 'string') {
           value = mom.localeData().monthsParse(value);
           // TODO: Another silent failure?
           if (typeof value !== 'number') {
               return mom;
           }
       }
</PRE><PRE>       dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
       mom._d['set' + (mom._isUTC ? 'UTC' : <I>) + 'Month'](value, dayOfMonth);</I>
       return mom;
   }
</PRE><PRE>   function getSetMonth (value) {
       if (value != null) {
           setMonth(this, value);
           utils_hooks__hooks.updateOffset(this, true);
           return this;
       } else {
           return get_set__get(this, 'Month');
       }
   }
</PRE><PRE>   function getDaysInMonth () {
       return daysInMonth(this.year(), this.month());
   }
</PRE><PRE>   function checkOverflow (m) {
       var overflow;
       var a = m._a;
</PRE><PRE>       if (a &amp;&amp; getParsingFlags(m).overflow === -2) {
           overflow =
               a[MONTH]       &lt; 0 || a[MONTH]       &gt; 11  ? MONTH :
               a[DATE]        &lt; 1 || a[DATE]        &gt; daysInMonth(a[YEAR], a[MONTH]) ? DATE :
               a[HOUR]        &lt; 0 || a[HOUR]        &gt; 24 || (a[HOUR] === 24 &amp;&amp; (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
               a[MINUTE]      &lt; 0 || a[MINUTE]      &gt; 59  ? MINUTE :
               a[SECOND]      &lt; 0 || a[SECOND]      &gt; 59  ? SECOND :
               a[MILLISECOND] &lt; 0 || a[MILLISECOND] &gt; 999 ? MILLISECOND :
               -1;
</PRE><PRE>           if (getParsingFlags(m)._overflowDayOfYear &amp;&amp; (overflow &lt; YEAR || overflow &gt; DATE)) {
               overflow = DATE;
           }
</PRE><PRE>           getParsingFlags(m).overflow = overflow;
       }
</PRE><PRE>       return m;
   }
</PRE><PRE>   function warn(msg) {
       if (utils_hooks__hooks.suppressDeprecationWarnings === false &amp;&amp; typeof console !== 'undefined' &amp;&amp; console.warn) {
           console.warn('Deprecation warning: ' + msg);
       }
   }
</PRE><PRE>   function deprecate(msg, fn) {
       var firstTime = true,
           msgWithStack = msg + '\n' + (new Error()).stack;
</PRE><PRE>       return extend(function () {
           if (firstTime) {
               warn(msgWithStack);
               firstTime = false;
           }
           return fn.apply(this, arguments);
       }, fn);
   }
</PRE><PRE>   var deprecations = {};
</PRE><PRE>   function deprecateSimple(name, msg) {
       if (!deprecations[name]) {
           warn(msg);
           deprecations[name] = true;
       }
   }
</PRE><PRE>   utils_hooks__hooks.suppressDeprecationWarnings = false;
</PRE><PRE>   var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
</PRE><PRE>   var isoDates = [
       ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
       ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
       ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
       ['GGGG-[W]WW', /\d{4}-W\d{2}/],
       ['YYYY-DDD', /\d{4}-\d{3}/]
   ];
</PRE><PRE>   // iso time formats and regexes
   var isoTimes = [
       ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
       ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
       ['HH:mm', /(T| )\d\d:\d\d/],
       ['HH', /(T| )\d\d/]
   ];
</PRE><PRE>   var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
</PRE><PRE>   // date from iso format
   function configFromISO(config) {
       var i, l,
           string = config._i,
           match = from_string__isoRegex.exec(string);
</PRE><PRE>       if (match) {
           getParsingFlags(config).iso = true;
           for (i = 0, l = isoDates.length; i &lt; l; i++) {
               if (isoDates[i][1].exec(string)) {
                   // match[5] should be 'T' or undefined
                   config._f = isoDates[i][0] + (match[6] || ' ');
                   break;
               }
           }
           for (i = 0, l = isoTimes.length; i &lt; l; i++) {
               if (isoTimes[i][1].exec(string)) {
                   config._f += isoTimes[i][0];
                   break;
               }
           }
           if (string.match(matchOffset)) {
               config._f += 'Z';
           }
           configFromStringAndFormat(config);
       } else {
           config._isValid = false;
       }
   }
</PRE><PRE>   // date from iso format or fallback
   function configFromString(config) {
       var matched = aspNetJsonRegex.exec(config._i);
</PRE><PRE>       if (matched !== null) {
           config._d = new Date(+matched[1]);
           return;
       }
</PRE><PRE>       configFromISO(config);
       if (config._isValid === false) {
           delete config._isValid;
           utils_hooks__hooks.createFromInputFallback(config);
       }
   }
</PRE><PRE>   utils_hooks__hooks.createFromInputFallback = deprecate(
       'moment construction falls back to js Date. This is ' +
       'discouraged and will be removed in upcoming major ' +
       'release. Please refer to ' +
       '<A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1407">https://github.com/moment/moment/issues/1407</A> for more info.',
       function (config) {
           config._d = new Date(config._i + (config._useUTC ? ' UTC' : <I>));</I>
       }
   );
</PRE><PRE>   function createDate (y, m, d, h, M, s, ms) {
       //can't just apply() to create a date:
       //<A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply">http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply</A>
       var date = new Date(y, m, d, h, M, s, ms);
</PRE><PRE>       //the date constructor doesn't accept years &lt; 1970
       if (y &lt; 1970) {
           date.setFullYear(y);
       }
       return date;
   }
</PRE><PRE>   function createUTCDate (y) {
       var date = new Date(Date.UTC.apply(null, arguments));
       if (y &lt; 1970) {
           date.setUTCFullYear(y);
       }
       return date;
   }
</PRE><PRE>   addFormatToken(0, ['YY', 2], 0, function () {
       return this.year() % 100;
   });
</PRE><PRE>   addFormatToken(0, ['YYYY',   4],       0, 'year');
   addFormatToken(0, ['YYYYY',  5],       0, 'year');
   addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('year', 'y');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('Y',      matchSigned);
   addRegexToken('YY',     match1to2, match2);
   addRegexToken('YYYY',   match1to4, match4);
   addRegexToken('YYYYY',  match1to6, match6);
   addRegexToken('YYYYYY', match1to6, match6);
</PRE><PRE>   addParseToken(['YYYY', 'YYYYY', 'YYYYYY'], YEAR);
   addParseToken('YY', function (input, array) {
       array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   function daysInYear(year) {
       return isLeapYear(year) ? 366 : 365;
   }
</PRE><PRE>   function isLeapYear(year) {
       return (year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0;
   }
</PRE><PRE>   // HOOKS
</PRE><PRE>   utils_hooks__hooks.parseTwoDigitYear = function (input) {
       return toInt(input) + (toInt(input) &gt; 68 ? 1900 : 2000);
   };
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetYear = makeGetSet('FullYear', false);
</PRE><PRE>   function getIsLeapYear () {
       return isLeapYear(this.year());
   }
</PRE><PRE>   addFormatToken('w', ['ww', 2], 'wo', 'week');
   addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('week', 'w');
   addUnitAlias('isoWeek', 'W');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('w',  match1to2);
   addRegexToken('ww', match1to2, match2);
   addRegexToken('W',  match1to2);
   addRegexToken('WW', match1to2, match2);
</PRE><PRE>   addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
       week[token.substr(0, 1)] = toInt(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   // firstDayOfWeek       0 = sun, 6 = sat
   //                      the day of the week that starts the week
   //                      (usually sunday or monday)
   // firstDayOfWeekOfYear 0 = sun, 6 = sat
   //                      the first week is the week that contains the first
   //                      of this day of the week
   //                      (eg. ISO weeks use thursday (4))
   function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
       var end = firstDayOfWeekOfYear - firstDayOfWeek,
           daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
           adjustedMoment;
</PRE><PRE>       if (daysToDayOfWeek &gt; end) {
           daysToDayOfWeek -= 7;
       }
</PRE><PRE>       if (daysToDayOfWeek &lt; end - 7) {
           daysToDayOfWeek += 7;
       }
</PRE><PRE>       adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
       return {
           week: Math.ceil(adjustedMoment.dayOfYear() / 7),
           year: adjustedMoment.year()
       };
   }
</PRE><PRE>   // LOCALES
</PRE><PRE>   function localeWeek (mom) {
       return weekOfYear(mom, this._week.dow, this._week.doy).week;
   }
</PRE><PRE>   var defaultLocaleWeek = {
       dow : 0, // Sunday is the first day of the week.
       doy : 6  // The week that contains Jan 1st is the first week of the year.
   };
</PRE><PRE>   function localeFirstDayOfWeek () {
       return this._week.dow;
   }
</PRE><PRE>   function localeFirstDayOfYear () {
       return this._week.doy;
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetWeek (input) {
       var week = this.localeData().week(this);
       return input == null ? week : this.add((input - week) * 7, 'd');
   }
</PRE><PRE>   function getSetISOWeek (input) {
       var week = weekOfYear(this, 1, 4).week;
       return input == null ? week : this.add((input - week) * 7, 'd');
   }
</PRE><PRE>   addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('dayOfYear', 'DDD');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('DDD',  match1to3);
   addRegexToken('DDDD', match3);
   addParseToken(['DDD', 'DDDD'], function (input, array, config) {
       config._dayOfYear = toInt(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   //<A rel="nofollow" class="external free" href="http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday">http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday</A>
   function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
       var d = createUTCDate(year, 0, 1).getUTCDay();
       var daysToAdd;
       var dayOfYear;
</PRE><PRE> d = d === 0 ? 7 : d;
       weekday = weekday != null ? weekday : firstDayOfWeek;
       daysToAdd = firstDayOfWeek - d + (d &gt; firstDayOfWeekOfYear ? 7 : 0) - (d &lt; firstDayOfWeek ? 7 : 0);
       dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
</PRE><PRE>       return {
           year      : dayOfYear &gt; 0 ? year      : year - 1,
           dayOfYear : dayOfYear &gt; 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
       };
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetDayOfYear (input) {
       var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
       return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
   }
</PRE><PRE>   // Pick the first defined of two or three arguments.
   function defaults(a, b, c) {
       if (a != null) {
           return a;
       }
       if (b != null) {
           return b;
       }
       return c;
   }
</PRE><PRE>   function currentDateArray(config) {
       var now = new Date();
       if (config._useUTC) {
           return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
       }
       return [now.getFullYear(), now.getMonth(), now.getDate()];
   }
</PRE><PRE>   // convert an array to a date.
   // the array should mirror the parameters below
   // note: all values past the year are optional and will default to the lowest possible value.
   // [year, month, day , hour, minute, second, millisecond]
   function configFromArray (config) {
       var i, date, input = [], currentDate, yearToUse;
</PRE><PRE>       if (config._d) {
           return;
       }
</PRE><PRE>       currentDate = currentDateArray(config);
</PRE><PRE>       //compute day of the year from weeks and weekdays
       if (config._w &amp;&amp; config._a[DATE] == null &amp;&amp; config._a[MONTH] == null) {
           dayOfYearFromWeekInfo(config);
       }
</PRE><PRE>       //if the day of the year is set, figure out what it is
       if (config._dayOfYear) {
           yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
</PRE><PRE>           if (config._dayOfYear &gt; daysInYear(yearToUse)) {
               getParsingFlags(config)._overflowDayOfYear = true;
           }
</PRE><PRE>           date = createUTCDate(yearToUse, 0, config._dayOfYear);
           config._a[MONTH] = date.getUTCMonth();
           config._a[DATE] = date.getUTCDate();
       }
</PRE><PRE>       // Default to current date.
       // * if no year, month, day of month are given, default to today
       // * if day of month is given, default month and year
       // * if month is given, default only year
       // * if year is given, don't default anything
       for (i = 0; i &lt; 3 &amp;&amp; config._a[i] == null; ++i) {
           config._a[i] = input[i] = currentDate[i];
       }
</PRE><PRE>       // Zero out whatever was not defaulted, including time
       for (; i &lt; 7; i++) {
           config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
       }
</PRE><PRE>       // Check for 24:00:00.000
       if (config._a[HOUR] === 24 &amp;&amp;
               config._a[MINUTE] === 0 &amp;&amp;
               config._a[SECOND] === 0 &amp;&amp;
               config._a[MILLISECOND] === 0) {
           config._nextDay = true;
           config._a[HOUR] = 0;
       }
</PRE><PRE>       config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
       // Apply timezone offset from input. The actual utcOffset can be changed
       // with parseZone.
       if (config._tzm != null) {
           config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
       }
</PRE><PRE>       if (config._nextDay) {
           config._a[HOUR] = 24;
       }
   }
</PRE><PRE>   function dayOfYearFromWeekInfo(config) {
       var w, weekYear, week, weekday, dow, doy, temp;
</PRE><PRE>       w = config._w;
       if (w.GG != null || w.W != null || w.E != null) {
           dow = 1;
           doy = 4;
</PRE><PRE>           // TODO: We need to take the current isoWeekYear, but that depends on
           // how we interpret now (local, utc, fixed offset). So create
           // a now version of current config (take local/utc/offset flags, and
           // create now).
           weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
           week = defaults(w.W, 1);
           weekday = defaults(w.E, 1);
       } else {
           dow = config._locale._week.dow;
           doy = config._locale._week.doy;
</PRE><PRE>           weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
           week = defaults(w.w, 1);
</PRE><PRE>           if (w.d != null) {
               // weekday -- low day numbers are considered next week
               weekday = w.d;
               if (weekday &lt; dow) {
                   ++week;
               }
           } else if (w.e != null) {
               // local weekday -- counting starts from begining of week
               weekday = w.e + dow;
           } else {
               // default to begining of week
               weekday = dow;
           }
       }
       temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
</PRE><PRE>       config._a[YEAR] = temp.year;
       config._dayOfYear = temp.dayOfYear;
   }
</PRE><PRE>   utils_hooks__hooks.ISO_8601 = function () {};
</PRE><PRE>   // date from string and format string
   function configFromStringAndFormat(config) {
       // TODO: Move this to another part of the creation flow to prevent circular deps
       if (config._f === utils_hooks__hooks.ISO_8601) {
           configFromISO(config);
           return;
       }
</PRE><PRE>       config._a = [];
       getParsingFlags(config).empty = true;
</PRE><PRE>       // This array is used to make a Date, either with `new Date` or `Date.UTC`
       var string = <I> + config._i,</I>
           i, parsedInput, tokens, token, skipped,
           stringLength = string.length,
           totalParsedInputLength = 0;
</PRE><PRE>       tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
</PRE><PRE>       for (i = 0; i &lt; tokens.length; i++) {
           token = tokens[i];
           parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
           if (parsedInput) {
               skipped = string.substr(0, string.indexOf(parsedInput));
               if (skipped.length &gt; 0) {
                   getParsingFlags(config).unusedInput.push(skipped);
               }
               string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
               totalParsedInputLength += parsedInput.length;
           }
           // don't parse if it's not a known token
           if (formatTokenFunctions[token]) {
               if (parsedInput) {
                   getParsingFlags(config).empty = false;
               }
               else {
                   getParsingFlags(config).unusedTokens.push(token);
               }
               addTimeToArrayFromToken(token, parsedInput, config);
           }
           else if (config._strict &amp;&amp; !parsedInput) {
               getParsingFlags(config).unusedTokens.push(token);
           }
       }
</PRE><PRE>       // add remaining unparsed input length to the string
       getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
       if (string.length &gt; 0) {
           getParsingFlags(config).unusedInput.push(string);
       }
</PRE><PRE>       // clear _12h flag if hour is &lt;= 12
       if (getParsingFlags(config).bigHour === true &amp;&amp;
               config._a[HOUR] &lt;= 12 &amp;&amp;
               config._a[HOUR] &gt; 0) {
           getParsingFlags(config).bigHour = undefined;
       }
       // handle meridiem
       config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
</PRE><PRE>       configFromArray(config);
       checkOverflow(config);
   }
</PRE><PRE>   function meridiemFixWrap (locale, hour, meridiem) {
       var isPm;
</PRE><PRE>       if (meridiem == null) {
           // nothing to do
           return hour;
       }
       if (locale.meridiemHour != null) {
           return locale.meridiemHour(hour, meridiem);
       } else if (locale.isPM != null) {
           // Fallback
           isPm = locale.isPM(meridiem);
           if (isPm &amp;&amp; hour &lt; 12) {
               hour += 12;
           }
           if (!isPm &amp;&amp; hour === 12) {
               hour = 0;
           }
           return hour;
       } else {
           // this is not supposed to happen
           return hour;
       }
   }
</PRE><PRE>   function configFromStringAndArray(config) {
       var tempConfig,
           bestMoment,
</PRE><PRE>           scoreToBeat,
           i,
           currentScore;
</PRE><PRE>       if (config._f.length === 0) {
           getParsingFlags(config).invalidFormat = true;
           config._d = new Date(NaN);
           return;
       }
</PRE><PRE>       for (i = 0; i &lt; config._f.length; i++) {
           currentScore = 0;
           tempConfig = copyConfig({}, config);
           if (config._useUTC != null) {
               tempConfig._useUTC = config._useUTC;
           }
           tempConfig._f = config._f[i];
           configFromStringAndFormat(tempConfig);
</PRE><PRE>           if (!valid__isValid(tempConfig)) {
               continue;
           }
</PRE><PRE>           // if there is any input that was not parsed add a penalty for that format
           currentScore += getParsingFlags(tempConfig).charsLeftOver;
</PRE><PRE>           //or tokens
           currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
</PRE><PRE>           getParsingFlags(tempConfig).score = currentScore;
</PRE><PRE>           if (scoreToBeat == null || currentScore &lt; scoreToBeat) {
               scoreToBeat = currentScore;
               bestMoment = tempConfig;
           }
       }
</PRE><PRE>       extend(config, bestMoment || tempConfig);
   }
</PRE><PRE>   function configFromObject(config) {
       if (config._d) {
           return;
       }
</PRE><PRE>       var i = normalizeObjectUnits(config._i);
       config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];
</PRE><PRE>       configFromArray(config);
   }
</PRE><PRE>   function createFromConfig (config) {
       var input = config._i,
           format = config._f,
           res;
</PRE><PRE>       config._locale = config._locale || locale_locales__getLocale(config._l);
</PRE><PRE>       if (input === null || (format === undefined &amp;&amp; input === <I>)) {</I>
           return valid__createInvalid({nullInput: true});
       }
</PRE><PRE>       if (typeof input === 'string') {
           config._i = input = config._locale.preparse(input);
       }
</PRE><PRE>       if (isMoment(input)) {
           return new Moment(checkOverflow(input));
       } else if (isArray(format)) {
           configFromStringAndArray(config);
       } else if (format) {
           configFromStringAndFormat(config);
       } else if (isDate(input)) {
           config._d = input;
       } else {
           configFromInput(config);
       }
</PRE><PRE>       res = new Moment(checkOverflow(config));
       if (res._nextDay) {
           // Adding is smart enough around DST
           res.add(1, 'd');
           res._nextDay = undefined;
       }
</PRE><PRE>       return res;
   }
</PRE><PRE>   function configFromInput(config) {
       var input = config._i;
       if (input === undefined) {
           config._d = new Date();
       } else if (isDate(input)) {
           config._d = new Date(+input);
       } else if (typeof input === 'string') {
           configFromString(config);
       } else if (isArray(input)) {
           config._a = map(input.slice(0), function (obj) {
               return parseInt(obj, 10);
           });
           configFromArray(config);
       } else if (typeof(input) === 'object') {
           configFromObject(config);
       } else if (typeof(input) === 'number') {
           // from milliseconds
           config._d = new Date(input);
       } else {
           utils_hooks__hooks.createFromInputFallback(config);
       }
   }
</PRE><PRE>   function createLocalOrUTC (input, format, locale, strict, isUTC) {
       var c = {};
</PRE><PRE>       if (typeof(locale) === 'boolean') {
           strict = locale;
           locale = undefined;
       }
       // object construction must be done this way.
       // <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1423">https://github.com/moment/moment/issues/1423</A>
       c._isAMomentObject = true;
       c._useUTC = c._isUTC = isUTC;
       c._l = locale;
       c._i = input;
       c._f = format;
       c._strict = strict;
</PRE><PRE>       return createFromConfig(c);
   }
</PRE><PRE>   function local__createLocal (input, format, locale, strict) {
       return createLocalOrUTC(input, format, locale, strict, false);
   }
</PRE><PRE>   var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.min instead. <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1548'">https://github.com/moment/moment/issues/1548'</A>,
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other &lt; this ? this : other;
        }
    );
</PRE><PRE>   var prototypeMax = deprecate(
       'moment().max is deprecated, use moment.max instead. <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1548'">https://github.com/moment/moment/issues/1548'</A>,
       function () {
           var other = local__createLocal.apply(null, arguments);
           return other &gt; this ? this : other;
       }
   );
</PRE><PRE>   // Pick a moment m from moments so that m[fn](other) is true for all
   // other. This relies on the function fn to be transitive.
   //
   // moments should either be an array of moment objects or an array, whose
   // first element is an array of moment objects.
   function pickBy(fn, moments) {
       var res, i;
       if (moments.length === 1 &amp;&amp; isArray(moments[0])) {
           moments = moments[0];
       }
       if (!moments.length) {
           return local__createLocal();
       }
       res = moments[0];
       for (i = 1; i &lt; moments.length; ++i) {
           if (moments[i][fn](res)) {
               res = moments[i];
           }
       }
       return res;
   }
</PRE><PRE>   // TODO: Use [].sort instead?
   function min () {
       var args = [].slice.call(arguments, 0);
</PRE><PRE>       return pickBy('isBefore', args);
   }
</PRE><PRE>   function max () {
       var args = [].slice.call(arguments, 0);
</PRE><PRE>       return pickBy('isAfter', args);
   }
</PRE><PRE>   function Duration (duration) {
       var normalizedInput = normalizeObjectUnits(duration),
           years = normalizedInput.year || 0,
           quarters = normalizedInput.quarter || 0,
           months = normalizedInput.month || 0,
           weeks = normalizedInput.week || 0,
           days = normalizedInput.day || 0,
           hours = normalizedInput.hour || 0,
           minutes = normalizedInput.minute || 0,
           seconds = normalizedInput.second || 0,
           milliseconds = normalizedInput.millisecond || 0;
</PRE><PRE>       // representation for dateAddRemove
       this._milliseconds = +milliseconds +
           seconds * 1e3 + // 1000
           minutes * 6e4 + // 1000 * 60
           hours * 36e5; // 1000 * 60 * 60
       // Because of dateAddRemove treats 24 hours as different from a
       // day when working around DST, we need to store them separately
       this._days = +days +
           weeks * 7;
       // It is impossible translate months into days without knowing
       // which months you are are talking about, so we have to store
       // it separately.
       this._months = +months +
           quarters * 3 +
           years * 12;
</PRE><PRE>       this._data = {};
</PRE><PRE>       this._locale = locale_locales__getLocale();
</PRE><PRE>       this._bubble();
   }
</PRE><PRE>   function isDuration (obj) {
       return obj instanceof Duration;
   }
</PRE><PRE>   function offset (token, separator) {
       addFormatToken(token, 0, 0, function () {
           var offset = this.utcOffset();
           var sign = '+';
           if (offset &lt; 0) {
               offset = -offset;
               sign = '-';
           }
           return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
       });
   }
</PRE><PRE>   offset('Z', ':');
   offset('ZZ', <I>);</I></PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('Z',  matchOffset);
   addRegexToken('ZZ', matchOffset);
   addParseToken(['Z', 'ZZ'], function (input, array, config) {
       config._useUTC = true;
       config._tzm = offsetFromString(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   // timezone chunker
   // '+10:00' &gt; ['10',  '00']
   // '-1530'  &gt; ['-15', '30']
   var chunkOffset = /([\+\-]|\d\d)/gi;
</PRE><PRE>   function offsetFromString(string) {
       var matches = ((string || <I>).match(matchOffset) || []);</I>
       var chunk   = matches[matches.length - 1] || [];
       var parts   = (chunk + <I>).match(chunkOffset) || ['-', 0, 0];</I>
       var minutes = +(parts[1] * 60) + toInt(parts[2]);
</PRE><PRE>       return parts[0] === '+' ? minutes : -minutes;
   }
</PRE><PRE>   // Return a moment from input, that is local/utc/zone equivalent to model.
   function cloneWithOffset(input, model) {
       var res, diff;
       if (model._isUTC) {
           res = model.clone();
           diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
           // Use low-level api, because this fn is low-level api.
           res._d.setTime(+res._d + diff);
           utils_hooks__hooks.updateOffset(res, false);
           return res;
       } else {
           return local__createLocal(input).local();
       }
       return model._isUTC ? local__createLocal(input).zone(model._offset || 0) : local__createLocal(input).local();
   }
</PRE><PRE>   function getDateOffset (m) {
       // On Firefox.24 Date#getTimezoneOffset returns a floating point.
       // <A rel="nofollow" class="external free" href="https://github.com/moment/moment/pull/1871">https://github.com/moment/moment/pull/1871</A>
       return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
   }
</PRE><PRE>   // HOOKS
</PRE><PRE>   // This function will be called whenever a moment is mutated.
   // It is intended to keep the offset in sync with the timezone.
   utils_hooks__hooks.updateOffset = function () {};
</PRE><PRE>   // MOMENTS
</PRE><PRE>   // keepLocalTime = true means only change the timezone, without
   // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--&gt;
   // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
   // +0200, so we adjust the time as needed, to be valid.
   //
   // Keeping the time actually adds/subtracts (one hour)
   // from the actual represented time. That is why we call updateOffset
   // a second time. In case it wants us to change the offset again
   // _changeInProgress == true case, then we have to adjust, because
   // there is no such time in the given timezone.
   function getSetOffset (input, keepLocalTime) {
       var offset = this._offset || 0,
           localAdjust;
       if (input != null) {
           if (typeof input === 'string') {
               input = offsetFromString(input);
           }
           if (Math.abs(input) &lt; 16) {
               input = input * 60;
           }
           if (!this._isUTC &amp;&amp; keepLocalTime) {
               localAdjust = getDateOffset(this);
           }
           this._offset = input;
           this._isUTC = true;
           if (localAdjust != null) {
               this.add(localAdjust, 'm');
           }
           if (offset !== input) {
               if (!keepLocalTime || this._changeInProgress) {
                   add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
               } else if (!this._changeInProgress) {
                   this._changeInProgress = true;
                   utils_hooks__hooks.updateOffset(this, true);
                   this._changeInProgress = null;
               }
           }
           return this;
       } else {
           return this._isUTC ? offset : getDateOffset(this);
       }
   }
</PRE><PRE>   function getSetZone (input, keepLocalTime) {
       if (input != null) {
           if (typeof input !== 'string') {
               input = -input;
           }
</PRE><PRE>           this.utcOffset(input, keepLocalTime);
</PRE><PRE>           return this;
       } else {
           return -this.utcOffset();
       }
   }
</PRE><PRE>   function setOffsetToUTC (keepLocalTime) {
       return this.utcOffset(0, keepLocalTime);
   }
</PRE><PRE>   function setOffsetToLocal (keepLocalTime) {
       if (this._isUTC) {
           this.utcOffset(0, keepLocalTime);
           this._isUTC = false;
</PRE><PRE>           if (keepLocalTime) {
               this.subtract(getDateOffset(this), 'm');
           }
       }
       return this;
   }
</PRE><PRE>   function setOffsetToParsedOffset () {
       if (this._tzm) {
           this.utcOffset(this._tzm);
       } else if (typeof this._i === 'string') {
           this.utcOffset(offsetFromString(this._i));
       }
       return this;
   }
</PRE><PRE>   function hasAlignedHourOffset (input) {
       if (!input) {
           input = 0;
       }
       else {
           input = local__createLocal(input).utcOffset();
       }
</PRE><PRE>       return (this.utcOffset() - input) % 60 === 0;
   }
</PRE><PRE>   function isDaylightSavingTime () {
       return (
           this.utcOffset() &gt; this.clone().month(0).utcOffset() ||
           this.utcOffset() &gt; this.clone().month(5).utcOffset()
       );
   }
</PRE><PRE>   function isDaylightSavingTimeShifted () {
       if (this._a) {
           var other = this._isUTC ? create_utc__createUTC(this._a) : local__createLocal(this._a);
           return this.isValid() &amp;&amp; compareArrays(this._a, other.toArray()) &gt; 0;
       }
</PRE><PRE>       return false;
   }
</PRE><PRE>   function isLocal () {
       return !this._isUTC;
   }
</PRE><PRE>   function isUtcOffset () {
       return this._isUTC;
   }
</PRE><PRE>   function isUtc () {
       return this._isUTC &amp;&amp; this._offset === 0;
   }
</PRE><PRE>   var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
</PRE><PRE>   // from <A rel="nofollow" class="external free" href="http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html">http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html</A>
   // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
   var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
</PRE><PRE>   function create__createDuration (input, key) {
       var duration = input,
           // matching against regexp is expensive, do it on demand
           match = null,
           sign,
           ret,
           diffRes;
</PRE><PRE>       if (isDuration(input)) {
           duration = {
               ms : input._milliseconds,
               d  : input._days,
               M  : input._months
           };
       } else if (typeof input === 'number') {
           duration = {};
           if (key) {
               duration[key] = input;
           } else {
               duration.milliseconds = input;
           }
       } else if (!!(match = aspNetRegex.exec(input))) {
           sign = (match[1] === '-') ? -1 : 1;
           duration = {
               y  : 0,
               d  : toInt(match[DATE])        * sign,
               h  : toInt(match[HOUR])        * sign,
               m  : toInt(match[MINUTE])      * sign,
               s  : toInt(match[SECOND])      * sign,
               ms : toInt(match[MILLISECOND]) * sign
           };
       } else if (!!(match = create__isoRegex.exec(input))) {
           sign = (match[1] === '-') ? -1 : 1;
           duration = {
               y : parseIso(match[2], sign),
               M : parseIso(match[3], sign),
               d : parseIso(match[4], sign),
               h : parseIso(match[5], sign),
               m : parseIso(match[6], sign),
               s : parseIso(match[7], sign),
               w : parseIso(match[8], sign)
           };
       } else if (duration == null) {// checks for null or undefined
           duration = {};
       } else if (typeof duration === 'object' &amp;&amp; ('from' in duration || 'to' in duration)) {
           diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
</PRE><PRE>           duration = {};
           duration.ms = diffRes.milliseconds;
           duration.M = diffRes.months;
       }
</PRE><PRE>       ret = new Duration(duration);
</PRE><PRE>       if (isDuration(input) &amp;&amp; hasOwnProp(input, '_locale')) {
           ret._locale = input._locale;
       }
</PRE><PRE>       return ret;
   }
</PRE><PRE>   create__createDuration.fn = Duration.prototype;
</PRE><PRE>   function parseIso (inp, sign) {
       // We'd normally use ~~inp for this, but unfortunately it also
       // converts floats to ints.
       // inp may be undefined, so careful calling replace on it.
       var res = inp &amp;&amp; parseFloat(inp.replace(',', '.'));
       // apply sign while we're at it
       return (isNaN(res) ? 0 : res) * sign;
   }
</PRE><PRE>   function positiveMomentsDifference(base, other) {
       var res = {milliseconds: 0, months: 0};
</PRE><PRE>       res.months = other.month() - base.month() +
           (other.year() - base.year()) * 12;
       if (base.clone().add(res.months, 'M').isAfter(other)) {
           --res.months;
       }
</PRE><PRE>       res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
</PRE><PRE>       return res;
   }
</PRE><PRE>   function momentsDifference(base, other) {
       var res;
       other = cloneWithOffset(other, base);
       if (base.isBefore(other)) {
           res = positiveMomentsDifference(base, other);
       } else {
           res = positiveMomentsDifference(other, base);
           res.milliseconds = -res.milliseconds;
           res.months = -res.months;
       }
</PRE><PRE>       return res;
   }
</PRE><PRE>   function createAdder(direction, name) {
       return function (val, period) {
           var dur, tmp;
           //invert the arguments, but complain about it
           if (period !== null &amp;&amp; !isNaN(+period)) {
               deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
               tmp = val; val = period; period = tmp;
           }
</PRE><PRE>           val = typeof val === 'string' ? +val : val;
           dur = create__createDuration(val, period);
           add_subtract__addSubtract(this, dur, direction);
           return this;
       };
   }
</PRE><PRE>   function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
       var milliseconds = duration._milliseconds,
           days = duration._days,
           months = duration._months;
       updateOffset = updateOffset == null ? true : updateOffset;
</PRE><PRE>       if (milliseconds) {
           mom._d.setTime(+mom._d + milliseconds * isAdding);
       }
       if (days) {
           get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
       }
       if (months) {
           setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
       }
       if (updateOffset) {
           utils_hooks__hooks.updateOffset(mom, days || months);
       }
   }
</PRE><PRE>   var add_subtract__add      = createAdder(1, 'add');
   var add_subtract__subtract = createAdder(-1, 'subtract');
</PRE><PRE>   function moment_calendar__calendar (time) {
       // We want to compare the start of today, vs this.
       // Getting start-of-today depends on whether we're local/utc/offset or not.
       var now = time || local__createLocal(),
           sod = cloneWithOffset(now, this).startOf('day'),
           diff = this.diff(sod, 'days', true),
           format = diff &lt; -6 ? 'sameElse' :
               diff &lt; -1 ? 'lastWeek' :
               diff &lt; 0 ? 'lastDay' :
               diff &lt; 1 ? 'sameDay' :
               diff &lt; 2 ? 'nextDay' :
               diff &lt; 7 ? 'nextWeek' : 'sameElse';
       return this.format(this.localeData().calendar(format, this, local__createLocal(now)));
   }
</PRE><PRE>   function clone () {
       return new Moment(this);
   }
</PRE><PRE>   function isAfter (input, units) {
       var inputMs;
       units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
       if (units === 'millisecond') {
           input = isMoment(input) ? input : local__createLocal(input);
           return +this &gt; +input;
       } else {
           inputMs = isMoment(input) ? +input : +local__createLocal(input);
           return inputMs &lt; +this.clone().startOf(units);
       }
   }
</PRE><PRE>   function isBefore (input, units) {
       var inputMs;
       units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
       if (units === 'millisecond') {
           input = isMoment(input) ? input : local__createLocal(input);
           return +this &lt; +input;
       } else {
           inputMs = isMoment(input) ? +input : +local__createLocal(input);
           return +this.clone().endOf(units) &lt; inputMs;
       }
   }
</PRE><PRE>   function isBetween (from, to, units) {
       return this.isAfter(from, units) &amp;&amp; this.isBefore(to, units);
   }
</PRE><PRE>   function isSame (input, units) {
       var inputMs;
       units = normalizeUnits(units || 'millisecond');
       if (units === 'millisecond') {
           input = isMoment(input) ? input : local__createLocal(input);
           return +this === +input;
       } else {
           inputMs = +local__createLocal(input);
           return +(this.clone().startOf(units)) &lt;= inputMs &amp;&amp; inputMs &lt;= +(this.clone().endOf(units));
       }
   }
</PRE><PRE>   function absFloor (number) {
       if (number &lt; 0) {
           return Math.ceil(number);
       } else {
           return Math.floor(number);
       }
   }
</PRE><PRE>   function diff (input, units, asFloat) {
       var that = cloneWithOffset(input, this),
           zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
           delta, output;
</PRE><PRE>       units = normalizeUnits(units);
</PRE><PRE>       if (units === 'year' || units === 'month' || units === 'quarter') {
           output = monthDiff(this, that);
           if (units === 'quarter') {
               output = output / 3;
           } else if (units === 'year') {
               output = output / 12;
           }
       } else {
           delta = this - that;
           output = units === 'second' ? delta / 1e3 : // 1000
               units === 'minute' ? delta / 6e4 : // 1000 * 60
               units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
               units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
               units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
               delta;
       }
       return asFloat ? output : absFloor(output);
   }
</PRE><PRE>   function monthDiff (a, b) {
       // difference in months
       var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
           // b is in (anchor - 1 month, anchor + 1 month)
           anchor = a.clone().add(wholeMonthDiff, 'months'),
           anchor2, adjust;
</PRE><PRE>       if (b - anchor &lt; 0) {
           anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
           // linear across the month
           adjust = (b - anchor) / (anchor - anchor2);
       } else {
           anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
           // linear across the month
           adjust = (b - anchor) / (anchor2 - anchor);
       }
</PRE><PRE>       return -(wholeMonthDiff + adjust);
   }
</PRE><PRE>   utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
</PRE><PRE>   function toString () {
       return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
   }
</PRE><PRE>   function moment_format__toISOString () {
       var m = this.clone().utc();
       if (0 &lt; m.year() &amp;&amp; m.year() &lt;= 9999) {
           if ('function' === typeof Date.prototype.toISOString) {
               // native implementation is ~50x faster, use it when we can
               return this.toDate().toISOString();
           } else {
               return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
           }
       } else {
           return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
       }
   }
</PRE><PRE>   function format (inputString) {
       var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
       return this.localeData().postformat(output);
   }
</PRE><PRE>   function from (time, withoutSuffix) {
       if (!this.isValid()) {
           return this.localeData().invalidDate();
       }
       return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
   }
</PRE><PRE>   function fromNow (withoutSuffix) {
       return this.from(local__createLocal(), withoutSuffix);
   }
</PRE><PRE>   function to (time, withoutSuffix) {
       if (!this.isValid()) {
           return this.localeData().invalidDate();
       }
       return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
   }
</PRE><PRE>   function toNow (withoutSuffix) {
       return this.to(local__createLocal(), withoutSuffix);
   }
</PRE><PRE>   function locale (key) {
       var newLocaleData;
</PRE><PRE>       if (key === undefined) {
           return this._locale._abbr;
       } else {
           newLocaleData = locale_locales__getLocale(key);
           if (newLocaleData != null) {
               this._locale = newLocaleData;
           }
           return this;
       }
   }
</PRE><PRE>   var lang = deprecate(
       'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
       function (key) {
           if (key === undefined) {
               return this.localeData();
           } else {
               return this.locale(key);
           }
       }
   );
</PRE><PRE>   function localeData () {
       return this._locale;
   }
</PRE><PRE>   function startOf (units) {
       units = normalizeUnits(units);
       // the following switch intentionally omits break keywords
       // to utilize falling through the cases.
       switch (units) {
       case 'year':
           this.month(0);
           /* falls through */
       case 'quarter':
       case 'month':
           this.date(1);
           /* falls through */
       case 'week':
       case 'isoWeek':
       case 'day':
           this.hours(0);
           /* falls through */
       case 'hour':
           this.minutes(0);
           /* falls through */
       case 'minute':
           this.seconds(0);
           /* falls through */
       case 'second':
           this.milliseconds(0);
       }
</PRE><PRE>       // weeks are a special case
       if (units === 'week') {
           this.weekday(0);
       }
       if (units === 'isoWeek') {
           this.isoWeekday(1);
       }
</PRE><PRE>       // quarters are also special
       if (units === 'quarter') {
           this.month(Math.floor(this.month() / 3) * 3);
       }
</PRE><PRE>       return this;
   }
</PRE><PRE>   function endOf (units) {
       units = normalizeUnits(units);
       if (units === undefined || units === 'millisecond') {
           return this;
       }
       return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
   }
</PRE><PRE>   function to_type__valueOf () {
       return +this._d - ((this._offset || 0) * 60000);
   }
</PRE><PRE>   function unix () {
       return Math.floor(+this / 1000);
   }
</PRE><PRE>   function toDate () {
       return this._offset ? new Date(+this) : this._d;
   }
</PRE><PRE>   function toArray () {
       var m = this;
       return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
   }
</PRE><PRE>   function moment_valid__isValid () {
       return valid__isValid(this);
   }
</PRE><PRE>   function parsingFlags () {
       return extend({}, getParsingFlags(this));
   }
</PRE><PRE>   function invalidAt () {
       return getParsingFlags(this).overflow;
   }
</PRE><PRE>   addFormatToken(0, ['gg', 2], 0, function () {
       return this.weekYear() % 100;
   });
</PRE><PRE>   addFormatToken(0, ['GG', 2], 0, function () {
       return this.isoWeekYear() % 100;
   });
</PRE><PRE>   function addWeekYearFormatToken (token, getter) {
       addFormatToken(0, [token, token.length], 0, getter);
   }
</PRE><PRE>   addWeekYearFormatToken('gggg',     'weekYear');
   addWeekYearFormatToken('ggggg',    'weekYear');
   addWeekYearFormatToken('GGGG',  'isoWeekYear');
   addWeekYearFormatToken('GGGGG', 'isoWeekYear');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('weekYear', 'gg');
   addUnitAlias('isoWeekYear', 'GG');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('G',      matchSigned);
   addRegexToken('g',      matchSigned);
   addRegexToken('GG',     match1to2, match2);
   addRegexToken('gg',     match1to2, match2);
   addRegexToken('GGGG',   match1to4, match4);
   addRegexToken('gggg',   match1to4, match4);
   addRegexToken('GGGGG',  match1to6, match6);
   addRegexToken('ggggg',  match1to6, match6);
</PRE><PRE>   addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
       week[token.substr(0, 2)] = toInt(input);
   });
</PRE><PRE>   addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
       week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   function weeksInYear(year, dow, doy) {
       return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetWeekYear (input) {
       var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
       return input == null ? year : this.add((input - year), 'y');
   }
</PRE><PRE>   function getSetISOWeekYear (input) {
       var year = weekOfYear(this, 1, 4).year;
       return input == null ? year : this.add((input - year), 'y');
   }
</PRE><PRE>   function getISOWeeksInYear () {
       return weeksInYear(this.year(), 1, 4);
   }
</PRE><PRE>   function getWeeksInYear () {
       var weekInfo = this.localeData()._week;
       return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
   }
</PRE><PRE>   addFormatToken('Q', 0, 0, 'quarter');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('quarter', 'Q');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('Q', match1);
   addParseToken('Q', function (input, array) {
       array[MONTH] = (toInt(input) - 1) * 3;
   });
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetQuarter (input) {
       return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
   }
</PRE><PRE>   addFormatToken('D', ['DD', 2], 'Do', 'date');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('date', 'D');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('D',  match1to2);
   addRegexToken('DD', match1to2, match2);
   addRegexToken('Do', function (isStrict, locale) {
       return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
   });
</PRE><PRE>   addParseToken(['D', 'DD'], DATE);
   addParseToken('Do', function (input, array) {
       array[DATE] = toInt(input.match(match1to2)[0], 10);
   });
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetDayOfMonth = makeGetSet('Date', true);
</PRE><PRE>   addFormatToken('d', 0, 'do', 'day');
</PRE><PRE>   addFormatToken('dd', 0, 0, function (format) {
       return this.localeData().weekdaysMin(this, format);
   });
</PRE><PRE>   addFormatToken('ddd', 0, 0, function (format) {
       return this.localeData().weekdaysShort(this, format);
   });
</PRE><PRE>   addFormatToken('dddd', 0, 0, function (format) {
       return this.localeData().weekdays(this, format);
   });
</PRE><PRE>   addFormatToken('e', 0, 0, 'weekday');
   addFormatToken('E', 0, 0, 'isoWeekday');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('day', 'd');
   addUnitAlias('weekday', 'e');
   addUnitAlias('isoWeekday', 'E');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('d',    match1to2);
   addRegexToken('e',    match1to2);
   addRegexToken('E',    match1to2);
   addRegexToken('dd',   matchWord);
   addRegexToken('ddd',  matchWord);
   addRegexToken('dddd', matchWord);
</PRE><PRE>   addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
       var weekday = config._locale.weekdaysParse(input);
       // if we didn't get a weekday name, mark the date as invalid
       if (weekday != null) {
           week.d = weekday;
       } else {
           getParsingFlags(config).invalidWeekday = input;
       }
   });
</PRE><PRE>   addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
       week[token] = toInt(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   function parseWeekday(input, locale) {
       if (typeof input === 'string') {
           if (!isNaN(input)) {
               input = parseInt(input, 10);
           }
           else {
               input = locale.weekdaysParse(input);
               if (typeof input !== 'number') {
                   return null;
               }
           }
       }
       return input;
   }
</PRE><PRE>   // LOCALES
</PRE><PRE>   var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
   function localeWeekdays (m) {
       return this._weekdays[m.day()];
   }
</PRE><PRE>   var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
   function localeWeekdaysShort (m) {
       return this._weekdaysShort[m.day()];
   }
</PRE><PRE>   var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
   function localeWeekdaysMin (m) {
       return this._weekdaysMin[m.day()];
   }
</PRE><PRE>   function localeWeekdaysParse (weekdayName) {
       var i, mom, regex;
</PRE><PRE>       if (!this._weekdaysParse) {
           this._weekdaysParse = [];
       }
</PRE><PRE>       for (i = 0; i &lt; 7; i++) {
           // make the regex if we don't have it already
           if (!this._weekdaysParse[i]) {
               mom = local__createLocal([2000, 1]).day(i);
               regex = '^' + this.weekdays(mom, <I>) + '|^' + this.weekdaysShort(mom, </I>) + '|^' + this.weekdaysMin(mom, <I>);</I>
               this._weekdaysParse[i] = new RegExp(regex.replace('.', <I>), 'i');</I>
           }
           // test the regex
           if (this._weekdaysParse[i].test(weekdayName)) {
               return i;
           }
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetDayOfWeek (input) {
       var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
       if (input != null) {
           input = parseWeekday(input, this.localeData());
           return this.add(input - day, 'd');
       } else {
           return day;
       }
   }
</PRE><PRE>   function getSetLocaleDayOfWeek (input) {
       var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
       return input == null ? weekday : this.add(input - weekday, 'd');
   }
</PRE><PRE>   function getSetISODayOfWeek (input) {
       // behaves the same as moment#day except
       // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
       // as a setter, sunday should belong to the previous week.
       return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
   }
</PRE><PRE>   addFormatToken('H', ['HH', 2], 0, 'hour');
   addFormatToken('h', ['hh', 2], 0, function () {
       return this.hours() % 12 || 12;
   });
</PRE><PRE>   function meridiem (token, lowercase) {
       addFormatToken(token, 0, 0, function () {
           return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
       });
   }
</PRE><PRE>   meridiem('a', true);
   meridiem('A', false);
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('hour', 'h');
</PRE><PRE>   // PARSING
</PRE><PRE>   function matchMeridiem (isStrict, locale) {
       return locale._meridiemParse;
   }
</PRE><PRE>   addRegexToken('a',  matchMeridiem);
   addRegexToken('A',  matchMeridiem);
   addRegexToken('H',  match1to2);
   addRegexToken('h',  match1to2);
   addRegexToken('HH', match1to2, match2);
   addRegexToken('hh', match1to2, match2);
</PRE><PRE>   addParseToken(['H', 'HH'], HOUR);
   addParseToken(['a', 'A'], function (input, array, config) {
       config._isPm = config._locale.isPM(input);
       config._meridiem = input;
   });
   addParseToken(['h', 'hh'], function (input, array, config) {
       array[HOUR] = toInt(input);
       getParsingFlags(config).bigHour = true;
   });
</PRE><PRE>   // LOCALES
</PRE><PRE>   function localeIsPM (input) {
       // IE8 Quirks Mode &amp; IE7 Standards Mode do not allow accessing strings like arrays
       // Using charAt should be more compatible.
       return ((input + <I>).toLowerCase().charAt(0) === 'p');</I>
   }
</PRE><PRE>   var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
   function localeMeridiem (hours, minutes, isLower) {
       if (hours &gt; 11) {
           return isLower ? 'pm' : 'PM';
       } else {
           return isLower ? 'am' : 'AM';
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   // Setting the hour should keep the time, because the user explicitly
   // specified which hour he wants. So trying to maintain the same hour (in
   // a new timezone) makes sense. Adding/subtracting hours does not follow
   // this rule.
   var getSetHour = makeGetSet('Hours', true);
</PRE><PRE>   addFormatToken('m', ['mm', 2], 0, 'minute');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('minute', 'm');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('m',  match1to2);
   addRegexToken('mm', match1to2, match2);
   addParseToken(['m', 'mm'], MINUTE);
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetMinute = makeGetSet('Minutes', false);
</PRE><PRE>   addFormatToken('s', ['ss', 2], 0, 'second');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('second', 's');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('s',  match1to2);
   addRegexToken('ss', match1to2, match2);
   addParseToken(['s', 'ss'], SECOND);
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetSecond = makeGetSet('Seconds', false);
</PRE><PRE>   addFormatToken('S', 0, 0, function () {
       return ~~(this.millisecond() / 100);
   });
</PRE><PRE>   addFormatToken(0, ['SS', 2], 0, function () {
       return ~~(this.millisecond() / 10);
   });
</PRE><PRE>   function millisecond__milliseconds (token) {
       addFormatToken(0, [token, 3], 0, 'millisecond');
   }
</PRE><PRE>   millisecond__milliseconds('SSS');
   millisecond__milliseconds('SSSS');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('millisecond', 'ms');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('S',    match1to3, match1);
   addRegexToken('SS',   match1to3, match2);
   addRegexToken('SSS',  match1to3, match3);
   addRegexToken('SSSS', matchUnsigned);
   addParseToken(['S', 'SS', 'SSS', 'SSSS'], function (input, array) {
       array[MILLISECOND] = toInt(('0.' + input) * 1000);
   });
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetMillisecond = makeGetSet('Milliseconds', false);
</PRE><PRE>   addFormatToken('z',  0, 0, 'zoneAbbr');
   addFormatToken('zz', 0, 0, 'zoneName');
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getZoneAbbr () {
       return this._isUTC ? 'UTC' : <I>;</I>
   }
</PRE><PRE>   function getZoneName () {
       return this._isUTC ? 'Coordinated Universal Time' : <I>;</I>
   }
</PRE><PRE>   var momentPrototype__proto = Moment.prototype;
</PRE><PRE>   momentPrototype__proto.add          = add_subtract__add;
   momentPrototype__proto.calendar     = moment_calendar__calendar;
   momentPrototype__proto.clone        = clone;
   momentPrototype__proto.diff         = diff;
   momentPrototype__proto.endOf        = endOf;
   momentPrototype__proto.format       = format;
   momentPrototype__proto.from         = from;
   momentPrototype__proto.fromNow      = fromNow;
   momentPrototype__proto.to           = to;
   momentPrototype__proto.toNow        = toNow;
   momentPrototype__proto.get          = getSet;
   momentPrototype__proto.invalidAt    = invalidAt;
   momentPrototype__proto.isAfter      = isAfter;
   momentPrototype__proto.isBefore     = isBefore;
   momentPrototype__proto.isBetween    = isBetween;
   momentPrototype__proto.isSame       = isSame;
   momentPrototype__proto.isValid      = moment_valid__isValid;
   momentPrototype__proto.lang         = lang;
   momentPrototype__proto.locale       = locale;
   momentPrototype__proto.localeData   = localeData;
   momentPrototype__proto.max          = prototypeMax;
   momentPrototype__proto.min          = prototypeMin;
   momentPrototype__proto.parsingFlags = parsingFlags;
   momentPrototype__proto.set          = getSet;
   momentPrototype__proto.startOf      = startOf;
   momentPrototype__proto.subtract     = add_subtract__subtract;
   momentPrototype__proto.toArray      = toArray;
   momentPrototype__proto.toDate       = toDate;
   momentPrototype__proto.toISOString  = moment_format__toISOString;
   momentPrototype__proto.toJSON       = moment_format__toISOString;
   momentPrototype__proto.toString     = toString;
   momentPrototype__proto.unix         = unix;
   momentPrototype__proto.valueOf      = to_type__valueOf;
</PRE><PRE>   // Year
   momentPrototype__proto.year       = getSetYear;
   momentPrototype__proto.isLeapYear = getIsLeapYear;
</PRE><PRE>   // Week Year
   momentPrototype__proto.weekYear    = getSetWeekYear;
   momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
</PRE><PRE>   // Quarter
   momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
</PRE><PRE>   // Month
   momentPrototype__proto.month       = getSetMonth;
   momentPrototype__proto.daysInMonth = getDaysInMonth;
</PRE><PRE>   // Week
   momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
   momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
   momentPrototype__proto.weeksInYear    = getWeeksInYear;
   momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
</PRE><PRE>   // Day
   momentPrototype__proto.date       = getSetDayOfMonth;
   momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
   momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
   momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
   momentPrototype__proto.dayOfYear  = getSetDayOfYear;
</PRE><PRE>   // Hour
   momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
</PRE><PRE>   // Minute
   momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
</PRE><PRE>   // Second
   momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
</PRE><PRE>   // Millisecond
   momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
</PRE><PRE>   // Offset
   momentPrototype__proto.utcOffset            = getSetOffset;
   momentPrototype__proto.utc                  = setOffsetToUTC;
   momentPrototype__proto.local                = setOffsetToLocal;
   momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
   momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
   momentPrototype__proto.isDST                = isDaylightSavingTime;
   momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
   momentPrototype__proto.isLocal              = isLocal;
   momentPrototype__proto.isUtcOffset          = isUtcOffset;
   momentPrototype__proto.isUtc                = isUtc;
   momentPrototype__proto.isUTC                = isUtc;
</PRE><PRE>   // Timezone
   momentPrototype__proto.zoneAbbr = getZoneAbbr;
   momentPrototype__proto.zoneName = getZoneName;
</PRE><PRE>   // Deprecations
   momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
   momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
   momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
   momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1779'">https://github.com/moment/moment/issues/1779'</A>, getSetZone);
</PRE><PRE>   var momentPrototype = momentPrototype__proto;
</PRE><PRE>   function moment__createUnix (input) {
       return local__createLocal(input * 1000);
   }
</PRE><PRE>   function moment__createInZone () {
       return local__createLocal.apply(null, arguments).parseZone();
   }
</PRE><PRE>   var defaultCalendar = {
       sameDay : '[Today at] LT',
       nextDay : '[Tomorrow at] LT',
       nextWeek : 'dddd [at] LT',
       lastDay : '[Yesterday at] LT',
       lastWeek : '[Last] dddd [at] LT',
       sameElse : 'L'
   };
</PRE><PRE>   function locale_calendar__calendar (key, mom, now) {
       var output = this._calendar[key];
       return typeof output === 'function' ? output.call(mom, now) : output;
   }
</PRE><PRE>   var defaultLongDateFormat = {
       LTS  : 'h:mm:ss A',
       LT   : 'h:mm A',
       L    : 'MM/DD/YYYY',
       LL   : 'MMMM D, YYYY',
       LLL  : 'MMMM D, YYYY LT',
       LLLL : 'dddd, MMMM D, YYYY LT'
   };
</PRE><PRE>   function longDateFormat (key) {
       var output = this._longDateFormat[key];
       if (!output &amp;&amp; this._longDateFormat[key.toUpperCase()]) {
           output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
               return val.slice(1);
           });
           this._longDateFormat[key] = output;
       }
       return output;
   }
</PRE><PRE>   var defaultInvalidDate = 'Invalid date';
</PRE><PRE>   function invalidDate () {
       return this._invalidDate;
   }
</PRE><PRE>   var defaultOrdinal = '%d';
   var defaultOrdinalParse = /\d{1,2}/;
</PRE><PRE>   function ordinal (number) {
       return this._ordinal.replace('%d', number);
   }
</PRE><PRE>   function preParsePostFormat (string) {
       return string;
   }
</PRE><PRE>   var defaultRelativeTime = {
       future : 'in %s',
       past   : '%s ago',
       s  : 'a few seconds',
       m  : 'a minute',
       mm : '%d minutes',
       h  : 'an hour',
       hh : '%d hours',
       d  : 'a day',
       dd : '%d days',
       M  : 'a month',
       MM : '%d months',
       y  : 'a year',
       yy : '%d years'
   };
</PRE><PRE>   function relative__relativeTime (number, withoutSuffix, string, isFuture) {
       var output = this._relativeTime[string];
       return (typeof output === 'function') ?
           output(number, withoutSuffix, string, isFuture) :
           output.replace(/%d/i, number);
   }
</PRE><PRE>   function pastFuture (diff, output) {
       var format = this._relativeTime[diff &gt; 0 ? 'future' : 'past'];
       return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
   }
</PRE><PRE>   function locale_set__set (config) {
       var prop, i;
       for (i in config) {
           prop = config[i];
           if (typeof prop === 'function') {
               this[i] = prop;
           } else {
               this['_' + i] = prop;
           }
       }
       // Lenient ordinal parsing accepts just a number in addition to
       // number + (possibly) stuff coming from _ordinalParseLenient.
       this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
   }
</PRE><PRE>   var prototype__proto = Locale.prototype;
</PRE><PRE>   prototype__proto._calendar       = defaultCalendar;
   prototype__proto.calendar        = locale_calendar__calendar;
   prototype__proto._longDateFormat = defaultLongDateFormat;
   prototype__proto.longDateFormat  = longDateFormat;
   prototype__proto._invalidDate    = defaultInvalidDate;
   prototype__proto.invalidDate     = invalidDate;
   prototype__proto._ordinal        = defaultOrdinal;
   prototype__proto.ordinal         = ordinal;
   prototype__proto._ordinalParse   = defaultOrdinalParse;
   prototype__proto.preparse        = preParsePostFormat;
   prototype__proto.postformat      = preParsePostFormat;
   prototype__proto._relativeTime   = defaultRelativeTime;
   prototype__proto.relativeTime    = relative__relativeTime;
   prototype__proto.pastFuture      = pastFuture;
   prototype__proto.set             = locale_set__set;
</PRE><PRE>   // Month
   prototype__proto.months       =        localeMonths;
   prototype__proto._months      = defaultLocaleMonths;
   prototype__proto.monthsShort  =        localeMonthsShort;
   prototype__proto._monthsShort = defaultLocaleMonthsShort;
   prototype__proto.monthsParse  =        localeMonthsParse;
</PRE><PRE>   // Week
   prototype__proto.week = localeWeek;
   prototype__proto._week = defaultLocaleWeek;
   prototype__proto.firstDayOfYear = localeFirstDayOfYear;
   prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
</PRE><PRE>   // Day of Week
   prototype__proto.weekdays       =        localeWeekdays;
   prototype__proto._weekdays      = defaultLocaleWeekdays;
   prototype__proto.weekdaysMin    =        localeWeekdaysMin;
   prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
   prototype__proto.weekdaysShort  =        localeWeekdaysShort;
   prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
   prototype__proto.weekdaysParse  =        localeWeekdaysParse;
</PRE><PRE>   // Hours
   prototype__proto.isPM = localeIsPM;
   prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
   prototype__proto.meridiem = localeMeridiem;
</PRE><PRE>   function lists__get (format, index, field, setter) {
       var locale = locale_locales__getLocale();
       var utc = create_utc__createUTC().set(setter, index);
       return locale[field](utc, format);
   }
</PRE><PRE>   function list (format, index, field, count, setter) {
       if (typeof format === 'number') {
           index = format;
           format = undefined;
       }
</PRE><PRE>       format = format || <I>;</I></PRE><PRE>       if (index != null) {
           return lists__get(format, index, field, setter);
       }
</PRE><PRE>       var i;
       var out = [];
       for (i = 0; i &lt; count; i++) {
           out[i] = lists__get(format, i, field, setter);
       }
       return out;
   }
</PRE><PRE>   function lists__listMonths (format, index) {
       return list(format, index, 'months', 12, 'month');
   }
</PRE><PRE>   function lists__listMonthsShort (format, index) {
       return list(format, index, 'monthsShort', 12, 'month');
   }
</PRE><PRE>   function lists__listWeekdays (format, index) {
       return list(format, index, 'weekdays', 7, 'day');
   }
</PRE><PRE>   function lists__listWeekdaysShort (format, index) {
       return list(format, index, 'weekdaysShort', 7, 'day');
   }
</PRE><PRE>   function lists__listWeekdaysMin (format, index) {
       return list(format, index, 'weekdaysMin', 7, 'day');
   }
</PRE><PRE>   locale_locales__getSetGlobalLocale('en', {
       ordinalParse: /\d{1,2}(th|st|nd|rd)/,
       ordinal : function (number) {
           var b = number % 10,
               output = (toInt(number % 100 / 10) === 1) ? 'th' :
               (b === 1) ? 'st' :
               (b === 2) ? 'nd' :
               (b === 3) ? 'rd' : 'th';
           return number + output;
       }
   });
</PRE><PRE>   // Side effect imports
   utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
   utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
</PRE><PRE>   var mathAbs = Math.abs;
</PRE><PRE>   function duration_abs__abs () {
       var data           = this._data;
</PRE><PRE>       this._milliseconds = mathAbs(this._milliseconds);
       this._days         = mathAbs(this._days);
       this._months       = mathAbs(this._months);
</PRE><PRE>       data.milliseconds  = mathAbs(data.milliseconds);
       data.seconds       = mathAbs(data.seconds);
       data.minutes       = mathAbs(data.minutes);
       data.hours         = mathAbs(data.hours);
       data.months        = mathAbs(data.months);
       data.years         = mathAbs(data.years);
</PRE><PRE>       return this;
   }
</PRE><PRE>   function duration_add_subtract__addSubtract (duration, input, value, direction) {
       var other = create__createDuration(input, value);
</PRE><PRE>       duration._milliseconds += direction * other._milliseconds;
       duration._days         += direction * other._days;
       duration._months       += direction * other._months;
</PRE><PRE>       return duration._bubble();
   }
</PRE><PRE>   // supports only 2.0-style add(1, 's') or add(duration)
   function duration_add_subtract__add (input, value) {
       return duration_add_subtract__addSubtract(this, input, value, 1);
   }
</PRE><PRE>   // supports only 2.0-style subtract(1, 's') or subtract(duration)
   function duration_add_subtract__subtract (input, value) {
       return duration_add_subtract__addSubtract(this, input, value, -1);
   }
</PRE><PRE>   function bubble () {
       var milliseconds = this._milliseconds;
       var days         = this._days;
       var months       = this._months;
       var data         = this._data;
       var seconds, minutes, hours, years = 0;
</PRE><PRE>       // The following code bubbles up values, see the tests for
       // examples of what that means.
       data.milliseconds = milliseconds % 1000;
</PRE><PRE>       seconds           = absFloor(milliseconds / 1000);
       data.seconds      = seconds % 60;
</PRE><PRE>       minutes           = absFloor(seconds / 60);
       data.minutes      = minutes % 60;
</PRE><PRE>       hours             = absFloor(minutes / 60);
       data.hours        = hours % 24;
</PRE><PRE>       days += absFloor(hours / 24);
</PRE><PRE>       // Accurately convert days to years, assume start from year 0.
       years = absFloor(daysToYears(days));
       days -= absFloor(yearsToDays(years));
</PRE><PRE>       // 30 days to a month
       // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
       months += absFloor(days / 30);
       days   %= 30;
</PRE><PRE>       // 12 months -&gt; 1 year
       years  += absFloor(months / 12);
       months %= 12;
</PRE><PRE>       data.days   = days;
       data.months = months;
       data.years  = years;
</PRE><PRE>       return this;
   }
</PRE><PRE>   function daysToYears (days) {
       // 400 years have 146097 days (taking into account leap year rules)
       return days * 400 / 146097;
   }
</PRE><PRE>   function yearsToDays (years) {
       // years * 365 + absFloor(years / 4) -
       //     absFloor(years / 100) + absFloor(years / 400);
       return years * 146097 / 400;
   }
</PRE><PRE>   function as (units) {
       var days;
       var months;
       var milliseconds = this._milliseconds;
</PRE><PRE>       units = normalizeUnits(units);
</PRE><PRE>       if (units === 'month' || units === 'year') {
           days   = this._days   + milliseconds / 864e5;
           months = this._months + daysToYears(days) * 12;
           return units === 'month' ? months : months / 12;
       } else {
           // handle milliseconds separately because of floating point math errors (issue #1867)
           days = this._days + Math.round(yearsToDays(this._months / 12));
           switch (units) {
               case 'week'   : return days / 7     + milliseconds / 6048e5;
               case 'day'    : return days         + milliseconds / 864e5;
               case 'hour'   : return days * 24    + milliseconds / 36e5;
               case 'minute' : return days * 1440  + milliseconds / 6e4;
               case 'second' : return days * 86400 + milliseconds / 1000;
               // Math.floor prevents floating point math errors here
               case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
               default: throw new Error('Unknown unit ' + units);
           }
       }
   }
</PRE><PRE>   // TODO: Use this.as('ms')?
   function duration_as__valueOf () {
       return (
           this._milliseconds +
           this._days * 864e5 +
           (this._months % 12) * 2592e6 +
           toInt(this._months / 12) * 31536e6
       );
   }
</PRE><PRE>   function makeAs (alias) {
       return function () {
           return this.as(alias);
       };
   }
</PRE><PRE>   var asMilliseconds = makeAs('ms');
   var asSeconds      = makeAs('s');
   var asMinutes      = makeAs('m');
   var asHours        = makeAs('h');
   var asDays         = makeAs('d');
   var asWeeks        = makeAs('w');
   var asMonths       = makeAs('M');
   var asYears        = makeAs('y');
</PRE><PRE>   function duration_get__get (units) {
       units = normalizeUnits(units);
       return this[units + 's']();
   }
</PRE><PRE>  function makeGetter(name) {
       return function () {
           return this._data[name];
       };
   }
</PRE><PRE>   var duration_get__milliseconds = makeGetter('milliseconds');
   var seconds      = makeGetter('seconds');
   var minutes      = makeGetter('minutes');
   var hours        = makeGetter('hours');
   var days         = makeGetter('days');
   var months       = makeGetter('months');
   var years        = makeGetter('years');
</PRE><PRE>   function weeks () {
       return absFloor(this.days() / 7);
   }
</PRE><PRE>   var round = Math.round;
   var thresholds = {
       s: 45,  // seconds to minute
       m: 45,  // minutes to hour
       h: 22,  // hours to day
       d: 26,  // days to month
       M: 11   // months to year
   };
</PRE><PRE>   // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
   function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
       return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
   }
</PRE><PRE>   function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
       var duration = create__createDuration(posNegDuration).abs();
       var seconds  = round(duration.as('s'));
       var minutes  = round(duration.as('m'));
       var hours    = round(duration.as('h'));
       var days     = round(duration.as('d'));
       var months   = round(duration.as('M'));
       var years    = round(duration.as('y'));
</PRE><PRE>       var a = seconds &lt; thresholds.s &amp;&amp; ['s', seconds]  ||
               minutes === 1          &amp;&amp; ['m']           ||
               minutes &lt; thresholds.m &amp;&amp; ['mm', minutes] ||
               hours   === 1          &amp;&amp; ['h']           ||
               hours   &lt; thresholds.h &amp;&amp; ['hh', hours]   ||
               days    === 1          &amp;&amp; ['d']           ||
               days    &lt; thresholds.d &amp;&amp; ['dd', days]    ||
               months  === 1          &amp;&amp; ['M']           ||
               months  &lt; thresholds.M &amp;&amp; ['MM', months]  ||
               years   === 1          &amp;&amp; ['y']           || ['yy', years];
</PRE><PRE>       a[2] = withoutSuffix;
       a[3] = +posNegDuration &gt; 0;
       a[4] = locale;
       return substituteTimeAgo.apply(null, a);
   }
</PRE><PRE>   // This function allows you to set a threshold for relative time strings
   function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
       if (thresholds[threshold] === undefined) {
           return false;
       }
       if (limit === undefined) {
           return thresholds[threshold];
       }
       thresholds[threshold] = limit;
       return true;
   }
</PRE><PRE>   function humanize (withSuffix) {
       var locale = this.localeData();
       var output = duration_humanize__relativeTime(this, !withSuffix, locale);
</PRE><PRE>       if (withSuffix) {
           output = locale.pastFuture(+this, output);
       }
</PRE><PRE>       return locale.postformat(output);
   }
</PRE><PRE>   var iso_string__abs = Math.abs;
</PRE><PRE>   function iso_string__toISOString() {
       // inspired by <A rel="nofollow" class="external free" href="https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js">https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js</A>
       var Y = iso_string__abs(this.years());
       var M = iso_string__abs(this.months());
       var D = iso_string__abs(this.days());
       var h = iso_string__abs(this.hours());
       var m = iso_string__abs(this.minutes());
       var s = iso_string__abs(this.seconds() + this.milliseconds() / 1000);
       var total = this.asSeconds();
</PRE><PRE>       if (!total) {
           // this is the same as C#'s (Noda) and python (isodate)...
           // but not other JS (goog.date)
           return 'P0D';
       }
</PRE><PRE>       return (total &lt; 0 ? '-' : <I>) +</I>
           'P' +
           (Y ? Y + 'Y' : <I>) +</I> (M ? M + 'M' : <I>) +</I>
           (D ? D + 'D' : <I>) +</I>
           ((h || m || s) ? 'T' : <I>) +</I>
           (h ? h + 'H' : <I>) +</I>
           (m ? m + 'M' : <I>) +</I>
           (s ? s + 'S' : <I>);</I>
   }
</PRE><PRE>   var duration_prototype__proto = Duration.prototype;
</PRE><PRE>   duration_prototype__proto.abs            = duration_abs__abs;
   duration_prototype__proto.add            = duration_add_subtract__add;
   duration_prototype__proto.subtract       = duration_add_subtract__subtract;
   duration_prototype__proto.as             = as;
   duration_prototype__proto.asMilliseconds = asMilliseconds;
   duration_prototype__proto.asSeconds      = asSeconds;
   duration_prototype__proto.asMinutes      = asMinutes;
   duration_prototype__proto.asHours        = asHours;
   duration_prototype__proto.asDays         = asDays;
   duration_prototype__proto.asWeeks        = asWeeks;
   duration_prototype__proto.asMonths       = asMonths;
   duration_prototype__proto.asYears        = asYears;
   duration_prototype__proto.valueOf        = duration_as__valueOf;
   duration_prototype__proto._bubble        = bubble;
   duration_prototype__proto.get            = duration_get__get;
   duration_prototype__proto.milliseconds   = duration_get__milliseconds;
   duration_prototype__proto.seconds        = seconds;
   duration_prototype__proto.minutes        = minutes;
   duration_prototype__proto.hours          = hours;
   duration_prototype__proto.days           = days;
   duration_prototype__proto.weeks          = weeks;
   duration_prototype__proto.months         = months;
   duration_prototype__proto.years          = years;
   duration_prototype__proto.humanize       = humanize;
   duration_prototype__proto.toISOString    = iso_string__toISOString;
   duration_prototype__proto.toString       = iso_string__toISOString;
   duration_prototype__proto.toJSON         = iso_string__toISOString;
   duration_prototype__proto.locale         = locale;
   duration_prototype__proto.localeData     = localeData;
</PRE><PRE>   // Deprecations
   duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
   duration_prototype__proto.lang = lang;
</PRE><PRE>   // Side effect imports
</PRE><PRE>   addFormatToken('X', 0, 0, 'unix');
   addFormatToken('x', 0, 0, 'valueOf');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('x', matchSigned);
   addRegexToken('X', matchTimestamp);
   addParseToken('X', function (input, array, config) {
       config._d = new Date(parseFloat(input, 10) * 1000);
   });
   addParseToken('x', function (input, array, config) {
       config._d = new Date(toInt(input));
   });
</PRE><PRE>   // Side effect imports
</PRE><PRE>   utils_hooks__hooks.version = '2.10.3';
</PRE><PRE>   setHookCallback(local__createLocal);
</PRE><PRE>   utils_hooks__hooks.fn                    = momentPrototype;
   utils_hooks__hooks.min                   = min;
   utils_hooks__hooks.max                   = max;
   utils_hooks__hooks.utc                   = create_utc__createUTC;
   utils_hooks__hooks.unix                  = moment__createUnix;
   utils_hooks__hooks.months                = lists__listMonths;
   utils_hooks__hooks.isDate                = isDate;
   utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
   utils_hooks__hooks.invalid               = valid__createInvalid;
   utils_hooks__hooks.duration              = create__createDuration;
   utils_hooks__hooks.isMoment              = isMoment;
   utils_hooks__hooks.weekdays              = lists__listWeekdays;
   utils_hooks__hooks.parseZone             = moment__createInZone;
   utils_hooks__hooks.localeData            = locale_locales__getLocale;
   utils_hooks__hooks.isDuration            = isDuration;
   utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
   utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
   utils_hooks__hooks.defineLocale          = defineLocale;
   utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
   utils_hooks__hooks.normalizeUnits        = normalizeUnits;
   utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
</PRE><PRE>   var _moment = utils_hooks__hooks;
</PRE><PRE>   return _moment;
</PRE><P>}));
</P></DIV></DIV></DIV></DIV></BODY></HTML>
<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_SPSingapore_fullcalendar_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:SPSingapore/fullcalendar.js</SPAN></H1><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE>* FullCalendar v2.3.2
* Docs &amp; License: <A rel="nofollow" class="external free" href="http://fullcalendar.io/">http://fullcalendar.io/</A>
* (c) 2015 Adam Shaw
*/
</PRE><P>(function(factory) {
	if (typeof define === 'function' &amp;&amp; define.amd) {
		define([ 'jquery', 'moment' ], factory);
	}
	else if (typeof exports === 'object') { // Node/CommonJS
		module.exports = factory(require('jquery'), require('moment'));
	}
	else {
		factory(jQuery, moment);
	}
})(function($, moment) {
</P><P>var fc = $.fullCalendar = { version: &quot;2.3.2&quot; };
var fcViews = fc.views = {};
</P><P>
$.fn.fullCalendar = function(options) {
	var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
	var res = this; // what this function will return (this jQuery object by default)
</P><P>	this.each(function(i, _element) { // loop each DOM element involved
		var element = $(_element);
		var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
		var singleRes; // the returned value of this single method call
</P><P>		// a method call
		if (typeof options === 'string') {
			if (calendar &amp;&amp; $.isFunction(calendar[options])) {
				singleRes = calendar[options].apply(calendar, args);
				if (!i) {
					res = singleRes; // record the first method call result
				}
				if (options === 'destroy') { // for the destroy method, must remove Calendar object data
					element.removeData('fullCalendar');
				}
			}
		}
		// a new calendar initialization
		else if (!calendar) { // don't initialize twice
			calendar = new Calendar(element, options);
			element.data('fullCalendar', calendar);
			calendar.render();
		}
	});
</P><P>	return res;
};
</P><P>
var complexOptions = [ // names of options that are objects whose properties should be combined
	'header',
	'buttonText',
	'buttonIcons',
	'themeButtonIcons'
];
</P><P>
// Merges an array of option objects into a single object
function mergeOptions(optionObjs) {
	return mergeProps(optionObjs, complexOptions);
}
</P><P>
// Given options specified for the calendar's constructor, massages any legacy options into a non-legacy form.
// Converts View-Option-Hashes into the View-Specific-Options format.
function massageOverrides(input) {
	var overrides = { views: input.views || {} }; // the output. ensure a `views` hash
	var subObj;
</P><P>	// iterate through all option override properties (except `views`)
	$.each(input, function(name, val) {
		if (name != 'views') {
</P><P>			// could the value be a legacy View-Option-Hash?
			if (
				$.isPlainObject(val) &amp;&amp;
				!/(time|duration|interval)$/i.test(name) &amp;&amp; // exclude duration options. might be given as objects
				$.inArray(name, complexOptions) == -1 // complex options aren't allowed to be View-Option-Hashes
			) {
				subObj = null;
</P><P>				// iterate through the properties of this possible View-Option-Hash value
				$.each(val, function(subName, subVal) {
</P><P>					// is the property targeting a view?
					if (/^(month|week|day|default|basic(Week|Day)?|agenda(Week|Day)?)$/.test(subName)) {
						if (!overrides.views[subName]) { // ensure the view-target entry exists
							overrides.views[subName] = {};
						}
						overrides.views[subName][name] = subVal; // record the value in the `views` object
					}
					else { // a non-View-Option-Hash property
						if (!subObj) {
							subObj = {};
						}
						subObj[subName] = subVal; // accumulate these unrelated values for later
					}
				});
</P><P>				if (subObj) { // non-View-Option-Hash properties? transfer them as-is
					overrides[name] = subObj;
				}
			}
			else {
				overrides[name] = val; // transfer normal options as-is
			}
		}
	});
</P><P>	return overrides;
}
</P><P>// exports
fc.intersectionToSeg = intersectionToSeg;
fc.applyAll = applyAll;
fc.debounce = debounce;
fc.isInt = isInt;
fc.htmlEscape = htmlEscape;
fc.cssToStr = cssToStr;
fc.proxy = proxy;
fc.capitaliseFirstLetter = capitaliseFirstLetter;
</P><P>
/* FullCalendar-specific DOM Utilities
</P>*/
<P>
// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls, scrollbarWidths) {
	if (scrollbarWidths.left) {
		rowEls.css({
			'border-left-width': 1,
			'margin-left': scrollbarWidths.left - 1
		});
	}
	if (scrollbarWidths.right) {
		rowEls.css({
			'border-right-width': 1,
			'margin-right': scrollbarWidths.right - 1
		});
	}
}
</P><P>
// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls) {
	rowEls.css({
		'margin-left': <I>,</I>
		'margin-right': <I>,</I>
		'border-left-width': <I>,</I>
		'border-right-width': 
	});
}
</P><P>
// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
	$('body').addClass('fc-not-allowed');
}
</P><P>
// Returns the mouse cursor to its original look
function enableCursor() {
	$('body').removeClass('fc-not-allowed');
}
</P><P>
// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and 
// reduces the available height.
function distributeHeight(els, availableHeight, shouldRedistribute) {
</P><P>	// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
	// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
</P><P>	var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
	var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
	var flexEls = []; // elements that are allowed to expand. array of DOM nodes
	var flexOffsets = []; // amount of vertical space it takes up
	var flexHeights = []; // actual css height
	var usedHeight = 0;
</P><P>	undistributeHeight(els); // give all elements their natural height
</P><P>	// find elements that are below the recommended height (expandable).
	// important to query for heights in a single first pass (to avoid reflow oscillation).
	els.each(function(i, el) {
		var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = $(el).outerHeight(true);
</P><P>		if (naturalOffset &lt; minOffset) {
			flexEls.push(el);
			flexOffsets.push(naturalOffset);
			flexHeights.push($(el).height());
		}
		else {
			// this element stretches past recommended height (non-expandable). mark the space as occupied.
			usedHeight += naturalOffset;
		}
	});
</P><P>	// readjust the recommended height to only consider the height available to non-maxed-out rows.
	if (shouldRedistribute) {
		availableHeight -= usedHeight;
		minOffset1 = Math.floor(availableHeight / flexEls.length);
		minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
	}
</P><P>	// assign heights to all expandable elements
	$(flexEls).each(function(i, el) {
		var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = flexOffsets[i];
		var naturalHeight = flexHeights[i];
		var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding
</P><P>		if (naturalOffset &lt; minOffset) { // we check this again because redistribution might have changed things
			$(el).height(newHeight);
		}
	});
}
</P><P>
// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {
	els.height(<I>);</I>
}
</P><P>
// Given `els`, a jQuery set of &lt;td&gt; cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els) {
	var maxInnerWidth = 0;
</P><P>	els.find('&gt; *').each(function(i, innerEl) {
		var innerWidth = $(innerEl).outerWidth();
		if (innerWidth &gt; maxInnerWidth) {
			maxInnerWidth = innerWidth;
		}
	});
</P><P>	maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance
</P><P>	els.width(maxInnerWidth);
</P><P>	return maxInnerWidth;
}
</P><P>
// Turns a container element into a scroller if its contents is taller than the allotted height.
// Returns true if the element is now a scroller, false otherwise.
// NOTE: this method is best because it takes weird zooming dimensions into account
function setPotentialScroller(containerEl, height) {
	containerEl.height(height).addClass('fc-scroller');
</P><P>	// are scrollbars needed?
	if (containerEl[0].scrollHeight - 1 &gt; containerEl[0].clientHeight) { // !!! -1 because IE is often off-by-one :(
		return true;
	}
</P><P>	unsetScroller(containerEl); // undo
	return false;
}
</P><P>
// Takes an element that might have been a scroller, and turns it back into a normal element.
function unsetScroller(containerEl) {
	containerEl.height(<I>).removeClass('fc-scroller');</I>
}
</P><P>
/* General DOM Utilities
</P>*/
<P>fc.getClientRect = getClientRect;
fc.getContentRect = getContentRect;
fc.getScrollbarWidths = getScrollbarWidths;
</P><P>
// borrowed from <A rel="nofollow" class="external free" href="https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51">https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51</A>
function getScrollParent(el) {
	var position = el.css('position'),
		scrollParent = el.parents().filter(function() {
			var parent = $(this);
			return (/(auto|scroll)/).test(
				parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')
			);
		}).eq(0);
</P><P>	return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
}
</P><P>
// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
function getOuterRect(el) {
	var offset = el.offset();
</P><P>	return {
		left: offset.left,
		right: offset.left + el.outerWidth(),
		top: offset.top,
		bottom: offset.top + el.outerHeight()
	};
}
</P><P>
// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el) {
	var offset = el.offset();
	var scrollbarWidths = getScrollbarWidths(el);
	var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left;
	var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top;
</P><P>	return {
		left: left,
		right: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars
		top: top,
		bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
	};
}
</P><P>
// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
function getContentRect(el) {
	var offset = el.offset(); // just outside of border, margin not included
	var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left');
	var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top');
</P><P>	return {
		left: left,
		right: left + el.width(),
		top: top,
		bottom: top + el.height()
	};
}
</P><P>
// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getScrollbarWidths(el) {
	var leftRightWidth = el.innerWidth() - el[0].clientWidth; // the paddings cancel out, leaving the scrollbars
	var widths = {
		left: 0,
		right: 0,
		top: 0,
		bottom: el.innerHeight() - el[0].clientHeight // the paddings cancel out, leaving the bottom scrollbar
	};
</P><P>	if (getIsLeftRtlScrollbars() &amp;&amp; el.css('direction') == 'rtl') { // is the scrollbar on the left side?
		widths.left = leftRightWidth;
	}
	else {
		widths.right = leftRightWidth;
	}
</P><P>	return widths;
}
</P><P>
// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side
</P><P>var _isLeftRtlScrollbars = null;
</P><P>function getIsLeftRtlScrollbars() { // responsible for caching the computation
	if (_isLeftRtlScrollbars === null) {
		_isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
	}
	return _isLeftRtlScrollbars;
}
</P><P>function computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it
</P>
	var el = $('<DIV>&lt;div/&gt;</DIV>')
<P>		.css({
			position: 'absolute',
			top: -1000,
			left: 0,
			border: 0,
			padding: 0,
			overflow: 'scroll',
			direction: 'rtl'
		})
		.appendTo('body');
	var innerEl = el.children();
	var res = innerEl.offset().left &gt; el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
	el.remove();
	return res;
}
</P><P>
// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return &quot;medium&quot; for border width), will just return zero.
function getCssFloat(el, prop) {
	return parseFloat(el.css(prop)) || 0;
}
</P><P>
// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
	return ev.which == 1 &amp;&amp; !ev.ctrlKey;
}
</P><P>
/* Geometry
</P>*/
<P>
// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
	var res = {
		left: Math.max(rect1.left, rect2.left),
		right: Math.min(rect1.right, rect2.right),
		top: Math.max(rect1.top, rect2.top),
		bottom: Math.min(rect1.bottom, rect2.bottom)
	};
</P><P>	if (res.left &lt; res.right &amp;&amp; res.top &lt; res.bottom) {
		return res;
	}
	return false;
}
</P><P>
// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
	return {
		left: Math.min(Math.max(point.left, rect.left), rect.right),
		top: Math.min(Math.max(point.top, rect.top), rect.bottom)
	};
}
</P><P>
// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
	return {
		left: (rect.left + rect.right) / 2,
		top: (rect.top + rect.bottom) / 2
	};
}
</P><P>
// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
	return {
		left: point1.left - point2.left,
		top: point1.top - point2.top
	};
}
</P><P>
/* FullCalendar-specific Misc Utilities
</P>*/
<P>
// Creates a basic segment with the intersection of the two ranges. Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
// TODO: move to date section?
function intersectionToSeg(subjectRange, constraintRange) {
	var subjectStart = subjectRange.start;
	var subjectEnd = subjectRange.end;
	var constraintStart = constraintRange.start;
	var constraintEnd = constraintRange.end;
	var segStart, segEnd;
	var isStart, isEnd;
</P><P>	if (subjectEnd &gt; constraintStart &amp;&amp; subjectStart &lt; constraintEnd) { // in bounds at all?
</P><P>		if (subjectStart &gt;= constraintStart) {
			segStart = subjectStart.clone();
			isStart = true;
		}
		else {
			segStart = constraintStart.clone();
			isStart =  false;
		}
</P><P>		if (subjectEnd &lt;= constraintEnd) {
			segEnd = subjectEnd.clone();
			isEnd = true;
		}
		else {
			segEnd = constraintEnd.clone();
			isEnd = false;
		}
</P><P>		return {
			start: segStart,
			end: segEnd,
			isStart: isStart,
			isEnd: isEnd
		};
	}
}
</P><P>
/* Date Utilities
</P>*/
<P>fc.computeIntervalUnit = computeIntervalUnit;
fc.durationHasTime = durationHasTime;
</P><P>var dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];
var intervalUnits = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ];
</P><P>
// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
		ms: a.time() - b.time() // time-of-day from day start. disregards timezone
	});
}
</P><P>
// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
	});
}
</P><P>
// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a, b, unit) {
	return moment.duration(
		Math.round(a.diff(b, unit, true)), // returnFloat=true
		unit
	);
}
</P><P>
// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be &quot;days&quot; whereas 49 hours will be &quot;hours&quot;.
// Accepts start/end, a range object, or an original duration object.
function computeIntervalUnit(start, end) {
	var i, unit;
	var val;
</P><P>	for (i = 0; i &lt; intervalUnits.length; i++) {
		unit = intervalUnits[i];
		val = computeRangeAs(unit, start, end);
</P><P>		if (val &gt;= 1 &amp;&amp; isInt(val)) {
			break;
		}
	}
</P><P>	return unit; // will be &quot;milliseconds&quot; if nothing else matches
}
</P><P>
// Computes the number of units (like &quot;hours&quot;) in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit, start, end) {
</P><P>	if (end != null) { // given start, end
		return end.diff(start, unit, true);
	}
	else if (moment.isDuration(start)) { // given duration
		return start.as(unit);
	}
	else { // given { start, end } range object
		return start.end.diff(start.start, unit, true);
	}
}
</P><P>
// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {
	return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
}
</P><P>
function isNativeDate(input) {
	return  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
}
</P><P>
// Returns a boolean about whether the given input is a time string, like &quot;06:40:00&quot; or &quot;06:00&quot;
function isTimeString(str) {
	return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
}
</P><P>
/* General Utilities
</P>*/
<P>var hasOwnPropMethod = {}.hasOwnProperty;
</P><P>
// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexProps) {
	var dest = {};
	var i, name;
	var complexObjs;
	var j, val;
	var props;
</P><P>	if (complexProps) {
		for (i = 0; i &lt; complexProps.length; i++) {
			name = complexProps[i];
			complexObjs = [];
</P><P>			// collect the trailing object values, stopping when a non-object is discovered
			for (j = propObjs.length - 1; j &gt;= 0; j--) {
				val = propObjs[j][name];
</P><P>				if (typeof val === 'object') {
					complexObjs.unshift(val);
				}
				else if (val !== undefined) {
					dest[name] = val; // if there were no objects, this value will be used
					break;
				}
			}
</P><P>			// if the trailing values were objects, use the merged value
			if (complexObjs.length) {
				dest[name] = mergeProps(complexObjs);
			}
		}
	}
</P><P>	// copy values into the destination, going from last to first
	for (i = propObjs.length - 1; i &gt;= 0; i--) {
		props = propObjs[i];
</P><P>		for (name in props) {
			if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
				dest[name] = props[name];
			}
		}
	}
</P><P>	return dest;
}
</P><P>
// Create an object that has the given prototype. Just like Object.create
function createObject(proto) {
	var f = function() {};
	f.prototype = proto;
	return new f();
}
</P><P>
function copyOwnProps(src, dest) {
	for (var name in src) {
		if (hasOwnProp(src, name)) {
			dest[name] = src[name];
		}
	}
}
</P><P>
// Copies over certain methods with the same names as Object.prototype methods. Overcomes an IE&lt;=8 bug:
// <A rel="nofollow" class="external free" href="https://developer.mozilla.org/en-US/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug">https://developer.mozilla.org/en-US/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug</A>
function copyNativeMethods(src, dest) {
	var names = [ 'constructor', 'toString', 'valueOf' ];
	var i, name;
</P><P>	for (i = 0; i &lt; names.length; i++) {
		name = names[i];
</P><P>		if (src[name] !== Object.prototype[name]) {
			dest[name] = src[name];
		}
	}
}
</P><P>
function hasOwnProp(obj, name) {
	return hasOwnPropMethod.call(obj, name);
}
</P><P>
// Is the given value a non-object non-function value?
function isAtomic(val) {
	return /undefined|null|boolean|number|string/.test($.type(val));
}
</P><P>
function applyAll(functions, thisObj, args) {
	if ($.isFunction(functions)) {
		functions = [ functions ];
	}
	if (functions) {
		var i;
		var ret;
		for (i=0; i&lt;functions.length; i++) {
			ret = functions[i].apply(thisObj, args) || ret;
		}
		return ret;
	}
}
</P><P>
function firstDefined() {
	for (var i=0; i&lt;arguments.length; i++) {
		if (arguments[i] !== undefined) {
			return arguments[i];
		}
	}
}
</P><P>
function htmlEscape(s) {
	return (s + <I>).replace(/&amp;/g, '&amp;')</I>
		.replace(/&lt;/g, '&lt;')
		.replace(/&gt;/g, '&gt;')
		.replace(/'/g, ''')
		.replace(/&quot;/g, '&quot;')
		.replace(/\n/g, '');
}
</P><P>
function stripHtmlEntities(text) {
	return text.replace(/&amp;.*?;/g, <I>);</I>
}
</P><P>
// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {
	var statements = [];
</P><P>	$.each(cssProps, function(name, val) {
		if (val != null) {
			statements.push(name + ':' + val);
		}
	});
</P><P>	return statements.join(';');
}
</P><P>
function capitaliseFirstLetter(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
}
</P><P>
function compareNumbers(a, b) { // for .sort()
	return a - b;
}
</P><P>
function isInt(n) {
	return n % 1 === 0;
}
</P><P>
// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj, methodName) {
	var method = obj[methodName];
</P><P>	return function() {
		return method.apply(obj, arguments);
	};
}
</P><P>
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds.
// <A rel="nofollow" class="external free" href="https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714">https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714</A>
function debounce(func, wait) {
	var timeoutId;
	var args;
	var context;
	var timestamp; // of most recent call
	var later = function() {
		var last = +new Date() - timestamp;
		if (last &lt; wait &amp;&amp; last &gt; 0) {
			timeoutId = setTimeout(later, wait - last);
		}
		else {
			timeoutId = null;
			func.apply(context, args);
			if (!timeoutId) {
				context = args = null;
			}
		}
	};
</P><P>	return function() {
		context = this;
		args = arguments;
		timestamp = +new Date();
		if (!timeoutId) {
			timeoutId = setTimeout(later, wait);
		}
	};
}
</P><P>var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
var ambigTimeOrZoneRegex =
	/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods
var allowValueOptimization;
var setUTCValues; // function defined below
var setLocalValues; // function defined below
</P><P>
// Creating
// -------------------------------------------------------------------------------------------------
</P><P>// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
fc.moment = function() {
	return makeMoment(arguments);
};
</P><P>// Sames as fc.moment, but forces the resulting moment to be in the UTC timezone.
fc.moment.utc = function() {
	var mom = makeMoment(arguments, true);
</P><P>	// Force it into UTC because makeMoment doesn't guarantee it
	// (if given a pre-existing moment for example)
	if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone
		mom.utc();
	}
</P><P>	return mom;
};
</P><P>// Same as fc.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
fc.moment.parseZone = function() {
	return makeMoment(arguments, true, true);
};
</P><P>// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be &quot;parsed&quot; (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args, parseAsUTC, parseZone) {
	var input = args[0];
	var isSingleString = args.length == 1 &amp;&amp; typeof input === 'string';
	var isAmbigTime;
	var isAmbigZone;
	var ambigMatch;
	var mom;
</P><P>	if (moment.isMoment(input)) {
		mom = moment.apply(null, args); // clone it
		transferAmbigs(input, mom); // the ambig flags weren't transfered with the clone
	}
	else if (isNativeDate(input) || input === undefined) {
		mom = moment.apply(null, args); // will be local
	}
	else { // &quot;parsing&quot; is required
		isAmbigTime = false;
		isAmbigZone = false;
</P><P>		if (isSingleString) {
			if (ambigDateOfMonthRegex.test(input)) {
				// accept strings like '2014-05', but convert to the first of the month
				input += '-01';
				args = [ input ]; // for when we pass it on to moment's constructor
				isAmbigTime = true;
				isAmbigZone = true;
			}
			else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
				isAmbigTime = !ambigMatch[5]; // no time part?
				isAmbigZone = true;
			}
		}
		else if ($.isArray(input)) {
			// arrays have no timezone information, so assume ambiguous zone
			isAmbigZone = true;
		}
		// otherwise, probably a string with a format
</P><P>		if (parseAsUTC || isAmbigTime) {
			mom = moment.utc.apply(moment, args);
		}
		else {
			mom = moment.apply(null, args);
		}
</P><P>		if (isAmbigTime) {
			mom._ambigTime = true;
			mom._ambigZone = true; // ambiguous time always means ambiguous zone
		}
		else if (parseZone) { // let's record the inputted zone somehow
			if (isAmbigZone) {
				mom._ambigZone = true;
			}
			else if (isSingleString) {
				if (mom.utcOffset) {
					mom.utcOffset(input); // if not a valid zone, will assign UTC
				}
				else {
					mom.zone(input); // for moment-pre-2.9
				}
			}
		}
	}
</P><P>	mom._fullCalendar = true; // flag for extended functionality
</P><P>	return mom;
}
</P><P>
// A clone method that works with the flags related to our enhanced functionality.
// In the future, use moment.momentProperties
newMomentProto.clone = function() {
	var mom = oldMomentProto.clone.apply(this, arguments);
</P><P>	// these flags weren't transfered with the clone
	transferAmbigs(this, mom);
	if (this._fullCalendar) {
		mom._fullCalendar = true;
	}
</P><P>	return mom;
};
</P><P>
// Week Number
// -------------------------------------------------------------------------------------------------
</P><P>
// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week = newMomentProto.weeks = function(input) {
	var weekCalc = (this._locale || this._lang) // works pre-moment-2.8
		._fullCalendar_weekCalc;
</P><P>	if (input == null &amp;&amp; typeof weekCalc === 'function') { // custom function only works for getter
		return weekCalc(this);
	}
	else if (weekCalc === 'ISO') {
		return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
	}
</P><P>	return oldMomentProto.week.apply(this, arguments); // local getter/setter
};
</P><P>
// Time-of-day
// -------------------------------------------------------------------------------------------------
</P><P>// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time = function(time) {
</P><P>	// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
	// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
	if (!this._fullCalendar) {
		return oldMomentProto.time.apply(this, arguments);
	}
</P><P>	if (time == null) { // getter
		return moment.duration({
			hours: this.hours(),
			minutes: this.minutes(),
			seconds: this.seconds(),
			milliseconds: this.milliseconds()
		});
	}
	else { // setter
</P><P>		this._ambigTime = false; // mark that the moment now has a time
</P><P>		if (!moment.isDuration(time) &amp;&amp; !moment.isMoment(time)) {
			time = moment.duration(time);
		}
</P><P>		// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
		// Only for Duration times, not Moment times.
		var dayHours = 0;
		if (moment.isDuration(time)) {
			dayHours = Math.floor(time.asDays()) * 24;
		}
</P><P>		// We need to set the individual fields.
		// Can't use startOf('day') then add duration. In case of DST at start of day.
		return this.hours(dayHours + time.hours())
			.minutes(time.minutes())
			.seconds(time.seconds())
			.milliseconds(time.milliseconds());
	}
};
</P><P>// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime = function() {
	var a;
</P><P>	if (!this._ambigTime) {
</P><P>		// get the values before any conversion happens
		a = this.toArray(); // array of y/m/d/h/m/s/ms
</P><P>		// TODO: use keepLocalTime in the future
		this.utc(); // set the internal UTC flag (will clear the ambig flags)
		setUTCValues(this, a.slice(0, 3)); // set the year/month/date. time will be zero
</P><P>		// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears all ambig flags. Same with setUTCValues with moment-timezone.
		this._ambigTime = true;
		this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
	}
</P><P>	return this; // for chaining
};
</P><P>// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function() {
	return !this._ambigTime;
};
</P><P>
// Timezone
// -------------------------------------------------------------------------------------------------
</P><P>// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
// TODO: look into Moment's keepLocalTime functionality
newMomentProto.stripZone = function() {
	var a, wasAmbigTime;
</P><P>	if (!this._ambigZone) {
</P><P>		// get the values before any conversion happens
		a = this.toArray(); // array of y/m/d/h/m/s/ms
		wasAmbigTime = this._ambigTime;
</P><P>		this.utc(); // set the internal UTC flag (might clear the ambig flags, depending on Moment internals)
		setUTCValues(this, a); // will set the year/month/date/hours/minutes/seconds/ms
</P><P>		// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
		this._ambigTime = wasAmbigTime || false;
</P><P>		// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears the ambig flags. Same with setUTCValues with moment-timezone.
		this._ambigZone = true;
	}
</P><P>	return this; // for chaining
};
</P><P>// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function() {
	return !this._ambigZone;
};
</P><P>
// this method implicitly marks a zone
newMomentProto.local = function() {
	var a = this.toArray(); // year,month,date,hours,minutes,seconds,ms as an array
	var wasAmbigZone = this._ambigZone;
</P><P>	oldMomentProto.local.apply(this, arguments);
</P><P>	// ensure non-ambiguous
	// this probably already happened via local() -&gt; utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;
</P><P>	if (wasAmbigZone) {
		// If the moment was ambiguously zoned, the date fields were stored as UTC.
		// We want to preserve these, but in local time.
		// TODO: look into Moment's keepLocalTime functionality
		setLocalValues(this, a);
	}
</P><P>	return this; // for chaining
};
</P><P>
// implicitly marks a zone
newMomentProto.utc = function() {
	oldMomentProto.utc.apply(this, arguments);
</P><P>	// ensure non-ambiguous
	// this probably already happened via utc() -&gt; utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;
</P><P>	return this;
};
</P><P>
// methods for arbitrarily manipulating timezone offset.
// should clear time/zone ambiguity when called.
$.each([
	'zone', // only in moment-pre-2.9. deprecated afterwards
	'utcOffset'
], function(i, name) {
	if (oldMomentProto[name]) { // original method exists?
</P><P>		// this method implicitly marks a zone (will probably get called upon .utc() and .local())
		newMomentProto[name] = function(tzo) {
</P><P>			if (tzo != null) { // setter
				// these assignments needs to happen before the original zone method is called.
				// I forget why, something to do with a browser crash.
				this._ambigTime = false;
				this._ambigZone = false;
			}
</P><P>			return oldMomentProto[name].apply(this, arguments);
		};
	}
});
</P><P>
// Formatting
// -------------------------------------------------------------------------------------------------
</P><P>newMomentProto.format = function() {
	if (this._fullCalendar &amp;&amp; arguments[0]) { // an enhanced moment? and a format string provided?
		return formatDate(this, arguments[0]); // our extended formatting
	}
	if (this._ambigTime) {
		return oldMomentFormat(this, 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
	}
	return oldMomentProto.format.apply(this, arguments);
};
</P><P>newMomentProto.toISOString = function() {
	if (this._ambigTime) {
		return oldMomentFormat(this, 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
	}
	return oldMomentProto.toISOString.apply(this, arguments);
};
</P><P>
// Querying
// -------------------------------------------------------------------------------------------------
</P><P>// Is the moment within the specified range? `end` is exclusive.
// FYI, this method is not a standard Moment method, so always do our enhanced logic.
newMomentProto.isWithin = function(start, end) {
	var a = commonlyAmbiguate([ this, start, end ]);
	return a[0] &gt;= a[1] &amp;&amp; a[0] &lt; a[2];
};
</P><P>// When isSame is called with units, timezone ambiguity is normalized before the comparison happens.
// If no units specified, the two moments must be identically the same, with matching ambig flags.
newMomentProto.isSame = function(input, units) {
	var a;
</P><P>	// only do custom logic if this is an enhanced moment
	if (!this._fullCalendar) {
		return oldMomentProto.isSame.apply(this, arguments);
	}
</P><P>	if (units) {
		a = commonlyAmbiguate([ this, input ], true); // normalize timezones but don't erase times
		return oldMomentProto.isSame.call(a[0], a[1], units);
	}
	else {
		input = fc.moment.parseZone(input); // normalize input
		return oldMomentProto.isSame.call(this, input) &amp;&amp;
			Boolean(this._ambigTime) === Boolean(input._ambigTime) &amp;&amp;
			Boolean(this._ambigZone) === Boolean(input._ambigZone);
	}
};
</P><P>// Make these query methods work with ambiguous moments
$.each([
	'isBefore',
	'isAfter'
], function(i, methodName) {
	newMomentProto[methodName] = function(input, units) {
		var a;
</P><P>		// only do custom logic if this is an enhanced moment
		if (!this._fullCalendar) {
			return oldMomentProto[methodName].apply(this, arguments);
		}
</P><P>		a = commonlyAmbiguate([ this, input ]);
		return oldMomentProto[methodName].call(a[0], a[1], units);
	};
});
</P><P>
// Misc Internals
// -------------------------------------------------------------------------------------------------
</P><P>// given an array of moment-like inputs, return a parallel array w/ moments similarly ambiguated.
// for example, of one moment has ambig time, but not others, all moments will have their time stripped.
// set `preserveTime` to `true` to keep times, but only normalize zone ambiguity.
// returns the original moments if no modifications are necessary.
function commonlyAmbiguate(inputs, preserveTime) {
	var anyAmbigTime = false;
	var anyAmbigZone = false;
	var len = inputs.length;
	var moms = [];
	var i, mom;
</P><P>	// parse inputs into real moments and query their ambig flags
	for (i = 0; i &lt; len; i++) {
		mom = inputs[i];
		if (!moment.isMoment(mom)) {
			mom = fc.moment.parseZone(mom);
		}
		anyAmbigTime = anyAmbigTime || mom._ambigTime;
		anyAmbigZone = anyAmbigZone || mom._ambigZone;
		moms.push(mom);
	}
</P><P>	// strip each moment down to lowest common ambiguity
	// use clones to avoid modifying the original moments
	for (i = 0; i &lt; len; i++) {
		mom = moms[i];
		if (!preserveTime &amp;&amp; anyAmbigTime &amp;&amp; !mom._ambigTime) {
			moms[i] = mom.clone().stripTime();
		}
		else if (anyAmbigZone &amp;&amp; !mom._ambigZone) {
			moms[i] = mom.clone().stripZone();
		}
	}
</P><P>	return moms;
}
</P><P>// Transfers all the flags related to ambiguous time/zone from the `src` moment to the `dest` moment
// TODO: look into moment.momentProperties for this.
function transferAmbigs(src, dest) {
	if (src._ambigTime) {
		dest._ambigTime = true;
	}
	else if (dest._ambigTime) {
		dest._ambigTime = false;
	}
</P><P>	if (src._ambigZone) {
		dest._ambigZone = true;
	}
	else if (dest._ambigZone) {
		dest._ambigZone = false;
	}
}
</P><P>
// Sets the year/month/date/etc values of the moment from the given array.
// Inefficient because it calls each individual setter.
function setMomentValues(mom, a) {
	mom.year(a[0] || 0)
		.month(a[1] || 0)
		.date(a[2] || 0)
		.hours(a[3] || 0)
		.minutes(a[4] || 0)
		.seconds(a[5] || 0)
		.milliseconds(a[6] || 0);
}
</P><P>// Can we set the moment's internal date directly?
allowValueOptimization = '_d' in moment() &amp;&amp; 'updateOffset' in moment;
</P><P>// Utility function. Accepts a moment and an array of the UTC year/month/date/etc values to set.
// Assumes the given moment is already in UTC mode.
setUTCValues = allowValueOptimization ? function(mom, a) {
	// simlate what moment's accessors do
	mom._d.setTime(Date.UTC.apply(Date, a));
	moment.updateOffset(mom, false); // keepTime=false
} : setMomentValues;
</P><P>// Utility function. Accepts a moment and an array of the local year/month/date/etc values to set.
// Assumes the given moment is already in local mode.
setLocalValues = allowValueOptimization ? function(mom, a) {
	// simlate what moment's accessors do
	mom._d.setTime(+new Date( // FYI, there is now way to apply an array of args to a constructor
		a[0] || 0,
		a[1] || 0,
		a[2] || 0,
		a[3] || 0,
		a[4] || 0,
		a[5] || 0,
		a[6] || 0
	));
	moment.updateOffset(mom, false); // keepTime=false
} : setMomentValues;
</P><P>// Single Date Formatting
// -------------------------------------------------------------------------------------------------
</P><P>
// call this if you want Moment's original format method to be used
function oldMomentFormat(mom, formatStr) {
	return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
}
</P><P>
// Formats `date` with a Moment formatting string, but allow our non-zero areas and
// additional token.
function formatDate(date, formatStr) {
	return formatDateWithChunks(date, getFormatStringChunks(formatStr));
}
</P><P>
function formatDateWithChunks(date, chunks) {
	var s = <I>;</I>
	var i;
</P><P>	for (i=0; i&lt;chunks.length; i++) {
		s += formatDateWithChunk(date, chunks[i]);
	}
</P><P>	return s;
}
</P><P>
// addition formatting tokens we want recognized
var tokenOverrides = {
	t: function(date) { // &quot;a&quot; or &quot;p&quot;
		return oldMomentFormat(date, 'a').charAt(0);
	},
	T: function(date) { // &quot;A&quot; or &quot;P&quot;
		return oldMomentFormat(date, 'A').charAt(0);
	}
};
</P><P>
function formatDateWithChunk(date, chunk) {
	var token;
	var maybeStr;
</P><P>	if (typeof chunk === 'string') { // a literal string
		return chunk;
	}
	else if ((token = chunk.token)) { // a token, like &quot;YYYY&quot;
		if (tokenOverrides[token]) {
			return tokenOverrides[token](date); // use our custom token
		}
		return oldMomentFormat(date, token);
	}
	else if (chunk.maybe) { // a grouping of other chunks that must be non-zero
		maybeStr = formatDateWithChunks(date, chunk.maybe);
		if (maybeStr.match(/[1-9]/)) {
			return maybeStr;
		}
	}
</P><P>	return <I>;</I>
}
</P><P>
// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset
</P><P>// Using a formatting string meant for a single date, generate a range string, like
// &quot;Sep 2 - 9 2013&quot;, that intelligently inserts a separator where the dates differ.
// If the dates are the same as far as the format string is concerned, just return a single
// rendering of one date, without any separator.
function formatRange(date1, date2, formatStr, separator, isRTL) {
	var localeData;
</P><P>	date1 = fc.moment.parseZone(date1);
	date2 = fc.moment.parseZone(date2);
</P><P>	localeData = (date1.localeData || date1.lang).call(date1); // works with moment-pre-2.8
</P><P>	// Expand localized format strings, like &quot;LL&quot; -&gt; &quot;MMMM D YYYY&quot;
	formatStr = localeData.longDateFormat(formatStr) || formatStr;
	// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
	// or non-zero areas in Moment's localized format strings.
</P><P>	separator = separator || ' - ';
</P><P>	return formatRangeWithChunks(
		date1,
		date2,
		getFormatStringChunks(formatStr),
		separator,
		isRTL
	);
}
fc.formatRange = formatRange; // expose
</P><P>
function formatRangeWithChunks(date1, date2, chunks, separator, isRTL) {
	var chunkStr; // the rendering of the chunk
	var leftI;
	var leftStr = <I>;</I>
	var rightI;
	var rightStr = <I>;</I>
	var middleI;
	var middleStr1 = <I>;</I>
	var middleStr2 = <I>;</I>
	var middleStr = <I>;</I></P><P>	// Start at the leftmost side of the formatting string and continue until you hit a token
	// that is not the same between dates.
	for (leftI=0; leftI&lt;chunks.length; leftI++) {
		chunkStr = formatSimilarChunk(date1, date2, chunks[leftI]);
		if (chunkStr === false) {
			break;
		}
		leftStr += chunkStr;
	}
</P><P>	// Similarly, start at the rightmost side of the formatting string and move left
	for (rightI=chunks.length-1; rightI&gt;leftI; rightI--) {
		chunkStr = formatSimilarChunk(date1, date2, chunks[rightI]);
		if (chunkStr === false) {
			break;
		}
		rightStr = chunkStr + rightStr;
	}
</P><P>	// The area in the middle is different for both of the dates.
	// Collect them distinctly so we can jam them together later.
	for (middleI=leftI; middleI&lt;=rightI; middleI++) {
		middleStr1 += formatDateWithChunk(date1, chunks[middleI]);
		middleStr2 += formatDateWithChunk(date2, chunks[middleI]);
	}
</P><P>	if (middleStr1 || middleStr2) {
		if (isRTL) {
			middleStr = middleStr2 + separator + middleStr1;
		}
		else {
			middleStr = middleStr1 + separator + middleStr2;
		}
	}
</P><P>	return leftStr + middleStr + rightStr;
}
</P><P>
var similarUnitMap = {
	Y: 'year',
	M: 'month',
	D: 'day', // day of month
	d: 'day', // day of week
	// prevents a separator between anything time-related...
	A: 'second', // AM/PM
	a: 'second', // am/pm
	T: 'second', // A/P
	t: 'second', // a/p
	H: 'second', // hour (24)
	h: 'second', // hour (12)
	m: 'second', // minute
	s: 'second' // second
};
// TODO: week maybe?
</P><P>
// Given a formatting chunk, and given that both dates are similar in the regard the
// formatting chunk is concerned, format date1 against `chunk`. Otherwise, return `false`.
function formatSimilarChunk(date1, date2, chunk) {
	var token;
	var unit;
</P><P>	if (typeof chunk === 'string') { // a literal string
		return chunk;
	}
	else if ((token = chunk.token)) {
		unit = similarUnitMap[token.charAt(0)];
		// are the dates the same for this unit of measurement?
		if (unit &amp;&amp; date1.isSame(date2, unit)) {
			return oldMomentFormat(date1, token); // would be the same if we used `date2`
			// BTW, don't support custom tokens
		}
	}
</P><P>	return false; // the chunk is NOT the same for the two dates
	// BTW, don't support splitting on non-zero areas
}
</P><P>
// Chunking Utils
// -------------------------------------------------------------------------------------------------
</P><P>
var formatStringChunkCache = {};
</P><P>
function getFormatStringChunks(formatStr) {
	if (formatStr in formatStringChunkCache) {
		return formatStringChunkCache[formatStr];
	}
	return (formatStringChunkCache[formatStr] = chunkFormatString(formatStr));
}
</P><P>
// Break the formatting string into an array of chunks
function chunkFormatString(formatStr) {
	var chunks = [];
	var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g; // TODO: more descrimination
	var match;
</P><P>	while ((match = chunker.exec(formatStr))) {
		if (match[1]) { // a literal string inside [ ... ]
			chunks.push(match[1]);
		}
		else if (match[2]) { // non-zero formatting inside ( ... )
			chunks.push({ maybe: chunkFormatString(match[2]) });
		}
		else if (match[3]) { // a formatting token
			chunks.push({ token: match[3] });
		}
		else if (match[5]) { // an unenclosed literal string
			chunks.push(match[5]);
		}
	}
</P><P>	return chunks;
}
</P><P>fc.Class = Class; // export
</P><P>// class that all other classes will inherit from
function Class() { }
</P><P>// called upon a class to create a subclass
Class.extend = function(members) {
	var superClass = this;
	var subClass;
</P><P>	members = members || {};
</P><P>	// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist
	if (hasOwnProp(members, 'constructor')) {
		subClass = members.constructor;
	}
	if (typeof subClass !== 'function') {
		subClass = members.constructor = function() {
			superClass.apply(this, arguments);
		};
	}
</P><P>	// build the base prototype for the subclass, which is an new object chained to the superclass's prototype
	subClass.prototype = createObject(superClass.prototype);
</P><P>	// copy each member variable/method onto the the subclass's prototype
	copyOwnProps(members, subClass.prototype);
	copyNativeMethods(members, subClass.prototype); // hack for IE8
</P><P>	// copy over all class variables/methods to the subclass, such as `extend` and `mixin`
	copyOwnProps(superClass, subClass);
</P><P>	return subClass;
};
</P><P>// adds new member variables/methods to the class's prototype.
// can be called with another class, or a plain object hash containing new members.
Class.mixin = function(members) {
	copyOwnProps(members.prototype || members, this.prototype); // TODO: copyNativeMethods?
};
</P><P>/* A rectangular panel that is absolutely positioned over other content
</P><P>Options:
	- className (string)
	- content (HTML string or jQuery element set)
	- parentEl
	- top
	- left
	- right (the x coord of where the right edge should be. not a &quot;CSS&quot; right)
	- autoHide (boolean)
	- show (callback)
	- hide (callback)
</P><UL><LI>/</LI></UL><P>var Popover = Class.extend({
</P><P>	isHidden: true,
	options: null,
	el: null, // the container element for the popover. generated by this object
	documentMousedownProxy: null, // document mousedown handler bound to `this`
	margin: 10, // the space required between the popover and the edges of the scroll container
</P><P>
	constructor: function(options) {
		this.options = options || {};
	},
</P><P>
	// Shows the popover on the specified position. Renders it if not already
	show: function() {
		if (this.isHidden) {
			if (!this.el) {
				this.render();
			}
			this.el.show();
			this.position();
			this.isHidden = false;
			this.trigger('show');
		}
	},
</P><P>
	// Hides the popover, through CSS, but does not remove it from the DOM
	hide: function() {
		if (!this.isHidden) {
			this.el.hide();
			this.isHidden = true;
			this.trigger('hide');
		}
	},
</P><P>
	// Creates `this.el` and renders content inside of it
	render: function() {
		var _this = this;
		var options = this.options;
</P><P>		this.el = $('&lt;div class=&quot;fc-popover&quot;/&gt;')
			.addClass(options.className || <I>)</I>
			.css({
				// position initially to the top left to avoid creating scrollbars
				top: 0,
				left: 0
			})
			.append(options.content)
			.appendTo(options.parentEl);
</P><P>		// when a click happens on anything inside with a 'fc-close' className, hide the popover
		this.el.on('click', '.fc-close', function() {
			_this.hide();
		});
</P><P>		if (options.autoHide) {
			$(document).on('mousedown', this.documentMousedownProxy = proxy(this, 'documentMousedown'));
		}
	},
</P><P>
	// Triggered when the user clicks *anywhere* in the document, for the autoHide feature
	documentMousedown: function(ev) {
		// only hide the popover if the click happened outside the popover
		if (this.el &amp;&amp; !$(ev.target).closest(this.el).length) {
			this.hide();
		}
	},
</P><P>
	// Hides and unregisters any handlers
	removeElement: function() {
		this.hide();
</P><P>		if (this.el) {
			this.el.remove();
			this.el = null;
		}
</P><P>		$(document).off('mousedown', this.documentMousedownProxy);
	},
</P><P>
	// Positions the popover optimally, using the top/left/right options
	position: function() {
		var options = this.options;
		var origin = this.el.offsetParent().offset();
		var width = this.el.outerWidth();
		var height = this.el.outerHeight();
		var windowEl = $(window);
		var viewportEl = getScrollParent(this.el);
		var viewportTop;
		var viewportLeft;
		var viewportOffset;
		var top; // the &quot;position&quot; (not &quot;offset&quot;) values for the popover
		var left; //
</P><P>		// compute top and left
		top = options.top || 0;
		if (options.left !== undefined) {
			left = options.left;
		}
		else if (options.right !== undefined) {
			left = options.right - width; // derive the left value from the right value
		}
		else {
			left = 0;
		}
</P><P>		if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result
			viewportEl = windowEl;
			viewportTop = 0; // the window is always at the top left
			viewportLeft = 0; // (and .offset() won't work if called here)
		}
		else {
			viewportOffset = viewportEl.offset();
			viewportTop = viewportOffset.top;
			viewportLeft = viewportOffset.left;
		}
</P><P>		// if the window is scrolled, it causes the visible area to be further down
		viewportTop += windowEl.scrollTop();
		viewportLeft += windowEl.scrollLeft();
</P><P>		// constrain to the view port. if constrained by two edges, give precedence to top/left
		if (options.viewportConstrain !== false) {
			top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
			top = Math.max(top, viewportTop + this.margin);
			left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
			left = Math.max(left, viewportLeft + this.margin);
		}
</P><P>		this.el.css({
			top: top - origin.top,
			left: left - origin.left
		});
	},
</P><P>
	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	// TODO: better code reuse for this. Repeat code
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	}
</P><P>});
</P><P>/* A &quot;coordinate map&quot; converts pixel coordinates into an associated cell, which has an associated date
</P><P>Common interface:
</P><P>	CoordMap.prototype = {
		build: function() {},
		getCell: function(x, y) {}
	};
</P><UL><LI>/</LI></UL><P>/* Coordinate map for a grid component
</P>*/
<P>var GridCoordMap = Class.extend({
</P><P>	grid: null, // reference to the Grid
	rowCoords: null, // array of {top,bottom} objects
	colCoords: null, // array of {left,right} objects
</P><P>	containerEl: null, // container element that all coordinates are constrained to. optionally assigned
	bounds: null,
</P><P>
	constructor: function(grid) {
		this.grid = grid;
	},
</P><P>
	// Queries the grid for the coordinates of all the cells
	build: function() {
		this.grid.build();
		this.rowCoords = this.grid.computeRowCoords();
		this.colCoords = this.grid.computeColCoords();
		this.computeBounds();
	},
</P><P>
	// Clears the coordinates data to free up memory
	clear: function() {
		this.grid.clear();
		this.rowCoords = null;
		this.colCoords = null;
	},
</P><P>
	// Given a coordinate of the document, gets the associated cell. If no cell is underneath, returns null
	getCell: function(x, y) {
		var rowCoords = this.rowCoords;
		var rowCnt = rowCoords.length;
		var colCoords = this.colCoords;
		var colCnt = colCoords.length;
		var hitRow = null;
		var hitCol = null;
		var i, coords;
		var cell;
</P><P>		if (this.inBounds(x, y)) {
</P><P>			for (i = 0; i &lt; rowCnt; i++) {
				coords = rowCoords[i];
				if (y &gt;= coords.top &amp;&amp; y &lt; coords.bottom) {
					hitRow = i;
					break;
				}
			}
</P><P>			for (i = 0; i &lt; colCnt; i++) {
				coords = colCoords[i];
				if (x &gt;= coords.left &amp;&amp; x &lt; coords.right) {
					hitCol = i;
					break;
				}
			}
</P><P>			if (hitRow !== null &amp;&amp; hitCol !== null) {
</P><P>				cell = this.grid.getCell(hitRow, hitCol); // expected to return a fresh object we can modify
				cell.grid = this.grid; // for CellDragListener's isCellsEqual. dragging between grids
</P><P>				// make the coordinates available on the cell object
				$.extend(cell, rowCoords[hitRow], colCoords[hitCol]);
</P><P>				return cell;
			}
		}
</P><P>		return null;
	},
</P><P>
	// If there is a containerEl, compute the bounds into min/max values
	computeBounds: function() {
		this.bounds = this.containerEl ?
			getClientRect(this.containerEl) : // area within scrollbars
			null;
	},
</P><P>
	// Determines if the given coordinates are in bounds. If no `containerEl`, always true
	inBounds: function(x, y) {
		var bounds = this.bounds;
</P><P>		if (bounds) {
			return x &gt;= bounds.left &amp;&amp; x &lt; bounds.right &amp;&amp; y &gt;= bounds.top &amp;&amp; y &lt; bounds.bottom;
		}
</P><P>		return true;
	}
</P><P>});
</P><P>
/* Coordinate map that is a combination of multiple other coordinate maps
</P>*/
<P>var ComboCoordMap = Class.extend({
</P><P>	coordMaps: null, // an array of CoordMaps
</P><P>
	constructor: function(coordMaps) {
		this.coordMaps = coordMaps;
	},
</P><P>
	// Builds all coordMaps
	build: function() {
		var coordMaps = this.coordMaps;
		var i;
</P><P>		for (i = 0; i &lt; coordMaps.length; i++) {
			coordMaps[i].build();
		}
	},
</P><P>
	// Queries all coordMaps for the cell underneath the given coordinates, returning the first result
	getCell: function(x, y) {
		var coordMaps = this.coordMaps;
		var cell = null;
		var i;
</P><P>		for (i = 0; i &lt; coordMaps.length &amp;&amp; !cell; i++) {
			cell = coordMaps[i].getCell(x, y);
		}
</P><P>		return cell;
	},
</P><P>
	// Clears all coordMaps
	clear: function() {
		var coordMaps = this.coordMaps;
		var i;
</P><P>		for (i = 0; i &lt; coordMaps.length; i++) {
			coordMaps[i].clear();
		}
	}
</P><P>});
</P><P>/* Tracks a drag's mouse movement, firing various handlers
</P>*/
<P>var DragListener = fc.DragListener = Class.extend({
</P><P>	options: null,
</P><P>	isListening: false,
	isDragging: false,
</P><P>	// coordinates of the initial mousedown
	originX: null,
	originY: null,
</P><P>	// handler attached to the document, bound to the DragListener's `this`
	mousemoveProxy: null,
	mouseupProxy: null,
</P><P>	// for IE8 bug-fighting behavior, for now
	subjectEl: null, // the element being draged. optional
	subjectHref: null,
</P><P>	scrollEl: null,
	scrollBounds: null, // { top, bottom, left, right }
	scrollTopVel: null, // pixels per second
	scrollLeftVel: null, // pixels per second
	scrollIntervalId: null, // ID of setTimeout for scrolling animation loop
	scrollHandlerProxy: null, // this-scoped function for handling when scrollEl is scrolled
</P><P>	scrollSensitivity: 30, // pixels from edge for scrolling to start
	scrollSpeed: 200, // pixels per second, at maximum speed
	scrollIntervalMs: 50, // millisecond wait between scroll increment
</P><P>
	constructor: function(options) {
		options = options || {};
		this.options = options;
		this.subjectEl = options.subjectEl;
	},
</P><P>
	// Call this when the user does a mousedown. Will probably lead to startListening
	mousedown: function(ev) {
		if (isPrimaryMouseButton(ev)) {
</P><P>			ev.preventDefault(); // prevents native selection in most browsers
</P><P>			this.startListening(ev);
</P><P>			// start the drag immediately if there is no minimum distance for a drag start
			if (!this.options.distance) {
				this.startDrag(ev);
			}
		}
	},
</P><P>
	// Call this to start tracking mouse movements
	startListening: function(ev) {
		var scrollParent;
</P><P>	if (!this.isListening) {
</P><P>			// grab scroll container and attach handler
			if (ev &amp;&amp; this.options.scroll) {
				scrollParent = getScrollParent($(ev.target));
				if (!scrollParent.is(window) &amp;&amp; !scrollParent.is(document)) {
					this.scrollEl = scrollParent;
</P><P>					// scope to `this`, and use `debounce` to make sure rapid calls don't happen
					this.scrollHandlerProxy = debounce(proxy(this, 'scrollHandler'), 100);
					this.scrollEl.on('scroll', this.scrollHandlerProxy);
				}
			}
</P><P>			$(document)
				.on('mousemove', this.mousemoveProxy = proxy(this, 'mousemove'))
				.on('mouseup', this.mouseupProxy = proxy(this, 'mouseup'))
				.on('selectstart', this.preventDefault); // prevents native selection in IE&lt;=8
</P><P>			if (ev) {
				this.originX = ev.pageX;
				this.originY = ev.pageY;
			}
			else {
				// if no starting information was given, origin will be the topleft corner of the screen.
				// if so, dx/dy in the future will be the absolute coordinates.
				this.originX = 0;
				this.originY = 0;
			}
</P><P>			this.isListening = true;
			this.listenStart(ev);
		}
	},
</P><P>
	// Called when drag listening has started (but a real drag has not necessarily began)
	listenStart: function(ev) {
		this.trigger('listenStart', ev);
	},
</P><P>
	// Called when the user moves the mouse
	mousemove: function(ev) {
		var dx = ev.pageX - this.originX;
		var dy = ev.pageY - this.originY;
		var minDistance;
		var distanceSq; // current distance from the origin, squared
</P><P>		if (!this.isDragging) { // if not already dragging...
			// then start the drag if the minimum distance criteria is met
			minDistance = this.options.distance || 1;
			distanceSq = dx * dx + dy * dy;
			if (distanceSq &gt;= minDistance * minDistance) { // use pythagorean theorem
				this.startDrag(ev);
			}
		}
</P><P>		if (this.isDragging) {
			this.drag(dx, dy, ev); // report a drag, even if this mousemove initiated the drag
		}
	},
</P><P>
	// Call this to initiate a legitimate drag.
	// This function is called internally from this class, but can also be called explicitly from outside
	startDrag: function(ev) {
</P><P>		if (!this.isListening) { // startDrag must have manually initiated
			this.startListening();
		}
</P><P>		if (!this.isDragging) {
			this.isDragging = true;
			this.dragStart(ev);
		}
	},
</P><P>
	// Called when the actual drag has started (went beyond minDistance)
	dragStart: function(ev) {
		var subjectEl = this.subjectEl;
</P><P>		this.trigger('dragStart', ev);
</P><P>		// remove a mousedown'd &lt;a&gt;'s href so it is not visited (IE8 bug)
		if ((this.subjectHref = subjectEl ? subjectEl.attr('href') : null)) {
			subjectEl.removeAttr('href');
		}
	},
</P><P>
	// Called while the mouse is being moved and when we know a legitimate drag is taking place
	drag: function(dx, dy, ev) {
		this.trigger('drag', dx, dy, ev);
		this.updateScroll(ev); // will possibly cause scrolling
	},
</P><P>
	// Called when the user does a mouseup
	mouseup: function(ev) {
		this.stopListening(ev);
	},
</P><P>
	// Called when the drag is over. Will not cause listening to stop however.
	// A concluding 'cellOut' event will NOT be triggered.
	stopDrag: function(ev) {
		if (this.isDragging) {
			this.stopScrolling();
			this.dragStop(ev);
			this.isDragging = false;
		}
	},
</P><P>
	// Called when dragging has been stopped
	dragStop: function(ev) {
		var _this = this;
</P><P>		this.trigger('dragStop', ev);
</P><P>		// restore a mousedown'd &lt;a&gt;'s href (for IE8 bug)
		setTimeout(function() { // must be outside of the click's execution
			if (_this.subjectHref) {
				_this.subjectEl.attr('href', _this.subjectHref);
			}
		}, 0);
	},
</P><P>
	// Call this to stop listening to the user's mouse events
	stopListening: function(ev) {
		this.stopDrag(ev); // if there's a current drag, kill it
</P><P>		if (this.isListening) {
</P><P>			// remove the scroll handler if there is a scrollEl
			if (this.scrollEl) {
				this.scrollEl.off('scroll', this.scrollHandlerProxy);
				this.scrollHandlerProxy = null;
			}
</P><P>			$(document)
				.off('mousemove', this.mousemoveProxy)
				.off('mouseup', this.mouseupProxy)
				.off('selectstart', this.preventDefault);
</P><P>			this.mousemoveProxy = null;
			this.mouseupProxy = null;
</P><P>			this.isListening = false;
			this.listenStop(ev);
		}
	},
</P><P>
	// Called when drag listening has stopped
	listenStop: function(ev) {
		this.trigger('listenStop', ev);
	},
</P><P>
	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	},
</P><P>
	// Stops a given mouse event from doing it's native browser action. In our case, text selection.
	preventDefault: function(ev) {
		ev.preventDefault();
	},
</P><P>
	/* Scrolling
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Computes and stores the bounding rectangle of scrollEl
	computeScrollBounds: function() {
		var el = this.scrollEl;
</P><P>		this.scrollBounds = el ? getOuterRect(el) : null;
			// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
	},
</P><P>
	// Called when the dragging is in progress and scrolling should be updated
	updateScroll: function(ev) {
		var sensitivity = this.scrollSensitivity;
		var bounds = this.scrollBounds;
		var topCloseness, bottomCloseness;
		var leftCloseness, rightCloseness;
		var topVel = 0;
		var leftVel = 0;
</P><P>		if (bounds) { // only scroll if scrollEl exists
</P><P>			// compute closeness to edges. valid range is from 0.0 - 1.0
			topCloseness = (sensitivity - (ev.pageY - bounds.top)) / sensitivity;
			bottomCloseness = (sensitivity - (bounds.bottom - ev.pageY)) / sensitivity;
			leftCloseness = (sensitivity - (ev.pageX - bounds.left)) / sensitivity;
			rightCloseness = (sensitivity - (bounds.right - ev.pageX)) / sensitivity;
</P><P>			// translate vertical closeness into velocity.
			// mouse must be completely in bounds for velocity to happen.
			if (topCloseness &gt;= 0 &amp;&amp; topCloseness &lt;= 1) {
				topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
			}
			else if (bottomCloseness &gt;= 0 &amp;&amp; bottomCloseness &lt;= 1) {
				topVel = bottomCloseness * this.scrollSpeed;
			}
</P><P>			// translate horizontal closeness into velocity
			if (leftCloseness &gt;= 0 &amp;&amp; leftCloseness &lt;= 1) {
				leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
			}
			else if (rightCloseness &gt;= 0 &amp;&amp; rightCloseness &lt;= 1) {
				leftVel = rightCloseness * this.scrollSpeed;
			}
		}
</P><P>		this.setScrollVel(topVel, leftVel);
	},
</P><P>
	// Sets the speed-of-scrolling for the scrollEl
	setScrollVel: function(topVel, leftVel) {
</P><P>		this.scrollTopVel = topVel;
		this.scrollLeftVel = leftVel;
</P><P>		this.constrainScrollVel(); // massages into realistic values
</P><P>		// if there is non-zero velocity, and an animation loop hasn't already started, then START
		if ((this.scrollTopVel || this.scrollLeftVel) &amp;&amp; !this.scrollIntervalId) {
			this.scrollIntervalId = setInterval(
				proxy(this, 'scrollIntervalFunc'), // scope to `this`
				this.scrollIntervalMs
			);
		}
	},
</P><P>
	// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
	constrainScrollVel: function() {
		var el = this.scrollEl;
</P><P>		if (this.scrollTopVel &lt; 0) { // scrolling up?
			if (el.scrollTop() &lt;= 0) { // already scrolled all the way up?
				this.scrollTopVel = 0;
			}
		}
		else if (this.scrollTopVel &gt; 0) { // scrolling down?
			if (el.scrollTop() + el[0].clientHeight &gt;= el[0].scrollHeight) { // already scrolled all the way down?
				this.scrollTopVel = 0;
			}
		}
</P><P>		if (this.scrollLeftVel &lt; 0) { // scrolling left?
			if (el.scrollLeft() &lt;= 0) { // already scrolled all the left?
				this.scrollLeftVel = 0;
			}
		}
		else if (this.scrollLeftVel &gt; 0) { // scrolling right?
			if (el.scrollLeft() + el[0].clientWidth &gt;= el[0].scrollWidth) { // already scrolled all the way right?
				this.scrollLeftVel = 0;
			}
		}
	},
</P><P>
	// This function gets called during every iteration of the scrolling animation loop
	scrollIntervalFunc: function() {
		var el = this.scrollEl;
		var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by
</P><P>		// change the value of scrollEl's scroll
		if (this.scrollTopVel) {
			el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
		}
		if (this.scrollLeftVel) {
			el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
		}
</P><P>		this.constrainScrollVel(); // since the scroll values changed, recompute the velocities
</P><P>		// if scrolled all the way, which causes the vels to be zero, stop the animation loop
		if (!this.scrollTopVel &amp;&amp; !this.scrollLeftVel) {
			this.stopScrolling();
		}
	},
</P><P>
	// Kills any existing scrolling animation loop
	stopScrolling: function() {
		if (this.scrollIntervalId) {
			clearInterval(this.scrollIntervalId);
			this.scrollIntervalId = null;
</P><P>			// when all done with scrolling, recompute positions since they probably changed
			this.scrollStop();
		}
	},
</P><P>
	// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
	scrollHandler: function() {
		// recompute all coordinates, but *only* if this is *not* part of our scrolling animation
		if (!this.scrollIntervalId) {
			this.scrollStop();
		}
	},
</P><P>
	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	scrollStop: function() {
	}
</P><P>});
</P><P>/* Tracks mouse movements over a CoordMap and raises events about which cell the mouse is over.
</P><P>options:
- subjectEl
- subjectCenter
</P><UL><LI>/</LI></UL><P>var CellDragListener = DragListener.extend({
</P><P>	coordMap: null, // converts coordinates to date cells
	origCell: null, // the cell the mouse was over when listening started
	cell: null, // the cell the mouse is over
	coordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions
</P><P>
	constructor: function(coordMap, options) {
		DragListener.prototype.constructor.call(this, options); // call the super-constructor
</P><P>		this.coordMap = coordMap;
	},
</P><P>
	// Called when drag listening starts (but a real drag has not necessarily began).
	// ev might be undefined if dragging was started manually.
	listenStart: function(ev) {
		var subjectEl = this.subjectEl;
		var subjectRect;
		var origPoint;
		var point;
</P><P>		DragListener.prototype.listenStart.apply(this, arguments); // call the super-method
</P><P>		this.computeCoords();
</P><P>		if (ev) {
			origPoint = { left: ev.pageX, top: ev.pageY };
			point = origPoint;
</P><P>			// constrain the point to bounds of the element being dragged
			if (subjectEl) {
				subjectRect = getOuterRect(subjectEl); // used for centering as well
				point = constrainPoint(point, subjectRect);
			}
</P><P>			this.origCell = this.getCell(point.left, point.top);
</P><P>			// treat the center of the subject as the collision point?
			if (subjectEl &amp;&amp; this.options.subjectCenter) {
</P><P>				// only consider the area the subject overlaps the cell. best for large subjects
				if (this.origCell) {
					subjectRect = intersectRects(this.origCell, subjectRect) ||
						subjectRect; // in case there is no intersection
				}
</P><P>				point = getRectCenter(subjectRect);
			}
</P><P>			this.coordAdjust = diffPoints(point, origPoint); // point - origPoint
		}
		else {
			this.origCell = null;
			this.coordAdjust = null;
		}
	},
</P><P>
	// Recomputes the drag-critical positions of elements
	computeCoords: function() {
		this.coordMap.build();
		this.computeScrollBounds();
	},
</P><P>
	// Called when the actual drag has started
	dragStart: function(ev) {
		var cell;
</P><P>		DragListener.prototype.dragStart.apply(this, arguments); // call the super-method
</P><P>		cell = this.getCell(ev.pageX, ev.pageY); // might be different from this.origCell if the min-distance is large
</P><P>		// report the initial cell the mouse is over
		// especially important if no min-distance and drag starts immediately
		if (cell) {
			this.cellOver(cell);
		}
	},
</P><P>
	// Called when the drag moves
	drag: function(dx, dy, ev) {
		var cell;
</P><P>		DragListener.prototype.drag.apply(this, arguments); // call the super-method
</P><P>		cell = this.getCell(ev.pageX, ev.pageY);
</P><P>		if (!isCellsEqual(cell, this.cell)) { // a different cell than before?
			if (this.cell) {
				this.cellOut();
			}
			if (cell) {
				this.cellOver(cell);
			}
		}
	},
</P><P>
	// Called when dragging has been stopped
	dragStop: function() {
		this.cellDone();
		DragListener.prototype.dragStop.apply(this, arguments); // call the super-method
	},
</P><P>
	// Called when a the mouse has just moved over a new cell
	cellOver: function(cell) {
		this.cell = cell;
		this.trigger('cellOver', cell, isCellsEqual(cell, this.origCell), this.origCell);
	},
</P><P>
	// Called when the mouse has just moved out of a cell
	cellOut: function() {
		if (this.cell) {
			this.trigger('cellOut', this.cell);
			this.cellDone();
			this.cell = null;
		}
	},
</P><P>
	// Called after a cellOut. Also called before a dragStop
	cellDone: function() {
		if (this.cell) {
			this.trigger('cellDone', this.cell);
		}
	},
</P><P>
	// Called when drag listening has stopped
	listenStop: function() {
		DragListener.prototype.listenStop.apply(this, arguments); // call the super-method
</P><P>		this.origCell = this.cell = null;
		this.coordMap.clear();
	},
</P><P>
	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	scrollStop: function() {
		DragListener.prototype.scrollStop.apply(this, arguments); // call the super-method
</P><P>	this.computeCoords(); // cells' absolute positions will be in new places. recompute
	},
</P><P>
	// Gets the cell underneath the coordinates for the given mouse event
	getCell: function(left, top) {
</P><P>		if (this.coordAdjust) {
			left += this.coordAdjust.left;
			top += this.coordAdjust.top;
		}
</P><P>		return this.coordMap.getCell(left, top);
	}
</P><P>});
</P><P>
// Returns `true` if the cells are identically equal. `false` otherwise.
// They must have the same row, col, and be from the same grid.
// Two null values will be considered equal, as two &quot;out of the grid&quot; states are the same.
function isCellsEqual(cell1, cell2) {
</P><P>	if (!cell1 &amp;&amp; !cell2) {
		return true;
	}
</P><P>	if (cell1 &amp;&amp; cell2) {
		return cell1.grid === cell2.grid &amp;&amp;
			cell1.row === cell2.row &amp;&amp;
			cell1.col === cell2.col;
	}
</P><P>	return false;
}
</P><P>/* Creates a clone of an element and lets it track the mouse as it moves
</P>*/
<P>var MouseFollower = Class.extend({
</P><P>	options: null,
</P><P>	sourceEl: null, // the element that will be cloned and made to look like it is dragging
	el: null, // the clone of `sourceEl` that will track the mouse
	parentEl: null, // the element that `el` (the clone) will be attached to
</P><P>	// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
	top0: null,
	left0: null,
</P><P>	// the initial position of the mouse
	mouseY0: null,
	mouseX0: null,
</P><P>	// the number of pixels the mouse has moved from its initial position
	topDelta: null,
	leftDelta: null,
</P><P>	mousemoveProxy: null, // document mousemove handler, bound to the MouseFollower's `this`
</P><P>	isFollowing: false,
	isHidden: false,
	isAnimating: false, // doing the revert animation?
</P><P>	constructor: function(sourceEl, options) {
		this.options = options = options || {};
		this.sourceEl = sourceEl;
		this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
	},
</P><P>
	// Causes the element to start following the mouse
	start: function(ev) {
		if (!this.isFollowing) {
			this.isFollowing = true;
</P><P>			this.mouseY0 = ev.pageY;
			this.mouseX0 = ev.pageX;
			this.topDelta = 0;
			this.leftDelta = 0;
</P><P>			if (!this.isHidden) {
				this.updatePosition();
			}
</P><P>			$(document).on('mousemove', this.mousemoveProxy = proxy(this, 'mousemove'));
		}
	},
</P><P>
	// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
	// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
	stop: function(shouldRevert, callback) {
		var _this = this;
		var revertDuration = this.options.revertDuration;
</P><P>		function complete() {
			this.isAnimating = false;
			_this.removeElement();
</P><P>			this.top0 = this.left0 = null; // reset state for future updatePosition calls
</P><P>			if (callback) {
				callback();
			}
		}
</P><P>		if (this.isFollowing &amp;&amp; !this.isAnimating) { // disallow more than one stop animation at a time
			this.isFollowing = false;
</P><P>			$(document).off('mousemove', this.mousemoveProxy);
</P><P>			if (shouldRevert &amp;&amp; revertDuration &amp;&amp; !this.isHidden) { // do a revert animation?
				this.isAnimating = true;
				this.el.animate({
					top: this.top0,
					left: this.left0
				}, {
					duration: revertDuration,
					complete: complete
				});
			}
			else {
				complete();
			}
		}
	},
</P><P>
	// Gets the tracking element. Create it if necessary
	getEl: function() {
		var el = this.el;
</P><P>		if (!el) {
			this.sourceEl.width(); // hack to force IE8 to compute correct bounding box
			el = this.el = this.sourceEl.clone()
				.css({
					position: 'absolute',
					visibility: <I>, // in case original element was hidden (commonly through hideEvents())</I>
					display: this.isHidden ? 'none' : <I>, // for when initially hidden</I>
					margin: 0,
					right: 'auto', // erase and set width instead
					bottom: 'auto', // erase and set height instead
					width: this.sourceEl.width(), // explicit height in case there was a 'right' value
					height: this.sourceEl.height(), // explicit width in case there was a 'bottom' value
					opacity: this.options.opacity || <I>,</I>
					zIndex: this.options.zIndex
				})
				.appendTo(this.parentEl);
		}
</P><P>		return el;
	},
</P><P>
	// Removes the tracking element if it has already been created
	removeElement: function() {
		if (this.el) {
			this.el.remove();
			this.el = null;
		}
	},
</P><P>
	// Update the CSS position of the tracking element
	updatePosition: function() {
		var sourceOffset;
		var origin;
</P><P>		this.getEl(); // ensure this.el
</P><P>		// make sure origin info was computed
		if (this.top0 === null) {
			this.sourceEl.width(); // hack to force IE8 to compute correct bounding box
			sourceOffset = this.sourceEl.offset();
			origin = this.el.offsetParent().offset();
			this.top0 = sourceOffset.top - origin.top;
			this.left0 = sourceOffset.left - origin.left;
		}
</P><P>		this.el.css({
			top: this.top0 + this.topDelta,
			left: this.left0 + this.leftDelta
		});
	},
</P><P>
	// Gets called when the user moves the mouse
	mousemove: function(ev) {
		this.topDelta = ev.pageY - this.mouseY0;
		this.leftDelta = ev.pageX - this.mouseX0;
</P><P>		if (!this.isHidden) {
			this.updatePosition();
		}
	},
</P><P>
	// Temporarily makes the tracking element invisible. Can be called before following starts
	hide: function() {
		if (!this.isHidden) {
			this.isHidden = true;
			if (this.el) {
				this.el.hide();
			}
		}
	},
</P><P>
	// Show the tracking element after it has been temporarily hidden
	show: function() {
		if (this.isHidden) {
			this.isHidden = false;
			this.updatePosition();
			this.getEl().show();
		}
	}
</P><P>});
</P><P>/* A utility class for rendering &lt;tr&gt; rows.
</P>*/
<P>// It leverages methods of the subclass and the View to determine custom rendering behavior for each row &quot;type&quot;
// (such as highlight rows, day rows, helper rows, etc).
</P><P>var RowRenderer = Class.extend({
</P><P>	view: null, // a View object
	isRTL: null, // shortcut to the view's isRTL option
	cellHtml: '&lt;td/&gt;', // plain default HTML used for a cell when no other is available
</P><P>
	constructor: function(view) {
		this.view = view;
		this.isRTL = view.opt('isRTL');
	},
</P><P>
	// Renders the HTML for a row, leveraging custom cell-HTML-renderers based on the `rowType`.
	// Also applies the &quot;intro&quot; and &quot;outro&quot; cells, which are specified by the subclass and views.
	// `row` is an optional row number.
	rowHtml: function(rowType, row) {
		var renderCell = this.getHtmlRenderer('cell', rowType);
		var rowCellHtml = <I>;</I>
		var col;
		var cell;
</P><P>		row = row || 0;
</P><P>		for (col = 0; col &lt; this.colCnt; col++) {
			cell = this.getCell(row, col);
			rowCellHtml += renderCell(cell);
		}
</P><P>		rowCellHtml = this.bookendCells(rowCellHtml, rowType, row); // apply intro and outro
</P><P>		return '&lt;tr&gt;' + rowCellHtml + '&lt;/tr&gt;';
	},
</P><P>
	// Applies the &quot;intro&quot; and &quot;outro&quot; HTML to the given cells.
	// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
	// `cells` can be an HTML string of &lt;td&gt;'s or a jQuery &lt;tr&gt; element
	// `row` is an optional row number.
	bookendCells: function(cells, rowType, row) {
		var intro = this.getHtmlRenderer('intro', rowType)(row || 0);
		var outro = this.getHtmlRenderer('outro', rowType)(row || 0);
		var prependHtml = this.isRTL ? outro : intro;
		var appendHtml = this.isRTL ? intro : outro;
</P><P>		if (typeof cells === 'string') {
			return prependHtml + cells + appendHtml;
		}
		else { // a jQuery &lt;tr&gt; element
			return cells.prepend(prependHtml).append(appendHtml);
		}
	},
</P><P>
	// Returns an HTML-rendering function given a specific `rendererName` (like cell, intro, or outro) and a specific
	// `rowType` (like day, eventSkeleton, helperSkeleton), which is optional.
	// If a renderer for the specific rowType doesn't exist, it will fall back to a generic renderer.
	// We will query the View object first for any custom rendering functions, then the methods of the subclass.
	getHtmlRenderer: function(rendererName, rowType) {
		var view = this.view;
		var generalName; // like &quot;cellHtml&quot;
		var specificName; // like &quot;dayCellHtml&quot;. based on rowType
		var provider; // either the View or the RowRenderer subclass, whichever provided the method
		var renderer;
</P><P>		generalName = rendererName + 'Html';
		if (rowType) {
			specificName = rowType + capitaliseFirstLetter(rendererName) + 'Html';
		}
</P><P>		if (specificName &amp;&amp; (renderer = view[specificName])) {
			provider = view;
		}
		else if (specificName &amp;&amp; (renderer = this[specificName])) {
			provider = this;
		}
		else if ((renderer = view[generalName])) {
			provider = view;
		}
		else if ((renderer = this[generalName])) {
			provider = this;
		}
</P><P>		if (typeof renderer === 'function') {
			return function() {
				return renderer.apply(provider, arguments) || <I>; // use correct `this` and always return a string</I>
			};
		}
</P><P>		// the rendered can be a plain string as well. if not specified, always an empty string.
		return function() {
			return renderer || <I>;</I>
		};
	}
</P><P>});
</P><P>/* An abstract class comprised of a &quot;grid&quot; of cells that each represent a specific datetime
</P>*/
<P>var Grid = fc.Grid = RowRenderer.extend({
</P><P>	start: null, // the date of the first cell
	end: null, // the date after the last cell
</P><P>	rowCnt: 0, // number of rows
	colCnt: 0, // number of cols
</P><P>	el: null, // the containing element
	coordMap: null, // a GridCoordMap that converts pixel values to datetimes
	elsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.
</P><P>	externalDragStartProxy: null, // binds the Grid's scope to externalDragStart (in DayGrid.events)
</P><P>	// derived from options
	colHeadFormat: null, // TODO: move to another class. not applicable to all Grids
	eventTimeFormat: null,
	displayEventTime: null,
	displayEventEnd: null,
</P><P>	// if all cells are the same length of time, the duration they all share. optional.
	// when defined, allows the computeCellRange shortcut, as well as improved resizing behavior.
	cellDuration: null,
</P><P>	// if defined, holds the unit identified (ex: &quot;year&quot; or &quot;month&quot;) that determines the level of granularity
	// of the date cells. if not defined, assumes to be day and time granularity.
	largeUnit: null,
</P><P>
	constructor: function() {
		RowRenderer.apply(this, arguments); // call the super-constructor
</P><P>		this.coordMap = new GridCoordMap(this);
		this.elsByFill = {};
		this.externalDragStartProxy = proxy(this, 'externalDragStart');
	},
</P><P>
	/* Options
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Generates the format string used for the text in column headers, if not explicitly defined by 'columnFormat'
	// TODO: move to another class. not applicable to all Grids
	computeColHeadFormat: function() {
		// subclasses must implement if they want to use headHtml()
	},
</P><P>
	// Generates the format string used for event time text, if not explicitly defined by 'timeFormat'
	computeEventTimeFormat: function() {
		return this.view.opt('smallTimeFormat');
	},
</P><P>
	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.
	// Only applies to non-all-day events.
	computeDisplayEventTime: function() {
		return true;
	},
</P><P>
	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'
	computeDisplayEventEnd: function() {
		return true;
	},
</P><P>
	/* Dates
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Tells the grid about what period of time to display.
	// Any date-related cell system internal data should be generated.
	setRange: function(range) {
		this.start = range.start.clone();
		this.end = range.end.clone();
</P><P>		this.rangeUpdated();
		this.processRangeOptions();
	},
</P><P>
	// Called when internal variables that rely on the range should be updated
	rangeUpdated: function() {
	},
</P><P>
	// Updates values that rely on options and also relate to range
	processRangeOptions: function() {
		var view = this.view;
		var displayEventTime;
		var displayEventEnd;
</P><P>		// Populate option-derived settings. Look for override first, then compute if necessary.
		this.colHeadFormat = view.opt('columnFormat') || this.computeColHeadFormat();
</P><P>		this.eventTimeFormat =
			view.opt('eventTimeFormat') ||
			view.opt('timeFormat') || // deprecated
			this.computeEventTimeFormat();
</P><P>		displayEventTime = view.opt('displayEventTime');
		if (displayEventTime == null) {
			displayEventTime = this.computeDisplayEventTime(); // might be based off of range
		}
</P><P>		displayEventEnd = view.opt('displayEventEnd');
		if (displayEventEnd == null) {
			displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
		}
</P><P>		this.displayEventTime = displayEventTime;
		this.displayEventEnd = displayEventEnd;
	},
</P><P>
	// Called before the grid's coordinates will need to be queried for cells.
	// Any non-date-related cell system internal data should be built.
	build: function() {
	},
</P><P>
	// Called after the grid's coordinates are done being relied upon.
	// Any non-date-related cell system internal data should be cleared.
	clear: function() {
	},
</P><P>
	// Converts a range with an inclusive `start` and an exclusive `end` into an array of segment objects
	rangeToSegs: function(range) {
		// subclasses must implement
	},
</P><P>
	// Diffs the two dates, returning a duration, based on granularity of the grid
	diffDates: function(a, b) {
		if (this.largeUnit) {
			return diffByUnit(a, b, this.largeUnit);
		}
		else {
			return diffDayTime(a, b);
		}
	},
</P><P>
	/* Cells
	------------------------------------------------------------------------------------------------------------------*/
	// NOTE: columns are ordered left-to-right
</P><P>
	// Gets an object containing row/col number, misc data, and range information about the cell.
	// Accepts row/col values, an object with row/col properties, or a single-number offset from the first cell.
	getCell: function(row, col) {
		var cell;
</P><P>		if (col == null) {
			if (typeof row === 'number') { // a single-number offset
				col = row % this.colCnt;
				row = Math.floor(row / this.colCnt);
			}
			else { // an object with row/col properties
				col = row.col;
				row = row.row;
			}
		}
</P><P>		cell = { row: row, col: col };
</P><P>		$.extend(cell, this.getRowData(row), this.getColData(col));
		$.extend(cell, this.computeCellRange(cell));
</P><P>		return cell;
	},
</P><P>
	// Given a cell object with index and misc data, generates a range object
	// If the grid is leveraging cellDuration, this doesn't need to be defined. Only computeCellDate does.
	// If being overridden, should return a range with reference-free date copies.
	computeCellRange: function(cell) {
		var date = this.computeCellDate(cell);
</P><P>		return {
			start: date,
			end: date.clone().add(this.cellDuration)
		};
	},
</P><P>
	// Given a cell, returns its start date. Should return a reference-free date copy.
	computeCellDate: function(cell) {
		// subclasses can implement
	},
</P><P>
	// Retrieves misc data about the given row
	getRowData: function(row) {
		return {};
	},
</P><P>
	// Retrieves misc data baout the given column
	getColData: function(col) {
		return {};
	},
</P><P>
	// Retrieves the element representing the given row
	getRowEl: function(row) {
		// subclasses should implement if leveraging the default getCellDayEl() or computeRowCoords()
	},
</P><P>
	// Retrieves the element representing the given column
	getColEl: function(col) {
		// subclasses should implement if leveraging the default getCellDayEl() or computeColCoords()
	},
</P><P>
	// Given a cell object, returns the element that represents the cell's whole-day
	getCellDayEl: function(cell) {
		return this.getColEl(cell.col) || this.getRowEl(cell.row);
	},
</P><P>
	/* Cell Coordinates
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Computes the top/bottom coordinates of all rows.
	// By default, queries the dimensions of the element provided by getRowEl().
	computeRowCoords: function() {
		var items = [];
		var i, el;
		var top;
</P><P>		for (i = 0; i &lt; this.rowCnt; i++) {
			el = this.getRowEl(i);
			top = el.offset().top;
			items.push({
				top: top,
				bottom: top + el.outerHeight()
			});
		}
</P><P>		return items;
	},
</P><P>
	// Computes the left/right coordinates of all rows.
	// By default, queries the dimensions of the element provided by getColEl(). Columns can be LTR or RTL.
	computeColCoords: function() {
		var items = [];
		var i, el;
		var left;
</P><P>		for (i = 0; i &lt; this.colCnt; i++) {
			el = this.getColEl(i);
			left = el.offset().left;
			items.push({
				left: left,
				right: left + el.outerWidth()
			});
		}
</P><P>		return items;
	},
</P><P>
	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Sets the container element that the grid should render inside of.
	// Does other DOM-related initializations.
	setElement: function(el) {
		var _this = this;
</P><P>		this.el = el;
</P><P>		// attach a handler to the grid's root element.
		// jQuery will take care of unregistering them when removeElement gets called.
		el.on('mousedown', function(ev) {
			if (
				!$(ev.target).is('.fc-event-container *, .fc-more') &amp;&amp; // not an an event element, or &quot;more..&quot; link
				!$(ev.target).closest('.fc-popover').length // not on a popover (like the &quot;more..&quot; events one)
			) {
				_this.dayMousedown(ev);
			}
		});
</P><P>		// attach event-element-related handlers. in Grid.events
		// same garbage collection note as above.
		this.bindSegHandlers();
</P><P>		this.bindGlobalHandlers();
	},
</P><P>
	// Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.
	// DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View
	removeElement: function() {
		this.unbindGlobalHandlers();
</P><P>		this.el.remove();
</P><P>		// NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement
	},
</P><P>
	// Renders the basic structure of grid view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},
</P><P>
	// Renders the grid's date-related content (like cells that represent days/times).
	// Assumes setRange has already been called and the skeleton has already been rendered.
	renderDates: function() {
		// subclasses should implement
	},
</P><P>
	// Unrenders the grid's date-related content
	unrenderDates: function() {
		// subclasses should implement
	},
</P><P>
	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Binds DOM handlers to elements that reside outside the grid, such as the document
	bindGlobalHandlers: function() {
		$(document).on('dragstart sortstart', this.externalDragStartProxy); // jqui
	},
</P><P>
	// Unbinds DOM handlers from elements that reside outside the grid
	unbindGlobalHandlers: function() {
		$(document).off('dragstart sortstart', this.externalDragStartProxy); // jqui
	},
</P><P>
	// Process a mousedown on an element that represents a day. For day clicking and selecting.
	dayMousedown: function(ev) {
		var _this = this;
		var view = this.view;
		var isSelectable = view.opt('selectable');
		var dayClickCell; // null if invalid dayClick
		var selectionRange; // null if invalid selection
</P><P>		// this listener tracks a mousedown on a day element, and a subsequent drag.
		// if the drag ends on the same day, it is a 'dayClick'.
		// if 'selectable' is enabled, this listener also detects selections.
		var dragListener = new CellDragListener(this.coordMap, {
			//distance: 5, // needs more work if we want dayClick to fire correctly
			scroll: view.opt('dragScroll'),
			dragStart: function() {
				view.unselect(); // since we could be rendering a new selection, we want to clear any old one
			},
			cellOver: function(cell, isOrig, origCell) {
				if (origCell) { // click needs to have started on a cell
					dayClickCell = isOrig ? cell : null; // single-cell selection is a day click
					if (isSelectable) {
						selectionRange = _this.computeSelection(origCell, cell);
						if (selectionRange) {
							_this.renderSelection(selectionRange);
						}
						else {
							disableCursor();
						}
					}
				}
			},
			cellOut: function(cell) {
				dayClickCell = null;
				selectionRange = null;
				_this.unrenderSelection();
				enableCursor();
			},
			listenStop: function(ev) {
				if (dayClickCell) {
					view.triggerDayClick(dayClickCell, _this.getCellDayEl(dayClickCell), ev);
				}
				if (selectionRange) {
					// the selection will already have been rendered. just report it
					view.reportSelection(selectionRange, ev);
				}
				enableCursor();
			}
		});
</P><P>		dragListener.mousedown(ev); // start listening, which will eventually initiate a dragStart
	},
</P><P>
	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: should probably move this to Grid.events, like we did event dragging / resizing
</P><P>
	// Renders a mock event over the given range
	renderRangeHelper: function(range, sourceSeg) {
		var fakeEvent = this.fabricateHelperEvent(range, sourceSeg);
</P><P>		this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering
	},
</P><P>
	// Builds a fake event given a date range it should cover, and a segment is should be inspired from.
	// The range's end can be null, in which case the mock event that is rendered will have a null end time.
	// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
	fabricateHelperEvent: function(range, sourceSeg) {
		var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible
</P><P>		fakeEvent.start = range.start.clone();
		fakeEvent.end = range.end ? range.end.clone() : null;
		fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventRange
		this.view.calendar.normalizeEventRange(fakeEvent);
</P><P>		// this extra className will be useful for differentiating real events from mock events in CSS
		fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');
</P><P>		// if something external is being dragged in, don't render a resizer
		if (!sourceSeg) {
			fakeEvent.editable = false;
		}
</P><P>		return fakeEvent;
	},
</P><P>
	// Renders a mock event
	renderHelper: function(event, sourceSeg) {
		// subclasses must implement
	},
</P><P>
	// Unrenders a mock event
	unrenderHelper: function() {
		// subclasses must implement
	},
</P><P>
	/* Selection
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
	renderSelection: function(range) {
		this.renderHighlight(this.selectionRangeToSegs(range));
	},
</P><P>
	// Unrenders any visual indications of a selection. Will unrender a highlight by default.
	unrenderSelection: function() {
		this.unrenderHighlight();
	},
</P><P>
	// Given the first and last cells of a selection, returns a range object.
	// Will return something falsy if the selection is invalid (when outside of selectionConstraint for example).
	// Subclasses can override and provide additional data in the range object. Will be passed to renderSelection().
	computeSelection: function(firstCell, lastCell) {
		var dates = [
			firstCell.start,
			firstCell.end,
			lastCell.start,
			lastCell.end
		];
		var range;
</P><P>		dates.sort(compareNumbers); // sorts chronologically. works with Moments
</P><P>		range = {
			start: dates[0].clone(),
			end: dates[3].clone()
		};
</P><P>		if (!this.view.calendar.isSelectionRangeAllowed(range)) {
			return null;
		}
</P><P>		return range;
	},
</P><P>
	selectionRangeToSegs: function(range) {
		return this.rangeToSegs(range);
	},
</P><P>
	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders an emphasis on the given date range. Given an array of segments.
	renderHighlight: function(segs) {
		this.renderFill('highlight', segs);
	},
</P><P>
	// Unrenders the emphasis on a date range
	unrenderHighlight: function() {
		this.unrenderFill('highlight');
	},
</P><P>
	// Generates an array of classNames for rendering the highlight. Used by the fill system.
	highlightSegClasses: function() {
		return [ 'fc-highlight' ];
	},
</P><P>
	/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a set of rectangles over the given segments of time.
	// MUST RETURN a subset of segs, the segs that were actually rendered.
	// Responsible for populating this.elsByFill. TODO: better API for expressing this requirement
	renderFill: function(type, segs) {
		// subclasses must implement
	},
</P><P>
	// Unrenders a specific type of fill that is currently rendered on the grid
	unrenderFill: function(type) {
		var el = this.elsByFill[type];
</P><P>		if (el) {
			el.remove();
			delete this.elsByFill[type];
		}
	},
</P><P>
	// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
	// Only returns segments that successfully rendered.
	// To be harnessed by renderFill (implemented by subclasses).
	// Analagous to renderFgSegEls.
	renderFillSegEls: function(type, segs) {
		var _this = this;
		var segElMethod = this[type + 'SegEl'];
		var html = <I>;</I>
		var renderedSegs = [];
		var i;
</P><P>		if (segs.length) {
</P><P>			// build a large concatenation of segment HTML
			for (i = 0; i &lt; segs.length; i++) {
				html += this.fillSegHtml(type, segs[i]);
			}
</P><P>			// Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment.
			$(html).each(function(i, node) {
				var seg = segs[i];
				var el = $(node);
</P><P>				// allow custom filter methods per-type
				if (segElMethod) {
					el = segElMethod.call(_this, seg, el);
				}
</P><P>				if (el) { // custom filters did not cancel the render
					el = $(el); // allow custom filter to return raw DOM node
</P><P>					// correct element type? (would be bad if a non-TD were inserted into a table for example)
					if (el.is(_this.fillSegTag)) {
						seg.el = el;
						renderedSegs.push(seg);
					}
				}
			});
		}
</P><P>		return renderedSegs;
	},
</P><P>
	fillSegTag: 'div', // subclasses can override
</P><P>
	// Builds the HTML needed for one fill segment. Generic enought o work with different types.
	fillSegHtml: function(type, seg) {
</P><P>		// custom hooks per-type
		var classesMethod = this[type + 'SegClasses'];
		var cssMethod = this[type + 'SegCss'];
</P><P>		var classes = classesMethod ? classesMethod.call(this, seg) : [];
		var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});
</P><P>		return '&lt;' + this.fillSegTag +
			(classes.length ? ' class=&quot;' + classes.join(' ') + '&quot;' : <I>) +</I>
			(css ? ' style=&quot;' + css + '&quot;' : <I>) +</I>
			' /&gt;';
	},
</P><P>
	/* Generic rendering utilities for subclasses
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a day-of-week header row.
	// TODO: move to another class. not applicable to all Grids
	headHtml: function() {
		return <I> +</I></P>
			'<DIV class="fc-row ' + this.view.widgetHeaderClass + '">' +
				'<TABLE>' +
					'&lt;thead&gt;' +
						this.rowHtml('head') + // leverages RowRenderer
					'&lt;/thead&gt;' +
				'</TABLE>' +
			'</DIV>';
<P>	},
</P><P>
	// Used by the `headHtml` method, via RowRenderer, for rendering the HTML of a day-of-week header cell
	// TODO: move to another class. not applicable to all Grids
	headCellHtml: function(cell) {
		var view = this.view;
		var date = cell.start;
</P><P>		return <I> +</I>
			'&lt;th class=&quot;fc-day-header ' + view.widgetHeaderClass + ' fc-' + dayIDs[date.day()] + '&quot;&gt;' +
				htmlEscape(date.format(this.colHeadFormat)) +
			'&lt;/th&gt;';
	},
</P><P>
	// Renders the HTML for a single-day background cell
	bgCellHtml: function(cell) {
		var view = this.view;
		var date = cell.start;
		var classes = this.getDayClasses(date);
</P><P>		classes.unshift('fc-day', view.widgetContentClass);
</P><P>		return '&lt;td class=&quot;' + classes.join(' ') + '&quot;' +
			' data-date=&quot;' + date.format('YYYY-MM-DD') + '&quot;' + // if date has a time, won't format it
			'&gt;&lt;/td&gt;';
	},
</P><P>
	// Computes HTML classNames for a single-day cell
	getDayClasses: function(date) {
		var view = this.view;
		var today = view.calendar.getNow().stripTime();
		var classes = [ 'fc-' + dayIDs[date.day()] ];
</P><P>		if (
			view.intervalDuration.as('months') == 1 &amp;&amp;
			date.month() != view.intervalStart.month()
		) {
			classes.push('fc-other-month');
		}
</P><P>		if (date.isSame(today, 'day')) {
			classes.push(
				'fc-today',
				view.highlightStateClass
			);
		}
		else if (date &lt; today) {
			classes.push('fc-past');
		}
		else {
			classes.push('fc-future');
		}
</P><P>		return classes;
	}
</P><P>});
</P><P>/* Event-rendering and event-interaction methods for the abstract Grid class
</P>*/
<P>Grid.mixin({
</P><P>	mousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing
	isDraggingSeg: false, // is a segment being dragged? boolean
	isResizingSeg: false, // is a segment being resized? boolean
	isDraggingExternal: false, // jqui-dragging an external element? boolean
	segs: null, // the event segments currently rendered in the grid
</P><P>
	// Renders the given events onto the grid
	renderEvents: function(events) {
		var segs = this.eventsToSegs(events);
		var bgSegs = [];
		var fgSegs = [];
		var i, seg;
</P><P>		for (i = 0; i &lt; segs.length; i++) {
			seg = segs[i];
</P><P>			if (isBgEvent(seg.event)) {
				bgSegs.push(seg);
			}
			else {
				fgSegs.push(seg);
			}
		}
</P><P>		// Render each different type of segment.
		// Each function may return a subset of the segs, segs that were actually rendered.
		bgSegs = this.renderBgSegs(bgSegs) || bgSegs;
		fgSegs = this.renderFgSegs(fgSegs) || fgSegs;
</P><P>		this.segs = bgSegs.concat(fgSegs);
	},
</P><P>
	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.triggerSegMouseout(); // trigger an eventMouseout if user's mouse is over an event
</P><P>		this.unrenderFgSegs();
		this.unrenderBgSegs();
</P><P>		this.segs = null;
	},
</P><P>
	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return this.segs || [];
	},
</P><P>
	/* Foreground Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
	renderFgSegs: function(segs) {
		// subclasses must implement
	},
</P><P>
	// Unrenders all currently rendered foreground segments
	unrenderFgSegs: function() {
		// subclasses must implement
	},
</P><P>
	// Renders and assigns an `el` property for each foreground event segment.
	// Only returns segments that successfully rendered.
	// A utility that subclasses may use.
	renderFgSegEls: function(segs, disableResizing) {
		var view = this.view;
		var html = <I>;</I>
		var renderedSegs = [];
		var i;
</P><P>		if (segs.length) { // don't build an empty html string
</P><P>			// build a large concatenation of event segment HTML
			for (i = 0; i &lt; segs.length; i++) {
				html += this.fgSegHtml(segs[i], disableResizing);
			}
</P><P>			// Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
			$(html).each(function(i, node) {
				var seg = segs[i];
				var el = view.resolveEventEl(seg.event, $(node));
</P><P>				if (el) {
					el.data('fc-seg', seg); // used by handlers
					seg.el = el;
					renderedSegs.push(seg);
				}
			});
		}
</P><P>		return renderedSegs;
	},
</P><P>
	// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
	fgSegHtml: function(seg, disableResizing) {
		// subclasses should implement
	},
</P><P>
	/* Background Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders the given background event segments onto the grid.
	// Returns a subset of the segs that were actually rendered.
	renderBgSegs: function(segs) {
		return this.renderFill('bgEvent', segs);
	},
</P><P>
	// Unrenders all the currently rendered background event segments
	unrenderBgSegs: function() {
		this.unrenderFill('bgEvent');
	},
</P><P>
	// Renders a background event element, given the default rendering. Called by the fill system.
	bgEventSegEl: function(seg, el) {
		return this.view.resolveEventEl(seg.event, el); // will filter through eventRender
	},
</P><P>
	// Generates an array of classNames to be used for the default rendering of a background event.
	// Called by the fill system.
	bgEventSegClasses: function(seg) {
		var event = seg.event;
		var source = event.source || {};
</P><P>		return [ 'fc-bgevent' ].concat(
			event.className,
			source.className || []
		);
	},
</P><P>
	// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
	// Called by the fill system.
	// TODO: consolidate with getEventSkinCss?
	bgEventSegCss: function(seg) {
		var view = this.view;
		var event = seg.event;
		var source = event.source || {};
</P><P>		return {
			'background-color':
				event.backgroundColor ||
				event.color ||
				source.backgroundColor ||
				source.color ||
				view.opt('eventBackgroundColor') ||
				view.opt('eventColor')
		};
	},
</P><P>
	// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
	businessHoursSegClasses: function(seg) {
		return [ 'fc-nonbusiness', 'fc-bgevent' ];
	},
</P><P>
	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Attaches event-element-related handlers to the container element and leverage bubbling
	bindSegHandlers: function() {
		var _this = this;
		var view = this.view;
</P><P>		$.each(
			{
				mouseenter: function(seg, ev) {
					_this.triggerSegMouseover(seg, ev);
				},
				mouseleave: function(seg, ev) {
					_this.triggerSegMouseout(seg, ev);
				},
				click: function(seg, ev) {
					return view.trigger('eventClick', this, seg.event, ev); // can return `false` to cancel
				},
				mousedown: function(seg, ev) {
					if ($(ev.target).is('.fc-resizer') &amp;&amp; view.isEventResizable(seg.event)) {
						_this.segResizeMousedown(seg, ev, $(ev.target).is('.fc-start-resizer'));
					}
					else if (view.isEventDraggable(seg.event)) {
						_this.segDragMousedown(seg, ev);
					}
				}
			},
			function(name, func) {
				// attach the handler to the container element and only listen for real event elements via bubbling
				_this.el.on(name, '.fc-event-container &gt; *', function(ev) {
					var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents
</P><P>					// only call the handlers if there is not a drag/resize in progress
					if (seg &amp;&amp; !_this.isDraggingSeg &amp;&amp; !_this.isResizingSeg) {
						return func.call(this, seg, ev); // `this` will be the event element
					}
				});
			}
		);
	},
</P><P>
	// Updates internal state and triggers handlers for when an event element is moused over
	triggerSegMouseover: function(seg, ev) {
		if (!this.mousedOverSeg) {
			this.mousedOverSeg = seg;
			this.view.trigger('eventMouseover', seg.el[0], seg.event, ev);
		}
	},
</P><P>
	// Updates internal state and triggers handlers for when an event element is moused out.
	// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
	triggerSegMouseout: function(seg, ev) {
		ev = ev || {}; // if given no args, make a mock mouse event
</P><P>		if (this.mousedOverSeg) {
			seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment
			this.mousedOverSeg = null;
			this.view.trigger('eventMouseout', seg.el[0], seg.event, ev);
		}
	},
</P><P>
	/* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Called when the user does a mousedown on an event, which might lead to dragging.
	// Generic enough to work with any type of Grid.
	segDragMousedown: function(seg, ev) {
		var _this = this;
		var view = this.view;
		var calendar = view.calendar;
		var el = seg.el;
		var event = seg.event;
		var dropLocation;
</P><P>		// A clone of the original element that will move with the mouse
		var mouseFollower = new MouseFollower(seg.el, {
			parentEl: view.el,
			opacity: view.opt('dragOpacity'),
			revertDuration: view.opt('dragRevertDuration'),
			zIndex: 2 // one above the .fc-view
		});
</P><P>		// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
		// of the view.
		var dragListener = new CellDragListener(view.coordMap, {
			distance: 5,
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			subjectCenter: true,
			listenStart: function(ev) {
				mouseFollower.hide(); // don't show until we know this is a real drag
				mouseFollower.start(ev);
			},
			dragStart: function(ev) {
				_this.triggerSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segDragStart(seg, ev);
				view.hideEvent(event); // hide all event segments. our mouseFollower will take over
			},
			cellOver: function(cell, isOrig, origCell) {
</P><P>				// starting cell could be forced (DayGrid.limit)
				if (seg.cell) {
					origCell = seg.cell;
				}
</P><P>				dropLocation = _this.computeEventDrop(origCell, cell, event);
</P><P>				if (dropLocation &amp;&amp; !calendar.isEventRangeAllowed(dropLocation, event)) {
					disableCursor();
					dropLocation = null;
				}
</P><P>				// if a valid drop location, have the subclass render a visual indication
				if (dropLocation &amp;&amp; view.renderDrag(dropLocation, seg)) {
					mouseFollower.hide(); // if the subclass is already using a mock event &quot;helper&quot;, hide our own
				}
				else {
					mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
				}
</P><P>				if (isOrig) {
					dropLocation = null; // needs to have moved cells to be a valid drop
				}
			},
			cellOut: function() { // called before mouse moves to a different cell OR moved out of all cells
				view.unrenderDrag(); // unrender whatever was done in renderDrag
				mouseFollower.show(); // show in case we are moving out of all cells
				dropLocation = null;
			},
			cellDone: function() { // Called after a cellOut OR before a dragStop
				enableCursor();
			},
			dragStop: function(ev) {
				// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
				mouseFollower.stop(!dropLocation, function() {
					view.unrenderDrag();
					view.showEvent(event);
					_this.segDragStop(seg, ev);
</P><P>					if (dropLocation) {
						view.reportEventDrop(event, dropLocation, this.largeUnit, el, ev);
					}
				});
			},
			listenStop: function() {
				mouseFollower.stop(); // put in listenStop in case there was a mousedown but the drag never started
			}
		});
</P><P>		dragListener.mousedown(ev); // start listening, which will eventually lead to a dragStart
	},
</P><P>
	// Called before event segment dragging starts
	segDragStart: function(seg, ev) {
		this.isDraggingSeg = true;
		this.view.trigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},
</P><P>
	// Called after event segment dragging stops
	segDragStop: function(seg, ev) {
		this.isDraggingSeg = false;
		this.view.trigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},
</P><P>
	// Given the cell an event drag began, and the cell event was dropped, calculates the new start/end/allDay
	// values for the event. Subclasses may override and set additional properties to be used by renderDrag.
	// A falsy returned value indicates an invalid drop.
	computeEventDrop: function(startCell, endCell, event) {
		var calendar = this.view.calendar;
		var dragStart = startCell.start;
		var dragEnd = endCell.start;
		var delta;
		var dropLocation;
</P><P>		if (dragStart.hasTime() === dragEnd.hasTime()) {
			delta = this.diffDates(dragEnd, dragStart);
</P><P>			// if an all-day event was in a timed area and it was dragged to a different time,
			// guarantee an end and adjust start/end to have times
			if (event.allDay &amp;&amp; durationHasTime(delta)) {
				dropLocation = {
					start: event.start.clone(),
					end: calendar.getEventEnd(event), // will be an ambig day
					allDay: false // for normalizeEventRangeTimes
				};
				calendar.normalizeEventRangeTimes(dropLocation);
			}
			// othewise, work off existing values
			else {
				dropLocation = {
					start: event.start.clone(),
					end: event.end ? event.end.clone() : null,
					allDay: event.allDay // keep it the same
				};
			}
</P><P>			dropLocation.start.add(delta);
			if (dropLocation.end) {
				dropLocation.end.add(delta);
			}
		}
		else {
			// if switching from day &lt;-&gt; timed, start should be reset to the dropped date, and the end cleared
			dropLocation = {
				start: dragEnd.clone(),
				end: null, // end should be cleared
				allDay: !dragEnd.hasTime()
			};
		}
</P><P>		return dropLocation;
	},
</P><P>
	// Utility for apply dragOpacity to a jQuery set
	applyDragOpacity: function(els) {
		var opacity = this.view.opt('dragOpacity');
</P><P>		if (opacity != null) {
			els.each(function(i, node) {
				// Don't use jQuery (will set an IE filter), do it the old fashioned way.
				// In IE8, a helper element will disappears if there's a filter.
				node.style.opacity = opacity;
			});
		}
	},
</P><P>
	/* External Element Dragging
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Called when a jQuery UI drag is initiated anywhere in the DOM
	externalDragStart: function(ev, ui) {
		var view = this.view;
		var el;
		var accept;
</P><P>		if (view.opt('droppable')) { // only listen if this setting is on
			el = $((ui ? ui.item : null) || ev.target);
</P><P>			// Test that the dragged element passes the dropAccept selector or filter function.
			// FYI, the default is &quot;*&quot; (matches all)
			accept = view.opt('dropAccept');
			if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
				if (!this.isDraggingExternal) { // prevent double-listening if fired twice
					this.listenToExternalDrag(el, ev, ui);
				}
			}
		}
	},
</P><P>
	// Called when a jQuery UI drag starts and it needs to be monitored for cell dropping
	listenToExternalDrag: function(el, ev, ui) {
		var _this = this;
		var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
		var dragListener;
		var dropLocation; // a null value signals an unsuccessful drag
</P><P>		// listener that tracks mouse movement over date-associated pixel regions
		dragListener = new CellDragListener(this.coordMap, {
			listenStart: function() {
				_this.isDraggingExternal = true;
			},
			cellOver: function(cell) {
				dropLocation = _this.computeExternalDrop(cell, meta);
				if (dropLocation) {
					_this.renderDrag(dropLocation); // called without a seg parameter
				}
				else { // invalid drop cell
					disableCursor();
				}
			},
			cellOut: function() {
				dropLocation = null; // signal unsuccessful
				_this.unrenderDrag();
				enableCursor();
			},
			dragStop: function() {
				_this.unrenderDrag();
				enableCursor();
</P><P>				if (dropLocation) { // element was dropped on a valid date/time cell
					_this.view.reportExternalDrop(meta, dropLocation, el, ev, ui);
				}
			},
			listenStop: function() {
				_this.isDraggingExternal = false;
			}
		});
</P><P>		dragListener.startDrag(ev); // start listening immediately
	},
</P><P>
	// Given a cell to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
	// returns start/end dates for the event that would result from the hypothetical drop. end might be null.
	// Returning a null value signals an invalid drop cell.
	computeExternalDrop: function(cell, meta) {
		var dropLocation = {
			start: cell.start.clone(),
			end: null
		};
</P><P>		// if dropped on an all-day cell, and element's metadata specified a time, set it
		if (meta.startTime &amp;&amp; !dropLocation.start.hasTime()) {
			dropLocation.start.time(meta.startTime);
		}
</P><P>		if (meta.duration) {
			dropLocation.end = dropLocation.start.clone().add(meta.duration);
		}
</P><P>		if (!this.view.calendar.isExternalDropRangeAllowed(dropLocation, meta.eventProps)) {
			return null;
		}
</P><P>		return dropLocation;
	},
</P><P>	/* Drag Rendering (for both events and an external elements)
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a visual indication of an event or external element being dragged.
	// `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.
	// `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.
	// A truthy returned value indicates this method has rendered a helper element.
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},
</P><P>
	// Unrenders a visual indication of an event or external element being dragged
	unrenderDrag: function() {
		// subclasses must implement
	},
</P><P>
	/* Resizing
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Called when the user does a mousedown on an event's resizer, which might lead to resizing.
	// Generic enough to work with any type of Grid.
	segResizeMousedown: function(seg, ev, isStart) {
		var _this = this;
		var view = this.view;
		var calendar = view.calendar;
		var el = seg.el;
		var event = seg.event;
		var eventEnd = calendar.getEventEnd(event);
		var dragListener;
		var resizeLocation; // falsy if invalid resize
</P><P>		// Tracks mouse movement over the *grid's* coordinate map
		dragListener = new CellDragListener(this.coordMap, {
			distance: 5,
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			dragStart: function(ev) {
				_this.triggerSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segResizeStart(seg, ev);
			},
			cellOver: function(cell, isOrig, origCell) {
				resizeLocation = isStart ?
					_this.computeEventStartResize(origCell, cell, event) :
					_this.computeEventEndResize(origCell, cell, event);
</P><P>				if (resizeLocation) {
					if (!calendar.isEventRangeAllowed(resizeLocation, event)) {
						disableCursor();
						resizeLocation = null;
					}
					// no change? (TODO: how does this work with timezones?)
					else if (resizeLocation.start.isSame(event.start) &amp;&amp; resizeLocation.end.isSame(eventEnd)) {
						resizeLocation = null;
					}
				}
</P><P>				if (resizeLocation) {
					view.hideEvent(event);
					_this.renderEventResize(resizeLocation, seg);
				}
			},
			cellOut: function() { // called before mouse moves to a different cell OR moved out of all cells
				resizeLocation = null;
			},
			cellDone: function() { // resets the rendering to show the original event
				_this.unrenderEventResize();
				view.showEvent(event);
				enableCursor();
			},
			dragStop: function(ev) {
				_this.segResizeStop(seg, ev);
</P><P>				if (resizeLocation) { // valid date to resize to?
					view.reportEventResize(event, resizeLocation, this.largeUnit, el, ev);
				}
			}
		});
</P><P>		dragListener.mousedown(ev); // start listening, which will eventually lead to a dragStart
	},
</P><P>
	// Called before event segment resizing starts
	segResizeStart: function(seg, ev) {
		this.isResizingSeg = true;
		this.view.trigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},
</P><P>
	// Called after event segment resizing stops
	segResizeStop: function(seg, ev) {
		this.isResizingSeg = false;
		this.view.trigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},
</P><P>
	// Returns new date-information for an event segment being resized from its start
	computeEventStartResize: function(startCell, endCell, event) {
		return this.computeEventResize('start', startCell, endCell, event);
	},
</P><P>
	// Returns new date-information for an event segment being resized from its end
	computeEventEndResize: function(startCell, endCell, event) {
		return this.computeEventResize('end', startCell, endCell, event);
	},
</P><P>
	// Returns new date-information for an event segment being resized from its start OR end
	// `type` is either 'start' or 'end'
	computeEventResize: function(type, startCell, endCell, event) {
		var calendar = this.view.calendar;
		var delta = this.diffDates(endCell[type], startCell[type]);
		var range;
		var defaultDuration;
</P><P>		// build original values to work from, guaranteeing a start and end
		range = {
			start: event.start.clone(),
			end: calendar.getEventEnd(event),
			allDay: event.allDay
		};
</P><P>		// if an all-day event was in a timed area and was resized to a time, adjust start/end to have times
		if (range.allDay &amp;&amp; durationHasTime(delta)) {
			range.allDay = false;
			calendar.normalizeEventRangeTimes(range);
		}
</P><P>		range[type].add(delta); // apply delta to start or end
</P><P>		// if the event was compressed too small, find a new reasonable duration for it
		if (!range.start.isBefore(range.end)) {
</P><P>			defaultDuration = event.allDay ?
				calendar.defaultAllDayEventDuration :
				calendar.defaultTimedEventDuration;
</P><P>			// between the cell's duration and the event's default duration, use the smaller of the two.
			// example: if year-length slots, and compressed to one slot, we don't want the event to be a year long
			if (this.cellDuration &amp;&amp; this.cellDuration &lt; defaultDuration) {
				defaultDuration = this.cellDuration;
			}
</P><P>			if (type == 'start') { // resizing the start?
				range.start = range.end.clone().subtract(defaultDuration);
			}
			else { // resizing the end?
				range.end = range.start.clone().add(defaultDuration);
			}
		}
</P><P>		return range;
	},
</P><P>
	// Renders a visual indication of an event being resized.
	// `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.
	renderEventResize: function(range, seg) {
		// subclasses must implement
	},
</P><P>
	// Unrenders a visual indication of an event being resized.
	unrenderEventResize: function() {
		// subclasses must implement
	},
</P><P>
	/* Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Compute the text that should be displayed on an event's element.
	// `range` can be the Event object itself, or something range-like, with at least a `start`.
	// If event times are disabled, or the event has no time, will return a blank string.
	// If not specified, formatStr will default to the eventTimeFormat setting,
	// and displayEnd will default to the displayEventEnd setting.
	getEventTimeText: function(range, formatStr, displayEnd) {
</P><P>		if (formatStr == null) {
			formatStr = this.eventTimeFormat;
		}
</P><P>		if (displayEnd == null) {
			displayEnd = this.displayEventEnd;
		}
</P><P>		if (this.displayEventTime &amp;&amp; range.start.hasTime()) {
			if (displayEnd &amp;&amp; range.end) {
				return this.view.formatRange(range, formatStr);
			}
			else {
				return range.start.format(formatStr);
			}
		}
</P><P>		return <I>;</I>
	},
</P><P>
	// Generic utility for generating the HTML classNames for an event segment's element
	getSegClasses: function(seg, isDraggable, isResizable) {
		var event = seg.event;
		var classes = [
			'fc-event',
			seg.isStart ? 'fc-start' : 'fc-not-start',
			seg.isEnd ? 'fc-end' : 'fc-not-end'
		].concat(
			event.className,
			event.source ? event.source.className : []
		);
</P><P>		if (isDraggable) {
			classes.push('fc-draggable');
		}
		if (isResizable) {
			classes.push('fc-resizable');
		}
</P><P>		return classes;
	},
</P><P>
	// Utility for generating event skin-related CSS properties
	getEventSkinCss: function(event) {
		var view = this.view;
		var source = event.source || {};
		var eventColor = event.color;
		var sourceColor = source.color;
		var optionColor = view.opt('eventColor');
</P><P>		return {
			'background-color':
				event.backgroundColor ||
				eventColor ||
				source.backgroundColor ||
				sourceColor ||
				view.opt('eventBackgroundColor') ||
				optionColor,
			'border-color':
				event.borderColor ||
				eventColor ||
				source.borderColor ||
				sourceColor ||
				view.opt('eventBorderColor') ||
				optionColor,
			color:
				event.textColor ||
				source.textColor ||
				view.opt('eventTextColor')
		};
	},
</P><P>
	/* Converting events -&gt; ranges -&gt; segs
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Converts an array of event objects into an array of event segment objects.
	// A custom `rangeToSegsFunc` may be given for arbitrarily slicing up events.
	// Doesn't guarantee an order for the resulting array.
	eventsToSegs: function(events, rangeToSegsFunc) {
		var eventRanges = this.eventsToRanges(events);
		var segs = [];
		var i;
</P><P>		for (i = 0; i &lt; eventRanges.length; i++) {
			segs.push.apply(
				segs,
				this.eventRangeToSegs(eventRanges[i], rangeToSegsFunc)
			);
		}
</P><P>		return segs;
	},
</P><P>
	// Converts an array of events into an array of &quot;range&quot; objects.
	// A &quot;range&quot; object is a plain object with start/end properties denoting the time it covers. Also an event property.
	// For &quot;normal&quot; events, this will be identical to the event's start/end, but for &quot;inverse-background&quot; events,
	// will create an array of ranges that span the time *not* covered by the given event.
	// Doesn't guarantee an order for the resulting array.
	eventsToRanges: function(events) {
		var _this = this;
		var eventsById = groupEventsById(events);
		var ranges = [];
</P><P>		// group by ID so that related inverse-background events can be rendered together
		$.each(eventsById, function(id, eventGroup) {
			if (eventGroup.length) {
				ranges.push.apply(
					ranges,
					isInverseBgEvent(eventGroup[0]) ?
						_this.eventsToInverseRanges(eventGroup) :
						_this.eventsToNormalRanges(eventGroup)
				);
			}
		});
</P><P>		return ranges;
	},
</P><P>
	// Converts an array of &quot;normal&quot; events (not inverted rendering) into a parallel array of ranges
	eventsToNormalRanges: function(events) {
		var calendar = this.view.calendar;
		var ranges = [];
		var i, event;
		var eventStart, eventEnd;
</P><P>		for (i = 0; i &lt; events.length; i++) {
			event = events[i];
</P><P>			// make copies and normalize by stripping timezone
			eventStart = event.start.clone().stripZone();
			eventEnd = calendar.getEventEnd(event).stripZone();
</P><P>			ranges.push({
				event: event,
				start: eventStart,
				end: eventEnd,
				eventStartMS: +eventStart,
				eventDurationMS: eventEnd - eventStart
			});
		}
</P><P>		return ranges;
	},
</P><P>
	// Converts an array of events, with inverse-background rendering, into an array of range objects.
	// The range objects will cover all the time NOT covered by the events.
	eventsToInverseRanges: function(events) {
		var view = this.view;
		var viewStart = view.start.clone().stripZone(); // normalize timezone
		var viewEnd = view.end.clone().stripZone(); // normalize timezone
		var normalRanges = this.eventsToNormalRanges(events); // will give us normalized dates we can use w/o copies
		var inverseRanges = [];
		var event0 = events[0]; // assign this to each range's `.event`
		var start = viewStart; // the end of the previous range. the start of the new range
		var i, normalRange;
</P><P>		// ranges need to be in order. required for our date-walking algorithm
		normalRanges.sort(compareNormalRanges);
</P><P>		for (i = 0; i &lt; normalRanges.length; i++) {
			normalRange = normalRanges[i];
</P><P>			// add the span of time before the event (if there is any)
			if (normalRange.start &gt; start) { // compare millisecond time (skip any ambig logic)
				inverseRanges.push({
					event: event0,
					start: start,
					end: normalRange.start
				});
			}
</P><P>			start = normalRange.end;
		}
</P><P>		// add the span of time after the last event (if there is any)
		if (start &lt; viewEnd) { // compare millisecond time (skip any ambig logic)
			inverseRanges.push({
				event: event0,
				start: start,
				end: viewEnd
			});
		}
</P><P>		return inverseRanges;
	},
</P><P>
	// Slices the given event range into one or more segment objects.
	// A `rangeToSegsFunc` custom slicing function can be given.
	eventRangeToSegs: function(eventRange, rangeToSegsFunc) {
		var segs;
		var i, seg;
</P><P>		eventRange = this.view.calendar.ensureVisibleEventRange(eventRange);
</P><P>		if (rangeToSegsFunc) {
			segs = rangeToSegsFunc(eventRange);
		}
		else {
			segs = this.rangeToSegs(eventRange); // defined by the subclass
		}
</P><P>		for (i = 0; i &lt; segs.length; i++) {
			seg = segs[i];
			seg.event = eventRange.event;
			seg.eventStartMS = eventRange.eventStartMS;
			seg.eventDurationMS = eventRange.eventDurationMS;
		}
</P><P>		return segs;
	}
</P><P>});
</P><P>
/* Utilities
</P>*/
<P>
function isBgEvent(event) { // returns true if background OR inverse-background
	var rendering = getEventRendering(event);
	return rendering === 'background' || rendering === 'inverse-background';
}
</P><P>
function isInverseBgEvent(event) {
	return getEventRendering(event) === 'inverse-background';
}
</P><P>
function getEventRendering(event) {
	return firstDefined((event.source || {}).rendering, event.rendering);
}
</P><P>
function groupEventsById(events) {
	var eventsById = {};
	var i, event;
</P><P>	for (i = 0; i &lt; events.length; i++) {
		event = events[i];
		(eventsById[event._id] || (eventsById[event._id] = [])).push(event);
	}
</P><P>	return eventsById;
}
</P><P>
// A cmp function for determining which non-inverted &quot;ranges&quot; (see above) happen earlier
function compareNormalRanges(range1, range2) {
	return range1.eventStartMS - range2.eventStartMS; // earlier ranges go first
}
</P><P>
// A cmp function for determining which segments should take visual priority
// DOES NOT WORK ON INVERTED BACKGROUND EVENTS because they have no eventStartMS/eventDurationMS
function compareSegs(seg1, seg2) {
	return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first
		seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first
		seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)
		(seg1.event.title || <I>).localeCompare(seg2.event.title); // tie? alphabetically by title</I>
}
</P><P>fc.compareSegs = compareSegs; // export
</P><P>
/* External-Dragging-Element Data
</P>*/
<P>// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of <I> will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.</I>
fc.dataAttrPrefix = <I>;</I></P><P>// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el) {
	var prefix = fc.dataAttrPrefix;
	var eventProps; // properties for creating the event, not related to date/time
	var startTime; // a Duration
	var duration;
	var stick;
</P><P>	if (prefix) { prefix += '-'; }
	eventProps = el.data(prefix + 'event') || null;
</P><P>	if (eventProps) {
		if (typeof eventProps === 'object') {
			eventProps = $.extend({}, eventProps); // make a copy
		}
		else { // something like 1 or true. still signal event creation
			eventProps = {};
		}
</P><P>		// pluck special-cased date/time properties
		startTime = eventProps.start;
		if (startTime == null) { startTime = eventProps.time; } // accept 'time' as well
		duration = eventProps.duration;
		stick = eventProps.stick;
		delete eventProps.start;
		delete eventProps.time;
		delete eventProps.duration;
		delete eventProps.stick;
	}
</P><P>	// fallback to standalone attribute values for each of the date/time properties
	if (startTime == null) { startTime = el.data(prefix + 'start'); }
	if (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well
	if (duration == null) { duration = el.data(prefix + 'duration'); }
	if (stick == null) { stick = el.data(prefix + 'stick'); }
</P><P>	// massage into correct data types
	startTime = startTime != null ? moment.duration(startTime) : null;
	duration = duration != null ? moment.duration(duration) : null;
	stick = Boolean(stick);
</P><P>	return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
}
</P><P>/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
</P>*/
<P>var DayGrid = Grid.extend({
</P><P>	numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal
	bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid
	breakOnWeeks: null, // should create a new row for each week? set by outside view
</P><P>	cellDates: null, // flat chronological array of each cell's dates
	dayToCellOffsets: null, // maps days offsets from grid's start date, to cell offsets
</P><P>	rowEls: null, // set of fake row elements
	dayEls: null, // set of whole-day elements comprising the row's background
	helperEls: null, // set of cell skeleton elements for rendering the mock event &quot;helper&quot;
</P><P>
	constructor: function() {
		Grid.apply(this, arguments);
</P><P>		this.cellDuration = moment.duration(1, 'day'); // for Grid system
	},
</P><P>
	// Renders the rows and columns into the component's `this.el`, which should already be assigned.
	// isRigid determins whether the individual rows should ignore the contents and be a constant height.
	// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
	renderDates: function(isRigid) {
		var view = this.view;
		var rowCnt = this.rowCnt;
		var colCnt = this.colCnt;
		var cellCnt = rowCnt * colCnt;
		var html = <I>;</I>
		var row;
		var i, cell;
</P><P>		for (row = 0; row &lt; rowCnt; row++) {
			html += this.dayRowHtml(row, isRigid);
		}
		this.el.html(html);
</P><P>		this.rowEls = this.el.find('.fc-row');
		this.dayEls = this.el.find('.fc-day');
</P><P>		// trigger dayRender with each cell's element
		for (i = 0; i &lt; cellCnt; i++) {
			cell = this.getCell(i);
			view.trigger('dayRender', null, cell.start, this.dayEls.eq(i));
		}
	},
</P><P>
	unrenderDates: function() {
		this.removeSegPopover();
	},
</P><P>
	renderBusinessHours: function() {
		var events = this.view.calendar.getBusinessHoursEvents(true); // wholeDay=true
		var segs = this.eventsToSegs(events);
</P><P>		this.renderFill('businessHours', segs, 'bgevent');
	},
</P><P>
	// Generates the HTML for a single row. `row` is the row number.
	dayRowHtml: function(row, isRigid) {
		var view = this.view;
		var classes = [ 'fc-row', 'fc-week', view.widgetContentClass ];
</P><P>		if (isRigid) {
			classes.push('fc-rigid');
		}
</P><P>		return <I> +</I></P>
			'<DIV class="' + classes.join(' ') + '">' +
				'<DIV class="fc-bg">' +
					'<TABLE>' +
						this.rowHtml('day', row) + // leverages RowRenderer. calls dayCellHtml()
					'</TABLE>' +
				'</DIV>' +
				'<DIV class="fc-content-skeleton">' +
					'<TABLE>' +
						(this.numbersVisible ?
							'&lt;thead&gt;' +
								this.rowHtml('number', row) + // leverages RowRenderer. View will define render method
							'&lt;/thead&gt;' :
							
							) +
					'</TABLE>' +
				'</DIV>' +
			'</DIV>';
<P>	},
</P><P>
	// Renders the HTML for a whole-day cell. Will eventually end up in the day-row's background.
	// We go through a 'day' row type instead of just doing a 'bg' row type so that the View can do custom rendering
	// specifically for whole-day rows, whereas a 'bg' might also be used for other purposes (TimeGrid bg for example).
	dayCellHtml: function(cell) {
		return this.bgCellHtml(cell);
	},
</P><P>
	/* Options
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Computes a default column header formatting string if `colFormat` is not explicitly defined
	computeColHeadFormat: function() {
		if (this.rowCnt &gt; 1) { // more than one week row. day numbers will be in each cell
			return 'ddd'; // &quot;Sat&quot;
		}
		else if (this.colCnt &gt; 1) { // multiple days, so full single date string WON'T be in title text
			return this.view.opt('dayOfMonthFormat'); // &quot;Sat 12/10&quot;
		}
		else { // single day, so full single date string will probably be in title text
			return 'dddd'; // &quot;Saturday&quot;
		}
	},
</P><P>
	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('extraSmallTimeFormat'); // like &quot;6p&quot; or &quot;6:30p&quot;
	},
</P><P>
	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return this.colCnt == 1; // we'll likely have space if there's only one day
	},
</P><P>
	/* Cell System
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	rangeUpdated: function() {
		var cellDates;
		var firstDay;
		var rowCnt;
		var colCnt;
</P><P>		this.updateCellDates(); // populates cellDates and dayToCellOffsets
		cellDates = this.cellDates;
</P><P>		if (this.breakOnWeeks) {
			// count columns until the day-of-week repeats
			firstDay = cellDates[0].day();
			for (colCnt = 1; colCnt &lt; cellDates.length; colCnt++) {
				if (cellDates[colCnt].day() == firstDay) {
					break;
				}
			}
			rowCnt = Math.ceil(cellDates.length / colCnt);
		}
		else {
			rowCnt = 1;
			colCnt = cellDates.length;
		}
</P><P>		this.rowCnt = rowCnt;
		this.colCnt = colCnt;
	},
</P><P>
	// Populates cellDates and dayToCellOffsets
	updateCellDates: function() {
		var view = this.view;
		var date = this.start.clone();
		var dates = [];
		var offset = -1;
		var offsets = [];
</P><P>		while (date.isBefore(this.end)) { // loop each day from start to end
			if (view.isHiddenDay(date)) {
				offsets.push(offset + 0.5); // mark that it's between offsets
			}
			else {
				offset++;
				offsets.push(offset);
				dates.push(date.clone());
			}
			date.add(1, 'days');
		}
</P><P>		this.cellDates = dates;
		this.dayToCellOffsets = offsets;
	},
</P><P>
	// Given a cell object, generates its start date. Returns a reference-free copy.
	computeCellDate: function(cell) {
		var colCnt = this.colCnt;
		var index = cell.row * colCnt + (this.isRTL ? colCnt - cell.col - 1 : cell.col);
</P><P>		return this.cellDates[index].clone();
	},
</P><P>
	// Retrieves the element representing the given row
	getRowEl: function(row) {
		return this.rowEls.eq(row);
	},
</P><P>
	// Retrieves the element representing the given column
	getColEl: function(col) {
		return this.dayEls.eq(col);
	},
</P><P>
	// Gets the whole-day element associated with the cell
	getCellDayEl: function(cell) {
		return this.dayEls.eq(cell.row * this.colCnt + cell.col);
	},
</P><P>
	// Overrides Grid's method for when row coordinates are computed
	computeRowCoords: function() {
		var rowCoords = Grid.prototype.computeRowCoords.call(this); // call the super-method
</P><P>		// hack for extending last row (used by AgendaView)
		rowCoords[rowCoords.length - 1].bottom += this.bottomCoordPadding;
</P><P>		return rowCoords;
	},
</P><P>
	/* Dates
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Slices up a date range by row into an array of segments
	rangeToSegs: function(range) {
		var isRTL = this.isRTL;
		var rowCnt = this.rowCnt;
		var colCnt = this.colCnt;
		var segs = [];
		var first, last; // inclusive cell-offset range for given range
		var row;
		var rowFirst, rowLast; // inclusive cell-offset range for current row
		var isStart, isEnd;
		var segFirst, segLast; // inclusive cell-offset range for segment
		var seg;
</P><P>		range = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
		first = this.dateToCellOffset(range.start);
		last = this.dateToCellOffset(range.end.subtract(1, 'days')); // offset of inclusive end date
</P><P>		for (row = 0; row &lt; rowCnt; row++) {
			rowFirst = row * colCnt;
			rowLast = rowFirst + colCnt - 1;
</P><P>			// intersect segment's offset range with the row's
			segFirst = Math.max(rowFirst, first);
			segLast = Math.min(rowLast, last);
</P><P>			// deal with in-between indices
			segFirst = Math.ceil(segFirst); // in-between starts round to next cell
			segLast = Math.floor(segLast); // in-between ends round to prev cell
</P><P>			if (segFirst &lt;= segLast) { // was there any intersection with the current row?
</P><P>				// must be matching integers to be the segment's start/end
				isStart = segFirst === first;
				isEnd = segLast === last;
</P><P>				// translate offsets to be relative to start-of-row
				segFirst -= rowFirst;
				segLast -= rowFirst;
</P><P>				seg = { row: row, isStart: isStart, isEnd: isEnd };
				if (isRTL) {
					seg.leftCol = colCnt - segLast - 1;
					seg.rightCol = colCnt - segFirst - 1;
				}
				else {
					seg.leftCol = segFirst;
					seg.rightCol = segLast;
				}
				segs.push(seg);
			}
		}
</P><P>		return segs;
	},
</P><P>
	// Given a date, returns its chronolocial cell-offset from the first cell of the grid.
	// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
	// If before the first offset, returns a negative number.
	// If after the last offset, returns an offset past the last cell offset.
	// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
	dateToCellOffset: function(date) {
		var offsets = this.dayToCellOffsets;
		var day = date.diff(this.start, 'days');
</P><P>		if (day &lt; 0) {
			return offsets[0] - 1;
		}
		else if (day &gt;= offsets.length) {
			return offsets[offsets.length - 1] + 1;
		}
		else {
			return offsets[day];
		}
	},
</P><P>
	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: move to DayGrid.event, similar to what we did with Grid's drag methods
</P><P>
	// Renders a visual indication of an event or external element being dragged.
	// The dropLocation's end can be null. seg can be null. See Grid::renderDrag for more info.
	renderDrag: function(dropLocation, seg) {
</P><P>		// always render a highlight underneath
		this.renderHighlight(this.eventRangeToSegs(dropLocation));
</P><P>		// if a segment from the same calendar but another component is being dragged, render a helper event
		if (seg &amp;&amp; !seg.el.closest(this.el).length) {
</P><P>			this.renderRangeHelper(dropLocation, seg);
			this.applyDragOpacity(this.helperEls);
</P><P>			return true; // a helper has been rendered
		}
	},
</P><P>
	// Unrenders any visual indication of a hovering event
	unrenderDrag: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},
</P><P>
	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a visual indication of an event being resized
	renderEventResize: function(range, seg) {
		this.renderHighlight(this.eventRangeToSegs(range));
		this.renderRangeHelper(range, seg);
	},
</P><P>
	// Unrenders a visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},
</P><P>
	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a mock &quot;helper&quot; event. `sourceSeg` is the associated internal segment object. It can be null.
	renderHelper: function(event, sourceSeg) {
		var helperNodes = [];
		var segs = this.eventsToSegs([ event ]);
		var rowStructs;
</P><P>		segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
		rowStructs = this.renderSegRows(segs);
</P><P>		// inject each new event skeleton into each associated row
		this.rowEls.each(function(row, rowNode) {
			var rowEl = $(rowNode); // the .fc-row
</P>
			var skeletonEl = $('<DIV class="fc-helper-skeleton">&lt;table/&gt;</DIV>'); // will be absolutely positioned
<P>			var skeletonTop;
</P><P>			// If there is an original segment, match the top position. Otherwise, put it at the row's top level
			if (sourceSeg &amp;&amp; sourceSeg.row === row) {
				skeletonTop = sourceSeg.el.position().top;
			}
			else {
				skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;
			}
</P><P>			skeletonEl.css('top', skeletonTop)
				.find('table')
					.append(rowStructs[row].tbodyEl);
</P><P>			rowEl.append(skeletonEl);
			helperNodes.push(skeletonEl[0]);
		});
</P><P>		this.helperEls = $(helperNodes); // array -&gt; jQuery set
	},
</P><P>
	// Unrenders any visual indication of a mock helper event
	unrenderHelper: function() {
		if (this.helperEls) {
			this.helperEls.remove();
			this.helperEls = null;
		}
	},
</P><P>
	/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	fillSegTag: 'td', // override the default tag name
</P><P>
	// Renders a set of rectangles over the given segments of days.
	// Only returns segments that successfully rendered.
	renderFill: function(type, segs, className) {
		var nodes = [];
		var i, seg;
		var skeletonEl;
</P><P>		segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs
</P><P>		for (i = 0; i &lt; segs.length; i++) {
			seg = segs[i];
			skeletonEl = this.renderFillRow(type, seg, className);
			this.rowEls.eq(seg.row).append(skeletonEl);
			nodes.push(skeletonEl[0]);
		}
</P><P>		this.elsByFill[type] = $(nodes);
</P><P>		return segs;
	},
</P><P>
	// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
	renderFillRow: function(type, seg, className) {
		var colCnt = this.colCnt;
		var startCol = seg.leftCol;
		var endCol = seg.rightCol + 1;
		var skeletonEl;
		var trEl;
</P><P>		className = className || type.toLowerCase();
</P><P>		skeletonEl = $(
</P>
			'<DIV class="fc-' + className + '-skeleton">' +
				'' +
<P>			'&lt;/div&gt;'
		);
		trEl = skeletonEl.find('tr');
</P><P>		if (startCol &gt; 0) {
			trEl.append('&lt;td colspan=&quot;' + startCol + '&quot;/&gt;');
		}
</P><P>		trEl.append(
			seg.el.attr('colspan', endCol - startCol)
		);
</P><P>		if (endCol &lt; colCnt) {
			trEl.append('&lt;td colspan=&quot;' + (colCnt - endCol) + '&quot;/&gt;');
		}
</P><P>		this.bookendCells(trEl, type);
</P><P>		return skeletonEl;
	}
</P><P>});
</P><P>/* Event-rendering methods for the DayGrid class
</P>*/
<P>DayGrid.mixin({
</P><P>	rowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering
</P><P>
	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.removeSegPopover(); // removes the &quot;more..&quot; events popover
		Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method
	},
</P><P>
	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method
			.concat(this.popoverSegs || []); // append the segments from the &quot;more...&quot; popover
	},
</P><P>
	// Renders the given background event segments onto the grid
	renderBgSegs: function(segs) {
</P><P>		// don't render timed background events
		var allDaySegs = $.grep(segs, function(seg) {
			return seg.event.allDay;
		});
</P><P>		return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method
	},
</P><P>
	// Renders the given foreground event segments onto the grid
	renderFgSegs: function(segs) {
		var rowStructs;
</P><P>		// render an `.el` on each seg
		// returns a subset of the segs. segs that were actually rendered
		segs = this.renderFgSegEls(segs);
</P><P>		rowStructs = this.rowStructs = this.renderSegRows(segs);
</P><P>		// append to each row's content skeleton
		this.rowEls.each(function(i, rowNode) {
			$(rowNode).find('.fc-content-skeleton &gt; table').append(
				rowStructs[i].tbodyEl
			);
		});
</P><P>		return segs; // return only the segs that were actually rendered
	},
</P><P>
	// Unrenders all currently rendered foreground event segments
	unrenderFgSegs: function() {
		var rowStructs = this.rowStructs || [];
		var rowStruct;
</P><P>		while ((rowStruct = rowStructs.pop())) {
			rowStruct.tbodyEl.remove();
		}
</P><P>		this.rowStructs = null;
	},
</P><P>
	// Uses the given events array to generate &lt;tbody&gt; elements that should be appended to each row's content skeleton.
	// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
	// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
	renderSegRows: function(segs) {
		var rowStructs = [];
		var segRows;
		var row;
</P><P>		segRows = this.groupSegRows(segs); // group into nested arrays
</P><P>		// iterate each row of segment groupings
		for (row = 0; row &lt; segRows.length; row++) {
			rowStructs.push(
				this.renderSegRow(row, segRows[row])
			);
		}
</P><P>		return rowStructs;
	},
</P><P>
	// Builds the HTML to be used for the default element for an individual segment
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing &amp;&amp; event.allDay &amp;&amp;
			seg.isStart &amp;&amp; view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing &amp;&amp; event.allDay &amp;&amp;
			seg.isEnd &amp;&amp; view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getEventSkinCss(event));
		var timeHtml = <I>;</I>
		var timeText;
		var titleHtml;
</P><P>		classes.unshift('fc-day-grid-event', 'fc-h-event');
</P><P>		// Only display a timed events time if it is the starting segment
		if (seg.isStart) {
			timeText = this.getEventTimeText(event);
			if (timeText) {
				timeHtml = '<SPAN class="fc-time">' + htmlEscape(timeText) + '</SPAN>';
			}
		}
</P><P>		titleHtml =
			'<SPAN class="fc-title">' +
				(htmlEscape(event.title || <I>) || ' ') + // we always want one line of height</I>
			'</SPAN>';
</P><P>		return '&lt;a class=&quot;' + classes.join(' ') + '&quot;' +
				(event.url ?
					' href=&quot;' + htmlEscape(event.url) + '&quot;' :
					
					) +
				(skinCss ?
					' style=&quot;' + skinCss + '&quot;' :
					
					) +
			'&gt;' +
</P>
				'<DIV class="fc-content">' +
<P>					(this.isRTL ?
						titleHtml + ' ' + timeHtml : // put a natural space in between
						timeHtml + ' ' + titleHtml   //
						) +
</P>
				'</DIV>' +
<P>				(isResizableFromStart ?
					'&lt;div class=&quot;fc-resizer fc-start-resizer&quot; /&gt;' :
					
					) +
				(isResizableFromEnd ?
					'&lt;div class=&quot;fc-resizer fc-end-resizer&quot; /&gt;' :
					
					) +
			'&lt;/a&gt;';
	},
</P><P>
	// Given a row # and an array of segments all in the same row, render a &lt;tbody&gt; element, a skeleton that contains
	// the segments. Returns object with a bunch of internal data about how the render was calculated.
	// NOTE: modifies rowSegs
	renderSegRow: function(row, rowSegs) {
		var colCnt = this.colCnt;
		var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
		var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
		var tbody = $('&lt;tbody/&gt;');
		var segMatrix = []; // lookup for which segments are rendered into which level+col cells
		var cellMatrix = []; // lookup for all &lt;td&gt; elements of the level+col matrix
		var loneCellMatrix = []; // lookup for &lt;td&gt; elements that only take up a single column
		var i, levelSegs;
		var col;
		var tr;
		var j, seg;
		var td;
</P><P>		// populates empty cells from the current column (`col`) to `endCol`
		function emptyCellsUntil(endCol) {
			while (col &lt; endCol) {
				// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
				td = (loneCellMatrix[i - 1] || [])[col];
				if (td) {
					td.attr(
						'rowspan',
						parseInt(td.attr('rowspan') || 1, 10) + 1
					);
				}
				else {
					td = $('&lt;td/&gt;');
					tr.append(td);
				}
				cellMatrix[i][col] = td;
				loneCellMatrix[i][col] = td;
				col++;
			}
		}
</P><P>		for (i = 0; i &lt; levelCnt; i++) { // iterate through all levels
			levelSegs = segLevels[i];
			col = 0;
			tr = $('&lt;tr/&gt;');
</P><P>			segMatrix.push([]);
			cellMatrix.push([]);
			loneCellMatrix.push([]);
</P><P>			// levelCnt might be 1 even though there are no actual levels. protect against this.
			// this single empty row is useful for styling.
			if (levelSegs) {
				for (j = 0; j &lt; levelSegs.length; j++) { // iterate through segments in level
					seg = levelSegs[j];
</P><P>					emptyCellsUntil(seg.leftCol);
</P><P>					// create a container that occupies or more columns. append the event element.
					td = $('&lt;td class=&quot;fc-event-container&quot;/&gt;').append(seg.el);
					if (seg.leftCol != seg.rightCol) {
						td.attr('colspan', seg.rightCol - seg.leftCol + 1);
					}
					else { // a single-column segment
						loneCellMatrix[i][col] = td;
					}
</P><P>					while (col &lt;= seg.rightCol) {
						cellMatrix[i][col] = td;
						segMatrix[i][col] = seg;
						col++;
					}
</P><P>					tr.append(td);
				}
			}
</P><P>			emptyCellsUntil(colCnt); // finish off the row
			this.bookendCells(tr, 'eventSkeleton');
			tbody.append(tr);
		}
</P><P>		return { // a &quot;rowStruct&quot;
			row: row, // the row number
			tbodyEl: tbody,
			cellMatrix: cellMatrix,
			segMatrix: segMatrix,
			segLevels: segLevels,
			segs: rowSegs
		};
	},
</P><P>
	// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
	// NOTE: modifies segs
	buildSegLevels: function(segs) {
		var levels = [];
		var i, seg;
		var j;
</P><P>		// Give preference to elements with certain criteria, so they have
		// a chance to be closer to the top.
		segs.sort(compareSegs);
</P><P>		for (i = 0; i &lt; segs.length; i++) {
			seg = segs[i];
</P><P>			// loop through levels, starting with the topmost, until the segment doesn't collide with other segments
			for (j = 0; j &lt; levels.length; j++) {
				if (!isDaySegCollision(seg, levels[j])) {
					break;
				}
			}
			// `j` now holds the desired subrow index
			seg.level = j;
</P><P>			// create new level array if needed and append segment
			(levels[j] || (levels[j] = [])).push(seg);
		}
</P><P>		// order segments left-to-right. very important if calendar is RTL
		for (j = 0; j &lt; levels.length; j++) {
			levels[j].sort(compareDaySegCols);
		}
</P><P>		return levels;
	},
</P><P>
	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
	groupSegRows: function(segs) {
		var segRows = [];
		var i;
</P><P>		for (i = 0; i &lt; this.rowCnt; i++) {
			segRows.push([]);
		}
</P><P>		for (i = 0; i &lt; segs.length; i++) {
			segRows[segs[i].row].push(segs[i]);
		}
</P><P>		return segRows;
	}
</P><P>});
</P><P>
// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg, otherSegs) {
	var i, otherSeg;
</P><P>	for (i = 0; i &lt; otherSegs.length; i++) {
		otherSeg = otherSegs[i];
</P><P>		if (
			otherSeg.leftCol &lt;= seg.rightCol &amp;&amp;
			otherSeg.rightCol &gt;= seg.leftCol
		) {
			return true;
		}
	}
</P><P>	return false;
}
</P><P>
// A cmp function for determining the leftmost event
function compareDaySegCols(a, b) {
	return a.leftCol - b.leftCol;
}
</P><P>/* Methods relate to limiting the number events for a given day on a DayGrid
</P>*/
<P>// NOTE: all the segs being passed around in here are foreground segs
</P><P>DayGrid.mixin({
</P><P>	segPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible
	popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible
</P><P>
	removeSegPopover: function() {
		if (this.segPopover) {
			this.segPopover.hide(); // in handler, will call segPopover's removeElement
		}
	},
</P><P>
	// Limits the number of &quot;levels&quot; (vertically stacking layers of events) for each row of the grid.
	// `levelLimit` can be false (don't limit), a number, or true (should be computed).
	limitRows: function(levelLimit) {
		var rowStructs = this.rowStructs || [];
		var row; // row #
		var rowLevelLimit;
</P><P>		for (row = 0; row &lt; rowStructs.length; row++) {
			this.unlimitRow(row);
</P><P>			if (!levelLimit) {
				rowLevelLimit = false;
			}
			else if (typeof levelLimit === 'number') {
				rowLevelLimit = levelLimit;
			}
			else {
				rowLevelLimit = this.computeRowLevelLimit(row);
			}
</P><P>			if (rowLevelLimit !== false) {
				this.limitRow(row, rowLevelLimit);
			}
		}
	},
</P><P>
	// Computes the number of levels a row will accomodate without going outside its bounds.
	// Assumes the row is &quot;rigid&quot; (maintains a constant height regardless of what is inside).
	// `row` is the row number.
	computeRowLevelLimit: function(row) {
		var rowEl = this.rowEls.eq(row); // the containing &quot;fake&quot; row div
		var rowHeight = rowEl.height(); // TODO: cache somehow?
		var trEls = this.rowStructs[row].tbodyEl.children();
		var i, trEl;
		var trHeight;
</P><P>		function iterInnerHeights(i, childNode) {
			trHeight = Math.max(trHeight, $(childNode).outerHeight());
		}
</P><P>		// Reveal one level &lt;tr&gt; at a time and stop when we find one out of bounds
		for (i = 0; i &lt; trEls.length; i++) {
			trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)
</P><P>			// with rowspans&gt;1 and IE8, trEl.outerHeight() would return the height of the largest cell,
			// so instead, find the tallest inner content element.
			trHeight = 0;
			trEl.find('&gt; td &gt; :first-child').each(iterInnerHeights);
</P><P>			if (trEl.position().top + trHeight &gt; rowHeight) {
				return i;
			}
		}
</P><P>		return false; // should not limit at all
	},
</P><P>
	// Limits the given grid row to the maximum number of levels and injects &quot;more&quot; links if necessary.
	// `row` is the row number.
	// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
	limitRow: function(row, levelLimit) {
		var _this = this;
		var rowStruct = this.rowStructs[row];
		var moreNodes = []; // array of &quot;more&quot; &lt;a&gt; links and &lt;td&gt; DOM nodes
		var col = 0; // col #, left-to-right (not chronologically)
		var cell;
		var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
		var cellMatrix; // a matrix (by level, then column) of all &lt;td&gt; jQuery elements in the row
		var limitedNodes; // array of temporarily hidden level &lt;tr&gt; and segment &lt;td&gt; DOM nodes
		var i, seg;
		var segsBelow; // array of segment objects below `seg` in the current `col`
		var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
		var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
		var td, rowspan;
		var segMoreNodes; // array of &quot;more&quot; &lt;td&gt; cells that will stand-in for the current seg's cell
		var j;
		var moreTd, moreWrap, moreLink;
</P><P>		// Iterates through empty level cells and places &quot;more&quot; links inside if need be
		function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`
			while (col &lt; endCol) {
				cell = _this.getCell(row, col);
				segsBelow = _this.getCellSegs(cell, levelLimit);
				if (segsBelow.length) {
					td = cellMatrix[levelLimit - 1][col];
					moreLink = _this.renderMoreLink(cell, segsBelow);
					moreWrap = $('&lt;div/&gt;').append(moreLink);
					td.append(moreWrap);
					moreNodes.push(moreWrap[0]);
				}
				col++;
			}
		}
</P><P>		if (levelLimit &amp;&amp; levelLimit &lt; rowStruct.segLevels.length) { // is it actually over the limit?
			levelSegs = rowStruct.segLevels[levelLimit - 1];
			cellMatrix = rowStruct.cellMatrix;
</P><P>			limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level &lt;tr&gt; elements past the limit
				.addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array
</P><P>			// iterate though segments in the last allowable level
			for (i = 0; i &lt; levelSegs.length; i++) {
				seg = levelSegs[i];
				emptyCellsUntil(seg.leftCol); // process empty cells before the segment
</P><P>				// determine *all* segments below `seg` that occupy the same columns
				colSegsBelow = [];
				totalSegsBelow = 0;
				while (col &lt;= seg.rightCol) {
					cell = this.getCell(row, col);
					segsBelow = this.getCellSegs(cell, levelLimit);
					colSegsBelow.push(segsBelow);
					totalSegsBelow += segsBelow.length;
					col++;
				}
</P><P>				if (totalSegsBelow) { // do we need to replace this segment with one or many &quot;more&quot; links?
					td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
					rowspan = td.attr('rowspan') || 1;
					segMoreNodes = [];
</P><P>					// make a replacement &lt;td&gt; for each column the segment occupies. will be one for each colspan
					for (j = 0; j &lt; colSegsBelow.length; j++) {
						moreTd = $('&lt;td class=&quot;fc-more-cell&quot;/&gt;').attr('rowspan', rowspan);
						segsBelow = colSegsBelow[j];
						cell = this.getCell(row, seg.leftCol + j);
						moreLink = this.renderMoreLink(cell, [ seg ].concat(segsBelow)); // count seg as hidden too
						moreWrap = $('&lt;div/&gt;').append(moreLink);
						moreTd.append(moreWrap);
						segMoreNodes.push(moreTd[0]);
						moreNodes.push(moreTd[0]);
					}
</P><P>					td.addClass('fc-limited').after($(segMoreNodes)); // hide original &lt;td&gt; and inject replacements
					limitedNodes.push(td[0]);
				}
			}
</P><P>			emptyCellsUntil(this.colCnt); // finish off the level
			rowStruct.moreEls = $(moreNodes); // for easy undoing later
			rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
		}
	},
</P><P>
	// Reveals all levels and removes all &quot;more&quot;-related elements for a grid's row.
	// `row` is a row number.
	unlimitRow: function(row) {
		var rowStruct = this.rowStructs[row];
</P><P>		if (rowStruct.moreEls) {
			rowStruct.moreEls.remove();
			rowStruct.moreEls = null;
		}
</P><P>		if (rowStruct.limitedEls) {
			rowStruct.limitedEls.removeClass('fc-limited');
			rowStruct.limitedEls = null;
		}
	},
</P><P>
	// Renders an &lt;a&gt; element that represents hidden event element for a cell.
	// Responsible for attaching click handler as well.
	renderMoreLink: function(cell, hiddenSegs) {
		var _this = this;
		var view = this.view;
</P><P>		return $('&lt;a class=&quot;fc-more&quot;/&gt;')
			.text(
				this.getMoreLinkText(hiddenSegs.length)
			)
			.on('click', function(ev) {
				var clickOption = view.opt('eventLimitClick');
				var date = cell.start;
				var moreEl = $(this);
				var dayEl = _this.getCellDayEl(cell);
				var allSegs = _this.getCellSegs(cell);
</P><P>				// rescope the segments to be within the cell's date
				var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
				var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);
</P><P>				if (typeof clickOption === 'function') {
					// the returned value can be an atomic option
					clickOption = view.trigger('eventLimitClick', null, {
						date: date,
						dayEl: dayEl,
						moreEl: moreEl,
						segs: reslicedAllSegs,
						hiddenSegs: reslicedHiddenSegs
					}, ev);
				}
</P><P>				if (clickOption === 'popover') {
					_this.showSegPopover(cell, moreEl, reslicedAllSegs);
				}
				else if (typeof clickOption === 'string') { // a view name
					view.calendar.zoomTo(date, clickOption);
				}
			});
	},
</P><P>
	// Reveals the popover that displays all events within a cell
	showSegPopover: function(cell, moreLink, segs) {
		var _this = this;
		var view = this.view;
</P>
		var moreWrap = moreLink.parent(); // the <DIV> wrapper around the &lt;a&gt;<P>		var topEl; // the element we want to match the top coordinate of
		var options;
</P><P>		if (this.rowCnt == 1) {
			topEl = view.el; // will cause the popover to cover any sort of header
		}
		else {
			topEl = this.rowEls.eq(cell.row); // will align with top of row
		}
</P><P>		options = {
			className: 'fc-more-popover',
			content: this.renderSegPopoverContent(cell, segs),
			parentEl: this.el,
			top: topEl.offset().top,
			autoHide: true, // when the user clicks elsewhere, hide the popover
			viewportConstrain: view.opt('popoverViewportConstrain'),
			hide: function() {
				// kill everything when the popover is hidden
				_this.segPopover.removeElement();
				_this.segPopover = null;
				_this.popoverSegs = null;
			}
		};
</P><P>		// Determine horizontal coordinate.
		// We use the moreWrap instead of the &lt;td&gt; to avoid border confusion.
		if (this.isRTL) {
			options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
		}
		else {
			options.left = moreWrap.offset().left - 1; // -1 to be over cell border
		}
</P><P>		this.segPopover = new Popover(options);
		this.segPopover.show();
	},
</P><P>
	// Builds the inner DOM contents of the segment popover
	renderSegPopoverContent: function(cell, segs) {
		var view = this.view;
		var isTheme = view.opt('theme');
		var title = cell.start.format(view.opt('dayPopoverFormat'));
		var content = $(
</P>
			'<DIV class="fc-header ' + view.widgetHeaderClass + '">' +
<P>				'' +
				'<SPAN class="fc-title">' +
					htmlEscape(title) +
				'</SPAN>' +
				'&lt;div class=&quot;fc-clear&quot;/&gt;' +
</P>
			'</DIV>' +
			'<DIV class="fc-body ' + view.widgetContentClass + '">' +
				'' +
			'</DIV>'
<P>		);
		var segContainer = content.find('.fc-event-container');
		var i;
</P><P>		// render each seg's `el` and only return the visible segs
		segs = this.renderFgSegEls(segs, true); // disableResizing=true
		this.popoverSegs = segs;
</P><P>		for (i = 0; i &lt; segs.length; i++) {
</P><P>			// because segments in the popover are not part of a grid coordinate system, provide a hint to any
			// grids that want to do drag-n-drop about which cell it came from
			segs[i].cell = cell;
</P><P>			segContainer.append(segs[i].el);
		}
</P><P>		return content;
	},
</P><P>
	// Given the events within an array of segment objects, reslice them to be in a single day
	resliceDaySegs: function(segs, dayDate) {
</P><P>		// build an array of the original events
		var events = $.map(segs, function(seg) {
			return seg.event;
		});
</P><P>		var dayStart = dayDate.clone().stripTime();
		var dayEnd = dayStart.clone().add(1, 'days');
		var dayRange = { start: dayStart, end: dayEnd };
</P><P>		// slice the events with a custom slicing function
		segs = this.eventsToSegs(
			events,
			function(range) {
				var seg = intersectionToSeg(range, dayRange); // undefind if no intersection
				return seg ? [ seg ] : []; // must return an array of segments
			}
		);
</P><P>		// force an order because eventsToSegs doesn't guarantee one
		segs.sort(compareSegs);
</P><P>		return segs;
	},
</P><P>
	// Generates the text that should be inside a &quot;more&quot; link, given the number of events it represents
	getMoreLinkText: function(num) {
		var opt = this.view.opt('eventLimitText');
</P><P>		if (typeof opt === 'function') {
			return opt(num);
		}
		else {
			return '+' + num + ' ' + opt;
		}
	},
</P><P>
	// Returns segments within a given cell.
	// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
	getCellSegs: function(cell, startLevel) {
		var segMatrix = this.rowStructs[cell.row].segMatrix;
		var level = startLevel || 0;
		var segs = [];
		var seg;
</P><P>		while (level &lt; segMatrix.length) {
			seg = segMatrix[level][cell.col];
			if (seg) {
				segs.push(seg);
			}
			level++;
		}</P><P>		return segs;
	}
</P><P>});
</P><P>/* A component that renders one or more columns of vertical time slots
</P>*/
<P>var TimeGrid = Grid.extend({
</P><P>	slotDuration: null, // duration of a &quot;slot&quot;, a distinct time segment on given day, visualized by lines
	snapDuration: null, // granularity of time for dragging and selecting
	minTime: null, // Duration object that denotes the first visible time of any given day
	maxTime: null, // Duration object that denotes the exclusive visible end time of any given day
	colDates: null, // whole-day dates for each column. left to right
	axisFormat: null, // formatting string for times running along vertical axis
</P><P>	dayEls: null, // cells elements in the day-row background
	slatEls: null, // elements running horizontally across all columns
</P><P>	slatTops: null, // an array of top positions, relative to the container. last item holds bottom of last slot
</P><P>	helperEl: null, // cell skeleton element for rendering the mock event &quot;helper&quot;
</P><P>	businessHourSegs: null,
</P><P>
	constructor: function() {
		Grid.apply(this, arguments); // call the super-constructor
		this.processOptions();
	},
</P><P>
	// Renders the time grid into `this.el`, which should already be assigned.
	// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
	renderDates: function() {
		this.el.html(this.renderHtml());
		this.dayEls = this.el.find('.fc-day');
		this.slatEls = this.el.find('.fc-slats tr');
	},
</P><P>
	renderBusinessHours: function() {
		var events = this.view.calendar.getBusinessHoursEvents();
		this.businessHourSegs = this.renderFill('businessHours', this.eventsToSegs(events), 'bgevent');
	},
</P><P>
	// Renders the basic HTML skeleton for the grid
	renderHtml: function() {
		return <I> +</I></P>
			'<DIV class="fc-bg">' +
				'<TABLE>' +
					this.rowHtml('slotBg') + // leverages RowRenderer, which will call slotBgCellHtml
				'</TABLE>' +
			'</DIV>' +
			'<DIV class="fc-slats">' +
				'<TABLE>' +
					this.slatRowHtml() +
				'</TABLE>' +
			'</DIV>';
<P>	},
</P><P>
	// Renders the HTML for a vertical background cell behind the slots.
	// This method is distinct from 'bg' because we wanted a new `rowType` so the View could customize the rendering.
	slotBgCellHtml: function(cell) {
		return this.bgCellHtml(cell);
	},
</P><P>
	// Generates the HTML for the horizontal &quot;slats&quot; that run width-wise. Has a time axis on a side. Depends on RTL.
	slatRowHtml: function() {
		var view = this.view;
		var isRTL = this.isRTL;
		var html = <I>;</I>
		var slotNormal = this.slotDuration.asMinutes() % 15 === 0;
		var slotTime = moment.duration(+this.minTime); // wish there was .clone() for durations
		var slotDate; // will be on the view's first day, but we only care about its time
		var minutes;
		var axisHtml;
</P><P>		// Calculate the time for each slot
		while (slotTime &lt; this.maxTime) {
			slotDate = this.start.clone().time(slotTime); // will be in UTC but that's good. to avoid DST issues
			minutes = slotDate.minutes();
</P><P>			axisHtml =
				'&lt;td class=&quot;fc-axis fc-time ' + view.widgetContentClass + '&quot; ' + view.axisStyleAttr() + '&gt;' +
					((!slotNormal || !minutes) ? // if irregular slot duration, or on the hour, then display the time
						'<SPAN>' + // for matchCellWidths
							htmlEscape(slotDate.format(this.axisFormat)) +
						'</SPAN>' :
						
						) +
				'&lt;/td&gt;';
</P><P>			html +=
				'&lt;tr ' + (!minutes ? <I> : 'class=&quot;fc-minor&quot;') + '&gt;' +</I>
					(!isRTL ? axisHtml : <I>) +</I>
					'&lt;td class=&quot;' + view.widgetContentClass + '&quot;/&gt;' +
					(isRTL ? axisHtml : <I>) +</I>
				&quot;&lt;/tr&gt;&quot;;
</P><P>			slotTime.add(this.slotDuration);
		}
</P><P>		return html;
	},
</P><P>
	/* Options
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Parses various options into properties of this object
	processOptions: function() {
		var view = this.view;
		var slotDuration = view.opt('slotDuration');
		var snapDuration = view.opt('snapDuration');
</P><P>		slotDuration = moment.duration(slotDuration);
		snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;
</P><P>		this.slotDuration = slotDuration;
		this.snapDuration = snapDuration;
		this.cellDuration = snapDuration; // for Grid system
</P><P>		this.minTime = moment.duration(view.opt('minTime'));
		this.maxTime = moment.duration(view.opt('maxTime'));
</P><P>		this.axisFormat = view.opt('axisFormat') || view.opt('smallTimeFormat');
	},
</P><P>
	// Computes a default column header formatting string if `colFormat` is not explicitly defined
	computeColHeadFormat: function() {
		if (this.colCnt &gt; 1) { // multiple days, so full single date string WON'T be in title text
			return this.view.opt('dayOfMonthFormat'); // &quot;Sat 12/10&quot;
		}
		else { // single day, so full single date string will probably be in title text
			return 'dddd'; // &quot;Saturday&quot;
		}
	},
</P><P>
	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('noMeridiemTimeFormat'); // like &quot;6:30&quot; (no AM/PM)
	},
</P><P>
	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return true;
	},
</P><P>
	/* Cell System
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	rangeUpdated: function() {
		var view = this.view;
		var colDates = [];
		var date;
</P><P>		date = this.start.clone();
		while (date.isBefore(this.end)) {
			colDates.push(date.clone());
			date.add(1, 'day');
			date = view.skipHiddenDays(date);
		}
</P><P>		if (this.isRTL) {
			colDates.reverse();
		}
</P><P>		this.colDates = colDates;
		this.colCnt = colDates.length;
		this.rowCnt = Math.ceil((this.maxTime - this.minTime) / this.snapDuration); // # of vertical snaps
	},
</P><P>
	// Given a cell object, generates its start date. Returns a reference-free copy.
	computeCellDate: function(cell) {
		var date = this.colDates[cell.col];
		var time = this.computeSnapTime(cell.row);
</P><P>		date = this.view.calendar.rezoneDate(date); // give it a 00:00 time
		date.time(time);
</P><P>		return date;
	},
</P><P>
	// Retrieves the element representing the given column
	getColEl: function(col) {
		return this.dayEls.eq(col);
	},
</P><P>
	/* Dates
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Given a row number of the grid, representing a &quot;snap&quot;, returns a time (Duration) from its start-of-day
	computeSnapTime: function(row) {
		return moment.duration(this.minTime + this.snapDuration * row);
	},
</P><P>
	// Slices up a date range by column into an array of segments
	rangeToSegs: function(range) {
		var colCnt = this.colCnt;
		var segs = [];
		var seg;
		var col;
		var colDate;
		var colRange;
</P><P>		// normalize :(
		range = {
			start: range.start.clone().stripZone(),
			end: range.end.clone().stripZone()
		};
</P><P>		for (col = 0; col &lt; colCnt; col++) {
			colDate = this.colDates[col]; // will be ambig time/timezone
			colRange = {
				start: colDate.clone().time(this.minTime),
				end: colDate.clone().time(this.maxTime)
			};
			seg = intersectionToSeg(range, colRange); // both will be ambig timezone
			if (seg) {
				seg.col = col;
				segs.push(seg);
			}
		}
</P><P>		return segs;
	},
</P><P>
	/* Coordinates
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	updateSize: function(isResize) { // NOT a standard Grid method
		this.computeSlatTops();
</P><P>		if (isResize) {
			this.updateSegVerticals();
		}
	},
</P><P>
	// Computes the top/bottom coordinates of each &quot;snap&quot; rows
	computeRowCoords: function() {
		var originTop = this.el.offset().top;
		var items = [];
		var i;
		var item;
</P><P>		for (i = 0; i &lt; this.rowCnt; i++) {
			item = {
				top: originTop + this.computeTimeTop(this.computeSnapTime(i))
			};
			if (i &gt; 0) {
				items[i - 1].bottom = item.top;
			}
			items.push(item);
		}
		item.bottom = item.top + this.computeTimeTop(this.computeSnapTime(i));
</P><P>		return items;
	},
</P><P>
	// Computes the top coordinate, relative to the bounds of the grid, of the given date.
	// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
	computeDateTop: function(date, startOfDayDate) {
		return this.computeTimeTop(
			moment.duration(
				date.clone().stripZone() - startOfDayDate.clone().stripTime()
			)
		);
	},
</P><P>
	// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
	computeTimeTop: function(time) {
		var slatCoverage = (time - this.minTime) / this.slotDuration; // floating-point value of # of slots covered
		var slatIndex;
		var slatRemainder;
		var slatTop;
		var slatBottom;
</P><P>		// constrain. because minTime/maxTime might be customized
		slatCoverage = Math.max(0, slatCoverage);
		slatCoverage = Math.min(this.slatEls.length, slatCoverage);
</P><P>		slatIndex = Math.floor(slatCoverage); // an integer index of the furthest whole slot
		slatRemainder = slatCoverage - slatIndex;
		slatTop = this.slatTops[slatIndex]; // the top position of the furthest whole slot
</P><P>		if (slatRemainder) { // time spans part-way into the slot
			slatBottom = this.slatTops[slatIndex + 1];
			return slatTop + (slatBottom - slatTop) * slatRemainder; // part-way between slots
		}
		else {
			return slatTop;
		}
	},
</P><P>
	// Queries each `slatEl` for its position relative to the grid's container and stores it in `slatTops`.
	// Includes the the bottom of the last slat as the last item in the array.
	computeSlatTops: function() {
		var tops = [];
		var top;
</P><P>		this.slatEls.each(function(i, node) {
			top = $(node).position().top;
			tops.push(top);
		});
</P><P>		tops.push(top + this.slatEls.last().outerHeight()); // bottom of the last slat
</P><P>		this.slatTops = tops;
	},
</P><P>
	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a visual indication of an event being dragged over the specified date(s).
	// dropLocation's end might be null, as well as `seg`. See Grid::renderDrag for more info.
	// A returned value of `true` signals that a mock &quot;helper&quot; event has been rendered.
	renderDrag: function(dropLocation, seg) {
</P><P>		if (seg) { // if there is event information for this drag, render a helper event
			this.renderRangeHelper(dropLocation, seg);
			this.applyDragOpacity(this.helperEl);
</P><P>			return true; // signal that a helper has been rendered
		}
		else {
			// otherwise, just render a highlight
			this.renderHighlight(this.eventRangeToSegs(dropLocation));
		}
	},
</P><P>
	// Unrenders any visual indication of an event being dragged
	unrenderDrag: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},
</P><P>
	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a visual indication of an event being resized
	renderEventResize: function(range, seg) {
		this.renderRangeHelper(range, seg);
	},
</P><P>
	// Unrenders any visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHelper();
	},
</P><P>
	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a mock &quot;helper&quot; event. `sourceSeg` is the original segment object and might be null (an external drag)
	renderHelper: function(event, sourceSeg) {
		var segs = this.eventsToSegs([ event ]);
		var tableEl;
		var i, seg;
		var sourceEl;
</P><P>		segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
		tableEl = this.renderSegTable(segs);
</P><P>		// Try to make the segment that is in the same row as sourceSeg look the same
		for (i = 0; i &lt; segs.length; i++) {
			seg = segs[i];
			if (sourceSeg &amp;&amp; sourceSeg.col === seg.col) {
				sourceEl = sourceSeg.el;
				seg.el.css({
					left: sourceEl.css('left'),
					right: sourceEl.css('right'),
					'margin-left': sourceEl.css('margin-left'),
					'margin-right': sourceEl.css('margin-right')
				});
			}
		}
</P><P>		this.helperEl = $('&lt;div class=&quot;fc-helper-skeleton&quot;/&gt;')
			.append(tableEl)
				.appendTo(this.el);
	},
</P><P>
	// Unrenders any mock helper event
	unrenderHelper: function() {
		if (this.helperEl) {
			this.helperEl.remove();
			this.helperEl = null;
		}
	},
</P><P>
	/* Selection
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
	renderSelection: function(range) {
		if (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered
			this.renderRangeHelper(range);
		}
		else {
			this.renderHighlight(this.selectionRangeToSegs(range));
		}
	},
</P><P>
	// Unrenders any visual indication of a selection
	unrenderSelection: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},
</P><P>
	/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a set of rectangles over the given time segments.
	// Only returns segments that successfully rendered.
	renderFill: function(type, segs, className) {
		var segCols;
		var skeletonEl;
		var trEl;
		var col, colSegs;
		var tdEl;
		var containerEl;
		var dayDate;
		var i, seg;
</P><P>		if (segs.length) {
</P><P>			segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs
			segCols = this.groupSegCols(segs); // group into sub-arrays, and assigns 'col' to each seg
</P><P>			className = className || type.toLowerCase();
			skeletonEl = $(
</P>
				'<DIV class="fc-' + className + '-skeleton">' +
					'' +
<P>				'&lt;/div&gt;'
			);
			trEl = skeletonEl.find('tr');
</P><P>			for (col = 0; col &lt; segCols.length; col++) {
				colSegs = segCols[col];
				tdEl = $('&lt;td/&gt;').appendTo(trEl);
</P><P>				if (colSegs.length) {
					containerEl = $('&lt;div class=&quot;fc-' + className + '-container&quot;/&gt;').appendTo(tdEl);
					dayDate = this.colDates[col];
</P><P>					for (i = 0; i &lt; colSegs.length; i++) {
						seg = colSegs[i];
						containerEl.append(
							seg.el.css({
								top: this.computeDateTop(seg.start, dayDate),
								bottom: -this.computeDateTop(seg.end, dayDate) // the y position of the bottom edge
							})
						);
					}
				}
			}
</P><P>			this.bookendCells(trEl, type);
</P><P>			this.el.append(skeletonEl);
			this.elsByFill[type] = skeletonEl;
		}
</P><P>		return segs;
	}
</P><P>});
</P><P>/* Event-rendering methods for the TimeGrid class
</P>*/
<P>TimeGrid.mixin({
</P><P>	eventSkeletonEl: null, // has cells with event-containers, which contain absolutely positioned event elements
</P><P>
	// Renders the given foreground event segments onto the grid
	renderFgSegs: function(segs) {
		segs = this.renderFgSegEls(segs); // returns a subset of the segs. segs that were actually rendered
</P><P>		this.el.append(
			this.eventSkeletonEl = $('&lt;div class=&quot;fc-content-skeleton&quot;/&gt;')
				.append(this.renderSegTable(segs))
		);
</P><P>		return segs; // return only the segs that were actually rendered
	},
</P><P>
	// Unrenders all currently rendered foreground event segments
	unrenderFgSegs: function(segs) {
		if (this.eventSkeletonEl) {
			this.eventSkeletonEl.remove();
			this.eventSkeletonEl = null;
		}
	},
</P>
	// Renders and returns the <TABLE> portion of the event-skeleton.
	// Returns an object with properties 'tbodyEl' and 'segs'.
	renderSegTable: function(segs) {
		var tableEl = $('');
<P>		var trEl = tableEl.find('tr');
		var segCols;
		var i, seg;
		var col, colSegs;
		var containerEl;
</P><P>		segCols = this.groupSegCols(segs); // group into sub-arrays, and assigns 'col' to each seg
</P><P>		this.computeSegVerticals(segs); // compute and assign top/bottom
</P><P>		for (col = 0; col &lt; segCols.length; col++) { // iterate each column grouping
			colSegs = segCols[col];
			placeSlotSegs(colSegs); // compute horizontal coordinates, z-index's, and reorder the array
</P><P>			containerEl = $('&lt;div class=&quot;fc-event-container&quot;/&gt;');
</P><P>			// assign positioning CSS and insert into container
			for (i = 0; i &lt; colSegs.length; i++) {
				seg = colSegs[i];
				seg.el.css(this.generateSegPositionCss(seg));
</P><P>				// if the height is short, add a className for alternate styling
				if (seg.bottom - seg.top &lt; 30) {
					seg.el.addClass('fc-short');
				}
</P><P>				containerEl.append(seg.el);
			}
</P><P>			trEl.append($('&lt;td/&gt;').append(containerEl));
		}
</P><P>		this.bookendCells(trEl, 'eventSkeleton');
</P><P>		return tableEl;
	},
</P><P>
	// Refreshes the CSS top/bottom coordinates for each segment element. Probably after a window resize/zoom.
	// Repositions business hours segs too, so not just for events. Maybe shouldn't be here.
	updateSegVerticals: function() {
		var allSegs = (this.segs || []).concat(this.businessHourSegs || []);
		var i;
</P><P>		this.computeSegVerticals(allSegs);
</P><P>		for (i = 0; i &lt; allSegs.length; i++) {
			allSegs[i].el.css(
				this.generateSegVerticalCss(allSegs[i])
			);
		}
	},
</P><P>
	// For each segment in an array, computes and assigns its top and bottom properties
	computeSegVerticals: function(segs) {
		var i, seg;
</P><P>		for (i = 0; i &lt; segs.length; i++) {
			seg = segs[i];
			seg.top = this.computeDateTop(seg.start, seg.start);
			seg.bottom = this.computeDateTop(seg.end, seg.start);
		}
	},
</P><P>
	// Renders the HTML for a single event segment's default rendering
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing &amp;&amp; seg.isStart &amp;&amp; view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing &amp;&amp; seg.isEnd &amp;&amp; view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getEventSkinCss(event));
		var timeText;
		var fullTimeText; // more verbose time text. for the print stylesheet
		var startTimeText; // just the start time text
</P><P>		classes.unshift('fc-time-grid-event', 'fc-v-event');
</P><P>		if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
			// Don't display time text on segments that run entirely through a day.
			// That would appear as midnight-midnight and would look dumb.
			// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
			if (seg.isStart || seg.isEnd) {
				timeText = this.getEventTimeText(seg);
				fullTimeText = this.getEventTimeText(seg, 'LT');
				startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
			}
		} else {
			// Display the normal time text for the *event's* times
			timeText = this.getEventTimeText(event);
			fullTimeText = this.getEventTimeText(event, 'LT');
			startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
		}
</P><P>		return '&lt;a class=&quot;' + classes.join(' ') + '&quot;' +
			(event.url ?
				' href=&quot;' + htmlEscape(event.url) + '&quot;' :
				
				) +
			(skinCss ?
				' style=&quot;' + skinCss + '&quot;' :
				
				) +
			'&gt;' +
</P>
				'<DIV class="fc-content">' +
<P>					(timeText ?
</P>
						'<DIV>' +
<P>							'<SPAN>' + htmlEscape(timeText) + '</SPAN>' +
</P>
						'</DIV>' :
<P>						
						) +
					(event.title ?
</P>
						'<DIV class="fc-title">' +
<P>							htmlEscape(event.title) +
</P>
						'</DIV>' :
<P>						
						) +
</P>
				'</DIV>' +
<P>				'&lt;div class=&quot;fc-bg&quot;/&gt;' +
				/* TODO: write CSS for this
				(isResizableFromStart ?
					'&lt;div class=&quot;fc-resizer fc-start-resizer&quot; /&gt;' :
					
					) +
				*/
				(isResizableFromEnd ?
					'&lt;div class=&quot;fc-resizer fc-end-resizer&quot; /&gt;' :
					
					) +
			'&lt;/a&gt;';
	},
</P><P>
	// Generates an object with CSS properties/values that should be applied to an event segment element.
	// Contains important positioning-related properties that should be applied to any event element, customized or not.
	generateSegPositionCss: function(seg) {
		var shouldOverlap = this.view.opt('slotEventOverlap');
		var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
		var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
		var props = this.generateSegVerticalCss(seg); // get top/bottom first
		var left; // amount of space from left edge, a fraction of the total width
		var right; // amount of space from right edge, a fraction of the total width
</P><P>		if (shouldOverlap) {
			// double the width, but don't go beyond the maximum forward coordinate (1.0)
			forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
		}
</P><P>		if (this.isRTL) {
			left = 1 - forwardCoord;
			right = backwardCoord;
		}
		else {
			left = backwardCoord;
			right = 1 - forwardCoord;
		}
</P><P>		props.zIndex = seg.level + 1; // convert from 0-base to 1-based
		props.left = left * 100 + '%';
		props.right = right * 100 + '%';
</P><P>		if (shouldOverlap &amp;&amp; seg.forwardPressure) {
			// add padding to the edge so that forward stacked events don't cover the resizer's icon
			props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
		}
</P><P>		return props;
	},
</P><P>
	// Generates an object with CSS properties for the top/bottom coordinates of a segment element
	generateSegVerticalCss: function(seg) {
		return {
			top: seg.top,
			bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
		};
	},
</P><P>
	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
	groupSegCols: function(segs) {
		var segCols = [];
		var i;
</P><P>		for (i = 0; i &lt; this.colCnt; i++) {
			segCols.push([]);
		}
</P><P>		for (i = 0; i &lt; segs.length; i++) {
			segCols[segs[i].col].push(segs[i]);
		}
</P><P>		return segCols;
	}
</P><P>});
</P><P>
// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
// NOTE: Also reorders the given array by date!
function placeSlotSegs(segs) {
	var levels;
	var level0;
	var i;
</P><P>	segs.sort(compareSegs); // order by date
	levels = buildSlotSegLevels(segs);
	computeForwardSlotSegs(levels);
</P><P>	if ((level0 = levels[0])) {
</P><P>		for (i = 0; i &lt; level0.length; i++) {
			computeSlotSegPressures(level0[i]);
		}
</P><P>		for (i = 0; i &lt; level0.length; i++) {
			computeSlotSegCoords(level0[i], 0, 0);
		}
	}
}
</P><P>
// Builds an array of segments &quot;levels&quot;. The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs) {
	var levels = [];
	var i, seg;
	var j;
</P><P>	for (i=0; i&lt;segs.length; i++) {
		seg = segs[i];
</P><P>		// go through all the levels and stop on the first level where there are no collisions
		for (j=0; j&lt;levels.length; j++) {
			if (!computeSlotSegCollisions(seg, levels[j]).length) {
				break;
			}
		}
</P><P>		seg.level = j;
</P><P>		(levels[j] || (levels[j] = [])).push(seg);
	}
</P><P>	return levels;
}
</P><P>
// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
	var i, level;
	var j, seg;
	var k;
</P><P>	for (i=0; i&lt;levels.length; i++) {
		level = levels[i];
</P><P>		for (j=0; j&lt;level.length; j++) {
			seg = level[j];
</P><P>			seg.forwardSegs = [];
			for (k=i+1; k&lt;levels.length; k++) {
				computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
			}
		}
	}
}
</P><P>
// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
	var forwardSegs = seg.forwardSegs;
	var forwardPressure = 0;
	var i, forwardSeg;
</P><P>	if (seg.forwardPressure === undefined) { // not already computed
</P><P>		for (i=0; i&lt;forwardSegs.length; i++) {
			forwardSeg = forwardSegs[i];
</P><P>			// figure out the child's maximum forward path
			computeSlotSegPressures(forwardSeg);
</P><P>			// either use the existing maximum, or use the child's forward pressure
			// plus one (for the forwardSeg itself)
			forwardPressure = Math.max(
				forwardPressure,
				1 + forwardSeg.forwardPressure
			);
		}
</P><P>		seg.forwardPressure = forwardPressure;
	}
}
</P><P>
// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to &quot;left&quot; and
// seg.forwardCoord maps to &quot;right&quot; (via percentage). Vice-versa if the calendar is right-to-left.
//
// The segment might be part of a &quot;series&quot;, which means consecutive segments with the same pressure
// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
// coordinate of the first segment in the series.
function computeSlotSegCoords(seg, seriesBackwardPressure, seriesBackwardCoord) {
	var forwardSegs = seg.forwardSegs;
	var i;
</P><P>	if (seg.forwardCoord === undefined) { // not already computed
</P><P>		if (!forwardSegs.length) {
</P><P>			// if there are no forward segments, this segment should butt up against the edge
			seg.forwardCoord = 1;
		}
		else {
</P><P>			// sort highest pressure first
			forwardSegs.sort(compareForwardSlotSegs);
</P><P>			// this segment's forwardCoord will be calculated from the backwardCoord of the
			// highest-pressure forward segment.
			computeSlotSegCoords(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
			seg.forwardCoord = forwardSegs[0].backwardCoord;
		}
</P><P>		// calculate the backwardCoord from the forwardCoord. consider the series
		seg.backwardCoord = seg.forwardCoord -
			(seg.forwardCoord - seriesBackwardCoord) / // available width for series
			(seriesBackwardPressure + 1); // # of segments in the series
</P><P>		// use this segment's coordinates to computed the coordinates of the less-pressurized
		// forward segments
		for (i=0; i&lt;forwardSegs.length; i++) {
			computeSlotSegCoords(forwardSegs[i], 0, seg.forwardCoord);
		}
	}
}
</P><P>
// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
	results = results || [];
</P><P>	for (var i=0; i&lt;otherSegs.length; i++) {
		if (isSlotSegCollision(seg, otherSegs[i])) {
			results.push(otherSegs[i]);
		}
	}
</P><P>	return results;
}
</P><P>
// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
	return seg1.bottom &gt; seg2.top &amp;&amp; seg1.top &lt; seg2.bottom;
}
</P><P>
// A cmp function for determining which forward segment to rely on more when computing coordinates.
function compareForwardSlotSegs(seg1, seg2) {
	// put higher-pressure first
	return seg2.forwardPressure - seg1.forwardPressure ||
		// put segments that are closer to initial edge first (and favor ones with no coords yet)
		(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
		// do normal sorting...
		compareSegs(seg1, seg2);
}
</P><P>/* An abstract class from which other views inherit from
</P>*/
<P>var View = fc.View = Class.extend({
</P><P>	type: null, // subclass' view name (string)
	name: null, // deprecated. use `type` instead
	title: null, // the text that will be displayed in the header's title
</P><P>	calendar: null, // owner Calendar object
	options: null, // hash containing all options. already merged with view-specific-options
	coordMap: null, // a CoordMap object for converting pixel regions to dates
	el: null, // the view's containing element. set by Calendar
</P><P>	displaying: null, // a promise representing the state of rendering. null if no render requested
	isSkeletonRendered: false,
	isEventsRendered: false,
</P><P>	// range the view is actually displaying (moments)
	start: null,
	end: null, // exclusive
</P><P>	// range the view is formally responsible for (moments)
	// may be different from start/end. for example, a month view might have 1st-31st, excluding padded dates
	intervalStart: null,
	intervalEnd: null, // exclusive
	intervalDuration: null,
	intervalUnit: null, // name of largest unit being displayed, like &quot;month&quot; or &quot;week&quot;
</P><P>	isRTL: false,
	isSelected: false, // boolean whether a range of time is user-selected or not
</P><P>	// subclasses can optionally use a scroll container
	scrollerEl: null, // the element that will most likely scroll when content is too tall
	scrollTop: null, // cached vertical scroll value
</P><P>	// classNames styled by jqui themes
	widgetHeaderClass: null,
	widgetContentClass: null,
	highlightStateClass: null,
</P><P>	// for date utils, computed from options
	nextDayThreshold: null,
	isHiddenDayHash: null,
</P><P>	// document handlers, bound to `this` object
	documentMousedownProxy: null, // TODO: doesn't work with touch
</P><P>
	constructor: function(calendar, type, options, intervalDuration) {
</P><P>		this.calendar = calendar;
		this.type = this.name = type; // .name is deprecated
		this.options = options;
		this.intervalDuration = intervalDuration || moment.duration(1, 'day');
</P><P>		this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));
		this.initThemingProps();
		this.initHiddenDays();
		this.isRTL = this.opt('isRTL');
</P><P>		this.documentMousedownProxy = proxy(this, 'documentMousedown');
</P><P>		this.initialize();
	},
</P><P>
	// A good place for subclasses to initialize member variables
	initialize: function() {
		// subclasses can implement
	},
</P><P>
	// Retrieves an option with the given name
	opt: function(name) {
		return this.options[name];
	},
</P><P>
	// Triggers handlers that are view-related. Modifies args before passing to calendar.
	trigger: function(name, thisObj) { // arguments beyond thisObj are passed along
		var calendar = this.calendar;
</P><P>		return calendar.trigger.apply(
			calendar,
			[name, thisObj || this].concat(
				Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj
				[ this ] // always make the last argument a reference to the view. TODO: deprecate
			)
		);
	},
</P><P>
	/* Dates
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Updates all internal dates to center around the given current date
	setDate: function(date) {
		this.setRange(this.computeRange(date));
	},
</P><P>
	// Updates all internal dates for displaying the given range.
	// Expects all values to be normalized (like what computeRange does).
	setRange: function(range) {
		$.extend(this, range);
		this.updateTitle();
	},
</P><P>
	// Given a single current date, produce information about what range to display.
	// Subclasses can override. Must return all properties.
	computeRange: function(date) {
		var intervalUnit = computeIntervalUnit(this.intervalDuration);
		var intervalStart = date.clone().startOf(intervalUnit);
		var intervalEnd = intervalStart.clone().add(this.intervalDuration);
		var start, end;
</P><P>		// normalize the range's time-ambiguity
		if (/year|month|week|day/.test(intervalUnit)) { // whole-days?
			intervalStart.stripTime();
			intervalEnd.stripTime();
		}
		else { // needs to have a time?
			if (!intervalStart.hasTime()) {
				intervalStart = this.calendar.rezoneDate(intervalStart); // convert to current timezone, with 00:00
			}
			if (!intervalEnd.hasTime()) {
				intervalEnd = this.calendar.rezoneDate(intervalEnd); // convert to current timezone, with 00:00
			}
		}
</P><P>		start = intervalStart.clone();
		start = this.skipHiddenDays(start);
		end = intervalEnd.clone();
		end = this.skipHiddenDays(end, -1, true); // exclusively move backwards
</P><P>		return {
			intervalUnit: intervalUnit,
			intervalStart: intervalStart,
			intervalEnd: intervalEnd,
			start: start,
			end: end
		};
	},
</P><P>
	// Computes the new date when the user hits the prev button, given the current date
	computePrevDate: function(date) {
		return this.massageCurrentDate(
			date.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1
		);
	},
</P><P>
	// Computes the new date when the user hits the next button, given the current date
	computeNextDate: function(date) {
		return this.massageCurrentDate(
			date.clone().startOf(this.intervalUnit).add(this.intervalDuration)
		);
	},
</P><P>
	// Given an arbitrarily calculated current date of the calendar, returns a date that is ensured to be completely
	// visible. `direction` is optional and indicates which direction the current date was being
	// incremented or decremented (1 or -1).
	massageCurrentDate: function(date, direction) {
		if (this.intervalDuration.as('days') &lt;= 1) { // if the view displays a single day or smaller
			if (this.isHiddenDay(date)) {
				date = this.skipHiddenDays(date, direction);
				date.startOf('day');
			}
		}
</P><P>		return date;
	},
</P><P>
	/* Title and Date Formatting
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Sets the view's title property to the most updated computed value
	updateTitle: function() {
		this.title = this.computeTitle();
	},
</P><P>
	// Computes what the title at the top of the calendar should be for this view
	computeTitle: function() {
		return this.formatRange(
			{ start: this.intervalStart, end: this.intervalEnd },
			this.opt('titleFormat') || this.computeTitleFormat(),
			this.opt('titleRangeSeparator')
		);
	},
</P><P>
	// Generates the format string that should be used to generate the title for the current date range.
	// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
	computeTitleFormat: function() {
		if (this.intervalUnit == 'year') {
			return 'YYYY';
		}
		else if (this.intervalUnit == 'month') {
			return this.opt('monthYearFormat'); // like &quot;September 2014&quot;
		}
		else if (this.intervalDuration.as('days') &gt; 1) {
			return 'll'; // multi-day range. shorter, like &quot;Sep 9 - 10 2014&quot;
		}
		else {
			return 'LL'; // one day. longer, like &quot;September 9 2014&quot;
		}
	},
</P><P>
	// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
	// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
	formatRange: function(range, formatStr, separator) {
		var end = range.end;
</P><P>		if (!end.hasTime()) { // all-day?
			end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
		}
</P><P>		return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));
	},
</P><P>
	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Sets the container element that the view should render inside of.
	// Does other DOM-related initializations.
	setElement: function(el) {
		this.el = el;
		this.bindGlobalHandlers();
	},
</P><P>
	// Removes the view's container element from the DOM, clearing any content beforehand.
	// Undoes any other DOM-related attachments.
	removeElement: function() {
		this.clear(); // clears all content
</P><P>		// clean up the skeleton
		if (this.isSkeletonRendered) {
			this.unrenderSkeleton();
			this.isSkeletonRendered = false;
		}
</P><P>		this.unbindGlobalHandlers();
</P><P>		this.el.remove();
</P><P>		// NOTE: don't null-out this.el in case the View was destroyed within an API callback.
		// We don't null-out the View's other jQuery element references upon destroy,
		//  so we shouldn't kill this.el either.
	},
</P><P>
	// Does everything necessary to display the view centered around the given date.
	// Does every type of rendering EXCEPT rendering events.
	// Is asychronous and returns a promise.
	display: function(date) {
		var _this = this;
		var scrollState = null;
</P><P>		if (this.displaying) {
			scrollState = this.queryScroll();
		}
</P><P>		return this.clear().then(function() { // clear the content first (async)
			return (
				_this.displaying =
					$.when(_this.displayView(date)) // displayView might return a promise
						.then(function() {
							_this.forceScroll(_this.computeInitialScroll(scrollState));
							_this.triggerRender();
						})
			);
		});
	},
</P><P>
	// Does everything necessary to clear the content of the view.
	// Clears dates and events. Does not clear the skeleton.
	// Is asychronous and returns a promise.
	clear: function() {
		var _this = this;
		var displaying = this.displaying;
</P><P>		if (displaying) { // previously displayed, or in the process of being displayed?
			return displaying.then(function() { // wait for the display to finish
				_this.displaying = null;
				_this.clearEvents();
				return _this.clearView(); // might return a promise. chain it
			});
		}
		else {
			return $.when(); // an immediately-resolved promise
		}
	},
</P><P>
	// Displays the view's non-event content, such as date-related content or anything required by events.
	// Renders the view's non-content skeleton if necessary.
	// Can be asynchronous and return a promise.
	displayView: function(date) {
		if (!this.isSkeletonRendered) {
			this.renderSkeleton();
			this.isSkeletonRendered = true;
		}
		this.setDate(date);
		if (this.render) {
			this.render(); // TODO: deprecate
		}
		this.renderDates();
		this.updateSize();
		this.renderBusinessHours(); // might need coordinates, so should go after updateSize()
	},
</P><P>
	// Unrenders the view content that was rendered in displayView.
	// Can be asynchronous and return a promise.
	clearView: function() {
		this.unselect();
		this.triggerUnrender();
		this.unrenderBusinessHours();
		this.unrenderDates();
		if (this.destroy) {
			this.destroy(); // TODO: deprecate
		}
	},
</P><P>
	// Renders the basic structure of the view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},
</P><P>
	// Unrenders the basic structure of the view
	unrenderSkeleton: function() {
		// subclasses should implement
	},
</P><P>
	// Renders the view's date-related content (like cells that represent days/times).
	// Assumes setRange has already been called and the skeleton has already been rendered.
	renderDates: function() {
		// subclasses should implement
	},
</P><P>
	// Unrenders the view's date-related content
	unrenderDates: function() {
		// subclasses should override
	},
</P><P>
	// Renders business-hours onto the view. Assumes updateSize has already been called.
	renderBusinessHours: function() {
		// subclasses should implement
	},
</P><P>
	// Unrenders previously-rendered business-hours
	unrenderBusinessHours: function() {
		// subclasses should implement
	},
</P><P>
	// Signals that the view's content has been rendered
	triggerRender: function() {
		this.trigger('viewRender', this, this, this.el);
	},
</P><P>
	// Signals that the view's content is about to be unrendered
	triggerUnrender: function() {
		this.trigger('viewDestroy', this, this, this.el);
	},
</P><P>
	// Binds DOM handlers to elements that reside outside the view container, such as the document
	bindGlobalHandlers: function() {
		$(document).on('mousedown', this.documentMousedownProxy);
	},
</P><P>
	// Unbinds DOM handlers from elements that reside outside the view container
	unbindGlobalHandlers: function() {
		$(document).off('mousedown', this.documentMousedownProxy);
	},
</P><P>
	// Initializes internal variables related to theming
	initThemingProps: function() {
		var tm = this.opt('theme') ? 'ui' : 'fc';
</P><P>		this.widgetHeaderClass = tm + '-widget-header';
		this.widgetContentClass = tm + '-widget-content';
		this.highlightStateClass = tm + '-state-highlight';
	},
</P><P>
	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Refreshes anything dependant upon sizing of the container element of the grid
	updateSize: function(isResize) {
		var scrollState;
</P><P>		if (isResize) {
			scrollState = this.queryScroll();
		}
</P><P>		this.updateHeight(isResize);
		this.updateWidth(isResize);
</P><P>		if (isResize) {
			this.setScroll(scrollState);
		}
	},
</P><P>
	// Refreshes the horizontal dimensions of the calendar
	updateWidth: function(isResize) {
		// subclasses should implement
	},
</P><P>
	// Refreshes the vertical dimensions of the calendar
	updateHeight: function(isResize) {
		var calendar = this.calendar; // we poll the calendar for height information
</P><P>		this.setHeight(
			calendar.getSuggestedViewHeight(),
			calendar.isHeightAuto()
		);
	},
</P><P>
	// Updates the vertical dimensions of the calendar to the specified height.
	// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its &quot;natural&quot; height.
	setHeight: function(height, isAuto) {
		// subclasses should implement
	},
</P><P>
	/* Scroller
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Given the total height of the view, return the number of pixels that should be used for the scroller.
	// Utility for subclasses.
	computeScrollerHeight: function(totalHeight) {
		var scrollerEl = this.scrollerEl;
		var both;
		var otherHeight; // cumulative height of everything that is not the scrollerEl in the view (header+borders)
</P><P>		both = this.el.add(scrollerEl);
</P><P>		// fuckin IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
		both.css({
			position: 'relative', // cause a reflow, which will force fresh dimension recalculation
			left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
		});
		otherHeight = this.el.outerHeight() - scrollerEl.height(); // grab the dimensions
		both.css({ position: <I>, left: </I> }); // undo hack
</P><P>		return totalHeight - otherHeight;
	},
</P><P>
	// Computes the initial pre-configured scroll state prior to allowing the user to change it.
	// Given the scroll state from the previous rendering. If first time rendering, given null.
	computeInitialScroll: function(previousScrollState) {
		return 0;
	},
</P><P>
	// Retrieves the view's current natural scroll state. Can return an arbitrary format.
	queryScroll: function() {
		if (this.scrollerEl) {
			return this.scrollerEl.scrollTop(); // operates on scrollerEl by default
		}
	},
</P><P>
	// Sets the view's scroll state. Will accept the same format computeInitialScroll and queryScroll produce.
	setScroll: function(scrollState) {
		if (this.scrollerEl) {
			return this.scrollerEl.scrollTop(scrollState); // operates on scrollerEl by default
		}
	},
</P><P>
	// Sets the scroll state, making sure to overcome any predefined scroll value the browser has in mind
	forceScroll: function(scrollState) {
		var _this = this;
</P><P>		this.setScroll(scrollState);
		setTimeout(function() {
			_this.setScroll(scrollState);
		}, 0);
	},
</P><P>/* Event Elements / Segments
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Does everything necessary to display the given events onto the current view
	displayEvents: function(events) {
		var scrollState = this.queryScroll();
</P><P>		this.clearEvents();
		this.renderEvents(events);
		this.isEventsRendered = true;
		this.setScroll(scrollState);
		this.triggerEventRender();
	},
</P><P>
	// Does everything necessary to clear the view's currently-rendered events
	clearEvents: function() {
		if (this.isEventsRendered) {
			this.triggerEventUnrender();
			if (this.destroyEvents) {
				this.destroyEvents(); // TODO: deprecate
			}
			this.unrenderEvents();
			this.isEventsRendered = false;
		}
	},
</P><P>
	// Renders the events onto the view.
	renderEvents: function(events) {
		// subclasses should implement
	},
</P><P>
	// Removes event elements from the view.
	unrenderEvents: function() {
		// subclasses should implement
	},
</P><P>
	// Signals that all events have been rendered
	triggerEventRender: function() {
		this.renderedEventSegEach(function(seg) {
			this.trigger('eventAfterRender', seg.event, seg.event, seg.el);
		});
		this.trigger('eventAfterAllRender');
	},
</P><P>
	// Signals that all event elements are about to be removed
	triggerEventUnrender: function() {
		this.renderedEventSegEach(function(seg) {
			this.trigger('eventDestroy', seg.event, seg.event, seg.el);
		});
	},
</P><P>
	// Given an event and the default element used for rendering, returns the element that should actually be used.
	// Basically runs events and elements through the eventRender hook.
	resolveEventEl: function(event, el) {
		var custom = this.trigger('eventRender', event, event, el);
</P><P>		if (custom === false) { // means don't render at all
			el = null;
		}
		else if (custom &amp;&amp; custom !== true) {
			el = $(custom);
		}
</P><P>		return el;
	},
</P><P>
	// Hides all rendered event segments linked to the given event
	showEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', <I>);</I>
		}, event);
	},
</P><P>
	// Shows all rendered event segments linked to the given event
	hideEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', 'hidden');
		}, event);
	},
</P><P>
	// Iterates through event segments that have been rendered (have an el). Goes through all by default.
	// If the optional `event` argument is specified, only iterates through segments linked to that event.
	// The `this` value of the callback function will be the view.
	renderedEventSegEach: function(func, event) {
		var segs = this.getEventSegs();
		var i;
</P><P>		for (i = 0; i &lt; segs.length; i++) {
			if (!event || segs[i].event._id === event._id) {
				if (segs[i].el) {
					func.call(this, segs[i]);
				}
			}
		}
	},
</P><P>
	// Retrieves all the rendered segment objects for the view
	getEventSegs: function() {
		// subclasses must implement
		return [];
	},
</P><P>
	/* Event Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Computes if the given event is allowed to be dragged by the user
	isEventDraggable: function(event) {
		var source = event.source || {};
</P><P>		return firstDefined(
			event.startEditable,
			source.startEditable,
			this.opt('eventStartEditable'),
			event.editable,
			source.editable,
			this.opt('editable')
		);
	},
</P><P>
	// Must be called when an event in the view is dropped onto new location.
	// `dropLocation` is an object that contains the new start/end/allDay values for the event.
	reportEventDrop: function(event, dropLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateEvent(event, dropLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};
</P><P>		this.triggerEventDrop(event, mutateResult.dateDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},
</P><P>
	// Triggers event-drop handlers that have subscribed via the API
	triggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {
		this.trigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy
	},
</P><P>
	/* External Element Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
	// `meta` is the parsed data that has been embedded into the dragging event.
	// `dropLocation` is an object that contains the new start/end/allDay values for the event.
	reportExternalDrop: function(meta, dropLocation, el, ev, ui) {
		var eventProps = meta.eventProps;
		var eventInput;
		var event;
</P><P>		// Try to build an event object and render it. TODO: decouple the two
		if (eventProps) {
			eventInput = $.extend({}, eventProps, dropLocation);
			event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array
		}
</P><P>		this.triggerExternalDrop(event, dropLocation, el, ev, ui);
	},
</P><P>
	// Triggers external-drop handlers that have subscribed via the API
	triggerExternalDrop: function(event, dropLocation, el, ev, ui) {
</P><P>		// trigger 'drop' regardless of whether element represents an event
		this.trigger('drop', el[0], dropLocation.start, ev, ui);
</P><P>		if (event) {
			this.trigger('eventReceive', null, event); // signal an external event landed
		}
	},
</P><P>
	/* Drag-n-Drop Rendering (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a visual indication of a event or external-element drag over the given drop zone.
	// If an external-element, seg will be `null`
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},
</P><P>
	// Unrenders a visual indication of an event or external-element being dragged.
	unrenderDrag: function() {
		// subclasses must implement
	},
</P><P>
	/* Event Resizing
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Computes if the given event is allowed to be resized from its starting edge
	isEventResizableFromStart: function(event) {
		return this.opt('eventResizableFromStart') &amp;&amp; this.isEventResizable(event);
	},
</P><P>
	// Computes if the given event is allowed to be resized from its ending edge
	isEventResizableFromEnd: function(event) {
		return this.isEventResizable(event);
	},
</P><P>
	// Computes if the given event is allowed to be resized by the user at all
	isEventResizable: function(event) {
		var source = event.source || {};
</P><P>		return firstDefined(
			event.durationEditable,
			source.durationEditable,
			this.opt('eventDurationEditable'),
			event.editable,
			source.editable,
			this.opt('editable')
		);
	},
</P><P>
	// Must be called when an event in the view has been resized to a new length
	reportEventResize: function(event, resizeLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateEvent(event, resizeLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};
</P><P>		this.triggerEventResize(event, mutateResult.durationDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},
</P><P>
	// Triggers event-resize handlers that have subscribed via the API
	triggerEventResize: function(event, durationDelta, undoFunc, el, ev) {
		this.trigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy
	},
</P><P>
	/* Selection
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Selects a date range on the view. `start` and `end` are both Moments.
	// `ev` is the native mouse event that begin the interaction.
	select: function(range, ev) {
		this.unselect(ev);
		this.renderSelection(range);
		this.reportSelection(range, ev);
	},
</P><P>
	// Renders a visual indication of the selection
	renderSelection: function(range) {
		// subclasses should implement
	},
</P><P>
	// Called when a new selection is made. Updates internal state and triggers handlers.
	reportSelection: function(range, ev) {
		this.isSelected = true;
		this.triggerSelect(range, ev);
	},
</P><P>
	// Triggers handlers to 'select'
	triggerSelect: function(range, ev) {
		this.trigger('select', null, range.start, range.end, ev);
	},
</P><P>
	// Undoes a selection. updates in the internal state and triggers handlers.
	// `ev` is the native mouse event that began the interaction.
	unselect: function(ev) {
		if (this.isSelected) {
			this.isSelected = false;
			if (this.destroySelection) {
				this.destroySelection(); // TODO: deprecate
			}
			this.unrenderSelection();
			this.trigger('unselect', null, ev);
		}
	},
</P><P>
	// Unrenders a visual indication of selection
	unrenderSelection: function() {
		// subclasses should implement
	},
</P><P>
	// Handler for unselecting when the user clicks something and the 'unselectAuto' setting is on
	documentMousedown: function(ev) {
		var ignore;
</P><P>		// is there a selection, and has the user made a proper left click?
		if (this.isSelected &amp;&amp; this.opt('unselectAuto') &amp;&amp; isPrimaryMouseButton(ev)) {
</P><P>			// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
			ignore = this.opt('unselectCancel');
			if (!ignore || !$(ev.target).closest(ignore).length) {
				this.unselect(ev);
			}
		}
	},
</P><P>
	/* Day Click
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Triggers handlers to 'dayClick'
	triggerDayClick: function(cell, dayEl, ev) {
		this.trigger('dayClick', dayEl, cell.start, ev);
	},
</P><P>
	/* Date Utils
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Initializes internal variables related to calculating hidden days-of-week
	initHiddenDays: function() {
		var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
		var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -&gt; bool)
		var dayCnt = 0;
		var i;
</P><P>		if (this.opt('weekends') === false) {
			hiddenDays.push(0, 6); // 0=sunday, 6=saturday
		}
</P><P>		for (i = 0; i &lt; 7; i++) {
			if (
				!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)
			) {
				dayCnt++;
			}
		}
</P><P>		if (!dayCnt) {
			throw 'invalid hiddenDays'; // all days were hidden? bad.
		}
</P><P>		this.isHiddenDayHash = isHiddenDayHash;
	},
</P><P>
	// Is the current day hidden?
	// `day` is a day-of-week index (0-6), or a Moment
	isHiddenDay: function(day) {
		if (moment.isMoment(day)) {
			day = day.day();
		}
		return this.isHiddenDayHash[day];
	},
</P><P>
	// Incrementing the current day until it is no longer a hidden day, returning a copy.
	// If the initial value of `date` is not a hidden day, don't do anything.
	// Pass `isExclusive` as `true` if you are dealing with an end date.
	// `inc` defaults to `1` (increment one day forward each time)
	skipHiddenDays: function(date, inc, isExclusive) {
		var out = date.clone();
		inc = inc || 1;
		while (
			this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]
		) {
			out.add(inc, 'days');
		}
		return out;
	},
</P><P>
	// Returns the date range of the full days the given range visually appears to occupy.
	// Returns a new range object.
	computeDayRange: function(range) {
		var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts
		var end = range.end;
		var endDay = null;
		var endTimeMS;
</P><P>		if (end) {
			endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
			endTimeMS = +end.time(); // # of milliseconds into `endDay`
</P><P>			// If the end time is actually inclusively part of the next day and is equal to or
			// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
			// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
			if (endTimeMS &amp;&amp; endTimeMS &gt;= this.nextDayThreshold) {
				endDay.add(1, 'days');
			}
		}
</P><P>		// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
		// assign the default duration of one day.
		if (!end || endDay &lt;= startDay) {
			endDay = startDay.clone().add(1, 'days');
		}
</P><P>		return { start: startDay, end: endDay };
	},
</P><P>
	// Does the given event visually appear to occupy more than one day?
	isMultiDayEvent: function(event) {
		var range = this.computeDayRange(event); // event is range-ish
</P><P>		return range.end.diff(range.start, 'days') &gt; 1;
	}
</P><P>});
</P><P>var Calendar = fc.Calendar = Class.extend({
</P><P>	dirDefaults: null, // option defaults related to LTR or RTL
	langDefaults: null, // option defaults related to current locale
	overrides: null, // option overrides given to the fullCalendar constructor
	options: null, // all defaults combined with overrides
	viewSpecCache: null, // cache of view definitions
	view: null, // current View object
	header: null,
	loadingLevel: 0, // number of simultaneous loading tasks
</P><P>
	// a lot of this class' OOP logic is scoped within this constructor function,
	// but in the future, write individual methods on the prototype.
	constructor: Calendar_constructor,
</P><P>
	// Subclasses can override this for initialization logic after the constructor has been called
	initialize: function() {
	},
</P><P>
	// Initializes `this.options` and other important options-related objects
	initOptions: function(overrides) {
		var lang, langDefaults;
		var isRTL, dirDefaults;
</P><P>		// converts legacy options into non-legacy ones.
		// in the future, when this is removed, don't use `overrides` reference. make a copy.
		overrides = massageOverrides(overrides);
</P><P>		lang = overrides.lang;
		langDefaults = langOptionHash[lang];
		if (!langDefaults) {
			lang = Calendar.defaults.lang;
			langDefaults = langOptionHash[lang] || {};
		}
</P><P>		isRTL = firstDefined(
			overrides.isRTL,
			langDefaults.isRTL,
			Calendar.defaults.isRTL
		);
		dirDefaults = isRTL ? Calendar.rtlDefaults : {};
</P><P>		this.dirDefaults = dirDefaults;
		this.langDefaults = langDefaults;
		this.overrides = overrides;
		this.options = mergeOptions([ // merge defaults and overrides. lowest to highest precedence
			Calendar.defaults, // global defaults
			dirDefaults,
			langDefaults,
			overrides
		]);
		populateInstanceComputableOptions(this.options);
</P><P>		this.viewSpecCache = {}; // somewhat unrelated
	},
</P><P>
	// Gets information about how to create a view. Will use a cache.
	getViewSpec: function(viewType) {
		var cache = this.viewSpecCache;
</P><P>		return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
	},
</P><P>
	// Given a duration singular unit, like &quot;week&quot; or &quot;day&quot;, finds a matching view spec.
	// Preference is given to views that have corresponding buttons.
	getUnitViewSpec: function(unit) {
		var viewTypes;
		var i;
		var spec;
</P><P>		if ($.inArray(unit, intervalUnits) != -1) {
</P><P>			// put views that have buttons first. there will be duplicates, but oh well
			viewTypes = this.header.getViewsWithButtons();
			$.each(fc.views, function(viewType) { // all views
				viewTypes.push(viewType);
			});
</P><P>			for (i = 0; i &lt; viewTypes.length; i++) {
				spec = this.getViewSpec(viewTypes[i]);
				if (spec) {
					if (spec.singleUnit == unit) {
						return spec;
					}
				}
			}
		}
	},
</P><P>
	// Builds an object with information on how to create a given view
	buildViewSpec: function(requestedViewType) {
		var viewOverrides = this.overrides.views || {};
		var specChain = []; // for the view. lowest to highest priority
		var defaultsChain = []; // for the view. lowest to highest priority
		var overridesChain = []; // for the view. lowest to highest priority
		var viewType = requestedViewType;
		var spec; // for the view
		var overrides; // for the view
		var duration;
		var unit;
</P><P>		// iterate from the specific view definition to a more general one until we hit an actual View class
		while (viewType) {
			spec = fcViews[viewType];
			overrides = viewOverrides[viewType];
			viewType = null; // clear. might repopulate for another iteration
</P><P>			if (typeof spec === 'function') { // TODO: deprecate
				spec = { 'class': spec };
			}
</P><P>			if (spec) {
				specChain.unshift(spec);
				defaultsChain.unshift(spec.defaults || {});
				duration = duration || spec.duration;
				viewType = viewType || spec.type;
			}
</P><P>			if (overrides) {
				overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
				duration = duration || overrides.duration;
				viewType = viewType || overrides.type;
			}
		}
</P><P>		spec = mergeProps(specChain);
		spec.type = requestedViewType;
		if (!spec['class']) {
			return false;
		}
</P><P>		if (duration) {
			duration = moment.duration(duration);
			if (duration.valueOf()) { // valid?
				spec.duration = duration;
				unit = computeIntervalUnit(duration);
</P><P>				// view is a single-unit duration, like &quot;week&quot; or &quot;day&quot;
				// incorporate options for this. lowest priority
				if (duration.as(unit) === 1) {
					spec.singleUnit = unit;
					overridesChain.unshift(viewOverrides[unit] || {});
				}
			}
		}
</P><P>		spec.defaults = mergeOptions(defaultsChain);
		spec.overrides = mergeOptions(overridesChain);
</P><P>		this.buildViewSpecOptions(spec);
		this.buildViewSpecButtonText(spec, requestedViewType);
</P><P>		return spec;
	},
</P><P>
	// Builds and assigns a view spec's options object from its already-assigned defaults and overrides
	buildViewSpecOptions: function(spec) {
		spec.options = mergeOptions([ // lowest to highest priority
			Calendar.defaults, // global defaults
			spec.defaults, // view's defaults (from ViewSubclass.defaults)
			this.dirDefaults,
			this.langDefaults, // locale and dir take precedence over view's defaults!
			this.overrides, // calendar's overrides (options given to constructor)
			spec.overrides // view's overrides (view-specific options)
		]);
		populateInstanceComputableOptions(spec.options);
	},
</P><P>
	// Computes and assigns a view spec's buttonText-related options
	buildViewSpecButtonText: function(spec, requestedViewType) {
</P><P>		// given an options object with a possible `buttonText` hash, lookup the buttonText for the
		// requested view, falling back to a generic unit entry like &quot;week&quot; or &quot;day&quot;
		function queryButtonText(options) {
			var buttonText = options.buttonText || {};
			return buttonText[requestedViewType] ||
				(spec.singleUnit ? buttonText[spec.singleUnit] : null);
		}
</P><P>		// highest to lowest priority
		spec.buttonTextOverride =
			queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence
			spec.overrides.buttonText; // `buttonText` for view-specific options is a string
</P><P>		// highest to lowest priority. mirrors buildViewSpecOptions
		spec.buttonTextDefault =
			queryButtonText(this.langDefaults) ||
			queryButtonText(this.dirDefaults) ||
			spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
			queryButtonText(Calendar.defaults) ||
			(spec.duration ? this.humanizeDuration(spec.duration) : null) || // like &quot;3 days&quot;
			requestedViewType; // fall back to given view name
	},
</P><P>
	// Given a view name for a custom view or a standard view, creates a ready-to-go View object
	instantiateView: function(viewType) {
		var spec = this.getViewSpec(viewType);
</P><P>		return new spec['class'](this, viewType, spec.options, spec.duration);
	},
</P><P>
	// Returns a boolean about whether the view is okay to instantiate at some point
	isValidViewType: function(viewType) {
		return Boolean(this.getViewSpec(viewType));
	},
</P><P>
	// Should be called when any type of async data fetching begins
	pushLoading: function() {
		if (!(this.loadingLevel++)) {
			this.trigger('loading', null, true, this.view);
		}
	},
</P><P>
	// Should be called when any type of async data fetching completes
	popLoading: function() {
		if (!(--this.loadingLevel)) {
			this.trigger('loading', null, false, this.view);
		}
	},
</P><P>
	// Given arguments to the select method in the API, returns a range
	buildSelectRange: function(start, end) {
</P><P>		start = this.moment(start);
		if (end) {
			end = this.moment(end);
		}
		else if (start.hasTime()) {
			end = start.clone().add(this.defaultTimedEventDuration);
		}
		else {
			end = start.clone().add(this.defaultAllDayEventDuration);
		}
</P><P>		return { start: start, end: end };
	}
</P><P>});
</P><P>
function Calendar_constructor(element, overrides) {
	var t = this;
</P><P>
	t.initOptions(overrides || {});
	var options = this.options;
</P><P>	
	// Exports
	// -----------------------------------------------------------------------------------
</P><P>	t.render = render;
	t.destroy = destroy;
	t.refetchEvents = refetchEvents;
	t.reportEvents = reportEvents;
	t.reportEventChange = reportEventChange;
	t.rerenderEvents = renderEvents; // `renderEvents` serves as a rerender. an API method
	t.changeView = renderView; // `renderView` will switch to another view
	t.select = select;
	t.unselect = unselect;
	t.prev = prev;
	t.next = next;
	t.prevYear = prevYear;
	t.nextYear = nextYear;
	t.today = today;
	t.gotoDate = gotoDate;
	t.incrementDate = incrementDate;
	t.zoomTo = zoomTo;
	t.getDate = getDate;
	t.getCalendar = getCalendar;
	t.getView = getView;
	t.option = option;
	t.trigger = trigger;
</P><P>	// Language-data Internals
	// -----------------------------------------------------------------------------------
	// Apply overrides to the current language's data
</P><P>
	var localeData = createObject( // make a cheap copy
		getMomentLocaleData(options.lang) // will fall back to en
	);
</P><P>	if (options.monthNames) {
		localeData._months = options.monthNames;
	}
	if (options.monthNamesShort) {
		localeData._monthsShort = options.monthNamesShort;
	}
	if (options.dayNames) {
		localeData._weekdays = options.dayNames;
	}
	if (options.dayNamesShort) {
		localeData._weekdaysShort = options.dayNamesShort;
	}
	if (options.firstDay != null) {
		var _week = createObject(localeData._week); // _week: { dow: # }
		_week.dow = options.firstDay;
		localeData._week = _week;
	}
</P><P>	// assign a normalized value, to be used by our .week() moment extension
	localeData._fullCalendar_weekCalc = (function(weekCalc) {
		if (typeof weekCalc === 'function') {
			return weekCalc;
		}
		else if (weekCalc === 'local') {
			return weekCalc;
		}
		else if (weekCalc === 'iso' || weekCalc === 'ISO') {
			return 'ISO';
		}
	})(options.weekNumberCalculation);
</P><P>	// Calendar-specific Date Utilities
	// -----------------------------------------------------------------------------------
</P><P>
	t.defaultAllDayEventDuration = moment.duration(options.defaultAllDayEventDuration);
	t.defaultTimedEventDuration = moment.duration(options.defaultTimedEventDuration);
</P><P>
	// Builds a moment using the settings of the current calendar: timezone and language.
	// Accepts anything the vanilla moment() constructor accepts.
	t.moment = function() {
		var mom;
</P><P>		if (options.timezone === 'local') {
			mom = fc.moment.apply(null, arguments);
</P><P>			// Force the moment to be local, because fc.moment doesn't guarantee it.
			if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone
				mom.local();
			}
		}
		else if (options.timezone === 'UTC') {
			mom = fc.moment.utc.apply(null, arguments); // process as UTC
		}
		else {
			mom = fc.moment.parseZone.apply(null, arguments); // let the input decide the zone
		}
</P><P>		if ('_locale' in mom) { // moment 2.8 and above
			mom._locale = localeData;
		}
		else { // pre-moment-2.8
			mom._lang = localeData;
		}
</P><P>		return mom;
	};
</P><P>
	// Returns a boolean about whether or not the calendar knows how to calculate
	// the timezone offset of arbitrary dates in the current timezone.
	t.getIsAmbigTimezone = function() {
		return options.timezone !== 'local' &amp;&amp; options.timezone !== 'UTC';
	};
</P><P>
	// Returns a copy of the given date in the current timezone of it is ambiguously zoned.
	// This will also give the date an unambiguous time.
	t.rezoneDate = function(date) {
		return t.moment(date.toArray());
	};
</P><P>
	// Returns a moment for the current date, as defined by the client's computer,
	// or overridden by the `now` option.
	t.getNow = function() {
		var now = options.now;
		if (typeof now === 'function') {
			now = now();
		}
		return t.moment(now);
	};
</P><P>
	// Get an event's normalized end date. If not present, calculate it from the defaults.
	t.getEventEnd = function(event) {
		if (event.end) {
			return event.end.clone();
		}
		else {
			return t.getDefaultEventEnd(event.allDay, event.start);
		}
	};
</P><P>
	// Given an event's allDay status and start date, return swhat its fallback end date should be.
	t.getDefaultEventEnd = function(allDay, start) { // TODO: rename to computeDefaultEventEnd
		var end = start.clone();
</P><P>		if (allDay) {
			end.stripTime().add(t.defaultAllDayEventDuration);
		}
		else {
			end.add(t.defaultTimedEventDuration);
		}
</P><P>		if (t.getIsAmbigTimezone()) {
			end.stripZone(); // we don't know what the tzo should be
		}
</P><P>		return end;
	};
</P><P>
	// Produces a human-readable string for the given duration.
	// Side-effect: changes the locale of the given duration.
	t.humanizeDuration = function(duration) {
		return (duration.locale || duration.lang).call(duration, options.lang) // works moment-pre-2.8
			.humanize();
	};
</P><P>	// Imports
	// -----------------------------------------------------------------------------------
</P><P>
	EventManager.call(t, options);
	var isFetchNeeded = t.isFetchNeeded;
	var fetchEvents = t.fetchEvents;
</P><P>	// Locals
	// -----------------------------------------------------------------------------------
</P><P>
	var _element = element[0];
	var header;
	var headerElement;
	var content;
	var tm; // for making theme classes
	var currentView; // NOTE: keep this in sync with this.view
	var viewsByType = {}; // holds all instantiated view instances, current or not
	var suggestedViewHeight;
	var windowResizeProxy; // wraps the windowResize function
	var ignoreWindowResize = 0;
	var date;
	var events = [];
</P><P>	// Main Rendering
	// -----------------------------------------------------------------------------------
</P><P>
	if (options.defaultDate != null) {
		date = t.moment(options.defaultDate);
	}
	else {
		date = t.getNow();
	}
</P><P>	
	function render() {
		if (!content) {
			initialRender();
		}
		else if (elementVisible()) {
			// mainly for the public API
			calcSize();
			renderView();
		}
	}
</P><P>	
	function initialRender() {
		tm = options.theme ? 'ui' : 'fc';
		element.addClass('fc');
</P><P>		if (options.isRTL) {
			element.addClass('fc-rtl');
		}
		else {
			element.addClass('fc-ltr');
		}
</P><P>		if (options.theme) {
			element.addClass('ui-widget');
		}
		else {
			element.addClass('fc-unthemed');
		}
</P><P>		content = $(&quot;&lt;div class='fc-view-container'/&gt;&quot;).prependTo(element);
</P><P>		header = t.header = new Header(t, options);
		headerElement = header.render();
		if (headerElement) {
			element.prepend(headerElement);
		}
</P><P>		renderView(options.defaultView);
</P><P>		if (options.handleWindowResize) {
			windowResizeProxy = debounce(windowResize, options.windowResizeDelay); // prevents rapid calls
			$(window).resize(windowResizeProxy);
		}
	}
</P><P>	
	function destroy() {
</P><P>		if (currentView) {
			currentView.removeElement();
</P><P>			// NOTE: don't null-out currentView/t.view in case API methods are called after destroy.
			// It is still the &quot;current&quot; view, just not rendered.
		}
</P><P>		header.removeElement();
		content.remove();
		element.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');
</P><P>		if (windowResizeProxy) {
			$(window).unbind('resize', windowResizeProxy);
		}
	}
</P><P>	
	function elementVisible() {
		return element.is(':visible');
	}
</P><P>	// View Rendering
	// -----------------------------------------------------------------------------------
</P><P>
	// Renders a view because of a date change, view-type change, or for the first time.
	// If not given a viewType, keep the current view but render different dates.
	function renderView(viewType) {
		ignoreWindowResize++;
</P><P>		// if viewType is changing, remove the old view's rendering
		if (currentView &amp;&amp; viewType &amp;&amp; currentView.type !== viewType) {
			header.deactivateButton(currentView.type);
			freezeContentHeight(); // prevent a scroll jump when view element is removed
			currentView.removeElement();
			currentView = t.view = null;
		}
</P><P>		// if viewType changed, or the view was never created, create a fresh view
		if (!currentView &amp;&amp; viewType) {
			currentView = t.view =
				viewsByType[viewType] ||
				(viewsByType[viewType] = t.instantiateView(viewType));
</P><P>			currentView.setElement(
				$(&quot;&lt;div class='fc-view fc-&quot; + viewType + &quot;-view' /&gt;&quot;).appendTo(content)
			);
			header.activateButton(viewType);
		}
</P><P>		if (currentView) {
</P><P>			// in case the view should render a period of time that is completely hidden
			date = currentView.massageCurrentDate(date);
</P><P>			// render or rerender the view
			if (
				!currentView.displaying ||
				!date.isWithin(currentView.intervalStart, currentView.intervalEnd) // implicit date window change
			) {
				if (elementVisible()) {
</P><P>					freezeContentHeight();
					currentView.display(date);
					unfreezeContentHeight(); // immediately unfreeze regardless of whether display is async
</P><P>					// need to do this after View::render, so dates are calculated
					updateHeaderTitle();
					updateTodayButton();
</P><P>					getAndRenderEvents();
				}
			}
		}
</P><P>		unfreezeContentHeight(); // undo any lone freezeContentHeight calls
		ignoreWindowResize--;
	}
</P><P>	// Resizing
	// -----------------------------------------------------------------------------------
</P><P>
	t.getSuggestedViewHeight = function() {
		if (suggestedViewHeight === undefined) {
			calcSize();
		}
		return suggestedViewHeight;
	};
</P><P>
	t.isHeightAuto = function() {
		return options.contentHeight === 'auto' || options.height === 'auto';
	};
</P><P>	
	function updateSize(shouldRecalc) {
		if (elementVisible()) {
</P><P>			if (shouldRecalc) {
				_calcSize();
			}
</P><P>			ignoreWindowResize++;
			currentView.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
			ignoreWindowResize--;
</P><P>			return true; // signal success
		}
	}
</P><P>
	function calcSize() {
		if (elementVisible()) {
			_calcSize();
		}
	}
</P><P>	
	function _calcSize() { // assumes elementVisible
		if (typeof options.contentHeight === 'number') { // exists and not 'auto'
			suggestedViewHeight = options.contentHeight;
		}
		else if (typeof options.height === 'number') { // exists and not 'auto'
			suggestedViewHeight = options.height - (headerElement ? headerElement.outerHeight(true) : 0);
		}
		else {
			suggestedViewHeight = Math.round(content.width() / Math.max(options.aspectRatio, .5));
		}
	}
</P><P>	
	function windowResize(ev) {
		if (
			!ignoreWindowResize &amp;&amp;
			ev.target === window &amp;&amp; // so we don't process jqui &quot;resize&quot; events that have bubbled up
			currentView.start // view has already been rendered
		) {
			if (updateSize(true)) {
				currentView.trigger('windowResize', _element);
			}
		}
	}
</P><P>	/* Event Fetching/Rendering
	-----------------------------------------------------------------------------*/
	// TODO: going forward, most of this stuff should be directly handled by the view
</P><P>
	function refetchEvents() { // can be called as an API method
		destroyEvents(); // so that events are cleared before user starts waiting for AJAX
		fetchAndRenderEvents();
	}
</P><P>
	function renderEvents() { // destroys old events if previously rendered
		if (elementVisible()) {
			freezeContentHeight();
			currentView.displayEvents(events);
			unfreezeContentHeight();
		}
	}
</P><P>
	function destroyEvents() {
		freezeContentHeight();
		currentView.clearEvents();
		unfreezeContentHeight();
	}
</P><P>
	function getAndRenderEvents() {
		if (!options.lazyFetching || isFetchNeeded(currentView.start, currentView.end)) {
			fetchAndRenderEvents();
		}
		else {
			renderEvents();
		}
	}
</P><P>
	function fetchAndRenderEvents() {
		fetchEvents(currentView.start, currentView.end);
			// ... will call reportEvents
			// ... which will call renderEvents
	}
</P><P>	
	// called when event data arrives
	function reportEvents(_events) {
		events = _events;
		renderEvents();
	}
</P><P>
	// called when a single event's data has been changed
	function reportEventChange() {
		renderEvents();
	}
</P><P>	/* Header Updating
	-----------------------------------------------------------------------------*/
</P><P>
	function updateHeaderTitle() {
		header.updateTitle(currentView.title);
	}
</P><P>
	function updateTodayButton() {
		var now = t.getNow();
		if (now.isWithin(currentView.intervalStart, currentView.intervalEnd)) {
			header.disableButton('today');
		}
		else {
			header.enableButton('today');
		}
	}
</P><P>	/* Selection
	-----------------------------------------------------------------------------*/
</P><P>
	function select(start, end) {
		currentView.select(
			t.buildSelectRange.apply(t, arguments)
		);
	}
</P><P>
	function unselect() { // safe to be called before renderView
		if (currentView) {
			currentView.unselect();
		}
	}
</P><P>	/* Date
	-----------------------------------------------------------------------------*/
</P><P>	
	function prev() {
		date = currentView.computePrevDate(date);
		renderView();
	}
</P><P>	
	function next() {
		date = currentView.computeNextDate(date);
		renderView();
	}
</P><P>	
	function prevYear() {
		date.add(-1, 'years');
		renderView();
	}
</P><P>	
	function nextYear() {
		date.add(1, 'years');
		renderView();
	}
</P><P>	
	function today() {
		date = t.getNow();
		renderView();
	}
</P><P>	
	function gotoDate(dateInput) {
		date = t.moment(dateInput);
		renderView();
	}
</P><P>	
	function incrementDate(delta) {
		date.add(moment.duration(delta));
		renderView();
	}
</P><P>
	// Forces navigation to a view for the given date.
	// `viewType` can be a specific view name or a generic one like &quot;week&quot; or &quot;day&quot;.
	function zoomTo(newDate, viewType) {
		var spec;
</P><P>		viewType = viewType || 'day'; // day is default zoom
		spec = t.getViewSpec(viewType) || t.getUnitViewSpec(viewType);
</P><P>		date = newDate;
		renderView(spec ? spec.type : null);
	}
</P><P>	
	function getDate() {
		return date.clone();
	}
</P><P>	/* Height &quot;Freezing&quot;
	-----------------------------------------------------------------------------*/
	// TODO: move this into the view
</P><P>
	function freezeContentHeight() {
		content.css({
			width: '100%',
			height: content.height(),
			overflow: 'hidden'
		});
	}
</P><P>
	function unfreezeContentHeight() {
		content.css({
			width: <I>,</I>
			height: <I>,</I>
			overflow: 
		});
	}
</P><P>	/* Misc
	-----------------------------------------------------------------------------*/
</P><P>
	function getCalendar() {
		return t;
	}
</P><P>	
	function getView() {
		return currentView;
	}
</P><P>	
	function option(name, value) {
		if (value === undefined) {
			return options[name];
		}
		if (name == 'height' || name == 'contentHeight' || name == 'aspectRatio') {
			options[name] = value;
			updateSize(true); // true = allow recalculation of height
		}
	}
</P><P>	
	function trigger(name, thisObj) {
		if (options[name]) {
			return options[name].apply(
				thisObj || _element,
				Array.prototype.slice.call(arguments, 2)
			);
		}
	}
</P><P>	t.initialize();
}
</P><P>Calendar.defaults = {
</P><P>	titleRangeSeparator: ' \u2014 ', // emphasized dash
	monthYearFormat: 'MMMM YYYY', // required for en. other languages rely on datepicker computable option
</P><P>	defaultTimedEventDuration: '02:00:00',
	defaultAllDayEventDuration: { days: 1 },
	forceEventDuration: false,
	nextDayThreshold: '09:00:00', // 9am
</P><P>	// display
	defaultView: 'month',
	aspectRatio: 1.35,
	header: {
		left: 'title',
		center: <I>,</I>
		right: 'today prev,next'
	},
	weekends: true,
	weekNumbers: false,
</P><P>	weekNumberTitle: 'W',
	weekNumberCalculation: 'local',
</P><P>	//editable: false,
</P><P>	scrollTime: '06:00:00',
</P><P>	// event ajax
	lazyFetching: true,
	startParam: 'start',
	endParam: 'end',
	timezoneParam: 'timezone',
</P><P>	timezone: false,
</P><P>	//allDayDefault: undefined,
</P><P>	// locale
	isRTL: false,
	buttonText: {
		prev: &quot;prev&quot;,
		next: &quot;next&quot;,
		prevYear: &quot;prev year&quot;,
		nextYear: &quot;next year&quot;,
		year: 'year', // TODO: locale files need to specify this
		today: 'today',
		month: 'month',
		week: 'week',
		day: 'day'
	},
</P><P>	buttonIcons: {
		prev: 'left-single-arrow',
		next: 'right-single-arrow',
		prevYear: 'left-double-arrow',
		nextYear: 'right-double-arrow'
	},
</P><P>	// jquery-ui theming
	theme: false,
	themeButtonIcons: {
		prev: 'circle-triangle-w',
		next: 'circle-triangle-e',
		prevYear: 'seek-prev',
		nextYear: 'seek-next'
	},
</P><P>	//eventResizableFromStart: false,
	dragOpacity: .75,
	dragRevertDuration: 500,
	dragScroll: true,
</P><P>	//selectable: false,
	unselectAuto: true,
</P><P>	dropAccept: '*',
</P><P>	eventLimit: false,
	eventLimitText: 'more',
	eventLimitClick: 'popover',
	dayPopoverFormat: 'LL',
</P><P>	handleWindowResize: true,
	windowResizeDelay: 200 // milliseconds before an updateSize happens
</P><P>};
</P><P>
Calendar.englishDefaults = { // used by lang.js
	dayPopoverFormat: 'dddd, MMMM D'
};
</P><P>
Calendar.rtlDefaults = { // right-to-left defaults
	header: { // TODO: smarter solution (first/center/last ?)
		left: 'next,prev today',
		center: <I>,</I>
		right: 'title'
	},
	buttonIcons: {
		prev: 'right-single-arrow',
		next: 'left-single-arrow',
		prevYear: 'right-double-arrow',
		nextYear: 'left-double-arrow'
	},
	themeButtonIcons: {
		prev: 'circle-triangle-e',
		next: 'circle-triangle-w',
		nextYear: 'seek-prev',
		prevYear: 'seek-next'
	}
};
</P><P>var langOptionHash = fc.langs = {}; // initialize and expose
</P><P>
// TODO: document the structure and ordering of a FullCalendar lang file
// TODO: rename everything &quot;lang&quot; to &quot;locale&quot;, like what the moment project did
</P><P>
// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default language for datepicker.
fc.datepickerLang = function(langCode, dpLangCode, dpOptions) {
</P><P>	// get the FullCalendar internal option hash for this language. create if necessary
	var fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {});
</P><P>	// transfer some simple options from datepicker to fc
	fcOptions.isRTL = dpOptions.isRTL;
	fcOptions.weekNumberTitle = dpOptions.weekHeader;
</P><P>	// compute some more complex options from datepicker
	$.each(dpComputableOptions, function(name, func) {
		fcOptions[name] = func(dpOptions);
	});
</P><P>	// is jQuery UI Datepicker is on the page?
	if ($.datepicker) {
</P><P>		// Register the language data.
		// FullCalendar and MomentJS use language codes like &quot;pt-br&quot; but Datepicker
		// does it like &quot;pt-BR&quot; or if it doesn't have the language, maybe just &quot;pt&quot;.
		// Make an alias so the language can be referenced either way.
		$.datepicker.regional[dpLangCode] =
			$.datepicker.regional[langCode] = // alias
				dpOptions;
</P><P>		// Alias 'en' to the default language data. Do this every time.
		$.datepicker.regional.en = $.datepicker.regional[<I>];</I></P><P>		// Set as Datepicker's global defaults.
		$.datepicker.setDefaults(dpOptions);
	}
};
</P><P>
// Sets FullCalendar-specific translations. Will set the language as the global default.
fc.lang = function(langCode, newFcOptions) {
	var fcOptions;
	var momOptions;
</P><P>	// get the FullCalendar internal option hash for this language. create if necessary
	fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {});
</P><P>	// provided new options for this language? merge them in
	if (newFcOptions) {
		fcOptions = langOptionHash[langCode] = mergeOptions([ fcOptions, newFcOptions ]);
	}
</P><P>	// compute language options that weren't defined.
	// always do this. newFcOptions can be undefined when initializing from i18n file,
	// so no way to tell if this is an initialization or a default-setting.
	momOptions = getMomentLocaleData(langCode); // will fall back to en
	$.each(momComputableOptions, function(name, func) {
		if (fcOptions[name] == null) {
			fcOptions[name] = func(momOptions, fcOptions);
		}
	});
</P><P>	// set it as the default language for FullCalendar
	Calendar.defaults.lang = langCode;
};
</P><P>
// NOTE: can't guarantee any of these computations will run because not every language has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {
</P><P>	buttonText: function(dpOptions) {
		return {
			// the translations sometimes wrongly contain HTML entities
			prev: stripHtmlEntities(dpOptions.prevText),
			next: stripHtmlEntities(dpOptions.nextText),
			today: stripHtmlEntities(dpOptions.currentText)
		};
	},
</P><P>	// Produces format strings like &quot;MMMM YYYY&quot; -&gt; &quot;September 2014&quot;
	monthYearFormat: function(dpOptions) {
		return dpOptions.showMonthAfterYear ?
			'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
			'MMMM YYYY[' + dpOptions.yearSuffix + ']';
	}
</P><P>};
</P><P>var momComputableOptions = {
</P><P>	// Produces format strings like &quot;ddd M/D&quot; -&gt; &quot;Fri 9/15&quot;
	dayOfMonthFormat: function(momOptions, fcOptions) {
		var format = momOptions.longDateFormat('l'); // for the format like &quot;M/D/YYYY&quot;
</P><P>		// strip the year off the edge, as well as other misc non-whitespace chars
		format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, <I>);</I></P><P>		if (fcOptions.isRTL) {
			format += ' ddd'; // for RTL, add day-of-week to end
		}
		else {
			format = 'ddd ' + format; // for LTR, add day-of-week to beginning
		}
		return format;
	},
</P><P>	// Produces format strings like &quot;h:mma&quot; -&gt; &quot;6:00pm&quot;
	mediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},
</P><P>	// Produces format strings like &quot;h(:mm)a&quot; -&gt; &quot;6pm&quot; / &quot;6:30pm&quot;
	smallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign langs
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},
</P><P>	// Produces format strings like &quot;h(:mm)t&quot; -&gt; &quot;6p&quot; / &quot;6:30p&quot;
	extraSmallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign langs
			.replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
	},
</P><P>	// Produces format strings like &quot;ha&quot; / &quot;H&quot; -&gt; &quot;6pm&quot; / &quot;18&quot;
	hourFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', <I>)</I>
			.replace(/(\Wmm)$/, <I>) // like above, but for foreign langs</I>
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},
</P><P>	// Produces format strings like &quot;h:mm&quot; -&gt; &quot;6:30&quot; (with no AM/PM)
	noMeridiemTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, <I>); // remove trailing AM/PM</I>
	}
</P><P>};
</P><P>
// options that should be computed off live calendar options (considers override options)
var instanceComputableOptions = { // TODO: best place for this? related to lang?
</P><P>	// Produces format strings for results like &quot;Mo 16&quot;
	smallDayDateFormat: function(options) {
		return options.isRTL ?
			'D dd' :
			'dd D';
	},
</P><P>	// Produces format strings for results like &quot;Wk 5&quot;
	weekFormat: function(options) {
		return options.isRTL ?
			'w[ ' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ' ]w';
	},
</P><P>	// Produces format strings for results like &quot;Wk5&quot;
	smallWeekFormat: function(options) {
		return options.isRTL ?
			'w[' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ']w';
	}
</P><P>};
</P><P>function populateInstanceComputableOptions(options) {
	$.each(instanceComputableOptions, function(name, func) {
		if (options[name] == null) {
			options[name] = func(options);
		}
	});
}
</P><P>
// Returns moment's internal locale data. If doesn't exist, returns English.
// Works with moment-pre-2.8
function getMomentLocaleData(langCode) {
	var func = moment.localeData || moment.langData;
	return func.call(moment, langCode) ||
		func.call(moment, 'en'); // the newer localData could return null, so fall back to en
}
</P><P>
// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
fc.lang('en', Calendar.englishDefaults);
</P><P>/* Top toolbar area with buttons and title
</P>*/
<P>// TODO: rename all header-related things to &quot;toolbar&quot;
</P><P>function Header(calendar, options) {
	var t = this;
</P><P>	// exports
	t.render = render;
	t.removeElement = removeElement;
	t.updateTitle = updateTitle;
	t.activateButton = activateButton;
	t.deactivateButton = deactivateButton;
	t.disableButton = disableButton;
	t.enableButton = enableButton;
	t.getViewsWithButtons = getViewsWithButtons;
</P><P>	// locals
	var el = $();
	var viewsWithButtons = [];
	var tm;
</P><P>
	function render() {
		var sections = options.header;
</P><P>		tm = options.theme ? 'ui' : 'fc';
</P><P>		if (sections) {
			el = $(&quot;&lt;div class='fc-toolbar'/&gt;&quot;)
				.append(renderSection('left'))
				.append(renderSection('right'))
				.append(renderSection('center'))
				.append('&lt;div class=&quot;fc-clear&quot;/&gt;');
</P><P>			return el;
		}
	}
</P><P>	
	function removeElement() {
		el.remove();
		el = $();
	}
</P><P>	
	function renderSection(position) {
		var sectionEl = $('&lt;div class=&quot;fc-' + position + '&quot;/&gt;');
		var buttonStr = options.header[position];
</P><P>		if (buttonStr) {
			$.each(buttonStr.split(' '), function(i) {
				var groupChildren = $();
				var isOnlyButtons = true;
				var groupEl;
</P><P>				$.each(this.split(','), function(j, buttonName) {
					var viewSpec;
					var buttonClick;
					var overrideText; // text explicitly set by calendar's constructor options. overcomes icons
					var defaultText;
					var themeIcon;
					var normalIcon;
					var innerHtml;
					var classes;
					var button;
</P><P>					if (buttonName == 'title') {
</P>
						groupChildren = groupChildren.add($('<H2><SPAN class="mw-headline" id=".C2.A0"> </SPAN></H2>')); // we always want it to take up height
<P>						isOnlyButtons = false;
					}
					else {
						viewSpec = calendar.getViewSpec(buttonName);
</P><P>						if (viewSpec) {
							buttonClick = function() {
								calendar.changeView(buttonName);
							};
							viewsWithButtons.push(buttonName);
							overrideText = viewSpec.buttonTextOverride;
							defaultText = viewSpec.buttonTextDefault;
						}
						else if (calendar[buttonName]) { // a calendar method
							buttonClick = function() {
								calendar[buttonName]();
							};
							overrideText = (calendar.overrides.buttonText || {})[buttonName];
							defaultText = options.buttonText[buttonName]; // everything else is considered default
						}
</P><P>						if (buttonClick) {
</P><P>							themeIcon = options.themeButtonIcons[buttonName];
							normalIcon = options.buttonIcons[buttonName];
</P><P>							if (overrideText) {
								innerHtml = htmlEscape(overrideText);
							}
							else if (themeIcon &amp;&amp; options.theme) {
								innerHtml = &quot;&quot;;
							}
							else if (normalIcon &amp;&amp; !options.theme) {
								innerHtml = &quot;&quot;;
							}
							else {
								innerHtml = htmlEscape(defaultText);
							}
</P><P>							classes = [
								'fc-' + buttonName + '-button',
								tm + '-button',
								tm + '-state-default'
							];
</P><P>							button = $( // type=&quot;button&quot; so that it doesn't submit a form
								'&lt;button type=&quot;button&quot; class=&quot;' + classes.join(' ') + '&quot;&gt;' +
									innerHtml +
								'&lt;/button&gt;'
								)
								.click(function() {
									// don't process clicks for disabled buttons
									if (!button.hasClass(tm + '-state-disabled')) {
</P><P>										buttonClick();
</P><P>										// after the click action, if the button becomes the &quot;active&quot; tab, or disabled,
										// it should never have a hover class, so remove it now.
										if (
											button.hasClass(tm + '-state-active') ||
											button.hasClass(tm + '-state-disabled')
										) {
											button.removeClass(tm + '-state-hover');
										}
									}
								})
								.mousedown(function() {
									// the *down* effect (mouse pressed in).
									// only on buttons that are not the &quot;active&quot; tab, or disabled
									button
										.not('.' + tm + '-state-active')
										.not('.' + tm + '-state-disabled')
										.addClass(tm + '-state-down');
								})
								.mouseup(function() {
									// undo the *down* effect
									button.removeClass(tm + '-state-down');
								})
								.hover(
									function() {
										// the *hover* effect.
										// only on buttons that are not the &quot;active&quot; tab, or disabled
										button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-hover');
									},
									function() {
										// undo the *hover* effect
										button
											.removeClass(tm + '-state-hover')
											.removeClass(tm + '-state-down'); // if mouseleave happens before mouseup
									}
								);
</P><P>							groupChildren = groupChildren.add(button);
						}
					}
				});
</P><P>				if (isOnlyButtons) {
					groupChildren
						.first().addClass(tm + '-corner-left').end()
						.last().addClass(tm + '-corner-right').end();
				}
</P><P>				if (groupChildren.length &gt; 1) {
					groupEl = $('&lt;div/&gt;');
					if (isOnlyButtons) {
						groupEl.addClass('fc-button-group');
					}
					groupEl.append(groupChildren);
					sectionEl.append(groupEl);
				}
				else {
					sectionEl.append(groupChildren); // 1 or 0 children
				}
			});
		}
</P><P>		return sectionEl;
	}
</P><P>	
	function updateTitle(text) {
		el.find('h2').text(text);
	}
</P><P>	
	function activateButton(buttonName) {
		el.find('.fc-' + buttonName + '-button')
			.addClass(tm + '-state-active');
	}
</P><P>	
	function deactivateButton(buttonName) {
		el.find('.fc-' + buttonName + '-button')
			.removeClass(tm + '-state-active');
	}
</P><P>	
	function disableButton(buttonName) {
		el.find('.fc-' + buttonName + '-button')
			.attr('disabled', 'disabled')
			.addClass(tm + '-state-disabled');
	}
</P><P>	
	function enableButton(buttonName) {
		el.find('.fc-' + buttonName + '-button')
			.removeAttr('disabled')
			.removeClass(tm + '-state-disabled');
	}
</P><P>
	function getViewsWithButtons() {
		return viewsWithButtons;
	}
</P><P>}
</P><P>fc.sourceNormalizers = [];
fc.sourceFetchers = [];
</P><P>var ajaxDefaults = {
	dataType: 'json',
	cache: false
};
</P><P>var eventGUID = 1;
</P><P>
function EventManager(options) { // assumed to be a calendar
	var t = this;
</P><P>	
	// exports
	t.isFetchNeeded = isFetchNeeded;
	t.fetchEvents = fetchEvents;
	t.addEventSource = addEventSource;
	t.removeEventSource = removeEventSource;
	t.updateEvent = updateEvent;
	t.renderEvent = renderEvent;
	t.removeEvents = removeEvents;
	t.clientEvents = clientEvents;
	t.mutateEvent = mutateEvent;
	t.normalizeEventRange = normalizeEventRange;
	t.normalizeEventRangeTimes = normalizeEventRangeTimes;
	t.ensureVisibleEventRange = ensureVisibleEventRange;
</P><P>	
	// imports
	var reportEvents = t.reportEvents;
</P><P>	
	// locals
	var stickySource = { events: [] };
	var sources = [ stickySource ];
	var rangeStart, rangeEnd;
	var currentFetchID = 0;
	var pendingSourceCnt = 0;
	var cache = []; // holds events that have already been expanded
</P><P>
	$.each(
		(options.events ? [ options.events ] : []).concat(options.eventSources || []),
		function(i, sourceInput) {
			var source = buildEventSource(sourceInput);
			if (source) {
				sources.push(source);
			}
		}
	);
</P><P>	/* Fetching
	-----------------------------------------------------------------------------*/
</P><P>	
	function isFetchNeeded(start, end) {
		return !rangeStart || // nothing has been fetched yet?
			// or, a part of the new range is outside of the old range? (after normalizing)
			start.clone().stripZone() &lt; rangeStart.clone().stripZone() ||
			end.clone().stripZone() &gt; rangeEnd.clone().stripZone();
	}
</P><P>	
	function fetchEvents(start, end) {
		rangeStart = start;
		rangeEnd = end;
		cache = [];
		var fetchID = ++currentFetchID;
		var len = sources.length;
		pendingSourceCnt = len;
		for (var i=0; i&lt;len; i++) {
			fetchEventSource(sources[i], fetchID);
		}
	}
</P><P>	
	function fetchEventSource(source, fetchID) {
		_fetchEventSource(source, function(eventInputs) {
			var isArraySource = $.isArray(source.events);
			var i, eventInput;
			var abstractEvent;
</P><P>			if (fetchID == currentFetchID) {
</P><P>				if (eventInputs) {
					for (i = 0; i &lt; eventInputs.length; i++) {
						eventInput = eventInputs[i];
</P><P>						if (isArraySource) { // array sources have already been convert to Event Objects
							abstractEvent = eventInput;
						}
						else {
							abstractEvent = buildEventFromInput(eventInput, source);
						}
</P><P>						if (abstractEvent) { // not false (an invalid event)
							cache.push.apply(
								cache,
								expandEvent(abstractEvent) // add individual expanded events to the cache
							);
						}
					}
				}
</P><P>				pendingSourceCnt--;
				if (!pendingSourceCnt) {
					reportEvents(cache);
				}
			}
		});
	}
</P><P>	
	function _fetchEventSource(source, callback) {
		var i;
		var fetchers = fc.sourceFetchers;
		var res;
</P><P>		for (i=0; i&lt;fetchers.length; i++) {
			res = fetchers[i].call(
				t, // this, the Calendar object
				source,
				rangeStart.clone(),
				rangeEnd.clone(),
				options.timezone,
				callback
			);
</P><P>			if (res === true) {
				// the fetcher is in charge. made its own async request
				return;
			}
			else if (typeof res == 'object') {
				// the fetcher returned a new source. process it
				_fetchEventSource(res, callback);
				return;
			}
		}
</P><P>		var events = source.events;
		if (events) {
			if ($.isFunction(events)) {
				t.pushLoading();
				events.call(
					t, // this, the Calendar object
					rangeStart.clone(),
					rangeEnd.clone(),
					options.timezone,
					function(events) {
						callback(events);
						t.popLoading();
					}
				);
			}
			else if ($.isArray(events)) {
				callback(events);
			}
			else {
				callback();
			}
		}else{
			var url = source.url;
			if (url) {
				var success = source.success;
				var error = source.error;
				var complete = source.complete;
</P><P>				// retrieve any outbound GET/POST $.ajax data from the options
				var customData;
				if ($.isFunction(source.data)) {
					// supplied as a function that returns a key/value object
					customData = source.data();
				}
				else {
					// supplied as a straight key/value object
					customData = source.data;
				}
</P><P>				// use a copy of the custom data so we can modify the parameters
				// and not affect the passed-in object.
				var data = $.extend({}, customData || {});
</P><P>				var startParam = firstDefined(source.startParam, options.startParam);
				var endParam = firstDefined(source.endParam, options.endParam);
				var timezoneParam = firstDefined(source.timezoneParam, options.timezoneParam);
</P><P>				if (startParam) {
					data[startParam] = rangeStart.format();
				}
				if (endParam) {
					data[endParam] = rangeEnd.format();
				}
				if (options.timezone &amp;&amp; options.timezone != 'local') {
					data[timezoneParam] = options.timezone;
				}
</P><P>				t.pushLoading();
				$.ajax($.extend({}, ajaxDefaults, source, {
					data: data,
					success: function(events) {
						events = events || [];
						var res = applyAll(success, this, arguments);
						if ($.isArray(res)) {
							events = res;
						}
						callback(events);
					},
					error: function() {
						applyAll(error, this, arguments);
						callback();
					},
					complete: function() {
						applyAll(complete, this, arguments);
						t.popLoading();
					}
				}));
			}else{
				callback();
			}
		}
	}
</P><P>	/* Sources
	-----------------------------------------------------------------------------*/
</P><P>
	function addEventSource(sourceInput) {
		var source = buildEventSource(sourceInput);
		if (source) {
			sources.push(source);
			pendingSourceCnt++;
			fetchEventSource(source, currentFetchID); // will eventually call reportEvents
		}
	}
</P><P>
	function buildEventSource(sourceInput) { // will return undefined if invalid source
		var normalizers = fc.sourceNormalizers;
		var source;
		var i;
</P><P>		if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
			source = { events: sourceInput };
		}
		else if (typeof sourceInput === 'string') {
			source = { url: sourceInput };
		}
		else if (typeof sourceInput === 'object') {
			source = $.extend({}, sourceInput); // shallow copy
		}
</P><P>		if (source) {
</P><P>			// TODO: repeat code, same code for event classNames
			if (source.className) {
				if (typeof source.className === 'string') {
					source.className = source.className.split(/\s+/);
				}
				// otherwise, assumed to be an array
			}
			else {
				source.className = [];
			}
</P><P>			// for array sources, we convert to standard Event Objects up front
			if ($.isArray(source.events)) {
				source.origArray = source.events; // for removeEventSource
				source.events = $.map(source.events, function(eventInput) {
					return buildEventFromInput(eventInput, source);
				});
			}
</P><P>			for (i=0; i&lt;normalizers.length; i++) {
				normalizers[i].call(t, source);
			}
</P><P>			return source;
		}
	}
</P><P>
	function removeEventSource(source) {
		sources = $.grep(sources, function(src) {
			return !isSourcesEqual(src, source);
		});
		// remove all client events from that source
		cache = $.grep(cache, function(e) {
			return !isSourcesEqual(e.source, source);
		});
		reportEvents(cache);
	}
</P><P>
	function isSourcesEqual(source1, source2) {
		return source1 &amp;&amp; source2 &amp;&amp; getSourcePrimitive(source1) == getSourcePrimitive(source2);
	}
</P><P>
	function getSourcePrimitive(source) {
		return (
			(typeof source === 'object') ? // a normalized event source?
				(source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive
				null
		) ||
		source; // the given argument *is* the primitive
	}
</P><P>	/* Manipulation
	-----------------------------------------------------------------------------*/
</P><P>
	// Only ever called from the externally-facing API
	function updateEvent(event) {
</P><P>		// massage start/end values, even if date string values
		event.start = t.moment(event.start);
		if (event.end) {
			event.end = t.moment(event.end);
		}
		else {
			event.end = null;
		}
</P><P>		mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization
		reportEvents(cache); // reports event modifications (so we can redraw)
	}
</P><P>
	// Returns a hash of misc event properties that should be copied over to related events.
	function getMiscEventProps(event) {
		var props = {};
</P><P>		$.each(event, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined &amp;&amp; isAtomic(val)) { // a defined non-object
					props[name] = val;
				}
			}
		});
</P><P>		return props;
	}
</P><P>	// non-date-related, non-id-related, non-secret
	function isMiscEventPropName(name) {
		return !/^_|^(id|allDay|start|end)$/.test(name);
	}
</P><P>	
	// returns the expanded events that were created
	function renderEvent(eventInput, stick) {
		var abstractEvent = buildEventFromInput(eventInput);
		var events;
		var i, event;
</P><P>		if (abstractEvent) { // not false (a valid input)
			events = expandEvent(abstractEvent);
</P><P>			for (i = 0; i &lt; events.length; i++) {
				event = events[i];
</P><P>				if (!event.source) {
					if (stick) {
						stickySource.events.push(event);
						event.source = stickySource;
					}
					cache.push(event);
				}
			}
</P><P>			reportEvents(cache);
</P><P>			return events;
		}
</P><P>		return [];
	}
</P><P>	
	function removeEvents(filter) {
		var eventID;
		var i;
</P><P>		if (filter == null) { // null or undefined. remove all events
			filter = function() { return true; }; // will always match
		}
		else if (!$.isFunction(filter)) { // an event ID
			eventID = filter + <I>;</I>
			filter = function(event) {
				return event._id == eventID;
			};
		}
</P><P>		// Purge event(s) from our local cache
		cache = $.grep(cache, filter, true); // inverse=true
</P><P>		// Remove events from array sources.
		// This works because they have been converted to official Event Objects up front.
		// (and as a result, event._id has been calculated).
		for (i=0; i&lt;sources.length; i++) {
			if ($.isArray(sources[i].events)) {
				sources[i].events = $.grep(sources[i].events, filter, true);
			}
		}
</P><P>		reportEvents(cache);
	}
</P><P>	
	function clientEvents(filter) {
		if ($.isFunction(filter)) {
			return $.grep(cache, filter);
		}
		else if (filter != null) { // not null, not undefined. an event ID
			filter += <I>;</I>
			return $.grep(cache, function(e) {
				return e._id == filter;
			});
		}
		return cache; // else, return all
	}
</P><P>	/* Event Normalization
	-----------------------------------------------------------------------------*/
</P><P>
	// Given a raw object with key/value properties, returns an &quot;abstract&quot; Event object.
	// An &quot;abstract&quot; event is an event that, if recurring, will not have been expanded yet.
	// Will return `false` when input is invalid.
	// `source` is optional
	function buildEventFromInput(input, source) {
		var out = {};
		var start, end;
		var allDay;
</P><P>		if (options.eventDataTransform) {
			input = options.eventDataTransform(input);
		}
		if (source &amp;&amp; source.eventDataTransform) {
			input = source.eventDataTransform(input);
		}
</P><P>		// Copy all properties over to the resulting object.
		// The special-case properties will be copied over afterwards.
		$.extend(out, input);
</P><P>		if (source) {
			out.source = source;
		}
</P><P>		out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + <I>);</I></P><P>		if (input.className) {
			if (typeof input.className == 'string') {
				out.className = input.className.split(/\s+/);
			}
			else { // assumed to be an array
				out.className = input.className;
			}
		}
		else {
			out.className = [];
		}
</P><P>		start = input.start || input.date; // &quot;date&quot; is an alias for &quot;start&quot;
		end = input.end;
</P><P>		// parse as a time (Duration) if applicable
		if (isTimeString(start)) {
			start = moment.duration(start);
		}
		if (isTimeString(end)) {
			end = moment.duration(end);
		}
</P><P>		if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {
</P><P>			// the event is &quot;abstract&quot; (recurring) so don't calculate exact start/end dates just yet
			out.start = start ? moment.duration(start) : null; // will be a Duration or null
			out.end = end ? moment.duration(end) : null; // will be a Duration or null
			out._recurring = true; // our internal marker
		}
		else {
</P><P>			if (start) {
				start = t.moment(start);
				if (!start.isValid()) {
					return false;
				}
			}
</P><P>			if (end) {
				end = t.moment(end);
				if (!end.isValid()) {
					end = null; // let defaults take over
				}
			}
</P><P>			allDay = input.allDay;
			if (allDay === undefined) { // still undefined? fallback to default
				allDay = firstDefined(
					source ? source.allDayDefault : undefined,
					options.allDayDefault
				);
				// still undefined? normalizeEventRange will calculate it
			}
</P><P>			assignDatesToEvent(start, end, allDay, out);
		}
</P><P>		return out;
	}
</P><P>
	// Normalizes and assigns the given dates to the given partially-formed event object.
	// NOTE: mutates the given start/end moments. does not make a copy.
	function assignDatesToEvent(start, end, allDay, event) {
		event.start = start;
		event.end = end;
		event.allDay = allDay;
		normalizeEventRange(event);
		backupEventDates(event);
	}
</P><P>
	// Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.
	// NOTE: Will modify the given object.
	function normalizeEventRange(props) {
</P><P>		normalizeEventRangeTimes(props);
</P><P>		if (props.end &amp;&amp; !props.end.isAfter(props.start)) {
			props.end = null;
		}
</P><P>		if (!props.end) {
			if (options.forceEventDuration) {
				props.end = t.getDefaultEventEnd(props.allDay, props.start);
			}
			else {
				props.end = null;
			}
		}
	}
</P><P>
	// Ensures the allDay property exists and the timeliness of the start/end dates are consistent
	function normalizeEventRangeTimes(range) {
		if (range.allDay == null) {
			range.allDay = !(range.start.hasTime() || (range.end &amp;&amp; range.end.hasTime()));
		}
</P><P>		if (range.allDay) {
			range.start.stripTime();
			if (range.end) {
				// TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment
				range.end.stripTime();
			}
		}
		else {
			if (!range.start.hasTime()) {
				range.start = t.rezoneDate(range.start); // will assign a 00:00 time
			}
			if (range.end &amp;&amp; !range.end.hasTime()) {
				range.end = t.rezoneDate(range.end); // will assign a 00:00 time
			}
		}
	}
</P><P>
	// If `range` is a proper range with a start and end, returns the original object.
	// If missing an end, computes a new range with an end, computing it as if it were an event.
	// TODO: make this a part of the event -&gt; eventRange system
	function ensureVisibleEventRange(range) {
		var allDay;
</P><P>		if (!range.end) {
</P><P>			allDay = range.allDay; // range might be more event-ish than we think
			if (allDay == null) {
				allDay = !range.start.hasTime();
			}
</P><P>			range = $.extend({}, range); // make a copy, copying over other misc properties
			range.end = t.getDefaultEventEnd(allDay, range.start);
		}
		return range;
	}
</P><P>
	// If the given event is a recurring event, break it down into an array of individual instances.
	// If not a recurring event, return an array with the single original event.
	// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
	// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
	function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
		var events = [];
		var dowHash;
		var dow;
		var i;
		var date;
		var startTime, endTime;
		var start, end;
		var event;
</P><P>		_rangeStart = _rangeStart || rangeStart;
		_rangeEnd = _rangeEnd || rangeEnd;
</P><P>		if (abstractEvent) {
			if (abstractEvent._recurring) {
</P><P>				// make a boolean hash as to whether the event occurs on each day-of-week
				if ((dow = abstractEvent.dow)) {
					dowHash = {};
					for (i = 0; i &lt; dow.length; i++) {
						dowHash[dow[i]] = true;
					}
				}
</P><P>				// iterate through every day in the current range
				date = _rangeStart.clone().stripTime(); // holds the date of the current day
				while (date.isBefore(_rangeEnd)) {
</P><P>					if (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week
</P><P>						startTime = abstractEvent.start; // the stored start and end properties are times (Durations)
						endTime = abstractEvent.end; // &quot;
						start = date.clone();
						end = null;
</P><P>						if (startTime) {
							start = start.time(startTime);
						}
						if (endTime) {
							end = date.clone().time(endTime);
						}
</P><P>						event = $.extend({}, abstractEvent); // make a copy of the original
						assignDatesToEvent(
							start, end,
							!startTime &amp;&amp; !endTime, // allDay?
							event
						);
						events.push(event);
					}
</P><P>					date.add(1, 'days');
				}
			}
			else {
				events.push(abstractEvent); // return the original event. will be a one-item array
			}
		}
</P><P>		return events;
	}
</P><P>	/* Event Modification Math
	-----------------------------------------------------------------------------------------*/
</P><P>
	// Modifies an event and all related events by applying the given properties.
	// Special date-diffing logic is used for manipulation of dates.
	// If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.
	// All date comparisons are done against the event's pristine _start and _end dates.
	// Returns an object with delta information and a function to undo all operations.
	// For making computations in a granularity greater than day/time, specify largeUnit.
	// NOTE: The given `newProps` might be mutated for normalization purposes.
	function mutateEvent(event, newProps, largeUnit) {
		var miscProps = {};
		var oldProps;
		var clearEnd;
		var startDelta;
		var endDelta;
		var durationDelta;
		var undoFunc;
</P><P>		// diffs the dates in the appropriate way, returning a duration
		function diffDates(date1, date0) { // date1 - date0
			if (largeUnit) {
				return diffByUnit(date1, date0, largeUnit);
			}
			else if (newProps.allDay) {
				return diffDay(date1, date0);
			}
			else {
				return diffDayTime(date1, date0);
			}
		}
</P><P>		newProps = newProps || {};
</P><P>		// normalize new date-related properties
		if (!newProps.start) {
			newProps.start = event.start.clone();
		}
		if (newProps.end === undefined) {
			newProps.end = event.end ? event.end.clone() : null;
		}
		if (newProps.allDay == null) { // is null or undefined?
			newProps.allDay = event.allDay;
		}
		normalizeEventRange(newProps);
</P><P>		// create normalized versions of the original props to compare against
		// need a real end value, for diffing
		oldProps = {
			start: event._start.clone(),
			end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
			allDay: newProps.allDay // normalize the dates in the same regard as the new properties
		};
		normalizeEventRange(oldProps);
</P><P>		// need to clear the end date if explicitly changed to null
		clearEnd = event._end !== null &amp;&amp; newProps.end === null;
</P><P>		// compute the delta for moving the start date
		startDelta = diffDates(newProps.start, oldProps.start);
</P><P>		// compute the delta for moving the end date
		if (newProps.end) {
			endDelta = diffDates(newProps.end, oldProps.end);
			durationDelta = endDelta.subtract(startDelta);
		}
		else {
			durationDelta = null;
		}
</P><P>		// gather all non-date-related properties
		$.each(newProps, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined) {
					miscProps[name] = val;
				}
			}
		});
</P><P>		// apply the operations to the event and all related events
		undoFunc = mutateEvents(
			clientEvents(event._id), // get events with this ID
			clearEnd,
			newProps.allDay,
			startDelta,
			durationDelta,
			miscProps
		);
</P><P>		return {
			dateDelta: startDelta,
			durationDelta: durationDelta,
			undo: undoFunc
		};
	}
</P><P>
	// Modifies an array of events in the following ways (operations are in order):
	// - clear the event's `end`
	// - convert the event to allDay
	// - add `dateDelta` to the start and end
	// - add `durationDelta` to the event's duration
	// - assign `miscProps` to the event
	//
	// Returns a function that can be called to undo all the operations.
	//
	// TODO: don't use so many closures. possible memory issues when lots of events with same ID.
	//
	function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
		var isAmbigTimezone = t.getIsAmbigTimezone();
		var undoFunctions = [];
</P><P>		// normalize zero-length deltas to be null
		if (dateDelta &amp;&amp; !dateDelta.valueOf()) { dateDelta = null; }
		if (durationDelta &amp;&amp; !durationDelta.valueOf()) { durationDelta = null; }
</P><P>		$.each(events, function(i, event) {
			var oldProps;
			var newProps;
</P><P>			// build an object holding all the old values, both date-related and misc.
			// for the undo function.
			oldProps = {
				start: event.start.clone(),
				end: event.end ? event.end.clone() : null,
				allDay: event.allDay
			};
			$.each(miscProps, function(name) {
				oldProps[name] = event[name];
			});
</P><P>			// new date-related properties. work off the original date snapshot.
			// ok to use references because they will be thrown away when backupEventDates is called.
			newProps = {
				start: event._start,
				end: event._end,
				allDay: allDay // normalize the dates in the same regard as the new properties
			};
			normalizeEventRange(newProps); // massages start/end/allDay
</P><P>			// strip or ensure the end date
			if (clearEnd) {
				newProps.end = null;
			}
			else if (durationDelta &amp;&amp; !newProps.end) { // the duration translation requires an end date
				newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
			}
</P><P>			if (dateDelta) {
				newProps.start.add(dateDelta);
				if (newProps.end) {
					newProps.end.add(dateDelta);
				}
			}
</P><P>			if (durationDelta) {
				newProps.end.add(durationDelta); // end already ensured above
			}
</P><P>			// if the dates have changed, and we know it is impossible to recompute the
			// timezone offsets, strip the zone.
			if (
				isAmbigTimezone &amp;&amp;
				!newProps.allDay &amp;&amp;
				(dateDelta || durationDelta)
			) {
				newProps.start.stripZone();
				if (newProps.end) {
					newProps.end.stripZone();
				}
			}
</P><P>			$.extend(event, miscProps, newProps); // copy over misc props, then date-related props
			backupEventDates(event); // regenerate internal _start/_end/_allDay
</P><P>			undoFunctions.push(function() {
				$.extend(event, oldProps);
				backupEventDates(event); // regenerate internal _start/_end/_allDay
			});
		});
</P><P>		return function() {
			for (var i = 0; i &lt; undoFunctions.length; i++) {
				undoFunctions[i]();
			}
		};
	}
</P><P>
	/* Business Hours
	-----------------------------------------------------------------------------------------*/
</P><P>	t.getBusinessHoursEvents = getBusinessHoursEvents;
</P><P>
	// Returns an array of events as to when the business hours occur in the given view.
	// Abuse of our event system :(
	function getBusinessHoursEvents(wholeDay) {
		var optionVal = options.businessHours;
		var defaultVal = {
			className: 'fc-nonbusiness',
			start: '09:00',
			end: '17:00',
			dow: [ 1, 2, 3, 4, 5 ], // monday - friday
			rendering: 'inverse-background'
		};
		var view = t.getView();
		var eventInput;
</P><P>		if (optionVal) { // `true` (which means &quot;use the defaults&quot;) or an override object
			eventInput = $.extend(
				{}, // copy to a new object in either case
				defaultVal,
				typeof optionVal === 'object' ? optionVal : {} // override the defaults
			);
		}
</P><P>		if (eventInput) {
</P><P>			// if a whole-day series is requested, clear the start/end times
			if (wholeDay) {
				eventInput.start = null;
				eventInput.end = null;
			}
</P><P>			return expandEvent(
				buildEventFromInput(eventInput),
				view.start,
				view.end
			);
		}
</P><P>		return [];
	}
</P><P>
	/* Overlapping / Constraining
	-----------------------------------------------------------------------------------------*/
</P><P>	t.isEventRangeAllowed = isEventRangeAllowed;
	t.isSelectionRangeAllowed = isSelectionRangeAllowed;
	t.isExternalDropRangeAllowed = isExternalDropRangeAllowed;
</P><P>
	function isEventRangeAllowed(range, event) {
		var source = event.source || {};
		var constraint = firstDefined(
			event.constraint,
			source.constraint,
			options.eventConstraint
		);
		var overlap = firstDefined(
			event.overlap,
			source.overlap,
			options.eventOverlap
		);
</P><P>		range = ensureVisibleEventRange(range); // ensure a proper range with an end for isRangeAllowed
</P><P>		return isRangeAllowed(range, constraint, overlap, event);
	}
</P><P>
	function isSelectionRangeAllowed(range) {
		return isRangeAllowed(range, options.selectConstraint, options.selectOverlap);
	}
</P><P>
	// when `eventProps` is defined, consider this an event.
	// `eventProps` can contain misc non-date-related info about the event.
	function isExternalDropRangeAllowed(range, eventProps) {
		var eventInput;
		var event;
</P><P>		// note: very similar logic is in View's reportExternalDrop
		if (eventProps) {
			eventInput = $.extend({}, eventProps, range);
			event = expandEvent(buildEventFromInput(eventInput))[0];
		}
</P><P>		if (event) {
			return isEventRangeAllowed(range, event);
		}
		else { // treat it as a selection
</P><P>			range = ensureVisibleEventRange(range); // ensure a proper range with an end for isSelectionRangeAllowed
</P><P>			return isSelectionRangeAllowed(range);
		}
	}
</P><P>
	// Returns true if the given range (caused by an event drop/resize or a selection) is allowed to exist
	// according to the constraint/overlap settings.
	// `event` is not required if checking a selection.
	function isRangeAllowed(range, constraint, overlap, event) {
		var constraintEvents;
		var anyContainment;
		var peerEvents;
		var i, peerEvent;
		var peerOverlap;
</P><P>		// normalize. fyi, we're normalizing in too many places :(
		range = $.extend({}, range); // copy all properties in case there are misc non-date properties
		range.start = range.start.clone().stripZone();
		range.end = range.end.clone().stripZone();
</P><P>		// the range must be fully contained by at least one of produced constraint events
		if (constraint != null) {
</P><P>			// not treated as an event! intermediate data structure
			// TODO: use ranges in the future
			constraintEvents = constraintToEvents(constraint);
</P><P>			anyContainment = false;
			for (i = 0; i &lt; constraintEvents.length; i++) {
				if (eventContainsRange(constraintEvents[i], range)) {
					anyContainment = true;
					break;
				}
			}
</P><P>			if (!anyContainment) {
				return false;
			}
		}
</P><P>		peerEvents = t.getPeerEvents(event, range);
</P><P>		for (i = 0; i &lt; peerEvents.length; i++)  {
			peerEvent = peerEvents[i];
</P><P>			// there needs to be an actual intersection before disallowing anything
			if (eventIntersectsRange(peerEvent, range)) {
</P><P>				// evaluate overlap for the given range and short-circuit if necessary
				if (overlap === false) {
					return false;
				}
				// if the event's overlap is a test function, pass the peer event in question as the first param
				else if (typeof overlap === 'function' &amp;&amp; !overlap(peerEvent, event)) {
					return false;
				}
</P><P>				// if we are computing if the given range is allowable for an event, consider the other event's
				// EventObject-specific or Source-specific `overlap` property
				if (event) {
					peerOverlap = firstDefined(
						peerEvent.overlap,
						(peerEvent.source || {}).overlap
						// we already considered the global `eventOverlap`
					);
					if (peerOverlap === false) {
						return false;
					}
					// if the peer event's overlap is a test function, pass the subject event as the first param
					if (typeof peerOverlap === 'function' &amp;&amp; !peerOverlap(event, peerEvent)) {
						return false;
					}
				}
			}
		}
</P><P>		return true;
	}
</P><P>
	// Given an event input from the API, produces an array of event objects. Possible event inputs:
	// 'businessHours'
	// An event ID (number or string)
	// An object with specific start/end dates or a recurring event (like what businessHours accepts)
	function constraintToEvents(constraintInput) {
</P><P>		if (constraintInput === 'businessHours') {
			return getBusinessHoursEvents();
		}
</P><P>		if (typeof constraintInput === 'object') {
			return expandEvent(buildEventFromInput(constraintInput));
		}
</P><P>		return clientEvents(constraintInput); // probably an ID
	}
</P><P>
	// Does the event's date range fully contain the given range?
	// start/end already assumed to have stripped zones :(
	function eventContainsRange(event, range) {
		var eventStart = event.start.clone().stripZone();
		var eventEnd = t.getEventEnd(event).stripZone();
</P><P>		return range.start &gt;= eventStart &amp;&amp; range.end &lt;= eventEnd;
	}
</P><P>
	// Does the event's date range intersect with the given range?
	// start/end already assumed to have stripped zones :(
	function eventIntersectsRange(event, range) {
		var eventStart = event.start.clone().stripZone();
		var eventEnd = t.getEventEnd(event).stripZone();
</P><P>		return range.start &lt; eventEnd &amp;&amp; range.end &gt; eventStart;
	}
</P><P>
	t.getEventCache = function() {
		return cache;
	};
</P><P>}
</P><P>
// Returns a list of events that the given event should be compared against when being considered for a move to
// the specified range. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.
Calendar.prototype.getPeerEvents = function(event, range) {
	var cache = this.getEventCache();
	var peerEvents = [];
	var i, otherEvent;
</P><P>	for (i = 0; i &lt; cache.length; i++) {
		otherEvent = cache[i];
		if (
			!event ||
			event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events
		) {
			peerEvents.push(otherEvent);
		}
	}
</P><P>	return peerEvents;
};
</P><P>
// updates the &quot;backup&quot; properties, which are preserved in order to compute diffs later on.
function backupEventDates(event) {
	event._allDay = event.allDay;
	event._start = event.start.clone();
	event._end = event.end ? event.end.clone() : null;
}
</P><P>/* An abstract class for the &quot;basic&quot; views, as well as month view. Renders one or more rows of day cells.
</P>*/
<P>// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.
</P><P>var BasicView = View.extend({
</P><P>	dayGrid: null, // the main subcomponent that does most of the heavy lifting
</P><P>	dayNumbersVisible: false, // display day numbers on each day cell?
	weekNumbersVisible: false, // display week numbers along the side?
</P><P>	weekNumberWidth: null, // width of all the week-number cells running down the side
</P><P>	headRowEl: null, // the fake row element of the day-of-week header
</P><P>
	initialize: function() {
		this.dayGrid = new DayGrid(this);
		this.coordMap = this.dayGrid.coordMap; // the view's date-to-cell mapping is identical to the subcomponent's
	},
</P><P>
	// Sets the display range and computes all necessary dates
	setRange: function(range) {
		View.prototype.setRange.call(this, range); // call the super-method
</P><P>		this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit); // do before setRange
		this.dayGrid.setRange(range);
	},
</P><P>
	// Compute the value to feed into setRange. Overrides superclass.
	computeRange: function(date) {
		var range = View.prototype.computeRange.call(this, date); // get value from the super-method
</P><P>		// year and month views should be aligned with weeks. this is already done for week
		if (/year|month/.test(range.intervalUnit)) {
			range.start.startOf('week');
			range.start = this.skipHiddenDays(range.start);
</P><P>			// make end-of-week if not already
			if (range.end.weekday()) {
				range.end.add(1, 'week').startOf('week');
				range.end = this.skipHiddenDays(range.end, -1, true); // exclusively move backwards
			}
		}
</P><P>		return range;
	},
</P><P>
	// Renders the view into `this.el`, which should already be assigned
	renderDates: function() {
</P><P>		this.dayNumbersVisible = this.dayGrid.rowCnt &gt; 1; // TODO: make grid responsible
		this.weekNumbersVisible = this.opt('weekNumbers');
		this.dayGrid.numbersVisible = this.dayNumbersVisible || this.weekNumbersVisible;
</P><P>		this.el.addClass('fc-basic-view').html(this.renderHtml());
</P><P>		this.headRowEl = this.el.find('thead .fc-row');
</P><P>		this.scrollerEl = this.el.find('.fc-day-grid-container');
		this.dayGrid.coordMap.containerEl = this.scrollerEl; // constrain clicks/etc to the dimensions of the scroller
</P><P>		this.dayGrid.setElement(this.el.find('.fc-day-grid'));
		this.dayGrid.renderDates(this.hasRigidRows());
	},
</P><P>
	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill the dayGrid's rendering.
	unrenderDates: function() {
		this.dayGrid.unrenderDates();
		this.dayGrid.removeElement();
	},
</P><P>
	renderBusinessHours: function() {
		this.dayGrid.renderBusinessHours();
	},
</P><P>
	// Builds the HTML skeleton for the view.
	// The day-grid component will render inside of a container defined by this HTML.
	renderHtml: function() {
		return <I> +</I></P>
			'<TABLE>' +
				'&lt;thead class=&quot;fc-head&quot;&gt;' +
					'<TBODY><TR>' +
						'<TD class="' + this.widgetHeaderClass + '">' +
<P>							this.dayGrid.headHtml() + // render the day-of-week headers
</P>
						'</TD>' +
					'</TR>' +
				'&lt;/thead&gt;' +
				'&lt;tbody class=&quot;fc-body&quot;&gt;' +
					'<TR>' +
						'<TD class="' + this.widgetContentClass + '">' +
							'<DIV class="fc-day-grid-container">' +
<P>								'&lt;div class=&quot;fc-day-grid&quot;/&gt;' +
</P>
							'</DIV>' +
						'</TD>' +
					'</TR>' +
				'&lt;/tbody&gt;' +
			'</TBODY></TABLE>';
<P>	},
</P><P>
	// Generates the HTML that will go before the day-of week header cells.
	// Queried by the DayGrid subcomponent when generating rows. Ordering depends on isRTL.
	headIntroHtml: function() {
		if (this.weekNumbersVisible) {
			return <I> +</I>
				'&lt;th class=&quot;fc-week-number ' + this.widgetHeaderClass + '&quot; ' + this.weekNumberStyleAttr() + '&gt;' +
					'<SPAN>' + // needed for matchCellWidths
						htmlEscape(this.opt('weekNumberTitle')) +
					'</SPAN>' +
				'&lt;/th&gt;';
		}
	},
</P><P>
	// Generates the HTML that will go before content-skeleton cells that display the day/week numbers.
	// Queried by the DayGrid subcomponent. Ordering depends on isRTL.
	numberIntroHtml: function(row) {
		if (this.weekNumbersVisible) {
			return <I> +</I>
				'&lt;td class=&quot;fc-week-number&quot; ' + this.weekNumberStyleAttr() + '&gt;' +
					'<SPAN>' + // needed for matchCellWidths
						this.dayGrid.getCell(row, 0).start.format('w') +
					'</SPAN>' +
				'&lt;/td&gt;';
		}
	},
</P><P>
	// Generates the HTML that goes before the day bg cells for each day-row.
	// Queried by the DayGrid subcomponent. Ordering depends on isRTL.
	dayIntroHtml: function() {
		if (this.weekNumbersVisible) {
			return '&lt;td class=&quot;fc-week-number ' + this.widgetContentClass + '&quot; ' +
				this.weekNumberStyleAttr() + '&gt;&lt;/td&gt;';
		}
	},
</P><P>
	// Generates the HTML that goes before every other type of row generated by DayGrid. Ordering depends on isRTL.
	// Affects helper-skeleton and highlight-skeleton rows.
	introHtml: function() {
		if (this.weekNumbersVisible) {
			return '&lt;td class=&quot;fc-week-number&quot; ' + this.weekNumberStyleAttr() + '&gt;&lt;/td&gt;';
		}
	},
</P><P>
	// Generates the HTML for the &lt;td&gt;s of the &quot;number&quot; row in the DayGrid's content skeleton.
	// The number row will only exist if either day numbers or week numbers are turned on.
	numberCellHtml: function(cell) {
		var date = cell.start;
		var classes;
</P><P>		if (!this.dayNumbersVisible) { // if there are week numbers but not day numbers
			return '&lt;td/&gt;'; //  will create an empty space above events :(
		}
</P><P>		classes = this.dayGrid.getDayClasses(date);
		classes.unshift('fc-day-number');
</P><P>		return <I> +</I>
			'&lt;td class=&quot;' + classes.join(' ') + '&quot; data-date=&quot;' + date.format() + '&quot;&gt;' +
				date.date() +
			'&lt;/td&gt;';
	},
</P><P>
	// Generates an HTML attribute string for setting the width of the week number column, if it is known
	weekNumberStyleAttr: function() {
		if (this.weekNumberWidth !== null) {
			return 'style=&quot;width:' + this.weekNumberWidth + 'px&quot;';
		}
		return <I>;</I>
	},
</P><P>
	// Determines whether each row should have a constant height
	hasRigidRows: function() {
		var eventLimit = this.opt('eventLimit');
		return eventLimit &amp;&amp; typeof eventLimit !== 'number';
	},
</P><P>
	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		if (this.weekNumbersVisible) {
			// Make sure all week number cells running down the side have the same width.
			// Record the width for cells created later.
			this.weekNumberWidth = matchCellWidths(
				this.el.find('.fc-week-number')
			);
		}
	},
</P><P>
	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit = this.opt('eventLimit');
		var scrollerHeight;
</P><P>		// reset all heights to be natural
		unsetScroller(this.scrollerEl);
		uncompensateScroll(this.headRowEl);
</P><P>		this.dayGrid.removeSegPopover(); // kill the &quot;more&quot; popover if displayed
</P><P>		// is the event limit a constant level number?
		if (eventLimit &amp;&amp; typeof eventLimit === 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
		}
</P><P>		scrollerHeight = this.computeScrollerHeight(totalHeight);
		this.setGridHeight(scrollerHeight, isAuto);
</P><P>		// is the event limit dynamically calculated?
		if (eventLimit &amp;&amp; typeof eventLimit !== 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
		}
</P><P>		if (!isAuto &amp;&amp; setPotentialScroller(this.scrollerEl, scrollerHeight)) { // using scrollbars?
</P><P>			compensateScroll(this.headRowEl, getScrollbarWidths(this.scrollerEl));
</P><P>			// doing the scrollbar compensation might have created text overflow which created more height. redo
			scrollerHeight = this.computeScrollerHeight(totalHeight);
			this.scrollerEl.height(scrollerHeight);
		}
	},
</P><P>
	// Sets the height of just the DayGrid component in this view
	setGridHeight: function(height, isAuto) {
		if (isAuto) {
			undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
		}
		else {
			distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
		}
	},
</P><P>
	/* Events
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders the given events onto the view and populates the segments array
	renderEvents: function(events) {
		this.dayGrid.renderEvents(events);
</P><P>		this.updateHeight(); // must compensate for events that overflow the row
	},
</P><P>
	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.dayGrid.getEventSegs();
	},
</P><P>
	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {
		this.dayGrid.unrenderEvents();
</P><P>		// we DON'T need to call updateHeight() because:
		// A) a renderEvents() call always happens after this, which will eventually call updateHeight()
		// B) in IE8, this causes a flash whenever events are rerendered
	},
</P><P>
	/* Dragging (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// A returned value of `true` signals that a mock &quot;helper&quot; event has been rendered.
	renderDrag: function(dropLocation, seg) {
		return this.dayGrid.renderDrag(dropLocation, seg);
	},
</P><P>
	unrenderDrag: function() {
		this.dayGrid.unrenderDrag();
	},
</P><P>
	/* Selection
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a visual indication of a selection
	renderSelection: function(range) {
		this.dayGrid.renderSelection(range);
	},
</P><P>
	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.dayGrid.unrenderSelection();
	}
</P><P>});
</P><P>/* A month view with day cells running in rows (one-per-week) and columns
</P>*/
<P>var MonthView = BasicView.extend({
</P><P>	// Produces information about what range to display
	computeRange: function(date) {
		var range = BasicView.prototype.computeRange.call(this, date); // get value from super-method
		var rowCnt;
</P><P>		// ensure 6 weeks
		if (this.isFixedWeeks()) {
			rowCnt = Math.ceil(range.end.diff(range.start, 'weeks', true)); // could be partial weeks due to hiddenDays
			range.end.add(6 - rowCnt, 'weeks');
		}
</P><P>		return range;
	},
</P><P>
	// Overrides the default BasicView behavior to have special multi-week auto-height logic
	setGridHeight: function(height, isAuto) {
</P><P>		isAuto = isAuto || this.opt('weekMode') === 'variable'; // LEGACY: weekMode is deprecated
</P><P>		// if auto, make the height of each row the height that it would be if there were 6 weeks
		if (isAuto) {
			height *= this.rowCnt / 6;
		}
</P><P>		distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
	},
</P><P>
	isFixedWeeks: function() {
		var weekMode = this.opt('weekMode'); // LEGACY: weekMode is deprecated
		if (weekMode) {
			return weekMode === 'fixed'; // if any other type of weekMode, assume NOT fixed
		}
</P><P>		return this.opt('fixedWeekCount');
	}
</P><P>});
</P><P>fcViews.basic = {
	'class': BasicView
};
</P><P>fcViews.basicDay = {
	type: 'basic',
	duration: { days: 1 }
};
</P><P>fcViews.basicWeek = {
	type: 'basic',
	duration: { weeks: 1 }
};
</P><P>fcViews.month = {
	'class': MonthView,
	duration: { months: 1 }, // important for prev/next
	defaults: {
		fixedWeekCount: true
	}
};
</P><P>/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
</P>*/
<P>// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.
</P><P>var AgendaView = View.extend({
</P><P>	timeGrid: null, // the main time-grid subcomponent of this view
	dayGrid: null, // the &quot;all-day&quot; subcomponent. if all-day is turned off, this will be null
</P><P>	axisWidth: null, // the width of the time axis running down the side
</P><P>	noScrollRowEls: null, // set of fake row elements that must compensate when scrollerEl has scrollbars
</P>
	// when the time-grid isn't tall enough to occupy the given height, we render an  underneath
<P>	bottomRuleEl: null,
	bottomRuleHeight: null,
</P><P>
	initialize: function() {
		this.timeGrid = new TimeGrid(this);
</P><P>		if (this.opt('allDaySlot')) { // should we display the &quot;all-day&quot; area?
			this.dayGrid = new DayGrid(this); // the all-day subcomponent of this view
</P><P>			// the coordinate grid will be a combination of both subcomponents' grids
			this.coordMap = new ComboCoordMap([
				this.dayGrid.coordMap,
				this.timeGrid.coordMap
			]);
		}
		else {
			this.coordMap = this.timeGrid.coordMap;
		}
	},
</P><P>
	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Sets the display range and computes all necessary dates
	setRange: function(range) {
		View.prototype.setRange.call(this, range); // call the super-method
</P><P>		this.timeGrid.setRange(range);
		if (this.dayGrid) {
			this.dayGrid.setRange(range);
		}
	},
</P><P>
	// Renders the view into `this.el`, which has already been assigned
	renderDates: function() {
</P><P>		this.el.addClass('fc-agenda-view').html(this.renderHtml());
</P><P>		// the element that wraps the time-grid that will probably scroll
		this.scrollerEl = this.el.find('.fc-time-grid-container');
		this.timeGrid.coordMap.containerEl = this.scrollerEl; // don't accept clicks/etc outside of this
</P><P>		this.timeGrid.setElement(this.el.find('.fc-time-grid'));
		this.timeGrid.renderDates();
</P>
		// the  that sometimes displays under the time-grid
		this.bottomRuleEl = $('')
<P>			.appendTo(this.timeGrid.el); // inject it into the time-grid
</P><P>		if (this.dayGrid) {
			this.dayGrid.setElement(this.el.find('.fc-day-grid'));
			this.dayGrid.renderDates();
</P>
			// have the day-grid extend it's coordinate area over the  dividing the two grids
<P>			this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
		}
</P><P>		this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller
	},
</P><P>
	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill each grid's rendering.
	unrenderDates: function() {
		this.timeGrid.unrenderDates();
		this.timeGrid.removeElement();
</P><P>		if (this.dayGrid) {
			this.dayGrid.unrenderDates();
			this.dayGrid.removeElement();
		}
	},
</P><P>
	renderBusinessHours: function() {
		this.timeGrid.renderBusinessHours();
</P><P>		if (this.dayGrid) {
			this.dayGrid.renderBusinessHours();
		}
	},
</P><P>
	// Builds the HTML skeleton for the view.
	// The day-grid and time-grid components will render inside containers defined by this HTML.
	renderHtml: function() {
		return <I> +</I></P>
			'<TABLE>' +
				'&lt;thead class=&quot;fc-head&quot;&gt;' +
					'<TBODY><TR>' +
						'<TD class="' + this.widgetHeaderClass + '">' +
<P>							this.timeGrid.headHtml() + // render the day-of-week headers
</P>
						'</TD>' +
					'</TR>' +
				'&lt;/thead&gt;' +
				'&lt;tbody class=&quot;fc-body&quot;&gt;' +
					'<TR>' +
						'<TD class="' + this.widgetContentClass + '">' +
<P>							(this.dayGrid ?
								'&lt;div class=&quot;fc-day-grid&quot;/&gt;' +
</P>
								'' :
<P>								
								) +
</P>
							'<DIV class="fc-time-grid-container">' +
<P>								'&lt;div class=&quot;fc-time-grid&quot;/&gt;' +
</P>
							'</DIV>' +
						'</TD>' +
					'</TR>' +
				'&lt;/tbody&gt;' +
			'</TBODY></TABLE>';
<P>	},
</P><P>
	// Generates the HTML that will go before the day-of week header cells.
	// Queried by the TimeGrid subcomponent when generating rows. Ordering depends on isRTL.
	headIntroHtml: function() {
		var date;
		var weekText;
</P><P>		if (this.opt('weekNumbers')) {
			date = this.timeGrid.getCell(0).start;
			weekText = date.format(this.opt('smallWeekFormat'));
</P><P>			return <I> +</I>
				'&lt;th class=&quot;fc-axis fc-week-number ' + this.widgetHeaderClass + '&quot; ' + this.axisStyleAttr() + '&gt;' +
					'<SPAN>' + // needed for matchCellWidths
						htmlEscape(weekText) +
					'</SPAN>' +
				'&lt;/th&gt;';
		}
		else {
			return '&lt;th class=&quot;fc-axis ' + this.widgetHeaderClass + '&quot; ' + this.axisStyleAttr() + '&gt;&lt;/th&gt;';
		}
	},
</P><P>
	// Generates the HTML that goes before the all-day cells.
	// Queried by the DayGrid subcomponent when generating rows. Ordering depends on isRTL.
	dayIntroHtml: function() {
		return <I> +</I>
			'&lt;td class=&quot;fc-axis ' + this.widgetContentClass + '&quot; ' + this.axisStyleAttr() + '&gt;' +
				'<SPAN>' + // needed for matchCellWidths
					(this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'))) +
				'</SPAN>' +
			'&lt;/td&gt;';
	},
</P><P>
	// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
	slotBgIntroHtml: function() {
		return '&lt;td class=&quot;fc-axis ' + this.widgetContentClass + '&quot; ' + this.axisStyleAttr() + '&gt;&lt;/td&gt;';
	},
</P><P>
	// Generates the HTML that goes before all other types of cells.
	// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
	// Queried by the TimeGrid and DayGrid subcomponents when generating rows. Ordering depends on isRTL.
	introHtml: function() {
		return '&lt;td class=&quot;fc-axis&quot; ' + this.axisStyleAttr() + '&gt;&lt;/td&gt;';
	},
</P><P>
	// Generates an HTML attribute string for setting the width of the axis, if it is known
	axisStyleAttr: function() {
		if (this.axisWidth !== null) {
			 return 'style=&quot;width:' + this.axisWidth + 'px&quot;';
		}
		return <I>;</I>
	},
</P><P>
	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	updateSize: function(isResize) {
		this.timeGrid.updateSize(isResize);
</P><P>		View.prototype.updateSize.call(this, isResize); // call the super-method
	},
</P><P>
	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		// make all axis cells line up, and record the width so newly created axis cells will have it
		this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));
	},
</P><P>
	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit;
		var scrollerHeight;
</P><P>		if (this.bottomRuleHeight === null) {
			// calculate the height of the rule the very first time
			this.bottomRuleHeight = this.bottomRuleEl.outerHeight();
		}
</P>
		this.bottomRuleEl.hide(); // .show() will be called later if this  is necessary
<P>		// reset all dimensions back to the original state
		this.scrollerEl.css('overflow', <I>);</I>
		unsetScroller(this.scrollerEl);
		uncompensateScroll(this.noScrollRowEls);
</P><P>		// limit number of events in the all-day area
		if (this.dayGrid) {
			this.dayGrid.removeSegPopover(); // kill the &quot;more&quot; popover if displayed
</P><P>			eventLimit = this.opt('eventLimit');
			if (eventLimit &amp;&amp; typeof eventLimit !== 'number') {
				eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure &quot;auto&quot; goes to a real number
			}
			if (eventLimit) {
				this.dayGrid.limitRows(eventLimit);
			}
		}
</P><P>		if (!isAuto) { // should we force dimensions of the scroll container, or let the contents be natural height?
</P><P>			scrollerHeight = this.computeScrollerHeight(totalHeight);
			if (setPotentialScroller(this.scrollerEl, scrollerHeight)) { // using scrollbars?
</P><P>				// make the all-day and header rows lines up
				compensateScroll(this.noScrollRowEls, getScrollbarWidths(this.scrollerEl));
</P><P>				// the scrollbar compensation might have changed text flow, which might affect height, so recalculate
				// and reapply the desired height to the scroller.
				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.scrollerEl.height(scrollerHeight);
			}
			else { // no scrollbars
				// still, force a height and display the bottom rule (marks the end of day)
</P>
				this.scrollerEl.height(scrollerHeight).css('overflow', 'hidden'); // in case  goes outside
<P>				this.bottomRuleEl.show();
			}
		}
	},
</P><P>
	// Computes the initial pre-configured scroll state prior to allowing the user to change it
	computeInitialScroll: function() {
		var scrollTime = moment.duration(this.opt('scrollTime'));
		var top = this.timeGrid.computeTimeTop(scrollTime);
</P><P>		// zoom can give weird floating-point values. rather scroll a little bit further
		top = Math.ceil(top);
</P><P>		if (top) {
			top++; // to overcome top border that slots beyond the first have. looks better
		}
</P><P>		return top;
	},
</P><P>
	/* Events
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders events onto the view and populates the View's segment array
	renderEvents: function(events) {
		var dayEvents = [];
		var timedEvents = [];
		var daySegs = [];
		var timedSegs;
		var i;
</P><P>		// separate the events into all-day and timed
		for (i = 0; i &lt; events.length; i++) {
			if (events[i].allDay) {
				dayEvents.push(events[i]);
			}
			else {
				timedEvents.push(events[i]);
			}
		}
</P><P>		// render the events in the subcomponents
		timedSegs = this.timeGrid.renderEvents(timedEvents);
		if (this.dayGrid) {
			daySegs = this.dayGrid.renderEvents(dayEvents);
		}
</P><P>		// the all-day area is flexible and might have a lot of events, so shift the height
		this.updateHeight();
	},
</P><P>
	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.timeGrid.getEventSegs().concat(
			this.dayGrid ? this.dayGrid.getEventSegs() : []
		);
	},
</P><P>
	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {
</P><P>		// unrender the events in the subcomponents
		this.timeGrid.unrenderEvents();
		if (this.dayGrid) {
			this.dayGrid.unrenderEvents();
		}
</P><P>		// we DON'T need to call updateHeight() because:
		// A) a renderEvents() call always happens after this, which will eventually call updateHeight()
		// B) in IE8, this causes a flash whenever events are rerendered
	},
</P><P>
	/* Dragging (for events and external elements)
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// A returned value of `true` signals that a mock &quot;helper&quot; event has been rendered.
	renderDrag: function(dropLocation, seg) {
		if (dropLocation.start.hasTime()) {
			return this.timeGrid.renderDrag(dropLocation, seg);
		}
		else if (this.dayGrid) {
			return this.dayGrid.renderDrag(dropLocation, seg);
		}
	},
</P><P>
	unrenderDrag: function() {
		this.timeGrid.unrenderDrag();
		if (this.dayGrid) {
			this.dayGrid.unrenderDrag();
		}
	},
</P><P>
	/* Selection
	------------------------------------------------------------------------------------------------------------------*/
</P><P>
	// Renders a visual indication of a selection
	renderSelection: function(range) {
		if (range.start.hasTime() || range.end.hasTime()) {
			this.timeGrid.renderSelection(range);
		}
		else if (this.dayGrid) {
			this.dayGrid.renderSelection(range);
		}
	},
</P><P>
	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.timeGrid.unrenderSelection();
		if (this.dayGrid) {
			this.dayGrid.unrenderSelection();
		}
	}
</P><P>});
</P><P>var AGENDA_ALL_DAY_EVENT_LIMIT = 5;
</P><P>fcViews.agenda = {
	'class': AgendaView,
	defaults: {
		allDaySlot: true,
		allDayText: 'all-day',
		slotDuration: '00:30:00',
		minTime: '00:00:00',
		maxTime: '24:00:00',
		slotEventOverlap: true // a bad name. confused with overlap/constraint system
	}
};
</P><P>fcViews.agendaDay = {
	type: 'agenda',
	duration: { days: 1 }
};
</P><P>fcViews.agendaWeek = {
	type: 'agenda',
	duration: { weeks: 1 }
};
</P><P>return fc; // export for Node/CommonJS
});
</P></TABLE></DIV></DIV></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_CityU_HK_Template_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:CityU HK/Template/js</SPAN></H1><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/****************************
</P><PRE>   custom js
</PRE><UL><LI>/</LI></UL><P>jQuery(function($) {
</P><PRE> // Mobile sidebars
 $.fn.expandableSidebar = function(expandedClass) {
   var $me = this;
</PRE><PRE>   $me.on('click', function() {
     if(!$me.hasClass(expandedClass)) {
       $me.addClass(expandedClass);
     } else {
       $me.removeClass(expandedClass);
     }
   });
 }
 
 // Interval loop
 $.fn.intervalLoop = function(condition, action, duration, limit) {
   var counter = 0;
   var looper = setInterval(function(){
     if (counter &gt;= limit || $.fn.checkIfElementExists(condition)) {
       clearInterval(looper);
     } else {
       action();
       counter++;
     }
   }, duration);
 }
</PRE><PRE> // Check if element exists
 $.fn.checkIfElementExists = function(selector) {
   return $(selector).length;
 }
</PRE><PRE> var parisController = {
</PRE><PRE>   init: function(opts) {
     var base = this;
</PRE><PRE>     // Add classes to elements
     base._addClasses();
</PRE><PRE>     setTimeout(function(){
       base._checkCartItems();
       base._attachEvents();
     }, 1000);
   },
</PRE><PRE>   _addClasses: function() {
     var base = this;
</PRE><PRE>     // Add fade in class to nav + logo
     $('.landing-page').addClass('fade-in');
</PRE><PRE>     // Add class to nav items with subnav
     $('.wsite-menu-default').find('li.wsite-menu-item-wrap').each(function(){
       var $me = $(this);
</PRE><PRE>       if($me.children('.wsite-menu-wrap').length &gt; 0) {
</PRE><PRE>         $me.addClass('has-submenu');
         $('').insertAfter($me.children('a.wsite-menu-item'));
       }
     });
</PRE><PRE>     // ADd class to subnav items with subnav
     $('.wsite-menu').find('li.wsite-menu-subitem-wrap').each(function(){
       var $me = $(this);
</PRE><PRE>       if($me.children('.wsite-menu-wrap').length &gt; 0) {
</PRE><PRE>         $me.addClass('has-submenu');
         $('').insertAfter($me.children('a.wsite-menu-subitem'));
       }
     });
</PRE><PRE>     // Keep subnav open if submenu item is active
     $('.wsite-menu-wrap').find('li.wsite-menu-subitem-wrap').each(function(){
       var $me = $(this);
</PRE><PRE>       if($me.hasClass('wsite-nav-current')) {
         $me.parents().addClass('open');
       }
     });
</PRE><PRE>     // Add placeholder text to inputs
     $('.wsite-form-sublabel').each(function(){
       var sublabel = $(this).text();
       $(this).prev('.wsite-form-input').attr('placeholder', sublabel);
     });
</PRE><PRE>     // Add fullwidth class to gallery thumbs if less than 6
     $('.imageGallery').each(function(){
       if ($(this).children('div').length &lt;= 6) {
         $(this).children('div').addClass('fullwidth-mobile');
       }
     });
   },
</PRE><PRE>   _checkCartItems: function() {
     var base = this;
     
     if($('#wsite-mini-cart').find('li.wsite-product-item').length &gt; 0) {
       $('body').addClass('cart-full');
     } else {
       $('body').removeClass('cart-full');
     }
   },
</PRE><PRE>   _moveLogin: function() {
     var loginDetach = $('#member-login').detach();
     $('.mobile-nav .wsite-menu-default li:last-child').after(loginDetach);
   },
</PRE><PRE>   _attachEvents: function() {
     var base = this;
</PRE><PRE>     // Move cart + login
     if ($(window).width() &lt;= 992) {
       $.fn.intervalLoop('.mobile-nav #member-login', base._moveLogin, 800, 5);
     }
</PRE><PRE>     // Subnav toggle
     $('li.has-submenu').each(function(){
       var $me = $(this);
       var caret = $me.children('span.icon-caret');
</PRE><PRE>       caret.on('click', function(){          
         if($me.children('.wsite-menu-wrap.open').length &gt; 0) {
           caret.siblings('.wsite-menu-wrap').removeClass('open');
         } else {
           caret.siblings('.wsite-menu-wrap').addClass('open');
         }
       });
     });
</PRE><PRE>     // Scroll on landing page
     $('#contentArrow').on('click', function() {
       $('html, body').animate({
         scrollTop: $('.main-wrap').offset().top - $('.paris-header').outerHeight()
       }, 500);
     });
</PRE><PRE>     // Store category dropdown
     $('.wsite-com-sidebar').expandableSidebar('sidebar-expanded');
</PRE><PRE>     // Search filters dropdown
     $('#wsite-search-sidebar').expandableSidebar('sidebar-expanded');
</PRE><PRE>     // Init fancybox swipe on mobile
     if ('ontouchstart' in window) {
       $('body').on('click', 'a.w-fancybox', function() {
         base._initSwipeGallery();
       });
     }
   },
</PRE><PRE>   _initSwipeGallery: function() {
     var base = this;
</PRE><PRE>     setTimeout(function(){
       var touchGallery = document.getElementsByClassName('fancybox-wrap')[0];
       var mc = new Hammer(touchGallery);
       mc.on(&quot;panleft panright&quot;, function(ev) {
         if (ev.type == &quot;panleft&quot;) {
           $(&quot;a.fancybox-next&quot;).trigger(&quot;click&quot;);
         } else if (ev.type == &quot;panright&quot;) {
           $(&quot;a.fancybox-prev&quot;).trigger(&quot;click&quot;);
         }
         base._initSwipeGallery();
       });
     }, 500);
   }
 } 
</PRE><PRE> $(document).ready(function(){
   parisController.init();
 }); 
</PRE><P>});
</P><P>/***********************************
</P><PRE>   Plugin js
</PRE><UL><LI>/</LI></UL><P>/*! Hammer.JS - v2.0.4 - 2014-09-28
</P><PRE>* <A rel="nofollow" class="external free" href="http://hammerjs.github.io/">http://hammerjs.github.io/</A>
*
* Copyright (c) 2014 Jorik Tangelder;
* Licensed under the MIT license */
</PRE><P>(function(window, document, exportName, undefined) {
</P><PRE> 'use strict';
</PRE><P>var VENDOR_PREFIXES = [<I>, 'webkit', 'moz', 'MS', 'ms', 'o'];</I>
var TEST_ELEMENT = document.createElement('div');
</P><P>var TYPE_FUNCTION = 'function';
</P><P>var round = Math.round;
var abs = Math.abs;
var now = Date.now;
</P><P>/**
</P><PRE>* set a timeout with a given scope
* @param {Function} fn
* @param {Number} timeout
* @param {Object} context
* @returns {number}
*/
</PRE><P>function setTimeoutContext(fn, timeout, context) {
</P><PRE>   return setTimeout(bindFn(fn, context), timeout);
</PRE><P>}
</P><P>/**
</P><PRE>* if the argument is an array, we want to execute the fn on each entry
* if it aint an array we don't want to do a thing.
* this is used by all the methods that accept a single and array argument.
* @param {*|Array} arg
* @param {String} fn
* @param {Object} [context]
* @returns {Boolean}
*/
</PRE><P>function invokeArrayArg(arg, fn, context) {
</P><PRE>   if (Array.isArray(arg)) {
       each(arg, context[fn], context);
       return true;
   }
   return false;
</PRE><P>}
</P><P>/**
</P><PRE>* walk objects and arrays
* @param {Object} obj
* @param {Function} iterator
* @param {Object} context
*/
</PRE><P>function each(obj, iterator, context) {
</P><PRE>   var i;
</PRE><PRE>   if (!obj) {
       return;
   }
</PRE><PRE>   if (obj.forEach) {
       obj.forEach(iterator, context);
   } else if (obj.length !== undefined) {
       i = 0;
       while (i &lt; obj.length) {
           iterator.call(context, obj[i], i, obj);
           i++;
       }
   } else {
       for (i in obj) {
           obj.hasOwnProperty(i) &amp;&amp; iterator.call(context, obj[i], i, obj);
       }
   }
</PRE><P>}
</P><P>/**
</P><PRE>* extend object.
* means that properties in dest will be overwritten by the ones in src.
* @param {Object} dest
* @param {Object} src
* @param {Boolean} [merge]
* @returns {Object} dest
*/
</PRE><P>function extend(dest, src, merge) {
</P><PRE>   var keys = Object.keys(src);
   var i = 0;
   while (i &lt; keys.length) {
       if (!merge || (merge &amp;&amp; dest[keys[i]] === undefined)) {
           dest[keys[i]] = src[keys[i]];
       }
       i++;
   }
   return dest;
</PRE><P>}
</P><P>/**
</P><PRE>* merge the values from src in the dest.
* means that properties that exist in dest will not be overwritten by src
* @param {Object} dest
* @param {Object} src
* @returns {Object} dest
*/
</PRE><P>function merge(dest, src) {
</P><PRE>   return extend(dest, src, true);
</PRE><P>}
</P><P>/**
</P><PRE>* simple class inheritance
* @param {Function} child
* @param {Function} base
* @param {Object} [properties]
*/
</PRE><P>function inherit(child, base, properties) {
</P><PRE>   var baseP = base.prototype,
       childP;
</PRE><PRE>   childP = child.prototype = Object.create(baseP);
   childP.constructor = child;
   childP._super = baseP;
</PRE><PRE>   if (properties) {
       extend(childP, properties);
   }
</PRE><P>}
</P><P>/**
</P><PRE>* simple function bind
* @param {Function} fn
* @param {Object} context
* @returns {Function}
*/
</PRE><P>function bindFn(fn, context) {
</P><PRE>   return function boundFn() {
       return fn.apply(context, arguments);
   };
</PRE><P>}
</P><P>/**
</P><PRE>* let a boolean value also be a function that must return a boolean
* this first item in args will be used as the context
* @param {Boolean|Function} val
* @param {Array} [args]
* @returns {Boolean}
*/
</PRE><P>function boolOrFn(val, args) {
</P><PRE>   if (typeof val == TYPE_FUNCTION) {
       return val.apply(args ? args[0] || undefined : undefined, args);
   }
   return val;
</PRE><P>}
</P><P>/**
</P><PRE>* use the val2 when val1 is undefined
* @param {*} val1
* @param {*} val2
* @returns {*}
*/
</PRE><P>function ifUndefined(val1, val2) {
</P><PRE>   return (val1 === undefined) ? val2 : val1;
</PRE><P>}
</P><P>/**
</P><PRE>* addEventListener with multiple events at once
* @param {EventTarget} target
* @param {String} types
* @param {Function} handler
*/
</PRE><P>function addEventListeners(target, types, handler) {
</P><PRE>   each(splitStr(types), function(type) {
       target.addEventListener(type, handler, false);
   });
</PRE><P>}
</P><P>/**
</P><PRE>* removeEventListener with multiple events at once
* @param {EventTarget} target
* @param {String} types
* @param {Function} handler
*/
</PRE><P>function removeEventListeners(target, types, handler) {
</P><PRE>   each(splitStr(types), function(type) {
       target.removeEventListener(type, handler, false);
   });
</PRE><P>}
</P><P>/**
</P><PRE>* find if a node is in the given parent
* @method hasParent
* @param {HTMLElement} node
* @param {HTMLElement} parent
* @return {Boolean} found
*/
</PRE><P>function hasParent(node, parent) {
</P><PRE>   while (node) {
       if (node == parent) {
           return true;
       }
       node = node.parentNode;
   }
   return false;
</PRE><P>}
</P><P>/**
</P><PRE>* small indexOf wrapper
* @param {String} str
* @param {String} find
* @returns {Boolean} found
*/
</PRE><P>function inStr(str, find) {
</P><PRE>   return str.indexOf(find) &gt; -1;
</PRE><P>}
</P><P>/**
</P><PRE>* split string on whitespace
* @param {String} str
* @returns {Array} words
*/
</PRE><P>function splitStr(str) {
</P><PRE>   return str.trim().split(/\s+/g);
</PRE><P>}
</P><P>/**
</P><PRE>* find if a array contains the object using indexOf or a simple polyFill
* @param {Array} src
* @param {String} find
* @param {String} [findByKey]
* @return {Boolean|Number} false when not found, or the index
*/
</PRE><P>function inArray(src, find, findByKey) {
</P><PRE>   if (src.indexOf &amp;&amp; !findByKey) {
       return src.indexOf(find);
   } else {
       var i = 0;
       while (i &lt; src.length) {
           if ((findByKey &amp;&amp; src[i][findByKey] == find) || (!findByKey &amp;&amp; src[i] === find)) {
               return i;
           }
           i++;
       }
       return -1;
   }
</PRE><P>}
</P><P>/**
</P><PRE>* convert array-like objects to real arrays
* @param {Object} obj
* @returns {Array}
*/
</PRE><P>function toArray(obj) {
</P><PRE>   return Array.prototype.slice.call(obj, 0);
</PRE><P>}
</P><P>/**
</P><PRE>* unique array with objects based on a key (like 'id') or just by the array's value
* @param {Array} src [{id:1},{id:2},{id:1}]
* @param {String} [key]
* @param {Boolean} [sort=False]
* @returns {Array} [{id:1},{id:2}]
*/
</PRE><P>function uniqueArray(src, key, sort) {
</P><PRE>   var results = [];
   var values = [];
   var i = 0;
</PRE><PRE>   while (i &lt; src.length) {
       var val = key ? src[i][key] : src[i];
       if (inArray(values, val) &lt; 0) {
           results.push(src[i]);
       }
       values[i] = val;
       i++;
   }
</PRE><PRE>   if (sort) {
       if (!key) {
           results = results.sort();
       } else {
           results = results.sort(function sortUniqueArray(a, b) {
               return a[key] &gt; b[key];
           });
       }
   }
</PRE><PRE>   return results;
</PRE><P>}
</P><P>/**
</P><PRE>* get the prefixed property
* @param {Object} obj
* @param {String} property
* @returns {String|Undefined} prefixed
*/
</PRE><P>function prefixed(obj, property) {
</P><PRE>   var prefix, prop;
   var camelProp = property[0].toUpperCase() + property.slice(1);
</PRE><PRE>   var i = 0;
   while (i &lt; VENDOR_PREFIXES.length) {
       prefix = VENDOR_PREFIXES[i];
       prop = (prefix) ? prefix + camelProp : property;
</PRE><PRE>       if (prop in obj) {
           return prop;
       }
       i++;
   }
   return undefined;
</PRE><P>}
</P><P>/**
</P><PRE>* get a unique id
* @returns {number} uniqueId
*/
</PRE><P>var _uniqueId = 1;
function uniqueId() {
</P><PRE>   return _uniqueId++;
</PRE><P>}
</P><P>/**
</P><PRE>* get the window object of an element
* @param {HTMLElement} element
* @returns {DocumentView|Window}
*/
</PRE><P>function getWindowForElement(element) {
</P><PRE>   var doc = element.ownerDocument;
   return (doc.defaultView || doc.parentWindow);
</PRE><P>}
</P><P>var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
</P><P>var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH &amp;&amp; MOBILE_REGEX.test(navigator.userAgent);
</P><P>var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';
</P><P>var COMPUTE_INTERVAL = 25;
</P><P>var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;
</P><P>var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
</P><P>var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
</P><P>var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];
</P><P>/**
</P><PRE>* create new input type manager
* @param {Manager} manager
* @param {Function} callback
* @returns {Input}
* @constructor
*/
</PRE><P>function Input(manager, callback) {
</P><PRE>   var self = this;
   this.manager = manager;
   this.callback = callback;
   this.element = manager.element;
   this.target = manager.options.inputTarget;
</PRE><PRE>   // smaller wrapper around the handler, for the scope and the enabled state of the manager,
   // so when disabled the input events are completely bypassed.
   this.domHandler = function(ev) {
       if (boolOrFn(manager.options.enable, [manager])) {
           self.handler(ev);
       }
   };
</PRE><PRE>   this.init();
</PRE><P>}
</P><P>Input.prototype = {
</P><PRE>   /**
    * should handle the inputEvent data and trigger the callback
    * @virtual
    */
   handler: function() { },
</PRE><PRE>   /**
    * bind the events
    */
   init: function() {
       this.evEl &amp;&amp; addEventListeners(this.element, this.evEl, this.domHandler);
       this.evTarget &amp;&amp; addEventListeners(this.target, this.evTarget, this.domHandler);
       this.evWin &amp;&amp; addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
   },
</PRE><PRE>  /**
    * unbind the events
    */
   destroy: function() {
       this.evEl &amp;&amp; removeEventListeners(this.element, this.evEl, this.domHandler);
       this.evTarget &amp;&amp; removeEventListeners(this.target, this.evTarget, this.domHandler);
       this.evWin &amp;&amp; removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
   }
</PRE><P>};
</P><P>/**
</P><PRE>* create new input type manager
* called by the Manager constructor
* @param {Hammer} manager
* @returns {Input}
*/
</PRE><P>function createInputInstance(manager) {
</P><PRE>   var Type;
   var inputClass = manager.options.inputClass;
</PRE><PRE>   if (inputClass) {
       Type = inputClass;
   } else if (SUPPORT_POINTER_EVENTS) {
       Type = PointerEventInput;
   } else if (SUPPORT_ONLY_TOUCH) {
       Type = TouchInput;
   } else if (!SUPPORT_TOUCH) {
       Type = MouseInput;
   } else {
       Type = TouchMouseInput;
   }
   return new (Type)(manager, inputHandler);
</PRE><P>}
</P><P>/**
</P><PRE>* handle input events
* @param {Manager} manager
* @param {String} eventType
* @param {Object} input
*/
</PRE><P>function inputHandler(manager, eventType, input) {
</P><PRE>   var pointersLen = input.pointers.length;
   var changedPointersLen = input.changedPointers.length;
   var isFirst = (eventType &amp; INPUT_START &amp;&amp; (pointersLen - changedPointersLen === 0));
   var isFinal = (eventType &amp; (INPUT_END | INPUT_CANCEL) &amp;&amp; (pointersLen - changedPointersLen === 0));
</PRE><PRE>   input.isFirst = !!isFirst;
   input.isFinal = !!isFinal;
</PRE><PRE>   if (isFirst) {
       manager.session = {};
   }
</PRE><PRE>   // source event is the normalized value of the domEvents
   // like 'touchstart, mouseup, pointerdown'
   input.eventType = eventType;
</PRE><PRE>   // compute scale, rotation etc
   computeInputData(manager, input);
</PRE><PRE>   // emit secret event
   manager.emit('hammer.input', input);
</PRE><PRE>   manager.recognize(input);
   manager.session.prevInput = input;
</PRE><P>}
</P><P>/**
</P><PRE>* extend the data with some usable properties like scale, rotate, velocity etc
* @param {Object} manager
* @param {Object} input
*/
</PRE><P>function computeInputData(manager, input) {
</P><PRE>   var session = manager.session;
   var pointers = input.pointers;
   var pointersLength = pointers.length;
</PRE><PRE>   // store the first input to calculate the distance and direction
   if (!session.firstInput) {
       session.firstInput = simpleCloneInputData(input);
   }
</PRE><PRE>   // to compute scale and rotation we need to store the multiple touches
   if (pointersLength &gt; 1 &amp;&amp; !session.firstMultiple) {
       session.firstMultiple = simpleCloneInputData(input);
   } else if (pointersLength === 1) {
       session.firstMultiple = false;
   }
</PRE><PRE>   var firstInput = session.firstInput;
   var firstMultiple = session.firstMultiple;
   var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
</PRE><PRE>   var center = input.center = getCenter(pointers);
   input.timeStamp = now();
   input.deltaTime = input.timeStamp - firstInput.timeStamp;
</PRE><PRE>   input.angle = getAngle(offsetCenter, center);
   input.distance = getDistance(offsetCenter, center);
</PRE><PRE>   computeDeltaXY(session, input);
   input.offsetDirection = getDirection(input.deltaX, input.deltaY);
</PRE><PRE>   input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
   input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
</PRE><PRE>   computeIntervalInputData(session, input);
</PRE><PRE>   // find the correct target
   var target = manager.element;
   if (hasParent(input.srcEvent.target, target)) {
       target = input.srcEvent.target;
   }
   input.target = target;
</PRE><P>}
</P><P>function computeDeltaXY(session, input) {
</P><PRE>   var center = input.center;
   var offset = session.offsetDelta || {};
   var prevDelta = session.prevDelta || {};
   var prevInput = session.prevInput || {};
</PRE><PRE>   if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
       prevDelta = session.prevDelta = {
           x: prevInput.deltaX || 0,
           y: prevInput.deltaY || 0
       };
</PRE><PRE>       offset = session.offsetDelta = {
           x: center.x,
           y: center.y
       };
   }
</PRE><PRE>   input.deltaX = prevDelta.x + (center.x - offset.x);
   input.deltaY = prevDelta.y + (center.y - offset.y);
</PRE><P>}
</P><P>/**
</P><PRE>* velocity is calculated every x ms
* @param {Object} session
* @param {Object} input
*/
</PRE><P>function computeIntervalInputData(session, input) {
</P><PRE>   var last = session.lastInterval || input,
       deltaTime = input.timeStamp - last.timeStamp,
       velocity, velocityX, velocityY, direction;
</PRE><PRE>   if (input.eventType != INPUT_CANCEL &amp;&amp; (deltaTime &gt; COMPUTE_INTERVAL || last.velocity === undefined)) {
       var deltaX = last.deltaX - input.deltaX;
       var deltaY = last.deltaY - input.deltaY;
</PRE><PRE>       var v = getVelocity(deltaTime, deltaX, deltaY);
       velocityX = v.x;
       velocityY = v.y;
       velocity = (abs(v.x) &gt; abs(v.y)) ? v.x : v.y;
       direction = getDirection(deltaX, deltaY);
</PRE><PRE>       session.lastInterval = input;
   } else {
       // use latest velocity info if it doesn't overtake a minimum period
       velocity = last.velocity;
       velocityX = last.velocityX;
       velocityY = last.velocityY;
       direction = last.direction;
   }
</PRE><PRE>   input.velocity = velocity;
   input.velocityX = velocityX;
   input.velocityY = velocityY;
   input.direction = direction;
</PRE><P>}
</P><P>/**
</P><PRE>* create a simple clone from the input used for storage of firstInput and firstMultiple
* @param {Object} input
* @returns {Object} clonedInputData
*/
</PRE><P>function simpleCloneInputData(input) {
</P><PRE>   // make a simple copy of the pointers because we will get a reference if we don't
   // we only need clientXY for the calculations
   var pointers = [];
   var i = 0;
   while (i &lt; input.pointers.length) {
       pointers[i] = {
           clientX: round(input.pointers[i].clientX),
           clientY: round(input.pointers[i].clientY)
       };
       i++;
   }
</PRE><PRE>   return {
       timeStamp: now(),
       pointers: pointers,
       center: getCenter(pointers),
       deltaX: input.deltaX,
       deltaY: input.deltaY
   };
</PRE><P>}
</P><P>/**
</P><PRE>* get the center of all the pointers
* @param {Array} pointers
* @return {Object} center contains `x` and `y` properties
*/
</PRE><P>function getCenter(pointers) {
</P><PRE>   var pointersLength = pointers.length;
</PRE><PRE>   // no need to loop when only one touch
   if (pointersLength === 1) {
       return {
           x: round(pointers[0].clientX),
           y: round(pointers[0].clientY)
       };
   }
</PRE><PRE>   var x = 0, y = 0, i = 0;
   while (i &lt; pointersLength) {
       x += pointers[i].clientX;
       y += pointers[i].clientY;
       i++;
   }
</PRE><PRE>   return {
       x: round(x / pointersLength),
       y: round(y / pointersLength)
   };
</PRE><P>}
</P><P>/**
</P><PRE>* calculate the velocity between two points. unit is in px per ms.
* @param {Number} deltaTime
* @param {Number} x
* @param {Number} y
* @return {Object} velocity `x` and `y`
*/
</PRE><P>function getVelocity(deltaTime, x, y) {
</P><PRE>   return {
       x: x / deltaTime || 0,
       y: y / deltaTime || 0
   };
</PRE><P>}
</P><P>/**
</P><PRE>* get the direction between two points
* @param {Number} x
* @param {Number} y
* @return {Number} direction
*/
</PRE><P>function getDirection(x, y) {
</P><PRE>   if (x === y) {
       return DIRECTION_NONE;
   }
</PRE><PRE>   if (abs(x) &gt;= abs(y)) {
       return x &gt; 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
   }
   return y &gt; 0 ? DIRECTION_UP : DIRECTION_DOWN;
</PRE><P>}
</P><P>/**
</P><PRE>* calculate the absolute distance between two points
* @param {Object} p1 {x, y}
* @param {Object} p2 {x, y}
* @param {Array} [props] containing x and y keys
* @return {Number} distance
*/
</PRE><P>function getDistance(p1, p2, props) {
</P><PRE>   if (!props) {
       props = PROPS_XY;
   }
   var x = p2[props[0]] - p1[props[0]],
       y = p2[props[1]] - p1[props[1]];
</PRE><PRE>   return Math.sqrt((x * x) + (y * y));
</PRE><P>}
</P><P>/**
</P><PRE>* calculate the angle between two coordinates
* @param {Object} p1
* @param {Object} p2
* @param {Array} [props] containing x and y keys
* @return {Number} angle
*/
</PRE><P>function getAngle(p1, p2, props) {
</P><PRE>   if (!props) {
       props = PROPS_XY;
   }
   var x = p2[props[0]] - p1[props[0]],
       y = p2[props[1]] - p1[props[1]];
   return Math.atan2(y, x) * 180 / Math.PI;
</PRE><P>}
</P><P>/**
</P><PRE>* calculate the rotation degrees between two pointersets
* @param {Array} start array of pointers
* @param {Array} end array of pointers
* @return {Number} rotation
*/
</PRE><P>function getRotation(start, end) {
</P><PRE>   return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
</PRE><P>}
</P><P>/**
</P><PRE>* calculate the scale factor between two pointersets
* no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
* @param {Array} start array of pointers
* @param {Array} end array of pointers
* @return {Number} scale
*/
</PRE><P>function getScale(start, end) {
</P><PRE>   return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
</PRE><P>}
</P><P>var MOUSE_INPUT_MAP = {
</P><PRE>   mousedown: INPUT_START,
   mousemove: INPUT_MOVE,
   mouseup: INPUT_END
</PRE><P>};
</P><P>var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
</P><P>/**
</P><PRE>* Mouse events input
* @constructor
* @extends Input
*/
</PRE><P>function MouseInput() {
</P><PRE>   this.evEl = MOUSE_ELEMENT_EVENTS;
   this.evWin = MOUSE_WINDOW_EVENTS;
</PRE><PRE>   this.allow = true; // used by Input.TouchMouse to disable mouse events
   this.pressed = false; // mousedown state
</PRE><PRE>   Input.apply(this, arguments);
</PRE><P>}
</P><P>inherit(MouseInput, Input, {
</P><PRE>   /**
    * handle mouse events
    * @param {Object} ev
    */
   handler: function MEhandler(ev) {
       var eventType = MOUSE_INPUT_MAP[ev.type];
</PRE><PRE>       // on start we want to have the left mouse button down
       if (eventType &amp; INPUT_START &amp;&amp; ev.button === 0) {
           this.pressed = true;
       }
</PRE><PRE>       if (eventType &amp; INPUT_MOVE &amp;&amp; ev.which !== 1) {
           eventType = INPUT_END;
       }
</PRE><PRE>       // mouse must be down, and mouse events are allowed (see the TouchMouse input)
       if (!this.pressed || !this.allow) {
           return;
       }
</PRE><PRE>       if (eventType &amp; INPUT_END) {
           this.pressed = false;
       }
</PRE><PRE>       this.callback(this.manager, eventType, {
           pointers: [ev],
           changedPointers: [ev],
           pointerType: INPUT_TYPE_MOUSE,
           srcEvent: ev
       });
   }
</PRE><P>});
</P><P>var POINTER_INPUT_MAP = {
</P><PRE>   pointerdown: INPUT_START,
   pointermove: INPUT_MOVE,
   pointerup: INPUT_END,
   pointercancel: INPUT_CANCEL,
   pointerout: INPUT_CANCEL
</PRE><P>};
</P><P>// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
</P><PRE>   2: INPUT_TYPE_TOUCH,
   3: INPUT_TYPE_PEN,
   4: INPUT_TYPE_MOUSE,
   5: INPUT_TYPE_KINECT // see <A rel="nofollow" class="external free" href="https://twitter.com/jacobrossi/status/480596438489890816">https://twitter.com/jacobrossi/status/480596438489890816</A></PRE><P>};
</P><P>var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
</P><P>// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
</P><PRE>   POINTER_ELEMENT_EVENTS = 'MSPointerDown';
   POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
</PRE><P>}
</P><P>/**
</P><PRE>* Pointer events input
* @constructor
* @extends Input
*/
</PRE><P>function PointerEventInput() {
</P><PRE>   this.evEl = POINTER_ELEMENT_EVENTS;
   this.evWin = POINTER_WINDOW_EVENTS;
</PRE><PRE>   Input.apply(this, arguments);
</PRE><PRE>   this.store = (this.manager.session.pointerEvents = []);
</PRE><P>}
</P><P>inherit(PointerEventInput, Input, {
</P><PRE>   /**
    * handle mouse events
    * @param {Object} ev
    */
   handler: function PEhandler(ev) {
       var store = this.store;
       var removePointer = false;
</PRE><PRE>       var eventTypeNormalized = ev.type.toLowerCase().replace('ms', <I>);</I>
       var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
       var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
</PRE><PRE>       var isTouch = (pointerType == INPUT_TYPE_TOUCH);
</PRE><PRE>       // get index of the event in the store
       var storeIndex = inArray(store, ev.pointerId, 'pointerId');
</PRE><PRE>       // start and mouse must be down
       if (eventType &amp; INPUT_START &amp;&amp; (ev.button === 0 || isTouch)) {
           if (storeIndex &lt; 0) {
               store.push(ev);
               storeIndex = store.length - 1;
           }
       } else if (eventType &amp; (INPUT_END | INPUT_CANCEL)) {
           removePointer = true;
       }
</PRE><PRE>       // it not found, so the pointer hasn't been down (so it's probably a hover)
       if (storeIndex &lt; 0) {
           return;
       }
</PRE><PRE>       // update the event in the store
       store[storeIndex] = ev;
</PRE><PRE>       this.callback(this.manager, eventType, {
           pointers: store,
           changedPointers: [ev],
           pointerType: pointerType,
           srcEvent: ev
       });
</PRE><PRE>       if (removePointer) {
           // remove from the store
           store.splice(storeIndex, 1);
       }
   }
</PRE><P>});
</P><P>var SINGLE_TOUCH_INPUT_MAP = {
</P><PRE>   touchstart: INPUT_START,
   touchmove: INPUT_MOVE,
   touchend: INPUT_END,
   touchcancel: INPUT_CANCEL
</PRE><P>};
</P><P>var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
</P><P>/**
</P><PRE>* Touch events input
* @constructor
* @extends Input
*/
</PRE><P>function SingleTouchInput() {
</P><PRE>   this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
   this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
   this.started = false;
</PRE><PRE>   Input.apply(this, arguments);
</PRE><P>}
</P><P>inherit(SingleTouchInput, Input, {
</P><PRE>   handler: function TEhandler(ev) {
       var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
</PRE><PRE>       // should we handle the touch events?
       if (type === INPUT_START) {
           this.started = true;
       }
</PRE><PRE>       if (!this.started) {
           return;
       }
</PRE><PRE>       var touches = normalizeSingleTouches.call(this, ev, type);
</PRE><PRE>       // when done, reset the started state
       if (type &amp; (INPUT_END | INPUT_CANCEL) &amp;&amp; touches[0].length - touches[1].length === 0) {
           this.started = false;
       }
</PRE><PRE>       this.callback(this.manager, type, {
           pointers: touches[0],
           changedPointers: touches[1],
           pointerType: INPUT_TYPE_TOUCH,
           srcEvent: ev
       });
   }
</PRE><P>});
</P><P>/**
</P><PRE>* @this {TouchInput}
* @param {Object} ev
* @param {Number} type flag
* @returns {undefined|Array} [all, changed]
*/
</PRE><P>function normalizeSingleTouches(ev, type) {
</P><PRE>   var all = toArray(ev.touches);
   var changed = toArray(ev.changedTouches);
</PRE><PRE>   if (type &amp; (INPUT_END | INPUT_CANCEL)) {
       all = uniqueArray(all.concat(changed), 'identifier', true);
   }
</PRE><PRE>   return [all, changed];
</PRE><P>}
</P><P>var TOUCH_INPUT_MAP = {
</P><PRE>   touchstart: INPUT_START,
   touchmove: INPUT_MOVE,
   touchend: INPUT_END,
   touchcancel: INPUT_CANCEL
</PRE><P>};
</P><P>var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
</P><P>/**
</P><PRE>* Multi-user touch events input
* @constructor
* @extends Input
*/
</PRE><P>function TouchInput() {
</P><PRE>   this.evTarget = TOUCH_TARGET_EVENTS;
   this.targetIds = {};
</PRE><PRE>   Input.apply(this, arguments);
</PRE><P>}
</P><P>inherit(TouchInput, Input, {
</P><PRE>   handler: function MTEhandler(ev) {
       var type = TOUCH_INPUT_MAP[ev.type];
       var touches = getTouches.call(this, ev, type);
       if (!touches) {
           return;
       }
</PRE><PRE>       this.callback(this.manager, type, {
           pointers: touches[0],
           changedPointers: touches[1],
           pointerType: INPUT_TYPE_TOUCH,
           srcEvent: ev
       });
   }
</PRE><P>});
</P><P>/**
</P><PRE>* @this {TouchInput}
* @param {Object} ev
* @param {Number} type flag
* @returns {undefined|Array} [all, changed]
*/
</PRE><P>function getTouches(ev, type) {
</P><PRE>   var allTouches = toArray(ev.touches);
   var targetIds = this.targetIds;
</PRE><PRE>   // when there is only one touch, the process can be simplified
   if (type &amp; (INPUT_START | INPUT_MOVE) &amp;&amp; allTouches.length === 1) {
       targetIds[allTouches[0].identifier] = true;
       return [allTouches, allTouches];
   }
</PRE><PRE>   var i,
       targetTouches,
       changedTouches = toArray(ev.changedTouches),
       changedTargetTouches = [],
       target = this.target;
</PRE><PRE>   // get target touches from touches
   targetTouches = allTouches.filter(function(touch) {
       return hasParent(touch.target, target);
   });
</PRE><PRE>   // collect touches
   if (type === INPUT_START) {
       i = 0;
       while (i &lt; targetTouches.length) {
           targetIds[targetTouches[i].identifier] = true;
           i++;
       }
   }
</PRE><PRE>   // filter changed touches to only contain touches that exist in the collected target ids
   i = 0;
   while (i &lt; changedTouches.length) {
       if (targetIds[changedTouches[i].identifier]) {
           changedTargetTouches.push(changedTouches[i]);
       }
</PRE><PRE>       // cleanup removed touches
       if (type &amp; (INPUT_END | INPUT_CANCEL)) {
           delete targetIds[changedTouches[i].identifier];
       }
       i++;
   }
</PRE><PRE>   if (!changedTargetTouches.length) {
       return;
   }
</PRE><PRE>   return [
       // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
       uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
       changedTargetTouches
   ];
</PRE><P>}
</P><P>/**
</P><PRE>* Combined touch and mouse input
*
* Touch has a higher priority then mouse, and while touching no mouse events are allowed.
* This because touch devices also emit mouse events while doing a touch.
*
* @constructor
* @extends Input
*/
</PRE><P>function TouchMouseInput() {
</P><PRE>   Input.apply(this, arguments);
</PRE><PRE>   var handler = bindFn(this.handler, this);
   this.touch = new TouchInput(this.manager, handler);
   this.mouse = new MouseInput(this.manager, handler);
</PRE><P>}
</P><P>inherit(TouchMouseInput, Input, {
</P><PRE>   /**
    * handle mouse and touch events
    * @param {Hammer} manager
    * @param {String} inputEvent
    * @param {Object} inputData
    */
   handler: function TMEhandler(manager, inputEvent, inputData) {
       var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
           isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);
</PRE><PRE>       // when we're in a touch event, so  block all upcoming mouse events
       // most mobile browser also emit mouseevents, right after touchstart
       if (isTouch) {
           this.mouse.allow = false;
       } else if (isMouse &amp;&amp; !this.mouse.allow) {
           return;
       }
</PRE><PRE>       // reset the allowMouse when we're done
       if (inputEvent &amp; (INPUT_END | INPUT_CANCEL)) {
           this.mouse.allow = true;
       }
</PRE><PRE>       this.callback(manager, inputEvent, inputData);
   },
</PRE><PRE>   /**
    * remove the event listeners
    */
   destroy: function destroy() {
       this.touch.destroy();
       this.mouse.destroy();
   }
</PRE><P>});
</P><P>var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
</P><P>// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
</P><P>/**
</P><PRE>* Touch Action
* sets the touchAction property or uses the js alternative
* @param {Manager} manager
* @param {String} value
* @constructor
*/
</PRE><P>function TouchAction(manager, value) {
</P><PRE>   this.manager = manager;
   this.set(value);
</PRE><P>}
</P><P>TouchAction.prototype = {
</P><PRE>   /**
    * set the touchAction value on the element or enable the polyfill
    * @param {String} value
    */
   set: function(value) {
       // find out the touch-action by the event handlers
       if (value == TOUCH_ACTION_COMPUTE) {
           value = this.compute();
       }
</PRE><PRE>       if (NATIVE_TOUCH_ACTION) {
           this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
       }
       this.actions = value.toLowerCase().trim();
   },
</PRE><PRE>   /**
    * just re-set the touchAction value
    */
   update: function() {
       this.set(this.manager.options.touchAction);
   },
</PRE><PRE>   /**
    * compute the value for the touchAction property based on the recognizer's settings
    * @returns {String} value
    */
   compute: function() {
       var actions = [];
       each(this.manager.recognizers, function(recognizer) {
           if (boolOrFn(recognizer.options.enable, [recognizer])) {
               actions = actions.concat(recognizer.getTouchAction());
           }
       });
       return cleanTouchActions(actions.join(' '));
   },
</PRE><PRE>   /**
    * this method is called on each input cycle and provides the preventing of the browser behavior
    * @param {Object} input
    */
   preventDefaults: function(input) {
       // not needed with native support for the touchAction property
       if (NATIVE_TOUCH_ACTION) {
           return;
       }
</PRE><PRE>       var srcEvent = input.srcEvent;
       var direction = input.offsetDirection;
</PRE><PRE>       // if the touch action did prevented once this session
       if (this.manager.session.prevented) {
           srcEvent.preventDefault();
           return;
       }
</PRE><PRE>       var actions = this.actions;
       var hasNone = inStr(actions, TOUCH_ACTION_NONE);
       var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
       var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
</PRE><PRE>       if (hasNone ||
           (hasPanY &amp;&amp; direction &amp; DIRECTION_HORIZONTAL) ||
           (hasPanX &amp;&amp; direction &amp; DIRECTION_VERTICAL)) {
           return this.preventSrc(srcEvent);
       }
   },
</PRE><PRE>   /**
    * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
    * @param {Object} srcEvent
    */
   preventSrc: function(srcEvent) {
       this.manager.session.prevented = true;
       srcEvent.preventDefault();
   }
</PRE><P>};
</P><P>/**
</P><PRE>* when the touchActions are collected they are not a valid value, so we need to clean things up. *
* @param {String} actions
* @returns {*}
*/
</PRE><P>function cleanTouchActions(actions) {
</P><PRE>   // none
   if (inStr(actions, TOUCH_ACTION_NONE)) {
       return TOUCH_ACTION_NONE;
   }
</PRE><PRE>   var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
   var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
</PRE><PRE>   // pan-x and pan-y can be combined
   if (hasPanX &amp;&amp; hasPanY) {
       return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
   }
</PRE><PRE>   // pan-x OR pan-y
   if (hasPanX || hasPanY) {
       return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
   }
</PRE><PRE>   // manipulation
   if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
       return TOUCH_ACTION_MANIPULATION;
   }
</PRE><PRE> return TOUCH_ACTION_AUTO;
</PRE><P>}
</P><P>/**
</P><PRE>* Recognizer flow explained; *
* All recognizers have the initial state of POSSIBLE when a input session starts.
* The definition of a input session is from the first input until the last input, with all it's movement in it. *
* Example session for mouse-input: mousedown -&gt; mousemove -&gt; mouseup
*
* On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
* which determines with state it should be.
*
* If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
* POSSIBLE to give it another change on the next cycle.
*
*               Possible
*                  |
*            +-----+---------------+
*            |                     |
*      +-----+-----+               |
*      |           |               |
*   Failed      Cancelled          |
*                          +-------+------+
*                          |              |
*                      Recognized       Began
*                                         |
*                                      Changed
*                                         |
*                                  Ended/Recognized
*/
</PRE><P>var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;
</P><P>/**
</P><PRE>* Recognizer
* Every recognizer needs to extend from this class.
* @constructor
* @param {Object} options
*/
</PRE><P>function Recognizer(options) {
</P><PRE>   this.id = uniqueId();
</PRE><PRE>   this.manager = null;
   this.options = merge(options || {}, this.defaults);
</PRE><PRE>   // default is enable true
   this.options.enable = ifUndefined(this.options.enable, true);
</PRE><PRE>   this.state = STATE_POSSIBLE;
</PRE><PRE>   this.simultaneous = {};
   this.requireFail = [];
</PRE><P>}
</P><P>Recognizer.prototype = {
</P><PRE>   /**
    * @virtual
    * @type {Object}
    */
   defaults: {},
</PRE><PRE>   /**
    * set options
    * @param {Object} options
    * @return {Recognizer}
    */
   set: function(options) {
       extend(this.options, options);
</PRE><PRE>       // also update the touchAction, in case something changed about the directions/enabled state
       this.manager &amp;&amp; this.manager.touchAction.update();
       return this;
   },
</PRE><PRE>   /**
    * recognize simultaneous with an other recognizer.
    * @param {Recognizer} otherRecognizer
    * @returns {Recognizer} this
    */
   recognizeWith: function(otherRecognizer) {
       if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
           return this;
       }
</PRE><PRE>       var simultaneous = this.simultaneous;
       otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
       if (!simultaneous[otherRecognizer.id]) {
           simultaneous[otherRecognizer.id] = otherRecognizer;
           otherRecognizer.recognizeWith(this);
       }
       return this;
   },
</PRE><PRE>   /**
    * drop the simultaneous link. it doesnt remove the link on the other recognizer.
    * @param {Recognizer} otherRecognizer
    * @returns {Recognizer} this
    */
   dropRecognizeWith: function(otherRecognizer) {
       if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
           return this;
       }
</PRE><PRE>       otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
       delete this.simultaneous[otherRecognizer.id];
       return this;
   },
</PRE><PRE>   /**
    * recognizer can only run when an other is failing
    * @param {Recognizer} otherRecognizer
    * @returns {Recognizer} this
    */
   requireFailure: function(otherRecognizer) {
       if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
           return this;
       }
</PRE><PRE>       var requireFail = this.requireFail;
       otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
       if (inArray(requireFail, otherRecognizer) === -1) {
           requireFail.push(otherRecognizer);
           otherRecognizer.requireFailure(this);
       }
       return this;
   },
</PRE><PRE>   /**
    * drop the requireFailure link. it does not remove the link on the other recognizer.
    * @param {Recognizer} otherRecognizer
    * @returns {Recognizer} this
    */
   dropRequireFailure: function(otherRecognizer) {
       if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
           return this;
       }
</PRE><PRE>       otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
       var index = inArray(this.requireFail, otherRecognizer);
       if (index &gt; -1) {
           this.requireFail.splice(index, 1);
       }
       return this;
   },
</PRE><PRE>   /**
    * has require failures boolean
    * @returns {boolean}
    */
   hasRequireFailures: function() {
       return this.requireFail.length &gt; 0;
   },
</PRE><PRE>   /**
    * if the recognizer can recognize simultaneous with an other recognizer
    * @param {Recognizer} otherRecognizer
    * @returns {Boolean}
    */
   canRecognizeWith: function(otherRecognizer) {
       return !!this.simultaneous[otherRecognizer.id];
   },
</PRE><PRE>   /**
    * You should use `tryEmit` instead of `emit` directly to check
    * that all the needed recognizers has failed before emitting.
    * @param {Object} input
    */
   emit: function(input) {
       var self = this;
       var state = this.state;
</PRE><PRE>       function emit(withState) {
           self.manager.emit(self.options.event + (withState ? stateStr(state) : <I>), input);</I>
       }
</PRE><PRE>       // 'panstart' and 'panmove'
       if (state &lt; STATE_ENDED) {
           emit(true);
       }
</PRE><PRE>       emit(); // simple 'eventName' events
</PRE><PRE>       // panend and pancancel
       if (state &gt;= STATE_ENDED) {
           emit(true);
       }
   },
</PRE><PRE>   /**
    * Check that all the require failure recognizers has failed,
    * if true, it emits a gesture event,
    * otherwise, setup the state to FAILED.
    * @param {Object} input
    */
   tryEmit: function(input) {
       if (this.canEmit()) {
           return this.emit(input);
       }
       // it's failing anyway
       this.state = STATE_FAILED;
   },
</PRE><PRE>   /**
    * can we emit?
    * @returns {boolean}
    */
   canEmit: function() {
       var i = 0;
       while (i &lt; this.requireFail.length) {
           if (!(this.requireFail[i].state &amp; (STATE_FAILED | STATE_POSSIBLE))) {
               return false;
           }
           i++;
       }
       return true;
   },
</PRE><PRE>   /**
    * update the recognizer
    * @param {Object} inputData
    */
   recognize: function(inputData) {
       // make a new copy of the inputData
       // so we can change the inputData without messing up the other recognizers
       var inputDataClone = extend({}, inputData);
</PRE><PRE>       // is is enabled and allow recognizing?
       if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
           this.reset();
           this.state = STATE_FAILED;
           return;
       }
</PRE><PRE>       // reset when we've reached the end
       if (this.state &amp; (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
           this.state = STATE_POSSIBLE;
       }
</PRE><PRE>       this.state = this.process(inputDataClone);
</PRE><PRE>       // the recognizer has recognized a gesture
       // so trigger an event
       if (this.state &amp; (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
           this.tryEmit(inputDataClone);
       }
   },
</PRE><PRE>   /**
    * return the state of the recognizer
    * the actual recognizing happens in this method
    * @virtual
    * @param {Object} inputData
    * @returns {Const} STATE
    */
   process: function(inputData) { }, // jshint ignore:line
</PRE><PRE>   /**
    * return the preferred touch-action
    * @virtual
    * @returns {Array}
    */
   getTouchAction: function() { },
</PRE><PRE>   /**
    * called when the gesture isn't allowed to recognize
    * like when another is being recognized or it is disabled
    * @virtual
    */
   reset: function() { }
</PRE><P>};
</P><P>/**
</P><PRE>* get a usable string, used as event postfix
* @param {Const} state
* @returns {String} state
*/
</PRE><P>function stateStr(state) {
</P><PRE>   if (state &amp; STATE_CANCELLED) {
       return 'cancel';
   } else if (state &amp; STATE_ENDED) {
       return 'end';
   } else if (state &amp; STATE_CHANGED) {
       return 'move';
   } else if (state &amp; STATE_BEGAN) {
       return 'start';
   }
   return <I>;</I></PRE><P>}
</P><P>/**
</P><PRE>* direction cons to string
* @param {Const} direction
* @returns {String}
*/
</PRE><P>function directionStr(direction) {
</P><PRE>   if (direction == DIRECTION_DOWN) {
       return 'down';
   } else if (direction == DIRECTION_UP) {
       return 'up';
   } else if (direction == DIRECTION_LEFT) {
       return 'left';
   } else if (direction == DIRECTION_RIGHT) {
       return 'right';
   }
   return <I>;</I></PRE><P>}
</P><P>/**
</P><PRE>* get a recognizer by name if it is bound to a manager
* @param {Recognizer|String} otherRecognizer
* @param {Recognizer} recognizer
* @returns {Recognizer}
*/
</PRE><P>function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
</P><PRE>   var manager = recognizer.manager;
   if (manager) {
       return manager.get(otherRecognizer);
   }
   return otherRecognizer;
</PRE><P>}
</P><P>/**
</P><PRE>* This recognizer is just used as a base for the simple attribute recognizers.
* @constructor
* @extends Recognizer
*/
</PRE><P>function AttrRecognizer() {
</P><PRE>   Recognizer.apply(this, arguments);
</PRE><P>}
</P><P>inherit(AttrRecognizer, Recognizer, {
</P><PRE>   /**
    * @namespace
    * @memberof AttrRecognizer
    */
   defaults: {
       /**
        * @type {Number}
        * @default 1
        */
       pointers: 1
   },
</PRE><PRE>   /**
    * Used to check if it the recognizer receives valid input, like input.distance &gt; 10.
    * @memberof AttrRecognizer
    * @param {Object} input
    * @returns {Boolean} recognized
    */
   attrTest: function(input) {
       var optionPointers = this.options.pointers;
       return optionPointers === 0 || input.pointers.length === optionPointers;
   },
</PRE><PRE>   /**
    * Process the input and return the state for the recognizer
    * @memberof AttrRecognizer
    * @param {Object} input
    * @returns {*} State
    */
   process: function(input) {
       var state = this.state;
       var eventType = input.eventType;
</PRE><PRE>       var isRecognized = state &amp; (STATE_BEGAN | STATE_CHANGED);
       var isValid = this.attrTest(input);
</PRE><PRE>       // on cancel input and we've recognized before, return STATE_CANCELLED
       if (isRecognized &amp;&amp; (eventType &amp; INPUT_CANCEL || !isValid)) {
           return state | STATE_CANCELLED;
       } else if (isRecognized || isValid) {
           if (eventType &amp; INPUT_END) {
               return state | STATE_ENDED;
           } else if (!(state &amp; STATE_BEGAN)) {
               return STATE_BEGAN;
           }
           return state | STATE_CHANGED;
       }
       return STATE_FAILED;
   }
</PRE><P>});
</P><P>/**
</P><PRE>* Pan
* Recognized when the pointer is down and moved in the allowed direction.
* @constructor
* @extends AttrRecognizer
*/
</PRE><P>function PanRecognizer() {
</P><PRE>   AttrRecognizer.apply(this, arguments);
</PRE><PRE>   this.pX = null;
   this.pY = null;
</PRE><P>}
</P><P>inherit(PanRecognizer, AttrRecognizer, {
</P><PRE>   /**
    * @namespace
    * @memberof PanRecognizer
    */
   defaults: {
       event: 'pan',
       threshold: 10,
       pointers: 1,
       direction: DIRECTION_ALL
   },
</PRE><PRE>   getTouchAction: function() {
       var direction = this.options.direction;
       var actions = [];
       if (direction &amp; DIRECTION_HORIZONTAL) {
           actions.push(TOUCH_ACTION_PAN_Y);
       }
       if (direction &amp; DIRECTION_VERTICAL) {
           actions.push(TOUCH_ACTION_PAN_X);
       }
       return actions;
   },
</PRE><PRE>   directionTest: function(input) {
       var options = this.options;
       var hasMoved = true;
       var distance = input.distance;
       var direction = input.direction;
       var x = input.deltaX;
       var y = input.deltaY;
</PRE><PRE>       // lock to axis?
       if (!(direction &amp; options.direction)) {
           if (options.direction &amp; DIRECTION_HORIZONTAL) {
               direction = (x === 0) ? DIRECTION_NONE : (x &lt; 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
               hasMoved = x != this.pX;
               distance = Math.abs(input.deltaX);
           } else {
               direction = (y === 0) ? DIRECTION_NONE : (y &lt; 0) ? DIRECTION_UP : DIRECTION_DOWN;
               hasMoved = y != this.pY;
               distance = Math.abs(input.deltaY);
           }
       }
       input.direction = direction;
       return hasMoved &amp;&amp; distance &gt; options.threshold &amp;&amp; direction &amp; options.direction;
   },
</PRE><PRE>   attrTest: function(input) {
       return AttrRecognizer.prototype.attrTest.call(this, input) &amp;&amp;
           (this.state &amp; STATE_BEGAN || (!(this.state &amp; STATE_BEGAN) &amp;&amp; this.directionTest(input)));
   },
</PRE><PRE>   emit: function(input) {
       this.pX = input.deltaX;
       this.pY = input.deltaY;
</PRE><PRE>       var direction = directionStr(input.direction);
       if (direction) {
           this.manager.emit(this.options.event + direction, input);
       }
</PRE><PRE>       this._super.emit.call(this, input);
   }
</PRE><P>});
</P><P>/**
</P><PRE>* Pinch
* Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
* @constructor
* @extends AttrRecognizer
*/
</PRE><P>function PinchRecognizer() {
</P><PRE>   AttrRecognizer.apply(this, arguments);
</PRE><P>}
</P><P>inherit(PinchRecognizer, AttrRecognizer, {
</P><PRE>   /**
    * @namespace
    * @memberof PinchRecognizer
    */
   defaults: {
       event: 'pinch',
       threshold: 0,
       pointers: 2
   },
</PRE><PRE>   getTouchAction: function() {
       return [TOUCH_ACTION_NONE];
   },
</PRE><PRE>   attrTest: function(input) {
       return this._super.attrTest.call(this, input) &amp;&amp;
           (Math.abs(input.scale - 1) &gt; this.options.threshold || this.state &amp; STATE_BEGAN);
   },
</PRE><PRE>   emit: function(input) {
       this._super.emit.call(this, input);
       if (input.scale !== 1) {
           var inOut = input.scale &lt; 1 ? 'in' : 'out';
           this.manager.emit(this.options.event + inOut, input);
       }
   }
</PRE><P>});
</P><P>/**
</P><PRE>* Press
* Recognized when the pointer is down for x ms without any movement.
* @constructor
* @extends Recognizer
*/
</PRE><P>function PressRecognizer() {
</P><PRE>   Recognizer.apply(this, arguments);
</PRE><PRE>   this._timer = null;
   this._input = null;
</PRE><P>}
</P><P>inherit(PressRecognizer, Recognizer, {
</P><PRE>   /**
    * @namespace
    * @memberof PressRecognizer
    */
   defaults: {
       event: 'press',
       pointers: 1,
       time: 500, // minimal time of the pointer to be pressed
       threshold: 5 // a minimal movement is ok, but keep it low
   },
</PRE><PRE>   getTouchAction: function() {
       return [TOUCH_ACTION_AUTO];
   },
</PRE><PRE>   process: function(input) {
       var options = this.options;
       var validPointers = input.pointers.length === options.pointers;
       var validMovement = input.distance &lt; options.threshold;
       var validTime = input.deltaTime &gt; options.time;
</PRE><PRE>       this._input = input;
</PRE><PRE>       // we only allow little movement
       // and we've reached an end event, so a tap is possible
       if (!validMovement || !validPointers || (input.eventType &amp; (INPUT_END | INPUT_CANCEL) &amp;&amp; !validTime)) {
           this.reset();
       } else if (input.eventType &amp; INPUT_START) {
           this.reset();
           this._timer = setTimeoutContext(function() {
               this.state = STATE_RECOGNIZED;
               this.tryEmit();
           }, options.time, this);
       } else if (input.eventType &amp; INPUT_END) {
           return STATE_RECOGNIZED;
       }
       return STATE_FAILED;
   },
</PRE><PRE>   reset: function() {
       clearTimeout(this._timer);
   },
</PRE><PRE>   emit: function(input) {
       if (this.state !== STATE_RECOGNIZED) {
           return;
       }
</PRE><PRE>       if (input &amp;&amp; (input.eventType &amp; INPUT_END)) {
           this.manager.emit(this.options.event + 'up', input);
       } else {
           this._input.timeStamp = now();
           this.manager.emit(this.options.event, this._input);
       }
   }
</PRE><P>});
</P><P>/**
</P><PRE>* Rotate
* Recognized when two or more pointer are moving in a circular motion.
* @constructor
* @extends AttrRecognizer
*/
</PRE><P>function RotateRecognizer() {
</P><PRE>   AttrRecognizer.apply(this, arguments);
</PRE><P>}
</P><P>inherit(RotateRecognizer, AttrRecognizer, {
</P><PRE>   /**
    * @namespace
    * @memberof RotateRecognizer
    */
   defaults: {
       event: 'rotate',
       threshold: 0,
       pointers: 2
   },
</PRE><PRE>   getTouchAction: function() {
       return [TOUCH_ACTION_NONE];
   },
</PRE><PRE>   attrTest: function(input) {
       return this._super.attrTest.call(this, input) &amp;&amp;
           (Math.abs(input.rotation) &gt; this.options.threshold || this.state &amp; STATE_BEGAN);
   }
</PRE><P>});
</P><P>/**
</P><PRE>* Swipe
* Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
* @constructor
* @extends AttrRecognizer
*/
</PRE><P>function SwipeRecognizer() {
</P><PRE>   AttrRecognizer.apply(this, arguments);
</PRE><P>}
</P><P>inherit(SwipeRecognizer, AttrRecognizer, {
</P><PRE>   /**
    * @namespace
    * @memberof SwipeRecognizer
    */
   defaults: {
       event: 'swipe',
       threshold: 10,
       velocity: 0.65,
       direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
       pointers: 1
   },
</PRE><PRE>   getTouchAction: function() {
       return PanRecognizer.prototype.getTouchAction.call(this);
   },
</PRE><PRE>   attrTest: function(input) {
       var direction = this.options.direction;
       var velocity;
</PRE><PRE>       if (direction &amp; (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
           velocity = input.velocity;
       } else if (direction &amp; DIRECTION_HORIZONTAL) {
           velocity = input.velocityX;
       } else if (direction &amp; DIRECTION_VERTICAL) {
           velocity = input.velocityY;
       }
</PRE><PRE>       return this._super.attrTest.call(this, input) &amp;&amp;
           direction &amp; input.direction &amp;&amp;
           input.distance &gt; this.options.threshold &amp;&amp;
           abs(velocity) &gt; this.options.velocity &amp;&amp; input.eventType &amp; INPUT_END;
   },
</PRE><PRE>   emit: function(input) {
       var direction = directionStr(input.direction);
       if (direction) {
           this.manager.emit(this.options.event + direction, input);
       }
</PRE><PRE>       this.manager.emit(this.options.event, input);
   }
</PRE><P>});
</P><P>/**
</P><PRE>* A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
* between the given interval and position. The delay option can be used to recognize multi-taps without firing
* a single tap.
*
* The eventData from the emitted event contains the property `tapCount`, which contains the amount of
* multi-taps being recognized.
* @constructor
* @extends Recognizer
*/
</PRE><P>function TapRecognizer() {
</P><PRE>   Recognizer.apply(this, arguments);
</PRE><PRE>   // previous time and center,
   // used for tap counting
   this.pTime = false;
   this.pCenter = false;
</PRE><PRE>   this._timer = null;
   this._input = null;
   this.count = 0;
</PRE><P>}
</P><P>inherit(TapRecognizer, Recognizer, {
</P><PRE>   /**
    * @namespace
    * @memberof PinchRecognizer
    */
   defaults: {
       event: 'tap',
       pointers: 1,
       taps: 1,
       interval: 300, // max time between the multi-tap taps
       time: 250, // max time of the pointer to be down (like finger on the screen)
       threshold: 2, // a minimal movement is ok, but keep it low
       posThreshold: 10 // a multi-tap can be a bit off the initial position
   },
</PRE><PRE>   getTouchAction: function() {
       return [TOUCH_ACTION_MANIPULATION];
   },
</PRE><PRE>   process: function(input) {
       var options = this.options;
</PRE><PRE>       var validPointers = input.pointers.length === options.pointers;
       var validMovement = input.distance &lt; options.threshold;
       var validTouchTime = input.deltaTime &lt; options.time;
</PRE><PRE>       this.reset();
</PRE><PRE>       if ((input.eventType &amp; INPUT_START) &amp;&amp; (this.count === 0)) {
           return this.failTimeout();
       }
</PRE><PRE>       // we only allow little movement
       // and we've reached an end event, so a tap is possible
       if (validMovement &amp;&amp; validTouchTime &amp;&amp; validPointers) {
           if (input.eventType != INPUT_END) {
               return this.failTimeout();
           }
</PRE><PRE>           var validInterval = this.pTime ? (input.timeStamp - this.pTime &lt; options.interval) : true;
           var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) &lt; options.posThreshold;
</PRE><PRE>           this.pTime = input.timeStamp;
           this.pCenter = input.center;
</PRE><PRE>           if (!validMultiTap || !validInterval) {
               this.count = 1;
           } else {
               this.count += 1;
           }
</PRE><PRE>           this._input = input;
</PRE><PRE>           // if tap count matches we have recognized it,
           // else it has began recognizing...
           var tapCount = this.count % options.taps;
           if (tapCount === 0) {
               // no failing requirements, immediately trigger the tap event
               // or wait as long as the multitap interval to trigger
               if (!this.hasRequireFailures()) {
                   return STATE_RECOGNIZED;
               } else {
                   this._timer = setTimeoutContext(function() {
                       this.state = STATE_RECOGNIZED;
                       this.tryEmit();
                   }, options.interval, this);
                   return STATE_BEGAN;
               }
           }
       }
       return STATE_FAILED;
   },
</PRE><PRE>   failTimeout: function() {
       this._timer = setTimeoutContext(function() {
           this.state = STATE_FAILED;
       }, this.options.interval, this);
       return STATE_FAILED;
   },
</PRE><PRE>   reset: function() {
       clearTimeout(this._timer);
   },
</PRE><PRE>   emit: function() {
       if (this.state == STATE_RECOGNIZED ) {
           this._input.tapCount = this.count;
           this.manager.emit(this.options.event, this._input);
       }
   }
</PRE><P>});
</P><P>/**
</P><PRE>* Simple way to create an manager with a default set of recognizers.
* @param {HTMLElement} element
* @param {Object} [options]
* @constructor
*/
</PRE><P>function Hammer(element, options) {
</P><PRE>   options = options || {};
   options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
   return new Manager(element, options);
</PRE><P>}
</P><P>/**
</P><PRE>* @const {string}
*/
</PRE><P>Hammer.VERSION = '2.0.4';
</P><P>/**
</P><PRE>* default settings
* @namespace
*/
</PRE><P>Hammer.defaults = {
</P><PRE>   /**
    * set if DOM events are being triggered.
    * But this is slower and unused by simple implementations, so disabled by default.
    * @type {Boolean}
    * @default false
    */
   domEvents: false,
</PRE><PRE>   /**
    * The value for the touchAction property/fallback.
    * When set to `compute` it will magically set the correct value based on the added recognizers.
    * @type {String}
    * @default compute
    */
   touchAction: TOUCH_ACTION_COMPUTE,
</PRE><PRE>   /**
    * @type {Boolean}
    * @default true
    */
   enable: true,
</PRE><PRE>   /**
    * EXPERIMENTAL FEATURE -- can be removed/changed
    * Change the parent input target element.
    * If Null, then it is being set the to main element.
    * @type {Null|EventTarget}
    * @default null
    */
   inputTarget: null,
</PRE><PRE>   /**
    * force an input class
    * @type {Null|Function}
    * @default null
    */
   inputClass: null,
</PRE><PRE>   /**
    * Default recognizer setup when calling `Hammer()`
    * When creating a new Manager these will be skipped.
    * @type {Array}
    */
   preset: [
       // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
       [RotateRecognizer, { enable: false }],
       [PinchRecognizer, { enable: false }, ['rotate']],
       [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
       [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
       [TapRecognizer],
       [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
       [PressRecognizer]
   ],
</PRE><PRE>   /**
    * Some CSS properties can be used to improve the working of Hammer.
    * Add them to this method and they will be set when creating a new Manager.
    * @namespace
    */
   cssProps: {
       /**
        * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
        * @type {String}
        * @default 'none'
        */
       userSelect: 'none',
</PRE><PRE>       /**
        * Disable the Windows Phone grippers when pressing an element.
        * @type {String}
        * @default 'none'
        */
       touchSelect: 'none',
</PRE><PRE>       /**
        * Disables the default callout shown when you touch and hold a touch target.
        * On iOS, when you touch and hold a touch target such as a link, Safari displays
        * a callout containing information about the link. This property allows you to disable that callout.
        * @type {String}
        * @default 'none'
        */
       touchCallout: 'none',
</PRE><PRE>       /**
        * Specifies whether zooming is enabled. Used by IE10&gt;
        * @type {String}
        * @default 'none'
        */
       contentZooming: 'none',
</PRE><PRE>       /**
        * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
        * @type {String}
        * @default 'none'
        */
       userDrag: 'none',
</PRE><PRE>       /**
        * Overrides the highlight color shown when the user taps a link or a JavaScript
        * clickable element in iOS. This property obeys the alpha value, if specified.
        * @type {String}
        * @default 'rgba(0,0,0,0)'
        */
       tapHighlightColor: 'rgba(0,0,0,0)'
   }
</PRE><P>};
</P><P>var STOP = 1;
var FORCED_STOP = 2;
</P><P>/**
</P><PRE>* Manager
* @param {HTMLElement} element
* @param {Object} [options]
* @constructor
*/
</PRE><P>function Manager(element, options) {
</P><PRE>   options = options || {};
</PRE><PRE>   this.options = merge(options, Hammer.defaults);
   this.options.inputTarget = this.options.inputTarget || element;
</PRE><PRE>   this.handlers = {};
   this.session = {};
   this.recognizers = [];
</PRE><PRE>   this.element = element;
   this.input = createInputInstance(this);
   this.touchAction = new TouchAction(this, this.options.touchAction);
</PRE><PRE>   toggleCssProps(this, true);
</PRE><PRE>   each(options.recognizers, function(item) {
       var recognizer = this.add(new (item[0])(item[1]));
       item[2] &amp;&amp; recognizer.recognizeWith(item[2]);
       item[3] &amp;&amp; recognizer.requireFailure(item[3]);
   }, this);
</PRE><P>}
</P><P>Manager.prototype = {
</P><PRE>   /**
    * set options
    * @param {Object} options
    * @returns {Manager}
    */
   set: function(options) {
       extend(this.options, options);
</PRE><PRE>       // Options that need a little more setup
       if (options.touchAction) {
           this.touchAction.update();
       }
       if (options.inputTarget) {
           // Clean up existing event listeners and reinitialize
           this.input.destroy();
           this.input.target = options.inputTarget;
           this.input.init();
       }
       return this;
   },
</PRE><PRE>   /**
    * stop recognizing for this session.
    * This session will be discarded, when a new [input]start event is fired.
    * When forced, the recognizer cycle is stopped immediately.
    * @param {Boolean} [force]
    */
   stop: function(force) {
       this.session.stopped = force ? FORCED_STOP : STOP;
   },
</PRE><PRE>   /**
    * run the recognizers!
    * called by the inputHandler function on every movement of the pointers (touches)
    * it walks through all the recognizers and tries to detect the gesture that is being made
    * @param {Object} inputData
    */
   recognize: function(inputData) {
       var session = this.session;
       if (session.stopped) {
           return;
       }
</PRE><PRE>       // run the touch-action polyfill
       this.touchAction.preventDefaults(inputData);
</PRE><PRE>       var recognizer;
       var recognizers = this.recognizers;
</PRE><PRE>       // this holds the recognizer that is being recognized.
       // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
       // if no recognizer is detecting a thing, it is set to `null`
       var curRecognizer = session.curRecognizer;
</PRE><PRE>       // reset when the last recognizer is recognized
       // or when we're in a new session
       if (!curRecognizer || (curRecognizer &amp;&amp; curRecognizer.state &amp; STATE_RECOGNIZED)) {
           curRecognizer = session.curRecognizer = null;
       }
</PRE><PRE>       var i = 0;
       while (i &lt; recognizers.length) {
           recognizer = recognizers[i];
</PRE><PRE>           // find out if we are allowed try to recognize the input for this one.
           // 1.   allow if the session is NOT forced stopped (see the .stop() method)
           // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
           //      that is being recognized.
           // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
           //      this can be setup with the `recognizeWith()` method on the recognizer.
           if (session.stopped !== FORCED_STOP &amp;&amp; ( // 1
                   !curRecognizer || recognizer == curRecognizer || // 2
                   recognizer.canRecognizeWith(curRecognizer))) { // 3
               recognizer.recognize(inputData);
           } else {
               recognizer.reset();
           }
</PRE><PRE>           // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
           // current active recognizer. but only if we don't already have an active recognizer
           if (!curRecognizer &amp;&amp; recognizer.state &amp; (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
               curRecognizer = session.curRecognizer = recognizer;
           }
           i++;
       }
   },
</PRE><PRE>   /**
    * get a recognizer by its event name.
    * @param {Recognizer|String} recognizer
    * @returns {Recognizer|Null}
    */
   get: function(recognizer) {
       if (recognizer instanceof Recognizer) {
           return recognizer;
       }
</PRE><PRE>       var recognizers = this.recognizers;
       for (var i = 0; i &lt; recognizers.length; i++) {
           if (recognizers[i].options.event == recognizer) {
               return recognizers[i];
           }
       }
       return null;
   },
</PRE><PRE>   /**
    * add a recognizer to the manager
    * existing recognizers with the same event name will be removed
    * @param {Recognizer} recognizer
    * @returns {Recognizer|Manager}
    */
   add: function(recognizer) {
       if (invokeArrayArg(recognizer, 'add', this)) {
           return this;
       }
</PRE><PRE>       // remove existing
       var existing = this.get(recognizer.options.event);
       if (existing) {
           this.remove(existing);
       }
</PRE><PRE>       this.recognizers.push(recognizer);
       recognizer.manager = this;
</PRE><PRE>       this.touchAction.update();
       return recognizer;
   },
</PRE><PRE>   /**
    * remove a recognizer by name or instance
    * @param {Recognizer|String} recognizer
    * @returns {Manager}
    */
   remove: function(recognizer) {
       if (invokeArrayArg(recognizer, 'remove', this)) {
           return this;
       }
</PRE><PRE>       var recognizers = this.recognizers;
       recognizer = this.get(recognizer);
       recognizers.splice(inArray(recognizers, recognizer), 1);
</PRE><PRE>       this.touchAction.update();
       return this;
   },
</PRE><PRE>   /**
    * bind event
    * @param {String} events
    * @param {Function} handler
    * @returns {EventEmitter} this
    */
   on: function(events, handler) {
       var handlers = this.handlers;
       each(splitStr(events), function(event) {
           handlers[event] = handlers[event] || [];
           handlers[event].push(handler);
       });
       return this;
   },
</PRE><PRE>   /**
    * unbind event, leave emit blank to remove all handlers
    * @param {String} events
    * @param {Function} [handler]
    * @returns {EventEmitter} this
    */
   off: function(events, handler) {
       var handlers = this.handlers;
       each(splitStr(events), function(event) {
           if (!handler) {
               delete handlers[event];
           } else {
               handlers[event].splice(inArray(handlers[event], handler), 1);
           }
       });
       return this;
   },
</PRE><PRE>   /**
    * emit event to the listeners
    * @param {String} event
    * @param {Object} data
    */
   emit: function(event, data) {
       // we also want to trigger dom events
       if (this.options.domEvents) {
           triggerDomEvent(event, data);
       }
</PRE><PRE>       // no handlers, so skip it all
       var handlers = this.handlers[event] &amp;&amp; this.handlers[event].slice();
       if (!handlers || !handlers.length) {
           return;
       }
</PRE><PRE>       data.type = event;
       data.preventDefault = function() {
           data.srcEvent.preventDefault();
       };
</PRE><PRE>       var i = 0;
       while (i &lt; handlers.length) {
           handlers[i](data);
           i++;
       }
   },
</PRE><PRE>   /**
    * destroy the manager and unbinds all events
    * it doesn't unbind dom events, that is the user own responsibility
    */
   destroy: function() {
       this.element &amp;&amp; toggleCssProps(this, false);
</PRE><PRE>       this.handlers = {};
       this.session = {};
       this.input.destroy();
       this.element = null;
   }
</PRE><P>};
</P><P>/**
</P><PRE>* add/remove the css properties as defined in manager.options.cssProps
* @param {Manager} manager
* @param {Boolean} add
*/
</PRE><P>function toggleCssProps(manager, add) {
</P><PRE>   var element = manager.element;
   each(manager.options.cssProps, function(value, name) {
       element.style[prefixed(element.style, name)] = add ? value : <I>;</I>
   });
</PRE><P>}
</P><P>/**
</P><PRE>* trigger dom event
* @param {String} event
* @param {Object} data
*/
</PRE><P>function triggerDomEvent(event, data) {
</P><PRE>   var gestureEvent = document.createEvent('Event');
   gestureEvent.initEvent(event, true, true);
   gestureEvent.gesture = data;
   data.target.dispatchEvent(gestureEvent);
</PRE><P>}
</P><P>extend(Hammer, {
</P><PRE>   INPUT_START: INPUT_START,
   INPUT_MOVE: INPUT_MOVE,
   INPUT_END: INPUT_END,
   INPUT_CANCEL: INPUT_CANCEL,
</PRE><PRE>   STATE_POSSIBLE: STATE_POSSIBLE,
   STATE_BEGAN: STATE_BEGAN,
   STATE_CHANGED: STATE_CHANGED,
   STATE_ENDED: STATE_ENDED,
   STATE_RECOGNIZED: STATE_RECOGNIZED,
   STATE_CANCELLED: STATE_CANCELLED,
   STATE_FAILED: STATE_FAILED,
</PRE><PRE>   DIRECTION_NONE: DIRECTION_NONE,
   DIRECTION_LEFT: DIRECTION_LEFT,
   DIRECTION_RIGHT: DIRECTION_RIGHT,
   DIRECTION_UP: DIRECTION_UP,
   DIRECTION_DOWN: DIRECTION_DOWN,
   DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
   DIRECTION_VERTICAL: DIRECTION_VERTICAL,
   DIRECTION_ALL: DIRECTION_ALL,
</PRE><PRE>   Manager: Manager,
   Input: Input,
   TouchAction: TouchAction,
</PRE><PRE>   TouchInput: TouchInput,
   MouseInput: MouseInput,
   PointerEventInput: PointerEventInput,
   TouchMouseInput: TouchMouseInput,
   SingleTouchInput: SingleTouchInput,
</PRE><PRE>   Recognizer: Recognizer,
   AttrRecognizer: AttrRecognizer,
   Tap: TapRecognizer,
   Pan: PanRecognizer,
   Swipe: SwipeRecognizer,
   Pinch: PinchRecognizer,
   Rotate: RotateRecognizer,
   Press: PressRecognizer,
</PRE><PRE>   on: addEventListeners,
   off: removeEventListeners,
   each: each,
   merge: merge,
   extend: extend,
   inherit: inherit,
   bindFn: bindFn,
   prefixed: prefixed
</PRE><P>});
</P><P>if (typeof module != 'undefined' &amp;&amp; module.exports) {
</P><PRE>   module.exports = Hammer;
</PRE><P>} else {
</P><PRE>   window[exportName] = Hammer;
</PRE><P>}
</P><P>})(window, document, 'Hammer');
</P></DIV></DIV></DIV></DIV></BODY></HTML>
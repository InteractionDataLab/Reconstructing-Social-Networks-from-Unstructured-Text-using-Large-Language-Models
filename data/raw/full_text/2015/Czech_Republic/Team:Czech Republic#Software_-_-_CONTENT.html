<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Czech_Republic_Software skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Czech Republic/Software</SPAN></H1><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><DIV id="panel"><DIV class="centered-list"><DIV id="panel-ul-switch"><DIV id="panel-ul-button"><UL id="panel-ul"><LI><A href="/Team:Czech_Republic/Achievements">Achievements</A></LI><LI><A href="/Team:Czech_Republic/People">People</A></LI><LI><A href="/Team:Czech_Republic/Project">Project</A></LI><LI><A href="/Team:Czech_Republic/Software">Software</A></LI><LI><A href="/Team:Czech_Republic/Practices">Human Practices</A></LI><LI><A href="/Team:Czech_Republic/Parts">Parts</A></LI><LI><A href="/Team:Czech_Republic/Interlab_study">Interlab</A></LI><LI><A href="/Team:Czech_Republic/Notebook">Notebook</A></LI></UL></DIV></DIV></DIV></DIV><DIV id="main-div"><HEADER><H1>Software</H1></HEADER><DIV id="toc" class="toc"><DIV id="toctitle"><H2>Contents</H2></DIV><UL><LI class="toclevel-1 tocsection-1"><A href="#Abstract"><SPAN class="tocnumber">1</SPAN><SPAN class="toctext">Abstract</SPAN></A></LI><LI class="toclevel-1 tocsection-2"><A href="#Key_Achievements"><SPAN class="tocnumber">2</SPAN><SPAN class="toctext">Key Achievements</SPAN></A></LI><LI class="toclevel-1 tocsection-3"><A href="#Demo"><SPAN class="tocnumber">3</SPAN><SPAN class="toctext">Demo</SPAN></A></LI><LI class="toclevel-2 tocsection-4"><A href="#Demo_1"><SPAN class="tocnumber">3.1</SPAN><SPAN class="toctext">Demo 1</SPAN></A></LI><LI class="toclevel-2 tocsection-5"><A href="#Demo_2"><SPAN class="tocnumber">3.2</SPAN><SPAN class="toctext">Demo 2</SPAN></A></LI><LI class="toclevel-2 tocsection-6"><A href="#Download"><SPAN class="tocnumber">3.3</SPAN><SPAN class="toctext">Download</SPAN></A></LI></UL><LI class="toclevel-1 tocsection-7"><A href="#Architecture"><SPAN class="tocnumber">4</SPAN><SPAN class="toctext">Architecture</SPAN></A></LI><LI class="toclevel-2 tocsection-8"><A href="#Visualization"><SPAN class="tocnumber">4.1</SPAN><SPAN class="toctext">Visualization</SPAN></A></LI><LI class="toclevel-1 tocsection-9"><A href="#The_underlying_models"><SPAN class="tocnumber">5</SPAN><SPAN class="toctext">The underlying models</SPAN></A></LI><LI class="toclevel-2 tocsection-10"><A href="#Diffusion"><SPAN class="tocnumber">5.1</SPAN><SPAN class="toctext">Diffusion</SPAN></A></LI><LI class="toclevel-2 tocsection-11"><A href="#Streamlines"><SPAN class="tocnumber">5.2</SPAN><SPAN class="toctext">Streamlines</SPAN></A></LI><LI class="toclevel-3 tocsection-12"><A href="#Boundary_conditions"><SPAN class="tocnumber">5.2.1</SPAN><SPAN class="toctext">Boundary conditions</SPAN></A></LI><LI class="toclevel-4 tocsection-13"><A href="#Inlet"><SPAN class="tocnumber">5.2.1.1</SPAN><SPAN class="toctext">Inlet</SPAN></A></LI><LI class="toclevel-4 tocsection-14"><A href="#Outlet"><SPAN class="tocnumber">5.2.1.2</SPAN><SPAN class="toctext">Outlet</SPAN></A></LI><LI class="toclevel-2 tocsection-15"><A href="#Stochastic_reactions"><SPAN class="tocnumber">5.3</SPAN><SPAN class="toctext">Stochastic reactions</SPAN></A></LI><LI class="toclevel-3 tocsection-16"><A href="#Propensity"><SPAN class="tocnumber">5.3.1</SPAN><SPAN class="toctext">Propensity</SPAN></A></LI><LI class="toclevel-3 tocsection-17"><A href="#Gillespie_First_reaction_method"><SPAN class="tocnumber">5.3.2</SPAN><SPAN class="toctext">Gillespie First reaction method</SPAN></A></LI><LI class="toclevel-3 tocsection-18"><A href="#Tau-leaping_and_Dependency_graph"><SPAN class="tocnumber">5.3.3</SPAN><SPAN class="toctext">Tau-leaping and Dependency graph</SPAN></A></LI><LI class="toclevel-1 tocsection-19"><A href="#Download_2"><SPAN class="tocnumber">6</SPAN><SPAN class="toctext">Download</SPAN></A></LI><LI class="toclevel-2 tocsection-20"><A href="#Source_code"><SPAN class="tocnumber">6.1</SPAN><SPAN class="toctext">Source code</SPAN></A></LI><LI class="toclevel-1 tocsection-21"><A href="#References"><SPAN class="tocnumber">7</SPAN><SPAN class="toctext">References</SPAN></A></LI></DIV><DIV class="info-box"><DIV class="left"><H2><SPAN class="mw-headline" id="Abstract">Abstract</SPAN></H2><P>CeCe is a simulation environment capturing in one setting the key processes that influence cell-cell signal transmission. The underlying scene is a simple 2D world. Cells enter and exit this world through predefined channels of arbitrary shape. Each cell executes its own stochastic biochemical reactions and based on its state interacts with the rest of the population. As such, CeCe is easy to setup, intuitive to interpret, and fast to run.
</P></DIV><DIV class="right"><H2><SPAN class="mw-headline" id="Key_Achievements">Key Achievements</SPAN></H2><UL><LI> Provided simulation tool to confirm IOD design</LI><LI> Built in streamlines, diffusion, stochastic reactions, and more</LI><LI> Released under open-source license so everyone can simulate their projects</LI><LI> Highly modular, easy to be extended by community-made plugins</LI><LI> Extendable by Python without having C++ knowledge</LI></UL></DIV></DIV><H1><SPAN class="mw-headline" id="Demo">Demo</SPAN></H1><H2><SPAN class="mw-headline" id="Demo_1">Demo 1</SPAN></H2><DIV class="left" style="width: auto"><VIDEO width="480" height="270" controls=""><SOURCE src="/wiki/images/8/80/Czech_Republic_CeCe_demo.mp4" type="video/mp4"><SOURCE src="/wiki/images/d/d3/Czech_Republic_CeCe_demo.ogg" type="video/ogg"><SOURCE src="/wiki/images/0/00/Czech_Republic_CeCe_demo.webm" type="video/webm">
Your browser does not support the video tag.
</SOURCE></SOURCE></SOURCE></VIDEO></DIV><P>We created a demo simulation to present some of CeCe's features. This simulation contains two different length paths. The slower flow velocity in the bottom path causes signal and cells to accumulate leading to higher cell activation, represented by YFP expression. The connection between tanks shows how the simulator handles differences in pressure.
</P><H2><SPAN class="mw-headline" id="Demo_2">Demo 2</SPAN></H2><DIV class="left" style="width: auto"><VIDEO width="480" height="270" controls=""><SOURCE src="/wiki/images/c/cb/Czech_Republic_CeCe_contamination.mp4" type="video/mp4"><SOURCE src="/wiki/images/a/a2/Czech_Republic_CeCe_contamination.ogg" type="video/ogg"><SOURCE src="/wiki/images/3/30/Czech_Republic_CeCe_contamination.webm" type="video/webm">
Your browser does not support the video tag.
</SOURCE></SOURCE></SOURCE></VIDEO></DIV><P>The second demo shows yeast colony cells reacting to contamination, i.e., cells of different types producing measurable extracellular signals. Contaminating cells are added randomly throughout the scene and produce an invisible signal. When the yeast cells (shown in grey) detect a sufficient amount of the signal in the surrounding medium, they randomly express RFP.
</P><P>This simulation was constructed to model detection of contaminants for <A rel="nofollow" class="external text" href="https://2015.igem.org/Team:Chalmers-Gothenburg">Team Chalmers Gothenburg's</A> Scarlett detection design.
</P><H2><SPAN class="mw-headline" id="Download">Download</SPAN></H2><P>Simulate yourself, both simulation files can be downloaded <A href="/wiki/images/6/6d/Czech_Republic_CeCe_Demos.zip" class="internal" title="Czech Republic CeCe Demos.zip">here</A>.
</P><H1><SPAN class="mw-headline" id="Architecture">Architecture</SPAN></H1><DIV class="thumb tright"><DIV class="thumbinner" style="width:202px;"><DIV class="MediaTransformError" style="width: 200px; height: 176px; display:inline-block;">Error creating thumbnail: File missing</DIV><DIV class="thumbcaption">Simulation iteration scheme</DIV></DIV></DIV><P>The simulator is designed to be highly modular. The simulator's core contains almost no functionality and the missing functionality is provided by plugins. This design allows for an extension of the simulator's functionality by the addition of plugins written by someone else. Plugins are loaded on demand by a simulation file, so unnecessary functionality is never used.
</P><P>Simulation is computed by stepping over independent iterations. Each iteration is defined by a time step and all modules and objects (provided by plugins) are updated. A module is a unit that is updated in each iteration and provides some global functionality (e.g. diffusion). Only one module of the same type is allowed to be in a simulation. Objects are simulation entities that provide some local functionality (e.g. Yeast cells).
</P><P>Objects within a simulation are driven by a physical engine (<A rel="nofollow" class="external text" href="http://box2d.org">Box2D</A>) so interactions between objects look almost realistic. The physical engine uses different time steps (engine is designed for games and generally expects a simulation step around 33 ms) than are used by the simulation and thus the physical engine uses coefficients to convert units between those two systems. The reason for separation of the time steps is that different simulations can require larger time steps (seconds, minutes, ...) - cell growth is a slow process that takes hours and having the same time step does not make sense in the context of the simulation.
</P><P>The simulator is written in <A rel="nofollow" class="external text" href="https://isocpp.org">ISO C++11</A> that provides good performance but is a quite difficult language to pick up. There is also <A rel="nofollow" class="external text" href="https://www.python.org">Python</A> language support for scripting purposes of dynamic parts of a simulation.
</P><H2><SPAN class="mw-headline" id="Visualization">Visualization</SPAN></H2><P>The CeCe simulator has the ability to visualize a given simulation (<A rel="nofollow" class="external text" href="https://www.opengl.org">OpenGL</A>). Final scene visualization is done by a combination of modules and objects visualization (if they provide it). The visualization is fast so a powerful graphics card is not required. Even an integrated GPU is able to render the visualization in real-time.
</P><H1><SPAN class="mw-headline" id="The_underlying_models">The underlying models</SPAN></H1><P>Default simulator package contains several plugins that offer additional functionalities, which are described below. More detailed overview of how the simulator has been used in our project can be found on the <A href="/Team:Czech_Republic/Modeling" title="Team:Czech Republic/Modeling">modeling</A> page.
</P><H2><SPAN class="mw-headline" id="Diffusion">Diffusion</SPAN></H2><P>The diffusion plugin is used to simulate diffusion where regions with high concentrations spread to regions with lower concentrations. Our model is able to account for this by distributing a grid cell concentration between surrounding grid cells.
The following formula is used to compute the signal distribution matrix (in our case it's 3x3):
</P><P>$$M_{i,j} = \frac{1}{4 \pi D dt} \cdot e^{\frac{d_{i,j}^2}{4 D dt}}\;i,\,j = 0, 1, 2$$
</P><P>where \(M\) is mapping matrix, \(D\) is diffusion rate, \(dt\) is time step and \(d_{i,j}\) is cell distance from source cell (\(M_{1,1}\)). For each diffusion grid cell the \(M\) matrix is used to distribute the cell signal between surrounding grid cells.
</P><P>$$G_{x,y+i,j-1,1}^{n+1} = G_{x,y-1,1}^{n} (1 - R_d dt) \bar{M_{i,j}},\;i,\,j = 0, 1, 2;\;x = 0, ... N;\;y = 0, ... M$$
</P><P>where \(G\) is diffusion grid, \(R_d\) is degradation rate, \(\bar{M_{i,j}}\) is normalized \(M_{i,j}\) and \(N\), \(M\) are dimensions of the diffusion grid.
</P><H2><SPAN class="mw-headline" id="Streamlines">Streamlines</SPAN></H2><P>For simulating complex fluid systems, the Lattice Boltzmann method became the de facto standard in last years. This relatively new method works in two steps:
</P><OL><LI> Collision step</LI><LI> Streaming step</LI></OL><P>Collision step computes all distribution functions of a node's mass and streaming step moves that specific mass to another node (in a defined direction).
</P><P>The simulator implements square lattice LBGK model (D2Q9), which is expressed as (collision step):
</P><P>$$f_i(\bar{x} + \bar{e_i}, t + 1) - f_i(\bar{x}, t) = - \frac{1}{\tau}[f_i(\bar{x}, t) - f^{(eq)}_i(\bar{x}, t)], i = 0, 1, ..., 8$$
</P><P>where \(f_i\) is distribution function in direction \(i\), \(\bar{x}\) is current position, \(\bar{e_i}\) is position change in direction \(i\), \(\tau\) is relaxation time and \(f^{(eq)}_i\) is equilibrium distribution function in direction \(i\). The direction \(i\) represents 2D direction of momentum. Node density \(\rho\) and macroscopic flow velocity \(\bar{u}\) can be calculated:
</P><P>$$\sum_{i=0}^{8}f_i = \rho$$
$$\sum_{i=1}^{8}f_i e_i = \rho \bar{u}$$
</P><P>The equilibrium distribution functions \(f^{(eq)}_i\) depends only on local density and velocity. In our case we chose to calculate it in the following way:
</P><P>$$f^{(eq)}_i = \rho \cdot w_i [1 - 3(\bar{e_i} \cdot \bar{u}) + \frac{9}{2}(\bar{e_i} \cdot \bar{u})^2 - \frac{3}{2} \bar{u} \cdot \bar{u}]$$
</P><P>where \(w_i\) is direction weight:
</P><P>$$w_i = \begin{cases} \frac{4}{9} &amp; i = 0\\ \frac{1}{9} &amp; i = 1,2,3,4\\ \frac{1}{36} &amp; i = 5,6,7,8 \end{cases}$$
</P><P>After collision step is performed, the streaming step takes place.
</P><P>$$f_i(\bar{x} + \bar{e_i}, t + 1) = f_i(\bar{x}, t + 1)$$
</P><P>This means the distribution function value is streamed to a next node in that specific direction.
</P><H3><SPAN class="mw-headline" id="Boundary_conditions">Boundary conditions</SPAN></H3><P>Boundary conditions are a quite complex problem. The problem arises from the fact that there is no physical intuition on the behaviour of the velocities at boundaries. Choosing the right boundary conditions plays an important role in the simulation's stability. In our simulator, we implement the boundary conditions defined by Zou and He<SUP id="ref_Zou1997_back" class="ref-back"><A href="#ref_Zou1997">[Zou1997]</A></SUP>.
</P><H4><SPAN class="mw-headline" id="Inlet">Inlet</SPAN></H4><P>At inlet boundary condition, we have no information about the behaviour before the inlet. For each inlet node we compute the density and then use this density and inlet velocity \(\bar{u}\) to compute distribution functions.
</P><P>$$\rho = \frac{1}{1 - \bar{u}_i} (f_{0,2,4} + 2 f_{3,6,7})$$
</P><H4><SPAN class="mw-headline" id="Outlet">Outlet</SPAN></H4><P>At outlet boundary condition, there is no information about the behaviour after the outlet. We thus compute the outlet velocity and then use this velocity with \(\rho = 1\) to compute distribution functions.
</P><P>$$u = -1 + \frac{1}{\rho} (f_{0,2,4} + 2 f_{1,5,8})$$
</P><H2><SPAN class="mw-headline" id="Stochastic_reactions">Stochastic reactions</SPAN></H2><P>In a stochastic reaction, each reaction is defined by the rate and chemical components. To simulate a reaction, you have to know how much of each reactant there is plus how probable it is for the reaction to happen. The chemical components can be divided into two classes:
</P><UL><LI> Non-diffusive</LI><LI> Diffusive</LI></UL><P>Non-diffusive components are proteins, markers, and genes, which do not leave the cell. They may be treated as being present only inside of the cell’s center, i.e., programmatically speaking, each biological cell remembers how many molecules of each component there are.
</P><P>Diffusive components are a bit trickier, because they are not linked to the cell interior but rather to the environment itself. During each step, a routine is run to determine how many molecules of a diffusive component are currently present in the cell's close surroundings.
</P><P>In some simulations, you may need reactions inside the cell, but not diffusive components. To save your resources, diffusive reactions are an optional extension, which may or may not be included in your simulation.
</P><H3><SPAN class="mw-headline" id="Propensity">Propensity</SPAN></H3><P>Each reaction is described by the reactants, the rate, and when talking stochastically, the probability that the reaction happens in the following moments. Usually, a reaction is described by a probability measure called propensity, which is the probability that the reaction fires in the infinitesimal time dt. To simulate a system of chemical reactions, we  need to know how to compute the propensity for simple reactions
</P><DL><DT> Birth</DT><DD> \(\varnothing \Rightarrow k_A \Rightarrow A\), propensity \(k_A\)</DD></DL><DL><DT> Death</DT><DD> \(A \Rightarrow d_A \Rightarrow \varnothing\), propensity \(d_A A\)</DD></DL><DL><DT> Two component</DT><DD> \(A + B \Rightarrow k_{AB} \Rightarrow C\), propensity \(k_{AB} A B\)</DD></DL><P>Probability of the birth reaction is constant, it depends only on its rate, but the probability that something dies increases with the amount of things that can die (the more A's, the higher the probability of any of them dying). Similarly, the probability that something collides increases with amounts of both of things that can collide.
</P><P>It is often useful to write down reactions in terms of a stoichiometric matrix. This matrix’s rows correspond to reactions and columns to species. Each row says how much of a change in species numbers there is if the linked reaction happens. For example consider the following reaction system:
</P><UL><LI> \(\varnothing \Rightarrow k_A \Rightarrow A\)</LI><LI> \(B \Rightarrow d_B \Rightarrow \varnothing\)</LI><LI> \(A + B \Rightarrow k_{AB} \Rightarrow C\)</LI></UL><P>The underlying stoichiometric matrix is
$$\begin{bmatrix}+1 &amp; 0 &amp; 0\\0 &amp; -1 &amp; 0\\ -1 &amp; -1 &amp; +1\end{bmatrix}$$
The number at position i, j says how much of a change in number of j-th species molecules there is
when the i-th reaction fires.
</P><H3><SPAN class="mw-headline" id="Gillespie_First_reaction_method">Gillespie First reaction method</SPAN></H3><P>It can be proved that in a well-mixed solution with the assumption of a thermal equilibrium, the reaction
times have an exponential distribution in time. The simplest way to simulate a stochastic system is the
Gillespie first reaction method. This method consists of the following steps in each iteration
</P><OL><LI> Compute propensities of all reactions in the system</LI><LI> Generate a uniform random variable (0,1)</LI><LI> Calculate the random time of next reaction from the following formula $$ \tau = -\dfrac{1}{\sum\nolimits Propenisty} log[rand[0,1]]$$</LI><LI> Determine which reaction happened – the index of a reaction is the index of the first entry in the cumulative sum of propensities that is greater than $$rand[0,1] \sum\nolimits Propensity$$ </LI><LI> Update the system’s state according to the stoichiometry matrix</LI></OL><H3><SPAN class="mw-headline" id="Tau-leaping_and_Dependency_graph">Tau-leaping and Dependency graph</SPAN></H3><P>Tau-leaping is an enhancement of the Gillespie algorithm, where propensities are updated only once per fixed time step instead of after each reaction. This method makes Gillespie algorithm more efficient in simulating larger systems. On the other hand, this approximation does not fully satisfy the idea of the Gillespie algorithm, because some computations are based on outdated propensities.
</P><P>To have an efficient simulation together with up-to-date propensities, we decided to include the Dependency graph.
This improvement makes recomputation of propensities more effective because propensities are no longer updated all at once, but only those that had changed when a particular reaction occurred. For example, when a reaction with the expression of A has happened, only reactions whose propensity is a function of A are updated. Dependency graph removes the disadvantages of tau-leaping and keeps propensities accurate.
</P><H1><SPAN class="mw-headline" id="Download_2">Download</SPAN></H1><P>Simulator binaries are available to download for following platforms:
</P><UL><LI><A href="/wiki/images/6/6c/Czech_Republic_CeCe_Win64.zip" class="internal" title="Czech Republic CeCe Win64.zip"> Windows 64bit</A></LI><LI><A href="/wiki/images/7/71/Czech_Republic_CeCe_Darwin.zip" class="internal" title="Czech Republic CeCe Darwin.zip"> Mac OS X</A></LI><LI><A href="/wiki/images/6/68/Czech_Republic_CeCe_Linux.zip" class="internal" title="Czech Republic CeCe Linux.zip"> Ubuntu/Mint x64</A></LI></UL><P>Package contains simulator binary, examples, <A href="/Team:Czech_Republic/Software/Manual" title="Team:Czech Republic/Software/Manual">manual</A> and <A href="/Team:Czech_Republic/Software/Tutorial" title="Team:Czech Republic/Software/Tutorial">tutorial</A> (HTML).
</P><H2><SPAN class="mw-headline" id="Source_code">Source code</SPAN></H2><P>The CeCe simulator source code is available on <A rel="nofollow" class="external text" href="http://github.com/GeorgievLab/CeCe">GitHub</A>.
</P><H1><SPAN class="mw-headline" id="References">References</SPAN></H1><OL><LI><CITE id="ref_Zou1997" class="ref"><A href="#ref_Zou1997_back">↑</A> Qisu Zou, Xiaoyi He (1997) On pressure and velocity boundary conditions for the lattice Boltzmann BGK model, Phys. Fluids, 9, 1592-1598</CITE></LI></OL></DIV><DIV id="footer"><DIV id="footer-container"><DIV id="footer-left"><H1>links out</H1><A target="_blank" href="http://www.ccy.zcu.cz">Georgiev Lab</A><A target="_blank" href="http://www.kky.zcu.cz/en">Department of Cybernetics</A><A target="_blank" href="http://www.ntis.zcu.cz/en/">NTIS Research centre</A><A target="_blank" href="https://www.fav.zcu.cz/en/">Faculty of Applied Sciences</A><A target="_blank" href="https://www.zcu.cz/en/">University of West Bohemia</A></DIV><DIV id="footer-right"><H1>contact</H1><ADDRESS><P>Faculty of Applied Sciences</P><P>Technicka 8</P><P>Pilsen 306 14</P><P>Czech Republic</P><P>georgiev@kky.zcu.cz</P></ADDRESS></DIV></DIV></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
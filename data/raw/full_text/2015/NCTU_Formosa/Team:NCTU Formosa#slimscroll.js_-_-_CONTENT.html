<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_NCTU_Formosa_slimscroll_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:NCTU Formosa/slimscroll.js</SPAN></H1><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*! Copyright (c) 2011 Piotr Rochala (<A rel="nofollow" class="external free" href="http://rocha.la">http://rocha.la</A>)
</P><PRE>* Dual licensed under the MIT (<A rel="nofollow" class="external free" href="http://www.opensource.org/licenses/mit-license.php">http://www.opensource.org/licenses/mit-license.php</A>)
* and GPL (<A rel="nofollow" class="external free" href="http://www.opensource.org/licenses/gpl-license.php">http://www.opensource.org/licenses/gpl-license.php</A>) licenses.
*
* Version: 1.3.2 (modified for fullpage.js)
*
*/
</PRE><P>(function($) {
</P><PRE> jQuery.fn.extend({
   slimScroll: function(options) {
</PRE><PRE>     var defaults = {
</PRE><PRE>       // width in pixels of the visible scroll area
       width : 'auto',
</PRE><PRE>       // height in pixels of the visible scroll area
       height : '250px',
</PRE><PRE>       // width in pixels of the scrollbar and rail
       size : '7px',
</PRE><PRE>       // scrollbar color, accepts any hex/color value
       color: '#000',
</PRE><PRE>       // scrollbar position - left/right
       position : 'right',
</PRE><PRE>       // distance in pixels between the side edge and the scrollbar
       distance : '1px',
</PRE><PRE>       // default scroll position on load - top / bottom / $('selector')
       start : 'top',
</PRE><PRE>       // sets scrollbar opacity
       opacity : .4,
</PRE><PRE>       // enables always-on mode for the scrollbar
       alwaysVisible : false,
</PRE><PRE>       // check if we should hide the scrollbar when user is hovering over
       disableFadeOut : false,
</PRE><PRE>       // sets visibility of the rail
       railVisible : false,
</PRE><PRE>       // sets rail color
       railColor : '#333',
</PRE><PRE>       // sets rail opacity
       railOpacity : .2,
</PRE><PRE>       // whether  we should use jQuery UI Draggable to enable bar dragging
       railDraggable : true,
</PRE><PRE>       // defautlt CSS class of the slimscroll rail
       railClass : 'slimScrollRail',
</PRE><PRE>       // defautlt CSS class of the slimscroll bar
       barClass : 'slimScrollBar',
</PRE><PRE>       // defautlt CSS class of the slimscroll wrapper
       wrapperClass : 'slimScrollDiv',
</PRE><PRE>       // check if mousewheel should scroll the window if we reach top/bottom
       allowPageScroll : false,
</PRE><PRE>       // scroll amount applied to each mouse wheel step
       wheelStep : 20,
</PRE><PRE>       // scroll amount applied when user is using gestures
       touchScrollStep : 200,
</PRE><PRE>       // sets border radius
       borderRadius: '7px',
</PRE><PRE>       // sets border radius of the rail
       railBorderRadius : '7px'
     };
</PRE><PRE>     var o = $.extend(defaults, options);
</PRE><PRE>     // do it for every element that matches selector
     this.each(function(){
</PRE><PRE>     var isOverPanel, isOverBar, isDragg, queueHide, touchDif,
       barHeight, percentScroll, lastScroll,
</PRE>
        divS = '',
<PRE>       minBarHeight = 30,
       releaseScroll = false;
</PRE><PRE>       // used in event handlers and for better minification
       var me = $(this);
</PRE><PRE>       // ensure we are not binding it again
       if (me.parent().hasClass(o.wrapperClass))
       {
           // start from last bar position
           var offset = me.scrollTop();
</PRE><PRE>           // find bar and rail
           bar = me.parent().find('.' + o.barClass);
           rail = me.parent().find('.' + o.railClass);
</PRE><PRE>           getBarHeight();
</PRE><PRE>           // check if we should scroll existing instance
           if ($.isPlainObject(options))
           {
             // Pass height: auto to an existing slimscroll object to force a resize after contents have changed
             if ( 'height' in options &amp;&amp; options.height == 'auto' ) {
               me.parent().css('height', 'auto');
               me.css('height', 'auto');
               var height = me.parent().parent().height();
               me.parent().css('height', height);
               me.css('height', height);
             }
</PRE><PRE>             if ('scrollTo' in options)
             {
               // jump to a static point
               offset = parseInt(o.scrollTo);
             }
             else if ('scrollBy' in options)
             {
               // jump by value pixels
               offset += parseInt(o.scrollBy);
             }
             else if ('destroy' in options)
             {
               // clear slimscroll mouse event listeners
               detachWheel();
</PRE><PRE>               // remove slimscroll elements
               bar.remove();
               rail.remove();
               me.unwrap();
               return;
             }
</PRE><PRE>             // scroll content by the given offset
             scrollContent(offset, false, true);
           }
</PRE><PRE>           return;
       }
</PRE><PRE>       // optionally set height to the parent's height
       o.height = (options.height == 'auto') ? me.parent().height() : options.height;
</PRE><PRE>       // wrap content
       var wrapper = $(divS)
         .addClass(o.wrapperClass)
         .css({
           position: 'relative',
           overflow: 'hidden',
           width: o.width,
           height: o.height
         });
</PRE><PRE>       // update style for the div
       me.css({
         overflow: 'hidden',
         width: o.width,
         height: o.height
       });
</PRE><PRE>       // create scrollbar rail
       var rail = $(divS)
         .addClass(o.railClass)
         .css({
           width: o.size,
           height: '100%',
           position: 'absolute',
           top: 0,
           display: (o.alwaysVisible &amp;&amp; o.railVisible) ? 'block' : 'none',
           'border-radius': o.railBorderRadius,
           background: o.railColor,
           opacity: o.railOpacity,
           zIndex: 90
         });
</PRE><PRE>       // create scrollbar
       var bar = $(divS)
         .addClass(o.barClass)
         .css({
           background: o.color,
           width: o.size,
           position: 'absolute',
           top: 0,
           opacity: o.opacity,
           display: o.alwaysVisible ? 'block' : 'none',
           'border-radius' : o.borderRadius,
           BorderRadius: o.borderRadius,
           MozBorderRadius: o.borderRadius,
           WebkitBorderRadius: o.borderRadius,
           zIndex: 99
         });
</PRE><PRE>       // set position
       var posCss = (o.position == 'right') ? { right: o.distance } : { left: o.distance };
       rail.css(posCss);
       bar.css(posCss);
</PRE><PRE>       // wrap it
       me.wrap(wrapper);
</PRE><PRE>       // append to parent div
       me.parent().append(bar);
       me.parent().append(rail);
</PRE><PRE>       // make it draggable and no longer dependent on the jqueryUI
       if (o.railDraggable){
         bar.bind(&quot;mousedown&quot;, function(e) {
           var $doc = $(document);
           isDragg = true;
           t = parseFloat(bar.css('top'));
           pageY = e.pageY;
</PRE><PRE>           $doc.bind(&quot;mousemove.slimscroll&quot;, function(e){
             currTop = t + e.pageY - pageY;
             bar.css('top', currTop);
             scrollContent(0, bar.position().top, false);// scroll content
           });
</PRE><PRE>           $doc.bind(&quot;mouseup.slimscroll&quot;, function(e) {
             isDragg = false;hideBar();
             $doc.unbind('.slimscroll');
           });
           return false;
         }).bind(&quot;selectstart.slimscroll&quot;, function(e){
           e.stopPropagation();
           e.preventDefault();
           return false;
         });
       }
</PRE><PRE>       // on rail over
       rail.hover(function(){
         showBar();
       }, function(){
         hideBar();
       });
</PRE><PRE>       // on bar over
       bar.hover(function(){
         isOverBar = true;
       }, function(){
         isOverBar = false;
       });
</PRE><PRE>       // show on parent mouseover
       me.hover(function(){
         isOverPanel = true;
         showBar();
         hideBar();
       }, function(){
         isOverPanel = false;
         hideBar();
       });
</PRE><PRE>       // support for mobile
       me.bind('touchstart', function(e,b){
         if (e.originalEvent.touches.length)
         {
           // record where touch started
           touchDif = e.originalEvent.touches[0].pageY;
         }
       });
</PRE><PRE>       me.bind('touchmove', function(e){
         // prevent scrolling the page if necessary
         if(!releaseScroll)
         {
 		      e.originalEvent.preventDefault();
</PRE><P>  }
</P><PRE>         if (e.originalEvent.touches.length)
         {
           // see how far user swiped
           var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
           // scroll content
           scrollContent(diff, true);
           touchDif = e.originalEvent.touches[0].pageY;
         }
       });
</PRE><PRE>       // set up initial height
       getBarHeight();
</PRE><PRE>       // check start position
       if (o.start === 'bottom')
       {
         // scroll content to bottom
         bar.css({ top: me.outerHeight() - bar.outerHeight() });
         scrollContent(0, true);
       }
       else if (o.start !== 'top')
       {
         // assume jQuery selector
         scrollContent($(o.start).position().top, null, true);
</PRE><PRE>         // make sure bar stays hidden
         if (!o.alwaysVisible) { bar.hide(); }
       }
</PRE><PRE>       // attach scroll events
       attachWheel();
</PRE><PRE>       function _onWheel(e)
       {
         // use mouse wheel only when mouse is over
         if (!isOverPanel) { return; }
</PRE><PRE>         var e = e || window.event;
</PRE><PRE>         var delta = 0;
         if (e.wheelDelta) { delta = -e.wheelDelta/120; }
         if (e.detail) { delta = e.detail / 3; }
</PRE><PRE>         var target = e.target || e.srcTarget || e.srcElement;
         if ($(target).closest('.' + o.wrapperClass).is(me.parent())) {
           // scroll content
           scrollContent(delta, true);
         }
</PRE><PRE>         // stop window scroll
         if (e.preventDefault &amp;&amp; !releaseScroll) { e.preventDefault(); }
         if (!releaseScroll) { e.returnValue = false; }
       }
</PRE><PRE>       function scrollContent(y, isWheel, isJump)
       {
         releaseScroll = false;
         var delta = y;
         var maxTop = me.outerHeight() - bar.outerHeight();
</PRE><PRE>         if (isWheel)
         {
           // move bar with mouse wheel
           delta = parseInt(bar.css('top')) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();
</PRE><PRE>           // move bar, make sure it doesn't go out
           delta = Math.min(Math.max(delta, 0), maxTop);
</PRE><PRE>           // if scrolling down, make sure a fractional change to the
           // scroll position isn't rounded away when the scrollbar's CSS is set
           // this flooring of delta would happened automatically when
           // bar.css is set below, but we floor here for clarity
           delta = (y &gt; 0) ? Math.ceil(delta) : Math.floor(delta);
</PRE><PRE>           // scroll the scrollbar
           bar.css({ top: delta + 'px' });
         }
</PRE><PRE>         // calculate actual scroll amount
         percentScroll = parseInt(bar.css('top')) / (me.outerHeight() - bar.outerHeight());
         delta = percentScroll * (me[0].scrollHeight - me.outerHeight());
</PRE><PRE>         if (isJump)
         {
           delta = y;
           var offsetTop = delta / me[0].scrollHeight * me.outerHeight();
           offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
           bar.css({ top: offsetTop + 'px' });
         }
</PRE><PRE>         // scroll content
         me.scrollTop(delta);
</PRE><PRE>         // fire scrolling event
         me.trigger('slimscrolling', ~~delta);
</PRE><PRE>         // ensure bar is visible
         showBar();
</PRE><PRE>         // trigger hide when scroll is stopped
         hideBar();
       }
</PRE><PRE>       function attachWheel()
       {
         if (window.addEventListener)
         {
           this.addEventListener('DOMMouseScroll', _onWheel, false );
           this.addEventListener('mousewheel', _onWheel, false );
         }
         else
         {
           document.attachEvent(&quot;onmousewheel&quot;, _onWheel)
         }
       }
</PRE><PRE>       function detachWheel()
       {
         if (window.removeEventListener)
         {
           this.removeEventListener('DOMMouseScroll', _onWheel);
           this.removeEventListener('mousewheel', _onWheel);
         }
         else
         {
           document.detachEvent('onmousewheel', _onWheel);
         }
       }
</PRE><PRE>       function getBarHeight()
       {
         // calculate scrollbar height and make sure it is not too small
         barHeight = Math.max((me.outerHeight() / me[0].scrollHeight) * me.outerHeight(), minBarHeight);
         bar.css({ height: barHeight + 'px' });
</PRE><PRE>         // hide scrollbar if content is not long enough
         var display = barHeight == me.outerHeight() ? 'none' : 'block';
         bar.css({ display: display });
       }
</PRE><PRE>       function showBar()
       {
         // recalculate bar height
         getBarHeight();
         clearTimeout(queueHide);
</PRE><PRE>         // when bar reached top or bottom
         if (percentScroll == ~~percentScroll)
         {
           //release wheel
           releaseScroll = o.allowPageScroll;
</PRE><PRE>           // publish approporiate event
           if (lastScroll != percentScroll)
           {
               var msg = (~~percentScroll == 0) ? 'top' : 'bottom';
               me.trigger('slimscroll', msg);
           }
         }
         else
         {
           releaseScroll = false;
         }
         lastScroll = percentScroll;
</PRE><PRE>         // show only when required
         if(barHeight &gt;= me.outerHeight()) {
           //allow window scroll
           releaseScroll = true;
           return;
         }
         bar.stop(true,true).fadeIn('fast');
         if (o.railVisible) { rail.stop(true,true).fadeIn('fast'); }
       }
</PRE><PRE>       function hideBar()
       {
         // only hide when options allow it
         if (!o.alwaysVisible)
         {
           queueHide = setTimeout(function(){
             if (!(o.disableFadeOut &amp;&amp; isOverPanel) &amp;&amp; !isOverBar &amp;&amp; !isDragg)
             {
               bar.fadeOut('slow');
               rail.fadeOut('slow');
             }
           }, 1000);
         }
       }
</PRE><PRE>     });
</PRE><PRE>     // maintain chainability
     return this;
   }
 });
</PRE><PRE> jQuery.fn.extend({
   slimscroll: jQuery.fn.slimScroll
 });
</PRE><P>})(jQuery);
</P></DIV></DIV></DIV></DIV></BODY></HTML>
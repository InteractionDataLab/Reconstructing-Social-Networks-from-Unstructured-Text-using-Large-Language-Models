<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_USTC-Software_Software skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:USTC-Software/Software</SPAN></H1><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><UL><LI><A href="/Team:USTC-Software" title="Team:USTC-Software">Home</A></LI><LI><A href="/Team:USTC-Software/Description" title="Team:USTC-Software/Description">Project</A></LI><LI><A href="/Team:USTC-Software/Description" title="Team:USTC-Software/Description">Description</A></LI><LI><A href="/Team:USTC-Software/Results" title="Team:USTC-Software/Results">Demo</A></LI><LI><A href="/Team:USTC-Software/Results#Future_Work" title="Team:USTC-Software/Results">Future Work</A></LI><LI><A href="/Team:USTC-Software/Results#Validation" title="Team:USTC-Software/Results">Validation</A></LI></UL><LI><A href="/Team:USTC-Software/Team" title="Team:USTC-Software/Team">Team</A></LI><LI><A href="/Team:USTC-Software/Team#Members" title="Team:USTC-Software/Team">Team Members</A></LI><LI><A href="/Team:USTC-Software/Team#Instructors" title="Team:USTC-Software/Team">Instructors</A></LI><LI><STRONG class="selflink">Technology</STRONG></LI><LI><A href="/Team:USTC-Software/Software#Front_End" title="Team:USTC-Software/Software">Front End</A></LI><LI><A href="/Team:USTC-Software/Software#Back_End" title="Team:USTC-Software/Software">Back End</A></LI><LI><A href="/Team:USTC-Software/Software#Algorithms" title="Team:USTC-Software/Software">Algorithms</A></LI><LI><A href="/Team:USTC-Software/Modeling" title="Team:USTC-Software/Modeling">Modeling</A></LI><LI><A href="/Team:USTC-Software/Notebook" title="Team:USTC-Software/Notebook">Notebook</A></LI><LI><A href="/Team:USTC-Software/Medal" title="Team:USTC-Software/Medal">Requirements</A></LI><LI><A href="/Team:USTC-Software/Medal" title="Team:USTC-Software/Medal">Medal</A></LI><LI><A href="/Team:USTC-Software/Safety" title="Team:USTC-Software/Safety">Safety</A></LI><LI><A href="/Team:USTC-Software/Collaborations" title="Team:USTC-Software/Collaborations">Collaborations</A></LI><LI><A href="/Team:USTC-Software/Practices" title="Team:USTC-Software/Practices">Human Practices</A></LI><LI><A href="/Team:USTC-Software/Practices#Technological_Activity_Week" title="Team:USTC-Software/Practices">Technological Activity Week</A></LI><LI><A href="/Team:USTC-Software/Practices#Meetups" title="Team:USTC-Software/Practices">Meetups</A></LI><LI><A href="/Team:USTC-Software/Attributions" title="Team:USTC-Software/Attributions">Attributions</A></LI><LI><A href="/Team:USTC-Software/Attributions#Support" title="Team:USTC-Software/Attributions">Support</A></LI><LI><A href="/Team:USTC-Software/Attributions#iGEM_HQ" title="Team:USTC-Software/Attributions">iGEM HQ</A></LI><LI><A href="/Team:USTC-Software/Attributions#Fund" title="Team:USTC-Software/Attributions">Fund</A></LI><LI><A href="/Team:USTC-Software/Attributions#Database" title="Team:USTC-Software/Attributions">Database</A></LI><DIV id="main"><DIV id="techcon"><DIV id="frontend"><H1><A id="Front_End">Front End</A></H1><H2>WebGL</H2><P>
                                    To develop a cross-platform software, we use HTML5 and WebGL for the frontend. We use pixi.js as the framework of our software, and decorate the 2D-Canvas in the html &lt;canvas&gt;
                                        for compatibility on browsers which don’t support WebGL.
                                        The aim of this project is to provide a fast lightweight 2D library that works across all devices. The Pixi renderer allows everyone to enjoy the power of hardware acceleration without prior knowledge of WebGL. It is also very fast.
                                </P><H2>Unit Test</H2><P>
                                    We use mocha, chai and phantomjs for unit test.
                                    Mocha is a simple, flexible, fun JavaScript test framework for node.js and browsers. For more information please view the documentation.
                                    Chai is a BDD / TDD assertion library for node and browsers that can be delightfully paired with any JavaScript testing framework.
                                    Phantomjs is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas and SVG.
                                </P><H2>Automated Documentation Generation</H2><P>
                                    We use jsdoc to generate the code documentation and API documentation generator for JavaScript.</P></DIV><DIV id="backend"><H1><A id="Back_End">Back End</A></H1><H2>Separation of Front End &amp; Back End</H2><P>Unlike most websites using MVC architect, we decide to separate front end and back end completely and use REST API as the interface between them. We have made it easier for other biologists and developers to continue work on our basis by decoupling. As a consequence, developers may design their own interface style based on our back end codes and no longer worry about any conflict with present front end codes. </P><H2>Django &amp; Django REST Framework</H2><P>Django is a very popular web framework with MVC architect in python, which is efficient, safe and extendable. Based on Django, we also add Django REST Framework and the function of documents generating, thus we can obtain automatically generated API documentation on <A href="http://ustc.software/docs">ustc.software/docs</A></P><H2>Cython &amp; Ctypes</H2><P>In order to further shorten the time of simulating, we use C programming language to rewrite our simulator. Meanwhile we use the techniques of cython and ctypes to connect the simulator with diango framework. As a result, the speed of simulation is approximately 30 times faster now.</P><H2>Automatic Unit Test &amp; CI</H2><P>Our project is deposited on github to support work division and efficient cooperation. During the development of the project, we use travis-CI for continuous integration and use coverall for coverage test. Thus our software is most likely to operate well as long as the unit test is good. With this method, we can ensure the quality of software and prevent programming bugs.</P></DIV><DIV id="algorithms"><H1><A id="Algorithms">Algorithms</A></H1><H2>Biocircuit (Transformation from a truth table to logic circuits)</H2><P>The Quine-McCluskey algorithm is a method used for minimizing of boolean functions that was developed by W.V.Quine and extended by Edward J.McCluskey.</P><P>Espresso heuristic logic minimizer is a computer program using heuristic and specific algorithms for efficiently reducing the complexity of digital electronic gate circuits.</P><P>Because Espresso is more efficient than Q-M algorithm, especially when inputs are more than 6, we choose Espresso for our software.</P><P>NetworkX is a Python language software package for the creation, manipulation and study of the structure, dynamics and functions of complex networks. </P><P>We use directed graph to characterize biocircuit, and NetworkX has make it more convenient to operate with graphs.</P><P>NumPy is the fundamental package for scientific computing with Python.</P><P>
                                    Pyeda is a Python library for electronic design automation. We once used pyeda to simplify Boolean formulas. However, we found bugs in the process, so we got in touch with its author Chris Drake and submitted the issue. Therefore, we didn't use pyeda directly but make some changes to his espresso model. We are very grateful to his excellent work.
                                </P><H2>Score Calculation for Logic Circuits:</H2><P>
                                    The complexity of electronic circuits essentially depends only on the number of gates, and it can be minimized by the Espresso algorithm. Synthetic biology, however, is distinct from electronics and a gene circuit is much more complex than a logic circuit. We first simplify the truth table input by users to obtain several simplified logic circuits, and then correspond them to a gene circuit. We estimate the complexity of a circuit solution as a function of the number of the regulatory factors involved in the network. Considering the complexity involved in the promoters and RBS, we give a score function.
                                </P><P>$$
			\begin{align*}
			S = 2^{N_\mathrm{R}-1}+2^{N_\mathrm{A}-1}+N_\mathrm{L}+N_\mathrm{K} \\
			
			\end{align*}
			$$ </P><P>$N_R$, $N_A$, $N_L$ and $N_K$ represent the total number of repressors, activators, locks and keys present in the circuit. S does not reflect the quality of a circuit design. The score is intended to characterize its practical realizability. There might be millions of circuits generated automatically by computers, but we only choose the most reliable and representative results for users according to the score.</P><H2>Promotion of Simulation Methods</H2><P>We use the Tao Algorithm based on probability. We have optimized Tao according to some specific characteristics of biology reaction, and have used cache to avoid repeated calculating. </P><H2>Cache of Simulation Results</H2><P>Our bio-system is a kind of graph. The core idea of cache is to find out whether two graphs are the same (isomorphic exactly). As we may know, it is NP-Complete to make sure that two graphs are isomorphic, which means it is very hard to calculate on any computer. But our bio-system is more than just a graph: it has a flow-like direction, to which topological sorts can be applied. However, such kinds of sorts are far from figuring out whether they are isomorphic. So we tried to resolve the graph into chains. It can be proved that these chains can fully describe the graph in our cases. For the depth of our graph is tiny, the algorithm becomes effective. Then we hash the chains, make it easier and faster to sort. After the sort we hash them again to get a number which is big enough to avoid the collision. Then we convert a bio-system into a number. The same numbers imply the same bio-systems. So we will compare the numbers of bio-systems to make sure whether a cache is needed. We store the cache in a folder and limit the total cache size for safety. After all the process above, you can finally use it securely.</P></DIV></DIV></DIV><FOOTER id="attr"><P id="ustc_address">
        University of Science and Technology of China
        No.96, Jinzhai Road, Hefei, Anhui, P.R.China
        USTC-Software 2015
    </P><P id="ustc">
        University of Science and Technology of China
    </P><P id="copyright">©2015 USTC-Software, University of Science and Technology of China. All rights reserved.
    </P><DIV id="contact"><P>We are here for you</P></DIV><DIV id="sponseror"><P>Sponsered by</P></DIV></FOOTER></DIV></DIV></DIV></DIV></BODY></HTML>
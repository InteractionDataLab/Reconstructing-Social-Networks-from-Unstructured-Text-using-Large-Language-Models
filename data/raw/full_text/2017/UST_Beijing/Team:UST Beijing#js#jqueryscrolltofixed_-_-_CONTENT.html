<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_UST_Beijing_js_jqueryscrolltofixed skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:UST Beijing/js/jqueryscrolltofixed</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/**
</P><PRE>* Created by lemon on 2017/10/19.
*/
</PRE><P>/*
</P><PRE>* ScrollToFixed
* <A rel="nofollow" class="external free" href="https://github.com/bigspotteddog/ScrollToFixed">https://github.com/bigspotteddog/ScrollToFixed</A>
*
* Copyright (c) 2011 Joseph Cava-Lynch
* MIT license
*/
</PRE><P>(function($) {
</P><PRE>   $.isScrollToFixed = function(el) {
       return !!$(el).data('ScrollToFixed');
   };
</PRE><PRE>   $.ScrollToFixed = function(el, options) {
       // To avoid scope issues, use 'base' instead of 'this' to reference this
       // class from internal events and functions.
       var base = this;
</PRE><PRE>       // Access to jQuery and DOM versions of element.
       base.$el = $(el);
       base.el = el;
</PRE><PRE>       // Add a reverse reference to the DOM object.
       base.$el.data('ScrollToFixed', base);
</PRE><PRE>       // A flag so we know if the scroll has been reset.
       var isReset = false;
</PRE><PRE>       // The element that was given to us to fix if scrolled above the top of
       // the page.
       var target = base.$el;
</PRE><PRE>       var position;
       var originalPosition;
       var originalOffsetTop;
       var originalZIndex;
</PRE><PRE>       // The offset top of the element when resetScroll was called. This is
       // used to determine if we have scrolled past the top of the element.
       var offsetTop = 0;
</PRE><PRE>       // The offset left of the element when resetScroll was called. This is
       // used to move the element left or right relative to the horizontal
       // scroll.
       var offsetLeft = 0;
       var originalOffsetLeft = -1;
</PRE><PRE>       // This last offset used to move the element horizontally. This is used
       // to determine if we need to move the element because we would not want
       // to do that for no reason.
       var lastOffsetLeft = -1;
</PRE><PRE>       // This is the element used to fill the void left by the target element
       // when it goes fixed; otherwise, everything below it moves up the page.
       var spacer = null;
</PRE><PRE>       var spacerClass;
</PRE><PRE>       var className;
</PRE><PRE>       // Capture the original offsets for the target element. This needs to be
       // called whenever the page size changes or when the page is first
       // scrolled. For some reason, calling this before the page is first
       // scrolled causes the element to become fixed too late.
       function resetScroll() {
           // Set the element to it original positioning.
           target.trigger('preUnfixed.ScrollToFixed');
           setUnfixed();
           target.trigger('unfixed.ScrollToFixed');
</PRE><PRE>           // Reset the last offset used to determine if the page has moved
           // horizontally.
           lastOffsetLeft = -1;
</PRE><PRE>           // Capture the offset top of the target element.
           offsetTop = target.offset().top;
</PRE><PRE>           // Capture the offset left of the target element.
           offsetLeft = target.offset().left;
</PRE><PRE>           // If the offsets option is on, alter the left offset.
           if (base.options.offsets) {
               offsetLeft += (target.offset().left - target.position().left);
           }
</PRE><PRE>           if (originalOffsetLeft == -1) {
               originalOffsetLeft = offsetLeft;
           }
</PRE><PRE>           position = target.css('position');
</PRE><PRE>           // Set that this has been called at least once.
           isReset = true;
</PRE><PRE>           if (base.options.bottom != -1) {
               target.trigger('preFixed.ScrollToFixed');
               setFixed();
               target.trigger('fixed.ScrollToFixed');
           }
       }
</PRE><PRE>       function getLimit() {
           var limit = base.options.limit;
           if (!limit) return 0;
</PRE><PRE>           if (typeof(limit) === 'function') {
               return limit.apply(target);
           }
           return limit;
       }
</PRE><PRE>       // Returns whether the target element is fixed or not.
       function isFixed() {
           return position === 'fixed';
       }
</PRE><PRE>       // Returns whether the target element is absolute or not.
       function isAbsolute() {
           return position === 'absolute';
       }
</PRE><PRE>       function isUnfixed() {
           return !(isFixed() || isAbsolute());
       }
</PRE><PRE>       // Sets the target element to fixed. Also, sets the spacer to fill the
       // void left by the target element.
       function setFixed() {
           // Only fix the target element and the spacer if we need to.
           if (!isFixed()) {
               // Set the spacer to fill the height and width of the target
               // element, then display it.
               spacer.css({
                   'display' : target.css('display'),
                   'width' : target.outerWidth(true),
                   'height' : target.outerHeight(true),
                   'float' : target.css('float')
               });
</PRE><PRE>               // Set the target element to fixed and set its width so it does
               // not fill the rest of the page horizontally. Also, set its top
               // to the margin top specified in the options.
</PRE><PRE>               cssOptions={
                   'z-index' : base.options.zIndex,
                   'position' : 'fixed',
                   'top' : base.options.bottom == -1?getMarginTop():<I>,</I>
                   'bottom' : base.options.bottom == -1?<I>:base.options.bottom,</I>
                   'margin-left' : '0px'
               }
               if (!base.options.dontSetWidth){ cssOptions['width']=target.width(); };
</PRE><PRE>               target.css(cssOptions);
</PRE><PRE>               target.addClass(base.options.baseClassName);
</PRE><PRE>               if (base.options.className) {
                   target.addClass(base.options.className);
               }
</PRE><PRE>               position = 'fixed';
           }
       }
</PRE><PRE>       function setAbsolute() {
</PRE><PRE>           var top = getLimit();
           var left = offsetLeft;
</PRE><PRE>           if (base.options.removeOffsets) {
               left = <I>;</I>   top = top - offsetTop;
           }
</PRE><PRE>           cssOptions={
             'position' : 'absolute',
             'top' : top,
             'left' : left,
             'margin-left' : '0px',
             'bottom' : 
           }
           if (!base.options.dontSetWidth){ cssOptions['width']=target.width(); };
</PRE><PRE>           target.css(cssOptions);
</PRE><PRE>           position = 'absolute';
       }
</PRE><PRE>       // Sets the target element back to unfixed. Also, hides the spacer.
       function setUnfixed() {
           // Only unfix the target element and the spacer if we need to.
           if (!isUnfixed()) {
               lastOffsetLeft = -1;
</PRE><PRE>               // Hide the spacer now that the target element will fill the
               // space.
               spacer.css('display', 'none');
</PRE><PRE>               // Remove the style attributes that were added to the target.
               // This will reverse the target back to the its original style.
               target.css({
                   'z-index' : originalZIndex,
                   'width' : <I>,</I>
                   'position' : originalPosition,
                   'left' : <I>,</I>
                   'top' : originalOffsetTop,
                   'margin-left' : 
               });
</PRE><PRE>               target.removeClass('scroll-to-fixed-fixed');
</PRE><PRE>               if (base.options.className) {
                   target.removeClass(base.options.className);
               }
</PRE><PRE>               position = null;
           }
       }
</PRE><PRE>       // Moves the target element left or right relative to the horizontal
       // scroll position.
       function setLeft(x) {
           // Only if the scroll is not what it was last time we did this.
           if (x != lastOffsetLeft) {
               // Move the target element horizontally relative to its original
               // horizontal position.
               target.css('left', offsetLeft - x);
</PRE><PRE>               // Hold the last horizontal position set.
               lastOffsetLeft = x;
           }
       }
</PRE><PRE>       function getMarginTop() {
           var marginTop = base.options.marginTop;
           if (!marginTop) return 0;
</PRE><PRE>           if (typeof(marginTop) === 'function') {
               return marginTop.apply(target);
           }
           return marginTop;
       }
</PRE><PRE>       // Checks to see if we need to do something based on new scroll position
       // of the page.
       function checkScroll() {
           if (!$.isScrollToFixed(target)) return;
           var wasReset = isReset;
</PRE><PRE>           // If resetScroll has not yet been called, call it. This only
           // happens once.
           if (!isReset) {
               resetScroll();
           } else if (isUnfixed()) {
               // if the offset has changed since the last scroll,
               // we need to get it again.
</PRE><PRE>               // Capture the offset top of the target element.
               offsetTop = target.offset().top;
</PRE><PRE>               // Capture the offset left of the target element.
               offsetLeft = target.offset().left;
           }
</PRE><PRE>           // Grab the current horizontal scroll position.
           var x = $(window).scrollLeft();
</PRE><PRE>           // Grab the current vertical scroll position.
           var y = $(window).scrollTop();
</PRE><PRE>           // Get the limit, if there is one.
           var limit = getLimit();
</PRE><PRE>           // If the vertical scroll position, plus the optional margin, would
           // put the target element at the specified limit, set the target
           // element to absolute.
           if (base.options.minWidth &amp;&amp; $(window).width() &lt; base.options.minWidth) {
               if (!isUnfixed() || !wasReset) {
                   postPosition();
                   target.trigger('preUnfixed.ScrollToFixed');
                   setUnfixed();
                   target.trigger('unfixed.ScrollToFixed');
               }
           } else if (base.options.maxWidth &amp;&amp; $(window).width() &gt; base.options.maxWidth) {
               if (!isUnfixed() || !wasReset) {
                   postPosition();
                   target.trigger('preUnfixed.ScrollToFixed');
                   setUnfixed();
                   target.trigger('unfixed.ScrollToFixed');
               }
           } else if (base.options.bottom == -1) {
               // If the vertical scroll position, plus the optional margin, would
               // put the target element at the specified limit, set the target
               // element to absolute.
               if (limit &gt; 0 &amp;&amp; y &gt;= limit - getMarginTop()) {
                   if (!isAbsolute() || !wasReset) {
                       postPosition();
                       target.trigger('preAbsolute.ScrollToFixed');
                       setAbsolute();
                       target.trigger('unfixed.ScrollToFixed');
                   }
               // If the vertical scroll position, plus the optional margin, would
               // put the target element above the top of the page, set the target
               // element to fixed.
               } else if (y &gt;= offsetTop - getMarginTop()) {
                   if (!isFixed() || !wasReset) {
                       postPosition();
                       target.trigger('preFixed.ScrollToFixed');
</PRE><PRE>                       // Set the target element to fixed.
                       setFixed();
</PRE><PRE>                       // Reset the last offset left because we just went fixed.
                       lastOffsetLeft = -1;
</PRE><PRE>                       target.trigger('fixed.ScrollToFixed');
                   }
                   // If the page has been scrolled horizontally as well, move the
                   // target element accordingly.
                   setLeft(x);
               } else {
                   // Set the target element to unfixed, placing it where it was
                   // before.
                   if (!isUnfixed() || !wasReset) {
                       postPosition();
                       target.trigger('preUnfixed.ScrollToFixed');
                       setUnfixed();
                       target.trigger('unfixed.ScrollToFixed');
                   }
               }
           } else {
               if (limit &gt; 0) {
                   if (y + $(window).height() - target.outerHeight(true) &gt;= limit - (getMarginTop() || -getBottom())) {
                       if (isFixed()) {
                           postPosition();
                           target.trigger('preUnfixed.ScrollToFixed');
</PRE><PRE>                           if (originalPosition === 'absolute') {
                               setAbsolute();
                           } else {
                               setUnfixed();
                           }
</PRE><PRE>                           target.trigger('unfixed.ScrollToFixed');
                       }
                   } else {
                       if (!isFixed()) {
                           postPosition();
                           target.trigger('preFixed.ScrollToFixed');
                           setFixed();
                       }
                       setLeft(x);
                       target.trigger('fixed.ScrollToFixed');
                   }
               } else {
                   setLeft(x);
               }
           }
       }
</PRE><PRE>       function getBottom() {
           if (!base.options.bottom) return 0;
           return base.options.bottom;
       }
</PRE><PRE>       function postPosition() {
           var position = target.css('position');
</PRE><PRE>           if (position == 'absolute') {
               target.trigger('postAbsolute.ScrollToFixed');
           } else if (position == 'fixed') {
               target.trigger('postFixed.ScrollToFixed');
           } else {
               target.trigger('postUnfixed.ScrollToFixed');
           }
       }
</PRE><PRE>       var windowResize = function(event) {
           // Check if the element is visible before updating it's position, which
           // improves behavior with responsive designs where this element is hidden.
           if(target.is(':visible')) {
               isReset = false;
               checkScroll();
           }
       }
</PRE><PRE>       var windowScroll = function(event) {
           (!!window.requestAnimationFrame) ? requestAnimationFrame(checkScroll) : checkScroll();
       }
</PRE><PRE>       // From: <A rel="nofollow" class="external free" href="http://kangax.github.com/cft/#IS_POSITION_FIXED_SUPPORTED">http://kangax.github.com/cft/#IS_POSITION_FIXED_SUPPORTED</A>
       var isPositionFixedSupported = function() {
           var container = document.body;
</PRE><PRE>           if (document.createElement &amp;&amp; container &amp;&amp; container.appendChild &amp;&amp; container.removeChild) {
               var el = document.createElement('div');
</PRE><PRE>               if (!el.getBoundingClientRect) return null;
</PRE><PRE>               el.innerHTML = 'x';
               el.style.cssText = 'position:fixed;top:100px;';
               container.appendChild(el);
</PRE><PRE>               var originalHeight = container.style.height,
               originalScrollTop = container.scrollTop;
</PRE><PRE>               container.style.height = '3000px';
               container.scrollTop = 500;
</PRE><PRE>               var elementTop = el.getBoundingClientRect().top;
               container.style.height = originalHeight;
</PRE><PRE>               var isSupported = (elementTop === 100);
               container.removeChild(el);
               container.scrollTop = originalScrollTop;
</PRE><PRE>               return isSupported;
           }
</PRE><PRE>           return null;
       }
</PRE><PRE>       var preventDefault = function(e) {
           e = e || window.event;
           if (e.preventDefault) {
               e.preventDefault();
           }
           e.returnValue = false;
       }
</PRE><PRE>       // Initializes this plugin. Captures the options passed in, turns this
       // off for devices that do not support fixed position, adds the spacer,
       // and binds to the window scroll and resize events.
       base.init = function() {
           // Capture the options for this plugin.
           base.options = $.extend({}, $.ScrollToFixed.defaultOptions, options);
</PRE><PRE>           originalZIndex = target.css('z-index')
</PRE><PRE>           // Turn off this functionality for devices that do not support it.
           // if (!(base.options &amp;&amp; base.options.dontCheckForPositionFixedSupport)) {
           //     var fixedSupported = isPositionFixedSupported();
           //     if (!fixedSupported) return;
           // }
</PRE><PRE>           // Put the target element on top of everything that could be below
           // it. This reduces flicker when the target element is transitioning
           // to fixed.
           base.$el.css('z-index', base.options.zIndex);
</PRE><PRE>           // Create a spacer element to fill the void left by the target
           // element when it goes fixed.
           spacer = $('&lt;div /&gt;');
</PRE><PRE>           position = target.css('position');
           originalPosition = target.css('position');
</PRE><PRE>           originalOffsetTop = target.css('top');
</PRE><PRE>           // Place the spacer right after the target element.
           if (isUnfixed()) base.$el.after(spacer);
</PRE><PRE>           // Reset the target element offsets when the window is resized, then
           // check to see if we need to fix or unfix the target element.
           $(window).bind('resize.ScrollToFixed', windowResize);
</PRE><PRE>           // When the window scrolls, check to see if we need to fix or unfix
           // the target element.
           $(window).bind('scroll.ScrollToFixed', windowScroll);
</PRE><PRE>           // For touch devices, call checkScroll directlly rather than
           // rAF wrapped windowScroll to animate the element
           if ('ontouchmove' in window) {
             $(window).bind('touchmove.ScrollToFixed', checkScroll);
           }
</PRE><PRE>           if (base.options.preFixed) {
               target.bind('preFixed.ScrollToFixed', base.options.preFixed);
           }
           if (base.options.postFixed) {
               target.bind('postFixed.ScrollToFixed', base.options.postFixed);
           }
           if (base.options.preUnfixed) {
               target.bind('preUnfixed.ScrollToFixed', base.options.preUnfixed);
           }
           if (base.options.postUnfixed) {
               target.bind('postUnfixed.ScrollToFixed', base.options.postUnfixed);
           }
           if (base.options.preAbsolute) {
               target.bind('preAbsolute.ScrollToFixed', base.options.preAbsolute);
           }
           if (base.options.postAbsolute) {
               target.bind('postAbsolute.ScrollToFixed', base.options.postAbsolute);
           }
           if (base.options.fixed) {
               target.bind('fixed.ScrollToFixed', base.options.fixed);
           }
           if (base.options.unfixed) {
               target.bind('unfixed.ScrollToFixed', base.options.unfixed);
           }
</PRE><PRE>           if (base.options.spacerClass) {
               spacer.addClass(base.options.spacerClass);
           }
</PRE><PRE>           target.bind('resize.ScrollToFixed', function() {
               spacer.height(target.height());
           });
</PRE><PRE>           target.bind('scroll.ScrollToFixed', function() {
               target.trigger('preUnfixed.ScrollToFixed');
               setUnfixed();
               target.trigger('unfixed.ScrollToFixed');
               checkScroll();
           });
</PRE><PRE>           target.bind('detach.ScrollToFixed', function(ev) {
               preventDefault(ev);
</PRE><PRE>               target.trigger('preUnfixed.ScrollToFixed');
               setUnfixed();
               target.trigger('unfixed.ScrollToFixed');
</PRE><PRE>               $(window).unbind('resize.ScrollToFixed', windowResize);
               $(window).unbind('scroll.ScrollToFixed', windowScroll);
</PRE><PRE>               target.unbind('.ScrollToFixed');
</PRE><PRE>               //remove spacer from dom
               spacer.remove();
</PRE><PRE>               base.$el.removeData('ScrollToFixed');
           });
</PRE><PRE>           // Reset everything.
           windowResize();
       };
</PRE><PRE>       // Initialize the plugin.
       base.init();
   };
</PRE><PRE>   // Sets the option defaults.
   $.ScrollToFixed.defaultOptions = {
       marginTop : 0,
       limit : 0,
       bottom : -1,
       zIndex : 1000,
       baseClassName: 'scroll-to-fixed-fixed'
   };
</PRE><PRE>   // Returns enhanced elements that will fix to the top of the page when the
   // page is scrolled.
   $.fn.scrollToFixed = function(options) {
       return this.each(function() {
           (new $.ScrollToFixed(this, options));
       });
   };
</PRE><P>})(jQuery);
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
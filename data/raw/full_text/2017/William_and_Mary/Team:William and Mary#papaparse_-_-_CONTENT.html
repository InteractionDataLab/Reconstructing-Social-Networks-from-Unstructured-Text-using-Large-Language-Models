<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_William_and_Mary_papaparse skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:William and Mary/papaparse</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
	Papa Parse
	v4.3.2
	<A rel="nofollow" class="external free" href="https://github.com/mholt/PapaParse">https://github.com/mholt/PapaParse</A></P><UL><LI>/</LI></UL><P>(function(root, factory)
{
	if (typeof define === 'function' &amp;&amp; define.amd)
	{
		// AMD. Register as an anonymous module.
		define([], factory);
	}
	else if (typeof module === 'object' &amp;&amp; module.exports)
	{
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	}
	else
	{
		// Browser globals (root is window)
		root.Papa = factory();
	}
}(this, function()
{
	'use strict';
</P><P>	var global = (function () {
		// alternative method, similar to `Function('return this')()`
		// but without using `eval` (which is disabled when
		// using Content Security Policy).
</P><P>		if (typeof self !== 'undefined') { return self; }
		if (typeof window !== 'undefined') { return window; }
		if (typeof global !== 'undefined') { return global; }
</P><PRE>       // When running tests none of the above have been defined
       return {};
</PRE><P>	})();
</P><P>
	var IS_WORKER = !global.document &amp;&amp; !!global.postMessage,
		IS_PAPA_WORKER = IS_WORKER &amp;&amp; /(\?|&amp;)papaworker(=|&amp;|$)/.test(global.location.search),
		LOADED_SYNC = false, AUTO_SCRIPT_PATH;
	var workers = {}, workerIdCounter = 0;
</P><P>	var Papa = {};
</P><P>	Papa.parse = CsvToJson;
	Papa.unparse = JsonToCsv;
</P><P>	Papa.RECORD_SEP = String.fromCharCode(30);
	Papa.UNIT_SEP = String.fromCharCode(31);
	Papa.BYTE_ORDER_MARK = '\ufeff';
	Papa.BAD_DELIMITERS = ['\r', '\n', '&quot;', Papa.BYTE_ORDER_MARK];
	Papa.WORKERS_SUPPORTED = !IS_WORKER &amp;&amp; !!global.Worker;
	Papa.SCRIPT_PATH = null;	// Must be set by your code if you use workers and this lib is loaded asynchronously
</P><P>	// Configurable chunk sizes for local and remote files, respectively
	Papa.LocalChunkSize = 1024 * 1024 * 10;	// 10 MB
	Papa.RemoteChunkSize = 1024 * 1024 * 5;	// 5 MB
	Papa.DefaultDelimiter = ',';			// Used if not specified and detection fails
</P><P>	// Exposed for testing and development only
	Papa.Parser = Parser;
	Papa.ParserHandle = ParserHandle;
	Papa.NetworkStreamer = NetworkStreamer;
	Papa.FileStreamer = FileStreamer;
	Papa.StringStreamer = StringStreamer;
	Papa.ReadableStreamStreamer = ReadableStreamStreamer;
</P><P>	if (global.jQuery)
	{
		var $ = global.jQuery;
		$.fn.parse = function(options)
		{
			var config = options.config || {};
			var queue = [];
</P><P>			this.each(function(idx)
			{
				var supported = $(this).prop('tagName').toUpperCase() === 'INPUT'
								&amp;&amp; $(this).attr('type').toLowerCase() === 'file'
								&amp;&amp; global.FileReader;
</P><P>				if (!supported || !this.files || this.files.length === 0)
					return true;	// continue to next input element
</P><P>				for (var i = 0; i &lt; this.files.length; i++)
				{
					queue.push({
						file: this.files[i],
						inputElem: this,
						instanceConfig: $.extend({}, config)
					});
				}
			});
</P><P>			parseNextFile();	// begin parsing
			return this;		// maintains chainability
</P><P>
			function parseNextFile()
			{
				if (queue.length === 0)
				{
					if (isFunction(options.complete))
						options.complete();
					return;
				}
</P><P>				var f = queue[0];
</P><P>				if (isFunction(options.before))
				{
					var returned = options.before(f.file, f.inputElem);
</P><P>					if (typeof returned === 'object')
					{
						if (returned.action === 'abort')
						{
							error('AbortError', f.file, f.inputElem, returned.reason);
							return;	// Aborts all queued files immediately
						}
						else if (returned.action === 'skip')
						{
							fileComplete();	// parse the next file in the queue, if any
							return;
						}
						else if (typeof returned.config === 'object')
							f.instanceConfig = $.extend(f.instanceConfig, returned.config);
					}
					else if (returned === 'skip')
					{
						fileComplete();	// parse the next file in the queue, if any
						return;
					}
				}
</P><P>				// Wrap up the user's complete callback, if any, so that ours also gets executed
				var userCompleteFunc = f.instanceConfig.complete;
				f.instanceConfig.complete = function(results)
				{
					if (isFunction(userCompleteFunc))
						userCompleteFunc(results, f.file, f.inputElem);
					fileComplete();
				};
</P><P>				Papa.parse(f.file, f.instanceConfig);
			}
</P><P>			function error(name, file, elem, reason)
			{
				if (isFunction(options.error))
					options.error({name: name}, file, elem, reason);
			}
</P><P>			function fileComplete()
			{
				queue.splice(0, 1);
				parseNextFile();
			}
		}
	}
</P><P>
	if (IS_PAPA_WORKER)
	{
		global.onmessage = workerThreadReceivedMessage;
	}
	else if (Papa.WORKERS_SUPPORTED)
	{
		AUTO_SCRIPT_PATH = getScriptPath();
</P><P>		// Check if the script was loaded synchronously
		if (!document.body)
		{
			// Body doesn't exist yet, must be synchronous
			LOADED_SYNC = true;
		}
		else
		{
			document.addEventListener('DOMContentLoaded', function () {
				LOADED_SYNC = true;
			}, true);
		}
	}
</P><P>
	function CsvToJson(_input, _config)
	{
		_config = _config || {};
</P><PRE>       var dynamicTyping = _config.dynamicTyping || false;
       if (isFunction(dynamicTyping)) {
           _config.dynamicTypingFunction = dynamicTyping;
           // Will be filled on first row call
           dynamicTyping = {};
       }
       _config.dynamicTyping = dynamicTyping;
</PRE><P>		if (_config.worker &amp;&amp; Papa.WORKERS_SUPPORTED)
		{
			var w = newWorker();
</P><P>			w.userStep = _config.step;
			w.userChunk = _config.chunk;
			w.userComplete = _config.complete;
			w.userError = _config.error;
</P><P>			_config.step = isFunction(_config.step);
			_config.chunk = isFunction(_config.chunk);
			_config.complete = isFunction(_config.complete);
			_config.error = isFunction(_config.error);
			delete _config.worker;	// prevent infinite loop
</P><P>			w.postMessage({
				input: _input,
				config: _config,
				workerId: w.id
			});
</P><P>			return;
		}
</P><P>		var streamer = null;
		if (typeof _input === 'string')
		{
			if (_config.download)
				streamer = new NetworkStreamer(_config);
			else
				streamer = new StringStreamer(_config);
		}
		else if (_input.readable === true &amp;&amp; isFunction(_input.read) &amp;&amp; isFunction(_input.on))
		{
			streamer = new ReadableStreamStreamer(_config);
		}
		else if ((global.File &amp;&amp; _input instanceof File) || _input instanceof Object)	// ...Safari. (see issue #106)
			streamer = new FileStreamer(_config);
</P><P>		return streamer.stream(_input);
	}
</P><P>
	function JsonToCsv(_input, _config)
	{
		var _output = <I>;</I>
		var _fields = [];
</P><P>		// Default configuration
</P><P>		/** whether to surround every datum with quotes */
		var _quotes = false;
</P><P>		/** whether to write headers */
		var _writeHeader = true;
</P><P>		/** delimiting character */
		var _delimiter = ',';
</P><P>		/** newline character(s) */
		var _newline = '\r\n';
</P><P>		/** quote character */
		var _quoteChar = '&quot;';
</P><P>		unpackConfig();
</P><P>		var quoteCharRegex = new RegExp(_quoteChar, 'g');
</P><P>		if (typeof _input === 'string')
			_input = JSON.parse(_input);
</P><P>		if (_input instanceof Array)
		{
			if (!_input.length || _input[0] instanceof Array)
				return serialize(null, _input);
			else if (typeof _input[0] === 'object')
				return serialize(objectKeys(_input[0]), _input);
		}
		else if (typeof _input === 'object')
		{
			if (typeof _input.data === 'string')
				_input.data = JSON.parse(_input.data);
</P><P>			if (_input.data instanceof Array)
			{
				if (!_input.fields)
					_input.fields =  _input.meta &amp;&amp; _input.meta.fields;
</P><P>				if (!_input.fields)
					_input.fields =  _input.data[0] instanceof Array
									? _input.fields
									: objectKeys(_input.data[0]);
</P><P>				if (!(_input.data[0] instanceof Array) &amp;&amp; typeof _input.data[0] !== 'object')
					_input.data = [_input.data];	// handles input like [1,2,3] or ['asdf']
			}
</P><P>			return serialize(_input.fields || [], _input.data || []);
		}
</P><P>		// Default (any valid paths should return before this)
		throw 'exception: Unable to serialize unrecognized input';
</P><P>
		function unpackConfig()
		{
			if (typeof _config !== 'object')
				return;
</P><P>			if (typeof _config.delimiter === 'string'
				&amp;&amp; _config.delimiter.length === 1
				&amp;&amp; Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)
			{
				_delimiter = _config.delimiter;
			}
</P><P>			if (typeof _config.quotes === 'boolean'
				|| _config.quotes instanceof Array)
				_quotes = _config.quotes;
</P><P>			if (typeof _config.newline === 'string')
				_newline = _config.newline;
</P><P>			if (typeof _config.quoteChar === 'string')
				_quoteChar = _config.quoteChar;
</P><P>			if (typeof _config.header === 'boolean')
				_writeHeader = _config.header;
		}
</P><P>
		/** Turns an object's keys into an array */
		function objectKeys(obj)
		{
			if (typeof obj !== 'object')
				return [];
			var keys = [];
			for (var key in obj)
				keys.push(key);
			return keys;
		}
</P><P>		/** The double for loop that iterates the data and writes out a CSV string including header row */
		function serialize(fields, data)
		{
			var csv = <I>;</I></P><P>			if (typeof fields === 'string')
				fields = JSON.parse(fields);
			if (typeof data === 'string')
				data = JSON.parse(data);
</P><P>			var hasHeader = fields instanceof Array &amp;&amp; fields.length &gt; 0;
			var dataKeyedByField = !(data[0] instanceof Array);
</P><P>			// If there a header row, write it first
			if (hasHeader &amp;&amp; _writeHeader)
			{
				for (var i = 0; i &lt; fields.length; i++)
				{
					if (i &gt; 0)
						csv += _delimiter;
					csv += safe(fields[i], i);
				}
				if (data.length &gt; 0)
					csv += _newline;
			}
</P><P>			// Then write out the data
			for (var row = 0; row &lt; data.length; row++)
			{
				var maxCol = hasHeader ? fields.length : data[row].length;
</P><P>				for (var col = 0; col &lt; maxCol; col++)
				{
					if (col &gt; 0)
						csv += _delimiter;
					var colIdx = hasHeader &amp;&amp; dataKeyedByField ? fields[col] : col;
					csv += safe(data[row][colIdx], col);
				}
</P><P>				if (row &lt; data.length - 1)
					csv += _newline;
			}
</P><P>			return csv;
		}
</P><P>		/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
		function safe(str, col)
		{
			if (typeof str === 'undefined' || str === null)
				return <I>;</I></P><P>			str = str.toString().replace(quoteCharRegex, _quoteChar+_quoteChar);
</P><P>			var needsQuotes = (typeof _quotes === 'boolean' &amp;&amp; _quotes)
							|| (_quotes instanceof Array &amp;&amp; _quotes[col])
							|| hasAny(str, Papa.BAD_DELIMITERS)
							|| str.indexOf(_delimiter) &gt; -1
							|| str.charAt(0) === ' '
							|| str.charAt(str.length - 1) === ' ';
</P><P>			return needsQuotes ? _quoteChar + str + _quoteChar : str;
		}
</P><P>		function hasAny(str, substrings)
		{
			for (var i = 0; i &lt; substrings.length; i++)
				if (str.indexOf(substrings[i]) &gt; -1)
					return true;
			return false;
		}
	}
</P><P>	/** ChunkStreamer is the base prototype for various streamer implementations. */
	function ChunkStreamer(config)
	{
		this._handle = null;
		this._paused = false;
		this._finished = false;
		this._input = null;
		this._baseIndex = 0;
		this._partialLine = <I>;</I>
		this._rowCount = 0;
		this._start = 0;
		this._nextChunk = null;
		this.isFirstChunk = true;
		this._completeResults = {
			data: [],
			errors: [],
			meta: {}
		};
		replaceConfig.call(this, config);
</P><P>		this.parseChunk = function(chunk)
		{
			// First chunk pre-processing
			if (this.isFirstChunk &amp;&amp; isFunction(this._config.beforeFirstChunk))
			{
				var modifiedChunk = this._config.beforeFirstChunk(chunk);
				if (modifiedChunk !== undefined)
					chunk = modifiedChunk;
			}
			this.isFirstChunk = false;
</P><P>			// Rejoin the line we likely just split in two by chunking the file
			var aggregate = this._partialLine + chunk;
			this._partialLine = <I>;</I></P><P>			var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);
</P><P>			if (this._handle.paused() || this._handle.aborted())
				return;
</P><P>			var lastIndex = results.meta.cursor;
</P><P>			if (!this._finished)
			{
				this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
				this._baseIndex = lastIndex;
			}
</P><P>			if (results &amp;&amp; results.data)
				this._rowCount += results.data.length;
</P><P>			var finishedIncludingPreview = this._finished || (this._config.preview &amp;&amp; this._rowCount &gt;= this._config.preview);
</P><P>			if (IS_PAPA_WORKER)
			{
				global.postMessage({
					results: results,
					workerId: Papa.WORKER_ID,
					finished: finishedIncludingPreview
				});
			}
			else if (isFunction(this._config.chunk))
			{
				this._config.chunk(results, this._handle);
				if (this._paused)
					return;
				results = undefined;
				this._completeResults = undefined;
			}
</P><P>			if (!this._config.step &amp;&amp; !this._config.chunk) {
				this._completeResults.data = this._completeResults.data.concat(results.data);
				this._completeResults.errors = this._completeResults.errors.concat(results.errors);
				this._completeResults.meta = results.meta;
			}
</P><P>			if (finishedIncludingPreview &amp;&amp; isFunction(this._config.complete) &amp;&amp; (!results || !results.meta.aborted))
				this._config.complete(this._completeResults, this._input);
</P><P>			if (!finishedIncludingPreview &amp;&amp; (!results || !results.meta.paused))
				this._nextChunk();
</P><P>			return results;
		};
</P><P>		this._sendError = function(error)
		{
			if (isFunction(this._config.error))
				this._config.error(error);
			else if (IS_PAPA_WORKER &amp;&amp; this._config.error)
			{
				global.postMessage({
					workerId: Papa.WORKER_ID,
					error: error,
					finished: false
				});
			}
		};
</P><P>		function replaceConfig(config)
		{
			// Deep-copy the config so we can edit it
			var configCopy = copy(config);
			configCopy.chunkSize = parseInt(configCopy.chunkSize);	// parseInt VERY important so we don't concatenate strings!
			if (!config.step &amp;&amp; !config.chunk)
				configCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196
			this._handle = new ParserHandle(configCopy);
			this._handle.streamer = this;
			this._config = configCopy;	// persist the copy to the caller
		}
	}
</P><P>
	function NetworkStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.RemoteChunkSize;
		ChunkStreamer.call(this, config);
</P><P>		var xhr;
</P><P>		if (IS_WORKER)
		{
			this._nextChunk = function()
			{
				this._readChunk();
				this._chunkLoaded();
			};
		}
		else
		{
			this._nextChunk = function()
			{
				this._readChunk();
			};
		}
</P><P>		this.stream = function(url)
		{
			this._input = url;
			this._nextChunk();	// Starts streaming
		};
</P><P>		this._readChunk = function()
		{
			if (this._finished)
			{
				this._chunkLoaded();
				return;
			}
</P><P>			xhr = new XMLHttpRequest();
</P><P>			if (this._config.withCredentials)
			{
				xhr.withCredentials = this._config.withCredentials;
			}
</P><P>			if (!IS_WORKER)
			{
				xhr.onload = bindFunction(this._chunkLoaded, this);
				xhr.onerror = bindFunction(this._chunkError, this);
			}
</P><P>			xhr.open('GET', this._input, !IS_WORKER);
			// Headers can only be set when once the request state is OPENED
			if (this._config.downloadRequestHeaders)
			{
				var headers = this._config.downloadRequestHeaders;
</P><P>				for (var headerName in headers)
				{
					xhr.setRequestHeader(headerName, headers[headerName]);
				}
			}
</P><P>			if (this._config.chunkSize)
			{
				var end = this._start + this._config.chunkSize - 1;	// minus one because byte range is inclusive
				xhr.setRequestHeader('Range', 'bytes='+this._start+'-'+end);
				xhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // <A rel="nofollow" class="external free" href="https://bugs.webkit.org/show_bug.cgi?id=82672">https://bugs.webkit.org/show_bug.cgi?id=82672</A>
			}
</P><P>			try {
				xhr.send();
			}
			catch (err) {
				this._chunkError(err.message);
			}
</P><P>			if (IS_WORKER &amp;&amp; xhr.status === 0)
				this._chunkError();
			else
				this._start += this._config.chunkSize;
		}
</P><P>		this._chunkLoaded = function()
		{
			if (xhr.readyState != 4)
				return;
</P><P>			if (xhr.status &lt; 200 || xhr.status &gt;= 400)
			{
				this._chunkError();
				return;
			}
</P><P>			this._finished = !this._config.chunkSize || this._start &gt; getFileSize(xhr);
			this.parseChunk(xhr.responseText);
		}
</P><P>		this._chunkError = function(errorMessage)
		{
			var errorText = xhr.statusText || errorMessage;
			this._sendError(errorText);
		}
</P><P>		function getFileSize(xhr)
		{
			var contentRange = xhr.getResponseHeader('Content-Range');
			if (contentRange === null) { // no content range, then finish!
</P><PRE>       			return -1;
           		}
</PRE><P>			return parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));
		}
	}
	NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
	NetworkStreamer.prototype.constructor = NetworkStreamer;
</P><P>
	function FileStreamer(config)
	{
		config = config || {};
		if (!config.chunkSize)
			config.chunkSize = Papa.LocalChunkSize;
		ChunkStreamer.call(this, config);
</P><P>		var reader, slice;
</P><P>		// FileReader is better than FileReaderSync (even in worker) - see <A rel="nofollow" class="external free" href="http://stackoverflow.com/q/24708649/1048862">http://stackoverflow.com/q/24708649/1048862</A>
		// But Firefox is a pill, too - see issue #76: <A rel="nofollow" class="external free" href="https://github.com/mholt/PapaParse/issues/76">https://github.com/mholt/PapaParse/issues/76</A>
		var usingAsyncReader = typeof FileReader !== 'undefined';	// Safari doesn't consider it a function - see issue #105
</P><P>		this.stream = function(file)
		{
			this._input = file;
			slice = file.slice || file.webkitSlice || file.mozSlice;
</P><P>			if (usingAsyncReader)
			{
				reader = new FileReader();		// Preferred method of reading files, even in workers
				reader.onload = bindFunction(this._chunkLoaded, this);
				reader.onerror = bindFunction(this._chunkError, this);
			}
			else
				reader = new FileReaderSync();	// Hack for running in a web worker in Firefox
</P><P>			this._nextChunk();	// Starts streaming
		};
</P><P>		this._nextChunk = function()
		{
			if (!this._finished &amp;&amp; (!this._config.preview || this._rowCount &lt; this._config.preview))
				this._readChunk();
		}
</P><P>		this._readChunk = function()
		{
			var input = this._input;
			if (this._config.chunkSize)
			{
				var end = Math.min(this._start + this._config.chunkSize, this._input.size);
				input = slice.call(input, this._start, end);
			}
			var txt = reader.readAsText(input, this._config.encoding);
			if (!usingAsyncReader)
				this._chunkLoaded({ target: { result: txt } });	// mimic the async signature
		}
</P><P>		this._chunkLoaded = function(event)
		{
			// Very important to increment start each time before handling results
			this._start += this._config.chunkSize;
			this._finished = !this._config.chunkSize || this._start &gt;= this._input.size;
			this.parseChunk(event.target.result);
		}
</P><P>		this._chunkError = function()
		{
			this._sendError(reader.error);
		}
</P><P>	}
	FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
	FileStreamer.prototype.constructor = FileStreamer;
</P><P>
	function StringStreamer(config)
	{
		config = config || {};
		ChunkStreamer.call(this, config);
</P><P>		var string;
		var remaining;
		this.stream = function(s)
		{
			string = s;
			remaining = s;
			return this._nextChunk();
		}
		this._nextChunk = function()
		{
			if (this._finished) return;
			var size = this._config.chunkSize;
			var chunk = size ? remaining.substr(0, size) : remaining;
			remaining = size ? remaining.substr(size) : <I>;</I>
			this._finished = !remaining;
			return this.parseChunk(chunk);
		}
	}
	StringStreamer.prototype = Object.create(StringStreamer.prototype);
	StringStreamer.prototype.constructor = StringStreamer;
</P><P>
	function ReadableStreamStreamer(config)
	{
		config = config || {};
</P><P>		ChunkStreamer.call(this, config);
</P><P>		var queue = [];
		var parseOnData = true;
</P><P>		this.stream = function(stream)
		{
			this._input = stream;
</P><P>			this._input.on('data', this._streamData);
			this._input.on('end', this._streamEnd);
			this._input.on('error', this._streamError);
		}
</P><P>		this._nextChunk = function()
		{
			if (queue.length)
			{
				this.parseChunk(queue.shift());
			}
			else
			{
				parseOnData = true;
			}
		}
</P><P>		this._streamData = bindFunction(function(chunk)
		{
			try
			{
				queue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));
</P><P>				if (parseOnData)
				{
					parseOnData = false;
					this.parseChunk(queue.shift());
				}
			}
			catch (error)
			{
				this._streamError(error);
			}
		}, this);
</P><P>		this._streamError = bindFunction(function(error)
		{
			this._streamCleanUp();
			this._sendError(error.message);
		}, this);
</P><P>		this._streamEnd = bindFunction(function()
		{
			this._streamCleanUp();
			this._finished = true;
			this._streamData(<I>);</I>
		}, this);
</P><P>		this._streamCleanUp = bindFunction(function()
		{
			this._input.removeListener('data', this._streamData);
			this._input.removeListener('end', this._streamEnd);
			this._input.removeListener('error', this._streamError);
		}, this);
	}
	ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
	ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;
</P><P>
	// Use one ParserHandle per entire CSV file or string
	function ParserHandle(_config)
	{
		// One goal is to minimize the use of regular expressions...
		var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
</P><P>		var self = this;
		var _stepCounter = 0;	// Number of times step was called (number of rows parsed)
		var _input;				// The input being parsed
		var _parser;			// The core parser being used
		var _paused = false;	// Whether we are paused or not
		var _aborted = false;   // Whether the parser has aborted or not
		var _delimiterError;	// Temporary state between delimiter detection and processing results
		var _fields = [];		// Fields are from the header row of the input, if there is one
		var _results = {		// The last results returned from the parser
			data: [],
			errors: [],
			meta: {}
		};
</P><P>		if (isFunction(_config.step))
		{
			var userStep = _config.step;
			_config.step = function(results)
			{
				_results = results;
</P><P>				if (needsHeaderRow())
					processResults();
				else	// only call user's step function after header row
				{
					processResults();
</P><P>					// It's possbile that this line was empty and there's no row here after all
					if (_results.data.length === 0)
						return;
</P><P>					_stepCounter += results.data.length;
					if (_config.preview &amp;&amp; _stepCounter &gt; _config.preview)
						_parser.abort();
					else
						userStep(_results, self);
				}
			};
		}
</P><P>		/**
		 * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
		 * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
		 * when an input comes in multiple chunks, like from a file.
		 */
		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			if (!_config.newline)
				_config.newline = guessLineEndings(input);
</P><P>			_delimiterError = false;
			if (!_config.delimiter)
			{
				var delimGuess = guessDelimiter(input, _config.newline);
				if (delimGuess.successful)
					_config.delimiter = delimGuess.bestDelimiter;
				else
				{
					_delimiterError = true;	// add error after parsing (otherwise it would be overwritten)
					_config.delimiter = Papa.DefaultDelimiter;
				}
				_results.meta.delimiter = _config.delimiter;
			}
			else if(isFunction(_config.delimiter))
			{
				_config.delimiter = _config.delimiter(input);
				_results.meta.delimiter = _config.delimiter;
			}
</P><P>			var parserConfig = copy(_config);
			if (_config.preview &amp;&amp; _config.header)
				parserConfig.preview++;	// to compensate for header row
</P><P>			_input = input;
			_parser = new Parser(parserConfig);
			_results = _parser.parse(_input, baseIndex, ignoreLastRow);
			processResults();
			return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });
		};
</P><P>		this.paused = function()
		{
			return _paused;
		};
</P><P>		this.pause = function()
		{
			_paused = true;
			_parser.abort();
			_input = _input.substr(_parser.getCharIndex());
		};
</P><P>		this.resume = function()
		{
			_paused = false;
			self.streamer.parseChunk(_input);
		};
</P><P>		this.aborted = function ()
		{
			return _aborted;
		};
</P><P>		this.abort = function()
		{
			_aborted = true;
			_parser.abort();
			_results.meta.aborted = true;
			if (isFunction(_config.complete))
				_config.complete(_results);
			_input = <I>;</I>
		};
</P><P>		function processResults()
		{
			if (_results &amp;&amp; _delimiterError)
			{
				addError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \<I>+Papa.DefaultDelimiter+'\</I>);
				_delimiterError = false;
			}
</P><P>			if (_config.skipEmptyLines)
			{
				for (var i = 0; i &lt; _results.data.length; i++)
					if (_results.data[i].length === 1 &amp;&amp; _results.data[i][0] === <I>)</I>
						_results.data.splice(i--, 1);
			}
</P><P>			if (needsHeaderRow())
				fillHeaderFields();
</P><P>			return applyHeaderAndDynamicTyping();
		}
</P><P>		function needsHeaderRow()
		{
			return _config.header &amp;&amp; _fields.length === 0;
		}
</P><P>		function fillHeaderFields()
		{
			if (!_results)
				return;
			for (var i = 0; needsHeaderRow() &amp;&amp; i &lt; _results.data.length; i++)
				for (var j = 0; j &lt; _results.data[i].length; j++)
					_fields.push(_results.data[i][j]);
			_results.data.splice(0, 1);
		}
</P><PRE>       function shouldApplyDynamicTyping(field) {
           // Cache function values to avoid calling it for each row
           if (_config.dynamicTypingFunction &amp;&amp; _config.dynamicTyping[field] === undefined) {
               _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
           }
           return (_config.dynamicTyping[field] || _config.dynamicTyping) === true
       }
</PRE><P>		function parseDynamic(field, value)
		{
			if (shouldApplyDynamicTyping(field))
			{
				if (value === 'true' || value === 'TRUE')
					return true;
				else if (value === 'false' || value === 'FALSE')
					return false;
				else
					return tryParseFloat(value);
			}
			return value;
		}
</P><P>		function applyHeaderAndDynamicTyping()
		{
			if (!_results || (!_config.header &amp;&amp; !_config.dynamicTyping))
				return _results;
</P><P>			for (var i = 0; i &lt; _results.data.length; i++)
			{
				var row = _config.header ? {} : [];
</P><P>				for (var j = 0; j &lt; _results.data[i].length; j++)
				{
					var field = j;
					var value = _results.data[i][j];
</P><P>					if (_config.header)
						field = j &gt;= _fields.length ? '__parsed_extra' : _fields[j];
</P><P>					value = parseDynamic(field, value);
</P><P>					if (field === '__parsed_extra')
					{
						row[field] = row[field] || [];
						row[field].push(value);
					}
					else
						row[field] = value;
				}
</P><P>				_results.data[i] = row;
</P><P>				if (_config.header)
				{
					if (j &gt; _fields.length)
						addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
					else if (j &lt; _fields.length)
						addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);
				}
			}
</P><P>			if (_config.header &amp;&amp; _results.meta)
				_results.meta.fields = _fields;
			return _results;
		}
</P><P>		function guessDelimiter(input, newline)
		{
			var delimChoices = [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];
			var bestDelim, bestDelta, fieldCountPrevRow;
</P><P>			for (var i = 0; i &lt; delimChoices.length; i++)
			{
				var delim = delimChoices[i];
				var delta = 0, avgFieldCount = 0;
				fieldCountPrevRow = undefined;
</P><P>			var preview = new Parser({
					delimiter: delim,
					newline: newline,
					preview: 10
				}).parse(input);
</P><P>				for (var j = 0; j &lt; preview.data.length; j++)
				{
					var fieldCount = preview.data[j].length;
					avgFieldCount += fieldCount;
</P><P>					if (typeof fieldCountPrevRow === 'undefined')
					{
						fieldCountPrevRow = fieldCount;
						continue;
					}
					else if (fieldCount &gt; 1)
					{
						delta += Math.abs(fieldCount - fieldCountPrevRow);
						fieldCountPrevRow = fieldCount;
					}
				}
</P><P>				if (preview.data.length &gt; 0)
					avgFieldCount /= preview.data.length;
</P><P>				if ((typeof bestDelta === 'undefined' || delta &lt; bestDelta)
					&amp;&amp; avgFieldCount &gt; 1.99)
				{
					bestDelta = delta;
					bestDelim = delim;
				}
			}
</P><P>			_config.delimiter = bestDelim;
</P><P>			return {
				successful: !!bestDelim,
				bestDelimiter: bestDelim
			}
		}
</P><P>		function guessLineEndings(input)
		{
			input = input.substr(0, 1024*1024);	// max length 1 MB
</P><P>			var r = input.split('\r');
</P><P>			var n = input.split('\n');
</P><P>			var nAppearsFirst = (n.length &gt; 1 &amp;&amp; n[0].length &lt; r[0].length);
</P><P>			if (r.length === 1 || nAppearsFirst)
				return '\n';
</P><P>			var numWithN = 0;
			for (var i = 0; i &lt; r.length; i++)
			{
				if (r[i][0] === '\n')
					numWithN++;
			}
</P><P>			return numWithN &gt;= r.length / 2 ? '\r\n' : '\r';
		}
</P><P>		function tryParseFloat(val)
		{
			var isNumber = FLOAT.test(val);
			return isNumber ? parseFloat(val) : val;
		}
</P><P>		function addError(type, code, msg, row)
		{
			_results.errors.push({
				type: type,
				code: code,
				message: msg,
				row: row
			});
		}
	}
</P><P>	/** The core parser implements speedy and correct CSV parsing */
	function Parser(config)
	{
		// Unpack the config object
		config = config || {};
		var delim = config.delimiter;
		var newline = config.newline;
		var comments = config.comments;
		var step = config.step;
		var preview = config.preview;
		var fastMode = config.fastMode;
		var quoteChar = config.quoteChar || '&quot;';
</P><P>		// Delimiter must be valid
		if (typeof delim !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(delim) &gt; -1)
			delim = ',';
</P><P>		// Comment character must be valid
		if (comments === delim)
			throw 'Comment character same as delimiter';
		else if (comments === true)
			comments = '#';
		else if (typeof comments !== 'string'
			|| Papa.BAD_DELIMITERS.indexOf(comments) &gt; -1)
			comments = false;
</P><P>		// Newline must be valid: \r, \n, or \r\n
		if (newline != '\n' &amp;&amp; newline != '\r' &amp;&amp; newline != '\r\n')
			newline = '\n';
</P><P>		// We're gonna need these at the Parser scope
		var cursor = 0;
		var aborted = false;
</P><P>		this.parse = function(input, baseIndex, ignoreLastRow)
		{
			// For some reason, in Chrome, this speeds things up (!?)
			if (typeof input !== 'string')
				throw 'Input must be a string';
</P><P>			// We don't need to compute some of these every time parse() is called,
			// but having them in a more local scope seems to perform better
			var inputLen = input.length,
				delimLen = delim.length,
				newlineLen = newline.length,
				commentsLen = comments.length;
			var stepIsFunction = isFunction(step);
</P><P>			// Establish starting state
			cursor = 0;
			var data = [], errors = [], row = [], lastCursor = 0;
</P><P>			if (!input)
				return returnable();
</P><P>			if (fastMode || (fastMode !== false &amp;&amp; input.indexOf(quoteChar) === -1))
			{
				var rows = input.split(newline);
				for (var i = 0; i &lt; rows.length; i++)
				{
					var row = rows[i];
					cursor += row.length;
					if (i !== rows.length - 1)
						cursor += newline.length;
					else if (ignoreLastRow)
						return returnable();
					if (comments &amp;&amp; row.substr(0, commentsLen) === comments)
						continue;
					if (stepIsFunction)
					{
						data = [];
						pushRow(row.split(delim));
						doStep();
						if (aborted)
							return returnable();
					}
					else
						pushRow(row.split(delim));
					if (preview &amp;&amp; i &gt;= preview)
					{
						data = data.slice(0, preview);
						return returnable(true);
					}
				}
				return returnable();
			}
</P><P>			var nextDelim = input.indexOf(delim, cursor);
			var nextNewline = input.indexOf(newline, cursor);
			var quoteCharRegex = new RegExp(quoteChar+quoteChar, 'g');
</P><P>			// Parser loop
			for (;;)
			{
				// Field has opening quote
				if (input[cursor] === quoteChar)
				{
					// Start our search for the closing quote where the cursor is
					var quoteSearch = cursor;
</P><P>					// Skip the opening quote
					cursor++;
</P><P>					for (;;)
					{
						// Find closing quote
						var quoteSearch = input.indexOf(quoteChar, quoteSearch+1);
</P><P>						if (quoteSearch === -1)
						{
							if (!ignoreLastRow) {
								// No closing quote... what a pity
								errors.push({
									type: 'Quotes',
									code: 'MissingQuotes',
									message: 'Quoted field unterminated',
									row: data.length,	// row has yet to be inserted
									index: cursor
								});
							}
							return finish();
						}
</P><P>						if (quoteSearch === inputLen-1)
						{
							// Closing quote at EOF
							var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
							return finish(value);
						}
</P><P>						// If this quote is escaped, it's part of the data; skip it
						if (input[quoteSearch+1] === quoteChar)
						{
							quoteSearch++;
							continue;
						}
</P><P>						if (input[quoteSearch+1] === delim)
						{
							// Closing quote followed by delimiter
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							cursor = quoteSearch + 1 + delimLen;
							nextDelim = input.indexOf(delim, cursor);
							nextNewline = input.indexOf(newline, cursor);
							break;
						}
</P><P>						if (input.substr(quoteSearch+1, newlineLen) === newline)
						{
							// Closing quote followed by newline
							row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
							saveRow(quoteSearch + 1 + newlineLen);
							nextDelim = input.indexOf(delim, cursor);	// because we may have skipped the nextDelim in the quoted field
</P><P>							if (stepIsFunction)
							{
								doStep();
								if (aborted)
									return returnable();
							}
</P><P>							if (preview &amp;&amp; data.length &gt;= preview)
								return returnable(true);
</P><P>							break;
						}
					}
</P><P>					continue;
				}
</P><P>				// Comment found at start of new line
				if (comments &amp;&amp; row.length === 0 &amp;&amp; input.substr(cursor, commentsLen) === comments)
				{
					if (nextNewline === -1)	// Comment ends at EOF
						return returnable();
					cursor = nextNewline + newlineLen;
					nextNewline = input.indexOf(newline, cursor);
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}
</P><P>				// Next delimiter comes before next newline, so we've reached end of field
				if (nextDelim !== -1 &amp;&amp; (nextDelim &lt; nextNewline || nextNewline === -1))
				{
					row.push(input.substring(cursor, nextDelim));
					cursor = nextDelim + delimLen;
					nextDelim = input.indexOf(delim, cursor);
					continue;
				}
</P><P>				// End of row
				if (nextNewline !== -1)
				{
					row.push(input.substring(cursor, nextNewline));
					saveRow(nextNewline + newlineLen);
</P><P>					if (stepIsFunction)
					{
						doStep();
						if (aborted)
							return returnable();
					}
</P><P>					if (preview &amp;&amp; data.length &gt;= preview)
						return returnable(true);
</P><P>					continue;
				}
</P><P>				break;
			}
</P><P>
			return finish();
</P><P>
			function pushRow(row)
			{
				data.push(row);
				lastCursor = cursor;
			}
</P><P>			/**
			 * Appends the remaining input from cursor to the end into
			 * row, saves the row, calls step, and returns the results.
			 */
			function finish(value)
			{
				if (ignoreLastRow)
					return returnable();
				if (typeof value === 'undefined')
					value = input.substr(cursor);
				row.push(value);
				cursor = inputLen;	// important in case parsing is paused
				pushRow(row);
				if (stepIsFunction)
					doStep();
				return returnable();
			}
</P><P>			/**
			 * Appends the current row to the results. It sets the cursor
			 * to newCursor and finds the nextNewline. The caller should
			 * take care to execute user's step function and check for
			 * preview and end parsing if necessary.
			 */
			function saveRow(newCursor)
			{
				cursor = newCursor;
				pushRow(row);
				row = [];
				nextNewline = input.indexOf(newline, cursor);
			}
</P><P>			/** Returns an object with the results, errors, and meta. */
			function returnable(stopped)
			{
				return {
					data: data,
					errors: errors,
					meta: {
						delimiter: delim,
						linebreak: newline,
						aborted: aborted,
						truncated: !!stopped,
						cursor: lastCursor + (baseIndex || 0)
					}
				};
			}
</P><P>			/** Executes the user's step function and resets data &amp; errors. */
			function doStep()
			{
				step(returnable());
				data = [], errors = [];
			}
		};
</P><P>		/** Sets the abort flag */
		this.abort = function()
		{
			aborted = true;
		};
</P><P>		/** Gets the cursor position */
		this.getCharIndex = function()
		{
			return cursor;
		};
	}
</P><P>
	// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code
	// the script path here. See: <A rel="nofollow" class="external free" href="https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358">https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358</A>
	function getScriptPath()
	{
		var scripts = document.getElementsByTagName('script');
		return scripts.length ? scripts[scripts.length - 1].src : <I>;</I>
	}
</P><P>	function newWorker()
	{
		if (!Papa.WORKERS_SUPPORTED)
			return false;
		if (!LOADED_SYNC &amp;&amp; Papa.SCRIPT_PATH === null)
			throw new Error(
				'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +
				'You need to set Papa.SCRIPT_PATH manually.'
			);
		var workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;
		// Append 'papaworker' to the search string to tell papaparse that this is our worker.
		workerUrl += (workerUrl.indexOf('?') !== -1 ? '&amp;' : '?') + 'papaworker';
		var w = new global.Worker(workerUrl);
		w.onmessage = mainThreadReceivedMessage;
		w.id = workerIdCounter++;
		workers[w.id] = w;
		return w;
	}
</P><P>	/** Callback when main thread receives a message */
	function mainThreadReceivedMessage(e)
	{
		var msg = e.data;
		var worker = workers[msg.workerId];
		var aborted = false;
</P><P>		if (msg.error)
			worker.userError(msg.error, msg.file);
		else if (msg.results &amp;&amp; msg.results.data)
		{
			var abort = function() {
				aborted = true;
				completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
			};
</P><P>			var handle = {
				abort: abort,
				pause: notImplemented,
				resume: notImplemented
			};
</P><P>			if (isFunction(worker.userStep))
			{
				for (var i = 0; i &lt; msg.results.data.length; i++)
				{
					worker.userStep({
						data: [msg.results.data[i]],
						errors: msg.results.errors,
						meta: msg.results.meta
					}, handle);
					if (aborted)
						break;
				}
				delete msg.results;	// free memory ASAP
			}
			else if (isFunction(worker.userChunk))
			{
				worker.userChunk(msg.results, handle, msg.file);
				delete msg.results;
			}
		}
</P><P>		if (msg.finished &amp;&amp; !aborted)
			completeWorker(msg.workerId, msg.results);
	}
</P><P>	function completeWorker(workerId, results) {
		var worker = workers[workerId];
		if (isFunction(worker.userComplete))
			worker.userComplete(results);
		worker.terminate();
		delete workers[workerId];
	}
</P><P>	function notImplemented() {
		throw 'Not implemented.';
	}
</P><P>	/** Callback when worker thread receives a message */
	function workerThreadReceivedMessage(e)
	{
		var msg = e.data;
</P><P>		if (typeof Papa.WORKER_ID === 'undefined' &amp;&amp; msg)
			Papa.WORKER_ID = msg.workerId;
</P><P>		if (typeof msg.input === 'string')
		{
			global.postMessage({
				workerId: Papa.WORKER_ID,
				results: Papa.parse(msg.input, msg.config),
				finished: true
			});
		}
		else if ((global.File &amp;&amp; msg.input instanceof File) || msg.input instanceof Object)	// thank you, Safari (see issue #106)
		{
			var results = Papa.parse(msg.input, msg.config);
			if (results)
				global.postMessage({
					workerId: Papa.WORKER_ID,
					results: results,
					finished: true
				});
		}
	}
</P><P>	/** Makes a deep copy of an array or object (mostly) */
	function copy(obj)
	{
		if (typeof obj !== 'object')
			return obj;
		var cpy = obj instanceof Array ? [] : {};
		for (var key in obj)
			cpy[key] = copy(obj[key]);
		return cpy;
	}
</P><P>	function bindFunction(f, self)
	{
		return function() { f.apply(self, arguments); };
	}
</P><P>	function isFunction(func)
	{
		return typeof func === 'function';
	}
</P><P>	return Papa;
}));
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
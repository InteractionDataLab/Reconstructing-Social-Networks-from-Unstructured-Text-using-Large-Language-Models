<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Utrecht_Template_Prototypejs_Javascript skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Utrecht/Template:Prototypejs/Javascript</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*  Prototype JavaScript framework, version 1.7.2
</P><PRE>*  (c) 2005-2010 Sam Stephenson
*
*  Prototype is freely distributable under the terms of an MIT-style license.
*  For details, see the Prototype web site: <A rel="nofollow" class="external free" href="http://www.prototypejs.org/">http://www.prototypejs.org/</A>
*
*--------------------------------------------------------------------------*/
</PRE><P>var Prototype = {
</P><PRE> Version: '1.7.2',
</PRE><PRE> Browser: (function(){
   var ua = navigator.userAgent;
   var isOpera = Object.prototype.toString.call(window.opera) == '[object Opera]';
   return {
     IE:             !!window.attachEvent &amp;&amp; !isOpera,
     Opera:          isOpera,
     WebKit:         ua.indexOf('AppleWebKit/') &gt; -1,
     Gecko:          ua.indexOf('Gecko') &gt; -1 &amp;&amp; ua.indexOf('KHTML') === -1,
     MobileSafari:   /Apple.*Mobile/.test(ua)
   }
 })(),
</PRE><PRE> BrowserFeatures: {
   XPath: !!document.evaluate,
</PRE><PRE>   SelectorsAPI: !!document.querySelector,
</PRE><PRE>   ElementExtensions: (function() {
     var constructor = window.Element || window.HTMLElement;
     return !!(constructor &amp;&amp; constructor.prototype);
   })(),
   SpecificElementExtensions: (function() {
     if (typeof window.HTMLDivElement !== 'undefined')
       return true;
</PRE><PRE>     var div = document.createElement('div'),
         form = document.createElement('form'),
         isSupported = false;
</PRE><PRE>     if (div['__proto__'] &amp;&amp; (div['__proto__'] !== form['__proto__'])) {
       isSupported = true;
     }
</PRE><PRE>     div = form = null;
</PRE><PRE>     return isSupported;
   })()
 },
</PRE><PRE> ScriptFragment: '&lt;script[^&gt;]*&gt;([\\S\\s]*?)&lt;\/script\\s*&gt;',
 JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,
</PRE><PRE> emptyFunction: function() { },
</PRE><PRE> K: function(x) { return x }
</PRE><P>};
</P><P>if (Prototype.Browser.MobileSafari)
</P><PRE> Prototype.BrowserFeatures.SpecificElementExtensions = false;
</PRE><P>/* Based on Alex Arnell's inheritance implementation. */
</P><P>var Class = (function() {
</P><PRE> var IS_DONTENUM_BUGGY = (function(){
   for (var p in { toString: 1 }) {
     if (p === 'toString') return false;
   }
   return true;
 })();
</PRE><PRE> function subclass() {};
 function create() {
   var parent = null, properties = $A(arguments);
   if (Object.isFunction(properties[0]))
     parent = properties.shift();
</PRE><PRE>   function klass() {
     this.initialize.apply(this, arguments);
   }
</PRE><PRE>   Object.extend(klass, Class.Methods);
   klass.superclass = parent;
   klass.subclasses = [];
</PRE><PRE>   if (parent) {
     subclass.prototype = parent.prototype;
     klass.prototype = new subclass;
     parent.subclasses.push(klass);
   }
</PRE><PRE>   for (var i = 0, length = properties.length; i &lt; length; i++)
     klass.addMethods(properties[i]);
</PRE><PRE>   if (!klass.prototype.initialize)
     klass.prototype.initialize = Prototype.emptyFunction;
</PRE><PRE>   klass.prototype.constructor = klass;
   return klass;
 }
</PRE><PRE> function addMethods(source) {
   var ancestor   = this.superclass &amp;&amp; this.superclass.prototype,
       properties = Object.keys(source);
</PRE><PRE>   if (IS_DONTENUM_BUGGY) {
     if (source.toString != Object.prototype.toString)
       properties.push(&quot;toString&quot;);
     if (source.valueOf != Object.prototype.valueOf)
       properties.push(&quot;valueOf&quot;);
   }
</PRE><PRE>   for (var i = 0, length = properties.length; i &lt; length; i++) {
     var property = properties[i], value = source[property];
     if (ancestor &amp;&amp; Object.isFunction(value) &amp;&amp;
         value.argumentNames()[0] == &quot;$super&quot;) {
       var method = value;
       value = (function(m) {
         return function() { return ancestor[m].apply(this, arguments); };
       })(property).wrap(method);
</PRE><PRE>       value.valueOf = (function(method) {
         return function() { return method.valueOf.call(method); };
       })(method);
</PRE><PRE>       value.toString = (function(method) {
         return function() { return method.toString.call(method); };
       })(method);
     }
     this.prototype[property] = value;
   }
</PRE><PRE>   return this;
 }
</PRE><PRE> return {
   create: create,
   Methods: {
     addMethods: addMethods
   }
 };
</PRE><P>})();
(function() {
</P><PRE> var _toString = Object.prototype.toString,
     _hasOwnProperty = Object.prototype.hasOwnProperty,
     NULL_TYPE = 'Null',
     UNDEFINED_TYPE = 'Undefined',
     BOOLEAN_TYPE = 'Boolean',
     NUMBER_TYPE = 'Number',
     STRING_TYPE = 'String',
     OBJECT_TYPE = 'Object',
     FUNCTION_CLASS = '[object Function]',
     BOOLEAN_CLASS = '[object Boolean]',
     NUMBER_CLASS = '[object Number]',
     STRING_CLASS = '[object String]',
     ARRAY_CLASS = '[object Array]',
     DATE_CLASS = '[object Date]',
     NATIVE_JSON_STRINGIFY_SUPPORT = window.JSON &amp;&amp;
       typeof JSON.stringify === 'function' &amp;&amp;
       JSON.stringify(0) === '0' &amp;&amp;
       typeof JSON.stringify(Prototype.K) === 'undefined';
</PRE><PRE> var DONT_ENUMS = ['toString', 'toLocaleString', 'valueOf',
  'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
</PRE><PRE> var IS_DONTENUM_BUGGY = (function(){
   for (var p in { toString: 1 }) {
     if (p === 'toString') return false;
   }
   return true;
 })();
</PRE><PRE> function Type(o) {
   switch(o) {
     case null: return NULL_TYPE;
     case (void 0): return UNDEFINED_TYPE;
   }
   var type = typeof o;
   switch(type) {
     case 'boolean': return BOOLEAN_TYPE;
     case 'number':  return NUMBER_TYPE;
     case 'string':  return STRING_TYPE;
   }
   return OBJECT_TYPE;
 }
</PRE><PRE> function extend(destination, source) {
   for (var property in source)
     destination[property] = source[property];
   return destination;
 }
</PRE><PRE> function inspect(object) {
   try {
     if (isUndefined(object)) return 'undefined';
     if (object === null) return 'null';
     return object.inspect ? object.inspect() : String(object);
   } catch (e) {
     if (e instanceof RangeError) return '...';
     throw e;
   }
 }
</PRE><PRE> function toJSON(value) {
   return Str(<I>, { </I>: value }, []);
 }
</PRE><PRE> function Str(key, holder, stack) {
   var value = holder[key];
   if (Type(value) === OBJECT_TYPE &amp;&amp; typeof value.toJSON === 'function') {
     value = value.toJSON(key);
   }
</PRE><PRE>   var _class = _toString.call(value);
</PRE><PRE>   switch (_class) {
     case NUMBER_CLASS:
     case BOOLEAN_CLASS:
     case STRING_CLASS:
       value = value.valueOf();
   }
</PRE><PRE>   switch (value) {
     case null: return 'null';
     case true: return 'true';
     case false: return 'false';
   }
</PRE><PRE>   var type = typeof value;
   switch (type) {
     case 'string':
       return value.inspect(true);
     case 'number':
       return isFinite(value) ? String(value) : 'null';
     case 'object':
</PRE><PRE>       for (var i = 0, length = stack.length; i &lt; length; i++) {
         if (stack[i] === value) {
           throw new TypeError(&quot;Cyclic reference to '&quot; + value + &quot;' in object&quot;);
         }
       }
       stack.push(value);
</PRE><PRE>       var partial = [];
       if (_class === ARRAY_CLASS) {
         for (var i = 0, length = value.length; i &lt; length; i++) {
           var str = Str(i, value, stack);
           partial.push(typeof str === 'undefined' ? 'null' : str);
         }
         partial = '[' + partial.join(',') + ']';
       } else {
         var keys = Object.keys(value);
         for (var i = 0, length = keys.length; i &lt; length; i++) {
           var key = keys[i], str = Str(key, value, stack);
           if (typeof str !== &quot;undefined&quot;) {
              partial.push(key.inspect(true)+ ':' + str);
            }
         }
         partial = '{' + partial.join(',') + '}';
       }
       stack.pop();
       return partial;
   }
 }
</PRE><PRE> function stringify(object) {
   return JSON.stringify(object);
 }
</PRE><PRE> function toQueryString(object) {
   return $H(object).toQueryString();
 }
</PRE><PRE> function toHTML(object) {
   return object &amp;&amp; object.toHTML ? object.toHTML() : String.interpret(object);
 }
</PRE><PRE> function keys(object) {
   if (Type(object) !== OBJECT_TYPE) { throw new TypeError(); }
   var results = [];
   for (var property in object) {
     if (_hasOwnProperty.call(object, property))
       results.push(property);
   }
</PRE><PRE>   if (IS_DONTENUM_BUGGY) {
     for (var i = 0; property = DONT_ENUMS[i]; i++) {
       if (_hasOwnProperty.call(object, property))
         results.push(property);
     }
   }
</PRE><PRE>   return results;
 }
</PRE><PRE> function values(object) {
   var results = [];
   for (var property in object)
     results.push(object[property]);
   return results;
 }
</PRE><PRE> function clone(object) {
   return extend({ }, object);
 }
</PRE><PRE> function isElement(object) {
   return !!(object &amp;&amp; object.nodeType == 1);
 }
</PRE><PRE> function isArray(object) {
   return _toString.call(object) === ARRAY_CLASS;
 }
</PRE><PRE> var hasNativeIsArray = (typeof Array.isArray == 'function')
   &amp;&amp; Array.isArray([]) &amp;&amp; !Array.isArray({});
</PRE><PRE> if (hasNativeIsArray) {
   isArray = Array.isArray;
 }
</PRE><PRE> function isHash(object) {
   return object instanceof Hash;
 }
</PRE><PRE> function isFunction(object) {
   return _toString.call(object) === FUNCTION_CLASS;
 }
</PRE><PRE> function isString(object) {
   return _toString.call(object) === STRING_CLASS;
 }
</PRE><PRE> function isNumber(object) {
   return _toString.call(object) === NUMBER_CLASS;
 }
</PRE><PRE> function isDate(object) {
   return _toString.call(object) === DATE_CLASS;
 }
</PRE><PRE> function isUndefined(object) {
   return typeof object === &quot;undefined&quot;;
 }
</PRE><PRE> extend(Object, {
   extend:        extend,
   inspect:       inspect,
   toJSON:        NATIVE_JSON_STRINGIFY_SUPPORT ? stringify : toJSON,
   toQueryString: toQueryString,
   toHTML:        toHTML,
   keys:          Object.keys || keys,
   values:        values,
   clone:         clone,
   isElement:     isElement,
   isArray:       isArray,
   isHash:        isHash,
   isFunction:    isFunction,
   isString:      isString,
   isNumber:      isNumber,
   isDate:        isDate,
   isUndefined:   isUndefined
 });
</PRE><P>})();
Object.extend(Function.prototype, (function() {
</P><PRE> var slice = Array.prototype.slice;
</PRE><PRE> function update(array, args) {
   var arrayLength = array.length, length = args.length;
   while (length--) array[arrayLength + length] = args[length];
   return array;
 }
</PRE><PRE> function merge(array, args) {
   array = slice.call(array, 0);
   return update(array, args);
 }
</PRE><PRE> function argumentNames() {
   var names = this.toString().match(/^[\s\(]*function[^(]*\(([^)]*)\)/)[1]
     .replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, <I>)</I>
     .replace(/\s+/g, <I>).split(',');</I>
   return names.length == 1 &amp;&amp; !names[0] ? [] : names;
 }
</PRE><PRE> function bind(context) {
   if (arguments.length &lt; 2 &amp;&amp; Object.isUndefined(arguments[0]))
     return this;
</PRE><PRE>   if (!Object.isFunction(this))
     throw new TypeError(&quot;The object is not callable.&quot;);
</PRE><PRE>   var nop = function() {};
   var __method = this, args = slice.call(arguments, 1);
</PRE><PRE>   var bound = function() {
     var a = merge(args, arguments);
     var c = this instanceof bound ? this : context;
     return __method.apply(c, a);
   };
</PRE><PRE>   nop.prototype   = this.prototype;
   bound.prototype = new nop();
</PRE><PRE>   return bound;
 }
</PRE><PRE> function bindAsEventListener(context) {
   var __method = this, args = slice.call(arguments, 1);
   return function(event) {
     var a = update([event || window.event], args);
     return __method.apply(context, a);
   }
 }
</PRE><PRE> function curry() {
   if (!arguments.length) return this;
   var __method = this, args = slice.call(arguments, 0);
   return function() {
     var a = merge(args, arguments);
     return __method.apply(this, a);
   }
 }
</PRE><PRE> function delay(timeout) {
   var __method = this, args = slice.call(arguments, 1);
   timeout = timeout * 1000;
   return window.setTimeout(function() {
     return __method.apply(__method, args);
   }, timeout);
 }
</PRE><PRE> function defer() {
   var args = update([0.01], arguments);
   return this.delay.apply(this, args);
 }
</PRE><PRE> function wrap(wrapper) {
   var __method = this;
   return function() {
     var a = update([__method.bind(this)], arguments);
     return wrapper.apply(this, a);
   }
 }
</PRE><PRE> function methodize() {
   if (this._methodized) return this._methodized;
   var __method = this;
   return this._methodized = function() {
     var a = update([this], arguments);
     return __method.apply(null, a);
   };
 }
</PRE><PRE> var extensions = {
   argumentNames:       argumentNames,
   bindAsEventListener: bindAsEventListener,
   curry:               curry,
   delay:               delay,
   defer:               defer,
   wrap:                wrap,
   methodize:           methodize
 };
</PRE><PRE> if (!Function.prototype.bind)
   extensions.bind = bind;
</PRE><PRE> return extensions;
</PRE><P>})());
</P><P>(function(proto) {
</P><PRE> function toISOString() {
   return this.getUTCFullYear() + '-' +
     (this.getUTCMonth() + 1).toPaddedString(2) + '-' +
     this.getUTCDate().toPaddedString(2) + 'T' +
     this.getUTCHours().toPaddedString(2) + ':' +
     this.getUTCMinutes().toPaddedString(2) + ':' +
     this.getUTCSeconds().toPaddedString(2) + 'Z';
 }
</PRE><PRE> function toJSON() {
   return this.toISOString();
 }
</PRE><PRE> if (!proto.toISOString) proto.toISOString = toISOString;
 if (!proto.toJSON) proto.toJSON = toJSON;
</PRE><P>})(Date.prototype);
</P><P>
RegExp.prototype.match = RegExp.prototype.test;
</P><P>RegExp.escape = function(str) {
</P><PRE> return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
</PRE><P>};
var PeriodicalExecuter = Class.create({
</P><PRE> initialize: function(callback, frequency) {
   this.callback = callback;
   this.frequency = frequency;
   this.currentlyExecuting = false;
</PRE><PRE>   this.registerCallback();
 },
</PRE><PRE> registerCallback: function() {
   this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
 },
</PRE><PRE> execute: function() {
   this.callback(this);
 },
</PRE><PRE> stop: function() {
   if (!this.timer) return;
   clearInterval(this.timer);
   this.timer = null;
 },
</PRE><PRE> onTimerEvent: function() {
   if (!this.currentlyExecuting) {
     try {
       this.currentlyExecuting = true;
       this.execute();
       this.currentlyExecuting = false;
     } catch(e) {
       this.currentlyExecuting = false;
       throw e;
     }
   }
 }
</PRE><P>});
Object.extend(String, {
</P><PRE> interpret: function(value) {
   return value == null ? <I> : String(value);</I>
 },
 specialChar: {
   '\b': '\\b',
   '\t': '\\t',
   '\n': '\\n',
   '\f': '\\f',
   '\r': '\\r',
   '\\': '\\\\'
 }
</PRE><P>});
</P><P>Object.extend(String.prototype, (function() {
</P><PRE> var NATIVE_JSON_PARSE_SUPPORT = window.JSON &amp;&amp;
   typeof JSON.parse === 'function' &amp;&amp;
   JSON.parse('{&quot;test&quot;: true}').test;
</PRE><PRE> function prepareReplacement(replacement) {
   if (Object.isFunction(replacement)) return replacement;
   var template = new Template(replacement);
   return function(match) { return template.evaluate(match) };
 }
</PRE><PRE> function isNonEmptyRegExp(regexp) {
   return regexp.source &amp;&amp; regexp.source !== '(?:)';
 }
</PRE><PRE> function gsub(pattern, replacement) {
   var result = <I>, source = this, match;</I>
   replacement = prepareReplacement(replacement);
</PRE><PRE>   if (Object.isString(pattern))
     pattern = RegExp.escape(pattern);
</PRE><PRE>   if (!(pattern.length || isNonEmptyRegExp(pattern))) {
     replacement = replacement(<I>);</I>
     return replacement + source.split(<I>).join(replacement) + replacement;</I>
   }
</PRE><PRE>   while (source.length &gt; 0) {
     match = source.match(pattern)
     if (match &amp;&amp; match[0].length &gt; 0) {
       result += source.slice(0, match.index);
       result += String.interpret(replacement(match));
       source  = source.slice(match.index + match[0].length);
     } else {
       result += source, source = <I>;</I>
     }
   }
   return result;
 }
</PRE><PRE> function sub(pattern, replacement, count) {
   replacement = prepareReplacement(replacement);
   count = Object.isUndefined(count) ? 1 : count;
</PRE><PRE>   return this.gsub(pattern, function(match) {
     if (--count &lt; 0) return match[0];
     return replacement(match);
   });
 }
</PRE><PRE> function scan(pattern, iterator) {
   this.gsub(pattern, iterator);
   return String(this);
 }
</PRE><PRE> function truncate(length, truncation) {
   length = length || 30;
   truncation = Object.isUndefined(truncation) ? '...' : truncation;
   return this.length &gt; length ?
     this.slice(0, length - truncation.length) + truncation : String(this);
 }
</PRE><PRE> function strip() {
   return this.replace(/^\s+/, <I>).replace(/\s+$/, </I>);
 }
</PRE><PRE> function stripTags() {
   return this.replace(/&lt;\w+(\s+(&quot;[^&quot;]*&quot;|'[^']*'|[^&gt;])+)?&gt;|&lt;\/\w+&gt;/gi, <I>);</I>
 }
</PRE><PRE> function stripScripts() {
   return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), <I>);</I>
 }
</PRE><PRE> function extractScripts() {
   var matchAll = new RegExp(Prototype.ScriptFragment, 'img'),
       matchOne = new RegExp(Prototype.ScriptFragment, 'im');
   return (this.match(matchAll) || []).map(function(scriptTag) {
     return (scriptTag.match(matchOne) || [<I>, </I>])[1];
   });
 }
</PRE><PRE> function evalScripts() {
   return this.extractScripts().map(function(script) { return eval(script); });
 }
</PRE><PRE> function escapeHTML() {
   return this.replace(/&amp;/g,'&amp;').replace(/&lt;/g,'&lt;').replace(/&gt;/g,'&gt;');
 }
</PRE><PRE> function unescapeHTML() {
   return this.stripTags().replace(/&lt;/g,'&lt;').replace(/&gt;/g,'&gt;').replace(/&amp;/g,'&amp;');
 }
</PRE><PRE> function toQueryParams(separator) {
   var match = this.strip().match(/([^?#]*)(#.*)?$/);
   if (!match) return { };
</PRE><PRE>   return match[1].split(separator || '&amp;').inject({ }, function(hash, pair) {
     if ((pair = pair.split('='))[0]) {
       var key = decodeURIComponent(pair.shift()),
           value = pair.length &gt; 1 ? pair.join('=') : pair[0];
</PRE><PRE>       if (value != undefined) {
         value = value.gsub('+', ' ');
         value = decodeURIComponent(value);
       }
</PRE><PRE>       if (key in hash) {
         if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
         hash[key].push(value);
       }
       else hash[key] = value;
     }
     return hash;
   });
 }
</PRE><PRE> function toArray() {
   return this.split(<I>);</I>
 }
</PRE><PRE> function succ() {
   return this.slice(0, this.length - 1) +
     String.fromCharCode(this.charCodeAt(this.length - 1) + 1);
 }
</PRE><PRE> function times(count) {
   return count &lt; 1 ? <I> : new Array(count + 1).join(this);</I>
 }
</PRE><PRE> function camelize() {
   return this.replace(/-+(.)?/g, function(match, chr) {
     return chr ? chr.toUpperCase() : <I>;</I>
   });
 }
</PRE><PRE> function capitalize() {
   return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
 }
</PRE><PRE> function underscore() {
   return this.replace(/::/g, '/')
              .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
              .replace(/([a-z\d])([A-Z])/g, '$1_$2')
              .replace(/-/g, '_')
              .toLowerCase();
 }
</PRE><PRE> function dasherize() {
   return this.replace(/_/g, '-');
 }
</PRE><PRE> function inspect(useDoubleQuotes) {
   var escapedString = this.replace(/[\x00-\x1f\\]/g, function(character) {
     if (character in String.specialChar) {
       return String.specialChar[character];
     }
     return '\\u00' + character.charCodeAt().toPaddedString(2, 16);
   });
   if (useDoubleQuotes) return '&quot;' + escapedString.replace(/&quot;/g, '\\&quot;') + '&quot;';
   return &quot;'&quot; + escapedString.replace(/'/g, '\\\<I>) + &quot;'&quot;;</I>
 }
</PRE><PRE> function unfilterJSON(filter) {
   return this.replace(filter || Prototype.JSONFilter, '$1');
 }
</PRE><PRE> function isJSON() {
   var str = this;
   if (str.blank()) return false;
   str = str.replace(/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@');
   str = str.replace(/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
   str = str.replace(/(?:^|:|,)(?:\s*\[)+/g, <I>);</I>
   return (/^[\],:{}\s]*$/).test(str);
 }
</PRE><PRE> function evalJSON(sanitize) {
   var json = this.unfilterJSON(),
       cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
   if (cx.test(json)) {
     json = json.replace(cx, function (a) {
       return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
     });
   }
   try {
     if (!sanitize || json.isJSON()) return eval('(' + json + ')');
   } catch (e) { }
   throw new SyntaxError('Badly formed JSON string: ' + this.inspect());
 }
</PRE><PRE> function parseJSON() {
   var json = this.unfilterJSON();
   return JSON.parse(json);
 }
</PRE><PRE> function include(pattern) {
   return this.indexOf(pattern) &gt; -1;
 }
</PRE><PRE> function startsWith(pattern, position) {
   position = Object.isNumber(position) ? position : 0;
   return this.lastIndexOf(pattern, position) === position;
 }
</PRE><PRE> function endsWith(pattern, position) {
   pattern = String(pattern);
   position = Object.isNumber(position) ? position : this.length;
   if (position &lt; 0) position = 0;
   if (position &gt; this.length) position = this.length;
   var d = position - pattern.length;
   return d &gt;= 0 &amp;&amp; this.indexOf(pattern, d) === d;
 }
</PRE><PRE> function empty() {
   return this == <I>;</I>
 }
</PRE><PRE> function blank() {
   return /^\s*$/.test(this);
 }
</PRE><PRE> function interpolate(object, pattern) {
   return new Template(this, pattern).evaluate(object);
 }
</PRE><PRE> return {
   gsub:           gsub,
   sub:            sub,
   scan:           scan,
   truncate:       truncate,
   strip:          String.prototype.trim || strip,
   stripTags:      stripTags,
   stripScripts:   stripScripts,
   extractScripts: extractScripts,
   evalScripts:    evalScripts,
   escapeHTML:     escapeHTML,
   unescapeHTML:   unescapeHTML,
   toQueryParams:  toQueryParams,
   parseQuery:     toQueryParams,
   toArray:        toArray,
   succ:           succ,
   times:          times,
   camelize:       camelize,
   capitalize:     capitalize,
   underscore:     underscore,
   dasherize:      dasherize,
   inspect:        inspect,
   unfilterJSON:   unfilterJSON,
   isJSON:         isJSON,
   evalJSON:       NATIVE_JSON_PARSE_SUPPORT ? parseJSON : evalJSON,
   include:        include,
   startsWith:     String.prototype.startsWith || startsWith,
   endsWith:       String.prototype.endsWith || endsWith,
   empty:          empty,
   blank:          blank,
   interpolate:    interpolate
 };
</PRE><P>})());
</P><P>var Template = Class.create({
</P><PRE> initialize: function(template, pattern) {
   this.template = template.toString();
   this.pattern = pattern || Template.Pattern;
 },
</PRE><PRE> evaluate: function(object) {
   if (object &amp;&amp; Object.isFunction(object.toTemplateReplacements))
     object = object.toTemplateReplacements();
</PRE><PRE>   return this.template.gsub(this.pattern, function(match) {
     if (object == null) return (match[1] + <I>);</I></PRE><PRE>     var before = match[1] || <I>;</I>
     if (before == '\\') return match[2];
</PRE><PRE>     var ctx = object, expr = match[3],
         pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
</PRE><PRE>     match = pattern.exec(expr);
     if (match == null) return before;
</PRE><PRE>     while (match != null) {
       var comp = match[1].startsWith('[') ? match[2].replace(/\\\\]/g, ']') : match[1];
       ctx = ctx[comp];
       if (null == ctx || <I> == match[3]) break;</I>
       expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
       match = pattern.exec(expr);
     }
</PRE><PRE>     return before + String.interpret(ctx);
   });
 }
</PRE><P>});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
</P><P>var $break = { };
</P><P>var Enumerable = (function() {
</P><PRE> function each(iterator, context) {
   try {
     this._each(iterator, context);
   } catch (e) {
     if (e != $break) throw e;
   }
   return this;
 }
</PRE><PRE> function eachSlice(number, iterator, context) {
   var index = -number, slices = [], array = this.toArray();
   if (number &lt; 1) return array;
   while ((index += number) &lt; array.length)
     slices.push(array.slice(index, index+number));
   return slices.collect(iterator, context);
 }
</PRE><PRE> function all(iterator, context) {
   iterator = iterator || Prototype.K;
   var result = true;
   this.each(function(value, index) {
     result = result &amp;&amp; !!iterator.call(context, value, index, this);
     if (!result) throw $break;
   }, this);
   return result;
 }
</PRE><PRE> function any(iterator, context) {
   iterator = iterator || Prototype.K;
   var result = false;
   this.each(function(value, index) {
     if (result = !!iterator.call(context, value, index, this))
       throw $break;
   }, this);
   return result;
 }
</PRE><PRE> function collect(iterator, context) {
   iterator = iterator || Prototype.K;
   var results = [];
   this.each(function(value, index) {
     results.push(iterator.call(context, value, index, this));
   }, this);
   return results;
 }
</PRE><PRE> function detect(iterator, context) {
   var result;
   this.each(function(value, index) {
     if (iterator.call(context, value, index, this)) {
       result = value;
       throw $break;
     }
   }, this);
   return result;
 }
</PRE><PRE> function findAll(iterator, context) {
   var results = [];
   this.each(function(value, index) {
     if (iterator.call(context, value, index, this))
       results.push(value);
   }, this);
   return results;
 }
</PRE><PRE> function grep(filter, iterator, context) {
   iterator = iterator || Prototype.K;
   var results = [];
</PRE><PRE>   if (Object.isString(filter))
     filter = new RegExp(RegExp.escape(filter));
</PRE><PRE>   this.each(function(value, index) {
     if (filter.match(value))
       results.push(iterator.call(context, value, index, this));
   }, this);
   return results;
 }
</PRE><PRE> function include(object) {
   if (Object.isFunction(this.indexOf) &amp;&amp; this.indexOf(object) != -1)
     return true;
</PRE><PRE>   var found = false;
   this.each(function(value) {
     if (value == object) {
       found = true;
       throw $break;
     }
   });
   return found;
 }
</PRE><PRE> function inGroupsOf(number, fillWith) {
   fillWith = Object.isUndefined(fillWith) ? null : fillWith;
   return this.eachSlice(number, function(slice) {
     while(slice.length &lt; number) slice.push(fillWith);
     return slice;
   });
 }
</PRE><PRE> function inject(memo, iterator, context) {
   this.each(function(value, index) {
     memo = iterator.call(context, memo, value, index, this);
   }, this);
   return memo;
 }
</PRE><PRE> function invoke(method) {
   var args = $A(arguments).slice(1);
   return this.map(function(value) {
     return value[method].apply(value, args);
   });
 }
</PRE><PRE> function max(iterator, context) {
   iterator = iterator || Prototype.K;
   var result;
   this.each(function(value, index) {
     value = iterator.call(context, value, index, this);
     if (result == null || value &gt;= result)
       result = value;
   }, this);
   return result;
 }
</PRE><PRE> function min(iterator, context) {
   iterator = iterator || Prototype.K;
   var result;
   this.each(function(value, index) {
     value = iterator.call(context, value, index, this);
     if (result == null || value &lt; result)
       result = value;
   }, this);
   return result;
 }
</PRE><PRE> function partition(iterator, context) {
   iterator = iterator || Prototype.K;
   var trues = [], falses = [];
   this.each(function(value, index) {
     (iterator.call(context, value, index, this) ?
       trues : falses).push(value);
   }, this);
   return [trues, falses];
 }
</PRE><PRE> function pluck(property) {
   var results = [];
   this.each(function(value) {
     results.push(value[property]);
   });
   return results;
 }
</PRE><PRE> function reject(iterator, context) {
   var results = [];
   this.each(function(value, index) {
     if (!iterator.call(context, value, index, this))
       results.push(value);
   }, this);
   return results;
 }
</PRE><PRE> function sortBy(iterator, context) {
   return this.map(function(value, index) {
     return {
       value: value,
       criteria: iterator.call(context, value, index, this)
     };
   }, this).sort(function(left, right) {
     var a = left.criteria, b = right.criteria;
     return a &lt; b ? -1 : a &gt; b ? 1 : 0;
   }).pluck('value');
 }
</PRE><PRE> function toArray() {
   return this.map();
 }
</PRE><PRE> function zip() {
   var iterator = Prototype.K, args = $A(arguments);
   if (Object.isFunction(args.last()))
     iterator = args.pop();
</PRE><PRE>   var collections = [this].concat(args).map($A);
   return this.map(function(value, index) {
     return iterator(collections.pluck(index));
   });
 }
</PRE><PRE> function size() {
   return this.toArray().length;
 }
</PRE><PRE> function inspect() {
   return '#&lt;Enumerable:' + this.toArray().inspect() + '&gt;';
 }
</PRE><PRE> return {
   each:       each,
   eachSlice:  eachSlice,
   all:        all,
   every:      all,
   any:        any,
   some:       any,
   collect:    collect,
   map:        collect,
   detect:     detect,
   findAll:    findAll,
   select:     findAll,
   filter:     findAll,
   grep:       grep,
   include:    include,
   member:     include,
   inGroupsOf: inGroupsOf,
   inject:     inject,
   invoke:     invoke,
   max:        max,
   min:        min,
   partition:  partition,
   pluck:      pluck,
   reject:     reject,
   sortBy:     sortBy,
   toArray:    toArray,
   entries:    toArray,
   zip:        zip,
   size:       size,
   inspect:    inspect,
   find:       detect
 };
</PRE><P>})();
</P><P>function $A(iterable) {
</P><PRE> if (!iterable) return [];
 if ('toArray' in Object(iterable)) return iterable.toArray();
 var length = iterable.length || 0, results = new Array(length);
 while (length--) results[length] = iterable[length];
 return results;
</PRE><P>}
</P><P>
function $w(string) {
</P><PRE> if (!Object.isString(string)) return [];
 string = string.strip();
 return string ? string.split(/\s+/) : [];
</PRE><P>}
</P><P>Array.from = $A;
</P><P>
(function() {
</P><PRE> var arrayProto = Array.prototype,
     slice = arrayProto.slice,
     _each = arrayProto.forEach; // use native browser JS 1.6 implementation if available
</PRE><PRE> function each(iterator, context) {
   for (var i = 0, length = this.length &gt;&gt;&gt; 0; i &lt; length; i++) {
     if (i in this) iterator.call(context, this[i], i, this);
   }
 }
 if (!_each) _each = each;
</PRE><PRE> function clear() {
   this.length = 0;
   return this;
 }
</PRE><PRE> function first() {
   return this[0];
 }
</PRE><PRE> function last() {
   return this[this.length - 1];
 }
</PRE><PRE> function compact() {
   return this.select(function(value) {
     return value != null;
   });
 }
</PRE><PRE> function flatten() {
   return this.inject([], function(array, value) {
     if (Object.isArray(value))
       return array.concat(value.flatten());
     array.push(value);
     return array;
   });
 }
</PRE><PRE> function without() {
   var values = slice.call(arguments, 0);
   return this.select(function(value) {
     return !values.include(value);
   });
 }
</PRE><PRE> function reverse(inline) {
   return (inline === false ? this.toArray() : this)._reverse();
 }
</PRE><PRE> function uniq(sorted) {
   return this.inject([], function(array, value, index) {
     if (0 == index || (sorted ? array.last() != value : !array.include(value)))
       array.push(value);
     return array;
   });
 }
</PRE><PRE> function intersect(array) {
   return this.uniq().findAll(function(item) {
     return array.indexOf(item) !== -1;
   });
 }
</PRE><PRE> function clone() {
   return slice.call(this, 0);
 }
</PRE><PRE> function size() {
   return this.length;
 }
</PRE><PRE> function inspect() {
   return '[' + this.map(Object.inspect).join(', ') + ']';
 }
</PRE><PRE> function indexOf(item, i) {
   if (this == null) throw new TypeError();
</PRE><PRE>   var array = Object(this), length = array.length &gt;&gt;&gt; 0;
   if (length === 0) return -1;
</PRE><PRE>   i = Number(i);
   if (isNaN(i)) {
     i = 0;
   } else if (i !== 0 &amp;&amp; isFinite(i)) {
     i = (i &gt; 0 ? 1 : -1) * Math.floor(Math.abs(i));
   }
</PRE><PRE>   if (i &gt; length) return -1;
</PRE><PRE>   var k = i &gt;= 0 ? i : Math.max(length - Math.abs(i), 0);
   for (; k &lt; length; k++)
     if (k in array &amp;&amp; array[k] === item) return k;
   return -1;
 }
</PRE><PRE> function lastIndexOf(item, i) {
   if (this == null) throw new TypeError();
</PRE><PRE>   var array = Object(this), length = array.length &gt;&gt;&gt; 0;
   if (length === 0) return -1;
</PRE><PRE>   if (!Object.isUndefined(i)) {
     i = Number(i);
     if (isNaN(i)) {
       i = 0;
     } else if (i !== 0 &amp;&amp; isFinite(i)) {
       i = (i &gt; 0 ? 1 : -1) * Math.floor(Math.abs(i));
     }
   } else {
     i = length;
   }
</PRE><PRE>   var k = i &gt;= 0 ? Math.min(i, length - 1) :
    length - Math.abs(i);
</PRE><PRE>   for (; k &gt;= 0; k--)
     if (k in array &amp;&amp; array[k] === item) return k;
   return -1;
 }
</PRE><PRE> function concat(_) {
   var array = [], items = slice.call(arguments, 0), item, n = 0;
   items.unshift(this);
   for (var i = 0, length = items.length; i &lt; length; i++) {
     item = items[i];
     if (Object.isArray(item) &amp;&amp; !('callee' in item)) {
       for (var j = 0, arrayLength = item.length; j &lt; arrayLength; j++) {
         if (j in item) array[n] = item[j];
         n++;
       }
     } else {
       array[n++] = item;
     }
   }
   array.length = n;
   return array;
 }
</PRE><PRE> function wrapNative(method) {
   return function() {
     if (arguments.length === 0) {
       return method.call(this, Prototype.K);
     } else if (arguments[0] === undefined) {
       var args = slice.call(arguments, 1);
       args.unshift(Prototype.K);
       return method.apply(this, args);
     } else {
       return method.apply(this, arguments);
     }
   };
 }
</PRE><PRE> function map(iterator) {
   if (this == null) throw new TypeError();
   iterator = iterator || Prototype.K;
</PRE><PRE>   var object = Object(this);
   var results = [], context = arguments[1], n = 0;
</PRE><PRE>   for (var i = 0, length = object.length &gt;&gt;&gt; 0; i &lt; length; i++) {
     if (i in object) {
       results[n] = iterator.call(context, object[i], i, object);
     }
     n++;
   }
   results.length = n;
   return results;
 }
</PRE><PRE> if (arrayProto.map) {
   map = wrapNative(Array.prototype.map);
 }
</PRE><PRE> function filter(iterator) {
   if (this == null || !Object.isFunction(iterator))
     throw new TypeError();
</PRE><PRE>   var object = Object(this);
   var results = [], context = arguments[1], value;
</PRE><PRE>   for (var i = 0, length = object.length &gt;&gt;&gt; 0; i &lt; length; i++) {
     if (i in object) {
       value = object[i];
       if (iterator.call(context, value, i, object)) {
         results.push(value);
       }
     }
   }
   return results;
 }
</PRE><PRE> if (arrayProto.filter) {
   filter = Array.prototype.filter;
 }
</PRE><PRE> function some(iterator) {
   if (this == null) throw new TypeError();
   iterator = iterator || Prototype.K;
   var context = arguments[1];
</PRE><PRE>   var object = Object(this);
   for (var i = 0, length = object.length &gt;&gt;&gt; 0; i &lt; length; i++) {
     if (i in object &amp;&amp; iterator.call(context, object[i], i, object)) {
       return true;
     }
   }
</PRE><PRE>   return false;
 }
</PRE><PRE> if (arrayProto.some) {
   var some = wrapNative(Array.prototype.some);
 }
</PRE><PRE> function every(iterator) {
   if (this == null) throw new TypeError();
   iterator = iterator || Prototype.K;
   var context = arguments[1];
</PRE><PRE>   var object = Object(this);
   for (var i = 0, length = object.length &gt;&gt;&gt; 0; i &lt; length; i++) {
     if (i in object &amp;&amp; !iterator.call(context, object[i], i, object)) {
       return false;
     }
   }
</PRE><PRE>   return true;
 }
</PRE><PRE> if (arrayProto.every) {
   var every = wrapNative(Array.prototype.every);
 }
</PRE><PRE> var _reduce = arrayProto.reduce;
 function inject(memo, iterator) {
   iterator = iterator || Prototype.K;
   var context = arguments[2];
   return _reduce.call(this, iterator.bind(context), memo);
 }
</PRE><PRE> if (!arrayProto.reduce) {
   var inject = Enumerable.inject;
 }
</PRE><PRE> Object.extend(arrayProto, Enumerable);
</PRE><PRE> if (!arrayProto._reverse)
   arrayProto._reverse = arrayProto.reverse;
</PRE><PRE> Object.extend(arrayProto, {
   _each:     _each,
</PRE><PRE>   map:       map,
   collect:   map,
   select:    filter,
   filter:    filter,
   findAll:   filter,
   some:      some,
   any:       some,
   every:     every,
   all:       every,
   inject:    inject,
</PRE><PRE>   clear:     clear,
   first:     first,
   last:      last,
   compact:   compact,
   flatten:   flatten,
   without:   without,
   reverse:   reverse,
   uniq:      uniq,
   intersect: intersect,
   clone:     clone,
   toArray:   clone,
   size:      size,
   inspect:   inspect
 });
</PRE><PRE> var CONCAT_ARGUMENTS_BUGGY = (function() {
   return [].concat(arguments)[0][0] !== 1;
 })(1,2);
</PRE><PRE> if (CONCAT_ARGUMENTS_BUGGY) arrayProto.concat = concat;
</PRE><PRE> if (!arrayProto.indexOf) arrayProto.indexOf = indexOf;
 if (!arrayProto.lastIndexOf) arrayProto.lastIndexOf = lastIndexOf;
</PRE><P>})();
function $H(object) {
</P><PRE> return new Hash(object);
</PRE><P>};
</P><P>var Hash = Class.create(Enumerable, (function() {
</P><PRE> function initialize(object) {
   this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);
 }
</PRE><PRE> function _each(iterator, context) {
   var i = 0;
   for (var key in this._object) {
     var value = this._object[key], pair = [key, value];
     pair.key = key;
     pair.value = value;
     iterator.call(context, pair, i);
     i++;
   }
 }
</PRE><PRE> function set(key, value) {
   return this._object[key] = value;
 }
</PRE><PRE> function get(key) {
   if (this._object[key] !== Object.prototype[key])
     return this._object[key];
 }
</PRE><PRE> function unset(key) {
   var value = this._object[key];
   delete this._object[key];
   return value;
 }
</PRE><PRE> function toObject() {
   return Object.clone(this._object);
 }
</PRE><PRE> function keys() {
   return this.pluck('key');
 }
</PRE><PRE> function values() {
   return this.pluck('value');
 }
</PRE><PRE> function index(value) {
   var match = this.detect(function(pair) {
     return pair.value === value;
   });
   return match &amp;&amp; match.key;
 }
</PRE><PRE> function merge(object) {
   return this.clone().update(object);
 }
</PRE><PRE> function update(object) {
   return new Hash(object).inject(this, function(result, pair) {
     result.set(pair.key, pair.value);
     return result;
   });
 }
</PRE><PRE> function toQueryPair(key, value) {
   if (Object.isUndefined(value)) return key;
</PRE><PRE>   value = String.interpret(value);
</PRE><PRE>   value = value.gsub(/(\r)?\n/, '\r\n');
   value = encodeURIComponent(value);
   value = value.gsub(/%20/, '+');
   return key + '=' + value;
 }
</PRE><PRE> function toQueryString() {
   return this.inject([], function(results, pair) {
     var key = encodeURIComponent(pair.key), values = pair.value;
</PRE><PRE>     if (values &amp;&amp; typeof values == 'object') {
       if (Object.isArray(values)) {
         var queryValues = [];
         for (var i = 0, len = values.length, value; i &lt; len; i++) {
           value = values[i];
           queryValues.push(toQueryPair(key, value));
         }
         return results.concat(queryValues);
       }
     } else results.push(toQueryPair(key, values));
     return results;
   }).join('&amp;');
 }
</PRE><PRE> function inspect() {
   return '#&lt;Hash:{' + this.map(function(pair) {
     return pair.map(Object.inspect).join(': ');
   }).join(', ') + '}&gt;';
 }
</PRE><PRE> function clone() {
   return new Hash(this);
 }
</PRE><PRE> return {
   initialize:             initialize,
   _each:                  _each,
   set:                    set,
   get:                    get,
   unset:                  unset,
   toObject:               toObject,
   toTemplateReplacements: toObject,
   keys:                   keys,
   values:                 values,
   index:                  index,
   merge:                  merge,
   update:                 update,
   toQueryString:          toQueryString,
   inspect:                inspect,
   toJSON:                 toObject,
   clone:                  clone
 };
</PRE><P>})());
</P><P>Hash.from = $H;
Object.extend(Number.prototype, (function() {
</P><PRE> function toColorPart() {
   return this.toPaddedString(2, 16);
 }
</PRE><PRE> function succ() {
   return this + 1;
 }
</PRE><PRE> function times(iterator, context) {
   $R(0, this, true).each(iterator, context);
   return this;
 }
</PRE><PRE> function toPaddedString(length, radix) {
   var string = this.toString(radix || 10);
   return '0'.times(length - string.length) + string;
 }
</PRE><PRE> function abs() {
   return Math.abs(this);
 }
</PRE><PRE> function round() {
   return Math.round(this);
 }
</PRE><PRE> function ceil() {
   return Math.ceil(this);
 }
</PRE><PRE> function floor() {
   return Math.floor(this);
 }
</PRE><PRE> return {
   toColorPart:    toColorPart,
   succ:           succ,
   times:          times,
   toPaddedString: toPaddedString,
   abs:            abs,
   round:          round,
   ceil:           ceil,
   floor:          floor
 };
</PRE><P>})());
</P><P>function $R(start, end, exclusive) {
</P><PRE> return new ObjectRange(start, end, exclusive);
</PRE><P>}
</P><P>var ObjectRange = Class.create(Enumerable, (function() {
</P><PRE> function initialize(start, end, exclusive) {
   this.start = start;
   this.end = end;
   this.exclusive = exclusive;
 }
</PRE><PRE> function _each(iterator, context) {
   var value = this.start, i;
   for (i = 0; this.include(value); i++) {
     iterator.call(context, value, i);
     value = value.succ();
   }
 }
</PRE><PRE> function include(value) {
   if (value &lt; this.start)
     return false;
   if (this.exclusive)
     return value &lt; this.end;
   return value &lt;= this.end;
 }
</PRE><PRE> return {
   initialize: initialize,
   _each:      _each,
   include:    include
 };
</PRE><P>})());
</P><P>var Abstract = { };
</P><P>
var Try = {
</P><PRE> these: function() {
   var returnValue;
</PRE><PRE>   for (var i = 0, length = arguments.length; i &lt; length; i++) {
     var lambda = arguments[i];
     try {
       returnValue = lambda();
       break;
     } catch (e) { }
   }
</PRE><PRE>   return returnValue;
 }
</PRE><P>};
</P><P>var Ajax = {
</P><PRE> getTransport: function() {
   return Try.these(
     function() {return new XMLHttpRequest()},
     function() {return new ActiveXObject('Msxml2.XMLHTTP')},
     function() {return new ActiveXObject('Microsoft.XMLHTTP')}
   ) || false;
 },
</PRE><PRE> activeRequestCount: 0
</PRE><P>};
</P><P>Ajax.Responders = {
</P><PRE> responders: [],
</PRE><PRE> _each: function(iterator, context) {
   this.responders._each(iterator, context);
 },
</PRE><PRE> register: function(responder) {
   if (!this.include(responder))
     this.responders.push(responder);
 },
</PRE><PRE> unregister: function(responder) {
   this.responders = this.responders.without(responder);
 },
</PRE><PRE> dispatch: function(callback, request, transport, json) {
   this.each(function(responder) {
     if (Object.isFunction(responder[callback])) {
       try {
         responder[callback].apply(responder, [request, transport, json]);
       } catch (e) { }
     }
   });
 }
</PRE><P>};
</P><P>Object.extend(Ajax.Responders, Enumerable);
</P><P>Ajax.Responders.register({
</P><PRE> onCreate:   function() { Ajax.activeRequestCount++ },
 onComplete: function() { Ajax.activeRequestCount-- }
</PRE><P>});
Ajax.Base = Class.create({
</P><PRE> initialize: function(options) {
   this.options = {
     method:       'post',
     asynchronous: true,
     contentType:  'application/x-www-form-urlencoded',
     encoding:     'UTF-8',
     parameters:   <I>,</I>
     evalJSON:     true,
     evalJS:       true
   };
   Object.extend(this.options, options || { });
</PRE><PRE>   this.options.method = this.options.method.toLowerCase();
</PRE><PRE>   if (Object.isHash(this.options.parameters))
     this.options.parameters = this.options.parameters.toObject();
 }
</PRE><P>});
Ajax.Request = Class.create(Ajax.Base, {
</P><PRE> _complete: false,
</PRE><PRE> initialize: function($super, url, options) {
   $super(options);
   this.transport = Ajax.getTransport();
   this.request(url);
 },
</PRE><PRE> request: function(url) {
   this.url = url;
   this.method = this.options.method;
   var params = Object.isString(this.options.parameters) ?
         this.options.parameters :
         Object.toQueryString(this.options.parameters);
</PRE><PRE>   if (!['get', 'post'].include(this.method)) {
     params += (params ? '&amp;' : <I>) + &quot;_method=&quot; + this.method;</I>
     this.method = 'post';
   }
</PRE><PRE>   if (params &amp;&amp; this.method === 'get') {
     this.url += (this.url.include('?') ? '&amp;' : '?') + params;
   }
</PRE><PRE>   this.parameters = params.toQueryParams();
</PRE><PRE>   try {
     var response = new Ajax.Response(this);
     if (this.options.onCreate) this.options.onCreate(response);
     Ajax.Responders.dispatch('onCreate', this, response);
</PRE><PRE>     this.transport.open(this.method.toUpperCase(), this.url,
       this.options.asynchronous);
</PRE><PRE>     if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);
</PRE><PRE>     this.transport.onreadystatechange = this.onStateChange.bind(this);
     this.setRequestHeaders();
</PRE><PRE>     this.body = this.method == 'post' ? (this.options.postBody || params) : null;
     this.transport.send(this.body);
</PRE><PRE>     /* Force Firefox to handle ready state 4 for synchronous requests */
     if (!this.options.asynchronous &amp;&amp; this.transport.overrideMimeType)
       this.onStateChange();
</PRE><PRE>   }
   catch (e) {
     this.dispatchException(e);
   }
 },
</PRE><PRE> onStateChange: function() {
   var readyState = this.transport.readyState;
   if (readyState &gt; 1 &amp;&amp; !((readyState == 4) &amp;&amp; this._complete))
     this.respondToReadyState(this.transport.readyState);
 },
</PRE><PRE> setRequestHeaders: function() {
   var headers = {
     'X-Requested-With': 'XMLHttpRequest',
     'X-Prototype-Version': Prototype.Version,
     'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
   };
</PRE><PRE>   if (this.method == 'post') {
     headers['Content-type'] = this.options.contentType +
       (this.options.encoding ? '; charset=' + this.options.encoding : <I>);</I></PRE><PRE>     /* Force &quot;Connection: close&quot; for older Mozilla browsers to work
      * around a bug where XMLHttpRequest sends an incorrect
      * Content-length header. See Mozilla Bugzilla #246651.
      */
     if (this.transport.overrideMimeType &amp;&amp;
         (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] &lt; 2005)
           headers['Connection'] = 'close';
   }
</PRE><PRE>   if (typeof this.options.requestHeaders == 'object') {
     var extras = this.options.requestHeaders;
</PRE><PRE>     if (Object.isFunction(extras.push))
       for (var i = 0, length = extras.length; i &lt; length; i += 2)
         headers[extras[i]] = extras[i+1];
     else
       $H(extras).each(function(pair) { headers[pair.key] = pair.value });
   }
</PRE><PRE>   for (var name in headers)
     if (headers[name] != null)
       this.transport.setRequestHeader(name, headers[name]);
 },
</PRE><PRE> success: function() {
   var status = this.getStatus();
   return !status || (status &gt;= 200 &amp;&amp; status &lt; 300) || status == 304;
 },
</PRE><PRE> getStatus: function() {
   try {
     if (this.transport.status === 1223) return 204;
     return this.transport.status || 0;
   } catch (e) { return 0 }
 },
</PRE><PRE> respondToReadyState: function(readyState) {
   var state = Ajax.Request.Events[readyState], response = new Ajax.Response(this);
</PRE><PRE>   if (state == 'Complete') {
     try {
       this._complete = true;
       (this.options['on' + response.status]
        || this.options['on' + (this.success() ? 'Success' : 'Failure')]
        || Prototype.emptyFunction)(response, response.headerJSON);
     } catch (e) {
       this.dispatchException(e);
     }
</PRE><PRE>     var contentType = response.getHeader('Content-type');
     if (this.options.evalJS == 'force'
         || (this.options.evalJS &amp;&amp; this.isSameOrigin() &amp;&amp; contentType
         &amp;&amp; contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
       this.evalResponse();
   }
</PRE><PRE>   try {
     (this.options['on' + state] || Prototype.emptyFunction)(response, response.headerJSON);
     Ajax.Responders.dispatch('on' + state, this, response, response.headerJSON);
   } catch (e) {
     this.dispatchException(e);
   }
</PRE><PRE>   if (state == 'Complete') {
     this.transport.onreadystatechange = Prototype.emptyFunction;
   }
 },
</PRE><PRE> isSameOrigin: function() {
   var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
   return !m || (m[0] == '#{protocol}//#{domain}#{port}'.interpolate({
     protocol: location.protocol,
     domain: document.domain,
     port: location.port ? ':' + location.port : 
   }));
 },
</PRE><PRE> getHeader: function(name) {
   try {
     return this.transport.getResponseHeader(name) || null;
   } catch (e) { return null; }
 },
</PRE><PRE> evalResponse: function() {
   try {
     return eval((this.transport.responseText || <I>).unfilterJSON());</I>
   } catch (e) {
     this.dispatchException(e);
   }
 },
</PRE><PRE> dispatchException: function(exception) {
   (this.options.onException || Prototype.emptyFunction)(this, exception);
   Ajax.Responders.dispatch('onException', this, exception);
 }
</PRE><P>});
</P><P>Ajax.Request.Events =
</P><PRE> ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];
</PRE><P>
Ajax.Response = Class.create({
</P><PRE> initialize: function(request){
   this.request = request;
   var transport  = this.transport  = request.transport,
       readyState = this.readyState = transport.readyState;
</PRE><PRE>   if ((readyState &gt; 2 &amp;&amp; !Prototype.Browser.IE) || readyState == 4) {
     this.status       = this.getStatus();
     this.statusText   = this.getStatusText();
     this.responseText = String.interpret(transport.responseText);
     this.headerJSON   = this._getHeaderJSON();
   }
</PRE><PRE>   if (readyState == 4) {
     var xml = transport.responseXML;
     this.responseXML  = Object.isUndefined(xml) ? null : xml;
     this.responseJSON = this._getResponseJSON();
   }
 },
</PRE><PRE> status:      0,
</PRE><PRE> statusText: <I>,</I></PRE><PRE> getStatus: Ajax.Request.prototype.getStatus,
</PRE><PRE> getStatusText: function() {
   try {
     return this.transport.statusText || <I>;</I>
   } catch (e) { return <I> }</I>
 },
</PRE><PRE> getHeader: Ajax.Request.prototype.getHeader,
</PRE><PRE> getAllHeaders: function() {
   try {
     return this.getAllResponseHeaders();
   } catch (e) { return null }
 },
</PRE><PRE> getResponseHeader: function(name) {
   return this.transport.getResponseHeader(name);
 },
</PRE><PRE> getAllResponseHeaders: function() {
   return this.transport.getAllResponseHeaders();
 },
</PRE><PRE> _getHeaderJSON: function() {
   var json = this.getHeader('X-JSON');
   if (!json) return null;
</PRE><PRE>   try {
     json = decodeURIComponent(escape(json));
   } catch(e) {
   }
</PRE><PRE>   try {
     return json.evalJSON(this.request.options.sanitizeJSON ||
       !this.request.isSameOrigin());
   } catch (e) {
     this.request.dispatchException(e);
   }
 },
</PRE><PRE> _getResponseJSON: function() {
   var options = this.request.options;
   if (!options.evalJSON || (options.evalJSON != 'force' &amp;&amp; !(this.getHeader('Content-type') || <I>).include('application/json')) ||</I>
       this.responseText.blank())
         return null;
   try {
     return this.responseText.evalJSON(options.sanitizeJSON ||
       !this.request.isSameOrigin());
   } catch (e) {
     this.request.dispatchException(e);
   }
 }
</PRE><P>});
</P><P>Ajax.Updater = Class.create(Ajax.Request, {
</P><PRE> initialize: function($super, container, url, options) {
   this.container = {
     success: (container.success || container),
     failure: (container.failure || (container.success ? null : container))
   };
</PRE><PRE>   options = Object.clone(options);
   var onComplete = options.onComplete;
   options.onComplete = (function(response, json) {
     this.updateContent(response.responseText);
     if (Object.isFunction(onComplete)) onComplete(response, json);
   }).bind(this);
</PRE><PRE>   $super(url, options);
 },
</PRE><PRE> updateContent: function(responseText) {
   var receiver = this.container[this.success() ? 'success' : 'failure'],
       options = this.options;
</PRE><PRE>   if (!options.evalScripts) responseText = responseText.stripScripts();
</PRE><PRE>   if (receiver = $(receiver)) {
     if (options.insertion) {
       if (Object.isString(options.insertion)) {
         var insertion = { }; insertion[options.insertion] = responseText;
         receiver.insert(insertion);
       }
       else options.insertion(receiver, responseText);
     }
     else receiver.update(responseText);
   }
 }
</PRE><P>});
</P><P>Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
</P><PRE> initialize: function($super, container, url, options) {
   $super(options);
   this.onComplete = this.options.onComplete;
</PRE><PRE>   this.frequency = (this.options.frequency || 2);
   this.decay = (this.options.decay || 1);
</PRE><PRE>   this.updater = { };
   this.container = container;
   this.url = url;
</PRE><PRE>   this.start();
 },
</PRE><PRE> start: function() {
   this.options.onComplete = this.updateComplete.bind(this);
   this.onTimerEvent();
 },
</PRE><PRE> stop: function() {
   this.updater.options.onComplete = undefined;
   clearTimeout(this.timer);
   (this.onComplete || Prototype.emptyFunction).apply(this, arguments);
 },
</PRE><PRE> updateComplete: function(response) {
   if (this.options.decay) {
     this.decay = (response.responseText == this.lastText ?
       this.decay * this.options.decay : 1);
</PRE><PRE>     this.lastText = response.responseText;
   }
   this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);
 },
</PRE><PRE> onTimerEvent: function() {
   this.updater = new Ajax.Updater(this.container, this.url, this.options);
 }
</PRE><P>});
</P><P>(function(GLOBAL) {
</P><PRE> var UNDEFINED;
 var SLICE = Array.prototype.slice;
</PRE><PRE> var DIV = document.createElement('div');
</PRE><PRE> function $(element) {
   if (arguments.length &gt; 1) {
     for (var i = 0, elements = [], length = arguments.length; i &lt; length; i++)
       elements.push($(arguments[i]));
     return elements;
   }
</PRE><PRE>   if (Object.isString(element))
     element = document.getElementById(element);
   return Element.extend(element);
 }
</PRE><PRE> GLOBAL.$ = $;
</PRE><PRE> if (!GLOBAL.Node) GLOBAL.Node = {};
</PRE><PRE> if (!GLOBAL.Node.ELEMENT_NODE) {
   Object.extend(GLOBAL.Node, {
     ELEMENT_NODE:                1,
     ATTRIBUTE_NODE:              2,
     TEXT_NODE:                   3,
     CDATA_SECTION_NODE:          4,
     ENTITY_REFERENCE_NODE:       5,
     ENTITY_NODE:                 6,
     PROCESSING_INSTRUCTION_NODE: 7,
     COMMENT_NODE:                8,
     DOCUMENT_NODE:               9,
     DOCUMENT_TYPE_NODE:         10,
     DOCUMENT_FRAGMENT_NODE:     11,
     NOTATION_NODE:              12
   });
 }
</PRE><PRE> var ELEMENT_CACHE = {};
</PRE><PRE> function shouldUseCreationCache(tagName, attributes) {
   if (tagName === 'select') return false;
   if ('type' in attributes) return false;
   return true;
 }
</PRE><PRE> var HAS_EXTENDED_CREATE_ELEMENT_SYNTAX = (function(){
   try {
     var el = document.createElement('&lt;input name=&quot;x&quot;&gt;');
     return el.tagName.toLowerCase() === 'input' &amp;&amp; el.name === 'x';
   }
   catch(err) {
     return false;
   }
 })();
</PRE><PRE> var oldElement = GLOBAL.Element;
 function Element(tagName, attributes) {
   attributes = attributes || {};
   tagName = tagName.toLowerCase();
</PRE><PRE>   if (HAS_EXTENDED_CREATE_ELEMENT_SYNTAX &amp;&amp; attributes.name) {
     tagName = '&lt;' + tagName + ' name=&quot;' + attributes.name + '&quot;&gt;';
     delete attributes.name;
     return Element.writeAttribute(document.createElement(tagName), attributes);
   }
</PRE><PRE>   if (!ELEMENT_CACHE[tagName])
     ELEMENT_CACHE[tagName] = Element.extend(document.createElement(tagName));
</PRE><PRE>   var node = shouldUseCreationCache(tagName, attributes) ?
    ELEMENT_CACHE[tagName].cloneNode(false) : document.createElement(tagName);
</PRE><PRE>   return Element.writeAttribute(node, attributes);
 }
</PRE><PRE> GLOBAL.Element = Element;
</PRE><PRE> Object.extend(GLOBAL.Element, oldElement || {});
 if (oldElement) GLOBAL.Element.prototype = oldElement.prototype;
</PRE><PRE> Element.Methods = { ByTag: {}, Simulated: {} };
</PRE><PRE> var methods = {};
</PRE><PRE> var INSPECT_ATTRIBUTES = { id: 'id', className: 'class' };
 function inspect(element) {
   element = $(element);
   var result = '&lt;' + element.tagName.toLowerCase();
</PRE><PRE>   var attribute, value;
   for (var property in INSPECT_ATTRIBUTES) {
     attribute = INSPECT_ATTRIBUTES[property];
     value = (element[property] || <I>).toString();</I>
     if (value) result += ' ' + attribute + '=' + value.inspect(true);
   }
</PRE><PRE>   return result + '&gt;';
 }
</PRE><PRE> methods.inspect = inspect;
</PRE><PRE> function visible(element) {
   return $(element).style.display !== 'none';
 }
</PRE><PRE> function toggle(element, bool) {
   element = $(element);
   if (Object.isUndefined(bool))
     bool = !Element.visible(element);
   Element[bool ? 'show' : 'hide'](element);
</PRE><PRE>   return element;
 }
</PRE><PRE> function hide(element) {
   element = $(element);
   element.style.display = 'none';
   return element;
 }
</PRE><PRE> function show(element) {
   element = $(element);
   element.style.display = <I>;</I>
   return element;
 }
</PRE><PRE> Object.extend(methods, {
   visible: visible,
   toggle:  toggle,
   hide:    hide,
   show:    show
 });
</PRE><PRE> function remove(element) {
   element = $(element);
   element.parentNode.removeChild(element);
   return element;
 }
</PRE><PRE> var SELECT_ELEMENT_INNERHTML_BUGGY = (function(){
   var el = document.createElement(&quot;select&quot;),
       isBuggy = true;
   el.innerHTML = &quot;&lt;option value=\&quot;test\&quot;&gt;test&lt;/option&gt;&quot;;
   if (el.options &amp;&amp; el.options[0]) {
     isBuggy = el.options[0].nodeName.toUpperCase() !== &quot;OPTION&quot;;
   }
   el = null;
   return isBuggy;
 })();
</PRE><PRE> var TABLE_ELEMENT_INNERHTML_BUGGY = (function(){
   try {
     var el = document.createElement(&quot;table&quot;);
     if (el &amp;&amp; el.tBodies) {
       el.innerHTML = &quot;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;test&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&quot;;
       var isBuggy = typeof el.tBodies[0] == &quot;undefined&quot;;
       el = null;
       return isBuggy;
     }
   } catch (e) {
     return true;
   }
 })();
</PRE><PRE> var LINK_ELEMENT_INNERHTML_BUGGY = (function() {
   try {
     var el = document.createElement('div');
     el.innerHTML = &quot;&lt;link /&gt;&quot;;
     var isBuggy = (el.childNodes.length === 0);
     el = null;
     return isBuggy;
   } catch(e) {
     return true;
   }
 })();
</PRE><PRE> var ANY_INNERHTML_BUGGY = SELECT_ELEMENT_INNERHTML_BUGGY ||
  TABLE_ELEMENT_INNERHTML_BUGGY || LINK_ELEMENT_INNERHTML_BUGGY;
</PRE><PRE> var SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING = (function () {
   var s = document.createElement(&quot;script&quot;),
       isBuggy = false;
   try {
     s.appendChild(document.createTextNode(&quot;&quot;));
     isBuggy = !s.firstChild ||
       s.firstChild &amp;&amp; s.firstChild.nodeType !== 3;
   } catch (e) {
     isBuggy = true;
   }
   s = null;
   return isBuggy;
 })();
</PRE><PRE> function update(element, content) {
   element = $(element);
</PRE><PRE>   var descendants = element.getElementsByTagName('*'),
    i = descendants.length;
   while (i--) purgeElement(descendants[i]);
</PRE><PRE>   if (content &amp;&amp; content.toElement)
     content = content.toElement();
</PRE><PRE>   if (Object.isElement(content))
     return element.update().insert(content);
</PRE><PRE>   content = Object.toHTML(content);
   var tagName = element.tagName.toUpperCase();
</PRE><PRE>   if (tagName === 'SCRIPT' &amp;&amp; SCRIPT_ELEMENT_REJECTS_TEXTNODE_APPENDING) {
     element.text = content;
     return element;
   }
</PRE><PRE>   if (ANY_INNERHTML_BUGGY) {
     if (tagName in INSERTION_TRANSLATIONS.tags) {
       while (element.firstChild)
         element.removeChild(element.firstChild);
</PRE><PRE>       var nodes = getContentFromAnonymousElement(tagName, content.stripScripts());
       for (var i = 0, node; node = nodes[i]; i++)
         element.appendChild(node);
</PRE><PRE>     } else if (LINK_ELEMENT_INNERHTML_BUGGY &amp;&amp; Object.isString(content) &amp;&amp; content.indexOf('&lt;link') &gt; -1) {
       while (element.firstChild)
         element.removeChild(element.firstChild);
</PRE><PRE>       var nodes = getContentFromAnonymousElement(tagName,
        content.stripScripts(), true);
</PRE><PRE>       for (var i = 0, node; node = nodes[i]; i++)
         element.appendChild(node);
     } else {
       element.innerHTML = content.stripScripts();
     }
   } else {
     element.innerHTML = content.stripScripts();
   }
</PRE><PRE>   content.evalScripts.bind(content).defer();
   return element;
 }
</PRE><PRE> function replace(element, content) {
   element = $(element);
</PRE><PRE>   if (content &amp;&amp; content.toElement) {
     content = content.toElement();
   } else if (!Object.isElement(content)) {
     content = Object.toHTML(content);
     var range = element.ownerDocument.createRange();
     range.selectNode(element);
     content.evalScripts.bind(content).defer();
     content = range.createContextualFragment(content.stripScripts());
   }
</PRE><PRE>   element.parentNode.replaceChild(content, element);
   return element;
 }
</PRE><PRE> var INSERTION_TRANSLATIONS = {
   before: function(element, node) {
     element.parentNode.insertBefore(node, element);
   },
   top: function(element, node) {
     element.insertBefore(node, element.firstChild);
   },
   bottom: function(element, node) {
     element.appendChild(node);
   },
   after: function(element, node) {
     element.parentNode.insertBefore(node, element.nextSibling);
   },
</PRE><PRE>   tags: {
</PRE>
      TABLE:  ['<TABLE>',                '</TABLE>',                   1],
      TBODY:  ['<TABLE>&lt;tbody&gt;',         '&lt;/tbody&gt;</TABLE>',           2],
      TR:     ['<TABLE>&lt;tbody&gt;<TBODY><TR>',     '</TR>&lt;/tbody&gt;</TBODY></TABLE>',      3],
      TD:     ['<TABLE>&lt;tbody&gt;<TBODY><TR><TD>', '</TD></TR>&lt;/tbody&gt;</TBODY></TABLE>', 4],
<PRE>     SELECT: ['&lt;select&gt;',               '&lt;/select&gt;',                  1]
   }
 };
</PRE><PRE> var tags = INSERTION_TRANSLATIONS.tags;
</PRE><PRE> Object.extend(tags, {
   THEAD: tags.TBODY,
   TFOOT: tags.TBODY,
   TH:    tags.TD
 });
</PRE><PRE> function replace_IE(element, content) {
   element = $(element);
   if (content &amp;&amp; content.toElement)
     content = content.toElement();
   if (Object.isElement(content)) {
     element.parentNode.replaceChild(content, element);
     return element;
   }
</PRE><PRE>   content = Object.toHTML(content);
   var parent = element.parentNode, tagName = parent.tagName.toUpperCase();
</PRE><PRE>   if (tagName in INSERTION_TRANSLATIONS.tags) {
     var nextSibling = Element.next(element);
     var fragments = getContentFromAnonymousElement(
      tagName, content.stripScripts());
</PRE><PRE>     parent.removeChild(element);
</PRE><PRE>     var iterator;
     if (nextSibling)
       iterator = function(node) { parent.insertBefore(node, nextSibling) };
     else
       iterator = function(node) { parent.appendChild(node); }
</PRE><PRE>     fragments.each(iterator);
   } else {
     element.outerHTML = content.stripScripts();
   }
</PRE><PRE>   content.evalScripts.bind(content).defer();
   return element;
 }
</PRE><PRE> if ('outerHTML' in document.documentElement)
   replace = replace_IE;
</PRE><PRE> function isContent(content) {
   if (Object.isUndefined(content) || content === null) return false;
</PRE><PRE>   if (Object.isString(content) || Object.isNumber(content)) return true;
   if (Object.isElement(content)) return true;
   if (content.toElement || content.toHTML) return true;
</PRE><PRE>   return false;
 }
</PRE><PRE> function insertContentAt(element, content, position) {
   position   = position.toLowerCase();
   var method = INSERTION_TRANSLATIONS[position];
</PRE><PRE>   if (content &amp;&amp; content.toElement) content = content.toElement();
   if (Object.isElement(content)) {
     method(element, content);
     return element;
   }
</PRE><PRE>   content = Object.toHTML(content);
   var tagName = ((position === 'before' || position === 'after') ?
    element.parentNode : element).tagName.toUpperCase();
</PRE><PRE>   var childNodes = getContentFromAnonymousElement(tagName, content.stripScripts());
</PRE><PRE>   if (position === 'top' || position === 'after') childNodes.reverse();
</PRE><PRE>   for (var i = 0, node; node = childNodes[i]; i++)
     method(element, node);
</PRE><PRE>   content.evalScripts.bind(content).defer();
 }
</PRE><PRE> function insert(element, insertions) {
   element = $(element);
</PRE><PRE>   if (isContent(insertions))
     insertions = { bottom: insertions };
</PRE><PRE>   for (var position in insertions)
     insertContentAt(element, insertions[position], position);
</PRE><PRE>   return element;
 }
</PRE><PRE> function wrap(element, wrapper, attributes) {
   element = $(element);
</PRE><PRE>   if (Object.isElement(wrapper)) {
     $(wrapper).writeAttribute(attributes || {});
   } else if (Object.isString(wrapper)) {
     wrapper = new Element(wrapper, attributes);
   } else {
     wrapper = new Element('div', wrapper);
   }
</PRE><PRE>   if (element.parentNode)
     element.parentNode.replaceChild(wrapper, element);
</PRE><PRE>   wrapper.appendChild(element);
</PRE><PRE>   return wrapper;
 }
</PRE><PRE> function cleanWhitespace(element) {
   element = $(element);
   var node = element.firstChild;
</PRE><PRE>   while (node) {
     var nextNode = node.nextSibling;
     if (node.nodeType === Node.TEXT_NODE &amp;&amp; !/\S/.test(node.nodeValue))
       element.removeChild(node);
     node = nextNode;
   }
   return element;
 }
</PRE><PRE> function empty(element) {
   return $(element).innerHTML.blank();
 }
</PRE><PRE> function getContentFromAnonymousElement(tagName, html, force) {
   var t = INSERTION_TRANSLATIONS.tags[tagName], div = DIV;
</PRE><PRE>   var workaround = !!t;
   if (!workaround &amp;&amp; force) {
     workaround = true;
     t = [<I>, </I>, 0];
   }
</PRE><PRE>   if (workaround) {
     div.innerHTML = ' ' + t[0] + html + t[1];
     div.removeChild(div.firstChild);
     for (var i = t[2]; i--; )
       div = div.firstChild;
   } else {
     div.innerHTML = html;
   }
</PRE><PRE>   return $A(div.childNodes);
 }
</PRE><PRE> function clone(element, deep) {
   if (!(element = $(element))) return;
   var clone = element.cloneNode(deep);
   if (!HAS_UNIQUE_ID_PROPERTY) {
     clone._prototypeUID = UNDEFINED;
     if (deep) {
       var descendants = Element.select(clone, '*'),
        i = descendants.length;
       while (i--)
         descendants[i]._prototypeUID = UNDEFINED;
     }
   }
   return Element.extend(clone);
 }
</PRE><PRE> function purgeElement(element) {
   var uid = getUniqueElementID(element);
   if (uid) {
     Element.stopObserving(element);
     if (!HAS_UNIQUE_ID_PROPERTY)
       element._prototypeUID = UNDEFINED;
     delete Element.Storage[uid];
   }
 }
</PRE><PRE> function purgeCollection(elements) {
   var i = elements.length;
   while (i--)
     purgeElement(elements[i]);
 }
</PRE><PRE> function purgeCollection_IE(elements) {
   var i = elements.length, element, uid;
   while (i--) {
     element = elements[i];
     uid = getUniqueElementID(element);
     delete Element.Storage[uid];
     delete Event.cache[uid];
   }
 }
</PRE><PRE> if (HAS_UNIQUE_ID_PROPERTY) {
   purgeCollection = purgeCollection_IE;
 }
</PRE><PRE> function purge(element) {
   if (!(element = $(element))) return;
   purgeElement(element);
</PRE><PRE>   var descendants = element.getElementsByTagName('*'),
    i = descendants.length;
</PRE><PRE>   while (i--) purgeElement(descendants[i]);
</PRE><PRE>   return null;
 }
</PRE><PRE> Object.extend(methods, {
   remove:  remove,
   update:  update,
   replace: replace,
   insert:  insert,
   wrap:    wrap,
   cleanWhitespace: cleanWhitespace,
   empty:   empty,
   clone:   clone,
   purge:   purge
 });
</PRE><PRE> function recursivelyCollect(element, property, maximumLength) {
   element = $(element);
   maximumLength = maximumLength || -1;
   var elements = [];
</PRE><PRE>   while (element = element[property]) {
     if (element.nodeType === Node.ELEMENT_NODE)
       elements.push(Element.extend(element));
</PRE><PRE>     if (elements.length === maximumLength) break;
   }
</PRE><PRE>   return elements;
 }
</PRE><PRE> function ancestors(element) {
   return recursivelyCollect(element, 'parentNode');
 }
</PRE><PRE> function descendants(element) {
   return Element.select(element, '*');
 }
</PRE><PRE> function firstDescendant(element) {
   element = $(element).firstChild;
   while (element &amp;&amp; element.nodeType !== Node.ELEMENT_NODE)
     element = element.nextSibling;
</PRE><PRE>   return $(element);
 }
</PRE><PRE> function immediateDescendants(element) {
   var results = [], child = $(element).firstChild;
</PRE><PRE>   while (child) {
     if (child.nodeType === Node.ELEMENT_NODE)
       results.push(Element.extend(child));
</PRE><PRE>     child = child.nextSibling;
   }
</PRE><PRE>   return results;
 }
</PRE><PRE> function previousSiblings(element) {
   return recursivelyCollect(element, 'previousSibling');
 }
</PRE><PRE> function nextSiblings(element) {
   return recursivelyCollect(element, 'nextSibling');
 }
</PRE><PRE> function siblings(element) {
   element = $(element);
   var previous = previousSiblings(element),
    next = nextSiblings(element);
   return previous.reverse().concat(next);
 }
</PRE><PRE> function match(element, selector) {
   element = $(element);
</PRE><PRE>   if (Object.isString(selector))
     return Prototype.Selector.match(element, selector);
</PRE><PRE>   return selector.match(element);
 }
</PRE><PRE> function _recursivelyFind(element, property, expression, index) {
   element = $(element), expression = expression || 0, index = index || 0;
   if (Object.isNumber(expression)) {
     index = expression, expression = null;
   }
</PRE><PRE>   while (element = element[property]) {
     if (element.nodeType !== 1) continue;
     if (expression &amp;&amp; !Prototype.Selector.match(element, expression))
       continue;
     if (--index &gt;= 0) continue;
</PRE><PRE>     return Element.extend(element);
   }
 }
</PRE><PRE> function up(element, expression, index) {
   element = $(element);
</PRE><PRE>   if (arguments.length === 1) return $(element.parentNode);
   return _recursivelyFind(element, 'parentNode', expression, index);
 }
</PRE><PRE> function down(element, expression, index) {
   if (arguments.length === 1) return firstDescendant(element);
   element = $(element), expression = expression || 0, index = index || 0;
</PRE><PRE>   if (Object.isNumber(expression))
     index = expression, expression = '*';
</PRE><PRE>   var node = Prototype.Selector.select(expression, element)[index];
   return Element.extend(node);
 }
</PRE><PRE> function previous(element, expression, index) {
   return _recursivelyFind(element, 'previousSibling', expression, index);
 }
</PRE><PRE> function next(element, expression, index) {
   return _recursivelyFind(element, 'nextSibling', expression, index);
 }
</PRE><PRE> function select(element) {
   element = $(element);
   var expressions = SLICE.call(arguments, 1).join(', ');
   return Prototype.Selector.select(expressions, element);
 }
</PRE><PRE> function adjacent(element) {
   element = $(element);
   var expressions = SLICE.call(arguments, 1).join(', ');
   var siblings = Element.siblings(element), results = [];
   for (var i = 0, sibling; sibling = siblings[i]; i++) {
     if (Prototype.Selector.match(sibling, expressions))
       results.push(sibling);
   }
</PRE><PRE>   return results;
 }
</PRE><PRE> function descendantOf_DOM(element, ancestor) {
   element = $(element), ancestor = $(ancestor);
   while (element = element.parentNode)
     if (element === ancestor) return true;
   return false;
 }
</PRE><PRE> function descendantOf_contains(element, ancestor) {
   element = $(element), ancestor = $(ancestor);
   if (!ancestor.contains) return descendantOf_DOM(element, ancestor);
   return ancestor.contains(element) &amp;&amp; ancestor !== element;
 }
</PRE><PRE> function descendantOf_compareDocumentPosition(element, ancestor) {
   element = $(element), ancestor = $(ancestor);
   return (element.compareDocumentPosition(ancestor) &amp; 8) === 8;
 }
</PRE><PRE> var descendantOf;
 if (DIV.compareDocumentPosition) {
   descendantOf = descendantOf_compareDocumentPosition;
 } else if (DIV.contains) {
   descendantOf = descendantOf_contains;
 } else {
   descendantOf = descendantOf_DOM;
 }
</PRE><PRE> Object.extend(methods, {
   recursivelyCollect:   recursivelyCollect,
   ancestors:            ancestors,
   descendants:          descendants,
   firstDescendant:      firstDescendant,
   immediateDescendants: immediateDescendants,
   previousSiblings:     previousSiblings,
   nextSiblings:         nextSiblings,
   siblings:             siblings,
   match:                match,
   up:                   up,
   down:                 down,
   previous:             previous,
   next:                 next,
   select:               select,
   adjacent:             adjacent,
   descendantOf:         descendantOf,
</PRE><PRE>   getElementsBySelector: select,
</PRE><PRE>   childElements:         immediateDescendants
 });
</PRE><PRE> var idCounter = 1;
 function identify(element) {
   element = $(element);
   var id = Element.readAttribute(element, 'id');
   if (id) return id;
</PRE><PRE>   do { id = 'anonymous_element_' + idCounter++ } while ($(id));
</PRE><PRE>   Element.writeAttribute(element, 'id', id);
   return id;
 }
</PRE><PRE> function readAttribute(element, name) {
   return $(element).getAttribute(name);
 }
</PRE><PRE> function readAttribute_IE(element, name) {
   element = $(element);
</PRE><PRE>   var table = ATTRIBUTE_TRANSLATIONS.read;
   if (table.values[name])
     return table.values[name](element, name);
</PRE><PRE>   if (table.names[name]) name = table.names[name];
</PRE><PRE>   if (name.include(':')) {
     if (!element.attributes || !element.attributes[name]) return null;
     return element.attributes[name].value;
   }
</PRE><PRE>   return element.getAttribute(name);
 }
</PRE><PRE> function readAttribute_Opera(element, name) {
   if (name === 'title') return element.title;
   return element.getAttribute(name);
 }
</PRE><PRE> var PROBLEMATIC_ATTRIBUTE_READING = (function() {
   DIV.setAttribute('onclick', []);
   var value = DIV.getAttribute('onclick');
   var isFunction = Object.isArray(value);
   DIV.removeAttribute('onclick');
   return isFunction;
 })();
</PRE><PRE> if (PROBLEMATIC_ATTRIBUTE_READING) {
   readAttribute = readAttribute_IE;
 } else if (Prototype.Browser.Opera) {
   readAttribute = readAttribute_Opera;
 }
</PRE><PRE> function writeAttribute(element, name, value) {
   element = $(element);
   var attributes = {}, table = ATTRIBUTE_TRANSLATIONS.write;
</PRE><PRE>   if (typeof name === 'object') {
     attributes = name;
   } else {
     attributes[name] = Object.isUndefined(value) ? true : value;
   }
</PRE><PRE>   for (var attr in attributes) {
     name = table.names[attr] || attr;
     value = attributes[attr];
     if (table.values[attr])
       name = table.values[attr](element, value) || name;
     if (value === false || value === null)
       element.removeAttribute(name);
     else if (value === true)
       element.setAttribute(name, name);
     else element.setAttribute(name, value);
   }
</PRE><PRE>   return element;
 }
</PRE><PRE> var PROBLEMATIC_HAS_ATTRIBUTE_WITH_CHECKBOXES = (function () {
   if (!HAS_EXTENDED_CREATE_ELEMENT_SYNTAX) {
     return false;
   }
   var checkbox = document.createElement('&lt;input type=&quot;checkbox&quot;&gt;');
   checkbox.checked = true;
   var node = checkbox.getAttributeNode('checked');
   return !node || !node.specified;
 })();
</PRE><PRE> function hasAttribute(element, attribute) {
   attribute = ATTRIBUTE_TRANSLATIONS.has[attribute] || attribute;
   var node = $(element).getAttributeNode(attribute);
   return !!(node &amp;&amp; node.specified);
 }
</PRE><PRE> function hasAttribute_IE(element, attribute) {
   if (attribute === 'checked') {
     return element.checked;
   }
   return hasAttribute(element, attribute);
 }
</PRE><PRE> GLOBAL.Element.Methods.Simulated.hasAttribute =
  PROBLEMATIC_HAS_ATTRIBUTE_WITH_CHECKBOXES ?
  hasAttribute_IE : hasAttribute;
</PRE><PRE> function classNames(element) {
   return new Element.ClassNames(element);
 }
</PRE><PRE> var regExpCache = {};
 function getRegExpForClassName(className) {
   if (regExpCache[className]) return regExpCache[className];
</PRE><PRE>   var re = new RegExp(&quot;(^|\\s+)&quot; + className + &quot;(\\s+|$)&quot;);
   regExpCache[className] = re;
   return re;
 }
</PRE><PRE> function hasClassName(element, className) {
   if (!(element = $(element))) return;
</PRE><PRE>   var elementClassName = element.className;
</PRE><PRE>   if (elementClassName.length === 0) return false;
   if (elementClassName === className) return true;
</PRE><PRE>   return getRegExpForClassName(className).test(elementClassName);
 }
</PRE><PRE> function addClassName(element, className) {
   if (!(element = $(element))) return;
</PRE><PRE>   if (!hasClassName(element, className))
     element.className += (element.className ? ' ' : <I>) + className;</I></PRE><PRE>   return element;
 }
</PRE><PRE> function removeClassName(element, className) {
   if (!(element = $(element))) return;
</PRE><PRE>   element.className = element.className.replace(
    getRegExpForClassName(className), ' ').strip();
</PRE><PRE>   return element;
 }
</PRE><PRE> function toggleClassName(element, className, bool) {
   if (!(element = $(element))) return;
</PRE><PRE>   if (Object.isUndefined(bool))
     bool = !hasClassName(element, className);
</PRE><PRE>   var method = Element[bool ? 'addClassName' : 'removeClassName'];
   return method(element, className);
 }
</PRE><PRE> var ATTRIBUTE_TRANSLATIONS = {};
</PRE><PRE> var classProp = 'className', forProp = 'for';
</PRE><PRE> DIV.setAttribute(classProp, 'x');
 if (DIV.className !== 'x') {
   DIV.setAttribute('class', 'x');
   if (DIV.className === 'x')
     classProp = 'class';
 }
</PRE><PRE> var LABEL = document.createElement('label');
 LABEL.setAttribute(forProp, 'x');
 if (LABEL.htmlFor !== 'x') {
   LABEL.setAttribute('htmlFor', 'x');
   if (LABEL.htmlFor === 'x')
     forProp = 'htmlFor';
 }
 LABEL = null;
</PRE><PRE> function _getAttr(element, attribute) {
   return element.getAttribute(attribute);
 }
</PRE><PRE> function _getAttr2(element, attribute) {
   return element.getAttribute(attribute, 2);
 }
</PRE><PRE> function _getAttrNode(element, attribute) {
   var node = element.getAttributeNode(attribute);
   return node ? node.value : <I>;</I>
 }
</PRE><PRE> function _getFlag(element, attribute) {
   return $(element).hasAttribute(attribute) ? attribute : null;
 }
</PRE><PRE> DIV.onclick = Prototype.emptyFunction;
 var onclickValue = DIV.getAttribute('onclick');
</PRE><PRE> var _getEv;
</PRE><PRE> if (String(onclickValue).indexOf('{') &gt; -1) {
   _getEv = function(element, attribute) {
     var value = element.getAttribute(attribute);
     if (!value) return null;
     value = value.toString();
     value = value.split('{')[1];
     value = value.split('}')[0];
     return value.strip();
   };
 }
 else if (onclickValue === <I>) {</I>
   _getEv = function(element, attribute) {
     var value = element.getAttribute(attribute);
     if (!value) return null;
     return value.strip();
   };
 }
</PRE><PRE> ATTRIBUTE_TRANSLATIONS.read = {
   names: {
     'class':     classProp,
     'className': classProp,
     'for':       forProp,
     'htmlFor':   forProp
   },
</PRE><PRE>   values: {
     style: function(element) {
       return element.style.cssText.toLowerCase();
     },
     title: function(element) {
       return element.title;
     }
   }
 };
</PRE><PRE> ATTRIBUTE_TRANSLATIONS.write = {
   names: {
     className:   'class',
     htmlFor:     'for',
     cellpadding: 'cellPadding',
     cellspacing: 'cellSpacing'
   },
</PRE><PRE>   values: {
     checked: function(element, value) {
       element.checked = !!value;
     },
</PRE><PRE>     style: function(element, value) {
       element.style.cssText = value ? value : <I>;</I>
     }
   }
 };
</PRE><PRE> ATTRIBUTE_TRANSLATIONS.has = { names: {} };
</PRE><PRE> Object.extend(ATTRIBUTE_TRANSLATIONS.write.names,
  ATTRIBUTE_TRANSLATIONS.read.names);
</PRE><PRE> var CAMEL_CASED_ATTRIBUTE_NAMES = $w('colSpan rowSpan vAlign dateTime ' +
  'accessKey tabIndex encType maxLength readOnly longDesc frameBorder');
</PRE><PRE> for (var i = 0, attr; attr = CAMEL_CASED_ATTRIBUTE_NAMES[i]; i++) {
   ATTRIBUTE_TRANSLATIONS.write.names[attr.toLowerCase()] = attr;
   ATTRIBUTE_TRANSLATIONS.has.names[attr.toLowerCase()]   = attr;
 }
</PRE><PRE> Object.extend(ATTRIBUTE_TRANSLATIONS.read.values, {
   href:        _getAttr2,
   src:         _getAttr2,
   type:        _getAttr,
   action:      _getAttrNode,
   disabled:    _getFlag,
   checked:     _getFlag,
   readonly:    _getFlag,
   multiple:    _getFlag,
   onload:      _getEv,
   onunload:    _getEv,
   onclick:     _getEv,
   ondblclick:  _getEv,
   onmousedown: _getEv,
   onmouseup:   _getEv,
   onmouseover: _getEv,
   onmousemove: _getEv,
   onmouseout:  _getEv,
   onfocus:     _getEv,
   onblur:      _getEv,
   onkeypress:  _getEv,
   onkeydown:   _getEv,
   onkeyup:     _getEv,
   onsubmit:    _getEv,
   onreset:     _getEv,
   onselect:    _getEv,
   onchange:    _getEv
 });
</PRE><PRE> Object.extend(methods, {
   identify:        identify,
   readAttribute:   readAttribute,
   writeAttribute:  writeAttribute,
   classNames:      classNames,
   hasClassName:    hasClassName,
   addClassName:    addClassName,
   removeClassName: removeClassName,
   toggleClassName: toggleClassName
 });
</PRE><PRE> function normalizeStyleName(style) {
   if (style === 'float' || style === 'styleFloat')
     return 'cssFloat';
   return style.camelize();
 }
</PRE><PRE> function normalizeStyleName_IE(style) {
   if (style === 'float' || style === 'cssFloat')
     return 'styleFloat';
   return style.camelize();
 }
</PRE><PRE> function setStyle(element, styles) {
   element = $(element);
   var elementStyle = element.style, match;
</PRE><PRE>   if (Object.isString(styles)) {
     elementStyle.cssText += ';' + styles;
     if (styles.include('opacity')) {
       var opacity = styles.match(/opacity:\s*(\d?\.?\d*)/)[1];
       Element.setOpacity(element, opacity);
     }
     return element;
   }
</PRE><PRE>   for (var property in styles) {
     if (property === 'opacity') {
       Element.setOpacity(element, styles[property]);
     } else {
       var value = styles[property];
       if (property === 'float' || property === 'cssFloat') {
         property = Object.isUndefined(elementStyle.styleFloat) ?
          'cssFloat' : 'styleFloat';
       }
       elementStyle[property] = value;
     }
   }
</PRE><PRE>   return element;
 }
</PRE><PRE> function getStyle(element, style) {
   element = $(element);
   style = normalizeStyleName(style);
</PRE><PRE>   var value = element.style[style];
   if (!value || value === 'auto') {
     var css = document.defaultView.getComputedStyle(element, null);
     value = css ? css[style] : null;
   }
</PRE><PRE>   if (style === 'opacity') return value ? parseFloat(value) : 1.0;
   return value === 'auto' ? null : value;
 }
</PRE><PRE> function getStyle_Opera(element, style) {
   switch (style) {
     case 'height': case 'width':
       if (!Element.visible(element)) return null;
</PRE><PRE>       var dim = parseInt(getStyle(element, style), 10);
</PRE><PRE>       if (dim !== element['offset' + style.capitalize()])
         return dim + 'px';
</PRE><PRE>       return Element.measure(element, style);
</PRE><PRE>     default: return getStyle(element, style);
   }
 }
</PRE><PRE> function getStyle_IE(element, style) {
   element = $(element);
   style = normalizeStyleName_IE(style);
</PRE><PRE>   var value = element.style[style];
   if (!value &amp;&amp; element.currentStyle) {
     value = element.currentStyle[style];
   }
</PRE><PRE>   if (style === 'opacity' &amp;&amp; !STANDARD_CSS_OPACITY_SUPPORTED)
     return getOpacity_IE(element);
</PRE><PRE>   if (value === 'auto') {
     if ((style === 'width' || style === 'height') &amp;&amp; Element.visible(element))
       return Element.measure(element, style) + 'px';
     return null;
   }
</PRE><PRE>   return value;
 }
</PRE><PRE> function stripAlphaFromFilter_IE(filter) {
   return (filter || <I>).replace(/alpha\([^\)]*\)/gi, </I>);
 }
</PRE><PRE> function hasLayout_IE(element) {
   if (!element.currentStyle || !element.currentStyle.hasLayout)
     element.style.zoom = 1;
   return element;
 }
</PRE><PRE> var STANDARD_CSS_OPACITY_SUPPORTED = (function() {
   DIV.style.cssText = &quot;opacity:.55&quot;;
   return /^0.55/.test(DIV.style.opacity);
 })();
</PRE><PRE> function setOpacity(element, value) {
   element = $(element);
   if (value == 1 || value === <I>) value = </I>;
   else if (value &lt; 0.00001) value = 0;
   element.style.opacity = value;
   return element;
 }
</PRE><PRE> function setOpacity_IE(element, value) {
   if (STANDARD_CSS_OPACITY_SUPPORTED)
     return setOpacity(element, value);
</PRE><PRE>   element = hasLayout_IE($(element));
   var filter = Element.getStyle(element, 'filter'),
    style = element.style;
</PRE><PRE>   if (value == 1 || value === <I>) {</I>
     filter = stripAlphaFromFilter_IE(filter);
     if (filter) style.filter = filter;
     else style.removeAttribute('filter');
     return element;
   }
</PRE><PRE>   if (value &lt; 0.00001) value = 0;
</PRE><PRE>   style.filter = stripAlphaFromFilter_IE(filter) +
    'alpha(opacity=' + (value * 100) + ')';
</PRE><PRE>   return element;
 }
</PRE><PRE> function getOpacity(element) {
   return Element.getStyle(element, 'opacity');
 }
</PRE><PRE> function getOpacity_IE(element) {
   if (STANDARD_CSS_OPACITY_SUPPORTED)
     return getOpacity(element);
</PRE><PRE>   var filter = Element.getStyle(element, 'filter');
   if (filter.length === 0) return 1.0;
   var match = (filter || <I>).match(/alpha\(opacity=(.*)\)/);</I>
   if (match &amp;&amp; match[1]) return parseFloat(match[1]) / 100;
   return 1.0;
 }
</PRE><PRE> Object.extend(methods, {
   setStyle:   setStyle,
   getStyle:   getStyle,
   setOpacity: setOpacity,
   getOpacity: getOpacity
 });
</PRE><PRE> if ('styleFloat' in DIV.style) {
   methods.getStyle = getStyle_IE;
   methods.setOpacity = setOpacity_IE;
   methods.getOpacity = getOpacity_IE;
 }
</PRE><PRE> var UID = 0;
</PRE><PRE> GLOBAL.Element.Storage = { UID: 1 };
</PRE><PRE> function getUniqueElementID(element) {
   if (element === window) return 0;
</PRE><PRE>   if (typeof element._prototypeUID === 'undefined')
     element._prototypeUID = Element.Storage.UID++;
   return element._prototypeUID;
 }
</PRE><PRE> function getUniqueElementID_IE(element) {
   if (element === window) return 0;
   if (element == document) return 1;
   return element.uniqueID;
 }
</PRE><PRE> var HAS_UNIQUE_ID_PROPERTY = ('uniqueID' in DIV);
 if (HAS_UNIQUE_ID_PROPERTY)
   getUniqueElementID = getUniqueElementID_IE;
</PRE><PRE> function getStorage(element) {
   if (!(element = $(element))) return;
</PRE><PRE>   var uid = getUniqueElementID(element);
</PRE><PRE>   if (!Element.Storage[uid])
     Element.Storage[uid] = $H();
</PRE><PRE>   return Element.Storage[uid];
 }
</PRE><PRE> function store(element, key, value) {
   if (!(element = $(element))) return;
   var storage = getStorage(element);
   if (arguments.length === 2) {
     storage.update(key);
   } else {
     storage.set(key, value);
   }
   return element;
 }
</PRE><PRE> function retrieve(element, key, defaultValue) {
   if (!(element = $(element))) return;
   var storage = getStorage(element), value = storage.get(key);
</PRE><PRE>   if (Object.isUndefined(value)) {
     storage.set(key, defaultValue);
     value = defaultValue;
   }
</PRE><PRE>   return value;
 }
</PRE><PRE> Object.extend(methods, {
   getStorage: getStorage,
   store:      store,
   retrieve:   retrieve
 });
</PRE><PRE> var Methods = {}, ByTag = Element.Methods.ByTag,
  F = Prototype.BrowserFeatures;
</PRE><PRE> if (!F.ElementExtensions &amp;&amp; ('__proto__' in DIV)) {
   GLOBAL.HTMLElement = {};
   GLOBAL.HTMLElement.prototype = DIV['__proto__'];
   F.ElementExtensions = true;
 }
</PRE><PRE> function checkElementPrototypeDeficiency(tagName) {
   if (typeof window.Element === 'undefined') return false;
   if (!HAS_EXTENDED_CREATE_ELEMENT_SYNTAX) return false;
   var proto = window.Element.prototype;
   if (proto) {
     var id = '_' + (Math.random() + <I>).slice(2),</I>
      el = document.createElement(tagName);
     proto[id] = 'x';
     var isBuggy = (el[id] !== 'x');
     delete proto[id];
     el = null;
     return isBuggy;
   }
</PRE><PRE>   return false;
 }
</PRE><PRE> var HTMLOBJECTELEMENT_PROTOTYPE_BUGGY =
  checkElementPrototypeDeficiency('object');
</PRE><PRE> function extendElementWith(element, methods) {
   for (var property in methods) {
     var value = methods[property];
     if (Object.isFunction(value) &amp;&amp; !(property in element))
       element[property] = value.methodize();
   }
 }
</PRE><PRE> var EXTENDED = {};
 function elementIsExtended(element) {
   var uid = getUniqueElementID(element);
   return (uid in EXTENDED);
 }
</PRE><PRE> function extend(element) {
   if (!element || elementIsExtended(element)) return element;
   if (element.nodeType !== Node.ELEMENT_NODE || element == window)
     return element;
</PRE><PRE>   var methods = Object.clone(Methods),
    tagName = element.tagName.toUpperCase();
</PRE><PRE>   if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);
</PRE><PRE>   extendElementWith(element, methods);
   EXTENDED[getUniqueElementID(element)] = true;
   return element;
 }
</PRE><PRE> function extend_IE8(element) {
   if (!element || elementIsExtended(element)) return element;
</PRE><PRE>   var t = element.tagName;
   if (t &amp;&amp; (/^(?:object|applet|embed)$/i.test(t))) {
     extendElementWith(element, Element.Methods);
     extendElementWith(element, Element.Methods.Simulated);
     extendElementWith(element, Element.Methods.ByTag[t.toUpperCase()]);
   }
</PRE><PRE>   return element;
 }
</PRE><PRE> if (F.SpecificElementExtensions) {
   extend = HTMLOBJECTELEMENT_PROTOTYPE_BUGGY ? extend_IE8 : Prototype.K;
 }
</PRE><PRE> function addMethodsToTagName(tagName, methods) {
   tagName = tagName.toUpperCase();
   if (!ByTag[tagName]) ByTag[tagName] = {};
   Object.extend(ByTag[tagName], methods);
 }
</PRE><PRE> function mergeMethods(destination, methods, onlyIfAbsent) {
   if (Object.isUndefined(onlyIfAbsent)) onlyIfAbsent = false;
   for (var property in methods) {
     var value = methods[property];
     if (!Object.isFunction(value)) continue;
     if (!onlyIfAbsent || !(property in destination))
       destination[property] = value.methodize();
   }
 }
</PRE><PRE> function findDOMClass(tagName) {
   var klass;
   var trans = {
     &quot;OPTGROUP&quot;: &quot;OptGroup&quot;, &quot;TEXTAREA&quot;: &quot;TextArea&quot;, &quot;P&quot;: &quot;Paragraph&quot;,
     &quot;FIELDSET&quot;: &quot;FieldSet&quot;, &quot;UL&quot;: &quot;UList&quot;, &quot;OL&quot;: &quot;OList&quot;, &quot;DL&quot;: &quot;DList&quot;,
     &quot;DIR&quot;: &quot;Directory&quot;, &quot;H1&quot;: &quot;Heading&quot;, &quot;H2&quot;: &quot;Heading&quot;, &quot;H3&quot;: &quot;Heading&quot;,
     &quot;H4&quot;: &quot;Heading&quot;, &quot;H5&quot;: &quot;Heading&quot;, &quot;H6&quot;: &quot;Heading&quot;, &quot;Q&quot;: &quot;Quote&quot;,
     &quot;INS&quot;: &quot;Mod&quot;, &quot;DEL&quot;: &quot;Mod&quot;, &quot;A&quot;: &quot;Anchor&quot;, &quot;IMG&quot;: &quot;Image&quot;, &quot;CAPTION&quot;:
     &quot;TableCaption&quot;, &quot;COL&quot;: &quot;TableCol&quot;, &quot;COLGROUP&quot;: &quot;TableCol&quot;, &quot;THEAD&quot;:
     &quot;TableSection&quot;, &quot;TFOOT&quot;: &quot;TableSection&quot;, &quot;TBODY&quot;: &quot;TableSection&quot;, &quot;TR&quot;:
     &quot;TableRow&quot;, &quot;TH&quot;: &quot;TableCell&quot;, &quot;TD&quot;: &quot;TableCell&quot;, &quot;FRAMESET&quot;:
     &quot;FrameSet&quot;, &quot;IFRAME&quot;: &quot;IFrame&quot;
   };
   if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
   if (window[klass]) return window[klass];
   klass = 'HTML' + tagName + 'Element';
   if (window[klass]) return window[klass];
   klass = 'HTML' + tagName.capitalize() + 'Element';
   if (window[klass]) return window[klass];
</PRE><PRE>   var element = document.createElement(tagName),
    proto = element['__proto__'] || element.constructor.prototype;
</PRE><PRE>   element = null;
   return proto;
 }
</PRE><PRE> function addMethods(methods) {
   if (arguments.length === 0) addFormMethods();
</PRE><PRE>   if (arguments.length === 2) {
     var tagName = methods;
     methods = arguments[1];
   }
</PRE><PRE>   if (!tagName) {
     Object.extend(Element.Methods, methods || {});
   } else {
     if (Object.isArray(tagName)) {
       for (var i = 0, tag; tag = tagName[i]; i++)
         addMethodsToTagName(tag, methods);
     } else {
       addMethodsToTagName(tagName, methods);
     }
   }
</PRE><PRE>   var ELEMENT_PROTOTYPE = window.HTMLElement ? HTMLElement.prototype :
    Element.prototype;
</PRE><PRE>   if (F.ElementExtensions) {
     mergeMethods(ELEMENT_PROTOTYPE, Element.Methods);
     mergeMethods(ELEMENT_PROTOTYPE, Element.Methods.Simulated, true);
   }
</PRE><PRE>   if (F.SpecificElementExtensions) {
     for (var tag in Element.Methods.ByTag) {
       var klass = findDOMClass(tag);
       if (Object.isUndefined(klass)) continue;
       mergeMethods(klass.prototype, ByTag[tag]);
     }
   }
</PRE><PRE>   Object.extend(Element, Element.Methods);
   Object.extend(Element, Element.Methods.Simulated);
   delete Element.ByTag;
   delete Element.Simulated;
</PRE><PRE>   Element.extend.refresh();
</PRE><PRE>   ELEMENT_CACHE = {};
 }
</PRE><PRE> Object.extend(GLOBAL.Element, {
   extend:     extend,
   addMethods: addMethods
 });
</PRE><PRE> if (extend === Prototype.K) {
   GLOBAL.Element.extend.refresh = Prototype.emptyFunction;
 } else {
   GLOBAL.Element.extend.refresh = function() {
     if (Prototype.BrowserFeatures.ElementExtensions) return;
     Object.extend(Methods, Element.Methods);
     Object.extend(Methods, Element.Methods.Simulated);
</PRE><PRE>     EXTENDED = {};
   };
 }
</PRE><PRE> function addFormMethods() {
   Object.extend(Form, Form.Methods);
   Object.extend(Form.Element, Form.Element.Methods);
   Object.extend(Element.Methods.ByTag, {
     &quot;FORM&quot;:     Object.clone(Form.Methods),
     &quot;INPUT&quot;:    Object.clone(Form.Element.Methods),
     &quot;SELECT&quot;:   Object.clone(Form.Element.Methods),
     &quot;TEXTAREA&quot;: Object.clone(Form.Element.Methods),
     &quot;BUTTON&quot;:   Object.clone(Form.Element.Methods)
   });
 }
</PRE><PRE> Element.addMethods(methods);
</PRE><PRE> function destroyCache_IE() {
   DIV = null;
   ELEMENT_CACHE = null;
 }
</PRE><PRE> if (window.attachEvent)
   window.attachEvent('onunload', destroyCache_IE);
</PRE><P>})(this);
(function() {
</P><PRE> function toDecimal(pctString) {
   var match = pctString.match(/^(\d+)%?$/i);
   if (!match) return null;
   return (Number(match[1]) / 100);
 }
</PRE><PRE> function getRawStyle(element, style) {
   element = $(element);
</PRE><PRE>   var value = element.style[style];
   if (!value || value === 'auto') {
     var css = document.defaultView.getComputedStyle(element, null);
     value = css ? css[style] : null;
   }
</PRE><PRE>   if (style === 'opacity') return value ? parseFloat(value) : 1.0;
   return value === 'auto' ? null : value;
 }
</PRE><PRE> function getRawStyle_IE(element, style) {
   var value = element.style[style];
   if (!value &amp;&amp; element.currentStyle) {
     value = element.currentStyle[style];
   }
   return value;
 }
</PRE><PRE> function getContentWidth(element, context) {
   var boxWidth = element.offsetWidth;
</PRE><PRE>   var bl = getPixelValue(element, 'borderLeftWidth',  context) || 0;
   var br = getPixelValue(element, 'borderRightWidth', context) || 0;
   var pl = getPixelValue(element, 'paddingLeft',      context) || 0;
   var pr = getPixelValue(element, 'paddingRight',     context) || 0;
</PRE><PRE>   return boxWidth - bl - br - pl - pr;
 }
</PRE><PRE> if ('currentStyle' in document.documentElement) {
   getRawStyle = getRawStyle_IE;
 }
</PRE><PRE> function getPixelValue(value, property, context) {
   var element = null;
   if (Object.isElement(value)) {
     element = value;
     value = getRawStyle(element, property);
   }
</PRE><PRE>   if (value === null || Object.isUndefined(value)) {
     return null;
   }
</PRE><PRE>   if ((/^(?:-)?\d+(\.\d+)?(px)?$/i).test(value)) {
     return window.parseFloat(value);
   }
</PRE><PRE>   var isPercentage = value.include('%'), isViewport = (context === document.viewport);
</PRE><PRE>   if (/\d/.test(value) &amp;&amp; element &amp;&amp; element.runtimeStyle &amp;&amp; !(isPercentage &amp;&amp; isViewport)) {
     var style = element.style.left, rStyle = element.runtimeStyle.left;
     element.runtimeStyle.left = element.currentStyle.left;
     element.style.left = value || 0;
     value = element.style.pixelLeft;
     element.style.left = style;
     element.runtimeStyle.left = rStyle;
</PRE><PRE>     return value;
   }
</PRE><PRE>   if (element &amp;&amp; isPercentage) {
     context = context || element.parentNode;
     var decimal = toDecimal(value), whole = null;
</PRE><PRE>     var isHorizontal = property.include('left') || property.include('right') ||
      property.include('width');
</PRE><PRE>     var isVertical   = property.include('top') || property.include('bottom') ||
       property.include('height');
</PRE><PRE>     if (context === document.viewport) {
       if (isHorizontal) {
         whole = document.viewport.getWidth();
       } else if (isVertical) {
         whole = document.viewport.getHeight();
       }
     } else {
       if (isHorizontal) {
         whole = $(context).measure('width');
       } else if (isVertical) {
         whole = $(context).measure('height');
       }
     }
</PRE><PRE>     return (whole === null) ? 0 : whole * decimal;
   }
</PRE><PRE>   return 0;
 }
</PRE><PRE> function toCSSPixels(number) {
   if (Object.isString(number) &amp;&amp; number.endsWith('px'))
     return number;
   return number + 'px';
 }
</PRE><PRE> function isDisplayed(element) {
   while (element &amp;&amp; element.parentNode) {
     var display = element.getStyle('display');
     if (display === 'none') {
       return false;
     }
     element = $(element.parentNode);
   }
   return true;
 }
</PRE><PRE> var hasLayout = Prototype.K;
 if ('currentStyle' in document.documentElement) {
   hasLayout = function(element) {
     if (!element.currentStyle.hasLayout) {
       element.style.zoom = 1;
     }
     return element;
   };
 }
</PRE><PRE> function cssNameFor(key) {
   if (key.include('border')) key = key + '-width';
   return key.camelize();
 }
</PRE><PRE> Element.Layout = Class.create(Hash, {
   initialize: function($super, element, preCompute) {
     $super();
     this.element = $(element);
</PRE><PRE>     Element.Layout.PROPERTIES.each( function(property) {
       this._set(property, null);
     }, this);
</PRE><PRE>     if (preCompute) {
       this._preComputing = true;
       this._begin();
       Element.Layout.PROPERTIES.each( this._compute, this );
       this._end();
       this._preComputing = false;
     }
   },
</PRE><PRE>   _set: function(property, value) {
     return Hash.prototype.set.call(this, property, value);
   },
</PRE><PRE>   set: function(property, value) {
     throw &quot;Properties of Element.Layout are read-only.&quot;;
   },
</PRE><PRE>   get: function($super, property) {
     var value = $super(property);
     return value === null ? this._compute(property) : value;
   },
</PRE><PRE>   _begin: function() {
     if (this._isPrepared()) return;
</PRE><PRE>     var element = this.element;
     if (isDisplayed(element)) {
       this._setPrepared(true);
       return;
     }
</PRE><PRE>     var originalStyles = {
       position:   element.style.position   || <I>,</I>
       width:      element.style.width      || <I>,</I>
       visibility: element.style.visibility || <I>,</I>
       display:    element.style.display    || 
     };
</PRE><PRE>     element.store('prototype_original_styles', originalStyles);
</PRE><PRE>     var position = getRawStyle(element, 'position'), width = element.offsetWidth;
</PRE><PRE>     if (width === 0 || width === null) {
       element.style.display = 'block';
       width = element.offsetWidth;
     }
</PRE><PRE>     var context = (position === 'fixed') ? document.viewport :
      element.parentNode;
</PRE><PRE>     var tempStyles = {
       visibility: 'hidden',
       display:    'block'
     };
</PRE><PRE>     if (position !== 'fixed') tempStyles.position = 'absolute';
</PRE><PRE>     element.setStyle(tempStyles);
</PRE><PRE>     var positionedWidth = element.offsetWidth, newWidth;
     if (width &amp;&amp; (positionedWidth === width)) {
       newWidth = getContentWidth(element, context);
     } else if (position === 'absolute' || position === 'fixed') {
       newWidth = getContentWidth(element, context);
     } else {
       var parent = element.parentNode, pLayout = $(parent).getLayout();
</PRE><PRE>       newWidth = pLayout.get('width') -
        this.get('margin-left') -
        this.get('border-left') -
        this.get('padding-left') -
        this.get('padding-right') -
        this.get('border-right') -
        this.get('margin-right');
     }
</PRE><PRE>     element.setStyle({ width: newWidth + 'px' });
</PRE><PRE>     this._setPrepared(true);
   },
</PRE><PRE>   _end: function() {
     var element = this.element;
     var originalStyles = element.retrieve('prototype_original_styles');
     element.store('prototype_original_styles', null);
     element.setStyle(originalStyles);
     this._setPrepared(false);
   },
</PRE><PRE>   _compute: function(property) {
     var COMPUTATIONS = Element.Layout.COMPUTATIONS;
     if (!(property in COMPUTATIONS)) {
       throw &quot;Property not found.&quot;;
     }
</PRE><PRE>     return this._set(property, COMPUTATIONS[property].call(this, this.element));
   },
</PRE><PRE>   _isPrepared: function() {
     return this.element.retrieve('prototype_element_layout_prepared', false);
   },
</PRE><PRE>   _setPrepared: function(bool) {
     return this.element.store('prototype_element_layout_prepared', bool);
   },
</PRE><PRE>   toObject: function() {
     var args = $A(arguments);
     var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
      args.join(' ').split(' ');
     var obj = {};
     keys.each( function(key) {
       if (!Element.Layout.PROPERTIES.include(key)) return;
       var value = this.get(key);
       if (value != null) obj[key] = value;
     }, this);
     return obj;
   },
</PRE><PRE>   toHash: function() {
     var obj = this.toObject.apply(this, arguments);
     return new Hash(obj);
   },
</PRE><PRE>   toCSS: function() {
     var args = $A(arguments);
     var keys = (args.length === 0) ? Element.Layout.PROPERTIES :
      args.join(' ').split(' ');
     var css = {};
</PRE><PRE>     keys.each( function(key) {
       if (!Element.Layout.PROPERTIES.include(key)) return;
       if (Element.Layout.COMPOSITE_PROPERTIES.include(key)) return;
</PRE><PRE>       var value = this.get(key);
       if (value != null) css[cssNameFor(key)] = value + 'px';
     }, this);
     return css;
   },
</PRE><PRE>   inspect: function() {
     return &quot;#&lt;Element.Layout&gt;&quot;;
   }
 });
</PRE><PRE> Object.extend(Element.Layout, {
   PROPERTIES: $w('height width top left right bottom border-left border-right border-top border-bottom padding-left padding-right padding-top padding-bottom margin-top margin-bottom margin-left margin-right padding-box-width padding-box-height border-box-width border-box-height margin-box-width margin-box-height'),
</PRE><PRE>   COMPOSITE_PROPERTIES: $w('padding-box-width padding-box-height margin-box-width margin-box-height border-box-width border-box-height'),
</PRE><PRE>   COMPUTATIONS: {
     'height': function(element) {
       if (!this._preComputing) this._begin();
</PRE><PRE>       var bHeight = this.get('border-box-height');
       if (bHeight &lt;= 0) {
         if (!this._preComputing) this._end();
         return 0;
       }
</PRE><PRE>       var bTop = this.get('border-top'),
        bBottom = this.get('border-bottom');
</PRE><PRE>       var pTop = this.get('padding-top'),
        pBottom = this.get('padding-bottom');
</PRE><PRE>       if (!this._preComputing) this._end();
</PRE><PRE>       return bHeight - bTop - bBottom - pTop - pBottom;
     },
</PRE><PRE>     'width': function(element) {
       if (!this._preComputing) this._begin();
</PRE><PRE>       var bWidth = this.get('border-box-width');
       if (bWidth &lt;= 0) {
         if (!this._preComputing) this._end();
         return 0;
       }
</PRE><PRE>       var bLeft = this.get('border-left'),
        bRight = this.get('border-right');
</PRE><PRE>       var pLeft = this.get('padding-left'),
        pRight = this.get('padding-right');
</PRE><PRE>       if (!this._preComputing) this._end();
       return bWidth - bLeft - bRight - pLeft - pRight;
     },
</PRE><PRE>     'padding-box-height': function(element) {
       var height = this.get('height'),
        pTop = this.get('padding-top'),
        pBottom = this.get('padding-bottom');
</PRE><PRE>       return height + pTop + pBottom;
     },
</PRE><PRE>     'padding-box-width': function(element) {
       var width = this.get('width'),
        pLeft = this.get('padding-left'),
        pRight = this.get('padding-right');
</PRE><PRE>       return width + pLeft + pRight;
     },
</PRE><PRE>     'border-box-height': function(element) {
       if (!this._preComputing) this._begin();
       var height = element.offsetHeight;
       if (!this._preComputing) this._end();
       return height;
     },
</PRE><PRE>     'border-box-width': function(element) {
       if (!this._preComputing) this._begin();
       var width = element.offsetWidth;
       if (!this._preComputing) this._end();
       return width;
     },
</PRE><PRE>     'margin-box-height': function(element) {
       var bHeight = this.get('border-box-height'),
        mTop = this.get('margin-top'),
        mBottom = this.get('margin-bottom');
</PRE><PRE>       if (bHeight &lt;= 0) return 0;
</PRE><PRE>       return bHeight + mTop + mBottom;
     },
</PRE><PRE>     'margin-box-width': function(element) {
       var bWidth = this.get('border-box-width'),
        mLeft = this.get('margin-left'),
        mRight = this.get('margin-right');
</PRE><PRE>       if (bWidth &lt;= 0) return 0;
</PRE><PRE>       return bWidth + mLeft + mRight;
     },
</PRE><PRE>     'top': function(element) {
       var offset = element.positionedOffset();
       return offset.top;
     },
</PRE><PRE>     'bottom': function(element) {
       var offset = element.positionedOffset(),
        parent = element.getOffsetParent(),
        pHeight = parent.measure('height');
</PRE><PRE>       var mHeight = this.get('border-box-height');
</PRE><PRE>       return pHeight - mHeight - offset.top;
     },
</PRE><PRE>     'left': function(element) {
       var offset = element.positionedOffset();
       return offset.left;
     },
</PRE><PRE>     'right': function(element) {
       var offset = element.positionedOffset(),
        parent = element.getOffsetParent(),
        pWidth = parent.measure('width');
</PRE><PRE>       var mWidth = this.get('border-box-width');
</PRE><PRE>       return pWidth - mWidth - offset.left;
     },
</PRE><PRE>     'padding-top': function(element) {
       return getPixelValue(element, 'paddingTop');
     },
</PRE><PRE>     'padding-bottom': function(element) {
       return getPixelValue(element, 'paddingBottom');
     },
</PRE><PRE>     'padding-left': function(element) {
       return getPixelValue(element, 'paddingLeft');
     },
</PRE><PRE>     'padding-right': function(element) {
       return getPixelValue(element, 'paddingRight');
     },
</PRE><PRE>     'border-top': function(element) {
       return getPixelValue(element, 'borderTopWidth');
     },
</PRE><PRE>     'border-bottom': function(element) {
       return getPixelValue(element, 'borderBottomWidth');
     },
</PRE><PRE>     'border-left': function(element) {
       return getPixelValue(element, 'borderLeftWidth');
     },
</PRE><PRE>     'border-right': function(element) {
       return getPixelValue(element, 'borderRightWidth');
     },
</PRE><PRE>     'margin-top': function(element) {
       return getPixelValue(element, 'marginTop');
     },
</PRE><PRE>     'margin-bottom': function(element) {
       return getPixelValue(element, 'marginBottom');
     },
</PRE><PRE>     'margin-left': function(element) {
       return getPixelValue(element, 'marginLeft');
     },
</PRE><PRE>     'margin-right': function(element) {
       return getPixelValue(element, 'marginRight');
     }
   }
 });
</PRE><PRE> if ('getBoundingClientRect' in document.documentElement) {
   Object.extend(Element.Layout.COMPUTATIONS, {
     'right': function(element) {
       var parent = hasLayout(element.getOffsetParent());
       var rect = element.getBoundingClientRect(),
        pRect = parent.getBoundingClientRect();
</PRE><PRE>       return (pRect.right - rect.right).round();
     },
</PRE><PRE>     'bottom': function(element) {
       var parent = hasLayout(element.getOffsetParent());
       var rect = element.getBoundingClientRect(),
        pRect = parent.getBoundingClientRect();
</PRE><PRE>       return (pRect.bottom - rect.bottom).round();
     }
   });
 }
</PRE><PRE> Element.Offset = Class.create({
   initialize: function(left, top) {
     this.left = left.round();
     this.top  = top.round();
</PRE><PRE>     this[0] = this.left;
     this[1] = this.top;
   },
</PRE><PRE>   relativeTo: function(offset) {
     return new Element.Offset(
       this.left - offset.left,
       this.top  - offset.top
     );
   },
</PRE><PRE>   inspect: function() {
     return &quot;#&lt;Element.Offset left: #{left} top: #{top}&gt;&quot;.interpolate(this);
   },
</PRE><PRE>   toString: function() {
     return &quot;[#{left}, #{top}]&quot;.interpolate(this);
   },
</PRE><PRE>   toArray: function() {
     return [this.left, this.top];
   }
 });
</PRE><PRE> function getLayout(element, preCompute) {
   return new Element.Layout(element, preCompute);
 }
</PRE><PRE> function measure(element, property) {
   return $(element).getLayout().get(property);
 }
</PRE><PRE> function getHeight(element) {
   return Element.getDimensions(element).height;
 }
</PRE><PRE> function getWidth(element) {
   return Element.getDimensions(element).width;
 }
</PRE><PRE> function getDimensions(element) {
   element = $(element);
   var display = Element.getStyle(element, 'display');
</PRE><PRE>   if (display &amp;&amp; display !== 'none') {
     return { width: element.offsetWidth, height: element.offsetHeight };
   }
</PRE><PRE>   var style = element.style;
   var originalStyles = {
     visibility: style.visibility,
     position:   style.position,
     display:    style.display
   };
</PRE><PRE>   var newStyles = {
     visibility: 'hidden',
     display:    'block'
   };
</PRE><PRE>   if (originalStyles.position !== 'fixed')
     newStyles.position = 'absolute';
</PRE><PRE>   Element.setStyle(element, newStyles);
</PRE><PRE>   var dimensions = {
     width:  element.offsetWidth,
     height: element.offsetHeight
   };
</PRE><PRE>   Element.setStyle(element, originalStyles);
</PRE><PRE>   return dimensions;
 }
</PRE><PRE> function getOffsetParent(element) {
   element = $(element);
</PRE><PRE>   if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
     return $(document.body);
</PRE><PRE>   var isInline = (Element.getStyle(element, 'display') === 'inline');
   if (!isInline &amp;&amp; element.offsetParent) return $(element.offsetParent);
</PRE><PRE>   while ((element = element.parentNode) &amp;&amp; element !== document.body) {
     if (Element.getStyle(element, 'position') !== 'static') {
       return isHtml(element) ? $(document.body) : $(element);
     }
   }
</PRE><PRE>   return $(document.body);
 }
</PRE><PRE> function cumulativeOffset(element) {
   element = $(element);
   var valueT = 0, valueL = 0;
   if (element.parentNode) {
     do {
       valueT += element.offsetTop  || 0;
       valueL += element.offsetLeft || 0;
       element = element.offsetParent;
     } while (element);
   }
   return new Element.Offset(valueL, valueT);
 }
</PRE><PRE> function positionedOffset(element) {
   element = $(element);
</PRE><PRE>   var layout = element.getLayout();
</PRE><PRE>   var valueT = 0, valueL = 0;
   do {
     valueT += element.offsetTop  || 0;
     valueL += element.offsetLeft || 0;
     element = element.offsetParent;
     if (element) {
       if (isBody(element)) break;
       var p = Element.getStyle(element, 'position');
       if (p !== 'static') break;
     }
   } while (element);
</PRE><PRE>   valueL -= layout.get('margin-top');
   valueT -= layout.get('margin-left');
</PRE><PRE>   return new Element.Offset(valueL, valueT);
 }
</PRE><PRE> function cumulativeScrollOffset(element) {
   var valueT = 0, valueL = 0;
   do {
     if (element === document.body) {
       var bodyScrollNode = document.documentElement || document.body.parentNode || document.body;
       valueT += !Object.isUndefined(window.pageYOffset) ? window.pageYOffset : bodyScrollNode.scrollTop || 0;
       valueL += !Object.isUndefined(window.pageXOffset) ? window.pageXOffset : bodyScrollNode.scrollLeft || 0;
       break;
     } else {
       valueT += element.scrollTop  || 0;
       valueL += element.scrollLeft || 0;
       element = element.parentNode;
     }
   } while (element);
   return new Element.Offset(valueL, valueT);
 }
</PRE><PRE> function viewportOffset(forElement) {
   var valueT = 0, valueL = 0, docBody = document.body;
</PRE><PRE>   forElement = $(forElement);
   var element = forElement;
   do {
     valueT += element.offsetTop  || 0;
     valueL += element.offsetLeft || 0;
     if (element.offsetParent == docBody &amp;&amp;
       Element.getStyle(element, 'position') == 'absolute') break;
   } while (element = element.offsetParent);
</PRE><PRE>   element = forElement;
   do {
     if (element != docBody) {
       valueT -= element.scrollTop  || 0;
       valueL -= element.scrollLeft || 0;
     }
   } while (element = element.parentNode);
   return new Element.Offset(valueL, valueT);
 }
</PRE><PRE> function absolutize(element) {
   element = $(element);
</PRE><PRE>   if (Element.getStyle(element, 'position') === 'absolute') {
     return element;
   }
</PRE><PRE>   var offsetParent = getOffsetParent(element);
   var eOffset = element.viewportOffset(),
    pOffset = offsetParent.viewportOffset();
</PRE><PRE>   var offset = eOffset.relativeTo(pOffset);
   var layout = element.getLayout();
</PRE><PRE>   element.store('prototype_absolutize_original_styles', {
     position: element.getStyle('position'),
     left:     element.getStyle('left'),
     top:      element.getStyle('top'),
     width:    element.getStyle('width'),
     height:   element.getStyle('height')
   });
</PRE><PRE>   element.setStyle({
     position: 'absolute',
     top:    offset.top + 'px',
     left:   offset.left + 'px',
     width:  layout.get('width') + 'px',
     height: layout.get('height') + 'px'
   });
</PRE><PRE>   return element;
 }
</PRE><PRE> function relativize(element) {
   element = $(element);
   if (Element.getStyle(element, 'position') === 'relative') {
     return element;
   }
</PRE><PRE>   var originalStyles =
    element.retrieve('prototype_absolutize_original_styles');
</PRE><PRE>   if (originalStyles) element.setStyle(originalStyles);
   return element;
 }
</PRE><PRE> function scrollTo(element) {
   element = $(element);
   var pos = Element.cumulativeOffset(element);
   window.scrollTo(pos.left, pos.top);
   return element;
 }
</PRE><PRE> function makePositioned(element) {
   element = $(element);
   var position = Element.getStyle(element, 'position'), styles = {};
   if (position === 'static' || !position) {
     styles.position = 'relative';
     if (Prototype.Browser.Opera) {
       styles.top  = 0;
       styles.left = 0;
     }
     Element.setStyle(element, styles);
     Element.store(element, 'prototype_made_positioned', true);
   }
   return element;
 }
</PRE><PRE> function undoPositioned(element) {
   element = $(element);
   var storage = Element.getStorage(element),
    madePositioned = storage.get('prototype_made_positioned');
</PRE><PRE>   if (madePositioned) {
     storage.unset('prototype_made_positioned');
     Element.setStyle(element, {
       position: <I>,</I>
       top:      <I>,</I>
       bottom:   <I>,</I>
       left:     <I>,</I>
       right:    
     });
   }
   return element;
 }
</PRE><PRE> function makeClipping(element) {
   element = $(element);
</PRE><PRE>   var storage = Element.getStorage(element),
    madeClipping = storage.get('prototype_made_clipping');
</PRE><PRE>   if (Object.isUndefined(madeClipping)) {
     var overflow = Element.getStyle(element, 'overflow');
     storage.set('prototype_made_clipping', overflow);
     if (overflow !== 'hidden')
       element.style.overflow = 'hidden';
   }
</PRE><PRE>   return element;
 }
</PRE><PRE> function undoClipping(element) {
   element = $(element);
   var storage = Element.getStorage(element),
    overflow = storage.get('prototype_made_clipping');
</PRE><PRE>   if (!Object.isUndefined(overflow)) {
     storage.unset('prototype_made_clipping');
     element.style.overflow = overflow || <I>;</I>
   }
</PRE><PRE>   return element;
 }
</PRE><PRE> function clonePosition(element, source, options) {
   options = Object.extend({
     setLeft:    true,
     setTop:     true,
     setWidth:   true,
     setHeight:  true,
     offsetTop:  0,
     offsetLeft: 0
   }, options || {});
</PRE><PRE>   source  = $(source);
   element = $(element);
   var p, delta, layout, styles = {};
</PRE><PRE>   if (options.setLeft || options.setTop) {
     p = Element.viewportOffset(source);
     delta = [0, 0];
     if (Element.getStyle(element, 'position') === 'absolute') {
       var parent = Element.getOffsetParent(element);
       if (parent !== document.body) delta = Element.viewportOffset(parent);
     }
   }
</PRE><PRE>   if (options.setWidth || options.setHeight) {
     layout = Element.getLayout(source);
   }
</PRE><PRE>   if (options.setLeft)
     styles.left = (p[0] - delta[0] + options.offsetLeft) + 'px';
   if (options.setTop)
     styles.top  = (p[1] - delta[1] + options.offsetTop)  + 'px';
</PRE><PRE>   if (options.setWidth)
     styles.width  = layout.get('border-box-width')  + 'px';
   if (options.setHeight)
     styles.height = layout.get('border-box-height') + 'px';
</PRE><PRE>   return Element.setStyle(element, styles);
 }
</PRE><PRE> if (Prototype.Browser.IE) {
   getOffsetParent = getOffsetParent.wrap(
     function(proceed, element) {
       element = $(element);
</PRE><PRE>       if (isDocument(element) || isDetached(element) || isBody(element) || isHtml(element))
         return $(document.body);
</PRE><PRE>       var position = element.getStyle('position');
       if (position !== 'static') return proceed(element);
</PRE><PRE>       element.setStyle({ position: 'relative' });
       var value = proceed(element);
       element.setStyle({ position: position });
       return value;
     }
   );
</PRE><PRE>   positionedOffset = positionedOffset.wrap(function(proceed, element) {
     element = $(element);
     if (!element.parentNode) return new Element.Offset(0, 0);
     var position = element.getStyle('position');
     if (position !== 'static') return proceed(element);
</PRE><PRE>     var offsetParent = element.getOffsetParent();
     if (offsetParent &amp;&amp; offsetParent.getStyle('position') === 'fixed')
       hasLayout(offsetParent);
</PRE><PRE>     element.setStyle({ position: 'relative' });
     var value = proceed(element);
     element.setStyle({ position: position });
     return value;
   });
 } else if (Prototype.Browser.Webkit) {
   cumulativeOffset = function(element) {
     element = $(element);
     var valueT = 0, valueL = 0;
     do {
       valueT += element.offsetTop  || 0;
       valueL += element.offsetLeft || 0;
       if (element.offsetParent == document.body) {
         if (Element.getStyle(element, 'position') == 'absolute') break;
       }
</PRE><PRE>       element = element.offsetParent;
     } while (element);
</PRE><PRE>     return new Element.Offset(valueL, valueT);
   };
 }
</PRE><PRE> Element.addMethods({
   getLayout:              getLayout,
   measure:                measure,
   getWidth:               getWidth,
   getHeight:              getHeight,
   getDimensions:          getDimensions,
   getOffsetParent:        getOffsetParent,
   cumulativeOffset:       cumulativeOffset,
   positionedOffset:       positionedOffset,
   cumulativeScrollOffset: cumulativeScrollOffset,
   viewportOffset:         viewportOffset,
   absolutize:             absolutize,
   relativize:             relativize,
   scrollTo:               scrollTo,
   makePositioned:         makePositioned,
   undoPositioned:         undoPositioned,
   makeClipping:           makeClipping,
   undoClipping:           undoClipping,
   clonePosition:          clonePosition
 });
</PRE><PRE> function isBody(element) {
   return element.nodeName.toUpperCase() === 'BODY';
 }
</PRE><PRE> function isHtml(element) {
   return element.nodeName.toUpperCase() === 'HTML';
 }
</PRE><PRE> function isDocument(element) {
   return element.nodeType === Node.DOCUMENT_NODE;
 }
</PRE><PRE> function isDetached(element) {
   return element !== document.body &amp;&amp; !Element.descendantOf(element, document.body);
 }
</PRE><PRE> if ('getBoundingClientRect' in document.documentElement) {
   Element.addMethods({
     viewportOffset: function(element) {
       element = $(element);
       if (isDetached(element)) return new Element.Offset(0, 0);
</PRE><PRE>       var rect = element.getBoundingClientRect(),
        docEl = document.documentElement;
       return new Element.Offset(rect.left - docEl.clientLeft,
        rect.top - docEl.clientTop);
     }
   });
 }
</PRE><P>
})();
</P><P>(function() {
</P><PRE> var IS_OLD_OPERA = Prototype.Browser.Opera &amp;&amp;
  (window.parseFloat(window.opera.version()) &lt; 9.5);
 var ROOT = null;
 function getRootElement() {
   if (ROOT) return ROOT;
   ROOT = IS_OLD_OPERA ? document.body : document.documentElement;
   return ROOT;
 }
</PRE><PRE> function getDimensions() {
   return { width: this.getWidth(), height: this.getHeight() };
 }
</PRE><PRE> function getWidth() {
   return getRootElement().clientWidth;
 }
</PRE><PRE> function getHeight() {
   return getRootElement().clientHeight;
 }
</PRE><PRE> function getScrollOffsets() {
   var x = window.pageXOffset || document.documentElement.scrollLeft ||
    document.body.scrollLeft;
   var y = window.pageYOffset || document.documentElement.scrollTop ||
    document.body.scrollTop;
</PRE><PRE>   return new Element.Offset(x, y);
 }
</PRE><PRE> document.viewport = {
   getDimensions:    getDimensions,
   getWidth:         getWidth,
   getHeight:        getHeight,
   getScrollOffsets: getScrollOffsets
 };
</PRE><P>})();
window.$$ = function() {
</P><PRE> var expression = $A(arguments).join(', ');
 return Prototype.Selector.select(expression, document);
</PRE><P>};
</P><P>Prototype.Selector = (function() {
</P><PRE> function select() {
   throw new Error('Method &quot;Prototype.Selector.select&quot; must be defined.');
 }
</PRE><PRE> function match() {
   throw new Error('Method &quot;Prototype.Selector.match&quot; must be defined.');
 }
</PRE><PRE> function find(elements, expression, index) {
   index = index || 0;
   var match = Prototype.Selector.match, length = elements.length, matchIndex = 0, i;
</PRE><PRE>   for (i = 0; i &lt; length; i++) {
     if (match(elements[i], expression) &amp;&amp; index == matchIndex++) {
       return Element.extend(elements[i]);
     }
   }
 }
</PRE><PRE> function extendElements(elements) {
   for (var i = 0, length = elements.length; i &lt; length; i++) {
     Element.extend(elements[i]);
   }
   return elements;
 }
</PRE><PRE> var K = Prototype.K;
</PRE><PRE> return {
   select: select,
   match: match,
   find: find,
   extendElements: (Element.extend === K) ? K : extendElements,
   extendElement: Element.extend
 };
</PRE><P>})();
Prototype._original_property = window.Sizzle;
/*!
</P><PRE>* Sizzle CSS Selector Engine v@VERSION
* <A rel="nofollow" class="external free" href="http://sizzlejs.com/">http://sizzlejs.com/</A>
*
* Copyright 2013 jQuery Foundation, Inc. and other contributors
* Released under the MIT license
* <A rel="nofollow" class="external free" href="http://jquery.org/license">http://jquery.org/license</A>
*
* Date: @DATE
*/
</PRE><P>(function( window ) {
</P><P>var i,
	support,
	Expr,
	getText,
	isXML,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,
</P><P>	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,
</P><P>	expando = &quot;sizzle&quot; + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},
</P><P>	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 &lt;&lt; 31,
</P><P>	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i &lt; len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},
</P><P>	booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,
</P><P>
	whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,
	characterEncoding = &quot;(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+&quot;,
</P><P>	identifier = characterEncoding.replace( &quot;w&quot;, &quot;w#&quot; ),
</P><P>	attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + characterEncoding + &quot;)&quot; + whitespace +
		&quot;*(?:([*^$|!~]?=)&quot; + whitespace + &quot;*(?:(['\&quot;])((?:\\\\.|[^\\\\])*?)\\3|(&quot; + identifier + &quot;)|)|)&quot; + whitespace + &quot;*\\]&quot;,
</P><P>	pseudos = &quot;:(&quot; + characterEncoding + &quot;)(?:\\(((['\&quot;])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes.replace( 3, 8 ) + &quot;)*)|.*)\\)|)&quot;,
</P><P>	rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),
</P><P>	rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
	rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace + &quot;)&quot; + whitespace + &quot;*&quot; ),
</P><P>	rattributeQuotes = new RegExp( &quot;=&quot; + whitespace + &quot;*([^\\]'\&quot;]*?)&quot; + whitespace + &quot;*\\]&quot;, &quot;g&quot; ),
</P><P>	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),
</P><P>	matchExpr = {
		&quot;ID&quot;: new RegExp( &quot;^#(&quot; + characterEncoding + &quot;)&quot; ),
		&quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + characterEncoding + &quot;)&quot; ),
		&quot;TAG&quot;: new RegExp( &quot;^(&quot; + characterEncoding.replace( &quot;w&quot;, &quot;w*&quot; ) + &quot;)&quot; ),
		&quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
		&quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
		&quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
			&quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
			&quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
		&quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
		&quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
			whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
	},
</P><P>	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,
</P><P>	rnative = /^[^{]+\{\s*\[native \w/,
</P><P>	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
</P><P>	rsibling = /[+~]/,
	rescape = /'|\\/g,
</P><P>	runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = &quot;0x&quot; + escaped - 0x10000;
		return high !== high || escapedWhitespace ?
			escaped :
			high &lt; 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
	};
</P><P>try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?
</P><P>		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :
</P><P>		function( target, els ) {
			var j = target.length,
				i = 0;
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}
</P><P>function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		i, groups, old, nid, newContext, newSelector;
</P><P>	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}
</P><P>	context = context || document;
	results = results || [];
</P><P>	if ( !selector || typeof selector !== &quot;string&quot; ) {
		return results;
	}
</P><P>	if ( (nodeType = context.nodeType) !== 1 &amp;&amp; nodeType !== 9 ) {
		return [];
	}
</P><P>	if ( documentIsHTML &amp;&amp; !seed ) {
</P><P>		if ( (match = rquickExpr.exec( selector )) ) {
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					if ( elem &amp;&amp; elem.parentNode ) {
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					if ( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp;
						contains( context, elem ) &amp;&amp; elem.id === m ) {
						results.push( elem );
						return results;
					}
				}
</P><P>			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;
</P><P>			} else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp; context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}
</P><P>		if ( support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 &amp;&amp; selector;
</P><P>			if ( nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot; ) {
				groups = tokenize( selector );
</P><P>				if ( (old = context.getAttribute(&quot;id&quot;)) ) {
					nid = old.replace( rescape, &quot;\\$&amp;&quot; );
				} else {
					context.setAttribute( &quot;id&quot;, nid );
				}
				nid = &quot;[id='&quot; + nid + &quot;'] &quot;;
</P><P>				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context;
				newSelector = groups.join(&quot;,&quot;);
			}
</P><P>			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute(&quot;id&quot;);
					}
				}
			}
		}
	}
</P><P>	return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );
}
</P><P>/**
</P><PRE>* Create key-value caches of limited size
* @returns {Function(string, Object)} Returns the Object data after storing it on itself with
*	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
*	deleting the oldest entry
*/
</PRE><P>function createCache() {
	var keys = [];
</P><P>	function cache( key, value ) {
		if ( keys.push( key + &quot; &quot; ) &gt; Expr.cacheLength ) {
			delete cache[ keys.shift() ];
		}
		return (cache[ key + &quot; &quot; ] = value);
	}
	return cache;
}
</P><P>/**
</P><PRE>* Mark a function for special use by Sizzle
* @param {Function} fn The function to mark
*/
</PRE><P>function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}
</P><P>/**
</P><PRE>* Support testing using an element
* @param {Function} fn Passed the created div and expects a boolean result
*/
</PRE><P>function assert( fn ) {
	var div = document.createElement(&quot;div&quot;);
</P><P>	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		div = null;
	}
}
</P><P>/**
</P><PRE>* Adds the same handler for all of the specified attrs
* @param {String} attrs Pipe-separated list of attributes
* @param {Function} handler The method that will be applied
*/
</PRE><P>function addHandle( attrs, handler ) {
	var arr = attrs.split(&quot;|&quot;),
		i = attrs.length;
</P><P>	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}
</P><P>/**
</P><PRE>* Checks document order of two siblings
* @param {Element} a
* @param {Element} b
* @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
*/
</PRE><P>function siblingCheck( a, b ) {
	var cur = b &amp;&amp; a,
		diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );
</P><P>	if ( diff ) {
		return diff;
	}
</P><P>	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}
</P><P>	return a ? 1 : -1;
}
</P><P>/**
</P><PRE>* Returns a function to use in pseudos for input types
* @param {String} type
*/
</PRE><P>function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === &quot;input&quot; &amp;&amp; elem.type === type;
	};
}
</P><P>/**
</P><PRE>* Returns a function to use in pseudos for buttons
* @param {String} type
*/
</PRE><P>function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
	};
}
</P><P>/**
</P><PRE>* Returns a function to use in pseudos for positionals
* @param {Function} fn
*/
</PRE><P>function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;
</P><P>			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}
</P><P>/**
</P><PRE>* Checks a node for validity as a Sizzle context
* @param {Element|Object=} context
* @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
*/
</PRE><P>function testContext( context ) {
	return context &amp;&amp; typeof context.getElementsByTagName !== strundefined &amp;&amp; context;
}
</P><P>support = Sizzle.support = {};
</P><P>/**
</P><PRE>* Detects XML nodes
* @param {Element|Object} elem An element or a document
* @returns {Boolean} True iff elem is a non-HTML XML node
*/
</PRE><P>isXML = Sizzle.isXML = function( elem ) {
	var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
};
</P><P>/**
</P><PRE>* Sets document-related variables once based on the current document
* @param {Element|Object} [doc] An element or document object to use to set the document
* @returns {Object} Returns the current document
*/
</PRE><P>setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;
</P><P>	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}
</P><P>	document = doc;
	docElem = doc.documentElement;
</P><P>	documentIsHTML = !isXML( doc );
</P><P>	if ( parent &amp;&amp; parent !== parent.top ) {
		if ( parent.addEventListener ) {
			parent.addEventListener( &quot;unload&quot;, function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( &quot;onunload&quot;, function() {
				setDocument();
			});
		}
	}
</P><P>	/* Attributes
	---------------------------------------------------------------------- */
</P><P>	support.attributes = assert(function( div ) {
		div.className = &quot;i&quot;;
		return !div.getAttribute(&quot;className&quot;);
	});
</P><P>	/* getElement(s)By*
	---------------------------------------------------------------------- */
</P><P>	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment(&quot;&quot;) );
		return !div.getElementsByTagName(&quot;*&quot;).length;
	});
</P><P>	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) &amp;&amp; assert(function( div ) {
</P>
		div.innerHTML = &quot;&quot;;
<P>		div.firstChild.className = &quot;i&quot;;
		return div.getElementsByClassName(&quot;i&quot;).length === 2;
	});
</P><P>	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});
</P><P>	if ( support.getById ) {
		Expr.find[&quot;ID&quot;] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined &amp;&amp; documentIsHTML ) {
				var m = context.getElementById( id );
				return m &amp;&amp; m.parentNode ? [m] : [];
			}
		};
		Expr.filter[&quot;ID&quot;] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute(&quot;id&quot;) === attrId;
			};
		};
	} else {
		delete Expr.find[&quot;ID&quot;];
</P><P>		Expr.filter[&quot;ID&quot;] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(&quot;id&quot;);
				return node &amp;&amp; node.value === attrId;
			};
		};
	}
</P><P>	Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );
</P><P>			if ( tag === &quot;*&quot; ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}
</P><P>				return tmp;
			}
			return results;
		};
</P><P>	Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined &amp;&amp; documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};
</P><P>	/* QSA/matchesSelector
	---------------------------------------------------------------------- */
</P><P>
	rbuggyMatches = [];
</P><P>	rbuggyQSA = [];
</P><P>	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		assert(function( div ) {
			div.innerHTML = &quot;&lt;select t=<I>&gt;&lt;option selected=</I>&gt;&lt;/option&gt;&lt;/select&gt;&quot;;
</P><P>			if ( div.querySelectorAll(&quot;[t^=<I>]&quot;).length ) {</I>
				rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:<I>|\&quot;\&quot;)&quot; );</I>
			}
</P><P>			if ( !div.querySelectorAll(&quot;[selected]&quot;).length ) {
				rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; );
			}
</P><P>			if ( !div.querySelectorAll(&quot;:checked&quot;).length ) {
				rbuggyQSA.push(&quot;:checked&quot;);
			}
		});
</P><P>		assert(function( div ) {
			var input = doc.createElement(&quot;input&quot;);
			input.setAttribute( &quot;type&quot;, &quot;hidden&quot; );
			div.appendChild( input ).setAttribute( &quot;name&quot;, &quot;D&quot; );
</P><P>			if ( div.querySelectorAll(&quot;[name=d]&quot;).length ) {
				rbuggyQSA.push( &quot;name&quot; + whitespace + &quot;*[*^$|!~]?=&quot; );
			}
</P><P>			if ( !div.querySelectorAll(&quot;:enabled&quot;).length ) {
				rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
			}
</P><P>			div.querySelectorAll(&quot;*,:x&quot;);
			rbuggyQSA.push(&quot;,.*:&quot;);
		});
	}
</P><P>	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {
</P><P>		assert(function( div ) {
			support.disconnectedMatch = matches.call( div, &quot;div&quot; );
</P><P>			matches.call( div, &quot;[s!=<I>]:x&quot; );</I>
			rbuggyMatches.push( &quot;!=&quot;, pseudos );
		});
	}
</P><P>	rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) );
	rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );
</P><P>	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );
</P><P>	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b &amp;&amp; b.parentNode;
			return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};
</P><P>	/* Sorting
	---------------------------------------------------------------------- */
</P><P>	sortOrder = hasCompare ?
	function( a, b ) {
</P><P>		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
</P><P>		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}
</P><P>		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :
</P><P>			1;
</P><P>		if ( compare &amp; 1 ||
			(!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {
</P><P>			if ( a === doc || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) {
				return 1;
			}
</P><P>			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}
</P><P>		return compare &amp; 4 ? -1 : 1;
	} :
	function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
</P><P>		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];
</P><P>		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
</P><P>		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}
</P><P>		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}
</P><P>		while ( ap[i] === bp[i] ) {
			i++;
		}
</P><P>		return i ?
			siblingCheck( ap[i], bp[i] ) :
</P><P>			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};
</P><P>	return doc;
};
</P><P>Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};
</P><P>Sizzle.matchesSelector = function( elem, expr ) {
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}
</P><P>	expr = expr.replace( rattributeQuotes, &quot;='$1']&quot; );
</P><P>	if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
</P><P>		try {
			var ret = matches.call( elem, expr );
</P><P>			if ( ret || support.disconnectedMatch ||
					elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}
</P><P>	return Sizzle( expr, document, null, [elem] ).length &gt; 0;
};
</P><P>Sizzle.contains = function( context, elem ) {
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};
</P><P>Sizzle.attr = function( elem, name ) {
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}
</P><P>	var fn = Expr.attrHandle[ name.toLowerCase() ],
		val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;
</P><P>	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
				val.value :
				null;
};
</P><P>Sizzle.error = function( msg ) {
	throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
};
</P><P>/**
</P><PRE>* Document sorting and removing duplicates
* @param {ArrayLike} results
*/
</PRE><P>Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;
</P><P>	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable &amp;&amp; results.slice( 0 );
	results.sort( sortOrder );
</P><P>	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}
</P><P>	sortInput = null;
</P><P>	return results;
};
</P><P>/**
</P><PRE>* Utility function for retrieving the text value of an array of DOM nodes
* @param {Array|Element} elem
*/
</PRE><P>getText = Sizzle.getText = function( elem ) {
	var node,
		ret = &quot;&quot;,
		i = 0,
		nodeType = elem.nodeType;
</P><P>	if ( !nodeType ) {
		while ( (node = elem[i++]) ) {
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		if ( typeof elem.textContent === &quot;string&quot; ) {
			return elem.textContent;
		} else {
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
</P><P>	return ret;
};
</P><P>Expr = Sizzle.selectors = {
</P><P>	cacheLength: 50,
</P><P>	createPseudo: markFunction,
</P><P>	match: matchExpr,
</P><P>	attrHandle: {},
</P><P>	find: {},
</P><P>	relative: {
		&quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
		&quot; &quot;: { dir: &quot;parentNode&quot; },
		&quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
		&quot;~&quot;: { dir: &quot;previousSibling&quot; }
	},
</P><P>	preFilter: {
		&quot;ATTR&quot;: function( match ) {
			match[1] = match[1].replace( runescape, funescape );
</P><P>			match[3] = ( match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );
</P><P>			if ( match[2] === &quot;~=&quot; ) {
				match[3] = &quot; &quot; + match[3] + &quot; &quot;;
			}
</P><P>			return match.slice( 0, 4 );
		},
</P><P>		&quot;CHILD&quot;: function( match ) {
			/* matches from matchExpr[&quot;CHILD&quot;]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();
</P><P>			if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) {
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}
</P><P>				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; );
</P><P>			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}
</P><P>			return match;
		},
</P><P>		&quot;PSEUDO&quot;: function( match ) {
			var excess,
				unquoted = !match[5] &amp;&amp; match[2];
</P><P>			if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
				return null;
			}
</P><P>			if ( match[3] &amp;&amp; match[4] !== undefined ) {
				match[2] = match[4];
</P><P>			} else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
				(excess = tokenize( unquoted, true )) &amp;&amp;
				(excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {
</P><P>				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}
</P><P>			return match.slice( 0, 3 );
		}
	},
</P><P>	filter: {
</P><P>		&quot;TAG&quot;: function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === &quot;*&quot; ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
				};
		},
</P><P>		&quot;CLASS&quot;: function( className ) {
			var pattern = classCache[ className + &quot; &quot; ];
</P><P>			return pattern ||
				(pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; );
				});
		},
</P><P>		&quot;ATTR&quot;: function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );
</P><P>				if ( result == null ) {
					return operator === &quot;!=&quot;;
				}
				if ( !operator ) {
					return true;
				}
</P><P>				result += &quot;&quot;;
</P><P>				return operator === &quot;=&quot; ? result === check :
					operator === &quot;!=&quot; ? result !== check :
					operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
					operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
					operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check :
					operator === &quot;~=&quot; ? ( &quot; &quot; + result + &quot; &quot; ).indexOf( check ) &gt; -1 :
					operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; :
					false;
			};
		},
</P><P>		&quot;CHILD&quot;: function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== &quot;nth&quot;,
				forward = type.slice( -4 ) !== &quot;last&quot;,
				ofType = what === &quot;of-type&quot;;
</P><P>			return first === 1 &amp;&amp; last === 0 ?
</P><P>				function( elem ) {
					return !!elem.parentNode;
				} :
</P><P>				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
						parent = elem.parentNode,
						name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
						useCache = !xml &amp;&amp; !ofType;
</P><P>					if ( parent ) {
</P><P>						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
							}
							return true;
						}
</P><P>						start = [ forward ? parent.firstChild : parent.lastChild ];
</P><P>						if ( forward &amp;&amp; useCache ) {
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
							diff = cache[0] === dirruns &amp;&amp; cache[2];
							node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];
</P><P>							while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
</P><P>								(diff = nodeIndex = 0) || start.pop()) ) {
</P><P>								if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}
</P><P>						} else if ( useCache &amp;&amp; (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) &amp;&amp; cache[0] === dirruns ) {
							diff = cache[1];
</P><P>						} else {
							while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {
</P><P>								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) &amp;&amp; ++diff ) {
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}
</P><P>									if ( node === elem ) {
										break;
									}
								}
							}
						}
</P><P>						diff -= last;
						return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
					}
				};
		},
</P><P>		&quot;PSEUDO&quot;: function( pseudo, argument ) {
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );
</P><P>			if ( fn[ expando ] ) {
				return fn( argument );
			}
</P><P>			if ( fn.length &gt; 1 ) {
				args = [ pseudo, pseudo, &quot;&quot;, argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}
</P><P>			return fn;
		}
	},
</P><P>	pseudos: {
		&quot;not&quot;: markFunction(function( selector ) {
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );
</P><P>			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;
</P><P>					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),
</P><P>		&quot;has&quot;: markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length &gt; 0;
			};
		}),
</P><P>		&quot;contains&quot;: markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
			};
		}),
</P><P>		&quot;lang&quot;: markFunction( function( lang ) {
			if ( !ridentifier.test(lang || &quot;&quot;) ) {
				Sizzle.error( &quot;unsupported lang: &quot; + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) {
</P><P>						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0;
					}
				} while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );
				return false;
			};
		}),
</P><P>		&quot;target&quot;: function( elem ) {
			var hash = window.location &amp;&amp; window.location.hash;
			return hash &amp;&amp; hash.slice( 1 ) === elem.id;
		},
</P><P>		&quot;root&quot;: function( elem ) {
			return elem === docElem;
		},
</P><P>		&quot;focus&quot;: function( elem ) {
			return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
		},
</P><P>		&quot;enabled&quot;: function( elem ) {
			return elem.disabled === false;
		},
</P><P>		&quot;disabled&quot;: function( elem ) {
			return elem.disabled === true;
		},
</P><P>		&quot;checked&quot;: function( elem ) {
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
		},
</P><P>		&quot;selected&quot;: function( elem ) {
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
</P><P>			return elem.selected === true;
		},
</P><P>		&quot;empty&quot;: function( elem ) {
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType &lt; 6 ) {
					return false;
				}
			}
			return true;
		},
</P><P>		&quot;parent&quot;: function( elem ) {
			return !Expr.pseudos[&quot;empty&quot;]( elem );
		},
</P><P>		&quot;header&quot;: function( elem ) {
			return rheader.test( elem.nodeName );
		},
</P><P>		&quot;input&quot;: function( elem ) {
			return rinputs.test( elem.nodeName );
		},
</P><P>		&quot;button&quot;: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
		},
</P><P>		&quot;text&quot;: function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
				elem.type === &quot;text&quot; &amp;&amp;</P><P>				( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === &quot;text&quot; );
		},
</P><P>		&quot;first&quot;: createPositionalPseudo(function() {
			return [ 0 ];
		}),
</P><P>		&quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),
</P><P>		&quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument &lt; 0 ? argument + length : argument ];
		}),
</P><P>		&quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i &lt; length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),
</P><P>		&quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i &lt; length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),
</P><P>		&quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument &lt; 0 ? argument + length : argument;
			for ( ; --i &gt;= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),
</P><P>		&quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument &lt; 0 ? argument + length : argument;
			for ( ; ++i &lt; length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};
</P><P>Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];
</P><P>for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}
</P><P>function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();
</P><P>function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + &quot; &quot; ];
</P><P>	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}
</P><P>	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;
</P><P>	while ( soFar ) {
</P><P>		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}
</P><P>		matched = false;
</P><P>		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				type: match[0].replace( rtrim, &quot; &quot; )
			});
			soFar = soFar.slice( matched.length );
		}
</P><P>		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}
</P><P>		if ( !matched ) {
			break;
		}
	}
</P><P>	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			tokenCache( selector, groups ).slice( 0 );
}
</P><P>function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = &quot;&quot;;
	for ( ; i &lt; len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}
</P><P>function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base &amp;&amp; dir === &quot;parentNode&quot;,
		doneName = done++;
</P><P>	return combinator.first ?
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :
</P><P>		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];
</P><P>			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &amp;&amp;
							oldCache[ 0 ] === dirruns &amp;&amp; oldCache[ 1 ] === doneName ) {
</P><P>							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							outerCache[ dir ] = newCache;
</P><P>							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}
</P><P>function elementMatcher( matchers ) {
	return matchers.length &gt; 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}
</P><P>function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i &lt; len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}
</P><P>function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;
</P><P>	for ( ; i &lt; len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}
</P><P>	return newUnmatched;
}
</P><P>function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,
</P><P>			elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),
</P><P>			matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,
</P><P>			matcherOut = matcher ?
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
</P><P>					[] :
</P><P>					results :
				matcherIn;
</P><P>		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}
</P><P>		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );
</P><P>			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}
</P><P>		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}
</P><P>				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &amp;&amp;
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) &gt; -1 ) {
</P><P>						seed[temp] = !(results[temp] = elem);
					}
				}
			}
</P><P>		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}
</P><P>function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
		i = leadingRelative ? 1 : 0,
</P><P>		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) &gt; -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];
</P><P>	for ( ; i &lt; len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
</P><P>			if ( matcher[ expando ] ) {
				j = ++i;
				for ( ; j &lt; len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i &gt; 1 &amp;&amp; elementMatcher( matchers ),
					i &gt; 1 &amp;&amp; toSelector(
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
					).replace( rtrim, &quot;$1&quot; ),
					matcher,
					i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
					j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
					j &lt; len &amp;&amp; toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}
</P><P>	return elementMatcher( matchers );
}
</P><P>function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length &gt; 0,
		byElement = elementMatchers.length &gt; 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = &quot;0&quot;,
				unmatched = seed &amp;&amp; [],
				setMatched = [],
				contextBackup = outermostContext,
				elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, outermost ),
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;
</P><P>			if ( outermost ) {
				outermostContext = context !== document &amp;&amp; context;
			}
</P><P>			for ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) {
				if ( byElement &amp;&amp; elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}
</P><P>				if ( bySet ) {
					if ( (elem = !matcher &amp;&amp; elem) ) {
						matchedCount--;
					}
</P><P>					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}
</P><P>			matchedCount += i;
			if ( bySet &amp;&amp; i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}
</P><P>				if ( seed ) {
					if ( matchedCount &gt; 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}
</P><P>					setMatched = condense( setMatched );
				}</P><P>				push.apply( results, setMatched );
</P><P>				if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
					( matchedCount + setMatchers.length ) &gt; 1 ) {
</P><P>					Sizzle.uniqueSort( results );
				}
			}
</P><P>			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}
</P><P>			return unmatched;
		};
</P><P>	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}
</P><P>compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + &quot; &quot; ];
</P><P>	if ( !cached ) {
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}
</P><P>		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
</P><P>		cached.selector = selector;
	}
	return cached;
};
</P><P>/**
</P><PRE>* A low-level selection function that works with Sizzle's compiled
*  selector functions
* @param {String|Function} selector A selector or a pre-compiled
*  selector function built with Sizzle.compile
* @param {Element} context
* @param {Array} [results]
* @param {Array} [seed] A set of elements to match against
*/
</PRE><P>select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === &quot;function&quot; &amp;&amp; selector,
		match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) );
</P><P>	results = results || [];
</P><P>	if ( match.length === 1 ) {
</P><P>		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
				support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp;
				Expr.relative[ tokens[1].type ] ) {
</P><P>			context = ( Expr.find[&quot;ID&quot;]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;
</P><P>			} else if ( compiled ) {
				context = context.parentNode;
			}
</P><P>			selector = selector.slice( tokens.shift().value.length );
		}
</P><P>		i = matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];
</P><P>			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context
				)) ) {
</P><P>					tokens.splice( i, 1 );
					selector = seed.length &amp;&amp; toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}
</P><P>					break;
				}
			}
		}
	}
</P><P>	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context
	);
	return results;
};
</P><P>
support.sortStable = expando.split(&quot;&quot;).sort( sortOrder ).join(&quot;&quot;) === expando;
</P><P>support.detectDuplicates = !!hasDuplicate;
</P><P>setDocument();
</P><P>support.sortDetached = assert(function( div1 ) {
	return div1.compareDocumentPosition( document.createElement(&quot;div&quot;) ) &amp; 1;
});
</P><P>if ( !assert(function( div ) {
	div.innerHTML = &quot;&lt;a href='#'&gt;&lt;/a&gt;&quot;;
	return div.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot; ;
}) ) {
	addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === &quot;type&quot; ? 1 : 2 );
		}
	});
}
</P><P>if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = &quot;&lt;input/&gt;&quot;;
	div.firstChild.setAttribute( &quot;value&quot;, &quot;&quot; );
	return div.firstChild.getAttribute( &quot;value&quot; ) === &quot;&quot;;
}) ) {
	addHandle( &quot;value&quot;, function( elem, name, isXML ) {
		if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot; ) {
			return elem.defaultValue;
		}
	});
}
</P><P>if ( !assert(function( div ) {
	return div.getAttribute(&quot;disabled&quot;) == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?
					val.value :
				null;
		}
	});
}
</P><P>if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
	define(function() { return Sizzle; });
} else if ( typeof module !== &quot;undefined&quot; &amp;&amp; module.exports ) {
	module.exports = Sizzle;
} else {
	window.Sizzle = Sizzle;
}
</P><P>})( window );
</P><DL><DT>(function(engine) {</DT></DL><PRE> var extendElements = Prototype.Selector.extendElements;
</PRE><PRE> function select(selector, scope) {
   return extendElements(engine(selector, scope || document));
 }
</PRE><PRE> function match(element, selector) {
   return engine.matches(selector, [element]).length == 1;
 }
</PRE><PRE> Prototype.Selector.engine = engine;
 Prototype.Selector.select = select;
 Prototype.Selector.match = match;
</PRE><P>})(Sizzle);
</P><P>window.Sizzle = Prototype._original_property;
delete Prototype._original_property;
</P><P>var Form = {
</P><PRE> reset: function(form) {
   form = $(form);
   form.reset();
   return form;
 },
</PRE><PRE> serializeElements: function(elements, options) {
   if (typeof options != 'object') options = { hash: !!options };
   else if (Object.isUndefined(options.hash)) options.hash = true;
   var key, value, submitted = false, submit = options.submit, accumulator, initial;
</PRE><PRE>   if (options.hash) {
     initial = {};
     accumulator = function(result, key, value) {
       if (key in result) {
         if (!Object.isArray(result[key])) result[key] = [result[key]];
         result[key] = result[key].concat(value);
       } else result[key] = value;
       return result;
     };
   } else {
     initial = <I>;</I>
     accumulator = function(result, key, values) {
       if (!Object.isArray(values)) {values = [values];}
       if (!values.length) {return result;}
       var encodedKey = encodeURIComponent(key).gsub(/%20/, '+');
       return result + (result ? &quot;&amp;&quot; : &quot;&quot;) + values.map(function (value) {
         value = value.gsub(/(\r)?\n/, '\r\n');
         value = encodeURIComponent(value);
         value = value.gsub(/%20/, '+');
         return encodedKey + &quot;=&quot; + value;
       }).join(&quot;&amp;&quot;);
     };
   }
</PRE><PRE>   return elements.inject(initial, function(result, element) {
     if (!element.disabled &amp;&amp; element.name) {
       key = element.name; value = $(element).getValue();
       if (value != null &amp;&amp; element.type != 'file' &amp;&amp; (element.type != 'submit' || (!submitted &amp;&amp;
           submit !== false &amp;&amp; (!submit || key == submit) &amp;&amp; (submitted = true)))) {
         result = accumulator(result, key, value);
       }
     }
     return result;
   });
 }
</PRE><P>};
</P><P>Form.Methods = {
</P><PRE> serialize: function(form, options) {
   return Form.serializeElements(Form.getElements(form), options);
 },
</PRE><PRE> getElements: function(form) {
   var elements = $(form).getElementsByTagName('*');
   var element, results = [], serializers = Form.Element.Serializers;
</PRE><PRE>   for (var i = 0; element = elements[i]; i++) {
     if (serializers[element.tagName.toLowerCase()])
       results.push(Element.extend(element));
   }
   return results;
 },
</PRE><PRE> getInputs: function(form, typeName, name) {
   form = $(form);
   var inputs = form.getElementsByTagName('input');
</PRE><PRE>   if (!typeName &amp;&amp; !name) return $A(inputs).map(Element.extend);
</PRE><PRE>   for (var i = 0, matchingInputs = [], length = inputs.length; i &lt; length; i++) {
     var input = inputs[i];
     if ((typeName &amp;&amp; input.type != typeName) || (name &amp;&amp; input.name != name))
       continue;
     matchingInputs.push(Element.extend(input));
   }
</PRE><PRE>   return matchingInputs;
 },
</PRE><PRE> disable: function(form) {
   form = $(form);
   Form.getElements(form).invoke('disable');
   return form;
 },
</PRE><PRE> enable: function(form) {
   form = $(form);
   Form.getElements(form).invoke('enable');
   return form;
 },
</PRE><PRE> findFirstElement: function(form) {
   var elements = $(form).getElements().findAll(function(element) {
     return 'hidden' != element.type &amp;&amp; !element.disabled;
   });
   var firstByIndex = elements.findAll(function(element) {
     return element.hasAttribute('tabIndex') &amp;&amp; element.tabIndex &gt;= 0;
   }).sortBy(function(element) { return element.tabIndex }).first();
</PRE><PRE>   return firstByIndex ? firstByIndex : elements.find(function(element) {
     return /^(?:input|select|textarea)$/i.test(element.tagName);
   });
 },
</PRE><PRE> focusFirstElement: function(form) {
   form = $(form);
   var element = form.findFirstElement();
   if (element) element.activate();
   return form;
 },
</PRE><PRE> request: function(form, options) {
   form = $(form), options = Object.clone(options || { });
</PRE><PRE>   var params = options.parameters, action = form.readAttribute('action') || <I>;</I>
   if (action.blank()) action = window.location.href;
   options.parameters = form.serialize(true);
</PRE><PRE>   if (params) {
     if (Object.isString(params)) params = params.toQueryParams();
     Object.extend(options.parameters, params);
   }
</PRE><PRE>   if (form.hasAttribute('method') &amp;&amp; !options.method)
     options.method = form.method;
</PRE><PRE>   return new Ajax.Request(action, options);
 }
</PRE><P>};
</P><P>/*--------------------------------------------------------------------------*/
</P><P>
Form.Element = {
</P><PRE> focus: function(element) {
   $(element).focus();
   return element;
 },
</PRE><PRE> select: function(element) {
   $(element).select();
   return element;
 }
</PRE><P>};
</P><P>Form.Element.Methods = {
</P><PRE> serialize: function(element) {
   element = $(element);
   if (!element.disabled &amp;&amp; element.name) {
     var value = element.getValue();
     if (value != undefined) {
       var pair = { };
       pair[element.name] = value;
       return Object.toQueryString(pair);
     }
   }
   return <I>;</I>
 },
</PRE><PRE> getValue: function(element) {
   element = $(element);
   var method = element.tagName.toLowerCase();
   return Form.Element.Serializers[method](element);
 },
</PRE><PRE> setValue: function(element, value) {
   element = $(element);
   var method = element.tagName.toLowerCase();
   Form.Element.Serializers[method](element, value);
   return element;
 },
</PRE><PRE> clear: function(element) {
   $(element).value = <I>;</I>
   return element;
 },
</PRE><PRE> present: function(element) {
   return $(element).value != <I>;</I>
 },
</PRE><PRE> activate: function(element) {
   element = $(element);
   try {
     element.focus();
     if (element.select &amp;&amp; (element.tagName.toLowerCase() != 'input' ||
         !(/^(?:button|reset|submit)$/i.test(element.type))))
       element.select();
   } catch (e) { }
   return element;
 },
</PRE><PRE> disable: function(element) {
   element = $(element);
   element.disabled = true;
   return element;
 },
</PRE><PRE> enable: function(element) {
   element = $(element);
   element.disabled = false;
   return element;
 }
</PRE><P>};
</P><P>/*--------------------------------------------------------------------------*/
</P><P>var Field = Form.Element;
</P><P>var $F = Form.Element.Methods.getValue;
</P><P>/*--------------------------------------------------------------------------*/
</P><P>Form.Element.Serializers = (function() {
</P><PRE> function input(element, value) {
   switch (element.type.toLowerCase()) {
     case 'checkbox':
     case 'radio':
       return inputSelector(element, value);
     default:
       return valueSelector(element, value);
   }
 }
</PRE><PRE> function inputSelector(element, value) {
   if (Object.isUndefined(value))
     return element.checked ? element.value : null;
   else element.checked = !!value;
 }
</PRE><PRE> function valueSelector(element, value) {
   if (Object.isUndefined(value)) return element.value;
   else element.value = value;
 }
</PRE><PRE> function select(element, value) {
   if (Object.isUndefined(value))
     return (element.type === 'select-one' ? selectOne : selectMany)(element);
</PRE><PRE>   var opt, currentValue, single = !Object.isArray(value);
   for (var i = 0, length = element.length; i &lt; length; i++) {
     opt = element.options[i];
     currentValue = this.optionValue(opt);
     if (single) {
       if (currentValue == value) {
         opt.selected = true;
         return;
       }
     }
     else opt.selected = value.include(currentValue);
   }
 }
</PRE><PRE> function selectOne(element) {
   var index = element.selectedIndex;
   return index &gt;= 0 ? optionValue(element.options[index]) : null;
 }
</PRE><PRE> function selectMany(element) {
   var values, length = element.length;
   if (!length) return null;
</PRE><PRE>   for (var i = 0, values = []; i &lt; length; i++) {
     var opt = element.options[i];
     if (opt.selected) values.push(optionValue(opt));
   }
   return values;
 }
</PRE><PRE> function optionValue(opt) {
   return Element.hasAttribute(opt, 'value') ? opt.value : opt.text;
 }
</PRE><PRE> return {
   input:         input,
   inputSelector: inputSelector,
   textarea:      valueSelector,
   select:        select,
   selectOne:     selectOne,
   selectMany:    selectMany,
   optionValue:   optionValue,
   button:        valueSelector
 };
</PRE><P>})();
</P><P>/*--------------------------------------------------------------------------*/
</P><P>
Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
</P><PRE> initialize: function($super, element, frequency, callback) {
   $super(callback, frequency);
   this.element   = $(element);
   this.lastValue = this.getValue();
 },
</PRE><PRE> execute: function() {
   var value = this.getValue();
   if (Object.isString(this.lastValue) &amp;&amp; Object.isString(value) ?
       this.lastValue != value : String(this.lastValue) != String(value)) {
     this.callback(this.element, value);
     this.lastValue = value;
   }
 }
</PRE><P>});
</P><P>Form.Element.Observer = Class.create(Abstract.TimedObserver, {
</P><PRE> getValue: function() {
   return Form.Element.getValue(this.element);
 }
</PRE><P>});
</P><P>Form.Observer = Class.create(Abstract.TimedObserver, {
</P><PRE> getValue: function() {
   return Form.serialize(this.element);
 }
</PRE><P>});
</P><P>/*--------------------------------------------------------------------------*/
</P><P>Abstract.EventObserver = Class.create({
</P><PRE> initialize: function(element, callback) {
   this.element  = $(element);
   this.callback = callback;
</PRE><PRE>   this.lastValue = this.getValue();
   if (this.element.tagName.toLowerCase() == 'form')
     this.registerFormCallbacks();
   else
     this.registerCallback(this.element);
 },
</PRE><PRE> onElementEvent: function() {
   var value = this.getValue();
   if (this.lastValue != value) {
     this.callback(this.element, value);
     this.lastValue = value;
   }
 },
</PRE><PRE> registerFormCallbacks: function() {
   Form.getElements(this.element).each(this.registerCallback, this);
 },
</PRE><PRE> registerCallback: function(element) {
   if (element.type) {
     switch (element.type.toLowerCase()) {
       case 'checkbox':
       case 'radio':
         Event.observe(element, 'click', this.onElementEvent.bind(this));
         break;
       default:
         Event.observe(element, 'change', this.onElementEvent.bind(this));
         break;
     }
   }
 }
</PRE><P>});
</P><P>Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
</P><PRE> getValue: function() {
   return Form.Element.getValue(this.element);
 }
</PRE><P>});
</P><P>Form.EventObserver = Class.create(Abstract.EventObserver, {
</P><PRE> getValue: function() {
   return Form.serialize(this.element);
 }
</PRE><P>});
(function(GLOBAL) {
</P><PRE> var DIV = document.createElement('div');
 var docEl = document.documentElement;
 var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl
  &amp;&amp; 'onmouseleave' in docEl;
</PRE><PRE> var Event = {
   KEY_BACKSPACE: 8,
   KEY_TAB:       9,
   KEY_RETURN:   13,
   KEY_ESC:      27,
   KEY_LEFT:     37,
   KEY_UP:       38,
   KEY_RIGHT:    39,
   KEY_DOWN:     40,
   KEY_DELETE:   46,
   KEY_HOME:     36,
   KEY_END:      35,
   KEY_PAGEUP:   33,
   KEY_PAGEDOWN: 34,
   KEY_INSERT:   45
 };
</PRE><PRE> var isIELegacyEvent = function(event) { return false; };
</PRE><PRE> if (window.attachEvent) {
   if (window.addEventListener) {
     isIELegacyEvent = function(event) {
       return !(event instanceof window.Event);
     };
   } else {
     isIELegacyEvent = function(event) { return true; };
   }
 }
</PRE><PRE> var _isButton;
</PRE><PRE> function _isButtonForDOMEvents(event, code) {
   return event.which ? (event.which === code + 1) : (event.button === code);
 }
</PRE><PRE> var legacyButtonMap = { 0: 1, 1: 4, 2: 2 };
 function _isButtonForLegacyEvents(event, code) {
   return event.button === legacyButtonMap[code];
 }
</PRE><PRE> function _isButtonForWebKit(event, code) {
   switch (code) {
     case 0: return event.which == 1 &amp;&amp; !event.metaKey;
     case 1: return event.which == 2 || (event.which == 1 &amp;&amp; event.metaKey);
     case 2: return event.which == 3;
     default: return false;
   }
 }
</PRE><PRE> if (window.attachEvent) {
   if (!window.addEventListener) {
     _isButton = _isButtonForLegacyEvents;
   } else {
     _isButton = function(event, code) {
       return isIELegacyEvent(event) ? _isButtonForLegacyEvents(event, code) :
        _isButtonForDOMEvents(event, code);
     }
   }
 } else if (Prototype.Browser.WebKit) {
   _isButton = _isButtonForWebKit;
 } else {
   _isButton = _isButtonForDOMEvents;
 }
</PRE><PRE> function isLeftClick(event)   { return _isButton(event, 0) }
</PRE><PRE> function isMiddleClick(event) { return _isButton(event, 1) }
</PRE><PRE> function isRightClick(event)  { return _isButton(event, 2) }
</PRE><PRE> function element(event) {
   return Element.extend(_element(event));
 }
</PRE><PRE> function _element(event) {
   event = Event.extend(event);
</PRE><PRE>   var node = event.target, type = event.type,
    currentTarget = event.currentTarget;
</PRE><PRE>   if (currentTarget &amp;&amp; currentTarget.tagName) {
     if (type === 'load' || type === 'error' ||
       (type === 'click' &amp;&amp; currentTarget.tagName.toLowerCase() === 'input'
         &amp;&amp; currentTarget.type === 'radio'))
           node = currentTarget;
   }
</PRE><PRE>   return node.nodeType == Node.TEXT_NODE ? node.parentNode : node;
 }
</PRE><PRE> function findElement(event, expression) {
   var element = _element(event), selector = Prototype.Selector;
   if (!expression) return Element.extend(element);
   while (element) {
     if (Object.isElement(element) &amp;&amp; selector.match(element, expression))
       return Element.extend(element);
     element = element.parentNode;
   }
 }
</PRE><PRE> function pointer(event) {
   return { x: pointerX(event), y: pointerY(event) };
 }
</PRE><PRE> function pointerX(event) {
   var docElement = document.documentElement,
    body = document.body || { scrollLeft: 0 };
</PRE><PRE>   return event.pageX || (event.clientX +
     (docElement.scrollLeft || body.scrollLeft) -
     (docElement.clientLeft || 0));
 }
</PRE><PRE> function pointerY(event) {
   var docElement = document.documentElement,
    body = document.body || { scrollTop: 0 };
</PRE><PRE>   return  event.pageY || (event.clientY +
      (docElement.scrollTop || body.scrollTop) -
      (docElement.clientTop || 0));
 }
</PRE><PRE> function stop(event) {
   Event.extend(event);
   event.preventDefault();
   event.stopPropagation();
</PRE><PRE>   event.stopped = true;
 }
</PRE><PRE> Event.Methods = {
   isLeftClick:   isLeftClick,
   isMiddleClick: isMiddleClick,
   isRightClick:  isRightClick,
</PRE><PRE>   element:     element,
   findElement: findElement,
</PRE><PRE>   pointer:  pointer,
   pointerX: pointerX,
   pointerY: pointerY,
</PRE><PRE>   stop: stop
 };
</PRE><PRE> var methods = Object.keys(Event.Methods).inject({ }, function(m, name) {
   m[name] = Event.Methods[name].methodize();
   return m;
 });
</PRE><PRE> if (window.attachEvent) {
   function _relatedTarget(event) {
     var element;
     switch (event.type) {
       case 'mouseover':
       case 'mouseenter':
         element = event.fromElement;
         break;
       case 'mouseout':
       case 'mouseleave':
         element = event.toElement;
         break;
       default:
         return null;
     }
     return Element.extend(element);
   }
</PRE><PRE>   var additionalMethods = {
     stopPropagation: function() { this.cancelBubble = true },
     preventDefault:  function() { this.returnValue = false },
     inspect: function() { return '[object Event]' }
   };
</PRE><PRE>   Event.extend = function(event, element) {
     if (!event) return false;
</PRE><PRE>     if (!isIELegacyEvent(event)) return event;
</PRE><PRE>     if (event._extendedByPrototype) return event;
     event._extendedByPrototype = Prototype.emptyFunction;
</PRE><PRE>     var pointer = Event.pointer(event);
</PRE><PRE>     Object.extend(event, {
       target: event.srcElement || element,
       relatedTarget: _relatedTarget(event),
       pageX:  pointer.x,
       pageY:  pointer.y
     });
</PRE><PRE>     Object.extend(event, methods);
     Object.extend(event, additionalMethods);
</PRE><PRE>     return event;
   };
 } else {
   Event.extend = Prototype.K;
 }
</PRE><PRE> if (window.addEventListener) {
   Event.prototype = window.Event.prototype || document.createEvent('HTMLEvents').__proto__;
   Object.extend(Event.prototype, methods);
 }
</PRE><PRE> var EVENT_TRANSLATIONS = {
   mouseenter: 'mouseover',
   mouseleave: 'mouseout'
 };
</PRE><PRE> function getDOMEventName(eventName) {
   return EVENT_TRANSLATIONS[eventName] || eventName;
 }
</PRE><PRE> if (MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED)
   getDOMEventName = Prototype.K;
</PRE><PRE> function getUniqueElementID(element) {
   if (element === window) return 0;
</PRE><PRE>   if (typeof element._prototypeUID === 'undefined')
     element._prototypeUID = Element.Storage.UID++;
   return element._prototypeUID;
 }
</PRE><PRE> function getUniqueElementID_IE(element) {
   if (element === window) return 0;
   if (element == document) return 1;
   return element.uniqueID;
 }
</PRE><PRE> if ('uniqueID' in DIV)
   getUniqueElementID = getUniqueElementID_IE;
</PRE><PRE> function isCustomEvent(eventName) {
   return eventName.include(':');
 }
</PRE><PRE> Event._isCustomEvent = isCustomEvent;
</PRE><PRE> function getRegistryForElement(element, uid) {
   var CACHE = GLOBAL.Event.cache;
   if (Object.isUndefined(uid))
     uid = getUniqueElementID(element);
   if (!CACHE[uid]) CACHE[uid] = { element: element };
   return CACHE[uid];
 }
</PRE><PRE> function destroyRegistryForElement(element, uid) {
   if (Object.isUndefined(uid))
     uid = getUniqueElementID(element);
   delete GLOBAL.Event.cache[uid];
 }
</PRE><PRE> function register(element, eventName, handler) {
   var registry = getRegistryForElement(element);
   if (!registry[eventName]) registry[eventName] = [];
   var entries = registry[eventName];
</PRE><PRE>   var i = entries.length;
   while (i--)
     if (entries[i].handler === handler) return null;
</PRE><PRE>   var uid = getUniqueElementID(element);
   var responder = GLOBAL.Event._createResponder(uid, eventName, handler);
   var entry = {
     responder: responder,
     handler:   handler
   };
</PRE><PRE>   entries.push(entry);
   return entry;
 }
</PRE><PRE> function unregister(element, eventName, handler) {
   var registry = getRegistryForElement(element);
   var entries = registry[eventName];
   if (!entries) return;
</PRE><PRE>   var i = entries.length, entry;
   while (i--) {
     if (entries[i].handler === handler) {
       entry = entries[i];
       break;
     }
   }
</PRE><PRE>   if (!entry) return;
</PRE><PRE>   var index = entries.indexOf(entry);
   entries.splice(index, 1);
</PRE><PRE>   return entry;
 }
</PRE><PRE> function observe(element, eventName, handler) {
   element = $(element);
   var entry = register(element, eventName, handler);
</PRE><PRE>   if (entry === null) return element;
</PRE><PRE>   var responder = entry.responder;
   if (isCustomEvent(eventName))
     observeCustomEvent(element, eventName, responder);
   else
     observeStandardEvent(element, eventName, responder);
</PRE><PRE>   return element;
 }
</PRE><PRE> function observeStandardEvent(element, eventName, responder) {
   var actualEventName = getDOMEventName(eventName);
   if (element.addEventListener) {
     element.addEventListener(actualEventName, responder, false);
   } else {
     element.attachEvent('on' + actualEventName, responder);
   }
 }
</PRE><PRE> function observeCustomEvent(element, eventName, responder) {
   if (element.addEventListener) {
     element.addEventListener('dataavailable', responder, false);
   } else {
     element.attachEvent('ondataavailable', responder);
     element.attachEvent('onlosecapture',   responder);
   }
 }
</PRE><PRE> function stopObserving(element, eventName, handler) {
   element = $(element);
   var handlerGiven = !Object.isUndefined(handler),
    eventNameGiven = !Object.isUndefined(eventName);
</PRE><PRE>   if (!eventNameGiven &amp;&amp; !handlerGiven) {
     stopObservingElement(element);
     return element;
   }
</PRE><PRE>   if (!handlerGiven) {
     stopObservingEventName(element, eventName);
     return element;
   }
</PRE><PRE>   var entry = unregister(element, eventName, handler);
</PRE><PRE>   if (!entry) return element;
   removeEvent(element, eventName, entry.responder);
   return element;
 }
</PRE><PRE> function stopObservingStandardEvent(element, eventName, responder) {
   var actualEventName = getDOMEventName(eventName);
   if (element.removeEventListener) {
     element.removeEventListener(actualEventName, responder, false);
   } else {
     element.detachEvent('on' + actualEventName, responder);
   }
 }
</PRE><PRE> function stopObservingCustomEvent(element, eventName, responder) {
   if (element.removeEventListener) {
     element.removeEventListener('dataavailable', responder, false);
   } else {
     element.detachEvent('ondataavailable', responder);
     element.detachEvent('onlosecapture',   responder);
   }
 }
</PRE><PRE> function stopObservingElement(element) {
   var uid = getUniqueElementID(element), registry = GLOBAL.Event.cache[uid];
   if (!registry) return;
</PRE><PRE>   destroyRegistryForElement(element, uid);
</PRE><PRE>   var entries, i;
   for (var eventName in registry) {
     if (eventName === 'element') continue;
</PRE><PRE>     entries = registry[eventName];
     i = entries.length;
     while (i--)
       removeEvent(element, eventName, entries[i].responder);
   }
 }
</PRE><PRE> function stopObservingEventName(element, eventName) {
   var registry = getRegistryForElement(element);
   var entries = registry[eventName];
   if (!entries) return;
   delete registry[eventName];
</PRE><PRE>   var i = entries.length;
   while (i--)
     removeEvent(element, eventName, entries[i].responder);
 }
</PRE><PRE> function removeEvent(element, eventName, handler) {
   if (isCustomEvent(eventName))
     stopObservingCustomEvent(element, eventName, handler);
   else
     stopObservingStandardEvent(element, eventName, handler);
 }
</PRE><PRE> function getFireTarget(element) {
   if (element !== document) return element;
   if (document.createEvent &amp;&amp; !element.dispatchEvent)
     return document.documentElement;
   return element;
 }
</PRE><PRE> function fire(element, eventName, memo, bubble) {
   element = getFireTarget($(element));
   if (Object.isUndefined(bubble)) bubble = true;
   memo = memo || {};
</PRE><PRE>   var event = fireEvent(element, eventName, memo, bubble);
   return Event.extend(event);
 }
</PRE><PRE> function fireEvent_DOM(element, eventName, memo, bubble) {
   var event = document.createEvent('HTMLEvents');
   event.initEvent('dataavailable', bubble, true);
</PRE><PRE>   event.eventName = eventName;
   event.memo = memo;
</PRE><PRE>   element.dispatchEvent(event);
   return event;
 }
</PRE><PRE> function fireEvent_IE(element, eventName, memo, bubble) {
   var event = document.createEventObject();
   event.eventType = bubble ? 'ondataavailable' : 'onlosecapture';
</PRE><PRE>   event.eventName = eventName;
   event.memo = memo;
</PRE><PRE>   element.fireEvent(event.eventType, event);
   return event;
 }
</PRE><PRE> var fireEvent = document.createEvent ? fireEvent_DOM : fireEvent_IE;
</PRE><PRE> Event.Handler = Class.create({
   initialize: function(element, eventName, selector, callback) {
     this.element   = $(element);
     this.eventName = eventName;
     this.selector  = selector;
     this.callback  = callback;
     this.handler   = this.handleEvent.bind(this);
   },
</PRE><PRE>   start: function() {
     Event.observe(this.element, this.eventName, this.handler);
     return this;
   },
</PRE><PRE>   stop: function() {
     Event.stopObserving(this.element, this.eventName, this.handler);
     return this;
   },
</PRE><PRE>   handleEvent: function(event) {
     var element = Event.findElement(event, this.selector);
     if (element) this.callback.call(this.element, event, element);
   }
 });
</PRE><PRE> function on(element, eventName, selector, callback) {
   element = $(element);
   if (Object.isFunction(selector) &amp;&amp; Object.isUndefined(callback)) {
     callback = selector, selector = null;
   }
</PRE><PRE>   return new Event.Handler(element, eventName, selector, callback).start();
 }
</PRE><PRE> Object.extend(Event, Event.Methods);
</PRE><PRE> Object.extend(Event, {
   fire:          fire,
   observe:       observe,
   stopObserving: stopObserving,
   on:            on
 });
</PRE><PRE> Element.addMethods({
   fire:          fire,
</PRE><PRE>   observe:       observe,
</PRE><PRE>   stopObserving: stopObserving,
</PRE><PRE>   on:            on
 });
</PRE><PRE> Object.extend(document, {
   fire:          fire.methodize(),
</PRE><PRE>   observe:       observe.methodize(),
</PRE><PRE>   stopObserving: stopObserving.methodize(),
</PRE><PRE>   on:            on.methodize(),
</PRE><PRE>   loaded:        false
 });
</PRE><PRE> if (GLOBAL.Event) Object.extend(window.Event, Event);
 else GLOBAL.Event = Event;
</PRE><PRE> GLOBAL.Event.cache = {};
</PRE><PRE> function destroyCache_IE() {
   GLOBAL.Event.cache = null;
 }
</PRE><PRE> if (window.attachEvent)
   window.attachEvent('onunload', destroyCache_IE);
</PRE><PRE> DIV = null;
 docEl = null;
</PRE><P>})(this);
</P><P>(function(GLOBAL) {
</P><PRE> /* Code for creating leak-free event responders is based on work by
  John-David Dalton. */
</PRE><PRE> var docEl = document.documentElement;
 var MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED = 'onmouseenter' in docEl
   &amp;&amp; 'onmouseleave' in docEl;
</PRE><PRE> function isSimulatedMouseEnterLeaveEvent(eventName) {
   return !MOUSEENTER_MOUSELEAVE_EVENTS_SUPPORTED &amp;&amp;
    (eventName === 'mouseenter' || eventName === 'mouseleave');
 }
</PRE><PRE> function createResponder(uid, eventName, handler) {
   if (Event._isCustomEvent(eventName))
     return createResponderForCustomEvent(uid, eventName, handler);
   if (isSimulatedMouseEnterLeaveEvent(eventName))
     return createMouseEnterLeaveResponder(uid, eventName, handler);
</PRE><PRE>   return function(event) {
     if (!Event.cache) return;
</PRE><PRE>     var element = Event.cache[uid].element;
     Event.extend(event, element);
     handler.call(element, event);
   };
 }
</PRE><PRE> function createResponderForCustomEvent(uid, eventName, handler) {
   return function(event) {
     var element = Event.cache[uid].element;
</PRE><PRE>     if (Object.isUndefined(event.eventName))
       return false;
</PRE><PRE>     if (event.eventName !== eventName)
       return false;
</PRE><PRE>     Event.extend(event, element);
     handler.call(element, event);
   };
 }
</PRE><PRE> function createMouseEnterLeaveResponder(uid, eventName, handler) {
   return function(event) {
     var element = Event.cache[uid].element;
</PRE><PRE>     Event.extend(event, element);
     var parent = event.relatedTarget;
</PRE><PRE>     while (parent &amp;&amp; parent !== element) {
       try { parent = parent.parentNode; }
       catch(e) { parent = element; }
     }
</PRE><PRE>     if (parent === element) return;
     handler.call(element, event);
   }
 }
</PRE><PRE> GLOBAL.Event._createResponder = createResponder;
 docEl = null;
</PRE><P>})(this);
</P><P>(function(GLOBAL) {
</P><PRE> /* Support for the DOMContentLoaded event is based on work by Dan Webb,
    Matthias Miller, Dean Edwards, John Resig, and Diego Perini. */
</PRE><PRE> var TIMER;
</PRE><PRE> function fireContentLoadedEvent() {
   if (document.loaded) return;
   if (TIMER) window.clearTimeout(TIMER);
   document.loaded = true;
   document.fire('dom:loaded');
 }
</PRE><PRE> function checkReadyState() {
   if (document.readyState === 'complete') {
     document.detachEvent('onreadystatechange', checkReadyState);
     fireContentLoadedEvent();
   }
 }
</PRE><PRE> function pollDoScroll() {
   try {
     document.documentElement.doScroll('left');
   } catch (e) {
     TIMER = pollDoScroll.defer();
     return;
   }
</PRE><PRE>   fireContentLoadedEvent();
 }
</PRE><PRE> if (document.readyState === 'complete') {
   fireContentLoadedEvent();
   return;
 }
</PRE><PRE> if (document.addEventListener) {
   document.addEventListener('DOMContentLoaded', fireContentLoadedEvent, false);
 } else {
   document.attachEvent('onreadystatechange', checkReadyState);
   if (window == top) TIMER = pollDoScroll.defer();
 }
</PRE><PRE> Event.observe(window, 'load', fireContentLoadedEvent);
</PRE><P>})(this);
</P><P>
Element.addMethods();
/*------------------------------- DEPRECATED -------------------------------*/
</P><P>Hash.toQueryString = Object.toQueryString;
</P><P>var Toggle = { display: Element.toggle };
</P><P>Element.Methods.childOf = Element.Methods.descendantOf;
</P><P>var Insertion = {
</P><PRE> Before: function(element, content) {
   return Element.insert(element, {before:content});
 },
</PRE><PRE> Top: function(element, content) {
   return Element.insert(element, {top:content});
 },
</PRE><PRE> Bottom: function(element, content) {
   return Element.insert(element, {bottom:content});
 },
</PRE><PRE> After: function(element, content) {
   return Element.insert(element, {after:content});
 }
</PRE><P>};
</P><P>var $continue = new Error('&quot;throw $continue&quot; is deprecated, use &quot;return&quot; instead');
</P><P>var Position = {
</P><PRE> includeScrollOffsets: false,
</PRE><PRE> prepare: function() {
   this.deltaX =  window.pageXOffset
               || document.documentElement.scrollLeft
               || document.body.scrollLeft
               || 0;
   this.deltaY =  window.pageYOffset
               || document.documentElement.scrollTop
               || document.body.scrollTop
               || 0;
 },
</PRE><PRE> within: function(element, x, y) {
   if (this.includeScrollOffsets)
     return this.withinIncludingScrolloffsets(element, x, y);
   this.xcomp = x;
   this.ycomp = y;
   this.offset = Element.cumulativeOffset(element);
</PRE><PRE>   return (y &gt;= this.offset[1] &amp;&amp;
           y &lt;  this.offset[1] + element.offsetHeight &amp;&amp;
           x &gt;= this.offset[0] &amp;&amp;
           x &lt;  this.offset[0] + element.offsetWidth);
 },
</PRE><PRE> withinIncludingScrolloffsets: function(element, x, y) {
   var offsetcache = Element.cumulativeScrollOffset(element);
</PRE><PRE>   this.xcomp = x + offsetcache[0] - this.deltaX;
   this.ycomp = y + offsetcache[1] - this.deltaY;
   this.offset = Element.cumulativeOffset(element);
</PRE><PRE>   return (this.ycomp &gt;= this.offset[1] &amp;&amp;
           this.ycomp &lt;  this.offset[1] + element.offsetHeight &amp;&amp;
           this.xcomp &gt;= this.offset[0] &amp;&amp;
           this.xcomp &lt;  this.offset[0] + element.offsetWidth);
 },
</PRE><PRE> overlap: function(mode, element) {
   if (!mode) return 0;
   if (mode == 'vertical')
     return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
       element.offsetHeight;
   if (mode == 'horizontal')
     return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
       element.offsetWidth;
 },
</PRE><PRE> cumulativeOffset: Element.Methods.cumulativeOffset,
</PRE><PRE> positionedOffset: Element.Methods.positionedOffset,
</PRE><PRE> absolutize: function(element) {
   Position.prepare();
   return Element.absolutize(element);
 },
</PRE><PRE> relativize: function(element) {
   Position.prepare();
   return Element.relativize(element);
 },
</PRE><PRE> realOffset: Element.Methods.cumulativeScrollOffset,
</PRE><PRE> offsetParent: Element.Methods.getOffsetParent,
</PRE><PRE> page: Element.Methods.viewportOffset,
</PRE><PRE> clone: function(source, target, options) {
   options = options || { };
   return Element.clonePosition(target, source, options);
 }
</PRE><P>};
</P><P>/*--------------------------------------------------------------------------*/
</P><P>if (!document.getElementsByClassName) document.getElementsByClassName = function(instanceMethods){
</P><PRE> function iter(name) {
   return name.blank() ? null : &quot;[contains(concat(' ', @class, ' '), ' &quot; + name + &quot; ')]&quot;;
 }
</PRE><PRE> instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ?
 function(element, className) {
   className = className.toString().strip();
   var cond = /\s/.test(className) ? $w(className).map(iter).join(<I>) : iter(className);</I>
   return cond ? document._getElementsByXPath('.//*' + cond, element) : [];
 } : function(element, className) {
   className = className.toString().strip();
   var elements = [], classNames = (/\s/.test(className) ? $w(className) : null);
   if (!classNames &amp;&amp; !className) return elements;
</PRE><PRE>   var nodes = $(element).getElementsByTagName('*');
   className = ' ' + className + ' ';
</PRE><PRE>   for (var i = 0, child, cn; child = nodes[i]; i++) {
     if (child.className &amp;&amp; (cn = ' ' + child.className + ' ') &amp;&amp; (cn.include(className) ||
         (classNames &amp;&amp; classNames.all(function(name) {
           return !name.toString().blank() &amp;&amp; cn.include(' ' + name + ' ');
         }))))
       elements.push(Element.extend(child));
   }
   return elements;
 };
</PRE><PRE> return function(className, parentElement) {
   return $(parentElement || document.body).getElementsByClassName(className);
 };
</PRE><P>}(Element.Methods);
</P><P>/*--------------------------------------------------------------------------*/
</P><P>Element.ClassNames = Class.create();
Element.ClassNames.prototype = {
</P><PRE> initialize: function(element) {
   this.element = $(element);
 },
</PRE><PRE> _each: function(iterator, context) {
   this.element.className.split(/\s+/).select(function(name) {
     return name.length &gt; 0;
   })._each(iterator, context);
 },
</PRE><PRE> set: function(className) {
   this.element.className = className;
 },
</PRE><PRE> add: function(classNameToAdd) {
   if (this.include(classNameToAdd)) return;
   this.set($A(this).concat(classNameToAdd).join(' '));
 },
</PRE><PRE> remove: function(classNameToRemove) {
   if (!this.include(classNameToRemove)) return;
   this.set($A(this).without(classNameToRemove).join(' '));
 },
</PRE><PRE> toString: function() {
   return $A(this).join(' ');
 }
</PRE><P>};
</P><P>Object.extend(Element.ClassNames.prototype, Enumerable);
</P><P>/*--------------------------------------------------------------------------*/
</P><P>(function() {
</P><PRE> window.Selector = Class.create({
   initialize: function(expression) {
     this.expression = expression.strip();
   },
</PRE><PRE>   findElements: function(rootElement) {
     return Prototype.Selector.select(this.expression, rootElement);
   },
</PRE><PRE>   match: function(element) {
     return Prototype.Selector.match(element, this.expression);
   },
</PRE><PRE>   toString: function() {
     return this.expression;
   },
</PRE><PRE>   inspect: function() {
     return &quot;#&lt;Selector: &quot; + this.expression + &quot;&gt;&quot;;
   }
 });
</PRE><PRE> Object.extend(Selector, {
   matchElements: function(elements, expression) {
     var match = Prototype.Selector.match,
         results = [];
</PRE><PRE>     for (var i = 0, length = elements.length; i &lt; length; i++) {
       var element = elements[i];
       if (match(element, expression)) {
         results.push(Element.extend(element));
       }
     }
     return results;
   },
</PRE><PRE>   findElement: function(elements, expression, index) {
     index = index || 0;
     var matchIndex = 0, element;
     for (var i = 0, length = elements.length; i &lt; length; i++) {
       element = elements[i];
       if (Prototype.Selector.match(element, expression) &amp;&amp; index === matchIndex++) {
         return Element.extend(element);
       }
     }
   },
</PRE><PRE>   findChildElements: function(element, expressions) {
     var selector = expressions.toArray().join(', ');
     return Prototype.Selector.select(selector, element || document);
   }
 });
</PRE><P>})();
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
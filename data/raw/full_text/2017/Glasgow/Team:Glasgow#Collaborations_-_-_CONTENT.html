<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Glasgow_Collaborations skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Glasgow/Collaborations</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><DIV class="title-bar" data-responsive-toggle="main-menu" data-hide-for="medium"><DIV class="title-bar-title">Glasgow iGEM 2017</DIV></DIV><DIV class="top-bar" id="main-menu"><DIV><DIV class="top-bar-right"><UL class="vertical large-horizontal menu" id="main-nav" data-responsive-menu="medium-accordion large-dropdown"><LI><A class="headline" href="#">Project</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Description">Project Background</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Demonstrate">Demonstrate</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/mtlR">Exploiting the Mannitol regulator MtlR</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/araC">Mutagenesis of AraC</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/QuorumSensing">Quorum Sensing </A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/ANDGate">AND Gate testing</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/XyluloseBiosynthesis">Xylulose Biosynthesis</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/InterLab">InterLab study</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Measurement">Measurement</A></LI></UL><LI><A href="https://2017.igem.org/Team:Glasgow/Parts">Parts List</A></LI><LI><A class="headline" href="#">Engineering</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Applied_Design">Designing the Biosensor Device</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Hardware">Hardware</A></LI><LI><A href="#">Additional Work</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/HydrogelStrip">Hydrogel Strip Experiments</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/BacillusSubtilis"><I>Bacillus subtilis</I> Experiments</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Collaborations">Collaborations</A></LI><LI><A class="headline" href="#">Practices</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/HP/Silver">Silver</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/HP/Gold_Integrated">Gold and 
                                                 Integrated</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Engagement">Education and Public 
                                                Outreach</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/HP/Gold_Integrated/PolicyBrief">Policy Brief</A></LI><LI><A class="headline" href="#">Notebook</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Protocols">Protocols</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/WeeklyJournal">Weekly Journal</A></LI><LI><A class="headline" href="#">People</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Team">Team Members</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Attributions">Attributions</A></LI><LI><A class="headline" href="#">Accomplishments</A></LI><LI><A href="https://2017.igem.org/Team:Glasgow/Accomplishments">Accomplishments</A></LI></DIV></DIV></DIV><DIV class="photo-block" id="Collaborations"><DIV class="text left"><DIV class="title">
			Collaborations
		</DIV></DIV></DIV><DIV class="wiki-block"><DIV id="article"><H2><SPAN class="mw-headline" id="Collaboration_with_Edinburgh_iGEM">Collaboration with Edinburgh iGEM</SPAN></H2><P>In August, <A rel="nofollow" class="external text" href="https://2017.igem.org/Team:Edinburgh_UG">Edinburgh iGEM</A> approached us asking if we were able to assist them with programming the function of stepper drivers which they used to operate syringe drives. They required the stepper motor to adjust pace based on a number of parameters to give a desired flow rate.
</P><DIV class="center"><DIV class="thumb tnone"><DIV class="thumbinner" style="width:752px;"><DIV class="thumbcaption"><B>Figure 1:</B> Collaboration with Edinburgh iGEM</DIV></DIV></DIV></DIV><P>
A day was arranged when the two teams should meet mid-August. When we met, we first spoke to one of our advisors, <A rel="nofollow" class="external text" href="https://2017.igem.org/Team:Glasgow/Team">Julien Reboud</A>. Following an hour long meeting with Dr. Reboud, we proceeded to discuss the part Edinburgh iGEM hoped Glasgow iGEM could help them with. Their design consisted of two microfluidic flows that would be able to sort cells depending on their fluorescent output when observed underneath a fluorescent microscope. When the threshold level of fluorescence was reached, one of the microfluidic flows, controlled by the stepper motor, would increase in flow rate such that the cell would be “pushed” to a different output due to the shear forces imparted on it. As none of the Edinburgh iGEM team had any experience of programming, we offered our assistance in this area.
</P><P>Our initial focus was to produce a code that would be able to produce a desired flow rate over a total distance, based on the following parameters: 
</P><DL><DD><UL><LI>User’s Desired Flow Rate</LI><LI>Syringe Inner Lumen Diameter</LI><LI>Total Distance of Syringe Travel</LI></UL></DD></DL><P>Having established these input conditions, we set to work for the next 3 days to write code which would be able to perform as desired. This code is shown below.
</P><DIV style="overflow: auto; width:100%; height:250px; background-color:#ffffff; border:3px solid #a6a6a6;padding:1%"><P>//This code should give you the flow rate you enter into the code for a threaded rod of pitch 0.8mm
//
// The limits in flow rate [FOR A SYRINGE OF 4.73mm INNER LUMEN DIAMETER] you can use (due to the limitations of the microsecond delay function and/or the stepper driver) are:
// Max Flow rate ~32 microlitres per second
// Min Flow rate ~0.4 microlitres per second
// These limits are due to the fact that the stepper motor becomes unstable when the time between a step is less than ~ 1000 microseconds and when the delay is greater than ~10000 microseconds
// To account for this we've designed the code so that it will compute the delay time necessary for a given flow rate,
// select from 4 stepping modes (Full-Stepping, Half-Stepping, Quarter-Stepping, Eigth-Stepping), and display an error if the flow rate is unsuitable.
// 
// The parameters which you can control are as follows: 
// 1) Flow Rate
// 2) Syringe Inner Lumen Diameter
// 3) Total Distance you want the syringe to be driven
//
//From iGEM Glasgow with love.
</P><P>
//Declare pin functions on Redboard [Set pins up as follows on microcontroller]
int stp = 2; 
int dir = 3;
int MS1 = 4;
int MS2 = 5;
int EN = 6;
</P><P>
//Declare variables for functions
char user_input;
float dt;
int x;
int y;
int state;
float delay_time; //The total time taken for one step
float step_dist = 25; //Distance pushed by one microstep (mm)
float syringe_x_section; //Cross Sectional area of syringe (mm2)
float final_step_no; //final number of steps (based on totalDist)
float flow_rate = 0.46; //in microliters per second.
float syringe_diam = 4.73; //diameter of the syringe inner lumen (mm)
float totalDist = 2; //total distance user wants syringe to travel (mm)
float delayLimit = 20000; //The upper limit of delay time
</P><P>
//Reset Easy Driver pins to default states
void resetEDPins(){</P><DL><DD>digitalWrite(stp, LOW);</DD><DD>digitalWrite(dir, LOW);</DD><DD>digitalWrite(MS1, LOW);</DD><DD>digitalWrite(MS2, LOW);</DD><DD>digitalWrite(EN, HIGH);</DD><DD>Serial.println(&quot;ED pins reset&quot;);</DD><DD>delay(10);</DD></DL><P>}
</P><P>
//Reverse default microstep mode function
void ReverseStepMode(){</P><DL><DD>Serial.println(&quot;Reversing in full step mode&quot;);</DD><DD>digitalWrite(dir, HIGH); //Pull direction pin low to move &quot;forward&quot;</DD><DD>digitalWrite(MS1, LOW); //Pull MS1, and MS2 high to set logic to 1/8th microstep resolution</DD><DD>digitalWrite(MS2, LOW);</DD><DD>for(x= 1; x&lt;final_step_no; x++)  //Loop the forward stepping enough times for motion to be visible</DD><DD>{</DD><DD>digitalWrite(stp,HIGH); //Trigger one step forward</DD><DD>delayMicroseconds(dt);</DD><DD>digitalWrite(stp,LOW); //Pull step pin low so it can be triggered again</DD><DD>delayMicroseconds(dt);</DD></DL><DL><DD>}</DD><DD>delay(100000000);</DD></DL><P>}
</P><P>
//Reverse default microstep mode function
void ReverseHalfStepMode(){</P><DL><DD>Serial.println(&quot;Reversing in Half-Step Mode&quot;);</DD><DD>digitalWrite(dir, HIGH); //Pull direction pin low to move &quot;forward&quot;</DD><DD>digitalWrite(MS1, HIGH); //Pull MS1, and MS2 high to set logic to 1/8th microstep resolution</DD><DD>digitalWrite(MS2, LOW);</DD><DD>for(x= 1; x&lt;final_step_no; x++)  //Loop the forward stepping enough times for motion to be visible</DD><DD>{</DD><DD>digitalWrite(stp,HIGH); //Trigger one step forward</DD><DD>delayMicroseconds(dt);</DD><DD>digitalWrite(stp,LOW); //Pull step pin low so it can be triggered again</DD><DD>delayMicroseconds(dt);</DD></DL><DL><DD>}</DD><DD>delay(100000000);</DD></DL><P>}
</P><P>
//Reverse default microstep mode function
void ReverseQuarterStepMode(){</P><DL><DD>Serial.println(&quot;Reversing in 1/4 Step Mode&quot;);</DD><DD>digitalWrite(dir, HIGH); //Pull direction pin low to move &quot;forward&quot;</DD><DD>digitalWrite(MS1, LOW); //Pull MS1, and MS2 high to set logic to 1/8th microstep resolution</DD><DD>digitalWrite(MS2, HIGH);</DD><DD>for(x= 1; x&lt;final_step_no; x++)  //Loop the forward stepping enough times for motion to be visible</DD><DD>{</DD><DD>digitalWrite(stp,HIGH); //Trigger one step forward</DD><DD>delayMicroseconds(dt);</DD><DD>digitalWrite(stp,LOW); //Pull step pin low so it can be triggered again</DD><DD>delayMicroseconds(dt);</DD></DL><DL><DD>}</DD><DD>delay(100000000);</DD></DL><P>}
</P><P>
//Reverse default microstep mode function
void ReverseEighthStepMode(){</P><DL><DD>Serial.println(&quot;Reversing in 1/8 Step Mode&quot;);</DD><DD>digitalWrite(dir, HIGH); //Pull direction pin low to move &quot;forward&quot;</DD><DD>digitalWrite(MS1, HIGH); //Pull MS1, and MS2 high to set logic to 1/8th microstep resolution</DD><DD>digitalWrite(MS2, HIGH);</DD><DD>for(x= 1; x&lt;final_step_no; x++)  //Loop the forward stepping enough times for motion to be visible</DD><DD>{</DD><DD>digitalWrite(stp,HIGH); //Trigger one step forward</DD><DD>delayMicroseconds(dt);</DD><DD>digitalWrite(stp,LOW); //Pull step pin low so it can be triggered again</DD><DD>delayMicroseconds(dt);</DD></DL><DL><DD>}</DD><DD>delay(100000000);</DD></DL><P>}
</P><P>
//Calculate Variables for Chosen Flow Rate
void CalculateVariables(){</P><DL><DD>Serial.println(&quot;Calculating Variables&quot;);</DD><DD>Serial.println(&quot; &quot;);</DD><DD>float step_dist = 25;</DD><DD>int i = 1;</DD><DD>float delay_time=0;</DD><DD>while ( delay_time &lt; 2180 || delay_time &gt; delayLimit ) {</DD><DD>step_dist = step_dist*2;</DD><DD>final_step_no=totalDist*100000/(step_dist); // Calculates the Final Steps required for the Total Distance specified</DD><DD>final_step_no = round(final_step_no);</DD></DL><DL><DD>syringe_x_section=PI*(syringe_diam*syringe_diam)/4; // Calculates Cross-Sectional Area of Syringe</DD></DL><DL><DD>delay_time = (step_dist*syringe_x_section*10)/flow_rate; // Calculates Delay Time Required for Specified Flow Rate</DD><DD>delay_time = round(delay_time);</DD></DL><DL><DD>if (i == 5) {</DD><DD>if (delay_time &gt; delayLimit) {</DD><DD>Serial.println(&quot;The delay time for the flow rate that you have specified is unsuitable with the syringe you have chosen.&quot;);</DD><DD>Serial.println(&quot;Please use a syringe with a SMALLER inner lumen diameter.&quot;);</DD><DD>delay(100000000);</DD></DL><DL><DD>}</DD><DD>else {</DD><DD>Serial.println(&quot;The delay time for the flow rate that you have specified is unsuitable with the syringe you have chosen.&quot;);</DD><DD>Serial.println(&quot;Please use a syringe with a LARGER inner lumen diameter.&quot;);</DD><DD>delay(100000000);</DD></DL><DL><DD>}</DD></DL><DL><DD>}</DD><DD>else{</DD><DD>i=i+1;</DD><DD>delay(100);</DD></DL><DL><DD>}</DD></DL><DL><DD>}</DD></DL><DL><DD>float (half_delay_time);</DD><DD>half_delay_time = delay_time/2;</DD><DD>dt = round(half_delay_time);</DD><DD>Serial.println(&quot;Delay Time (microseconds) =&quot;);</DD><DD>Serial.println(delay_time);</DD><DD>Serial.println(&quot;Half of delay time =&quot;);</DD><DD>Serial.println(half_delay_time);</DD><DD>Serial.println(&quot;Rounded Delay Time (microseconds) =&quot;);</DD><DD>Serial.println(dt);</DD><DD>Serial.println(&quot;Step Distance (microns) =&quot;);</DD><DD>Serial.println(step_dist/100);</DD><DD>Serial.println(&quot;total distance =&quot;);</DD><DD>Serial.println(totalDist);</DD><DD>Serial.println(&quot;Final Step no =&quot;);</DD><DD>Serial.println(final_step_no);</DD></DL><DL><DD>if (step_dist == 50) {</DD><DD>EighthStepMode();</DD></DL><DL><DD>}</DD></DL><DL><DD>else if (step_dist == 100) {</DD><DD>QuarterStepMode();</DD></DL><DL><DD>}</DD></DL><DL><DD>else if (step_dist == 200) {</DD><DD>HalfStepMode();</DD></DL><DL><DD>}</DD></DL><DL><DD>else if (step_dist == 400) {</DD><DD>FullStepMode();</DD></DL><DL><DD>}</DD></DL><P>}
</P><P>
//Default microstep mode function
void FullStepMode(){</P><DL><DD>Serial.println(&quot;Moving forward at default step mode.&quot;);</DD><DD>digitalWrite(dir, LOW); //Pull direction pin low to move &quot;forward&quot;</DD><DD>for(x= 1; x&lt;final_step_no; x++){  //Loop the forward stepping enough times for motion to be visible</DD><DD>digitalWrite(stp,HIGH); //Trigger one step forward</DD><DD>delayMicroseconds(dt);</DD><DD>digitalWrite(stp,LOW); //Pull step pin low so it can be triggered again</DD><DD>delayMicroseconds(dt);</DD></DL><DL><DD>}</DD><DD>Serial.println(&quot;Enter '1' into the serial port to begin reversing&quot;);</DD></DL><DL><DD>while (user_input != 1){</DD><DD>delay(500);</DD><DD>user_input = Serial.parseInt();</DD></DL><DL><DD>}</DD><DD>ReverseStepMode();</DD></DL><P>}
</P><P>
// 1/2 microstep foward mode function
void HalfStepMode() {</P><DL><DD>Serial.println(&quot;Stepping at 1/2 microstep mode.&quot;);</DD><DD>digitalWrite(dir, LOW); //Pull direction pin low to move &quot;forward&quot;</DD><DD>digitalWrite(MS1, HIGH); //Pull MS1 high, MS2 low to set logic to 1/2th microstep resolution</DD><DD>digitalWrite(MS2, LOW);</DD><DD>for(x= 1; x &lt; final_step_no; )  //Loop the forward stepping enough times for motion to be visible</DD><DD>{</DD><DD>digitalWrite(stp,HIGH); //Trigger one step forward</DD><DD>delayMicroseconds(dt);</DD><DD>digitalWrite(stp,LOW); //Pull step pin low so it can be triggered again</DD><DD>delayMicroseconds(dt);</DD><DD>x++;</DD><DD>}</DD></DL><DL><DD>Serial.println(&quot;Enter '1' into the serial port to begin reversing&quot;);</DD><DD>while (user_input != 1)</DD><DD>{</DD><DD>delay(500);</DD><DD>user_input = Serial.parseInt();</DD><DD>}</DD></DL><DL><DD>ReverseHalfStepMode();</DD></DL><P>}</P><P>// 1/4 microstep foward mode function
void QuarterStepMode()</P><DL><DD>{</DD><DD>Serial.println(&quot;Stepping at 1/4 step mode&quot;);</DD><DD>digitalWrite(dir, LOW); //Pull direction pin low to move &quot;forward&quot;</DD><DD>digitalWrite(MS1, LOW); //Pull MS1 low, MS2 high to set logic to 1/4 microstep resolution</DD><DD>digitalWrite(MS2, HIGH);</DD><DD>for(x= 1; x&lt;final_step_no; x++)  //Loop the forward stepping enough times for motion to be visible</DD><DD>{</DD><DD>digitalWrite(stp,HIGH); //Trigger one step forward</DD><DD>delayMicroseconds(dt);</DD><DD>digitalWrite(stp,LOW); //Pull step pin low so it can be triggered again</DD><DD>delayMicroseconds(dt);</DD><DD>}</DD></DL><DL><DD>Serial.println(&quot;Enter '1' into the serial port to begin reversing&quot;);</DD><DD>while (user_input != 1)</DD><DD>{</DD><DD>delay(500);</DD><DD>user_input = Serial.parseInt();</DD><DD>}</DD></DL><DL><DD>ReverseQuarterStepMode();</DD><DD>}</DD></DL><P>
// 1/8th microstep foward mode function
void EighthStepMode()</P><DL><DD>{</DD><DD>Serial.println(&quot;Stepping at 1/8th microstep mode.&quot;);</DD><DD>digitalWrite(dir, LOW); //Pull direction pin low to move &quot;forward&quot;</DD><DD>digitalWrite(MS1, HIGH); //Pull MS1, and MS2 high to set logic to 1/8th microstep resolution</DD><DD>digitalWrite(MS2, HIGH);</DD><DD>for(x= 1; x&lt;final_step_no; x++)  //Loop the forward stepping enough times for motion to be visible</DD><DD>{</DD><DD>digitalWrite(stp,HIGH); //Trigger one step forward</DD><DD>delayMicroseconds(dt);</DD><DD>digitalWrite(stp,LOW); //Pull step pin low so it can be triggered again</DD><DD>delayMicroseconds(dt);</DD><DD>}</DD></DL><DL><DD>Serial.println(&quot;Enter '1' into the serial port to begin reversing&quot;);</DD><DD>while (user_input != 1)</DD><DD>{</DD><DD>delay(500);</DD><DD>user_input = Serial.parseInt();</DD><DD>}</DD></DL><DL><DD>ReverseEighthStepMode();</DD><DD>}</DD></DL><P>// INITIALISATION
void setup() {</P><DL><DD>pinMode(stp, OUTPUT);</DD><DD>pinMode(dir, OUTPUT);</DD><DD>pinMode(MS1, OUTPUT);</DD><DD>pinMode(MS2, OUTPUT);</DD><DD>pinMode(EN, OUTPUT);</DD><DD>resetEDPins(); //Set step, direction, microstep and enable pins to default states</DD><DD>Serial.begin(9600); //Open Serial connection for debugging</DD><DD>Serial.println(&quot;Begin motor control&quot;);</DD><DD>Serial.println();</DD></DL><P>}
</P><P>// RUNNING OF PROGRAM
void loop() </P><DL><DD>{</DD><DD>Serial.println(&quot;Starting Main Loop&quot;);</DD><DD>digitalWrite(EN, LOW); //Pull enable pin low to allow motor control</DD><DD>resetEDPins();</DD><DD>CalculateVariables();</DD><DD>}</DD></DL></DIV><P>Due to limitations of the arduino microcontroller, it was found that there were lower and upper limits to the delay times between each execution of a step by the stepper motor. The suitable range of delay times was found to be between 2180 and 20000 milliseconds. Thus, in order to obtain a desired flow rate, it would be necessary to use different sized syringes for different flow rates.
</P><P>Due to time restrictions, we did not did not have any more time to work on the stepper motor code which, ideally, we would have done to assist the Edinburgh iGEM team further. If we had sufficient time, we would have liked to develop the code to a point where multiple syringes would be controlled by the same code and where one of them would be able to switch between flow rates in response to a user input such as the press of a button. Additionally, it would have been useful if the system had been more autonomous and had a way of detecting the fluorescent intensity of cells and responding appropriately. 
</P></DIV></DIV><FOOTER class="marketing-site-footer"><DIV class="row medium-unstack"><DIV class="medium-4 columns"><H4 class="marketing-site-footer-name">iGEM 2017 Glasgow</H4><P>Using synthetic biology to create a biosensor for detection of <I>Campylobacter jejuni</I>, a bacteria linked to food poisoning.</P></DIV><DIV class="medium-4 columns"><H4 class="marketing-site-footer-title">Contact Info</H4><DIV class="marketing-site-footer-block"><P>                    iGEM 2017 Glasgow 
Wilkins Teaching Laboratory
                    Bower Building 
                    University of Glasgow</P></DIV><DIV class="marketing-site-footer-block"><P>igem.glasgow2017@gmail.com</P></DIV></DIV><DIV class="medium-4 columns"><H4 class="marketing-site-footer-title">Sponsors</H4></DIV></DIV><DIV class="marketing-site-footer-bottom"><DIV class="row large-unstack align-middle"><DIV class="column"><UL class="menu marketing-site-footer-bottom-links"><LI><A href="https://2017.igem.org/Team:Glasgow">Home</A></LI></UL></DIV></DIV></DIV></FOOTER></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
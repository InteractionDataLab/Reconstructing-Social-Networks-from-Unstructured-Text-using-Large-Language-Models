<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_SUSTech_Shenzhen_css_threejs_OBJLoader_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:SUSTech Shenzhen/css/threejs/OBJLoader.js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/**
</P><PRE>* @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
*/
</PRE><P>THREE.OBJLoader = function ( manager ) {
</P><P>	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
</P><P>};
</P><P>THREE.OBJLoader.prototype = {
</P><P>	constructor: THREE.OBJLoader,
</P><P>	load: function ( url, onLoad, onProgress, onError ) {
</P><P>		var scope = this;
</P><P>		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {
</P><P>			onLoad( scope.parse( text ) );
</P><P>		} );
</P><P>	},
</P><P>	parse: function ( text ) {
</P><P>		function vector( x, y, z ) {
</P><P>			return new THREE.Vector3( x, y, z );
</P><P>		}
</P><P>		function uv( u, v ) {
</P><P>			return new THREE.Vector2( u, v );
</P><P>		}
</P><P>		function face3( a, b, c, normals ) {
</P><P>			return new THREE.Face3( a, b, c, normals );
</P><P>		}
</P><P>		var object = new THREE.Object3D();
		var geometry, material, mesh;
		var face_offset = 0;
</P><P>		function add_face( a, b, c, normals_inds ) {
</P><P>			if ( normals_inds === undefined ) {
</P><P>				geometry.faces.push( face3(
					parseInt( a ) - (face_offset + 1),
					parseInt( b ) - (face_offset + 1),
					parseInt( c ) - (face_offset + 1)
				) );
</P><P>			} else {
</P><P>				geometry.faces.push( face3(
					parseInt( a ) - (face_offset + 1),
					parseInt( b ) - (face_offset + 1),
					parseInt( c ) - (face_offset + 1),
					[
						normals[ parseInt( normals_inds[ 0 ] ) - 1 ].clone(),
						normals[ parseInt( normals_inds[ 1 ] ) - 1 ].clone(),
						normals[ parseInt( normals_inds[ 2 ] ) - 1 ].clone()
					]
				) );
</P><P>			}
</P><P>		}
</P><P>		function add_uvs( a, b, c ) {
</P><P>			geometry.faceVertexUvs[ 0 ].push( [
				uvs[ parseInt( a ) - 1 ].clone(),
				uvs[ parseInt( b ) - 1 ].clone(),
				uvs[ parseInt( c ) - 1 ].clone()
			] );
</P><P>		}
</P><P>		function handle_face_line(faces, uvs, normals_inds) {
</P><P>			if ( faces[ 3 ] === undefined ) {
</P><P>				add_face( faces[ 0 ], faces[ 1 ], faces[ 2 ], normals_inds );
</P><P>				if (!(uvs === undefined) &amp;&amp; uvs.length &gt; 0) {
</P><P>					add_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 2 ] );
</P><P>				}
</P><P>			} else {
</P><P>				if (!(normals_inds === undefined) &amp;&amp; normals_inds.length &gt; 0) {
</P><P>					add_face( faces[ 0 ], faces[ 1 ], faces[ 3 ], [ normals_inds[ 0 ], normals_inds[ 1 ], normals_inds[ 3 ] ]);
					add_face( faces[ 1 ], faces[ 2 ], faces[ 3 ], [ normals_inds[ 1 ], normals_inds[ 2 ], normals_inds[ 3 ] ]);
</P><P>				} else {
</P><P>					add_face( faces[ 0 ], faces[ 1 ], faces[ 3 ]);
					add_face( faces[ 1 ], faces[ 2 ], faces[ 3 ]);
</P><P>				}
</P><P>				if (!(uvs === undefined) &amp;&amp; uvs.length &gt; 0) {
</P><P>					add_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] );
					add_uvs( uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] );
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		// create mesh if no objects in text
</P><P>		if ( /^o /gm.test( text ) === false ) {
</P><P>			geometry = new THREE.Geometry();
			material = new THREE.MeshLambertMaterial();
			mesh = new THREE.Mesh( geometry, material );
			object.add( mesh );
</P><P>		}
</P><P>		var vertices = [];
		var verticesCount = 0;
		var normals = [];
		var uvs = [];
</P><P>		// v float float float
</P><P>		var vertex_pattern = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
</P><P>		// vn float float float
</P><P>		var normal_pattern = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
</P><P>		// vt float float
</P><P>		var uv_pattern = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
</P><P>		// f vertex vertex vertex ...
</P><P>		var face_pattern1 = /f( +\d+)( +\d+)( +\d+)( +\d+)?/;
</P><P>		// f vertex/uv vertex/uv vertex/uv ...
</P><P>		var face_pattern2 = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/;
</P><P>		// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...
</P><P>		var face_pattern3 = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/;
</P><P>		// f vertex//normal vertex//normal vertex//normal ... 
</P><P>		var face_pattern4 = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/
</P><P>		//
</P><P>		var lines = text.split( '\n' );
</P><P>		for ( var i = 0; i &lt; lines.length; i ++ ) {
</P><P>			var line = lines[ i ];
			line = line.trim();
</P><P>			var result;
</P><P>			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {
</P><P>				continue;
</P><P>			} else if ( ( result = vertex_pattern.exec( line ) ) !== null ) {
</P><P>				// [&quot;v 1.0 2.0 3.0&quot;, &quot;1.0&quot;, &quot;2.0&quot;, &quot;3.0&quot;]
</P><P>				geometry.vertices.push( vector(
					parseFloat( result[ 1 ] ),
					parseFloat( result[ 2 ] ),
					parseFloat( result[ 3 ] )
				) );
</P><P>			} else if ( ( result = normal_pattern.exec( line ) ) !== null ) {
</P><P>				// [&quot;vn 1.0 2.0 3.0&quot;, &quot;1.0&quot;, &quot;2.0&quot;, &quot;3.0&quot;]
</P><P>				normals.push( vector(
					parseFloat( result[ 1 ] ),
					parseFloat( result[ 2 ] ),
					parseFloat( result[ 3 ] )
				) );
</P><P>			} else if ( ( result = uv_pattern.exec( line ) ) !== null ) {
</P><P>				// [&quot;vt 0.1 0.2&quot;, &quot;0.1&quot;, &quot;0.2&quot;]
</P><P>				uvs.push( uv(
					parseFloat( result[ 1 ] ),
					parseFloat( result[ 2 ] )
				) );
</P><P>			} else if ( ( result = face_pattern1.exec( line ) ) !== null ) {
</P><P>				// [&quot;f 1 2 3&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, undefined]
</P><P>				handle_face_line([ result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] ]);
</P><P>			} else if ( ( result = face_pattern2.exec( line ) ) !== null ) {
</P><P>				// [&quot;f 1/1 2/2 3/3&quot;, &quot; 1/1&quot;, &quot;1&quot;, &quot;1&quot;, &quot; 2/2&quot;, &quot;2&quot;, &quot;2&quot;, &quot; 3/3&quot;, &quot;3&quot;, &quot;3&quot;, undefined, undefined, undefined]
</P><P>				handle_face_line(
					[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces
					[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //uv
				);
</P><P>			} else if ( ( result = face_pattern3.exec( line ) ) !== null ) {
</P><P>				// [&quot;f 1/1/1 2/2/2 3/3/3&quot;, &quot; 1/1/1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot; 2/2/2&quot;, &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, &quot; 3/3/3&quot;, &quot;3&quot;, &quot;3&quot;, &quot;3&quot;, undefined, undefined, undefined, undefined]
</P><P>				handle_face_line(
					[ result[ 2 ], result[ 6 ], result[ 10 ], result[ 14 ] ], //faces
					[ result[ 3 ], result[ 7 ], result[ 11 ], result[ 15 ] ], //uv
					[ result[ 4 ], result[ 8 ], result[ 12 ], result[ 16 ] ] //normal
				);
</P><P>			} else if ( ( result = face_pattern4.exec( line ) ) !== null ) {
</P><P>				// [&quot;f 1//1 2//2 3//3&quot;, &quot; 1//1&quot;, &quot;1&quot;, &quot;1&quot;, &quot; 2//2&quot;, &quot;2&quot;, &quot;2&quot;, &quot; 3//3&quot;, &quot;3&quot;, &quot;3&quot;, undefined, undefined, undefined]
</P><P>				handle_face_line(
					[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces
					[ ], //uv
					[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //normal
				);
</P><P>			} else if ( /^o /.test( line ) ) {
</P><P>				// object
</P><P>				if (!(geometry === undefined)) {
</P><P>					face_offset = face_offset + geometry.vertices.length;
</P><P>				}
</P><P>				geometry = new THREE.Geometry();
				material = new THREE.MeshLambertMaterial();
</P><P>				mesh = new THREE.Mesh( geometry, material );
				mesh.name = line.substring( 2 ).trim();
				object.add( mesh );
</P><P>				verticesCount = 0;
</P><P>			} else if ( /^g /.test( line ) ) {
</P><P>				// group
</P><P>			} else if ( /^usemtl /.test( line ) ) {
</P><P>				// material
</P><P>				material.name = line.substring( 7 ).trim();
</P><P>			} else if ( /^mtllib /.test( line ) ) {
</P><P>				// mtl file
</P><P>			} else if ( /^s /.test( line ) ) {
</P><P>				// smooth shading
</P><P>			} else {
</P><P>				// console.log( &quot;THREE.OBJLoader: Unhandled line &quot; + line );
</P><P>			}
</P><P>		}
</P><P>		for ( var i = 0, l = object.children.length; i &lt; l; i ++ ) {
</P><P>			var geometry = object.children[ i ].geometry;
</P><P>			geometry.computeCentroids();
			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();
</P><P>		}
</P><P>		return object;
</P><P>	}
</P><P>};
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
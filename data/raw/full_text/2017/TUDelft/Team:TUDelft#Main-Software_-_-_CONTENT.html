<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_TUDelft_Main-Software skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:TUDelft/Main-Software</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><DIV class="col s12 m10 l8"><MENU id="tocc" class="hide-on-med-and-down"><H5>Software Tool:</H5><UL><LI><A href="#intro-scroll">Introduction</A></LI><LI><A href="#database-scroll">Database Initiation</A></LI><LI><A href="#retrieve-scroll">Retrieve from NCBI</A></LI><LI><A href="#motifsearch-scroll">Motif Search</A></LI><LI><A href="#postprocessing-scroll">Post Processing</A></LI><LI><A href="#off_targeting-scroll">Off Targeting Tool</A></LI></UL></MENU><UL class="collapsible popout"><LI><DIV class="collapsible-header">Motif finder</DIV><DIV class="collapsible-body"><DIV class="center-align"><A class="btn" href="https://static.igem.org/mediawiki/2017/1/11/T--TUDelft--2017_igemtudelft.zip" style="color: white">DOWNLOAD THE MOTIF FINDER TOOL</A></DIV><H3>Documentation</H3><P id="intro-scroll" class="scrollspy">These scripts are intended for the retrieval of antibiotic resistance encoding sequences from online databases, finding conserved regions in said sequences, postprocessing them to comply to the Cas13a crRNA requirements, and finally showing this and the relevant statistics visually.</P><P>This is the online documentation for our scripts used during our iGEM project. Note that most of the documentation is found in the code as well and that a lot of it is actually auto generated from the code. If you are an advanced programmer intending to build upon this software, you can definitely skip this and go straight into the code itself (Completely safe).
            </P><P>All scripts are written in Python, but there are sometimes calls from Python to other programs. How to install those additional programs is explained below.
            </P><P>Installation of Python can best be done by downloading the Anaconda distribution. You need to install Python 3.6. It can work with 3.x, however this has not been tested. It will not work with Python 2.x or lower. Anaconda will also include the conda package manager. With conda you can install python packages much easier, but you are free to stick with the regular python with pip.
            </P><P>You can call our scripts from the command line. If you are on Windows you can better use the Anaconda Prompt, which will automatically be installed if you install the Anaconda distribution. If you are on a *NIX system (Mac OS for example), you can make use of the build-in terminal. In the documentation we provide command line examples by prefixing it with a dollar sign $.
            </P><P>Calling the Python script from the command line can be done in different ways. The easiest way is to prefix it with python or python3 if you have python 2 also installed. The scripts do include a shebang, so if you are on a *NIX system you can make it an executable and run it without.
            </P><P>The command line utility is set up with the build-in argparse module. This will work like many other command line utilities. So to give variables you set a flag and after that give the variable, like this: (-b antibiotic_molecule). We also make use of positional arguments. Those do not have these flags and must be included all the way at the end. This is important to remember, and can be confusing since the help includes the positional arguments first and then the positional. When calling the script you have to turn it around.
            </P><P>All scripts have build-in help. You can call it by passing '-h'. For example: $ python3 meme_process.py -h.
            </P><H3>Setting up the database</H3><P id="database-scroll" class="scrollspy">This is about setting up the database from the CARD database. The database will just be implemented in your filesystem because that is the easiest way to do it.
            </P><P>Script: card_reader.py Internal dependencies: card_functions.py, custom_functions.py Requirements: Python3, BeautifulSoup, Internet Estimated time: a few hours (Remark: There is no parallel execution, if you know about parallel programming you can probably change this. 'processGenes(gene, BASE)' should be moved to a new thread every time it is called.)

            </P><H4>Set-Up</H4><P>First install BeautifulSoup, this will be very easy to install with the use of conda.</P><P>You now can use the script. Take a look at the help to see how it works. For you convenience the build-in help is also shown here:
            </P><P>$ python3 card_reader.py -h</P><P>usage: card_reader.py [-h] [-b BASE] [-l LINK] [-n NAME] ...
            </P><P>Run the webcrawler on the meme database
            </P><P>positional arguments: relations The relations which to follow for the recursive search. DEFAULT=['confers_resistance_to',
                 'confers_resistance_to_drug']
            </P><P>Optional arguments:<B> -h, --help:</B> show this help message and exit<B> -b BASE, --base BASE:</B> The location of the CARD database. DEFAULT='https://card.mcmaster.ca'
                <B> -l LINK, --link LINK:</B> The link were to start searching. DEFAULT='/ontology/36008'
                <B> -n NAME, --name NAME:</B> The name of the folder were everything will be saved. DEFAULT='antibiotic molecule'
            </P><H4>Additional information about the variables</H4><P><B>BASE:</B> The current domain name of the CARD database. You should check if it is still online and not moved, otherwise you don't have to touch this.
            </P><P><B>LINK:</B> The link where you want to start. 36008 are the antibiotic molecules, but there are also other options to start, like to look at the mechanisms. Take a look at 36006 for the options on this.
            </P><P><B>NAME:</B> The name of the folder where everything will be saved. For 36008 this is of course antibiotic molecule.
            </P><P><B>RELATIONS:</B> The relations the recursive search follows. This is a list of positional arguments and therefore should be passed to the script at the end of the line. By default it always goes to direct inheritance (is_a), but there are more relations as well. Take a look at 40324 for more options.
            </P><P>So for example:
                $ python3 card_reader -b <A href="https://card.mcmaster.ca/" target="_blank">https://card.mcmaster.ca</A> -l /ontology/36008 -n antibiotic_molecule confers_resistance_to confers_resistance_to_drug
            </P><P>Starts the default process. It looks for the antibiotic_molecule drug resistance conferring genes.
            </P></DIV></LI><LI><DIV class="collapsible-header">
                        card_functions.py
                    </DIV><DIV class="collapsible-body"><DIV class="row center"><P>If you want you can take a look at the auto generated documentation for the functions below:
                            </P><P>Created on Mon Jul 10 16:32:22 2017 @author: hielke This module contains functions for processing the CARD database with web crawling
                            </P><H5>Functions</H5><P>getSoup(url) From a given url, returns the object containing the parsed html
                            </P><P>getSubTerms(entry, BASE) Collect the sub-Term(s) from the given card entry Returns dict with keys as relation and list with the entries
                            </P><P>getSubTermsFromSoup(soup) Collect the sub-Term(s) from the given soup
                            </P><P>processGenes(entry, BASE) processes a gene entry or an entry to multiple by producing the fasta file of the DNA sequence
                            </P><P>saveFasta(fastaDNA, webID) from the fasta data, create a fastafile
                            </P></DIV></DIV></LI></UL><H3>Search from the NCBI</H3><P id="retrieve-scroll" class="scrollspy">Sometimes you only want to look into one specific gene and all its variants. The CARD database already contains the homologous sequences and so, you don't know about the variants in one gene. For this you can search the NCBI for the variants. This however might give you some trouble, because sometimes a gene is annotated, but doesn't have its own entry. Therefore, we wrote a small script that automatically selects the annotated region and retrieves that instead.
            </P><P>Script: retrieve_from_ncbi.py Internal depencies: custom_functions.py Requirements: Python3, BioPython, Internet
            </P><P>Estimated Time: A minute or a bit more.</P><H4>Set-Up</H4><P>First install BioPython. Again, using conda will give you the highest success rate.
            </P><P>Now you can use the script. We put the help here again for your convenience:<SPAN class="code"> $ python3 retrieve_from_ncbi.py -h</SPAN></P><P>usage: retrieve_from_ncbi.py [-h] [-m MAIL] [-g GENE] ...
            </P><P>A script to retrieve all genes from the NCBI database, and save them. It is also able to retrieve genes that have no own entry but are only annotated.
            </P><P>Positional arguments: Organisms: At the end you can optionally specify the organisms you want to filter on.
            </P><P>Optional arguments:<B> -h, --help:</B> show this help message and exit<B> -m MAIL, --mail MAIL:</B> You have to give your email address in order to be allowed to interact with the NCBI API.<B>-g GENE, --gene GENE:</B> The gene from which you want to retrieve all the variants
            </P><H4>Additional information about the variables</H4><P><B>MAIL:</B> If you overuse the server you will be contacted. Please take care you obey to this, because they might take further actions in preventing you to access the database or adding more restrictions for all users.
            </P><P><B>GENE:</B> Give the gene name to search for. You can take a look at NCBI first to see if it is really listed like this.
            </P><P><B>ORGAS:</B> The organisms you want to filter on. These are optional parameters and have to be given at the end or the line. Selecting the organisms usually gives much better results.
            </P><P>For example, for the mecA search we used these arguments: <SPAN class="code">$ python3 retrieve_from_ncbi.py -m example@mail.com -g mecA <I>Streptococcus Staphylococcus</I></SPAN></P><H3>Motif search</H3><P id="motifsearch-scroll" class="scrollspy">After you set up your database, or retrieved your sequences , you want to submit the motif search jobs to it. This part of the documentation is about how to do that. Basically, this process consists of two steps. First you have to gather all sequences you want and put them in one file. Next, you want to run multiple motif searches on these files. Results may vary so you need to do tweaking here.
            </P><P>Script: meme_process.py Internal depencies: meme_functions.py, custom_functions.py Requirements: Python3, MEME, BASH
            </P><P>Estimated time: a few hours to a day or more. (Meme is not a very efficient program. We do not recommend going over the 200 unique sequences per batch. The program runs with parallel computing, but not really optimal. So it does not take into account the cores and all cores will not finish simultaneously.</P><H4>Set-Up</H4><P>First you have to comply to the BASH requirement. This is in fact the default shell your terminal will run in a *NIX system. We use this a few times because of laziness. However you need to be on a *NIX system anyway because otherwise you cannot install MEME. If you run Windows you might want to create a virtual box or install cygwin. You can find installation instructions for MEME online: <A href="http://meme-suite.org/doc/install.html?man_type=web" target="_blank">http://meme-suite.org/doc/install.html?man_type=web</A>.
            </P><P>Help is given here</P><P><SPAN class="code">$ python3 meme_process.py -h</SPAN></P><P>usage: meme_process.py [-h] [-b BEGIN] [-e END] [-s STEP] [-m MOTIFS] [-x EXTENSION] [-r ROOT] mode ...
            </P><P>What kind of process related to meme you want to run
            </P><P>positional arguments: mode: The mode you want to run in. Choose from: ['gather', 'meme'] gather: Creates one fastafile from all fastafiles. Not all the options are used for this one. meme: Start the meme process with the folowing options: dirs: Optional different folders in which to execute the same process
            </P><P>optional arguments:<B> -h, --help:</B> show this help message and exit<B> -b BEGIN, --begin BEGIN:</B> For the range of the amount of sites to visit, this is the beginning. (Including) DEFAULT=2<B> -e END, --end END:</B> For the range of the amount of sites to visit, this is the end. (Excluding) DEFAULT=7<B> -s STEP, --step STEP:</B> The step size for the range of the amount of sites to visit. DEFAULT=1<B> -m MOTIFS, --motifs MOTIFS:</B> The amount of motifs you want to find, otherwise a bit of a clever algorithm tries to find these.<B> -x EXTENSION, --extension EXTENSION:</B> The extension of the file that contains all fasta sequences, it doesn't allows temp in the filename. DEFAULT=.multiple.fasta
                <B> -r ROOT, --root ROOT:</B> Give the root folder in which the process has to work on all available directories, if you want to do the same process in a given set of directories, provide them at the end of the command, and leave this one
            </P><H4>Additional information about the variables</H4><P>As already mentioned, there are two parts represented as two modes in the command line utility. These modes are 'gather' and 'meme'. Specify these after the flags (with the dash), but before the optional list of directories to work in.
            </P><P>There are also two ways the command line utility work. It can either work in all subdirectories for a given ROOT, or it takes the remainder of the command line input as directories to work from.
            </P><P>For the gathering process, specify only which directory/directories it has to work on. It will now automatically create a file with all the sequences found in the whole directory (recursive). The file will be called gathered.multiple.fasta. There is also a file called temp.gathered.multiple.fasta. This file has incorrect line break encoding for the meme software to work, but is left there because the correct line break encoding is not recognized by the Windows operating system and old Mac operating systems. (This is the “classic” Mac OS. In Mac OS X and newer versions this has been changed in order to be POSIX compliant.) So if you are a Windows user you can check this file instead.
            </P><P>For the meme process, you have a lot more options.
            </P><P><B>EXTENSION:</B> Only set this one if you created your .fasta file collection yourself. The default meets the file naming convention used by the 'gather' process, which is ending on .multiple.fasta and not containing temp.
            </P><P><B>BEGIN, END, STEP:</B> These variables are used to create the range of sites in which the meme processes will look for motifs. MEME has to be set to a maximum number of sites that each motif covers. A higher number meets more errors in the motifs, while a lower number means less coverage. You have to find the sweet spots. The destination folder will, in turn, be suffixed with the number of sites, like meme_out_10. These settings also will determine the number of processes that are spawned, so ideally you start the number of processes equal to the amount of cores (or threads if your cores support hyper threading), or leave one free so that you can keep working on other things without much lag.
            </P><P><B>MOTIFS:</B> This variable determines how much motifs will be found. If you collect more you have a higher success rate, but there is of course a max to this. There is however also a mechanism that determines when to stop searching so that your computer doesn't run unnecessarily.
            </P><P>So for example, for gathering all sequences in one file:
            </P><P><SPAN class="code">$ python3 meme_process.py -r antibiotic_molecule_36008 gather
                </SPAN></P><P>and then specifically initiate the meme processes on two directories
            </P><P><SPAN class="code">$ python3 meme_process.py -m 50 meme glycopeptide_antibiotic_36220 elfamycin_antibiotic_37618
                </SPAN></P><H3>Postprocessing</H3><P id="postprocessing-scroll" class="scrollspy">After you collected your motifs you must collect the motifs that fulfill the requirements for Cas13a and that don't have too many incorrect spots in your motifs. The MEME program will give you its output in different formats. There is HTML, XML, and a simple TXT file. You can view the HTML for quick reference. The TXT file, however, is used by BioPython for parsing it in memory. The TXT file is also the only file that is created on the fly, and not at the end. This means that when a MEME process is stopped in the middle, there are still possibilities to retrieve the information from the file. The BioPython parser is however not capable of doing that. Besides, there are problems with different versions of the MEME program. That's why we have rewritten this parser partly and included it in the folder.
            </P><P>Script: meme_postprocess.py Internal dependencies: meme_functions.py, custom_functions.py Requirements: Python3, BioPython, BASH (only one option)
            </P><P>Estimated time: less than a few minutes
            </P><H4>Set-Up</H4><P>For visualizing the results we use matplotlib. We recommend you to download this with conda. The only function that requires you to have BASH is the statistics one. We presume that if you already came this far and downloaded MEME you are having the control over a BASH shell, but you can also rewrite this one yourself if you want to. You have to look in meme_postprocess.py and then find the function.
            </P><P>Again the help is shown here
            </P><P><SPAN class="code">$ python3 meme_postprocess.py -h
                </SPAN></P><P>usage: meme_postprocess.py [-h] [-s STATISTICS] [-f FILE] [-d DIR] [-v] ...
            </P><P>A program to calculate the motifs that pass our requirements and plot them in a meaningful way
            </P><P>positional arguments: dirs List of dirs to work in the meme_output*
            </P><P>optional arguments:<B> -h, --help:</B> show this help message and exit<B> -s STATISTICS, --statistics STATISTICS:</B> Give statistics of the given directory<B> -f FILE, --file FILE:</B> Give a file and calculate from this file the motifs that did pass<B> -d DIR, --dir DIR:</B> A directory to work in all subdirectories<B> -v, --verbose:</B> Execute the code in a more verbose manner
            </P><H4>Additional information for the variables</H4><P><B>VERBOSE:</B> Here we also have a verbose flag. You do not have to give a variable here, but just give it so that you will receive a more verbose output.
            </P><P><B>FILE:</B> One way to use this script is just by simply giving the path to a file and you will simply get all the motifs back that pass the criteria.
            </P><P><B>DIR:</B> How to work is again the same as with the meme_process.py. You either specify the directory to work in all subdirectories, or you specify the directories you work from on the end of the line.
            </P><P><B>DIRS:</B> So these are the directories you work in, if you do not give a dire with '-d'.
            </P><UL class="collapsible popout" data-collapsible="expandable"><LI><DIV class="collapsible-header">
                        meme_functions.py
                    </DIV><DIV class="collapsible-body"><DIV class="row"><P>If you want you can take a look at the auto generated documentation for the functions below:
                            </P><P>@author: hielke This module is related to function for sending the correct jobs to the meme utility, and for post-processing the results from it.
                            </P><H5>Functions</H5><P>memeCmd(file:str, sites:int, motifs:int, width:int=24) -&gt; str Create a command for the terminal running the meme process on 'file' with a maximum number of sites to check and a number of motifs to find. The number of motifs largely determines the time the program will run. The number of sites will largely determine how good the results will be. If you attempt to cover more sites, the result will have more SNPs in them. Optionally, you can specify the width of the motif (default is 24).

                            </P><P>memeOnFile(f:str) This function is a factory. It returns a function. The returned function is the memeProcess function, but with the file already set.

                            </P><P>memeProcess(f:str, i:int, n:int) -&gt; None This executes the meme program. It spawns as a new process, not as a new thread.
                            </P><P>only_one(motif, loc) Returns false if in the counts array there is only one base. (So a 100 % score.) (This might be a little strict though, a motif could contain valuable data, but still got thrown away while it might be just one sequence that ruins the 100 % score.)
                            </P><P>passed(motif) Returns true if the motif passes the requirements for Cas13a. * The is GC between 40 and 60 percent. * No more than 2 SNPs. * If there are 2 SNPs, don't allow any between position 9 and 16, that is the place of the seed region.
                            </P><P>wrong(motif) Returns the amount of SNPs and the place it is in.
                            </P></DIV></DIV></LI><LI><DIV class="collapsible-header">
                        custom_function.py
                    </DIV><DIV class="collapsible-body"><DIV class="row"><H5>And last, some general functions we used sometimes.
                            </H5><P>custom_function.py @author: hielke Just some useful general functions. The first are available on all operating systems, but the second half requires the use of *NIX operating system. (Like mac, or Linux, but Windows with cygwin installed might also mentioned.) The functions of the second half are only used in the scripts related to the meme program which by itself can only be installed on *NIX operating systems.
                            </P><P>cd(newdir, verbose=True) performs a change of directory, but with 'with' context manangement
                            </P><P>fileCat(extension, verbose=True, Windows=False) In the current folder collect all the files with the extension 'extension' recursively and catenate them. It will not take into account files that already have the word multiple prefixed to their extension. The last condition makes sure this function can be repeated without collecting duplicates. As a bonus converts the newline character to standard Creates file temp.gathered.multiple.extension with unaltered newline characters and file gathered.multiple.extension with altered newline characters NB. Windows might experience problems with this. so if you want you can pass windows=True in the function. NB2. Requires sed version 4.2.2, because of the -z option. Usually you will find it any modern *NIX based OS.
                            </P><P>grouper(iterable, n, fillvalue=None) Collect data into fixed-length chunks or blocks &gt;&gt;&gt; grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx
                            </P><P>logit(f) # A decorator for logging all the important information
                            </P><P>mkdir(entry) Creates a directory from an entry, checks also if already exists
                            </P><P>nonEmptyDir() -&gt; bool Lists all nonempty directories recursively NB. Returns a filter object (an iterator) Requires *NIX based OS.
                            </P><P>saveCat(*args) catenates all iterables in the input, and leaves out the None types if all are None, return None
                           </P><P>sh(cmd, verbose=True) Returns the stdout of the shell command as an iterator over the lines. The lines are strip()-ed.
                            </P></DIV></DIV></LI></UL></DIV><UL class="collapsible popout"><LI><DIV class="collapsible-header">Off-targeting tool</DIV><DIV class="collapsible-body"><DIV class="center-align"><A class="btn" href="https://static.igem.org/mediawiki/2017/4/48/T--TUDelft--iGEM_TUDelft_Off_Target_Cas13a.zip" style="color: white">DOWNLOAD THE OFF-TARGETING TOOL</A></DIV><H3>Documentation</H3><P id="off_targeting-scroll" class="scrollspy">These scripts are intended for determining the off-target activity of a given crRNA when encountering a specific genome. This is an implementation of a kinetic model of CRISPR-Cas off-targeting rules (<A href="www.biorxiv.org/content/early/2017/05/30/143602">Klein et al. 2017</A>) that has been adapted for Cas13a. Please find an elaborate description of the model <A href="https://2017.igem.org/Team:TUDelft/Model/Off_Targeting">here</A></P><H3>Software requirements</H3><P>Python (anaconda) distribution with the following libraries installed:</P></DIV></LI><LI>Numpy</LI><LI>Matplotlib</LI><LI>Biopython</LI><LI>h5py</LI></UL><H3>Running the software</H3><P><B>iGEM_Off_Target_Cas13a.py</B> can be run as a command line utility in the Anaconda prompt for calculating the cleavage probability for every possible frame in the input sequence.</P><P>Please first ensure that the current directory matches the directory where the program is filed, as well as all required input files. </P><P>In the command line, run:</P><P>python iGEM_Off_Target_Cas13.py gRNA genome file_in file_out</P><DL><LI>gRNA: the sequence of the spacer 5’ to 3’. The program can handle both thymine (T) and uracyl (U) and will convert them automatically.</LI><LI>genome: the genbank file containing the genomic information to calculate the off-target activity for.</LI><LI>file_in: text file containing the values for model parameters $\Delta C$, $\Delta I$ and the length of the guide.</LI><LI>File_out: output file to be written with .hdf5 file extension</LI></DL><P>For example:</P><P>python iGEM_Off_Target_Cas13a.py ACTTTACTCCCTTCCTCCCCGCTGAAAG TcR.gb parameters.txt my_output_file.hdf5</P><H3>Output file</H3><P>An output file (file_out.hdf5) will be written to the current directory. This dataset contains the scores for all possible frames along the input genome which the crRNA can target (assuming it is all converted to RNA in equal amounts): ‘forward’ and ‘reversed’.</P><P>Here is an example of how to load them into Python for further treatment and visualization:</P><P>I=h5py.File(‘file_out.hdf5’,’r’)</P><P>Pclv_forward=np.array(I[‘forward’])</P><P>Pclv_reverse=np.array(I[‘reversed’])</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
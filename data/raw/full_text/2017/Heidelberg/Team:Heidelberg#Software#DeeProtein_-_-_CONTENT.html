<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Heidelberg_Software_DeeProtein skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Heidelberg/Software/DeeProtein</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><DIV class="container"><DIV class="navbar-header"><A type="button" data-canvas="body" id="sidebarCollapse" class="navbar-toggle" data-toggle="offcanvas" data-target="#sidebar" style="color: #393939;margin-top: 9px;">NAVIGATION
                    </A></DIV><DIV class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"><UL class="nav navbar-nav pull-right"><LI class="dropdown"><A href="https://2017.igem.org/Team:Heidelberg/Team">People </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Team">Team</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Attributions">Attributions</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Sponsoring">Sponsoring</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/For_Judges">For Judges</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Jamboree">Giant Jamboree</A></LI></UL><LI class="dropdown"><A href="https://2017.igem.org/Team:Heidelberg/Description">Project </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Description">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Design">Background &amp; Design </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Pace">PACE</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Predcel">PREDCEL</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Results">Results Summary</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Validation">Software Validation</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Organosilicons">Organosilicons</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Protein_Interaction">Protein Interaction</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Cytochrome_Engineering">Cytochrome Engineering</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Optogenetics">Optogenetics</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/CRISPR">CRISPR Cas9</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/InterLab">InterLab Study</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Achievements">Achievements</A></LI><LI class="dropdown"><A href="https://2017.igem.org/Team:Heidelberg/Parts">Parts </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Basic_Part">Basic Parts</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Composite_Part">Composite Parts</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Improved_Part">Improved Part</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Part_Collection">Parts Collection</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Part_List">Part List</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/RFC">RFC</A></LI><LI class="dropdown"><A href="https://2017.igem.org/Team:Heidelberg/Model">Modeling </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Phage_Titer">Phage Titer</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Mutagenesis_Induction">Mutagenesis Induction</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Mutation_Rate_Estimation">Mutation Rate Estimation</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Lagoon_Contamination">Lagoon Contamination</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Medium_Consumption">Medium Consumption</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Tools">Interactive Web Tools</A></LI><LI class="dropdown"><A href="https://2017.igem.org/Team:Heidelberg/Software">Software </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software">AiGEM Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software/DeeProtein">DeeProtein</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software/GAIA">GAIA</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software/SafetyNet">SafetyNet</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software/MAWS">MAWS 2.0</A></LI><LI class="dropdown"><A href="https://2017.igem.org/Team:Heidelberg/Human_Practices">Human Practices </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Human_Practices">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/HP/Gold_Integrated">Integrated Human Practices</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Interviews">Expert Interviews</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Safety">Safety &amp; Security</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Engagement">Public Engagement</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Education">Education</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Collaborations">Collaborations</A></LI><LI class="dropdown"><A href="https://2017.igem.org/Team:Heidelberg/Notebook">Notebook </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Notebook">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Experiments">Methods</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Materials">Materials</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Database">Notebook Database</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Toolbox">Toolbox Guide</A></LI></DIV></DIV><NAV id="sidebar" style="z-index: 10001; background-color: white;border: none;box-shadow:1px 0px 0px #393939;" class="navmenu navmenu-default navmenu-fixed-left offcanvas" role="navigation"><A class="navmenu-brand" href="https://2017.igem.org/Team:Heidelberg"> iGEM TEAM HEIDELBERG 2017</A><DIV id="sidebarHide" data-toggle="offcanvas" data-target="#sidebar" style="padding-left: 20px;"><A style="font-family: 'Josefin Sans' !important; font-size: 16px; line-height: 18px; height: 18px;"> COLLAPSE NAVIGATION </A></DIV><UL class="nav navmenu-nav" id="sidenav"><LI><A data-toggle="collapse" data-target="#People_side">People </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Team">Team</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Attributions">Attributions</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Sponsoring">Sponsoring</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/For_Judges">For Judges</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Jamboree">Giant Jamboree</A></LI></UL><LI><A data-toggle="collapse" data-target="#Project_side">Project </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Description">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Design">Background &amp; Design </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Pace">PACE</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Predcel">PREDCEL</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Results">Results Summary</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Validation">Software Validation</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Organosilicons">Organosilicons</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Protein_Interaction">Protein Interaction</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Cytochrome_Engineering">Cytochrome Engineering</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Optogenetics">Optogenetics</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/CRISPR">CRISPR Cas9</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/InterLab">InterLab Study</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Achievements">Achievements</A></LI><LI><A data-toggle="collapse" data-target="#Parts_side">Parts </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Basic_Part">Basic Parts</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Composite_Part">Composite Parts</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Improved_Part">Improved Part</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Part_Collection">Parts Collection</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Parts#Part_List">Part List</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/RFC">RFC</A></LI><LI><A data-toggle="collapse" data-target="#Model_side">Modeling </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Phage_Titer">Phage Titer</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Mutagenesis_Induction">Mutagenesis Induction</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Mutation_Rate_Estimation">Mutation Rate Estimation</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Lagoon_Contamination">Lagoon Contamination</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Medium_Consumption">Medium Consumption</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Model/Tools">Interactive Web Tools</A></LI><LI><A data-toggle="collapse" data-target="#AI_side">Software </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software">AiGEM Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software/DeeProtein">DeeProtein</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software/GAIA">GAIA</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software/SafetyNet">SafetyNet</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Software/MAWS">MAWS 2.0</A></LI><LI><A data-toggle="collapse" data-target="#HP_side">Human Practices </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Human_Practices">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/HP/Gold_Integrated">Integrated Human Practices</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Interviews">Expert Interviews</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Safety">Safety &amp; Security</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Engagement">Public Engagement</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Education">Education</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Collaborations">Collaborations</A></LI><LI><A data-toggle="collapse" data-target="#Notebook_side">Notebook </A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Notebook">Overview</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Experiments">Methods</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Materials">Materials</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Database">Notebook Database</A></LI><LI><A href="https://2017.igem.org/Team:Heidelberg/Toolbox">Toolbox Guide</A></LI></NAV><DIV style="background-color: white !important; padding: 0 !important; margin: 0 !important;"><DIV class="page-title" style="background-color: white !important; border-top: 0px solid #222;"><DIV class="container" style=" padding: 0 !important;"><DIV class="col-lg-12 col-md-12 col-xs-12" style="padding-right: 0 !important; padding-bottom: 0 !important; position: relative; left: -10px;"><DIV style="border-right: 5px solid #393939; padding: 20px 20px 0px 0px"><DIV class="header-title heidelberg-turk">                
    DeeProtein </DIV><DIV class="header-subtitle" style="color: #393939 !important;"> 
    Deep learning for protein sequences </DIV></DIV></DIV></DIV></DIV><DIV class="container" style="background-color: white !important; padding: 0 !important;"><DIV class="col-lg-12 col-md-12 col-xs-12" style="padding: 0 !important; margin: 0px important!;"><DIV class="container" style="position: relative; left: -10px; border-left: 5px solid #393939; border-top: 5px solid #393939; padding: 0 !important"><DIV class="col-lg-12 col-md-12 col-xs-12 content" style="text-align: justify; text-color: #393939 !important; padding: 20px 5px 0px 20px !important; font-weight: bold !important; font-family: 'Open Sans' !important">
        
        Sequence based, functional protein classification is a multi-label, hierarchical classification problem that remains largely unsolved. As protein function is greatly determined by structure, a simple sequence based classification is extremely difficult. Thus manual feature extraction along with conventional machine learning models is not satisfyingly applicable in this context. With the advent of deep learning, however, a possible solution to this fundamental problem appears to be in reach. Here we present DeeProtein, a mutli-label model for protein function prediction from raw sequence data. DeeProtein was trained on ~10 million protein sequences representing 886 protein classes. It is confident in classification achieving an area under the curve of the reciever operating characteristic of 99% on the validation set, with an average F1-score of 78%. To better understand the protein sequence space, DeeProtein comprises a word2vec embedding for amino acid 3-mers, generated on the complete UniProt database.
    
    </DIV></DIV><DIV style="padding-top: 50px; padding-bottom:50px;"><DIV class="heidel-form container"><DIV class="heidel-form-header col-lg-12" style="text-align: left !important;"><A href="https://github.com/igemsoftware2017/AiGEM_TeamHeidelberg2017" style="color: #000000">                 Fork us on GitHub!</A></DIV></DIV></DIV><DIV class="container"><DIV class="row"><DIV class="col-lg-12 col-md-12 col-xs-12 content" style="display: inline-block; padding-bottom: 10px; padding-top:10px;"><H1>Introduction</H1>
While the idea of applying a stack of layers composed of computational nodes to estimate complex functions origins in the 1960s <X-REF>rosenblatt1958perceptron</X-REF>, it was not until the 1990s, when the first convolutional neural networks were introduced <X-REF>LeCun1990Handwritten</X-REF>, that artificial neural networks were successfully applied on real world classification tasks. With the beginning of this decade and the massive increase in broadly available computing power the advent of Deep Learning begun. Groundbreaking work by Krizhevsky in image classification <X-REF>Krizhevsky2012ImageNet</X-REF> paved the way for many applications in image, video, sound and natural language processing. There has also been successful work on biological and medical data <X-REF>alipanahi2015predicting</X-REF>, <X-REF>kadurin2017cornucopia</X-REF>.<H3>Background</H3>
Artificial neural networks are powerful function approximators, able to untangle complex relations in the input space <X-REF>cybenko1989approximation</X-REF>. However it were the convolutional neural networks proposed in the early 1990s <X-REF>LeCun1990Handwritten</X-REF> that made deep learning possible.  Convolutional neural networks rely on trainable filters or kernels to extract valuable information (features) from the input space. The application of trainable kernels for feature extraction has been demonstrated to be extremely powerful in representation learning <X-REF>oquab2014learning</X-REF>, detection <X-REF>lee2009unsupervised</X-REF> and classification <X-REF>Krizhevsky2012ImageNet</X-REF> tasks. Similar to the visual cortex of mammals, convolutional neural networks comprise different layers of abstraction. While the lower layers detect simple properties like edges and corners, higher layers assemble the features from the lower layers and detect more complex shapes <X-REF>lecun2015deep</X-REF>. With increasing depth the layers have a larger receptive field and are thus able to combine more signals from the layers below <X-REF>lecun2015deep</X-REF>. A convolutional neural network can thus be trained to extract the relevant information present in the input space and encode the input in a compressed representation. Handwritten, human-designed feature extraction thus becomes obsolete. Often a convolutional neural network is complemented by a small fully connected (dense) neural network part processing the extracted features to perform the real classification or detection task <X-REF>Krizhevsky2012ImageNet</X-REF>.<H1>Protein representation learning</H1>
  The protein space is extremely complex. The amino acid alphabet knows 20 basic letters and an average protein has a length of 500 residues, making the combinatory complexity of the space tremendous. Comparable to images however, functional protein sequences reside on a thin manyfold within the total sequence space. Learning the properties of the protein distribution of a certain functionality would enable not only a decent classification of sequences into functions but also unlimited sampling from this distribution resulting in <I>de novo</I> protein sequence generation. Attempts for protein sequence classification have been made with CNNs <X-REF>szalkai2017near</X-REF> as well as with recurrent neural networks <X-REF>liu2017deep</X-REF> with good success, however without the possibility for generative modelling.
  Also handwritten feature extractors exist for protein sequences <X-REF>bandyopadhyay2005efficient</X-REF><X-REF>saeys2007review</X-REF>. Along with support vector machines they were applied in protein-protein interaction prediciton <X-REF>hamp2015evolutionary</X-REF> as well as in protein family classification <X-REF>cai2003svm</X-REF><X-REF>leslie2002spectrum</X-REF>. However they are outperformed by trainable approaches applying CNNs <X-REF>szalkai2017near</X-REF> or word2vec models <X-REF>leslie2002spectrum</X-REF>.<H2>Network Architecture</H2>
To harness the strenghts of convolutional networks in representation learning and feature extraction we implemented a fully convolutional architecture to classify protein sequences to functions based on the ResNet architecture <X-REF>he2016deep</X-REF>. The motivation behind applying a residual neural network is an optimized training stability and facilitated learining process. As the identity is added to the output of a residual block through a shortcut, the fear of fading gradients and accuracy saturation is reduced.
      We define a residual block as a set of two convolutional layers, a convolutional layer with kernel size 1 to squeeze the channels <X-REF>Iandola2016SqueezeNet</X-REF> and a pooling layer. Further a batch normalisation layer is attached to every convolutional layer. The input of a residual block is added to its output after being resized by a pooling layer and padded on the channels. A schematic view on a residual block is depicted in figure 1, together with an overview of the overall architecture. The model consists of an input processing layer, 30 residual blocks and two independent convolutional outlayers.<DIV class="col-lg-12 col-md-12 col-xs-12"><DIV class="mdl-shadow--4dp" style="padding:20px; float:left}"><DIV class="img-caption title"><STRONG><B>
      
      Figure 1: The Architecture of DeeProtein ResNet30. 
    </B></STRONG></DIV><DIV class="img-caption subtitle">
      
The one-hot encoded input sequence is embedded by the input processig layer, a 2D convolutional layer with kernel size [20, 1], resulting in a 1D output per sequence. Following the embedding processing layer all subsequent convolutions are 1 dimensional. Through the network we apply 13 pooling layers sizing the length dimension from 1000 positions to 1. At the same time the channel size increases with depth from 64 in the input processing layer to 512 in the last residual block. A Residual block is composed of two 1-d convolutional layers with kernel size 3, and a 1-d 1x1 convolutional layer. Every convolutional layer has a batchnorm layer attached. The output of the 1x1 layer is then pooled with a stride of 2 and kernel size 2. Subsequently the input of the residual block is added to the output of the pooling layer in an element-wise addition (shortcut).
      
    </DIV></DIV></DIV><H2>Label selection</H2>
      To harness the strenghts of convolutional networks in representation learning and feature extraction we implemented a fully convolutional architecture to classify protein sequences to functions. Function labels were thereby defined by the gene ontology (GO) annotation <X-REF>gene2004gene</X-REF>. The gene ontology annotation is hierarchical and best described as a directed acyclic graph (DAG). It contains labels providing information on the cellular location, pathway and molecular function of a particular protein. As we were interested solely in protein function classification, we considered on GO-labels in the molecular function sub-DAG. The molecular function sub-DAG has up to 12 levels and 11135 GO-terms. As the population between terms varies greatly and strongly depends on the terms' level in the DAG, with terms towards the roots being stronger populated than leaf terms.
Thus, we thresholded the considered labels based on their minimum population, ending with a set of 1509 GO terms with a minimum population of 50 samples when considering the manually annotated SwissProt database <X-REF>apweiler2004uniprot</X-REF>. As the hierarchy in the DAG is fully inferable towards the root term, a classification by leaf terms is fully sufficient for a comprehensive classification, we further reduced the set of considered labels to all leaf nodes in the 1509-terms sub-DAG. Our final set of classes had 886 GO-terms of all levels.<H2>Data preprocessing</H2>
In order to convert the protein sequences into a machine readable format we preprocessed the whole UniProt database (release 08/17) as well as the SwissProt database (release 08/17) <X-REF>apweiler2004uniprot</X-REF>. For the classification task of 886 GO-labels we genererated a dataset containing 180774 sequences for the SwissProt and ~7 million sequences for Uniprot database respectively.
During datapreprocessing the full GO-annotation was infered through the DAG from the annotated Go-terms to facilitate the subsequent preprocessing steps. Sequences were then filtered for a minimum length of 175 amino acids and sequences containing non canonical amino acids were excluded.
To ensure a random distribution of sequences over in the validation and train sets for each label and at the same time account for the extreme class in-balance among the GO-terms, the validation set was created on the fly during generation of the training set. This was done by randomly sampling sequences from the preprocessing streams, ensuring the validation set to contain at least 5 sequences per GO-term. Training and validation sets were mutually exclusive.
Prior to training the generated datasets were processed to a binary file format, to speed up the feed streams for the GPUs. Thereby sequences were one-hot encoded and clipped or zero padded to a window of 1000 residues. The labels were also one-hot encoded. In the uniprot dataset the average sequence had 1.3 labels assigned.<H3>Training</H3>
The model was trained using the Adagrad optimizer <X-REF>duchi2011adaptive</X-REF> on a Nvidia Tesla K80 GPU for overall 4.8 epochs (600.000 steps) with a mini-batchsize of 64 and an initial learing rate of 0.01.  We minimized the cross entropy between sigmoid logits and labels, while for metrics calculations a label was considered predicted with an output value higher than 0.5. During the training process the independent outlayers where updated alternatingly depending on their argmax. The signal for both outlayers was averaged for inference and the variance between the outlayers was considered as a metric for model uncertainty. Upon loss convergence the training was stopped and the model was reinitialized with a factor 10 reduced learining rate with an ultimate learining rate of 0.001.

<H2>Results</H2>
The performance of the network was asserted on an exclusive validation set of 4425 sequences. For each GO-label the validation set contained at least 5 distinct samples. Our model achieved an area under the curve (AUC) for the reciever operating characteristic (ROC) of 99.8% with an average F1 score of 78% (Figure 3).<DIV class="col-lg-12 col-md-12 col-xs-12"><DIV class="mdl-shadow--4dp" style="padding:20px; float:left}"><DIV class="img-caption title"><STRONG><B>
      
      Figure 3: Performance on the validation set after completed training process.
    </B></STRONG></DIV><DIV class="img-caption subtitle">
      
      A) The reciever operating characteristic (ROC) curve for DeeProtein ResNet30. The area under the ROC curve is 99%. B) The precision recall curve for DeeProtein ResNet30.
      
    </DIV></DIV></DIV><H2>Wet Lab Validation</H2>
To assert the value of DeeProtein in sequence activtiy evaluation context, we validated the correlation between the DeeProtein classification score and enzyme activity in the wetlab. First we predicted a set of 25 single and double mutant beta-Lactamase variants with both higher and lower scores as the wildtype and subsequently asserted the activity in the wetlab.
      In order to derive a measure for enzyme activity we investigated the minimum inhibitory concentration (MIC) of Carbenicillin for all predicted mutants. The MIC was asserted by OD600-measurement in Carbenicillin containing media. As the OD was measuren in a 96-well plate the values are not absolute. From the measurements the MIC-score was calculated as the first Carbenicillin concentration where the OD fell below a threshold of 0.08. Next the classification scores were averaged for each MIC-score and then plotted against the Carbenicilline concentration (Figure 2).<DIV class="col-lg-12 col-md-12 col-xs-12"><DIV class="mdl-shadow--4dp" style="padding:20px; float:left}"><DIV class="img-caption title"><STRONG><B>
      
      Figure 4: The DeeProtein classification score for beta Lactamases correlates with the minimum inhibitory concentration (MIC) of Carbenicillin. 
    </B></STRONG></DIV><DIV class="img-caption subtitle">
      
      The avergage DeeProtein classification scores assigned to samples in the MIC-score bins are depicted as black dots. The red line is the fitted linear model. Samples assigned with a high classification score tend to sustain higher carbenicillin concentrations, whereas a low classification score is assigned to variants with a low MIC.
      
    </DIV></DIV></DIV><H1>Protein Sequence Embedding</H1>
      A protein representation first described by Asgari et al is prot2vec <X-REF>asgari2015continuous</X-REF>. The technique originates in the natural language processing and is based on the word2vec model <X-REF>mikolov2013efficient</X-REF> originally deriving vectorized word representations. Applied to proteins a word is defined as a k-mer of 3 amino acid residues. A protein sequence can thus be respresented as the sum over all internal k-mers. Interesting properties have been described in the resulting vectorspace, for example clustering of hydrophobic and hydrophilic k-mers and sequences <X-REF>asgari2015continuous</X-REF>. However there are limitations to the prot2vec model, the most important being the information loss on the sequence order. This has been addressed by application of the continuous bag of words model, with a paragraph embedding <X-REF>kimothi2016distributed</X-REF>. However training is here extremely slow as a proteinsequence itself is embedded in the paragraph context, where a paragraph is a greater set of protein sequences (e.g. SwissProt-DB). Further new protein sequences can not be added to the embedding as the paragraph context may not change.
      Thus we intended to find a optimized word2vec approach for fast, reproducible and simple protein sequence embedding. Therefore we applied a word2vec model <X-REF>mikolov2013efficient</X-REF> on kmers of length 3 with a total dimension size of 100. As the quality of the representation estimate scales with the number of training samples we trained our model on the whole UniProt database (Release 8/2017, <X-REF>apweiler2004uniprot</X-REF>), composed of over 87 million sequences, exceeding the training base of 324,018 sequences derived by <X-REF>asgari2015continuous</X-REF>.<H2>Results</H2>
We visualized our 100 dimensional embedding through PCA dimensionality reduction as shown in Fig 5. Highlighted in sequence are all kmers containing a certain amino acid. Clear clusters can be observed for the aminoacids Cysteine (top right corner), Lysine (top left corner), Tryptophane (center right), Glutamate (center left), Proline (bottom) and Arginine (center) even after dimensionality reduction. In contrast, for aminoacids like Glycine, Serine and Valine are distributed over the whole kmer space.<DIV class="col-lg-12 col-md-12 col-xs-12"><DIV class="mdl-shadow--4dp" style="padding:20px; float:left}"><DIV class="img-caption title"><STRONG><B>
      
      Figure 5: The 3mer sequence space reduced on two dimensions by PCA. 
    </B></STRONG></DIV><DIV class="img-caption subtitle">
      
      Highlighted are particular kmers containing a ceratin amino acid in sequential order. For the aminoacids Cysteine (top right corner), Lysine (top left corner), Tryptophane (center right), Glutamate (center left), Proline (bottom) and Arginine (center) clear clusters are observable. Others, like Glycine and Serine are distrbuted over the whole kmer space.
      
    </DIV></DIV></DIV><H2>Application</H2>
      Our kmer embedding provides a great base to explore the protein space for future research. The embedding may be applied in classification as demonstrated by <X-REF>asgari2015continuous</X-REF> but also in alternation of existing sequences. By exploiting the intrinsic properties of the vector space, a sequence defined as the path through that vector space (namely by its start and ending point) may be altered by exchanging vector components along that path to similar ones. For instance if the kmer 'AAG' and 'GAG' cluster closely in figure 3 and the distance between their embedding vectors is close, out hypothesis is they're exchangeable, without huge perturbations to the sequence because the two kmers are likely in the same sequence context.

<H1 id="nn101">Neural Networks 101</H1><H3>1. Neural Network Basics</H3>
The idea of neural networks origins in the late 1960 where Rosenblatt et al. first descriped the perceptron as a the functional unit of neural networks <X-REF>rosenblatt1958perceptron</X-REF> and subsequently their application in mulitlayered perceptrons (MLPs) <X-REF>rosenblatt1961principles</X-REF>. Most neural networks are feedforward neural networks where the information flows from the input layer through the networks until the last layer generates an output.
In general a neural network can be seen as a function approximator mapping an input to an output function, in terms of a classifier for instance:

$$y = f(x)$$

In contrast to a &quot;handdesigned&quot; classification algorithm, a neural network learns the parameters \(\theta\) required for a successfull classification:

$$y = f(x, \theta)$$

And when we consider the chain like structure of neural networks:

$$y = f_3(f_2(f_1(x, \theta_1), \theta_2), \theta_3)$$

A single neuron thereby consists of a linear mapping and an non-linear activation function applied after the linear activation:

$$z_j = w_{ij} i + b_j$$
$$y_j = a(z_j)$$

In the context of a layer with multiple neurons:

$$ z_j = \sum w_{ij} i + b_j$$
$$ y_j = a(z_j)$$

The weights \(w\) and biases \(b\) thereby describe the trainable parameters of the layer.

<H3>2. Training - Backpropagation</H3>
Like other machine learning models neural networks are trained with gradient based methods <X-REF>Goodfellow-et-al-2016</X-REF>. The most common technique that is applied on artificial neural networks is error backpropagation with stochastic gradient descent (SGD). Here the network is shown small batches of the training data and the trainable parameters are updated after each step with the goal to minimize the error of a cost or loss function. A training cycle consists of a forward and backward pass. In the forward pass the information flows from input through the network, an output is generated and the error is estimated by computing the loss function. Subsequently, during the backward pass, the error is backpropagated through the network and the trainable parameters of the network are updated to minimize the value of the loss function. Technically the gradient of the loss function with respect to the wights and biases is computed and distributed throught the network (see Fig. 6).<DIV class="col-lg-12 col-md-12 col-xs-12"><DIV class="mdl-shadow--4dp" style="padding:20px; float:left}"><DIV class="img-caption title"><STRONG><B>
      
Figure 6: A forward and backward pass through a neural network. 
    </B></STRONG></DIV><DIV class="img-caption subtitle">
      
A forward pass through a neural network with one hidden layer (left). First the input for each neuron is computed as a weighted sum of the outputs of the previous layer \(y\) or in case of the first hidden layer, the input \(x_{i}\) with an added trainable bias term. Next the \(z\) is squished through a non-linear function (activation) and the output of a layer \(y\) is obtained. The last layer (outlayer) is then compared to the target in order to estimate the error of the model in the loss-function \(L\). This initializes the backward pass (right). Here the gradients of the loss-function are backpropagated through the network by application of the chain rule. In order to do so, the error derivatives in each unit are calculated with respect to each units output, denoted as a weighted sum of the derivatives with respect to the previous layers inputs \(z_{l}\). By multiplication with the gradient of the activation function \(\frac{\partial y_{z} }{\partial z}\) the gradient with respect to a layers output is converted in a gradient with respect to a layers input \(z_{l-1}\). Once the loss is known, the error derivatives for each weight can be computed as \( y_{l} \frac{\partial L}{\partial z_{l+1} }\). Subsequently all weights are updated by their gradient value multiplied with a learning rate. Then the next forward pass is performed.
    </DIV></DIV></DIV> 
The most common cost or loss functions for classification tasks include the mean squared error (MSE) and the cross entropy (CE):
$$ MSE = \frac{1}{2}(y - \hat{y})^2 $$
$$ CE = \sum_y y log(\hat{y})$$

<H3>3. Fully Connected vs. Convolutional Nets</H3>
A convolutional neural network (CNN) is a special neural network architecture first described by Yann LeCun <X-REF>LeCun1990Handwritten</X-REF>. CNNs are specialized on analyzing spatial or time-series data, with a grid like topology. Instead of matrix multiplication, CNNs apply a mathematical operation called convolution in at least one of their layers <X-REF>Goodfellow-et-al-2016</X-REF>. Inspired by the structure of neurons on the visual cortex of mammals CNNs, have achieved tremendous results on various tasks like image, video, sound and language processing.
A convolution is defined as:
     $$ s(t)=\int x(a)w(t-a) da $$
     Where the input function \(x()\) is smoothed by the weighting function (or Kernel) \(w\), leading to the output \(s\). Typically a convolution is denoted with an asterix:
     $$ s(t)=(x \ast w)(t) $$
     Applied on a two dimenstional discrete input, a convolution is described as:
     $$ S(i,j) = \sum_m \sum_n I(i-m,j-n)K(m,n) $$

A ConvNet in abstract representation could look like this:
     $$Input \rightarrow Conv \rightarrow Conv2 \rightarrow Conv3 \rightarrow Fully Connected \rightarrow Fully Connected \rightarrow Output$$
     The information is propagated from the input throught the convolutional layers and fully connected layers to generate an output. By repeated application of convolutions and different kernel sizes the size of the image is reduced as the information proceedes through the network. The kernels are thereby modular, and optimized during the training process. The result is a trainable feature extractor (Conv1-Conv3) that can be examined by a small fully connected neural network.
     Another advantage is that CNNs rely on parameter sharing. As a kernel is often much smaller as the image it is applied on, and a kernel is applied on the whole image, the size of parameters that needs to be restored is greatly reduced compared to conventional neural networks that rely on general matrix multiplication <X-REF>Goodfellow-et-al-2016</X-REF>.

<H3>More Ressources</H3>
We provide a brief overview on what a neural network does in our <A href="">neuralnetworks101</A>. For a comprehensice explanation please rely on these ressources:
- <A href="http://colah.github.io/">colah's Blog</A> provides decent explanations of virtually all neural network architectures
- <A href="https://adeshpande3.github.io/">Adit Deshpande's Blog</A> is a very good resource for introductory explanations and overviews on applications
- <A href="http://www.deeplearningbook.org/">The Deep Learning Book</A> is a comprehensive work by three of the fields most prominent figures
Practical tips are given in these resources:
- <A href="http://cs229.stanford.edu/materials/ML-advice.pdf">Andrew Ng's tips</A> on practical implementation
- <A href="https://github.com/Hvass-Labs/TensorFlow-Tutorials">Comprehensive TensoFlow tutorials</A> by the Hvass labs</DIV></DIV></DIV></DIV></DIV></DIV><DIV style="background-color: white; padding-top: 20px;"><DIV class="container"><DIV class="row"><DIV class="col-lg-12 col-md-12 col-xs-12 content" style="display: inline-block;"><DIV class="row content"><DIV class="col-lg-12 col-md-12 col-xs-12" style="padding-top: 20px; padding-bottom: 50px; display: block"><DIV class="mdl-shadow--4dp" style="padding: 20px"><H3> References </H3></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><SECTION id="footer-sec" style="background-color: #222 !important"><DIV class="container"><DIV class="row" style="padding-top: 30px;"><DIV class="col-md-3"><H4 style="text-align: center">Quote</H4><P><I>“”</I></P></DIV><DIV class="col-md-3"><H4 style="text-align: center"> Useful <STRONG>Links</STRONG></H4><P><A href="https://igem.org/Special:SpecialPages">
			Special pages
		</A></P><P><A href="https://igem.org/Main_Page">
			Main Page
		</A></P></DIV><DIV class="col-md-3"><H4 style="text-align: center"> Follow us on </H4><DIV style="text-align: center;"><SPAN style="color: grey; text-align: center;">&amp;</SPAN></DIV></DIV><DIV class="col-md-3"><H4 style="text-align: center"> Contact us </H4><P>

               iGEM-Heidelberg2017@bioquant.uni-heidelberg.de
               
		 Im Neuenheimer Feld 267
		
		69120 Heidelberg
                    </P></DIV></DIV></DIV></SECTION></DIV></DIV></DIV></DIV></BODY></HTML>
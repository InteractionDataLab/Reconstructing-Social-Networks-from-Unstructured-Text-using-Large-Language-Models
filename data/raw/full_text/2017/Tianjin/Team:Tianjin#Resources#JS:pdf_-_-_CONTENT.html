<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Tianjin_Resources_JS_pdf skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Tianjin/Resources/JS:pdf</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*jshint globalstrict: false */
/* globals PDFJS */
</P><P>// Initializing PDFJS global object (if still undefined)
if (typeof PDFJS === 'undefined') {
</P><PRE> (typeof window !== 'undefined' ? window : this).PDFJS = {};
</PRE><P>}
</P><P>PDFJS.version = '1.1.469';
PDFJS.build = 'f06aa6a';
</P><P>(function pdfjsWrapper() {
</P><PRE> // Use strict in our context only - users might not want it
 'use strict';
</PRE><P>var globalScope = (typeof window === 'undefined') ? this : window;
</P><P>var isWorker = (typeof window === 'undefined');
</P><P>var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
</P><P>var TextRenderingMode = {
</P><PRE> FILL: 0,
 STROKE: 1,
 FILL_STROKE: 2,
 INVISIBLE: 3,
 FILL_ADD_TO_PATH: 4,
 STROKE_ADD_TO_PATH: 5,
 FILL_STROKE_ADD_TO_PATH: 6,
 ADD_TO_PATH: 7,
 FILL_STROKE_MASK: 3,
 ADD_TO_PATH_FLAG: 4
</PRE><P>};
</P><P>var ImageKind = {
</P><PRE> GRAYSCALE_1BPP: 1,
 RGB_24BPP: 2,
 RGBA_32BPP: 3
</PRE><P>};
</P><P>var AnnotationType = {
</P><PRE> WIDGET: 1,
 TEXT: 2,
 LINK: 3
</PRE><P>};
</P><P>var AnnotationBorderStyleType = {
</P><PRE> SOLID: 1,
 DASHED: 2,
 BEVELED: 3,
 INSET: 4,
 UNDERLINE: 5
</PRE><P>};
</P><P>var StreamType = {
</P><PRE> UNKNOWN: 0,
 FLATE: 1,
 LZW: 2,
 DCT: 3,
 JPX: 4,
 JBIG: 5,
 A85: 6,
 AHX: 7,
 CCF: 8,
 RL: 9
</PRE><P>};
</P><P>var FontType = {
</P><PRE> UNKNOWN: 0,
 TYPE1: 1,
 TYPE1C: 2,
 CIDFONTTYPE0: 3,
 CIDFONTTYPE0C: 4,
 TRUETYPE: 5,
 CIDFONTTYPE2: 6,
 TYPE3: 7,
 OPENTYPE: 8,
 TYPE0: 9,
 MMTYPE1: 10
</PRE><P>};
</P><P>// The global PDFJS object exposes the API
// In production, it will be declared outside a global wrapper
// In development, it will be declared here
if (!globalScope.PDFJS) {
</P><PRE> globalScope.PDFJS = {};
</PRE><P>}
</P><P>globalScope.PDFJS.pdfBug = false;
</P><P>PDFJS.VERBOSITY_LEVELS = {
</P><PRE> errors: 0,
 warnings: 1,
 infos: 5
</PRE><P>};
</P><P>// All the possible operations for an operator list.
var OPS = PDFJS.OPS = {
</P><PRE> // Intentionally start from 1 so it is easy to spot bad operators that will be
 // 0's.
 dependency: 1,
 setLineWidth: 2,
 setLineCap: 3,
 setLineJoin: 4,
 setMiterLimit: 5,
 setDash: 6,
 setRenderingIntent: 7,
 setFlatness: 8,
 setGState: 9,
 save: 10,
 restore: 11,
 transform: 12,
 moveTo: 13,
 lineTo: 14,
 curveTo: 15,
 curveTo2: 16,
 curveTo3: 17,
 closePath: 18,
 rectangle: 19,
 stroke: 20,
 closeStroke: 21,
 fill: 22,
 eoFill: 23,
 fillStroke: 24,
 eoFillStroke: 25,
 closeFillStroke: 26,
 closeEOFillStroke: 27,
 endPath: 28,
 clip: 29,
 eoClip: 30,
 beginText: 31,
 endText: 32,
 setCharSpacing: 33,
 setWordSpacing: 34,
 setHScale: 35,
 setLeading: 36,
 setFont: 37,
 setTextRenderingMode: 38,
 setTextRise: 39,
 moveText: 40,
 setLeadingMoveText: 41,
 setTextMatrix: 42,
 nextLine: 43,
 showText: 44,
 showSpacedText: 45,
 nextLineShowText: 46,
 nextLineSetSpacingShowText: 47,
 setCharWidth: 48,
 setCharWidthAndBounds: 49,
 setStrokeColorSpace: 50,
 setFillColorSpace: 51,
 setStrokeColor: 52,
 setStrokeColorN: 53,
 setFillColor: 54,
 setFillColorN: 55,
 setStrokeGray: 56,
 setFillGray: 57,
 setStrokeRGBColor: 58,
 setFillRGBColor: 59,
 setStrokeCMYKColor: 60,
 setFillCMYKColor: 61,
 shadingFill: 62,
 beginInlineImage: 63,
 beginImageData: 64,
 endInlineImage: 65,
 paintXObject: 66,
 markPoint: 67,
 markPointProps: 68,
 beginMarkedContent: 69,
 beginMarkedContentProps: 70,
 endMarkedContent: 71,
 beginCompat: 72,
 endCompat: 73,
 paintFormXObjectBegin: 74,
 paintFormXObjectEnd: 75,
 beginGroup: 76,
 endGroup: 77,
 beginAnnotations: 78,
 endAnnotations: 79,
 beginAnnotation: 80,
 endAnnotation: 81,
 paintJpegXObject: 82,
 paintImageMaskXObject: 83,
 paintImageMaskXObjectGroup: 84,
 paintImageXObject: 85,
 paintInlineImageXObject: 86,
 paintInlineImageXObjectGroup: 87,
 paintImageXObjectRepeat: 88,
 paintImageMaskXObjectRepeat: 89,
 paintSolidColorImageMask: 90,
 constructPath: 91
</PRE><P>};
</P><P>// A notice for devs. These are good for things that are helpful to devs, such
// as warning that Workers were disabled, which is important to devs but not
// end users.
function info(msg) {
</P><PRE> if (PDFJS.verbosity &gt;= PDFJS.VERBOSITY_LEVELS.infos) {
   console.log('Info: ' + msg);
 }
</PRE><P>}
</P><P>// Non-fatal warnings.
function warn(msg) {
</P><PRE> if (PDFJS.verbosity &gt;= PDFJS.VERBOSITY_LEVELS.warnings) {
   console.log('Warning: ' + msg);
 }
</PRE><P>}
</P><P>// Fatal errors that should trigger the fallback UI and halt execution by
// throwing an exception.
function error(msg) {
</P><PRE> if (PDFJS.verbosity &gt;= PDFJS.VERBOSITY_LEVELS.errors) {
   console.log('Error: ' + msg);
   console.log(backtrace());
 }
 UnsupportedManager.notify(UNSUPPORTED_FEATURES.unknown);
 throw new Error(msg);
</PRE><P>}
</P><P>function backtrace() {
</P><PRE> try {
   throw new Error();
 } catch (e) {
   return e.stack ? e.stack.split('\n').slice(2).join('\n') : <I>;</I>
 }
</PRE><P>}
</P><P>function assert(cond, msg) {
</P><PRE> if (!cond) {
   error(msg);
 }
</PRE><P>}
</P><P>var UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {
</P><PRE> unknown: 'unknown',
 forms: 'forms',
 javaScript: 'javaScript',
 smask: 'smask',
 shadingPattern: 'shadingPattern',
 font: 'font'
</PRE><P>};
</P><P>var UnsupportedManager = PDFJS.UnsupportedManager =
</P><PRE> (function UnsupportedManagerClosure() {
 var listeners = [];
 return {
   listen: function (cb) {
     listeners.push(cb);
   },
   notify: function (featureId) {
     warn('Unsupported feature &quot;' + featureId + '&quot;');
     for (var i = 0, ii = listeners.length; i &lt; ii; i++) {
       listeners[i](featureId);
     }
   }
 };
</PRE><P>})();
</P><P>// Combines two URLs. The baseUrl shall be absolute URL. If the url is an
// absolute URL, it will be returned as is.
function combineUrl(baseUrl, url) {
</P><PRE> if (!url) {
   return baseUrl;
 }
 if (/^[a-z][a-z0-9+\-.]*:/i.test(url)) {
   return url;
 }
 var i;
 if (url.charAt(0) === '/') {
   // absolute path
   i = baseUrl.indexOf('://');
   if (url.charAt(1) === '/') {
     ++i;
   } else {
     i = baseUrl.indexOf('/', i + 3);
   }
   return baseUrl.substring(0, i) + url;
 } else {
   // relative path
   var pathLength = baseUrl.length;
   i = baseUrl.lastIndexOf('#');
   pathLength = i &gt;= 0 ? i : pathLength;
   i = baseUrl.lastIndexOf('?', pathLength);
   pathLength = i &gt;= 0 ? i : pathLength;
   var prefixLength = baseUrl.lastIndexOf('/', pathLength);
   return baseUrl.substring(0, prefixLength + 1) + url;
 }
</PRE><P>}
</P><P>// Validates if URL is safe and allowed, e.g. to avoid XSS.
function isValidUrl(url, allowRelative) {
</P><PRE> if (!url) {
   return false;
 }
 // <A class="external mw-magiclink-rfc" rel="nofollow" href="//tools.ietf.org/html/rfc3986">RFC 3986</A> (<A rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc3986#section-3.1">http://tools.ietf.org/html/rfc3986#section-3.1</A>)
 // scheme = ALPHA *( ALPHA / DIGIT / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; )
 var protocol = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(url);
 if (!protocol) {
   return allowRelative;
 }
 protocol = protocol[0].toLowerCase();
 switch (protocol) {
   case 'http':
   case 'https':
   case 'ftp':
   case 'mailto':
   case 'tel':
     return true;
   default:
     return false;
 }
</PRE><P>}
PDFJS.isValidUrl = isValidUrl;
</P><P>function shadow(obj, prop, value) {
</P><PRE> Object.defineProperty(obj, prop, { value: value,
                                    enumerable: true,
                                    configurable: true,
                                    writable: false });
 return value;
</PRE><P>}
PDFJS.shadow = shadow;
</P><P>var PasswordResponses = PDFJS.PasswordResponses = {
</P><PRE> NEED_PASSWORD: 1,
 INCORRECT_PASSWORD: 2
</PRE><P>};
</P><P>var PasswordException = (function PasswordExceptionClosure() {
</P><PRE> function PasswordException(msg, code) {
   this.name = 'PasswordException';
   this.message = msg;
   this.code = code;
 }
</PRE><PRE> PasswordException.prototype = new Error();
 PasswordException.constructor = PasswordException;
</PRE><PRE> return PasswordException;
</PRE><P>})();
PDFJS.PasswordException = PasswordException;
</P><P>var UnknownErrorException = (function UnknownErrorExceptionClosure() {
</P><PRE> function UnknownErrorException(msg, details) {
   this.name = 'UnknownErrorException';
   this.message = msg;
   this.details = details;
 }
</PRE><PRE> UnknownErrorException.prototype = new Error();
 UnknownErrorException.constructor = UnknownErrorException;
</PRE><PRE> return UnknownErrorException;
</PRE><P>})();
PDFJS.UnknownErrorException = UnknownErrorException;
</P><P>var InvalidPDFException = (function InvalidPDFExceptionClosure() {
</P><PRE> function InvalidPDFException(msg) {
   this.name = 'InvalidPDFException';
   this.message = msg;
 }
</PRE><PRE> InvalidPDFException.prototype = new Error();
 InvalidPDFException.constructor = InvalidPDFException;
</PRE><PRE> return InvalidPDFException;
</PRE><P>})();
PDFJS.InvalidPDFException = InvalidPDFException;
</P><P>var MissingPDFException = (function MissingPDFExceptionClosure() {
</P><PRE> function MissingPDFException(msg) {
   this.name = 'MissingPDFException';
   this.message = msg;
 }
</PRE><PRE> MissingPDFException.prototype = new Error();
 MissingPDFException.constructor = MissingPDFException;
</PRE><PRE> return MissingPDFException;
</PRE><P>})();
PDFJS.MissingPDFException = MissingPDFException;
</P><P>var UnexpectedResponseException =
</P><PRE>   (function UnexpectedResponseExceptionClosure() {
 function UnexpectedResponseException(msg, status) {
   this.name = 'UnexpectedResponseException';
   this.message = msg;
   this.status = status;
 }
</PRE><PRE> UnexpectedResponseException.prototype = new Error();
 UnexpectedResponseException.constructor = UnexpectedResponseException;
</PRE><PRE> return UnexpectedResponseException;
</PRE><P>})();
PDFJS.UnexpectedResponseException = UnexpectedResponseException;
</P><P>var NotImplementedException = (function NotImplementedExceptionClosure() {
</P><PRE> function NotImplementedException(msg) {
   this.message = msg;
 }
</PRE><PRE> NotImplementedException.prototype = new Error();
 NotImplementedException.prototype.name = 'NotImplementedException';
 NotImplementedException.constructor = NotImplementedException;
</PRE><PRE> return NotImplementedException;
</PRE><P>})();
</P><P>var MissingDataException = (function MissingDataExceptionClosure() {
</P><PRE> function MissingDataException(begin, end) {
   this.begin = begin;
   this.end = end;
   this.message = 'Missing data [' + begin + ', ' + end + ')';
 }
</PRE><PRE> MissingDataException.prototype = new Error();
 MissingDataException.prototype.name = 'MissingDataException';
 MissingDataException.constructor = MissingDataException;
</PRE><PRE> return MissingDataException;
</PRE><P>})();
</P><P>var XRefParseException = (function XRefParseExceptionClosure() {
</P><PRE> function XRefParseException(msg) {
   this.message = msg;
 }
</PRE><PRE> XRefParseException.prototype = new Error();
 XRefParseException.prototype.name = 'XRefParseException';
 XRefParseException.constructor = XRefParseException;
</PRE><PRE> return XRefParseException;
</PRE><P>})();
</P><P>
function bytesToString(bytes) {
</P><PRE> assert(bytes !== null &amp;&amp; typeof bytes === 'object' &amp;&amp;
        bytes.length !== undefined, 'Invalid argument for bytesToString');
 var length = bytes.length;
 var MAX_ARGUMENT_COUNT = 8192;
 if (length &lt; MAX_ARGUMENT_COUNT) {
   return String.fromCharCode.apply(null, bytes);
 }
 var strBuf = [];
 for (var i = 0; i &lt; length; i += MAX_ARGUMENT_COUNT) {
   var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
   var chunk = bytes.subarray(i, chunkEnd);
   strBuf.push(String.fromCharCode.apply(null, chunk));
 }
 return strBuf.join(<I>);</I></PRE><P>}
</P><P>function stringToBytes(str) {
</P><PRE> assert(typeof str === 'string', 'Invalid argument for stringToBytes');
 var length = str.length;
 var bytes = new Uint8Array(length);
 for (var i = 0; i &lt; length; ++i) {
   bytes[i] = str.charCodeAt(i) &amp; 0xFF;
 }
 return bytes;
</PRE><P>}
</P><P>function string32(value) {
</P><PRE> return String.fromCharCode((value &gt;&gt; 24) &amp; 0xff, (value &gt;&gt; 16) &amp; 0xff,
                            (value &gt;&gt; 8) &amp; 0xff, value &amp; 0xff);
</PRE><P>}
</P><P>function log2(x) {
</P><PRE> var n = 1, i = 0;
 while (x &gt; n) {
   n &lt;&lt;= 1;
   i++;
 }
 return i;
</PRE><P>}
</P><P>function readInt8(data, start) {
</P><PRE> return (data[start] &lt;&lt; 24) &gt;&gt; 24;
</PRE><P>}
</P><P>function readUint16(data, offset) {
</P><PRE> return (data[offset] &lt;&lt; 8) | data[offset + 1];
</PRE><P>}
</P><P>function readUint32(data, offset) {
</P><PRE> return ((data[offset] &lt;&lt; 24) | (data[offset + 1] &lt;&lt; 16) |
        (data[offset + 2] &lt;&lt; 8) | data[offset + 3]) &gt;&gt;&gt; 0;
</PRE><P>}
</P><P>// Lazy test the endianness of the platform
// NOTE: This will be 'true' for simulated TypedArrays
function isLittleEndian() {
</P><PRE> var buffer8 = new Uint8Array(2);
 buffer8[0] = 1;
 var buffer16 = new Uint16Array(buffer8.buffer);
 return (buffer16[0] === 1);
</PRE><P>}
</P><P>Object.defineProperty(PDFJS, 'isLittleEndian', {
</P><PRE> configurable: true,
 get: function PDFJS_isLittleEndian() {
   return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
 }
</PRE><P>});
</P><PRE> // Lazy test if the userAgent support CanvasTypedArrays
</PRE><P>function hasCanvasTypedArrays() {
</P><PRE> var canvas = document.createElement('canvas');
 canvas.width = canvas.height = 1;
 var ctx = canvas.getContext('2d');
 var imageData = ctx.createImageData(1, 1);
 return (typeof imageData.data.buffer !== 'undefined');
</PRE><P>}
</P><P>Object.defineProperty(PDFJS, 'hasCanvasTypedArrays', {
</P><PRE> configurable: true,
 get: function PDFJS_hasCanvasTypedArrays() {
   return shadow(PDFJS, 'hasCanvasTypedArrays', hasCanvasTypedArrays());
 }
</PRE><P>});
</P><P>var Uint32ArrayView = (function Uint32ArrayViewClosure() {
</P><PRE> function Uint32ArrayView(buffer, length) {
   this.buffer = buffer;
   this.byteLength = buffer.length;
   this.length = length === undefined ? (this.byteLength &gt;&gt; 2) : length;
   ensureUint32ArrayViewProps(this.length);
 }
 Uint32ArrayView.prototype = Object.create(null);
</PRE><PRE> var uint32ArrayViewSetters = 0;
 function createUint32ArrayProp(index) {
   return {
     get: function () {
       var buffer = this.buffer, offset = index &lt;&lt; 2;
       return (buffer[offset] | (buffer[offset + 1] &lt;&lt; 8) |
         (buffer[offset + 2] &lt;&lt; 16) | (buffer[offset + 3] &lt;&lt; 24)) &gt;&gt;&gt; 0;
     },
     set: function (value) {
       var buffer = this.buffer, offset = index &lt;&lt; 2;
       buffer[offset] = value &amp; 255;
       buffer[offset + 1] = (value &gt;&gt; 8) &amp; 255;
       buffer[offset + 2] = (value &gt;&gt; 16) &amp; 255;
       buffer[offset + 3] = (value &gt;&gt;&gt; 24) &amp; 255;
     }
   };
 }
</PRE><PRE> function ensureUint32ArrayViewProps(length) {
   while (uint32ArrayViewSetters &lt; length) {
     Object.defineProperty(Uint32ArrayView.prototype,
       uint32ArrayViewSetters,
       createUint32ArrayProp(uint32ArrayViewSetters));
     uint32ArrayViewSetters++;
   }
 }
</PRE><PRE> return Uint32ArrayView;
</PRE><P>})();
</P><P>var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
</P><P>var Util = PDFJS.Util = (function UtilClosure() {
</P><PRE> function Util() {}
</PRE><PRE> var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];
</PRE><PRE> // makeCssRgb() can be called thousands of times. Using |rgbBuf| avoids
 // creating many intermediate strings.
 Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
   rgbBuf[1] = r;
   rgbBuf[3] = g;
   rgbBuf[5] = b;
   return rgbBuf.join(<I>);</I>
 };
</PRE><PRE> // Concatenates two transformation matrices together and returns the result.
 Util.transform = function Util_transform(m1, m2) {
   return [
     m1[0] * m2[0] + m1[2] * m2[1],
     m1[1] * m2[0] + m1[3] * m2[1],
     m1[0] * m2[2] + m1[2] * m2[3],
     m1[1] * m2[2] + m1[3] * m2[3],
     m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
     m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
   ];
 };
</PRE><PRE> // For 2d affine transforms
 Util.applyTransform = function Util_applyTransform(p, m) {
   var xt = p[0] * m[0] + p[1] * m[2] + m[4];
   var yt = p[0] * m[1] + p[1] * m[3] + m[5];
   return [xt, yt];
 };
</PRE><PRE> Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
   var d = m[0] * m[3] - m[1] * m[2];
   var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
   var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
   return [xt, yt];
 };
</PRE><PRE> // Applies the transform to the rectangle and finds the minimum axially
 // aligned bounding box.
 Util.getAxialAlignedBoundingBox =
   function Util_getAxialAlignedBoundingBox(r, m) {
</PRE><PRE>   var p1 = Util.applyTransform(r, m);
   var p2 = Util.applyTransform(r.slice(2, 4), m);
   var p3 = Util.applyTransform([r[0], r[3]], m);
   var p4 = Util.applyTransform([r[2], r[1]], m);
   return [
     Math.min(p1[0], p2[0], p3[0], p4[0]),
     Math.min(p1[1], p2[1], p3[1], p4[1]),
     Math.max(p1[0], p2[0], p3[0], p4[0]),
     Math.max(p1[1], p2[1], p3[1], p4[1])
   ];
 };
</PRE><PRE> Util.inverseTransform = function Util_inverseTransform(m) {
   var d = m[0] * m[3] - m[1] * m[2];
   return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d,
     (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
 };
</PRE><PRE> // Apply a generic 3d matrix M on a 3-vector v:
 //   | a b c |   | X |
 //   | d e f | x | Y |
 //   | g h i |   | Z |
 // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],
 // with v as [X,Y,Z]
 Util.apply3dTransform = function Util_apply3dTransform(m, v) {
   return [
     m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
     m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
     m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
   ];
 };
</PRE><PRE> // This calculation uses Singular Value Decomposition.
 // The SVD can be represented with formula A = USV. We are interested in the
 // matrix S here because it represents the scale values.
 Util.singularValueDecompose2dScale =
   function Util_singularValueDecompose2dScale(m) {
</PRE><PRE>   var transpose = [m[0], m[2], m[1], m[3]];
</PRE><PRE>   // Multiply matrix m with its transpose.
   var a = m[0] * transpose[0] + m[1] * transpose[2];
   var b = m[0] * transpose[1] + m[1] * transpose[3];
   var c = m[2] * transpose[0] + m[3] * transpose[2];
   var d = m[2] * transpose[1] + m[3] * transpose[3];
</PRE><PRE>   // Solve the second degree polynomial to get roots.
   var first = (a + d) / 2;
   var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
   var sx = first + second || 1;
   var sy = first - second || 1;
</PRE><PRE>   // Scale values are the square roots of the eigenvalues.
   return [Math.sqrt(sx), Math.sqrt(sy)];
 };
</PRE><PRE> // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) &lt; (x2,y2)
 // For coordinate systems whose origin lies in the bottom-left, this
 // means normalization to (BL,TR) ordering. For systems with origin in the
 // top-left, this means (TL,BR) ordering.
 Util.normalizeRect = function Util_normalizeRect(rect) {
   var r = rect.slice(0); // clone rect
   if (rect[0] &gt; rect[2]) {
     r[0] = rect[2];
     r[2] = rect[0];
   }
   if (rect[1] &gt; rect[3]) {
     r[1] = rect[3];
     r[3] = rect[1];
   }
   return r;
 };
</PRE><PRE> // Returns a rectangle [x1, y1, x2, y2] corresponding to the
 // intersection of rect1 and rect2. If no intersection, returns 'false'
 // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]
 Util.intersect = function Util_intersect(rect1, rect2) {
   function compare(a, b) {
     return a - b;
   }
</PRE><PRE>   // Order points along the axes
   var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
       orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
       result = [];
</PRE><PRE>   rect1 = Util.normalizeRect(rect1);
   rect2 = Util.normalizeRect(rect2);
</PRE><PRE>   // X: first and second points belong to different rectangles?
   if ((orderedX[0] === rect1[0] &amp;&amp; orderedX[1] === rect2[0]) ||
       (orderedX[0] === rect2[0] &amp;&amp; orderedX[1] === rect1[0])) {
     // Intersection must be between second and third points
     result[0] = orderedX[1];
     result[2] = orderedX[2];
   } else {
     return false;
   }
</PRE><PRE>   // Y: first and second points belong to different rectangles?
   if ((orderedY[0] === rect1[1] &amp;&amp; orderedY[1] === rect2[1]) ||
       (orderedY[0] === rect2[1] &amp;&amp; orderedY[1] === rect1[1])) {
     // Intersection must be between second and third points
     result[1] = orderedY[1];
     result[3] = orderedY[2];
   } else {
     return false;
   }
</PRE><PRE>   return result;
 };
</PRE><PRE> Util.sign = function Util_sign(num) {
   return num &lt; 0 ? -1 : 1;
 };
</PRE><PRE> Util.appendToArray = function Util_appendToArray(arr1, arr2) {
   Array.prototype.push.apply(arr1, arr2);
 };
</PRE><PRE> Util.prependToArray = function Util_prependToArray(arr1, arr2) {
   Array.prototype.unshift.apply(arr1, arr2);
 };
</PRE><PRE> Util.extendObj = function extendObj(obj1, obj2) {
   for (var key in obj2) {
     obj1[key] = obj2[key];
   }
 };
</PRE><PRE> Util.getInheritableProperty = function Util_getInheritableProperty(dict,
                                                                    name) {
   while (dict &amp;&amp; !dict.has(name)) {
     dict = dict.get('Parent');
   }
   if (!dict) {
     return null;
   }
   return dict.get(name);
 };
</PRE><PRE> Util.inherit = function Util_inherit(sub, base, prototype) {
   sub.prototype = Object.create(base.prototype);
   sub.prototype.constructor = sub;
   for (var prop in prototype) {
     sub.prototype[prop] = prototype[prop];
   }
 };
</PRE><PRE> Util.loadScript = function Util_loadScript(src, callback) {
   var script = document.createElement('script');
   var loaded = false;
   script.setAttribute('src', src);
   if (callback) {
     script.onload = function() {
       if (!loaded) {
         callback();
       }
       loaded = true;
     };
   }
   document.getElementsByTagName('head')[0].appendChild(script);
 };
</PRE><PRE> return Util;
</PRE><P>})();
</P><P>/**
</P><PRE>* PDF page viewport created based on scale, rotation and offset.
* @class
* @alias PDFJS.PageViewport
*/
</PRE><P>var PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {
</P><PRE> /**
  * @constructor
  * @private
  * @param viewBox {Array} xMin, yMin, xMax and yMax coordinates.
  * @param scale {number} scale of the viewport.
  * @param rotation {number} rotations of the viewport in degrees.
  * @param offsetX {number} offset X
  * @param offsetY {number} offset Y
  * @param dontFlip {boolean} if true, axis Y will not be flipped.
  */
 function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
   this.viewBox = viewBox;
   this.scale = scale;
   this.rotation = rotation;
   this.offsetX = offsetX;
   this.offsetY = offsetY;
</PRE><PRE>   // creating transform to convert pdf coordinate system to the normal
   // canvas like coordinates taking in account scale and rotation
   var centerX = (viewBox[2] + viewBox[0]) / 2;
   var centerY = (viewBox[3] + viewBox[1]) / 2;
   var rotateA, rotateB, rotateC, rotateD;
   rotation = rotation % 360;
   rotation = rotation &lt; 0 ? rotation + 360 : rotation;
   switch (rotation) {
     case 180:
       rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1;
       break;
     case 90:
       rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0;
       break;
     case 270:
       rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0;
       break;
     //case 0:
     default:
       rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1;
       break;
   }
</PRE><PRE>   if (dontFlip) {
     rotateC = -rotateC; rotateD = -rotateD;
   }
</PRE><PRE>   var offsetCanvasX, offsetCanvasY;
   var width, height;
   if (rotateA === 0) {
     offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
     offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
     width = Math.abs(viewBox[3] - viewBox[1]) * scale;
     height = Math.abs(viewBox[2] - viewBox[0]) * scale;
   } else {
     offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
     offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
     width = Math.abs(viewBox[2] - viewBox[0]) * scale;
     height = Math.abs(viewBox[3] - viewBox[1]) * scale;
   }
   // creating transform for the following operations:
   // translate(-centerX, -centerY), rotate and flip vertically,
   // scale, and translate(offsetCanvasX, offsetCanvasY)
   this.transform = [
     rotateA * scale,
     rotateB * scale,
     rotateC * scale,
     rotateD * scale,
     offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,
     offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY
   ];
</PRE><PRE>   this.width = width;
   this.height = height;
   this.fontScale = scale;
 }
 PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {
   /**
    * Clones viewport with additional properties.
    * @param args {Object} (optional) If specified, may contain the 'scale' or
    * 'rotation' properties to override the corresponding properties in
    * the cloned viewport.
    * @returns {PDFJS.PageViewport} Cloned viewport.
    */
   clone: function PageViewPort_clone(args) {
     args = args || {};
     var scale = 'scale' in args ? args.scale : this.scale;
     var rotation = 'rotation' in args ? args.rotation : this.rotation;
     return new PageViewport(this.viewBox.slice(), scale, rotation,
                             this.offsetX, this.offsetY, args.dontFlip);
   },
   /**
    * Converts PDF point to the viewport coordinates. For examples, useful for
    * converting PDF location into canvas pixel coordinates.
    * @param x {number} X coordinate.
    * @param y {number} Y coordinate.
    * @returns {Object} Object that contains 'x' and 'y' properties of the
    * point in the viewport coordinate space.
    * @see {@link convertToPdfPoint}
    * @see {@link convertToViewportRectangle}
    */
   convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
     return Util.applyTransform([x, y], this.transform);
   },
   /**
    * Converts PDF rectangle to the viewport coordinates.
    * @param rect {Array} xMin, yMin, xMax and yMax coordinates.
    * @returns {Array} Contains corresponding coordinates of the rectangle
    * in the viewport coordinate space.
    * @see {@link convertToViewportPoint}
    */
   convertToViewportRectangle:
     function PageViewport_convertToViewportRectangle(rect) {
     var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
     var br = Util.applyTransform([rect[2], rect[3]], this.transform);
     return [tl[0], tl[1], br[0], br[1]];
   },
   /**
    * Converts viewport coordinates to the PDF location. For examples, useful
    * for converting canvas pixel location into PDF one.
    * @param x {number} X coordinate.
    * @param y {number} Y coordinate.
    * @returns {Object} Object that contains 'x' and 'y' properties of the
    * point in the PDF coordinate space.
    * @see {@link convertToViewportPoint}
    */
   convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
     return Util.applyInverseTransform([x, y], this.transform);
   }
 };
 return PageViewport;
</PRE><P>})();
</P><P>var PDFStringTranslateTable = [
</P><PRE> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014,
 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C,
 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160,
 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC
</PRE><P>];
</P><P>function stringToPDFString(str) {
</P><PRE> var i, n = str.length, strBuf = [];
 if (str[0] === '\xFE' &amp;&amp; str[1] === '\xFF') {
   // UTF16BE BOM
   for (i = 2; i &lt; n; i += 2) {
     strBuf.push(String.fromCharCode(
       (str.charCodeAt(i) &lt;&lt; 8) | str.charCodeAt(i + 1)));
   }
 } else {
   for (i = 0; i &lt; n; ++i) {
     var code = PDFStringTranslateTable[str.charCodeAt(i)];
     strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
   }
 }
 return strBuf.join(<I>);</I></PRE><P>}
</P><P>function stringToUTF8String(str) {
</P><PRE> return decodeURIComponent(escape(str));
</PRE><P>}
</P><P>function utf8StringToString(str) {
</P><PRE> return unescape(encodeURIComponent(str));
</PRE><P>}
</P><P>function isEmptyObj(obj) {
</P><PRE> for (var key in obj) {
   return false;
 }
 return true;
</PRE><P>}
</P><P>function isBool(v) {
</P><PRE> return typeof v === 'boolean';
</PRE><P>}
</P><P>function isInt(v) {
</P><PRE> return typeof v === 'number' &amp;&amp; ((v | 0) === v);
</PRE><P>}
</P><P>function isNum(v) {
</P><PRE> return typeof v === 'number';
</PRE><P>}
</P><P>function isString(v) {
</P><PRE> return typeof v === 'string';
</PRE><P>}
</P><P>function isName(v) {
</P><PRE> return v instanceof Name;
</PRE><P>}
</P><P>function isCmd(v, cmd) {
</P><PRE> return v instanceof Cmd &amp;&amp; (cmd === undefined || v.cmd === cmd);
</PRE><P>}
</P><P>function isDict(v, type) {
</P><PRE> if (!(v instanceof Dict)) {
   return false;
 }
 if (!type) {
   return true;
 }
 var dictType = v.get('Type');
 return isName(dictType) &amp;&amp; dictType.name === type;
</PRE><P>}
</P><P>function isArray(v) {
</P><PRE> return v instanceof Array;
</PRE><P>}
</P><P>function isStream(v) {
</P><PRE> return typeof v === 'object' &amp;&amp; v !== null &amp;&amp; v.getBytes !== undefined;
</PRE><P>}
</P><P>function isArrayBuffer(v) {
</P><PRE> return typeof v === 'object' &amp;&amp; v !== null &amp;&amp; v.byteLength !== undefined;
</PRE><P>}
</P><P>function isRef(v) {
</P><PRE> return v instanceof Ref;
</PRE><P>}
</P><P>/**
</P><PRE>* Promise Capability object.
*
* @typedef {Object} PromiseCapability
* @property {Promise} promise - A promise object.
* @property {function} resolve - Fullfills the promise.
* @property {function} reject - Rejects the promise.
*/
</PRE><P>/**
</P><PRE>* Creates a promise capability object.
* @alias PDFJS.createPromiseCapability
*
* @return {PromiseCapability} A capability object contains:
* - a Promise, resolve and reject methods.
*/
</PRE><P>function createPromiseCapability() {
</P><PRE> var capability = {};
 capability.promise = new Promise(function (resolve, reject) {
   capability.resolve = resolve;
   capability.reject = reject;
 });
 return capability;
</PRE><P>}
</P><P>PDFJS.createPromiseCapability = createPromiseCapability;
</P><P>/**
</P><PRE>* Polyfill for Promises:
* The following promise implementation tries to generally implement the
* Promise/A+ spec. Some notable differences from other promise libaries are:
* - There currently isn't a seperate deferred and promise object.
* - Unhandled rejections eventually show an error if they aren't handled.
*
* Based off of the work in:
* <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=810490">https://bugzilla.mozilla.org/show_bug.cgi?id=810490</A>
*/
</PRE><P>(function PromiseClosure() {
</P><PRE> if (globalScope.Promise) {
   // Promises existing in the DOM/Worker, checking presence of all/resolve
   if (typeof globalScope.Promise.all !== 'function') {
     globalScope.Promise.all = function (iterable) {
       var count = 0, results = [], resolve, reject;
       var promise = new globalScope.Promise(function (resolve_, reject_) {
         resolve = resolve_;
         reject = reject_;
       });
       iterable.forEach(function (p, i) {
         count++;
         p.then(function (result) {
           results[i] = result;
           count--;
           if (count === 0) {
             resolve(results);
           }
         }, reject);
       });
       if (count === 0) {
         resolve(results);
       }
       return promise;
     };
   }
   if (typeof globalScope.Promise.resolve !== 'function') {
     globalScope.Promise.resolve = function (value) {
       return new globalScope.Promise(function (resolve) { resolve(value); });
     };
   }
   if (typeof globalScope.Promise.reject !== 'function') {
     globalScope.Promise.reject = function (reason) {
       return new globalScope.Promise(function (resolve, reject) {
         reject(reason);
       });
     };
   }
   if (typeof globalScope.Promise.prototype.catch !== 'function') {
     globalScope.Promise.prototype.catch = function (onReject) {
       return globalScope.Promise.prototype.then(undefined, onReject);
     };
   }
   return;
 }
 var STATUS_PENDING = 0;
 var STATUS_RESOLVED = 1;
 var STATUS_REJECTED = 2;
</PRE><PRE> // In an attempt to avoid silent exceptions, unhandled rejections are
 // tracked and if they aren't handled in a certain amount of time an
 // error is logged.
 var REJECTION_TIMEOUT = 500;
</PRE><PRE> var HandlerManager = {
   handlers: [],
   running: false,
   unhandledRejections: [],
   pendingRejectionCheck: false,
</PRE><PRE>   scheduleHandlers: function scheduleHandlers(promise) {
     if (promise._status === STATUS_PENDING) {
       return;
     }
</PRE><PRE>     this.handlers = this.handlers.concat(promise._handlers);
     promise._handlers = [];
</PRE><PRE>     if (this.running) {
       return;
     }
     this.running = true;
</PRE><PRE>     setTimeout(this.runHandlers.bind(this), 0);
   },
</PRE><PRE>   runHandlers: function runHandlers() {
     var RUN_TIMEOUT = 1; // ms
     var timeoutAt = Date.now() + RUN_TIMEOUT;
     while (this.handlers.length &gt; 0) {
       var handler = this.handlers.shift();
</PRE><PRE>       var nextStatus = handler.thisPromise._status;
       var nextValue = handler.thisPromise._value;
</PRE><PRE>       try {
         if (nextStatus === STATUS_RESOLVED) {
           if (typeof handler.onResolve === 'function') {
             nextValue = handler.onResolve(nextValue);
           }
         } else if (typeof handler.onReject === 'function') {
             nextValue = handler.onReject(nextValue);
             nextStatus = STATUS_RESOLVED;
</PRE><PRE>             if (handler.thisPromise._unhandledRejection) {
               this.removeUnhandeledRejection(handler.thisPromise);
             }
         }
       } catch (ex) {
         nextStatus = STATUS_REJECTED;
         nextValue = ex;
       }
</PRE><PRE>       handler.nextPromise._updateStatus(nextStatus, nextValue);
       if (Date.now() &gt;= timeoutAt) {
         break;
       }
     }
</PRE><PRE>     if (this.handlers.length &gt; 0) {
       setTimeout(this.runHandlers.bind(this), 0);
       return;
     }
</PRE><PRE>     this.running = false;
   },
</PRE><PRE>   addUnhandledRejection: function addUnhandledRejection(promise) {
     this.unhandledRejections.push({
       promise: promise,
       time: Date.now()
     });
     this.scheduleRejectionCheck();
   },
</PRE><PRE>   removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
     promise._unhandledRejection = false;
     for (var i = 0; i &lt; this.unhandledRejections.length; i++) {
       if (this.unhandledRejections[i].promise === promise) {
         this.unhandledRejections.splice(i);
         i--;
       }
     }
   },
</PRE><PRE>   scheduleRejectionCheck: function scheduleRejectionCheck() {
     if (this.pendingRejectionCheck) {
       return;
     }
     this.pendingRejectionCheck = true;
     setTimeout(function rejectionCheck() {
       this.pendingRejectionCheck = false;
       var now = Date.now();
       for (var i = 0; i &lt; this.unhandledRejections.length; i++) {
         if (now - this.unhandledRejections[i].time &gt; REJECTION_TIMEOUT) {
           var unhandled = this.unhandledRejections[i].promise._value;
           var msg = 'Unhandled rejection: ' + unhandled;
           if (unhandled.stack) {
             msg += '\n' + unhandled.stack;
           }
           warn(msg);
           this.unhandledRejections.splice(i);
           i--;
         }
       }
       if (this.unhandledRejections.length) {
         this.scheduleRejectionCheck();
       }
     }.bind(this), REJECTION_TIMEOUT);
   }
 };
</PRE><PRE> function Promise(resolver) {
   this._status = STATUS_PENDING;
   this._handlers = [];
   try {
     resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
   } catch (e) {
     this._reject(e);
   }
 }
 /**
  * Builds a promise that is resolved when all the passed in promises are
  * resolved.
  * @param {array} array of data and/or promises to wait for.
  * @return {Promise} New dependant promise.
  */
 Promise.all = function Promise_all(promises) {
   var resolveAll, rejectAll;
   var deferred = new Promise(function (resolve, reject) {
     resolveAll = resolve;
     rejectAll = reject;
   });
   var unresolved = promises.length;
   var results = [];
   if (unresolved === 0) {
     resolveAll(results);
     return deferred;
   }
   function reject(reason) {
     if (deferred._status === STATUS_REJECTED) {
       return;
     }
     results = [];
     rejectAll(reason);
   }
   for (var i = 0, ii = promises.length; i &lt; ii; ++i) {
     var promise = promises[i];
     var resolve = (function(i) {
       return function(value) {
         if (deferred._status === STATUS_REJECTED) {
           return;
         }
         results[i] = value;
         unresolved--;
         if (unresolved === 0) {
           resolveAll(results);
         }
       };
     })(i);
     if (Promise.isPromise(promise)) {
       promise.then(resolve, reject);
     } else {
       resolve(promise);
     }
   }
   return deferred;
 };
</PRE><PRE> /**
  * Checks if the value is likely a promise (has a 'then' function).
  * @return {boolean} true if value is thenable
  */
 Promise.isPromise = function Promise_isPromise(value) {
   return value &amp;&amp; typeof value.then === 'function';
 };
</PRE><PRE> /**
  * Creates resolved promise
  * @param value resolve value
  * @returns {Promise}
  */
 Promise.resolve = function Promise_resolve(value) {
   return new Promise(function (resolve) { resolve(value); });
 };
</PRE><PRE> /**
  * Creates rejected promise
  * @param reason rejection value
  * @returns {Promise}
  */
 Promise.reject = function Promise_reject(reason) {
   return new Promise(function (resolve, reject) { reject(reason); });
 };
</PRE><PRE> Promise.prototype = {
   _status: null,
   _value: null,
   _handlers: null,
   _unhandledRejection: null,
</PRE><PRE>   _updateStatus: function Promise__updateStatus(status, value) {
     if (this._status === STATUS_RESOLVED ||
         this._status === STATUS_REJECTED) {
       return;
     }
</PRE><PRE>     if (status === STATUS_RESOLVED &amp;&amp;
         Promise.isPromise(value)) {
       value.then(this._updateStatus.bind(this, STATUS_RESOLVED),
                  this._updateStatus.bind(this, STATUS_REJECTED));
       return;
     }
</PRE><PRE>     this._status = status;
     this._value = value;
</PRE><PRE>     if (status === STATUS_REJECTED &amp;&amp; this._handlers.length === 0) {
       this._unhandledRejection = true;
       HandlerManager.addUnhandledRejection(this);
     }
</PRE><PRE>     HandlerManager.scheduleHandlers(this);
   },
</PRE><PRE>   _resolve: function Promise_resolve(value) {
     this._updateStatus(STATUS_RESOLVED, value);
   },
</PRE><PRE>   _reject: function Promise_reject(reason) {
     this._updateStatus(STATUS_REJECTED, reason);
   },
</PRE><PRE>   then: function Promise_then(onResolve, onReject) {
     var nextPromise = new Promise(function (resolve, reject) {
       this.resolve = resolve;
       this.reject = reject;
     });
     this._handlers.push({
       thisPromise: this,
       onResolve: onResolve,
       onReject: onReject,
       nextPromise: nextPromise
     });
     HandlerManager.scheduleHandlers(this);
     return nextPromise;
   },
</PRE><PRE>   catch: function Promise_catch(onReject) {
     return this.then(undefined, onReject);
   }
 };
</PRE><PRE> globalScope.Promise = Promise;
</PRE><P>})();
</P><P>var StatTimer = (function StatTimerClosure() {
</P><PRE> function rpad(str, pad, length) {
   while (str.length &lt; length) {
     str += pad;
   }
   return str;
 }
 function StatTimer() {
   this.started = {};
   this.times = [];
   this.enabled = true;
 }
 StatTimer.prototype = {
   time: function StatTimer_time(name) {
     if (!this.enabled) {
       return;
     }
     if (name in this.started) {
       warn('Timer is already running for ' + name);
     }
     this.started[name] = Date.now();
   },
   timeEnd: function StatTimer_timeEnd(name) {
     if (!this.enabled) {
       return;
     }
     if (!(name in this.started)) {
       warn('Timer has not been started for ' + name);
     }
     this.times.push({
       'name': name,
       'start': this.started[name],
       'end': Date.now()
     });
     // Remove timer from started so it can be called again.
     delete this.started[name];
   },
   toString: function StatTimer_toString() {
     var i, ii;
     var times = this.times;
     var out = <I>;</I>
     // Find the longest name for padding purposes.
     var longest = 0;
     for (i = 0, ii = times.length; i &lt; ii; ++i) {
       var name = times[i]['name'];
       if (name.length &gt; longest) {
         longest = name.length;
       }
     }
     for (i = 0, ii = times.length; i &lt; ii; ++i) {
       var span = times[i];
       var duration = span.end - span.start;
       out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
     }
     return out;
   }
 };
 return StatTimer;
</PRE><P>})();
</P><P>PDFJS.createBlob = function createBlob(data, contentType) {
</P><PRE> if (typeof Blob !== 'undefined') {
   return new Blob([data], { type: contentType });
 }
 // Blob builder is deprecated in FF14 and removed in FF18.
 var bb = new MozBlobBuilder();
 bb.append(data);
 return bb.getBlob(contentType);
</PRE><P>};
</P><P>PDFJS.createObjectURL = (function createObjectURLClosure() {
</P><PRE> // Blob/createObjectURL is not available, falling back to data schema.
 var digits =
   'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
</PRE><PRE> return function createObjectURL(data, contentType) {
   if (!PDFJS.disableCreateObjectURL &amp;&amp;
       typeof URL !== 'undefined' &amp;&amp; URL.createObjectURL) {
     var blob = PDFJS.createBlob(data, contentType);
     return URL.createObjectURL(blob);
   }
</PRE><PRE>   var buffer = 'data:' + contentType + ';base64,';
   for (var i = 0, ii = data.length; i &lt; ii; i += 3) {
     var b1 = data[i] &amp; 0xFF;
     var b2 = data[i + 1] &amp; 0xFF;
     var b3 = data[i + 2] &amp; 0xFF;
     var d1 = b1 &gt;&gt; 2, d2 = ((b1 &amp; 3) &lt;&lt; 4) | (b2 &gt;&gt; 4);
     var d3 = i + 1 &lt; ii ? ((b2 &amp; 0xF) &lt;&lt; 2) | (b3 &gt;&gt; 6) : 64;
     var d4 = i + 2 &lt; ii ? (b3 &amp; 0x3F) : 64;
     buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
   }
   return buffer;
 };
</PRE><P>})();
</P><P>function MessageHandler(name, comObj) {
</P><PRE> this.name = name;
 this.comObj = comObj;
 this.callbackIndex = 1;
 this.postMessageTransfers = true;
 var callbacksCapabilities = this.callbacksCapabilities = {};
 var ah = this.actionHandler = {};
</PRE><PRE> ah['console_log'] = [function ahConsoleLog(data) {
   console.log.apply(console, data);
 }];
 ah['console_error'] = [function ahConsoleError(data) {
   console.error.apply(console, data);
 }];
 ah['_unsupported_feature'] = [function ah_unsupportedFeature(data) {
   UnsupportedManager.notify(data);
 }];
</PRE><PRE> comObj.onmessage = function messageHandlerComObjOnMessage(event) {
   var data = event.data;
   if (data.isReply) {
     var callbackId = data.callbackId;
     if (data.callbackId in callbacksCapabilities) {
       var callback = callbacksCapabilities[callbackId];
       delete callbacksCapabilities[callbackId];
       if ('error' in data) {
         callback.reject(data.error);
       } else {
         callback.resolve(data.data);
       }
     } else {
       error('Cannot resolve callback ' + callbackId);
     }
   } else if (data.action in ah) {
     var action = ah[data.action];
     if (data.callbackId) {
       Promise.resolve().then(function () {
         return action[0].call(action[1], data.data);
       }).then(function (result) {
         comObj.postMessage({
           isReply: true,
           callbackId: data.callbackId,
           data: result
         });
       }, function (reason) {
         if (reason instanceof Error) {
           // Serialize error to avoid &quot;DataCloneError&quot;
           reason = reason + <I>;</I>
         }
         comObj.postMessage({
           isReply: true,
           callbackId: data.callbackId,
           error: reason
         });
       });
     } else {
       action[0].call(action[1], data.data);
     }
   } else {
     error('Unknown action from worker: ' + data.action);
   }
 };
</PRE><P>}
</P><P>MessageHandler.prototype = {
</P><PRE> on: function messageHandlerOn(actionName, handler, scope) {
   var ah = this.actionHandler;
   if (ah[actionName]) {
     error('There is already an actionName called &quot;' + actionName + '&quot;');
   }
   ah[actionName] = [handler, scope];
 },
 /**
  * Sends a message to the comObj to invoke the action with the supplied data.
  * @param {String} actionName Action to call.
  * @param {JSON} data JSON data to send.
  * @param {Array} [transfers] Optional list of transfers/ArrayBuffers
  */
 send: function messageHandlerSend(actionName, data, transfers) {
   var message = {
     action: actionName,
     data: data
   };
   this.postMessage(message, transfers);
 },
 /**
  * Sends a message to the comObj to invoke the action with the supplied data.
  * Expects that other side will callback with the response.
  * @param {String} actionName Action to call.
  * @param {JSON} data JSON data to send.
  * @param {Array} [transfers] Optional list of transfers/ArrayBuffers.
  * @returns {Promise} Promise to be resolved with response data.
  */
 sendWithPromise:
   function messageHandlerSendWithPromise(actionName, data, transfers) {
   var callbackId = this.callbackIndex++;
   var message = {
     action: actionName,
     data: data,
     callbackId: callbackId
   };
   var capability = createPromiseCapability();
   this.callbacksCapabilities[callbackId] = capability;
   try {
     this.postMessage(message, transfers);
   } catch (e) {
     capability.reject(e);
   }
   return capability.promise;
 },
 /**
  * Sends raw message to the comObj.
  * @private
  * @param message {Object} Raw message.
  * @param transfers List of transfers/ArrayBuffers, or undefined.
  */
 postMessage: function (message, transfers) {
   if (transfers &amp;&amp; this.postMessageTransfers) {
     this.comObj.postMessage(message, transfers);
   } else {
     this.comObj.postMessage(message);
   }
 }
</PRE><P>};
</P><P>function loadJpegStream(id, imageUrl, objs) {
</P><PRE> var img = new Image();
 img.onload = (function loadJpegStream_onloadClosure() {
   objs.resolve(id, img);
 });
 img.onerror = (function loadJpegStream_onerrorClosure() {
   objs.resolve(id, null);
   warn('Error during JPEG image loading');
 });
 img.src = imageUrl;
</PRE><P>}
</P><P>
/**
</P><PRE>* The maximum allowed image size in total pixels e.g. width * height. Images
* above this value will not be drawn. Use -1 for no limit.
* @var {number}
*/
</PRE><P>PDFJS.maxImageSize = (PDFJS.maxImageSize === undefined ?
</P><PRE>                     -1 : PDFJS.maxImageSize);
</PRE><P>/**
</P><PRE>* The url of where the predefined Adobe CMaps are located. Include trailing
* slash.
* @var {string}
*/
</PRE><P>PDFJS.cMapUrl = (PDFJS.cMapUrl === undefined ? null : PDFJS.cMapUrl);
</P><P>/**
</P><PRE>* Specifies if CMaps are binary packed.
* @var {boolean}
*/
</PRE><P>PDFJS.cMapPacked = PDFJS.cMapPacked === undefined ? false : PDFJS.cMapPacked;
</P><P>/**
</P><PRE>* By default fonts are converted to OpenType fonts and loaded via font face
* rules. If disabled, the font will be rendered using a built in font renderer
* that constructs the glyphs with primitive path commands.
* @var {boolean}
*/
</PRE><P>PDFJS.disableFontFace = (PDFJS.disableFontFace === undefined ?
</P><PRE>                        false : PDFJS.disableFontFace);
</PRE><P>/**
</P><PRE>* Path for image resources, mainly for annotation icons. Include trailing
* slash.
* @var {string}
*/
</PRE><P>PDFJS.imageResourcesPath = (PDFJS.imageResourcesPath === undefined ?
</P><PRE><I> : PDFJS.imageResourcesPath);</I></PRE><P>/**
</P><PRE>* Disable the web worker and run all code on the main thread. This will happen
* automatically if the browser doesn't support workers or sending typed arrays
* to workers.
* @var {boolean}
*/
</PRE><P>PDFJS.disableWorker = (PDFJS.disableWorker === undefined ?
</P><PRE>                      false : PDFJS.disableWorker);
</PRE><P>/**
</P><PRE>* Path and filename of the worker file. Required when the worker is enabled in
* development mode. If unspecified in the production build, the worker will be
* loaded based on the location of the pdf.js file.
* @var {string}
*/
</PRE><P>PDFJS.workerSrc = (PDFJS.workerSrc === undefined ? null : PDFJS.workerSrc);
</P><P>/**
</P><PRE>* Disable range request loading of PDF files. When enabled and if the server
* supports partial content requests then the PDF will be fetched in chunks.
* Enabled (false) by default.
* @var {boolean}
*/
</PRE><P>PDFJS.disableRange = (PDFJS.disableRange === undefined ?
</P><PRE>                     false : PDFJS.disableRange);
</PRE><P>/**
</P><PRE>* Disable streaming of PDF file data. By default PDF.js attempts to load PDF
* in chunks. This default behavior can be disabled.
* @var {boolean}
*/
</PRE><P>PDFJS.disableStream = (PDFJS.disableStream === undefined ?
</P><PRE>                      false : PDFJS.disableStream);
</PRE><P>/**
</P><PRE>* Disable pre-fetching of PDF file data. When range requests are enabled PDF.js
* will automatically keep fetching more data even if it isn't needed to display
* the current page. This default behavior can be disabled.
*
* NOTE: It is also necessary to disable streaming, see above,
*       in order for disabling of pre-fetching to work correctly.
* @var {boolean}
*/
</PRE><P>PDFJS.disableAutoFetch = (PDFJS.disableAutoFetch === undefined ?
</P><PRE>                         false : PDFJS.disableAutoFetch);
</PRE><P>/**
</P><PRE>* Enables special hooks for debugging PDF.js.
* @var {boolean}
*/</PRE><P>PDFJS.pdfBug = (PDFJS.pdfBug === undefined ? false : PDFJS.pdfBug);
</P><P>/**
</P><PRE>* Enables transfer usage in postMessage for ArrayBuffers.
* @var {boolean}
*/
</PRE><P>PDFJS.postMessageTransfers = (PDFJS.postMessageTransfers === undefined ?
</P><PRE>                             true : PDFJS.postMessageTransfers);
</PRE><P>/**
</P><PRE>* Disables URL.createObjectURL usage.
* @var {boolean}
*/
</PRE><P>PDFJS.disableCreateObjectURL = (PDFJS.disableCreateObjectURL === undefined ?
</P><PRE>                               false : PDFJS.disableCreateObjectURL);
</PRE><P>/**
</P><PRE>* Disables WebGL usage.
* @var {boolean}
*/
</PRE><P>PDFJS.disableWebGL = (PDFJS.disableWebGL === undefined ?
</P><PRE>                     true : PDFJS.disableWebGL);
</PRE><P>/**
</P><PRE>* Disables fullscreen support, and by extension Presentation Mode,
* in browsers which support the fullscreen API.
* @var {boolean}
*/
</PRE><P>PDFJS.disableFullscreen = (PDFJS.disableFullscreen === undefined ?
</P><PRE>                          false : PDFJS.disableFullscreen);
</PRE><P>/**
</P><PRE>* Enables CSS only zooming.
* @var {boolean}
*/
</PRE><P>PDFJS.useOnlyCssZoom = (PDFJS.useOnlyCssZoom === undefined ?
</P><PRE>                       false : PDFJS.useOnlyCssZoom);
</PRE><P>/**
</P><PRE>* Controls the logging level.
* The constants from PDFJS.VERBOSITY_LEVELS should be used:
* - errors
* - warnings [default]
* - infos
* @var {number}
*/
</PRE><P>PDFJS.verbosity = (PDFJS.verbosity === undefined ?
</P><PRE>                  PDFJS.VERBOSITY_LEVELS.warnings : PDFJS.verbosity);
</PRE><P>/**
</P><PRE>* The maximum supported canvas size in total pixels e.g. width * height.
* The default value is 4096 * 4096. Use -1 for no limit.
* @var {number}
*/
</PRE><P>PDFJS.maxCanvasPixels = (PDFJS.maxCanvasPixels === undefined ?
</P><PRE>                        16777216 : PDFJS.maxCanvasPixels);
</PRE><P>/**
</P><PRE>* Opens external links in a new window if enabled. The default behavior opens
* external links in the PDF.js window.
* @var {boolean}
*/
</PRE><P>PDFJS.openExternalLinksInNewWindow = (
</P><PRE> PDFJS.openExternalLinksInNewWindow === undefined ?
   false : PDFJS.openExternalLinksInNewWindow);
</PRE><P>/**
</P><PRE> * Determines if we can eval strings as JS. Primarily used to improve
 * performance for font rendering.
 * @var {boolean}
 */
</PRE><P>PDFJS.isEvalSupported = (PDFJS.isEvalSupported === undefined ?
</P><PRE>                        true : PDFJS.isEvalSupported);
</PRE><P>/**
</P><PRE>* Document initialization / loading parameters object.
*
* @typedef {Object} DocumentInitParameters
* @property {string}     url   - The URL of the PDF.
* @property {TypedArray|Array|string} data - Binary PDF data. Use typed arrays
*   (Uint8Array) to improve the memory usage. If PDF data is BASE64-encoded,
*   use atob() to convert it to a binary string first.
* @property {Object}     httpHeaders - Basic authentication headers.
* @property {boolean}    withCredentials - Indicates whether or not cross-site
*   Access-Control requests should be made using credentials such as cookies
*   or authorization headers. The default is false.
* @property {string}     password - For decrypting password-protected PDFs.
* @property {TypedArray} initialData - A typed array with the first portion or
*   all of the pdf data. Used by the extension since some data is already
*   loaded before the switch to range requests.
* @property {number}     length - The PDF file length. It's used for progress
*   reports and range requests operations.
* @property {PDFDataRangeTransport} range
*/
</PRE><P>/**
</P><PRE>* @typedef {Object} PDFDocumentStats
* @property {Array} streamTypes - Used stream types in the document (an item
*   is set to true if specific stream ID was used in the document).
* @property {Array} fontTypes - Used font type in the document (an item is set
*   to true if specific font ID was used in the document).
*/
</PRE><P>/**
</P><PRE>* This is the main entry point for loading a PDF and interacting with it.
* NOTE: If a URL is used to fetch the PDF data a standard XMLHttpRequest(XHR)
* is used, which means it must follow the same origin rules that any XHR does
* e.g. No cross domain requests without CORS.
*
* @param {string|TypedArray|DocumentInitParameters|PDFDataRangeTransport} src
* Can be a url to where a PDF is located, a typed array (Uint8Array)
* already populated with data or parameter object.
*
* @param {PDFDataRangeTransport} pdfDataRangeTransport (deprecated) It is used
* if you want to manually serve range requests for data in the PDF.
*
* @param {function} passwordCallback (deprecated) It is used to request a
* password if wrong or no password was provided. The callback receives two
* parameters: function that needs to be called with new password and reason
* (see {PasswordResponses}).
*
* @param {function} progressCallback (deprecated) It is used to be able to
* monitor the loading progress of the PDF file (necessary to implement e.g.
* a loading bar). The callback receives an {Object} with the properties:
* {number} loaded and {number} total.
*
* @return {PDFDocumentLoadingTask}
*/
</PRE><P>PDFJS.getDocument = function getDocument(src,
</P><PRE>                                        pdfDataRangeTransport,
                                        passwordCallback,
                                        progressCallback) {
 var task = new PDFDocumentLoadingTask();
</PRE><PRE> // Support of the obsolete arguments (for compatibility with API v1.0)
 if (pdfDataRangeTransport) {
   if (!(pdfDataRangeTransport instanceof PDFDataRangeTransport)) {
     // Not a PDFDataRangeTransport instance, trying to add missing properties.
     pdfDataRangeTransport = Object.create(pdfDataRangeTransport);
     pdfDataRangeTransport.length = src.length;
     pdfDataRangeTransport.initialData = src.initialData;
   }
   src = Object.create(src);
   src.range = pdfDataRangeTransport;
 }
 task.onPassword = passwordCallback || null;
 task.onProgress = progressCallback || null;
</PRE><PRE> var workerInitializedCapability, transport;
 var source;
 if (typeof src === 'string') {
   source = { url: src };
 } else if (isArrayBuffer(src)) {
   source = { data: src };
 } else if (src instanceof PDFDataRangeTransport) {
   source = { range: src };
 } else {
   if (typeof src !== 'object') {
     error('Invalid parameter in getDocument, need either Uint8Array, ' +
       'string or a parameter object');
   }
   if (!src.url &amp;&amp; !src.data &amp;&amp; !src.range) {
     error('Invalid parameter object: need either .data, .range or .url');
   }
</PRE><PRE>   source = src;
 }
</PRE><PRE> var params = {};
 for (var key in source) {
   if (key === 'url' &amp;&amp; typeof window !== 'undefined') {
     // The full path is required in the 'url' field.
     params[key] = combineUrl(window.location.href, source[key]);
     continue;
   } else if (key === 'range') {
     continue;
   } else if (key === 'data' &amp;&amp; !(source[key] instanceof Uint8Array)) {
     // Converting string or array-like data to Uint8Array.
     var pdfBytes = source[key];
     if (typeof pdfBytes === 'string') {
       params[key] = stringToBytes(pdfBytes);
     } else if (typeof pdfBytes === 'object' &amp;&amp; pdfBytes !== null &amp;&amp; !isNaN(pdfBytes.length)) {
       params[key] = new Uint8Array(pdfBytes);
     } else if (isArrayBuffer(pdfBytes)) {
       params[key] = new Uint8Array(pdfBytes);
     } else {
       error('Invalid PDF binary data: either typed array, string or ' +
             'array-like object is expected in the data property.');
     }
     continue;
   }
   params[key] = source[key];
 }
</PRE><PRE> workerInitializedCapability = createPromiseCapability();
 transport = new WorkerTransport(workerInitializedCapability, source.range);
 workerInitializedCapability.promise.then(function transportInitialized() {
   transport.fetchDocument(task, params);
 });
</PRE><PRE> return task;
</PRE><P>};
</P><P>/**
</P><PRE>* PDF document loading operation.
* @class
*/
</PRE><P>var PDFDocumentLoadingTask = (function PDFDocumentLoadingTaskClosure() {
</P><PRE> /** @constructs PDFDocumentLoadingTask */
 function PDFDocumentLoadingTask() {
   this._capability = createPromiseCapability();
</PRE><PRE>   /**
    * Callback to request a password if wrong or no password was provided.
    * The callback receives two parameters: function that needs to be called
    * with new password and reason (see {PasswordResponses}).
    */
   this.onPassword = null;
</PRE><PRE>   /**
    * Callback to be able to monitor the loading progress of the PDF file
    * (necessary to implement e.g. a loading bar). The callback receives
    * an {Object} with the properties: {number} loaded and {number} total.
    */
   this.onProgress = null;
 }
</PRE><PRE> PDFDocumentLoadingTask.prototype =
     /** @lends PDFDocumentLoadingTask.prototype */ {
   /**
    * @return {Promise}
    */
   get promise() {
     return this._capability.promise;
   },
</PRE><PRE>   // TODO add cancel or abort method
</PRE><PRE>   /**
    * Registers callbacks to indicate the document loading completion.
    *
    * @param {function} onFulfilled The callback for the loading completion.
    * @param {function} onRejected The callback for the loading failure.
    * @return {Promise} A promise that is resolved after the onFulfilled or
    *                   onRejected callback.
    */
   then: function PDFDocumentLoadingTask_then(onFulfilled, onRejected) {
     return this.promise.then.apply(this.promise, arguments);
   }
 };
</PRE><PRE> return PDFDocumentLoadingTask;
</PRE><P>})();
</P><P>/**
</P><PRE>* Abstract class to support range requests file loading.
* @class
*/
</PRE><P>var PDFDataRangeTransport = (function pdfDataRangeTransportClosure() {
</P><PRE> /**
  * @constructs PDFDataRangeTransport
  * @param {number} length
  * @param {Uint8Array} initialData
  */
 function PDFDataRangeTransport(length, initialData) {
   this.length = length;
   this.initialData = initialData;
</PRE><PRE>   this._rangeListeners = [];
   this._progressListeners = [];
   this._progressiveReadListeners = [];
   this._readyCapability = createPromiseCapability();
 }
 PDFDataRangeTransport.prototype =
     /** @lends PDFDataRangeTransport.prototype */ {
   addRangeListener:
       function PDFDataRangeTransport_addRangeListener(listener) {
     this._rangeListeners.push(listener);
   },
</PRE><PRE>   addProgressListener:
       function PDFDataRangeTransport_addProgressListener(listener) {
     this._progressListeners.push(listener);
   },
</PRE><PRE>   addProgressiveReadListener:
       function PDFDataRangeTransport_addProgressiveReadListener(listener) {
     this._progressiveReadListeners.push(listener);
   },
</PRE><PRE>   onDataRange: function PDFDataRangeTransport_onDataRange(begin, chunk) {
     var listeners = this._rangeListeners;
     for (var i = 0, n = listeners.length; i &lt; n; ++i) {
       listeners[i](begin, chunk);
     }
   },
</PRE><PRE>   onDataProgress: function PDFDataRangeTransport_onDataProgress(loaded) {
     this._readyCapability.promise.then(function () {
       var listeners = this._progressListeners;
       for (var i = 0, n = listeners.length; i &lt; n; ++i) {
         listeners[i](loaded);
       }
     }.bind(this));
   },
</PRE><PRE>   onDataProgressiveRead:
       function PDFDataRangeTransport_onDataProgress(chunk) {
     this._readyCapability.promise.then(function () {
       var listeners = this._progressiveReadListeners;
       for (var i = 0, n = listeners.length; i &lt; n; ++i) {
         listeners[i](chunk);
       }
     }.bind(this));
   },
</PRE><PRE>   transportReady: function PDFDataRangeTransport_transportReady() {
     this._readyCapability.resolve();
   },
</PRE><PRE>   requestDataRange:
       function PDFDataRangeTransport_requestDataRange(begin, end) {
     throw new Error('Abstract method PDFDataRangeTransport.requestDataRange');
   }
 };
 return PDFDataRangeTransport;
</PRE><P>})();
</P><P>PDFJS.PDFDataRangeTransport = PDFDataRangeTransport;
</P><P>/**
</P><PRE>* Proxy to a PDFDocument in the worker thread. Also, contains commonly used
* properties that can be read synchronously.
* @class
*/
</PRE><P>var PDFDocumentProxy = (function PDFDocumentProxyClosure() {
</P><PRE> function PDFDocumentProxy(pdfInfo, transport) {
   this.pdfInfo = pdfInfo;
   this.transport = transport;
 }
 PDFDocumentProxy.prototype = /** @lends PDFDocumentProxy.prototype */ {
   /**
    * @return {number} Total number of pages the PDF contains.
    */
   get numPages() {
     return this.pdfInfo.numPages;
   },
   /**
    * @return {string} A unique ID to identify a PDF. Not guaranteed to be
    * unique.
    */
   get fingerprint() {
     return this.pdfInfo.fingerprint;
   },
   /**
    * @param {number} pageNumber The page number to get. The first page is 1.
    * @return {Promise} A promise that is resolved with a {@link PDFPageProxy}
    * object.
    */
   getPage: function PDFDocumentProxy_getPage(pageNumber) {
     return this.transport.getPage(pageNumber);
   },
   /**
    * @param <A href="/wiki/index.php?title=Template:Num:_number,_gen:_number&amp;action=edit&amp;redlink=1" class="new" title="Template:Num: number, gen: number (page does not exist)">Template:Num: number, gen: number</A> ref The page reference. Must have
    *   the 'num' and 'gen' properties.
    * @return {Promise} A promise that is resolved with the page index that is
    * associated with the reference.
    */
   getPageIndex: function PDFDocumentProxy_getPageIndex(ref) {
     return this.transport.getPageIndex(ref);
   },
   /**
    * @return {Promise} A promise that is resolved with a lookup table for
    * mapping named destinations to reference numbers.
    *
    * This can be slow for large documents: use getDestination instead
    */
   getDestinations: function PDFDocumentProxy_getDestinations() {
     return this.transport.getDestinations();
   },
   /**
    * @param {string} id The named destination to get.
    * @return {Promise} A promise that is resolved with all information
    * of the given named destination.
    */
   getDestination: function PDFDocumentProxy_getDestination(id) {
     return this.transport.getDestination(id);
   },
   /**
    * @return {Promise} A promise that is resolved with a lookup table for
    * mapping named attachments to their content.
    */
   getAttachments: function PDFDocumentProxy_getAttachments() {
     return this.transport.getAttachments();
   },
   /**
    * @return {Promise} A promise that is resolved with an array of all the
    * JavaScript strings in the name tree.
    */
   getJavaScript: function PDFDocumentProxy_getJavaScript() {
     return this.transport.getJavaScript();
   },
   /**
    * @return {Promise} A promise that is resolved with an {Array} that is a
    * tree outline (if it has one) of the PDF. The tree is in the format of:
    * [
    *  {
    *   title: string,
    *   bold: boolean,
    *   italic: boolean,
    *   color: rgb array,
    *   dest: dest obj,
    *   items: array of more items like this
    *  },
    *  ...
    * ].
    */
   getOutline: function PDFDocumentProxy_getOutline() {
     return this.transport.getOutline();
   },
   /**
    * @return {Promise} A promise that is resolved with an {Object} that has
    * info and metadata properties.  Info is an {Object} filled with anything
    * available in the information dictionary and similarly metadata is a
    * {Metadata} object with information from the metadata section of the PDF.
    */
   getMetadata: function PDFDocumentProxy_getMetadata() {
     return this.transport.getMetadata();
   },
   /**
    * @return {Promise} A promise that is resolved with a TypedArray that has
    * the raw data from the PDF.
    */
   getData: function PDFDocumentProxy_getData() {
     return this.transport.getData();
   },
   /**
    * @return {Promise} A promise that is resolved when the document's data
    * is loaded. It is resolved with an {Object} that contains the length
    * property that indicates size of the PDF data in bytes.
    */
   getDownloadInfo: function PDFDocumentProxy_getDownloadInfo() {
     return this.transport.downloadInfoCapability.promise;
   },
   /**
    * @return {Promise} A promise this is resolved with current stats about
    * document structures (see {@link PDFDocumentStats}).
    */
   getStats: function PDFDocumentProxy_getStats() {
     return this.transport.getStats();
   },
   /**
    * Cleans up resources allocated by the document, e.g. created @font-face.
    */
   cleanup: function PDFDocumentProxy_cleanup() {
     this.transport.startCleanup();
   },
   /**
    * Destroys current document instance and terminates worker.
    */
   destroy: function PDFDocumentProxy_destroy() {
     this.transport.destroy();
   }
 };
 return PDFDocumentProxy;
</PRE><P>})();
</P><P>/**
</P><PRE>* Page text content.
*
* @typedef {Object} TextContent
* @property {array} items - array of {@link TextItem}
* @property {Object} styles - {@link TextStyles} objects, indexed by font
*                    name.
*/
</PRE><P>/**
</P><PRE>* Page text content part.
*
* @typedef {Object} TextItem
* @property {string} str - text content.
* @property {string} dir - text direction: 'ttb', 'ltr' or 'rtl'.
* @property {array} transform - transformation matrix.
* @property {number} width - width in device space.
* @property {number} height - height in device space.
* @property {string} fontName - font name used by pdf.js for converted font.
*/
</PRE><P>/**
</P><PRE>* Text style.
*
* @typedef {Object} TextStyle
* @property {number} ascent - font ascent.
* @property {number} descent - font descent.
* @property {boolean} vertical - text is in vertical mode.
* @property {string} fontFamily - possible font family
*/
</PRE><P>/**
</P><PRE>* Page render parameters.
*
* @typedef {Object} RenderParameters
* @property {Object} canvasContext - A 2D context of a DOM Canvas object.
* @property {PDFJS.PageViewport} viewport - Rendering viewport obtained by
*                                calling of PDFPage.getViewport method.
* @property {string} intent - Rendering intent, can be 'display' or 'print'
*                    (default value is 'display').
* @property {Object} imageLayer - (optional) An object that has beginLayout,
*                    endLayout and appendImage functions.
* @property {function} continueCallback - (deprecated) A function that will be
*                      called each time the rendering is paused.  To continue
*                      rendering call the function that is the first argument
*                      to the callback.
*/
</PRE><P>/**
</P><PRE>* PDF page operator list.
*
* @typedef {Object} PDFOperatorList
* @property {Array} fnArray - Array containing the operator functions.
* @property {Array} argsArray - Array containing the arguments of the
*                               functions.
*/
</PRE><P>/**
</P><PRE>* Proxy to a PDFPage in the worker thread.
* @class
*/
</PRE><P>var PDFPageProxy = (function PDFPageProxyClosure() {
</P><PRE> function PDFPageProxy(pageIndex, pageInfo, transport) {
   this.pageIndex = pageIndex;
   this.pageInfo = pageInfo;
   this.transport = transport;
   this.stats = new StatTimer();
   this.stats.enabled = !!globalScope.PDFJS.enableStats;
   this.commonObjs = transport.commonObjs;
   this.objs = new PDFObjects();
   this.cleanupAfterRender = false;
   this.pendingDestroy = false;
   this.intentStates = {};
 }
 PDFPageProxy.prototype = /** @lends PDFPageProxy.prototype */ {
   /**
    * @return {number} Page number of the page. First page is 1.
    */
   get pageNumber() {
     return this.pageIndex + 1;
   },
   /**
    * @return {number} The number of degrees the page is rotated clockwise.
    */
   get rotate() {
     return this.pageInfo.rotate;
   },
   /**
    * @return {Object} The reference that points to this page. It has 'num' and
    * 'gen' properties.
    */
   get ref() {
     return this.pageInfo.ref;
   },
   /**
    * @return {Array} An array of the visible portion of the PDF page in the
    * user space units - [x1, y1, x2, y2].
    */
   get view() {
     return this.pageInfo.view;
   },
   /**
    * @param {number} scale The desired scale of the viewport.
    * @param {number} rotate Degrees to rotate the viewport. If omitted this
    * defaults to the page rotation.
    * @return {PDFJS.PageViewport} Contains 'width' and 'height' properties
    * along with transforms required for rendering.
    */
   getViewport: function PDFPageProxy_getViewport(scale, rotate) {
     if (arguments.length &lt; 2) {
       rotate = this.rotate;
     }
     return new PDFJS.PageViewport(this.view, scale, rotate, 0, 0);
   },
   /**
    * @return {Promise} A promise that is resolved with an {Array} of the
    * annotation objects.
    */
   getAnnotations: function PDFPageProxy_getAnnotations() {
     if (!this.annotationsPromise) {
       this.annotationsPromise = this.transport.getAnnotations(this.pageIndex);
     }
     return this.annotationsPromise;
   },
   /**
    * Begins the process of rendering a page to the desired context.
    * @param {RenderParameters} params Page render parameters.
    * @return {RenderTask} An object that contains the promise, which
    *                      is resolved when the page finishes rendering.
    */
   render: function PDFPageProxy_render(params) {
     var stats = this.stats;
     stats.time('Overall');
</PRE><PRE>     // If there was a pending destroy cancel it so no cleanup happens during
     // this call to render.
     this.pendingDestroy = false;
</PRE><PRE>     var renderingIntent = (params.intent === 'print' ? 'print' : 'display');
</PRE><PRE>     if (!this.intentStates[renderingIntent]) {
       this.intentStates[renderingIntent] = {};
     }
     var intentState = this.intentStates[renderingIntent];
</PRE><PRE>     // If there's no displayReadyCapability yet, then the operatorList
     // was never requested before. Make the request and create the promise.
     if (!intentState.displayReadyCapability) {
       intentState.receivingOperatorList = true;
       intentState.displayReadyCapability = createPromiseCapability();
       intentState.operatorList = {
         fnArray: [],
         argsArray: [],
         lastChunk: false
       };
</PRE><PRE>       this.stats.time('Page Request');
       this.transport.messageHandler.send('RenderPageRequest', {
         pageIndex: this.pageNumber - 1,
         intent: renderingIntent
       });
     }
</PRE><PRE>     var internalRenderTask = new InternalRenderTask(complete, params,
                                                     this.objs,
                                                     this.commonObjs,
                                                     intentState.operatorList,
                                                     this.pageNumber);
     internalRenderTask.useRequestAnimationFrame = renderingIntent !== 'print';
     if (!intentState.renderTasks) {
       intentState.renderTasks = [];
     }
     intentState.renderTasks.push(internalRenderTask);
     var renderTask = internalRenderTask.task;
</PRE><PRE>     // Obsolete parameter support
     if (params.continueCallback) {
       renderTask.onContinue = params.continueCallback;
     }
</PRE><PRE>     var self = this;
     intentState.displayReadyCapability.promise.then(
       function pageDisplayReadyPromise(transparency) {
         if (self.pendingDestroy) {
           complete();
           return;
         }
         stats.time('Rendering');
         internalRenderTask.initalizeGraphics(transparency);
         internalRenderTask.operatorListChanged();
       },
       function pageDisplayReadPromiseError(reason) {
         complete(reason);
       }
     );
</PRE><PRE>     function complete(error) {
       var i = intentState.renderTasks.indexOf(internalRenderTask);
       if (i &gt;= 0) {
         intentState.renderTasks.splice(i, 1);
       }
</PRE><PRE>       if (self.cleanupAfterRender) {
         self.pendingDestroy = true;
       }
       self._tryDestroy();
</PRE><PRE>       if (error) {
         internalRenderTask.capability.reject(error);
       } else {
         internalRenderTask.capability.resolve();
       }
       stats.timeEnd('Rendering');
       stats.timeEnd('Overall');
     }
</PRE><PRE>     return renderTask;
   },
</PRE><PRE>   /**
    * @return {Promise} A promise resolved with an {@link PDFOperatorList}
    * object that represents page's operator list.
    */
   getOperatorList: function PDFPageProxy_getOperatorList() {
     function operatorListChanged() {
       if (intentState.operatorList.lastChunk) {
         intentState.opListReadCapability.resolve(intentState.operatorList);
       }
     }
</PRE><PRE>     var renderingIntent = 'oplist';
     if (!this.intentStates[renderingIntent]) {
       this.intentStates[renderingIntent] = {};
     }
     var intentState = this.intentStates[renderingIntent];
</PRE><PRE>     if (!intentState.opListReadCapability) {
       var opListTask = {};
       opListTask.operatorListChanged = operatorListChanged;
       intentState.receivingOperatorList = true;
       intentState.opListReadCapability = createPromiseCapability();
       intentState.renderTasks = [];
       intentState.renderTasks.push(opListTask);
       intentState.operatorList = {
         fnArray: [],
         argsArray: [],
         lastChunk: false
       };
</PRE><PRE>       this.transport.messageHandler.send('RenderPageRequest', {
         pageIndex: this.pageIndex,
         intent: renderingIntent
       });
     }
     return intentState.opListReadCapability.promise;
   },
</PRE><PRE>   /**
    * @return {Promise} That is resolved a {@link TextContent}
    * object that represent the page text content.
    */
   getTextContent: function PDFPageProxy_getTextContent() {
     return this.transport.messageHandler.sendWithPromise('GetTextContent', {
       pageIndex: this.pageNumber - 1
     });
   },
   /**
    * Destroys resources allocated by the page.
    */
   destroy: function PDFPageProxy_destroy() {
     this.pendingDestroy = true;
     this._tryDestroy();
   },
   /**
    * For internal use only. Attempts to clean up if rendering is in a state
    * where that's possible.
    * @ignore
    */
   _tryDestroy: function PDFPageProxy__destroy() {
     if (!this.pendingDestroy ||
         Object.keys(this.intentStates).some(function(intent) {
           var intentState = this.intentStates[intent];
           return (intentState.renderTasks.length !== 0 ||
                   intentState.receivingOperatorList);
         }, this)) {
       return;
     }
</PRE><PRE>     Object.keys(this.intentStates).forEach(function(intent) {
       delete this.intentStates[intent];
     }, this);
     this.objs.clear();
     this.annotationsPromise = null;
     this.pendingDestroy = false;
   },
   /**
    * For internal use only.
    * @ignore
    */
   _startRenderPage: function PDFPageProxy_startRenderPage(transparency,
                                                           intent) {
     var intentState = this.intentStates[intent];
     // TODO Refactor RenderPageRequest to separate rendering
     // and operator list logic
     if (intentState.displayReadyCapability) {
       intentState.displayReadyCapability.resolve(transparency);
     }
   },
   /**
    * For internal use only.
    * @ignore
    */
   _renderPageChunk: function PDFPageProxy_renderPageChunk(operatorListChunk,
                                                           intent) {
     var intentState = this.intentStates[intent];
     var i, ii;
     // Add the new chunk to the current operator list.
     for (i = 0, ii = operatorListChunk.length; i &lt; ii; i++) {
       intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
       intentState.operatorList.argsArray.push(
         operatorListChunk.argsArray[i]);
     }
     intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
</PRE><PRE>     // Notify all the rendering tasks there are more operators to be consumed.
     for (i = 0; i &lt; intentState.renderTasks.length; i++) {
       intentState.renderTasks[i].operatorListChanged();
     }
</PRE><PRE>     if (operatorListChunk.lastChunk) {
       intentState.receivingOperatorList = false;
       this._tryDestroy();
     }
   }
 };
 return PDFPageProxy;
</PRE><P>})();
</P><P>/**
</P><PRE>* For internal use only.
* @ignore
*/
</PRE><P>var WorkerTransport = (function WorkerTransportClosure() {
</P><PRE> function WorkerTransport(workerInitializedCapability, pdfDataRangeTransport) {
   this.pdfDataRangeTransport = pdfDataRangeTransport;
   this.workerInitializedCapability = workerInitializedCapability;
   this.commonObjs = new PDFObjects();
</PRE><PRE>   this.loadingTask = null;
</PRE><PRE>   this.pageCache = [];
   this.pagePromises = [];
   this.downloadInfoCapability = createPromiseCapability();
</PRE><PRE>   // If worker support isn't disabled explicit and the browser has worker
   // support, create a new web worker and test if it/the browser fullfills
   // all requirements to run parts of pdf.js in a web worker.
   // Right now, the requirement is, that an Uint8Array is still an Uint8Array
   // as it arrives on the worker. Chrome added this with version 15.
   if (!globalScope.PDFJS.disableWorker &amp;&amp; typeof Worker !== 'undefined') {
     var workerSrc = PDFJS.workerSrc;
     if (!workerSrc) {
       error('No PDFJS.workerSrc specified');
     }
</PRE><PRE>     try {
       // Some versions of FF can't create a worker on localhost, see:
       // <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=683280">https://bugzilla.mozilla.org/show_bug.cgi?id=683280</A>
       var worker = new Worker(workerSrc);
       var messageHandler = new MessageHandler('main', worker);
       this.messageHandler = messageHandler;
</PRE><PRE>       messageHandler.on('test', function transportTest(data) {
         var supportTypedArray = data &amp;&amp; data.supportTypedArray;
         if (supportTypedArray) {
           this.worker = worker;
           if (!data.supportTransfers) {
             PDFJS.postMessageTransfers = false;
           }
           this.setupMessageHandler(messageHandler);
           workerInitializedCapability.resolve();
         } else {
           this.setupFakeWorker();
         }
       }.bind(this));
</PRE><PRE>       var testObj = new Uint8Array([PDFJS.postMessageTransfers ? 255 : 0]);
       // Some versions of Opera throw a DATA_CLONE_ERR on serializing the
       // typed array. Also, checking if we can use transfers.
       try {
         messageHandler.send('test', testObj, [testObj.buffer]);
       } catch (ex) {
         info('Cannot use postMessage transfers');
         testObj[0] = 0;
         messageHandler.send('test', testObj);
       }
       return;
     } catch (e) {
       info('The worker has been disabled.');
     }
   }
   // Either workers are disabled, not supported or have thrown an exception.
   // Thus, we fallback to a faked worker.
   this.setupFakeWorker();
 }
 WorkerTransport.prototype = {
   destroy: function WorkerTransport_destroy() {
     this.pageCache = [];
     this.pagePromises = [];
     var self = this;
     this.messageHandler.sendWithPromise('Terminate', null).then(function () {
       FontLoader.clear();
       if (self.worker) {
         self.worker.terminate();
       }
     });
   },
</PRE><PRE>   setupFakeWorker: function WorkerTransport_setupFakeWorker() {
     globalScope.PDFJS.disableWorker = true;
</PRE><PRE>     if (!PDFJS.fakeWorkerFilesLoadedCapability) {
       PDFJS.fakeWorkerFilesLoadedCapability = createPromiseCapability();
       // In the developer build load worker_loader which in turn loads all the
       // other files and resolves the promise. In production only the
       // pdf.worker.js file is needed.
       Util.loadScript(PDFJS.workerSrc, function() {
         PDFJS.fakeWorkerFilesLoadedCapability.resolve();
       });
     }
     PDFJS.fakeWorkerFilesLoadedCapability.promise.then(function () {
       warn('Setting up fake worker.');
       // If we don't use a worker, just post/sendMessage to the main thread.
       var fakeWorker = {
         postMessage: function WorkerTransport_postMessage(obj) {
           fakeWorker.onmessage({data: obj});
         },
         terminate: function WorkerTransport_terminate() {}
       };
</PRE><PRE>       var messageHandler = new MessageHandler('main', fakeWorker);
       this.setupMessageHandler(messageHandler);
</PRE><PRE>       // If the main thread is our worker, setup the handling for the messages
       // the main thread sends to it self.
       PDFJS.WorkerMessageHandler.setup(messageHandler);
</PRE><PRE>       this.workerInitializedCapability.resolve();
     }.bind(this));
   },
</PRE><PRE>   setupMessageHandler:
     function WorkerTransport_setupMessageHandler(messageHandler) {
     this.messageHandler = messageHandler;
</PRE><PRE>     function updatePassword(password) {
       messageHandler.send('UpdatePassword', password);
     }
</PRE><PRE>     var pdfDataRangeTransport = this.pdfDataRangeTransport;
     if (pdfDataRangeTransport) {
       pdfDataRangeTransport.addRangeListener(function(begin, chunk) {
         messageHandler.send('OnDataRange', {
           begin: begin,
           chunk: chunk
         });
       });
</PRE><PRE>       pdfDataRangeTransport.addProgressListener(function(loaded) {
         messageHandler.send('OnDataProgress', {
           loaded: loaded
         });
       });
</PRE><PRE>       pdfDataRangeTransport.addProgressiveReadListener(function(chunk) {
         messageHandler.send('OnDataRange', {
           chunk: chunk
         });
       });
</PRE><PRE>       messageHandler.on('RequestDataRange',
         function transportDataRange(data) {
           pdfDataRangeTransport.requestDataRange(data.begin, data.end);
         }, this);
     }
</PRE><PRE>     messageHandler.on('GetDoc', function transportDoc(data) {
       var pdfInfo = data.pdfInfo;
       this.numPages = data.pdfInfo.numPages;
       var pdfDocument = new PDFDocumentProxy(pdfInfo, this);
       this.pdfDocument = pdfDocument;
       this.loadingTask._capability.resolve(pdfDocument);
     }, this);
</PRE><PRE>     messageHandler.on('NeedPassword',
                       function transportNeedPassword(exception) {
       var loadingTask = this.loadingTask;
       if (loadingTask.onPassword) {
         return loadingTask.onPassword(updatePassword,
                                       PasswordResponses.NEED_PASSWORD);
       }
       loadingTask._capability.reject(
         new PasswordException(exception.message, exception.code));
     }, this);
</PRE><PRE>     messageHandler.on('IncorrectPassword',
                       function transportIncorrectPassword(exception) {
       var loadingTask = this.loadingTask;
       if (loadingTask.onPassword) {
         return loadingTask.onPassword(updatePassword,
                                       PasswordResponses.INCORRECT_PASSWORD);
       }
       loadingTask._capability.reject(
         new PasswordException(exception.message, exception.code));
     }, this);
</PRE><PRE>     messageHandler.on('InvalidPDF', function transportInvalidPDF(exception) {
       this.loadingTask._capability.reject(
         new InvalidPDFException(exception.message));
     }, this);
</PRE><PRE>     messageHandler.on('MissingPDF', function transportMissingPDF(exception) {
       this.loadingTask._capability.reject(
         new MissingPDFException(exception.message));
     }, this);
</PRE><PRE>     messageHandler.on('UnexpectedResponse',
                       function transportUnexpectedResponse(exception) {
       this.loadingTask._capability.reject(
         new UnexpectedResponseException(exception.message, exception.status));
     }, this);
</PRE><PRE>     messageHandler.on('UnknownError',
                       function transportUnknownError(exception) {
       this.loadingTask._capability.reject(
         new UnknownErrorException(exception.message, exception.details));
     }, this);
</PRE><PRE>     messageHandler.on('DataLoaded', function transportPage(data) {
       this.downloadInfoCapability.resolve(data);
     }, this);
</PRE><PRE>     messageHandler.on('PDFManagerReady', function transportPage(data) {
       if (this.pdfDataRangeTransport) {
         this.pdfDataRangeTransport.transportReady();
       }
     }, this);
</PRE><PRE>     messageHandler.on('StartRenderPage', function transportRender(data) {
       var page = this.pageCache[data.pageIndex];
</PRE><PRE>       page.stats.timeEnd('Page Request');
       page._startRenderPage(data.transparency, data.intent);
     }, this);
</PRE><PRE>     messageHandler.on('RenderPageChunk', function transportRender(data) {
       var page = this.pageCache[data.pageIndex];
</PRE><PRE>       page._renderPageChunk(data.operatorList, data.intent);
     }, this);
</PRE><PRE>     messageHandler.on('commonobj', function transportObj(data) {
       var id = data[0];
       var type = data[1];
       if (this.commonObjs.hasData(id)) {
         return;
       }
</PRE><PRE>       switch (type) {
         case 'Font':
           var exportedData = data[2];
</PRE><PRE>           var font;
           if ('error' in exportedData) {
             var error = exportedData.error;
             warn('Error during font loading: ' + error);
             this.commonObjs.resolve(id, error);
             break;
           } else {
             font = new FontFaceObject(exportedData);
           }
</PRE><PRE>           FontLoader.bind(
             [font],
             function fontReady(fontObjs) {
               this.commonObjs.resolve(id, font);
             }.bind(this)
           );
           break;
         case 'FontPath':
           this.commonObjs.resolve(id, data[2]);
           break;
         default:
           error('Got unknown common object type ' + type);
       }
     }, this);
</PRE><PRE>     messageHandler.on('obj', function transportObj(data) {
       var id = data[0];
       var pageIndex = data[1];
       var type = data[2];
       var pageProxy = this.pageCache[pageIndex];
       var imageData;
       if (pageProxy.objs.hasData(id)) {
         return;
       }
</PRE><PRE>       switch (type) {
         case 'JpegStream':
           imageData = data[3];
           loadJpegStream(id, imageData, pageProxy.objs);
           break;
         case 'Image':
           imageData = data[3];
           pageProxy.objs.resolve(id, imageData);
</PRE><PRE>           // heuristics that will allow not to store large data
           var MAX_IMAGE_SIZE_TO_STORE = 8000000;
           if (imageData &amp;&amp; 'data' in imageData &amp;&amp;
               imageData.data.length &gt; MAX_IMAGE_SIZE_TO_STORE) {
             pageProxy.cleanupAfterRender = true;
           }
           break;
         default:
           error('Got unknown object type ' + type);
       }
     }, this);
</PRE><PRE>     messageHandler.on('DocProgress', function transportDocProgress(data) {
       var loadingTask = this.loadingTask;
       if (loadingTask.onProgress) {
         loadingTask.onProgress({
           loaded: data.loaded,
           total: data.total
         });
       }
     }, this);
</PRE><PRE>     messageHandler.on('PageError', function transportError(data) {
       var page = this.pageCache[data.pageNum - 1];
       var intentState = page.intentStates[data.intent];
       if (intentState.displayReadyCapability) {
         intentState.displayReadyCapability.reject(data.error);
       } else {
         error(data.error);
       }
     }, this);
</PRE><PRE>     messageHandler.on('JpegDecode', function(data) {
       var imageUrl = data[0];
       var components = data[1];
       if (components !== 3 &amp;&amp; components !== 1) {
         return Promise.reject(
           new Error('Only 3 components or 1 component can be returned'));
       }
</PRE><PRE>       return new Promise(function (resolve, reject) {
         var img = new Image();
         img.onload = function () {
           var width = img.width;
           var height = img.height;
           var size = width * height;
           var rgbaLength = size * 4;
           var buf = new Uint8Array(size * components);
           var tmpCanvas = createScratchCanvas(width, height);
           var tmpCtx = tmpCanvas.getContext('2d');
           tmpCtx.drawImage(img, 0, 0);
           var data = tmpCtx.getImageData(0, 0, width, height).data;
           var i, j;
</PRE><PRE>           if (components === 3) {
             for (i = 0, j = 0; i &lt; rgbaLength; i += 4, j += 3) {
               buf[j] = data[i];
               buf[j + 1] = data[i + 1];
               buf[j + 2] = data[i + 2];
             }
           } else if (components === 1) {
             for (i = 0, j = 0; i &lt; rgbaLength; i += 4, j++) {
               buf[j] = data[i];
             }
           }
           resolve({ data: buf, width: width, height: height});
         };
         img.onerror = function () {
           reject(new Error('JpegDecode failed to load image'));
         };
         img.src = imageUrl;
       });
     });
   },
</PRE><PRE>   fetchDocument: function WorkerTransport_fetchDocument(loadingTask, source) {
     this.loadingTask = loadingTask;
</PRE><PRE>     source.disableAutoFetch = PDFJS.disableAutoFetch;
     source.disableStream = PDFJS.disableStream;
     source.chunkedViewerLoading = !!this.pdfDataRangeTransport;
     if (this.pdfDataRangeTransport) {
       source.length = this.pdfDataRangeTransport.length;
       source.initialData = this.pdfDataRangeTransport.initialData;
     }
     this.messageHandler.send('GetDocRequest', {
       source: source,
       disableRange: PDFJS.disableRange,
       maxImageSize: PDFJS.maxImageSize,
       cMapUrl: PDFJS.cMapUrl,
       cMapPacked: PDFJS.cMapPacked,
       disableFontFace: PDFJS.disableFontFace,
       disableCreateObjectURL: PDFJS.disableCreateObjectURL,
       verbosity: PDFJS.verbosity
     });
   },
</PRE><PRE>   getData: function WorkerTransport_getData() {
     return this.messageHandler.sendWithPromise('GetData', null);
   },
</PRE><PRE>   getPage: function WorkerTransport_getPage(pageNumber, capability) {
     if (pageNumber &lt;= 0 || pageNumber &gt; this.numPages ||
         (pageNumber|0) !== pageNumber) {
       return Promise.reject(new Error('Invalid page request'));
     }
</PRE><PRE>     var pageIndex = pageNumber - 1;
     if (pageIndex in this.pagePromises) {
       return this.pagePromises[pageIndex];
     }
     var promise = this.messageHandler.sendWithPromise('GetPage', {
       pageIndex: pageIndex
     }).then(function (pageInfo) {
       var page = new PDFPageProxy(pageIndex, pageInfo, this);
       this.pageCache[pageIndex] = page;
       return page;
     }.bind(this));
     this.pagePromises[pageIndex] = promise;
     return promise;
   },
</PRE><PRE>   getPageIndex: function WorkerTransport_getPageIndexByRef(ref) {
     return this.messageHandler.sendWithPromise('GetPageIndex', { ref: ref });
   },
</PRE><PRE>   getAnnotations: function WorkerTransport_getAnnotations(pageIndex) {
     return this.messageHandler.sendWithPromise('GetAnnotations',
       { pageIndex: pageIndex });
   },
</PRE><PRE>   getDestinations: function WorkerTransport_getDestinations() {
     return this.messageHandler.sendWithPromise('GetDestinations', null);
   },
</PRE><PRE>   getDestination: function WorkerTransport_getDestination(id) {
     return this.messageHandler.sendWithPromise('GetDestination', { id: id } );
   },
</PRE><PRE>   getAttachments: function WorkerTransport_getAttachments() {
     return this.messageHandler.sendWithPromise('GetAttachments', null);
   },
</PRE><PRE>   getJavaScript: function WorkerTransport_getJavaScript() {
     return this.messageHandler.sendWithPromise('GetJavaScript', null);
   },
</PRE><PRE>   getOutline: function WorkerTransport_getOutline() {
     return this.messageHandler.sendWithPromise('GetOutline', null);
   },
</PRE><PRE>   getMetadata: function WorkerTransport_getMetadata() {
     return this.messageHandler.sendWithPromise('GetMetadata', null).
       then(function transportMetadata(results) {
       return {
         info: results[0],
         metadata: (results[1] ? new PDFJS.Metadata(results[1]) : null)
       };
     });
   },
</PRE><PRE>   getStats: function WorkerTransport_getStats() {
     return this.messageHandler.sendWithPromise('GetStats', null);
   },
</PRE><PRE>   startCleanup: function WorkerTransport_startCleanup() {
     this.messageHandler.sendWithPromise('Cleanup', null).
       then(function endCleanup() {
       for (var i = 0, ii = this.pageCache.length; i &lt; ii; i++) {
         var page = this.pageCache[i];
         if (page) {
           page.destroy();
         }
       }
       this.commonObjs.clear();
       FontLoader.clear();
     }.bind(this));
   }
 };
 return WorkerTransport;
</PRE><P>})();
</P><P>/**
</P><PRE>* A PDF document and page is built of many objects. E.g. there are objects
* for fonts, images, rendering code and such. These objects might get processed
* inside of a worker. The `PDFObjects` implements some basic functions to
* manage these objects.
* @ignore
*/
</PRE><P>var PDFObjects = (function PDFObjectsClosure() {
</P><PRE> function PDFObjects() {
   this.objs = {};
 }
</PRE><PRE> PDFObjects.prototype = {
   /**
    * Internal function.
    * Ensures there is an object defined for `objId`.
    */
   ensureObj: function PDFObjects_ensureObj(objId) {
     if (this.objs[objId]) {
       return this.objs[objId];
     }
</PRE><PRE>     var obj = {
       capability: createPromiseCapability(),
       data: null,
       resolved: false
     };
     this.objs[objId] = obj;
</PRE><PRE>     return obj;
   },
</PRE><PRE>   /**
    * If called *without* callback, this returns the data of `objId` but the
    * object needs to be resolved. If it isn't, this function throws.
    *
    * If called *with* a callback, the callback is called with the data of the
    * object once the object is resolved. That means, if you call this
    * function and the object is already resolved, the callback gets called
    * right away.
    */
   get: function PDFObjects_get(objId, callback) {
     // If there is a callback, then the get can be async and the object is
     // not required to be resolved right now
     if (callback) {
       this.ensureObj(objId).capability.promise.then(callback);
       return null;
     }
</PRE><PRE>     // If there isn't a callback, the user expects to get the resolved data
     // directly.
     var obj = this.objs[objId];
</PRE><PRE>     // If there isn't an object yet or the object isn't resolved, then the
     // data isn't ready yet!
     if (!obj || !obj.resolved) {
       error('Requesting object that isn\'t resolved yet ' + objId);
     }
</PRE><PRE>     return obj.data;
   },
</PRE><PRE>   /**
    * Resolves the object `objId` with optional `data`.
    */
   resolve: function PDFObjects_resolve(objId, data) {
     var obj = this.ensureObj(objId);
</PRE><PRE>     obj.resolved = true;
     obj.data = data;
     obj.capability.resolve(data);
   },
</PRE><PRE>   isResolved: function PDFObjects_isResolved(objId) {
     var objs = this.objs;
</PRE><PRE>     if (!objs[objId]) {
       return false;
     } else {
       return objs[objId].resolved;
     }
   },
</PRE><PRE>   hasData: function PDFObjects_hasData(objId) {
     return this.isResolved(objId);
   },
</PRE><PRE>   /**
    * Returns the data of `objId` if object exists, null otherwise.
    */
   getData: function PDFObjects_getData(objId) {
     var objs = this.objs;
     if (!objs[objId] || !objs[objId].resolved) {
       return null;
     } else {
       return objs[objId].data;
     }
   },
</PRE><PRE>   clear: function PDFObjects_clear() {
     this.objs = {};
   }
 };
 return PDFObjects;
</PRE><P>})();
</P><P>/**
</P><PRE>* Allows controlling of the rendering tasks.
* @class
*/
</PRE><P>var RenderTask = (function RenderTaskClosure() {
</P><PRE> function RenderTask(internalRenderTask) {
   this._internalRenderTask = internalRenderTask;
</PRE><PRE>   /**
    * Callback for incremental rendering -- a function that will be called
    * each time the rendering is paused.  To continue rendering call the
    * function that is the first argument to the callback.
    * @type {function}
    */
   this.onContinue = null;
 }
</PRE><PRE> RenderTask.prototype = /** @lends RenderTask.prototype */ {
   /**
    * Promise for rendering task completion.
    * @return {Promise}
    */
   get promise() {
     return this._internalRenderTask.capability.promise;
   },
</PRE><PRE>   /**
    * Cancels the rendering task. If the task is currently rendering it will
    * not be cancelled until graphics pauses with a timeout. The promise that
    * this object extends will resolved when cancelled.
    */
   cancel: function RenderTask_cancel() {
     this._internalRenderTask.cancel();
   },
</PRE><PRE>   /**
    * Registers callbacks to indicate the rendering task completion.
    *
    * @param {function} onFulfilled The callback for the rendering completion.
    * @param {function} onRejected The callback for the rendering failure.
    * @return {Promise} A promise that is resolved after the onFulfilled or
    *                   onRejected callback.
    */
   then: function RenderTask_then(onFulfilled, onRejected) {
     return this.promise.then.apply(this.promise, arguments);
   }
 };
</PRE><PRE> return RenderTask;
</PRE><P>})();
</P><P>/**
</P><PRE>* For internal use only.
* @ignore
*/
</PRE><P>var InternalRenderTask = (function InternalRenderTaskClosure() {
</P><PRE> function InternalRenderTask(callback, params, objs, commonObjs, operatorList,
                             pageNumber) {
   this.callback = callback;
   this.params = params;
   this.objs = objs;
   this.commonObjs = commonObjs;
   this.operatorListIdx = null;
   this.operatorList = operatorList;
   this.pageNumber = pageNumber;
   this.running = false;
   this.graphicsReadyCallback = null;
   this.graphicsReady = false;
   this.useRequestAnimationFrame = false;
   this.cancelled = false;
   this.capability = createPromiseCapability();
   this.task = new RenderTask(this);
   // caching this-bound methods
   this._continueBound = this._continue.bind(this);
   this._scheduleNextBound = this._scheduleNext.bind(this);
   this._nextBound = this._next.bind(this);
 }
</PRE><PRE> InternalRenderTask.prototype = {
</PRE><PRE>   initalizeGraphics:
       function InternalRenderTask_initalizeGraphics(transparency) {
</PRE><PRE>     if (this.cancelled) {
       return;
     }
     if (PDFJS.pdfBug &amp;&amp; 'StepperManager' in globalScope &amp;&amp;
         globalScope.StepperManager.enabled) {
       this.stepper = globalScope.StepperManager.create(this.pageNumber - 1);
       this.stepper.init(this.operatorList);
       this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
     }
</PRE><PRE>     var params = this.params;
     this.gfx = new CanvasGraphics(params.canvasContext, this.commonObjs,
                                   this.objs, params.imageLayer);
</PRE><PRE>     this.gfx.beginDrawing(params.viewport, transparency);
     this.operatorListIdx = 0;
     this.graphicsReady = true;
     if (this.graphicsReadyCallback) {
       this.graphicsReadyCallback();
     }
   },
</PRE><PRE>   cancel: function InternalRenderTask_cancel() {
     this.running = false;
     this.cancelled = true;
     this.callback('cancelled');
   },
</PRE><PRE>   operatorListChanged: function InternalRenderTask_operatorListChanged() {
     if (!this.graphicsReady) {
       if (!this.graphicsReadyCallback) {
         this.graphicsReadyCallback = this._continueBound;
       }
       return;
     }
</PRE><PRE>     if (this.stepper) {
       this.stepper.updateOperatorList(this.operatorList);
     }
</PRE><PRE>     if (this.running) {
       return;
     }
     this._continue();
   },
</PRE><PRE>   _continue: function InternalRenderTask__continue() {
     this.running = true;
     if (this.cancelled) {
       return;
     }
     if (this.task.onContinue) {
       this.task.onContinue.call(this.task, this._scheduleNextBound);
     } else {
       this._scheduleNext();
     }
   },
</PRE><PRE>   _scheduleNext: function InternalRenderTask__scheduleNext() {
     if (this.useRequestAnimationFrame) {
       window.requestAnimationFrame(this._nextBound);
     } else {
       Promise.resolve(undefined).then(this._nextBound);
     }
   },
</PRE><PRE>   _next: function InternalRenderTask__next() {
     if (this.cancelled) {
       return;
     }
     this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList,
                                       this.operatorListIdx,
                                       this._continueBound,
                                       this.stepper);
     if (this.operatorListIdx === this.operatorList.argsArray.length) {
       this.running = false;
       if (this.operatorList.lastChunk) {
         this.gfx.endDrawing();
         this.callback();
       }
     }
   }
</PRE><PRE> };
</PRE><PRE> return InternalRenderTask;
</PRE><P>})();
</P><P>
var Metadata = PDFJS.Metadata = (function MetadataClosure() {
</P><PRE> function fixMetadata(meta) {
   return meta.replace(/&gt;\\376\\377([^&lt;]+)/g, function(all, codes) {
     var bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g,
                               function(code, d1, d2, d3) {
       return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
     });
     var chars = <I>;</I>
     for (var i = 0; i &lt; bytes.length; i += 2) {
       var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);
       chars += code &gt;= 32 &amp;&amp; code &lt; 127 &amp;&amp; code !== 60 &amp;&amp; code !== 62 &amp;&amp;
         code !== 38 &amp;&amp; false ? String.fromCharCode(code) :
         '&amp;#x' + (0x10000 + code).toString(16).substring(1) + ';';
     }
     return '&gt;' + chars;
   });
 }
</PRE><PRE> function Metadata(meta) {
   if (typeof meta === 'string') {
     // Ghostscript produces invalid metadata
     meta = fixMetadata(meta);
</PRE><PRE>     var parser = new DOMParser();
     meta = parser.parseFromString(meta, 'application/xml');
   } else if (!(meta instanceof Document)) {
     error('Metadata: Invalid metadata object');
   }
</PRE><PRE>   this.metaDocument = meta;
   this.metadata = {};
   this.parse();
 }
</PRE><PRE> Metadata.prototype = {
   parse: function Metadata_parse() {
     var doc = this.metaDocument;
     var rdf = doc.documentElement;
</PRE><PRE>     if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') { // Wrapped in &lt;xmpmeta&gt;
       rdf = rdf.firstChild;
       while (rdf &amp;&amp; rdf.nodeName.toLowerCase() !== 'rdf:rdf') {
         rdf = rdf.nextSibling;
       }
     }
</PRE><PRE>     var nodeName = (rdf) ? rdf.nodeName.toLowerCase() : null;
     if (!rdf || nodeName !== 'rdf:rdf' || !rdf.hasChildNodes()) {
       return;
     }
</PRE><PRE>     var children = rdf.childNodes, desc, entry, name, i, ii, length, iLength;
     for (i = 0, length = children.length; i &lt; length; i++) {
       desc = children[i];
       if (desc.nodeName.toLowerCase() !== 'rdf:description') {
         continue;
       }
</PRE><PRE>       for (ii = 0, iLength = desc.childNodes.length; ii &lt; iLength; ii++) {
         if (desc.childNodes[ii].nodeName.toLowerCase() !== '#text') {
           entry = desc.childNodes[ii];
           name = entry.nodeName.toLowerCase();
           this.metadata[name] = entry.textContent.trim();
         }
       }
     }
   },
</PRE><PRE>   get: function Metadata_get(name) {
     return this.metadata[name] || null;
   },
</PRE><PRE>   has: function Metadata_has(name) {
     return typeof this.metadata[name] !== 'undefined';
   }
 };
</PRE><PRE> return Metadata;
</PRE><P>})();
</P><P>
// &lt;canvas&gt; contexts store most of the state we need natively.
// However, PDF needs a bit more state, which we store here.
</P><P>// Minimal font size that would be used during canvas fillText operations.
var MIN_FONT_SIZE = 16;
// Maximum font size that would be used during canvas fillText operations.
var MAX_FONT_SIZE = 100;
var MAX_GROUP_SIZE = 4096;
</P><P>// Heuristic value used when enforcing minimum line widths.
var MIN_WIDTH_FACTOR = 0.65;
</P><P>var COMPILE_TYPE3_GLYPHS = true;
var MAX_SIZE_TO_COMPILE = 1000;
</P><P>var FULL_CHUNK_HEIGHT = 16;
</P><P>function createScratchCanvas(width, height) {
</P><PRE> var canvas = document.createElement('canvas');
 canvas.width = width;
 canvas.height = height;
 return canvas;
</PRE><P>}
</P><P>function addContextCurrentTransform(ctx) {
</P><PRE> // If the context doesn't expose a `mozCurrentTransform`, add a JS based one.
 if (!ctx.mozCurrentTransform) {
   ctx._originalSave = ctx.save;
   ctx._originalRestore = ctx.restore;
   ctx._originalRotate = ctx.rotate;
   ctx._originalScale = ctx.scale;
   ctx._originalTranslate = ctx.translate;
   ctx._originalTransform = ctx.transform;
   ctx._originalSetTransform = ctx.setTransform;
</PRE><PRE>   ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
   ctx._transformStack = [];
</PRE><PRE>   Object.defineProperty(ctx, 'mozCurrentTransform', {
     get: function getCurrentTransform() {
       return this._transformMatrix;
     }
   });
</PRE><PRE>   Object.defineProperty(ctx, 'mozCurrentTransformInverse', {
     get: function getCurrentTransformInverse() {
       // Calculation done using WolframAlpha:
       // <A rel="nofollow" class="external free" href="http://www.wolframalpha.com/input/">http://www.wolframalpha.com/input/</A>?
       //   i=Inverse+{{a%2C+c%2C+e}%2C+{b%2C+d%2C+f}%2C+{0%2C+0%2C+1}}
</PRE><PRE>       var m = this._transformMatrix;
       var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];
</PRE><PRE>       var ad_bc = a * d - b * c;
       var bc_ad = b * c - a * d;
</PRE><PRE>       return [
         d / ad_bc,
         b / bc_ad,
         c / bc_ad,
         a / ad_bc,
         (d * e - c * f) / bc_ad,
         (b * e - a * f) / ad_bc
       ];
     }
   });
</PRE><PRE>   ctx.save = function ctxSave() {
     var old = this._transformMatrix;
     this._transformStack.push(old);
     this._transformMatrix = old.slice(0, 6);
</PRE><PRE>     this._originalSave();
   };
</PRE><PRE>   ctx.restore = function ctxRestore() {
     var prev = this._transformStack.pop();
     if (prev) {
       this._transformMatrix = prev;
       this._originalRestore();
     }
   };
</PRE><PRE>   ctx.translate = function ctxTranslate(x, y) {
     var m = this._transformMatrix;
     m[4] = m[0] * x + m[2] * y + m[4];
     m[5] = m[1] * x + m[3] * y + m[5];
</PRE><PRE>  this._originalTranslate(x, y);
   };
</PRE><PRE>   ctx.scale = function ctxScale(x, y) {
     var m = this._transformMatrix;
     m[0] = m[0] * x;
     m[1] = m[1] * x;
     m[2] = m[2] * y;
     m[3] = m[3] * y;
</PRE><PRE>     this._originalScale(x, y);
   };
</PRE><PRE>   ctx.transform = function ctxTransform(a, b, c, d, e, f) {
     var m = this._transformMatrix;
     this._transformMatrix = [
       m[0] * a + m[2] * b,
       m[1] * a + m[3] * b,
       m[0] * c + m[2] * d,
       m[1] * c + m[3] * d,
       m[0] * e + m[2] * f + m[4],
       m[1] * e + m[3] * f + m[5]
     ];
</PRE><PRE>     ctx._originalTransform(a, b, c, d, e, f);
   };
</PRE><PRE>   ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
     this._transformMatrix = [a, b, c, d, e, f];
</PRE><PRE>     ctx._originalSetTransform(a, b, c, d, e, f);
   };
</PRE><PRE>   ctx.rotate = function ctxRotate(angle) {
     var cosValue = Math.cos(angle);
     var sinValue = Math.sin(angle);
</PRE><PRE>     var m = this._transformMatrix;
     this._transformMatrix = [
       m[0] * cosValue + m[2] * sinValue,
       m[1] * cosValue + m[3] * sinValue,
       m[0] * (-sinValue) + m[2] * cosValue,
       m[1] * (-sinValue) + m[3] * cosValue,
       m[4],
       m[5]
     ];
</PRE><PRE>     this._originalRotate(angle);
   };
 }
</PRE><P>}
</P><P>var CachedCanvases = (function CachedCanvasesClosure() {
</P><PRE> var cache = {};
 return {
   getCanvas: function CachedCanvases_getCanvas(id, width, height,
                                                trackTransform) {
     var canvasEntry;
     if (cache[id] !== undefined) {
       canvasEntry = cache[id];
       canvasEntry.canvas.width = width;
       canvasEntry.canvas.height = height;
       // reset canvas transform for emulated mozCurrentTransform, if needed
       canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
     } else {
       var canvas = createScratchCanvas(width, height);
       var ctx = canvas.getContext('2d');
       if (trackTransform) {
         addContextCurrentTransform(ctx);
       }
       cache[id] = canvasEntry = {canvas: canvas, context: ctx};
     }
     return canvasEntry;
   },
   clear: function () {
     for (var id in cache) {
       var canvasEntry = cache[id];
       // Zeroing the width and height causes Firefox to release graphics
       // resources immediately, which can greatly reduce memory consumption.
       canvasEntry.canvas.width = 0;
       canvasEntry.canvas.height = 0;
       delete cache[id];
     }
   }
 };
</PRE><P>})();
</P><P>function compileType3Glyph(imgData) {
</P><PRE> var POINT_TO_PROCESS_LIMIT = 1000;
</PRE><PRE> var width = imgData.width, height = imgData.height;
 var i, j, j0, width1 = width + 1;
 var points = new Uint8Array(width1 * (height + 1));
 var POINT_TYPES =
     new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
</PRE><PRE> // decodes bit-packed mask data
 var lineSize = (width + 7) &amp; ~7, data0 = imgData.data;
 var data = new Uint8Array(lineSize * height), pos = 0, ii;
 for (i = 0, ii = data0.length; i &lt; ii; i++) {
   var mask = 128, elem = data0[i];
   while (mask &gt; 0) {
     data[pos++] = (elem &amp; mask) ? 0 : 255;
     mask &gt;&gt;= 1;
   }
 }
</PRE><PRE> // finding iteresting points: every point is located between mask pixels,
 // so there will be points of the (width + 1)x(height + 1) grid. Every point
 // will have flags assigned based on neighboring mask pixels:
 //   4 | 8
 //   --P--
 //   2 | 1
 // We are interested only in points with the flags:
 //   - outside corners: 1, 2, 4, 8;
 //   - inside corners: 7, 11, 13, 14;
 //   - and, intersections: 5, 10.
 var count = 0;
 pos = 0;
 if (data[pos] !== 0) {
   points[0] = 1;
   ++count;
 }
 for (j = 1; j &lt; width; j++) {
   if (data[pos] !== data[pos + 1]) {
     points[j] = data[pos] ? 2 : 1;
     ++count;
   }
   pos++;
 }
 if (data[pos] !== 0) {
   points[j] = 2;
   ++count;
 }
 for (i = 1; i &lt; height; i++) {
   pos = i * lineSize;
   j0 = i * width1;
   if (data[pos - lineSize] !== data[pos]) {
     points[j0] = data[pos] ? 1 : 8;
     ++count;
   }
   // 'sum' is the position of the current pixel configuration in the 'TYPES'
   // array (in order 8-1-2-4, so we can use '&gt;&gt;2' to shift the column).
   var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
   for (j = 1; j &lt; width; j++) {
     sum = (sum &gt;&gt; 2) + (data[pos + 1] ? 4 : 0) +
           (data[pos - lineSize + 1] ? 8 : 0);
     if (POINT_TYPES[sum]) {
       points[j0 + j] = POINT_TYPES[sum];
       ++count;
     }
     pos++;
   }
   if (data[pos - lineSize] !== data[pos]) {
     points[j0 + j] = data[pos] ? 2 : 4;
     ++count;
   }
</PRE><PRE>   if (count &gt; POINT_TO_PROCESS_LIMIT) {
     return null;
   }
 }
</PRE><PRE> pos = lineSize * (height - 1);
 j0 = i * width1;
 if (data[pos] !== 0) {
   points[j0] = 8;
   ++count;
 }
 for (j = 1; j &lt; width; j++) {
   if (data[pos] !== data[pos + 1]) {
     points[j0 + j] = data[pos] ? 4 : 8;
     ++count;
   }
   pos++;
 }
 if (data[pos] !== 0) {
   points[j0 + j] = 4;
   ++count;
 }
 if (count &gt; POINT_TO_PROCESS_LIMIT) {
   return null;
 }
</PRE><PRE> // building outlines
 var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
 var outlines = [];
 for (i = 0; count &amp;&amp; i &lt;= height; i++) {
   var p = i * width1;
   var end = p + width;
   while (p &lt; end &amp;&amp; !points[p]) {
     p++;
   }
   if (p === end) {
     continue;
   }
   var coords = [p % width1, i];
</PRE><PRE>   var type = points[p], p0 = p, pp;
   do {
     var step = steps[type];
     do {
       p += step;
     } while (!points[p]);
</PRE><PRE>     pp = points[p];
     if (pp !== 5 &amp;&amp; pp !== 10) {
       // set new direction
       type = pp;
       // delete mark
       points[p] = 0;
     } else { // type is 5 or 10, ie, a crossing
       // set new direction
       type = pp &amp; ((0x33 * type) &gt;&gt; 4);
       // set new type for &quot;future hit&quot;
       points[p] &amp;= (type &gt;&gt; 2 | type &lt;&lt; 2);
     }
</PRE><PRE>     coords.push(p % width1);
     coords.push((p / width1) | 0);
     --count;
   } while (p0 !== p);
   outlines.push(coords);
   --i;
 }
</PRE><PRE> var drawOutline = function(c) {
   c.save();
   // the path shall be painted in [0..1]x[0..1] space
   c.scale(1 / width, -1 / height);
   c.translate(0, -height);
   c.beginPath();
   for (var i = 0, ii = outlines.length; i &lt; ii; i++) {
     var o = outlines[i];
     c.moveTo(o[0], o[1]);
     for (var j = 2, jj = o.length; j &lt; jj; j += 2) {
       c.lineTo(o[j], o[j+1]);
     }
   }
   c.fill();
   c.beginPath();
   c.restore();
 };
</PRE><PRE> return drawOutline;
</PRE><P>}
</P><P>var CanvasExtraState = (function CanvasExtraStateClosure() {
</P><PRE> function CanvasExtraState(old) {
   // Are soft masks and alpha values shapes or opacities?
   this.alphaIsShape = false;
   this.fontSize = 0;
   this.fontSizeScale = 1;
   this.textMatrix = IDENTITY_MATRIX;
   this.textMatrixScale = 1;
   this.fontMatrix = FONT_IDENTITY_MATRIX;
   this.leading = 0;
   // Current point (in user coordinates)
   this.x = 0;
   this.y = 0;
   // Start of text line (in text coordinates)
   this.lineX = 0;
   this.lineY = 0;
   // Character and word spacing
   this.charSpacing = 0;
   this.wordSpacing = 0;
   this.textHScale = 1;
   this.textRenderingMode = TextRenderingMode.FILL;
   this.textRise = 0;
   // Default fore and background colors
   this.fillColor = '#000000';
   this.strokeColor = '#000000';
   this.patternFill = false;
   // Note: fill alpha applies to all non-stroking operations
   this.fillAlpha = 1;
   this.strokeAlpha = 1;
   this.lineWidth = 1;
   this.activeSMask = null; // nonclonable field (see the save method below)
</PRE><PRE>   this.old = old;
 }
</PRE><PRE> CanvasExtraState.prototype = {
   clone: function CanvasExtraState_clone() {
     return Object.create(this);
   },
   setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
     this.x = x;
     this.y = y;
   }
 };
 return CanvasExtraState;
</PRE><P>})();
</P><P>var CanvasGraphics = (function CanvasGraphicsClosure() {
</P><PRE> // Defines the time the executeOperatorList is going to be executing
 // before it stops and shedules a continue of execution.
 var EXECUTION_TIME = 15;
 // Defines the number of steps before checking the execution time
 var EXECUTION_STEPS = 10;
</PRE><PRE> function CanvasGraphics(canvasCtx, commonObjs, objs, imageLayer) {
   this.ctx = canvasCtx;
   this.current = new CanvasExtraState();
   this.stateStack = [];
   this.pendingClip = null;
   this.pendingEOFill = false;
   this.res = null;
   this.xobjs = null;
   this.commonObjs = commonObjs;
   this.objs = objs;
   this.imageLayer = imageLayer;
   this.groupStack = [];
   this.processingType3 = null;
   // Patterns are painted relative to the initial page/form transform, see pdf
   // spec 8.7.2 NOTE 1.
   this.baseTransform = null;
   this.baseTransformStack = [];
   this.groupLevel = 0;
   this.smaskStack = [];
   this.smaskCounter = 0;
   this.tempSMask = null;
   if (canvasCtx) {
     // NOTE: if mozCurrentTransform is polyfilled, then the current state of
     // the transformation must already be set in canvasCtx._transformMatrix.
     addContextCurrentTransform(canvasCtx);
   }
   this.cachedGetSinglePixelWidth = null;
 }
</PRE><PRE> function putBinaryImageData(ctx, imgData) {
   if (typeof ImageData !== 'undefined' &amp;&amp; imgData instanceof ImageData) {
     ctx.putImageData(imgData, 0, 0);
     return;
   }
</PRE><PRE>   // Put the image data to the canvas in chunks, rather than putting the
   // whole image at once.  This saves JS memory, because the ImageData object
   // is smaller. It also possibly saves C++ memory within the implementation
   // of putImageData(). (E.g. in Firefox we make two short-lived copies of
   // the data passed to putImageData()). |n| shouldn't be too small, however,
   // because too many putImageData() calls will slow things down.
   //
   // Note: as written, if the last chunk is partial, the putImageData() call
   // will (conceptually) put pixels past the bounds of the canvas.  But
   // that's ok; any such pixels are ignored.
</PRE><PRE>   var height = imgData.height, width = imgData.width;
   var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
   var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
   var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
</PRE><PRE>   var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
   var srcPos = 0, destPos;
   var src = imgData.data;
   var dest = chunkImgData.data;
   var i, j, thisChunkHeight, elemsInThisChunk;
</PRE><PRE>   // There are multiple forms in which the pixel data can be passed, and
   // imgData.kind tells us which one this is.
   if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {
     // Grayscale, 1 bit per pixel (i.e. black-and-white).
     var srcLength = src.byteLength;
     var dest32 = PDFJS.hasCanvasTypedArrays ? new Uint32Array(dest.buffer) :
       new Uint32ArrayView(dest);
     var dest32DataLength = dest32.length;
     var fullSrcDiff = (width + 7) &gt;&gt; 3;
     var white = 0xFFFFFFFF;
     var black = (PDFJS.isLittleEndian || !PDFJS.hasCanvasTypedArrays) ?
       0xFF000000 : 0x000000FF;
     for (i = 0; i &lt; totalChunks; i++) {
       thisChunkHeight =
         (i &lt; fullChunks) ? FULL_CHUNK_HEIGHT : partialChunkHeight;
       destPos = 0;
       for (j = 0; j &lt; thisChunkHeight; j++) {
         var srcDiff = srcLength - srcPos;
         var k = 0;
         var kEnd = (srcDiff &gt; fullSrcDiff) ? width : srcDiff * 8 - 7;
         var kEndUnrolled = kEnd &amp; ~7;
         var mask = 0;
         var srcByte = 0;
         for (; k &lt; kEndUnrolled; k += 8) {
           srcByte = src[srcPos++];
           dest32[destPos++] = (srcByte &amp; 128) ? white : black;
           dest32[destPos++] = (srcByte &amp; 64) ? white : black;
           dest32[destPos++] = (srcByte &amp; 32) ? white : black;
           dest32[destPos++] = (srcByte &amp; 16) ? white : black;
           dest32[destPos++] = (srcByte &amp; 8) ? white : black;
           dest32[destPos++] = (srcByte &amp; 4) ? white : black;
           dest32[destPos++] = (srcByte &amp; 2) ? white : black;
           dest32[destPos++] = (srcByte &amp; 1) ? white : black;
         }
         for (; k &lt; kEnd; k++) {
            if (mask === 0) {
              srcByte = src[srcPos++];
              mask = 128;
            }
</PRE><PRE>           dest32[destPos++] = (srcByte &amp; mask) ? white : black;
           mask &gt;&gt;= 1;
         }
       }
       // We ran out of input. Make all remaining pixels transparent.
       while (destPos &lt; dest32DataLength) {
         dest32[destPos++] = 0;
       }
</PRE><PRE>       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
     }
   } else if (imgData.kind === ImageKind.RGBA_32BPP) {
     // RGBA, 32-bits per pixel.
</PRE><PRE>     j = 0;
     elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
     for (i = 0; i &lt; fullChunks; i++) {
       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
       srcPos += elemsInThisChunk;
</PRE><PRE>       ctx.putImageData(chunkImgData, 0, j);
       j += FULL_CHUNK_HEIGHT;
     }
     if (i &lt; totalChunks) {
       elemsInThisChunk = width * partialChunkHeight * 4;
       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
       ctx.putImageData(chunkImgData, 0, j);
     }
</PRE><PRE>   } else if (imgData.kind === ImageKind.RGB_24BPP) {
     // RGB, 24-bits per pixel.
     thisChunkHeight = FULL_CHUNK_HEIGHT;
     elemsInThisChunk = width * thisChunkHeight;
     for (i = 0; i &lt; totalChunks; i++) {
       if (i &gt;= fullChunks) {
         thisChunkHeight = partialChunkHeight;
         elemsInThisChunk = width * thisChunkHeight;
       }
</PRE><PRE>       destPos = 0;
       for (j = elemsInThisChunk; j--;) {
         dest[destPos++] = src[srcPos++];
         dest[destPos++] = src[srcPos++];
         dest[destPos++] = src[srcPos++];
         dest[destPos++] = 255;
       }
       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
     }
   } else {
     error('bad image kind: ' + imgData.kind);
   }
 }
</PRE><PRE> function putBinaryImageMask(ctx, imgData) {
   var height = imgData.height, width = imgData.width;
   var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
   var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
   var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
</PRE><PRE>   var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
   var srcPos = 0;
   var src = imgData.data;
   var dest = chunkImgData.data;
</PRE><PRE>   for (var i = 0; i &lt; totalChunks; i++) {
     var thisChunkHeight =
       (i &lt; fullChunks) ? FULL_CHUNK_HEIGHT : partialChunkHeight;
</PRE><PRE>     // Expand the mask so it can be used by the canvas.  Any required
     // inversion has already been handled.
     var destPos = 3; // alpha component offset
     for (var j = 0; j &lt; thisChunkHeight; j++) {
       var mask = 0;
       for (var k = 0; k &lt; width; k++) {
         if (!mask) {
           var elem = src[srcPos++];
           mask = 128;
         }
         dest[destPos] = (elem &amp; mask) ? 0 : 255;
         destPos += 4;
         mask &gt;&gt;= 1;
       }
     }
     ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
   }
 }
</PRE><PRE> function copyCtxState(sourceCtx, destCtx) {
   var properties = ['strokeStyle', 'fillStyle', 'fillRule', 'globalAlpha',
                     'lineWidth', 'lineCap', 'lineJoin', 'miterLimit',
                     'globalCompositeOperation', 'font'];
   for (var i = 0, ii = properties.length; i &lt; ii; i++) {
     var property = properties[i];
     if (sourceCtx[property] !== undefined) {
       destCtx[property] = sourceCtx[property];
     }
   }
   if (sourceCtx.setLineDash !== undefined) {
     destCtx.setLineDash(sourceCtx.getLineDash());
     destCtx.lineDashOffset =  sourceCtx.lineDashOffset;
   } else if (sourceCtx.mozDashOffset !== undefined) {
     destCtx.mozDash = sourceCtx.mozDash;
     destCtx.mozDashOffset = sourceCtx.mozDashOffset;
   }
 }
</PRE><PRE> function composeSMaskBackdrop(bytes, r0, g0, b0) {
   var length = bytes.length;
   for (var i = 3; i &lt; length; i += 4) {
     var alpha = bytes[i];
     if (alpha === 0) {
       bytes[i - 3] = r0;
       bytes[i - 2] = g0;
       bytes[i - 1] = b0;
     } else if (alpha &lt; 255) {
       var alpha_ = 255 - alpha;
       bytes[i - 3] = (bytes[i - 3] * alpha + r0 * alpha_) &gt;&gt; 8;
       bytes[i - 2] = (bytes[i - 2] * alpha + g0 * alpha_) &gt;&gt; 8;
       bytes[i - 1] = (bytes[i - 1] * alpha + b0 * alpha_) &gt;&gt; 8;
     }
   }
 }
</PRE><PRE> function composeSMaskAlpha(maskData, layerData) {
   var length = maskData.length;
   var scale = 1 / 255;
   for (var i = 3; i &lt; length; i += 4) {
     var alpha = maskData[i];
     layerData[i] = (layerData[i] * alpha * scale) | 0;
   }
 }
</PRE><PRE> function composeSMaskLuminosity(maskData, layerData) {
   var length = maskData.length;
   for (var i = 3; i &lt; length; i += 4) {
     var y = (maskData[i - 3] * 77) +  // * 0.3 / 255 * 0x10000
             (maskData[i - 2] * 152) + // * 0.59 ....
             (maskData[i - 1] * 28);   // * 0.11 ....
     layerData[i] = (layerData[i] * y) &gt;&gt; 16;
   }
 }
</PRE><PRE> function genericComposeSMask(maskCtx, layerCtx, width, height,
                              subtype, backdrop) {
   var hasBackdrop = !!backdrop;
   var r0 = hasBackdrop ? backdrop[0] : 0;
   var g0 = hasBackdrop ? backdrop[1] : 0;
   var b0 = hasBackdrop ? backdrop[2] : 0;
</PRE><PRE>   var composeFn;
   if (subtype === 'Luminosity') {
     composeFn = composeSMaskLuminosity;
   } else {
     composeFn = composeSMaskAlpha;
   }
</PRE><PRE>   // processing image in chunks to save memory
   var PIXELS_TO_PROCESS = 1048576;
   var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
   for (var row = 0; row &lt; height; row += chunkSize) {
     var chunkHeight = Math.min(chunkSize, height - row);
     var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
     var layerData = layerCtx.getImageData(0, row, width, chunkHeight);
</PRE><PRE>     if (hasBackdrop) {
       composeSMaskBackdrop(maskData.data, r0, g0, b0);
     }
     composeFn(maskData.data, layerData.data);
</PRE><PRE>     maskCtx.putImageData(layerData, 0, row);
   }
 }
</PRE><PRE> function composeSMask(ctx, smask, layerCtx) {
   var mask = smask.canvas;
   var maskCtx = smask.context;
</PRE><PRE>   ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY,
                    smask.offsetX, smask.offsetY);
</PRE><PRE>   var backdrop = smask.backdrop || null;
   if (WebGLUtils.isEnabled) {
     var composed = WebGLUtils.composeSMask(layerCtx.canvas, mask,
       {subtype: smask.subtype, backdrop: backdrop});
     ctx.setTransform(1, 0, 0, 1, 0, 0);
     ctx.drawImage(composed, smask.offsetX, smask.offsetY);
     return;
   }
   genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height,
                       smask.subtype, backdrop);
   ctx.drawImage(mask, 0, 0);
 }
</PRE><PRE> var LINE_CAP_STYLES = ['butt', 'round', 'square'];
 var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
 var NORMAL_CLIP = {};
 var EO_CLIP = {};
</PRE><PRE> CanvasGraphics.prototype = {
</PRE><PRE>   beginDrawing: function CanvasGraphics_beginDrawing(viewport, transparency) {
     // For pdfs that use blend modes we have to clear the canvas else certain
     // blend modes can look wrong since we'd be blending with a white
     // backdrop. The problem with a transparent backdrop though is we then
     // don't get sub pixel anti aliasing on text, so we fill with white if
     // we can.
     var width = this.ctx.canvas.width;
     var height = this.ctx.canvas.height;
     if (transparency) {
       this.ctx.clearRect(0, 0, width, height);
     } else {
       this.ctx.mozOpaque = true;
       this.ctx.save();
       this.ctx.fillStyle = 'rgb(255, 255, 255)';
       this.ctx.fillRect(0, 0, width, height);
       this.ctx.restore();
     }
</PRE><PRE>     var transform = viewport.transform;
</PRE><PRE>     this.ctx.save();
     this.ctx.transform.apply(this.ctx, transform);
</PRE><PRE>     this.baseTransform = this.ctx.mozCurrentTransform.slice();
</PRE><PRE>     if (this.imageLayer) {
       this.imageLayer.beginLayout();
     }
   },
</PRE><PRE>   executeOperatorList: function CanvasGraphics_executeOperatorList(
                                   operatorList,
                                   executionStartIdx, continueCallback,
                                   stepper) {
     var argsArray = operatorList.argsArray;
     var fnArray = operatorList.fnArray;
     var i = executionStartIdx || 0;
     var argsArrayLen = argsArray.length;
</PRE><PRE>     // Sometimes the OperatorList to execute is empty.
     if (argsArrayLen === i) {
       return i;
     }
</PRE><PRE>     var chunkOperations = (argsArrayLen - i &gt; EXECUTION_STEPS &amp;&amp;
                            typeof continueCallback === 'function');
     var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
     var steps = 0;
</PRE><PRE>     var commonObjs = this.commonObjs;
     var objs = this.objs;
     var fnId;
</PRE><PRE>     while (true) {
       if (stepper !== undefined &amp;&amp; i === stepper.nextBreakPoint) {
         stepper.breakIt(i, continueCallback);
         return i;
       }
</PRE><PRE>       fnId = fnArray[i];
</PRE><PRE>       if (fnId !== OPS.dependency) {
         this[fnId].apply(this, argsArray[i]);
       } else {
         var deps = argsArray[i];
         for (var n = 0, nn = deps.length; n &lt; nn; n++) {
           var depObjId = deps[n];
           var common = depObjId[0] === 'g' &amp;&amp; depObjId[1] === '_';
           var objsPool = common ? commonObjs : objs;
</PRE><PRE>           // If the promise isn't resolved yet, add the continueCallback
           // to the promise and bail out.
           if (!objsPool.isResolved(depObjId)) {
             objsPool.get(depObjId, continueCallback);
             return i;
           }
         }
       }
</PRE><PRE>       i++;
</PRE><PRE>       // If the entire operatorList was executed, stop as were done.
       if (i === argsArrayLen) {
         return i;
       }
</PRE><PRE>       // If the execution took longer then a certain amount of time and
       // `continueCallback` is specified, interrupt the execution.
       if (chunkOperations &amp;&amp; ++steps &gt; EXECUTION_STEPS) {
         if (Date.now() &gt; endTime) {
           continueCallback();
           return i;
         }
         steps = 0;
       }
</PRE><PRE>       // If the operatorList isn't executed completely yet OR the execution
       // time was short enough, do another execution round.
     }
   },
</PRE><PRE>   endDrawing: function CanvasGraphics_endDrawing() {
     this.ctx.restore();
     CachedCanvases.clear();
     WebGLUtils.clear();
</PRE><PRE>     if (this.imageLayer) {
       this.imageLayer.endLayout();
     }
   },
</PRE><PRE>   // Graphics state
   setLineWidth: function CanvasGraphics_setLineWidth(width) {
     this.current.lineWidth = width;
     this.ctx.lineWidth = width;
   },
   setLineCap: function CanvasGraphics_setLineCap(style) {
     this.ctx.lineCap = LINE_CAP_STYLES[style];
   },
   setLineJoin: function CanvasGraphics_setLineJoin(style) {
     this.ctx.lineJoin = LINE_JOIN_STYLES[style];
   },
   setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
     this.ctx.miterLimit = limit;
   },
   setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
     var ctx = this.ctx;
     if (ctx.setLineDash !== undefined) {
       ctx.setLineDash(dashArray);
       ctx.lineDashOffset = dashPhase;
     } else {
       ctx.mozDash = dashArray;
       ctx.mozDashOffset = dashPhase;
     }
   },
   setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {
     // Maybe if we one day fully support color spaces this will be important
     // for now we can ignore.
     // TODO set rendering intent?
   },
   setFlatness: function CanvasGraphics_setFlatness(flatness) {
     // There's no way to control this with canvas, but we can safely ignore.
     // TODO set flatness?
   },
   setGState: function CanvasGraphics_setGState(states) {
     for (var i = 0, ii = states.length; i &lt; ii; i++) {
       var state = states[i];
       var key = state[0];
       var value = state[1];
</PRE><PRE>       switch (key) {
         case 'LW':
           this.setLineWidth(value);
           break;
         case 'LC':
           this.setLineCap(value);
           break;
         case 'LJ':
           this.setLineJoin(value);
           break;
         case 'ML':
           this.setMiterLimit(value);
           break;
         case 'D':
           this.setDash(value[0], value[1]);
           break;
         case 'RI':
           this.setRenderingIntent(value);
           break;
         case 'FL':
           this.setFlatness(value);
           break;
         case 'Font':
           this.setFont(value[0], value[1]);
           break;
         case 'CA':
           this.current.strokeAlpha = state[1];
           break;
         case 'ca':
           this.current.fillAlpha = state[1];
           this.ctx.globalAlpha = state[1];
           break;
         case 'BM':
           if (value &amp;&amp; value.name &amp;&amp; (value.name !== 'Normal')) {
             var mode = value.name.replace(/([A-Z])/g,
               function(c) {
                 return '-' + c.toLowerCase();
               }
             ).substring(1);
             this.ctx.globalCompositeOperation = mode;
             if (this.ctx.globalCompositeOperation !== mode) {
               warn('globalCompositeOperation &quot;' + mode +
                    '&quot; is not supported');
             }
           } else {
             this.ctx.globalCompositeOperation = 'source-over';
           }
           break;
         case 'SMask':
           if (this.current.activeSMask) {
             this.endSMaskGroup();
           }
           this.current.activeSMask = value ? this.tempSMask : null;
           if (this.current.activeSMask) {
             this.beginSMaskGroup();
           }
           this.tempSMask = null;
           break;
       }
     }
   },
   beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
</PRE><PRE>     var activeSMask = this.current.activeSMask;
     var drawnWidth = activeSMask.canvas.width;
     var drawnHeight = activeSMask.canvas.height;
     var cacheId = 'smaskGroupAt' + this.groupLevel;
     var scratchCanvas = CachedCanvases.getCanvas(
       cacheId, drawnWidth, drawnHeight, true);
</PRE><PRE>     var currentCtx = this.ctx;
     var currentTransform = currentCtx.mozCurrentTransform;
     this.ctx.save();
</PRE><PRE>     var groupCtx = scratchCanvas.context;
     groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
     groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
     groupCtx.transform.apply(groupCtx, currentTransform);
</PRE><PRE>     copyCtxState(currentCtx, groupCtx);
     this.ctx = groupCtx;
     this.setGState([
       ['BM', 'Normal'],
       ['ca', 1],
       ['CA', 1]
     ]);
     this.groupStack.push(currentCtx);
     this.groupLevel++;
   },
   endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
     var groupCtx = this.ctx;
     this.groupLevel--;
     this.ctx = this.groupStack.pop();
</PRE><PRE>     composeSMask(this.ctx, this.current.activeSMask, groupCtx);
     this.ctx.restore();
   },
   save: function CanvasGraphics_save() {
     this.ctx.save();
     var old = this.current;
     this.stateStack.push(old);
     this.current = old.clone();
     this.current.activeSMask = null;
   },
   restore: function CanvasGraphics_restore() {
     if (this.stateStack.length !== 0) {
       if (this.current.activeSMask !== null) {
         this.endSMaskGroup();
       }
</PRE><PRE>       this.current = this.stateStack.pop();
       this.ctx.restore();
</PRE><PRE>       // Ensure that the clipping path is reset (fixes issue6413.pdf).
       this.pendingClip = null;
</PRE><PRE>       this.cachedGetSinglePixelWidth = null;
     }
   },
   transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
     this.ctx.transform(a, b, c, d, e, f);
</PRE><PRE>     this.cachedGetSinglePixelWidth = null;
   },
</PRE><PRE>   // Path
   constructPath: function CanvasGraphics_constructPath(ops, args) {
     var ctx = this.ctx;
     var current = this.current;
     var x = current.x, y = current.y;
     for (var i = 0, j = 0, ii = ops.length; i &lt; ii; i++) {
       switch (ops[i] | 0) {
         case OPS.rectangle:
           x = args[j++];
           y = args[j++];
           var width = args[j++];
           var height = args[j++];
           if (width === 0) {
             width = this.getSinglePixelWidth();
           }
           if (height === 0) {
             height = this.getSinglePixelWidth();
           }
           var xw = x + width;
           var yh = y + height;
           this.ctx.moveTo(x, y);
           this.ctx.lineTo(xw, y);
           this.ctx.lineTo(xw, yh);
           this.ctx.lineTo(x, yh);
           this.ctx.lineTo(x, y);
           this.ctx.closePath();
           break;
         case OPS.moveTo:
           x = args[j++];
           y = args[j++];
           ctx.moveTo(x, y);
           break;
         case OPS.lineTo:
           x = args[j++];
           y = args[j++];
           ctx.lineTo(x, y);
           break;
         case OPS.curveTo:
           x = args[j + 4];
           y = args[j + 5];
           ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3],
                             x, y);
           j += 6;
           break;
         case OPS.curveTo2:
           ctx.bezierCurveTo(x, y, args[j], args[j + 1],
                             args[j + 2], args[j + 3]);
           x = args[j + 2];
           y = args[j + 3];
           j += 4;
           break;
         case OPS.curveTo3:
           x = args[j + 2];
           y = args[j + 3];
           ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
           j += 4;
           break;
         case OPS.closePath:
           ctx.closePath();
           break;
       }
     }
     current.setCurrentPoint(x, y);
   },
   closePath: function CanvasGraphics_closePath() {
     this.ctx.closePath();
   },
   stroke: function CanvasGraphics_stroke(consumePath) {
     consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
     var ctx = this.ctx;
     var strokeColor = this.current.strokeColor;
     // Prevent drawing too thin lines by enforcing a minimum line width.
     ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR,
                              this.current.lineWidth);
     // For stroke we want to temporarily change the global alpha to the
     // stroking alpha.
     ctx.globalAlpha = this.current.strokeAlpha;
     if (strokeColor &amp;&amp; strokeColor.hasOwnProperty('type') &amp;&amp;
         strokeColor.type === 'Pattern') {
       // for patterns, we transform to pattern space, calculate
       // the pattern, call stroke, and restore to user space
       ctx.save();
       ctx.strokeStyle = strokeColor.getPattern(ctx, this);
       ctx.stroke();
       ctx.restore();
     } else {
       ctx.stroke();
     }
     if (consumePath) {
       this.consumePath();
     }
     // Restore the global alpha to the fill alpha
     ctx.globalAlpha = this.current.fillAlpha;
   },
   closeStroke: function CanvasGraphics_closeStroke() {
     this.closePath();
     this.stroke();
   },
   fill: function CanvasGraphics_fill(consumePath) {
     consumePath = typeof consumePath !== 'undefined' ? consumePath : true;
     var ctx = this.ctx;
     var fillColor = this.current.fillColor;
     var isPatternFill = this.current.patternFill;
     var needRestore = false;
</PRE><PRE>     if (isPatternFill) {
       ctx.save();
       ctx.fillStyle = fillColor.getPattern(ctx, this);
       needRestore = true;
     }
</PRE><PRE>     if (this.pendingEOFill) {
       if (ctx.mozFillRule !== undefined) {
         ctx.mozFillRule = 'evenodd';
         ctx.fill();
         ctx.mozFillRule = 'nonzero';
       } else {
         try {
           ctx.fill('evenodd');
         } catch (ex) {
           // shouldn't really happen, but browsers might think differently
           ctx.fill();
         }
       }
       this.pendingEOFill = false;
     } else {
       ctx.fill();
     }
</PRE><PRE>     if (needRestore) {
       ctx.restore();
     }
     if (consumePath) {
       this.consumePath();
     }
   },
   eoFill: function CanvasGraphics_eoFill() {
     this.pendingEOFill = true;
     this.fill();
   },
   fillStroke: function CanvasGraphics_fillStroke() {
     this.fill(false);
     this.stroke(false);
</PRE><PRE>     this.consumePath();
   },
   eoFillStroke: function CanvasGraphics_eoFillStroke() {
     this.pendingEOFill = true;
     this.fillStroke();
   },
   closeFillStroke: function CanvasGraphics_closeFillStroke() {
     this.closePath();
     this.fillStroke();
   },
   closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
     this.pendingEOFill = true;
     this.closePath();
     this.fillStroke();
   },
   endPath: function CanvasGraphics_endPath() {
     this.consumePath();
   },
</PRE><PRE>   // Clipping
   clip: function CanvasGraphics_clip() {
     this.pendingClip = NORMAL_CLIP;
   },
   eoClip: function CanvasGraphics_eoClip() {
     this.pendingClip = EO_CLIP;
   },
</PRE><PRE>   // Text
   beginText: function CanvasGraphics_beginText() {
     this.current.textMatrix = IDENTITY_MATRIX;
     this.current.textMatrixScale = 1;
     this.current.x = this.current.lineX = 0;
     this.current.y = this.current.lineY = 0;
   },
   endText: function CanvasGraphics_endText() {
     var paths = this.pendingTextPaths;
     var ctx = this.ctx;
     if (paths === undefined) {
       ctx.beginPath();
       return;
     }
</PRE><PRE>     ctx.save();
     ctx.beginPath();
     for (var i = 0; i &lt;paths.length; i++) {
       var path = paths[i];
       ctx.setTransform.apply(ctx, path.transform);
       ctx.translate(path.x, path.y);
       path.addToPath(ctx, path.fontSize);
     }
     ctx.restore();
     ctx.clip();
     ctx.beginPath();
     delete this.pendingTextPaths;
   },
   setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
     this.current.charSpacing = spacing;
   },
   setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
     this.current.wordSpacing = spacing;
   },
   setHScale: function CanvasGraphics_setHScale(scale) {
     this.current.textHScale = scale / 100;
   },
   setLeading: function CanvasGraphics_setLeading(leading) {
     this.current.leading = -leading;
   },
   setFont: function CanvasGraphics_setFont(fontRefName, size) {
     var fontObj = this.commonObjs.get(fontRefName);
     var current = this.current;
</PRE><PRE>     if (!fontObj) {
       error('Can\'t find font for ' + fontRefName);
     }
</PRE><PRE>     current.fontMatrix = (fontObj.fontMatrix ?
                           fontObj.fontMatrix : FONT_IDENTITY_MATRIX);
</PRE><PRE>     // A valid matrix needs all main diagonal elements to be non-zero
     // This also ensures we bypass FF bugzilla bug #719844.
     if (current.fontMatrix[0] === 0 ||
         current.fontMatrix[3] === 0) {
       warn('Invalid font matrix for font ' + fontRefName);
     }
</PRE><PRE>     // The spec for Tf (setFont) says that 'size' specifies the font 'scale',
     // and in some docs this can be negative (inverted x-y axes).
     if (size &lt; 0) {
       size = -size;
       current.fontDirection = -1;
     } else {
       current.fontDirection = 1;
     }
</PRE><PRE>     this.current.font = fontObj;
     this.current.fontSize = size;
</PRE><PRE>     if (fontObj.isType3Font) {
       return; // we don't need ctx.font for Type3 fonts
     }
</PRE><PRE>     var name = fontObj.loadedName || 'sans-serif';
     var bold = fontObj.black ? (fontObj.bold ? '900' : 'bold') :
                                (fontObj.bold ? 'bold' : 'normal');
</PRE><PRE>     var italic = fontObj.italic ? 'italic' : 'normal';
     var typeface = '&quot;' + name + '&quot;, ' + fontObj.fallbackName;
</PRE><PRE>     // Some font backends cannot handle fonts below certain size.
     // Keeping the font at minimal size and using the fontSizeScale to change
     // the current transformation matrix before the fillText/strokeText.
     // See <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=726227">https://bugzilla.mozilla.org/show_bug.cgi?id=726227</A>
     var browserFontSize = size &lt; MIN_FONT_SIZE ? MIN_FONT_SIZE :
                           size &gt; MAX_FONT_SIZE ? MAX_FONT_SIZE : size;
     this.current.fontSizeScale = size / browserFontSize;
</PRE><PRE>     var rule = italic + ' ' + bold + ' ' + browserFontSize + 'px ' + typeface;
     this.ctx.font = rule;
   },
   setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
     this.current.textRenderingMode = mode;
   },
   setTextRise: function CanvasGraphics_setTextRise(rise) {
     this.current.textRise = rise;
   },
   moveText: function CanvasGraphics_moveText(x, y) {
     this.current.x = this.current.lineX += x;
     this.current.y = this.current.lineY += y;
   },
   setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
     this.setLeading(-y);
     this.moveText(x, y);
   },
   setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
     this.current.textMatrix = [a, b, c, d, e, f];
     this.current.textMatrixScale = Math.sqrt(a * a + b * b);
</PRE><PRE>     this.current.x = this.current.lineX = 0;
     this.current.y = this.current.lineY = 0;
   },
   nextLine: function CanvasGraphics_nextLine() {
     this.moveText(0, this.current.leading);
   },
</PRE><PRE>   paintChar: function CanvasGraphics_paintChar(character, x, y) {
     var ctx = this.ctx;
     var current = this.current;
     var font = current.font;
     var textRenderingMode = current.textRenderingMode;
     var fontSize = current.fontSize / current.fontSizeScale;
     var fillStrokeMode = textRenderingMode &amp;
       TextRenderingMode.FILL_STROKE_MASK;
     var isAddToPathSet = !!(textRenderingMode &amp;
       TextRenderingMode.ADD_TO_PATH_FLAG);
</PRE><PRE>     var addToPath;
     if (font.disableFontFace || isAddToPathSet) {
       addToPath = font.getPathGenerator(this.commonObjs, character);
     }
</PRE><PRE>     if (font.disableFontFace) {
       ctx.save();
       ctx.translate(x, y);
       ctx.beginPath();
       addToPath(ctx, fontSize);
       if (fillStrokeMode === TextRenderingMode.FILL ||
           fillStrokeMode === TextRenderingMode.FILL_STROKE) {
         ctx.fill();
       }
       if (fillStrokeMode === TextRenderingMode.STROKE ||
           fillStrokeMode === TextRenderingMode.FILL_STROKE) {
         ctx.stroke();
       }
       ctx.restore();
     } else {
       if (fillStrokeMode === TextRenderingMode.FILL ||
           fillStrokeMode === TextRenderingMode.FILL_STROKE) {
         ctx.fillText(character, x, y);
       }
       if (fillStrokeMode === TextRenderingMode.STROKE ||
           fillStrokeMode === TextRenderingMode.FILL_STROKE) {
         ctx.strokeText(character, x, y);
       }
     }
</PRE><PRE>     if (isAddToPathSet) {
       var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
       paths.push({
         transform: ctx.mozCurrentTransform,
         x: x,
         y: y,
         fontSize: fontSize,
         addToPath: addToPath
       });
     }
   },
</PRE><PRE>   get isFontSubpixelAAEnabled() {
     // Checks if anti-aliasing is enabled when scaled text is painted.
     // On Windows GDI scaled fonts looks bad.
     var ctx = document.createElement('canvas').getContext('2d');
     ctx.scale(1.5, 1);
     ctx.fillText('I', 0, 10);
     var data = ctx.getImageData(0, 0, 10, 10).data;
     var enabled = false;
     for (var i = 3; i &lt; data.length; i += 4) {
       if (data[i] &gt; 0 &amp;&amp; data[i] &lt; 255) {
         enabled = true;
         break;
       }
     }
     return shadow(this, 'isFontSubpixelAAEnabled', enabled);
   },
</PRE><PRE>   showText: function CanvasGraphics_showText(glyphs) {
     var current = this.current;
     var font = current.font;
     if (font.isType3Font) {
       return this.showType3Text(glyphs);
     }
</PRE><PRE>     var fontSize = current.fontSize;
     if (fontSize === 0) {
       return;
     }
</PRE><PRE>     var ctx = this.ctx;
     var fontSizeScale = current.fontSizeScale;
     var charSpacing = current.charSpacing;
     var wordSpacing = current.wordSpacing;
     var fontDirection = current.fontDirection;
     var textHScale = current.textHScale * fontDirection;
     var glyphsLength = glyphs.length;
     var vertical = font.vertical;
     var spacingDir = vertical ? 1 : -1;
     var defaultVMetrics = font.defaultVMetrics;
     var widthAdvanceScale = fontSize * current.fontMatrix[0];
</PRE><PRE>     var simpleFillText =
       current.textRenderingMode === TextRenderingMode.FILL &amp;&amp; !font.disableFontFace;
</PRE><PRE>     ctx.save();
     ctx.transform.apply(ctx, current.textMatrix);
     ctx.translate(current.x, current.y + current.textRise);
</PRE><PRE>     if (fontDirection &gt; 0) {
       ctx.scale(textHScale, -1);
     } else {
       ctx.scale(textHScale, 1);
     }
</PRE><PRE>     var lineWidth = current.lineWidth;
     var scale = current.textMatrixScale;
     if (scale === 0 || lineWidth === 0) {
       var fillStrokeMode = current.textRenderingMode &amp;
         TextRenderingMode.FILL_STROKE_MASK;
       if (fillStrokeMode === TextRenderingMode.STROKE ||
           fillStrokeMode === TextRenderingMode.FILL_STROKE) {
         this.cachedGetSinglePixelWidth = null;
         lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
       }
     } else {
       lineWidth /= scale;
     }
</PRE><PRE>     if (fontSizeScale !== 1.0) {
       ctx.scale(fontSizeScale, fontSizeScale);
       lineWidth /= fontSizeScale;
     }
</PRE><PRE>     ctx.lineWidth = lineWidth;
</PRE><PRE>     var x = 0, i;
     for (i = 0; i &lt; glyphsLength; ++i) {
       var glyph = glyphs[i];
       if (glyph === null) {
         // word break
         x += fontDirection * wordSpacing;
         continue;
       } else if (isNum(glyph)) {
         x += spacingDir * glyph * fontSize / 1000;
         continue;
       }
</PRE><PRE>       var restoreNeeded = false;
       var character = glyph.fontChar;
       var accent = glyph.accent;
       var scaledX, scaledY, scaledAccentX, scaledAccentY;
       var width = glyph.width;
       if (vertical) {
         var vmetric, vx, vy;
         vmetric = glyph.vmetric || defaultVMetrics;
         vx = glyph.vmetric ? vmetric[1] : width * 0.5;
         vx = -vx * widthAdvanceScale;
         vy = vmetric[2] * widthAdvanceScale;
</PRE><PRE>         width = vmetric ? -vmetric[0] : width;
         scaledX = vx / fontSizeScale;
         scaledY = (x + vy) / fontSizeScale;
       } else {
         scaledX = x / fontSizeScale;
         scaledY = 0;
       }
</PRE><PRE>       if (font.remeasure &amp;&amp; width &gt; 0 &amp;&amp; this.isFontSubpixelAAEnabled) {
         // some standard fonts may not have the exact width, trying to
         // rescale per character
         var measuredWidth = ctx.measureText(character).width * 1000 /
           fontSize * fontSizeScale;
         var characterScaleX = width / measuredWidth;
         restoreNeeded = true;
         ctx.save();
         ctx.scale(characterScaleX, 1);
         scaledX /= characterScaleX;
       }
</PRE><PRE>       if (simpleFillText &amp;&amp; !accent) {
         // common case
         ctx.fillText(character, scaledX, scaledY);
       } else {
         this.paintChar(character, scaledX, scaledY);
         if (accent) {
           scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
           scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
           this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY);
         }
       }
</PRE><PRE>       var charWidth = width * widthAdvanceScale + charSpacing * fontDirection;
       x += charWidth;
</PRE><PRE>       if (restoreNeeded) {
         ctx.restore();
       }
     }
     if (vertical) {
       current.y -= x * textHScale;
     } else {
       current.x += x * textHScale;
     }
     ctx.restore();
   },
</PRE><PRE>   showType3Text: function CanvasGraphics_showType3Text(glyphs) {
     // Type3 fonts - each glyph is a &quot;mini-PDF&quot;
     var ctx = this.ctx;
     var current = this.current;
     var font = current.font;
     var fontSize = current.fontSize;
     var fontDirection = current.fontDirection;
     var spacingDir = font.vertical ? 1 : -1;
     var charSpacing = current.charSpacing;
     var wordSpacing = current.wordSpacing;
     var textHScale = current.textHScale * fontDirection;
     var fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
     var glyphsLength = glyphs.length;
     var isTextInvisible =
       current.textRenderingMode === TextRenderingMode.INVISIBLE;
     var i, glyph, width, spacingLength;
</PRE><PRE>     if (isTextInvisible || fontSize === 0) {
       return;
     }
     this.cachedGetSinglePixelWidth = null;
</PRE><PRE>     ctx.save();
     ctx.transform.apply(ctx, current.textMatrix);
     ctx.translate(current.x, current.y);
</PRE><PRE>     ctx.scale(textHScale, fontDirection);
</PRE><PRE>     for (i = 0; i &lt; glyphsLength; ++i) {
       glyph = glyphs[i];
       if (glyph === null) {
         // word break
         this.ctx.translate(wordSpacing, 0);
         current.x += wordSpacing * textHScale;
         continue;
       } else if (isNum(glyph)) {
         spacingLength = spacingDir * glyph * fontSize / 1000;
         this.ctx.translate(spacingLength, 0);
         current.x += spacingLength * textHScale;
         continue;
       }
</PRE><PRE>       var operatorList = font.charProcOperatorList[glyph.operatorListId];
       if (!operatorList) {
         warn('Type3 character \&quot;' + glyph.operatorListId +
              '\&quot; is not available');
         continue;
       }
       this.processingType3 = glyph;
       this.save();
       ctx.scale(fontSize, fontSize);
       ctx.transform.apply(ctx, fontMatrix);
       this.executeOperatorList(operatorList);
       this.restore();
</PRE><PRE>       var transformed = Util.applyTransform([glyph.width, 0], fontMatrix);
       width = transformed[0] * fontSize + charSpacing;
</PRE><PRE>       ctx.translate(width, 0);
       current.x += width * textHScale;
     }
     ctx.restore();
     this.processingType3 = null;
   },
</PRE><PRE>   // Type3 fonts
   setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {
     // We can safely ignore this since the width should be the same
     // as the width in the Widths array.
   },
   setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth,
                                                                       yWidth,
                                                                       llx,
                                                                       lly,
                                                                       urx,
                                                                       ury) {
     // TODO According to the spec we're also suppose to ignore any operators
     // that set color or include images while processing this type3 font.
     this.ctx.rect(llx, lly, urx - llx, ury - lly);
     this.clip();
     this.endPath();
   },
</PRE><PRE>   // Color
   getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
     var pattern;
     if (IR[0] === 'TilingPattern') {
       var color = IR[1];
       pattern = new TilingPattern(IR, color, this.ctx, this.objs,
                                   this.commonObjs, this.baseTransform);
     } else {
       pattern = getShadingPatternFromIR(IR);
     }
     return pattern;
   },
   setStrokeColorN: function CanvasGraphics_setStrokeColorN(/*...*/) {
     this.current.strokeColor = this.getColorN_Pattern(arguments);
   },
   setFillColorN: function CanvasGraphics_setFillColorN(/*...*/) {
     this.current.fillColor = this.getColorN_Pattern(arguments);
     this.current.patternFill = true;
   },
   setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
     var color = Util.makeCssRgb(r, g, b);
     this.ctx.strokeStyle = color;
     this.current.strokeColor = color;
   },
   setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
     var color = Util.makeCssRgb(r, g, b);
     this.ctx.fillStyle = color;
     this.current.fillColor = color;
     this.current.patternFill = false;
   },
</PRE><PRE>   shadingFill: function CanvasGraphics_shadingFill(patternIR) {
     var ctx = this.ctx;
</PRE><PRE>     this.save();
     var pattern = getShadingPatternFromIR(patternIR);
     ctx.fillStyle = pattern.getPattern(ctx, this, true);
</PRE><PRE>     var inv = ctx.mozCurrentTransformInverse;
     if (inv) {
       var canvas = ctx.canvas;
       var width = canvas.width;
       var height = canvas.height;
</PRE><PRE>       var bl = Util.applyTransform([0, 0], inv);
       var br = Util.applyTransform([0, height], inv);
       var ul = Util.applyTransform([width, 0], inv);
       var ur = Util.applyTransform([width, height], inv);
</PRE><PRE>       var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
       var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
       var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
       var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
</PRE><PRE>       this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
     } else {
       // HACK to draw the gradient onto an infinite rectangle.
       // PDF gradients are drawn across the entire image while
       // Canvas only allows gradients to be drawn in a rectangle
       // The following bug should allow us to remove this.
       // <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=664884">https://bugzilla.mozilla.org/show_bug.cgi?id=664884</A></PRE><PRE>       this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
     }
</PRE><PRE>     this.restore();
   },
</PRE><PRE>   // Images
   beginInlineImage: function CanvasGraphics_beginInlineImage() {
     error('Should not call beginInlineImage');
   },
   beginImageData: function CanvasGraphics_beginImageData() {
     error('Should not call beginImageData');
   },
</PRE><PRE>   paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix,
                                                                       bbox) {
     this.save();
     this.baseTransformStack.push(this.baseTransform);
</PRE><PRE>     if (isArray(matrix) &amp;&amp; 6 === matrix.length) {
       this.transform.apply(this, matrix);
     }
</PRE><PRE>     this.baseTransform = this.ctx.mozCurrentTransform;
</PRE><PRE>     if (isArray(bbox) &amp;&amp; 4 === bbox.length) {
       var width = bbox[2] - bbox[0];
       var height = bbox[3] - bbox[1];
       this.ctx.rect(bbox[0], bbox[1], width, height);
       this.clip();
       this.endPath();
     }
   },
</PRE><PRE>   paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
     this.restore();
     this.baseTransform = this.baseTransformStack.pop();
   },
</PRE><PRE>   beginGroup: function CanvasGraphics_beginGroup(group) {
     this.save();
     var currentCtx = this.ctx;
     // TODO non-isolated groups - according to Rik at adobe non-isolated
     // group results aren't usually that different and they even have tools
     // that ignore this setting. Notes from Rik on implmenting:
     // - When you encounter an transparency group, create a new canvas with
     // the dimensions of the bbox
     // - copy the content from the previous canvas to the new canvas
     // - draw as usual
     // - remove the backdrop alpha:
     // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha
     // value of your transparency group and 'alphaBackdrop' the alpha of the
     // backdrop
     // - remove background color:
     // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)
     if (!group.isolated) {
       info('TODO: Support non-isolated groups.');
     }
</PRE><PRE>     // TODO knockout - supposedly possible with the clever use of compositing
     // modes.
     if (group.knockout) {
       warn('Knockout groups not supported.');
     }
</PRE><PRE>     var currentTransform = currentCtx.mozCurrentTransform;
     if (group.matrix) {
       currentCtx.transform.apply(currentCtx, group.matrix);
     }
     assert(group.bbox, 'Bounding box is required.');
</PRE><PRE>     // Based on the current transform figure out how big the bounding box
     // will actually be.
     var bounds = Util.getAxialAlignedBoundingBox(
                   group.bbox,
                   currentCtx.mozCurrentTransform);
     // Clip the bounding box to the current canvas.
     var canvasBounds = [0,
                         0,
                         currentCtx.canvas.width,
                         currentCtx.canvas.height];
     bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
     // Use ceil in case we're between sizes so we don't create canvas that is
     // too small and make the canvas at least 1x1 pixels.
     var offsetX = Math.floor(bounds[0]);
     var offsetY = Math.floor(bounds[1]);
     var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
     var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
     var scaleX = 1, scaleY = 1;
     if (drawnWidth &gt; MAX_GROUP_SIZE) {
       scaleX = drawnWidth / MAX_GROUP_SIZE;
       drawnWidth = MAX_GROUP_SIZE;
     }
     if (drawnHeight &gt; MAX_GROUP_SIZE) {
       scaleY = drawnHeight / MAX_GROUP_SIZE;
       drawnHeight = MAX_GROUP_SIZE;
     }
</PRE><PRE>     var cacheId = 'groupAt' + this.groupLevel;
     if (group.smask) {
       // Using two cache entries is case if masks are used one after another.
       cacheId +=  '_smask_' + ((this.smaskCounter++) % 2);
     }
     var scratchCanvas = CachedCanvases.getCanvas(
       cacheId, drawnWidth, drawnHeight, true);
     var groupCtx = scratchCanvas.context;
</PRE><PRE>     // Since we created a new canvas that is just the size of the bounding box
     // we have to translate the group ctx.
     groupCtx.scale(1 / scaleX, 1 / scaleY);
     groupCtx.translate(-offsetX, -offsetY);
     groupCtx.transform.apply(groupCtx, currentTransform);
</PRE><PRE>     if (group.smask) {
       // Saving state and cached mask to be used in setGState.
       this.smaskStack.push({
         canvas: scratchCanvas.canvas,
         context: groupCtx,
         offsetX: offsetX,
         offsetY: offsetY,
         scaleX: scaleX,
         scaleY: scaleY,
         subtype: group.smask.subtype,
         backdrop: group.smask.backdrop
       });
     } else {
       // Setup the current ctx so when the group is popped we draw it at the
       // right location.
       currentCtx.setTransform(1, 0, 0, 1, 0, 0);
       currentCtx.translate(offsetX, offsetY);
       currentCtx.scale(scaleX, scaleY);
     }
     // The transparency group inherits all off the current graphics state
     // except the blend mode, soft mask, and alpha constants.
     copyCtxState(currentCtx, groupCtx);
     this.ctx = groupCtx;
     this.setGState([
       ['BM', 'Normal'],
       ['ca', 1],
       ['CA', 1]
     ]);
     this.groupStack.push(currentCtx);
     this.groupLevel++;
   },
</PRE><PRE>   endGroup: function CanvasGraphics_endGroup(group) {
     this.groupLevel--;
     var groupCtx = this.ctx;
     this.ctx = this.groupStack.pop();
     // Turn off image smoothing to avoid sub pixel interpolation which can
     // look kind of blurry for some pdfs.
     if (this.ctx.imageSmoothingEnabled !== undefined) {
       this.ctx.imageSmoothingEnabled = false;
     } else {
       this.ctx.mozImageSmoothingEnabled = false;
     }
     if (group.smask) {
       this.tempSMask = this.smaskStack.pop();
     } else {
       this.ctx.drawImage(groupCtx.canvas, 0, 0);
     }
     this.restore();
   },
</PRE><PRE>   beginAnnotations: function CanvasGraphics_beginAnnotations() {
     this.save();
     this.current = new CanvasExtraState();
   },
</PRE><PRE>   endAnnotations: function CanvasGraphics_endAnnotations() {
     this.restore();
   },
</PRE><PRE>   beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform,
                                                            matrix) {
     this.save();
</PRE><PRE>     if (isArray(rect) &amp;&amp; 4 === rect.length) {
       var width = rect[2] - rect[0];
       var height = rect[3] - rect[1];
       this.ctx.rect(rect[0], rect[1], width, height);
       this.clip();
       this.endPath();
     }
</PRE><PRE>     this.transform.apply(this, transform);
     this.transform.apply(this, matrix);
   },
</PRE><PRE>   endAnnotation: function CanvasGraphics_endAnnotation() {
     this.restore();
   },
</PRE><PRE>   paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
     var domImage = this.objs.get(objId);
     if (!domImage) {
       warn('Dependent image isn\'t ready yet');
       return;
     }
</PRE><PRE>     this.save();
</PRE><PRE>     var ctx = this.ctx;
     // scale the image to the unit square
     ctx.scale(1 / w, -1 / h);
</PRE><PRE>     ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height,
                   0, -h, w, h);
     if (this.imageLayer) {
       var currentTransform = ctx.mozCurrentTransformInverse;
       var position = this.getCanvasPosition(0, 0);
       this.imageLayer.appendImage({
         objId: objId,
         left: position[0],
         top: position[1],
         width: w / currentTransform[0],
         height: h / currentTransform[3]
       });
     }
     this.restore();
   },
</PRE><PRE>   paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
     var ctx = this.ctx;
     var width = img.width, height = img.height;
     var fillColor = this.current.fillColor;
     var isPatternFill = this.current.patternFill;
</PRE><PRE>     var glyph = this.processingType3;
</PRE><PRE>     if (COMPILE_TYPE3_GLYPHS &amp;&amp; glyph &amp;&amp; glyph.compiled === undefined) {
       if (width &lt;= MAX_SIZE_TO_COMPILE &amp;&amp; height &lt;= MAX_SIZE_TO_COMPILE) {
         glyph.compiled =
           compileType3Glyph({data: img.data, width: width, height: height});
       } else {
         glyph.compiled = null;
       }
     }
</PRE><PRE>     if (glyph &amp;&amp; glyph.compiled) {
       glyph.compiled(ctx);
       return;
     }
</PRE><PRE>     var maskCanvas = CachedCanvases.getCanvas('maskCanvas', width, height);
     var maskCtx = maskCanvas.context;
     maskCtx.save();
</PRE><PRE>     putBinaryImageMask(maskCtx, img);
</PRE><PRE>     maskCtx.globalCompositeOperation = 'source-in';
</PRE><PRE>     maskCtx.fillStyle = isPatternFill ?
                         fillColor.getPattern(maskCtx, this) : fillColor;
     maskCtx.fillRect(0, 0, width, height);
</PRE><PRE>     maskCtx.restore();
</PRE><PRE>     this.paintInlineImageXObject(maskCanvas.canvas);
   },
</PRE><PRE>   paintImageMaskXObjectRepeat:
     function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX,
                                                         scaleY, positions) {
     var width = imgData.width;
     var height = imgData.height;
     var fillColor = this.current.fillColor;
     var isPatternFill = this.current.patternFill;
</PRE><PRE>     var maskCanvas = CachedCanvases.getCanvas('maskCanvas', width, height);
     var maskCtx = maskCanvas.context;
     maskCtx.save();
</PRE><PRE>     putBinaryImageMask(maskCtx, imgData);
</PRE><PRE>     maskCtx.globalCompositeOperation = 'source-in';
</PRE><PRE>     maskCtx.fillStyle = isPatternFill ?
                         fillColor.getPattern(maskCtx, this) : fillColor;
     maskCtx.fillRect(0, 0, width, height);
</PRE><PRE>     maskCtx.restore();
</PRE><PRE>     var ctx = this.ctx;
     for (var i = 0, ii = positions.length; i &lt; ii; i += 2) {
       ctx.save();
       ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);
       ctx.scale(1, -1);
       ctx.drawImage(maskCanvas.canvas, 0, 0, width, height,
         0, -1, 1, 1);
       ctx.restore();
     }
   },
</PRE><PRE>   paintImageMaskXObjectGroup:
     function CanvasGraphics_paintImageMaskXObjectGroup(images) {
     var ctx = this.ctx;
</PRE><PRE>     var fillColor = this.current.fillColor;
     var isPatternFill = this.current.patternFill;
     for (var i = 0, ii = images.length; i &lt; ii; i++) {
       var image = images[i];
       var width = image.width, height = image.height;
</PRE><PRE>       var maskCanvas = CachedCanvases.getCanvas('maskCanvas', width, height);
       var maskCtx = maskCanvas.context;
       maskCtx.save();
</PRE><PRE>       putBinaryImageMask(maskCtx, image);
</PRE><PRE>       maskCtx.globalCompositeOperation = 'source-in';
</PRE><PRE>       maskCtx.fillStyle = isPatternFill ?
                           fillColor.getPattern(maskCtx, this) : fillColor;
       maskCtx.fillRect(0, 0, width, height);
</PRE><PRE>       maskCtx.restore();
</PRE><PRE>       ctx.save();
       ctx.transform.apply(ctx, image.transform);
       ctx.scale(1, -1);
       ctx.drawImage(maskCanvas.canvas, 0, 0, width, height,
                     0, -1, 1, 1);
       ctx.restore();
     }
   },
</PRE><PRE>   paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
     var imgData = this.objs.get(objId);
     if (!imgData) {
       warn('Dependent image isn\'t ready yet');
       return;
     }
</PRE><PRE>     this.paintInlineImageXObject(imgData);
   },
</PRE><PRE>   paintImageXObjectRepeat:
     function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY,
                                                         positions) {
     var imgData = this.objs.get(objId);
     if (!imgData) {
       warn('Dependent image isn\'t ready yet');
       return;
     }
</PRE><PRE>     var width = imgData.width;
     var height = imgData.height;
     var map = [];
     for (var i = 0, ii = positions.length; i &lt; ii; i += 2) {
       map.push({transform: [scaleX, 0, 0, scaleY, positions[i],
                positions[i + 1]], x: 0, y: 0, w: width, h: height});
     }
     this.paintInlineImageXObjectGroup(imgData, map);
   },
</PRE><PRE>   paintInlineImageXObject:
     function CanvasGraphics_paintInlineImageXObject(imgData) {
     var width = imgData.width;
     var height = imgData.height;
     var ctx = this.ctx;
</PRE><PRE>     this.save();
     // scale the image to the unit square
     ctx.scale(1 / width, -1 / height);
</PRE><PRE>     var currentTransform = ctx.mozCurrentTransformInverse;
     var a = currentTransform[0], b = currentTransform[1];
     var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
     var c = currentTransform[2], d = currentTransform[3];
     var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
</PRE><PRE>     var imgToPaint, tmpCanvas;
     // instanceof HTMLElement does not work in jsdom node.js module
     if (imgData instanceof HTMLElement || !imgData.data) {
       imgToPaint = imgData;
     } else {
       tmpCanvas = CachedCanvases.getCanvas('inlineImage', width, height);
       var tmpCtx = tmpCanvas.context;
       putBinaryImageData(tmpCtx, imgData);
       imgToPaint = tmpCanvas.canvas;
     }
</PRE><PRE>     var paintWidth = width, paintHeight = height;
     var tmpCanvasId = 'prescale1';
     // Vertial or horizontal scaling shall not be more than 2 to not loose the
     // pixels during drawImage operation, painting on the temporary canvas(es)
     // that are twice smaller in size
     while ((widthScale &gt; 2 &amp;&amp; paintWidth &gt; 1) ||
            (heightScale &gt; 2 &amp;&amp; paintHeight &gt; 1)) {
       var newWidth = paintWidth, newHeight = paintHeight;
       if (widthScale &gt; 2 &amp;&amp; paintWidth &gt; 1) {
         newWidth = Math.ceil(paintWidth / 2);
         widthScale /= paintWidth / newWidth;
       }
       if (heightScale &gt; 2 &amp;&amp; paintHeight &gt; 1) {
         newHeight = Math.ceil(paintHeight / 2);
         heightScale /= paintHeight / newHeight;
       }
       tmpCanvas = CachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
       tmpCtx = tmpCanvas.context;
       tmpCtx.clearRect(0, 0, newWidth, newHeight);
       tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight,
                                    0, 0, newWidth, newHeight);
       imgToPaint = tmpCanvas.canvas;
       paintWidth = newWidth;
       paintHeight = newHeight;
       tmpCanvasId = tmpCanvasId === 'prescale1' ? 'prescale2' : 'prescale1';
     }
     ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight,
                               0, -height, width, height);
</PRE><PRE>     if (this.imageLayer) {
       var position = this.getCanvasPosition(0, -height);
       this.imageLayer.appendImage({
         imgData: imgData,
         left: position[0],
         top: position[1],
         width: width / currentTransform[0],
         height: height / currentTransform[3]
       });
     }
     this.restore();
   },
</PRE><PRE>   paintInlineImageXObjectGroup:
     function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
     var ctx = this.ctx;
     var w = imgData.width;
     var h = imgData.height;
</PRE><PRE>     var tmpCanvas = CachedCanvases.getCanvas('inlineImage', w, h);
     var tmpCtx = tmpCanvas.context;
     putBinaryImageData(tmpCtx, imgData);
</PRE><PRE>     for (var i = 0, ii = map.length; i &lt; ii; i++) {
       var entry = map[i];
       ctx.save();
       ctx.transform.apply(ctx, entry.transform);
       ctx.scale(1, -1);
       ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h,
                     0, -1, 1, 1);
       if (this.imageLayer) {
         var position = this.getCanvasPosition(entry.x, entry.y);
         this.imageLayer.appendImage({
           imgData: imgData,
           left: position[0],
           top: position[1],
           width: w,
           height: h
         });
       }
       ctx.restore();
     }
   },
</PRE><PRE>   paintSolidColorImageMask:
     function CanvasGraphics_paintSolidColorImageMask() {
       this.ctx.fillRect(0, 0, 1, 1);
   },
</PRE><PRE>   // Marked content
</PRE><PRE>   markPoint: function CanvasGraphics_markPoint(tag) {
     // TODO Marked content.
   },
   markPointProps: function CanvasGraphics_markPointProps(tag, properties) {
     // TODO Marked content.
   },
   beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {
     // TODO Marked content.
   },
   beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(
                                       tag, properties) {
     // TODO Marked content.
   },
   endMarkedContent: function CanvasGraphics_endMarkedContent() {
     // TODO Marked content.
   },
</PRE><PRE>   // Compatibility
</PRE><PRE>   beginCompat: function CanvasGraphics_beginCompat() {
     // TODO ignore undefined operators (should we do that anyway?)
   },
   endCompat: function CanvasGraphics_endCompat() {
     // TODO stop ignoring undefined operators
   },
</PRE><PRE>   // Helper functions
</PRE><PRE>   consumePath: function CanvasGraphics_consumePath() {
     var ctx = this.ctx;
     if (this.pendingClip) {
       if (this.pendingClip === EO_CLIP) {
         if (ctx.mozFillRule !== undefined) {
           ctx.mozFillRule = 'evenodd';
           ctx.clip();
           ctx.mozFillRule = 'nonzero';
         } else {
           try {
             ctx.clip('evenodd');
           } catch (ex) {
             // shouldn't really happen, but browsers might think differently
             ctx.clip();
           }
         }
       } else {
         ctx.clip();
       }
       this.pendingClip = null;
     }
     ctx.beginPath();
   },
   getSinglePixelWidth: function CanvasGraphics_getSinglePixelWidth(scale) {
     if (this.cachedGetSinglePixelWidth === null) {
       var inverse = this.ctx.mozCurrentTransformInverse;
       // max of the current horizontal and vertical scale
       this.cachedGetSinglePixelWidth = Math.sqrt(Math.max(
         (inverse[0] * inverse[0] + inverse[1] * inverse[1]),
         (inverse[2] * inverse[2] + inverse[3] * inverse[3])));
     }
     return this.cachedGetSinglePixelWidth;
   },
   getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
       var transform = this.ctx.mozCurrentTransform;
       return [
         transform[0] * x + transform[2] * y + transform[4],
         transform[1] * x + transform[3] * y + transform[5]
       ];
   }
 };
</PRE><PRE> for (var op in OPS) {
   CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
 }
</PRE><PRE> return CanvasGraphics;
</PRE><P>})();
</P><P>
var WebGLUtils = (function WebGLUtilsClosure() {
</P><PRE> function loadShader(gl, code, shaderType) {
   var shader = gl.createShader(shaderType);
   gl.shaderSource(shader, code);
   gl.compileShader(shader);
   var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
   if (!compiled) {
     var errorMsg = gl.getShaderInfoLog(shader);
     throw new Error('Error during shader compilation: ' + errorMsg);
   }
   return shader;
 }
 function createVertexShader(gl, code) {
   return loadShader(gl, code, gl.VERTEX_SHADER);
 }
 function createFragmentShader(gl, code) {
   return loadShader(gl, code, gl.FRAGMENT_SHADER);
 }
 function createProgram(gl, shaders) {
   var program = gl.createProgram();
   for (var i = 0, ii = shaders.length; i &lt; ii; ++i) {
     gl.attachShader(program, shaders[i]);
   }
   gl.linkProgram(program);
   var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
   if (!linked) {
     var errorMsg = gl.getProgramInfoLog(program);
     throw new Error('Error during program linking: ' + errorMsg);
   }
   return program;
 }
 function createTexture(gl, image, textureId) {
   gl.activeTexture(textureId);
   var texture = gl.createTexture();
   gl.bindTexture(gl.TEXTURE_2D, texture);
</PRE><PRE>   // Set the parameters so we can render any size image.
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</PRE><PRE>   // Upload the image into the texture.
   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
   return texture;
 }
</PRE><PRE> var currentGL, currentCanvas;
 function generateGL() {
   if (currentGL) {
     return;
   }
   currentCanvas = document.createElement('canvas');
   currentGL = currentCanvas.getContext('webgl',
     { premultipliedalpha: false });
 }
</PRE><PRE> var smaskVertexShaderCode = '\
 attribute vec2 a_position;                                    \
 attribute vec2 a_texCoord;                                    \
                                                               \
 uniform vec2 u_resolution;                                    \
                                                               \
 varying vec2 v_texCoord;                                      \
                                                               \
 void main() {                                                 \
   vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \
   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                               \
   v_texCoord = a_texCoord;                                    \
 }                                                             ';
</PRE><PRE> var smaskFragmentShaderCode = '\
 precision mediump float;                                      \
                                                               \
 uniform vec4 u_backdrop;                                      \
 uniform int u_subtype;                                        \
 uniform sampler2D u_image;                                    \
 uniform sampler2D u_mask;                                     \
                                                               \
 varying vec2 v_texCoord;                                      \
                                                               \
 void main() {                                                 \
   vec4 imageColor = texture2D(u_image, v_texCoord);           \
   vec4 maskColor = texture2D(u_mask, v_texCoord);             \
   if (u_backdrop.a &gt; 0.0) {                                   \
     maskColor.rgb = maskColor.rgb * maskColor.a +             \
                     u_backdrop.rgb * (1.0 - maskColor.a);     \
   }                                                           \
   float lum;                                                  \
   if (u_subtype == 0) {                                       \
     lum = maskColor.a;                                        \
   } else {                                                    \
     lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \
           maskColor.b * 0.11;                                 \
   }                                                           \
   imageColor.a *= lum;                                        \
   imageColor.rgb *= imageColor.a;                             \
   gl_FragColor = imageColor;                                  \
 }                                                             ';
</PRE><PRE> var smaskCache = null;
</PRE><PRE> function initSmaskGL() {
   var canvas, gl;
</PRE><PRE>   generateGL();
   canvas = currentCanvas;
   currentCanvas = null;
   gl = currentGL;
   currentGL = null;
</PRE><PRE>   // setup a GLSL program
   var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
   var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
   var program = createProgram(gl, [vertexShader, fragmentShader]);
   gl.useProgram(program);
</PRE><PRE>   var cache = {};
   cache.gl = gl;
   cache.canvas = canvas;
   cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
   cache.positionLocation = gl.getAttribLocation(program, 'a_position');
   cache.backdropLocation = gl.getUniformLocation(program, 'u_backdrop');
   cache.subtypeLocation = gl.getUniformLocation(program, 'u_subtype');
</PRE><PRE>   var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
   var texLayerLocation = gl.getUniformLocation(program, 'u_image');
   var texMaskLocation = gl.getUniformLocation(program, 'u_mask');
</PRE><PRE>   // provide texture coordinates for the rectangle.
   var texCoordBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
   gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     0.0,  0.0,
     1.0,  0.0,
     0.0,  1.0,
     0.0,  1.0,
     1.0,  0.0,
     1.0,  1.0]), gl.STATIC_DRAW);
   gl.enableVertexAttribArray(texCoordLocation);
   gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
</PRE><PRE>   gl.uniform1i(texLayerLocation, 0);
   gl.uniform1i(texMaskLocation, 1);
</PRE><PRE>   smaskCache = cache;
 }
</PRE><PRE> function composeSMask(layer, mask, properties) {
   var width = layer.width, height = layer.height;
</PRE><PRE>   if (!smaskCache) {
     initSmaskGL();
   }
   var cache = smaskCache,canvas = cache.canvas, gl = cache.gl;
   canvas.width = width;
   canvas.height = height;
   gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
   gl.uniform2f(cache.resolutionLocation, width, height);
</PRE><PRE>   if (properties.backdrop) {
     gl.uniform4f(cache.resolutionLocation, properties.backdrop[0],
                  properties.backdrop[1], properties.backdrop[2], 1);
   } else {
     gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
   }
   gl.uniform1i(cache.subtypeLocation,
                properties.subtype === 'Luminosity' ? 1 : 0);
</PRE><PRE>   // Create a textures
   var texture = createTexture(gl, layer, gl.TEXTURE0);
   var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
</PRE><PRE>   // Create a buffer and put a single clipspace rectangle in
   // it (2 triangles)
   var buffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
   gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     0, 0,
     width, 0,
     0, height,
     0, height,
     width, 0,
     width, height]), gl.STATIC_DRAW);
   gl.enableVertexAttribArray(cache.positionLocation);
   gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
</PRE><PRE>   // draw
   gl.clearColor(0, 0, 0, 0);
   gl.enable(gl.BLEND);
   gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
   gl.clear(gl.COLOR_BUFFER_BIT);
</PRE><PRE>   gl.drawArrays(gl.TRIANGLES, 0, 6);
</PRE><PRE>   gl.flush();
</PRE><PRE>   gl.deleteTexture(texture);
   gl.deleteTexture(maskTexture);
   gl.deleteBuffer(buffer);
</PRE><PRE>   return canvas;
 }
</PRE><PRE> var figuresVertexShaderCode = '\
 attribute vec2 a_position;                                    \
 attribute vec3 a_color;                                       \
                                                               \
 uniform vec2 u_resolution;                                    \
 uniform vec2 u_scale;                                         \
 uniform vec2 u_offset;                                        \
                                                               \
 varying vec4 v_color;                                         \
                                                               \
 void main() {                                                 \
   vec2 position = (a_position + u_offset) * u_scale;          \
   vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \
   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                               \
   v_color = vec4(a_color / 255.0, 1.0);                       \
 }                                                             ';
</PRE><PRE> var figuresFragmentShaderCode = '\
 precision mediump float;                                      \
                                                               \
 varying vec4 v_color;                                         \
                                                               \
 void main() {                                                 \
   gl_FragColor = v_color;                                     \
 }                                                             ';
</PRE><PRE> var figuresCache = null;
</PRE><PRE> function initFiguresGL() {
   var canvas, gl;
</PRE><PRE>   generateGL();
   canvas = currentCanvas;
   currentCanvas = null;
   gl = currentGL;
   currentGL = null;
</PRE><PRE>   // setup a GLSL program
   var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
   var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
   var program = createProgram(gl, [vertexShader, fragmentShader]);
   gl.useProgram(program);
</PRE><PRE>   var cache = {};
   cache.gl = gl;
   cache.canvas = canvas;
   cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
   cache.scaleLocation = gl.getUniformLocation(program, 'u_scale');
   cache.offsetLocation = gl.getUniformLocation(program, 'u_offset');
   cache.positionLocation = gl.getAttribLocation(program, 'a_position');
   cache.colorLocation = gl.getAttribLocation(program, 'a_color');
</PRE><PRE>   figuresCache = cache;
 }
</PRE><PRE> function drawFigures(width, height, backgroundColor, figures, context) {
   if (!figuresCache) {
     initFiguresGL();
   }
   var cache = figuresCache, canvas = cache.canvas, gl = cache.gl;
</PRE><PRE>   canvas.width = width;
   canvas.height = height;
   gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
   gl.uniform2f(cache.resolutionLocation, width, height);
</PRE><PRE>   // count triangle points
   var count = 0;
   var i, ii, rows;
   for (i = 0, ii = figures.length; i &lt; ii; i++) {
     switch (figures[i].type) {
       case 'lattice':
         rows = (figures[i].coords.length / figures[i].verticesPerRow) | 0;
         count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
         break;
       case 'triangles':
         count += figures[i].coords.length;
         break;
     }
   }
   // transfer data
   var coords = new Float32Array(count * 2);
   var colors = new Uint8Array(count * 3);
   var coordsMap = context.coords, colorsMap = context.colors;
   var pIndex = 0, cIndex = 0;
   for (i = 0, ii = figures.length; i &lt; ii; i++) {
     var figure = figures[i], ps = figure.coords, cs = figure.colors;
     switch (figure.type) {
       case 'lattice':
         var cols = figure.verticesPerRow;
         rows = (ps.length / cols) | 0;
         for (var row = 1; row &lt; rows; row++) {
           var offset = row * cols + 1;
           for (var col = 1; col &lt; cols; col++, offset++) {
             coords[pIndex] = coordsMap[ps[offset - cols - 1]];
             coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
             coords[pIndex + 2] = coordsMap[ps[offset - cols]];
             coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
             coords[pIndex + 4] = coordsMap[ps[offset - 1]];
             coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
             colors[cIndex] = colorsMap[cs[offset - cols - 1]];
             colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
             colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
             colors[cIndex + 3] = colorsMap[cs[offset - cols]];
             colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
             colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
             colors[cIndex + 6] = colorsMap[cs[offset - 1]];
             colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
             colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
</PRE><PRE>             coords[pIndex + 6] = coords[pIndex + 2];
             coords[pIndex + 7] = coords[pIndex + 3];
             coords[pIndex + 8] = coords[pIndex + 4];
             coords[pIndex + 9] = coords[pIndex + 5];
             coords[pIndex + 10] = coordsMap[ps[offset]];
             coords[pIndex + 11] = coordsMap[ps[offset] + 1];
             colors[cIndex + 9] = colors[cIndex + 3];
             colors[cIndex + 10] = colors[cIndex + 4];
             colors[cIndex + 11] = colors[cIndex + 5];
             colors[cIndex + 12] = colors[cIndex + 6];
             colors[cIndex + 13] = colors[cIndex + 7];
             colors[cIndex + 14] = colors[cIndex + 8];
             colors[cIndex + 15] = colorsMap[cs[offset]];
             colors[cIndex + 16] = colorsMap[cs[offset] + 1];
             colors[cIndex + 17] = colorsMap[cs[offset] + 2];
             pIndex += 12;
             cIndex += 18;
           }
         }
         break;
       case 'triangles':
         for (var j = 0, jj = ps.length; j &lt; jj; j++) {
           coords[pIndex] = coordsMap[ps[j]];
           coords[pIndex + 1] = coordsMap[ps[j] + 1];
           colors[cIndex] = colorsMap[cs[j]];
           colors[cIndex + 1] = colorsMap[cs[j] + 1];
           colors[cIndex + 2] = colorsMap[cs[j] + 2];
           pIndex += 2;
           cIndex += 3;
         }
         break;
     }
   }
</PRE><PRE>   // draw
   if (backgroundColor) {
     gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255,
                   backgroundColor[2] / 255, 1.0);
   } else {
     gl.clearColor(0, 0, 0, 0);
   }
   gl.clear(gl.COLOR_BUFFER_BIT);
</PRE><PRE>   var coordsBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
   gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
   gl.enableVertexAttribArray(cache.positionLocation);
   gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
</PRE><PRE>   var colorsBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
   gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
   gl.enableVertexAttribArray(cache.colorLocation);
   gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false,
                          0, 0);
</PRE><PRE>   gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
   gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
</PRE><PRE>   gl.drawArrays(gl.TRIANGLES, 0, count);
</PRE><PRE>   gl.flush();
</PRE><PRE>   gl.deleteBuffer(coordsBuffer);
   gl.deleteBuffer(colorsBuffer);
</PRE><PRE>   return canvas;
 }
</PRE><PRE> function cleanup() {
   if (smaskCache &amp;&amp; smaskCache.canvas) {
     smaskCache.canvas.width = 0;
     smaskCache.canvas.height = 0;
   }
   if (figuresCache &amp;&amp; figuresCache.canvas) {
     figuresCache.canvas.width = 0;
     figuresCache.canvas.height = 0;
   }
   smaskCache = null;
   figuresCache = null;
 }
</PRE><PRE> return {
   get isEnabled() {
     if (PDFJS.disableWebGL) {
       return false;
     }
     var enabled = false;
     try {
       generateGL();
       enabled = !!currentGL;
     } catch (e) { }
     return shadow(this, 'isEnabled', enabled);
   },
   composeSMask: composeSMask,
   drawFigures: drawFigures,
   clear: cleanup
 };
</PRE><P>})();
</P><P>
var ShadingIRs = {};
</P><P>ShadingIRs.RadialAxial = {
</P><PRE> fromIR: function RadialAxial_fromIR(raw) {
   var type = raw[1];
   var colorStops = raw[2];
   var p0 = raw[3];
   var p1 = raw[4];
   var r0 = raw[5];
   var r1 = raw[6];
   return {
     type: 'Pattern',
     getPattern: function RadialAxial_getPattern(ctx) {
       var grad;
       if (type === 'axial') {
         grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
       } else if (type === 'radial') {
         grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
       }
</PRE><PRE>       for (var i = 0, ii = colorStops.length; i &lt; ii; ++i) {
         var c = colorStops[i];
         grad.addColorStop(c[0], c[1]);
       }
       return grad;
     }
   };
 }
</PRE><P>};
</P><P>var createMeshCanvas = (function createMeshCanvasClosure() {
</P><PRE> function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
   // Very basic Gouraud-shaded triangle rasterization algorithm.
   var coords = context.coords, colors = context.colors;
   var bytes = data.data, rowSize = data.width * 4;
   var tmp;
   if (coords[p1 + 1] &gt; coords[p2 + 1]) {
     tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp;
   }
   if (coords[p2 + 1] &gt; coords[p3 + 1]) {
     tmp = p2; p2 = p3; p3 = tmp; tmp = c2; c2 = c3; c3 = tmp;
   }
   if (coords[p1 + 1] &gt; coords[p2 + 1]) {
     tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp;
   }
   var x1 = (coords[p1] + context.offsetX) * context.scaleX;
   var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
   var x2 = (coords[p2] + context.offsetX) * context.scaleX;
   var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
   var x3 = (coords[p3] + context.offsetX) * context.scaleX;
   var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
   if (y1 &gt;= y3) {
     return;
   }
   var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
   var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
   var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
</PRE><PRE>   var minY = Math.round(y1), maxY = Math.round(y3);
   var xa, car, cag, cab;
   var xb, cbr, cbg, cbb;
   var k;
   for (var y = minY; y &lt;= maxY; y++) {
     if (y &lt; y2) {
       k = y &lt; y1 ? 0 : y1 === y2 ? 1 : (y1 - y) / (y1 - y2);
       xa = x1 - (x1 - x2) * k;
       car = c1r - (c1r - c2r) * k;
       cag = c1g - (c1g - c2g) * k;
       cab = c1b - (c1b - c2b) * k;
     } else {
       k = y &gt; y3 ? 1 : y2 === y3 ? 0 : (y2 - y) / (y2 - y3);
       xa = x2 - (x2 - x3) * k;
       car = c2r - (c2r - c3r) * k;
       cag = c2g - (c2g - c3g) * k;
       cab = c2b - (c2b - c3b) * k;
     }
     k = y &lt; y1 ? 0 : y &gt; y3 ? 1 : (y1 - y) / (y1 - y3);
     xb = x1 - (x1 - x3) * k;
     cbr = c1r - (c1r - c3r) * k;
     cbg = c1g - (c1g - c3g) * k;
     cbb = c1b - (c1b - c3b) * k;
     var x1_ = Math.round(Math.min(xa, xb));
     var x2_ = Math.round(Math.max(xa, xb));
     var j = rowSize * y + x1_ * 4;
     for (var x = x1_; x &lt;= x2_; x++) {
       k = (xa - x) / (xa - xb);
       k = k &lt; 0 ? 0 : k &gt; 1 ? 1 : k;
       bytes[j++] = (car - (car - cbr) * k) | 0;
       bytes[j++] = (cag - (cag - cbg) * k) | 0;
       bytes[j++] = (cab - (cab - cbb) * k) | 0;
       bytes[j++] = 255;
     }
   }
 }
</PRE><PRE> function drawFigure(data, figure, context) {
   var ps = figure.coords;
   var cs = figure.colors;
   var i, ii;
   switch (figure.type) {
     case 'lattice':
       var verticesPerRow = figure.verticesPerRow;
       var rows = Math.floor(ps.length / verticesPerRow) - 1;
       var cols = verticesPerRow - 1;
       for (i = 0; i &lt; rows; i++) {
         var q = i * verticesPerRow;
         for (var j = 0; j &lt; cols; j++, q++) {
           drawTriangle(data, context,
             ps[q], ps[q + 1], ps[q + verticesPerRow],
             cs[q], cs[q + 1], cs[q + verticesPerRow]);
           drawTriangle(data, context,
             ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow],
             cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
         }
       }
       break;
     case 'triangles':
       for (i = 0, ii = ps.length; i &lt; ii; i += 3) {
         drawTriangle(data, context,
           ps[i], ps[i + 1], ps[i + 2],
           cs[i], cs[i + 1], cs[i + 2]);
       }
       break;
     default:
       error('illigal figure');
       break;
   }
 }
</PRE><PRE> function createMeshCanvas(bounds, combinesScale, coords, colors, figures,
                           backgroundColor) {
   // we will increase scale on some weird factor to let antialiasing take
   // care of &quot;rough&quot; edges
   var EXPECTED_SCALE = 1.1;
   // MAX_PATTERN_SIZE is used to avoid OOM situation.
   var MAX_PATTERN_SIZE = 3000; // 10in @ 300dpi shall be enough
</PRE><PRE>   var offsetX = Math.floor(bounds[0]);
   var offsetY = Math.floor(bounds[1]);
   var boundsWidth = Math.ceil(bounds[2]) - offsetX;
   var boundsHeight = Math.ceil(bounds[3]) - offsetY;
</PRE><PRE>   var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] *
     EXPECTED_SCALE)), MAX_PATTERN_SIZE);
   var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] *
     EXPECTED_SCALE)), MAX_PATTERN_SIZE);
   var scaleX = boundsWidth / width;
   var scaleY = boundsHeight / height;
</PRE><PRE>   var context = {
     coords: coords,
     colors: colors,
     offsetX: -offsetX,
     offsetY: -offsetY,
     scaleX: 1 / scaleX,
     scaleY: 1 / scaleY
   };
</PRE><PRE>   var canvas, tmpCanvas, i, ii;
   if (WebGLUtils.isEnabled) {
     canvas = WebGLUtils.drawFigures(width, height, backgroundColor,
                                     figures, context);
</PRE><PRE>     // <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=972126">https://bugzilla.mozilla.org/show_bug.cgi?id=972126</A>
     tmpCanvas = CachedCanvases.getCanvas('mesh', width, height, false);
     tmpCanvas.context.drawImage(canvas, 0, 0);
     canvas = tmpCanvas.canvas;
   } else {
     tmpCanvas = CachedCanvases.getCanvas('mesh', width, height, false);
     var tmpCtx = tmpCanvas.context;
</PRE><PRE>     var data = tmpCtx.createImageData(width, height);
     if (backgroundColor) {
       var bytes = data.data;
       for (i = 0, ii = bytes.length; i &lt; ii; i += 4) {
         bytes[i] = backgroundColor[0];
         bytes[i + 1] = backgroundColor[1];
         bytes[i + 2] = backgroundColor[2];
         bytes[i + 3] = 255;
       }
     }
     for (i = 0; i &lt; figures.length; i++) {
       drawFigure(data, figures[i], context);
     }
     tmpCtx.putImageData(data, 0, 0);
     canvas = tmpCanvas.canvas;
   }
</PRE><PRE>   return {canvas: canvas, offsetX: offsetX, offsetY: offsetY,
           scaleX: scaleX, scaleY: scaleY};
 }
 return createMeshCanvas;
</PRE><P>})();
</P><P>ShadingIRs.Mesh = {
</P><PRE> fromIR: function Mesh_fromIR(raw) {
   //var type = raw[1];
   var coords = raw[2];
   var colors = raw[3];
   var figures = raw[4];
   var bounds = raw[5];
   var matrix = raw[6];
   //var bbox = raw[7];
   var background = raw[8];
   return {
     type: 'Pattern',
     getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
       var scale;
       if (shadingFill) {
         scale = Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
       } else {
         // Obtain scale from matrix and current transformation matrix.
         scale = Util.singularValueDecompose2dScale(owner.baseTransform);
         if (matrix) {
           var matrixScale = Util.singularValueDecompose2dScale(matrix);
           scale = [scale[0] * matrixScale[0],
                    scale[1] * matrixScale[1]];
         }
       }
</PRE><PRE>       // Rasterizing on the main thread since sending/queue large canvases
       // might cause OOM.
       var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords,
         colors, figures, shadingFill ? null : background);
</PRE><PRE>       if (!shadingFill) {
         ctx.setTransform.apply(ctx, owner.baseTransform);
         if (matrix) {
           ctx.transform.apply(ctx, matrix);
         }
       }
</PRE><PRE>       ctx.translate(temporaryPatternCanvas.offsetX,
                     temporaryPatternCanvas.offsetY);
       ctx.scale(temporaryPatternCanvas.scaleX,
                 temporaryPatternCanvas.scaleY);
</PRE><PRE>       return ctx.createPattern(temporaryPatternCanvas.canvas, 'no-repeat');
     }
   };
 }
</PRE><P>};
</P><P>ShadingIRs.Dummy = {
</P><PRE> fromIR: function Dummy_fromIR() {
   return {
     type: 'Pattern',
     getPattern: function Dummy_fromIR_getPattern() {
       return 'hotpink';
     }
   };
 }
</PRE><P>};
</P><P>function getShadingPatternFromIR(raw) {
</P><PRE> var shadingIR = ShadingIRs[raw[0]];
 if (!shadingIR) {
   error('Unknown IR type: ' + raw[0]);
 }
 return shadingIR.fromIR(raw);
</PRE><P>}
</P><P>var TilingPattern = (function TilingPatternClosure() {
</P><PRE> var PaintType = {
   COLORED: 1,
   UNCOLORED: 2
 };
</PRE><PRE> var MAX_PATTERN_SIZE = 3000; // 10in @ 300dpi shall be enough
</PRE><PRE> function TilingPattern(IR, color, ctx, objs, commonObjs, baseTransform) {
   this.operatorList = IR[2];
   this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
   this.bbox = IR[4];
   this.xstep = IR[5];
   this.ystep = IR[6];
   this.paintType = IR[7];
   this.tilingType = IR[8];
   this.color = color;
   this.objs = objs;
   this.commonObjs = commonObjs;
   this.baseTransform = baseTransform;
   this.type = 'Pattern';
   this.ctx = ctx;
 }
</PRE><PRE> TilingPattern.prototype = {
   createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
     var operatorList = this.operatorList;
     var bbox = this.bbox;
     var xstep = this.xstep;
     var ystep = this.ystep;
     var paintType = this.paintType;
     var tilingType = this.tilingType;
     var color = this.color;
     var objs = this.objs;
     var commonObjs = this.commonObjs;
</PRE><PRE>     info('TilingType: ' + tilingType);
</PRE><PRE>     var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
</PRE><PRE>     var topLeft = [x0, y0];
     // we want the canvas to be as large as the step size
     var botRight = [x0 + xstep, y0 + ystep];
</PRE><PRE>     var width = botRight[0] - topLeft[0];
     var height = botRight[1] - topLeft[1];
</PRE><PRE>     // Obtain scale from matrix and current transformation matrix.
     var matrixScale = Util.singularValueDecompose2dScale(this.matrix);
     var curMatrixScale = Util.singularValueDecompose2dScale(
       this.baseTransform);
     var combinedScale = [matrixScale[0] * curMatrixScale[0],
       matrixScale[1] * curMatrixScale[1]];
</PRE><PRE>     // MAX_PATTERN_SIZE is used to avoid OOM situation.
     // Use width and height values that are as close as possible to the end
     // result when the pattern is used. Too low value makes the pattern look
     // blurry. Too large value makes it look too crispy.
     width = Math.min(Math.ceil(Math.abs(width * combinedScale[0])),
       MAX_PATTERN_SIZE);
</PRE><PRE>     height = Math.min(Math.ceil(Math.abs(height * combinedScale[1])),
       MAX_PATTERN_SIZE);
</PRE><PRE>     var tmpCanvas = CachedCanvases.getCanvas('pattern', width, height, true);
     var tmpCtx = tmpCanvas.context;
     var graphics = new CanvasGraphics(tmpCtx, commonObjs, objs);
     graphics.groupLevel = owner.groupLevel;
</PRE><PRE>     this.setFillAndStrokeStyleToContext(tmpCtx, paintType, color);
</PRE><PRE>     this.setScale(width, height, xstep, ystep);
     this.transformToScale(graphics);
</PRE><PRE>     // transform coordinates to pattern space
     var tmpTranslate = [1, 0, 0, 1, -topLeft[0], -topLeft[1]];
     graphics.transform.apply(graphics, tmpTranslate);
</PRE><PRE>     this.clipBbox(graphics, bbox, x0, y0, x1, y1);
</PRE><PRE>     graphics.executeOperatorList(operatorList);
     return tmpCanvas.canvas;
   },
</PRE><PRE>   setScale: function TilingPattern_setScale(width, height, xstep, ystep) {
     this.scale = [width / xstep, height / ystep];
   },
</PRE><PRE>   transformToScale: function TilingPattern_transformToScale(graphics) {
     var scale = this.scale;
     var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];
     graphics.transform.apply(graphics, tmpScale);
   },
</PRE><PRE>   scaleToContext: function TilingPattern_scaleToContext() {
     var scale = this.scale;
     this.ctx.scale(1 / scale[0], 1 / scale[1]);
   },
</PRE><PRE>   clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
     if (bbox &amp;&amp; isArray(bbox) &amp;&amp; bbox.length === 4) {
       var bboxWidth = x1 - x0;
       var bboxHeight = y1 - y0;
       graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
       graphics.clip();
       graphics.endPath();
     }
   },
</PRE><PRE>   setFillAndStrokeStyleToContext:
     function setFillAndStrokeStyleToContext(context, paintType, color) {
       switch (paintType) {
         case PaintType.COLORED:
           var ctx = this.ctx;
           context.fillStyle = ctx.fillStyle;
           context.strokeStyle = ctx.strokeStyle;
           break;
         case PaintType.UNCOLORED:
           var cssColor = Util.makeCssRgb(color[0], color[1], color[2]);
           context.fillStyle = cssColor;
           context.strokeStyle = cssColor;
           break;
         default:
           error('Unsupported paint type: ' + paintType);
       }
     },
</PRE><PRE>   getPattern: function TilingPattern_getPattern(ctx, owner) {
     var temporaryPatternCanvas = this.createPatternCanvas(owner);
</PRE><PRE>     ctx = this.ctx;
     ctx.setTransform.apply(ctx, this.baseTransform);
     ctx.transform.apply(ctx, this.matrix);
     this.scaleToContext();</PRE><PRE>     return ctx.createPattern(temporaryPatternCanvas, 'repeat');
   }
 };
</PRE><PRE> return TilingPattern;
</PRE><P>})();
</P><P>
PDFJS.disableFontFace = false;
</P><P>var FontLoader = {
</P><PRE> insertRule: function fontLoaderInsertRule(rule) {
   var styleElement = document.getElementById('PDFJS_FONT_STYLE_TAG');
   if (!styleElement) {
     styleElement = document.createElement('style');
     styleElement.id = 'PDFJS_FONT_STYLE_TAG';
     document.documentElement.getElementsByTagName('head')[0].appendChild(
       styleElement);
   }
</PRE><PRE>   var styleSheet = styleElement.sheet;
   styleSheet.insertRule(rule, styleSheet.cssRules.length);
 },
</PRE><PRE> clear: function fontLoaderClear() {
   var styleElement = document.getElementById('PDFJS_FONT_STYLE_TAG');
   if (styleElement) {
     styleElement.parentNode.removeChild(styleElement);
   }
   this.nativeFontFaces.forEach(function(nativeFontFace) {
     document.fonts.delete(nativeFontFace);
   });
   this.nativeFontFaces.length = 0;
 },
 get loadTestFont() {
   // This is a CFF font with 1 glyph for '.' that fills its entire width and
   // height.
   return shadow(this, 'loadTestFont', atob(
     'T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQ' +
     'AABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwA' +
     'AAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbm' +
     'FtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAA' +
     'AADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6A' +
     'ABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAA' +
     'MQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAA' +
     'AAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAA' +
     'AAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQ' +
     'AAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMA' +
     'AQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAA' +
     'EAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAA' +
     'AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAA' +
     'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +
     'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +
     'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +
     'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA' +
     'AAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgc' +
     'A/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF' +
     'hYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQA' +
     'AAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAg' +
     'ABAAAAAAAAAAAD6AAAAAAAAA=='
   ));
 },
</PRE><PRE> get isEvalSupported() {
   var evalSupport = false;
   if (PDFJS.isEvalSupported) {
     try {
       /* jshint evil: true */
       new Function(<I>);</I>
       evalSupport = true;
     } catch (e) {}
   }
   return shadow(this, 'isEvalSupported', evalSupport);
 },
</PRE><PRE> loadTestFontId: 0,
</PRE><PRE> loadingContext: {
   requests: [],
   nextRequestId: 0
 },
</PRE><PRE> isSyncFontLoadingSupported: (function detectSyncFontLoadingSupport() {
   if (isWorker) {
     return false;
   }
</PRE><PRE>   // User agent string sniffing is bad, but there is no reliable way to tell
   // if font is fully loaded and ready to be used with canvas.
   var userAgent = window.navigator.userAgent;
   var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(userAgent);
   if (m &amp;&amp; m[1] &gt;= 14) {
     return true;
   }
   // TODO other browsers
   if (userAgent === 'node') {
     return true;
   }
   return false;
 })(),
</PRE><PRE> nativeFontFaces: [],
</PRE><PRE> isFontLoadingAPISupported: (!isWorker &amp;&amp; typeof document !== 'undefined' &amp;&amp; !!document.fonts),
</PRE><PRE> addNativeFontFace: function fontLoader_addNativeFontFace(nativeFontFace) {
   this.nativeFontFaces.push(nativeFontFace);
   document.fonts.add(nativeFontFace);
 },
</PRE><PRE> bind: function fontLoaderBind(fonts, callback) {
   assert(!isWorker, 'bind() shall be called from main thread');
</PRE><PRE>   var rules = [];
   var fontsToLoad = [];
   var fontLoadPromises = [];
   var getNativeFontPromise = function(nativeFontFace) {
     // Return a promise that is always fulfilled, even when the font fails to
     // load.
     return nativeFontFace.loaded.catch(function(e) {
       warn('Failed to load font &quot;' + nativeFontFace.family + '&quot;: ' + e);
     });
   };
   for (var i = 0, ii = fonts.length; i &lt; ii; i++) {
     var font = fonts[i];
</PRE><PRE>     // Add the font to the DOM only once or skip if the font
     // is already loaded.
     if (font.attached || font.loading === false) {
       continue;
     }
     font.attached = true;
</PRE><PRE>     if (this.isFontLoadingAPISupported) {
       var nativeFontFace = font.createNativeFontFace();
       if (nativeFontFace) {
         fontLoadPromises.push(getNativeFontPromise(nativeFontFace));
       }
     } else {
       var rule = font.bindDOM();
       if (rule) {
         rules.push(rule);
         fontsToLoad.push(font);
       }
     }
   }
</PRE><PRE>   var request = FontLoader.queueLoadingCallback(callback);
   if (this.isFontLoadingAPISupported) {
     Promise.all(fontLoadPromises).then(function() {
       request.complete();
     });
   } else if (rules.length &gt; 0 &amp;&amp; !this.isSyncFontLoadingSupported) {
     FontLoader.prepareFontLoadEvent(rules, fontsToLoad, request);
   } else {
     request.complete();
   }
 },
</PRE><PRE> queueLoadingCallback: function FontLoader_queueLoadingCallback(callback) {
   function LoadLoader_completeRequest() {
     assert(!request.end, 'completeRequest() cannot be called twice');
     request.end = Date.now();
</PRE><PRE>     // sending all completed requests in order how they were queued
     while (context.requests.length &gt; 0 &amp;&amp; context.requests[0].end) {
       var otherRequest = context.requests.shift();
       setTimeout(otherRequest.callback, 0);
     }
   }
</PRE><PRE>   var context = FontLoader.loadingContext;
   var requestId = 'pdfjs-font-loading-' + (context.nextRequestId++);
   var request = {
     id: requestId,
     complete: LoadLoader_completeRequest,
     callback: callback,
     started: Date.now()
   };
   context.requests.push(request);
   return request;
 },
</PRE><PRE> prepareFontLoadEvent: function fontLoaderPrepareFontLoadEvent(rules,
                                                               fonts,
                                                               request) {
     /** Hack begin */
     // There's currently no event when a font has finished downloading so the
     // following code is a dirty hack to 'guess' when a font is
     // ready. It's assumed fonts are loaded in order, so add a known test
     // font after the desired fonts and then test for the loading of that
     // test font.
</PRE><PRE>     function int32(data, offset) {
       return (data.charCodeAt(offset) &lt;&lt; 24) |
              (data.charCodeAt(offset + 1) &lt;&lt; 16) |
              (data.charCodeAt(offset + 2) &lt;&lt; 8) |
              (data.charCodeAt(offset + 3) &amp; 0xff);
     }
</PRE><PRE>     function spliceString(s, offset, remove, insert) {
       var chunk1 = s.substr(0, offset);
       var chunk2 = s.substr(offset + remove);
       return chunk1 + insert + chunk2;
     }
</PRE><PRE>     var i, ii;
</PRE><PRE>     var canvas = document.createElement('canvas');
     canvas.width = 1;
     canvas.height = 1;
     var ctx = canvas.getContext('2d');
</PRE><PRE>     var called = 0;
     function isFontReady(name, callback) {
       called++;
       // With setTimeout clamping this gives the font ~100ms to load.
       if(called &gt; 30) {
         warn('Load test font never loaded.');
         callback();
         return;
       }
       ctx.font = '30px ' + name;
       ctx.fillText('.', 0, 20);
       var imageData = ctx.getImageData(0, 0, 1, 1);
       if (imageData.data[3] &gt; 0) {
         callback();
         return;
       }
       setTimeout(isFontReady.bind(null, name, callback));
     }
</PRE><PRE>     var loadTestFontId = 'lt' + Date.now() + this.loadTestFontId++;
     // Chromium seems to cache fonts based on a hash of the actual font data,
     // so the font must be modified for each load test else it will appear to
     // be loaded already.
     // TODO: This could maybe be made faster by avoiding the btoa of the full
     // font by splitting it in chunks before hand and padding the font id.
     var data = this.loadTestFont;
     var COMMENT_OFFSET = 976; // has to be on 4 byte boundary (for checksum)
     data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length,
                         loadTestFontId);
     // CFF checksum is important for IE, adjusting it
     var CFF_CHECKSUM_OFFSET = 16;
     var XXXX_VALUE = 0x58585858; // the &quot;comment&quot; filled with 'X'
     var checksum = int32(data, CFF_CHECKSUM_OFFSET);
     for (i = 0, ii = loadTestFontId.length - 3; i &lt; ii; i += 4) {
       checksum = (checksum - XXXX_VALUE + int32(loadTestFontId, i)) | 0;
     }
     if (i &lt; loadTestFontId.length) { // align to 4 bytes boundary
       checksum = (checksum - XXXX_VALUE +
                   int32(loadTestFontId + 'XXX', i)) | 0;
     }
     data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
</PRE><PRE>     var url = 'url(data:font/opentype;base64,' + btoa(data) + ');';
     var rule = '@font-face { font-family:&quot;' + loadTestFontId + '&quot;;src:' +
                url + '}';
     FontLoader.insertRule(rule);
</PRE><PRE>     var names = [];
     for (i = 0, ii = fonts.length; i &lt; ii; i++) {
       names.push(fonts[i].loadedName);
     }
     names.push(loadTestFontId);
</PRE><PRE>     var div = document.createElement('div');
     div.setAttribute('style',
                      'visibility: hidden;' +
                      'width: 10px; height: 10px;' +
                      'position: absolute; top: 0px; left: 0px;');
     for (i = 0, ii = names.length; i &lt; ii; ++i) {
       var span = document.createElement('span');
       span.textContent = 'Hi';
       span.style.fontFamily = names[i];
       div.appendChild(span);
     }
     document.body.appendChild(div);
</PRE><PRE>     isFontReady(loadTestFontId, function() {
       document.body.removeChild(div);
       request.complete();
     });
     /** Hack end */
 }
</PRE><P>};
</P><P>var FontFaceObject = (function FontFaceObjectClosure() {
</P><PRE> function FontFaceObject(name, file, properties) {
   this.compiledGlyphs = {};
   if (arguments.length === 1) {
     // importing translated data
     var data = arguments[0];
     for (var i in data) {
       this[i] = data[i];
     }
     return;
   }
 }
 FontFaceObject.prototype = {
   createNativeFontFace: function FontFaceObject_createNativeFontFace() {
     if (!this.data) {
       return null;
     }
</PRE><PRE>     if (PDFJS.disableFontFace) {
       this.disableFontFace = true;
       return null;
     }
</PRE><PRE>     var nativeFontFace = new FontFace(this.loadedName, this.data, {});
</PRE><PRE>     FontLoader.addNativeFontFace(nativeFontFace);
</PRE><PRE>     if (PDFJS.pdfBug &amp;&amp; 'FontInspector' in globalScope &amp;&amp;
         globalScope['FontInspector'].enabled) {
       globalScope['FontInspector'].fontAdded(this);
     }
     return nativeFontFace;
   },
</PRE><PRE>   bindDOM: function FontFaceObject_bindDOM() {
     if (!this.data) {
       return null;
     }
</PRE><PRE>     if (PDFJS.disableFontFace) {
       this.disableFontFace = true;
       return null;
     }
</PRE><PRE>     var data = bytesToString(new Uint8Array(this.data));
     var fontName = this.loadedName;
</PRE><PRE>     // Add the font-face rule to the document
     var url = ('url(data:' + this.mimetype + ';base64,' +
                window.btoa(data) + ');');
     var rule = '@font-face { font-family:&quot;' + fontName + '&quot;;src:' + url + '}';
     FontLoader.insertRule(rule);
</PRE><PRE>     if (PDFJS.pdfBug &amp;&amp; 'FontInspector' in globalScope &amp;&amp;
         globalScope['FontInspector'].enabled) {
       globalScope['FontInspector'].fontAdded(this, url);
     }
</PRE><PRE>     return rule;
   },
</PRE><PRE>   getPathGenerator: function FontLoader_getPathGenerator(objs, character) {
     if (!(character in this.compiledGlyphs)) {
       var cmds = objs.get(this.loadedName + '_path_' + character);
       var current, i, len;
</PRE><PRE>       // If we can, compile cmds into JS for MAXIMUM SPEED
       if (FontLoader.isEvalSupported) {
         var args, js = <I>;</I>
         for (i = 0, len = cmds.length; i &lt; len; i++) {
           current = cmds[i];
</PRE><PRE>           if (current.args !== undefined) {
             args = current.args.join(',');
           } else {
             args = <I>;</I>
           }
</PRE><PRE>           js += 'c.' + current.cmd + '(' + args + ');\n';
         }
         /* jshint -W054 */
         this.compiledGlyphs[character] = new Function('c', 'size', js);
       } else {
         // But fall back on using Function.prototype.apply() if we're
         // blocked from using eval() for whatever reason (like CSP policies)
         this.compiledGlyphs[character] = function(c, size) {
           for (i = 0, len = cmds.length; i &lt; len; i++) {
             current = cmds[i];
</PRE><PRE>             if (current.cmd === 'scale') {
               current.args = [size, -size];
             }
</PRE><PRE>             c[current.cmd].apply(c, current.args);
           }
         };
       }
     }
     return this.compiledGlyphs[character];
   }
 };
 return FontFaceObject;
</PRE><P>})();
</P><P>
var ANNOT_MIN_SIZE = 10; // px
</P><P>var AnnotationUtils = (function AnnotationUtilsClosure() {
</P><PRE> // TODO(mack): This dupes some of the logic in CanvasGraphics.setFont()
 function setTextStyles(element, item, fontObj) {
</PRE><PRE>   var style = element.style;
   style.fontSize = item.fontSize + 'px';
   style.direction = item.fontDirection &lt; 0 ? 'rtl': 'ltr';
</PRE><PRE>   if (!fontObj) {
     return;
   }
</PRE><PRE>   style.fontWeight = fontObj.black ?
     (fontObj.bold ? 'bolder' : 'bold') :
     (fontObj.bold ? 'bold' : 'normal');
   style.fontStyle = fontObj.italic ? 'italic' : 'normal';
</PRE><PRE>   var fontName = fontObj.loadedName;
   var fontFamily = fontName ? '&quot;' + fontName + '&quot;, ' : <I>;</I>
   // Use a reasonable default font if the font doesn't specify a fallback
   var fallbackName = fontObj.fallbackName || 'Helvetica, sans-serif';
   style.fontFamily = fontFamily + fallbackName;
 }
</PRE><PRE> function initContainer(item) {
   var container = document.createElement('section');
   var cstyle = container.style;
   var width = item.rect[2] - item.rect[0];
   var height = item.rect[3] - item.rect[1];
</PRE><PRE>   // Border
   if (item.borderStyle.width &gt; 0) {
     // Border width
     container.style.borderWidth = item.borderStyle.width + 'px';
     if (item.borderStyle.style !== AnnotationBorderStyleType.UNDERLINE) {
       // Underline styles only have a bottom border, so we do not need
       // to adjust for all borders. This yields a similar result as
       // Adobe Acrobat/Reader.
       width = width - 2 * item.borderStyle.width;
       height = height - 2 * item.borderStyle.width;
     }
</PRE><PRE>     // Horizontal and vertical border radius
     var horizontalRadius = item.borderStyle.horizontalCornerRadius;
     var verticalRadius = item.borderStyle.verticalCornerRadius;
     if (horizontalRadius &gt; 0 || verticalRadius &gt; 0) {
       var radius = horizontalRadius + 'px / ' + verticalRadius + 'px';
       CustomStyle.setProp('borderRadius', container, radius);
     }
</PRE><PRE>     // Border style
     switch (item.borderStyle.style) {
       case AnnotationBorderStyleType.SOLID:
         container.style.borderStyle = 'solid';
         break;
</PRE><PRE>       case AnnotationBorderStyleType.DASHED:
         container.style.borderStyle = 'dashed';
         break;
</PRE><PRE>       case AnnotationBorderStyleType.BEVELED:
         warn('Unimplemented border style: beveled');
         break;
</PRE><PRE>       case AnnotationBorderStyleType.INSET:
         warn('Unimplemented border style: inset');
         break;
</PRE><PRE>       case AnnotationBorderStyleType.UNDERLINE:
         container.style.borderBottomStyle = 'solid';
         break;
</PRE><PRE>       default:
         break;
     }
</PRE><PRE>     // Border color
     if (item.color) {
       container.style.borderColor =
         Util.makeCssRgb(item.color[0] | 0,
                         item.color[1] | 0,
                         item.color[2] | 0);
     } else {
       // Transparent (invisible) border, so do not draw it at all.
       container.style.borderWidth = 0;
     }
   }
</PRE><PRE>   cstyle.width = width + 'px';
   cstyle.height = height + 'px';
   return container;
 }
</PRE><PRE> function getHtmlElementForTextWidgetAnnotation(item, commonObjs) {
   var element = document.createElement('div');
   var width = item.rect[2] - item.rect[0];
   var height = item.rect[3] - item.rect[1];
   element.style.width = width + 'px';
   element.style.height = height + 'px';
   element.style.display = 'table';
</PRE><PRE>   var content = document.createElement('div');
   content.textContent = item.fieldValue;
   var textAlignment = item.textAlignment;
   content.style.textAlign = ['left', 'center', 'right'][textAlignment];
   content.style.verticalAlign = 'middle';
   content.style.display = 'table-cell';
</PRE><PRE>   var fontObj = item.fontRefName ?
     commonObjs.getData(item.fontRefName) : null;
   setTextStyles(content, item, fontObj);
</PRE><PRE>   element.appendChild(content);
</PRE><PRE>   return element;
 }
</PRE><PRE> function getHtmlElementForTextAnnotation(item) {
   var rect = item.rect;
</PRE><PRE>   // sanity check because of OOo-generated PDFs
   if ((rect[3] - rect[1]) &lt; ANNOT_MIN_SIZE) {
     rect[3] = rect[1] + ANNOT_MIN_SIZE;
   }
   if ((rect[2] - rect[0]) &lt; ANNOT_MIN_SIZE) {
     rect[2] = rect[0] + (rect[3] - rect[1]); // make it square
   }
</PRE><PRE>   var container = initContainer(item);
   container.className = 'annotText';
</PRE><PRE>   var image  = document.createElement('img');
   image.style.height = container.style.height;
   image.style.width = container.style.width;
   var iconName = item.name;
   image.src = PDFJS.imageResourcesPath + 'annotation-' +
     iconName.toLowerCase() + '.svg';
   image.alt = '[[[:Template:Type]] Annotation]';
   image.dataset.l10nId = 'text_annotation_type';
   image.dataset.l10nArgs = JSON.stringify({type: iconName});
</PRE><PRE>   var contentWrapper = document.createElement('div');
   contentWrapper.className = 'annotTextContentWrapper';
   contentWrapper.style.left = Math.floor(rect[2] - rect[0] + 5) + 'px';
   contentWrapper.style.top = '-10px';
</PRE><PRE>   var content = document.createElement('div');
   content.className = 'annotTextContent';
   content.setAttribute('hidden', true);
</PRE><PRE>   var i, ii;
   if (item.hasBgColor &amp;&amp; item.color) {
     var color = item.color;
</PRE><PRE>     // Enlighten the color (70%)
     var BACKGROUND_ENLIGHT = 0.7;
     var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
     var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
     var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
     content.style.backgroundColor = Util.makeCssRgb(r | 0, g | 0, b | 0);
   }
</PRE><PRE>   var title = document.createElement('h1');
   var text = document.createElement('p');
   title.textContent = item.title;
</PRE><PRE>   if (!item.content &amp;&amp; !item.title) {
     content.setAttribute('hidden', true);
   } else {
     var e = document.createElement('span');
     var lines = item.content.split(/(?:\r\n?|\n)/);
     for (i = 0, ii = lines.length; i &lt; ii; ++i) {
       var line = lines[i];
       e.appendChild(document.createTextNode(line));
       if (i &lt; (ii - 1)) {
         e.appendChild(document.createElement('br'));
       }
     }
     text.appendChild(e);
</PRE><PRE>     var pinned = false;
</PRE><PRE>     var showAnnotation = function showAnnotation(pin) {
       if (pin) {
         pinned = true;
       }
       if (content.hasAttribute('hidden')) {
         container.style.zIndex += 1;
         content.removeAttribute('hidden');
       }
     };
</PRE><PRE>     var hideAnnotation = function hideAnnotation(unpin) {
       if (unpin) {
         pinned = false;
       }
       if (!content.hasAttribute('hidden') &amp;&amp; !pinned) {
         container.style.zIndex -= 1;
         content.setAttribute('hidden', true);
       }
     };
</PRE><PRE>     var toggleAnnotation = function toggleAnnotation() {
       if (pinned) {
         hideAnnotation(true);
       } else {
         showAnnotation(true);
       }
     };
</PRE><PRE>     image.addEventListener('click', function image_clickHandler() {
       toggleAnnotation();
     }, false);
     image.addEventListener('mouseover', function image_mouseOverHandler() {
       showAnnotation();
     }, false);
     image.addEventListener('mouseout', function image_mouseOutHandler() {
       hideAnnotation();
     }, false);
</PRE><PRE>     content.addEventListener('click', function content_clickHandler() {
       hideAnnotation(true);
     }, false);
   }
</PRE><PRE>   content.appendChild(title);
   content.appendChild(text);
   contentWrapper.appendChild(content);
   container.appendChild(image);
   container.appendChild(contentWrapper);
</PRE><PRE>   return container;
 }
</PRE><PRE> function getHtmlElementForLinkAnnotation(item) {
   var container = initContainer(item);
   container.className = 'annotLink';
</PRE><PRE>   var link = document.createElement('a');
   link.href = link.title = item.url || <I>;</I>
   if (item.url &amp;&amp; PDFJS.openExternalLinksInNewWindow) {
     link.target = '_blank';
   }
</PRE><PRE>   container.appendChild(link);
</PRE><PRE>   return container;
 }
</PRE><PRE> function getHtmlElement(data, objs) {
   switch (data.annotationType) {
     case AnnotationType.WIDGET:
       return getHtmlElementForTextWidgetAnnotation(data, objs);
     case AnnotationType.TEXT:
       return getHtmlElementForTextAnnotation(data);
     case AnnotationType.LINK:
       return getHtmlElementForLinkAnnotation(data);
     default:
       throw new Error('Unsupported annotationType: ' + data.annotationType);
   }
 }
</PRE><PRE> return {
   getHtmlElement: getHtmlElement
 };
</PRE><P>})();
PDFJS.AnnotationUtils = AnnotationUtils;
</P><P>
var SVG_DEFAULTS = {
</P><PRE> fontStyle: 'normal',
 fontWeight: 'normal',
 fillColor: '#000000'
</PRE><P>};
</P><P>var convertImgDataToPng = (function convertImgDataToPngClosure() {
</P><PRE> var PNG_HEADER =
   new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
</PRE><PRE> var CHUNK_WRAPPER_SIZE = 12;
</PRE><PRE> var crcTable = new Int32Array(256);
 for (var i = 0; i &lt; 256; i++) {
   var c = i;
   for (var h = 0; h &lt; 8; h++) {
     if (c &amp; 1) {
       c = 0xedB88320 ^ ((c &gt;&gt; 1) &amp; 0x7fffffff);
     } else {
       c = (c &gt;&gt; 1) &amp; 0x7fffffff;
     }
   }
   crcTable[i] = c;
 }
</PRE><PRE> function crc32(data, start, end) {
   var crc = -1;
   for (var i = start; i &lt; end; i++) {
     var a = (crc ^ data[i]) &amp; 0xff;
     var b = crcTable[a];
     crc = (crc &gt;&gt;&gt; 8) ^ b;
   }
   return crc ^ -1;
 }
</PRE><PRE> function writePngChunk(type, body, data, offset) {
   var p = offset;
   var len = body.length;
</PRE><PRE>   data[p] = len &gt;&gt; 24 &amp; 0xff;
   data[p + 1] = len &gt;&gt; 16 &amp; 0xff;
   data[p + 2] = len &gt;&gt; 8 &amp; 0xff;
   data[p + 3] = len &amp; 0xff;
   p += 4;
</PRE><PRE>   data[p] = type.charCodeAt(0) &amp; 0xff;
   data[p + 1] = type.charCodeAt(1) &amp; 0xff;
   data[p + 2] = type.charCodeAt(2) &amp; 0xff;
   data[p + 3] = type.charCodeAt(3) &amp; 0xff;
   p += 4;
</PRE><PRE>   data.set(body, p);
   p += body.length;
</PRE><PRE>   var crc = crc32(data, offset + 4, p);
</PRE><PRE>   data[p] = crc &gt;&gt; 24 &amp; 0xff;
   data[p + 1] = crc &gt;&gt; 16 &amp; 0xff;
   data[p + 2] = crc &gt;&gt; 8 &amp; 0xff;
   data[p + 3] = crc &amp; 0xff;
 }
</PRE><PRE> function adler32(data, start, end) {
   var a = 1;
   var b = 0;
   for (var i = start; i &lt; end; ++i) {
     a = (a + (data[i] &amp; 0xff)) % 65521;
     b = (b + a) % 65521;
   }
   return (b &lt;&lt; 16) | a;
 }
</PRE><PRE> function encode(imgData, kind) {
   var width = imgData.width;
   var height = imgData.height;
   var bitDepth, colorType, lineSize;
   var bytes = imgData.data;
</PRE><PRE>   switch (kind) {
     case ImageKind.GRAYSCALE_1BPP:
       colorType = 0;
       bitDepth = 1;
       lineSize = (width + 7) &gt;&gt; 3;
       break;
     case ImageKind.RGB_24BPP:
       colorType = 2;
       bitDepth = 8;
       lineSize = width * 3;
       break;
     case ImageKind.RGBA_32BPP:
       colorType = 6;
       bitDepth = 8;
       lineSize = width * 4;
       break;
     default:
       throw new Error('invalid format');
   }
</PRE><PRE>   // prefix every row with predictor 0
   var literals = new Uint8Array((1 + lineSize) * height);
   var offsetLiterals = 0, offsetBytes = 0;
   var y, i;
   for (y = 0; y &lt; height; ++y) {
     literals[offsetLiterals++] = 0; // no prediction
     literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize),
                  offsetLiterals);
     offsetBytes += lineSize;
     offsetLiterals += lineSize;
   }
</PRE><PRE>   if (kind === ImageKind.GRAYSCALE_1BPP) {
     // inverting for B/W
     offsetLiterals = 0;
     for (y = 0; y &lt; height; y++) {
       offsetLiterals++; // skipping predictor
       for (i = 0; i &lt; lineSize; i++) {
         literals[offsetLiterals++] ^= 0xFF;
       }
     }
   }
</PRE><PRE>   var ihdr = new Uint8Array([
     width &gt;&gt; 24 &amp; 0xff,
     width &gt;&gt; 16 &amp; 0xff,
     width &gt;&gt; 8 &amp; 0xff,
     width &amp; 0xff,
     height &gt;&gt; 24 &amp; 0xff,
     height &gt;&gt; 16 &amp; 0xff,
     height &gt;&gt; 8 &amp; 0xff,
     height &amp; 0xff,
     bitDepth, // bit depth
     colorType, // color type
     0x00, // compression method
     0x00, // filter method
     0x00 // interlace method
   ]);
</PRE><PRE>   var len = literals.length;
   var maxBlockLength = 0xFFFF;
</PRE><PRE>   var deflateBlocks = Math.ceil(len / maxBlockLength);
   var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
   var pi = 0;
   idat[pi++] = 0x78; // compression method and flags
   idat[pi++] = 0x9c; // flags
</PRE><PRE>   var pos = 0;
   while (len &gt; maxBlockLength) {
     // writing non-final DEFLATE blocks type 0 and length of 65535
     idat[pi++] = 0x00;
     idat[pi++] = 0xff;
     idat[pi++] = 0xff;
     idat[pi++] = 0x00;
     idat[pi++] = 0x00;
     idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
     pi += maxBlockLength;
     pos += maxBlockLength;
     len -= maxBlockLength;
   }
</PRE><PRE>   // writing non-final DEFLATE blocks type 0
   idat[pi++] = 0x01;
   idat[pi++] = len &amp; 0xff;
   idat[pi++] = len &gt;&gt; 8 &amp; 0xff;
   idat[pi++] = (~len &amp; 0xffff) &amp; 0xff;
   idat[pi++] = (~len &amp; 0xffff) &gt;&gt; 8 &amp; 0xff;
   idat.set(literals.subarray(pos), pi);
   pi += literals.length - pos;
</PRE><PRE>   var adler = adler32(literals, 0, literals.length); // checksum
   idat[pi++] = adler &gt;&gt; 24 &amp; 0xff;
   idat[pi++] = adler &gt;&gt; 16 &amp; 0xff;
   idat[pi++] = adler &gt;&gt; 8 &amp; 0xff;
   idat[pi++] = adler &amp; 0xff;
</PRE><PRE>   // PNG will consists: header, IHDR+data, IDAT+data, and IEND.
   var pngLength = PNG_HEADER.length + (CHUNK_WRAPPER_SIZE * 3) +
                   ihdr.length + idat.length;
   var data = new Uint8Array(pngLength);
   var offset = 0;
   data.set(PNG_HEADER, offset);
   offset += PNG_HEADER.length;
   writePngChunk('IHDR', ihdr, data, offset);
   offset += CHUNK_WRAPPER_SIZE + ihdr.length;
   writePngChunk('IDATA', idat, data, offset);
   offset += CHUNK_WRAPPER_SIZE + idat.length;
   writePngChunk('IEND', new Uint8Array(0), data, offset);
</PRE><PRE>   return PDFJS.createObjectURL(data, 'image/png');
 }
</PRE><PRE> return function convertImgDataToPng(imgData) {
   var kind = (imgData.kind === undefined ?
               ImageKind.GRAYSCALE_1BPP : imgData.kind);
   return encode(imgData, kind);
 };
</PRE><P>})();
</P><P>var SVGExtraState = (function SVGExtraStateClosure() {
</P><PRE> function SVGExtraState() {
   this.fontSizeScale = 1;
   this.fontWeight = SVG_DEFAULTS.fontWeight;
   this.fontSize = 0;
</PRE><PRE>   this.textMatrix = IDENTITY_MATRIX;
   this.fontMatrix = FONT_IDENTITY_MATRIX;
   this.leading = 0;
</PRE><PRE>   // Current point (in user coordinates)
   this.x = 0;
   this.y = 0;
</PRE><PRE>   // Start of text line (in text coordinates)
   this.lineX = 0;
   this.lineY = 0;
</PRE><PRE>   // Character and word spacing
   this.charSpacing = 0;
   this.wordSpacing = 0;
   this.textHScale = 1;
   this.textRise = 0;
</PRE><PRE>   // Default foreground and background colors
   this.fillColor = SVG_DEFAULTS.fillColor;
   this.strokeColor = '#000000';
</PRE><PRE>   this.fillAlpha = 1;
   this.strokeAlpha = 1;
   this.lineWidth = 1;
   this.lineJoin = <I>;</I>
   this.lineCap = <I>;</I>
   this.miterLimit = 0;
</PRE><PRE>   this.dashArray = [];
   this.dashPhase = 0;
</PRE><PRE>   this.dependencies = [];
</PRE><PRE>   // Clipping
   this.clipId = <I>;</I>
   this.pendingClip = false;
</PRE><PRE>   this.maskId = <I>;</I>
 }
</PRE><PRE> SVGExtraState.prototype = {
   clone: function SVGExtraState_clone() {
     return Object.create(this);
   },
   setCurrentPoint: function SVGExtraState_setCurrentPoint(x, y) {
     this.x = x;
     this.y = y;
   }
 };
 return SVGExtraState;
</PRE><P>})();
</P><P>var SVGGraphics = (function SVGGraphicsClosure() {
</P><PRE> function createScratchSVG(width, height) {
   var NS = '<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg'">http://www.w3.org/2000/svg'</A>;
   var svg = document.createElementNS(NS, 'svg:svg');
   svg.setAttributeNS(null, 'version', '1.1');
   svg.setAttributeNS(null, 'width', width + 'px');
   svg.setAttributeNS(null, 'height', height + 'px');
   svg.setAttributeNS(null, 'viewBox', '0 0 ' + width + ' ' + height);
   return svg;
 }
</PRE><PRE> function opListToTree(opList) {
   var opTree = [];
   var tmp = [];
   var opListLen = opList.length;
</PRE><PRE>   for (var x = 0; x &lt; opListLen; x++) {
     if (opList[x].fn === 'save') {
       opTree.push({'fnId': 92, 'fn': 'group', 'items': []});
       tmp.push(opTree);
       opTree = opTree[opTree.length - 1].items;
       continue;
     }
</PRE><PRE>     if(opList[x].fn === 'restore') {
       opTree = tmp.pop();
     } else {
       opTree.push(opList[x]);
     }
   }
   return opTree;
 }
</PRE><PRE> /**
  * Formats float number.
  * @param value {number} number to format.
  * @returns {string}
  */
 function pf(value) {
   if (value === (value | 0)) { // integer number
     return value.toString();
   }
   var s = value.toFixed(10);
   var i = s.length - 1;
   if (s[i] !== '0') {
     return s;
   }
   // removing trailing zeros
   do {
     i--;
   } while (s[i] === '0');
   return s.substr(0, s[i] === '.' ? i : i + 1);
 }
</PRE><PRE> /**
  * Formats transform matrix. The standard rotation, scale and translate
  * matrices are replaced by their shorter forms, and for identity matrix
  * returns empty string to save the memory.
  * @param m {Array} matrix to format.
  * @returns {string}
  */
 function pm(m) {
   if (m[4] === 0 &amp;&amp; m[5] === 0) {
     if (m[1] === 0 &amp;&amp; m[2] === 0) {
       if (m[0] === 1 &amp;&amp; m[3] === 1) {
         return <I>;</I>
       }
       return 'scale(' + pf(m[0]) + ' ' + pf(m[3]) + ')';
     }
     if (m[0] === m[3] &amp;&amp; m[1] === -m[2]) {
       var a = Math.acos(m[0]) * 180 / Math.PI;
       return 'rotate(' + pf(a) + ')';
     }
   } else {
     if (m[0] === 1 &amp;&amp; m[1] === 0 &amp;&amp; m[2] === 0 &amp;&amp; m[3] === 1) {
       return 'translate(' + pf(m[4]) + ' ' + pf(m[5]) + ')';
     }
   }
   return 'matrix(' + pf(m[0]) + ' ' + pf(m[1]) + ' ' + pf(m[2]) + ' ' +
     pf(m[3]) + ' ' + pf(m[4]) + ' ' + pf(m[5]) + ')';
 }
</PRE><PRE> function SVGGraphics(commonObjs, objs) {
   this.current = new SVGExtraState();
   this.transformMatrix = IDENTITY_MATRIX; // Graphics state matrix
   this.transformStack = [];
   this.extraStack = [];
   this.commonObjs = commonObjs;
   this.objs = objs;
   this.pendingEOFill = false;
</PRE><PRE>   this.embedFonts = false;
   this.embeddedFonts = {};
   this.cssStyle = null;
 }
</PRE><PRE> var NS = '<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg'">http://www.w3.org/2000/svg'</A>;
 var XML_NS = '<A rel="nofollow" class="external free" href="http://www.w3.org/XML/1998/namespace'">http://www.w3.org/XML/1998/namespace'</A>;
 var XLINK_NS = '<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xlink'">http://www.w3.org/1999/xlink'</A>;
 var LINE_CAP_STYLES = ['butt', 'round', 'square'];
 var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];
 var clipCount = 0;
 var maskCount = 0;
</PRE><PRE> SVGGraphics.prototype = {
   save: function SVGGraphics_save() {
     this.transformStack.push(this.transformMatrix);
     var old = this.current;
     this.extraStack.push(old);
     this.current = old.clone();
   },
</PRE><PRE>   restore: function SVGGraphics_restore() {
     this.transformMatrix = this.transformStack.pop();
     this.current = this.extraStack.pop();
</PRE><PRE>     this.tgrp = document.createElementNS(NS, 'svg:g');
     this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
     this.pgrp.appendChild(this.tgrp);
   },
</PRE><PRE>   group: function SVGGraphics_group(items) {
     this.save();
     this.executeOpTree(items);
     this.restore();
   },
</PRE><PRE>   loadDependencies: function SVGGraphics_loadDependencies(operatorList) {
     var fnArray = operatorList.fnArray;
     var fnArrayLen = fnArray.length;
     var argsArray = operatorList.argsArray;
</PRE><PRE>     var self = this;
     for (var i = 0; i &lt; fnArrayLen; i++) {
       if (OPS.dependency === fnArray[i]) {
         var deps = argsArray[i];
         for (var n = 0, nn = deps.length; n &lt; nn; n++) {
           var obj = deps[n];
           var common = obj.substring(0, 2) === 'g_';
           var promise;
           if (common) {
             promise = new Promise(function(resolve) {
               self.commonObjs.get(obj, resolve);
             });
           } else {
             promise = new Promise(function(resolve) {
               self.objs.get(obj, resolve);
             });
           }
           this.current.dependencies.push(promise);
         }
       }
     }
     return Promise.all(this.current.dependencies);
   },
</PRE><PRE>   transform: function SVGGraphics_transform(a, b, c, d, e, f) {
     var transformMatrix = [a, b, c, d, e, f];
     this.transformMatrix = PDFJS.Util.transform(this.transformMatrix,
                                                 transformMatrix);
</PRE><PRE>     this.tgrp = document.createElementNS(NS, 'svg:g');
     this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
   },
</PRE><PRE>   getSVG: function SVGGraphics_getSVG(operatorList, viewport) {
     this.svg = createScratchSVG(viewport.width, viewport.height);
     this.viewport = viewport;
</PRE><PRE>     return this.loadDependencies(operatorList).then(function () {
       this.transformMatrix = IDENTITY_MATRIX;
       this.pgrp = document.createElementNS(NS, 'svg:g'); // Parent group
       this.pgrp.setAttributeNS(null, 'transform', pm(viewport.transform));
       this.tgrp = document.createElementNS(NS, 'svg:g'); // Transform group
       this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
       this.defs = document.createElementNS(NS, 'svg:defs');
       this.pgrp.appendChild(this.defs);
       this.pgrp.appendChild(this.tgrp);
       this.svg.appendChild(this.pgrp);
       var opTree = this.convertOpList(operatorList);
       this.executeOpTree(opTree);
       return this.svg;
     }.bind(this));
   },
</PRE><PRE>   convertOpList: function SVGGraphics_convertOpList(operatorList) {
     var argsArray = operatorList.argsArray;
     var fnArray = operatorList.fnArray;
     var fnArrayLen  = fnArray.length;
     var REVOPS = [];
     var opList = [];
</PRE><PRE>     for (var op in OPS) {
       REVOPS[OPS[op]] = op;
     }
</PRE><PRE>     for (var x = 0; x &lt; fnArrayLen; x++) {
       var fnId = fnArray[x];
       opList.push({'fnId' : fnId, 'fn': REVOPS[fnId], 'args': argsArray[x]});
     }
     return opListToTree(opList);
   },
</PRE><PRE>   executeOpTree: function SVGGraphics_executeOpTree(opTree) {
     var opTreeLen = opTree.length;
     for(var x = 0; x &lt; opTreeLen; x++) {
       var fn = opTree[x].fn;
       var fnId = opTree[x].fnId;
       var args = opTree[x].args;
</PRE><PRE>       switch (fnId | 0) {
         case OPS.beginText:
           this.beginText();
           break;
         case OPS.setLeading:
           this.setLeading(args);
           break;
         case OPS.setLeadingMoveText:
           this.setLeadingMoveText(args[0], args[1]);
           break;
         case OPS.setFont:
           this.setFont(args);
           break;
         case OPS.showText:
           this.showText(args[0]);
           break;
         case OPS.showSpacedText:
           this.showText(args[0]);
           break;
         case OPS.endText:
           this.endText();
           break;
         case OPS.moveText:
           this.moveText(args[0], args[1]);
           break;
         case OPS.setCharSpacing:
           this.setCharSpacing(args[0]);
           break;
         case OPS.setWordSpacing:
           this.setWordSpacing(args[0]);
           break;
         case OPS.setHScale:
           this.setHScale(args[0]);
           break;
         case OPS.setTextMatrix:
           this.setTextMatrix(args[0], args[1], args[2],
                              args[3], args[4], args[5]);
           break;
         case OPS.setLineWidth:
           this.setLineWidth(args[0]);
           break;
         case OPS.setLineJoin:
           this.setLineJoin(args[0]);
           break;
         case OPS.setLineCap:
           this.setLineCap(args[0]);
           break;
         case OPS.setMiterLimit:
           this.setMiterLimit(args[0]);
           break;
         case OPS.setFillRGBColor:
           this.setFillRGBColor(args[0], args[1], args[2]);
           break;
         case OPS.setStrokeRGBColor:
           this.setStrokeRGBColor(args[0], args[1], args[2]);
           break;
         case OPS.setDash:
           this.setDash(args[0], args[1]);
           break;
         case OPS.setGState:
           this.setGState(args[0]);
           break;
         case OPS.fill:
           this.fill();
           break;
         case OPS.eoFill:
           this.eoFill();
           break;
         case OPS.stroke:
           this.stroke();
           break;
         case OPS.fillStroke:
           this.fillStroke();
           break;
         case OPS.eoFillStroke:
           this.eoFillStroke();
           break;
         case OPS.clip:
           this.clip('nonzero');
           break;
         case OPS.eoClip:
           this.clip('evenodd');
           break;
         case OPS.paintSolidColorImageMask:
           this.paintSolidColorImageMask();
           break;
         case OPS.paintJpegXObject:
           this.paintJpegXObject(args[0], args[1], args[2]);
           break;
         case OPS.paintImageXObject:
           this.paintImageXObject(args[0]);
           break;
         case OPS.paintInlineImageXObject:
           this.paintInlineImageXObject(args[0]);
           break;
         case OPS.paintImageMaskXObject:
           this.paintImageMaskXObject(args[0]);
           break;
         case OPS.paintFormXObjectBegin:
           this.paintFormXObjectBegin(args[0], args[1]);
           break;
         case OPS.paintFormXObjectEnd:
           this.paintFormXObjectEnd();
           break;
         case OPS.closePath:
           this.closePath();
           break;
         case OPS.closeStroke:
           this.closeStroke();
           break;
         case OPS.closeFillStroke:
           this.closeFillStroke();
           break;
         case OPS.nextLine:
           this.nextLine();
           break;
         case OPS.transform:
           this.transform(args[0], args[1], args[2], args[3],
                          args[4], args[5]);
           break;
         case OPS.constructPath:
           this.constructPath(args[0], args[1]);
           break;
         case OPS.endPath:
           this.endPath();
           break;
         case 92:
           this.group(opTree[x].items);
           break;
         default:
           warn('Unimplemented method '+ fn);
           break;
       }
     }
   },
</PRE><PRE>   setWordSpacing: function SVGGraphics_setWordSpacing(wordSpacing) {
     this.current.wordSpacing = wordSpacing;
   },
</PRE><PRE>   setCharSpacing: function SVGGraphics_setCharSpacing(charSpacing) {
     this.current.charSpacing = charSpacing;
   },
</PRE><PRE>   nextLine: function SVGGraphics_nextLine() {
     this.moveText(0, this.current.leading);
   },
</PRE><PRE>   setTextMatrix: function SVGGraphics_setTextMatrix(a, b, c, d, e, f) {
     var current = this.current;
     this.current.textMatrix = this.current.lineMatrix = [a, b, c, d, e, f];
</PRE><PRE>     this.current.x = this.current.lineX = 0;
     this.current.y = this.current.lineY = 0;
</PRE><PRE>     current.xcoords = [];
     current.tspan = document.createElementNS(NS, 'svg:tspan');
     current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
     current.tspan.setAttributeNS(null, 'font-size',
                                  pf(current.fontSize) + 'px');
     current.tspan.setAttributeNS(null, 'y', pf(-current.y));
</PRE><PRE>     current.txtElement = document.createElementNS(NS, 'svg:text');
     current.txtElement.appendChild(current.tspan);
   },
</PRE><PRE>   beginText: function SVGGraphics_beginText() {
     this.current.x = this.current.lineX = 0;
     this.current.y = this.current.lineY = 0;
     this.current.textMatrix = IDENTITY_MATRIX;
     this.current.lineMatrix = IDENTITY_MATRIX;
     this.current.tspan = document.createElementNS(NS, 'svg:tspan');
     this.current.txtElement = document.createElementNS(NS, 'svg:text');
     this.current.txtgrp = document.createElementNS(NS, 'svg:g');
     this.current.xcoords = [];
   },
</PRE><PRE>   moveText: function SVGGraphics_moveText(x, y) {
     var current = this.current;
     this.current.x = this.current.lineX += x;
     this.current.y = this.current.lineY += y;
</PRE><PRE>     current.xcoords = [];
     current.tspan = document.createElementNS(NS, 'svg:tspan');
     current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
     current.tspan.setAttributeNS(null, 'font-size',
                                  pf(current.fontSize) + 'px');
     current.tspan.setAttributeNS(null, 'y', pf(-current.y));
   },
</PRE><PRE>   showText: function SVGGraphics_showText(glyphs) {
     var current = this.current;
     var font = current.font;
     var fontSize = current.fontSize;
</PRE><PRE>     if (fontSize === 0) {
       return;
     }
</PRE><PRE>     var charSpacing = current.charSpacing;
     var wordSpacing = current.wordSpacing;
     var fontDirection = current.fontDirection;
     var textHScale = current.textHScale * fontDirection;
     var glyphsLength = glyphs.length;
     var vertical = font.vertical;
     var widthAdvanceScale = fontSize * current.fontMatrix[0];
</PRE><PRE>     var x = 0, i;
     for (i = 0; i &lt; glyphsLength; ++i) {
       var glyph = glyphs[i];
       if (glyph === null) {
         // word break
         x += fontDirection * wordSpacing;
         continue;
       } else if (isNum(glyph)) {
         x += -glyph * fontSize * 0.001;
         continue;
       }
       current.xcoords.push(current.x + x * textHScale);
</PRE><PRE>       var width = glyph.width;
       var character = glyph.fontChar;
       var charWidth = width * widthAdvanceScale + charSpacing * fontDirection;
       x += charWidth;
</PRE><PRE>       current.tspan.textContent += character;
     }
     if (vertical) {
       current.y -= x * textHScale;
     } else {
       current.x += x * textHScale;
     }
</PRE><PRE>     current.tspan.setAttributeNS(null, 'x',
                                  current.xcoords.map(pf).join(' '));
     current.tspan.setAttributeNS(null, 'y', pf(-current.y));
     current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);
     current.tspan.setAttributeNS(null, 'font-size',
                                  pf(current.fontSize) + 'px');
     if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
       current.tspan.setAttributeNS(null, 'font-style', current.fontStyle);
     }
     if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
       current.tspan.setAttributeNS(null, 'font-weight', current.fontWeight);
     }
     if (current.fillColor !== SVG_DEFAULTS.fillColor) {
       current.tspan.setAttributeNS(null, 'fill', current.fillColor);
     }
</PRE><PRE>     current.txtElement.setAttributeNS(null, 'transform',
                                       pm(current.textMatrix) +
                                       ' scale(1, -1)' );
     current.txtElement.setAttributeNS(XML_NS, 'xml:space', 'preserve');
     current.txtElement.appendChild(current.tspan);
     current.txtgrp.appendChild(current.txtElement);
</PRE><PRE>     this.tgrp.appendChild(current.txtElement);
</PRE><PRE>   },
</PRE><PRE>   setLeadingMoveText: function SVGGraphics_setLeadingMoveText(x, y) {
     this.setLeading(-y);
     this.moveText(x, y);
   },
</PRE><PRE>   addFontStyle: function SVGGraphics_addFontStyle(fontObj) {
     if (!this.cssStyle) {
       this.cssStyle = document.createElementNS(NS, 'svg:style');
       this.cssStyle.setAttributeNS(null, 'type', 'text/css');
       this.defs.appendChild(this.cssStyle);
     }
</PRE><PRE>     var url = PDFJS.createObjectURL(fontObj.data, fontObj.mimetype);
     this.cssStyle.textContent +=
       '@font-face { font-family: &quot;' + fontObj.loadedName + '&quot;;' +
       ' src: url(' + url + '); }\n';
   },
</PRE><PRE>   setFont: function SVGGraphics_setFont(details) {
     var current = this.current;
     var fontObj = this.commonObjs.get(details[0]);
     var size = details[1];
     this.current.font = fontObj;
</PRE><PRE>     if (this.embedFonts &amp;&amp; fontObj.data &amp;&amp; !this.embeddedFonts[fontObj.loadedName]) {
       this.addFontStyle(fontObj);
       this.embeddedFonts[fontObj.loadedName] = fontObj;
     }
</PRE><PRE>     current.fontMatrix = (fontObj.fontMatrix ?
                           fontObj.fontMatrix : FONT_IDENTITY_MATRIX);
</PRE><PRE>     var bold = fontObj.black ? (fontObj.bold ? 'bolder' : 'bold') :
                                (fontObj.bold ? 'bold' : 'normal');
     var italic = fontObj.italic ? 'italic' : 'normal';
</PRE><PRE>     if (size &lt; 0) {
       size = -size;
       current.fontDirection = -1;
     } else {
       current.fontDirection = 1;
     }
     current.fontSize = size;
     current.fontFamily = fontObj.loadedName;
     current.fontWeight = bold;
     current.fontStyle = italic;
</PRE><PRE>     current.tspan = document.createElementNS(NS, 'svg:tspan');
     current.tspan.setAttributeNS(null, 'y', pf(-current.y));
     current.xcoords = [];
   },
</PRE><PRE>   endText: function SVGGraphics_endText() {
     if (this.current.pendingClip) {
       this.cgrp.appendChild(this.tgrp);
       this.pgrp.appendChild(this.cgrp);
     } else {
       this.pgrp.appendChild(this.tgrp);
     }
     this.tgrp = document.createElementNS(NS, 'svg:g');
     this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
   },
</PRE><PRE>   // Path properties
   setLineWidth: function SVGGraphics_setLineWidth(width) {
     this.current.lineWidth = width;
   },
   setLineCap: function SVGGraphics_setLineCap(style) {
     this.current.lineCap = LINE_CAP_STYLES[style];
   },
   setLineJoin: function SVGGraphics_setLineJoin(style) {
     this.current.lineJoin = LINE_JOIN_STYLES[style];
   },
   setMiterLimit: function SVGGraphics_setMiterLimit(limit) {
     this.current.miterLimit = limit;
   },
   setStrokeRGBColor: function SVGGraphics_setStrokeRGBColor(r, g, b) {
     var color = Util.makeCssRgb(r, g, b);
     this.current.strokeColor = color;
   },
   setFillRGBColor: function SVGGraphics_setFillRGBColor(r, g, b) {
     var color = Util.makeCssRgb(r, g, b);
     this.current.fillColor = color;
     this.current.tspan = document.createElementNS(NS, 'svg:tspan');
     this.current.xcoords = [];
   },
   setDash: function SVGGraphics_setDash(dashArray, dashPhase) {
     this.current.dashArray = dashArray;
     this.current.dashPhase = dashPhase;
   },
</PRE><PRE>   constructPath: function SVGGraphics_constructPath(ops, args) {
     var current = this.current;
     var x = current.x, y = current.y;
     current.path = document.createElementNS(NS, 'svg:path');
     var d = [];
     var opLength = ops.length;
</PRE><PRE>     for (var i = 0, j = 0; i &lt; opLength; i++) {
       switch (ops[i] | 0) {
         case OPS.rectangle:
           x = args[j++];
           y = args[j++];
           var width = args[j++];
           var height = args[j++];
           var xw = x + width;
           var yh = y + height;
           d.push('M', pf(x), pf(y), 'L', pf(xw) , pf(y), 'L', pf(xw), pf(yh),
                  'L', pf(x), pf(yh), 'Z');
           break;
         case OPS.moveTo:
           x = args[j++];
           y = args[j++];
           d.push('M', pf(x), pf(y));
           break;
         case OPS.lineTo:
           x = args[j++];
           y = args[j++];
           d.push('L', pf(x) , pf(y));
           break;
         case OPS.curveTo:
           x = args[j + 4];
           y = args[j + 5];
           d.push('C', pf(args[j]), pf(args[j + 1]), pf(args[j + 2]),
                  pf(args[j + 3]), pf(x), pf(y));
           j += 6;
           break;
         case OPS.curveTo2:
           x = args[j + 2];
           y = args[j + 3];
           d.push('C', pf(x), pf(y), pf(args[j]), pf(args[j + 1]),
                  pf(args[j + 2]), pf(args[j + 3]));
           j += 4;
           break;
         case OPS.curveTo3:
           x = args[j + 2];
           y = args[j + 3];
           d.push('C', pf(args[j]), pf(args[j + 1]), pf(x), pf(y),
                  pf(x), pf(y));
           j += 4;
           break;
         case OPS.closePath:
           d.push('Z');
           break;
       }
     }
     current.path.setAttributeNS(null, 'd', d.join(' '));
     current.path.setAttributeNS(null, 'stroke-miterlimit',
                                 pf(current.miterLimit));
     current.path.setAttributeNS(null, 'stroke-linecap', current.lineCap);
     current.path.setAttributeNS(null, 'stroke-linejoin', current.lineJoin);
     current.path.setAttributeNS(null, 'stroke-width',
                                 pf(current.lineWidth) + 'px');
     current.path.setAttributeNS(null, 'stroke-dasharray',
                                 current.dashArray.map(pf).join(' '));
     current.path.setAttributeNS(null, 'stroke-dashoffset',
                                 pf(current.dashPhase) + 'px');
     current.path.setAttributeNS(null, 'fill', 'none');
</PRE><PRE>     this.tgrp.appendChild(current.path);
     if (current.pendingClip) {
       this.cgrp.appendChild(this.tgrp);
       this.pgrp.appendChild(this.cgrp);
     } else {
       this.pgrp.appendChild(this.tgrp);
     }
     // Saving a reference in current.element so that it can be addressed
     // in 'fill' and 'stroke'
     current.element = current.path;
     current.setCurrentPoint(x, y);
   },
</PRE><PRE>   endPath: function SVGGraphics_endPath() {
     var current = this.current;
     if (current.pendingClip) {
       this.cgrp.appendChild(this.tgrp);
       this.pgrp.appendChild(this.cgrp);
     } else {
       this.pgrp.appendChild(this.tgrp);
     }
     this.tgrp = document.createElementNS(NS, 'svg:g');
     this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));
   },
</PRE><PRE>   clip: function SVGGraphics_clip(type) {
     var current = this.current;
     // Add current path to clipping path
     current.clipId = 'clippath' + clipCount;
     clipCount++;
     this.clippath = document.createElementNS(NS, 'svg:clipPath');
     this.clippath.setAttributeNS(null, 'id', current.clipId);
     var clipElement = current.element.cloneNode();
     if (type === 'evenodd') {
       clipElement.setAttributeNS(null, 'clip-rule', 'evenodd');
     } else {
       clipElement.setAttributeNS(null, 'clip-rule', 'nonzero');
     }
     this.clippath.setAttributeNS(null, 'transform', pm(this.transformMatrix));
     this.clippath.appendChild(clipElement);
     this.defs.appendChild(this.clippath);
</PRE><PRE>     // Create a new group with that attribute
     current.pendingClip = true;
     this.cgrp = document.createElementNS(NS, 'svg:g');
     this.cgrp.setAttributeNS(null, 'clip-path',
                              'url(#' + current.clipId + ')');
     this.pgrp.appendChild(this.cgrp);
   },
</PRE><PRE>   closePath: function SVGGraphics_closePath() {
     var current = this.current;
     var d = current.path.getAttributeNS(null, 'd');
     d += 'Z';
     current.path.setAttributeNS(null, 'd', d);
   },
</PRE><PRE>   setLeading: function SVGGraphics_setLeading(leading) {
     this.current.leading = -leading;
   },
</PRE><PRE>   setTextRise: function SVGGraphics_setTextRise(textRise) {
     this.current.textRise = textRise;
   },
</PRE><PRE>   setHScale: function SVGGraphics_setHScale(scale) {
     this.current.textHScale = scale / 100;
   },
</PRE><PRE>   setGState: function SVGGraphics_setGState(states) {
     for (var i = 0, ii = states.length; i &lt; ii; i++) {
       var state = states[i];
       var key = state[0];
       var value = state[1];
</PRE><PRE>       switch (key) {
         case 'LW':
           this.setLineWidth(value);
           break;
         case 'LC':
           this.setLineCap(value);
           break;
         case 'LJ':
           this.setLineJoin(value);
           break;
         case 'ML':
           this.setMiterLimit(value);
           break;
         case 'D':
           this.setDash(value[0], value[1]);
           break;
         case 'RI':
           break;
         case 'FL':
           break;
         case 'Font':
           this.setFont(value);
           break;
         case 'CA':
           break;
         case 'ca':
           break;
         case 'BM':
           break;
         case 'SMask':
           break;
       }
     }
   },
</PRE><PRE>   fill: function SVGGraphics_fill() {
     var current = this.current;
     current.element.setAttributeNS(null, 'fill', current.fillColor);
   },
</PRE><PRE>   stroke: function SVGGraphics_stroke() {
     var current = this.current;
     current.element.setAttributeNS(null, 'stroke', current.strokeColor);
     current.element.setAttributeNS(null, 'fill', 'none');
   },
</PRE><PRE>   eoFill: function SVGGraphics_eoFill() {
     var current = this.current;
     current.element.setAttributeNS(null, 'fill', current.fillColor);
     current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
   },
</PRE><PRE>   fillStroke: function SVGGraphics_fillStroke() {
     // Order is important since stroke wants fill to be none.
     // First stroke, then if fill needed, it will be overwritten.
     this.stroke();
     this.fill();
   },
</PRE><PRE>   eoFillStroke: function SVGGraphics_eoFillStroke() {
     this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');
     this.fillStroke();
   },
</PRE><PRE>   closeStroke: function SVGGraphics_closeStroke() {
     this.closePath();
     this.stroke();
   },
</PRE><PRE>   closeFillStroke: function SVGGraphics_closeFillStroke() {
     this.closePath();
     this.fillStroke();
   },
</PRE><PRE>   paintSolidColorImageMask:
       function SVGGraphics_paintSolidColorImageMask() {
     var current = this.current;
     var rect = document.createElementNS(NS, 'svg:rect');
     rect.setAttributeNS(null, 'x', '0');
     rect.setAttributeNS(null, 'y', '0');
     rect.setAttributeNS(null, 'width', '1px');
     rect.setAttributeNS(null, 'height', '1px');
     rect.setAttributeNS(null, 'fill', current.fillColor);
     this.tgrp.appendChild(rect);
   },
</PRE><PRE>   paintJpegXObject: function SVGGraphics_paintJpegXObject(objId, w, h) {
     var current = this.current;
     var imgObj = this.objs.get(objId);
     var imgEl = document.createElementNS(NS, 'svg:image');
     imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgObj.src);
     imgEl.setAttributeNS(null, 'width', imgObj.width + 'px');
     imgEl.setAttributeNS(null, 'height', imgObj.height + 'px');
     imgEl.setAttributeNS(null, 'x', '0');
     imgEl.setAttributeNS(null, 'y', pf(-h));
     imgEl.setAttributeNS(null, 'transform',
                          'scale(' + pf(1 / w) + ' ' + pf(-1 / h) + ')');
</PRE><PRE>     this.tgrp.appendChild(imgEl);
     if (current.pendingClip) {
       this.cgrp.appendChild(this.tgrp);
       this.pgrp.appendChild(this.cgrp);
     } else {
       this.pgrp.appendChild(this.tgrp);
     }
   },
</PRE><PRE>   paintImageXObject: function SVGGraphics_paintImageXObject(objId) {
     var imgData = this.objs.get(objId);
     if (!imgData) {
       warn('Dependent image isn\'t ready yet');
       return;
     }
     this.paintInlineImageXObject(imgData);
   },
</PRE><PRE>   paintInlineImageXObject:
       function SVGGraphics_paintInlineImageXObject(imgData, mask) {
     var current = this.current;
     var width = imgData.width;
     var height = imgData.height;
</PRE><PRE>     var imgSrc = convertImgDataToPng(imgData);
     var cliprect = document.createElementNS(NS, 'svg:rect');
     cliprect.setAttributeNS(null, 'x', '0');
     cliprect.setAttributeNS(null, 'y', '0');
     cliprect.setAttributeNS(null, 'width', pf(width));
     cliprect.setAttributeNS(null, 'height', pf(height));
     current.element = cliprect;
     this.clip('nonzero');
     var imgEl = document.createElementNS(NS, 'svg:image');
     imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgSrc);
     imgEl.setAttributeNS(null, 'x', '0');
     imgEl.setAttributeNS(null, 'y', pf(-height));
     imgEl.setAttributeNS(null, 'width', pf(width) + 'px');
     imgEl.setAttributeNS(null, 'height', pf(height) + 'px');
     imgEl.setAttributeNS(null, 'transform',
                          'scale(' + pf(1 / width) + ' ' +
                          pf(-1 / height) + ')');
     if (mask) {
       mask.appendChild(imgEl);
     } else {
       this.tgrp.appendChild(imgEl);
     }
     if (current.pendingClip) {
       this.cgrp.appendChild(this.tgrp);
       this.pgrp.appendChild(this.cgrp);
     } else {
       this.pgrp.appendChild(this.tgrp);
     }
   },
</PRE><PRE>   paintImageMaskXObject:
       function SVGGraphics_paintImageMaskXObject(imgData) {
     var current = this.current;
     var width = imgData.width;
     var height = imgData.height;
     var fillColor = current.fillColor;
</PRE><PRE>     current.maskId = 'mask' + maskCount++;
     var mask = document.createElementNS(NS, 'svg:mask');
     mask.setAttributeNS(null, 'id', current.maskId);
</PRE><PRE>     var rect = document.createElementNS(NS, 'svg:rect');
     rect.setAttributeNS(null, 'x', '0');
     rect.setAttributeNS(null, 'y', '0');
     rect.setAttributeNS(null, 'width', pf(width));
     rect.setAttributeNS(null, 'height', pf(height));
     rect.setAttributeNS(null, 'fill', fillColor);
     rect.setAttributeNS(null, 'mask', 'url(#' + current.maskId +')');
     this.defs.appendChild(mask);
     this.tgrp.appendChild(rect);
</PRE><PRE>     this.paintInlineImageXObject(imgData, mask);
   },
</PRE><PRE>   paintFormXObjectBegin:
       function SVGGraphics_paintFormXObjectBegin(matrix, bbox) {
     this.save();
</PRE><PRE>     if (isArray(matrix) &amp;&amp; matrix.length === 6) {
       this.transform(matrix[0], matrix[1], matrix[2],
                      matrix[3], matrix[4], matrix[5]);
     }
</PRE><PRE>     if (isArray(bbox) &amp;&amp; bbox.length === 4) {
       var width = bbox[2] - bbox[0];
       var height = bbox[3] - bbox[1];
</PRE><PRE>       var cliprect = document.createElementNS(NS, 'svg:rect');
       cliprect.setAttributeNS(null, 'x', bbox[0]);
       cliprect.setAttributeNS(null, 'y', bbox[1]);
       cliprect.setAttributeNS(null, 'width', pf(width));
       cliprect.setAttributeNS(null, 'height', pf(height));
       this.current.element = cliprect;
       this.clip('nonzero');
       this.endPath();
     }
   },
</PRE><PRE>   paintFormXObjectEnd:
       function SVGGraphics_paintFormXObjectEnd() {
     this.restore();
   }
 };
 return SVGGraphics;
</PRE><P>})();
</P><P>PDFJS.SVGGraphics = SVGGraphics;
</P><P>
}).call((typeof window === 'undefined') ? this : window);
</P><P>if (!PDFJS.workerSrc &amp;&amp; typeof document !== 'undefined') {
</P><PRE> // workerSrc is not set -- using last script url to define default location
 PDFJS.workerSrc = (function () {
   'use strict';
   var scriptTagContainer = document.body ||
                            document.getElementsByTagName('head')[0];
   var pdfjsSrc = scriptTagContainer.lastChild.src;
   return pdfjsSrc &amp;&amp; pdfjsSrc.replace(/\.js$/i, '.worker.js');
 })();
</PRE><P>}
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
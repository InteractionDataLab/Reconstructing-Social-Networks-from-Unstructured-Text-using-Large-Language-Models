<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Lund_scripts_parallax skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Lund/scripts/parallax</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE>* parallax.js v1.4.2 (<A rel="nofollow" class="external free" href="http://pixelcog.github.io/parallax.js/">http://pixelcog.github.io/parallax.js/</A>)
* @copyright 2016 PixelCog, Inc.
* @license MIT (<A rel="nofollow" class="external free" href="https://github.com/pixelcog/parallax.js/blob/master/LICENSE">https://github.com/pixelcog/parallax.js/blob/master/LICENSE</A>)
*/
</PRE><DL><DT>(function ( $, window, document, undefined ) {</DT></DL><PRE> // Polyfill for requestAnimationFrame
 // via: <A rel="nofollow" class="external free" href="https://gist.github.com/paulirish/1579671">https://gist.github.com/paulirish/1579671</A></PRE><PRE> (function() {
   var lastTime = 0;
   var vendors = ['ms', 'moz', 'webkit', 'o'];
   for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
     window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
     window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
       || window[vendors[x]+'CancelRequestAnimationFrame'];
   }
</PRE><PRE>   if (!window.requestAnimationFrame)
     window.requestAnimationFrame = function(callback) {
       var currTime = new Date().getTime();
       var timeToCall = Math.max(0, 16 - (currTime - lastTime));
       var id = window.setTimeout(function() { callback(currTime + timeToCall); },
         timeToCall);
       lastTime = currTime + timeToCall;
       return id;
     };
</PRE><PRE>   if (!window.cancelAnimationFrame)
     window.cancelAnimationFrame = function(id) {
       clearTimeout(id);
     };
 }());
</PRE><PRE> // Parallax Constructor
</PRE><PRE> function Parallax(element, options) {
   var self = this;
</PRE><PRE>   if (typeof options == 'object') {
     delete options.refresh;
     delete options.render;
     $.extend(this, options);
   }
</PRE><PRE>   this.$element = $(element);
</PRE><PRE>   if (!this.imageSrc &amp;&amp; this.$element.is('img')) {
     this.imageSrc = this.$element.attr('src');
   }
</PRE><PRE>   var positions = (this.position + <I>).toLowerCase().match(/\S+/g) || [];</I></PRE><PRE>   if (positions.length &lt; 1) {
     positions.push('center');
   }
   if (positions.length == 1) {
     positions.push(positions[0]);
   }
</PRE><PRE>   if (positions[0] == 'top' || positions[0] == 'bottom' || positions[1] == 'left' || positions[1] == 'right') {
     positions = [positions[1], positions[0]];
   }
</PRE><PRE>   if (this.positionX != undefined) positions[0] = this.positionX.toLowerCase();
   if (this.positionY != undefined) positions[1] = this.positionY.toLowerCase();
</PRE><PRE>   self.positionX = positions[0];
   self.positionY = positions[1];
</PRE><PRE>   if (this.positionX != 'left' &amp;&amp; this.positionX != 'right') {
     if (isNaN(parseInt(this.positionX))) {
       this.positionX = 'center';
     } else {
       this.positionX = parseInt(this.positionX);
     }
   }
</PRE><PRE>   if (this.positionY != 'top' &amp;&amp; this.positionY != 'bottom') {
     if (isNaN(parseInt(this.positionY))) {
       this.positionY = 'center';
     } else {
       this.positionY = parseInt(this.positionY);
     }
   }
</PRE><PRE>   this.position =
     this.positionX + (isNaN(this.positionX)? <I> : 'px') + ' ' +</I>
     this.positionY + (isNaN(this.positionY)? <I> : 'px');</I></PRE><PRE>   if (navigator.userAgent.match(/(iPod|iPhone|iPad)/)) {
     if (this.imageSrc &amp;&amp; this.iosFix &amp;&amp; !this.$element.is('img')) {
       this.$element.css({
         backgroundImage: 'url(' + this.imageSrc + ')',
         backgroundSize: 'cover',
         backgroundPosition: this.position
       });
     }
     return this;
   }
</PRE><PRE>   if (navigator.userAgent.match(/(Android)/)) {
     if (this.imageSrc &amp;&amp; this.androidFix &amp;&amp; !this.$element.is('img')) {
       this.$element.css({
         backgroundImage: 'url(' + this.imageSrc + ')',
         backgroundSize: 'cover',
         backgroundPosition: this.position
       });
     }
     return this;
   }
</PRE><PRE>   this.$mirror = $('&lt;div /&gt;').prependTo('body');
</PRE><PRE>   var slider = this.$element.find('&gt;.parallax-slider');
   var sliderExisted = false;
</PRE><PRE>   if (slider.length == 0)
     this.$slider = $('&lt;img /&gt;').prependTo(this.$mirror);
   else {
     this.$slider = slider.prependTo(this.$mirror)
     sliderExisted = true;
   }
</PRE><PRE>   this.$mirror.addClass('parallax-mirror').css({
     visibility: 'hidden',
     zIndex: this.zIndex,
     position: 'fixed',
     top: 0,
     left: 0,
     overflow: 'hidden'
   });
</PRE><PRE>   this.$slider.addClass('parallax-slider').one('load', function() {
     if (!self.naturalHeight || !self.naturalWidth) {
       self.naturalHeight = this.naturalHeight || this.height || 1;
       self.naturalWidth  = this.naturalWidth  || this.width  || 1;
     }
     self.aspectRatio = self.naturalWidth / self.naturalHeight;
</PRE><PRE>     Parallax.isSetup || Parallax.setup();
     Parallax.sliders.push(self);
     Parallax.isFresh = false;
     Parallax.requestRender();
   });
</PRE><PRE>   if (!sliderExisted)
     this.$slider[0].src = this.imageSrc;
</PRE><PRE>   if (this.naturalHeight &amp;&amp; this.naturalWidth || this.$slider[0].complete || slider.length &gt; 0) {
     this.$slider.trigger('load');
   }
</PRE><PRE> };
</PRE><PRE> // Parallax Instance Methods
</PRE><PRE> $.extend(Parallax.prototype, {
   speed:    0.2,
   bleed:    0,
   zIndex:   -100,
   iosFix:   true,
   androidFix: true,
   position: 'center',
   overScrollFix: false,
</PRE><PRE>   refresh: function() {
     this.boxWidth        = this.$element.outerWidth();
     this.boxHeight       = this.$element.outerHeight() + this.bleed * 2;
     this.boxOffsetTop    = this.$element.offset().top - this.bleed;
     this.boxOffsetLeft   = this.$element.offset().left;
     this.boxOffsetBottom = this.boxOffsetTop + this.boxHeight;
</PRE><PRE>     var winHeight = Parallax.winHeight;
     var docHeight = Parallax.docHeight;
     var maxOffset = Math.min(this.boxOffsetTop, docHeight - winHeight);
     var minOffset = Math.max(this.boxOffsetTop + this.boxHeight - winHeight, 0);
     var imageHeightMin = this.boxHeight + (maxOffset - minOffset) * (1 - this.speed) | 0;
     var imageOffsetMin = (this.boxOffsetTop - maxOffset) * (1 - this.speed) | 0;
</PRE><PRE>     if (imageHeightMin * this.aspectRatio &gt;= this.boxWidth) {
       this.imageWidth    = imageHeightMin * this.aspectRatio | 0;
       this.imageHeight   = imageHeightMin;
       this.offsetBaseTop = imageOffsetMin;
</PRE><PRE>       var margin = this.imageWidth - this.boxWidth;
</PRE><PRE>       if (this.positionX == 'left') {
         this.offsetLeft = 0;
       } else if (this.positionX == 'right') {
         this.offsetLeft = - margin;
       } else if (!isNaN(this.positionX)) {
         this.offsetLeft = Math.max(this.positionX, - margin);
       } else {
         this.offsetLeft = - margin / 2 | 0;
       }
     } else {
       this.imageWidth    = this.boxWidth;
       this.imageHeight   = this.boxWidth / this.aspectRatio | 0;
       this.offsetLeft    = 0;
</PRE><PRE>       var margin = this.imageHeight - imageHeightMin;
</PRE><PRE>       if (this.positionY == 'top') {
         this.offsetBaseTop = imageOffsetMin;
       } else if (this.positionY == 'bottom') {
         this.offsetBaseTop = imageOffsetMin - margin;
       } else if (!isNaN(this.positionY)) {
         this.offsetBaseTop = imageOffsetMin + Math.max(this.positionY, - margin);
       } else {
         this.offsetBaseTop = imageOffsetMin - margin / 2 | 0;
       }
     }
   },
</PRE><PRE>   render: function() {
     var scrollTop    = Parallax.scrollTop;
     var scrollLeft   = Parallax.scrollLeft;
     var overScroll   = this.overScrollFix ? Parallax.overScroll : 0;
     var scrollBottom = scrollTop + Parallax.winHeight;
</PRE><PRE>     if (this.boxOffsetBottom &gt; scrollTop &amp;&amp; this.boxOffsetTop &lt;= scrollBottom) {
       this.visibility = 'visible';
       this.mirrorTop = this.boxOffsetTop  - scrollTop;
       this.mirrorLeft = this.boxOffsetLeft - scrollLeft;
       this.offsetTop = this.offsetBaseTop - this.mirrorTop * (1 - this.speed);
     } else {
       this.visibility = 'hidden';
     }
</PRE><PRE>     this.$mirror.css({
       transform: 'translate3d(0px, 0px, 0px)',
       visibility: this.visibility,
       top: this.mirrorTop - overScroll,
       left: this.mirrorLeft,
       height: this.boxHeight,
       width: this.boxWidth
     });
</PRE><PRE>     this.$slider.css({
       transform: 'translate3d(0px, 0px, 0px)',
       position: 'absolute',
       top: this.offsetTop,
       left: this.offsetLeft,
       height: this.imageHeight,
       width: this.imageWidth,
       maxWidth: 'none'
     });
   }
 });
</PRE><PRE> // Parallax Static Methods
</PRE><PRE> $.extend(Parallax, {
   scrollTop:    0,
   scrollLeft:   0,
   winHeight:    0,
   winWidth:     0,
   docHeight:    1 &lt;&lt; 30,
   docWidth:     1 &lt;&lt; 30,
   sliders:      [],
   isReady:      false,
   isFresh:      false,
   isBusy:       false,
</PRE><PRE>   setup: function() {
     if (this.isReady) return;
</PRE><PRE>     var $doc = $(document), $win = $(window);
</PRE><PRE>     var loadDimensions = function() {
       Parallax.winHeight = $win.height();
       Parallax.winWidth  = $win.width();
       Parallax.docHeight = $doc.height();
       Parallax.docWidth  = $doc.width();
     };
</PRE><PRE>     var loadScrollPosition = function() {
       var winScrollTop  = $win.scrollTop();
       var scrollTopMax  = Parallax.docHeight - Parallax.winHeight;
       var scrollLeftMax = Parallax.docWidth  - Parallax.winWidth;
       Parallax.scrollTop  = Math.max(0, Math.min(scrollTopMax,  winScrollTop));
       Parallax.scrollLeft = Math.max(0, Math.min(scrollLeftMax, $win.scrollLeft()));
       Parallax.overScroll = Math.max(winScrollTop - scrollTopMax, Math.min(winScrollTop, 0));
     };
</PRE><PRE>     $win.on('resize.px.parallax load.px.parallax', function() {
         loadDimensions();
         Parallax.isFresh = false;
         Parallax.requestRender();
       })
       .on('scroll.px.parallax load.px.parallax', function() {
         loadScrollPosition();
         Parallax.requestRender();
       });
</PRE><PRE>     loadDimensions();
     loadScrollPosition();
</PRE><PRE>     this.isReady = true;
   },
</PRE><PRE>   configure: function(options) {
     if (typeof options == 'object') {
       delete options.refresh;
       delete options.render;
       $.extend(this.prototype, options);
     }
   },
</PRE><PRE>   refresh: function() {
     $.each(this.sliders, function(){ this.refresh() });
     this.isFresh = true;
   },
</PRE><PRE>   render: function() {
     this.isFresh || this.refresh();
     $.each(this.sliders, function(){ this.render() });
   },
</PRE><PRE>   requestRender: function() {
     var self = this;
</PRE><PRE>     if (!this.isBusy) {
       this.isBusy = true;
       window.requestAnimationFrame(function() {
         self.render();
         self.isBusy = false;
       });
     }
   },
   destroy: function(el){
     var i,
         parallaxElement = $(el).data('px.parallax');
     parallaxElement.$mirror.remove();
     for(i=0; i &lt; this.sliders.length; i+=1){
       if(this.sliders[i] == parallaxElement){
         this.sliders.splice(i, 1);
       }
     }
     $(el).data('px.parallax', false);
     if(this.sliders.length === 0){
       $(window).off('scroll.px.parallax resize.px.parallax load.px.parallax');
       this.isReady = false;
       Parallax.isSetup = false;
     }
   }
 });
</PRE><PRE> // Parallax Plugin Definition
</PRE><PRE> function Plugin(option) {
   return this.each(function () {
     var $this = $(this);
     var options = typeof option == 'object' &amp;&amp; option;
</PRE><PRE>     if (this == window || this == document || $this.is('body')) {
       Parallax.configure(options);
     }
     else if (!$this.data('px.parallax')) {
       options = $.extend({}, $this.data(), options);
       $this.data('px.parallax', new Parallax(this, options));
     }
     else if (typeof option == 'object')
     {
       $.extend($this.data('px.parallax'), options);
     }
     if (typeof option == 'string') {
       if(option == 'destroy'){
           Parallax['destroy'](this);
       }else{
         Parallax[option]();
       }
     }
   })
 };
</PRE><PRE> var old = $.fn.parallax;
</PRE><PRE> $.fn.parallax             = Plugin;
 $.fn.parallax.Constructor = Parallax;
</PRE><PRE> // Parallax No Conflict
</PRE><PRE> $.fn.parallax.noConflict = function () {
   $.fn.parallax = old;
   return this;
 };
</PRE><PRE> // Parallax Data-API
</PRE><PRE> $(document).on('ready.px.parallax.data-api', function () {
   $('[data-parallax=&quot;scroll&quot;]').parallax();
 });
</PRE><P>}(jQuery, window, document));
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
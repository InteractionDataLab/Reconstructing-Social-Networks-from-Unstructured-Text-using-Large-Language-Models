<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_NAWI_Graz_Resources_netlogo_1 skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:NAWI Graz/Resources/netlogo 1</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><PRE>&lt;style&gt;/* BASICS */
</PRE><P>.CodeMirror {
</P><PRE> /* Set height, width, borders, and global font properties here */
 font-family: monospace;
 height: 300px;
 color: black;
</PRE><P>}
</P><P>/* PADDING */
</P><P>.CodeMirror-lines {
</P><PRE> padding: 4px 0; /* Vertical padding around content */
</PRE><P>}
.CodeMirror pre {
</P><PRE> padding: 0 4px; /* Horizontal padding of content */
</PRE><P>}
</P><P>.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
</P><PRE> background-color: white; /* The little square between H and V scrollbars */
</PRE><P>}
</P><P>/* GUTTER */
</P><P>.CodeMirror-gutters {
</P><PRE> border-right: 1px solid #ddd;
 background-color: #f7f7f7;
 white-space: nowrap;
</PRE><P>}
.CodeMirror-linenumbers {}
.CodeMirror-linenumber {
</P><PRE> padding: 0 3px 0 5px;
 min-width: 20px;
 text-align: right;
 color: #999;
 white-space: nowrap;
</PRE><P>}
</P><P>.CodeMirror-guttermarker { color: black; }
.CodeMirror-guttermarker-subtle { color: #999; }
</P><P>/* CURSOR */
</P><P>.CodeMirror-cursor {
</P><PRE> border-left: 1px solid black;
 border-right: none;
 width: 0;
</PRE><P>}
/* Shown when moving in bi-directional text */
.CodeMirror div.CodeMirror-secondarycursor {
</P><PRE> border-left: 1px solid silver;
</PRE><P>}
.cm-fat-cursor .CodeMirror-cursor {
</P><PRE> width: auto;
 border: 0 !important;
 background: #7e7;
</PRE><P>}
.cm-fat-cursor div.CodeMirror-cursors {
</P><PRE> z-index: 1;
</PRE><P>}
</P><P>.cm-animate-fat-cursor {
</P><PRE> width: auto;
 border: 0;
 -webkit-animation: blink 1.06s steps(1) infinite;
 -moz-animation: blink 1.06s steps(1) infinite;
 animation: blink 1.06s steps(1) infinite;
 background-color: #7e7;
</PRE><P>}
@-moz-keyframes blink {
</P><PRE> 0% {}
 50% { background-color: transparent; }
 100% {}
</PRE><P>}
@-webkit-keyframes blink {
</P><PRE> 0% {}
 50% { background-color: transparent; }
 100% {}
</PRE><P>}
@keyframes blink {
</P><PRE> 0% {}
 50% { background-color: transparent; }
 100% {}
</PRE><P>}
</P><P>/* Can style cursor different in overwrite (non-insert) mode */
.CodeMirror-overwrite .CodeMirror-cursor {}
</P><P>.cm-tab { display: inline-block; text-decoration: inherit; }
</P><P>.CodeMirror-rulers {
</P><PRE> position: absolute;
 left: 0; right: 0; top: -50px; bottom: -20px;
 overflow: hidden;
</PRE><P>}
.CodeMirror-ruler {
</P><PRE> border-left: 1px solid #ccc;
 top: 0; bottom: 0;
 position: absolute;
</PRE><P>}
</P><P>/* DEFAULT THEME */
</P><P>.cm-s-default .cm-header {color: blue;}
.cm-s-default .cm-quote {color: #090;}
.cm-negative {color: #d44;}
.cm-positive {color: #292;}
.cm-header, .cm-strong {font-weight: bold;}
.cm-em {font-style: italic;}
.cm-link {text-decoration: underline;}
.cm-strikethrough {text-decoration: line-through;}
</P><P>.cm-s-default .cm-keyword {color: #708;}
.cm-s-default .cm-atom {color: #219;}
.cm-s-default .cm-number {color: #164;}
.cm-s-default .cm-def {color: #00f;}
.cm-s-default .cm-variable,
.cm-s-default .cm-punctuation,
.cm-s-default .cm-property,
.cm-s-default .cm-operator {}
.cm-s-default .cm-variable-2 {color: #05a;}
.cm-s-default .cm-variable-3 {color: #085;}
.cm-s-default .cm-comment {color: #a50;}
.cm-s-default .cm-string {color: #a11;}
.cm-s-default .cm-string-2 {color: #f50;}
.cm-s-default .cm-meta {color: #555;}
.cm-s-default .cm-qualifier {color: #555;}
.cm-s-default .cm-builtin {color: #30a;}
.cm-s-default .cm-bracket {color: #997;}
.cm-s-default .cm-tag {color: #170;}
.cm-s-default .cm-attribute {color: #00c;}
.cm-s-default .cm-hr {color: #999;}
.cm-s-default .cm-link {color: #00c;}
</P><P>.cm-s-default .cm-error {color: #f00;}
.cm-invalidchar {color: #f00;}
</P><P>.CodeMirror-composing { border-bottom: 2px solid; }
</P><P>/* Default styles for common addons */
</P><P>div.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}
div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}
.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }
.CodeMirror-activeline-background {background: #e8f2ff;}
</P><P>/* STOP */
</P><P>/* The rest of this file contains styles related to the mechanics of
</P><PRE>  the editor. You probably shouldn't touch them. */
</PRE><P>.CodeMirror {
</P><PRE> position: relative;
 overflow: hidden;
 background: white;
</PRE><P>}
</P><P>.CodeMirror-scroll {
</P><PRE> overflow: scroll !important; /* Things will break if this is overridden */
 /* 30px is the magic margin used to hide the element's real scrollbars */
 /* See overflow: hidden in .CodeMirror */
 margin-bottom: -30px; margin-right: -30px;
 padding-bottom: 30px;
 height: 100%;
 outline: none; /* Prevent dragging from highlighting the element */
 position: relative;
</PRE><P>}
.CodeMirror-sizer {
</P><PRE> position: relative;
 border-right: 30px solid transparent;
</PRE><P>}
</P><P>/* The fake, visible scrollbars. Used to force redraw during scrolling
</P><PRE>  before actual scrolling happens, thus preventing shaking and
  flickering artifacts. */
</PRE><P>.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
</P><PRE> position: absolute;
 z-index: 6;
 display: none;
</PRE><P>}
.CodeMirror-vscrollbar {
</P><PRE> right: 0; top: 0;
 overflow-x: hidden;
 overflow-y: scroll;
</PRE><P>}
.CodeMirror-hscrollbar {
</P><PRE> bottom: 0; left: 0;
 overflow-y: hidden;
 overflow-x: scroll;
</PRE><P>}
.CodeMirror-scrollbar-filler {
</P><PRE> right: 0; bottom: 0;
</PRE><P>}
.CodeMirror-gutter-filler {
</P><PRE> left: 0; bottom: 0;
</PRE><P>}
</P><P>.CodeMirror-gutters {
</P><PRE> position: absolute; left: 0; top: 0;
 min-height: 100%;
 z-index: 3;
</PRE><P>}
.CodeMirror-gutter {
</P><PRE> white-space: normal;
 height: 100%;
 display: inline-block;
 vertical-align: top;
 margin-bottom: -30px;
</PRE><P>}
.CodeMirror-gutter-wrapper {
</P><PRE> position: absolute;
 z-index: 4;
 background: none !important;
 border: none !important;
</PRE><P>}
.CodeMirror-gutter-background {
</P><PRE> position: absolute;
 top: 0; bottom: 0;
 z-index: 4;
</PRE><P>}
.CodeMirror-gutter-elt {
</P><PRE> position: absolute;
 cursor: default;
 z-index: 4;
</PRE><P>}
.CodeMirror-gutter-wrapper {
</P><PRE> -webkit-user-select: none;
 -moz-user-select: none;
 user-select: none;
</PRE><P>}
</P><P>.CodeMirror-lines {
</P><PRE> cursor: text;
 min-height: 1px; /* prevents collapsing before first draw */
</PRE><P>}
.CodeMirror pre {
</P><PRE> /* Reset some styles that the rest of the page might have set */
 -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;
 border-width: 0;
 background: transparent;
 font-family: inherit;
 font-size: inherit;
 margin: 0;
 white-space: pre;
 word-wrap: normal;
 line-height: inherit;
 color: inherit;
 z-index: 2;
 position: relative;
 overflow: visible;
 -webkit-tap-highlight-color: transparent;
 -webkit-font-variant-ligatures: contextual;
 font-variant-ligatures: contextual;
</PRE><P>}
.CodeMirror-wrap pre {
</P><PRE> word-wrap: break-word;
 white-space: pre-wrap;
 word-break: normal;
</PRE><P>}
</P><P>.CodeMirror-linebackground {
</P><PRE> position: absolute;
 left: 0; right: 0; top: 0; bottom: 0;
 z-index: 0;
</PRE><P>}
</P><P>.CodeMirror-linewidget {
</P><PRE> position: relative;
 z-index: 2;
 overflow: auto;
</PRE><P>}
</P><P>.CodeMirror-widget {}
</P><P>.CodeMirror-code {
</P><PRE> outline: none;
</PRE><P>}
</P><P>/* Force content-box sizing for the elements where we expect it */
.CodeMirror-scroll,
.CodeMirror-sizer,
.CodeMirror-gutter,
.CodeMirror-gutters,
.CodeMirror-linenumber {
</P><PRE> -moz-box-sizing: content-box;
 box-sizing: content-box;
</PRE><P>}
</P><P>.CodeMirror-measure {
</P><PRE> position: absolute;
 width: 100%;
 height: 0;
 overflow: hidden;
 visibility: hidden;
</PRE><P>}
</P><P>.CodeMirror-cursor {
</P><PRE> position: absolute;
 pointer-events: none;
</PRE><P>}
.CodeMirror-measure pre { position: static; }
</P><P>div.CodeMirror-cursors {
</P><PRE> visibility: hidden;
 position: relative;
 z-index: 3;
</PRE><P>}
div.CodeMirror-dragcursors {
</P><PRE> visibility: visible;
</PRE><P>}
</P><P>.CodeMirror-focused div.CodeMirror-cursors {
</P><PRE> visibility: visible;
</PRE><P>}
</P><P>.CodeMirror-selected { background: #d9d9d9; }
.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }
.CodeMirror-crosshair { cursor: crosshair; }
.CodeMirror-line::selection, .CodeMirror-line &gt; span::selection, .CodeMirror-line &gt; span &gt; span::selection { background: #d7d4f0; }
.CodeMirror-line::-moz-selection, .CodeMirror-line &gt; span::-moz-selection, .CodeMirror-line &gt; span &gt; span::-moz-selection { background: #d7d4f0; }
</P><P>.cm-searching {
</P><PRE> background: #ffa;
 background: rgba(255, 255, 0, .4);
</PRE><P>}
</P><P>/* Used to force a border model for a node */
.cm-force-border { padding-right: .1px; }
</P><P>@media print {
</P><PRE> /* Hide the cursor when printing */
 .CodeMirror div.CodeMirror-cursors {
   visibility: hidden;
 }
</PRE><P>}
</P><P>/* See issue #2901 */
.cm-tab-wrap-hack:after { content: <I>; }</I></P><P>/* Help users use markselection to safely style text background */
span.CodeMirror-selectedtext { background: none; }
&lt;/style&gt;</P><PRE>&lt;style&gt;.CodeMirror-dialog {
 position: absolute;
 left: 0; right: 0;
 background: inherit;
 z-index: 15;
 padding: .1em .8em;
 overflow: hidden;
 color: inherit;
</PRE><P>}
</P><P>.CodeMirror-dialog-top {
</P><PRE> border-bottom: 1px solid #eee;
 top: 0;
</PRE><P>}
</P><P>.CodeMirror-dialog-bottom {
</P><PRE> border-top: 1px solid #eee;
 bottom: 0;
</PRE><P>}
</P><P>.CodeMirror-dialog input {
</P><PRE> border: none;
 outline: none;
 background: transparent;
 width: 20em;
 color: inherit;
 font-family: monospace;
</PRE><P>}
</P><P>.CodeMirror-dialog button {
</P><PRE> font-size: 70%;
</PRE><P>}
&lt;/style&gt;</P><PRE>&lt;style&gt;/*
* This file should contain generally useful css classes - &quot;round the corners&quot;, &quot;add the font&quot;, etc.
* Where possible, css for certain elements should be moved out, although there are clearly some exceptions.
*/
</PRE><P>.hidden {
</P><PRE> display: none;
</PRE><P>}
</P><P>.rounded {
</P><PRE> border-radius: 10px;
</PRE><P>}
</P><P>.contained {
</P><PRE> height: 92%;
 min-height: 92%;
</PRE><P>}
</P><P>.normal_font {
</P><PRE> font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
</PRE><P>}
</P><P>.monospace_font {
</P><PRE> font-family: &quot;Courier New&quot;, Courier, monospace;
</PRE><P>}
</P><P>.invisible {
</P><PRE> opacity:0;
 width: 0;
 z-index: -1;
</PRE><P>}
</P><P>.text_input_margin {
</P><PRE> margin-top: 10px;
 margin-right: 15px;
</PRE><P>}
</P><P>.center {
</P><PRE> display: block;
 margin: auto;
</PRE><P>}
</P><P>.spacious-entry {
</P><PRE> padding: 8px 8px;
</PRE><P>}
</P><P>.index-button {
</P><PRE> margin: 2%;
 border: 2px solid #347999;
 border-radius: 6px;
 background-color: #DDF4FB;
 transition: background-color 0.25s;
 text-align: center;
</PRE><P>}
</P><P>.index-button:hover {
</P><PRE> background-color: #E8FFFF;
</PRE><P>}
</P><P>.index-button &gt; h2 {
</P><PRE> margin-top: 3%;
 margin-bottom: 0;
</PRE><P>}
</P><P>.icon-button {
</P><PRE> display: block;
 width: 100%;
 height: auto;
 max-width: 256px;
 max-height: 256px;
 margin: auto;
</PRE><P>}
</P><P>.index-link {
</P><PRE> max-width: 300px;
 min-width: 200px;
 text-decoration: none !important;
 color: inherit;
</PRE><P>}
</P><P>.index-link:hover {
</P><PRE> text-decoration: none;
 color: inherit;
</PRE><P>}
</P><P>.properties-list {
</P><PRE> margin-left: 0;
 padding-left: 0;
 list-style: none;
 margin-bottom: 0;
</PRE><P>}
</P><P>.properties-list &gt; li {
</P><PRE> margin: auto;
 padding-left: 0;
 padding-top: 10px;
 padding-bottom: 10px;
 border-top: 1px solid #5499B9;
</PRE><P>}
</P><P>.server-error {
</P><PRE> margin-top: 20px;
 font-size: 20px;
 line-height: 25px;
 text-align: center;
</PRE><P>}
</P><P>div.link-header {
</P><PRE> margin-left: -27px;
 margin-bottom: 20px;
 display: -ms-flexbox;
 display: flex;
 -ms-flex-direction: row;
     flex-direction: row;
 -ms-flex-align: center;
     align-items: center;
</PRE><P>}
</P><P>.anchor-header {
</P><PRE> visibility: hidden;
 display: block;
 margin-top: -20px;
 padding-bottom: 20px;
</PRE><P>}
</P><P>.anchor-header:target {
</P><PRE> margin-top: -40px;
 padding-bottom: 40px;
</PRE><P>}
</P><P>div.link-header:hover &gt; a &gt; img.link-img {
</P><PRE> visibility: visible;
</PRE><P>}
</P><P>div.link-header &gt; h2 {
</P><PRE> margin-top: 0;
 margin-bottom: 0;
</PRE><P>}
</P><P>img.link-img {
</P><PRE> top: 50%;
 max-width: 20px;
 visibility: hidden;
</PRE><P>}
</P><P>/*
</P><PRE>Flexbox stuff
</PRE><PRE>Much of this could be inlined in styles, but we do this to allow the autoprefixer access to it --JAB 3/30/15
</PRE><PRE>*/
</PRE><P>.dynamic-row {
</P><PRE> -ms-flex-align: center;
     align-items: center;
 display: -ms-flexbox;
 display: flex;
 -ms-flex-wrap: wrap;
     flex-wrap: wrap;
 -ms-flex-pack: justify;
     justify-content: space-between;
</PRE><P>}
</P><P>.dynamic-column-holder {
</P><PRE> -ms-flex-align: center;
     align-items: center;
 display: -ms-flexbox;
 display: flex;
 -ms-flex-wrap: wrap;
     flex-wrap: wrap;
 -ms-flex-pack: distribute;
     justify-content: space-around;
</PRE><P>}
</P><P>.flex1 {
</P><PRE> -ms-flex: 1;
     flex: 1;
</PRE><P>}
</P><P>.flex2 {
</P><PRE> -ms-flex: 2;
     flex: 2;
</PRE><P>}
</P><P>.flex3 {
</P><PRE> -ms-flex: 3;
     flex: 3;
</PRE><P>}
</P><P>.flex-column {
</P><PRE> display: -ms-flexbox;
 display: flex;
 -ms-flex-direction: column;
     flex-direction: column;
</PRE><P>}
</P><P>.flex-row {
</P><PRE> display: -ms-flexbox;
 display: flex;
 -ms-flex-direction: row;
     flex-direction: row;
</PRE><P>}
&lt;/style&gt;</P><PRE>&lt;style&gt;/*
* General-purpose widget styles, applied regardless of what the widget &quot;theme&quot; is
*/
</PRE><P>.netlogo-model {
</P><PRE>   display: -ms-flexbox;
   display: flex;
   padding: 20px;
   -ms-flex-flow: column;
       flex-flow: column;
   font-size: 12px;
   font-family: &quot;Lucida Grande&quot;, sans-serif;
   outline: none;
</PRE><P>}
</P><P>.netlogo-header {
</P><PRE>   display: -ms-flexbox;
   display: flex;
   -ms-flex-flow: row;
       flex-flow: row;
   -ms-flex-align: center;
       align-items: center;
   -ms-flex-pack: justify;
       justify-content: space-between;
</PRE><P>}
</P><P>.netlogo-widget {
</P><PRE>   box-sizing: border-box;
   background-color: #CCC;
   border-radius: 4px;
   overflow: hidden;
</PRE><P>}
</P><P>.netlogo-command,.netlogo-input {
</P><PRE>   -webkit-user-select: none;
      -moz-user-select: none;
       -ms-user-select: none;
           user-select: none;
</PRE><P>}
</P><P>.netlogo-command:hover,.netlogo-input:hover {
</P><PRE> box-shadow: 0 0 6px 3px rgba(15, 15, 15, .40);
 cursor:     pointer;
 z-index:    3;
</PRE><P>}
</P><P>.netlogo-command.netlogo-disabled:hover {
</P><PRE> box-shadow: none;
 cursor:     default;
</PRE><P>}
</P><P>.netlogo-tab-area {
</P><PRE> margin-top: 25px;
</PRE><P>}
</P><P>.netlogo-tab {
</P><PRE> display: block;
 background-color: #BCBCE5;
 background-image: url(&quot;data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyIDEiPjxwb2x5Z29uIHBvaW50cz0iMCwwIDIsMCAxLDEiIGZpbGw9InJnYig4Myw4Myw4MykiLz4gPC9zdmc+&quot;);
 background-position: 97% 50%;
 background-repeat: no-repeat;
 background-size: 20px 20px;
 border-width: 2px;
 border-bottom-width: 0;
 border-style: solid;
 padding: 7px;
 text-align: center;
 cursor: pointer;
</PRE><P>}
</P><P>.netlogo-tab.netlogo-active {
</P><PRE> background-image: url(&quot;data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyIDEiPjxwb2x5Z29uIHBvaW50cz0iMCwxIDIsMSAxLDAiIGZpbGw9InJnYig4Myw4Myw4MykiLz4gPC9zdmc+&quot;);
</PRE><P>}
</P><P>.netlogo-tab:first-child {
</P><PRE> border-radius: 10px 10px 0px 0px;
</PRE><P>}
</P><P>.netlogo-tab:last-child, .netlogo-tab-content:last-child {
</P><PRE> border-radius: 0px 0px 10px 10px;
 border-bottom-width: 2px;
</PRE><P>}
</P><P>.netlogo-tab:hover  {
</P><PRE> background-color: #D3D3EE;
</PRE><P>}
</P><P>.netlogo-tab.netlogo-active:hover  {
</P><PRE> background-color: #9E99FD;
</PRE><P>}
</P><P>.netlogo-tab input[type=checkbox] {
</P><PRE> display: none;
</PRE><P>}
</P><P>.netlogo-tab-text {
</P><PRE> font-size: 20px;
 font-weight: bold;
 text-align: center;
 -webkit-user-select: none;
    -moz-user-select: none;
     -ms-user-select: none;
         user-select: none;
</PRE><P>}
</P><P>.netlogo-tab-content {
</P><PRE> margin-top: 0;
 border: 0 solid #242479;
 border-left-width: 2px;
 border-right-width: 2px;
</PRE><P>}
</P><P>.unselectable {
</P><PRE> -webkit-user-select: none;
    -moz-user-select: none;
     -ms-user-select: none;
         user-select: none;
</PRE><P>}
</P><P>.growing {
</P><PRE> animation-name: grow;
 animation-duration: 0.4s;
 animation-timing-function: ease-out;
</PRE><P>}
</P><P>.shrinking {
</P><PRE> animation-name: grow;
 animation-direction: reverse;
 animation-duration: 0.4s;
 animation-timing-function: ease-in;
</PRE><P>}
</P><P>@keyframes grow {
</P><PRE> 0% {
   max-height: 0;
 }
 100% {
   max-height: 100%;
 }
</PRE><P>}
</P><P>.netlogo-model-text {
</P><PRE>   background-color: white;
</PRE><P>}
</P><P>.netlogo-model-masthead {
</P><PRE> -ms-flex-positive: 1;
     flex-grow: 1;
 margin: 0 10px 0 0;
 width: 350px;
</PRE><P>}
</P><P>.netlogo-model-masthead &gt; form {
</P><PRE> margin: 0 auto;
</PRE><P>}
</P><P>.netlogo-model-title {
</P><PRE> background-color: initial;
 margin: 0 70px;
 overflow: hidden;
 padding: 0 8px;
 text-align: center;
 text-overflow: ellipsis;
 white-space: nowrap;
</PRE><P>}
</P><P>.hidden {
</P><PRE> visibility: hidden;
</PRE><P>}
</P><P>.netlogo-title-input {
</P><PRE> font-size: 1.5em;
 font-weight: bold;
 letter-spacing: normal;
 margin: 0 5%;
 text-align: center;
 width: 350px;
</PRE><P>}
</P><P>.netlogo-code-container {
</P><PRE>   display: -ms-flexbox;
   display: flex;
   -ms-flex-flow: column;
       flex-flow: column;
   background-color: white;
   margin-top: 0;
</PRE><P>}
</P><P>.netlogo-ugly-button {
</P><PRE> text-align: center;
 background-color: rgb(240, 240, 240);
 border-color: rgb(238, 238, 238);
</PRE><P>}
</P><P>.netlogo-recompilation-button {
</P><PRE> width: 30%;
 margin: 12px auto;
 font-size: 16px;
 font-weight: bold;
 cursor: pointer;
</PRE><P>}
</P><P>.netlogo-info-editor {
</P><PRE> border: 1px solid black;
 height: 500px;
</PRE><P>}
</P><P>.netlogo-toggle-edit-mode {
</P><PRE> display: block;
 margin: 0;
 margin-bottom: 10px;
</PRE><P>}
</P><P>.netlogo-info {
</P><PRE> -ms-flex: 1;
     flex: 1;
 margin-top: 0;
 padding-top: 10px;
 padding: 15px;
</PRE><P>}
</P><P>.netlogo-command-center {
</P><PRE> -ms-flex: 1;
     flex: 1;
 display: -ms-flexbox;
 display: flex;
 -ms-flex-direction: column;
     flex-direction: column;
 height: 175px;
 padding: 6px 8px;
</PRE><P>}
</P><P>.netlogo-command-center-editor {
</P><PRE> height: 1.25em;
 -ms-flex-positive: 1;
     flex-grow: 1;
</PRE><P>}
</P><P>.netlogo-command-center-editor .CodeMirror {
</P><PRE> border: 1px solid #eee;
 height: auto;
</PRE><P>}
</P><P>.netlogo-output-widget {
</P><PRE> display: -ms-flexbox;
 display: flex;
 padding: 5px;
</PRE><P>}
</P><P>.netlogo-output-area {
</P><PRE> -ms-flex-positive: 1;
     flex-grow: 1;
 -ms-flex-direction: column;
     flex-direction: column;
 background-color: white;
 margin: 0px;
 overflow: auto;
</PRE><P>}
</P><P>.netlogo-command-center-input {
</P><PRE> display: -ms-flexbox;
 display: flex;
 -ms-flex-negative: 0;
     flex-shrink: 0;
</PRE><P>}
</P><P>.netlogo-speed-slider {
</P><PRE> background-color: transparent;
 border: none;
 display: -ms-flexbox;
 display: flex;
 -ms-flex-direction: column;
     flex-direction: column;
 margin: 15px auto 0 auto;
 width: 75%;
</PRE><P>}
</P><P>.netlogo-widget input[type=range]::-ms-tooltip {
</P><PRE> display: none;
</PRE><P>}
</P><P>.netlogo-speed-slider input {
</P><PRE> border: none;
 width: 100%;
</PRE><P>}
</P><P>.netlogo-model input[type=range] {
</P><PRE>   cursor: pointer;
   cursor: -webkit-grab;
   cursor: grab;
</PRE><P>}
</P><P>.netlogo-model input[type=range]:active {
</P><PRE>   cursor: pointer;
   cursor: -webkit-grabbing;
   cursor: grabbing;
</PRE><P>}
</P><P>.netlogo-tick-counter {
</P><PRE>   background-color: #F4F4F4;
   font-size: 13px;
   margin: 3px;
   border: none;
   height: 15px;
</PRE><P>}
</P><P>.netlogo-button {
</P><PRE>   border: inherit;
   display: -ms-flexbox;
   display: flex;
   -ms-flex-pack: distribute;
       justify-content: space-around;
   -ms-flex-align: center;
       align-items: center;
   padding: 0px;
</PRE><P>}
</P><P>.netlogo-disabled {
</P><PRE> color: grey;
</PRE><P>}
</P><P>.netlogo-button.clear-button {
</P><PRE>   padding: 5px;
</PRE><P>}
</P><P>.netlogo-button .netlogo-label {
</P><PRE>   /* For some reason, Safari doesn't like justify-content in buttons,
      we have to resort to putting a span in the button that can then be
      centered.
      BCH 11/14/2014 */
   margin: auto;
</PRE><P>}
</P><P>.netlogo-action-key {
</P><PRE> color:    grey;
 position: absolute;
 right:    6px;
 top:      5px;
</PRE><P>}
</P><P>.netlogo-action-key.netlogo-focus {
</P><PRE> color: black;
</PRE><P>}
</P><P>.netlogo-button:active, .netlogo-forever-button.netlogo-active {
</P><PRE>   background-color: gray;
   color: white;
</PRE><P>}
</P><P>.netlogo-forever-button .netlogo-forever-icon {
</P><PRE> background-image:  url(data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDQzOC41NDIgNDM4LjU0MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDM4LjU0MiA0MzguNTQyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnPgoJPHBhdGggZD0iTTQyNy40MDgsMTkuNjk3Yy03LjgwMy0zLjIzLTE0LjQ2My0xLjkwMi0xOS45ODYsMy45OTlsLTM3LjExNiwzNi44MzRDMzQ5Ljk0LDQxLjMwNSwzMjYuNjcyLDI2LjQxMiwzMDAuNSwxNS44NDggICBDMjc0LjMyOCw1LjI4NSwyNDcuMjUxLDAuMDAzLDIxOS4yNzEsMC4wMDNjLTI5LjY5MiwwLTU4LjA1Miw1LjgwOC04NS4wOCwxNy40MTdjLTI3LjAzLDExLjYxLTUwLjM0NywyNy4yMTUtNjkuOTUxLDQ2LjgyICAgYy0xOS42MDUsMTkuNjA3LTM1LjIxNCw0Mi45MjEtNDYuODI0LDY5Ljk0OUM1LjgwNywxNjEuMjE5LDAsMTg5LjU3NSwwLDIxOS4yNzFjMCwyOS42ODcsNS44MDcsNTguMDUsMTcuNDE3LDg1LjA3OSAgIGMxMS42MTMsMjcuMDMxLDI3LjIxOCw1MC4zNDcsNDYuODI0LDY5Ljk1MmMxOS42MDQsMTkuNTk5LDQyLjkyMSwzNS4yMDcsNjkuOTUxLDQ2LjgxOGMyNy4wMjgsMTEuNjExLDU1LjM4OCwxNy40MTksODUuMDgsMTcuNDE5ICAgYzMyLjczNiwwLDYzLjg2NS02Ljg5OSw5My4zNjMtMjAuN2MyOS41LTEzLjc5NSw1NC42MjUtMzMuMjYsNzUuMzc3LTU4LjM4NmMxLjUyLTEuOTAzLDIuMjM0LTQuMDQ1LDIuMTM2LTYuNDI0ICAgYy0wLjA4OS0yLjM3OC0wLjk5OS00LjMyOS0yLjcxMS01Ljg1MmwtMzkuMTA4LTM5LjM5OWMtMi4xMDEtMS43MTEtNC40NzMtMi41NjYtNy4xMzktMi41NjZjLTMuMDQ1LDAuMzgtNS4yMzIsMS41MjYtNi41NjYsMy40MjkgICBjLTEzLjg5NSwxOC4wODYtMzAuOTMsMzIuMDcyLTUxLjEwNyw0MS45NzdjLTIwLjE3Myw5Ljg5NC00MS41ODYsMTQuODM5LTY0LjIzNywxNC44MzljLTE5Ljc5MiwwLTM4LjY4NC0zLjg1NC01Ni42NzEtMTEuNTY0ICAgYy0xNy45ODktNy43MDYtMzMuNTUxLTE4LjEyNy00Ni42ODItMzEuMjYxYy0xMy4xMy0xMy4xMzUtMjMuNTUxLTI4LjY5MS0zMS4yNjEtNDYuNjgyYy03LjcwOC0xNy45ODctMTEuNTYzLTM2Ljg3NC0xMS41NjMtNTYuNjcxICAgYzAtMTkuNzk1LDMuODU4LTM4LjY5MSwxMS41NjMtNTYuNjc0YzcuNzA3LTE3Ljk4NSwxOC4xMjctMzMuNTQ3LDMxLjI2MS00Ni42NzhjMTMuMTM1LTEzLjEzNCwyOC42OTMtMjMuNTU1LDQ2LjY4Mi0zMS4yNjUgICBjMTcuOTgzLTcuNzA3LDM2Ljg3OS0xMS41NjMsNTYuNjcxLTExLjU2M2MzOC4yNTksMCw3MS40NzUsMTMuMDM5LDk5LjY0NiwzOS4xMTZsLTM5LjQwOSwzOS4zOTQgICBjLTUuOTAzLDUuNzExLTcuMjMxLDEyLjI3OS00LjAwMSwxOS43MDFjMy4yNDEsNy42MTQsOC44NTYsMTEuNDIsMTYuODU0LDExLjQyaDEyNy45MDZjNC45NDksMCw5LjIzLTEuODA3LDEyLjg0OC01LjQyNCAgIGMzLjYxMy0zLjYxNiw1LjQyLTcuODk4LDUuNDItMTIuODQ3VjM2LjU1QzQzOC41NDIsMjguNTU4LDQzNC44NCwyMi45NDMsNDI3LjQwOCwxOS42OTd6IiBmaWxsPSIjMDAwMDAwIi8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg==);
 background-repeat: no-repeat;
 background-size:   10px 10px;
 bottom:            5px;
 height:            10px;
 position:          absolute;
 right:             5px;
 width:             10px;
</PRE><P>}
</P><P>.netlogo-disabled .netlogo-forever-icon {
</P><PRE> background-image: url(data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDQzOC41NDIgNDM4LjU0MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDM4LjU0MiA0MzguNTQyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnPgoJPHBhdGggZD0iTTQyNy40MDgsMTkuNjk3Yy03LjgwMy0zLjIzLTE0LjQ2My0xLjkwMi0xOS45ODYsMy45OTlsLTM3LjExNiwzNi44MzRDMzQ5Ljk0LDQxLjMwNSwzMjYuNjcyLDI2LjQxMiwzMDAuNSwxNS44NDggICBDMjc0LjMyOCw1LjI4NSwyNDcuMjUxLDAuMDAzLDIxOS4yNzEsMC4wMDNjLTI5LjY5MiwwLTU4LjA1Miw1LjgwOC04NS4wOCwxNy40MTdjLTI3LjAzLDExLjYxLTUwLjM0NywyNy4yMTUtNjkuOTUxLDQ2LjgyICAgYy0xOS42MDUsMTkuNjA3LTM1LjIxNCw0Mi45MjEtNDYuODI0LDY5Ljk0OUM1LjgwNywxNjEuMjE5LDAsMTg5LjU3NSwwLDIxOS4yNzFjMCwyOS42ODcsNS44MDcsNTguMDUsMTcuNDE3LDg1LjA3OSAgIGMxMS42MTMsMjcuMDMxLDI3LjIxOCw1MC4zNDcsNDYuODI0LDY5Ljk1MmMxOS42MDQsMTkuNTk5LDQyLjkyMSwzNS4yMDcsNjkuOTUxLDQ2LjgxOGMyNy4wMjgsMTEuNjExLDU1LjM4OCwxNy40MTksODUuMDgsMTcuNDE5ICAgYzMyLjczNiwwLDYzLjg2NS02Ljg5OSw5My4zNjMtMjAuN2MyOS41LTEzLjc5NSw1NC42MjUtMzMuMjYsNzUuMzc3LTU4LjM4NmMxLjUyLTEuOTAzLDIuMjM0LTQuMDQ1LDIuMTM2LTYuNDI0ICAgYy0wLjA4OS0yLjM3OC0wLjk5OS00LjMyOS0yLjcxMS01Ljg1MmwtMzkuMTA4LTM5LjM5OWMtMi4xMDEtMS43MTEtNC40NzMtMi41NjYtNy4xMzktMi41NjZjLTMuMDQ1LDAuMzgtNS4yMzIsMS41MjYtNi41NjYsMy40MjkgICBjLTEzLjg5NSwxOC4wODYtMzAuOTMsMzIuMDcyLTUxLjEwNyw0MS45NzdjLTIwLjE3Myw5Ljg5NC00MS41ODYsMTQuODM5LTY0LjIzNywxNC44MzljLTE5Ljc5MiwwLTM4LjY4NC0zLjg1NC01Ni42NzEtMTEuNTY0ICAgYy0xNy45ODktNy43MDYtMzMuNTUxLTE4LjEyNy00Ni42ODItMzEuMjYxYy0xMy4xMy0xMy4xMzUtMjMuNTUxLTI4LjY5MS0zMS4yNjEtNDYuNjgyYy03LjcwOC0xNy45ODctMTEuNTYzLTM2Ljg3NC0xMS41NjMtNTYuNjcxICAgYzAtMTkuNzk1LDMuODU4LTM4LjY5MSwxMS41NjMtNTYuNjc0YzcuNzA3LTE3Ljk4NSwxOC4xMjctMzMuNTQ3LDMxLjI2MS00Ni42NzhjMTMuMTM1LTEzLjEzNCwyOC42OTMtMjMuNTU1LDQ2LjY4Mi0zMS4yNjUgICBjMTcuOTgzLTcuNzA3LDM2Ljg3OS0xMS41NjMsNTYuNjcxLTExLjU2M2MzOC4yNTksMCw3MS40NzUsMTMuMDM5LDk5LjY0NiwzOS4xMTZsLTM5LjQwOSwzOS4zOTQgICBjLTUuOTAzLDUuNzExLTcuMjMxLDEyLjI3OS00LjAwMSwxOS43MDFjMy4yNDEsNy42MTQsOC44NTYsMTEuNDIsMTYuODU0LDExLjQyaDEyNy45MDZjNC45NDksMCw5LjIzLTEuODA3LDEyLjg0OC01LjQyNCAgIGMzLjYxMy0zLjYxNiw1LjQyLTcuODk4LDUuNDItMTIuODQ3VjM2LjU1QzQzOC41NDIsMjguNTU4LDQzNC44NCwyMi45NDMsNDI3LjQwOCwxOS42OTd6IiBmaWxsPSIjODA4MDgwIi8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg==);
</PRE><P>}
</P><P>.netlogo-button-agent-context {
</P><PRE> font-size: 11px;
 left:      8px;
 position:  absolute;
 top:       5px;
</PRE><P>}
</P><P>.netlogo-disabled .netlogo-button-agent-content {
</P><PRE> color: #808080;
</PRE><P>}
</P><P>.netlogo-text-box {
</P><PRE>   background-color: white;
   border: none;
   margin: 0;
   white-space: pre-wrap;
   font-family: &quot;Lucida Grande&quot;, sans-serif;
</PRE><P>}
</P><P>.netlogo-switcher {
</P><PRE>   display: -ms-flexbox;
   display: flex;
   -ms-flex-align: center;
       align-items: center;
</PRE><P>}
</P><P>.netlogo-slider {
</P><PRE>   padding-left: 3px;
   padding-right: 3px;
</PRE><P>}
</P><P>.netlogo-slider:hover {
</P><PRE>   cursor: default;
</PRE><P>}
</P><P>.netlogo-slider input[type=range] {
</P><PRE> background-color: transparent;
 height: 22px;
 margin: 0px;
 margin-bottom: -5px;
 margin-top: 2px;
 padding: 0px;
 width: 100%;
</PRE><P>}
</P><P>.netlogo-label {
</P><PRE> margin: 0 auto;
 overflow: hidden;
 text-overflow: ellipsis;
 white-space: nowrap;
</PRE><P>}
</P><P>.netlogo-slider-label {
</P><PRE> display: -ms-flexbox;
 display: flex;
 -ms-flex-pack: justify;
     justify-content: space-between;
</PRE><P>}
</P><P>.netlogo-slider-label .netlogo-label {
</P><PRE> -ms-flex: 1 1 auto;
     flex: 1 1 auto;
 min-width: 0;
</PRE><P>}
</P><P>.netlogo-slider-label .netlogo-slider-value {
</P><PRE> -ms-flex: 0 0 auto;
     flex: 0 0 auto;
</PRE><P>}
</P><P>.netlogo-slider-label input[type=number] {
</P><PRE>   margin: 0px;
   border: 1px;
   padding: 0px;
</PRE><P>}
</P><P>.netlogo-monitor {
</P><PRE>   padding: 2px 4px;
   display: -ms-flexbox;
   display: flex;
   -ms-flex-flow: column;
       flex-flow: column;
   -ms-flex-pack: distribute;
       justify-content: space-around;
</PRE><P>}
</P><P>.netlogo-monitor &gt; .netlogo-value {
</P><PRE> background-color: white;
 min-height: 11px;
 padding: 2px 2px;
</PRE><P>}
</P><P>.netlogo-value {
</P><PRE>   overflow: hidden;
</PRE><P>}
</P><P>.netlogo-code {
</P><PRE> border: 1px solid black;
</PRE><P>}
</P><P>.netlogo-code-tab {
</P><PRE> height: 500px;
</PRE><P>}
</P><P>.netlogo-input-box {
</P><PRE>   padding: 2px 4px;
   display: -ms-flexbox;
   display: flex;
   -ms-flex-flow: column;
       flex-flow: column;
   -ms-flex-pack: distribute;
       justify-content: space-around;
</PRE><P>}
</P><P>.netlogo-multiline-input {
</P><PRE> -ms-flex-positive: 1;
     flex-grow: 1;
 margin:    4px;
 resize:    none;
</PRE><P>}
</P><P>.netlogo-chooser {
</P><PRE>   padding: 2px 4px;
   display: -ms-flexbox;
   display: flex;
   -ms-flex-flow: column;
       flex-flow: column;
   -ms-flex-pack: distribute;
       justify-content: space-around;
</PRE><P>}
</P><P>.netlogo-plot {
</P><PRE>   box-sizing: content-box; /* otherwise border gets cut off -- BCH 11/9/2014 */
   border: 1px solid black;
</PRE><P>}
</P><P>.netlogo-forever-button &gt; input {
</P><PRE>   display: none;
</PRE><P>}
</P><P>.netlogo-subheader {
</P><PRE> -ms-flex-align: center;
     align-items: center;
 display: -ms-flexbox;
 display: flex;
 -ms-flex-flow: column;
     flex-flow: column;
 -ms-flex-positive: 0;
     flex-grow: 0;
 white-space: nowrap;
</PRE><P>}
</P><P>.netlogo-export-wrapper {
</P><PRE> -ms-flex-align: center;
     align-items: center;
 display: -ms-flexbox;
 display: flex;
 -ms-flex-positive: 0;
     flex-grow: 0;
 white-space: nowrap;
</PRE><P>}
</P><P>.netlogo-widget-error {
</P><PRE> color: red;
</PRE><P>}
</P><P>.netlogo-widget-error:hover {
</P><PRE> cursor: pointer;
</PRE><P>}
</P><P>.CodeMirror {
</P><PRE> height: auto;
</PRE><P>}
&lt;/style&gt;</P><PRE>&lt;style&gt;/*
* Style for things relevant to the widget/interface editor
*/
</PRE><P>.netlogo-interface-unlocker {
</P><PRE> height: 20px;
 margin: auto 0;
 outline: none;
 width: 20px;
 background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAADu0lEQVR4Xu1b0VHcMBDddQMhFeRSQUgFOTo4KgiW+A+pAKgg8I+sUAGXCnJXQUgFuXRAGvBmlhGZA05aS9YZz0WaYRjGsqx92n270hMIAzVr7T4AfGjbdoqIEwDgv9fbLRGtqqpaAMCyruvbIaaG2/yItXYPAD4R0REAsNExbYWIXwHgsq7ru5gXY/puDQBr7SkRnQAAg9Cn3SHiRV3X530G8b2bHQB2dSK6SVhxyT72iMPcoZEVAGPMESJayZI+z4mo1lpzaGRp2QBwLn+WZVbCIIh4lisksgAwxMo/xSSXJ/QG4OrqalZVFcd8p0ZEvxFxTkTM7Cv+jYj7iLhHRDNEfNNpIABo2/bw+Ph43rX/pn69AOA0R0S/OjL9EhFPJBJzJHrBNUMHwxi8t33SZC8AjDE3iDgLTZSI/lRVNavrmguczs1aO23bdo6Ir4Tx51rrw84DP+mYDABPkIi+C5P7WVXVNHWF2MPatl0g4rvQdxDxIBbgh/GSAWiaho2f+iZGRL2Mfxi3IwgLpdRBihckAWCtnbjY3/hN5/a88lnqeeYF5wnecHBcsIoFIQkAY8wJIn4JrP651jprTWCMOUPE08A3P2utmTyjWhIATdMwoW1kabf6k9S4983ehQKXwz4vWCqlvCHpGzcVAArAfK2U4t1f9tY0DZfAH30DK6Wi7Yl+weXpH75J5ChOfGNLRRcivo/lnRQAgukPEV/ndv+1jBAk35R0mB2AFDeMiZWmabzhNwgAUgZ4SQCIKDoTRHuAlI5eGIDo9FsAiIk/7ls8QKjISggkFCMxXhjKAkRUOCB2D1JIMMb9/ksSdCe+6xsQlrhCMlfU0VfsAoQOYfiQ1f3cD0tE15KGIIaAlPYSDBjslS6kWACQlqN4gFD4SAC+5PMSAh0Ko8IBkosWDtgeB1wS0b1uwOIoX6WRFiP2+Sg5gNVhpxU+Ek2c+MFaYGd1WAJklACEzu266I2S0evPRwcA64Va66fX4x7ZZIxh8SOLF4wOAAD4ppQKyukh1Slm9d1eQDwfGDoNivLVrgPAjO8VTiTVeRc8gLeo3hsd0p2DnQDAGfFMQJWEz1jjx8oBDwcVz8hpGxXnGLNAAYAR2CShS9L3ToXApmowdxU4ag7YdJFBunixUx7gk89Cqk8BIAGBUWaB0IbIGHMr3QqNwWGUAPA/RPmus+XcB4yZBPmavO8GKW+V+/6P0T8nGasHxHhxr74FgHIsLl+YGPpApJdLx75cQqCEQAmB0R2KxoZxr/6FAzpwwF8eSx5uwugU8AAAAABJRU5ErkJggg==');
 background-size: contain;
</PRE><P>}
</P><P>.netlogo-interface-unlocker:hover {
</P><PRE> background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAADQElEQVR4Xu2a8bFNMRDGv1cBKuBVgArQARWgAlSAClABKkAFngpQATqgAubn5c7cuXOym01yzsu7k515f7y5e5Lsl91vN9mcaDu5JemOpLuSbkji/335JumnpDNJXyTx/+pysvIMVyU9kfQoGR2ZDjDeSXoj6Xfkw4jumgA8l/RUEiC0CMa/lvSyZZDct2sAgGt/qNhxzz484kHv0OgNAK7+1rOk8ffHKTQahzn/vCcAuPyLLqvyB2GeLiHRC4Atdv4Qli6e0AOA+ynm/X071/gl6WNiduIakoM3IEvGul46UOIExqqWVgBY9I9Cpie3kxW8/A4YsD41gyeAd9qSJlsBgO3ZNUv+JB0KnIhQMLG7V5yP0CE7VEkLACzwszPr91T51RYyeBjA3XTmuZf0wiC0AIDxgJCTVuN345aAAEiAEJZaAKjlif2c4PaA48V76YLhBYy0wgEugFRDUgsAZPbKmIkc3bsmYDxqjZw8S+S5CQDsRo6l2X08pDbucwYQCuxwzgvIMlZILo5b6wF/DZjfp9NfaCcKlTkdPjR0w/aEP0hFy1djEaSkpuLEGNsrum5HeacGAC/9XVvB/XeYeOQbTodrAFAzZmEE/Fezwm8TALwMcJEAhDNBzWK9dFQzZi8PCKffmsVOAJyCpAbU6QEBBCwSnCEQLcFr3HVywOQA+1RW41UBCjALoVU4gBvf/QMI5Sh/OYlefUWMR9c68XFa3L8T4GDGASorJbvlxXzUgC31XY+YABRsx/QAh/ULMLwwlRkCXmE0OaDAOScHrMQBPH3Z9Q249+cpTW8ZkgPoDnO5edg0AQQuUyPdYQ+wIQGw7u28C1fP4MPfhwOAfuHh87jDRVPK9vKC4QD4VNBOt7pOl94DStpXRw0AO2g1TrzGx6X3AAywXnR4bw6OAgCMWGqgeo3PqPHoD0eCOyOWFrZGxTkBGPUwtNRC91rfRxUCS9Vg7ypwaA5YeshAhWg9vDgqD8jdQ1htrwlABQJDZgHrQMQR2XsVGsFhSACs80DPc8CwJMj7wdwL0t2z+cguW7pDekAv40rGmQCMWgmW7F4PnekB0wOcV+uzM1QQaGuc0wum7aIyOWBygMMB/wCoI9hBlHmMqwAAAABJRU5ErkJggg==');
</PRE><P>}
</P><P>.netlogo-interface-unlocker.interface-unlocked {
</P><PRE> background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAADbklEQVR4Xu2b4VXbMBSFdbVA2w3aCZpOUJgAOkGRPABlgtIJSv9HMp0AMkHDBIUJChuEAcjreSGhqWPJsi2wfSyfk3+SrPfp6j5ZUiBG/mDk8YsEIClgYASstR+5ywAmQojXRHQrhLgFcK+Uuq4bTu+nQJ7nHOQBER0COKwI8JaI5gAutdazEBi9BpDn+TERnfJIhwRTKHMN4EQpNffV7SWAPM8nRHQhhHjbIPBiFVbEJ6XUoqyt3gEwxhwByCMEvt0EewRD2PGIXgEwxnwB8D1y8JvmFgD2ixB6A6DuyBPRHQA2vQmAV4HQGMIHpRRnjtXTCwDrOf/LZ3ZEdA/gnH/FUeRM8fDwsCel5CzxuQIGmyMrYeUJvQBgrf0thOC87npmAI5cRrZdKc/zveVyeQbgvasxIvqWZRlnl+4BVEmfiFSWZeeBEl8VW68duM6Box5PhXcMtHMFWGv/uNIdEZ1kWXZWJ/jtssYYlrtLCT+11kedAmC5EhHP/bJnprWuWvl52bASlsslp8Ayk1xord90CsBay6N7XLpAeZTok1u3UMEpgK+Od+x3DcAl/9ajX5gKPOfLVPCjawBUNjJNjM+nEGvtpcMQrzoDsM79nP52nrVDt5b/pmFjjGsadArAaYBa66gDM51OD6WU/HG1C7upubSt58sAsQH43hWVdB0oCYBnDZAUENkD0hTwqC15QB3jilm2Nya42WePGVxIW7yvT0SuL729TRsA7tp+E3g9wFpbuhwNCeIlymxvXjR9XwLwuM1eqjaMQQE+5SQASQEjMMEXmwJEdANgUfOwwmvuMbLAswPgwKWUvG//dPbm2YSolc16D4BPbKSUk7LFim/TM5RC7wEIIZwbmBXb3kEMeg+gqoNts0xV+0EUPYVirANWJyxl7/BtfIZ2fAgA+MISHznvXD4wxlwE3OsZfhYQQuycu8cwQCYzCAVwR4sqsNby5aTVlbY2z2AAFDcyR6eAIoDRLITW8/Qmy7L/bnhUXXwInRZDmQJXWuunbSwOLsYiaEgmuLMWGBUAl0zbrgIHo4DRAwg1tCblhmKCTWILqpMAbF1qDCJWs1CMr8Gar6xXPCkgKeDfvd562gkrnaZAjMVKGOtmpZ7dA/irrVnXXqaWlHJe9cenNj3p7IZIm07HrJsAxKQ5xLZGr4C/ICqoLrwEHLcAAAAASUVORK5CYII=')
</PRE><P>}
</P><P>.netlogo-interface-unlocker.interface-unlocked:hover {
</P><PRE> background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAC3klEQVR4Xu2b8TUEMRDGv6sAHVABKuAqQAWoABWgAlSAClABVwEqQAdUwPtW1tu3l2STzaxNLsl7+5cke/ObL5PZSUyQeZtkbj8KgKKA9AhsqZ+8AWAZwLt6vgC8+JqTwhKgkTsAdtVjs5EwngDcA3hwgRE7gCMAZ8rTLvY0+1ANJwqIcWysACjvOwCrvlZr+lMRewA+dXPFCOAAwLWA4c0puDQIYS5GxAbgGMCFsPH1dFTAtA0hJgC+nv9Q0Z/LZckRGiFsqnHVkFgA0IjHjmDHbe5GPW0pc6fYVrvEfgcMjqUSqpgQC4BnAIRgatzSqBBtIGsNIohLAOuW+c7V7hIFgC7pHyqvO6q86kZFUC3MH3SNINcINAYFvFm2O+7j9GbfRrmblHBLVY0NgHLl2tc1yp7ZX0irU2VdkKQKVsYGQO8y29M1SpT7d2hjJnlqmGQ6NgCT/CW837SZ3tap4GpsAN8Gz/QJfDal8ONIFxBnYwLgtsftb0j513OblsGoAGwBUNoxDKb8uJpr0i/yCVj/CcD4rgLAx2XCfYsCLEmQtDLLEjDBlibts0rKEohlCdR1dh/vSfRlImT60qM66lZXfkLeaY0BpnQ05IWSY/+KFwGTZg/AqDYGwRwUYBRPAVAUUJaAaAx4VaVrn8OKruAusQsMHgNoOMvbzQMLWy2uy+jm36MHwBMbelxXwLQVPV0hRA/AVsC05fsLA6DLQ6F5Rtf8riC1/STygOqExfArbIVP1x8ePQAawiNn3QUlFiJDT3eSADB37q6+9EynPq7eZ78kAOhUwLs5Ep/ayQBoV5cktsCkFNAGkE0iRC8xE2zf8Oi6+OAaB5JYAjN1R6dplEQSlMwS0OUCWQEwyTQ0C0xGAdkDcA1offolEQT7GOY6pgCoLzW6EvPpJ/E16PO+Pn2LAooCfv9rZJBWlkA5GBlQXkKaZV2BzyBtzBsigxjkO2kB4Ets0fpnr4Af4sW1RwixQEAAAAAASUVORK5CYII=')
</PRE><P>}
</P><P>.netlogo-widget.interface-unlocked {
</P><PRE> -webkit-user-select: none;
    -moz-user-select: none;
     -ms-user-select: none;
         user-select: none;
</PRE><P>}
</P><P>.netlogo-widget.interface-unlocked:hover {
</P><PRE> box-shadow: 0 0 6px 3px rgba(15, 15, 15, .40);
 cursor:     default;
 z-index:    3;
</PRE><P>}
</P><P>.context-menu-item {
</P><PRE> border-bottom: solid 1px #dfdfdf;
 color:         #0066aa;
 cursor:        pointer;
 font-size:     18px;
 padding:       5px;
 -webkit-user-select:   none;
    -moz-user-select:   none;
     -ms-user-select:   none;
         user-select:   none;
</PRE><P>}
</P><P>.context-menu-item:hover {
</P><PRE> background-color: #0066aa;
 color:            white;
</PRE><P>}
</P><P>.context-menu-item:last-child {
</P><PRE> border-bottom: none;
</PRE><P>}
</P><P>.context-menu-list {
</P><PRE> list-style: none;
 margin:     0;
 padding:    0;
</PRE><P>}
</P><P>.widget-context-menu {
</P><PRE> background-color: white;
 border:           solid 1px #dfdfdf;
 box-shadow:       1px 1px 2px #cfcfcf;
 display:          none;
 margin:           0;
 padding:          8px 10px;
 position:         absolute;
 width:            200px;
 z-index:          10;
</PRE><P>}
</P><P>.widget-edit-popup {
</P><PRE> background-color: white;
 border:           1px solid black;
 border-radius:    5px;
 box-shadow:       0 0 10px rgba(0,0,0,0.5);
 padding:          10px 10px 0 10px;
 position:         absolute;
 outline:          none;
 width:            450px;
 z-index:          100;
</PRE><P>}
</P><P>.widget-edit-form {
</P><PRE> margin-bottom: 10px;
</PRE><P>}
</P><P>.widget-edit-form label {
</P><PRE> -webkit-user-select: none;
    -moz-user-select: none;
     -ms-user-select: none;
         user-select: none;
</PRE><P>}
</P><P>.widget-edit-form-title {
</P><PRE> cursor:        default;
 font-weight:   bold;
 margin-bottom: 10px;
 text-align:    center;
 -webkit-user-select:   none;
    -moz-user-select:   none;
     -ms-user-select:   none;
         user-select:   none;
</PRE><P>}
</P><P>.widget-edit-form-button-container {
</P><PRE> margin-top: 10px;
 text-align: center;
</PRE><P>}
</P><P>.widget-edit-closer {
</P><PRE> color:       #7F7F7F;
 cursor:      pointer;
 font-weight: bold;
 position:    absolute;
 right:       10px;
 top:         10px;
 -webkit-user-select: none;
    -moz-user-select: none;
     -ms-user-select: none;
         user-select: none;
</PRE><P>}
</P><P>.widget-edit-closer:hover {
</P><PRE> color: black;
</PRE><P>}
</P><P>.widget-edit-text {
</P><PRE> font-size: 20px;
</PRE><P>}
</P><P>.widget-edit-checkbox {
</P><PRE> height: 13px;
</PRE><P>}
</P><P>.widget-edit-input-label {
</P><PRE> margin-right: 10px;
 white-space:  nowrap;
</PRE><P>}
</P><P>.widget-edit-input {
</P><PRE> width: 100%;
</PRE><P>}
</P><P>.widget-edit-input[type=&quot;number&quot;] {
</P><PRE> text-align: right;
</PRE><P>}
</P><P>.widget-edit-hint-text {
</P><PRE> font-size:   12px;
 -webkit-user-select: none;
    -moz-user-select: none;
     -ms-user-select: none;
         user-select: none;
</PRE><P>}
</P><P>.widget-edit-dropdown {
</P><PRE> font-size: 14px;
 height:    20px;
 margin:    0 10px;
</PRE><P>}
</P><P>.widget-edit-textbox {
</P><PRE> font-size: 14px;
 height:    115px;
 max-width: 100%;
 min-width: 100%;
</PRE><P>}
</P><P>.widget-edit-fieldset {
</P><PRE> border-radius: 8px;
</PRE><P>}
</P><P>.widget-edit-legend {
</P><PRE> -webkit-user-select: none;
    -moz-user-select: none;
     -ms-user-select: none;
         user-select: none;
</PRE><P>}
&lt;/style&gt;</P><PRE>&lt;style&gt;.netlogo-command {
 background-color: #BACFF3;
</PRE><P>}
.netlogo-command.netlogo-active, .netlogo-command:active {
</P><PRE> background-color: #1F6A99;
 color: #BACFF3;
</PRE><P>}
.netlogo-button.netlogo-disabled:active, .netlogo-forever-button.netlogo-disabled.netlogo-active {
</P><PRE> background-color: #BCBCE5;
 color: #888888;
</PRE><P>}
.netlogo-input {
</P><PRE> background-color: #8FE585;
</PRE><P>}
.netlogo-output {
</P><PRE> background-color: #FFFF9A;
 border: 1px solid #E7E741;
</PRE><P>}
</P><P>.netlogo-slider-label .netlogo-label {
</P><PRE> background-color: #8FE585;
</PRE><P>}
</P><P>.netlogo-slider-label .netlogo-slider-value {
</P><PRE> background-color: #8FE585;
</PRE><P>}
</P><P>.netlogo-tab {
</P><PRE> background-color: #BCBCE5;
 border-color: #242479;
 font-size: 16px;
</PRE><P>}
</P><P>.netlogo-tab.netlogo-active {
</P><PRE> background-color: #7C76fD;
</PRE><P>}
</P><P>.netlogo-tab:active {
</P><PRE> background-color: #7C76fD;
</PRE><P>}
</P><P>.netlogo-view-container {
</P><PRE> background-color: #F4F4F4;
 border: 1px solid #CCCCCC;
</PRE><P>}
&lt;/style&gt;</P><PRE>&lt;style&gt;.cm-s-netlogo-default .cm-reporter {
   color: #660096;
</PRE><P>}
.cm-s-netlogo-default .cm-command {
</P><PRE>   color: #0000AA;
</PRE><P>}
.cm-s-netlogo-default .cm-keyword {
</P><PRE>   color: #007F69;
</PRE><P>}
.cm-s-netlogo-default .cm-comment {
</P><PRE>   color: #5A5A5A;
</PRE><P>}
.cm-s-netlogo-default .cm-string,
.cm-s-netlogo-default .cm-number,
.cm-s-netlogo-default .cm-constant {
</P><PRE>   color: #963700;
</PRE><P>}
&lt;/style&gt;</P><PRE>&lt;style&gt;/*
* Styles for that sweet loading spinner with turtles
*/
</PRE><OL><LI>loading-overlay {</LI></OL><PRE> display: -ms-flexbox;
 display: flex;
 -ms-flex-align: center;
     align-items: center;
 -ms-flex-pack: center;
     justify-content: center;
</PRE><P>}
</P><P>.spinner-img {
</P><PRE> height: auto;
 width: 10px;
 z-index: 11;
 position: absolute;
</PRE><P>}
</P><OL><LI>spinner {</LI></OL><PRE> height: 50px;
 width:  50px;
 transform-origin: 60% 60%;
 animation-name: spin;
 animation-duration: 1.75s;
 animation-iteration-count: infinite;
 animation-direction: normal;
 animation-timing-function: linear;
 animation-fill-mode: forwards;
 animation-delay: 0s;
 animation-play-state: running;
 z-index: 11;
</PRE><P>}
</P><P>.turtle1 {
</P><PRE> top: 29%;
 left: 29%;
</PRE><P>}
</P><P>.turtle2 {
</P><PRE> top: 20%;
 left: 50%;
</PRE><P>}
</P><P>.turtle3 {
</P><PRE> top: 29%;
 left: 71%;
</PRE><P>}
</P><P>.turtle4 {
</P><PRE> top:  50%;
 left: 80%;
</PRE><P>}
</P><P>.turtle5 {
</P><PRE> top:  71%;
 left: 71%;
</PRE><P>}
</P><P>.turtle6 {
</P><PRE> top:  80%;
 left: 50%;
</PRE><P>}
</P><P>.turtle7 {
</P><PRE> top:  71%;
 left: 29%;
</PRE><P>}
</P><P>.turtle8 {
</P><PRE> top: 50%;
 left: 20%;
</PRE><P>}
</P><P>@keyframes spin {
</P><PRE> from {
     transform: rotate(0deg);
 }
 to {
     transform: rotate(360deg);
 }
</PRE><P>}
&lt;/style&gt;</P><PRE>&lt;style&gt;/*
* styles to use with the &quot;error alert&quot; component
*/
</PRE><P>.dark-overlay {
</P><PRE> background-color:rgba(0, 0, 0, 0.7);
 width:100%;
 height:100%;
 z-index:10;
 top:0;
 left:0;
 position: fixed;
</PRE><P>}
</P><OL><LI>alert-overlay {</LI></OL><PRE> display: -ms-flexbox;
 display: flex;
 -ms-flex-direction: row;
     flex-direction: row;
 -ms-flex-pack: center;
     justify-content: center;
 -ms-flex-align: center;
     align-items: center;
 font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
</PRE><P>}
</P><OL><LI>alert-dialog {</LI></OL><PRE> -ms-flex-align: center;
     align-items: center;
 background-color: whitesmoke;
 border: 2px black solid;
 border-radius: 10px;
 display:-ms-flexbox;
 display:flex;
 -ms-flex-direction: column;
     flex-direction: column;
 margin: 0 50px;
 min-width: 350px;
 opacity: 1;
 z-index: 15;
</PRE><P>}
</P><OL><LI>alert-title {</LI></OL><PRE> margin-bottom: 5px;
</PRE><P>}
</P><P>.alert-text {
</P><PRE> padding: 10px;
 font-size: 16px;
</PRE><P>}
</P><P>.standalone-text {
</P><PRE> color: #555555;
 display: none;
 text-align: center;
 max-width: 600px;
</PRE><P>}
</P><OL><LI>alert-dismiss-container {</LI></OL><PRE> border-top: 1px solid lightgray;
 width: 100%;
 text-align: center;
 padding: 10px 0;
</PRE><P>}
</P><P>.alert-button {
</P><PRE> font-size: 14px;
 height: 25px;
 min-width: 50%;
 border-radius: 3px;
 border: 1px solid lightgray;
 background-color: #e6e6e6;
</PRE><P>}
&lt;/style&gt;</P><PRE>&lt;body style=&quot;margin: 0px;&quot;&gt;</PRE><DIV class="dark-overlay" id="loading-overlay"><DIV id="spinner"><PRE>&lt;svg class=&quot;spinner-img turtle1&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 50 55&quot;&gt;&lt;polygon points=&quot;22,0 0,49 22,40 44,49&quot; style=&quot;fill: rgba(255, 255, 255, 0.125);&quot; transform=&quot;rotate(45.0, 22, 24)&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt;&lt;svg class=&quot;spinner-img turtle2&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 50 55&quot;&gt;&lt;polygon points=&quot;22,0 0,49 22,40 44,49&quot; style=&quot;fill: rgba(255, 255, 255, 0.25);&quot; transform=&quot;rotate(90.0, 22, 24)&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt;&lt;svg class=&quot;spinner-img turtle3&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 50 55&quot;&gt;&lt;polygon points=&quot;22,0 0,49 22,40 44,49&quot; style=&quot;fill: rgba(255, 255, 255, 0.375);&quot; transform=&quot;rotate(135.0, 22, 24)&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt;&lt;svg class=&quot;spinner-img turtle4&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 50 55&quot;&gt;&lt;polygon points=&quot;22,0 0,49 22,40 44,49&quot; style=&quot;fill: rgba(255, 255, 255, 0.5);&quot; transform=&quot;rotate(180.0, 22, 24)&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt;&lt;svg class=&quot;spinner-img turtle5&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 50 55&quot;&gt;&lt;polygon points=&quot;22,0 0,49 22,40 44,49&quot; style=&quot;fill: rgba(255, 255, 255, 0.625);&quot; transform=&quot;rotate(225.0, 22, 24)&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt;&lt;svg class=&quot;spinner-img turtle6&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 50 55&quot;&gt;&lt;polygon points=&quot;22,0 0,49 22,40 44,49&quot; style=&quot;fill: rgba(255, 255, 255, 0.75);&quot; transform=&quot;rotate(270.0, 22, 24)&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt;&lt;svg class=&quot;spinner-img turtle7&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 50 55&quot;&gt;&lt;polygon points=&quot;22,0 0,49 22,40 44,49&quot; style=&quot;fill: rgba(255, 255, 255, 0.875);&quot; transform=&quot;rotate(315.0, 22, 24)&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt;&lt;svg class=&quot;spinner-img turtle8&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 50 55&quot;&gt;&lt;polygon points=&quot;22,0 0,49 22,40 44,49&quot; style=&quot;fill: rgba(255, 255, 255, 1.0);&quot; transform=&quot;rotate(360.0, 22, 24)&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt;</PRE></DIV></DIV><DIV class="dark-overlay" id="alert-overlay" style="display : none ;"><DIV id="alert-dialog"><H3 id="alert-title"><SPAN class="mw-headline" id="Error">Error</SPAN></H3><DIV id="alert-message" class="alert-text"><PRE>           NetLogo Web has encountered a problem.
</PRE></DIV><DIV class="alert-text standalone-text"><PRE>           It looks like you're using NetLogo Web in standalone mode.
           
           If the above error is being caused by an unimplemented primitive, we recommend a quick visit to
               &lt;a href=&quot;<A rel="nofollow" class="external free" href="https://netlogoweb.org">https://netlogoweb.org</A>&quot; target=&quot;_blank&quot;&gt;NetLogoWeb.org&lt;/a&gt;
               to see if the primitive has been implemented in the most up-to-date version.
</PRE></DIV><DIV id="alert-dismiss-container"><PRE>&lt;button id=&quot;alert-dismiss&quot; class=&quot;alert-button alert-separator-top&quot; onclick=&quot;window.nlwAlerter.hide()&quot;&gt;
               Dismiss
           &lt;/button&gt;</PRE></DIV></DIV></DIV><PRE>&lt;script&gt;/*!
* jQuery JavaScript Library v3.2.1
* <A rel="nofollow" class="external free" href="https://jquery.com/">https://jquery.com/</A>
*
* Includes Sizzle.js
* <A rel="nofollow" class="external free" href="https://sizzlejs.com/">https://sizzlejs.com/</A>
*
* Copyright JS Foundation and other contributors
* Released under the MIT license
* <A rel="nofollow" class="external free" href="https://jquery.org/license">https://jquery.org/license</A>
*
* Date: 2017-03-20T18:59Z
*/
</PRE><P>( function( global, factory ) {
</P><P>	&quot;use strict&quot;;
</P><P>	if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) {
</P><P>		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require(&quot;jquery&quot;)(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( &quot;jQuery requires a window with a document&quot; );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}
</P><P>// Pass this if window is not defined yet
} )( typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal ) {
</P><P>// Edge &lt;= 12 - 13+, Firefox &lt;=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
&quot;use strict&quot;;
</P><P>var arr = [];
</P><P>var document = window.document;
</P><P>var getProto = Object.getPrototypeOf;
</P><P>var slice = arr.slice;
</P><P>var concat = arr.concat;
</P><P>var push = arr.push;
</P><P>var indexOf = arr.indexOf;
</P><P>var class2type = {};
</P><P>var toString = class2type.toString;
</P><P>var hasOwn = class2type.hasOwnProperty;
</P><P>var fnToString = hasOwn.toString;
</P><P>var ObjectFunctionString = fnToString.call( Object );
</P><P>var support = {};
</P><P>	function DOMEval( code, doc ) {
		doc = doc || document;
</P><P>		var script = doc.createElement( &quot;script&quot; );
</P><P>		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module
</P><P>var
	version = &quot;3.2.1&quot;,
</P><P>	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
</P><P>		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},
</P><P>	// Support: Android &lt;=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
</P><P>	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,
</P><P>	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};
</P><P>jQuery.fn = jQuery.prototype = {
</P><P>	// The current version of jQuery being used
	jquery: version,
</P><P>	constructor: jQuery,
</P><P>	// The default length of a jQuery object is 0
	length: 0,
</P><P>	toArray: function() {
		return slice.call( this );
	},
</P><P>	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
</P><P>		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}
</P><P>		// Return just the one element from the set
		return num &lt; 0 ? this[ num + this.length ] : this[ num ];
	},
</P><P>	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {
</P><P>		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );
</P><P>		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
</P><P>		// Return the newly-formed element set
		return ret;
	},
</P><P>	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},
</P><P>	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},
</P><P>	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},
</P><P>	first: function() {
		return this.eq( 0 );
	},
</P><P>	last: function() {
		return this.eq( -1 );
	},
</P><P>	eq: function( i ) {
		var len = this.length,
			j = +i + ( i &lt; 0 ? len : 0 );
		return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] );
	},
</P><P>	end: function() {
		return this.prevObject || this.constructor();
	},
</P><P>	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};
</P><P>jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;
</P><P>	// Handle a deep copy situation
	if ( typeof target === &quot;boolean&quot; ) {
		deep = target;
</P><P>		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}
</P><P>	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction( target ) ) {
		target = {};
	}
</P><P>	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}
</P><P>	for ( ; i &lt; length; i++ ) {
</P><P>		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {
</P><P>			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];
</P><P>				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}
</P><P>				// Recurse if we're merging plain objects or arrays
				if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
</P><P>					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src &amp;&amp; Array.isArray( src ) ? src : [];
</P><P>					} else {
						clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : {};
					}
</P><P>					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );
</P><P>				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}
</P><P>	// Return the modified object
	return target;
};
</P><P>jQuery.extend( {
</P><P>	// Unique for each copy of jQuery on the page
	expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),
</P><P>	// Assume jQuery is ready without the ready module
	isReady: true,
</P><P>	error: function( msg ) {
		throw new Error( msg );
	},
</P><P>	noop: function() {},
</P><P>	isFunction: function( obj ) {
		return jQuery.type( obj ) === &quot;function&quot;;
	},
</P><P>	isWindow: function( obj ) {
		return obj != null &amp;&amp; obj === obj.window;
	},
</P><P>	isNumeric: function( obj ) {
</P><P>		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === &quot;number&quot; || type === &quot;string&quot; ) &amp;&amp;</P><P>			// parseFloat NaNs numeric-cast false positives (&quot;&quot;)
			// ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},
</P><P>	isPlainObject: function( obj ) {
		var proto, Ctor;
</P><P>		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== &quot;[object Object]&quot; ) {
			return false;
		}
</P><P>		proto = getProto( obj );
</P><P>		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}
</P><P>		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, &quot;constructor&quot; ) &amp;&amp; proto.constructor;
		return typeof Ctor === &quot;function&quot; &amp;&amp; fnToString.call( Ctor ) === ObjectFunctionString;
	},
</P><P>	isEmptyObject: function( obj ) {
</P><P>		/* eslint-disable no-unused-vars */
		// See <A rel="nofollow" class="external free" href="https://github.com/eslint/eslint/issues/6125">https://github.com/eslint/eslint/issues/6125</A>
		var name;
</P><P>		for ( name in obj ) {
			return false;
		}
		return true;
	},
</P><P>	type: function( obj ) {
		if ( obj == null ) {
			return obj + &quot;&quot;;
		}
</P><P>		// Support: Android &lt;=2.3 only (functionish RegExp)
		return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
			class2type[ toString.call( obj ) ] || &quot;object&quot; :
			typeof obj;
	},
</P><P>	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},
</P><P>	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE &lt;=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );
	},
</P><P>	each: function( obj, callback ) {
		var length, i = 0;
</P><P>		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i &lt; length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}
</P><P>		return obj;
	},
</P><P>	// Support: Android &lt;=4.0 only
	trim: function( text ) {
		return text == null ?
			&quot;&quot; :
			( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
	},
</P><P>	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];
</P><P>		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === &quot;string&quot; ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}
</P><P>		return ret;
	},
</P><P>	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},
</P><P>	// Support: Android &lt;=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;
</P><P>		for ( ; j &lt; len; j++ ) {
			first[ i++ ] = second[ j ];
		}
</P><P>		first.length = i;
</P><P>		return first;
	},
</P><P>	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;
</P><P>		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i &lt; length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}
</P><P>		return matches;
	},
</P><P>	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];
</P><P>		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i &lt; length; i++ ) {
				value = callback( elems[ i ], i, arg );
</P><P>				if ( value != null ) {
					ret.push( value );
				}
			}
</P><P>		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );
</P><P>				if ( value != null ) {
					ret.push( value );
				}
			}
		}
</P><P>		// Flatten any nested arrays
		return concat.apply( [], ret );
	},
</P><P>	// A global GUID counter for objects
	guid: 1,
</P><P>	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;
</P><P>		if ( typeof context === &quot;string&quot; ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}
</P><P>		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}
</P><P>		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};
</P><P>		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;
</P><P>		return proxy;
	},
</P><P>	now: Date.now,
</P><P>	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );
</P><P>if ( typeof Symbol === &quot;function&quot; ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
</P><P>// Populate the class2type map
jQuery.each( &quot;Boolean Number String Function Array Date RegExp Object Error Symbol&quot;.split( &quot; &quot; ),
function( i, name ) {
	class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
} );
</P><P>function isArrayLike( obj ) {
</P><P>	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,
		type = jQuery.type( obj );
</P><P>	if ( type === &quot;function&quot; || jQuery.isWindow( obj ) ) {
		return false;
	}
</P><P>	return type === &quot;array&quot; || length === 0 ||
		typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;
}
var Sizzle =
/*!
</P><PRE>* Sizzle CSS Selector Engine v2.3.3
* <A rel="nofollow" class="external free" href="https://sizzlejs.com/">https://sizzlejs.com/</A>
*
* Copyright jQuery Foundation and other contributors
* Released under the MIT license
* <A rel="nofollow" class="external free" href="http://jquery.org/license">http://jquery.org/license</A>
*
* Date: 2016-08-08
*/
</PRE><P>(function( window ) {
</P><P>var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,
</P><P>	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,
</P><P>	// Instance-specific data
	expando = &quot;sizzle&quot; + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},
</P><P>	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// <A rel="nofollow" class="external free" href="https://jsperf.com/thor-indexof-vs-for/5">https://jsperf.com/thor-indexof-vs-for/5</A>
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i &lt; len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},
</P><P>	booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,
</P><P>	// Regular expressions
</P><P>	// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/css3-selectors/#whitespace">http://www.w3.org/TR/css3-selectors/#whitespace</A>
	whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,
</P><P>	// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier</A>
	identifier = &quot;(?:\\\\.|[\\w-]|[^\0-\\xa0])+&quot;,
</P><P>	// Attribute selectors: <A rel="nofollow" class="external free" href="http://www.w3.org/TR/selectors/#attribute-selectors">http://www.w3.org/TR/selectors/#attribute-selectors</A>
	attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + identifier + &quot;)(?:&quot; + whitespace +
		// Operator (capture 2)
		&quot;*([*^$|!~]?=)&quot; + whitespace +
		// &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;
		&quot;*(?:'((?:\\\\.|[^\\\\'])*)'|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;|(&quot; + identifier + &quot;))|)&quot; + whitespace +
		&quot;*\\]&quot;,
</P><P>	pseudos = &quot;:(&quot; + identifier + &quot;)(?:\\((&quot; +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		&quot;('((?:\\\\.|[^\\\\'])*)'|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;)|&quot; +
		// 2. simple (capture 6)
		&quot;((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes + &quot;)*)|&quot; +
		// 3. anything else (capture 2)
		&quot;.*&quot; +
		&quot;)\\)|)&quot;,
</P><P>	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + &quot;+&quot;, &quot;g&quot; ),
	rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),
</P><P>	rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
	rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace + &quot;)&quot; + whitespace + &quot;*&quot; ),
</P><P>	rattributeQuotes = new RegExp( &quot;=&quot; + whitespace + &quot;*([^\\]'\&quot;]*?)&quot; + whitespace + &quot;*\\]&quot;, &quot;g&quot; ),
</P><P>	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),
</P><P>	matchExpr = {
		&quot;ID&quot;: new RegExp( &quot;^#(&quot; + identifier + &quot;)&quot; ),
		&quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + identifier + &quot;)&quot; ),
		&quot;TAG&quot;: new RegExp( &quot;^(&quot; + identifier + &quot;|[*])&quot; ),
		&quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
		&quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
		&quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
			&quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
			&quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
		&quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		&quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
			whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
	},
</P><P>	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,
</P><P>	rnative = /^[^{]+\{\s*\[native \w/,
</P><P>	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
</P><P>	rsibling = /[+~]/,
</P><P>	// CSS escapes
	// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/CSS21/syndata.html#escaped-characters">http://www.w3.org/TR/CSS21/syndata.html#escaped-characters</A>
	runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = &quot;0x&quot; + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox&lt;24
		// Workaround erroneous numeric interpretation of +&quot;0x&quot;
		return high !== high || escapedWhitespace ?
			escaped :
			high &lt; 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
	},
</P><P>	// CSS string/identifier serialization
	// <A rel="nofollow" class="external free" href="https://drafts.csswg.org/cssom/#common-serializing-idioms">https://drafts.csswg.org/cssom/#common-serializing-idioms</A>
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {
</P><P>			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === &quot;\0&quot; ) {
				return &quot;\uFFFD&quot;;
			}
</P><P>			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + &quot;\\&quot; + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + &quot; &quot;;
		}
</P><P>		// Other potentially-special ASCII characters get backslash-escaped
		return &quot;\\&quot; + ch;
	},
</P><P>	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a &quot;Permission Denied&quot;
	// error in IE
	unloadHandler = function() {
		setDocument();
	},
</P><P>	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true &amp;&amp; (&quot;form&quot; in elem || &quot;label&quot; in elem);
		},
		{ dir: &quot;parentNode&quot;, next: &quot;legend&quot; }
	);
</P><P>// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android&lt;4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?
</P><P>		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :
</P><P>		// Support: IE&lt;9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}
</P><P>function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context &amp;&amp; context.ownerDocument,
</P><P>		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;
</P><P>	results = results || [];
</P><P>	// Return early from calls with invalid selector or context
	if ( typeof selector !== &quot;string&quot; || !selector ||
		nodeType !== 1 &amp;&amp; nodeType !== 9 &amp;&amp; nodeType !== 11 ) {
</P><P>		return results;
	}
</P><P>	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
</P><P>		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;
</P><P>		if ( documentIsHTML ) {
</P><P>			// If the selector is sufficiently simple, try using a &quot;get*By*&quot; DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 &amp;&amp; (match = rquickExpr.exec( selector )) ) {
</P><P>				// ID selector
				if ( (m = match[1]) ) {
</P><P>					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {
</P><P>							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
</P><P>					// Element context
					} else {
</P><P>						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext &amp;&amp; (elem = newContext.getElementById( m )) &amp;&amp;
							contains( context, elem ) &amp;&amp;
							elem.id === m ) {
</P><P>							results.push( elem );
							return results;
						}
					}
</P><P>				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;
</P><P>				// Class selector
				} else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp;
					context.getElementsByClassName ) {
</P><P>					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}
</P><P>			// Take advantage of querySelectorAll
			if ( support.qsa &amp;&amp;
				!compilerCache[ selector + &quot; &quot; ] &amp;&amp;
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
</P><P>				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;
</P><P>				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE &lt;=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== &quot;object&quot; ) {
</P><P>					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( &quot;id&quot; )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( &quot;id&quot;, (nid = expando) );
					}
</P><P>					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = &quot;#&quot; + nid + &quot; &quot; + toSelector( groups[i] );
					}
					newSelector = groups.join( &quot;,&quot; );
</P><P>					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) ||
						context;
				}
</P><P>				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( &quot;id&quot; );
						}
					}
				}
			}
		}
	}
</P><P>	// All others
	return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );
}
</P><P>/**
</P><PRE>* Create key-value caches of limited size
* @returns {function(string, object)} Returns the Object data after storing it on itself with
*	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
*	deleting the oldest entry
*/
</PRE><P>function createCache() {
	var keys = [];
</P><P>	function cache( key, value ) {
		// Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + &quot; &quot; ) &gt; Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + &quot; &quot; ] = value);
	}
	return cache;
}
</P><P>/**
</P><PRE>* Mark a function for special use by Sizzle
* @param {Function} fn The function to mark
*/
</PRE><P>function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}
</P><P>/**
</P><PRE>* Support testing using an element
* @param {Function} fn Passed the created element and returns a boolean result
*/
</PRE><P>function assert( fn ) {
	var el = document.createElement(&quot;fieldset&quot;);
</P><P>	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}
</P><P>/**
</P><PRE>* Adds the same handler for all of the specified attrs
* @param {String} attrs Pipe-separated list of attributes
* @param {Function} handler The method that will be applied
*/
</PRE><P>function addHandle( attrs, handler ) {
	var arr = attrs.split(&quot;|&quot;),
		i = arr.length;
</P><P>	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}
</P><P>/**
</P><PRE>* Checks document order of two siblings
* @param {Element} a
* @param {Element} b
* @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
*/
</PRE><P>function siblingCheck( a, b ) {
	var cur = b &amp;&amp; a,
		diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
			a.sourceIndex - b.sourceIndex;
</P><P>	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}
</P><P>	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}
</P><P>	return a ? 1 : -1;
}
</P><P>/**
</P><PRE>* Returns a function to use in pseudos for input types
* @param {String} type
*/
</PRE><P>function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === &quot;input&quot; &amp;&amp; elem.type === type;
	};
}
</P><P>/**
</P><PRE>* Returns a function to use in pseudos for buttons
* @param {String} type
*/
</PRE><P>function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
	};
}
</P><P>/**
</P><PRE>* Returns a function to use in pseudos for :enabled/:disabled
* @param {Boolean} disabled true for :disabled; false for :enabled
*/
</PRE><P>function createDisabledPseudo( disabled ) {
</P><P>	// Known :disabled false positives: fieldset[disabled] &gt; legend:nth-of-type(n+2) :can-disable
	return function( elem ) {
</P><P>		// Only certain elements can match :enabled or :disabled
		// <A rel="nofollow" class="external free" href="https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled">https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled</A>
		// <A rel="nofollow" class="external free" href="https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled">https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled</A>
		if ( &quot;form&quot; in elem ) {
</P><P>			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   <A rel="nofollow" class="external free" href="https://html.spec.whatwg.org/multipage/forms.html#category-listed">https://html.spec.whatwg.org/multipage/forms.html#category-listed</A>
			//   <A rel="nofollow" class="external free" href="https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled">https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled</A>
			// * option elements in a disabled optgroup
			//   <A rel="nofollow" class="external free" href="https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled">https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled</A>
			// All such elements have a &quot;form&quot; property.
			if ( elem.parentNode &amp;&amp; elem.disabled === false ) {
</P><P>				// Option elements defer to a parent optgroup if present
				if ( &quot;label&quot; in elem ) {
					if ( &quot;label&quot; in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}
</P><P>				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||
</P><P>					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &amp;&amp;
						disabledAncestor( elem ) === disabled;
			}
</P><P>			return elem.disabled === disabled;
</P><P>		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( &quot;label&quot; in elem ) {
			return elem.disabled === disabled;
		}
</P><P>		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}
</P><P>/**
</P><PRE>* Returns a function to use in pseudos for positionals
* @param {Function} fn
*/
</PRE><P>function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;
</P><P>			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}
</P><P>/**
</P><PRE>* Checks a node for validity as a Sizzle context
* @param {Element|Object=} context
* @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
*/
</PRE><P>function testContext( context ) {
	return context &amp;&amp; typeof context.getElementsByTagName !== &quot;undefined&quot; &amp;&amp; context;
}
</P><P>// Expose support vars for convenience
support = Sizzle.support = {};
</P><P>/**
</P><PRE>* Detects XML nodes
* @param {Element|Object} elem An element or a document
* @returns {Boolean} True iff elem is a non-HTML XML node
*/
</PRE><P>isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
};
</P><P>/**
</P><PRE>* Sets document-related variables once based on the current document
* @param {Element|Object} [doc] An element or document object to use to set the document
* @returns {Object} Returns the current document
*/
</PRE><P>setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;
</P><P>	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}
</P><P>	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );
</P><P>	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws &quot;permission denied&quot; errors (jQuery #13936)
	if ( preferredDoc !== document &amp;&amp;
		(subWindow = document.defaultView) &amp;&amp; subWindow.top !== subWindow ) {
</P><P>		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( &quot;unload&quot;, unloadHandler, false );
</P><P>		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( &quot;onunload&quot;, unloadHandler );
		}
	}
</P><P>	/* Attributes
	---------------------------------------------------------------------- */
</P><P>	// Support: IE&lt;8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = &quot;i&quot;;
		return !el.getAttribute(&quot;className&quot;);
	});
</P><P>	/* getElement(s)By*
	---------------------------------------------------------------------- */
</P><P>	// Check if getElementsByTagName(&quot;*&quot;) returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment(&quot;&quot;) );
		return !el.getElementsByTagName(&quot;*&quot;).length;
	});
</P><P>	// Support: IE&lt;9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );
</P><P>	// Support: IE&lt;10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});
</P><P>	// ID filter and find
	if ( support.getById ) {
		Expr.filter[&quot;ID&quot;] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute(&quot;id&quot;) === attrId;
			};
		};
		Expr.find[&quot;ID&quot;] = function( id, context ) {
			if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[&quot;ID&quot;] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== &quot;undefined&quot; &amp;&amp;
					elem.getAttributeNode(&quot;id&quot;);
				return node &amp;&amp; node.value === attrId;
			};
		};
</P><P>		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[&quot;ID&quot;] = function( id, context ) {
			if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );
</P><P>				if ( elem ) {
</P><P>					// Verify the id attribute
					node = elem.getAttributeNode(&quot;id&quot;);
					if ( node &amp;&amp; node.value === id ) {
						return [ elem ];
					}
</P><P>					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode(&quot;id&quot;);
						if ( node &amp;&amp; node.value === id ) {
							return [ elem ];
						}
					}
				}
</P><P>				return [];
			}
		};
	}
</P><P>	// Tag
	Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
				return context.getElementsByTagName( tag );
</P><P>			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :
</P><P>		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );
</P><P>			// Filter out possible comments
			if ( tag === &quot;*&quot; ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}
</P><P>				return tmp;
			}
			return results;
		};
</P><P>	// Class
	Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function( className, context ) {
		if ( typeof context.getElementsByClassName !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};
</P><P>	/* QSA/matchesSelector
	---------------------------------------------------------------------- */
</P><P>	// QSA and matchesSelector support
</P><P>	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];
</P><P>	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See <A rel="nofollow" class="external free" href="https://bugs.jquery.com/ticket/13378">https://bugs.jquery.com/ticket/13378</A>
	rbuggyQSA = [];
</P><P>	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// <A rel="nofollow" class="external free" href="https://bugs.jquery.com/ticket/12359">https://bugs.jquery.com/ticket/12359</A>
			docElem.appendChild( el ).innerHTML = &quot;&lt;a id='&quot; + expando + &quot;'&gt;&lt;/a&gt;&quot; +
				&quot;&lt;select id='&quot; + expando + &quot;-\r\\' msallowcapture=<I>&gt;&quot; +</I>
				&quot;&lt;option selected=<I>&gt;&lt;/option&gt;&lt;/select&gt;&quot;;</I></P><P>			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT
			// <A rel="nofollow" class="external free" href="https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section">https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section</A>
			if ( el.querySelectorAll(&quot;[msallowcapture^=<I>]&quot;).length ) {</I>
				rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:<I>|\&quot;\&quot;)&quot; );</I>
			}
</P><P>			// Support: IE8
			// Boolean attributes and &quot;value&quot; are not treated correctly
			if ( !el.querySelectorAll(&quot;[selected]&quot;).length ) {
				rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; );
			}
</P><P>			// Support: Chrome&lt;29, Android&lt;4.4, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.8+
			if ( !el.querySelectorAll( &quot;[id~=&quot; + expando + &quot;-]&quot; ).length ) {
				rbuggyQSA.push(&quot;~=&quot;);
			}
</P><P>			// Webkit/Opera - :checked should return selected option elements
			// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</A>
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(&quot;:checked&quot;).length ) {
				rbuggyQSA.push(&quot;:checked&quot;);
			}
</P><P>			// Support: Safari 8+, iOS 8+
			// <A rel="nofollow" class="external free" href="https://bugs.webkit.org/show_bug.cgi?id=136851">https://bugs.webkit.org/show_bug.cgi?id=136851</A>
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( &quot;a#&quot; + expando + &quot;+*&quot; ).length ) {
				rbuggyQSA.push(&quot;.#.+[+~]&quot;);
			}
		});
</P><P>		assert(function( el ) {
			el.innerHTML = &quot;&lt;a href=<I> disabled='disabled'&gt;&lt;/a&gt;&quot; +</I>
				&quot;&lt;select disabled='disabled'&gt;&lt;option/&gt;&lt;/select&gt;&quot;;
</P><P>			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement(&quot;input&quot;);
			input.setAttribute( &quot;type&quot;, &quot;hidden&quot; );
			el.appendChild( input ).setAttribute( &quot;name&quot;, &quot;D&quot; );
</P><P>			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll(&quot;[name=d]&quot;).length ) {
				rbuggyQSA.push( &quot;name&quot; + whitespace + &quot;*[*^$|!~]?=&quot; );
			}
</P><P>			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(&quot;:enabled&quot;).length !== 2 ) {
				rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
			}
</P><P>			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(&quot;:disabled&quot;).length !== 2 ) {
				rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
			}
</P><P>			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll(&quot;*,:x&quot;);
			rbuggyQSA.push(&quot;,.*:&quot;);
		});
	}
</P><P>	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {
</P><P>		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, &quot;*&quot; );
</P><P>			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, &quot;[s!=<I>]:x&quot; );</I>
			rbuggyMatches.push( &quot;!=&quot;, pseudos );
		});
	}
</P><P>	rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) );
	rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );
</P><P>	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );
</P><P>	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b &amp;&amp; b.parentNode;
			return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};
</P><P>	/* Sorting
	---------------------------------------------------------------------- */
</P><P>	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {
</P><P>		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
</P><P>		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}
</P><P>		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :
</P><P>			// Otherwise we know they are disconnected
			1;
</P><P>		// Disconnected nodes
		if ( compare &amp; 1 ||
			(!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {
</P><P>			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) {
				return 1;
			}
</P><P>			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}
</P><P>		return compare &amp; 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
</P><P>		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];
</P><P>		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
</P><P>		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}
</P><P>		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}
</P><P>		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}
</P><P>		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :
</P><P>			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};
</P><P>	return document;
};
</P><P>Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};
</P><P>Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}
</P><P>	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, &quot;='$1']&quot; );
</P><P>	if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
		!compilerCache[ expr + &quot; &quot; ] &amp;&amp;
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
</P><P>		try {
			var ret = matches.call( elem, expr );
</P><P>			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}
</P><P>	return Sizzle( expr, document, null, [ elem ] ).length &gt; 0;
};
</P><P>Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};
</P><P>Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}
</P><P>	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;
</P><P>	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
				val.value :
				null;
};
</P><P>Sizzle.escape = function( sel ) {
	return (sel + &quot;&quot;).replace( rcssescape, fcssescape );
};
</P><P>Sizzle.error = function( msg ) {
	throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
};
</P><P>/**
</P><PRE>* Document sorting and removing duplicates
* @param {ArrayLike} results
*/
</PRE><P>Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;
</P><P>	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable &amp;&amp; results.slice( 0 );
	results.sort( sortOrder );
</P><P>	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}
</P><P>	// Clear input after sorting to release objects
	// See <A rel="nofollow" class="external free" href="https://github.com/jquery/sizzle/pull/225">https://github.com/jquery/sizzle/pull/225</A>
	sortInput = null;
</P><P>	return results;
};
</P><P>/**
</P><PRE>* Utility function for retrieving the text value of an array of DOM nodes
* @param {Array|Element} elem
*/
</PRE><P>getText = Sizzle.getText = function( elem ) {
	var node,
		ret = &quot;&quot;,
		i = 0,
		nodeType = elem.nodeType;
</P><P>	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === &quot;string&quot; ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes
</P><P>	return ret;
};
</P><P>Expr = Sizzle.selectors = {
</P><P>	// Can be adjusted by the user
	cacheLength: 50,
</P><P>	createPseudo: markFunction,
</P><P>	match: matchExpr,
</P><P>	attrHandle: {},
</P><P>	find: {},
</P><P>	relative: {
		&quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
		&quot; &quot;: { dir: &quot;parentNode&quot; },
		&quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
		&quot;~&quot;: { dir: &quot;previousSibling&quot; }
	},
</P><P>	preFilter: {
		&quot;ATTR&quot;: function( match ) {
			match[1] = match[1].replace( runescape, funescape );
</P><P>			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );
</P><P>			if ( match[2] === &quot;~=&quot; ) {
				match[3] = &quot; &quot; + match[3] + &quot; &quot;;
			}
</P><P>			return match.slice( 0, 4 );
		},
</P><P>		&quot;CHILD&quot;: function( match ) {
			/* matches from matchExpr[&quot;CHILD&quot;]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();
</P><P>			if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}
</P><P>				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; );
</P><P>			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}
</P><P>			return match;
		},
</P><P>		&quot;PSEUDO&quot;: function( match ) {
			var excess,
				unquoted = !match[6] &amp;&amp; match[2];
</P><P>			if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
				return null;
			}
</P><P>			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || &quot;&quot;;
</P><P>			// Strip excess characters from unquoted arguments
			} else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &amp;&amp;
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {
</P><P>				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}
</P><P>			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},
</P><P>	filter: {
</P><P>		&quot;TAG&quot;: function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === &quot;*&quot; ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
				};
		},
</P><P>		&quot;CLASS&quot;: function( className ) {
			var pattern = classCache[ className + &quot; &quot; ];
</P><P>			return pattern ||
				(pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== &quot;undefined&quot; &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; );
				});
		},
</P><P>		&quot;ATTR&quot;: function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );
</P><P>				if ( result == null ) {
					return operator === &quot;!=&quot;;
				}
				if ( !operator ) {
					return true;
				}
</P><P>				result += &quot;&quot;;
</P><P>				return operator === &quot;=&quot; ? result === check :
					operator === &quot;!=&quot; ? result !== check :
					operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
					operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
					operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check :
					operator === &quot;~=&quot; ? ( &quot; &quot; + result.replace( rwhitespace, &quot; &quot; ) + &quot; &quot; ).indexOf( check ) &gt; -1 :
					operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; :
					false;
			};
		},
</P><P>		&quot;CHILD&quot;: function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== &quot;nth&quot;,
				forward = type.slice( -4 ) !== &quot;last&quot;,
				ofType = what === &quot;of-type&quot;;
</P><P>			return first === 1 &amp;&amp; last === 0 ?
</P><P>				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :
</P><P>				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
						parent = elem.parentNode,
						name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
						useCache = !xml &amp;&amp; !ofType,
						diff = false;
</P><P>					if ( parent ) {
</P><P>						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {
</P><P>										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
							}
							return true;
						}
</P><P>						start = [ forward ? parent.firstChild : parent.lastChild ];
</P><P>						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward &amp;&amp; useCache ) {
</P><P>							// Seek `elem` from a previously-cached index
</P><P>							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});
</P><P>							// Support: IE &lt;9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});
</P><P>							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];
							diff = nodeIndex &amp;&amp; cache[ 2 ];
							node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];
</P><P>							while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
</P><P>								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {
</P><P>								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}
</P><P>						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});
</P><P>								// Support: IE &lt;9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});
</P><P>								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];
								diff = nodeIndex;
							}
</P><P>							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {
</P><P>									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &amp;&amp;
										++diff ) {
</P><P>										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});
</P><P>											// Support: IE &lt;9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});
</P><P>											uniqueCache[ type ] = [ dirruns, diff ];
										}
</P><P>										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}
</P><P>						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
					}
				};
		},
</P><P>		&quot;PSEUDO&quot;: function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/selectors/#pseudo-classes">http://www.w3.org/TR/selectors/#pseudo-classes</A>
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );
</P><P>			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}
</P><P>			// But maintain support for old signatures
			if ( fn.length &gt; 1 ) {
				args = [ pseudo, pseudo, &quot;&quot;, argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}
</P><P>			return fn;
		}
	},
</P><P>	pseudos: {
		// Potentially complex pseudos
		&quot;not&quot;: markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );
</P><P>			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;
</P><P>					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),
</P><P>		&quot;has&quot;: markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length &gt; 0;
			};
		}),
</P><P>		&quot;contains&quot;: markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
			};
		}),
</P><P>		// &quot;Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by &quot;-&quot;.
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name.&quot;
		// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/selectors/#lang-pseudo">http://www.w3.org/TR/selectors/#lang-pseudo</A>
		&quot;lang&quot;: markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || &quot;&quot;) ) {
				Sizzle.error( &quot;unsupported lang: &quot; + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) {
</P><P>						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0;
					}
				} while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );
				return false;
			};
		}),
</P><P>		// Miscellaneous
		&quot;target&quot;: function( elem ) {
			var hash = window.location &amp;&amp; window.location.hash;
			return hash &amp;&amp; hash.slice( 1 ) === elem.id;
		},
</P><P>		&quot;root&quot;: function( elem ) {
			return elem === docElem;
		},
</P><P>		&quot;focus&quot;: function( elem ) {
			return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
		},
</P><P>		// Boolean properties
		&quot;enabled&quot;: createDisabledPseudo( false ),
		&quot;disabled&quot;: createDisabledPseudo( true ),
</P><P>		&quot;checked&quot;: function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked">http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</A>
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
		},
</P><P>		&quot;selected&quot;: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
</P><P>			return elem.selected === true;
		},
</P><P>		// Contents
		&quot;empty&quot;: function( elem ) {
			// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/selectors/#empty-pseudo">http://www.w3.org/TR/selectors/#empty-pseudo</A>
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType &lt; 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType &lt; 6 ) {
					return false;
				}
			}
			return true;
		},
</P><P>		&quot;parent&quot;: function( elem ) {
			return !Expr.pseudos[&quot;empty&quot;]( elem );
		},
</P><P>		// Element/input types
		&quot;header&quot;: function( elem ) {
			return rheader.test( elem.nodeName );
		},
</P><P>		&quot;input&quot;: function( elem ) {
			return rinputs.test( elem.nodeName );
		},
</P><P>		&quot;button&quot;: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
		},
</P><P>		&quot;text&quot;: function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
				elem.type === &quot;text&quot; &amp;&amp;</P><P>				// Support: IE&lt;8
				// New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;
				( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === &quot;text&quot; );
		},
</P><P>		// Position-in-collection
		&quot;first&quot;: createPositionalPseudo(function() {
			return [ 0 ];
		}),
</P><P>		&quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),
</P><P>		&quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument &lt; 0 ? argument + length : argument ];
		}),
</P><P>		&quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i &lt; length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),
</P><P>		&quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i &lt; length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),
</P><P>		&quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument &lt; 0 ? argument + length : argument;
			for ( ; --i &gt;= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),
</P><P>		&quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument &lt; 0 ? argument + length : argument;
			for ( ; ++i &lt; length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};
</P><P>Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];
</P><P>// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}
</P><P>// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();
</P><P>tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + &quot; &quot; ];
</P><P>	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}
</P><P>	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;
</P><P>	while ( soFar ) {
</P><P>		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}
</P><P>		matched = false;
</P><P>		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, &quot; &quot; )
			});
			soFar = soFar.slice( matched.length );
		}
</P><P>		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}
</P><P>		if ( !matched ) {
			break;
		}
	}
</P><P>	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};
</P><P>function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = &quot;&quot;;
	for ( ; i &lt; len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}
</P><P>function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base &amp;&amp; key === &quot;parentNode&quot;,
		doneName = done++;
</P><P>	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :
</P><P>		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];
</P><P>			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
</P><P>						// Support: IE &lt;9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
</P><P>						if ( skip &amp;&amp; skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &amp;&amp;
							oldCache[ 0 ] === dirruns &amp;&amp; oldCache[ 1 ] === doneName ) {
</P><P>							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;
</P><P>							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}
</P><P>function elementMatcher( matchers ) {
	return matchers.length &gt; 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}
</P><P>function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i &lt; len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}
</P><P>function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;
</P><P>	for ( ; i &lt; len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}
</P><P>	return newUnmatched;
}
</P><P>function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,
</P><P>			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),
</P><P>			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,
</P><P>			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
</P><P>					// ...intermediate processing is necessary
					[] :
</P><P>					// ...otherwise use results directly
					results :
				matcherIn;
</P><P>		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}
</P><P>		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );
</P><P>			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}
</P><P>		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}
</P><P>				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &amp;&amp;
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) &gt; -1 ) {
</P><P>						seed[temp] = !(results[temp] = elem);
					}
				}
			}
</P><P>		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}
</P><P>function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
		i = leadingRelative ? 1 : 0,
</P><P>		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) &gt; -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];
</P><P>	for ( ; i &lt; len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
</P><P>			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j &lt; len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i &gt; 1 &amp;&amp; elementMatcher( matchers ),
					i &gt; 1 &amp;&amp; toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
					).replace( rtrim, &quot;$1&quot; ),
					matcher,
					i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
					j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
					j &lt; len &amp;&amp; toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}
</P><P>	return elementMatcher( matchers );
}
</P><P>function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length &gt; 0,
		byElement = elementMatchers.length &gt; 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = &quot;0&quot;,
				unmatched = seed &amp;&amp; [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;
</P><P>			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}
</P><P>			// Add elements passing elementMatchers directly to results
			// Support: IE&lt;9, Safari
			// Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id
			for ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) {
				if ( byElement &amp;&amp; elem ) {
					j = 0;
					if ( !context &amp;&amp; elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}
</P><P>				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher &amp;&amp; elem) ) {
						matchedCount--;
					}
</P><P>					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}
</P><P>			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;
</P><P>			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string &quot;0&quot; `i` allows `i` to remain a string only in that
			// case, which will result in a &quot;00&quot; `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet &amp;&amp; i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}
</P><P>				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount &gt; 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}
</P><P>					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}
</P><P>				// Add matches to results
				push.apply( results, setMatched );
</P><P>				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
					( matchedCount + setMatchers.length ) &gt; 1 ) {
</P><P>					Sizzle.uniqueSort( results );
				}
			}
</P><P>			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}
</P><P>			return unmatched;
		};
</P><P>	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}
</P><P>compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + &quot; &quot; ];
</P><P>	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}
</P><P>		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
</P><P>		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};
</P><P>/**
</P><PRE>* A low-level selection function that works with Sizzle's compiled
*  selector functions
* @param {String|Function} selector A selector or a pre-compiled
*  selector function built with Sizzle.compile
* @param {Element} context
* @param {Array} [results]
* @param {Array} [seed] A set of elements to match against
*/
</PRE><P>select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === &quot;function&quot; &amp;&amp; selector,
		match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) );
</P><P>	results = results || [];
</P><P>	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {
</P><P>		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
				context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp; Expr.relative[ tokens[1].type ] ) {
</P><P>			context = ( Expr.find[&quot;ID&quot;]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;
</P><P>			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}
</P><P>			selector = selector.slice( tokens.shift().value.length );
		}
</P><P>		// Fetch a seed set for right-to-left matching
		i = matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];
</P><P>			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context
				)) ) {
</P><P>					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length &amp;&amp; toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}
</P><P>					break;
				}
			}
		}
	}
</P><P>	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context
	);
	return results;
};
</P><P>// One-time assignments
</P><P>// Sort stability
support.sortStable = expando.split(&quot;&quot;).sort( sortOrder ).join(&quot;&quot;) === expando;
</P><P>// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;
</P><P>// Initialize against the default document
setDocument();
</P><P>// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement(&quot;fieldset&quot;) ) &amp; 1;
});
</P><P>// Support: IE&lt;8
// Prevent attribute/property &quot;interpolation&quot;
// <A rel="nofollow" class="external free" href="https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx">https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</A>
if ( !assert(function( el ) {
	el.innerHTML = &quot;&lt;a href='#'&gt;&lt;/a&gt;&quot;;
	return el.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot; ;
}) ) {
	addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === &quot;type&quot; ? 1 : 2 );
		}
	});
}
</P><P>// Support: IE&lt;9
// Use defaultValue in place of getAttribute(&quot;value&quot;)
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = &quot;&lt;input/&gt;&quot;;
	el.firstChild.setAttribute( &quot;value&quot;, &quot;&quot; );
	return el.firstChild.getAttribute( &quot;value&quot; ) === &quot;&quot;;
}) ) {
	addHandle( &quot;value&quot;, function( elem, name, isXML ) {
		if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot; ) {
			return elem.defaultValue;
		}
	});
}
</P><P>// Support: IE&lt;9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute(&quot;disabled&quot;) == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?
					val.value :
				null;
		}
	});
}
</P><P>return Sizzle;
</P><P>})( window );
</P><P>jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
</P><P>// Deprecated
jQuery.expr[ &quot;:&quot; ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;
</P><P>
var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;
</P><P>	while ( ( elem = elem[ dir ] ) &amp;&amp; elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate &amp;&amp; jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};
</P><P>
var siblings = function( n, elem ) {
	var matched = [];
</P><P>	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 &amp;&amp; n !== elem ) {
			matched.push( n );
		}
	}
</P><P>	return matched;
};
</P><P>
var rneedsContext = jQuery.expr.match.needsContext;
</P><P>function nodeName( elem, name ) {
</P><PRE> return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
</PRE><P>};
var rsingleTag = ( /^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i );
</P><P>var risSimple = /^.[^:#\[\.,]*$/;
</P><P>// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}
</P><P>	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}
</P><P>	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== &quot;string&quot; ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) &gt; -1 ) !== not;
		} );
	}
</P><P>	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}
</P><P>	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) &gt; -1 ) !== not &amp;&amp; elem.nodeType === 1;
	} );
}
</P><P>jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];
</P><P>	if ( not ) {
		expr = &quot;:not(&quot; + expr + &quot;)&quot;;
	}
</P><P>	if ( elems.length === 1 &amp;&amp; elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}
</P><P>	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};
</P><P>jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;
</P><P>		if ( typeof selector !== &quot;string&quot; ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i &lt; len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}
</P><P>		ret = this.pushStack( [] );
</P><P>		for ( i = 0; i &lt; len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}
</P><P>		return len &gt; 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,
</P><P>			// If this is a positional/relative selector, check membership in the returned set
			// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won't return true for a doc with two &quot;p&quot;.
			typeof selector === &quot;string&quot; &amp;&amp; rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );
</P><P>
// Initialize a jQuery object
</P><P>
// A central reference to the root jQuery(document)
var rootjQuery,
</P><P>	// A simple way to check for HTML strings
	// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with &lt;)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/,
</P><P>	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;
</P><P>		// HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}
</P><P>		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;
</P><P>		// Handle HTML strings
		if ( typeof selector === &quot;string&quot; ) {
			if ( selector[ 0 ] === &quot;&lt;&quot; &amp;&amp;
				selector[ selector.length - 1 ] === &quot;&gt;&quot; &amp;&amp;
				selector.length &gt;= 3 ) {
</P><P>				// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
				match = [ null, selector, null ];
</P><P>			} else {
				match = rquickExpr.exec( selector );
			}
</P><P>			// Match html or make sure no context is specified for #id
			if ( match &amp;&amp; ( match[ 1 ] || !context ) ) {
</P><P>				// HANDLE: $(html) -&gt; $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;
</P><P>					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
						true
					) );
</P><P>					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
</P><P>							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );
</P><P>							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}
</P><P>					return this;
</P><P>				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );
</P><P>					if ( elem ) {
</P><P>						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}
</P><P>			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );
</P><P>			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}
</P><P>		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;
</P><P>		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :
</P><P>				// Execute immediately if ready is not present
				selector( jQuery );
		}
</P><P>		return jQuery.makeArray( selector, this );
	};
</P><P>// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;
</P><P>// Initialize central reference
rootjQuery = jQuery( document );
</P><P>
var rparentsprev = /^(?:parents|prev(?:Until|All))/,
</P><P>	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};
</P><P>jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;
</P><P>		return this.filter( function() {
			var i = 0;
			for ( ; i &lt; l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},
</P><P>	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== &quot;string&quot; &amp;&amp; jQuery( selectors );
</P><P>		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i &lt; l; i++ ) {
				for ( cur = this[ i ]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) {
</P><P>					// Always skip document fragments
					if ( cur.nodeType &lt; 11 &amp;&amp; ( targets ?
						targets.index( cur ) &gt; -1 :
</P><P>						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &amp;&amp;
							jQuery.find.matchesSelector( cur, selectors ) ) ) {
</P><P>						matched.push( cur );
						break;
					}
				}
			}
		}
</P><P>		return this.pushStack( matched.length &gt; 1 ? jQuery.uniqueSort( matched ) : matched );
	},
</P><P>	// Determine the position of an element within the set
	index: function( elem ) {
</P><P>		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] &amp;&amp; this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}
</P><P>		// Index in selector
		if ( typeof elem === &quot;string&quot; ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}
</P><P>		// Locate the position of the desired element
		return indexOf.call( this,
</P><P>			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},
</P><P>	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},
</P><P>	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );
</P><P>function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) &amp;&amp; cur.nodeType !== 1 ) {}
	return cur;
}
</P><P>jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, &quot;parentNode&quot; );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, &quot;parentNode&quot;, until );
	},
	next: function( elem ) {
		return sibling( elem, &quot;nextSibling&quot; );
	},
	prev: function( elem ) {
		return sibling( elem, &quot;previousSibling&quot; );
	},
	nextAll: function( elem ) {
		return dir( elem, &quot;nextSibling&quot; );
	},
	prevAll: function( elem ) {
		return dir( elem, &quot;previousSibling&quot; );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, &quot;nextSibling&quot;, until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, &quot;previousSibling&quot;, until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
</P><PRE>       if ( nodeName( elem, &quot;iframe&quot; ) ) {
           return elem.contentDocument;
       }
</PRE><PRE>       // Support: IE 9 - 11 only, iOS 7 only, Android Browser &lt;=4.3 only
       // Treat the template element as a regular one in browsers that
       // don't support it.
       if ( nodeName( elem, &quot;template&quot; ) ) {
           elem = elem.content || elem;
       }
</PRE><PRE>       return jQuery.merge( [], elem.childNodes );
</PRE><P>	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );
</P><P>		if ( name.slice( -5 ) !== &quot;Until&quot; ) {
			selector = until;
		}
</P><P>		if ( selector &amp;&amp; typeof selector === &quot;string&quot; ) {
			matched = jQuery.filter( selector, matched );
		}
</P><P>		if ( this.length &gt; 1 ) {
</P><P>			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}
</P><P>			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}
</P><P>		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
</P><P>// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}
</P><P>/*
</P><PRE>* Create a callback list using the following parameters:
*
*	options: an optional list of space-separated options that will change how
*			the callback list behaves or a more traditional option object
*
* By default a callback list will act like an event callback list and can be
* &quot;fired&quot; multiple times.
*
* Possible options:
*
*	once:			will ensure the callback list can only be fired once (like a Deferred)
*
*	memory:			will keep track of previous values and will call any callback added
*					after the list has been fired right away with the latest &quot;memorized&quot;
*					values (like a Deferred)
*
*	unique:			will ensure a callback can only be added once (no duplicate in the list)
*
*	stopOnFalse:	interrupt callings when a callback returns false
*
*/
</PRE><P>jQuery.Callbacks = function( options ) {
</P><P>	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === &quot;string&quot; ?
		createOptions( options ) :
		jQuery.extend( {}, options );
</P><P>	var // Flag to know if list is currently firing
		firing,
</P><P>		// Last fire value for non-forgettable lists
		memory,
</P><P>		// Flag to know if list was already fired
		fired,
</P><P>		// Flag to prevent firing
		locked,
</P><P>		// Actual callback list
		list = [],
</P><P>		// Queue of execution data for repeatable lists
		queue = [],</P><P>		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,
</P><P>		// Fire callbacks
		fire = function() {
</P><P>			// Enforce single-firing
			locked = locked || options.once;
</P><P>			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex &lt; list.length ) {
</P><P>					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &amp;&amp;
						options.stopOnFalse ) {
</P><P>						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}
</P><P>			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}
</P><P>			firing = false;
</P><P>			// Clean up if we're done firing for good
			if ( locked ) {
</P><P>				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];
</P><P>				// Otherwise, this object is spent
				} else {
					list = &quot;&quot;;
				}
			}
		},
</P><P>		// Actual Callbacks object
		self = {
</P><P>			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
</P><P>					// If we have memory from a past run, we should fire after adding
					if ( memory &amp;&amp; !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}
</P><P>					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg &amp;&amp; arg.length &amp;&amp; jQuery.type( arg ) !== &quot;string&quot; ) {
</P><P>								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );
</P><P>					if ( memory &amp;&amp; !firing ) {
						fire();
					}
				}
				return this;
			},
</P><P>			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
						list.splice( index, 1 );
</P><P>						// Handle firing indexes
						if ( index &lt;= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},
</P><P>			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) &gt; -1 :
					list.length &gt; 0;
			},
</P><P>			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},
</P><P>			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = &quot;&quot;;
				return this;
			},
			disabled: function() {
				return !list;
			},
</P><P>			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory &amp;&amp; !firing ) {
					list = memory = &quot;&quot;;
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},
</P><P>			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},
</P><P>			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
</P><P>			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};
</P><P>	return self;
};
</P><P>
function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}
</P><P>function adoptValue( value, resolve, reject, noValue ) {
	var method;
</P><P>	try {
</P><P>		// Check for promise aspect first to privilege synchronous behavior
		if ( value &amp;&amp; jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );
</P><P>		// Other thenables
		} else if ( value &amp;&amp; jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );
</P><P>		// Other non-thenables
		} else {
</P><P>			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) =&gt; resolve( value )
			// * true: [ value ].slice( 1 ) =&gt; resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}
</P><P>	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {
</P><P>		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}
</P><P>jQuery.extend( {
</P><P>	Deferred: function( func ) {
		var tuples = [
</P><P>				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks( &quot;memory&quot; ),
					jQuery.Callbacks( &quot;memory&quot; ), 2 ],
				[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
					jQuery.Callbacks( &quot;once memory&quot; ), 0, &quot;resolved&quot; ],
				[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
					jQuery.Callbacks( &quot;once memory&quot; ), 1, &quot;rejected&quot; ]
			],
			state = &quot;pending&quot;,
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				&quot;catch&quot;: function( fn ) {
					return promise.then( null, fn );
				},
</P><P>				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
</P><P>					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
</P><P>							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) &amp;&amp; fns[ tuple[ 4 ] ];
</P><P>							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn &amp;&amp; fn.apply( this, arguments );
								if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + &quot;With&quot; ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;
</P><P>									// Support: Promises/A+ section 2.3.3.3.3
									// <A rel="nofollow" class="external free" href="https://promisesaplus.com/#point-59">https://promisesaplus.com/#point-59</A>
									// Ignore double-resolution attempts
									if ( depth &lt; maxDepth ) {
										return;
									}
</P><P>									returned = handler.apply( that, args );
</P><P>									// Support: Promises/A+ section 2.3.1
									// <A rel="nofollow" class="external free" href="https://promisesaplus.com/#point-48">https://promisesaplus.com/#point-48</A>
									if ( returned === deferred.promise() ) {
										throw new TypeError( &quot;Thenable self-resolution&quot; );
									}
</P><P>									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// <A rel="nofollow" class="external free" href="https://promisesaplus.com/#point-54">https://promisesaplus.com/#point-54</A>
									// <A rel="nofollow" class="external free" href="https://promisesaplus.com/#point-75">https://promisesaplus.com/#point-75</A>
									// Retrieve `then` only once
									then = returned &amp;&amp;</P><P>										// Support: Promises/A+ section 2.3.4
										// <A rel="nofollow" class="external free" href="https://promisesaplus.com/#point-64">https://promisesaplus.com/#point-64</A>
										// Only check objects and functions for thenability
										( typeof returned === &quot;object&quot; ||
											typeof returned === &quot;function&quot; ) &amp;&amp;
										returned.then;
</P><P>									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {
</P><P>										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);
</P><P>										// Normal processors (resolve) also hook into progress
										} else {
</P><P>											// ...and disregard older resolution values
											maxDepth++;
</P><P>											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}
</P><P>									// Handle all other returned values
									} else {
</P><P>										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}
</P><P>										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},
</P><P>								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {
</P><P>											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}
</P><P>											// Support: Promises/A+ section 2.3.3.3.4.1
											// <A rel="nofollow" class="external free" href="https://promisesaplus.com/#point-61">https://promisesaplus.com/#point-61</A>
											// Ignore post-resolution exceptions
											if ( depth + 1 &gt;= maxDepth ) {
</P><P>												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}
</P><P>												deferred.rejectWith( that, args );
											}
										}
									};
</P><P>							// Support: Promises/A+ section 2.3.3.3.1
							// <A rel="nofollow" class="external free" href="https://promisesaplus.com/#point-57">https://promisesaplus.com/#point-57</A>
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {
</P><P>								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}
</P><P>					return jQuery.Deferred( function( newDefer ) {
</P><P>						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);
</P><P>						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);
</P><P>						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},
</P><P>				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};
</P><P>		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];
</P><P>			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;
</P><P>			// Handle state
			if ( stateString ) {
				list.add(
					function() {
</P><P>						// state = &quot;resolved&quot; (i.e., fulfilled)
						// state = &quot;rejected&quot;
						state = stateString;
					},
</P><P>					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,
</P><P>					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}
</P><P>			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );
</P><P>			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + &quot;With&quot; ]( this === deferred ? undefined : this, arguments );
				return this;
			};
</P><P>			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + &quot;With&quot; ] = list.fireWith;
		} );
</P><P>		// Make the deferred a promise
		promise.promise( deferred );
</P><P>		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}
</P><P>		// All done!
		return deferred;
	},
</P><P>	// Deferred helper
	when: function( singleValue ) {
		var
</P><P>			// count of uncompleted subordinates
			remaining = arguments.length,
</P><P>			// count of unprocessed arguments
			i = remaining,
</P><P>			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),
</P><P>			// the master Deferred
			master = jQuery.Deferred(),
</P><P>			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};
</P><P>		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining &lt;= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );
</P><P>			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === &quot;pending&quot; ||
				jQuery.isFunction( resolveValues[ i ] &amp;&amp; resolveValues[ i ].then ) ) {
</P><P>				return master.then();
			}
		}
</P><P>		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}
</P><P>		return master.promise();
	}
} );
</P><P>
// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
</P><P>jQuery.Deferred.exceptionHook = function( error, stack ) {
</P><P>	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console &amp;&amp; window.console.warn &amp;&amp; error &amp;&amp; rerrorNames.test( error.name ) ) {
		window.console.warn( &quot;jQuery.Deferred exception: &quot; + error.message, error.stack, stack );
	}
};
</P><P>
jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};
</P><P>
// The deferred used on DOM ready
var readyList = jQuery.Deferred();
</P><P>jQuery.fn.ready = function( fn ) {
</P><P>	readyList
		.then( fn )
</P><P>		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );
</P><P>	return this;
};
</P><P>jQuery.extend( {
</P><P>	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,
</P><P>	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,
</P><P>	// Handle when the DOM is ready
	ready: function( wait ) {
</P><P>		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}
</P><P>		// Remember that the DOM is ready
		jQuery.isReady = true;
</P><P>		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
			return;
		}
</P><P>		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );
</P><P>jQuery.ready.then = readyList.then;
</P><P>// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( &quot;DOMContentLoaded&quot;, completed );
	window.removeEventListener( &quot;load&quot;, completed );
	jQuery.ready();
}
</P><P>// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE &lt;=9 - 10 only
// Older IE sometimes signals &quot;interactive&quot; too soon
if ( document.readyState === &quot;complete&quot; ||
	( document.readyState !== &quot;loading&quot; &amp;&amp; !document.documentElement.doScroll ) ) {
</P><P>	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );
</P><P>} else {
</P><P>	// Use the handy event callback
	document.addEventListener( &quot;DOMContentLoaded&quot;, completed );
</P><P>	// A fallback to window.onload, that will always work
	window.addEventListener( &quot;load&quot;, completed );
}
</P><P>
// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;
</P><P>	// Sets many values
	if ( jQuery.type( key ) === &quot;object&quot; ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}
</P><P>	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;
</P><P>		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}
</P><P>		if ( bulk ) {
</P><P>			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;
</P><P>			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}
</P><P>		if ( fn ) {
			for ( ; i &lt; len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}
</P><P>	if ( chainable ) {
		return elems;
	}
</P><P>	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}
</P><P>	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {
</P><P>	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};
</P><P>
function Data() {
	this.expando = jQuery.expando + Data.uid++;
}
</P><P>Data.uid = 1;
</P><P>Data.prototype = {
</P><P>	cache: function( owner ) {
</P><P>		// Check if the owner object already has a cache
		var value = owner[ this.expando ];
</P><P>		// If not, create one
		if ( !value ) {
			value = {};
</P><P>			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {
</P><P>				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;
</P><P>				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}
</P><P>		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );
</P><P>		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === &quot;string&quot; ) {
			cache[ jQuery.camelCase( data ) ] = value;
</P><P>		// Handle: [ owner, { properties } ] args
		} else {
</P><P>			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :
</P><P>			// Always use camelCase key (gh-2257)
			owner[ this.expando ] &amp;&amp; owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {
</P><P>		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the &quot;read&quot; path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key &amp;&amp; typeof key === &quot;string&quot; ) &amp;&amp; value === undefined ) ) {
</P><P>			return this.get( owner, key );
		}
</P><P>		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );
</P><P>		// Since the &quot;set&quot; path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];
</P><P>		if ( cache === undefined ) {
			return;
		}
</P><P>		if ( key !== undefined ) {
</P><P>			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {
</P><P>				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );
</P><P>				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}
</P><P>			i = key.length;
</P><P>			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}
</P><P>		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
</P><P>			// Support: Chrome &lt;=35 - 45
			// Webkit &amp; Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// <A rel="nofollow" class="external free" href="https://bugs.chromium.org/p/chromium/issues/detail?id=378607">https://bugs.chromium.org/p/chromium/issues/detail?id=378607</A> (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined &amp;&amp; !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();
</P><P>var dataUser = new Data();
</P><P>//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.
//	4. _Never_ expose &quot;private&quot; data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
</P><P>var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;
</P><P>function getData( data ) {
	if ( data === &quot;true&quot; ) {
		return true;
	}
</P><P>	if ( data === &quot;false&quot; ) {
		return false;
	}
</P><P>	if ( data === &quot;null&quot; ) {
		return null;
	}
</P><P>	// Only convert to a number if it doesn't change the string
	if ( data === +data + &quot;&quot; ) {
		return +data;
	}
</P><P>	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}
</P><P>	return data;
}
</P><P>function dataAttr( elem, key, data ) {
	var name;
</P><P>	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {
		name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$&amp;&quot; ).toLowerCase();
		data = elem.getAttribute( name );
</P><P>		if ( typeof data === &quot;string&quot; ) {
			try {
				data = getData( data );
			} catch ( e ) {}
</P><P>			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}
</P><P>jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},
</P><P>	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},
</P><P>	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},
</P><P>	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},
</P><P>	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );
</P><P>jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem &amp;&amp; elem.attributes;
</P><P>		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );
</P><P>				if ( elem.nodeType === 1 &amp;&amp; !dataPriv.get( elem, &quot;hasDataAttrs&quot; ) ) {
					i = attrs.length;
					while ( i-- ) {
</P><P>						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( &quot;data-&quot; ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, &quot;hasDataAttrs&quot;, true );
				}
			}
</P><P>			return data;
		}
</P><P>		// Sets multiple values
		if ( typeof key === &quot;object&quot; ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}
</P><P>		return access( this, function( value ) {
			var data;
</P><P>			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem &amp;&amp; value === undefined ) {
</P><P>				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}
</P><P>				// Attempt to &quot;discover&quot; the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}
</P><P>				// We tried really hard, but the data doesn't exist.
				return;
			}
</P><P>			// Set the data...
			this.each( function() {
</P><P>				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length &gt; 1, null, true );
	},
</P><P>	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );
</P><P>
jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;
</P><P>		if ( elem ) {
			type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
			queue = dataPriv.get( elem, type );
</P><P>			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},
</P><P>	dequeue: function( elem, type ) {
		type = type || &quot;fx&quot;;
</P><P>		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};
</P><P>		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === &quot;inprogress&quot; ) {
			fn = queue.shift();
			startLength--;
		}
</P><P>		if ( fn ) {
</P><P>			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === &quot;fx&quot; ) {
				queue.unshift( &quot;inprogress&quot; );
			}
</P><P>			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}
</P><P>		if ( !startLength &amp;&amp; hooks ) {
			hooks.empty.fire();
		}
	},
</P><P>	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + &quot;queueHooks&quot;;
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( &quot;once memory&quot; ).add( function() {
				dataPriv.remove( elem, [ type + &quot;queue&quot;, key ] );
			} )
		} );
	}
} );
</P><P>jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;
</P><P>		if ( typeof type !== &quot;string&quot; ) {
			data = type;
			type = &quot;fx&quot;;
			setter--;
		}
</P><P>		if ( arguments.length &lt; setter ) {
			return jQuery.queue( this[ 0 ], type );
		}
</P><P>		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );
</P><P>				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );
</P><P>				if ( type === &quot;fx&quot; &amp;&amp; queue[ 0 ] !== &quot;inprogress&quot; ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || &quot;fx&quot;, [] );
	},
</P><P>	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};
</P><P>		if ( typeof type !== &quot;string&quot; ) {
			obj = type;
			type = undefined;
		}
		type = type || &quot;fx&quot;;
</P><P>		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + &quot;queueHooks&quot; );
			if ( tmp &amp;&amp; tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
</P><P>var rcssNum = new RegExp( &quot;^(?:([+-])=|)(&quot; + pnum + &quot;)([a-z%]*)$&quot;, &quot;i&quot; );
</P><P>
var cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ];
</P><P>var isHiddenWithinTree = function( elem, el ) {
</P><P>		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
</P><P>		// Inline style trumps all
		return elem.style.display === &quot;none&quot; ||
			elem.style.display === &quot;&quot; &amp;&amp;</P><P>			// Otherwise, check computed style
			// Support: Firefox &lt;=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &amp;&amp;</P><P>			jQuery.css( elem, &quot;display&quot; ) === &quot;none&quot;;
	};
</P><P>var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};
</P><P>	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}
</P><P>	ret = callback.apply( elem, args || [] );
</P><P>	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}
</P><P>	return ret;
};
</P><P>
function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, &quot;&quot; );
			},
		initial = currentValue(),
		unit = valueParts &amp;&amp; valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; ),
</P><P>		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== &quot;px&quot; &amp;&amp; +initial ) &amp;&amp;
			rcssNum.exec( jQuery.css( elem, prop ) );
</P><P>	if ( initialInUnit &amp;&amp; initialInUnit[ 3 ] !== unit ) {
</P><P>		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];
</P><P>		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
</P><P>		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;
</P><P>		do {
</P><P>			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || &quot;.5&quot;;
</P><P>			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );
</P><P>		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) &amp;&amp; scale !== 1 &amp;&amp; --maxIterations
		);
	}
</P><P>	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;
</P><P>		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}
</P><P>
var defaultDisplayMap = {};
</P><P>function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];
</P><P>	if ( display ) {
		return display;
	}
</P><P>	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, &quot;display&quot; );
</P><P>	temp.parentNode.removeChild( temp );
</P><P>	if ( display === &quot;none&quot; ) {
		display = &quot;block&quot;;
	}
	defaultDisplayMap[ nodeName ] = display;
</P><P>	return display;
}
</P><P>function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;
</P><P>	// Determine new display value for elements that need to change
	for ( ; index &lt; length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
</P><P>		display = elem.style.display;
		if ( show ) {
</P><P>			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === &quot;none&quot; ) {
				values[ index ] = dataPriv.get( elem, &quot;display&quot; ) || null;
				if ( !values[ index ] ) {
					elem.style.display = &quot;&quot;;
				}
			}
			if ( elem.style.display === &quot;&quot; &amp;&amp; isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== &quot;none&quot; ) {
				values[ index ] = &quot;none&quot;;
</P><P>				// Remember what we're overwriting
				dataPriv.set( elem, &quot;display&quot;, display );
			}
		}
	}
</P><P>	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index &lt; length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}
</P><P>	return elements;
}
</P><P>jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === &quot;boolean&quot; ) {
			return state ? this.show() : this.hide();
		}
</P><P>		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );
</P><P>var rtagName = ( /&lt;([a-z][^\/\0&gt;\x20\t\r\n\f]+)/i );
</P><P>var rscriptType = ( /^$|\/(?:java|ecma)script/i );
</P><P>// We have to close these tags to support XHTML (#13200)
var wrapMap = {
</P><P>	// Support: IE &lt;=9 only
	option: [ 1, &quot;&lt;select multiple='multiple'&gt;&quot;, &quot;&lt;/select&gt;&quot; ],
</P><P>	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting &lt;tbody&gt; or other required elements.
</P>
	thead: [ 1, &quot;<TABLE>&quot;, &quot;</TABLE>&quot; ],
	col: [ 2, &quot;<TABLE>&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;</TABLE>&quot; ],
	tr: [ 2, &quot;<TABLE>&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;</TABLE>&quot; ],
	td: [ 3, &quot;<TABLE>&lt;tbody&gt;<TBODY><TR>&quot;, &quot;</TR>&lt;/tbody&gt;</TBODY></TABLE>&quot; ],
<P>	_default: [ 0, &quot;&quot;, &quot;&quot; ]
};
</P><P>// Support: IE &lt;=9 only
wrapMap.optgroup = wrapMap.option;
</P><P>wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;
</P><P>
function getAll( context, tag ) {
</P><P>	// Support: IE &lt;=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;
</P><P>	if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
		ret = context.getElementsByTagName( tag || &quot;*&quot; );
</P><P>	} else if ( typeof context.querySelectorAll !== &quot;undefined&quot; ) {
		ret = context.querySelectorAll( tag || &quot;*&quot; );
</P><P>	} else {
		ret = [];
	}
</P><P>	if ( tag === undefined || tag &amp;&amp; nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}
</P><P>	return ret;
}
</P><P>
// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;
</P><P>	for ( ; i &lt; l; i++ ) {
		dataPriv.set(
			elems[ i ],
			&quot;globalEval&quot;,
			!refElements || dataPriv.get( refElements[ i ], &quot;globalEval&quot; )
		);
	}
}
</P><P>
var rhtml = /&lt;|&amp;#?\w+;/;
</P><P>function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;
</P><P>	for ( ; i &lt; l; i++ ) {
		elem = elems[ i ];
</P><P>		if ( elem || elem === 0 ) {
</P><P>			// Add nodes directly
			if ( jQuery.type( elem ) === &quot;object&quot; ) {
</P><P>				// Support: Android &lt;=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
</P><P>			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );
</P><P>			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( &quot;div&quot; ) );
</P><P>				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
</P><P>				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}
</P><P>				// Support: Android &lt;=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );
</P><P>				// Remember the top-level container
				tmp = fragment.firstChild;
</P><P>				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = &quot;&quot;;
			}
		}
	}
</P><P>	// Remove wrapper from fragment
	fragment.textContent = &quot;&quot;;
</P><P>	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {
</P><P>		// Skip elements already in the context collection (trac-4087)
		if ( selection &amp;&amp; jQuery.inArray( elem, selection ) &gt; -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}
</P><P>		contains = jQuery.contains( elem.ownerDocument, elem );
</P><P>		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), &quot;script&quot; );
</P><P>		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}
</P><P>		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || &quot;&quot; ) ) {
					scripts.push( elem );
				}
			}
		}
	}
</P><P>	return fragment;
}
</P><P>
( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( &quot;div&quot; ) ),
		input = document.createElement( &quot;input&quot; );
</P><P>	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( &quot;type&quot;, &quot;radio&quot; );
	input.setAttribute( &quot;checked&quot;, &quot;checked&quot; );
	input.setAttribute( &quot;name&quot;, &quot;t&quot; );
</P><P>	div.appendChild( input );
</P><P>	// Support: Android &lt;=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
</P><P>	// Support: IE &lt;=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = &quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;;
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;
</P><P>var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
</P><P>function returnTrue() {
	return true;
}
</P><P>function returnFalse() {
	return false;
}
</P><P>// Support: IE &lt;=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}
</P><P>function on( elem, types, selector, data, fn, one ) {
	var origFn, type;
</P><P>	// Types can be a map of types/handlers
	if ( typeof types === &quot;object&quot; ) {
</P><P>		// ( types-Object, selector, data )
		if ( typeof selector !== &quot;string&quot; ) {
</P><P>			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}
</P><P>	if ( data == null &amp;&amp; fn == null ) {
</P><P>		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === &quot;string&quot; ) {
</P><P>			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {
</P><P>			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}
</P><P>	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {
</P><P>			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};
</P><P>		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}
</P><P>/*
</P><PRE>* Helper functions for managing events -- not part of the public interface.
* Props to Dean Edwards' addEvent library for many of the ideas.
*/
</PRE><P>jQuery.event = {
</P><P>	global: {},
</P><P>	add: function( elem, types, handler, data, selector ) {
</P><P>		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );
</P><P>		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}
</P><P>		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}
</P><P>		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}
</P><P>		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}
</P><P>		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {
</P><P>				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== &quot;undefined&quot; &amp;&amp; jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}
</P><P>		// Handle multiple events separated by a space
		types = ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();
</P><P>			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}
</P><P>			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};
</P><P>			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;
</P><P>			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};
</P><P>			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( &quot;.&quot; )
			}, handleObjIn );
</P><P>			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;
</P><P>				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
</P><P>					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}
</P><P>			if ( special.add ) {
				special.add.call( elem, handleObj );
</P><P>				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}
</P><P>			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}
</P><P>			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}
</P><P>	},
</P><P>	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
</P><P>		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) &amp;&amp; dataPriv.get( elem );
</P><P>		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}
</P><P>		// Once for each type.namespace in types; type may be omitted
		types = ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();
</P><P>			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}
</P><P>			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &amp;&amp;
				new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; );
</P><P>			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];
</P><P>				if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
					( !handler || handler.guid === handleObj.guid ) &amp;&amp;
					( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
					( !selector || selector === handleObj.selector ||
						selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
					handlers.splice( j, 1 );
</P><P>					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}
</P><P>			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount &amp;&amp; !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
</P><P>					jQuery.removeEvent( elem, type, elemData.handle );
				}
</P><P>				delete events[ type ];
			}
		}
</P><P>		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, &quot;handle events&quot; );
		}
	},
</P><P>	dispatch: function( nativeEvent ) {
</P><P>		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );
</P><P>		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, &quot;events&quot; ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};
</P><P>		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
</P><P>		for ( i = 1; i &lt; arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}
</P><P>		event.delegateTarget = this;
</P><P>		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
			return;
		}
</P><P>		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );
</P><P>		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;
</P><P>			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &amp;&amp;
				!event.isImmediatePropagationStopped() ) {
</P><P>				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
</P><P>					event.handleObj = handleObj;
					event.data = handleObj.data;
</P><P>					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );
</P><P>					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}
</P><P>		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}
</P><P>		return event.result;
	},
</P><P>	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;
</P><P>		// Find delegate handlers
		if ( delegateCount &amp;&amp;</P><P>			// Support: IE &lt;=9
			// Black-hole SVG &lt;use&gt; instance trees (trac-13180)
			cur.nodeType &amp;&amp;</P><P>			// Support: Firefox &lt;=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// <A rel="nofollow" class="external free" href="https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click">https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click</A>
			// Support: IE 11 only
			// ...but not arrow key &quot;clicks&quot; of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === &quot;click&quot; &amp;&amp; event.button &gt;= 1 ) ) {
</P><P>			for ( ; cur !== this; cur = cur.parentNode || this ) {
</P><P>				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 &amp;&amp; !( event.type === &quot;click&quot; &amp;&amp; cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i &lt; delegateCount; i++ ) {
						handleObj = handlers[ i ];
</P><P>						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + &quot; &quot;;
</P><P>						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) &gt; -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}
</P><P>		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount &lt; handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}
</P><P>		return handlerQueue;
	},
</P><P>	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,
</P><P>			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},
</P><P>			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},
</P><P>	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},
</P><P>	special: {
		load: {
</P><P>			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
</P><P>			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() &amp;&amp; this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: &quot;focusin&quot;
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() &amp;&amp; this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: &quot;focusout&quot;
		},
		click: {
</P><P>			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === &quot;checkbox&quot; &amp;&amp; this.click &amp;&amp; nodeName( this, &quot;input&quot; ) ) {
					this.click();
					return false;
				}
			},
</P><P>			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, &quot;a&quot; );
			}
		},
</P><P>		beforeunload: {
			postDispatch: function( event ) {
</P><P>				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined &amp;&amp; event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};
</P><P>jQuery.removeEvent = function( elem, type, handle ) {
</P><P>	// This &quot;if&quot; is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};
</P><P>jQuery.Event = function( src, props ) {
</P><P>	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}
</P><P>	// Event object
	if ( src &amp;&amp; src.type ) {
		this.originalEvent = src;
		this.type = src.type;
</P><P>		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &amp;&amp;</P><P>				// Support: Android &lt;=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;
</P><P>		// Create target properties
		// Support: Safari &lt;=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target &amp;&amp; src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;
</P><P>		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;
</P><P>	// Event type
	} else {
		this.type = src;
	}
</P><P>	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}
</P><P>	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();
</P><P>	// Mark it as fixed
	this[ jQuery.expando ] = true;
};
</P><P>// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// <A rel="nofollow" class="external free" href="https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html">https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html</A>
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,
</P><P>	preventDefault: function() {
		var e = this.originalEvent;
</P><P>		this.isDefaultPrevented = returnTrue;
</P><P>		if ( e &amp;&amp; !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;
</P><P>		this.isPropagationStopped = returnTrue;
</P><P>		if ( e &amp;&amp; !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;
</P><P>		this.isImmediatePropagationStopped = returnTrue;
</P><P>		if ( e &amp;&amp; !this.isSimulated ) {
			e.stopImmediatePropagation();
		}
</P><P>		this.stopPropagation();
	}
};
</P><P>// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	&quot;char&quot;: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
</P><P>	which: function( event ) {
		var button = event.button;
</P><P>		// Add which for key events
		if ( event.which == null &amp;&amp; rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}
</P><P>		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which &amp;&amp; button !== undefined &amp;&amp; rmouseEvent.test( event.type ) ) {
			if ( button &amp; 1 ) {
				return 1;
			}
</P><P>			if ( button &amp; 2 ) {
				return 3;
			}
</P><P>			if ( button &amp; 4 ) {
				return 2;
			}
</P><P>			return 0;
		}
</P><P>		return event.which;
	}
}, jQuery.event.addProp );
</P><P>// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// <A rel="nofollow" class="external free" href="https://bugs.chromium.org/p/chromium/issues/detail?id=470258">https://bugs.chromium.org/p/chromium/issues/detail?id=470258</A>
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: &quot;mouseover&quot;,
	mouseleave: &quot;mouseout&quot;,
	pointerenter: &quot;pointerover&quot;,
	pointerleave: &quot;pointerout&quot;
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,
</P><P>		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;
</P><P>			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target &amp;&amp; !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );
</P><P>jQuery.fn.extend( {
</P><P>	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
</P><P>			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + &quot;.&quot; + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === &quot;object&quot; ) {
</P><P>			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === &quot;function&quot; ) {
</P><P>			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );
</P><P>
var
</P><P>	/* eslint-disable max-len */
</P><P>	// See <A rel="nofollow" class="external free" href="https://github.com/eslint/eslint/issues/3229">https://github.com/eslint/eslint/issues/3229</A>
	rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi,
</P><P>	/* eslint-enable */
</P><P>	// Support: IE &lt;=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See <A rel="nofollow" class="external free" href="https://connect.microsoft.com/IE/feedback/details/1736512/">https://connect.microsoft.com/IE/feedback/details/1736512/</A>
	rnoInnerhtml = /&lt;script|&lt;style|&lt;link/i,
</P><P>	// checked=&quot;checked&quot; or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g;
</P><P>// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, &quot;table&quot; ) &amp;&amp;
		nodeName( content.nodeType !== 11 ? content : content.firstChild, &quot;tr&quot; ) ) {
</P><P>		return jQuery( &quot;&gt;tbody&quot;, elem )[ 0 ] || elem;
	}
</P><P>	return elem;
}
</P><P>// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( &quot;type&quot; ) !== null ) + &quot;/&quot; + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
</P><P>	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( &quot;type&quot; );
	}
</P><P>	return elem;
}
</P><P>function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
</P><P>	if ( dest.nodeType !== 1 ) {
		return;
	}
</P><P>	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;
</P><P>		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};
</P><P>			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}
</P><P>	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );
</P><P>		dataUser.set( dest, udataCur );
	}
}
</P><P>// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();
</P><P>	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === &quot;input&quot; &amp;&amp; rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;
</P><P>	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === &quot;input&quot; || nodeName === &quot;textarea&quot; ) {
		dest.defaultValue = src.defaultValue;
	}
}
</P><P>function domManip( collection, args, callback, ignored ) {
</P><P>	// Flatten any nested arrays
	args = concat.apply( [], args );
</P><P>	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );
</P><P>	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l &gt; 1 &amp;&amp; typeof value === &quot;string&quot; &amp;&amp;
				!support.checkClone &amp;&amp; rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}
</P><P>	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;
</P><P>		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}
</P><P>		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, &quot;script&quot; ), disableScript );
			hasScripts = scripts.length;
</P><P>			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i &lt; l; i++ ) {
				node = fragment;
</P><P>				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );
</P><P>					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {
</P><P>						// Support: Android &lt;=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, &quot;script&quot; ) );
					}
				}
</P><P>				callback.call( collection[ i ], node, i );
			}
</P><P>			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;
</P><P>				// Reenable scripts
				jQuery.map( scripts, restoreScript );
</P><P>				// Evaluate executable scripts on first document insertion
				for ( i = 0; i &lt; hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || &quot;&quot; ) &amp;&amp;
						!dataPriv.access( node, &quot;globalEval&quot; ) &amp;&amp;
						jQuery.contains( doc, node ) ) {
</P><P>						if ( node.src ) {
</P><P>							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, &quot;&quot; ), doc );
						}
					}
				}
			}
		}
	}
</P><P>	return collection;
}</P><P>function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;
</P><P>	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData &amp;&amp; node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}
</P><P>		if ( node.parentNode ) {
			if ( keepData &amp;&amp; jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, &quot;script&quot; ) );
			}
			node.parentNode.removeChild( node );
		}
	}
</P><P>	return elem;
}
</P><P>jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );
	},
</P><P>	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );
</P><P>		// Fix IE cloning issues
		if ( !support.noCloneChecked &amp;&amp; ( elem.nodeType === 1 || elem.nodeType === 11 ) &amp;&amp;
				!jQuery.isXMLDoc( elem ) ) {
</P><P>			// We eschew Sizzle here for performance reasons: <A rel="nofollow" class="external free" href="https://jsperf.com/getall-vs-sizzle/2">https://jsperf.com/getall-vs-sizzle/2</A>
			destElements = getAll( clone );
			srcElements = getAll( elem );
</P><P>			for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}
</P><P>		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );
</P><P>				for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}
</P><P>		// Preserve script evaluation history
		destElements = getAll( clone, &quot;script&quot; );
		if ( destElements.length &gt; 0 ) {
			setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, &quot;script&quot; ) );
		}
</P><P>	// Return the cloned set
		return clone;
	},
</P><P>	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;
</P><P>		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );
</P><P>							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
</P><P>					// Support: Chrome &lt;=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {
</P><P>					// Support: Chrome &lt;=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );
</P><P>jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},
</P><P>	remove: function( selector ) {
		return remove( this, selector );
	},
</P><P>	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},
</P><P>	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},
</P><P>	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},
</P><P>	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},
</P><P>	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},
</P><P>	empty: function() {
		var elem,
			i = 0;
</P><P>		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {
</P><P>				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );
</P><P>				// Remove any remaining nodes
				elem.textContent = &quot;&quot;;
			}
		}
</P><P>		return this;
	},
</P><P>	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
</P><P>		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},
</P><P>	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;
</P><P>			if ( value === undefined &amp;&amp; elem.nodeType === 1 ) {
				return elem.innerHTML;
			}
</P><P>			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;
				!wrapMap[ ( rtagName.exec( value ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase() ] ) {
</P><P>				value = jQuery.htmlPrefilter( value );
</P><P>				try {
					for ( ; i &lt; l; i++ ) {
						elem = this[ i ] || {};
</P><P>						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}
</P><P>					elem = 0;
</P><P>				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}
</P><P>			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},
</P><P>	replaceWith: function() {
		var ignored = [];
</P><P>		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;
</P><P>			if ( jQuery.inArray( this, ignored ) &lt; 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}
</P><P>		// Force callback invocation
		}, ignored );
	}
} );
</P><P>jQuery.each( {
	appendTo: &quot;append&quot;,
	prependTo: &quot;prepend&quot;,
	insertBefore: &quot;before&quot;,
	insertAfter: &quot;after&quot;,
	replaceAll: &quot;replaceWith&quot;
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;
</P><P>		for ( ; i &lt;= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );
</P><P>			// Support: Android &lt;=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}
</P><P>		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );
</P><P>var rnumnonpx = new RegExp( &quot;^(&quot; + pnum + &quot;)(?!px)[a-z%]+$&quot;, &quot;i&quot; );
</P><P>var getStyles = function( elem ) {
</P><P>		// Support: IE &lt;=11 only, Firefox &lt;=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through &quot;defaultView.getComputedStyle&quot;
		var view = elem.ownerDocument.defaultView;
</P><P>		if ( !view || !view.opener ) {
			view = window;
		}
</P><P>		return view.getComputedStyle( elem );
	};
</P><P>( function() {
</P><P>	// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {
</P><P>		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}
</P><P>		div.style.cssText =
			&quot;box-sizing:border-box;&quot; +
			&quot;position:relative;display:block;&quot; +
			&quot;margin:auto;border:1px;padding:1px;&quot; +
			&quot;top:1%;width:50%&quot;;
		div.innerHTML = &quot;&quot;;
		documentElement.appendChild( container );
</P><P>		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== &quot;1%&quot;;
</P><P>		// Support: Android 4.0 - 4.3 only, Firefox &lt;=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === &quot;2px&quot;;
		boxSizingReliableVal = divStyle.width === &quot;4px&quot;;
</P><P>		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = &quot;50%&quot;;
		pixelMarginRightVal = divStyle.marginRight === &quot;4px&quot;;
</P><P>		documentElement.removeChild( container );
</P><P>		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}
</P><P>	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( &quot;div&quot; ),
		div = document.createElement( &quot;div&quot; );
</P><P>	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}
</P><P>	// Support: IE &lt;=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = &quot;content-box&quot;;
	div.cloneNode( true ).style.backgroundClip = &quot;&quot;;
	support.clearCloneStyle = div.style.backgroundClip === &quot;content-box&quot;;
</P><P>	container.style.cssText = &quot;border:0;width:8px;height:0;top:0;left:-9999px;&quot; +
		&quot;padding:0;margin-top:1px;position:absolute&quot;;
	container.appendChild( div );
</P><P>	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();
</P><P>
function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
</P><P>		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;
</P><P>	computed = computed || getStyles( elem );
</P><P>	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
</P><P>		if ( ret === &quot;&quot; &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}
</P><P>		// A tribute to the &quot;awesome hack by Dean Edwards&quot;
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// <A rel="nofollow" class="external free" href="https://drafts.csswg.org/cssom/#resolved-values">https://drafts.csswg.org/cssom/#resolved-values</A>
		if ( !support.pixelMarginRight() &amp;&amp; rnumnonpx.test( ret ) &amp;&amp; rmargin.test( name ) ) {
</P><P>			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;
</P><P>			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;
</P><P>			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}
</P><P>	return ret !== undefined ?
</P><P>		// Support: IE &lt;=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + &quot;&quot; :
		ret;
}
</P><P>
function addGetHookIf( conditionFn, hookFn ) {
</P><P>	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
</P><P>				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}
</P><P>			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}
</P><P>
var
</P><P>	// Swappable if display is none or starts with table
	// except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;
	// See here for display values: <A rel="nofollow" class="external free" href="https://developer.mozilla.org/en-US/docs/CSS/display">https://developer.mozilla.org/en-US/docs/CSS/display</A>
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; },
	cssNormalTransform = {
		letterSpacing: &quot;0&quot;,
		fontWeight: &quot;400&quot;
	},
</P><P>	cssPrefixes = [ &quot;Webkit&quot;, &quot;Moz&quot;, &quot;ms&quot; ],
	emptyStyle = document.createElement( &quot;div&quot; ).style;
</P><P>// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {
</P><P>	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}
</P><P>	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;
</P><P>	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}
</P><P>// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}
</P><P>function setPositiveNumber( elem, value, subtract ) {
</P><P>	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?
</P><P>		// Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || &quot;px&quot; ) :
		value;
}
</P><P>function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;
</P><P>	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ) {
		i = 4;
</P><P>	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === &quot;width&quot; ? 1 : 0;
	}
</P><P>	for ( ; i &lt; 4; i += 2 ) {
</P><P>		// Both box models exclude margin, so add it if we want it
		if ( extra === &quot;margin&quot; ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}
</P><P>		if ( isBorderBox ) {
</P><P>			// border-box includes padding, so remove it if we want content
			if ( extra === &quot;content&quot; ) {
				val -= jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
			}
</P><P>			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== &quot;margin&quot; ) {
				val -= jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
			}
		} else {
</P><P>			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
</P><P>			// At this point, extra isn't content nor padding, so add border
			if ( extra !== &quot;padding&quot; ) {
				val += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
			}
		}
	}
</P><P>	return val;
}
</P><P>function getWidthOrHeight( elem, name, extra ) {
</P><P>	// Start with computed style
	var valueIsBorderBox,
		styles = getStyles( elem ),
		val = curCSS( elem, name, styles ),
		isBorderBox = jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;;
</P><P>	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test( val ) ) {
		return val;
	}
</P><P>	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = isBorderBox &amp;&amp;
		( support.boxSizingReliable() || val === elem.style[ name ] );
</P><P>	// Fall back to offsetWidth/Height when value is &quot;auto&quot;
	// This happens for inline elements with no explicit setting (gh-3571)
	if ( val === &quot;auto&quot; ) {
		val = elem[ &quot;offset&quot; + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
	}
</P><P>	// Normalize &quot;&quot;, auto, and prepare for extra
	val = parseFloat( val ) || 0;
</P><P>	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ),
			valueIsBorderBox,
			styles
		)
	) + &quot;px&quot;;
}
</P><P>jQuery.extend( {
</P><P>	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
</P><P>					// We should always get a number back from opacity
					var ret = curCSS( elem, &quot;opacity&quot; );
					return ret === &quot;&quot; ? &quot;1&quot; : ret;
				}
			}
		}
	},
</P><P>	// Don't automatically add &quot;px&quot; to these possibly-unitless properties
	cssNumber: {
		&quot;animationIterationCount&quot;: true,
		&quot;columnCount&quot;: true,
		&quot;fillOpacity&quot;: true,
		&quot;flexGrow&quot;: true,
		&quot;flexShrink&quot;: true,
		&quot;fontWeight&quot;: true,
		&quot;lineHeight&quot;: true,
		&quot;opacity&quot;: true,
		&quot;order&quot;: true,
		&quot;orphans&quot;: true,
		&quot;widows&quot;: true,
		&quot;zIndex&quot;: true,
		&quot;zoom&quot;: true
	},
</P><P>	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		&quot;float&quot;: &quot;cssFloat&quot;
	},
</P><P>	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
</P><P>		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}
</P><P>		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;
</P><P>		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}
</P><P>		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
</P><P>		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;
</P><P>			// Convert &quot;+=&quot; or &quot;-=&quot; to relative numbers (#7345)
			if ( type === &quot;string&quot; &amp;&amp; ( ret = rcssNum.exec( value ) ) &amp;&amp; ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );
</P><P>				// Fixes bug #9237
				type = &quot;number&quot;;
			}
</P><P>			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}
</P><P>			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === &quot;number&quot; ) {
				value += ret &amp;&amp; ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? &quot;&quot; : &quot;px&quot; );
			}
</P><P>			// background-* props affect original clone's values
			if ( !support.clearCloneStyle &amp;&amp; value === &quot;&quot; &amp;&amp; name.indexOf( &quot;background&quot; ) === 0 ) {
				style[ name ] = &quot;inherit&quot;;
			}
</P><P>			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( &quot;set&quot; in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {
</P><P>				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}
</P><P>		} else {
</P><P>			// If a hook was provided get the non-computed value from there
			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp;
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
</P><P>				return ret;
			}
</P><P>			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},
</P><P>	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name );
</P><P>		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}
</P><P>		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
</P><P>		// If a hook was provided get the computed value from there
		if ( hooks &amp;&amp; &quot;get&quot; in hooks ) {
			val = hooks.get( elem, true, extra );
		}
</P><P>		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}
</P><P>		// Convert &quot;normal&quot; to computed value
		if ( val === &quot;normal&quot; &amp;&amp; name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}
</P><P>		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === &quot;&quot; || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
</P><P>		return val;
	}
} );
</P><P>jQuery.each( [ &quot;height&quot;, &quot;width&quot; ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
</P><P>				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, &quot;display&quot; ) ) &amp;&amp;</P><P>					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth &amp; zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE &lt;=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},
</P><P>		set: function( elem, value, extra ) {
			var matches,
				styles = extra &amp;&amp; getStyles( elem ),
				subtract = extra &amp;&amp; augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;,
					styles
				);
</P><P>			// Convert to pixels if value adjustment is needed
			if ( subtract &amp;&amp; ( matches = rcssNum.exec( value ) ) &amp;&amp;
				( matches[ 3 ] || &quot;px&quot; ) !== &quot;px&quot; ) {
</P><P>				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}
</P><P>			return setPositiveNumber( elem, value, subtract );
		}
	};
} );
</P><P>jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, &quot;marginLeft&quot; ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + &quot;px&quot;;
		}
	}
);
</P><P>// These hooks are used by animate to expand properties
jQuery.each( {
	margin: &quot;&quot;,
	padding: &quot;&quot;,
	border: &quot;Width&quot;
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},
</P><P>				// Assumes a single number if not a string
				parts = typeof value === &quot;string&quot; ? value.split( &quot; &quot; ) : [ value ];
</P><P>			for ( ; i &lt; 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}
</P><P>			return expanded;
		}
	};
</P><P>	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );
</P><P>jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;
</P><P>			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;
</P><P>				for ( ; i &lt; len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}
</P><P>				return map;
			}
</P><P>			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length &gt; 1 );
	}
} );
</P><P>
function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;
</P><P>Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];
</P><P>		return hooks &amp;&amp; hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];
</P><P>		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;
</P><P>		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}
</P><P>		if ( hooks &amp;&amp; hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};
</P><P>Tween.prototype.init.prototype = Tween.prototype;
</P><P>Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;
</P><P>			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null &amp;&amp; tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}
</P><P>			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as &quot;10px&quot; are parsed to Float;
			// complex values such as &quot;rotate(1rad)&quot; are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, &quot;&quot; );
</P><P>			// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.
			return !result || result === &quot;auto&quot; ? 0 : result;
		},
		set: function( tween ) {
</P><P>			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &amp;&amp;
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};
</P><P>// Support: IE &lt;=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};
</P><P>jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: &quot;swing&quot;
};
</P><P>jQuery.fx = Tween.prototype.init;
</P><P>// Back compat &lt;1.8 extension point
jQuery.fx.step = {};
</P><P>
var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;
</P><P>function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false &amp;&amp; window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}
</P><P>		jQuery.fx.tick();
	}
}
</P><P>// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}
</P><P>// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };
</P><P>	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i &lt; 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ &quot;margin&quot; + which ] = attrs[ &quot;padding&quot; + which ] = type;
	}
</P><P>	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}
</P><P>	return attrs;
}
</P><P>function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ &quot;*&quot; ] ),
		index = 0,
		length = collection.length;
	for ( ; index &lt; length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
</P><P>			// We're done with this property
			return tween;
		}
	}
}
</P><P>function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = &quot;width&quot; in props || &quot;height&quot; in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType &amp;&amp; isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, &quot;fxshow&quot; );
</P><P>	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, &quot;fx&quot; );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;
</P><P>		anim.always( function() {
</P><P>			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, &quot;fx&quot; ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}
</P><P>	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === &quot;toggle&quot;;
			if ( value === ( hidden ? &quot;hide&quot; : &quot;show&quot; ) ) {
</P><P>				// Pretend to be hidden if this is a &quot;show&quot; and
				// there is still data from a stopped show/hide
				if ( value === &quot;show&quot; &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) {
					hidden = true;
</P><P>				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}
</P><P>	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween &amp;&amp; jQuery.isEmptyObject( orig ) ) {
		return;
	}
</P><P>	// Restrict &quot;overflow&quot; and &quot;display&quot; styles during box animations
	if ( isBox &amp;&amp; elem.nodeType === 1 ) {
</P><P>		// Support: IE &lt;=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
</P><P>		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow &amp;&amp; dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, &quot;display&quot; );
		}
		display = jQuery.css( elem, &quot;display&quot; );
		if ( display === &quot;none&quot; ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {
</P><P>				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, &quot;display&quot; );
				showHide( [ elem ] );
			}
		}
</P><P>		// Animate inline elements as inline-block
		if ( display === &quot;inline&quot; || display === &quot;inline-block&quot; &amp;&amp; restoreDisplay != null ) {
			if ( jQuery.css( elem, &quot;float&quot; ) === &quot;none&quot; ) {
</P><P>				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === &quot;none&quot; ? &quot;&quot; : display;
					}
				}
				style.display = &quot;inline-block&quot;;
			}
		}
	}
</P><P>	if ( opts.overflow ) {
		style.overflow = &quot;hidden&quot;;
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}
</P><P>	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {
</P><P>		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( &quot;hidden&quot; in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, &quot;fxshow&quot;, { display: restoreDisplay } );
			}
</P><P>			// Store hidden/visible for toggle so `.stop().toggle()` &quot;reverses&quot;
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
</P><P>			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}
</P><P>			/* eslint-disable no-loop-func */
</P><P>			anim.done( function() {
</P><P>			/* eslint-enable no-loop-func */
</P><P>				// The final step of a &quot;hide&quot; animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, &quot;fxshow&quot; );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}
</P><P>		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}
</P><P>function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;
</P><P>	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}
</P><P>		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}
</P><P>		hooks = jQuery.cssHooks[ name ];
		if ( hooks &amp;&amp; &quot;expand&quot; in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];
</P><P>			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct &quot;name&quot;
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}
</P><P>function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {
</P><P>			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
</P><P>				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;
</P><P>			for ( ; index &lt; length; index++ ) {
				animation.tweens[ index ].run( percent );
			}
</P><P>			deferred.notifyWith( elem, [ animation, percent, remaining ] );
</P><P>			// If there's more to do, yield
			if ( percent &lt; 1 &amp;&amp; length ) {
				return remaining;
			}
</P><P>			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}
</P><P>			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
</P><P>					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index &lt; length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}
</P><P>				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;
</P><P>	propFilter( props, animation.opts.specialEasing );
</P><P>	for ( ; index &lt; length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}
</P><P>	jQuery.map( props, createTween, animation );
</P><P>	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}
</P><P>	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
</P><P>	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);
</P><P>	return animation;
}
</P><P>jQuery.Animation = jQuery.extend( Animation, {
</P><P>	tweeners: {
		&quot;*&quot;: [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},
</P><P>	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ &quot;*&quot; ];
		} else {
			props = props.match( rnothtmlwhite );
		}
</P><P>		var prop,
			index = 0,
			length = props.length;
</P><P>		for ( ; index &lt; length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},
</P><P>	prefilters: [ defaultPrefilter ],
</P><P>	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );
</P><P>jQuery.speed = function( speed, easing, fn ) {
	var opt = speed &amp;&amp; typeof speed === &quot;object&quot; ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn &amp;&amp; easing ||
			jQuery.isFunction( speed ) &amp;&amp; speed,
		duration: speed,
		easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing
	};
</P><P>	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;
</P><P>	} else {
		if ( typeof opt.duration !== &quot;number&quot; ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];
</P><P>			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}
</P><P>	// Normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = &quot;fx&quot;;
	}
</P><P>	// Queueing
	opt.old = opt.complete;
</P><P>	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}
</P><P>		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};
</P><P>	return opt;
};
</P><P>jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {
</P><P>		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( &quot;opacity&quot;, 0 ).show()
</P><P>			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
</P><P>				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );
</P><P>				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, &quot;finish&quot; ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;
</P><P>		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};
</P><P>		if ( typeof type !== &quot;string&quot; ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue &amp;&amp; type !== false ) {
			this.queue( type || &quot;fx&quot;, [] );
		}
</P><P>		return this.each( function() {
			var dequeue = true,
				index = type != null &amp;&amp; type + &quot;queueHooks&quot;,
				timers = jQuery.timers,
				data = dataPriv.get( this );
</P><P>			if ( index ) {
				if ( data[ index ] &amp;&amp; data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}
</P><P>			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &amp;&amp;
					( type == null || timers[ index ].queue === type ) ) {
</P><P>					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}
</P><P>			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || &quot;fx&quot;;
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + &quot;queue&quot; ],
				hooks = data[ type + &quot;queueHooks&quot; ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;
</P><P>			// Enable finishing flag on private data
			data.finish = true;
</P><P>			// Empty the queue first
			jQuery.queue( this, type, [] );
</P><P>			if ( hooks &amp;&amp; hooks.stop ) {
				hooks.stop.call( this, true );
			}
</P><P>			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &amp;&amp; timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}
</P><P>			// Look for any animations in the old queue and finish them
			for ( index = 0; index &lt; length; index++ ) {
				if ( queue[ index ] &amp;&amp; queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}
</P><P>			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );
</P><P>jQuery.each( [ &quot;toggle&quot;, &quot;show&quot;, &quot;hide&quot; ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === &quot;boolean&quot; ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );
</P><P>// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( &quot;show&quot; ),
	slideUp: genFx( &quot;hide&quot; ),
	slideToggle: genFx( &quot;toggle&quot; ),
	fadeIn: { opacity: &quot;show&quot; },
	fadeOut: { opacity: &quot;hide&quot; },
	fadeToggle: { opacity: &quot;toggle&quot; }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );
</P><P>jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;
</P><P>	fxNow = jQuery.now();
</P><P>	for ( ; i &lt; timers.length; i++ ) {
		timer = timers[ i ];
</P><P>		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() &amp;&amp; timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}
</P><P>	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};
</P><P>jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};
</P><P>jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}
</P><P>	inProgress = true;
	schedule();
};
</P><P>jQuery.fx.stop = function() {
	inProgress = null;
};
</P><P>jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
</P><P>	// Default speed
	_default: 400
};
</P><P>
// Based off of the plugin by Clint Helfers, with permission.
// <A rel="nofollow" class="external free" href="https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/">https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/</A>
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || &quot;fx&quot;;
</P><P>	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};
</P><P>
( function() {
	var input = document.createElement( &quot;input&quot; ),
		select = document.createElement( &quot;select&quot; ),
		opt = select.appendChild( document.createElement( &quot;option&quot; ) );
</P><P>	input.type = &quot;checkbox&quot;;
</P><P>	// Support: Android &lt;=4.3 only
	// Default value for a checkbox should be &quot;on&quot;
	support.checkOn = input.value !== &quot;&quot;;
</P><P>	// Support: IE &lt;=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;
</P><P>	// Support: IE &lt;=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( &quot;input&quot; );
	input.value = &quot;t&quot;;
	input.type = &quot;radio&quot;;
	support.radioValue = input.value === &quot;t&quot;;
} )();
</P><P>
var boolHook,
	attrHandle = jQuery.expr.attrHandle;
</P><P>jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length &gt; 1 );
	},
</P><P>	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );
</P><P>jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;
</P><P>		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}
</P><P>		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === &quot;undefined&quot; ) {
			return jQuery.prop( elem, name, value );
		}
</P><P>		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}
</P><P>		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}
</P><P>			if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}
</P><P>			elem.setAttribute( name, value + &quot;&quot; );
			return value;
		}
</P><P>		if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}
</P><P>		ret = jQuery.find.attr( elem, name );
</P><P>		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},
</P><P>	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp;
					nodeName( elem, &quot;input&quot; ) ) {
					var val = elem.value;
					elem.setAttribute( &quot;type&quot;, value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},
</P><P>	removeAttr: function( elem, value ) {
		var name,
			i = 0,
</P><P>			// Attribute names can contain non-HTML whitespace characters
			// <A rel="nofollow" class="external free" href="https://html.spec.whatwg.org/multipage/syntax.html#attributes-2">https://html.spec.whatwg.org/multipage/syntax.html#attributes-2</A>
			attrNames = value &amp;&amp; value.match( rnothtmlwhite );
</P><P>		if ( attrNames &amp;&amp; elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );
</P><P>// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
</P><P>			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
</P><P>jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;
</P><P>	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();
</P><P>		if ( !isXML ) {
</P><P>			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );
</P><P>
var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;
</P><P>jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length &gt; 1 );
	},
</P><P>	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );
</P><P>jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;
</P><P>		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}
</P><P>		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
</P><P>			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}
</P><P>		if ( value !== undefined ) {
			if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}
</P><P>			return ( elem[ name ] = value );
		}
</P><P>		if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}
</P><P>		return elem[ name ];
	},
</P><P>	propHooks: {
		tabIndex: {
			get: function( elem ) {
</P><P>				// Support: IE &lt;=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// <A rel="nofollow" class="external free" href="https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/">https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/</A>
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, &quot;tabindex&quot; );
</P><P>				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}
</P><P>				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &amp;&amp;
					elem.href
				) {
					return 0;
				}
</P><P>				return -1;
			}
		}
	},
</P><P>	propFix: {
		&quot;for&quot;: &quot;htmlFor&quot;,
		&quot;class&quot;: &quot;className&quot;
	}
} );
</P><P>// Support: IE &lt;=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule &quot;no-unused-expressions&quot; is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
</P><P>			/* eslint no-unused-expressions: &quot;off&quot; */
</P><P>			var parent = elem.parentNode;
			if ( parent &amp;&amp; parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {
</P><P>			/* eslint no-unused-expressions: &quot;off&quot; */
</P><P>			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;
</P><P>				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}
</P><P>jQuery.each( [
	&quot;tabIndex&quot;,
	&quot;readOnly&quot;,
	&quot;maxLength&quot;,
	&quot;cellSpacing&quot;,
	&quot;cellPadding&quot;,
	&quot;rowSpan&quot;,
	&quot;colSpan&quot;,
	&quot;useMap&quot;,
	&quot;frameBorder&quot;,
	&quot;contentEditable&quot;
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );
</P><P>
	// Strip and collapse whitespace according to HTML spec
	// <A rel="nofollow" class="external free" href="https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace">https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace</A>
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( &quot; &quot; );
	}
</P><P>
function getClass( elem ) {
	return elem.getAttribute &amp;&amp; elem.getAttribute( &quot;class&quot; ) || &quot;&quot;;
}
</P><P>jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;
</P><P>		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}
</P><P>		if ( typeof value === &quot;string&quot; &amp;&amp; value ) {
			classes = value.match( rnothtmlwhite ) || [];
</P><P>			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );
</P><P>				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &lt; 0 ) {
							cur += clazz + &quot; &quot;;
						}
					}
</P><P>					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( &quot;class&quot;, finalValue );
					}
				}
			}
		}
</P><P>		return this;
	},
</P><P>	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;
</P><P>		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}
</P><P>		if ( !arguments.length ) {
			return this.attr( &quot;class&quot;, &quot;&quot; );
		}
</P><P>		if ( typeof value === &quot;string&quot; &amp;&amp; value ) {
			classes = value.match( rnothtmlwhite ) || [];
</P><P>			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
</P><P>				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );
</P><P>				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
</P><P>						// Remove *all* instances
						while ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &gt; -1 ) {
							cur = cur.replace( &quot; &quot; + clazz + &quot; &quot;, &quot; &quot; );
						}
					}
</P><P>					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( &quot;class&quot;, finalValue );
					}
				}
			}
		}
</P><P>		return this;
	},
</P><P>	toggleClass: function( value, stateVal ) {
		var type = typeof value;
</P><P>		if ( typeof stateVal === &quot;boolean&quot; &amp;&amp; type === &quot;string&quot; ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}
</P><P>		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}
</P><P>		return this.each( function() {
			var className, i, self, classNames;
</P><P>			if ( type === &quot;string&quot; ) {
</P><P>				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];
</P><P>				while ( ( className = classNames[ i++ ] ) ) {
</P><P>					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}
</P><P>			// Toggle whole class name
			} else if ( value === undefined || type === &quot;boolean&quot; ) {
				className = getClass( this );
				if ( className ) {
</P><P>					// Store className if set
					dataPriv.set( this, &quot;__className__&quot;, className );
				}
</P><P>				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( &quot;class&quot;,
						className || value === false ?
						&quot;&quot; :
						dataPriv.get( this, &quot;__className__&quot; ) || &quot;&quot;
					);
				}
			}
		} );
	},
</P><P>	hasClass: function( selector ) {
		var className, elem,
			i = 0;
</P><P>		className = &quot; &quot; + selector + &quot; &quot;;
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &amp;&amp;
				( &quot; &quot; + stripAndCollapse( getClass( elem ) ) + &quot; &quot; ).indexOf( className ) &gt; -1 ) {
					return true;
			}
		}
</P><P>		return false;
	}
} );
</P><P>
var rreturn = /\r/g;
</P><P>jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];
</P><P>		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];
</P><P>				if ( hooks &amp;&amp;
					&quot;get&quot; in hooks &amp;&amp;
					( ret = hooks.get( elem, &quot;value&quot; ) ) !== undefined
				) {
					return ret;
				}
</P><P>				ret = elem.value;
</P><P>				// Handle most common string cases
				if ( typeof ret === &quot;string&quot; ) {
					return ret.replace( rreturn, &quot;&quot; );
				}
</P><P>				// Handle cases where value is null/undef or number
				return ret == null ? &quot;&quot; : ret;
			}
</P><P>			return;
		}
</P><P>		isFunction = jQuery.isFunction( value );
</P><P>		return this.each( function( i ) {
			var val;
</P><P>			if ( this.nodeType !== 1 ) {
				return;
			}
</P><P>			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}
</P><P>			// Treat null/undefined as &quot;&quot;; convert numbers to string
			if ( val == null ) {
				val = &quot;&quot;;
</P><P>			} else if ( typeof val === &quot;number&quot; ) {
				val += &quot;&quot;;
</P><P>			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? &quot;&quot; : value + &quot;&quot;;
				} );
			}
</P><P>			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
</P><P>			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( &quot;set&quot; in hooks ) || hooks.set( this, val, &quot;value&quot; ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );
</P><P>jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {
</P><P>				var val = jQuery.find.attr( elem, &quot;value&quot; );
				return val != null ?
					val :
</P><P>					// Support: IE &lt;=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// <A rel="nofollow" class="external free" href="https://html.spec.whatwg.org/#strip-and-collapse-whitespace">https://html.spec.whatwg.org/#strip-and-collapse-whitespace</A>
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === &quot;select-one&quot;,
					values = one ? null : [],
					max = one ? index + 1 : options.length;
</P><P>				if ( index &lt; 0 ) {
					i = max;
</P><P>				} else {
					i = one ? index : 0;
				}
</P><P>				// Loop through all the selected options
				for ( ; i &lt; max; i++ ) {
					option = options[ i ];
</P><P>					// Support: IE &lt;=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &amp;&amp;</P><P>							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &amp;&amp;
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, &quot;optgroup&quot; ) ) ) {
</P><P>						// Get the specific value for the option
						value = jQuery( option ).val();
</P><P>						// We don't need an array for one selects
						if ( one ) {
							return value;
						}
</P><P>						// Multi-Selects return an array
						values.push( value );
					}
				}
</P><P>				return values;
			},
</P><P>			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;
</P><P>				while ( i-- ) {
					option = options[ i ];
</P><P>					/* eslint-disable no-cond-assign */
</P><P>					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) &gt; -1
					) {
						optionSet = true;
					}
</P><P>					/* eslint-enable no-cond-assign */
				}
</P><P>				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );
</P><P>// Radios and checkboxes getter/setter
jQuery.each( [ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) &gt; -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( &quot;value&quot; ) === null ? &quot;on&quot; : elem.value;
		};
	}
} );
</P><P>
// Return jQuery for attributes-only inclusion</P><P>
var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
</P><P>jQuery.extend( jQuery.event, {
</P><P>	trigger: function( event, data, elem, onlyHandlers ) {
</P><P>		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, &quot;type&quot; ) ? event.type : event,
			namespaces = hasOwn.call( event, &quot;namespace&quot; ) ? event.namespace.split( &quot;.&quot; ) : [];
</P><P>		cur = tmp = elem = elem || document;
</P><P>		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}
</P><P>		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}
</P><P>		if ( type.indexOf( &quot;.&quot; ) &gt; -1 ) {
</P><P>			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( &quot;.&quot; );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( &quot;:&quot; ) &lt; 0 &amp;&amp; &quot;on&quot; + type;
</P><P>		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === &quot;object&quot; &amp;&amp; event );
</P><P>		// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( &quot;.&quot; );
		event.rnamespace = event.namespace ?
			new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; ) :
			null;
</P><P>		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}
</P><P>		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );
</P><P>		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
			return;
		}
</P><P>		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {
</P><P>			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}
</P><P>			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}
</P><P>		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
</P><P>			event.type = i &gt; 1 ?
				bubbleType :
				special.bindType || type;
</P><P>			// jQuery handler
			handle = ( dataPriv.get( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp;
				dataPriv.get( cur, &quot;handle&quot; );
			if ( handle ) {
				handle.apply( cur, data );
			}
</P><P>			// Native handler
			handle = ontype &amp;&amp; cur[ ontype ];
			if ( handle &amp;&amp; handle.apply &amp;&amp; acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;
</P><P>		// If nobody prevented the default action, do it now
		if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {
</P><P>			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &amp;&amp;
				acceptData( elem ) ) {
</P><P>				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) {
</P><P>					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];
</P><P>					if ( tmp ) {
						elem[ ontype ] = null;
					}
</P><P>					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;
</P><P>					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}
</P><P>		return event.result;
	},
</P><P>	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);
</P><P>		jQuery.event.trigger( e, null, elem );
	}
</P><P>} );
</P><P>jQuery.fn.extend( {
</P><P>	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );
</P><P>
jQuery.each( ( &quot;blur focus focusin focusout resize scroll click dblclick &quot; +
	&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
	&quot;change select submit keydown keypress keyup contextmenu&quot; ).split( &quot; &quot; ),
	function( i, name ) {
</P><P>	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length &gt; 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );
</P><P>jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );
</P><P>
support.focusin = &quot;onfocusin&quot; in window;
</P><P>
// Support: Firefox &lt;=44
// Firefox doesn't have focus(in | out) events
// Related ticket - <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=687787">https://bugzilla.mozilla.org/show_bug.cgi?id=687787</A>
//
// Support: Chrome &lt;=48 - 49, Safari &lt;=9.0 - 9.1
// focus(in | out) events fire after focus &amp; blur events,
// which is spec violation - <A rel="nofollow" class="external free" href="http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order">http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order</A>
// Related ticket - <A rel="nofollow" class="external free" href="https://bugs.chromium.org/p/chromium/issues/detail?id=449857">https://bugs.chromium.org/p/chromium/issues/detail?id=449857</A>
if ( !support.focusin ) {
	jQuery.each( { focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {
</P><P>		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};
</P><P>		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );
</P><P>				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;
</P><P>				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );
</P><P>				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;
</P><P>var nonce = jQuery.now();
</P><P>var rquery = ( /\?/ );
</P><P>// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== &quot;string&quot; ) {
		return null;
	}
</P><P>	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, &quot;text/xml&quot; );
	} catch ( e ) {
		xml = undefined;
	}
</P><P>	if ( !xml || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
		jQuery.error( &quot;Invalid XML: &quot; + data );
	}
	return xml;
};
</P><P>
var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;
</P><P>function buildParams( prefix, obj, traditional, add ) {
	var name;
</P><P>	if ( Array.isArray( obj ) ) {
</P><P>		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
</P><P>				// Treat each array item as a scalar.
				add( prefix, v );
</P><P>			} else {
</P><P>				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; &amp;&amp; v != null ? i : &quot;&quot; ) + &quot;]&quot;,
					v,
					traditional,
					add
				);
			}
		} );
</P><P>	} else if ( !traditional &amp;&amp; jQuery.type( obj ) === &quot;object&quot; ) {
</P><P>		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
		}
</P><P>	} else {
</P><P>		// Serialize scalar item.
		add( prefix, obj );
	}
}
</P><P>// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {
</P><P>			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;
</P><P>			s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; +
				encodeURIComponent( value == null ? &quot;&quot; : value );
		};
</P><P>	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {
</P><P>		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );
</P><P>	} else {
</P><P>		// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}
</P><P>	// Return the resulting serialization
	return s.join( &quot;&amp;&quot; );
};
</P><P>jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {
</P><P>			// Can add propHook for &quot;elements&quot; to filter or add form elements
			var elements = jQuery.prop( this, &quot;elements&quot; );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;
</P><P>			// Use .is( &quot;:disabled&quot; ) so that fieldset[disabled] works
			return this.name &amp;&amp; !jQuery( this ).is( &quot;:disabled&quot; ) &amp;&amp;
				rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();
</P><P>			if ( val == null ) {
				return null;
			}
</P><P>			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
				} );
			}
</P><P>			return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
		} ).get();
	}
} );
</P><P>
var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&amp;])_=[^&amp;]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
</P><P>	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
</P><P>	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol &quot;*&quot; can be used
	 * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed
	 */
	prefilters = {},
</P><P>	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol &quot;*&quot; can be used
	 * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed
	 */
	transports = {},
</P><P>	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = &quot;*/&quot;.concat( &quot;*&quot; ),
</P><P>	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( &quot;a&quot; );
	originAnchor.href = location.href;
</P><P>// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {
</P><P>	// dataTypeExpression is optional and defaults to &quot;*&quot;
	return function( dataTypeExpression, func ) {
</P><P>		if ( typeof dataTypeExpression !== &quot;string&quot; ) {
			func = dataTypeExpression;
			dataTypeExpression = &quot;*&quot;;
		}
</P><P>		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
</P><P>		if ( jQuery.isFunction( func ) ) {
</P><P>			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {
</P><P>				// Prepend if requested
				if ( dataType[ 0 ] === &quot;+&quot; ) {
					dataType = dataType.slice( 1 ) || &quot;*&quot;;
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
</P><P>				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}
</P><P>// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
</P><P>	var inspected = {},
		seekingTransport = ( structure === transports );
</P><P>	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === &quot;string&quot; &amp;&amp;
				!seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {
</P><P>				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}
</P><P>	return inspect( options.dataTypes[ 0 ] ) || !inspected[ &quot;*&quot; ] &amp;&amp; inspect( &quot;*&quot; );
}
</P><P>// A special extend for ajax options
// that takes &quot;flat&quot; options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
</P><P>	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
</P><P>	return target;
}
</P><P>/* Handles responses to an ajax request:
</P><PRE>* - finds the right dataType (mediates between content-type and expected dataType)
* - returns the corresponding response
*/
</PRE><P>function ajaxHandleResponses( s, jqXHR, responses ) {
</P><P>	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;
</P><P>	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === &quot;*&quot; ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( &quot;Content-Type&quot; );
		}
	}
</P><P>	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}
</P><P>	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
</P><P>		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
</P><P>		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}
</P><P>	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}
</P><P>/* Chain conversions given the request and the original response
</P><PRE>* Also sets the responseXXX fields on the jqXHR instance
*/
</PRE><P>function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
</P><P>		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();
</P><P>	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}
</P><P>	current = dataTypes.shift();
</P><P>	// Convert to each sequential dataType
	while ( current ) {
</P><P>		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}
</P><P>		// Apply the dataFilter if provided
		if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}
</P><P>		prev = current;
		current = dataTypes.shift();
</P><P>		if ( current ) {
</P><P>			// There's only work to do if current dataType is non-auto
			if ( current === &quot;*&quot; ) {
</P><P>				current = prev;
</P><P>			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) {
</P><P>				// Seek a direct converter
				conv = converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ];
</P><P>				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {
</P><P>						// If conv2 outputs current
						tmp = conv2.split( &quot; &quot; );
						if ( tmp[ 1 ] === current ) {
</P><P>							// If prev can be converted to accepted input
							conv = converters[ prev + &quot; &quot; + tmp[ 0 ] ] ||
								converters[ &quot;* &quot; + tmp[ 0 ] ];
							if ( conv ) {
</P><P>								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];
</P><P>								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}
</P><P>				// Apply converter (if not an equivalence)
				if ( conv !== true ) {
</P><P>					// Unless errors are allowed to bubble, catch and return them
					if ( conv &amp;&amp; s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: &quot;parsererror&quot;,
								error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current
							};
						}
					}
				}
			}
		}
	}
</P><P>	return { state: &quot;success&quot;, data: response };
}
</P><P>jQuery.extend( {
</P><P>	// Counter for holding the number of active queries
	active: 0,
</P><P>	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},
</P><P>	ajaxSettings: {
		url: location.href,
		type: &quot;GET&quot;,
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
</P><P>		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/
</P><P>		accepts: {
			&quot;*&quot;: allTypes,
			text: &quot;text/plain&quot;,
			html: &quot;text/html&quot;,
			xml: &quot;application/xml, text/xml&quot;,
			json: &quot;application/json, text/javascript&quot;
		},
</P><P>		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},
</P><P>		responseFields: {
			xml: &quot;responseXML&quot;,
			text: &quot;responseText&quot;,
			json: &quot;responseJSON&quot;
		},
</P><P>		// Data converters
		// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space
		converters: {
</P><P>			// Convert anything to text
			&quot;* text&quot;: String,
</P><P>			// Text to html (true = no transformation)
			&quot;text html&quot;: true,
</P><P>			// Evaluate text as a json expression
			&quot;text json&quot;: JSON.parse,
</P><P>			// Parse text as xml
			&quot;text xml&quot;: jQuery.parseXML
		},
</P><P>		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},
</P><P>	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?
</P><P>			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
</P><P>			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},
</P><P>	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),
</P><P>	// Main method
	ajax: function( url, options ) {
</P><P>		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === &quot;object&quot; ) {
			options = url;
			url = undefined;
		}
</P><P>		// Force options to be an object
		options = options || {};
</P><P>		var transport,
</P><P>			// URL without anti-cache param
			cacheURL,
</P><P>			// Response headers
			responseHeadersString,
			responseHeaders,
</P><P>			// timeout handle
			timeoutTimer,
</P><P>			// Url cleanup var
			urlAnchor,
</P><P>			// Request state (becomes false upon send and true upon completion)
			completed,
</P><P>			// To know if global events are to be dispatched
			fireGlobals,
</P><P>			// Loop variable
			i,
</P><P>			// uncached part of the url
			uncached,
</P><P>			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
</P><P>			// Callbacks context
			callbackContext = s.context || s,
</P><P>			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &amp;&amp;
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
</P><P>			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( &quot;once memory&quot; ),
</P><P>			// Status-dependent callbacks
			statusCode = s.statusCode || {},
</P><P>			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
</P><P>			// Default abort message
			strAbort = &quot;canceled&quot;,
</P><P>			// Fake xhr
			jqXHR = {
				readyState: 0,
</P><P>				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},
</P><P>				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},
</P><P>				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},
</P><P>				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},
</P><P>				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {
</P><P>							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {
</P><P>							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},
</P><P>				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};
</P><P>		// Attach deferreds
		deferred.promise( jqXHR );
</P><P>		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + &quot;&quot; )
			.replace( rprotocol, location.protocol + &quot;//&quot; );
</P><P>		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;
</P><P>		// Extract dataTypes list
		s.dataTypes = ( s.dataType || &quot;*&quot; ).toLowerCase().match( rnothtmlwhite ) || [ &quot;&quot; ];
</P><P>		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( &quot;a&quot; );
</P><P>			// Support: IE &lt;=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. <A rel="nofollow" class="external free" href="http://example.com:80x/">http://example.com:80x/</A>
			try {
				urlAnchor.href = s.url;
</P><P>				// Support: IE &lt;=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + &quot;//&quot; + originAnchor.host !==
					urlAnchor.protocol + &quot;//&quot; + urlAnchor.host;
			} catch ( e ) {
</P><P>				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}
</P><P>		// Convert data if not already a string
		if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) {
			s.data = jQuery.param( s.data, s.traditional );
		}
</P><P>		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
</P><P>		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}
</P><P>		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event &amp;&amp; s.global;
</P><P>		// Watch for a new set of requests
		if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {
			jQuery.event.trigger( &quot;ajaxStart&quot; );
		}
</P><P>		// Uppercase the type
		s.type = s.type.toUpperCase();
</P><P>		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );
</P><P>		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, &quot;&quot; );
</P><P>		// More options handling for requests with no content
		if ( !s.hasContent ) {
</P><P>			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );
</P><P>			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data;
</P><P>				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}
</P><P>			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, &quot;$1&quot; );
				uncached = ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + ( nonce++ ) + uncached;
			}
</P><P>			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;
</P><P>		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data &amp;&amp; s.processData &amp;&amp;
			( s.contentType || &quot;&quot; ).indexOf( &quot;application/x-www-form-urlencoded&quot; ) === 0 ) {
			s.data = s.data.replace( r20, &quot;+&quot; );
		}
</P><P>		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ cacheURL ] );
			}
		}
</P><P>		// Set the correct header, if data is being sent
		if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
		}
</P><P>		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			&quot;Accept&quot;,
			s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) :
				s.accepts[ &quot;*&quot; ]
		);
</P><P>		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}
</P><P>		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &amp;&amp;
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
</P><P>			// Abort if not done already and return
			return jqXHR.abort();
		}
</P><P>		// Aborting is no longer a cancellation
		strAbort = &quot;abort&quot;;
</P><P>		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );
</P><P>		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
</P><P>		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, &quot;No Transport&quot; );
		} else {
			jqXHR.readyState = 1;
</P><P>			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
			}
</P><P>			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}
</P><P>			// Timeout
			if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( &quot;timeout&quot; );
				}, s.timeout );
			}
</P><P>			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {
</P><P>				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}
</P><P>				// Propagate others as results
				done( -1, e );
			}
		}
</P><P>		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;
</P><P>			// Ignore repeat invocations
			if ( completed ) {
				return;
			}
</P><P>			completed = true;
</P><P>			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}
</P><P>			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;
</P><P>			// Cache response headers
			responseHeadersString = headers || &quot;&quot;;
</P><P>			// Set readyState
			jqXHR.readyState = status &gt; 0 ? 4 : 0;
</P><P>			// Determine if successful
			isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;
</P><P>			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}
</P><P>			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );
</P><P>			// If successful, handle type chaining
			if ( isSuccess ) {
</P><P>				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( &quot;Last-Modified&quot; );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( &quot;etag&quot; );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}
</P><P>				// if no content
				if ( status === 204 || s.type === &quot;HEAD&quot; ) {
					statusText = &quot;nocontent&quot;;
</P><P>				// if not modified
				} else if ( status === 304 ) {
					statusText = &quot;notmodified&quot;;
</P><P>				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
</P><P>				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = &quot;error&quot;;
					if ( status &lt; 0 ) {
						status = 0;
					}
				}
			}
</P><P>			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + &quot;&quot;;
</P><P>			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}
</P><P>			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;
</P><P>			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? &quot;ajaxSuccess&quot; : &quot;ajaxError&quot;,
					[ jqXHR, s, isSuccess ? success : error ] );
			}
</P><P>			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
</P><P>			if ( fireGlobals ) {
				globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );
</P><P>				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( &quot;ajaxStop&quot; );
				}
			}
		}
</P><P>		return jqXHR;
	},
</P><P>	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, &quot;json&quot; );
	},
</P><P>	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, &quot;script&quot; );
	}
} );
</P><P>jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
</P><P>		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}
</P><P>		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) &amp;&amp; url ) );
	};
} );
</P><P>
jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,
</P><P>		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: &quot;GET&quot;,
		dataType: &quot;script&quot;,
		cache: true,
		async: false,
		global: false,
		&quot;throws&quot;: true
	} );
};
</P><P>
jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;
</P><P>		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}
</P><P>			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
</P><P>			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}
</P><P>			wrap.map( function() {
				var elem = this;
</P><P>				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}
</P><P>				return elem;
			} ).append( this );
		}
</P><P>		return this;
	},
</P><P>	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}
</P><P>		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();
</P><P>			if ( contents.length ) {
				contents.wrapAll( html );
</P><P>			} else {
				self.append( html );
			}
		} );
	},
</P><P>	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );
</P><P>		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},
</P><P>	unwrap: function( selector ) {
		this.parent( selector ).not( &quot;body&quot; ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );
</P><P>
jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};
</P><P>
jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};
</P><P>var xhrSuccessStatus = {
</P><P>		// File protocol always yields status code 0, assume 200
		0: 200,
</P><P>		// Support: IE &lt;=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();
</P><P>support.cors = !!xhrSupported &amp;&amp; ( &quot;withCredentials&quot; in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;
</P><P>jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;
</P><P>	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();
</P><P>				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);
</P><P>				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}
</P><P>				// Override mime type if needed
				if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}
</P><P>				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain &amp;&amp; !headers[ &quot;X-Requested-With&quot; ] ) {
					headers[ &quot;X-Requested-With&quot; ] = &quot;XMLHttpRequest&quot;;
				}
</P><P>				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}
</P><P>				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
</P><P>							if ( type === &quot;abort&quot; ) {
								xhr.abort();
							} else if ( type === &quot;error&quot; ) {
</P><P>								// Support: IE &lt;=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== &quot;number&quot; ) {
									complete( 0, &quot;error&quot; );
								} else {
									complete(
</P><P>										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
</P><P>									// Support: IE &lt;=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || &quot;text&quot; ) !== &quot;text&quot;  ||
									typeof xhr.responseText !== &quot;string&quot; ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};
</P><P>				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( &quot;error&quot; );
</P><P>				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {
</P><P>						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {
</P><P>							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}
</P><P>				// Create the abort callback
				callback = callback( &quot;abort&quot; );
</P><P>				try {
</P><P>					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent &amp;&amp; options.data || null );
				} catch ( e ) {
</P><P>					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},
</P><P>			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );
</P><P>
// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );
</P><P>// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: &quot;text/javascript, application/javascript, &quot; +
			&quot;application/ecmascript, application/x-ecmascript&quot;
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		&quot;text script&quot;: function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );
</P><P>// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = &quot;GET&quot;;
	}
} );
</P><P>// Bind script tag hack transport
jQuery.ajaxTransport( &quot;script&quot;, function( s ) {
</P><P>	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( &quot;&lt;script&gt;&quot; ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					&quot;load error&quot;,
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === &quot;error&quot; ? 404 : 200, evt.type );
						}
					}
				);
</P><P>				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );
</P><P>
var oldCallbacks = [],
	rjsonp = /(=)\?(?=&amp;|$)|\?\?/;
</P><P>// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: &quot;callback&quot;,
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );
</P><P>// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {
</P><P>	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ?
			&quot;url&quot; :
			typeof s.data === &quot;string&quot; &amp;&amp;
				( s.contentType || &quot;&quot; )
					.indexOf( &quot;application/x-www-form-urlencoded&quot; ) === 0 &amp;&amp;
				rjsonp.test( s.data ) &amp;&amp; &quot;data&quot;
		);
</P><P>	// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === &quot;jsonp&quot; ) {
</P><P>		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;
</P><P>		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, &quot;$1&quot; + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;=&quot; + callbackName;
		}
</P><P>		// Use data converter to retrieve json after script execution
		s.converters[ &quot;script json&quot; ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + &quot; was not called&quot; );
			}
			return responseContainer[ 0 ];
		};
</P><P>		// Force json dataType
		s.dataTypes[ 0 ] = &quot;json&quot;;
</P><P>		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};
</P><P>		// Clean-up function (fires after converters)
		jqXHR.always( function() {
</P><P>			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );
</P><P>			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}
</P><P>			// Save back as free
			if ( s[ callbackName ] ) {
</P><P>				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;
</P><P>				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}
</P><P>			// Call if it was a function and we have a response
			if ( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}
</P><P>			responseContainer = overwritten = undefined;
		} );
</P><P>		// Delegate to script
		return &quot;script&quot;;
	}
} );
</P><P>
// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// <A rel="nofollow" class="external free" href="https://bugs.webkit.org/show_bug.cgi?id=137337">https://bugs.webkit.org/show_bug.cgi?id=137337</A>
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( &quot;&quot; ).body;
	body.innerHTML = &quot;&lt;form&gt;&lt;/form&gt;&lt;form&gt;&lt;/form&gt;&quot;;
	return body.childNodes.length === 2;
} )();
</P><P>
// Argument &quot;data&quot; should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== &quot;string&quot; ) {
		return [];
	}
	if ( typeof context === &quot;boolean&quot; ) {
		keepScripts = context;
		context = false;
	}
</P><P>	var base, parsed, scripts;
</P><P>	if ( !context ) {
</P><P>		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( &quot;&quot; );
</P><P>			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( &quot;base&quot; );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}
</P><P>	parsed = rsingleTag.exec( data );
	scripts = !keepScripts &amp;&amp; [];
</P><P>	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}
</P><P>	parsed = buildFragment( [ data ], context, scripts );
</P><P>	if ( scripts &amp;&amp; scripts.length ) {
		jQuery( scripts ).remove();
	}
</P><P>	return jQuery.merge( [], parsed.childNodes );
};
</P><P>
/**
</P><PRE>* Load a url into a page
*/
</PRE><P>jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( &quot; &quot; );
</P><P>	if ( off &gt; -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}
</P><P>	// If it's a function
	if ( jQuery.isFunction( params ) ) {
</P><P>		// We assume that it's the callback
		callback = params;
		params = undefined;
</P><P>	// Otherwise, build a param string
	} else if ( params &amp;&amp; typeof params === &quot;object&quot; ) {
		type = &quot;POST&quot;;
	}
</P><P>	// If we have elements to modify, make the request
	if ( self.length &gt; 0 ) {
		jQuery.ajax( {
			url: url,
</P><P>			// If &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || &quot;GET&quot;,
			dataType: &quot;html&quot;,
			data: params
		} ).done( function( responseText ) {
</P><P>			// Save response for use in complete callback
			response = arguments;
</P><P>			self.html( selector ?
</P><P>				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
</P>			jQuery( &quot;<DIV>&quot; ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
<P>				// Otherwise use the full result
				responseText );
</P><P>		// If the request succeeds, this function gets &quot;data&quot;, &quot;status&quot;, &quot;jqXHR&quot;
		// but they are ignored because response was set above.
		// If it fails, this function gets &quot;jqXHR&quot;, &quot;status&quot;, &quot;error&quot;
		} ).always( callback &amp;&amp; function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}
</P><P>	return this;
};
</P><P>
// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	&quot;ajaxStart&quot;,
	&quot;ajaxStop&quot;,
	&quot;ajaxComplete&quot;,
	&quot;ajaxError&quot;,
	&quot;ajaxSuccess&quot;,
	&quot;ajaxSend&quot;
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );
</P><P>
jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};
</P><P>
jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, &quot;position&quot; ),
			curElem = jQuery( elem ),
			props = {};
</P><P>		// Set position first, in-case top/left are set even on static elem
		if ( position === &quot;static&quot; ) {
			elem.style.position = &quot;relative&quot;;
		}
</P><P>		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, &quot;top&quot; );
		curCSSLeft = jQuery.css( elem, &quot;left&quot; );
		calculatePosition = ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) &amp;&amp;
			( curCSSTop + curCSSLeft ).indexOf( &quot;auto&quot; ) &gt; -1;
</P><P>		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
</P><P>		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}
</P><P>		if ( jQuery.isFunction( options ) ) {
</P><P>			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}
</P><P>		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}
</P><P>		if ( &quot;using&quot; in options ) {
			options.using.call( elem, props );
</P><P>		} else {
			curElem.css( props );
		}
	}
};
</P><P>jQuery.fn.extend( {
	offset: function( options ) {
</P><P>		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}
</P><P>		var doc, docElem, rect, win,
			elem = this[ 0 ];
</P><P>		if ( !elem ) {
			return;
		}
</P><P>		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE &lt;=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}
</P><P>		rect = elem.getBoundingClientRect();
</P><P>		doc = elem.ownerDocument;
		docElem = doc.documentElement;
		win = doc.defaultView;
</P><P>		return {
			top: rect.top + win.pageYOffset - docElem.clientTop,
			left: rect.left + win.pageXOffset - docElem.clientLeft
		};
	},
</P><P>	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}
</P><P>		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };
</P><P>		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) {
</P><P>			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();
</P><P>		} else {
</P><P>			// Get *real* offsetParent
			offsetParent = this.offsetParent();
</P><P>			// Get correct offsets
			offset = this.offset();
			if ( !nodeName( offsetParent[ 0 ], &quot;html&quot; ) ) {
				parentOffset = offsetParent.offset();
			}
</P><P>			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], &quot;borderTopWidth&quot;, true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], &quot;borderLeftWidth&quot;, true )
			};
		}
</P><P>		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true )
		};
	},
</P><P>	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;
</P><P>			while ( offsetParent &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) {
				offsetParent = offsetParent.offsetParent;
			}
</P><P>			return offsetParent || documentElement;
		} );
	}
} );
</P><P>// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: &quot;pageXOffset&quot;, scrollTop: &quot;pageYOffset&quot; }, function( method, prop ) {
	var top = &quot;pageYOffset&quot; === prop;
</P><P>	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
</P><P>			// Coalesce documents and windows
			var win;
			if ( jQuery.isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}
</P><P>			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}
</P><P>			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);
</P><P>			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );
</P><P>// Support: Safari &lt;=7 - 9.1, Chrome &lt;=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: <A rel="nofollow" class="external free" href="https://bugs.webkit.org/show_bug.cgi?id=29084">https://bugs.webkit.org/show_bug.cgi?id=29084</A>
// Blink bug: <A rel="nofollow" class="external free" href="https://bugs.chromium.org/p/chromium/issues/detail?id=589347">https://bugs.chromium.org/p/chromium/issues/detail?id=589347</A>
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ &quot;top&quot;, &quot;left&quot; ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
</P><P>				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + &quot;px&quot; :
					computed;
			}
		}
	);
} );
</P><P>
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: &quot;height&quot;, Width: &quot;width&quot; }, function( name, type ) {
	jQuery.each( { padding: &quot;inner&quot; + name, content: type, &quot;&quot;: &quot;outer&quot; + name },
		function( defaultExtra, funcName ) {
</P><P>		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== &quot;boolean&quot; ),
				extra = defaultExtra || ( margin === true || value === true ? &quot;margin&quot; : &quot;border&quot; );
</P><P>			return access( this, function( elem, type, value ) {
				var doc;
</P><P>				if ( jQuery.isWindow( elem ) ) {
</P><P>				// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( &quot;outer&quot; ) === 0 ?
						elem[ &quot;inner&quot; + name ] :
						elem.document.documentElement[ &quot;client&quot; + name ];
				}
</P><P>				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;
</P><P>					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ],
						elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ],
						doc[ &quot;client&quot; + name ]
					);
				}
</P><P>				return value === undefined ?
</P><P>					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :
</P><P>					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );
</P><P>
jQuery.fn.extend( {
</P><P>	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},
</P><P>	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
</P><P>		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, &quot;**&quot; ) :
			this.off( types, selector || &quot;**&quot;, fn );
	}
} );
</P><P>jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
</P><P>
// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.
</P><P>// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// <A rel="nofollow" class="external free" href="https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon">https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon</A></P><P>if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
	define( &quot;jquery&quot;, [], function() {
		return jQuery;
	} );
}
</P><P>
var
</P><P>	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,
</P><P>	// Map over the $ in case of overwrite
	_$ = window.$;
</P><P>jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}
</P><P>	if ( deep &amp;&amp; window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}
</P><P>	return jQuery;
};
</P><P>// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, <A rel="nofollow" class="external free" href="https://github.com/jquery/jquery/pull/557">https://github.com/jquery/jquery/pull/557</A>)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}
</P><P>
return jQuery;
} );
&lt;/script&gt;</P><PRE>&lt;script&gt;/* FileSaver.js
* A saveAs() FileSaver implementation.
* 1.3.2
* 2016-06-16 18:25:19
*
* By Eli Grey, <A rel="nofollow" class="external free" href="http://eligrey.com">http://eligrey.com</A>
* License: MIT
*   See <A rel="nofollow" class="external free" href="https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md">https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md</A>
*/
</PRE><P>/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */
</P><P>/*! @source <A rel="nofollow" class="external free" href="http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js">http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js</A> */
</P><P>var saveAs = saveAs || (function(view) {
	&quot;use strict&quot;;
	// IE &lt;10 is explicitly unsupported
	if (typeof view === &quot;undefined&quot; || typeof navigator !== &quot;undefined&quot; &amp;&amp; /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS(&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot;, &quot;a&quot;)
		, can_use_save_link = &quot;download&quot; in save_link
		, click = function(node) {
			var event = new MouseEvent(&quot;click&quot;);
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = &quot;application/octet-stream&quot;
		// the Blob API is fundamentally broken as there is no &quot;downloadfinished&quot; event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === &quot;string&quot;) { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver[&quot;on&quot; + event_types[i]];
				if (typeof listener === &quot;function&quot;) {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, &quot;writestart progress write writeend&quot;.split(&quot; &quot;));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force &amp;&amp; is_safari)) &amp;&amp; view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, &quot;_blank&quot;);
						if (!opened) {
							// Apple does not allow window.open, see <A rel="nofollow" class="external free" href="https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html">https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html</A>
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;
</P><P>			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}
</P><P>			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || &quot;download&quot;, no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== &quot;undefined&quot; &amp;&amp; navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || &quot;download&quot;;
</P><P>			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}
</P><P>	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;
</P><P>	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;
</P><P>	return saveAs;
}(
	   typeof self !== &quot;undefined&quot; &amp;&amp; self
	|| typeof window !== &quot;undefined&quot; &amp;&amp; window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window
</P><P>if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) {
</P><PRE> module.exports.saveAs = saveAs;
</PRE><P>} else if ((typeof define !== &quot;undefined&quot; &amp;&amp; define !== null) &amp;&amp; (define.amd !== null)) {
</P><PRE> define(&quot;FileSaver.js&quot;, function() {
   return saveAs;
 });
</PRE><P>}
&lt;/script&gt;</P><PRE>&lt;script&gt;var URI=function(){function parse(uriStr){var m=(&quot;&quot;+uriStr).match(URI_RE_);if(!m){return null}return new URI(nullIfAbsent(m[1]),nullIfAbsent(m[2]),nullIfAbsent(m[3]),nullIfAbsent(m[4]),nullIfAbsent(m[5]),nullIfAbsent(m[6]),nullIfAbsent(m[7]))}function create(scheme,credentials,domain,port,path,query,fragment){var uri=new URI(encodeIfExists2(scheme,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),encodeIfExists2(credentials,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),encodeIfExists(domain),port&gt;0?port.toString():null,encodeIfExists2(path,URI_DISALLOWED_IN_PATH_),null,encodeIfExists(fragment));if(query){if(&quot;string&quot;===typeof query){uri.setRawQuery(query.replace(/[^?&amp;=0-9A-Za-z_\-~.%]/g,encodeOne))}else{uri.setAllParameters(query)}}return uri}function encodeIfExists(unescapedPart){if(&quot;string&quot;==typeof unescapedPart){return encodeURIComponent(unescapedPart)}return null}function encodeIfExists2(unescapedPart,extra){if(&quot;string&quot;==typeof unescapedPart){return encodeURI(unescapedPart).replace(extra,encodeOne)}return null}function encodeOne(ch){var n=ch.charCodeAt(0);return&quot;%&quot;+&quot;0123456789ABCDEF&quot;.charAt(n&gt;&gt;4&amp;15)+&quot;0123456789ABCDEF&quot;.charAt(n&amp;15)}function normPath(path){return path.replace(/(^|\/)\.(?:\/|$)/g,&quot;$1&quot;).replace(/\/{2,}/g,&quot;/&quot;)}var PARENT_DIRECTORY_HANDLER=new RegExp(&quot;&quot;+&quot;(/|^)&quot;+&quot;(?:[^./][^/]*|\\.{2,}(?:[^./][^/]*)|\\.{3,}[^/]*)&quot;+&quot;/\\.\\.(?:/|$)&quot;);var PARENT_DIRECTORY_HANDLER_RE=new RegExp(PARENT_DIRECTORY_HANDLER);var EXTRA_PARENT_PATHS_RE=/^(?:\.\.\/)*(?:\.\.$)?/;function collapse_dots(path){if(path===null){return null}var p=normPath(path);var r=PARENT_DIRECTORY_HANDLER_RE;for(var q;(q=p.replace(r,&quot;$1&quot;))!=p;p=q){}return p}function resolve(baseUri,relativeUri){var absoluteUri=baseUri.clone();var overridden=relativeUri.hasScheme();if(overridden){absoluteUri.setRawScheme(relativeUri.getRawScheme())}else{overridden=relativeUri.hasCredentials()}if(overridden){absoluteUri.setRawCredentials(relativeUri.getRawCredentials())}else{overridden=relativeUri.hasDomain()}if(overridden){absoluteUri.setRawDomain(relativeUri.getRawDomain())}else{overridden=relativeUri.hasPort()}var rawPath=relativeUri.getRawPath();var simplifiedPath=collapse_dots(rawPath);if(overridden){absoluteUri.setPort(relativeUri.getPort());simplifiedPath=simplifiedPath&amp;&amp;simplifiedPath.replace(EXTRA_PARENT_PATHS_RE,&quot;&quot;)}else{overridden=!!rawPath;if(overridden){if(simplifiedPath.charCodeAt(0)!==47){var absRawPath=collapse_dots(absoluteUri.getRawPath()||&quot;&quot;).replace(EXTRA_PARENT_PATHS_RE,&quot;&quot;);var slash=absRawPath.lastIndexOf(&quot;/&quot;)+1;simplifiedPath=collapse_dots((slash?absRawPath.substring(0,slash):&quot;&quot;)+collapse_dots(rawPath)).replace(EXTRA_PARENT_PATHS_RE,&quot;&quot;)}}else{simplifiedPath=simplifiedPath&amp;&amp;simplifiedPath.replace(EXTRA_PARENT_PATHS_RE,&quot;&quot;);if(simplifiedPath!==rawPath){absoluteUri.setRawPath(simplifiedPath)}}}if(overridden){absoluteUri.setRawPath(simplifiedPath)}else{overridden=relativeUri.hasQuery()}if(overridden){absoluteUri.setRawQuery(relativeUri.getRawQuery())}else{overridden=relativeUri.hasFragment()}if(overridden){absoluteUri.setRawFragment(relativeUri.getRawFragment())}return absoluteUri}function URI(rawScheme,rawCredentials,rawDomain,port,rawPath,rawQuery,rawFragment){this.scheme_=rawScheme;this.credentials_=rawCredentials;this.domain_=rawDomain;this.port_=port;this.path_=rawPath;this.query_=rawQuery;this.fragment_=rawFragment;this.paramCache_=null}URI.prototype.toString=function(){var out=[];if(null!==this.scheme_){out.push(this.scheme_,&quot;:&quot;)}if(null!==this.domain_){out.push(&quot;//&quot;);if(null!==this.credentials_){out.push(this.credentials_,&quot;@&quot;)}out.push(this.domain_);if(null!==this.port_){out.push(&quot;:&quot;,this.port_.toString())}}if(null!==this.path_){out.push(this.path_)}if(null!==this.query_){out.push(&quot;?&quot;,this.query_)}if(null!==this.fragment_){out.push(&quot;#&quot;,this.fragment_)}return out.join(&quot;&quot;)};URI.prototype.clone=function(){return new URI(this.scheme_,this.credentials_,this.domain_,this.port_,this.path_,this.query_,this.fragment_)};URI.prototype.getScheme=function(){return this.scheme_&amp;&amp;decodeURIComponent(this.scheme_).toLowerCase()};URI.prototype.getRawScheme=function(){return this.scheme_};URI.prototype.setScheme=function(newScheme){this.scheme_=encodeIfExists2(newScheme,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);return this};URI.prototype.setRawScheme=function(newScheme){this.scheme_=newScheme?newScheme:null;return this};URI.prototype.hasScheme=function(){return null!==this.scheme_};URI.prototype.getCredentials=function(){return this.credentials_&amp;&amp;decodeURIComponent(this.credentials_)};URI.prototype.getRawCredentials=function(){return this.credentials_};URI.prototype.setCredentials=function(newCredentials){this.credentials_=encodeIfExists2(newCredentials,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);return this};URI.prototype.setRawCredentials=function(newCredentials){this.credentials_=newCredentials?newCredentials:null;return this};URI.prototype.hasCredentials=function(){return null!==this.credentials_};URI.prototype.getDomain=function(){return this.domain_&amp;&amp;decodeURIComponent(this.domain_)};URI.prototype.getRawDomain=function(){return this.domain_};URI.prototype.setDomain=function(newDomain){return this.setRawDomain(newDomain&amp;&amp;encodeURIComponent(newDomain))};URI.prototype.setRawDomain=function(newDomain){this.domain_=newDomain?newDomain:null;return this.setRawPath(this.path_)};URI.prototype.hasDomain=function(){return null!==this.domain_};URI.prototype.getPort=function(){return this.port_&amp;&amp;decodeURIComponent(this.port_)};URI.prototype.setPort=function(newPort){if(newPort){newPort=Number(newPort);if(newPort!==(newPort&amp;65535)){throw new Error(&quot;Bad port number &quot;+newPort)}this.port_=&quot;&quot;+newPort}else{this.port_=null}return this};URI.prototype.hasPort=function(){return null!==this.port_};URI.prototype.getPath=function(){return this.path_&amp;&amp;decodeURIComponent(this.path_)};URI.prototype.getRawPath=function(){return this.path_};URI.prototype.setPath=function(newPath){return this.setRawPath(encodeIfExists2(newPath,URI_DISALLOWED_IN_PATH_))};URI.prototype.setRawPath=function(newPath){if(newPath){newPath=String(newPath);this.path_=!this.domain_||/^\//.test(newPath)?newPath:&quot;/&quot;+newPath}else{this.path_=null}return this};URI.prototype.hasPath=function(){return null!==this.path_};URI.prototype.getQuery=function(){return this.query_&amp;&amp;decodeURIComponent(this.query_).replace(/\+/g,&quot; &quot;)};URI.prototype.getRawQuery=function(){return this.query_};URI.prototype.setQuery=function(newQuery){this.paramCache_=null;this.query_=encodeIfExists(newQuery);return this};URI.prototype.setRawQuery=function(newQuery){this.paramCache_=null;this.query_=newQuery?newQuery:null;return this};URI.prototype.hasQuery=function(){return null!==this.query_};URI.prototype.setAllParameters=function(params){if(typeof params===&quot;object&quot;){if(!(params instanceof Array)&amp;&amp;(params instanceof Object||Object.prototype.toString.call(params)!==&quot;[object Array]&quot;)){var newParams=[];var i=-1;for(var k in params){var v=params[k];if(&quot;string&quot;===typeof v){newParams[++i]=k;newParams[++i]=v}}params=newParams}}this.paramCache_=null;var queryBuf=[];var separator=&quot;&quot;;for(var j=0;j&lt;params.length;){var k=params[j++];var v=params[j++];queryBuf.push(separator,encodeURIComponent(k.toString()));separator=&quot;&amp;&quot;;if(v){queryBuf.push(&quot;=&quot;,encodeURIComponent(v.toString()))}}this.query_=queryBuf.join(&quot;&quot;);return this};URI.prototype.checkParameterCache_=function(){if(!this.paramCache_){var q=this.query_;if(!q){this.paramCache_=[]}else{var cgiParams=q.split(/[&amp;\?]/);var out=[];var k=-1;for(var i=0;i&lt;cgiParams.length;++i){var m=cgiParams[i].match(/^([^=]*)(?:=(.*))?$/);out[++k]=decodeURIComponent(m[1]).replace(/\+/g,&quot; &quot;);out[++k]=decodeURIComponent(m[2]||&quot;&quot;).replace(/\+/g,&quot; &quot;)}this.paramCache_=out}}};URI.prototype.setParameterValues=function(key,values){if(typeof values===&quot;string&quot;){values=[values]}this.checkParameterCache_();var newValueIndex=0;var pc=this.paramCache_;var params=[];for(var i=0,k=0;i&lt;pc.length;i+=2){if(key===pc[i]){if(newValueIndex&lt;values.length){params.push(key,values[newValueIndex++])}}else{params.push(pc[i],pc[i+1])}}while(newValueIndex&lt;values.length){params.push(key,values[newValueIndex++])}this.setAllParameters(params);return this};URI.prototype.removeParameter=function(key){return this.setParameterValues(key,[])};URI.prototype.getAllParameters=function(){this.checkParameterCache_();return this.paramCache_.slice(0,this.paramCache_.length)};URI.prototype.getParameterValues=function(paramNameUnescaped){this.checkParameterCache_();var values=[];for(var i=0;i&lt;this.paramCache_.length;i+=2){if(paramNameUnescaped===this.paramCache_[i]){values.push(this.paramCache_[i+1])}}return values};URI.prototype.getParameterMap=function(paramNameUnescaped){this.checkParameterCache_();var paramMap={};for(var i=0;i&lt;this.paramCache_.length;i+=2){var key=this.paramCache_[i++],value=this.paramCache_[i++];if(!(key in paramMap)){paramMap[key]=[value]}else{paramMap[key].push(value)}}return paramMap};URI.prototype.getParameterValue=function(paramNameUnescaped){this.checkParameterCache_();for(var i=0;i&lt;this.paramCache_.length;i+=2){if(paramNameUnescaped===this.paramCache_[i]){return this.paramCache_[i+1]}}return null};URI.prototype.getFragment=function(){return this.fragment_&amp;&amp;decodeURIComponent(this.fragment_)};URI.prototype.getRawFragment=function(){return this.fragment_};URI.prototype.setFragment=function(newFragment){this.fragment_=newFragment?encodeURIComponent(newFragment):null;return this};URI.prototype.setRawFragment=function(newFragment){this.fragment_=newFragment?newFragment:null;return this};URI.prototype.hasFragment=function(){return null!==this.fragment_};function nullIfAbsent(matchPart){return&quot;string&quot;==typeof matchPart&amp;&amp;matchPart.length&gt;0?matchPart:null}var URI_RE_=new RegExp(&quot;^&quot;+&quot;(?:&quot;+&quot;([^:/?#]+)&quot;+&quot;:)?&quot;+&quot;(?://&quot;+&quot;(?:([^/?#]*)@)?&quot;+&quot;([^/?#:@]*)&quot;+&quot;(?::([0-9]+))?&quot;+&quot;)?&quot;+&quot;([^?#]+)?&quot;+&quot;(?:\\?([^#]*))?&quot;+&quot;(?:#(.*))?&quot;+&quot;$&quot;);var URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_=/[#\/\?@]/g;var URI_DISALLOWED_IN_PATH_=/[\#\?]/g;URI.parse=parse;URI.create=create;URI.resolve=resolve;URI.collapse_dots=collapse_dots;URI.utils={mimeTypeOf:function(uri){var uriObj=parse(uri);if(/\.html$/.test(uriObj.getPath())){return&quot;text/html&quot;}else{return&quot;application/javascript&quot;}},resolve:function(base,uri){if(base){return resolve(parse(base),parse(uri)).toString()}else{return&quot;&quot;+uri}}};return URI}();if(typeof window!==&quot;undefined&quot;){window[&quot;URI&quot;]=URI}var html4={};html4.atype={NONE:0,URI:1,URI_FRAGMENT:11,SCRIPT:2,STYLE:3,HTML:12,ID:4,IDREF:5,IDREFS:6,GLOBAL_NAME:7,LOCAL_NAME:8,CLASSES:9,FRAME_TARGET:10,MEDIA_QUERY:13};html4[&quot;atype&quot;]=html4.atype;html4.ATTRIBS={&quot;*::class&quot;:9,&quot;*::dir&quot;:0,&quot;*::draggable&quot;:0,&quot;*::hidden&quot;:0,&quot;*::id&quot;:4,&quot;*::inert&quot;:0,&quot;*::itemprop&quot;:0,&quot;*::itemref&quot;:6,&quot;*::itemscope&quot;:0,&quot;*::lang&quot;:0,&quot;*::onblur&quot;:2,&quot;*::onchange&quot;:2,&quot;*::onclick&quot;:2,&quot;*::ondblclick&quot;:2,&quot;*::onerror&quot;:2,&quot;*::onfocus&quot;:2,&quot;*::onkeydown&quot;:2,&quot;*::onkeypress&quot;:2,&quot;*::onkeyup&quot;:2,&quot;*::onload&quot;:2,&quot;*::onmousedown&quot;:2,&quot;*::onmousemove&quot;:2,&quot;*::onmouseout&quot;:2,&quot;*::onmouseover&quot;:2,&quot;*::onmouseup&quot;:2,&quot;*::onreset&quot;:2,&quot;*::onscroll&quot;:2,&quot;*::onselect&quot;:2,&quot;*::onsubmit&quot;:2,&quot;*::ontouchcancel&quot;:2,&quot;*::ontouchend&quot;:2,&quot;*::ontouchenter&quot;:2,&quot;*::ontouchleave&quot;:2,&quot;*::ontouchmove&quot;:2,&quot;*::ontouchstart&quot;:2,&quot;*::onunload&quot;:2,&quot;*::spellcheck&quot;:0,&quot;*::style&quot;:3,&quot;*::tabindex&quot;:0,&quot;*::title&quot;:0,&quot;*::translate&quot;:0,&quot;a::accesskey&quot;:0,&quot;a::coords&quot;:0,&quot;a::href&quot;:1,&quot;a::hreflang&quot;:0,&quot;a::name&quot;:7,&quot;a::onblur&quot;:2,&quot;a::onfocus&quot;:2,&quot;a::shape&quot;:0,&quot;a::target&quot;:10,&quot;a::type&quot;:0,&quot;area::accesskey&quot;:0,&quot;area::alt&quot;:0,&quot;area::coords&quot;:0,&quot;area::href&quot;:1,&quot;area::nohref&quot;:0,&quot;area::onblur&quot;:2,&quot;area::onfocus&quot;:2,&quot;area::shape&quot;:0,&quot;area::target&quot;:10,&quot;audio::controls&quot;:0,&quot;audio::loop&quot;:0,&quot;audio::mediagroup&quot;:5,&quot;audio::muted&quot;:0,&quot;audio::preload&quot;:0,&quot;audio::src&quot;:1,&quot;bdo::dir&quot;:0,&quot;blockquote::cite&quot;:1,&quot;br::clear&quot;:0,&quot;button::accesskey&quot;:0,&quot;button::disabled&quot;:0,&quot;button::name&quot;:8,&quot;button::onblur&quot;:2,&quot;button::onfocus&quot;:2,&quot;button::type&quot;:0,&quot;button::value&quot;:0,&quot;canvas::height&quot;:0,&quot;canvas::width&quot;:0,&quot;caption::align&quot;:0,&quot;col::align&quot;:0,&quot;col::char&quot;:0,&quot;col::charoff&quot;:0,&quot;col::span&quot;:0,&quot;col::valign&quot;:0,&quot;col::width&quot;:0,&quot;colgroup::align&quot;:0,&quot;colgroup::char&quot;:0,&quot;colgroup::charoff&quot;:0,&quot;colgroup::span&quot;:0,&quot;colgroup::valign&quot;:0,&quot;colgroup::width&quot;:0,&quot;command::checked&quot;:0,&quot;command::command&quot;:5,&quot;command::disabled&quot;:0,&quot;command::icon&quot;:1,&quot;command::label&quot;:0,&quot;command::radiogroup&quot;:0,&quot;command::type&quot;:0,&quot;data::value&quot;:0,&quot;del::cite&quot;:1,&quot;del::datetime&quot;:0,&quot;details::open&quot;:0,&quot;dir::compact&quot;:0,&quot;div::align&quot;:0,&quot;dl::compact&quot;:0,&quot;fieldset::disabled&quot;:0,&quot;font::color&quot;:0,&quot;font::face&quot;:0,&quot;font::size&quot;:0,&quot;form::accept&quot;:0,&quot;form::action&quot;:1,&quot;form::autocomplete&quot;:0,&quot;form::enctype&quot;:0,&quot;form::method&quot;:0,&quot;form::name&quot;:7,&quot;form::novalidate&quot;:0,&quot;form::onreset&quot;:2,&quot;form::onsubmit&quot;:2,&quot;form::target&quot;:10,&quot;h1::align&quot;:0,&quot;h2::align&quot;:0,&quot;h3::align&quot;:0,&quot;h4::align&quot;:0,&quot;h5::align&quot;:0,&quot;h6::align&quot;:0,&quot;hr::align&quot;:0,&quot;hr::noshade&quot;:0,&quot;hr::size&quot;:0,&quot;hr::width&quot;:0,&quot;iframe::align&quot;:0,&quot;iframe::frameborder&quot;:0,&quot;iframe::height&quot;:0,&quot;iframe::marginheight&quot;:0,&quot;iframe::marginwidth&quot;:0,&quot;iframe::width&quot;:0,&quot;img::align&quot;:0,&quot;img::alt&quot;:0,&quot;img::border&quot;:0,&quot;img::height&quot;:0,&quot;img::hspace&quot;:0,&quot;img::ismap&quot;:0,&quot;img::name&quot;:7,&quot;img::src&quot;:1,&quot;img::usemap&quot;:11,&quot;img::vspace&quot;:0,&quot;img::width&quot;:0,&quot;input::accept&quot;:0,&quot;input::accesskey&quot;:0,&quot;input::align&quot;:0,&quot;input::alt&quot;:0,&quot;input::autocomplete&quot;:0,&quot;input::checked&quot;:0,&quot;input::disabled&quot;:0,&quot;input::inputmode&quot;:0,&quot;input::ismap&quot;:0,&quot;input::list&quot;:5,&quot;input::max&quot;:0,&quot;input::maxlength&quot;:0,&quot;input::min&quot;:0,&quot;input::multiple&quot;:0,&quot;input::name&quot;:8,&quot;input::onblur&quot;:2,&quot;input::onchange&quot;:2,&quot;input::onfocus&quot;:2,&quot;input::onselect&quot;:2,&quot;input::pattern&quot;:0,&quot;input::placeholder&quot;:0,&quot;input::readonly&quot;:0,&quot;input::required&quot;:0,&quot;input::size&quot;:0,&quot;input::src&quot;:1,&quot;input::step&quot;:0,&quot;input::type&quot;:0,&quot;input::usemap&quot;:11,&quot;input::value&quot;:0,&quot;ins::cite&quot;:1,&quot;ins::datetime&quot;:0,&quot;label::accesskey&quot;:0,&quot;label::for&quot;:5,&quot;label::onblur&quot;:2,&quot;label::onfocus&quot;:2,&quot;legend::accesskey&quot;:0,&quot;legend::align&quot;:0,&quot;li::type&quot;:0,&quot;li::value&quot;:0,&quot;map::name&quot;:7,&quot;menu::compact&quot;:0,&quot;menu::label&quot;:0,&quot;menu::type&quot;:0,&quot;meter::high&quot;:0,&quot;meter::low&quot;:0,&quot;meter::max&quot;:0,&quot;meter::min&quot;:0,&quot;meter::optimum&quot;:0,&quot;meter::value&quot;:0,&quot;ol::compact&quot;:0,&quot;ol::reversed&quot;:0,&quot;ol::start&quot;:0,&quot;ol::type&quot;:0,&quot;optgroup::disabled&quot;:0,&quot;optgroup::label&quot;:0,&quot;option::disabled&quot;:0,&quot;option::label&quot;:0,&quot;option::selected&quot;:0,&quot;option::value&quot;:0,&quot;output::for&quot;:6,&quot;output::name&quot;:8,&quot;p::align&quot;:0,&quot;pre::width&quot;:0,&quot;progress::max&quot;:0,&quot;progress::min&quot;:0,&quot;progress::value&quot;:0,&quot;q::cite&quot;:1,&quot;select::autocomplete&quot;:0,&quot;select::disabled&quot;:0,&quot;select::multiple&quot;:0,&quot;select::name&quot;:8,&quot;select::onblur&quot;:2,&quot;select::onchange&quot;:2,&quot;select::onfocus&quot;:2,&quot;select::required&quot;:0,&quot;select::size&quot;:0,&quot;source::type&quot;:0,&quot;table::align&quot;:0,&quot;table::bgcolor&quot;:0,&quot;table::border&quot;:0,&quot;table::cellpadding&quot;:0,&quot;table::cellspacing&quot;:0,&quot;table::frame&quot;:0,&quot;table::rules&quot;:0,&quot;table::summary&quot;:0,&quot;table::width&quot;:0,&quot;tbody::align&quot;:0,&quot;tbody::char&quot;:0,&quot;tbody::charoff&quot;:0,&quot;tbody::valign&quot;:0,&quot;td::abbr&quot;:0,&quot;td::align&quot;:0,&quot;td::axis&quot;:0,&quot;td::bgcolor&quot;:0,&quot;td::char&quot;:0,&quot;td::charoff&quot;:0,&quot;td::colspan&quot;:0,&quot;td::headers&quot;:6,&quot;td::height&quot;:0,&quot;td::nowrap&quot;:0,&quot;td::rowspan&quot;:0,&quot;td::scope&quot;:0,&quot;td::valign&quot;:0,&quot;td::width&quot;:0,&quot;textarea::accesskey&quot;:0,&quot;textarea::autocomplete&quot;:0,&quot;textarea::cols&quot;:0,&quot;textarea::disabled&quot;:0,&quot;textarea::inputmode&quot;:0,&quot;textarea::name&quot;:8,&quot;textarea::onblur&quot;:2,&quot;textarea::onchange&quot;:2,&quot;textarea::onfocus&quot;:2,&quot;textarea::onselect&quot;:2,&quot;textarea::placeholder&quot;:0,&quot;textarea::readonly&quot;:0,&quot;textarea::required&quot;:0,&quot;textarea::rows&quot;:0,&quot;textarea::wrap&quot;:0,&quot;tfoot::align&quot;:0,&quot;tfoot::char&quot;:0,&quot;tfoot::charoff&quot;:0,&quot;tfoot::valign&quot;:0,&quot;th::abbr&quot;:0,&quot;th::align&quot;:0,&quot;th::axis&quot;:0,&quot;th::bgcolor&quot;:0,&quot;th::char&quot;:0,&quot;th::charoff&quot;:0,&quot;th::colspan&quot;:0,&quot;th::headers&quot;:6,&quot;th::height&quot;:0,&quot;th::nowrap&quot;:0,&quot;th::rowspan&quot;:0,&quot;th::scope&quot;:0,&quot;th::valign&quot;:0,&quot;th::width&quot;:0,&quot;thead::align&quot;:0,&quot;thead::char&quot;:0,&quot;thead::charoff&quot;:0,&quot;thead::valign&quot;:0,&quot;tr::align&quot;:0,&quot;tr::bgcolor&quot;:0,&quot;tr::char&quot;:0,&quot;tr::charoff&quot;:0,&quot;tr::valign&quot;:0,&quot;track::default&quot;:0,&quot;track::kind&quot;:0,&quot;track::label&quot;:0,&quot;track::srclang&quot;:0,&quot;ul::compact&quot;:0,&quot;ul::type&quot;:0,&quot;video::controls&quot;:0,&quot;video::height&quot;:0,&quot;video::loop&quot;:0,&quot;video::mediagroup&quot;:5,&quot;video::muted&quot;:0,&quot;video::poster&quot;:1,&quot;video::preload&quot;:0,&quot;video::src&quot;:1,&quot;video::width&quot;:0};html4[&quot;ATTRIBS&quot;]=html4.ATTRIBS;html4.eflags={OPTIONAL_ENDTAG:1,EMPTY:2,CDATA:4,RCDATA:8,UNSAFE:16,FOLDABLE:32,SCRIPT:64,STYLE:128,VIRTUALIZED:256};html4[&quot;eflags&quot;]=html4.eflags;html4.ELEMENTS={a:0,abbr:0,acronym:0,address:0,applet:272,area:2,article:0,aside:0,audio:0,b:0,base:274,basefont:274,bdi:0,bdo:0,big:0,blockquote:0,body:305,br:2,button:0,canvas:0,caption:0,center:0,cite:0,code:0,col:2,colgroup:1,command:2,data:0,datalist:0,dd:1,del:0,details:0,dfn:0,dialog:272,dir:0,div:0,dl:0,dt:1,em:0,fieldset:0,figcaption:0,figure:0,font:0,footer:0,form:0,frame:274,frameset:272,h1:0,h2:0,h3:0,h4:0,h5:0,h6:0,head:305,header:0,hgroup:0,hr:2,html:305,i:0,iframe:4,img:2,input:2,ins:0,isindex:274,kbd:0,keygen:274,label:0,legend:0,li:1,link:274,map:0,mark:0,menu:0,meta:274,meter:0,nav:0,nobr:0,noembed:276,noframes:276,noscript:276,object:272,ol:0,optgroup:0,option:1,output:0,p:1,param:274,pre:0,progress:0,q:0,s:0,samp:0,script:84,section:0,select:0,small:0,source:2,span:0,strike:0,strong:0,style:148,sub:0,summary:0,sup:0,table:0,tbody:1,td:1,textarea:8,tfoot:1,th:1,thead:1,time:0,title:280,tr:1,track:2,tt:0,u:0,ul:0,&quot;var&quot;:0,video:0,wbr:2};html4[&quot;ELEMENTS&quot;]=html4.ELEMENTS;html4.ELEMENT_DOM_INTERFACES={a:&quot;HTMLAnchorElement&quot;,abbr:&quot;HTMLElement&quot;,acronym:&quot;HTMLElement&quot;,address:&quot;HTMLElement&quot;,applet:&quot;HTMLAppletElement&quot;,area:&quot;HTMLAreaElement&quot;,article:&quot;HTMLElement&quot;,aside:&quot;HTMLElement&quot;,audio:&quot;HTMLAudioElement&quot;,b:&quot;HTMLElement&quot;,base:&quot;HTMLBaseElement&quot;,basefont:&quot;HTMLBaseFontElement&quot;,bdi:&quot;HTMLElement&quot;,bdo:&quot;HTMLElement&quot;,big:&quot;HTMLElement&quot;,blockquote:&quot;HTMLQuoteElement&quot;,body:&quot;HTMLBodyElement&quot;,br:&quot;HTMLBRElement&quot;,button:&quot;HTMLButtonElement&quot;,canvas:&quot;HTMLCanvasElement&quot;,caption:&quot;HTMLTableCaptionElement&quot;,center:&quot;HTMLElement&quot;,cite:&quot;HTMLElement&quot;,code:&quot;HTMLElement&quot;,col:&quot;HTMLTableColElement&quot;,colgroup:&quot;HTMLTableColElement&quot;,command:&quot;HTMLCommandElement&quot;,data:&quot;HTMLElement&quot;,datalist:&quot;HTMLDataListElement&quot;,dd:&quot;HTMLElement&quot;,del:&quot;HTMLModElement&quot;,details:&quot;HTMLDetailsElement&quot;,dfn:&quot;HTMLElement&quot;,dialog:&quot;HTMLDialogElement&quot;,dir:&quot;HTMLDirectoryElement&quot;,div:&quot;HTMLDivElement&quot;,dl:&quot;HTMLDListElement&quot;,dt:&quot;HTMLElement&quot;,em:&quot;HTMLElement&quot;,fieldset:&quot;HTMLFieldSetElement&quot;,figcaption:&quot;HTMLElement&quot;,figure:&quot;HTMLElement&quot;,font:&quot;HTMLFontElement&quot;,footer:&quot;HTMLElement&quot;,form:&quot;HTMLFormElement&quot;,frame:&quot;HTMLFrameElement&quot;,frameset:&quot;HTMLFrameSetElement&quot;,h1:&quot;HTMLHeadingElement&quot;,h2:&quot;HTMLHeadingElement&quot;,h3:&quot;HTMLHeadingElement&quot;,h4:&quot;HTMLHeadingElement&quot;,h5:&quot;HTMLHeadingElement&quot;,h6:&quot;HTMLHeadingElement&quot;,head:&quot;HTMLHeadElement&quot;,header:&quot;HTMLElement&quot;,hgroup:&quot;HTMLElement&quot;,hr:&quot;HTMLHRElement&quot;,html:&quot;HTMLHtmlElement&quot;,i:&quot;HTMLElement&quot;,iframe:&quot;HTMLIFrameElement&quot;,img:&quot;HTMLImageElement&quot;,input:&quot;HTMLInputElement&quot;,ins:&quot;HTMLModElement&quot;,isindex:&quot;HTMLUnknownElement&quot;,kbd:&quot;HTMLElement&quot;,keygen:&quot;HTMLKeygenElement&quot;,label:&quot;HTMLLabelElement&quot;,legend:&quot;HTMLLegendElement&quot;,li:&quot;HTMLLIElement&quot;,link:&quot;HTMLLinkElement&quot;,map:&quot;HTMLMapElement&quot;,mark:&quot;HTMLElement&quot;,menu:&quot;HTMLMenuElement&quot;,meta:&quot;HTMLMetaElement&quot;,meter:&quot;HTMLMeterElement&quot;,nav:&quot;HTMLElement&quot;,nobr:&quot;HTMLElement&quot;,noembed:&quot;HTMLElement&quot;,noframes:&quot;HTMLElement&quot;,noscript:&quot;HTMLElement&quot;,object:&quot;HTMLObjectElement&quot;,ol:&quot;HTMLOListElement&quot;,optgroup:&quot;HTMLOptGroupElement&quot;,option:&quot;HTMLOptionElement&quot;,output:&quot;HTMLOutputElement&quot;,p:&quot;HTMLParagraphElement&quot;,param:&quot;HTMLParamElement&quot;,pre:&quot;HTMLPreElement&quot;,progress:&quot;HTMLProgressElement&quot;,q:&quot;HTMLQuoteElement&quot;,s:&quot;HTMLElement&quot;,samp:&quot;HTMLElement&quot;,script:&quot;HTMLScriptElement&quot;,section:&quot;HTMLElement&quot;,select:&quot;HTMLSelectElement&quot;,small:&quot;HTMLElement&quot;,source:&quot;HTMLSourceElement&quot;,span:&quot;HTMLSpanElement&quot;,strike:&quot;HTMLElement&quot;,strong:&quot;HTMLElement&quot;,style:&quot;HTMLStyleElement&quot;,sub:&quot;HTMLElement&quot;,summary:&quot;HTMLElement&quot;,sup:&quot;HTMLElement&quot;,table:&quot;HTMLTableElement&quot;,tbody:&quot;HTMLTableSectionElement&quot;,td:&quot;HTMLTableDataCellElement&quot;,textarea:&quot;HTMLTextAreaElement&quot;,tfoot:&quot;HTMLTableSectionElement&quot;,th:&quot;HTMLTableHeaderCellElement&quot;,thead:&quot;HTMLTableSectionElement&quot;,time:&quot;HTMLTimeElement&quot;,title:&quot;HTMLTitleElement&quot;,tr:&quot;HTMLTableRowElement&quot;,track:&quot;HTMLTrackElement&quot;,tt:&quot;HTMLElement&quot;,u:&quot;HTMLElement&quot;,ul:&quot;HTMLUListElement&quot;,&quot;var&quot;:&quot;HTMLElement&quot;,video:&quot;HTMLVideoElement&quot;,wbr:&quot;HTMLElement&quot;};html4[&quot;ELEMENT_DOM_INTERFACES&quot;]=html4.ELEMENT_DOM_INTERFACES;html4.ueffects={NOT_LOADED:0,SAME_DOCUMENT:1,NEW_DOCUMENT:2};html4[&quot;ueffects&quot;]=html4.ueffects;html4.URIEFFECTS={&quot;a::href&quot;:2,&quot;area::href&quot;:2,&quot;audio::src&quot;:1,&quot;blockquote::cite&quot;:0,&quot;command::icon&quot;:1,&quot;del::cite&quot;:0,&quot;form::action&quot;:2,&quot;img::src&quot;:1,&quot;input::src&quot;:1,&quot;ins::cite&quot;:0,&quot;q::cite&quot;:0,&quot;video::poster&quot;:1,&quot;video::src&quot;:1};html4[&quot;URIEFFECTS&quot;]=html4.URIEFFECTS;html4.ltypes={UNSANDBOXED:2,SANDBOXED:1,DATA:0};html4[&quot;ltypes&quot;]=html4.ltypes;html4.LOADERTYPES={&quot;a::href&quot;:2,&quot;area::href&quot;:2,&quot;audio::src&quot;:2,&quot;blockquote::cite&quot;:2,&quot;command::icon&quot;:1,&quot;del::cite&quot;:2,&quot;form::action&quot;:2,&quot;img::src&quot;:1,&quot;input::src&quot;:1,&quot;ins::cite&quot;:2,&quot;q::cite&quot;:2,&quot;video::poster&quot;:1,&quot;video::src&quot;:2};html4[&quot;LOADERTYPES&quot;]=html4.LOADERTYPES;if(typeof window!==&quot;undefined&quot;){window[&quot;html4&quot;]=html4}if(&quot;I&quot;.toLowerCase()!==&quot;i&quot;){throw&quot;I/i problem&quot;}var defs={};defs.TagPolicyDecision;defs.TagPolicy;var html=function(html4){var parseCssDeclarations,sanitizeCssProperty,cssSchema;if(&quot;undefined&quot;!==typeof window){parseCssDeclarations=window[&quot;parseCssDeclarations&quot;];sanitizeCssProperty=window[&quot;sanitizeCssProperty&quot;];cssSchema=window[&quot;cssSchema&quot;]}var ENTITIES={lt:&quot;&lt;&quot;,LT:&quot;&lt;&quot;,gt:&quot;&gt;&quot;,GT:&quot;&gt;&quot;,amp:&quot;&amp;&quot;,AMP:&quot;&amp;&quot;,quot:'&quot;',apos:&quot;'&quot;,nbsp:&quot; &quot;};var decimalEscapeRe=/^#(\d+)$/;var hexEscapeRe=/^#x([0-9A-Fa-f]+)$/;var safeEntityNameRe=/^[A-Za-z][A-za-z0-9]+$/;var entityLookupElement=&quot;undefined&quot;!==typeof window&amp;&amp;window[&quot;document&quot;]?window[&quot;document&quot;].createElement(&quot;textarea&quot;):null;function lookupEntity(name){if(ENTITIES.hasOwnProperty(name)){return ENTITIES[name]}var m=name.match(decimalEscapeRe);if(m){return String.fromCharCode(parseInt(m[1],10))}else if(!!(m=name.match(hexEscapeRe))){return String.fromCharCode(parseInt(m[1],16))}else if(entityLookupElement&amp;&amp;safeEntityNameRe.test(name)){entityLookupElement.innerHTML=&quot;&amp;&quot;+name+&quot;;&quot;;var text=entityLookupElement.textContent;ENTITIES[name]=text;return text}else{return&quot;&amp;&quot;+name+&quot;;&quot;}}function decodeOneEntity(_,name){return lookupEntity(name)}var nulRe=/\0/g;function stripNULs(s){return s.replace(nulRe,&quot;&quot;)}var ENTITY_RE_1=/&amp;(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/g;var ENTITY_RE_2=/^(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/;function unescapeEntities(s){return s.replace(ENTITY_RE_1,decodeOneEntity)}var ampRe=/&amp;/g;var looseAmpRe=/&amp;([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi;var ltRe=/[&lt;]/g;var gtRe=/&gt;/g;var quotRe=/\&quot;/g;function escapeAttrib(s){return(&quot;&quot;+s).replace(ampRe,&quot;&amp;&quot;).replace(ltRe,&quot;&lt;&quot;).replace(gtRe,&quot;&gt;&quot;).replace(quotRe,&quot;&quot;&quot;)}function normalizeRCData(rcdata){return rcdata.replace(looseAmpRe,&quot;&amp;$1&quot;).replace(ltRe,&quot;&lt;&quot;).replace(gtRe,&quot;&gt;&quot;)}var ATTR_RE=new RegExp(&quot;^\\s*&quot;+&quot;([-.:\\w]+)&quot;+&quot;(?:&quot;+(&quot;\\s*(=)\\s*&quot;+&quot;(&quot;+('(&quot;)[^&quot;]*(&quot;|$)'+&quot;|&quot;+&quot;(')[^']*('|$)&quot;+&quot;|&quot;+&quot;(?=[a-z][-\\w]*\\s*=)&quot;+&quot;|&quot;+&quot;[^\&quot;'\\s]*&quot;)+&quot;)&quot;)+&quot;)?&quot;,&quot;i&quot;);var splitWillCapture=&quot;a,b&quot;.split(/(,)/).length===3;var EFLAGS_TEXT=html4.eflags[&quot;CDATA&quot;]|html4.eflags[&quot;RCDATA&quot;];function makeSaxParser(handler){var hcopy={cdata:handler.cdata||handler[&quot;cdata&quot;],comment:handler.comment||handler[&quot;comment&quot;],endDoc:handler.endDoc||handler[&quot;endDoc&quot;],endTag:handler.endTag||handler[&quot;endTag&quot;],pcdata:handler.pcdata||handler[&quot;pcdata&quot;],rcdata:handler.rcdata||handler[&quot;rcdata&quot;],startDoc:handler.startDoc||handler[&quot;startDoc&quot;],startTag:handler.startTag||handler[&quot;startTag&quot;]};return function(htmlText,param){return parse(htmlText,hcopy,param)}}var continuationMarker={};function parse(htmlText,handler,param){var m,p,tagName;var parts=htmlSplit(htmlText);var state={noMoreGT:false,noMoreEndComments:false};parseCPS(handler,parts,0,state,param)}function continuationMaker(h,parts,initial,state,param){return function(){parseCPS(h,parts,initial,state,param)}}function parseCPS(h,parts,initial,state,param){try{if(h.startDoc&amp;&amp;initial==0){h.startDoc(param)}var m,p,tagName;for(var pos=initial,end=parts.length;pos&lt;end;){var current=parts[pos++];var next=parts[pos];switch(current){case&quot;&amp;&quot;:if(ENTITY_RE_2.test(next)){if(h.pcdata){h.pcdata(&quot;&amp;&quot;+next,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}pos++}else{if(h.pcdata){h.pcdata(&quot;&amp;&quot;,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case&quot;&lt;/&quot;:if(m=/^([-\w:]+)[^\'\&quot;]*/.exec(next)){if(m[0].length===next.length&amp;&amp;parts[pos+1]===&quot;&gt;&quot;){pos+=2;tagName=m[1].toLowerCase();if(h.endTag){h.endTag(tagName,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}else{pos=parseEndTag(parts,pos,h,param,continuationMarker,state)}}else{if(h.pcdata){h.pcdata(&quot;&lt;/&quot;,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case&quot;&lt;&quot;:if(m=/^([-\w:]+)\s*\/?/.exec(next)){if(m[0].length===next.length&amp;&amp;parts[pos+1]===&quot;&gt;&quot;){pos+=2;tagName=m[1].toLowerCase();if(h.startTag){h.startTag(tagName,[],param,continuationMarker,continuationMaker(h,parts,pos,state,param))}var eflags=html4.ELEMENTS[tagName];if(eflags&amp;EFLAGS_TEXT){var tag={name:tagName,next:pos,eflags:eflags};pos=parseText(parts,tag,h,param,continuationMarker,state)}}else{pos=parseStartTag(parts,pos,h,param,continuationMarker,state)}}else{if(h.pcdata){h.pcdata(&quot;&lt;&quot;,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case&quot;' +
               '&lt;style&gt;td{border:none;font-family: Calibri, sans-serif;} .number{mso-number-format:&quot;0.00&quot;;}&lt;/style&gt;' +
               '&lt;meta name=ProgId content=Excel.Sheet&gt;' +
               '&lt;meta charset=UTF-8&gt;' +
               '&lt;/head&gt;&lt;body&gt;' +
               this.getTable(true) +
               '&lt;/body&gt;&lt;/html&gt;',
           base64 = function (s) { 
               return window.btoa(unescape(encodeURIComponent(s))); // #50
           };
       getContent(
           this,
           uri + base64(template),
           'xls',
           template,
           'application/vnd.ms-excel'
       );
   };
</PRE><PRE>   /**
    * View the data in a table below the chart
    */
   Highcharts.Chart.prototype.viewData = function () {
       if (!this.insertedTable) {
           var div = document.createElement('div');
           div.className = 'highcharts-data-table';
           // Insert after the chart container
           this.renderTo.parentNode.insertBefore(div, this.renderTo.nextSibling);
           div.innerHTML = this.getTable();
           this.insertedTable = true;
       }
   };
</PRE><PRE>   // Add &quot;Download CSV&quot; to the exporting menu. Use download attribute if supported, else
   // run a simple PHP script that returns a file. The source code for the PHP script can be viewed at
   // <A rel="nofollow" class="external free" href="https://raw.github.com/highslide-software/highcharts.com/master/studies/csv-export/csv.php">https://raw.github.com/highslide-software/highcharts.com/master/studies/csv-export/csv.php</A>
   if (Highcharts.getOptions().exporting) {
       Highcharts.getOptions().exporting.buttons.contextButton.menuItems.push({
           textKey: 'downloadCSV',
           onclick: function () { this.downloadCSV(); }
       }, {
           textKey: 'downloadXLS',
           onclick: function () { this.downloadXLS(); }
       }, {
           textKey: 'viewData',
           onclick: function () { this.viewData(); }
       });
   }
</PRE><PRE>   // Series specific
   if (seriesTypes.map) {
       seriesTypes.map.prototype.exportKey = 'name';
   }
   if (seriesTypes.mapbubble) {
       seriesTypes.mapbubble.prototype.exportKey = 'name';
   }
</PRE><P>});
&lt;/script&gt;</P><PRE>&lt;script&gt;/*
</PRE><P>	Ractive.js v0.9.0
	Build: e2505c5cb8d78ee9e760ea6f91b74ccfb3e8424b
	Date: Fri May 26 2017 21:43:30 GMT+0000 (UTC)
	Website: <A rel="nofollow" class="external free" href="http://ractivejs.org">http://ractivejs.org</A>
	License: MIT
</P><UL><LI>/</LI></UL><P>(function (global, factory) {
	typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' &amp;&amp; define.amd ? define(factory) :
	(function() {
		var current = global.Ractive;
		var exports = factory();
		global.Ractive = exports;
		exports.noConflict = function() { global.Ractive = current; return exports; };
	})();
}(this, (function () { 'use strict';
</P><P>var defaults = {
	// render placement:
	el:                     void 0,
	append:                 false,
	delegate:               true,
</P><P>	// template:
	template:               null,
</P><P>	// parse:
	delimiters:             [ '<A href="/wiki/index.php?title=Template:%27,_%27&amp;action=edit&amp;redlink=1" class="new" title="Template:', ' (page does not exist)">Template:', '</A>' ],
	tripleDelimiters:       [ '{{{', '}}}' ],
	staticDelimiters:       [ '<A href="/wiki/index.php?title=%27,_%27&amp;action=edit&amp;redlink=1" class="new" title="', ' (page does not exist)">', '</A>' ],
	staticTripleDelimiters: [ '[[[', ']]]' ],
	csp:                    true,
	interpolate:            false,
	preserveWhitespace:     false,
	sanitize:               false,
	stripComments:          true,
	contextLines:           0,
	parserTransforms:       [],
</P><P>	// data &amp; binding:
	data:                   {},
	computed:               {},
	syncComputedChildren:   false,
	resolveInstanceMembers: true,
	warnAboutAmbiguity:     false,
	adapt:                  [],
	isolated:               true,
	twoway:                 true,
	lazy:                   false,
</P><P>	// transitions:
	noIntro:                false,
	noOutro:                false,
	transitionsEnabled:     true,
	complete:               void 0,
	nestedTransitions:      true,
</P><P>	// css:
	css:                    null,
	noCssTransform:         false
};
</P><P>// These are a subset of the easing equations found at
// <A rel="nofollow" class="external free" href="https://raw.github.com/danro/easing-js">https://raw.github.com/danro/easing-js</A> - license info
// follows:
</P><P>// --------------------------------------------------
// easing.js v0.5.4
// Generic set of easing functions with AMD support
// <A rel="nofollow" class="external free" href="https://github.com/danro/easing-js">https://github.com/danro/easing-js</A>
// This code may be freely distributed under the MIT license
// <A rel="nofollow" class="external free" href="http://danro.mit-license.org/">http://danro.mit-license.org/</A>
// --------------------------------------------------
// All functions adapted from Thomas Fuchs &amp; Jeremy Kahn
// Easing Equations (c) 2003 Robert Penner, BSD license
// <A rel="nofollow" class="external free" href="https://raw.github.com/danro/easing-js/master/LICENSE">https://raw.github.com/danro/easing-js/master/LICENSE</A>
// --------------------------------------------------
</P><P>// In that library, the functions named easeIn, easeOut, and
// easeInOut below are named easeInCubic, easeOutCubic, and
// (you guessed it) easeInOutCubic.
//
// You can add additional easing functions to this list, and they
// will be globally available.
</P><P>
var easing = {
	linear: function linear ( pos ) { return pos; },
	easeIn: function easeIn ( pos ) { return Math.pow( pos, 3 ); },
	easeOut: function easeOut ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },
	easeInOut: function easeInOut ( pos ) {
		if ( ( pos /= 0.5 ) &lt; 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }
		return ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );
	}
};
</P><P>var toString = Object.prototype.toString;
</P><P>
function isEqual ( a, b ) {
	if ( a === null &amp;&amp; b === null ) {
		return true;
	}
</P><P>	if ( typeof a === 'object' || typeof b === 'object' ) {
		return false;
	}
</P><P>	return a === b;
}
</P><P>// <A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric">http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric</A>
function isNumeric ( thing ) {
	return !isNaN( parseFloat( thing ) ) &amp;&amp; isFinite( thing );
}
</P><P>function isObject ( thing ) {
	return ( thing &amp;&amp; toString.call( thing ) === '[object Object]' );
}
</P><P>function isObjectLike ( thing ) {
	if ( !thing ) { return false; }
	var type = typeof thing;
	if ( type === 'object' || type === 'function' ) { return true; }
}
</P><P>/* eslint no-console:&quot;off&quot; */
var win = typeof window !== 'undefined' ? window : null;
var doc = win ? document : null;
var isClient = !!doc;
var hasConsole = ( typeof console !== 'undefined' &amp;&amp; typeof console.warn === 'function' &amp;&amp; typeof console.warn.apply === 'function' );
</P><P>var svg = doc ?
	doc.implementation.hasFeature( '<A rel="nofollow" class="external free" href="http://www.w3.org/TR/SVG11/feature#BasicStructure'">http://www.w3.org/TR/SVG11/feature#BasicStructure'</A>, '1.1' ) :
	false;
</P><P>var vendors = [ 'o', 'ms', 'moz', 'webkit' ];
</P><P>var noop = function () {};
</P><P>/* global console */
/* eslint no-console:&quot;off&quot; */
</P><P>var alreadyWarned = {};
var log;
var printWarning;
var welcome;
</P><P>if ( hasConsole ) {
	var welcomeIntro = [
		&quot;%cRactive.js %c0.9.0 %cin debug mode, %cmore...&quot;,
		'color: rgb(114, 157, 52); font-weight: normal;',
		'color: rgb(85, 85, 85); font-weight: normal;',
		'color: rgb(85, 85, 85); font-weight: normal;',
		'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'
	];
	var welcomeMessage = &quot;You're running Ractive 0.9.0 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n  <A rel="nofollow" class="external free" href="http://docs.ractivejs.org\n">http://docs.ractivejs.org\n</A><A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/tagged/ractivejs\n">http://stackoverflow.com/questions/tagged/ractivejs\n</A><A rel="nofollow" class="external free" href="http://groups.google.com/forum/#!forum/ractive-js\n">http://groups.google.com/forum/#!forum/ractive-js\n</A><A rel="nofollow" class="external free" href="http://twitter.com/ractivejs\n\nFound">http://twitter.com/ractivejs\n\nFound</A> a bug? Raise an issue:\n  <A rel="nofollow" class="external free" href="https://github.com/ractivejs/ractive/issues\n\n">https://github.com/ractivejs/ractive/issues\n\n</A>&quot;;
</P><P>	welcome = function () {
		if ( Ractive.WELCOME_MESSAGE === false ) {
			welcome = noop;
			return;
		}
		var message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;
		var hasGroup = !!console.groupCollapsed;
		if ( hasGroup ) { console.groupCollapsed.apply( console, welcomeIntro ); }
		console.log( message );
		if ( hasGroup ) {
			console.groupEnd( welcomeIntro );
		}
</P><P>		welcome = noop;
	};
</P><P>	printWarning = function ( message, args ) {
		welcome();
</P><P>		// extract information about the instance this message pertains to, if applicable
		if ( typeof args[ args.length - 1 ] === 'object' ) {
			var options = args.pop();
			var ractive = options ? options.ractive : null;
</P><P>			if ( ractive ) {
				// if this is an instance of a component that we know the name of, add
				// it to the message
				var name;
				if ( ractive.component &amp;&amp; ( name = ractive.component.name ) ) {
					message = &quot;&lt;&quot; + name + &quot;&gt; &quot; + message;
				}
</P><P>				var node;
				if ( node = ( options.node || ( ractive.fragment &amp;&amp; ractive.fragment.rendered &amp;&amp; ractive.find( '*' ) ) ) ) {
					args.push( node );
				}
			}
		}
</P><P>		console.warn.apply( console, [ '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' ].concat( args ) );
	};
</P><P>	log = function () {
		console.log.apply( console, arguments );
	};
} else {
	printWarning = log = welcome = noop;
}
</P><P>function format ( message, args ) {
	return message.replace( /%s/g, function () { return args.shift(); } );
}
</P><P>function fatal ( message ) {
	var args = [], len = arguments.length - 1;
	while ( len-- &gt; 0 ) args[ len ] = arguments[ len + 1 ];
</P><P>	message = format( message, args );
	throw new Error( message );
}
</P><P>function logIfDebug () {
	if ( Ractive.DEBUG ) {
		log.apply( null, arguments );
	}
}
</P><P>function warn ( message ) {
	var args = [], len = arguments.length - 1;
	while ( len-- &gt; 0 ) args[ len ] = arguments[ len + 1 ];
</P><P>	message = format( message, args );
	printWarning( message, args );
}
</P><P>function warnOnce ( message ) {
	var args = [], len = arguments.length - 1;
	while ( len-- &gt; 0 ) args[ len ] = arguments[ len + 1 ];
</P><P>	message = format( message, args );
</P><P>	if ( alreadyWarned[ message ] ) {
		return;
	}
</P><P>	alreadyWarned[ message ] = true;
	printWarning( message, args );
}
</P><P>function warnIfDebug () {
	if ( Ractive.DEBUG ) {
		warn.apply( null, arguments );
	}
}
</P><P>function warnOnceIfDebug () {
	if ( Ractive.DEBUG ) {
		warnOnce.apply( null, arguments );
	}
}
</P><P>// Error messages that are used (or could be) in multiple places
var badArguments = 'Bad arguments';
var noRegistryFunctionReturn = 'A function was specified for &quot;%s&quot; %s, but no %s was returned';
var missingPlugin = function ( name, type ) { return (&quot;Missing \&quot;&quot; + name + &quot;\&quot; &quot; + type + &quot; plugin. You may need to download a plugin via <A rel="nofollow" class="external free" href="http://docs.ractivejs.org/latest/plugins#">http://docs.ractivejs.org/latest/plugins#</A>&quot; + type + &quot;s&quot;); };
</P><P>function findInViewHierarchy ( registryName, ractive, name ) {
	var instance = findInstance( registryName, ractive, name );
	return instance ? instance[ registryName ][ name ] : null;
}
</P><P>function findInstance ( registryName, ractive, name ) {
	while ( ractive ) {
		if ( name in ractive[ registryName ] ) {
			return ractive;
		}
</P><P>		if ( ractive.isolated ) {
			return null;
		}
</P><P>		ractive = ractive.parent;
	}
}
</P><P>function interpolate ( from, to, ractive, type ) {
	if ( from === to ) { return null; }
</P><P>	if ( type ) {
		var interpol = findInViewHierarchy( 'interpolators', ractive, type );
		if ( interpol ) { return interpol( from, to ) || null; }
</P><P>		fatal( missingPlugin( type, 'interpolator' ) );
	}
</P><P>	return interpolators.number( from, to ) ||
	       interpolators.array( from, to ) ||
	       interpolators.object( from, to ) ||
	       null;
}
</P><P>function snap ( to ) {
	return function () { return to; };
}
</P><P>var interpolators = {
	number: function number ( from, to ) {
		if ( !isNumeric( from ) || !isNumeric( to ) ) {
			return null;
		}
</P><P>		from = +from;
		to = +to;
</P><P>		var delta = to - from;
</P><P>		if ( !delta ) {
			return function () { return from; };
		}
</P><P>		return function ( t ) {
			return from + ( t * delta );
		};
	},
</P><P>	array: function array ( from, to ) {
		var len, i;
</P><P>		if ( !Array.isArray( from ) || !Array.isArray( to ) ) {
			return null;
		}
</P><P>		var intermediate = [];
		var interpolators = [];
</P><P>		i = len = Math.min( from.length, to.length );
		while ( i-- ) {
			interpolators[i] = interpolate( from[i], to[i] );
		}
</P><P>		// surplus values - don't interpolate, but don't exclude them either
		for ( i=len; i&lt;from.length; i+=1 ) {
			intermediate[i] = from[i];
		}
</P><P>		for ( i=len; i&lt;to.length; i+=1 ) {
			intermediate[i] = to[i];
		}
</P><P>		return function ( t ) {
			var i = len;
</P><P>			while ( i-- ) {
				intermediate[i] = interpolators[i]( t );
			}
</P><P>			return intermediate;
		};
	},
</P><P>	object: function object ( from, to ) {
		if ( !isObject( from ) || !isObject( to ) ) {
			return null;
		}
</P><P>		var properties = [];
		var intermediate = {};
		var interpolators = {};
</P><P>		for ( var prop in from ) {
			if ( from.hasOwnProperty( prop ) ) {
				if ( to.hasOwnProperty( prop ) ) {
					properties.push( prop );
					interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] ) || snap( to[ prop ] );
				}
</P><P>				else {
					intermediate[ prop ] = from[ prop ];
				}
			}
		}
</P><P>		for ( var prop$1 in to ) {
			if ( to.hasOwnProperty( prop$1 ) &amp;&amp; !from.hasOwnProperty( prop$1 ) ) {
				intermediate[ prop$1 ] = to[ prop$1 ];
			}
		}
</P><P>		var len = properties.length;
</P><P>		return function ( t ) {
			var i = len;
</P><P>			while ( i-- ) {
				var prop = properties[i];
</P><P>				intermediate[ prop ] = interpolators[ prop ]( t );
			}
</P><P>			return intermediate;
		};
	}
};
</P><P>function addToArray ( array, value ) {
	var index = array.indexOf( value );
</P><P>	if ( index === -1 ) {
		array.push( value );
	}
}
</P><P>function arrayContains ( array, value ) {
	for ( var i = 0, c = array.length; i &lt; c; i++ ) {
		if ( array[i] == value ) {
			return true;
		}
	}
</P><P>	return false;
}
</P><P>function arrayContentsMatch ( a, b ) {
	var i;
</P><P>	if ( !Array.isArray( a ) || !Array.isArray( b ) ) {
		return false;
	}
</P><P>	if ( a.length !== b.length ) {
		return false;
	}
</P><P>	i = a.length;
	while ( i-- ) {
		if ( a[i] !== b[i] ) {
			return false;
		}
	}
</P><P>	return true;
}
</P><P>function ensureArray ( x ) {
	if ( typeof x === 'string' ) {
		return [ x ];
	}
</P><P>	if ( x === undefined ) {
		return [];
	}
</P><P>	return x;
}
</P><P>function lastItem ( array ) {
	return array[ array.length - 1 ];
}
</P><P>function removeFromArray ( array, member ) {
	if ( !array ) {
		return;
	}
</P><P>	var index = array.indexOf( member );
</P><P>	if ( index !== -1 ) {
		array.splice( index, 1 );
	}
}
</P><P>function combine () {
	var arrays = [], len = arguments.length;
	while ( len-- ) arrays[ len ] = arguments[ len ];
</P><P>	var res = arrays.concat.apply( [], arrays );
	var i = res.length;
	while ( i-- ) {
		var idx = res.indexOf( res[i] );
		if ( ~idx &amp;&amp; idx &lt; i ) { res.splice( i, 1 ); }
	}
</P><P>	return res;
}
</P><P>function toArray ( arrayLike ) {
	var array = [];
	var i = arrayLike.length;
	while ( i-- ) {
		array[i] = arrayLike[i];
	}
</P><P>	return array;
}
</P><P>function findMap ( array, fn ) {
	var len = array.length;
	for ( var i = 0; i &lt; len; i++ ) {
		var result = fn( array[i] );
		if ( result ) { return result; }
	}
}
</P><P>var TransitionManager = function TransitionManager ( callback, parent ) {
	this.callback = callback;
	this.parent = parent;
</P><P>	this.intros = [];
	this.outros = [];
</P><P>	this.children = [];
	this.totalChildren = this.outroChildren = 0;
</P><P>	this.detachQueue = [];
	this.outrosComplete = false;
</P><P>	if ( parent ) {
		parent.addChild( this );
	}
};
</P><P>TransitionManager.prototype.add = function add ( transition ) {
	var list = transition.isIntro ? this.intros : this.outros;
	transition.starting = true;
	list.push( transition );
};
</P><P>TransitionManager.prototype.addChild = function addChild ( child ) {
	this.children.push( child );
</P><P>	this.totalChildren += 1;
	this.outroChildren += 1;
};
</P><P>TransitionManager.prototype.decrementOutros = function decrementOutros () {
	this.outroChildren -= 1;
	check( this );
};
</P><P>TransitionManager.prototype.decrementTotal = function decrementTotal () {
	this.totalChildren -= 1;
	check( this );
};
</P><P>TransitionManager.prototype.detachNodes = function detachNodes () {
	this.detachQueue.forEach( detach );
	this.children.forEach( _detachNodes );
	this.detachQueue = [];
};
</P><P>TransitionManager.prototype.ready = function ready () {
	if ( this.detachQueue.length ) { detachImmediate( this ); }
};
</P><P>TransitionManager.prototype.remove = function remove ( transition ) {
	var list = transition.isIntro ? this.intros : this.outros;
	removeFromArray( list, transition );
	check( this );
};
</P><P>TransitionManager.prototype.start = function start () {
	this.children.forEach( function (c) { return c.start(); } );
	this.intros.concat( this.outros ).forEach( function (t) { return t.start(); } );
	this.ready = true;
	check( this );
};
</P><P>function detach ( element ) {
	element.detach();
}
</P><P>function _detachNodes ( tm ) { // _ to avoid transpiler quirk
	tm.detachNodes();
}
</P><P>function check ( tm ) {
	if ( !tm.ready || tm.outros.length || tm.outroChildren ) { return; }
</P><P>	// If all outros are complete, and we haven't already done this,
	// we notify the parent if there is one, otherwise
	// start detaching nodes
	if ( !tm.outrosComplete ) {
		tm.outrosComplete = true;
</P><P>		if ( tm.parent &amp;&amp; !tm.parent.outrosComplete ) {
			tm.parent.decrementOutros( tm );
		} else {
			tm.detachNodes();
		}
	}
</P><P>	// Once everything is done, we can notify parent transition
	// manager and call the callback
	if ( !tm.intros.length &amp;&amp; !tm.totalChildren ) {
		if ( typeof tm.callback === 'function' ) {
			tm.callback();
		}
</P><P>		if ( tm.parent &amp;&amp; !tm.notifiedTotal ) {
			tm.notifiedTotal = true;
			tm.parent.decrementTotal();
		}
	}
}
</P><P>// check through the detach queue to see if a node is up or downstream from a
// transition and if not, go ahead and detach it
function detachImmediate ( manager ) {
	var queue = manager.detachQueue;
	var outros = collectAllOutros( manager );
</P><P>	var i = queue.length;
	var j = 0;
	var node, trans;
	start: while ( i-- ) {
		node = queue[i].node;
		j = outros.length;
		while ( j-- ) {
			trans = outros[j].element.node;
			// check to see if the node is, contains, or is contained by the transitioning node
			if ( trans === node || trans.contains( node ) || node.contains( trans ) ) { continue start; }
		}
</P><P>		// no match, we can drop it
		queue[i].detach();
		queue.splice( i, 1 );
	}
}
</P><P>function collectAllOutros ( manager, _list ) {
	var list = _list;
</P><P>	// if there's no list, we're starting at the root to build one
	if ( !list ) {
		list = [];
		var parent = manager;
		while ( parent.parent ) { parent = parent.parent; }
		return collectAllOutros( parent, list );
	} else {
		// grab all outros from child managers
		var i = manager.children.length;
		while ( i-- ) {
			list = collectAllOutros( manager.children[i], list );
		}
</P><P>		// grab any from this manager if there are any
		if ( manager.outros.length ) { list = list.concat( manager.outros ); }
</P><P>		return list;
	}
}
</P><P>var batch;
</P><P>var runloop = {
	start: function start ( instance ) {
		var fulfilPromise;
		var promise = new Promise( function (f) { return ( fulfilPromise = f ); } );
</P><P>		batch = {
			previousBatch: batch,
			transitionManager: new TransitionManager( fulfilPromise, batch &amp;&amp; batch.transitionManager ),
			fragments: [],
			tasks: [],
			immediateObservers: [],
			deferredObservers: [],
			instance: instance,
			promise: promise
		};
</P><P>		return promise;
	},
</P><P>	end: function end () {
		flushChanges();
</P><P>		if ( !batch.previousBatch ) { batch.transitionManager.start(); }
</P><P>		batch = batch.previousBatch;
	},
</P><P>	addFragment: function addFragment ( fragment ) {
		addToArray( batch.fragments, fragment );
	},
</P><P>	// TODO: come up with a better way to handle fragments that trigger their own update
	addFragmentToRoot: function addFragmentToRoot ( fragment ) {
		if ( !batch ) { return; }
</P><P>		var b = batch;
		while ( b.previousBatch ) {
			b = b.previousBatch;
		}
</P><P>		addToArray( b.fragments, fragment );
	},
</P><P>	addObserver: function addObserver ( observer, defer ) {
		if ( !batch ) {
			observer.dispatch();
		} else {
			addToArray( defer ? batch.deferredObservers : batch.immediateObservers, observer );
		}
	},
</P><P>	registerTransition: function registerTransition ( transition ) {
		transition._manager = batch.transitionManager;
		batch.transitionManager.add( transition );
	},
</P><P>	// synchronise node detachments with transition ends
	detachWhenReady: function detachWhenReady ( thing ) {
		batch.transitionManager.detachQueue.push( thing );
	},
</P><P>	scheduleTask: function scheduleTask ( task, postRender ) {
		var _batch;
</P><P>		if ( !batch ) {
			task();
		} else {
			_batch = batch;
			while ( postRender &amp;&amp; _batch.previousBatch ) {
				// this can't happen until the DOM has been fully updated
				// otherwise in some situations (with components inside elements)
				// transitions and decorators will initialise prematurely
				_batch = _batch.previousBatch;
			}
</P><P>			_batch.tasks.push( task );
		}
	},
</P><P>	promise: function promise () {
		if ( !batch ) { return Promise.resolve(); }
</P><P>		var target = batch;
		while ( target.previousBatch ) {
			target = target.previousBatch;
		}
</P><P>		return target.promise || Promise.resolve();
	}
};
</P><P>function dispatch ( observer ) {
	observer.dispatch();
}
</P><P>function flushChanges () {
	var which = batch.immediateObservers;
	batch.immediateObservers = [];
	which.forEach( dispatch );
</P><P>	// Now that changes have been fully propagated, we can update the DOM
	// and complete other tasks
	var i = batch.fragments.length;
	var fragment;
</P><P>	which = batch.fragments;
	batch.fragments = [];
</P><P>	while ( i-- ) {
		fragment = which[i];
		fragment.update();
	}
</P><P>	batch.transitionManager.ready();
</P><P>	which = batch.deferredObservers;
	batch.deferredObservers = [];
	which.forEach( dispatch );
</P><P>	var tasks = batch.tasks;
	batch.tasks = [];
</P><P>	for ( i = 0; i &lt; tasks.length; i += 1 ) {
		tasks[i]();
	}
</P><P>	// If updating the view caused some model blowback - e.g. a triple
	// containing &lt;option&gt; elements caused the binding on the &lt;select&gt;
	// to update - then we start over
	if ( batch.fragments.length || batch.immediateObservers.length || batch.deferredObservers.length || batch.tasks.length ) { return flushChanges(); }
}
</P><P>var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
var splitPattern = /([^\\](?:\\\\)*)\./;
var escapeKeyPattern = /\\|\./g;
var unescapeKeyPattern = /((?:\\)+)\1|\\(\.)/g;
</P><P>function escapeKey ( key ) {
	if ( typeof key === 'string' ) {
		return key.replace( escapeKeyPattern, '\\$&amp;' );
	}
</P><P>	return key;
}
</P><P>function normalise ( ref ) {
	return ref ? ref.replace( refPattern, '.$1' ) : <I>;</I>
}
</P><P>function splitKeypath ( keypath ) {
	var result = [];
	var match;
</P><P>	keypath = normalise( keypath );
</P><P>	while ( match = splitPattern.exec( keypath ) ) {
		var index = match.index + match[1].length;
		result.push( keypath.substr( 0, index ) );
		keypath = keypath.substr( index + 1 );
	}
</P><P>	result.push( keypath );
</P><P>	return result;
}
</P><P>function unescapeKey ( key ) {
	if ( typeof key === 'string' ) {
		return key.replace( unescapeKeyPattern, '$1$2' );
	}
</P><P>	return key;
}
</P><P>var stack = [];
var captureGroup;
</P><P>function startCapturing () {
	stack.push( captureGroup = [] );
}
</P><P>function stopCapturing () {
	var dependencies = stack.pop();
	captureGroup = stack[ stack.length - 1 ];
	return dependencies;
}
</P><P>function capture ( model ) {
	if ( captureGroup ) {
		captureGroup.push( model );
	}
}
</P><P>var KeyModel = function KeyModel ( key, parent ) {
	this.value = key;
	this.isReadonly = this.isKey = true;
	this.deps = [];
	this.links = [];
	this.parent = parent;
};
</P><P>KeyModel.prototype.get = function get ( shouldCapture ) {
	if ( shouldCapture ) { capture( this ); }
	return unescapeKey( this.value );
};
</P><P>KeyModel.prototype.getKeypath = function getKeypath () {
	return unescapeKey( this.value );
};
</P><P>KeyModel.prototype.rebind = function rebind ( next, previous ) {
		var this$1 = this;
</P><P>	var i = this.deps.length;
	while ( i-- ) { this$1.deps[i].rebind( next, previous, false ); }
</P><P>	i = this.links.length;
	while ( i-- ) { this$1.links[i].rebind( next, previous, false ); }
};
</P><P>KeyModel.prototype.register = function register ( dependant ) {
	this.deps.push( dependant );
};
</P><P>KeyModel.prototype.registerLink = function registerLink ( link ) {
	addToArray( this.links, link );
};
</P><P>KeyModel.prototype.unregister = function unregister ( dependant ) {
	removeFromArray( this.deps, dependant );
};
</P><P>KeyModel.prototype.unregisterLink = function unregisterLink ( link ) {
	removeFromArray( this.links, link );
};
</P><P>KeyModel.prototype.reference = noop;
KeyModel.prototype.unreference = noop;
</P><P>function bind               ( x ) { x.bind(); }
function cancel             ( x ) { x.cancel(); }
function destroyed          ( x ) { x.destroyed(); }
function handleChange       ( x ) { x.handleChange(); }
function mark               ( x ) { x.mark(); }
function marked             ( x ) { x.marked(); }
function markedAll          ( x ) { x.markedAll(); }
function render             ( x ) { x.render(); }
function shuffled           ( x ) { x.shuffled(); }
function teardown           ( x ) { x.teardown(); }
function unbind             ( x ) { x.unbind(); }
function unrender           ( x ) { x.unrender(); }
function unrenderAndDestroy ( x ) { x.unrender( true ); }
function update             ( x ) { x.update(); }
function toString$1           ( x ) { return x.toString(); }
function toEscapedString    ( x ) { return x.toString( true ); }
</P><P>var KeypathModel = function KeypathModel ( parent, ractive ) {
	this.parent = parent;
	this.ractive = ractive;
	this.value = ractive ? parent.getKeypath( ractive ) : parent.getKeypath();
	this.deps = [];
	this.children = {};
	this.isReadonly = this.isKeypath = true;
};
</P><P>KeypathModel.prototype.get = function get ( shouldCapture ) {
	if ( shouldCapture ) { capture( this ); }
	return this.value;
};
</P><P>KeypathModel.prototype.getChild = function getChild ( ractive ) {
	if ( !( ractive._guid in this.children ) ) {
		var model = new KeypathModel( this.parent, ractive );
		this.children[ ractive._guid ] = model;
		model.owner = this;
	}
	return this.children[ ractive._guid ];
};
</P><P>KeypathModel.prototype.getKeypath = function getKeypath () {
	return this.value;
};
</P><P>KeypathModel.prototype.handleChange = function handleChange$1 () {
		var this$1 = this;
</P><P>	var keys = Object.keys( this.children );
	var i = keys.length;
	while ( i-- ) {
		this$1.children[ keys[i] ].handleChange();
	}
</P><P>	this.deps.forEach( handleChange );
};
</P><P>KeypathModel.prototype.rebindChildren = function rebindChildren ( next ) {
		var this$1 = this;
</P><P>	var keys = Object.keys( this.children );
	var i = keys.length;
	while ( i-- ) {
		var child = this$1.children[keys[i]];
		child.value = next.getKeypath( child.ractive );
		child.handleChange();
	}
};
</P><P>KeypathModel.prototype.rebind = function rebind ( next, previous ) {
		var this$1 = this;
</P><P>	var model = next ? next.getKeypathModel( this.ractive ) : undefined;
</P><P>	var keys = Object.keys( this.children );
	var i = keys.length;
	while ( i-- ) {
		this$1.children[ keys[i] ].rebind( next, previous, false );
	}
</P><P>	i = this.deps.length;
	while ( i-- ) {
		this$1.deps[i].rebind( model, this$1, false );
	}
};
</P><P>KeypathModel.prototype.register = function register ( dep ) {
	this.deps.push( dep );
};
</P><P>KeypathModel.prototype.removeChild = function removeChild ( model ) {
	if ( model.ractive ) { delete this.children[ model.ractive._guid ]; }
};
</P><P>KeypathModel.prototype.teardown = function teardown$$1 () {
		var this$1 = this;
</P><P>	if ( this.owner ) { this.owner.removeChild( this ); }
</P><P>	var keys = Object.keys( this.children );
	var i = keys.length;
	while ( i-- ) {
		this$1.children[ keys[i] ].teardown();
	}
};
</P><P>KeypathModel.prototype.unregister = function unregister ( dep ) {
	removeFromArray( this.deps, dep );
	if ( !this.deps.length ) { this.teardown(); }
};
</P><P>KeypathModel.prototype.reference = noop;
KeypathModel.prototype.unreference = noop;
</P><P>var fnBind = Function.prototype.bind;
</P><P>function bind$1 ( fn, context ) {
	if ( !/this/.test( fn.toString() ) ) { return fn; }
</P><P>	var bound = fnBind.call( fn, context );
	for ( var prop in fn ) { bound[ prop ] = fn[ prop ]; }
</P><P>	return bound;
}
</P><P>var hasProp = Object.prototype.hasOwnProperty;
</P><P>var shuffleTasks = { early: [], mark: [] };
var registerQueue = { early: [], mark: [] };
</P><P>var ModelBase = function ModelBase ( parent ) {
	this.deps = [];
</P><P>	this.children = [];
	this.childByKey = {};
	this.links = [];
</P><P>	this.keyModels = {};
</P><P>	this.bindings = [];
	this.patternObservers = [];
</P><P>	if ( parent ) {
		this.parent = parent;
		this.root = parent.root;
	}
};
</P><P>ModelBase.prototype.addShuffleTask = function addShuffleTask ( task, stage ) {
	if ( stage === void 0 ) stage = 'early';
</P><PRE>shuffleTasks[stage].push( task ); };
</PRE><P>ModelBase.prototype.addShuffleRegister = function addShuffleRegister ( item, stage ) {
	if ( stage === void 0 ) stage = 'early';
</P><PRE>registerQueue[stage].push({ model: this, item: item }); };
</PRE><P>ModelBase.prototype.findMatches = function findMatches ( keys ) {
	var len = keys.length;
</P><P>	var existingMatches = [ this ];
	var matches;
	var i;
</P><P>	var loop = function (  ) {
		var key = keys[i];
</P><P>		if ( key === '*' ) {
			matches = [];
			existingMatches.forEach( function (model) {
				matches.push.apply( matches, model.getValueChildren( model.get() ) );
			});
		} else {
			matches = existingMatches.map( function (model) { return model.joinKey( key ); } );
		}
</P><P>		existingMatches = matches;
	};
</P><P>		for ( i = 0; i &lt; len; i += 1 ) loop(  );
</P><P>	return matches;
};
</P><P>ModelBase.prototype.getKeyModel = function getKeyModel ( key, skip ) {
	if ( key !== undefined &amp;&amp; !skip ) { return this.parent.getKeyModel( key, true ); }
</P><P>	if ( !( key in this.keyModels ) ) { this.keyModels[ key ] = new KeyModel( escapeKey( key ), this ); }
</P><P>	return this.keyModels[ key ];
};
</P><P>ModelBase.prototype.getKeypath = function getKeypath ( ractive ) {
	if ( ractive !== this.ractive &amp;&amp; this._link ) { return this._link.target.getKeypath( ractive ); }
</P><P>	if ( !this.keypath ) {
		var parent = this.parent &amp;&amp; this.parent.getKeypath( ractive );
		this.keypath = parent ? ((this.parent.getKeypath( ractive )) + &quot;.&quot; + (escapeKey( this.key ))) : escapeKey( this.key );
	}
</P><P>	return this.keypath;
};
</P><P>ModelBase.prototype.getValueChildren = function getValueChildren ( value ) {
		var this$1 = this;
</P><P>	var children;
	if ( Array.isArray( value ) ) {
		children = [];
		if ( 'length' in this &amp;&amp; this.length !== value.length ) {
			children.push( this.joinKey( 'length' ) );
		}
		value.forEach( function ( m, i ) {
			children.push( this$1.joinKey( i ) );
		});
	}
</P><P>	else if ( isObject( value ) || typeof value === 'function' ) {
		children = Object.keys( value ).map( function (key) { return this$1.joinKey( key ); } );
	}
</P><P>	else if ( value != null ) {
		return [];
	}
</P><P>	return children;
};
</P><P>ModelBase.prototype.getVirtual = function getVirtual ( shouldCapture ) {
		var this$1 = this;
</P><P>	var value = this.get( shouldCapture, { virtual: false } );
	if ( isObject( value ) ) {
		var result = Array.isArray( value ) ? [] : {};
</P><P>		var keys = Object.keys( value );
		var i = keys.length;
		while ( i-- ) {
			var child = this$1.childByKey[ keys[i] ];
			if ( !child ) { result[ keys[i] ] = value[ keys[i] ]; }
			else if ( child._link ) { result[ keys[i] ] = child._link.getVirtual(); }
			else { result[ keys[i] ] = child.getVirtual(); }
		}
</P><P>		i = this.children.length;
		while ( i-- ) {
			var child$1 = this$1.children[i];
			if ( !( child$1.key in result ) &amp;&amp; child$1._link ) {
				result[ child$1.key ] = child$1._link.getVirtual();
			}
		}
</P><P>		return result;
	} else { return value; }
};
</P><P>ModelBase.prototype.has = function has ( key ) {
	if ( this._link ) { return this._link.has( key ); }
</P><P>	var value = this.get();
	if ( !value ) { return false; }
</P><P>	key = unescapeKey( key );
	if ( hasProp.call( value, key ) ) { return true; }
</P><P>	// We climb up the constructor chain to find if one of them contains the key
	var constructor = value.constructor;
	while ( constructor !== Function &amp;&amp; constructor !== Array &amp;&amp; constructor !== Object ) {
		if ( hasProp.call( constructor.prototype, key ) ) { return true; }
		constructor = constructor.constructor;
	}
</P><P>	return false;
};
</P><P>ModelBase.prototype.joinAll = function joinAll ( keys, opts ) {
	var model = this;
	for ( var i = 0; i &lt; keys.length; i += 1 ) {
		if ( opts &amp;&amp; opts.lastLink === false &amp;&amp; i + 1 === keys.length &amp;&amp; model.childByKey[keys[i]] &amp;&amp; model.childByKey[keys[i]]._link ) { return model.childByKey[keys[i]]; }
		model = model.joinKey( keys[i], opts );
	}
</P><P>	return model;
};
</P><P>ModelBase.prototype.notifyUpstream = function notifyUpstream ( startPath ) {
		var this$1 = this;
</P><P>	var parent = this.parent;
	var path = startPath || [ this.key ];
	while ( parent ) {
		if ( parent.patternObservers.length ) { parent.patternObservers.forEach( function (o) { return o.notify( path.slice() ); } ); }
		path.unshift( parent.key );
		parent.links.forEach( function (l) { return l.notifiedUpstream( path, this$1.root ); } );
		parent.deps.forEach( handleChange );
		parent = parent.parent;
	}
};
</P><P>ModelBase.prototype.rebind = function rebind ( next, previous, safe ) {
		var this$1 = this;
</P><P>	// tell the deps to move to the new target
	var i = this.deps.length;
	while ( i-- ) {
		if ( this$1.deps[i].rebind ) { this$1.deps[i].rebind( next, previous, safe ); }
	}
</P><P>	i = this.links.length;
	while ( i-- ) {
		var link = this$1.links[i];
		// only relink the root of the link tree
		if ( link.owner._link ) { link.relinking( next, safe ); }
	}
</P><P>	i = this.children.length;
	while ( i-- ) {
		var child = this$1.children[i];
		child.rebind( next ? next.joinKey( child.key ) : undefined, child, safe );
	}
</P><P>	if ( this.keypathModel ) { this.keypathModel.rebind( next, previous, false ); }
</P><P>	i = this.bindings.length;
	while ( i-- ) {
		this$1.bindings[i].rebind( next, previous, safe );
	}
};
</P><P>ModelBase.prototype.reference = function reference () {
	'refs' in this ? this.refs++ : this.refs = 1;
};
</P><P>ModelBase.prototype.register = function register ( dep ) {
	this.deps.push( dep );
};
</P><P>ModelBase.prototype.registerLink = function registerLink ( link ) {
	addToArray( this.links, link );
};
</P><P>ModelBase.prototype.registerPatternObserver = function registerPatternObserver ( observer ) {
	this.patternObservers.push( observer );
	this.register( observer );
};
</P><P>ModelBase.prototype.registerTwowayBinding = function registerTwowayBinding ( binding ) {
	this.bindings.push( binding );
};
</P><P>ModelBase.prototype.unreference = function unreference () {
	if ( 'refs' in this ) { this.refs--; }
};
</P><P>ModelBase.prototype.unregister = function unregister ( dep ) {
	removeFromArray( this.deps, dep );
};
</P><P>ModelBase.prototype.unregisterLink = function unregisterLink ( link ) {
	removeFromArray( this.links, link );
};
</P><P>ModelBase.prototype.unregisterPatternObserver = function unregisterPatternObserver ( observer ) {
	removeFromArray( this.patternObservers, observer );
	this.unregister( observer );
};
</P><P>ModelBase.prototype.unregisterTwowayBinding = function unregisterTwowayBinding ( binding ) {
	removeFromArray( this.bindings, binding );
};
</P><P>ModelBase.prototype.updateFromBindings = function updateFromBindings$1 ( cascade ) {
		var this$1 = this;
</P><P>	var i = this.bindings.length;
	while ( i-- ) {
		var value = this$1.bindings[i].getValue();
		if ( value !== this$1.value ) { this$1.set( value ); }
	}
</P><P>	// check for one-way bindings if there are no two-ways
	if ( !this.bindings.length ) {
		var oneway = findBoundValue( this.deps );
		if ( oneway &amp;&amp; oneway.value !== this.value ) { this.set( oneway.value ); }
	}
</P><P>	if ( cascade ) {
		this.children.forEach( updateFromBindings );
		this.links.forEach( updateFromBindings );
		if ( this._link ) { this._link.updateFromBindings( cascade ); }
	}
};
</P><P>// TODO: this may be better handled by overreiding `get` on models with a parent that isRoot
function maybeBind ( model, value, shouldBind ) {
	if ( shouldBind &amp;&amp; typeof value === 'function' &amp;&amp; model.parent &amp;&amp; model.parent.isRoot ) {
		if ( !model.boundValue ) {
			model.boundValue = bind$1( value._r_unbound || value, model.parent.ractive );
		}
</P><P>		return model.boundValue;
	}
</P><P>	return value;
}
</P><P>function updateFromBindings ( model ) {
	model.updateFromBindings( true );
}
</P><P>function findBoundValue( list ) {
	var i = list.length;
	while ( i-- ) {
		if ( list[i].bound ) {
			var owner = list[i].owner;
			if ( owner ) {
				var value = owner.name === 'checked' ?
					owner.node.checked :
					owner.node.value;
				return { value: value };
			}
		}
	}
}
</P><P>function fireShuffleTasks ( stage ) {
	if ( !stage ) {
		fireShuffleTasks( 'early' );
		fireShuffleTasks( 'mark' );
	} else {
		var tasks = shuffleTasks[stage];
		shuffleTasks[stage] = [];
		var i = tasks.length;
		while ( i-- ) { tasks[i](); }
</P><P>		var register = registerQueue[stage];
		registerQueue[stage] = [];
		i = register.length;
		while ( i-- ) { register[i].model.register( register[i].item ); }
	}
}
</P><P>function shuffle ( model, newIndices, link ) {
	model.shuffling = true;
</P><P>	var i = newIndices.length;
	while ( i-- ) {
		var idx = newIndices[ i ];
		// nothing is actually changing, so move in the index and roll on
		if ( i === idx ) {
			continue;
		}
</P><P>		// rebind the children on i to idx
		if ( i in model.childByKey ) { model.childByKey[ i ].rebind( !~idx ? undefined : model.joinKey( idx ), model.childByKey[ i ], true ); }
</P><P>		if ( !~idx &amp;&amp; model.keyModels[ i ] ) {
			model.keyModels[i].rebind( undefined, model.keyModels[i], false );
		} else if ( ~idx &amp;&amp; model.keyModels[ i ] ) {
			if ( !model.keyModels[ idx ] ) { model.childByKey[ idx ].getKeyModel( idx ); }
			model.keyModels[i].rebind( model.keyModels[ idx ], model.keyModels[i], false );
		}
	}
</P><P>	var upstream = model.source().length !== model.source().value.length;
</P><P>	model.links.forEach( function (l) { return l.shuffle( newIndices ); } );
	if ( !link ) { fireShuffleTasks( 'early' ); }
</P><P>	i = model.deps.length;
	while ( i-- ) {
		if ( model.deps[i].shuffle ) { model.deps[i].shuffle( newIndices ); }
	}
</P><P>	model[ link ? 'marked' : 'mark' ]();
	if ( !link ) { fireShuffleTasks( 'mark' ); }
</P><P>	if ( upstream ) { model.notifyUpstream(); }
</P><P>	model.shuffling = false;
}
</P><P>KeyModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;
KeyModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;
KeypathModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;
KeypathModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;
</P><P>// this is the dry method of checking to see if a rebind applies to
// a particular keypath because in some cases, a dep may be bound
// directly to a particular keypath e.g. foo.bars.0.baz and need
// to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted
function rebindMatch ( template, next, previous, fragment ) {
	var keypath = template.r || template;
</P><P>	// no valid keypath, go with next
	if ( !keypath || typeof keypath !== 'string' ) { return next; }
</P><P>	// completely contextual ref, go with next
	if ( keypath === '.' || keypath[0] === '@' || ( next || previous ).isKey || ( next || previous ).isKeypath ) { return next; }
</P><P>	var parts = keypath.split( '/' );
	var keys = splitKeypath( parts[ parts.length - 1 ] );
	var last = keys[ keys.length - 1 ];
</P><P>	// check the keypath against the model keypath to see if it matches
	var model = next || previous;
</P><P>	// check to see if this was an alias
	if ( model &amp;&amp; keys.length === 1 &amp;&amp; last !== model.key &amp;&amp; fragment ) {
		keys = findAlias( last, fragment ) || keys;
	}
</P><P>	var i = keys.length;
	var match = true;
	var shuffling = false;
</P><P>	while ( model &amp;&amp; i-- ) {
		if ( model.shuffling ) { shuffling = true; }
		// non-strict comparison to account for indices in keypaths
		if ( keys[i] != model.key ) { match = false; }
		model = model.parent;
	}
</P><P>	// next is undefined, but keypath is shuffling and previous matches
	if ( !next &amp;&amp; match &amp;&amp; shuffling ) { return previous; }
	// next is defined, but doesn't match the keypath
	else if ( next &amp;&amp; !match &amp;&amp; shuffling ) { return previous; }
	else { return next; }
}
</P><P>function findAlias ( name, fragment ) {
	while ( fragment ) {
		var z = fragment.aliases;
		if ( z &amp;&amp; z[ name ] ) {
			var aliases = ( fragment.owner.iterations ? fragment.owner : fragment ).owner.template.z;
			for ( var i = 0; i &lt; aliases.length; i++ ) {
				if ( aliases[i].n === name ) {
					var alias = aliases[i].x;
					if ( !alias.r ) { return false; }
					var parts = alias.r.split( '/' );
					return splitKeypath( parts[ parts.length - 1 ] );
				}
			}
			return;
		}
</P><P>		fragment = fragment.componentParent || fragment.parent;
	}
}
</P><P>// temporary placeholder target for detached implicit links
var Missing = {
	key: '@missing',
	animate: noop,
	applyValue: noop,
	get: noop,
	getKeypath: function getKeypath () { return this.key; },
	joinAll: function joinAll () { return this; },
	joinKey: function joinKey () { return this; },
	mark: noop,
	registerLink: noop,
	shufle: noop,
	set: noop,
	unregisterLink: noop
};
Missing.parent = Missing;
</P><P>var LinkModel = (function (ModelBase$$1) {
	function LinkModel ( parent, owner, target, key ) {
		ModelBase$$1.call( this, parent );
</P><P>		this.owner = owner;
		this.target = target;
		this.key = key === undefined ? owner.key : key;
		if ( owner.isLink ) { this.sourcePath = (owner.sourcePath) + &quot;.&quot; + (this.key); }
</P><P>		target.registerLink( this );
</P><P>		if ( parent ) { this.isReadonly = parent.isReadonly; }
</P><P>		this.isLink = true;
	}
</P><P>	if ( ModelBase$$1 ) LinkModel.__proto__ = ModelBase$$1;
	LinkModel.prototype = Object.create( ModelBase$$1 &amp;&amp; ModelBase$$1.prototype );
	LinkModel.prototype.constructor = LinkModel;
</P><P>	LinkModel.prototype.animate = function animate ( from, to, options, interpolator ) {
		return this.target.animate( from, to, options, interpolator );
	};
</P><P>	LinkModel.prototype.applyValue = function applyValue ( value ) {
		if ( this.boundValue ) { this.boundValue = null; }
		this.target.applyValue( value );
	};
</P><P>	LinkModel.prototype.attach = function attach ( fragment ) {
		var model = resolveReference( fragment, this.key );
		if ( model ) {
			this.relinking( model, false );
		} else { // if there is no link available, move everything here to real models
			this.owner.unlink();
		}
	};
</P><P>	LinkModel.prototype.detach = function detach () {
		this.relinking( Missing, false );
	};
</P><P>	LinkModel.prototype.get = function get ( shouldCapture, opts ) {
		if ( opts === void 0 ) opts = {};
</P><P>		if ( shouldCapture ) {
			capture( this );
</P><P>			// may need to tell the target to unwrap
			opts.unwrap = true;
		}
</P><P>		var bind$$1 = 'shouldBind' in opts ? opts.shouldBind : true;
		opts.shouldBind = false;
</P><P>		return maybeBind( this, this.target.get( false, opts ), bind$$1 );
	};
</P><P>	LinkModel.prototype.getKeypath = function getKeypath ( ractive ) {
		if ( ractive &amp;&amp; ractive !== this.root.ractive ) { return this.target.getKeypath( ractive ); }
</P><P>		return ModelBase$$1.prototype.getKeypath.call( this, ractive );
	};
</P><P>	LinkModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {
		if ( !this.keypathModel ) { this.keypathModel = new KeypathModel( this ); }
		if ( ractive &amp;&amp; ractive !== this.root.ractive ) { return this.keypathModel.getChild( ractive ); }
		return this.keypathModel;
	};
</P><P>	LinkModel.prototype.handleChange = function handleChange$1 () {
		this.deps.forEach( handleChange );
		this.links.forEach( handleChange );
		this.notifyUpstream();
	};
</P><P>	LinkModel.prototype.isDetached = function isDetached () { return this.virtual &amp;&amp; this.target === Missing; };
</P><P>	LinkModel.prototype.joinKey = function joinKey ( key ) {
		// TODO: handle nested links
		if ( key === undefined || key === <I> ) { return this; }</I></P><P>		if ( !this.childByKey.hasOwnProperty( key ) ) {
			var child = new LinkModel( this, this, this.target.joinKey( key ), key );
			this.children.push( child );
			this.childByKey[ key ] = child;
		}
</P><P>		return this.childByKey[ key ];
	};
</P><P>	LinkModel.prototype.mark = function mark$$1 ( force ) {
		this.target.mark( force );
	};
</P><P>	LinkModel.prototype.marked = function marked$1 () {
		if ( this.boundValue ) { this.boundValue = null; }
</P><P>		this.links.forEach( marked );
</P><P>		this.deps.forEach( handleChange );
	};
</P><P>	LinkModel.prototype.markedAll = function markedAll$1 () {
		this.children.forEach( markedAll );
		this.marked();
	};
</P><P>	LinkModel.prototype.notifiedUpstream = function notifiedUpstream ( startPath, root ) {
		var this$1 = this;
</P><P>		this.links.forEach( function (l) { return l.notifiedUpstream( startPath, this$1.root ); } );
		this.deps.forEach( handleChange );
		if ( startPath &amp;&amp; this.rootLink &amp;&amp; this.root !== root ) {
			var path = startPath.slice( 1 );
			path.unshift( this.key );
			this.notifyUpstream( path );
		}
	};
</P><P>	LinkModel.prototype.relinked = function relinked () {
		this.target.registerLink( this );
		this.children.forEach( function (c) { return c.relinked(); } );
	};
</P><P>	LinkModel.prototype.relinking = function relinking ( target, safe ) {
		var this$1 = this;
</P><P>		if ( this.rootLink &amp;&amp; this.sourcePath ) { target = rebindMatch( this.sourcePath, target, this.target ); }
		if ( !target || this.target === target ) { return; }
</P><P>		this.target.unregisterLink( this );
		if ( this.keypathModel ) { this.keypathModel.rebindChildren( target ); }
</P><P>		this.target = target;
		this.children.forEach( function (c) {
			c.relinking( target.joinKey( c.key ), safe );
		});
</P><P>		if ( this.rootLink ) { this.addShuffleTask( function () {
			this$1.relinked();
			if ( !safe ) { this$1.notifyUpstream(); }
		}); }
	};
</P><P>	LinkModel.prototype.set = function set ( value ) {
		if ( this.boundValue ) { this.boundValue = null; }
		this.target.set( value );
	};
</P><P>	LinkModel.prototype.shuffle = function shuffle$1 ( newIndices ) {
		// watch for extra shuffles caused by a shuffle in a downstream link
		if ( this.shuffling ) { return; }
</P><P>		// let the real model handle firing off shuffles
		if ( !this.target.shuffling ) {
			this.target.shuffle( newIndices );
		} else {
			shuffle( this, newIndices, true );
		}
</P><P>	};
</P><P>	LinkModel.prototype.source = function source () {
		if ( this.target.source ) { return this.target.source(); }
		else { return this.target; }
	};
</P><P>	LinkModel.prototype.teardown = function teardown$1 () {
		if ( this._link ) { this._link.teardown(); }
		this.target.unregisterLink( this );
		this.children.forEach( teardown );
	};
</P><P>	return LinkModel;
}(ModelBase));
</P><P>ModelBase.prototype.link = function link ( model, keypath, options ) {
	var lnk = this._link || new LinkModel( this.parent, this, model, this.key );
	lnk.implicit = options &amp;&amp; options.implicit;
	lnk.sourcePath = keypath;
	lnk.rootLink = true;
	if ( this._link ) { this._link.relinking( model, true, false ); }
	this.rebind( lnk, this, false );
	fireShuffleTasks();
</P><P>	this._link = lnk;
	lnk.markedAll();
</P><P>	this.notifyUpstream();
	return lnk;
};
</P><P>ModelBase.prototype.unlink = function unlink () {
	if ( this._link ) {
		var ln = this._link;
		this._link = undefined;
		ln.rebind( this, this._link );
		fireShuffleTasks();
		ln.teardown();
		this.notifyUpstream();
	}
};
</P><P>// TODO what happens if a transition is aborted?
</P><P>var tickers = [];
var running = false;
</P><P>function tick () {
	runloop.start();
</P><P>	var now = performance.now();
</P><P>	var i;
	var ticker;
</P><P>	for ( i = 0; i &lt; tickers.length; i += 1 ) {
		ticker = tickers[i];
</P><P>		if ( !ticker.tick( now ) ) {
			// ticker is complete, remove it from the stack, and decrement i so we don't miss one
			tickers.splice( i--, 1 );
		}
	}
</P><P>	runloop.end();
</P><P>	if ( tickers.length ) {
		requestAnimationFrame( tick );
	} else {
		running = false;
	}
}
</P><P>var Ticker = function Ticker ( options ) {
	this.duration = options.duration;
	this.step = options.step;
	this.complete = options.complete;
	this.easing = options.easing;
</P><P>	this.start = performance.now();
	this.end = this.start + this.duration;
</P><P>	this.running = true;
</P><P>	tickers.push( this );
	if ( !running ) { requestAnimationFrame( tick ); }
};
</P><P>Ticker.prototype.tick = function tick ( now ) {
	if ( !this.running ) { return false; }
</P><P>	if ( now &gt; this.end ) {
		if ( this.step ) { this.step( 1 ); }
		if ( this.complete ) { this.complete( 1 ); }
</P><P>		return false;
	}
</P><P>	var elapsed = now - this.start;
	var eased = this.easing( elapsed / this.duration );
</P><P>	if ( this.step ) { this.step( eased ); }
</P><P>	return true;
};
</P><P>Ticker.prototype.stop = function stop () {
	if ( this.abort ) { this.abort(); }
	this.running = false;
};
</P><P>var prefixers = {};
</P><P>// TODO this is legacy. sooner we can replace the old adaptor API the better
function prefixKeypath ( obj, prefix ) {
	var prefixed = {};
</P><P>	if ( !prefix ) {
		return obj;
	}
</P><P>	prefix += '.';
</P><P>	for ( var key in obj ) {
		if ( obj.hasOwnProperty( key ) ) {
			prefixed[ prefix + key ] = obj[ key ];
		}
	}
</P><P>	return prefixed;
}
</P><P>function getPrefixer ( rootKeypath ) {
	var rootDot;
</P><P>	if ( !prefixers[ rootKeypath ] ) {
		rootDot = rootKeypath ? rootKeypath + '.' : <I>;</I></P><P>		prefixers[ rootKeypath ] = function ( relativeKeypath, value ) {
			var obj;
</P><P>			if ( typeof relativeKeypath === 'string' ) {
				obj = {};
				obj[ rootDot + relativeKeypath ] = value;
				return obj;
			}
</P><P>			if ( typeof relativeKeypath === 'object' ) {
				// 'relativeKeypath' is in fact a hash, not a keypath
				return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
			}
		};
	}
</P><P>	return prefixers[ rootKeypath ];
}
</P><P>var Model = (function (ModelBase$$1) {
	function Model ( parent, key ) {
		ModelBase$$1.call( this, parent );
</P><P>		this.ticker = null;
</P><P>		if ( parent ) {
			this.key = unescapeKey( key );
			this.isReadonly = parent.isReadonly;
</P><P>			if ( parent.value ) {
				this.value = parent.value[ this.key ];
				if ( Array.isArray( this.value ) ) { this.length = this.value.length; }
				this.adapt();
			}
		}
	}
</P><P>	if ( ModelBase$$1 ) Model.__proto__ = ModelBase$$1;
	Model.prototype = Object.create( ModelBase$$1 &amp;&amp; ModelBase$$1.prototype );
	Model.prototype.constructor = Model;
</P><P>	Model.prototype.adapt = function adapt () {
		var this$1 = this;
</P><P>		var adaptors = this.root.adaptors;
		var len = adaptors.length;
</P><P>		this.rewrap = false;
</P><P>		// Exit early if no adaptors
		if ( len === 0 ) { return; }
</P><P>		var value = this.wrapper ? ( 'newWrapperValue' in this ? this.newWrapperValue : this.wrapperValue ) : this.value;
</P><P>		// TODO remove this legacy nonsense
		var ractive = this.root.ractive;
		var keypath = this.getKeypath();
</P><P>		// tear previous adaptor down if present
		if ( this.wrapper ) {
			var shouldTeardown = this.wrapperValue === value ? false : !this.wrapper.reset || this.wrapper.reset( value ) === false;
</P><P>			if ( shouldTeardown ) {
				this.wrapper.teardown();
				this.wrapper = null;
</P><P>				// don't branch for undefined values
				if ( this.value !== undefined ) {
					var parentValue = this.parent.value || this.parent.createBranch( this.key );
					if ( parentValue[ this.key ] !== value ) { parentValue[ this.key ] = value; }
				}
			} else {
				delete this.newWrapperValue;
				this.wrapperValue = value;
				this.value = this.wrapper.get();
				return;
			}
		}
</P><P>		var i;
</P><P>		for ( i = 0; i &lt; len; i += 1 ) {
			var adaptor = adaptors[i];
			if ( adaptor.filter( value, keypath, ractive ) ) {
				this$1.wrapper = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
				this$1.wrapperValue = value;
				this$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor
</P><P>				this$1.value = this$1.wrapper.get();
</P><P>				break;
			}
		}
	};
</P><P>	Model.prototype.animate = function animate ( from, to, options, interpolator ) {
		var this$1 = this;
</P><P>		if ( this.ticker ) { this.ticker.stop(); }
</P><P>		var fulfilPromise;
		var promise = new Promise( function (fulfil) { return fulfilPromise = fulfil; } );
</P><P>		this.ticker = new Ticker({
			duration: options.duration,
			easing: options.easing,
			step: function (t) {
				var value = interpolator( t );
				this$1.applyValue( value );
				if ( options.step ) { options.step( t, value ); }
			},
			complete: function () {
				this$1.applyValue( to );
				if ( options.complete ) { options.complete( to ); }
</P><P>				this$1.ticker = null;
				fulfilPromise();
			}
		});
</P><P>		promise.stop = this.ticker.stop;
		return promise;
	};
</P><P>	Model.prototype.applyValue = function applyValue ( value, notify ) {
		if ( notify === void 0 ) notify = true;
</P><P>		if ( isEqual( value, this.value ) ) { return; }
		if ( this.boundValue ) { this.boundValue = null; }
</P><P>		if ( this.parent.wrapper &amp;&amp; this.parent.wrapper.set ) {
			this.parent.wrapper.set( this.key, value );
			this.parent.value = this.parent.wrapper.get();
</P><P>			this.value = this.parent.value[ this.key ];
			if ( this.wrapper ) { this.newWrapperValue = this.value; }
			this.adapt();
		} else if ( this.wrapper ) {
			this.newWrapperValue = value;
			this.adapt();
		} else {
			var parentValue = this.parent.value || this.parent.createBranch( this.key );
			if ( isObjectLike( parentValue ) ) {
				parentValue[ this.key ] = value;
			} else {
				warnIfDebug( (&quot;Attempted to set a property of a non-object '&quot; + (this.getKeypath()) + &quot;'&quot;) );
				return;
			}
</P><P>			this.value = value;
			this.adapt();
		}
</P><P>		// keep track of array stuff
		if ( Array.isArray( value ) ) {
			this.length = value.length;
			this.isArray = true;
		} else {
			this.isArray = false;
		}
</P><P>		// notify dependants
		this.links.forEach( handleChange );
		this.children.forEach( mark );
		this.deps.forEach( handleChange );
</P><P>		if ( notify ) { this.notifyUpstream(); }
</P><P>		if ( this.parent.isArray ) {
			if ( this.key === 'length' ) { this.parent.length = value; }
			else { this.parent.joinKey( 'length' ).mark(); }
		}
	};
</P><P>	Model.prototype.createBranch = function createBranch ( key ) {
		var branch = isNumeric( key ) ? [] : {};
		this.applyValue( branch, false );
</P><P>		return branch;
	};
</P><P>	Model.prototype.get = function get ( shouldCapture, opts ) {
		if ( this._link ) { return this._link.get( shouldCapture, opts ); }
		if ( shouldCapture ) { capture( this ); }
		// if capturing, this value needs to be unwrapped because it's for external use
		if ( opts &amp;&amp; opts.virtual ) { return this.getVirtual( false ); }
		return maybeBind( this, ( ( opts &amp;&amp; 'unwrap' in opts ) ? opts.unwrap !== false : shouldCapture ) &amp;&amp; this.wrapper ? this.wrapperValue : this.value, !opts || opts.shouldBind !== false );
	};
</P><P>	Model.prototype.getKeypathModel = function getKeypathModel () {
		if ( !this.keypathModel ) { this.keypathModel = new KeypathModel( this ); }
		return this.keypathModel;
	};
</P><P>	Model.prototype.joinKey = function joinKey ( key, opts ) {
		if ( this._link ) {
			if ( opts &amp;&amp; opts.lastLink !== false &amp;&amp; ( key === undefined || key === <I> ) ) { return this; }</I>
			return this._link.joinKey( key );
		}
</P><P>		if ( key === undefined || key === <I> ) { return this; }</I></P><P>
		if ( !this.childByKey.hasOwnProperty( key ) ) {
			var child = new Model( this, key );
			this.children.push( child );
			this.childByKey[ key ] = child;
		}
</P><P>		if ( this.childByKey[ key ]._link &amp;&amp; ( !opts || opts.lastLink !== false ) ) { return this.childByKey[ key ]._link; }
		return this.childByKey[ key ];
	};
</P><P>	Model.prototype.mark = function mark$1 ( force ) {
		if ( this._link ) { return this._link.mark(); }
</P><P>		var value = this.retrieve();
</P><P>		if ( force || !isEqual( value, this.value ) ) {
			var old = this.value;
			this.value = value;
			if ( this.boundValue ) { this.boundValue = null; }
</P><P>			// make sure the wrapper stays in sync
			if ( old !== value || this.rewrap ) {
				if ( this.wrapper ) { this.newWrapperValue = value; }
				this.adapt();
			}
</P><P>			// keep track of array stuff
			if ( Array.isArray( value ) ) {
				this.length = value.length;
				this.isArray = true;
			} else {
				this.isArray = false;
			}
</P><P>			this.children.forEach( mark );
			this.links.forEach( marked );
</P><P>			this.deps.forEach( handleChange );
		}
	};
</P><P>	Model.prototype.merge = function merge ( array, comparator ) {
		var oldArray = this.value;
		var newArray = array;
		if ( oldArray === newArray ) { oldArray = recreateArray( this ); }
		if ( comparator ) {
			oldArray = oldArray.map( comparator );
			newArray = newArray.map( comparator );
		}
</P><P>		var oldLength = oldArray.length;
</P><P>		var usedIndices = {};
		var firstUnusedIndex = 0;
</P><P>		var newIndices = oldArray.map( function (item) {
			var index;
			var start = firstUnusedIndex;
</P><P>			do {
				index = newArray.indexOf( item, start );
</P><P>				if ( index === -1 ) {
					return -1;
				}
</P><P>				start = index + 1;
			} while ( ( usedIndices[ index ] === true ) &amp;&amp; start &lt; oldLength );
</P><P>			// keep track of the first unused index, so we don't search
			// the whole of newArray for each item in oldArray unnecessarily
			if ( index === firstUnusedIndex ) {
				firstUnusedIndex += 1;
			}
			// allow next instance of next &quot;equal&quot; to be found item
			usedIndices[ index ] = true;
			return index;
		});
</P><P>		this.parent.value[ this.key ] = array;
		this.shuffle( newIndices );
	};
</P><P>	Model.prototype.retrieve = function retrieve () {
		return this.parent.value ? this.parent.value[ this.key ] : undefined;
	};
</P><P>	Model.prototype.set = function set ( value ) {
		if ( this.ticker ) { this.ticker.stop(); }
		this.applyValue( value );
	};
</P><P>	Model.prototype.shuffle = function shuffle$1 ( newIndices ) {
		shuffle( this, newIndices, false );
	};
</P><P>	Model.prototype.source = function source () { return this; };
</P><P>	Model.prototype.teardown = function teardown$1 () {
		if ( this._link ) { this._link.teardown(); }
		this.children.forEach( teardown );
		if ( this.wrapper ) { this.wrapper.teardown(); }
		if ( this.keypathModel ) { this.keypathModel.teardown(); }
	};
</P><P>	return Model;
}(ModelBase));
</P><P>function recreateArray( model ) {
	var array = [];
</P><P>	for ( var i = 0; i &lt; model.length; i++ ) {
		array[ i ] = (model.childByKey[i] || {}).value;
	}
</P><P>	return array;
}
</P><P>/* global global */
var data = {};
</P><P>var SharedModel = (function (Model$$1) {
	function SharedModel ( value, name ) {
		Model$$1.call( this, null, (&quot;@&quot; + name) );
		this.key = &quot;@&quot; + name;
		this.value = value;
		this.isRoot = true;
		this.root = this;
		this.adaptors = [];
	}
</P><P>	if ( Model$$1 ) SharedModel.__proto__ = Model$$1;
	SharedModel.prototype = Object.create( Model$$1 &amp;&amp; Model$$1.prototype );
	SharedModel.prototype.constructor = SharedModel;
</P><P>	SharedModel.prototype.getKeypath = function getKeypath () {
		return this.key;
	};
</P><P>	return SharedModel;
}(Model));
</P><P>var SharedModel$1 = new SharedModel( data, 'shared' );
</P><P>var GlobalModel = new SharedModel( typeof global !== 'undefined' ? global : window, 'global' );
</P><P>function resolveReference ( fragment, ref ) {
	var initialFragment = fragment;
	// current context ref
	if ( ref === '.' ) { return fragment.findContext(); }
</P><P>	// ancestor references
	if ( ref[0] === '~' ) { return fragment.ractive.viewmodel.joinAll( splitKeypath( ref.slice( 2 ) ) ); }
</P><P>	// scoped references
	if ( ref[0] === '.' || ref[0] === '^' ) {
		var frag = fragment;
		var parts = ref.split( '/' );
		var explicitContext = parts[0] === '^^';
		var context$1 = explicitContext ? null : fragment.findContext();
</P><P>		// account for the first context hop
		if ( explicitContext ) { parts.unshift( '^^' ); }
</P><P>		// walk up the context chain
		while ( parts[0] === '^^' ) {
			parts.shift();
			context$1 = null;
			while ( frag &amp;&amp; !context$1 ) {
				context$1 = frag.context;
				frag = frag.parent.component ? frag.parent.component.parentFragment : frag.parent;
			}
		}
</P><P>		if ( !context$1 &amp;&amp; explicitContext ) {
			throw new Error( (&quot;Invalid context parent reference ('&quot; + ref + &quot;'). There is not context at that level.&quot;) );
		}
</P><P>		// walk up the context path
		while ( parts[0] === '.' || parts[0] === '..' ) {
			var part = parts.shift();
</P><P>			if ( part === '..' ) {
				context$1 = context$1.parent;
			}
		}
</P><P>		ref = parts.join( '/' );
</P><P>		// special case - `<A href="/wiki/index.php?title=Template:.foo&amp;action=edit&amp;redlink=1" class="new" title="Template:.foo (page does not exist)">Template:.foo</A>` means the same as `{{./foo}}`
		if ( ref[0] === '.' ) { ref = ref.slice( 1 ); }
		return context$1.joinAll( splitKeypath( ref ) );
	}
</P><P>	var keys = splitKeypath( ref );
	if ( !keys.length ) { return; }
	var base = keys.shift();
</P><P>	// special refs
	if ( base[0] === '@' ) {
		// shorthand from outside the template
		// @this referring to local ractive instance
		if ( base === '@this' || base === '@' ) {
			return fragment.ractive.viewmodel.getRactiveModel().joinAll( keys );
		}
</P><P>		// @index or @key referring to the nearest repeating index or key
		else if ( base === '@index' || base === '@key' ) {
			if ( keys.length ) { badReference( base ); }
			var repeater = fragment.findRepeatingFragment();
			// make sure the found fragment is actually an iteration
			if ( !repeater.isIteration ) { return; }
			return repeater.context.getKeyModel( repeater[ ref[1] === 'i' ? 'index' : 'key' ] );
		}
</P><P>		// @global referring to window or global
		else if ( base === '@global' ) {
			return GlobalModel.joinAll( keys );
		}
</P><P>		// @global referring to window or global
		else if ( base === '@shared' ) {
			return SharedModel$1.joinAll( keys );
		}
</P><P>		// @keypath or @rootpath, the current keypath string
		else if ( base === '@keypath' || base === '@rootpath' ) {
			var root = ref[1] === 'r' ? fragment.ractive.root : null;
			var context$2 = fragment.findContext();
</P><P>			// skip over component roots, which provide no context
			while ( root &amp;&amp; context$2.isRoot &amp;&amp; context$2.ractive.component ) {
				context$2 = context$2.ractive.component.parentFragment.findContext();
			}
</P><P>			return context$2.getKeypathModel( root );
		}
</P><P>		else if ( base === '@context' ) {
			return new ContextModel( fragment.getContext() );
		}
</P><P>		// @context-local data
		else if ( base === '@local' ) {
			return fragment.getContext()._data.joinAll( keys );
		}
</P><P>		// nope
		else {
			throw new Error( (&quot;Invalid special reference '&quot; + base + &quot;'&quot;) );
		}
	}
</P><P>	var context = fragment.findContext();
</P><P>	// check immediate context for a match
	if ( context.has( base ) ) {
		return context.joinKey( base ).joinAll( keys );
	}
</P><P>	// walk up the fragment hierarchy looking for a matching ref, alias, or key in a context
	var createMapping = false;
	var shouldWarn = fragment.ractive.warnAboutAmbiguity;
</P><P>	while ( fragment ) {
		// repeated fragments
		if ( fragment.isIteration ) {
			if ( base === fragment.parent.keyRef ) {
				if ( keys.length ) { badReference( base ); }
				return fragment.context.getKeyModel( fragment.key );
			}
</P><P>			if ( base === fragment.parent.indexRef ) {
				if ( keys.length ) { badReference( base ); }
				return fragment.context.getKeyModel( fragment.index );
			}
		}
</P><P>		// alias node or iteration
		if ( fragment.aliases  &amp;&amp; fragment.aliases.hasOwnProperty( base ) ) {
			var model = fragment.aliases[ base ];
</P><P>			if ( keys.length === 0 ) { return model; }
			else if ( typeof model.joinAll === 'function' ) {
				return model.joinAll( keys );
			}
		}
</P><P>		// check fragment context to see if it has the key we need
		if ( fragment.context &amp;&amp; fragment.context.has( base ) ) {
			// this is an implicit mapping
			if ( createMapping ) {
				if ( shouldWarn ) { warnIfDebug( (&quot;'&quot; + ref + &quot;' resolved but is ambiguous and will create a mapping to a parent component.&quot;) ); }
				return context.root.createLink( base, fragment.context.joinKey( base ), base, { implicit: true }).joinAll( keys );
			}
</P><P>			if ( shouldWarn ) { warnIfDebug( (&quot;'&quot; + ref + &quot;' resolved but is ambiguous.&quot;) ); }
			return fragment.context.joinKey( base ).joinAll( keys );
		}
</P><P>		if ( ( fragment.componentParent || ( !fragment.parent &amp;&amp; fragment.ractive.component ) ) &amp;&amp; !fragment.ractive.isolated ) {
			// ascend through component boundary
			fragment = fragment.componentParent || fragment.ractive.component.parentFragment;
			createMapping = true;
		} else {
			fragment = fragment.parent;
		}
	}
</P><P>	// if enabled, check the instance for a match
	if ( initialFragment.ractive.resolveInstanceMembers ) {
		var model$1 = initialFragment.ractive.viewmodel.getRactiveModel();
		if ( model$1.has( base ) ) {
			return model$1.joinKey( base ).joinAll( keys );
		}
	}
</P><P>	if ( shouldWarn ) {
		warnIfDebug( (&quot;'&quot; + ref + &quot;' is ambiguous and did not resolve.&quot;) );
	}
</P><P>	// didn't find anything, so go ahead and create the key on the local model
	return context.joinKey( base ).joinAll( keys );
}
</P><P>function badReference ( key ) {
	throw new Error( (&quot;An index or key reference (&quot; + key + &quot;) cannot have child properties&quot;) );
}
</P><P>var ContextModel = function ContextModel ( context ) {
	this.context = context;
};
</P><P>ContextModel.prototype.get = function get () { return this.context; };
</P><P>var extern = {};
</P><P>function getRactiveContext ( ractive ) {
	var assigns = [], len = arguments.length - 1;
	while ( len-- &gt; 0 ) assigns[ len ] = arguments[ len + 1 ];
</P><P>	var fragment = ractive.fragment || ractive._fakeFragment || ( ractive._fakeFragment = new FakeFragment( ractive ) );
	return fragment.getContext.apply( fragment, assigns );
}
</P><P>function getContext () {
	var assigns = [], len = arguments.length;
	while ( len-- ) assigns[ len ] = arguments[ len ];
</P><P>	if ( !this.ctx ) { this.ctx = new extern.Context( this ); }
	assigns.unshift( Object.create( this.ctx ) );
	return Object.assign.apply( null, assigns );
}
</P><P>var FakeFragment = function FakeFragment ( ractive ) {
	this.ractive = ractive;
};
</P><P>FakeFragment.prototype.findContext = function findContext () { return this.ractive.viewmodel; };
var proto = FakeFragment.prototype;
proto.getContext = getContext;
proto.find = proto.findComponent = proto.findAll = proto.findAllComponents = noop;
</P><P>var keep = false;
</P><P>function set ( ractive, pairs, options ) {
	var k = keep;
</P><P>	var deep = options &amp;&amp; options.deep;
	var shuffle = options &amp;&amp; options.shuffle;
	var promise = runloop.start( ractive, true );
	if ( options &amp;&amp; 'keep' in options ) { keep = options.keep; }
</P><P>	var i = pairs.length;
	while ( i-- ) {
		var model = pairs[i][0];
		var value = pairs[i][1];
		var keypath = pairs[i][2];
</P><P>		if ( !model ) {
			runloop.end();
			throw new Error( (&quot;Failed to set invalid keypath '&quot; + keypath + &quot;'&quot;) );
		}
</P><P>		if ( deep ) { deepSet( model, value ); }
		else if ( shuffle ) {
			var array = value;
			var target = model.get();
			// shuffle target array with itself
			if ( !array ) { array = target; }
</P><P>			if ( !Array.isArray( target ) || !Array.isArray( array ) ) {
				throw new Error( 'You cannot merge an array with a non-array' );
			}
</P><P>			var comparator = getComparator( shuffle );
			model.merge( array, comparator );
		} else { model.set( value ); }
	}
</P><P>	runloop.end();
</P><P>	keep = k;
</P><P>	return promise;
}
</P><P>var star = /\*/;
function gather ( ractive, keypath, base, isolated ) {
	if ( !base &amp;&amp; ( keypath[0] === '.' || keypath[1] === '^' ) ) {
		warnIfDebug( &quot;Attempted to set a relative keypath from a non-relative context. You can use a context object to set relative keypaths.&quot; );
		return [];
	}
</P><P>	var keys = splitKeypath( keypath );
	var model = base || ractive.viewmodel;
</P><P>	if ( star.test( keypath ) ) {
		return model.findMatches( keys );
	} else {
		if ( model === ractive.viewmodel ) {
			// allow implicit mappings
			if ( ractive.component &amp;&amp; !ractive.isolated &amp;&amp; !model.has( keys[0] ) &amp;&amp; keypath[0] !== '@' &amp;&amp; keypath[0] &amp;&amp; !isolated ) {
				return [ resolveReference( ractive.fragment || new FakeFragment( ractive ), keypath ) ];
			} else {
				return [ model.joinAll( keys ) ];
			}
		} else {
			return [ model.joinAll( keys ) ];
		}
	}
}
</P><P>function build ( ractive, keypath, value, isolated ) {
	var sets = [];
</P><P>	// set multiple keypaths in one go
	if ( isObject( keypath ) ) {
		var loop = function ( k ) {
			if ( keypath.hasOwnProperty( k ) ) {
				sets.push.apply( sets, gather( ractive, k, null, isolated ).map( function (m) { return [ m, keypath[k], k ]; } ) );
			}
		};
</P><P>		for ( var k in keypath ) loop( k );
</P><P>	}
	// set a single keypath
	else {
		sets.push.apply( sets, gather( ractive, keypath, null, isolated ).map( function (m) { return [ m, value, keypath ]; } ) );
	}
</P><P>	return sets;
}
</P><P>var deepOpts = { virtual: false };
function deepSet( model, value ) {
	var dest = model.get( false, deepOpts );
</P><P>	// if dest doesn't exist, just set it
	if ( dest == null || typeof value !== 'object' ) { return model.set( value ); }
	if ( typeof dest !== 'object' ) { return model.set( value ); }
</P><P>	for ( var k in value ) {
		if ( value.hasOwnProperty( k ) ) {
			deepSet( model.joinKey( k ), value[k] );
		}
	}
}
</P><P>var comparators = {};
function getComparator ( option ) {
	if ( option === true ) { return null; } // use existing arrays
	if ( typeof option === 'function' ) { return option; }
</P><P>	if ( typeof option === 'string' ) {
		return comparators[ option ] || ( comparators[ option ] = function (thing) { return thing[ option ]; } );
	}
</P><P>	throw new Error( 'If supplied, options.compare must be a string, function, or true' ); // TODO link to docs
}
</P><P>var errorMessage = 'Cannot add to a non-numeric value';
</P><P>function add ( ractive, keypath, d, options ) {
	if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
		throw new Error( 'Bad arguments' );
	}
</P><P>	var sets = build( ractive, keypath, d, options &amp;&amp; options.isolated );
</P><P>	return set( ractive, sets.map( function (pair) {
		var model = pair[0];
		var add = pair[1];
		var value = model.get();
		if ( !isNumeric( add ) || !isNumeric( value ) ) { throw new Error( errorMessage ); }
		return [ model, value + add ];
	}));
}
</P><P>function Ractive$add ( keypath, d, options ) {
	var num = typeof d === 'number' ? d : 1;
	var opts = typeof d === 'object' ? d : options;
	return add( this, keypath, num, opts );
}
</P><P>var noAnimation = Promise.resolve();
Object.defineProperty( noAnimation, 'stop', { value: noop });
</P><P>var linear = easing.linear;
</P><P>function getOptions ( options, instance ) {
	options = options || {};
</P><P>	var easing$$1;
	if ( options.easing ) {
		easing$$1 = typeof options.easing === 'function' ?
			options.easing :
			instance.easing[ options.easing ];
	}
</P><P>	return {
		easing: easing$$1 || linear,
		duration: 'duration' in options ? options.duration : 400,
		complete: options.complete || noop,
		step: options.step || noop
	};
}
</P><P>function animate ( ractive, model, to, options ) {
	options = getOptions( options, ractive );
	var from = model.get();
</P><P>	// don't bother animating values that stay the same
	if ( isEqual( from, to ) ) {
		options.complete( options.to );
		return noAnimation; // TODO should this have .then and .catch methods?
	}
</P><P>	var interpolator = interpolate( from, to, ractive, options.interpolator );
</P><P>	// if we can't interpolate the value, set it immediately
	if ( !interpolator ) {
		runloop.start();
		model.set( to );
		runloop.end();
</P><P>		return noAnimation;
	}
</P><P>	return model.animate( from, to, options, interpolator );
}
</P><P>function Ractive$animate ( keypath, to, options ) {
	if ( typeof keypath === 'object' ) {
		var keys = Object.keys( keypath );
</P><P>		throw new Error( (&quot;ractive.animate(...) no longer supports objects. Instead of ractive.animate({\n  &quot; + (keys.map( function (key) { return (&quot;'&quot; + key + &quot;': &quot; + (keypath[ key ])); } ).join( '\n  ' )) + &quot;\n}, {...}), do\n\n&quot; + (keys.map( function (key) { return (&quot;ractive.animate('&quot; + key + &quot;', &quot; + (keypath[ key ]) + &quot;, {...});&quot;); } ).join( '\n' )) + &quot;\n&quot;) );
	}
</P><P>
	return animate( this, this.viewmodel.joinAll( splitKeypath( keypath ) ), to, options );
}
</P><P>function enqueue ( ractive, event ) {
	if ( ractive.event ) {
		ractive._eventQueue.push( ractive.event );
	}
</P><P>	ractive.event = event;
}
</P><P>function dequeue ( ractive ) {
	if ( ractive._eventQueue.length ) {
		ractive.event = ractive._eventQueue.pop();
	} else {
		ractive.event = null;
	}
}
</P><P>var initStars = {};
var bubbleStars = {};
</P><P>// cartesian product of name parts and stars
// adjusted appropriately for special cases
function variants ( name, initial ) {
	var map = initial ? initStars : bubbleStars;
	if ( map[ name ] ) { return map[ name ]; }
</P><P>	var parts = name.split( '.' );
	var result = [];
	var base = false;
</P><P>	// initial events the implicit namespace of 'this'
	if ( initial ) {
		parts.unshift( 'this' );
		base = true;
	}
</P><P>	// use max - 1 bits as a bitmap to pick a part or a *
	// need to skip the full star case if the namespace is synthetic
	var max = Math.pow( 2, parts.length ) - ( initial ? 1 : 0 );
	for ( var i = 0; i &lt; max; i++ ) {
		var join = [];
		for ( var j = 0; j &lt; parts.length; j++ ) {
			join.push( 1 &amp; ( i &gt;&gt; j ) ? '*' : parts[j] );
		}
		result.unshift( join.join( '.' ) );
	}
</P><P>	if ( base ) {
		// include non-this-namespaced versions
		if ( parts.length &gt; 2 ) {
			result.push.apply( result, variants( name, false ) );
		} else {
			result.push( '*' );
			result.push( name );
		}
	}
</P><P>	map[ name ] = result;
	return result;
}
</P><P>function fireEvent ( ractive, eventName, context, args ) {
	if ( args === void 0 ) args = [];
</P><P>	if ( !eventName ) { return; }
</P><P>	context.name = eventName;
	args.unshift( context );
</P><P>	var eventNames = ractive._nsSubs ? variants( eventName, true ) : [ '*', eventName ];
</P><P>	return fireEventAs( ractive, eventNames, context, args, true );
}
</P><P>function fireEventAs  ( ractive, eventNames, context, args, initialFire ) {
	if ( initialFire === void 0 ) initialFire = false;
</P><P>	var bubble = true;
</P><P>	if ( initialFire || ractive._nsSubs ) {
		enqueue( ractive, context );
</P><P>		var i = eventNames.length;
		while ( i-- ) {
			if ( eventNames[ i ] in ractive._subs ) {
				bubble = notifySubscribers( ractive, ractive._subs[ eventNames[ i ] ], context, args ) &amp;&amp; bubble;
			}
		}
</P><P>		dequeue( ractive );
	}
</P><P>	if ( ractive.parent &amp;&amp; bubble ) {
		if ( initialFire &amp;&amp; ractive.component ) {
			var fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];
			eventNames = variants( fullName, false );
</P><P>			if ( context &amp;&amp; !context.component ) {
				context.component = ractive;
			}
		}
</P><P>		bubble = fireEventAs( ractive.parent, eventNames, context, args );
	}
</P><P>	return bubble;
}
</P><P>function notifySubscribers ( ractive, subscribers, context, args ) {
	var originalEvent = null;
	var stopEvent = false;
</P><P>	// subscribers can be modified inflight, e.g. &quot;once&quot; functionality
	// so we need to copy to make sure everyone gets called
	subscribers = subscribers.slice();
</P><P>	for ( var i = 0, len = subscribers.length; i &lt; len; i += 1 ) {
		if ( !subscribers[ i ].off &amp;&amp; subscribers[ i ].handler.apply( ractive, args ) === false ) {
			stopEvent = true;
		}
	}
</P><P>	if ( context &amp;&amp; stopEvent &amp;&amp; ( originalEvent = context.event ) ) {
		originalEvent.preventDefault &amp;&amp; originalEvent.preventDefault();
		originalEvent.stopPropagation &amp;&amp; originalEvent.stopPropagation();
	}
</P><P>	return !stopEvent;
}
</P><P>var Hook = function Hook ( event ) {
	this.event = event;
	this.method = 'on' + event;
};
</P><P>Hook.prototype.fire = function fire ( ractive, arg ) {
	var context = getRactiveContext( ractive );
</P><P>	if ( ractive[ this.method ] ) {
		arg ? ractive[ this.method ]( context, arg ) : ractive[ this.method ]( context );
	}
</P><P>	fireEvent( ractive, this.event, context, arg ? [ arg, ractive ] : [ ractive ] );
};
</P><P>function findAnchors ( fragment, name ) {
	if ( name === void 0 ) name = null;
</P><P>	var res = [];
</P><P>	findAnchorsIn( fragment, name, res );
</P><P>	return res;
}
</P><P>function findAnchorsIn ( item, name, result ) {
	if ( item.isAnchor ) {
		if ( !name || item.name === name ) {
			result.push( item );
		}
	} else if ( item.items ) {
		item.items.forEach( function (i) { return findAnchorsIn( i, name, result ); } );
	} else if ( item.iterations ) {
		item.iterations.forEach( function (i) { return findAnchorsIn( i, name, result ); } );
	} else if ( item.fragment &amp;&amp; !item.component ) {
		findAnchorsIn( item.fragment, name, result );
	}
}
</P><P>function updateAnchors ( instance, name ) {
	if ( name === void 0 ) name = null;
</P><P>	var anchors = findAnchors( instance.fragment, name );
	var idxs = {};
	var children = instance._children.byName;
</P><P>	anchors.forEach( function (a) {
		var name = a.name;
		if ( !( name in idxs ) ) { idxs[name] = 0; }
		var idx = idxs[name];
		var child = ( children[name] || [] )[idx];
</P><P>		if ( child &amp;&amp; child.lastBound !== a ) {
			if ( child.lastBound ) { child.lastBound.removeChild( child ); }
			a.addChild( child );
		}
</P><P>		idxs[name]++;
	});
}
</P><P>function unrenderChild ( meta ) {
	if ( meta.instance.fragment.rendered ) {
		meta.shouldDestroy = true;
		meta.instance.unrender();
	}
	meta.instance.el = null;
}
</P><P>var attachHook = new Hook( 'attachchild' );
</P><P>function attachChild ( child, options ) {
	if ( options === void 0 ) options = {};
</P><P>	var children = this._children;
</P><P>	if ( child.parent &amp;&amp; child.parent !== this ) { throw new Error( (&quot;Instance &quot; + (child._guid) + &quot; is already attached to a different instance &quot; + (child.parent._guid) + &quot;. Please detach it from the other instance using detachChild first.&quot;) ); }
	else if ( child.parent ) { throw new Error( (&quot;Instance &quot; + (child._guid) + &quot; is already attached to this instance.&quot;) ); }
</P><P>	var meta = {
		instance: child,
		ractive: this,
		name: options.name || child.constructor.name || 'Ractive',
		target: options.target || false,
		bubble: bubble,
		findNextNode: findNextNode
	};
	meta.nameOption = options.name;
</P><P>	// child is managing itself
	if ( !meta.target ) {
		meta.parentFragment = this.fragment;
		meta.external = true;
	} else {
		var list;
		if ( !( list = children.byName[ meta.target ] ) ) {
			list = [];
			this.set( (&quot;@this.children.byName.&quot; + (meta.target)), list );
		}
		var idx = options.prepend ? 0 : options.insertAt !== undefined ? options.insertAt : list.length;
		list.splice( idx, 0, meta );
	}
</P><P>	child.set({
		'@this.parent': this,
		'@this.root': this.root
	});
	child.component = meta;
	children.push( meta );
</P><P>	attachHook.fire( child );
</P><P>	var promise = runloop.start( child, true );
</P><P>	if ( meta.target ) {
		unrenderChild( meta );
		this.set( (&quot;@this.children.byName.&quot; + (meta.target)), null, { shuffle: true } );
		updateAnchors( this, meta.target );
	} else {
		if ( !child.isolated ) { child.viewmodel.attached( this.fragment ); }
	}
</P><P>	runloop.end();
</P><P>	promise.ractive = child;
	return promise.then( function () { return child; } );
}
</P><P>function bubble () { runloop.addFragment( this.instance.fragment ); }
</P><P>function findNextNode () {
	if ( this.anchor ) { return this.anchor.findNextNode(); }
}
</P><P>var detachHook = new Hook( 'detach' );
</P><P>function Ractive$detach () {
	if ( this.isDetached ) {
		return this.el;
	}
</P><P>	if ( this.el ) {
		removeFromArray( this.el.__ractive_instances__, this );
	}
</P><P>	this.el = this.fragment.detach();
	this.isDetached = true;
</P><P>	detachHook.fire( this );
	return this.el;
}
</P><P>var detachHook$1 = new Hook( 'detachchild' );
</P><P>function detachChild ( child ) {
	var children = this._children;
	var meta, index;
</P><P>	var i = children.length;
	while ( i-- ) {
		if ( children[i].instance === child ) {
			index = i;
			meta = children[i];
			break;
		}
	}
</P><P>	if ( !meta || child.parent !== this ) { throw new Error( (&quot;Instance &quot; + (child._guid) + &quot; is not attached to this instance.&quot;) ); }
</P><P>	var promise = runloop.start( child, true );
</P><P>	if ( meta.anchor ) { meta.anchor.removeChild( meta ); }
	if ( !child.isolated ) { child.viewmodel.detached(); }
</P><P>	runloop.end();
</P><P>	children.splice( index, 1 );
	if ( meta.target ) {
		var list = children.byName[ meta.target ];
		list.splice( list.indexOf( meta ), 1 );
		this.set( (&quot;@this.children.byName.&quot; + (meta.target)), null, { shuffle: true } );
		updateAnchors( this, meta.target );
	}
	child.set({
		'@this.parent': undefined,
		'@this.root': child
	});
	child.component = null;
</P><P>	detachHook$1.fire( child );
</P><P>	promise.ractive = child;
	return promise.then( function () { return child; } );
}
</P><P>function Ractive$find ( selector, options ) {
	var this$1 = this;
	if ( options === void 0 ) options = {};
</P><P>	if ( !this.el ) { throw new Error( (&quot;Cannot call ractive.find('&quot; + selector + &quot;') unless instance is rendered to the DOM&quot;) ); }
</P><P>	var node = this.fragment.find( selector, options );
	if ( node ) { return node; }
</P><P>	if ( options.remote ) {
		for ( var i = 0; i &lt; this._children.length; i++ ) {
			if ( !this$1._children[i].instance.fragment.rendered ) { continue; }
			node = this$1._children[i].instance.find( selector, options );
			if ( node ) { return node; }
		}
	}
}
</P><P>function Ractive$findAll ( selector, options ) {
	if ( options === void 0 ) options = {};
</P><P>	if ( !this.el ) { throw new Error( (&quot;Cannot call ractive.findAll('&quot; + selector + &quot;', ...) unless instance is rendered to the DOM&quot;) ); }
</P><P>	if ( !Array.isArray( options.result ) ) { options.result = []; }
</P><P>	this.fragment.findAll( selector, options );
</P><P>	if ( options.remote ) {
		// seach non-fragment children
		this._children.forEach( function (c) {
			if ( !c.target &amp;&amp; c.instance.fragment &amp;&amp; c.instance.fragment.rendered ) {
				c.instance.findAll( selector, options );
			}
		});
	}
</P><P>	return options.result;
}
</P><P>function Ractive$findAllComponents ( selector, options ) {
	if ( !options &amp;&amp; typeof selector === 'object' ) {
		options = selector;
		selector = <I>;</I>
	}
</P><P>	options = options || {};
</P><P>	if ( !Array.isArray( options.result ) ) { options.result = []; }
</P><P>	this.fragment.findAllComponents( selector, options );
</P><P>	if ( options.remote ) {
		// search non-fragment children
		this._children.forEach( function (c) {
			if ( !c.target &amp;&amp; c.instance.fragment &amp;&amp; c.instance.fragment.rendered ) {
				if ( !selector || c.name === selector ) {
					options.result.push( c.instance );
				}
</P><P>				c.instance.findAllComponents( selector, options );
			}
		});
	}
</P><P>	return options.result;
}
</P><P>function Ractive$findComponent ( selector, options ) {
	var this$1 = this;
	if ( options === void 0 ) options = {};
</P><P>	if ( typeof selector === 'object' ) {
		options = selector;
		selector = <I>;</I>
	}
</P><P>	var child = this.fragment.findComponent( selector, options );
	if ( child ) { return child; }
</P><P>	if ( options.remote ) {
		if ( !selector &amp;&amp; this._children.length ) { return this._children[0].instance; }
		for ( var i = 0; i &lt; this._children.length; i++ ) {
			// skip children that are or should be in an anchor
			if ( this$1._children[i].target ) { continue; }
			if ( this$1._children[i].name === selector ) { return this$1._children[i].instance; }
			child = this$1._children[i].instance.findComponent( selector, options );
			if ( child ) { return child; }
		}
	}
}
</P><P>function Ractive$findContainer ( selector ) {
	if ( this.container ) {
		if ( this.container.component &amp;&amp; this.container.component.name === selector ) {
			return this.container;
		} else {
			return this.container.findContainer( selector );
		}
	}
</P><P>	return null;
}
</P><P>function Ractive$findParent ( selector ) {
</P><P>	if ( this.parent ) {
		if ( this.parent.component &amp;&amp; this.parent.component.name === selector ) {
			return this.parent;
		} else {
			return this.parent.findParent ( selector );
		}
	}
</P><P>	return null;
}
</P><P>// This function takes an array, the name of a mutator method, and the
// arguments to call that mutator method with, and returns an array that
// maps the old indices to their new indices.
</P><P>// So if you had something like this...
//
//     array = [ 'a', 'b', 'c', 'd' ];
//     array.push( 'e' );
//
// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
// have changed. If you then did this...
//
//     array.unshift( 'z' );
//
// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
// one higher to make room for the 'z'. If you removed an item, the new index
// would be -1...
//
//     array.splice( 2, 2 );
//
// ...this would result in [ 0, 1, -1, -1, 2, 3 ].
//
// This information is used to enable fast, non-destructive shuffling of list
// sections when you do e.g. `ractive.splice( 'items', 2, 2 );
</P><P>function getNewIndices ( length, methodName, args ) {
	var newIndices = [];
</P><P>	var spliceArguments = getSpliceEquivalent( length, methodName, args );
</P><P>	if ( !spliceArguments ) {
		return null; // TODO support reverse and sort?
	}
</P><P>	var balance = ( spliceArguments.length - 2 ) - spliceArguments[1];
</P><P>	var removeStart = Math.min( length, spliceArguments[0] );
	var removeEnd = removeStart + spliceArguments[1];
	newIndices.startIndex = removeStart;
</P><P>	var i;
	for ( i = 0; i &lt; removeStart; i += 1 ) {
		newIndices.push( i );
	}
</P><P>	for ( ; i &lt; removeEnd; i += 1 ) {
		newIndices.push( -1 );
	}
</P><P>	for ( ; i &lt; length; i += 1 ) {
		newIndices.push( i + balance );
	}
</P><P>	// there is a net shift for the rest of the array starting with index + balance
	if ( balance !== 0 ) {
		newIndices.touchedFrom = spliceArguments[0];
	} else {
		newIndices.touchedFrom = length;
	}
</P><P>	return newIndices;
}
</P><P>
// The pop, push, shift an unshift methods can all be represented
// as an equivalent splice
function getSpliceEquivalent ( length, methodName, args ) {
	switch ( methodName ) {
		case 'splice':
			if ( args[0] !== undefined &amp;&amp; args[0] &lt; 0 ) {
				args[0] = length + Math.max( args[0], -length );
			}
</P><P>			if ( args[0] === undefined ) { args[0] = 0; }
</P><P>			while ( args.length &lt; 2 ) {
				args.push( length - args[0] );
			}
</P><P>			if ( typeof args[1] !== 'number' ) {
				args[1] = length - args[0];
			}
</P><P>			// ensure we only remove elements that exist
			args[1] = Math.min( args[1], length - args[0] );
</P><P>			return args;
</P><P>		case 'sort':
		case 'reverse':
			return null;
</P><P>		case 'pop':
			if ( length ) {
				return [ length - 1, 1 ];
			}
			return [ 0, 0 ];
</P><P>		case 'push':
			return [ length, 0 ].concat( args );
</P><P>		case 'shift':
			return [ 0, length ? 1 : 0 ];
</P><P>		case 'unshift':
			return [ 0, 0 ].concat( args );
	}
}
</P><P>var arrayProto = Array.prototype;
</P><P>var makeArrayMethod = function ( methodName ) {
	function path ( keypath ) {
		var args = [], len = arguments.length - 1;
		while ( len-- &gt; 0 ) args[ len ] = arguments[ len + 1 ];
</P><P>		return model( this.viewmodel.joinAll( splitKeypath( keypath ) ), args );
	}
</P><P>	function model ( mdl, args ) {
		var array = mdl.get();
</P><P>		if ( !Array.isArray( array ) ) {
			if ( array === undefined ) {
				array = [];
				var result$1 = arrayProto[ methodName ].apply( array, args );
				var promise$1 = runloop.start( this, true ).then( function () { return result$1; } );
				mdl.set( array );
				runloop.end();
				return promise$1;
			} else {
				throw new Error( (&quot;shuffle array method &quot; + methodName + &quot; called on non-array at &quot; + (mdl.getKeypath())) );
			}
		}
</P><P>		var newIndices = getNewIndices( array.length, methodName, args );
		var result = arrayProto[ methodName ].apply( array, args );
</P><P>		var promise = runloop.start( this, true ).then( function () { return result; } );
		promise.result = result;
</P><P>		if ( newIndices ) {
			mdl.shuffle( newIndices );
		} else {
			mdl.set( result );
		}
</P><P>		runloop.end();
</P><P>		return promise;
	}
</P><P>	return { path: path, model: model };
};
</P><P>var updateHook = new Hook( 'update' );
</P><P>function update$1 ( ractive, model, options ) {
	// if the parent is wrapped, the adaptor will need to be updated before
	// updating on this keypath
	if ( model.parent &amp;&amp; model.parent.wrapper ) {
		model.parent.adapt();
	}
</P><P>	var promise = runloop.start( ractive, true );
</P><P>	model.mark( options &amp;&amp; options.force );
</P><P>	// notify upstream of changes
	model.notifyUpstream();
</P><P>	runloop.end();
</P><P>	updateHook.fire( ractive, model );
</P><P>	return promise;
}
</P><P>function Ractive$update ( keypath, options ) {
	var opts, path;
</P><P>	if ( typeof keypath === 'string' ) {
		path = splitKeypath( keypath );
		opts = options;
	} else {
		opts = keypath;
	}
</P><P>	return update$1( this, path ? this.viewmodel.joinAll( path ) : this.viewmodel, opts );
}
</P><P>var TEXT              = 1;
var INTERPOLATOR      = 2;
var TRIPLE            = 3;
var SECTION           = 4;
var INVERTED          = 5;
var CLOSING           = 6;
var ELEMENT           = 7;
var PARTIAL           = 8;
var COMMENT           = 9;
var DELIMCHANGE       = 10;
var ANCHOR            = 11;
var ATTRIBUTE         = 13;
var CLOSING_TAG       = 14;
var COMPONENT         = 15;
var YIELDER           = 16;
var INLINE_PARTIAL    = 17;
var DOCTYPE           = 18;
var ALIAS             = 19;
</P><P>var NUMBER_LITERAL    = 20;
var STRING_LITERAL    = 21;
var ARRAY_LITERAL     = 22;
var OBJECT_LITERAL    = 23;
var BOOLEAN_LITERAL   = 24;
var REGEXP_LITERAL    = 25;
</P><P>var GLOBAL            = 26;
var KEY_VALUE_PAIR    = 27;
</P><P>
var REFERENCE         = 30;
var REFINEMENT        = 31;
var MEMBER            = 32;
var PREFIX_OPERATOR   = 33;
var BRACKETED         = 34;
var CONDITIONAL       = 35;
var INFIX_OPERATOR    = 36;
</P><P>var INVOCATION        = 40;
</P><P>var SECTION_IF        = 50;
var SECTION_UNLESS    = 51;
var SECTION_EACH      = 52;
var SECTION_WITH      = 53;
var SECTION_IF_WITH   = 54;
</P><P>var ELSE              = 60;
var ELSEIF            = 61;
</P><P>var EVENT             = 70;
var DECORATOR         = 71;
var TRANSITION        = 72;
var BINDING_FLAG      = 73;
var DELEGATE_FLAG     = 74;
</P><P>function findElement( start, orComponent, name ) {
	if ( orComponent === void 0 ) orComponent = true;
</P><P>	while ( start &amp;&amp; ( start.type !== ELEMENT || ( name &amp;&amp; start.name !== name ) ) &amp;&amp; ( !orComponent || ( start.type !== COMPONENT &amp;&amp; start.type !== ANCHOR ) ) ) {
		// start is a fragment - look at the owner
		if ( start.owner ) { start = start.owner; }
		// start is a component or yielder - look at the container
		else if ( start.component ) { start = start.containerFragment || start.component.parentFragment; }
		// start is an item - look at the parent
		else if ( start.parent ) { start = start.parent; }
		// start is an item without a parent - look at the parent fragment
		else if ( start.parentFragment ) { start = start.parentFragment; }
</P><P>		else { start = undefined; }
	}
</P><P>	return start;
}
</P><P>var modelPush = makeArrayMethod( 'push' ).model;
var modelPop = makeArrayMethod( 'pop' ).model;
var modelShift = makeArrayMethod( 'shift' ).model;
var modelUnshift = makeArrayMethod( 'unshift' ).model;
var modelSort = makeArrayMethod( 'sort' ).model;
var modelSplice = makeArrayMethod( 'splice' ).model;
var modelReverse = makeArrayMethod( 'reverse' ).model;
</P><P>var ContextData = (function (Model$$1) {
	function ContextData ( options ) {
		Model$$1.call( this, null, null );
</P><P>		this.isRoot = true;
		this.root = this;
		this.value = {};
		this.ractive = options.ractive;
		this.adaptors = [];
		this.context = options.context;
	}
</P><P>	if ( Model$$1 ) ContextData.__proto__ = Model$$1;
	ContextData.prototype = Object.create( Model$$1 &amp;&amp; Model$$1.prototype );
	ContextData.prototype.constructor = ContextData;
</P><P>	ContextData.prototype.getKeypath = function getKeypath () {
		return '@context.data';
	};
</P><P>	return ContextData;
}(Model));
</P><P>var Context = function Context ( fragment, element ) {
	this.fragment = fragment;
	this.element = element || findElement( fragment );
	this.node = this.element &amp;&amp; this.element.node;
	this.ractive = fragment.ractive;
	this.root = this;
};
</P><P>var prototypeAccessors = { decorators: {},_data: {} };
</P><P>prototypeAccessors.decorators.get = function () {
	var items = {};
	if ( !this.element ) { return items; }
	this.element.decorators.forEach( function (d) { return items[ d.name ] = d.intermediary; } );
	return items;
};
</P><P>prototypeAccessors._data.get = function () {
	return this.model || ( this.root.model = new ContextData({ ractive: this.ractive, context: this.root }) );
};
</P><P>// the usual mutation suspects
Context.prototype.add = function add ( keypath, d, options ) {
	var num = typeof d === 'number' ? +d : 1;
	var opts = typeof d === 'object' ? d : options;
	return set( this.ractive, build$1( this, keypath, num ).map( function (pair) {
		var model = pair[0];
			var val = pair[1];
		var value = model.get();
		if ( !isNumeric( val ) || !isNumeric( value ) ) { throw new Error( 'Cannot add non-numeric value' ); }
		return [ model, value + val ];
	}), opts );
};
</P><P>Context.prototype.animate = function animate$$1 ( keypath, value, options ) {
	var model = findModel( this, keypath ).model;
	return animate( this.ractive, model, value, options );
};
</P><P>// get relative keypaths and values
Context.prototype.get = function get ( keypath ) {
	if ( !keypath ) { return this.fragment.findContext().get( true ); }
</P><P>	var ref = findModel( this, keypath );
		var model = ref.model;
</P><P>	return model ? model.get( true ) : undefined;
};
</P><P>Context.prototype.link = function link ( source, dest ) {
	var there = findModel( this, source ).model;
	var here = findModel( this, dest ).model;
	var promise = runloop.start( this.ractive, true );
	here.link( there, source );
	runloop.end();
	return promise;
};
</P><P>Context.prototype.observe = function observe ( keypath, callback, options ) {
		if ( options === void 0 ) options = {};
</P><P>	if ( isObject( keypath ) ) { options = callback || {}; }
	options.fragment = this.fragment;
	return this.ractive.observe( keypath, callback, options );
};
</P><P>Context.prototype.observeOnce = function observeOnce ( keypath, callback, options ) {
		if ( options === void 0 ) options = {};
</P><P>	if ( isObject( keypath ) ) { options = callback || {}; }
	options.fragment = this.fragment;
	return this.ractive.observeOnce( keypath, callback, options );
};
</P><P>Context.prototype.pop = function pop ( keypath ) {
	return modelPop( findModel( this, keypath ).model, [] );
};
</P><P>Context.prototype.push = function push ( keypath ) {
		var values = [], len = arguments.length - 1;
		while ( len-- &gt; 0 ) values[ len ] = arguments[ len + 1 ];
</P><P>	return modelPush( findModel( this, keypath ).model, values );
};
</P><P>Context.prototype.raise = function raise ( name, event ) {
		var args = [], len = arguments.length - 2;
		while ( len-- &gt; 0 ) args[ len ] = arguments[ len + 2 ];
</P><P>	var element = this.element;
</P><P>	while ( element ) {
		var events = element.events;
		for ( var i = 0; i &lt; events.length; i++ ) {
			var ev = events[i];
			if ( ~ev.template.n.indexOf( name ) ) {
				var ctx = !event || !( 'original' in event ) ?
					ev.element.getContext( event || {}, { original: {} } ) :
					ev.element.getContext( event || {} );
				return ev.fire( ctx, args );
			}
		}
</P><P>		element = element.parent;
	}
};
</P><P>Context.prototype.readLink = function readLink ( keypath, options ) {
	return this.ractive.readLink( this.resolve( keypath ), options );
};
</P><P>Context.prototype.resolve = function resolve ( path, ractive ) {
	var ref = findModel( this, path );
		var model = ref.model;
		var instance = ref.instance;
	return model ? model.getKeypath( ractive || instance ) : path;
};
</P><P>Context.prototype.reverse = function reverse ( keypath ) {
	return modelReverse( findModel( this, keypath ).model, [] );
};
</P><P>Context.prototype.set = function set$$1 ( keypath, value, options ) {
	return set( this.ractive, build$1( this, keypath, value ), options );
};
</P><P>Context.prototype.shift = function shift ( keypath ) {
	return modelShift( findModel( this, keypath ).model, [] );
};
</P><P>Context.prototype.splice = function splice ( keypath, index, drop ) {
		var add = [], len = arguments.length - 3;
		while ( len-- &gt; 0 ) add[ len ] = arguments[ len + 3 ];
</P><P>	add.unshift( index, drop );
	return modelSplice( findModel( this, keypath ).model, add );
};
</P><P>Context.prototype.sort = function sort ( keypath ) {
	return modelSort( findModel( this, keypath ).model, [] );
};
</P><P>Context.prototype.subtract = function subtract ( keypath, d, options ) {
	var num = typeof d === 'number' ? d : 1;
	var opts = typeof d === 'object' ? d : options;
	return set( this.ractive, build$1( this, keypath, num ).map( function (pair) {
		var model = pair[0];
			var val = pair[1];
		var value = model.get();
		if ( !isNumeric( val ) || !isNumeric( value ) ) { throw new Error( 'Cannot add non-numeric value' ); }
		return [ model, value - val ];
	}), opts );
};
</P><P>Context.prototype.toggle = function toggle ( keypath, options ) {
	var ref = findModel( this, keypath );
		var model = ref.model;
	return set( this.ractive, [ [ model, !model.get() ] ], options );
};
</P><P>Context.prototype.unlink = function unlink ( dest ) {
	var here = findModel( this, dest ).model;
	var promise = runloop.start( this.ractive, true );
	if ( here.owner &amp;&amp; here.owner._link ) { here.owner.unlink(); }
	runloop.end();
	return promise;
};
</P><P>Context.prototype.unshift = function unshift ( keypath ) {
		var add = [], len = arguments.length - 1;
		while ( len-- &gt; 0 ) add[ len ] = arguments[ len + 1 ];
</P><P>	return modelUnshift( findModel( this, keypath ).model, add );
};
</P><P>Context.prototype.update = function update$$1 ( keypath, options ) {
	return update$1( this.ractive, findModel( this, keypath ).model, options );
};
</P><P>Context.prototype.updateModel = function updateModel ( keypath, cascade ) {
	var ref = findModel( this, keypath );
		var model = ref.model;
	var promise = runloop.start( this.ractive, true );
	model.updateFromBindings( cascade );
	runloop.end();
	return promise;
};
</P><P>// two-way binding related helpers
Context.prototype.isBound = function isBound () {
	var ref = this.getBindingModel( this );
		var model = ref.model;
	return !!model;
};
</P><P>Context.prototype.getBindingPath = function getBindingPath ( ractive ) {
	var ref = this.getBindingModel( this );
		var model = ref.model;
		var instance = ref.instance;
	if ( model ) { return model.getKeypath( ractive || instance ); }
};
</P><P>Context.prototype.getBinding = function getBinding () {
	var ref = this.getBindingModel( this );
		var model = ref.model;
	if ( model ) { return model.get( true ); }
};
</P><P>Context.prototype.getBindingModel = function getBindingModel ( ctx ) {
	var el = ctx.element;
	return { model: el.binding &amp;&amp; el.binding.model, instance: el.parentFragment.ractive };
};
</P><P>Context.prototype.setBinding = function setBinding ( value ) {
	var ref = this.getBindingModel( this );
		var model = ref.model;
	return set( this.ractive, [ [ model, value ] ] );
};
</P><P>Object.defineProperties( Context.prototype, prototypeAccessors );
</P><P>Context.forRactive = getRactiveContext;
// circular deps are fun
extern.Context = Context;
</P><P>// TODO: at some point perhaps this could support relative * keypaths?
function build$1 ( ctx, keypath, value ) {
	var sets = [];
</P><P>	// set multiple keypaths in one go
	if ( isObject( keypath ) ) {
		for ( var k in keypath ) {
			if ( keypath.hasOwnProperty( k ) ) {
				sets.push( [ findModel( ctx, k ).model, keypath[k] ] );
			}
		}
</P><P>	}
	// set a single keypath
	else {
		sets.push( [ findModel( ctx, keypath ).model, value ] );
	}
</P><P>	return sets;
}
</P><P>function findModel ( ctx, path ) {
	var frag = ctx.fragment;
</P><P>	if ( typeof path !== 'string' ) {
		return { model: frag.findContext(), instance: path };
	}
</P><P>	return { model: resolveReference( frag, path ), instance: frag.ractive };
}
</P><P>function Ractive$fire ( eventName ) {
	var args = [], len = arguments.length - 1;
	while ( len-- &gt; 0 ) args[ len ] = arguments[ len + 1 ];
</P><P>	// watch for reproxy
	if ( args[0] instanceof Context ) {
		var proto = args.shift();
		var ctx = Object.create( proto );
		Object.assign( ctx, proto );
		return fireEvent( this, eventName, ctx, args );
	} else {
		return fireEvent( this, eventName, Context.forRactive( this ), args );
	}
}
</P><P>function Ractive$get ( keypath, opts ) {
	if ( typeof keypath !== 'string' ) { return this.viewmodel.get( true, keypath ); }
</P><P>	var keys = splitKeypath( keypath );
	var key = keys[0];
</P><P>	var model;
</P><P>	if ( !this.viewmodel.has( key ) ) {
		// if this is an inline component, we may need to create
		// an implicit mapping
		if ( this.component &amp;&amp; !this.isolated ) {
			model = resolveReference( this.fragment || new FakeFragment( this ), key );
		}
	}
</P><P>	model = this.viewmodel.joinAll( keys );
	return model.get( true, opts );
}
</P><P>var query = doc &amp;&amp; doc.querySelector;
</P><P>function getContext$2 ( node ) {
	if ( typeof node === 'string' &amp;&amp; query ) {
		node = query.call( document, node );
	}
</P><P>	var instances;
	if ( node ) {
		if ( node._ractive ) {
			return node._ractive.proxy.getContext();
		} else if ( ( instances = node.__ractive_instances__ ) &amp;&amp; instances.length === 1 ) {
			return getRactiveContext( instances[0] );
		}
	}
}
</P><P>function getNodeInfo$1 ( node ) {
	warnOnceIfDebug( &quot;getNodeInfo has been renamed to getContext, and the getNodeInfo alias will be removed in a future release.&quot; );
	return getContext$2 ( node );
}
</P><P>function getContext$1 ( node, options ) {
	if ( typeof node === 'string' ) {
		node = this.find( node, options );
	}
</P><P>	return getContext$2( node );
}
</P><P>function getNodeInfo$$1 ( node, options ) {
	if ( typeof node === 'string' ) {
		node = this.find( node, options );
	}
</P><P>	return getNodeInfo$1( node );
}
</P><P>var html   = '<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml'">http://www.w3.org/1999/xhtml'</A>;
var mathml = '<A rel="nofollow" class="external free" href="http://www.w3.org/1998/Math/MathML'">http://www.w3.org/1998/Math/MathML'</A>;
var svg$1    = '<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg'">http://www.w3.org/2000/svg'</A>;
var xlink  = '<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xlink'">http://www.w3.org/1999/xlink'</A>;
var xml    = '<A rel="nofollow" class="external free" href="http://www.w3.org/XML/1998/namespace'">http://www.w3.org/XML/1998/namespace'</A>;
var xmlns  = '<A rel="nofollow" class="external free" href="http://www.w3.org/2000/xmlns'">http://www.w3.org/2000/xmlns'</A>;
</P><P>var namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };
</P><P>var createElement;
var matches;
var div;
var methodNames;
var unprefixed;
var prefixed;
var i;
var j;
var makeFunction;
</P><P>// Test for SVG support
if ( !svg ) {
	createElement = function ( type, ns, extend ) {
		if ( ns &amp;&amp; ns !== html ) {
			throw 'This browser does not support namespaces other than <A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See <A rel="nofollow" class="external free" href="http://docs.ractivejs.org/latest/svg-and-older-browsers">http://docs.ractivejs.org/latest/svg-and-older-browsers</A> for more information';
		}
</P><P>		return extend ?
			doc.createElement( type, extend ) :
			doc.createElement( type );
	};
} else {
	createElement = function ( type, ns, extend ) {
		if ( !ns || ns === html ) {
			return extend ?
				doc.createElement( type, extend ) :
				doc.createElement( type );
		}
</P><P>		return extend ?
			doc.createElementNS( ns, type, extend ) :
			doc.createElementNS( ns, type );
	};
}
</P><P>function createDocumentFragment () {
	return doc.createDocumentFragment();
}
</P><P>function getElement ( input ) {
	var output;
</P><P>	if ( !input || typeof input === 'boolean' ) { return; }
</P><P>	if ( !win || !doc || !input ) {
		return null;
	}
</P><P>	// We already have a DOM node - no work to do. (Duck typing alert!)
	if ( input.nodeType ) {
		return input;
	}
</P><P>	// Get node from string
	if ( typeof input === 'string' ) {
		// try ID first
		output = doc.getElementById( input );
</P><P>		// then as selector, if possible
		if ( !output &amp;&amp; doc.querySelector ) {
			output = doc.querySelector( input );
		}
</P><P>		// did it work?
		if ( output &amp;&amp; output.nodeType ) {
			return output;
		}
	}
</P><P>	// If we've been given a collection (jQuery, Zepto etc), extract the first item
	if ( input[0] &amp;&amp; input[0].nodeType ) {
		return input[0];
	}
</P><P>	return null;
}
</P><P>if ( !isClient ) {
	matches = null;
} else {
	div = createElement( 'div' );
	methodNames = [ 'matches', 'matchesSelector' ];
</P><P>	makeFunction = function ( methodName ) {
		return function ( node, selector ) {
			return node[ methodName ]( selector );
		};
	};
</P><P>	i = methodNames.length;
</P><P>	while ( i-- &amp;&amp; !matches ) {
		unprefixed = methodNames[i];
</P><P>		if ( div[ unprefixed ] ) {
			matches = makeFunction( unprefixed );
		} else {
			j = vendors.length;
			while ( j-- ) {
				prefixed = vendors[i] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
</P><P>				if ( div[ prefixed ] ) {
					matches = makeFunction( prefixed );
					break;
				}
			}
		}
	}
</P><P>	// IE8...
	if ( !matches ) {
		matches = function ( node, selector ) {
			var parentNode, i;
</P><P>			parentNode = node.parentNode;
</P><P>			if ( !parentNode ) {
</P>
				// empty dummy <DIV><P>				div.innerHTML = <I>;</I></P><P>				parentNode = div;
				node = node.cloneNode();
</P><P>				div.appendChild( node );
			}
</P><P>			var nodes = parentNode.querySelectorAll( selector );
</P><P>			i = nodes.length;
			while ( i-- ) {
				if ( nodes[i] === node ) {
					return true;
				}
			}
</P><P>			return false;
		};
	}
}
</P><P>function detachNode ( node ) {
	// stupid ie
	if ( node &amp;&amp; typeof node.parentNode !== 'unknown' &amp;&amp; node.parentNode ) { // eslint-disable-line valid-typeof
		node.parentNode.removeChild( node );
	}
</P><P>	return node;
}
</P><P>function safeToStringValue ( value ) {
	return ( value == null || !value.toString ) ? <I> : </I> + value;
}
</P><P>function safeAttributeString ( string ) {
	return safeToStringValue( string )
		.replace( /&amp;/g, '&amp;' )
		.replace( /&quot;/g, '&quot;' )
		.replace( /'/g, ''' );
}
</P><P>var insertHook = new Hook( 'insert' );
</P><P>function Ractive$insert ( target, anchor ) {
	if ( !this.fragment.rendered ) {
		// TODO create, and link to, documentation explaining this
		throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
	}
</P><P>	target = getElement( target );
	anchor = getElement( anchor ) || null;
</P><P>	if ( !target ) {
		throw new Error( 'You must specify a valid target to insert into' );
	}
</P><P>	target.insertBefore( this.detach(), anchor );
	this.el = target;
</P><P>	( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
	this.isDetached = false;
</P><P>	fireInsertHook( this );
}
</P><P>function fireInsertHook( ractive ) {
	insertHook.fire( ractive );
</P><P>	ractive.findAllComponents('*').forEach( function (child) {
		fireInsertHook( child.instance );
	});
}
</P><P>function link( there, here, options ) {
	var model;
	var target = ( options &amp;&amp; ( options.ractive || options.instance ) ) || this;
</P><P>	// may need to allow a mapping to resolve implicitly
	var sourcePath = splitKeypath( there );
	if ( !target.viewmodel.has( sourcePath[0] ) &amp;&amp; target.component ) {
		model = resolveReference( target.component.parentFragment, sourcePath[0] );
		model = model.joinAll( sourcePath.slice( 1 ) );
	}
</P><P>	var src = model || target.viewmodel.joinAll( sourcePath );
	var dest = this.viewmodel.joinAll( splitKeypath( here ), { lastLink: false });
</P><P>	if ( isUpstream( src, dest ) || isUpstream( dest, src ) ) {
		throw new Error( 'A keypath cannot be linked to itself.' );
	}
</P><P>	var promise = runloop.start();
</P><P>	dest.link( src, there );
</P><P>	runloop.end();
</P><P>	return promise;
}
</P><P>function isUpstream ( check, start ) {
	var model = start;
	while ( model ) {
		if ( model === check ) { return true; }
		model = model.target || model.parent;
	}
}
</P><P>var Observer = function Observer ( ractive, model, callback, options ) {
	this.context = options.context || ractive;
	this.callback = callback;
	this.ractive = ractive;
	this.keypath = options.keypath;
	this.options = options;
</P><P>	if ( model ) { this.resolved( model ); }
</P><P>	if ( typeof options.old === 'function' ) {
		this.oldContext = Object.create( ractive );
		this.old = options.old;
	} else {
		this.old = old;
	}
</P><P>	if ( options.init !== false ) {
		this.dirty = true;
		this.dispatch();
	} else {
		this.oldValue = this.old.call( this.oldContext, undefined, this.newValue );
	}
</P><P>	this.dirty = false;
};
</P><P>Observer.prototype.cancel = function cancel () {
	this.cancelled = true;
	if ( this.model ) {
		this.model.unregister( this );
	} else {
		this.resolver.unbind();
	}
	removeFromArray( this.ractive._observers, this );
};
</P><P>Observer.prototype.dispatch = function dispatch () {
	if ( !this.cancelled ) {
		this.callback.call( this.context, this.newValue, this.oldValue, this.keypath );
		this.oldValue = this.old.call( this.oldContext, this.oldValue, this.model ? this.model.get() : this.newValue );
		this.dirty = false;
	}
};
</P><P>Observer.prototype.handleChange = function handleChange () {
		var this$1 = this;
</P><P>	if ( !this.dirty ) {
		var newValue = this.model.get();
		if ( isEqual( newValue, this.oldValue ) ) { return; }
</P><P>		this.newValue = newValue;
</P><P>		if ( this.options.strict &amp;&amp; this.newValue === this.oldValue ) { return; }
</P><P>		runloop.addObserver( this, this.options.defer );
		this.dirty = true;
</P><P>		if ( this.options.once ) { runloop.scheduleTask( function () { return this$1.cancel(); } ); }
	}
};
</P><P>Observer.prototype.rebind = function rebind ( next, previous ) {
		var this$1 = this;
</P><P>	next = rebindMatch( this.keypath, next, previous );
	// TODO: set up a resolver if next is undefined?
	if ( next === this.model ) { return false; }
</P><P>	if ( this.model ) { this.model.unregister( this ); }
	if ( next ) { next.addShuffleTask( function () { return this$1.resolved( next ); } ); }
};
</P><P>Observer.prototype.resolved = function resolved ( model ) {
	this.model = model;
</P><P>	this.oldValue = undefined;
	this.newValue = model.get();
</P><P>	model.register( this );
};
</P><P>function old ( previous, next ) {
	return next;
}
</P><P>var star$1 = /\*+/g;
</P><P>var PatternObserver = function PatternObserver ( ractive, baseModel, keys, callback, options ) {
	var this$1 = this;
</P><P>	this.context = options.context || ractive;
	this.ractive = ractive;
	this.baseModel = baseModel;
	this.keys = keys;
	this.callback = callback;
</P><P>	var pattern = keys.join( '\\.' ).replace( star$1, '(.+)' );
	var baseKeypath = this.baseKeypath = baseModel.getKeypath( ractive );
	this.pattern = new RegExp( (&quot;^&quot; + (baseKeypath ? baseKeypath + '\\.' : <I>) + pattern + &quot;$&quot;) );</I>
	this.recursive = keys.length === 1 &amp;&amp; keys[0] === '**';
	if ( this.recursive ) { this.keys = [ '*' ]; }
</P><P>	this.oldValues = {};
	this.newValues = {};
</P><P>	this.defer = options.defer;
	this.once = options.once;
	this.strict = options.strict;
</P><P>	this.dirty = false;
	this.changed = [];
	this.partial = false;
	this.links = options.links;
</P><P>	var models = baseModel.findMatches( this.keys );
</P><P>	models.forEach( function (model) {
		this$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();
	});
</P><P>	if ( options.init !== false ) {
		this.dispatch();
	} else {
		this.oldValues = this.newValues;
	}
</P><P>	baseModel.registerPatternObserver( this );
};
</P><P>PatternObserver.prototype.cancel = function cancel () {
	this.baseModel.unregisterPatternObserver( this );
	removeFromArray( this.ractive._observers, this );
};
</P><P>PatternObserver.prototype.dispatch = function dispatch () {
		var this$1 = this;
</P><P>	var newValues = this.newValues;
	this.newValues = {};
	Object.keys( newValues ).forEach( function (keypath) {
		if ( this$1.newKeys &amp;&amp; !this$1.newKeys[ keypath ] ) { return; }
</P><P>		var newValue = newValues[ keypath ];
		var oldValue = this$1.oldValues[ keypath ];
</P><P>		if ( this$1.strict &amp;&amp; newValue === oldValue ) { return; }
		if ( isEqual( newValue, oldValue ) ) { return; }
</P><P>		var args = [ newValue, oldValue, keypath ];
		if ( keypath ) {
			var wildcards = this$1.pattern.exec( keypath );
			if ( wildcards ) {
				args = args.concat( wildcards.slice( 1 ) );
			}
		}
</P><P>		this$1.callback.apply( this$1.context, args );
	});
</P><P>	if ( this.partial ) {
		for ( var k in newValues ) {
			this$1.oldValues[k] = newValues[k];
		}
	} else {
		this.oldValues = newValues;
	}
</P><P>	this.newKeys = null;
	this.dirty = false;
};
</P><P>PatternObserver.prototype.notify = function notify ( key ) {
	this.changed.push( key );
};
</P><P>PatternObserver.prototype.shuffle = function shuffle ( newIndices ) {
		var this$1 = this;
</P><P>	if ( !Array.isArray( this.baseModel.value ) ) { return; }
</P><P>	var base = this.baseKeypath = this.baseModel.getKeypath( this.ractive );
	var max = this.baseModel.value.length;
	var suffix = this.keys.length &gt; 1 ? '.' + this.keys.slice( 1 ).join( '.' ) : <I>;</I></P><P>	this.newKeys = {};
	for ( var i = 0; i &lt; newIndices.length; i++ ) {
		if ( newIndices[ i ] === -1 || newIndices[ i ] === i ) { continue; }
		this$1.newKeys[ (base + &quot;.&quot; + i + suffix) ] = true;
	}
</P><P>	for ( var i$1 = newIndices.touchedFrom; i$1 &lt; max; i$1++ ) {
		this$1.newKeys[ (base + &quot;.&quot; + i$1 + suffix) ] = true;
	}
};
</P><P>PatternObserver.prototype.handleChange = function handleChange () {
		var this$1 = this;
</P><P>	if ( !this.dirty || this.changed.length ) {
		if ( !this.dirty ) { this.newValues = {}; }
</P><P>		if ( !this.changed.length ) {
			this.baseModel.findMatches( this.keys ).forEach( function (model) {
				var keypath = model.getKeypath( this$1.ractive );
				this$1.newValues[ keypath ] = model.get();
			});
			this.partial = false;
		} else {
			var count = 0;
</P><P>			if ( this.recursive ) {
				this.changed.forEach( function (keys) {
					var model = this$1.baseModel.joinAll( keys );
					if ( model.isLink &amp;&amp; !this$1.links ) { return; }
					count++;
					this$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();
				});
			} else {
				var ok = this.baseModel.isRoot ?
					this.changed.map( function (keys) { return keys.map( escapeKey ).join( '.' ); } ) :
					this.changed.map( function (keys) { return this$1.baseKeypath + '.' + keys.map( escapeKey ).join( '.' ); } );
</P><P>				this.baseModel.findMatches( this.keys ).forEach( function (model) {
					var keypath = model.getKeypath( this$1.ractive );
					var check = function (k) {
						return ( k.indexOf( keypath ) === 0 &amp;&amp; ( k.length === keypath.length || k[ keypath.length ] === '.' ) ) ||
							( keypath.indexOf( k ) === 0 &amp;&amp; ( k.length === keypath.length || keypath[ k.length ] === '.' ) );
</P><P>					};
</P><P>					// is this model on a changed keypath?
					if ( ok.filter( check ).length ) {
						count++;
						this$1.newValues[ keypath ] = model.get();
					}
				});
			}
</P><P>			// no valid change triggered, so bail to avoid breakage
			if ( !count ) { return; }
</P><P>			this.partial = true;
		}
</P><P>		runloop.addObserver( this, this.defer );
		this.dirty = true;
		this.changed.length = 0;
</P><P>		if ( this.once ) { this.cancel(); }
	}
};
</P><P>function negativeOne () {
	return -1;
}
</P><P>var ArrayObserver = function ArrayObserver ( ractive, model, callback, options ) {
	this.ractive = ractive;
	this.model = model;
	this.keypath = model.getKeypath();
	this.callback = callback;
	this.options = options;
</P><P>	this.pending = null;
</P><P>	model.register( this );
</P><P>	if ( options.init !== false ) {
		this.sliced = [];
		this.shuffle([]);
		this.dispatch();
	} else {
		this.sliced = this.slice();
	}
};
</P><P>ArrayObserver.prototype.cancel = function cancel () {
	this.model.unregister( this );
	removeFromArray( this.ractive._observers, this );
};
</P><P>ArrayObserver.prototype.dispatch = function dispatch () {
	this.callback( this.pending );
	this.pending = null;
	if ( this.options.once ) { this.cancel(); }
};
</P><P>ArrayObserver.prototype.handleChange = function handleChange () {
	if ( this.pending ) {
		// post-shuffle
		runloop.addObserver( this, this.options.defer );
	} else {
		// entire array changed
		this.shuffle( this.sliced.map( negativeOne ) );
		this.handleChange();
	}
};
</P><P>ArrayObserver.prototype.shuffle = function shuffle ( newIndices ) {
		var this$1 = this;
</P><P>	var newValue = this.slice();
</P><P>	var inserted = [];
	var deleted = [];
	var start;
</P><P>	var hadIndex = {};
</P><P>	newIndices.forEach( function ( newIndex, oldIndex ) {
		hadIndex[ newIndex ] = true;
</P><P>		if ( newIndex !== oldIndex &amp;&amp; start === undefined ) {
			start = oldIndex;
		}
</P><P>		if ( newIndex === -1 ) {
			deleted.push( this$1.sliced[ oldIndex ] );
		}
	});
</P><P>	if ( start === undefined ) { start = newIndices.length; }
</P><P>	var len = newValue.length;
	for ( var i = 0; i &lt; len; i += 1 ) {
		if ( !hadIndex[i] ) { inserted.push( newValue[i] ); }
	}
</P><P>	this.pending = { inserted: inserted, deleted: deleted, start: start };
	this.sliced = newValue;
};
</P><P>ArrayObserver.prototype.slice = function slice () {
	var value = this.model.get();
	return Array.isArray( value ) ? value.slice() : [];
};
</P><P>function observe ( keypath, callback, options ) {
	var this$1 = this;
</P><P>	var observers = [];
	var map;
	var opts;
</P><P>	if ( isObject( keypath ) ) {
		map = keypath;
		opts = callback || {};
	} else {
		if ( typeof keypath === 'function' ) {
			map = { <I>: keypath };</I>
			opts = callback || {};
		} else {
			map = {};
			map[ keypath ] = callback;
			opts = options || {};
		}
	}
</P><P>	var silent = false;
	Object.keys( map ).forEach( function (keypath) {
		var callback = map[ keypath ];
		var caller = function () {
			var args = [], len = arguments.length;
			while ( len-- ) args[ len ] = arguments[ len ];
</P><P>			if ( silent ) { return; }
			return callback.apply( this, args );
		};
</P><P>		var keypaths = keypath.split( ' ' );
		if ( keypaths.length &gt; 1 ) { keypaths = keypaths.filter( function (k) { return k; } ); }
</P><P>		keypaths.forEach( function (keypath) {
			opts.keypath = keypath;
			var observer = createObserver( this$1, keypath, caller, opts );
			if ( observer ) { observers.push( observer ); }
		});
	});
</P><P>	// add observers to the Ractive instance, so they can be
	// cancelled on ractive.teardown()
	this._observers.push.apply( this._observers, observers );
</P><P>	return {
		cancel: function () { return observers.forEach( function (o) { return o.cancel(); } ); },
		isSilenced: function () { return silent; },
		silence: function () { return silent = true; },
		resume: function () { return silent = false; }
	};
}
</P><P>function createObserver ( ractive, keypath, callback, options ) {
	var keys = splitKeypath( keypath );
	var wildcardIndex = keys.indexOf( '*' );
	if ( !~wildcardIndex ) { wildcardIndex = keys.indexOf( '**' ); }
</P><P>	options.fragment = options.fragment || ractive.fragment;
</P><P>	var model;
	if ( !options.fragment ) {
		model = ractive.viewmodel.joinKey( keys[0] );
	} else {
		// .*.whatever relative wildcard is a special case because splitkeypath doesn't handle the leading .
		if ( ~keys[0].indexOf( '.*' ) ) {
			model = options.fragment.findContext();
			wildcardIndex = 0;
			keys[0] = keys[0].slice( 1 );
		} else {
			model = wildcardIndex === 0 ? options.fragment.findContext() : resolveReference( options.fragment, keys[0] );
		}
	}
</P><P>	// the model may not exist key
	if ( !model ) { model = ractive.viewmodel.joinKey( keys[0] ); }
</P><P>	if ( !~wildcardIndex ) {
		model = model.joinAll( keys.slice( 1 ) );
		if ( options.array ) {
			return new ArrayObserver( ractive, model, callback, options );
		} else {
			return new Observer( ractive, model, callback, options );
		}
	} else {
		var double = keys.indexOf( '**' );
		if ( ~double ) {
			if ( double + 1 !== keys.length || ~keys.indexOf( '*' ) ) {
				warnOnceIfDebug( &quot;Recursive observers may only specify a single '**' at the end of the path.&quot; );
				return;
			}
		}
</P><P>		model = model.joinAll( keys.slice( 1, wildcardIndex ) );
</P><P>		return new PatternObserver( ractive, model, keys.slice( wildcardIndex ), callback, options );
	}
}
</P><P>var onceOptions = { init: false, once: true };
</P><P>function observeOnce ( keypath, callback, options ) {
	if ( isObject( keypath ) || typeof keypath === 'function' ) {
		options = Object.assign( callback || {}, onceOptions );
		return this.observe( keypath, options );
	}
</P><P>	options = Object.assign( options || {}, onceOptions );
	return this.observe( keypath, callback, options );
}
</P><P>var trim = function (str) { return str.trim(); };
</P><P>var notEmptyString = function (str) { return str !== <I>; };</I></P><P>function Ractive$off ( eventName, callback ) {
	var this$1 = this;
</P><P>	// if no event is specified, remove _all_ event listeners
	if ( !eventName ) {
		this._subs = {};
	} else {
		// Handle multiple space-separated event names
		var eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
</P><P>		eventNames.forEach( function (event) {
			var subs = this$1._subs[ event ];
			// if given a specific callback to remove, remove only it
			if ( subs &amp;&amp; callback ) {
				var entry = subs.find( function (s) { return s.callback === callback; } );
				if ( entry ) {
					removeFromArray( subs, entry );
					entry.off = true;
</P><P>					if ( event.indexOf( '.' ) ) { this$1._nsSubs--; }
				}
			}
</P><P>			// otherwise, remove all listeners for this event
			else if ( subs ) {
				if ( event.indexOf( '.' ) ) { this$1._nsSubs -= subs.length; }
				subs.length = 0;
			}
		});
	}
</P><P>	return this;
}
</P><P>function Ractive$on ( eventName, callback ) {
	var this$1 = this;
</P><P>	// eventName may already be a map
	var map = typeof eventName === 'object' ? eventName : {};
	// or it may be a string along with a callback
	if ( typeof eventName === 'string' ) { map[ eventName ] = callback; }
</P><P>	var silent = false;
	var events = [];
</P><P>	var loop = function ( k ) {
		var callback$1 = map[k];
		var caller = function () {
			var args = [], len = arguments.length;
			while ( len-- ) args[ len ] = arguments[ len ];
</P><P>			if ( !silent ) { return callback$1.apply( this, args ); }
		};
		var entry = {
			callback: callback$1,
			handler: caller
		};
</P><P>		if ( map.hasOwnProperty( k ) ) {
			var names = k.split( ' ' ).map( trim ).filter( notEmptyString );
			names.forEach( function (n) {
				( this$1._subs[ n ] || ( this$1._subs[ n ] = [] ) ).push( entry );
				if ( n.indexOf( '.' ) ) { this$1._nsSubs++; }
				events.push( [ n, entry ] );
			});
		}
	};
</P><P>	for ( var k in map ) loop( k );
</P><P>	return {
		cancel: function () { return events.forEach( function (e) { return this$1.off( e[0], e[1].callback ); } ); },
		isSilenced: function () { return silent; },
		silence: function () { return silent = true; },
		resume: function () { return silent = false; }
	};
}
</P><P>function Ractive$once ( eventName, handler ) {
	var listener = this.on( eventName, function () {
		handler.apply( this, arguments );
		listener.cancel();
	});
</P><P>	// so we can still do listener.cancel() manually
	return listener;
}
</P><P>var pop = makeArrayMethod( 'pop' ).path;
</P><P>var push = makeArrayMethod( 'push' ).path;
</P><P>function readLink ( keypath, options ) {
	if ( options === void 0 ) options = {};
</P><P>	var path = splitKeypath( keypath );
</P><P>	if ( this.viewmodel.has( path[0] ) ) {
		var model = this.viewmodel.joinAll( path );
</P><P>		if ( !model.isLink ) { return; }
</P><P>		while ( ( model = model.target ) &amp;&amp; options.canonical !== false ) {
			if ( !model.isLink ) { break; }
		}
</P><P>		if ( model ) { return { ractive: model.root.ractive, keypath: model.getKeypath() }; }
	}
}
</P><P>var PREFIX = '/* Ractive.js component styles */';
</P><P>// Holds current definitions of styles.
var styleDefinitions = [];
</P><P>// Flag to tell if we need to update the CSS
var isDirty = false;
</P><P>// These only make sense on the browser. See additional setup below.
var styleElement = null;
var useCssText = null;
</P><P>function addCSS( styleDefinition ) {
	styleDefinitions.push( styleDefinition );
	isDirty = true;
}
</P><P>function applyCSS() {
</P><P>	// Apply only seems to make sense when we're in the DOM. Server-side renders
	// can call toCSS to get the updated CSS.
	if ( !doc || !isDirty ) { return; }
</P><P>	if ( useCssText ) {
		styleElement.styleSheet.cssText = getCSS( null );
	} else {
		styleElement.innerHTML = getCSS( null );
	}
</P><P>	isDirty = false;
}
</P><P>function getCSS( cssIds ) {
</P><P>	var filteredStyleDefinitions = cssIds ? styleDefinitions.filter( function (style) { return ~cssIds.indexOf( style.id ); } ) : styleDefinitions;
</P><P>	return filteredStyleDefinitions.reduce( function ( styles, style ) { return (styles + &quot;\n\n/* {&quot; + (style.id) + &quot;} */\n&quot; + (style.styles)); }, PREFIX );
</P><P>}
</P><P>// If we're on the browser, additional setup needed.
if ( doc &amp;&amp; ( !styleElement || !styleElement.parentNode ) ) {
</P><P>	styleElement = doc.createElement( 'style' );
	styleElement.type = 'text/css';
</P><P>	doc.getElementsByTagName( 'head' )[ 0 ].appendChild( styleElement );
</P><P>	useCssText = !!styleElement.styleSheet;
}
</P><P>function fillGaps ( target ) {
	var sources = [], len = arguments.length - 1;
	while ( len-- &gt; 0 ) sources[ len ] = arguments[ len + 1 ];
</P><P>
	for (var i = 0; i &lt; sources.length; i++){
		var source = sources[i];
		for ( var key in source ) {
			// Source can be a prototype-less object.
			if ( key in target || !Object.prototype.hasOwnProperty.call( source, key ) ) { continue; }
			target[ key ] = source[ key ];
		}
	}
</P><P>	return target;
}
</P><P>function toPairs ( obj ) {
	if ( obj === void 0 ) obj = {};
</P><P>	var pairs = [];
	for ( var key in obj ) {
		// Source can be a prototype-less object.
		if ( !Object.prototype.hasOwnProperty.call( obj, key ) ) { continue; }
		pairs.push( [ key, obj[ key ] ] );
	}
	return pairs;
}
</P><P>var adaptConfigurator = {
	extend: function ( Parent, proto, options ) {
		proto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );
	},
</P><P>	init: function init () {}
};
</P><P>var remove = /\/\*(?:[\s\S]*?)\*\//g;
var escape = /url\(\s*(['&quot;])(?:\\[\s\S]|(?!\1).)*\1\s*\)|url\((?:\\[\s\S]|[^)])*\)|(['&quot;])(?:\\[\s\S]|(?!\2).)*\2/gi;
var value = /\0(\d+)/g;
</P><P>// Removes comments and strings from the given CSS to make it easier to parse.
// Callback receives the cleaned CSS and a function which can be used to put
// the removed strings back in place after parsing is done.
var cleanCss = function ( css, callback, additionalReplaceRules ) {
	if ( additionalReplaceRules === void 0 ) additionalReplaceRules = [];
</P><P>var values = [];
	var reconstruct = function (css) { return css.replace( value, function ( match, n ) { return values[ n ]; } ); };
	css = css.replace( escape, function (match) { return (&quot;\u0000&quot; + (values.push( match ) - 1)); }).replace( remove, <I> );</I></P><P>	additionalReplaceRules.forEach( function ( pattern ) {
		css = css.replace( pattern, function (match) { return (&quot;\u0000&quot; + (values.push( match ) - 1)); } );
	});
</P><P>	return callback( css, reconstruct );
};
</P><P>var selectorsPattern = /(?:^|\}|\{)\s*([^\{\}\0]+)\s*(?=\{)/g;
var keyframesDeclarationPattern = /@keyframes\s+[^\{\}]+\s*\{(?:[^{}]+|\{[^{}]+})*}/gi;
var selectorUnitPattern = /((?:(?:\<A href="/wiki/index.php?title=%5E%5C&amp;action=edit&amp;redlink=1" class="new" title="^\ (page does not exist)">^\</A>+\])|(?:[^\s\+\&gt;~:]))+)((?:::?[^\s\+\&gt;\~\(:]+(?:\([^\)]+\))?)*\s*[\s\+\&gt;\~]?)\s*/g;
var excludePattern = /^(?:@|\d+%)/;
var dataRvcGuidPattern = /\[data-ractive-css~=&quot;\{[a-z0-9-]+\}&quot;]/g;
</P><P>function trim$1 ( str ) {
	return str.trim();
}
</P><P>function extractString ( unit ) {
	return unit.str;
}
</P><P>function transformSelector ( selector, parent ) {
	var selectorUnits = [];
	var match;
</P><P>	while ( match = selectorUnitPattern.exec( selector ) ) {
		selectorUnits.push({
			str: match[0],
			base: match[1],
			modifiers: match[2]
		});
	}
</P><P>	// For each simple selector within the selector, we need to create a version
	// that a) combines with the id, and b) is inside the id
	var base = selectorUnits.map( extractString );
</P><P>	var transformed = [];
	var i = selectorUnits.length;
</P><P>	while ( i-- ) {
		var appended = base.slice();
</P><P>		// Pseudo-selectors should go after the attribute selector
		var unit = selectorUnits[i];
		appended[i] = unit.base + parent + unit.modifiers || <I>;</I></P><P>		var prepended = base.slice();
		prepended[i] = parent + ' ' + prepended[i];
</P><P>		transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
	}
</P><P>	return transformed.join( ', ' );
}
</P><P>function transformCss ( css, id ) {
	var dataAttr = &quot;[data-ractive-css~=\&quot;{&quot; + id + &quot;}\&quot;]&quot;;
</P><P>	var transformed;
</P><P>	if ( dataRvcGuidPattern.test( css ) ) {
		transformed = css.replace( dataRvcGuidPattern, dataAttr );
	} else {
		transformed = cleanCss( css, function ( css, reconstruct ) {
			css = css.replace( selectorsPattern, function ( match, $1 ) {
				// don't transform at-rules and keyframe declarations
				if ( excludePattern.test( $1 ) ) { return match; }
</P><P>				var selectors = $1.split( ',' ).map( trim$1 );
				var transformed = selectors
					.map( function (selector) { return transformSelector( selector, dataAttr ); } )
					.join( ', ' ) + ' ';
</P><P>				return match.replace( $1, transformed );
			});
</P><P>			return reconstruct( css );
		}, [ keyframesDeclarationPattern ]);
	}
</P><P>	return transformed;
}
</P><P>function s4() {
	return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
}
</P><P>function uuid() {
	return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
}
</P><P>var hasCurly = /\{/;
var cssConfigurator = {
	name: 'css',
</P><P>	// Called when creating a new component definition
	extend: function ( Parent, proto, options ) {
		if ( !options.css ) { return; }
		var css = typeof options.css === 'string' &amp;&amp; !hasCurly.test( options.css ) ?
			( getElement( options.css ) || options.css ) :
			options.css;
</P><P>		var id = options.cssId || uuid();
</P><P>		if ( typeof css === 'object' ) {
			css = 'textContent' in css ? css.textContent : css.innerHTML;
		}
</P><P>		if ( !css ) { return; }
</P><P>		var styles = options.noCssTransform ? css : transformCss( css, id );
</P><P>		proto.cssId = id;
</P><P>		addCSS( { id: id, styles: styles } );
	},
</P><P>	// Called when creating a new component instance
	init: function ( Parent, target, options ) {
		if ( !options.css ) { return; }
</P><P>		warnIfDebug( &quot;\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\n\nconst Component = Ractive.extend({\n\t...\n\tcss: '/* your css */',\n\t...\n});\n\nconst componentInstance = new Component({ ... })\n\t\t&quot; );
	}
</P><P>};
</P><P>function validate ( data ) {
	// Warn if userOptions.data is a non-POJO
	if ( data &amp;&amp; data.constructor !== Object ) {
		if ( typeof data === 'function' ) {
			// TODO do we need to support this in the new Ractive() case?
		} else if ( typeof data !== 'object' ) {
			fatal( (&quot;data option must be an object or a function, `&quot; + data + &quot;` is not valid&quot;) );
		} else {
			warnIfDebug( 'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged' );
		}
	}
}
</P><P>var dataConfigurator = {
	name: 'data',
</P><P>	extend: function ( Parent, proto, options ) {
		var key;
		var value;
</P><P>		// check for non-primitives, which could cause mutation-related bugs
		if ( options.data &amp;&amp; isObject( options.data ) ) {
			for ( key in options.data ) {
				value = options.data[ key ];
</P><P>				if ( value &amp;&amp; typeof value === 'object' ) {
					if ( isObject( value ) || Array.isArray( value ) ) {
						warnIfDebug( &quot;Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }&quot; );
					}
				}
			}
		}
</P><P>		proto.data = combine$1( proto.data, options.data );
	},
</P><P>	init: function ( Parent, ractive, options ) {
		var result = combine$1( Parent.prototype.data, options.data );
</P><P>		if ( typeof result === 'function' ) { result = result.call( ractive ); }
</P><P>		// bind functions to the ractive instance at the top level,
		// unless it's a non-POJO (in which case alarm bells should ring)
		if ( result &amp;&amp; result.constructor === Object ) {
			for ( var prop in result ) {
				if ( typeof result[ prop ] === 'function' ) {
					var value = result[ prop ];
					result[ prop ] = bind$1( value, ractive );
					result[ prop ]._r_unbound = value;
				}
			}
		}
</P><P>		return result || {};
	},
</P><P>	reset: function reset ( ractive ) {
		var result = this.init( ractive.constructor, ractive, ractive.viewmodel );
		ractive.viewmodel.root.set( result );
		return true;
	}
};
</P><P>function combine$1 ( parentValue, childValue ) {
	validate( childValue );
</P><P>	var parentIsFn = typeof parentValue === 'function';
	var childIsFn = typeof childValue === 'function';
</P><P>	// Very important, otherwise child instance can become
	// the default data object on Ractive or a component.
	// then ractive.set() ends up setting on the prototype!
	if ( !childValue &amp;&amp; !parentIsFn ) {
		childValue = {};
	}
</P><P>	// Fast path, where we just need to copy properties from
	// parent to child
	if ( !parentIsFn &amp;&amp; !childIsFn ) {
		return fromProperties( childValue, parentValue );
	}
</P><P>	return function () {
		var child = childIsFn ? callDataFunction( childValue, this ) : childValue;
		var parent = parentIsFn ? callDataFunction( parentValue, this ) : parentValue;
</P><P>		return fromProperties( child, parent );
	};
}
</P><P>function callDataFunction ( fn, context ) {
	var data = fn.call( context );
</P><P>	if ( !data ) { return; }
</P><P>	if ( typeof data !== 'object' ) {
		fatal( 'Data function must return an object' );
	}
</P><P>	if ( data.constructor !== Object ) {
		warnOnceIfDebug( 'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged' );
	}
</P><P>	return data;
}
</P><P>function fromProperties ( primary, secondary ) {
	if ( primary &amp;&amp; secondary ) {
		for ( var key in secondary ) {
			if ( !( key in primary ) ) {
				primary[ key ] = secondary[ key ];
			}
		}
</P><P>		return primary;
	}
</P><P>	return primary || secondary;
}
</P><P>var TEMPLATE_VERSION = 4;
</P><P>var pattern = /\$\{([^\}]+)\}/g;
</P><P>function fromExpression ( body, length ) {
	if ( length === void 0 ) length = 0;
</P><P>	var args = new Array( length );
</P><P>	while ( length-- ) {
		args[length] = &quot;_&quot; + length;
	}
</P><P>	// Functions created directly with new Function() look like this:
	//     function anonymous (_0 /**/) { return _0*2 }
	//
	// With this workaround, we get a little more compact:
	//     function (_0){return _0*2}
	return new Function( [], (&quot;return function (&quot; + (args.join(',')) + &quot;){return(&quot; + body + &quot;);};&quot;) )();
}
</P><P>function fromComputationString ( str, bindTo ) {
	var hasThis;
</P><P>	var functionBody = 'return (' + str.replace( pattern, function ( match, keypath ) {
		hasThis = true;
		return (&quot;__ractive.get(\&quot;&quot; + keypath + &quot;\&quot;)&quot;);
	}) + ');';
</P><P>	if ( hasThis ) { functionBody = &quot;var __ractive = this; &quot; + functionBody; }
	var fn = new Function( functionBody );
	return hasThis ? fn.bind( bindTo ) : fn;
}
</P><P>var functions = Object.create( null );
</P><P>function getFunction ( str, i ) {
	if ( functions[ str ] ) { return functions[ str ]; }
	return functions[ str ] = createFunction( str, i );
}
</P><P>function addFunctions( template ) {
	if ( !template ) { return; }
</P><P>	var exp = template.e;
</P><P>	if ( !exp ) { return; }
</P><P>	Object.keys( exp ).forEach( function ( str ) {
		if ( functions[ str ] ) { return; }
		functions[ str ] = exp[ str ];
	});
}
</P><P>var leadingWhitespace = /^\s+/;
</P><P>var ParseError = function ( message ) {
	this.name = 'ParseError';
	this.message = message;
	try {
		throw new Error(message);
	} catch (e) {
		this.stack = e.stack;
	}
};
</P><P>ParseError.prototype = Error.prototype;
</P><P>var Parser = function ( str, options ) {
	var item;
	var lineStart = 0;
</P><P>	this.str = str;
	this.options = options || {};
	this.pos = 0;
</P><P>	this.lines = this.str.split( '\n' );
	this.lineEnds = this.lines.map( function (line) {
		var lineEnd = lineStart + line.length + 1; // +1 for the newline
</P><P>		lineStart = lineEnd;
		return lineEnd;
	}, 0 );
</P><P>	// Custom init logic
	if ( this.init ) { this.init( str, options ); }
</P><P>	var items = [];
</P><P>	while ( ( this.pos &lt; this.str.length ) &amp;&amp; ( item = this.read() ) ) {
		items.push( item );
	}
</P><P>	this.leftover = this.remaining();
	this.result = this.postProcess ? this.postProcess( items, options ) : items;
};
</P><P>Parser.prototype = {
	read: function read ( converters ) {
		var this$1 = this;
</P><P>		var i, item;
</P><P>		if ( !converters ) { converters = this.converters; }
</P><P>		var pos = this.pos;
</P><P>		var len = converters.length;
		for ( i = 0; i &lt; len; i += 1 ) {
			this$1.pos = pos; // reset for each attempt
</P><P>			if ( item = converters[i]( this$1 ) ) {
				return item;
			}
		}
</P><P>		return null;
	},
</P><P>	getContextMessage: function getContextMessage ( pos, message ) {
		var ref = this.getLinePos( pos );
		var lineNum = ref[0];
		var columnNum = ref[1];
		if ( this.options.contextLines === -1 ) {
			return [ lineNum, columnNum, (message + &quot; at line &quot; + lineNum + &quot; character &quot; + columnNum) ];
		}
</P><P>		var line = this.lines[ lineNum - 1 ];
</P><P>		var contextUp = <I>;</I>
		var contextDown = <I>;</I>
		if ( this.options.contextLines ) {
			var start = lineNum - 1 - this.options.contextLines &lt; 0 ? 0 : lineNum - 1 - this.options.contextLines;
			contextUp = this.lines.slice( start, lineNum - 1 - start ).join( '\n' ).replace( /\t/g, '  ' );
			contextDown = this.lines.slice( lineNum, lineNum + this.options.contextLines ).join( '\n' ).replace( /\t/g, '  ' );
			if ( contextUp ) {
				contextUp += '\n';
			}
			if ( contextDown ) {
				contextDown = '\n' + contextDown;
			}
		}
</P><P>		var numTabs = 0;
		var annotation = contextUp + line.replace( /\t/g, function ( match, char ) {
			if ( char &lt; columnNum ) {
				numTabs += 1;
			}
</P><P>			return '  ';
		}) + '\n' + new Array( columnNum + numTabs ).join( ' ' ) + '^----' + contextDown;</P><P>		return [ lineNum, columnNum, (message + &quot; at line &quot; + lineNum + &quot; character &quot; + columnNum + &quot;:\n&quot; + annotation) ];
	},
</P><P>	getLinePos: function getLinePos ( char ) {
		var this$1 = this;
</P><P>		var lineNum = 0;
		var lineStart = 0;
</P><P>		while ( char &gt;= this.lineEnds[ lineNum ] ) {
			lineStart = this$1.lineEnds[ lineNum ];
			lineNum += 1;
		}
</P><P>		var columnNum = char - lineStart;
		return [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!
	},
</P><P>	error: function error ( message ) {
		var ref = this.getContextMessage( this.pos, message );
		var lineNum = ref[0];
		var columnNum = ref[1];
		var msg = ref[2];
</P><P>		var error = new ParseError( msg );
</P><P>		error.line = lineNum;
		error.character = columnNum;
		error.shortMessage = message;
</P><P>		throw error;
	},
</P><P>	matchString: function matchString ( string ) {
		if ( this.str.substr( this.pos, string.length ) === string ) {
			this.pos += string.length;
			return string;
		}
	},
</P><P>	matchPattern: function matchPattern ( pattern ) {
		var match;
</P><P>		if ( match = pattern.exec( this.remaining() ) ) {
			this.pos += match[0].length;
			return match[1] || match[0];
		}
	},
</P><P>	allowWhitespace: function allowWhitespace () {
		this.matchPattern( leadingWhitespace );
	},
</P><P>	remaining: function remaining () {
		return this.str.substring( this.pos );
	},
</P><P>	nextChar: function nextChar () {
		return this.str.charAt( this.pos );
	},
</P><P>	warn: function warn$$1 ( message ) {
		var msg = this.getContextMessage( this.pos, message )[2];
</P><P>		warnIfDebug( msg );
	}
};
</P><P>Parser.extend = function ( proto ) {
	var Parent = this;
	var Child = function ( str, options ) {
		Parser.call( this, str, options );
	};
</P><P>	Child.prototype = Object.create( Parent.prototype );
</P><P>	for ( var key in proto ) {
		if ( proto.hasOwnProperty( key ) ) {
			Child.prototype[ key ] = proto[ key ];
		}
	}
</P><P>	Child.extend = Parser.extend;
	return Child;
};
</P><P>var delimiterChangePattern = /^[^\s=]+/;
var whitespacePattern = /^\s+/;
</P><P>function readDelimiterChange ( parser ) {
	if ( !parser.matchString( '=' ) ) {
		return null;
	}
</P><P>	var start = parser.pos;
</P><P>	// allow whitespace before new opening delimiter
	parser.allowWhitespace();
</P><P>	var opening = parser.matchPattern( delimiterChangePattern );
	if ( !opening ) {
		parser.pos = start;
		return null;
	}
</P><P>	// allow whitespace (in fact, it's necessary...)
	if ( !parser.matchPattern( whitespacePattern ) ) {
		return null;
	}
</P><P>	var closing = parser.matchPattern( delimiterChangePattern );
	if ( !closing ) {
		parser.pos = start;
		return null;
	}
</P><P>	// allow whitespace before closing '='
	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( '=' ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	return [ opening, closing ];
}
</P><P>var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;
</P><P>function readNumberLiteral ( parser ) {
	var result;
</P><P>	if ( result = parser.matchPattern( regexpPattern ) ) {
		return {
			t: REGEXP_LITERAL,
			v: result
		};
	}
</P><P>	return null;
}
</P><P>var pattern$1 = /[-/\\^$*+?.()|[\]{}]/g;
</P><P>function escapeRegExp ( str ) {
	return str.replace( pattern$1, '\\$&amp;' );
}
</P><P>var regExpCache = {};
</P><P>var getLowestIndex = function ( haystack, needles ) {
	return haystack.search( regExpCache[needles.join()] || ( regExpCache[needles.join()] = new RegExp( needles.map( escapeRegExp ).join( '|' ) ) ) );
};
</P><P>// <A rel="nofollow" class="external free" href="https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316">https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316</A>
var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
</P><P>var htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830	};
var controlCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];
var entityPattern = new RegExp( '&amp;(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );
var codePointSupport = typeof String.fromCodePoint === 'function';
var codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;
</P><P>function decodeCharacterReferences ( html ) {
	return html.replace( entityPattern, function ( match, entity ) {
		var code;
</P><P>		// Handle named entities
		if ( entity[0] !== '#' ) {
			code = htmlEntities[ entity ];
		} else if ( entity[1] === 'x' ) {
			code = parseInt( entity.substring( 2 ), 16 );
		} else {
			code = parseInt( entity.substring( 1 ), 10 );
		}
</P><P>		if ( !code ) {
			return match;
		}
</P><P>		return codeToChar( validateCode( code ) );
	});
}
</P><P>var lessThan = /&lt;/g;
var greaterThan = /&gt;/g;
var amp = /&amp;/g;
var invalid = 65533;
</P><P>function escapeHtml ( str ) {
	return str
		.replace( amp, '&amp;' )
		.replace( lessThan, '&lt;' )
		.replace( greaterThan, '&gt;' );
}
</P><P>// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
// code points with alternatives in some cases - since we're bypassing that mechanism, we need
// to replace them ourselves
//
// Source: <A rel="nofollow" class="external free" href="http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters">http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters</A>
function validateCode ( code ) {
	if ( !code ) {
		return invalid;
	}
</P><P>	// line feed becomes generic whitespace
	if ( code === 10 ) {
		return 32;
	}
</P><P>	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
	if ( code &lt; 128 ) {
		return code;
	}
</P><P>	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
	// to correct the mistake or we'll end up with missing € signs and so on
	if ( code &lt;= 159 ) {
		return controlCharacters[ code - 128 ];
	}
</P><P>	// basic multilingual plane
	if ( code &lt; 55296 ) {
		return code;
	}
</P><P>	// UTF-16 surrogate halves
	if ( code &lt;= 57343 ) {
		return invalid;
	}
</P><P>	// rest of the basic multilingual plane
	if ( code &lt;= 65535 ) {
		return code;
	} else if ( !codePointSupport ) {
		return invalid;
	}
</P><P>	// supplementary multilingual plane 0x10000 - 0x1ffff
	if ( code &gt;= 65536 &amp;&amp; code &lt;= 131071 ) {
		return code;
	}
</P><P>	// supplementary ideographic plane 0x20000 - 0x2ffff
	if ( code &gt;= 131072 &amp;&amp; code &lt;= 196607 ) {
		return code;
	}
</P><P>	return invalid;
}
</P><P>var expectedExpression = 'Expected a JavaScript expression';
var expectedParen = 'Expected closing paren';
</P><P>// bulletproof number regex from <A rel="nofollow" class="external free" href="https://gist.github.com/Rich-Harris/7544330">https://gist.github.com/Rich-Harris/7544330</A>
var numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
</P><P>function readNumberLiteral$1 ( parser ) {
	var result;
</P><P>	if ( result = parser.matchPattern( numberPattern ) ) {
		return {
			t: NUMBER_LITERAL,
			v: result
		};
	}
</P><P>	return null;
}
</P><P>function readBooleanLiteral ( parser ) {
	var remaining = parser.remaining();
</P><P>	if ( remaining.substr( 0, 4 ) === 'true' ) {
		parser.pos += 4;
		return {
			t: BOOLEAN_LITERAL,
			v: 'true'
		};
	}
</P><P>	if ( remaining.substr( 0, 5 ) === 'false' ) {
		parser.pos += 5;
		return {
			t: BOOLEAN_LITERAL,
			v: 'false'
		};
	}
</P><P>	return null;
}
</P><P>// Match one or more characters until: &quot;, ', \, or EOL/EOF.
// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
var stringMiddlePattern = /^(?=.)[^&quot;'\\]+?(?:(?!.)|(?=[&quot;'\\]))/;
</P><P>// Match one escape sequence, including the backslash.
var escapeSequencePattern = /^\\(?:[`'&quot;\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
</P><P>// Match one ES5 line continuation (backslash + line terminator).
var lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
</P><P>// Helper for defining getDoubleQuotedString and getSingleQuotedString.
var makeQuotedStringMatcher = function ( okQuote ) {
	return function ( parser ) {
		var literal = '&quot;';
		var done = false;
		var next;
</P><P>		while ( !done ) {
			next = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||
				parser.matchString( okQuote ) );
			if ( next ) {
				if ( next === &quot;\&quot;&quot; ) {
					literal += &quot;\\\&quot;&quot;;
				} else if ( next === &quot;\\'&quot; ) {
					literal += &quot;'&quot;;
				} else {
					literal += next;
				}
			} else {
				next = parser.matchPattern( lineContinuationPattern );
				if ( next ) {
					// convert \(newline-like) into a \u escape, which is allowed in JSON
					literal += '\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );
				} else {
					done = true;
				}
			}
		}
</P><P>		literal += '&quot;';
</P><P>		// use JSON.parse to interpret escapes
		return JSON.parse( literal );
	};
};
</P><P>var singleMatcher = makeQuotedStringMatcher( &quot;\&quot;&quot; );
var doubleMatcher = makeQuotedStringMatcher( &quot;'&quot; );
</P><P>var readStringLiteral = function ( parser ) {
	var start = parser.pos;
	var quote = parser.matchString( &quot;'&quot; ) || parser.matchString( &quot;\&quot;&quot; );
</P><P>	if ( quote ) {
		var string = ( quote === &quot;'&quot; ? singleMatcher : doubleMatcher )( parser );
</P><P>		if ( !parser.matchString( quote ) ) {
			parser.pos = start;
			return null;
		}
</P><P>		return {
			t: STRING_LITERAL,
			v: string
		};
	}
</P><P>	return null;
};
</P><P>// Match one or more characters until: &quot;, ', or \
var stringMiddlePattern$1 = /^[^`&quot;\\\$]+?(?:(?=[`&quot;\\\$]))/;
</P><P>var escapes = /[\r\n\t\b\f]/g;
function getString ( literal ) {
	return JSON.parse( (&quot;\&quot;&quot; + (literal.replace( escapes, escapeChar )) + &quot;\&quot;&quot;) );
}
</P><P>function escapeChar ( c ) {
	switch ( c ) {
		case '\n': return '\\n';
		case '\r': return '\\r';
		case '\t': return '\\t';
		case '\b': return '\\b';
		case '\f': return '\\f';
	}
}
</P><P>function readTemplateStringLiteral ( parser ) {
	if ( !parser.matchString( '`' ) ) { return null; }
</P><P>	var literal = <I>;</I>
	var done = false;
	var next;
	var parts = [];
</P><P>	while ( !done ) {
		next = parser.matchPattern( stringMiddlePattern$1 ) || parser.matchPattern( escapeSequencePattern ) ||
			parser.matchString( '$' ) || parser.matchString( '&quot;' );
		if ( next ) {
			if ( next === &quot;\&quot;&quot; ) {
				literal += &quot;\\\&quot;&quot;;
			} else if ( next === '\\`' ) {
				literal += '`';
			} else if ( next === '$' ) {
				if ( parser.matchString( '{' ) ) {
					parts.push({ t: STRING_LITERAL, v: getString( literal ) });
					literal = <I>;</I></P><P>					parser.allowWhitespace();
					var expr = readExpression( parser );
</P><P>					if ( !expr ) { parser.error( 'Expected valid expression' ); }
</P><P>					parts.push({ t: BRACKETED, x: expr });
</P><P>					parser.allowWhitespace();
					if ( !parser.matchString( '}' ) ) { parser.error( &quot;Expected closing '}' after interpolated expression&quot; ); }
				} else {
					literal += '$';
				}
			} else {
				literal += next;
			}
		} else {
			next = parser.matchPattern( lineContinuationPattern );
			if ( next ) {
				// convert \(newline-like) into a \u escape, which is allowed in JSON
				literal += '\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );
			} else {
				done = true;
			}
		}
	}
</P><P>	if ( literal.length ) { parts.push({ t: STRING_LITERAL, v: getString( literal ) }); }
</P><P>	if ( !parser.matchString( '`' ) ) { parser.error( &quot;Expected closing '`'&quot; ); }
</P><P>	if ( parts.length === 1 ) {
		return parts[0];
	} else {
		var result = parts.pop();
		var part;
</P><P>		while ( part = parts.pop() ) {
			result = {
				t: INFIX_OPERATOR,
				s: '+',
				o: [ part, result ]
			};
		}
</P><P>		return {
			t: BRACKETED,
			x: result
		};
	}
}
</P><P>var name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;
var spreadPattern = /^\s*\.{3}/;
var legalReference = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:\.(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/;
var relaxedName = /^[a-zA-Z_$][-\/a-zA-Z_$0-9]*(?:\.(?:[a-zA-Z_$][-\/a-zA-Z_$0-9]*))*/;
</P><P>var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
</P><P>// <A rel="nofollow" class="external free" href="http://mathiasbynens.be/notes/javascript-properties">http://mathiasbynens.be/notes/javascript-properties</A>
// can be any name, string literal, or number literal
function readKey ( parser ) {
	var token;
</P><P>	if ( token = readStringLiteral( parser ) ) {
		return identifier.test( token.v ) ? token.v : '&quot;' + token.v.replace( /&quot;/g, '\\&quot;' ) + '&quot;';
	}
</P><P>	if ( token = readNumberLiteral$1( parser ) ) {
		return token.v;
	}
</P><P>	if ( token = parser.matchPattern( name ) ) {
		return token;
	}
</P><P>	return null;
}
</P><P>function readKeyValuePair ( parser ) {
	var spread;
	var start = parser.pos;
</P><P>	// allow whitespace between '{' and key
	parser.allowWhitespace();
</P><P>	var refKey = parser.nextChar() !== '\<I>&amp;&amp; parser.nextChar() !== '&quot;';</I>
	if ( refKey ) { spread = parser.matchPattern( spreadPattern ); }
</P><P>	var key = spread ? readExpression( parser ) : readKey( parser );
	if ( key === null ) {
		parser.pos = start;
		return null;
	}
</P><P>	// allow whitespace between key and ':'
	parser.allowWhitespace();
</P><P>	// es2015 shorthand property
	if ( refKey &amp;&amp; ( parser.nextChar() === ',' || parser.nextChar() === '}' ) ) {
		if ( !spread &amp;&amp; !name.test( key ) ) {
			parser.error( (&quot;Expected a valid reference, but found '&quot; + key + &quot;' instead.&quot;) );
		}
</P><P>		var pair = {
			t: KEY_VALUE_PAIR,
			k: key,
			v: {
				t: REFERENCE,
				n: key
			}
		};
</P><P>		if ( spread ) {
			pair.p = true;
		}
</P><P>		return pair;
	}
</P><P>
	// next character must be ':'
	if ( !parser.matchString( ':' ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	// allow whitespace between ':' and value
	parser.allowWhitespace();
</P><P>	// next expression must be a, well... expression
	var value = readExpression( parser );
	if ( value === null ) {
		parser.pos = start;
		return null;
	}
</P><P>	return {
		t: KEY_VALUE_PAIR,
		k: key,
		v: value
	};
}
</P><P>function readKeyValuePairs ( parser ) {
	var start = parser.pos;
</P><P>	var pair = readKeyValuePair( parser );
	if ( pair === null ) {
		return null;
	}
</P><P>	var pairs = [ pair ];
</P><P>	if ( parser.matchString( ',' ) ) {
		var keyValuePairs = readKeyValuePairs( parser );
</P><P>		if ( !keyValuePairs ) {
			parser.pos = start;
			return null;
		}
</P><P>		return pairs.concat( keyValuePairs );
	}
</P><P>	return pairs;
}
</P><P>var readObjectLiteral = function ( parser ) {
	var start = parser.pos;
</P><P>	// allow whitespace
	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( '{' ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	var keyValuePairs = readKeyValuePairs( parser );
</P><P>	// allow whitespace between final value and '}'
	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( '}' ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	return {
		t: OBJECT_LITERAL,
		m: keyValuePairs
	};
};
</P><P>var readArrayLiteral = function ( parser ) {
	var start = parser.pos;
</P><P>	// allow whitespace before '['
	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( '[' ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	var expressionList = readExpressionList( parser, true );
</P><P>	if ( !parser.matchString( ']' ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	return {
		t: ARRAY_LITERAL,
		m: expressionList
	};
};
</P><P>function readLiteral ( parser ) {
	return readNumberLiteral$1( parser )         ||
	       readBooleanLiteral( parser )        ||
	       readStringLiteral( parser )         ||
	       readTemplateStringLiteral( parser ) ||
	       readObjectLiteral( parser )         ||
	       readArrayLiteral( parser )          ||
	       readNumberLiteral( parser );
}
</P><P>// if a reference is a browser global, we don't deference it later, so it needs special treatment
var globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\b/;
</P><P>// keywords are not valid references, with the exception of `this`
var keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
</P><P>var prefixPattern = /^(?:\@\.|\@|~\/|(?:\^\^\/(?:\^\^\/)*(?:\.\.\/)*)|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/;
var specials = /^(key|index|keypath|rootpath|this|global|shared|context|event|node|local)/;
</P><P>function readReference ( parser ) {
	var prefix, name$$1, global, reference, lastDotIndex;
</P><P>	var startPos = parser.pos;
</P><P>	prefix = parser.matchPattern( prefixPattern ) || <I>;</I>
	name$$1 = ( !prefix &amp;&amp; parser.relaxedNames &amp;&amp; parser.matchPattern( relaxedName ) ) ||
			parser.matchPattern( legalReference );
	var actual = prefix.length + ( ( name$$1 &amp;&amp; name$$1.length ) || 0 );
</P><P>	if ( prefix === '@.' ) {
		prefix = '@';
		if ( name$$1 ) { name$$1 = 'this.' + name$$1; }
		else { name$$1 = 'this'; }
	}
</P><P>	if ( !name$$1 &amp;&amp; prefix ) {
		name$$1 = prefix;
		prefix = <I>;</I>
	}
</P><P>	if ( !name$$1 ) {
		return null;
	}
</P><P>	if ( prefix === '@' ) {
		if ( !specials.test( name$$1 ) ) {
			parser.error( (&quot;Unrecognized special reference @&quot; + name$$1) );
		} else if ( ( ~name$$1.indexOf( 'event' ) || ~name$$1.indexOf( 'node' ) ) &amp;&amp; !parser.inEvent ) {
			parser.error( &quot;@event and @node are only valid references within an event directive&quot; );
		} else if ( ~name$$1.indexOf( 'context' ) ) {
			parser.pos = parser.pos - ( name$$1.length - 7 );
			return {
				t: BRACKETED,
				x: {
					t: REFERENCE,
					n: '@context'
				}
			};
		}
	}
</P><P>	// bug out if it's a keyword (exception for ancestor/restricted refs - see <A rel="nofollow" class="external free" href="https://github.com/ractivejs/ractive/issues/1497">https://github.com/ractivejs/ractive/issues/1497</A>)
	if ( !prefix &amp;&amp; !parser.relaxedNames &amp;&amp; keywords.test( name$$1 ) ) {
		parser.pos = startPos;
		return null;
	}
</P><P>	// if this is a browser global, stop here
	if ( !prefix &amp;&amp; globals.test( name$$1 ) ) {
		global = globals.exec( name$$1 )[0];
		parser.pos = startPos + global.length;
</P><P>		return {
			t: GLOBAL,
			v: global
		};
	}
</P><P>	reference = ( prefix || <I> ) + normalise( name$$1 );</I></P><P>	if ( parser.matchString( '(' ) ) {
		// if this is a method invocation (as opposed to a function) we need
		// to strip the method name from the reference combo, else the context
		// will be wrong
		// but only if the reference was actually a member and not a refinement
		lastDotIndex = reference.lastIndexOf( '.' );
		if ( lastDotIndex !== -1 &amp;&amp; name$$1[ name$$1.length - 1 ] !== ']' ) {
			var refLength = reference.length;
			reference = reference.substr( 0, lastDotIndex );
			parser.pos = startPos + ( actual - ( refLength - lastDotIndex ) );
		} else {
			parser.pos -= 1;
		}
	}
</P><P>	return {
		t: REFERENCE,
		n: reference.replace( /^this\./, './' ).replace( /^this$/, '.' )
	};
}
</P><P>function readBracketedExpression ( parser ) {
	if ( !parser.matchString( '(' ) ) { return null; }
</P><P>	parser.allowWhitespace();
</P><P>	var expr = readExpression( parser );
</P><P>	if ( !expr ) { parser.error( expectedExpression ); }
</P><P>	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( ')' ) ) { parser.error( expectedParen ); }
</P><P>	return {
		t: BRACKETED,
		x: expr
	};
}
</P><P>var readPrimary = function ( parser ) {
	return readLiteral( parser )
		|| readReference( parser )
		|| readBracketedExpression( parser );
};
</P><P>function readRefinement ( parser ) {
	// some things call for strict refinement (partial names), meaning no space between reference and refinement
	if ( !parser.strictRefinement ) {
		parser.allowWhitespace();
	}
</P><P>	// &quot;.&quot; name
	if ( parser.matchString( '.' ) ) {
		parser.allowWhitespace();
</P><P>		var name$$1 = parser.matchPattern( name );
		if ( name$$1 ) {
			return {
				t: REFINEMENT,
				n: name$$1
			};
		}
</P><P>		parser.error( 'Expected a property name' );
	}
</P><P>	// &quot;[&quot; expression &quot;]&quot;
	if ( parser.matchString( '[' ) ) {
		parser.allowWhitespace();
</P><P>		var expr = readExpression( parser );
		if ( !expr ) { parser.error( expectedExpression ); }
</P><P>		parser.allowWhitespace();
</P><P>		if ( !parser.matchString( ']' ) ) { parser.error( &quot;Expected ']'&quot; ); }
</P><P>		return {
			t: REFINEMENT,
			x: expr
		};
	}
</P><P>	return null;
}
</P><P>var readMemberOrInvocation = function ( parser ) {
	var expression = readPrimary( parser );
</P><P>	if ( !expression ) { return null; }
</P><P>	while ( expression ) {
		var refinement = readRefinement( parser );
		if ( refinement ) {
			expression = {
				t: MEMBER,
				x: expression,
				r: refinement
			};
		}
</P><P>		else if ( parser.matchString( '(' ) ) {
			parser.allowWhitespace();
			var expressionList = readExpressionList( parser, true );
</P><P>			parser.allowWhitespace();
</P><P>			if ( !parser.matchString( ')' ) ) {
				parser.error( expectedParen );
			}
</P><P>			expression = {
				t: INVOCATION,
				x: expression
			};
</P><P>			if ( expressionList ) { expression.o = expressionList; }
		}
</P><P>		else {
			break;
		}
	}
</P><P>	return expression;
};
</P><P>var readTypeOf;
</P><P>var makePrefixSequenceMatcher = function ( symbol, fallthrough ) {
	return function ( parser ) {
		var expression;
</P><P>		if ( expression = fallthrough( parser ) ) {
			return expression;
		}
</P><P>		if ( !parser.matchString( symbol ) ) {
			return null;
		}
</P><P>		parser.allowWhitespace();
</P><P>		expression = readExpression( parser );
		if ( !expression ) {
			parser.error( expectedExpression );
		}
</P><P>		return {
			s: symbol,
			o: expression,
			t: PREFIX_OPERATOR
		};
	};
};
</P><P>// create all prefix sequence matchers, return readTypeOf
(function() {
	var i, len, matcher, fallthrough;
</P><P>	var prefixOperators = '! ~ + - typeof'.split( ' ' );
</P><P>	fallthrough = readMemberOrInvocation;
	for ( i = 0, len = prefixOperators.length; i &lt; len; i += 1 ) {
		matcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );
		fallthrough = matcher;
	}
</P><P>	// typeof operator is higher precedence than multiplication, so provides the
	// fallthrough for the multiplication sequence matcher we're about to create
	// (we're skipping void and delete)
	readTypeOf = fallthrough;
}());
</P><P>var readTypeof = readTypeOf;
</P><P>var readLogicalOr;
</P><P>var makeInfixSequenceMatcher = function ( symbol, fallthrough ) {
	return function ( parser ) {
		// &gt; and / have to be quoted
		if ( parser.inUnquotedAttribute &amp;&amp; ( symbol === '&gt;' || symbol === '/' ) ) { return fallthrough( parser ); }
</P><P>		var start, left, right;
</P><P>		left = fallthrough( parser );
		if ( !left ) {
			return null;
		}
</P><P>		// Loop to handle left-recursion in a case like `a * b * c` and produce
		// left association, i.e. `(a * b) * c`.  The matcher can't call itself
		// to parse `left` because that would be infinite regress.
		while ( true ) {
			start = parser.pos;
</P><P>			parser.allowWhitespace();
</P><P>			if ( !parser.matchString( symbol ) ) {
				parser.pos = start;
				return left;
			}
</P><P>			// special case - in operator must not be followed by [a-zA-Z_$0-9]
			if ( symbol === 'in' &amp;&amp; /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
				parser.pos = start;
				return left;
			}
</P><P>			parser.allowWhitespace();
</P><P>			// right operand must also consist of only higher-precedence operators
			right = fallthrough( parser );
			if ( !right ) {
				parser.pos = start;
				return left;
			}
</P><P>			left = {
				t: INFIX_OPERATOR,
				s: symbol,
				o: [ left, right ]
			};
</P><P>			// Loop back around.  If we don't see another occurrence of the symbol,
			// we'll return left.
		}
	};
};
</P><P>// create all infix sequence matchers, and return readLogicalOr
(function() {
	var i, len, matcher, fallthrough;
</P><P>	// All the infix operators on order of precedence (source: <A rel="nofollow" class="external free" href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence</A>)
	// Each sequence matcher will initially fall through to its higher precedence
	// neighbour, and only attempt to match if one of the higher precedence operators
	// (or, ultimately, a literal, reference, or bracketed expression) already matched
	var infixOperators = '* / % + - &lt;&lt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;= &gt;&gt;= in instanceof == != === !== &amp; ^ | &amp;&amp; ||'.split( ' ' );
</P><P>	// A typeof operator is higher precedence than multiplication
	fallthrough = readTypeof;
	for ( i = 0, len = infixOperators.length; i &lt; len; i += 1 ) {
		matcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );
		fallthrough = matcher;
	}
</P><P>	// Logical OR is the fallthrough for the conditional matcher
	readLogicalOr = fallthrough;
}());
</P><P>var readLogicalOr$1 = readLogicalOr;
</P><P>// The conditional operator is the lowest precedence operator, so we start here
function getConditional ( parser ) {
	var expression = readLogicalOr$1( parser );
	if ( !expression ) {
		return null;
	}
</P><P>	var start = parser.pos;
</P><P>	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( '?' ) ) {
		parser.pos = start;
		return expression;
	}
</P><P>	parser.allowWhitespace();
</P><P>	var ifTrue = readExpression( parser );
	if ( !ifTrue ) {
		parser.error( expectedExpression );
	}
</P><P>	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( ':' ) ) {
		parser.error( 'Expected &quot;:&quot;' );
	}
</P><P>	parser.allowWhitespace();
</P><P>	var ifFalse = readExpression( parser );
	if ( !ifFalse ) {
		parser.error( expectedExpression );
	}
</P><P>	return {
		t: CONDITIONAL,
		o: [ expression, ifTrue, ifFalse ]
	};
}
</P><P>function readExpression ( parser ) {
	// The conditional operator is the lowest precedence operator (except yield,
	// assignment operators, and commas, none of which are supported), so we
	// start there. If it doesn't match, it 'falls through' to progressively
	// higher precedence operators, until it eventually matches (or fails to
	// match) a 'primary' - a literal or a reference. This way, the abstract syntax
	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
	return getConditional( parser );
}
</P><P>function readExpressionList ( parser, spread ) {
	var isSpread;
	var expressions = [];
</P><P>	var pos = parser.pos;
</P><P>	do {
		parser.allowWhitespace();
</P><P>		if ( spread ) {
			isSpread = parser.matchPattern( spreadPattern );
		}
</P><P>		var expr = readExpression( parser );
</P><P>		if ( expr === null &amp;&amp; expressions.length ) {
			parser.error( expectedExpression );
		} else if ( expr === null ) {
			parser.pos = pos;
			return null;
		}
</P><P>		if ( isSpread ) {
			expr.p = true;
		}
</P><P>		expressions.push( expr );
</P><P>		parser.allowWhitespace();
	} while ( parser.matchString( ',' ) );
</P><P>	return expressions;
}
</P><P>function readExpressionOrReference ( parser, expectedFollowers ) {
	var start = parser.pos;
	var expression = readExpression( parser );
</P><P>	if ( !expression ) {
		// valid reference but invalid expression e.g. `<A href="/wiki/index.php?title=Template:New&amp;action=edit&amp;redlink=1" class="new" title="Template:New (page does not exist)">Template:New</A>`?
		var ref = parser.matchPattern( /^(\w+)/ );
		if ( ref ) {
			return {
				t: REFERENCE,
				n: ref
			};
		}
</P><P>		return null;
	}
</P><P>	for ( var i = 0; i &lt; expectedFollowers.length; i += 1 ) {
		if ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {
			return expression;
		}
	}
</P><P>	parser.pos = start;
	return readReference( parser );
}
</P><P>function flattenExpression ( expression ) {
	var refs;
	var count = 0;
</P><P>	extractRefs( expression, refs = [] );
	var stringified = stringify( expression );
</P><P>	return {
		r: refs,
		s: getVars(stringified)
	};
</P><P>	function getVars(expr) {
		var vars = [];
		for ( var i = count - 1; i &gt;= 0; i-- ) {
			vars.push( (&quot;x$&quot; + i) );
		}
		return vars.length ? (&quot;(function(){var &quot; + (vars.join(',')) + &quot;;return(&quot; + expr + &quot;);})()&quot;) : expr;
	}
</P><P>	function stringify ( node ) {
		if ( typeof node === 'string' ) {
			return node;
		}
</P><P>		switch ( node.t ) {
			case BOOLEAN_LITERAL:
			case GLOBAL:
			case NUMBER_LITERAL:
			case REGEXP_LITERAL:
				return node.v;
</P><P>			case STRING_LITERAL:
				return JSON.stringify( String( node.v ) );
</P><P>			case ARRAY_LITERAL:
				if ( node.m &amp;&amp; hasSpread( node.m )) {
					return (&quot;[].concat(&quot; + (makeSpread( node.m, '[', ']', stringify )) + &quot;)&quot;);
				} else {
					return '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : <I> ) + ']';</I>
				}
</P><P>			case OBJECT_LITERAL:
				if ( node.m &amp;&amp; hasSpread( node.m ) ) {
					return (&quot;Object.assign({},&quot; + (makeSpread( node.m, '{', '}', stringifyPair)) + &quot;)&quot;);
				} else {
					return '{' + ( node.m ? node.m.map( function (n) { return ((n.k) + &quot;:&quot; + (stringify( n.v ))); } ).join( ',' ) : <I> ) + '}';</I>
				}
</P><P>			case PREFIX_OPERATOR:
				return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );
</P><P>			case INFIX_OPERATOR:
				return stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );
</P><P>			case INVOCATION:
				if ( node.o &amp;&amp; hasSpread( node.o ) ) {
					var id = count++;
					return (&quot;(x$&quot; + id + &quot;=&quot; + (stringify(node.x)) + &quot;).apply(x$&quot; + id + &quot;,&quot; + (stringify({ t: ARRAY_LITERAL, m: node.o })) + &quot;)&quot;);
				} else {
					return stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : <I> ) + ')';</I>
				}
</P><P>			case BRACKETED:
				return '(' + stringify( node.x ) + ')';
</P><P>			case MEMBER:
				return stringify( node.x ) + stringify( node.r );
</P><P>			case REFINEMENT:
				return ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );
</P><P>			case CONDITIONAL:
				return stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );
</P><P>			case REFERENCE:
				return '_' + refs.indexOf( node.n );
</P><P>			default:
				throw new Error( 'Expected legal JavaScript' );
		}
	}
</P><P>	function stringifyPair ( node ) { return node.p ? stringify( node.k ) : ((node.k) + &quot;:&quot; + (stringify( node.v ))); }
</P><P>	function makeSpread ( list, open, close, fn ) {
		var out = list.reduce( function ( a, c ) {
			if ( c.p ) {
				a.str += &quot;&quot; + (a.open ? close + ',' : a.str.length ? ',' : <I>) + (fn( c ));</I>
			} else {
				a.str += &quot;&quot; + (!a.str.length ? open : !a.open ? ',' + open : ',') + (fn( c ));
			}
			a.open = !c.p;
			return a;
		}, { open: false, str: <I> } );</I>
		if ( out.open ) { out.str += close; }
		return out.str;
	}
}
</P><P>function hasSpread ( list ) {
	for ( var i = 0; i &lt; list.length; i++ ) {
		if ( list[i].p ) { return true; }
	}
</P><P>	return false;
}
</P><P>// TODO maybe refactor this?
function extractRefs ( node, refs ) {
	if ( node.t === REFERENCE &amp;&amp; typeof node.n === 'string' ) {
		if ( !~refs.indexOf( node.n ) ) {
			refs.unshift( node.n );
		}
	}
</P><P>	var list = node.o || node.m;
	if ( list ) {
		if ( isObject( list ) ) {
			extractRefs( list, refs );
		} else {
			var i = list.length;
			while ( i-- ) {
				extractRefs( list[i], refs );
			}
		}
	}
</P><P>	if ( node.k &amp;&amp; node.t === KEY_VALUE_PAIR &amp;&amp; typeof node.k !== 'string' ) {
		extractRefs( node.k, refs );
	}
</P><P>	if ( node.x ) {
		extractRefs( node.x, refs );
	}
</P><P>	if ( node.r ) {
		extractRefs( node.r, refs );
	}
</P><P>	if ( node.v ) {
		extractRefs( node.v, refs );
	}
}
</P><P>function refineExpression ( expression, mustache ) {
	var referenceExpression;
</P><P>	if ( expression ) {
		while ( expression.t === BRACKETED &amp;&amp; expression.x ) {
			expression = expression.x;
		}
</P><P>		if ( expression.t === REFERENCE ) {
			var n = expression.n;
			if ( !~n.indexOf( '@context' ) ) {
				mustache.r = expression.n;
			} else {
				mustache.x = flattenExpression( expression );
			}
		} else {
			if ( referenceExpression = getReferenceExpression( expression ) ) {
				mustache.rx = referenceExpression;
			} else {
				mustache.x = flattenExpression( expression );
			}
		}
</P><P>		return mustache;
	}
}
</P><P>// TODO refactor this! it's bewildering
function getReferenceExpression ( expression ) {
	var members = [];
	var refinement;
</P><P>	while ( expression.t === MEMBER &amp;&amp; expression.r.t === REFINEMENT ) {
		refinement = expression.r;
</P><P>		if ( refinement.x ) {
			if ( refinement.x.t === REFERENCE ) {
				members.unshift( refinement.x );
			} else {
				members.unshift( flattenExpression( refinement.x ) );
			}
		} else {
			members.unshift( refinement.n );
		}
</P><P>		expression = expression.x;
	}
</P><P>	if ( expression.t !== REFERENCE ) {
		return null;
	}
</P><P>	return {
		r: expression.n,
		m: members
	};
}
</P><P>var attributeNamePattern = /^[^\s&quot;'&gt;\/=]+/;
var onPattern = /^on/;
var eventPattern = /^on-([a-zA-Z\*\.$_]((?:[a-zA-Z\*\.$_0-9\-]|\\-)+))$/;
var reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|complete|unrender|detach|insert|destruct|attachchild|detachchild)$/;
var decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;
var transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;
var boundPattern = /^((bind|class)-(([-a-zA-Z0-9_])+))$/;
var directives = {
	lazy: { t: BINDING_FLAG, v: 'l' },
	twoway: { t: BINDING_FLAG, v: 't' },
	'no-delegation': { t: DELEGATE_FLAG }
};
var unquotedAttributeValueTextPattern = /^[^\s&quot;'=&lt;&gt;\/`]+/;
var proxyEvent = /^[^\s&quot;'=&lt;&gt;@\[\]()]*/;
var whitespace = /^\s+/;
</P><P>var slashes = /\\/g;
function splitEvent ( str ) {
	var result = [];
	var s = 0;
</P><P>	for ( var i = 0; i &lt; str.length; i++ ) {
		if ( str[i] === '-' &amp;&amp; str[ i - 1 ] !== '\\' ) {
			result.push( str.substring( s, i ).replace( slashes, <I> ) );</I>
			s = i + 1;
		}
	}
</P><P>	result.push( str.substring( s ).replace( slashes, <I> ) );</I></P><P>	return result;
}
</P><P>function readAttribute ( parser ) {
	var name, i, nearest, idx;
</P><P>	parser.allowWhitespace();
</P><P>	name = parser.matchPattern( attributeNamePattern );
	if ( !name ) {
		return null;
	}
</P><P>	// check for accidental delimiter consumption e.g. &lt;tag bool{{&gt;attrs}} /&gt;
	nearest = name.length;
	for ( i = 0; i &lt; parser.tags.length; i++ ) {
		if ( ~( idx = name.indexOf( parser.tags[ i ].open ) ) ) {
			if ( idx &lt; nearest ) { nearest = idx; }
		}
	}
	if ( nearest &lt; name.length ) {
		parser.pos -= name.length - nearest;
		name = name.substr( 0, nearest );
		if ( !name ) { return null; }
	}
</P><P>	return { n: name };
}
</P><P>function readAttributeValue ( parser ) {
	var start = parser.pos;
</P><P>	// next character must be `=`, `/`, `&gt;` or whitespace
	if ( !/[=\/&gt;\s]/.test( parser.nextChar() ) ) {
		parser.error( 'Expected `=`, `/`, `&gt;` or whitespace' );
	}
</P><P>	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( '=' ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	parser.allowWhitespace();
</P><P>	var valueStart = parser.pos;
	var startDepth = parser.sectionDepth;
</P><P>	var value = readQuotedAttributeValue( parser, &quot;'&quot; ) ||
			readQuotedAttributeValue( parser, &quot;\&quot;&quot; ) ||
			readUnquotedAttributeValue( parser );
</P><P>	if ( value === null ) {
		parser.error( 'Expected valid attribute value' );
	}
</P><P>	if ( parser.sectionDepth !== startDepth ) {
		parser.pos = valueStart;
		parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
	}
</P><P>	if ( !value.length ) {
		return <I>;</I>
	}
</P><P>	if ( value.length === 1 &amp;&amp; typeof value[0] === 'string' ) {
		return decodeCharacterReferences( value[0] );
	}
</P><P>	return value;
}
</P><P>function readUnquotedAttributeValueToken ( parser ) {
	var text, index;
</P><P>	var start = parser.pos;
</P><P>	text = parser.matchPattern( unquotedAttributeValueTextPattern );
</P><P>	if ( !text ) {
		return null;
	}
</P><P>	var haystack = text;
	var needles = parser.tags.map( function (t) { return t.open; } ); // TODO refactor... we do this in readText.js as well
</P><P>	if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {
		text = text.substr( 0, index );
		parser.pos = start + text.length;
	}
</P><P>	return text;
}
</P><P>function readUnquotedAttributeValue ( parser ) {
	parser.inAttribute = true;
</P><P>	var tokens = [];
</P><P>	var token = readMustache( parser ) || readUnquotedAttributeValueToken( parser );
	while ( token ) {
		tokens.push( token );
		token = readMustache( parser ) || readUnquotedAttributeValueToken( parser );
	}
</P><P>	if ( !tokens.length ) {
		return null;
	}
</P><P>	parser.inAttribute = false;
	return tokens;
}
</P><P>function readQuotedAttributeValue ( parser, quoteMark ) {
	var start = parser.pos;
</P><P>	if ( !parser.matchString( quoteMark ) ) {
		return null;
	}
</P><P>	parser.inAttribute = quoteMark;
</P><P>	var tokens = [];
</P><P>	var token = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );
	while ( token !== null ) {
		tokens.push( token );
		token = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );
	}
</P><P>	if ( !parser.matchString( quoteMark ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	parser.inAttribute = false;
</P><P>	return tokens;
}
</P><P>function readQuotedStringToken ( parser, quoteMark ) {
	var haystack = parser.remaining();
</P><P>	var needles = parser.tags.map( function (t) { return t.open; } ); // TODO refactor... we do this in readText.js as well
	needles.push( quoteMark );
</P><P>	var index = getLowestIndex( haystack, needles );
</P><P>	if ( index === -1 ) {
		parser.error( 'Quoted attribute value must have a closing quote' );
	}
</P><P>	if ( !index ) {
		return null;
	}
</P><P>	parser.pos += index;
	return haystack.substr( 0, index );
}
</P><P>function readAttributeOrDirective ( parser ) {
	var match, directive;
</P><P>	var attribute = readAttribute( parser, false );
</P><P>	if ( !attribute ) { return null; }
</P><P>		// lazy, twoway
	if ( directive = directives[ attribute.n ] ) {
		attribute.t = directive.t;
		if ( directive.v ) { attribute.v = directive.v; }
		delete attribute.n; // no name necessary
		parser.allowWhitespace();
		if ( parser.nextChar() === '=' ) { attribute.f = readAttributeValue( parser ); }
	}
</P><P>		// decorators
	else if ( match = decoratorPattern.exec( attribute.n ) ) {
		attribute.n = match[1];
		attribute.t = DECORATOR;
		readArguments( parser, attribute );
	}
</P><P>		// transitions
	else if ( match = transitionPattern.exec( attribute.n ) ) {
		attribute.n = match[1];
		attribute.t = TRANSITION;
		readArguments( parser, attribute );
		attribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';
	}
</P><P>		// on-click etc
	else if ( match = eventPattern.exec( attribute.n ) ) {
		attribute.n = splitEvent( match[1] );
		attribute.t = EVENT;
</P><P>		parser.inEvent = true;
</P><P>			// check for a proxy event
		if ( !readProxyEvent( parser, attribute ) ) {
				// otherwise, it's an expression
			readArguments( parser, attribute, true );
		} else if ( reservedEventNames.test( attribute.f ) ) {
			parser.pos -= attribute.f.length;
			parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, complete, detach, insert, destruct, attachchild, detachchild)' );
		}
</P><P>		parser.inEvent = false;
	}
</P><P>		// bound directives
	else if ( match = boundPattern.exec( attribute.n ) ){
		var bind = match[2] === 'bind';
		attribute.n = bind ? match[3] : match[1];
		attribute.t = ATTRIBUTE;
		readArguments( parser, attribute, false, true );
</P><P>		if ( !attribute.f &amp;&amp; bind ) {
			attribute.f = [{ t: INTERPOLATOR, r: match[3] }];
		}
	}
</P><P>	else {
		parser.allowWhitespace();
		var value = parser.nextChar() === '=' ? readAttributeValue( parser ) : null;
		attribute.f = value != null ? value : attribute.f;
</P><P>		if ( parser.sanitizeEventAttributes &amp;&amp; onPattern.test( attribute.n ) ) {
			return { exclude: true };
		} else {
			attribute.f = attribute.f || ( attribute.f === <I> ? </I> : 0 );
			attribute.t = ATTRIBUTE;
		}
	}
</P><P>	return attribute;
}
</P><P>function readProxyEvent ( parser, attribute ) {
	var start = parser.pos;
	if ( !parser.matchString( '=' ) ) { parser.error( &quot;Missing required directive arguments&quot; ); }
</P><P>	var quote = parser.matchString( &quot;'&quot; ) || parser.matchString( &quot;\&quot;&quot; );
	parser.allowWhitespace();
	var proxy = parser.matchPattern( proxyEvent );
</P><P>	if ( proxy !== undefined ) {
		if ( quote ) {
			parser.allowWhitespace();
			if ( !parser.matchString( quote ) ) { parser.pos = start; }
			else { return ( attribute.f = proxy ) || true; }
		} else if ( !parser.matchPattern( whitespace ) ) {
			parser.pos = start;
		} else {
			return ( attribute.f = proxy ) || true;
		}
	} else {
		parser.pos = start;
	}
}
</P><P>function readArguments ( parser, attribute, required, single ) {
	if ( required === void 0 ) required = false;
	if ( single === void 0 ) single = false;
</P><P>	parser.allowWhitespace();
	if ( !parser.matchString( '=' ) ) {
		if ( required ) { parser.error( &quot;Missing required directive arguments&quot; ); }
		return;
	}
	parser.allowWhitespace();
</P><P>	var quote = parser.matchString( '&quot;' ) || parser.matchString( &quot;'&quot; );
	var spread = parser.spreadArgs;
	parser.spreadArgs = true;
	parser.inUnquotedAttribute = !quote;
	var expr = single ? readExpressionOrReference( parser, [ quote || ' ', '/', '&gt;' ] ) : { m: readExpressionList( parser ), t: ARRAY_LITERAL };
	parser.inUnquotedAttribute = false;
	parser.spreadArgs = spread;
</P><P>	if ( quote ) {
		parser.allowWhitespace();
		if ( parser.matchString( quote ) !== quote ) { parser.error( (&quot;Expected matching quote '&quot; + quote + &quot;'&quot;) ); }
	}
</P><P>	if ( single ) {
		var interpolator = { t: INTERPOLATOR };
		refineExpression( expr, interpolator );
		attribute.f = [interpolator];
	} else {
		attribute.f = flattenExpression( expr );
	}
}
</P><P>var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };
</P><P>function readMustache ( parser ) {
	var mustache, i;
</P><P>	// If we're inside a &lt;script&gt; or &lt;style&gt; tag, and we're not
	// interpolating, bug out
	if ( parser.interpolate[ parser.inside ] === false ) {
		return null;
	}
</P><P>	for ( i = 0; i &lt; parser.tags.length; i += 1 ) {
		if ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {
			return mustache;
		}
	}
</P><P>	if ( parser.inTag &amp;&amp; !parser.inAttribute ) {
		mustache = readAttributeOrDirective( parser );
		if ( mustache ) {
			parser.allowWhitespace();
			return mustache;
		}
	}
}
</P><P>function readMustacheOfType ( parser, tag ) {
	var mustache, reader, i;
</P><P>	var start = parser.pos;
</P><P>	if ( parser.matchString( '\\' + tag.open ) ) {
		if ( start === 0 || parser.str[ start - 1 ] !== '\\' ) {
			return tag.open;
		}
	} else if ( !parser.matchString( tag.open ) ) {
		return null;
	}
</P><P>	// delimiter change?
	if ( mustache = readDelimiterChange( parser ) ) {
		// find closing delimiter or abort...
		if ( !parser.matchString( tag.close ) ) {
			return null;
		}
</P><P>		// ...then make the switch
		tag.open = mustache[0];
		tag.close = mustache[1];
		parser.sortMustacheTags();
</P><P>		return delimiterChangeToken;
	}
</P><P>	parser.allowWhitespace();
</P><P>	// illegal section closer
	if ( parser.matchString( '/' ) ) {
		parser.pos -= 1;
		var rewind = parser.pos;
		if ( !readNumberLiteral( parser ) ) {
			parser.pos = rewind - ( tag.close.length );
			if ( parser.inAttribute ) {
				parser.pos = start;
				return null;
			} else {
				parser.error( 'Attempted to close a section that wasn\'t open' );
			}
		} else {
			parser.pos = rewind;
		}
	}
</P><P>	for ( i = 0; i &lt; tag.readers.length; i += 1 ) {
		reader = tag.readers[i];
</P><P>		if ( mustache = reader( parser, tag ) ) {
			if ( tag.isStatic ) {
				mustache.s = 1;
			}
</P><P>			if ( parser.includeLinePositions ) {
				mustache.p = parser.getLinePos( start );
			}
</P><P>			return mustache;
		}
	}
</P><P>	parser.pos = start;
	return null;
}
</P><P>function readTriple ( parser, tag ) {
	var expression = readExpression( parser );
</P><P>	if ( !expression ) {
		return null;
	}
</P><P>	if ( !parser.matchString( tag.close ) ) {
		parser.error( (&quot;Expected closing delimiter '&quot; + (tag.close) + &quot;'&quot;) );
	}
</P><P>	var triple = { t: TRIPLE };
	refineExpression( expression, triple ); // TODO handle this differently - it's mysterious
</P><P>	return triple;
}
</P><P>function readUnescaped ( parser, tag ) {
	if ( !parser.matchString( '&amp;' ) ) {
		return null;
	}
</P><P>	parser.allowWhitespace();
</P><P>	var expression = readExpression( parser );
</P><P>	if ( !expression ) {
		return null;
	}
</P><P>	if ( !parser.matchString( tag.close ) ) {
		parser.error( (&quot;Expected closing delimiter '&quot; + (tag.close) + &quot;'&quot;) );
	}
</P><P>	var triple = { t: TRIPLE };
	refineExpression( expression, triple ); // TODO handle this differently - it's mysterious
</P><P>	return triple;
}
</P><P>var legalAlias = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/;
var asRE = /^as/i;
</P><P>function readAliases( parser ) {
	var aliases = [];
	var alias;
	var start = parser.pos;
</P><P>	parser.allowWhitespace();
</P><P>	alias = readAlias( parser );
</P><P>	if ( alias ) {
		alias.x = refineExpression( alias.x, {} );
		aliases.push( alias );
</P><P>		parser.allowWhitespace();
</P><P>		while ( parser.matchString(',') ) {
			alias = readAlias( parser );
</P><P>			if ( !alias ) {
				parser.error( 'Expected another alias.' );
			}
</P><P>			alias.x = refineExpression( alias.x, {} );
			aliases.push( alias );
</P><P>			parser.allowWhitespace();
		}
</P><P>		return aliases;
	}
</P><P>	parser.pos = start;
	return null;
}
</P><P>function readAlias( parser ) {
	var start = parser.pos;
</P><P>	parser.allowWhitespace();
</P><P>	var expr = readExpression( parser, [] );
</P><P>	if ( !expr ) {
		parser.pos = start;
		return null;
	}
</P><P>	parser.allowWhitespace();
</P><P>	if ( !parser.matchPattern( asRE ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	parser.allowWhitespace();
</P><P>	var alias = parser.matchPattern( legalAlias );
</P><P>	if ( !alias ) {
		parser.error( 'Expected a legal alias name.' );
	}
</P><P>	return { n: alias, x: expr };
}
</P><P>function readPartial ( parser, tag ) {
	var type = parser.matchString( '&gt;' ) || parser.matchString( 'yield' );
	var partial = { t: type === '&gt;' ? PARTIAL : YIELDER };
	var aliases;
</P><P>	if ( !type ) { return null; }
</P><P>	parser.allowWhitespace();
</P><P>	if ( type === '&gt;' || !( aliases = parser.matchString( 'with' ) ) ) {
		// Partial names can include hyphens, so we can't use readExpression
		// blindly. Instead, we use the `relaxedNames` flag to indicate that
		// `foo-bar` should be read as a single name, rather than 'subtract
		// bar from foo'
		parser.relaxedNames = parser.strictRefinement = true;
		var expression = readExpression( parser );
		parser.relaxedNames = parser.strictRefinement = false;
</P><P>		if ( !expression &amp;&amp; type === '&gt;' ) { return null; }
</P><P>		if ( expression ) {
			refineExpression( expression, partial ); // TODO...
			parser.allowWhitespace();
			if ( type !== '&gt;' ) { aliases = parser.matchString( 'with' ); }
		}
	}
</P><P>	parser.allowWhitespace();
</P><P>	// check for alias context e.g. `{{&gt;foo bar as bat, bip as bop}}`
	if ( aliases || type === '&gt;' ) {
		aliases = readAliases( parser );
		if ( aliases &amp;&amp; aliases.length ) {
			partial.z = aliases;
		}
</P><P>		// otherwise check for literal context e.g. `{{&gt;foo bar}}` then
		// turn it into `{{#with bar}}{{&gt;foo}}<A href="/wiki/index.php?title=Template:/with&amp;action=edit&amp;redlink=1" class="new" title="Template:/with (page does not exist)">Template:/with</A>`
		else if ( type === '&gt;' ) {
			var context = readExpression( parser );
			if ( context) {
				partial.c = {};
				refineExpression( context, partial.c );
			}
		}
</P><P>		else {
			// <A href="/wiki/index.php?title=Template:Yield_with&amp;action=edit&amp;redlink=1" class="new" title="Template:Yield with (page does not exist)">Template:Yield with</A> requires some aliases
			parser.error( &quot;Expected one or more aliases&quot; );
		}
	}
</P><P>	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( tag.close ) ) {
		parser.error( (&quot;Expected closing delimiter '&quot; + (tag.close) + &quot;'&quot;) );
	}
</P><P>	return partial;
}
</P><P>function readComment ( parser, tag ) {
	if ( !parser.matchString( '!' ) ) {
		return null;
	}
</P><P>	var index = parser.remaining().indexOf( tag.close );
</P><P>	if ( index !== -1 ) {
		parser.pos += index + tag.close.length;
		return { t: COMMENT };
	}
}
</P><P>function readInterpolator ( parser, tag ) {
	var expression, err;
</P><P>	var start = parser.pos;
</P><P>	// TODO would be good for perf if we could do away with the try-catch
	try {
		expression = readExpressionOrReference( parser, [ tag.close ] );
	} catch ( e ) {
		err = e;
	}
</P><P>	if ( !expression ) {
		if ( parser.str.charAt( start ) === '!' ) {
			// special case - comment
			parser.pos = start;
			return null;
		}
</P><P>		if ( err ) {
			throw err;
		}
	}
</P><P>	if ( !parser.matchString( tag.close ) ) {
		parser.error( (&quot;Expected closing delimiter '&quot; + (tag.close) + &quot;' after reference&quot;) );
</P><P>		if ( !expression ) {
			// special case - comment
			if ( parser.nextChar() === '!' ) {
				return null;
			}
</P><P>			parser.error( &quot;Expected expression or legal reference&quot; );
		}
	}
</P><P>	var interpolator = { t: INTERPOLATOR };
	refineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious
</P><P>	return interpolator;
}
</P><P>function readClosing ( parser, tag ) {
	var start = parser.pos;
</P><P>	if ( !parser.matchString( tag.open ) ) {
		return null;
	}
</P><P>	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( '/' ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	parser.allowWhitespace();
</P><P>	var remaining = parser.remaining();
	var index = remaining.indexOf( tag.close );
</P><P>	if ( index !== -1 ) {
		var closing = {
			t: CLOSING,
			r: remaining.substr( 0, index ).split( ' ' )[0]
		};
</P><P>		parser.pos += index;
</P><P>		if ( !parser.matchString( tag.close ) ) {
			parser.error( (&quot;Expected closing delimiter '&quot; + (tag.close) + &quot;'&quot;) );
		}
</P><P>		return closing;
	}
</P><P>	parser.pos = start;
	return null;
}
</P><P>var elsePattern = /^\s*else\s*/;
</P><P>function readElse ( parser, tag ) {
	var start = parser.pos;
</P><P>	if ( !parser.matchString( tag.open ) ) {
		return null;
	}
</P><P>	if ( !parser.matchPattern( elsePattern ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	if ( !parser.matchString( tag.close ) ) {
		parser.error( (&quot;Expected closing delimiter '&quot; + (tag.close) + &quot;'&quot;) );
	}
</P><P>	return {
		t: ELSE
	};
}
</P><P>var elsePattern$1 = /^\s*elseif\s+/;
</P><P>function readElseIf ( parser, tag ) {
	var start = parser.pos;
</P><P>	if ( !parser.matchString( tag.open ) ) {
		return null;
	}
</P><P>	if ( !parser.matchPattern( elsePattern$1 ) ) {
		parser.pos = start;
		return null;
	}
</P><P>	var expression = readExpression( parser );
</P><P>	if ( !parser.matchString( tag.close ) ) {
		parser.error( (&quot;Expected closing delimiter '&quot; + (tag.close) + &quot;'&quot;) );
	}
</P><P>	return {
		t: ELSEIF,
		x: expression
	};
}
</P><P>var handlebarsBlockCodes = {
	each:    SECTION_EACH,
	if:      SECTION_IF,
	with:    SECTION_IF_WITH,
	unless:  SECTION_UNLESS
};
</P><P>var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;
var keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;
var handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' );
</P><P>function readSection ( parser, tag ) {
	var expression, section, child, children, hasElse, block, unlessBlock, closed, i, expectedClose;
	var aliasOnly = false;
</P><P>	var start = parser.pos;
</P><P>	if ( parser.matchString( '^' ) ) {
		// watch out for parent context refs - <A href="/wiki/index.php?title=Template:%5E%5E/%5E%5E/foo&amp;action=edit&amp;redlink=1" class="new" title="Template:^^/^^/foo (page does not exist)">Template:^^/^^/foo</A>
		if ( parser.matchString( '^/' ) ){
			parser.pos = start;
			return null;
		}
		section = { t: SECTION, f: [], n: SECTION_UNLESS };
	} else if ( parser.matchString( '#' ) ) {
		section = { t: SECTION, f: [] };
</P><P>		if ( parser.matchString( 'partial' ) ) {
			parser.pos = start - parser.standardDelimiters[0].length;
			parser.error( 'Partial definitions can only be at the top level of the template, or immediately inside components' );
		}
</P><P>		if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
			expectedClose = block;
			section.n = handlebarsBlockCodes[ block ];
		}
	} else {
		return null;
	}
</P><P>	parser.allowWhitespace();
</P><P>	if ( block === 'with' ) {
		var aliases = readAliases( parser );
		if ( aliases ) {
			aliasOnly = true;
			section.z = aliases;
			section.t = ALIAS;
		}
	} else if ( block === 'each' ) {
		var alias = readAlias( parser );
		if ( alias ) {
			section.z = [ { n: alias.n, x: { r: '.' } } ];
			expression = alias.x;
		}
	}
</P><P>	if ( !aliasOnly ) {
		if ( !expression ) { expression = readExpression( parser ); }
</P><P>		if ( !expression ) {
			parser.error( 'Expected expression' );
		}
</P><P>		// optional index and key references
		if ( i = parser.matchPattern( indexRefPattern ) ) {
			var extra;
</P><P>			if ( extra = parser.matchPattern( keyIndexRefPattern ) ) {
				section.i = i + ',' + extra;
			} else {
				section.i = i;
			}
		}
</P><P>		if ( !block &amp;&amp; expression.n ) {
			expectedClose = expression.n;
		}
	}
</P><P>	parser.allowWhitespace();
</P><P>	if ( !parser.matchString( tag.close ) ) {
		parser.error( (&quot;Expected closing delimiter '&quot; + (tag.close) + &quot;'&quot;) );
	}
</P><P>	parser.sectionDepth += 1;
	children = section.f;
</P><P>	var pos;
	do {
		pos = parser.pos;
		if ( child = readClosing( parser, tag ) ) {
			if ( expectedClose &amp;&amp; child.r !== expectedClose ) {
				if ( !block ) {
					if ( child.r ) { parser.warn( (&quot;Expected &quot; + (tag.open) + &quot;/&quot; + expectedClose + (tag.close) + &quot; but found &quot; + (tag.open) + &quot;/&quot; + (child.r) + (tag.close)) ); }
				} else {
					parser.pos = pos;
					parser.error( (&quot;Expected &quot; + (tag.open) + &quot;/&quot; + expectedClose + (tag.close)) );
				}
			}
</P><P>			parser.sectionDepth -= 1;
			closed = true;
		}
</P><P>		else if ( !aliasOnly &amp;&amp; ( child = readElseIf( parser, tag ) ) ) {
			if ( section.n === SECTION_UNLESS ) {
				parser.error( '<A href="/wiki/index.php?title=Template:Else&amp;action=edit&amp;redlink=1" class="new" title="Template:Else (page does not exist)">Template:Else</A> not allowed in {{#unless}}' );
			}
</P><P>			if ( hasElse ) {
				parser.error( 'illegal <A href="/wiki/index.php?title=Template:Elseif...&amp;action=edit&amp;redlink=1" class="new" title="Template:Elseif... (page does not exist)">Template:Elseif...</A> after <A href="/wiki/index.php?title=Template:Else&amp;action=edit&amp;redlink=1" class="new" title="Template:Else (page does not exist)">Template:Else</A>' );
			}
</P><P>			if ( !unlessBlock ) {
				unlessBlock = [];
			}
</P><P>			var mustache = {
				t: SECTION,
				n: SECTION_IF,
				f: children = []
			};
			refineExpression( child.x, mustache );
</P><P>			unlessBlock.push( mustache );
		}
</P><P>		else if ( !aliasOnly &amp;&amp; ( child = readElse( parser, tag ) ) ) {
			if ( section.n === SECTION_UNLESS ) {
				parser.error( '<A href="/wiki/index.php?title=Template:Else&amp;action=edit&amp;redlink=1" class="new" title="Template:Else (page does not exist)">Template:Else</A> not allowed in {{#unless}}' );
			}
</P><P>			if ( hasElse ) {
				parser.error( 'there can only be one <A href="/wiki/index.php?title=Template:Else&amp;action=edit&amp;redlink=1" class="new" title="Template:Else (page does not exist)">Template:Else</A> block, at the end of a section' );
			}
</P><P>			hasElse = true;
</P><P>			// use an unless block if there's no elseif
			if ( !unlessBlock ) {
				unlessBlock = [];
			}
</P><P>			unlessBlock.push({
				t: SECTION,
				n: SECTION_UNLESS,
				f: children = []
			});
		}
</P><P>		else {
			child = parser.read( READERS );
</P><P>			if ( !child ) {
				break;
			}
</P><P>			children.push( child );
		}
	} while ( !closed );
</P><P>	if ( unlessBlock ) {
		section.l = unlessBlock;
	}
</P><P>	if ( !aliasOnly ) {
		refineExpression( expression, section );
	}
</P><P>	// TODO if a section is empty it should be discarded. Don't do
	// that here though - we need to clean everything up first, as
	// it may contain removeable whitespace. As a temporary measure,
	// to pass the existing tests, remove empty `f` arrays
	if ( !section.f.length ) {
		delete section.f;
	}
</P><P>	return section;
}
</P><P>var OPEN_COMMENT = <I>;</I></P><P>function readHtmlComment ( parser ) {
	var start = parser.pos;
</P><P>	if ( parser.textOnlyMode || !parser.matchString( OPEN_COMMENT ) ) {
		return null;
	}
</P><P>	var remaining = parser.remaining();
	var endIndex = remaining.indexOf( CLOSE_COMMENT );
</P><P>	if ( endIndex === -1 ) {
		parser.error( 'Illegal HTML - expected closing comment sequence (\'--&gt;\')' );
	}
</P><P>	var content = remaining.substr( 0, endIndex );
	parser.pos += endIndex + 3;
</P><P>	var comment = {
		t: COMMENT,
		c: content
	};
</P><P>	if ( parser.includeLinePositions ) {
		comment.p = parser.getLinePos( start );
	}
</P><P>	return comment;
}
</P><P>var leadingLinebreak = /^[ \t\f\r\n]*\r?\n/;
var trailingLinebreak = /\r?\n[ \t\f\r\n]*$/;
</P><P>var stripStandalones = function ( items ) {
	var i, current, backOne, backTwo, lastSectionItem;
</P><P>	for ( i=1; i&lt;items.length; i+=1 ) {
		current = items[i];
		backOne = items[i-1];
		backTwo = items[i-2];
</P><P>		// if we're at the end of a [text][comment][text] sequence...
		if ( isString( current ) &amp;&amp; isComment( backOne ) &amp;&amp; isString( backTwo ) ) {
</P><P>			// ... and the comment is a standalone (i.e. line breaks either side)...
			if ( trailingLinebreak.test( backTwo ) &amp;&amp; leadingLinebreak.test( current ) ) {
</P><P>				// ... then we want to remove the whitespace after the first line break
				items[i-2] = backTwo.replace( trailingLinebreak, '\n' );
</P><P>				// and the leading line break of the second text token
				items[i] = current.replace( leadingLinebreak, <I> );</I>
			}
		}
</P><P>		// if the current item is a section, and it is preceded by a linebreak, and
		// its first item is a linebreak...
		if ( isSection( current ) &amp;&amp; isString( backOne ) ) {
			if ( trailingLinebreak.test( backOne ) &amp;&amp; isString( current.f[0] ) &amp;&amp; leadingLinebreak.test( current.f[0] ) ) {
				items[i-1] = backOne.replace( trailingLinebreak, '\n' );
				current.f[0] = current.f[0].replace( leadingLinebreak, <I> );</I>
			}
		}
</P><P>		// if the last item was a section, and it is followed by a linebreak, and
		// its last item is a linebreak...
		if ( isString( current ) &amp;&amp; isSection( backOne ) ) {
			lastSectionItem = lastItem( backOne.f );
</P><P>			if ( isString( lastSectionItem ) &amp;&amp; trailingLinebreak.test( lastSectionItem ) &amp;&amp; leadingLinebreak.test( current ) ) {
				backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
				items[i] = current.replace( leadingLinebreak, <I> );</I>
			}
		}
	}
</P><P>	return items;
};
</P><P>function isString ( item ) {
	return typeof item === 'string';
}
</P><P>function isComment ( item ) {
	return item.t === COMMENT || item.t === DELIMCHANGE;
}
</P><P>function isSection ( item ) {
	return ( item.t === SECTION || item.t === INVERTED ) &amp;&amp; item.f;
}
</P><P>var trimWhitespace = function ( items, leadingPattern, trailingPattern ) {
	var item;
</P><P>	if ( leadingPattern ) {
		item = items[0];
		if ( typeof item === 'string' ) {
			item = item.replace( leadingPattern, <I> );</I></P><P>			if ( !item ) {
				items.shift();
			} else {
				items[0] = item;
			}
		}
	}
</P><P>	if ( trailingPattern ) {
		item = lastItem( items );
		if ( typeof item === 'string' ) {
			item = item.replace( trailingPattern, <I> );</I></P><P>			if ( !item ) {
				items.pop();
			} else {
				items[ items.length - 1 ] = item;
			}
		}
	}
};
</P><P>var contiguousWhitespace = /[ \t\f\r\n]+/g;
var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;
var leadingWhitespace$1 = /^[ \t\f\r\n]+/;
var trailingWhitespace = /[ \t\f\r\n]+$/;
var leadingNewLine = /^(?:\r\n|\r|\n)/;
var trailingNewLine = /(?:\r\n|\r|\n)$/;
</P><P>function cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {
	if ( typeof items === 'string' ) { return; }
</P><P>	var i,
		item,
		previousItem,
		nextItem,
		preserveWhitespaceInsideFragment,
		removeLeadingWhitespaceInsideFragment,
		removeTrailingWhitespaceInsideFragment;
</P><P>	// First pass - remove standalones and comments etc
	stripStandalones( items );
</P><P>	i = items.length;
	while ( i-- ) {
		item = items[i];
</P><P>		// Remove delimiter changes, unsafe elements etc
		if ( item.exclude ) {
			items.splice( i, 1 );
		}
</P><P>		// Remove comments, unless we want to keep them
		else if ( stripComments &amp;&amp; item.t === COMMENT ) {
			items.splice( i, 1 );
		}
	}
</P><P>	// If necessary, remove leading and trailing whitespace
	trimWhitespace( items, removeLeadingWhitespace ? leadingWhitespace$1 : null, removeTrailingWhitespace ? trailingWhitespace : null );
</P><P>	i = items.length;
	while ( i-- ) {
		item = items[i];
</P><P>		// Recurse
		if ( item.f ) {
			var isPreserveWhitespaceElement = item.t === ELEMENT &amp;&amp; preserveWhitespaceElements.test( item.e );
			preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;
</P><P>			if ( !preserveWhitespace &amp;&amp; isPreserveWhitespaceElement ) {
				trimWhitespace( item.f, leadingNewLine, trailingNewLine );
			}
</P><P>			if ( !preserveWhitespaceInsideFragment ) {
				previousItem = items[ i - 1 ];
				nextItem = items[ i + 1 ];
</P><P>				// if the previous item was a text item with trailing whitespace,
				// remove leading whitespace inside the fragment
				if ( !previousItem || ( typeof previousItem === 'string' &amp;&amp; trailingWhitespace.test( previousItem ) ) ) {
					removeLeadingWhitespaceInsideFragment = true;
				}
</P><P>				// and vice versa
				if ( !nextItem || ( typeof nextItem === 'string' &amp;&amp; leadingWhitespace$1.test( nextItem ) ) ) {
					removeTrailingWhitespaceInsideFragment = true;
				}
			}
</P><P>			cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
		}
</P><P>		// Split if-else blocks into two (an if, and an unless)
		if ( item.l ) {
			cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
</P><P>			item.l.forEach( function (s) { return s.l = 1; } );
			item.l.unshift( i + 1, 0 );
			items.splice.apply( items, item.l );
			delete item.l; // TODO would be nice if there was a way around this
		}
</P><P>		// Clean up conditional attributes
		if ( item.m ) {
			cleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
			if ( item.m.length &lt; 1 ) { delete item.m; }
		}
	}
</P><P>	// final pass - fuse text nodes together
	i = items.length;
	while ( i-- ) {
		if ( typeof items[i] === 'string' ) {
			if ( typeof items[i+1] === 'string' ) {
				items[i] = items[i] + items[i+1];
				items.splice( i + 1, 1 );
			}
</P><P>			if ( !preserveWhitespace ) {
				items[i] = items[i].replace( contiguousWhitespace, ' ' );
			}
</P><P>			if ( items[i] === <I> ) {</I>
				items.splice( i, 1 );
			}
		}
	}
}
</P><P>var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\&gt;/;
</P><P>function readClosingTag ( parser ) {
	var tag;
</P><P>	var start = parser.pos;
</P><P>	// are we looking at a closing tag?
	if ( !parser.matchString( '&lt;/' ) ) {
		return null;
	}
</P><P>	if ( tag = parser.matchPattern( closingTagPattern ) ) {
		if ( parser.inside &amp;&amp; tag !== parser.inside ) {
			parser.pos = start;
			return null;
		}
</P><P>		return {
			t: CLOSING_TAG,
			e: tag
		};
	}
</P><P>	// We have an illegal closing tag, report it
	parser.pos -= 2;
	parser.error( 'Illegal closing tag' );
}
</P><P>var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
var anchorPattern = /^[a-zA-Z_$][-a-zA-Z0-9_$]*/;
var validTagNameFollower = /^[\s\n\/&gt;]/;
var exclude = { exclude: true };
</P><P>// based on <A rel="nofollow" class="external free" href="http://developers.whatwg.org/syntax.html#syntax-tag-omission">http://developers.whatwg.org/syntax.html#syntax-tag-omission</A>
var disallowedContents = {
	li: [ 'li' ],
	dt: [ 'dt', 'dd' ],
	dd: [ 'dt', 'dd' ],
	p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),
	rt: [ 'rt', 'rp' ],
	rp: [ 'rt', 'rp' ],
	optgroup: [ 'optgroup' ],
	option: [ 'option', 'optgroup' ],
	thead: [ 'tbody', 'tfoot' ],
	tbody: [ 'tbody', 'tfoot' ],
	tfoot: [ 'tbody' ],
	tr: [ 'tr', 'tbody' ],
	td: [ 'td', 'th', 'tr' ],
	th: [ 'td', 'th', 'tr' ]
};
</P><P>function readElement$1 ( parser ) {
	var attribute, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag, anchor;
</P><P>	var start = parser.pos;
</P><P>	if ( parser.inside || parser.inAttribute || parser.textOnlyMode ) {
		return null;
	}
</P><P>	if ( !parser.matchString( '&lt;' ) ) {
		return null;
	}
</P><P>	// if this is a closing tag, abort straight away
	if ( parser.nextChar() === '/' ) {
		return null;
	}
</P><P>	var element = {};
	if ( parser.includeLinePositions ) {
		element.p = parser.getLinePos( start );
	}
</P><P>	// check for doctype decl
	if ( parser.matchString( '!' ) ) {
		element.t = DOCTYPE;
		if ( !parser.matchPattern( /^doctype/i ) ) {
			parser.error( 'Expected DOCTYPE declaration' );
		}
</P><P>		element.a = parser.matchPattern( /^(.+?)&gt;/ );
		return element;
	}
	// check for anchor
	else if ( anchor = parser.matchString( '#' ) ) {
		parser.allowWhitespace();
		element.t = ANCHOR;
		element.n = parser.matchPattern( anchorPattern );
	}
	// otherwise, it's an element/component
	else {
		element.t = ELEMENT;
</P><P>		// element name
		element.e = parser.matchPattern( tagNamePattern );
		if ( !element.e ) {
			return null;
		}
	}
</P><P>	// next character must be whitespace, closing solidus or '&gt;'
	if ( !validTagNameFollower.test( parser.nextChar() ) ) {
		parser.error( 'Illegal tag name' );
	}
</P><P>	parser.allowWhitespace();
</P><P>	parser.inTag = true;
</P><P>	// directives and attributes
	while ( attribute = readMustache( parser ) ) {
		if ( attribute !== false ) {
			if ( !element.m ) { element.m = []; }
			element.m.push( attribute );
		}
</P><P>		parser.allowWhitespace();
	}
</P><P>	parser.inTag = false;
</P><P>	// allow whitespace before closing solidus
	parser.allowWhitespace();
</P><P>	// self-closing solidus?
	if ( parser.matchString( '/' ) ) {
		selfClosing = true;
	}
</P><P>	// closing angle bracket
	if ( !parser.matchString( '&gt;' ) ) {
		return null;
	}
</P><P>	var lowerCaseName = ( element.e || element.n ).toLowerCase();
	var preserveWhitespace = parser.preserveWhitespace;
</P><P>	if ( !selfClosing &amp;&amp; ( anchor || !voidElementNames.test( element.e ) ) ) {
		if ( !anchor ) {
			parser.elementStack.push( lowerCaseName );
</P><P>			// Special case - if we open a script element, further tags should
			// be ignored unless they're a closing script element
			if ( lowerCaseName in parser.interpolate ) {
				parser.inside = lowerCaseName;
			}
		}
</P><P>		children = [];
		partials = Object.create( null );
</P><P>		do {
			pos = parser.pos;
			remaining = parser.remaining();
</P><P>			if ( !remaining ) {
				parser.error( (&quot;Missing end &quot; + (parser.elementStack.length &gt; 1 ? 'tags' : 'tag') + &quot; (&quot; + (parser.elementStack.reverse().map( function (x) { return (&quot;&lt;/&quot; + x + &quot;&gt;&quot;); } ).join( <I> )) + &quot;)&quot;) );</I>
			}
</P>
			// if for example we're in an <LI> element, and we see another
			// </LI><LI> tag, close the first so they become siblings
			if ( !anchor &amp;&amp; !canContain( lowerCaseName, remaining ) ) {
				closed = true;
			}

			// closing tag
			else if ( !anchor &amp;&amp; ( closingTag = readClosingTag( parser ) ) ) {
				closed = true;

				var closingTagName = closingTag.e.toLowerCase();

				// if this *isn't* the closing tag for the current element...
				if ( closingTagName !== lowerCaseName ) {
					// rewind parser
					parser.pos = pos;

					// if it doesn't close a parent tag, error
					if ( !~parser.elementStack.indexOf( closingTagName ) ) {
						var errorMessage = 'Unexpected closing tag';

						// add additional help for void elements, since component names
						// might clash with them
						if ( voidElementNames.test( closingTagName ) ) {
							errorMessage += &quot; (&lt;&quot; + closingTagName + &quot;&gt; is a void element - it cannot contain children)&quot;;
						}

						parser.error( errorMessage );
					}
				}
			}

			else if ( anchor &amp;&amp; readAnchorClose( parser, element.n ) ) {
				closed = true;
			}

			// implicit close by closing section tag. TODO clean this up
			else if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {
				closed = true;
				parser.pos = pos;
			}

			else {
				if ( child = parser.read( PARTIAL_READERS ) ) {
					if ( partials[ child.n ] ) {
						parser.pos = pos;
						parser.error( 'Duplicate partial definition' );
					}

					cleanup( child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );

					partials[ child.n ] = child.f;
					hasPartials = true;
				}

				else {
					if ( child = parser.read( READERS ) ) {
						children.push( child );
					} else {
						closed = true;
					}
				}
			}
		} while ( !closed );

		if ( children.length ) {
			element.f = children;
		}

		if ( hasPartials ) {
			element.p = partials;
		}

		parser.elementStack.pop();
	}

	parser.inside = null;

	if ( parser.sanitizeElements &amp;&amp; parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
		return exclude;
	}

	return element;
}

function canContain ( name, remaining ) {
	var match = /^&lt;([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );
	var disallowed = disallowedContents[ name ];

	if ( !match || !disallowed ) {
		return true;
	}

	return !~disallowed.indexOf( match[1].toLowerCase() );
}

function readAnchorClose ( parser, name ) {
	var pos = parser.pos;
	if ( !parser.matchString( '&lt;/' ) ) {
		return null;
	}

	parser.matchString( '#' );
	parser.allowWhitespace();

	if ( !parser.matchString( name ) ) {
		parser.pos = pos;
		return null;
	}

	parser.allowWhitespace();

	if ( !parser.matchString( '&gt;' ) ) {
		parser.pos = pos;
		return null;
	}

	return true;
}

function readText ( parser ) {
	var index, disallowed, barrier;

	var remaining = parser.remaining();

	if ( parser.textOnlyMode ) {
		disallowed = parser.tags.map( function (t) { return t.open; } );
		disallowed = disallowed.concat( parser.tags.map( function (t) { return '\\' + t.open; } ) );

		index = getLowestIndex( remaining, disallowed );
	} else {
		barrier = parser.inside ? '&lt;/' + parser.inside : '&lt;';

		if ( parser.inside &amp;&amp; !parser.interpolate[ parser.inside ] ) {
			index = remaining.indexOf( barrier );
		} else {
			disallowed = parser.tags.map( function (t) { return t.open; } );
			disallowed = disallowed.concat( parser.tags.map( function (t) { return '\\' + t.open; } ) );

			// <A rel="nofollow" class="external free" href="http://developers.whatwg.org/syntax.html#syntax-attributes">http://developers.whatwg.org/syntax.html#syntax-attributes</A>
			if ( parser.inAttribute === true ) {
				// we're inside an unquoted attribute value
				disallowed.push( &quot;\&quot;&quot;, &quot;'&quot;, &quot;=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, '`' );
			} else if ( parser.inAttribute ) {
				// quoted attribute value
				disallowed.push( parser.inAttribute );
			} else {
				disallowed.push( barrier );
			}

			index = getLowestIndex( remaining, disallowed );
		}
	}

	if ( !index ) {
		return null;
	}

	if ( index === -1 ) {
		index = remaining.length;
	}

	parser.pos += index;

	if ( ( parser.inside &amp;&amp; parser.inside !== 'textarea' ) || parser.textOnlyMode ) {
		return remaining.substr( 0, index );
	} else {
		return decodeCharacterReferences( remaining.substr( 0, index ) );
	}
}

var partialDefinitionSectionPattern = /^\s*#\s*partial\s+/;

function readPartialDefinitionSection ( parser ) {
	var child, closed;

	var start = parser.pos;

	var delimiters = parser.standardDelimiters;

	if ( !parser.matchString( delimiters[0] ) ) {
		return null;
	}

	if ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {
		parser.pos = start;
		return null;
	}

	var name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\-\/]*/ );

	if ( !name ) {
		parser.error( 'expected legal partial name' );
	}

	parser.allowWhitespace();
	if ( !parser.matchString( delimiters[1] ) ) {
		parser.error( (&quot;Expected closing delimiter '&quot; + (delimiters[1]) + &quot;'&quot;) );
	}

	var content = [];

	var open = delimiters[0];
	var close = delimiters[1];

	do {
		if ( child = readClosing( parser, { open: open, close: close }) ) {
			if ( child.r !== 'partial' ) {
				parser.error( (&quot;Expected &quot; + open + &quot;/partial&quot; + close) );
			}

			closed = true;
		}

		else {
			child = parser.read( READERS );

			if ( !child ) {
				parser.error( (&quot;Expected &quot; + open + &quot;/partial&quot; + close) );
			}

			content.push( child );
		}
	} while ( !closed );

	return {
		t: INLINE_PARTIAL,
		n: name,
		f: content
	};
}

function readTemplate ( parser ) {
	var fragment = [];
	var partials = Object.create( null );
	var hasPartials = false;

	var preserveWhitespace = parser.preserveWhitespace;

	while ( parser.pos &lt; parser.str.length ) {
		var pos = parser.pos;
		var item = (void 0), partial = (void 0);

		if ( partial = parser.read( PARTIAL_READERS ) ) {
			if ( partials[ partial.n ] ) {
				parser.pos = pos;
				parser.error( 'Duplicated partial definition' );
			}

			cleanup( partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );

			partials[ partial.n ] = partial.f;
			hasPartials = true;
		} else if ( item = parser.read( READERS ) ) {
			fragment.push( item );
		} else  {
			parser.error( 'Unexpected template content' );
		}
	}

	var result = {
		v: TEMPLATE_VERSION,
		t: fragment
	};

	if ( hasPartials ) {
		result.p = partials;
	}

	return result;
}

function insertExpressions ( obj, expr ) {

	Object.keys( obj ).forEach( function (key) {
		if  ( isExpression( key, obj ) ) { return addTo( obj, expr ); }

		var ref = obj[ key ];
		if ( hasChildren( ref ) ) { insertExpressions( ref, expr ); }
	});
}

function isExpression( key, obj ) {
	return key === 's' &amp;&amp; Array.isArray( obj.r );
}

function addTo( obj, expr ) {
	var s = obj.s;
	var r = obj.r;
	if ( !expr[ s ] ) { expr[ s ] = fromExpression( s, r.length ); }
}

function hasChildren( ref ) {
	return Array.isArray( ref ) || isObject( ref );
}

var shared = {};

// See <A rel="nofollow" class="external free" href="https://github.com/ractivejs/template-spec">https://github.com/ractivejs/template-spec</A> for information
// about the Ractive template specification

var STANDARD_READERS = [ readPartial, readUnescaped, readSection, readInterpolator, readComment ];
var TRIPLE_READERS = [ readTriple ];
var STATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?

var READERS = [ readMustache, readHtmlComment, readElement$1, readText ];
var PARTIAL_READERS = [ readPartialDefinitionSection ];

var defaultInterpolate = [ 'script', 'style', 'template' ];

var StandardParser = Parser.extend({
	init: function init ( str, options ) {
		var this$1 = this;

		var tripleDelimiters = options.tripleDelimiters || shared.defaults.tripleDelimiters;
		var staticDelimiters = options.staticDelimiters || shared.defaults.staticDelimiters;
		var staticTripleDelimiters = options.staticTripleDelimiters || shared.defaults.staticTripleDelimiters;

		this.standardDelimiters = options.delimiters || shared.defaults.delimiters;

		this.tags = [
			{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },
			{ isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },
			{ isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },
			{ isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }
		];

		this.contextLines = options.contextLines || shared.defaults.contextLines;

		this.sortMustacheTags();

		this.sectionDepth = 0;
		this.elementStack = [];

		this.interpolate = Object.create( options.interpolate || shared.defaults.interpolate || {} );
		this.interpolate.textarea = true;
		defaultInterpolate.forEach( function (t) { return this$1.interpolate[ t ] = !options.interpolate || options.interpolate[ t ] !== false; } );

		if ( options.sanitize === true ) {
			options.sanitize = {
				// blacklist from <A rel="nofollow" class="external free" href="https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json">https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json</A>
				elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
				eventAttributes: true
			};
		}

		this.stripComments = options.stripComments !== false;
		this.preserveWhitespace = options.preserveWhitespace;
		this.sanitizeElements = options.sanitize &amp;&amp; options.sanitize.elements;
		this.sanitizeEventAttributes = options.sanitize &amp;&amp; options.sanitize.eventAttributes;
		this.includeLinePositions = options.includeLinePositions;
		this.textOnlyMode = options.textOnlyMode;
		this.csp = options.csp;

		this.transforms = options.transforms || options.parserTransforms;
		if ( this.transforms ) {
			this.transforms = this.transforms.concat( shared.defaults.parserTransforms );
		} else {
			this.transforms = shared.defaults.parserTransforms;
		}
	},

	postProcess: function postProcess ( result ) {
		// special case - empty string
		if ( !result.length ) {
			return { t: [], v: TEMPLATE_VERSION };
		}

		if ( this.sectionDepth &gt; 0 ) {
			this.error( 'A section was left open' );
		}

		cleanup( result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace );

		var transforms = this.transforms;
		if ( transforms.length ) {
			var tlen = transforms.length;
			var walk = function ( fragment ) {
				var len = fragment.length;

				for ( var i = 0; i &lt; len; i++ ) {
					var node = fragment[i];

					if ( node.t === ELEMENT ) {
						for ( var j = 0; j &lt; tlen; j++ ) {
							var res = transforms[j].call( shared.Ractive, node );
							if ( !res ) {
								continue;
							} else if ( res.remove ) {
								fragment.splice( i--, 1 );
								len--;
								break;
							} else if ( res.replace ) {
								if ( Array.isArray( res.replace ) ) {
									fragment.splice.apply( fragment, [ i--, 1 ].concat( res.replace ) );
									len += res.replace.length - 1;
								} else {
									fragment[i--] = node = res.replace;
								}

								break;
							}
						}

						// watch for partials
						if ( node.p ) {
							for ( var k in node.p ) { walk( node.p[k] ); }
						}
					}

					if ( node.f ) { walk( node.f ); }
				}
			};

			// process the root fragment
			walk( result[0].t );

			// watch for root partials
			if ( result[0].p ) {
				for ( var k in result[0].p ) { walk( result[0].p[k] ); }
			}
		}

		if ( this.csp !== false ) {
			var expr = {};
			insertExpressions( result[0].t, expr );
			if ( Object.keys( expr ).length ) { result[0].e = expr; }
		}

		return result[0];
	},

	converters: [
		readTemplate
	],

	sortMustacheTags: function sortMustacheTags () {
		// Sort in order of descending opening delimiter length (longer first),
		// to protect against opening delimiters being substrings of each other
		this.tags.sort( function ( a, b ) {
			return b.open.length - a.open.length;
		});
	}
});

function parse ( template, options ) {
	return new StandardParser( template, options || {} ).result;
}

var parseOptions = [
	'delimiters',
	'tripleDelimiters',
	'staticDelimiters',
	'staticTripleDelimiters',
	'csp',
	'interpolate',
	'preserveWhitespace',
	'sanitize',
	'stripComments',
	'contextLines'
];

var TEMPLATE_INSTRUCTIONS = &quot;Either preparse or use a ractive runtime source that includes the parser. &quot;;

var COMPUTATION_INSTRUCTIONS = &quot;Either include a version of Ractive that can parse or convert your computation strings to functions.&quot;;


function throwNoParse ( method, error, instructions ) {
	if ( !method ) {
		fatal( (&quot;Missing Ractive.parse - cannot parse &quot; + error + &quot;. &quot; + instructions) );
	}
}

function createFunction ( body, length ) {
	throwNoParse( fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS );
	return fromExpression( body, length );
}

function createFunctionFromString ( str, bindTo ) {
	throwNoParse( fromComputationString, 'compution string &quot;${str}&quot;', COMPUTATION_INSTRUCTIONS );
	return fromComputationString( str, bindTo );
}

var parser = {

	fromId: function fromId ( id, options ) {
		if ( !doc ) {
			if ( options &amp;&amp; options.noThrow ) { return; }
			throw new Error( (&quot;Cannot retrieve template #&quot; + id + &quot; as Ractive is not running in a browser.&quot;) );
		}

		if ( id ) { id = id.replace( /^#/, <I> ); }</I>

		var template;

		if ( !( template = doc.getElementById( id ) )) {
			if ( options &amp;&amp; options.noThrow ) { return; }
			throw new Error( (&quot;Could not find template element with id #&quot; + id) );
		}

		if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {
			if ( options &amp;&amp; options.noThrow ) { return; }
			throw new Error( (&quot;Template element with id #&quot; + id + &quot;, must be a &lt;script&gt; element&quot;) );
		}

		return ( 'textContent' in template ? template.textContent : template.innerHTML );

	},

	isParsed: function isParsed ( template) {
		return !( typeof template === 'string' );
	},

	getParseOptions: function getParseOptions ( ractive ) {
		// Could be Ractive or a Component
		if ( ractive.defaults ) { ractive = ractive.defaults; }

		return parseOptions.reduce( function ( val, key ) {
			val[ key ] = ractive[ key ];
			return val;
		}, {});
	},

	parse: function parse$1 ( template, options ) {
		throwNoParse( parse, 'template', TEMPLATE_INSTRUCTIONS );
		var parsed = parse( template, options );
		addFunctions( parsed );
		return parsed;
	},

	parseFor: function parseFor( template, ractive ) {
		return this.parse( template, this.getParseOptions( ractive ) );
	}
};

var templateConfigurator = {
	name: 'template',

	extend: function extend ( Parent, proto, options ) {
		// only assign if exists
		if ( 'template' in options ) {
			var template = options.template;

			if ( typeof template === 'function' ) {
				proto.template = template;
			} else {
				proto.template = parseTemplate( template, proto );
			}
		}
	},

	init: function init ( Parent, ractive, options ) {
		// TODO because of prototypal inheritance, we might just be able to use
		// ractive.template, and not bother passing through the Parent object.
		// At present that breaks the test mocks' expectations
		var template = 'template' in options ? options.template : Parent.prototype.template;
		template = template || { v: TEMPLATE_VERSION, t: [] };

		if ( typeof template === 'function' ) {
			var fn = template;
			template = getDynamicTemplate( ractive, fn );

			ractive._config.template = {
				fn: fn,
				result: template
			};
		}

		template = parseTemplate( template, ractive );

		// TODO the naming of this is confusing - ractive.template refers to [...],
		// but Component.prototype.template refers to {v:1,t:[],p:[]}...
		// it's unnecessary, because the developer never needs to access
		// ractive.template
		ractive.template = template.t;

		if ( template.p ) {
			extendPartials( ractive.partials, template.p );
		}
	},

	reset: function reset ( ractive ) {
		var result = resetValue( ractive );

		if ( result ) {
			var parsed = parseTemplate( result, ractive );

			ractive.template = parsed.t;
			extendPartials( ractive.partials, parsed.p, true );

			return true;
		}
	}
};

function resetValue ( ractive ) {
	var initial = ractive._config.template;

	// If this isn't a dynamic template, there's nothing to do
	if ( !initial || !initial.fn ) {
		return;
	}

	var result = getDynamicTemplate( ractive, initial.fn );

	// TODO deep equality check to prevent unnecessary re-rendering
	// in the case of already-parsed templates
	if ( result !== initial.result ) {
		initial.result = result;
		return result;
	}
}

function getDynamicTemplate ( ractive, fn ) {
	return fn.call( ractive, {
		fromId: parser.fromId,
		isParsed: parser.isParsed,
		parse: function parse ( template, options ) {
			if ( options === void 0 ) options = parser.getParseOptions( ractive );

			return parser.parse( template, options );
		}
	});
}

function parseTemplate ( template, ractive ) {
	if ( typeof template === 'string' ) {
		// parse will validate and add expression functions
		template = parseAsString( template, ractive );
	}
	else {
		// need to validate and add exp for already parsed template
		validate$1( template );
		addFunctions( template );
	}

	return template;
}

function parseAsString ( template, ractive ) {
	// ID of an element containing the template?
	if ( template[0] === '#' ) {
		template = parser.fromId( template );
	}

	return parser.parseFor( template, ractive );
}

function validate$1( template ) {

	// Check that the template even exists
	if ( template == undefined ) {
		throw new Error( (&quot;The template cannot be &quot; + template + &quot;.&quot;) );
	}

	// Check the parsed template has a version at all
	else if ( typeof template.v !== 'number' ) {
		throw new Error( 'The template parser was passed a non-string template, but the template doesn\'t have a version.  Make sure you\'re passing in the template you think you are.' );
	}

	// Check we're using the correct version
	else if ( template.v !== TEMPLATE_VERSION ) {
		throw new Error( (&quot;Mismatched template version (expected &quot; + TEMPLATE_VERSION + &quot;, got &quot; + (template.v) + &quot;) Please ensure you are using the latest version of Ractive.js in your build process as well as in your app&quot;) );
	}
}

function extendPartials ( existingPartials, newPartials, overwrite ) {
	if ( !newPartials ) { return; }

	// TODO there's an ambiguity here - we need to overwrite in the `reset()`
	// case, but not initially...

	for ( var key in newPartials ) {
		if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
			existingPartials[ key ] = newPartials[ key ];
		}
	}
}

var registryNames = [
	'adaptors',
	'components',
	'computed',
	'decorators',
	'easing',
	'events',
	'interpolators',
	'partials',
	'transitions'
];

var registriesOnDefaults = [
	'computed'
];

var Registry = function Registry ( name, useDefaults ) {
	this.name = name;
	this.useDefaults = useDefaults;
};

Registry.prototype.extend = function extend ( Parent, proto, options ) {
	var parent = this.useDefaults ? Parent.defaults : Parent;
	var target = this.useDefaults ? proto : proto.constructor;
	this.configure( parent, target, options );
};

Registry.prototype.init = function init () {
	// noop
};

Registry.prototype.configure = function configure ( Parent, target, options ) {
	var name = this.name;
	var option = options[ name ];

	var registry = Object.create( Parent[name] );

	for ( var key in option ) {
		registry[ key ] = option[ key ];
	}

	target[ name ] = registry;
};

Registry.prototype.reset = function reset ( ractive ) {
	var registry = ractive[ this.name ];
	var changed = false;

	Object.keys( registry ).forEach( function (key) {
		var item = registry[ key ];

		if ( item._fn ) {
			if ( item._fn.isOwner ) {
				registry[key] = item._fn;
			} else {
				delete registry[key];
			}
			changed = true;
		}
	});

	return changed;
};

var registries = registryNames.map( function (name) {
	var putInDefaults = registriesOnDefaults.indexOf(name) &gt; -1;
	return new Registry( name, putInDefaults );
});

function wrap ( parent, name, method ) {
	if ( !/_super/.test( method ) ) { return method; }

	function wrapper () {
		var superMethod = getSuperMethod( wrapper._parent, name );
		var hasSuper = '_super' in this;
		var oldSuper = this._super;

		this._super = superMethod;

		var result = method.apply( this, arguments );

		if ( hasSuper ) {
			this._super = oldSuper;
		} else {
			delete this._super;
		}

		return result;
	}

	wrapper._parent = parent;
	wrapper._method = method;

	return wrapper;
}

function getSuperMethod ( parent, name ) {
	if ( name in parent ) {
		var value = parent[ name ];

		return typeof value === 'function' ?
			value :
			function () { return value; };
	}

	return noop;
}

function getMessage( deprecated, correct, isError ) {
	return &quot;options.&quot; + deprecated + &quot; has been deprecated in favour of options.&quot; + correct + &quot;.&quot;
		+ ( isError ? (&quot; You cannot specify both options, please use options.&quot; + correct + &quot;.&quot;) : <I> );</I>
}

function deprecateOption ( options, deprecatedOption, correct ) {
	if ( deprecatedOption in options ) {
		if( !( correct in options ) ) {
			warnIfDebug( getMessage( deprecatedOption, correct ) );
			options[ correct ] = options[ deprecatedOption ];
		} else {
			throw new Error( getMessage( deprecatedOption, correct, true ) );
		}
	}
}

function deprecate ( options ) {
	deprecateOption( options, 'beforeInit', 'onconstruct' );
	deprecateOption( options, 'init', 'onrender' );
	deprecateOption( options, 'complete', 'oncomplete' );
	deprecateOption( options, 'eventDefinitions', 'events' );

	// Using extend with Component instead of options,
	// like Human.extend( Spider ) means adaptors as a registry
	// gets copied to options. So we have to check if actually an array
	if ( Array.isArray( options.adaptors ) ) {
		deprecateOption( options, 'adaptors', 'adapt' );
	}
}

var custom = {
	adapt: adaptConfigurator,
	css: cssConfigurator,
	data: dataConfigurator,
	template: templateConfigurator
};

var defaultKeys = Object.keys( defaults );

var isStandardKey = makeObj( defaultKeys.filter( function (key) { return !custom[ key ]; } ) );

// blacklisted keys that we don't double extend
var isBlacklisted = makeObj( defaultKeys.concat( registries.map( function (r) { return r.name; } ), [ 'on', 'observe', 'attributes' ] ) );

var order = [].concat(
	defaultKeys.filter( function (key) { return !registries[ key ] &amp;&amp; !custom[ key ]; } ),
	registries,
	//custom.data,
	custom.template,
	custom.css
);

var config = {
	extend: function ( Parent, proto, options ) { return configure( 'extend', Parent, proto, options ); },
	init: function ( Parent, ractive, options ) { return configure( 'init', Parent, ractive, options ); },
	reset: function (ractive) { return order.filter( function (c) { return c.reset &amp;&amp; c.reset( ractive ); } ).map( function (c) { return c.name; } ); }
};

function configure ( method, Parent, target, options ) {
	deprecate( options );

	for ( var key in options ) {
		if ( isStandardKey.hasOwnProperty( key ) ) {
			var value = options[ key ];

			// warn the developer if they passed a function and ignore its value

			// NOTE: we allow some functions on &quot;el&quot; because we duck type element lists
			// and some libraries or ef'ed-up virtual browsers (phantomJS) return a
			// function object as the result of querySelector methods
			if ( key !== 'el' &amp;&amp; typeof value === 'function' ) {
				warnIfDebug( (key + &quot; is a Ractive option that does not expect a function and will be ignored&quot;),
					method === 'init' ? target : null );
			}
			else {
				target[ key ] = value;
			}
		}
	}

	// disallow combination of `append` and `enhance`
	if ( options.append &amp;&amp; options.enhance ) {
		throw new Error( 'Cannot use append and enhance at the same time' );
	}

	registries.forEach( function (registry) {
		registry[ method ]( Parent, target, options );
	});

	adaptConfigurator[ method ]( Parent, target, options );
	templateConfigurator[ method ]( Parent, target, options );
	cssConfigurator[ method ]( Parent, target, options );

	extendOtherMethods( Parent.prototype, target, options );
}

var _super = /\b_super\b/;
function extendOtherMethods ( parent, target, options ) {
	for ( var key in options ) {
		if ( !isBlacklisted[ key ] &amp;&amp; options.hasOwnProperty( key ) ) {
			var member = options[ key ];

			// if this is a method that overwrites a method, wrap it:
			if ( typeof member === 'function' ) {
				if ( key in RactiveProto &amp;&amp; !_super.test( member.toString() ) ) {
					warnIfDebug( (&quot;Overriding Ractive prototype function '&quot; + key + &quot;' without calling the '&quot; + _super + &quot;' method can be very dangerous.&quot;) );
				}
				member = wrap( parent, key, member );
			}

			target[ key ] = member;
		}
	}
}

function makeObj ( array ) {
	var obj = {};
	array.forEach( function (x) { return obj[x] = true; } );
	return obj;
}

var Item = function Item ( options ) {
	this.parentFragment = options.parentFragment;
	this.ractive = options.parentFragment.ractive;

	this.template = options.template;
	this.index = options.index;
	this.type = options.template.t;

	this.dirty = false;
};

Item.prototype.bubble = function bubble () {
	if ( !this.dirty ) {
		this.dirty = true;
		this.parentFragment.bubble();
	}
};

Item.prototype.destroyed = function destroyed () {
	if ( this.fragment ) { this.fragment.destroyed(); }
};

Item.prototype.find = function find () {
	return null;
};

Item.prototype.findComponent = function findComponent () {
	return null;
};

Item.prototype.findNextNode = function findNextNode () {
	return this.parentFragment.findNextNode( this );
};

Item.prototype.shuffled = function shuffled () {
	if ( this.fragment ) { this.fragment.shuffled(); }
};

Item.prototype.valueOf = function valueOf () {
	return this.toString();
};

Item.prototype.findAll = noop;
Item.prototype.findAllComponents = noop;

var ContainerItem = (function (Item) {
	function ContainerItem ( options ) {
		Item.call( this, options );
	}

	if ( Item ) ContainerItem.__proto__ = Item;
	ContainerItem.prototype = Object.create( Item &amp;&amp; Item.prototype );
	ContainerItem.prototype.constructor = ContainerItem;

	ContainerItem.prototype.detach = function detach () {
		return this.fragment ? this.fragment.detach() : createDocumentFragment();
	};

	ContainerItem.prototype.find = function find ( selector ) {
		if ( this.fragment ) {
			return this.fragment.find( selector );
		}
	};

	ContainerItem.prototype.findAll = function findAll ( selector, options ) {
		if ( this.fragment ) {
			this.fragment.findAll( selector, options );
		}
	};

	ContainerItem.prototype.findComponent = function findComponent ( name ) {
		if ( this.fragment ) {
			return this.fragment.findComponent( name );
		}
	};

	ContainerItem.prototype.findAllComponents = function findAllComponents ( name, options ) {
		if ( this.fragment ) {
			this.fragment.findAllComponents( name, options );
		}
	};

	ContainerItem.prototype.firstNode = function firstNode ( skipParent ) {
		return this.fragment &amp;&amp; this.fragment.firstNode( skipParent );
	};

	ContainerItem.prototype.toString = function toString ( escape ) {
		return this.fragment ? this.fragment.toString( escape ) : <I>;</I>
	};

	return ContainerItem;
}(Item));

var ComputationChild = (function (Model$$1) {
	function ComputationChild ( parent, key ) {
		Model$$1.call( this, parent, key );

		this.isReadonly = !this.root.ractive.syncComputedChildren;
		this.dirty = true;
	}

	if ( Model$$1 ) ComputationChild.__proto__ = Model$$1;
	ComputationChild.prototype = Object.create( Model$$1 &amp;&amp; Model$$1.prototype );
	ComputationChild.prototype.constructor = ComputationChild;

	ComputationChild.prototype.applyValue = function applyValue ( value ) {
		Model$$1.prototype.applyValue.call( this, value );

		if ( !this.isReadonly ) {
			var source = this.parent;
			// computed models don't have a shuffle method
			while ( source &amp;&amp; source.shuffle ) {
				source = source.parent;
			}

			if ( source ) {
				source.dependencies.forEach( mark );
			}
		}
	};

	ComputationChild.prototype.get = function get ( shouldCapture ) {
		if ( shouldCapture ) { capture( this ); }

		if ( this.dirty ) {
			this.dirty = false;
			var parentValue = this.parent.get();
			this.value = parentValue ? parentValue[ this.key ] : undefined;
		}

		return this.value;
	};

	ComputationChild.prototype.handleChange = function handleChange$1 () {
		this.dirty = true;

		if ( this.boundValue ) { this.boundValue = null; }

		this.links.forEach( marked );
		this.deps.forEach( handleChange );
		this.children.forEach( handleChange );
	};

	ComputationChild.prototype.joinKey = function joinKey ( key ) {
		if ( key === undefined || key === <I> ) { return this; }</I>

		if ( !this.childByKey.hasOwnProperty( key ) ) {
			var child = new ComputationChild( this, key );
			this.children.push( child );
			this.childByKey[ key ] = child;
		}

		return this.childByKey[ key ];
	};

	return ComputationChild;
}(Model));

/* global console */
/* eslint no-console:&quot;off&quot; */

var Computation = (function (Model$$1) {
	function Computation ( viewmodel, signature, key ) {
		Model$$1.call( this, null, null );

		this.root = this.parent = viewmodel;
		this.signature = signature;

		this.key = key; // not actually used, but helps with debugging
		this.isExpression = key &amp;&amp; key[0] === '@';

		this.isReadonly = !this.signature.setter;

		this.context = viewmodel.computationContext;

		this.dependencies = [];

		this.children = [];
		this.childByKey = {};

		this.deps = [];

		this.dirty = true;

		// TODO: is there a less hackish way to do this?
		this.shuffle = undefined;
	}

	if ( Model$$1 ) Computation.__proto__ = Model$$1;
	Computation.prototype = Object.create( Model$$1 &amp;&amp; Model$$1.prototype );
	Computation.prototype.constructor = Computation;

	Computation.prototype.get = function get ( shouldCapture ) {
		if ( shouldCapture ) { capture( this ); }

		if ( this.dirty ) {
			this.dirty = false;
			var old = this.value;
			this.value = this.getValue();
			if ( !isEqual( old, this.value ) ) { this.notifyUpstream(); }
			if ( this.wrapper ) { this.newWrapperValue = this.value; }
			this.adapt();
		}

		// if capturing, this value needs to be unwrapped because it's for external use
		return maybeBind( this, shouldCapture &amp;&amp; this.wrapper ? this.wrapperValue : this.value );
	};

	Computation.prototype.getValue = function getValue () {
		startCapturing();
		var result;

		try {
			result = this.signature.getter.call( this.context );
		} catch ( err ) {
			warnIfDebug( (&quot;Failed to compute &quot; + (this.getKeypath()) + &quot;: &quot; + (err.message || err)) );

			// TODO this is all well and good in Chrome, but...
			// ...also, should encapsulate this stuff better, and only
			// show it if Ractive.DEBUG
			if ( hasConsole ) {
				if ( console.groupCollapsed ) { console.groupCollapsed( '%cshow details', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;' ); }
				var sig = this.signature;
				console.error( ((err.name) + &quot;: &quot; + (err.message) + &quot;\n\n&quot; + (sig.getterString) + (sig.getterUseStack ? '\n\n' + err.stack : <I>)) );</I>
				if ( console.groupCollapsed ) { console.groupEnd(); }
			}
		}

		var dependencies = stopCapturing();
		this.setDependencies( dependencies );

		return result;
	};

	Computation.prototype.mark = function mark () {
		this.handleChange();
	};

	Computation.prototype.rebind = function rebind ( next, previous ) {
		// computations will grab all of their deps again automagically
		if ( next !== previous ) { this.handleChange(); }
	};

	Computation.prototype.set = function set ( value ) {
		if ( this.isReadonly ) {
			throw new Error( (&quot;Cannot set read-only computed value '&quot; + (this.key) + &quot;'&quot;) );
		}

		this.signature.setter( value );
		this.mark();
	};

	Computation.prototype.setDependencies = function setDependencies ( dependencies ) {
		var this$1 = this;

		// unregister any soft dependencies we no longer have
		var i = this.dependencies.length;
		while ( i-- ) {
			var model = this$1.dependencies[i];
			if ( !~dependencies.indexOf( model ) ) { model.unregister( this$1 ); }
		}

		// and add any new ones
		i = dependencies.length;
		while ( i-- ) {
			var model$1 = dependencies[i];
			if ( !~this$1.dependencies.indexOf( model$1 ) ) { model$1.register( this$1 ); }
		}

		this.dependencies = dependencies;
	};

	Computation.prototype.teardown = function teardown () {
		var this$1 = this;

		var i = this.dependencies.length;
		while ( i-- ) {
			if ( this$1.dependencies[i] ) { this$1.dependencies[i].unregister( this$1 ); }
		}
		if ( this.root.computations[this.key] === this ) { delete this.root.computations[this.key]; }
		Model$$1.prototype.teardown.call(this);
	};

	return Computation;
}(Model));

var prototype$1 = Computation.prototype;
var child = ComputationChild.prototype;
prototype$1.handleChange = child.handleChange;
prototype$1.joinKey = child.joinKey;

var ExpressionProxy = (function (Model$$1) {
	function ExpressionProxy ( fragment, template ) {
		var this$1 = this;

		Model$$1.call( this, fragment.ractive.viewmodel, null );

		this.fragment = fragment;
		this.template = template;

		this.isReadonly = true;
		this.dirty = true;

		this.fn = getFunction( template.s, template.r.length );

		this.models = this.template.r.map( function (ref) {
			return resolveReference( this$1.fragment, ref );
		});
		this.dependencies = [];

		this.shuffle = undefined;

		this.bubble();
	}

	if ( Model$$1 ) ExpressionProxy.__proto__ = Model$$1;
	ExpressionProxy.prototype = Object.create( Model$$1 &amp;&amp; Model$$1.prototype );
	ExpressionProxy.prototype.constructor = ExpressionProxy;

	ExpressionProxy.prototype.bubble = function bubble ( actuallyChanged ) {
		if ( actuallyChanged === void 0 ) actuallyChanged = true;

		// refresh the keypath
		this.keypath = undefined;

		if ( actuallyChanged ) {
			this.handleChange();
		}
	};

	ExpressionProxy.prototype.getKeypath = function getKeypath () {
		var this$1 = this;

		if ( !this.template ) { return '@undefined'; }
		if ( !this.keypath ) {
			this.keypath = '@' + this.template.s.replace( /_(\d+)/g, function ( match, i ) {
				if ( i &gt;= this$1.models.length ) { return match; }

				var model = this$1.models[i];
				return model ? model.getKeypath() : '@undefined';
			});
		}

		return this.keypath;
	};

	ExpressionProxy.prototype.getValue = function getValue () {
		var this$1 = this;

		startCapturing();
		var result;

		try {
			var params = this.models.map( function (m) { return m ? m.get( true ) : undefined; } );
			result = this.fn.apply( this.fragment.ractive, params );
		} catch ( err ) {
			warnIfDebug( (&quot;Failed to compute &quot; + (this.getKeypath()) + &quot;: &quot; + (err.message || err)) );
		}

		var dependencies = stopCapturing();
		// remove missing deps
		this.dependencies.filter( function (d) { return !~dependencies.indexOf( d ); } ).forEach( function (d) {
			d.unregister( this$1 );
			removeFromArray( this$1.dependencies, d );
		});
		// register new deps
		dependencies.filter( function (d) { return !~this$1.dependencies.indexOf( d ); } ).forEach( function (d) {
			d.register( this$1 );
			this$1.dependencies.push( d );
		});

		return result;
	};

	ExpressionProxy.prototype.rebind = function rebind ( next, previous, safe ) {
		var idx = this.models.indexOf( previous );

		if ( ~idx ) {
			next = rebindMatch( this.template.r[idx], next, previous );
			if ( next !== previous ) {
				previous.unregister( this );
				this.models.splice( idx, 1, next );
				if ( next ) { next.addShuffleRegister( this, 'mark' ); }
			}
		}
		this.bubble( !safe );
	};

	ExpressionProxy.prototype.retrieve = function retrieve () {
		return this.get();
	};

	ExpressionProxy.prototype.teardown = function teardown () {
		var this$1 = this;

		this.unbind();
		this.fragment = undefined;
		if ( this.dependencies ) { this.dependencies.forEach( function (d) { return d.unregister( this$1 ); } ); }
		Model$$1.prototype.teardown.call(this);
	};

	ExpressionProxy.prototype.unreference = function unreference () {
		Model$$1.prototype.unreference.call(this);
		if ( !this.deps.length &amp;&amp; !this.refs ) { this.teardown(); }
	};

	ExpressionProxy.prototype.unregister = function unregister ( dep ) {
		Model$$1.prototype.unregister.call( this, dep );
		if ( !this.deps.length &amp;&amp; !this.refs ) { this.teardown(); }
	};

	return ExpressionProxy;
}(Model));

var prototype = ExpressionProxy.prototype;
var computation = Computation.prototype;
prototype.get = computation.get;
prototype.handleChange = computation.handleChange;
prototype.joinKey = computation.joinKey;
prototype.mark = computation.mark;
prototype.unbind = noop;

var ReferenceExpressionChild = (function (Model$$1) {
	function ReferenceExpressionChild ( parent, key ) {
		Model$$1.call ( this, parent, key );
	}

	if ( Model$$1 ) ReferenceExpressionChild.__proto__ = Model$$1;
	ReferenceExpressionChild.prototype = Object.create( Model$$1 &amp;&amp; Model$$1.prototype );
	ReferenceExpressionChild.prototype.constructor = ReferenceExpressionChild;

	ReferenceExpressionChild.prototype.applyValue = function applyValue ( value ) {
		if ( isEqual( value, this.value ) ) { return; }

		var parent = this.parent;
		var keys = [ this.key ];
		while ( parent ) {
			if ( parent.base ) {
				var target = parent.model.joinAll( keys );
				target.applyValue( value );
				break;
			}

			keys.unshift( parent.key );

			parent = parent.parent;
		}
	};

	ReferenceExpressionChild.prototype.get = function get ( shouldCapture, opts ) {
		this.value = this.retrieve();
		return Model$$1.prototype.get.call( this, shouldCapture, opts );
	};

	ReferenceExpressionChild.prototype.joinKey = function joinKey ( key ) {
		if ( key === undefined || key === <I> ) { return this; }</I>

		if ( !this.childByKey.hasOwnProperty( key ) ) {
			var child = new ReferenceExpressionChild( this, key );
			this.children.push( child );
			this.childByKey[ key ] = child;
		}

		return this.childByKey[ key ];
	};

	ReferenceExpressionChild.prototype.retrieve = function retrieve () {
		var parent = this.parent.get();
		return parent &amp;&amp; parent[ this.key ];
	};

	return ReferenceExpressionChild;
}(Model));

var ReferenceExpressionProxy = (function (Model$$1) {
	function ReferenceExpressionProxy ( fragment, template ) {
		var this$1 = this;

		Model$$1.call( this, null, null );
		this.dirty = true;
		this.root = fragment.ractive.viewmodel;
		this.template = template;

		this.base = resolve( fragment, template );

		var intermediary = this.intermediary = {
			handleChange: function () { return this$1.handleChange(); },
			rebind: function ( next, previous ) {
				if ( previous === this$1.base ) {
					next = rebindMatch( template, next, previous );
					if ( next !== this$1.base ) {
						this$1.base.unregister( intermediary );
						this$1.base = next;
					}
				} else {
					var idx = this$1.members.indexOf( previous );
					if ( ~idx ) {
						// only direct references will rebind... expressions handle themselves
						next = rebindMatch( template.m[idx].n, next, previous );
						if ( next !== this$1.members[idx] ) {
							this$1.members.splice( idx, 1, next );
						}
					}
				}

				if ( next !== previous ) { previous.unregister( intermediary ); }
				if ( next ) { next.addShuffleTask( function () { return next.register( intermediary ); } ); }

				this$1.bubble();
			}
		};

		this.members = template.m.map( function ( template ) {
			if ( typeof template === 'string' ) {
				return { get: function () { return template; } };
			}

			var model;

			if ( template.t === REFERENCE ) {
				model = resolveReference( fragment, template.n );
				model.register( intermediary );

				return model;
			}

			model = new ExpressionProxy( fragment, template );
			model.register( intermediary );
			return model;
		});

		this.bubble();
	}

	if ( Model$$1 ) ReferenceExpressionProxy.__proto__ = Model$$1;
	ReferenceExpressionProxy.prototype = Object.create( Model$$1 &amp;&amp; Model$$1.prototype );
	ReferenceExpressionProxy.prototype.constructor = ReferenceExpressionProxy;

	ReferenceExpressionProxy.prototype.bubble = function bubble () {
		if ( !this.base ) { return; }
		if ( !this.dirty ) { this.handleChange(); }
	};

	ReferenceExpressionProxy.prototype.get = function get ( shouldCapture ) {
		if ( this.dirty ) {
			this.bubble();

			var keys = this.members.map( function (m) { return escapeKey( String( m.get() ) ); } );
			var model = this.base.joinAll( keys );

			if ( model !== this.model ) {
				if ( this.model ) {
					this.model.unregister( this );
					this.model.unregisterTwowayBinding( this );
				}

				this.model = model;
				this.parent = model.parent;
				this.model.register( this );
				this.model.registerTwowayBinding( this );

				if ( this.keypathModel ) { this.keypathModel.handleChange(); }
			}

			this.value = this.model.get( shouldCapture );
			this.dirty = false;
			this.mark();
			return this.value;
		} else {
			return this.model ? this.model.get( shouldCapture ) : undefined;
		}
	};

	// indirect two-way bindings
	ReferenceExpressionProxy.prototype.getValue = function getValue () {
		var this$1 = this;

		this.value = this.model ? this.model.get() : undefined;

		var i = this.bindings.length;
		while ( i-- ) {
			var value = this$1.bindings[i].getValue();
			if ( value !== this$1.value ) { return value; }
		}

		// check one-way bindings
		var oneway = findBoundValue( this.deps );
		if ( oneway ) { return oneway.value; }

		return this.value;
	};

	ReferenceExpressionProxy.prototype.getKeypath = function getKeypath () {
		return this.model ? this.model.getKeypath() : '@undefined';
	};

	ReferenceExpressionProxy.prototype.handleChange = function handleChange$$1 () {
		this.dirty = true;
		this.mark();
	};

	ReferenceExpressionProxy.prototype.joinKey = function joinKey ( key ) {
		if ( key === undefined || key === <I> ) { return this; }</I>

		if ( !this.childByKey.hasOwnProperty( key ) ) {
			var child = new ReferenceExpressionChild( this, key );
			this.children.push( child );
			this.childByKey[ key ] = child;
		}

		return this.childByKey[ key ];
	};

	ReferenceExpressionProxy.prototype.mark = function mark$1 () {
		if ( this.dirty ) {
			this.deps.forEach( handleChange );
		}

		this.links.forEach( marked );
		this.children.forEach( mark );
	};

	ReferenceExpressionProxy.prototype.retrieve = function retrieve () {
		return this.value;
	};

	ReferenceExpressionProxy.prototype.set = function set ( value ) {
		this.model.set( value );
	};

	ReferenceExpressionProxy.prototype.teardown = function teardown$$1 () {
		var this$1 = this;

		if ( this.model ) {
			this.model.unregister( this );
			this.model.unregisterTwowayBinding( this );
		}
		if ( this.members ) {
			this.members.forEach( function (m) { return m &amp;&amp; m.unregister &amp;&amp; m.unregister( this$1 ); } );
		}
	};

	ReferenceExpressionProxy.prototype.unreference = function unreference () {
		Model$$1.prototype.unreference.call(this);
		if ( !this.deps.length &amp;&amp; !this.refs ) { this.teardown(); }
	};

	ReferenceExpressionProxy.prototype.unregister = function unregister ( dep ) {
		Model$$1.prototype.unregister.call( this, dep );
		if ( !this.deps.length &amp;&amp; !this.refs ) { this.teardown(); }
	};

	return ReferenceExpressionProxy;
}(Model));

ReferenceExpressionProxy.prototype.rebind = noop;

function resolve ( fragment, template ) {
	if ( template.r ) {
		return resolveReference( fragment, template.r );
	}

	else if ( template.x ) {
		return new ExpressionProxy( fragment, template.x );
	}

	else if ( template.rx ) {
		return new ReferenceExpressionProxy( fragment, template.rx );
	}
}

function resolveAliases( aliases, fragment ) {
	var resolved = {};

	for ( var i = 0; i &lt; aliases.length; i++ ) {
		resolved[ aliases[i].n ] = resolve( fragment, aliases[i].x );
	}

	for ( var k in resolved ) {
		resolved[k].reference();
	}

	return resolved;
}

var Alias = (function (ContainerItem$$1) {
	function Alias ( options ) {
		ContainerItem$$1.call( this, options );

		this.fragment = null;
	}

	if ( ContainerItem$$1 ) Alias.__proto__ = ContainerItem$$1;
	Alias.prototype = Object.create( ContainerItem$$1 &amp;&amp; ContainerItem$$1.prototype );
	Alias.prototype.constructor = Alias;

	Alias.prototype.bind = function bind () {
		this.fragment = new Fragment({
			owner: this,
			template: this.template.f
		});

		this.fragment.aliases = resolveAliases( this.template.z, this.parentFragment );
		this.fragment.bind();
	};

	Alias.prototype.render = function render ( target ) {
		this.rendered = true;
		if ( this.fragment ) { this.fragment.render( target ); }
	};

	Alias.prototype.unbind = function unbind () {
		var this$1 = this;

		for ( var k in this$1.fragment.aliases ) {
			this$1.fragment.aliases[k].unreference();
		}

		this.fragment.aliases = {};
		if ( this.fragment ) { this.fragment.unbind(); }
	};

	Alias.prototype.unrender = function unrender ( shouldDestroy ) {
		if ( this.rendered &amp;&amp; this.fragment ) { this.fragment.unrender( shouldDestroy ); }
		this.rendered = false;
	};

	Alias.prototype.update = function update () {
		if ( this.dirty ) {
			this.dirty = false;
			this.fragment.update();
		}
	};

	return Alias;
}(ContainerItem));

var space = /\s+/;

function readStyle ( css ) {
	if ( typeof css !== 'string' ) { return {}; }

	return cleanCss( css, function ( css, reconstruct ) {
		return css.split( ';' )
			.filter( function (rule) { return !!rule.trim(); } )
			.map( reconstruct )
			.reduce(function ( rules, rule ) {
				var i = rule.indexOf(':');
				var name = rule.substr( 0, i ).trim();
				rules[ name ] = rule.substr( i + 1 ).trim();
				return rules;
			}, {});
	});
}

function readClass ( str ) {
	var list = str.split( space );

  // remove any empty entries
	var i = list.length;
	while ( i-- ) {
		if ( !list[i] ) { list.splice( i, 1 ); }
	}

	return list;
}

var hyphenateCamel = function ( camelCaseStr ) {
	return camelCaseStr.replace( /([A-Z])/g, function ( match, $1 ) {
		return '-' + $1.toLowerCase();
	});
};

var textTypes = [ undefined, 'text', 'search', 'url', 'email', 'hidden', 'password', 'search', 'reset', 'submit' ];

function getUpdateDelegate ( attribute ) {
	var element = attribute.element;
	var name = attribute.name;

	if ( name === 'value' ) {
		if ( attribute.interpolator ) { attribute.interpolator.bound = true; }

		// special case - selects
		if ( element.name === 'select' &amp;&amp; name === 'value' ) {
			return element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;
		}

		if ( element.name === 'textarea' ) { return updateStringValue; }

		// special case - contenteditable
		if ( element.getAttribute( 'contenteditable' ) != null ) { return updateContentEditableValue; }

		// special case - &lt;input&gt;
		if ( element.name === 'input' ) {
			var type = element.getAttribute( 'type' );

			// type='file' value='<A href="/wiki/index.php?title=Template:FileList&amp;action=edit&amp;redlink=1" class="new" title="Template:FileList (page does not exist)">Template:FileList</A>'&gt;
			if ( type === 'file' ) { return noop; } // read-only

			// type='radio' name='<A href="/wiki/index.php?title=Template:Twoway&amp;action=edit&amp;redlink=1" class="new" title="Template:Twoway (page does not exist)">Template:Twoway</A>'
			if ( type === 'radio' &amp;&amp; element.binding &amp;&amp; element.binding.attribute.name === 'name' ) { return updateRadioValue; }

			if ( ~textTypes.indexOf( type ) ) { return updateStringValue; }
		}

		return updateValue;
	}

	var node = element.node;

	// special case - &lt;input type='radio' name='<A href="/wiki/index.php?title=Template:Twoway&amp;action=edit&amp;redlink=1" class="new" title="Template:Twoway (page does not exist)">Template:Twoway</A>' value='foo'&gt;
	if ( attribute.isTwoway &amp;&amp; name === 'name' ) {
		if ( node.type === 'radio' ) { return updateRadioName; }
		if ( node.type === 'checkbox' ) { return updateCheckboxName; }
	}

	if ( name === 'style' ) { return updateStyleAttribute; }

	if ( name.indexOf( 'style-' ) === 0 ) { return updateInlineStyle; }

	// special case - class names. IE fucks things up, again
	if ( name === 'class' &amp;&amp; ( !node.namespaceURI || node.namespaceURI === html ) ) { return updateClassName; }

	if ( name.indexOf( 'class-' ) === 0 ) { return updateInlineClass; }

	if ( attribute.isBoolean ) {
		var type$1 = element.getAttribute( 'type' );
		if ( attribute.interpolator &amp;&amp; name === 'checked' &amp;&amp; ( type$1 === 'checkbox' || type$1 === 'radio' ) ) { attribute.interpolator.bound = true; }
		return updateBoolean;
	}

	if ( attribute.namespace &amp;&amp; attribute.namespace !== attribute.node.namespaceURI ) { return updateNamespacedAttribute; }

	return updateAttribute;
}

function updateMultipleSelectValue ( reset ) {
	var value = this.getValue();

	if ( !Array.isArray( value ) ) { value = [ value ]; }

	var options = this.node.options;
	var i = options.length;

	if ( reset ) {
		while ( i-- ) { options[i].selected = false; }
	} else {
		while ( i-- ) {
			var option = options[i];
			var optionValue = option._ractive ?
				option._ractive.value :
				option.value; // options inserted via a triple don't have _ractive

			option.selected = arrayContains( value, optionValue );
		}
	}
}

function updateSelectValue ( reset ) {
	var value = this.getValue();

	if ( !this.locked ) { // TODO is locked still a thing?
		this.node._ractive.value = value;

		var options = this.node.options;
		var i = options.length;
		var wasSelected = false;

		if ( reset ) {
			while ( i-- ) { options[i].selected = false; }
		} else {
			while ( i-- ) {
				var option = options[i];
				var optionValue = option._ractive ?
					option._ractive.value :
					option.value; // options inserted via a triple don't have _ractive
				if ( option.disabled &amp;&amp; option.selected ) { wasSelected = true; }

				if ( optionValue == value ) { // double equals as we may be comparing numbers with strings
					option.selected = true;
					return;
				}
			}
		}

		if ( !wasSelected ) { this.node.selectedIndex = -1; }
	}
}


function updateContentEditableValue ( reset ) {
	var value = this.getValue();

	if ( !this.locked ) {
		if ( reset ) { this.node.innerHTML = <I>; }</I>
		else { this.node.innerHTML = value === undefined ? <I> : value; }</I>
	}
}

function updateRadioValue ( reset ) {
	var node = this.node;
	var wasChecked = node.checked;

	var value = this.getValue();

	if ( reset ) { return node.checked = false; }

	//node.value = this.element.getAttribute( 'value' );
	node.value = this.node._ractive.value = value;
	node.checked = this.element.compare( value, this.element.getAttribute( 'name' ) );

	// This is a special case - if the input was checked, and the value
	// changed so that it's no longer checked, the twoway binding is
	// most likely out of date. To fix it we have to jump through some
	// hoops... this is a little kludgy but it works
	if ( wasChecked &amp;&amp; !node.checked &amp;&amp; this.element.binding &amp;&amp; this.element.binding.rendered ) {
		this.element.binding.group.model.set( this.element.binding.group.getValue() );
	}
}

function updateValue ( reset ) {
	if ( !this.locked ) {
		if ( reset ) {
			this.node.removeAttribute( 'value' );
			this.node.value = this.node._ractive.value = null;
		} else {
			var value = this.getValue();

			this.node.value = this.node._ractive.value = value;
			this.node.setAttribute( 'value', safeToStringValue( value ) );
		}
	}
}

function updateStringValue ( reset ) {
	if ( !this.locked ) {
		if ( reset ) {
			this.node._ractive.value = <I>;</I>
			this.node.removeAttribute( 'value' );
		} else {
			var value = this.getValue();

			this.node._ractive.value = value;

			this.node.value = safeToStringValue( value );
			this.node.setAttribute( 'value', safeToStringValue( value ) );
		}
	}
}

function updateRadioName ( reset ) {
	if ( reset ) { this.node.checked = false; }
	else { this.node.checked = this.element.compare( this.getValue(), this.element.binding.getValue() ); }
}

function updateCheckboxName ( reset ) {
	var ref = this;
	var element = ref.element;
	var node = ref.node;
	var binding = element.binding;

	var value = this.getValue();
	var valueAttribute = element.getAttribute( 'value' );

	if ( reset ) {
		// TODO: WAT?
	}

	if ( !Array.isArray( value ) ) {
		binding.isChecked = node.checked = element.compare( value, valueAttribute );
	} else {
		var i = value.length;
		while ( i-- ) {
			if ( element.compare ( valueAttribute, value[i] ) ) {
				binding.isChecked = node.checked = true;
				return;
			}
		}
		binding.isChecked = node.checked = false;
	}
}

function updateStyleAttribute ( reset ) {
	var props = reset ? {} : readStyle( this.getValue() || <I> );</I>
	var style = this.node.style;
	var keys = Object.keys( props );
	var prev = this.previous || [];

	var i = 0;
	while ( i &lt; keys.length ) {
		if ( keys[i] in style ) {
			var safe = props[ keys[i] ].replace( '!important', <I> );</I>
			style.setProperty( keys[i], safe, safe.length !== props[ keys[i] ].length ? 'important' : <I> );</I>
		}
		i++;
	}

	// remove now-missing attrs
	i = prev.length;
	while ( i-- ) {
		if ( !~keys.indexOf( prev[i] ) &amp;&amp; prev[i] in style ) { style.setProperty( prev[i], <I>, </I> ); }
	}

	this.previous = keys;
}

function updateInlineStyle ( reset ) {
	if ( !this.style ) {
		this.style = hyphenateCamel( this.name.substr( 6 ) );
	}

	var value = reset ? <I> : safeToStringValue( this.getValue() );</I>
	var safe = value.replace( '!important', <I> );</I>
	this.node.style.setProperty( this.style, safe, safe.length !== value.length ? 'important' : <I> );</I>
}

function updateClassName ( reset ) {
	var value = reset ? [] : readClass( safeToStringValue( this.getValue() ) );

	// watch out for werdo svg elements
	var cls = this.node.className;
	cls = cls.baseVal !== undefined ? cls.baseVal : cls;

	var attr = readClass( cls );
	var prev = this.previous || attr.slice( 0 );

	var className = value.concat( attr.filter( function (c) { return !~prev.indexOf( c ); } ) ).join( ' ' );

	if ( className !== cls ) {
		if ( typeof this.node.className !== 'string' ) {
			this.node.className.baseVal = className;
		} else {
			this.node.className = className;
		}
	}

	this.previous = value;
}

function updateInlineClass ( reset ) {
	var name = this.name.substr( 6 );

	// watch out for werdo svg elements
	var cls = this.node.className;
	cls = cls.baseVal !== undefined ? cls.baseVal : cls;

	var attr = readClass( cls );
	var value = reset ? false : this.getValue();

	if ( !this.inlineClass ) { this.inlineClass = name; }

	if ( value &amp;&amp; !~attr.indexOf( name ) ) { attr.push( name ); }
	else if ( !value &amp;&amp; ~attr.indexOf( name ) ) { attr.splice( attr.indexOf( name ), 1 ); }

	if ( typeof this.node.className !== 'string' ) {
		this.node.className.baseVal = attr.join( ' ' );
	} else {
		this.node.className = attr.join( ' ' );
	}
}

function updateBoolean ( reset ) {
	// with two-way binding, only update if the change wasn't initiated by the user
	// otherwise the cursor will often be sent to the wrong place
	if ( !this.locked ) {
		if ( reset ) {
			if ( this.useProperty ) { this.node[ this.propertyName ] = false; }
			this.node.removeAttribute( this.propertyName );
		} else {
			if ( this.useProperty ) {
				this.node[ this.propertyName ] = this.getValue();
			} else {
				if ( this.getValue() ) {
					this.node.setAttribute( this.propertyName, <I> );</I>
				} else {
					this.node.removeAttribute( this.propertyName );
				}
			}
		}
	}
}

function updateAttribute ( reset ) {
	if ( reset ) { this.node.removeAttribute( this.name ); }
	else { this.node.setAttribute( this.name, safeToStringValue( this.getString() ) ); }
}

function updateNamespacedAttribute ( reset ) {
	if ( reset ) { this.node.removeAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ) ); }
	else { this.node.setAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ), safeToStringValue( this.getString() ) ); }
}

var propertyNames = {
	'accept-charset': 'acceptCharset',
	accesskey: 'accessKey',
	bgcolor: 'bgColor',
	class: 'className',
	codebase: 'codeBase',
	colspan: 'colSpan',
	contenteditable: 'contentEditable',
	datetime: 'dateTime',
	dirname: 'dirName',
	for: 'htmlFor',
	'http-equiv': 'httpEquiv',
	ismap: 'isMap',
	maxlength: 'maxLength',
	novalidate: 'noValidate',
	pubdate: 'pubDate',
	readonly: 'readOnly',
	rowspan: 'rowSpan',
	tabindex: 'tabIndex',
	usemap: 'useMap'
};

var div$1 = doc ? createElement( 'div' ) : null;

var attributes = false;
function inAttributes() { return attributes; }
function doInAttributes( fn ) {
	attributes = true;
	fn();
	attributes = false;
}

var ConditionalAttribute = (function (Item$$1) {
	function ConditionalAttribute ( options ) {
		Item$$1.call( this, options );

		this.attributes = [];

		this.owner = options.owner;

		this.fragment = new Fragment({
			ractive: this.ractive,
			owner: this,
			template: this.template
		});
		// this fragment can't participate in node-y things
		this.fragment.findNextNode = noop;

		this.dirty = false;
	}

	if ( Item$$1 ) ConditionalAttribute.__proto__ = Item$$1;
	ConditionalAttribute.prototype = Object.create( Item$$1 &amp;&amp; Item$$1.prototype );
	ConditionalAttribute.prototype.constructor = ConditionalAttribute;

	ConditionalAttribute.prototype.bind = function bind () {
		this.fragment.bind();
	};

	ConditionalAttribute.prototype.bubble = function bubble () {
		if ( !this.dirty ) {
			this.dirty = true;
			this.owner.bubble();
		}
	};

	ConditionalAttribute.prototype.render = function render () {
		this.node = this.owner.node;
		if ( this.node ) {
			this.isSvg = this.node.namespaceURI === svg$1;
		}

		attributes = true;
		if ( !this.rendered ) { this.fragment.render(); }

		this.rendered = true;
		this.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js
		this.update();
		attributes = false;
	};

	ConditionalAttribute.prototype.toString = function toString () {
		return this.fragment.toString();
	};

	ConditionalAttribute.prototype.unbind = function unbind () {
		this.fragment.unbind();
	};

	ConditionalAttribute.prototype.unrender = function unrender () {
		this.rendered = false;
		this.fragment.unrender();
	};

	ConditionalAttribute.prototype.update = function update () {
		var this$1 = this;

		var str;
		var attrs;

		if ( this.dirty ) {
			this.dirty = false;

			var current = attributes;
			attributes = true;
			this.fragment.update();
			attributes = current || false;

			if ( this.rendered &amp;&amp; this.node ) {
				str = this.fragment.toString();
				attrs = parseAttributes( str, this.isSvg );

				// any attributes that previously existed but no longer do
				// must be removed
				this.attributes.filter( function (a) { return notIn( attrs, a ); } ).forEach( function (a) {
					this$1.node.removeAttribute( a.name );
				});

				attrs.forEach( function (a) {
					this$1.node.setAttribute( a.name, a.value );
				});

				this.attributes = attrs;
			}
		}
	};

	return ConditionalAttribute;
}(Item));

function parseAttributes ( str, isSvg ) {
	var tagName = isSvg ? 'svg' : 'div';
	return str
		? (div$1.innerHTML = &quot;&lt;&quot; + tagName + &quot; &quot; + str + &quot;&gt;&lt;/&quot; + tagName + &quot;&gt;&quot;) &amp;&amp;
			toArray(div$1.childNodes[0].attributes)
		: [];
}

function notIn ( haystack, needle ) {
	var i = haystack.length;

	while ( i-- ) {
		if ( haystack[i].name === needle.name ) {
			return false;
		}
	}

	return true;
}

function lookupNamespace ( node, prefix ) {
	var qualified = &quot;xmlns:&quot; + prefix;

	while ( node ) {
		if ( node.hasAttribute &amp;&amp; node.hasAttribute( qualified ) ) { return node.getAttribute( qualified ); }
		node = node.parentNode;
	}

	return namespaces[ prefix ];
}

var attribute = false;
function inAttribute () { return attribute; }

var Attribute = (function (Item$$1) {
	function Attribute ( options ) {
		Item$$1.call( this, options );

		this.name = options.template.n;
		this.namespace = null;

		this.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );
		this.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );
		this.parentFragment = options.parentFragment; // shared
		this.ractive = this.parentFragment.ractive;

		this.rendered = false;
		this.updateDelegate = null;
		this.fragment = null;

		this.element.attributeByName[ this.name ] = this;

		if ( !Array.isArray( options.template.f ) ) {
			this.value = options.template.f;
			if ( this.value === 0 ) {
				this.value = <I>;</I>
			} else if ( this.value === undefined ) {
				this.value = true;
			}
		} else {
			this.fragment = new Fragment({
				owner: this,
				template: options.template.f
			});
		}

		this.interpolator = this.fragment &amp;&amp;
			this.fragment.items.length === 1 &amp;&amp;
			this.fragment.items[0].type === INTERPOLATOR &amp;&amp;
			this.fragment.items[0];

		if ( this.interpolator ) { this.interpolator.owner = this; }
	}

	if ( Item$$1 ) Attribute.__proto__ = Item$$1;
	Attribute.prototype = Object.create( Item$$1 &amp;&amp; Item$$1.prototype );
	Attribute.prototype.constructor = Attribute;

	Attribute.prototype.bind = function bind () {
		if ( this.fragment ) {
			this.fragment.bind();
		}
	};

	Attribute.prototype.bubble = function bubble () {
		if ( !this.dirty ) {
			this.parentFragment.bubble();
			this.element.bubble();
			this.dirty = true;
		}
	};

	Attribute.prototype.getString = function getString () {
		attribute = true;
		var value = this.fragment ?
			this.fragment.toString() :
			this.value != null ? <I> + this.value : </I>;
		attribute = false;
		return value;
	};

	// TODO could getValue ever be called for a static attribute,
	// or can we assume that this.fragment exists?
	Attribute.prototype.getValue = function getValue () {
		attribute = true;
		var value = this.fragment ? this.fragment.valueOf() : booleanAttributes.test( this.name ) ? true : this.value;
		attribute = false;
		return value;
	};

	Attribute.prototype.render = function render () {
		var node = this.element.node;
		this.node = node;

		// should we use direct property access, or setAttribute?
		if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
			this.propertyName = propertyNames[ this.name ] || this.name;

			if ( node[ this.propertyName ] !== undefined ) {
				this.useProperty = true;
			}

			// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
			// node.selected = true rather than node.setAttribute( 'selected', <I> )</I>
			if ( booleanAttributes.test( this.name ) || this.isTwoway ) {
				this.isBoolean = true;
			}

			if ( this.propertyName === 'value' ) {
				node._ractive.value = this.value;
			}
		}

		if ( node.namespaceURI ) {
			var index = this.name.indexOf( ':' );
			if ( index !== -1 ) {
				this.namespace = lookupNamespace( node, this.name.slice( 0, index ) );
			} else {
				this.namespace = node.namespaceURI;
			}
		}

		this.rendered = true;
		this.updateDelegate = getUpdateDelegate( this );
		this.updateDelegate();
	};

	Attribute.prototype.toString = function toString () {
		if ( inAttributes() ) { return <I>; }</I>
		attribute = true;

		var value = this.getValue();

		// Special case - select and textarea values (should not be stringified)
		if ( this.name === 'value' &amp;&amp; ( this.element.getAttribute( 'contenteditable' ) !== undefined || ( this.element.name === 'select' || this.element.name === 'textarea' ) ) ) {
			return;
		}

		// Special case – bound radio `name` attributes
		if ( this.name === 'name' &amp;&amp; this.element.name === 'input' &amp;&amp; this.interpolator &amp;&amp; this.element.getAttribute( 'type' ) === 'radio' ) {
			return (&quot;name=\&quot;<A href="/wiki/index.php?title=Template:%22_%2B_(this.interpolator.model.getKeypath())_%2B_%22&amp;action=edit&amp;redlink=1" class="new" title="Template:&quot; + (this.interpolator.model.getKeypath()) + &quot; (page does not exist)">Template:&quot; + (this.interpolator.model.getKeypath()) + &quot;</A>\&quot;&quot;);
		}

		// Special case - style and class attributes and directives
		if ( this.owner === this.element &amp;&amp; ( this.name === 'style' || this.name === 'class' || this.style || this.inlineClass ) ) {
			return;
		}

		if ( !this.rendered &amp;&amp; this.owner === this.element &amp;&amp; ( !this.name.indexOf( 'style-' ) || !this.name.indexOf( 'class-' ) ) ) {
			if ( !this.name.indexOf( 'style-' ) ) {
				this.style = hyphenateCamel( this.name.substr( 6 ) );
			} else {
				this.inlineClass = this.name.substr( 6 );
			}

			return;
		}

		if ( booleanAttributes.test( this.name ) ) { return value ? this.name : <I>; }</I>
		if ( value == null ) { return <I>; }</I>

		var str = safeAttributeString( this.getString() );
		attribute = false;

		return str ?
			((this.name) + &quot;=\&quot;&quot; + str + &quot;\&quot;&quot;) :
			this.name;
	};

	Attribute.prototype.unbind = function unbind () {
		if ( this.fragment ) { this.fragment.unbind(); }
	};

	Attribute.prototype.unrender = function unrender () {
		this.updateDelegate( true );

		this.rendered = false;
	};

	Attribute.prototype.update = function update () {
		if ( this.dirty ) {
			this.dirty = false;
			if ( this.fragment ) { this.fragment.update(); }
			if ( this.rendered ) { this.updateDelegate(); }
			if ( this.isTwoway &amp;&amp; !this.locked ) {
				this.interpolator.twowayBinding.lastVal( true, this.interpolator.model.get() );
			}
		}
	};

	return Attribute;
}(Item));

var BindingFlag = (function (Item$$1) {
	function BindingFlag ( options ) {
		Item$$1.call( this, options );

		this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );
		this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );
		this.flag = options.template.v === 'l' ? 'lazy' : 'twoway';

		if ( this.element.type === ELEMENT ) {
			if ( Array.isArray( options.template.f ) ) {
				this.fragment = new Fragment({
					owner: this,
					template: options.template.f
				});
			}

			this.interpolator = this.fragment &amp;&amp;
								this.fragment.items.length === 1 &amp;&amp;
								this.fragment.items[0].type === INTERPOLATOR &amp;&amp;
								this.fragment.items[0];
		}
	}

	if ( Item$$1 ) BindingFlag.__proto__ = Item$$1;
	BindingFlag.prototype = Object.create( Item$$1 &amp;&amp; Item$$1.prototype );
	BindingFlag.prototype.constructor = BindingFlag;

	BindingFlag.prototype.bind = function bind () {
		if ( this.fragment ) { this.fragment.bind(); }
		set$1( this, this.getValue(), true );
	};

	BindingFlag.prototype.bubble = function bubble () {
		if ( !this.dirty ) {
			this.element.bubble();
			this.dirty = true;
		}
	};

	BindingFlag.prototype.getValue = function getValue () {
		if ( this.fragment ) { return this.fragment.valueOf(); }
		else if ( 'value' in this ) { return this.value; }
		else if ( 'f' in this.template ) { return this.template.f; }
		else { return true; }
	};

	BindingFlag.prototype.render = function render () {
		set$1( this, this.getValue(), true );
	};

	BindingFlag.prototype.toString = function toString () { return <I>; };</I>

	BindingFlag.prototype.unbind = function unbind () {
		if ( this.fragment ) { this.fragment.unbind(); }

		delete this.element[ this.flag ];
	};

	BindingFlag.prototype.unrender = function unrender () {
		if ( this.element.rendered ) { this.element.recreateTwowayBinding(); }
	};

	BindingFlag.prototype.update = function update () {
		if ( this.dirty ) {
			if ( this.fragment ) { this.fragment.update(); }
			set$1( this, this.getValue(), true );
		}
	};

	return BindingFlag;
}(Item));

function set$1 ( flag, value, update ) {
	if ( value === 0 ) {
		flag.value = true;
	} else if ( value === 'true' ) {
		flag.value = true;
	} else if ( value === 'false' || value === '0' ) {
		flag.value = false;
	} else {
		flag.value = value;
	}

	var current = flag.element[ flag.flag ];
	flag.element[ flag.flag ] = flag.value;
	if ( update &amp;&amp; !flag.element.attributes.binding &amp;&amp; current !== flag.value ) {
		flag.element.recreateTwowayBinding();
	}

	return flag.value;
}

var RactiveModel = (function (Model$$1) {
	function RactiveModel ( ractive ) {
		Model$$1.call( this, null, <I> );</I>
		this.value = ractive;
		this.isRoot = true;
		this.root = this;
		this.adaptors = [];
		this.ractive = ractive;
	}

	if ( Model$$1 ) RactiveModel.__proto__ = Model$$1;
	RactiveModel.prototype = Object.create( Model$$1 &amp;&amp; Model$$1.prototype );
	RactiveModel.prototype.constructor = RactiveModel;

	RactiveModel.prototype.joinKey = function joinKey ( key ) {
		var model = Model$$1.prototype.joinKey.call( this, key );

		if ( ( key === 'root' || key === 'parent' ) &amp;&amp; !model.isLink ) { return initLink( model, key ); }
		else if ( key === 'data' ) { return this.ractive.viewmodel; }

		return model;
	};

	RactiveModel.prototype.getKeypath = function getKeypath () {
		return '@this';
	};

	RactiveModel.prototype.retrieve = function retrieve () {
		return this.ractive;
	};

	return RactiveModel;
}(Model));

function initLink ( model, key ) {
	model.applyValue = function ( value ) {
		this.parent.value[ key ] = value;
		if ( value &amp;&amp; value.viewmodel ) {
			this.link( value.viewmodel.getRactiveModel(), key );
			this._link.markedAll();
		} else {
			this.link( Object.create( Missing ), key );
			this._link.markedAll();
		}
	};

	model.applyValue( model.parent.ractive[ key ], key );
	model._link.set = function (v) { return model.applyValue( v ); };
	model._link.applyValue = function (v) { return model.applyValue( v ); };
	return model._link;
}

var hasProp$1 = Object.prototype.hasOwnProperty;

var RootModel = (function (Model$$1) {
	function RootModel ( options ) {
		Model$$1.call( this, null, null );

		this.isRoot = true;
		this.root = this;
		this.ractive = options.ractive; // TODO sever this link

		this.value = options.data;
		this.adaptors = options.adapt;
		this.adapt();

		this.computationContext = options.ractive;
		this.computations = {};
	}

	if ( Model$$1 ) RootModel.__proto__ = Model$$1;
	RootModel.prototype = Object.create( Model$$1 &amp;&amp; Model$$1.prototype );
	RootModel.prototype.constructor = RootModel;

	RootModel.prototype.attached = function attached ( fragment ) {
		attachImplicits( this, fragment );
	};

	RootModel.prototype.compute = function compute ( key, signature ) {
		var computation = new Computation( this, signature, key );
		this.computations[ escapeKey( key ) ] = computation;

		return computation;
	};

	RootModel.prototype.createLink = function createLink ( keypath, target, targetPath, options ) {
		var this$1 = this;

		var keys = splitKeypath( keypath );

		var model = this;
		while ( keys.length ) {
			var key = keys.shift();
			model = this$1.childByKey[ key ] || this$1.joinKey( key );
		}

		return model.link( target, targetPath, options );
	};

	RootModel.prototype.detached = function detached () {
		detachImplicits( this );
	};

	RootModel.prototype.get = function get ( shouldCapture, options ) {
		var this$1 = this;

		if ( shouldCapture ) { capture( this ); }

		if ( !options || options.virtual !== false ) {
			var result = this.getVirtual();
			var keys = Object.keys( this.computations );
			var i = keys.length;
			while ( i-- ) {
				result[ keys[i] ] = this$1.computations[ keys[i] ].get();
			}

			return result;
		} else {
			return this.value;
		}
	};

	RootModel.prototype.getKeypath = function getKeypath () {
		return <I>;</I>
	};

	RootModel.prototype.getRactiveModel = function getRactiveModel () {
		return this.ractiveModel || ( this.ractiveModel = new RactiveModel( this.ractive ) );
	};

	RootModel.prototype.getValueChildren = function getValueChildren () {
		var this$1 = this;

		var children = Model$$1.prototype.getValueChildren.call( this, this.value );

		this.children.forEach( function (child) {
			if ( child._link ) {
				var idx = children.indexOf( child );
				if ( ~idx ) { children.splice( idx, 1, child._link ); }
				else { children.push( child._link ); }
			}
		});

		for ( var k in this$1.computations ) {
			children.push( this$1.computations[k] );
		}

		return children;
	};

	RootModel.prototype.has = function has ( key ) {
		var value = this.value;
		var unescapedKey = unescapeKey( key );

		if ( unescapedKey === '@this' || unescapedKey === '@global' || unescapedKey === '@shared' ) { return true; }
		if ( unescapedKey[0] === '~' &amp;&amp; unescapedKey[1] === '/' ) { unescapedKey = unescapedKey.slice( 2 ); }
		if ( hasProp$1.call( value, unescapedKey ) ) { return true; }

		// mappings/links and computations
		if ( key in this.computations || this.childByKey[unescapedKey] &amp;&amp; this.childByKey[unescapedKey]._link ) { return true; }

		// We climb up the constructor chain to find if one of them contains the unescapedKey
		var constructor = value.constructor;
		while ( constructor !== Function &amp;&amp; constructor !== Array &amp;&amp; constructor !== Object ) {
			if ( hasProp$1.call( constructor.prototype, unescapedKey ) ) { return true; }
			constructor = constructor.constructor;
		}

		return false;
	};

	RootModel.prototype.joinKey = function joinKey ( key, opts ) {
		if ( key[0] === '@' ) {
			if ( key === '@this' || key === '@' ) { return this.getRactiveModel(); }
			if ( key === '@global' ) { return GlobalModel; }
			if ( key === '@shared' ) { return SharedModel$1; }
			return;
		}

		if ( key[0] === '~' &amp;&amp; key[1] === '/' ) { key = key.slice( 2 ); }

		return this.computations.hasOwnProperty( key ) ? this.computations[ key ] :
		       Model$$1.prototype.joinKey.call( this, key, opts );
	};

	RootModel.prototype.set = function set ( value ) {
		// TODO wrapping root node is a baaaad idea. We should prevent this
		var wrapper = this.wrapper;
		if ( wrapper ) {
			var shouldTeardown = !wrapper.reset || wrapper.reset( value ) === false;

			if ( shouldTeardown ) {
				wrapper.teardown();
				this.wrapper = null;
				this.value = value;
				this.adapt();
			}
		} else {
			this.value = value;
			this.adapt();
		}

		this.deps.forEach( handleChange );
		this.children.forEach( mark );
	};

	RootModel.prototype.retrieve = function retrieve () {
		return this.wrapper ? this.wrapper.get() : this.value;
	};

	RootModel.prototype.teardown = function teardown$$1 () {
		var this$1 = this;

		Model$$1.prototype.teardown.call(this);
		for ( var k in this$1.computations ) {
			this$1.computations[ k ].teardown();
		}
	};

	return RootModel;
}(Model));

RootModel.prototype.update = noop;

function attachImplicits ( model, fragment ) {
	if ( model._link &amp;&amp; model._link.implicit &amp;&amp; model._link.isDetached() ) {
		model.attach( fragment );
	}

	// look for virtual children to relink and cascade
	for ( var k in model.childByKey ) {
		if ( k in model.value ) {
			attachImplicits( model.childByKey[k], fragment );
		} else if ( !model.childByKey[k]._link || model.childByKey[k]._link.isDetached() ) {
			var mdl = resolveReference( fragment, k );
			if ( mdl ) {
				model.childByKey[k].link( mdl, k, { implicit: true } );
			}
		}
	}
}

function detachImplicits ( model ) {
	if ( model._link &amp;&amp; model._link.implicit ) {
		model.unlink();
	}

	for ( var k in model.childByKey ) {
		detachImplicits( model.childByKey[k] );
	}
}

function getComputationSignature ( ractive, key, signature ) {
	var getter;
	var setter;

	// useful for debugging
	var getterString;
	var getterUseStack;
	var setterString;

	if ( typeof signature === 'function' ) {
		getter = bind$1( signature, ractive );
		getterString = signature.toString();
		getterUseStack = true;
	}

	if ( typeof signature === 'string' ) {
		getter = createFunctionFromString( signature, ractive );
		getterString = signature;
	}

	if ( typeof signature === 'object' ) {
		if ( typeof signature.get === 'string' ) {
			getter = createFunctionFromString( signature.get, ractive );
			getterString = signature.get;
		} else if ( typeof signature.get === 'function' ) {
			getter = bind$1( signature.get, ractive );
			getterString = signature.get.toString();
			getterUseStack = true;
		} else {
			fatal( '`%s` computation must have a `get()` method', key );
		}

		if ( typeof signature.set === 'function' ) {
			setter = bind$1( signature.set, ractive );
			setterString = signature.set.toString();
		}
	}

	return {
		getter: getter,
		setter: setter,
		getterString: getterString,
		setterString: setterString,
		getterUseStack: getterUseStack
	};
}

var constructHook = new Hook( 'construct' );

var registryNames$1 = [
	'adaptors',
	'components',
	'decorators',
	'easing',
	'events',
	'interpolators',
	'partials',
	'transitions'
];

var uid = 0;

function construct ( ractive, options ) {
	if ( Ractive.DEBUG ) { welcome(); }

	initialiseProperties( ractive );
	handleAttributes( ractive );

	// if there's not a delegation setting, inherit from parent if it's not default
	if ( !options.hasOwnProperty( 'delegate' ) &amp;&amp; ractive.parent &amp;&amp; ractive.parent.delegate !== ractive.delegate ) {
		ractive.delegate = false;
	}

	// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it
	constructHook.fire( ractive, options );

	// Add registries
	var i = registryNames$1.length;
	while ( i-- ) {
		var name = registryNames$1[ i ];
		ractive[ name ] = Object.assign( Object.create( ractive.constructor[ name ] || null ), options[ name ] );
	}

	if ( ractive._attributePartial ) {
		ractive.partials['extra-attributes'] = ractive._attributePartial;
		delete ractive._attributePartial;
	}

	// Create a viewmodel
	var viewmodel = new RootModel({
		adapt: getAdaptors( ractive, ractive.adapt, options ),
		data: dataConfigurator.init( ractive.constructor, ractive, options ),
		ractive: ractive
	});

	ractive.viewmodel = viewmodel;

	// Add computed properties
	var computed = Object.assign( Object.create( ractive.constructor.prototype.computed ), options.computed );

	for ( var key in computed ) {
		if ( key === '__proto__' ) { continue; }
		var signature = getComputationSignature( ractive, key, computed[ key ] );
		viewmodel.compute( key, signature );
	}
}

function getAdaptors ( ractive, protoAdapt, options ) {
	protoAdapt = protoAdapt.map( lookup );
	var adapt = ensureArray( options.adapt ).map( lookup );

	var srcs = [ protoAdapt, adapt ];
	if ( ractive.parent &amp;&amp; !ractive.isolated ) {
		srcs.push( ractive.parent.viewmodel.adaptors );
	}

	return combine.apply( null, srcs );

	function lookup ( adaptor ) {
		if ( typeof adaptor === 'string' ) {
			adaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );

			if ( !adaptor ) {
				fatal( missingPlugin( adaptor, 'adaptor' ) );
			}
		}

		return adaptor;
	}
}

function initialiseProperties ( ractive ) {
	// Generate a unique identifier, for places where you'd use a weak map if it
	// existed
	ractive._guid = 'r-' + uid++;

	// events
	ractive._subs = Object.create( null );
	ractive._nsSubs = 0;

	// storage for item configuration from instantiation to reset,
	// like dynamic functions or original values
	ractive._config = {};

	// events
	ractive.event = null;
	ractive._eventQueue = [];

	// observers
	ractive._observers = [];

	// external children
	ractive._children = [];
	ractive._children.byName = {};
	ractive.children = ractive._children;

	if ( !ractive.component ) {
		ractive.root = ractive;
		ractive.parent = ractive.container = null; // TODO container still applicable?
	}
}

function handleAttributes ( ractive ) {
	var component = ractive.component;
	var attributes = ractive.constructor.attributes;

	if ( attributes &amp;&amp; component ) {
		var tpl = component.template;
		var attrs = tpl.m ? tpl.m.slice() : [];

		// grab all of the passed attribute names
		var props = attrs.filter( function (a) { return a.t === ATTRIBUTE; } ).map( function (a) { return a.n; } );

		// warn about missing requireds
		attributes.required.forEach( function (p) {
			if ( !~props.indexOf( p ) ) {
				warnIfDebug( (&quot;Component '&quot; + (component.name) + &quot;' requires attribute '&quot; + p + &quot;' to be provided&quot;) );
			}
		});

		// set up a partial containing non-property attributes
		var all = attributes.optional.concat( attributes.required );
		var partial = [];
		var i = attrs.length;
		while ( i-- ) {
			var a = attrs[i];
			if ( a.t === ATTRIBUTE &amp;&amp; !~all.indexOf( a.n ) ) {
				if ( attributes.mapAll ) {
					// map the attribute if requested and make the extra attribute in the partial refer to the mapping
					partial.unshift({ t: ATTRIBUTE, n: a.n, f: [{ t: INTERPOLATOR, r: (&quot;~/&quot; + (a.n)) }] });
				} else {
					// transfer the attribute to the extra attributes partal
					partial.unshift( attrs.splice( i, 1 )[0] );
				}
			}
		}

		if ( partial.length ) { component.template = { t: tpl.t, e: tpl.e, f: tpl.f, m: attrs, p: tpl.p }; }
		ractive._attributePartial = partial;
	}
}

var teardownHook = new Hook( 'teardown' );
var destructHook = new Hook( 'destruct' );

// Teardown. This goes through the root fragment and all its children, removing observers
// and generally cleaning up after itself

function Ractive$teardown () {
	var this$1 = this;

	if ( this.torndown ) {
		warnIfDebug( 'ractive.teardown() was called on a Ractive instance that was already torn down' );
		return Promise.resolve();
	}

	this.shouldDestroy = true;
	return teardown$1( this, function () { return this$1.fragment.rendered ? this$1.unrender() : Promise.resolve(); } );
}

function teardown$1 ( instance, getPromise ) {
	instance.torndown = true;
	instance.viewmodel.teardown();
	instance.fragment.unbind();
	instance._observers.slice().forEach( cancel );

	if ( instance.el &amp;&amp; instance.el.__ractive_instances__ ) {
		removeFromArray( instance.el.__ractive_instances__, instance );
	}

	var promise = getPromise();

	teardownHook.fire( instance );
	promise.then( function () { return destructHook.fire( instance ); } );

	return promise;
}

var Component = (function (Item$$1) {
	function Component ( options, ComponentConstructor ) {
		var this$1 = this;

		Item$$1.call( this, options );
		this.isAnchor = this.template.t === ANCHOR;
		this.type = this.isAnchor ? ANCHOR : COMPONENT; // override ELEMENT from super

		var partials = options.template.p || {};
		if ( !( 'content' in partials ) ) { partials.content = options.template.f || []; }
		this._partials = partials; // TEMP

		if ( this.isAnchor ) {
			this.name = options.template.n;

			this.addChild = addChild;
			this.removeChild = removeChild;
		} else {
			var instance = Object.create( ComponentConstructor.prototype );

			this.instance = instance;
			this.name = options.template.e;

			if ( instance.el ) {
				warnIfDebug( (&quot;The &lt;&quot; + (this.name) + &quot;&gt; component has a default 'el' property; it has been disregarded&quot;) );
			}

			// find container
			var fragment = options.parentFragment;
			var container;
			while ( fragment ) {
				if ( fragment.owner.type === YIELDER ) {
					container = fragment.owner.container;
					break;
				}

				fragment = fragment.parent;
			}

			// add component-instance-specific properties
			instance.parent = this.parentFragment.ractive;
			instance.container = container || null;
			instance.root = instance.parent.root;
			instance.component = this;

			construct( this.instance, { partials: partials });

			// for hackability, this could be an open option
			// for any ractive instance, but for now, just
			// for components and just for ractive...
			instance._inlinePartials = partials;
		}

		this.attributeByName = {};

		this.events = [];
		this.attributes = [];
		var leftovers = [];
		( this.template.m || [] ).forEach( function (template) {
			switch ( template.t ) {
				case ATTRIBUTE:
				case EVENT:
					this$1.attributes.push( createItem({
						owner: this$1,
						parentFragment: this$1.parentFragment,
						template: template
					}) );
					break;

				case TRANSITION:
				case BINDING_FLAG:
				case DECORATOR:
					break;

				default:
					leftovers.push( template );
					break;
			}
		});

		if ( leftovers.length ) {
			this.attributes.push( new ConditionalAttribute({
				owner: this,
				parentFragment: this.parentFragment,
				template: leftovers
			}) );
		}

		this.eventHandlers = [];
	}

	if ( Item$$1 ) Component.__proto__ = Item$$1;
	Component.prototype = Object.create( Item$$1 &amp;&amp; Item$$1.prototype );
	Component.prototype.constructor = Component;

	Component.prototype.bind = function bind$1 () {
		if ( !this.isAnchor ) {
			this.attributes.forEach( bind );

			initialise( this.instance, {
				partials: this._partials
			}, {
				cssIds: this.parentFragment.cssIds
			});

			this.eventHandlers.forEach( bind );

			this.bound = true;
		}
	};

	Component.prototype.bubble = function bubble () {
		if ( !this.dirty ) {
			this.dirty = true;
			this.parentFragment.bubble();
		}
	};

	Component.prototype.destroyed = function destroyed$$1 () {
		if ( !this.isAnchor &amp;&amp; this.instance.fragment ) { this.instance.fragment.destroyed(); }
	};

	Component.prototype.detach = function detach () {
		if ( this.isAnchor ) {
			if ( this.instance ) { return this.instance.fragment.detach(); }
			return createDocumentFragment();
		}

		return this.instance.fragment.detach();
	};

	Component.prototype.find = function find ( selector, options ) {
		if ( this.instance ) { return this.instance.fragment.find( selector, options ); }
	};

	Component.prototype.findAll = function findAll ( selector, options ) {
		if ( this.instance ) { this.instance.fragment.findAll( selector, options ); }
	};

	Component.prototype.findComponent = function findComponent ( name, options ) {
		if ( !name || this.name === name ) { return this.instance; }

		if ( this.instance.fragment ) {
			return this.instance.fragment.findComponent( name, options );
		}
	};

	Component.prototype.findAllComponents = function findAllComponents ( name, options ) {
		var result = options.result;

		if ( this.instance &amp;&amp; ( !name || this.name === name ) ) {
			result.push( this.instance );
		}

		if ( this.instance ) { this.instance.findAllComponents( name, options ); }
	};

	Component.prototype.firstNode = function firstNode ( skipParent ) {
		if ( this.instance ) { return this.instance.fragment.firstNode( skipParent ); }
	};

	Component.prototype.getContext = function getContext$$1 () {
		var assigns = [], len = arguments.length;
		while ( len-- ) assigns[ len ] = arguments[ len ];

		assigns.unshift( this );
		return getRactiveContext.apply( null, assigns );
	};

	Component.prototype.render = function render$1$$1 ( target, occupants ) {
		if ( this.isAnchor ) {
			this.rendered = true;
			this.target = target;

			if ( !checking.length ) {
				checking.push( this.ractive );
				if ( occupants ) {
					this.occupants = occupants;
					checkAnchors();
					this.occupants = null;
				} else {
					runloop.scheduleTask( checkAnchors, true );
				}
			}
		} else {
			render$1( this.instance, target, null, occupants );

			this.attributes.forEach( render );
			this.eventHandlers.forEach( render );

			this.rendered = true;
		}
	};

	Component.prototype.toString = function toString$$1 () {
		if ( this.instance ) { return this.instance.toHTML(); }
	};

	Component.prototype.unbind = function unbind$1 () {
		if ( !this.isAnchor ) {
			this.bound = false;

			this.attributes.forEach( unbind );

			teardown$1( this.instance, function () { return runloop.promise(); } );
		}
	};

	Component.prototype.unrender = function unrender$1 ( shouldDestroy ) {
		this.shouldDestroy = shouldDestroy;

		if ( this.isAnchor ) {
			if ( this.item ) { unrenderItem( this, this.item ); }
			this.target = null;
			if ( !checking.length ) {
				checking.push( this.ractive );
				runloop.scheduleTask( checkAnchors, true );
			}
		} else {
			this.instance.unrender();
			this.instance.el = this.instance.target = null;
			this.attributes.forEach( unrender );
			this.eventHandlers.forEach( unrender );
		}

		this.rendered = false;
	};

	Component.prototype.update = function update$1 () {
		this.dirty = false;
		if ( this.instance ) {
			this.instance.fragment.update();
			this.attributes.forEach( update );
			this.eventHandlers.forEach( update );
		}
	};

	return Component;
}(Item));

function addChild ( meta ) {
	if ( this.item ) { this.removeChild( this.item ); }

	var child = meta.instance;
	meta.anchor = this;

	meta.parentFragment = this.parentFragment;
	meta.name = meta.nameOption || this.name;
	this.name = meta.name;


	if ( !child.isolated ) { child.viewmodel.attached( this.parentFragment ); }

	// render as necessary
	if ( this.rendered ) {
		renderItem( this, meta );
	}
}

function removeChild ( meta ) {
	// unrender as necessary
	if ( this.item === meta ) {
		unrenderItem( this, meta );
		this.name = this.template.n;
	}
}

function renderItem ( anchor, meta ) {
	if ( !anchor.rendered ) { return; }

	meta.shouldDestroy = false;
	meta.parentFragment = anchor.parentFragment;

	anchor.item = meta;
	anchor.instance = meta.instance;
	var nextNode = anchor.parentFragment.findNextNode( anchor );

	if ( meta.instance.fragment.rendered ) {
		meta.instance.unrender();
	}

	meta.partials = meta.instance.partials;
	meta.instance.partials = Object.assign( {}, meta.partials, anchor._partials );

	meta.instance.fragment.unbind();
	meta.instance.fragment.bind( meta.instance.viewmodel );

	anchor.attributes.forEach( bind );
	anchor.eventHandlers.forEach( bind );
	anchor.attributes.forEach( render );
	anchor.eventHandlers.forEach( render );

	var target = anchor.parentFragment.findParentNode();
	render$1( meta.instance, target, target.contains( nextNode ) ? nextNode : null, anchor.occupants );

	if ( meta.lastBound !== anchor ) {
		meta.lastBound = anchor;
	}
}

function unrenderItem ( anchor, meta ) {
	if ( !anchor.rendered ) { return; }

	meta.shouldDestroy = true;
	meta.instance.unrender();

	anchor.eventHandlers.forEach( unrender );
	anchor.attributes.forEach( unrender );
	anchor.eventHandlers.forEach( unbind );
	anchor.attributes.forEach( unbind );

	meta.instance.el = meta.instance.anchor = null;
	meta.parentFragment = null;
	meta.anchor = null;
	anchor.item = null;
	anchor.instance = null;
}

var checking = [];
function checkAnchors () {
	var list = checking;
	checking = [];

	list.forEach( updateAnchors );
}

function setupArgsFn ( item, template, fragment, opts ) {
	if ( opts === void 0 ) opts = {};

	if ( template &amp;&amp; template.f &amp;&amp; template.f.s ) {
		item.fn = getFunction( template.f.s, template.f.r.length );
		if ( opts.register === true ) {
			item.models = resolveArgs( item, template, fragment, opts );
		}
	}
}

function resolveArgs ( item, template, fragment, opts ) {
	if ( opts === void 0 ) opts = {};

	return template.f.r.map( function ( ref, i ) {
		var model;

		if ( opts.specialRef &amp;&amp; ( model = opts.specialRef( ref, i ) ) ) { return model; }

		model = resolveReference( fragment, ref );
		if ( opts.register === true ) {
			model.register( item );
		}

		return model;
	});
}

function teardownArgsFn ( item, template ) {
	if ( template &amp;&amp; template.f &amp;&amp; template.f.s ) {
		if ( item.models ) { item.models.forEach( function (m) {
			if ( m &amp;&amp; m.unregister ) { m.unregister( item ); }
		}); }
		item.models = null;
	}
}

var missingDecorator = {
	update: noop,
	teardown: noop
};

var Decorator = function Decorator ( options ) {
	this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );
	this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );
	this.parentFragment = this.owner.parentFragment;
	this.ractive = this.owner.ractive;
	var template = this.template = options.template;

	this.name = template.n;

	this.node = null;
	this.intermediary = null;

	this.element.decorators.push( this );
};

Decorator.prototype.bind = function bind () {
	setupArgsFn( this, this.template, this.parentFragment, { register: true } );
};

Decorator.prototype.bubble = function bubble () {
	if ( !this.dirty ) {
		this.dirty = true;
		this.owner.bubble();
	}
};

Decorator.prototype.destroyed = function destroyed () {
	if ( this.intermediary ) { this.intermediary.teardown(); }
	this.shouldDestroy = true;
};

Decorator.prototype.handleChange = function handleChange () { this.bubble(); };

Decorator.prototype.rebind = function rebind ( next, previous, safe ) {
	var idx = this.models.indexOf( previous );
	if ( !~idx ) { return; }

	next = rebindMatch( this.template.f.r[ idx ], next, previous );
	if ( next === previous ) { return; }

	previous.unregister( this );
	this.models.splice( idx, 1, next );
	if ( next ) { next.addShuffleRegister( this, 'mark' ); }

	if ( !safe ) { this.bubble(); }
};

Decorator.prototype.render = function render () {
		var this$1 = this;

	runloop.scheduleTask( function () {
		var fn = findInViewHierarchy( 'decorators', this$1.ractive, this$1.name );

		if ( !fn ) {
			warnOnce( missingPlugin( this$1.name, 'decorator' ) );
			this$1.intermediary = missingDecorator;
			return;
		}

		this$1.node = this$1.element.node;

		var args;
		if ( this$1.fn ) {
			args = this$1.models.map( function (model) {
				if ( !model ) { return undefined; }

				return model.get();
			});
			args = this$1.fn.apply( this$1.ractive, args );
		}

		this$1.intermediary = fn.apply( this$1.ractive, [ this$1.node ].concat( args ) );

		if ( !this$1.intermediary || !this$1.intermediary.teardown ) {
			throw new Error( (&quot;The '&quot; + (this$1.name) + &quot;' decorator must return an object with a teardown method&quot;) );
		}

		// watch out for decorators that cause their host element to be unrendered
		if ( this$1.shouldDestroy ) { this$1.destroyed(); }
	}, true );
	this.rendered = true;
};

Decorator.prototype.toString = function toString () { return <I>; };</I>

Decorator.prototype.unbind = function unbind () {
	teardownArgsFn( this, this.template );
};

Decorator.prototype.unrender = function unrender ( shouldDestroy ) {
	if ( ( !shouldDestroy || this.element.rendered ) &amp;&amp; this.intermediary ) { this.intermediary.teardown(); }
	this.rendered = false;
};

Decorator.prototype.update = function update () {
	if ( !this.dirty ) { return; }

	this.dirty = false;

	if ( this.intermediary ) {
		if ( !this.intermediary.update ) {
			this.unrender();
			this.render();
		}
		else {
			var args = this.models.map( function (model) { return model &amp;&amp; model.get(); } );
			this.intermediary.update.apply( this.ractive, this.fn.apply( this.ractive, args ) );
		}
	}
};

var Doctype = (function (Item$$1) {
	function Doctype () {
		Item$$1.apply(this, arguments);
	}

	if ( Item$$1 ) Doctype.__proto__ = Item$$1;
	Doctype.prototype = Object.create( Item$$1 &amp;&amp; Item$$1.prototype );
	Doctype.prototype.constructor = Doctype;

	Doctype.prototype.toString = function toString () {
		return '&lt;!DOCTYPE' + this.template.a + '&gt;';
	};

	return Doctype;
}(Item));

var proto$1 = Doctype.prototype;
proto$1.bind = proto$1.render = proto$1.teardown = proto$1.unbind = proto$1.unrender = proto$1.update = noop;

var Binding = function Binding ( element, name ) {
	if ( name === void 0 ) name = 'value';

	this.element = element;
	this.ractive = element.ractive;
	this.attribute = element.attributeByName[ name ];

	var interpolator = this.attribute.interpolator;
	interpolator.twowayBinding = this;

	var model = interpolator.model;

	if ( model.isReadonly ) {
		var keypath = model.getKeypath().replace( /^@/, <I> );</I>
		warnOnceIfDebug( (&quot;Cannot use two-way binding on &lt;&quot; + (element.name) + &quot;&gt; element: &quot; + keypath + &quot; is read-only. To suppress this warning use &lt;&quot; + (element.name) + &quot; twoway='false'...&gt;&quot;), { ractive: this.ractive });
		return false;
	}

	this.attribute.isTwoway = true;
	this.model = model;

	// initialise value, if it's undefined
	var value = model.get();
	this.wasUndefined = value === undefined;

	if ( value === undefined &amp;&amp; this.getInitialValue ) {
		value = this.getInitialValue();
		model.set( value );
	}
	this.lastVal( true, value );

	var parentForm = findElement( this.element, false, 'form' );
	if ( parentForm ) {
		this.resetValue = value;
		parentForm.formBindings.push( this );
	}
};

Binding.prototype.bind = function bind () {
	this.model.registerTwowayBinding( this );
};

Binding.prototype.handleChange = function handleChange () {
		var this$1 = this;

	var value = this.getValue();
	if ( this.lastVal() === value ) { return; }

	runloop.start( this.root );
	this.attribute.locked = true;
	this.model.set( value );
	this.lastVal( true, value );

	// if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up
	if ( this.model.get() !== value ) { this.attribute.locked = false; }
	else { runloop.scheduleTask( function () { return this$1.attribute.locked = false; } ); }

	runloop.end();
};

Binding.prototype.lastVal = function lastVal ( setting, value ) {
	if ( setting ) { this.lastValue = value; }
	else { return this.lastValue; }
};

Binding.prototype.rebind = function rebind ( next, previous ) {
		var this$1 = this;

	if ( this.model &amp;&amp; this.model === previous ) { previous.unregisterTwowayBinding( this ); }
	if ( next ) {
		this.model = next;
		runloop.scheduleTask( function () { return next.registerTwowayBinding( this$1 ); } );
	}
};

Binding.prototype.render = function render () {
	this.node = this.element.node;
	this.node._ractive.binding = this;
	this.rendered = true; // TODO is this used anywhere?
};

Binding.prototype.setFromNode = function setFromNode ( node ) {
	this.model.set( node.value );
};

Binding.prototype.unbind = function unbind () {
	this.model.unregisterTwowayBinding( this );
};

Binding.prototype.unrender = noop;

// This is the handler for DOM events that would lead to a change in the model
// (i.e. change, sometimes, input, and occasionally click and keyup)
function handleDomEvent () {
	this._ractive.binding.handleChange();
}

var CheckboxBinding = (function (Binding$$1) {
	function CheckboxBinding ( element ) {
		Binding$$1.call( this, element, 'checked' );
	}

	if ( Binding$$1 ) CheckboxBinding.__proto__ = Binding$$1;
	CheckboxBinding.prototype = Object.create( Binding$$1 &amp;&amp; Binding$$1.prototype );
	CheckboxBinding.prototype.constructor = CheckboxBinding;

	CheckboxBinding.prototype.render = function render () {
		Binding$$1.prototype.render.call(this);

		this.node.addEventListener( 'change', handleDomEvent, false );

		if ( this.node.attachEvent ) {
			this.node.addEventListener( 'click', handleDomEvent, false );
		}
	};

	CheckboxBinding.prototype.unrender = function unrender () {
		this.node.removeEventListener( 'change', handleDomEvent, false );
		this.node.removeEventListener( 'click', handleDomEvent, false );
	};

	CheckboxBinding.prototype.getInitialValue = function getInitialValue () {
		return !!this.element.getAttribute( 'checked' );
	};

	CheckboxBinding.prototype.getValue = function getValue () {
		return this.node.checked;
	};

	CheckboxBinding.prototype.setFromNode = function setFromNode ( node ) {
		this.model.set( node.checked );
	};

	return CheckboxBinding;
}(Binding));

function getBindingGroup ( group, model, getValue ) {
	var hash = group + &quot;-bindingGroup&quot;;
	return model[hash] || ( model[ hash ] = new BindingGroup( hash, model, getValue ) );
}

var BindingGroup = function BindingGroup ( hash, model, getValue ) {
	var this$1 = this;

	this.model = model;
	this.hash = hash;
	this.getValue = function () {
		this$1.value = getValue.call(this$1);
		return this$1.value;
	};

	this.bindings = [];
};

BindingGroup.prototype.add = function add ( binding ) {
	this.bindings.push( binding );
};

BindingGroup.prototype.bind = function bind () {
	this.value = this.model.get();
	this.model.registerTwowayBinding( this );
	this.bound = true;
};

BindingGroup.prototype.remove = function remove ( binding ) {
	removeFromArray( this.bindings, binding );
	if ( !this.bindings.length ) {
		this.unbind();
	}
};

BindingGroup.prototype.unbind = function unbind () {
	this.model.unregisterTwowayBinding( this );
	this.bound = false;
	delete this.model[this.hash];
};

BindingGroup.prototype.rebind = Binding.prototype.rebind;

var push$1 = [].push;

function getValue() {
	var this$1 = this;

	var all = this.bindings.filter(function (b) { return b.node &amp;&amp; b.node.checked; }).map(function (b) { return b.element.getAttribute( 'value' ); });
	var res = [];
	all.forEach(function (v) { if ( !this$1.bindings[0].arrayContains( res, v ) ) { res.push( v ); } });
	return res;
}

var CheckboxNameBinding = (function (Binding$$1) {
	function CheckboxNameBinding ( element ) {
		Binding$$1.call( this, element, 'name' );

		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this

		// Each input has a reference to an array containing it and its
		// group, as two-way binding depends on being able to ascertain
		// the status of all inputs within the group
		this.group = getBindingGroup( 'checkboxes', this.model, getValue );
		this.group.add( this );

		if ( this.noInitialValue ) {
			this.group.noInitialValue = true;
		}

		// If no initial value was set, and this input is checked, we
		// update the model
		if ( this.group.noInitialValue &amp;&amp; this.element.getAttribute( 'checked' ) ) {
			var existingValue = this.model.get();
			var bindingValue = this.element.getAttribute( 'value' );

			if ( !this.arrayContains( existingValue, bindingValue ) ) {
				push$1.call( existingValue, bindingValue ); // to avoid triggering runloop with array adaptor
			}
		}
	}

	if ( Binding$$1 ) CheckboxNameBinding.__proto__ = Binding$$1;
	CheckboxNameBinding.prototype = Object.create( Binding$$1 &amp;&amp; Binding$$1.prototype );
	CheckboxNameBinding.prototype.constructor = CheckboxNameBinding;

	CheckboxNameBinding.prototype.bind = function bind () {
		if ( !this.group.bound ) {
			this.group.bind();
		}
	};

	CheckboxNameBinding.prototype.getInitialValue = function getInitialValue () {
		// This only gets called once per group (of inputs that
		// share a name), because it only gets called if there
		// isn't an initial value. By the same token, we can make
		// a note of that fact that there was no initial value,
		// and populate it using any `checked` attributes that
		// exist (which users should avoid, but which we should
		// support anyway to avoid breaking expectations)
		this.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?
		return [];
	};

	CheckboxNameBinding.prototype.getValue = function getValue () {
		return this.group.value;
	};

	CheckboxNameBinding.prototype.handleChange = function handleChange () {
		this.isChecked = this.element.node.checked;
		this.group.value = this.model.get();
		var value = this.element.getAttribute( 'value' );
		if ( this.isChecked &amp;&amp; !this.arrayContains( this.group.value, value ) ) {
			this.group.value.push( value );
		} else if ( !this.isChecked &amp;&amp; this.arrayContains( this.group.value, value ) ) {
			this.removeFromArray( this.group.value, value );
		}
		// make sure super knows there's a change
		this.lastValue = null;
		Binding$$1.prototype.handleChange.call(this);
	};

	CheckboxNameBinding.prototype.render = function render () {
		Binding$$1.prototype.render.call(this);

		var node = this.node;

		var existingValue = this.model.get();
		var bindingValue = this.element.getAttribute( 'value' );

		if ( Array.isArray( existingValue ) ) {
			this.isChecked = this.arrayContains( existingValue, bindingValue );
		} else {
			this.isChecked = this.element.compare( existingValue, bindingValue );
		}
		node.name = '<A href="/wiki/index.php?title=Template:%27_%2B_this.model.getKeypath()_%2B_%27&amp;action=edit&amp;redlink=1" class="new" title="Template:' + this.model.getKeypath() + ' (page does not exist)">Template:' + this.model.getKeypath() + '</A>';
		node.checked = this.isChecked;

		node.addEventListener( 'change', handleDomEvent, false );

		// in case of IE emergency, bind to click event as well
		if ( node.attachEvent ) {
			node.addEventListener( 'click', handleDomEvent, false );
		}
	};

	CheckboxNameBinding.prototype.setFromNode = function setFromNode ( node ) {
		this.group.bindings.forEach( function (binding) { return binding.wasUndefined = true; } );

		if ( node.checked ) {
			var valueSoFar = this.group.getValue();
			valueSoFar.push( this.element.getAttribute( 'value' ) );

			this.group.model.set( valueSoFar );
		}
	};

	CheckboxNameBinding.prototype.unbind = function unbind () {
		this.group.remove( this );
	};

	CheckboxNameBinding.prototype.unrender = function unrender () {
		var node = this.element.node;

		node.removeEventListener( 'change', handleDomEvent, false );
		node.removeEventListener( 'click', handleDomEvent, false );
	};

	CheckboxNameBinding.prototype.arrayContains = function arrayContains ( selectValue, optionValue ) {
		var this$1 = this;

		var i = selectValue.length;
		while ( i-- ) {
			if ( this$1.element.compare( optionValue, selectValue[i] ) ) { return true; }
		}
		return false;
	};

	CheckboxNameBinding.prototype.removeFromArray = function removeFromArray ( array, item ) {
		var this$1 = this;

		if (!array) { return; }
		var i = array.length;
		while( i-- ) {
			if ( this$1.element.compare( item, array[i] ) ) {
				array.splice( i, 1 );
			}
		}
	};

	return CheckboxNameBinding;
}(Binding));

var ContentEditableBinding = (function (Binding$$1) {
	function ContentEditableBinding () {
		Binding$$1.apply(this, arguments);
	}

	if ( Binding$$1 ) ContentEditableBinding.__proto__ = Binding$$1;
	ContentEditableBinding.prototype = Object.create( Binding$$1 &amp;&amp; Binding$$1.prototype );
	ContentEditableBinding.prototype.constructor = ContentEditableBinding;

	ContentEditableBinding.prototype.getInitialValue = function getInitialValue () {
		return this.element.fragment ? this.element.fragment.toString() : <I>;</I>
	};

	ContentEditableBinding.prototype.getValue = function getValue () {
		return this.element.node.innerHTML;
	};

	ContentEditableBinding.prototype.render = function render () {
		Binding$$1.prototype.render.call(this);

		var node = this.node;

		node.addEventListener( 'change', handleDomEvent, false );
		node.addEventListener( 'blur', handleDomEvent, false );

		if ( !this.ractive.lazy ) {
			node.addEventListener( 'input', handleDomEvent, false );

			if ( node.attachEvent ) {
				node.addEventListener( 'keyup', handleDomEvent, false );
			}
		}
	};

	ContentEditableBinding.prototype.setFromNode = function setFromNode ( node ) {
		this.model.set( node.innerHTML );
	};

	ContentEditableBinding.prototype.unrender = function unrender () {
		var node = this.node;

		node.removeEventListener( 'blur', handleDomEvent, false );
		node.removeEventListener( 'change', handleDomEvent, false );
		node.removeEventListener( 'input', handleDomEvent, false );
		node.removeEventListener( 'keyup', handleDomEvent, false );
	};

	return ContentEditableBinding;
}(Binding));

function handleBlur () {
	handleDomEvent.call( this );

	var value = this._ractive.binding.model.get();
	this.value = value == undefined ? <I> : value;</I>
}

function handleDelay ( delay ) {
	var timeout;

	return function () {
		var this$1 = this;

		if ( timeout ) { clearTimeout( timeout ); }

		timeout = setTimeout( function () {
			var binding = this$1._ractive.binding;
			if ( binding.rendered ) { handleDomEvent.call( this$1 ); }
			timeout = null;
		}, delay );
	};
}

var GenericBinding = (function (Binding$$1) {
	function GenericBinding () {
		Binding$$1.apply(this, arguments);
	}

	if ( Binding$$1 ) GenericBinding.__proto__ = Binding$$1;
	GenericBinding.prototype = Object.create( Binding$$1 &amp;&amp; Binding$$1.prototype );
	GenericBinding.prototype.constructor = GenericBinding;

	GenericBinding.prototype.getInitialValue = function getInitialValue () {
		return <I>;</I>
	};

	GenericBinding.prototype.getValue = function getValue () {
		return this.node.value;
	};

	GenericBinding.prototype.render = function render () {
		Binding$$1.prototype.render.call(this);

		// any lazy setting for this element overrides the root
		// if the value is a number, it's a timeout
		var lazy = this.ractive.lazy;
		var timeout = false;

		if ( 'lazy' in this.element ) {
			lazy = this.element.lazy;
		}

		if ( isNumeric( lazy ) ) {
			timeout = +lazy;
			lazy = false;
		}

		this.handler = timeout ? handleDelay( timeout ) : handleDomEvent;

		var node = this.node;

		node.addEventListener( 'change', handleDomEvent, false );

		if ( !lazy ) {
			node.addEventListener( 'input', this.handler, false );

			if ( node.attachEvent ) {
				node.addEventListener( 'keyup', this.handler, false );
			}
		}

		node.addEventListener( 'blur', handleBlur, false );
	};

	GenericBinding.prototype.unrender = function unrender () {
		var node = this.element.node;
		this.rendered = false;

		node.removeEventListener( 'change', handleDomEvent, false );
		node.removeEventListener( 'input', this.handler, false );
		node.removeEventListener( 'keyup', this.handler, false );
		node.removeEventListener( 'blur', handleBlur, false );
	};

	return GenericBinding;
}(Binding));

var FileBinding = (function (GenericBinding$$1) {
	function FileBinding () {
		GenericBinding$$1.apply(this, arguments);
	}

	if ( GenericBinding$$1 ) FileBinding.__proto__ = GenericBinding$$1;
	FileBinding.prototype = Object.create( GenericBinding$$1 &amp;&amp; GenericBinding$$1.prototype );
	FileBinding.prototype.constructor = FileBinding;

	FileBinding.prototype.getInitialValue = function getInitialValue () {
		return undefined;
	};

	FileBinding.prototype.getValue = function getValue () {
		return this.node.files;
	};

	FileBinding.prototype.render = function render () {
		this.element.lazy = false;
		GenericBinding$$1.prototype.render.call(this);
	};

	FileBinding.prototype.setFromNode = function setFromNode ( node ) {
		this.model.set( node.files );
	};

	return FileBinding;
}(GenericBinding));

function getSelectedOptions ( select ) {
	return select.selectedOptions
		? toArray( select.selectedOptions )
		: select.options
			? toArray( select.options ).filter( function (option) { return option.selected; } )
			: [];
}

var MultipleSelectBinding = (function (Binding$$1) {
	function MultipleSelectBinding () {
		Binding$$1.apply(this, arguments);
	}

	if ( Binding$$1 ) MultipleSelectBinding.__proto__ = Binding$$1;
	MultipleSelectBinding.prototype = Object.create( Binding$$1 &amp;&amp; Binding$$1.prototype );
	MultipleSelectBinding.prototype.constructor = MultipleSelectBinding;

	MultipleSelectBinding.prototype.getInitialValue = function getInitialValue () {
		return this.element.options
			.filter( function (option) { return option.getAttribute( 'selected' ); } )
			.map( function (option) { return option.getAttribute( 'value' ); } );
	};

	MultipleSelectBinding.prototype.getValue = function getValue () {
		var options = this.element.node.options;
		var len = options.length;

		var selectedValues = [];

		for ( var i = 0; i &lt; len; i += 1 ) {
			var option = options[i];

			if ( option.selected ) {
				var optionValue = option._ractive ? option._ractive.value : option.value;
				selectedValues.push( optionValue );
			}
		}

		return selectedValues;
	};

	MultipleSelectBinding.prototype.handleChange = function handleChange () {
		var attribute = this.attribute;
		var previousValue = attribute.getValue();

		var value = this.getValue();

		if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
			Binding$$1.prototype.handleChange.call(this);
		}

		return this;
	};

	MultipleSelectBinding.prototype.render = function render () {
		Binding$$1.prototype.render.call(this);

		this.node.addEventListener( 'change', handleDomEvent, false );

		if ( this.model.get() === undefined ) {
			// get value from DOM, if possible
			this.handleChange();
		}
	};

	MultipleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {
		var selectedOptions = getSelectedOptions( node );
		var i = selectedOptions.length;
		var result = new Array( i );

		while ( i-- ) {
			var option = selectedOptions[i];
			result[i] = option._ractive ? option._ractive.value : option.value;
		}

		this.model.set( result );
	};

	MultipleSelectBinding.prototype.unrender = function unrender () {
		this.node.removeEventListener( 'change', handleDomEvent, false );
	};

	return MultipleSelectBinding;
}(Binding));

var NumericBinding = (function (GenericBinding$$1) {
	function NumericBinding () {
		GenericBinding$$1.apply(this, arguments);
	}

	if ( GenericBinding$$1 ) NumericBinding.__proto__ = GenericBinding$$1;
	NumericBinding.prototype = Object.create( GenericBinding$$1 &amp;&amp; GenericBinding$$1.prototype );
	NumericBinding.prototype.constructor = NumericBinding;

	NumericBinding.prototype.getInitialValue = function getInitialValue () {
		return undefined;
	};

	NumericBinding.prototype.getValue = function getValue () {
		var value = parseFloat( this.node.value );
		return isNaN( value ) ? undefined : value;
	};

	NumericBinding.prototype.setFromNode = function setFromNode ( node ) {
		var value = parseFloat( node.value );
		if ( !isNaN( value ) ) { this.model.set( value ); }
	};

	return NumericBinding;
}(GenericBinding));

var siblings = {};

function getSiblings ( hash ) {
	return siblings[ hash ] || ( siblings[ hash ] = [] );
}

var RadioBinding = (function (Binding$$1) {
	function RadioBinding ( element ) {
		Binding$$1.call( this, element, 'checked' );

		this.siblings = getSiblings( this.ractive._guid + this.element.getAttribute( 'name' ) );
		this.siblings.push( this );
	}

	if ( Binding$$1 ) RadioBinding.__proto__ = Binding$$1;
	RadioBinding.prototype = Object.create( Binding$$1 &amp;&amp; Binding$$1.prototype );
	RadioBinding.prototype.constructor = RadioBinding;

	RadioBinding.prototype.getValue = function getValue () {
		return this.node.checked;
	};

	RadioBinding.prototype.handleChange = function handleChange () {
		runloop.start( this.root );

		this.siblings.forEach( function (binding) {
			binding.model.set( binding.getValue() );
		});

		runloop.end();
	};

	RadioBinding.prototype.render = function render () {
		Binding$$1.prototype.render.call(this);

		this.node.addEventListener( 'change', handleDomEvent, false );

		if ( this.node.attachEvent ) {
			this.node.addEventListener( 'click', handleDomEvent, false );
		}
	};

	RadioBinding.prototype.setFromNode = function setFromNode ( node ) {
		this.model.set( node.checked );
	};

	RadioBinding.prototype.unbind = function unbind () {
		removeFromArray( this.siblings, this );
	};

	RadioBinding.prototype.unrender = function unrender () {
		this.node.removeEventListener( 'change', handleDomEvent, false );
		this.node.removeEventListener( 'click', handleDomEvent, false );
	};

	return RadioBinding;
}(Binding));

function getValue$1() {
	var checked = this.bindings.filter( function (b) { return b.node.checked; } );
	if ( checked.length &gt; 0 ) {
		return checked[0].element.getAttribute( 'value' );
	}
}

var RadioNameBinding = (function (Binding$$1) {
	function RadioNameBinding ( element ) {
		Binding$$1.call( this, element, 'name' );

		this.group = getBindingGroup( 'radioname', this.model, getValue$1 );
		this.group.add( this );

		if ( element.checked ) {
			this.group.value = this.getValue();
		}
	}

	if ( Binding$$1 ) RadioNameBinding.__proto__ = Binding$$1;
	RadioNameBinding.prototype = Object.create( Binding$$1 &amp;&amp; Binding$$1.prototype );
	RadioNameBinding.prototype.constructor = RadioNameBinding;

	RadioNameBinding.prototype.bind = function bind () {
		var this$1 = this;

		if ( !this.group.bound ) {
			this.group.bind();
		}

		// update name keypath when necessary
		this.nameAttributeBinding = {
			handleChange: function () { return this$1.node.name = &quot;<A href="/wiki/index.php?title=Template:%22_%2B_(this$1.model.getKeypath())_%2B_%22&amp;action=edit&amp;redlink=1" class="new" title="Template:&quot; + (this$1.model.getKeypath()) + &quot; (page does not exist)">Template:&quot; + (this$1.model.getKeypath()) + &quot;</A>&quot;; },
			rebind: noop
		};

		this.model.getKeypathModel().register( this.nameAttributeBinding );
	};

	RadioNameBinding.prototype.getInitialValue = function getInitialValue () {
		if ( this.element.getAttribute( 'checked' ) ) {
			return this.element.getAttribute( 'value' );
		}
	};

	RadioNameBinding.prototype.getValue = function getValue () {
		return this.element.getAttribute( 'value' );
	};

	RadioNameBinding.prototype.handleChange = function handleChange () {
		// If this &lt;input&gt; is the one that's checked, then the value of its
		// `name` model gets set to its value
		if ( this.node.checked ) {
			this.group.value = this.getValue();
			Binding$$1.prototype.handleChange.call(this);
		}
	};

	RadioNameBinding.prototype.lastVal = function lastVal ( setting, value ) {
		if ( !this.group ) { return; }
		if ( setting ) { this.group.lastValue = value; }
		else { return this.group.lastValue; }
	};

	RadioNameBinding.prototype.render = function render () {
		Binding$$1.prototype.render.call(this);

		var node = this.node;

		node.name = &quot;<A href="/wiki/index.php?title=Template:%22_%2B_(this.model.getKeypath())_%2B_%22&amp;action=edit&amp;redlink=1" class="new" title="Template:&quot; + (this.model.getKeypath()) + &quot; (page does not exist)">Template:&quot; + (this.model.getKeypath()) + &quot;</A>&quot;;
		node.checked = this.element.compare ( this.model.get(), this.element.getAttribute( 'value' ) );

		node.addEventListener( 'change', handleDomEvent, false );

		if ( node.attachEvent ) {
			node.addEventListener( 'click', handleDomEvent, false );
		}
	};

	RadioNameBinding.prototype.setFromNode = function setFromNode ( node ) {
		if ( node.checked ) {
			this.group.model.set( this.element.getAttribute( 'value' ) );
		}
	};

	RadioNameBinding.prototype.unbind = function unbind () {
		this.group.remove( this );

		this.model.getKeypathModel().unregister( this.nameAttributeBinding );
	};

	RadioNameBinding.prototype.unrender = function unrender () {
		var node = this.node;

		node.removeEventListener( 'change', handleDomEvent, false );
		node.removeEventListener( 'click', handleDomEvent, false );
	};

	return RadioNameBinding;
}(Binding));

var SingleSelectBinding = (function (Binding$$1) {
	function SingleSelectBinding () {
		Binding$$1.apply(this, arguments);
	}

	if ( Binding$$1 ) SingleSelectBinding.__proto__ = Binding$$1;
	SingleSelectBinding.prototype = Object.create( Binding$$1 &amp;&amp; Binding$$1.prototype );
	SingleSelectBinding.prototype.constructor = SingleSelectBinding;

	SingleSelectBinding.prototype.forceUpdate = function forceUpdate () {
		var this$1 = this;

		var value = this.getValue();

		if ( value !== undefined ) {
			this.attribute.locked = true;
			runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );
			this.model.set( value );
		}
	};

	SingleSelectBinding.prototype.getInitialValue = function getInitialValue () {
		if ( this.element.getAttribute( 'value' ) !== undefined ) {
			return;
		}

		var options = this.element.options;
		var len = options.length;

		if ( !len ) { return; }

		var value;
		var optionWasSelected;
		var i = len;

		// take the final selected option...
		while ( i-- ) {
			var option = options[i];

			if ( option.getAttribute( 'selected' ) ) {
				if ( !option.getAttribute( 'disabled' ) ) {
					value = option.getAttribute( 'value' );
				}

				optionWasSelected = true;
				break;
			}
		}

		// or the first non-disabled option, if none are selected
		if ( !optionWasSelected ) {
			while ( ++i &lt; len ) {
				if ( !options[i].getAttribute( 'disabled' ) ) {
					value = options[i].getAttribute( 'value' );
					break;
				}
			}
		}

		// This is an optimisation (aka hack) that allows us to forgo some
		// other more expensive work
		// TODO does it still work? seems at odds with new architecture
		if ( value !== undefined ) {
			this.element.attributeByName.value.value = value;
		}

		return value;
	};

	SingleSelectBinding.prototype.getValue = function getValue () {
		var options = this.node.options;
		var len = options.length;

		var i;
		for ( i = 0; i &lt; len; i += 1 ) {
			var option = options[i];

			if ( options[i].selected &amp;&amp; !options[i].disabled ) {
				return option._ractive ? option._ractive.value : option.value;
			}
		}
	};

	SingleSelectBinding.prototype.render = function render () {
		Binding$$1.prototype.render.call(this);
		this.node.addEventListener( 'change', handleDomEvent, false );
	};

	SingleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {
		var option = getSelectedOptions( node )[0];
		this.model.set( option._ractive ? option._ractive.value : option.value );
	};

	SingleSelectBinding.prototype.unrender = function unrender () {
		this.node.removeEventListener( 'change', handleDomEvent, false );
	};

	return SingleSelectBinding;
}(Binding));

function isBindable ( attribute ) {

	// The fragment must be a single non-string fragment
	if ( !attribute || !attribute.template.f || !attribute.template.f.length === 1 || attribute.template.f[0].s ) { return false; }

	// A binding is an interpolator `{{ }}`, yey.
	if ( attribute.template.f[0].t === INTERPOLATOR ) { return true; }

	// The above is probably the only true case. For the rest, show an appropriate
	// warning before returning false.

	// You can't bind a triple curly. HTML values on an attribute makes no sense.
	if ( attribute.template.f[0].t === TRIPLE ) { warnIfDebug( 'It is not possible create a binding using a triple mustache.' ); }

	return false;
}

function selectBinding ( element ) {
	var name = element.name;
	var attributes = element.attributeByName;
	var isBindableByValue = isBindable( attributes.value );
	var isBindableByContentEditable = isBindable( attributes.contenteditable );
	var isContentEditable =  element.getAttribute( 'contenteditable' );

	// contenteditable
	// Bind if the contenteditable is true or a binding that may become true.
	if ( ( isContentEditable || isBindableByContentEditable ) &amp;&amp; isBindableByValue ) { return ContentEditableBinding; }

	// &lt;input&gt;
	if ( name === 'input' ) {
		var type = element.getAttribute( 'type' );

		if ( type === 'radio' ) {
			var isBindableByName = isBindable( attributes.name );
			var isBindableByChecked = isBindable( attributes.checked );

			// For radios we can either bind the name or checked, but not both.
			// Name binding is handed instead.
			if ( isBindableByName &amp;&amp; isBindableByChecked ) {
				warnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });
				return RadioNameBinding;
			}

			if ( isBindableByName ) { return RadioNameBinding; }

			if ( isBindableByChecked ) { return RadioBinding; }

			// Dead end. Unknown binding on radio input.
			return null;
		}

		if ( type === 'checkbox' ) {
			var isBindableByName$1 = isBindable( attributes.name );
			var isBindableByChecked$1 = isBindable( attributes.checked );

			// A checkbox with bindings for both name and checked. Checked treated as
			// the checkbox value, name is treated as a regular binding.
			//
			// See <A rel="nofollow" class="external free" href="https://github.com/ractivejs/ractive/issues/1749">https://github.com/ractivejs/ractive/issues/1749</A>
			if ( isBindableByName$1 &amp;&amp; isBindableByChecked$1 ) { return CheckboxBinding; }

			if ( isBindableByName$1 ) { return CheckboxNameBinding; }

			if ( isBindableByChecked$1 ) { return CheckboxBinding; }

			// Dead end. Unknown binding on checkbox input.
			return null;
		}

		if ( type === 'file' &amp;&amp; isBindableByValue ) { return FileBinding; }

		if ( type === 'number' &amp;&amp; isBindableByValue ) { return NumericBinding; }

		if ( type === 'range' &amp;&amp; isBindableByValue ) { return NumericBinding; }

		// Some input of unknown type (browser usually falls back to text).
		if ( isBindableByValue ) { return GenericBinding; }

		// Dead end. Some unknown input and an unbindable.
		return null;
	}

	// &lt;select&gt;
	if ( name === 'select' &amp;&amp; isBindableByValue ){
		return element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SingleSelectBinding;
	}

	// &lt;textarea&gt;
	if ( name === 'textarea' &amp;&amp; isBindableByValue ) { return GenericBinding; }

	// Dead end. Some unbindable element.
	return null;
}

var DOMEvent = function DOMEvent ( name, owner, delegate ) {
	if ( name.indexOf( '*' ) !== -1 ) {
		fatal( (&quot;Only component proxy-events may contain \&quot;*\&quot; wildcards, &lt;&quot; + (owner.name) + &quot; on-&quot; + name + &quot;=\&quot;...\&quot;/&gt; is not valid&quot;) );
	}

	this.name = name;
	this.owner = owner;
	this.delegate = delegate;
	this.node = null;
	this.handler = null;
};

DOMEvent.prototype.listen = function listen ( directive ) {
	var node = this.node = this.owner.node;
	var name = this.name;

	// this is probably a custom event fired from a decorator or manually
	if ( !( (&quot;on&quot; + name) in node ) ) { return; }

	node.addEventListener( name, this.handler = function( event ) {
		directive.fire({
			node: node,
			original: event,
			event: event,
			name: name
		});
	}, this.delegate );
};

DOMEvent.prototype.unlisten = function unlisten () {
	if ( this.handler ) { this.node.removeEventListener( this.name, this.handler, false ); }
};

var CustomEvent = function CustomEvent ( eventPlugin, owner, name ) {
	this.eventPlugin = eventPlugin;
	this.owner = owner;
	this.name = name;
	this.handler = null;
};

CustomEvent.prototype.listen = function listen ( directive ) {
		var this$1 = this;

	var node = this.owner.node;

	this.handler = this.eventPlugin( node, function ( event ) {
			if ( event === void 0 ) event = {};

		if ( event.original ) { event.event = event.original; }
		else { event.original = event.event; }

		event.name = this$1.name;
		event.node = event.node || node;
		directive.fire( event );
	});
};

CustomEvent.prototype.unlisten = function unlisten () {
	this.handler.teardown();
};

var RactiveEvent = function RactiveEvent ( component, name ) {
	this.component = component;
	this.name = name;
	this.handler = null;
};

RactiveEvent.prototype.listen = function listen ( directive ) {
	var ractive = this.component.instance;

	this.handler = ractive.on( this.name, function () {
			var args = [], len = arguments.length;
			while ( len-- ) args[ len ] = arguments[ len ];

		// watch for reproxy
		if ( args[0] instanceof Context ) {
			var ctx = args.shift();
			ctx.component = ractive;
			directive.fire( ctx, args );
		} else {
			directive.fire( {}, args );
		}

		// cancel bubbling
		return false;
	});
};

RactiveEvent.prototype.unlisten = function unlisten () {
	this.handler.cancel();
};

var specialPattern = /^(event|arguments|@node|@event|@context)(\..+)?$/;
var dollarArgsPattern = /^\$(\d+)(\..+)?$/;

var DelegateProxy = {
	fire: function fire ( event, args ) {
		if ( args === void 0 ) args = [];

		if ( event &amp;&amp; event.event ) {
			var ev = event.event;

			// TODO if IE&lt;9 needs to be supported here, could probably walk to the element with a ractive proxy with a delegates property
			var end = ev.currentTarget;
			var node = ev.target;
			var name = event.name;
			var bubble = true;

			// starting with the origin node, walk up the DOM looking for ractive nodes with a matching event listener
			while ( bubble &amp;&amp; node &amp;&amp; node !== end ) {
				var el = node._ractive &amp;&amp; node._ractive.proxy;

				if ( el ) {
					// set up the context for the handler
					event.node = el.node;
					event.name = name;

					el.events.forEach( function (ev) {
						if ( ev.delegate &amp;&amp; ~ev.template.n.indexOf( name ) ) {
							bubble = ev.fire( event, args ) !== false &amp;&amp; bubble;
						}
					});
				}

				node = node.parentNode;
			}

			return bubble;
		}
	}
};

var EventDirective = function EventDirective ( options ) {
	var this$1 = this;

	this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );
	this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment, true );
	this.template = options.template;
	this.parentFragment = options.parentFragment;
	this.ractive = options.parentFragment.ractive;
	var delegate = this.delegate = this.ractive.delegate &amp;&amp; options.parentFragment.delegate;
	this.events = [];

	if ( this.element.type === COMPONENT || this.element.type === ANCHOR ) {
		this.template.n.forEach( function (n) {
			this$1.events.push( new RactiveEvent( this$1.element, n ) );
		});
	} else {
		// make sure the delegate element has a storag object
		if ( delegate &amp;&amp; !delegate.delegates ) { delegate.delegates = {}; }

		this.template.n.forEach( function (n) {
			var fn = findInViewHierarchy( 'events', this$1.ractive, n );
			if ( fn ) {
				this$1.events.push( new CustomEvent( fn, this$1.element, n ) );
			} else {
				if ( delegate ) {
					if ( !delegate.delegates[n] ) {
						var ev = new DOMEvent( n, delegate, true );
						delegate.delegates[n] = ev;
						// if the element is already rendered, render the event too
						if ( delegate.rendered ) { ev.listen( DelegateProxy ); }
					}
				} else {
					this$1.events.push( new DOMEvent( n, this$1.element ) );
				}
			}
		});
	}

	// method calls
	this.models = null;
};

EventDirective.prototype.bind = function bind () {
	addToArray( this.element.events, this );

	setupArgsFn( this, this.template );
	if ( !this.fn ) { this.action = this.template.f; }
};

EventDirective.prototype.destroyed = function destroyed () {
	this.events.forEach( function (e) { return e.unlisten(); } );
};

EventDirective.prototype.fire = function fire ( event, args ) {
		var this$1 = this;
		if ( args === void 0 ) args = [];

	var context = this.element.getContext( event );

	if ( this.fn ) {
		var values = [];

		var models = resolveArgs( this, this.template, this.parentFragment, {
			specialRef: function specialRef ( ref ) {
				var specialMatch = specialPattern.exec( ref );
				if ( specialMatch ) {
					// on-click=&quot;foo(event.node)&quot;
					return {
						special: specialMatch[1],
						keys: specialMatch[2] ? splitKeypath( specialMatch[2].substr(1) ) : []
					};
				}

				var dollarMatch = dollarArgsPattern.exec( ref );
				if ( dollarMatch ) {
					// on-click=&quot;foo($1)&quot;
					return {
						special: 'arguments',
						keys: [ dollarMatch[1] - 1 ].concat( dollarMatch[2] ? splitKeypath( dollarMatch[2].substr( 1 ) ) : [] )
					};
				}
			}
		});

		if ( models ) {
			models.forEach( function (model) {
				if ( !model ) { return values.push( undefined ); }

				if ( model.special ) {
					var which = model.special;
					var obj;

					if ( which === '@node' ) {
						obj = this$1.element.node;
					} else if ( which === '@event' ) {
						obj = event &amp;&amp; event.event;
					} else if ( which === 'event' ) {
						warnOnceIfDebug( &quot;The event reference available to event directives is deprecated and should be replaced with @context and @event&quot; );
						obj = context;
					} else if ( which === '@context' ) {
						obj = context;
					} else {
						obj = args;
					}

					var keys = model.keys.slice();

					while ( obj &amp;&amp; keys.length ) { obj = obj[ keys.shift() ]; }
					return values.push( obj );
				}

				if ( model.wrapper ) {
					return values.push( model.wrapperValue );
				}

				values.push( model.get() );
			});
		}

		// make event available as `this.event`
		var ractive = this.ractive;
		var oldEvent = ractive.event;

		ractive.event = context;
		var returned = this.fn.apply( ractive, values );
		var result = returned.pop();

		// Auto prevent and stop if return is explicitly false
		if ( result === false ) {
			var original = event ? event.original : undefined;
			if ( original ) {
				original.preventDefault &amp;&amp; original.preventDefault();
				original.stopPropagation &amp;&amp; original.stopPropagation();
			} else {
				warnOnceIfDebug( (&quot;handler '&quot; + (this.template.n.join( ' ' )) + &quot;' returned false, but there is no event available to cancel&quot;) );
			}
		}

		// watch for proxy events
		else if ( !returned.length &amp;&amp; Array.isArray( result ) &amp;&amp; typeof result[0] === 'string' ) {
			result = fireEvent( this.ractive, result.shift(), context, result );
		}

		ractive.event = oldEvent;

		return result;
	}

	else {
		return fireEvent( this.ractive, this.action, context, args);
	}
};

EventDirective.prototype.handleChange = function handleChange () {};

EventDirective.prototype.render = function render () {
		var this$1 = this;

	// render events after everything else, so they fire after bindings
	runloop.scheduleTask( function () { return this$1.events.forEach( function (e) { return e.listen( this$1 ); }, true ); } );
};

EventDirective.prototype.toString = function toString () { return <I>; };</I>

EventDirective.prototype.unbind = function unbind () {
	removeFromArray( this.element.events, this );
};

EventDirective.prototype.unrender = function unrender () {
	this.events.forEach( function (e) { return e.unlisten(); } );
};

EventDirective.prototype.update = noop;

var endsWithSemi = /;\s*$/;

var Element = (function (ContainerItem$$1) {
	function Element ( options ) {
		var this$1 = this;

		ContainerItem$$1.call( this, options );

		this.name = options.template.e.toLowerCase();
		this.isVoid = voidElementNames.test( this.name );

		// find parent element
		this.parent = findElement( this.parentFragment, false );

		if ( this.parent &amp;&amp; this.parent.name === 'option' ) {
			throw new Error( (&quot;An &lt;option&gt; element cannot contain other elements (encountered &lt;&quot; + (this.name) + &quot;&gt;)&quot;) );
		}

		this.decorators = [];
		this.events = [];

		// create attributes
		this.attributeByName = {};

		this.attributes = [];
		var leftovers = [];
		( this.template.m || [] ).forEach( function (template) {
			switch ( template.t ) {
				case ATTRIBUTE:
				case BINDING_FLAG:
				case DECORATOR:
				case EVENT:
				case TRANSITION:
					this$1.attributes.push( createItem({
						owner: this$1,
						parentFragment: this$1.parentFragment,
						template: template
					}) );
					break;

				case DELEGATE_FLAG:
				  this$1.delegate = false;
					break;

				default:
					leftovers.push( template );
					break;
			}
		});

		if ( leftovers.length ) {
			this.attributes.push( new ConditionalAttribute({
				owner: this,
				parentFragment: this.parentFragment,
				template: leftovers
			}) );
		}

		this.attributes.sort( sortAttributes );

		// create children
		if ( options.template.f &amp;&amp; !options.deferContent ) {
			this.fragment = new Fragment({
				template: options.template.f,
				owner: this,
				cssIds: null
			});
		}

		this.binding = null; // filled in later
	}

	if ( ContainerItem$$1 ) Element.__proto__ = ContainerItem$$1;
	Element.prototype = Object.create( ContainerItem$$1 &amp;&amp; ContainerItem$$1.prototype );
	Element.prototype.constructor = Element;

	Element.prototype.bind = function bind$1 () {
		this.attributes.binding = true;
		this.attributes.forEach( bind );
		this.attributes.binding = false;

		if ( this.fragment ) { this.fragment.bind(); }

		// create two-way binding if necessary
		if ( !this.binding ) { this.recreateTwowayBinding(); }
		else { this.binding.bind(); }
	};

	Element.prototype.createTwowayBinding = function createTwowayBinding () {
		if ( 'twoway' in this ? this.twoway : this.ractive.twoway ) {
			var Binding = selectBinding( this );
			if ( Binding ) {
				var binding = new Binding( this );
				if ( binding &amp;&amp; binding.model ) { return binding; }
			}
		}
	};

	Element.prototype.destroyed = function destroyed$1 () {
		var this$1 = this;

		this.attributes.forEach( destroyed );
		for ( var ev in this$1.delegates ) {
			this$1.delegates[ev].unlisten();
		}
		if ( this.fragment ) { this.fragment.destroyed(); }
	};

	Element.prototype.detach = function detach () {
		// if this element is no longer rendered, the transitions are complete and the attributes can be torn down
		if ( !this.rendered ) { this.destroyed(); }

		return detachNode( this.node );
	};

	Element.prototype.find = function find ( selector, options ) {
		if ( this.node &amp;&amp; matches( this.node, selector ) ) { return this.node; }
		if ( this.fragment ) {
			return this.fragment.find( selector, options );
		}
	};

	Element.prototype.findAll = function findAll ( selector, options ) {
		var result = options.result;

		if ( matches( this.node, selector ) ) {
			result.push( this.node );
		}

		if ( this.fragment ) {
			this.fragment.findAll( selector, options );
		}
	};

	Element.prototype.findNextNode = function findNextNode () {
		return null;
	};

	Element.prototype.firstNode = function firstNode () {
		return this.node;
	};

	Element.prototype.getAttribute = function getAttribute ( name ) {
		var attribute = this.attributeByName[ name ];
		return attribute ? attribute.getValue() : undefined;
	};

	Element.prototype.getContext = function getContext () {
		var assigns = [], len = arguments.length;
		while ( len-- ) assigns[ len ] = arguments[ len ];

		if ( this.fragment ) { return (ref = this.fragment).getContext.apply( ref, assigns ); }

		if ( !this.ctx ) { this.ctx = new Context( this.parentFragment, this ); }
		assigns.unshift( Object.create( this.ctx ) );
		return Object.assign.apply( null, assigns );
		var ref;
	};

	Element.prototype.recreateTwowayBinding = function recreateTwowayBinding () {
		if ( this.binding ) {
			this.binding.unbind();
			this.binding.unrender();
		}

		if ( this.binding = this.createTwowayBinding() ) {
			this.binding.bind();
			if ( this.rendered ) { this.binding.render(); }
		}
	};

	Element.prototype.render = function render$1 ( target, occupants ) {
		var this$1 = this;

		// TODO determine correct namespace
		this.namespace = getNamespace( this );

		var node;
		var existing = false;

		if ( occupants ) {
			var n;
			while ( ( n = occupants.shift() ) ) {
				if ( n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() &amp;&amp; n.namespaceURI === this$1.namespace ) {
					this$1.node = node = n;
					existing = true;
					break;
				} else {
					detachNode( n );
				}
			}
		}

		if ( !node ) {
			var name = this.template.e;
			node = createElement( this.namespace === html ? name.toLowerCase() : name, this.namespace, this.getAttribute( 'is' ) );
			this.node = node;
		}

		// tie the node to this vdom element
		Object.defineProperty( node, '_ractive', {
			value: {
				proxy: this
			}
		});

		// Is this a top-level node of a component? If so, we may need to add
		// a data-ractive-css attribute, for CSS encapsulation
		if ( this.parentFragment.cssIds ) {
			node.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( function (x) { return (&quot;{&quot; + x + &quot;}&quot;); } ).join( ' ' ) );
		}

		if ( existing &amp;&amp; this.foundNode ) { this.foundNode( node ); }

		// register intro before rendering content so children can find the intro
		var intro = this.intro;
		if ( intro &amp;&amp; intro.shouldFire( 'intro' ) ) {
			intro.isIntro = true;
			intro.isOutro = false;
			runloop.registerTransition( intro );
		}

		if ( this.fragment ) {
			var children = existing ? toArray( node.childNodes ) : undefined;

			this.fragment.render( node, children );

			// clean up leftover children
			if ( children ) {
				children.forEach( detachNode );
			}
		}

		if ( existing ) {
			// store initial values for two-way binding
			if ( this.binding &amp;&amp; this.binding.wasUndefined ) { this.binding.setFromNode( node ); }
			// remove unused attributes
			var i = node.attributes.length;
			while ( i-- ) {
				var name$1 = node.attributes[i].name;
				if ( !( name$1 in this$1.attributeByName ) ){ node.removeAttribute( name$1 ); }
			}
		}

		this.attributes.forEach( render );
		if ( this.delegates ) {
			for ( var ev in this$1.delegates ) {
				this$1.delegates[ev].listen( DelegateProxy );
			}
		}

		if ( this.binding ) { this.binding.render(); }

		if ( !existing ) {
			target.appendChild( node );
		}

		this.rendered = true;
	};

	Element.prototype.toString = function toString$$1 () {
		var tagName = this.template.e;

		var attrs = this.attributes.map( stringifyAttribute ).join( <I> );</I>

		// Special case - selected options
		if ( this.name === 'option' &amp;&amp; this.isSelected() ) {
			attrs += ' selected';
		}

		// Special case - two-way radio name bindings
		if ( this.name === 'input' &amp;&amp; inputIsCheckedRadio( this ) ) {
			attrs += ' checked';
		}

		// Special case style and class attributes and directives
		var style, cls;
		this.attributes.forEach( function (attr) {
			if ( attr.name === 'class' ) {
				cls = ( cls || <I> ) + ( cls ? ' ' : </I> ) + safeAttributeString( attr.getString() );
			} else if ( attr.name === 'style' ) {
				style = ( style || <I> ) + ( style ? ' ' : </I> ) + safeAttributeString( attr.getString() );
				if ( style &amp;&amp; !endsWithSemi.test( style ) ) { style += ';'; }
			} else if ( attr.style ) {
				style = ( style || <I> ) + ( style ? ' ' : </I> ) +  (attr.style) + &quot;: &quot; + (safeAttributeString( attr.getString() )) + &quot;;&quot;;
			} else if ( attr.inlineClass &amp;&amp; attr.getValue() ) {
				cls = ( cls || <I> ) + ( cls ? ' ' : </I> ) + attr.inlineClass;
			}
		});
		// put classes first, then inline style
		if ( style !== undefined ) { attrs = ' style' + ( style ? (&quot;=\&quot;&quot; + style + &quot;\&quot;&quot;) : <I> ) + attrs; }</I>
		if ( cls !== undefined ) { attrs = ' class' + (cls ? (&quot;=\&quot;&quot; + cls + &quot;\&quot;&quot;) : <I>) + attrs; }</I>

		if ( this.parentFragment.cssIds ) {
			attrs += &quot; data-ractive-css=\&quot;&quot; + (this.parentFragment.cssIds.map( function (x) { return (&quot;{&quot; + x + &quot;}&quot;); } ).join( ' ' )) + &quot;\&quot;&quot;;
		}

		var str = &quot;&lt;&quot; + tagName + attrs + &quot;&gt;&quot;;

		if ( this.isVoid ) { return str; }

		// Special case - textarea
		if ( this.name === 'textarea' &amp;&amp; this.getAttribute( 'value' ) !== undefined ) {
			str += escapeHtml( this.getAttribute( 'value' ) );
		}

		// Special case - contenteditable
		else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {
			str += ( this.getAttribute( 'value' ) || <I> );</I>
		}

		if ( this.fragment ) {
			str += this.fragment.toString( !/^(?:script|style)$/i.test( this.template.e ) ); // escape text unless script/style
		}

		str += &quot;&lt;/&quot; + tagName + &quot;&gt;&quot;;
		return str;
	};

	Element.prototype.unbind = function unbind$1 () {
		this.attributes.unbinding = true;
		this.attributes.forEach( unbind );
		this.attributes.unbinding = false;

		if ( this.binding ) { this.binding.unbind(); }
		if ( this.fragment ) { this.fragment.unbind(); }
	};

	Element.prototype.unrender = function unrender$$1 ( shouldDestroy ) {
		if ( !this.rendered ) { return; }
		this.rendered = false;

		// unrendering before intro completed? complete it now
		// TODO should be an API for aborting transitions
		var transition = this.intro;
		if ( transition &amp;&amp; transition.complete ) { transition.complete(); }

		// Detach as soon as we can
		if ( this.name === 'option' ) {
			// &lt;option&gt; elements detach immediately, so that
			// their parent &lt;select&gt; element syncs correctly, and
			// since option elements can't have transitions anyway
			this.detach();
		} else if ( shouldDestroy ) {
			runloop.detachWhenReady( this );
		}

		// outro transition
		var outro = this.outro;
		if ( outro &amp;&amp; outro.shouldFire( 'outro' ) ) {
			outro.isIntro = false;
			outro.isOutro = true;
			runloop.registerTransition( outro );
		}

		if ( this.fragment ) { this.fragment.unrender(); }

		if ( this.binding ) { this.binding.unrender(); }
	};

	Element.prototype.update = function update$1 () {
		if ( this.dirty ) {
			this.dirty = false;

			this.attributes.forEach( update );

			if ( this.fragment ) { this.fragment.update(); }
		}
	};

	return Element;
}(ContainerItem));

var toFront = [ 'min', 'max', 'class', 'type' ];
function sortAttributes ( left, right ) {
	left = left.name;
	right = right.name;
	var l = left === 'value' ? 1 : ~toFront.indexOf( left );
	var r = right === 'value' ? 1 : ~toFront.indexOf( right );
	return l &lt; r ? -1 : l &gt; r ? 1 : 0;
}

function inputIsCheckedRadio ( element ) {
	var nameAttr = element.attributeByName.name;
	return element.getAttribute( 'type' ) === 'radio' &amp;&amp;
		( nameAttr || {} ).interpolator &amp;&amp;
		element.getAttribute( 'value' ) === nameAttr.interpolator.model.get();
}

function stringifyAttribute ( attribute ) {
	var str = attribute.toString();
	return str ? ' ' + str : <I>;</I>
}

function getNamespace ( element ) {
	// Use specified namespace...
	var xmlns$$1 = element.getAttribute( 'xmlns' );
	if ( xmlns$$1 ) { return xmlns$$1; }

	// ...or SVG namespace, if this is an &lt;svg&gt; element
	if ( element.name === 'svg' ) { return svg$1; }

	var parent = element.parent;

	if ( parent ) {
		// ...or HTML, if the parent is a &lt;foreignObject&gt;
		if ( parent.name === 'foreignobject' ) { return html; }

		// ...or inherit from the parent node
		return parent.node.namespaceURI;
	}

	return element.ractive.el.namespaceURI;
}

var Form = (function (Element$$1) {
	function Form ( options ) {
		Element$$1.call( this, options );
		this.formBindings = [];
	}

	if ( Element$$1 ) Form.__proto__ = Element$$1;
	Form.prototype = Object.create( Element$$1 &amp;&amp; Element$$1.prototype );
	Form.prototype.constructor = Form;

	Form.prototype.render = function render ( target, occupants ) {
		Element$$1.prototype.render.call( this, target, occupants );
		this.node.addEventListener( 'reset', handleReset, false );
	};

	Form.prototype.unrender = function unrender ( shouldDestroy ) {
		this.node.removeEventListener( 'reset', handleReset, false );
		Element$$1.prototype.unrender.call( this, shouldDestroy );
	};

	return Form;
}(Element));

function handleReset () {
	var element = this._ractive.proxy;

	runloop.start();
	element.formBindings.forEach( updateModel );
	runloop.end();
}

function updateModel ( binding ) {
	binding.model.set( binding.resetValue );
}

function progressiveText ( item, target, occupants, text ) {
	if ( occupants ) {
		var n = occupants[0];
		if ( n &amp;&amp; n.nodeType === 3 ) {
			var idx = n.nodeValue.indexOf( text );
			occupants.shift();

			if ( idx === 0 ) {
				if ( n.nodeValue.length !== text.length ) {
					occupants.unshift( n.splitText( text.length ) );
				}
			} else {
				n.nodeValue = text;
			}
		} else {
			n = item.node = doc.createTextNode( text );
			if ( occupants[0] ) {
				target.insertBefore( n, occupants[0] );
			} else {
				target.appendChild( n );
			}
		}

		item.node = n;
	} else {
		if ( !item.node ) { item.node = doc.createTextNode( text ); }
		target.appendChild( item.node );
	}
}

var Mustache = (function (Item$$1) {
	function Mustache ( options ) {
		Item$$1.call( this, options );

		this.parentFragment = options.parentFragment;
		this.template = options.template;
		this.index = options.index;
		if ( options.owner ) { this.parent = options.owner; }

		this.isStatic = !!options.template.s;

		this.model = null;
		this.dirty = false;
	}

	if ( Item$$1 ) Mustache.__proto__ = Item$$1;
	Mustache.prototype = Object.create( Item$$1 &amp;&amp; Item$$1.prototype );
	Mustache.prototype.constructor = Mustache;

	Mustache.prototype.bind = function bind () {
		// yield mustaches should resolve in container context
		var start = this.containerFragment || this.parentFragment;
		// try to find a model for this view
		var model = resolve( start, this.template );

		if ( model ) {
			var value = model.get();

			if ( this.isStatic ) {
				this.model = { get: function () { return value; } };
				return;
			}

			model.register( this );
			this.model = model;
		}
	};

	Mustache.prototype.handleChange = function handleChange () {
		this.bubble();
	};

	Mustache.prototype.rebind = function rebind ( next, previous, safe ) {
		next = rebindMatch( this.template, next, previous, this.parentFragment );
		if ( next === this.model ) { return false; }

		if ( this.model ) {
			this.model.unregister( this );
		}
		if ( next ) { next.addShuffleRegister( this, 'mark' ); }
		this.model = next;
		if ( !safe ) { this.handleChange(); }
		return true;
	};

	Mustache.prototype.unbind = function unbind () {
		if ( !this.isStatic ) {
			this.model &amp;&amp; this.model.unregister( this );
			this.model = undefined;
		}
	};

	return Mustache;
}(Item));

var MustacheContainer = (function (ContainerItem$$1) {
	function MustacheContainer ( options ) {
		ContainerItem$$1.call( this, options );
	}

	if ( ContainerItem$$1 ) MustacheContainer.__proto__ = ContainerItem$$1;
	MustacheContainer.prototype = Object.create( ContainerItem$$1 &amp;&amp; ContainerItem$$1.prototype );
	MustacheContainer.prototype.constructor = MustacheContainer;

	return MustacheContainer;
}(ContainerItem));
var proto$2 = MustacheContainer.prototype;
var mustache = Mustache.prototype;
proto$2.bind = mustache.bind;
proto$2.handleChange = mustache.handleChange;
proto$2.rebind = mustache.rebind;
proto$2.unbind = mustache.unbind;

var Interpolator = (function (Mustache$$1) {
	function Interpolator () {
		Mustache$$1.apply(this, arguments);
	}

	if ( Mustache$$1 ) Interpolator.__proto__ = Mustache$$1;
	Interpolator.prototype = Object.create( Mustache$$1 &amp;&amp; Mustache$$1.prototype );
	Interpolator.prototype.constructor = Interpolator;

	Interpolator.prototype.bubble = function bubble () {
		if ( this.owner ) { this.owner.bubble(); }
		Mustache$$1.prototype.bubble.call(this);
	};

	Interpolator.prototype.detach = function detach () {
		return detachNode( this.node );
	};

	Interpolator.prototype.firstNode = function firstNode () {
		return this.node;
	};

	Interpolator.prototype.getString = function getString () {
		return this.model ? safeToStringValue( this.model.get() ) : <I>;</I>
	};

	Interpolator.prototype.render = function render ( target, occupants ) {
		if ( inAttributes() ) { return; }
		var value = this.getString();

		this.rendered = true;

		progressiveText( this, target, occupants, value );
	};

	Interpolator.prototype.toString = function toString ( escape ) {
		var string = this.getString();
		return escape ? escapeHtml( string ) : string;
	};

	Interpolator.prototype.unrender = function unrender ( shouldDestroy ) {
		if ( shouldDestroy ) { this.detach(); }
		this.rendered = false;
	};

	Interpolator.prototype.update = function update () {
		if ( this.dirty ) {
			this.dirty = false;
			if ( this.rendered ) {
				this.node.data = this.getString();
			}
		}
	};

	Interpolator.prototype.valueOf = function valueOf () {
		return this.model ? this.model.get() : undefined;
	};

	return Interpolator;
}(Mustache));

var Input = (function (Element$$1) {
	function Input () {
		Element$$1.apply(this, arguments);
	}

	if ( Element$$1 ) Input.__proto__ = Element$$1;
	Input.prototype = Object.create( Element$$1 &amp;&amp; Element$$1.prototype );
	Input.prototype.constructor = Input;

	Input.prototype.render = function render ( target, occupants ) {
		Element$$1.prototype.render.call( this, target, occupants );
		this.node.defaultValue = this.node.value;
	};
	Input.prototype.compare = function compare ( value, attrValue ) {
		var comparator = this.getAttribute( 'value-comparator' );
		if ( comparator ) {
			if ( typeof comparator === 'function' ) {
				return comparator( value, attrValue );
			}
			if (value &amp;&amp; attrValue) {
				return value[comparator] == attrValue[comparator];
			}
		}
		return value == attrValue;
	};

	return Input;
}(Element));

// simple JSON parser, without the restrictions of JSON parse
// (i.e. having to double-quote keys).
//
// If passed a hash of values as the second argument, ${placeholders}
// will be replaced with those values

var specials$1 = {
	true: true,
	false: false,
	null: null,
	undefined: undefined
};

var specialsPattern = new RegExp( '^(?:' + Object.keys( specials$1 ).join( '|' ) + ')' );
var numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
var placeholderPattern = /\$\{([^\}]+)\}/g;
var placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
var onlyWhitespace = /^\s*$/;

var JsonParser = Parser.extend({
	init: function init ( str, options ) {
		this.values = options.values;
		this.allowWhitespace();
	},

	postProcess: function postProcess ( result ) {
		if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
			return null;
		}

		return { value: result[0].v };
	},

	converters: [
		function getPlaceholder ( parser ) {
			if ( !parser.values ) { return null; }

			var placeholder = parser.matchPattern( placeholderAtStartPattern );

			if ( placeholder &amp;&amp; ( parser.values.hasOwnProperty( placeholder ) ) ) {
				return { v: parser.values[ placeholder ] };
			}
		},

		function getSpecial ( parser ) {
			var special = parser.matchPattern( specialsPattern );
			if ( special ) { return { v: specials$1[ special ] }; }
		},

		function getNumber ( parser ) {
			var number = parser.matchPattern( numberPattern$1 );
			if ( number ) { return { v: +number }; }
		},

		function getString ( parser ) {
			var stringLiteral = readStringLiteral( parser );
			var values = parser.values;

			if ( stringLiteral &amp;&amp; values ) {
				return {
					v: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) { return ( $1 in values ? values[ $1 ] : $1 ); } )
				};
			}

			return stringLiteral;
		},

		function getObject ( parser ) {
			if ( !parser.matchString( '{' ) ) { return null; }

			var result = {};

			parser.allowWhitespace();

			if ( parser.matchString( '}' ) ) {
				return { v: result };
			}

			var pair;
			while ( pair = getKeyValuePair( parser ) ) {
				result[ pair.key ] = pair.value;

				parser.allowWhitespace();

				if ( parser.matchString( '}' ) ) {
					return { v: result };
				}

				if ( !parser.matchString( ',' ) ) {
					return null;
				}
			}

			return null;
		},

		function getArray ( parser ) {
			if ( !parser.matchString( '[' ) ) { return null; }

			var result = [];

			parser.allowWhitespace();

			if ( parser.matchString( ']' ) ) {
				return { v: result };
			}

			var valueToken;
			while ( valueToken = parser.read() ) {
				result.push( valueToken.v );

				parser.allowWhitespace();

				if ( parser.matchString( ']' ) ) {
					return { v: result };
				}

				if ( !parser.matchString( ',' ) ) {
					return null;
				}

				parser.allowWhitespace();
			}

			return null;
		}
	]
});

function getKeyValuePair ( parser ) {
	parser.allowWhitespace();

	var key = readKey( parser );

	if ( !key ) { return null; }

	var pair = { key: key };

	parser.allowWhitespace();
	if ( !parser.matchString( ':' ) ) {
		return null;
	}
	parser.allowWhitespace();

	var valueToken = parser.read();

	if ( !valueToken ) { return null; }

	pair.value = valueToken.v;
	return pair;
}

var parseJSON = function ( str, values ) {
	var parser = new JsonParser( str, { values: values });
	return parser.result;
};

var Mapping = (function (Item$$1) {
	function Mapping ( options ) {
		Item$$1.call( this, options );

		this.name = options.template.n;

		this.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );
		this.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );
		this.parentFragment = this.element.parentFragment; // shared
		this.ractive = this.parentFragment.ractive;

		this.fragment = null;

		this.element.attributeByName[ this.name ] = this;

		this.value = options.template.f;
	}

	if ( Item$$1 ) Mapping.__proto__ = Item$$1;
	Mapping.prototype = Object.create( Item$$1 &amp;&amp; Item$$1.prototype );
	Mapping.prototype.constructor = Mapping;

	Mapping.prototype.bind = function bind () {
		if ( this.fragment ) {
			this.fragment.bind();
		}

		var template = this.template.f;
		var viewmodel = this.element.instance.viewmodel;

		if ( template === 0 ) {
			// empty attributes are `true`
			viewmodel.joinKey( this.name ).set( true );
		}

		else if ( typeof template === 'string' ) {
			var parsed = parseJSON( template );
			viewmodel.joinKey( this.name ).set( parsed ? parsed.value : template );
		}

		else if ( Array.isArray( template ) ) {
			createMapping( this, true );
		}
	};

	Mapping.prototype.render = function render () {};

	Mapping.prototype.unbind = function unbind () {
		if ( this.fragment ) { this.fragment.unbind(); }
		if ( this.model ) { this.model.unregister( this ); }
		if ( this.boundFragment ) { this.boundFragment.unbind(); }

		if ( this.element.bound ) {
			if ( this.link.target === this.model ) { this.link.owner.unlink(); }
		}
	};

	Mapping.prototype.unrender = function unrender () {};

	Mapping.prototype.update = function update () {
		if ( this.dirty ) {
			this.dirty = false;
			if ( this.fragment ) { this.fragment.update(); }
			if ( this.boundFragment ) { this.boundFragment.update(); }
			if ( this.rendered ) { this.updateDelegate(); }
		}
	};

	return Mapping;
}(Item));

function createMapping ( item ) {
	var template = item.template.f;
	var viewmodel = item.element.instance.viewmodel;
	var childData = viewmodel.value;

	if ( template.length === 1 &amp;&amp; template[0].t === INTERPOLATOR ) {
		var model = resolve( item.parentFragment, template[0] );
		var val = model.get( false );

		// if the interpolator is not static
		if ( !template[0].s ) {
			item.model = model;
			item.link = viewmodel.createLink( item.name, model, template[0].r );

			// initialize parent side of the mapping from child data
			if ( val === undefined &amp;&amp; !model.isReadonly &amp;&amp; item.name in childData ) {
				model.set( childData[ item.name ] );
			}
		}

		// copy non-object, non-computed vals through
		else if ( typeof val !== 'object' || template[0].x ) {
			viewmodel.joinKey( item.name ).set( val );
		}

		// warn about trying to copy an object
		else {
			warnIfDebug( (&quot;Cannot copy non-computed object value from static mapping '&quot; + (item.name) + &quot;'&quot;) );
		}
	}

	else {
		item.boundFragment = new Fragment({
			owner: item,
			template: template
		}).bind();

		item.model = viewmodel.joinKey( item.name );
		item.model.set( item.boundFragment.valueOf() );

		// item is a *bit* of a hack
		item.boundFragment.bubble = function () {
			Fragment.prototype.bubble.call( item.boundFragment );
			// defer this to avoid mucking around model deps if there happens to be an expression involved
			runloop.scheduleTask(function () {
				item.boundFragment.update();
				item.model.set( item.boundFragment.valueOf() );
			});
		};
	}
}

var Option = (function (Element$$1) {
	function Option ( options ) {
		var template = options.template;
		if ( !template.a ) { template.a = {}; }

		// If the value attribute is missing, use the element's content,
		// as long as it isn't disabled
		if ( template.a.value === undefined &amp;&amp; !( 'disabled' in template.a ) ) {
			template.a.value = template.f || <I>;</I>
		}

		Element$$1.call( this, options );

		this.select = findElement( this.parent || this.parentFragment, false, 'select' );
	}

	if ( Element$$1 ) Option.__proto__ = Element$$1;
	Option.prototype = Object.create( Element$$1 &amp;&amp; Element$$1.prototype );
	Option.prototype.constructor = Option;

	Option.prototype.bind = function bind () {
		if ( !this.select ) {
			Element$$1.prototype.bind.call(this);
			return;
		}

		// If the select has a value, it overrides the `selected` attribute on
		// this option - so we delete the attribute
		var selectedAttribute = this.attributeByName.selected;
		if ( selectedAttribute &amp;&amp; this.select.getAttribute( 'value' ) !== undefined ) {
			var index = this.attributes.indexOf( selectedAttribute );
			this.attributes.splice( index, 1 );
			delete this.attributeByName.selected;
		}

		Element$$1.prototype.bind.call(this);
		this.select.options.push( this );
	};

	Option.prototype.bubble = function bubble () {
		// if we're using content as value, may need to update here
		var value = this.getAttribute( 'value' );
		if ( this.node &amp;&amp; this.node.value !== value ) {
			this.node._ractive.value = value;
		}
		Element$$1.prototype.bubble.call(this);
	};

	Option.prototype.getAttribute = function getAttribute ( name ) {
		var attribute = this.attributeByName[ name ];
		return attribute ? attribute.getValue() : name === 'value' &amp;&amp; this.fragment ? this.fragment.valueOf() : undefined;
	};

	Option.prototype.isSelected = function isSelected () {
		var this$1 = this;

		var optionValue = this.getAttribute( 'value' );

		if ( optionValue === undefined || !this.select ) {
			return false;
		}

		var selectValue = this.select.getAttribute( 'value' );

		if ( this.select.compare( selectValue, optionValue ) ) {
			return true;
		}

		if ( this.select.getAttribute( 'multiple' ) &amp;&amp; Array.isArray( selectValue ) ) {
			var i = selectValue.length;
			while ( i-- ) {
				if ( this$1.select.compare( selectValue[i], optionValue ) ) {
					return true;
				}
			}
		}
	};

	Option.prototype.render = function render ( target, occupants ) {
		Element$$1.prototype.render.call( this, target, occupants );

		if ( !this.attributeByName.value ) {
			this.node._ractive.value = this.getAttribute( 'value' );
		}
	};

	Option.prototype.unbind = function unbind () {
		Element$$1.prototype.unbind.call(this);

		if ( this.select ) {
			removeFromArray( this.select.options, this );
		}
	};

	return Option;
}(Element));

function getPartialTemplate ( ractive, name, parentFragment ) {
	// If the partial in instance or view heirarchy instances, great
	var partial = getPartialFromRegistry( ractive, name, parentFragment || {} );
	if ( partial ) { return partial; }

	// Does it exist on the page as a script tag?
	partial = parser.fromId( name, { noThrow: true } );
	if ( partial ) {
		// parse and register to this ractive instance
		var parsed = parser.parseFor( partial, ractive );

		// register extra partials on the ractive instance if they don't already exist
		if ( parsed.p ) { fillGaps( ractive.partials, parsed.p ); }

		// register (and return main partial if there are others in the template)
		return ractive.partials[ name ] = parsed.t;
	}
}

function getPartialFromRegistry ( ractive, name, parentFragment ) {
	// if there was an instance up-hierarchy, cool
	var partial = findParentPartial( name, parentFragment.owner );
	if ( partial ) { return partial; }

	// find first instance in the ractive or view hierarchy that has this partial
	var instance = findInstance( 'partials', ractive, name );

	if ( !instance ) { return; }

	partial = instance.partials[ name ];

	// partial is a function?
	var fn;
	if ( typeof partial === 'function' ) {
		fn = partial.bind( instance );
		fn.isOwner = instance.partials.hasOwnProperty(name);
		partial = fn.call( ractive, parser );
	}

	if ( !partial &amp;&amp; partial !== <I> ) {</I>
		warnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive: ractive });
		return;
	}

	// If this was added manually to the registry,
	// but hasn't been parsed, parse it now
	if ( !parser.isParsed( partial ) ) {
		// use the parseOptions of the ractive instance on which it was found
		var parsed = parser.parseFor( partial, instance );

		// Partials cannot contain nested partials!
		// TODO add a test for this
		if ( parsed.p ) {
			warnIfDebug( 'Partials ({{&gt;%s}}) cannot contain nested inline partials', name, { ractive: ractive });
		}

		// if fn, use instance to store result, otherwise needs to go
		// in the correct point in prototype chain on instance or constructor
		var target = fn ? instance : findOwner( instance, name );

		// may be a template with partials, which need to be registered and main template extracted
		target.partials[ name ] = partial = parsed.t;
	}

	// store for reset
	if ( fn ) { partial._fn = fn; }

	return partial.v ? partial.t : partial;
}

function findOwner ( ractive, key ) {
	return ractive.partials.hasOwnProperty( key )
		? ractive
		: findConstructor( ractive.constructor, key);
}

function findConstructor ( constructor, key ) {
	if ( !constructor ) { return; }
	return constructor.partials.hasOwnProperty( key )
		? constructor
		: findConstructor( constructor._Parent, key );
}

function findParentPartial( name, parent ) {
	if ( parent ) {
		if ( parent.template &amp;&amp; parent.template.p &amp;&amp; parent.template.p[name] ) {
			return parent.template.p[name];
		} else if ( parent.parentFragment &amp;&amp; parent.parentFragment.owner ) {
			return findParentPartial( name, parent.parentFragment.owner );
		}
	}
}

var Partial = (function (MustacheContainer$$1) {
	function Partial ( options ) {
		MustacheContainer$$1.call( this, options );

		this.yielder = options.template.t === YIELDER;

		if ( this.yielder ) {
			this.container = options.parentFragment.ractive;
			this.component = this.container.component;

			this.containerFragment = options.parentFragment;
			this.parentFragment = this.component.parentFragment;

			// <A href="/wiki/index.php?title=Template:Yield&amp;action=edit&amp;redlink=1" class="new" title="Template:Yield (page does not exist)">Template:Yield</A> is equivalent to <A href="/wiki/index.php?title=Template:Yield_content&amp;action=edit&amp;redlink=1" class="new" title="Template:Yield content (page does not exist)">Template:Yield content</A>
			if ( !options.template.r &amp;&amp; !options.template.rx &amp;&amp; !options.template.x ) { options.template.r = 'content'; }
		}
	}

	if ( MustacheContainer$$1 ) Partial.__proto__ = MustacheContainer$$1;
	Partial.prototype = Object.create( MustacheContainer$$1 &amp;&amp; MustacheContainer$$1.prototype );
	Partial.prototype.constructor = Partial;

	Partial.prototype.bind = function bind () {
		var this$1 = this;

		// keep track of the reference name for future resets
		this.refName = this.template.r;

		// name matches take priority over expressions
		var template = this.refName ? getPartialTemplate( this.ractive, this.refName, this.parentFragment ) || null : null;
		var templateObj;

		if ( template ) {
			this.named = true;
			this.setTemplate( this.template.r, template );
		}

		if ( !template ) {
			MustacheContainer$$1.prototype.bind.call(this);
			if ( ( templateObj = this.model.get() ) &amp;&amp; typeof templateObj === 'object' &amp;&amp; ( typeof templateObj.template === 'string' || Array.isArray( templateObj.t ) ) ) {
				if ( templateObj.template ) {
					this.source = templateObj.template;
					templateObj = parsePartial( this.template.r, templateObj.template, this.ractive );
				} else {
					this.source = templateObj.t;
				}
				this.setTemplate( this.template.r, templateObj.t );
			} else if ( typeof this.model.get() !== 'string' &amp;&amp; this.refName ) {
				this.setTemplate( this.refName, template );
			} else {
				this.setTemplate( this.model.get() );
			}
		}

		var options = {
			owner: this,
			template: this.partialTemplate
		};

		if ( this.template.c ) {
			options.template = [{ t: SECTION, n: SECTION_WITH, f: options.template }];
			for ( var k in this$1.template.c ) {
				options.template[0][k] = this$1.template.c[k];
			}
		}

		if ( this.yielder ) {
			options.ractive = this.container.parent;
		}

		this.fragment = new Fragment(options);
		if ( this.template.z ) {
			this.fragment.aliases = resolveAliases( this.template.z, this.yielder ? this.containerFragment : this.parentFragment );
		}
		this.fragment.bind();
	};

	Partial.prototype.bubble = function bubble () {
		if ( this.yielder &amp;&amp; !this.dirty ) {
			this.containerFragment.bubble();
			this.dirty = true;
		} else {
			MustacheContainer$$1.prototype.bubble.call(this);
		}
	};

	Partial.prototype.findNextNode = function findNextNode () {
		return this.yielder ? this.containerFragment.findNextNode( this ) : MustacheContainer$$1.prototype.findNextNode.call(this);
	};

	Partial.prototype.forceResetTemplate = function forceResetTemplate () {
		var this$1 = this;

		this.partialTemplate = undefined;

		// on reset, check for the reference name first
		if ( this.refName ) {
			this.partialTemplate = getPartialTemplate( this.ractive, this.refName, this.parentFragment );
		}

		// then look for the resolved name
		if ( !this.partialTemplate ) {
			this.partialTemplate = getPartialTemplate( this.ractive, this.name, this.parentFragment );
		}

		if ( !this.partialTemplate ) {
			warnOnceIfDebug( (&quot;Could not find template for partial '&quot; + (this.name) + &quot;'&quot;) );
			this.partialTemplate = [];
		}

		if ( this.inAttribute ) {
			doInAttributes( function () { return this$1.fragment.resetTemplate( this$1.partialTemplate ); } );
		} else {
			this.fragment.resetTemplate( this.partialTemplate );
		}

		this.bubble();
	};

	Partial.prototype.render = function render ( target, occupants ) {
		return this.fragment.render( target, occupants );
	};

	Partial.prototype.setTemplate = function setTemplate ( name, template ) {
		this.name = name;

		if ( !template &amp;&amp; template !== null ) { template = getPartialTemplate( this.ractive, name, this.parentFragment ); }

		if ( !template ) {
			warnOnceIfDebug( (&quot;Could not find template for partial '&quot; + name + &quot;'&quot;) );
		}

		this.partialTemplate = template || [];
	};

	Partial.prototype.unbind = function unbind () {
		MustacheContainer$$1.prototype.unbind.call(this);
		this.fragment.aliases = {};
		this.fragment.unbind();
	};

	Partial.prototype.unrender = function unrender ( shouldDestroy ) {
		this.fragment.unrender( shouldDestroy );
	};

	Partial.prototype.update = function update () {
		var template;

		if ( this.dirty ) {
			this.dirty = false;

			if ( !this.named ) {
				if ( this.model ) {
					template = this.model.get();
				}

				if ( template &amp;&amp; typeof template === 'string' &amp;&amp; template !== this.name ) {
					this.setTemplate( template );
					this.fragment.resetTemplate( this.partialTemplate );
				} else if ( template &amp;&amp; typeof template === 'object' &amp;&amp; ( typeof template.template === 'string' || Array.isArray( template.t ) ) ) {
					if ( template.t !== this.source &amp;&amp; template.template !== this.source ) {
						if ( template.template ) {
							this.source = template.template;
							template = parsePartial( this.name, template.template, this.ractive );
						} else {
							this.source = template.t;
						}
						this.setTemplate( this.name, template.t );
						this.fragment.resetTemplate( this.partialTemplate );
					}
				}
			}

			this.fragment.update();
		}
	};

	return Partial;
}(MustacheContainer));

function parsePartial( name, partial, ractive ) {
	var parsed;

	try {
		parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
	} catch (e) {
		warnIfDebug( (&quot;Could not parse partial from expression '&quot; + name + &quot;'\n&quot; + (e.message)) );
	}

	return parsed || { t: [] };
}

var RepeatedFragment = function RepeatedFragment ( options ) {
	this.parent = options.owner.parentFragment;

	// bit of a hack, so reference resolution works without another
	// layer of indirection
	this.parentFragment = this;
	this.owner = options.owner;
	this.ractive = this.parent.ractive;
	this.delegate = this.parent.delegate || findElement( options.owner );
	// delegation disabled by directive
	if ( this.delegate &amp;&amp; this.delegate.delegate === false ) { this.delegate = false; }

	// encapsulated styles should be inherited until they get applied by an element
	this.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );

	this.context = null;
	this.rendered = false;
	this.iterations = [];

	this.template = options.template;

	this.indexRef = options.indexRef;
	this.keyRef = options.keyRef;

	this.pendingNewIndices = null;
	this.previousIterations = null;

	// track array versus object so updates of type rest
	this.isArray = false;
};

RepeatedFragment.prototype.bind = function bind$$1 ( context ) {
		var this$1 = this;

	this.context = context;
	var value = context.get();

	// {{#each array}}...
	if ( this.isArray = Array.isArray( value ) ) {
		// we can't use map, because of sparse arrays
		this.iterations = [];
		var max = value.length;
		for ( var i = 0; i &lt; max; i += 1 ) {
			this$1.iterations[i] = this$1.createIteration( i, i );
		}
	}

	// {{#each object}}...
	else if ( isObject( value ) ) {
		this.isArray = false;

		// TODO this is a dreadful hack. There must be a neater way
		if ( this.indexRef ) {
			var refs = this.indexRef.split( ',' );
			this.keyRef = refs[0];
			this.indexRef = refs[1];
		}

		this.iterations = Object.keys( value ).map( function ( key, index ) {
			return this$1.createIteration( key, index );
		});
	}

	return this;
};

RepeatedFragment.prototype.bubble = function bubble ( index ) {
	if  ( !this.bubbled ) { this.bubbled = []; }
	this.bubbled.push( index );

	this.owner.bubble();
};

RepeatedFragment.prototype.createIteration = function createIteration ( key, index ) {
	var fragment = new Fragment({
		owner: this,
		template: this.template
	});

	fragment.key = key;
	fragment.index = index;
	fragment.isIteration = true;
	fragment.delegate = this.delegate;

	var model = this.context.joinKey( key );

	// set up an iteration alias if there is one
	if ( this.owner.template.z ) {
		fragment.aliases = {};
		fragment.aliases[ this.owner.template.z[0].n ] = model;
	}

	return fragment.bind( model );
};

RepeatedFragment.prototype.destroyed = function destroyed$1 () {
	this.iterations.forEach( destroyed );
};

RepeatedFragment.prototype.detach = function detach () {
	var docFrag = createDocumentFragment();
	this.iterations.forEach( function (fragment) { return docFrag.appendChild( fragment.detach() ); } );
	return docFrag;
};

RepeatedFragment.prototype.find = function find ( selector, options ) {
	return findMap( this.iterations, function (i) { return i.find( selector, options ); } );
};

RepeatedFragment.prototype.findAll = function findAll ( selector, options ) {
	return this.iterations.forEach( function (i) { return i.findAll( selector, options ); } );
};

RepeatedFragment.prototype.findComponent = function findComponent ( name, options ) {
	return findMap( this.iterations, function (i) { return i.findComponent( name, options ); } );
};

RepeatedFragment.prototype.findAllComponents = function findAllComponents ( name, options ) {
	return this.iterations.forEach( function (i) { return i.findAllComponents( name, options ); } );
};

RepeatedFragment.prototype.findNextNode = function findNextNode ( iteration ) {
		var this$1 = this;

	if ( iteration.index &lt; this.iterations.length - 1 ) {
		for ( var i = iteration.index + 1; i &lt; this.iterations.length; i++ ) {
			var node = this$1.iterations[ i ].firstNode( true );
			if ( node ) { return node; }
		}
	}

	return this.owner.findNextNode();
};

RepeatedFragment.prototype.firstNode = function firstNode ( skipParent ) {
	return this.iterations[0] ? this.iterations[0].firstNode( skipParent ) : null;
};

RepeatedFragment.prototype.rebind = function rebind ( next ) {
		var this$1 = this;

	this.context = next;
	this.iterations.forEach( function (fragment) {
		var model = next ? next.joinKey( fragment.key ) : undefined;
		fragment.context = model;
		if ( this$1.owner.template.z ) {
			fragment.aliases = {};
			fragment.aliases[ this$1.owner.template.z[0].n ] = model;
		}
	});
};

RepeatedFragment.prototype.render = function render$$1 ( target, occupants ) {
	// TODO use docFrag.cloneNode...

	var xs = this.iterations;
	if ( xs ) {
		var len = xs.length;
		for ( var i = 0; i &lt; len; i++ ) {
			xs[i].render( target, occupants );
		}
	}

	this.rendered = true;
};

RepeatedFragment.prototype.shuffle = function shuffle ( newIndices ) {
		var this$1 = this;

	if ( !this.pendingNewIndices ) { this.previousIterations = this.iterations.slice(); }

	if ( !this.pendingNewIndices ) { this.pendingNewIndices = []; }

	this.pendingNewIndices.push( newIndices );

	var iterations = [];

	newIndices.forEach( function ( newIndex, oldIndex ) {
		if ( newIndex === -1 ) { return; }

		var fragment = this$1.iterations[ oldIndex ];
		iterations[ newIndex ] = fragment;

		if ( newIndex !== oldIndex &amp;&amp; fragment ) { fragment.dirty = true; }
	});

	this.iterations = iterations;

	this.bubble();
};

RepeatedFragment.prototype.shuffled = function shuffled$1 () {
	this.iterations.forEach( shuffled );
};

RepeatedFragment.prototype.toString = function toString$1$$1 ( escape ) {
	return this.iterations ?
		this.iterations.map( escape ? toEscapedString : toString$1 ).join( <I> ) :</I><I>;</I>
};

RepeatedFragment.prototype.unbind = function unbind$1 () {
	this.iterations.forEach( unbind );
	return this;
};

RepeatedFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {
	this.iterations.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
	if ( this.pendingNewIndices &amp;&amp; this.previousIterations ) {
		this.previousIterations.forEach( function (fragment) {
			if ( fragment.rendered ) { shouldDestroy ? unrenderAndDestroy( fragment ) : unrender( fragment ); }
		});
	}
	this.rendered = false;
};

// TODO smart update
RepeatedFragment.prototype.update = function update$1 () {
		var this$1 = this;

	// skip dirty check, since this is basically just a facade

	if ( this.pendingNewIndices ) {
		this.bubbled.length = 0;
		this.updatePostShuffle();
		return;
	}

	if ( this.updating ) { return; }
	this.updating = true;

	var value = this.context.get();
	var wasArray = this.isArray;

	var toRemove;
	var oldKeys;
	var reset = true;
	var i;

	if ( this.isArray = Array.isArray( value ) ) {
		if ( wasArray ) {
			reset = false;
			if ( this.iterations.length &gt; value.length ) {
				toRemove = this.iterations.splice( value.length );
			}
		}
	} else if ( isObject( value ) &amp;&amp; !wasArray ) {
		reset = false;
		toRemove = [];
		oldKeys = {};
		i = this.iterations.length;

		while ( i-- ) {
			var fragment$1 = this$1.iterations[i];
			if ( fragment$1.key in value ) {
				oldKeys[ fragment$1.key ] = true;
			} else {
				this$1.iterations.splice( i, 1 );
				toRemove.push( fragment$1 );
			}
		}
	}

	if ( reset ) {
		toRemove = this.iterations;
		this.iterations = [];
	}

	if ( toRemove ) {
		toRemove.forEach( function (fragment) {
			fragment.unbind();
			fragment.unrender( true );
		});
	}

	// update the remaining ones
	if ( !reset &amp;&amp; this.isArray &amp;&amp; this.bubbled &amp;&amp; this.bubbled.length ) {
		this.bubbled.forEach( function (i) { return this$1.iterations[i] &amp;&amp; this$1.iterations[i].update(); } );
	} else {
		this.iterations.forEach( update );
	}

	if ( this.bubbled ) { this.bubbled.length = 0; }

	// add new iterations
	var newLength = Array.isArray( value ) ?
		value.length :
		isObject( value ) ?
			Object.keys( value ).length :
			0;

	var docFrag;
	var fragment;

	if ( newLength &gt; this.iterations.length ) {
		docFrag = this.rendered ? createDocumentFragment() : null;
		i = this.iterations.length;

		if ( Array.isArray( value ) ) {
			while ( i &lt; value.length ) {
				fragment = this$1.createIteration( i, i );

				this$1.iterations.push( fragment );
				if ( this$1.rendered ) { fragment.render( docFrag ); }

				i += 1;
			}
		}

		else if ( isObject( value ) ) {
			// TODO this is a dreadful hack. There must be a neater way
			if ( this.indexRef &amp;&amp; !this.keyRef ) {
				var refs = this.indexRef.split( ',' );
				this.keyRef = refs[0];
				this.indexRef = refs[1];
			}

			Object.keys( value ).forEach( function (key) {
				if ( !oldKeys || !( key in oldKeys ) ) {
					fragment = this$1.createIteration( key, i );

					this$1.iterations.push( fragment );
					if ( this$1.rendered ) { fragment.render( docFrag ); }

					i += 1;
				}
			});
		}

		if ( this.rendered ) {
			var parentNode = this.parent.findParentNode();
			var anchor = this.parent.findNextNode( this.owner );

			parentNode.insertBefore( docFrag, anchor );
		}
	}

	this.updating = false;
};

RepeatedFragment.prototype.updatePostShuffle = function updatePostShuffle () {
		var this$1 = this;

	var newIndices = this.pendingNewIndices[ 0 ];

	// map first shuffle through
	this.pendingNewIndices.slice( 1 ).forEach( function (indices) {
		newIndices.forEach( function ( newIndex, oldIndex ) {
			newIndices[ oldIndex ] = indices[ newIndex ];
		});
	});

	// This algorithm (for detaching incorrectly-ordered fragments from the DOM and
	// storing them in a document fragment for later reinsertion) seems a bit hokey,
	// but it seems to work for now
	var len = this.context.get().length;
	var oldLen = this.previousIterations.length;
	var removed = {};
	var i;

	newIndices.forEach( function ( newIndex, oldIndex ) {
		var fragment = this$1.previousIterations[ oldIndex ];
		this$1.previousIterations[ oldIndex ] = null;

		if ( newIndex === -1 ) {
			removed[ oldIndex ] = fragment;
		} else if ( fragment.index !== newIndex ) {
			var model = this$1.context.joinKey( newIndex );
			fragment.index = fragment.key = newIndex;
			fragment.context = model;
			if ( this$1.owner.template.z ) {
				fragment.aliases = {};
				fragment.aliases[ this$1.owner.template.z[0].n ] = model;
			}
		}
	});

	// if the array was spliced outside of ractive, sometimes there are leftover fragments not in the newIndices
	this.previousIterations.forEach( function ( frag, i ) {
		if ( frag ) { removed[ i ] = frag; }
	});

	// create new/move existing iterations
	var docFrag = this.rendered ? createDocumentFragment() : null;
	var parentNode = this.rendered ? this.parent.findParentNode() : null;

	var contiguous = 'startIndex' in newIndices;
	i = contiguous ? newIndices.startIndex : 0;

	for ( i; i &lt; len; i++ ) {
		var frag = this$1.iterations[i];

		if ( frag &amp;&amp; contiguous ) {
			// attach any built-up iterations
			if ( this$1.rendered ) {
				if ( removed[i] ) { docFrag.appendChild( removed[i].detach() ); }
				if ( docFrag.childNodes.length  ) { parentNode.insertBefore( docFrag, frag.firstNode() ); }
			}
			continue;
		}

		if ( !frag ) { this$1.iterations[i] = this$1.createIteration( i, i ); }

		if ( this$1.rendered ) {
			if ( removed[i] ) { docFrag.appendChild( removed[i].detach() ); }

			if ( frag ) { docFrag.appendChild( frag.detach() ); }
			else {
				this$1.iterations[i].render( docFrag );
			}
		}
	}

	// append any leftovers
	if ( this.rendered ) {
		for ( i = len; i &lt; oldLen; i++ ) {
			if ( removed[i] ) { docFrag.appendChild( removed[i].detach() ); }
		}

		if ( docFrag.childNodes.length ) {
			parentNode.insertBefore( docFrag, this.owner.findNextNode() );
		}
	}

	// trigger removal on old nodes
	Object.keys( removed ).forEach( function (k) { return removed[k].unbind().unrender( true ); } );

	this.iterations.forEach( update );

	this.pendingNewIndices = null;

	this.shuffled();
};

function isEmpty ( value ) {
	return !value ||
	       ( Array.isArray( value ) &amp;&amp; value.length === 0 ) ||
		   ( isObject( value ) &amp;&amp; Object.keys( value ).length === 0 );
}

function getType ( value, hasIndexRef ) {
	if ( hasIndexRef || Array.isArray( value ) ) { return SECTION_EACH; }
	if ( isObject( value ) || typeof value === 'function' ) { return SECTION_IF_WITH; }
	if ( value === undefined ) { return null; }
	return SECTION_IF;
}

var Section = (function (MustacheContainer$$1) {
	function Section ( options ) {
		MustacheContainer$$1.call( this, options );

		this.sectionType = options.template.n || null;
		this.templateSectionType = this.sectionType;
		this.subordinate = options.template.l === 1;
		this.fragment = null;
	}

	if ( MustacheContainer$$1 ) Section.__proto__ = MustacheContainer$$1;
	Section.prototype = Object.create( MustacheContainer$$1 &amp;&amp; MustacheContainer$$1.prototype );
	Section.prototype.constructor = Section;

	Section.prototype.bind = function bind () {
		MustacheContainer$$1.prototype.bind.call(this);

		if ( this.subordinate ) {
			this.sibling = this.parentFragment.items[ this.parentFragment.items.indexOf( this ) - 1 ];
			this.sibling.nextSibling = this;
		}

		// if we managed to bind, we need to create children
		if ( this.model ) {
			this.dirty = true;
			this.update();
		} else if ( this.sectionType &amp;&amp; this.sectionType === SECTION_UNLESS &amp;&amp; ( !this.sibling || !this.sibling.isTruthy() ) ) {
			this.fragment = new Fragment({
				owner: this,
				template: this.template.f
			}).bind();
		}
	};

	Section.prototype.detach = function detach () {
		var frag = this.fragment || this.detached;
		return frag ? frag.detach() : MustacheContainer$$1.prototype.detach.call(this);
	};

	Section.prototype.isTruthy = function isTruthy () {
		if ( this.subordinate &amp;&amp; this.sibling.isTruthy() ) { return true; }
		var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();
		return !!value &amp;&amp; ( this.templateSectionType === SECTION_IF_WITH || !isEmpty( value ) );
	};

	Section.prototype.rebind = function rebind ( next, previous, safe ) {
		if ( MustacheContainer$$1.prototype.rebind.call( this, next, previous, safe ) ) {
			if ( this.fragment &amp;&amp; this.sectionType !== SECTION_IF &amp;&amp; this.sectionType !== SECTION_UNLESS ) {
				this.fragment.rebind( next );
			}
		}
	};

	Section.prototype.render = function render ( target, occupants ) {
		this.rendered = true;
		if ( this.fragment ) { this.fragment.render( target, occupants ); }
	};

	Section.prototype.shuffle = function shuffle ( newIndices ) {
		if ( this.fragment &amp;&amp; this.sectionType === SECTION_EACH ) {
			this.fragment.shuffle( newIndices );
		}
	};

	Section.prototype.unbind = function unbind () {
		MustacheContainer$$1.prototype.unbind.call(this);
		if ( this.fragment ) { this.fragment.unbind(); }
	};

	Section.prototype.unrender = function unrender ( shouldDestroy ) {
		if ( this.rendered &amp;&amp; this.fragment ) { this.fragment.unrender( shouldDestroy ); }
		this.rendered = false;
	};

	Section.prototype.update = function update () {
		var this$1 = this;

		if ( !this.dirty ) { return; }

		if ( this.fragment &amp;&amp; this.sectionType !== SECTION_IF &amp;&amp; this.sectionType !== SECTION_UNLESS ) {
			this.fragment.context = this.model;
		}

		if ( !this.model &amp;&amp; this.sectionType !== SECTION_UNLESS ) { return; }

		this.dirty = false;

		var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();
		var siblingFalsey = !this.subordinate || !this.sibling.isTruthy();
		var lastType = this.sectionType;

		// watch for switching section types
		if ( this.sectionType === null || this.templateSectionType === null ) { this.sectionType = getType( value, this.template.i ); }
		if ( lastType &amp;&amp; lastType !== this.sectionType &amp;&amp; this.fragment ) {
			if ( this.rendered ) {
				this.fragment.unbind().unrender( true );
			}

			this.fragment = null;
		}

		var newFragment;

		var fragmentShouldExist = this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations
		                            this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment
		                            ( siblingFalsey &amp;&amp; ( this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy() ) ); // if, unless, and if-with depend on siblings and the condition

		if ( fragmentShouldExist ) {
			if ( !this.fragment ) { this.fragment = this.detached; }

			if ( this.fragment ) {
				// check for detached fragment
				if ( this.detached ) {
					attach( this, this.fragment );
					this.detached = false;
					this.rendered = true;
				}

				this.fragment.update();
			} else {
				if ( this.sectionType === SECTION_EACH ) {
					newFragment = new RepeatedFragment({
						owner: this,
						template: this.template.f,
						indexRef: this.template.i
					}).bind( this.model );
				} else {
					// only with and if-with provide context - if and unless do not
					var context = this.sectionType !== SECTION_IF &amp;&amp; this.sectionType !== SECTION_UNLESS ? this.model : null;
					newFragment = new Fragment({
						owner: this,
						template: this.template.f
					}).bind( context );
				}
			}
		} else {
			if ( this.fragment &amp;&amp; this.rendered ) {
				if ( keep !== true ) {
					this.fragment.unbind().unrender( true );
				} else {
					this.unrender( false );
					this.detached = this.fragment;
					runloop.scheduleTask( function () { return this$1.detach(); } );
				}
			} else if ( this.fragment ) {
				this.fragment.unbind();
			}

			this.fragment = null;
		}

		if ( newFragment ) {
			if ( this.rendered ) {
				attach( this, newFragment );
			}

			this.fragment = newFragment;
		}

		if ( this.nextSibling ) {
			this.nextSibling.dirty = true;
			this.nextSibling.update();
		}
	};

	return Section;
}(MustacheContainer));

function attach ( section, fragment ) {
	var anchor = section.parentFragment.findNextNode( section );

	if ( anchor ) {
		var docFrag = createDocumentFragment();
		fragment.render( docFrag );

		anchor.parentNode.insertBefore( docFrag, anchor );
	} else {
		fragment.render( section.parentFragment.findParentNode() );
	}
}

var Select = (function (Element$$1) {
	function Select ( options ) {
		Element$$1.call( this, options );
		this.options = [];
	}

	if ( Element$$1 ) Select.__proto__ = Element$$1;
	Select.prototype = Object.create( Element$$1 &amp;&amp; Element$$1.prototype );
	Select.prototype.constructor = Select;

	Select.prototype.foundNode = function foundNode ( node ) {
		if ( this.binding ) {
			var selectedOptions = getSelectedOptions( node );

			if ( selectedOptions.length &gt; 0 ) {
				this.selectedOptions = selectedOptions;
			}
		}
	};

	Select.prototype.render = function render ( target, occupants ) {
		Element$$1.prototype.render.call( this, target, occupants );
		this.sync();

		var node = this.node;

		var i = node.options.length;
		while ( i-- ) {
			node.options[i].defaultSelected = node.options[i].selected;
		}

		this.rendered = true;
	};

	Select.prototype.sync = function sync () {
		var this$1 = this;

		var selectNode = this.node;

		if ( !selectNode ) { return; }

		var options = toArray( selectNode.options );

		if ( this.selectedOptions ) {
			options.forEach( function (o) {
				if ( this$1.selectedOptions.indexOf( o ) &gt;= 0 ) { o.selected = true; }
				else { o.selected = false; }
			});
			this.binding.setFromNode( selectNode );
			delete this.selectedOptions;
			return;
		}

		var selectValue = this.getAttribute( 'value' );
		var isMultiple = this.getAttribute( 'multiple' );
		var array = isMultiple &amp;&amp; Array.isArray( selectValue );

		// If the &lt;select&gt; has a specified value, that should override
		// these options
		if ( selectValue !== undefined ) {
			var optionWasSelected;

			options.forEach( function (o) {
				var optionValue = o._ractive ? o._ractive.value : o.value;
				var shouldSelect = isMultiple ?
					array &amp;&amp; this$1.valueContains( selectValue, optionValue ) :
					this$1.compare( selectValue, optionValue );

				if ( shouldSelect ) {
					optionWasSelected = true;
				}

				o.selected = shouldSelect;
			});

			if ( !optionWasSelected &amp;&amp; !isMultiple ) {
				if ( this.binding ) {
					this.binding.forceUpdate();
				}
			}
		}

		// Otherwise the value should be initialised according to which
		// &lt;option&gt; element is selected, if twoway binding is in effect
		else if ( this.binding ) {
			this.binding.forceUpdate();
		}
	};
	Select.prototype.valueContains = function valueContains ( selectValue, optionValue ) {
		var this$1 = this;

		var i = selectValue.length;
		while ( i-- ) {
			if ( this$1.compare( optionValue, selectValue[i] ) ) { return true; }
		}
	};
	Select.prototype.compare = function compare (optionValue, selectValue) {
		var comparator = this.getAttribute( 'value-comparator' );
		if ( comparator ) {
			if (typeof comparator === 'function') {
				return comparator( selectValue, optionValue );
			}
			if ( selectValue &amp;&amp; optionValue ) {
				return selectValue[comparator] == optionValue[comparator];
			}
		}
		return selectValue == optionValue;
	};
	Select.prototype.update = function update () {
		var dirty = this.dirty;
		Element$$1.prototype.update.call(this);
		if ( dirty ) {
			this.sync();
		}
	};

	return Select;
}(Element));

var Textarea = (function (Input$$1) {
	function Textarea( options ) {
		var template = options.template;

		options.deferContent = true;

		Input$$1.call( this, options );

		// check for single interpolator binding
		if ( !this.attributeByName.value ) {
			if ( template.f &amp;&amp; isBindable( { template: template } ) ) {
				this.attributes.push( createItem( {
					owner: this,
					template: { t: ATTRIBUTE, f: template.f, n: 'value' },
					parentFragment: this.parentFragment
				} ) );
			} else {
				this.fragment = new Fragment({ owner: this, cssIds: null, template: template.f });
			}
		}
	}

	if ( Input$$1 ) Textarea.__proto__ = Input$$1;
	Textarea.prototype = Object.create( Input$$1 &amp;&amp; Input$$1.prototype );
	Textarea.prototype.constructor = Textarea;

	Textarea.prototype.bubble = function bubble () {
		var this$1 = this;

		if ( !this.dirty ) {
			this.dirty = true;

			if ( this.rendered &amp;&amp; !this.binding &amp;&amp; this.fragment ) {
				runloop.scheduleTask( function () {
					this$1.dirty = false;
					this$1.node.value = this$1.fragment.toString();
				});
			}

			this.parentFragment.bubble(); // default behaviour
		}
	};

	return Textarea;
}(Input));

var Text = (function (Item$$1) {
	function Text ( options ) {
		Item$$1.call( this, options );
		this.type = TEXT;
	}

	if ( Item$$1 ) Text.__proto__ = Item$$1;
	Text.prototype = Object.create( Item$$1 &amp;&amp; Item$$1.prototype );
	Text.prototype.constructor = Text;

	Text.prototype.detach = function detach () {
		return detachNode( this.node );
	};

	Text.prototype.firstNode = function firstNode () {
		return this.node;
	};

	Text.prototype.render = function render ( target, occupants ) {
		if ( inAttributes() ) { return; }
		this.rendered = true;

		progressiveText( this, target, occupants, this.template );
	};

	Text.prototype.toString = function toString ( escape ) {
		return escape ? escapeHtml( this.template ) : this.template;
	};

	Text.prototype.unrender = function unrender ( shouldDestroy ) {
		if ( this.rendered &amp;&amp; shouldDestroy ) { this.detach(); }
		this.rendered = false;
	};

	Text.prototype.valueOf = function valueOf () {
		return this.template;
	};

	return Text;
}(Item));

var proto$3 = Text.prototype;
proto$3.bind = proto$3.unbind = proto$3.update = noop;

var camelizeHyphenated = function ( hyphenatedStr ) {
	return hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {
		return $1.toUpperCase();
	});
};

var prefix;

if ( !isClient ) {
	prefix = null;
} else {
	var prefixCache = {};
	var testStyle = createElement( 'div' ).style;

	prefix = function ( prop ) {
		prop = camelizeHyphenated( prop );

		if ( !prefixCache[ prop ] ) {
			if ( testStyle[ prop ] !== undefined ) {
				prefixCache[ prop ] = prop;
			}

			else {
				// test vendors...
				var capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );

				var i = vendors.length;
				while ( i-- ) {
					var vendor = vendors[i];
					if ( testStyle[ vendor + capped ] !== undefined ) {
						prefixCache[ prop ] = vendor + capped;
						break;
					}
				}
			}
		}

		return prefixCache[ prop ];
	};
}

var prefix$1 = prefix;

var visible;
var hidden = 'hidden';

if ( doc ) {
	var prefix$2;

	if ( hidden in doc ) {
		prefix$2 = <I>;</I>
	} else {
		var i$1 = vendors.length;
		while ( i$1-- ) {
			var vendor = vendors[i$1];
			hidden = vendor + 'Hidden';

			if ( hidden in doc ) {
				prefix$2 = vendor;
				break;
			}
		}
	}

	if ( prefix$2 !== undefined ) {
		doc.addEventListener( prefix$2 + 'visibilitychange', onChange );
		onChange();
	} else {
		// gah, we're in an old browser
		if ( 'onfocusout' in doc ) {
			doc.addEventListener( 'focusout', onHide );
			doc.addEventListener( 'focusin', onShow );
		}

		else {
			win.addEventListener( 'pagehide', onHide );
			win.addEventListener( 'blur', onHide );

			win.addEventListener( 'pageshow', onShow );
			win.addEventListener( 'focus', onShow );
		}

		visible = true; // until proven otherwise. Not ideal but hey
	}
}

function onChange () {
	visible = !doc[ hidden ];
}

function onHide () {
	visible = false;
}

function onShow () {
	visible = true;
}

var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );

var unprefix = function ( prop ) {
	return prop.replace( unprefixPattern, <I> );</I>
};

var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );

var hyphenate = function ( str ) {
	if ( !str ) { return <I>; } // edge case</I>

	if ( vendorPattern.test( str ) ) { str = '-' + str; }

	return str.replace( /[A-Z]/g, function (match) { return '-' + match.toLowerCase(); } );
};

var createTransitions;

if ( !isClient ) {
	createTransitions = null;
} else {
	var testStyle$1 = createElement( 'div' ).style;
	var linear$1 = function (x) { return x; };

	var canUseCssTransitions = {};
	var cannotUseCssTransitions = {};

	// determine some facts about our environment
	var TRANSITION$1;
	var TRANSITIONEND;
	var CSS_TRANSITIONS_ENABLED;
	var TRANSITION_DURATION;
	var TRANSITION_PROPERTY;
	var TRANSITION_TIMING_FUNCTION;

	if ( testStyle$1.transition !== undefined ) {
		TRANSITION$1 = 'transition';
		TRANSITIONEND = 'transitionend';
		CSS_TRANSITIONS_ENABLED = true;
	} else if ( testStyle$1.webkitTransition !== undefined ) {
		TRANSITION$1 = 'webkitTransition';
		TRANSITIONEND = 'webkitTransitionEnd';
		CSS_TRANSITIONS_ENABLED = true;
	} else {
		CSS_TRANSITIONS_ENABLED = false;
	}

	if ( TRANSITION$1 ) {
		TRANSITION_DURATION = TRANSITION$1 + 'Duration';
		TRANSITION_PROPERTY = TRANSITION$1 + 'Property';
		TRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';
	}

	createTransitions = function ( t, to, options, changedProperties, resolve ) {

		// Wait a beat (otherwise the target styles will be applied immediately)
		// TODO use a fastdom-style mechanism?
		setTimeout( function () {
			var jsTransitionsComplete;
			var cssTransitionsComplete;
			var cssTimeout; // eslint-disable-line prefer-const

			function transitionDone () { clearTimeout( cssTimeout ); }

			function checkComplete () {
				if ( jsTransitionsComplete &amp;&amp; cssTransitionsComplete ) {
					t.unregisterCompleteHandler( transitionDone );
					// will changes to events and fire have an unexpected consequence here?
					t.ractive.fire( t.name + ':end', t.node, t.isIntro );
					resolve();
				}
			}

			// this is used to keep track of which elements can use CSS to animate
			// which properties
			var hashPrefix = ( t.node.namespaceURI || <I> ) + t.node.tagName;</I>

			// need to reset transition properties
			var style = t.node.style;
			var previous = {
				property: style[ TRANSITION_PROPERTY ],
				timing: style[ TRANSITION_TIMING_FUNCTION ],
				duration: style[ TRANSITION_DURATION ]
			};

			style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix$1 ).map( hyphenate ).join( ',' );
			var easingName = hyphenate( options.easing || 'linear' );
			style[ TRANSITION_TIMING_FUNCTION ] = easingName;
			var cssTiming = style[ TRANSITION_TIMING_FUNCTION ] === easingName;
			style[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';

			function transitionEndHandler ( event ) {
				var index = changedProperties.indexOf( camelizeHyphenated( unprefix( event.propertyName ) ) );

				if ( index !== -1 ) {
					changedProperties.splice( index, 1 );
				}

				if ( changedProperties.length ) {
					// still transitioning...
					return;
				}

				clearTimeout( cssTimeout );
				cssTransitionsDone();
			}

			function cssTransitionsDone () {
				style[ TRANSITION_PROPERTY ] = previous.property;
				style[ TRANSITION_TIMING_FUNCTION ] = previous.duration;
				style[ TRANSITION_DURATION ] = previous.timing;

				t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );

				cssTransitionsComplete = true;
				checkComplete();
			}

			t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );

			// safety net in case transitionend never fires
			cssTimeout = setTimeout( function () {
				changedProperties = [];
				cssTransitionsDone();
			}, options.duration + ( options.delay || 0 ) + 50 );
			t.registerCompleteHandler( transitionDone );

			setTimeout( function () {
				var i = changedProperties.length;
				var hash;
				var originalValue;
				var index;
				var propertiesToTransitionInJs = [];
				var prop;
				var suffix;
				var interpolator;

				while ( i-- ) {
					prop = changedProperties[i];
					hash = hashPrefix + prop;

					if ( cssTiming &amp;&amp; CSS_TRANSITIONS_ENABLED &amp;&amp; !cannotUseCssTransitions[ hash ] ) {
						style[ prefix$1( prop ) ] = to[ prop ];

						// If we're not sure if CSS transitions are supported for
						// this tag/property combo, find out now
						if ( !canUseCssTransitions[ hash ] ) {
							originalValue = t.getStyle( prop );

							// if this property is transitionable in this browser,
							// the current style will be different from the target style
							canUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );
							cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];

							// Reset, if we're going to use timers after all
							if ( cannotUseCssTransitions[ hash ] ) {
								style[ prefix$1( prop ) ] = originalValue;
							}
						}
					}

					if ( !cssTiming || !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
						// we need to fall back to timer-based stuff
						if ( originalValue === undefined ) {
							originalValue = t.getStyle( prop );
						}

						// need to remove this from changedProperties, otherwise transitionEndHandler
						// will get confused
						index = changedProperties.indexOf( prop );
						if ( index === -1 ) {
							warnIfDebug( 'Something very strange happened with transitions. Please raise an issue at <A rel="nofollow" class="external free" href="https://github.com/ractivejs/ractive/issues">https://github.com/ractivejs/ractive/issues</A> - thanks!', { node: t.node });
						} else {
							changedProperties.splice( index, 1 );
						}

						// TODO Determine whether this property is animatable at all

						suffix = /[^\d]*$/.exec( to[ prop ] )[0];
						interpolator = interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ) || ( function () { return to[ prop ]; } );

						// ...then kick off a timer-based transition
						propertiesToTransitionInJs.push({
							name: prefix$1( prop ),
							interpolator: interpolator,
							suffix: suffix
						});
					}
				}

				// javascript transitions
				if ( propertiesToTransitionInJs.length ) {
					var easing;

					if ( typeof options.easing === 'string' ) {
						easing = t.ractive.easing[ options.easing ];

						if ( !easing ) {
							warnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );
							easing = linear$1;
						}
					} else if ( typeof options.easing === 'function' ) {
						easing = options.easing;
					} else {
						easing = linear$1;
					}

					new Ticker({
						duration: options.duration,
						easing: easing,
						step: function step ( pos ) {
							var i = propertiesToTransitionInJs.length;
							while ( i-- ) {
								var prop = propertiesToTransitionInJs[i];
								t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
							}
						},
						complete: function complete () {
							jsTransitionsComplete = true;
							checkComplete();
						}
					});
				} else {
					jsTransitionsComplete = true;
				}

				if ( !changedProperties.length ) {
					// We need to cancel the transitionEndHandler, and deal with
					// the fact that it will never fire
					t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
					cssTransitionsComplete = true;
					checkComplete();
				}
			}, 0 );
		}, options.delay || 0 );
	};
}

var createTransitions$1 = createTransitions;

function resetStyle ( node, style ) {
	if ( style ) {
		node.setAttribute( 'style', style );
	} else {
		// Next line is necessary, to remove empty style attribute!
		// See <A rel="nofollow" class="external free" href="http://stackoverflow.com/a/7167553">http://stackoverflow.com/a/7167553</A>
		node.getAttribute( 'style' );
		node.removeAttribute( 'style' );
	}
}

var getComputedStyle = win &amp;&amp; win.getComputedStyle;
var resolved = Promise.resolve();

var names = {
	t0: 'intro-outro',
	t1: 'intro',
	t2: 'outro'
};

var Transition = function Transition ( options ) {
	this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );
	this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );
	this.ractive = this.owner.ractive;
	this.template = options.template;
	this.parentFragment = options.parentFragment;
	this.options = options;
	this.onComplete = [];
};

Transition.prototype.animateStyle = function animateStyle ( style, value, options ) {
		var this$1 = this;

	if ( arguments.length === 4 ) {
		throw new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );
	}

	// Special case - page isn't visible. Don't animate anything, because
	// that way you'll never get CSS transitionend events
	if ( !visible ) {
		this.setStyle( style, value );
		return resolved;
	}

	var to;

	if ( typeof style === 'string' ) {
		to = {};
		to[ style ] = value;
	} else {
		to = style;

		// shuffle arguments
		options = value;
	}

	// As of 0.3.9, transition authors should supply an `option` object with
	// `duration` and `easing` properties (and optional `delay`), plus a
	// callback function that gets called after the animation completes

	// TODO remove this check in a future version
	if ( !options ) {
		warnOnceIfDebug( 'The &quot;%s&quot; transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see <A rel="nofollow" class="external free" href="https://github.com/RactiveJS/Ractive/issues/340'">https://github.com/RactiveJS/Ractive/issues/340'</A>, this.name );
		options = this;
	}

	return new Promise( function (fulfil) {
		// Edge case - if duration is zero, set style synchronously and complete
		if ( !options.duration ) {
			this$1.setStyle( to );
			fulfil();
			return;
		}

		// Get a list of the properties we're animating
		var propertyNames = Object.keys( to );
		var changedProperties = [];

		// Store the current styles
		var computedStyle = getComputedStyle( this$1.node );

		var i = propertyNames.length;
		while ( i-- ) {
			var prop = propertyNames[i];
			var current = computedStyle[ prefix$1( prop ) ];

			if ( current === '0px' ) { current = 0; }

			// we need to know if we're actually changing anything
			if ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers
				changedProperties.push( prop );

				// make the computed style explicit, so we can animate where
				// e.g. height='auto'
				this$1.node.style[ prefix$1( prop ) ] = current;
			}
		}

		// If we're not actually changing anything, the transitionend event
		// will never fire! So we complete early
		if ( !changedProperties.length ) {
			fulfil();
			return;
		}

		createTransitions$1( this$1, to, options, changedProperties, fulfil );
	});
};

Transition.prototype.bind = function bind () {
	var options = this.options;
	var type = options.template &amp;&amp; options.template.v;
	if ( type ) {
		if ( type === 't0' || type === 't1' ) { this.element.intro = this; }
		if ( type === 't0' || type === 't2' ) { this.element.outro = this; }
		this.eventName = names[ type ];
	}

	var ractive = this.owner.ractive;

	this.name = options.name || options.template.n;

	if ( options.params ) {
		this.params = options.params;
	}

	if ( typeof this.name === 'function' ) {
		this._fn = this.name;
		this.name = this._fn.name;
	} else {
		this._fn = findInViewHierarchy( 'transitions', ractive, this.name );
	}

	if ( !this._fn ) {
		warnOnceIfDebug( missingPlugin( this.name, 'transition' ), { ractive: ractive });
	}

	setupArgsFn( this, options.template );
};

Transition.prototype.getParams = function getParams () {
	if ( this.params ) { return this.params; }

	// get expression args if supplied
	if ( this.fn ) {
		var values = resolveArgs( this, this.template, this.parentFragment ).map( function (model) {
			if ( !model ) { return undefined; }

			return model.get();
		});
		return this.fn.apply( this.ractive, values );
	}
};

Transition.prototype.getStyle = function getStyle ( props ) {
	var computedStyle = getComputedStyle( this.node );

	if ( typeof props === 'string' ) {
		var value = computedStyle[ prefix$1( props ) ];
		return value === '0px' ? 0 : value;
	}

	if ( !Array.isArray( props ) ) {
		throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
	}

	var styles = {};

	var i = props.length;
	while ( i-- ) {
		var prop = props[i];
		var value$1 = computedStyle[ prefix$1( prop ) ];

		if ( value$1 === '0px' ) { value$1 = 0; }
		styles[ prop ] = value$1;
	}

	return styles;
};

Transition.prototype.processParams = function processParams ( params, defaults ) {
	if ( typeof params === 'number' ) {
		params = { duration: params };
	}

	else if ( typeof params === 'string' ) {
		if ( params === 'slow' ) {
			params = { duration: 600 };
		} else if ( params === 'fast' ) {
			params = { duration: 200 };
		} else {
			params = { duration: 400 };
		}
	} else if ( !params ) {
		params = {};
	}

	return Object.assign( {}, defaults, params );
};

Transition.prototype.registerCompleteHandler = function registerCompleteHandler ( fn ) {
	addToArray( this.onComplete, fn );
};

Transition.prototype.setStyle = function setStyle ( style, value ) {
		var this$1 = this;

	if ( typeof style === 'string' ) {
		this.node.style[ prefix$1( style ) ] = value;
	}

	else {
		var prop;
		for ( prop in style ) {
			if ( style.hasOwnProperty( prop ) ) {
				this$1.node.style[ prefix$1( prop ) ] = style[ prop ];
			}
		}
	}

	return this;
};

Transition.prototype.shouldFire = function shouldFire ( type ) {
	if ( !this.ractive.transitionsEnabled ) { return false; }

	// check for noIntro and noOutro cases, which only apply when the owner ractive is rendering and unrendering, respectively
	if ( type === 'intro' &amp;&amp; this.ractive.rendering &amp;&amp; nearestProp( 'noIntro', this.ractive, true ) ) { return false; }
	if ( type === 'outro' &amp;&amp; this.ractive.unrendering &amp;&amp; nearestProp( 'noOutro', this.ractive, false ) ) { return false; }

	var params = this.getParams(); // this is an array, the params object should be the first member
	// if there's not a parent element, this can't be nested, so roll on
	if ( !this.element.parent ) { return true; }

	// if there is a local param, it takes precedent
	if ( params &amp;&amp; params[0] &amp;&amp; 'nested' in params[0] ) {
		if ( params[0].nested !== false ) { return true; }
	} else { // use the nearest instance setting
		// find the nearest instance that actually has a nested setting
		if ( nearestProp( 'nestedTransitions', this.ractive ) !== false ) { return true; }
	}

	// check to see if this is actually a nested transition
	var el = this.element.parent;
	while ( el ) {
		if ( el[type] &amp;&amp; el[type].starting ) { return false; }
		el = el.parent;
	}

	return true;
};

Transition.prototype.start = function start () {
		var this$1 = this;

	var node = this.node = this.element.node;
	var originalStyle = node.getAttribute( 'style' );

	var completed;
	var args = this.getParams();

	// create t.complete() - we don't want this on the prototype,
	// because we don't want `this` silliness when passing it as
	// an argument
	this.complete = function (noReset) {
		this$1.starting = false;
		if ( completed ) {
			return;
		}

		this$1.onComplete.forEach( function (fn) { return fn(); } );
		if ( !noReset &amp;&amp; this$1.isIntro ) {
			resetStyle( node, originalStyle);
		}

		this$1._manager.remove( this$1 );

		completed = true;
	};

	// If the transition function doesn't exist, abort
	if ( !this._fn ) {
		this.complete();
		return;
	}

	var promise = this._fn.apply( this.ractive, [ this ].concat( args ) );
	if ( promise ) { promise.then( this.complete ); }
};

Transition.prototype.toString = function toString () { return <I>; };</I>

Transition.prototype.unbind = function unbind () {
	if ( !this.element.attributes.unbinding ) {
		var type = this.options &amp;&amp; this.options.template &amp;&amp; this.options.template.v;
		if ( type === 't0' || type === 't1' ) { this.element.intro = null; }
		if ( type === 't0' || type === 't2' ) { this.element.outro = null; }
	}
};

Transition.prototype.unregisterCompleteHandler = function unregisterCompleteHandler ( fn ) {
	removeFromArray( this.onComplete, fn );
};

var proto$4 = Transition.prototype;
proto$4.destroyed = proto$4.render = proto$4.unrender = proto$4.update = noop;

function nearestProp ( prop, ractive, rendering ) {
	var instance = ractive;
	while ( instance ) {
		if ( instance.hasOwnProperty( prop ) &amp;&amp; ( rendering === undefined || rendering ? instance.rendering : instance.unrendering ) ) { return instance[ prop ]; }
		instance = instance.component &amp;&amp; instance.component.ractive;
	}

	return ractive[ prop ];
}

var elementCache = {};

var ieBug;
var ieBlacklist;

try {
	createElement( 'table' ).innerHTML = 'foo';
} catch ( err ) {
	ieBug = true;

	ieBlacklist = {
		TABLE:  [ '<TABLE class="x">', '</TABLE>' ],
		THEAD:  [ '<TABLE>&lt;thead class=&quot;x&quot;&gt;', '&lt;/thead&gt;</TABLE>' ],
		TBODY:  [ '<TABLE>&lt;tbody class=&quot;x&quot;&gt;', '&lt;/tbody&gt;</TABLE>' ],
		TR:     [ '<TABLE><TBODY><TR class="x">', '</TR></TBODY></TABLE>' ],
<P>		SELECT: [ '&lt;select class=&quot;x&quot;&gt;', '&lt;/select&gt;' ]
	};
}
</P><P>var insertHtml = function ( html$$1, node ) {
	var nodes = [];
</P><P>	// render 0 and false
	if ( html$$1 == null || html$$1 === <I> ) { return nodes; }</I></P><P>	var container;
	var wrapper;
	var selectedOption;
</P><P>	if ( ieBug &amp;&amp; ( wrapper = ieBlacklist[ node.tagName ] ) ) {
		container = element( 'DIV' );
		container.innerHTML = wrapper[0] + html$$1 + wrapper[1];
		container = container.querySelector( '.x' );
</P><P>		if ( container.tagName === 'SELECT' ) {
			selectedOption = container.options[ container.selectedIndex ];
		}
	}
</P><P>	else if ( node.namespaceURI === svg$1 ) {
		container = element( 'DIV' );
		container.innerHTML = '&lt;svg class=&quot;x&quot;&gt;' + html$$1 + '&lt;/svg&gt;';
		container = container.querySelector( '.x' );
	}
</P><P>	else if ( node.tagName === 'TEXTAREA' ) {
		container = createElement( 'div' );
</P><P>		if ( typeof container.textContent !== 'undefined' ) {
			container.textContent = html$$1;
		} else {
			container.innerHTML = html$$1;
		}
	}
</P><P>	else {
		container = element( node.tagName );
		container.innerHTML = html$$1;
</P><P>		if ( container.tagName === 'SELECT' ) {
			selectedOption = container.options[ container.selectedIndex ];
		}
	}
</P><P>	var child;
	while ( child = container.firstChild ) {
		nodes.push( child );
		container.removeChild( child );
	}
</P><P>	// This is really annoying. Extracting &lt;option&gt; nodes from the
	// temporary container &lt;select&gt; causes the remaining ones to
	// become selected. So now we have to deselect them. IE8, you
	// amaze me. You really do
	// ...and now Chrome too
	var i;
	if ( node.tagName === 'SELECT' ) {
		i = nodes.length;
		while ( i-- ) {
			if ( nodes[i] !== selectedOption ) {
				nodes[i].selected = false;
			}
		}
	}
</P><P>	return nodes;
};
</P><P>function element ( tagName ) {
	return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
}
</P><P>var Triple = (function (Mustache$$1) {
	function Triple ( options ) {
		Mustache$$1.call( this, options );
	}
</P><P>	if ( Mustache$$1 ) Triple.__proto__ = Mustache$$1;
	Triple.prototype = Object.create( Mustache$$1 &amp;&amp; Mustache$$1.prototype );
	Triple.prototype.constructor = Triple;
</P><P>	Triple.prototype.detach = function detach () {
		var docFrag = createDocumentFragment();
		if ( this.nodes ) { this.nodes.forEach( function (node) { return docFrag.appendChild( node ); } ); }
		return docFrag;
	};
</P><P>	Triple.prototype.find = function find ( selector ) {
		var this$1 = this;
</P><P>		var len = this.nodes.length;
		var i;
</P><P>		for ( i = 0; i &lt; len; i += 1 ) {
			var node = this$1.nodes[i];
</P><P>			if ( node.nodeType !== 1 ) { continue; }
</P><P>			if ( matches( node, selector ) ) { return node; }
</P><P>			var queryResult = node.querySelector( selector );
			if ( queryResult ) { return queryResult; }
		}
</P><P>		return null;
	};
</P><P>	Triple.prototype.findAll = function findAll ( selector, options ) {
		var this$1 = this;
</P><P>		var result = options.result;
		var len = this.nodes.length;
		var i;
</P><P>		for ( i = 0; i &lt; len; i += 1 ) {
			var node = this$1.nodes[i];
</P><P>			if ( node.nodeType !== 1 ) { continue; }
</P><P>			if ( matches( node, selector ) ) { result.push( node ); }
</P><P>			var queryAllResult = node.querySelectorAll( selector );
			if ( queryAllResult ) {
				result.push.apply( result, queryAllResult );
			}
		}
	};
</P><P>	Triple.prototype.findComponent = function findComponent () {
		return null;
	};
</P><P>	Triple.prototype.firstNode = function firstNode () {
		return this.rendered &amp;&amp; this.nodes[0];
	};
</P><P>	Triple.prototype.render = function render ( target, occupants ) {
		var this$1 = this;
</P><P>		var parentNode = this.parentFragment.findParentNode();
</P><P>		if ( !this.nodes ) {
			var html = this.model ? this.model.get() : <I>;</I>
			this.nodes = insertHtml( html, this.parentFragment.findParentNode(), target );
		}
</P><P>		var nodes = this.nodes;
		var anchor = this.parentFragment.findNextNode( this );
</P><P>		// progressive enhancement
		if ( occupants ) {
			var i = -1;
			var next;
</P><P>			// start with the first node that should be rendered
			while ( occupants.length &amp;&amp; ( next = this.nodes[ i + 1 ] ) ) {
				var n = (void 0);
				// look through the occupants until a matching node is found
				while ( n = occupants.shift() ) {
					var t = n.nodeType;
</P><P>					if ( t === next.nodeType &amp;&amp; ( ( t === 1 &amp;&amp; n.outerHTML === next.outerHTML ) || ( ( t === 3 || t === 8 ) &amp;&amp; n.nodeValue === next.nodeValue ) ) ) {
						this$1.nodes.splice( ++i, 1, n ); // replace the generated node with the existing one
						break;
					} else {
						target.removeChild( n ); // remove the non-matching existing node
					}
				}
			}
</P><P>			if ( i &gt;= 0 ) {
				// update the list of remaining nodes to attach, excluding any that were replaced by existing nodes
				nodes = this.nodes.slice( i );
			}
</P><P>			// update the anchor to be the next occupant
			if ( occupants.length ) { anchor = occupants[0]; }
		}
</P><P>		// attach any remainging nodes to the parent
		if ( nodes.length ) {
			var frag = createDocumentFragment();
			nodes.forEach( function (n) { return frag.appendChild( n ); } );
</P><P>			if ( anchor ) {
				anchor.parentNode.insertBefore( frag, anchor );
			} else {
				parentNode.appendChild( frag );
			}
		}
</P><P>		this.rendered = true;
	};
</P><P>	Triple.prototype.toString = function toString () {
		var value = this.model &amp;&amp; this.model.get();
		value = value != null ? <I> + value : </I>;
</P><P>		return inAttribute() ? decodeCharacterReferences( value ) : value;
	};
</P><P>	Triple.prototype.unrender = function unrender () {
		if ( this.nodes ) { this.nodes.forEach( function (node) { return detachNode( node ); } ); }
		this.rendered = false;
		this.nodes = null;
	};
</P><P>	Triple.prototype.update = function update () {
		if ( this.rendered &amp;&amp; this.dirty ) {
			this.dirty = false;
</P><P>			this.unrender();
			this.render();
		} else {
			// make sure to reset the dirty flag even if not rendered
			this.dirty = false;
		}
	};
</P><P>	return Triple;
}(Mustache));
</P><P>// finds the component constructor in the registry or view hierarchy registries
function getComponentConstructor ( ractive, name ) {
	var instance = findInstance( 'components', ractive, name );
	var Component;
</P><P>	if ( instance ) {
		Component = instance.components[ name ];
</P><P>		// best test we have for not Ractive.extend
		if ( Component &amp;&amp; !Component._Parent ) {
			// function option, execute and store for reset
			var fn = Component.bind( instance );
			fn.isOwner = instance.components.hasOwnProperty( name );
			Component = fn();
</P><P>			if ( !Component ) {
				warnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive: ractive });
				return;
			}
</P><P>			if ( typeof Component === 'string' ) {
				// allow string lookup
				Component = getComponentConstructor( ractive, Component );
			}
</P><P>			Component._fn = fn;
			instance.components[ name ] = Component;
		}
	}
</P><P>	return Component;
}
</P><P>//import Yielder from './Yielder';
var constructors = {};
constructors[ ALIAS ] = Alias;
constructors[ ANCHOR ] = Component;
constructors[ DOCTYPE ] = Doctype;
constructors[ INTERPOLATOR ] = Interpolator;
constructors[ PARTIAL ] = Partial;
constructors[ SECTION ] = Section;
constructors[ TRIPLE ] = Triple;
constructors[ YIELDER ] = Partial;
</P><P>constructors[ ATTRIBUTE ] = Attribute;
constructors[ BINDING_FLAG ] = BindingFlag;
constructors[ DECORATOR ] = Decorator;
constructors[ EVENT ] = EventDirective;
constructors[ TRANSITION ] = Transition;
</P><P>var specialElements = {
	doctype: Doctype,
	form: Form,
	input: Input,
	option: Option,
	select: Select,
	textarea: Textarea
};
</P><P>function createItem ( options ) {
	if ( typeof options.template === 'string' ) {
		return new Text( options );
	}
</P><P>	if ( options.template.t === ELEMENT ) {
		// could be component or element
		var ComponentConstructor = getComponentConstructor( options.parentFragment.ractive, options.template.e );
		if ( ComponentConstructor ) {
			return new Component( options, ComponentConstructor );
		}
</P><P>		var tagName = options.template.e.toLowerCase();
</P><P>		var ElementConstructor = specialElements[ tagName ] || Element;
		return new ElementConstructor( options );
	}
</P><P>	var Item;
</P><P>	// component mappings are a special case of attribute
	if ( options.template.t === ATTRIBUTE ) {
		var el = options.owner;
		if ( !el || ( el.type !== ANCHOR &amp;&amp; el.type !== COMPONENT &amp;&amp; el.type !== ELEMENT ) ) {
			el = findElement( options.parentFragment );
		}
		options.element = el;
</P><P>		Item = el.type === COMPONENT || el.type === ANCHOR ? Mapping : Attribute;
	} else {
		Item = constructors[ options.template.t ];
	}
</P><P>	if ( !Item ) { throw new Error( (&quot;Unrecognised item type &quot; + (options.template.t)) ); }
</P><P>	return new Item( options );
}
</P><P>// TODO all this code needs to die
function processItems ( items, values, guid, counter ) {
	if ( counter === void 0 ) counter = 0;
</P><P>	return items.map( function (item) {
		if ( item.type === TEXT ) {
			return item.template;
		}
</P><P>		if ( item.fragment ) {
			if ( item.fragment.iterations ) {
				return item.fragment.iterations.map( function (fragment) {
					return processItems( fragment.items, values, guid, counter );
				}).join( <I> );</I>
			} else {
				return processItems( item.fragment.items, values, guid, counter );
			}
		}
</P><P>		var placeholderId = guid + &quot;-&quot; + (counter++);
		var model = item.model || item.newModel;
</P><P>		values[ placeholderId ] = model ?
			model.wrapper ?
				model.wrapperValue :
				model.get() :
			undefined;
</P><P>		return '${' + placeholderId + '}';
	}).join( <I> );</I>
}
</P><P>function unrenderAndDestroy$1 ( item ) {
	item.unrender( true );
}
</P><P>var Fragment = function Fragment ( options ) {
	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute
</P><P>	this.isRoot = !options.owner.parentFragment;
	this.parent = this.isRoot ? null : this.owner.parentFragment;
	this.ractive = options.ractive || ( this.isRoot ? options.owner : this.parent.ractive );
</P><P>	this.componentParent = ( this.isRoot &amp;&amp; this.ractive.component ) ? this.ractive.component.parentFragment : null;
	this.delegate = ( this.parent ? this.parent.delegate : ( this.componentParent &amp;&amp; this.componentParent.delegate ) ) ||
		( this.owner.containerFragment &amp;&amp; this.owner.containerFragment.delegate );
</P><P>	this.context = null;
	this.rendered = false;
</P><P>	// encapsulated styles should be inherited until they get applied by an element
	this.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );
</P><P>	this.dirty = false;
	this.dirtyValue = true; // used for attribute values
</P><P>	this.template = options.template || [];
	this.createItems();
};
</P><P>Fragment.prototype.bind = function bind$1 ( context ) {
	this.context = context;
	this.items.forEach( bind );
	this.bound = true;
</P><P>	// in rare cases, a forced resolution (or similar) will cause the
	// fragment to be dirty before it's even finished binding. In those
	// cases we update immediately
	if ( this.dirty ) { this.update(); }
</P><P>	return this;
};
</P><P>Fragment.prototype.bubble = function bubble () {
	this.dirtyValue = true;
</P><P>	if ( !this.dirty ) {
		this.dirty = true;
</P><P>		if ( this.isRoot ) { // TODO encapsulate 'is component root, but not overall root' check?
			if ( this.ractive.component ) {
				this.ractive.component.bubble();
			} else if ( this.bound ) {
				runloop.addFragment( this );
			}
		} else {
			this.owner.bubble( this.index );
		}
	}
};
</P><P>Fragment.prototype.createItems = function createItems () {
		var this$1 = this;
</P><P>	// this is a hot code path
	var max = this.template.length;
	this.items = [];
	for ( var i = 0; i &lt; max; i++ ) {
		this$1.items[i] = createItem({ parentFragment: this$1, template: this$1.template[i], index: i });
	}
};
</P><P>Fragment.prototype.destroyed = function destroyed$1 () {
	this.items.forEach( destroyed );
};
</P><P>Fragment.prototype.detach = function detach () {
	var docFrag = createDocumentFragment();
	var xs = this.items;
	var len = xs.length;
	for ( var i = 0; i &lt; len; i++ ) {
		docFrag.appendChild( xs[i].detach() );
	}
	return docFrag;
};
</P><P>Fragment.prototype.find = function find ( selector, options ) {
	return findMap( this.items, function (i) { return i.find( selector, options ); } );
};
</P><P>Fragment.prototype.findAll = function findAll ( selector, options ) {
	if ( this.items ) {
		this.items.forEach( function (i) { return i.findAll &amp;&amp; i.findAll( selector, options ); } );
	}
};
</P><P>Fragment.prototype.findComponent = function findComponent ( name, options ) {
	return findMap( this.items, function (i) { return i.findComponent( name, options ); } );
};
</P><P>Fragment.prototype.findAllComponents = function findAllComponents ( name, options ) {
	if ( this.items ) {
		this.items.forEach( function (i) { return i.findAllComponents &amp;&amp; i.findAllComponents( name, options ); } );
	}
};
</P><P>Fragment.prototype.findContext = function findContext () {
	var fragment = this;
	while ( fragment &amp;&amp; !fragment.context ) { fragment = fragment.parent; }
	if ( !fragment ) { return this.ractive.viewmodel; }
	else { return fragment.context; }
};
</P><P>Fragment.prototype.findNextNode = function findNextNode ( item ) {
		var this$1 = this;
</P><P>	// search for the next node going forward
	if ( item ) {
		for ( var i = item.index + 1; i &lt; this.items.length; i++ ) {
			if ( !this$1.items[ i ] ) { continue; }
</P><P>			var node = this$1.items[ i ].firstNode( true );
			if ( node ) { return node; }
		}
	}
</P><P>	// if this is the root fragment, and there are no more items,
	// it means we're at the end...
	if ( this.isRoot ) {
		if ( this.ractive.component ) {
			return this.ractive.component.parentFragment.findNextNode( this.ractive.component );
		}
</P><P>		// TODO possible edge case with other content
		// appended to this.ractive.el?
		return null;
	}
</P><P>	if ( this.parent ) { return this.owner.findNextNode( this ); } // the argument is in case the parent is a RepeatedFragment
};
</P><P>Fragment.prototype.findParentNode = function findParentNode () {
	var fragment = this;
</P><P>	do {
		if ( fragment.owner.type === ELEMENT ) {
			return fragment.owner.node;
		}
</P><P>		if ( fragment.isRoot &amp;&amp; !fragment.ractive.component ) { // TODO encapsulate check
			return fragment.ractive.el;
		}
</P><P>		if ( fragment.owner.type === YIELDER ) {
			fragment = fragment.owner.containerFragment;
		} else {
			fragment = fragment.componentParent || fragment.parent; // TODO ugh
		}
	} while ( fragment );
</P><P>	throw new Error( 'Could not find parent node' ); // TODO link to issue tracker
};
</P><P>Fragment.prototype.findRepeatingFragment = function findRepeatingFragment () {
	var fragment = this;
	// TODO better check than fragment.parent.iterations
	while ( ( fragment.parent || fragment.componentParent ) &amp;&amp; !fragment.isIteration ) {
		fragment = fragment.parent || fragment.componentParent;
	}
</P><P>	return fragment;
};
</P><P>Fragment.prototype.firstNode = function firstNode ( skipParent ) {
	var node = findMap( this.items, function (i) { return i.firstNode( true ); } );
	if ( node ) { return node; }
	if ( skipParent ) { return null; }
</P><P>	return this.parent.findNextNode( this.owner );
};
</P><P>Fragment.prototype.rebind = function rebind ( next ) {
	this.context = next;
};
</P><P>Fragment.prototype.render = function render$$1 ( target, occupants ) {
	if ( this.rendered ) { throw new Error( 'Fragment is already rendered!' ); }
	this.rendered = true;
</P><P>	var xs = this.items;
	var len = xs.length;
	for ( var i = 0; i &lt; len; i++ ) {
		xs[i].render( target, occupants );
	}
};
</P><P>Fragment.prototype.resetTemplate = function resetTemplate ( template ) {
	var wasBound = this.bound;
	var wasRendered = this.rendered;
</P><P>	// TODO ensure transitions are disabled globally during reset
</P><P>	if ( wasBound ) {
		if ( wasRendered ) { this.unrender( true ); }
		this.unbind();
	}
</P><P>	this.template = template;
	this.createItems();
</P><P>	if ( wasBound ) {
		this.bind( this.context );
</P><P>		if ( wasRendered ) {
			var parentNode = this.findParentNode();
			var anchor = this.findNextNode();
</P><P>			if ( anchor ) {
				var docFrag = createDocumentFragment();
				this.render( docFrag );
				parentNode.insertBefore( docFrag, anchor );
			} else {
				this.render( parentNode );
			}
		}
	}
};
</P><P>Fragment.prototype.shuffled = function shuffled$1 () {
	this.items.forEach( shuffled );
};
</P><P>Fragment.prototype.toString = function toString$1$$1 ( escape ) {
	return this.items.map( escape ? toEscapedString : toString$1 ).join( <I> );</I>
};
</P><P>Fragment.prototype.unbind = function unbind$1 () {
	this.context = null;
	this.items.forEach( unbind );
	this.bound = false;
</P><P>	return this;
};
</P><P>Fragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {
	this.items.forEach( shouldDestroy ? unrenderAndDestroy$1 : unrender );
	this.rendered = false;
};
</P><P>Fragment.prototype.update = function update$1 () {
	if ( this.dirty ) {
		if ( !this.updating ) {
			this.dirty = false;
			this.updating = true;
			this.items.forEach( update );
			this.updating = false;
		} else if ( this.isRoot ) {
			runloop.addFragmentToRoot( this );
		}
	}
};
</P><P>Fragment.prototype.valueOf = function valueOf () {
	if ( this.items.length === 1 ) {
		return this.items[0].valueOf();
	}
</P><P>	if ( this.dirtyValue ) {
		var values = {};
		var source = processItems( this.items, values, this.ractive._guid );
		var parsed = parseJSON( source, values );
</P><P>		this.value = parsed ?
			parsed.value :
			this.toString();
</P><P>		this.dirtyValue = false;
	}
</P><P>	return this.value;
};
</P><P>Fragment.prototype.getContext = getContext;
</P><P>function getChildQueue ( queue, ractive ) {
	return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );
}
</P><P>function fire ( hookQueue, ractive ) {
	var childQueue = getChildQueue( hookQueue.queue, ractive );
</P><P>	hookQueue.hook.fire( ractive );
</P><P>	// queue is &quot;live&quot; because components can end up being
	// added while hooks fire on parents that modify data values.
	while ( childQueue.length ) {
		fire( hookQueue, childQueue.shift() );
	}
</P><P>	delete hookQueue.queue[ ractive._guid ];
}
</P><P>var HookQueue = function HookQueue ( event ) {
	this.hook = new Hook( event );
	this.inProcess = {};
	this.queue = {};
};
</P><P>HookQueue.prototype.begin = function begin ( ractive ) {
	this.inProcess[ ractive._guid ] = true;
};
</P><P>HookQueue.prototype.end = function end ( ractive ) {
	var parent = ractive.parent;
</P><P>	// If this is *isn't* a child of a component that's in process,
	// it should call methods or fire at this point
	if ( !parent || !this.inProcess[ parent._guid ] ) {
		fire( this, ractive );
	}
	// elsewise, handoff to parent to fire when ready
	else {
		getChildQueue( this.queue, parent ).push( ractive );
	}
</P><P>	delete this.inProcess[ ractive._guid ];
};
</P><P>var configHook = new Hook( 'config' );
var initHook = new HookQueue( 'init' );
</P><P>function initialise ( ractive, userOptions, options ) {
	Object.keys( ractive.viewmodel.computations ).forEach( function (key) {
		var computation = ractive.viewmodel.computations[ key ];
</P><P>		if ( ractive.viewmodel.value.hasOwnProperty( key ) ) {
			computation.set( ractive.viewmodel.value[ key ] );
		}
	});
</P><P>	// set up event subscribers
	subscribe( ractive, userOptions, 'on' );
</P><P>	// init config from Parent and options
	config.init( ractive.constructor, ractive, userOptions );
</P><P>	configHook.fire( ractive );
</P><P>	// general config done, set up observers
	subscribe( ractive, userOptions, 'observe' );
</P><P>	initHook.begin( ractive );
</P><P>	var fragment = ractive.fragment = createFragment( ractive, options );
	if ( fragment ) { fragment.bind( ractive.viewmodel ); }
</P><P>	initHook.end( ractive );
</P><P>	if ( fragment ) {
		// render automatically ( if `el` is specified )
		var el = getElement( ractive.el || ractive.target );
		if ( el ) {
			var promise = ractive.render( el, ractive.append );
</P><P>			if ( Ractive.DEBUG_PROMISES ) {
				promise.catch( function (err) {
					warnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;' );
					warnIfDebug( 'An error happened during rendering', { ractive: ractive });
					logIfDebug( err );
</P><P>					throw err;
				});
			}
		}
	}
}
</P><P>function createFragment ( ractive, options ) {
	if ( options === void 0 ) options = {};
</P><P>	if ( ractive.template ) {
		var cssIds;
</P><P>		if ( options.cssIds || ractive.cssId ) {
			cssIds = options.cssIds ? options.cssIds.slice() : [];
</P><P>			if ( ractive.cssId ) {
				cssIds.push( ractive.cssId );
			}
		}
</P><P>		return new Fragment({
			owner: ractive,
			template: ractive.template,
			cssIds: cssIds
		});
	}
}
</P><P>function subscribe ( instance, options, type ) {
	var subs = ( instance.constructor[ (&quot;_&quot; + type) ] || [] ).concat( toPairs( options[ type ] || [] ) );
	var single = type === 'on' ? 'once' : (type + &quot;Once&quot;);
</P><P>	subs.forEach( function (ref) {
		var target = ref[0];
		var config$$1 = ref[1];
</P><P>		if ( typeof config$$1 === 'function' ) {
			instance[type]( target, config$$1 );
		} else if ( typeof config$$1 === 'object' &amp;&amp; typeof config$$1.handler === 'function' ) {
			instance[ config$$1.once ? single : type ]( target, config$$1.handler, config$$1 );
		}
	});
}
</P><P>var renderHook = new Hook( 'render' );
var completeHook = new Hook( 'complete' );
</P><P>function render$1 ( ractive, target, anchor, occupants ) {
	// set a flag to let any transitions know that this instance is currently rendering
	ractive.rendering = true;
</P><P>	var promise = runloop.start( ractive, true );
	runloop.scheduleTask( function () { return renderHook.fire( ractive ); }, true );
</P><P>	if ( ractive.fragment.rendered ) {
		throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
	}
</P><P>	if ( ractive.destroyed ) {
		ractive.destroyed = false;
		ractive.fragment = createFragment( ractive ).bind( ractive.viewmodel );
	}
</P><P>	anchor = getElement( anchor ) || ractive.anchor;
</P><P>	ractive.el = ractive.target = target;
	ractive.anchor = anchor;
</P><P>	// ensure encapsulated CSS is up-to-date
	if ( ractive.cssId ) { applyCSS(); }
</P><P>	if ( target ) {
		( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( ractive );
</P><P>		if ( anchor ) {
			var docFrag = doc.createDocumentFragment();
			ractive.fragment.render( docFrag );
			target.insertBefore( docFrag, anchor );
		} else {
			ractive.fragment.render( target, occupants );
		}
	}
</P><P>	runloop.end();
	ractive.rendering = false;
</P><P>	return promise.then( function () {
		if (ractive.torndown) { return; }
</P><P>		completeHook.fire( ractive );
	});
}
</P><P>function Ractive$render ( target, anchor ) {
	if ( this.torndown ) {
		warnIfDebug( 'ractive.render() was called on a Ractive instance that was already torn down' );
		return Promise.resolve();
	}
</P><P>	target = getElement( target ) || this.el;
</P><P>	if ( !this.append &amp;&amp; target ) {
		// Teardown any existing instances *before* trying to set up the new one -
		// avoids certain weird bugs
		var others = target.__ractive_instances__;
		if ( others ) { others.forEach( teardown ); }
</P><P>		// make sure we are the only occupants
		if ( !this.enhance ) {
			target.innerHTML = <I>; // TODO is this quicker than removeChild? Initial research inconclusive</I>
		}
	}
</P><P>	var occupants = this.enhance ? toArray( target.childNodes ) : null;
	var promise = render$1( this, target, anchor, occupants );
</P><P>	if ( occupants ) {
		while ( occupants.length ) { target.removeChild( occupants.pop() ); }
	}
</P><P>	return promise;
}
</P><P>var shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ];
</P><P>var completeHook$1 = new Hook( 'complete' );
var resetHook = new Hook( 'reset' );
var renderHook$1 = new Hook( 'render' );
var unrenderHook = new Hook( 'unrender' );
</P><P>function Ractive$reset ( data ) {
	data = data || {};
</P><P>	if ( typeof data !== 'object' ) {
		throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
	}
</P><P>	// TEMP need to tidy this up
	data = dataConfigurator.init( this.constructor, this, { data: data });
</P><P>	var promise = runloop.start( this, true );
</P><P>	// If the root object is wrapped, try and use the wrapper's reset value
	var wrapper = this.viewmodel.wrapper;
	if ( wrapper &amp;&amp; wrapper.reset ) {
		if ( wrapper.reset( data ) === false ) {
			// reset was rejected, we need to replace the object
			this.viewmodel.set( data );
		}
	} else {
		this.viewmodel.set( data );
	}
</P><P>	// reset config items and track if need to rerender
	var changes = config.reset( this );
	var rerender;
</P><P>	var i = changes.length;
	while ( i-- ) {
		if ( shouldRerender.indexOf( changes[i] ) &gt; -1 ) {
			rerender = true;
			break;
		}
	}
</P><P>	if ( rerender ) {
		unrenderHook.fire( this );
		this.fragment.resetTemplate( this.template );
		renderHook$1.fire( this );
		completeHook$1.fire( this );
	}
</P><P>	runloop.end();
</P><P>	resetHook.fire( this, data );
</P><P>	return promise;
}
</P><P>function collect( source, name, attr, dest ) {
	source.forEach( function (item) {
		// queue to rerender if the item is a partial and the current name matches
		if ( item.type === PARTIAL &amp;&amp; ( item.refName ===  name || item.name === name ) ) {
			item.inAttribute = attr;
			dest.push( item );
			return; // go no further
		}
</P><P>		// if it has a fragment, process its items
		if ( item.fragment ) {
			collect( item.fragment.iterations || item.fragment.items, name, attr, dest );
		}
</P><P>		// or if it is itself a fragment, process its items
		else if ( Array.isArray( item.items ) ) {
			collect( item.items, name, attr, dest );
		}
</P><P>		// or if it is a component, step in and process its items
		else if ( item.type === COMPONENT &amp;&amp; item.instance ) {
			// ...unless the partial is shadowed
			if ( item.instance.partials[ name ] ) { return; }
			collect( item.instance.fragment.items, name, attr, dest );
		}
</P><P>		// if the item is an element, process its attributes too
		if ( item.type === ELEMENT ) {
			if ( Array.isArray( item.attributes ) ) {
				collect( item.attributes, name, true, dest );
			}
		}
	});
}
</P><P>function forceResetTemplate ( partial ) {
	partial.forceResetTemplate();
}
</P><P>var resetPartial = function ( name, partial ) {
	var collection = [];
	collect( this.fragment.items, name, false, collection );
</P><P>	var promise = runloop.start( this, true );
</P><P>	this.partials[ name ] = partial;
	collection.forEach( forceResetTemplate );
</P><P>	runloop.end();
</P><P>	return promise;
};
</P><P>// TODO should resetTemplate be asynchronous? i.e. should it be a case
// of outro, update template, intro? I reckon probably not, since that
// could be achieved with unrender-resetTemplate-render. Also, it should
// conceptually be similar to resetPartial, which couldn't be async
</P><P>function Ractive$resetTemplate ( template ) {
	templateConfigurator.init( null, this, { template: template });
</P><P>	var transitionsEnabled = this.transitionsEnabled;
	this.transitionsEnabled = false;
</P><P>	// Is this is a component, we need to set the `shouldDestroy`
	// flag, otherwise it will assume by default that a parent node
	// will be detached, and therefore it doesn't need to bother
	// detaching its own nodes
	var component = this.component;
	if ( component ) { component.shouldDestroy = true; }
	this.unrender();
	if ( component ) { component.shouldDestroy = false; }
</P><P>	var promise = runloop.start();
</P><P>	// remove existing fragment and create new one
	this.fragment.unbind().unrender( true );
</P><P>	this.fragment = new Fragment({
		template: this.template,
		root: this,
		owner: this
	});
</P><P>	var docFrag = createDocumentFragment();
	this.fragment.bind( this.viewmodel ).render( docFrag );
</P><P>	// if this is a component, its el may not be valid, so find a
	// target based on the component container
	if ( component &amp;&amp; !component.external ) {
		this.fragment.findParentNode().insertBefore( docFrag, component.findNextNode() );
	} else {
		this.el.insertBefore( docFrag, this.anchor );
	}
</P><P>	runloop.end();
</P><P>	this.transitionsEnabled = transitionsEnabled;
</P><P>	return promise;
}
</P><P>var reverse = makeArrayMethod( 'reverse' ).path;
</P><P>function Ractive$set ( keypath, value, options ) {
	var ractive = this;
</P><P>	var opts = typeof keypath === 'object' ? value : options;
</P><P>	return set( ractive, build( ractive, keypath, value, opts &amp;&amp; opts.isolated ), opts );
}
</P><P>var shift = makeArrayMethod( 'shift' ).path;
</P><P>var sort = makeArrayMethod( 'sort' ).path;
</P><P>var splice = makeArrayMethod( 'splice' ).path;
</P><P>function Ractive$subtract ( keypath, d, options ) {
	var num = typeof d === 'number' ? -d : -1;
	var opts = typeof d === 'object' ? d : options;
	return add( this, keypath, num, opts );
}
</P><P>function Ractive$toggle ( keypath, options ) {
	if ( typeof keypath !== 'string' ) {
		throw new TypeError( badArguments );
	}
</P><P>	return set( this, gather( this, keypath, null, options &amp;&amp; options.isolated ).map( function (m) { return [ m, !m.get() ]; } ), options );
}
</P><P>function Ractive$toCSS() {
	var cssIds = [ this.cssId ].concat( this.findAllComponents().map( function (c) { return c.cssId; } ) );
	var uniqueCssIds = Object.keys(cssIds.reduce( function ( ids, id ) { return (ids[id] = true, ids); }, {}));
	return getCSS( uniqueCssIds );
}
</P><P>function Ractive$toHTML () {
	return this.fragment.toString( true );
}
</P><P>function toText () {
	return this.fragment.toString( false );
}
</P><P>function Ractive$transition ( name, node, params ) {
</P><P>	if ( node instanceof HTMLElement ) {
		// good to go
	}
	else if ( isObject( node ) ) {
		// omitted, use event node
		params = node;
	}
</P><P>	// if we allow query selector, then it won't work
	// simple params like &quot;fast&quot;
</P><P>	// else if ( typeof node === 'string' ) {
	// 	// query selector
	// 	node = this.find( node )
	// }
</P><P>	node = node || this.event.node;
</P><P>	if ( !node || !node._ractive ) {
		fatal( (&quot;No node was supplied for transition &quot; + name) );
	}
</P><P>	params = params || {};
	var owner = node._ractive.proxy;
	var transition = new Transition({ owner: owner, parentFragment: owner.parentFragment, name: name, params: params });
	transition.bind();
</P><P>	var promise = runloop.start( this, true );
	runloop.registerTransition( transition );
	runloop.end();
</P><P>	promise.then( function () { return transition.unbind(); } );
	return promise;
}
</P><P>function unlink( here ) {
	var promise = runloop.start();
	this.viewmodel.joinAll( splitKeypath( here ), { lastLink: false } ).unlink();
	runloop.end();
	return promise;
}
</P><P>var unrenderHook$1 = new Hook( 'unrender' );
</P><P>function Ractive$unrender () {
	if ( !this.fragment.rendered ) {
		warnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );
		return Promise.resolve();
	}
</P><P>	this.unrendering = true;
	var promise = runloop.start( this, true );
</P><P>	// If this is a component, and the component isn't marked for destruction,
	// don't detach nodes from the DOM unnecessarily
	var shouldDestroy = !this.component || ( this.component.anchor || {} ).shouldDestroy || this.component.shouldDestroy || this.shouldDestroy;
	this.fragment.unrender( shouldDestroy );
	if ( shouldDestroy ) { this.destroyed = true; }
</P><P>	removeFromArray( this.el.__ractive_instances__, this );
</P><P>	unrenderHook$1.fire( this );
</P><P>	runloop.end();
	this.unrendering = false;
</P><P>	return promise;
}
</P><P>var unshift = makeArrayMethod( 'unshift' ).path;
</P><P>function Ractive$updateModel ( keypath, cascade ) {
	var promise = runloop.start( this, true );
</P><P>	if ( !keypath ) {
		this.viewmodel.updateFromBindings( true );
	} else {
		this.viewmodel.joinAll( splitKeypath( keypath ) ).updateFromBindings( cascade !== false );
	}
</P><P>	runloop.end();
</P><P>	return promise;
}
</P><P>var RactiveProto = {
	add: Ractive$add,
	animate: Ractive$animate,
	attachChild: attachChild,
	detach: Ractive$detach,
	detachChild: detachChild,
	find: Ractive$find,
	findAll: Ractive$findAll,
	findAllComponents: Ractive$findAllComponents,
	findComponent: Ractive$findComponent,
	findContainer: Ractive$findContainer,
	findParent: Ractive$findParent,
	fire: Ractive$fire,
	get: Ractive$get,
	getContext: getContext$1,
	getNodeInfo: getNodeInfo$$1,
	insert: Ractive$insert,
	link: link,
	observe: observe,
	observeOnce: observeOnce,
	off: Ractive$off,
	on: Ractive$on,
	once: Ractive$once,
	pop: pop,
	push: push,
	readLink: readLink,
	render: Ractive$render,
	reset: Ractive$reset,
	resetPartial: resetPartial,
	resetTemplate: Ractive$resetTemplate,
	reverse: reverse,
	set: Ractive$set,
	shift: shift,
	sort: sort,
	splice: splice,
	subtract: Ractive$subtract,
	teardown: Ractive$teardown,
	toggle: Ractive$toggle,
	toCSS: Ractive$toCSS,
	toCss: Ractive$toCSS,
	toHTML: Ractive$toHTML,
	toHtml: Ractive$toHTML,
	toText: toText,
	transition: Ractive$transition,
	unlink: unlink,
	unrender: Ractive$unrender,
	unshift: unshift,
	update: Ractive$update,
	updateModel: Ractive$updateModel
};
</P><P>var callsSuper = /super\s\(|\.call\s*\(\s*this/;
</P><P>function extend () {
	var options = [], len = arguments.length;
	while ( len-- ) options[ len ] = arguments[ len ];
</P><P>	if( !options.length ) {
		return extendOne( this );
	} else {
		return options.reduce( extendOne, this );
	}
}
</P><P>function extendWith ( Class, options ) {
	if ( options === void 0 ) options = {};
</P><P>	return extendOne( this, options, Class );
}
</P><P>function extendOne ( Parent, options, Target ) {
	if ( options === void 0 ) options = {};
</P><P>	var proto;
	var Child = typeof Target === 'function' &amp;&amp; Target;
</P><P>	if ( options.prototype instanceof Ractive ) {
		throw new Error( &quot;Ractive no longer supports multiple inheritance.&quot; );
	}
</P><P>	if ( Child ) {
		if ( !( Child.prototype instanceof Parent ) ) {
			throw new Error( &quot;Only classes that inherit the appropriate prototype may be used with extend&quot; );
		}
		if ( !callsSuper.test( Child.toString() ) ) {
			throw new Error( &quot;Only classes that call super in their constructor may be used with extend&quot; );
		}
</P><P>		proto = Child.prototype;
	} else {
		Child = function ( options ) {
			if ( !( this instanceof Child ) ) { return new Child( options ); }
</P><P>			construct( this, options || {} );
			initialise( this, options || {}, {} );
		};
</P><P>		proto = Object.create( Parent.prototype );
		proto.constructor = Child;
</P><P>		Child.prototype = proto;
	}
</P><P>	// Static properties
	Object.defineProperties( Child, {
		// alias prototype as defaults
		defaults: { value: proto },
</P><P>		// extendable
		extend: { value: extend, writable: true, configurable: true },
		extendClass: { value: extendWith, writable: true, configurable: true },
</P><P>		// Parent - for IE8, can't use Object.getPrototypeOf
		_Parent: { value: Parent }
	});
</P><P>	// extend configuration
	config.extend( Parent, proto, options );
</P><P>	// store event and observer registries on the constructor when extending
	Child._on = ( Parent._on || [] ).concat( toPairs( options.on ) );
	Child._observe = ( Parent._observe || [] ).concat( toPairs( options.observe ) );
</P><P>	// attribute defs are not inherited, but they need to be stored
	if ( options.attributes ) {
		var attrs;
</P><P>		// allow an array of optional props or an object with arrays for optional and required props
		if ( Array.isArray( options.attributes ) ) {
			attrs = { optional: options.attributes, required: [] };
		} else {
			attrs = options.attributes;
		}
</P><P>		// make sure the requisite keys actually store arrays
		if ( !Array.isArray( attrs.required ) ) { attrs.required = []; }
		if ( !Array.isArray( attrs.optional ) ) { attrs.optional = []; }
</P><P>		Child.attributes = attrs;
	}
</P><P>	dataConfigurator.extend( Parent, proto, options );
</P><P>	if ( options.computed ) {
		proto.computed = Object.assign( Object.create( Parent.prototype.computed ), options.computed );
	}
</P><P>	return Child;
}
</P><P>function joinKeys () {
	var keys = [], len = arguments.length;
	while ( len-- ) keys[ len ] = arguments[ len ];
</P><P>	return keys.map( escapeKey ).join( '.' );
}
</P><P>function splitKeypath$1 ( keypath ) {
	return splitKeypath( keypath ).map( unescapeKey );
}
</P><P>function findPlugin(name, type, instance) {
	return findInViewHierarchy(type, instance, name);
}
</P><P>function Ractive ( options ) {
	if ( !( this instanceof Ractive ) ) { return new Ractive( options ); }
</P><P>	construct( this, options || {} );
	initialise( this, options || {}, {} );
}
</P><P>// check to see if we're being asked to force Ractive as a global for some weird environments
if ( win &amp;&amp; !win.Ractive ) {
	var opts = <I>;</I>
	var script = document.currentScript || document.querySelector( 'script[data-ractive-options]' );
</P><P>	if ( script ) { opts = script.getAttribute( 'data-ractive-options' ) || <I>; }</I></P><P>	if ( ~opts.indexOf( 'ForceGlobal' ) ) { win.Ractive = Ractive; }
}
</P><P>Object.assign( Ractive.prototype, RactiveProto, defaults );
Ractive.prototype.constructor = Ractive;
</P><P>// alias prototype as `defaults`
Ractive.defaults = Ractive.prototype;
</P><P>// share defaults with the parser
shared.defaults = Ractive.defaults;
shared.Ractive = Ractive;
</P><P>// static properties
Object.defineProperties( Ractive, {
</P><P>	// debug flag
	DEBUG:            { writable: true, value: true },
	DEBUG_PROMISES:   { writable: true, value: true },
</P><P>	// static methods:
	extend:           { value: extend },
	extendWith:       { value: extendWith },
	escapeKey:        { value: escapeKey },
	getContext:       { value: getContext$2 },
	getNodeInfo:      { value: getNodeInfo$1 },
	joinKeys:         { value: joinKeys },
	parse:            { value: parse },
	splitKeypath:     { value: splitKeypath$1 },
	unescapeKey:      { value: unescapeKey },
	getCSS:           { value: getCSS },
	normaliseKeypath: { value: normalise },
	findPlugin:       { value: findPlugin },
	evalObjectString: { value: parseJSON },
</P><P>	// support
	enhance:          { writable: true, value: false },
	svg:              { value: svg },
</P><P>	// version
	VERSION:          { value: '0.9.0' },
</P><P>	// plugins
	adaptors:         { writable: true, value: {} },
	components:       { writable: true, value: {} },
	decorators:       { writable: true, value: {} },
	easing:           { writable: true, value: easing },
	events:           { writable: true, value: {} },
	interpolators:    { writable: true, value: interpolators },
	partials:         { writable: true, value: {} },
	transitions:      { writable: true, value: {} }
});
</P><P>return Ractive;
</P><P>})));
//# sourceMappingURL=ractive.js.map
&lt;/script&gt;</P><PRE>&lt;script&gt;// CodeMirror, copyright (c) by Marijn Haverbeke and others
</PRE><P>// Distributed under an MIT license: <A rel="nofollow" class="external free" href="http://codemirror.net/LICENSE">http://codemirror.net/LICENSE</A></P><P>// This is CodeMirror (<A rel="nofollow" class="external free" href="http://codemirror.net">http://codemirror.net</A>), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at <A rel="nofollow" class="external free" href="http://marijnhaverbeke.nl/blog/#cm-internals">http://marijnhaverbeke.nl/blog/#cm-internals</A> .
</P><P>(function (global, factory) {
</P><PRE> typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() :
 typeof define === 'function' &amp;&amp; define.amd ? define(factory) :
 (global.CodeMirror = factory());
</PRE><P>}(this, (function () { 'use strict';
</P><P>// Kludges for bugs and behavior differences that can't be feature
// detected are enabled based on userAgent etc sniffing.
var userAgent = navigator.userAgent
var platform = navigator.platform
</P><P>var gecko = /gecko\/\d/i.test(userAgent)
var ie_upto10 = /MSIE \d/.test(userAgent)
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent)
var edge = /Edge\/(\d+)/.exec(userAgent)
var ie = ie_upto10 || ie_11up || edge
var ie_version = ie &amp;&amp; (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1])
var webkit = !edge &amp;&amp; /WebKit\//.test(userAgent)
var qtwebkit = webkit &amp;&amp; /Qt\/\d+\.\d+/.test(userAgent)
var chrome = !edge &amp;&amp; /Chrome\//.test(userAgent)
var presto = /Opera\//.test(userAgent)
var safari = /Apple Computer/.test(navigator.vendor)
var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent)
var phantom = /PhantomJS/.test(userAgent)
</P><P>var ios = !edge &amp;&amp; /AppleWebKit/.test(userAgent) &amp;&amp; /Mobile\/\w+/.test(userAgent)
// This is woefully incomplete. Suggestions for alternative methods welcome.
var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent)
var mac = ios || /Mac/.test(platform)
var chromeOS = /\bCrOS\b/.test(userAgent)
var windows = /win/i.test(platform)
</P><P>var presto_version = presto &amp;&amp; userAgent.match(/Version\/(\d*\.\d*)/)
if (presto_version) { presto_version = Number(presto_version[1]) }
if (presto_version &amp;&amp; presto_version &gt;= 15) { presto = false; webkit = true }
// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
var flipCtrlCmd = mac &amp;&amp; (qtwebkit || presto &amp;&amp; (presto_version == null || presto_version &lt; 12.11))
var captureRightClick = gecko || (ie &amp;&amp; ie_version &gt;= 9)
</P><P>function classTest(cls) { return new RegExp(&quot;(^|\\s)&quot; + cls + &quot;(?:$|\\s)\\s*&quot;) }
</P><P>var rmClass = function(node, cls) {
</P><PRE> var current = node.className
 var match = classTest(cls).exec(current)
 if (match) {
   var after = current.slice(match.index + match[0].length)
   node.className = current.slice(0, match.index) + (after ? match[1] + after : &quot;&quot;)
 }
</PRE><P>}
</P><P>function removeChildren(e) {
</P><PRE> for (var count = e.childNodes.length; count &gt; 0; --count)
   { e.removeChild(e.firstChild) }
 return e
</PRE><P>}
</P><P>function removeChildrenAndAdd(parent, e) {
</P><PRE> return removeChildren(parent).appendChild(e)
</PRE><P>}
</P><P>function elt(tag, content, className, style) {
</P><PRE> var e = document.createElement(tag)
 if (className) { e.className = className }
 if (style) { e.style.cssText = style }
 if (typeof content == &quot;string&quot;) { e.appendChild(document.createTextNode(content)) }
 else if (content) { for (var i = 0; i &lt; content.length; ++i) { e.appendChild(content[i]) } }
 return e
</PRE><P>}
</P><P>var range
if (document.createRange) { range = function(node, start, end, endNode) {
</P><PRE> var r = document.createRange()
 r.setEnd(endNode || node, end)
 r.setStart(node, start)
 return r
</PRE><P>} }
else { range = function(node, start, end) {
</P><PRE> var r = document.body.createTextRange()
 try { r.moveToElementText(node.parentNode) }
 catch(e) { return r }
 r.collapse(true)
 r.moveEnd(&quot;character&quot;, end)
 r.moveStart(&quot;character&quot;, start)
 return r
</PRE><P>} }
</P><P>function contains(parent, child) {
</P><PRE> if (child.nodeType == 3) // Android browser always returns false when child is a textnode
   { child = child.parentNode }
 if (parent.contains)
   { return parent.contains(child) }
 do {
   if (child.nodeType == 11) { child = child.host }
   if (child == parent) { return true }
 } while (child = child.parentNode)
</PRE><P>}
</P><P>function activeElt() {
</P><PRE> // IE and Edge may throw an &quot;Unspecified Error&quot; when accessing document.activeElement.
 // IE &lt; 10 will throw when accessed while the page is loading or in an iframe.
 // IE &gt; 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
 var activeElement
 try {
   activeElement = document.activeElement
 } catch(e) {
   activeElement = document.body || null
 }
 while (activeElement &amp;&amp; activeElement.root &amp;&amp; activeElement.root.activeElement)
   { activeElement = activeElement.root.activeElement }
 return activeElement
</PRE><P>}
</P><P>function addClass(node, cls) {
</P><PRE> var current = node.className
 if (!classTest(cls).test(current)) { node.className += (current ? &quot; &quot; : &quot;&quot;) + cls }
</PRE><P>}
function joinClasses(a, b) {
</P><PRE> var as = a.split(&quot; &quot;)
 for (var i = 0; i &lt; as.length; i++)
   { if (as[i] &amp;&amp; !classTest(as[i]).test(b)) { b += &quot; &quot; + as[i] } }
 return b
</PRE><P>}
</P><P>var selectInput = function(node) { node.select() }
if (ios) // Mobile Safari apparently has a bug where select() is broken.
</P><PRE> { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length } }
</PRE><P>else if (ie) // Suppress mysterious IE10 errors
</P><PRE> { selectInput = function(node) { try { node.select() } catch(_e) {} } }
</PRE><P>function bind(f) {
</P><PRE> var args = Array.prototype.slice.call(arguments, 1)
 return function(){return f.apply(null, args)}
</PRE><P>}
</P><P>function copyObj(obj, target, overwrite) {
</P><PRE> if (!target) { target = {} }
 for (var prop in obj)
   { if (obj.hasOwnProperty(prop) &amp;&amp; (overwrite !== false || !target.hasOwnProperty(prop)))
     { target[prop] = obj[prop] } }
 return target
</PRE><P>}
</P><P>// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
function countColumn(string, end, tabSize, startIndex, startValue) {
</P><PRE> if (end == null) {
   end = string.search(/[^\s\u00a0]/)
   if (end == -1) { end = string.length }
 }
 for (var i = startIndex || 0, n = startValue || 0;;) {
   var nextTab = string.indexOf(&quot;\t&quot;, i)
   if (nextTab &lt; 0 || nextTab &gt;= end)
     { return n + (end - i) }
   n += nextTab - i
   n += tabSize - (n % tabSize)
   i = nextTab + 1
 }
</PRE><P>}
</P><P>var Delayed = function() {this.id = null};
Delayed.prototype.set = function (ms, f) {
</P><PRE> clearTimeout(this.id)
 this.id = setTimeout(f, ms)
</PRE><P>};
</P><P>function indexOf(array, elt) {
</P><PRE> for (var i = 0; i &lt; array.length; ++i)
   { if (array[i] == elt) { return i } }
 return -1
</PRE><P>}
</P><P>// Number of pixels added to scroller and sizer to hide scrollbar
var scrollerGap = 30
</P><P>// Returned or thrown by various protocols to signal 'I'm not
// handling this'.
var Pass = {toString: function(){return &quot;CodeMirror.Pass&quot;}}
</P><P>// Reused option objects for setSelection &amp; friends
var sel_dontScroll = {scroll: false};
var sel_mouse = {origin: &quot;*mouse&quot;};
var sel_move = {origin: &quot;+move&quot;};
// The inverse of countColumn -- find the offset that corresponds to
// a particular column.
function findColumn(string, goal, tabSize) {
</P><PRE> for (var pos = 0, col = 0;;) {
   var nextTab = string.indexOf(&quot;\t&quot;, pos)
   if (nextTab == -1) { nextTab = string.length }
   var skipped = nextTab - pos
   if (nextTab == string.length || col + skipped &gt;= goal)
     { return pos + Math.min(skipped, goal - col) }
   col += nextTab - pos
   col += tabSize - (col % tabSize)
   pos = nextTab + 1
   if (col &gt;= goal) { return pos }
 }
</PRE><P>}
</P><P>var spaceStrs = [&quot;&quot;]
function spaceStr(n) {
</P><PRE> while (spaceStrs.length &lt;= n)
   { spaceStrs.push(lst(spaceStrs) + &quot; &quot;) }
 return spaceStrs[n]
</PRE><P>}
</P><P>function lst(arr) { return arr[arr.length-1] }
</P><P>function map(array, f) {
</P><PRE> var out = []
 for (var i = 0; i &lt; array.length; i++) { out[i] = f(array[i], i) }
 return out
</PRE><P>}
</P><P>function insertSorted(array, value, score) {
</P><PRE> var pos = 0, priority = score(value)
 while (pos &lt; array.length &amp;&amp; score(array[pos]) &lt;= priority) { pos++ }
 array.splice(pos, 0, value)
</PRE><P>}
</P><P>function nothing() {}
</P><P>function createObj(base, props) {
</P><PRE> var inst
 if (Object.create) {
   inst = Object.create(base)
 } else {
   nothing.prototype = base
   inst = new nothing()
 }
 if (props) { copyObj(props, inst) }
 return inst
</PRE><P>}
</P><P>var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/
function isWordCharBasic(ch) {
</P><PRE> return /\w/.test(ch) || ch &gt; &quot;\x80&quot; &amp;&amp;
   (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
</PRE><P>}
function isWordChar(ch, helper) {
</P><PRE> if (!helper) { return isWordCharBasic(ch) }
 if (helper.source.indexOf(&quot;\\w&quot;) &gt; -1 &amp;&amp; isWordCharBasic(ch)) { return true }
 return helper.test(ch)
</PRE><P>}
</P><P>function isEmpty(obj) {
</P><PRE> for (var n in obj) { if (obj.hasOwnProperty(n) &amp;&amp; obj[n]) { return false } }
 return true
</PRE><P>}
</P><P>// Extending unicode characters. A series of a non-extending char +
// any number of extending chars is treated as a single unit as far
// as editing and measuring is concerned. This is not fully correct,
// since some scripts/fonts/browsers also treat other configurations
// of code points as a group.
var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/
function isExtendingChar(ch) { return ch.charCodeAt(0) &gt;= 768 &amp;&amp; extendingChars.test(ch) }
</P><P>// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
function skipExtendingChars(str, pos, dir) {
</P><PRE> while ((dir &lt; 0 ? pos &gt; 0 : pos &lt; str.length) &amp;&amp; isExtendingChar(str.charAt(pos))) { pos += dir }
 return pos
</PRE><P>}
</P><P>// Returns the value from the range [`from`; `to`] that satisfies
// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.
function findFirst(pred, from, to) {
</P><PRE> for (;;) {
   if (Math.abs(from - to) &lt;= 1) { return pred(from) ? from : to }
   var mid = Math.floor((from + to) / 2)
   if (pred(mid)) { to = mid }
   else { from = mid }
 }
</PRE><P>}
</P><P>// The display handles the DOM integration, both for input reading
// and content drawing. It holds references to DOM nodes and
// display-related state.
</P><P>function Display(place, doc, input) {
</P><PRE> var d = this
 this.input = input
</PRE><PRE> // Covers bottom-right square when both scrollbars are present.
 d.scrollbarFiller = elt(&quot;div&quot;, null, &quot;CodeMirror-scrollbar-filler&quot;)
 d.scrollbarFiller.setAttribute(&quot;cm-not-content&quot;, &quot;true&quot;)
 // Covers bottom of gutter when coverGutterNextToScrollbar is on
 // and h scrollbar is present.
 d.gutterFiller = elt(&quot;div&quot;, null, &quot;CodeMirror-gutter-filler&quot;)
 d.gutterFiller.setAttribute(&quot;cm-not-content&quot;, &quot;true&quot;)
 // Will contain the actual code, positioned to cover the viewport.
 d.lineDiv = elt(&quot;div&quot;, null, &quot;CodeMirror-code&quot;)
 // Elements are added to these to represent selection and cursors.
 d.selectionDiv = elt(&quot;div&quot;, null, null, &quot;position: relative; z-index: 1&quot;)
 d.cursorDiv = elt(&quot;div&quot;, null, &quot;CodeMirror-cursors&quot;)
 // A visibility: hidden element used to find the size of things.
 d.measure = elt(&quot;div&quot;, null, &quot;CodeMirror-measure&quot;)
 // When lines outside of the viewport are measured, they are drawn in this.
 d.lineMeasure = elt(&quot;div&quot;, null, &quot;CodeMirror-measure&quot;)
 // Wraps everything that needs to exist inside the vertically-padded coordinate system
 d.lineSpace = elt(&quot;div&quot;, [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                   null, &quot;position: relative; outline: none&quot;)
 // Moved around its parent to cover visible view.
 d.mover = elt(&quot;div&quot;, [elt(&quot;div&quot;, [d.lineSpace], &quot;CodeMirror-lines&quot;)], null, &quot;position: relative&quot;)
 // Set to the height of the document, allowing scrolling.
 d.sizer = elt(&quot;div&quot;, [d.mover], &quot;CodeMirror-sizer&quot;)
 d.sizerWidth = null
 // Behavior of elts with overflow: auto and padding is
 // inconsistent across browsers. This is used to ensure the
 // scrollable area is big enough.
 d.heightForcer = elt(&quot;div&quot;, null, null, &quot;position: absolute; height: &quot; + scrollerGap + &quot;px; width: 1px;&quot;)
 // Will contain the gutters, if any.
 d.gutters = elt(&quot;div&quot;, null, &quot;CodeMirror-gutters&quot;)
 d.lineGutter = null
 // Actual scrollable element.
 d.scroller = elt(&quot;div&quot;, [d.sizer, d.heightForcer, d.gutters], &quot;CodeMirror-scroll&quot;)
 d.scroller.setAttribute(&quot;tabIndex&quot;, &quot;-1&quot;)
 // The element in which the editor lives.
 d.wrapper = elt(&quot;div&quot;, [d.scrollbarFiller, d.gutterFiller, d.scroller], &quot;CodeMirror&quot;)
</PRE><PRE> // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
 if (ie &amp;&amp; ie_version &lt; 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0 }
 if (!webkit &amp;&amp; !(gecko &amp;&amp; mobile)) { d.scroller.draggable = true }
</PRE><PRE> if (place) {
   if (place.appendChild) { place.appendChild(d.wrapper) }
   else { place(d.wrapper) }
 }
</PRE><PRE> // Current rendered range (may be bigger than the view window).
 d.viewFrom = d.viewTo = doc.first
 d.reportedViewFrom = d.reportedViewTo = doc.first
 // Information about the rendered lines.
 d.view = []
 d.renderedView = null
 // Holds info about a single rendered line when it was rendered
 // for measurement, while not in view.
 d.externalMeasured = null
 // Empty space (in pixels) above the view
 d.viewOffset = 0
 d.lastWrapHeight = d.lastWrapWidth = 0
 d.updateLineNumbers = null
</PRE><PRE> d.nativeBarWidth = d.barHeight = d.barWidth = 0
 d.scrollbarsClipped = false
</PRE><PRE> // Used to only resize the line number gutter when necessary (when
 // the amount of lines crosses a boundary that makes its width change)
 d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null
 // Set to true when a non-horizontal-scrolling line widget is
 // added. As an optimization, line widget aligning is skipped when
 // this is false.
 d.alignWidgets = false
</PRE><PRE> d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null
</PRE><PRE> // Tracks the maximum line length so that the horizontal scrollbar
 // can be kept static when scrolling.
 d.maxLine = null
 d.maxLineLength = 0
 d.maxLineChanged = false
</PRE><PRE> // Used for measuring wheel scrolling granularity
 d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null
</PRE><PRE> // True when shift is held down.
 d.shift = false
</PRE><PRE> // Used to track whether anything happened since the context menu
 // was opened.
 d.selForContextMenu = null
</PRE><PRE> d.activeTouch = null
</PRE><PRE> input.init(d)
</PRE><P>}
</P><P>// Find the line object corresponding to the given line number.
function getLine(doc, n) {
</P><PRE> n -= doc.first
 if (n &lt; 0 || n &gt;= doc.size) { throw new Error(&quot;There is no line &quot; + (n + doc.first) + &quot; in the document.&quot;) }
 var chunk = doc
 while (!chunk.lines) {
   for (var i = 0;; ++i) {
     var child = chunk.children[i], sz = child.chunkSize()
     if (n &lt; sz) { chunk = child; break }
     n -= sz
   }
 }
 return chunk.lines[n]
</PRE><P>}
</P><P>// Get the part of a document between two positions, as an array of
// strings.
function getBetween(doc, start, end) {
</P><PRE> var out = [], n = start.line
 doc.iter(start.line, end.line + 1, function (line) {
   var text = line.text
   if (n == end.line) { text = text.slice(0, end.ch) }
   if (n == start.line) { text = text.slice(start.ch) }
   out.push(text)
   ++n
 })
 return out
</PRE><P>}
// Get the lines between from and to, as array of strings.
function getLines(doc, from, to) {
</P><PRE> var out = []
 doc.iter(from, to, function (line) { out.push(line.text) }) // iter aborts when callback returns truthy value
 return out
</PRE><P>}
</P><P>// Update the height of a line, propagating the height change
// upwards to parent nodes.
function updateLineHeight(line, height) {
</P><PRE> var diff = height - line.height
 if (diff) { for (var n = line; n; n = n.parent) { n.height += diff } }
</PRE><P>}
</P><P>// Given a line object, find its line number by walking up through
// its parent links.
function lineNo(line) {
</P><PRE> if (line.parent == null) { return null }
 var cur = line.parent, no = indexOf(cur.lines, line)
 for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
   for (var i = 0;; ++i) {
     if (chunk.children[i] == cur) { break }
     no += chunk.children[i].chunkSize()
   }
 }
 return no + cur.first
</PRE><P>}
</P><P>// Find the line at the given vertical position, using the height
// information in the document tree.
function lineAtHeight(chunk, h) {
</P><PRE> var n = chunk.first
 outer: do {
   for (var i$1 = 0; i$1 &lt; chunk.children.length; ++i$1) {
     var child = chunk.children[i$1], ch = child.height
     if (h &lt; ch) { chunk = child; continue outer }
     h -= ch
     n += child.chunkSize()
   }
   return n
 } while (!chunk.lines)
 var i = 0
 for (; i &lt; chunk.lines.length; ++i) {
   var line = chunk.lines[i], lh = line.height
   if (h &lt; lh) { break }
   h -= lh
 }
 return n + i
</PRE><P>}
</P><P>function isLine(doc, l) {return l &gt;= doc.first &amp;&amp; l &lt; doc.first + doc.size}
</P><P>function lineNumberFor(options, i) {
</P><PRE> return String(options.lineNumberFormatter(i + options.firstLineNumber))
</PRE><P>}
</P><P>// A Pos instance represents a position within the text.
function Pos(line, ch, sticky) {
</P><PRE> if ( sticky === void 0 ) sticky = null;
</PRE><PRE> if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
 this.line = line
 this.ch = ch
 this.sticky = sticky
</PRE><P>}
</P><P>// Compare two positions, return 0 if they are the same, a negative
// number when a is less, and a positive number otherwise.
function cmp(a, b) { return a.line - b.line || a.ch - b.ch }
</P><P>function equalCursorPos(a, b) { return a.sticky == b.sticky &amp;&amp; cmp(a, b) == 0 }
</P><P>function copyPos(x) {return Pos(x.line, x.ch)}
function maxPos(a, b) { return cmp(a, b) &lt; 0 ? b : a }
function minPos(a, b) { return cmp(a, b) &lt; 0 ? a : b }
</P><P>// Most of the external API clips given positions to make sure they
// actually exist within the document.
function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
function clipPos(doc, pos) {
</P><PRE> if (pos.line &lt; doc.first) { return Pos(doc.first, 0) }
 var last = doc.first + doc.size - 1
 if (pos.line &gt; last) { return Pos(last, getLine(doc, last).text.length) }
 return clipToLen(pos, getLine(doc, pos.line).text.length)
</PRE><P>}
function clipToLen(pos, linelen) {
</P><PRE> var ch = pos.ch
 if (ch == null || ch &gt; linelen) { return Pos(pos.line, linelen) }
 else if (ch &lt; 0) { return Pos(pos.line, 0) }
 else { return pos }
</PRE><P>}
function clipPosArray(doc, array) {
</P><PRE> var out = []
 for (var i = 0; i &lt; array.length; i++) { out[i] = clipPos(doc, array[i]) }
 return out
</PRE><P>}
</P><P>// Optimize some code when these features are not used.
var sawReadOnlySpans = false;
var sawCollapsedSpans = false;
function seeReadOnlySpans() {
</P><PRE> sawReadOnlySpans = true
</PRE><P>}
</P><P>function seeCollapsedSpans() {
</P><PRE> sawCollapsedSpans = true
</PRE><P>}
</P><P>// TEXTMARKER SPANS
</P><P>function MarkedSpan(marker, from, to) {
</P><PRE> this.marker = marker
 this.from = from; this.to = to
</PRE><P>}
</P><P>// Search an array of spans for a span matching the given marker.
function getMarkedSpanFor(spans, marker) {
</P><PRE> if (spans) { for (var i = 0; i &lt; spans.length; ++i) {
   var span = spans[i]
   if (span.marker == marker) { return span }
 } }
</PRE><P>}
// Remove a span from an array, returning undefined if no spans are
// left (we don't store arrays for lines without spans).
function removeMarkedSpan(spans, span) {
</P><PRE> var r
 for (var i = 0; i &lt; spans.length; ++i)
   { if (spans[i] != span) { (r || (r = [])).push(spans[i]) } }
 return r
</PRE><P>}
// Add a span to a line.
function addMarkedSpan(line, span) {
</P><PRE> line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span]
 span.marker.attachLine(line)
</PRE><P>}
</P><P>// Used for the algorithm that adjusts markers for a change in the
// document. These functions cut an array of spans at a given
// character position, returning an array of remaining chunks (or
// undefined if nothing remains).
function markedSpansBefore(old, startCh, isInsert) {
</P><PRE> var nw
 if (old) { for (var i = 0; i &lt; old.length; ++i) {
   var span = old[i], marker = span.marker
   var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from &lt;= startCh : span.from &lt; startCh)
   if (startsBefore || span.from == startCh &amp;&amp; marker.type == &quot;bookmark&quot; &amp;&amp; (!isInsert || !span.marker.insertLeft)) {
     var endsAfter = span.to == null || (marker.inclusiveRight ? span.to &gt;= startCh : span.to &gt; startCh)
     ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))
   }
 } }
 return nw
</PRE><P>}
function markedSpansAfter(old, endCh, isInsert) {
</P><PRE> var nw
 if (old) { for (var i = 0; i &lt; old.length; ++i) {
   var span = old[i], marker = span.marker
   var endsAfter = span.to == null || (marker.inclusiveRight ? span.to &gt;= endCh : span.to &gt; endCh)
   if (endsAfter || span.from == endCh &amp;&amp; marker.type == &quot;bookmark&quot; &amp;&amp; (!isInsert || span.marker.insertLeft)) {
     var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from &lt;= endCh : span.from &lt; endCh)
     ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                           span.to == null ? null : span.to - endCh))
   }
 } }
 return nw
</PRE><P>}
</P><P>// Given a change object, compute the new set of marker spans that
// cover the line in which the change took place. Removes spans
// entirely within the change, reconnects spans belonging to the
// same marker that appear on both sides of the change, and cuts off
// spans partially within the change. Returns an array of span
// arrays with one element for each line in (after) the change.
function stretchSpansOverChange(doc, change) {
</P><PRE> if (change.full) { return null }
 var oldFirst = isLine(doc, change.from.line) &amp;&amp; getLine(doc, change.from.line).markedSpans
 var oldLast = isLine(doc, change.to.line) &amp;&amp; getLine(doc, change.to.line).markedSpans
 if (!oldFirst &amp;&amp; !oldLast) { return null }
</PRE><PRE> var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0
 // Get the spans that 'stick out' on both sides
 var first = markedSpansBefore(oldFirst, startCh, isInsert)
 var last = markedSpansAfter(oldLast, endCh, isInsert)
</PRE><PRE> // Next, merge those two ends
 var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0)
 if (first) {
   // Fix up .to properties of first
   for (var i = 0; i &lt; first.length; ++i) {
     var span = first[i]
     if (span.to == null) {
       var found = getMarkedSpanFor(last, span.marker)
       if (!found) { span.to = startCh }
       else if (sameLine) { span.to = found.to == null ? null : found.to + offset }
     }
   }
 }
 if (last) {
   // Fix up .from in last (or move them into first in case of sameLine)
   for (var i$1 = 0; i$1 &lt; last.length; ++i$1) {
     var span$1 = last[i$1]
     if (span$1.to != null) { span$1.to += offset }
     if (span$1.from == null) {
       var found$1 = getMarkedSpanFor(first, span$1.marker)
       if (!found$1) {
         span$1.from = offset
         if (sameLine) { (first || (first = [])).push(span$1) }
       }
     } else {
       span$1.from += offset
       if (sameLine) { (first || (first = [])).push(span$1) }
     }
   }
 }
 // Make sure we didn't create any zero-length spans
 if (first) { first = clearEmptySpans(first) }
 if (last &amp;&amp; last != first) { last = clearEmptySpans(last) }
</PRE><PRE> var newMarkers = [first]
 if (!sameLine) {
   // Fill gap with whole-line-spans
   var gap = change.text.length - 2, gapMarkers
   if (gap &gt; 0 &amp;&amp; first)
     { for (var i$2 = 0; i$2 &lt; first.length; ++i$2)
       { if (first[i$2].to == null)
         { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)) } } }
   for (var i$3 = 0; i$3 &lt; gap; ++i$3)
     { newMarkers.push(gapMarkers) }
   newMarkers.push(last)
 }
 return newMarkers
</PRE><P>}
</P><P>// Remove spans that are empty and don't have a clearWhenEmpty
// option of false.
function clearEmptySpans(spans) {
</P><PRE> for (var i = 0; i &lt; spans.length; ++i) {
   var span = spans[i]
   if (span.from != null &amp;&amp; span.from == span.to &amp;&amp; span.marker.clearWhenEmpty !== false)
     { spans.splice(i--, 1) }
 }
 if (!spans.length) { return null }
 return spans
</PRE><P>}
</P><P>// Used to 'clip' out readOnly ranges when making a change.
function removeReadOnlyRanges(doc, from, to) {
</P><PRE> var markers = null
 doc.iter(from.line, to.line + 1, function (line) {
   if (line.markedSpans) { for (var i = 0; i &lt; line.markedSpans.length; ++i) {
     var mark = line.markedSpans[i].marker
     if (mark.readOnly &amp;&amp; (!markers || indexOf(markers, mark) == -1))
       { (markers || (markers = [])).push(mark) }
   } }
 })
 if (!markers) { return null }
 var parts = [{from: from, to: to}]
 for (var i = 0; i &lt; markers.length; ++i) {
   var mk = markers[i], m = mk.find(0)
   for (var j = 0; j &lt; parts.length; ++j) {
     var p = parts[j]
     if (cmp(p.to, m.from) &lt; 0 || cmp(p.from, m.to) &gt; 0) { continue }
     var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to)
     if (dfrom &lt; 0 || !mk.inclusiveLeft &amp;&amp; !dfrom)
       { newParts.push({from: p.from, to: m.from}) }
     if (dto &gt; 0 || !mk.inclusiveRight &amp;&amp; !dto)
       { newParts.push({from: m.to, to: p.to}) }
     parts.splice.apply(parts, newParts)
     j += newParts.length - 3
   }
 }
 return parts
</PRE><P>}
</P><P>// Connect or disconnect spans from a line.
function detachMarkedSpans(line) {
</P><PRE> var spans = line.markedSpans
 if (!spans) { return }
 for (var i = 0; i &lt; spans.length; ++i)
   { spans[i].marker.detachLine(line) }
 line.markedSpans = null
</PRE><P>}
function attachMarkedSpans(line, spans) {
</P><PRE> if (!spans) { return }
 for (var i = 0; i &lt; spans.length; ++i)
   { spans[i].marker.attachLine(line) }
 line.markedSpans = spans
</PRE><P>}
</P><P>// Helpers used when computing which overlapping collapsed span
// counts as the larger one.
function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }
</P><P>// Returns a number indicating which of two overlapping collapsed
// spans is larger (and thus includes the other). Falls back to
// comparing ids when the spans cover exactly the same range.
function compareCollapsedMarkers(a, b) {
</P><PRE> var lenDiff = a.lines.length - b.lines.length
 if (lenDiff != 0) { return lenDiff }
 var aPos = a.find(), bPos = b.find()
 var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b)
 if (fromCmp) { return -fromCmp }
 var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b)
 if (toCmp) { return toCmp }
 return b.id - a.id
</PRE><P>}
</P><P>// Find out whether a line ends or starts in a collapsed span. If
// so, return the marker for that span.
function collapsedSpanAtSide(line, start) {
</P><PRE> var sps = sawCollapsedSpans &amp;&amp; line.markedSpans, found
 if (sps) { for (var sp = (void 0), i = 0; i &lt; sps.length; ++i) {
   sp = sps[i]
   if (sp.marker.collapsed &amp;&amp; (start ? sp.from : sp.to) == null &amp;&amp;
       (!found || compareCollapsedMarkers(found, sp.marker) &lt; 0))
     { found = sp.marker }
 } }
 return found
</PRE><P>}
function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }
</P><P>// Test whether there exists a collapsed span that partially
// overlaps (covers the start or end, but not both) of a new span.
// Such overlap is not allowed.
function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
</P><PRE> var line = getLine(doc, lineNo)
 var sps = sawCollapsedSpans &amp;&amp; line.markedSpans
 if (sps) { for (var i = 0; i &lt; sps.length; ++i) {
   var sp = sps[i]
   if (!sp.marker.collapsed) { continue }
   var found = sp.marker.find(0)
   var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker)
   var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker)
   if (fromCmp &gt;= 0 &amp;&amp; toCmp &lt;= 0 || fromCmp &lt;= 0 &amp;&amp; toCmp &gt;= 0) { continue }
   if (fromCmp &lt;= 0 &amp;&amp; (sp.marker.inclusiveRight &amp;&amp; marker.inclusiveLeft ? cmp(found.to, from) &gt;= 0 : cmp(found.to, from) &gt; 0) ||
       fromCmp &gt;= 0 &amp;&amp; (sp.marker.inclusiveRight &amp;&amp; marker.inclusiveLeft ? cmp(found.from, to) &lt;= 0 : cmp(found.from, to) &lt; 0))
     { return true }
 } }
</PRE><P>}
</P><P>// A visual line is a line as drawn on the screen. Folding, for
// example, can cause multiple logical lines to appear on the same
// visual line. This finds the start of the visual line that the
// given line is part of (usually that is the line itself).
function visualLine(line) {
</P><PRE> var merged
 while (merged = collapsedSpanAtStart(line))
   { line = merged.find(-1, true).line }
 return line
</PRE><P>}
</P><P>function visualLineEnd(line) {
</P><PRE> var merged
 while (merged = collapsedSpanAtEnd(line))
   { line = merged.find(1, true).line }
 return line
</PRE><P>}
</P><P>// Returns an array of logical lines that continue the visual line
// started by the argument, or undefined if there are no such lines.
function visualLineContinued(line) {
</P><PRE> var merged, lines
 while (merged = collapsedSpanAtEnd(line)) {
   line = merged.find(1, true).line
   ;(lines || (lines = [])).push(line)
 }
 return lines
</PRE><P>}
</P><P>// Get the line number of the start of the visual line that the
// given line number is part of.
function visualLineNo(doc, lineN) {
</P><PRE> var line = getLine(doc, lineN), vis = visualLine(line)
 if (line == vis) { return lineN }
 return lineNo(vis)
</PRE><P>}
</P><P>// Get the line number of the start of the next visual line after
// the given line.
function visualLineEndNo(doc, lineN) {
</P><PRE> if (lineN &gt; doc.lastLine()) { return lineN }
 var line = getLine(doc, lineN), merged
 if (!lineIsHidden(doc, line)) { return lineN }
 while (merged = collapsedSpanAtEnd(line))
   { line = merged.find(1, true).line }
 return lineNo(line) + 1
</PRE><P>}
</P><P>// Compute whether a line is hidden. Lines count as hidden when they
// are part of a visual line that starts with another line, or when
// they are entirely covered by collapsed, non-widget span.
function lineIsHidden(doc, line) {
</P><PRE> var sps = sawCollapsedSpans &amp;&amp; line.markedSpans
 if (sps) { for (var sp = (void 0), i = 0; i &lt; sps.length; ++i) {
   sp = sps[i]
   if (!sp.marker.collapsed) { continue }
   if (sp.from == null) { return true }
   if (sp.marker.widgetNode) { continue }
   if (sp.from == 0 &amp;&amp; sp.marker.inclusiveLeft &amp;&amp; lineIsHiddenInner(doc, line, sp))
     { return true }
 } }
</PRE><P>}
function lineIsHiddenInner(doc, line, span) {
</P><PRE> if (span.to == null) {
   var end = span.marker.find(1, true)
   return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
 }
 if (span.marker.inclusiveRight &amp;&amp; span.to == line.text.length)
   { return true }
 for (var sp = (void 0), i = 0; i &lt; line.markedSpans.length; ++i) {
   sp = line.markedSpans[i]
   if (sp.marker.collapsed &amp;&amp; !sp.marker.widgetNode &amp;&amp; sp.from == span.to &amp;&amp;
       (sp.to == null || sp.to != span.from) &amp;&amp;
       (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &amp;&amp;
       lineIsHiddenInner(doc, line, sp)) { return true }
 }
</PRE><P>}
</P><P>// Find the height above the given line.
function heightAtLine(lineObj) {
</P><PRE> lineObj = visualLine(lineObj)
</PRE><PRE> var h = 0, chunk = lineObj.parent
 for (var i = 0; i &lt; chunk.lines.length; ++i) {
   var line = chunk.lines[i]
   if (line == lineObj) { break }
   else { h += line.height }
 }
 for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
   for (var i$1 = 0; i$1 &lt; p.children.length; ++i$1) {
     var cur = p.children[i$1]
     if (cur == chunk) { break }
     else { h += cur.height }
   }
 }
 return h
</PRE><P>}
</P><P>// Compute the character length of a line, taking into account
// collapsed ranges (see markText) that might hide parts, and join
// other lines onto it.
function lineLength(line) {
</P><PRE> if (line.height == 0) { return 0 }
 var len = line.text.length, merged, cur = line
 while (merged = collapsedSpanAtStart(cur)) {
   var found = merged.find(0, true)
   cur = found.from.line
   len += found.from.ch - found.to.ch
 }
 cur = line
 while (merged = collapsedSpanAtEnd(cur)) {
   var found$1 = merged.find(0, true)
   len -= cur.text.length - found$1.from.ch
   cur = found$1.to.line
   len += cur.text.length - found$1.to.ch
 }
 return len
</PRE><P>}
</P><P>// Find the longest line in the document.
function findMaxLine(cm) {
</P><PRE> var d = cm.display, doc = cm.doc
 d.maxLine = getLine(doc, doc.first)
 d.maxLineLength = lineLength(d.maxLine)
 d.maxLineChanged = true
 doc.iter(function (line) {
   var len = lineLength(line)
   if (len &gt; d.maxLineLength) {
     d.maxLineLength = len
     d.maxLine = line
   }
 })
</PRE><P>}
</P><P>// BIDI HELPERS
</P><P>function iterateBidiSections(order, from, to, f) {
</P><PRE> if (!order) { return f(from, to, &quot;ltr&quot;) }
 var found = false
 for (var i = 0; i &lt; order.length; ++i) {
   var part = order[i]
   if (part.from &lt; to &amp;&amp; part.to &gt; from || from == to &amp;&amp; part.to == from) {
     f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? &quot;rtl&quot; : &quot;ltr&quot;)
     found = true
   }
 }
 if (!found) { f(from, to, &quot;ltr&quot;) }
</PRE><P>}
</P><P>var bidiOther = null
function getBidiPartAt(order, ch, sticky) {
</P><PRE> var found
 bidiOther = null
 for (var i = 0; i &lt; order.length; ++i) {
   var cur = order[i]
   if (cur.from &lt; ch &amp;&amp; cur.to &gt; ch) { return i }
   if (cur.to == ch) {
     if (cur.from != cur.to &amp;&amp; sticky == &quot;before&quot;) { found = i }
     else { bidiOther = i }
   }
   if (cur.from == ch) {
     if (cur.from != cur.to &amp;&amp; sticky != &quot;before&quot;) { found = i }
     else { bidiOther = i }
   }
 }
 return found != null ? found : bidiOther
</PRE><P>}
</P><P>// Bidirectional ordering algorithm
// See <A rel="nofollow" class="external free" href="http://unicode.org/reports/tr9/tr9-13.html">http://unicode.org/reports/tr9/tr9-13.html</A> for the algorithm
// that this (partially) implements.
</P><P>// One-char codes used for character types:
// L (L):   Left-to-Right
// R (R):   Right-to-Left
// r (AL):  Right-to-Left Arabic
// 1 (EN):  European Number
// + (ES):  European Number Separator
// % (ET):  European Number Terminator
// n (AN):  Arabic Number
// , (CS):  Common Number Separator
// m (NSM): Non-Spacing Mark
// b (BN):  Boundary Neutral
// s (B):   Paragraph Separator
// t (S):   Segment Separator
// w (WS):  Whitespace
// N (ON):  Other Neutrals
</P><P>// Returns null if characters are ordered as they appear
// (left-to-right), or an array of sections ({from, to, level}
// objects) in the order in which they occur visually.
var bidiOrdering = (function() {
</P><PRE> // Character types for codepoints 0 to 0xff
 var lowTypes = &quot;bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN&quot;
 // Character types for codepoints 0x600 to 0x6f9
 var arabicTypes = &quot;nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111&quot;
 function charType(code) {
   if (code &lt;= 0xf7) { return lowTypes.charAt(code) }
   else if (0x590 &lt;= code &amp;&amp; code &lt;= 0x5f4) { return &quot;R&quot; }
   else if (0x600 &lt;= code &amp;&amp; code &lt;= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
   else if (0x6ee &lt;= code &amp;&amp; code &lt;= 0x8ac) { return &quot;r&quot; }
   else if (0x2000 &lt;= code &amp;&amp; code &lt;= 0x200b) { return &quot;w&quot; }
   else if (code == 0x200c) { return &quot;b&quot; }
   else { return &quot;L&quot; }
 }
</PRE><PRE> var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
 var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/
 // Browsers seem to always treat the boundaries of block elements as being L.
 var outerType = &quot;L&quot;
</PRE><PRE> function BidiSpan(level, from, to) {
   this.level = level
   this.from = from; this.to = to
 }
</PRE><PRE> return function(str) {
   if (!bidiRE.test(str)) { return false }
   var len = str.length, types = []
   for (var i = 0; i &lt; len; ++i)
     { types.push(charType(str.charCodeAt(i))) }
</PRE><PRE>   // W1. Examine each non-spacing mark (NSM) in the level run, and
   // change the type of the NSM to the type of the previous
   // character. If the NSM is at the start of the level run, it will
   // get the type of sor.
   for (var i$1 = 0, prev = outerType; i$1 &lt; len; ++i$1) {
     var type = types[i$1]
     if (type == &quot;m&quot;) { types[i$1] = prev }
     else { prev = type }
   }
</PRE><PRE>   // W2. Search backwards from each instance of a European number
   // until the first strong type (R, L, AL, or sor) is found. If an
   // AL is found, change the type of the European number to Arabic
   // number.
   // W3. Change all ALs to R.
   for (var i$2 = 0, cur = outerType; i$2 &lt; len; ++i$2) {
     var type$1 = types[i$2]
     if (type$1 == &quot;1&quot; &amp;&amp; cur == &quot;r&quot;) { types[i$2] = &quot;n&quot; }
     else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == &quot;r&quot;) { types[i$2] = &quot;R&quot; } }
   }
</PRE><PRE>   // W4. A single European separator between two European numbers
   // changes to a European number. A single common separator between
   // two numbers of the same type changes to that type.
   for (var i$3 = 1, prev$1 = types[0]; i$3 &lt; len - 1; ++i$3) {
     var type$2 = types[i$3]
     if (type$2 == &quot;+&quot; &amp;&amp; prev$1 == &quot;1&quot; &amp;&amp; types[i$3+1] == &quot;1&quot;) { types[i$3] = &quot;1&quot; }
     else if (type$2 == &quot;,&quot; &amp;&amp; prev$1 == types[i$3+1] &amp;&amp;
              (prev$1 == &quot;1&quot; || prev$1 == &quot;n&quot;)) { types[i$3] = prev$1 }
     prev$1 = type$2
   }
</PRE><PRE>   // W5. A sequence of European terminators adjacent to European
   // numbers changes to all European numbers.
   // W6. Otherwise, separators and terminators change to Other
   // Neutral.
   for (var i$4 = 0; i$4 &lt; len; ++i$4) {
     var type$3 = types[i$4]
     if (type$3 == &quot;,&quot;) { types[i$4] = &quot;N&quot; }
     else if (type$3 == &quot;%&quot;) {
       var end = (void 0)
       for (end = i$4 + 1; end &lt; len &amp;&amp; types[end] == &quot;%&quot;; ++end) {}
       var replace = (i$4 &amp;&amp; types[i$4-1] == &quot;!&quot;) || (end &lt; len &amp;&amp; types[end] == &quot;1&quot;) ? &quot;1&quot; : &quot;N&quot;
       for (var j = i$4; j &lt; end; ++j) { types[j] = replace }
       i$4 = end - 1
     }
   }
</PRE><PRE>   // W7. Search backwards from each instance of a European number
   // until the first strong type (R, L, or sor) is found. If an L is
   // found, then change the type of the European number to L.
   for (var i$5 = 0, cur$1 = outerType; i$5 &lt; len; ++i$5) {
     var type$4 = types[i$5]
     if (cur$1 == &quot;L&quot; &amp;&amp; type$4 == &quot;1&quot;) { types[i$5] = &quot;L&quot; }
     else if (isStrong.test(type$4)) { cur$1 = type$4 }
   }
</PRE><PRE>   // N1. A sequence of neutrals takes the direction of the
   // surrounding strong text if the text on both sides has the same
   // direction. European and Arabic numbers act as if they were R in
   // terms of their influence on neutrals. Start-of-level-run (sor)
   // and end-of-level-run (eor) are used at level run boundaries.
   // N2. Any remaining neutrals take the embedding direction.
   for (var i$6 = 0; i$6 &lt; len; ++i$6) {
     if (isNeutral.test(types[i$6])) {
       var end$1 = (void 0)
       for (end$1 = i$6 + 1; end$1 &lt; len &amp;&amp; isNeutral.test(types[end$1]); ++end$1) {}
       var before = (i$6 ? types[i$6-1] : outerType) == &quot;L&quot;
       var after = (end$1 &lt; len ? types[end$1] : outerType) == &quot;L&quot;
       var replace$1 = before || after ? &quot;L&quot; : &quot;R&quot;
       for (var j$1 = i$6; j$1 &lt; end$1; ++j$1) { types[j$1] = replace$1 }
       i$6 = end$1 - 1
     }
   }
</PRE><PRE>   // Here we depart from the documented algorithm, in order to avoid
   // building up an actual levels array. Since there are only three
   // levels (0, 1, 2) in an implementation that doesn't take
   // explicit embedding into account, we can build up the order on
   // the fly, without following the level-based algorithm.
   var order = [], m
   for (var i$7 = 0; i$7 &lt; len;) {
     if (countsAsLeft.test(types[i$7])) {
       var start = i$7
       for (++i$7; i$7 &lt; len &amp;&amp; countsAsLeft.test(types[i$7]); ++i$7) {}
       order.push(new BidiSpan(0, start, i$7))
     } else {
       var pos = i$7, at = order.length
       for (++i$7; i$7 &lt; len &amp;&amp; types[i$7] != &quot;L&quot;; ++i$7) {}
       for (var j$2 = pos; j$2 &lt; i$7;) {
         if (countsAsNum.test(types[j$2])) {
           if (pos &lt; j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)) }
           var nstart = j$2
           for (++j$2; j$2 &lt; i$7 &amp;&amp; countsAsNum.test(types[j$2]); ++j$2) {}
           order.splice(at, 0, new BidiSpan(2, nstart, j$2))
           pos = j$2
         } else { ++j$2 }
       }
       if (pos &lt; i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)) }
     }
   }
   if (order[0].level == 1 &amp;&amp; (m = str.match(/^\s+/))) {
     order[0].from = m[0].length
     order.unshift(new BidiSpan(0, 0, m[0].length))
   }
   if (lst(order).level == 1 &amp;&amp; (m = str.match(/\s+$/))) {
     lst(order).to -= m[0].length
     order.push(new BidiSpan(0, len - m[0].length, len))
   }
</PRE><PRE>   return order
 }
</PRE><P>})()
</P><P>// Get the bidi ordering for the given line (and cache it). Returns
// false for lines that are fully left-to-right, and an array of
// BidiSpan objects otherwise.
function getOrder(line) {
</P><PRE> var order = line.order
 if (order == null) { order = line.order = bidiOrdering(line.text) }
 return order
</PRE><P>}
</P><P>function moveCharLogically(line, ch, dir) {
</P><PRE> var target = skipExtendingChars(line.text, ch + dir, dir)
 return target &lt; 0 || target &gt; line.text.length ? null : target
</PRE><P>}
</P><P>function moveLogically(line, start, dir) {
</P><PRE> var ch = moveCharLogically(line, start.ch, dir)
 return ch == null ? null : new Pos(start.line, ch, dir &lt; 0 ? &quot;after&quot; : &quot;before&quot;)
</PRE><P>}
</P><P>function endOfLine(visually, cm, lineObj, lineNo, dir) {
</P><PRE> if (visually) {
   var order = getOrder(lineObj)
   if (order) {
     var part = dir &lt; 0 ? lst(order) : order[0]
     var moveInStorageOrder = (dir &lt; 0) == (part.level == 1)
     var sticky = moveInStorageOrder ? &quot;after&quot; : &quot;before&quot;
     var ch
     // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
     // it could be that the last bidi part is not on the last visual line,
     // since visual lines contain content order-consecutive chunks.
     // Thus, in rtl, we are looking for the first (content-order) character
     // in the rtl chunk that is on the last line (that is, the same line
     // as the last (content-order) character).
     if (part.level &gt; 0) {
       var prep = prepareMeasureForLine(cm, lineObj)
       ch = dir &lt; 0 ? lineObj.text.length - 1 : 0
       var targetTop = measureCharPrepared(cm, prep, ch).top
       ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir &lt; 0) == (part.level == 1) ? part.from : part.to - 1, ch)
       if (sticky == &quot;before&quot;) { ch = moveCharLogically(lineObj, ch, 1, true) }
     } else { ch = dir &lt; 0 ? part.to : part.from }
     return new Pos(lineNo, ch, sticky)
   }
 }
 return new Pos(lineNo, dir &lt; 0 ? lineObj.text.length : 0, dir &lt; 0 ? &quot;before&quot; : &quot;after&quot;)
</PRE><P>}
</P><P>function moveVisually(cm, line, start, dir) {
</P><PRE> var bidi = getOrder(line)
 if (!bidi) { return moveLogically(line, start, dir) }
 if (start.ch &gt;= line.text.length) {
   start.ch = line.text.length
   start.sticky = &quot;before&quot;
 } else if (start.ch &lt;= 0) {
   start.ch = 0
   start.sticky = &quot;after&quot;
 }
 var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos]
 if (part.level % 2 == 0 &amp;&amp; (dir &gt; 0 ? part.to &gt; start.ch : part.from &lt; start.ch)) {
   // Case 1: We move within an ltr part. Even with wrapped lines,
   // nothing interesting happens.
   return moveLogically(line, start, dir)
 }
</PRE><PRE> var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); }
 var prep
 var getWrappedLineExtent = function (ch) {
   if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
   prep = prep || prepareMeasureForLine(cm, line)
   return wrappedLineExtentChar(cm, line, prep, ch)
 }
 var wrappedLineExtent = getWrappedLineExtent(start.sticky == &quot;before&quot; ? mv(start, -1) : start.ch)
</PRE><PRE> if (part.level % 2 == 1) {
   var ch = mv(start, -dir)
   if (ch != null &amp;&amp; (dir &gt; 0 ? ch &gt;= part.from &amp;&amp; ch &gt;= wrappedLineExtent.begin : ch &lt;= part.to &amp;&amp; ch &lt;= wrappedLineExtent.end)) {
     // Case 2: We move within an rtl part on the same visual line
     var sticky = dir &lt; 0 ? &quot;before&quot; : &quot;after&quot;
     return new Pos(start.line, ch, sticky)
   }
 }
</PRE><PRE> // Case 3: Could not move within this bidi part in this visual line, so leave
 // the current bidi part
</PRE><PRE> var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
   var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
     ? new Pos(start.line, mv(ch, 1), &quot;before&quot;)
     : new Pos(start.line, ch, &quot;after&quot;); }
</PRE><PRE>   for (; partPos &gt;= 0 &amp;&amp; partPos &lt; bidi.length; partPos += dir) {
     var part = bidi[partPos]
     var moveInStorageOrder = (dir &gt; 0) == (part.level != 1)
     var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1)
     if (part.from &lt;= ch &amp;&amp; ch &lt; part.to) { return getRes(ch, moveInStorageOrder) }
     ch = moveInStorageOrder ? part.from : mv(part.to, -1)
     if (wrappedLineExtent.begin &lt;= ch &amp;&amp; ch &lt; wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
   }
 }
</PRE><PRE> // Case 3a: Look for other bidi parts on the same visual line
 var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent)
 if (res) { return res }
</PRE><PRE> // Case 3b: Look for other bidi parts on the next visual line
 var nextCh = dir &gt; 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1)
 if (nextCh != null &amp;&amp; !(dir &gt; 0 &amp;&amp; nextCh == line.text.length)) {
   res = searchInVisualLine(dir &gt; 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh))
   if (res) { return res }
 }
</PRE><PRE> // Case 4: Nowhere to move
 return null
</PRE><P>}
</P><P>// EVENT HANDLING
</P><P>// Lightweight event framework. on/off also work on DOM nodes,
// registering native DOM handlers.
</P><P>var noHandlers = []
</P><P>var on = function(emitter, type, f) {
</P><PRE> if (emitter.addEventListener) {
   emitter.addEventListener(type, f, false)
 } else if (emitter.attachEvent) {
   emitter.attachEvent(&quot;on&quot; + type, f)
 } else {
   var map = emitter._handlers || (emitter._handlers = {})
   map[type] = (map[type] || noHandlers).concat(f)
 }
</PRE><P>}
</P><P>function getHandlers(emitter, type) {
</P><PRE> return emitter._handlers &amp;&amp; emitter._handlers[type] || noHandlers
</PRE><P>}
</P><P>function off(emitter, type, f) {
</P><PRE> if (emitter.removeEventListener) {
   emitter.removeEventListener(type, f, false)
 } else if (emitter.detachEvent) {
   emitter.detachEvent(&quot;on&quot; + type, f)
 } else {
   var map = emitter._handlers, arr = map &amp;&amp; map[type]
   if (arr) {
     var index = indexOf(arr, f)
     if (index &gt; -1)
       { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)) }
   }
 }
</PRE><P>}
</P><P>function signal(emitter, type /*, values...*/) {
</P><PRE> var handlers = getHandlers(emitter, type)
 if (!handlers.length) { return }
 var args = Array.prototype.slice.call(arguments, 2)
 for (var i = 0; i &lt; handlers.length; ++i) { handlers[i].apply(null, args) }
</PRE><P>}
</P><P>// The DOM events that CodeMirror handles can be overridden by
// registering a (non-DOM) handler on the editor for the event name,
// and preventDefault-ing the event in that handler.
function signalDOMEvent(cm, e, override) {
</P><PRE> if (typeof e == &quot;string&quot;)
   { e = {type: e, preventDefault: function() { this.defaultPrevented = true }} }
 signal(cm, override || e.type, cm, e)
 return e_defaultPrevented(e) || e.codemirrorIgnore
</PRE><P>}
</P><P>function signalCursorActivity(cm) {
</P><PRE> var arr = cm._handlers &amp;&amp; cm._handlers.cursorActivity
 if (!arr) { return }
 var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = [])
 for (var i = 0; i &lt; arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
   { set.push(arr[i]) } }
</PRE><P>}
</P><P>function hasHandler(emitter, type) {
</P><PRE> return getHandlers(emitter, type).length &gt; 0
</PRE><P>}
</P><P>// Add on and off methods to a constructor's prototype, to make
// registering events on such objects more convenient.
function eventMixin(ctor) {
</P><PRE> ctor.prototype.on = function(type, f) {on(this, type, f)}
 ctor.prototype.off = function(type, f) {off(this, type, f)}
</PRE><P>}
</P><P>// Due to the fact that we still support jurassic IE versions, some
// compatibility wrappers are needed.
</P><P>function e_preventDefault(e) {
</P><PRE> if (e.preventDefault) { e.preventDefault() }
 else { e.returnValue = false }
</PRE><P>}
function e_stopPropagation(e) {
</P><PRE> if (e.stopPropagation) { e.stopPropagation() }
 else { e.cancelBubble = true }
</PRE><P>}
function e_defaultPrevented(e) {
</P><PRE> return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
</PRE><P>}
function e_stop(e) {e_preventDefault(e); e_stopPropagation(e)}
</P><P>function e_target(e) {return e.target || e.srcElement}
function e_button(e) {
</P><PRE> var b = e.which
 if (b == null) {
   if (e.button &amp; 1) { b = 1 }
   else if (e.button &amp; 2) { b = 3 }
   else if (e.button &amp; 4) { b = 2 }
 }
 if (mac &amp;&amp; e.ctrlKey &amp;&amp; b == 1) { b = 3 }
 return b
</PRE><P>}
</P><P>// Detect drag-and-drop
var dragAndDrop = function() {
</P><PRE> // There is *some* kind of drag-and-drop support in IE6-8, but I
 // couldn't get it to work yet.
 if (ie &amp;&amp; ie_version &lt; 9) { return false }
 var div = elt('div')
 return &quot;draggable&quot; in div || &quot;dragDrop&quot; in div
</PRE><P>}()
</P><P>var zwspSupported
function zeroWidthElement(measure) {
</P><PRE> if (zwspSupported == null) {
   var test = elt(&quot;span&quot;, &quot;\u200b&quot;)
   removeChildrenAndAdd(measure, elt(&quot;span&quot;, [test, document.createTextNode(&quot;x&quot;)]))
   if (measure.firstChild.offsetHeight != 0)
     { zwspSupported = test.offsetWidth &lt;= 1 &amp;&amp; test.offsetHeight &gt; 2 &amp;&amp; !(ie &amp;&amp; ie_version &lt; 8) }
 }
 var node = zwspSupported ? elt(&quot;span&quot;, &quot;\u200b&quot;) :
   elt(&quot;span&quot;, &quot;\u00a0&quot;, null, &quot;display: inline-block; width: 1px; margin-right: -1px&quot;)
 node.setAttribute(&quot;cm-text&quot;, &quot;&quot;)
 return node
</PRE><P>}
</P><P>// Feature-detect IE's crummy client rect reporting for bidi text
var badBidiRects
function hasBadBidiRects(measure) {
</P><PRE> if (badBidiRects != null) { return badBidiRects }
 var txt = removeChildrenAndAdd(measure, document.createTextNode(&quot;A\u062eA&quot;))
 var r0 = range(txt, 0, 1).getBoundingClientRect()
 var r1 = range(txt, 1, 2).getBoundingClientRect()
 removeChildren(measure)
 if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
 return badBidiRects = (r1.right - r0.right &lt; 3)
</PRE><P>}
</P><P>// See if &quot;&quot;.split is the broken IE version, if so, provide an
// alternative way to split lines.
var splitLinesAuto = &quot;\n\nb&quot;.split(/\n/).length != 3 ? function (string) {
</P><PRE> var pos = 0, result = [], l = string.length
 while (pos &lt;= l) {
   var nl = string.indexOf(&quot;\n&quot;, pos)
   if (nl == -1) { nl = string.length }
   var line = string.slice(pos, string.charAt(nl - 1) == &quot;\r&quot; ? nl - 1 : nl)
   var rt = line.indexOf(&quot;\r&quot;)
   if (rt != -1) {
     result.push(line.slice(0, rt))
     pos += rt + 1
   } else {
     result.push(line)
     pos = nl + 1
   }
 }
 return result
</PRE><P>} : function (string) { return string.split(/\r\n?|\n/); }
</P><P>var hasSelection = window.getSelection ? function (te) {
</P><PRE> try { return te.selectionStart != te.selectionEnd }
 catch(e) { return false }
</PRE><P>} : function (te) {
</P><PRE> var range
 try {range = te.ownerDocument.selection.createRange()}
 catch(e) {}
 if (!range || range.parentElement() != te) { return false }
 return range.compareEndPoints(&quot;StartToEnd&quot;, range) != 0
</PRE><P>}
</P><P>var hasCopyEvent = (function () {
</P><PRE> var e = elt(&quot;div&quot;)
 if (&quot;oncopy&quot; in e) { return true }
 e.setAttribute(&quot;oncopy&quot;, &quot;return;&quot;)
 return typeof e.oncopy == &quot;function&quot;
</PRE><P>})()
</P><P>var badZoomedRects = null
function hasBadZoomedRects(measure) {
</P><PRE> if (badZoomedRects != null) { return badZoomedRects }
 var node = removeChildrenAndAdd(measure, elt(&quot;span&quot;, &quot;x&quot;))
 var normal = node.getBoundingClientRect()
 var fromRange = range(node, 0, 1).getBoundingClientRect()
 return badZoomedRects = Math.abs(normal.left - fromRange.left) &gt; 1
</PRE><P>}
</P><P>var modes = {};
var mimeModes = {};
// Extra arguments are stored as the mode's dependencies, which is
// used by (legacy) mechanisms like loadmode.js to automatically
// load a mode. (Preferred mechanism is the require/define calls.)
function defineMode(name, mode) {</P><PRE> if (arguments.length &gt; 2)
   { mode.dependencies = Array.prototype.slice.call(arguments, 2) }
 modes[name] = mode
</PRE><P>}
</P><P>function defineMIME(mime, spec) {
</P><PRE> mimeModes[mime] = spec
</PRE><P>}
</P><P>// Given a MIME type, a {name, ...options} config object, or a name
// string, return a mode config object.
function resolveMode(spec) {
</P><PRE> if (typeof spec == &quot;string&quot; &amp;&amp; mimeModes.hasOwnProperty(spec)) {
   spec = mimeModes[spec]
 } else if (spec &amp;&amp; typeof spec.name == &quot;string&quot; &amp;&amp; mimeModes.hasOwnProperty(spec.name)) {
   var found = mimeModes[spec.name]
   if (typeof found == &quot;string&quot;) { found = {name: found} }
   spec = createObj(found, spec)
   spec.name = found.name
 } else if (typeof spec == &quot;string&quot; &amp;&amp; /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
   return resolveMode(&quot;application/xml&quot;)
 } else if (typeof spec == &quot;string&quot; &amp;&amp; /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
   return resolveMode(&quot;application/json&quot;)
 }
 if (typeof spec == &quot;string&quot;) { return {name: spec} }
 else { return spec || {name: &quot;null&quot;} }
</PRE><P>}
</P><P>// Given a mode spec (anything that resolveMode accepts), find and
// initialize an actual mode object.
function getMode(options, spec) {
</P><PRE> spec = resolveMode(spec)
 var mfactory = modes[spec.name]
 if (!mfactory) { return getMode(options, &quot;text/plain&quot;) }
 var modeObj = mfactory(options, spec)
 if (modeExtensions.hasOwnProperty(spec.name)) {
   var exts = modeExtensions[spec.name]
   for (var prop in exts) {
     if (!exts.hasOwnProperty(prop)) { continue }
     if (modeObj.hasOwnProperty(prop)) { modeObj[&quot;_&quot; + prop] = modeObj[prop] }
     modeObj[prop] = exts[prop]
   }
 }
 modeObj.name = spec.name
 if (spec.helperType) { modeObj.helperType = spec.helperType }
 if (spec.modeProps) { for (var prop$1 in spec.modeProps)
   { modeObj[prop$1] = spec.modeProps[prop$1] } }
</PRE><PRE> return modeObj
</PRE><P>}
</P><P>// This can be used to attach properties to mode objects from
// outside the actual mode definition.
var modeExtensions = {}
function extendMode(mode, properties) {
</P><PRE> var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {})
 copyObj(properties, exts)
</PRE><P>}
</P><P>function copyState(mode, state) {
</P><PRE> if (state === true) { return state }
 if (mode.copyState) { return mode.copyState(state) }
 var nstate = {}
 for (var n in state) {
   var val = state[n]
   if (val instanceof Array) { val = val.concat([]) }
   nstate[n] = val
 }
 return nstate
</PRE><P>}
</P><P>// Given a mode and a state (for that mode), find the inner mode and
// state at the position that the state refers to.
function innerMode(mode, state) {
</P><PRE> var info
 while (mode.innerMode) {
   info = mode.innerMode(state)
   if (!info || info.mode == mode) { break }
   state = info.state
   mode = info.mode
 }
 return info || {mode: mode, state: state}
</PRE><P>}
</P><P>function startState(mode, a1, a2) {
</P><PRE> return mode.startState ? mode.startState(a1, a2) : true
</PRE><P>}
</P><P>// STRING STREAM
</P><P>// Fed to the mode parsers, provides helper functions to make
// parsers more succinct.
</P><P>var StringStream = function(string, tabSize) {
</P><PRE> this.pos = this.start = 0
 this.string = string
 this.tabSize = tabSize || 8
 this.lastColumnPos = this.lastColumnValue = 0
 this.lineStart = 0
</PRE><P>};
</P><P>StringStream.prototype.eol = function () {return this.pos &gt;= this.string.length};
StringStream.prototype.sol = function () {return this.pos == this.lineStart};
StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
StringStream.prototype.next = function () {
</P><PRE> if (this.pos &lt; this.string.length)
   { return this.string.charAt(this.pos++) }
</PRE><P>};
StringStream.prototype.eat = function (match) {
</P><PRE> var ch = this.string.charAt(this.pos)
 var ok
 if (typeof match == &quot;string&quot;) { ok = ch == match }
 else { ok = ch &amp;&amp; (match.test ? match.test(ch) : match(ch)) }
 if (ok) {++this.pos; return ch}
</PRE><P>};
StringStream.prototype.eatWhile = function (match) {
</P><PRE> var start = this.pos
 while (this.eat(match)){}
 return this.pos &gt; start
</PRE><P>};
StringStream.prototype.eatSpace = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> var start = this.pos
 while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos }
 return this.pos &gt; start
</PRE><P>};
StringStream.prototype.skipToEnd = function () {this.pos = this.string.length};
StringStream.prototype.skipTo = function (ch) {
</P><PRE> var found = this.string.indexOf(ch, this.pos)
 if (found &gt; -1) {this.pos = found; return true}
</PRE><P>};
StringStream.prototype.backUp = function (n) {this.pos -= n};
StringStream.prototype.column = function () {
</P><PRE> if (this.lastColumnPos &lt; this.start) {
   this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)
   this.lastColumnPos = this.start
 }
 return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
</PRE><P>};
StringStream.prototype.indentation = function () {
</P><PRE> return countColumn(this.string, null, this.tabSize) -
   (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
</PRE><P>};
StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
</P><PRE> if (typeof pattern == &quot;string&quot;) {
   var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; }
   var substr = this.string.substr(this.pos, pattern.length)
   if (cased(substr) == cased(pattern)) {
     if (consume !== false) { this.pos += pattern.length }
     return true
   }
 } else {
   var match = this.string.slice(this.pos).match(pattern)
   if (match &amp;&amp; match.index &gt; 0) { return null }
   if (match &amp;&amp; consume !== false) { this.pos += match[0].length }
   return match
 }
</PRE><P>};
StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
StringStream.prototype.hideFirstChars = function (n, inner) {
</P><PRE> this.lineStart += n
 try { return inner() }
 finally { this.lineStart -= n }
</PRE><P>};
</P><P>// Compute a style array (an array starting with a mode generation
// -- for invalidation -- followed by pairs of end positions and
// style strings), which is used to highlight the tokens on the
// line.
function highlightLine(cm, line, state, forceToEnd) {
</P><PRE> // A styles array always starts with a number identifying the
 // mode/overlays that it is based on (for easy invalidation).
 var st = [cm.state.modeGen], lineClasses = {}
 // Compute the base array of styles
 runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },
   lineClasses, forceToEnd)
</PRE><PRE> // Run overlays, adjust style array.
 var loop = function ( o ) {
   var overlay = cm.state.overlays[o], i = 1, at = 0
   runMode(cm, line.text, overlay.mode, true, function (end, style) {
     var start = i
     // Ensure there's a token end at the current position, and that i points at it
     while (at &lt; end) {
       var i_end = st[i]
       if (i_end &gt; end)
         { st.splice(i, 1, end, st[i+1], i_end) }
       i += 2
       at = Math.min(end, i_end)
     }
     if (!style) { return }
     if (overlay.opaque) {
       st.splice(start, i - start, end, &quot;overlay &quot; + style)
       i = start + 2
     } else {
       for (; start &lt; i; start += 2) {
         var cur = st[start+1]
         st[start+1] = (cur ? cur + &quot; &quot; : &quot;&quot;) + &quot;overlay &quot; + style
       }
     }
   }, lineClasses)
 };
</PRE><PRE> for (var o = 0; o &lt; cm.state.overlays.length; ++o) loop( o );
</PRE><PRE> return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
</PRE><P>}
</P><P>function getLineStyles(cm, line, updateFrontier) {
</P><PRE> if (!line.styles || line.styles[0] != cm.state.modeGen) {
   var state = getStateBefore(cm, lineNo(line))
   var result = highlightLine(cm, line, line.text.length &gt; cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state)
   line.stateAfter = state
   line.styles = result.styles
   if (result.classes) { line.styleClasses = result.classes }
   else if (line.styleClasses) { line.styleClasses = null }
   if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++ }
 }
 return line.styles
</PRE><P>}
</P><P>function getStateBefore(cm, n, precise) {
</P><PRE> var doc = cm.doc, display = cm.display
 if (!doc.mode.startState) { return true }
 var pos = findStartLine(cm, n, precise), state = pos &gt; doc.first &amp;&amp; getLine(doc, pos-1).stateAfter
 if (!state) { state = startState(doc.mode) }
 else { state = copyState(doc.mode, state) }
 doc.iter(pos, n, function (line) {
   processLine(cm, line.text, state)
   var save = pos == n - 1 || pos % 5 == 0 || pos &gt;= display.viewFrom &amp;&amp; pos &lt; display.viewTo
   line.stateAfter = save ? copyState(doc.mode, state) : null
   ++pos
 })
 if (precise) { doc.frontier = pos }
 return state
</PRE><P>}
</P><P>// Lightweight form of highlight -- proceed over this line and
// update state, but don't save a style array. Used for lines that
// aren't currently visible.
function processLine(cm, text, state, startAt) {
</P><PRE> var mode = cm.doc.mode
 var stream = new StringStream(text, cm.options.tabSize)
 stream.start = stream.pos = startAt || 0
 if (text == &quot;&quot;) { callBlankLine(mode, state) }
 while (!stream.eol()) {
   readToken(mode, stream, state)
   stream.start = stream.pos
 }
</PRE><P>}
</P><P>function callBlankLine(mode, state) {
</P><PRE> if (mode.blankLine) { return mode.blankLine(state) }
 if (!mode.innerMode) { return }
 var inner = innerMode(mode, state)
 if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
</PRE><P>}
</P><P>function readToken(mode, stream, state, inner) {
</P><PRE> for (var i = 0; i &lt; 10; i++) {
   if (inner) { inner[0] = innerMode(mode, state).mode }
   var style = mode.token(stream, state)
   if (stream.pos &gt; stream.start) { return style }
 }
 throw new Error(&quot;Mode &quot; + mode.name + &quot; failed to advance stream.&quot;)
</PRE><P>}
</P><P>// Utility for getTokenAt and getLineTokens
function takeToken(cm, pos, precise, asArray) {
</P><PRE> var getObj = function (copy) { return ({
   start: stream.start, end: stream.pos,
   string: stream.current(),
   type: style || null,
   state: copy ? copyState(doc.mode, state) : state
 }); }
</PRE><PRE> var doc = cm.doc, mode = doc.mode, style
 pos = clipPos(doc, pos)
 var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise)
 var stream = new StringStream(line.text, cm.options.tabSize), tokens
 if (asArray) { tokens = [] }
 while ((asArray || stream.pos &lt; pos.ch) &amp;&amp; !stream.eol()) {
   stream.start = stream.pos
   style = readToken(mode, stream, state)
   if (asArray) { tokens.push(getObj(true)) }
 }
 return asArray ? tokens : getObj()
</PRE><P>}
</P><P>function extractLineClasses(type, output) {
</P><PRE> if (type) { for (;;) {
   var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/)
   if (!lineClass) { break }
   type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length)
   var prop = lineClass[1] ? &quot;bgClass&quot; : &quot;textClass&quot;
   if (output[prop] == null)
     { output[prop] = lineClass[2] }
   else if (!(new RegExp(&quot;(?:^|\s)&quot; + lineClass[2] + &quot;(?:$|\s)&quot;)).test(output[prop]))
     { output[prop] += &quot; &quot; + lineClass[2] }
 } }
 return type
</PRE><P>}
</P><P>// Run the given mode's parser over a line, calling f for each token.
function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
</P><PRE> var flattenSpans = mode.flattenSpans
 if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans }
 var curStart = 0, curStyle = null
 var stream = new StringStream(text, cm.options.tabSize), style
 var inner = cm.options.addModeClass &amp;&amp; [null]
 if (text == &quot;&quot;) { extractLineClasses(callBlankLine(mode, state), lineClasses) }
 while (!stream.eol()) {
   if (stream.pos &gt; cm.options.maxHighlightLength) {
     flattenSpans = false
     if (forceToEnd) { processLine(cm, text, state, stream.pos) }
     stream.pos = text.length
     style = null
   } else {
     style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses)
   }
   if (inner) {
     var mName = inner[0].name
     if (mName) { style = &quot;m-&quot; + (style ? mName + &quot; &quot; + style : mName) }
   }
   if (!flattenSpans || curStyle != style) {
     while (curStart &lt; stream.start) {
       curStart = Math.min(stream.start, curStart + 5000)
       f(curStart, curStyle)
     }
     curStyle = style
   }
   stream.start = stream.pos
 }
 while (curStart &lt; stream.pos) {
   // Webkit seems to refuse to render text nodes longer than 57444
   // characters, and returns inaccurate measurements in nodes
   // starting around 5000 chars.
   var pos = Math.min(stream.pos, curStart + 5000)
   f(pos, curStyle)
   curStart = pos
 }
</PRE><P>}
</P><P>// Finds the line to start with when starting a parse. Tries to
// find a line with a stateAfter, so that it can start with a
// valid state. If that fails, it returns the line with the
// smallest indentation, which tends to need the least context to
// parse correctly.
function findStartLine(cm, n, precise) {
</P><PRE> var minindent, minline, doc = cm.doc
 var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)
 for (var search = n; search &gt; lim; --search) {
   if (search &lt;= doc.first) { return doc.first }
   var line = getLine(doc, search - 1)
   if (line.stateAfter &amp;&amp; (!precise || search &lt;= doc.frontier)) { return search }
   var indented = countColumn(line.text, null, cm.options.tabSize)
   if (minline == null || minindent &gt; indented) {
     minline = search - 1
     minindent = indented
   }
 }
 return minline
</PRE><P>}
</P><P>// LINE DATA STRUCTURE
</P><P>// Line objects. These hold state related to a line, including
// highlighting info (the styles array).
var Line = function(text, markedSpans, estimateHeight) {
</P><PRE> this.text = text
 attachMarkedSpans(this, markedSpans)
 this.height = estimateHeight ? estimateHeight(this) : 1
</PRE><P>};
</P><P>Line.prototype.lineNo = function () { return lineNo(this) };
eventMixin(Line)
</P><P>// Change the content (text, markers) of a line. Automatically
// invalidates cached information and tries to re-estimate the
// line's height.
function updateLine(line, text, markedSpans, estimateHeight) {
</P><PRE> line.text = text
 if (line.stateAfter) { line.stateAfter = null }
 if (line.styles) { line.styles = null }
 if (line.order != null) { line.order = null }
 detachMarkedSpans(line)
 attachMarkedSpans(line, markedSpans)
 var estHeight = estimateHeight ? estimateHeight(line) : 1
 if (estHeight != line.height) { updateLineHeight(line, estHeight) }
</PRE><P>}
</P><P>// Detach a line from the document tree and its markers.
function cleanUpLine(line) {
</P><PRE> line.parent = null
 detachMarkedSpans(line)
</PRE><P>}
</P><P>// Convert a style as returned by a mode (either null, or a string
// containing one or more styles) to a CSS style. This is cached,
// and also looks for line-wide styles.
var styleToClassCache = {};
var styleToClassCacheWithMode = {};
function interpretTokenStyle(style, options) {
</P><PRE> if (!style || /^\s*$/.test(style)) { return null }
 var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache
 return cache[style] ||
   (cache[style] = style.replace(/\S+/g, &quot;cm-$&amp;&quot;))
</PRE><P>}
</P><P>// Render the DOM representation of the text of a line. Also builds
// up a 'line map', which points at the DOM nodes that represent
// specific stretches of text, and is used by the measuring code.
// The returned object contains the DOM node, this map, and
// information about line-wide styles that were set by the mode.
function buildLineContent(cm, lineView) {
</P><PRE> // The padding-right forces the element to have a 'border', which
 // is needed on Webkit to be able to get line-level bounding
 // rectangles for it (in measureChar).
 var content = elt(&quot;span&quot;, null, null, webkit ? &quot;padding-right: .1px&quot; : null)
 var builder = {pre: elt(&quot;pre&quot;, [content], &quot;CodeMirror-line&quot;), content: content,
                col: 0, pos: 0, cm: cm,
                trailingSpace: false,
                splitSpaces: (ie || webkit) &amp;&amp; cm.getOption(&quot;lineWrapping&quot;)}
 // hide from accessibility tree
 content.setAttribute(&quot;role&quot;, &quot;presentation&quot;)
 builder.pre.setAttribute(&quot;role&quot;, &quot;presentation&quot;)
 lineView.measure = {}
</PRE><PRE> // Iterate over the logical lines that make up this visual line.
 for (var i = 0; i &lt;= (lineView.rest ? lineView.rest.length : 0); i++) {
   var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0)
   builder.pos = 0
   builder.addToken = buildToken
   // Optionally wire in some hacks into the token-rendering
   // algorithm, to deal with browser quirks.
   if (hasBadBidiRects(cm.display.measure) &amp;&amp; (order = getOrder(line)))
     { builder.addToken = buildTokenBadBidi(builder.addToken, order) }
   builder.map = []
   var allowFrontierUpdate = lineView != cm.display.externalMeasured &amp;&amp; lineNo(line)
   insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate))
   if (line.styleClasses) {
     if (line.styleClasses.bgClass)
       { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || &quot;&quot;) }
     if (line.styleClasses.textClass)
       { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || &quot;&quot;) }
   }
</PRE><PRE>   // Ensure at least a single node is present, for measuring.
   if (builder.map.length == 0)
     { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))) }
</PRE><PRE>   // Store the map and a cache object for the current logical line
   if (i == 0) {
     lineView.measure.map = builder.map
     lineView.measure.cache = {}
   } else {
     ;(lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
     ;(lineView.measure.caches || (lineView.measure.caches = [])).push({})
   }
 }
</PRE><PRE> // See issue #2901
 if (webkit) {
   var last = builder.content.lastChild
   if (/\bcm-tab\b/.test(last.className) || (last.querySelector &amp;&amp; last.querySelector(&quot;.cm-tab&quot;)))
     { builder.content.className = &quot;cm-tab-wrap-hack&quot; }
 }
</PRE><PRE> signal(cm, &quot;renderLine&quot;, cm, lineView.line, builder.pre)
 if (builder.pre.className)
   { builder.textClass = joinClasses(builder.pre.className, builder.textClass || &quot;&quot;) }
</PRE><PRE> return builder
</PRE><P>}
</P><P>function defaultSpecialCharPlaceholder(ch) {
</P><PRE> var token = elt(&quot;span&quot;, &quot;\u2022&quot;, &quot;cm-invalidchar&quot;)
 token.title = &quot;\\u&quot; + ch.charCodeAt(0).toString(16)
 token.setAttribute(&quot;aria-label&quot;, token.title)
 return token
</PRE><P>}
</P><P>// Build up the DOM representation for a single token, and add it to
// the line map. Takes care to render special characters separately.
function buildToken(builder, text, style, startStyle, endStyle, title, css) {
</P><PRE> if (!text) { return }
 var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text
 var special = builder.cm.state.specialChars, mustWrap = false
 var content
 if (!special.test(text)) {
   builder.col += text.length
   content = document.createTextNode(displayText)
   builder.map.push(builder.pos, builder.pos + text.length, content)
   if (ie &amp;&amp; ie_version &lt; 9) { mustWrap = true }
   builder.pos += text.length
 } else {
   content = document.createDocumentFragment()
   var pos = 0
   while (true) {
     special.lastIndex = pos
     var m = special.exec(text)
     var skipped = m ? m.index - pos : text.length - pos
     if (skipped) {
       var txt = document.createTextNode(displayText.slice(pos, pos + skipped))
       if (ie &amp;&amp; ie_version &lt; 9) { content.appendChild(elt(&quot;span&quot;, [txt])) }
       else { content.appendChild(txt) }
       builder.map.push(builder.pos, builder.pos + skipped, txt)
       builder.col += skipped
       builder.pos += skipped
     }
     if (!m) { break }
     pos += skipped + 1
     var txt$1 = (void 0)
     if (m[0] == &quot;\t&quot;) {
       var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize
       txt$1 = content.appendChild(elt(&quot;span&quot;, spaceStr(tabWidth), &quot;cm-tab&quot;))
       txt$1.setAttribute(&quot;role&quot;, &quot;presentation&quot;)
       txt$1.setAttribute(&quot;cm-text&quot;, &quot;\t&quot;)
       builder.col += tabWidth
     } else if (m[0] == &quot;\r&quot; || m[0] == &quot;\n&quot;) {
       txt$1 = content.appendChild(elt(&quot;span&quot;, m[0] == &quot;\r&quot; ? &quot;\u240d&quot; : &quot;\u2424&quot;, &quot;cm-invalidchar&quot;))
       txt$1.setAttribute(&quot;cm-text&quot;, m[0])
       builder.col += 1
     } else {
       txt$1 = builder.cm.options.specialCharPlaceholder(m[0])
       txt$1.setAttribute(&quot;cm-text&quot;, m[0])
       if (ie &amp;&amp; ie_version &lt; 9) { content.appendChild(elt(&quot;span&quot;, [txt$1])) }
       else { content.appendChild(txt$1) }
       builder.col += 1
     }
     builder.map.push(builder.pos, builder.pos + 1, txt$1)
     builder.pos++
   }
 }
 builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32
 if (style || startStyle || endStyle || mustWrap || css) {
   var fullStyle = style || &quot;&quot;
   if (startStyle) { fullStyle += startStyle }
   if (endStyle) { fullStyle += endStyle }
   var token = elt(&quot;span&quot;, [content], fullStyle, css)
   if (title) { token.title = title }
   return builder.content.appendChild(token)
 }
 builder.content.appendChild(content)
</PRE><P>}
</P><P>function splitSpaces(text, trailingBefore) {
</P><PRE> if (text.length &gt; 1 &amp;&amp; !/  /.test(text)) { return text }
 var spaceBefore = trailingBefore, result = &quot;&quot;
 for (var i = 0; i &lt; text.length; i++) {
   var ch = text.charAt(i)
   if (ch == &quot; &quot; &amp;&amp; spaceBefore &amp;&amp; (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
     { ch = &quot;\u00a0&quot; }
   result += ch
   spaceBefore = ch == &quot; &quot;
 }
 return result
</PRE><P>}
</P><P>// Work around nonsense dimensions being reported for stretches of
// right-to-left text.
function buildTokenBadBidi(inner, order) {
</P><PRE> return function (builder, text, style, startStyle, endStyle, title, css) {
   style = style ? style + &quot; cm-force-border&quot; : &quot;cm-force-border&quot;
   var start = builder.pos, end = start + text.length
   for (;;) {
     // Find the part that overlaps with the start of this text
     var part = (void 0)
     for (var i = 0; i &lt; order.length; i++) {
       part = order[i]
       if (part.to &gt; start &amp;&amp; part.from &lt;= start) { break }
     }
     if (part.to &gt;= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
     inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css)
     startStyle = null
     text = text.slice(part.to - start)
     start = part.to
   }
 }
</PRE><P>}
</P><P>function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
</P><PRE> var widget = !ignoreWidget &amp;&amp; marker.widgetNode
 if (widget) { builder.map.push(builder.pos, builder.pos + size, widget) }
 if (!ignoreWidget &amp;&amp; builder.cm.display.input.needsContentAttribute) {
   if (!widget)
     { widget = builder.content.appendChild(document.createElement(&quot;span&quot;)) }
   widget.setAttribute(&quot;cm-marker&quot;, marker.id)
 }
 if (widget) {
   builder.cm.display.input.setUneditable(widget)
   builder.content.appendChild(widget)
 }
 builder.pos += size
 builder.trailingSpace = false
</PRE><P>}
</P><P>// Outputs a number of spans to make up a line, taking highlighting
// and marked text into account.
function insertLineContent(line, builder, styles) {
</P><PRE> var spans = line.markedSpans, allText = line.text, at = 0
 if (!spans) {
   for (var i$1 = 1; i$1 &lt; styles.length; i$1+=2)
     { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)) }
   return
 }
</PRE><PRE> var len = allText.length, pos = 0, i = 1, text = &quot;&quot;, style, css
 var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed
 for (;;) {
   if (nextChange == pos) { // Update current marker set
     spanStyle = spanEndStyle = spanStartStyle = title = css = &quot;&quot;
     collapsed = null; nextChange = Infinity
     var foundBookmarks = [], endStyles = (void 0)
     for (var j = 0; j &lt; spans.length; ++j) {
       var sp = spans[j], m = sp.marker
       if (m.type == &quot;bookmark&quot; &amp;&amp; sp.from == pos &amp;&amp; m.widgetNode) {
         foundBookmarks.push(m)
       } else if (sp.from &lt;= pos &amp;&amp; (sp.to == null || sp.to &gt; pos || m.collapsed &amp;&amp; sp.to == pos &amp;&amp; sp.from == pos)) {
         if (sp.to != null &amp;&amp; sp.to != pos &amp;&amp; nextChange &gt; sp.to) {
           nextChange = sp.to
           spanEndStyle = &quot;&quot;
         }
         if (m.className) { spanStyle += &quot; &quot; + m.className }
         if (m.css) { css = (css ? css + &quot;;&quot; : &quot;&quot;) + m.css }
         if (m.startStyle &amp;&amp; sp.from == pos) { spanStartStyle += &quot; &quot; + m.startStyle }
         if (m.endStyle &amp;&amp; sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to) }
         if (m.title &amp;&amp; !title) { title = m.title }
         if (m.collapsed &amp;&amp; (!collapsed || compareCollapsedMarkers(collapsed.marker, m) &lt; 0))
           { collapsed = sp }
       } else if (sp.from &gt; pos &amp;&amp; nextChange &gt; sp.from) {
         nextChange = sp.from
       }
     }
     if (endStyles) { for (var j$1 = 0; j$1 &lt; endStyles.length; j$1 += 2)
       { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += &quot; &quot; + endStyles[j$1] } } }
</PRE><PRE>     if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 &lt; foundBookmarks.length; ++j$2)
       { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]) } }
     if (collapsed &amp;&amp; (collapsed.from || 0) == pos) {
       buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                          collapsed.marker, collapsed.from == null)
       if (collapsed.to == null) { return }
       if (collapsed.to == pos) { collapsed = false }
     }
   }
   if (pos &gt;= len) { break }
</PRE><PRE>   var upto = Math.min(len, nextChange)
   while (true) {
     if (text) {
       var end = pos + text.length
       if (!collapsed) {
         var tokenText = end &gt; upto ? text.slice(0, upto - pos) : text
         builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                          spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : &quot;&quot;, title, css)
       }
       if (end &gt;= upto) {text = text.slice(upto - pos); pos = upto; break}
       pos = end
       spanStartStyle = &quot;&quot;
     }
     text = allText.slice(at, at = styles[i++])
     style = interpretTokenStyle(styles[i++], builder.cm.options)
   }
 }
</PRE><P>}
</P><P>
// These objects are used to represent the visible (currently drawn)
// part of the document. A LineView may correspond to multiple
// logical lines, if those are connected by collapsed ranges.
function LineView(doc, line, lineN) {
</P><PRE> // The starting line
 this.line = line
 // Continuing lines, if any
 this.rest = visualLineContinued(line)
 // Number of logical lines in this visual line
 this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1
 this.node = this.text = null
 this.hidden = lineIsHidden(doc, line)
</PRE><P>}
</P><P>// Create a range of LineView objects for the given lines.
function buildViewArray(cm, from, to) {
</P><PRE> var array = [], nextPos
 for (var pos = from; pos &lt; to; pos = nextPos) {
   var view = new LineView(cm.doc, getLine(cm.doc, pos), pos)
   nextPos = pos + view.size
   array.push(view)
 }
 return array
</PRE><P>}
</P><P>var operationGroup = null
</P><P>function pushOperation(op) {
</P><PRE> if (operationGroup) {
   operationGroup.ops.push(op)
 } else {
   op.ownsGroup = operationGroup = {
     ops: [op],
     delayedCallbacks: []
   }
 }
</PRE><P>}
</P><P>function fireCallbacksForOps(group) {
</P><PRE> // Calls delayed callbacks and cursorActivity handlers until no
 // new ones appear
 var callbacks = group.delayedCallbacks, i = 0
 do {
   for (; i &lt; callbacks.length; i++)
     { callbacks[i].call(null) }
   for (var j = 0; j &lt; group.ops.length; j++) {
     var op = group.ops[j]
     if (op.cursorActivityHandlers)
       { while (op.cursorActivityCalled &lt; op.cursorActivityHandlers.length)
         { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm) } }
   }
 } while (i &lt; callbacks.length)
</PRE><P>}
</P><P>function finishOperation(op, endCb) {
</P><PRE> var group = op.ownsGroup
 if (!group) { return }
</PRE><PRE> try { fireCallbacksForOps(group) }
 finally {
   operationGroup = null
   endCb(group)
 }
</PRE><P>}
</P><P>var orphanDelayedCallbacks = null
</P><P>// Often, we want to signal events at a point where we are in the
// middle of some work, but don't want the handler to start calling
// other methods on the editor, which might be in an inconsistent
// state or simply not expect any other events to happen.
// signalLater looks whether there are any handlers, and schedules
// them to be executed when the last operation ends, or, if no
// operation is active, when a timeout fires.
function signalLater(emitter, type /*, values...*/) {
</P><PRE> var arr = getHandlers(emitter, type)
 if (!arr.length) { return }
 var args = Array.prototype.slice.call(arguments, 2), list
 if (operationGroup) {
   list = operationGroup.delayedCallbacks
 } else if (orphanDelayedCallbacks) {
   list = orphanDelayedCallbacks
 } else {
   list = orphanDelayedCallbacks = []
   setTimeout(fireOrphanDelayed, 0)
 }
 var loop = function ( i ) {
   list.push(function () { return arr[i].apply(null, args); })
 };
</PRE><PRE> for (var i = 0; i &lt; arr.length; ++i)
   loop( i );
</PRE><P>}
</P><P>function fireOrphanDelayed() {
</P><PRE> var delayed = orphanDelayedCallbacks
 orphanDelayedCallbacks = null
 for (var i = 0; i &lt; delayed.length; ++i) { delayed[i]() }
</PRE><P>}
</P><P>// When an aspect of a line changes, a string is added to
// lineView.changes. This updates the relevant part of the line's
// DOM structure.
function updateLineForChanges(cm, lineView, lineN, dims) {
</P><PRE> for (var j = 0; j &lt; lineView.changes.length; j++) {
   var type = lineView.changes[j]
   if (type == &quot;text&quot;) { updateLineText(cm, lineView) }
   else if (type == &quot;gutter&quot;) { updateLineGutter(cm, lineView, lineN, dims) }
   else if (type == &quot;class&quot;) { updateLineClasses(lineView) }
   else if (type == &quot;widget&quot;) { updateLineWidgets(cm, lineView, dims) }
 }
 lineView.changes = null
</PRE><P>}
</P><P>// Lines with gutter elements, widgets or a background class need to
// be wrapped, and have the extra elements added to the wrapper div
function ensureLineWrapped(lineView) {
</P><PRE> if (lineView.node == lineView.text) {
   lineView.node = elt(&quot;div&quot;, null, null, &quot;position: relative&quot;)
   if (lineView.text.parentNode)
     { lineView.text.parentNode.replaceChild(lineView.node, lineView.text) }
   lineView.node.appendChild(lineView.text)
   if (ie &amp;&amp; ie_version &lt; 8) { lineView.node.style.zIndex = 2 }
 }
 return lineView.node
</PRE><P>}
</P><P>function updateLineBackground(lineView) {
</P><PRE> var cls = lineView.bgClass ? lineView.bgClass + &quot; &quot; + (lineView.line.bgClass || &quot;&quot;) : lineView.line.bgClass
 if (cls) { cls += &quot; CodeMirror-linebackground&quot; }
 if (lineView.background) {
   if (cls) { lineView.background.className = cls }
   else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null }
 } else if (cls) {
   var wrap = ensureLineWrapped(lineView)
   lineView.background = wrap.insertBefore(elt(&quot;div&quot;, null, cls), wrap.firstChild)
 }
</PRE><P>}
</P><P>// Wrapper around buildLineContent which will reuse the structure
// in display.externalMeasured when possible.
function getLineContent(cm, lineView) {
</P><PRE> var ext = cm.display.externalMeasured
 if (ext &amp;&amp; ext.line == lineView.line) {
   cm.display.externalMeasured = null
   lineView.measure = ext.measure
   return ext.built
 }
 return buildLineContent(cm, lineView)
</PRE><P>}
</P><P>// Redraw the line's text. Interacts with the background and text
// classes because the mode may output tokens that influence these
// classes.
function updateLineText(cm, lineView) {
</P><PRE> var cls = lineView.text.className
 var built = getLineContent(cm, lineView)
 if (lineView.text == lineView.node) { lineView.node = built.pre }
 lineView.text.parentNode.replaceChild(built.pre, lineView.text)
 lineView.text = built.pre
 if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
   lineView.bgClass = built.bgClass
   lineView.textClass = built.textClass
   updateLineClasses(lineView)
 } else if (cls) {
   lineView.text.className = cls
 }
</PRE><P>}
</P><P>function updateLineClasses(lineView) {
</P><PRE> updateLineBackground(lineView)
 if (lineView.line.wrapClass)
   { ensureLineWrapped(lineView).className = lineView.line.wrapClass }
 else if (lineView.node != lineView.text)
   { lineView.node.className = &quot;&quot; }
 var textClass = lineView.textClass ? lineView.textClass + &quot; &quot; + (lineView.line.textClass || &quot;&quot;) : lineView.line.textClass
 lineView.text.className = textClass || &quot;&quot;
</PRE><P>}
</P><P>function updateLineGutter(cm, lineView, lineN, dims) {
</P><PRE> if (lineView.gutter) {
   lineView.node.removeChild(lineView.gutter)
   lineView.gutter = null
 }
 if (lineView.gutterBackground) {
   lineView.node.removeChild(lineView.gutterBackground)
   lineView.gutterBackground = null
 }
 if (lineView.line.gutterClass) {
   var wrap = ensureLineWrapped(lineView)
   lineView.gutterBackground = elt(&quot;div&quot;, null, &quot;CodeMirror-gutter-background &quot; + lineView.line.gutterClass,
                                   (&quot;left: &quot; + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + &quot;px; width: &quot; + (dims.gutterTotalWidth) + &quot;px&quot;))
   wrap.insertBefore(lineView.gutterBackground, lineView.text)
 }
 var markers = lineView.line.gutterMarkers
 if (cm.options.lineNumbers || markers) {
   var wrap$1 = ensureLineWrapped(lineView)
   var gutterWrap = lineView.gutter = elt(&quot;div&quot;, null, &quot;CodeMirror-gutter-wrapper&quot;, (&quot;left: &quot; + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + &quot;px&quot;))
   cm.display.input.setUneditable(gutterWrap)
   wrap$1.insertBefore(gutterWrap, lineView.text)
   if (lineView.line.gutterClass)
     { gutterWrap.className += &quot; &quot; + lineView.line.gutterClass }
   if (cm.options.lineNumbers &amp;&amp; (!markers || !markers[&quot;CodeMirror-linenumbers&quot;]))
     { lineView.lineNumber = gutterWrap.appendChild(
       elt(&quot;div&quot;, lineNumberFor(cm.options, lineN),
           &quot;CodeMirror-linenumber CodeMirror-gutter-elt&quot;,
           (&quot;left: &quot; + (dims.gutterLeft[&quot;CodeMirror-linenumbers&quot;]) + &quot;px; width: &quot; + (cm.display.lineNumInnerWidth) + &quot;px&quot;))) }
   if (markers) { for (var k = 0; k &lt; cm.options.gutters.length; ++k) {
     var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) &amp;&amp; markers[id]
     if (found)
       { gutterWrap.appendChild(elt(&quot;div&quot;, [found], &quot;CodeMirror-gutter-elt&quot;,
                                  (&quot;left: &quot; + (dims.gutterLeft[id]) + &quot;px; width: &quot; + (dims.gutterWidth[id]) + &quot;px&quot;))) }
   } }
 }
</PRE><P>}
</P><P>function updateLineWidgets(cm, lineView, dims) {
</P><PRE> if (lineView.alignable) { lineView.alignable = null }
 for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
   next = node.nextSibling
   if (node.className == &quot;CodeMirror-linewidget&quot;)
     { lineView.node.removeChild(node) }
 }
 insertLineWidgets(cm, lineView, dims)
</PRE><P>}
</P><P>// Build a line's DOM representation from scratch
function buildLineElement(cm, lineView, lineN, dims) {
</P><PRE> var built = getLineContent(cm, lineView)
 lineView.text = lineView.node = built.pre
 if (built.bgClass) { lineView.bgClass = built.bgClass }
 if (built.textClass) { lineView.textClass = built.textClass }
</PRE><PRE> updateLineClasses(lineView)
 updateLineGutter(cm, lineView, lineN, dims)
 insertLineWidgets(cm, lineView, dims)
 return lineView.node
</PRE><P>}
</P><P>// A lineView may contain multiple logical lines (when merged by
// collapsed spans). The widgets for all of them need to be drawn.
function insertLineWidgets(cm, lineView, dims) {
</P><PRE> insertLineWidgetsFor(cm, lineView.line, lineView, dims, true)
 if (lineView.rest) { for (var i = 0; i &lt; lineView.rest.length; i++)
   { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false) } }
</PRE><P>}
</P><P>function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
</P><PRE> if (!line.widgets) { return }
 var wrap = ensureLineWrapped(lineView)
 for (var i = 0, ws = line.widgets; i &lt; ws.length; ++i) {
   var widget = ws[i], node = elt(&quot;div&quot;, [widget.node], &quot;CodeMirror-linewidget&quot;)
   if (!widget.handleMouseEvents) { node.setAttribute(&quot;cm-ignore-events&quot;, &quot;true&quot;) }
   positionLineWidget(widget, node, lineView, dims)
   cm.display.input.setUneditable(node)
   if (allowAbove &amp;&amp; widget.above)
     { wrap.insertBefore(node, lineView.gutter || lineView.text) }
   else
     { wrap.appendChild(node) }
   signalLater(widget, &quot;redraw&quot;)
 }
</PRE><P>}
</P><P>function positionLineWidget(widget, node, lineView, dims) {
</P><PRE> if (widget.noHScroll) {
   ;(lineView.alignable || (lineView.alignable = [])).push(node)
   var width = dims.wrapperWidth
   node.style.left = dims.fixedPos + &quot;px&quot;
   if (!widget.coverGutter) {
     width -= dims.gutterTotalWidth
     node.style.paddingLeft = dims.gutterTotalWidth + &quot;px&quot;
   }
   node.style.width = width + &quot;px&quot;
 }
 if (widget.coverGutter) {
   node.style.zIndex = 5
   node.style.position = &quot;relative&quot;
   if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + &quot;px&quot; }
 }
</PRE><P>}
</P><P>function widgetHeight(widget) {
</P><PRE> if (widget.height != null) { return widget.height }
 var cm = widget.doc.cm
 if (!cm) { return 0 }
 if (!contains(document.body, widget.node)) {
   var parentStyle = &quot;position: relative;&quot;
   if (widget.coverGutter)
     { parentStyle += &quot;margin-left: -&quot; + cm.display.gutters.offsetWidth + &quot;px;&quot; }
   if (widget.noHScroll)
     { parentStyle += &quot;width: &quot; + cm.display.wrapper.clientWidth + &quot;px;&quot; }
   removeChildrenAndAdd(cm.display.measure, elt(&quot;div&quot;, [widget.node], null, parentStyle))
 }
 return widget.height = widget.node.parentNode.offsetHeight
</PRE><P>}
</P><P>// Return true when the given mouse event happened in a widget
function eventInWidget(display, e) {
</P><PRE> for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
   if (!n || (n.nodeType == 1 &amp;&amp; n.getAttribute(&quot;cm-ignore-events&quot;) == &quot;true&quot;) ||
       (n.parentNode == display.sizer &amp;&amp; n != display.mover))
     { return true }
 }
</PRE><P>}
</P><P>// POSITION MEASUREMENT
</P><P>function paddingTop(display) {return display.lineSpace.offsetTop}
function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
function paddingH(display) {
</P><PRE> if (display.cachedPaddingH) { return display.cachedPaddingH }
 var e = removeChildrenAndAdd(display.measure, elt(&quot;pre&quot;, &quot;x&quot;))
 var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle
 var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)}
 if (!isNaN(data.left) &amp;&amp; !isNaN(data.right)) { display.cachedPaddingH = data }
 return data
</PRE><P>}
</P><P>function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
function displayWidth(cm) {
</P><PRE> return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
</PRE><P>}
function displayHeight(cm) {
</P><PRE> return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
</PRE><P>}
</P><P>// Ensure the lineView.wrapping.heights array is populated. This is
// an array of bottom offsets for the lines that make up a drawn
// line. When lineWrapping is on, there might be more than one
// height.
function ensureLineHeights(cm, lineView, rect) {
</P><PRE> var wrapping = cm.options.lineWrapping
 var curWidth = wrapping &amp;&amp; displayWidth(cm)
 if (!lineView.measure.heights || wrapping &amp;&amp; lineView.measure.width != curWidth) {
   var heights = lineView.measure.heights = []
   if (wrapping) {
     lineView.measure.width = curWidth
     var rects = lineView.text.firstChild.getClientRects()
     for (var i = 0; i &lt; rects.length - 1; i++) {
       var cur = rects[i], next = rects[i + 1]
       if (Math.abs(cur.bottom - next.bottom) &gt; 2)
         { heights.push((cur.bottom + next.top) / 2 - rect.top) }
     }
   }
   heights.push(rect.bottom - rect.top)
 }
</PRE><P>}
</P><P>// Find a line map (mapping character offsets to text nodes) and a
// measurement cache for the given line number. (A line view might
// contain multiple lines when collapsed ranges are present.)
function mapFromLineView(lineView, line, lineN) {
</P><PRE> if (lineView.line == line)
   { return {map: lineView.measure.map, cache: lineView.measure.cache} }
 for (var i = 0; i &lt; lineView.rest.length; i++)
   { if (lineView.rest[i] == line)
     { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
 for (var i$1 = 0; i$1 &lt; lineView.rest.length; i$1++)
   { if (lineNo(lineView.rest[i$1]) &gt; lineN)
     { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
</PRE><P>}
</P><P>// Render a line into the hidden node display.externalMeasured. Used
// when measurement is needed for a line that's not in the viewport.
function updateExternalMeasurement(cm, line) {
</P><PRE> line = visualLine(line)
 var lineN = lineNo(line)
 var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN)
 view.lineN = lineN
 var built = view.built = buildLineContent(cm, view)
 view.text = built.pre
 removeChildrenAndAdd(cm.display.lineMeasure, built.pre)
 return view
</PRE><P>}
</P><P>// Get a {top, bottom, left, right} box (in line-local coordinates)
// for a given character.
function measureChar(cm, line, ch, bias) {
</P><PRE> return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
</PRE><P>}
</P><P>// Find a line view that corresponds to the given line number.
function findViewForLine(cm, lineN) {
</P><PRE> if (lineN &gt;= cm.display.viewFrom &amp;&amp; lineN &lt; cm.display.viewTo)
   { return cm.display.view[findViewIndex(cm, lineN)] }
 var ext = cm.display.externalMeasured
 if (ext &amp;&amp; lineN &gt;= ext.lineN &amp;&amp; lineN &lt; ext.lineN + ext.size)
   { return ext }
</PRE><P>}
</P><P>// Measurement can be split in two steps, the set-up work that
// applies to the whole line, and the measurement of the actual
// character. Functions like coordsChar, that need to do a lot of
// measurements in a row, can thus ensure that the set-up work is
// only done once.
function prepareMeasureForLine(cm, line) {
</P><PRE> var lineN = lineNo(line)
 var view = findViewForLine(cm, lineN)
 if (view &amp;&amp; !view.text) {
   view = null
 } else if (view &amp;&amp; view.changes) {
   updateLineForChanges(cm, view, lineN, getDimensions(cm))
   cm.curOp.forceUpdate = true
 }
 if (!view)
   { view = updateExternalMeasurement(cm, line) }
</PRE><PRE> var info = mapFromLineView(view, line, lineN)
 return {
   line: line, view: view, rect: null,
   map: info.map, cache: info.cache, before: info.before,
   hasHeights: false
 }
</PRE><P>}
</P><P>// Given a prepared measurement object, measures the position of an
// actual character (or fetches it from the cache).
function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
</P><PRE> if (prepared.before) { ch = -1 }
 var key = ch + (bias || &quot;&quot;), found
 if (prepared.cache.hasOwnProperty(key)) {
   found = prepared.cache[key]
 } else {
   if (!prepared.rect)
     { prepared.rect = prepared.view.text.getBoundingClientRect() }
   if (!prepared.hasHeights) {
     ensureLineHeights(cm, prepared.view, prepared.rect)
     prepared.hasHeights = true
   }
   found = measureCharInner(cm, prepared, ch, bias)
   if (!found.bogus) { prepared.cache[key] = found }
 }
 return {left: found.left, right: found.right,
         top: varHeight ? found.rtop : found.top,
         bottom: varHeight ? found.rbottom : found.bottom}
</PRE><P>}
</P><P>var nullRect = {left: 0, right: 0, top: 0, bottom: 0}
</P><P>function nodeAndOffsetInLineMap(map, ch, bias) {
</P><PRE> var node, start, end, collapse, mStart, mEnd
 // First, search the line map for the text node corresponding to,
 // or closest to, the target character.
 for (var i = 0; i &lt; map.length; i += 3) {
   mStart = map[i]
   mEnd = map[i + 1]
   if (ch &lt; mStart) {
     start = 0; end = 1
     collapse = &quot;left&quot;
   } else if (ch &lt; mEnd) {
     start = ch - mStart
     end = start + 1
   } else if (i == map.length - 3 || ch == mEnd &amp;&amp; map[i + 3] &gt; ch) {
     end = mEnd - mStart
     start = end - 1
     if (ch &gt;= mEnd) { collapse = &quot;right&quot; }
   }
   if (start != null) {
     node = map[i + 2]
     if (mStart == mEnd &amp;&amp; bias == (node.insertLeft ? &quot;left&quot; : &quot;right&quot;))
       { collapse = bias }
     if (bias == &quot;left&quot; &amp;&amp; start == 0)
       { while (i &amp;&amp; map[i - 2] == map[i - 3] &amp;&amp; map[i - 1].insertLeft) {
         node = map[(i -= 3) + 2]
         collapse = &quot;left&quot;
       } }
     if (bias == &quot;right&quot; &amp;&amp; start == mEnd - mStart)
       { while (i &lt; map.length - 3 &amp;&amp; map[i + 3] == map[i + 4] &amp;&amp; !map[i + 5].insertLeft) {
         node = map[(i += 3) + 2]
         collapse = &quot;right&quot;
       } }
     break
   }
 }
 return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
</PRE><P>}
</P><P>function getUsefulRect(rects, bias) {
</P><PRE> var rect = nullRect
 if (bias == &quot;left&quot;) { for (var i = 0; i &lt; rects.length; i++) {
   if ((rect = rects[i]).left != rect.right) { break }
 } } else { for (var i$1 = rects.length - 1; i$1 &gt;= 0; i$1--) {
   if ((rect = rects[i$1]).left != rect.right) { break }
 } }
 return rect
</PRE><P>}
</P><P>function measureCharInner(cm, prepared, ch, bias) {
</P><PRE> var place = nodeAndOffsetInLineMap(prepared.map, ch, bias)
 var node = place.node, start = place.start, end = place.end, collapse = place.collapse
</PRE><PRE> var rect
 if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
   for (var i$1 = 0; i$1 &lt; 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
     while (start &amp;&amp; isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start }
     while (place.coverStart + end &lt; place.coverEnd &amp;&amp; isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end }
     if (ie &amp;&amp; ie_version &lt; 9 &amp;&amp; start == 0 &amp;&amp; end == place.coverEnd - place.coverStart)
       { rect = node.parentNode.getBoundingClientRect() }
     else
       { rect = getUsefulRect(range(node, start, end).getClientRects(), bias) }
     if (rect.left || rect.right || start == 0) { break }
     end = start
     start = start - 1
     collapse = &quot;right&quot;
   }
   if (ie &amp;&amp; ie_version &lt; 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect) }
 } else { // If it is a widget, simply get the box for the whole widget.
   if (start &gt; 0) { collapse = bias = &quot;right&quot; }
   var rects
   if (cm.options.lineWrapping &amp;&amp; (rects = node.getClientRects()).length &gt; 1)
     { rect = rects[bias == &quot;right&quot; ? rects.length - 1 : 0] }
   else
     { rect = node.getBoundingClientRect() }
 }
 if (ie &amp;&amp; ie_version &lt; 9 &amp;&amp; !start &amp;&amp; (!rect || !rect.left &amp;&amp; !rect.right)) {
   var rSpan = node.parentNode.getClientRects()[0]
   if (rSpan)
     { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom} }
   else
     { rect = nullRect }
 }
</PRE><PRE> var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top
 var mid = (rtop + rbot) / 2
 var heights = prepared.view.measure.heights
 var i = 0
 for (; i &lt; heights.length - 1; i++)
   { if (mid &lt; heights[i]) { break } }
 var top = i ? heights[i - 1] : 0, bot = heights[i]
 var result = {left: (collapse == &quot;right&quot; ? rect.right : rect.left) - prepared.rect.left,
               right: (collapse == &quot;left&quot; ? rect.left : rect.right) - prepared.rect.left,
               top: top, bottom: bot}
 if (!rect.left &amp;&amp; !rect.right) { result.bogus = true }
 if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot }
</PRE><PRE> return result
</PRE><P>}
</P><P>// Work around problem with bounding client rects on ranges being
// returned incorrectly when zoomed on IE10 and below.
function maybeUpdateRectForZooming(measure, rect) {
</P><PRE> if (!window.screen || screen.logicalXDPI == null ||
     screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
   { return rect }
 var scaleX = screen.logicalXDPI / screen.deviceXDPI
 var scaleY = screen.logicalYDPI / screen.deviceYDPI
 return {left: rect.left * scaleX, right: rect.right * scaleX,
         top: rect.top * scaleY, bottom: rect.bottom * scaleY}
</PRE><P>}
</P><P>function clearLineMeasurementCacheFor(lineView) {
</P><PRE> if (lineView.measure) {
   lineView.measure.cache = {}
   lineView.measure.heights = null
   if (lineView.rest) { for (var i = 0; i &lt; lineView.rest.length; i++)
     { lineView.measure.caches[i] = {} } }
 }
</PRE><P>}
</P><P>function clearLineMeasurementCache(cm) {
</P><PRE> cm.display.externalMeasure = null
 removeChildren(cm.display.lineMeasure)
 for (var i = 0; i &lt; cm.display.view.length; i++)
   { clearLineMeasurementCacheFor(cm.display.view[i]) }
</PRE><P>}
</P><P>function clearCaches(cm) {
</P><PRE> clearLineMeasurementCache(cm)
 cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null
 if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true }
 cm.display.lineNumChars = null
</PRE><P>}
</P><P>function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft }
function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }
</P><P>// Converts a {top, bottom, left, right} box from line-local
// coordinates into another coordinate system. Context may be one of
// &quot;line&quot;, &quot;div&quot; (display.lineDiv), &quot;local&quot;./null (editor), &quot;window&quot;,
// or &quot;page&quot;.
function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
</P><PRE> if (!includeWidgets &amp;&amp; lineObj.widgets) { for (var i = 0; i &lt; lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {
   var size = widgetHeight(lineObj.widgets[i])
   rect.top += size; rect.bottom += size
 } } }
 if (context == &quot;line&quot;) { return rect }
 if (!context) { context = &quot;local&quot; }
 var yOff = heightAtLine(lineObj)
 if (context == &quot;local&quot;) { yOff += paddingTop(cm.display) }
 else { yOff -= cm.display.viewOffset }
 if (context == &quot;page&quot; || context == &quot;window&quot;) {
   var lOff = cm.display.lineSpace.getBoundingClientRect()
   yOff += lOff.top + (context == &quot;window&quot; ? 0 : pageScrollY())
   var xOff = lOff.left + (context == &quot;window&quot; ? 0 : pageScrollX())
   rect.left += xOff; rect.right += xOff
 }
 rect.top += yOff; rect.bottom += yOff
 return rect
</PRE><P>}
</P><P>// Coverts a box from &quot;div&quot; coords to another coordinate system.
// Context may be &quot;window&quot;, &quot;page&quot;, &quot;div&quot;, or &quot;local&quot;./null.
function fromCoordSystem(cm, coords, context) {
</P><PRE> if (context == &quot;div&quot;) { return coords }
 var left = coords.left, top = coords.top
 // First move into &quot;page&quot; coordinate system
 if (context == &quot;page&quot;) {
   left -= pageScrollX()
   top -= pageScrollY()
 } else if (context == &quot;local&quot; || !context) {
   var localBox = cm.display.sizer.getBoundingClientRect()
   left += localBox.left
   top += localBox.top
 }
</PRE><PRE> var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect()
 return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
</PRE><P>}
</P><P>function charCoords(cm, pos, context, lineObj, bias) {
</P><PRE> if (!lineObj) { lineObj = getLine(cm.doc, pos.line) }
 return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
</PRE><P>}
</P><P>// Returns a box for a given cursor position, which may have an
// 'other' property containing the position of the secondary cursor
// on a bidi boundary.
// A cursor Pos(line, char, &quot;before&quot;) is on the same visual line as `char - 1`
// and after `char - 1` in writing order of `char - 1`
// A cursor Pos(line, char, &quot;after&quot;) is on the same visual line as `char`
// and before `char` in writing order of `char`
// Examples (upper-case letters are RTL, lower-case are LTR):
//     Pos(0, 1, ...)
//     before   after
// ab     a|b     a|b
// aB     a|B     aB|
// Ab     |Ab     A|b
// AB     B|A     B|A
// Every position after the last character on a line is considered to stick
// to the last character on the line.
function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
</P><PRE> lineObj = lineObj || getLine(cm.doc, pos.line)
 if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj) }
 function get(ch, right) {
   var m = measureCharPrepared(cm, preparedMeasure, ch, right ? &quot;right&quot; : &quot;left&quot;, varHeight)
   if (right) { m.left = m.right; } else { m.right = m.left }
   return intoCoordSystem(cm, lineObj, m, context)
 }
 var order = getOrder(lineObj), ch = pos.ch, sticky = pos.sticky
 if (ch &gt;= lineObj.text.length) {
   ch = lineObj.text.length
   sticky = &quot;before&quot;
 } else if (ch &lt;= 0) {
   ch = 0
   sticky = &quot;after&quot;
 }
 if (!order) { return get(sticky == &quot;before&quot; ? ch - 1 : ch, sticky == &quot;before&quot;) }
</PRE><PRE> function getBidi(ch, partPos, invert) {
   var part = order[partPos], right = (part.level % 2) != 0
   return get(invert ? ch - 1 : ch, right != invert)
 }
 var partPos = getBidiPartAt(order, ch, sticky)
 var other = bidiOther
 var val = getBidi(ch, partPos, sticky == &quot;before&quot;)
 if (other != null) { val.other = getBidi(ch, other, sticky != &quot;before&quot;) }
 return val
</PRE><P>}
</P><P>// Used to cheaply estimate the coordinates for a position. Used for
// intermediate scroll updates.
function estimateCoords(cm, pos) {
</P><PRE> var left = 0
 pos = clipPos(cm.doc, pos)
 if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch }
 var lineObj = getLine(cm.doc, pos.line)
 var top = heightAtLine(lineObj) + paddingTop(cm.display)
 return {left: left, right: left, top: top, bottom: top + lineObj.height}
</PRE><P>}
</P><P>// Positions returned by coordsChar contain some extra information.
// xRel is the relative x position of the input coordinates compared
// to the found position (so xRel &gt; 0 means the coordinates are to
// the right of the character position, for example). When outside
// is true, that means the coordinates lie outside the line's
// vertical range.
function PosWithInfo(line, ch, sticky, outside, xRel) {
</P><PRE> var pos = Pos(line, ch, sticky)
 pos.xRel = xRel
 if (outside) { pos.outside = true }
 return pos
</PRE><P>}
</P><P>// Compute the character position closest to the given coordinates.
// Input must be lineSpace-local (&quot;div&quot; coordinate system).
function coordsChar(cm, x, y) {
</P><PRE> var doc = cm.doc
 y += cm.display.viewOffset
 if (y &lt; 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
 var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1
 if (lineN &gt; last)
   { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
 if (x &lt; 0) { x = 0 }
</PRE><PRE> var lineObj = getLine(doc, lineN)
 for (;;) {
   var found = coordsCharInner(cm, lineObj, lineN, x, y)
   var merged = collapsedSpanAtEnd(lineObj)
   var mergedPos = merged &amp;&amp; merged.find(0, true)
   if (merged &amp;&amp; (found.ch &gt; mergedPos.from.ch || found.ch == mergedPos.from.ch &amp;&amp; found.xRel &gt; 0))
     { lineN = lineNo(lineObj = mergedPos.to.line) }
   else
     { return found }
 }
</PRE><P>}
</P><P>function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
</P><PRE> var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), &quot;line&quot;); }
 var end = lineObj.text.length
 var begin = findFirst(function (ch) { return measure(ch - 1).bottom &lt;= y; }, end, 0)
 end = findFirst(function (ch) { return measure(ch).top &gt; y; }, begin, end)
 return {begin: begin, end: end}
</PRE><P>}
</P><P>function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
</P><PRE> var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), &quot;line&quot;).top
 return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
</PRE><P>}
</P><P>function coordsCharInner(cm, lineObj, lineNo, x, y) {
</P><PRE> y -= heightAtLine(lineObj)
 var begin = 0, end = lineObj.text.length
 var preparedMeasure = prepareMeasureForLine(cm, lineObj)
 var pos
 var order = getOrder(lineObj)
 if (order) {
   if (cm.options.lineWrapping) {
     ;var assign;
     ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign))
   }
   pos = new Pos(lineNo, begin)
   var beginLeft = cursorCoords(cm, pos, &quot;line&quot;, lineObj, preparedMeasure).left
   var dir = beginLeft &lt; x ? 1 : -1
   var prevDiff, diff = beginLeft - x, prevPos
   do {
     prevDiff = diff
     prevPos = pos
     pos = moveVisually(cm, lineObj, pos, dir)
     if (pos == null || pos.ch &lt; begin || end &lt;= (pos.sticky == &quot;before&quot; ? pos.ch - 1 : pos.ch)) {
       pos = prevPos
       break
     }
     diff = cursorCoords(cm, pos, &quot;line&quot;, lineObj, preparedMeasure).left - x
   } while ((dir &lt; 0) != (diff &lt; 0) &amp;&amp; (Math.abs(diff) &lt;= Math.abs(prevDiff)))
   if (Math.abs(diff) &gt; Math.abs(prevDiff)) {
     if ((diff &lt; 0) == (prevDiff &lt; 0)) { throw new Error(&quot;Broke out of infinite loop in coordsCharInner&quot;) }
     pos = prevPos
   }
 } else {
   var ch = findFirst(function (ch) {
     var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), &quot;line&quot;)
     if (box.top &gt; y) {
       // For the cursor stickiness
       end = Math.min(ch, end)
       return true
     }
     else if (box.bottom &lt;= y) { return false }
     else if (box.left &gt; x) { return true }
     else if (box.right &lt; x) { return false }
     else { return (x - box.left &lt; box.right - x) }
   }, begin, end)
   ch = skipExtendingChars(lineObj.text, ch, 1)
   pos = new Pos(lineNo, ch, ch == end ? &quot;before&quot; : &quot;after&quot;)
 }
 var coords = cursorCoords(cm, pos, &quot;line&quot;, lineObj, preparedMeasure)
 if (y &lt; coords.top || coords.bottom &lt; y) { pos.outside = true }
 pos.xRel = x &lt; coords.left ? -1 : (x &gt; coords.right ? 1 : 0)
 return pos
</PRE><P>}
</P><P>var measureText
// Compute the default text height.
function textHeight(display) {
</P><PRE> if (display.cachedTextHeight != null) { return display.cachedTextHeight }
 if (measureText == null) {
   measureText = elt(&quot;pre&quot;)
   // Measure a bunch of lines, for browsers that compute
   // fractional heights.
   for (var i = 0; i &lt; 49; ++i) {
     measureText.appendChild(document.createTextNode(&quot;x&quot;))
     measureText.appendChild(elt(&quot;br&quot;))
   }
   measureText.appendChild(document.createTextNode(&quot;x&quot;))
 }
 removeChildrenAndAdd(display.measure, measureText)
 var height = measureText.offsetHeight / 50
 if (height &gt; 3) { display.cachedTextHeight = height }
 removeChildren(display.measure)
 return height || 1
</PRE><P>}
</P><P>// Compute the default character width.
function charWidth(display) {
</P><PRE> if (display.cachedCharWidth != null) { return display.cachedCharWidth }
 var anchor = elt(&quot;span&quot;, &quot;xxxxxxxxxx&quot;)
 var pre = elt(&quot;pre&quot;, [anchor])
 removeChildrenAndAdd(display.measure, pre)
 var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10
 if (width &gt; 2) { display.cachedCharWidth = width }
 return width || 10
</PRE><P>}
</P><P>// Do a bulk-read of the DOM positions and sizes needed to draw the
// view, so that we don't interleave reading and writing to the DOM.
function getDimensions(cm) {
</P><PRE> var d = cm.display, left = {}, width = {}
 var gutterLeft = d.gutters.clientLeft
 for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
   left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft
   width[cm.options.gutters[i]] = n.clientWidth
 }
 return {fixedPos: compensateForHScroll(d),
         gutterTotalWidth: d.gutters.offsetWidth,
         gutterLeft: left,
         gutterWidth: width,
         wrapperWidth: d.wrapper.clientWidth}
</PRE><P>}
</P><P>// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
// but using getBoundingClientRect to get a sub-pixel-accurate
// result.
function compensateForHScroll(display) {
</P><PRE> return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
</PRE><P>}
</P><P>// Returns a function that estimates the height of a line, to use as
// first approximation until the line becomes visible (and is thus
// properly measurable).
function estimateHeight(cm) {
</P><PRE> var th = textHeight(cm.display), wrapping = cm.options.lineWrapping
 var perLine = wrapping &amp;&amp; Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3)
 return function (line) {
   if (lineIsHidden(cm.doc, line)) { return 0 }
</PRE><PRE>   var widgetsHeight = 0
   if (line.widgets) { for (var i = 0; i &lt; line.widgets.length; i++) {
     if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height }
   } }
</PRE><PRE>   if (wrapping)
     { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
   else
     { return widgetsHeight + th }
 }
</PRE><P>}
</P><P>function estimateLineHeights(cm) {
</P><PRE> var doc = cm.doc, est = estimateHeight(cm)
 doc.iter(function (line) {
   var estHeight = est(line)
   if (estHeight != line.height) { updateLineHeight(line, estHeight) }
 })
</PRE><P>}
</P><P>// Given a mouse event, find the corresponding position. If liberal
// is false, it checks whether a gutter or scrollbar was clicked,
// and returns null if it was. forRect is used by rectangular
// selections, and tries to estimate a character position even for
// coordinates beyond the right of the text.
function posFromMouse(cm, e, liberal, forRect) {
</P><PRE> var display = cm.display
 if (!liberal &amp;&amp; e_target(e).getAttribute(&quot;cm-not-content&quot;) == &quot;true&quot;) { return null }
</PRE><PRE> var x, y, space = display.lineSpace.getBoundingClientRect()
 // Fails unpredictably on IE[67] when mouse is dragged around quickly.
 try { x = e.clientX - space.left; y = e.clientY - space.top }
 catch (e) { return null }
 var coords = coordsChar(cm, x, y), line
 if (forRect &amp;&amp; coords.xRel == 1 &amp;&amp; (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
   var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length
   coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))
 }
 return coords
</PRE><P>}
</P><P>// Find the view element corresponding to a given line. Return null
// when the line isn't visible.
function findViewIndex(cm, n) {
</P><PRE> if (n &gt;= cm.display.viewTo) { return null }
 n -= cm.display.viewFrom
 if (n &lt; 0) { return null }
 var view = cm.display.view
 for (var i = 0; i &lt; view.length; i++) {
   n -= view[i].size
   if (n &lt; 0) { return i }
 }
</PRE><P>}
</P><P>function updateSelection(cm) {
</P><PRE> cm.display.input.showSelection(cm.display.input.prepareSelection())
</PRE><P>}
</P><P>function prepareSelection(cm, primary) {
</P><PRE> var doc = cm.doc, result = {}
 var curFragment = result.cursors = document.createDocumentFragment()
 var selFragment = result.selection = document.createDocumentFragment()
</PRE><PRE> for (var i = 0; i &lt; doc.sel.ranges.length; i++) {
   if (primary === false &amp;&amp; i == doc.sel.primIndex) { continue }
   var range = doc.sel.ranges[i]
   if (range.from().line &gt;= cm.display.viewTo || range.to().line &lt; cm.display.viewFrom) { continue }
   var collapsed = range.empty()
   if (collapsed || cm.options.showCursorWhenSelecting)
     { drawSelectionCursor(cm, range.head, curFragment) }
   if (!collapsed)
     { drawSelectionRange(cm, range, selFragment) }
 }
 return result
</PRE><P>}
</P><P>// Draws a cursor for the given range
function drawSelectionCursor(cm, head, output) {
</P><PRE> var pos = cursorCoords(cm, head, &quot;div&quot;, null, null, !cm.options.singleCursorHeightPerLine)
</PRE><PRE> var cursor = output.appendChild(elt(&quot;div&quot;, &quot;\u00a0&quot;, &quot;CodeMirror-cursor&quot;))
 cursor.style.left = pos.left + &quot;px&quot;
 cursor.style.top = pos.top + &quot;px&quot;
 cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + &quot;px&quot;
</PRE><PRE> if (pos.other) {
   // Secondary cursor, shown when on a 'jump' in bi-directional text
   var otherCursor = output.appendChild(elt(&quot;div&quot;, &quot;\u00a0&quot;, &quot;CodeMirror-cursor CodeMirror-secondarycursor&quot;))
   otherCursor.style.display = &quot;&quot;
   otherCursor.style.left = pos.other.left + &quot;px&quot;
   otherCursor.style.top = pos.other.top + &quot;px&quot;
   otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + &quot;px&quot;
 }
</PRE><P>}
</P><P>// Draws the given range as a highlighted selection
function drawSelectionRange(cm, range, output) {
</P><PRE> var display = cm.display, doc = cm.doc
 var fragment = document.createDocumentFragment()
 var padding = paddingH(cm.display), leftSide = padding.left
 var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right
</PRE><PRE> function add(left, top, width, bottom) {
   if (top &lt; 0) { top = 0 }
   top = Math.round(top)
   bottom = Math.round(bottom)
   fragment.appendChild(elt(&quot;div&quot;, null, &quot;CodeMirror-selected&quot;, (&quot;position: absolute; left: &quot; + left + &quot;px;\n                             top: &quot; + top + &quot;px; width: &quot; + (width == null ? rightSide - left : width) + &quot;px;\n                             height: &quot; + (bottom - top) + &quot;px&quot;)))
 }
</PRE><PRE> function drawForLine(line, fromArg, toArg) {
   var lineObj = getLine(doc, line)
   var lineLen = lineObj.text.length
   var start, end
   function coords(ch, bias) {
     return charCoords(cm, Pos(line, ch), &quot;div&quot;, lineObj, bias)
   }
</PRE><PRE>   iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
     var leftPos = coords(from, &quot;left&quot;), rightPos, left, right
     if (from == to) {
       rightPos = leftPos
       left = right = leftPos.left
     } else {
       rightPos = coords(to - 1, &quot;right&quot;)
       if (dir == &quot;rtl&quot;) { var tmp = leftPos; leftPos = rightPos; rightPos = tmp }
       left = leftPos.left
       right = rightPos.right
     }
     if (fromArg == null &amp;&amp; from == 0) { left = leftSide }
     if (rightPos.top - leftPos.top &gt; 3) { // Different lines, draw top part
       add(left, leftPos.top, null, leftPos.bottom)
       left = leftSide
       if (leftPos.bottom &lt; rightPos.top) { add(left, leftPos.bottom, null, rightPos.top) }
     }
     if (toArg == null &amp;&amp; to == lineLen) { right = rightSide }
     if (!start || leftPos.top &lt; start.top || leftPos.top == start.top &amp;&amp; leftPos.left &lt; start.left)
       { start = leftPos }
     if (!end || rightPos.bottom &gt; end.bottom || rightPos.bottom == end.bottom &amp;&amp; rightPos.right &gt; end.right)
       { end = rightPos }
     if (left &lt; leftSide + 1) { left = leftSide }
     add(left, rightPos.top, right - left, rightPos.bottom)
   })
   return {start: start, end: end}
 }
</PRE><PRE> var sFrom = range.from(), sTo = range.to()
 if (sFrom.line == sTo.line) {
   drawForLine(sFrom.line, sFrom.ch, sTo.ch)
 } else {
   var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line)
   var singleVLine = visualLine(fromLine) == visualLine(toLine)
   var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end
   var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start
   if (singleVLine) {
     if (leftEnd.top &lt; rightStart.top - 2) {
       add(leftEnd.right, leftEnd.top, null, leftEnd.bottom)
       add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)
     } else {
       add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)
     }
   }
   if (leftEnd.bottom &lt; rightStart.top)
     { add(leftSide, leftEnd.bottom, null, rightStart.top) }
 }
</PRE><PRE> output.appendChild(fragment)
</PRE><P>}
</P><P>// Cursor-blinking
function restartBlink(cm) {
</P><PRE> if (!cm.state.focused) { return }
 var display = cm.display
 clearInterval(display.blinker)
 var on = true
 display.cursorDiv.style.visibility = &quot;&quot;
 if (cm.options.cursorBlinkRate &gt; 0)
   { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? &quot;&quot; : &quot;hidden&quot;; },
     cm.options.cursorBlinkRate) }
 else if (cm.options.cursorBlinkRate &lt; 0)
   { display.cursorDiv.style.visibility = &quot;hidden&quot; }
</PRE><P>}
</P><P>function ensureFocus(cm) {
</P><PRE> if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm) }
</PRE><P>}
</P><P>function delayBlurEvent(cm) {
</P><PRE> cm.state.delayingBlurEvent = true
 setTimeout(function () { if (cm.state.delayingBlurEvent) {
   cm.state.delayingBlurEvent = false
   onBlur(cm)
 } }, 100)
</PRE><P>}
</P><P>function onFocus(cm, e) {
</P><PRE> if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false }
</PRE><PRE> if (cm.options.readOnly == &quot;nocursor&quot;) { return }
 if (!cm.state.focused) {
   signal(cm, &quot;focus&quot;, cm, e)
   cm.state.focused = true
   addClass(cm.display.wrapper, &quot;CodeMirror-focused&quot;)
   // This test prevents this from firing when a context
   // menu is closed (since the input reset would kill the
   // select-all detection hack)
   if (!cm.curOp &amp;&amp; cm.display.selForContextMenu != cm.doc.sel) {
     cm.display.input.reset()
     if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20) } // Issue #1730
   }
   cm.display.input.receivedFocus()
 }
 restartBlink(cm)
</PRE><P>}
function onBlur(cm, e) {
</P><PRE> if (cm.state.delayingBlurEvent) { return }
</PRE><PRE> if (cm.state.focused) {
   signal(cm, &quot;blur&quot;, cm, e)
   cm.state.focused = false
   rmClass(cm.display.wrapper, &quot;CodeMirror-focused&quot;)
 }
 clearInterval(cm.display.blinker)
 setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false } }, 150)
</PRE><P>}
</P><P>// Re-align line numbers and gutter marks to compensate for
// horizontal scrolling.
function alignHorizontally(cm) {
</P><PRE> var display = cm.display, view = display.view
 if (!display.alignWidgets &amp;&amp; (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
 var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft
 var gutterW = display.gutters.offsetWidth, left = comp + &quot;px&quot;
 for (var i = 0; i &lt; view.length; i++) { if (!view[i].hidden) {
   if (cm.options.fixedGutter) {
     if (view[i].gutter)
       { view[i].gutter.style.left = left }
     if (view[i].gutterBackground)
       { view[i].gutterBackground.style.left = left }
   }
   var align = view[i].alignable
   if (align) { for (var j = 0; j &lt; align.length; j++)
     { align[j].style.left = left } }
 } }
 if (cm.options.fixedGutter)
   { display.gutters.style.left = (comp + gutterW) + &quot;px&quot; }
</PRE><P>}
</P><P>// Used to ensure that the line number gutter is still the right
// size for the current document size. Returns true when an update
// is needed.
function maybeUpdateLineNumberWidth(cm) {
</P><PRE> if (!cm.options.lineNumbers) { return false }
 var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display
 if (last.length != display.lineNumChars) {
   var test = display.measure.appendChild(elt(&quot;div&quot;, [elt(&quot;div&quot;, last)],
                                              &quot;CodeMirror-linenumber CodeMirror-gutter-elt&quot;))
   var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW
   display.lineGutter.style.width = &quot;&quot;
   display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1
   display.lineNumWidth = display.lineNumInnerWidth + padding
   display.lineNumChars = display.lineNumInnerWidth ? last.length : -1
   display.lineGutter.style.width = display.lineNumWidth + &quot;px&quot;
   updateGutterSpace(cm)
   return true
 }
 return false
</PRE><P>}
</P><P>// Read the actual heights of the rendered lines, and update their
// stored heights to match.
function updateHeightsInViewport(cm) {
</P><PRE> var display = cm.display
 var prevBottom = display.lineDiv.offsetTop
 for (var i = 0; i &lt; display.view.length; i++) {
   var cur = display.view[i], height = (void 0)
   if (cur.hidden) { continue }
   if (ie &amp;&amp; ie_version &lt; 8) {
     var bot = cur.node.offsetTop + cur.node.offsetHeight
     height = bot - prevBottom
     prevBottom = bot
   } else {
     var box = cur.node.getBoundingClientRect()
     height = box.bottom - box.top
   }
   var diff = cur.line.height - height
   if (height &lt; 2) { height = textHeight(display) }
   if (diff &gt; .001 || diff &lt; -.001) {
     updateLineHeight(cur.line, height)
     updateWidgetHeight(cur.line)
     if (cur.rest) { for (var j = 0; j &lt; cur.rest.length; j++)
       { updateWidgetHeight(cur.rest[j]) } }
   }
 }
</PRE><P>}
</P><P>// Read and store the height of line widgets associated with the
// given line.
function updateWidgetHeight(line) {
</P><PRE> if (line.widgets) { for (var i = 0; i &lt; line.widgets.length; ++i)
   { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight } }
</PRE><P>}
</P><P>// Compute the lines that are visible in a given viewport (defaults
// the the current scroll position). viewport may contain top,
// height, and ensure (see op.scrollToPos) properties.
function visibleLines(display, doc, viewport) {
</P><PRE> var top = viewport &amp;&amp; viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop
 top = Math.floor(top - paddingTop(display))
 var bottom = viewport &amp;&amp; viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight
</PRE><PRE> var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom)
 // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
 // forces those lines into the viewport (if possible).
 if (viewport &amp;&amp; viewport.ensure) {
   var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line
   if (ensureFrom &lt; from) {
     from = ensureFrom
     to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)
   } else if (Math.min(ensureTo, doc.lastLine()) &gt;= to) {
     from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight)
     to = ensureTo
   }
 }
 return {from: from, to: Math.max(to, from + 1)}
</PRE><P>}
</P><P>// Sync the scrollable area and scrollbars, ensure the viewport
// covers the visible area.
function setScrollTop(cm, val) {
</P><PRE> if (Math.abs(cm.doc.scrollTop - val) &lt; 2) { return }
 cm.doc.scrollTop = val
 if (!gecko) { updateDisplaySimple(cm, {top: val}) }
 if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val }
 cm.display.scrollbars.setScrollTop(val)
 if (gecko) { updateDisplaySimple(cm) }
 startWorker(cm, 100)
</PRE><P>}
// Sync scroller and scrollbar, ensure the gutter elements are
// aligned.
function setScrollLeft(cm, val, isScroller) {
</P><PRE> if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) &lt; 2) { return }
 val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth)
 cm.doc.scrollLeft = val
 alignHorizontally(cm)
 if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val }
 cm.display.scrollbars.setScrollLeft(val)
</PRE><P>}
</P><P>// Since the delta values reported on mouse wheel events are
// unstandardized between browsers and even browser versions, and
// generally horribly unpredictable, this code starts by measuring
// the scroll effect that the first few mouse wheel events have,
// and, from that, detects the way it can convert deltas to pixel
// offsets afterwards.
//
// The reason we want to know the amount a wheel event will scroll
// is that it gives us a chance to update the display before the
// actual scrolling happens, reducing flickering.
</P><P>var wheelSamples = 0;
var wheelPixelsPerUnit = null;
// Fill in a browser-detected starting value on browsers where we
// know one. These don't have to be accurate -- the result of them
// being wrong would just be a slight flicker on the first wheel
// scroll (if it is large enough).
if (ie) { wheelPixelsPerUnit = -.53 }
else if (gecko) { wheelPixelsPerUnit = 15 }
else if (chrome) { wheelPixelsPerUnit = -.7 }
else if (safari) { wheelPixelsPerUnit = -1/3 }
</P><P>function wheelEventDelta(e) {
</P><PRE> var dx = e.wheelDeltaX, dy = e.wheelDeltaY
 if (dx == null &amp;&amp; e.detail &amp;&amp; e.axis == e.HORIZONTAL_AXIS) { dx = e.detail }
 if (dy == null &amp;&amp; e.detail &amp;&amp; e.axis == e.VERTICAL_AXIS) { dy = e.detail }
 else if (dy == null) { dy = e.wheelDelta }
 return {x: dx, y: dy}
</PRE><P>}
function wheelEventPixels(e) {
</P><PRE> var delta = wheelEventDelta(e)
 delta.x *= wheelPixelsPerUnit
 delta.y *= wheelPixelsPerUnit
 return delta
</PRE><P>}
</P><P>function onScrollWheel(cm, e) {
</P><PRE> var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y
</PRE><PRE> var display = cm.display, scroll = display.scroller
 // Quit if there's nothing to scroll here
 var canScrollX = scroll.scrollWidth &gt; scroll.clientWidth
 var canScrollY = scroll.scrollHeight &gt; scroll.clientHeight
 if (!(dx &amp;&amp; canScrollX || dy &amp;&amp; canScrollY)) { return }
</PRE><PRE> // Webkit browsers on OS X abort momentum scrolls when the target
 // of the scroll event is removed from the scrollable element.
 // This hack (see related code in patchDisplay) makes sure the
 // element is kept around.
 if (dy &amp;&amp; mac &amp;&amp; webkit) {
   outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
     for (var i = 0; i &lt; view.length; i++) {
       if (view[i].node == cur) {
         cm.display.currentWheelTarget = cur
         break outer
       }
     }
   }
 }
</PRE><PRE> // On some browsers, horizontal scrolling will cause redraws to
 // happen before the gutter has been realigned, causing it to
 // wriggle around in a most unseemly way. When we have an
 // estimated pixels/delta value, we just handle horizontal
 // scrolling entirely here. It'll be slightly off from native, but
 // better than glitching out.
 if (dx &amp;&amp; !gecko &amp;&amp; !presto &amp;&amp; wheelPixelsPerUnit != null) {
   if (dy &amp;&amp; canScrollY)
     { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))) }
   setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)))
   // Only prevent default scrolling if vertical scrolling is
   // actually possible. Otherwise, it causes vertical scroll
   // jitter on OSX trackpads when deltaX is small and deltaY
   // is large (issue #3579)
   if (!dy || (dy &amp;&amp; canScrollY))
     { e_preventDefault(e) }
   display.wheelStartX = null // Abort measurement, if in progress
   return
 }
</PRE><PRE> // 'Project' the visible viewport to cover the area that is being
 // scrolled into view (if we know enough to estimate it).
 if (dy &amp;&amp; wheelPixelsPerUnit != null) {
   var pixels = dy * wheelPixelsPerUnit
   var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight
   if (pixels &lt; 0) { top = Math.max(0, top + pixels - 50) }
   else { bot = Math.min(cm.doc.height, bot + pixels + 50) }
   updateDisplaySimple(cm, {top: top, bottom: bot})
 }
</PRE><PRE> if (wheelSamples &lt; 20) {
   if (display.wheelStartX == null) {
     display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop
     display.wheelDX = dx; display.wheelDY = dy
     setTimeout(function () {
       if (display.wheelStartX == null) { return }
       var movedX = scroll.scrollLeft - display.wheelStartX
       var movedY = scroll.scrollTop - display.wheelStartY
       var sample = (movedY &amp;&amp; display.wheelDY &amp;&amp; movedY / display.wheelDY) ||
         (movedX &amp;&amp; display.wheelDX &amp;&amp; movedX / display.wheelDX)
       display.wheelStartX = display.wheelStartY = null
       if (!sample) { return }
       wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1)
       ++wheelSamples
     }, 200)
   } else {
     display.wheelDX += dx; display.wheelDY += dy
   }
 }
</PRE><P>}
</P><P>// SCROLLBARS
</P><P>// Prepare DOM reads needed to update the scrollbars. Done in one
// shot to minimize update/measure roundtrips.
function measureForScrollbars(cm) {
</P><PRE> var d = cm.display, gutterW = d.gutters.offsetWidth
 var docH = Math.round(cm.doc.height + paddingVert(cm.display))
 return {
   clientHeight: d.scroller.clientHeight,
   viewHeight: d.wrapper.clientHeight,
   scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
   viewWidth: d.wrapper.clientWidth,
   barLeft: cm.options.fixedGutter ? gutterW : 0,
   docHeight: docH,
   scrollHeight: docH + scrollGap(cm) + d.barHeight,
   nativeBarWidth: d.nativeBarWidth,
   gutterWidth: gutterW
 }
</PRE><P>}
</P><P>var NativeScrollbars = function(place, scroll, cm) {
</P><PRE> this.cm = cm
 var vert = this.vert = elt(&quot;div&quot;, [elt(&quot;div&quot;, null, null, &quot;min-width: 1px&quot;)], &quot;CodeMirror-vscrollbar&quot;)
 var horiz = this.horiz = elt(&quot;div&quot;, [elt(&quot;div&quot;, null, null, &quot;height: 100%; min-height: 1px&quot;)], &quot;CodeMirror-hscrollbar&quot;)
 place(vert); place(horiz)
</PRE><PRE> on(vert, &quot;scroll&quot;, function () {
   if (vert.clientHeight) { scroll(vert.scrollTop, &quot;vertical&quot;) }
 })
 on(horiz, &quot;scroll&quot;, function () {
   if (horiz.clientWidth) { scroll(horiz.scrollLeft, &quot;horizontal&quot;) }
 })
</PRE><PRE> this.checkedZeroWidth = false
 // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
 if (ie &amp;&amp; ie_version &lt; 8) { this.horiz.style.minHeight = this.vert.style.minWidth = &quot;18px&quot; }
</PRE><P>};
</P><P>NativeScrollbars.prototype.update = function (measure) {
</P><PRE> var needsH = measure.scrollWidth &gt; measure.clientWidth + 1
 var needsV = measure.scrollHeight &gt; measure.clientHeight + 1
 var sWidth = measure.nativeBarWidth
</PRE><PRE> if (needsV) {
   this.vert.style.display = &quot;block&quot;
   this.vert.style.bottom = needsH ? sWidth + &quot;px&quot; : &quot;0&quot;
   var totalHeight = measure.viewHeight - (needsH ? sWidth : 0)
   // A bug in IE8 can cause this value to be negative, so guard it.
   this.vert.firstChild.style.height =
     Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + &quot;px&quot;
 } else {
   this.vert.style.display = &quot;&quot;
   this.vert.firstChild.style.height = &quot;0&quot;
 }
</PRE><PRE> if (needsH) {
   this.horiz.style.display = &quot;block&quot;
   this.horiz.style.right = needsV ? sWidth + &quot;px&quot; : &quot;0&quot;
   this.horiz.style.left = measure.barLeft + &quot;px&quot;
   var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0)
   this.horiz.firstChild.style.width =
     Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + &quot;px&quot;
 } else {
   this.horiz.style.display = &quot;&quot;
   this.horiz.firstChild.style.width = &quot;0&quot;
 }
</PRE><PRE> if (!this.checkedZeroWidth &amp;&amp; measure.clientHeight &gt; 0) {
   if (sWidth == 0) { this.zeroWidthHack() }
   this.checkedZeroWidth = true
 }
</PRE><PRE> return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
</PRE><P>};
</P><P>NativeScrollbars.prototype.setScrollLeft = function (pos) {
</P><PRE> if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos }
 if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz) }
</PRE><P>};
</P><P>NativeScrollbars.prototype.setScrollTop = function (pos) {
</P><PRE> if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos }
 if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert) }
</PRE><P>};
</P><P>NativeScrollbars.prototype.zeroWidthHack = function () {
</P><PRE> var w = mac &amp;&amp; !mac_geMountainLion ? &quot;12px&quot; : &quot;18px&quot;
 this.horiz.style.height = this.vert.style.width = w
 this.horiz.style.pointerEvents = this.vert.style.pointerEvents = &quot;none&quot;
 this.disableHoriz = new Delayed
 this.disableVert = new Delayed
</PRE><P>};
</P><P>NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay) {
</P><PRE> bar.style.pointerEvents = &quot;auto&quot;
 function maybeDisable() {
   // To find out whether the scrollbar is still visible, we
   // check whether the element under the pixel in the bottom
   // left corner of the scrollbar box is the scrollbar box
   // itself (when the bar is still visible) or its filler child
   // (when the bar is hidden). If it is still visible, we keep
   // it enabled, if it's hidden, we disable pointer events.
   var box = bar.getBoundingClientRect()
   var elt = document.elementFromPoint(box.left + 1, box.bottom - 1)
   if (elt != bar) { bar.style.pointerEvents = &quot;none&quot; }
   else { delay.set(1000, maybeDisable) }
 }
 delay.set(1000, maybeDisable)
</PRE><P>};
</P><P>NativeScrollbars.prototype.clear = function () {
</P><PRE> var parent = this.horiz.parentNode
 parent.removeChild(this.horiz)
 parent.removeChild(this.vert)
</PRE><P>};
</P><P>var NullScrollbars = function () {};
</P><P>NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
NullScrollbars.prototype.setScrollLeft = function () {};
NullScrollbars.prototype.setScrollTop = function () {};
NullScrollbars.prototype.clear = function () {};
</P><P>function updateScrollbars(cm, measure) {
</P><PRE> if (!measure) { measure = measureForScrollbars(cm) }
 var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight
 updateScrollbarsInner(cm, measure)
 for (var i = 0; i &lt; 4 &amp;&amp; startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
   if (startWidth != cm.display.barWidth &amp;&amp; cm.options.lineWrapping)
     { updateHeightsInViewport(cm) }
   updateScrollbarsInner(cm, measureForScrollbars(cm))
   startWidth = cm.display.barWidth; startHeight = cm.display.barHeight
 }
</PRE><P>}
</P><P>// Re-synchronize the fake scrollbars with the actual size of the
// content.
function updateScrollbarsInner(cm, measure) {
</P><PRE> var d = cm.display
 var sizes = d.scrollbars.update(measure)
</PRE><PRE> d.sizer.style.paddingRight = (d.barWidth = sizes.right) + &quot;px&quot;
 d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + &quot;px&quot;
 d.heightForcer.style.borderBottom = sizes.bottom + &quot;px solid transparent&quot;
</PRE><PRE> if (sizes.right &amp;&amp; sizes.bottom) {
   d.scrollbarFiller.style.display = &quot;block&quot;
   d.scrollbarFiller.style.height = sizes.bottom + &quot;px&quot;
   d.scrollbarFiller.style.width = sizes.right + &quot;px&quot;
 } else { d.scrollbarFiller.style.display = &quot;&quot; }
 if (sizes.bottom &amp;&amp; cm.options.coverGutterNextToScrollbar &amp;&amp; cm.options.fixedGutter) {
   d.gutterFiller.style.display = &quot;block&quot;
   d.gutterFiller.style.height = sizes.bottom + &quot;px&quot;
   d.gutterFiller.style.width = measure.gutterWidth + &quot;px&quot;
 } else { d.gutterFiller.style.display = &quot;&quot; }
</PRE><P>}
</P><P>var scrollbarModel = {&quot;native&quot;: NativeScrollbars, &quot;null&quot;: NullScrollbars}
</P><P>function initScrollbars(cm) {
</P><PRE> if (cm.display.scrollbars) {
   cm.display.scrollbars.clear()
   if (cm.display.scrollbars.addClass)
     { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass) }
 }
</PRE><PRE> cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
   cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller)
   // Prevent clicks in the scrollbars from killing focus
   on(node, &quot;mousedown&quot;, function () {
     if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0) }
   })
   node.setAttribute(&quot;cm-not-content&quot;, &quot;true&quot;)
 }, function (pos, axis) {
   if (axis == &quot;horizontal&quot;) { setScrollLeft(cm, pos) }
   else { setScrollTop(cm, pos) }
 }, cm)
 if (cm.display.scrollbars.addClass)
   { addClass(cm.display.wrapper, cm.display.scrollbars.addClass) }
</PRE><P>}
</P><P>// SCROLLING THINGS INTO VIEW
</P><P>// If an editor sits on the top or bottom of the window, partially
// scrolled out of view, this ensures that the cursor is visible.
function maybeScrollWindow(cm, coords) {
</P><PRE> if (signalDOMEvent(cm, &quot;scrollCursorIntoView&quot;)) { return }
</PRE><PRE> var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null
 if (coords.top + box.top &lt; 0) { doScroll = true }
 else if (coords.bottom + box.top &gt; (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false }
 if (doScroll != null &amp;&amp; !phantom) {
   var scrollNode = elt(&quot;div&quot;, &quot;\u200b&quot;, null, (&quot;position: absolute;\n                         top: &quot; + (coords.top - display.viewOffset - paddingTop(cm.display)) + &quot;px;\n                         height: &quot; + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + &quot;px;\n                         left: &quot; + (coords.left) + &quot;px; width: 2px;&quot;))
   cm.display.lineSpace.appendChild(scrollNode)
   scrollNode.scrollIntoView(doScroll)
   cm.display.lineSpace.removeChild(scrollNode)
 }
</PRE><P>}
</P><P>// Scroll a given position into view (immediately), verifying that
// it actually became visible (as line heights are accurately
// measured, the position of something may 'drift' during drawing).
function scrollPosIntoView(cm, pos, end, margin) {
</P><PRE> if (margin == null) { margin = 0 }
 var coords
 for (var limit = 0; limit &lt; 5; limit++) {
   var changed = false
   coords = cursorCoords(cm, pos)
   var endCoords = !end || end == pos ? coords : cursorCoords(cm, end)
   var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                      Math.min(coords.top, endCoords.top) - margin,
                                      Math.max(coords.left, endCoords.left),
                                      Math.max(coords.bottom, endCoords.bottom) + margin)
   var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft
   if (scrollPos.scrollTop != null) {
     setScrollTop(cm, scrollPos.scrollTop)
     if (Math.abs(cm.doc.scrollTop - startTop) &gt; 1) { changed = true }
   }
   if (scrollPos.scrollLeft != null) {
     setScrollLeft(cm, scrollPos.scrollLeft)
     if (Math.abs(cm.doc.scrollLeft - startLeft) &gt; 1) { changed = true }
   }
   if (!changed) { break }
 }
 return coords
</PRE><P>}
</P><P>// Scroll a given set of coordinates into view (immediately).
function scrollIntoView(cm, x1, y1, x2, y2) {
</P><PRE> var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2)
 if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop) }
 if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft) }
</PRE><P>}
</P><P>// Calculate a new scroll position needed to scroll the given
// rectangle into view. Returns an object with scrollTop and
// scrollLeft properties. When these are undefined, the
// vertical/horizontal position does not need to be adjusted.
function calculateScrollPos(cm, x1, y1, x2, y2) {
</P><PRE> var display = cm.display, snapMargin = textHeight(cm.display)
 if (y1 &lt; 0) { y1 = 0 }
 var screentop = cm.curOp &amp;&amp; cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop
 var screen = displayHeight(cm), result = {}
 if (y2 - y1 &gt; screen) { y2 = y1 + screen }
 var docBottom = cm.doc.height + paddingVert(display)
 var atTop = y1 &lt; snapMargin, atBottom = y2 &gt; docBottom - snapMargin
 if (y1 &lt; screentop) {
   result.scrollTop = atTop ? 0 : y1
 } else if (y2 &gt; screentop + screen) {
   var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen)
   if (newTop != screentop) { result.scrollTop = newTop }
 }
</PRE><PRE> var screenleft = cm.curOp &amp;&amp; cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft
 var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0)
 var tooWide = x2 - x1 &gt; screenw
 if (tooWide) { x2 = x1 + screenw }
 if (x1 &lt; 10)
   { result.scrollLeft = 0 }
 else if (x1 &lt; screenleft)
   { result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) }
 else if (x2 &gt; screenw + screenleft - 3)
   { result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw }
 return result
</PRE><P>}
</P><P>// Store a relative adjustment to the scroll position in the current
// operation (to be applied when the operation finishes).
function addToScrollPos(cm, left, top) {
</P><PRE> if (left != null || top != null) { resolveScrollToPos(cm) }
 if (left != null)
   { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left }
 if (top != null)
   { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top }
</PRE><P>}
</P><P>// Make sure that at the end of the operation the current cursor is
// shown.
function ensureCursorVisible(cm) {
</P><PRE> resolveScrollToPos(cm)
 var cur = cm.getCursor(), from = cur, to = cur
 if (!cm.options.lineWrapping) {
   from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur
   to = Pos(cur.line, cur.ch + 1)
 }
 cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true}
</PRE><P>}
</P><P>// When an operation has its scrollToPos property set, and another
// scroll action is applied before the end of the operation, this
// 'simulates' scrolling that position into view in a cheap way, so
// that the effect of intermediate scroll commands is not ignored.
function resolveScrollToPos(cm) {
</P><PRE> var range = cm.curOp.scrollToPos
 if (range) {
   cm.curOp.scrollToPos = null
   var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to)
   var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                 Math.min(from.top, to.top) - range.margin,
                                 Math.max(from.right, to.right),
                                 Math.max(from.bottom, to.bottom) + range.margin)
   cm.scrollTo(sPos.scrollLeft, sPos.scrollTop)
 }
</PRE><P>}
</P><P>// Operations are used to wrap a series of changes to the editor
// state in such a way that each change won't have to update the
// cursor and display (which would be awkward, slow, and
// error-prone). Instead, display updates are batched and then all
// combined and executed at once.
</P><P>var nextOpId = 0
// Start a new operation.
function startOperation(cm) {
</P><PRE> cm.curOp = {
   cm: cm,
   viewChanged: false,      // Flag that indicates that lines might need to be redrawn
   startHeight: cm.doc.height, // Used to detect need to update scrollbar
   forceUpdate: false,      // Used to force a redraw
   updateInput: null,       // Whether to reset the input textarea
   typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
   changeObjs: null,        // Accumulated changes, for firing change events
   cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
   cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
   selectionChanged: false, // Whether the selection needs to be redrawn
   updateMaxLine: false,    // Set when the widest line needs to be determined anew
   scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
   scrollToPos: null,       // Used to scroll to a specific position
   focus: false,
   id: ++nextOpId           // Unique ID
 }
 pushOperation(cm.curOp)
</PRE><P>}
</P><P>// Finish an operation, updating the display and signalling delayed events
function endOperation(cm) {
</P><PRE> var op = cm.curOp
 finishOperation(op, function (group) {
   for (var i = 0; i &lt; group.ops.length; i++)
     { group.ops[i].cm.curOp = null }
   endOperations(group)
 })
</PRE><P>}
</P><P>// The DOM updates done when an operation finishes are batched so
// that the minimum number of relayouts are required.
function endOperations(group) {
</P><PRE> var ops = group.ops
 for (var i = 0; i &lt; ops.length; i++) // Read DOM
   { endOperation_R1(ops[i]) }
 for (var i$1 = 0; i$1 &lt; ops.length; i$1++) // Write DOM (maybe)
   { endOperation_W1(ops[i$1]) }
 for (var i$2 = 0; i$2 &lt; ops.length; i$2++) // Read DOM
   { endOperation_R2(ops[i$2]) }
 for (var i$3 = 0; i$3 &lt; ops.length; i$3++) // Write DOM (maybe)
   { endOperation_W2(ops[i$3]) }
 for (var i$4 = 0; i$4 &lt; ops.length; i$4++) // Read DOM
   { endOperation_finish(ops[i$4]) }
</PRE><P>}
</P><P>function endOperation_R1(op) {
</P><PRE> var cm = op.cm, display = cm.display
 maybeClipScrollbars(cm)
 if (op.updateMaxLine) { findMaxLine(cm) }
</PRE><PRE> op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
   op.scrollToPos &amp;&amp; (op.scrollToPos.from.line &lt; display.viewFrom ||
                      op.scrollToPos.to.line &gt;= display.viewTo) ||
   display.maxLineChanged &amp;&amp; cm.options.lineWrapping
 op.update = op.mustUpdate &amp;&amp;
   new DisplayUpdate(cm, op.mustUpdate &amp;&amp; {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate)
</PRE><P>}
</P><P>function endOperation_W1(op) {
</P><PRE> op.updatedDisplay = op.mustUpdate &amp;&amp; updateDisplayIfNeeded(op.cm, op.update)
</PRE><P>}
</P><P>function endOperation_R2(op) {
</P><PRE> var cm = op.cm, display = cm.display
 if (op.updatedDisplay) { updateHeightsInViewport(cm) }
</PRE><PRE> op.barMeasure = measureForScrollbars(cm)
</PRE><PRE> // If the max line changed since it was last measured, measure it,
 // and ensure the document's width matches it.
 // updateDisplay_W2 will use these properties to do the actual resizing
 if (display.maxLineChanged &amp;&amp; !cm.options.lineWrapping) {
   op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3
   cm.display.sizerWidth = op.adjustWidthTo
   op.barMeasure.scrollWidth =
     Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth)
   op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))
 }
</PRE><PRE> if (op.updatedDisplay || op.selectionChanged)
   { op.preparedSelection = display.input.prepareSelection(op.focus) }
</PRE><P>}
</P><P>function endOperation_W2(op) {
</P><PRE> var cm = op.cm
</PRE><PRE> if (op.adjustWidthTo != null) {
   cm.display.sizer.style.minWidth = op.adjustWidthTo + &quot;px&quot;
   if (op.maxScrollLeft &lt; cm.doc.scrollLeft)
     { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true) }
   cm.display.maxLineChanged = false
 }
</PRE><PRE> var takeFocus = op.focus &amp;&amp; op.focus == activeElt() &amp;&amp; (!document.hasFocus || document.hasFocus())
 if (op.preparedSelection)
   { cm.display.input.showSelection(op.preparedSelection, takeFocus) }
 if (op.updatedDisplay || op.startHeight != cm.doc.height)
   { updateScrollbars(cm, op.barMeasure) }
 if (op.updatedDisplay)
   { setDocumentHeight(cm, op.barMeasure) }
</PRE><PRE> if (op.selectionChanged) { restartBlink(cm) }
</PRE><PRE> if (cm.state.focused &amp;&amp; op.updateInput)
   { cm.display.input.reset(op.typing) }
 if (takeFocus) { ensureFocus(op.cm) }
</PRE><P>}
</P><P>function endOperation_finish(op) {
</P><PRE> var cm = op.cm, display = cm.display, doc = cm.doc
</PRE><PRE> if (op.updatedDisplay) { postUpdateDisplay(cm, op.update) }
</PRE><PRE> // Abort mouse wheel delta measurement, when scrolling explicitly
 if (display.wheelStartX != null &amp;&amp; (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
   { display.wheelStartX = display.wheelStartY = null }
</PRE><PRE> // Propagate the scroll position to the actual DOM scroller
 if (op.scrollTop != null &amp;&amp; (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
   doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop))
   display.scrollbars.setScrollTop(doc.scrollTop)
   display.scroller.scrollTop = doc.scrollTop
 }
 if (op.scrollLeft != null &amp;&amp; (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
   doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft))
   display.scrollbars.setScrollLeft(doc.scrollLeft)
   display.scroller.scrollLeft = doc.scrollLeft
   alignHorizontally(cm)
 }
 // If we need to scroll a specific position into view, do so.
 if (op.scrollToPos) {
   var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                  clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin)
   if (op.scrollToPos.isCursor &amp;&amp; cm.state.focused) { maybeScrollWindow(cm, coords) }
 }
</PRE><PRE> // Fire events for markers that are hidden/unidden by editing or
 // undoing
 var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers
 if (hidden) { for (var i = 0; i &lt; hidden.length; ++i)
   { if (!hidden[i].lines.length) { signal(hidden[i], &quot;hide&quot;) } } }
 if (unhidden) { for (var i$1 = 0; i$1 &lt; unhidden.length; ++i$1)
   { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], &quot;unhide&quot;) } } }
</PRE><PRE> if (display.wrapper.offsetHeight)
   { doc.scrollTop = cm.display.scroller.scrollTop }
</PRE><PRE> // Fire change events, and delayed event handlers
 if (op.changeObjs)
   { signal(cm, &quot;changes&quot;, cm, op.changeObjs) }
 if (op.update)
   { op.update.finish() }
</PRE><P>}
</P><P>// Run the given function in an operation
function runInOp(cm, f) {
</P><PRE> if (cm.curOp) { return f() }
 startOperation(cm)
 try { return f() }
 finally { endOperation(cm) }
</PRE><P>}
// Wraps a function in an operation. Returns the wrapped function.
function operation(cm, f) {
</P><PRE> return function() {
   if (cm.curOp) { return f.apply(cm, arguments) }
   startOperation(cm)
   try { return f.apply(cm, arguments) }
   finally { endOperation(cm) }
 }
</PRE><P>}
// Used to add methods to editor and doc instances, wrapping them in
// operations.
function methodOp(f) {
</P><PRE> return function() {
   if (this.curOp) { return f.apply(this, arguments) }
   startOperation(this)
   try { return f.apply(this, arguments) }
   finally { endOperation(this) }
 }
</PRE><P>}
function docMethodOp(f) {
</P><PRE> return function() {
   var cm = this.cm
   if (!cm || cm.curOp) { return f.apply(this, arguments) }
   startOperation(cm)
   try { return f.apply(this, arguments) }
   finally { endOperation(cm) }
 }
</PRE><P>}
</P><P>// Updates the display.view data structure for a given change to the
// document. From and to are in pre-change coordinates. Lendiff is
// the amount of lines added or subtracted by the change. This is
// used for changes that span multiple lines, or change the way
// lines are divided into visual lines. regLineChange (below)
// registers single-line changes.
function regChange(cm, from, to, lendiff) {
</P><PRE> if (from == null) { from = cm.doc.first }
 if (to == null) { to = cm.doc.first + cm.doc.size }
 if (!lendiff) { lendiff = 0 }
</PRE><PRE> var display = cm.display
 if (lendiff &amp;&amp; to &lt; display.viewTo &amp;&amp;
     (display.updateLineNumbers == null || display.updateLineNumbers &gt; from))
   { display.updateLineNumbers = from }
</PRE><PRE> cm.curOp.viewChanged = true
</PRE><PRE> if (from &gt;= display.viewTo) { // Change after
   if (sawCollapsedSpans &amp;&amp; visualLineNo(cm.doc, from) &lt; display.viewTo)
     { resetView(cm) }
 } else if (to &lt;= display.viewFrom) { // Change before
   if (sawCollapsedSpans &amp;&amp; visualLineEndNo(cm.doc, to + lendiff) &gt; display.viewFrom) {
     resetView(cm)
   } else {
     display.viewFrom += lendiff
     display.viewTo += lendiff
   }
 } else if (from &lt;= display.viewFrom &amp;&amp; to &gt;= display.viewTo) { // Full overlap
   resetView(cm)
 } else if (from &lt;= display.viewFrom) { // Top overlap
   var cut = viewCuttingPoint(cm, to, to + lendiff, 1)
   if (cut) {
     display.view = display.view.slice(cut.index)
     display.viewFrom = cut.lineN
     display.viewTo += lendiff
   } else {
     resetView(cm)
   }
 } else if (to &gt;= display.viewTo) { // Bottom overlap
   var cut$1 = viewCuttingPoint(cm, from, from, -1)
   if (cut$1) {
     display.view = display.view.slice(0, cut$1.index)
     display.viewTo = cut$1.lineN
   } else {
     resetView(cm)
   }
 } else { // Gap in the middle
   var cutTop = viewCuttingPoint(cm, from, from, -1)
   var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1)
   if (cutTop &amp;&amp; cutBot) {
     display.view = display.view.slice(0, cutTop.index)
       .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
       .concat(display.view.slice(cutBot.index))
     display.viewTo += lendiff
   } else {
     resetView(cm)
   }
 }
</PRE><PRE> var ext = display.externalMeasured
 if (ext) {
   if (to &lt; ext.lineN)
     { ext.lineN += lendiff }
   else if (from &lt; ext.lineN + ext.size)
     { display.externalMeasured = null }
 }
</PRE><P>}
</P><P>// Register a change to a single line. Type must be one of &quot;text&quot;,
// &quot;gutter&quot;, &quot;class&quot;, &quot;widget&quot;
function regLineChange(cm, line, type) {
</P><PRE> cm.curOp.viewChanged = true
 var display = cm.display, ext = cm.display.externalMeasured
 if (ext &amp;&amp; line &gt;= ext.lineN &amp;&amp; line &lt; ext.lineN + ext.size)
   { display.externalMeasured = null }
</PRE><PRE> if (line &lt; display.viewFrom || line &gt;= display.viewTo) { return }
 var lineView = display.view[findViewIndex(cm, line)]
 if (lineView.node == null) { return }
 var arr = lineView.changes || (lineView.changes = [])
 if (indexOf(arr, type) == -1) { arr.push(type) }
</PRE><P>}
</P><P>// Clear the view.
function resetView(cm) {
</P><PRE> cm.display.viewFrom = cm.display.viewTo = cm.doc.first
 cm.display.view = []
 cm.display.viewOffset = 0
</PRE><P>}
</P><P>function viewCuttingPoint(cm, oldN, newN, dir) {
</P><PRE> var index = findViewIndex(cm, oldN), diff, view = cm.display.view
 if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
   { return {index: index, lineN: newN} }
 var n = cm.display.viewFrom
 for (var i = 0; i &lt; index; i++)
   { n += view[i].size }
 if (n != oldN) {
   if (dir &gt; 0) {
     if (index == view.length - 1) { return null }
     diff = (n + view[index].size) - oldN
     index++
   } else {
     diff = n - oldN
   }
   oldN += diff; newN += diff
 }
 while (visualLineNo(cm.doc, newN) != newN) {
   if (index == (dir &lt; 0 ? 0 : view.length - 1)) { return null }
   newN += dir * view[index - (dir &lt; 0 ? 1 : 0)].size
   index += dir
 }
 return {index: index, lineN: newN}
</PRE><P>}
</P><P>// Force the view to cover a given range, adding empty view element
// or clipping off existing ones as needed.
function adjustView(cm, from, to) {
</P><PRE> var display = cm.display, view = display.view
 if (view.length == 0 || from &gt;= display.viewTo || to &lt;= display.viewFrom) {
   display.view = buildViewArray(cm, from, to)
   display.viewFrom = from
 } else {
   if (display.viewFrom &gt; from)
     { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) }
   else if (display.viewFrom &lt; from)
     { display.view = display.view.slice(findViewIndex(cm, from)) }
   display.viewFrom = from
   if (display.viewTo &lt; to)
     { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) }
   else if (display.viewTo &gt; to)
     { display.view = display.view.slice(0, findViewIndex(cm, to)) }
 }
 display.viewTo = to
</PRE><P>}
</P><P>// Count the number of lines in the view whose DOM representation is
// out of date (or nonexistent).
function countDirtyView(cm) {
</P><PRE> var view = cm.display.view, dirty = 0
 for (var i = 0; i &lt; view.length; i++) {
   var lineView = view[i]
   if (!lineView.hidden &amp;&amp; (!lineView.node || lineView.changes)) { ++dirty }
 }
 return dirty
</PRE><P>}
</P><P>// HIGHLIGHT WORKER
</P><P>function startWorker(cm, time) {
</P><PRE> if (cm.doc.mode.startState &amp;&amp; cm.doc.frontier &lt; cm.display.viewTo)
   { cm.state.highlight.set(time, bind(highlightWorker, cm)) }
</PRE><P>}
</P><P>function highlightWorker(cm) {
</P><PRE> var doc = cm.doc
 if (doc.frontier &lt; doc.first) { doc.frontier = doc.first }
 if (doc.frontier &gt;= cm.display.viewTo) { return }
 var end = +new Date + cm.options.workTime
 var state = copyState(doc.mode, getStateBefore(cm, doc.frontier))
 var changedLines = []
</PRE><PRE> doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
   if (doc.frontier &gt;= cm.display.viewFrom) { // Visible
     var oldStyles = line.styles, tooLong = line.text.length &gt; cm.options.maxHighlightLength
     var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true)
     line.styles = highlighted.styles
     var oldCls = line.styleClasses, newCls = highlighted.classes
     if (newCls) { line.styleClasses = newCls }
     else if (oldCls) { line.styleClasses = null }
     var ischange = !oldStyles || oldStyles.length != line.styles.length ||
       oldCls != newCls &amp;&amp; (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass)
     for (var i = 0; !ischange &amp;&amp; i &lt; oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i] }
     if (ischange) { changedLines.push(doc.frontier) }
     line.stateAfter = tooLong ? state : copyState(doc.mode, state)
   } else {
     if (line.text.length &lt;= cm.options.maxHighlightLength)
       { processLine(cm, line.text, state) }
     line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null
   }
   ++doc.frontier
   if (+new Date &gt; end) {
     startWorker(cm, cm.options.workDelay)
     return true
   }
 })
 if (changedLines.length) { runInOp(cm, function () {
   for (var i = 0; i &lt; changedLines.length; i++)
     { regLineChange(cm, changedLines[i], &quot;text&quot;) }
 }) }
</PRE><P>}
</P><P>// DISPLAY DRAWING
</P><P>var DisplayUpdate = function(cm, viewport, force) {
</P><PRE> var display = cm.display
</PRE><PRE> this.viewport = viewport
 // Store some values that we'll need later (but don't want to force a relayout for)
 this.visible = visibleLines(display, cm.doc, viewport)
 this.editorIsHidden = !display.wrapper.offsetWidth
 this.wrapperHeight = display.wrapper.clientHeight
 this.wrapperWidth = display.wrapper.clientWidth
 this.oldDisplayWidth = displayWidth(cm)
 this.force = force
 this.dims = getDimensions(cm)
 this.events = []
</PRE><P>};
</P><P>DisplayUpdate.prototype.signal = function (emitter, type) {
</P><PRE> if (hasHandler(emitter, type))
   { this.events.push(arguments) }
</PRE><P>};
DisplayUpdate.prototype.finish = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> for (var i = 0; i &lt; this.events.length; i++)
   { signal.apply(null, this$1.events[i]) }
</PRE><P>};
</P><P>function maybeClipScrollbars(cm) {
</P><PRE> var display = cm.display
 if (!display.scrollbarsClipped &amp;&amp; display.scroller.offsetWidth) {
   display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth
   display.heightForcer.style.height = scrollGap(cm) + &quot;px&quot;
   display.sizer.style.marginBottom = -display.nativeBarWidth + &quot;px&quot;
   display.sizer.style.borderRightWidth = scrollGap(cm) + &quot;px&quot;
   display.scrollbarsClipped = true
 }
</PRE><P>}
</P><P>// Does the actual updating of the line display. Bails out
// (returning false) when there is nothing to be done and forced is
// false.
function updateDisplayIfNeeded(cm, update) {
</P><PRE> var display = cm.display, doc = cm.doc
</PRE><PRE> if (update.editorIsHidden) {
   resetView(cm)
   return false
 }
</PRE><PRE> // Bail out if the visible area is already rendered and nothing changed.
 if (!update.force &amp;&amp;
     update.visible.from &gt;= display.viewFrom &amp;&amp; update.visible.to &lt;= display.viewTo &amp;&amp;
     (display.updateLineNumbers == null || display.updateLineNumbers &gt;= display.viewTo) &amp;&amp;
     display.renderedView == display.view &amp;&amp; countDirtyView(cm) == 0)
   { return false }
</PRE><PRE> if (maybeUpdateLineNumberWidth(cm)) {
   resetView(cm)
   update.dims = getDimensions(cm)
 }
</PRE><PRE> // Compute a suitable new viewport (from &amp; to)
 var end = doc.first + doc.size
 var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first)
 var to = Math.min(end, update.visible.to + cm.options.viewportMargin)
 if (display.viewFrom &lt; from &amp;&amp; from - display.viewFrom &lt; 20) { from = Math.max(doc.first, display.viewFrom) }
 if (display.viewTo &gt; to &amp;&amp; display.viewTo - to &lt; 20) { to = Math.min(end, display.viewTo) }
 if (sawCollapsedSpans) {
   from = visualLineNo(cm.doc, from)
   to = visualLineEndNo(cm.doc, to)
 }
</PRE><PRE> var different = from != display.viewFrom || to != display.viewTo ||
   display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth
 adjustView(cm, from, to)
</PRE><PRE> display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom))
 // Position the mover div to align with the current scroll position
 cm.display.mover.style.top = display.viewOffset + &quot;px&quot;
</PRE><PRE> var toUpdate = countDirtyView(cm)
 if (!different &amp;&amp; toUpdate == 0 &amp;&amp; !update.force &amp;&amp; display.renderedView == display.view &amp;&amp;
     (display.updateLineNumbers == null || display.updateLineNumbers &gt;= display.viewTo))
   { return false }
</PRE><PRE> // For big changes, we hide the enclosing element during the
 // update, since that speeds up the operations on most browsers.
 var focused = activeElt()
 if (toUpdate &gt; 4) { display.lineDiv.style.display = &quot;none&quot; }
 patchDisplay(cm, display.updateLineNumbers, update.dims)
 if (toUpdate &gt; 4) { display.lineDiv.style.display = &quot;&quot; }
 display.renderedView = display.view
 // There might have been a widget with a focused element that got
 // hidden or updated, if so re-focus it.
 if (focused &amp;&amp; activeElt() != focused &amp;&amp; focused.offsetHeight) { focused.focus() }
</PRE><PRE> // Prevent selection and cursors from interfering with the scroll
 // width and height.
 removeChildren(display.cursorDiv)
 removeChildren(display.selectionDiv)
 display.gutters.style.height = display.sizer.style.minHeight = 0
</PRE><PRE> if (different) {
   display.lastWrapHeight = update.wrapperHeight
   display.lastWrapWidth = update.wrapperWidth
   startWorker(cm, 400)
 }
</PRE><PRE> display.updateLineNumbers = null
</PRE><PRE> return true
</PRE><P>}
</P><P>function postUpdateDisplay(cm, update) {
</P><PRE> var viewport = update.viewport
</PRE><PRE> for (var first = true;; first = false) {
   if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
     // Clip forced viewport to actual scrollable area.
     if (viewport &amp;&amp; viewport.top != null)
       { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)} }
     // Updated line heights might result in the drawn area not
     // actually covering the viewport. Keep looping until it does.
     update.visible = visibleLines(cm.display, cm.doc, viewport)
     if (update.visible.from &gt;= cm.display.viewFrom &amp;&amp; update.visible.to &lt;= cm.display.viewTo)
       { break }
   }
   if (!updateDisplayIfNeeded(cm, update)) { break }
   updateHeightsInViewport(cm)
   var barMeasure = measureForScrollbars(cm)
   updateSelection(cm)
   updateScrollbars(cm, barMeasure)
   setDocumentHeight(cm, barMeasure)
 }
</PRE><PRE> update.signal(cm, &quot;update&quot;, cm)
 if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
   update.signal(cm, &quot;viewportChange&quot;, cm, cm.display.viewFrom, cm.display.viewTo)
   cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo
 }
</PRE><P>}
</P><P>function updateDisplaySimple(cm, viewport) {
</P><PRE> var update = new DisplayUpdate(cm, viewport)
 if (updateDisplayIfNeeded(cm, update)) {
   updateHeightsInViewport(cm)
   postUpdateDisplay(cm, update)
   var barMeasure = measureForScrollbars(cm)
   updateSelection(cm)
   updateScrollbars(cm, barMeasure)
   setDocumentHeight(cm, barMeasure)
   update.finish()
 }
</PRE><P>}
</P><P>// Sync the actual display DOM structure with display.view, removing
// nodes for lines that are no longer in view, and creating the ones
// that are not there yet, and updating the ones that are out of
// date.
function patchDisplay(cm, updateNumbersFrom, dims) {
</P><PRE> var display = cm.display, lineNumbers = cm.options.lineNumbers
 var container = display.lineDiv, cur = container.firstChild
</PRE><PRE> function rm(node) {
   var next = node.nextSibling
   // Works around a throw-scroll bug in OS X Webkit
   if (webkit &amp;&amp; mac &amp;&amp; cm.display.currentWheelTarget == node)
     { node.style.display = &quot;none&quot; }
   else
     { node.parentNode.removeChild(node) }
   return next
 }
</PRE><PRE> var view = display.view, lineN = display.viewFrom
 // Loop over the elements in the view, syncing cur (the DOM nodes
 // in display.lineDiv) with the view as we go.
 for (var i = 0; i &lt; view.length; i++) {
   var lineView = view[i]
   if (lineView.hidden) {
   } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
     var node = buildLineElement(cm, lineView, lineN, dims)
     container.insertBefore(node, cur)
   } else { // Already drawn
     while (cur != lineView.node) { cur = rm(cur) }
     var updateNumber = lineNumbers &amp;&amp; updateNumbersFrom != null &amp;&amp;
       updateNumbersFrom &lt;= lineN &amp;&amp; lineView.lineNumber
     if (lineView.changes) {
       if (indexOf(lineView.changes, &quot;gutter&quot;) &gt; -1) { updateNumber = false }
       updateLineForChanges(cm, lineView, lineN, dims)
     }
     if (updateNumber) {
       removeChildren(lineView.lineNumber)
       lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))
     }
     cur = lineView.node.nextSibling
   }
   lineN += lineView.size
 }
 while (cur) { cur = rm(cur) }
</PRE><P>}
</P><P>function updateGutterSpace(cm) {
</P><PRE> var width = cm.display.gutters.offsetWidth
 cm.display.sizer.style.marginLeft = width + &quot;px&quot;
</PRE><P>}
</P><P>function setDocumentHeight(cm, measure) {
</P><PRE> cm.display.sizer.style.minHeight = measure.docHeight + &quot;px&quot;
 cm.display.heightForcer.style.top = measure.docHeight + &quot;px&quot;
 cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + &quot;px&quot;
</PRE><P>}
</P><P>// Rebuild the gutter elements, ensure the margin to the left of the
// code matches their width.
function updateGutters(cm) {
</P><PRE> var gutters = cm.display.gutters, specs = cm.options.gutters
 removeChildren(gutters)
 var i = 0
 for (; i &lt; specs.length; ++i) {
   var gutterClass = specs[i]
   var gElt = gutters.appendChild(elt(&quot;div&quot;, null, &quot;CodeMirror-gutter &quot; + gutterClass))
   if (gutterClass == &quot;CodeMirror-linenumbers&quot;) {
     cm.display.lineGutter = gElt
     gElt.style.width = (cm.display.lineNumWidth || 1) + &quot;px&quot;
   }
 }
 gutters.style.display = i ? &quot;&quot; : &quot;none&quot;
 updateGutterSpace(cm)
</PRE><P>}
</P><P>// Make sure the gutters options contains the element
// &quot;CodeMirror-linenumbers&quot; when the lineNumbers option is true.
function setGuttersForLineNumbers(options) {
</P><PRE> var found = indexOf(options.gutters, &quot;CodeMirror-linenumbers&quot;)
 if (found == -1 &amp;&amp; options.lineNumbers) {
   options.gutters = options.gutters.concat([&quot;CodeMirror-linenumbers&quot;])
 } else if (found &gt; -1 &amp;&amp; !options.lineNumbers) {
   options.gutters = options.gutters.slice(0)
   options.gutters.splice(found, 1)
 }
</PRE><P>}
</P><P>// Selection objects are immutable. A new one is created every time
// the selection changes. A selection is one or more non-overlapping
// (and non-touching) ranges, sorted, and an integer that indicates
// which one is the primary selection (the one that's scrolled into
// view, that getCursor returns, etc).
var Selection = function(ranges, primIndex) {
</P><PRE> this.ranges = ranges
 this.primIndex = primIndex
</PRE><P>};
</P><P>Selection.prototype.primary = function () { return this.ranges[this.primIndex] };
</P><P>Selection.prototype.equals = function (other) {
</P><PRE>   var this$1 = this;
</PRE><PRE> if (other == this) { return true }
 if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
 for (var i = 0; i &lt; this.ranges.length; i++) {
   var here = this$1.ranges[i], there = other.ranges[i]
   if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
 }
 return true
</PRE><P>};
</P><P>Selection.prototype.deepCopy = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> var out = []
 for (var i = 0; i &lt; this.ranges.length; i++)
   { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)) }
 return new Selection(out, this.primIndex)
</PRE><P>};
</P><P>Selection.prototype.somethingSelected = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> for (var i = 0; i &lt; this.ranges.length; i++)
   { if (!this$1.ranges[i].empty()) { return true } }
 return false
</PRE><P>};
</P><P>Selection.prototype.contains = function (pos, end) {
</P><PRE>   var this$1 = this;
</PRE><PRE> if (!end) { end = pos }
 for (var i = 0; i &lt; this.ranges.length; i++) {
   var range = this$1.ranges[i]
   if (cmp(end, range.from()) &gt;= 0 &amp;&amp; cmp(pos, range.to()) &lt;= 0)
     { return i }
 }
 return -1
</PRE><P>};
</P><P>var Range = function(anchor, head) {
</P><PRE> this.anchor = anchor; this.head = head
</PRE><P>};
</P><P>Range.prototype.from = function () { return minPos(this.anchor, this.head) };
Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
Range.prototype.empty = function () { return this.head.line == this.anchor.line &amp;&amp; this.head.ch == this.anchor.ch };
</P><P>// Take an unsorted, potentially overlapping set of ranges, and
// build a selection out of it. 'Consumes' ranges array (modifying
// it).
function normalizeSelection(ranges, primIndex) {
</P><PRE> var prim = ranges[primIndex]
 ranges.sort(function (a, b) { return cmp(a.from(), b.from()); })
 primIndex = indexOf(ranges, prim)
 for (var i = 1; i &lt; ranges.length; i++) {
   var cur = ranges[i], prev = ranges[i - 1]
   if (cmp(prev.to(), cur.from()) &gt;= 0) {
     var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to())
     var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head
     if (i &lt;= primIndex) { --primIndex }
     ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))
   }
 }
 return new Selection(ranges, primIndex)
</PRE><P>}
</P><P>function simpleSelection(anchor, head) {
</P><PRE> return new Selection([new Range(anchor, head || anchor)], 0)
</PRE><P>}
</P><P>// Compute the position of the end of a change (its 'to' property
// refers to the pre-change end).
function changeEnd(change) {
</P><PRE> if (!change.text) { return change.to }
 return Pos(change.from.line + change.text.length - 1,
            lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
</PRE><P>}
</P><P>// Adjust a position to refer to the post-change position of the
// same text, or the end of the change if the change covers it.
function adjustForChange(pos, change) {
</P><PRE> if (cmp(pos, change.from) &lt; 0) { return pos }
 if (cmp(pos, change.to) &lt;= 0) { return changeEnd(change) }
</PRE><PRE> var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch
 if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch }
 return Pos(line, ch)
</PRE><P>}
</P><P>function computeSelAfterChange(doc, change) {
</P><PRE> var out = []
 for (var i = 0; i &lt; doc.sel.ranges.length; i++) {
   var range = doc.sel.ranges[i]
   out.push(new Range(adjustForChange(range.anchor, change),
                      adjustForChange(range.head, change)))
 }
 return normalizeSelection(out, doc.sel.primIndex)
</PRE><P>}
</P><P>function offsetPos(pos, old, nw) {
</P><PRE> if (pos.line == old.line)
   { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
 else
   { return Pos(nw.line + (pos.line - old.line), pos.ch) }
</PRE><P>}
</P><P>// Used by replaceSelections to allow moving the selection to the
// start or around the replaced test. Hint may be &quot;start&quot; or &quot;around&quot;.
function computeReplacedSel(doc, changes, hint) {
</P><PRE> var out = []
 var oldPrev = Pos(doc.first, 0), newPrev = oldPrev
 for (var i = 0; i &lt; changes.length; i++) {
   var change = changes[i]
   var from = offsetPos(change.from, oldPrev, newPrev)
   var to = offsetPos(changeEnd(change), oldPrev, newPrev)
   oldPrev = change.to
   newPrev = to
   if (hint == &quot;around&quot;) {
     var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) &lt; 0
     out[i] = new Range(inv ? to : from, inv ? from : to)
   } else {
     out[i] = new Range(from, from)
   }
 }
 return new Selection(out, doc.sel.primIndex)
</PRE><P>}
</P><P>// Used to get the editor into a consistent state again when options change.
</P><P>function loadMode(cm) {
</P><PRE> cm.doc.mode = getMode(cm.options, cm.doc.modeOption)
 resetModeState(cm)
</PRE><P>}
</P><P>function resetModeState(cm) {
</P><PRE> cm.doc.iter(function (line) {
   if (line.stateAfter) { line.stateAfter = null }
   if (line.styles) { line.styles = null }
 })
 cm.doc.frontier = cm.doc.first
 startWorker(cm, 100)
 cm.state.modeGen++
 if (cm.curOp) { regChange(cm) }
</PRE><P>}
</P><P>// DOCUMENT DATA STRUCTURE
</P><P>// By default, updates that start and end at the beginning of a line
// are treated specially, in order to make the association of line
// widgets and marker elements with the text behave more intuitive.
function isWholeLineUpdate(doc, change) {
</P><PRE> return change.from.ch == 0 &amp;&amp; change.to.ch == 0 &amp;&amp; lst(change.text) == &quot;&quot; &amp;&amp;
   (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
</PRE><P>}
</P><P>// Perform a change on the document data structure.
function updateDoc(doc, change, markedSpans, estimateHeight) {
</P><PRE> function spansFor(n) {return markedSpans ? markedSpans[n] : null}
 function update(line, text, spans) {
   updateLine(line, text, spans, estimateHeight)
   signalLater(line, &quot;change&quot;, line, change)
 }
 function linesFor(start, end) {
   var result = []
   for (var i = start; i &lt; end; ++i)
     { result.push(new Line(text[i], spansFor(i), estimateHeight)) }
   return result
 }
</PRE><PRE> var from = change.from, to = change.to, text = change.text
 var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line)
 var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line
</PRE><PRE> // Adjust the line structure
 if (change.full) {
   doc.insert(0, linesFor(0, text.length))
   doc.remove(text.length, doc.size - text.length)
 } else if (isWholeLineUpdate(doc, change)) {
   // This is a whole-line replace. Treated specially to make
   // sure line objects move the way they are supposed to.
   var added = linesFor(0, text.length - 1)
   update(lastLine, lastLine.text, lastSpans)
   if (nlines) { doc.remove(from.line, nlines) }
   if (added.length) { doc.insert(from.line, added) }
 } else if (firstLine == lastLine) {
   if (text.length == 1) {
     update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans)
   } else {
     var added$1 = linesFor(1, text.length - 1)
     added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight))
     update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))
     doc.insert(from.line + 1, added$1)
   }
 } else if (text.length == 1) {
   update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0))
   doc.remove(from.line + 1, nlines)
 } else {
   update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))
   update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans)
   var added$2 = linesFor(1, text.length - 1)
   if (nlines &gt; 1) { doc.remove(from.line + 1, nlines - 1) }
   doc.insert(from.line + 1, added$2)
 }
</PRE><PRE> signalLater(doc, &quot;change&quot;, doc, change)
</PRE><P>}
</P><P>// Call f for all linked documents.
function linkedDocs(doc, f, sharedHistOnly) {
</P><PRE> function propagate(doc, skip, sharedHist) {
   if (doc.linked) { for (var i = 0; i &lt; doc.linked.length; ++i) {
     var rel = doc.linked[i]
     if (rel.doc == skip) { continue }
     var shared = sharedHist &amp;&amp; rel.sharedHist
     if (sharedHistOnly &amp;&amp; !shared) { continue }
     f(rel.doc, shared)
     propagate(rel.doc, doc, shared)
   } }
 }
 propagate(doc, null, true)
</PRE><P>}
</P><P>// Attach a document to an editor.
function attachDoc(cm, doc) {
</P><PRE> if (doc.cm) { throw new Error(&quot;This document is already in use.&quot;) }
 cm.doc = doc
 doc.cm = cm
 estimateLineHeights(cm)
 loadMode(cm)
 if (!cm.options.lineWrapping) { findMaxLine(cm) }
 cm.options.mode = doc.modeOption
 regChange(cm)
</PRE><P>}
</P><P>function History(startGen) {
</P><PRE> // Arrays of change events and selections. Doing something adds an
 // event to done and clears undo. Undoing moves events from done
 // to undone, redoing moves them in the other direction.
 this.done = []; this.undone = []
 this.undoDepth = Infinity
 // Used to track when changes can be merged into a single undo
 // event
 this.lastModTime = this.lastSelTime = 0
 this.lastOp = this.lastSelOp = null
 this.lastOrigin = this.lastSelOrigin = null
 // Used by the isClean() method
 this.generation = this.maxGeneration = startGen || 1
</PRE><P>}
</P><P>// Create a history change event from an updateDoc-style change
// object.
function historyChangeFromChange(doc, change) {
</P><PRE> var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)}
 attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)
 linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true)
 return histChange
</PRE><P>}
</P><P>// Pop all selection events off the end of a history array. Stop at
// a change event.
function clearSelectionEvents(array) {
</P><PRE> while (array.length) {
   var last = lst(array)
   if (last.ranges) { array.pop() }
   else { break }
 }
</PRE><P>}
</P><P>// Find the top change event in the history. Pop off selection
// events that are in the way.
function lastChangeEvent(hist, force) {
</P><PRE> if (force) {
   clearSelectionEvents(hist.done)
   return lst(hist.done)
 } else if (hist.done.length &amp;&amp; !lst(hist.done).ranges) {
   return lst(hist.done)
 } else if (hist.done.length &gt; 1 &amp;&amp; !hist.done[hist.done.length - 2].ranges) {
   hist.done.pop()
   return lst(hist.done)
 }
</PRE><P>}
</P><P>// Register a change in the history. Merges changes that are within
// a single operation, or are close together with an origin that
// allows merging (starting with &quot;+&quot;) into a single event.
function addChangeToHistory(doc, change, selAfter, opId) {
</P><PRE> var hist = doc.history
 hist.undone.length = 0
 var time = +new Date, cur
 var last
</PRE><PRE> if ((hist.lastOp == opId ||
      hist.lastOrigin == change.origin &amp;&amp; change.origin &amp;&amp;
      ((change.origin.charAt(0) == &quot;+&quot; &amp;&amp; doc.cm &amp;&amp; hist.lastModTime &gt; time - doc.cm.options.historyEventDelay) ||
       change.origin.charAt(0) == &quot;*&quot;)) &amp;&amp;
     (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
   // Merge this change into the last event
   last = lst(cur.changes)
   if (cmp(change.from, change.to) == 0 &amp;&amp; cmp(change.from, last.to) == 0) {
     // Optimized case for simple insertion -- don't want to add
     // new changesets for every character typed
     last.to = changeEnd(change)
   } else {
     // Add new sub-event
     cur.changes.push(historyChangeFromChange(doc, change))
   }
 } else {
   // Can not be merged, start a new event.
   var before = lst(hist.done)
   if (!before || !before.ranges)
     { pushSelectionToHistory(doc.sel, hist.done) }
   cur = {changes: [historyChangeFromChange(doc, change)],
          generation: hist.generation}
   hist.done.push(cur)
   while (hist.done.length &gt; hist.undoDepth) {
     hist.done.shift()
     if (!hist.done[0].ranges) { hist.done.shift() }
   }
 }
 hist.done.push(selAfter)
 hist.generation = ++hist.maxGeneration
 hist.lastModTime = hist.lastSelTime = time
 hist.lastOp = hist.lastSelOp = opId
 hist.lastOrigin = hist.lastSelOrigin = change.origin
</PRE><PRE> if (!last) { signal(doc, &quot;historyAdded&quot;) }
</PRE><P>}
</P><P>function selectionEventCanBeMerged(doc, origin, prev, sel) {
</P><PRE> var ch = origin.charAt(0)
 return ch == &quot;*&quot; ||
   ch == &quot;+&quot; &amp;&amp;
   prev.ranges.length == sel.ranges.length &amp;&amp;
   prev.somethingSelected() == sel.somethingSelected() &amp;&amp;
   new Date - doc.history.lastSelTime &lt;= (doc.cm ? doc.cm.options.historyEventDelay : 500)
</PRE><P>}
</P><P>// Called whenever the selection changes, sets the new selection as
// the pending selection in the history, and pushes the old pending
// selection into the 'done' array when it was significantly
// different (in number of selected ranges, emptiness, or time).
function addSelectionToHistory(doc, sel, opId, options) {
</P><PRE> var hist = doc.history, origin = options &amp;&amp; options.origin
</PRE><PRE> // A new event is started when the previous origin does not match
 // the current, or the origins don't allow matching. Origins
 // starting with * are always merged, those starting with + are
 // merged when similar and close together in time.
 if (opId == hist.lastSelOp ||
     (origin &amp;&amp; hist.lastSelOrigin == origin &amp;&amp;
      (hist.lastModTime == hist.lastSelTime &amp;&amp; hist.lastOrigin == origin ||
       selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
   { hist.done[hist.done.length - 1] = sel }
 else
   { pushSelectionToHistory(sel, hist.done) }
</PRE><PRE> hist.lastSelTime = +new Date
 hist.lastSelOrigin = origin
 hist.lastSelOp = opId
 if (options &amp;&amp; options.clearRedo !== false)
   { clearSelectionEvents(hist.undone) }
</PRE><P>}
</P><P>function pushSelectionToHistory(sel, dest) {
</P><PRE> var top = lst(dest)
 if (!(top &amp;&amp; top.ranges &amp;&amp; top.equals(sel)))
   { dest.push(sel) }
</PRE><P>}
</P><P>// Used to store marked span information in the history.
function attachLocalSpans(doc, change, from, to) {
</P><PRE> var existing = change[&quot;spans_&quot; + doc.id], n = 0
 doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
   if (line.markedSpans)
     { (existing || (existing = change[&quot;spans_&quot; + doc.id] = {}))[n] = line.markedSpans }
   ++n
 })
</PRE><P>}
</P><P>// When un/re-doing restores text containing marked spans, those
// that have been explicitly cleared should not be restored.
function removeClearedSpans(spans) {
</P><PRE> if (!spans) { return null }
 var out
 for (var i = 0; i &lt; spans.length; ++i) {
   if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i) } }
   else if (out) { out.push(spans[i]) }
 }
 return !out ? spans : out.length ? out : null
</PRE><P>}
</P><P>// Retrieve and filter the old marked spans stored in a change event.
function getOldSpans(doc, change) {
</P><PRE> var found = change[&quot;spans_&quot; + doc.id]
 if (!found) { return null }
 var nw = []
 for (var i = 0; i &lt; change.text.length; ++i)
   { nw.push(removeClearedSpans(found[i])) }
 return nw
</PRE><P>}
</P><P>// Used for un/re-doing changes from the history. Combines the
// result of computing the existing spans with the set of spans that
// existed in the history (so that deleting around a span and then
// undoing brings back the span).
function mergeOldSpans(doc, change) {
</P><PRE> var old = getOldSpans(doc, change)
 var stretched = stretchSpansOverChange(doc, change)
 if (!old) { return stretched }
 if (!stretched) { return old }
</PRE><PRE> for (var i = 0; i &lt; old.length; ++i) {
   var oldCur = old[i], stretchCur = stretched[i]
   if (oldCur &amp;&amp; stretchCur) {
     spans: for (var j = 0; j &lt; stretchCur.length; ++j) {
       var span = stretchCur[j]
       for (var k = 0; k &lt; oldCur.length; ++k)
         { if (oldCur[k].marker == span.marker) { continue spans } }
       oldCur.push(span)
     }
   } else if (stretchCur) {
     old[i] = stretchCur
   }
 }
 return old
</PRE><P>}
</P><P>// Used both to provide a JSON-safe object in .getHistory, and, when
// detaching a document, to split the history in two
function copyHistoryArray(events, newGroup, instantiateSel) {
</P><PRE> var copy = []
 for (var i = 0; i &lt; events.length; ++i) {
   var event = events[i]
   if (event.ranges) {
     copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event)
     continue
   }
   var changes = event.changes, newChanges = []
   copy.push({changes: newChanges})
   for (var j = 0; j &lt; changes.length; ++j) {
     var change = changes[j], m = (void 0)
     newChanges.push({from: change.from, to: change.to, text: change.text})
     if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
       if (indexOf(newGroup, Number(m[1])) &gt; -1) {
         lst(newChanges)[prop] = change[prop]
         delete change[prop]
       }
     } } }
   }
 }
 return copy
</PRE><P>}
</P><P>// The 'scroll' parameter given to many of these indicated whether
// the new cursor position should be scrolled into view after
// modifying the selection.
</P><P>// If shift is held or the extend flag is set, extends a range to
// include a given position (and optionally a second position).
// Otherwise, simply returns the range between the given positions.
// Used for cursor motion and such.
function extendRange(doc, range, head, other) {
</P><PRE> if (doc.cm &amp;&amp; doc.cm.display.shift || doc.extend) {
   var anchor = range.anchor
   if (other) {
     var posBefore = cmp(head, anchor) &lt; 0
     if (posBefore != (cmp(other, anchor) &lt; 0)) {
       anchor = head
       head = other
     } else if (posBefore != (cmp(head, other) &lt; 0)) {
       head = other
     }
   }
   return new Range(anchor, head)
 } else {
   return new Range(other || head, head)
 }
</PRE><P>}
</P><P>// Extend the primary selection range, discard the rest.
function extendSelection(doc, head, other, options) {
</P><PRE> setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options)
</PRE><P>}
</P><P>// Extend all selections (pos is an array of selections with length
// equal the number of selections)
function extendSelections(doc, heads, options) {
</P><PRE> var out = []
 for (var i = 0; i &lt; doc.sel.ranges.length; i++)
   { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null) }
 var newSel = normalizeSelection(out, doc.sel.primIndex)
 setSelection(doc, newSel, options)
</PRE><P>}
</P><P>// Updates a single range in the selection.
function replaceOneSelection(doc, i, range, options) {
</P><PRE> var ranges = doc.sel.ranges.slice(0)
 ranges[i] = range
 setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)
</PRE><P>}
</P><P>// Reset the selection to a single range.
function setSimpleSelection(doc, anchor, head, options) {
</P><PRE> setSelection(doc, simpleSelection(anchor, head), options)
</PRE><P>}
</P><P>// Give beforeSelectionChange handlers a change to influence a
// selection update.
function filterSelectionChange(doc, sel, options) {
</P><PRE> var obj = {
   ranges: sel.ranges,
   update: function(ranges) {
     var this$1 = this;
</PRE><PRE>     this.ranges = []
     for (var i = 0; i &lt; ranges.length; i++)
       { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                  clipPos(doc, ranges[i].head)) }
   },
   origin: options &amp;&amp; options.origin
 }
 signal(doc, &quot;beforeSelectionChange&quot;, doc, obj)
 if (doc.cm) { signal(doc.cm, &quot;beforeSelectionChange&quot;, doc.cm, obj) }
 if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
 else { return sel }
</PRE><P>}
</P><P>function setSelectionReplaceHistory(doc, sel, options) {
</P><PRE> var done = doc.history.done, last = lst(done)
 if (last &amp;&amp; last.ranges) {
   done[done.length - 1] = sel
   setSelectionNoUndo(doc, sel, options)
 } else {
   setSelection(doc, sel, options)
 }
</PRE><P>}
</P><P>// Set a new selection.
function setSelection(doc, sel, options) {
</P><PRE> setSelectionNoUndo(doc, sel, options)
 addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)
</PRE><P>}
</P><P>function setSelectionNoUndo(doc, sel, options) {
</P><PRE> if (hasHandler(doc, &quot;beforeSelectionChange&quot;) || doc.cm &amp;&amp; hasHandler(doc.cm, &quot;beforeSelectionChange&quot;))
   { sel = filterSelectionChange(doc, sel, options) }
</PRE><PRE> var bias = options &amp;&amp; options.bias ||
   (cmp(sel.primary().head, doc.sel.primary().head) &lt; 0 ? -1 : 1)
 setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true))
</PRE><PRE> if (!(options &amp;&amp; options.scroll === false) &amp;&amp; doc.cm)
   { ensureCursorVisible(doc.cm) }
</PRE><P>}
</P><P>function setSelectionInner(doc, sel) {
</P><PRE> if (sel.equals(doc.sel)) { return }
</PRE><PRE> doc.sel = sel
</PRE><PRE> if (doc.cm) {
   doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true
   signalCursorActivity(doc.cm)
 }
 signalLater(doc, &quot;cursorActivity&quot;, doc)
</PRE><P>}
</P><P>// Verify that the selection does not partially select any atomic
// marked ranges.
function reCheckSelection(doc) {
</P><PRE> setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll)
</PRE><P>}
</P><P>// Return a selection that does not partially select any atomic
// ranges.
function skipAtomicInSelection(doc, sel, bias, mayClear) {
</P><PRE> var out
 for (var i = 0; i &lt; sel.ranges.length; i++) {
   var range = sel.ranges[i]
   var old = sel.ranges.length == doc.sel.ranges.length &amp;&amp; doc.sel.ranges[i]
   var newAnchor = skipAtomic(doc, range.anchor, old &amp;&amp; old.anchor, bias, mayClear)
   var newHead = skipAtomic(doc, range.head, old &amp;&amp; old.head, bias, mayClear)
   if (out || newAnchor != range.anchor || newHead != range.head) {
     if (!out) { out = sel.ranges.slice(0, i) }
     out[i] = new Range(newAnchor, newHead)
   }
 }
 return out ? normalizeSelection(out, sel.primIndex) : sel
</PRE><P>}
</P><P>function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
</P><PRE> var line = getLine(doc, pos.line)
 if (line.markedSpans) { for (var i = 0; i &lt; line.markedSpans.length; ++i) {
   var sp = line.markedSpans[i], m = sp.marker
   if ((sp.from == null || (m.inclusiveLeft ? sp.from &lt;= pos.ch : sp.from &lt; pos.ch)) &amp;&amp;
       (sp.to == null || (m.inclusiveRight ? sp.to &gt;= pos.ch : sp.to &gt; pos.ch))) {
     if (mayClear) {
       signal(m, &quot;beforeCursorEnter&quot;)
       if (m.explicitlyCleared) {
         if (!line.markedSpans) { break }
         else {--i; continue}
       }
     }
     if (!m.atomic) { continue }
</PRE><PRE>     if (oldPos) {
       var near = m.find(dir &lt; 0 ? 1 : -1), diff = (void 0)
       if (dir &lt; 0 ? m.inclusiveRight : m.inclusiveLeft)
         { near = movePos(doc, near, -dir, near &amp;&amp; near.line == pos.line ? line : null) }
       if (near &amp;&amp; near.line == pos.line &amp;&amp; (diff = cmp(near, oldPos)) &amp;&amp; (dir &lt; 0 ? diff &lt; 0 : diff &gt; 0))
         { return skipAtomicInner(doc, near, pos, dir, mayClear) }
     }
</PRE><PRE>     var far = m.find(dir &lt; 0 ? -1 : 1)
     if (dir &lt; 0 ? m.inclusiveLeft : m.inclusiveRight)
       { far = movePos(doc, far, dir, far.line == pos.line ? line : null) }
     return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
   }
 } }
 return pos
</PRE><P>}
</P><P>// Ensure a given position is not inside an atomic range.
function skipAtomic(doc, pos, oldPos, bias, mayClear) {
</P><PRE> var dir = bias || 1
 var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
     (!mayClear &amp;&amp; skipAtomicInner(doc, pos, oldPos, dir, true)) ||
     skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
     (!mayClear &amp;&amp; skipAtomicInner(doc, pos, oldPos, -dir, true))
 if (!found) {
   doc.cantEdit = true
   return Pos(doc.first, 0)
 }
 return found
</PRE><P>}
</P><P>function movePos(doc, pos, dir, line) {
</P><PRE> if (dir &lt; 0 &amp;&amp; pos.ch == 0) {
   if (pos.line &gt; doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
   else { return null }
 } else if (dir &gt; 0 &amp;&amp; pos.ch == (line || getLine(doc, pos.line)).text.length) {
   if (pos.line &lt; doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
   else { return null }
 } else {
   return new Pos(pos.line, pos.ch + dir)
 }
</PRE><P>}
</P><P>function selectAll(cm) {
</P><PRE> cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)
</PRE><P>}
</P><P>// UPDATING
</P><P>// Allow &quot;beforeChange&quot; event handlers to influence a change
function filterChange(doc, change, update) {
</P><PRE> var obj = {
   canceled: false,
   from: change.from,
   to: change.to,
   text: change.text,
   origin: change.origin,
   cancel: function () { return obj.canceled = true; }
 }
 if (update) { obj.update = function (from, to, text, origin) {
   if (from) { obj.from = clipPos(doc, from) }
   if (to) { obj.to = clipPos(doc, to) }
   if (text) { obj.text = text }
   if (origin !== undefined) { obj.origin = origin }
 } }
 signal(doc, &quot;beforeChange&quot;, doc, obj)
 if (doc.cm) { signal(doc.cm, &quot;beforeChange&quot;, doc.cm, obj) }
</PRE><PRE> if (obj.canceled) { return null }
 return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
</PRE><P>}
</P><P>// Apply a change to a document, and add it to the document's
// history, and propagating it to all linked documents.
function makeChange(doc, change, ignoreReadOnly) {
</P><PRE> if (doc.cm) {
   if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
   if (doc.cm.state.suppressEdits) { return }
 }
</PRE><PRE> if (hasHandler(doc, &quot;beforeChange&quot;) || doc.cm &amp;&amp; hasHandler(doc.cm, &quot;beforeChange&quot;)) {
   change = filterChange(doc, change, true)
   if (!change) { return }
 }
</PRE><PRE> // Possibly split or suppress the update based on the presence
 // of read-only spans in its range.
 var split = sawReadOnlySpans &amp;&amp; !ignoreReadOnly &amp;&amp; removeReadOnlyRanges(doc, change.from, change.to)
 if (split) {
   for (var i = split.length - 1; i &gt;= 0; --i)
     { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [&quot;&quot;] : change.text}) }
 } else {
   makeChangeInner(doc, change)
 }
</PRE><P>}
</P><P>function makeChangeInner(doc, change) {
</P><PRE> if (change.text.length == 1 &amp;&amp; change.text[0] == &quot;&quot; &amp;&amp; cmp(change.from, change.to) == 0) { return }
 var selAfter = computeSelAfterChange(doc, change)
 addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN)
</PRE><PRE> makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change))
 var rebased = []
</PRE><PRE> linkedDocs(doc, function (doc, sharedHist) {
   if (!sharedHist &amp;&amp; indexOf(rebased, doc.history) == -1) {
     rebaseHist(doc.history, change)
     rebased.push(doc.history)
   }
   makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))
 })
</PRE><P>}
</P><P>// Revert a change stored in a document's history.
function makeChangeFromHistory(doc, type, allowSelectionOnly) {
</P><PRE> if (doc.cm &amp;&amp; doc.cm.state.suppressEdits &amp;&amp; !allowSelectionOnly) { return }
</PRE><PRE> var hist = doc.history, event, selAfter = doc.sel
 var source = type == &quot;undo&quot; ? hist.done : hist.undone, dest = type == &quot;undo&quot; ? hist.undone : hist.done
</PRE><PRE> // Verify that there is a useable event (so that ctrl-z won't
 // needlessly clear selection events)
 var i = 0
 for (; i &lt; source.length; i++) {
   event = source[i]
   if (allowSelectionOnly ? event.ranges &amp;&amp; !event.equals(doc.sel) : !event.ranges)
     { break }
 }
 if (i == source.length) { return }
 hist.lastOrigin = hist.lastSelOrigin = null
</PRE><PRE> for (;;) {
   event = source.pop()
   if (event.ranges) {
     pushSelectionToHistory(event, dest)
     if (allowSelectionOnly &amp;&amp; !event.equals(doc.sel)) {
       setSelection(doc, event, {clearRedo: false})
       return
     }
     selAfter = event
   }
   else { break }
 }
</PRE><PRE> // Build up a reverse change object to add to the opposite history
 // stack (redo when undoing, and vice versa).
 var antiChanges = []
 pushSelectionToHistory(selAfter, dest)
 dest.push({changes: antiChanges, generation: hist.generation})
 hist.generation = event.generation || ++hist.maxGeneration
</PRE><PRE> var filter = hasHandler(doc, &quot;beforeChange&quot;) || doc.cm &amp;&amp; hasHandler(doc.cm, &quot;beforeChange&quot;)
</PRE><PRE> var loop = function ( i ) {
   var change = event.changes[i]
   change.origin = type
   if (filter &amp;&amp; !filterChange(doc, change, false)) {
     source.length = 0
     return {}
   }
</PRE><PRE>   antiChanges.push(historyChangeFromChange(doc, change))
</PRE><PRE>   var after = i ? computeSelAfterChange(doc, change) : lst(source)
   makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change))
   if (!i &amp;&amp; doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}) }
   var rebased = []
</PRE><PRE>   // Propagate to the linked documents
   linkedDocs(doc, function (doc, sharedHist) {
     if (!sharedHist &amp;&amp; indexOf(rebased, doc.history) == -1) {
       rebaseHist(doc.history, change)
       rebased.push(doc.history)
     }
     makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
   })
 };
</PRE><PRE> for (var i$1 = event.changes.length - 1; i$1 &gt;= 0; --i$1) {
   var returned = loop( i$1 );
</PRE><PRE>   if ( returned ) return returned.v;
 }
</PRE><P>}
</P><P>// Sub-views need their line numbers shifted when text is added
// above or below them in the parent document.
function shiftDoc(doc, distance) {
</P><PRE> if (distance == 0) { return }
 doc.first += distance
 doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
   Pos(range.anchor.line + distance, range.anchor.ch),
   Pos(range.head.line + distance, range.head.ch)
 ); }), doc.sel.primIndex)
 if (doc.cm) {
   regChange(doc.cm, doc.first, doc.first - distance, distance)
   for (var d = doc.cm.display, l = d.viewFrom; l &lt; d.viewTo; l++)
     { regLineChange(doc.cm, l, &quot;gutter&quot;) }
 }
</PRE><P>}
</P><P>// More lower-level change function, handling only a single document
// (not linked ones).
function makeChangeSingleDoc(doc, change, selAfter, spans) {
</P><PRE> if (doc.cm &amp;&amp; !doc.cm.curOp)
   { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }
</PRE><PRE> if (change.to.line &lt; doc.first) {
   shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line))
   return
 }
 if (change.from.line &gt; doc.lastLine()) { return }
</PRE><PRE> // Clip the change to the size of this doc
 if (change.from.line &lt; doc.first) {
   var shift = change.text.length - 1 - (doc.first - change.from.line)
   shiftDoc(doc, shift)
   change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
             text: [lst(change.text)], origin: change.origin}
 }
 var last = doc.lastLine()
 if (change.to.line &gt; last) {
   change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
             text: [change.text[0]], origin: change.origin}
 }
</PRE><PRE> change.removed = getBetween(doc, change.from, change.to)
</PRE><PRE> if (!selAfter) { selAfter = computeSelAfterChange(doc, change) }
 if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans) }
 else { updateDoc(doc, change, spans) }
 setSelectionNoUndo(doc, selAfter, sel_dontScroll)
</PRE><P>}
</P><P>// Handle the interaction of a change to a document with the editor
// that this document is part of.
function makeChangeSingleDocInEditor(cm, change, spans) {
</P><PRE> var doc = cm.doc, display = cm.display, from = change.from, to = change.to
</PRE><PRE> var recomputeMaxLength = false, checkWidthStart = from.line
 if (!cm.options.lineWrapping) {
   checkWidthStart = lineNo(visualLine(getLine(doc, from.line)))
   doc.iter(checkWidthStart, to.line + 1, function (line) {
     if (line == display.maxLine) {
       recomputeMaxLength = true
       return true
     }
   })
 }
</PRE><PRE> if (doc.sel.contains(change.from, change.to) &gt; -1)
   { signalCursorActivity(cm) }
</PRE><PRE> updateDoc(doc, change, spans, estimateHeight(cm))
</PRE><PRE> if (!cm.options.lineWrapping) {
   doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
     var len = lineLength(line)
     if (len &gt; display.maxLineLength) {
       display.maxLine = line
       display.maxLineLength = len
       display.maxLineChanged = true
       recomputeMaxLength = false
     }
   })
   if (recomputeMaxLength) { cm.curOp.updateMaxLine = true }
 }
</PRE><PRE> // Adjust frontier, schedule worker
 doc.frontier = Math.min(doc.frontier, from.line)
 startWorker(cm, 400)
</PRE><PRE> var lendiff = change.text.length - (to.line - from.line) - 1
 // Remember that these lines changed, for updating the display
 if (change.full)
   { regChange(cm) }
 else if (from.line == to.line &amp;&amp; change.text.length == 1 &amp;&amp; !isWholeLineUpdate(cm.doc, change))
   { regLineChange(cm, from.line, &quot;text&quot;) }
 else
   { regChange(cm, from.line, to.line + 1, lendiff) }
</PRE><PRE> var changesHandler = hasHandler(cm, &quot;changes&quot;), changeHandler = hasHandler(cm, &quot;change&quot;)
 if (changeHandler || changesHandler) {
   var obj = {
     from: from, to: to,
     text: change.text,
     removed: change.removed,
     origin: change.origin
   }
   if (changeHandler) { signalLater(cm, &quot;change&quot;, cm, obj) }
   if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj) }
 }
 cm.display.selForContextMenu = null
</PRE><P>}
</P><P>function replaceRange(doc, code, from, to, origin) {
</P><PRE> if (!to) { to = from }
 if (cmp(to, from) &lt; 0) { var tmp = to; to = from; from = tmp }
 if (typeof code == &quot;string&quot;) { code = doc.splitLines(code) }
 makeChange(doc, {from: from, to: to, text: code, origin: origin})
</PRE><P>}
</P><P>// Rebasing/resetting history to deal with externally-sourced changes
</P><P>function rebaseHistSelSingle(pos, from, to, diff) {
</P><PRE> if (to &lt; pos.line) {
   pos.line += diff
 } else if (from &lt; pos.line) {
   pos.line = from
   pos.ch = 0
 }
</PRE><P>}
</P><P>// Tries to rebase an array of history events given a change in the
// document. If the change touches the same lines as the event, the
// event, and everything 'behind' it, is discarded. If the change is
// before the event, the event's positions are updated. Uses a
// copy-on-write scheme for the positions, to avoid having to
// reallocate them all on every rebase, but also avoid problems with
// shared position objects being unsafely updated.
function rebaseHistArray(array, from, to, diff) {
</P><PRE> for (var i = 0; i &lt; array.length; ++i) {
   var sub = array[i], ok = true
   if (sub.ranges) {
     if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true }
     for (var j = 0; j &lt; sub.ranges.length; j++) {
       rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff)
       rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)
     }
     continue
   }
   for (var j$1 = 0; j$1 &lt; sub.changes.length; ++j$1) {
     var cur = sub.changes[j$1]
     if (to &lt; cur.from.line) {
       cur.from = Pos(cur.from.line + diff, cur.from.ch)
       cur.to = Pos(cur.to.line + diff, cur.to.ch)
     } else if (from &lt;= cur.to.line) {
       ok = false
       break
     }
   }
   if (!ok) {
     array.splice(0, i + 1)
     i = 0
   }
 }
</PRE><P>}
</P><P>function rebaseHist(hist, change) {
</P><PRE> var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1
 rebaseHistArray(hist.done, from, to, diff)
 rebaseHistArray(hist.undone, from, to, diff)
</PRE><P>}
</P><P>// Utility for applying a change to a line by handle or number,
// returning the number and optionally registering the line as
// changed.
function changeLine(doc, handle, changeType, op) {
</P><PRE> var no = handle, line = handle
 if (typeof handle == &quot;number&quot;) { line = getLine(doc, clipLine(doc, handle)) }
 else { no = lineNo(handle) }
 if (no == null) { return null }
 if (op(line, no) &amp;&amp; doc.cm) { regLineChange(doc.cm, no, changeType) }
 return line
</PRE><P>}
</P><P>// The document is represented as a BTree consisting of leaves, with
// chunk of lines in them, and branches, with up to ten leaves or
// other branch nodes below them. The top node is always a branch
// node, and is the document object itself (meaning it has
// additional methods and properties).
//
// All nodes have parent links. The tree is used both to go from
// line numbers to line objects, and to go from objects to numbers.
// It also indexes by height, and is used to convert between height
// and line object, and to find the total height of the document.
//
// See also <A rel="nofollow" class="external free" href="http://marijnhaverbeke.nl/blog/codemirror-line-tree.html">http://marijnhaverbeke.nl/blog/codemirror-line-tree.html</A></P><P>var LeafChunk = function(lines) {
</P><PRE> var this$1 = this;
</PRE><PRE> this.lines = lines
 this.parent = null
 var height = 0
 for (var i = 0; i &lt; lines.length; ++i) {
   lines[i].parent = this$1
   height += lines[i].height
 }
 this.height = height
</PRE><P>};
</P><P>LeafChunk.prototype.chunkSize = function () { return this.lines.length };
</P><P>// Remove the n lines at offset 'at'.
LeafChunk.prototype.removeInner = function (at, n) {
</P><PRE>   var this$1 = this;
</PRE><PRE> for (var i = at, e = at + n; i &lt; e; ++i) {
   var line = this$1.lines[i]
   this$1.height -= line.height
   cleanUpLine(line)
   signalLater(line, &quot;delete&quot;)
 }
 this.lines.splice(at, n)
</PRE><P>};
</P><P>// Helper used to collapse a small branch into a single leaf.
LeafChunk.prototype.collapse = function (lines) {
</P><PRE> lines.push.apply(lines, this.lines)
</PRE><P>};
</P><P>// Insert the given array of lines at offset 'at', count them as
// having the given height.
LeafChunk.prototype.insertInner = function (at, lines, height) {
</P><PRE>   var this$1 = this;
</PRE><PRE> this.height += height
 this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at))
 for (var i = 0; i &lt; lines.length; ++i) { lines[i].parent = this$1 }
</PRE><P>};
</P><P>// Used to iterate over a part of the tree.
LeafChunk.prototype.iterN = function (at, n, op) {
</P><PRE>   var this$1 = this;
</PRE><PRE> for (var e = at + n; at &lt; e; ++at)
   { if (op(this$1.lines[at])) { return true } }
</PRE><P>};
</P><P>var BranchChunk = function(children) {
</P><PRE> var this$1 = this;
</PRE><PRE> this.children = children
 var size = 0, height = 0
 for (var i = 0; i &lt; children.length; ++i) {
   var ch = children[i]
   size += ch.chunkSize(); height += ch.height
   ch.parent = this$1
 }
 this.size = size
 this.height = height
 this.parent = null
</PRE><P>};
</P><P>BranchChunk.prototype.chunkSize = function () { return this.size };
</P><P>BranchChunk.prototype.removeInner = function (at, n) {
</P><PRE>   var this$1 = this;
</PRE><PRE> this.size -= n
 for (var i = 0; i &lt; this.children.length; ++i) {
   var child = this$1.children[i], sz = child.chunkSize()
   if (at &lt; sz) {
     var rm = Math.min(n, sz - at), oldHeight = child.height
     child.removeInner(at, rm)
     this$1.height -= oldHeight - child.height
     if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null }
     if ((n -= rm) == 0) { break }
     at = 0
   } else { at -= sz }
 }
 // If the result is smaller than 25 lines, ensure that it is a
 // single leaf node.
 if (this.size - n &lt; 25 &amp;&amp;
     (this.children.length &gt; 1 || !(this.children[0] instanceof LeafChunk))) {
   var lines = []
   this.collapse(lines)
   this.children = [new LeafChunk(lines)]
   this.children[0].parent = this
 }
</PRE><P>};
</P><P>BranchChunk.prototype.collapse = function (lines) {
</P><PRE>   var this$1 = this;
</PRE><PRE> for (var i = 0; i &lt; this.children.length; ++i) { this$1.children[i].collapse(lines) }
</PRE><P>};
</P><P>BranchChunk.prototype.insertInner = function (at, lines, height) {
</P><PRE>   var this$1 = this;
</PRE><PRE> this.size += lines.length
 this.height += height
 for (var i = 0; i &lt; this.children.length; ++i) {
   var child = this$1.children[i], sz = child.chunkSize()
   if (at &lt;= sz) {
     child.insertInner(at, lines, height)
     if (child.lines &amp;&amp; child.lines.length &gt; 50) {
       // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
       // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
       var remaining = child.lines.length % 25 + 25
       for (var pos = remaining; pos &lt; child.lines.length;) {
         var leaf = new LeafChunk(child.lines.slice(pos, pos += 25))
         child.height -= leaf.height
         this$1.children.splice(++i, 0, leaf)
         leaf.parent = this$1
       }
       child.lines = child.lines.slice(0, remaining)
       this$1.maybeSpill()
     }
     break
   }
   at -= sz
 }
</PRE><P>};
</P><P>// When a node has grown, check whether it should be split.
BranchChunk.prototype.maybeSpill = function () {
</P><PRE> if (this.children.length &lt;= 10) { return }
 var me = this
 do {
   var spilled = me.children.splice(me.children.length - 5, 5)
   var sibling = new BranchChunk(spilled)
   if (!me.parent) { // Become the parent node
     var copy = new BranchChunk(me.children)
     copy.parent = me
     me.children = [copy, sibling]
     me = copy
  } else {
     me.size -= sibling.size
     me.height -= sibling.height
     var myIndex = indexOf(me.parent.children, me)
     me.parent.children.splice(myIndex + 1, 0, sibling)
   }
   sibling.parent = me.parent
 } while (me.children.length &gt; 10)
 me.parent.maybeSpill()
</PRE><P>};
</P><P>BranchChunk.prototype.iterN = function (at, n, op) {
</P><PRE>   var this$1 = this;
</PRE><PRE> for (var i = 0; i &lt; this.children.length; ++i) {
   var child = this$1.children[i], sz = child.chunkSize()
   if (at &lt; sz) {
     var used = Math.min(n, sz - at)
     if (child.iterN(at, used, op)) { return true }
     if ((n -= used) == 0) { break }
     at = 0
   } else { at -= sz }
 }
</PRE><P>};
</P><P>// Line widgets are block elements displayed above or below a line.
</P><P>var LineWidget = function(doc, node, options) {
</P><PRE> var this$1 = this;
</PRE><PRE> if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
   { this$1[opt] = options[opt] } } }
 this.doc = doc
 this.node = node
</PRE><P>};
</P><P>LineWidget.prototype.clear = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line)
 if (no == null || !ws) { return }
 for (var i = 0; i &lt; ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1) } }
 if (!ws.length) { line.widgets = null }
 var height = widgetHeight(this)
 updateLineHeight(line, Math.max(0, line.height - height))
 if (cm) {
   runInOp(cm, function () {
     adjustScrollWhenAboveVisible(cm, line, -height)
     regLineChange(cm, no, &quot;widget&quot;)
   })
   signalLater(cm, &quot;lineWidgetCleared&quot;, cm, this, no)
 }
</PRE><P>};
</P><P>LineWidget.prototype.changed = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> var oldH = this.height, cm = this.doc.cm, line = this.line
 this.height = null
 var diff = widgetHeight(this) - oldH
 if (!diff) { return }
 updateLineHeight(line, line.height + diff)
 if (cm) {
   runInOp(cm, function () {
     cm.curOp.forceUpdate = true
     adjustScrollWhenAboveVisible(cm, line, diff)
     signalLater(cm, &quot;lineWidgetChanged&quot;, cm, this$1, lineNo(line))
   })
 }
</PRE><P>};
eventMixin(LineWidget)
</P><P>function adjustScrollWhenAboveVisible(cm, line, diff) {
</P><PRE> if (heightAtLine(line) &lt; ((cm.curOp &amp;&amp; cm.curOp.scrollTop) || cm.doc.scrollTop))
   { addToScrollPos(cm, null, diff) }
</PRE><P>}
</P><P>function addLineWidget(doc, handle, node, options) {
</P><PRE> var widget = new LineWidget(doc, node, options)
 var cm = doc.cm
 if (cm &amp;&amp; widget.noHScroll) { cm.display.alignWidgets = true }
 changeLine(doc, handle, &quot;widget&quot;, function (line) {
   var widgets = line.widgets || (line.widgets = [])
   if (widget.insertAt == null) { widgets.push(widget) }
   else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget) }
   widget.line = line
   if (cm &amp;&amp; !lineIsHidden(doc, line)) {
     var aboveVisible = heightAtLine(line) &lt; doc.scrollTop
     updateLineHeight(line, line.height + widgetHeight(widget))
     if (aboveVisible) { addToScrollPos(cm, null, widget.height) }
     cm.curOp.forceUpdate = true
   }
   return true
 })
 signalLater(cm, &quot;lineWidgetAdded&quot;, cm, widget, typeof handle == &quot;number&quot; ? handle : lineNo(handle))
 return widget
</PRE><P>}
</P><P>// TEXTMARKERS
</P><P>// Created with markText and setBookmark methods. A TextMarker is a
// handle that can be used to clear or find a marked position in the
// document. Line objects hold arrays (markedSpans) containing
// {from, to, marker} object pointing to such marker objects, and
// indicating that such a marker is present on that line. Multiple
// lines may point to the same marker when it spans across lines.
// The spans will have null for their from/to properties when the
// marker continues beyond the start/end of the line. Markers have
// links back to the lines they currently touch.
</P><P>// Collapsed markers have unique ids, in order to be able to order
// them, which is needed for uniquely determining an outer marker
// when they overlap (they may nest, but not partially overlap).
var nextMarkerId = 0
</P><P>var TextMarker = function(doc, type) {
</P><PRE> this.lines = []
 this.type = type
 this.doc = doc
 this.id = ++nextMarkerId
</PRE><P>};
</P><P>// Clear the marker.
TextMarker.prototype.clear = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> if (this.explicitlyCleared) { return }
 var cm = this.doc.cm, withOp = cm &amp;&amp; !cm.curOp
 if (withOp) { startOperation(cm) }
 if (hasHandler(this, &quot;clear&quot;)) {
   var found = this.find()
   if (found) { signalLater(this, &quot;clear&quot;, found.from, found.to) }
 }
 var min = null, max = null
 for (var i = 0; i &lt; this.lines.length; ++i) {
   var line = this$1.lines[i]
   var span = getMarkedSpanFor(line.markedSpans, this$1)
   if (cm &amp;&amp; !this$1.collapsed) { regLineChange(cm, lineNo(line), &quot;text&quot;) }
   else if (cm) {
     if (span.to != null) { max = lineNo(line) }
     if (span.from != null) { min = lineNo(line) }
   }
   line.markedSpans = removeMarkedSpan(line.markedSpans, span)
   if (span.from == null &amp;&amp; this$1.collapsed &amp;&amp; !lineIsHidden(this$1.doc, line) &amp;&amp; cm)
     { updateLineHeight(line, textHeight(cm.display)) }
 }
 if (cm &amp;&amp; this.collapsed &amp;&amp; !cm.options.lineWrapping) { for (var i$1 = 0; i$1 &lt; this.lines.length; ++i$1) {
   var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual)
   if (len &gt; cm.display.maxLineLength) {
     cm.display.maxLine = visual
     cm.display.maxLineLength = len
     cm.display.maxLineChanged = true
   }
 } }
</PRE><PRE> if (min != null &amp;&amp; cm &amp;&amp; this.collapsed) { regChange(cm, min, max + 1) }
 this.lines.length = 0
 this.explicitlyCleared = true
 if (this.atomic &amp;&amp; this.doc.cantEdit) {
   this.doc.cantEdit = false
   if (cm) { reCheckSelection(cm.doc) }
 }
 if (cm) { signalLater(cm, &quot;markerCleared&quot;, cm, this, min, max) }
 if (withOp) { endOperation(cm) }
 if (this.parent) { this.parent.clear() }
</PRE><P>};
</P><P>// Find the position of the marker in the document. Returns a {from,
// to} object by default. Side can be passed to get a specific side
// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
// Pos objects returned contain a line object, rather than a line
// number (used to prevent looking up the same line twice).
TextMarker.prototype.find = function (side, lineObj) {
</P><PRE>   var this$1 = this;
</PRE><PRE> if (side == null &amp;&amp; this.type == &quot;bookmark&quot;) { side = 1 }
 var from, to
 for (var i = 0; i &lt; this.lines.length; ++i) {
   var line = this$1.lines[i]
   var span = getMarkedSpanFor(line.markedSpans, this$1)
   if (span.from != null) {
     from = Pos(lineObj ? line : lineNo(line), span.from)
     if (side == -1) { return from }
   }
   if (span.to != null) {
     to = Pos(lineObj ? line : lineNo(line), span.to)
     if (side == 1) { return to }
   }
 }
 return from &amp;&amp; {from: from, to: to}
</PRE><P>};
</P><P>// Signals that the marker's widget changed, and surrounding layout
// should be recomputed.
TextMarker.prototype.changed = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> var pos = this.find(-1, true), widget = this, cm = this.doc.cm
 if (!pos || !cm) { return }
 runInOp(cm, function () {
   var line = pos.line, lineN = lineNo(pos.line)
   var view = findViewForLine(cm, lineN)
   if (view) {
     clearLineMeasurementCacheFor(view)
     cm.curOp.selectionChanged = cm.curOp.forceUpdate = true
   }
   cm.curOp.updateMaxLine = true
   if (!lineIsHidden(widget.doc, line) &amp;&amp; widget.height != null) {
     var oldHeight = widget.height
     widget.height = null
     var dHeight = widgetHeight(widget) - oldHeight
     if (dHeight)
       { updateLineHeight(line, line.height + dHeight) }
   }
   signalLater(cm, &quot;markerChanged&quot;, cm, this$1)
 })
</PRE><P>};
</P><P>TextMarker.prototype.attachLine = function (line) {
</P><PRE> if (!this.lines.length &amp;&amp; this.doc.cm) {
   var op = this.doc.cm.curOp
   if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
     { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this) }
 }
 this.lines.push(line)
</PRE><P>};
</P><P>TextMarker.prototype.detachLine = function (line) {
</P><PRE> this.lines.splice(indexOf(this.lines, line), 1)
 if (!this.lines.length &amp;&amp; this.doc.cm) {
   var op = this.doc.cm.curOp
   ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
 }
</PRE><P>};
eventMixin(TextMarker)
</P><P>// Create a marker, wire it up to the right lines, and
function markText(doc, from, to, options, type) {
</P><PRE> // Shared markers (across linked documents) are handled separately
 // (markTextShared will call out to this again, once per
 // document).
 if (options &amp;&amp; options.shared) { return markTextShared(doc, from, to, options, type) }
 // Ensure we are in an operation.
 if (doc.cm &amp;&amp; !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }
</PRE><PRE> var marker = new TextMarker(doc, type), diff = cmp(from, to)
 if (options) { copyObj(options, marker, false) }
 // Don't connect empty markers unless clearWhenEmpty is false
 if (diff &gt; 0 || diff == 0 &amp;&amp; marker.clearWhenEmpty !== false)
   { return marker }
 if (marker.replacedWith) {
   // Showing up as a widget implies collapsed (widget replaces text)
   marker.collapsed = true
   marker.widgetNode = elt(&quot;span&quot;, [marker.replacedWith], &quot;CodeMirror-widget&quot;)
   marker.widgetNode.setAttribute(&quot;role&quot;, &quot;presentation&quot;) // hide from accessibility tree
   if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(&quot;cm-ignore-events&quot;, &quot;true&quot;) }
   if (options.insertLeft) { marker.widgetNode.insertLeft = true }
 }
 if (marker.collapsed) {
   if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
       from.line != to.line &amp;&amp; conflictingCollapsedRange(doc, to.line, from, to, marker))
     { throw new Error(&quot;Inserting collapsed marker partially overlapping an existing one&quot;) }
   seeCollapsedSpans()
 }
</PRE><PRE> if (marker.addToHistory)
   { addChangeToHistory(doc, {from: from, to: to, origin: &quot;markText&quot;}, doc.sel, NaN) }
</PRE><PRE> var curLine = from.line, cm = doc.cm, updateMaxLine
 doc.iter(curLine, to.line + 1, function (line) {
   if (cm &amp;&amp; marker.collapsed &amp;&amp; !cm.options.lineWrapping &amp;&amp; visualLine(line) == cm.display.maxLine)
     { updateMaxLine = true }
   if (marker.collapsed &amp;&amp; curLine != from.line) { updateLineHeight(line, 0) }
   addMarkedSpan(line, new MarkedSpan(marker,
                                      curLine == from.line ? from.ch : null,
                                      curLine == to.line ? to.ch : null))
   ++curLine
 })
 // lineIsHidden depends on the presence of the spans, so needs a second pass
 if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
   if (lineIsHidden(doc, line)) { updateLineHeight(line, 0) }
 }) }
</PRE><PRE> if (marker.clearOnEnter) { on(marker, &quot;beforeCursorEnter&quot;, function () { return marker.clear(); }) }
</PRE><PRE> if (marker.readOnly) {
   seeReadOnlySpans()
   if (doc.history.done.length || doc.history.undone.length)
     { doc.clearHistory() }
 }
 if (marker.collapsed) {
   marker.id = ++nextMarkerId
   marker.atomic = true
 }
 if (cm) {
   // Sync editor state
   if (updateMaxLine) { cm.curOp.updateMaxLine = true }
   if (marker.collapsed)
     { regChange(cm, from.line, to.line + 1) }
   else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
     { for (var i = from.line; i &lt;= to.line; i++) { regLineChange(cm, i, &quot;text&quot;) } }
   if (marker.atomic) { reCheckSelection(cm.doc) }
   signalLater(cm, &quot;markerAdded&quot;, cm, marker)
 }
 return marker
</PRE><P>}
</P><P>// SHARED TEXTMARKERS
</P><P>// A shared marker spans multiple linked documents. It is
// implemented as a meta-marker-object controlling multiple normal
// markers.
var SharedTextMarker = function(markers, primary) {
</P><PRE> var this$1 = this;
</PRE><PRE> this.markers = markers
 this.primary = primary
 for (var i = 0; i &lt; markers.length; ++i)
   { markers[i].parent = this$1 }
</PRE><P>};
</P><P>SharedTextMarker.prototype.clear = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> if (this.explicitlyCleared) { return }
 this.explicitlyCleared = true
 for (var i = 0; i &lt; this.markers.length; ++i)
   { this$1.markers[i].clear() }
 signalLater(this, &quot;clear&quot;)
</PRE><P>};
</P><P>SharedTextMarker.prototype.find = function (side, lineObj) {
</P><PRE> return this.primary.find(side, lineObj)
</PRE><P>};
eventMixin(SharedTextMarker)
</P><P>function markTextShared(doc, from, to, options, type) {
</P><PRE> options = copyObj(options)
 options.shared = false
 var markers = [markText(doc, from, to, options, type)], primary = markers[0]
 var widget = options.widgetNode
 linkedDocs(doc, function (doc) {
   if (widget) { options.widgetNode = widget.cloneNode(true) }
   markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type))
   for (var i = 0; i &lt; doc.linked.length; ++i)
     { if (doc.linked[i].isParent) { return } }
   primary = lst(markers)
 })
 return new SharedTextMarker(markers, primary)
</PRE><P>}
</P><P>function findSharedMarkers(doc) {
</P><PRE> return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
</PRE><P>}
</P><P>function copySharedMarkers(doc, markers) {
</P><PRE> for (var i = 0; i &lt; markers.length; i++) {
   var marker = markers[i], pos = marker.find()
   var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to)
   if (cmp(mFrom, mTo)) {
     var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type)
     marker.markers.push(subMark)
     subMark.parent = marker
   }
 }
</PRE><P>}
</P><P>function detachSharedMarkers(markers) {
</P><PRE> var loop = function ( i ) {
   var marker = markers[i], linked = [marker.primary.doc]
   linkedDocs(marker.primary.doc, function (d) { return linked.push(d); })
   for (var j = 0; j &lt; marker.markers.length; j++) {
     var subMarker = marker.markers[j]
     if (indexOf(linked, subMarker.doc) == -1) {
       subMarker.parent = null
       marker.markers.splice(j--, 1)
     }
   }
 };
</PRE><PRE> for (var i = 0; i &lt; markers.length; i++) loop( i );
</PRE><P>}
</P><P>var nextDocId = 0
var Doc = function(text, mode, firstLine, lineSep) {
</P><PRE> if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep) }
 if (firstLine == null) { firstLine = 0 }
</PRE><PRE> BranchChunk.call(this, [new LeafChunk([new Line(&quot;&quot;, null)])])
 this.first = firstLine
 this.scrollTop = this.scrollLeft = 0
 this.cantEdit = false
 this.cleanGeneration = 1
 this.frontier = firstLine
 var start = Pos(firstLine, 0)
 this.sel = simpleSelection(start)
 this.history = new History(null)
 this.id = ++nextDocId
 this.modeOption = mode
 this.lineSep = lineSep
 this.extend = false
</PRE><PRE> if (typeof text == &quot;string&quot;) { text = this.splitLines(text) }
 updateDoc(this, {from: start, to: start, text: text})
 setSelection(this, simpleSelection(start), sel_dontScroll)
</PRE><P>}
</P><P>Doc.prototype = createObj(BranchChunk.prototype, {
</P><PRE> constructor: Doc,
 // Iterate over the document. Supports two forms -- with only one
 // argument, it calls that for each line in the document. With
 // three, it iterates over the range given by the first two (with
 // the second being non-inclusive).
 iter: function(from, to, op) {
   if (op) { this.iterN(from - this.first, to - from, op) }
   else { this.iterN(this.first, this.first + this.size, from) }
 },
</PRE><PRE> // Non-public interface for adding and removing lines.
 insert: function(at, lines) {
   var height = 0
   for (var i = 0; i &lt; lines.length; ++i) { height += lines[i].height }
   this.insertInner(at - this.first, lines, height)
 },
 remove: function(at, n) { this.removeInner(at - this.first, n) },
</PRE><PRE> // From here, the methods are part of the public interface. Most
 // are also available from CodeMirror (editor) instances.
</PRE><PRE> getValue: function(lineSep) {
   var lines = getLines(this, this.first, this.first + this.size)
   if (lineSep === false) { return lines }
   return lines.join(lineSep || this.lineSeparator())
 },
 setValue: docMethodOp(function(code) {
   var top = Pos(this.first, 0), last = this.first + this.size - 1
   makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                     text: this.splitLines(code), origin: &quot;setValue&quot;, full: true}, true)
   setSelection(this, simpleSelection(top))
 }),
 replaceRange: function(code, from, to, origin) {
   from = clipPos(this, from)
   to = to ? clipPos(this, to) : from
   replaceRange(this, code, from, to, origin)
 },
 getRange: function(from, to, lineSep) {
   var lines = getBetween(this, clipPos(this, from), clipPos(this, to))
   if (lineSep === false) { return lines }
   return lines.join(lineSep || this.lineSeparator())
 },
</PRE><PRE> getLine: function(line) {var l = this.getLineHandle(line); return l &amp;&amp; l.text},
</PRE><PRE> getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
 getLineNumber: function(line) {return lineNo(line)},
</PRE><PRE> getLineHandleVisualStart: function(line) {
   if (typeof line == &quot;number&quot;) { line = getLine(this, line) }
   return visualLine(line)
 },
</PRE><PRE> lineCount: function() {return this.size},
 firstLine: function() {return this.first},
 lastLine: function() {return this.first + this.size - 1},
</PRE><PRE> clipPos: function(pos) {return clipPos(this, pos)},
</PRE><PRE> getCursor: function(start) {
   var range = this.sel.primary(), pos
   if (start == null || start == &quot;head&quot;) { pos = range.head }
   else if (start == &quot;anchor&quot;) { pos = range.anchor }
   else if (start == &quot;end&quot; || start == &quot;to&quot; || start === false) { pos = range.to() }
   else { pos = range.from() }
   return pos
 },
 listSelections: function() { return this.sel.ranges },
 somethingSelected: function() {return this.sel.somethingSelected()},
</PRE><PRE> setCursor: docMethodOp(function(line, ch, options) {
   setSimpleSelection(this, clipPos(this, typeof line == &quot;number&quot; ? Pos(line, ch || 0) : line), null, options)
 }),
 setSelection: docMethodOp(function(anchor, head, options) {
   setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)
 }),
 extendSelection: docMethodOp(function(head, other, options) {
   extendSelection(this, clipPos(this, head), other &amp;&amp; clipPos(this, other), options)
 }),
 extendSelections: docMethodOp(function(heads, options) {
   extendSelections(this, clipPosArray(this, heads), options)
 }),
 extendSelectionsBy: docMethodOp(function(f, options) {
   var heads = map(this.sel.ranges, f)
   extendSelections(this, clipPosArray(this, heads), options)
 }),
 setSelections: docMethodOp(function(ranges, primary, options) {
   var this$1 = this;
</PRE><PRE>   if (!ranges.length) { return }
   var out = []
   for (var i = 0; i &lt; ranges.length; i++)
     { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                        clipPos(this$1, ranges[i].head)) }
   if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex) }
   setSelection(this, normalizeSelection(out, primary), options)
 }),
 addSelection: docMethodOp(function(anchor, head, options) {
   var ranges = this.sel.ranges.slice(0)
   ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)))
   setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)
 }),
</PRE><PRE> getSelection: function(lineSep) {
   var this$1 = this;
</PRE><PRE>   var ranges = this.sel.ranges, lines
   for (var i = 0; i &lt; ranges.length; i++) {
     var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())
     lines = lines ? lines.concat(sel) : sel
   }
   if (lineSep === false) { return lines }
   else { return lines.join(lineSep || this.lineSeparator()) }
 },
 getSelections: function(lineSep) {
   var this$1 = this;
</PRE><PRE>   var parts = [], ranges = this.sel.ranges
   for (var i = 0; i &lt; ranges.length; i++) {
     var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())
     if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()) }
     parts[i] = sel
   }
   return parts
 },
 replaceSelection: function(code, collapse, origin) {
   var dup = []
   for (var i = 0; i &lt; this.sel.ranges.length; i++)
     { dup[i] = code }
   this.replaceSelections(dup, collapse, origin || &quot;+input&quot;)
 },
 replaceSelections: docMethodOp(function(code, collapse, origin) {
   var this$1 = this;
</PRE><PRE>   var changes = [], sel = this.sel
   for (var i = 0; i &lt; sel.ranges.length; i++) {
     var range = sel.ranges[i]
     changes[i] = {from: range.from(), to: range.to(), text: this$1.splitLines(code[i]), origin: origin}
   }
   var newSel = collapse &amp;&amp; collapse != &quot;end&quot; &amp;&amp; computeReplacedSel(this, changes, collapse)
   for (var i$1 = changes.length - 1; i$1 &gt;= 0; i$1--)
     { makeChange(this$1, changes[i$1]) }
   if (newSel) { setSelectionReplaceHistory(this, newSel) }
   else if (this.cm) { ensureCursorVisible(this.cm) }
 }),
 undo: docMethodOp(function() {makeChangeFromHistory(this, &quot;undo&quot;)}),
 redo: docMethodOp(function() {makeChangeFromHistory(this, &quot;redo&quot;)}),
 undoSelection: docMethodOp(function() {makeChangeFromHistory(this, &quot;undo&quot;, true)}),
 redoSelection: docMethodOp(function() {makeChangeFromHistory(this, &quot;redo&quot;, true)}),
</PRE><PRE> setExtending: function(val) {this.extend = val},
 getExtending: function() {return this.extend},
</PRE><PRE> historySize: function() {
   var hist = this.history, done = 0, undone = 0
   for (var i = 0; i &lt; hist.done.length; i++) { if (!hist.done[i].ranges) { ++done } }
   for (var i$1 = 0; i$1 &lt; hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone } }
   return {undo: done, redo: undone}
 },
 clearHistory: function() {this.history = new History(this.history.maxGeneration)},
</PRE><PRE> markClean: function() {
   this.cleanGeneration = this.changeGeneration(true)
 },
 changeGeneration: function(forceSplit) {
   if (forceSplit)
     { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null }
   return this.history.generation
 },
 isClean: function (gen) {
   return this.history.generation == (gen || this.cleanGeneration)
 },
</PRE><PRE> getHistory: function() {
   return {done: copyHistoryArray(this.history.done),
           undone: copyHistoryArray(this.history.undone)}
 },
 setHistory: function(histData) {
   var hist = this.history = new History(this.history.maxGeneration)
   hist.done = copyHistoryArray(histData.done.slice(0), null, true)
   hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)
 },
</PRE><PRE> setGutterMarker: docMethodOp(function(line, gutterID, value) {
   return changeLine(this, line, &quot;gutter&quot;, function (line) {
     var markers = line.gutterMarkers || (line.gutterMarkers = {})
     markers[gutterID] = value
     if (!value &amp;&amp; isEmpty(markers)) { line.gutterMarkers = null }
     return true
   })
 }),
</PRE><PRE> clearGutter: docMethodOp(function(gutterID) {
   var this$1 = this;
</PRE><PRE>   this.iter(function (line) {
     if (line.gutterMarkers &amp;&amp; line.gutterMarkers[gutterID]) {
       changeLine(this$1, line, &quot;gutter&quot;, function () {
         line.gutterMarkers[gutterID] = null
         if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null }
         return true
       })
     }
   })
 }),
</PRE><PRE> lineInfo: function(line) {
   var n
   if (typeof line == &quot;number&quot;) {
     if (!isLine(this, line)) { return null }
     n = line
     line = getLine(this, line)
     if (!line) { return null }
   } else {
     n = lineNo(line)
     if (n == null) { return null }
   }
   return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
           textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
           widgets: line.widgets}
 },
</PRE><PRE> addLineClass: docMethodOp(function(handle, where, cls) {
   return changeLine(this, handle, where == &quot;gutter&quot; ? &quot;gutter&quot; : &quot;class&quot;, function (line) {
     var prop = where == &quot;text&quot; ? &quot;textClass&quot;
              : where == &quot;background&quot; ? &quot;bgClass&quot;
              : where == &quot;gutter&quot; ? &quot;gutterClass&quot; : &quot;wrapClass&quot;
     if (!line[prop]) { line[prop] = cls }
     else if (classTest(cls).test(line[prop])) { return false }
     else { line[prop] += &quot; &quot; + cls }
     return true
   })
 }),
 removeLineClass: docMethodOp(function(handle, where, cls) {
   return changeLine(this, handle, where == &quot;gutter&quot; ? &quot;gutter&quot; : &quot;class&quot;, function (line) {
     var prop = where == &quot;text&quot; ? &quot;textClass&quot;
              : where == &quot;background&quot; ? &quot;bgClass&quot;
              : where == &quot;gutter&quot; ? &quot;gutterClass&quot; : &quot;wrapClass&quot;
     var cur = line[prop]
     if (!cur) { return false }
     else if (cls == null) { line[prop] = null }
     else {
       var found = cur.match(classTest(cls))
       if (!found) { return false }
       var end = found.index + found[0].length
       line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? &quot;&quot; : &quot; &quot;) + cur.slice(end) || null
     }
     return true
   })
 }),
</PRE><PRE> addLineWidget: docMethodOp(function(handle, node, options) {
   return addLineWidget(this, handle, node, options)
 }),
 removeLineWidget: function(widget) { widget.clear() },
</PRE><PRE> markText: function(from, to, options) {
   return markText(this, clipPos(this, from), clipPos(this, to), options, options &amp;&amp; options.type || &quot;range&quot;)
 },
 setBookmark: function(pos, options) {
   var realOpts = {replacedWith: options &amp;&amp; (options.nodeType == null ? options.widget : options),
                   insertLeft: options &amp;&amp; options.insertLeft,
                   clearWhenEmpty: false, shared: options &amp;&amp; options.shared,
                   handleMouseEvents: options &amp;&amp; options.handleMouseEvents}
   pos = clipPos(this, pos)
   return markText(this, pos, pos, realOpts, &quot;bookmark&quot;)
 },
 findMarksAt: function(pos) {
   pos = clipPos(this, pos)
   var markers = [], spans = getLine(this, pos.line).markedSpans
   if (spans) { for (var i = 0; i &lt; spans.length; ++i) {
     var span = spans[i]
     if ((span.from == null || span.from &lt;= pos.ch) &amp;&amp;
         (span.to == null || span.to &gt;= pos.ch))
       { markers.push(span.marker.parent || span.marker) }
   } }
   return markers
 },
 findMarks: function(from, to, filter) {
   from = clipPos(this, from); to = clipPos(this, to)
   var found = [], lineNo = from.line
   this.iter(from.line, to.line + 1, function (line) {
     var spans = line.markedSpans
     if (spans) { for (var i = 0; i &lt; spans.length; i++) {
       var span = spans[i]
       if (!(span.to != null &amp;&amp; lineNo == from.line &amp;&amp; from.ch &gt;= span.to ||
             span.from == null &amp;&amp; lineNo != from.line ||
             span.from != null &amp;&amp; lineNo == to.line &amp;&amp; span.from &gt;= to.ch) &amp;&amp;
           (!filter || filter(span.marker)))
         { found.push(span.marker.parent || span.marker) }
     } }
     ++lineNo
   })
   return found
 },
 getAllMarks: function() {
   var markers = []
   this.iter(function (line) {
     var sps = line.markedSpans
     if (sps) { for (var i = 0; i &lt; sps.length; ++i)
       { if (sps[i].from != null) { markers.push(sps[i].marker) } } }
   })
   return markers
 },
</PRE><PRE> posFromIndex: function(off) {
   var ch, lineNo = this.first, sepSize = this.lineSeparator().length
   this.iter(function (line) {
     var sz = line.text.length + sepSize
     if (sz &gt; off) { ch = off; return true }
     off -= sz
     ++lineNo
   })
   return clipPos(this, Pos(lineNo, ch))
 },
 indexFromPos: function (coords) {
   coords = clipPos(this, coords)
   var index = coords.ch
   if (coords.line &lt; this.first || coords.ch &lt; 0) { return 0 }
   var sepSize = this.lineSeparator().length
   this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
     index += line.text.length + sepSize
   })
   return index
 },
</PRE><PRE> copy: function(copyHistory) {
   var doc = new Doc(getLines(this, this.first, this.first + this.size),
                     this.modeOption, this.first, this.lineSep)
   doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft
   doc.sel = this.sel
   doc.extend = false
   if (copyHistory) {
     doc.history.undoDepth = this.history.undoDepth
     doc.setHistory(this.getHistory())
   }
   return doc
 },
</PRE><PRE> linkedDoc: function(options) {
   if (!options) { options = {} }
   var from = this.first, to = this.first + this.size
   if (options.from != null &amp;&amp; options.from &gt; from) { from = options.from }
   if (options.to != null &amp;&amp; options.to &lt; to) { to = options.to }
   var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep)
   if (options.sharedHist) { copy.history = this.history
   ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist})
   copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}]
   copySharedMarkers(copy, findSharedMarkers(this))
   return copy
 },
 unlinkDoc: function(other) {
   var this$1 = this;
</PRE><PRE>   if (other instanceof CodeMirror) { other = other.doc }
   if (this.linked) { for (var i = 0; i &lt; this.linked.length; ++i) {
     var link = this$1.linked[i]
     if (link.doc != other) { continue }
     this$1.linked.splice(i, 1)
     other.unlinkDoc(this$1)
     detachSharedMarkers(findSharedMarkers(this$1))
     break
   } }
   // If the histories were shared, split them again
   if (other.history == this.history) {
     var splitIds = [other.id]
     linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true)
     other.history = new History(null)
     other.history.done = copyHistoryArray(this.history.done, splitIds)
     other.history.undone = copyHistoryArray(this.history.undone, splitIds)
   }
 },
 iterLinkedDocs: function(f) {linkedDocs(this, f)},
</PRE><PRE> getMode: function() {return this.mode},
 getEditor: function() {return this.cm},
</PRE><PRE> splitLines: function(str) {
   if (this.lineSep) { return str.split(this.lineSep) }
   return splitLinesAuto(str)
 },
 lineSeparator: function() { return this.lineSep || &quot;\n&quot; }
</PRE><P>})
</P><P>// Public alias.
Doc.prototype.eachLine = Doc.prototype.iter
</P><P>// Kludge to work around strange IE behavior where it'll sometimes
// re-fire a series of drag-related events right after the drop (#1551)
var lastDrop = 0
</P><P>function onDrop(e) {
</P><PRE> var cm = this
 clearDragCursor(cm)
 if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
   { return }
 e_preventDefault(e)
 if (ie) { lastDrop = +new Date }
 var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files
 if (!pos || cm.isReadOnly()) { return }
 // Might be a file drop, in which case we simply extract the text
 // and insert it.
 if (files &amp;&amp; files.length &amp;&amp; window.FileReader &amp;&amp; window.File) {
   var n = files.length, text = Array(n), read = 0
   var loadFile = function (file, i) {
     if (cm.options.allowDropFileTypes &amp;&amp;
         indexOf(cm.options.allowDropFileTypes, file.type) == -1)
       { return }
</PRE><PRE>     var reader = new FileReader
     reader.onload = operation(cm, function () {
       var content = reader.result
       if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = &quot;&quot; }
       text[i] = content
       if (++read == n) {
         pos = clipPos(cm.doc, pos)
         var change = {from: pos, to: pos,
                       text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                       origin: &quot;paste&quot;}
         makeChange(cm.doc, change)
         setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))
       }
     })
     reader.readAsText(file)
   }
   for (var i = 0; i &lt; n; ++i) { loadFile(files[i], i) }
 } else { // Normal drop
   // Don't do a replace if the drop happened inside of the selected text.
   if (cm.state.draggingText &amp;&amp; cm.doc.sel.contains(pos) &gt; -1) {
     cm.state.draggingText(e)
     // Ensure the editor is re-focused
     setTimeout(function () { return cm.display.input.focus(); }, 20)
     return
   }
   try {
     var text$1 = e.dataTransfer.getData(&quot;Text&quot;)
     if (text$1) {
       var selected
       if (cm.state.draggingText &amp;&amp; !cm.state.draggingText.copy)
         { selected = cm.listSelections() }
       setSelectionNoUndo(cm.doc, simpleSelection(pos, pos))
       if (selected) { for (var i$1 = 0; i$1 &lt; selected.length; ++i$1)
         { replaceRange(cm.doc, &quot;&quot;, selected[i$1].anchor, selected[i$1].head, &quot;drag&quot;) } }
       cm.replaceSelection(text$1, &quot;around&quot;, &quot;paste&quot;)
       cm.display.input.focus()
     }
   }
   catch(e){}
 }
</PRE><P>}
</P><P>function onDragStart(cm, e) {
</P><PRE> if (ie &amp;&amp; (!cm.state.draggingText || +new Date - lastDrop &lt; 100)) { e_stop(e); return }
 if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }
</PRE><PRE> e.dataTransfer.setData(&quot;Text&quot;, cm.getSelection())
 e.dataTransfer.effectAllowed = &quot;copyMove&quot;
</PRE><PRE> // Use dummy image instead of default browsers image.
 // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
 if (e.dataTransfer.setDragImage &amp;&amp; !safari) {
   var img = elt(&quot;img&quot;, null, null, &quot;position: fixed; left: 0; top: 0;&quot;)
   img.src = &quot;data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==&quot;
   if (presto) {
     img.width = img.height = 1
     cm.display.wrapper.appendChild(img)
     // Force a relayout, or Opera won't use our image for some obscure reason
     img._top = img.offsetTop
   }
   e.dataTransfer.setDragImage(img, 0, 0)
   if (presto) { img.parentNode.removeChild(img) }
 }
</PRE><P>}
</P><P>function onDragOver(cm, e) {
</P><PRE> var pos = posFromMouse(cm, e)
 if (!pos) { return }
 var frag = document.createDocumentFragment()
 drawSelectionCursor(cm, pos, frag)
 if (!cm.display.dragCursor) {
   cm.display.dragCursor = elt(&quot;div&quot;, null, &quot;CodeMirror-cursors CodeMirror-dragcursors&quot;)
   cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)
 }
 removeChildrenAndAdd(cm.display.dragCursor, frag)
</PRE><P>}
</P><P>function clearDragCursor(cm) {
</P><PRE> if (cm.display.dragCursor) {
   cm.display.lineSpace.removeChild(cm.display.dragCursor)
   cm.display.dragCursor = null
 }
</PRE><P>}
</P><P>// These must be handled carefully, because naively registering a
// handler for each editor will cause the editors to never be
// garbage collected.
</P><P>function forEachCodeMirror(f) {
</P><PRE> if (!document.body.getElementsByClassName) { return }
 var byClass = document.body.getElementsByClassName(&quot;CodeMirror&quot;)
 for (var i = 0; i &lt; byClass.length; i++) {
   var cm = byClass[i].CodeMirror
   if (cm) { f(cm) }
 }
</PRE><P>}
</P><P>var globalsRegistered = false
function ensureGlobalHandlers() {
</P><PRE> if (globalsRegistered) { return }
 registerGlobalHandlers()
 globalsRegistered = true
</PRE><P>}
function registerGlobalHandlers() {
</P><PRE> // When the window resizes, we need to refresh active editors.
 var resizeTimer
 on(window, &quot;resize&quot;, function () {
   if (resizeTimer == null) { resizeTimer = setTimeout(function () {
     resizeTimer = null
     forEachCodeMirror(onResize)
   }, 100) }
 })
 // When the window loses focus, we want to show the editor as blurred
 on(window, &quot;blur&quot;, function () { return forEachCodeMirror(onBlur); })
</PRE><P>}
// Called when the window resizes
function onResize(cm) {
</P><PRE> var d = cm.display
 if (d.lastWrapHeight == d.wrapper.clientHeight &amp;&amp; d.lastWrapWidth == d.wrapper.clientWidth)
   { return }
 // Might be a text scaling operation, clear size caches.
 d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null
 d.scrollbarsClipped = false
 cm.setSize()
</PRE><P>}
</P><P>var keyNames = {
</P><PRE> 3: &quot;Enter&quot;, 8: &quot;Backspace&quot;, 9: &quot;Tab&quot;, 13: &quot;Enter&quot;, 16: &quot;Shift&quot;, 17: &quot;Ctrl&quot;, 18: &quot;Alt&quot;,
 19: &quot;Pause&quot;, 20: &quot;CapsLock&quot;, 27: &quot;Esc&quot;, 32: &quot;Space&quot;, 33: &quot;PageUp&quot;, 34: &quot;PageDown&quot;, 35: &quot;End&quot;,
 36: &quot;Home&quot;, 37: &quot;Left&quot;, 38: &quot;Up&quot;, 39: &quot;Right&quot;, 40: &quot;Down&quot;, 44: &quot;PrintScrn&quot;, 45: &quot;Insert&quot;,
 46: &quot;Delete&quot;, 59: &quot;;&quot;, 61: &quot;=&quot;, 91: &quot;Mod&quot;, 92: &quot;Mod&quot;, 93: &quot;Mod&quot;,
 106: &quot;*&quot;, 107: &quot;=&quot;, 109: &quot;-&quot;, 110: &quot;.&quot;, 111: &quot;/&quot;, 127: &quot;Delete&quot;,
 173: &quot;-&quot;, 186: &quot;;&quot;, 187: &quot;=&quot;, 188: &quot;,&quot;, 189: &quot;-&quot;, 190: &quot;.&quot;, 191: &quot;/&quot;, 192: &quot;`&quot;, 219: &quot;[&quot;, 220: &quot;\\&quot;,
 221: &quot;]&quot;, 222: &quot;'&quot;, 63232: &quot;Up&quot;, 63233: &quot;Down&quot;, 63234: &quot;Left&quot;, 63235: &quot;Right&quot;, 63272: &quot;Delete&quot;,
 63273: &quot;Home&quot;, 63275: &quot;End&quot;, 63276: &quot;PageUp&quot;, 63277: &quot;PageDown&quot;, 63302: &quot;Insert&quot;
</PRE><P>}
</P><P>// Number keys
for (var i = 0; i &lt; 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i) }
// Alphabetic keys
for (var i$1 = 65; i$1 &lt;= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1) }
// Function keys
for (var i$2 = 1; i$2 &lt;= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = &quot;F&quot; + i$2 }
</P><P>var keyMap = {}
</P><P>keyMap.basic = {
</P><PRE> &quot;Left&quot;: &quot;goCharLeft&quot;, &quot;Right&quot;: &quot;goCharRight&quot;, &quot;Up&quot;: &quot;goLineUp&quot;, &quot;Down&quot;: &quot;goLineDown&quot;,
 &quot;End&quot;: &quot;goLineEnd&quot;, &quot;Home&quot;: &quot;goLineStartSmart&quot;, &quot;PageUp&quot;: &quot;goPageUp&quot;, &quot;PageDown&quot;: &quot;goPageDown&quot;,
 &quot;Delete&quot;: &quot;delCharAfter&quot;, &quot;Backspace&quot;: &quot;delCharBefore&quot;, &quot;Shift-Backspace&quot;: &quot;delCharBefore&quot;,
 &quot;Tab&quot;: &quot;defaultTab&quot;, &quot;Shift-Tab&quot;: &quot;indentAuto&quot;,
 &quot;Enter&quot;: &quot;newlineAndIndent&quot;, &quot;Insert&quot;: &quot;toggleOverwrite&quot;,
 &quot;Esc&quot;: &quot;singleSelection&quot;
</PRE><P>}
// Note that the save and find-related commands aren't defined by
// default. User code or addons can define them. Unknown commands
// are simply ignored.
keyMap.pcDefault = {
</P><PRE> &quot;Ctrl-A&quot;: &quot;selectAll&quot;, &quot;Ctrl-D&quot;: &quot;deleteLine&quot;, &quot;Ctrl-Z&quot;: &quot;undo&quot;, &quot;Shift-Ctrl-Z&quot;: &quot;redo&quot;, &quot;Ctrl-Y&quot;: &quot;redo&quot;,
 &quot;Ctrl-Home&quot;: &quot;goDocStart&quot;, &quot;Ctrl-End&quot;: &quot;goDocEnd&quot;, &quot;Ctrl-Up&quot;: &quot;goLineUp&quot;, &quot;Ctrl-Down&quot;: &quot;goLineDown&quot;,
 &quot;Ctrl-Left&quot;: &quot;goGroupLeft&quot;, &quot;Ctrl-Right&quot;: &quot;goGroupRight&quot;, &quot;Alt-Left&quot;: &quot;goLineStart&quot;, &quot;Alt-Right&quot;: &quot;goLineEnd&quot;,
 &quot;Ctrl-Backspace&quot;: &quot;delGroupBefore&quot;, &quot;Ctrl-Delete&quot;: &quot;delGroupAfter&quot;, &quot;Ctrl-S&quot;: &quot;save&quot;, &quot;Ctrl-F&quot;: &quot;find&quot;,
 &quot;Ctrl-G&quot;: &quot;findNext&quot;, &quot;Shift-Ctrl-G&quot;: &quot;findPrev&quot;, &quot;Shift-Ctrl-F&quot;: &quot;replace&quot;, &quot;Shift-Ctrl-R&quot;: &quot;replaceAll&quot;,
 &quot;Ctrl-[&quot;: &quot;indentLess&quot;, &quot;Ctrl-]&quot;: &quot;indentMore&quot;,
 &quot;Ctrl-U&quot;: &quot;undoSelection&quot;, &quot;Shift-Ctrl-U&quot;: &quot;redoSelection&quot;, &quot;Alt-U&quot;: &quot;redoSelection&quot;,
 fallthrough: &quot;basic&quot;
</PRE><P>}
// Very basic readline/emacs-style bindings, which are standard on Mac.
keyMap.emacsy = {
</P><PRE> &quot;Ctrl-F&quot;: &quot;goCharRight&quot;, &quot;Ctrl-B&quot;: &quot;goCharLeft&quot;, &quot;Ctrl-P&quot;: &quot;goLineUp&quot;, &quot;Ctrl-N&quot;: &quot;goLineDown&quot;,
 &quot;Alt-F&quot;: &quot;goWordRight&quot;, &quot;Alt-B&quot;: &quot;goWordLeft&quot;, &quot;Ctrl-A&quot;: &quot;goLineStart&quot;, &quot;Ctrl-E&quot;: &quot;goLineEnd&quot;,
 &quot;Ctrl-V&quot;: &quot;goPageDown&quot;, &quot;Shift-Ctrl-V&quot;: &quot;goPageUp&quot;, &quot;Ctrl-D&quot;: &quot;delCharAfter&quot;, &quot;Ctrl-H&quot;: &quot;delCharBefore&quot;,
 &quot;Alt-D&quot;: &quot;delWordAfter&quot;, &quot;Alt-Backspace&quot;: &quot;delWordBefore&quot;, &quot;Ctrl-K&quot;: &quot;killLine&quot;, &quot;Ctrl-T&quot;: &quot;transposeChars&quot;,
 &quot;Ctrl-O&quot;: &quot;openLine&quot;
</PRE><P>}
keyMap.macDefault = {
</P><PRE> &quot;Cmd-A&quot;: &quot;selectAll&quot;, &quot;Cmd-D&quot;: &quot;deleteLine&quot;, &quot;Cmd-Z&quot;: &quot;undo&quot;, &quot;Shift-Cmd-Z&quot;: &quot;redo&quot;, &quot;Cmd-Y&quot;: &quot;redo&quot;,
 &quot;Cmd-Home&quot;: &quot;goDocStart&quot;, &quot;Cmd-Up&quot;: &quot;goDocStart&quot;, &quot;Cmd-End&quot;: &quot;goDocEnd&quot;, &quot;Cmd-Down&quot;: &quot;goDocEnd&quot;, &quot;Alt-Left&quot;: &quot;goGroupLeft&quot;,
 &quot;Alt-Right&quot;: &quot;goGroupRight&quot;, &quot;Cmd-Left&quot;: &quot;goLineLeft&quot;, &quot;Cmd-Right&quot;: &quot;goLineRight&quot;, &quot;Alt-Backspace&quot;: &quot;delGroupBefore&quot;,
 &quot;Ctrl-Alt-Backspace&quot;: &quot;delGroupAfter&quot;, &quot;Alt-Delete&quot;: &quot;delGroupAfter&quot;, &quot;Cmd-S&quot;: &quot;save&quot;, &quot;Cmd-F&quot;: &quot;find&quot;,
 &quot;Cmd-G&quot;: &quot;findNext&quot;, &quot;Shift-Cmd-G&quot;: &quot;findPrev&quot;, &quot;Cmd-Alt-F&quot;: &quot;replace&quot;, &quot;Shift-Cmd-Alt-F&quot;: &quot;replaceAll&quot;,
 &quot;Cmd-[&quot;: &quot;indentLess&quot;, &quot;Cmd-]&quot;: &quot;indentMore&quot;, &quot;Cmd-Backspace&quot;: &quot;delWrappedLineLeft&quot;, &quot;Cmd-Delete&quot;: &quot;delWrappedLineRight&quot;,
 &quot;Cmd-U&quot;: &quot;undoSelection&quot;, &quot;Shift-Cmd-U&quot;: &quot;redoSelection&quot;, &quot;Ctrl-Up&quot;: &quot;goDocStart&quot;, &quot;Ctrl-Down&quot;: &quot;goDocEnd&quot;,
 fallthrough: [&quot;basic&quot;, &quot;emacsy&quot;]
</PRE><P>}
keyMap[&quot;default&quot;] = mac ? keyMap.macDefault : keyMap.pcDefault
</P><P>// KEYMAP DISPATCH
</P><P>function normalizeKeyName(name) {
</P><PRE> var parts = name.split(/-(?!$)/)
 name = parts[parts.length - 1]
 var alt, ctrl, shift, cmd
 for (var i = 0; i &lt; parts.length - 1; i++) {
   var mod = parts[i]
   if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true }
   else if (/^a(lt)?$/i.test(mod)) { alt = true }
   else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }
   else if (/^s(hift)?$/i.test(mod)) { shift = true }
   else { throw new Error(&quot;Unrecognized modifier name: &quot; + mod) }
 }
 if (alt) { name = &quot;Alt-&quot; + name }
 if (ctrl) { name = &quot;Ctrl-&quot; + name }
 if (cmd) { name = &quot;Cmd-&quot; + name }
 if (shift) { name = &quot;Shift-&quot; + name }
 return name
</PRE><P>}
</P><P>// This is a kludge to keep keymaps mostly working as raw objects
// (backwards compatibility) while at the same time support features
// like normalization and multi-stroke key bindings. It compiles a
// new normalized keymap, and then updates the old object to reflect
// this.
function normalizeKeyMap(keymap) {
</P><PRE> var copy = {}
 for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
   var value = keymap[keyname]
   if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
   if (value == &quot;...&quot;) { delete keymap[keyname]; continue }
</PRE><PRE>   var keys = map(keyname.split(&quot; &quot;), normalizeKeyName)
   for (var i = 0; i &lt; keys.length; i++) {
     var val = (void 0), name = (void 0)
     if (i == keys.length - 1) {
       name = keys.join(&quot; &quot;)
       val = value
     } else {
       name = keys.slice(0, i + 1).join(&quot; &quot;)
       val = &quot;...&quot;
     }
     var prev = copy[name]
     if (!prev) { copy[name] = val }
     else if (prev != val) { throw new Error(&quot;Inconsistent bindings for &quot; + name) }
   }
   delete keymap[keyname]
 } }
 for (var prop in copy) { keymap[prop] = copy[prop] }
 return keymap
</PRE><P>}
</P><P>function lookupKey(key, map, handle, context) {
</P><PRE> map = getKeyMap(map)
 var found = map.call ? map.call(key, context) : map[key]
 if (found === false) { return &quot;nothing&quot; }
 if (found === &quot;...&quot;) { return &quot;multi&quot; }
 if (found != null &amp;&amp; handle(found)) { return &quot;handled&quot; }
</PRE><PRE> if (map.fallthrough) {
   if (Object.prototype.toString.call(map.fallthrough) != &quot;[object Array]&quot;)
     { return lookupKey(key, map.fallthrough, handle, context) }
   for (var i = 0; i &lt; map.fallthrough.length; i++) {
     var result = lookupKey(key, map.fallthrough[i], handle, context)
     if (result) { return result }
   }
 }
</PRE><P>}
</P><P>// Modifier key presses don't count as 'real' key presses for the
// purpose of keymap fallthrough.
function isModifierKey(value) {
</P><PRE> var name = typeof value == &quot;string&quot; ? value : keyNames[value.keyCode]
 return name == &quot;Ctrl&quot; || name == &quot;Alt&quot; || name == &quot;Shift&quot; || name == &quot;Mod&quot;
</PRE><P>}
</P><P>// Look up the name of a key as indicated by an event object.
function keyName(event, noShift) {
</P><PRE> if (presto &amp;&amp; event.keyCode == 34 &amp;&amp; event[&quot;char&quot;]) { return false }
 var base = keyNames[event.keyCode], name = base
 if (name == null || event.altGraphKey) { return false }
 if (event.altKey &amp;&amp; base != &quot;Alt&quot;) { name = &quot;Alt-&quot; + name }
 if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) &amp;&amp; base != &quot;Ctrl&quot;) { name = &quot;Ctrl-&quot; + name }
 if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) &amp;&amp; base != &quot;Cmd&quot;) { name = &quot;Cmd-&quot; + name }
 if (!noShift &amp;&amp; event.shiftKey &amp;&amp; base != &quot;Shift&quot;) { name = &quot;Shift-&quot; + name }
 return name
</PRE><P>}
</P><P>function getKeyMap(val) {
</P><PRE> return typeof val == &quot;string&quot; ? keyMap[val] : val
</PRE><P>}
</P><P>// Helper for deleting text near the selection(s), used to implement
// backspace, delete, and similar functionality.
function deleteNearSelection(cm, compute) {
</P><PRE> var ranges = cm.doc.sel.ranges, kill = []
 // Build up a set of ranges to kill first, merging overlapping
 // ranges.
 for (var i = 0; i &lt; ranges.length; i++) {
   var toKill = compute(ranges[i])
   while (kill.length &amp;&amp; cmp(toKill.from, lst(kill).to) &lt;= 0) {
     var replaced = kill.pop()
     if (cmp(replaced.from, toKill.from) &lt; 0) {
       toKill.from = replaced.from
       break
     }
   }
   kill.push(toKill)
 }
 // Next, remove those actual ranges.
 runInOp(cm, function () {
   for (var i = kill.length - 1; i &gt;= 0; i--)
     { replaceRange(cm.doc, &quot;&quot;, kill[i].from, kill[i].to, &quot;+delete&quot;) }
   ensureCursorVisible(cm)
 })
</PRE><P>}
</P><P>// Commands are parameter-less actions that can be performed on an
// editor, mostly used for keybindings.
var commands = {
</P><PRE> selectAll: selectAll,
 singleSelection: function (cm) { return cm.setSelection(cm.getCursor(&quot;anchor&quot;), cm.getCursor(&quot;head&quot;), sel_dontScroll); },
 killLine: function (cm) { return deleteNearSelection(cm, function (range) {
   if (range.empty()) {
     var len = getLine(cm.doc, range.head.line).text.length
     if (range.head.ch == len &amp;&amp; range.head.line &lt; cm.lastLine())
       { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
     else
       { return {from: range.head, to: Pos(range.head.line, len)} }
   } else {
     return {from: range.from(), to: range.to()}
   }
 }); },
 deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
   from: Pos(range.from().line, 0),
   to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
 }); }); },
 delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
   from: Pos(range.from().line, 0), to: range.from()
 }); }); },
 delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
   var top = cm.charCoords(range.head, &quot;div&quot;).top + 5
   var leftPos = cm.coordsChar({left: 0, top: top}, &quot;div&quot;)
   return {from: leftPos, to: range.from()}
 }); },
 delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
   var top = cm.charCoords(range.head, &quot;div&quot;).top + 5
   var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, &quot;div&quot;)
   return {from: range.from(), to: rightPos }
 }); },
 undo: function (cm) { return cm.undo(); },
 redo: function (cm) { return cm.redo(); },
 undoSelection: function (cm) { return cm.undoSelection(); },
 redoSelection: function (cm) { return cm.redoSelection(); },
 goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
 goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
 goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
   {origin: &quot;+move&quot;, bias: 1}
 ); },
 goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
   {origin: &quot;+move&quot;, bias: 1}
 ); },
 goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
   {origin: &quot;+move&quot;, bias: -1}
 ); },
 goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
   var top = cm.charCoords(range.head, &quot;div&quot;).top + 5
   return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, &quot;div&quot;)
 }, sel_move); },
 goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
   var top = cm.charCoords(range.head, &quot;div&quot;).top + 5
   return cm.coordsChar({left: 0, top: top}, &quot;div&quot;)
 }, sel_move); },
 goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
   var top = cm.charCoords(range.head, &quot;div&quot;).top + 5
   var pos = cm.coordsChar({left: 0, top: top}, &quot;div&quot;)
   if (pos.ch &lt; cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
   return pos
 }, sel_move); },
 goLineUp: function (cm) { return cm.moveV(-1, &quot;line&quot;); },
 goLineDown: function (cm) { return cm.moveV(1, &quot;line&quot;); },
 goPageUp: function (cm) { return cm.moveV(-1, &quot;page&quot;); },
 goPageDown: function (cm) { return cm.moveV(1, &quot;page&quot;); },
 goCharLeft: function (cm) { return cm.moveH(-1, &quot;char&quot;); },
 goCharRight: function (cm) { return cm.moveH(1, &quot;char&quot;); },
 goColumnLeft: function (cm) { return cm.moveH(-1, &quot;column&quot;); },
 goColumnRight: function (cm) { return cm.moveH(1, &quot;column&quot;); },
 goWordLeft: function (cm) { return cm.moveH(-1, &quot;word&quot;); },
 goGroupRight: function (cm) { return cm.moveH(1, &quot;group&quot;); },
 goGroupLeft: function (cm) { return cm.moveH(-1, &quot;group&quot;); },
 goWordRight: function (cm) { return cm.moveH(1, &quot;word&quot;); },
 delCharBefore: function (cm) { return cm.deleteH(-1, &quot;char&quot;); },
 delCharAfter: function (cm) { return cm.deleteH(1, &quot;char&quot;); },
 delWordBefore: function (cm) { return cm.deleteH(-1, &quot;word&quot;); },
 delWordAfter: function (cm) { return cm.deleteH(1, &quot;word&quot;); },
 delGroupBefore: function (cm) { return cm.deleteH(-1, &quot;group&quot;); },
 delGroupAfter: function (cm) { return cm.deleteH(1, &quot;group&quot;); },
 indentAuto: function (cm) { return cm.indentSelection(&quot;smart&quot;); },
 indentMore: function (cm) { return cm.indentSelection(&quot;add&quot;); },
 indentLess: function (cm) { return cm.indentSelection(&quot;subtract&quot;); },
 insertTab: function (cm) { return cm.replaceSelection(&quot;\t&quot;); },
 insertSoftTab: function (cm) {
   var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize
   for (var i = 0; i &lt; ranges.length; i++) {
     var pos = ranges[i].from()
     var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize)
     spaces.push(spaceStr(tabSize - col % tabSize))
   }
   cm.replaceSelections(spaces)
 },
 defaultTab: function (cm) {
   if (cm.somethingSelected()) { cm.indentSelection(&quot;add&quot;) }
   else { cm.execCommand(&quot;insertTab&quot;) }
 },
 // Swap the two chars left and right of each selection's head.
 // Move cursor behind the two swapped characters afterwards.
 //
 // Doesn't consider line feeds a character.
 // Doesn't scan more than one line above to find a character.
 // Doesn't do anything on an empty line.
 // Doesn't do anything with non-empty selections.
 transposeChars: function (cm) { return runInOp(cm, function () {
   var ranges = cm.listSelections(), newSel = []
   for (var i = 0; i &lt; ranges.length; i++) {
     if (!ranges[i].empty()) { continue }
     var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text
     if (line) {
       if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1) }
       if (cur.ch &gt; 0) {
         cur = new Pos(cur.line, cur.ch + 1)
         cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                         Pos(cur.line, cur.ch - 2), cur, &quot;+transpose&quot;)
       } else if (cur.line &gt; cm.doc.first) {
         var prev = getLine(cm.doc, cur.line - 1).text
         if (prev) {
           cur = new Pos(cur.line, 1)
           cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                           prev.charAt(prev.length - 1),
                           Pos(cur.line - 1, prev.length - 1), cur, &quot;+transpose&quot;)
         }
       }
     }
     newSel.push(new Range(cur, cur))
   }
   cm.setSelections(newSel)
 }); },
 newlineAndIndent: function (cm) { return runInOp(cm, function () {
   var sels = cm.listSelections()
   for (var i = sels.length - 1; i &gt;= 0; i--)
     { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, &quot;+input&quot;) }
   sels = cm.listSelections()
   for (var i$1 = 0; i$1 &lt; sels.length; i$1++)
     { cm.indentLine(sels[i$1].from().line, null, true) }
   ensureCursorVisible(cm)
 }); },
 openLine: function (cm) { return cm.replaceSelection(&quot;\n&quot;, &quot;start&quot;); },
 toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
</PRE><P>}
</P><P>
function lineStart(cm, lineN) {
</P><PRE> var line = getLine(cm.doc, lineN)
 var visual = visualLine(line)
 if (visual != line) { lineN = lineNo(visual) }
 return endOfLine(true, cm, visual, lineN, 1)
</PRE><P>}
function lineEnd(cm, lineN) {
</P><PRE> var line = getLine(cm.doc, lineN)
 var visual = visualLineEnd(line)
 if (visual != line) { lineN = lineNo(visual) }
 return endOfLine(true, cm, line, lineN, -1)
</PRE><P>}
function lineStartSmart(cm, pos) {
</P><PRE> var start = lineStart(cm, pos.line)
 var line = getLine(cm.doc, start.line)
 var order = getOrder(line)
 if (!order || order[0].level == 0) {
   var firstNonWS = Math.max(0, line.text.search(/\S/))
   var inWS = pos.line == start.line &amp;&amp; pos.ch &lt;= firstNonWS &amp;&amp; pos.ch
   return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
 }
 return start
</PRE><P>}
</P><P>// Run a handler that was bound to a key.
function doHandleBinding(cm, bound, dropShift) {
</P><PRE> if (typeof bound == &quot;string&quot;) {
   bound = commands[bound]
   if (!bound) { return false }
 }
 // Ensure previous input has been read, so that the handler sees a
 // consistent view of the document
 cm.display.input.ensurePolled()
 var prevShift = cm.display.shift, done = false
 try {
   if (cm.isReadOnly()) { cm.state.suppressEdits = true }
   if (dropShift) { cm.display.shift = false }
   done = bound(cm) != Pass
 } finally {
   cm.display.shift = prevShift
   cm.state.suppressEdits = false
 }
 return done
</PRE><P>}
</P><P>function lookupKeyForEditor(cm, name, handle) {
</P><PRE> for (var i = 0; i &lt; cm.state.keyMaps.length; i++) {
   var result = lookupKey(name, cm.state.keyMaps[i], handle, cm)
   if (result) { return result }
 }
 return (cm.options.extraKeys &amp;&amp; lookupKey(name, cm.options.extraKeys, handle, cm))
   || lookupKey(name, cm.options.keyMap, handle, cm)
</PRE><P>}
</P><P>var stopSeq = new Delayed
function dispatchKey(cm, name, e, handle) {
</P><PRE> var seq = cm.state.keySeq
 if (seq) {
   if (isModifierKey(name)) { return &quot;handled&quot; }
   stopSeq.set(50, function () {
     if (cm.state.keySeq == seq) {
       cm.state.keySeq = null
       cm.display.input.reset()
     }
   })
   name = seq + &quot; &quot; + name
 }
 var result = lookupKeyForEditor(cm, name, handle)
</PRE><PRE> if (result == &quot;multi&quot;)
   { cm.state.keySeq = name }
 if (result == &quot;handled&quot;)
   { signalLater(cm, &quot;keyHandled&quot;, cm, name, e) }
</PRE><PRE> if (result == &quot;handled&quot; || result == &quot;multi&quot;) {
   e_preventDefault(e)
   restartBlink(cm)
 }
</PRE><PRE> if (seq &amp;&amp; !result &amp;&amp; /\'$/.test(name)) {
   e_preventDefault(e)
   return true
 }
 return !!result
</PRE><P>}
</P><P>// Handle a key from the keydown event.
function handleKeyBinding(cm, e) {
</P><PRE> var name = keyName(e, true)
 if (!name) { return false }
</PRE><PRE> if (e.shiftKey &amp;&amp; !cm.state.keySeq) {
   // First try to resolve full name (including 'Shift-'). Failing
   // that, see if there is a cursor-motion command (starting with
   // 'go') bound to the keyname without 'Shift-'.
   return dispatchKey(cm, &quot;Shift-&quot; + name, e, function (b) { return doHandleBinding(cm, b, true); })
       || dispatchKey(cm, name, e, function (b) {
            if (typeof b == &quot;string&quot; ? /^go[A-Z]/.test(b) : b.motion)
              { return doHandleBinding(cm, b) }
          })
 } else {
   return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
 }
</PRE><P>}
</P><P>// Handle a key from the keypress event
function handleCharBinding(cm, e, ch) {
</P><PRE> return dispatchKey(cm, &quot;'&quot; + ch + &quot;'&quot;, e, function (b) { return doHandleBinding(cm, b, true); })
</PRE><P>}
</P><P>var lastStoppedKey = null
function onKeyDown(e) {
</P><PRE> var cm = this
 cm.curOp.focus = activeElt()
 if (signalDOMEvent(cm, e)) { return }
 // IE does strange things with escape.
 if (ie &amp;&amp; ie_version &lt; 11 &amp;&amp; e.keyCode == 27) { e.returnValue = false }
 var code = e.keyCode
 cm.display.shift = code == 16 || e.shiftKey
 var handled = handleKeyBinding(cm, e)
 if (presto) {
   lastStoppedKey = handled ? code : null
   // Opera has no cut event... we try to at least catch the key combo
   if (!handled &amp;&amp; code == 88 &amp;&amp; !hasCopyEvent &amp;&amp; (mac ? e.metaKey : e.ctrlKey))
     { cm.replaceSelection(&quot;&quot;, null, &quot;cut&quot;) }
 }
</PRE><PRE> // Turn mouse into crosshair when Alt is held on Mac.
 if (code == 18 &amp;&amp; !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
   { showCrossHair(cm) }
</PRE><P>}
</P><P>function showCrossHair(cm) {
</P><PRE> var lineDiv = cm.display.lineDiv
 addClass(lineDiv, &quot;CodeMirror-crosshair&quot;)
</PRE><PRE> function up(e) {
   if (e.keyCode == 18 || !e.altKey) {
     rmClass(lineDiv, &quot;CodeMirror-crosshair&quot;)
     off(document, &quot;keyup&quot;, up)
     off(document, &quot;mouseover&quot;, up)
   }
 }
 on(document, &quot;keyup&quot;, up)
 on(document, &quot;mouseover&quot;, up)
</PRE><P>}
</P><P>function onKeyUp(e) {
</P><PRE> if (e.keyCode == 16) { this.doc.sel.shift = false }
 signalDOMEvent(this, e)
</PRE><P>}
</P><P>function onKeyPress(e) {
</P><PRE> var cm = this
 if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey &amp;&amp; !e.altKey || mac &amp;&amp; e.metaKey) { return }
 var keyCode = e.keyCode, charCode = e.charCode
 if (presto &amp;&amp; keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
 if ((presto &amp;&amp; (!e.which || e.which &lt; 10)) &amp;&amp; handleKeyBinding(cm, e)) { return }
 var ch = String.fromCharCode(charCode == null ? keyCode : charCode)
 // Some browsers fire keypress events for backspace
 if (ch == &quot;\x08&quot;) { return }
 if (handleCharBinding(cm, e, ch)) { return }
 cm.display.input.onKeyPress(e)
</PRE><P>}
</P><P>// A mouse down can be a single click, double click, triple click,
// start of selection drag, start of text drag, new cursor
// (ctrl-click), rectangle drag (alt-drag), or xwin
// middle-click-paste. Or it might be a click on something we should
// not interfere with, such as a scrollbar or widget.
function onMouseDown(e) {
</P><PRE> var cm = this, display = cm.display
 if (signalDOMEvent(cm, e) || display.activeTouch &amp;&amp; display.input.supportsTouch()) { return }
 display.input.ensurePolled()
 display.shift = e.shiftKey
</PRE><PRE> if (eventInWidget(display, e)) {
   if (!webkit) {
     // Briefly turn off draggability, to allow widgets to do
     // normal dragging things.
     display.scroller.draggable = false
     setTimeout(function () { return display.scroller.draggable = true; }, 100)
   }
   return
 }
 if (clickInGutter(cm, e)) { return }
 var start = posFromMouse(cm, e)
 window.focus()
</PRE><PRE> switch (e_button(e)) {
 case 1:
   // #3261: make sure, that we're not starting a second selection
   if (cm.state.selectingText)
     { cm.state.selectingText(e) }
   else if (start)
     { leftButtonDown(cm, e, start) }
   else if (e_target(e) == display.scroller)
     { e_preventDefault(e) }
   break
 case 2:
   if (webkit) { cm.state.lastMiddleDown = +new Date }
   if (start) { extendSelection(cm.doc, start) }
   setTimeout(function () { return display.input.focus(); }, 20)
   e_preventDefault(e)
   break
 case 3:
   if (captureRightClick) { onContextMenu(cm, e) }
   else { delayBlurEvent(cm) }
   break
 }
</PRE><P>}
</P><P>var lastClick;
var lastDoubleClick;
function leftButtonDown(cm, e, start) {
</P><PRE> if (ie) { setTimeout(bind(ensureFocus, cm), 0) }
 else { cm.curOp.focus = activeElt() }
</PRE><PRE> var now = +new Date, type
 if (lastDoubleClick &amp;&amp; lastDoubleClick.time &gt; now - 400 &amp;&amp; cmp(lastDoubleClick.pos, start) == 0) {
   type = &quot;triple&quot;
 } else if (lastClick &amp;&amp; lastClick.time &gt; now - 400 &amp;&amp; cmp(lastClick.pos, start) == 0) {
   type = &quot;double&quot;
   lastDoubleClick = {time: now, pos: start}
 } else {
   type = &quot;single&quot;
   lastClick = {time: now, pos: start}
 }
</PRE><PRE> var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained
 if (cm.options.dragDrop &amp;&amp; dragAndDrop &amp;&amp; !cm.isReadOnly() &amp;&amp;
     type == &quot;single&quot; &amp;&amp; (contained = sel.contains(start)) &gt; -1 &amp;&amp;
     (cmp((contained = sel.ranges[contained]).from(), start) &lt; 0 || start.xRel &gt; 0) &amp;&amp;
     (cmp(contained.to(), start) &gt; 0 || start.xRel &lt; 0))
   { leftButtonStartDrag(cm, e, start, modifier) }
 else
   { leftButtonSelect(cm, e, start, type, modifier) }
</PRE><P>}
</P><P>// Start a text drag. When it ends, see if any dragging actually
// happen, and treat as a click if it didn't.
function leftButtonStartDrag(cm, e, start, modifier) {
</P><PRE> var display = cm.display, startTime = +new Date
 var dragEnd = operation(cm, function (e2) {
   if (webkit) { display.scroller.draggable = false }
   cm.state.draggingText = false
   off(document, &quot;mouseup&quot;, dragEnd)
   off(display.scroller, &quot;drop&quot;, dragEnd)
   if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) &lt; 10) {
     e_preventDefault(e2)
     if (!modifier &amp;&amp; +new Date - 200 &lt; startTime)
       { extendSelection(cm.doc, start) }
     // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
     if (webkit || ie &amp;&amp; ie_version == 9)
       { setTimeout(function () {document.body.focus(); display.input.focus()}, 20) }
     else
       { display.input.focus() }
   }
 })
 // Let the drag handler handle this.
 if (webkit) { display.scroller.draggable = true }
 cm.state.draggingText = dragEnd
 dragEnd.copy = mac ? e.altKey : e.ctrlKey
 // IE's approach to draggable
 if (display.scroller.dragDrop) { display.scroller.dragDrop() }
 on(document, &quot;mouseup&quot;, dragEnd)
 on(display.scroller, &quot;drop&quot;, dragEnd)
</PRE><P>}
</P><P>// Normal selection, as opposed to text dragging.
function leftButtonSelect(cm, e, start, type, addNew) {
</P><PRE> var display = cm.display, doc = cm.doc
 e_preventDefault(e)
</PRE><PRE> var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges
 if (addNew &amp;&amp; !e.shiftKey) {
   ourIndex = doc.sel.contains(start)
   if (ourIndex &gt; -1)
     { ourRange = ranges[ourIndex] }
   else
     { ourRange = new Range(start, start) }
 } else {
   ourRange = doc.sel.primary()
   ourIndex = doc.sel.primIndex
 }
</PRE><PRE> if (chromeOS ? e.shiftKey &amp;&amp; e.metaKey : e.altKey) {
   type = &quot;rect&quot;
   if (!addNew) { ourRange = new Range(start, start) }
   start = posFromMouse(cm, e, true, true)
   ourIndex = -1
 } else if (type == &quot;double&quot;) {
   var word = cm.findWordAt(start)
   if (cm.display.shift || doc.extend)
     { ourRange = extendRange(doc, ourRange, word.anchor, word.head) }
   else
     { ourRange = word }
 } else if (type == &quot;triple&quot;) {
   var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)))
   if (cm.display.shift || doc.extend)
     { ourRange = extendRange(doc, ourRange, line.anchor, line.head) }
   else
     { ourRange = line }
 } else {
   ourRange = extendRange(doc, ourRange, start)
 }
</PRE><PRE> if (!addNew) {
   ourIndex = 0
   setSelection(doc, new Selection([ourRange], 0), sel_mouse)
   startSel = doc.sel
 } else if (ourIndex == -1) {
   ourIndex = ranges.length
   setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                {scroll: false, origin: &quot;*mouse&quot;})
 } else if (ranges.length &gt; 1 &amp;&amp; ranges[ourIndex].empty() &amp;&amp; type == &quot;single&quot; &amp;&amp; !e.shiftKey) {
   setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                {scroll: false, origin: &quot;*mouse&quot;})
   startSel = doc.sel
 } else {
   replaceOneSelection(doc, ourIndex, ourRange, sel_mouse)
 }
</PRE><PRE> var lastPos = start
 function extendTo(pos) {
   if (cmp(lastPos, pos) == 0) { return }
   lastPos = pos
</PRE><PRE>   if (type == &quot;rect&quot;) {
     var ranges = [], tabSize = cm.options.tabSize
     var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize)
     var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize)
     var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol)
     for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
          line &lt;= end; line++) {
       var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize)
       if (left == right)
         { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) }
       else if (text.length &gt; leftPos)
         { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))) }
     }
     if (!ranges.length) { ranges.push(new Range(start, start)) }
     setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                  {origin: &quot;*mouse&quot;, scroll: false})
     cm.scrollIntoView(pos)
   } else {
     var oldRange = ourRange
     var anchor = oldRange.anchor, head = pos
     if (type != &quot;single&quot;) {
       var range
       if (type == &quot;double&quot;)
         { range = cm.findWordAt(pos) }
       else
         { range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))) }
       if (cmp(range.anchor, anchor) &gt; 0) {
         head = range.head
         anchor = minPos(oldRange.from(), range.anchor)
       } else {
         head = range.anchor
         anchor = maxPos(oldRange.to(), range.head)
       }
     }
     var ranges$1 = startSel.ranges.slice(0)
     ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head)
     setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)
   }
 }
</PRE><PRE> var editorSize = display.wrapper.getBoundingClientRect()
 // Used to ensure timeout re-tries don't fire when another extend
 // happened in the meantime (clearTimeout isn't reliable -- at
 // least on Chrome, the timeouts still happen even when cleared,
 // if the clear happens after their scheduled firing time).
 var counter = 0
</PRE><PRE> function extend(e) {
   var curCount = ++counter
   var cur = posFromMouse(cm, e, true, type == &quot;rect&quot;)
   if (!cur) { return }
   if (cmp(cur, lastPos) != 0) {
     cm.curOp.focus = activeElt()
     extendTo(cur)
     var visible = visibleLines(display, doc)
     if (cur.line &gt;= visible.to || cur.line &lt; visible.from)
       { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e) }}), 150) }
   } else {
     var outside = e.clientY &lt; editorSize.top ? -20 : e.clientY &gt; editorSize.bottom ? 20 : 0
     if (outside) { setTimeout(operation(cm, function () {
       if (counter != curCount) { return }
       display.scroller.scrollTop += outside
       extend(e)
     }), 50) }
   }
 }
</PRE><PRE> function done(e) {
   cm.state.selectingText = false
   counter = Infinity
   e_preventDefault(e)
   display.input.focus()
   off(document, &quot;mousemove&quot;, move)
   off(document, &quot;mouseup&quot;, up)
   doc.history.lastSelOrigin = null
 }
</PRE><PRE> var move = operation(cm, function (e) {
   if (!e_button(e)) { done(e) }
   else { extend(e) }
 })
 var up = operation(cm, done)
 cm.state.selectingText = up
 on(document, &quot;mousemove&quot;, move)
 on(document, &quot;mouseup&quot;, up)
</PRE><P>}
</P><P>
// Determines whether an event happened in the gutter, and fires the
// handlers for the corresponding event.
function gutterEvent(cm, e, type, prevent) {
</P><PRE> var mX, mY
 try { mX = e.clientX; mY = e.clientY }
 catch(e) { return false }
 if (mX &gt;= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
 if (prevent) { e_preventDefault(e) }
</PRE><PRE> var display = cm.display
 var lineBox = display.lineDiv.getBoundingClientRect()
</PRE><PRE> if (mY &gt; lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
 mY -= lineBox.top - display.viewOffset
</PRE><PRE> for (var i = 0; i &lt; cm.options.gutters.length; ++i) {
   var g = display.gutters.childNodes[i]
   if (g &amp;&amp; g.getBoundingClientRect().right &gt;= mX) {
     var line = lineAtHeight(cm.doc, mY)
     var gutter = cm.options.gutters[i]
     signal(cm, type, cm, line, gutter, e)
     return e_defaultPrevented(e)
   }
 }
</PRE><P>}
</P><P>function clickInGutter(cm, e) {
</P><PRE> return gutterEvent(cm, e, &quot;gutterClick&quot;, true)
</PRE><P>}
</P><P>// CONTEXT MENU HANDLING
</P><P>// To make the context menu work, we need to briefly unhide the
// textarea (making it as unobtrusive as possible) to let the
// right-click take effect on it.
function onContextMenu(cm, e) {
</P><PRE> if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
 if (signalDOMEvent(cm, e, &quot;contextmenu&quot;)) { return }
 cm.display.input.onContextMenu(e)
</PRE><P>}
</P><P>function contextMenuInGutter(cm, e) {
</P><PRE> if (!hasHandler(cm, &quot;gutterContextMenu&quot;)) { return false }
 return gutterEvent(cm, e, &quot;gutterContextMenu&quot;, false)
</PRE><P>}
</P><P>function themeChanged(cm) {
</P><PRE> cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, &quot;&quot;) +
   cm.options.theme.replace(/(^|\s)\s*/g, &quot; cm-s-&quot;)
 clearCaches(cm)
</PRE><P>}
</P><P>var Init = {toString: function(){return &quot;CodeMirror.Init&quot;}}
</P><P>var defaults = {}
var optionHandlers = {}
</P><P>function defineOptions(CodeMirror) {
</P><PRE> var optionHandlers = CodeMirror.optionHandlers
</PRE><PRE> function option(name, deflt, handle, notOnInit) {
   CodeMirror.defaults[name] = deflt
   if (handle) { optionHandlers[name] =
     notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old) }} : handle }
 }
</PRE><PRE> CodeMirror.defineOption = option
</PRE><PRE> // Passed to option handlers when there is no old value.
 CodeMirror.Init = Init
</PRE><PRE> // These two are, on init, called from the constructor because they
 // have to be initialized before the editor can start at all.
 option(&quot;value&quot;, &quot;&quot;, function (cm, val) { return cm.setValue(val); }, true)
 option(&quot;mode&quot;, null, function (cm, val) {
   cm.doc.modeOption = val
   loadMode(cm)
 }, true)
</PRE><PRE> option(&quot;indentUnit&quot;, 2, loadMode, true)
 option(&quot;indentWithTabs&quot;, false)
 option(&quot;smartIndent&quot;, true)
 option(&quot;tabSize&quot;, 4, function (cm) {
   resetModeState(cm)
   clearCaches(cm)
   regChange(cm)
 }, true)
 option(&quot;lineSeparator&quot;, null, function (cm, val) {
   cm.doc.lineSep = val
   if (!val) { return }
   var newBreaks = [], lineNo = cm.doc.first
   cm.doc.iter(function (line) {
     for (var pos = 0;;) {
       var found = line.text.indexOf(val, pos)
       if (found == -1) { break }
       pos = found + val.length
       newBreaks.push(Pos(lineNo, found))
     }
     lineNo++
   })
   for (var i = newBreaks.length - 1; i &gt;= 0; i--)
     { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)) }
 })
 option(&quot;specialChars&quot;, /[\u0000-\u001f\u007f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
   cm.state.specialChars = new RegExp(val.source + (val.test(&quot;\t&quot;) ? &quot;&quot; : &quot;|\t&quot;), &quot;g&quot;)
   if (old != Init) { cm.refresh() }
 })
 option(&quot;specialCharPlaceholder&quot;, defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true)
 option(&quot;electricChars&quot;, true)
 option(&quot;inputStyle&quot;, mobile ? &quot;contenteditable&quot; : &quot;textarea&quot;, function () {
   throw new Error(&quot;inputStyle can not (yet) be changed in a running editor&quot;) // FIXME
 }, true)
 option(&quot;spellcheck&quot;, false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true)
 option(&quot;rtlMoveVisually&quot;, !windows)
 option(&quot;wholeLineUpdateBefore&quot;, true)
</PRE><PRE> option(&quot;theme&quot;, &quot;default&quot;, function (cm) {
   themeChanged(cm)
   guttersChanged(cm)
 }, true)
 option(&quot;keyMap&quot;, &quot;default&quot;, function (cm, val, old) {
   var next = getKeyMap(val)
   var prev = old != Init &amp;&amp; getKeyMap(old)
   if (prev &amp;&amp; prev.detach) { prev.detach(cm, next) }
   if (next.attach) { next.attach(cm, prev || null) }
 })
 option(&quot;extraKeys&quot;, null)
</PRE><PRE> option(&quot;lineWrapping&quot;, false, wrappingChanged, true)
 option(&quot;gutters&quot;, [], function (cm) {
   setGuttersForLineNumbers(cm.options)
   guttersChanged(cm)
 }, true)
 option(&quot;fixedGutter&quot;, true, function (cm, val) {
   cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + &quot;px&quot; : &quot;0&quot;
   cm.refresh()
 }, true)
 option(&quot;coverGutterNextToScrollbar&quot;, false, function (cm) { return updateScrollbars(cm); }, true)
 option(&quot;scrollbarStyle&quot;, &quot;native&quot;, function (cm) {
   initScrollbars(cm)
   updateScrollbars(cm)
   cm.display.scrollbars.setScrollTop(cm.doc.scrollTop)
   cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)
 }, true)
 option(&quot;lineNumbers&quot;, false, function (cm) {
   setGuttersForLineNumbers(cm.options)
   guttersChanged(cm)
 }, true)
 option(&quot;firstLineNumber&quot;, 1, guttersChanged, true)
 option(&quot;lineNumberFormatter&quot;, function (integer) { return integer; }, guttersChanged, true)
 option(&quot;showCursorWhenSelecting&quot;, false, updateSelection, true)
</PRE><PRE> option(&quot;resetSelectionOnContextMenu&quot;, true)
 option(&quot;lineWiseCopyCut&quot;, true)
</PRE><PRE> option(&quot;readOnly&quot;, false, function (cm, val) {
   if (val == &quot;nocursor&quot;) {
     onBlur(cm)
     cm.display.input.blur()
     cm.display.disabled = true
   } else {
     cm.display.disabled = false
   }
   cm.display.input.readOnlyChanged(val)
 })
 option(&quot;disableInput&quot;, false, function (cm, val) {if (!val) { cm.display.input.reset() }}, true)
 option(&quot;dragDrop&quot;, true, dragDropChanged)
 option(&quot;allowDropFileTypes&quot;, null)
</PRE><PRE> option(&quot;cursorBlinkRate&quot;, 530)
 option(&quot;cursorScrollMargin&quot;, 0)
 option(&quot;cursorHeight&quot;, 1, updateSelection, true)
 option(&quot;singleCursorHeightPerLine&quot;, true, updateSelection, true)
 option(&quot;workTime&quot;, 100)
 option(&quot;workDelay&quot;, 100)
 option(&quot;flattenSpans&quot;, true, resetModeState, true)
 option(&quot;addModeClass&quot;, false, resetModeState, true)
 option(&quot;pollInterval&quot;, 100)
 option(&quot;undoDepth&quot;, 200, function (cm, val) { return cm.doc.history.undoDepth = val; })
 option(&quot;historyEventDelay&quot;, 1250)
 option(&quot;viewportMargin&quot;, 10, function (cm) { return cm.refresh(); }, true)
 option(&quot;maxHighlightLength&quot;, 10000, resetModeState, true)
 option(&quot;moveInputWithCursor&quot;, true, function (cm, val) {
   if (!val) { cm.display.input.resetPosition() }
 })
</PRE><PRE> option(&quot;tabindex&quot;, null, function (cm, val) { return cm.display.input.getField().tabIndex = val || &quot;&quot;; })
 option(&quot;autofocus&quot;, null)
</PRE><P>}
</P><P>function guttersChanged(cm) {
</P><PRE> updateGutters(cm)
 regChange(cm)
 alignHorizontally(cm)
</PRE><P>}
</P><P>function dragDropChanged(cm, value, old) {
</P><PRE> var wasOn = old &amp;&amp; old != Init
 if (!value != !wasOn) {
   var funcs = cm.display.dragFunctions
   var toggle = value ? on : off
   toggle(cm.display.scroller, &quot;dragstart&quot;, funcs.start)
   toggle(cm.display.scroller, &quot;dragenter&quot;, funcs.enter)
   toggle(cm.display.scroller, &quot;dragover&quot;, funcs.over)
   toggle(cm.display.scroller, &quot;dragleave&quot;, funcs.leave)
   toggle(cm.display.scroller, &quot;drop&quot;, funcs.drop)
 }
</PRE><P>}
</P><P>function wrappingChanged(cm) {
</P><PRE> if (cm.options.lineWrapping) {
   addClass(cm.display.wrapper, &quot;CodeMirror-wrap&quot;)
   cm.display.sizer.style.minWidth = &quot;&quot;
   cm.display.sizerWidth = null
 } else {
   rmClass(cm.display.wrapper, &quot;CodeMirror-wrap&quot;)
   findMaxLine(cm)
 }
 estimateLineHeights(cm)
 regChange(cm)
 clearCaches(cm)
 setTimeout(function () { return updateScrollbars(cm); }, 100)
</PRE><P>}
</P><P>// A CodeMirror instance represents an editor. This is the object
// that user code is usually dealing with.
</P><P>function CodeMirror(place, options) {
</P><PRE> var this$1 = this;
</PRE><PRE> if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }
</PRE><PRE> this.options = options = options ? copyObj(options) : {}
 // Determine effective options based on given values and defaults.
 copyObj(defaults, options, false)
 setGuttersForLineNumbers(options)
</PRE><PRE> var doc = options.value
 if (typeof doc == &quot;string&quot;) { doc = new Doc(doc, options.mode, null, options.lineSeparator) }
 this.doc = doc
</PRE><PRE> var input = new CodeMirror.inputStyles[options.inputStyle](this)
 var display = this.display = new Display(place, doc, input)
 display.wrapper.CodeMirror = this
 updateGutters(this)
 themeChanged(this)
 if (options.lineWrapping)
   { this.display.wrapper.className += &quot; CodeMirror-wrap&quot; }
 initScrollbars(this)
</PRE><PRE> this.state = {
   keyMaps: [],  // stores maps added by addKeyMap
   overlays: [], // highlighting overlays, as added by addOverlay
   modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
   overwrite: false,
   delayingBlurEvent: false,
   focused: false,
   suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
   pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
   selectingText: false,
   draggingText: false,
   highlight: new Delayed(), // stores highlight worker timeout
   keySeq: null,  // Unfinished key sequence
   specialChars: null
 }
</PRE><PRE> if (options.autofocus &amp;&amp; !mobile) { display.input.focus() }
</PRE><PRE> // Override magic textarea content restore that IE sometimes does
 // on our hidden textarea on reload
 if (ie &amp;&amp; ie_version &lt; 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20) }
</PRE><PRE> registerEventHandlers(this)
 ensureGlobalHandlers()
</PRE><PRE> startOperation(this)
 this.curOp.forceUpdate = true
 attachDoc(this, doc)
</PRE><PRE> if ((options.autofocus &amp;&amp; !mobile) || this.hasFocus())
   { setTimeout(bind(onFocus, this), 20) }
 else
   { onBlur(this) }
</PRE><PRE> for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
   { optionHandlers[opt](this$1, options[opt], Init) } }
 maybeUpdateLineNumberWidth(this)
 if (options.finishInit) { options.finishInit(this) }
 for (var i = 0; i &lt; initHooks.length; ++i) { initHooks[i](this$1) }
 endOperation(this)
 // Suppress optimizelegibility in Webkit, since it breaks text
 // measuring on line wrapping boundaries.
 if (webkit &amp;&amp; options.lineWrapping &amp;&amp;
     getComputedStyle(display.lineDiv).textRendering == &quot;optimizelegibility&quot;)
   { display.lineDiv.style.textRendering = &quot;auto&quot; }
</PRE><P>}
</P><P>// The default configuration options.
CodeMirror.defaults = defaults
// Functions to run when options are changed.
CodeMirror.optionHandlers = optionHandlers
</P><P>// Attach the necessary event handlers when initializing the editor
function registerEventHandlers(cm) {
</P><PRE> var d = cm.display
 on(d.scroller, &quot;mousedown&quot;, operation(cm, onMouseDown))
 // Older IE's will not fire a second mousedown for a double click
 if (ie &amp;&amp; ie_version &lt; 11)
   { on(d.scroller, &quot;dblclick&quot;, operation(cm, function (e) {
     if (signalDOMEvent(cm, e)) { return }
     var pos = posFromMouse(cm, e)
     if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
     e_preventDefault(e)
     var word = cm.findWordAt(pos)
     extendSelection(cm.doc, word.anchor, word.head)
   })) }
 else
   { on(d.scroller, &quot;dblclick&quot;, function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }) }
 // Some browsers fire contextmenu *after* opening the menu, at
 // which point we can't mess with it anymore. Context menu is
 // handled in onMouseDown for these browsers.
 if (!captureRightClick) { on(d.scroller, &quot;contextmenu&quot;, function (e) { return onContextMenu(cm, e); }) }
</PRE><PRE> // Used to suppress mouse event handling when a touch happens
 var touchFinished, prevTouch = {end: 0}
 function finishTouch() {
   if (d.activeTouch) {
     touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000)
     prevTouch = d.activeTouch
     prevTouch.end = +new Date
   }
 }
 function isMouseLikeTouchEvent(e) {
   if (e.touches.length != 1) { return false }
   var touch = e.touches[0]
   return touch.radiusX &lt;= 1 &amp;&amp; touch.radiusY &lt;= 1
 }
 function farAway(touch, other) {
   if (other.left == null) { return true }
   var dx = other.left - touch.left, dy = other.top - touch.top
   return dx * dx + dy * dy &gt; 20 * 20
 }
 on(d.scroller, &quot;touchstart&quot;, function (e) {
   if (!signalDOMEvent(cm, e) &amp;&amp; !isMouseLikeTouchEvent(e)) {
     d.input.ensurePolled()
     clearTimeout(touchFinished)
     var now = +new Date
     d.activeTouch = {start: now, moved: false,
                      prev: now - prevTouch.end &lt;= 300 ? prevTouch : null}
     if (e.touches.length == 1) {
       d.activeTouch.left = e.touches[0].pageX
       d.activeTouch.top = e.touches[0].pageY
     }
   }
 })
 on(d.scroller, &quot;touchmove&quot;, function () {
   if (d.activeTouch) { d.activeTouch.moved = true }
 })
 on(d.scroller, &quot;touchend&quot;, function (e) {
   var touch = d.activeTouch
   if (touch &amp;&amp; !eventInWidget(d, e) &amp;&amp; touch.left != null &amp;&amp; !touch.moved &amp;&amp; new Date - touch.start &lt; 300) {
     var pos = cm.coordsChar(d.activeTouch, &quot;page&quot;), range
     if (!touch.prev || farAway(touch, touch.prev)) // Single tap
       { range = new Range(pos, pos) }
     else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
       { range = cm.findWordAt(pos) }
     else // Triple tap
       { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
     cm.setSelection(range.anchor, range.head)
     cm.focus()
     e_preventDefault(e)
   }
   finishTouch()
 })
 on(d.scroller, &quot;touchcancel&quot;, finishTouch)
</PRE><PRE> // Sync scrolling between fake scrollbars and real scrollable
 // area, ensure viewport is updated when scrolling.
 on(d.scroller, &quot;scroll&quot;, function () {
   if (d.scroller.clientHeight) {
     setScrollTop(cm, d.scroller.scrollTop)
     setScrollLeft(cm, d.scroller.scrollLeft, true)
     signal(cm, &quot;scroll&quot;, cm)
   }
 })
</PRE><PRE> // Listen to wheel events in order to try and update the viewport on time.
 on(d.scroller, &quot;mousewheel&quot;, function (e) { return onScrollWheel(cm, e); })
 on(d.scroller, &quot;DOMMouseScroll&quot;, function (e) { return onScrollWheel(cm, e); })
</PRE><PRE> // Prevent wrapper from ever scrolling
 on(d.wrapper, &quot;scroll&quot;, function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; })
</PRE><PRE> d.dragFunctions = {
   enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e) }},
   over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e) }},
   start: function (e) { return onDragStart(cm, e); },
   drop: operation(cm, onDrop),
   leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm) }}
 }
</PRE><PRE> var inp = d.input.getField()
 on(inp, &quot;keyup&quot;, function (e) { return onKeyUp.call(cm, e); })
 on(inp, &quot;keydown&quot;, operation(cm, onKeyDown))
 on(inp, &quot;keypress&quot;, operation(cm, onKeyPress))
 on(inp, &quot;focus&quot;, function (e) { return onFocus(cm, e); })
 on(inp, &quot;blur&quot;, function (e) { return onBlur(cm, e); })
</PRE><P>}
</P><P>var initHooks = []
CodeMirror.defineInitHook = function (f) { return initHooks.push(f); }
</P><P>// Indent the given line. The how parameter can be &quot;smart&quot;,
// &quot;add&quot;/null, &quot;subtract&quot;, or &quot;prev&quot;. When aggressive is false
// (typically set to true for forced single-line indents), empty
// lines are not indented, and places where the mode returns Pass
// are left alone.
function indentLine(cm, n, how, aggressive) {
</P><PRE> var doc = cm.doc, state
 if (how == null) { how = &quot;add&quot; }
 if (how == &quot;smart&quot;) {
   // Fall back to &quot;prev&quot; when the mode doesn't have an indentation
   // method.
   if (!doc.mode.indent) { how = &quot;prev&quot; }
   else { state = getStateBefore(cm, n) }
 }
</PRE><PRE> var tabSize = cm.options.tabSize
 var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize)
 if (line.stateAfter) { line.stateAfter = null }
 var curSpaceString = line.text.match(/^\s*/)[0], indentation
 if (!aggressive &amp;&amp; !/\S/.test(line.text)) {
   indentation = 0
   how = &quot;not&quot;
 } else if (how == &quot;smart&quot;) {
   indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)
   if (indentation == Pass || indentation &gt; 150) {
     if (!aggressive) { return }
     how = &quot;prev&quot;
   }
 }
 if (how == &quot;prev&quot;) {
   if (n &gt; doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize) }
   else { indentation = 0 }
 } else if (how == &quot;add&quot;) {
   indentation = curSpace + cm.options.indentUnit
 } else if (how == &quot;subtract&quot;) {
   indentation = curSpace - cm.options.indentUnit
 } else if (typeof how == &quot;number&quot;) {
   indentation = curSpace + how
 }
 indentation = Math.max(0, indentation)
</PRE><PRE> var indentString = &quot;&quot;, pos = 0
 if (cm.options.indentWithTabs)
   { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += &quot;\t&quot;} }
 if (pos &lt; indentation) { indentString += spaceStr(indentation - pos) }
</PRE><PRE> if (indentString != curSpaceString) {
   replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), &quot;+input&quot;)
   line.stateAfter = null
   return true
 } else {
   // Ensure that, if the cursor was in the whitespace at the start
   // of the line, it is moved to the end of that space.
   for (var i$1 = 0; i$1 &lt; doc.sel.ranges.length; i$1++) {
     var range = doc.sel.ranges[i$1]
     if (range.head.line == n &amp;&amp; range.head.ch &lt; curSpaceString.length) {
       var pos$1 = Pos(n, curSpaceString.length)
       replaceOneSelection(doc, i$1, new Range(pos$1, pos$1))
       break
     }
   }
 }
</PRE><P>}
</P><P>// This will be set to a {lineWise: bool, text: [string]} object, so
// that, when pasting, we know what kind of selections the copied
// text was made out of.
var lastCopied = null
</P><P>function setLastCopied(newLastCopied) {
</P><PRE> lastCopied = newLastCopied
</PRE><P>}
</P><P>function applyTextInput(cm, inserted, deleted, sel, origin) {
</P><PRE> var doc = cm.doc
 cm.display.shift = false
 if (!sel) { sel = doc.sel }
</PRE><PRE> var paste = cm.state.pasteIncoming || origin == &quot;paste&quot;
 var textLines = splitLinesAuto(inserted), multiPaste = null
 // When pasing N lines into N selections, insert one line per selection
 if (paste &amp;&amp; sel.ranges.length &gt; 1) {
   if (lastCopied &amp;&amp; lastCopied.text.join(&quot;\n&quot;) == inserted) {
     if (sel.ranges.length % lastCopied.text.length == 0) {
       multiPaste = []
       for (var i = 0; i &lt; lastCopied.text.length; i++)
         { multiPaste.push(doc.splitLines(lastCopied.text[i])) }
     }
   } else if (textLines.length == sel.ranges.length) {
     multiPaste = map(textLines, function (l) { return [l]; })
   }
 }
</PRE><PRE> var updateInput
 // Normal behavior is to insert the new text into every selection
 for (var i$1 = sel.ranges.length - 1; i$1 &gt;= 0; i$1--) {
   var range = sel.ranges[i$1]
   var from = range.from(), to = range.to()
   if (range.empty()) {
     if (deleted &amp;&amp; deleted &gt; 0) // Handle deletion
       { from = Pos(from.line, from.ch - deleted) }
     else if (cm.state.overwrite &amp;&amp; !paste) // Handle overwrite
       { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) }
     else if (lastCopied &amp;&amp; lastCopied.lineWise &amp;&amp; lastCopied.text.join(&quot;\n&quot;) == inserted)
       { from = to = Pos(from.line, 0) }
   }
   updateInput = cm.curOp.updateInput
   var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                      origin: origin || (paste ? &quot;paste&quot; : cm.state.cutIncoming ? &quot;cut&quot; : &quot;+input&quot;)}
   makeChange(cm.doc, changeEvent)
   signalLater(cm, &quot;inputRead&quot;, cm, changeEvent)
 }
 if (inserted &amp;&amp; !paste)
   { triggerElectric(cm, inserted) }
</PRE><PRE> ensureCursorVisible(cm)
 cm.curOp.updateInput = updateInput
 cm.curOp.typing = true
 cm.state.pasteIncoming = cm.state.cutIncoming = false
</PRE><P>}
</P><P>function handlePaste(e, cm) {
</P><PRE> var pasted = e.clipboardData &amp;&amp; e.clipboardData.getData(&quot;Text&quot;)
 if (pasted) {
   e.preventDefault()
   if (!cm.isReadOnly() &amp;&amp; !cm.options.disableInput)
     { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, &quot;paste&quot;); }) }
   return true
 }
</PRE><P>}
</P><P>function triggerElectric(cm, inserted) {
</P><PRE> // When an 'electric' character is inserted, immediately trigger a reindent
 if (!cm.options.electricChars || !cm.options.smartIndent) { return }
 var sel = cm.doc.sel
</PRE><PRE> for (var i = sel.ranges.length - 1; i &gt;= 0; i--) {
   var range = sel.ranges[i]
   if (range.head.ch &gt; 100 || (i &amp;&amp; sel.ranges[i - 1].head.line == range.head.line)) { continue }
   var mode = cm.getModeAt(range.head)
   var indented = false
   if (mode.electricChars) {
     for (var j = 0; j &lt; mode.electricChars.length; j++)
       { if (inserted.indexOf(mode.electricChars.charAt(j)) &gt; -1) {
         indented = indentLine(cm, range.head.line, &quot;smart&quot;)
         break
       } }
   } else if (mode.electricInput) {
     if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
       { indented = indentLine(cm, range.head.line, &quot;smart&quot;) }
   }
   if (indented) { signalLater(cm, &quot;electricInput&quot;, cm, range.head.line) }
 }
</PRE><P>}
</P><P>function copyableRanges(cm) {
</P><PRE> var text = [], ranges = []
 for (var i = 0; i &lt; cm.doc.sel.ranges.length; i++) {
   var line = cm.doc.sel.ranges[i].head.line
   var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)}
   ranges.push(lineRange)
   text.push(cm.getRange(lineRange.anchor, lineRange.head))
 }
 return {text: text, ranges: ranges}
</PRE><P>}
</P><P>function disableBrowserMagic(field, spellcheck) {
</P><PRE> field.setAttribute(&quot;autocorrect&quot;, &quot;off&quot;)
 field.setAttribute(&quot;autocapitalize&quot;, &quot;off&quot;)
 field.setAttribute(&quot;spellcheck&quot;, !!spellcheck)
</PRE><P>}
</P><P>function hiddenTextarea() {
</P><PRE> var te = elt(&quot;textarea&quot;, null, null, &quot;position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none&quot;)
 var div = elt(&quot;div&quot;, [te], null, &quot;overflow: hidden; position: relative; width: 3px; height: 0px;&quot;)
 // The textarea is kept positioned near the cursor to prevent the
 // fact that it'll be scrolled into view on input from scrolling
 // our fake cursor out of view. On webkit, when wrap=off, paste is
 // very slow. So make the area wide instead.
 if (webkit) { te.style.width = &quot;1000px&quot; }
 else { te.setAttribute(&quot;wrap&quot;, &quot;off&quot;) }
 // If border: 0; -- iOS fails to open keyboard (issue #1287)
 if (ios) { te.style.border = &quot;1px solid black&quot; }
 disableBrowserMagic(te)
 return div
</PRE><P>}
</P><P>// The publicly visible API. Note that methodOp(f) means
// 'wrap f in an operation, performed on its `this` parameter'.
</P><P>// This is not the complete set of editor methods. Most of the
// methods defined on the Doc type are also injected into
// CodeMirror.prototype, for backwards compatibility and
// convenience.
</P><P>function addEditorMethods(CodeMirror) {
</P><PRE> var optionHandlers = CodeMirror.optionHandlers
</PRE><PRE> var helpers = CodeMirror.helpers = {}
</PRE><PRE> CodeMirror.prototype = {
   constructor: CodeMirror,
   focus: function(){window.focus(); this.display.input.focus()},
</PRE><PRE>   setOption: function(option, value) {
     var options = this.options, old = options[option]
     if (options[option] == value &amp;&amp; option != &quot;mode&quot;) { return }
     options[option] = value
     if (optionHandlers.hasOwnProperty(option))
       { operation(this, optionHandlers[option])(this, value, old) }
     signal(this, &quot;optionChange&quot;, this, option)
   },
</PRE><PRE>   getOption: function(option) {return this.options[option]},
   getDoc: function() {return this.doc},
</PRE><PRE>   addKeyMap: function(map, bottom) {
     this.state.keyMaps[bottom ? &quot;push&quot; : &quot;unshift&quot;](getKeyMap(map))
   },
   removeKeyMap: function(map) {
     var maps = this.state.keyMaps
     for (var i = 0; i &lt; maps.length; ++i)
       { if (maps[i] == map || maps[i].name == map) {
         maps.splice(i, 1)
         return true
       } }
   },
</PRE><PRE>   addOverlay: methodOp(function(spec, options) {
     var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec)
     if (mode.startState) { throw new Error(&quot;Overlays may not be stateful.&quot;) }
     insertSorted(this.state.overlays,
                  {mode: mode, modeSpec: spec, opaque: options &amp;&amp; options.opaque,
                   priority: (options &amp;&amp; options.priority) || 0},
                  function (overlay) { return overlay.priority; })
     this.state.modeGen++
     regChange(this)
   }),
   removeOverlay: methodOp(function(spec) {
     var this$1 = this;
</PRE><PRE>     var overlays = this.state.overlays
     for (var i = 0; i &lt; overlays.length; ++i) {
       var cur = overlays[i].modeSpec
       if (cur == spec || typeof spec == &quot;string&quot; &amp;&amp; cur.name == spec) {
         overlays.splice(i, 1)
         this$1.state.modeGen++
         regChange(this$1)
         return
       }
     }
   }),
</PRE><PRE>   indentLine: methodOp(function(n, dir, aggressive) {
     if (typeof dir != &quot;string&quot; &amp;&amp; typeof dir != &quot;number&quot;) {
       if (dir == null) { dir = this.options.smartIndent ? &quot;smart&quot; : &quot;prev&quot; }
       else { dir = dir ? &quot;add&quot; : &quot;subtract&quot; }
     }
     if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive) }
   }),
   indentSelection: methodOp(function(how) {
     var this$1 = this;
</PRE><PRE>     var ranges = this.doc.sel.ranges, end = -1
     for (var i = 0; i &lt; ranges.length; i++) {
       var range = ranges[i]
       if (!range.empty()) {
         var from = range.from(), to = range.to()
         var start = Math.max(end, from.line)
         end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1
         for (var j = start; j &lt; end; ++j)
           { indentLine(this$1, j, how) }
         var newRanges = this$1.doc.sel.ranges
         if (from.ch == 0 &amp;&amp; ranges.length == newRanges.length &amp;&amp; newRanges[i].from().ch &gt; 0)
           { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll) }
       } else if (range.head.line &gt; end) {
         indentLine(this$1, range.head.line, how, true)
         end = range.head.line
         if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1) }
       }
     }
   }),
</PRE><PRE>   // Fetch the parser token for a given character. Useful for hacks
   // that want to inspect the mode state (say, for completion).
   getTokenAt: function(pos, precise) {
     return takeToken(this, pos, precise)
   },
</PRE><PRE>   getLineTokens: function(line, precise) {
     return takeToken(this, Pos(line), precise, true)
   },
</PRE><PRE>   getTokenTypeAt: function(pos) {
     pos = clipPos(this.doc, pos)
     var styles = getLineStyles(this, getLine(this.doc, pos.line))
     var before = 0, after = (styles.length - 1) / 2, ch = pos.ch
     var type
     if (ch == 0) { type = styles[2] }
     else { for (;;) {
       var mid = (before + after) &gt;&gt; 1
       if ((mid ? styles[mid * 2 - 1] : 0) &gt;= ch) { after = mid }
       else if (styles[mid * 2 + 1] &lt; ch) { before = mid + 1 }
       else { type = styles[mid * 2 + 2]; break }
     } }
     var cut = type ? type.indexOf(&quot;overlay &quot;) : -1
     return cut &lt; 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
   },
</PRE><PRE>   getModeAt: function(pos) {
     var mode = this.doc.mode
     if (!mode.innerMode) { return mode }
     return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
   },
</PRE><PRE>   getHelper: function(pos, type) {
     return this.getHelpers(pos, type)[0]
   },
</PRE><PRE>   getHelpers: function(pos, type) {
     var this$1 = this;
</PRE><PRE>     var found = []
     if (!helpers.hasOwnProperty(type)) { return found }
     var help = helpers[type], mode = this.getModeAt(pos)
     if (typeof mode[type] == &quot;string&quot;) {
       if (help[mode[type]]) { found.push(help[mode[type]]) }
     } else if (mode[type]) {
       for (var i = 0; i &lt; mode[type].length; i++) {
         var val = help[mode[type][i]]
         if (val) { found.push(val) }
       }
     } else if (mode.helperType &amp;&amp; help[mode.helperType]) {
       found.push(help[mode.helperType])
     } else if (help[mode.name]) {
       found.push(help[mode.name])
     }
     for (var i$1 = 0; i$1 &lt; help._global.length; i$1++) {
       var cur = help._global[i$1]
       if (cur.pred(mode, this$1) &amp;&amp; indexOf(found, cur.val) == -1)
         { found.push(cur.val) }
     }
     return found
   },
</PRE><PRE>   getStateAfter: function(line, precise) {
     var doc = this.doc
     line = clipLine(doc, line == null ? doc.first + doc.size - 1: line)
     return getStateBefore(this, line + 1, precise)
   },
</PRE><PRE>   cursorCoords: function(start, mode) {
     var pos, range = this.doc.sel.primary()
     if (start == null) { pos = range.head }
     else if (typeof start == &quot;object&quot;) { pos = clipPos(this.doc, start) }
     else { pos = start ? range.from() : range.to() }
     return cursorCoords(this, pos, mode || &quot;page&quot;)
   },
</PRE><PRE>   charCoords: function(pos, mode) {
     return charCoords(this, clipPos(this.doc, pos), mode || &quot;page&quot;)
   },
</PRE><PRE>   coordsChar: function(coords, mode) {
     coords = fromCoordSystem(this, coords, mode || &quot;page&quot;)
     return coordsChar(this, coords.left, coords.top)
   },
</PRE><PRE>   lineAtHeight: function(height, mode) {
     height = fromCoordSystem(this, {top: height, left: 0}, mode || &quot;page&quot;).top
     return lineAtHeight(this.doc, height + this.display.viewOffset)
   },
   heightAtLine: function(line, mode, includeWidgets) {
     var end = false, lineObj
     if (typeof line == &quot;number&quot;) {
       var last = this.doc.first + this.doc.size - 1
       if (line &lt; this.doc.first) { line = this.doc.first }
       else if (line &gt; last) { line = last; end = true }
       lineObj = getLine(this.doc, line)
     } else {
       lineObj = line
     }
     return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || &quot;page&quot;, includeWidgets || end).top +
       (end ? this.doc.height - heightAtLine(lineObj) : 0)
   },
</PRE><PRE>   defaultTextHeight: function() { return textHeight(this.display) },
   defaultCharWidth: function() { return charWidth(this.display) },
</PRE><PRE>   getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},
</PRE><PRE>   addWidget: function(pos, node, scroll, vert, horiz) {
     var display = this.display
     pos = cursorCoords(this, clipPos(this.doc, pos))
     var top = pos.bottom, left = pos.left
     node.style.position = &quot;absolute&quot;
     node.setAttribute(&quot;cm-ignore-events&quot;, &quot;true&quot;)
     this.display.input.setUneditable(node)
     display.sizer.appendChild(node)
     if (vert == &quot;over&quot;) {
       top = pos.top
     } else if (vert == &quot;above&quot; || vert == &quot;near&quot;) {
       var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
       hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth)
       // Default to positioning above (if specified and possible); otherwise default to positioning below
       if ((vert == 'above' || pos.bottom + node.offsetHeight &gt; vspace) &amp;&amp; pos.top &gt; node.offsetHeight)
         { top = pos.top - node.offsetHeight }
       else if (pos.bottom + node.offsetHeight &lt;= vspace)
         { top = pos.bottom }
       if (left + node.offsetWidth &gt; hspace)
         { left = hspace - node.offsetWidth }
     }
     node.style.top = top + &quot;px&quot;
     node.style.left = node.style.right = &quot;&quot;
     if (horiz == &quot;right&quot;) {
       left = display.sizer.clientWidth - node.offsetWidth
       node.style.right = &quot;0px&quot;
     } else {
       if (horiz == &quot;left&quot;) { left = 0 }
       else if (horiz == &quot;middle&quot;) { left = (display.sizer.clientWidth - node.offsetWidth) / 2 }
       node.style.left = left + &quot;px&quot;
     }
     if (scroll)
       { scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight) }
   },
</PRE><PRE>   triggerOnKeyDown: methodOp(onKeyDown),
   triggerOnKeyPress: methodOp(onKeyPress),
   triggerOnKeyUp: onKeyUp,
</PRE><PRE>   execCommand: function(cmd) {
     if (commands.hasOwnProperty(cmd))
       { return commands[cmd].call(null, this) }
   },
</PRE><PRE>   triggerElectric: methodOp(function(text) { triggerElectric(this, text) }),
</PRE><PRE>   findPosH: function(from, amount, unit, visually) {
     var this$1 = this;
</PRE><PRE>     var dir = 1
     if (amount &lt; 0) { dir = -1; amount = -amount }
     var cur = clipPos(this.doc, from)
     for (var i = 0; i &lt; amount; ++i) {
       cur = findPosH(this$1.doc, cur, dir, unit, visually)
       if (cur.hitSide) { break }
     }
     return cur
   },
</PRE><PRE>   moveH: methodOp(function(dir, unit) {
     var this$1 = this;
</PRE><PRE>     this.extendSelectionsBy(function (range) {
       if (this$1.display.shift || this$1.doc.extend || range.empty())
         { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
       else
         { return dir &lt; 0 ? range.from() : range.to() }
     }, sel_move)
   }),
</PRE><PRE>   deleteH: methodOp(function(dir, unit) {
     var sel = this.doc.sel, doc = this.doc
     if (sel.somethingSelected())
       { doc.replaceSelection(&quot;&quot;, null, &quot;+delete&quot;) }
     else
       { deleteNearSelection(this, function (range) {
         var other = findPosH(doc, range.head, dir, unit, false)
         return dir &lt; 0 ? {from: other, to: range.head} : {from: range.head, to: other}
       }) }
   }),
</PRE><PRE>   findPosV: function(from, amount, unit, goalColumn) {
     var this$1 = this;
</PRE><PRE>     var dir = 1, x = goalColumn
     if (amount &lt; 0) { dir = -1; amount = -amount }
     var cur = clipPos(this.doc, from)
     for (var i = 0; i &lt; amount; ++i) {
       var coords = cursorCoords(this$1, cur, &quot;div&quot;)
       if (x == null) { x = coords.left }
       else { coords.left = x }
       cur = findPosV(this$1, coords, dir, unit)
       if (cur.hitSide) { break }
     }
     return cur
   },
</PRE><PRE>   moveV: methodOp(function(dir, unit) {
     var this$1 = this;
</PRE><PRE>     var doc = this.doc, goals = []
     var collapse = !this.display.shift &amp;&amp; !doc.extend &amp;&amp; doc.sel.somethingSelected()
     doc.extendSelectionsBy(function (range) {
       if (collapse)
         { return dir &lt; 0 ? range.from() : range.to() }
       var headPos = cursorCoords(this$1, range.head, &quot;div&quot;)
       if (range.goalColumn != null) { headPos.left = range.goalColumn }
       goals.push(headPos.left)
       var pos = findPosV(this$1, headPos, dir, unit)
       if (unit == &quot;page&quot; &amp;&amp; range == doc.sel.primary())
         { addToScrollPos(this$1, null, charCoords(this$1, pos, &quot;div&quot;).top - headPos.top) }
       return pos
     }, sel_move)
     if (goals.length) { for (var i = 0; i &lt; doc.sel.ranges.length; i++)
       { doc.sel.ranges[i].goalColumn = goals[i] } }
   }),
</PRE><PRE>   // Find the word at the given position (as returned by coordsChar).
   findWordAt: function(pos) {
     var doc = this.doc, line = getLine(doc, pos.line).text
     var start = pos.ch, end = pos.ch
     if (line) {
       var helper = this.getHelper(pos, &quot;wordChars&quot;)
       if ((pos.sticky == &quot;before&quot; || end == line.length) &amp;&amp; start) { --start; } else { ++end }
       var startChar = line.charAt(start)
       var check = isWordChar(startChar, helper)
         ? function (ch) { return isWordChar(ch, helper); }
         : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
         : function (ch) { return (!/\s/.test(ch) &amp;&amp; !isWordChar(ch)); }
       while (start &gt; 0 &amp;&amp; check(line.charAt(start - 1))) { --start }
       while (end &lt; line.length &amp;&amp; check(line.charAt(end))) { ++end }
     }
     return new Range(Pos(pos.line, start), Pos(pos.line, end))
   },
</PRE><PRE>   toggleOverwrite: function(value) {
     if (value != null &amp;&amp; value == this.state.overwrite) { return }
     if (this.state.overwrite = !this.state.overwrite)
       { addClass(this.display.cursorDiv, &quot;CodeMirror-overwrite&quot;) }
     else
       { rmClass(this.display.cursorDiv, &quot;CodeMirror-overwrite&quot;) }
</PRE><PRE>     signal(this, &quot;overwriteToggle&quot;, this, this.state.overwrite)
   },
   hasFocus: function() { return this.display.input.getField() == activeElt() },
   isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },
</PRE><PRE>   scrollTo: methodOp(function(x, y) {
     if (x != null || y != null) { resolveScrollToPos(this) }
     if (x != null) { this.curOp.scrollLeft = x }
     if (y != null) { this.curOp.scrollTop = y }
   }),
   getScrollInfo: function() {
     var scroller = this.display.scroller
     return {left: scroller.scrollLeft, top: scroller.scrollTop,
             height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
             width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
             clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
   },
</PRE><PRE>   scrollIntoView: methodOp(function(range, margin) {
     if (range == null) {
       range = {from: this.doc.sel.primary().head, to: null}
       if (margin == null) { margin = this.options.cursorScrollMargin }
     } else if (typeof range == &quot;number&quot;) {
       range = {from: Pos(range, 0), to: null}
     } else if (range.from == null) {
       range = {from: range, to: null}
     }
     if (!range.to) { range.to = range.from }
     range.margin = margin || 0
</PRE><PRE>     if (range.from.line != null) {
       resolveScrollToPos(this)
       this.curOp.scrollToPos = range
     } else {
       var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                     Math.min(range.from.top, range.to.top) - range.margin,
                                     Math.max(range.from.right, range.to.right),
                                     Math.max(range.from.bottom, range.to.bottom) + range.margin)
       this.scrollTo(sPos.scrollLeft, sPos.scrollTop)
     }
   }),
</PRE><PRE>   setSize: methodOp(function(width, height) {
     var this$1 = this;
</PRE><PRE>     var interpret = function (val) { return typeof val == &quot;number&quot; || /^\d+$/.test(String(val)) ? val + &quot;px&quot; : val; }
     if (width != null) { this.display.wrapper.style.width = interpret(width) }
     if (height != null) { this.display.wrapper.style.height = interpret(height) }
     if (this.options.lineWrapping) { clearLineMeasurementCache(this) }
     var lineNo = this.display.viewFrom
     this.doc.iter(lineNo, this.display.viewTo, function (line) {
       if (line.widgets) { for (var i = 0; i &lt; line.widgets.length; i++)
         { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, &quot;widget&quot;); break } } }
       ++lineNo
     })
     this.curOp.forceUpdate = true
     signal(this, &quot;refresh&quot;, this)
   }),
</PRE><PRE>   operation: function(f){return runInOp(this, f)},
</PRE><PRE>   refresh: methodOp(function() {
     var oldHeight = this.display.cachedTextHeight
     regChange(this)
     this.curOp.forceUpdate = true
     clearCaches(this)
     this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop)
     updateGutterSpace(this)
     if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) &gt; .5)
       { estimateLineHeights(this) }
     signal(this, &quot;refresh&quot;, this)
   }),
</PRE><PRE>   swapDoc: methodOp(function(doc) {
     var old = this.doc
     old.cm = null
     attachDoc(this, doc)
     clearCaches(this)
     this.display.input.reset()
     this.scrollTo(doc.scrollLeft, doc.scrollTop)
     this.curOp.forceScroll = true
     signalLater(this, &quot;swapDoc&quot;, this, old)
     return old
   }),
</PRE><PRE>   getInputField: function(){return this.display.input.getField()},
   getWrapperElement: function(){return this.display.wrapper},
   getScrollerElement: function(){return this.display.scroller},
   getGutterElement: function(){return this.display.gutters}
 }
 eventMixin(CodeMirror)
</PRE><PRE> CodeMirror.registerHelper = function(type, name, value) {
   if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []} }
   helpers[type][name] = value
 }
 CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
   CodeMirror.registerHelper(type, name, value)
   helpers[type]._global.push({pred: predicate, val: value})
 }
</PRE><P>}
</P><P>// Used for horizontal relative motion. Dir is -1 or 1 (left or
// right), unit can be &quot;char&quot;, &quot;column&quot; (like char, but doesn't
// cross line boundaries), &quot;word&quot; (across next word), or &quot;group&quot; (to
// the start of next group of word or non-word-non-whitespace
// chars). The visually param controls whether, in right-to-left
// text, direction 1 means to move towards the next index in the
// string, or towards the character to the right of the current
// position. The resulting position will have a hitSide=true
// property if it reached the end of the document.
function findPosH(doc, pos, dir, unit, visually) {
</P><PRE> var oldPos = pos
 var origDir = dir
 var lineObj = getLine(doc, pos.line)
 function findNextLine() {
   var l = pos.line + dir
   if (l &lt; doc.first || l &gt;= doc.first + doc.size) { return false }
   pos = new Pos(l, pos.ch, pos.sticky)
   return lineObj = getLine(doc, l)
 }
 function moveOnce(boundToLine) {
   var next
   if (visually) {
     next = moveVisually(doc.cm, lineObj, pos, dir)
   } else {
     next = moveLogically(lineObj, pos, dir)
   }
   if (next == null) {
     if (!boundToLine &amp;&amp; findNextLine())
       { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir) }
     else
       { return false }
   } else {
     pos = next
   }
   return true
 }
</PRE><PRE> if (unit == &quot;char&quot;) {
   moveOnce()
 } else if (unit == &quot;column&quot;) {
   moveOnce(true)
 } else if (unit == &quot;word&quot; || unit == &quot;group&quot;) {
   var sawType = null, group = unit == &quot;group&quot;
   var helper = doc.cm &amp;&amp; doc.cm.getHelper(pos, &quot;wordChars&quot;)
   for (var first = true;; first = false) {
     if (dir &lt; 0 &amp;&amp; !moveOnce(!first)) { break }
     var cur = lineObj.text.charAt(pos.ch) || &quot;\n&quot;
     var type = isWordChar(cur, helper) ? &quot;w&quot;
       : group &amp;&amp; cur == &quot;\n&quot; ? &quot;n&quot;
       : !group || /\s/.test(cur) ? null
       : &quot;p&quot;
     if (group &amp;&amp; !first &amp;&amp; !type) { type = &quot;s&quot; }
     if (sawType &amp;&amp; sawType != type) {
       if (dir &lt; 0) {dir = 1; moveOnce(); pos.sticky = &quot;after&quot;}
       break
     }
</PRE><PRE>     if (type) { sawType = type }
     if (dir &gt; 0 &amp;&amp; !moveOnce(!first)) { break }
   }
 }
 var result = skipAtomic(doc, pos, oldPos, origDir, true)
 if (equalCursorPos(oldPos, result)) { result.hitSide = true }
 return result
</PRE><P>}
</P><P>// For relative vertical movement. Dir may be -1 or 1. Unit can be
// &quot;page&quot; or &quot;line&quot;. The resulting position will have a hitSide=true
// property if it reached the end of the document.
function findPosV(cm, pos, dir, unit) {
</P><PRE> var doc = cm.doc, x = pos.left, y
 if (unit == &quot;page&quot;) {
   var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight)
   var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3)
   y = (dir &gt; 0 ? pos.bottom : pos.top) + dir * moveAmount
</PRE><PRE> } else if (unit == &quot;line&quot;) {
   y = dir &gt; 0 ? pos.bottom + 3 : pos.top - 3
 }
 var target
 for (;;) {
   target = coordsChar(cm, x, y)
   if (!target.outside) { break }
   if (dir &lt; 0 ? y &lt;= 0 : y &gt;= doc.height) { target.hitSide = true; break }
   y += dir * 5
 }
 return target
</PRE><P>}
</P><P>// CONTENTEDITABLE INPUT STYLE
</P><P>var ContentEditableInput = function(cm) {
</P><PRE> this.cm = cm
 this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null
 this.polling = new Delayed()
 this.composing = null
 this.gracePeriod = false
 this.readDOMTimeout = null
</PRE><P>};
</P><P>ContentEditableInput.prototype.init = function (display) {
</P><PRE>   var this$1 = this;
</PRE><PRE> var input = this, cm = input.cm
 var div = input.div = display.lineDiv
 disableBrowserMagic(div, cm.options.spellcheck)
</PRE><PRE> on(div, &quot;paste&quot;, function (e) {
   if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
   // IE doesn't fire input events, so we schedule a read for the pasted content in this way
   if (ie_version &lt;= 11) { setTimeout(operation(cm, function () {
     if (!input.pollContent()) { regChange(cm) }
   }), 20) }
 })
</PRE><PRE> on(div, &quot;compositionstart&quot;, function (e) {
   this$1.composing = {data: e.data, done: false}
 })
 on(div, &quot;compositionupdate&quot;, function (e) {
   if (!this$1.composing) { this$1.composing = {data: e.data, done: false} }
 })
 on(div, &quot;compositionend&quot;, function (e) {
   if (this$1.composing) {
     if (e.data != this$1.composing.data) { this$1.readFromDOMSoon() }
     this$1.composing.done = true
   }
 })
</PRE><PRE> on(div, &quot;touchstart&quot;, function () { return input.forceCompositionEnd(); })
</PRE><PRE> on(div, &quot;input&quot;, function () {
   if (!this$1.composing) { this$1.readFromDOMSoon() }
 })
</PRE><PRE> function onCopyCut(e) {
   if (signalDOMEvent(cm, e)) { return }
   if (cm.somethingSelected()) {
     setLastCopied({lineWise: false, text: cm.getSelections()})
     if (e.type == &quot;cut&quot;) { cm.replaceSelection(&quot;&quot;, null, &quot;cut&quot;) }
   } else if (!cm.options.lineWiseCopyCut) {
     return
   } else {
     var ranges = copyableRanges(cm)
     setLastCopied({lineWise: true, text: ranges.text})
     if (e.type == &quot;cut&quot;) {
       cm.operation(function () {
         cm.setSelections(ranges.ranges, 0, sel_dontScroll)
         cm.replaceSelection(&quot;&quot;, null, &quot;cut&quot;)
       })
     }
   }
   if (e.clipboardData) {
     e.clipboardData.clearData()
     var content = lastCopied.text.join(&quot;\n&quot;)
     // iOS exposes the clipboard API, but seems to discard content inserted into it
     e.clipboardData.setData(&quot;Text&quot;, content)
     if (e.clipboardData.getData(&quot;Text&quot;) == content) {
       e.preventDefault()
       return
     }
   }
   // Old-fashioned briefly-focus-a-textarea hack
   var kludge = hiddenTextarea(), te = kludge.firstChild
   cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild)
   te.value = lastCopied.text.join(&quot;\n&quot;)
   var hadFocus = document.activeElement
   selectInput(te)
   setTimeout(function () {
     cm.display.lineSpace.removeChild(kludge)
     hadFocus.focus()
     if (hadFocus == div) { input.showPrimarySelection() }
   }, 50)
 }
 on(div, &quot;copy&quot;, onCopyCut)
 on(div, &quot;cut&quot;, onCopyCut)
</PRE><P>};
</P><P>ContentEditableInput.prototype.prepareSelection = function () {
</P><PRE> var result = prepareSelection(this.cm, false)
 result.focus = this.cm.state.focused
 return result
</PRE><P>};
</P><P>ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
</P><PRE> if (!info || !this.cm.display.view.length) { return }
 if (info.focus || takeFocus) { this.showPrimarySelection() }
 this.showMultipleSelections(info)
</PRE><P>};
</P><P>ContentEditableInput.prototype.showPrimarySelection = function () {
</P><PRE> var sel = window.getSelection(), prim = this.cm.doc.sel.primary()
 var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset)
 var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset)
 if (curAnchor &amp;&amp; !curAnchor.bad &amp;&amp; curFocus &amp;&amp; !curFocus.bad &amp;&amp;
     cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &amp;&amp;
     cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
   { return }
</PRE><PRE> var start = posToDOM(this.cm, prim.from())
 var end = posToDOM(this.cm, prim.to())
 if (!start &amp;&amp; !end) { return }
</PRE><PRE> var view = this.cm.display.view
 var old = sel.rangeCount &amp;&amp; sel.getRangeAt(0)
 if (!start) {
   start = {node: view[0].measure.map[2], offset: 0}
 } else if (!end) { // FIXME dangerously hacky
   var measure = view[view.length - 1].measure
   var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map
   end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]}
 }
</PRE><PRE> var rng
 try { rng = range(start.node, start.offset, end.offset, end.node) }
 catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
 if (rng) {
   if (!gecko &amp;&amp; this.cm.state.focused) {
     sel.collapse(start.node, start.offset)
     if (!rng.collapsed) {
       sel.removeAllRanges()
       sel.addRange(rng)
     }
   } else {
     sel.removeAllRanges()
     sel.addRange(rng)
   }
   if (old &amp;&amp; sel.anchorNode == null) { sel.addRange(old) }
   else if (gecko) { this.startGracePeriod() }
 }
 this.rememberSelection()
</PRE><P>};
</P><P>ContentEditableInput.prototype.startGracePeriod = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> clearTimeout(this.gracePeriod)
 this.gracePeriod = setTimeout(function () {
   this$1.gracePeriod = false
   if (this$1.selectionChanged())
     { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }) }
 }, 20)
</PRE><P>};
</P><P>ContentEditableInput.prototype.showMultipleSelections = function (info) {
</P><PRE> removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors)
 removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)
</PRE><P>};
</P><P>ContentEditableInput.prototype.rememberSelection = function () {
</P><PRE> var sel = window.getSelection()
 this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset
 this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset
</PRE><P>};
</P><P>ContentEditableInput.prototype.selectionInEditor = function () {
</P><PRE> var sel = window.getSelection()
 if (!sel.rangeCount) { return false }
 var node = sel.getRangeAt(0).commonAncestorContainer
 return contains(this.div, node)
</PRE><P>};
</P><P>ContentEditableInput.prototype.focus = function () {
</P><PRE> if (this.cm.options.readOnly != &quot;nocursor&quot;) {
   if (!this.selectionInEditor())
     { this.showSelection(this.prepareSelection(), true) }
   this.div.focus()
 }
</PRE><P>};
ContentEditableInput.prototype.blur = function () { this.div.blur() };
ContentEditableInput.prototype.getField = function () { return this.div };
</P><P>ContentEditableInput.prototype.supportsTouch = function () { return true };
</P><P>ContentEditableInput.prototype.receivedFocus = function () {
</P><PRE> var input = this
 if (this.selectionInEditor())
   { this.pollSelection() }
 else
   { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }) }
</PRE><PRE> function poll() {
   if (input.cm.state.focused) {
     input.pollSelection()
     input.polling.set(input.cm.options.pollInterval, poll)
   }
 }
 this.polling.set(this.cm.options.pollInterval, poll)
</PRE><P>};
</P><P>ContentEditableInput.prototype.selectionChanged = function () {
</P><PRE> var sel = window.getSelection()
 return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
   sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
</PRE><P>};
</P><P>ContentEditableInput.prototype.pollSelection = function () {
</P><PRE> if (!this.composing &amp;&amp; this.readDOMTimeout == null &amp;&amp; !this.gracePeriod &amp;&amp; this.selectionChanged()) {
   var sel = window.getSelection(), cm = this.cm
   this.rememberSelection()
   var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)
   var head = domToPos(cm, sel.focusNode, sel.focusOffset)
   if (anchor &amp;&amp; head) { runInOp(cm, function () {
     setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll)
     if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true }
   }) }
 }
</PRE><P>};
</P><P>ContentEditableInput.prototype.pollContent = function () {
</P><PRE> if (this.readDOMTimeout != null) {
   clearTimeout(this.readDOMTimeout)
   this.readDOMTimeout = null
 }
</PRE><PRE> var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary()
 var from = sel.from(), to = sel.to()
 if (from.ch == 0 &amp;&amp; from.line &gt; cm.firstLine())
   { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length) }
 if (to.ch == getLine(cm.doc, to.line).text.length &amp;&amp; to.line &lt; cm.lastLine())
   { to = Pos(to.line + 1, 0) }
 if (from.line &lt; display.viewFrom || to.line &gt; display.viewTo - 1) { return false }
</PRE><PRE> var fromIndex, fromLine, fromNode
 if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
   fromLine = lineNo(display.view[0].line)
   fromNode = display.view[0].node
 } else {
   fromLine = lineNo(display.view[fromIndex].line)
   fromNode = display.view[fromIndex - 1].node.nextSibling
 }
 var toIndex = findViewIndex(cm, to.line)
 var toLine, toNode
 if (toIndex == display.view.length - 1) {
   toLine = display.viewTo - 1
   toNode = display.lineDiv.lastChild
 } else {
   toLine = lineNo(display.view[toIndex + 1].line) - 1
   toNode = display.view[toIndex + 1].node.previousSibling
 }
</PRE><PRE> if (!fromNode) { return false }
 var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine))
 var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length))
 while (newText.length &gt; 1 &amp;&amp; oldText.length &gt; 1) {
   if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine-- }
   else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++ }
   else { break }
 }
</PRE><PRE> var cutFront = 0, cutEnd = 0
 var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length)
 while (cutFront &lt; maxCutFront &amp;&amp; newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
   { ++cutFront }
 var newBot = lst(newText), oldBot = lst(oldText)
 var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                          oldBot.length - (oldText.length == 1 ? cutFront : 0))
 while (cutEnd &lt; maxCutEnd &amp;&amp;
        newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
   { ++cutEnd }
</PRE><PRE> newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, &quot;&quot;)
 newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, &quot;&quot;)
</PRE><PRE> var chFrom = Pos(fromLine, cutFront)
 var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0)
 if (newText.length &gt; 1 || newText[0] || cmp(chFrom, chTo)) {
   replaceRange(cm.doc, newText, chFrom, chTo, &quot;+input&quot;)
   return true
 }
</PRE><P>};
</P><P>ContentEditableInput.prototype.ensurePolled = function () {
</P><PRE> this.forceCompositionEnd()
</PRE><P>};
ContentEditableInput.prototype.reset = function () {
</P><PRE> this.forceCompositionEnd()
</PRE><P>};
ContentEditableInput.prototype.forceCompositionEnd = function () {
</P><PRE> if (!this.composing) { return }
 clearTimeout(this.readDOMTimeout)
 this.composing = null
 if (!this.pollContent()) { regChange(this.cm) }
 this.div.blur()
 this.div.focus()
</PRE><P>};
ContentEditableInput.prototype.readFromDOMSoon = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> if (this.readDOMTimeout != null) { return }
 this.readDOMTimeout = setTimeout(function () {
   this$1.readDOMTimeout = null
   if (this$1.composing) {
     if (this$1.composing.done) { this$1.composing = null }
     else { return }
   }
   if (this$1.cm.isReadOnly() || !this$1.pollContent())
     { runInOp(this$1.cm, function () { return regChange(this$1.cm); }) }
 }, 80)
</PRE><P>};
</P><P>ContentEditableInput.prototype.setUneditable = function (node) {
</P><PRE> node.contentEditable = &quot;false&quot;
</PRE><P>};
</P><P>ContentEditableInput.prototype.onKeyPress = function (e) {
</P><PRE> if (e.charCode == 0) { return }
 e.preventDefault()
 if (!this.cm.isReadOnly())
   { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0) }
</PRE><P>};
</P><P>ContentEditableInput.prototype.readOnlyChanged = function (val) {
</P><PRE> this.div.contentEditable = String(val != &quot;nocursor&quot;)
</PRE><P>};
</P><P>ContentEditableInput.prototype.onContextMenu = function () {};
ContentEditableInput.prototype.resetPosition = function () {};
</P><P>ContentEditableInput.prototype.needsContentAttribute = true
</P><P>function posToDOM(cm, pos) {
</P><PRE> var view = findViewForLine(cm, pos.line)
 if (!view || view.hidden) { return null }
 var line = getLine(cm.doc, pos.line)
 var info = mapFromLineView(view, line, pos.line)
</PRE><PRE> var order = getOrder(line), side = &quot;left&quot;
 if (order) {
   var partPos = getBidiPartAt(order, pos.ch)
   side = partPos % 2 ? &quot;right&quot; : &quot;left&quot;
 }
 var result = nodeAndOffsetInLineMap(info.map, pos.ch, side)
 result.offset = result.collapse == &quot;right&quot; ? result.end : result.start
 return result
</PRE><P>}
</P><P>function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }
</P><P>function domTextBetween(cm, from, to, fromLine, toLine) {
</P><PRE> var text = &quot;&quot;, closing = false, lineSep = cm.doc.lineSeparator()
 function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
 function walk(node) {
   if (node.nodeType == 1) {
     var cmText = node.getAttribute(&quot;cm-text&quot;)
     if (cmText != null) {
       if (cmText == &quot;&quot;) { text += node.textContent.replace(/\u200b/g, &quot;&quot;) }
       else { text += cmText }
       return
     }
     var markerID = node.getAttribute(&quot;cm-marker&quot;), range
     if (markerID) {
       var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID))
       if (found.length &amp;&amp; (range = found[0].find()))
         { text += getBetween(cm.doc, range.from, range.to).join(lineSep) }
       return
     }
     if (node.getAttribute(&quot;contenteditable&quot;) == &quot;false&quot;) { return }
     for (var i = 0; i &lt; node.childNodes.length; i++)
       { walk(node.childNodes[i]) }
     if (/^(pre|div|p)$/i.test(node.nodeName))
       { closing = true }
   } else if (node.nodeType == 3) {
     var val = node.nodeValue
     if (!val) { return }
     if (closing) {
       text += lineSep
       closing = false
     }
     text += val
   }
 }
 for (;;) {
   walk(from)
   if (from == to) { break }
   from = from.nextSibling
 }
 return text
</PRE><P>}
</P><P>function domToPos(cm, node, offset) {
</P><PRE> var lineNode
 if (node == cm.display.lineDiv) {
   lineNode = cm.display.lineDiv.childNodes[offset]
   if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
   node = null; offset = 0
 } else {
   for (lineNode = node;; lineNode = lineNode.parentNode) {
     if (!lineNode || lineNode == cm.display.lineDiv) { return null }
     if (lineNode.parentNode &amp;&amp; lineNode.parentNode == cm.display.lineDiv) { break }
   }
 }
 for (var i = 0; i &lt; cm.display.view.length; i++) {
   var lineView = cm.display.view[i]
   if (lineView.node == lineNode)
     { return locateNodeInLineView(lineView, node, offset) }
 }
</PRE><P>}
</P><P>function locateNodeInLineView(lineView, node, offset) {
</P><PRE> var wrapper = lineView.text.firstChild, bad = false
 if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
 if (node == wrapper) {
   bad = true
   node = wrapper.childNodes[offset]
   offset = 0
   if (!node) {
     var line = lineView.rest ? lst(lineView.rest) : lineView.line
     return badPos(Pos(lineNo(line), line.text.length), bad)
   }
 }
</PRE><PRE> var textNode = node.nodeType == 3 ? node : null, topNode = node
 if (!textNode &amp;&amp; node.childNodes.length == 1 &amp;&amp; node.firstChild.nodeType == 3) {
   textNode = node.firstChild
   if (offset) { offset = textNode.nodeValue.length }
 }
 while (topNode.parentNode != wrapper) { topNode = topNode.parentNode }
 var measure = lineView.measure, maps = measure.maps
</PRE><PRE> function find(textNode, topNode, offset) {
   for (var i = -1; i &lt; (maps ? maps.length : 0); i++) {
     var map = i &lt; 0 ? measure.map : maps[i]
     for (var j = 0; j &lt; map.length; j += 3) {
       var curNode = map[j + 2]
       if (curNode == textNode || curNode == topNode) {
         var line = lineNo(i &lt; 0 ? lineView.line : lineView.rest[i])
         var ch = map[j] + offset
         if (offset &lt; 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)] }
         return Pos(line, ch)
       }
     }
   }
 }
 var found = find(textNode, topNode, offset)
 if (found) { return badPos(found, bad) }
</PRE><PRE> // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
 for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
   found = find(after, after.firstChild, 0)
   if (found)
     { return badPos(Pos(found.line, found.ch - dist), bad) }
   else
     { dist += after.textContent.length }
 }
 for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
   found = find(before, before.firstChild, -1)
   if (found)
     { return badPos(Pos(found.line, found.ch + dist$1), bad) }
   else
     { dist$1 += before.textContent.length }
 }
</PRE><P>}
</P><P>// TEXTAREA INPUT STYLE
</P><P>var TextareaInput = function(cm) {
</P><PRE> this.cm = cm
 // See input.poll and input.reset
 this.prevInput = &quot;&quot;
</PRE><PRE> // Flag that indicates whether we expect input to appear real soon
 // now (after some event like 'keypress' or 'input') and are
 // polling intensively.
 this.pollingFast = false
 // Self-resetting timeout for the poller
 this.polling = new Delayed()
 // Tracks when input.reset has punted to just putting a short
 // string into the textarea instead of the full selection.
 this.inaccurateSelection = false
 // Used to work around IE issue with selection being forgotten when focus moves away from textarea
 this.hasSelection = false
 this.composing = null
</PRE><P>};
</P><P>TextareaInput.prototype.init = function (display) {
</P><PRE>   var this$1 = this;
</PRE><PRE> var input = this, cm = this.cm
</PRE><PRE> // Wraps and hides input textarea
 var div = this.wrapper = hiddenTextarea()
 // The semihidden textarea that is focused when the editor is
 // focused, and receives input.
 var te = this.textarea = div.firstChild
 display.wrapper.insertBefore(div, display.wrapper.firstChild)
</PRE><PRE> // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
 if (ios) { te.style.width = &quot;0px&quot; }
</PRE><PRE> on(te, &quot;input&quot;, function () {
   if (ie &amp;&amp; ie_version &gt;= 9 &amp;&amp; this$1.hasSelection) { this$1.hasSelection = null }
   input.poll()
 })
</PRE><PRE> on(te, &quot;paste&quot;, function (e) {
   if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
</PRE><PRE>   cm.state.pasteIncoming = true
   input.fastPoll()
 })
</PRE><PRE> function prepareCopyCut(e) {
   if (signalDOMEvent(cm, e)) { return }
   if (cm.somethingSelected()) {
     setLastCopied({lineWise: false, text: cm.getSelections()})
     if (input.inaccurateSelection) {
       input.prevInput = &quot;&quot;
       input.inaccurateSelection = false
       te.value = lastCopied.text.join(&quot;\n&quot;)
       selectInput(te)
     }
   } else if (!cm.options.lineWiseCopyCut) {
     return
   } else {
     var ranges = copyableRanges(cm)
     setLastCopied({lineWise: true, text: ranges.text})
     if (e.type == &quot;cut&quot;) {
       cm.setSelections(ranges.ranges, null, sel_dontScroll)
     } else {
       input.prevInput = &quot;&quot;
       te.value = ranges.text.join(&quot;\n&quot;)
       selectInput(te)
     }
   }
   if (e.type == &quot;cut&quot;) { cm.state.cutIncoming = true }
 }
 on(te, &quot;cut&quot;, prepareCopyCut)
 on(te, &quot;copy&quot;, prepareCopyCut)
</PRE><PRE> on(display.scroller, &quot;paste&quot;, function (e) {
   if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
   cm.state.pasteIncoming = true
   input.focus()
 })
</PRE><PRE> // Prevent normal selection in the editor (we handle our own)
 on(display.lineSpace, &quot;selectstart&quot;, function (e) {
   if (!eventInWidget(display, e)) { e_preventDefault(e) }
 })
</PRE><PRE> on(te, &quot;compositionstart&quot;, function () {
   var start = cm.getCursor(&quot;from&quot;)
   if (input.composing) { input.composing.range.clear() }
   input.composing = {
     start: start,
     range: cm.markText(start, cm.getCursor(&quot;to&quot;), {className: &quot;CodeMirror-composing&quot;})
   }
 })
 on(te, &quot;compositionend&quot;, function () {
   if (input.composing) {
     input.poll()
     input.composing.range.clear()
     input.composing = null
   }
 })
</PRE><P>};
</P><P>TextareaInput.prototype.prepareSelection = function () {
</P><PRE> // Redraw the selection and/or cursor
 var cm = this.cm, display = cm.display, doc = cm.doc
 var result = prepareSelection(cm)
</PRE><PRE> // Move the hidden textarea near the cursor to prevent scrolling artifacts
 if (cm.options.moveInputWithCursor) {
   var headPos = cursorCoords(cm, doc.sel.primary().head, &quot;div&quot;)
   var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect()
   result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                       headPos.top + lineOff.top - wrapOff.top))
   result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                        headPos.left + lineOff.left - wrapOff.left))
 }
</PRE><PRE> return result
</PRE><P>};
</P><P>TextareaInput.prototype.showSelection = function (drawn) {
</P><PRE> var cm = this.cm, display = cm.display
 removeChildrenAndAdd(display.cursorDiv, drawn.cursors)
 removeChildrenAndAdd(display.selectionDiv, drawn.selection)
 if (drawn.teTop != null) {
   this.wrapper.style.top = drawn.teTop + &quot;px&quot;
   this.wrapper.style.left = drawn.teLeft + &quot;px&quot;
 }
</PRE><P>};
</P><P>// Reset the input to correspond to the selection (or to be empty,
// when not typing and nothing is selected)
TextareaInput.prototype.reset = function (typing) {
</P><PRE> if (this.contextMenuPending) { return }
 var minimal, selected, cm = this.cm, doc = cm.doc
 if (cm.somethingSelected()) {
   this.prevInput = &quot;&quot;
   var range = doc.sel.primary()
   minimal = hasCopyEvent &amp;&amp;
     (range.to().line - range.from().line &gt; 100 || (selected = cm.getSelection()).length &gt; 1000)
   var content = minimal ? &quot;-&quot; : selected || cm.getSelection()
   this.textarea.value = content
   if (cm.state.focused) { selectInput(this.textarea) }
   if (ie &amp;&amp; ie_version &gt;= 9) { this.hasSelection = content }
 } else if (!typing) {
   this.prevInput = this.textarea.value = &quot;&quot;
   if (ie &amp;&amp; ie_version &gt;= 9) { this.hasSelection = null }
 }
 this.inaccurateSelection = minimal
</PRE><P>};
</P><P>TextareaInput.prototype.getField = function () { return this.textarea };
</P><P>TextareaInput.prototype.supportsTouch = function () { return false };
</P><P>TextareaInput.prototype.focus = function () {
</P><PRE> if (this.cm.options.readOnly != &quot;nocursor&quot; &amp;&amp; (!mobile || activeElt() != this.textarea)) {
   try { this.textarea.focus() }
   catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
 }
</PRE><P>};
</P><P>TextareaInput.prototype.blur = function () { this.textarea.blur() };
</P><P>TextareaInput.prototype.resetPosition = function () {
</P><PRE> this.wrapper.style.top = this.wrapper.style.left = 0
</PRE><P>};
</P><P>TextareaInput.prototype.receivedFocus = function () { this.slowPoll() };
</P><P>// Poll for input changes, using the normal rate of polling. This
// runs as long as the editor is focused.
TextareaInput.prototype.slowPoll = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> if (this.pollingFast) { return }
 this.polling.set(this.cm.options.pollInterval, function () {
   this$1.poll()
   if (this$1.cm.state.focused) { this$1.slowPoll() }
 })
</PRE><P>};
</P><P>// When an event has just come in that is likely to add or change
// something in the input textarea, we poll faster, to ensure that
// the change appears on the screen quickly.
TextareaInput.prototype.fastPoll = function () {
</P><PRE> var missed = false, input = this
 input.pollingFast = true
 function p() {
   var changed = input.poll()
   if (!changed &amp;&amp; !missed) {missed = true; input.polling.set(60, p)}
   else {input.pollingFast = false; input.slowPoll()}
 }
 input.polling.set(20, p)
</PRE><P>};
</P><P>// Read input from the textarea, and update the document to match.
// When something is selected, it is present in the textarea, and
// selected (unless it is huge, in which case a placeholder is
// used). When nothing is selected, the cursor sits after previously
// seen text (can be empty), which is stored in prevInput (we must
// not reset the textarea when typing, because that breaks IME).
TextareaInput.prototype.poll = function () {
</P><PRE>   var this$1 = this;
</PRE><PRE> var cm = this.cm, input = this.textarea, prevInput = this.prevInput
 // Since this is called a *lot*, try to bail out as cheaply as
 // possible when it is clear that nothing happened. hasSelection
 // will be the case when there is a lot of text in the textarea,
 // in which case reading its value would be expensive.
 if (this.contextMenuPending || !cm.state.focused ||
     (hasSelection(input) &amp;&amp; !prevInput &amp;&amp; !this.composing) ||
     cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
   { return false }
</PRE><PRE> var text = input.value
 // If nothing changed, bail.
 if (text == prevInput &amp;&amp; !cm.somethingSelected()) { return false }
 // Work around nonsensical selection resetting in IE9/10, and
 // inexplicable appearance of private area unicode characters on
 // some key combos in Mac (#2689).
 if (ie &amp;&amp; ie_version &gt;= 9 &amp;&amp; this.hasSelection === text ||
     mac &amp;&amp; /[\uf700-\uf7ff]/.test(text)) {
   cm.display.input.reset()
   return false
 }
</PRE><PRE> if (cm.doc.sel == cm.display.selForContextMenu) {
   var first = text.charCodeAt(0)
   if (first == 0x200b &amp;&amp; !prevInput) { prevInput = &quot;\u200b&quot; }
   if (first == 0x21da) { this.reset(); return this.cm.execCommand(&quot;undo&quot;) }
 }
 // Find the part of the input that is actually new
 var same = 0, l = Math.min(prevInput.length, text.length)
 while (same &lt; l &amp;&amp; prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same }
</PRE><PRE> runInOp(cm, function () {
   applyTextInput(cm, text.slice(same), prevInput.length - same,
                  null, this$1.composing ? &quot;*compose&quot; : null)
</PRE><PRE>   // Don't leave long text in the textarea, since it makes further polling slow
   if (text.length &gt; 1000 || text.indexOf(&quot;\n&quot;) &gt; -1) { input.value = this$1.prevInput = &quot;&quot; }
   else { this$1.prevInput = text }
</PRE><PRE>   if (this$1.composing) {
     this$1.composing.range.clear()
     this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(&quot;to&quot;),
                                        {className: &quot;CodeMirror-composing&quot;})
   }
 })
 return true
</PRE><P>};
</P><P>TextareaInput.prototype.ensurePolled = function () {
</P><PRE> if (this.pollingFast &amp;&amp; this.poll()) { this.pollingFast = false }
</PRE><P>};
</P><P>TextareaInput.prototype.onKeyPress = function () {
</P><PRE> if (ie &amp;&amp; ie_version &gt;= 9) { this.hasSelection = null }
 this.fastPoll()
</PRE><P>};
</P><P>TextareaInput.prototype.onContextMenu = function (e) {
</P><PRE> var input = this, cm = input.cm, display = cm.display, te = input.textarea
 var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop
 if (!pos || presto) { return } // Opera is difficult.
</PRE><PRE> // Reset the current text selection only if the click is done outside of the selection
 // and 'resetSelectionOnContextMenu' option is true.
 var reset = cm.options.resetSelectionOnContextMenu
 if (reset &amp;&amp; cm.doc.sel.contains(pos) == -1)
   { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll) }
</PRE><PRE> var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText
 input.wrapper.style.cssText = &quot;position: absolute&quot;
 var wrapperBox = input.wrapper.getBoundingClientRect()
 te.style.cssText = &quot;position: absolute; width: 30px; height: 30px;\n      top: &quot; + (e.clientY - wrapperBox.top - 5) + &quot;px; left: &quot; + (e.clientX - wrapperBox.left - 5) + &quot;px;\n      z-index: 1000; background: &quot; + (ie ? &quot;rgba(255, 255, 255, .05)&quot; : &quot;transparent&quot;) + &quot;;\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);&quot;
 var oldScrollY
 if (webkit) { oldScrollY = window.scrollY } // Work around Chrome issue (#2712)
 display.input.focus()
 if (webkit) { window.scrollTo(null, oldScrollY) }
 display.input.reset()
 // Adds &quot;Select all&quot; to context menu in FF
 if (!cm.somethingSelected()) { te.value = input.prevInput = &quot; &quot; }
 input.contextMenuPending = true
 display.selForContextMenu = cm.doc.sel
 clearTimeout(display.detectingSelectAll)
</PRE><PRE> // Select-all will be greyed out if there's nothing to select, so
 // this adds a zero-width space so that we can later check whether
 // it got selected.
 function prepareSelectAllHack() {
   if (te.selectionStart != null) {
     var selected = cm.somethingSelected()
     var extval = &quot;\u200b&quot; + (selected ? te.value : &quot;&quot;)
     te.value = &quot;\u21da&quot; // Used to catch context-menu undo
     te.value = extval
     input.prevInput = selected ? &quot;&quot; : &quot;\u200b&quot;
     te.selectionStart = 1; te.selectionEnd = extval.length
     // Re-set this, in case some other handler touched the
     // selection in the meantime.
     display.selForContextMenu = cm.doc.sel
   }
 }
 function rehide() {
   input.contextMenuPending = false
   input.wrapper.style.cssText = oldWrapperCSS
   te.style.cssText = oldCSS
   if (ie &amp;&amp; ie_version &lt; 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos) }
</PRE><PRE>   // Try to detect the user choosing select-all
   if (te.selectionStart != null) {
     if (!ie || (ie &amp;&amp; ie_version &lt; 9)) { prepareSelectAllHack() }
     var i = 0, poll = function () {
       if (display.selForContextMenu == cm.doc.sel &amp;&amp; te.selectionStart == 0 &amp;&amp;
           te.selectionEnd &gt; 0 &amp;&amp; input.prevInput == &quot;\u200b&quot;) {
         operation(cm, selectAll)(cm)
       } else if (i++ &lt; 10) {
         display.detectingSelectAll = setTimeout(poll, 500)
       } else {
         display.selForContextMenu = null
         display.input.reset()
       }
     }
     display.detectingSelectAll = setTimeout(poll, 200)
   }
 }
</PRE><PRE> if (ie &amp;&amp; ie_version &gt;= 9) { prepareSelectAllHack() }
 if (captureRightClick) {
   e_stop(e)
   var mouseup = function () {
     off(window, &quot;mouseup&quot;, mouseup)
     setTimeout(rehide, 20)
   }
   on(window, &quot;mouseup&quot;, mouseup)
 } else {
   setTimeout(rehide, 50)
 }
</PRE><P>};
</P><P>TextareaInput.prototype.readOnlyChanged = function (val) {
</P><PRE> if (!val) { this.reset() }
</PRE><P>};
</P><P>TextareaInput.prototype.setUneditable = function () {};
</P><P>TextareaInput.prototype.needsContentAttribute = false
</P><P>function fromTextArea(textarea, options) {
</P><PRE> options = options ? copyObj(options) : {}
 options.value = textarea.value
 if (!options.tabindex &amp;&amp; textarea.tabIndex)
   { options.tabindex = textarea.tabIndex }
 if (!options.placeholder &amp;&amp; textarea.placeholder)
   { options.placeholder = textarea.placeholder }
 // Set autofocus to true if this textarea is focused, or if it has
 // autofocus and no other element is focused.
 if (options.autofocus == null) {
   var hasFocus = activeElt()
   options.autofocus = hasFocus == textarea ||
     textarea.getAttribute(&quot;autofocus&quot;) != null &amp;&amp; hasFocus == document.body
 }
</PRE><PRE> function save() {textarea.value = cm.getValue()}
</PRE><PRE> var realSubmit
 if (textarea.form) {
   on(textarea.form, &quot;submit&quot;, save)
   // Deplorable hack to make the submit method do the right thing.
   if (!options.leaveSubmitMethodAlone) {
     var form = textarea.form
     realSubmit = form.submit
     try {
       var wrappedSubmit = form.submit = function () {
         save()
         form.submit = realSubmit
         form.submit()
         form.submit = wrappedSubmit
       }
     } catch(e) {}
   }
 }
</PRE><PRE> options.finishInit = function (cm) {
   cm.save = save
   cm.getTextArea = function () { return textarea; }
   cm.toTextArea = function () {
     cm.toTextArea = isNaN // Prevent this from being ran twice
     save()
     textarea.parentNode.removeChild(cm.getWrapperElement())
     textarea.style.display = &quot;&quot;
     if (textarea.form) {
       off(textarea.form, &quot;submit&quot;, save)
       if (typeof textarea.form.submit == &quot;function&quot;)
         { textarea.form.submit = realSubmit }
     }
   }
 }
</PRE><PRE> textarea.style.display = &quot;none&quot;
 var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
   options)
 return cm
</PRE><P>}
</P><P>function addLegacyProps(CodeMirror) {
</P><PRE> CodeMirror.off = off
 CodeMirror.on = on
 CodeMirror.wheelEventPixels = wheelEventPixels
 CodeMirror.Doc = Doc
 CodeMirror.splitLines = splitLinesAuto
 CodeMirror.countColumn = countColumn
 CodeMirror.findColumn = findColumn
 CodeMirror.isWordChar = isWordCharBasic
 CodeMirror.Pass = Pass
 CodeMirror.signal = signal
 CodeMirror.Line = Line
 CodeMirror.changeEnd = changeEnd
 CodeMirror.scrollbarModel = scrollbarModel
 CodeMirror.Pos = Pos
 CodeMirror.cmpPos = cmp
 CodeMirror.modes = modes
 CodeMirror.mimeModes = mimeModes
 CodeMirror.resolveMode = resolveMode
 CodeMirror.getMode = getMode
 CodeMirror.modeExtensions = modeExtensions
 CodeMirror.extendMode = extendMode
 CodeMirror.copyState = copyState
 CodeMirror.startState = startState
 CodeMirror.innerMode = innerMode
 CodeMirror.commands = commands
 CodeMirror.keyMap = keyMap
 CodeMirror.keyName = keyName
 CodeMirror.isModifierKey = isModifierKey
 CodeMirror.lookupKey = lookupKey
 CodeMirror.normalizeKeyMap = normalizeKeyMap
 CodeMirror.StringStream = StringStream
 CodeMirror.SharedTextMarker = SharedTextMarker
 CodeMirror.TextMarker = TextMarker
 CodeMirror.LineWidget = LineWidget
 CodeMirror.e_preventDefault = e_preventDefault
 CodeMirror.e_stopPropagation = e_stopPropagation
 CodeMirror.e_stop = e_stop
 CodeMirror.addClass = addClass
 CodeMirror.contains = contains
 CodeMirror.rmClass = rmClass
 CodeMirror.keyNames = keyNames
</PRE><P>}
</P><P>// EDITOR CONSTRUCTOR
</P><P>defineOptions(CodeMirror)
</P><P>addEditorMethods(CodeMirror)
</P><P>// Set up methods on CodeMirror's prototype to redirect to the editor's document.
var dontDelegate = &quot;iter insert remove copy getEditor constructor&quot;.split(&quot; &quot;)
for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) &amp;&amp;indexOf(dontDelegate, prop) &lt; 0)
</P><PRE> { CodeMirror.prototype[prop] = (function(method) {
   return function() {return method.apply(this.doc, arguments)}
 })(Doc.prototype[prop]) } }
</PRE><P>eventMixin(Doc)
</P><P>// INPUT HANDLING
</P><P>CodeMirror.inputStyles = {&quot;textarea&quot;: TextareaInput, &quot;contenteditable&quot;: ContentEditableInput}
</P><P>// MODE DEFINITION AND QUERYING
</P><P>// Extra arguments are stored as the mode's dependencies, which is
// used by (legacy) mechanisms like loadmode.js to automatically
// load a mode. (Preferred mechanism is the require/define calls.)
CodeMirror.defineMode = function(name/*, mode, …*/) {
</P><PRE> if (!CodeMirror.defaults.mode &amp;&amp; name != &quot;null&quot;) { CodeMirror.defaults.mode = name }
 defineMode.apply(this, arguments)
</PRE><P>}
</P><P>CodeMirror.defineMIME = defineMIME
</P><P>// Minimal default mode.
CodeMirror.defineMode(&quot;null&quot;, function () { return ({token: function (stream) { return stream.skipToEnd(); }}); })
CodeMirror.defineMIME(&quot;text/plain&quot;, &quot;null&quot;)
</P><P>// EXTENSIONS
</P><P>CodeMirror.defineExtension = function (name, func) {
</P><PRE> CodeMirror.prototype[name] = func
</PRE><P>}
CodeMirror.defineDocExtension = function (name, func) {
</P><PRE> Doc.prototype[name] = func
</PRE><P>}
</P><P>CodeMirror.fromTextArea = fromTextArea
</P><P>addLegacyProps(CodeMirror)
</P><P>CodeMirror.version = &quot;5.24.2&quot;
</P><P>return CodeMirror;
</P><P>})));&lt;/script&gt;</P><PRE>&lt;script&gt;// CodeMirror, copyright (c) by Marijn Haverbeke and others
</PRE><P>// Distributed under an MIT license: <A rel="nofollow" class="external free" href="http://codemirror.net/LICENSE">http://codemirror.net/LICENSE</A></P><P>// Open simple dialogs on top of an editor. Relies on dialog.css.
</P><P>(function(mod) {
</P><PRE> if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
   mod(require(&quot;../../lib/codemirror&quot;));
 else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
   define([&quot;../../lib/codemirror&quot;], mod);
 else // Plain browser env
   mod(CodeMirror);
</PRE><P>})(function(CodeMirror) {
</P><PRE> function dialogDiv(cm, template, bottom) {
   var wrap = cm.getWrapperElement();
   var dialog;
   dialog = wrap.appendChild(document.createElement(&quot;div&quot;));
   if (bottom)
     dialog.className = &quot;CodeMirror-dialog CodeMirror-dialog-bottom&quot;;
   else
     dialog.className = &quot;CodeMirror-dialog CodeMirror-dialog-top&quot;;
</PRE><PRE>   if (typeof template == &quot;string&quot;) {
     dialog.innerHTML = template;
   } else { // Assuming it's a detached DOM element.
     dialog.appendChild(template);
   }
   return dialog;
 }
</PRE><PRE> function closeNotification(cm, newVal) {
   if (cm.state.currentNotificationClose)
     cm.state.currentNotificationClose();
   cm.state.currentNotificationClose = newVal;
 }
</PRE><PRE> CodeMirror.defineExtension(&quot;openDialog&quot;, function(template, callback, options) {
   if (!options) options = {};
</PRE><PRE>   closeNotification(this, null);
</PRE><PRE>   var dialog = dialogDiv(this, template, options.bottom);
   var closed = false, me = this;
   function close(newVal) {
     if (typeof newVal == 'string') {
       inp.value = newVal;
     } else {
       if (closed) return;
       closed = true;
       dialog.parentNode.removeChild(dialog);
       me.focus();
</PRE><PRE>       if (options.onClose) options.onClose(dialog);
     }
   }
</PRE><PRE>   var inp = dialog.getElementsByTagName(&quot;input&quot;)[0], button;
   if (inp) {
     inp.focus();
</PRE><PRE>     if (options.value) {
       inp.value = options.value;
       if (options.selectValueOnOpen !== false) {
         inp.select();
       }
     }
</PRE><PRE>     if (options.onInput)
       CodeMirror.on(inp, &quot;input&quot;, function(e) { options.onInput(e, inp.value, close);});
     if (options.onKeyUp)
       CodeMirror.on(inp, &quot;keyup&quot;, function(e) {options.onKeyUp(e, inp.value, close);});
</PRE><PRE>     CodeMirror.on(inp, &quot;keydown&quot;, function(e) {
       if (options &amp;&amp; options.onKeyDown &amp;&amp; options.onKeyDown(e, inp.value, close)) { return; }
       if (e.keyCode == 27 || (options.closeOnEnter !== false &amp;&amp; e.keyCode == 13)) {
         inp.blur();
         CodeMirror.e_stop(e);
         close();
       }
       if (e.keyCode == 13) callback(inp.value, e);
     });
</PRE><PRE>     if (options.closeOnBlur !== false) CodeMirror.on(inp, &quot;blur&quot;, close);
   } else if (button = dialog.getElementsByTagName(&quot;button&quot;)[0]) {
     CodeMirror.on(button, &quot;click&quot;, function() {
       close();
       me.focus();
     });
</PRE><PRE>     if (options.closeOnBlur !== false) CodeMirror.on(button, &quot;blur&quot;, close);
</PRE><PRE>     button.focus();
   }
   return close;
 });
</PRE><PRE> CodeMirror.defineExtension(&quot;openConfirm&quot;, function(template, callbacks, options) {
   closeNotification(this, null);
   var dialog = dialogDiv(this, template, options &amp;&amp; options.bottom);
   var buttons = dialog.getElementsByTagName(&quot;button&quot;);
   var closed = false, me = this, blurring = 1;
   function close() {
     if (closed) return;
     closed = true;
     dialog.parentNode.removeChild(dialog);
     me.focus();
   }
   buttons[0].focus();
   for (var i = 0; i &lt; buttons.length; ++i) {
     var b = buttons[i];
     (function(callback) {
       CodeMirror.on(b, &quot;click&quot;, function(e) {
         CodeMirror.e_preventDefault(e);
         close();
         if (callback) callback(me);
       });
     })(callbacks[i]);
     CodeMirror.on(b, &quot;blur&quot;, function() {
       --blurring;
       setTimeout(function() { if (blurring &lt;= 0) close(); }, 200);
     });
     CodeMirror.on(b, &quot;focus&quot;, function() { ++blurring; });
   }
 });
</PRE><PRE> /*
  * openNotification
  * Opens a notification, that can be closed with an optional timer
  * (default 5000ms timer) and always closes on click.
  *
  * If a notification is opened while another is opened, it will close the
  * currently opened one and open the new one immediately.
  */
 CodeMirror.defineExtension(&quot;openNotification&quot;, function(template, options) {
   closeNotification(this, close);
   var dialog = dialogDiv(this, template, options &amp;&amp; options.bottom);
   var closed = false, doneTimer;
   var duration = options &amp;&amp; typeof options.duration !== &quot;undefined&quot; ? options.duration : 5000;
</PRE><PRE>   function close() {
     if (closed) return;
     closed = true;
     clearTimeout(doneTimer);
     dialog.parentNode.removeChild(dialog);
   }
</PRE><PRE>   CodeMirror.on(dialog, 'click', function(e) {
     CodeMirror.e_preventDefault(e);
     close();
   });
</PRE><PRE>   if (duration)
     doneTimer = setTimeout(close, duration);
</PRE><PRE>   return close;
 });
</PRE><P>});
&lt;/script&gt;</P><PRE>&lt;script&gt;// CodeMirror, copyright (c) by Marijn Haverbeke and others
</PRE><P>// Distributed under an MIT license: <A rel="nofollow" class="external free" href="http://codemirror.net/LICENSE">http://codemirror.net/LICENSE</A></P><P>(function(mod) {
</P><PRE> if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
   mod(require(&quot;../../lib/codemirror&quot;));
 else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
   define([&quot;../../lib/codemirror&quot;], mod);
 else // Plain browser env
   mod(CodeMirror);
</PRE><P>})(function(CodeMirror) {
</P><PRE> &quot;use strict&quot;;
</PRE><PRE> CodeMirror.defineSimpleMode = function(name, states) {
   CodeMirror.defineMode(name, function(config) {
     return CodeMirror.simpleMode(config, states);
   });
 };
</PRE><PRE> CodeMirror.simpleMode = function(config, states) {
   ensureState(states, &quot;start&quot;);
   var states_ = {}, meta = states.meta || {}, hasIndentation = false;
   for (var state in states) if (state != meta &amp;&amp; states.hasOwnProperty(state)) {
     var list = states_[state] = [], orig = states[state];
     for (var i = 0; i &lt; orig.length; i++) {
       var data = orig[i];
       list.push(new Rule(data, states));
       if (data.indent || data.dedent) hasIndentation = true;
     }
   }
   var mode = {
     startState: function() {
       return {state: &quot;start&quot;, pending: null,
               local: null, localState: null,
               indent: hasIndentation ? [] : null};
     },
     copyState: function(state) {
       var s = {state: state.state, pending: state.pending,
                local: state.local, localState: null,
                indent: state.indent &amp;&amp; state.indent.slice(0)};
       if (state.localState)
         s.localState = CodeMirror.copyState(state.local.mode, state.localState);
       if (state.stack)
         s.stack = state.stack.slice(0);
       for (var pers = state.persistentStates; pers; pers = pers.next)
         s.persistentStates = {mode: pers.mode,
                               spec: pers.spec,
                               state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),
                               next: s.persistentStates};
       return s;
     },
     token: tokenFunction(states_, config),
     innerMode: function(state) { return state.local &amp;&amp; {mode: state.local.mode, state: state.localState}; },
     indent: indentFunction(states_, meta)
   };
   if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))
     mode[prop] = meta[prop];
   return mode;
 };
</PRE><PRE> function ensureState(states, name) {
   if (!states.hasOwnProperty(name))
     throw new Error(&quot;Undefined state &quot; + name + &quot; in simple mode&quot;);
 }
</PRE><PRE> function toRegex(val, caret) {
   if (!val) return /(?:)/;
   var flags = &quot;&quot;;
   if (val instanceof RegExp) {
     if (val.ignoreCase) flags = &quot;i&quot;;
     val = val.source;
   } else {
     val = String(val);
   }
   return new RegExp((caret === false ? &quot;&quot; : &quot;^&quot;) + &quot;(?:&quot; + val + &quot;)&quot;, flags);
 }
</PRE><PRE> function asToken(val) {
   if (!val) return null;
   if (typeof val == &quot;string&quot;) return val.replace(/\./g, &quot; &quot;);
   var result = [];
   for (var i = 0; i &lt; val.length; i++)
     result.push(val[i] &amp;&amp; val[i].replace(/\./g, &quot; &quot;));
   return result;
 }
</PRE><PRE> function Rule(data, states) {
   if (data.next || data.push) ensureState(states, data.next || data.push);
   this.regex = toRegex(data.regex);
   this.token = asToken(data.token);
   this.data = data;
 }
</PRE><PRE> function tokenFunction(states, config) {
   return function(stream, state) {
     if (state.pending) {
       var pend = state.pending.shift();
       if (state.pending.length == 0) state.pending = null;
       stream.pos += pend.text.length;
       return pend.token;
     }
</PRE><PRE>     if (state.local) {
       if (state.local.end &amp;&amp; stream.match(state.local.end)) {
         var tok = state.local.endToken || null;
         state.local = state.localState = null;
         return tok;
       } else {
         var tok = state.local.mode.token(stream, state.localState), m;
         if (state.local.endScan &amp;&amp; (m = state.local.endScan.exec(stream.current())))
           stream.pos = stream.start + m.index;
         return tok;
       }
     }
</PRE><PRE>     var curState = states[state.state];
     for (var i = 0; i &lt; curState.length; i++) {
       var rule = curState[i];
       var matches = (!rule.data.sol || stream.sol()) &amp;&amp; stream.match(rule.regex);
       if (matches) {
         if (rule.data.next) {
           state.state = rule.data.next;
         } else if (rule.data.push) {
           (state.stack || (state.stack = [])).push(state.state);
           state.state = rule.data.push;
         } else if (rule.data.pop &amp;&amp; state.stack &amp;&amp; state.stack.length) {
           state.state = state.stack.pop();
         }
</PRE><PRE>         if (rule.data.mode)
           enterLocalMode(config, state, rule.data.mode, rule.token);
         if (rule.data.indent)
           state.indent.push(stream.indentation() + config.indentUnit);
         if (rule.data.dedent)
           state.indent.pop();
         if (matches.length &gt; 2) {
           state.pending = [];
           for (var j = 2; j &lt; matches.length; j++)
             if (matches[j])
               state.pending.push({text: matches[j], token: rule.token[j - 1]});
           stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
           return rule.token[0];
         } else if (rule.token &amp;&amp; rule.token.join) {
           return rule.token[0];
         } else {
           return rule.token;
         }
       }
     }
     stream.next();
     return null;
   };
 }
</PRE><PRE> function cmp(a, b) {
   if (a === b) return true;
   if (!a || typeof a != &quot;object&quot; || !b || typeof b != &quot;object&quot;) return false;
   var props = 0;
   for (var prop in a) if (a.hasOwnProperty(prop)) {
     if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;
     props++;
   }
   for (var prop in b) if (b.hasOwnProperty(prop)) props--;
   return props == 0;
 }
</PRE><PRE> function enterLocalMode(config, state, spec, token) {
   var pers;
   if (spec.persistent) for (var p = state.persistentStates; p &amp;&amp; !pers; p = p.next)
     if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;
   var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec);
   var lState = pers ? pers.state : CodeMirror.startState(mode);
   if (spec.persistent &amp;&amp; !pers)
     state.persistentStates = {mode: mode, spec: spec.spec, state: lState, next: state.persistentStates};
</PRE><PRE>   state.localState = lState;
   state.local = {mode: mode,
                  end: spec.end &amp;&amp; toRegex(spec.end),
                  endScan: spec.end &amp;&amp; spec.forceEnd !== false &amp;&amp; toRegex(spec.end, false),
                  endToken: token &amp;&amp; token.join ? token[token.length - 1] : token};
 }
</PRE><PRE> function indexOf(val, arr) {
   for (var i = 0; i &lt; arr.length; i++) if (arr[i] === val) return true;
 }
</PRE><PRE> function indentFunction(states, meta) {
   return function(state, textAfter, line) {
     if (state.local &amp;&amp; state.local.mode.indent)
       return state.local.mode.indent(state.localState, textAfter, line);
     if (state.indent == null || state.local || meta.dontIndentStates &amp;&amp; indexOf(state.state, meta.dontIndentStates) &gt; -1)
       return CodeMirror.Pass;
</PRE><PRE>     var pos = state.indent.length - 1, rules = states[state.state];
     scan: for (;;) {
       for (var i = 0; i &lt; rules.length; i++) {
         var rule = rules[i];
         if (rule.data.dedent &amp;&amp; rule.data.dedentIfLineStart !== false) {
           var m = rule.regex.exec(textAfter);
           if (m &amp;&amp; m[0]) {
             pos--;
             if (rule.next || rule.push) rules = states[rule.next || rule.push];
             textAfter = textAfter.slice(m[0].length);
             continue scan;
           }
         }
       }
       break;
     }
     return pos &lt; 0 ? 0 : state.indent[pos];
   };
 }
</PRE><P>});
&lt;/script&gt;</P><PRE>&lt;script&gt;// CodeMirror, copyright (c) by Marijn Haverbeke and others
</PRE><P>// Distributed under an MIT license: <A rel="nofollow" class="external free" href="http://codemirror.net/LICENSE">http://codemirror.net/LICENSE</A></P><P>(function(mod) {
</P><PRE> if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
   mod(require(&quot;../../lib/codemirror&quot;));
 else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
   define([&quot;../../lib/codemirror&quot;], mod);
 else // Plain browser env
   mod(CodeMirror);
</PRE><P>})(function(CodeMirror) {
</P><PRE> &quot;use strict&quot;;
 var Pos = CodeMirror.Pos;
</PRE><PRE> function SearchCursor(doc, query, pos, caseFold) {
   this.atOccurrence = false; this.doc = doc;
   if (caseFold == null &amp;&amp; typeof query == &quot;string&quot;) caseFold = false;
</PRE><PRE>   pos = pos ? doc.clipPos(pos) : Pos(0, 0);
   this.pos = {from: pos, to: pos};
</PRE><PRE>   // The matches method is filled in based on the type of query.
   // It takes a position and a direction, and returns an object
   // describing the next occurrence of the query, or null if no
   // more matches were found.
   if (typeof query != &quot;string&quot;) { // Regexp match
     if (!query.global) query = new RegExp(query.source, query.ignoreCase ? &quot;ig&quot; : &quot;g&quot;);
     this.matches = function(reverse, pos) {
       if (reverse) {
         query.lastIndex = 0;
         var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;
         for (;;) {
           query.lastIndex = cutOff;
           var newMatch = query.exec(line);
           if (!newMatch) break;
           match = newMatch;
           start = match.index;
           cutOff = match.index + (match[0].length || 1);
           if (cutOff == line.length) break;
         }
         var matchLen = (match &amp;&amp; match[0].length) || 0;
         if (!matchLen) {
           if (start == 0 &amp;&amp; line.length == 0) {match = undefined;}
           else if (start != doc.getLine(pos.line).length) {
             matchLen++;
           }
         }
       } else {
         query.lastIndex = pos.ch;
         var line = doc.getLine(pos.line), match = query.exec(line);
         var matchLen = (match &amp;&amp; match[0].length) || 0;
         var start = match &amp;&amp; match.index;
         if (start + matchLen != line.length &amp;&amp; !matchLen) matchLen = 1;
       }
       if (match &amp;&amp; matchLen)
         return {from: Pos(pos.line, start),
                 to: Pos(pos.line, start + matchLen),
                 match: match};
     };
   } else { // String query
     var origQuery = query;
     if (caseFold) query = query.toLowerCase();
     var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};
     var target = query.split(&quot;\n&quot;);
     // Different methods for single-line and multi-line queries
     if (target.length == 1) {
       if (!query.length) {
         // Empty string would match anything and never progress, so
         // we define it to match nothing instead.
         this.matches = function() {};
       } else {
         this.matches = function(reverse, pos) {
           if (reverse) {
             var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);
             var match = line.lastIndexOf(query);
             if (match &gt; -1) {
               match = adjustPos(orig, line, match);
               return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
             }
            } else {
              var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);
              var match = line.indexOf(query);
              if (match &gt; -1) {
                match = adjustPos(orig, line, match) + pos.ch;
                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
              }
           }
         };
       }
     } else {
       var origTarget = origQuery.split(&quot;\n&quot;);
       this.matches = function(reverse, pos) {
         var last = target.length - 1;
         if (reverse) {
           if (pos.line - (target.length - 1) &lt; doc.firstLine()) return;
           if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;
           var to = Pos(pos.line, origTarget[last].length);
           for (var ln = pos.line - 1, i = last - 1; i &gt;= 1; --i, --ln)
             if (target[i] != fold(doc.getLine(ln))) return;
           var line = doc.getLine(ln), cut = line.length - origTarget[0].length;
           if (fold(line.slice(cut)) != target[0]) return;
           return {from: Pos(ln, cut), to: to};
         } else {
           if (pos.line + (target.length - 1) &gt; doc.lastLine()) return;
           var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;
           if (fold(line.slice(cut)) != target[0]) return;
           var from = Pos(pos.line, cut);
           for (var ln = pos.line + 1, i = 1; i &lt; last; ++i, ++ln)
             if (target[i] != fold(doc.getLine(ln))) return;
           if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;
           return {from: from, to: Pos(ln, origTarget[last].length)};
         }
       };
     }
   }
 }
</PRE><PRE> SearchCursor.prototype = {
   findNext: function() {return this.find(false);},
   findPrevious: function() {return this.find(true);},
</PRE><PRE>   find: function(reverse) {
     var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
     function savePosAndFail(line) {
       var pos = Pos(line, 0);
       self.pos = {from: pos, to: pos};
       self.atOccurrence = false;
       return false;
     }
</PRE><PRE>     for (;;) {
       if (this.pos = this.matches(reverse, pos)) {
         this.atOccurrence = true;
         return this.pos.match || true;
       }
       if (reverse) {
         if (!pos.line) return savePosAndFail(0);
         pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);
       }
       else {
         var maxLine = this.doc.lineCount();
         if (pos.line == maxLine - 1) return savePosAndFail(maxLine);
         pos = Pos(pos.line + 1, 0);
       }
     }
   },
</PRE><PRE>   from: function() {if (this.atOccurrence) return this.pos.from;},
   to: function() {if (this.atOccurrence) return this.pos.to;},
</PRE><PRE>   replace: function(newText, origin) {
     if (!this.atOccurrence) return;
     var lines = CodeMirror.splitLines(newText);
     this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
     this.pos.to = Pos(this.pos.from.line + lines.length - 1,
                       lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
   }
 };
</PRE><PRE> // Maps a position in a case-folded line back to a position in the original line
 // (compensating for codepoints increasing in number during folding)
 function adjustPos(orig, folded, pos) {
   if (orig.length == folded.length) return pos;
   for (var pos1 = Math.min(pos, orig.length);;) {
     var len1 = orig.slice(0, pos1).toLowerCase().length;
     if (len1 &lt; pos) ++pos1;
     else if (len1 &gt; pos) --pos1;
     else return pos1;
   }
 }
</PRE><PRE> CodeMirror.defineExtension(&quot;getSearchCursor&quot;, function(query, pos, caseFold) {
   return new SearchCursor(this.doc, query, pos, caseFold);
 });
 CodeMirror.defineDocExtension(&quot;getSearchCursor&quot;, function(query, pos, caseFold) {
   return new SearchCursor(this, query, pos, caseFold);
 });
</PRE><PRE> CodeMirror.defineExtension(&quot;selectMatches&quot;, function(query, caseFold) {
   var ranges = [];
   var cur = this.getSearchCursor(query, this.getCursor(&quot;from&quot;), caseFold);
   while (cur.findNext()) {
     if (CodeMirror.cmpPos(cur.to(), this.getCursor(&quot;to&quot;)) &gt; 0) break;
     ranges.push({anchor: cur.from(), head: cur.to()});
   }
   if (ranges.length)
     this.setSelections(ranges, 0);
 });
</PRE><P>});
&lt;/script&gt;</P><PRE>&lt;script&gt;// CodeMirror, copyright (c) by Marijn Haverbeke and others
</PRE><P>// Distributed under an MIT license: <A rel="nofollow" class="external free" href="http://codemirror.net/LICENSE">http://codemirror.net/LICENSE</A></P><P>// Define search commands. Depends on dialog.js or another
// implementation of the openDialog method.
</P><P>// Replace works a little oddly -- it will do the replace on the next
// Ctrl-G (or whatever is bound to findNext) press. You prevent a
// replace by making sure the match is no longer selected when hitting
// Ctrl-G.
</P><P>(function(mod) {
</P><PRE> if (typeof exports == &quot;object&quot; &amp;&amp; typeof module == &quot;object&quot;) // CommonJS
   mod(require(&quot;../../lib/codemirror&quot;), require(&quot;./searchcursor&quot;), require(&quot;../dialog/dialog&quot;));
 else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) // AMD
   define([&quot;../../lib/codemirror&quot;, &quot;./searchcursor&quot;, &quot;../dialog/dialog&quot;], mod);
 else // Plain browser env
   mod(CodeMirror);
</PRE><P>})(function(CodeMirror) {
</P><PRE> &quot;use strict&quot;;
</PRE><PRE> function searchOverlay(query, caseInsensitive) {
   if (typeof query == &quot;string&quot;)
     query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, &quot;\\$&amp;&quot;), caseInsensitive ? &quot;gi&quot; : &quot;g&quot;);
   else if (!query.global)
     query = new RegExp(query.source, query.ignoreCase ? &quot;gi&quot; : &quot;g&quot;);
</PRE><PRE>   return {token: function(stream) {
     query.lastIndex = stream.pos;
     var match = query.exec(stream.string);
     if (match &amp;&amp; match.index == stream.pos) {
       stream.pos += match[0].length || 1;
       return &quot;searching&quot;;
     } else if (match) {
       stream.pos = match.index;
     } else {
       stream.skipToEnd();
     }
   }};
 }
</PRE><PRE> function SearchState() {
   this.posFrom = this.posTo = this.lastQuery = this.query = null;
   this.overlay = null;
 }
</PRE><PRE> function getSearchState(cm) {
   return cm.state.search || (cm.state.search = new SearchState());
 }
</PRE><PRE> function queryCaseInsensitive(query) {
   return typeof query == &quot;string&quot; &amp;&amp; query == query.toLowerCase();
 }
</PRE><PRE> function getSearchCursor(cm, query, pos) {
   // Heuristic: if the query string is all lowercase, do a case insensitive search.
   return cm.getSearchCursor(query, pos, queryCaseInsensitive(query));
 }
</PRE><PRE> function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {
   cm.openDialog(text, onEnter, {
     value: deflt,
     selectValueOnOpen: true,
     closeOnEnter: false,
     onClose: function() { clearSearch(cm); },
     onKeyDown: onKeyDown
   });
 }
</PRE><PRE> function dialog(cm, text, shortText, deflt, f) {
   if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});
   else f(prompt(shortText, deflt));
 }
</PRE><PRE> function confirmDialog(cm, text, shortText, fs) {
   if (cm.openConfirm) cm.openConfirm(text, fs);
   else if (confirm(shortText)) fs[0]();
 }
</PRE><PRE> function parseString(string) {
   return string.replace(/\\(.)/g, function(_, ch) {
     if (ch == &quot;n&quot;) return &quot;\n&quot;
     if (ch == &quot;r&quot;) return &quot;\r&quot;
     return ch
   })
 }
</PRE><PRE> function parseQuery(query) {
   var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
   if (isRE) {
     try { query = new RegExp(isRE[1], isRE[2].indexOf(&quot;i&quot;) == -1 ? &quot;&quot; : &quot;i&quot;); }
     catch(e) {} // Not a regular expression after all, do a string search
   } else {
     query = parseString(query)
   }
   if (typeof query == &quot;string&quot; ? query == &quot;&quot; : query.test(&quot;&quot;))
     query = /x^/;
   return query;
 }
</PRE><PRE> var queryDialog =
   'Search: &lt;input type=&quot;text&quot; style=&quot;width: 10em&quot; class=&quot;CodeMirror-search-field&quot;/&gt;<SPAN style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</SPAN>';
</PRE><PRE> function startSearch(cm, state, query) {
   state.queryText = query;
   state.query = parseQuery(query);
   cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
   state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
   cm.addOverlay(state.overlay);
   if (cm.showMatchesOnScrollbar) {
     if (state.annotate) { state.annotate.clear(); state.annotate = null; }
     state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));
   }
 }
</PRE><PRE> function doSearch(cm, rev, persistent, immediate) {
   var state = getSearchState(cm);
   if (state.query) return findNext(cm, rev);
   var q = cm.getSelection() || state.lastQuery;
   if (persistent &amp;&amp; cm.openDialog) {
     var hiding = null
     var searchNext = function(query, event) {
       CodeMirror.e_stop(event);
       if (!query) return;
       if (query != state.queryText) {
         startSearch(cm, state, query);
         state.posFrom = state.posTo = cm.getCursor();
       }
       if (hiding) hiding.style.opacity = 1
       findNext(cm, event.shiftKey, function(_, to) {
         var dialog
         if (to.line &lt; 3 &amp;&amp; document.querySelector &amp;&amp;
             (dialog = cm.display.wrapper.querySelector(&quot;.CodeMirror-dialog&quot;)) &amp;&amp;
             dialog.getBoundingClientRect().bottom - 4 &gt; cm.cursorCoords(to, &quot;window&quot;).top)
           (hiding = dialog).style.opacity = .4
       })
     };
     persistentDialog(cm, queryDialog, q, searchNext, function(event, query) {
       var keyName = CodeMirror.keyName(event)
       var cmd = CodeMirror.keyMap[cm.getOption(&quot;keyMap&quot;)][keyName]
       if (!cmd) cmd = cm.getOption('extraKeys')[keyName]
       if (cmd == &quot;findNext&quot; || cmd == &quot;findPrev&quot; ||
         cmd == &quot;findPersistentNext&quot; || cmd == &quot;findPersistentPrev&quot;) {
         CodeMirror.e_stop(event);
         startSearch(cm, getSearchState(cm), query);
         cm.execCommand(cmd);
       } else if (cmd == &quot;find&quot; || cmd == &quot;findPersistent&quot;) {
         CodeMirror.e_stop(event);
         searchNext(query, event);
       }
     });
     if (immediate &amp;&amp; q) {
       startSearch(cm, state, q);
       findNext(cm, rev);
     }
   } else {
     dialog(cm, queryDialog, &quot;Search for:&quot;, q, function(query) {
       if (query &amp;&amp; !state.query) cm.operation(function() {
         startSearch(cm, state, query);
         state.posFrom = state.posTo = cm.getCursor();
         findNext(cm, rev);
       });
     });
   }
 }
</PRE><PRE> function findNext(cm, rev, callback) {cm.operation(function() {
   var state = getSearchState(cm);
   var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
   if (!cursor.find(rev)) {
     cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
     if (!cursor.find(rev)) return;
   }
   cm.setSelection(cursor.from(), cursor.to());
   cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);
   state.posFrom = cursor.from(); state.posTo = cursor.to();
   if (callback) callback(cursor.from(), cursor.to())
 });}
</PRE><PRE> function clearSearch(cm) {cm.operation(function() {
   var state = getSearchState(cm);
   state.lastQuery = state.query;
   if (!state.query) return;
   state.query = state.queryText = null;
   cm.removeOverlay(state.overlay);
   if (state.annotate) { state.annotate.clear(); state.annotate = null; }
 });}
</PRE><PRE> var replaceQueryDialog =
   ' &lt;input type=&quot;text&quot; style=&quot;width: 10em&quot; class=&quot;CodeMirror-search-field&quot;/&gt;<SPAN style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</SPAN>';
 var replacementQueryDialog = 'With: &lt;input type=&quot;text&quot; style=&quot;width: 10em&quot; class=&quot;CodeMirror-search-field&quot;/&gt;';
 var doReplaceConfirm = &quot;Replace? &lt;button&gt;Yes&lt;/button&gt;&lt;button&gt;No&lt;/button&gt;&lt;button&gt;All&lt;/button&gt;&lt;button&gt;Stop&lt;/button&gt;&quot;;
</PRE><PRE> function replaceAll(cm, query, text) {
   cm.operation(function() {
     for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {
       if (typeof query != &quot;string&quot;) {
         var match = cm.getRange(cursor.from(), cursor.to()).match(query);
         cursor.replace(text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
       } else cursor.replace(text);
     }
   });
 }
</PRE><PRE> function replace(cm, all) {
   if (cm.getOption(&quot;readOnly&quot;)) return;
   var query = cm.getSelection() || getSearchState(cm).lastQuery;
   var dialogText = all ? &quot;Replace all:&quot; : &quot;Replace:&quot;
   dialog(cm, dialogText + replaceQueryDialog, dialogText, query, function(query) {
     if (!query) return;
     query = parseQuery(query);
     dialog(cm, replacementQueryDialog, &quot;Replace with:&quot;, &quot;&quot;, function(text) {
       text = parseString(text)
       if (all) {
         replaceAll(cm, query, text)
       } else {
         clearSearch(cm);
         var cursor = getSearchCursor(cm, query, cm.getCursor(&quot;from&quot;));
         var advance = function() {
           var start = cursor.from(), match;
           if (!(match = cursor.findNext())) {
             cursor = getSearchCursor(cm, query);
             if (!(match = cursor.findNext()) ||
                 (start &amp;&amp; cursor.from().line == start.line &amp;&amp; cursor.from().ch == start.ch)) return;
           }
           cm.setSelection(cursor.from(), cursor.to());
           cm.scrollIntoView({from: cursor.from(), to: cursor.to()});
           confirmDialog(cm, doReplaceConfirm, &quot;Replace?&quot;,
                         [function() {doReplace(match);}, advance,
                          function() {replaceAll(cm, query, text)}]);
         };
         var doReplace = function(match) {
           cursor.replace(typeof query == &quot;string&quot; ? text :
                          text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
           advance();
         };
         advance();
       }
     });
   });
 }
</PRE><PRE> CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};
 CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};
 CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};
 CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};
 CodeMirror.commands.findNext = doSearch;
 CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};
 CodeMirror.commands.clearSearch = clearSearch;
 CodeMirror.commands.replace = replace;
 CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};
</PRE><P>});
&lt;/script&gt;</P><PRE>&lt;script&gt;(function(){'use strict';
</PRE><P>var c,aa=&quot;object&quot;===typeof __ScalaJSEnv&amp;&amp;__ScalaJSEnv?__ScalaJSEnv:{},ba=&quot;object&quot;===typeof aa.global&amp;&amp;aa.global?aa.global:&quot;object&quot;===typeof global&amp;&amp;global&amp;&amp;global.Object===Object?global:this;aa.global=ba;var ca=&quot;object&quot;===typeof aa.exportsNamespace&amp;&amp;aa.exportsNamespace?aa.exportsNamespace:ba;aa.exportsNamespace=ca;ba.Object.freeze(aa);var aaa={envInfo:aa,semantics:{asInstanceOfs:2,arrayIndexOutOfBounds:2,moduleInit:2,strictFloats:!1,productionMode:!0},assumingES6:!1,linkerVersion:&quot;0.6.18&quot;,globalThis:this};
ba.Object.freeze(aaa);ba.Object.freeze(aaa.semantics);var da=ba.Math.imul||function(a,b){var d=a&amp;65535,e=b&amp;65535;return d*e+((a&gt;&gt;&gt;16&amp;65535)*e+d*(b&gt;&gt;&gt;16&amp;65535)&lt;&lt;16&gt;&gt;&gt;0)|0},ea=ba.Math.fround||function(a){return+a},fa=ba.Math.clz32||function(a){if(0===a)return 32;var b=1;0===(a&amp;4294901760)&amp;&amp;(a&lt;&lt;=16,b+=16);0===(a&amp;4278190080)&amp;&amp;(a&lt;&lt;=8,b+=8);0===(a&amp;4026531840)&amp;&amp;(a&lt;&lt;=4,b+=4);0===(a&amp;3221225472)&amp;&amp;(a&lt;&lt;=2,b+=2);return b+(a&gt;&gt;31)},ha=0,ia=ba.WeakMap?new ba.WeakMap:null;
function ja(a){return function(b,d){return!(!b||!b.$classData||b.$classData.Br!==d||b.$classData.Ar!==a)}}function baa(a){for(var b in a)return b}function ka(a,b){return new a.xC(b)}function la(a,b){return caa(a,b,0)}function caa(a,b,d){var e=new a.xC(b[d]);if(d&lt;b.length-1){a=a.It;d+=1;for(var f=e.l,h=0;h&lt;f.length;h++)f[h]=caa(a,b,d)}return e}function na(a){return void 0===a?&quot;undefined&quot;:a.toString()}
function oa(a){switch(typeof a){case &quot;string&quot;:return pa(qa);case &quot;number&quot;:var b=a|0;return b===a?ra(b)?pa(sa):ta(b)?pa(ua):pa(wa):xa(a)?pa(ya):pa(za);case &quot;boolean&quot;:return pa(Aa);case &quot;undefined&quot;:return pa(Ba);default:return null===a?a.boa():Ca(a)?pa(Da):a&amp;&amp;a.$classData?pa(a.$classData):null}}function Ea(a,b){return a&amp;&amp;a.$classData||null===a?a.o(b):&quot;number&quot;===typeof a?&quot;number&quot;===typeof b&amp;&amp;(a===b?0!==a||1/a===1/b:a!==a&amp;&amp;b!==b):a===b}
function Ga(a){switch(typeof a){case &quot;string&quot;:return Ha(Ia(),a);case &quot;number&quot;:return daa(Ja(),a);case &quot;boolean&quot;:return a?1231:1237;case &quot;undefined&quot;:return 0;default:return a&amp;&amp;a.$classData||null===a?a.r():null===ia?42:Ka(a)}}function La(a){return&quot;string&quot;===typeof a?a.length|0:a.sa()}function Ma(a,b,d){return&quot;string&quot;===typeof a?a.substring(b,d):a.xv(b,d)}function Na(a){return 2147483647&lt;a?2147483647:-2147483648&gt;a?-2147483648:a|0}
function eaa(a,b){var d=ba.Object.getPrototypeOf,e=ba.Object.getOwnPropertyDescriptor;for(a=d(a);null!==a;){var f=e(a,b);if(void 0!==f)return f;a=d(a)}}function faa(a,b,d){a=eaa(a,d);if(void 0!==a)return d=a.get,void 0!==d?d.call(b):a.value}function gaa(a,b,d,e){a=eaa(a,d);if(void 0!==a&amp;&amp;(a=a.set,void 0!==a)){a.call(b,e);return}throw new ba.TypeError(&quot;super has no setter '&quot;+d+&quot;'.&quot;);}
function Oa(a,b,d,e,f){a=a.l;d=d.l;if(a!==d||e&lt;b||(b+f|0)&lt;e)for(var h=0;h&lt;f;h=h+1|0)d[e+h|0]=a[b+h|0];else for(h=f-1|0;0&lt;=h;h=h-1|0)d[e+h|0]=a[b+h|0]}
var Ka=null!==ia?function(a){switch(typeof a){case &quot;string&quot;:case &quot;number&quot;:case &quot;boolean&quot;:case &quot;undefined&quot;:return Ga(a);default:if(null===a)return 0;var b=ia.get(a);void 0===b&amp;&amp;(ha=b=ha+1|0,ia.set(a,b));return b}}:function(a){if(a&amp;&amp;a.$classData){var b=a.$idHashCode$0;if(void 0!==b)return b;if(ba.Object.isSealed(a))return 42;ha=b=ha+1|0;return a.$idHashCode$0=b}return null===a?0:Ga(a)};function ra(a){return&quot;number&quot;===typeof a&amp;&amp;a&lt;&lt;24&gt;&gt;24===a&amp;&amp;1/a!==1/-0}
function ta(a){return&quot;number&quot;===typeof a&amp;&amp;a&lt;&lt;16&gt;&gt;16===a&amp;&amp;1/a!==1/-0}function Pa(a){return&quot;number&quot;===typeof a&amp;&amp;(a|0)===a&amp;&amp;1/a!==1/-0}function xa(a){return&quot;number&quot;===typeof a}function Qa(a){return null===a?Ra().Bp:a}function Sa(){this.Xx=this.xC=void 0;this.Ar=this.It=this.n=null;this.Br=0;this.Vy=null;this.Tw=&quot;&quot;;this.wk=this.Kw=this.Lw=void 0;this.name=&quot;&quot;;this.isRawJSType=this.isArrayClass=this.isInterface=this.isPrimitive=!1;this.isInstance=void 0}
function Ta(a,b,d){var e=new Sa;e.n={};e.It=null;e.Vy=a;e.Tw=b;e.wk=function(){return!1};e.name=d;e.isPrimitive=!0;e.isInstance=function(){return!1};return e}function g(a,b,d,e,f,h,k,p){var t=new Sa,x=baa(a);k=k||function(a){return!!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n[x])};p=p||function(a,b){return!!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.Br===b&amp;&amp;a.$classData.Ar.n[x])};t.Xx=h;t.n=e;t.Tw=&quot;L&quot;+d+&quot;;&quot;;t.wk=p;t.name=d;t.isInterface=b;t.isRawJSType=!!f;t.isInstance=k;return t}
function haa(a){function b(a){if(&quot;number&quot;===typeof a){this.l=Array(a);for(var b=0;b&lt;a;b++)this.l[b]=f}else this.l=a}var d=new Sa,e=a.Vy,f=&quot;longZero&quot;==e?Ra().Bp:e;b.prototype=new l;b.prototype.constructor=b;b.prototype.MS=function(){return this.l instanceof Array?new b(this.l.slice(0)):new b(new this.l.constructor(this.l))};b.prototype.$classData=d;var e=&quot;[&quot;+a.Tw,h=a.Ar||a,k=a.Br+1;d.xC=b;d.Xx=Ua;d.n={d:1,Te:1,i:1};d.It=a;d.Ar=h;d.Br=k;d.Vy=null;d.Tw=e;d.Lw=void 0;d.Kw=void 0;d.wk=void 0;d.name=e;
d.isPrimitive=!1;d.isInterface=!1;d.isArrayClass=!0;d.isInstance=function(a){return h.wk(a,k)};return d}function pa(a){if(!a.Lw){var b=new Wa;b.ti=a;a.Lw=b}return a.Lw}function Xa(a){a.Kw||(a.Kw=haa(a));return a.Kw}Sa.prototype.getFakeInstance=function(){return this===qa?&quot;some string&quot;:this===Aa?!1:this===sa||this===ua||this===wa||this===ya||this===za?0:this===Da?Ra().Bp:this===Ba?void 0:{$classData:this}};Sa.prototype.getSuperclass=function(){return this.Xx?pa(this.Xx):null};
Sa.prototype.getComponentType=function(){return this.It?pa(this.It):null};Sa.prototype.newArrayOfThisClass=function(a){for(var b=this,d=0;d&lt;a.length;d++)b=Xa(b);return la(b,a)};var Ya=Ta(void 0,&quot;V&quot;,&quot;void&quot;),Za=Ta(!1,&quot;Z&quot;,&quot;boolean&quot;),ab=Ta(0,&quot;C&quot;,&quot;char&quot;),bb=Ta(0,&quot;B&quot;,&quot;byte&quot;),cb=Ta(0,&quot;S&quot;,&quot;short&quot;),db=Ta(0,&quot;I&quot;,&quot;int&quot;),eb=Ta(&quot;longZero&quot;,&quot;J&quot;,&quot;long&quot;),fb=Ta(0,&quot;F&quot;,&quot;float&quot;),gb=Ta(0,&quot;D&quot;,&quot;double&quot;),hb=ja(Za);Za.wk=hb;var ib=ja(ab);ab.wk=ib;var jb=ja(bb);bb.wk=jb;var kb=ja(cb);cb.wk=kb;var lb=ja(db);db.wk=lb;var mb=ja(eb);
eb.wk=mb;var nb=ja(fb);fb.wk=nb;var ob=ja(gb);gb.wk=ob;function iaa(a,b){return m(new n,function(a,b){return function(f){return a.y(b.y(f))}}(a,b))}function qb(a,b){return m(new n,function(a,b){return function(f){return b.y(a.y(f))}}(a,b))}function jaa(a){return m(new n,function(a){return function(d){if(null!==d)return rb(a,d.la(),d.pa());throw(new q).j(d);}}(a))}function sb(a){return m(new n,function(a){return function(d){return m(new n,function(a,b){return function(d){return rb(a,b,d)}}(a,d))}}(a))}
function kaa(a,b,d){return b.za.Gb(d,tb(new ub,function(a){return function(b,d){return wb(a,d,b)}}(a)))}function wb(a,b,d){if(xb(b))return laa(a,b,d);if(yb(b))return maa(a,b.fe,d);if(zb(b))return laa(a,b.Sk,d);throw(new q).j(b);}function maa(a,b,d){return b.Zf.Gb(d,tb(new ub,function(a){return function(b,d){return kaa(a,d,b)}}(a)))}function naa(a,b,d){return b.za.Gb(d,tb(new ub,function(a){return function(b,d){return wb(a,d,b)}}(a)))}
function Ab(a,b){if(xb(b))return a.Cg(b);if(yb(b))return a=oaa(a,b.fe),Bb(new Cb,a,b.ra,b.qj);if(zb(b))return a=a.Cg(b.Sk),Db(new Eb,a,b.ra);throw(new q).j(b);}function oaa(a,b){var d=b.Zf;a=m(new n,function(a){return function(b){return a.vh(b)}}(a));var e=r(),d=d.xa(a,e.s);return(new Fb).ns(b.Yr,d,b.oe)}function Gb(a,b){var d=b.za;a=m(new n,function(a){return function(b){return Ab(a,b)}}(a));var e=r(),d=d.xa(a,e.s);return(new Hb).cj(b.xd,d,b.ra)}
function Jb(a,b){var d=b.za;a=m(new n,function(a){return function(b){return Ab(a,b)}}(a));var e=r(),d=d.xa(a,e.s);return(new Kb).Qf(b.pe,d,b.ra)}function Lb(a,b){a=oaa(a,b.fe);return Mb(b.ji,a,b.bz)}function paa(a,b){b.za.wa(m(new n,function(a){return function(b){Nb(a,b)}}(a)))}function Ob(a,b){b.Zf.wa(m(new n,function(a){return function(b){a.MY(b)}}(a)))}function qaa(a,b){b.za.wa(m(new n,function(a){return function(b){Nb(a,b)}}(a)))}
function Nb(a,b){if(xb(b))a.VF(b);else if(yb(b))Ob(a,b.fe);else if(zb(b))a.VF(b.Sk);else throw(new q).j(b);}function raa(a,b){return-1!==(a.Ld.indexOf(&quot;\x3cBREED\x3e&quot;)|0)?b.Bf:b.va}function Pb(a){var b=Qb(Ia(),Qb(Ia(),a.Ld,&quot;\\?&quot;,&quot;\\\\?&quot;),saa(Rb()),&quot;(.+)&quot;),b=u((new v).K((new w).f([&quot;^&quot;,&quot;$&quot;])),(new w).f([b])),b=(new Sb).c(b),d=y();a.Ux((new Tb).Ro(b.R,d))}
function taa(a,b){var d=(new Ub).mD((new Vb).ia(1E8,0)),e=(new Wb).tk(0),f=uaa(a);Xb(new Yb,f,m(new n,function(){return function(a){return null!==a}}(a))).wa(m(new n,function(a,b,d,e){return function(a){if(null!==a){var f=+a.pa(),h;h=Na(+a.la());var U=255&amp;b&gt;&gt;16,ga=255&amp;h&gt;&gt;16;a=U+(ga/2|0)|0;U=U-ga|0;ga=(255&amp;b&gt;&gt;8)-(255&amp;h&gt;&gt;8)|0;h=(255&amp;b)-(255&amp;h)|0;a=((da(da(512+a|0,U),U)&gt;&gt;8)+da(ga&lt;&lt;2,ga)|0)+(da(da(767-a|0,h),h)&gt;&gt;8)|0;h=(new Vb).ia(a,a&gt;&gt;31);a=h.ka;h=h.qa;U=d.Ba;ga=U.qa;if(h===ga?(-2147483648^a)&lt;(-2147483648^
U.ka):h&lt;ga)d.Ba=(new Vb).ia(a,h),e.Ba=f}else throw(new q).j(a);}}(a,b,d,e)));return e.Ba}function vaa(a){var b=Zb,d=uaa(b).dc(a);return+(d.z()?taa(b,a):d.Y())}function $b(a,b,d,e){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Dump.scala: 56&quot;);return a.wT.y((new ac).ae(b,d,e))}function waa(a,b,d,e){a=(new bc).Gf(b,m(new n,function(a,b,d){return function(e){return $b(a,e,b,d)}}(a,d,e)));return cc(a,&quot;[&quot;,&quot; &quot;,&quot;]&quot;)}
function xaa(a,b,d,e,f,h,k,p){var t=[(new A).e(&quot;&quot;,b)];b=dc(new ec,gc());for(var x=0,E=t.length|0;x&lt;E;)hc(b,t[x]),x=1+x|0;t=yaa;x=new ic;x.Rs=b.Ma;x.hh=k;x.Fr=p;x.Mr=e;x.un=h;x.Hk=f;x.Um=d;return t(a,x)}
function zaa(a){B();for(var b=Aaa(a).Ga(),d=(new jc).b(),e=0;e&lt;b;){var f=lc();mc(d,f);e=1+e|0}b=d.ub();if(a.$u.jn){a=lc();d=C();D();e=nc();D();f=F();D();var h=F();D();D();D();var k=F();D();return G(new H,d,e,b,a,f,h,!1,&quot;OTPL&quot;,k,k.ba(),!0)}return oc(D(),b,(D(),F()),(D(),F()),(D(),&quot;OTPL&quot;),(D(),F()),(D(),!1),(D(),!0))}function Baa(a){a.M(&quot;OTPL&quot;);Caa(a,I(pc().Th,y()));a.a=(32|a.a)&lt;&lt;24&gt;&gt;24}function qc(a){return!!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.uJ)}
function Daa(a,b,d,e,f){var h=a.ep.y(f.me());b=rc(b,sc(f),tc());uc();h=h.Oa();vc||(vc=(new wc).b());var h=xc(0,h,vc),k=new yc;d=zc(d,a.ce);k.ec=a.ec;k.ce=d;k.ji=f;k.hh=e;Eaa(k);a=xc(uc(),h,k);Ac||(Ac=(new Cc).b());e=Ac;a=a.Om();d=Dc();for(h=I(Ec(),y());;)if(k=a.$().jb,null===k||k!==d){b=Fc(e,a,!1,b);if(null===b)throw(new q).j(b);k=b.la();b=b.pa();h.uj(k)}else break;b=h.Hc();e=a.$();b=(new Fb).ns(e.Lc().ab,b,!1);a=2147483647!==a.$().Lc().Va?a.$().Lc().Xa:b.Lc().Va;return Mb(f,b,a)}
function Faa(a,b){a=Gaa(Gc(),Hc(a),b);for(var d=Haa(Gc(),a.ec,zc(b.un,a.ce)),e=a.ce,f=Ic(b.un),e=Jc(e,f),f=(new Kc).fg(e),e=Lc().s,e=Mc(f,e),f=f.oi.rj();f.ta();){var h=f.ma();e.Na(Daa(a,d,b.un,b.hh,h))}b=e.Da().Hc();return(new A).e(b,a)}function Iaa(a,b,d,e){b=b.za;var f=r();return b.sj(f.s).Gb(e,tb(new ub,function(a,b){return function(d,e){d=(new A).e(d,e);e=d.kb;var f=d.Ab;if(null!==f)return Nc(a,f.la(),b,f.Dc(),e);throw(new q).j(d);}}(a,d)))}
function Oc(a,b,d,e){b=b.za;var f=r();return b.sj(f.s).Gb(e,tb(new ub,function(a,b){return function(d,e){d=(new A).e(d,e);e=d.kb;var f=d.Ab;if(null!==f)return Nc(a,f.la(),b,f.Dc(),e);throw(new q).j(d);}}(a,d)))}
function Jaa(a,b,d,e){b=b.Zf;var f=r();return b.sj(f.s).Gb(e,tb(new ub,function(a,b){return function(d,e){e=(new A).e(d,e);d=e.kb;var f=e.Ab;if(null!==f){e=f.la();f=Pc(b,(new Qc).Db(f.Dc()));var E=d.Uj.dc(f);E.z()?E=F():(E=E.Y(),E=(new J).j(Rc(E,a,e,f,d)));E.z()?(E=Sc(d.pf,f),E=Tc(Uc(d),&quot;&quot;+E+d.am.y(e.xd)),e=Iaa(a,e,f,E),d=Vc(new Wc,e.Wb,e.Uj,d.am,e.pf)):d=E.Y();return d}throw(new q).j(e);}}(a,d)))}
function Nc(a,b,d,e,f){if(xb(b))return d=Pc(d,(new Xc).Db(e)),Yc(a,b,d,f);if(yb(b)){d=Pc(d,(new Zc).Db(e));if(b.qj&amp;&amp;b.fe.Zf.z())f=Tc(Uc(f),Sc(f.pf,d));else if(b.qj)e=f.Uj.dc(d),e.z()?e=F():(e=e.Y(),e=(new J).j(Rc(e,a,b,d,Tc(Uc(f),Sc(f.pf,d))))),e.z()?(e=Tc(Uc(f),Sc(f.pf,d)),a=Jaa(a,b.fe,d,e),f=Tc(Uc(a),$c(f.pf,d))):f=e.Y();else{var h=Kaa(a);e=Laa(a);var k=f.Uj.dc(d);k.z()?k=F():(k=k.Y(),k=(new J).j(Rc(k,a,b,d,Tc(Uc(f),Sc(f.pf,d)))));k.z()?(h=Tc(Uc(f),h.y(f.pf).y(d)),a=Jaa(a,b.fe,d,h),f=Tc(Uc(a),e.y(f.pf).y(d))):
f=k.Y()}return f}if(zb(b))return d=Pc(d,(new ad).Db(e)),h=Kaa(a),e=Laa(a),k=f.Uj.dc(d),k.z()?k=F():(k=k.Y(),k=(new J).j(Rc(k,a,b,d,Tc(Uc(f),Sc(f.pf,d))))),k.z()?(h=Tc(Uc(f),h.y(f.pf).y(d)),b=b.Sk,k=Pc(d,(new Xc).Db(0)),a=Yc(a,b,k,h),f=Tc(Uc(a),e.y(f.pf).y(d))):f=k.Y(),f;throw(new q).j(b);}
function Maa(a,b,d,e,f){bd(a);d=cd(d,&quot;run&quot;);var h=f.cp;a=m(new n,function(a,b){return function(a){return u((new v).K((new w).f([&quot;&quot;,'Vars[&quot;','&quot;] \x3d ',&quot;;&quot;])),(new w).f([b,a,a]))}}(a,d));var k=r(),h=h.xa(a,k.s).zb(&quot;\n&quot;);!b&amp;&amp;f.lq?(a=u((new v).K((new w).f([&quot;var &quot;,&quot; \x3d &quot;])),(new w).f([d])),f=u((new v).K((new w).f([&quot;if(reporterContext \x26\x26 &quot;,&quot; !\x3d\x3d undefined) { return &quot;,&quot;; }&quot;])),(new w).f([d,d]))):f=a=&quot;&quot;;b=u((new v).K((new w).f([&quot;|&quot;,&quot;Prims.runCode(\n        |  &quot;,&quot;,\n        |  (function() {\n        |    let &quot;,
&quot;Vars \x3d { }; for(var v in letVars) { &quot;,&quot;Vars[v] \x3d letVars[v]; }\n        |    &quot;,&quot;\n        |    return &quot;,&quot;Vars;\n        |  })(),\n        |  &quot;,&quot;\n        |)\n        |&quot;,&quot;\n        |&quot;])),(new w).f([a,b,d,d,h,d,e.zb(&quot;, &quot;),f]));b=(new Sb).c(b);return dd(b)}function Naa(a){return u((new v).K((new w).f([&quot;notImplemented(&quot;,&quot;, undefined)&quot;])),(new w).f([ed(fd(),a)]))}function gd(a,b){throw(new hd).ms(a,b.ra.Xa,b.ra.Va,b.ra.ab);}
function id(a){a=jd().Uc(a);if(a.z())var b=!0;else b=a.Y(),b=(new Sb).c(b),b=kd(b);a=b?a:F();return a.z()?&quot;LINKS&quot;:a.Y()}function Oaa(a,b){ld();return md(new nd,Paa(b)).Uc(a)}function od(a){return pd(qd(),rd(qd(),a))}function sd(a,b){return a.Mk(b).KT(m(new n,function(){return function(a){throw(new td).K(a);}}(a)),m(new n,function(){return function(a){return a}}(a)))}var Qaa=g({ft:0},!0,&quot;sbt.testing.Fingerprint&quot;,{ft:1});function ud(a){return!!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.i7)}
var Raa=g({yB:0},!0,&quot;sbt.testing.Logger&quot;,{yB:1}),vd=g({VQ:0},!0,&quot;sbt.testing.Task&quot;,{VQ:1});function wd(a){a.Js(Saa(a))}function xd(a){a.kp(Taa(a))}function yd(a){a.ov(Uaa(a))}function zd(a){a.Vf(Vaa(a))}function Ad(a,b){return Bd(a.Hg(b,y(),tb(new ub,function(){return function(a,b){return Cd(new Dd,b,a)}}(a))))}function Ed(a){a.Hi(Waa(a))}
function Xaa(a,b,d,e){return a.Hg(b,e.vd(K(function(){return function(){}}(a))),tb(new ub,function(a,b,d){return function(e,t){return d.$e(K(function(a,b,d){return function(){return b.y(d)}}(a,b,t)),K(function(a,b,d){return function(){return b.Xc(d,m(new n,function(a){return function(){return m(new n,function(){return function(){}}(a))}}(a)))}}(a,d,e)))}}(a,d,e)))}
function Fd(a,b,d,e){e=m(new n,function(a,b){return function(a){Gd();var d=Yaa;Hd||(Hd=(new Id).b());d=d(Hd,b);a=sb(d).y(a);return(new Jd).cn(a)}}(a,e));Zaa||(Zaa=(new Kd).b());var f=Gd(),f=(new Ld).yD(f);return a.Zh(b,e,$aa(f)).Cq.y(d)}function Md(a){a.ig(aba(a))}function Nd(a){a.Jq(bba(a))}function Od(a){a.ff(cba(a))}function Pd(a,b){var d=Qd();a=[Rd(Qd(),a.Xg(b))];b=a.length|0;var e=0,f=Sd((new Td).dj(d.Pq));a:for(;;){if(e!==b){d=1+e|0;f=Ud(f,a[e]);e=d;continue a}return f}}
function Vd(a){a.Tg(dba(a))}function Wd(a){a.Gn(eba(a))}function Xd(a){a.Hn(fba(a))}function gba(a){a.cX((new Yd).Sd(a));a.QW((new Zd).Sd(a));a.PW((new $d).Sd(a));a.RW((new be).Sd(a));a.SW((new ce).Sd(a));a.TW((new de).Sd(a));a.UW((new ee).Sd(a));a.aX((new fe).Sd(a));a.bX((new ge).Sd(a));a.XW((new he).Sd(a));a.YW((new ie).Sd(a));a.ZW((new je).Sd(a));a.$W((new ke).Sd(a));a.WW((new le).Sd(a));a.VW((new me).Sd(a))}function hba(a){a.fX((new ne).HD(a));a.gX((new oe).HD(a))}
function iba(a,b){var d=new pe;qe||(qe=(new re).b());return jba(d,((new se).b(),a),b.XB)}function te(){}function l(){}l.prototype=te.prototype;te.prototype.b=function(){return this};te.prototype.o=function(a){return this===a};te.prototype.k=function(){var a=oa(this).kh(),b=(+(this.r()&gt;&gt;&gt;0)).toString(16);return a+&quot;@&quot;+b};te.prototype.r=function(){return Ka(this)};te.prototype.toString=function(){return this.k()};
function ve(a,b){if(a=a&amp;&amp;a.$classData){var d=a.Br||0;return!(d&lt;b)&amp;&amp;(d&gt;b||!a.Ar.isPrimitive)}return!1}var Ua=g({d:0},!1,&quot;java.lang.Object&quot;,{d:1},void 0,void 0,function(a){return null!==a},ve);te.prototype.$classData=Ua;function kba(a,b){b!==a&amp;&amp;b.ap(m(new n,function(a){return function(b){return a.Lv(b)}}(a)),we());return a}function xe(a,b){if(a.Lv(b))return a;throw(new ye).c(&quot;Promise already completed.&quot;);}
function lba(a,b){if(ze(b))return b=null===b?0:b.X,a.VD()&amp;&amp;a.wi()===b;if(ra(b))return b|=0,a.UD()&amp;&amp;a.Zw()===b;if(ta(b))return b|=0,a.WD()&amp;&amp;a.vy()===b;if(Pa(b))return b|=0,a.Eu()&amp;&amp;a.wi()===b;if(Ca(b)){var d=Qa(b);b=d.ka;d=d.qa;a=a.gj();var e=a.qa;return a.ka===b&amp;&amp;e===d}return xa(b)?(b=+b,a.Op()===b):&quot;number&quot;===typeof b?(b=+b,a.Lj()===b):!1}function mba(a,b){a.LE=b;return a}function nba(a,b){return 0&lt;=a.Sq(b)?na(Ma(a.wF(),a.Sq(b),a.Wt(b))):null}
function oba(a,b){return(new Ae).el(a,m(new n,function(a,b){return function(f){return Be(new Ce,a,b,f)}}(a,b)))}function De(a,b){return(new Ae).el(a,m(new n,function(a,b){return function(f){f=Ee(b).si(f);if(Fe(f)||Ge(f))return f;if(He(f))return(new Ie).en(a,f.Bk,f.be);throw(new q).j(f);}}(a,b)))}function Je(a,b){return(new Ae).el(a,m(new n,function(a,b){return function(f){return(new Ke).en(a,b,f)}}(a,b)))}
function Le(a,b,d){return(new Ae).el(a,m(new n,function(a,b,d){return function(k){var p;if(k.ym.z())p=(new Ke).en(a,&quot;end of input&quot;,k);else if(d.Ua(k.ym.$())){p=new Ce;var t=d.y(k.ym.$());k=pba(new Me,k.ym.aa(),k.ZC);p=Be(p,a,t,k)}else p=(new Ke).en(a,b+&quot; expected&quot;,k);return p}}(a,b,d)))}
function qba(a,b,d){return(new Ae).el(a,m(new n,function(a,b,d){return function(k){var p=(new Ne).b(),t=(new jc).b(),x=Ee(b).si(k);if(Fe(x)){k=x.be;mc(t,x.mm);if(p.La)p=p.hb;else{if(null===p)throw(new Oe).b();p=p.La?p.hb:Pe(p,Ee(d))}a:for(;;)if(x=p.si(k),Fe(x))k=x,x=k.be,mc(t,k.mm),k=x;else{t=Ge(x)?x:Be(new Ce,a,t.ub(),k);break a}return t}if(x&amp;&amp;x.$classData&amp;&amp;x.$classData.n.JE)return x;throw(new q).j(x);}}(a,b,d)))}
function Qe(a,b){return Re(qba(a,b,b),K(function(a){return function(){var b=y();return oba(a,b)}}(a)))}function rba(a,b){var d=a.Sa;a=Se(Ue(a,m(new n,function(a,b){return function(d){return Ve(De(a.Sa,b),m(new n,function(a,b){return function(d){return We(a.Sa,b,d)}}(a,d)))}}(a,b))),&quot;~&quot;);return(new Xe).el(d,a)}
function sba(a){var b=(new Sb).c(&quot;&quot;);a=-1+a.sc|0;b=Ye(Ze(),b.R,0,a);b=(new Sb).c(b);a=$e().zp;a=Mc(b,a);for(var d=0,e=b.R.length|0;d&lt;e;){var f=b.W(d),f=null===f?0:f.X;a.Na((new af).Ra(9===f?f:32));d=1+d|0}return&quot;\n&quot;+a.Da()+&quot;^&quot;}function bf(a,b){b.wa(m(new n,function(a){return function(b){return a.zm(b)}}(a)));return a}function Jc(a,b){var d=a.Tf();return b.mb().qf(d,tb(new ub,function(){return function(a,b){return a.ue(b)}}(a)))}
function cf(a){var b=la(Xa(Ua),[a.l.length]);Oa(a,0,b,0,a.l.length);return b}
function tba(a,b,d){if(32&gt;d)return a.ye().l[31&amp;b];if(1024&gt;d)return a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)].l[31&amp;b];if(32768&gt;d)return a.Kb().l[31&amp;(b&gt;&gt;&gt;10|0)].l[31&amp;(b&gt;&gt;&gt;5|0)].l[31&amp;b];if(1048576&gt;d)return a.kc().l[31&amp;(b&gt;&gt;&gt;15|0)].l[31&amp;(b&gt;&gt;&gt;10|0)].l[31&amp;(b&gt;&gt;&gt;5|0)].l[31&amp;b];if(33554432&gt;d)return a.rd().l[31&amp;(b&gt;&gt;&gt;20|0)].l[31&amp;(b&gt;&gt;&gt;15|0)].l[31&amp;(b&gt;&gt;&gt;10|0)].l[31&amp;(b&gt;&gt;&gt;5|0)].l[31&amp;b];if(1073741824&gt;d)return a.Eh().l[31&amp;(b&gt;&gt;&gt;25|0)].l[31&amp;(b&gt;&gt;&gt;20|0)].l[31&amp;(b&gt;&gt;&gt;15|0)].l[31&amp;(b&gt;&gt;&gt;10|0)].l[31&amp;(b&gt;&gt;&gt;5|0)].l[31&amp;b];throw(new df).b();}
function uba(a,b,d,e){if(32&lt;=e)if(1024&gt;e)1===a.uf()&amp;&amp;(a.nc(la(Xa(Ua),[32])),a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]=a.ye(),a.Ij(1+a.uf()|0)),a.Nc(la(Xa(Ua),[32]));else if(32768&gt;e)2===a.uf()&amp;&amp;(a.Vc(la(Xa(Ua),[32])),a.Kb().l[31&amp;(b&gt;&gt;&gt;10|0)]=a.wb(),a.Ij(1+a.uf()|0)),a.nc(a.Kb().l[31&amp;(d&gt;&gt;&gt;10|0)]),null===a.wb()&amp;&amp;a.nc(la(Xa(Ua),[32])),a.Nc(la(Xa(Ua),[32]));else if(1048576&gt;e)3===a.uf()&amp;&amp;(a.ze(la(Xa(Ua),[32])),a.kc().l[31&amp;(b&gt;&gt;&gt;15|0)]=a.Kb(),a.Ij(1+a.uf()|0)),a.Vc(a.kc().l[31&amp;(d&gt;&gt;&gt;15|0)]),null===a.Kb()&amp;&amp;a.Vc(la(Xa(Ua),[32])),
a.nc(a.Kb().l[31&amp;(d&gt;&gt;&gt;10|0)]),null===a.wb()&amp;&amp;a.nc(la(Xa(Ua),[32])),a.Nc(la(Xa(Ua),[32]));else if(33554432&gt;e)4===a.uf()&amp;&amp;(a.fh(la(Xa(Ua),[32])),a.rd().l[31&amp;(b&gt;&gt;&gt;20|0)]=a.kc(),a.Ij(1+a.uf()|0)),a.ze(a.rd().l[31&amp;(d&gt;&gt;&gt;20|0)]),null===a.kc()&amp;&amp;a.ze(la(Xa(Ua),[32])),a.Vc(a.kc().l[31&amp;(d&gt;&gt;&gt;15|0)]),null===a.Kb()&amp;&amp;a.Vc(la(Xa(Ua),[32])),a.nc(a.Kb().l[31&amp;(d&gt;&gt;&gt;10|0)]),null===a.wb()&amp;&amp;a.nc(la(Xa(Ua),[32])),a.Nc(la(Xa(Ua),[32]));else if(1073741824&gt;e)5===a.uf()&amp;&amp;(a.Ao(la(Xa(Ua),[32])),a.Eh().l[31&amp;(b&gt;&gt;&gt;25|0)]=a.rd(),
a.Ij(1+a.uf()|0)),a.fh(a.Eh().l[31&amp;(d&gt;&gt;&gt;25|0)]),null===a.rd()&amp;&amp;a.fh(la(Xa(Ua),[32])),a.ze(a.rd().l[31&amp;(d&gt;&gt;&gt;20|0)]),null===a.kc()&amp;&amp;a.ze(la(Xa(Ua),[32])),a.Vc(a.kc().l[31&amp;(d&gt;&gt;&gt;15|0)]),null===a.Kb()&amp;&amp;a.Vc(la(Xa(Ua),[32])),a.nc(a.Kb().l[31&amp;(d&gt;&gt;&gt;10|0)]),null===a.wb()&amp;&amp;a.nc(la(Xa(Ua),[32])),a.Nc(la(Xa(Ua),[32]));else throw(new df).b();}function ef(a,b,d){var e=la(Xa(Ua),[32]);Oa(a,b,e,d,32-(d&gt;b?d:b)|0);return e}
function vba(a,b,d){if(32&lt;=d)if(1024&gt;d)a.Nc(a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]);else if(32768&gt;d)a.nc(a.Kb().l[31&amp;(b&gt;&gt;&gt;10|0)]),a.Nc(a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]);else if(1048576&gt;d)a.Vc(a.kc().l[31&amp;(b&gt;&gt;&gt;15|0)]),a.nc(a.Kb().l[31&amp;(b&gt;&gt;&gt;10|0)]),a.Nc(a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]);else if(33554432&gt;d)a.ze(a.rd().l[31&amp;(b&gt;&gt;&gt;20|0)]),a.Vc(a.kc().l[31&amp;(b&gt;&gt;&gt;15|0)]),a.nc(a.Kb().l[31&amp;(b&gt;&gt;&gt;10|0)]),a.Nc(a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]);else if(1073741824&gt;d)a.fh(a.Eh().l[31&amp;(b&gt;&gt;&gt;25|0)]),a.ze(a.rd().l[31&amp;(b&gt;&gt;&gt;20|0)]),a.Vc(a.kc().l[31&amp;(b&gt;&gt;&gt;15|0)]),a.nc(a.Kb().l[31&amp;
(b&gt;&gt;&gt;10|0)]),a.Nc(a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]);else throw(new df).b();}
function wba(a,b){var d=-1+a.uf()|0;switch(d){case 5:a.Ao(cf(a.Eh()));a.fh(cf(a.rd()));a.ze(cf(a.kc()));a.Vc(cf(a.Kb()));a.nc(cf(a.wb()));a.Eh().l[31&amp;(b&gt;&gt;&gt;25|0)]=a.rd();a.rd().l[31&amp;(b&gt;&gt;&gt;20|0)]=a.kc();a.kc().l[31&amp;(b&gt;&gt;&gt;15|0)]=a.Kb();a.Kb().l[31&amp;(b&gt;&gt;&gt;10|0)]=a.wb();a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]=a.ye();break;case 4:a.fh(cf(a.rd()));a.ze(cf(a.kc()));a.Vc(cf(a.Kb()));a.nc(cf(a.wb()));a.rd().l[31&amp;(b&gt;&gt;&gt;20|0)]=a.kc();a.kc().l[31&amp;(b&gt;&gt;&gt;15|0)]=a.Kb();a.Kb().l[31&amp;(b&gt;&gt;&gt;10|0)]=a.wb();a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]=a.ye();break;
case 3:a.ze(cf(a.kc()));a.Vc(cf(a.Kb()));a.nc(cf(a.wb()));a.kc().l[31&amp;(b&gt;&gt;&gt;15|0)]=a.Kb();a.Kb().l[31&amp;(b&gt;&gt;&gt;10|0)]=a.wb();a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]=a.ye();break;case 2:a.Vc(cf(a.Kb()));a.nc(cf(a.wb()));a.Kb().l[31&amp;(b&gt;&gt;&gt;10|0)]=a.wb();a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]=a.ye();break;case 1:a.nc(cf(a.wb()));a.wb().l[31&amp;(b&gt;&gt;&gt;5|0)]=a.ye();break;case 0:break;default:throw(new q).j(d);}}function ff(a,b){var d=a.l[b];a.l[b]=null;return cf(d)}
function gf(a,b,d){a.Ij(d);d=-1+d|0;switch(d){case -1:break;case 0:a.Nc(b.ye());break;case 1:a.nc(b.wb());a.Nc(b.ye());break;case 2:a.Vc(b.Kb());a.nc(b.wb());a.Nc(b.ye());break;case 3:a.ze(b.kc());a.Vc(b.Kb());a.nc(b.wb());a.Nc(b.ye());break;case 4:a.fh(b.rd());a.ze(b.kc());a.Vc(b.Kb());a.nc(b.wb());a.Nc(b.ye());break;case 5:a.Ao(b.Eh());a.fh(b.rd());a.ze(b.kc());a.Vc(b.Kb());a.nc(b.wb());a.Nc(b.ye());break;default:throw(new q).j(d);}}function hf(a){return null===a?xba():a}
function yba(a){return a===xba()?null:a}var zba=g({jF:0},!0,&quot;scala.collection.mutable.HashEntry&quot;,{jF:1});function jf(){this.dy=this.ay=null}jf.prototype=new l;jf.prototype.constructor=jf;function Aba(a){var b=(new w).f([a.ay,a.dy]);a=b.oa.length|0;a=la(Xa(kf),[a]);var d;d=0;for(b=lf(new mf,b,0,b.oa.length|0);b.ta();){var e=b.ma();a.l[d]=e;d=1+d|0}return a}function nf(a,b,d){a.ay=b;a.dy=d;return a}jf.prototype.$classData=g({XY:0},!1,&quot;java.math.BigInteger$QuotAndRem&quot;,{XY:1,d:1});function of(){}
of.prototype=new l;of.prototype.constructor=of;of.prototype.b=function(){return this};function Bba(a,b,d,e){a=0;var f=-1+e|0;if(!(0&gt;=e))for(var h=0;;){var k=h,p=d.l[k];b.l[k]=p&lt;&lt;1|a;a=p&gt;&gt;&gt;31|0;if(h===f)break;h=1+h|0}0!==a&amp;&amp;(b.l[e]=a)}function Cba(a,b,d){a=d&gt;&gt;5;d&amp;=31;var e=(b.bc+a|0)+(0===d?0:1)|0,f=la(Xa(db),[e]);pf(0,f,b.xb,a,d);b=qf(new rf,b.Ub,e,f);uf(b);return b}
function Dba(a,b,d){a=d&gt;&gt;5;var e=31&amp;d;if(a&gt;=b.bc)return 0&gt;b.Ub?wf().Bw:wf().Bj;d=b.bc-a|0;var f=la(Xa(db),[1+d|0]);Eba(0,f,d,b.xb,a,e);if(0&gt;b.Ub){for(var h=0;h&lt;a&amp;&amp;0===b.xb.l[h];)h=1+h|0;var k=0!==b.xb.l[h]&lt;&lt;(32-e|0);if(h&lt;a||0&lt;e&amp;&amp;k){for(h=0;h&lt;d&amp;&amp;-1===f.l[h];)f.l[h]=0,h=1+h|0;h===d&amp;&amp;(d=1+d|0);a=h;f.l[a]=1+f.l[a]|0}}b=qf(new rf,b.Ub,d,f);uf(b);return b}function xf(a,b){if(0===b.Ub)return 0;a=b.bc&lt;&lt;5;var d=b.xb.l[-1+b.bc|0];0&gt;b.Ub&amp;&amp;yf(b)===(-1+b.bc|0)&amp;&amp;(d=-1+d|0);return a=a-fa(d)|0}
function Eba(a,b,d,e,f,h){for(a=0;a&lt;f;)a=1+a|0;if(0===h)Oa(e,f,b,0,d);else{var k=32-h|0;for(a=0;a&lt;(-1+d|0);)b.l[a]=e.l[a+f|0]&gt;&gt;&gt;h|0|e.l[1+(a+f|0)|0]&lt;&lt;k,a=1+a|0;b.l[a]=e.l[a+f|0]&gt;&gt;&gt;h|0}}function pf(a,b,d,e,f){if(0===f)Oa(d,0,b,e,b.l.length-e|0);else{a=32-f|0;b.l[-1+b.l.length|0]=0;for(var h=-1+b.l.length|0;h&gt;e;){var k=h;b.l[k]=b.l[k]|d.l[-1+(h-e|0)|0]&gt;&gt;&gt;a|0;b.l[-1+h|0]=d.l[-1+(h-e|0)|0]&lt;&lt;f;h=-1+h|0}}d=-1+e|0;if(!(0&gt;=e))for(e=0;;){b.l[e]=0;if(e===d)break;e=1+e|0}}
of.prototype.$classData=g({YY:0},!1,&quot;java.math.BitLevel$&quot;,{YY:1,d:1});var zf=void 0;function Af(){zf||(zf=(new of).b());return zf}function Bf(){this.gG=this.vG=null}Bf.prototype=new l;Bf.prototype.constructor=Bf;
Bf.prototype.b=function(){Cf=this;var a=(new w).f([-1,-1,31,19,15,13,11,11,10,9,9,8,8,8,8,7,7,7,7,7,7,7,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5]),b=a.oa.length|0,b=la(Xa(db),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e|0;d=1+d|0}this.vG=b;a=(new w).f([-2147483648,1162261467,1073741824,1220703125,362797056,1977326743,1073741824,387420489,1E9,214358881,429981696,815730721,1475789056,170859375,268435456,410338673,612220032,893871739,128E7,1801088541,113379904,148035889,191102976,
244140625,308915776,387420489,481890304,594823321,729E6,887503681,1073741824,1291467969,1544804416,1838265625,60466176]);b=a.oa.length|0;b=la(Xa(db),[b]);d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();)e=a.ma(),b.l[d]=e|0,d=1+d|0;this.gG=b;return this};
function Fba(a,b,d){if(0===b.ka&amp;&amp;0===b.qa)switch(d){case 0:return&quot;0&quot;;case 1:return&quot;0.0&quot;;case 2:return&quot;0.00&quot;;case 3:return&quot;0.000&quot;;case 4:return&quot;0.0000&quot;;case 5:return&quot;0.00000&quot;;case 6:return&quot;0.000000&quot;;default:return(0&gt;d?&quot;0E+&quot;:&quot;0E&quot;)+(-2147483648===d?&quot;2147483648&quot;:&quot;&quot;+(-d|0))}else{a=0&gt;b.qa;var e;e=&quot;&quot;;var f=18;if(a){var h=b.ka;b=b.qa;b=(new Vb).ia(-h|0,0!==h?~b:-b|0)}for(var h=b.ka,k=b.qa;;){b=h;var p=k,k=Ra(),h=Df(k,h,p,10,0),k=k.Pb,f=-1+f|0,p=k,t=h,x=t&gt;&gt;&gt;16|0,t=da(10,65535&amp;t),x=da(10,x),x=t+(x&lt;&lt;16)|0;da(10,
p);e=&quot;&quot;+(new af).Ra(65535&amp;(48+(b-x|0)|0))+e;b=k;if(0===h&amp;&amp;0===b)break}b=-1+((18-f|0)-d|0)|0;if(0&lt;d&amp;&amp;-6&lt;=b)if(d=1+b|0,0&lt;d)e=e.substring(0,d)+&quot;.&quot;+e.substring(d);else{f=-d|0;d=-1+f|0;if(!(0&gt;=f))for(f=0;;){e=&quot;&quot;+(new af).Ra(48)+e;if(f===d)break;f=1+f|0}e=&quot;0.&quot;+e}else 0!==d&amp;&amp;(d=&quot;&quot;+b,0&lt;b&amp;&amp;(d=&quot;&quot;+(new af).Ra(43)+d),d=&quot;&quot;+(new af).Ra(69)+d,1&lt;(18-f|0)?(f=65535&amp;(e.charCodeAt(0)|0),e=(new af).Ra(f)+&quot;.&quot;+e.substring(1)+d):e=&quot;&quot;+e+d);return a?&quot;&quot;+(new af).Ra(45)+e:e}}
function Ef(a,b){a=b.Ub;var d=b.bc,e=b.xb;if(0===a)return&quot;0&quot;;if(1===d)return b=(+(e.l[0]&gt;&gt;&gt;0)).toString(10),0&gt;a?&quot;-&quot;+b:b;b=&quot;&quot;;var f=la(Xa(db),[d]);Oa(e,0,f,0,d);do{for(var h=0,e=-1+d|0;0&lt;=e;){var k=h,h=f.l[e],p=Ff(Ra(),h,k,1E9,0);f.l[e]=p;var k=p&gt;&gt;31,t=65535&amp;p,p=p&gt;&gt;&gt;16|0,x=da(51712,t),t=da(15258,t),E=da(51712,p),x=x+((t+E|0)&lt;&lt;16)|0;da(1E9,k);da(15258,p);h=h-x|0;e=-1+e|0}e=&quot;&quot;+h;for(b=&quot;000000000&quot;.substring(e.length|0)+e+b;0!==d&amp;&amp;0===f.l[-1+d|0];)d=-1+d|0}while(0!==d);f=0;for(d=b.length|0;;)if(f&lt;d&amp;&amp;48===
(65535&amp;(b.charCodeAt(f)|0)))f=1+f|0;else break;b=b.substring(f);return 0&gt;a?&quot;&quot;+(new af).Ra(45)+b:b}Bf.prototype.$classData=g({ZY:0},!1,&quot;java.math.Conversion$&quot;,{ZY:1,d:1});var Cf=void 0;function Gf(){Cf||(Cf=(new Bf).b());return Cf}function Hf(){}Hf.prototype=new l;Hf.prototype.constructor=Hf;Hf.prototype.b=function(){return this};
function Gba(a,b,d,e,f,h,k){a=la(Xa(db),[1+f|0]);var p=la(Xa(db),[1+k|0]),t=fa(h.l[-1+k|0]);0!==t?(pf(Af(),p,h,0,t),pf(Af(),a,e,0,t)):(Oa(e,0,a,0,f),Oa(h,0,p,0,k));e=p.l[-1+k|0];for(d=-1+d|0;0&lt;=d;){if(a.l[f]===e)h=-1;else{var x=a.l[f],E=a.l[-1+f|0];h=Ra();var S=Ff(h,E,x,e,0),x=h.Pb;h=S;var U=65535&amp;S,S=S&gt;&gt;&gt;16|0,ga=65535&amp;e,ma=e&gt;&gt;&gt;16|0,va=da(U,ga),ga=da(S,ga),U=da(U,ma),U=va+((ga+U|0)&lt;&lt;16)|0;da(x,e);da(S,ma);E=E-U|0;if(0!==h)a:for(h=1+h|0;;){S=h=-1+h|0;ma=p.l[-2+k|0];x=65535&amp;S;S=S&gt;&gt;&gt;16|0;va=65535&amp;ma;
ma=ma&gt;&gt;&gt;16|0;U=da(x,va);va=da(S,va);ga=da(x,ma);x=U+((va+ga|0)&lt;&lt;16)|0;U=(U&gt;&gt;&gt;16|0)+ga|0;U=(da(S,ma)+(U&gt;&gt;&gt;16|0)|0)+(((65535&amp;U)+va|0)&gt;&gt;&gt;16|0)|0;ma=E;S=a.l[-2+f|0];va=E+e|0;if(0===((-2147483648^va)&lt;(-2147483648^E)?1:0)&amp;&amp;(E=va,U^=-2147483648,ma^=-2147483648,U===ma?(-2147483648^x)&gt;(-2147483648^S):U&gt;ma))continue a;break}}if(E=0!==h){If();var E=a,x=f-k|0,ma=p,S=k,U=h,Fa;Fa=0;var Va;Va=0;va=-1+S|0;if(!(0&gt;=S))for(ga=0;;){var vb=ga;Jf();var pb=ma.l[vb],Ib=65535&amp;pb,pb=pb&gt;&gt;&gt;16|0,kc=65535&amp;U,$a=U&gt;&gt;&gt;16|0,fc=da(Ib,
kc),kc=da(pb,kc),Bc=da(Ib,$a),Ib=fc+((kc+Bc|0)&lt;&lt;16)|0,fc=(fc&gt;&gt;&gt;16|0)+Bc|0,$a=(da(pb,$a)+(fc&gt;&gt;&gt;16|0)|0)+(((65535&amp;fc)+kc|0)&gt;&gt;&gt;16|0)|0,pb=Ib+Fa|0;Fa=(-2147483648^pb)&lt;(-2147483648^Ib)?1+$a|0:$a;$a=E.l[x+vb|0];pb=$a-pb|0;$a=(-2147483648^pb)&gt;(-2147483648^$a)?-1:0;Ib=Va;Va=Ib&gt;&gt;31;Ib=pb+Ib|0;Va=(-2147483648^Ib)&lt;(-2147483648^pb)?1+($a+Va|0)|0:$a+Va|0;E.l[x+vb|0]=Ib;if(ga===va)break;ga=1+ga|0}U=E.l[x+S|0];ma=U-Fa|0;U=(-2147483648^ma)&gt;(-2147483648^U)?-1:0;ga=Va;va=ga&gt;&gt;31;ga=ma+ga|0;E.l[x+S|0]=ga;E=0!==((-2147483648^
ga)&lt;(-2147483648^ma)?1+(U+va|0)|0:U+va|0)}if(E&amp;&amp;(h=-1+h|0,ga=va=0,E=-1+k|0,!(0&gt;=k)))for(x=0;;){S=x;U=a.l[(f-k|0)+S|0];ma=U+p.l[S]|0;U=(-2147483648^ma)&lt;(-2147483648^U)?1:0;ma=va+ma|0;U=(-2147483648^ma)&lt;(-2147483648^va)?1+(ga+U|0)|0:ga+U|0;va=ma;ga=U;a.l[(f-k|0)+S|0]=va;va=ga;ga=0;if(x===E)break;x=1+x|0}null!==b&amp;&amp;(b.l[d]=h);f=-1+f|0;d=-1+d|0}return 0!==t?(Eba(Af(),p,k,a,0,t),p):(Oa(a,0,p,0,k),a)}
function Hba(a,b,d,e,f){a=0;for(e=-1+e|0;0&lt;=e;){var h=a;a=d.l[e];var k=Ra(),h=Ff(k,a,h,f,0),k=k.Pb,p=65535&amp;h,t=h&gt;&gt;&gt;16|0,x=65535&amp;f,E=f&gt;&gt;&gt;16|0,S=da(p,x),x=da(t,x),p=da(p,E),S=S+((x+p|0)&lt;&lt;16)|0;da(k,f);da(t,E);a=a-S|0;b.l[e]=h;e=-1+e|0}return a}Hf.prototype.$classData=g({$Y:0},!1,&quot;java.math.Division$&quot;,{$Y:1,d:1});var Kf=void 0;function If(){Kf||(Kf=(new Hf).b());return Kf}function Lf(){}Lf.prototype=new l;Lf.prototype.constructor=Lf;Lf.prototype.b=function(){return this};
function Mf(a,b,d,e){for(var f=la(Xa(db),[b]),h=0,k=0;h&lt;e;){var p=a.l[h],t=p-d.l[h]|0,p=(-2147483648^t)&gt;(-2147483648^p)?-1:0,x=k,k=x&gt;&gt;31,x=t+x|0,t=(-2147483648^x)&lt;(-2147483648^t)?1+(p+k|0)|0:p+k|0;f.l[h]=x;k=t;h=1+h|0}for(;h&lt;b;)d=a.l[h],t=k,e=t&gt;&gt;31,t=d+t|0,d=(-2147483648^t)&lt;(-2147483648^d)?1+e|0:e,f.l[h]=t,k=d,h=1+h|0;return f}function Nf(a,b,d,e){for(a=-1+e|0;0&lt;=a&amp;&amp;b.l[a]===d.l[a];)a=-1+a|0;return 0&gt;a?0:(-2147483648^b.l[a])&lt;(-2147483648^d.l[a])?-1:1}
function Of(a,b,d,e){var f=la(Xa(db),[1+b|0]),h=1,k=a.l[0],p=k+d.l[0]|0;f.l[0]=p;k=(-2147483648^p)&lt;(-2147483648^k)?1:0;if(b&gt;=e){for(;h&lt;e;){var t=a.l[h],p=t+d.l[h]|0,t=(-2147483648^p)&lt;(-2147483648^t)?1:0,k=p+k|0,p=(-2147483648^k)&lt;(-2147483648^p)?1+t|0:t;f.l[h]=k;k=p;h=1+h|0}for(;h&lt;b;)d=a.l[h],e=d+k|0,d=(-2147483648^e)&lt;(-2147483648^d)?1:0,f.l[h]=e,k=d,h=1+h|0}else{for(;h&lt;b;)t=a.l[h],p=t+d.l[h]|0,t=(-2147483648^p)&lt;(-2147483648^t)?1:0,k=p+k|0,p=(-2147483648^k)&lt;(-2147483648^p)?1+t|0:t,f.l[h]=k,k=p,h=1+
h|0;for(;h&lt;e;)a=d.l[h],b=a+k|0,a=(-2147483648^b)&lt;(-2147483648^a)?1:0,f.l[h]=b,k=a,h=1+h|0}0!==k&amp;&amp;(f.l[h]=k);return f}
function Pf(a,b,d){a=b.Ub;var e=d.Ub,f=b.bc,h=d.bc;if(0===a)return d;if(0===e)return b;if(2===(f+h|0)){b=b.xb.l[0];d=d.xb.l[0];if(a===e)return e=b+d|0,d=(-2147483648^e)&lt;(-2147483648^b)?1:0,0===d?(new rf).ia(a,e):qf(new rf,a,2,Qf(Rf(),e,(new w).f([d])));e=wf();0&gt;a?(a=b=d-b|0,d=(-2147483648^b)&gt;(-2147483648^d)?-1:0):(a=d=b-d|0,d=(-2147483648^d)&gt;(-2147483648^b)?-1:0);return Tf(e,(new Vb).ia(a,d))}if(a===e)e=f&gt;=h?Of(b.xb,f,d.xb,h):Of(d.xb,h,b.xb,f);else{var k=f!==h?f&gt;h?1:-1:Nf(0,b.xb,d.xb,f);if(0===k)return wf().Bj;
1===k?e=Mf(b.xb,f,d.xb,h):(d=Mf(d.xb,h,b.xb,f),a=e,e=d)}a=qf(new rf,a|0,e.l.length,e);uf(a);return a}
function Wf(a,b,d){var e=b.Ub;a=d.Ub;var f=b.bc,h=d.bc;if(0===a)return b;if(0===e)return Iba(d);if(2===(f+h|0))return b=b.xb.l[0],f=0,d=d.xb.l[0],h=0,0&gt;e&amp;&amp;(e=b,b=-e|0,f=0!==e?~f:-f|0),0&gt;a&amp;&amp;(a=d,e=h,d=-a|0,h=0!==a?~e:-e|0),a=wf(),e=b,b=f,f=h,d=e-d|0,Tf(a,(new Vb).ia(d,(-2147483648^d)&gt;(-2147483648^e)?-1+(b-f|0)|0:b-f|0));var k=f!==h?f&gt;h?1:-1:Nf(Xf(),b.xb,d.xb,f);if(e===a&amp;&amp;0===k)return wf().Bj;-1===k?(d=e===a?Mf(d.xb,h,b.xb,f):Of(d.xb,h,b.xb,f),a=-a|0):(d=e===a?Mf(b.xb,f,d.xb,h):Of(b.xb,f,d.xb,h),a=
e);a=qf(new rf,a|0,d.l.length,d);uf(a);return a}Lf.prototype.$classData=g({aZ:0},!1,&quot;java.math.Elementary$&quot;,{aZ:1,d:1});var Yf=void 0;function Xf(){Yf||(Yf=(new Lf).b());return Yf}function Zf(){this.Jh=0;this.Bq=null}Zf.prototype=new l;Zf.prototype.constructor=Zf;Zf.prototype.o=function(a){return a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.ZG?this.Jh===a.Jh?this.Bq===a.Bq:!1:!1};Zf.prototype.k=function(){return&quot;precision\x3d&quot;+this.Jh+&quot; roundingMode\x3d&quot;+this.Bq};Zf.prototype.r=function(){return this.Jh&lt;&lt;3|this.Bq.aG};
Zf.prototype.$classData=g({ZG:0},!1,&quot;java.math.MathContext&quot;,{ZG:1,d:1});function $f(){this.sG=null}$f.prototype=new l;$f.prototype.constructor=$f;$f.prototype.b=function(){ag=this;bg();var a=cg().jw,b=new Zf;b.Jh=34;b.Bq=a;this.sG=b;bg();cg();bg();cg();bg();cg();return this};$f.prototype.$classData=g({bZ:0},!1,&quot;java.math.MathContext$&quot;,{bZ:1,d:1});var ag=void 0;function bg(){ag||(ag=(new $f).b());return ag}function dg(){this.ao=this.bo=this.ZB=null}dg.prototype=new l;dg.prototype.constructor=dg;
dg.prototype.b=function(){eg=this;this.ZB=Jba(10,10);Jba(14,5);this.bo=la(Xa(kf),[32]);this.ao=la(Xa(kf),[32]);var a,b;a=1;for(var d=b=0;;){var e=d;if(18&gt;=e){this.ao.l[e]=Tf(wf(),(new Vb).ia(a,b));var f=this.bo,h=wf(),k=a,p=b;f.l[e]=Tf(h,(new Vb).ia(0===(32&amp;e)?k&lt;&lt;e:0,0===(32&amp;e)?(k&gt;&gt;&gt;1|0)&gt;&gt;&gt;(31-e|0)|0|p&lt;&lt;e:k&lt;&lt;e));e=a;a=e&gt;&gt;&gt;16|0;e=da(5,65535&amp;e);f=da(5,a);a=e+(f&lt;&lt;16)|0;e=(e&gt;&gt;&gt;16|0)+f|0;b=da(5,b)+(e&gt;&gt;&gt;16|0)|0}else this.ao.l[e]=fg(this.ao.l[-1+e|0],this.ao.l[1]),this.bo.l[e]=fg(this.bo.l[-1+e|0],wf().Ap);
if(31===d)break;d=1+d|0}return this};
function Kba(a,b,d){var e,f=-1+b|0;if(!(0&gt;=b))for(var h=0;;){var k=h;e=0;var p=1+k|0,t=-1+b|0;if(!(p&gt;=b))for(;;){var x=p,E=a.l[k],S=a.l[x],U=d.l[k+x|0],ga=65535&amp;E,E=E&gt;&gt;&gt;16|0,ma=65535&amp;S,S=S&gt;&gt;&gt;16|0,va=da(ga,ma),ma=da(E,ma),Fa=da(ga,S),ga=va+((ma+Fa|0)&lt;&lt;16)|0,va=(va&gt;&gt;&gt;16|0)+Fa|0,E=(da(E,S)+(va&gt;&gt;&gt;16|0)|0)+(((65535&amp;va)+ma|0)&gt;&gt;&gt;16|0)|0,U=ga+U|0,E=(-2147483648^U)&lt;(-2147483648^ga)?1+E|0:E;e=U+e|0;U=(-2147483648^e)&lt;(-2147483648^U)?1+E|0:E;d.l[k+x|0]=e;e=U;if(p===t)break;p=1+p|0}d.l[k+b|0]=e;if(h===f)break;
h=1+h|0}Bba(Af(),d,d,b&lt;&lt;1);for(h=f=e=0;f&lt;b;)p=a.l[f],x=a.l[f],t=d.l[h],k=e,e=65535&amp;p,p=p&gt;&gt;&gt;16|0,E=65535&amp;x,x=x&gt;&gt;&gt;16|0,U=da(e,E),E=da(p,E),S=da(e,x),e=U+((E+S|0)&lt;&lt;16)|0,U=(U&gt;&gt;&gt;16|0)+S|0,p=(da(p,x)+(U&gt;&gt;&gt;16|0)|0)+(((65535&amp;U)+E|0)&gt;&gt;&gt;16|0)|0,t=e+t|0,p=(-2147483648^t)&lt;(-2147483648^e)?1+p|0:p,k=t+k|0,t=(-2147483648^k)&lt;(-2147483648^t)?1+p|0:p,d.l[h]=k,h=1+h|0,k=t+d.l[h]|0,t=(-2147483648^k)&lt;(-2147483648^t)?1:0,d.l[h]=k,e=t,f=1+f|0,h=1+h|0;return d}
function Jba(a,b){var d=la(Xa(db),[-1+a|0]);a=[];var e,f=e=1;a.push(null===f?0:f);f=0;for(d=d.l.length;f&lt;d;){var h=e=da(e|0,b);a.push(null===h?0:h);f=1+f|0}return ka(Xa(db),a)}
function gg(a,b,d){if(d.bc&gt;b.bc)var e=d;else e=b,b=d;d=e;var f=b;if(63&gt;f.bc){var h=d.bc,e=f.bc;b=h+e|0;a=d.Ub!==f.Ub?-1:1;if(2===b){e=d.xb.l[0];b=f.xb.l[0];d=65535&amp;e;var e=e&gt;&gt;&gt;16|0,k=65535&amp;b;b=b&gt;&gt;&gt;16|0;var f=da(d,k),k=da(e,k),p=da(d,b);d=f+((k+p|0)&lt;&lt;16)|0;f=(f&gt;&gt;&gt;16|0)+p|0;e=(da(e,b)+(f&gt;&gt;&gt;16|0)|0)+(((65535&amp;f)+k|0)&gt;&gt;&gt;16|0)|0;a=0===e?(new rf).ia(a,d):qf(new rf,a,2,Qf(Rf(),d,(new w).f([e])))}else{d=d.xb;f=f.xb;k=la(Xa(db),[b]);if(0!==h&amp;&amp;0!==e)if(1===h)k.l[e]=hg(0,k,f,e,d.l[0]);else if(1===e)k.l[h]=hg(0,
k,d,h,f.l[0]);else if(d===f&amp;&amp;h===e)Kba(d,h,k);else if(p=-1+h|0,!(0&gt;=h))for(h=0;;){var t=h,x;x=0;var E=d.l[t],S=-1+e|0;if(!(0&gt;=e))for(var U=0;;){var ga=U,ma=f.l[ga],va=k.l[t+ga|0],Fa=65535&amp;E,Va=E&gt;&gt;&gt;16|0,vb=65535&amp;ma,ma=ma&gt;&gt;&gt;16|0,pb=da(Fa,vb),vb=da(Va,vb),Ib=da(Fa,ma),Fa=pb+((vb+Ib|0)&lt;&lt;16)|0,pb=(pb&gt;&gt;&gt;16|0)+Ib|0,Va=(da(Va,ma)+(pb&gt;&gt;&gt;16|0)|0)+(((65535&amp;pb)+vb|0)&gt;&gt;&gt;16|0)|0,va=Fa+va|0,Va=(-2147483648^va)&lt;(-2147483648^Fa)?1+Va|0:Va;x=va+x|0;va=(-2147483648^x)&lt;(-2147483648^va)?1+Va|0:Va;k.l[t+ga|0]=x;x=va;if(U===
S)break;U=1+U|0}k.l[t+e|0]=x;if(h===p)break;h=1+h|0}a=qf(new rf,a,b,k);uf(a)}return a}e=(-2&amp;d.bc)&lt;&lt;4;k=ig(d,e);p=ig(f,e);b=jg(k,e);h=Wf(Xf(),d,b);b=jg(p,e);f=Wf(Xf(),f,b);d=gg(a,k,p);b=gg(a,h,f);a=gg(a,Wf(Xf(),k,h),Wf(Xf(),f,p));f=d;a=Pf(Xf(),a,f);a=Pf(Xf(),a,b);a=jg(a,e);e=d=jg(d,e&lt;&lt;1);a=Pf(Xf(),e,a);return Pf(Xf(),a,b)}
function hg(a,b,d,e,f){var h;h=0;a=-1+e|0;if(!(0&gt;=e))for(e=0;;){var k=e,p=d.l[k],t=65535&amp;p,p=p&gt;&gt;&gt;16|0,x=65535&amp;f,E=f&gt;&gt;&gt;16|0,S=da(t,x),x=da(p,x),U=da(t,E),t=S+((x+U|0)&lt;&lt;16)|0,S=(S&gt;&gt;&gt;16|0)+U|0,p=(da(p,E)+(S&gt;&gt;&gt;16|0)|0)+(((65535&amp;S)+x|0)&gt;&gt;&gt;16|0)|0;h=t+h|0;p=(-2147483648^h)&lt;(-2147483648^t)?1+p|0:p;b.l[k]=h;h=p;if(e===a)break;e=1+e|0}return h}
function kg(a,b){var d=a.bo.l.length,e=d&gt;&gt;31,f=b.qa;if(f===e?(-2147483648^b.ka)&lt;(-2147483648^d):f&lt;e)return a.bo.l[b.ka];d=b.qa;if(0===d?-2147483598&gt;=(-2147483648^b.ka):0&gt;d)return lg(wf().Ap,b.ka);d=b.qa;if(0===d?-1&gt;=(-2147483648^b.ka):0&gt;d)return jg(lg(a.ao.l[1],b.ka),b.ka);for(var h=lg(a.ao.l[1],2147483647),d=h,f=b.qa,k=-2147483647+b.ka|0,e=k,k=1&gt;(-2147483648^k)?f:-1+f|0,f=mg(Ra(),b.ka,b.qa,2147483647,0);;){var p=e,t=k;if(0===t?-1&lt;(-2147483648^p):0&lt;t)d=fg(d,h),e=-2147483647+e|0,k=1&gt;(-2147483648^e)?
k:-1+k|0;else break}d=fg(d,lg(a.ao.l[1],f));d=jg(d,2147483647);a=b.qa;e=b=-2147483647+b.ka|0;for(k=1&gt;(-2147483648^b)?a:-1+a|0;;)if(b=e,a=k,0===a?-1&lt;(-2147483648^b):0&lt;a)d=jg(d,2147483647),b=k,a=-2147483647+e|0,b=1&gt;(-2147483648^a)?b:-1+b|0,e=a,k=b;else break;return jg(d,f)}dg.prototype.$classData=g({cZ:0},!1,&quot;java.math.Multiplication$&quot;,{cZ:1,d:1});var eg=void 0;function Jf(){eg||(eg=(new dg).b());return eg}function ng(){this.bj=this.sV=null;this.a=0}ng.prototype=new l;ng.prototype.constructor=ng;
ng.prototype.b=function(){sg=this;this.sV=&quot;\x3cBREEDS?\x3e&quot;;this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;B();var a=(new w).f([(new tg).sd(&quot;CREATE-ORDERED-\x3cBREEDS\x3e&quot;,ug(),&quot;_createorderedturtles&quot;),(new tg).sd(&quot;CREATE-\x3cBREEDS\x3e&quot;,ug(),&quot;_createturtles&quot;),(new tg).sd(&quot;HATCH-\x3cBREEDS\x3e&quot;,ug(),&quot;_hatch&quot;),(new tg).sd(&quot;SPROUT-\x3cBREEDS\x3e&quot;,ug(),&quot;_sprout&quot;),(new tg).sd(&quot;\x3cBREEDS\x3e&quot;,vg(),&quot;_breed&quot;),(new tg).sd(&quot;\x3cBREEDS\x3e-AT&quot;,vg(),&quot;etc._breedat&quot;),(new tg).sd(&quot;\x3cBREEDS\x3e-HERE&quot;,vg(),&quot;etc._breedhere&quot;),(new tg).sd(&quot;\x3cBREEDS\x3e-ON&quot;,
vg(),&quot;etc._breedon&quot;),(new tg).sd(&quot;\x3cBREED\x3e&quot;,vg(),&quot;etc._breedsingular&quot;),(new tg).sd(&quot;IS-\x3cBREED\x3e?&quot;,vg(),&quot;etc._isbreed&quot;),(new wg).sd(&quot;CREATE-\x3cBREEDS\x3e-FROM&quot;,ug(),&quot;etc._createlinksfrom&quot;),(new wg).sd(&quot;CREATE-\x3cBREED\x3e-FROM&quot;,ug(),&quot;etc._createlinkfrom&quot;),(new wg).sd(&quot;CREATE-\x3cBREEDS\x3e-TO&quot;,ug(),&quot;etc._createlinksto&quot;),(new xg).sd(&quot;CREATE-\x3cBREEDS\x3e-WITH&quot;,ug(),&quot;etc._createlinkswith&quot;),(new wg).sd(&quot;CREATE-\x3cBREED\x3e-TO&quot;,ug(),&quot;etc._createlinkto&quot;),(new xg).sd(&quot;CREATE-\x3cBREED\x3e-WITH&quot;,
ug(),&quot;etc._createlinkwith&quot;),(new yg).sd(&quot;IN-\x3cBREED\x3e-FROM&quot;,vg(),&quot;etc._inlinkfrom&quot;),(new yg).sd(&quot;IN-\x3cBREED\x3e-NEIGHBOR?&quot;,vg(),&quot;etc._inlinkneighbor&quot;),(new yg).sd(&quot;IN-\x3cBREED\x3e-NEIGHBORS&quot;,vg(),&quot;etc._inlinkneighbors&quot;),(new yg).sd(&quot;IS-\x3cBREED\x3e?&quot;,vg(),&quot;etc._isbreed&quot;),(new yg).sd(&quot;\x3cBREEDS\x3e&quot;,vg(),&quot;etc._linkbreed&quot;),(new yg).sd(&quot;\x3cBREED\x3e&quot;,vg(),&quot;etc._linkbreedsingular&quot;),(new yg).sd(&quot;\x3cBREED\x3e-NEIGHBOR?&quot;,vg(),&quot;etc._linkneighbor&quot;),(new yg).sd(&quot;\x3cBREED\x3e-NEIGHBORS&quot;,vg(),&quot;etc._linkneighbors&quot;),
(new yg).sd(&quot;\x3cBREED\x3e-WITH&quot;,vg(),&quot;etc._linkwith&quot;),(new yg).sd(&quot;MY-IN-\x3cBREEDS\x3e&quot;,vg(),&quot;etc._myinlinks&quot;),(new yg).sd(&quot;MY-\x3cBREEDS\x3e&quot;,vg(),&quot;etc._mylinks&quot;),(new yg).sd(&quot;MY-OUT-\x3cBREEDS\x3e&quot;,vg(),&quot;etc._myoutlinks&quot;),(new yg).sd(&quot;OUT-\x3cBREED\x3e-NEIGHBOR?&quot;,vg(),&quot;etc._outlinkneighbor&quot;),(new yg).sd(&quot;OUT-\x3cBREED\x3e-NEIGHBORS&quot;,vg(),&quot;etc._outlinkneighbors&quot;),(new yg).sd(&quot;OUT-\x3cBREED\x3e-TO&quot;,vg(),&quot;etc._outlinkto&quot;)]),b=B().s;this.bj=L(a,b);this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;return this};
function Lba(a,b){return Qb(Ia(),Qb(Ia(),b.Ld,&quot;\x3cBREEDS\x3e&quot;,a.ql.va),&quot;\x3cBREED\x3e&quot;,a.Bf.va)}function zg(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/BreedIdentifierHandler.scala: 16&quot;);return a.bj}function Mba(a,b,d){return b.Kg&amp;&amp;b.Jg?(new Ag).iu(a,d):b.Kg?(new Bg).iu(a,d):(new Cg).iu(a,d)}
function saa(a){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/BreedIdentifierHandler.scala: 14&quot;);return a.sV}function Nba(a,b){var d=zg(a);a=Oba(a,b,vg()).Cj(m(new n,function(a,b){return function(a){return Lba(b,a)}}(a,b)));b=B();return d.ic(a,b.s)}
function Oba(a,b,d){return Mba(d,b,m(new n,function(a){return function(b){var d=u((new v).K((new w).f([&quot;^&quot;,&quot;$&quot;])),(new w).f([saa(a)]));if(null===b)throw(new Oe).b();var k=Dg(),d=Eg(k,d);return!Pba(Fg(new Gg,d,b,La(b)))}}(a)))}function Qba(a,b){var d=zg(a);a=Oba(a,b,ug()).Cj(m(new n,function(a,b){return function(a){return Lba(b,a)}}(a,b)));b=B();return d.ic(a,b.s)}
function Rba(a,b,d){return zg(a).Ic().aj(m(new n,function(a,b,d){return function(a){var e=b.X,e=Hg(a.Tx(),e);if(e.z())t=!1;else if(null!==e.Y())var t=e.Y(),t=0===Ig(t,1);else t=!1;if(t){var e=e.Y().W(0),t=(new Kc).fg(a.Yw(d)),x=new Jg;if(null===a)throw Kg(Lg(),null);x.Sa=a;x.qq=e;a=Mg(t,x)}else a=F();return a.ub()}}(a,b,d)),(Ng(),(new Og).b())).wg()}ng.prototype.$classData=g({mZ:0},!1,&quot;org.nlogo.core.BreedIdentifierHandler$&quot;,{mZ:1,d:1});var sg=void 0;
function Rb(){sg||(sg=(new ng).b());return sg}function Pg(){}Pg.prototype=new l;Pg.prototype.constructor=Pg;Pg.prototype.b=function(){return this};function Sba(a,b){if(Qg(b))return(new Wg).c(b);if(&quot;number&quot;===typeof b)return(new Xg).LD(b);if(&quot;boolean&quot;===typeof b)return(new Yg).qu(b);if(Zg(b))return Tba(b);throw Kg(Lg(),(new $g).c(u((new v).K((new w).f([&quot;Invalid chooser option &quot;,&quot;&quot;])),(new w).f([b]))));}Pg.prototype.$classData=g({rZ:0},!1,&quot;org.nlogo.core.Chooseable$&quot;,{rZ:1,d:1});var ah=void 0;
function Uba(){ah||(ah=(new Pg).b());return ah}function bh(){this.nG=null;this.lS=this.hG=0;this.oG=null;this.a=0}bh.prototype=new l;bh.prototype.constructor=bh;
bh.prototype.b=function(){ch=this;var a=(new w).f(&quot;gray red orange brown yellow green lime turquoise cyan sky blue violet magenta pink black white&quot;.split(&quot; &quot;)),b=a.oa.length|0,b=la(Xa(qa),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e;d=1+d|0}this.nG=b;this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;this.hG=0;this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;this.lS=9.9;this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;a=(new w).f([5,15,25,35,45,55,65,75,85,95,105,115,125,135,Vba(this),Wba(this)]);b=a.oa.length|0;b=la(Xa(gb),[b]);d=0;for(a=
lf(new mf,a,0,a.oa.length|0);a.ta();)e=a.ma(),b.l[d]=+e,d=1+d|0;this.oG=b;this.a=(8|this.a)&lt;&lt;24&gt;&gt;24;return this};function Wba(a){if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ColorConstants.scala: 17&quot;);return a.lS}function Xba(){var a=dh();if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ColorConstants.scala: 8&quot;);return a.nG}
function Vba(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ColorConstants.scala: 16&quot;);return a.hG}function Yba(a,b){if(0===(8&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ColorConstants.scala: 19&quot;);return a.oG.l[b]}bh.prototype.$classData=g({vZ:0},!1,&quot;org.nlogo.core.ColorConstants$&quot;,{vZ:1,d:1});var ch=void 0;function dh(){ch||(ch=(new bh).b());return ch}
var $ba=function Zba(b,d){if(Qg(d))return u((new v).K((new w).f(['&quot;','&quot;'])),(new w).f([eh(fh(),d)]));if(&quot;boolean&quot;===typeof d)return d?&quot;true&quot;:&quot;false&quot;;if(gh(d)){b=function(b){return function(d){return Zba(b,d)}}(b);var e=B().s;if(e===B().s)if(d===y())b=y();else{var e=d.$(),f=e=Cd(new Dd,b(e),y());for(d=d.aa();d!==y();){var h=d.$(),h=Cd(new Dd,b(h),y()),f=f.Ia=h;d=d.aa()}b=e}else{for(e=Mc(d,e);!d.z();)f=d.$(),e.Na(b(f)),d=d.aa();b=e.Da()}return b.Oc(&quot;[&quot;,&quot; &quot;,&quot;]&quot;)}if(Zg(d)){e=B().s;d=L(d,e);b=function(b){return function(d){return Zba(b,
d)}}(b);e=B().s;if(e===B().s)if(d===y())b=y();else{e=d.$();f=e=Cd(new Dd,b(e),y());for(d=d.aa();d!==y();)h=d.$(),h=Cd(new Dd,b(h),y()),f=f.Ia=h,d=d.aa();b=e}else{for(e=Mc(d,e);!d.z();)f=d.$(),e.Na(b(f)),d=d.aa();b=e.Da()}return b.Oc(&quot;[&quot;,&quot; &quot;,&quot;]&quot;)}if(null!==d)return na(d);throw(new q).j(d);};function hh(){this.g=null}hh.prototype=new l;hh.prototype.constructor=hh;hh.prototype.Ff=function(a){this.g=a;return this};hh.prototype.$classData=g({EZ:0},!1,&quot;org.nlogo.core.ErrorSource&quot;,{EZ:1,d:1});
function ih(){}ih.prototype=new l;ih.prototype.constructor=ih;ih.prototype.b=function(){return this};function jh(a,b,d,e){throw(new hd).ms(a,b,d,e);}ih.prototype.$classData=g({GZ:0},!1,&quot;org.nlogo.core.Fail$&quot;,{GZ:1,d:1});var aca=void 0;function kh(){aca||(aca=(new ih).b())}function lh(){this.HR=null;this.a=!1}lh.prototype=new l;lh.prototype.constructor=lh;lh.prototype.b=function(){mh=this;this.HR=nh(oh(),y());this.a=!0;return this};
function ph(){var a;mh||(mh=(new lh).b());a=mh;if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/FrontEndInterface.scala: 12&quot;);return a.HR}lh.prototype.$classData=g({HZ:0},!1,&quot;org.nlogo.core.FrontEndInterface$&quot;,{HZ:1,d:1});var mh=void 0;function qh(){this.Fo=null;this.ya=!1}qh.prototype=new l;qh.prototype.constructor=qh;qh.prototype.b=function(){return this};
function rh(){var a;sh||(sh=(new qh).b());a=sh;if(!a.ya&amp;&amp;!a.ya){for(var b=[(new A).e(&quot;org.nlogo.prim.$common.expectedBooleanValue&quot;,&quot;{0} expected a true/false value from {1}, but got {2} instead.&quot;),(new A).e(&quot;org.nlogo.prim._max.cantFindMaxOfListWithNoNumbers&quot;,&quot;Can<I>t find the maximum of a list with no numbers: {0}&quot;),(new A).e(&quot;org.nlogo.agent.Turtle.cantSetBreedToNonBreedAgentSet&quot;,&quot;You can</I>t set BREED to a non-breed agentset.&quot;),(new A).e(&quot;org.nlogo.prim.etc._atpoints.invalidListOfPoints&quot;,&quot;Invalid list of points: {0}&quot;),
(new A).e(&quot;org.nlogo.prim.etc.atan.bothInputsCannotBeZero&quot;,&quot;atan is undefined when both inputs are zero.&quot;),(new A).e(&quot;org.nlogo.agent.Agent.notADoubleVariable&quot;,&quot;{0} is not a double variable.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.requestMoreItemsThanInList&quot;,&quot;Requested {0} random items from a list of length {1}.&quot;),(new A).e(&quot;org.nlogo.agent.Turtle.cantAccessLinkWithoutSpecifyingLink&quot;,&quot;A turtle can<I>t access a link variable without specifying which link.&quot;),(new A).e(&quot;org.nlogo.agent.Patch.cantAccessTurtleWithoutSpecifyingTurtle&quot;,</I>
&quot;A patch can<I>t access a turtle variable without specifying which turtle.&quot;),(new A).e(&quot;org.nlogo.agent.Protractor.noHeadingFromAgentToSelf&quot;,&quot;No heading is defined from an agent to itself.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.divByZero&quot;,&quot;Division by zero.&quot;),(new A).e(&quot;org.nlogo.workspace.DefaultFileManager.cannotDeleteNonExistantFile&quot;,&quot;You cannot delete a non-existent file.&quot;),(new A).e(&quot;org.nlogo.agent.Topology.cantMoveTurtleBeyondWorldEdge&quot;,&quot;Cannot move turtle beyond the world</I>s edge.&quot;),(new A).e(&quot;org.nlogo.agent.Link.cantSetBreedToNonLinkBreedAgentSet&quot;,
&quot;You can<I>t set BREED to a non-link-breed agentset.&quot;),(new A).e(&quot;org.nlogo.prim.etc._foreach.listsMustBeSameLength&quot;,&quot;All the list arguments to FOREACH must be the same length.&quot;),(new A).e(&quot;compiler.StructureParser.includeNotFound&quot;,&quot;Could not find {0}&quot;),(new A).e(&quot;org.nlogo.prim.etc._randomNormal.secondInputNotNegative&quot;,&quot;random-normal</I>s second input can<I>t be negative.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.tickCounterNotStarted&quot;,&quot;The tick counter has not been started yet. Use RESET-TICKS.&quot;),(new A).e(&quot;org.nlogo.prim._lessorequal.cannotCompareParameters&quot;,</I>
&quot;The \x3c\x3d operator can only be used on two numbers, two strings, or two agents of the same type, but not on {0} and {1}.&quot;),(new A).e(&quot;org.nlogo.agent.Protractor.noHeadingFromPointToSelf&quot;,&quot;No heading is defined from a point ({0},{1}) to that same point.&quot;),(new A).e(&quot;org.nlogo.agent.Agent.shapeUndefined&quot;,'&quot;{0}&quot; is not a currently defined shape.'),(new A).e(&quot;org.nlogo.prim.etc._variance.listMustHaveMoreThanOneNumber&quot;,&quot;Can<I>t find the variance of a list without at least two numbers: {0}.&quot;),(new A).e(&quot;compiler.LocalsVisitor.notDefined&quot;,</I>
&quot;Nothing named {0} has been defined.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.cantTakeLogarithmOf&quot;,&quot;Can<I>t take logarithm of {0}.&quot;),(new A).e(&quot;org.nlogo.prim.$common.invalidAgentKind.simple&quot;,&quot;this code can</I>t be run by {0}&quot;),(new A).e(&quot;org.nlogo.prim.$common.withExpectedBooleanValue&quot;,&quot;WITH expected a true/false value from {0}, but got {1} instead.&quot;),(new A).e(&quot;org.nlogo.prim.etc._linkheading.noLinkHeadingWithSameEndpoints&quot;,&quot;There is no heading of a link whose endpoints are in the same position.&quot;),
(new A).e(&quot;org.nlogo.prim.$common.agentKind.patch&quot;,&quot;a patch&quot;),(new A).e(&quot;org.nlogo.prim._min.cantFindMinOfListWithNoNumbers&quot;,&quot;Can<I>t find the minimum of a list with no numbers: {0}&quot;),(new A).e(&quot;fileformat.invalidversion&quot;,'Invalid NetLogo file. Expected &quot;{0}&quot; formatted model to have version compatible with {1}, but this model had version {2}'),(new A).e(&quot;org.nlogo.prim.etc._sublist.endIsGreaterThanListSize&quot;,&quot;{0} is greater than the length of the input list ({1}).&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.indexExceedsStringSize&quot;,</I>
&quot;Can<I>t find element {0} of the string {1}, which is only of length {2}.&quot;),(new A).e(&quot;org.nlogo.prim.etc._runresult.failedToReportResult&quot;,&quot;Failed to report a result.&quot;),(new A).e(&quot;org.nlogo.agent.Patch.cantChangePatchCoordinates&quot;,&quot;You can</I>t change a patch<I>s coordinates.&quot;),(new A).e(&quot;org.nlogo.prim.lambda.missingInput&quot;,&quot;anonymous procedure expected 1 input, but only got 0&quot;),(new A).e(&quot;org.nlogo.prim.etc._exportoutput.emptyPath&quot;,&quot;Can</I>t export to empty pathname.&quot;),(new A).e(&quot;org.nlogo.prim.etc._myself.noAgentMyself&quot;,
&quot;There is no agent for MYSELF to refer to.&quot;),(new A).e(&quot;org.nlogo.prim.$common.onlyObserverCanAskAllPatches&quot;,&quot;Only the observer can ASK the set of all patches.&quot;),(new A).e(&quot;org.nlogo.prim.$common.turtleCantLinkToSelf&quot;,&quot;A turtle cannot link to itself.&quot;),(new A).e(&quot;org.nlogo.agent.ChooserConstraint.invalidValue&quot;,&quot;Value must be one of: {0}&quot;),(new A).e(&quot;org.nlogo.agent.Link.cantHaveBreededAndUnbreededLinks&quot;,&quot;You cannot have both breeded and unbreeded links in the same world.&quot;),(new A).e(&quot;org.nlogo.prim._returnreport.reportNotCalledInReportProcedure&quot;,
&quot;Reached end of reporter procedure without REPORT being called.&quot;),(new A).e(&quot;org.nlogo.prim.etc._turtleset.incorrectInputType&quot;,&quot;List inputs to {0} must only contain turtle or turtle agentset elements.  The list {1} contained {2} which is NOT a turtle or turtle agentset.&quot;),(new A).e(&quot;org.nlogo.prim.etc._linkset.invalidLAgentsetTypeInputToList&quot;,&quot;List inputs to {0} must only contain link, link agentset, or list elements.  The list {1} contained a different type agentset: {2}.&quot;),(new A).e(&quot;org.nlogo.agent.Patch.cantAccessLinkVarWithoutSpecifyingLink&quot;,
&quot;A patch can<I>t access a link variable without specifying which link.&quot;),(new A).e(&quot;org.nlogo.prim.$common.paramOutOfBounds&quot;,&quot;{0} is not in the range 0.0 to 1.0&quot;),(new A).e(&quot;org.nlogo.prim.etc.median.cantFindMedianOfListWithNoNumbers&quot;,&quot;Can</I>t find the median of a list with no numbers: {0}.&quot;),(new A).e(&quot;org.nlogo.prim.etc._sqrt.squareRootIsImaginary&quot;,&quot;The square root of {0} is an imaginary number.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.noNegativeNumber&quot;,&quot;{0} cannot take a negative number.&quot;),(new A).e(&quot;compiler.StructureConverter.noBreed&quot;,
'There is no breed &quot;{0}&quot;'),(new A).e(&quot;org.nlogo.prim.$common.agentKind.observer&quot;,&quot;the observer&quot;),(new A).e(&quot;org.nlogo.prim.etc._setDefaultShape.notADefinedLinkShape&quot;,'&quot;{0}&quot; is not a currently defined link shape.'),(new A).e(&quot;compiler.LetVariable.notDefined&quot;,&quot;Nothing named {0} has been defined.&quot;),(new A).e(&quot;org.nlogo.prim.lambda.missingInputs&quot;,&quot;anonymous procedure expected {0} inputs, but only got {1}&quot;),(new A).e(&quot;org.nlogo.prim.etc._setdefaultshape.canOnlySetDefaultShapeOfEntireBreed&quot;,&quot;Can only set the default shape of all turtles , all links, or an entire breed.&quot;),
(new A).e(&quot;org.nlogo.workspace.DefaultFileManager.noOpenFile&quot;,&quot;No file has been opened.&quot;),(new A).e(&quot;org.nlogo.agent.Patch.cantAccessTurtleOrLinkWithoutSpecifyingAgent&quot;,&quot;A patch can<I>t access a turtle or link variable without specifying which agent.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.syntaxError&quot;,&quot;Syntax Error: {0}&quot;),(new A).e(&quot;org.nlogo.prim.etc._median.emptyList&quot;,&quot;Can</I>t find the median of a list with no numbers: {0}&quot;),(new A).e(&quot;org.nlogo.agent.Patch.pcolorNotADouble&quot;,&quot;Pcolor is not a double.&quot;),
(new A).e(&quot;org.nlogo.prim._reduce.emptyListInvalidInput&quot;,&quot;The list argument to 'reduce' must not be empty.&quot;),(new A).e(&quot;org.nlogo.prim._lessthan.cantUseLessthanOnDifferentArgs&quot;,&quot;The \x3c operator can only be used on two numbers, two strings, or two agents of the same type, but not on {0} and {1}.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.noNegativeAngle&quot;,&quot;{0} cannot take a negative angle.&quot;),(new A).e(&quot;org.nlogo.prim.etc._resizeworld.worldMustIncludeOrigin&quot;,&quot;You must include the point (0, 0) in the world.&quot;),
(new A).e(&quot;compiler.TaskVisitor.notDefined&quot;,&quot;This special variable isn<I>t defined here.&quot;),(new A).e(&quot;org.nlogo.agent.Agent.wrongTypeOnSetError&quot;,&quot;can</I>t set {0} variable {1} to non-{2} {3}&quot;),(new A).e(&quot;org.nlogo.agent.Agent.cantMoveToLink&quot;,&quot;You can<I>t move-to a link.&quot;),(new A).e(&quot;org.nlogo.prim.etc._range.zeroStep&quot;,&quot;The step-size for range must be non-zero.&quot;),(new A).e(&quot;org.nlogo.plot.noPlotSelected&quot;,&quot;There is no current plot. Please select a current plot using the set-current-plot command.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.noAngleGreaterThan360&quot;,</I>
&quot;{0} cannot take an angle greater than 360.&quot;),(new A).e(&quot;org.nlogo.prim.etc._setDefaultShape.notADefinedTurtleShape&quot;,'&quot;{0}&quot; is not a currently defined turtle shape.'),(new A).e(&quot;org.nlogo.prim.etc._substring.endIsGreaterThanListSize&quot;,&quot;{0} is too big for {1}, which is only of length {2}.&quot;),(new A).e(&quot;org.nlogo.prim.$common.invalidAgentKind.alternative&quot;,&quot;this code can<I>t be run by {0}, only {1}&quot;),(new A).e(&quot;org.nlogo.prim.etc._setdefaultshape.cantSetDefaultShapeOfPatch&quot;,&quot;Cannot set the default shape of patches, because patches do not have shapes.&quot;),</I>
(new A).e(&quot;org.nlogo.agent.Agent.cantSetUnknownVariable&quot;,&quot;Unknown variable {0}.&quot;),(new A).e(&quot;org.nlogo.prim.etc._standarddeviation.needListGreaterThanOneItem&quot;,&quot;Can<I>t find the standard deviation of a list without at least two numbers: {0}&quot;),(new A).e(&quot;org.nlogo.prim.etc._tickadvance.noNegativeTickAdvances&quot;,&quot;Cannot advance the tick counter by a negative amount.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.negativeIndex&quot;,&quot;{0} isn</I>t greater than or equal to zero.&quot;),(new A).e(&quot;org.nlogo.prim.etc._patchset.listInputNonPatchAgentset&quot;,
&quot;List inputs to {0} must only contain patch, patch agentset, or list elements.  The list {1} contained a different type agentset: {2}.&quot;),(new A).e(&quot;org.nlogo.prim.etc._otherend.onlyTurtleCanGetLinkEnd&quot;,&quot;Only a turtle can get the OTHER-END of a link.&quot;),(new A).e(&quot;org.nlogo.prim.$common.agentKind.link&quot;,&quot;a link&quot;),(new A).e(&quot;org.nlogo.prim.etc._log.notAValidBase&quot;,&quot;{0} isn<I>t a valid base for a logarithm.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.noNegativeRadius&quot;,&quot;{0} cannot take a negative radius.&quot;),(new A).e(&quot;org.nlogo.agent.ImportPatchColors.unsupportedImageFormat&quot;,</I>
&quot;The following file is not in a supported image format: {0}&quot;),(new A).e(&quot;org.nlogo.agent.Agent.rgbValueError&quot;,&quot;RGB values must be 0-255&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.emptyListInput&quot;,&quot;{0} got an empty list as input.&quot;),(new A).e(&quot;org.nlogo.prim.etc._sublist.endIsLessThanStart&quot;,&quot;{0} is less than {1}.&quot;),(new A).e(&quot;org.nlogo.prim.etc._randomgamma.noNegativeInputs&quot;,&quot;Both inputs to {0} must be positive.&quot;),(new A).e(&quot;org.nlogo.agent.Turtle.cantChangeWho&quot;,&quot;You can<I>t change a turtle</I>s ID number.&quot;),
(new A).e(&quot;org.nlogo.prim.etc.$common.indexExceedsListSize&quot;,&quot;Can<I>t find element {0} of the list {1}, which is only of length {2}.&quot;),(new A).e(&quot;org.nlogo.prim._mean.cantFindMeanOfNonNumbers&quot;,&quot;Can</I>t find the mean of a list that contains non-numbers : {0} is a {1}.&quot;),(new A).e(&quot;org.nlogo.prim.etc._sublist.startIsLessThanZero&quot;,&quot;{0} is less than zero.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.firstInputCantBeNegative&quot;,&quot;First input to {0} can<I>t be negative.&quot;),(new A).e(&quot;org.nlogo.prim.etc._otherend.incorrectLink&quot;,</I>
&quot;{0} is not linked by {1}.&quot;),(new A).e(&quot;org.nlogo.prim.etc._turtleset.listInputsMustBeTurtleOrTurtleAgentset&quot;,&quot;List inputs to {0} must only contain turtle or turtle agentset elements.  The list {1} contained a different type agentset: {2}.&quot;),(new A).e(&quot;compiler.CarefullyVisitor.badNesting&quot;,&quot;{0} cannot be used outside of CAREFULLY.&quot;),(new A).e(&quot;org.nlogo.$common.thatAgentIsDead&quot;,&quot;That {0} is dead.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.expectedLastInputToBeLinkBreed&quot;,&quot;Expected the last input to be a link breed.&quot;),
(new A).e(&quot;compiler.SetVisitor.notSettable&quot;,&quot;This isn<I>t something you can use \&quot;set\&quot; on.&quot;),(new A).e(&quot;org.nlogo.prim.etc._patchset.listInputNonPatch&quot;,&quot;List inputs to {0} must only contain patch, patch agentset, or list elements.  The list {1} contained {2} which is NOT a patch or patch agentset.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.emptyString&quot;,&quot;String is empty.&quot;),(new A).e(&quot;org.nlogo.agent.Agent.rgbListSizeError.3or4&quot;,&quot;An rgb list must contain 3 or 4 numbers 0-255&quot;),(new A).e(&quot;org.nlogo.$common.tooBigForInt&quot;,</I>
&quot;{0} is too large to be represented exactly as an integer in NetLogo.&quot;),(new A).e(&quot;org.nlogo.prim.etc._stop.notAllowedInsideToReport&quot;,&quot;{0} is not allowed inside TO-REPORT.&quot;),(new A).e(&quot;org.nlogo.agent.Patch.cantSetTurtleWithoutSpecifyingTurtle&quot;,&quot;A patch can<I>t set a turtle variable without specifying which turtle.&quot;),(new A).e(&quot;org.nlogo.prim._report.mustImmediatelyBeUsedInToReport&quot;,&quot;{0} must be immediately inside a TO-REPORT.&quot;),(new A).e(&quot;org.nlogo.prim._askconcurrent.onlyObserverCanAskAllTurtles&quot;,</I>
&quot;only the observer can ASK the set of all turtles&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.expectedTurtleOrPatchButGotLink&quot;,&quot;Expected a turtle or a patch but got a link.&quot;),(new A).e(&quot;org.nlogo.prim.$common.agentKind.turtle&quot;,&quot;a turtle&quot;),(new A).e(&quot;org.nlogo.agent.Turtle.patchBeyondLimits&quot;,&quot;Cannot get patch beyond limits of current world.&quot;),(new A).e(&quot;org.nlogo.prim.etc._linkset.invalidListInputs&quot;,&quot;List inputs to {0} must only contain link, link agentset, or list elements.  The list {1} contained {2} which is NOT a link or link agentset.&quot;),
(new A).e(&quot;org.nlogo.prim.etc.$common.emptyStringInput&quot;,&quot;{0} got an empty string as input.&quot;),(new A).e(&quot;org.nlogo.prim.etc._setxy.pointOutsideWorld&quot;,&quot;The point [ {0} , {1} ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.&quot;),(new A).e(&quot;org.nlogo.prim._greaterorequal.cannotCompareParameters&quot;,&quot;The \x3e\x3d operator can only be used on two numbers, two strings, or two agents of the same type, but not on {0} and {1}.&quot;),(new A).e(&quot;org.nlogo.workspace.DefaultFileManager.canOnlyDeleteFiles&quot;,
&quot;You can only delete files.&quot;),(new A).e(&quot;org.nlogo.prim._report.canOnlyUseInToReport&quot;,&quot;{0} can only be used inside TO-REPORT.&quot;),(new A).e(&quot;org.nlogo.prim.$common.noSumOfListWithNonNumbers&quot;,&quot;Can<I>t find the sum of a list that contains non-numbers {0} is a {1}.&quot;),(new A).e(&quot;org.nlogo.prim.etc._layoutcircle.patchesImmovable&quot;,&quot;Patches are immovable.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.notThatManyAgentsExist&quot;,&quot;Requested {0} random agents from a set of only {1} agents.&quot;),(new A).e(&quot;org.nlogo.agent.Agent.rgbListSizeError.3&quot;,</I>
&quot;An rgb list must contain 3 numbers 0-255&quot;),(new A).e(&quot;org.nlogo.prim.etc._otherend.onlyLinkCanGetTurtleEnd&quot;,&quot;Only a link can get the OTHER-END from a turtle.&quot;),(new A).e(&quot;org.nlogo.prim.$common.onlyObserverCanAskAllTurtles&quot;,&quot;Only the observer can ASK the set of all turtles.&quot;),(new A).e(&quot;org.nlogo.agent.BooleanConstraint.bool&quot;,&quot;Value must be a boolean.&quot;),(new A).e(&quot;org.nlogo.prim.etc.$common.emptyList&quot;,&quot;List is empty.&quot;),(new A).e(&quot;org.nlogo.prim._greaterthan.cannotCompareParameters&quot;,&quot;The \x3e operator can only be used on two numbers, two strings, or two agents of the same type, but not on {0} and {1}.&quot;),
(new A).e(&quot;org.nlogo.agent.Agent.breedDoesNotOwnVariable&quot;,&quot;{0} breed does not own variable {1}&quot;)],d=dc(new ec,gc()),e=0,f=b.length|0;e&lt;f;)hc(d,b[e]),e=1+e|0;b=new Dh;b.Vl=d.Ma;a.Fo=b;a.ya=!0}return a.Fo}qh.prototype.$classData=g({JZ:0},!1,&quot;org.nlogo.core.I18N$&quot;,{JZ:1,d:1});var sh=void 0;function Dh(){this.Vl=null}Dh.prototype=new l;Dh.prototype.constructor=Dh;Dh.prototype.$classData=g({KZ:0},!1,&quot;org.nlogo.core.I18N$BundleKind&quot;,{KZ:1,d:1});function Eh(a){return a.H().Wb.toUpperCase()}
function M(a){a.L(null);a.M(a.G().h);a.P(a.G().p)}function Fh(a,b){var d=a.H();b.L(Gh(d,b,d.Wb,d.jb));b.M(a.N());return b}function Hh(){this.QU=null;this.a=!1}Hh.prototype=new l;Hh.prototype.constructor=Hh;
Hh.prototype.b=function(){Ih=this;var a=&quot;TO TO-REPORT END GLOBALS TURTLES-OWN LINKS-OWN PATCHES-OWN DIRECTED-LINK-BREED UNDIRECTED-LINK-BREED EXTENSIONS __INCLUDES&quot;.split(&quot; &quot;);if(0===(a.length|0))a=Jh();else{for(var b=Kh(new Lh,Jh()),d=0,e=a.length|0;d&lt;e;)Mh(b,a[d]),d=1+d|0;a=b.Ma}this.QU=a;this.a=!0;return this};Hh.prototype.$classData=g({LZ:0},!1,&quot;org.nlogo.core.Keywords$&quot;,{LZ:1,d:1});var Ih=void 0;function Nh(){}Nh.prototype=new l;Nh.prototype.constructor=Nh;Nh.prototype.b=function(){return this};
Nh.prototype.$classData=g({UZ:0},!1,&quot;org.nlogo.core.Nobody$&quot;,{UZ:1,d:1});var Oh=void 0;function Ph(){Oh||(Oh=(new Nh).b());return Oh}function Qh(){this.mV=this.LG=this.QG=this.PG=null;this.a=0}Qh.prototype=new l;Qh.prototype.constructor=Qh;
Qh.prototype.b=function(){Rh=this;this.PG=&quot;Number too large&quot;;this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;this.QG=&quot;is too large to be represented exactly as an integer in NetLogo&quot;;this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;this.LG=&quot;Illegal number format&quot;;this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;this.mV=(new Tb).Ro(&quot;^-?[0-9]*(\\.[0-9]*)?([Ee]-?[0-9]+)?$&quot;,(new w).f([]));this.a=(8|this.a)&lt;&lt;24&gt;&gt;24;return this};
function Sh(a,b){try{var d=(new Sb).c(b).R.length|0;if(0&lt;d){var e=0;45===(65535&amp;(b.charCodeAt(e)|0))&amp;&amp;(e=1+e|0);e&lt;d&amp;&amp;46===(65535&amp;(b.charCodeAt(e)|0))&amp;&amp;(e=1+e|0);if(e&lt;d)var f=65535&amp;(b.charCodeAt(e)|0),h=Th(Uh(),f);else h=!1}else h=!1;if(h){var k=Vh(Wh(),b);if(Infinity===k||-Infinity===k){pc();if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/NumberParser.scala: 12&quot;);return(new Xh).j(a.PG)}for(var p=(new Sb).c(&quot;.eE&quot;),d=0;;){if(d&lt;(p.R.length|0))var t=
p.W(d),x=null===t?0:t.X,E=(new Sb).c(b),S=(new af).Ra(x),U=!1===li(E,S);else U=!1;if(U)d=1+d|0;else break}if(d!==(p.R.length|0))return pc(),(new mi).j(k);var ga=bca(ni(),b),ma=ga.ka,va=ga.qa;if((2097152===va?0!==ma:2097152&lt;va)||-2097152&gt;va){pc();var Fa=u((new v).K((new w).f([&quot;&quot;,&quot; &quot;,&quot;&quot;])),(new w).f([b,cca(a)]));return(new Xh).j(Fa)}pc();return(new mi).j(k)}pc();return(new Xh).j(&quot;Illegal number format&quot;)}catch(Va){if(Va&amp;&amp;Va.$classData&amp;&amp;Va.$classData.n.aE){if(0===(8&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/NumberParser.scala: 21&quot;);
k=Fg(new Gg,a.mV.Xu,b,La(b));if((oi(k)?(new J).j(pi(k)):F()).ba())return pc(),a=u((new v).K((new w).f([&quot;&quot;,&quot; &quot;,&quot;&quot;])),(new w).f([b,cca(a)])),(new Xh).j(a);pc();if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/NumberParser.scala: 15&quot;);return(new Xh).j(a.LG)}throw Va;}}function cca(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/NumberParser.scala: 13&quot;);return a.QG}
Qh.prototype.$classData=g({VZ:0},!1,&quot;org.nlogo.core.NumberParser$&quot;,{VZ:1,d:1});var Rh=void 0;function qi(){Rh||(Rh=(new Qh).b());return Rh}function ri(){this.a=0}ri.prototype=new l;ri.prototype.constructor=ri;ri.prototype.b=function(){si=this;this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;this.a=(8|this.a)&lt;&lt;24&gt;&gt;24;this.a=(16|this.a)&lt;&lt;24&gt;&gt;24;return this};ri.prototype.$classData=g({$Z:0},!1,&quot;org.nlogo.core.PlotPenInterface$&quot;,{$Z:1,d:1});var si=void 0;function ti(){}
ti.prototype=new l;ti.prototype.constructor=ti;ti.prototype.b=function(){return this};ti.prototype.Yd=function(a){return(new J).j((new ac).ae(a.pe,a.za,a.ra))};ti.prototype.$classData=g({d_:0},!1,&quot;org.nlogo.core.ReporterApp$&quot;,{d_:1,d:1});var ui=void 0;function vi(){ui||(ui=(new ti).b());return ui}function wi(){}wi.prototype=new l;wi.prototype.constructor=wi;wi.prototype.b=function(){return this};function xi(a,b){return(new J).j((new A).e(b.Sk,b.ra))}
wi.prototype.$classData=g({e_:0},!1,&quot;org.nlogo.core.ReporterBlock$&quot;,{e_:1,d:1});var yi=void 0;function zi(){yi||(yi=(new wi).b());return yi}function Ai(){this.qk=null;this.a=!1}Ai.prototype=new l;Ai.prototype.constructor=Ai;
Ai.prototype.b=function(){Bi=this;var a=[I(r(),(new w).f([0,1])),I(r(),(new w).f([1,0])),I(r(),(new w).f([2,2])),I(r(),(new w).f([4,4])),I(r(),(new w).f([4,4,2,2]))];if(0===(a.length|0))a=Jh();else{for(var b=Kh(new Lh,Jh()),d=0,e=a.length|0;d&lt;e;)Mh(b,a[d]),d=1+d|0;a=b.Ma}this.qk=a;this.a=!0;return this};function dca(){var a;Bi||(Bi=(new Ai).b());a=Bi;if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Shape.scala: 60&quot;);return a.qk}
Ai.prototype.$classData=g({g_:0},!1,&quot;org.nlogo.core.Shape$LinkLine$&quot;,{g_:1,d:1});var Bi=void 0;function eca(a){var b=a.Zx();a=m(new n,function(){return function(a){return a.Dc()}}(a));var d=r();return b.xa(a,d.s)}function fca(a){var b=a.Zx();a=m(new n,function(){return function(a){return a.Vi()}}(a));var d=r();return b.xa(a,d.s)}function Ci(){}Ci.prototype=new l;Ci.prototype.constructor=Ci;Ci.prototype.b=function(){return this};
function gca(a,b){var d=r(),e=b.me(),f=b.Gj,h=b.kE(),k=m(new n,function(){return function(a){var b=a.XD()?&quot;1&quot;:&quot;0&quot;,b=I(r(),(new w).f([a.WF(),b]));a=a.BC();var d=r();return b.Rc(a,d.s).zb(&quot; &quot;)}}(a)),p=r();return I(d,(new w).f([e,f,h.xa(k,p.s).zb(&quot;\n&quot;),hca(a,b.kD())])).zb(&quot;\n&quot;)}function Di(a){return&quot;&quot;+(a.Cp&lt;&lt;24|a.xq&lt;&lt;16|a.Sp&lt;&lt;8|a.Fp)}
function ica(a,b){if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.zz)return I(r(),(new w).f([&quot;Circle&quot;,Di(b.yb),b.$k(),b.gc,b.gk,b.hk,b.EC()])).zb(&quot; &quot;);if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.Az)return I(r(),(new w).f([&quot;Line&quot;,Di(b.yb),b.gc,b.vv().Vi(),b.vv().Dc(),b.Vt().Vi(),b.Vt().Dc()])).zb(&quot; &quot;);if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.Bz){var d=I(r(),(new w).f([&quot;Polygon&quot;,Di(b.yb),b.$k(),b.gc]));b=b.Zx();a=m(new n,function(){return function(a){return I(r(),(new w).f([a.Vi(),a.Dc()]))}}(a));var e=r();b=b.aj(a,e.s);a=r();
return d.Rc(b,a.s).zb(&quot; &quot;)}if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.Cz)return I(r(),(new w).f([&quot;Rectangle&quot;,Di(b.yb),b.$k(),b.gc,b.Pv().Vi(),b.Pv().Dc(),b.Lu().Vi(),b.Lu().Dc()])).zb(&quot; &quot;);throw(new q).j(b);}
function jca(a,b){try{var d=!1,e=null,f=(new Sb).c(b),h=Ei(f,32),k=B().s.Uh(),p=h.l.length;switch(p){case -1:break;default:k.tc(p)}k.Yb((new Fi).Gh(h));var t=k.Da();if(Gi(t)){var d=!0,e=t,x=e.Ia;if(&quot;Circle&quot;===e.Bb&amp;&amp;Gi(x)){var E=x.Bb,S=x.Ia;if(Gi(S)){var U=S.Bb,ga=S.Ia;if(Gi(ga)){var ma=ga.Bb,va=ga.Ia;if(Gi(va)){var Fa=va.Bb,Va=va.Ia;if(Gi(Va)){var vb=Va.Bb,pb=Va.Ia;if(Gi(pb)){var Ib=pb.Bb,kc=pb.Ia;if(y().o(kc)){var $a=(new Sb).c(E),fc=Hi(),Bc=Ii(Ji(fc,$a.R,10)),sf=(new Sb).c(U),Sf=Ki(sf.R),th=(new Sb).c(ma),
Te=Ki(th.R),tf=(new Sb).c(Fa),ek=Ji(Hi(),tf.R,10),og=(new Sb).c(vb),uh=Ji(Hi(),og.R,10),pg=(new Sb).c(Ib),Yh=Hi();return(new Li).qD(Bc,Sf,Te,ek,uh,Ji(Yh,pg.R,10))}}}}}}}}if(d){var Ri=e.Ia;if(&quot;Line&quot;===e.Bb&amp;&amp;Gi(Ri)){var fk=Ri.Bb,Si=Ri.Ia;if(Gi(Si)){var gk=Si.Bb,Ti=Si.Ia;if(Gi(Ti)){var vl=Ti.Bb,Ui=Ti.Ia;if(Gi(Ui)){var hk=Ui.Bb,Vi=Ui.Ia;if(Gi(Vi)){var wl=Vi.Bb,vh=Vi.Ia;if(Gi(vh)){var xl=vh.Bb,wh=vh.Ia;if(y().o(wh)){var ik=(new Sb).c(fk),yl=Hi(),Zh=Ii(Ji(yl,ik.R,10)),$h=(new Sb).c(gk),zl=Ki($h.R),Al=(new Sb).c(vl),
Bl=Ji(Hi(),Al.R,10),jk=(new Sb).c(hk),Cl=Hi(),Dl=(new Mi).ia(Bl,Ji(Cl,jk.R,10)),El=(new Sb).c(wl),Fl=Ji(Hi(),El.R,10),kk=(new Sb).c(xl),Gl=Hi();return kca(new Ni,Zh,zl,Dl,(new Mi).ia(Fl,Ji(Gl,kk.R,10)))}}}}}}}}if(d){var ai=e.Ia;if(&quot;Rectangle&quot;===e.Bb&amp;&amp;Gi(ai)){var lk=ai.Bb,xh=ai.Ia;if(Gi(xh)){var Hl=xh.Bb,Wi=xh.Ia;if(Gi(Wi)){var mk=Wi.Bb,yh=Wi.Ia;if(Gi(yh)){var Uf=yh.Bb,ue=yh.Ia;if(Gi(ue)){var zh=ue.Bb,bi=ue.Ia;if(Gi(bi)){var nk=bi.Bb,Xi=bi.Ia;if(Gi(Xi)){var Il=Xi.Bb,Yi=Xi.Ia;if(y().o(Yi)){var Jl=(new Sb).c(lk),
Zi=Hi(),$i=Ii(Ji(Zi,Jl.R,10)),ok=(new Sb).c(Hl),Kl=Ki(ok.R),aj=(new Sb).c(mk),ci=Ki(aj.R),Ll=(new Sb).c(Uf),Rg=Ji(Hi(),Ll.R,10),Sg=(new Sb).c(zh),pk=Hi(),bj=(new Mi).ia(Rg,Ji(pk,Sg.R,10)),Ah=(new Sb).c(nk),qk=Ji(Hi(),Ah.R,10),Ml=(new Sb).c(Il),rk=Hi();return lca(new Oi,$i,Kl,ci,bj,(new Mi).ia(qk,Ji(rk,Ml.R,10)))}}}}}}}}}if(d){var Tg=e.Ia;if(&quot;Polygon&quot;===e.Bb&amp;&amp;Gi(Tg)){var Nl=Tg.Bb,cj=Tg.Ia;if(Gi(cj)){var di=cj.Bb,Bh=cj.Ia;if(Gi(Bh)){for(var Ol=Bh.Bb,qg=mca(Bh.Ia),fi=(new bc).Gf(qg,m(new n,function(){return function(a){var b=
Pi(a,0),b=(new Sb).c(b),b=Ji(Hi(),b.R,10);a=Pi(a,1);a=(new Sb).c(a);var d=Hi();return(new Mi).ia(b,Ji(d,a.R,10))}}(a))),Ch=null,Ch=I(r(),y());fi.ta();){var dj=fi.ma(),Ug=(new A).e(Ch,dj);a:{var ej=Ug.kb,fj=Ug.Ab;if(null!==fj){var gi=fj.Vi(),hi=fj.Dc();if(0&lt;ej.sa())var gj=ej.$(),Vf=(new Mi).ia(gi,hi),vf=null!==gj&amp;&amp;Ea(gj,Vf);else vf=!1;if(vf){var ae=(new Mi).ia(gi,hi),hj=r(),Ch=ej.fd(ae,hj.s);break a}}var rg=Ug.kb,ij=Ug.Ab;if(null!==ij)var jj=(new Mi).ia(ij.Vi(),ij.Dc()),ii=r(),Ch=rg.fd(jj,ii.s);else throw(new q).j(Ug);
}}var ji=Ch.yf(),Pl=(new Sb).c(Nl),sk=Hi(),Vg=Ii(Ji(sk,Pl.R,10)),ki=(new Sb).c(di),Ql=Ki(ki.R),tk=(new Sb).c(Ol);return nca(new Qi,Vg,Ql,Ki(tk.R),ji)}}}}throw(new ye).c(u((new v).K((new w).f([&quot;Invalid shape format in file: &quot;,&quot;&quot;])),(new w).f([b])));}catch(ei){if(ei&amp;&amp;ei.$classData&amp;&amp;ei.$classData.n.mn)throw(new ye).c(u((new v).K((new w).f([&quot;Invalid shape format in file: &quot;,&quot;&quot;])),(new w).f([b])));throw ei;}}
function oca(a,b){a=m(new n,function(a){return function(b){return gca(a,b)}}(a));var d=r();return b.xa(a,d.s).zb(&quot;\n\n&quot;)}
function pca(a,b){var d=function(a){return function(b){return qca(a,b)}}(a);B();var e=(new w).f([y()]),f=B().s;a=b.Gb(L(e,f),tb(new ub,function(){return function(a,b){a=(new A).e(a,b);b=a.kb;var d=a.Ab;if(null!==d&amp;&amp;&quot;&quot;===d)return a=y(),Cd(new Dd,a,b);var e=a.kb;b=a.Ab;if(Gi(e)&amp;&amp;(d=e.Bb,e=e.Ia,null!==b))return a=B().s,a=kj(d,b,a),Cd(new Dd,a,e);throw(new q).j(a);}}(a))).Gb(y(),tb(new ub,function(){return function(a,b){if(Gi(a)){var d=a.Bb,e=a.Ia;if(y().o(b))return a=B(),d=d.fd(&quot;&quot;,a.s),Cd(new Dd,d,e)}return Cd(new Dd,
b,a)}}(a))).Pf(m(new n,function(){return function(a){return kd(a)}}(a)));b=B().s;if(b===B().s){if(a===y())return y();b=a.$();e=b=Cd(new Dd,d(b),y());for(a=a.aa();a!==y();)f=a.$(),f=Cd(new Dd,d(f),y()),e=e.Ia=f,a=a.aa();return b}for(b=Mc(a,b);!a.z();)e=a.$(),b.Na(d(e)),a=a.aa();return b.Da()}
function rca(a,b){var d=function(a){return function(b){return sca(a,b)}}(a);B();var e=(new w).f([y()]),f=B().s;a=b.Gb(L(e,f),tb(new ub,function(){return function(a,b){a=(new A).e(a,b);b=a.kb;var d=a.Ab;if(null!==d&amp;&amp;&quot;&quot;===d)return a=y(),Cd(new Dd,a,b);var e=a.kb;b=a.Ab;if(Gi(e)&amp;&amp;(d=e.Bb,e=e.Ia,null!==b))return a=B().s,a=kj(d,b,a),Cd(new Dd,a,e);throw(new q).j(a);}}(a))).Gb(y(),tb(new ub,function(){return function(a,b){if(Gi(a)){var d=a.Bb,e=a.Ia;if(y().o(b))return a=B(),d=d.fd(&quot;&quot;,a.s),Cd(new Dd,d,e)}return Cd(new Dd,
b,a)}}(a))).Pf(m(new n,function(){return function(a){return kd(a)}}(a)));b=B().s;if(b===B().s){if(a===y())return y();b=a.$();e=b=Cd(new Dd,d(b),y());for(a=a.aa();a!==y();)f=a.$(),f=Cd(new Dd,d(f),y()),e=e.Ia=f,a=a.aa();return b}for(b=Mc(a,b);!a.z();)e=a.$(),b.Na(d(e)),a=a.aa();return b.Da()}
function qca(a,b){if(Gi(b)){var d=b.Bb,e=b.Ia;if(Gi(e)){var f=e.Bb,h=e.Ia;if(Gi(h)){var e=h.Bb,k=h.Ia;if(Gi(k)){var h=k.Bb,p=k.Ia;if(Gi(p))return k=p.Bb,b=p.Ia,f=(new Sb).c(f),f=Vh(Wh(),f.R),e=I(r(),(new w).f([e,h,k])),h=m(new n,function(a){return function(b){return tca(a,b)}}(a)),k=r(),uca(new lj,d,f,e.xa(h,k.s),sca(a,b))}}}}throw(new ye).c(u((new v).K((new w).f([&quot;Invalid link shape: &quot;,&quot;&quot;])),(new w).f([cc(b,&quot;&quot;,&quot;\n&quot;,&quot;&quot;)])));}function Ii(a){return vca(new mj,255&amp;a&gt;&gt;16,255&amp;a&gt;&gt;8,255&amp;a,255)}
function tca(a,b){var d=!1,e=null,f=(new Sb).c(b),f=Ei(f,32),h=B().s.Uh(),k=f.l.length;switch(k){case -1:break;default:h.tc(k)}h.Yb((new Fi).Gh(f));f=h.Da();if(Gi(f)&amp;&amp;(d=!0,e=f,h=e.Bb,k=e.Ia,Gi(k))){f=k.Ia;if(&quot;1&quot;===k.Bb){k=dca();$e();var p=function(){return function(a){a=(new Sb).c(a).R;return ea(Vh(Wh(),a))}}(a),t=B().s;if(t===B().s)if(f===y())p=y();else{for(var t=f.$(),x=t=Cd(new Dd,p(t),y()),E=f.aa();E!==y();)var S=E.$(),S=Cd(new Dd,p(S),y()),x=x.Ia=S,E=E.aa();p=t}else{t=Mc(f,t);for(x=f;!x.z();)E=
x.$(),t.Na(p(E)),x=x.aa();p=t.Da()}k=k.ib(wca(p.se(nj())))}else k=!1;if(k){b=(new Sb).c(h);b=Vh(Wh(),b.R);e=function(){return function(a){a=(new Sb).c(a).R;return ea(Vh(Wh(),a))}}(a);a=B().s;if(a===B().s)if(f===y())e=y();else{a=f.$();d=a=Cd(new Dd,e(a),y());for(f=f.aa();f!==y();)h=f.$(),h=Cd(new Dd,e(h),y()),d=d.Ia=h,f=f.aa();e=a}else{for(a=Mc(f,a);!f.z();)d=f.$(),a.Na(e(d)),f=f.aa();e=a.Da()}return(new oj).hu(b,!0,e)}}if(d&amp;&amp;(f=e.Bb,a=e.Ia,Gi(a)&amp;&amp;&quot;1&quot;===a.Bb))return b=(new Sb).c(f),e=Wh(),(new oj).hu(Vh(e,
b.R),!0,I(r(),(new w).f([1,0])));if(d&amp;&amp;(f=e.Bb,e=e.Ia,Gi(e)&amp;&amp;&quot;0&quot;===e.Bb))return b=(new Sb).c(f),e=Wh(),(new oj).hu(Vh(e,b.R),!1,I(r(),(new w).f([0,1])));throw(new ye).c(u((new v).K((new w).f([&quot;Invalid link line: &quot;,&quot;&quot;])),(new w).f([b])));}function hca(a,b){var d=I(r(),(new w).f([b.me(),b.CE(),b.Nj]));b=b.gh;a=m(new n,function(a){return function(b){return ica(a,b)}}(a));var e=r();b=b.xa(a,e.s);a=r();return d.Rc(b,a.s).zb(&quot;\n&quot;)}
function xca(a,b){a=m(new n,function(a){return function(b){return hca(a,b)}}(a));var d=r();return b.xa(a,d.s).zb(&quot;\n\n&quot;)}
function sca(a,b){if(Gi(b)){var d=b.Bb,e=b.Ia;if(Gi(e)){var f=e.Bb,h=e.Ia;if(Gi(h)){e=h.Ia;b=(new Sb).c(h.Bb);b=Ji(Hi(),b.R,10);a=function(a){return function(b){return jca(a,b)}}(a);h=B().s;if(h===B().s)if(e===y())a=y();else{for(var h=e.$(),k=h=Cd(new Dd,a(h),y()),e=e.aa();e!==y();)var p=e.$(),p=Cd(new Dd,a(p),y()),k=k.Ia=p,e=e.aa();a=h}else{for(h=Mc(e,h);!e.z();)k=e.$(),h.Na(a(k)),e=e.aa();a=h.Da()}return(new pj).JD(d,&quot;true&quot;===f,b,a)}}}throw(new ye).c(u((new v).K((new w).f([&quot;Invalid vector shape:\\n &quot;,
&quot;&quot;])),(new w).f([cc(b,&quot;&quot;,&quot;\n&quot;,&quot;&quot;)])));}Ci.prototype.$classData=g({i_:0},!1,&quot;org.nlogo.core.ShapeParser$&quot;,{i_:1,d:1});var qj=void 0;function rj(){qj||(qj=(new Ci).b());return qj}function sj(){this.uS=null;this.a=!1}sj.prototype=new l;sj.prototype.constructor=sj;
sj.prototype.b=function(){tj=this;for(var a=uj(),a=(new A).e(a,&quot;__observercode&quot;),b=vj(),b=(new A).e(b,&quot;__turtlecode&quot;),d=wj(),d=(new A).e(d,&quot;__patchcode&quot;),e=xj(),a=[a,b,d,(new A).e(e,&quot;__linkcode&quot;)],b=dc(new ec,gc()),d=0,e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.uS=b.Ma;this.a=!0;return this};sj.prototype.$classData=g({j_:0},!1,&quot;org.nlogo.core.SourceWrapping$&quot;,{j_:1,d:1});var tj=void 0;function yca(){tj||(tj=(new sj).b());return tj}function yj(){}yj.prototype=new l;yj.prototype.constructor=yj;
yj.prototype.b=function(){return this};function zj(a,b){return(new J).j((new ac).ae(b.xd,b.za,b.ra))}yj.prototype.$classData=g({l_:0},!1,&quot;org.nlogo.core.Statement$&quot;,{l_:1,d:1});var Aj=void 0;function Bj(){Aj||(Aj=(new yj).b());return Aj}function Cj(){}Cj.prototype=new l;Cj.prototype.constructor=Cj;Cj.prototype.b=function(){return this};
function eh(a,b){a=(new Sb).c(b);b=$e().zp.af(a.R);for(var d=0,e=a.R.length|0;d&lt;e;){var f=a.W(d),f=null===f?0:f.X;switch(f){case 10:f=&quot;\\n&quot;;break;case 13:f=&quot;\\r&quot;;break;case 9:f=&quot;\\t&quot;;break;case 92:f=&quot;\\\\&quot;;break;case 34:f='\\&quot;';break;default:f=ba.String.fromCharCode(f)}f=(new Sb).c(f).R;b.Yb((new Dj).c(f));d=1+d|0}return b.Da()}
function Ej(a,b){for(var d=(new Sb).c(b),e=d.R.length|0,f=0;;){if(f&lt;e)var h=d.W(f),h=92!==(null===h?0:h.X);else h=!1;if(h)f=1+f|0;else break}e=Fj(d,f);if(null===e)throw(new q).j(e);d=e.la();e=e.pa();if(2&gt;((new Sb).c(e).R.length|0))return b;b=zca(65535&amp;(e.charCodeAt(1)|0));b=(new af).Ra(b);e=(new Sb).c(e);f=e.R.length|0;return&quot;&quot;+d+b+Ej(a,Ye(Ze(),e.R,2,f))}
function zca(a){switch(a){case 110:return 10;case 114:return 13;case 116:return 9;case 92:return 92;case 34:return 34;default:throw(new df).c(&quot;invalid escape sequence: \\&quot;+(new af).Ra(a));}}Cj.prototype.$classData=g({m_:0},!1,&quot;org.nlogo.core.StringEscaper$&quot;,{m_:1,d:1});var Gj=void 0;function fh(){Gj||(Gj=(new Cj).b());return Gj}function Hj(){}Hj.prototype=new l;Hj.prototype.constructor=Hj;Hj.prototype.b=function(){return this};
function Aca(a,b){var d=Ij();b=b-(b&amp;d)|0;d=Jj();0!==(b&amp;d)?(d=Jj(),b=b-(b&amp;d)|0,d=&quot;variable&quot;):(b&amp;Kj())===Kj()?(d=Kj(),b=b-(b&amp;d)|0,d=&quot;list or block&quot;):(b&amp;lc())===lc()?(d=lc(),b=b-(b&amp;d)|0,d=&quot;anything&quot;):(b&amp;Lj(D()))===Lj(D())?(d=Lj(D())|Mj(D()),b=b-(b&amp;d)|0,d=&quot;agent&quot;):(d=N(D()),0!==(b&amp;d)?(d=N(D()),b=b-(b&amp;d)|0,d=&quot;number&quot;):(d=Nj(D()),0!==(b&amp;d)?(d=Nj(D()),b=b-(b&amp;d)|0,d=&quot;TRUE/FALSE&quot;):(d=Oj(D()),0!==(b&amp;d)?(d=Oj(D()),b=b-(b&amp;d)|0,d=&quot;string&quot;):(d=Pj(D()),0!==(b&amp;d)?(d=Pj(D()),b=b-(b&amp;d)|0,d=&quot;list&quot;):(b&amp;Qj(D()))===Qj(D())?
(d=Qj(D()),b=b-(b&amp;d)|0,d=&quot;agentset&quot;):(d=Rj(D()),0!==(b&amp;d)?(d=Rj(D()),b=b-(b&amp;d)|0,d=&quot;turtle agentset&quot;):(d=Sj(D()),0!==(b&amp;d)?(d=Sj(D()),b=b-(b&amp;d)|0,d=&quot;patch agentset&quot;):(d=Tj(D()),0!==(b&amp;d)?(d=Tj(D()),b=b-(b&amp;d)|0,d=&quot;link agentset&quot;):(d=Uj(D()),0!==(b&amp;d)?(d=Uj(D())|Mj(D()),b=b-(b&amp;d)|0,d=&quot;turtle&quot;):(d=Vj(D()),0!==(b&amp;d)?(d=Vj(D())|Mj(D()),b=b-(b&amp;d)|0,d=&quot;patch&quot;):(d=Wj(D()),0!==(b&amp;d)?(d=Wj(D())|Mj(D()),b=b-(b&amp;d)|0,d=&quot;link&quot;):(d=Xj(D()),0!==(b&amp;d)?(d=Xj(D()),b=b-(b&amp;d)|0,d=&quot;anonymous reporter&quot;):(d=Yj(D()),0!==
(b&amp;d)?(d=Yj(D()),b=b-(b&amp;d)|0,d=&quot;anonymous command&quot;):(d=Mj(D()),0!==(b&amp;d)?(d=Mj(D()),b=b-(b&amp;d)|0,d=&quot;NOBODY&quot;):(d=Zj(D()),0!==(b&amp;d)?(d=Zj(D()),b=b-(b&amp;d)|0,d=&quot;command block&quot;):(b&amp;ak(D()))===ak(D())?(d=ak(D()),b=b-(b&amp;d)|0,d=&quot;reporter block&quot;):(d=bk(D()),0!==(b&amp;d)?(d=ak(D()),b=b-(b&amp;d)|0,d=&quot;different kind of block&quot;):(d=ck(D()),0!==(b&amp;d)?(d=ck(D()),b=b-(b&amp;d)|0,d=&quot;TRUE/FALSE block&quot;):(d=dk(D()),0!==(b&amp;d)?(d=dk(D()),b=b-(b&amp;d)|0,d=&quot;number block&quot;):(d=uk(),0!==(b&amp;d)?(d=uk(),b=b-(b&amp;d)|0,d=&quot;code block&quot;):(d=xk(),0!==
(b&amp;d)?(d=xk(),b=b-(b&amp;d)|0,d=&quot;variable&quot;):d=&quot;(none)&quot;)))))))))))))))))));var e=b;return 0===e?d:yk()===e?d+&quot; (optional)&quot;:d+&quot; or &quot;+Aca(a,b)}function zk(a,b){a=Aca(a,b);if(&quot;NOBODY&quot;!==a&amp;&amp;&quot;anything&quot;!==a)a:switch(b=(new Sb).c(a),b=Ak(b),b=null===b?0:b.X,Bca(Uh(),b)){case 65:case 69:case 73:case 79:case 85:a=&quot;an &quot;+a;break a;default:a=&quot;a &quot;+a}return a}Hj.prototype.$classData=g({M_:0},!1,&quot;org.nlogo.core.TypeNames$&quot;,{M_:1,d:1});var Bk=void 0;function Ck(){Bk||(Bk=(new Hj).b());return Bk}
function Dk(){this.YR=null;this.a=!1}Dk.prototype=new l;Dk.prototype.constructor=Dk;Dk.prototype.b=function(){this.YR=&quot;@#$#@#$#@&quot;;this.a=!0;return this};function Cca(){var a=Ek();return m(new n,function(){return function(a){return a}}(a))}
function Dca(a,b){var d=Fk(),e=nh($e().kk,y()),f=Cca(),h;h=I(pc().Th,y());var k;k=I(pc().Th,y());Gk||(Gk=(new Hk).b());var p;p=Eca;var t=Gk;$e();b=null!==b?(new Dj).c(b):null;p=p(t,b);for(p=(new Ik).ru(p);Jk(p).ta();)t=p.km(),b=Kk(a),0&lt;=(t.length|0)&amp;&amp;t.substring(0,b.length|0)===b?(h=h.mc(k,(Lk(),Mk().qc)),k=I(pc().Th,y())):k=k.mc(t,(Lk(),Mk().qc));h=h.mc(k,(Lk(),Mk().qc));I(pc().Th,y());if(12!==h.sa())throw Kg(Lg(),(new $g).c(&quot;Models must have 12 sections, this had &quot;+h.sa()));a=h;var x,E,S,U;pc();
p=(new J).j(a);if(null!==p.U&amp;&amp;0===p.U.Rb(12)){var ga=p.U.W(0),ma=p.U.W(1);a=p.U.W(2);t=p.U.W(3);h=p.U.W(4);k=p.U.W(5);var va=p.U.W(6);b=p.U.W(7);x=p.U.W(8);E=p.U.W(9);S=p.U.W(10);U=p.U.W(11);p=va}else throw(new q).j(a);k;p;b;x;p=E;S;U;k=rca(rj(),t);p=pca(rj(),p);t=cc(ga,&quot;&quot;,&quot;\n&quot;,&quot;&quot;);x=Fca();E=B().s;b=new Nk;S=L(ma,E);E=I(pc().Th,y());for(ma=I(pc().Th,y());!S.z();){ga=S.$();U=(new Sb).c(ga);if(kd(U))ma=ma.mc(ga,(Lk(),Mk().qc));else{ga=Ok(ma);for(U=!0;U&amp;&amp;ga.qi;){U=ga.ma();if(null===U)throw(new Oe).b();
U=&quot;&quot;===U}U||(ga=B().s,E=E.mc(Gca(x,L(ma,ga),d,e,f),(Lk(),Mk().qc)));ma=I(pc().Th,y())}S=S.aa()}S=Ok(ma);for(ga=!0;ga&amp;&amp;S.qi;){ga=S.ma();if(null===ga)throw(new Oe).b();ga=&quot;&quot;===ga}ga||(S=B().s,E=E.mc(Gca(x,L(ma,S),d,e,f),(Lk(),Mk().qc)));d=E;e=B().s;d=L(d,e);return Pk(b,t,d,cc(a,&quot;&quot;,&quot;\n&quot;,&quot;&quot;),h.$(),k.ub(),p.ub(),I(r(),y()))}
function Hca(a,b){return&quot;&quot;+b.Zd+u((new v).K((new w).f([&quot;\\n&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))+Ica(Fca(),b.Gc)+u((new v).K((new w).f([&quot;\\n&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))+b.Se+u((new v).K((new w).f([&quot;\\n&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))+xca(rj(),b.Zg)+u((new v).K((new w).f([&quot;\\n&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))+b.Rh+u((new v).K((new w).f([&quot;\\n&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))+u((new v).K((new w).f([&quot;&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))+u((new v).K((new w).f([&quot;&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))+u((new v).K((new w).f([&quot;&quot;,&quot;\\n&quot;])),
(new w).f([Kk(a)]))+u((new v).K((new w).f([&quot;&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))+oca(rj(),b.Lg)+u((new v).K((new w).f([&quot;\\n&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))+u((new v).K((new w).f([&quot;\\n&quot;,&quot;\\n&quot;])),(new w).f([Kk(a)]))}function Kk(a){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/model/ModelReader.scala: 9&quot;);return a.YR}Dk.prototype.$classData=g({V_:0},!1,&quot;org.nlogo.core.model.ModelReader$&quot;,{V_:1,d:1});var Qk=void 0;
function Ek(){Qk||(Qk=(new Dk).b());return Qk}function Rk(){}Rk.prototype=new l;Rk.prototype.constructor=Rk;Rk.prototype.b=function(){return this};
function Jca(a){var b=&quot;&quot;;for(;;){var d=a;if(null===d)throw(new Oe).b();if(&quot;&quot;===d)return(new A).e(b,a);d=(new Sb).c(a);d=Ak(d);if(34===(null===d?0:d.X))return a=(new Sb).c(a),a=Sk(a),(new A).e(b,a.trim());d=(new Sb).c(a);d=Ye(Ze(),d.R,0,2);null!==d&amp;&amp;'\\&quot;'===d?(a=(new Sb).c(a),d=a.R.length|0,a=Ye(Ze(),a.R,2,d),b+='&quot;'):(d=(new Sb).c(a),d=Sk(d),a=(new Sb).c(a),b=&quot;&quot;+b+na(Ak(a)),a=d)}}
function Tk(a,b){var d=(new Sb).c(b),d=Uk(d);if(Vk(d)&amp;&amp;(d=d.U,34===(null===d?0:d.X))){b=(new Sb).c(b);d=Jca(Sk(b));if(null===d)throw(new q).j(d);b=d.la();a=Tk(a,d.pa());return Cd(new Dd,b,a)}return y()}function Wk(a){return&quot;&quot;+(new af).Ra(34)+a+(new af).Ra(34)}Rk.prototype.$classData=g({Y_:0},!1,&quot;org.nlogo.core.model.PenReader$&quot;,{Y_:1,d:1});var Xk=void 0;function Yk(){Xk||(Xk=(new Rk).b());return Xk}function Zk(){this.iT=null;this.a=!1}Zk.prototype=new l;Zk.prototype.constructor=Zk;
Zk.prototype.b=function(){$k=this;al||(al=(new bl).b());var a=(new A).e(&quot;BUTTON&quot;,al);cl||(cl=(new dl).b());var b=(new A).e(&quot;SLIDER&quot;,cl);el||(el=(new fl).b());var d=(new A).e(&quot;GRAPHICS-WINDOW&quot;,el);gl||(gl=(new hl).b());var e=(new A).e(&quot;MONITOR&quot;,gl);il||(il=(new jl).b());var f=(new A).e(&quot;SWITCH&quot;,il);kl||(kl=(new ll).b());var h=(new A).e(&quot;PLOT&quot;,kl);ml||(ml=(new nl).b());var k=(new A).e(&quot;CHOOSER&quot;,ml);ol||(ol=(new pl).b());var p=(new A).e(&quot;OUTPUT&quot;,ol);ql||(ql=(new rl).b());var t=(new A).e(&quot;TEXTBOX&quot;,ql);
sl||(sl=(new tl).b());a=[a,b,d,e,f,h,k,p,t,(new A).e(&quot;INPUTBOX&quot;,sl)];b=dc(new ec,gc());d=0;for(e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.iT=b.Ma;this.a=!0;return this};function Gca(a,b,d,e,f){a=Kca(a).Am(e);a=(new Kc).fg(a).oi.rj();a:{for(;a.ta();)if(e=a.ma(),e.RF(b)){a=(new J).j(e);break a}a=F()}if(Vk(a))return a.U.GV(b,d).Ql(f);if(F()===a)throw Kg(Lg(),(new $g).c(u((new v).K((new w).f([&quot;Couldn't find corresponding reader for &quot;,&quot;&quot;])),(new w).f([b.$()]))));throw(new q).j(a);}
function Ica(a,b){a=m(new n,function(a){return function(b){var d=nh($e().kk,y()),d=Kca(a).Am(d),k=(new Kc).fg(d);Lc();Lc();ul();d=(new jc).b();for(k=k.oi.rj();k.ta();){var p=k.ma(),t;t=p.Pl();var x=b;t=null!==x&amp;&amp;(Rl(t.Cd(),x)||ra(x)&amp;&amp;Sl(t.Cd(),pa(bb))||ta(x)&amp;&amp;Sl(t.Cd(),pa(cb))||ze(x)&amp;&amp;Sl(t.Cd(),pa(ab))||Pa(x)&amp;&amp;Sl(t.Cd(),pa(db))||Ca(x)&amp;&amp;Sl(t.Cd(),pa(eb))||xa(x)&amp;&amp;Sl(t.Cd(),pa(fb))||&quot;number&quot;===typeof x&amp;&amp;Sl(t.Cd(),pa(gb))||&quot;boolean&quot;===typeof x&amp;&amp;Sl(t.Cd(),pa(Za))||void 0===x&amp;&amp;Sl(t.Cd(),pa(Ya)))?(new J).j(x):
F();t.z()?p=F():(t=t.Y(),p=(new J).j(p.LT(t)));p=p.ub();Tl(d,p)}d=d.ub();d=Uk(d);if(d.z())throw(new Ul).c(&quot;Widget type is not supported: &quot;+oa(b).kh());return d.Y()}}(a));var d=r();return b.xa(a,d.s).zb(&quot;\n\n&quot;)}function Kca(a){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/model/WidgetReader.scala: 107&quot;);return a.iT}Zk.prototype.$classData=g({d0:0},!1,&quot;org.nlogo.core.model.WidgetReader$&quot;,{d0:1,d:1});var $k=void 0;
function Fca(){$k||($k=(new Zk).b());return $k}function Vl(){}Vl.prototype=new l;Vl.prototype.constructor=Vl;Vl.prototype.b=function(){return this};Vl.prototype.$classData=g({f0:0},!1,&quot;org.nlogo.core.prim.Lambda$&quot;,{f0:1,d:1});var Lca=void 0;function Wl(){this.WT=this.lT=this.XT=null;this.a=0}Wl.prototype=new l;Wl.prototype.constructor=Wl;
Wl.prototype.b=function(){Xl=this;this.XT=&quot;_.?\x3d*!\x3c\x3e:#+/%$^'\x26-&quot;;this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;this.lT=&quot;0123456789&quot;;this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;var a=[(new O).Q(65498,65500,1),(new O).Q(65490,65495,1),(new O).Q(65482,65487,1),(new O).Q(65474,65479,1),(new O).Q(65382,65470,1),(new O).Q(65345,65370,1),(new O).Q(65313,65338,1),(new O).Q(65142,65276,1),(new O).Q(65136,65140,1),(new O).Q(65008,65019,1),(new O).Q(64914,64967,1),(new O).Q(64848,64911,1),(new O).Q(64467,64829,1),(new O).Q(64326,64433,
1),(new O).Q(64323,64324,1),(new O).Q(64320,64321,1),(new O).Q(64318,64318,1),(new O).Q(64312,64316,1),(new O).Q(64298,64310,1),(new O).Q(64287,64296,1),(new O).Q(64285,64285,1),(new O).Q(64275,64279,1),(new O).Q(64256,64262,1),(new O).Q(64112,64217,1),(new O).Q(63744,64109,1),(new O).Q(55243,55291,1),(new O).Q(55216,55238,1),(new O).Q(44032,55203,1),(new O).Q(43968,44002,1),(new O).Q(43816,43822,1),(new O).Q(43808,43814,1),(new O).Q(43793,43798,1),(new O).Q(43785,43790,1),(new O).Q(43777,43782,1),
(new O).Q(43762,43764,1),(new O).Q(43744,43754,1),(new O).Q(43739,43741,1),(new O).Q(43714,43714,1),(new O).Q(43712,43712,1),(new O).Q(43705,43709,1),(new O).Q(43701,43702,1),(new O).Q(43697,43697,1),(new O).Q(43648,43695,1),(new O).Q(43642,43642,1),(new O).Q(43616,43638,1),(new O).Q(43588,43595,1),(new O).Q(43584,43586,1),(new O).Q(43520,43560,1),(new O).Q(43471,43471,1),(new O).Q(43396,43442,1),(new O).Q(43360,43388,1),(new O).Q(43312,43334,1),(new O).Q(43274,43301,1),(new O).Q(43259,43259,1),(new O).Q(43250,
43255,1),(new O).Q(43138,43187,1),(new O).Q(43072,43123,1),(new O).Q(43020,43042,1),(new O).Q(43015,43018,1),(new O).Q(43011,43013,1),(new O).Q(43E3,43009,1),(new O).Q(42912,42922,1),(new O).Q(42896,42899,1),(new O).Q(42891,42894,1),(new O).Q(42786,42888,1),(new O).Q(42775,42783,1),(new O).Q(42656,42725,1),(new O).Q(42623,42647,1),(new O).Q(42560,42606,1),(new O).Q(42538,42539,1),(new O).Q(42512,42527,1),(new O).Q(42240,42508,1),(new O).Q(42192,42237,1),(new O).Q(40960,42124,1),(new O).Q(19968,40908,
1),(new O).Q(13312,19893,1),(new O).Q(12784,12799,1),(new O).Q(12704,12730,1),(new O).Q(12593,12686,1),(new O).Q(12549,12589,1),(new O).Q(12540,12543,1),(new O).Q(12449,12538,1),(new O).Q(12445,12447,1),(new O).Q(12353,12438,1),(new O).Q(12347,12348,1),(new O).Q(12337,12341,1),(new O).Q(12293,12294,1),(new O).Q(11823,11823,1),(new O).Q(11736,11742,1),(new O).Q(11728,11734,1),(new O).Q(11720,11726,1),(new O).Q(11712,11718,1),(new O).Q(11704,11710,1),(new O).Q(11696,11702,1),(new O).Q(11688,11694,1),
(new O).Q(11680,11686,1),(new O).Q(11648,11670,1),(new O).Q(11631,11631,1),(new O).Q(11568,11623,1),(new O).Q(11565,11565,1),(new O).Q(11559,11559,1),(new O).Q(11520,11557,1),(new O).Q(11506,11507,1),(new O).Q(11499,11502,1),(new O).Q(11360,11492,1),(new O).Q(11312,11358,1),(new O).Q(11264,11310,1),(new O).Q(8579,8580,1),(new O).Q(8526,8526,1),(new O).Q(8517,8521,1),(new O).Q(8508,8511,1),(new O).Q(8495,8505,1),(new O).Q(8490,8493,1),(new O).Q(8488,8488,1),(new O).Q(8486,8486,1),(new O).Q(8484,8484,
1),(new O).Q(8473,8477,1),(new O).Q(8469,8469,1),(new O).Q(8458,8467,1),(new O).Q(8455,8455,1),(new O).Q(8450,8450,1),(new O).Q(8336,8348,1),(new O).Q(8319,8319,1),(new O).Q(8305,8305,1),(new O).Q(8182,8188,1),(new O).Q(8178,8180,1),(new O).Q(8160,8172,1),(new O).Q(8150,8155,1),(new O).Q(8144,8147,1),(new O).Q(8134,8140,1),(new O).Q(8130,8132,1),(new O).Q(8126,8126,1),(new O).Q(8118,8124,1),(new O).Q(8064,8116,1),(new O).Q(8031,8061,1),(new O).Q(8029,8029,1),(new O).Q(8027,8027,1),(new O).Q(8025,
8025,1),(new O).Q(8016,8023,1),(new O).Q(8008,8013,1),(new O).Q(7968,8005,1),(new O).Q(7960,7965,1),(new O).Q(7680,7957,1),(new O).Q(7424,7615,1),(new O).Q(7413,7414,1),(new O).Q(7406,7409,1),(new O).Q(7401,7404,1),(new O).Q(7258,7293,1),(new O).Q(7245,7247,1),(new O).Q(7168,7203,1),(new O).Q(7098,7141,1),(new O).Q(7086,7087,1),(new O).Q(7043,7072,1),(new O).Q(6981,6987,1),(new O).Q(6917,6963,1),(new O).Q(6823,6823,1),(new O).Q(6688,6740,1),(new O).Q(6656,6678,1),(new O).Q(6593,6599,1),(new O).Q(6528,
6571,1),(new O).Q(6512,6516,1),(new O).Q(6480,6509,1),(new O).Q(6400,6428,1),(new O).Q(6320,6389,1),(new O).Q(6314,6314,1),(new O).Q(6272,6312,1),(new O).Q(6176,6263,1),(new O).Q(6108,6108,1),(new O).Q(6103,6103,1),(new O).Q(6016,6067,1),(new O).Q(5998,6E3,1),(new O).Q(5984,5996,1),(new O).Q(5952,5969,1),(new O).Q(5920,5937,1),(new O).Q(5902,5905,1),(new O).Q(5888,5900,1),(new O).Q(5792,5866,1),(new O).Q(5761,5786,1),(new O).Q(5743,5759,1),(new O).Q(5121,5740,1),(new O).Q(5024,5108,1),(new O).Q(4992,
5007,1),(new O).Q(4888,4954,1),(new O).Q(4882,4885,1),(new O).Q(4824,4880,1),(new O).Q(4808,4822,1),(new O).Q(4802,4805,1),(new O).Q(4800,4800,1),(new O).Q(4792,4798,1),(new O).Q(4786,4789,1),(new O).Q(4752,4784,1),(new O).Q(4746,4749,1),(new O).Q(4704,4744,1),(new O).Q(4698,4701,1),(new O).Q(4696,4696,1),(new O).Q(4688,4694,1),(new O).Q(4682,4685,1),(new O).Q(4348,4680,1),(new O).Q(4304,4346,1),(new O).Q(4301,4301,1),(new O).Q(4295,4295,1),(new O).Q(4256,4293,1),(new O).Q(4238,4238,1),(new O).Q(4213,
4225,1),(new O).Q(4206,4208,1),(new O).Q(4197,4198,1),(new O).Q(4193,4193,1),(new O).Q(4186,4189,1),(new O).Q(4176,4181,1),(new O).Q(4159,4159,1),(new O).Q(4096,4138,1),(new O).Q(3976,3980,1),(new O).Q(3913,3948,1),(new O).Q(3904,3911,1),(new O).Q(3840,3840,1),(new O).Q(3804,3807,1),(new O).Q(3782,3782,1),(new O).Q(3776,3780,1),(new O).Q(3773,3773,1),(new O).Q(3762,3763,1),(new O).Q(3757,3760,1),(new O).Q(3754,3755,1),(new O).Q(3751,3751,1),(new O).Q(3749,3749,1),(new O).Q(3745,3747,1),(new O).Q(3737,
3743,1),(new O).Q(3732,3735,1),(new O).Q(3725,3725,1),(new O).Q(3722,3722,1),(new O).Q(3719,3720,1),(new O).Q(3716,3716,1),(new O).Q(3713,3714,1),(new O).Q(3648,3654,1),(new O).Q(3634,3635,1),(new O).Q(3585,3632,1),(new O).Q(3520,3526,1),(new O).Q(3517,3517,1),(new O).Q(3507,3515,1),(new O).Q(3482,3505,1),(new O).Q(3461,3478,1),(new O).Q(3450,3455,1),(new O).Q(3424,3425,1),(new O).Q(3406,3406,1),(new O).Q(3389,3389,1),(new O).Q(3346,3386,1),(new O).Q(3342,3344,1),(new O).Q(3333,3340,1),(new O).Q(3313,
3314,1),(new O).Q(3296,3297,1),(new O).Q(3294,3294,1),(new O).Q(3261,3261,1),(new O).Q(3253,3257,1),(new O).Q(3242,3251,1),(new O).Q(3218,3240,1),(new O).Q(3214,3216,1),(new O).Q(3205,3212,1),(new O).Q(3168,3169,1),(new O).Q(3160,3161,1),(new O).Q(3133,3133,1),(new O).Q(3125,3129,1),(new O).Q(3114,3123,1),(new O).Q(3090,3112,1),(new O).Q(3086,3088,1),(new O).Q(3077,3084,1),(new O).Q(3024,3024,1),(new O).Q(2990,3001,1),(new O).Q(2984,2986,1),(new O).Q(2979,2980,1),(new O).Q(2974,2975,1),(new O).Q(2972,
2972,1),(new O).Q(2969,2970,1),(new O).Q(2962,2965,1),(new O).Q(2958,2960,1),(new O).Q(2949,2954,1),(new O).Q(2947,2947,1),(new O).Q(2929,2929,1),(new O).Q(2911,2913,1),(new O).Q(2908,2909,1),(new O).Q(2877,2877,1),(new O).Q(2869,2873,1),(new O).Q(2866,2867,1),(new O).Q(2858,2864,1),(new O).Q(2835,2856,1),(new O).Q(2831,2832,1),(new O).Q(2821,2828,1),(new O).Q(2784,2785,1),(new O).Q(2768,2768,1),(new O).Q(2749,2749,1),(new O).Q(2741,2745,1),(new O).Q(2738,2739,1),(new O).Q(2730,2736,1),(new O).Q(2707,
2728,1),(new O).Q(2703,2705,1),(new O).Q(2693,2701,1),(new O).Q(2674,2676,1),(new O).Q(2654,2654,1),(new O).Q(2649,2652,1),(new O).Q(2616,2617,1),(new O).Q(2613,2614,1),(new O).Q(2610,2611,1),(new O).Q(2602,2608,1),(new O).Q(2579,2600,1),(new O).Q(2575,2576,1),(new O).Q(2565,2570,1),(new O).Q(2544,2545,1),(new O).Q(2527,2529,1),(new O).Q(2524,2525,1),(new O).Q(2510,2510,1),(new O).Q(2493,2493,1),(new O).Q(2486,2489,1),(new O).Q(2482,2482,1),(new O).Q(2474,2480,1),(new O).Q(2451,2472,1),(new O).Q(2447,
2448,1),(new O).Q(2437,2444,1),(new O).Q(2425,2431,1),(new O).Q(2417,2423,1),(new O).Q(2392,2401,1),(new O).Q(2384,2384,1),(new O).Q(2365,2365,1),(new O).Q(2308,2361,1),(new O).Q(2210,2220,1),(new O).Q(2208,2208,1),(new O).Q(2112,2136,1),(new O).Q(2088,2088,1),(new O).Q(2084,2084,1),(new O).Q(2074,2074,1),(new O).Q(2048,2069,1),(new O).Q(2042,2042,1),(new O).Q(2036,2037,1),(new O).Q(1994,2026,1),(new O).Q(1969,1969,1),(new O).Q(1869,1957,1),(new O).Q(1810,1839,1),(new O).Q(1808,1808,1),(new O).Q(1791,
1791,1),(new O).Q(1786,1788,1),(new O).Q(1774,1775,1),(new O).Q(1765,1766,1),(new O).Q(1749,1749,1),(new O).Q(1649,1747,1),(new O).Q(1646,1647,1),(new O).Q(1568,1610,1),(new O).Q(1520,1522,1),(new O).Q(1488,1514,1),(new O).Q(1377,1415,1),(new O).Q(1369,1369,1),(new O).Q(1329,1366,1),(new O).Q(1162,1319,1),(new O).Q(1015,1153,1),(new O).Q(931,1013,1),(new O).Q(910,929,1),(new O).Q(908,908,1),(new O).Q(904,906,1),(new O).Q(902,902,1),(new O).Q(890,893,1),(new O).Q(886,887,1),(new O).Q(880,884,1),(new O).Q(750,
750,1),(new O).Q(748,748,1),(new O).Q(736,740,1),(new O).Q(710,721,1),(new O).Q(248,705,1),(new O).Q(216,246,1),(new O).Q(192,214,1),(new O).Q(186,186,1),(new O).Q(181,181,1),(new O).Q(170,170,1),(new O).Q(97,122,1),(new O).Q(65,90,1)];if(0===(a.length|0))a=Jh();else{for(var b=Kh(new Lh,Jh()),d=0,e=a.length|0;d&lt;e;)Mh(b,a[d]),d=1+d|0;a=b.Ma}b=I(Yl(),y());a=Zl(a,b,tb(new ub,function(){return function(a,b){var d=$l(),d=cm(d);b=L(b,d);return dm(a,b)}}(this)));if(0===(2&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/lex/Charset.scala: 9&quot;);
b=(new Sb).c(this.lT);$e();for(var d=Mc(b,new em),e=0,f=b.R.length|0;e&lt;f;){var h=b.W(e);d.Na(null===h?0:h.X);e=1+e|0}b=d.Da().ed();if(0===(1&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/lex/Charset.scala: 8&quot;);d=(new Sb).c(this.XT);$e();e=Mc(d,new em);f=0;for(h=d.R.length|0;f&lt;h;){var k=d.W(f);e.Na(null===k?0:k.X);f=1+f|0}this.WT=a.qp(b.qp(e.Da().ed()));this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;return this};
function Mca(){var a;Xl||(Xl=(new Wl).b());a=Xl;if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/lex/Charset.scala: 11&quot;);return a.WT}Wl.prototype.$classData=g({o0:0},!1,&quot;org.nlogo.lex.Charset$&quot;,{o0:1,d:1});var Xl=void 0;function fm(){}fm.prototype=new l;fm.prototype.constructor=fm;function Nca(a,b){return m(new n,function(a,b){return function(a){return b.y((new af).Ra(null===a?0:a.X))?gm():hm()}}(a,b))}fm.prototype.b=function(){return this};
function im(a,b){return jm(a,b,tb(new ub,function(){return function(a,b){a:for(b=null===b?0:b.X;;){var f=a.$().y((new af).Ra(b));if(f===hm()&amp;&amp;a.aa().He())a=a.aa();else{a=f===hm()?(new A).e(I(r(),y()),hm()):(new A).e(a,f);break a}}return a}}(a)))}function Oca(a,b){return jm(a,!1,tb(new ub,function(a,b){return function(a,d){d=null===d?0:d.X;return a?(new A).e(!0,hm()):(new A).e(!0,b.y((new af).Ra(d)))}}(a,b)))}
function km(a,b){return jm(a,b,tb(new ub,function(a){return function(b,f){f=null===f?0:f.X;if(b.z())return(new A).e(b,hm());f=m(new n,function(a,b){return function(a){return a.y((new af).Ra(b))}}(a,f));var h=r();f=b.xa(f,h.s);h=r();b=b.De(f,h.s).Pf(m(new n,function(){return function(a){a=a.pa();var b=gm();return null!==a&amp;&amp;Ea(a,b)}}(a)));var h=m(new n,function(){return function(a){return a.la()}}(a)),k=r();b=b.xa(h,k.s);return(new A).e(b,f.Wj(tb(new ub,function(){return function(a,b){return a.tE(b)}}(a))))}}(a)))}
function lm(a,b){return Oca(a,m(new n,function(a,b){return function(a){return b.y((new af).Ra(null===a?0:a.X))?gm():mm()}}(a,b)))}function jm(a,b,d){b=(new nm).j(b);return m(new n,function(a,b,d){return function(a){a=rb(b,d.Ba,(new af).Ra(null===a?0:a.X));if(null===a)throw(new q).j(a);var e=a.pa();d.Ba=a.la();return e}}(a,d,b))}function Pca(a,b){return im(a,(new w).f([lm(a,b),m(new n,function(a,b){return function(a){return b.y((new af).Ra(null===a?0:a.X))?gm():hm()}}(a,b))]))}
fm.prototype.$classData=g({r0:0},!1,&quot;org.nlogo.lex.LexOperations$&quot;,{r0:1,d:1});var om=void 0;function pm(){om||(om=(new fm).b());return om}function qm(){}qm.prototype=new l;qm.prototype.constructor=qm;qm.prototype.b=function(){return this};function rm(a){var b;sm||(sm=(new qm).b());b=sm;return jm(pm(),!1,tb(new ub,function(a,b){return function(a,d){d=null===d?0:d.X;return a?(new A).e(!0,hm()):(new A).e(!0,d===b?gm():mm())}}(b,a)))}
qm.prototype.$classData=g({s0:0},!1,&quot;org.nlogo.lex.LexOperations$PrefixConversions$&quot;,{s0:1,d:1});var sm=void 0;function tm(){this.RV=null;this.a=!1}tm.prototype=new l;tm.prototype.constructor=tm;function Qca(){}Qca.prototype=tm.prototype;
tm.prototype.b=function(){um||(um=(new vm).b());var a=(new A).e(&quot;,&quot;,um),b=Rca(),b=(new A).e(&quot;{&quot;,b);wm||(wm=(new xm).b());for(var d=(new A).e(&quot;}&quot;,wm),e=ym(),e=(new A).e(&quot;(&quot;,e),f=zm(),f=(new A).e(&quot;)&quot;,f),h=Am(),h=(new A).e(&quot;[&quot;,h),k=Bm(),a=[a,b,d,e,f,h,(new A).e(&quot;]&quot;,k)],b=dc(new ec,gc()),d=0,e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.RV=b.Ma;this.a=!0;return this};
function Sca(a){return(new A).e(lm(pm(),m(new n,function(a){return function(d){var e=null===d?0:d.X;d=Tca(a);e=ba.String.fromCharCode(e);return d.ib(e)}}(a))),m(new n,function(a){return function(d){var e=Tca(a).dc(d);if(e.z())return F();e=e.Y();return(new J).j((new ac).ae(d,e,null))}}(a)))}
function Uca(a){return(new A).e(Pca(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return Mca().ib(a)}}(a))),m(new n,function(){return function(a){return(new J).j((new ac).ae(a,Cm(),a.toUpperCase()))}}(a)))}function Vca(a){return(new A).e(im(pm(),(new w).f([rm(59),Nca(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return 13!==a&amp;&amp;10!==a}}(a)))])),m(new n,function(){return function(a){return(new J).j((new ac).ae(a,Dm(),null))}}(a)))}
tm.prototype.lC=function(a){return a.ta()?(a=I(r(),(new w).f([Wca(this),Sca(this),Vca(this),Xca(this),Yca(this),Uca(this),Zca(this)])).Gb((new A).e(F(),a),tb(new ub,function(){return function(a,d){d=(new A).e(a,d);var e=d.kb;a=d.Ab;if(null!==e){var f=e.la(),e=e.pa();if(Vk(f)&amp;&amp;(f=f.U,null!==a))return(new A).e((new J).j(f),e)}a=d.kb;e=d.Ab;if(null!==a&amp;&amp;(f=a.la(),a=a.pa(),F()===f&amp;&amp;null!==e)){f=e.pa();d=a.Zo;e=e.la();Em(a.nk);b:{var h=(new Fm).b();c:for(;;){var k=$ca(a);if(Vk(k)&amp;&amp;(k=k.U,k=null===k?0:
k.X,e.y((new af).Ra(k)).dw())){h=Gm(h,k);continue c}e=h.vc.Zb;break b}}a.nk.zq();k=e.length|0;h=a.nk;k=(new Vb).ia(k,k&gt;&gt;31);h.Cn.uv(k);Hm(h,Im(h)-k.ka|0);a.Zo=a.Zo+(e.length|0)|0;e=(new A).e(e,a);if(null===e)throw(new q).j(e);h=e.la();e=e.pa();if(&quot;&quot;===h)f=F();else if(f=f.y(h),f.z())f=F();else{f=f.Y();if(null===f)throw(new q).j(f);f=(new J).j((new A).e(Jm(new Km,f.gb,f.Fb,f.og,Lm(new Mm,d,e.Zo,a.ab)),a))}f.z()?(a.nk.zq(),a.Zo=d,d=F()):d=f;d.z()?d=F():(d=d.Y(),d=(new J).j((new A).e((new J).j(d.la()),
d.pa())));return d.z()?(new A).e(F(),a):d.Y()}throw(new q).j(d);}}(this))),(new A).e(a.la().Y(),a.pa())):(new A).e(Nm(),a)};function Zca(a){return(new A).e(Oca(pm(),m(new n,function(){return function(){return gm()}}(a))),m(new n,function(){return function(a){return(new J).j((new ac).ae(a,Om(),&quot;This non-standard character is not allowed.&quot;))}}(a)))}
function Xca(a){return(new A).e(im(pm(),(new w).f([km(pm(),(new w).f([lm(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return Th(Uh(),a)}}(a))),im(pm(),(new w).f([km(pm(),(new w).f([rm(46),rm(45)])),km(pm(),(new w).f([lm(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return Th(Uh(),a)}}(a))),im(pm(),(new w).f([rm(46),lm(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return Th(Uh(),a)}}(a)))]))]))]))])),Nca(pm(),m(new n,function(){return function(a){a=null===
a?0:a.X;return Mca().ib(a)}}(a)))])),m(new n,function(){return function(a){a:{for(var d=(new Sb).c(a),e=0;;){if(e&lt;(d.R.length|0))var f=d.W(e),f=null===f?0:f.X,f=!1===Th(Uh(),f);else f=!1;if(f)e=1+e|0;else break}if(e!==(d.R.length|0)){d=Sh(qi(),a);if(Pm(d)){d=d.U;a=(new J).j((new ac).ae(a,Om(),d));break a}if(Qm(d)){d=d.U;a=(new J).j((new ac).ae(a,Rm(),d));break a}throw(new q).j(d);}a=F()}return a}}(a)))}
function Yca(a){return(new A).e(im(pm(),(new w).f([rm(34),ada(a),rm(34)])),m(new n,function(){return function(a){var d;var e=(new Sb).c(a),e=Sm(e,1),e=(new Sb).c(e),f=e.R.length|0,h=0,k=!1;b:for(;;){if(h!==f){var p=1+h|0,h=e.W(h),h=null===h?0:h.X,k=!(!0===!!k&amp;&amp;92===h)&amp;&amp;92===h,h=p;continue b}break}e=!!k;try{if(1===(a.length|0))var t=!0;else var x=(new Sb).c(a),E=Tm(x),t=34!==(null===E?0:E.X);if(t||e)d=(new J).j((new ac).ae(u((new v).K((new w).f([&quot;&quot;,&quot;&quot;])),(new w).f([a])),Om(),&quot;Closing double quote is missing&quot;));
else{var S=fh(),U=(new Sb).c(a),ga=U.R.length|0,ma=Ye(Ze(),U.R,1,ga),va=(new Sb).c(ma),Fa=Ej(S,Sm(va,1));d=(new J).j((new ac).ae(u((new v).K((new w).f([&quot;&quot;,&quot;&quot;])),(new w).f([a])),Rm(),Fa))}}catch(Va){if(Va&amp;&amp;Va.$classData&amp;&amp;Va.$classData.n.mn)d=(new J).j((new ac).ae(u((new v).K((new w).f([&quot;&quot;,&quot;&quot;])),(new w).f([a])),Om(),&quot;Illegal character after backslash&quot;));else throw Va;}return d}}(a)))}
function ada(a){return jm(pm(),(new J).j((new af).Ra(34)),tb(new ub,function(){return function(a,d){d=null===d?0:d.X;if(Vk(a)){var e=a.U;if(92===(null===e?0:e.X)&amp;&amp;34===d)return(new A).e((new J).j((new af).Ra(34)),gm())}return Vk(a)&amp;&amp;(a=a.U,92===(null===a?0:a.X)&amp;&amp;92===d)?(new A).e(F(),gm()):34===d?(new A).e((new J).j((new af).Ra(34)),hm()):10===d?(new A).e(F(),mm()):(new A).e((new J).j((new af).Ra(d)),gm())}}(a)))}
function Tca(a){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/TokenLexer.scala: 12&quot;);return a.RV}
function Wca(a){var b=bda(a);return(new A).e(im(pm(),(new w).f([b,km(pm(),(new w).f([rm(125),rm(10),rm(13)]))])),m(new n,function(){return function(a){var b=(new Sb).c(a),b=Ye(Ze(),b.R,0,2);if(null===b||&quot;{{&quot;!==b)a=F();else if(b=(new Sb).c(a),b=Tm(b),10===(null===b?0:b.X)?b=!0:(b=(new Sb).c(a),b=Tm(b),b=13===(null===b?0:b.X)),b)a=(new J).j((new ac).ae(&quot;&quot;,Om(),&quot;End of line reached unexpectedly&quot;));else{var b=(new Sb).c(a),f=F(),h=b.R.length|0,k=0,p=0,t=f;b:for(;;){if(k!==h){f=1+k|0;k=b.W(k);k=null===
k?0:k.X;p|=0;c:{if(Vk(t)){var x=t.U;if(123===(null===x?0:x.X)&amp;&amp;123===k){p=1+p|0;t=k=F();break c}}if(Vk(t)&amp;&amp;(t=t.U,125===(null===t?0:t.X)&amp;&amp;125===k)){p=-1+p|0;t=k=F();break c}t=k=(new J).j((new af).Ra(k))}k=f;continue b}break}a=0&lt;(p|0)?(new J).j((new ac).ae(&quot;&quot;,Om(),&quot;End of file reached unexpectedly&quot;)):(new J).j((new ac).ae(a,cda(),a))}return a}}(a,b)))}function Um(){}Um.prototype=new l;Um.prototype.constructor=Um;Um.prototype.b=function(){return this};
function dda(a,b){eda||(eda=(new Vm).b());if((a=(new Wm).c(a))&amp;&amp;a.$classData&amp;&amp;a.$classData.n.VG)b=(new Xm).iU(a,0,b);else{var d=new Xm;Xm.prototype.iU.call(d,fda(a),0,b);b=d}return b}Um.prototype.$classData=g({x0:0},!1,&quot;org.nlogo.lex.WrapStringInput$&quot;,{x0:1,d:1});var gda=void 0;function Vm(){}Vm.prototype=new l;Vm.prototype.constructor=Vm;Vm.prototype.b=function(){return this};Vm.prototype.$classData=g({y0:0},!1,&quot;org.nlogo.lex.WrappedInput$&quot;,{y0:1,d:1});var eda=void 0;function Ym(){this.CC=null}
Ym.prototype=new l;Ym.prototype.constructor=Ym;function hda(a){var b=ida(a);a.CC.wa(m(new n,function(a){return function(b){var d=Zm(a,&quot;OTPL&quot;);Ob(d,b.fe);b.ji.M(d.h)}}(a)));var d=ida(a);(null===d?null===b:d.o(b))||hda(a)}function ida(a){var b=a.CC;a=m(new n,function(){return function(a){return a.ji.N()}}(a));var d=r();return b.xa(a,d.s).ub()}Ym.prototype.K=function(a){this.CC=a;return this};Ym.prototype.$classData=g({z0:0},!1,&quot;org.nlogo.parse.AgentTypeChecker&quot;,{z0:1,d:1});function $m(){}
$m.prototype=new l;$m.prototype.constructor=$m;$m.prototype.b=function(){return this};
function jda(a,b,d){for(;;){var e=b.$(),f=(new an).Ff(e).li.jb,h=Bm();if(null!==f&amp;&amp;f===h)return(new ac).ae((new bn).K(a),b.aa().aa(),d);kda((new an).Ff(e),d)?lda(cn(),dn(d,e.Wb.toUpperCase()),e):(&quot;-\x3e&quot;===(new an).Ff(e).li.Wb?f=!0:(f=e.jb,h=vg(),f=!(null!==f&amp;&amp;f===h)),f?(kh(),f=u((new v).K((new w).f([&quot;Expected a variable name here&quot;])),y()),e=e.ra,jh(f,e.Xa,e.Va,e.ab)):(f=r(),a=a.mc(e,f.s),b=b.aa(),f=r(),d=e=rc(d,I(f,(new w).f([e.Wb.toUpperCase()])),en())))}}
function mda(a,b){var d=a.$();if(fn((new an).Ff(d)))d=(new J).j(jda(I(r(),y()),a.aa(),b));else if(d=a.$(),&quot;-\x3e&quot;===(new an).Ff(d).li.Wb)d=(new J).j((new ac).ae((new gn).td(!0),a.aa(),b));else if(fn((new an).Ff(d)))d=F();else if(kda((new an).Ff(d),b))d=nda(I(r(),(new w).f([d])),a.aa(),b);else{a=a.aa();var e=r();b=rc(b,I(e,(new w).f([d.Wb.toUpperCase()])),en());e=a.$();if(&quot;-\x3e&quot;===(new an).Ff(e).li.Wb){var e=d.jb,f=Cm();null!==e&amp;&amp;e===f||hn(d.X)||oda(d.X)?d=(new J).j((new ac).ae((new jn).Ff(d),a.aa(),
b)):(kh(),a=u((new v).K((new w).f([&quot;Expected a variable name here&quot;])),y()),d=d.ra,jh(a,d.Xa,d.Va,d.ab),d=void 0)}else var f=e.jb,h=Am(),d=null!==f&amp;&amp;f===h?F():nda(I(r(),(new w).f([d,e])),a.aa(),b)}return d}
function pda(a,b,d){if(b.le(m(new n,function(){return function(a){return&quot;-\x3e&quot;===a.Wb}}(a)))){var e=b.wg();if(e.z())e=!1;else var e=e.Y().jb,f=Am(),e=null!==e&amp;&amp;e===f}else e=!1;e?(e=b.nn(),e.z()?e=!1:(e=e.Y().jb,f=Bm(),e=null!==e&amp;&amp;e===f)):e=!1;if(e){b=b.$d(1).Qd(1);d=mda(b,d);if(d.z())return F();e=d.Y();if(null!==e)d=e.gb,b=e.Fb,e=e.og,a=m(new n,function(a,b){return function(a){if(null!==a){var d=a.Wb,e=a.jb,f=a.X;if(vg()===e&amp;&amp;hn(f)&amp;&amp;b.lk().ib(a.Wb.toUpperCase()))return Gh(a,(new kn).ID(d.toUpperCase(),
!1),a.Wb,a.jb)}return a}}(a,d)),f=r(),a=b.xa(a,f.s),a=(new ac).ae(d,a,e);else throw(new q).j(e);return(new J).j(a)}return F()}function nda(a,b,d){for(;;){var e=b.$();if(&quot;-\x3e&quot;===(new an).Ff(e).li.Wb)if(1&lt;a.sa()){kh();var f=a.$().Lc().Xa,h=a.gd();jh(&quot;An anonymous procedures of two or more arguments must enclose its argument list in brackets&quot;,f,h.Lc().Va,e.ra.ab)}else e=a.$(),lda(cn(),dn(d,e.Wb.toUpperCase()),e);else{if(fn((new an).Ff(e)))return F();f=r();a=a.mc(e,f.s);b=b.aa()}}}
$m.prototype.$classData=g({E0:0},!1,&quot;org.nlogo.parse.ArrowLambdaScoper$&quot;,{E0:1,d:1});var ln=void 0;function an(){this.li=null}an.prototype=new l;an.prototype.constructor=an;function kda(a,b){return mn(b,a.li.Wb.toUpperCase())?!oda(a.li.X):!1}an.prototype.Ff=function(a){this.li=a;return this};function fn(a){a=a.li.jb;var b=Am();return null!==a&amp;&amp;a===b}an.prototype.$classData=g({F0:0},!1,&quot;org.nlogo.parse.ArrowLambdaScoper$RichToken$2&quot;,{F0:1,d:1});function nn(){this.ZS=this.AV=this.PS=null;this.a=0}
nn.prototype=new l;nn.prototype.constructor=nn;
nn.prototype.b=function(){on=this;for(var a=Xba(),b=null,b=[],d=a.l.length,e=0;e&lt;d;){var f=(new A).e(a.l[e],e);b.push(f);e=1+e|0}a=ka(Xa(pn),b);a=Xb(new Yb,(new qn).Gh(a),m(new n,function(){return function(a){return null!==a}}(this)));b=m(new n,function(){return function(a){if(null!==a){var b=a.Dc();a=a.la().toUpperCase();b=Yba(dh(),b);return(new A).e(a,b)}throw(new q).j(a);}}(this));d=(new rn).xg(pa(pn));a.ga.wa(m(new n,function(a,b,d){return function(e){return a.ol.y(e)?d.Na(b.y(e)):void 0}}(a,
b,d)));a=d.Da();b=dc(new ec,gc());d=0;for(e=a.l.length;d&lt;e;)hc(b,a.l[d]),d=1+d|0;a=b.Ma;b=dh();d=Xba();e=d.l.length;for(f=0;;){if(f&lt;e)var h=d.l[f],h=!sn(tn(),&quot;gray&quot;,h);else h=!1;if(h)f=1+f|0;else break}e=f;b=Yba(b,e&gt;=d.l.length?-1:e);this.PS=a.vj((new A).e(&quot;GREY&quot;,b));this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;a=(new A).e(&quot;FALSE&quot;,!1);b=(new A).e(&quot;TRUE&quot;,!0);d=Ph();a=[a,b,(new A).e(&quot;NOBODY&quot;,d),(new A).e(&quot;E&quot;,2.718281828459045),(new A).e(&quot;PI&quot;,3.141592653589793)];b=dc(new ec,gc());d=0;for(e=a.length|0;d&lt;e;)hc(b,a[d]),d=
1+d|0;this.AV=b.Ma;this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;if(0===(2&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/Constants.scala: 13&quot;);this.ZS=this.AV.Am(qda(this));this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;return this};function qda(a){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/Constants.scala: 10&quot;);return a.PS}
nn.prototype.es=function(a){if(0===(4&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/Constants.scala: 20&quot;);return this.ZS.dc(a.toUpperCase())};nn.prototype.$classData=g({O0:0},!1,&quot;org.nlogo.parse.Constants$&quot;,{O0:1,d:1});var on=void 0;function un(){}un.prototype=new l;un.prototype.constructor=un;un.prototype.b=function(){return this};un.prototype.$classData=g({R0:0},!1,&quot;org.nlogo.parse.DelayedBlock$&quot;,{R0:1,d:1});var rda=void 0;
function Cc(){this.DR=0;this.GR=this.FR=this.ER=this.OG=this.HG=this.FG=this.EG=this.GG=null;this.a=0}Cc.prototype=new l;Cc.prototype.constructor=Cc;
function sda(a,b,d,e,f,h){var k=I(Ec(),y()),p=vn(b),t=-1+p|0;if(!(0&gt;=p))for(p=0;;){var x=p,E=b.Pa,S=-1+wn(b.Pa)|0;k.uj(xn(a,b,f,d,e,Pi(E,x&lt;S?x:S)|0,h));if(p===t)break;p=1+p|0}yn(b)&amp;&amp;(t=f.$().jb,p=Am(),null!==t&amp;&amp;t===p?d=xn(a,b,f,d,e,zn(b.Pa)|0,h):(a=f.$().Lc().ab,b=k.nn(),b.z()?b=F():(b=b.Y(),b=(new J).j(b.Lc().Va)),d=(b.z()?d.Va:b.Y())|0,d=Bb(new Cb,(new Fb).c(a),Lm(new Mm,d,d,a),!0)),k.uj(d));return k.Hc()}
Cc.prototype.b=function(){Ac=this;this.DR=-1;this.a|=1;this.GG=&quot;Expected command.&quot;;this.a|=2;this.EG=&quot;Expected closing bracket.&quot;;this.a|=4;this.FG=&quot;Expected a closing parenthesis here.&quot;;this.a|=8;this.HG=&quot;Expected reporter.&quot;;this.a|=16;this.OG=&quot;To use a non-default number of inputs, you need to put parentheses around this.&quot;;this.a|=32;this.ER=&quot;No closing bracket for this open bracket.&quot;;this.a|=64;this.FR=&quot;No closing parenthesis for this open parenthesis.&quot;;this.a|=128;this.GR=&quot;Missing input on the left.&quot;;
this.a|=256;return this};function tda(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,An(a)?&quot; on the right&quot;:&quot;&quot;)}
function uda(a,b,d,e,f,h){if(d&amp;&amp;En(b)){d=e.Lc();var k=Eh(e.Bx());a:{var p=b.Pa,t=I(r(),y());for(;;){var x=f.$();if(null!==x){var E=x.jb;if(zm()===E){f=t;break a}}if(null!==x&amp;&amp;(E=x.jb,x=x.X,vg()===E&amp;&amp;x&amp;&amp;x.$classData&amp;&amp;x.$classData.n.ca&amp;&amp;(p.$()|0)!==Xj(D())&amp;&amp;An(x.G()))){kh();if(t.Ga()!==Fn(b)){f=a;if(0===(32&amp;f.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 702&quot;);jh(f.OG,d.Xa,d.Va,d.ab)}f=t;break a}x=xn(a,b,f,d,k,p.$()|0,h);p=p.aa().He()?
p.aa():p;E=r();t=t.mc(x,E.s)}}}else d=e.Lc(),f=sda(a,b,d,Eh(e.Bx()),f,h);d=e.Lc();return vda(a,b,f,d,Eh(e.Bx()),h)}
function wda(a,b,d,e){var f=b.Gy().aa().Oa().Om(),h=!Gn(D(),d,Pj(D()));if(Gn(D(),d,uk())){if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.GP)a=b.gC;else{if(!(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.FP))throw(new q).j(b);a=b.Gy()}d=a.Qd(2);e=I(r(),y());a:for(;;){if(d.z())e.z()||(d=e.$().jb,e=ym(),null!==d&amp;&amp;d===e&amp;&amp;(kh(),d=b.Gy().gd().Lc(),jh(&quot;Expected close paren here&quot;,d.Xa,d.Va,d.ab)));else{f=d.$().jb;h=Am();null!==f&amp;&amp;f===h?(f=d.aa(),d=d.$(),h=r(),e=e.fd(d,h.s),d=f):(f=d.$().jb,h=ym(),null!==f&amp;&amp;f===h?(f=d.aa(),d=d.$(),
h=r(),e=e.fd(d,h.s),d=f):(f=d.$().jb,h=Bm(),null!==f&amp;&amp;f===h?(e.z()?f=!1:(f=e.$().jb,h=ym(),f=null!==f&amp;&amp;f===h),f&amp;&amp;(kh(),f=d.$().Lc(),jh(&quot;Expected close paren before close bracket here&quot;,f.Xa,f.Va,f.ab)),e.z()?f=!0:(f=e.$().jb,h=Am(),f=!(null!==f&amp;&amp;f===h)),f&amp;&amp;(kh(),f=d.$().Lc(),jh(&quot;Closing bracket has no matching open bracket here&quot;,f.Xa,f.Va,f.ab)),d=d.aa(),e=e.aa()):(f=d.$().jb,h=zm(),null!==f&amp;&amp;f===h?(e.z()?f=!1:(f=e.$().jb,h=Am(),f=null!==f&amp;&amp;f===h),f&amp;&amp;(kh(),f=d.$().Lc(),jh(&quot;Expected close bracket before close paren here&quot;,
f.Xa,f.Va,f.ab)),e.z()?f=!0:(f=e.$().jb,h=ym(),f=!(null!==f&amp;&amp;f===h)),f&amp;&amp;(kh(),f=d.$().Lc(),jh(&quot;Closing paren has no matching open paren here&quot;,f.Xa,f.Va,f.ab)),d=d.aa(),e=e.aa()):d=d.aa())));continue a}break}d=(new Hn).K(a.aa().Qd(2));d.L(a.$());e=a.$().Lc().Xa;b=b.Lc().Va;a=a.$();return In(new Kb,d,Lm(new Mm,e,b,a.Lc().ab))}if(b.OD()&amp;&amp;!b.zu())return xda(a,b.ve,b,f);if(b.OD()&amp;&amp;b.zu())return yda(a,b.ve,b,f);if(Gn(D(),d,ak(D()))){a=zda(a,d,e,b,f);if(null===a)throw(new q).j(a);d=a.pa();return Db(new Eb,
a.la(),Lm(new Mm,b.Ng.ra.Xa,d.ra.Va,d.ra.ab))}if(Gn(D(),d,Zj(D()))){a=Ada(a,f,e,b);if(null===a)throw(new q).j(a);d=a.pa();return Jn(Lm(new Mm,b.Ng.ra.Xa,d.ra.Va,d.ra.ab),a.la(),!1)}if(Gn(D(),d,Xj(D()))&amp;&amp;!b.zu()&amp;&amp;h)return xda(a,(new gn).td(!1),b,f);if(Gn(D(),d,Yj(D()))&amp;&amp;b.zu()&amp;&amp;h)return yda(a,(new gn).td(!1),b,f);if(Gn(D(),d,Pj(D()))){d=Bda(Cda(new Kn,Dda()),b.Ng,f);if(null===d)throw(new q).j(d);a=d.pa();d=(new Ln).j(d.la());e=Rm();d.L(Jm(new Km,&quot;&quot;,e,null,Lm(new Mm,b.Ng.ra.Xa,a.ra.Va,a.ra.ab)));return In(new Kb,
d,Lm(new Mm,b.Ng.ra.Xa,a.ra.Va,a.ra.ab))}kh();a=u((new v).K((new w).f([&quot;Expected &quot;,&quot; here, rather than a list or block.&quot;])),(new w).f([zk(Ck(),d)]));b=b.Lc();jh(a,b.Xa,b.Va,b.ab)}function Mn(a,b,d){return d.La?d.hb:Eda(a,b,d)}
function Fda(a,b,d,e,f,h){var k=b.$(),p=f===(Xj(D())|Yj(D())),t=p||f===Xj(D()),x=p||f===Yj(D()),E=k.jb;if(ym()===E){var S=k.ra.ab,U=b.ma();$e();var ga=U.jb,ma=ym();Nn(0,null!==ga&amp;&amp;ga===ma);var va=Gda(a,b,!0,f,h);kh();var Fa=b.$().jb,Va=ug();if(null!==Fa&amp;&amp;Fa===Va){var vb=On(a),pb=k.ra;jh(vb,pb.Xa,pb.Va,pb.ab)}var Ib=b.ma();kh();var kc=Ib.jb,$a=Dc();if(null!==kc&amp;&amp;kc===$a){var fc=On(a),Bc=U.ra;jh(fc,Bc.Xa,Bc.Va,Bc.ab)}kh();var sf=Ib.jb,Sf=zm();if(null===sf||sf!==Sf){var th=Hda(a),Te=Ib.ra;jh(th,Te.Xa,
Te.Va,Te.ab)}var tf=va.Et(Lm(new Mm,U.ra.Xa,Ib.ra.Va,S))}else if(Am()===E){var ek;a:{var og=(new Pn).So((new Qn).xg(pa(Ida))),uh=0;for(;;){var pg=b.ma(),Yh=pg.jb,Ri=Am();if(null!==Yh&amp;&amp;Yh===Ri)var fk=og.uj(pg),Si=1+uh|0,og=fk,uh=Si;else{var gk=pg.jb,Ti=Bm();if(null!==gk&amp;&amp;gk===Ti){if(1===uh){ek=og.uj(pg).Hc();break a}var vl=og.uj(pg),Ui=-1+uh|0,og=vl,uh=Ui}else{var hk=pg.jb,Vi=Dc();if(null===hk||hk!==Vi)og=og.uj(pg);else{kh();var wl=Rn(a),vh=k.ra;jh(wl,vh.Xa,vh.Va,vh.ab)}}}}}var xl=ek.Hc();rda||(rda=
(new un).b());a:{var wh=xl.aa(),ik;ln||(ln=(new $m).b());ik=ln;var yl=r(),Zh=pda(ik,wh.fd(k,yl.s),h);if(Vk(Zh)){var $h=Zh.U;if(null!==$h){var zl=$h.gb,Al=$h.Fb,Bl=$h.og,jk=wh.gd(),Cl=r(),Dl=wh.fd(k,Cl.s),El=Nm(),Fl=r(),kk=new Sn,Gl=Dl.mc(El,Fl.s);Sn.prototype.jU.call(kk,k,zl,Al,jk,Gl,Bl,Lm(new Mm,k.ra.Xa,jk.ra.Va,k.ra.ab));tf=kk;break a}}if(F()===Zh){var ai=new Tn,lk=wh.nn();if(lk.z())var xh=F();else var Hl=lk.Y(),xh=(new J).j(Hl.ra.Va);var Wi=(xh.z()?k.ra.Va:xh.Y())|0;Tn.prototype.kU.call(ai,k,wh,
h,Lm(new Mm,k.ra.Xa,Wi,k.ra.ab));tf=ai}else throw(new q).j(Zh);}}else if(vg()!==E&amp;&amp;ug()!==E||!Gn(D(),f,xk()))if(vg()===E||Rm()===E){b.ma();var mk=k.jb;if(Rm()===mk){var yh=(new Ln).j(k.X);yh.L(k);var Uf=(new A).e(yh.G(),In(new Kb,yh,k.ra))}else{vg()!==mk&amp;&amp;Un(Vn(),&quot;unexpected token type: &quot;+k.jb);var ue=k.X;if(Wn(ue)||hn(ue))if(f===xk())Uf=(new A).e(ue.G(),In(new Kb,ue,k.ra));else{Jda||(Jda=(new Xn).b());var zh;if(hn(ue)){var bi=h.es(k.Wb.toUpperCase()),nk=(new Yn).Ff(k);if(bi.z())Yi=F();else var Xi=
md(new nd,nk),Il=bi.Y(),Yi=Xi.Uc(Il);if(Yi.z())zh=F();else{var Jl=Yi.Y();zh=(new J).j((new A).e(Jl,h))}}else zh=F();if(zh.z())var Zi=F();else{var $i=zh.Y();if(null===$i)throw(new q).j($i);var ok=$i.la(),Zi=(new J).j((new A).e(ok.G(),In(new Kb,ok,k.ra)))}if(Zi.z()){kh();var Kl=rh(),aj=[k.Wb.toUpperCase()],ci=Kl.Vl.dc(&quot;compiler.LetVariable.notDefined&quot;);if(!Vk(ci)){if(F()===ci)throw(new df).c(u((new v).K((new w).f([&quot;coding error, bad translation key: &quot;,&quot; for Errors&quot;])),(new w).f([&quot;compiler.LetVariable.notDefined&quot;])));
throw(new q).j(ci);}var Ll=ci.U,Rg=aj.length|0;if(0&gt;=Rg)var Sg=0;else var pk=Rg&gt;&gt;31,Sg=(0===pk?-1&lt;(-2147483648^Rg):0&lt;pk)?-1:Rg;r();Zn();var bj=[],Ah=0,qk=aj.length|0;0&gt;Sg&amp;&amp;$n(ao(),0,Rg,1,!1);for(var Ml=qk&lt;Sg?qk:Sg;Ah&lt;Ml;){var rk=aj[Ah],Tg=Ah;0&gt;Sg&amp;&amp;$n(ao(),0,Rg,1,!1);if(0&gt;Tg||Tg&gt;=Sg)throw(new P).c(&quot;&quot;+Tg);var Nl=(new A).e(rk,Tg);bj.push(Nl);Ah=1+Ah|0}var cj=bj.length|0,di=0,Bh=Ll;a:for(;;){if(di!==cj){var Ol=1+di|0,qg=(new A).e(Bh,bj[di]);b:{var fi,Ch=qg.kb,dj=qg.Ab;if(null!==dj){var Ug=dj.la(),ej=
dj.Dc();if(Qg(Ug)){var fj=Ug;fi=Qb(Ia(),Ch,u((new v).K((new w).f([&quot;\\\\{&quot;,&quot;\\\\}&quot;])),(new w).f([&quot;&quot;+ej])),fj);break b}}throw(new q).j(qg);}di=Ol;Bh=fi;continue a}break}var gi=k.ra;jh(Bh,gi.Xa,gi.Va,gi.ab)}Uf=Zi.Y()}else if(!An(ue.G())||t)Uf=(new A).e(ue.G(),In(new Kb,ue,k.ra));else{if(!bo(ue)||!d)throw(new co).Ff(k);var hi=(new eo).b();hi.L(k);Uf=(new A).e(hi.G(),In(new Kb,hi,k.ra))}}if(null===Uf)throw(new q).j(Uf);var gj=Uf.la(),Vf=Uf.pa(),vf;if(vf=t&amp;&amp;!d){var ae;a:{var hj=Vf.pe;if(Gn(D(),hj.G().Wa,
uk()|xk()))ae=!0;else{for(var rg=hj.G().Pa;!rg.z();){var ij=rg.$()|0;if(Gn(D(),ij,uk()|xk())){ae=!0;break a}rg=rg.aa()}ae=!1}}vf=!ae}var jj;if(vf&amp;&amp;(p||0&lt;Fn(gj))){var ii=Vf.pe,ji=Kda(a,Fn(ii.G()),ii.H(),h);if(null===ji)throw(new q).j(ji);var Pl=ji.pa(),sk=(new fo).ku((new go).K(ji.la()));sk.L(ii.H());jj=(new Kb).Qf(sk,I(r(),(new w).f([Lda(Vf,Pl)])),ii.H().ra)}else jj=Lda(Vf,uda(a,gj,d,Vf,b,h));tf=jj}else{if(ug()!==E||!x)throw(new ho).Ff(k);b.ma();var Vg=k.X;if(!Vg.G().Dr)throw(new ho).Ff(k);var ki=
Kda(a,Fn(Vg.G()),Vg.H(),h);if(null===ki)throw(new q).j(ki);var Ql=ki.la(),tk=ki.pa();if(yn(Vg.G()))var ei=Bb(new Cb,(new Fb).c(k.ra.ab),k.ra,!0),qF=r(),xw=tk.mc(ei,qF.s);else xw=tk;var cx=(new io).ku((new go).K(Ql));cx.L(k);var WF=(new Hb).cj(Vg,xw,k.ra),wr=Jn(k.ra,I(r(),(new w).f([WF])),!0),tf=(new Kb).Qf(cx,I(r(),(new w).f([wr])),k.ra)}else{b.ma();var dx=(new jo).b();Gh(k,dx,k.Wb,k.jb);tf=In(new Kb,dx,k.ra)}for(var vk=tf,Bn=!1;!Bn;){var am=b.$(),ex=am.jb,xr=vg();if(null!==ex&amp;&amp;ex===xr){var Cn=am.X,
wk=Cn.G();if(An(wk)&amp;&amp;(wk.dp&gt;e||wk.ts&amp;&amp;wk.dp===e)){b.ma();kh();if(null===vk){var YF=Mda(a),yr=am.ra;jh(YF,yr.Xa,yr.Va,yr.ab)}var bm=Lm(new Mm,vk.Lc().Xa,am.ra.Va,am.ra.ab),zr=sda(a,wk,bm,Eh(Cn),b,h),ZF=vk,$F=r(),Dn=vda(a,wk,zr.fd(ZF,$F.s),bm,Eh(Cn),h),aG=Dn.gd().Lc().Va,vk=(new Kb).Qf(Cn,Dn,Lm(new Mm,bm.Xa,aG,bm.ab))}else Bn=!0}else Bn=!0}return vk}
function xn(a,b,d,e,f,h,k){try{return Fda(a,d,!1,b.dp,h,k)}catch(p){if(d=ko(Lg(),p),null!==d)if(d&amp;&amp;d.$classData&amp;&amp;d.$classData.n.aB||d&amp;&amp;d.$classData&amp;&amp;d.$classData.n.bB)kh(),a=lo(a,b,f,!0),jh(a,e.Xa,e.Va,e.ab);else throw Kg(Lg(),d);else throw p;}}
function Fc(a,b,d,e){var f=b.$(),h=f.jb;if(ym()===h){f=f.ra.ab;d=b.ma();$e();var h=d.jb,k=ym();Nn(0,null!==h&amp;&amp;h===k);e=Fc(a,b,!0,e);b=b.ma();kh();h=b.jb;k=Dc();null!==h&amp;&amp;h===k&amp;&amp;(h=On(a),k=d.ra,jh(h,k.Xa,k.Va,k.ab));kh();h=b.jb;k=zm();if(null===h||h!==k)a=Hda(a),h=b.ra,jh(a,h.Xa,h.Va,h.ab);b=(new A).e(e,Lm(new Mm,d.ra.Xa,b.ra.Va,f));a=b.kb;f=b.Ab;if(null!==a)b=a.pa(),a=a.la();else throw(new q).j(b);return(new A).e((new Hb).cj(a.xd,a.za,f),b)}if(ug()===h){b.ma();var h=f.X,k=b.$().jb,p=Dc(),p=null===
k||k!==p?(new J).j(b.$()):F();Nda||(Nda=(new mo).b());a:{var t=!1,k=null;if(no(h)){var t=!0,k=h,x=k.Wc;if(F()===x){t=!1;x=null;if(Vk(p)&amp;&amp;(t=!0,x=p,p=x.U,null!==p)){var E=p.Wb,S=p.jb;if(vg()===S){t=E.toUpperCase();x=(new oo).c(t);E=e.es(t);E.z()||(E=E.Y(),kh(),E=&quot;There is already a &quot;+po(cn(),E)+&quot; called &quot;+t,p=p.ra,jh(E,p.Xa,p.Va,p.ab));k=(new J).j((new A).e(Oda(k,x),Pda(e,t,(new qo).ks(x))));break a}}t&amp;&amp;(k=x.U,kh(),k=k.ra,jh(&quot;Expected variable name here&quot;,k.Xa,k.Va,k.ab));k=F();break a}}if(t&amp;&amp;(k=k.Wc,
Vk(k))){k=k.U;k=(new J).j((new A).e(h,Pda(e,k.va.toUpperCase(),(new qo).ks(k))));break a}k=F()}if(k.z())k=F();else{k=k.Y();if(null===k)throw(new q).j(k);p=k.pa();k=(new J).j((new A).e(Qda(k.la(),f.ra),p))}e=k.z()?(new A).e(Qda(h,f.ra),e):k.Y();if(null===e)throw(new q).j(e);f=e.la();e=e.pa();a=uda(a,h.G(),d,f,b,e);return(new A).e(Rda(f,a),e)}b=f.X;if(!Wn(b)&amp;&amp;!hn(b)||mn(e,f.Wb.toUpperCase())){kh();if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 698&quot;);
f=f.ra;jh(a.GG,f.Xa,f.Va,f.ab)}else{kh();a=rh();b=[f.Wb.toUpperCase()];a=a.Vl.dc(&quot;compiler.LetVariable.notDefined&quot;);if(!Vk(a)){if(F()===a)throw(new df).c(u((new v).K((new w).f([&quot;coding error, bad translation key: &quot;,&quot; for Errors&quot;])),(new w).f([&quot;compiler.LetVariable.notDefined&quot;])));throw(new q).j(a);}e=a.U;d=b.length|0;0&gt;=d?h=0:(a=d&gt;&gt;31,h=(0===a?-1&lt;(-2147483648^d):0&lt;a)?-1:d);r();Zn();a=[];k=0;p=b.length|0;0&gt;h&amp;&amp;$n(ao(),0,d,1,!1);for(p=p&lt;h?p:h;k&lt;p;){t=b[k];x=k;0&gt;h&amp;&amp;$n(ao(),0,d,1,!1);if(0&gt;x||x&gt;=h)throw(new P).c(&quot;&quot;+
x);t=(new A).e(t,x);a.push(t);k=1+k|0}b=a.length|0;d=0;h=e;a:for(;;){if(d!==b){e=1+d|0;h=(new A).e(h,a[d]);b:{d=h.kb;p=h.Ab;if(null!==p&amp;&amp;(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),d,u((new v).K((new w).f([&quot;\\\\{&quot;,&quot;\\\\}&quot;])),(new w).f([&quot;&quot;+p])),h);break b}throw(new q).j(h);}d=e;continue a}break}f=f.ra;jh(h,f.Xa,f.Va,f.ab)}}function Sda(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,En(a)?&quot; at least&quot;:&quot;&quot;)}
function Eda(a,b,d){if(null===d)throw(new Oe).b();if(d.La)return d.hb;b=b.Pa;a=function(){return function(a){a|=0;Ia();a=zk(Ck(),a);if(null===a)throw(new Oe).b();var b=Eg(Dg(),&quot;anything&quot;);a=Fg(new Gg,b,a,a.length|0);ro(a);oi(a)?(b=(new so).b(),to(a,b,&quot;any input&quot;),uo(a,b),a=b.Zb):a=a.Uo;return a}}(a);var e=B().s;if(e===B().s)if(b===y())a=y();else{var e=b.$(),f=e=Cd(new Dd,a(e),y());for(b=b.aa();b!==y();){var h=b.$(),h=Cd(new Dd,a(h),y()),f=f.Ia=h;b=b.aa()}a=e}else{for(e=Mc(b,e);!b.z();)f=b.$(),e.Na(a(f)),
b=b.aa();a=e.Da()}return Pe(d,a)}function Jn(a,b,d){b=(new Fb).Ro(a.ab,b);return Bb(new Cb,b,a,d)}
function Gda(a,b,d,e,f){try{if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 23&quot;);return Fda(a,b,d,a.DR,e,f)}catch(h){if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.aB)kh(),a=Mda(a),b=h.Iv.ra,jh(a,b.Xa,b.Va,b.ab);else if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.bB){kh();if(0===(16&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 701&quot;);b=h.Iv.ra;jh(a.HG,b.Xa,b.Va,
b.ab)}else throw h;}}function Tda(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,1&lt;vn(a)?&quot;inputs&quot;:&quot;input&quot;)}function xda(a,b,d,e){e=zda(a,lc(),d.iq,d,e);if(null===e)throw(new q).j(e);a=e.la();e=e.pa();b=(new fo).ku(b);b.L(d.Ng);a=I(r(),(new w).f([a]));return(new Kb).Qf(b,a,Lm(new Mm,d.Ng.ra.Xa,e.ra.Va,d.Lc().ab))}
function vo(a,b,d,e,f){a=d&amp;&amp;d.$classData&amp;&amp;d.$classData.n.QP?wda(a,d,b,f):d;kh();Gn(D(),b,a.Dn())||(d=0===(b&amp;Jj())&amp;&amp;0!==(a.Dn()&amp;~Jj())?a.Dn()&amp;~Jj():a.Dn(),b=u((new v).K((new w).f([&quot;&quot;,&quot; expected this input to be &quot;,&quot;, but got &quot;,&quot; instead&quot;])),(new w).f([e,zk(Ck(),b),zk(Ck(),d)])),e=a.Lc(),jh(b,e.Xa,e.Va,e.ab));return a}function On(a){if(0===(128&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 705&quot;);return a.FR}
function Ada(a,b,d,e){for(var f=Bm(),h=I(Ec(),y());;){var k=b.$().jb;if(null===k||k!==f){kh();var p=b.$().jb,t=Dc(),k=e.Ng;null!==p&amp;&amp;p===t&amp;&amp;(p=Rn(a),k=k.ra,jh(p,k.Xa,k.Va,k.ab));d=Fc(a,b,!1,d);if(null===d)throw(new q).j(d);k=d.la();d=d.pa();h.uj(k)}else break}a=h.Hc();return(new A).e(a,b.ma())}
function lo(a,b,d,e){var f=(new Ne).b(),h=(new Ne).b(),k=(new Ne).b(),p=(new Ne).b(),t;if(t=e&amp;&amp;En(b))t=b.ys,t=0===((t.z()?wo(b):t.Y())|0);d=t?u((new v).K((new w).f([&quot;&quot;,&quot; expected &quot;,&quot; &quot;,&quot; on the right or any number of inputs when surrounded by parentheses&quot;])),(new w).f([d,vn(b),f.La?f.hb:Tda(b,f)])):e?u((new v).K((new w).f(&quot;; expected; ; ;;&quot;.split(&quot;;&quot;))),(new w).f([d,h.La?h.hb:Sda(b,h),vn(b),f.La?f.hb:Tda(b,f),k.La?k.hb:tda(b,k)])):u((new v).K((new w).f([&quot;&quot;,&quot; expected &quot;,&quot; on the left&quot;])),(new w).f([d,
zk(Ck(),b.Wa)]));if(e){a:{for(e=Mn(a,b,p);!e.z();){if(&quot;any input&quot;!==e.$()){e=!1;break a}e=e.aa()}e=!0}if(e)return u((new v).K((new w).f([&quot;&quot;,&quot;.&quot;])),(new w).f([d]));e=Mn(a,b,p);if(1===wn(e))return e=(new v).K((new w).f([&quot;&quot;,&quot;, &quot;,&quot;.&quot;])),a=Mn(a,b,p),u(e,(new w).f([d,cc(a,&quot;&quot;,&quot;&quot;,&quot;&quot;)]));e=(new v).K((new w).f([&quot;&quot;,&quot;, &quot;,&quot; and &quot;,&quot;.&quot;]));f=Mn(a,b,p);f=xo(f,1).zb(&quot;, &quot;);a=Mn(a,b,p);return u(e,(new w).f([d,f,zn(a)]))}return d}
function Hda(a){if(0===(8&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 700&quot;);return a.FG}
function Kda(a,b,d,e){var f=1&gt;b,h=null,h=(new A).e(I(r(),y()),e);if(!f)for(e=1;;){h=(new A).e(h,e);f=h.kb;if(null!==f){var h=f.la(),k=Uda(f.pa());if(null===k)throw(new q).j(k);var f=k.la(),k=k.pa(),p=r(),h=(new A).e(h.mc(f,p.s),k)}else throw(new q).j(h);if(e===b)break;e=1+e|0}b=h;if(null===b)throw(new q).j(b);b=b.la();a=m(new n,function(a,b){return function(a){a=(new kn).ID(a,!0);a.L(b);return In(new Kb,a,Lm(new Mm,b.ra.Xa,b.ra.Va,b.ra.ab))}}(a,d));d=r();a=b.xa(a,d.s);return(new A).e(b,a)}
function vda(a,b,d,e,f,h){yo||(yo=(new zo).b());var k=I(yo,d),p=0;if(An(b)){p=b.Wa;kh();if(!(1&lt;=d.Ga())){var t=lo(a,b,f,!1);jh(t,e.Xa,e.Va,e.ab)}k.nf(0,vo(a,p,d.W(0),f,h));p=1}for(var t=0,x=b.Pa;;){if(t&lt;wn(x)){D();var E=Ij(),E=!Gn(0,E,Pi(x,t)|0)}else E=!1;if(E){t===(-1+wn(x)|0)&amp;&amp;d.Ga()===(-1+wn(x)|0)?(D(),E=yk(),E=Gn(0,E,Pi(x,t)|0)):E=!1;if(E)return I(Ao(),k);kh();d.Ga()&gt;p||(E=lo(a,b,f,!0),jh(E,e.Xa,e.Va,e.ab));k.nf(p,vo(a,Pi(x,t)|0,d.W(p),f,h));t=1+t|0;p=1+p|0}else break}if(t&lt;wn(x)){for(var E=-1+
d.Ga()|0,S=-1+wn(x)|0;;){if(0&lt;=S){D();var U=Ij(),U=!Gn(0,U,Pi(x,S)|0)}else U=!1;if(U)kh(),d.Ga()&gt;E&amp;&amp;-1&lt;E||(U=lo(a,b,f,!0),jh(U,e.Xa,e.Va,e.ab)),k.nf(E,vo(a,Pi(x,S)|0,d.W(E),f,h)),S=-1+S|0,E=-1+E|0;else break}for(;p&lt;=E;)k.nf(p,vo(a,Pi(x,t)|0,d.W(p),f,h)),p=1+p|0}return I(Ao(),k)}
function yda(a,b,d,e){a=Ada(a,e,d.iq,d);if(null===a)throw(new q).j(a);e=a.la();a=a.pa();b=(new io).ku(b);b.L(d.Ng);e=Jn(Lm(new Mm,d.Ng.ra.Xa,a.ra.Va,d.Lc().ab),e,!1);e=I(r(),(new w).f([e]));return(new Kb).Qf(b,e,Lm(new Mm,d.Ng.ra.Xa,a.ra.Va,d.Lc().ab))}function Mda(a){if(0===(256&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 706&quot;);return a.GR}
function zda(a,b,d,e,f){b=vo(a,lc(),Gda(a,f,!1,b,d),null,d);f=f.ma();kh();d=f.jb;var h=Dc();e=e.Ng;null!==d&amp;&amp;d===h&amp;&amp;(d=Rn(a),e=e.ra,jh(d,e.Xa,e.Va,e.ab));kh();e=f.jb;d=Bm();if(null===e||e!==d){if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 699&quot;);e=f.ra;jh(a.EG,e.Xa,e.Va,e.ab)}return(new A).e(b,f)}
function Rn(a){if(0===(64&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 704&quot;);return a.ER}Cc.prototype.$classData=g({S0:0},!1,&quot;org.nlogo.parse.ExpressionParser$&quot;,{S0:1,d:1});var Ac=void 0;function Bo(){}Bo.prototype=new l;Bo.prototype.constructor=Bo;Bo.prototype.b=function(){return this};
function Co(a,b){var d=!1,e=null;return Do(b)&amp;&amp;(d=!0,e=b,a=e.X,Zg(a))?(b=Eo(),$b(b,a,!0,!1)):d?e.H().Wb:Fo(b)||Go(b)&amp;&amp;b.qj?&quot;&quot;:b.H().Wb}function Vda(a,b,d){return Vc(new Wc,&quot;&quot;,b,m(new n,function(){return function(a){return Co(0,a)}}(a)),d)}function Wda(){var a=Ho();m(new n,function(){return function(a){return Co(0,a)}}(a))}Bo.prototype.$classData=g({V0:0},!1,&quot;org.nlogo.parse.Formatter$&quot;,{V0:1,d:1});var Io=void 0;function Ho(){Io||(Io=(new Bo).b());return Io}function Jo(){this.qt=null}
Jo.prototype=new l;Jo.prototype.constructor=Jo;function Uc(a){var b=new Jo;b.qt=a;return b}function Tc(a,b){return Vc(new Wc,&quot;&quot;+a.qt.Wb+b,a.qt.Uj,a.qt.am,a.qt.pf)}Jo.prototype.$classData=g({W0:0},!1,&quot;org.nlogo.parse.Formatter$RichFormat&quot;,{W0:1,d:1});
function yaa(a,b){b=Faa(a,b);if(null===b)throw(new q).j(b);var d=b.la();b=b.pa();var d=I(r(),(new w).f([(new Ko).b(),(new Lo).b(),(new Mo).b(),new No])).Gb(d,tb(new ub,function(a){return function(b,d){d=m(new n,function(a,b){return function(a){return b.$g(a)}}(a,d));var e=r();return b.xa(d,e.s)}}(a))),e=(new Oo).b();d.wa(m(new n,function(a,b){return function(a){Ob(b,a.fe)}}(a,e)));hda((new Ym).K(d));e=(new Po).b();a=m(new n,function(a,b){return function(a){return b.$g(a)}}(a,e));e=r();a=d.xa(a,e.s);
return(new A).e(a,b)}function mo(){}mo.prototype=new l;mo.prototype.constructor=mo;mo.prototype.b=function(){return this};mo.prototype.$classData=g({a1:0},!1,&quot;org.nlogo.parse.LetScope$&quot;,{a1:1,d:1});var Nda=void 0;function Xn(){}Xn.prototype=new l;Xn.prototype.constructor=Xn;Xn.prototype.b=function(){return this};Xn.prototype.$classData=g({b1:0},!1,&quot;org.nlogo.parse.LetVariableScope$&quot;,{b1:1,d:1});var Jda=void 0;function Kn(){this.AG=this.yG=this.xG=this.wG=this.hD=null;this.a=0}Kn.prototype=new l;
Kn.prototype.constructor=Kn;function Bda(a,b,d){for(var e=Xda(Qo(),y()),f=F();!f.ba();){var h=d.ma(),k=h.jb;if(Bm()===k)f=(new J).j(h);else if(Dc()===k){kh();h=a;if(0===(32&amp;h.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/LiteralParser.scala: 25&quot;);k=b.ra;jh(h.AG,k.Xa,k.Va,k.ab)}else e=Ro(e,So(a,h,d))}return(new A).e(e,f.Y())}
function So(a,b,d){var e=b.jb;if(cda()===e)a=a.hD,kh(),a=Yda(a),b=b.ra,jh(a,b.Xa,b.Va,b.ab);else{if(Rm()===e)return b.X;if(Am()===e){a=Bda(a,b,d);if(null===a)throw(new q).j(a);return a.la()}if(Rca()===e)a=a.hD,kh(),b=d.ma(),a=Yda(a),b=b.Lc(),jh(a,b.Xa,b.Va,b.ab);else{if(ym()===e){b=So(a,d.ma(),d);d=d.ma();kh();var e=d.jb,f=zm();if(null===e||e!==f){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/LiteralParser.scala: 20&quot;);d=d.ra;jh(a.wG,d.Xa,
d.Va,d.ab)}return b}if(Dm()===e)return So(a,d.ma(),d);kh();if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/LiteralParser.scala: 21&quot;);b=b.ra;jh(a.xG,b.Xa,b.Va,b.ab)}}}
function Cda(a,b){a.hD=b;a.wG=&quot;Expected a closing parenthesis.&quot;;a.a=(1|a.a)&lt;&lt;24&gt;&gt;24;a.xG=&quot;Expected a literal value.&quot;;a.a=(2|a.a)&lt;&lt;24&gt;&gt;24;a.a=(4|a.a)&lt;&lt;24&gt;&gt;24;a.yG=&quot;Extra characters after literal.&quot;;a.a=(8|a.a)&lt;&lt;24&gt;&gt;24;a.a=(16|a.a)&lt;&lt;24&gt;&gt;24;a.AG=&quot;No closing bracket for this open bracket.&quot;;a.a=(32|a.a)&lt;&lt;24&gt;&gt;24;return a}Kn.prototype.$classData=g({e1:0},!1,&quot;org.nlogo.parse.LiteralParser&quot;,{e1:1,d:1});function To(){}To.prototype=new l;To.prototype.constructor=To;
function Zda(a,b,d){var e=b.wo;if(Uo(e)){var f=Qba(Rb(),e).al(m(new n,function(a,b){return function(a){return mn(b,a.toUpperCase())}}(a,d)),!1),h=m(new n,function(){return function(a){return(new A).e(a,Vo())}}(a)),k=r(),f=f.xa(h,k.s),h=Nba(Rb(),e).al(m(new n,function(a,b){return function(a){return mn(b,a.toUpperCase())}}(a,d)),!1),k=m(new n,function(){return function(a){return(new A).e(a,Wo())}}(a)),p=r(),h=h.xa(k,p.s),k=r();f.Rc(h,k.s).wa(m(new n,function(a,b,d,e){return function(a){if(null!==a){a=
a.la();kh();var f=dn(d,a.toUpperCase()),f=po(cn(),f);a=u((new v).K((new w).f([&quot;Defining a breed [&quot;,&quot; &quot;,&quot;] redefines &quot;,&quot;, a &quot;,&quot;&quot;])),(new w).f([e.ql.va,e.Bf.va,a,f]));f=b.sk.g.ra;jh(a,f.Xa,f.Va,f.ab)}else throw(new q).j(a);}}(a,b,d,e)))}}To.prototype.b=function(){return this};
function $da(a,b,d){kh();var e=d.sk.va;if(!(e=a.toLowerCase()!==(null===e?null:e.toLowerCase()))){if(a=!!(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.Hm))a=d.Rn,a=Xo()===b&amp;&amp;Yo(a)||Yo(b)&amp;&amp;Xo()===a?!0:Zo()===b&amp;&amp;$o(a)||$o(b)&amp;&amp;Zo()===a?!0:$o(b)&amp;&amp;$o(a)||Yo(b)&amp;&amp;Yo(a);e=a}a=d.sk.g;e||(d=d.sk.va,b=po(cn(),b),b=u((new v).K((new w).f([&quot;There is already a &quot;,&quot; called &quot;,&quot;&quot;])),(new w).f([b,d])),d=a.ra,jh(b,d.Xa,d.Va,d.ab))}
function aea(a,b){var d=b.Oa();return(new ap).Gf(d,m(new n,function(a,b){return function(d){var k=b.Vn(m(new n,function(a,b){return function(a){return b!==a}}(a,d)));d=m(new n,function(a,b){return function(a){return(new A).e(b,a)}}(a,d));var p=r();return k.xa(d,p.s)}}(a,b)))}function bea(a){kh();var b=a.g;&quot;-\x3e&quot;===a.va&amp;&amp;(a=b.ra,jh(&quot;-\x3e can only be used to create anonymous procedures&quot;,a.Xa,a.Va,a.ab))}
function cea(a,b){return b.Gb(dea(),tb(new ub,function(){return function(a,b){return Uo(b)?rc(rc(a,Qba(Rb(),b),Vo()),Nba(Rb(),b),Wo()):a}}(a)))}function eea(a,b){if(bp(a)&amp;&amp;bp(b)){var d=a.zg,e=b.zg;if(null===d?null===e:d.o(e))return(new J).j((new A).e(a.zg.va,b.zg.g))}return cp(a)&amp;&amp;cp(b)?(new J).j((new A).e(&quot;EXTENSIONS&quot;,b.g)):dp(a)&amp;&amp;dp(b)?(new J).j((new A).e(&quot;INCLUDES&quot;,b.g)):F()}function fea(a){return u((new v).K((new w).f([&quot;Redeclaration of &quot;,&quot;&quot;])),(new w).f([a]))}
function gea(a,b){b.Vn(m(new n,function(){return function(a){return ep(a)}}(a))).wa(m(new n,function(a){return function(b){if(ep(b))b=b.fn,b.wa(m(new n,function(a,b){return function(d){bea(d);kh();var e=1===b.zC(m(new n,function(a,b){return function(a){return a.va===b.va}}(a,d))),f=d.g;e||(d=hea(d),f=f.ra,jh(d,f.Xa,f.Va,f.ab))}}(a,b)));else throw(new q).j(b);}}(a)));b=aea(a,b);for(b=(new fp).Gf(b,m(new n,function(){return function(a){return null!==a}}(a)));b.ta();){var d=b.ma();if(null!==d){var d=
eea(d.la(),d.pa()),e=iea(new gp,d,m(new n,function(){return function(a){return null!==a}}(a))),d=e.ga,e=e.ol,d=d.z()||e.y(d.Y())?d:F();if(!d.z())if(e=d.Y(),null!==e)d=e.la(),e=e.pa(),kh(),d=fea(d),e=e.ra,jh(d,e.Xa,e.Va,e.ab);else throw(new q).j(e);}else throw(new q).j(d);}}function hea(a){return u((new v).K((new w).f([&quot;There is already a local variable called &quot;,&quot; here&quot;])),(new w).f([a.va]))}
function jea(a,b){b=b.Gb(I(r(),y()),tb(new ub,function(a){return function(b,f){if(bp(f)){var h=f.If,k=f.zg.va.toUpperCase();if(&quot;TURTLES-OWN&quot;===k)f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,Xo(),!0)}}(a,f)),k=r(),f=h.xa(f,k.s);else if(&quot;PATCHES-OWN&quot;===k)f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,jp(),!0)}}(a,f)),k=r(),f=h.xa(f,k.s);else if(&quot;LINKS-OWN&quot;===k)f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,Zo(),!0)}}(a,f)),k=r(),f=h.xa(f,k.s);else if(&quot;GLOBALS&quot;===
k)f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,kp(),!0)}}(a,f)),k=r(),f=h.xa(f,k.s);else{var k=(new Sb).c(k),k=kea(k),p=b.Oj(m(new n,function(a,b){return function(a){return a.sk.va===b}}(a,k)));p.z()?f=F():(p=p.Y().Rn,lp()===p?(f=m(new n,function(a,b,d){return function(a){return hp(new ip,d,a,(new mp).c(b),!0)}}(a,k,f)),k=r(),f=h.xa(f,k.s)):np()===p?(f=m(new n,function(a,b,d){return function(a){return hp(new ip,d,a,(new op).c(b),!0)}}(a,k,f)),k=r(),f=h.xa(f,k.s)):f=I(r(),y()),f=
(new J).j(f));f=f.z()?I(r(),y()):f.Y()}h=r();return b.Rc(f,h.s)}if(ep(f))return k=f.fn,h=hp(new ip,f,f.va,pp(),!0),f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,tc(),!1)}}(a,f)),p=r(),f=k.xa(f,p.s),k=r(),f=f.fd(h,k.s),h=r(),f.Rc(b,h.s);if(Uo(f)){h=f.ql;k=f.Bf;if(f.Kg)var p=lp(),t=qp();else p=np(),t=rp();f=I(r(),(new w).f([hp(new ip,f,h,p,!0),hp(new ip,f,k,t,!0)]));h=r();return b.Rc(f,h.s)}return b}}(a)));a=m(new n,function(){return function(a){return a.Rn}}(a));sp||(sp=(new tp).b());
return up(b,a,sp)}
function lea(a,b,d){for(var e=jea(a,b),f=e.Oa(),f=(new fp).Gf(f,m(new n,function(){return function(a){return null!==a&amp;&amp;Uo(a.wo)?!0:!1}}(a)));f.ta();){var h=f.ma();if(null!==h&amp;&amp;Uo(h.wo))Zda(a,h,d);else throw(new q).j(h);}b=mea(d,cea(a,b));for(d=e.Oa();d.ta();)f=d.ma(),bea(f.sk),b.Vn(m(new n,function(){return function(a){return null!==a}}(a))).wa(m(new n,function(a,b){return function(a){if(null!==a)$da(a.la(),a.pa(),b);else throw(new q).j(a);}}(a,f)));b=e.Oa();for(b=(new fp).Gf(b,m(new n,function(){return function(a){return a.ss}}(a)));b.ta();)d=
b.ma(),e.Vn(m(new n,function(a,b){return function(a){return a!==b}}(a,d))).wa(m(new n,function(a,b){return function(a){$da(b.sk.va,b.Rn,a)}}(a,d)))}To.prototype.$classData=g({p1:0},!1,&quot;org.nlogo.parse.StructureChecker$&quot;,{p1:1,d:1});var vp=void 0;function nea(){vp||(vp=(new To).b());return vp}function wp(){}wp.prototype=new l;wp.prototype.constructor=wp;wp.prototype.b=function(){return this};
function oea(a){var b=xp,d=pba(new Me,a.Ic(),m(new n,function(){return function(a){return a.ra.Xa}}(b))),b=(new yp).b(),d=pea(b).si(d);if(Fe(d))return a=d.mm,pc(),(new mi).j(a);var e=qea(rea(b),d);if(!e.z())return b=e.Y().la(),d=e.Y().pa(),a=d.ym.z()?a.ta()?a.ma():Nm():d.ym.$(),pc(),a=(new A).e(b,a),(new Xh).j(a);throw(new q).j(d);}wp.prototype.$classData=g({r1:0},!1,&quot;org.nlogo.parse.StructureCombinators$&quot;,{r1:1,d:1});var xp=void 0;function zp(){}zp.prototype=new l;zp.prototype.constructor=zp;
zp.prototype.b=function(){return this};function sea(a,b,d){var e=Ic(b),e=Ap(e);d=b.Ws(d.va,d);b=oh();a=m(new n,function(a,b){return function(a){return(new A).e(a,b.y(a))}}(a,d));d=r();a=nh(b,e.xa(a,d.s).Hc());$e();b=Ic(a);Nn(0,e.Ie(Ap(b)));return a}function tea(a,b,d){return uea(a,vea(a,b,d),d)}
function wea(a,b,d,e,f){var h=Ic(b.bg),k=Ic(b.Hf);if(dm(h,k).ib(d)){if(b.Hf.ib(d))return f=b.Hf,d=b.Hf.y(d),f=sea(a,f,Bp(d.va,d.Bf,e,d.Kg,d.Jg)),Cp(b.Qj,b.fk,b.Li,b.hj,b.yi,b.bg,f,b.ug);f=b.bg;d=b.bg.y(d);f=sea(a,f,Bp(d.va,d.Bf,e,d.Kg,d.Jg));return Cp(b.Qj,b.fk,b.Li,b.hj,b.yi,f,b.Hf,b.ug)}b=rh();a=[d];b=b.Vl.dc(&quot;compiler.StructureConverter.noBreed&quot;);if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f([&quot;coding error, bad translation key: &quot;,&quot; for Errors&quot;])),(new w).f([&quot;compiler.StructureConverter.noBreed&quot;])));
throw(new q).j(b);}e=b.U;d=a.length|0;0&gt;=d?h=0:(b=d&gt;&gt;31,h=(0===b?-1&lt;(-2147483648^d):0&lt;b)?-1:d);r();Zn();b=[];var k=0,p=a.length|0;0&gt;h&amp;&amp;$n(ao(),0,d,1,!1);for(p=p&lt;h?p:h;k&lt;p;){var t=a[k],x=k;0&gt;h&amp;&amp;$n(ao(),0,d,1,!1);if(0&gt;x||x&gt;=h)throw(new P).c(&quot;&quot;+x);t=(new A).e(t,x);b.push(t);k=1+k|0}a=b.length|0;d=0;h=e;a:for(;;){if(d!==a){e=1+d|0;h=(new A).e(h,b[d]);b:{d=h.kb;p=h.Ab;if(null!==p&amp;&amp;(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),d,u((new v).K((new w).f([&quot;\\\\{&quot;,&quot;\\\\}&quot;])),(new w).f([&quot;&quot;+p])),h);break b}throw(new q).j(h);
}d=e;continue a}break}throw(new hd).ms(h,f.ra.Xa,f.ra.Va,f.ra.ab);}
function xea(a,b,d,e,f){var h=(new Dp).b(),k=r(),h=b.ic(h,k.s).cs($e().Fk);d=(new Ep).Ha(d);k=r();k=b.ic(d,k.s);k.wa(m(new n,function(){return function(a){a=a.la();a.a=(32|a.a)&lt;&lt;24&gt;&gt;24}}(a,f)));f=tea(a,e.ec,b);d=e.ce;var p=m(new n,function(){return function(a){if(null!==a){a=a.la();var b=a.me();return(new A).e(b,a)}throw(new q).j(a);}}(a)),t=r();d=zc(d,k.xa(p,t.s));p=e.ep;a=m(new n,function(){return function(a){if(null!==a){var b=a.pa();a=a.la().me();return(new A).e(a,b)}throw(new q).j(a);}}(a));
t=r();a=p.Am(k.xa(a,t.s));k=e.Xl;p=r();h=k.Rc(h,p.s);k=e.js;e=e.Mp;p=(new Fp).b();t=r();b=b.ic(p,t.s).cs($e().Fk);p=r();return Gp(new Hp,f,d,a,h,k,e.Rc(b,p.s))}function vea(a,b,d){return d.Gb(b,tb(new ub,function(){return function(a,b){if(Uo(b)){var d=b.Kg,k=b.Jg,p=b.ql.va;b=b.Bf.va;var t=I(r(),y()),k=Bp(p,b,t,d,k);if(d)return d=a.Hf.Ws(k.va,k),Cp(a.Qj,a.fk,a.Li,a.hj,a.yi,a.bg,d,a.ug);d=a.bg.Ws(k.va,k);return Cp(a.Qj,a.fk,a.Li,a.hj,a.yi,d,a.Hf,a.ug)}return a}}(a)))}
function uea(a,b,d){return d.Gb(b,tb(new ub,function(a){return function(b,d){if(bp(d)){var k=d.zg,p=d.If;if(null!==k&amp;&amp;&quot;GLOBALS&quot;===k.va){d=b.fk;var k=m(new n,function(){return function(a){return a.va}}(a)),t=r(),p=p.xa(k,t.s),k=r();d=d.Rc(p,k.s);return Cp(b.Qj,d,b.Li,b.hj,b.yi,b.bg,b.Hf,b.ug)}}if(bp(d)&amp;&amp;(k=d.zg,p=d.If,null!==k&amp;&amp;&quot;TURTLES-OWN&quot;===k.va))return d=b.Li,k=m(new n,function(){return function(a){a=a.va;var b=lc();return(new A).e(a,b)}}(a)),t=r(),d=zc(d,p.xa(k,t.s)),Cp(b.Qj,b.fk,d,b.hj,b.yi,
b.bg,b.Hf,b.ug);if(bp(d)&amp;&amp;(k=d.zg,p=d.If,null!==k&amp;&amp;&quot;PATCHES-OWN&quot;===k.va))return d=b.hj,k=m(new n,function(){return function(a){a=a.va;var b=lc();return(new A).e(a,b)}}(a)),t=r(),d=zc(d,p.xa(k,t.s)),Cp(b.Qj,b.fk,b.Li,d,b.yi,b.bg,b.Hf,b.ug);if(bp(d)&amp;&amp;(k=d.zg,p=d.If,null!==k&amp;&amp;&quot;LINKS-OWN&quot;===k.va))return d=b.yi,k=m(new n,function(){return function(a){a=a.va;var b=lc();return(new A).e(a,b)}}(a)),t=r(),d=zc(d,p.xa(k,t.s)),Cp(b.Qj,b.fk,b.Li,b.hj,d,b.bg,b.Hf,b.ug);if(bp(d)&amp;&amp;(k=d.zg,d=d.If,null!==k)){var p=
k.g,k=(new Sb).c(k.va),k=kea(k),t=m(new n,function(){return function(a){return a.va}}(a)),x=r();return wea(a,b,k,d.xa(t,x.s),p)}return b}}(a)))}zp.prototype.$classData=g({y1:0},!1,&quot;org.nlogo.parse.StructureConverter$&quot;,{y1:1,d:1});var Ip=void 0;function yea(){Ip||(Ip=(new zp).b());return Ip}function Jp(){this.Um=null;this.Hk=!1}Jp.prototype=new l;Jp.prototype.constructor=Jp;
function zea(a,b,d){xp||(xp=(new wp).b());b=oea(b);if(Qm(b))return b=b.U,gea(nea(),b),lea(nea(),b,Haa(Gc(),d.ec,d.ce)),xea(yea(),b,a.Um,a.Hk?Gp(new Hp,d.ec,(Kp(),ph()),(Kp(),nh($e().kk,y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())),(Kp(),I(r(),y()))):d,a.Hk);Pm(b)&amp;&amp;(d=b.U,null!==d&amp;&amp;(a=d.la(),d=d.pa(),kh(),d=d.ra,jh(a,d.Xa,d.Va,d.ab)));throw(new q).j(b);}function Aea(a,b,d){a.Um=b;a.Hk=d;return a}Jp.prototype.$classData=g({C1:0},!1,&quot;org.nlogo.parse.StructureParser&quot;,{C1:1,d:1});
function Lp(){this.MG=null;this.a=!1}Lp.prototype=new l;Lp.prototype.constructor=Lp;
function Haa(a,b,d){var e=dea(),f=Bea(Mp(b.ug)),e=rc(e,Ic(f),Np()),f=Cea(Mp(b.ug)),e=rc(rc(rc(rc(e,Ic(f),Op()),Pp(b),kp()),Qp(b),Xo()),Dea(b),jp()),f=Rp(b);a=rc(e,f.al(m(new n,function(a,b){return function(a){return Qp(b).ib(a)}}(a,b)),!0),Zo());f=(new Kc).fg(b.bg);e=Lc().s;e=Mc(f,e);for(f=f.oi.rj();f.ta();){var h=f.ma();e.Na(h.Bf)}a=rc(rc(a,e.Da(),rp()),Ic(b.bg),np());f=(new Kc).fg(b.Hf);e=Lc().s;e=Mc(f,e);for(f=f.oi.rj();f.ta();)h=f.ma(),e.Na(h.Bf);d=rc(rc(rc(a,e.Da(),qp()),Ic(b.Hf),lp()),Ic(d),
pp());a=(new Kc).fg(b.bg);b=null;b=d;for(d=a.oi.rj();d.ta();)a=d.ma(),b=a.Kg?rc(b,a.nl,(new mp).c(a.va)):rc(b,a.nl,(new op).c(a.va));return b}Lp.prototype.b=function(){this.MG=&quot;Included files must end with .nls&quot;;this.a=!0;return this};function Eea(a,b,d,e,f,h){b=Sp(b,e,f);a=(new fp).Gf(b,m(new n,function(){return function(a){a=a.jb;var b=Dm();return!(null!==a&amp;&amp;a===b)}}(a)));b=Tp();a=(new bc).Gf(a,b);return zea(d,a,h)}
function Fea(){var a=Gc();return tb(new ub,function(){return function(){return F()}}(a))}
function Gaa(a,b,d){var e=Fea();b=function(a,b,d,e){return function(){var t=Aea(new Jp,d.Um,d.Hk),x=d.Rs,E=Gp(new Hp,d.Mr,d.un,(Kp(),nh($e().kk,y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())),(Kp(),I(r(),y()))),x=Zl(x,E,tb(new ub,function(a,b,d){return function(e,f){e=(new A).e(e,f);f=e.kb;var h=e.Ab;if(null!==h)return Eea(a,b,d,h.pa(),h.la(),f);throw(new q).j(e);}}(a,b,t)));if(d.Hk)return x;pc();return(new Up).Gf(Gea(new Vp,x,m(new n,function(a,b,d,e,f){return function(h){var k=h.Xl.$().X;kh();var p=Wp(Ia(),
k,&quot;.nls&quot;),t=h.Xl.$();if(!p){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/StructureParser.scala: 29&quot;);p=a.MG;t=t.Lc();jh(p,t.Xa,t.Va,t.ab)}t=rb(e,d.Fr,k);if(Vk(t)&amp;&amp;(p=t.U,null!==p)){var t=p.la(),p=p.pa(),x=h.Xl.aa(),E=h.js,$a=r(),k=E.mc(k,$a.s);return Eea(a,b,f,p,t,Gp(new Hp,h.ec,h.ce,h.ep,x,k,h.Mp))}if(F()===t){kh();x=rh();p=[k];k=x.Vl.dc(&quot;compiler.StructureParser.includeNotFound&quot;);if(!Vk(k)){if(F()===k)throw(new df).c(u((new v).K((new w).f([&quot;coding error, bad translation key: &quot;,
&quot; for Errors&quot;])),(new w).f([&quot;compiler.StructureParser.includeNotFound&quot;])));throw(new q).j(k);}x=k.U;E=p.length|0;0&gt;=E?$a=0:(k=E&gt;&gt;31,$a=(0===k?-1&lt;(-2147483648^E):0&lt;k)?-1:E);r();Zn();var k=[],fc=0,Bc=p.length|0;0&gt;$a&amp;&amp;$n(ao(),0,E,1,!1);for(Bc=Bc&lt;$a?Bc:$a;fc&lt;Bc;){var sf=p[fc],Sf=fc;0&gt;$a&amp;&amp;$n(ao(),0,E,1,!1);if(0&gt;Sf||Sf&gt;=$a)throw(new P).c(&quot;&quot;+Sf);sf=(new A).e(sf,Sf);k.push(sf);fc=1+fc|0}p=k.length|0;E=0;$a=x;a:for(;;){if(E!==p){x=1+E|0;$a=(new A).e($a,k[E]);b:{E=$a.kb;Bc=$a.Ab;if(null!==Bc&amp;&amp;(fc=Bc.la(),Bc=
Bc.Dc(),Qg(fc))){$a=fc;$a=Qb(Ia(),E,u((new v).K((new w).f([&quot;\\\\{&quot;,&quot;\\\\}&quot;])),(new w).f([&quot;&quot;+Bc])),$a);break b}throw(new q).j($a);}E=x;continue a}k=$a;break}h=h.Xl.$().Lc();jh(k,h.Xa,h.Va,h.ab)}throw(new q).j(t);}}(a,b,d,e,t))),m(new n,function(){return function(a){return a.Xl.He()}}(a))).ma()}}(a,b,d,e);if(d.Hk)return b();d.hh.hY();b=b();b.Mp.wa(m(new n,function(a,b){return function(a){b.hh.bU(a.Wb.toLowerCase(),(new hh).Ff(a))}}(a,d)));return b}
Lp.prototype.$classData=g({D1:0},!1,&quot;org.nlogo.parse.StructureParser$&quot;,{D1:1,d:1});var Xp=void 0;function Gc(){Xp||(Xp=(new Lp).b());return Xp}function Yp(){}Yp.prototype=new l;Yp.prototype.constructor=Yp;Yp.prototype.b=function(){return this};function dea(){Hea||(Hea=(new Yp).b());return Zp(new $p,nh(Iea(),y()),0)}Yp.prototype.$classData=g({E1:0},!1,&quot;org.nlogo.parse.SymbolTable$&quot;,{E1:1,d:1});var Hea=void 0;function aq(){}aq.prototype=new l;aq.prototype.constructor=aq;aq.prototype.b=function(){return this};
function po(a,b){if(kp()===b)return&quot;global variable&quot;;if(Xo()===b)return&quot;turtle variable&quot;;if(jp()===b)return&quot;patch variable&quot;;if(Zo()===b)return&quot;link variable&quot;;if(np()===b)return&quot;breed&quot;;if(rp()===b)return&quot;singular breed name&quot;;if(lp()===b)return&quot;link breed&quot;;if(qp()===b)return&quot;singular link breed name&quot;;if(Yo(b)||$o(b))return a=b.ja,u((new v).K((new w).f([&quot;&quot;,&quot;-OWN variable&quot;])),(new w).f([a]));if(pp()===b)return&quot;procedure&quot;;if(Np()===b)return&quot;primitive command&quot;;if(Op()===b)return&quot;primitive reporter&quot;;if(Vo()===
b)return&quot;breed command&quot;;if(Wo()===b)return&quot;breed reporter&quot;;if(bq(b)||en()===b||tc()===b)return&quot;local variable here&quot;;throw(new q).j(b);}function lda(a,b,d){kh();a=&quot;There is already a &quot;+po(cn(),b)+&quot; called &quot;+d.Wb.toUpperCase();d=d.ra;jh(a,d.Xa,d.Va,d.ab)}aq.prototype.$classData=g({F1:0},!1,&quot;org.nlogo.parse.SymbolType$&quot;,{F1:1,d:1});var cq=void 0;function cn(){cq||(cq=(new aq).b());return cq}function dq(){}dq.prototype=new l;dq.prototype.constructor=dq;dq.prototype.b=function(){return this};
function xc(a,b,d){a=new eq;var e=new fq;e.ai=b;e.xY=d;e.AF=d.qU();e.a=!0;return gq(a,e)}dq.prototype.$classData=g({X1:0},!1,&quot;org.nlogo.parse.TransformableTokenStream$&quot;,{X1:1,d:1});var hq=void 0;function uc(){hq||(hq=(new dq).b());return hq}function iq(){}iq.prototype=new l;iq.prototype.constructor=iq;iq.prototype.b=function(){return this};
function Jea(a,b,d,e,f){var h=m(new n,function(a,b){return function(a){return Kea(b,a)}}(a,e)),k=r();b=b.xa(h,k.s);a=m(new n,function(a,b){return function(a){return Lea(b,a)}}(a,e));e=r();d=d.xa(a,e.s);return jq(new kq,f.Sf,f.Zd,f.Se,f.Gc,b,d)}
function Mea(a,b){b=lq(a,b,mq());if(nq(b)){b=b.ha;b=oq().by().y(b);if(!nq(b)){if(!pq(b))throw(new q).j(b);b=(new qq).j(rq(b.cc))}if(nq(b)){b=b.ha;var d=(new sq).j(Hca(Ek(),b.Ey()))}else{if(!pq(b))throw(new q).j(b);d=b}}else{if(!pq(b))throw(new q).j(b);d=b}b=qd();if(nq(d))a=d;else{if(!pq(d))throw(new q).j(d);var e=d.cc;a=function(){return function(a){return a}}(a);tq();var d=a(e.Fc),e=e.Mc,f=uq().Vd,e=vq(e);a:for(;;){if(!wq(e)){if(xq(e)){var h=e,e=h.dd,h=a(h.$c),f=(new yq).Qb(h,f);continue a}throw(new q).j(e);
}break}a=(new qq).j((new zq).Qb(d,f))}Aq||(Aq=(new Bq).b());return rd(b,Cq(a,Aq).Ye())}function lq(a,b,d){b=Dq(qd(),b);d=d.Za(b);if(nq(d))return d;if(pq(d)){b=d.cc;a=function(){return function(a){return(new Eq).c(a)}}(a);tq();d=a(b.Fc);b=b.Mc;var e=uq().Vd;b=vq(b);a:for(;;){if(!wq(b)){if(xq(b)){var f=b;b=f.dd;f=a(f.$c);e=(new yq).Qb(f,e);continue a}throw(new q).j(b);}break}return(new qq).j((new zq).Qb(d,e))}throw(new q).j(d);}
function Nea(a,b){var d=qd();Fq();var e=Oea(a);Gq();(new Hq).b();try{var f=Pea(Iq(),b);if(nq(f))var h=f;else{if(!pq(f))throw(new q).j(f);var k=f.cc,p=function(){return function(a){if(Jq(a))return Kq(a);if(null!==a)return(new Lq).ud(a);throw(new q).j(a);}}(a);tq();var t=p(k.Fc),x=k.Mc,E=uq().Vd,S=vq(x);a=E;var U;a:for(;;){b=S;if(!wq(b)){if(xq(b)){var ga=b.dd,f=a,ma=p(b.$c),va=(new yq).Qb(ma,f),S=ga;a=va;continue a}throw(new q).j(b);}U=a;break}h=(new qq).j((new zq).Qb(t,U))}if(nq(h))var Fa=h.ha,Va=
(new sq).j(rb(e,Fa,Mq(Nq(),Fa)));else if(pq(h))Va=h;else throw(new q).j(h);var vb=(new sq).j(Va)}catch(pb){if(e=ko(Lg(),pb),null!==e)if(Rl(pa(Oq),e))vb=(new qq).j(e);else throw Kg(Lg(),e);else throw pb;}if(nq(vb))e=vb.ha;else{if(!pq(vb))throw(new q).j(vb);e=vb.cc;Pq();e=(new Lq).ud(e);e=Qq(Gq(),e)}return rd(d,Rq(0,e).Ye())}function Oea(a){return tb(new ub,function(){return function(a,d){return d}}(a))}
function Qea(a,b,d){var e=Sq(Tq());d=lq(a,d,Rea());if(pq(d))Pq(),d=(new Eq).c(u((new v).K((new w).f([&quot;&quot;,&quot; must be an Array of &quot;,&quot;&quot;])),(new w).f([&quot;commands&quot;,Uq(pa(qa))]))),d=Qq(Gq(),d);else if(!nq(d))throw(new q).j(d);if(nq(d)){d=d.ha.Ma;var e=m(new n,function(a,b){return function(a){a=b.Za(a);if(pq(a))return(new qq).j(rq(a.cc));if(nq(a)){a=a.ha;B();a=(new w).f([a]);var d=B().s;return(new sq).j(L(a,d))}throw(new q).j(a);}}(a,e)),f=r(),e=d.xa(e,f.s);Pq();B();d=y();e=e.Gb(Vq().y(d),tb(new ub,function(a){return function(b,
d){d=function(a,b){return function(){return b}}(a,d);var e=Wq();(new Xq).nu(e);e=tq();(new Yq).gq(e);if(pq(b)){e=b.cc;d=d();if(pq(d))return(new qq).j(Zq(e,d.cc));if(nq(d))return b;throw(new q).j(d);}if(nq(b)){b=b.ha;d=d();if(pq(d))return d;if(nq(d))return(new sq).j($q(d.ha,b));throw(new q).j(d);}throw(new q).j(b);}}(a)));if(!nq(e)){if(!pq(e))throw(new q).j(e);f=e.cc;e=function(){return function(a){return a}}(a);tq();d=e(f.Fc);var f=f.Mc,h=uq().Vd,f=vq(f);a:for(;;){if(!wq(f)){if(xq(f)){var k=f,f=k.dd,
k=e(k.$c),h=(new yq).Qb(k,h);continue a}throw(new q).j(f);}break}e=(new qq).j((new zq).Qb(d,h))}}else{if(!pq(d))throw(new q).j(d);e=d}if(!nq(e)){if(!pq(e))throw(new q).j(e);f=e.cc;e=function(){return function(a){return a}}(a);tq();d=e(f.Fc);f=f.Mc;h=uq().Vd;f=vq(f);a:for(;;){if(!wq(f)){if(xq(f)){k=f;f=k.dd;k=e(k.$c);h=(new yq).Qb(k,h);continue a}throw(new q).j(f);}break}e=(new qq).j((new zq).Qb(d,h))}if(nq(e)){e=e.ha;d=I(r(),y());Gq();(new Hq).b();try{var p=Pea(Iq(),b);if(nq(p))var t=p;else{if(!pq(p))throw(new q).j(p);
var x=p.cc,E=function(){return function(a){if(Jq(a))return Kq(a);if(null!==a)return(new Lq).ud(a);throw(new q).j(a);}}(a);tq();var S=E(x.Fc),U=x.Mc,ga=uq().Vd,ma=vq(U);b=ga;var va;a:for(;;){p=ma;if(!wq(p)){if(xq(p)){var Fa=p.dd,x=b,Va=E(p.$c),vb=(new yq).Qb(Va,x),ma=Fa;b=vb;continue a}throw(new q).j(p);}va=b;break}t=(new qq).j((new zq).Qb(S,va))}if(nq(t))var pb=t.ha,Ib=Mq(Nq(),pb),kc=(new sq).j(Jea(a,e,d,pb,Ib));else if(pq(t))kc=t;else throw(new q).j(t);var $a=(new sq).j(kc)}catch(fc){if(a=ko(Lg(),
fc),null!==a)if(Rl(pa(Oq),a))$a=(new qq).j(a);else throw Kg(Lg(),a);else throw fc;}if(nq($a))a=$a.ha;else{if(!pq($a))throw(new q).j($a);a=$a.cc;Pq();a=(new Lq).ud(a);a=Qq(Gq(),a)}if(nq(a))a=(new sq).j(a.ha);else if(!pq(a))throw(new q).j(a);}else{if(!pq(e))throw(new q).j(e);a=e}return rd(qd(),Rq(Fq(),a).Ye())}
function Sea(a,b){b=lq(a,b,mq());if(nq(b)){b=b.ha;b=ar().by().y(b);if(!nq(b)){if(!pq(b))throw(new q).j(b);b=(new qq).j(rq(b.cc))}if(nq(b)){b=b.ha;Gq();(new Hq).b();try{var d=Tea(Iq(),b.Ey(),br(),cr());if(nq(d))var e=d;else{if(!pq(d))throw(new q).j(d);var f=d.cc,h=function(){return function(a){return a}}(a);tq();var k=h(f.Fc),p=f.Mc,t=uq().Vd,x=vq(p),d=t,E;a:for(;;){f=x;if(!wq(f)){if(xq(f)){var S=f.dd,p=d,U=h(f.$c),ga=(new yq).Qb(U,p),x=S,d=ga;continue a}throw(new q).j(f);}E=d;break}e=(new qq).j((new zq).Qb(k,
E))}if(nq(e))var ma=e;else{if(!pq(e))throw(new q).j(e);var va=e.cc,Fa=function(){return function(a){if(Jq(a))return Kq(a);if(null!==a)return(new Lq).ud(a);throw(new q).j(a);}}(a);tq();var Va=Fa(va.Fc),vb=va.Mc,pb=uq().Vd,Ib=vq(vb),e=pb,kc;a:for(;;){h=Ib;if(!wq(h)){if(xq(h)){var $a=h.dd,k=e,fc=Fa(h.$c),Bc=(new yq).Qb(fc,k),Ib=$a,e=Bc;continue a}throw(new q).j(h);}kc=e;break}ma=(new qq).j((new zq).Qb(Va,kc))}if(nq(ma))var sf=ma.ha,Sf=Mq(Nq(),sf),th=(new sq).j(Jea(a,Uea(b),Vea(b),sf,Sf));else if(pq(ma))th=
ma;else throw(new q).j(ma);var Te=(new sq).j(th)}catch(tf){if(ma=ko(Lg(),tf),null!==ma)if(Rl(pa(Oq),ma))Te=(new qq).j(ma);else throw Kg(Lg(),ma);else throw tf;}if(nq(Te))ma=Te.ha;else{if(!pq(Te))throw(new q).j(Te);ma=Te.cc;Pq();ma=(new Lq).ud(ma);ma=Qq(Gq(),ma)}if(nq(ma))Fa=(new sq).j(ma.ha);else{if(!pq(ma))throw(new q).j(ma);Fa=ma}}else{if(!pq(b))throw(new q).j(b);Fa=b}}else{if(!pq(b))throw(new q).j(b);Fa=b}ma=qd();Fq();if(nq(Fa))a=Fa;else{if(!pq(Fa))throw(new q).j(Fa);Va=Fa.cc;a=function(){return function(a){return a}}(a);
tq();Fa=a(Va.Fc);Va=Va.Mc;Ib=uq().Vd;Va=vq(Va);a:for(;;){if(!wq(Va)){if(xq(Va)){kc=Va;Va=kc.dd;kc=a(kc.$c);Ib=(new yq).Qb(kc,Ib);continue a}throw(new q).j(Va);}break}a=(new qq).j((new zq).Qb(Fa,Ib))}return rd(ma,Rq(0,a).Ye())}iq.prototype.exportNlogo=function(a){return Mea(this,a)};
iq.prototype.fromNlogo=function(a){for(var b=arguments.length|0,d=1,e=[];d&lt;b;)e.push(arguments[d]),d=d+1|0;switch(e.length|0){case 0:return Nea(this,a);case 1:return Qea(this,a,e[0]);default:throw&quot;No matching overload&quot;;}};iq.prototype.fromModel=function(a){return Sea(this,a)};iq.prototype.$classData=g({Y1:0},!1,&quot;org.nlogo.tortoise.compiler.BrowserCompiler&quot;,{Y1:1,d:1});function dr(){}dr.prototype=new l;dr.prototype.constructor=dr;dr.prototype.b=function(){return this};
function Rq(a,b){if(nq(b))a=b.ha;else{if(!pq(b))throw(new q).j(b);a=b.cc;a=jq(new kq,(Pq(),Wea().y(a)),&quot;&quot;,&quot;&quot;,I(r(),y()),I(r(),y()),I(r(),y()))}er||(er=(new fr).b());return Cq(a,er)}dr.prototype.$classData=g({Z1:0},!1,&quot;org.nlogo.tortoise.compiler.BrowserCompiler$&quot;,{Z1:1,d:1});var gr=void 0;function Fq(){gr||(gr=(new dr).b());return gr}function hr(a,b,d,e,f){a=bd(a);b=b.za.W(1);return ir(a,b,d,e,f)}
function jr(a,b,d,e,f){b=b.za;var h=new kr;if(null===a)throw Kg(Lg(),null);h.Sa=a;h.WS=d;h.TS=e;h.OV=f;a=r();return b.ic(h,a.s)}
function Xea(a,b,d,e,f){var h=b.xd;ld();var k=(new lr).b(),p=md(new nd,k).Uc(h);if(!p.z()){var t=p.Y();if(null===t)throw(new Oe).b();return&quot;&quot;===t?&quot;&quot;:u((new v).K((new w).f([&quot;&quot;,&quot;;&quot;])),(new w).f([t]))}ld();var x=(new mr).b(),E=md(new nd,x).Uc(h);if(!E.z()){var S=E.Y();return u((new v).K((new w).f([&quot;&quot;,&quot;(&quot;,&quot;);&quot;])),(new w).f([S,jr(a,b,d,e,f).zb(&quot;, &quot;)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Lz){var U;var ga=b.za.W(0).pe;if(nr(ga)){bd(a);var ma=ga.Wc.va,va=or(pr(),ma);U=u((new v).K((new w).f([&quot;&quot;,&quot; \x3d &quot;,&quot;; letVars['&quot;,
&quot;'] \x3d &quot;,&quot;;&quot;])),(new w).f([va,hr(a,b,d,e,f),va,va]))}else if(qr(ga)){var Fa=(new v).K((new w).f([&quot;&quot;,&quot; \x3d &quot;,&quot;;&quot;]));bd(a);var Va=ga.va;U=u(Fa,(new w).f([or(pr(),Va),hr(a,b,d,e,f)]))}else if(Go(ga)){var vb=(new v).K((new w).f([&quot;&quot;,&quot; \x3d &quot;,&quot;;&quot;]));bd(a);var pb=ga.va;U=u(vb,(new w).f([or(pr(),pb),hr(a,b,d,e,f)]))}else{null===a.Jw&amp;&amp;null===a.Jw&amp;&amp;(a.Jw=(new rr).vD(a));var Ib=a.Jw.PF(ga);if(Ib.z()){var kc=b.xd.H();gd('This isn\'t something you can use &quot;set&quot; on.',kc);U=void 0}else U=Ib.Y().y(hr(a,b,d,e,
f))}return U}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.yA){var $a=bd(a),fc=b.za.W(0),Bc=sr($a,fc,!0,!1,d,e,f),sf=u((new v).K((new w).f([&quot;|while (true) {\n        |&quot;,&quot;\n        |};&quot;])),(new w).f([tr(fd(),Bc)])),Sf=(new Sb).c(sf);return dd(Sf)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Kz){var th=bd(a),Te=b.za.W(0),tf=ir(th,Te,d,e,f),ek=bd(a),og=b.za.W(1),uh=sr(ek,og,!0,!1,d,e,f);bd(a);var pg=b.xd.H(),Yh=cd(pg,&quot;index&quot;);bd(a);var Ri=b.xd.H(),fk=cd(Ri,&quot;repeatcount&quot;),Si=u((new v).K((new w).f([&quot;|for (let &quot;,&quot; \x3d 0, &quot;,
&quot; \x3d StrictMath.floor(&quot;,&quot;); &quot;,&quot; \x3c &quot;,&quot;; &quot;,&quot;++){\n        |&quot;,&quot;\n        |}&quot;])),(new w).f([Yh,fk,tf,Yh,fk,Yh,tr(fd(),uh)])),gk=(new Sb).c(Si);return dd(gk)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.SA){var Ti=bd(a),vl=b.za.W(0),Ui=ir(Ti,vl,d,e,f),hk=bd(a),Vi=b.za.W(1),wl=sr(hk,Vi,!0,!1,d,e,f),vh=u((new v).K((new w).f([&quot;|while (&quot;,&quot;) {\n        |&quot;,&quot;\n        |}&quot;])),(new w).f([Ui,tr(fd(),wl)])),xl=(new Sb).c(vh);return dd(xl)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.lA){var wh=bd(a),ik=b.za.W(0),yl=ir(wh,ik,d,
e,f),Zh=bd(a),$h=b.za.W(1),zl=sr(Zh,$h,!0,!1,d,e,f),Al=u((new v).K((new w).f([&quot;|if (&quot;,&quot;) {\n        |&quot;,&quot;\n        |}&quot;])),(new w).f([yl,tr(fd(),zl)])),Bl=(new Sb).c(Al);return dd(Bl)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.mA){var jk=bd(a),Cl=b.za.W(0),Dl=ir(jk,Cl,d,e,f),El=bd(a),Fl=b.za.W(1),kk=sr(El,Fl,!0,!1,d,e,f),Gl=bd(a),ai=b.za.W(2),lk=sr(Gl,ai,!0,!1,d,e,f),xh=u((new v).K((new w).f([&quot;|if (&quot;,&quot;) {\n        |&quot;,&quot;\n        |}\n        |else {\n        |&quot;,&quot;\n        |}&quot;])),(new w).f([Dl,tr(fd(),kk),tr(fd(),
lk)])),Hl=(new Sb).c(xh);return dd(Hl)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Gz){var Wi=bd(a),mk=b.za.W(0),yh=ir(Wi,mk,d,e,f),Uf=bd(a),ue=b.za.W(1),zh=ur(Uf,ue,!1,d,e,f);return vr(yh,!0,zh)}if(Ar(h)){bd(a);var bi=b.xd.H(),nk=cd(bi,&quot;error&quot;),Xi=bd(a),Il=b.za.W(0),Yi=sr(Xi,Il,!0,!1,d,e,f);Ia();var Jl=bd(a),Zi=b.za.W(1),$i=sr(Jl,Zi,!0,!1,d,e,f),ok=(new v).K((new w).f([&quot;_error_&quot;,&quot;&quot;])),Kl=Yea(h),aj=Q(),ci=Qb(0,$i,u(ok,(new w).f([R(aj,Kl)])),nk),Ll=u((new v).K((new w).f([&quot;\n       |try {\n       |&quot;,&quot;\n       |} catch (&quot;,
&quot;) {\n       |&quot;,&quot;\n       |}\n     &quot;])),(new w).f([tr(fd(),Yi),nk,tr(fd(),ci)])),Rg=(new Sb).c(Ll);return dd(Rg)}if(Br(h))return Zea(a,b,!1,d,e,f);if(Cr(h))return Zea(a,b,!0,d,e,f);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.kB)return $ea(a,b,!1,d,e,f);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.jB)return $ea(a,b,!0,d,e,f);if(Dr(h)){var Sg=bd(a),pk=b.za.W(0),bj=ir(Sg,pk,d,e,f),Ah=bd(a),qk=b.za.W(1),Ml=ur(Ah,qk,!1,d,e,f),rk=b.xd.ja,Tg=(new Sb).c(rk),Nl=kd(Tg)?rk:&quot;TURTLES&quot;,cj=u((new v).K((new w).f([&quot;SelfManager.self().sprout(&quot;,
&quot;, &quot;,&quot;)&quot;])),(new w).f([bj,ed(fd(),Nl)]));return vr(cj,!0,Ml)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.pB){var di=bd(a),Bh=b.za.W(0),Ol=ir(di,Bh,d,e,f),qg=b.xd;if(!(qg&amp;&amp;qg.$classData&amp;&amp;qg.$classData.n.pB))throw(new df).c(u((new v).K((new w).f([&quot;How did you get here with class of type &quot;,&quot;&quot;])),(new w).f([oa(qg).kh()])));var fi=qg.ja,Ch=(new Sb).c(fi),dj=kd(Ch)?fi:&quot;TURTLES&quot;;return u((new v).K((new w).f([&quot;SelfManager.self().sprout(&quot;,&quot;, &quot;,&quot;);&quot;])),(new w).f([Ol,ed(fd(),dj)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Yz)return Er(a,
b,&quot;createLinkFrom&quot;,h.ja,d,e,f);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Zz)return Er(a,b,&quot;createLinksFrom&quot;,h.ja,d,e,f);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.bA)return Er(a,b,&quot;createLinkTo&quot;,h.ja,d,e,f);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.$z)return Er(a,b,&quot;createLinksTo&quot;,h.ja,d,e,f);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.cA)return Er(a,b,&quot;createLinkWith&quot;,h.ja,d,e,f);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.aA)return Er(a,b,&quot;createLinksWith&quot;,h.ja,d,e,f);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.hA){var Ug=bd(a),ej=b.za.W(0),fj=
ir(Ug,ej,d,e,f),gi=bd(a),hi=b.za.W(1),gj=sr(gi,hi,!0,!1,d,e,f),Vf,vf=bd(a),ae;if(!vf.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Compiler.scala: 55&quot;);ae=vf.Vx;if(null===ae)throw(new q).j(ae);var hj=ae.Vi(),rg=ae.pa(),ij=(new A).e(1+hj|0,rg);vf.Vx=ij;vf.a=!0;Vf=u((new v).K((new w).f([&quot;&quot;,&quot;_&quot;,&quot;&quot;])),(new w).f([rg,hj]));var jj=u((new v).K((new w).f(['|if (Prims.isThrottleTimeElapsed(&quot;','&quot;, workspace.selfManager.self(), ',')) {\n        |  Prims.resetThrottleTimerFor(&quot;',
'&quot;, workspace.selfManager.self());\n        |',&quot;\n        |}&quot;])),(new w).f([Vf,fj,Vf,tr(fd(),gj)])),ii=(new Sb).c(jj);return dd(ii)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.gA)return u((new v).K((new w).f([&quot;throw new Error(&quot;,&quot;);&quot;])),(new w).f([Fr(a,0,b,d,e,f)]));if(Gr(h)){var ji=h.ja,Pl=bd(a),sk=b.za.W(0),Vg=ir(Pl,sk,d,e,f),ki=bd(a),Ql=b.za.W(1),tk=ur(ki,Ql,!1,d,e,f),ei=u((new v).K((new w).f([&quot;SelfManager.self().hatch(&quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([Vg,ed(fd(),ji)]));return vr(ei,!0,tk)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.hQ){var qF=
h.ja,xw=bd(a),cx=b.za.W(0),WF=ir(xw,cx,d,e,f);return u((new v).K((new w).f([&quot;SelfManager.self().hatch(&quot;,&quot;, &quot;,&quot;);&quot;])),(new w).f([WF,ed(fd(),qF)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Hz)return u((new v).K((new w).f([&quot;SelfManager.self().fd(-&quot;,&quot;);&quot;])),(new w).f([Fr(a,0,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.sA)return u((new v).K((new w).f([&quot;SelfManager.self().right(-&quot;,&quot;);&quot;])),(new w).f([Fr(a,0,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.dA)return u((new v).K((new w).f([&quot;world.topology.diffuse(&quot;,
&quot;, &quot;,&quot;)&quot;])),(new w).f([ed(fd(),Hr(b)),Fr(a,1,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.QA)return u((new v).K((new w).f([&quot;Prims.uphill(&quot;,&quot;)&quot;])),(new w).f([ed(fd(),Hr(b))]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.RA)return u((new v).K((new w).f([&quot;Prims.uphill4(&quot;,&quot;)&quot;])),(new w).f([ed(fd(),Hr(b))]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.eA)return u((new v).K((new w).f([&quot;Prims.downhill(&quot;,&quot;)&quot;])),(new w).f([ed(fd(),Hr(b))]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.fA)return u((new v).K((new w).f([&quot;Prims.downhill4(&quot;,
&quot;)&quot;])),(new w).f([ed(fd(),Hr(b))]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.NA)return u((new v).K((new w).f([&quot;BreedManager.setDefaultShape(&quot;,&quot;.getSpecialName(), &quot;,&quot;)&quot;])),(new w).f([Fr(a,0,b,d,e,f),Fr(a,1,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.kA)return&quot;SelfManager.self().setVariable('hidden?', true)&quot;;if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.OA)return&quot;SelfManager.self().setVariable('hidden?', false)&quot;;if(Ir(h)){var wr;var dx=jr(a,b,d,e,f),vk=u((new v).K((new w).f(['procedures[&quot;','&quot;](',&quot;);&quot;])),(new w).f([h.Kh.me(),
dx.zb(&quot;,&quot;)])),Bn=d.Ds,am=afa();if(null!==Bn&amp;&amp;Bn===am&amp;&amp;1===e.no){bd(a);var ex=h.H(),xr=cd(ex,&quot;maybestop&quot;),Cn=u((new v).K((new w).f([&quot;|let &quot;,&quot; \x3d &quot;,&quot;\n          |if (&quot;,&quot; instanceof Exception.StopInterrupt) { return &quot;,&quot;; }&quot;])),(new w).f([xr,vk,xr,xr])),wk=(new Sb).c(Cn);wr=dd(wk)}else wr=vk;return wr}if(Jr(h)){var YF=u((new v).K((new w).f(['|if(!reporterContext) { throw new Error(&quot;REPORT can only be used inside TO-REPORT.&quot;) } else {\n            |  return ',&quot;\n            |}&quot;])),(new w).f([Fr(a,0,
b,d,e,f)])),yr=(new Sb).c(YF);return dd(yr)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.oA)return u((new v).K((new w).f([&quot;&quot;,&quot;;&quot;])),(new w).f([Fr(a,0,b,d,e,f)]));if(no(h)){var bm=h.Wc;if(bm.z())var zr=F();else{var ZF=bm.Y();bd(a);var $F=ZF.va,Dn=or(pr(),$F),zr=(new J).j(u((new v).K((new w).f([&quot;let &quot;,&quot; \x3d &quot;,&quot;; letVars['&quot;,&quot;'] \x3d &quot;,&quot;;&quot;])),(new w).f([Dn,Fr(a,0,b,d,e,f),Dn,Dn])))}return zr.z()?&quot;&quot;:zr.Y()}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.TA){var aG=(new v).K((new w).f([&quot;workspace.rng.withClone(function() { &quot;,
&quot; })&quot;])),e7=bd(a),f7=b.za.W(0);return u(aG,(new w).f([sr(e7,f7,!0,!1,d,e,f)]))}if(Kr(h)){var h7=h.H(),i7=jr(a,b,d,e,f);return Maa(a,!1,h7,i7,f)}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.jA){var j7=jr(a,b,d,e,f).Ge().zb(&quot;, &quot;);bd(a);var k7=h.H(),HG=cd(k7,&quot;foreach&quot;),l7=(new v).K((new w).f([&quot;var &quot;,&quot; \x3d Tasks.forEach(&quot;,&quot;, &quot;,&quot;); if(reporterContext \x26\x26 &quot;,&quot; !\x3d\x3d undefined) { return &quot;,&quot;; }&quot;])),m7=-1+b.za.Ga()|0;return u(l7,(new w).f([HG,Fr(a,m7,b,d,e,f),j7,HG,HG]))}if(Mr(h)){var o7=(new Sb).c(&quot;_extern\\(([^:]+):([^)]+)\\)&quot;),
p7=y(),q7=(new Tb).Ro(o7.R,p7),GZ=h.k();var Lr=Hg(q7,GZ);if(Lr.z())IG=!1;else if(null!==Lr.Y())var r7=Lr.Y(),IG=0===Ig(r7,2);else IG=!1;if(IG)var s7=Lr.Y().W(0),t7=Lr.Y().W(1);else throw(new q).j(GZ);var u7=s7,v7=t7;return u((new v).K((new w).f([&quot;Extensions[&quot;,&quot;].prims[&quot;,&quot;](&quot;,&quot;);&quot;])),(new w).f([ed(fd(),u7),ed(fd(),v7),jr(a,b,d,e,f).zb(&quot;, &quot;)]))}if(d.Lo){var w7=(new v).K((new w).f([&quot;&quot;,&quot;;&quot;])),x7=oa(b.xd).kh(),HZ=(new Sb).c(x7),y7=HZ.R.length|0,z7=Ye(Ze(),HZ.R,1,y7);return u(w7,(new w).f([Naa(z7)]))}var A7=
u((new v).K((new w).f([&quot;unimplemented primitive: &quot;,&quot;&quot;])),(new w).f([b.xd.H().Wb])),B7=b.xd.H();gd(A7,B7)}function Hr(a){var b=a.za.W(0).pe;if(Nr(b))return Eh(b).toLowerCase();b=u((new v).K((new w).f([&quot;unknown reference: &quot;,&quot;&quot;])),(new w).f([oa(b).kh()]));a=a.xd.H();gd(b,a)}function Fr(a,b,d,e,f,h){a=bd(a);b=d.za.W(b);return ir(a,b,e,f,h)}
function $ea(a,b,d,e,f,h){a=bd(a);var k=b.za.W(0);e=ir(a,k,e,f,h);d=d?&quot;createOrderedTurtles&quot;:&quot;createTurtles&quot;;b=b.xd;if(!(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.kB||b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.jB))throw(new df).c(u((new v).K((new w).f([&quot;How did you get here with class of type &quot;,&quot;&quot;])),(new w).f([oa(b).kh()])));b=b.ja;return u((new v).K((new w).f([&quot;world.turtleManager.&quot;,&quot;(&quot;,&quot;, &quot;,&quot;);&quot;])),(new w).f([d,e,ed(fd(),b)]))}
function Er(a,b,d,e,f,h,k){var p=bd(a),t=b.za.W(0),t=ir(p,t,f,h,k),p=b.za.W(1).fe.Zf.He();a=bd(a);b=b.za.W(1);f=ur(a,b,!1,f,h,k);d=u((new v).K((new w).f([&quot;LinkPrims.&quot;,&quot;(&quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([d,t,ed(fd(),id(e))]));return vr(d,p,f)}
function Zea(a,b,d,e,f,h){var k=bd(a),p=b.za.W(0),k=ir(k,p,e,f,h);d=d?&quot;createOrderedTurtles&quot;:&quot;createTurtles&quot;;p=b.xd;if(!Br(p)&amp;&amp;!Cr(p))throw(new df).c(&quot;How did you get here with class of type &quot;+oa(p).kh());p=p.ja;a=bd(a);b=b.za.W(1);e=ur(a,b,!1,e,f,h);f=u((new v).K((new w).f([&quot;world.turtleManager.&quot;,&quot;(&quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([d,k,ed(fd(),p)]));return vr(f,!0,e)}function vr(a,b,d){return u((new v).K((new w).f([&quot;&quot;,&quot;.ask(&quot;,&quot;, &quot;,&quot;);&quot;])),(new w).f([a,d,b]))}function Or(){}Or.prototype=new l;
Or.prototype.constructor=Or;Or.prototype.b=function(){return this};
function bfa(a,b){var d=Pr(Qr(),(new Rr).ci(b),&quot;returnType&quot;),e=Sr(),d=d.Mk(e).xt(),e=d.z()?&quot;unit&quot;:d.Y(),d=&quot;unit&quot;!==e,f=Tr(Qr(),(new Rr).ci(b),&quot;argTypes&quot;),h=cfa(),f=sd(f,h).X;a=m(new n,function(){return function(a){var b=Pr(Qr(),(new Rr).ci(a),&quot;type&quot;),d=Sr();if((b=Ur(b,d))&amp;&amp;b.$classData&amp;&amp;b.$classData.n.uB)b=Sr(),a=Vr(sd(a,b));else if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.wB)b=b.X,a=Pr(Qr(),(new Rr).ci(a),&quot;isRepeatable&quot;),d=dfa(),a=a.Mk(d).xt(),a=!(a.z()||!a.Y()),a=Vr(b)|(a?Ij():0);else throw(new q).j(b);
return a}}(a));h=Mk().qc;f=Wr(f,a,h);a=Vr(e);d?(d=Pr(Qr(),(new Rr).ci(b),&quot;isInfix&quot;),e=dfa(),d=d.Mk(e).xt(),(d.z()?0:d.Y())?(d=f.$(),e=f.aa()):(d=nc(),e=f),d|=0,f=Pr(Qr(),(new Rr).ci(b),&quot;precedenceOffset&quot;),h=efa(),f=f.Mk(h).xt(),f=(f.z()?0:f.Y())|0,f=C()+f|0,a=ffa(a,d,e,f)):a=(new Xr).zx(f);d=Tr(Qr(),(new Rr).ci(b),&quot;name&quot;);e=Sr();d=sd(d,e);b=Tr(Qr(),(new Rr).ci(b),&quot;actionName&quot;);e=Sr();return gfa(new Yr,a,d,sd(b,e))}
function Vr(a){if(&quot;agentset&quot;===a)return Qj(D());if(&quot;agent&quot;===a)return Lj(D());if(&quot;booleanblock&quot;===a)return ck(D());if(&quot;boolean&quot;===a)return Nj(D());if(&quot;bracketed&quot;===a)return Kj();if(&quot;codeblock&quot;===a)return uk();if(&quot;commandblock&quot;===a)return Zj(D());if(&quot;command&quot;===a)return Yj(D());if(&quot;linkset&quot;===a)return Tj(D());if(&quot;link&quot;===a)return Wj(D());if(&quot;list&quot;===a)return Pj(D());if(&quot;nobody&quot;===a)return Mj(D());if(&quot;numberblock&quot;===a)return dk(D());if(&quot;number&quot;===a)return N(D());if(&quot;optional&quot;===a)return yk();if(&quot;otherblock&quot;===
a)return bk(D());if(&quot;patchset&quot;===a)return Sj(D());if(&quot;patch&quot;===a)return Vj(D());if(&quot;readable&quot;===a)return Zr();if(&quot;reference&quot;===a)return Jj();if(&quot;repeatable&quot;===a)return Ij();if(&quot;reporterblock&quot;===a)return ak(D());if(&quot;reporter&quot;===a)return Xj(D());if(&quot;string&quot;===a)return Oj(D());if(&quot;symbol&quot;===a)return xk();if(&quot;turtleset&quot;===a)return Rj(D());if(&quot;turtle&quot;===a)return Uj(D());if(&quot;wildcard&quot;===a)return lc();if(&quot;unit&quot;===a)return nc();throw Kg(Lg(),(new $r).c(u((new v).K((new w).f([&quot;Unknown type given in extension: &quot;,
&quot;&quot;])),(new w).f([a]))));}Or.prototype.$classData=g({A2:0},!1,&quot;org.nlogo.tortoise.compiler.CreateExtension$&quot;,{A2:1,d:1});var as=void 0;function hfa(){as||(as=(new Or).b());return as}function bs(){}bs.prototype=new l;bs.prototype.constructor=bs;bs.prototype.b=function(){return this};bs.prototype.$classData=g({G2:0},!1,&quot;org.nlogo.tortoise.compiler.ExtDefReader$&quot;,{G2:1,d:1});var ifa=void 0;
function jfa(a){a=u((new v).K((new w).f([&quot;|try {\n        |  var reporterContext \x3d false;\n        |  var letVars \x3d { };\n        |&quot;,&quot;\n        |} catch (e) {\n        |  if (e instanceof Exception.StopInterrupt) {\n        |    return e;\n        |  } else {\n        |    throw e;\n        |  }\n        |}&quot;])),(new w).f([tr(fd(),a)]));a=(new Sb).c(a);return dd(a)}
var sr=function kfa(b,d,e,f,h,k,p){var t=(new cs).Po(1+k.no|0,k.uc);if(yb(d))return kfa(b,d.fe,!0,!1,h,t,p);if(!(d&amp;&amp;d.$classData&amp;&amp;d.$classData.n.Dz))throw(new q).j(d);k=d.Zf;h=m(new n,function(b,d,e,f){return function(h){var k=b.ya?b.$x:lfa(b);return Xea(k,h,d,f,e)}}(b,h,p,t));p=r();b=k.xa(h,p.s).Pf(m(new n,function(){return function(b){b=(new Sb).c(b);return kd(b)}}(b))).zb(&quot;\n&quot;);return f||e&amp;&amp;d.oe?jfa(b):b};
function ur(a,b,d,e,f,h){a=d?u((new v).K((new w).f([&quot;return &quot;,&quot;;&quot;])),(new w).f([ir(a,b,e,f,h)])):sr(a,b,!0,!1,e,f,h);b=I(r(),y());return ds(fd(),b,a)}var nfa=function mfa(b,d){if(Zg(d)){fd();var e=Mk().qc,e=Mc(d,e);for(d=Ok(d.Ac);d.qi;){var f=d.ma();e.Na(mfa(b,f))}return es(0,e.Da(),&quot; &quot;)}if(Ph()===d)return&quot;Nobody&quot;;b=Eo();return $b(b,d,!0,!1)};function cd(a,b){return u((new v).K((new w).f([&quot;_&quot;,&quot;_&quot;,&quot;_&quot;,&quot;&quot;])),(new w).f([b,a.ra.Xa,a.ra.Va]))}
var ir=function ofa(b,d,e,f,h){f=(new cs).Po(1+f.no|0,f.uc);if(zb(d))return ofa(b,d.Sk,e,f,h);if(!xb(d))throw(new q).j(d);b=b.ya?b.$x:lfa(b);return pfa(b,d,e,f,h)};
function qfa(a,b,d,e,f,h,k){a=d?u((new v).K((new w).f([&quot;return &quot;,&quot;;&quot;])),(new w).f([ir(a,b,f,h,k)])):sr(a,b,!0,!1,f,h,k);b=1!==e.sa()?&quot;s&quot;:&quot;&quot;;a=0&lt;e.sa()?u((new v).K((new w).f([&quot;if (arguments.length \x3c &quot;,') {\n          |  throw new Error(&quot;anonymous procedure expected ',&quot; input&quot;,', but only got &quot; + arguments.length);\n          |}\n          |',&quot;&quot;])),(new w).f([e.sa(),e.sa(),b,a])):u((new v).K((new w).f([&quot;&quot;,&quot;&quot;])),(new w).f([a]));a=(new Sb).c(a);a=dd(a);return ds(fd(),e,a)}
function fs(){this.RG=this.XR=this.NG=null;this.a=0}fs.prototype=new l;fs.prototype.constructor=fs;
fs.prototype.b=function(){gs=this;for(var a=[(new A).e(&quot;!&quot;,&quot;_exclamation_&quot;),(new A).e(&quot;#&quot;,&quot;_pound_&quot;),(new A).e(&quot;\\$&quot;,&quot;_dollar_&quot;),(new A).e(&quot;%&quot;,&quot;_percent_&quot;),(new A).e(&quot;\\^&quot;,&quot;_caret_&quot;),(new A).e(&quot;\\\x26&quot;,&quot;_ampersand_&quot;),(new A).e(&quot;\\*&quot;,&quot;_asterisk_&quot;),(new A).e(&quot;\x3c&quot;,&quot;_lessthan_&quot;),(new A).e(&quot;\x3e&quot;,&quot;_greaterthan_&quot;),(new A).e(&quot;/&quot;,&quot;_slash_&quot;),(new A).e(&quot;\\.&quot;,&quot;_dot_&quot;),(new A).e(&quot;\\?&quot;,&quot;_p&quot;),(new A).e(&quot;\x3d&quot;,&quot;_eq&quot;),(new A).e(&quot;\\+&quot;,&quot;_plus_&quot;),(new A).e(&quot;:&quot;,&quot;_colon_&quot;),(new A).e(&quot;'&quot;,&quot;_prime_&quot;)],b=dc(new ec,gc()),
d=0,e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.NG=b.Ma;this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;this.XR=I(r(),(new w).f(&quot;^(is)([A-Z].*)$ ^(on)([a-z].*)$ ^(screen)([A-Z].*)$ ^(scroll)([A-Zb].*)$ ^(webkit)([A-Z].*)$ ^(moz)([A-Z].*)$ ^(ms)([A-Z].*)$&quot;.split(&quot; &quot;)));this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;this.RG=I(r(),(new w).f(&quot;alert atob break blur btoa case catch class clear close closed console content copy const confirm console constructor continue crypto debugger default delete do document dump else enum escape eval event export extends external false finally find focus for frames function history if implements import in instanceof inspect interface keys length let location localStorage monitor moveBy moveTo name navigator new null open opener package parent parseFloat parseInt performance print private profile profileEnd prompt protected public return screen scroll setInterval setTimeout static status statusbar stop super switch table this throw toolbar toString top true try typeof updateCommands undefined unescape uneval unmonitor unwatch valueOf values var void while window with yield&quot;.split(&quot; &quot;)));
this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;return this};function rfa(a){if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/JSIdentProvider.scala: 55&quot;);return a.RG}
function sfa(a,b){return tfa(a).Gb(b,tb(new ub,function(){return function(a,b){b=(new Sb).c(b);var f=y(),f=(new Tb).Ro(b.R,f),h=f.MW;b=new hs;b.vF=a;b.jba=h;b.dm=Fg(new Gg,f.Xu,a,La(a));b.tn=0;a=new is;if(null===b)throw Kg(Lg(),null);a.Sa=b;for(a.ME=(new so).b();a.ta();)b=ufa(a),b=u((new v).K((new w).f([&quot;&quot;,&quot;_&quot;,&quot;&quot;])),(new w).f([nba(b,1),nba(b,2)])),to(a.Sa.dm,a.ME,b);b=(new so).KD(a.ME);uo(a.Sa.dm,b);return b.Zb}}(a)))}
function vfa(a,b){var d=wfa(a);return Zl(d,b,tb(new ub,function(){return function(a,b){var d=(new A).e(a,b);a=d.kb;b=d.Ab;if(null!==b)return d=b.la(),b=b.pa(),Qb(Ia(),a,d,b);throw(new q).j(d);}}(a)))}function wfa(a){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/JSIdentProvider.scala: 26&quot;);return a.NG}
function xfa(a,b){return rfa(a).Gb(b,tb(new ub,function(){return function(a,b){return a!==b?a:u((new v).K((new w).f([&quot;_&quot;,&quot;_&quot;])),(new w).f([a]))}}(a)))}
function or(a,b){return qb(m(new n,function(){return function(a){a=a.toLowerCase();a=(new Sb).c(a);a=Ei(a,45);var b;b=[];for(var f=0,h=a.l.length;f&lt;h;){var k=(new Sb).c(a.l[f]),k=yfa(k);b.push(null===k?null:k);f=1+f|0}a=ka(Xa(qa),b);b=(new Fm).b();f=!0;js(b,&quot;&quot;);h=0;for(k=a.l.length;h&lt;k;){var p=a.l[h];f?(ks(b,p),f=!1):(js(b,&quot;&quot;),ks(b,p));h=1+h|0}js(b,&quot;&quot;);a=b.vc.Zb;b=(new Sb).c(a);b=Ak(b);b=null===b?0:b.X;b=zfa(Uh(),b);b=(new af).Ra(b);a=(new Sb).c(a);return&quot;&quot;+b+Sk(a)}}(a)),m(new n,function(a){return function(b){return vfa(a,
b)}}(a))).Ca(m(new n,function(a){return function(b){return xfa(a,b)}}(a))).Ca(m(new n,function(a){return function(b){return sfa(a,b)}}(a))).y(b)}function tfa(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/JSIdentProvider.scala: 45&quot;);return a.XR}fs.prototype.$classData=g({I2:0},!1,&quot;org.nlogo.tortoise.compiler.JSIdentProvider$&quot;,{I2:1,d:1});var gs=void 0;function pr(){gs||(gs=(new fs).b());return gs}
function ls(){this.gh=null;this.ya=0}ls.prototype=new l;ls.prototype.constructor=ls;function Afa(a,b){b=ms(b.Pg);var d=m(new n,function(){return function(a){return(new A).e(a.la(),Bfa(a.pa()))}}(a)),e=r();b=b.xa(d,e.s);a=a.gh;d=r();return(new ls).K(b.Rc(a,d.s))}ls.prototype.K=function(a){this.gh=a;return this};ls.prototype.JF=function(){var a=this.gh,b=m(new n,function(){return function(a){return a.pa().$V(a.la())}}(this)),d=r();return a.xa(b,d.s).Oc(&quot;{&quot;,&quot;,&quot;,&quot;}&quot;)};
ls.prototype.$classData=g({J2:0},!1,&quot;org.nlogo.tortoise.compiler.JavascriptObject&quot;,{J2:1,d:1});function ns(){}ns.prototype=new l;ns.prototype.constructor=ns;ns.prototype.b=function(){return this};function es(a,b,d){return b.He()?b.Oc(&quot;[&quot;,u((new v).K((new w).f([&quot;,&quot;,&quot;&quot;])),(new w).f([d])),&quot;]&quot;):&quot;[]&quot;}function Cfa(a,b){a=(new Sb).c(b).R.split(&quot;\\&quot;).join(&quot;\\\\&quot;);a=(new Sb).c(a).R.split(&quot;\n&quot;).join(&quot;\\n&quot;);a=(new Sb).c(a).R.split('&quot;').join('\\&quot;');return(new Sb).c(a).R.split(&quot;'&quot;).join(&quot;\\'&quot;)}
function Dfa(a,b){return ed(0,Cfa(0,b))}function Efa(a,b){var d=(new Sb).c(b);return kd(d)?(b=u((new v).K((new w).f([&quot;return &quot;,&quot;;&quot;])),(new w).f([b])),d=I(r(),y()),ds(a,d,b)):ds(a,I(r(),y()),&quot;&quot;)}
function ds(a,b,d){b=b.Oc(&quot;(&quot;,&quot;, &quot;,&quot;)&quot;);if(0===(d.length|0))return u((new v).K((new w).f([&quot;function&quot;,&quot; {}&quot;])),(new w).f([b]));var e=(new Sb).c(d),e=Ffa(e);if(2&gt;os(e)&amp;&amp;100&gt;(d.length|0))return u((new v).K((new w).f([&quot;function&quot;,&quot; { &quot;,&quot; }&quot;])),(new w).f([b,d]));a=u((new v).K((new w).f([&quot;|function&quot;,&quot; {\n          |&quot;,&quot;\n          |}&quot;])),(new w).f([b,tr(a,d)]));a=(new Sb).c(a);return dd(a)}function ed(a,b){return&quot;&quot;+(new af).Ra(34)+b+(new af).Ra(34)}
function tr(a,b){b=(new Sb).c(b);b=Ffa(b);a=(new bc).Gf(b,m(new n,function(){return function(a){return&quot;  &quot;+a}}(a)));return cc(a,&quot;&quot;,&quot;\n&quot;,&quot;&quot;)}function ps(a,b){var d=(new Sb).c(b);return kd(d)?(b=u((new v).K((new w).f([&quot;&quot;,&quot;;&quot;])),(new w).f([b])),d=I(r(),y()),ds(a,d,b)):ds(a,I(r(),y()),&quot;&quot;)}function qs(a){return&quot;NIL&quot;!==a?(new Sb).c(a).R.split(&quot;'&quot;).join(&quot;\\'&quot;):&quot;&quot;}ns.prototype.$classData=g({L2:0},!1,&quot;org.nlogo.tortoise.compiler.JsOps$&quot;,{L2:1,d:1});var rs=void 0;
function fd(){rs||(rs=(new ns).b());return rs}function ss(){}ss.prototype=new l;ss.prototype.constructor=ss;ss.prototype.b=function(){return this};
function Gfa(a,b,d,e,f){b=Dq(qd(),b);b=mq().Za(b);if(!nq(b)){if(!pq(b))throw(new q).j(b);var h=b.cc;b=function(){return function(a){return(new Eq).c(a)}}(a);tq();var k=b(h.Fc),h=h.Mc,p=uq().Vd,h=vq(h);a:for(;;){if(!wq(h)){if(xq(h)){var t=h,h=t.dd,t=b(t.$c),p=(new yq).Qb(t,p);continue a}throw(new q).j(h);}break}b=(new qq).j((new zq).Qb(k,p))}if(nq(b)){b=b.ha;b=ar().by().y(b);if(!nq(b)){if(!pq(b))throw(new q).j(b);b=(new qq).j(rq(b.cc))}if(nq(b))b=(new sq).j(b.ha);else if(!pq(b))throw(new q).j(b);}else if(!pq(b))throw(new q).j(b);
if(!nq(b)){if(pq(b)){e=b.cc;Hfa();a=function(){return function(a){return a}}(a);tq();d=a(e.Fc);e=e.Mc;f=uq().Vd;e=vq(e);a:for(;;){if(!wq(e)){if(xq(e)){var x=e;e=x.dd;x=a(x.$c);f=(new yq).Qb(x,f);continue a}throw(new q).j(e);}break}a=(new zq).Qb(d,f);d=tq().qE;a=jba(new pe,a,d);a=a.nr.mi(a.pc);throw(new ts).c(cc(a,&quot;&quot;,&quot;\n&quot;,&quot;&quot;));}throw(new q).j(b);}b=b.ha;try{x=Ifa(br(),Jfa(b,e,f,d),cr())}catch(E){a=ko(Lg(),E);if(us(a))throw(new ts).c(a.Fh());throw E;}a=x.Jr.al(m(new n,function(){return function(a){if(null!==
a)return a.pa().ib(&quot;__run&quot;);throw(new q).j(a);}}(a)),!1);switch(a.Ga()){case 1:return a.$().la();case 0:throw(new ts).c(&quot;The compiler did not return a procedure for the run primitive, but it also did not throw an error.&quot;);default:throw(new ts).c(&quot;The compiler returned multiple procedures with the same name for the run primitive.&quot;);}}
function Jfa(a,b,d,e){b=b?u((new v).K((new w).f([&quot;&quot;,&quot;\\nto-report __run [&quot;,&quot;] report (&quot;,&quot;) end&quot;])),(new w).f([a.Zd,d,e])):u((new v).K((new w).f([&quot;&quot;,&quot;\\nto __run [&quot;,&quot;] &quot;,&quot; end&quot;])),(new w).f([a.Zd,d,e]));return Kfa(b,a.Se,a.Rh,a.Gc,a.Yi,a.ij,a.Zg,a.Lg).Ey()}
ss.prototype.isReporter=function(a){Fk();vs();var b;var d=ws(),e=ph(),f=(new xs).b();try{var h=Sp(Hc(ys()),&quot;to __is-reporter? report &quot;+a+&quot;\nend&quot;,(Hc(ys()),&quot;&quot;)),k=Tp(),p=(new bc).Gf(h,k),t=zea(Aea(new Jp,F(),!0),p,Gp(new Hp,d,e,(Kp(),nh($e().kk,y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())))),x=(new Kc).fg(t.ce).oi.rj().ma(),E=new yc,S=zc(e,t.ce);E.ec=d;E.ce=S;E.ji=x;E.hh=f;Eaa(E);for(var U=xc(uc(),t.ep.y(x.me()).Oa(),E),ga=zs(As(U),1);;){if(ga.z())Fa=!1;else var ma=ga.$().jb,va=ym(),
Fa=null!==ma&amp;&amp;ma===va;if(Fa)ga=ga.aa();else break}var Va=Uk(ga);if(Va.z())b=!1;else{var vb=Va.Y(),pb=vb.jb;b=Am()===pb||Rm()===pb||Cm()===pb?!0:vg()===pb?!(nr(vb.X)||Wn(vb.X)||hn(vb.X)):!1}}catch(Ib){if(Jq(Ib))b=!1;else throw Ib;}return b};ss.prototype.compileRunString=function(a,b,d,e){return Gfa(this,a,b,!!d,e)};ss.prototype.stringToJSValue=function(a){var b;try{var d=(new Bs).b(),e=Lfa(Fk(),a);b=d.db(e,ld().JC)}catch(f){a=ko(Lg(),f);if(us(a))throw(new ts).c(a.Fh());throw f;}return b};
ss.prototype.$classData=g({M2:0},!1,&quot;org.nlogo.tortoise.compiler.LiteralConverter$&quot;,{M2:1,d:1});var Cs=void 0;function Ds(){}Ds.prototype=new l;Ds.prototype.constructor=Ds;Ds.prototype.b=function(){return this};Ds.prototype.k=function(){return&quot;nobody&quot;};Ds.prototype.toString=function(){return&quot;nobody&quot;};Ds.prototype.isDead=function(){return!0};Object.defineProperty(Ds.prototype,&quot;id&quot;,{get:function(){return-1},configurable:!0});Ds.prototype.ask=function(){};
Ds.prototype.$classData=g({Q2:0},!1,&quot;org.nlogo.tortoise.compiler.Nobody$&quot;,{Q2:1,d:1});var Es=void 0;function Mfa(){Es||(Es=(new Ds).b());return Es}function Fs(){}Fs.prototype=new l;Fs.prototype.constructor=Fs;Fs.prototype.b=function(){return this};
function Nfa(a,b){return qb(m(new n,function(){return function(a){Gs||(Gs=(new Hs).b());return Lb(Gs,a)}}(a)),m(new n,function(){return function(a){Is||(Is=(new Js).b());return Lb(Is,a)}}(a))).Ca(m(new n,function(){return function(a){Ks||(Ks=(new Ls).b());return Lb(Ks,a)}}(a))).Ca(m(new n,function(){return function(a){Ms||(Ms=(new Ns).b());return Lb(Ms,a)}}(a))).Ca(m(new n,function(){return function(a){Os||(Os=(new Ps).b());return Lb(Os,a)}}(a))).Ca(m(new n,function(){return function(a){Qs||(Qs=(new Rs).b());
return Lb(Qs,a)}}(a))).Ca(m(new n,function(){return function(a){Ss||(Ss=(new Ts).b());return Lb(Ss,a)}}(a))).Ca(m(new n,function(){return function(a){Us||(Us=(new Vs).b());return Lb(Us,a)}}(a))).Ca(m(new n,function(){return function(a){Ws||(Ws=(new Xs).b());return Lb(Ws,a)}}(a))).Ca(m(new n,function(){return function(a){Ys||(Ys=(new Zs).b());return Lb(Ys,a)}}(a))).Ca(m(new n,function(){return function(a){$s||($s=(new at).b());return Lb($s,a)}}(a))).Ca(m(new n,function(){return function(a){bt||(bt=
(new ct).b());return Lb(bt,a)}}(a))).Ca(m(new n,function(){return function(a){dt||(dt=(new et).b());return Lb(dt,a)}}(a))).Ca(m(new n,function(){return function(a){ft||(ft=(new gt).b());return Lb(ft,a)}}(a))).y(b)}Fs.prototype.$classData=g({R2:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$&quot;,{R2:1,d:1});var ht=void 0;function Ofa(){ht||(ht=(new Fs).b());return ht}function it(){}it.prototype=new l;it.prototype.constructor=it;it.prototype.b=function(){return this};
it.prototype.Yd=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(jt(d)&amp;&amp;(r(),d=(new J).j(b),null!==d.U&amp;&amp;0===d.U.Rb(2)&amp;&amp;(b=d.U.W(0),d=d.U.W(1),xb(b)&amp;&amp;(b=vi().Yd(b),!b.z()&amp;&amp;(b=b.Y().gb,Nr(b)&amp;&amp;xb(d))))))return(new J).j((new A).e(b,d))}d=vi().Yd(a);return!d.z()&amp;&amp;(a=d.Y().gb,d=d.Y().Fb,jt(a)&amp;&amp;(r(),d=(new J).j(d),null!==d.U&amp;&amp;0===d.U.Rb(2)&amp;&amp;(a=d.U.W(0),d=d.U.W(1),xb(a)&amp;&amp;xb(d)&amp;&amp;(d=vi().Yd(d),!d.z()&amp;&amp;(d=d.Y().gb,Nr(d))))))?(new J).j((new A).e(d,a)):F()};
it.prototype.$classData=g({g3:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$WithTransformer$PatchVarEqualExpression$&quot;,{g3:1,d:1});var kt=void 0;function lt(){}lt.prototype=new l;lt.prototype.constructor=lt;lt.prototype.b=function(){return this};
function Pfa(a,b){var d=(new mt).b(),e=r();b=b.ic(d,e.s);a=m(new n,function(){return function(a){var b=new nt;b.Wk=a;a=b.Wk.pp;if(nq(a))a=a.ha,b=Qfa(b,a.Dj,a.Ej,a.Ir);else{if(!pq(a))throw(new q).j(a);b=Rfa(b,a.cc)}return b}}(a));d=r();a=b.xa(a,d.s);b=(new ot).b();d=r();b=a.ic(b,d.s);d=(new pt).b();e=r();a=a.ic(d,e.s).cs($e().Fk);b=es(fd(),b,&quot; &quot;);a=a.z()?&quot;&quot;:Sfa(0,a.zb(&quot;, &quot;));return I(r(),(new w).f([(new qt).cf(&quot;PenBundle&quot;,&quot;engine/plot/pen&quot;),(new qt).cf(&quot;Plot&quot;,&quot;engine/plot/plot&quot;),(new qt).cf(&quot;PlotOps&quot;,
&quot;engine/plot/plotops&quot;),(new rt).vk(&quot;modelConfig&quot;,st(0,&quot;window.modelConfig&quot;,&quot;{}&quot;),I(r(),y())),(new rt).vk(&quot;modelPlotOps&quot;,st(0,&quot;modelConfig.plotOps&quot;,&quot;{}&quot;),I(r(),(new w).f([&quot;modelConfig&quot;]))),(new tt).vk(&quot;modelConfig.plots&quot;,u((new v).K((new w).f([&quot;modelConfig.plots \x3d &quot;,&quot;;&quot;,&quot;&quot;])),(new w).f([b,a])),I(r(),(new w).f([&quot;PenBundle&quot;,&quot;Plot&quot;,&quot;PlotOps&quot;,&quot;modelConfig&quot;,&quot;modelPlotOps&quot;])))]))}function Sfa(a,b){return u((new v).K((new w).f(['modelConfig.dialog.notify(&quot;Error: ','&quot;);'])),(new w).f([b]))}
function st(a,b,d){return u((new v).K((new w).f([&quot;(typeof &quot;,' !\x3d\x3d &quot;undefined&quot; \x26\x26 ',&quot; !\x3d\x3d null) ? &quot;,&quot; : &quot;,&quot;&quot;])),(new w).f([b,b,b,d]))}lt.prototype.$classData=g({h3:0},!1,&quot;org.nlogo.tortoise.compiler.PlotCompiler$&quot;,{h3:1,d:1});var ut=void 0;function vt(){ut||(ut=(new lt).b());return ut}function nt(){this.Wk=null}nt.prototype=new l;nt.prototype.constructor=nt;
function Tfa(a,b){a=function(){return function(a){return a.Fh()}}(a);tq();var d=a(b.Fc);b=b.Mc;var e=uq().Vd;b=vq(b);a:for(;;){if(!wq(b)){if(xq(b)){var f=b;b=f.dd;f=a(f.$c);e=(new yq).Qb(f,e);continue a}throw(new q).j(b);}break}return(new wt).K(xt((new zq).Qb(d,e)).ub())}function Ufa(a){var b=(new v).K((new w).f([&quot;PenBundle.DisplayMode.&quot;,&quot;&quot;]));switch(a){case 0:a=&quot;Line&quot;;break;case 1:a=&quot;Bar&quot;;break;case 2:a=&quot;Point&quot;;break;default:a=&quot;Line&quot;}return u(b,(new w).f([a]))}
function Rfa(a,b){a=function(){return function(a){return a.Fh()}}(a);tq();var d=a(b.Fc);b=b.Mc;var e=uq().Vd;b=vq(b);a:for(;;){if(!wq(b)){if(xq(b)){var f=b;b=f.dd;f=a(f.$c);e=(new yq).Qb(f,e);continue a}throw(new q).j(b);}break}return(new wt).K(xt((new zq).Qb(d,e)).ub())}
function Qfa(a,b,d,e){var f=ps(fd(),&quot;&quot;),h=Efa(fd(),f),f=u((new v).K((new w).f(&quot;new PlotOps(;, ;, ;, ;, ;, ;, ;)&quot;.split(&quot;;&quot;))),(new w).f([f,f,f,h,h,h,h])),h=m(new n,function(a){return function(b){var d=b.Us;if(nq(d)){b=b.Cs;var d=d.ha,e=(new v).K((new w).f([&quot;new PenBundle.State(&quot;,&quot;, &quot;,&quot;, &quot;,&quot;)&quot;]));Zb||(Zb=(new yt).b());e=u(e,(new w).f([vaa(b.yb),b.fl,Ufa(b.il)]));b=I(r(),(new w).f([u((new v).K((new w).f([&quot;'&quot;,&quot;'&quot;])),(new w).f([b.Ya])),&quot;plotOps.makePenOps&quot;,&quot;false&quot;,e,d.Dj,d.Ej]));b=(new zt).c(u((new v).K((new w).f([&quot;new PenBundle.Pen(&quot;,
&quot;)&quot;])),(new w).f([b.zb(&quot;, &quot;)])))}else{if(!pq(d))throw(new q).j(d);b=Tfa(a,d.cc)}return b}}(a)),k=r();e=e.xa(h,k.s);var h=(new ot).b(),k=r(),h=e.ic(h,k.s),k=(new pt).b(),p=r(),k=e.ic(k,p.s).cs($e().Fk);e=es(fd(),h,&quot;\n&quot;);h=k.z()?&quot;&quot;:Sfa(vt(),k.zb(&quot;, &quot;));k=r();fd();fd();p=a.Wk.Ni.Wn;p=ed(0,qs(p.z()?&quot;&quot;:p.Y()));fd();fd();var t=a.Wk.Ni.Yn,t=ed(0,qs(t.z()?&quot;&quot;:t.Y())),k=I(k,(new w).f([&quot;name&quot;,&quot;pens&quot;,&quot;plotOps&quot;,p,t,a.Wk.Ni.on,a.Wk.Ni.Nm,a.Wk.Ni.Pi,a.Wk.Ni.Oi,a.Wk.Ni.Ri,a.Wk.Ni.Qi,&quot;setup&quot;,&quot;update&quot;])).zb(&quot;, &quot;);
a=u((new v).K((new w).f(&quot;|var name    \x3d ',';\n            |var plotOps \x3d ,;\n            |var pens    \x3d ,;,\n            |var setup   \x3d ,;\n            |var update  \x3d ,;\n            |return new Plot(,);&quot;.split(&quot;,&quot;))),(new w).f([a.Wk.LS,st(vt(),&quot;modelPlotOps[name]&quot;,f),e,h,b,d,k]));a=(new Sb).c(a);a=dd(a);b=(new v).K((new w).f([&quot;(&quot;,&quot;)()&quot;]));d=I(r(),y());return(new zt).c(u(b,(new w).f([ds(fd(),d,a)])))}
nt.prototype.$classData=g({m3:0},!1,&quot;org.nlogo.tortoise.compiler.PlotCompiler$RichCompiledPlot&quot;,{m3:1,d:1});function At(){this.SS=this.VS=this.bj=null}At.prototype=new l;At.prototype.constructor=At;function Vfa(a,b,d,e){a.bj=b;a.VS=d;a.SS=e;return a}
function Wfa(a,b){a=m(new n,function(a){return function(b){var d=a.VS,k=a.SS,p=d.bp?Nfa(Ofa(),b):b;b=p.ji.me();var t=or(pr(),b),x=a.bj,E=(new A).e(0,t);x.Vx=E;x.a=!0;E=sc(p.ji);Lk();x=Mk().qc;x=Mc(E,x);for(E=Ok(E);E.qi;){var S=E.ma();x.Na(or(pr(),S))}E=x.Da();x=new Bt;x.lq=!0;x.cp=E;p.ji.$u.jn?(d=sr(a.bj,p.fe,!1,!1,d,k,x),d=u((new v).K((new w).f([&quot;|try {\n        |  var reporterContext \x3d true;\n        |  var letVars \x3d { };\n        |&quot;,'\n        |  throw new Error(&quot;Reached end of reporter procedure without REPORT being called.&quot;);\n        |} catch (e) {\n        | if (e instanceof Exception.StopInterrupt) {\n        |    throw new Error(&quot;STOP is not allowed inside TO-REPORT.&quot;);\n        |  } else {\n        |    throw e;\n        |  }\n        |}'])),
(new w).f([tr(fd(),d)])),d=(new Sb).c(d),d=dd(d)):d=sr(a.bj,p.fe,!0,!0,d,k,x);d=u((new v).K((new w).f([&quot;(&quot;,&quot;)&quot;])),(new w).f([ds(fd(),x.cp,d)]));return(new A).e(d,I(r(),(new w).f([t,b])).ui())}}(a));var d=r();return b.xa(a,d.s)}At.prototype.$classData=g({r3:0},!1,&quot;org.nlogo.tortoise.compiler.ProcedureCompiler&quot;,{r3:1,d:1});function Ct(){}Ct.prototype=new l;Ct.prototype.constructor=Ct;Ct.prototype.b=function(){return this};
function Xfa(a,b){a=m(new n,function(a){return function(b){if(null!==b){var d=b.la();b=b.pa();var k=m(new n,function(){return function(a){return u((new v).K((new w).f(['procs[&quot;','&quot;] \x3d temp;'])),(new w).f([a]))}}(a)),p=r();return b.xa(k,p.s).Oc(u((new v).K((new w).f([&quot;temp \x3d &quot;,&quot;;\\n&quot;])),(new w).f([d])),&quot;\n&quot;,&quot;&quot;)}throw(new q).j(b);}}(a));var d=r();b=b.xa(a,d.s).zb(&quot;\n&quot;);b=u((new v).K((new w).f([&quot;|var procs \x3d {};\n          |var temp \x3d undefined;\n          |&quot;,&quot;\n          |return procs;&quot;])),
(new w).f([b]));b=(new Sb).c(b);b=dd(b);a=(new v).K((new w).f([&quot;(&quot;,&quot;)()&quot;]));d=I(r(),y());return u(a,(new w).f([ds(fd(),d,b)]))}function Yfa(a){var b=Dt;return I(r(),(new w).f([(new rt).vk(&quot;procedures&quot;,Xfa(b,a),I(r(),(new w).f([&quot;workspace&quot;,&quot;world&quot;])))]))}Ct.prototype.$classData=g({s3:0},!1,&quot;org.nlogo.tortoise.compiler.ProcedureCompiler$&quot;,{s3:1,d:1});var Dt=void 0;function Et(a,b,d,e,f){b=b.za;var h=new Ft;if(null===a)throw Kg(Lg(),null);h.Sa=a;h.XS=d;h.US=e;h.PV=f;a=r();return b.ic(h,a.s)}
function Zfa(a){r();var b=(new J).j(a);if(null!==b.U&amp;&amp;0===b.U.Rb(1))return a=b.U.W(0),u((new v).K((new w).f([&quot;Prims.rangeUnary(&quot;,&quot;)&quot;])),(new w).f([a]));r();b=(new J).j(a);if(null!==b.U&amp;&amp;0===b.U.Rb(2))return a=b.U.W(0),b=b.U.W(1),u((new v).K((new w).f([&quot;Prims.rangeBinary(&quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([a,b]));r();var d=(new J).j(a);if(null!==d.U&amp;&amp;0===d.U.Rb(3))return a=d.U.W(0),b=d.U.W(1),d=d.U.W(2),u((new v).K((new w).f([&quot;Prims.rangeTernary(&quot;,&quot;, &quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([a,b,d]));throw(new df).c(&quot;range expects at most three arguments&quot;);
}function $fa(a){return u((new v).K((new w).f([&quot;SelfManager.self()._optimalNSum4(&quot;,&quot;)&quot;])),(new w).f([ed(fd(),a)]))}function Gt(a,b,d,e,f,h){a=bd(a);b=d.za.W(b);return ir(a,b,e,f,h)}function aga(a){return u((new v).K((new w).f([&quot;SelfManager.self()._optimalNSum(&quot;,&quot;)&quot;])),(new w).f([ed(fd(),a)]))}function bga(a,b,d,e,f){var h=bd(a),k=b.za.W(1),h=ir(h,k,d,e,f);a=bd(a);b=b.za.W(0);d=ur(a,b,!0,d,e,f);return u((new v).K((new w).f([&quot;&quot;,&quot;.projectionBy(&quot;,&quot;)&quot;])),(new w).f([h,d]))}
function pfa(a,b,d,e,f){var h=b.pe;ld();var k=(new Ht).b(),p=md(new nd,k).Uc(h);if(!p.z())return p.Y();ld();var t=(new It).b(),x=md(new nd,t).Uc(h);if(!x.z()){var E=x.Y();return u((new v).K((new w).f([&quot;(&quot;,&quot; &quot;,&quot; &quot;,&quot;)&quot;])),(new w).f([Gt(a,0,b,d,e,f),E,Gt(a,1,b,d,e,f)]))}ld();var S=(new Jt).b(),U=md(new nd,S).Uc(h);if(!U.z()){var ga=U.Y();return u((new v).K((new w).f([&quot;&quot;,&quot;(&quot;,&quot;)&quot;])),(new w).f([ga,Et(a,b,d,e,f).zb(&quot;, &quot;)]))}ld();var ma=(new Kt).b(),va=md(new nd,ma).Uc(h);if(!va.z()){var Fa=va.Y();return u((new v).K((new w).f([&quot;NLType(&quot;,
&quot;).&quot;,&quot;&quot;])),(new w).f([Gt(a,0,b,d,e,f),Fa]))}var Va=cga(a).PF(h);if(!Va.z())return Va.Y();if(Do(h)){var vb=bd(a);return nfa(vb,h.X)}if(nr(h)){bd(a);var pb=h.Wc.va;return or(pr(),pb)}if(qr(h)){bd(a);var Ib=h.va;return or(pr(),Ib)}if(Go(h)){bd(a);var kc=h.va;return or(pr(),kc)}if(Lt(h))return u((new v).K((new w).f(['procedures[&quot;','&quot;](',&quot;)&quot;])),(new w).f([h.Kh.me(),Et(a,b,d,e,f).zb(&quot;,&quot;)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Mz)return u((new v).K((new w).f([&quot; -&quot;,&quot;&quot;])),(new w).f([Gt(a,0,b,d,e,f)]));if(h&amp;&amp;
h.$classData&amp;&amp;h.$classData.n.Jz)return u((new v).K((new w).f([&quot;!&quot;,&quot;&quot;])),(new w).f([Gt(a,0,b,d,e,f)]));if(Mt(h))return u((new v).K((new w).f([&quot;&quot;,&quot;.size()&quot;])),(new w).f([Gt(a,0,b,d,e,f)]));if(Nt(h))return u((new v).K((new w).f([&quot;!&quot;,&quot;.isEmpty()&quot;])),(new w).f([Gt(a,0,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Nz){var $a=Et(a,b,d,e,f),fc=r(),Bc=$a.fd(&quot;<I>&quot;,fc.s),sf=m(new n,function(){return function(a){return u((new v).K((new w).f([&quot;workspace.dump(&quot;,&quot;)&quot;])),(new w).f([a]))}}(a)),Sf=r();return Bc.xa(sf,</I>
Sf.s).Oc(&quot;(&quot;,&quot; + &quot;,&quot;)&quot;)}if(Ot(h))return bga(a,b,d,e,f);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.nA)return u((new v).K((new w).f([&quot;(&quot;,&quot; ? &quot;,&quot; : &quot;,&quot;)&quot;])),(new w).f([Gt(a,0,b,d,e,f),Gt(a,1,b,d,e,f),Gt(a,2,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.LA)return u((new v).K((new w).f([&quot;&quot;,&quot;.reduce(&quot;,&quot;)&quot;])),(new w).f([Gt(a,1,b,d,e,f),Gt(a,0,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.iA)return u((new v).K((new w).f([&quot;&quot;,&quot;.filter(&quot;,&quot;)&quot;])),(new w).f([Gt(a,1,b,d,e,f),Gt(a,0,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.GA)return u((new v).K((new w).f([&quot;Tasks.nValues(&quot;,
&quot;, &quot;,&quot;)&quot;])),(new w).f([Gt(a,0,b,d,e,f),Gt(a,1,b,d,e,f)]));if(Pt(h)){var th=h.Wc;if(Vk(th)){var Te=th.U,tf=(new v).K((new w).f([&quot;_error_&quot;,&quot;.message&quot;])),ek=Q();return u(tf,(new w).f([R(ek,Te)]))}}if(Qt(h)){var og=Gt(a,0,b,d,e,f),uh=(new v).K((new w).f([&quot;&quot;,&quot;.agentFilter(&quot;,&quot;)&quot;])),pg=bd(a),Yh=b.za.W(1);return u(uh,(new w).f([og,ur(pg,Yh,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.zA){var Ri=Gt(a,1,b,d,e,f),fk=(new v).K((new w).f([&quot;&quot;,&quot;.maxNOf(&quot;,&quot;, &quot;,&quot;)&quot;])),Si=Gt(a,0,b,d,e,f),gk=bd(a),Ti=b.za.W(2);return u(fk,
(new w).f([Ri,Si,ur(gk,Ti,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.AA){var vl=Gt(a,0,b,d,e,f),Ui=(new v).K((new w).f([&quot;&quot;,&quot;.maxOneOf(&quot;,&quot;)&quot;])),hk=bd(a),Vi=b.za.W(1);return u(Ui,(new w).f([vl,ur(hk,Vi,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.BA){var wl=Gt(a,1,b,d,e,f),vh=(new v).K((new w).f([&quot;&quot;,&quot;.minNOf(&quot;,&quot;, &quot;,&quot;)&quot;])),xl=Gt(a,0,b,d,e,f),wh=bd(a),ik=b.za.W(2);return u(vh,(new w).f([wl,xl,ur(wh,ik,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.CA){var yl=Gt(a,0,b,d,e,f),Zh=(new v).K((new w).f([&quot;&quot;,
&quot;.minOneOf(&quot;,&quot;)&quot;])),$h=bd(a),zl=b.za.W(1);return u(Zh,(new w).f([yl,ur($h,zl,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Sz){var Al=Gt(a,0,b,d,e,f),Bl=(new v).K((new w).f([&quot;&quot;,&quot;.agentAll(&quot;,&quot;)&quot;])),jk=bd(a),Cl=b.za.W(1);return u(Bl,(new w).f([Al,ur(jk,Cl,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.UA){var Dl=Gt(a,0,b,d,e,f),El=(new v).K((new w).f([&quot;&quot;,&quot;.maxesBy(&quot;,&quot;)&quot;])),Fl=bd(a),kk=b.za.W(1);return u(El,(new w).f([Dl,ur(Fl,kk,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.VA){var Gl=Gt(a,0,b,
d,e,f),ai=(new v).K((new w).f([&quot;&quot;,&quot;.minsBy(&quot;,&quot;)&quot;])),lk=bd(a),xh=b.za.W(1);return u(ai,(new w).f([Gl,ur(lk,xh,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Tz){var Hl=Gt(a,0,b,d,e,f);return u((new v).K((new w).f([&quot;&quot;,&quot;.atPoints(&quot;,&quot;)&quot;])),(new w).f([Hl,Gt(a,1,b,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.PA){var Wi=Gt(a,1,b,d,e,f),mk=(new v).K((new w).f([&quot;&quot;,&quot;.sortOn(&quot;,&quot;)&quot;])),yh=bd(a),Uf=b.za.W(0);return u(mk,(new w).f([Wi,ur(yh,Uf,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.iQ)return aga(h.Ok);
if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.jQ)return $fa(h.Ok);if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.lQ){var ue=Gt(a,0,b,d,e,f),zh=(new v).K((new w).f([&quot;&quot;,&quot;._optimalOtherWith(&quot;,&quot;)&quot;])),bi=bd(a),nk=b.za.W(1);return u(zh,(new w).f([ue,ur(bi,nk,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.kQ){var Xi=Gt(a,0,b,d,e,f),Il=(new v).K((new w).f([&quot;&quot;,&quot;._optimalOneOfWith(&quot;,&quot;)&quot;])),Yi=bd(a),Jl=b.za.W(1);return u(Il,(new w).f([Xi,ur(Yi,Jl,!0,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Iz)return u((new v).K((new w).f([&quot;world.turtleManager.turtlesOfBreed(&quot;,
&quot;)&quot;])),(new w).f([ed(fd(),h.ja)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Xz)return u((new v).K((new w).f([&quot;world.turtleManager.getTurtleOfBreed(&quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([ed(fd(),h.ja),Gt(a,0,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.tA)return u((new v).K((new w).f([&quot;world.linkManager.linksOfBreed(&quot;,&quot;)&quot;])),(new w).f([ed(fd(),h.ja)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.uA)return u((new v).K((new w).f([&quot;world.linkManager.getLink(&quot;,&quot;, &quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([Gt(a,0,b,d,e,f),Gt(a,1,b,d,e,f),ed(fd(),
h.ja)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Uz)return u((new v).K((new w).f([&quot;SelfManager.self().breedAt(&quot;,&quot;, &quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([ed(fd(),h.ja),Gt(a,0,b,d,e,f),Gt(a,1,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Vz)return u((new v).K((new w).f([&quot;SelfManager.self().breedHere(&quot;,&quot;)&quot;])),(new w).f([ed(fd(),h.ja)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.Wz)return u((new v).K((new w).f([&quot;Prims.breedOn(&quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([ed(fd(),h.ja),Gt(a,0,b,d,e,f)]));if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.pA){var Zi=
(new v).K((new w).f([&quot;LinkPrims.inLinkFrom(&quot;,&quot;, &quot;,&quot;)&quot;]));fd();return u(Zi,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.qA){var $i=(new v).K((new w).f([&quot;LinkPrims.isInLinkNeighbor(&quot;,&quot;, &quot;,&quot;)&quot;]));fd();return u($i,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.rA){var ok=(new v).K((new w).f([&quot;LinkPrims.inLinkNeighbors(&quot;,&quot;)&quot;]));fd();return u(ok,(new w).f([ed(0,id(h.ja))]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.vA){var Kl=(new v).K((new w).f([&quot;LinkPrims.isLinkNeighbor(&quot;,
&quot;, &quot;,&quot;)&quot;]));fd();return u(Kl,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.wA){var aj=(new v).K((new w).f([&quot;LinkPrims.linkNeighbors(&quot;,&quot;)&quot;]));fd();return u(aj,(new w).f([ed(0,id(h.ja))]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.xA){var ci=(new v).K((new w).f([&quot;LinkPrims.linkWith(&quot;,&quot;, &quot;,&quot;)&quot;]));fd();return u(ci,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.DA){var Ll=(new v).K((new w).f([&quot;LinkPrims.myInLinks(&quot;,&quot;)&quot;]));fd();return u(Ll,(new w).f([ed(0,
id(h.ja))]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.EA){var Rg=(new v).K((new w).f([&quot;LinkPrims.myLinks(&quot;,&quot;)&quot;]));fd();return u(Rg,(new w).f([ed(0,id(h.ja))]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.FA){var Sg=(new v).K((new w).f([&quot;LinkPrims.myOutLinks(&quot;,&quot;)&quot;]));fd();return u(Sg,(new w).f([ed(0,id(h.ja))]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.HA){var pk=(new v).K((new w).f([&quot;LinkPrims.isOutLinkNeighbor(&quot;,&quot;, &quot;,&quot;)&quot;]));fd();return u(pk,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.IA){var bj=
(new v).K((new w).f([&quot;LinkPrims.outLinkNeighbors(&quot;,&quot;)&quot;]));fd();return u(bj,(new w).f([ed(0,id(h.ja))]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.JA){var Ah=(new v).K((new w).f([&quot;LinkPrims.outLinkTo(&quot;,&quot;, &quot;,&quot;)&quot;]));fd();return u(Ah,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.MA){var qk=h.H(),Ml=Et(a,b,d,e,f);return Maa(a,!0,qk,Ml,f)}if(Rt(h)){var rk=b.za.W(0),Tg=h.ve.lk(),Nl=bd(a),cj=m(new n,function(){return function(a){return or(pr(),a)}}(a,Nl)),di=r(),Bh=Tg.xa(cj,di.s),
Ol=dga(a,rk,!0,Bh,h.uc,d,e,f);return u((new v).K((new w).f([&quot;Tasks.reporterTask(&quot;,&quot;)&quot;])),(new w).f([Ol]))}if(Fo(h)){var qg=b.za.W(0),fi=h.ve.lk(),Ch=bd(a),dj=m(new n,function(){return function(a){return or(pr(),a)}}(a,Ch)),Ug=r(),ej=fi.xa(dj,Ug.s),fj=dga(a,qg,!1,ej,h.uc,d,e,f);return u((new v).K((new w).f([&quot;Tasks.commandTask(&quot;,&quot;)&quot;])),(new w).f([fj]))}if(St(h)){var gi=(new Sb).c(&quot;_externreport\\(([^:]+):([^)]+)\\)&quot;),hi=y(),gj=(new Tb).Ro(gi.R,hi),Vf=h.k();var vf,ae=Hg(gj,Vf);if(ae.z())rg=!1;else if(null!==
ae.Y())var hj=ae.Y(),rg=0===Ig(hj,2);else rg=!1;if(rg){var ij=ae.Y().W(0),jj=ae.Y().W(1);vf=(new A).e(ij,jj)}else throw(new q).j(Vf);var ii=vf.la(),ji=vf.pa();return u((new v).K((new w).f([&quot;Extensions[&quot;,&quot;].prims[&quot;,&quot;](&quot;,&quot;)&quot;])),(new w).f([ed(fd(),ii),ed(fd(),ji),Et(a,b,d,e,f).zb(&quot;, &quot;)]))}if(h&amp;&amp;h.$classData&amp;&amp;h.$classData.n.KA){var Pl=Et(a,b,d,e,f);return Zfa(Pl)}if(d.Lo){var sk=oa(b.pe).kh(),Vg=(new Sb).c(sk),ki=Vg.R.length|0,Ql=Ye(Ze(),Vg.R,1,ki);return Naa(Ql)}var tk=u((new v).K((new w).f([&quot;unimplemented primitive: &quot;,
&quot;&quot;])),(new w).f([b.pe.H().Wb])),ei=b.pe.H();gd(tk,ei)}function dga(a,b,d,e,f,h,k,p){var t=(new v).K((new w).f([&quot;&quot;,&quot;, &quot;,&quot;&quot;]));a=bd(a);return u(t,(new w).f([qfa(a,b,d,e,h,k,p),Dfa(fd(),f.z()?&quot;&quot;:f.Y())]))}function Tt(){this.qV=this.Sf=this.Gc=this.ec=null}Tt.prototype=new l;Tt.prototype.constructor=Tt;
function ega(a){var b=r(),d=(new rt).vk(&quot;turtleShapes&quot;,fga(gga(new Ut,vj(),hga(Vt(),a.Sf.Zg))),I(r(),y())),e=(new rt).vk(&quot;linkShapes&quot;,fga(gga(new Ut,xj(),hga(Vt(),a.Sf.Lg))),I(r(),y())),f=r(),h=I(r(),(new w).f([iga(a)])),k=jga(a),p=I(r(),(new w).f([u((new v).K((new w).f([&quot;'&quot;,&quot;'&quot;])),(new w).f([Cfa(fd(),a.Sf.Zd)]))])),t=r();fd();var x=a.Gc,E=m(new n,function(){return function(a){a=kga(a).Ye();return od(a)}}(a)),S=r();return I(b,(new w).f([d,e,(new Wt).su(I(f,(new w).f([h,k,p,I(t,(new w).f([es(0,x.xa(E,
S.s),&quot; &quot;)])),I(r(),(new w).f(['tortoise_require(&quot;extensions/all&quot;).dumpers()'])),lga(a)])),I(r(),(new w).f([&quot;turtleShapes&quot;,&quot;linkShapes&quot;]))),Xt(&quot;BreedManager&quot;),Xt(&quot;ExportPrims&quot;),Xt(&quot;LayoutManager&quot;),Xt(&quot;LinkPrims&quot;),Xt(&quot;ListPrims&quot;),Xt(&quot;MousePrims&quot;),Xt(&quot;OutputPrims&quot;),Xt(&quot;plotManager&quot;),Xt(&quot;Prims&quot;),Xt(&quot;PrintPrims&quot;),Xt(&quot;SelfPrims&quot;),Xt(&quot;SelfManager&quot;),Xt(&quot;UserDialogPrims&quot;),Xt(&quot;Updater&quot;),Xt(&quot;world&quot;),(new qt).cf(&quot;Exception&quot;,&quot;util/exception&quot;),(new qt).cf(&quot;NLMath&quot;,&quot;util/nlmath&quot;),(new qt).cf(&quot;notImplemented&quot;,&quot;util/notimplemented&quot;),
(new qt).cf(&quot;ColorModel&quot;,&quot;engine/core/colormodel&quot;),(new qt).cf(&quot;Link&quot;,&quot;engine/core/link&quot;),(new qt).cf(&quot;LinkSet&quot;,&quot;engine/core/linkset&quot;),(new qt).cf(&quot;PatchSet&quot;,&quot;engine/core/patchset&quot;),(new qt).cf(&quot;Turtle&quot;,&quot;engine/core/turtle&quot;),(new qt).cf(&quot;TurtleSet&quot;,&quot;engine/core/turtleset&quot;),(new qt).cf(&quot;NLType&quot;,&quot;engine/core/typechecker&quot;),(new qt).cf(&quot;Tasks&quot;,&quot;engine/prim/tasks&quot;),(new qt).cf(&quot;AgentModel&quot;,&quot;agentmodel&quot;),(new qt).cf(&quot;Meta&quot;,&quot;meta&quot;),(new qt).cf(&quot;Random&quot;,&quot;shim/random&quot;),(new qt).cf(&quot;StrictMath&quot;,&quot;shim/strictmath&quot;),
mga()]))}
function jga(a){var b=Rp(a.ec),d=Yt($e(),nga()),d=Zt(b,d),b=Qp(a.ec),e=Yt($e(),oga()),b=Zt(b,e);fd();var e=m(new n,function(){return function(a){return a.toLowerCase()}}(a)),f=r(),d=d.xa(e,f.s),e=m(new n,function(){return function(a){return ed(fd(),a)}}(a)),f=r(),d=es(0,d.xa(e,f.s),&quot; &quot;);fd();e=m(new n,function(){return function(a){return a.toLowerCase()}}(a));f=r();b=b.xa(e,f.s);a=m(new n,function(){return function(a){return ed(fd(),a)}}(a));e=r();a=es(0,b.xa(a,e.s),&quot; &quot;);return I(r(),(new w).f([a,d]))}
function Xt(a){var b=(new Sb).c(a),b=Ak(b),b=null===b?0:b.X,b=zfa(Uh(),b),b=(new af).Ra(b),d=(new Sb).c(a),b=&quot;&quot;+b+Sk(d);return(new rt).vk(a,u((new v).K((new w).f([&quot;workspace.&quot;,&quot;&quot;])),(new w).f([b])),I(r(),(new w).f([&quot;workspace&quot;])))}function fga(a){var b=Ic(a.Nq);return kd(b)?pga($t(),a):&quot;{}&quot;}function qga(a,b,d,e){var f=new Tt;f.ec=a;f.Gc=b;f.Sf=d;f.qV=e;return f}
function lga(a){var b=Dea(a.ec),d=Yt($e(),rga()),b=Zt(b,d);fd();var d=Pp(a.ec),e=m(new n,function(){return function(a){return a.toLowerCase()}}(a)),f=r(),d=d.xa(e,f.s),e=m(new n,function(){return function(a){return ed(fd(),a)}}(a)),f=r(),d=es(0,d.xa(e,f.s),&quot; &quot;);fd();var e=a.ec.Qj,f=m(new n,function(){return function(a){return a.toLowerCase()}}(a)),h=r(),e=e.xa(f,h.s),f=m(new n,function(){return function(a){return ed(fd(),a)}}(a)),h=r(),e=es(0,e.xa(f,h.s),&quot; &quot;);fd();f=m(new n,function(){return function(a){return a.toLowerCase()}}(a));
h=r();b=b.xa(f,h.s);f=m(new n,function(){return function(a){return ed(fd(),a)}}(a));h=r();b=es(0,b.xa(f,h.s),&quot; &quot;);f=sga(a.Sf);b=I(r(),(new w).f([d,e,b,tga(f),uga(f),vga(f),wga(f),xga(f),yga(f),zga(f),&quot;turtleShapes&quot;,&quot;linkShapes&quot;,a.qV]));a=m(new n,function(){return function(a){return na(a)}}(a));d=r();return b.xa(a,d.s)}
function iga(a){var b=(new Kc).fg(a.ec.bg),d=(new Kc).fg(a.ec.Hf),e=Lc().s,b=au(b,d,e);a=m(new n,function(a){return function(b){var d=ed(fd(),b.va),e=ed(fd(),b.Bf.toLowerCase());fd();var t=b.nl,x=m(new n,function(){return function(a){return a.toLowerCase()}}(a)),E=r(),t=t.xa(x,E.s),x=m(new n,function(){return function(a){return ed(fd(),a)}}(a)),E=r(),t=es(0,t.xa(x,E.s),&quot; &quot;);b=b.Kg?u((new v).K((new w).f([&quot;, isDirected: &quot;,&quot;&quot;])),(new w).f([b.Jg])):&quot;&quot;;return u((new v).K((new w).f([&quot;{ name: &quot;,&quot;, singular: &quot;,
&quot;, varNames: &quot;,&quot;&quot;,&quot; }&quot;])),(new w).f([d,e,t,b]))}}(a));d=Lc();a=b.xa(a,d.s).Hc();return es(fd(),a,&quot; &quot;)}Tt.prototype.$classData=g({y3:0},!1,&quot;org.nlogo.tortoise.compiler.RuntimeInit&quot;,{y3:1,d:1});function bu(){}bu.prototype=new l;bu.prototype.constructor=bu;
function Aga(a,b){var d=m(new n,function(){return function(a){return a.Bn()}}(a)),e=r(),d=b.xa(d,e.s),e=r(),d=d.De(b,e.s).te($e().Fk),e=m(new n,function(a){return function(b){var d=b.Qr();b=m(new n,function(a,b){return function(a){var d=b.Bn();return(new A).e(a,d)}}(a,b));var e=r();return d.xa(b,e.s)}}(a)),f=r();b=b.aj(e,f.s).ed();var e=Ic(d),f=m(new n,function(){return function(a){return cu(a).Me.pa()}}(a)),h=$l(),h=cm(h),f=Wr(b,f,h),e=Jc(e,f);b=Bga(a,I(r(),(new w).f([e])),b);a=m(new n,function(a,
b){return function(a){var d=$l(),d=cm(d);a=Wr(a,b,d).Hc();d=(new du).b();return Cga(a,d)}}(a,d));d=r();return b.aj(a,d.s)}bu.prototype.b=function(){return this};function Dga(a,b){var d=m(new n,function(){return function(a){return a.Bn()}}(a)),e=r(),d=b.xa(d,e.s);a=m(new n,function(){return function(a){return a.Qr()}}(a));e=r();b=b.aj(a,e.s).ed();d=d.ed();return Jc(b,d)}
function Ega(a,b){var d=Dga(a,b);if(d.z())return b=Aga(a,b),a=m(new n,function(){return function(a){return a.Hv()}}(a)),d=r(),b.xa(a,d.s).Oc(&quot;&quot;,&quot;\n&quot;,&quot;\n&quot;);throw(new df).c(u((new v).K((new w).f([&quot;Please provide the following dependencies: &quot;,&quot;&quot;])),(new w).f([cc(d,&quot;&quot;,&quot;, &quot;,&quot;&quot;)])));}
function Bga(a,b,d){for(;;)if(kd(d)){var e=eu(d,m(new n,function(a,b){return function(a){return b.gd().ib(cu(a).Me.la())}}(a,b)));if(null===e)throw(new q).j(e);var f=e.la(),e=e.pa(),h=m(new n,function(){return function(a){return cu(a).Me.pa()}}(a)),k=$l(),k=cm(k),f=Wr(f,h,k),h=m(new n,function(){return function(a){return cu(a).Me.pa()}}(a)),k=$l(),k=cm(k),f=f.Pk(Wr(e,h,k));if(kd(f))d=r(),b=b.mc(f,d.s),d=e;else throw e=d,a=m(new n,function(){return function(a){return u((new v).K((new w).f([&quot;from &quot;,
&quot; to &quot;,&quot;&quot;])),(new w).f([a.pa(),a.la()]))}}(a)),b=$l(),b=cm(b),a=Wr(e,a,b).zb(&quot;,\n&quot;),(new df).c(u((new v).K((new w).f([&quot;unable to satisfy dependencies: &quot;,&quot;&quot;])),(new w).f([a])));}else return b}bu.prototype.$classData=g({H3:0},!1,&quot;org.nlogo.tortoise.compiler.TortoiseLoader$&quot;,{H3:1,d:1});var fu=void 0;function gu(){this.Me=null}gu.prototype=new l;gu.prototype.constructor=gu;function cu(a){var b=new gu;b.Me=a;return b}
gu.prototype.$classData=g({I3:0},!1,&quot;org.nlogo.tortoise.compiler.TortoiseLoader$RichEdge$2&quot;,{I3:1,d:1});function hu(){this.vC=this.uC=null}hu.prototype=new l;hu.prototype.constructor=hu;
function Fga(a,b){if(iu(b)){fd();var d=b.Ya,d=qs(d.z()?&quot;&quot;:d.Y()),e=r(),f=(new A).e(&quot;setup&quot;,b.lg),e=I(e,(new w).f([f,(new A).e(&quot;update&quot;,b.ng)])),f=m(new n,function(a,b){return function(d){if(null!==d){var e=d.la();d=d.pa();ju();d=Gga(a,d,b,F());return ku(lu(d),&quot;plot&quot;,b,e)}throw(new q).j(d);}}(a,d)),h=r(),f=e.xa(f,h.s);r();e=(new J).j(f);if(null!==e.U&amp;&amp;0===e.U.Rb(2))f=e.U.W(0),e=e.U.W(1);else throw(new q).j(f);Gq();var h=tq(),h=(new Yq).gq(h),h=mu(h),k=(new sq).j(tb(new ub,function(a,b,d){return function(e,
f){var h=d.zn,k=function(a,b){return function(d){return Hga(a,b,d)}}(a,b),p=B().s;if(p===B().s)if(h===y())k=y();else{for(var p=h.$(),t=p=Cd(new Dd,k(p),y()),h=h.aa();h!==y();)var vb=h.$(),vb=Cd(new Dd,k(vb),y()),t=t.Ia=vb,h=h.aa();k=p}else{for(p=Mc(h,p);!h.z();)t=h.$(),p.Na(k(t)),h=h.aa();k=p.Da()}return(new nu).vk(e,f,k)}}(a,d,b))),h=a=h.Ym,k=(new A).e(f,(new sq).j(sb(k.ha)));a:{var p=k.kb,t=k.Ab;if(nq(p)&amp;&amp;(p=p.ha,nq(t))){f=(new sq).j(t.ha.y(p));break a}t=k.kb;p=k.Ab;if(pq(t)&amp;&amp;nq(p))f=t;else if(t=
k.Ab,nq(k.kb)&amp;&amp;pq(t))f=t;else{p=k.kb;t=k.Ab;if(pq(p)&amp;&amp;(p=p.cc,pq(t))){f=(new qq).j(h.Xb(t.cc,K(function(a,b){return function(){return b}}(f,p))));break a}throw(new q).j(k);}}f=(new A).e(e,f);a:{k=f.kb;h=f.Ab;if(nq(k)&amp;&amp;(k=k.ha,nq(h))){e=(new sq).j(h.ha.y(k));break a}h=f.kb;k=f.Ab;if(pq(h)&amp;&amp;nq(k))e=h;else if(h=f.Ab,nq(f.kb)&amp;&amp;pq(h))e=h;else{k=f.kb;h=f.Ab;if(pq(k)&amp;&amp;(k=k.cc,pq(h))){e=(new qq).j(a.Xb(h.cc,K(function(a,b){return function(){return b}}(e,k))));break a}throw(new q).j(f);}}return Iga(b,d,e)}if(ou(b))return(new pu).ju(b,
Jga(a,b));if(qu(b))return(new pu).ju(b,Kga(a,b));if(ru(b))return(new pu).ju(b,Lga(a,b));Pq();d=Mga();return(new pu).ju(b,Vq().y(d))}
function Lga(a,b){var d=r(),e=(new A).e(&quot;min&quot;,b.sn),f=(new A).e(&quot;max&quot;,b.em),d=I(d,(new w).f([e,f,(new A).e(&quot;step&quot;,b.vm)]));b=jaa(tb(new ub,function(a,b){return function(d,e){ju();e=a.vC.y(e);var f=b.Ya;return ku(lu(e),&quot;slider&quot;,f.z()?b.Ys():f.Y(),d)}}(a,b)));e=r();b=d.xa(b,e.s);r();d=(new J).j(b);if(null!==d.U&amp;&amp;0===d.U.Rb(3))f=d.U.W(0),b=d.U.W(1),e=d.U.W(2);else throw(new q).j(b);d=b;b=e;Gq();var e=tq(),e=(new Yq).gq(e),e=mu(e),h=K(function(a,b){return function(){return b}}(a,f)),f=(new sq).j(tb(new ub,
function(a,b){return function(a,d){var e=a.la();a=a.pa();return(0,b.vi)(e,a,d)}}(e,su(function(){return function(a,b,d){var e=new tu;e.Hr=a;e.Gr=b;e.Lr=d;return e}}(a)))));a=e.Ym;var k=(new sq).j(tb(new ub,function(){return function(a,b){return(new A).e(a,b)}}(e))),d=Nga(d,K(function(a,b,d){return function(){return a.$e(b,K(function(a,b){return function(){return a.Xc(b,m(new n,function(){return function(a){return sb(a)}}(a)))}}(a,d)))}}(e,h,k)),e.Ym),e=e.Ym,f=(new A).e(d,(new sq).j(sb(f.ha)));a:{k=
f.kb;h=f.Ab;if(nq(k)&amp;&amp;(k=k.ha,nq(h))){d=(new sq).j(h.ha.y(k));break a}h=f.kb;k=f.Ab;if(pq(h)&amp;&amp;nq(k))d=h;else if(h=f.Ab,nq(f.kb)&amp;&amp;pq(h))d=h;else{k=f.kb;h=f.Ab;if(pq(k)&amp;&amp;(k=k.cc,pq(h))){d=(new qq).j(e.Xb(h.cc,K(function(a,b){return function(){return b}}(d,k))));break a}throw(new q).j(f);}}d=(new A).e(b,d);f=d.kb;e=d.Ab;if(nq(f)&amp;&amp;(f=f.ha,nq(e)))return(new sq).j(e.ha.y(f));e=d.kb;f=d.Ab;if(pq(e)&amp;&amp;nq(f))return e;e=d.Ab;if(nq(d.kb)&amp;&amp;pq(e))return e;f=d.kb;e=d.Ab;if(pq(f)&amp;&amp;(f=f.cc,pq(e)))return(new qq).j(a.Xb(e.cc,
K(function(a,b){return function(){return b}}(b,f))));throw(new q).j(d);}
function Hga(a,b,d){var e=r(),f=(new A).e(&quot;setup&quot;,d.lg),e=I(e,(new w).f([f,(new A).e(&quot;update&quot;,d.ng)]));b=m(new n,function(a,b,d){return function(e){if(null!==e){var f=e.la();e=e.pa();ju();e=Gga(a,e,b,jd().Uc(d.Ya));e=lu(e);var h=jd().Uc(d.Ya);return ku(e,&quot;pen&quot;,h.z()?&quot;&quot;:h.Y(),f)}throw(new q).j(e);}}(a,b,d));f=r();e=e.xa(b,f.s);r();b=(new J).j(e);if(null!==b.U&amp;&amp;0===b.U.Rb(2))e=b.U.W(0),b=b.U.W(1);else throw(new q).j(e);Gq();var f=tq(),f=(new Yq).gq(f),f=mu(f),h=(new sq).j(tb(new ub,function(){return function(a,
b){return(new uu).cf(a,b)}}(a))),f=a=f.Ym,h=(new A).e(e,(new sq).j(sb(h.ha)));a:{var k=h.kb,p=h.Ab;if(nq(k)&amp;&amp;(k=k.ha,nq(p))){e=(new sq).j(p.ha.y(k));break a}p=h.kb;k=h.Ab;if(pq(p)&amp;&amp;nq(k))e=p;else if(p=h.Ab,nq(h.kb)&amp;&amp;pq(p))e=p;else{k=h.kb;p=h.Ab;if(pq(k)&amp;&amp;(k=k.cc,pq(p))){e=(new qq).j(f.Xb(p.cc,K(function(a,b){return function(){return b}}(e,k))));break a}throw(new q).j(h);}}e=(new A).e(b,e);a:{h=e.kb;f=e.Ab;if(nq(h)&amp;&amp;(h=h.ha,nq(f))){b=(new sq).j(f.ha.y(h));break a}f=e.kb;h=e.Ab;if(pq(f)&amp;&amp;nq(h))b=f;
else if(f=e.Ab,nq(e.kb)&amp;&amp;pq(f))b=f;else{h=e.kb;f=e.Ab;if(pq(h)&amp;&amp;(h=h.cc,pq(f))){b=(new qq).j(a.Xb(f.cc,K(function(a,b){return function(){return b}}(b,h))));break a}throw(new q).j(e);}}return Oga(d,b)}hu.prototype.Zm=function(a){throw(new df).c(u((new v).K((new w).f([&quot;This type of agent cannot be asked: &quot;,&quot;&quot;])),(new w).f([a])));};
function Jga(a,b){ju();var d=a.uC,e=b.Pm.k().toUpperCase(),f=b.uc;a=d.y(Pga(a,e,f.z()?&quot;&quot;:f.Y()).split(&quot;\\n&quot;).join(&quot;\n&quot;).split(&quot;\\\\&quot;).join(&quot;\\&quot;).split('\\&quot;').join('&quot;'));a=lu(a);d=b.Ya;b=d.z()?b.uc:d;b=ku(a,&quot;button&quot;,b.z()?&quot;&quot;:b.Y(),&quot;source&quot;);if(nq(b))return(new sq).j((new vu).c(b.ha));if(pq(b))return b;throw(new q).j(b);}
function Gga(a,b,d,e){e.z()?e=F():(e=e.Y(),e=(new J).j(u((new v).K((new w).f([&quot;'&quot;,&quot;'&quot;])),(new w).f([e]))));e=e.z()?&quot;undefined&quot;:e.Y();var f=b.trim();if(null===f)throw(new Oe).b();if(&quot;&quot;===f)return Pq(),d=ps(fd(),&quot;&quot;),Vq().y(d);a=a.uC.y(b);if(nq(a))a=a.ha,a=(new sq).j(ps(fd(),a));else if(!pq(a))throw(new q).j(a);if(nq(a))a=a.ha,d=u((new v).K((new w).f([&quot;plotManager.withTemporaryContext('&quot;,&quot;', &quot;,&quot;)(&quot;,&quot;)&quot;])),(new w).f([d,e,a])),d=(new sq).j(ps(fd(),d));else{if(!pq(a))throw(new q).j(a);d=a}if(nq(d))return d=
d.ha,d=u((new v).K((new w).f([&quot;workspace.rng.withAux(&quot;,&quot;)&quot;])),(new w).f([d])),(new sq).j(ps(fd(),d));if(pq(d))return d;throw(new q).j(d);}
function Pga(a,b,d){for(var e=(new A).e(&quot;OBSERVER&quot;,m(new n,function(){return function(a){return a}}(a))),f=(new A).e(&quot;TURTLE&quot;,m(new n,function(){return function(a){return wu(&quot;turtles&quot;,a)}}(a))),h=(new A).e(&quot;PATCH&quot;,m(new n,function(){return function(a){return wu(&quot;patches&quot;,a)}}(a))),e=[e,f,h,(new A).e(&quot;LINK&quot;,m(new n,function(){return function(a){return wu(&quot;links&quot;,a)}}(a)))],f=dc(new ec,gc()),h=0,k=e.length|0;h&lt;k;)hc(f,e[h]),h=1+h|0;e=f.Ma.dc(b);if(!Vk(e))throw F()===e&amp;&amp;a.Zm(b),(new q).j(e);return e.U.y(d)}
function Qga(a,b){b=b.al(m(new n,function(){return function(a){return iu(a)}}(a)),!1);b=Rga(b,m(new n,function(){return function(a){if(iu(a))return a.Ya;throw(new q).j(a);}}(a))).Pf(m(new n,function(){return function(a){return 1&lt;a.pa().Ga()}}(a)));if(kd(b)){a=(new v).K((new w).f([&quot;Having multiple plots with same display name is not supported. Duplicate names detected: &quot;,&quot;&quot;]));b=Ic(b);a=u(a,(new w).f([cc(b,&quot;&quot;,&quot;, &quot;,&quot;&quot;)]));b=Nm().ra.Xa;var d=Nm().ra.Va,e=Nm();throw(new hd).ms(a,b,d,e.ra.ab);}}
function Kga(a,b){ju();var d=b.uc;a=a.vC.y(d.z()?&quot;&quot;:d.Y());a=lu(a);d=b.Ya;b=d.z()?b.uc:d;b=ku(a,&quot;monitor&quot;,b.z()?&quot;&quot;:b.Y(),&quot;reporter&quot;);if(nq(b))return(new sq).j((new vu).c(b.ha));if(pq(b))return b;throw(new q).j(b);}function wu(a,b){return u((new v).K((new w).f([&quot;ask &quot;,&quot; [ &quot;,&quot; ]&quot;])),(new w).f([a,b]))}function Sga(a,b){var d=new hu;d.uC=a;d.vC=b;return d}function Tga(a,b){Qga(a,b);a=m(new n,function(a){return function(b){return Fga(a,b)}}(a));var d=r();return b.xa(a,d.s)}
hu.prototype.$classData=g({U3:0},!1,&quot;org.nlogo.tortoise.compiler.WidgetCompiler&quot;,{U3:1,d:1});function xu(){this.eY=this.dV=null;this.a=0}xu.prototype=new l;xu.prototype.constructor=xu;
xu.prototype.b=function(){yu=this;for(var a=[(new A).e(&quot;compiledSource&quot;,&quot;reporter&quot;)],b=dc(new ec,gc()),d=0,e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.dV=b.Ma;this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;a=[(new A).e(&quot;compiledMin&quot;,&quot;getMin&quot;),(new A).e(&quot;compiledMax&quot;,&quot;getMax&quot;),(new A).e(&quot;compiledStep&quot;,&quot;getStep&quot;)];b=dc(new ec,gc());d=0;for(e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.eY=b.Ma;this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;return this};
function Uga(a,b){fd();a=m(new n,function(a){return function(b){return Vga(a,b).JF()}}(a));var d=r();return es(0,b.xa(a,d.s),&quot;\n&quot;)}
function Vga(a,b){var d=Afa((new ls).K(y()),kga(b).Ye());if(null!==b){var e=b.pp;if(qu(b.Ni)&amp;&amp;nq(e)&amp;&amp;(e=e.ha,zu(e)))return a=tb(new ub,function(a){return function(b,d){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/WidgetCompiler.scala: 141&quot;);return Wga(a.dV,b,d)}}(a)),e.wC().Gb(d,a)}return null!==b&amp;&amp;(e=b.pp,ru(b.Ni)&amp;&amp;nq(e)&amp;&amp;(b=e.ha,Au(b)))?(a=tb(new ub,function(a){return function(b,d){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/WidgetCompiler.scala: 144&quot;);
return Wga(a.eY,b,d)}}(a)),b.wC().Gb(d,a)):d}function Wga(a,b,d){if(null!==d){var e=d.pa();a=a.y(d.la());e=(new Bu).su(I(r(),y()),I(r(),(new w).f([u((new v).K((new w).f([&quot;return &quot;,&quot;;&quot;])),(new w).f([e]))])));e=(new A).e(a,e);b=b.gh;a=r();return(new ls).K(b.fd(e,a.s))}throw(new q).j(d);}xu.prototype.$classData=g({V3:0},!1,&quot;org.nlogo.tortoise.compiler.WidgetCompiler$&quot;,{V3:1,d:1});var yu=void 0;function ju(){yu||(yu=(new xu).b());return yu}function Cu(){this.IY=null}Cu.prototype=new l;
Cu.prototype.constructor=Cu;function ku(a,b,d,e){b=u((new v).K((new w).f([&quot;&quot;,&quot; '&quot;,&quot;' - &quot;,&quot;.&quot;,&quot;&quot;])),(new w).f([b,d,b,e]));d=a.IY;if(nq(d))return d;if(pq(d)){d=d.cc;a=function(a,b){return function(a){return(new $r).c(u((new v).K((new w).f([&quot;&quot;,&quot;: &quot;,&quot;&quot;])),(new w).f([b,a.Fh()])))}}(a,b);tq();b=a(d.Fc);d=d.Mc;e=uq().Vd;d=vq(d);a:for(;;){if(!wq(d)){if(xq(d)){var f=d;d=f.dd;f=a(f.$c);e=(new yq).Qb(f,e);continue a}throw(new q).j(d);}break}return(new qq).j((new zq).Qb(b,e))}throw(new q).j(d);}
function lu(a){var b=new Cu;b.IY=a;return b}Cu.prototype.$classData=g({W3:0},!1,&quot;org.nlogo.tortoise.compiler.WidgetCompiler$ValidationContextualizer&quot;,{W3:1,d:1});function Du(){}Du.prototype=new l;Du.prototype.constructor=Du;Du.prototype.b=function(){return this};Du.prototype.$classData=g({X3:0},!1,&quot;org.nlogo.tortoise.compiler.json.ElemToJsonConverters$&quot;,{X3:1,d:1});var Eu=void 0;function Fu(){this.dv=null;this.ya=!1}Fu.prototype=new l;Fu.prototype.constructor=Fu;Fu.prototype.b=function(){return this};
Fu.prototype.yE=function(){if(!this.ya&amp;&amp;!this.ya){var a=(new Ne).b();if(a.La)a=a.hb;else{if(null===a)throw(new Oe).b();a=a.La?a.hb:Pe(a,(new Gu).b())}var a=(new A).e(&quot;line&quot;,a),b=(new Ne).b();if(b.La)b=b.hb;else{if(null===b)throw(new Oe).b();b=b.La?b.hb:Pe(b,(new Hu).b())}var b=(new A).e(&quot;circle&quot;,b),d=(new Ne).b();if(d.La)d=d.hb;else{if(null===d)throw(new Oe).b();d=d.La?d.hb:Pe(d,(new Iu).b())}var d=(new A).e(&quot;rectangle&quot;,d),e=(new Ne).b();if(e.La)e=e.hb;else{if(null===e)throw(new Oe).b();e=e.La?e.hb:
Pe(e,(new Ju).b())}a=[a,b,d,(new A).e(&quot;polygon&quot;,e)];b=dc(new ec,gc());d=0;for(e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.dv=b.Ma;this.ya=!0}return this.dv};Fu.prototype.$classData=g({c4:0},!1,&quot;org.nlogo.tortoise.compiler.json.ElementReader$&quot;,{c4:1,d:1});var Ku=void 0;function Lu(a){return(new Mu).$b(zc(a.Np().Pg,a.Ep().Pg))}function Xga(){var a=y();return(new Mu).$b(nh(oh(),a))}function Nu(){}Nu.prototype=new l;Nu.prototype.constructor=Nu;Nu.prototype.b=function(){return this};
function pd(a,b){return ba.JSON.stringify(b)}
function Dq(a,b){var d=(new A).e(b,typeof b);if(null===d.kb)return Ou();var e=d.Ab;if(&quot;undefined&quot;===e||&quot;function&quot;===e)return Ou();e=d.kb;if(&quot;number&quot;===d.Ab)return a=+e,Pu(Qu(),a)?(new Ru).Db(Na(a)):(new Su).tk(a);e=d.kb;if(&quot;string&quot;===d.Ab)return(new Tu).c(e);e=d.kb;if(&quot;boolean&quot;===d.Ab)return(new Uu).td(!!e);var e=d.kb,f=d.Ab;if(e instanceof ba.Array&amp;&amp;&quot;object&quot;===f&amp;&amp;ba.Array.isArray(e)){b=[];d=0;for(f=e.length|0;d&lt;f;){var h=Dq(a,e[d]);b.push(h);d=1+d|0}a=B().s.Uh();d=b.length|0;switch(d){case -1:break;
default:a.tc(d)}a.Yb((new w).f(b));return(new Vu).K(a.Da())}if(&quot;object&quot;===d.Ab){e=ba.Object.keys(b);Lc();Zn();d=[];f=0;for(h=e.length|0;f&lt;h;){var k=e[f];if(!Wu().qm.call(b,k))throw(new Xu).c(&quot;key not found: &quot;+k);var p=Dq(a,b[k]),k=(new A).e(k,p);d.push(k);f=1+f|0}a=dc(new ec,Yu());b=0;for(e=d.length|0;b&lt;e;)hc(a,d[b]),b=1+b|0;return(new Mu).$b(a.Ma)}throw(new q).j(d);}
function rd(a,b){if(Ou()===b)return null;if(Zu(b))return b.ai;if($u(b))return b.Rl;if(av(b))return b.Kc;if(bv(b))return b.Ll;if(cv(b)){var d=b.Ma;b=Lg();a=m(new n,function(a){return function(b){return rd(a,b)}}(a));var e=r();a=d.xa(a,e.s);if(dv(a))return a.Wd;if(ev(a))return a.oa;d=[];a.wa(m(new n,function(a,b){return function(a){return b.push(a)|0}}(b,d)));return d}if(fv(b))return d=b.Pg,gv||(gv=(new hv).b()),b=gv,a=(new iv).Ax(d,m(new n,function(a){return function(b){return rd(a,b)}}(a))),Yga(b,
ms(a));throw(new q).j(b);}Nu.prototype.$classData=g({j4:0},!1,&quot;org.nlogo.tortoise.compiler.json.JsonLibrary$&quot;,{j4:1,d:1});var jv=void 0;function qd(){jv||(jv=(new Nu).b());return jv}function Zga(a,b){Pq();a=u((new v).K((new w).f([&quot;could not convert &quot;,&quot; to &quot;,&quot;&quot;])),(new w).f([Uq(a),Uq(b)]));return Qq(Gq(),a)}
function kv(a,b,d){d=(new lv).Ha(d);mv();d=d.hX;if(Vk(d))b=(new sq).j(d.U);else{if(F()!==d)throw(new q).j(d);tq();b=u((new v).K((new w).f([&quot;could not find key &quot;,&quot;&quot;])),(new w).f([b]));d=[];var e=uq().Vd,f=d.length|0;a:for(;;){if(0!==f){e=(new yq).Qb(d[-1+f|0],e);f=-1+f|0;continue a}break}b=(new qq).j((new zq).Qb(b,e))}if(nq(b))return a.Za(b.ha);if(pq(b))return b;throw(new q).j(b);}function nv(){this.OW=this.YU=this.FU=null;this.a=0}nv.prototype=new l;nv.prototype.constructor=nv;
nv.prototype.b=function(){ov=this;this.FU=(new pv).b();this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;this.YU=(new qv).b();this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;this.OW=(new rv).b();this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;return this};function $ga(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/JsonSerializer.scala: 99&quot;);return a.YU}
function aha(a){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/JsonSerializer.scala: 90&quot;);return a.FU}function sv(a,b){return aha(a).kl($ga(a)).kl(bha(a)).db(b,m(new n,function(){return function(){return(new Tu).c(&quot;XXX IMPLEMENT ME&quot;)}}(a)))}function bha(a){if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/JsonSerializer.scala: 108&quot;);return a.OW}
function pga(a,b){return qb(m(new n,function(a){return function(b){return sv(a,b)}}(a)),m(new n,function(){return function(a){return rd(qd(),a)}}(a))).Ca(m(new n,function(){return function(a){return pd(qd(),a)}}(a))).y(b)}nv.prototype.$classData=g({l4:0},!1,&quot;org.nlogo.tortoise.compiler.json.JsonSerializer$&quot;,{l4:1,d:1});var ov=void 0;function $t(){ov||(ov=(new nv).b());return ov}function tv(a,b){return(new J).j(a.rc(b))}function uv(){this.VU=this.LY=null;this.a=0}uv.prototype=new l;
uv.prototype.constructor=uv;uv.prototype.b=function(){vv=this;this.LY=(new wv).b();this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;this.VU=(new xv).b();this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;return this};function cha(a,b){return fv(b)?(b=b.Pg,a=(new Tu).c(a),(new Mu).$b(b.Cm((new A).e(&quot;name&quot;,a)))):b}function yv(a,b){if(fv(b))return a=(new Ne).b(),(a.La?a.hb:dha(a)).cb(b);Pq();b=u((new v).K((new w).f([&quot;Expected shape as json object, got &quot;,&quot;&quot;])),(new w).f([b]));return Qq(Gq(),b)}
function dha(a){if(null===a)throw(new Oe).b();return a.La?a.hb:Pe(a,(new zv).b())}function eha(a,b){if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.BH)return fha(new Av,b);if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.zH)return gha(b);throw(new q).j(b);}function hha(a,b){if(fv(b)){var d=b.Pg;b=ul().s;b=Mc(d,b);d=Bv(d);for(d=Cv(d);d.ta();){var e=d.ma();if(null===e)throw(new q).j(e);b.Na(cha(e.la(),e.pa()))}return a.Za((new Vu).K(b.Da().Hc()))}return a.Za(b)}
uv.prototype.$classData=g({F4:0},!1,&quot;org.nlogo.tortoise.compiler.json.ShapeToJsonConverters$&quot;,{F4:1,d:1});var vv=void 0;function Dv(){vv||(vv=(new uv).b());return vv}function Ev(){this.va=null}Ev.prototype=new l;Ev.prototype.constructor=Ev;Ev.prototype.c=function(a){this.va=a;return this};Ev.prototype.$classData=g({S4:0},!1,&quot;org.nlogo.tortoise.compiler.json.TortoiseJson$JsField&quot;,{S4:1,d:1});function Fv(){this.dv=null;this.a=!1}Fv.prototype=new l;Fv.prototype.constructor=Fv;
Fv.prototype.b=function(){Gv=this;var a=(new Ne).b();if(a.La)a=a.hb;else{if(null===a)throw(new Oe).b();a=a.La?a.hb:Pe(a,(new Hv).b())}var a=(new A).e(&quot;button&quot;,a),b=(new Ne).b();if(b.La)b=b.hb;else{if(null===b)throw(new Oe).b();b=b.La?b.hb:Pe(b,(new Iv).b())}var b=(new A).e(&quot;chooser&quot;,b),d=(new Ne).b();if(d.La)d=d.hb;else{if(null===d)throw(new Oe).b();d=d.La?d.hb:Pe(d,(new Jv).b())}var d=(new A).e(&quot;inputBox&quot;,d),e=(new Ne).b();if(e.La)e=e.hb;else{if(null===e)throw(new Oe).b();e=e.La?e.hb:Pe(e,(new Kv).b())}var e=
(new A).e(&quot;monitor&quot;,e),f=(new Ne).b();if(f.La)f=f.hb;else{if(null===f)throw(new Oe).b();f=f.La?f.hb:Pe(f,(new Lv).b())}var f=(new A).e(&quot;output&quot;,f),h=(new Ne).b();if(h.La)h=h.hb;else{if(null===h)throw(new Oe).b();h=h.La?h.hb:Pe(h,(new Mv).b())}var h=(new A).e(&quot;plot&quot;,h),k=(new Ne).b();if(k.La)k=k.hb;else{if(null===k)throw(new Oe).b();k=k.La?k.hb:Pe(k,(new Nv).b())}var k=(new A).e(&quot;slider&quot;,k),p=(new Ne).b();if(p.La)p=p.hb;else{if(null===p)throw(new Oe).b();p=p.La?p.hb:Pe(p,(new Ov).b())}var p=(new A).e(&quot;switch&quot;,
p),t=(new Ne).b();if(t.La)t=t.hb;else{if(null===t)throw(new Oe).b();t=t.La?t.hb:Pe(t,(new Pv).b())}var t=(new A).e(&quot;textBox&quot;,t),x=(new Ne).b();if(x.La)x=x.hb;else{if(null===x)throw(new Oe).b();x=x.La?x.hb:Pe(x,(new Qv).b())}a=[a,b,d,e,f,h,k,p,t,(new A).e(&quot;view&quot;,x)];b=dc(new ec,gc());d=0;for(e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.dv=b.Ma;this.a=!0;return this};
Fv.prototype.yE=function(){if(!this.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/WidgetRead.scala: 174&quot;);return this.dv};Fv.prototype.$classData=g({V4:0},!1,&quot;org.nlogo.tortoise.compiler.json.WidgetRead$&quot;,{V4:1,d:1});var Gv=void 0;function Rv(){this.Lt=this.xV=null}Rv.prototype=new l;Rv.prototype.constructor=Rv;
Rv.prototype.b=function(){Sv=this;var a=[Tv().jz,Tv().hw];if(0===(a.length|0))a=Jh();else{for(var b=Kh(new Lh,Jh()),d=0,e=a.length|0;d&lt;e;)Mh(b,a[d]),d=1+d|0;a=b.Ma}this.xV=a;a=(new Uv).b();this.Lt=iha(a);return this};Rv.prototype.$classData=g({i6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$EventCounter$&quot;,{i6:1,d:1});var Sv=void 0;function Vv(){Sv||(Sv=(new Rv).b());return Sv}function Wv(){this.uE=null;this.az=!1;this.vE=this.yn=this.yV=this.Su=this.Tu=null}Wv.prototype=new l;
Wv.prototype.constructor=Wv;function jha(a,b,d){b.wa(m(new n,function(a,b){return function(a){a.ZX(!!b.checked)}}(a,d)));return!0}function kha(a,b,d){var e=b.jh(m(new n,function(){return function(a){return a.sy()}}(a)));a=!e&amp;&amp;b.le(m(new n,function(){return function(a){return a.sy()}}(a)));(d.indeterminate=a)||(d.checked=e);return!0}function Xv(a){return a?&quot;success&quot;:&quot;error&quot;}
function lha(a){a=Yv(a.yn.Eg,&quot;&quot;,&quot;warn&quot;);Zv($v(),a,&quot;There are new excluded tests in your project. You may wish to &quot;);aw($v(),a,&quot;?&quot;,&quot;Run all&quot;);Zv($v(),a,&quot; to rediscover all available tests.&quot;)}function mha(a,b,d){return function(a,b,d){return function(){return jha(a,b,d)}}(a,b,d)}
function bw(a){var b=Vv().Lt.KY().$f(cw())|0,b=u((new v).K((new w).f([&quot;Total: &quot;,&quot;&quot;])),(new w).f([b])),d;d=Tv().kr.MS();var e;e=[];for(var f=0,h=d.l.length;f&lt;h;){var k=d.l[f],k=u((new v).K((new w).f([&quot;&quot;,&quot;: &quot;,&quot;&quot;])),(new w).f([k,Vv().Lt.y(k)]));e.push(null===k?null:k);f=1+f|0}e=ka(Xa(qa),e);d=1+e.l.length|0;d=la(Xa(qa),[d]);d.l[0]=b;dw(Rf(),e,0,d,1,e.l.length);b=(new Fm).b();e=!0;js(b,&quot;&quot;);f=0;for(h=d.l.length;f&lt;h;)k=d.l[f],e?(ks(b,k),e=!1):(js(b,&quot;, &quot;),ks(b,k)),f=1+f|0;js(b,&quot;&quot;);b=b.vc.Zb;a.yn.AC.textContent=
a.az?b:&quot;Running... &quot;+b}function nha(a,b){b=(new ew).mu(a,b);a.Tu.uj(b);return b}function oha(a,b,d){return function(a,b,d){return function(){return kha(a,b,d)}}(a,b,d)}
function pha(a,b){var d=new Wv;d.uE=a;d.az=!1;Ec();d.Tu=(new w).b();Ec();d.Su=(new w).b();var e=ba.document.body;d.yV=fw($v(),e,&quot;&quot;,&quot;&quot;,&quot;div&quot;);var e=new gw,f=a.Ga();if(null===d)throw Kg(Lg(),null);e.ga=d;0===f?b=u((new v).K((new w).f([&quot;Total Test Suites: &quot;,&quot;&quot;])),(new w).f([b])):(f=b-f|0,b=u((new v).K((new w).f([&quot;Selected Test Suites &quot;,&quot; (Total: &quot;,&quot;)&quot;])),(new w).f([f,b])));e.Eg=(new hw).mu(d,b);iw(e.Eg);e.Eg.Wh.onclick=mha(d,d.Tu,e.Eg.Wh);e.AC=Yv(e.Eg,&quot;&quot;,&quot;info&quot;);e.CY=oha(d,d.Tu,e.Eg.Wh);d.yn=e;d.vE=
a.He()?qha(d):d.yn;bw(d);return d}Wv.prototype.HC=function(a){this.az=!0;a.TC().wa(m(new n,function(a){return function(d){Yv(a.yn.Eg,&quot;Test framework crashed during execution:&quot;,&quot;error&quot;);var e=a.yn;d=d.k();return Yv(e.Eg,d,&quot;error&quot;)}}(this)));this.yn.gx(!!a.dD(K(function(){return function(){return!1}}(this))));bw(this)};Wv.prototype.$classData=g({k6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$UI&quot;,{k6:1,d:1});function jw(){}jw.prototype=new l;jw.prototype.constructor=jw;jw.prototype.b=function(){return this};
function rha(a,b,d){a=fw($v(),b,&quot;&quot;,&quot;&quot;,&quot;input&quot;);a.setAttribute(&quot;type&quot;,&quot;checkbox&quot;);a.checked=d;return a}function fw(a,b,d,e,f){a=ba.document.createElement(f);f=(new Sb).c(d);kd(f)&amp;&amp;(a.className=d);d=(new Sb).c(e);kd(d)&amp;&amp;(a.textContent=e);b.appendChild(a);return a}function Zv(a,b,d){a=ba.document.createTextNode(d);b.appendChild(a);return a}function aw(a,b,d,e){a=fw($v(),b,&quot;&quot;,e,&quot;a&quot;);a.setAttribute(&quot;href&quot;,d);return a}
jw.prototype.$classData=g({s6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$dom$RichElement$&quot;,{s6:1,d:1});var kw=void 0;function $v(){kw||(kw=(new jw).b());return kw}function lw(){}lw.prototype=new l;lw.prototype.constructor=lw;lw.prototype.b=function(){return this};
function sha(a,b){b=(new mw).f(b);b=lf(new mf,b,0,b.Wd.length|0);a=nw(As(b).xa(m(new n,function(){return function(a){a=(new Sb).c(a);a=Ei(a,46);var b=a.l.length,f=0,h=ba;a:for(;;){if(f!==b){var k=a.l[f],h=void 0===h?void 0:h[k],f=1+f|0;continue a}a=h;break}a=void 0===a?void 0:new a;(new ow).b();a=void 0===a?void 0:ud(a)?a:void 0;return void 0===a?F():(new J).j(a)}}(a)),(Ng(),(new Og).b())),m(new n,function(){return function(a){return a.ub()}}(a)));return Uk(a)}
function tha(){var a;pw||(pw=(new lw).b());a=pw;for(var b=ba.definedTests,d=[],e=0,f=b.length|0;e&lt;f;){var h=b[e],h=qw(rw(),h);d.push(h);e=1+e|0}e=ba.testFrameworkNames;b=[];f=0;for(h=e.length|0;f&lt;h;){var k=sha(a,e[f]).ub();if(null!==k)a:for(;;){if(kd(k)){var p=k.$();b.push(p);k=k.aa();continue a}break}else for(;!k.z();)p=k.$(),b.push(p),k=k.aa();f=1+f|0}e=B().s.Uh();f=b.length|0;switch(f){case -1:break;default:e.tc(f)}e.Yb((new w).f(b));b=e.Da();a=function(a,b){return function(a){for(var d=uha(),
e=[],f=0,h=b.length|0;f&lt;h;){for(var k=b[f],p=k,t=0;;){var vb;if(vb=t&lt;d.l.length){vb=d.l[t];var pb=p.rp;vb=!1===(sw(vb)&amp;&amp;sw(pb)?vb.Cu()===pb.Cu()&amp;&amp;vb.Av()===pb.Av():tw(vb)&amp;&amp;tw(pb)?vb.kq===pb.kq&amp;&amp;vb.Ow===pb.Ow:!1)}if(vb)t=1+t|0;else break}t!==d.l.length!==!1&amp;&amp;e.push(k);f=1+f|0}return(new A).e(a,(new w).f(e))}}(a,d);d=B().s;if(d===B().s){if(b===y())return y();d=b.$();e=d=Cd(new Dd,a(d),y());for(b=b.aa();b!==y();)f=b.$(),f=Cd(new Dd,a(f),y()),e=e.Ia=f,b=b.aa();return d}for(d=Mc(b,d);!b.z();)e=b.$(),d.Na(a(e)),
b=b.aa();return d.Da()}lw.prototype.$classData=g({t6:0},!1,&quot;org.scalajs.testinterface.TestDetector$&quot;,{t6:1,d:1});var pw=void 0;function uw(){}uw.prototype=new l;uw.prototype.constructor=uw;uw.prototype.b=function(){return this};function vha(a,b){if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.LQ)b=b.jV;else throw(new df).c(&quot;Need a ScalaJSClassLoader.&quot;);a:{a=(new Sb).c(a);a=Ei(a,46);var d=a.l.length,e=0;for(;;){if(e===d)break a;b=b[a.l[e]];e=1+e|0}}return b()}
uw.prototype.$classData=g({v6:0},!1,&quot;org.scalajs.testinterface.TestUtils$&quot;,{v6:1,d:1});var wha=void 0;function vw(){this.cu=null}vw.prototype=new l;vw.prototype.constructor=vw;function ww(){}ww.prototype=vw.prototype;function xha(a){ba.scalajsCom.init(function(a){return function(d){yha(a,d)}}(a))}
function yw(a){var b=!1,d=null;a:{if(zw(a)&amp;&amp;(b=!0,d=a,void 0===d.U)){ba.scalajsCom.send(&quot;ok:&quot;);break a}if(b)ba.scalajsCom.send(&quot;ok:&quot;+d.U);else if(Aw(a))a=a.rk,a=ba.JSON.stringify(Bw(Cw(),a)),ba.scalajsCom.send(&quot;fail:&quot;+a);else throw(new q).j(a);}}vw.prototype.c=function(a){this.cu=zha(Aha(),a);return this};
function Bha(a){var b;b=[];for(var d=0,e=a.l.length;d&lt;e;){var f=a.l[d],h=f.Dv,h=ba.JSON.stringify(Cha(rw(),h)),f=Cha(rw(),f.Dv),k,p=y();k=wn(p);k=la(Xa(qa),[k]);var t;t=0;for(p=Cv(p);p.ta();){var x=p.ma();k.l[t]=x;t=1+t|0}k=Dw($e(),k);if(dv(k))k=k.Wd;else if(ev(k))k=k.oa;else{t=[];p=0;for(x=k.sa();p&lt;x;){var E=k.W(p);t.push(E)|0;p=1+p|0}k=t}h={serializedTask:h,taskDef:f,tags:k};b.push(null===h?null:h);d=1+d|0}a=ka(Xa(Dha),b);a=Dw($e(),a);if(dv(a))return a.Wd;if(ev(a))return a.oa;b=[];d=0;for(e=a.sa();d&lt;
e;)h=a.W(d),b.push(h)|0,d=1+d|0;return b}function yha(a,b){var d=Ew(Ia(),b,58),e=-1===d?b:b.substring(0,d);try{a.UT(e,K(function(a,b,d,e){return function(){if(-1===d)throw(new df).c(u((new v).K((new w).f([&quot;&quot;,&quot; needs args&quot;])),(new w).f([e])));return b.substring(1+d|0)}}(a,b,d,e)))}catch(f){if(a=ko(Lg(),f),null!==a){b=Fw(Gw(),a);if(b.z())throw Kg(Lg(),a);a=b.Y();a=ba.JSON.stringify(Bw(Cw(),a));ba.scalajsCom.send(&quot;bad:&quot;+a)}else throw f;}}vw.prototype.init=function(){xha(this)};function Hw(){}
Hw.prototype=new l;Hw.prototype.constructor=Hw;Hw.prototype.b=function(){return this};Hw.prototype.$classData=g({x6:0},!1,&quot;org.scalajs.testinterface.internal.EventSerializer$&quot;,{x6:1,d:1});var Eha=void 0;function Iw(){}Iw.prototype=new l;Iw.prototype.constructor=Iw;Iw.prototype.b=function(){return this};
function Jw(a,b){if(tw(b))return{fpType:&quot;AnnotatedFingerprint&quot;,isModule:b.kq,annotationName:b.Ow};if(sw(b))return{fpType:&quot;SubclassFingerprint&quot;,isModule:b.Cu(),superclassName:b.Av(),requireNoArgConstructor:b.BE()};throw(new df).c(u((new v).K((new w).f([&quot;Unknown Fingerprint type: &quot;,&quot;&quot;])),(new w).f([oa(b)])));}Iw.prototype.$classData=g({y6:0},!1,&quot;org.scalajs.testinterface.internal.FingerprintSerializer$&quot;,{y6:1,d:1});var Kw=void 0;function Lw(){Kw||(Kw=(new Iw).b());return Kw}function Mw(){}
Mw.prototype=new l;Mw.prototype.constructor=Mw;Mw.prototype.b=function(){return this};function zha(a,b){a=aa.exportsNamespace;b=(new Sb).c(b);b=Ei(b,46);var d=b.l.length,e=0;a:for(;;){if(e!==d){a=a[b.l[e]];e=1+e|0;continue a}break}return new a}Mw.prototype.$classData=g({B6:0},!1,&quot;org.scalajs.testinterface.internal.FrameworkLoader$&quot;,{B6:1,d:1});var Nw=void 0;function Aha(){Nw||(Nw=(new Mw).b());return Nw}function Ow(){this.MT=null}Ow.prototype=new l;Ow.prototype.constructor=Ow;
function Fha(a){a=uha(zha(Aha(),a.MT));var b;b=[];for(var d=0,e=a.l.length;d&lt;e;){var f=a.l[d],f=Jw(Lw(),f);b.push(null===f?null:f);d=1+d|0}a=ka(Xa(Pw),b);a=Dw($e(),a);if(dv(a))a=a.Wd;else if(ev(a))a=a.oa;else{b=[];d=0;for(e=a.sa();d&lt;e;)f=a.W(d),b.push(f)|0,d=1+d|0;a=b}ba.scalajsCom.send(ba.JSON.stringify({name:&quot;utest&quot;,fingerprints:a}))}function Gha(a){ba.scalajsCom.init(function(){return function(){}}(a));Fha(a);ba.scalajsCom.close()}Ow.prototype.c=function(a){this.MT=a;return this};
Ow.prototype.initAndSend=function(){Gha(this)};Ow.prototype.$classData=g({C6:0},!1,&quot;org.scalajs.testinterface.internal.InfoSender&quot;,{C6:1,d:1});function Qw(){}Qw.prototype=new l;Qw.prototype.constructor=Qw;Qw.prototype.b=function(){return this};
function Hha(a,b){if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.CB)return{selType:&quot;SuiteSelector&quot;};if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.DB)return{selType:&quot;TestSelector&quot;,testName:b.xj};if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.zB)return{selType:&quot;NestedSuiteSelector&quot;,suiteId:b.wj};if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.AB)return{selType:&quot;NestedTestSelector&quot;,suiteId:b.wj,testName:b.xj};if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.EB)return{selType:&quot;TestWildcardSelector&quot;,testWildcard:b.jr};throw(new df).c(u((new v).K((new w).f([&quot;Unknown Selector type: &quot;,
&quot;&quot;])),(new w).f([oa(b)])));}function Iha(a,b){a=b.selType;if(&quot;SuiteSelector&quot;===a)return(new Rw).b();if(&quot;TestSelector&quot;===a)return(new Sw).c(b.testName);if(&quot;NestedSuiteSelector&quot;===a)return(new Tw).c(b.suiteId);if(&quot;NestedTestSelector&quot;===a)return(new Uw).cf(b.suiteId,b.testName);if(&quot;TestWildcardSelector&quot;===a)return(new Vw).c(b.testWildcard);throw(new df).c(u((new v).K((new w).f([&quot;Unknown Selector type: &quot;,&quot;&quot;])),(new w).f([a])));}
Qw.prototype.$classData=g({E6:0},!1,&quot;org.scalajs.testinterface.internal.SelectorSerializer$&quot;,{E6:1,d:1});var Ww=void 0;function Xw(){Ww||(Ww=(new Qw).b());return Ww}function Yw(){this.Uy=!1;this.ga=null}Yw.prototype=new l;Yw.prototype.constructor=Yw;function Zw(){}Zw.prototype=Yw.prototype;function Jha(a){if(!a.Uy)throw(new ye).c(u((new v).K((new w).f([&quot;&quot;,&quot; has been invalidated&quot;])),(new w).f([a])));}Yw.prototype.yx=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;this.Uy=!0;return this};
function $w(){}$w.prototype=new l;$w.prototype.constructor=$w;$w.prototype.b=function(){return this};
function qw(a,b){a=b.selectors;for(var d=[],e=0,f=a.length|0;e&lt;f;){var h=a[e],h=Iha(Xw(),h);d.push(h);e=1+e|0}a=d.length|0;a=la(Xa(Kha),[a]);for(var h=a.l.length,f=e=0,k=d.length|0,h=k&lt;h?k:h,k=a.l.length,h=h&lt;k?h:k;e&lt;h;)a.l[f]=d[e],e=1+e|0,f=1+f|0;d=new ax;e=b.fullyQualifiedName;Lw();f=b.fingerprint;h=f.fpType;if(&quot;AnnotatedFingerprint&quot;===h)h=f.annotationName,k=new bx,k.kq=!!f.isModule,k.Ow=h,f=k;else if(&quot;SubclassFingerprint&quot;===h){var h=f.superclassName,k=!!f.requireNoArgConstructor,p=new fx;p.kq=!!f.isModule;
p.lY=h;p.bW=k;f=p}else throw(new df).c(u((new v).K((new w).f([&quot;Unknown Fingerprint type: &quot;,&quot;&quot;])),(new w).f([h])));b=!!b.explicitlySpecified;d.ik=e;d.rp=f;d.hr=b;d.ir=a;if(null===e)throw(new Oe).c(&quot;fullyQualifiedName was null&quot;);if(null===f)throw(new Oe).c(&quot;fingerprint was null&quot;);if(null===a)throw(new Oe).c(&quot;selectors was null&quot;);return d}
function Cha(a,b){a=b.ik;var d=Jw(Lw(),b.rp),e=b.hr;b=b.ir;var f;f=[];for(var h=0,k=b.l.length;h&lt;k;){var p=b.l[h],p=Hha(Xw(),p);f.push(null===p?null:p);h=1+h|0}b=ka(Xa(Pw),f);b=Dw($e(),b);if(dv(b))b=b.Wd;else if(ev(b))b=b.oa;else{f=[];h=0;for(k=b.sa();h&lt;k;)p=b.W(h),f.push(p)|0,h=1+h|0;b=f}return{fullyQualifiedName:a,fingerprint:d,explicitlySpecified:e,selectors:b}}$w.prototype.$classData=g({J6:0},!1,&quot;org.scalajs.testinterface.internal.TaskDefSerializer$&quot;,{J6:1,d:1});var gx=void 0;
function rw(){gx||(gx=(new $w).b());return gx}function hx(){}hx.prototype=new l;hx.prototype.constructor=hx;hx.prototype.b=function(){return this};
function Bw(a,b){var d=oa(b).k(),e=b.Fh(),f=b.k(),h=ix(b),k;k=[];for(var p=0,t=h.l.length;p&lt;t;){var x;x=h.l[p];x={className:x.xo,methodName:x.xs,fileName:x.Zr,lineNumber:x.vs};k.push(null===x?null:x);p=1+p|0}h=ka(Xa(Pw),k);h=Dw($e(),h);if(dv(h))h=h.Wd;else if(ev(h))h=h.oa;else{k=[];p=0;for(t=h.sa();p&lt;t;)x=h.W(p),k.push(x)|0,p=1+p|0;h=k}d={&quot;class&quot;:d,message:e,toString:f,stackTrace:h};null!==b.Me&amp;&amp;(d.cause=Bw(a,b.Me));return d}
hx.prototype.$classData=g({K6:0},!1,&quot;org.scalajs.testinterface.internal.ThrowableSerializer$&quot;,{K6:1,d:1});var jx=void 0;function Cw(){jx||(jx=(new hx).b());return jx}function Ur(a,b){if(kx(a))return b.Ck(a.X);if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.xB)return lx(),a=mx(nx(),Ee(a.Eo)),ox(0,a);throw(new q).j(a);}var Lha=g({eo:0},!0,&quot;play.api.libs.json.JsValue&quot;,{eo:1,Im:1});function px(){}px.prototype=new l;px.prototype.constructor=px;px.prototype.b=function(){return this};
function qx(a){var b=Mha();return rx(b,a,!1,0,m(new n,function(){return function(){return&quot;&quot;}}(b)),!1,&quot;:&quot;,(new ac).ae(&quot;[&quot;,&quot;,&quot;,&quot;]&quot;))}
function sx(a,b){if(null===b)return Nha();if(Qg(b))return(new tx).c(b);if(&quot;number&quot;===typeof b){var d=+b;a=ux();return vx(new wx,xx(d,a.Hj))}if(xa(b))return d=+b,a=ux(),vx(new wx,xx(d,a.Hj));if(Pa(b))return d=b|0,a=ux(),vx(new wx,yx(a,d,a.Hj));if(Ca(b))return a=Qa(b),d=a.ka,a=a.qa,b=ux(),vx(new wx,Oha(b,(new Vb).ia(d,a)));if(sn(tn(),!0,b))return Pha();if(sn(tn(),!1,b))return Qha();if(b instanceof ba.Array){$e();for(var d=[],e=0,f=b.length|0;e&lt;f;){var h=sx(a,b[e]);d.push(h);e=1+e|0}a=d.length|0;a=la(Xa(Lha),
[a]);f=a.l.length;e=b=0;h=d.length|0;f=h&lt;f?h:f;h=a.l.length;for(f=f&lt;h?f:h;b&lt;f;)a.l[e]=d[b],b=1+b|0,e=1+e|0;return(new zx).zx(Yt(0,a))}if(b instanceof ba.Object)return Rha||(Rha=(new Ax).b()),d=(new Bx).$l(b),d=Xb(new Yb,d,m(new n,function(){return function(a){return null!==a}}(a))).xa(m(new n,function(a){return function(b){if(null!==b){var d=b.la();b=sx(a,b.pa());return(new A).e(d,b)}throw(new q).j(b);}}(a)),(new Cx).b()),Sha(Dx(d));Un(Vn(),u((new v).K((new w).f([&quot;Unexpected JS value: &quot;,&quot;&quot;])),(new w).f([b])))}
function Tha(a){a=(new Sb).c(a);for(var b=$e().zp.af(a.R),d=0,e=a.R.length|0;d&lt;e;){var f=a.W(d),h=null===f?0:f.X;if(31&lt;h&amp;&amp;127&gt;h)f=(new J).j((new af).Ra(h)).ub();else{var f=(new v).K((new w).f([&quot;u&quot;,&quot;&quot;])),h=(+(h&gt;&gt;&gt;0)).toString(16),h=(new Sb).c(h),h=Ex(h),h=(new Sb).c(h),k=(new af).Ra(48),p=$e().zp,p=p.af(h.Bd()),t=h.sa();p.tc(4&lt;t?t:4);t=4-t|0;for(p.Yb(h.Xd());0&lt;t;)p.Na(k),t=-1+t|0;h=p.Da();h=(new Sb).c(h);h=Ex(h);f=u(f,(new w).f([h.toUpperCase()]));f=(new Sb).c(f);h=(new af).Ra(92);k=$e().zp;f=Fx(f,
h,k);f=(new Sb).c(f)}b.Yb(f.mb());d=1+d|0}return b.Da()}
function rx(a,b,d,e,f,h,k,p){if(Nha()===b)return&quot;null&quot;;if(Gx(b))return p=b.X,d?Tha(ba.JSON.stringify(p)):ba.JSON.stringify(p);if(Hx(b))return b.X.Ec.k();if(Pha().o(b))return&quot;true&quot;;if(Qha().o(b))return&quot;false&quot;;if(Ix(b))return b=b.X,d=m(new n,function(a,b,d,e,f,h,k){return function(p){return rx(a,p,b,k,d,e,f,h)}}(a,d,f,h,k,p,1+e|0)),a=Mk().qc,Wr(b,d,a).Oc(p.gb,p.Fb,p.og);if(Jx(b)){b=b.Nv;var t=1+e|0;if(h){var x=u((new v).K((new w).f([&quot;\\n&quot;,&quot;&quot;])),(new w).f([f.y(t)])),E=u((new v).K((new w).f([&quot;\\n&quot;,&quot;}&quot;])),
(new w).f([f.y(e)]));e=x;x=E}else e=f.y(t),x=&quot;}&quot;;p=m(new n,function(a,b,d,e,f,h,k,p){return function(t){if(null!==t){var x=t.la();t=t.pa();return u((new v).K((new w).f([&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;])),(new w).f([p,b?Tha(ba.JSON.stringify(x)):ba.JSON.stringify(x),f,rx(a,t,b,k,d,e,f,h)]))}throw(new q).j(t);}}(a,d,f,h,k,p,t,e));d=Lc().s;return Wr(b,p,d).Oc(&quot;{&quot;,&quot;,&quot;,x)}throw(new q).j(b);}px.prototype.$classData=g({f7:0},!1,&quot;play.api.libs.json.StaticBinding$&quot;,{f7:1,d:1});var Kx=void 0;
function Mha(){Kx||(Kx=(new px).b());return Kx}function tw(a){return!!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.g7)}function Lx(){}Lx.prototype=new l;Lx.prototype.constructor=Lx;function Mx(){}Mx.prototype=Lx.prototype;var Kha=g({tr:0},!1,&quot;sbt.testing.Selector&quot;,{tr:1,d:1});Lx.prototype.$classData=Kha;function sw(a){return!!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.BB)}function Nx(a){a.nv(Uha(a))}function Ox(){}Ox.prototype=new l;Ox.prototype.constructor=Ox;function Vha(){}Vha.prototype=Ox.prototype;
Ox.prototype.b=function(){(new Px).xD(this);(new Qx).xD(this);return this};function Rx(){}Rx.prototype=new l;Rx.prototype.constructor=Rx;function Wha(){}Wha.prototype=Rx.prototype;function Xha(a,b,d){var e=a.Dm;d=Ee(d);return e.Xb(d,K(function(a,b){return function(){return b}}(a,b)))}function Sx(){}Sx.prototype=new l;Sx.prototype.constructor=Sx;function Yha(){}Yha.prototype=Sx.prototype;function Tx(){}Tx.prototype=new l;Tx.prototype.constructor=Tx;function Zha(){}Zha.prototype=Tx.prototype;
Tx.prototype.b=function(){(new Ux).yD(this);return this};function Vx(){}Vx.prototype=new l;Vx.prototype.constructor=Vx;function Wx(){}Wx.prototype=Vx.prototype;Vx.prototype.ub=function(){return this.Nx(m(new n,function(){return function(a){return a}}(this)),$ha()).ws()};function Xx(){this.ea=null}Xx.prototype=new l;Xx.prototype.constructor=Xx;function Yx(){}Yx.prototype=Xx.prototype;
function aia(a,b){Zx();b=(new $x).yc(b);return a.ih(m(new n,function(a,b){return function(){return T(b)}}(a,b)),tb(new ub,function(a,b){return function(f,h){return ay(T(b),K(function(a,b){return function(){return b}}(a,h)))}}(a,b)),by(function(a,b){return function(f,h,k,p){return T(b).ih(m(new n,function(a){return function(){return a}}(a)),tb(new ub,function(a){return function(b,d){return cy(a,K(function(a,b){return function(){return b}}(a,d)))}}(a)),by(function(a,b,d,e,f){return function(h,k,p,Fa){h=
a.ea.jl().Xb(b,K(function(a,b){return function(){return b}}(a,h)));return dy(new ey,h,d,K(function(a,b,d,e,f){return function(){return bia(a,Ee(b),d,e,f)}}(a,e,f,k,p)),Fa,a.ea)}}(a,f,h,k,p)))}}(a,b)))}
function cia(a,b,d,e,f,h,k){Zx();e=(new $x).yc(e);Zx();f=(new $x).yc(f);Zx();k=(new $x).yc(k);if(fy(d)){d=d.Aa;if(fy(h))return gy(b,K(function(a,b,d){return function(){return hy(iy(),d,T(b),a.ea)}}(a,e,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,f,h.Aa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(jy(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,
h.Aa,h.Qa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(ly(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h.Aa,h.Qa,h.Eb)),K(function(a,b){return function(){return T(b)}}(a,k)));if(my(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Aa,h.Qa)),K(function(a,
b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Eb,h.wd)),K(function(a,b){return function(){return T(b)}}(a,k)));throw(new q).j(h);}if(jy(d)){var p=d.Aa;d=d.Qa;if(fy(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,p,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,f,h.Aa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(jy(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,p,d)),K(function(a,
b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,f,h.Aa,h.Qa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(ly(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,p,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,f,h.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Qa,h.Eb)),K(function(a,b){return function(){return T(b)}}(a,k)));if(my(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),
d,e,T(b),a.ea)}}(a,e,p,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,f,h.Aa,h.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Eb,h.wd)),K(function(a,b){return function(){return T(b)}}(a,k)));throw(new q).j(h);}if(ly(d)){var p=d.Aa,t=d.Qa;d=d.Eb;if(fy(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,e,f,h.Aa)),K(function(a,b){return function(){return T(b)}}(a,
k)));if(jy(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,e,f)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Aa,h.Qa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(ly(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,e,f,h.Aa)),K(function(a,
b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Qa,h.Eb)),K(function(a,b){return function(){return T(b)}}(a,k)));if(my(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,e,f,h.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h.Qa,h.Eb,h.wd)),K(function(a,b){return function(){return T(b)}}(a,k)));throw(new q).j(h);}if(my(d)){var p=d.Aa,t=d.Qa,x=d.Eb;d=d.wd;
if(fy(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,x)),K(function(a,b,d){return function(){return hy(iy(),d,T(b),a.ea)}}(a,e,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,f,h.Aa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(jy(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,x)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),
b,d,a.ea)}}(a,h.Aa,h.Qa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(ly(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,x)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h.Aa,h.Qa,h.Eb)),K(function(a,b){return function(){return T(b)}}(a,k)));if(my(h))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,x)),
K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Aa,h.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Eb,h.wd)),K(function(a,b){return function(){return T(b)}}(a,k)));throw(new q).j(h);}throw(new q).j(d);}
function ny(a,b,d,e,f){Zx();f=(new $x).yc(f);Zx();b=(new $x).yc(b);Zx();d=(new $x).yc(d);Zx();e=(new $x).yc(e);return a.ih(m(new n,function(a,b,d,e,f){return function(){var E=T(d),S=T(e),U=T(f);return ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a,U))),K(function(a,b){return function(){return b}}(a,S))),K(function(a,b){return function(){return b}}(a,E)))}}(a,f,b,d,e)),tb(new ub,function(a,b,d,e,f){return function(E,S){E=T(d);var U=T(e),ga=T(f);return ay(ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a,
ga))),K(function(a,b){return function(){return b}}(a,U))),K(function(a,b){return function(){return b}}(a,E))),K(function(a,b){return function(){return b}}(a,S)))}}(a,f,b,d,e)),by(function(a,b,d,e,f){return function(E,S,U,ga){return T(b).ih(m(new n,function(a,b,d,e){return function(){return cy(cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return T(b)}}(a,e)))}}(a,d,e,f)),tb(new ub,function(a,b,
d,e){return function(f,h){return cy(cy(cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return T(b)}}(a,e))),K(function(a,b){return function(){return b}}(a,h)))}}(a,d,e,f)),by(function(a,b,d,e,f,h,k,p){return function(t,x,E,U){var S=a.ea,ga=a.ea.Le(a.ea.Le(a.ea.Le(f,T(b)),T(d)),T(e));t=S.jl().Xb(ga,K(function(a,b){return function(){return b}}(a,t)));return dy(new ey,t,h,K(function(a,b,d,e,f,h,k,
p){return function(){return dia(a,Ee(f),h,K(function(a,b){return function(){return T(b)}}(a,b)),K(function(a,b){return function(){return T(b)}}(a,d)),K(function(a,b){return function(){return T(b)}}(a,e)),k,p)}}(a,b,d,e,k,p,x,E)),U,a.ea)}}(a,d,e,f,E,S,U,ga)))}}(a,f,b,d,e)))}Xx.prototype.dj=function(a){this.ea=a;return this};
function gy(a,b,d,e){Zx();e=(new $x).yc(e);Zx();b=(new $x).yc(b);Zx();d=(new $x).yc(d);return a.ih(m(new n,function(a,b,d,e){return function(){var t=T(d),x=T(e);return ay(ay(T(b),K(function(a,b){return function(){return b}}(a,x))),K(function(a,b){return function(){return b}}(a,t)))}}(a,e,b,d)),tb(new ub,function(a,b,d,e){return function(t,x){t=T(d);var E=T(e);return ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a,E))),K(function(a,b){return function(){return b}}(a,t))),K(function(a,b){return function(){return b}}(a,
x)))}}(a,e,b,d)),by(function(a,b,d,e){return function(t,x,E,S){return T(b).ih(m(new n,function(a,b,d){return function(){return cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d)))}}(a,d,e)),tb(new ub,function(a,b,d){return function(e,f){return cy(cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return b}}(a,f)))}}(a,d,e)),by(function(a,
b,d,e,f,h,k){return function(p,t,x,E){var S=a.ea,Bc=a.ea.Le(a.ea.Le(e,T(b)),T(d));p=S.jl().Xb(Bc,K(function(a,b){return function(){return b}}(a,p)));return dy(new ey,p,f,K(function(a,b,d,e,f,h,k){return function(){return cia(a,Ee(e),f,K(function(a,b){return function(){return T(b)}}(a,b)),K(function(a,b){return function(){return T(b)}}(a,d)),h,k)}}(a,b,d,h,k,t,x)),E,a.ea)}}(a,d,e,t,x,E,S)))}}(a,e,b,d)))}
function oy(a,b,d,e,f,h){Zx();h=(new $x).yc(h);Zx();b=(new $x).yc(b);Zx();d=(new $x).yc(d);Zx();e=(new $x).yc(e);Zx();f=(new $x).yc(f);return a.ih(m(new n,function(a,b,d,e,f,h){return function(){var U=T(d),ga=T(e),ma=T(f),va=T(h);return ay(ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a,va))),K(function(a,b){return function(){return b}}(a,ma))),K(function(a,b){return function(){return b}}(a,ga))),K(function(a,b){return function(){return b}}(a,U)))}}(a,h,b,d,e,f)),tb(new ub,function(a,
b,d,e,f,h){return function(U,ga){U=T(d);var ma=T(e),va=T(f),Fa=T(h);return ay(ay(ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a,Fa))),K(function(a,b){return function(){return b}}(a,va))),K(function(a,b){return function(){return b}}(a,ma))),K(function(a,b){return function(){return b}}(a,U))),K(function(a,b){return function(){return b}}(a,ga)))}}(a,h,b,d,e,f)),by(function(a,b,d,e,f,h){return function(U,ga,ma,va){return T(b).ih(m(new n,function(a,b,d,e,f){return function(){return cy(cy(cy(cy(a,
K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return T(b)}}(a,e))),K(function(a,b){return function(){return T(b)}}(a,f)))}}(a,d,e,f,h)),tb(new ub,function(a,b,d,e,f){return function(h,k){return cy(cy(cy(cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return T(b)}}(a,e))),K(function(a,b){return function(){return T(b)}}(a,
f))),K(function(a,b){return function(){return b}}(a,k)))}}(a,d,e,f,h)),by(function(a,b,d,e,f,h,k,p,t){return function(x,E,U,S){var ga=a.ea,ma=a.ea.Le(a.ea.Le(a.ea.Le(a.ea.Le(h,T(b)),T(d)),T(e)),T(f));x=ga.jl().Xb(ma,K(function(a,b){return function(){return b}}(a,x)));return dy(new ey,x,k,K(function(a,b,d,e,f,h,k,p,t){return function(){return eia(a,Ee(h),k,K(function(a,b){return function(){return T(b)}}(a,b)),K(function(a,b){return function(){return T(b)}}(a,d)),K(function(a,b){return function(){return T(b)}}(a,
e)),K(function(a,b){return function(){return T(b)}}(a,f)),p,t)}}(a,b,d,e,f,p,t,E,U)),S,a.ea)}}(a,d,e,f,h,U,ga,ma,va)))}}(a,h,b,d,e,f)))}
function dia(a,b,d,e,f,h,k,p){Zx();e=(new $x).yc(e);Zx();f=(new $x).yc(f);Zx();h=(new $x).yc(h);Zx();p=(new $x).yc(p);if(fy(d)){d=d.Aa;if(fy(k))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(jy(k))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),
T(b),d,e,a.ea)}}(a,h,k.Aa,k.Qa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(ly(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Qa,k.Eb)),K(function(a,b){return function(){return T(b)}}(a,p)));if(my(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,
d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,h,k.Aa,k.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Eb,k.wd)),K(function(a,b){return function(){return T(b)}}(a,p)));throw(new q).j(k);}if(jy(d)){var t=d.Aa;d=d.Qa;if(fy(k))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,f,h,k.Aa)),K(function(a,b){return function(){return T(b)}}(a,
p)));if(jy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,t,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,f,h)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Aa,k.Qa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(ly(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,f,h,k.Aa)),
K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Qa,k.Eb)),K(function(a,b){return function(){return T(b)}}(a,p)));if(my(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,f,h,k.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k.Qa,k.Eb,k.wd)),K(function(a,b){return function(){return T(b)}}(a,p)));throw(new q).j(k);}if(ly(d)){var t=d.Aa,x=
d.Qa;d=d.Eb;if(fy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,e,f)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(jy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),
K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Aa,k.Qa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(ly(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k.Aa,k.Qa,k.Eb)),K(function(a,b){return function(){return T(b)}}(a,p)));if(my(k))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),
b,d,e,a.ea)}}(a,t,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Aa,k.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Eb,k.wd)),K(function(a,b){return function(){return T(b)}}(a,p)));throw(new q).j(k);}if(my(d)){var t=d.Aa,x=d.Qa,E=d.Eb;d=d.wd;if(fy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,E)),K(function(a,b,d,e){return function(){return ky(iy(),
e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(jy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,E)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,h,k.Aa,k.Qa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(ly(k))return oy(b,
K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,E)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Qa,k.Eb)),K(function(a,b){return function(){return T(b)}}(a,p)));if(my(k))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,E)),K(function(a,b,d,e){return function(){return ky(iy(),
e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,h,k.Aa,k.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Eb,k.wd)),K(function(a,b){return function(){return T(b)}}(a,p)));throw(new q).j(k);}throw(new q).j(d);}Xx.prototype.k=function(){py();var a=(new qy).b();py();var b=(new qy).b();iy();var d=new ry;d.Hw=a;d.lr=b;Vd(d);py();fia||(fia=(new sy).b());a=new ty;a.Xt=b;Vd(a);d.fz=a;return d.Md(this).k()};
function bia(a,b,d,e,f){if(fy(d)){d=d.Aa;if(fy(e))return e=e.Aa,uy(b,hy(iy(),d,e,a.ea),f);if(jy(e)){var h=e.Aa;e=e.Qa;return uy(b,ky(iy(),d,h,e,a.ea),f)}if(ly(e))return gy(b,K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,d,e.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Qa,e.Eb)),f);if(my(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,d,e.Aa,e.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Eb,
e.wd)),f);throw(new q).j(e);}if(jy(d)){h=d.Aa;d=d.Qa;if(fy(e))return e=e.Aa,uy(b,ky(iy(),h,d,e,a.ea),f);if(jy(e))return gy(b,K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Aa,e.Qa)),f);if(ly(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,d,e.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Qa,e.Eb)),f);if(my(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),
b,d,e,a.ea)}}(a,h,d,e.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,e.Qa,e.Eb,e.wd)),f);throw(new q).j(e);}if(ly(d)){var h=d.Aa,k=d.Qa;d=d.Eb;if(fy(e))return gy(b,K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h,k)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,d,e.Aa)),f);if(jy(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,
e.Aa,e.Qa)),f);if(ly(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,d)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,e.Aa,e.Qa,e.Eb)),f);if(my(e))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Aa,e.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Eb,e.wd)),f);throw(new q).j(e);}if(my(d)){var h=d.Aa,k=d.Qa,
p=d.Eb;d=d.wd;if(fy(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,p)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,d,e.Aa)),f);if(jy(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,p)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,d,e.Aa,e.Qa)),f);if(ly(e))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,p)),K(function(a,b,d){return function(){return hy(iy(),
b,d,a.ea)}}(a,d,e.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Qa,e.Eb)),f);if(my(e))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,p)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,d,e.Aa,e.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Eb,e.wd)),f);throw(new q).j(e);}throw(new q).j(d);}
Xx.prototype.Gb=function(a,b){return this.ih(m(new n,function(a,b){return function(){return b}}(this,a)),tb(new ub,function(a,b,f){return function(a,d){return rb(f,b,d)}}(this,a,b)),by(function(a,b,f){return function(h,k,p,t){h=iy();h=(new vy).ls(h);p=Ee(p);var x=iy(),x=(new vy).ls(x);k=p.Gb(Fd(x,k,b,f),tb(new ub,function(a,b){return function(a,d){var e=iy(),e=(new wy).ls(e);return Fd(e,d,a,b)}}(a,f)));return Fd(h,t,k,f)}}(this,a,b)))};Xx.prototype.ws=function(){return gia(iy(),this.ea).Al(this)};
function eia(a,b,d,e,f,h,k,p,t){Zx();e=(new $x).yc(e);Zx();f=(new $x).yc(f);Zx();h=(new $x).yc(h);Zx();k=(new $x).yc(k);Zx();t=(new $x).yc(t);if(fy(d)){d=d.Aa;if(fy(p))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(jy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,
f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,h,k)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Aa,p.Qa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(ly(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Qa,p.Eb)),K(function(a,b){return function(){return T(b)}}(a,
t)));if(my(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p.Qa,p.Eb,p.wd)),K(function(a,b){return function(){return T(b)}}(a,t)));throw(new q).j(p);}if(jy(d)){var x=d.Aa;d=d.Qa;if(fy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,x,d)),K(function(a,b,d){return function(){return hy(iy(),
T(b),T(d),a.ea)}}(a,f,h)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,k,p.Aa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(jy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,f,h,k)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Aa,p.Qa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(ly(p))return ny(b,K(function(a,
b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,f,h,k)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p.Aa,p.Qa,p.Eb)),K(function(a,b){return function(){return T(b)}}(a,t)));if(my(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,f,h,k)),K(function(a,b,d){return function(){return hy(iy(),
b,d,a.ea)}}(a,p.Aa,p.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Eb,p.wd)),K(function(a,b){return function(){return T(b)}}(a,t)));throw(new q).j(p);}if(ly(d)){var x=d.Aa,E=d.Qa;d=d.Eb;if(fy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,k,p.Aa)),K(function(a,b){return function(){return T(b)}}(a,
t)));if(jy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,k,p.Aa,p.Qa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(ly(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,
e,f,h)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,k,p.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Qa,p.Eb)),K(function(a,b){return function(){return T(b)}}(a,t)));if(my(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,k,p.Aa,p.Qa)),K(function(a,b,
d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Eb,p.wd)),K(function(a,b){return function(){return T(b)}}(a,t)));throw(new q).j(p);}if(my(d)){var x=d.Aa,E=d.Qa,S=d.Eb;d=d.wd;if(fy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,S)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(jy(p))return oy(b,
K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,S)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,h,k)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Aa,p.Qa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(ly(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,S)),K(function(a,b,d,e){return function(){return ky(iy(),
e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Qa,p.Eb)),K(function(a,b){return function(){return T(b)}}(a,t)));if(my(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,S)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,
h,k,p.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p.Qa,p.Eb,p.wd)),K(function(a,b){return function(){return T(b)}}(a,t)));throw(new q).j(p);}throw(new q).j(d);}
function cy(a,b){var d=xy(iy(),a.ea);Zx();b=(new $x).yc(b);return a.ih(m(new n,function(a,b){return function(d){d=a.ea.Le(d,T(b));return yy(new zy,d,K(function(a,b){return function(){return T(b)}}(a,b)),a.ea)}}(a,b)),tb(new ub,function(a,b,d){return function(k,p){k=a.ea.Le(k,T(d));p=Ay(iy(),p,a.ea);var t=K(function(a,b){return function(){return(new Td).dj(b)}}(a,b)),x=Ay(iy(),T(d),a.ea);return dy(new ey,k,p,t,x,a.ea)}}(a,d,b)),by(function(a,b){return function(d,k,p,t){p=Ee(p);if(my(t)){var x=t.Aa,
E=t.Qa,S=t.Eb;t=t.wd;d=a.ea.Le(d,T(b));p=K(function(a,b,d,e,f){return function(){return cy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,d,e,f)))}}(a,p,x,E,S));t=By(iy(),t,T(b),a.ea);return dy(new ey,d,k,p,t,a.ea)}d=a.ea.Le(d,T(b));p=K(function(a,b){return function(){return b}}(a,p));t=t.Zv(T(b));return dy(new ey,d,k,p,t,a.ea)}}(a,b)))}
function hia(a,b,d,e,f,h){Zx();e=(new $x).yc(e);Zx();h=(new $x).yc(h);if(fy(d)){d=d.Aa;if(fy(f))return f=f.Aa,uy(b,ky(iy(),d,T(e),f,a.ea),K(function(a,b){return function(){return T(b)}}(a,h)));if(jy(f))return gy(b,K(function(a,b,d){return function(){return hy(iy(),d,T(b),a.ea)}}(a,e,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Aa,f.Qa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(ly(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,T(b),
e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Qa,f.Eb)),K(function(a,b){return function(){return T(b)}}(a,h)));if(my(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,T(b),e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,f.Qa,f.Eb,f.wd)),K(function(a,b){return function(){return T(b)}}(a,h)));throw(new q).j(f);}if(jy(d)){var k=d.Aa;d=d.Qa;if(fy(f))return gy(b,K(function(a,b,d){return function(){return hy(iy(),
b,d,a.ea)}}(a,k,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,e,f.Aa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(jy(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,k,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Aa,f.Qa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(ly(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,k,d)),K(function(a,b,
d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,f.Aa,f.Qa,f.Eb)),K(function(a,b){return function(){return T(b)}}(a,h)));if(my(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,k,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Aa,f.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Eb,f.wd)),K(function(a,b){return function(){return T(b)}}(a,h)));throw(new q).j(f);}if(ly(d)){var k=d.Aa,p=d.Qa;d=d.Eb;if(fy(f))return gy(b,
K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,e,f.Aa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(jy(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,e,f.Aa,f.Qa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(ly(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),
b,d,e,a.ea)}}(a,k,p,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,e,f.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Qa,f.Eb)),K(function(a,b){return function(){return T(b)}}(a,h)));if(my(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,e,f.Aa,f.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Eb,f.wd)),K(function(a,
b){return function(){return T(b)}}(a,h)));throw(new q).j(f);}if(my(d)){var k=d.Aa,p=d.Qa,t=d.Eb;d=d.wd;if(fy(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,t)),K(function(a,b,d,e){return function(){return ky(iy(),d,T(b),e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(jy(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,t)),K(function(a,b,d){return function(){return hy(iy(),d,T(b),a.ea)}}(a,
e,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Aa,f.Qa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(ly(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,t)),K(function(a,b,d,e){return function(){return ky(iy(),d,T(b),e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Qa,f.Eb)),K(function(a,b){return function(){return T(b)}}(a,h)));if(my(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),
b,d,e,a.ea)}}(a,k,p,t)),K(function(a,b,d,e){return function(){return ky(iy(),d,T(b),e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,f.Qa,f.Eb,f.wd)),K(function(a,b){return function(){return T(b)}}(a,h)));throw(new q).j(f);}throw(new q).j(d);}
function uy(a,b,d){Zx();d=(new $x).yc(d);return a.ih(m(new n,function(a,b,d){return function(){return ay(T(d),K(function(a,b){return function(){return b}}(a,b)))}}(a,b,d)),tb(new ub,function(a,b,d){return function(k,p){return ay(ay(T(d),K(function(a,b){return function(){return b}}(a,b))),K(function(a,b){return function(){return b}}(a,p)))}}(a,b,d)),by(function(a,b,d){return function(k,p,t,x){return T(d).ih(m(new n,function(a,b){return function(){return cy(a,K(function(a,b){return function(){return b}}(a,
b)))}}(a,b)),tb(new ub,function(a,b){return function(d,e){return cy(cy(a,K(function(a,b){return function(){return b}}(a,b))),K(function(a,b){return function(){return b}}(a,e)))}}(a,b)),by(function(a,b,d,e,f,h){return function(k,p,t,x){var Ib=a.ea,kc=a.ea.Le(d,b);k=Ib.jl().Xb(kc,K(function(a,b){return function(){return b}}(a,k)));return dy(new ey,k,e,K(function(a,b,d,e,f,h){return function(){return hia(a,Ee(d),e,K(function(a,b){return function(){return b}}(a,b)),f,h)}}(a,b,f,h,p,t)),x,a.ea)}}(a,b,
k,p,t,x)))}}(a,b,d)))}
function ay(a,b){var d=xy(iy(),a.ea);Zx();b=(new $x).yc(b);return a.ih(m(new n,function(a,b){return function(d){d=a.ea.so(T(b),d);return yy(new zy,d,K(function(a,b){return function(){return T(b)}}(a,b)),a.ea)}}(a,b)),tb(new ub,function(a,b,d){return function(k,p){k=a.ea.so(T(d),k);var t=Ay(iy(),T(d),a.ea),x=K(function(a,b){return function(){return(new Td).dj(b)}}(a,b));p=Ay(iy(),p,a.ea);return dy(new ey,k,t,x,p,a.ea)}}(a,d,b)),by(function(a,b){return function(d,k,p,t){p=Ee(p);if(my(k)){var x=k.Aa,
E=k.Qa,S=k.Eb;k=k.wd;d=a.ea.so(T(b),d);x=By(iy(),T(b),x,a.ea);return dy(new ey,d,x,K(function(a,b,d,e,f){return function(){var h=ky(iy(),d,e,f,a.ea);return ay(b,K(function(a,b){return function(){return b}}(a,h)))}}(a,p,E,S,k)),t,a.ea)}E=a.ea.so(T(b),d);S=T(b);k=k.bw(S);return dy(new ey,E,k,K(function(a,b){return function(){return b}}(a,p)),t,a.ea)}}(a,b)))}
function iia(a,b,d){return a.ih(m(new n,function(a,b){return function(){return b.he()}}(a,d)),tb(new ub,function(a,b){return function(a,d){return b.y(d)}}(a,b)),by(function(a,b,d){return function(k,p,t,x){return d.Xb(d.Xb(p.an(b,d),K(function(a,b,d,e){return function(){return iia(Ee(e),m(new n,function(a,b,d){return function(a){return a.an(b,d)}}(a,b,d)),d)}}(a,b,d,t))),K(function(a,b,d,e){return function(){return e.an(b,d)}}(a,b,d,x)))}}(a,b,d)))}function Cy(){}Cy.prototype=new l;
Cy.prototype.constructor=Cy;function jia(){}jia.prototype=Cy.prototype;function xy(a,b){return Dy(new Ey,m(new n,function(a){return function(b){return b.$C(su(function(){return function(a){return a}}(a)),by(function(){return function(a){return a}}(a)))}}(a)),b.jl())}
function gia(a,b){return Dy(new Ey,m(new n,function(a){return function(b){return b.ih(m(new n,function(){return function(a){return a}}(a)),tb(new ub,function(){return function(a){return a}}(a)),by(function(){return function(a){return a}}(a)))}}(a)),b.jl())}function kia(a,b,d,e){var f=(new Fy).b();b.wa(m(new n,function(a,b){return function(a){return Gy(b,a)}}(a,f)));for(b=e.he();!f.z();){var h=b;b=lia(f);h=K(function(a,b){return function(){return b}}(a,h));b=e.Xb(d.y(b),h)}return b}
function mia(a,b,d,e){a=a.Hg(b,(mv(),F()),tb(new ub,function(a,b,d){return function(a,e){a=(new A).e(a,e);e=a.kb;var f=a.Ab;if(F()===e)return mv(),a=b.y(f),(new J).j(a);f=a.kb;e=a.Ab;if(Vk(f))return a=f.U,mv(),a=rb(d,a,e),(new J).j(a);throw(new q).j(a);}}(a,d,e)));return a.z()?Un(Vn(),&quot;foldMapLeft1&quot;):a.Y()}function nia(a,b,d){return a.sx(b,m(new n,function(){return function(a){return a}}(a)),d)}function Hy(){}Hy.prototype=new l;Hy.prototype.constructor=Hy;function Iy(){}Iy.prototype=Hy.prototype;
function oia(a,b){for(;;){var d=a;if(Jy(d))return(new Ky).j(d.ha);if(Ly(d))return(new My).j(b.Xc(d.ha,m(new n,function(){return function(a){return(new Ny).j(a)}}(a))));if(Oy(d)){var e=d.wr;if(Jy(e))a=d.Jo.y(e.ha);else{if(Ly(e))return(new My).j(b.Xc(e.ha,d.Jo));if(Oy(e))a=Py(new Qy,e.wr,m(new n,function(a,b,d){return function(a){a=b.Jo.y(a);return Py(new Qy,a,d.Jo)}}(a,e,d)));else throw(new q).j(e);}}else throw(new q).j(d);}}
function pia(a,b){return Py(new Qy,a,m(new n,function(a,b){return function(a){return(new Ny).j(b.y(a))}}(a,b)))}function Ry(){}Ry.prototype=new l;Ry.prototype.constructor=Ry;function qia(){}qia.prototype=Ry.prototype;function Sy(a,b){return m(new n,function(a,b){return function(f){return a.Xc(f,b)}}(a,b))}function Ty(a){a.Sg(ria(a))}function Uy(){}Uy.prototype=new l;Uy.prototype.constructor=Uy;function sia(){}sia.prototype=Uy.prototype;function Vy(){}Vy.prototype=new l;Vy.prototype.constructor=Vy;
function tia(){}tia.prototype=Vy.prototype;function Wy(){}Wy.prototype=new l;Wy.prototype.constructor=Wy;function Xy(){}Xy.prototype=Wy.prototype;function uia(a,b){return(new Yy).cn(m(new n,function(a,b){return function(f){return b.y(m(new n,function(a,b){return function(d){return Zy(a,d,b)}}(a,f)))}}(a,b)))}function Zy(a,b,d){return d.ej(d.Xc(a.bD().y(d),m(new n,function(a,b){return function(a){return a.y(b)}}(a,b))))}
function via(a,b,d){return uia(a,m(new n,function(a,b,d){return function(k){return m(new n,function(a,b,d,e){return function(f){return d.Xc(e.y(f),m(new n,function(a,b){return function(a){return(new A).e(a.la(),b.y(a.pa()))}}(a,b)))}}(a,b,d,k))}}(a,b,d)))}function wia(a,b){var d=$y();return(new Yy).cn(m(new n,function(a,b,d){return function(){return m(new n,function(a,b,d){return function(e){return d.vd(K(function(a,b,d){return function(){return Zy(a,d,b)}}(a,b,e)))}}(a,b,d))}}(a,b,d)))}
function xia(a,b,d){return uia(a,m(new n,function(a,b,d){return function(k){return m(new n,function(a,b,d,e){return function(f){return d.eh(e.y(f),m(new n,function(a,b,d){return function(e){var f=b.y(e.pa()).bD().y(d);return d.eh(f,m(new n,function(a,b){return function(a){return a.y(b.la())}}(a,e)))}}(a,b,d)))}}(a,b,d,k))}}(a,b,d)))}function az(){}az.prototype=new l;az.prototype.constructor=az;function yia(){}yia.prototype=az.prototype;function bz(a){a.Ns((new cz).zD(a));a.Ms((new dz).zD(a))}
function ez(a){a.SE((new fz).AD(a));a.RE((new gz).AD(a))}function hz(){}hz.prototype=new l;hz.prototype.constructor=hz;function zia(){}zia.prototype=hz.prototype;function iz(){}iz.prototype=new l;iz.prototype.constructor=iz;function Aia(){}Aia.prototype=iz.prototype;function jz(){}jz.prototype=new l;jz.prototype.constructor=jz;function Bia(){}Bia.prototype=jz.prototype;jz.prototype.b=function(){var a=new kz;yd(a);Nx(a);return this};function lz(){}lz.prototype=new l;lz.prototype.constructor=lz;
function Cia(){}Cia.prototype=lz.prototype;function mz(a){a.zf(Dia(a))}function nz(){}nz.prototype=new l;nz.prototype.constructor=nz;function Eia(){}Eia.prototype=nz.prototype;function oz(){}oz.prototype=new l;oz.prototype.constructor=oz;oz.prototype.b=function(){pz=this;(new qz).b();return this};oz.prototype.$classData=g({T8:0},!1,&quot;scalaz.Need$&quot;,{T8:1,d:1});var pz=void 0;function Zx(){pz||(pz=(new oz).b())}function rz(){}rz.prototype=new l;rz.prototype.constructor=rz;function sz(){}
sz.prototype=rz.prototype;rz.prototype.dj=function(){return this};rz.prototype.an=function(a,b){return this.$C(su(function(a,b,f){return function(h,k,p){return f.Xb(b.y(Ee(k)),K(function(a,b,d){return function(){return b.y(Ee(d))}}(a,b,p)))}}(this,a,b)),by(function(a,b,f){return function(h,k,p,t){return f.Xb(f.Xb(b.y(Ee(k)),K(function(a,b,d){return function(){return b.y(Ee(d))}}(a,b,p))),K(function(a,b,d){return function(){return b.y(Ee(d))}}(a,b,t)))}}(this,a,b)))};
function zq(){this.Mc=this.Fc=null}zq.prototype=new l;zq.prototype.constructor=zq;c=zq.prototype;c.o=function(a){if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.oR){var b=xt(this);a=xt(a);return null===b?null===a:b.o(a)}return!1};function xt(a){return(new yq).Qb(a.Fc,a.Mc)}c.k=function(){return&quot;NonEmpty&quot;+(new yq).Qb(this.Fc,this.Mc)};
function Fia(a,b,d){var e=a.Mc;if(wq(e))return d.Xc(b.y(a.Fc),m(new n,function(){return function(a){tq();var b=uq().Vd;return(new zq).Qb(a,b)}}(a)));if(xq(e))return tz(d,K(function(a,b){return function(){return b.y(a.Fc)}}(a,b)),K(function(a,b,d,e,t){return function(){uz||(uz=(new vz).b());var a=uq().ND,f=new wz;f.Xm=a;Md(f);Ty(f);Ed(f);xz(f);f.Iq(yz(f));f.Kq(zz(f));a=(new Az).e(e,t);return Gia(f,a,b,d)}}(a,b,d,e.$c,e.dd)),tb(new ub,function(){return function(a,b){tq();return(new zq).Qb(a,(new yq).Qb(b.Fc,
b.Mc))}}(a)));throw(new q).j(e);}function Zq(a,b){var d=xt(a);if(wq(d))a=b;else if(xq(d))a=d.$c,d=d.dd,tq(),b=xt(b),b=Hia(d,b),a=(new zq).Qb(a,b);else throw(new q).j(d);return a}function rq(a){var b;Bz||(Bz=(new Cz).b());b=Bz;tq();var d=b.y(a.Fc);a=Iia(a.Mc,b);return(new zq).Qb(d,a)}c.Qb=function(a,b){this.Fc=a;this.Mc=b;return this};c.r=function(){return xt(this).r()};c.$classData=g({oR:0},!1,&quot;scalaz.NonEmptyList&quot;,{oR:1,d:1});function Dz(){}Dz.prototype=new l;Dz.prototype.constructor=Dz;
function Jia(){}Jia.prototype=Dz.prototype;function Ez(){}Ez.prototype=new l;Ez.prototype.constructor=Ez;function Kia(){}Kia.prototype=Ez.prototype;function Fz(a){a.jg(Lia(a))}function Gz(a){a.Os(Mia(a))}function Hz(){}Hz.prototype=new l;Hz.prototype.constructor=Hz;function Iz(){}Iz.prototype=Hz.prototype;function Jz(){}Jz.prototype=new l;Jz.prototype.constructor=Jz;function Nia(){}Nia.prototype=Jz.prototype;
Jz.prototype.b=function(){Oia();m(new n,function(){return function(a){return!!a}}(this));m(new n,function(){return function(a){return!!a}}(this));Kz();m(new n,function(){return function(a){return a|0}}(this));Kz();m(new n,function(){return function(a){return(new af).Ra(null===a?0:a.X)}}(this));Kz();m(new n,function(){return function(a){return a|0}}(this));Kz();m(new n,function(){return function(a){a=Qa(a);return(new Vb).ia(a.ka,a.qa)}}(this));Kz();m(new n,function(){return function(a){return a|0}}(this));
Kz();m(new n,function(){return function(a){return a}}(this));Lz||(Lz=(new Mz).b());return this};function $ha(){var a;Nz||(Nz=(new Oz).b());a=Nz;var b=m(new n,function(){return function(a){var b=y();return Cd(new Dd,a,b)}}(a));a=m(new n,function(a){return function(b){return m(new n,function(a,b){return function(a){return Cd(new Dd,b,a)}}(a,b))}}(a));var d=Wq(),d=(new Xq).nu(d);return Pia(b,a,d)}function Pz(){}Pz.prototype=new l;Pz.prototype.constructor=Pz;
Pz.prototype.b=function(){Qz=this;(new Rz).b();return this};Pz.prototype.$classData=g({q9:0},!1,&quot;scalaz.Show$&quot;,{q9:1,d:1});var Qz=void 0;function py(){Qz||(Qz=(new Pz).b())}function Qia(a,b){a=m(new n,function(a,b){return function(a){a=b.y(a);return(new A).e(a,void 0)}}(a,b));b=Sz().dg;return Tz(new Uz,a,b)}function Vz(){}Vz.prototype=new l;Vz.prototype.constructor=Vz;
Vz.prototype.b=function(){Wz=this;(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();return this};Vz.prototype.$classData=g({B9:0},!1,&quot;scalaz.Tags$&quot;,{B9:1,d:1});var Wz=void 0;function Yz(){Wz||(Wz=(new Vz).b())}function Zz(){this.ga=this.JG=null}Zz.prototype=new l;Zz.prototype.constructor=Zz;Zz.prototype.$classData=g({G9:0},!1,&quot;scalaz.Traverse$Traversal&quot;,{G9:1,d:1});
function $z(){}$z.prototype=new l;$z.prototype.constructor=$z;function Ria(){}Ria.prototype=$z.prototype;function aA(){}aA.prototype=new l;aA.prototype.constructor=aA;function Sia(){}Sia.prototype=aA.prototype;aA.prototype.b=function(){var a=new bA;xd(a);wd(a);cA(a);return this};function dA(){this.dg=null}dA.prototype=new l;dA.prototype.constructor=dA;
dA.prototype.b=function(){eA=this;fA||(fA=(new gA).b());this.dg=fA.wx;Tia||(Tia=(new hA).b());Uia||(Uia=(new iA).b());Via||(Via=(new jA).b());Wia||(Wia=(new kA).b());Xia||(Xia=(new lA).b());Yia||(Yia=(new mA).b());Zia();$ia||($ia=(new nA).b());aja||(aja=(new oA).b());bja||(bja=(new pA).b());return this};dA.prototype.$classData=g({R9:0},!1,&quot;scalaz.package$&quot;,{R9:1,d:1});var eA=void 0;function Sz(){eA||(eA=(new dA).b());return eA}function qA(){}qA.prototype=new l;qA.prototype.constructor=qA;
qA.prototype.b=function(){return this};function cja(a){tq();var b=[],d=uq().Vd,e=b.length|0;a:for(;;){if(0!==e){d=(new yq).Qb(b[-1+e|0],d);e=-1+e|0;continue a}break}return(new zq).Qb(a,d)}qA.prototype.$classData=g({xaa:0},!1,&quot;scalaz.syntax.NelOps$&quot;,{xaa:1,d:1});var dja=void 0;function Id(){}Id.prototype=new l;Id.prototype.constructor=Id;Id.prototype.b=function(){return this};function Yaa(a,b){return tb(new ub,function(a,b){return function(a,d){return rb(b,d,a)}}(a,b))}
Id.prototype.$classData=g({Qaa:0},!1,&quot;scalaz.syntax.std.Function2Ops$&quot;,{Qaa:1,d:1});var Hd=void 0;function lv(){this.hX=null}lv.prototype=new l;lv.prototype.constructor=lv;lv.prototype.Ha=function(a){this.hX=a;return this};lv.prototype.$classData=g({Raa:0},!1,&quot;scalaz.syntax.std.OptionOps&quot;,{Raa:1,d:1});function rA(){}rA.prototype=new l;rA.prototype.constructor=rA;rA.prototype.b=function(){return this};rA.prototype.$classData=g({Saa:0},!1,&quot;utest.PlatformShims$&quot;,{Saa:1,d:1});var sA=void 0;
function tA(){this.Fv=null}tA.prototype=new l;tA.prototype.constructor=tA;function eja(a,b){Ec();for(var d=(new w).b(),e=a.Fv,f=b.ub();;)if(kd(f)){if(!Gi(f))throw(new q).j(f);for(var h=f.Bb,f=f.Ia,h=e.Qm.jD(m(new n,function(a,b){return function(a){return a.X.me()===b}}(a,h))),k=[h],p=0,t=k.length|0;p&lt;t;)d.oa.push(k[p]),p=1+p|0;if(!e.Qm.Vo(h))throw(new uA).K(b);e=e.Qm.W(h)}else break;return(new A).e(d,e)}function vA(a){var b=new tA;b.Fv=a;return b}
function fja(a,b,d,e,f,h,k,p,t,x){var E=b.wg();if(F()===E)return wA(xA(),K(function(a,b){return function(){return b}}(a,d)),t);if(Vk(E)){var S=E.U,E=vA(S),U=r(),U=h.mc(e,U.s),S=S.X.me(),ga=r();return gja(E,f,U,k.mc(S,ga.s),p,x,t).bl(m(new n,function(a,b,d,e,f,h,k,p,t,x){return function(E){var S=p.aa(),U=B().s;return fja(a,S,kj(t,E,U),1+x|0,b,d,e,f,h,k)}}(a,f,h,k,p,t,x,b,d,e)),t)}throw(new q).j(E);}
function hja(a,b,d,e,f,h){e=eja(a,e);if(null===e)throw(new q).j(e);a=e.la();e=vA(e.pa());var k=yA(xA(),F());return gja(e,b,a,d,f,k,h)}
function gja(a,b,d,e,f,h,k){return wA(xA(),K(function(a,b,d,e,f,h,k){return function(){var ma=ija(),va=f.y(K(function(a,b,d,e){return function(){return d.bl(m(new n,function(a,b,d){return function(e){if(F()===e)return wA(xA(),K(function(a,b){return function(){try{return yA(xA(),a.Fv.X.Yna().joa(b.ub()))}catch(d){var e=ko(Lg(),d);if(null!==e)return xA(),zA||(zA=(new AA).b()),e=(new BA).ud(e),jja(kja(),e);throw d;}}}(a,b)),d).bl(m(new n,function(){return function(a){return a}}(a)),d);if(Vk(e))throw e.U;
throw(new q).j(e);}}(a,b,e)),e).bl(m(new n,function(){return function(a){return a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.EE?a:yA(xA(),a)}}(a)),e)}}(a,d,h,k))),Fa=va.Ih(m(new n,function(){return function(){return F()}}(a)),k).Es(lja(a,e),k),Fa=fja(a,a.Fv.Qm,y(),0,b,d,e,f,k,Fa);return va.Ih(m(new n,function(){return function(a){return(new CA).j(a)}}(a)),k).Es(new DA,k).bl(m(new n,function(a,b,d,e,f,h){return function(k){return h.Ih(m(new n,function(a,b,d,e,f){return function(h){a:{var k;if(Aw(f)){var p=f.rk;
if(p&amp;&amp;p.$classData&amp;&amp;p.$classData.n.dE&amp;&amp;&quot;Boxed Error&quot;===p.Kc){k=(new BA).ud(p.Me);break a}}k=f}var t=ija(),p=a.Fv.X.me(),t=t.mp,x=t.Sn.Qn(t.Ak),t=x.ka,E=x.qa,x=e.mp,x=x.Sn.Qn(x.Ak),S=x.qa,x=t-x.ka|0,E=(-2147483648^x)&gt;(-2147483648^t)?-1+(E-S|0)|0:E-S|0,t=new EA,x=(new Vb).ia(x,E);t.va=p;t.X=k;t.Nu=x;rb(b,d,t);p=new FA;p.X=t;p.Qm=h;return p}}(a,b,d,f,k)),e)}}(a,b,e,k,ma,Fa)),k)}}(a,b,d,e,f,h,k)),k).bl(m(new n,function(){return function(a){return a}}(a)),k)}
tA.prototype.$classData=g({Uaa:0},!1,&quot;utest.framework.TestTreeSeq&quot;,{Uaa:1,d:1});function GA(){}GA.prototype=new l;GA.prototype.constructor=GA;GA.prototype.b=function(){HA=this;var a=(new IA).Db(100),b=JA().mt;mja(KA(),a.Is,b);a=(new IA).Db(1);b=JA().ot;mja(KA(),a.Is,b);return this};GA.prototype.$classData=g({Xaa:0},!1,&quot;utest.package$&quot;,{Xaa:1,d:1});var HA=void 0;function Wa(){this.ti=null}Wa.prototype=new l;Wa.prototype.constructor=Wa;Wa.prototype.kh=function(){return this.ti.name};
function LA(a){return a.ti.getComponentType()}Wa.prototype.k=function(){return(this.ti.isInterface?&quot;interface &quot;:this.ti.isPrimitive?&quot;&quot;:&quot;class &quot;)+this.kh()};function Sl(a,b){return a.ti.isPrimitive||b.ti.isPrimitive?a===b||(a===pa(cb)?b===pa(bb):a===pa(db)?b===pa(bb)||b===pa(cb):a===pa(fb)?b===pa(bb)||b===pa(cb)||b===pa(db):a===pa(gb)&amp;&amp;(b===pa(bb)||b===pa(cb)||b===pa(db)||b===pa(fb))):Rl(a,b.ti.getFakeInstance())}function Rl(a,b){return!!a.ti.isInstance(b)}
function Uq(a){a=(new Sb).c(a.ti.name);a=Ei(a,46);a=Tm((new qn).Gh(a));a=(new Sb).c(a);a=Ei(a,36);return Tm((new qn).Gh(a))}Wa.prototype.$classData=g({Bba:0},!1,&quot;java.lang.Class&quot;,{Bba:1,d:1});function MA(){}MA.prototype=new l;MA.prototype.constructor=MA;function nja(){}nja.prototype=MA.prototype;function NA(){this.JS=0;this.VV=OA();this.CV=OA()}NA.prototype=new l;NA.prototype.constructor=NA;NA.prototype.$classData=g({Nba:0},!1,&quot;java.lang.Long$StringRadixInfo&quot;,{Nba:1,d:1});
function PA(){this.QT=this.Eo=this.BV=null}PA.prototype=new l;PA.prototype.constructor=PA;PA.prototype.b=function(){QA=this;this.BV=(new RA).qu(!1);this.Eo=(new RA).qu(!0);this.QT=ba.performance?ba.performance.now?function(){SA();return+ba.performance.now()}:ba.performance.webkitNow?function(){SA();return+ba.performance.webkitNow()}:function(){SA();return+(new ba.Date).getTime()}:function(){SA();return+(new ba.Date).getTime()};return this};
PA.prototype.$classData=g({Uba:0},!1,&quot;java.lang.System$&quot;,{Uba:1,d:1});var QA=void 0;function SA(){QA||(QA=(new PA).b());return QA}function TA(){this.$R=null}TA.prototype=new l;TA.prototype.constructor=TA;TA.prototype.b=function(){UA=this;var a=new VA;a.va=&quot;main&quot;;this.$R=a;return this};TA.prototype.$classData=g({Wba:0},!1,&quot;java.lang.Thread$&quot;,{Wba:1,d:1});var UA=void 0;function WA(){this.Ac=this.tx=null}WA.prototype=new l;WA.prototype.constructor=WA;WA.prototype.b=function(){this.tx=!1;return this};
WA.prototype.Y=function(){this.tx||XA(this,null);return this.Ac};function XA(a,b){a.Ac=b;a.tx=!0}WA.prototype.$classData=g({Xba:0},!1,&quot;java.lang.ThreadLocal&quot;,{Xba:1,d:1});function YA(){}YA.prototype=new l;YA.prototype.constructor=YA;YA.prototype.b=function(){return this};function ZA(a,b,d){return b.ti.newArrayOfThisClass([d])}YA.prototype.$classData=g({Zba:0},!1,&quot;java.lang.reflect.Array$&quot;,{Zba:1,d:1});var $A=void 0;function aB(){$A||($A=(new YA).b());return $A}function bB(){}bB.prototype=new l;
bB.prototype.constructor=bB;function oja(a,b,d){if(b===d)return!0;if(null!==b&amp;&amp;null!==d&amp;&amp;b.l.length===d.l.length){a=Dw($e(),b);a=cB(a);a=lf(new mf,a,0,a.sa());for(var e=!0;e&amp;&amp;a.ta();)e=a.ma()|0,e=sn(tn(),b.l[e],d.l[e]);return e}return!1}bB.prototype.b=function(){return this};function pja(a){return m(new n,function(){return function(a){return Ga(a)}}(a))}
function qja(a,b,d,e){d=d-b|0;if(2&lt;=d){if(0&lt;e.pk(a.l[b],a.l[1+b|0])){var f=a.l[b];a.l[b]=a.l[1+b|0];a.l[1+b|0]=f}for(f=2;f&lt;d;){var h=a.l[b+f|0];if(0&gt;e.pk(h,a.l[-1+(b+f|0)|0])){for(var k=b,p=-1+(b+f|0)|0;1&lt;(p-k|0);){var t=(k+p|0)&gt;&gt;&gt;1|0;0&gt;e.pk(h,a.l[t])?p=t:k=t}k=k+(0&gt;e.pk(h,a.l[k])?0:1)|0;for(p=b+f|0;p&gt;k;)a.l[p]=a.l[-1+p|0],p=-1+p|0;a.l[k]=h}f=1+f|0}}}function rja(a,b){a=b.l.length;for(var d=0;d!==a;)b.l[d]=0,d=1+d|0}
function sja(a,b,d){var e=new dB;e.OS=d;d=b.l.length;16&lt;d?eB(a,b,la(Xa(Ua),[b.l.length]),0,d,e):qja(b,0,d,e)}function eB(a,b,d,e,f,h){var k=f-e|0;if(16&lt;k){var p=e+(k/2|0)|0;eB(a,b,d,e,p,h);eB(a,b,d,p,f,h);for(var t=a=e,x=p;a&lt;f;)t&lt;p&amp;&amp;(x&gt;=f||0&gt;=h.pk(b.l[t],b.l[x]))?(d.l[a]=b.l[t],t=1+t|0):(d.l[a]=b.l[x],x=1+x|0),a=1+a|0;Oa(d,e,b,e,k)}else qja(b,e,f,h)}bB.prototype.$classData=g({$ba:0},!1,&quot;java.util.Arrays$&quot;,{$ba:1,d:1});var fB=void 0;function gB(){fB||(fB=(new bB).b());return fB}
function hB(){this.BU=this.AU=this.zU=this.CU=null}hB.prototype=new l;hB.prototype.constructor=hB;hB.prototype.b=function(){iB=this;this.CU=jB(new kB,new ba.RegExp(&quot;^[^\\x25]+&quot;));this.zU=jB(new kB,new ba.RegExp(&quot;^\\x25{2}&quot;));this.AU=jB(new kB,new ba.RegExp(&quot;^\\x25n&quot;));this.BU=jB(new kB,new ba.RegExp(&quot;^\\x25(?:([1-9]\\d*)\\$)?([-#+ 0,\\(\x3c]*)(\\d*)(?:\\.(\\d+))?([A-Za-z])&quot;));return this};hB.prototype.$classData=g({dca:0},!1,&quot;java.util.Formatter$&quot;,{dca:1,d:1});var iB=void 0;
function lB(){iB||(iB=(new hB).b());return iB}function kB(){this.yq=null}kB.prototype=new l;kB.prototype.constructor=kB;function mB(a,b){return jd().Uc(a.yq.exec(b))}function jB(a,b){a.yq=b;return a}kB.prototype.$classData=g({eca:0},!1,&quot;java.util.Formatter$RegExpExtractor&quot;,{eca:1,d:1});function nB(){}nB.prototype=new l;nB.prototype.constructor=nB;function tja(){}tja.prototype=nB.prototype;function oB(){}oB.prototype=new l;oB.prototype.constructor=oB;function uja(){}uja.prototype=oB.prototype;
function pB(){}pB.prototype=new l;pB.prototype.constructor=pB;function vja(){}vja.prototype=pB.prototype;function Yt(a,b){null===b?a=null:0===b.l.length?(qB||(qB=(new rB).b()),a=qB.CG):a=(new Fi).Gh(b);return a}function wca(a){return null!==a?(new sB).Oo(a):null}function gp(){this.ga=this.ol=null}gp.prototype=new l;gp.prototype.constructor=gp;function iea(a,b,d){a.ol=d;if(null===b)throw Kg(Lg(),null);a.ga=b;return a}gp.prototype.$classData=g({Eca:0},!1,&quot;scala.Option$WithFilter&quot;,{Eca:1,d:1});
function tB(a,b){return m(new n,function(a,b){return function(f){f=a.db(f,ld().Eq);return!uB(ld(),f)&amp;&amp;(b.y(f),!0)}}(a,b))}function vB(a,b,d){return a.Ua(b)?a.y(b):d.y(b)}function wB(){this.JC=this.KW=this.Eq=null}wB.prototype=new l;wB.prototype.constructor=wB;wB.prototype.b=function(){xB=this;this.Eq=(new yB).b();this.KW=m(new n,function(){return function(){return!1}}(this));this.JC=(new zB).b();return this};function uB(a,b){return a.Eq===b}
wB.prototype.$classData=g({Fca:0},!1,&quot;scala.PartialFunction$&quot;,{Fca:1,d:1});var xB=void 0;function ld(){xB||(xB=(new wB).b());return xB}function AB(){}AB.prototype=new l;AB.prototype.constructor=AB;AB.prototype.b=function(){return this};AB.prototype.$classData=g({Qca:0},!1,&quot;scala.Predef$DummyImplicit&quot;,{Qca:1,d:1});function BB(){}BB.prototype=new l;BB.prototype.constructor=BB;BB.prototype.b=function(){return this};BB.prototype.$classData=g({Rca:0},!1,&quot;scala.Predef$RichException$&quot;,{Rca:1,d:1});
var wja=void 0;function CB(){}CB.prototype=new l;CB.prototype.constructor=CB;CB.prototype.b=function(){return this};function xja(a,b,d){return&quot;&quot;+DB(Ia(),b)+d}CB.prototype.$classData=g({Sca:0},!1,&quot;scala.Predef$any2stringadd$&quot;,{Sca:1,d:1});var EB=void 0;function yja(){EB||(EB=(new CB).b());return EB}function FB(){this.iz=null}FB.prototype=new l;FB.prototype.constructor=FB;FB.prototype.b=function(){this.iz=&quot;\n&quot;;return this};FB.prototype.$classData=g({Yca:0},!1,&quot;scala.compat.Platform$&quot;,{Yca:1,d:1});
var GB=void 0;function zja(){GB||(GB=(new FB).b());return GB}function HB(){this.Jt=null}HB.prototype=new l;HB.prototype.constructor=HB;HB.prototype.b=function(){IB=this;this.Jt=(new WA).b();return this};HB.prototype.$classData=g({$ca:0},!1,&quot;scala.concurrent.BlockContext$&quot;,{$ca:1,d:1});var IB=void 0;function Aja(){IB||(IB=(new HB).b());return IB}function JB(){this.ST=null;this.ya=!1}JB.prototype=new l;JB.prototype.constructor=JB;JB.prototype.b=function(){return this};
function KB(){var a;LB||(LB=(new JB).b());a=LB;a.ya||a.ya||(MB||(MB=(new NB).b()),a.ST=MB.UV,a.ya=!0);return a.ST}JB.prototype.$classData=g({bda:0},!1,&quot;scala.concurrent.ExecutionContext$Implicits$&quot;,{bda:1,d:1});var LB=void 0;function Bja(a,b,d){return Cja(a,m(new n,function(a,b){return function(d){if(zw(d))return b.y(d.U);if(Aw(d))return a;throw(new q).j(d);}}(a,b)),d)}function Dja(a,b,d){return Eja(a,m(new n,function(a,b){return function(a){return a.$U(b)}}(a,b)),d)}
function Fja(a,b,d,e){return a.bl(m(new n,function(a,b,d,e){return function(t){return b.Ih(m(new n,function(a,b,d){return function(a){return rb(b,d,a)}}(a,d,t)),e)}}(a,b,d,e)),we())}function Gja(a,b,d){return a.Ih(m(new n,function(a,b){return function(a){if(b.y(a))return a;throw(new Xu).c(&quot;Future.filter predicate is not satisfied&quot;);}}(a,b)),d)}function Hja(a,b,d){return Eja(a,m(new n,function(a,b){return function(a){return a.WV(b)}}(a,b)),d)}function OB(){this.BY=null}OB.prototype=new l;
OB.prototype.constructor=OB;OB.prototype.b=function(){PB=this;for(var a=[(new A).e(pa(Za),pa(Aa)),(new A).e(pa(bb),pa(sa)),(new A).e(pa(ab),pa(Ija)),(new A).e(pa(cb),pa(ua)),(new A).e(pa(db),pa(wa)),(new A).e(pa(eb),pa(Da)),(new A).e(pa(fb),pa(ya)),(new A).e(pa(gb),pa(za)),(new A).e(pa(Ya),pa(Ba))],b=dc(new ec,gc()),d=0,e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.BY=yA(0,void 0);return this};
function QB(a,b,d,e){return b.Gb(yA(0,d.af(b)),tb(new ub,function(a,b){return function(d,e){return d.XF(e,tb(new ub,function(){return function(a,b){return a.Na(b)}}(a)),b)}}(a,e))).Ih(m(new n,function(){return function(a){return a.Da()}}(a)),we())}function yA(a,b){zA||(zA=(new AA).b());a=(new CA).j(b);return jja(kja(),a)}function wA(a,b,d){return a.BY.Ih(m(new n,function(a,b){return function(){return Ee(b)}}(a,b)),d)}OB.prototype.$classData=g({cda:0},!1,&quot;scala.concurrent.Future$&quot;,{cda:1,d:1});
var PB=void 0;function xA(){PB||(PB=(new OB).b());return PB}function AA(){}AA.prototype=new l;AA.prototype.constructor=AA;AA.prototype.b=function(){return this};AA.prototype.$classData=g({fda:0},!1,&quot;scala.concurrent.Promise$&quot;,{fda:1,d:1});var zA=void 0;function RB(){}RB.prototype=new l;RB.prototype.constructor=RB;RB.prototype.b=function(){return this};function mja(a,b,d){SB();a=b&gt;&gt;31;TB(new UB,(new Vb).ia(b,a),d)}
RB.prototype.$classData=g({lda:0},!1,&quot;scala.concurrent.duration.package$DurationInt$&quot;,{lda:1,d:1});var VB=void 0;function KA(){VB||(VB=(new RB).b());return VB}function WB(){}WB.prototype=new l;WB.prototype.constructor=WB;WB.prototype.b=function(){return this};
function Jja(a){return a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.xF?(new CA).j(a.SF):XB(a)?(new BA).ud((new YB).jc(&quot;Boxed ControlThrowable&quot;,a)):ZB(a)?(new BA).ud((new YB).jc(&quot;Boxed InterruptedException&quot;,a)):a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.Fba?(new BA).ud((new YB).jc(&quot;Boxed Error&quot;,a)):(new BA).ud(a)}WB.prototype.$classData=g({nda:0},!1,&quot;scala.concurrent.impl.Promise$&quot;,{nda:1,d:1});var $B=void 0;function aC(){}aC.prototype=new l;aC.prototype.constructor=aC;aC.prototype.b=function(){return this};
function jja(a,b){$B||($B=(new WB).b());a=Aw(b)?Jja(b.rk):b;if(zw(a))return b=new bC,b.Ci=a,b;if(Aw(a))return b=new cC,b.Ci=a,b;throw(new q).j(a);}aC.prototype.$classData=g({oda:0},!1,&quot;scala.concurrent.impl.Promise$KeptPromise$&quot;,{oda:1,d:1});var dC=void 0;function kja(){dC||(dC=(new aC).b());return dC}function eC(){}eC.prototype=new l;eC.prototype.constructor=eC;function Kja(){}Kja.prototype=eC.prototype;function Hk(){}Hk.prototype=new l;Hk.prototype.constructor=Hk;Hk.prototype.b=function(){return this};
function Eca(a,b){return Lja(Mja(b),K(function(a,b){return function(){return Eca(a,b)}}(a,b)))}Hk.prototype.$classData=g({sda:0},!1,&quot;scala.io.Source$&quot;,{sda:1,d:1});var Gk=void 0;function fC(){this.nY=this.Gp=this.ax=this.sc=this.rC=0;this.ga=null}fC.prototype=new l;fC.prototype.constructor=fC;function Nja(){}Nja.prototype=fC.prototype;
fC.prototype.Rx=function(){var a=this.ga.wf.ma();this.rC=null===a?0:a.X;var a=this.ax,b=this.Gp;this.sc=1048575&lt;=a?2147481600:a&lt;&lt;11|(2047&lt;b?2047:b);switch(this.rC){case 10:this.Gp=1;this.ax=1+this.ax|0;break;case 9:this.Gp=this.Gp+this.nY|0;break;default:this.Gp=1+this.Gp|0}return this.rC};fC.prototype.rba=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;this.sc=0;this.Gp=this.ax=1;this.nY=4;return this};function gC(){}gC.prototype=new l;gC.prototype.constructor=gC;gC.prototype.b=function(){return this};
gC.prototype.$classData=g({Eda:0},!1,&quot;scala.math.Ordered$&quot;,{Eda:1,d:1});var Oja=void 0;function hC(){this.Th=this.bS=this.eG=null;this.ya=0}hC.prototype=new l;hC.prototype.constructor=hC;
hC.prototype.b=function(){iC=this;(new jC).b();kC||(kC=(new lC).b());Lc();r();Mk();mC();B();y();Pja||(Pja=(new nC).b());Qja||(Qja=(new oC).b());Rja||(Rja=(new pC).b());this.bS=Ng();Sja||(Sja=(new qC).b());this.Th=Lk();Tja||(Tja=(new rC).b());ao();Uja||(Uja=(new sC).b());Vja||(Vja=(new tC).b());Wja||(Wja=(new uC).b());Xja||(Xja=(new vC).b());Oja||(Oja=(new gC).b());Yja||(Yja=(new wC).b());Zja||(Zja=(new xC).b());$ja||($ja=(new yC).b());aka||(aka=(new zC).b());return this};
hC.prototype.$classData=g({Jda:0},!1,&quot;scala.package$&quot;,{Jda:1,d:1});var iC=void 0;function pc(){iC||(iC=(new hC).b());return iC}function AC(){}AC.prototype=new l;AC.prototype.constructor=AC;AC.prototype.b=function(){BC=this;CC();DC();EC();FC();GC();nj();HC();IC();JC();bka||(bka=(new KC).b());LC();cka||(cka=(new MC).b());dka();eka();return this};AC.prototype.$classData=g({Lda:0},!1,&quot;scala.reflect.ClassManifestFactory$&quot;,{Lda:1,d:1});var BC=void 0;function NC(){}NC.prototype=new l;
NC.prototype.constructor=NC;NC.prototype.b=function(){return this};NC.prototype.$classData=g({Oda:0},!1,&quot;scala.reflect.ManifestFactory$&quot;,{Oda:1,d:1});var fka=void 0;function OC(){}OC.prototype=new l;OC.prototype.constructor=OC;OC.prototype.b=function(){PC=this;BC||(BC=(new AC).b());fka||(fka=(new NC).b());return this};OC.prototype.$classData=g({dea:0},!1,&quot;scala.reflect.package$&quot;,{dea:1,d:1});var PC=void 0;function QC(){PC||(PC=(new OC).b())}function RC(){}RC.prototype=new l;
RC.prototype.constructor=RC;RC.prototype.b=function(){return this};function Un(a,b){throw Kg(Lg(),(new $g).c(b));}RC.prototype.$classData=g({eea:0},!1,&quot;scala.sys.package$&quot;,{eea:1,d:1});var SC=void 0;function Vn(){SC||(SC=(new RC).b());return SC}function TC(){this.Ac=null}TC.prototype=new l;TC.prototype.constructor=TC;TC.prototype.k=function(){return&quot;DynamicVariable(&quot;+this.Ac+&quot;)&quot;};TC.prototype.j=function(a){this.Ac=a;return this};
TC.prototype.$classData=g({fea:0},!1,&quot;scala.util.DynamicVariable&quot;,{fea:1,d:1});function UC(){}UC.prototype=new l;UC.prototype.constructor=UC;UC.prototype.b=function(){(new VC).b();return this};UC.prototype.$classData=g({lea:0},!1,&quot;scala.util.control.Breaks&quot;,{lea:1,d:1});function XB(a){return!!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.CW)}function WC(){this.lV=null}WC.prototype=new l;WC.prototype.constructor=WC;
WC.prototype.b=function(){XC=this;this.lV=gka(m(new n,function(){return function(){return!1}}(this)),m(new n,function(){return function(a){throw Kg(Lg(),a);}}(this)));var a=YC(new ZC,this.lV,F(),hka());mba(a,&quot;\x3cnothing\x3e&quot;);return this};function ika(a,b,d){return d.le(m(new n,function(a,b){return function(a){return Sl(a,oa(b))}}(a,b)))}
function jka(){var a=$C(),b=(new w).f([pa(kka)]),d=YC(new ZC,(new aD).K(b),F(),hka()),a=m(new n,function(){return function(a){return a.kh()}}(a)),e=r(),b=b.xa(a,e.s).zb(&quot;, &quot;);return mba(d,b)}function gka(a,b){var d=(new Qn).xg(pa(Oq)),e=new bD;e.tU=a;e.$i=b;e.Xt=d;return e}WC.prototype.$classData=g({mea:0},!1,&quot;scala.util.control.Exception$&quot;,{mea:1,d:1});var XC=void 0;function $C(){XC||(XC=(new WC).b());return XC}function cD(){}cD.prototype=new l;cD.prototype.constructor=cD;cD.prototype.b=function(){return this};
function hka(){dD||(dD=(new cD).b());return m(new n,function(){return function(a){$C();return XB(a)||ZB(a)}}(dD))}cD.prototype.$classData=g({qea:0},!1,&quot;scala.util.control.Exception$Catch$&quot;,{qea:1,d:1});var dD=void 0;function eD(){}eD.prototype=new l;eD.prototype.constructor=eD;eD.prototype.b=function(){return this};function Fw(a,b){return b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.goa||b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.foa||ZB(b)||b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.eoa||XB(b)?F():(new J).j(b)}
eD.prototype.$classData=g({uea:0},!1,&quot;scala.util.control.NonFatal$&quot;,{uea:1,d:1});var fD=void 0;function Gw(){fD||(fD=(new eD).b());return fD}function gD(){}gD.prototype=new l;gD.prototype.constructor=gD;function lka(){}lka.prototype=gD.prototype;gD.prototype.zs=function(a,b){b=da(-862048943,b);b=da(461845907,b&lt;&lt;15|b&gt;&gt;&gt;17|0);return a^b};gD.prototype.da=function(a,b){a=this.zs(a,b);return-430675100+da(5,a&lt;&lt;13|a&gt;&gt;&gt;19|0)|0};
function R(a,b){var d=b.v();if(0===d)return a=b.u(),Ha(Ia(),a);for(var e=-889275714,f=0;f&lt;d;)e=a.da(e,hD(V(),b.w(f))),f=1+f|0;return a.tb(e,d)}function iD(a,b,d){var e=(new jD).Db(0),f=(new jD).Db(0),h=(new jD).Db(0),k=(new jD).Db(1);b.wa(m(new n,function(a,b,d,e,f){return function(a){a=hD(V(),a);b.Ba=b.Ba+a|0;d.Ba^=a;0!==a&amp;&amp;(f.Ba=da(f.Ba,a));e.Ba=1+e.Ba|0}}(a,e,f,h,k)));b=a.da(d,e.Ba);b=a.da(b,f.Ba);b=a.zs(b,k.Ba);return a.tb(b,h.Ba)}
gD.prototype.tb=function(a,b){a^=b;a=da(-2048144789,a^(a&gt;&gt;&gt;16|0));a=da(-1028477387,a^(a&gt;&gt;&gt;13|0));return a^(a&gt;&gt;&gt;16|0)};function mka(a,b,d){var e=(new jD).Db(0);d=(new jD).Db(d);b.wa(m(new n,function(a,b,d){return function(e){d.Ba=a.da(d.Ba,hD(V(),e));b.Ba=1+b.Ba|0}}(a,e,d)));return a.tb(d.Ba,e.Ba)}function kD(){}kD.prototype=new l;kD.prototype.constructor=kD;kD.prototype.b=function(){return this};
function nka(a,b){a=da(-1640532531,b);Hi();return da(-1640532531,a&lt;&lt;24|16711680&amp;a&lt;&lt;8|65280&amp;(a&gt;&gt;&gt;8|0)|a&gt;&gt;&gt;24|0)}kD.prototype.$classData=g({wea:0},!1,&quot;scala.util.hashing.package$&quot;,{wea:1,d:1});var lD=void 0;function oka(){lD||(lD=(new kD).b());return lD}function mD(){}mD.prototype=new l;mD.prototype.constructor=mD;function qea(a,b){return He(b)?(new J).j((new A).e(b.Bk,b.be)):Ge(b)?(new J).j((new A).e(b.Bk,b.be)):F()}mD.prototype.To=function(){return this};
mD.prototype.$classData=g({Fea:0},!1,&quot;scala.util.parsing.combinator.Parsers$NoSuccess$&quot;,{Fea:1,d:1});function nD(){this.ga=null}nD.prototype=new l;nD.prototype.constructor=nD;function oD(){}oD.prototype=nD.prototype;nD.prototype.To=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};function pD(){}pD.prototype=new l;pD.prototype.constructor=pD;function pka(){}pka.prototype=pD.prototype;function pC(){}pC.prototype=new l;pC.prototype.constructor=pC;pC.prototype.b=function(){return this};
pC.prototype.$classData=g({Gea:0},!1,&quot;scala.collection.$colon$plus$&quot;,{Gea:1,d:1});var Rja=void 0;function oC(){}oC.prototype=new l;oC.prototype.constructor=oC;oC.prototype.b=function(){return this};oC.prototype.$classData=g({Hea:0},!1,&quot;scala.collection.$plus$colon$&quot;,{Hea:1,d:1});var Qja=void 0;function qD(){this.Rd=null}qD.prototype=new l;qD.prototype.constructor=qD;qD.prototype.b=function(){rD=this;this.Rd=(new sD).b();return this};
qD.prototype.$classData=g({Oea:0},!1,&quot;scala.collection.Iterator$&quot;,{Oea:1,d:1});var rD=void 0;function mC(){rD||(rD=(new qD).b());return rD}function tD(a,b,d){a.we(b,d,uD(W(),b)-d|0)}function vD(a,b){b=b.Uh();b.Yb(a.mb());return b.Da()}function wD(a,b){var d=(new jD).Db(0);a.wa(m(new n,function(a,b,d){return function(a){b.y(a)&amp;&amp;(d.Ba=1+d.Ba|0)}}(a,b,d)));return d.Ba}function cc(a,b,d,e){return a.Lf((new Fm).b(),b,d,e).vc.Zb}
function Zl(a,b,d){b=(new nm).j(b);a.wa(m(new n,function(a,b,d){return function(a){d.Ba=rb(b,d.Ba,a)}}(a,d,b)));return b.Ba}function os(a){var b=(new jD).Db(0);a.wa(m(new n,function(a,b){return function(){b.Ba=1+b.Ba|0}}(a,b)));return b.Ba}
function Mg(a,b){var d=(new te).b();try{if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.Zc)var e=a;else{if(!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.Jb))return a.wa(b.nm(m(new n,function(a,b){return function(a){throw(new xD).e(b,(new J).j(a));}}(a,d)))),F();e=a.Bg()}for(var f=new yD;e.ta();){var h=b.db(e.ma(),f);if(h!==f)return(new J).j(h)}return F()}catch(k){if(k&amp;&amp;k.$classData&amp;&amp;k.$classData.n.xF&amp;&amp;k.PU===d)return k.SF;throw k;}}
function zD(a,b,d,e,f){var h=(new AD).td(!0);js(b,d);a.wa(m(new n,function(a,b,d,e){return function(a){if(e.Ba)ks(b,a),e.Ba=!1;else return js(b,d),ks(b,a)}}(a,b,e,h)));js(b,f);return b}function BD(a,b){return a.Gb(0,tb(new ub,function(){return function(a,b){return(a|0)+(b|0)|0}}(a,b)))}function CD(a,b){return a.yg()?(b=b.Mg(a.Ga()),a.tg(b,0),b):a.Nd().se(b)}function kd(a){return!a.z()}
function DD(a,b){if(a.z())throw(new Ul).c(&quot;empty.reduceLeft&quot;);var d=(new AD).td(!0),e=(new nm).j(0);a.wa(m(new n,function(a,b,d,e){return function(a){d.Ba?(e.Ba=a,d.Ba=!1):e.Ba=rb(b,e.Ba,a)}}(a,b,d,e)));return e.Ba}function ED(){}ED.prototype=new l;ED.prototype.constructor=ED;function qka(){}qka.prototype=ED.prototype;function nh(a,b){return a.bb().Yb(b).Da()}ED.prototype.bb=function(){return dc(new ec,this.Ur())};function FD(){}FD.prototype=new l;FD.prototype.constructor=FD;function rka(){}
rka.prototype=FD.prototype;function GD(){}GD.prototype=new l;GD.prototype.constructor=GD;function HD(){}HD.prototype=GD.prototype;function I(a,b){if(b.z())return a.Do();a=a.bb();a.Yb(b);return a.Da()}GD.prototype.Do=function(){return this.bb().Da()};function ska(a,b){var d=a.md().bb();a.mb().wa(m(new n,function(a,b,d){return function(a){return d.Yb(b.y(a).mb())}}(a,b,d)));return d.Da()}function tka(a,b){a:for(;;){if(kd(b)){a.ld(b.$());b=b.aa();continue a}break}}
function ID(a,b){b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.gp?tka(a,b):b.wa(m(new n,function(a){return function(b){return a.ld(b)}}(a)));return a}function JD(){}JD.prototype=new l;JD.prototype.constructor=JD;function KD(){}KD.prototype=JD.prototype;function qC(){}qC.prototype=new l;qC.prototype.constructor=qC;qC.prototype.b=function(){return this};qC.prototype.$classData=g({aga:0},!1,&quot;scala.collection.immutable.Stream$$hash$colon$colon$&quot;,{aga:1,d:1});var Sja=void 0;function LD(){this.IF=null}LD.prototype=new l;
LD.prototype.constructor=LD;LD.prototype.yc=function(a){this.IF=a;return this};function uka(a,b){return MD(new ND,b,a.IF)}function vka(a,b){return OD(b,a.IF)}LD.prototype.$classData=g({bga:0},!1,&quot;scala.collection.immutable.Stream$ConsWrapper&quot;,{bga:1,d:1});function PD(){this.yF=this.Ac=null;this.ya=!1;this.ga=null}PD.prototype=new l;PD.prototype.constructor=PD;function QD(a,b,d){a.yF=d;if(null===b)throw Kg(Lg(),null);a.ga=b;return a}
function RD(a){a.ya||(a.ya||(a.Ac=Ee(a.yF),a.ya=!0),a.yF=null);return a.Ac}PD.prototype.$classData=g({gga:0},!1,&quot;scala.collection.immutable.StreamIterator$LazyCell&quot;,{gga:1,d:1});function SD(){}SD.prototype=new l;SD.prototype.constructor=SD;SD.prototype.b=function(){return this};function Ye(a,b,d,e){a=0&gt;d?0:d;return e&lt;=a||a&gt;=(b.length|0)?&quot;&quot;:b.substring(a,e&gt;(b.length|0)?b.length|0:e)}SD.prototype.$classData=g({iga:0},!1,&quot;scala.collection.immutable.StringOps$&quot;,{iga:1,d:1});var TD=void 0;
function Ze(){TD||(TD=(new SD).b());return TD}function UD(){}UD.prototype=new l;UD.prototype.constructor=UD;UD.prototype.b=function(){return this};UD.prototype.bb=function(){var a=(new Fm).b();return VD(new WD,a,m(new n,function(){return function(a){return(new Dj).c(a)}}(this)))};UD.prototype.$classData=g({qga:0},!1,&quot;scala.collection.immutable.WrappedString$&quot;,{qga:1,d:1});var XD=void 0;function YD(){}YD.prototype=new l;YD.prototype.constructor=YD;YD.prototype.b=function(){return this};
YD.prototype.$classData=g({uga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofBoolean$&quot;,{uga:1,d:1});var wka=void 0;function ZD(){}ZD.prototype=new l;ZD.prototype.constructor=ZD;ZD.prototype.b=function(){return this};ZD.prototype.$classData=g({vga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofByte$&quot;,{vga:1,d:1});var xka=void 0;function $D(){}$D.prototype=new l;$D.prototype.constructor=$D;$D.prototype.b=function(){return this};
$D.prototype.$classData=g({wga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofChar$&quot;,{wga:1,d:1});var yka=void 0;function aE(){}aE.prototype=new l;aE.prototype.constructor=aE;aE.prototype.b=function(){return this};aE.prototype.$classData=g({xga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofDouble$&quot;,{xga:1,d:1});var zka=void 0;function bE(){}bE.prototype=new l;bE.prototype.constructor=bE;bE.prototype.b=function(){return this};
bE.prototype.$classData=g({yga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofFloat$&quot;,{yga:1,d:1});var Aka=void 0;function cE(){}cE.prototype=new l;cE.prototype.constructor=cE;cE.prototype.b=function(){return this};cE.prototype.$classData=g({zga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofInt$&quot;,{zga:1,d:1});var Bka=void 0;function dE(){}dE.prototype=new l;dE.prototype.constructor=dE;dE.prototype.b=function(){return this};
dE.prototype.$classData=g({Aga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofLong$&quot;,{Aga:1,d:1});var Cka=void 0;function eE(){}eE.prototype=new l;eE.prototype.constructor=eE;eE.prototype.b=function(){return this};eE.prototype.$classData=g({Bga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofRef$&quot;,{Bga:1,d:1});var Dka=void 0;function fE(){}fE.prototype=new l;fE.prototype.constructor=fE;fE.prototype.b=function(){return this};
fE.prototype.$classData=g({Cga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofShort$&quot;,{Cga:1,d:1});var Eka=void 0;function gE(){}gE.prototype=new l;gE.prototype.constructor=gE;gE.prototype.b=function(){return this};gE.prototype.$classData=g({Dga:0},!1,&quot;scala.collection.mutable.ArrayOps$ofUnit$&quot;,{Dga:1,d:1});var Fka=void 0;function Gka(a){return hE(Hi(),-1+a.Vb.l.length|0)}
function Hka(a,b){for(var d=Ga(b),d=iE(a,d),e=a.Vb.l[d];null!==e;){if(sn(tn(),e,b))return;d=(1+d|0)%a.Vb.l.length|0;e=a.Vb.l[d]}a.Vb.l[d]=b;a.Cf=1+a.Cf|0;null!==a.Jf&amp;&amp;(b=d&gt;&gt;5,d=a.Jf,d.l[b]=1+d.l[b]|0);if(a.Cf&gt;=a.Ik)for(b=a.Vb,a.Vb=la(Xa(Ua),[a.Vb.l.length&lt;&lt;1]),a.Cf=0,null!==a.Jf&amp;&amp;(d=1+(a.Vb.l.length&gt;&gt;5)|0,a.Jf.l.length!==d?a.Jf=la(Xa(db),[d]):rja(gB(),a.Jf)),a.ul=Gka(a),a.Ik=Ika().Ou(a.Fl,a.Vb.l.length),d=0;d&lt;b.l.length;)e=b.l[d],null!==e&amp;&amp;Hka(a,e),d=1+d|0}
function iE(a,b){var d=a.ul;b=nka(oka(),b);a=-1+a.Vb.l.length|0;return((b&gt;&gt;&gt;d|0|b&lt;&lt;(-d|0))&gt;&gt;&gt;(32-hE(Hi(),a)|0)|0)&amp;a}function jE(a,b){b=hf(b);for(var d=Ga(b),d=iE(a,d),e=a.Vb.l[d];null!==e&amp;&amp;!sn(tn(),e,b);)d=(1+d|0)%a.Vb.l.length|0,e=a.Vb.l[d];return e}function kE(){}kE.prototype=new l;kE.prototype.constructor=kE;kE.prototype.b=function(){return this};
kE.prototype.Ou=function(a,b){if(!(500&gt;a))throw(new lE).j(&quot;assertion failed: loadFactor too large; must be \x3c 0.5&quot;);var d=b&gt;&gt;31,e=a&gt;&gt;31,f=65535&amp;b,h=b&gt;&gt;&gt;16|0,k=65535&amp;a,p=a&gt;&gt;&gt;16|0,t=da(f,k),k=da(h,k),x=da(f,p),f=t+((k+x|0)&lt;&lt;16)|0,t=(t&gt;&gt;&gt;16|0)+x|0;a=(((da(b,e)+da(d,a)|0)+da(h,p)|0)+(t&gt;&gt;&gt;16|0)|0)+(((65535&amp;t)+k|0)&gt;&gt;&gt;16|0)|0;return Df(Ra(),f,a,1E3,0)};kE.prototype.$classData=g({Mga:0},!1,&quot;scala.collection.mutable.FlatHashTable$&quot;,{Mga:1,d:1});var mE=void 0;
function Ika(){mE||(mE=(new kE).b());return mE}function nE(){}nE.prototype=new l;nE.prototype.constructor=nE;nE.prototype.b=function(){return this};nE.prototype.k=function(){return&quot;NullSentinel&quot;};nE.prototype.r=function(){return 0};nE.prototype.$classData=g({Oga:0},!1,&quot;scala.collection.mutable.FlatHashTable$NullSentinel$&quot;,{Oga:1,d:1});var oE=void 0;function xba(){oE||(oE=(new nE).b());return oE}function Jka(a){return hE(Hi(),-1+a.Vb.l.length|0)}
function Kka(a){for(var b=-1+a.Vb.l.length|0;0&lt;=b;)a.Vb.l[b]=null,b=-1+b|0;a.Uq(0);Lka(a,0)}function Mka(a,b,d){for(a=a.Vb.l[d];;)if(null!==a?(d=a.fj(),d=!sn(tn(),d,b)):d=!1,d)a=a.ma();else break;return a}function pE(a,b){var d=-1+a.Vb.l.length|0,e=fa(d);a=a.ul;b=nka(oka(),b);return((b&gt;&gt;&gt;a|0|b&lt;&lt;(-a|0))&gt;&gt;&gt;e|0)&amp;d}function Nka(a){a.cz(750);qE();a.Ay(la(Xa(zba),[rE(0,16)]));a.Uq(0);var b=a.Fl,d=qE();qE();a.Cy(d.Ou(b,rE(0,16)));a.wy(null);a.tF(Jka(a))}
function sE(a,b){var d=hD(V(),b),d=pE(a,d),e=a.Vb.l[d];if(null!==e){var f=e.fj();if(sn(tn(),f,b))return a.Vb.l[d]=e.ma(),a.Uq(-1+a.Cf|0),Oka(a,d),e.As(null),e;for(f=e.ma();;){if(null!==f)var h=f.fj(),h=!sn(tn(),h,b);else h=!1;if(h)e=f,f=f.ma();else break}if(null!==f)return e.As(f.ma()),a.Uq(-1+a.Cf|0),Oka(a,d),f.As(null),f}return null}function tE(a){for(var b=-1+a.Vb.l.length|0;null===a.Vb.l[b]&amp;&amp;0&lt;b;)b=-1+b|0;return b}
function uE(a,b,d){var e=hD(V(),b),e=pE(a,e),f=Mka(a,b,e);if(null!==f)return f;b=a.cT(b,d);Pka(a,b,e);return null}function vE(a,b){var d=hD(V(),b),d=pE(a,d);return Mka(a,b,d)}
function Pka(a,b,d){b.As(a.Vb.l[d]);a.Vb.l[d]=b;a.Uq(1+a.Cf|0);wE(a,d);if(a.Cf&gt;a.Ik){b=a.Vb.l.length&lt;&lt;1;d=a.Vb;a.Ay(la(Xa(zba),[b]));Lka(a,a.Vb.l.length);for(var e=-1+d.l.length|0;0&lt;=e;){for(var f=d.l[e];null!==f;){var h=f.fj(),h=hD(V(),h),h=pE(a,h),k=f.ma();f.As(a.Vb.l[h]);a.Vb.l[h]=f;f=k;wE(a,h)}e=-1+e|0}a.Cy(qE().Ou(a.Fl,b))}}function Oka(a,b){null!==a.Jf&amp;&amp;(a=a.Jf,b&gt;&gt;=5,a.l[b]=-1+a.l[b]|0)}function Lka(a,b){null!==a.Jf&amp;&amp;(b=1+(b&gt;&gt;5)|0,a.Jf.l.length!==b?a.wy(la(Xa(db),[b])):rja(gB(),a.Jf))}
function wE(a,b){null!==a.Jf&amp;&amp;(a=a.Jf,b&gt;&gt;=5,a.l[b]=1+a.l[b]|0)}function xE(){}xE.prototype=new l;xE.prototype.constructor=xE;xE.prototype.b=function(){return this};function rE(a,b){return 1&lt;&lt;(-fa(-1+b|0)|0)}xE.prototype.Ou=function(a,b){var d=b&gt;&gt;31,e=a&gt;&gt;31,f=65535&amp;b,h=b&gt;&gt;&gt;16|0,k=65535&amp;a,p=a&gt;&gt;&gt;16|0,t=da(f,k),k=da(h,k),x=da(f,p),f=t+((k+x|0)&lt;&lt;16)|0,t=(t&gt;&gt;&gt;16|0)+x|0;a=(((da(b,e)+da(d,a)|0)+da(h,p)|0)+(t&gt;&gt;&gt;16|0)|0)+(((65535&amp;t)+k|0)&gt;&gt;&gt;16|0)|0;return Df(Ra(),f,a,1E3,0)};
xE.prototype.$classData=g({Wga:0},!1,&quot;scala.collection.mutable.HashTable$&quot;,{Wga:1,d:1});var yE=void 0;function qE(){yE||(yE=(new xE).b());return yE}function zE(){this.pd=0;this.PC=this.qC=this.ne=this.Bh=null}zE.prototype=new l;zE.prototype.constructor=zE;c=zE.prototype;c.hU=function(a,b,d,e,f){this.pd=a;this.Bh=b;this.ne=d;this.qC=e;this.PC=f;return this};c.W=function(a){var b=this;for(;;){if(a&lt;b.pd)return AE(W(),b.Bh,a);a=a-b.pd|0;b=b.ne}};
c.nf=function(a,b){var d=this;a:for(;;){if(a&lt;d.pd)BE(W(),d.Bh,a,b);else{a=a-d.pd|0;d=d.ne;continue a}break}};
c.k=function(){$e();var a=Dw($e(),this.Bh),a=Dw(0,CE(a,0,this.pd)),b=(new Sb).c(&quot;Unrolled@%08x&quot;),d=[Ka(this)];Ia();b=b.R;r();Zn();for(var e=[],f=0,h=d.length|0;f&lt;h;){var k=d[f];e.push(DE(k)?k.AY():k);f=1+f|0}LC();for(var d=e.length|0,d=la(Xa(Ua),[d]),k=d.l.length,h=f=0,p=e.length|0,k=p&lt;k?p:k,p=d.l.length,k=k&lt;p?k:p;f&lt;k;)d.l[h]=e[f],f=1+f|0,h=1+h|0;e=(new EE).b();b=Qka(Rka(e,b,d)).k();e.qo();b=b+&quot;[&quot;+this.pd+&quot;/&quot;+uD(W(),this.Bh)+&quot;](&quot;;return cc(a,b,&quot;, &quot;,&quot;)&quot;)+&quot; -\x3e &quot;+(null!==this.ne?this.ne.k():&quot;&quot;)};
c.wa=function(a){for(var b=this,d=0;null!==b;){for(var e=b.Bh,f=b.pd;d&lt;f;){var h=AE(W(),e,d);a.y(h);d=1+d|0}d=0;b=b.ne}};function Ska(a){return null===a.qC?FE().QF:uD(W(),a.Bh)}c.$classData=g({yha:0},!1,&quot;scala.collection.mutable.UnrolledBuffer$Unrolled&quot;,{yha:1,d:1});function rB(){this.CG=null}rB.prototype=new l;rB.prototype.constructor=rB;rB.prototype.b=function(){qB=this;this.CG=(new Fi).Gh(la(Xa(Ua),[0]));return this};
rB.prototype.$classData=g({zha:0},!1,&quot;scala.collection.mutable.WrappedArray$&quot;,{zha:1,d:1});var qB=void 0;function NB(){this.UV=null}NB.prototype=new l;NB.prototype.constructor=NB;NB.prototype.b=function(){MB=this;Tka||(Tka=(new GE).b());Uka||(Uka=(new HE).b());this.UV=void 0===ba.Promise?(new IE).b():(new JE).b();return this};NB.prototype.$classData=g({Bha:0},!1,&quot;scala.scalajs.concurrent.JSExecutionContext$&quot;,{Bha:1,d:1});var MB=void 0;function HE(){}HE.prototype=new l;HE.prototype.constructor=HE;
HE.prototype.b=function(){return this};HE.prototype.$classData=g({Cha:0},!1,&quot;scala.scalajs.concurrent.QueueExecutionContext$&quot;,{Cha:1,d:1});var Uka=void 0;function hv(){}hv.prototype=new l;hv.prototype.constructor=hv;hv.prototype.b=function(){return this};function Yga(a,b){var d={};b.Vn(m(new n,function(){return function(a){return null!==a}}(a))).wa(m(new n,function(a,b){return function(a){if(null!==a)b[a.la()]=a.pa();else throw(new q).j(a);}}(a,d)));return d}
hv.prototype.$classData=g({Hha:0},!1,&quot;scala.scalajs.js.Dictionary$&quot;,{Hha:1,d:1});var gv=void 0;function KE(){this.qm=null}KE.prototype=new l;KE.prototype.constructor=KE;KE.prototype.b=function(){LE=this;this.qm=ba.Object.prototype.hasOwnProperty;return this};KE.prototype.$classData=g({Nha:0},!1,&quot;scala.scalajs.js.WrappedDictionary$Cache$&quot;,{Nha:1,d:1});var LE=void 0;function Wu(){LE||(LE=(new KE).b());return LE}function ME(){this.ip=!1;this.YC=this.qs=this.wt=null;this.nC=!1;this.mE=this.gD=0}
ME.prototype=new l;ME.prototype.constructor=ME;ME.prototype.b=function(){NE=this;this.wt=(this.ip=!!(ba.ArrayBuffer&amp;&amp;ba.Int32Array&amp;&amp;ba.Float32Array&amp;&amp;ba.Float64Array))?new ba.ArrayBuffer(8):null;this.qs=this.ip?new ba.Int32Array(this.wt,0,2):null;this.ip&amp;&amp;new ba.Float32Array(this.wt,0,2);this.YC=this.ip?new ba.Float64Array(this.wt,0,1):null;if(this.ip)this.qs[0]=16909060,a=1===((new ba.Int8Array(this.wt,0,8))[0]|0);else var a=!0;this.gD=(this.nC=a)?0:1;this.mE=this.nC?1:0;return this};
function daa(a,b){var d=b|0;if(d===b&amp;&amp;-Infinity!==1/b)return d;if(a.ip)a.YC[0]=b,a=(new Vb).ia(a.qs[a.mE]|0,a.qs[a.gD]|0);else{if(b!==b)a=!1,b=2047,d=+ba.Math.pow(2,51);else if(Infinity===b||-Infinity===b)a=0&gt;b,b=2047,d=0;else if(0===b)a=-Infinity===1/b,d=b=0;else{var e=(a=0&gt;b)?-b:b;if(e&gt;=+ba.Math.pow(2,-1022)){b=+ba.Math.pow(2,52);var d=+ba.Math.log(e)/.6931471805599453,d=+ba.Math.floor(d)|0,d=1023&gt;d?d:1023,f=+ba.Math.pow(2,d);f&gt;e&amp;&amp;(d=-1+d|0,f/=2);f=e/f*b;e=+ba.Math.floor(f);f-=e;e=.5&gt;f?e:.5&lt;f?1+
e:0!==e%2?1+e:e;2&lt;=e/b&amp;&amp;(d=1+d|0,e=1);1023&lt;d?(d=2047,e=0):(d=1023+d|0,e-=b);b=d;d=e}else b=e/+ba.Math.pow(2,-1074),d=+ba.Math.floor(b),e=b-d,b=0,d=.5&gt;e?d:.5&lt;e?1+d:0!==d%2?1+d:d}d=+d;a=(new Vb).ia(d|0,(a?-2147483648:0)|(b|0)&lt;&lt;20|d/4294967296|0)}return a.ka^a.qa}
function Vka(a){var b=a.qa,d=0&gt;b,e=2047&amp;b&gt;&gt;20;a=4294967296*(1048575&amp;b)+ +(a.ka&gt;&gt;&gt;0);return 2047===e?0!==a?NaN:d?-Infinity:Infinity:0&lt;e?(e=+ba.Math.pow(2,-1023+e|0)*(1+a/+ba.Math.pow(2,52)),d?-e:e):0!==a?(e=+ba.Math.pow(2,-1022)*(a/+ba.Math.pow(2,52)),d?-e:e):d?-0:0}ME.prototype.$classData=g({Vha:0},!1,&quot;scala.scalajs.runtime.Bits$&quot;,{Vha:1,d:1});var NE=void 0;function Ja(){NE||(NE=(new ME).b());return NE}function OE(){this.ya=!1}OE.prototype=new l;OE.prototype.constructor=OE;
function Wp(a,b,d){return b.substring((b.length|0)-(d.length|0)|0)===d}OE.prototype.b=function(){return this};function PE(a,b){a=b.length|0;for(var d=la(Xa(ab),[a]),e=0;e&lt;a;)d.l[e]=65535&amp;(b.charCodeAt(e)|0),e=1+e|0;return d}
function QE(a,b,d){if(null===b)throw(new Oe).b();a=Eg(Dg(),d);b=na(b);if(&quot;&quot;===b)for(d=(new w).f([&quot;&quot;]),b=d.oa.length|0,b=la(Xa(qa),[b]),a=0,d=lf(new mf,d,0,d.oa.length|0);d.ta();){var e=d.ma();b.l[a]=e;a=1+a|0}else{d=Fg(new Gg,a,b,b.length|0);a=[];for(var f=0,e=0;2147483646&gt;e&amp;&amp;oi(d);){if(0!==d.Wm()){var h=d.vl(),f=b.substring(f,h);a.push(null===f?null:f);e=1+e|0}f=d.Wm()}b=b.substring(f);a.push(null===b?null:b);b=ka(Xa(qa),a);for(a=b.l.length;0!==a&amp;&amp;&quot;&quot;===b.l[-1+a|0];)a=-1+a|0;a!==b.l.length&amp;&amp;(d=la(Xa(qa),
[a]),Oa(b,0,d,0,a),b=d)}return b}function DB(a,b){return null===b?&quot;null&quot;:na(b)}function Ew(a,b,d){a=Wka(d);return b.indexOf(a)|0}function RE(a,b,d,e){a=d+e|0;if(0&gt;d||a&lt;d||a&gt;b.l.length)throw(new SE).b();for(e=&quot;&quot;;d!==a;)e=&quot;&quot;+e+ba.String.fromCharCode(b.l[d]),d=1+d|0;return e}function Wka(a){if(0===(-65536&amp;a))return ba.String.fromCharCode(a);if(0&gt;a||1114111&lt;a)throw(new df).b();a=-65536+a|0;return ba.String.fromCharCode(55296|a&gt;&gt;10,56320|1023&amp;a)}
function Ha(a,b){a=0;for(var d=1,e=-1+(b.length|0)|0;0&lt;=e;)a=a+da(65535&amp;(b.charCodeAt(e)|0),d)|0,d=da(31,d),e=-1+e|0;return a}function Qb(a,b,d,e){if(null===b)throw(new Oe).b();a=Eg(Dg(),d);b=Fg(new Gg,a,b,b.length|0);ro(b);for(a=(new so).b();oi(b);)to(b,a,e);uo(b,a);return a.Zb}OE.prototype.$classData=g({Xha:0},!1,&quot;scala.scalajs.runtime.RuntimeString$&quot;,{Xha:1,d:1});var TE=void 0;function Ia(){TE||(TE=(new OE).b());return TE}function UE(){this.vU=!1;this.YS=this.gT=this.fT=null;this.ya=0}
UE.prototype=new l;UE.prototype.constructor=UE;UE.prototype.b=function(){return this};function Xka(a){return(a.stack+&quot;\n&quot;).replace(VE(&quot;^[\\s\\S]+?\\s+at\\s+&quot;),&quot; at &quot;).replace(WE(&quot;^\\s+(at eval )?at\\s+&quot;,&quot;gm&quot;),&quot;&quot;).replace(WE(&quot;^([^\\(]+?)([\\n])&quot;,&quot;gm&quot;),&quot;{anonymous}() ($1)$2&quot;).replace(WE(&quot;^Object.\x3canonymous\x3e\\s*\\(([^\\)]+)\\)&quot;,&quot;gm&quot;),&quot;{anonymous}() ($1)&quot;).replace(WE(&quot;^([^\\(]+|\\{anonymous\\}\\(\\)) \\((.+)\\)$&quot;,&quot;gm&quot;),&quot;$1@$2&quot;).split(&quot;\n&quot;).slice(0,-1)}
function Yka(a){0===(8&amp;a.ya)&amp;&amp;0===(8&amp;a.ya)&amp;&amp;(a.YS=ba.Object.keys(Zka(a)),a.ya=(8|a.ya)&lt;&lt;24&gt;&gt;24);return a.YS}function $ka(a){if(0===(2&amp;a.ya)&amp;&amp;0===(2&amp;a.ya)){for(var b={O:&quot;java_lang_Object&quot;,T:&quot;java_lang_String&quot;,V:&quot;scala_Unit&quot;,Z:&quot;scala_Boolean&quot;,C:&quot;scala_Char&quot;,B:&quot;scala_Byte&quot;,S:&quot;scala_Short&quot;,I:&quot;scala_Int&quot;,J:&quot;scala_Long&quot;,F:&quot;scala_Float&quot;,D:&quot;scala_Double&quot;},d=0;22&gt;=d;)2&lt;=d&amp;&amp;(b[&quot;T&quot;+d]=&quot;scala_Tuple&quot;+d),b[&quot;F&quot;+d]=&quot;scala_Function&quot;+d,d=1+d|0;a.fT=b;a.ya=(2|a.ya)&lt;&lt;24&gt;&gt;24}return a.fT}
function ala(a,b){var d=VE(&quot;^(?:Object\\.|\\[object Object\\]\\.)?(?:ScalaJS\\.c\\.|\\$c_)([^\\.]+)(?:\\.prototype)?\\.([^\\.]+)$&quot;),e=VE(&quot;^(?:Object\\.|\\[object Object\\]\\.)?(?:ScalaJS\\.(?:s|f)\\.|\\$(?:s|f)_)((?:_[^_]|[^_])+)__([^\\.]+)$&quot;),f=VE(&quot;^(?:Object\\.|\\[object Object\\]\\.)?(?:ScalaJS\\.m\\.|\\$m_)([^\\.]+)$&quot;),h=!1,d=d.exec(b);null===d&amp;&amp;(d=e.exec(b),null===d&amp;&amp;(d=f.exec(b),h=!0));if(null!==d){b=d[1];if(void 0===b)throw(new Xu).c(&quot;undefined.get&quot;);b=36===(65535&amp;(b.charCodeAt(0)|0))?b.substring(1):
b;e=$ka(a);if(Wu().qm.call(e,b)){a=$ka(a);if(!Wu().qm.call(a,b))throw(new Xu).c(&quot;key not found: &quot;+b);a=a[b]}else a:for(f=0;;)if(f&lt;(Yka(a).length|0)){e=Yka(a)[f];if(0&lt;=(b.length|0)&amp;&amp;b.substring(0,e.length|0)===e){a=Zka(a);if(!Wu().qm.call(a,e))throw(new Xu).c(&quot;key not found: &quot;+e);a=&quot;&quot;+a[e]+b.substring(e.length|0);break a}f=1+f|0}else{a=0&lt;=(b.length|0)&amp;&amp;&quot;L&quot;===b.substring(0,1)?b.substring(1):b;break a}a=a.split(&quot;_&quot;).join(&quot;.&quot;).split(&quot;$und&quot;).join(&quot;_&quot;);if(h)h=&quot;\x3cclinit\x3e&quot;;else{h=d[2];if(void 0===h)throw(new Xu).c(&quot;undefined.get&quot;);
0&lt;=(h.length|0)&amp;&amp;&quot;init___&quot;===h.substring(0,7)?h=&quot;\x3cinit\x3e&quot;:(d=h.indexOf(&quot;__&quot;)|0,h=0&gt;d?h:h.substring(0,d))}return(new A).e(a,h)}return(new A).e(&quot;\x3cjscode\x3e&quot;,b)}function bla(a){var b=WE(&quot;Line (\\d+).*script (?:in )?(\\S+)&quot;,&quot;i&quot;);a=a.message.split(&quot;\n&quot;);for(var d=[],e=2,f=a.length|0;e&lt;f;){var h=b.exec(a[e]);if(null!==h){var k=h[2];if(void 0===k)throw(new Xu).c(&quot;undefined.get&quot;);h=h[1];if(void 0===h)throw(new Xu).c(&quot;undefined.get&quot;);d.push(&quot;{anonymous}()@&quot;+k+&quot;:&quot;+h)}e=2+e|0}return d}
function Zka(a){0===(4&amp;a.ya)&amp;&amp;0===(4&amp;a.ya)&amp;&amp;(a.gT={sjsr_:&quot;scala_scalajs_runtime_&quot;,sjs_:&quot;scala_scalajs_&quot;,sci_:&quot;scala_collection_immutable_&quot;,scm_:&quot;scala_collection_mutable_&quot;,scg_:&quot;scala_collection_generic_&quot;,sc_:&quot;scala_collection_&quot;,sr_:&quot;scala_runtime_&quot;,s_:&quot;scala_&quot;,jl_:&quot;java_lang_&quot;,ju_:&quot;java_util_&quot;},a.ya=(4|a.ya)&lt;&lt;24&gt;&gt;24);return a.gT}UE.prototype.$classData=g({Yha:0},!1,&quot;scala.scalajs.runtime.StackTrace$&quot;,{Yha:1,d:1});var XE=void 0;function YE(){}YE.prototype=new l;YE.prototype.constructor=YE;
YE.prototype.b=function(){return this};function WE(a,b){ZE||(ZE=(new YE).b());return new ba.RegExp(a,b)}function VE(a){ZE||(ZE=(new YE).b());return new ba.RegExp(a)}YE.prototype.$classData=g({Zha:0},!1,&quot;scala.scalajs.runtime.StackTrace$StringRE$&quot;,{Zha:1,d:1});var ZE=void 0;function $E(){}$E.prototype=new l;$E.prototype.constructor=$E;$E.prototype.b=function(){return this};function Kg(a,b){return aF(b)?b.Go:b}function ko(a,b){return b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.ad?b:(new bF).j(b)}
$E.prototype.$classData=g({$ha:0},!1,&quot;scala.scalajs.runtime.package$&quot;,{$ha:1,d:1});var cF=void 0;function Lg(){cF||(cF=(new $E).b());return cF}function dF(){}dF.prototype=new l;dF.prototype.constructor=dF;dF.prototype.b=function(){return this};function cla(a,b){if(ze(b))return a.X===b.X;if(eF(b)){if(&quot;number&quot;===typeof b)return+b===a.X;if(Ca(b)){b=Qa(b);var d=b.qa;a=a.X;return b.ka===a&amp;&amp;d===a&gt;&gt;31}return null===b?null===a:Ea(b,a)}return null===a&amp;&amp;null===b}
function sn(a,b,d){if(b===d)d=!0;else if(eF(b))a:if(eF(d))d=fF(0,b,d);else{if(ze(d)){if(&quot;number&quot;===typeof b){d=+b===d.X;break a}if(Ca(b)){a=Qa(b);b=a.qa;d=d.X;d=a.ka===d&amp;&amp;b===d&gt;&gt;31;break a}}d=null===b?null===d:Ea(b,d)}else d=ze(b)?cla(b,d):null===b?null===d:Ea(b,d);return d}
function fF(a,b,d){if(&quot;number&quot;===typeof b)return a=+b,&quot;number&quot;===typeof d?a===+d:Ca(d)?(b=Qa(d),d=b.ka,b=b.qa,a===gF(Ra(),d,b)):DE(d)?d.o(a):!1;if(Ca(b)){b=Qa(b);a=b.ka;b=b.qa;if(Ca(d)){d=Qa(d);var e=d.qa;return a===d.ka&amp;&amp;b===e}return&quot;number&quot;===typeof d?(d=+d,gF(Ra(),a,b)===d):DE(d)?d.o((new Vb).ia(a,b)):!1}return null===b?null===d:Ea(b,d)}dF.prototype.$classData=g({cia:0},!1,&quot;scala.runtime.BoxesRunTime$&quot;,{cia:1,d:1});var hF=void 0;function tn(){hF||(hF=(new dF).b());return hF}
function iF(){this.hb=this.La=!1}iF.prototype=new l;iF.prototype.constructor=iF;iF.prototype.b=function(){return this};iF.prototype.k=function(){return u((new v).K((new w).f([&quot;LazyBoolean &quot;,&quot;&quot;])),(new w).f([this.La?u((new v).K((new w).f([&quot;of: &quot;,&quot;&quot;])),(new w).f([this.hb])):&quot;thunk&quot;]))};iF.prototype.$classData=g({fia:0},!1,&quot;scala.runtime.LazyBoolean&quot;,{fia:1,d:1});function jF(){this.La=!1;this.hb=0}jF.prototype=new l;jF.prototype.constructor=jF;jF.prototype.b=function(){return this};
jF.prototype.k=function(){return u((new v).K((new w).f([&quot;LazyInt &quot;,&quot;&quot;])),(new w).f([this.La?u((new v).K((new w).f([&quot;of: &quot;,&quot;&quot;])),(new w).f([this.hb])):&quot;thunk&quot;]))};jF.prototype.$classData=g({gia:0},!1,&quot;scala.runtime.LazyInt&quot;,{gia:1,d:1});function Ne(){this.La=!1;this.hb=null}Ne.prototype=new l;Ne.prototype.constructor=Ne;Ne.prototype.b=function(){return this};
Ne.prototype.k=function(){return u((new v).K((new w).f([&quot;LazyRef &quot;,&quot;&quot;])),(new w).f([this.La?u((new v).K((new w).f([&quot;of: &quot;,&quot;&quot;])),(new w).f([this.hb])):&quot;thunk&quot;]))};function Pe(a,b){a.hb=b;a.La=!0;return b}Ne.prototype.$classData=g({hia:0},!1,&quot;scala.runtime.LazyRef&quot;,{hia:1,d:1});var kF=g({kia:0},!1,&quot;scala.runtime.Null$&quot;,{kia:1,d:1});function lF(){}lF.prototype=new l;lF.prototype.constructor=lF;lF.prototype.b=function(){return this};function Pu(a,b){return Na(b)===b}
lF.prototype.$classData=g({mia:0},!1,&quot;scala.runtime.RichDouble$&quot;,{mia:1,d:1});var mF=void 0;function Qu(){mF||(mF=(new lF).b());return mF}function nF(){}nF.prototype=new l;nF.prototype.constructor=nF;nF.prototype.b=function(){return this};nF.prototype.$classData=g({nia:0},!1,&quot;scala.runtime.RichLong$&quot;,{nia:1,d:1});var dla=void 0;function oF(){dla||(dla=(new nF).b())}function pF(){}pF.prototype=new l;pF.prototype.constructor=pF;pF.prototype.b=function(){return this};
function uD(a,b){if(ve(b,1)||lb(b,1)||ob(b,1)||mb(b,1)||nb(b,1)||ib(b,1)||jb(b,1)||kb(b,1)||hb(b,1)||rF(b))return b.l.length;if(null===b)throw(new Oe).b();throw(new q).j(b);}
function BE(a,b,d,e){if(ve(b,1))b.l[d]=e;else if(lb(b,1))b.l[d]=e|0;else if(ob(b,1))b.l[d]=+e;else if(mb(b,1))b.l[d]=Qa(e);else if(nb(b,1))b.l[d]=+e;else if(ib(b,1))b.l[d]=null===e?0:e.X;else if(jb(b,1))b.l[d]=e|0;else if(kb(b,1))b.l[d]=e|0;else if(hb(b,1))b.l[d]=!!e;else if(rF(b))b.l[d]=void 0;else{if(null===b)throw(new Oe).b();throw(new q).j(b);}}function X(a,b){a=b.x();return cc(a,b.u()+&quot;(&quot;,&quot;,&quot;,&quot;)&quot;)}
function AE(a,b,d){if(ve(b,1)||lb(b,1)||ob(b,1)||mb(b,1)||nb(b,1))return b.l[d];if(ib(b,1))return(new af).Ra(b.l[d]);if(jb(b,1)||kb(b,1)||hb(b,1)||rF(b))return b.l[d];if(null===b)throw(new Oe).b();throw(new q).j(b);}pF.prototype.$classData=g({oia:0},!1,&quot;scala.runtime.ScalaRunTime$&quot;,{oia:1,d:1});var sF=void 0;function W(){sF||(sF=(new pF).b());return sF}function tF(){}tF.prototype=new l;tF.prototype.constructor=tF;c=tF.prototype;c.b=function(){return this};
c.zs=function(a,b){b=da(-862048943,b);b=da(461845907,b&lt;&lt;15|b&gt;&gt;&gt;17|0);return a^b};function uF(a,b){a=Na(b);if(a===b)return a;var d=Ra();a=vF(d,b);d=d.Pb;return gF(Ra(),a,d)===b?a^d:daa(Ja(),b)}function hD(a,b){return null===b?0:&quot;number&quot;===typeof b?uF(0,+b):Ca(b)?(a=Qa(b),wF(0,(new Vb).ia(a.ka,a.qa))):Ga(b)}c.da=function(a,b){a=this.zs(a,b);return-430675100+da(5,a&lt;&lt;13|a&gt;&gt;&gt;19|0)|0};function wF(a,b){a=b.ka;b=b.qa;return b===a&gt;&gt;31?a:a^b}
c.tb=function(a,b){a^=b;a=da(-2048144789,a^(a&gt;&gt;&gt;16|0));a=da(-1028477387,a^(a&gt;&gt;&gt;13|0));return a^(a&gt;&gt;&gt;16|0)};c.$classData=g({qia:0},!1,&quot;scala.runtime.Statics$&quot;,{qia:1,d:1});var xF=void 0;function V(){xF||(xF=(new tF).b());return xF}function yF(){this.ZT=null;this.QS=0;this.RT=this.YT=this.$T=this.aU=null;this.a=0}yF.prototype=new l;yF.prototype.constructor=yF;
yF.prototype.b=function(){zF=this;this.ZT=nh(oh(),y());this.a|=1;this.QS=N(D())|Pj(D());this.a|=2;for(var a=N(D()),a=(new A).e(&quot;WHO&quot;,a),b=AF(this),b=(new A).e(&quot;COLOR&quot;,b),d=N(D()),d=(new A).e(&quot;HEADING&quot;,d),e=N(D()),e=(new A).e(&quot;XCOR&quot;,e),f=N(D()),f=(new A).e(&quot;YCOR&quot;,f),h=Oj(D()),h=(new A).e(&quot;SHAPE&quot;,h),k=lc(),k=(new A).e(&quot;LABEL&quot;,k),p=AF(this),p=(new A).e(&quot;LABEL-COLOR&quot;,p),t=Qj(D()),t=(new A).e(&quot;BREED&quot;,t),x=Nj(D()),x=(new A).e(&quot;HIDDEN?&quot;,x),E=N(D()),E=(new A).e(&quot;SIZE&quot;,E),S=N(D()),S=(new A).e(&quot;PEN-SIZE&quot;,S),
U=Oj(D()),a=[a,b,d,e,f,h,k,p,t,x,E,S,(new A).e(&quot;PEN-MODE&quot;,U)],b=dc(new ec,Yu()),d=0,e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.aU=b.Ma;this.a|=4;a=N(D());a=(new A).e(&quot;PXCOR&quot;,a);b=N(D());b=(new A).e(&quot;PYCOR&quot;,b);d=AF(this);d=(new A).e(&quot;PCOLOR&quot;,d);e=lc();e=(new A).e(&quot;PLABEL&quot;,e);f=AF(this);a=[a,b,d,e,(new A).e(&quot;PLABEL-COLOR&quot;,f)];b=dc(new ec,Yu());d=0;for(e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.$T=b.Ma;this.a|=8;a=Uj(D());a=(new A).e(&quot;END1&quot;,a);b=Uj(D());b=(new A).e(&quot;END2&quot;,b);d=AF(this);d=(new A).e(&quot;COLOR&quot;,
d);e=lc();e=(new A).e(&quot;LABEL&quot;,e);f=AF(this);f=(new A).e(&quot;LABEL-COLOR&quot;,f);h=Nj(D());h=(new A).e(&quot;HIDDEN?&quot;,h);k=Tj(D());k=(new A).e(&quot;BREED&quot;,k);p=N(D());p=(new A).e(&quot;THICKNESS&quot;,p);t=Oj(D());t=(new A).e(&quot;SHAPE&quot;,t);x=Oj(D());a=[a,b,d,e,f,h,k,p,t,(new A).e(&quot;TIE-MODE&quot;,x)];b=dc(new ec,Yu());d=0;for(e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.YT=b.Ma;this.a|=16;a=BF(this);a=Ic(a);Ap(a);this.a|=32;a=CF(this);a=Ic(a);Ap(a);this.a|=64;a=DF(this);a=Ic(a);Ap(a);this.a|=128;a=EF(this);a=Ic(a);Ap(a);this.a|=256;a=
BF(this);a=Ic(a);Ap(a).se((new Qn).xg(pa(qa)));this.a|=512;a=EF(this);a=Ic(a);this.RT=Ap(a).se((new Qn).xg(pa(qa)));this.a|=1024;return this};function CF(a){if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 14&quot;);return a.aU}function BF(a){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 9&quot;);return a.ZT}
function rga(){var a=FF(),a=DF(a),a=Ic(a);return Ap(a).se((new Qn).xg(pa(qa)))}function oga(){var a=FF(),a=CF(a),a=Ic(a);return Ap(a).se((new Qn).xg(pa(qa)))}function AF(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 12&quot;);return a.QS}function EF(a){if(0===(16&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 36&quot;);return a.YT}
function nga(){var a=FF();if(0===(1024&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 56&quot;);return a.RT}function DF(a){if(0===(8&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 29&quot;);return a.$T}yF.prototype.$classData=g({jZ:0},!1,&quot;org.nlogo.core.AgentVariables$&quot;,{jZ:1,d:1,zia:1});var zF=void 0;function FF(){zF||(zF=(new yF).b());return zF}
function GF(a){return!!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.$G)}function yt(){this.CR=this.KR=0;this.eW=this.tV=this.uV=null;this.a=0}yt.prototype=new l;yt.prototype.constructor=yt;
yt.prototype.b=function(){Zb=this;this.KR=14;this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;if(0===(1&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231&quot;);this.CR=da(10,this.KR);this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;Wba(dh());this.a=(8|this.a)&lt;&lt;24&gt;&gt;24;var a=(new w).f([140,140,140,215,48,39,241,105,19,156,109,70,237,237,47,87,176,58,42,209,57,27,158,119,82,196,196,43,140,190,50,92,168,123,78,163,166,25,105,224,126,149,0,0,0,255,255,255]),
b=a.oa.length|0,b=la(Xa(db),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e|0;d=1+d|0}this.uV=b;this.a=(16|this.a)&lt;&lt;24&gt;&gt;24;a=da(10,ela(this));if(e=0&gt;=a)var f=0;else b=a&gt;&gt;31,f=(0===b?-1&lt;(-2147483648^a):0&lt;b)?-1:a;b=-1+a|0;HF();Mk();HF();Lk();d=(new IF).b();0&gt;f&amp;&amp;$n(ao(),0,a,1,!1);if(!e)for(a=0;;){var h=a,k=h/100|0,e=JF(this).l[da(3,k)],f=JF(this).l[1+da(3,k)|0],k=JF(this).l[2+da(3,k)|0],h=.012+(-50+(h%100|0)|0)/50.48;0&gt;h?(e=e+Na(e*h)|0,f=f+Na(f*h)|0,k=k+Na(k*h)|0):0&lt;h&amp;&amp;(e=
e+Na((255-e|0)*h)|0,f=f+Na((255-f|0)*h)|0,k=k+Na((255-k|0)*h)|0);KF(d,((-16777216+(e&lt;&lt;16)|0)+(f&lt;&lt;8)|0)+k|0);if(a===b)break;a=1+a|0}b=LF(d);d=b.sa();d=la(Xa(db),[d]);tD(b,d,0);d.l[0]=-16777216;d.l[99]=-1;this.tV=d;this.a=(32|this.a)&lt;&lt;24&gt;&gt;24;MF||(MF=(new NF).b());b=nh(MF,y());a=da(10,ela(this));d=-1+a|0;if(!(0&gt;=a))for(a=0;;){f=e=a/10;if(0===(32&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231&quot;);b.bv(this.tV.l[Na(10*f)],e);if(a===d)break;
a=1+a|0}this.eW=b;this.a=(64|this.a)&lt;&lt;24&gt;&gt;24;return this};function ela(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231&quot;);return a.CR}function uaa(a){if(0===(64&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231&quot;);return a.eW}
function JF(a){if(0===(16&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231&quot;);return a.uV}yt.prototype.$classData=g({uZ:0},!1,&quot;org.nlogo.core.Color$&quot;,{uZ:1,d:1,Bia:1});var Zb=void 0;function OF(){}OF.prototype=new l;OF.prototype.constructor=OF;OF.prototype.b=function(){return this};OF.prototype.$classData=g({AZ:0},!1,&quot;org.nlogo.core.DummyCompilationEnvironment&quot;,{AZ:1,d:1,Cia:1});function xs(){}xs.prototype=new l;
xs.prototype.constructor=xs;c=xs.prototype;c.b=function(){return this};c.hY=function(){};c.yS=function(){return!1};c.aW=function(){return null};c.bU=function(){throw(new Ul).b();};c.$classData=g({BZ:0},!1,&quot;org.nlogo.core.DummyExtensionManager&quot;,{BZ:1,d:1,FZ:1});function PF(){this.wT=null;this.a=!1}PF.prototype=new l;PF.prototype.constructor=PF;PF.prototype.b=function(){QF=this;var a=new RF;if(null===this)throw Kg(Lg(),null);a.Sa=this;this.wT=a;this.a=!0;return this};
PF.prototype.$classData=g({CZ:0},!1,&quot;org.nlogo.core.Dump$&quot;,{CZ:1,d:1,Fia:1});var QF=void 0;function Eo(){QF||(QF=(new PF).b());return QF}function SF(){this.Yi=this.ij=this.ES=null;this.a=0}SF.prototype=new l;SF.prototype.constructor=SF;function fla(){}fla.prototype=SF.prototype;
SF.prototype.cf=function(){var a=$e().kk,b=(new A).e(&quot;org.nlogo.core.prim._breed&quot;,m(new n,function(){return function(a){return(new TF).c(a)}}(this))),d=(new A).e(&quot;org.nlogo.core.prim._breedvariable&quot;,m(new n,function(){return function(a){return(new UF).c(a)}}(this))),e=(new A).e(&quot;org.nlogo.core.prim._createorderedturtles&quot;,m(new n,function(){return function(a){return(new VF).c(a)}}(this))),f=(new A).e(&quot;org.nlogo.core.prim._createturtles&quot;,m(new n,function(){return function(a){return(new XF).c(a)}}(this))),
h=(new A).e(&quot;org.nlogo.core.prim._hatch&quot;,m(new n,function(){return function(a){return(new bG).c(a)}}(this))),k=(new A).e(&quot;org.nlogo.core.prim._lambdavariable&quot;,m(new n,function(){return function(a){return(new kn).c(a)}}(this))),p=(new A).e(&quot;org.nlogo.core.prim._linkbreedvariable&quot;,m(new n,function(){return function(a){return(new cG).c(a)}}(this))),t=(new A).e(&quot;org.nlogo.core.prim._sprout&quot;,m(new n,function(){return function(a){return(new dG).c(a)}}(this))),x=(new A).e(&quot;org.nlogo.core.prim.etc._breedat&quot;,
m(new n,function(){return function(a){return(new eG).c(a)}}(this))),E=(new A).e(&quot;org.nlogo.core.prim.etc._breedhere&quot;,m(new n,function(){return function(a){return(new fG).c(a)}}(this))),S=(new A).e(&quot;org.nlogo.core.prim.etc._breedon&quot;,m(new n,function(){return function(a){return(new gG).c(a)}}(this))),U=(new A).e(&quot;org.nlogo.core.prim.etc._breedsingular&quot;,m(new n,function(){return function(a){return(new hG).c(a)}}(this))),ga=(new A).e(&quot;org.nlogo.core.prim.etc._inlinkfrom&quot;,m(new n,function(){return function(a){return(new iG).c(a)}}(this))),
ma=(new A).e(&quot;org.nlogo.core.prim.etc._inlinkneighbor&quot;,m(new n,function(){return function(a){return(new jG).c(a)}}(this))),va=(new A).e(&quot;org.nlogo.core.prim.etc._inlinkneighbors&quot;,m(new n,function(){return function(a){return(new kG).c(a)}}(this))),Fa=(new A).e(&quot;org.nlogo.core.prim.etc._isbreed&quot;,m(new n,function(){return function(a){return(new lG).c(a)}}(this))),Va=(new A).e(&quot;org.nlogo.core.prim.etc._linkbreed&quot;,m(new n,function(){return function(a){return(new mG).c(a)}}(this))),vb=(new A).e(&quot;org.nlogo.core.prim.etc._linkbreedsingular&quot;,
m(new n,function(){return function(a){return(new nG).c(a)}}(this))),pb=(new A).e(&quot;org.nlogo.core.prim.etc._linkneighbor&quot;,m(new n,function(){return function(a){return(new oG).c(a)}}(this))),Ib=(new A).e(&quot;org.nlogo.core.prim.etc._linkneighbors&quot;,m(new n,function(){return function(a){return(new pG).c(a)}}(this))),kc=(new A).e(&quot;org.nlogo.core.prim.etc._linkwith&quot;,m(new n,function(){return function(a){return(new qG).c(a)}}(this))),$a=(new A).e(&quot;org.nlogo.core.prim.etc._myinlinks&quot;,m(new n,function(){return function(a){return(new rG).c(a)}}(this))),
fc=(new A).e(&quot;org.nlogo.core.prim.etc._mylinks&quot;,m(new n,function(){return function(a){return(new sG).c(a)}}(this))),Bc=(new A).e(&quot;org.nlogo.core.prim.etc._myoutlinks&quot;,m(new n,function(){return function(a){return(new tG).c(a)}}(this))),sf=(new A).e(&quot;org.nlogo.core.prim.etc._outlinkneighbor&quot;,m(new n,function(){return function(a){return(new uG).c(a)}}(this))),Sf=(new A).e(&quot;org.nlogo.core.prim.etc._outlinkneighbors&quot;,m(new n,function(){return function(a){return(new vG).c(a)}}(this))),th=(new A).e(&quot;org.nlogo.core.prim.etc._outlinkto&quot;,
m(new n,function(){return function(a){return(new wG).c(a)}}(this))),Te=(new A).e(&quot;org.nlogo.core.prim.etc._createlinkwith&quot;,m(new n,function(){return function(a){return(new xG).c(a)}}(this))),tf=(new A).e(&quot;org.nlogo.core.prim.etc._createlinkto&quot;,m(new n,function(){return function(a){return(new yG).c(a)}}(this))),ek=(new A).e(&quot;org.nlogo.core.prim.etc._createlinkfrom&quot;,m(new n,function(){return function(a){return(new zG).c(a)}}(this))),og=(new A).e(&quot;org.nlogo.core.prim.etc._createlinkswith&quot;,m(new n,function(){return function(a){return(new AG).c(a)}}(this))),
uh=(new A).e(&quot;org.nlogo.core.prim.etc._createlinksto&quot;,m(new n,function(){return function(a){return(new BG).c(a)}}(this)));this.ES=nh(a,(new w).f([b,d,e,f,h,k,p,t,x,E,S,U,ga,ma,va,Fa,Va,vb,pb,Ib,kc,$a,fc,Bc,sf,Sf,th,Te,tf,ek,og,uh,(new A).e(&quot;org.nlogo.core.prim.etc._createlinksfrom&quot;,m(new n,function(){return function(a){return(new CG).c(a)}}(this)))]));this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;var pg=$e().kk,Yh=(new A).e(&quot;!\x3d&quot;,K(function(){return function(){return(new DG).b()}}(this))),Ri=(new A).e(&quot;*&quot;,K(function(){return function(){return(new EG).b()}}(this))),
fk=(new A).e(&quot;+&quot;,K(function(){return function(){return(new FG).b()}}(this))),Si=(new A).e(&quot;-&quot;,K(function(){return function(){return(new GG).b()}}(this))),gk=(new A).e(&quot;/&quot;,K(function(){return function(){return(new JG).b()}}(this))),Ti=(new A).e(&quot;\x3c&quot;,K(function(){return function(){return(new KG).b()}}(this))),vl=(new A).e(&quot;\x3c\x3d&quot;,K(function(){return function(){return(new LG).b()}}(this))),Ui=(new A).e(&quot;\x3d&quot;,K(function(){return function(){return(new MG).b()}}(this))),hk=(new A).e(&quot;\x3e&quot;,K(function(){return function(){return(new NG).b()}}(this))),
Vi=(new A).e(&quot;\x3e\x3d&quot;,K(function(){return function(){return(new OG).b()}}(this))),wl=(new A).e(&quot;^&quot;,K(function(){return function(){return(new PG).b()}}(this))),vh=(new A).e(&quot;__APPLY-RESULT&quot;,K(function(){return function(){return(new QG).b()}}(this))),xl=(new A).e(&quot;__BOOM&quot;,K(function(){return function(){return(new RG).b()}}(this))),wh=(new A).e(&quot;__BLOCK&quot;,K(function(){return function(){return(new SG).b()}}(this))),ik=(new A).e(&quot;__CHECK-SYNTAX&quot;,K(function(){return function(){return(new TG).b()}}(this))),
yl=(new A).e(&quot;__CHECKSUM&quot;,K(function(){return function(){return(new UG).b()}}(this))),Zh=(new A).e(&quot;__DUMP&quot;,K(function(){return function(){return(new VG).b()}}(this))),$h=(new A).e(&quot;__DUMP-EXTENSION-PRIMS&quot;,K(function(){return function(){return(new WG).b()}}(this))),zl=(new A).e(&quot;__DUMP-EXTENSIONS&quot;,K(function(){return function(){return(new XG).b()}}(this))),Al=(new A).e(&quot;__DUMP1&quot;,K(function(){return function(){return(new YG).b()}}(this))),Bl=(new A).e(&quot;__NANO-TIME&quot;,K(function(){return function(){return(new ZG).b()}}(this))),
jk=(new A).e(&quot;__PROCESSORS&quot;,K(function(){return function(){return(new $G).b()}}(this))),Cl=(new A).e(&quot;__RANDOM-STATE&quot;,K(function(){return function(){return(new aH).b()}}(this))),Dl=(new A).e(&quot;__REFERENCE&quot;,K(function(){return function(){return(new bH).b()}}(this))),El=(new A).e(&quot;__STACK-TRACE&quot;,K(function(){return function(){return(new cH).b()}}(this))),Fl=(new A).e(&quot;__SYMBOL&quot;,K(function(){return function(){return(new dH).b()}}(this))),kk=(new A).e(&quot;__TO-STRING&quot;,K(function(){return function(){return(new eH).b()}}(this))),
Gl=(new A).e(&quot;ABS&quot;,K(function(){return function(){return(new fH).b()}}(this))),ai=(new A).e(&quot;ACOS&quot;,K(function(){return function(){return(new gH).b()}}(this))),lk=(new A).e(&quot;ALL?&quot;,K(function(){return function(){return(new hH).b()}}(this))),xh=(new A).e(&quot;AND&quot;,K(function(){return function(){return(new iH).b()}}(this))),Hl=(new A).e(&quot;ANY?&quot;,K(function(){return function(){return(new jH).b()}}(this))),Wi=(new A).e(&quot;APPROXIMATE-HSB&quot;,K(function(){return function(){return(new kH).b()}}(this))),mk=(new A).e(&quot;APPROXIMATE-RGB&quot;,
K(function(){return function(){return(new lH).b()}}(this))),yh=(new A).e(&quot;ASIN&quot;,K(function(){return function(){return(new mH).b()}}(this))),Uf=(new A).e(&quot;AT-POINTS&quot;,K(function(){return function(){return(new nH).b()}}(this))),ue=(new A).e(&quot;ATAN&quot;,K(function(){return function(){return(new oH).b()}}(this))),zh=(new A).e(&quot;AUTOPLOT?&quot;,K(function(){return function(){return(new pH).b()}}(this))),bi=(new A).e(&quot;BASE-COLORS&quot;,K(function(){return function(){return(new qH).b()}}(this))),nk=(new A).e(&quot;BEHAVIORSPACE-RUN-NUMBER&quot;,
K(function(){return function(){return(new rH).b()}}(this))),Xi=(new A).e(&quot;BF&quot;,K(function(){return function(){return(new sH).b()}}(this))),Il=(new A).e(&quot;BL&quot;,K(function(){return function(){return(new tH).b()}}(this))),Yi=(new A).e(&quot;BOTH-ENDS&quot;,K(function(){return function(){return(new uH).b()}}(this))),Jl=(new A).e(&quot;BUT-FIRST&quot;,K(function(){return function(){return(new sH).b()}}(this))),Zi=(new A).e(&quot;BUT-LAST&quot;,K(function(){return function(){return(new tH).b()}}(this))),$i=(new A).e(&quot;BUTFIRST&quot;,K(function(){return function(){return(new sH).b()}}(this))),
ok=(new A).e(&quot;BUTLAST&quot;,K(function(){return function(){return(new tH).b()}}(this))),Kl=(new A).e(&quot;CAN-MOVE?&quot;,K(function(){return function(){return(new vH).b()}}(this))),aj=(new A).e(&quot;CEILING&quot;,K(function(){return function(){return(new wH).b()}}(this))),ci=(new A).e(&quot;COS&quot;,K(function(){return function(){return(new xH).b()}}(this))),Ll=(new A).e(&quot;COUNT&quot;,K(function(){return function(){return(new yH).b()}}(this))),Rg=(new A).e(&quot;DATE-AND-TIME&quot;,K(function(){return function(){return(new zH).b()}}(this))),Sg=
(new A).e(&quot;DISTANCE&quot;,K(function(){return function(){return(new AH).b()}}(this))),pk=(new A).e(&quot;DISTANCEXY&quot;,K(function(){return function(){return(new BH).b()}}(this))),bj=(new A).e(&quot;DX&quot;,K(function(){return function(){return(new CH).b()}}(this))),Ah=(new A).e(&quot;DY&quot;,K(function(){return function(){return(new DH).b()}}(this))),qk=(new A).e(&quot;EMPTY?&quot;,K(function(){return function(){return(new EH).b()}}(this))),Ml=(new A).e(&quot;ERROR-MESSAGE&quot;,K(function(){return function(){return(new FH).b()}}(this))),rk=(new A).e(&quot;EXP&quot;,
K(function(){return function(){return(new GH).b()}}(this))),Tg=(new A).e(&quot;EXTRACT-HSB&quot;,K(function(){return function(){return(new HH).b()}}(this))),Nl=(new A).e(&quot;EXTRACT-RGB&quot;,K(function(){return function(){return(new IH).b()}}(this))),cj=(new A).e(&quot;FILE-AT-END?&quot;,K(function(){return function(){return(new JH).b()}}(this))),di=(new A).e(&quot;FILE-EXISTS?&quot;,K(function(){return function(){return(new KH).b()}}(this))),Bh=(new A).e(&quot;FILE-READ&quot;,K(function(){return function(){return(new LH).b()}}(this))),Ol=(new A).e(&quot;FILE-READ-CHARACTERS&quot;,
K(function(){return function(){return(new MH).b()}}(this))),qg=(new A).e(&quot;FILE-READ-LINE&quot;,K(function(){return function(){return(new NH).b()}}(this))),fi=(new A).e(&quot;FILTER&quot;,K(function(){return function(){return(new OH).b()}}(this))),Ch=(new A).e(&quot;FIRST&quot;,K(function(){return function(){return(new PH).b()}}(this))),dj=(new A).e(&quot;FLOOR&quot;,K(function(){return function(){return(new QH).b()}}(this))),Ug=(new A).e(&quot;FPUT&quot;,K(function(){return function(){return(new RH).b()}}(this))),ej=(new A).e(&quot;HSB&quot;,K(function(){return function(){return(new SH).b()}}(this))),
fj=(new A).e(&quot;HUBNET-CLIENTS-LIST&quot;,K(function(){return function(){return(new TH).b()}}(this))),gi=(new A).e(&quot;HUBNET-ENTER-MESSAGE?&quot;,K(function(){return function(){return(new UH).b()}}(this))),hi=(new A).e(&quot;HUBNET-EXIT-MESSAGE?&quot;,K(function(){return function(){return(new VH).b()}}(this))),gj=(new A).e(&quot;HUBNET-MESSAGE&quot;,K(function(){return function(){return(new WH).b()}}(this))),Vf=(new A).e(&quot;HUBNET-MESSAGE-SOURCE&quot;,K(function(){return function(){return(new XH).b()}}(this))),vf=(new A).e(&quot;HUBNET-MESSAGE-TAG&quot;,
K(function(){return function(){return(new YH).b()}}(this))),ae=(new A).e(&quot;HUBNET-MESSAGE-WAITING?&quot;,K(function(){return function(){return(new ZH).b()}}(this))),hj=(new A).e(&quot;IFELSE-VALUE&quot;,K(function(){return function(){return(new $H).b()}}(this))),rg=(new A).e(&quot;IN-CONE&quot;,K(function(){return function(){return(new aI).b()}}(this))),ij=(new A).e(&quot;IN-LINK-FROM&quot;,K(function(){return function(){return(new iG).b()}}(this))),jj=(new A).e(&quot;IN-LINK-NEIGHBOR?&quot;,K(function(){return function(){return(new jG).b()}}(this))),
ii=(new A).e(&quot;IN-LINK-NEIGHBORS&quot;,K(function(){return function(){return(new kG).b()}}(this))),ji=(new A).e(&quot;IN-RADIUS&quot;,K(function(){return function(){return(new bI).b()}}(this))),Pl=(new A).e(&quot;INSERT-ITEM&quot;,K(function(){return function(){return(new cI).b()}}(this))),sk=(new A).e(&quot;INT&quot;,K(function(){return function(){return(new dI).b()}}(this))),Vg=(new A).e(&quot;IS-AGENT?&quot;,K(function(){return function(){return(new eI).b()}}(this))),ki=(new A).e(&quot;IS-AGENTSET?&quot;,K(function(){return function(){return(new fI).b()}}(this))),
Ql=(new A).e(&quot;IS-ANONYMOUS-COMMAND?&quot;,K(function(){return function(){return(new gI).b()}}(this))),tk=(new A).e(&quot;IS-ANONYMOUS-REPORTER?&quot;,K(function(){return function(){return(new hI).b()}}(this))),ei=(new A).e(&quot;IS-BOOLEAN?&quot;,K(function(){return function(){return(new iI).b()}}(this))),qF=(new A).e(&quot;IS-DIRECTED-LINK?&quot;,K(function(){return function(){return(new jI).b()}}(this))),xw=(new A).e(&quot;IS-LINK-SET?&quot;,K(function(){return function(){return(new kI).b()}}(this))),cx=(new A).e(&quot;IS-LINK?&quot;,K(function(){return function(){return(new lI).b()}}(this))),
WF=(new A).e(&quot;IS-LIST?&quot;,K(function(){return function(){return(new mI).b()}}(this))),wr=(new A).e(&quot;IS-NUMBER?&quot;,K(function(){return function(){return(new nI).b()}}(this))),dx=(new A).e(&quot;IS-PATCH-SET?&quot;,K(function(){return function(){return(new oI).b()}}(this))),vk=(new A).e(&quot;IS-PATCH?&quot;,K(function(){return function(){return(new pI).b()}}(this))),Bn=(new A).e(&quot;IS-STRING?&quot;,K(function(){return function(){return(new qI).b()}}(this))),am=(new A).e(&quot;IS-TURTLE-SET?&quot;,K(function(){return function(){return(new rI).b()}}(this))),
ex=(new A).e(&quot;IS-TURTLE?&quot;,K(function(){return function(){return(new sI).b()}}(this))),xr=(new A).e(&quot;IS-UNDIRECTED-LINK?&quot;,K(function(){return function(){return(new tI).b()}}(this))),Cn=(new A).e(&quot;ITEM&quot;,K(function(){return function(){return(new uI).b()}}(this))),wk=(new A).e(&quot;LAST&quot;,K(function(){return function(){return(new vI).b()}}(this))),YF=(new A).e(&quot;LENGTH&quot;,K(function(){return function(){return(new wI).b()}}(this))),yr=(new A).e(&quot;LINK&quot;,K(function(){return function(){return(new xI).b()}}(this))),
bm=(new A).e(&quot;LINK-HEADING&quot;,K(function(){return function(){return(new yI).b()}}(this))),zr=(new A).e(&quot;LINK-LENGTH&quot;,K(function(){return function(){return(new zI).b()}}(this))),ZF=(new A).e(&quot;LINK-NEIGHBOR?&quot;,K(function(){return function(){return(new oG).b()}}(this))),$F=(new A).e(&quot;LINK-NEIGHBORS&quot;,K(function(){return function(){return(new pG).b()}}(this))),Dn=(new A).e(&quot;LINK-SET&quot;,K(function(){return function(){return(new AI).b()}}(this))),aG=(new A).e(&quot;LINK-SHAPES&quot;,K(function(){return function(){return(new BI).b()}}(this))),
e7=(new A).e(&quot;LINK-WITH&quot;,K(function(){return function(){return(new qG).b()}}(this))),f7=(new A).e(&quot;LINKS&quot;,K(function(){return function(){return(new CI).b()}}(this))),h7=(new A).e(&quot;LIST&quot;,K(function(){return function(){return(new DI).b()}}(this))),i7=(new A).e(&quot;LN&quot;,K(function(){return function(){return(new EI).b()}}(this))),j7=(new A).e(&quot;LOG&quot;,K(function(){return function(){return(new FI).b()}}(this))),k7=(new A).e(&quot;LPUT&quot;,K(function(){return function(){return(new GI).b()}}(this))),HG=(new A).e(&quot;MAP&quot;,
K(function(){return function(){return(new HI).b()}}(this))),l7=(new A).e(&quot;MAX&quot;,K(function(){return function(){return(new II).b()}}(this))),m7=(new A).e(&quot;MAX-N-OF&quot;,K(function(){return function(){return(new JI).b()}}(this))),o7=(new A).e(&quot;MAX-ONE-OF&quot;,K(function(){return function(){return(new KI).b()}}(this))),p7=(new A).e(&quot;MAX-PXCOR&quot;,K(function(){return function(){return(new LI).b()}}(this))),q7=(new A).e(&quot;MAX-PYCOR&quot;,K(function(){return function(){return(new MI).b()}}(this))),GZ=(new A).e(&quot;MEAN&quot;,K(function(){return function(){return(new NI).b()}}(this))),
Lr=(new A).e(&quot;MEDIAN&quot;,K(function(){return function(){return(new OI).b()}}(this))),r7=(new A).e(&quot;MEMBER?&quot;,K(function(){return function(){return(new PI).b()}}(this))),IG=(new A).e(&quot;MIN&quot;,K(function(){return function(){return(new QI).b()}}(this))),s7=(new A).e(&quot;MIN-N-OF&quot;,K(function(){return function(){return(new RI).b()}}(this))),t7=(new A).e(&quot;MIN-ONE-OF&quot;,K(function(){return function(){return(new SI).b()}}(this))),u7=(new A).e(&quot;MIN-PXCOR&quot;,K(function(){return function(){return(new TI).b()}}(this))),v7=
(new A).e(&quot;MIN-PYCOR&quot;,K(function(){return function(){return(new UI).b()}}(this))),w7=(new A).e(&quot;MOD&quot;,K(function(){return function(){return(new VI).b()}}(this))),x7=(new A).e(&quot;MODES&quot;,K(function(){return function(){return(new WI).b()}}(this))),HZ=(new A).e(&quot;MOUSE-DOWN?&quot;,K(function(){return function(){return(new XI).b()}}(this))),y7=(new A).e(&quot;MOUSE-INSIDE?&quot;,K(function(){return function(){return(new YI).b()}}(this))),z7=(new A).e(&quot;MOUSE-XCOR&quot;,K(function(){return function(){return(new ZI).b()}}(this))),
A7=(new A).e(&quot;MOUSE-YCOR&quot;,K(function(){return function(){return(new $I).b()}}(this))),B7=(new A).e(&quot;MY-IN-LINKS&quot;,K(function(){return function(){return(new rG).b()}}(this))),kBa=(new A).e(&quot;MY-LINKS&quot;,K(function(){return function(){return(new sG).b()}}(this))),lBa=(new A).e(&quot;MY-OUT-LINKS&quot;,K(function(){return function(){return(new tG).b()}}(this))),mBa=(new A).e(&quot;MYSELF&quot;,K(function(){return function(){return(new aJ).b()}}(this))),nBa=(new A).e(&quot;N-OF&quot;,K(function(){return function(){return(new bJ).b()}}(this))),
oBa=(new A).e(&quot;N-VALUES&quot;,K(function(){return function(){return(new cJ).b()}}(this))),pBa=(new A).e(&quot;NEIGHBORS&quot;,K(function(){return function(){return(new dJ).b()}}(this))),qBa=(new A).e(&quot;NEIGHBORS4&quot;,K(function(){return function(){return(new eJ).b()}}(this))),rBa=(new A).e(&quot;NETLOGO-APPLET?&quot;,K(function(){return function(){return(new fJ).b()}}(this))),sBa=(new A).e(&quot;NETLOGO-VERSION&quot;,K(function(){return function(){return(new gJ).b()}}(this))),tBa=(new A).e(&quot;NETLOGO-WEB?&quot;,K(function(){return function(){return(new hJ).b()}}(this))),
uBa=(new A).e(&quot;NEW-SEED&quot;,K(function(){return function(){return(new iJ).b()}}(this))),vBa=(new A).e(&quot;NO-LINKS&quot;,K(function(){return function(){return(new jJ).b()}}(this))),wBa=(new A).e(&quot;NO-PATCHES&quot;,K(function(){return function(){return(new kJ).b()}}(this))),xBa=(new A).e(&quot;NO-TURTLES&quot;,K(function(){return function(){return(new lJ).b()}}(this))),yBa=(new A).e(&quot;NOT&quot;,K(function(){return function(){return(new mJ).b()}}(this))),zBa=(new A).e(&quot;OF&quot;,K(function(){return function(){return(new nJ).b()}}(this))),
ABa=(new A).e(&quot;ONE-OF&quot;,K(function(){return function(){return(new oJ).b()}}(this))),BBa=(new A).e(&quot;OR&quot;,K(function(){return function(){return(new pJ).b()}}(this))),CBa=(new A).e(&quot;OTHER&quot;,K(function(){return function(){return(new qJ).b()}}(this))),DBa=(new A).e(&quot;OTHER-END&quot;,K(function(){return function(){return(new rJ).b()}}(this))),EBa=(new A).e(&quot;OUT-LINK-NEIGHBOR?&quot;,K(function(){return function(){return(new uG).b()}}(this))),FBa=(new A).e(&quot;OUT-LINK-NEIGHBORS&quot;,K(function(){return function(){return(new vG).b()}}(this))),
GBa=(new A).e(&quot;OUT-LINK-TO&quot;,K(function(){return function(){return(new wG).b()}}(this))),HBa=(new A).e(&quot;PATCH&quot;,K(function(){return function(){return(new sJ).b()}}(this))),IBa=(new A).e(&quot;PATCH-AHEAD&quot;,K(function(){return function(){return(new tJ).b()}}(this))),JBa=(new A).e(&quot;PATCH-AT&quot;,K(function(){return function(){return(new uJ).b()}}(this))),KBa=(new A).e(&quot;PATCH-AT-HEADING-AND-DISTANCE&quot;,K(function(){return function(){return(new vJ).b()}}(this))),LBa=(new A).e(&quot;PATCH-HERE&quot;,K(function(){return function(){return(new wJ).b()}}(this))),
MBa=(new A).e(&quot;PATCH-LEFT-AND-AHEAD&quot;,K(function(){return function(){return(new xJ).b()}}(this))),NBa=(new A).e(&quot;PATCH-RIGHT-AND-AHEAD&quot;,K(function(){return function(){return(new yJ).b()}}(this))),OBa=(new A).e(&quot;PATCH-SET&quot;,K(function(){return function(){return(new zJ).b()}}(this))),PBa=(new A).e(&quot;PATCH-SIZE&quot;,K(function(){return function(){return(new AJ).b()}}(this))),QBa=(new A).e(&quot;PATCHES&quot;,K(function(){return function(){return(new BJ).b()}}(this))),RBa=(new A).e(&quot;PLOT-NAME&quot;,K(function(){return function(){return(new CJ).b()}}(this))),
SBa=(new A).e(&quot;PLOT-PEN-EXISTS?&quot;,K(function(){return function(){return(new DJ).b()}}(this))),TBa=(new A).e(&quot;PLOT-X-MAX&quot;,K(function(){return function(){return(new EJ).b()}}(this))),UBa=(new A).e(&quot;PLOT-X-MIN&quot;,K(function(){return function(){return(new FJ).b()}}(this))),VBa=(new A).e(&quot;PLOT-Y-MAX&quot;,K(function(){return function(){return(new GJ).b()}}(this))),WBa=(new A).e(&quot;PLOT-Y-MIN&quot;,K(function(){return function(){return(new HJ).b()}}(this))),XBa=(new A).e(&quot;POSITION&quot;,K(function(){return function(){return(new IJ).b()}}(this))),
YBa=(new A).e(&quot;PRECISION&quot;,K(function(){return function(){return(new JJ).b()}}(this))),ZBa=(new A).e(&quot;RANDOM&quot;,K(function(){return function(){return(new KJ).b()}}(this))),$Ba=(new A).e(&quot;RANDOM-EXPONENTIAL&quot;,K(function(){return function(){return(new LJ).b()}}(this))),aCa=(new A).e(&quot;RANDOM-FLOAT&quot;,K(function(){return function(){return(new MJ).b()}}(this))),bCa=(new A).e(&quot;RANDOM-GAMMA&quot;,K(function(){return function(){return(new NJ).b()}}(this))),cCa=(new A).e(&quot;RANDOM-NORMAL&quot;,K(function(){return function(){return(new OJ).b()}}(this))),
dCa=(new A).e(&quot;RANDOM-POISSON&quot;,K(function(){return function(){return(new PJ).b()}}(this))),eCa=(new A).e(&quot;RANDOM-PXCOR&quot;,K(function(){return function(){return(new QJ).b()}}(this))),fCa=(new A).e(&quot;RANDOM-PYCOR&quot;,K(function(){return function(){return(new RJ).b()}}(this))),gCa=(new A).e(&quot;RANDOM-XCOR&quot;,K(function(){return function(){return(new SJ).b()}}(this))),hCa=(new A).e(&quot;RANDOM-YCOR&quot;,K(function(){return function(){return(new TJ).b()}}(this))),iCa=(new A).e(&quot;RANGE&quot;,K(function(){return function(){return(new UJ).b()}}(this))),
jCa=(new A).e(&quot;READ-FROM-STRING&quot;,K(function(){return function(){return(new VJ).b()}}(this))),kCa=(new A).e(&quot;REDUCE&quot;,K(function(){return function(){return(new WJ).b()}}(this))),lCa=(new A).e(&quot;REMAINDER&quot;,K(function(){return function(){return(new XJ).b()}}(this))),mCa=(new A).e(&quot;REMOVE&quot;,K(function(){return function(){return(new YJ).b()}}(this))),nCa=(new A).e(&quot;REMOVE-DUPLICATES&quot;,K(function(){return function(){return(new ZJ).b()}}(this))),oCa=(new A).e(&quot;REMOVE-ITEM&quot;,K(function(){return function(){return(new $J).b()}}(this))),
pCa=(new A).e(&quot;REPLACE-ITEM&quot;,K(function(){return function(){return(new aK).b()}}(this))),qCa=(new A).e(&quot;REVERSE&quot;,K(function(){return function(){return(new bK).b()}}(this))),rCa=(new A).e(&quot;RGB&quot;,K(function(){return function(){return(new cK).b()}}(this))),sCa=(new A).e(&quot;ROUND&quot;,K(function(){return function(){return(new dK).b()}}(this))),tCa=(new A).e(&quot;RUN-RESULT&quot;,K(function(){return function(){return(new eK).b()}}(this))),uCa=(new A).e(&quot;RUNRESULT&quot;,K(function(){return function(){return(new eK).b()}}(this))),
vCa=(new A).e(&quot;SCALE-COLOR&quot;,K(function(){return function(){return(new fK).b()}}(this))),wCa=(new A).e(&quot;SE&quot;,K(function(){return function(){return(new gK).b()}}(this))),xCa=(new A).e(&quot;SELF&quot;,K(function(){return function(){return(new hK).b()}}(this))),yCa=(new A).e(&quot;SENTENCE&quot;,K(function(){return function(){return(new gK).b()}}(this))),zCa=(new A).e(&quot;SHADE-OF?&quot;,K(function(){return function(){return(new iK).b()}}(this))),ACa=(new A).e(&quot;SHAPES&quot;,K(function(){return function(){return(new jK).b()}}(this))),
BCa=(new A).e(&quot;SHUFFLE&quot;,K(function(){return function(){return(new kK).b()}}(this))),CCa=(new A).e(&quot;SIN&quot;,K(function(){return function(){return(new lK).b()}}(this))),DCa=(new A).e(&quot;SORT&quot;,K(function(){return function(){return(new mK).b()}}(this))),ECa=(new A).e(&quot;SORT-BY&quot;,K(function(){return function(){return(new nK).b()}}(this))),FCa=(new A).e(&quot;SORT-ON&quot;,K(function(){return function(){return(new oK).b()}}(this))),GCa=(new A).e(&quot;SQRT&quot;,K(function(){return function(){return(new pK).b()}}(this))),HCa=(new A).e(&quot;STANDARD-DEVIATION&quot;,
K(function(){return function(){return(new qK).b()}}(this))),ICa=(new A).e(&quot;SUBJECT&quot;,K(function(){return function(){return(new rK).b()}}(this))),JCa=(new A).e(&quot;SUBLIST&quot;,K(function(){return function(){return(new sK).b()}}(this))),KCa=(new A).e(&quot;SUBSTRING&quot;,K(function(){return function(){return(new tK).b()}}(this))),LCa=(new A).e(&quot;SUBTRACT-HEADINGS&quot;,K(function(){return function(){return(new uK).b()}}(this))),MCa=(new A).e(&quot;SUM&quot;,K(function(){return function(){return(new vK).b()}}(this))),NCa=(new A).e(&quot;TAN&quot;,
K(function(){return function(){return(new wK).b()}}(this))),OCa=(new A).e(&quot;TICKS&quot;,K(function(){return function(){return(new xK).b()}}(this))),PCa=(new A).e(&quot;TIMER&quot;,K(function(){return function(){return(new yK).b()}}(this))),QCa=(new A).e(&quot;TOWARDS&quot;,K(function(){return function(){return(new zK).b()}}(this))),RCa=(new A).e(&quot;TOWARDSXY&quot;,K(function(){return function(){return(new AK).b()}}(this))),SCa=(new A).e(&quot;TURTLE&quot;,K(function(){return function(){return(new BK).b()}}(this))),TCa=(new A).e(&quot;TURTLE-SET&quot;,
K(function(){return function(){return(new CK).b()}}(this))),UCa=(new A).e(&quot;TURTLES&quot;,K(function(){return function(){return(new DK).b()}}(this))),VCa=(new A).e(&quot;TURTLES-AT&quot;,K(function(){return function(){return(new EK).b()}}(this))),WCa=(new A).e(&quot;TURTLES-HERE&quot;,K(function(){return function(){return(new FK).b()}}(this))),XCa=(new A).e(&quot;TURTLES-ON&quot;,K(function(){return function(){return(new GK).b()}}(this))),YCa=(new A).e(&quot;USER-DIRECTORY&quot;,K(function(){return function(){return(new HK).b()}}(this))),ZCa=
(new A).e(&quot;USER-FILE&quot;,K(function(){return function(){return(new IK).b()}}(this))),$Ca=(new A).e(&quot;USER-INPUT&quot;,K(function(){return function(){return(new JK).b()}}(this))),aDa=(new A).e(&quot;USER-NEW-FILE&quot;,K(function(){return function(){return(new KK).b()}}(this))),bDa=(new A).e(&quot;USER-ONE-OF&quot;,K(function(){return function(){return(new LK).b()}}(this))),cDa=(new A).e(&quot;USER-YES-OR-NO?&quot;,K(function(){return function(){return(new MK).b()}}(this))),dDa=(new A).e(&quot;VARIANCE&quot;,K(function(){return function(){return(new NK).b()}}(this))),
eDa=(new A).e(&quot;WITH&quot;,K(function(){return function(){return(new OK).b()}}(this))),fDa=(new A).e(&quot;WITH-MAX&quot;,K(function(){return function(){return(new PK).b()}}(this))),gDa=(new A).e(&quot;WITH-MIN&quot;,K(function(){return function(){return(new QK).b()}}(this))),hDa=(new A).e(&quot;WORD&quot;,K(function(){return function(){return(new RK).b()}}(this))),iDa=(new A).e(&quot;WORLD-HEIGHT&quot;,K(function(){return function(){return(new SK).b()}}(this))),jDa=(new A).e(&quot;WORLD-WIDTH&quot;,K(function(){return function(){return(new TK).b()}}(this))),
kDa=(new A).e(&quot;WRAP-COLOR&quot;,K(function(){return function(){return(new UK).b()}}(this)));this.ij=nh(pg,(new w).f([Yh,Ri,fk,Si,gk,Ti,vl,Ui,hk,Vi,wl,vh,xl,wh,ik,yl,Zh,$h,zl,Al,Bl,jk,Cl,Dl,El,Fl,kk,Gl,ai,lk,xh,Hl,Wi,mk,yh,Uf,ue,zh,bi,nk,Xi,Il,Yi,Jl,Zi,$i,ok,Kl,aj,ci,Ll,Rg,Sg,pk,bj,Ah,qk,Ml,rk,Tg,Nl,cj,di,Bh,Ol,qg,fi,Ch,dj,Ug,ej,fj,gi,hi,gj,Vf,vf,ae,hj,rg,ij,jj,ii,ji,Pl,sk,Vg,ki,Ql,tk,ei,qF,xw,cx,WF,wr,dx,vk,Bn,am,ex,xr,Cn,wk,YF,yr,bm,zr,ZF,$F,Dn,aG,e7,f7,h7,i7,j7,k7,HG,l7,m7,o7,p7,q7,GZ,Lr,r7,IG,s7,t7,
u7,v7,w7,x7,HZ,y7,z7,A7,B7,kBa,lBa,mBa,nBa,oBa,pBa,qBa,rBa,sBa,tBa,uBa,vBa,wBa,xBa,yBa,zBa,ABa,BBa,CBa,DBa,EBa,FBa,GBa,HBa,IBa,JBa,KBa,LBa,MBa,NBa,OBa,PBa,QBa,RBa,SBa,TBa,UBa,VBa,WBa,XBa,YBa,ZBa,$Ba,aCa,bCa,cCa,dCa,eCa,fCa,gCa,hCa,iCa,jCa,kCa,lCa,mCa,nCa,oCa,pCa,qCa,rCa,sCa,tCa,uCa,vCa,wCa,xCa,yCa,zCa,ACa,BCa,CCa,DCa,ECa,FCa,GCa,HCa,ICa,JCa,KCa,LCa,MCa,NCa,OCa,PCa,QCa,RCa,SCa,TCa,UCa,VCa,WCa,XCa,YCa,ZCa,$Ca,aDa,bDa,cDa,dDa,eDa,fDa,gDa,hDa,iDa,jDa,kDa,(new A).e(&quot;XOR&quot;,K(function(){return function(){return(new VK).b()}}(this)))]));
this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;var lDa=$e().kk,mDa=(new A).e(&quot;__APPLY&quot;,K(function(){return function(){return(new WK).b()}}(this))),nDa=(new A).e(&quot;__BENCH&quot;,K(function(){return function(){return(new XK).b()}}(this))),oDa=(new A).e(&quot;__CHANGE-TOPOLOGY&quot;,K(function(){return function(){return(new YK).b()}}(this))),pDa=(new A).e(&quot;__DONE&quot;,K(function(){return function(){return(new ZK).b()}}(this))),qDa=(new A).e(&quot;__EXPERIMENTSTEPEND&quot;,K(function(){return function(){return(new $K).b()}}(this))),rDa=(new A).e(&quot;__EXPORT-DRAWING&quot;,
K(function(){return function(){return(new aL).b()}}(this))),sDa=(new A).e(&quot;__FOREVERBUTTONEND&quot;,K(function(){return function(){return(new bL).b()}}(this))),tDa=(new A).e(&quot;__IGNORE&quot;,K(function(){return function(){return(new cL).b()}}(this))),uDa=(new A).e(&quot;__LET&quot;,K(function(){return function(){return(new dL).b()}}(this))),vDa=(new A).e(&quot;__LINKCODE&quot;,K(function(){return function(){return(new eL).b()}}(this))),wDa=(new A).e(&quot;__MKDIR&quot;,K(function(){return function(){return(new fL).b()}}(this))),xDa=(new A).e(&quot;__OBSERVERCODE&quot;,
K(function(){return function(){return(new gL).b()}}(this))),yDa=(new A).e(&quot;__PATCHCODE&quot;,K(function(){return function(){return(new hL).b()}}(this))),zDa=(new A).e(&quot;__PLOT-PEN-HIDE&quot;,K(function(){return function(){return(new iL).b()}}(this))),ADa=(new A).e(&quot;__PLOT-PEN-SHOW&quot;,K(function(){return function(){return(new jL).b()}}(this))),BDa=(new A).e(&quot;__PWD&quot;,K(function(){return function(){return(new kL).b()}}(this))),CDa=(new A).e(&quot;__RELOAD-EXTENSIONS&quot;,K(function(){return function(){return(new lL).b()}}(this))),
DDa=(new A).e(&quot;__SET-LINE-THICKNESS&quot;,K(function(){return function(){return(new mL).b()}}(this))),EDa=(new A).e(&quot;__STDERR&quot;,K(function(){return function(){return(new nL).b()}}(this))),FDa=(new A).e(&quot;__STDOUT&quot;,K(function(){return function(){return(new oL).b()}}(this))),GDa=(new A).e(&quot;__THUNK-DID-FINISH&quot;,K(function(){return function(){return(new pL).b()}}(this))),HDa=(new A).e(&quot;__TURTLECODE&quot;,K(function(){return function(){return(new qL).b()}}(this))),IDa=(new A).e(&quot;ASK&quot;,K(function(){return function(){return(new rL).b()}}(this))),
JDa=(new A).e(&quot;ASK-CONCURRENT&quot;,K(function(){return function(){return(new sL).b()}}(this))),KDa=(new A).e(&quot;AUTO-PLOT-OFF&quot;,K(function(){return function(){return(new tL).b()}}(this))),LDa=(new A).e(&quot;AUTO-PLOT-ON&quot;,K(function(){return function(){return(new uL).b()}}(this))),MDa=(new A).e(&quot;BACK&quot;,K(function(){return function(){return(new vL).b()}}(this))),NDa=(new A).e(&quot;BEEP&quot;,K(function(){return function(){return(new wL).b()}}(this))),ODa=(new A).e(&quot;BK&quot;,K(function(){return function(){return(new vL).b()}}(this))),
PDa=(new A).e(&quot;CA&quot;,K(function(){return function(){return(new xL).b()}}(this))),QDa=(new A).e(&quot;CAREFULLY&quot;,K(function(){return function(){return(new yL).b()}}(this))),RDa=(new A).e(&quot;CD&quot;,K(function(){return function(){return(new zL).b()}}(this))),SDa=(new A).e(&quot;CLEAR-ALL&quot;,K(function(){return function(){return(new xL).b()}}(this))),TDa=(new A).e(&quot;CLEAR-ALL-PLOTS&quot;,K(function(){return function(){return(new AL).b()}}(this))),UDa=(new A).e(&quot;CLEAR-DRAWING&quot;,K(function(){return function(){return(new zL).b()}}(this))),
VDa=(new A).e(&quot;CLEAR-GLOBALS&quot;,K(function(){return function(){return(new BL).b()}}(this))),WDa=(new A).e(&quot;CLEAR-LINKS&quot;,K(function(){return function(){return(new CL).b()}}(this))),XDa=(new A).e(&quot;CLEAR-OUTPUT&quot;,K(function(){return function(){return(new DL).b()}}(this))),YDa=(new A).e(&quot;CLEAR-PATCHES&quot;,K(function(){return function(){return(new EL).b()}}(this))),ZDa=(new A).e(&quot;CLEAR-PLOT&quot;,K(function(){return function(){return(new FL).b()}}(this))),$Da=(new A).e(&quot;CLEAR-TICKS&quot;,K(function(){return function(){return(new GL).b()}}(this))),
aEa=(new A).e(&quot;CLEAR-TURTLES&quot;,K(function(){return function(){return(new HL).b()}}(this))),bEa=(new A).e(&quot;CP&quot;,K(function(){return function(){return(new EL).b()}}(this))),cEa=(new A).e(&quot;CREATE-LINK-FROM&quot;,K(function(){return function(){return(new zG).b()}}(this))),dEa=(new A).e(&quot;CREATE-LINK-TO&quot;,K(function(){return function(){return(new yG).b()}}(this))),eEa=(new A).e(&quot;CREATE-LINK-WITH&quot;,K(function(){return function(){return(new xG).b()}}(this))),fEa=(new A).e(&quot;CREATE-LINKS-FROM&quot;,K(function(){return function(){return(new CG).b()}}(this))),
gEa=(new A).e(&quot;CREATE-LINKS-TO&quot;,K(function(){return function(){return(new BG).b()}}(this))),hEa=(new A).e(&quot;CREATE-LINKS-WITH&quot;,K(function(){return function(){return(new AG).b()}}(this))),iEa=(new A).e(&quot;CREATE-ORDERED-TURTLES&quot;,K(function(){return function(){return(new VF).b()}}(this))),jEa=(new A).e(&quot;CREATE-TEMPORARY-PLOT-PEN&quot;,K(function(){return function(){return(new IL).b()}}(this))),kEa=(new A).e(&quot;CREATE-TURTLES&quot;,K(function(){return function(){return(new XF).b()}}(this))),lEa=(new A).e(&quot;CRO&quot;,K(function(){return function(){return(new VF).b()}}(this))),
mEa=(new A).e(&quot;CRT&quot;,K(function(){return function(){return(new XF).b()}}(this))),nEa=(new A).e(&quot;CT&quot;,K(function(){return function(){return(new HL).b()}}(this))),oEa=(new A).e(&quot;DIE&quot;,K(function(){return function(){return(new JL).b()}}(this))),pEa=(new A).e(&quot;DIFFUSE&quot;,K(function(){return function(){return(new KL).b()}}(this))),qEa=(new A).e(&quot;DIFFUSE4&quot;,K(function(){return function(){return(new LL).b()}}(this))),rEa=(new A).e(&quot;DISPLAY&quot;,K(function(){return function(){return(new ML).b()}}(this))),sEa=(new A).e(&quot;DOWNHILL&quot;,
K(function(){return function(){return(new NL).b()}}(this))),tEa=(new A).e(&quot;DOWNHILL4&quot;,K(function(){return function(){return(new OL).b()}}(this))),uEa=(new A).e(&quot;ERROR&quot;,K(function(){return function(){return(new PL).b()}}(this))),vEa=(new A).e(&quot;EVERY&quot;,K(function(){return function(){return(new QL).b()}}(this))),wEa=(new A).e(&quot;EXPORT-ALL-PLOTS&quot;,K(function(){return function(){return(new RL).b()}}(this))),xEa=(new A).e(&quot;EXPORT-INTERFACE&quot;,K(function(){return function(){return(new SL).b()}}(this))),yEa=(new A).e(&quot;EXPORT-OUTPUT&quot;,
K(function(){return function(){return(new TL).b()}}(this))),zEa=(new A).e(&quot;EXPORT-PLOT&quot;,K(function(){return function(){return(new UL).b()}}(this))),AEa=(new A).e(&quot;EXPORT-VIEW&quot;,K(function(){return function(){return(new VL).b()}}(this))),BEa=(new A).e(&quot;EXPORT-WORLD&quot;,K(function(){return function(){return(new WL).b()}}(this))),CEa=(new A).e(&quot;FACE&quot;,K(function(){return function(){return(new XL).b()}}(this))),DEa=(new A).e(&quot;FACEXY&quot;,K(function(){return function(){return(new YL).b()}}(this))),EEa=(new A).e(&quot;FD&quot;,
K(function(){return function(){return(new ZL).b()}}(this))),FEa=(new A).e(&quot;FILE-CLOSE&quot;,K(function(){return function(){return(new $L).b()}}(this))),GEa=(new A).e(&quot;FILE-CLOSE-ALL&quot;,K(function(){return function(){return(new aM).b()}}(this))),HEa=(new A).e(&quot;FILE-DELETE&quot;,K(function(){return function(){return(new bM).b()}}(this))),IEa=(new A).e(&quot;FILE-FLUSH&quot;,K(function(){return function(){return(new cM).b()}}(this))),JEa=(new A).e(&quot;FILE-OPEN&quot;,K(function(){return function(){return(new dM).b()}}(this))),KEa=
(new A).e(&quot;FILE-PRINT&quot;,K(function(){return function(){return(new eM).b()}}(this))),LEa=(new A).e(&quot;FILE-SHOW&quot;,K(function(){return function(){return(new fM).b()}}(this))),MEa=(new A).e(&quot;FILE-TYPE&quot;,K(function(){return function(){return(new gM).b()}}(this))),NEa=(new A).e(&quot;FILE-WRITE&quot;,K(function(){return function(){return(new hM).b()}}(this))),OEa=(new A).e(&quot;FOLLOW&quot;,K(function(){return function(){return(new iM).b()}}(this))),PEa=(new A).e(&quot;FOLLOW-ME&quot;,K(function(){return function(){return(new jM).b()}}(this))),
QEa=(new A).e(&quot;FOREACH&quot;,K(function(){return function(){return(new kM).b()}}(this))),REa=(new A).e(&quot;FORWARD&quot;,K(function(){return function(){return(new ZL).b()}}(this))),SEa=(new A).e(&quot;HATCH&quot;,K(function(){return function(){return(new bG).b()}}(this))),TEa=(new A).e(&quot;HIDE-LINK&quot;,K(function(){return function(){return(new lM).b()}}(this))),UEa=(new A).e(&quot;HIDE-TURTLE&quot;,K(function(){return function(){return(new mM).b()}}(this))),VEa=(new A).e(&quot;HISTOGRAM&quot;,K(function(){return function(){return(new nM).b()}}(this))),
WEa=(new A).e(&quot;HOME&quot;,K(function(){return function(){return(new oM).b()}}(this))),XEa=(new A).e(&quot;HT&quot;,K(function(){return function(){return(new mM).b()}}(this))),YEa=(new A).e(&quot;HUBNET-BROADCAST&quot;,K(function(){return function(){return(new pM).b()}}(this))),ZEa=(new A).e(&quot;HUBNET-BROADCAST-CLEAR-OUTPUT&quot;,K(function(){return function(){return(new qM).b()}}(this))),$Ea=(new A).e(&quot;HUBNET-BROADCAST-MESSAGE&quot;,K(function(){return function(){return(new rM).b()}}(this))),aFa=(new A).e(&quot;HUBNET-CLEAR-OVERRIDE&quot;,K(function(){return function(){return(new sM).b()}}(this))),
bFa=(new A).e(&quot;HUBNET-CLEAR-OVERRIDES&quot;,K(function(){return function(){return(new tM).b()}}(this))),cFa=(new A).e(&quot;HUBNET-FETCH-MESSAGE&quot;,K(function(){return function(){return(new uM).b()}}(this))),dFa=(new A).e(&quot;HUBNET-KICK-ALL-CLIENTS&quot;,K(function(){return function(){return(new vM).b()}}(this))),eFa=(new A).e(&quot;HUBNET-KICK-CLIENT&quot;,K(function(){return function(){return(new wM).b()}}(this))),fFa=(new A).e(&quot;HUBNET-RESET&quot;,K(function(){return function(){return(new xM).b()}}(this))),gFa=(new A).e(&quot;HUBNET-RESET-PERSPECTIVE&quot;,
K(function(){return function(){return(new yM).b()}}(this))),hFa=(new A).e(&quot;HUBNET-SEND&quot;,K(function(){return function(){return(new zM).b()}}(this))),iFa=(new A).e(&quot;HUBNET-SEND-CLEAR-OUTPUT&quot;,K(function(){return function(){return(new AM).b()}}(this))),jFa=(new A).e(&quot;HUBNET-SEND-FOLLOW&quot;,K(function(){return function(){return(new BM).b()}}(this))),kFa=(new A).e(&quot;HUBNET-SEND-MESSAGE&quot;,K(function(){return function(){return(new CM).b()}}(this))),lFa=(new A).e(&quot;HUBNET-SEND-OVERRIDE&quot;,K(function(){return function(){return(new DM).b()}}(this))),
mFa=(new A).e(&quot;HUBNET-SEND-WATCH&quot;,K(function(){return function(){return(new EM).b()}}(this))),nFa=(new A).e(&quot;IF&quot;,K(function(){return function(){return(new FM).b()}}(this))),oFa=(new A).e(&quot;IF-ELSE&quot;,K(function(){return function(){return(new GM).b()}}(this))),pFa=(new A).e(&quot;IFELSE&quot;,K(function(){return function(){return(new GM).b()}}(this))),qFa=(new A).e(&quot;IMPORT-DRAWING&quot;,K(function(){return function(){return(new HM).b()}}(this))),rFa=(new A).e(&quot;IMPORT-PCOLORS&quot;,K(function(){return function(){return(new IM).b()}}(this))),
sFa=(new A).e(&quot;IMPORT-PCOLORS-RGB&quot;,K(function(){return function(){return(new JM).b()}}(this))),tFa=(new A).e(&quot;IMPORT-WORLD&quot;,K(function(){return function(){return(new KM).b()}}(this))),uFa=(new A).e(&quot;INSPECT&quot;,K(function(){return function(){return(new LM).b()}}(this))),vFa=(new A).e(&quot;JUMP&quot;,K(function(){return function(){return(new MM).b()}}(this))),wFa=(new A).e(&quot;LAYOUT-CIRCLE&quot;,K(function(){return function(){return(new NM).b()}}(this))),xFa=(new A).e(&quot;LAYOUT-RADIAL&quot;,K(function(){return function(){return(new OM).b()}}(this))),
yFa=(new A).e(&quot;LAYOUT-SPRING&quot;,K(function(){return function(){return(new PM).b()}}(this))),zFa=(new A).e(&quot;LAYOUT-TUTTE&quot;,K(function(){return function(){return(new QM).b()}}(this))),AFa=(new A).e(&quot;LEFT&quot;,K(function(){return function(){return(new RM).b()}}(this))),BFa=(new A).e(&quot;LET&quot;,K(function(){return function(){return(new dL).b()}}(this))),CFa=(new A).e(&quot;LOOP&quot;,K(function(){return function(){return(new SM).b()}}(this))),DFa=(new A).e(&quot;LT&quot;,K(function(){return function(){return(new RM).b()}}(this))),EFa=
(new A).e(&quot;MOVE-TO&quot;,K(function(){return function(){return(new TM).b()}}(this))),FFa=(new A).e(&quot;NO-DISPLAY&quot;,K(function(){return function(){return(new UM).b()}}(this))),GFa=(new A).e(&quot;OUTPUT-PRINT&quot;,K(function(){return function(){return(new VM).b()}}(this))),HFa=(new A).e(&quot;OUTPUT-SHOW&quot;,K(function(){return function(){return(new WM).b()}}(this))),IFa=(new A).e(&quot;OUTPUT-TYPE&quot;,K(function(){return function(){return(new XM).b()}}(this))),JFa=(new A).e(&quot;OUTPUT-WRITE&quot;,K(function(){return function(){return(new YM).b()}}(this))),
KFa=(new A).e(&quot;PD&quot;,K(function(){return function(){return(new ZM).b()}}(this))),LFa=(new A).e(&quot;PE&quot;,K(function(){return function(){return(new $M).b()}}(this))),MFa=(new A).e(&quot;PEN-DOWN&quot;,K(function(){return function(){return(new ZM).b()}}(this))),NFa=(new A).e(&quot;PEN-ERASE&quot;,K(function(){return function(){return(new $M).b()}}(this))),OFa=(new A).e(&quot;PEN-UP&quot;,K(function(){return function(){return(new aN).b()}}(this))),PFa=(new A).e(&quot;PENDOWN&quot;,K(function(){return function(){return(new ZM).b()}}(this))),QFa=(new A).e(&quot;PENUP&quot;,
K(function(){return function(){return(new aN).b()}}(this))),RFa=(new A).e(&quot;PLOT&quot;,K(function(){return function(){return(new bN).b()}}(this))),SFa=(new A).e(&quot;PLOT-PEN-DOWN&quot;,K(function(){return function(){return(new cN).b()}}(this))),TFa=(new A).e(&quot;PLOT-PEN-RESET&quot;,K(function(){return function(){return(new dN).b()}}(this))),UFa=(new A).e(&quot;PLOT-PEN-UP&quot;,K(function(){return function(){return(new eN).b()}}(this))),VFa=(new A).e(&quot;PLOTXY&quot;,K(function(){return function(){return(new fN).b()}}(this))),WFa=(new A).e(&quot;PRINT&quot;,
K(function(){return function(){return(new gN).b()}}(this))),XFa=(new A).e(&quot;PU&quot;,K(function(){return function(){return(new aN).b()}}(this))),YFa=(new A).e(&quot;RANDOM-SEED&quot;,K(function(){return function(){return(new hN).b()}}(this))),ZFa=(new A).e(&quot;REPEAT&quot;,K(function(){return function(){return(new iN).b()}}(this))),$Fa=(new A).e(&quot;REPORT&quot;,K(function(){return function(){return(new jN).b()}}(this))),aGa=(new A).e(&quot;RESET-PERSPECTIVE&quot;,K(function(){return function(){return(new kN).b()}}(this))),bGa=(new A).e(&quot;RESET-TICKS&quot;,
K(function(){return function(){return(new lN).b()}}(this))),cGa=(new A).e(&quot;RESET-TIMER&quot;,K(function(){return function(){return(new mN).b()}}(this))),dGa=(new A).e(&quot;RESIZE-WORLD&quot;,K(function(){return function(){return(new nN).b()}}(this))),eGa=(new A).e(&quot;RIDE&quot;,K(function(){return function(){return(new oN).b()}}(this))),fGa=(new A).e(&quot;RIDE-ME&quot;,K(function(){return function(){return(new pN).b()}}(this))),gGa=(new A).e(&quot;RIGHT&quot;,K(function(){return function(){return(new qN).b()}}(this))),hGa=(new A).e(&quot;RP&quot;,
K(function(){return function(){return(new kN).b()}}(this))),iGa=(new A).e(&quot;RT&quot;,K(function(){return function(){return(new qN).b()}}(this))),jGa=(new A).e(&quot;RUN&quot;,K(function(){return function(){return(new rN).b()}}(this))),kGa=(new A).e(&quot;SET&quot;,K(function(){return function(){return(new sN).b()}}(this))),lGa=(new A).e(&quot;SET-CURRENT-DIRECTORY&quot;,K(function(){return function(){return(new tN).b()}}(this))),mGa=(new A).e(&quot;SET-CURRENT-PLOT&quot;,K(function(){return function(){return(new uN).b()}}(this))),nGa=(new A).e(&quot;SET-CURRENT-PLOT-PEN&quot;,
K(function(){return function(){return(new vN).b()}}(this))),oGa=(new A).e(&quot;SET-DEFAULT-SHAPE&quot;,K(function(){return function(){return(new wN).b()}}(this))),pGa=(new A).e(&quot;SET-HISTOGRAM-NUM-BARS&quot;,K(function(){return function(){return(new xN).b()}}(this))),qGa=(new A).e(&quot;SET-PATCH-SIZE&quot;,K(function(){return function(){return(new yN).b()}}(this))),rGa=(new A).e(&quot;SET-PLOT-PEN-COLOR&quot;,K(function(){return function(){return(new zN).b()}}(this))),sGa=(new A).e(&quot;SET-PLOT-PEN-INTERVAL&quot;,K(function(){return function(){return(new AN).b()}}(this))),
tGa=(new A).e(&quot;SET-PLOT-PEN-MODE&quot;,K(function(){return function(){return(new BN).b()}}(this))),uGa=(new A).e(&quot;SET-PLOT-X-RANGE&quot;,K(function(){return function(){return(new CN).b()}}(this))),vGa=(new A).e(&quot;SET-PLOT-Y-RANGE&quot;,K(function(){return function(){return(new DN).b()}}(this))),wGa=(new A).e(&quot;SETUP-PLOTS&quot;,K(function(){return function(){return(new EN).b()}}(this))),xGa=(new A).e(&quot;SETXY&quot;,K(function(){return function(){return(new FN).b()}}(this))),yGa=(new A).e(&quot;SHOW&quot;,K(function(){return function(){return(new GN).b()}}(this))),
zGa=(new A).e(&quot;SHOW-LINK&quot;,K(function(){return function(){return(new HN).b()}}(this))),AGa=(new A).e(&quot;SHOW-TURTLE&quot;,K(function(){return function(){return(new IN).b()}}(this))),BGa=(new A).e(&quot;SPROUT&quot;,K(function(){return function(){return(new dG).b()}}(this))),CGa=(new A).e(&quot;ST&quot;,K(function(){return function(){return(new IN).b()}}(this))),DGa=(new A).e(&quot;STAMP&quot;,K(function(){return function(){return(new JN).b()}}(this))),EGa=(new A).e(&quot;STAMP-ERASE&quot;,K(function(){return function(){return(new KN).b()}}(this))),
FGa=(new A).e(&quot;STOP&quot;,K(function(){return function(){return(new LN).b()}}(this))),GGa=(new A).e(&quot;STOP-INSPECTING&quot;,K(function(){return function(){return(new MN).b()}}(this))),HGa=(new A).e(&quot;STOP-INSPECTING-DEAD-AGENTS&quot;,K(function(){return function(){return(new NN).b()}}(this))),IGa=(new A).e(&quot;TICK&quot;,K(function(){return function(){return(new ON).b()}}(this))),JGa=(new A).e(&quot;TICK-ADVANCE&quot;,K(function(){return function(){return(new PN).b()}}(this))),KGa=(new A).e(&quot;TIE&quot;,K(function(){return function(){return(new QN).b()}}(this))),
LGa=(new A).e(&quot;TYPE&quot;,K(function(){return function(){return(new RN).b()}}(this))),MGa=(new A).e(&quot;UNTIE&quot;,K(function(){return function(){return(new SN).b()}}(this))),NGa=(new A).e(&quot;UPDATE-PLOTS&quot;,K(function(){return function(){return(new TN).b()}}(this))),OGa=(new A).e(&quot;UPHILL&quot;,K(function(){return function(){return(new UN).b()}}(this))),PGa=(new A).e(&quot;UPHILL4&quot;,K(function(){return function(){return(new VN).b()}}(this))),QGa=(new A).e(&quot;USER-MESSAGE&quot;,K(function(){return function(){return(new WN).b()}}(this))),
RGa=(new A).e(&quot;WAIT&quot;,K(function(){return function(){return(new XN).b()}}(this))),SGa=(new A).e(&quot;WATCH&quot;,K(function(){return function(){return(new YN).b()}}(this))),TGa=(new A).e(&quot;WATCH-ME&quot;,K(function(){return function(){return(new ZN).b()}}(this))),UGa=(new A).e(&quot;WHILE&quot;,K(function(){return function(){return(new $N).b()}}(this))),VGa=(new A).e(&quot;WITH-LOCAL-RANDOMNESS&quot;,K(function(){return function(){return(new aO).b()}}(this))),WGa=(new A).e(&quot;WITHOUT-INTERRUPTION&quot;,K(function(){return function(){return(new bO).b()}}(this)));
this.Yi=nh(lDa,(new w).f([mDa,nDa,oDa,pDa,qDa,rDa,sDa,tDa,uDa,vDa,wDa,xDa,yDa,zDa,ADa,BDa,CDa,DDa,EDa,FDa,GDa,HDa,IDa,JDa,KDa,LDa,MDa,NDa,ODa,PDa,QDa,RDa,SDa,TDa,UDa,VDa,WDa,XDa,YDa,ZDa,$Da,aEa,bEa,cEa,dEa,eEa,fEa,gEa,hEa,iEa,jEa,kEa,lEa,mEa,nEa,oEa,pEa,qEa,rEa,sEa,tEa,uEa,vEa,wEa,xEa,yEa,zEa,AEa,BEa,CEa,DEa,EEa,FEa,GEa,HEa,IEa,JEa,KEa,LEa,MEa,NEa,OEa,PEa,QEa,REa,SEa,TEa,UEa,VEa,WEa,XEa,YEa,ZEa,$Ea,aFa,bFa,cFa,dFa,eFa,fFa,gFa,hFa,iFa,jFa,kFa,lFa,mFa,nFa,oFa,pFa,qFa,rFa,sFa,tFa,uFa,vFa,wFa,xFa,yFa,
zFa,AFa,BFa,CFa,DFa,EFa,FFa,GFa,HFa,IFa,JFa,KFa,LFa,MFa,NFa,OFa,PFa,QFa,RFa,SFa,TFa,UFa,VFa,WFa,XFa,YFa,ZFa,$Fa,aGa,bGa,cGa,dGa,eGa,fGa,gGa,hGa,iGa,jGa,kGa,lGa,mGa,nGa,oGa,pGa,qGa,rGa,sGa,tGa,uGa,vGa,wGa,xGa,yGa,zGa,AGa,BGa,CGa,DGa,EGa,FGa,GGa,HGa,IGa,JGa,KGa,LGa,MGa,NGa,OGa,PGa,QGa,RGa,SGa,TGa,UGa,VGa,WGa,(new A).e(&quot;WRITE&quot;,K(function(){return function(){return(new cO).b()}}(this)))]));this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;var XGa=$e().kk,YGa=I(r(),(new w).f([&quot;__APPLY&quot;])),ZGa=(new A).e(&quot;etc._apply&quot;,YGa),$Ga=
I(r(),(new w).f([&quot;__BENCH&quot;])),aHa=(new A).e(&quot;etc._bench&quot;,$Ga),bHa=I(r(),(new w).f([&quot;__CHANGE-TOPOLOGY&quot;])),cHa=(new A).e(&quot;etc._changetopology&quot;,bHa),dHa=I(r(),(new w).f([&quot;__DONE&quot;])),eHa=(new A).e(&quot;_done&quot;,dHa),fHa=I(r(),(new w).f([&quot;__EXPERIMENTSTEPEND&quot;])),gHa=(new A).e(&quot;etc._experimentstepend&quot;,fHa),hHa=I(r(),(new w).f([&quot;__EXPORT-DRAWING&quot;])),iHa=(new A).e(&quot;etc._exportdrawing&quot;,hHa),jHa=I(r(),(new w).f([&quot;__FOREVERBUTTONEND&quot;])),kHa=(new A).e(&quot;etc._foreverbuttonend&quot;,jHa),lHa=I(r(),(new w).f([&quot;__IGNORE&quot;])),
mHa=(new A).e(&quot;etc._ignore&quot;,lHa),nHa=I(r(),(new w).f([&quot;__LET&quot;,&quot;LET&quot;])),oHa=(new A).e(&quot;_let&quot;,nHa),pHa=I(r(),(new w).f([&quot;__LINKCODE&quot;])),qHa=(new A).e(&quot;etc._linkcode&quot;,pHa),rHa=I(r(),(new w).f([&quot;__MKDIR&quot;])),sHa=(new A).e(&quot;etc._mkdir&quot;,rHa),tHa=I(r(),(new w).f([&quot;__OBSERVERCODE&quot;])),uHa=(new A).e(&quot;etc._observercode&quot;,tHa),vHa=I(r(),(new w).f([&quot;__PATCHCODE&quot;])),wHa=(new A).e(&quot;etc._patchcode&quot;,vHa),xHa=I(r(),(new w).f([&quot;__PLOT-PEN-HIDE&quot;])),yHa=(new A).e(&quot;etc._plotpenhide&quot;,xHa),zHa=I(r(),(new w).f([&quot;__PLOT-PEN-SHOW&quot;])),
AHa=(new A).e(&quot;etc._plotpenshow&quot;,zHa),BHa=I(r(),(new w).f([&quot;__PWD&quot;])),CHa=(new A).e(&quot;etc._pwd&quot;,BHa),DHa=I(r(),(new w).f([&quot;__RELOAD-EXTENSIONS&quot;])),EHa=(new A).e(&quot;etc._reloadextensions&quot;,DHa),FHa=I(r(),(new w).f([&quot;__SET-LINE-THICKNESS&quot;])),GHa=(new A).e(&quot;etc._setlinethickness&quot;,FHa),HHa=I(r(),(new w).f([&quot;__STDERR&quot;])),IHa=(new A).e(&quot;etc._stderr&quot;,HHa),JHa=I(r(),(new w).f([&quot;__STDOUT&quot;])),KHa=(new A).e(&quot;etc._stdout&quot;,JHa),LHa=I(r(),(new w).f([&quot;__THUNK-DID-FINISH&quot;])),MHa=(new A).e(&quot;etc._thunkdidfinish&quot;,LHa),
NHa=I(r(),(new w).f([&quot;__TURTLECODE&quot;])),OHa=(new A).e(&quot;etc._turtlecode&quot;,NHa),PHa=I(r(),(new w).f([&quot;ASK&quot;])),QHa=(new A).e(&quot;_ask&quot;,PHa),RHa=I(r(),(new w).f([&quot;ASK-CONCURRENT&quot;])),SHa=(new A).e(&quot;_askconcurrent&quot;,RHa),THa=I(r(),(new w).f([&quot;AUTO-PLOT-OFF&quot;])),UHa=(new A).e(&quot;etc._autoplotoff&quot;,THa),VHa=I(r(),(new w).f([&quot;AUTO-PLOT-ON&quot;])),WHa=(new A).e(&quot;etc._autoploton&quot;,VHa),XHa=I(r(),(new w).f([&quot;BACK&quot;,&quot;BK&quot;])),YHa=(new A).e(&quot;_bk&quot;,XHa),ZHa=I(r(),(new w).f([&quot;BEEP&quot;])),$Ha=(new A).e(&quot;etc._beep&quot;,ZHa),aIa=I(r(),(new w).f([&quot;BACK&quot;,
&quot;BK&quot;])),bIa=(new A).e(&quot;_bk&quot;,aIa),cIa=I(r(),(new w).f([&quot;CA&quot;,&quot;CLEAR-ALL&quot;])),dIa=(new A).e(&quot;etc._clearall&quot;,cIa),eIa=I(r(),(new w).f([&quot;CAREFULLY&quot;])),fIa=(new A).e(&quot;_carefully&quot;,eIa),gIa=I(r(),(new w).f([&quot;CD&quot;,&quot;CLEAR-DRAWING&quot;])),hIa=(new A).e(&quot;etc._cleardrawing&quot;,gIa),iIa=I(r(),(new w).f([&quot;CA&quot;,&quot;CLEAR-ALL&quot;])),jIa=(new A).e(&quot;etc._clearall&quot;,iIa),kIa=I(r(),(new w).f([&quot;CLEAR-ALL-PLOTS&quot;])),lIa=(new A).e(&quot;etc._clearallplots&quot;,kIa),mIa=I(r(),(new w).f([&quot;CD&quot;,&quot;CLEAR-DRAWING&quot;])),nIa=(new A).e(&quot;etc._cleardrawing&quot;,mIa),
oIa=I(r(),(new w).f([&quot;CLEAR-GLOBALS&quot;])),pIa=(new A).e(&quot;etc._clearglobals&quot;,oIa),qIa=I(r(),(new w).f([&quot;CLEAR-LINKS&quot;])),rIa=(new A).e(&quot;etc._clearlinks&quot;,qIa),sIa=I(r(),(new w).f([&quot;CLEAR-OUTPUT&quot;])),tIa=(new A).e(&quot;etc._clearoutput&quot;,sIa),uIa=I(r(),(new w).f([&quot;CLEAR-PATCHES&quot;,&quot;CP&quot;])),vIa=(new A).e(&quot;etc._clearpatches&quot;,uIa),wIa=I(r(),(new w).f([&quot;CLEAR-PLOT&quot;])),xIa=(new A).e(&quot;etc._clearplot&quot;,wIa),yIa=I(r(),(new w).f([&quot;CLEAR-TICKS&quot;])),zIa=(new A).e(&quot;etc._clearticks&quot;,yIa),AIa=I(r(),(new w).f([&quot;CLEAR-TURTLES&quot;,&quot;CT&quot;])),
BIa=(new A).e(&quot;etc._clearturtles&quot;,AIa),CIa=I(r(),(new w).f([&quot;CLEAR-PATCHES&quot;,&quot;CP&quot;])),DIa=(new A).e(&quot;etc._clearpatches&quot;,CIa),EIa=I(r(),(new w).f([&quot;CREATE-LINK-FROM&quot;])),FIa=(new A).e(&quot;etc._createlinkfrom&quot;,EIa),GIa=I(r(),(new w).f([&quot;CREATE-LINK-TO&quot;])),HIa=(new A).e(&quot;etc._createlinkto&quot;,GIa),IIa=I(r(),(new w).f([&quot;CREATE-LINK-WITH&quot;])),JIa=(new A).e(&quot;etc._createlinkwith&quot;,IIa),KIa=I(r(),(new w).f([&quot;CREATE-LINKS-FROM&quot;])),LIa=(new A).e(&quot;etc._createlinksfrom&quot;,KIa),MIa=I(r(),(new w).f([&quot;CREATE-LINKS-TO&quot;])),NIa=
(new A).e(&quot;etc._createlinksto&quot;,MIa),OIa=I(r(),(new w).f([&quot;CREATE-LINKS-WITH&quot;])),PIa=(new A).e(&quot;etc._createlinkswith&quot;,OIa),QIa=I(r(),(new w).f([&quot;CREATE-ORDERED-TURTLES&quot;,&quot;CRO&quot;])),RIa=(new A).e(&quot;_createorderedturtles&quot;,QIa),SIa=I(r(),(new w).f([&quot;CREATE-TEMPORARY-PLOT-PEN&quot;])),TIa=(new A).e(&quot;etc._createtemporaryplotpen&quot;,SIa),UIa=I(r(),(new w).f([&quot;CREATE-TURTLES&quot;,&quot;CRT&quot;])),VIa=(new A).e(&quot;_createturtles&quot;,UIa),WIa=I(r(),(new w).f([&quot;CREATE-ORDERED-TURTLES&quot;,&quot;CRO&quot;])),XIa=(new A).e(&quot;_createorderedturtles&quot;,WIa),
YIa=I(r(),(new w).f([&quot;CREATE-TURTLES&quot;,&quot;CRT&quot;])),ZIa=(new A).e(&quot;_createturtles&quot;,YIa),$Ia=I(r(),(new w).f([&quot;CLEAR-TURTLES&quot;,&quot;CT&quot;])),aJa=(new A).e(&quot;etc._clearturtles&quot;,$Ia),bJa=I(r(),(new w).f([&quot;DIE&quot;])),cJa=(new A).e(&quot;etc._die&quot;,bJa),dJa=I(r(),(new w).f([&quot;DIFFUSE&quot;])),eJa=(new A).e(&quot;etc._diffuse&quot;,dJa),fJa=I(r(),(new w).f([&quot;DIFFUSE4&quot;])),gJa=(new A).e(&quot;etc._diffuse4&quot;,fJa),hJa=I(r(),(new w).f([&quot;DISPLAY&quot;])),iJa=(new A).e(&quot;etc._display&quot;,hJa),jJa=I(r(),(new w).f([&quot;DOWNHILL&quot;])),kJa=(new A).e(&quot;etc._downhill&quot;,jJa),
lJa=I(r(),(new w).f([&quot;DOWNHILL4&quot;])),mJa=(new A).e(&quot;etc._downhill4&quot;,lJa),nJa=I(r(),(new w).f([&quot;ERROR&quot;])),oJa=(new A).e(&quot;etc._error&quot;,nJa),pJa=I(r(),(new w).f([&quot;EVERY&quot;])),qJa=(new A).e(&quot;etc._every&quot;,pJa),rJa=I(r(),(new w).f([&quot;EXPORT-ALL-PLOTS&quot;])),sJa=(new A).e(&quot;etc._exportplots&quot;,rJa),tJa=I(r(),(new w).f([&quot;EXPORT-INTERFACE&quot;])),uJa=(new A).e(&quot;etc._exportinterface&quot;,tJa),vJa=I(r(),(new w).f([&quot;EXPORT-OUTPUT&quot;])),wJa=(new A).e(&quot;etc._exportoutput&quot;,vJa),xJa=I(r(),(new w).f([&quot;EXPORT-PLOT&quot;])),yJa=(new A).e(&quot;etc._exportplot&quot;,
xJa),zJa=I(r(),(new w).f([&quot;EXPORT-VIEW&quot;])),AJa=(new A).e(&quot;etc._exportview&quot;,zJa),BJa=I(r(),(new w).f([&quot;EXPORT-WORLD&quot;])),CJa=(new A).e(&quot;etc._exportworld&quot;,BJa),DJa=I(r(),(new w).f([&quot;FACE&quot;])),EJa=(new A).e(&quot;etc._face&quot;,DJa),FJa=I(r(),(new w).f([&quot;FACEXY&quot;])),GJa=(new A).e(&quot;etc._facexy&quot;,FJa),HJa=I(r(),(new w).f([&quot;FD&quot;,&quot;FORWARD&quot;])),IJa=(new A).e(&quot;_fd&quot;,HJa),JJa=I(r(),(new w).f([&quot;FILE-CLOSE&quot;])),KJa=(new A).e(&quot;etc._fileclose&quot;,JJa),LJa=I(r(),(new w).f([&quot;FILE-CLOSE-ALL&quot;])),MJa=(new A).e(&quot;etc._filecloseall&quot;,LJa),
NJa=I(r(),(new w).f([&quot;FILE-DELETE&quot;])),OJa=(new A).e(&quot;etc._filedelete&quot;,NJa),PJa=I(r(),(new w).f([&quot;FILE-FLUSH&quot;])),QJa=(new A).e(&quot;etc._fileflush&quot;,PJa),RJa=I(r(),(new w).f([&quot;FILE-OPEN&quot;])),SJa=(new A).e(&quot;etc._fileopen&quot;,RJa),TJa=I(r(),(new w).f([&quot;FILE-PRINT&quot;])),UJa=(new A).e(&quot;etc._fileprint&quot;,TJa),VJa=I(r(),(new w).f([&quot;FILE-SHOW&quot;])),WJa=(new A).e(&quot;etc._fileshow&quot;,VJa),XJa=I(r(),(new w).f([&quot;FILE-TYPE&quot;])),YJa=(new A).e(&quot;etc._filetype&quot;,XJa),ZJa=I(r(),(new w).f([&quot;FILE-WRITE&quot;])),$Ja=(new A).e(&quot;etc._filewrite&quot;,
ZJa),aKa=I(r(),(new w).f([&quot;FOLLOW&quot;])),bKa=(new A).e(&quot;etc._follow&quot;,aKa),cKa=I(r(),(new w).f([&quot;FOLLOW-ME&quot;])),dKa=(new A).e(&quot;etc._followme&quot;,cKa),eKa=I(r(),(new w).f([&quot;FOREACH&quot;])),fKa=(new A).e(&quot;etc._foreach&quot;,eKa),gKa=I(r(),(new w).f([&quot;FD&quot;,&quot;FORWARD&quot;])),hKa=(new A).e(&quot;_fd&quot;,gKa),iKa=I(r(),(new w).f([&quot;HATCH&quot;])),jKa=(new A).e(&quot;_hatch&quot;,iKa),kKa=I(r(),(new w).f([&quot;HIDE-LINK&quot;])),lKa=(new A).e(&quot;etc._hidelink&quot;,kKa),mKa=I(r(),(new w).f([&quot;HIDE-TURTLE&quot;,&quot;HT&quot;])),nKa=(new A).e(&quot;etc._hideturtle&quot;,mKa),oKa=I(r(),(new w).f([&quot;HISTOGRAM&quot;])),
pKa=(new A).e(&quot;etc._histogram&quot;,oKa),qKa=I(r(),(new w).f([&quot;HOME&quot;])),rKa=(new A).e(&quot;etc._home&quot;,qKa),sKa=I(r(),(new w).f([&quot;HIDE-TURTLE&quot;,&quot;HT&quot;])),tKa=(new A).e(&quot;etc._hideturtle&quot;,sKa),uKa=I(r(),(new w).f([&quot;HUBNET-BROADCAST&quot;])),vKa=(new A).e(&quot;hubnet._hubnetbroadcast&quot;,uKa),wKa=I(r(),(new w).f([&quot;HUBNET-BROADCAST-CLEAR-OUTPUT&quot;])),xKa=(new A).e(&quot;hubnet._hubnetbroadcastclearoutput&quot;,wKa),yKa=I(r(),(new w).f([&quot;HUBNET-BROADCAST-MESSAGE&quot;])),zKa=(new A).e(&quot;hubnet._hubnetbroadcastmessage&quot;,yKa),AKa=I(r(),(new w).f([&quot;HUBNET-CLEAR-OVERRIDE&quot;])),
BKa=(new A).e(&quot;hubnet._hubnetclearoverride&quot;,AKa),CKa=I(r(),(new w).f([&quot;HUBNET-CLEAR-OVERRIDES&quot;])),DKa=(new A).e(&quot;hubnet._hubnetclearoverrides&quot;,CKa),EKa=I(r(),(new w).f([&quot;HUBNET-FETCH-MESSAGE&quot;])),FKa=(new A).e(&quot;hubnet._hubnetfetchmessage&quot;,EKa),GKa=I(r(),(new w).f([&quot;HUBNET-KICK-ALL-CLIENTS&quot;])),HKa=(new A).e(&quot;hubnet._hubnetkickallclients&quot;,GKa),IKa=I(r(),(new w).f([&quot;HUBNET-KICK-CLIENT&quot;])),JKa=(new A).e(&quot;hubnet._hubnetkickclient&quot;,IKa),KKa=I(r(),(new w).f([&quot;HUBNET-RESET&quot;])),LKa=(new A).e(&quot;hubnet._hubnetreset&quot;,
KKa),MKa=I(r(),(new w).f([&quot;HUBNET-RESET-PERSPECTIVE&quot;])),NKa=(new A).e(&quot;hubnet._hubnetresetperspective&quot;,MKa),OKa=I(r(),(new w).f([&quot;HUBNET-SEND&quot;])),PKa=(new A).e(&quot;hubnet._hubnetsend&quot;,OKa),QKa=I(r(),(new w).f([&quot;HUBNET-SEND-CLEAR-OUTPUT&quot;])),RKa=(new A).e(&quot;hubnet._hubnetsendclearoutput&quot;,QKa),SKa=I(r(),(new w).f([&quot;HUBNET-SEND-FOLLOW&quot;])),TKa=(new A).e(&quot;hubnet._hubnetsendfollow&quot;,SKa),UKa=I(r(),(new w).f([&quot;HUBNET-SEND-MESSAGE&quot;])),VKa=(new A).e(&quot;hubnet._hubnetsendmessage&quot;,UKa),WKa=I(r(),(new w).f([&quot;HUBNET-SEND-OVERRIDE&quot;])),
XKa=(new A).e(&quot;hubnet._hubnetsendoverride&quot;,WKa),YKa=I(r(),(new w).f([&quot;HUBNET-SEND-WATCH&quot;])),ZKa=(new A).e(&quot;hubnet._hubnetsendwatch&quot;,YKa),$Ka=I(r(),(new w).f([&quot;IF&quot;])),aLa=(new A).e(&quot;etc._if&quot;,$Ka),bLa=I(r(),(new w).f([&quot;IF-ELSE&quot;,&quot;IFELSE&quot;])),cLa=(new A).e(&quot;etc._ifelse&quot;,bLa),dLa=I(r(),(new w).f([&quot;IF-ELSE&quot;,&quot;IFELSE&quot;])),eLa=(new A).e(&quot;etc._ifelse&quot;,dLa),fLa=I(r(),(new w).f([&quot;IMPORT-DRAWING&quot;])),gLa=(new A).e(&quot;etc._importdrawing&quot;,fLa),hLa=I(r(),(new w).f([&quot;IMPORT-PCOLORS&quot;])),iLa=(new A).e(&quot;etc._importpatchcolors&quot;,
hLa),jLa=I(r(),(new w).f([&quot;IMPORT-PCOLORS-RGB&quot;])),kLa=(new A).e(&quot;etc._importpcolorsrgb&quot;,jLa),lLa=I(r(),(new w).f([&quot;IMPORT-WORLD&quot;])),mLa=(new A).e(&quot;etc._importworld&quot;,lLa),nLa=I(r(),(new w).f([&quot;INSPECT&quot;])),oLa=(new A).e(&quot;etc._inspect&quot;,nLa),pLa=I(r(),(new w).f([&quot;JUMP&quot;])),qLa=(new A).e(&quot;_jump&quot;,pLa),rLa=I(r(),(new w).f([&quot;LAYOUT-CIRCLE&quot;])),sLa=(new A).e(&quot;etc._layoutcircle&quot;,rLa),tLa=I(r(),(new w).f([&quot;LAYOUT-RADIAL&quot;])),uLa=(new A).e(&quot;etc._layoutradial&quot;,tLa),vLa=I(r(),(new w).f([&quot;LAYOUT-SPRING&quot;])),wLa=(new A).e(&quot;etc._layoutspring&quot;,
vLa),xLa=I(r(),(new w).f([&quot;LAYOUT-TUTTE&quot;])),yLa=(new A).e(&quot;etc._layouttutte&quot;,xLa),zLa=I(r(),(new w).f([&quot;LEFT&quot;,&quot;LT&quot;])),ALa=(new A).e(&quot;etc._left&quot;,zLa),BLa=I(r(),(new w).f([&quot;__LET&quot;,&quot;LET&quot;])),CLa=(new A).e(&quot;_let&quot;,BLa),DLa=I(r(),(new w).f([&quot;LOOP&quot;])),ELa=(new A).e(&quot;etc._loop&quot;,DLa),FLa=I(r(),(new w).f([&quot;LEFT&quot;,&quot;LT&quot;])),GLa=(new A).e(&quot;etc._left&quot;,FLa),HLa=I(r(),(new w).f([&quot;MOVE-TO&quot;])),ILa=(new A).e(&quot;etc._moveto&quot;,HLa),JLa=I(r(),(new w).f([&quot;NO-DISPLAY&quot;])),KLa=(new A).e(&quot;etc._nodisplay&quot;,JLa),LLa=I(r(),(new w).f([&quot;OUTPUT-PRINT&quot;])),
MLa=(new A).e(&quot;etc._outputprint&quot;,LLa),NLa=I(r(),(new w).f([&quot;OUTPUT-SHOW&quot;])),OLa=(new A).e(&quot;etc._outputshow&quot;,NLa),PLa=I(r(),(new w).f([&quot;OUTPUT-TYPE&quot;])),QLa=(new A).e(&quot;etc._outputtype&quot;,PLa),RLa=I(r(),(new w).f([&quot;OUTPUT-WRITE&quot;])),SLa=(new A).e(&quot;etc._outputwrite&quot;,RLa),TLa=I(r(),(new w).f([&quot;PD&quot;,&quot;PEN-DOWN&quot;,&quot;PENDOWN&quot;])),ULa=(new A).e(&quot;etc._pendown&quot;,TLa),VLa=I(r(),(new w).f([&quot;PE&quot;,&quot;PEN-ERASE&quot;])),WLa=(new A).e(&quot;etc._penerase&quot;,VLa),XLa=I(r(),(new w).f([&quot;PD&quot;,&quot;PEN-DOWN&quot;,&quot;PENDOWN&quot;])),YLa=(new A).e(&quot;etc._pendown&quot;,
XLa),ZLa=I(r(),(new w).f([&quot;PE&quot;,&quot;PEN-ERASE&quot;])),$La=(new A).e(&quot;etc._penerase&quot;,ZLa),aMa=I(r(),(new w).f([&quot;PEN-UP&quot;,&quot;PENUP&quot;,&quot;PU&quot;])),bMa=(new A).e(&quot;etc._penup&quot;,aMa),cMa=I(r(),(new w).f([&quot;PD&quot;,&quot;PEN-DOWN&quot;,&quot;PENDOWN&quot;])),dMa=(new A).e(&quot;etc._pendown&quot;,cMa),eMa=I(r(),(new w).f([&quot;PEN-UP&quot;,&quot;PENUP&quot;,&quot;PU&quot;])),fMa=(new A).e(&quot;etc._penup&quot;,eMa),gMa=I(r(),(new w).f([&quot;PLOT&quot;])),hMa=(new A).e(&quot;etc._plot&quot;,gMa),iMa=I(r(),(new w).f([&quot;PLOT-PEN-DOWN&quot;])),jMa=(new A).e(&quot;etc._plotpendown&quot;,iMa),kMa=I(r(),(new w).f([&quot;PLOT-PEN-RESET&quot;])),
lMa=(new A).e(&quot;etc._plotpenreset&quot;,kMa),mMa=I(r(),(new w).f([&quot;PLOT-PEN-UP&quot;])),nMa=(new A).e(&quot;etc._plotpenup&quot;,mMa),oMa=I(r(),(new w).f([&quot;PLOTXY&quot;])),pMa=(new A).e(&quot;etc._plotxy&quot;,oMa),qMa=I(r(),(new w).f([&quot;PRINT&quot;])),rMa=(new A).e(&quot;etc._print&quot;,qMa),sMa=I(r(),(new w).f([&quot;PEN-UP&quot;,&quot;PENUP&quot;,&quot;PU&quot;])),tMa=(new A).e(&quot;etc._penup&quot;,sMa),uMa=I(r(),(new w).f([&quot;RANDOM-SEED&quot;])),vMa=(new A).e(&quot;etc._randomseed&quot;,uMa),wMa=I(r(),(new w).f([&quot;REPEAT&quot;])),xMa=(new A).e(&quot;_repeat&quot;,wMa),yMa=I(r(),(new w).f([&quot;REPORT&quot;])),zMa=(new A).e(&quot;_report&quot;,
yMa),AMa=I(r(),(new w).f([&quot;RESET-PERSPECTIVE&quot;,&quot;RP&quot;])),BMa=(new A).e(&quot;etc._resetperspective&quot;,AMa),CMa=I(r(),(new w).f([&quot;RESET-TICKS&quot;])),DMa=(new A).e(&quot;etc._resetticks&quot;,CMa),EMa=I(r(),(new w).f([&quot;RESET-TIMER&quot;])),FMa=(new A).e(&quot;etc._resettimer&quot;,EMa),GMa=I(r(),(new w).f([&quot;RESIZE-WORLD&quot;])),HMa=(new A).e(&quot;etc._resizeworld&quot;,GMa),IMa=I(r(),(new w).f([&quot;RIDE&quot;])),JMa=(new A).e(&quot;etc._ride&quot;,IMa),KMa=I(r(),(new w).f([&quot;RIDE-ME&quot;])),LMa=(new A).e(&quot;etc._rideme&quot;,KMa),MMa=I(r(),(new w).f([&quot;RIGHT&quot;,&quot;RT&quot;])),NMa=(new A).e(&quot;etc._right&quot;,
MMa),OMa=I(r(),(new w).f([&quot;RESET-PERSPECTIVE&quot;,&quot;RP&quot;])),PMa=(new A).e(&quot;etc._resetperspective&quot;,OMa),QMa=I(r(),(new w).f([&quot;RIGHT&quot;,&quot;RT&quot;])),RMa=(new A).e(&quot;etc._right&quot;,QMa),SMa=I(r(),(new w).f([&quot;RUN&quot;])),TMa=(new A).e(&quot;_run&quot;,SMa),UMa=I(r(),(new w).f([&quot;SET&quot;])),VMa=(new A).e(&quot;_set&quot;,UMa),WMa=I(r(),(new w).f([&quot;SET-CURRENT-DIRECTORY&quot;])),XMa=(new A).e(&quot;etc._setcurdir&quot;,WMa),YMa=I(r(),(new w).f([&quot;SET-CURRENT-PLOT&quot;])),ZMa=(new A).e(&quot;etc._setcurrentplot&quot;,YMa),$Ma=I(r(),(new w).f([&quot;SET-CURRENT-PLOT-PEN&quot;])),aNa=(new A).e(&quot;etc._setcurrentplotpen&quot;,
$Ma),bNa=I(r(),(new w).f([&quot;SET-DEFAULT-SHAPE&quot;])),cNa=(new A).e(&quot;etc._setdefaultshape&quot;,bNa),dNa=I(r(),(new w).f([&quot;SET-HISTOGRAM-NUM-BARS&quot;])),eNa=(new A).e(&quot;etc._sethistogramnumbars&quot;,dNa),fNa=I(r(),(new w).f([&quot;SET-PATCH-SIZE&quot;])),gNa=(new A).e(&quot;etc._setpatchsize&quot;,fNa),hNa=I(r(),(new w).f([&quot;SET-PLOT-PEN-COLOR&quot;])),iNa=(new A).e(&quot;etc._setplotpencolor&quot;,hNa),jNa=I(r(),(new w).f([&quot;SET-PLOT-PEN-INTERVAL&quot;])),kNa=(new A).e(&quot;etc._setplotpeninterval&quot;,jNa),lNa=I(r(),(new w).f([&quot;SET-PLOT-PEN-MODE&quot;])),mNa=(new A).e(&quot;etc._setplotpenmode&quot;,
lNa),nNa=I(r(),(new w).f([&quot;SET-PLOT-X-RANGE&quot;])),oNa=(new A).e(&quot;etc._setplotxrange&quot;,nNa),pNa=I(r(),(new w).f([&quot;SET-PLOT-Y-RANGE&quot;])),qNa=(new A).e(&quot;etc._setplotyrange&quot;,pNa),rNa=I(r(),(new w).f([&quot;SETUP-PLOTS&quot;])),sNa=(new A).e(&quot;etc._setupplots&quot;,rNa),tNa=I(r(),(new w).f([&quot;SETXY&quot;])),uNa=(new A).e(&quot;etc._setxy&quot;,tNa),vNa=I(r(),(new w).f([&quot;SHOW&quot;])),wNa=(new A).e(&quot;etc._show&quot;,vNa),xNa=I(r(),(new w).f([&quot;SHOW-LINK&quot;])),yNa=(new A).e(&quot;etc._showlink&quot;,xNa),zNa=I(r(),(new w).f([&quot;SHOW-TURTLE&quot;,&quot;ST&quot;])),ANa=(new A).e(&quot;etc._showturtle&quot;,
zNa),BNa=I(r(),(new w).f([&quot;SPROUT&quot;])),CNa=(new A).e(&quot;_sprout&quot;,BNa),DNa=I(r(),(new w).f([&quot;SHOW-TURTLE&quot;,&quot;ST&quot;])),ENa=(new A).e(&quot;etc._showturtle&quot;,DNa),FNa=I(r(),(new w).f([&quot;STAMP&quot;])),GNa=(new A).e(&quot;etc._stamp&quot;,FNa),HNa=I(r(),(new w).f([&quot;STAMP-ERASE&quot;])),INa=(new A).e(&quot;etc._stamperase&quot;,HNa),JNa=I(r(),(new w).f([&quot;STOP&quot;])),KNa=(new A).e(&quot;_stop&quot;,JNa),LNa=I(r(),(new w).f([&quot;STOP-INSPECTING&quot;])),MNa=(new A).e(&quot;etc._stopinspecting&quot;,LNa),NNa=I(r(),(new w).f([&quot;STOP-INSPECTING-DEAD-AGENTS&quot;])),ONa=(new A).e(&quot;etc._stopinspectingdeadagents&quot;,
NNa),PNa=I(r(),(new w).f([&quot;TICK&quot;])),QNa=(new A).e(&quot;etc._tick&quot;,PNa),RNa=I(r(),(new w).f([&quot;TICK-ADVANCE&quot;])),SNa=(new A).e(&quot;etc._tickadvance&quot;,RNa),TNa=I(r(),(new w).f([&quot;TIE&quot;])),UNa=(new A).e(&quot;etc._tie&quot;,TNa),VNa=I(r(),(new w).f([&quot;TYPE&quot;])),WNa=(new A).e(&quot;etc._type&quot;,VNa),XNa=I(r(),(new w).f([&quot;UNTIE&quot;])),YNa=(new A).e(&quot;etc._untie&quot;,XNa),ZNa=I(r(),(new w).f([&quot;UPDATE-PLOTS&quot;])),$Na=(new A).e(&quot;etc._updateplots&quot;,ZNa),aOa=I(r(),(new w).f([&quot;UPHILL&quot;])),bOa=(new A).e(&quot;etc._uphill&quot;,aOa),cOa=I(r(),(new w).f([&quot;UPHILL4&quot;])),
dOa=(new A).e(&quot;etc._uphill4&quot;,cOa),eOa=I(r(),(new w).f([&quot;USER-MESSAGE&quot;])),fOa=(new A).e(&quot;etc._usermessage&quot;,eOa),gOa=I(r(),(new w).f([&quot;WAIT&quot;])),hOa=(new A).e(&quot;etc._wait&quot;,gOa),iOa=I(r(),(new w).f([&quot;WATCH&quot;])),jOa=(new A).e(&quot;etc._watch&quot;,iOa),kOa=I(r(),(new w).f([&quot;WATCH-ME&quot;])),lOa=(new A).e(&quot;etc._watchme&quot;,kOa),mOa=I(r(),(new w).f([&quot;WHILE&quot;])),nOa=(new A).e(&quot;etc._while&quot;,mOa),oOa=I(r(),(new w).f([&quot;WITH-LOCAL-RANDOMNESS&quot;])),pOa=(new A).e(&quot;etc._withlocalrandomness&quot;,oOa),qOa=I(r(),(new w).f([&quot;WITHOUT-INTERRUPTION&quot;])),
rOa=(new A).e(&quot;etc._withoutinterruption&quot;,qOa),sOa=I(r(),(new w).f([&quot;WRITE&quot;])),tOa=(new A).e(&quot;etc._write&quot;,sOa),uOa=I(r(),(new w).f([&quot;!\x3d&quot;])),vOa=(new A).e(&quot;_notequal&quot;,uOa),wOa=I(r(),(new w).f([&quot;*&quot;])),xOa=(new A).e(&quot;etc._mult&quot;,wOa),yOa=I(r(),(new w).f([&quot;+&quot;])),zOa=(new A).e(&quot;etc._plus&quot;,yOa),AOa=I(r(),(new w).f([&quot;-&quot;])),BOa=(new A).e(&quot;_minus&quot;,AOa),COa=I(r(),(new w).f([&quot;/&quot;])),DOa=(new A).e(&quot;etc._div&quot;,COa),EOa=I(r(),(new w).f([&quot;\x3c&quot;])),FOa=(new A).e(&quot;_lessthan&quot;,EOa),GOa=I(r(),(new w).f([&quot;\x3c\x3d&quot;])),
HOa=(new A).e(&quot;etc._lessorequal&quot;,GOa),IOa=I(r(),(new w).f([&quot;\x3d&quot;])),JOa=(new A).e(&quot;_equal&quot;,IOa),KOa=I(r(),(new w).f([&quot;\x3e&quot;])),LOa=(new A).e(&quot;_greaterthan&quot;,KOa),MOa=I(r(),(new w).f([&quot;\x3e\x3d&quot;])),NOa=(new A).e(&quot;etc._greaterorequal&quot;,MOa),OOa=I(r(),(new w).f([&quot;^&quot;])),POa=(new A).e(&quot;etc._pow&quot;,OOa),QOa=I(r(),(new w).f([&quot;__APPLY-RESULT&quot;])),ROa=(new A).e(&quot;etc._applyresult&quot;,QOa),SOa=I(r(),(new w).f([&quot;__BOOM&quot;])),TOa=(new A).e(&quot;etc._boom&quot;,SOa),UOa=I(r(),(new w).f([&quot;__BLOCK&quot;])),VOa=(new A).e(&quot;etc._block&quot;,UOa),
WOa=I(r(),(new w).f([&quot;__CHECK-SYNTAX&quot;])),XOa=(new A).e(&quot;etc._checksyntax&quot;,WOa),YOa=I(r(),(new w).f([&quot;__CHECKSUM&quot;])),ZOa=(new A).e(&quot;etc._checksum&quot;,YOa),$Oa=I(r(),(new w).f([&quot;__DUMP&quot;])),aPa=(new A).e(&quot;etc._dump&quot;,$Oa),bPa=I(r(),(new w).f([&quot;__DUMP-EXTENSION-PRIMS&quot;])),cPa=(new A).e(&quot;etc._dumpextensionprims&quot;,bPa),dPa=I(r(),(new w).f([&quot;__DUMP-EXTENSIONS&quot;])),ePa=(new A).e(&quot;etc._dumpextensions&quot;,dPa),fPa=I(r(),(new w).f([&quot;__DUMP1&quot;])),gPa=(new A).e(&quot;etc._dump1&quot;,fPa),hPa=I(r(),(new w).f([&quot;__NANO-TIME&quot;])),iPa=
(new A).e(&quot;etc._nanotime&quot;,hPa),jPa=I(r(),(new w).f([&quot;__PROCESSORS&quot;])),kPa=(new A).e(&quot;etc._processors&quot;,jPa),lPa=I(r(),(new w).f([&quot;__RANDOM-STATE&quot;])),mPa=(new A).e(&quot;etc._randomstate&quot;,lPa),nPa=I(r(),(new w).f([&quot;__REFERENCE&quot;])),oPa=(new A).e(&quot;etc._reference&quot;,nPa),pPa=I(r(),(new w).f([&quot;__STACK-TRACE&quot;])),qPa=(new A).e(&quot;etc._stacktrace&quot;,pPa),rPa=I(r(),(new w).f([&quot;__SYMBOL&quot;])),sPa=(new A).e(&quot;etc._symbolstring&quot;,rPa),tPa=I(r(),(new w).f([&quot;__TO-STRING&quot;])),uPa=(new A).e(&quot;etc._tostring&quot;,tPa),vPa=I(r(),(new w).f([&quot;ABS&quot;])),
wPa=(new A).e(&quot;etc._abs&quot;,vPa),xPa=I(r(),(new w).f([&quot;ACOS&quot;])),yPa=(new A).e(&quot;etc._acos&quot;,xPa),zPa=I(r(),(new w).f([&quot;ALL?&quot;])),APa=(new A).e(&quot;etc._all&quot;,zPa),BPa=I(r(),(new w).f([&quot;AND&quot;])),CPa=(new A).e(&quot;_and&quot;,BPa),DPa=I(r(),(new w).f([&quot;ANY?&quot;])),EPa=(new A).e(&quot;_any&quot;,DPa),FPa=I(r(),(new w).f([&quot;APPROXIMATE-HSB&quot;])),GPa=(new A).e(&quot;etc._approximatehsb&quot;,FPa),HPa=I(r(),(new w).f([&quot;APPROXIMATE-RGB&quot;])),IPa=(new A).e(&quot;etc._approximatergb&quot;,HPa),JPa=I(r(),(new w).f([&quot;ASIN&quot;])),KPa=(new A).e(&quot;etc._asin&quot;,JPa),LPa=I(r(),
(new w).f([&quot;AT-POINTS&quot;])),MPa=(new A).e(&quot;etc._atpoints&quot;,LPa),NPa=I(r(),(new w).f([&quot;ATAN&quot;])),OPa=(new A).e(&quot;etc._atan&quot;,NPa),PPa=I(r(),(new w).f([&quot;AUTOPLOT?&quot;])),QPa=(new A).e(&quot;etc._autoplot&quot;,PPa),RPa=I(r(),(new w).f([&quot;BASE-COLORS&quot;])),SPa=(new A).e(&quot;etc._basecolors&quot;,RPa),TPa=I(r(),(new w).f([&quot;BEHAVIORSPACE-RUN-NUMBER&quot;])),UPa=(new A).e(&quot;etc._behaviorspacerunnumber&quot;,TPa),VPa=I(r(),(new w).f([&quot;BF&quot;,&quot;BUT-FIRST&quot;,&quot;BUTFIRST&quot;])),WPa=(new A).e(&quot;etc._butfirst&quot;,VPa),XPa=I(r(),(new w).f([&quot;BL&quot;,&quot;BUT-LAST&quot;,&quot;BUTLAST&quot;])),
YPa=(new A).e(&quot;etc._butlast&quot;,XPa),ZPa=I(r(),(new w).f([&quot;BOTH-ENDS&quot;])),$Pa=(new A).e(&quot;etc._bothends&quot;,ZPa),aQa=I(r(),(new w).f([&quot;BF&quot;,&quot;BUT-FIRST&quot;,&quot;BUTFIRST&quot;])),bQa=(new A).e(&quot;etc._butfirst&quot;,aQa),cQa=I(r(),(new w).f([&quot;BL&quot;,&quot;BUT-LAST&quot;,&quot;BUTLAST&quot;])),dQa=(new A).e(&quot;etc._butlast&quot;,cQa),eQa=I(r(),(new w).f([&quot;BF&quot;,&quot;BUT-FIRST&quot;,&quot;BUTFIRST&quot;])),fQa=(new A).e(&quot;etc._butfirst&quot;,eQa),gQa=I(r(),(new w).f([&quot;BL&quot;,&quot;BUT-LAST&quot;,&quot;BUTLAST&quot;])),hQa=(new A).e(&quot;etc._butlast&quot;,gQa),iQa=I(r(),(new w).f([&quot;CAN-MOVE?&quot;])),jQa=(new A).e(&quot;etc._canmove&quot;,
iQa),kQa=I(r(),(new w).f([&quot;CEILING&quot;])),lQa=(new A).e(&quot;etc._ceil&quot;,kQa),mQa=I(r(),(new w).f([&quot;COS&quot;])),nQa=(new A).e(&quot;etc._cos&quot;,mQa),oQa=I(r(),(new w).f([&quot;COUNT&quot;])),pQa=(new A).e(&quot;_count&quot;,oQa),qQa=I(r(),(new w).f([&quot;DATE-AND-TIME&quot;])),rQa=(new A).e(&quot;etc._dateandtime&quot;,qQa),sQa=I(r(),(new w).f([&quot;DISTANCE&quot;])),tQa=(new A).e(&quot;etc._distance&quot;,sQa),uQa=I(r(),(new w).f([&quot;DISTANCEXY&quot;])),vQa=(new A).e(&quot;etc._distancexy&quot;,uQa),wQa=I(r(),(new w).f([&quot;DX&quot;])),xQa=(new A).e(&quot;etc._dx&quot;,wQa),yQa=I(r(),(new w).f([&quot;DY&quot;])),zQa=
(new A).e(&quot;etc._dy&quot;,yQa),AQa=I(r(),(new w).f([&quot;EMPTY?&quot;])),BQa=(new A).e(&quot;etc._empty&quot;,AQa),CQa=I(r(),(new w).f([&quot;ERROR-MESSAGE&quot;])),DQa=(new A).e(&quot;_errormessage&quot;,CQa),EQa=I(r(),(new w).f([&quot;EXP&quot;])),FQa=(new A).e(&quot;etc._exp&quot;,EQa),GQa=I(r(),(new w).f([&quot;EXTRACT-HSB&quot;])),HQa=(new A).e(&quot;etc._extracthsb&quot;,GQa),IQa=I(r(),(new w).f([&quot;EXTRACT-RGB&quot;])),JQa=(new A).e(&quot;etc._extractrgb&quot;,IQa),KQa=I(r(),(new w).f([&quot;FILE-AT-END?&quot;])),LQa=(new A).e(&quot;etc._fileatend&quot;,KQa),MQa=I(r(),(new w).f([&quot;FILE-EXISTS?&quot;])),NQa=(new A).e(&quot;etc._fileexists&quot;,
MQa),OQa=I(r(),(new w).f([&quot;FILE-READ&quot;])),PQa=(new A).e(&quot;etc._fileread&quot;,OQa),QQa=I(r(),(new w).f([&quot;FILE-READ-CHARACTERS&quot;])),RQa=(new A).e(&quot;etc._filereadchars&quot;,QQa),SQa=I(r(),(new w).f([&quot;FILE-READ-LINE&quot;])),TQa=(new A).e(&quot;etc._filereadline&quot;,SQa),UQa=I(r(),(new w).f([&quot;FILTER&quot;])),VQa=(new A).e(&quot;etc._filter&quot;,UQa),WQa=I(r(),(new w).f([&quot;FIRST&quot;])),XQa=(new A).e(&quot;etc._first&quot;,WQa),YQa=I(r(),(new w).f([&quot;FLOOR&quot;])),ZQa=(new A).e(&quot;etc._floor&quot;,YQa),$Qa=I(r(),(new w).f([&quot;FPUT&quot;])),aRa=(new A).e(&quot;etc._fput&quot;,$Qa),bRa=
I(r(),(new w).f([&quot;HSB&quot;])),cRa=(new A).e(&quot;etc._hsb&quot;,bRa),dRa=I(r(),(new w).f([&quot;HUBNET-CLIENTS-LIST&quot;])),eRa=(new A).e(&quot;hubnet._hubnetclientslist&quot;,dRa),fRa=I(r(),(new w).f([&quot;HUBNET-ENTER-MESSAGE?&quot;])),gRa=(new A).e(&quot;hubnet._hubnetentermessage&quot;,fRa),hRa=I(r(),(new w).f([&quot;HUBNET-EXIT-MESSAGE?&quot;])),iRa=(new A).e(&quot;hubnet._hubnetexitmessage&quot;,hRa),jRa=I(r(),(new w).f([&quot;HUBNET-MESSAGE&quot;])),kRa=(new A).e(&quot;hubnet._hubnetmessage&quot;,jRa),lRa=I(r(),(new w).f([&quot;HUBNET-MESSAGE-SOURCE&quot;])),mRa=(new A).e(&quot;hubnet._hubnetmessagesource&quot;,
lRa),nRa=I(r(),(new w).f([&quot;HUBNET-MESSAGE-TAG&quot;])),oRa=(new A).e(&quot;hubnet._hubnetmessagetag&quot;,nRa),pRa=I(r(),(new w).f([&quot;HUBNET-MESSAGE-WAITING?&quot;])),qRa=(new A).e(&quot;hubnet._hubnetmessagewaiting&quot;,pRa),rRa=I(r(),(new w).f([&quot;IFELSE-VALUE&quot;])),sRa=(new A).e(&quot;etc._ifelsevalue&quot;,rRa),tRa=I(r(),(new w).f([&quot;IN-CONE&quot;])),uRa=(new A).e(&quot;etc._incone&quot;,tRa),vRa=I(r(),(new w).f([&quot;IN-LINK-FROM&quot;])),wRa=(new A).e(&quot;etc._inlinkfrom&quot;,vRa),xRa=I(r(),(new w).f([&quot;IN-LINK-NEIGHBOR?&quot;])),yRa=(new A).e(&quot;etc._inlinkneighbor&quot;,xRa),
zRa=I(r(),(new w).f([&quot;IN-LINK-NEIGHBORS&quot;])),ARa=(new A).e(&quot;etc._inlinkneighbors&quot;,zRa),BRa=I(r(),(new w).f([&quot;IN-RADIUS&quot;])),CRa=(new A).e(&quot;_inradius&quot;,BRa),DRa=I(r(),(new w).f([&quot;INSERT-ITEM&quot;])),ERa=(new A).e(&quot;etc._insertitem&quot;,DRa),FRa=I(r(),(new w).f([&quot;INT&quot;])),GRa=(new A).e(&quot;etc._int&quot;,FRa),HRa=I(r(),(new w).f([&quot;IS-AGENT?&quot;])),IRa=(new A).e(&quot;etc._isagent&quot;,HRa),JRa=I(r(),(new w).f([&quot;IS-AGENTSET?&quot;])),KRa=(new A).e(&quot;etc._isagentset&quot;,JRa),LRa=I(r(),(new w).f([&quot;IS-ANONYMOUS-COMMAND?&quot;])),MRa=(new A).e(&quot;etc._isanonymouscommand&quot;,
LRa),NRa=I(r(),(new w).f([&quot;IS-ANONYMOUS-REPORTER?&quot;])),ORa=(new A).e(&quot;etc._isanonymousreporter&quot;,NRa),PRa=I(r(),(new w).f([&quot;IS-BOOLEAN?&quot;])),QRa=(new A).e(&quot;etc._isboolean&quot;,PRa),RRa=I(r(),(new w).f([&quot;IS-DIRECTED-LINK?&quot;])),SRa=(new A).e(&quot;etc._isdirectedlink&quot;,RRa),TRa=I(r(),(new w).f([&quot;IS-LINK-SET?&quot;])),URa=(new A).e(&quot;etc._islinkset&quot;,TRa),VRa=I(r(),(new w).f([&quot;IS-LINK?&quot;])),WRa=(new A).e(&quot;etc._islink&quot;,VRa),XRa=I(r(),(new w).f([&quot;IS-LIST?&quot;])),YRa=(new A).e(&quot;etc._islist&quot;,XRa),ZRa=I(r(),(new w).f([&quot;IS-NUMBER?&quot;])),
$Ra=(new A).e(&quot;etc._isnumber&quot;,ZRa),aSa=I(r(),(new w).f([&quot;IS-PATCH-SET?&quot;])),bSa=(new A).e(&quot;etc._ispatchset&quot;,aSa),cSa=I(r(),(new w).f([&quot;IS-PATCH?&quot;])),dSa=(new A).e(&quot;etc._ispatch&quot;,cSa),eSa=I(r(),(new w).f([&quot;IS-STRING?&quot;])),fSa=(new A).e(&quot;etc._isstring&quot;,eSa),gSa=I(r(),(new w).f([&quot;IS-TURTLE-SET?&quot;])),hSa=(new A).e(&quot;etc._isturtleset&quot;,gSa),iSa=I(r(),(new w).f([&quot;IS-TURTLE?&quot;])),jSa=(new A).e(&quot;etc._isturtle&quot;,iSa),kSa=I(r(),(new w).f([&quot;IS-UNDIRECTED-LINK?&quot;])),lSa=(new A).e(&quot;etc._isundirectedlink&quot;,kSa),mSa=I(r(),
(new w).f([&quot;ITEM&quot;])),nSa=(new A).e(&quot;etc._item&quot;,mSa),oSa=I(r(),(new w).f([&quot;LAST&quot;])),pSa=(new A).e(&quot;etc._last&quot;,oSa),qSa=I(r(),(new w).f([&quot;LENGTH&quot;])),rSa=(new A).e(&quot;etc._length&quot;,qSa),sSa=I(r(),(new w).f([&quot;LINK&quot;])),tSa=(new A).e(&quot;etc._link&quot;,sSa),uSa=I(r(),(new w).f([&quot;LINK-HEADING&quot;])),vSa=(new A).e(&quot;etc._linkheading&quot;,uSa),wSa=I(r(),(new w).f([&quot;LINK-LENGTH&quot;])),xSa=(new A).e(&quot;etc._linklength&quot;,wSa),ySa=I(r(),(new w).f([&quot;LINK-NEIGHBOR?&quot;])),zSa=(new A).e(&quot;etc._linkneighbor&quot;,ySa),ASa=I(r(),(new w).f([&quot;LINK-NEIGHBORS&quot;])),
BSa=(new A).e(&quot;etc._linkneighbors&quot;,ASa),CSa=I(r(),(new w).f([&quot;LINK-SET&quot;])),DSa=(new A).e(&quot;etc._linkset&quot;,CSa),ESa=I(r(),(new w).f([&quot;LINK-SHAPES&quot;])),FSa=(new A).e(&quot;etc._linkshapes&quot;,ESa),GSa=I(r(),(new w).f([&quot;LINK-WITH&quot;])),HSa=(new A).e(&quot;etc._linkwith&quot;,GSa),ISa=I(r(),(new w).f([&quot;LINKS&quot;])),JSa=(new A).e(&quot;etc._links&quot;,ISa),KSa=I(r(),(new w).f([&quot;LIST&quot;])),LSa=(new A).e(&quot;_list&quot;,KSa),MSa=I(r(),(new w).f([&quot;LN&quot;])),NSa=(new A).e(&quot;etc._ln&quot;,MSa),OSa=I(r(),(new w).f([&quot;LOG&quot;])),PSa=(new A).e(&quot;etc._log&quot;,OSa),QSa=I(r(),
(new w).f([&quot;LPUT&quot;])),RSa=(new A).e(&quot;etc._lput&quot;,QSa),SSa=I(r(),(new w).f([&quot;MAP&quot;])),TSa=(new A).e(&quot;etc._map&quot;,SSa),USa=I(r(),(new w).f([&quot;MAX&quot;])),VSa=(new A).e(&quot;etc._max&quot;,USa),WSa=I(r(),(new w).f([&quot;MAX-N-OF&quot;])),XSa=(new A).e(&quot;etc._maxnof&quot;,WSa),YSa=I(r(),(new w).f([&quot;MAX-ONE-OF&quot;])),ZSa=(new A).e(&quot;etc._maxoneof&quot;,YSa),$Sa=I(r(),(new w).f([&quot;MAX-PXCOR&quot;])),aTa=(new A).e(&quot;etc._maxpxcor&quot;,$Sa),bTa=I(r(),(new w).f([&quot;MAX-PYCOR&quot;])),cTa=(new A).e(&quot;etc._maxpycor&quot;,bTa),dTa=I(r(),(new w).f([&quot;MEAN&quot;])),eTa=(new A).e(&quot;etc._mean&quot;,
dTa),fTa=I(r(),(new w).f([&quot;MEDIAN&quot;])),gTa=(new A).e(&quot;etc._median&quot;,fTa),hTa=I(r(),(new w).f([&quot;MEMBER?&quot;])),iTa=(new A).e(&quot;etc._member&quot;,hTa),jTa=I(r(),(new w).f([&quot;MIN&quot;])),kTa=(new A).e(&quot;etc._min&quot;,jTa),lTa=I(r(),(new w).f([&quot;MIN-N-OF&quot;])),mTa=(new A).e(&quot;etc._minnof&quot;,lTa),nTa=I(r(),(new w).f([&quot;MIN-ONE-OF&quot;])),oTa=(new A).e(&quot;etc._minoneof&quot;,nTa),pTa=I(r(),(new w).f([&quot;MIN-PXCOR&quot;])),qTa=(new A).e(&quot;etc._minpxcor&quot;,pTa),rTa=I(r(),(new w).f([&quot;MIN-PYCOR&quot;])),sTa=(new A).e(&quot;etc._minpycor&quot;,rTa),tTa=I(r(),(new w).f([&quot;MOD&quot;])),
uTa=(new A).e(&quot;etc._mod&quot;,tTa),vTa=I(r(),(new w).f([&quot;MODES&quot;])),wTa=(new A).e(&quot;etc._modes&quot;,vTa),xTa=I(r(),(new w).f([&quot;MOUSE-DOWN?&quot;])),yTa=(new A).e(&quot;etc._mousedown&quot;,xTa),zTa=I(r(),(new w).f([&quot;MOUSE-INSIDE?&quot;])),ATa=(new A).e(&quot;etc._mouseinside&quot;,zTa),BTa=I(r(),(new w).f([&quot;MOUSE-XCOR&quot;])),CTa=(new A).e(&quot;etc._mousexcor&quot;,BTa),DTa=I(r(),(new w).f([&quot;MOUSE-YCOR&quot;])),ETa=(new A).e(&quot;etc._mouseycor&quot;,DTa),FTa=I(r(),(new w).f([&quot;MY-IN-LINKS&quot;])),GTa=(new A).e(&quot;etc._myinlinks&quot;,FTa),HTa=I(r(),(new w).f([&quot;MY-LINKS&quot;])),
ITa=(new A).e(&quot;etc._mylinks&quot;,HTa),JTa=I(r(),(new w).f([&quot;MY-OUT-LINKS&quot;])),KTa=(new A).e(&quot;etc._myoutlinks&quot;,JTa),LTa=I(r(),(new w).f([&quot;MYSELF&quot;])),MTa=(new A).e(&quot;etc._myself&quot;,LTa),NTa=I(r(),(new w).f([&quot;N-OF&quot;])),OTa=(new A).e(&quot;etc._nof&quot;,NTa),PTa=I(r(),(new w).f([&quot;N-VALUES&quot;])),QTa=(new A).e(&quot;etc._nvalues&quot;,PTa),RTa=I(r(),(new w).f([&quot;NEIGHBORS&quot;])),STa=(new A).e(&quot;_neighbors&quot;,RTa),TTa=I(r(),(new w).f([&quot;NEIGHBORS4&quot;])),UTa=(new A).e(&quot;_neighbors4&quot;,TTa),VTa=I(r(),(new w).f([&quot;NETLOGO-APPLET?&quot;])),WTa=(new A).e(&quot;etc._netlogoapplet&quot;,
VTa),XTa=I(r(),(new w).f([&quot;NETLOGO-VERSION&quot;])),YTa=(new A).e(&quot;etc._netlogoversion&quot;,XTa),ZTa=I(r(),(new w).f([&quot;NETLOGO-WEB?&quot;])),$Ta=(new A).e(&quot;etc._netlogoweb&quot;,ZTa),aUa=I(r(),(new w).f([&quot;NEW-SEED&quot;])),bUa=(new A).e(&quot;etc._newseed&quot;,aUa),cUa=I(r(),(new w).f([&quot;NO-LINKS&quot;])),dUa=(new A).e(&quot;etc._nolinks&quot;,cUa),eUa=I(r(),(new w).f([&quot;NO-PATCHES&quot;])),fUa=(new A).e(&quot;etc._nopatches&quot;,eUa),gUa=I(r(),(new w).f([&quot;NO-TURTLES&quot;])),hUa=(new A).e(&quot;etc._noturtles&quot;,gUa),iUa=I(r(),(new w).f([&quot;NOT&quot;])),jUa=(new A).e(&quot;_not&quot;,iUa),
kUa=I(r(),(new w).f([&quot;OF&quot;])),lUa=(new A).e(&quot;_of&quot;,kUa),mUa=I(r(),(new w).f([&quot;ONE-OF&quot;])),nUa=(new A).e(&quot;_oneof&quot;,mUa),oUa=I(r(),(new w).f([&quot;OR&quot;])),pUa=(new A).e(&quot;_or&quot;,oUa),qUa=I(r(),(new w).f([&quot;OTHER&quot;])),rUa=(new A).e(&quot;_other&quot;,qUa),sUa=I(r(),(new w).f([&quot;OTHER-END&quot;])),tUa=(new A).e(&quot;etc._otherend&quot;,sUa),uUa=I(r(),(new w).f([&quot;OUT-LINK-NEIGHBOR?&quot;])),vUa=(new A).e(&quot;etc._outlinkneighbor&quot;,uUa),wUa=I(r(),(new w).f([&quot;OUT-LINK-NEIGHBORS&quot;])),xUa=(new A).e(&quot;etc._outlinkneighbors&quot;,wUa),yUa=I(r(),(new w).f([&quot;OUT-LINK-TO&quot;])),
zUa=(new A).e(&quot;etc._outlinkto&quot;,yUa),AUa=I(r(),(new w).f([&quot;PATCH&quot;])),BUa=(new A).e(&quot;etc._patch&quot;,AUa),CUa=I(r(),(new w).f([&quot;PATCH-AHEAD&quot;])),DUa=(new A).e(&quot;etc._patchahead&quot;,CUa),EUa=I(r(),(new w).f([&quot;PATCH-AT&quot;])),FUa=(new A).e(&quot;_patchat&quot;,EUa),GUa=I(r(),(new w).f([&quot;PATCH-AT-HEADING-AND-DISTANCE&quot;])),HUa=(new A).e(&quot;etc._patchatheadinganddistance&quot;,GUa),IUa=I(r(),(new w).f([&quot;PATCH-HERE&quot;])),JUa=(new A).e(&quot;etc._patchhere&quot;,IUa),KUa=I(r(),(new w).f([&quot;PATCH-LEFT-AND-AHEAD&quot;])),LUa=(new A).e(&quot;etc._patchleftandahead&quot;,
KUa),MUa=I(r(),(new w).f([&quot;PATCH-RIGHT-AND-AHEAD&quot;])),NUa=(new A).e(&quot;etc._patchrightandahead&quot;,MUa),OUa=I(r(),(new w).f([&quot;PATCH-SET&quot;])),PUa=(new A).e(&quot;etc._patchset&quot;,OUa),QUa=I(r(),(new w).f([&quot;PATCH-SIZE&quot;])),RUa=(new A).e(&quot;etc._patchsize&quot;,QUa),SUa=I(r(),(new w).f([&quot;PATCHES&quot;])),TUa=(new A).e(&quot;_patches&quot;,SUa),UUa=I(r(),(new w).f([&quot;PLOT-NAME&quot;])),VUa=(new A).e(&quot;etc._plotname&quot;,UUa),WUa=I(r(),(new w).f([&quot;PLOT-PEN-EXISTS?&quot;])),XUa=(new A).e(&quot;etc._plotpenexists&quot;,WUa),YUa=I(r(),(new w).f([&quot;PLOT-X-MAX&quot;])),ZUa=
(new A).e(&quot;etc._plotxmax&quot;,YUa),$Ua=I(r(),(new w).f([&quot;PLOT-X-MIN&quot;])),aVa=(new A).e(&quot;etc._plotxmin&quot;,$Ua),bVa=I(r(),(new w).f([&quot;PLOT-Y-MAX&quot;])),cVa=(new A).e(&quot;etc._plotymax&quot;,bVa),dVa=I(r(),(new w).f([&quot;PLOT-Y-MIN&quot;])),eVa=(new A).e(&quot;etc._plotymin&quot;,dVa),fVa=I(r(),(new w).f([&quot;POSITION&quot;])),gVa=(new A).e(&quot;etc._position&quot;,fVa),hVa=I(r(),(new w).f([&quot;PRECISION&quot;])),iVa=(new A).e(&quot;etc._precision&quot;,hVa),jVa=I(r(),(new w).f([&quot;RANDOM&quot;])),kVa=(new A).e(&quot;_random&quot;,jVa),lVa=I(r(),(new w).f([&quot;RANDOM-EXPONENTIAL&quot;])),mVa=(new A).e(&quot;etc._randomexponential&quot;,
lVa),nVa=I(r(),(new w).f([&quot;RANDOM-FLOAT&quot;])),oVa=(new A).e(&quot;etc._randomfloat&quot;,nVa),pVa=I(r(),(new w).f([&quot;RANDOM-GAMMA&quot;])),qVa=(new A).e(&quot;etc._randomgamma&quot;,pVa),rVa=I(r(),(new w).f([&quot;RANDOM-NORMAL&quot;])),sVa=(new A).e(&quot;etc._randomnormal&quot;,rVa),tVa=I(r(),(new w).f([&quot;RANDOM-POISSON&quot;])),uVa=(new A).e(&quot;etc._randompoisson&quot;,tVa),vVa=I(r(),(new w).f([&quot;RANDOM-PXCOR&quot;])),wVa=(new A).e(&quot;etc._randompxcor&quot;,vVa),xVa=I(r(),(new w).f([&quot;RANDOM-PYCOR&quot;])),yVa=(new A).e(&quot;etc._randompycor&quot;,xVa),zVa=I(r(),(new w).f([&quot;RANDOM-XCOR&quot;])),
AVa=(new A).e(&quot;etc._randomxcor&quot;,zVa),BVa=I(r(),(new w).f([&quot;RANDOM-YCOR&quot;])),CVa=(new A).e(&quot;etc._randomycor&quot;,BVa),DVa=I(r(),(new w).f([&quot;RANGE&quot;])),EVa=(new A).e(&quot;etc._range&quot;,DVa),FVa=I(r(),(new w).f([&quot;READ-FROM-STRING&quot;])),GVa=(new A).e(&quot;etc._readfromstring&quot;,FVa),HVa=I(r(),(new w).f([&quot;REDUCE&quot;])),IVa=(new A).e(&quot;etc._reduce&quot;,HVa),JVa=I(r(),(new w).f([&quot;REMAINDER&quot;])),KVa=(new A).e(&quot;etc._remainder&quot;,JVa),LVa=I(r(),(new w).f([&quot;REMOVE&quot;])),MVa=(new A).e(&quot;etc._remove&quot;,LVa),NVa=I(r(),(new w).f([&quot;REMOVE-DUPLICATES&quot;])),
OVa=(new A).e(&quot;etc._removeduplicates&quot;,NVa),PVa=I(r(),(new w).f([&quot;REMOVE-ITEM&quot;])),QVa=(new A).e(&quot;etc._removeitem&quot;,PVa),RVa=I(r(),(new w).f([&quot;REPLACE-ITEM&quot;])),SVa=(new A).e(&quot;etc._replaceitem&quot;,RVa),TVa=I(r(),(new w).f([&quot;REVERSE&quot;])),UVa=(new A).e(&quot;etc._reverse&quot;,TVa),VVa=I(r(),(new w).f([&quot;RGB&quot;])),WVa=(new A).e(&quot;etc._rgb&quot;,VVa),XVa=I(r(),(new w).f([&quot;ROUND&quot;])),YVa=(new A).e(&quot;etc._round&quot;,XVa),ZVa=I(r(),(new w).f([&quot;RUN-RESULT&quot;,&quot;RUNRESULT&quot;])),$Va=(new A).e(&quot;etc._runresult&quot;,ZVa),aWa=I(r(),(new w).f([&quot;RUN-RESULT&quot;,
&quot;RUNRESULT&quot;])),bWa=(new A).e(&quot;etc._runresult&quot;,aWa),cWa=I(r(),(new w).f([&quot;SCALE-COLOR&quot;])),dWa=(new A).e(&quot;etc._scalecolor&quot;,cWa),eWa=I(r(),(new w).f([&quot;SE&quot;,&quot;SENTENCE&quot;])),fWa=(new A).e(&quot;_sentence&quot;,eWa),gWa=I(r(),(new w).f([&quot;SELF&quot;])),hWa=(new A).e(&quot;etc._self&quot;,gWa),iWa=I(r(),(new w).f([&quot;SE&quot;,&quot;SENTENCE&quot;])),jWa=(new A).e(&quot;_sentence&quot;,iWa),kWa=I(r(),(new w).f([&quot;SHADE-OF?&quot;])),lWa=(new A).e(&quot;etc._shadeof&quot;,kWa),mWa=I(r(),(new w).f([&quot;SHAPES&quot;])),nWa=(new A).e(&quot;etc._shapes&quot;,mWa),oWa=I(r(),(new w).f([&quot;SHUFFLE&quot;])),pWa=
(new A).e(&quot;etc._shuffle&quot;,oWa),qWa=I(r(),(new w).f([&quot;SIN&quot;])),rWa=(new A).e(&quot;etc._sin&quot;,qWa),sWa=I(r(),(new w).f([&quot;SORT&quot;])),tWa=(new A).e(&quot;etc._sort&quot;,sWa),uWa=I(r(),(new w).f([&quot;SORT-BY&quot;])),vWa=(new A).e(&quot;etc._sortby&quot;,uWa),wWa=I(r(),(new w).f([&quot;SORT-ON&quot;])),xWa=(new A).e(&quot;etc._sorton&quot;,wWa),yWa=I(r(),(new w).f([&quot;SQRT&quot;])),zWa=(new A).e(&quot;etc._sqrt&quot;,yWa),AWa=I(r(),(new w).f([&quot;STANDARD-DEVIATION&quot;])),BWa=(new A).e(&quot;etc._standarddeviation&quot;,AWa),CWa=I(r(),(new w).f([&quot;SUBJECT&quot;])),DWa=(new A).e(&quot;etc._subject&quot;,CWa),
EWa=I(r(),(new w).f([&quot;SUBLIST&quot;])),FWa=(new A).e(&quot;etc._sublist&quot;,EWa),GWa=I(r(),(new w).f([&quot;SUBSTRING&quot;])),HWa=(new A).e(&quot;etc._substring&quot;,GWa),IWa=I(r(),(new w).f([&quot;SUBTRACT-HEADINGS&quot;])),JWa=(new A).e(&quot;etc._subtractheadings&quot;,IWa),KWa=I(r(),(new w).f([&quot;SUM&quot;])),LWa=(new A).e(&quot;_sum&quot;,KWa),MWa=I(r(),(new w).f([&quot;TAN&quot;])),NWa=(new A).e(&quot;etc._tan&quot;,MWa),OWa=I(r(),(new w).f([&quot;TICKS&quot;])),PWa=(new A).e(&quot;etc._ticks&quot;,OWa),QWa=I(r(),(new w).f([&quot;TIMER&quot;])),RWa=(new A).e(&quot;etc._timer&quot;,QWa),SWa=I(r(),(new w).f([&quot;TOWARDS&quot;])),
TWa=(new A).e(&quot;etc._towards&quot;,SWa),UWa=I(r(),(new w).f([&quot;TOWARDSXY&quot;])),VWa=(new A).e(&quot;etc._towardsxy&quot;,UWa),WWa=I(r(),(new w).f([&quot;TURTLE&quot;])),XWa=(new A).e(&quot;_turtle&quot;,WWa),YWa=I(r(),(new w).f([&quot;TURTLE-SET&quot;])),ZWa=(new A).e(&quot;etc._turtleset&quot;,YWa),$Wa=I(r(),(new w).f([&quot;TURTLES&quot;])),aXa=(new A).e(&quot;_turtles&quot;,$Wa),bXa=I(r(),(new w).f([&quot;TURTLES-AT&quot;])),cXa=(new A).e(&quot;etc._turtlesat&quot;,bXa),dXa=I(r(),(new w).f([&quot;TURTLES-HERE&quot;])),eXa=(new A).e(&quot;etc._turtleshere&quot;,dXa),fXa=I(r(),(new w).f([&quot;TURTLES-ON&quot;])),gXa=(new A).e(&quot;etc._turtleson&quot;,
fXa),hXa=I(r(),(new w).f([&quot;USER-DIRECTORY&quot;])),iXa=(new A).e(&quot;etc._userdirectory&quot;,hXa),jXa=I(r(),(new w).f([&quot;USER-FILE&quot;])),kXa=(new A).e(&quot;etc._userfile&quot;,jXa),lXa=I(r(),(new w).f([&quot;USER-INPUT&quot;])),mXa=(new A).e(&quot;etc._userinput&quot;,lXa),nXa=I(r(),(new w).f([&quot;USER-NEW-FILE&quot;])),oXa=(new A).e(&quot;etc._usernewfile&quot;,nXa),pXa=I(r(),(new w).f([&quot;USER-ONE-OF&quot;])),qXa=(new A).e(&quot;etc._useroneof&quot;,pXa),rXa=I(r(),(new w).f([&quot;USER-YES-OR-NO?&quot;])),sXa=(new A).e(&quot;etc._useryesorno&quot;,rXa),tXa=I(r(),(new w).f([&quot;VARIANCE&quot;])),uXa=
(new A).e(&quot;etc._variance&quot;,tXa),vXa=I(r(),(new w).f([&quot;WITH&quot;])),wXa=(new A).e(&quot;_with&quot;,vXa),xXa=I(r(),(new w).f([&quot;WITH-MAX&quot;])),yXa=(new A).e(&quot;etc._withmax&quot;,xXa),zXa=I(r(),(new w).f([&quot;WITH-MIN&quot;])),AXa=(new A).e(&quot;etc._withmin&quot;,zXa),BXa=I(r(),(new w).f([&quot;WORD&quot;])),CXa=(new A).e(&quot;_word&quot;,BXa),DXa=I(r(),(new w).f([&quot;WORLD-HEIGHT&quot;])),EXa=(new A).e(&quot;etc._worldheight&quot;,DXa),FXa=I(r(),(new w).f([&quot;WORLD-WIDTH&quot;])),GXa=(new A).e(&quot;etc._worldwidth&quot;,FXa),HXa=I(r(),(new w).f([&quot;WRAP-COLOR&quot;])),IXa=(new A).e(&quot;etc._wrapcolor&quot;,
HXa),JXa=I(r(),(new w).f([&quot;XOR&quot;]));nh(XGa,(new w).f([ZGa,aHa,cHa,eHa,gHa,iHa,kHa,mHa,oHa,qHa,sHa,uHa,wHa,yHa,AHa,CHa,EHa,GHa,IHa,KHa,MHa,OHa,QHa,SHa,UHa,WHa,YHa,$Ha,bIa,dIa,fIa,hIa,jIa,lIa,nIa,pIa,rIa,tIa,vIa,xIa,zIa,BIa,DIa,FIa,HIa,JIa,LIa,NIa,PIa,RIa,TIa,VIa,XIa,ZIa,aJa,cJa,eJa,gJa,iJa,kJa,mJa,oJa,qJa,sJa,uJa,wJa,yJa,AJa,CJa,EJa,GJa,IJa,KJa,MJa,OJa,QJa,SJa,UJa,WJa,YJa,$Ja,bKa,dKa,fKa,hKa,jKa,lKa,nKa,pKa,rKa,tKa,vKa,xKa,zKa,BKa,DKa,FKa,HKa,JKa,LKa,NKa,PKa,RKa,TKa,VKa,XKa,ZKa,aLa,cLa,eLa,gLa,iLa,
kLa,mLa,oLa,qLa,sLa,uLa,wLa,yLa,ALa,CLa,ELa,GLa,ILa,KLa,MLa,OLa,QLa,SLa,ULa,WLa,YLa,$La,bMa,dMa,fMa,hMa,jMa,lMa,nMa,pMa,rMa,tMa,vMa,xMa,zMa,BMa,DMa,FMa,HMa,JMa,LMa,NMa,PMa,RMa,TMa,VMa,XMa,ZMa,aNa,cNa,eNa,gNa,iNa,kNa,mNa,oNa,qNa,sNa,uNa,wNa,yNa,ANa,CNa,ENa,GNa,INa,KNa,MNa,ONa,QNa,SNa,UNa,WNa,YNa,$Na,bOa,dOa,fOa,hOa,jOa,lOa,nOa,pOa,rOa,tOa,vOa,xOa,zOa,BOa,DOa,FOa,HOa,JOa,LOa,NOa,POa,ROa,TOa,VOa,XOa,ZOa,aPa,cPa,ePa,gPa,iPa,kPa,mPa,oPa,qPa,sPa,uPa,wPa,yPa,APa,CPa,EPa,GPa,IPa,KPa,MPa,OPa,QPa,SPa,UPa,WPa,
YPa,$Pa,bQa,dQa,fQa,hQa,jQa,lQa,nQa,pQa,rQa,tQa,vQa,xQa,zQa,BQa,DQa,FQa,HQa,JQa,LQa,NQa,PQa,RQa,TQa,VQa,XQa,ZQa,aRa,cRa,eRa,gRa,iRa,kRa,mRa,oRa,qRa,sRa,uRa,wRa,yRa,ARa,CRa,ERa,GRa,IRa,KRa,MRa,ORa,QRa,SRa,URa,WRa,YRa,$Ra,bSa,dSa,fSa,hSa,jSa,lSa,nSa,pSa,rSa,tSa,vSa,xSa,zSa,BSa,DSa,FSa,HSa,JSa,LSa,NSa,PSa,RSa,TSa,VSa,XSa,ZSa,aTa,cTa,eTa,gTa,iTa,kTa,mTa,oTa,qTa,sTa,uTa,wTa,yTa,ATa,CTa,ETa,GTa,ITa,KTa,MTa,OTa,QTa,STa,UTa,WTa,YTa,$Ta,bUa,dUa,fUa,hUa,jUa,lUa,nUa,pUa,rUa,tUa,vUa,xUa,zUa,BUa,DUa,FUa,HUa,JUa,
LUa,NUa,PUa,RUa,TUa,VUa,XUa,ZUa,aVa,cVa,eVa,gVa,iVa,kVa,mVa,oVa,qVa,sVa,uVa,wVa,yVa,AVa,CVa,EVa,GVa,IVa,KVa,MVa,OVa,QVa,SVa,UVa,WVa,YVa,$Va,bWa,dWa,fWa,hWa,jWa,lWa,nWa,pWa,rWa,tWa,vWa,xWa,zWa,BWa,DWa,FWa,HWa,JWa,LWa,NWa,PWa,RWa,TWa,VWa,XWa,ZWa,aXa,cXa,eXa,gXa,iXa,kXa,mXa,oXa,qXa,sXa,uXa,wXa,yXa,AXa,CXa,EXa,GXa,IXa,(new A).e(&quot;etc._xor&quot;,JXa)]));this.a=(8|this.a)&lt;&lt;24&gt;&gt;24;return this};
function Bea(a){if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/TokenMapper.scala: 20&quot;);return a.Yi}function Cea(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/TokenMapper.scala: 18&quot;);return a.ij}SF.prototype.$classData=g({XH:0},!1,&quot;org.nlogo.core.TokenMapper&quot;,{XH:1,d:1,v_:1});function dO(){}dO.prototype=new l;dO.prototype.constructor=dO;function eO(){}eO.prototype=dO.prototype;
dO.prototype.RF=function(a){var b=wn(a),d=this.Dh();if(b===wn(d))b=!0;else{a:{b=0;for(d=fO(this.Dh(),0);;)if(kd(d)){if(d.$().xh().ba())break a;b=1+b|0;d=d.aa()}else break;b=-1}if(-1!==b){b=wn(a);a:{for(var d=0,e=fO(this.Dh(),0);;)if(kd(e)){if(e.$().xh().ba())break a;d=1+d|0;e=e.aa()}else break;d=-1}b=b&gt;=d}else b=!1}if(b){b=this.Dh();d=B().s;for(a=gO(b,a,d);!a.z();){b=a.$();if(null===b)throw(new q).j(b);if(!b.la().Mi(b.pa()))return!1;a=a.aa()}return!0}return!1};
dO.prototype.LT=function(a){var b=this.Dh();a=this.Jl(a);var d=B().s;a=gO(b,a,d);b=function(){return function(a){if(null!==a)return a.la().$h(a.pa());throw(new q).j(a);}}(this);d=B().s;if(d===B().s)if(a===y())b=y();else{var d=a.$(),e=d=Cd(new Dd,b(d),y());for(a=a.aa();a!==y();){var f=a.$(),f=Cd(new Dd,b(f),y()),e=e.Ia=f;a=a.aa()}b=d}else{for(d=Mc(a,d);!a.z();)e=a.$(),d.Na(b(e)),a=a.aa();b=d.Da()}return b.zb(&quot;\n&quot;)};
dO.prototype.GV=function(a,b){var d=this.Dh(),e=B().s,d=hO(d,e);a=function(a,b){return function(a){if(null!==a){var d=a.la();a=a.Dc();return a&lt;wn(b)?d.ii(Pi(b,a)):d.xh().Y()}throw(new q).j(a);}}(this,a);e=B().s;if(e===B().s)if(d===y())a=y();else{for(var e=d.$(),f=e=Cd(new Dd,a(e),y()),d=d.aa();d!==y();)var h=d.$(),h=Cd(new Dd,a(h),y()),f=f.Ia=h,d=d.aa();a=e}else{for(e=Mc(d,e);!d.z();)f=d.$(),e.Na(a(f)),d=d.aa();a=e.Da()}return this.Kl(a,b)};function iO(){this.Cn=null;this.a=this.AE=this.nE=0}
iO.prototype=new l;iO.prototype.constructor=iO;iO.prototype.zq=function(){this.Cn.zq();Hm(this,jO(this))};function Em(a){gla(a.Cn,jO(a));Hm(a,jO(a))}function hla(a){var b=new iO;b.Cn=a;b.nE=65536;b.a=(1|b.a)&lt;&lt;24&gt;&gt;24;b.AE=0;b.a=(2|b.a)&lt;&lt;24&gt;&gt;24;return b}function Hm(a,b){a.AE=b;a.a=(2|a.a)&lt;&lt;24&gt;&gt;24}function Im(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/AutoGrowingBufferedReader.scala: 9&quot;);return a.AE}
function jO(a){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/AutoGrowingBufferedReader.scala: 8&quot;);return a.nE}iO.prototype.cy=function(){if(0===Im(this)){this.Cn.zq();gla(this.Cn,jO(this)&lt;&lt;1);var a=this.Cn,b=jO(this);a.uv((new Vb).ia(b,b&gt;&gt;31));Hm(this,jO(this));this.nE=jO(this)&lt;&lt;1;this.a=(1|this.a)&lt;&lt;24&gt;&gt;24}a=this.Cn.cy();Hm(this,-1+Im(this)|0);return a};
iO.prototype.$classData=g({m0:0},!1,&quot;org.nlogo.lex.AutoGrowingBufferedReader&quot;,{m0:1,d:1,Nia:1});function Xm(){this.nk=null;this.Zo=0;this.ab=null}Xm.prototype=new l;Xm.prototype.constructor=Xm;Xm.prototype.nba=function(a,b,d){this.nk=a;this.Zo=b;this.ab=d;return this};Xm.prototype.ta=function(){Em(this.nk);var a=-1!==this.nk.cy();this.nk.zq();return a};Xm.prototype.iU=function(a,b,d){Xm.prototype.nba.call(this,hla(a),b,d);return this};
function $ca(a){a=a.nk.cy();return-1===a?F():(new J).j((new af).Ra(65535&amp;a))}Xm.prototype.$classData=g({n0:0},!1,&quot;org.nlogo.lex.BufferedInputWrapper&quot;,{n0:1,d:1,Qia:1});function kO(){this.SU=null;this.kV=0;this.kT=null;this.a=0;this.ga=null}kO.prototype=new l;kO.prototype.constructor=kO;
function bda(a){var b=new kO;if(null===a)throw Kg(Lg(),null);b.ga=a;b.SU=F();b.a=(1|b.a)&lt;&lt;24&gt;&gt;24;b.kV=0;b.a=(2|b.a)&lt;&lt;24&gt;&gt;24;b.kT=jm(pm(),(new A).e(ila(b),jla(b)),tb(new ub,function(){return function(a,b){b=null===b?0:b.X;if(null!==a){var f=a.la(),h=a.Dc();if(F()===f&amp;&amp;0===h&amp;&amp;123===b)return(new A).e((new A).e((new J).j((new af).Ra(123)),0),gm())}return null!==a&amp;&amp;(f=a.Dc(),0&gt;f)?(new A).e((new A).e(F(),f),mm()):null!==a&amp;&amp;(f=a.Dc(),13===b||10===b)?(new A).e((new A).e((new J).j((new af).Ra(b)),f),hm()):
null!==a&amp;&amp;(h=a.la(),f=a.Dc(),Vk(h)&amp;&amp;(h=h.U,125===(null===h?0:h.X)&amp;&amp;1===f&amp;&amp;125===b))?(new A).e((new A).e(F(),0),hm()):null!==a&amp;&amp;(h=a.la(),f=a.Dc(),Vk(h)&amp;&amp;(h=h.U,123===(null===h?0:h.X)&amp;&amp;123===b))?(new A).e((new A).e(F(),1+f|0),gm()):null!==a&amp;&amp;(h=a.la(),f=a.Dc(),Vk(h)&amp;&amp;(h=h.U,125===(null===h?0:h.X)&amp;&amp;125===b))?(new A).e((new A).e(F(),-1+f|0),gm()):null!==a&amp;&amp;(h=a.la(),f=a.Dc(),Vk(h)&amp;&amp;(h=h.U,h=null===h?0:h.X,0===f&amp;&amp;123!==h))?(new A).e((new A).e(F(),0),mm()):null!==a?(a=a.Dc(),(new A).e((new A).e((new J).j((new af).Ra(b)),
a),gm())):(new A).e((new A).e(F(),0),mm())}}(b)));b.a=(4|b.a)&lt;&lt;24&gt;&gt;24;return b}c=kO.prototype;c.y=function(a){return kla(this,null===a?0:a.X)};function jla(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/TokenLexer.scala: 48&quot;);return a.kV}c.k=function(){return&quot;\x3cfunction1\x3e&quot;};c.Fa=function(a){return!!kla(this,a.X)};
function kla(a,b){if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/TokenLexer.scala: 49&quot;);return a.kT.y((new af).Ra(b))}function ila(a){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/TokenLexer.scala: 47&quot;);return a.SU}c.Ca=function(a){return qb(this,a)};c.$classData=g({u0:0},!1,&quot;org.nlogo.lex.TokenLexer$DoubleBracePairMatcher&quot;,{u0:1,d:1,fa:1});function lO(){}lO.prototype=new l;
lO.prototype.constructor=lO;lO.prototype.b=function(){return this};function Sp(a,b,d){var e=new mO,f;nO||(nO=(new oO).b());f=nO;gda||(gda=(new Um).b());b=lla(e,f,dda(b,d));return(new bc).Gf(b,m(new n,function(){return function(a){return a.la()}}(a)))}lO.prototype.$classData=g({v0:0},!1,&quot;org.nlogo.lex.Tokenizer$&quot;,{v0:1,d:1,Mia:1});var pO=void 0;function qO(){this.ga=this.h=null}qO.prototype=new l;qO.prototype.constructor=qO;
function mla(a){a:for(;;){var b=a.pe.G().Aq;if(Uj(D())===b||Rj(D())===b)return&quot;-T--&quot;;if(Vj(D())===b||Sj(D())===b)return&quot;--P-&quot;;if(Wj(D())===b||Tj(D())===b)return&quot;---L&quot;;if(Lj(D())===b||Qj(D())===b)if(a=a.za,r(),a=(new J).j(a),null!==a.U&amp;&amp;0&lt;=a.U.Rb(1)&amp;&amp;(a=a.U.W(0),xb(a)))continue a;return&quot;-TPL&quot;}}
function nla(a,b,d){d.wa(m(new n,function(a,b,d){return function(k){if(yb(k)||zb(k)){if(&quot;?&quot;!==b)var p=b;else a:{r();p=(new J).j(d);if(null!==p.U&amp;&amp;0&lt;=p.U.Rb(1)&amp;&amp;(p=p.U.W(0),xb(p))){p=mla(p);break a}p=&quot;-TPL&quot;}p=Zm(a.ga,p)}else p=a;Nb(p,k)}}(a,b,d)))}function ola(a){return 111===(65535&amp;(a.charCodeAt(0)|0))?u((new v).K((new w).f([&quot;an &quot;,&quot;&quot;])),(new w).f([a])):u((new v).K((new w).f([&quot;a &quot;,&quot;&quot;])),(new w).f([a]))}
qO.prototype.MY=function(a){var b=a.xd;this.h=pla(b,this.h);a=a.za;var d=b.G().Pa,e=r();a=a.De(d,e.s);d=new rO;e=r();a=a.ic(d,e.s);b.G().p.ba()?nla(this,b.G().p.Y(),a):a.wa(m(new n,function(a){return function(b){Nb(a,b)}}(this)));b.M(this.h)};
function sO(a,b,d){var e;e=(new Sb).c(b);for(var f=$e().zp,f=Mc(e,f),h=0,k=e.R.length|0;h&lt;k;){var p=e.W(h),p=null===p?0:p.X,p=45!==p&amp;&amp;-1!==Ew(Ia(),d,p)?p:45;f.Na((new af).Ra(p));h=1+h|0}e=f.Da();&quot;----&quot;===e&amp;&amp;(f=a.H().Wb.toUpperCase(),kh(),Ia(),b=u((new v).K((new w).f([&quot;|You can't use &quot;,&quot; in &quot;,&quot; context,\n              | because &quot;,&quot; is &quot;,&quot;-only.&quot;])),(new w).f([f,ola(qla(b)),f,qla(d)])),b=(new Sb).c(b),b=Qb(0,dd(b),&quot;\n&quot;,&quot;&quot;),a=a.H().ra,jh(b,a.Xa,a.Va,a.ab));return e}
function Zm(a,b){var d=new qO;d.h=b;if(null===a)throw Kg(Lg(),null);d.ga=a;return d}function pla(a,b){return Ir(a)?sO(a,b,a.Kh.N()):Lt(a)?sO(a,b,a.Kh.N()):sO(a,b,a.N())}
qO.prototype.VF=function(a){var b=a.pe;this.h=pla(b,this.h);if(An(b.G()))var d=b.G().Wa,e=b.G().Pa,f=B(),e=e.fd(d,f.s);else e=b.G().Pa;a:{d=0;for(e=fO(e,0);;)if(kd(e)){f=e.$()|0;if(Gn(D(),Jj(),f))break a;d=1+d|0;e=e.aa()}else break;d=-1}e=a.za;f=r();d=e.sj(f.s).Pf(m(new n,function(a,b){return function(a){if(null!==a)return a.Dc()!==b;throw(new q).j(a);}}(this,d)));e=m(new n,function(){return function(a){return a.la()}}(this));f=r();e=d.xa(e,f.s);d=Zm(this.ga,&quot;OTPL&quot;);Fo(b)||Rt(b)?(a=a.za.$(),Nb(d,
a)):b.G().p.ba()?nla(this,b.G().p.Y(),e):e.wa(m(new n,function(a){return function(b){Nb(a,b)}}(this)));Fo(b)||Rt(b)?b.P((new J).j(d.h)):b.M(this.h)};
function qla(a){for(var b=(new af).Ra(79),b=(new A).e(b,&quot;observer&quot;),d=(new af).Ra(84),d=(new A).e(d,&quot;turtle&quot;),e=(new af).Ra(80),e=(new A).e(e,&quot;patch&quot;),f=(new af).Ra(76),b=[b,d,e,(new A).e(f,&quot;link&quot;)],d=dc(new ec,gc()),e=0,f=b.length|0;e&lt;f;)hc(d,b[e]),e=1+e|0;b=d.Ma;a=(new Sb).c(a);d=(new Fm).b();e=0;for(f=a.R.length|0;e&lt;f;){var h=a.W(e);45!==(null===h?0:h.X)!==!1&amp;&amp;tO(d,null===h?0:h.X);e=1+e|0}a=(new Sb).c(d.vc.Zb);$e();d=Mc(a,new em);e=0;for(f=a.R.length|0;e&lt;f;)h=a.W(e),d.Na(b.y((new af).Ra(null===
h?0:h.X))),e=1+e|0;return d.Da().zb(&quot;/&quot;)}qO.prototype.$classData=g({A0:0},!1,&quot;org.nlogo.parse.AgentTypeChecker$AgentTypeCheckerVisitor&quot;,{A0:1,d:1,kZ:1});function Lo(){this.xy=null;this.a=!1}Lo.prototype=new l;Lo.prototype.constructor=Lo;c=Lo.prototype;c.b=function(){this.xy=(B(),y());this.a=!0;return this};function uO(a){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/CarefullyVisitor.scala: 15&quot;);return a.xy}
c.vh=function(a){var b=a.xd;if(Ar(b)){var d=a.za.W(0),d=Ab(this,d),e=uO(this);this.xy=Cd(new Dd,b,e);this.a=!0;b=a.za.W(1);b=Ab(this,b);this.xy=uO(this).aa();this.a=!0;d=I(r(),(new w).f([d,b]));return(new Hb).cj(a.xd,d,a.ra)}return Gb(this,a)};
c.Cg=function(a){var b=a.pe;if(Pt(b)){if(uO(this).z()){kh();var d=rh(),e=[b.H().Wb],d=d.Vl.dc(&quot;compiler.CarefullyVisitor.badNesting&quot;);if(!Vk(d)){if(F()===d)throw(new df).c(u((new v).K((new w).f([&quot;coding error, bad translation key: &quot;,&quot; for Errors&quot;])),(new w).f([&quot;compiler.CarefullyVisitor.badNesting&quot;])));throw(new q).j(d);}var f=d.U,h=e.length|0;if(0&gt;=h)var k=0;else d=h&gt;&gt;31,k=(0===d?-1&lt;(-2147483648^h):0&lt;d)?-1:h;r();Zn();var d=[],p=0,t=e.length|0;0&gt;k&amp;&amp;$n(ao(),0,h,1,!1);for(t=t&lt;k?t:k;p&lt;t;){var x=e[p],
E=p;0&gt;k&amp;&amp;$n(ao(),0,h,1,!1);if(0&gt;E||E&gt;=k)throw(new P).c(&quot;&quot;+E);x=(new A).e(x,E);d.push(x);p=1+p|0}e=d.length|0;h=0;k=f;a:for(;;){if(h!==e){f=1+h|0;k=(new A).e(k,d[h]);b:{h=k.kb;t=k.Ab;if(null!==t&amp;&amp;(p=t.la(),t=t.Dc(),Qg(p))){k=p;k=Qb(Ia(),h,u((new v).K((new w).f([&quot;\\\\{&quot;,&quot;\\\\}&quot;])),(new w).f([&quot;&quot;+t])),k);break b}throw(new q).j(k);}h=f;continue a}break}d=a.ra;jh(k,d.Xa,d.Va,d.ab)}d=jd().Uc(Yea(uO(this).$()));d=(new FH).Ha(d);b=Fh(b,d);return(new Kb).Qf(b,a.za,a.ra)}return Jb(this,a)};
c.$g=function(a){return Lb(this,a)};c.$classData=g({I0:0},!1,&quot;org.nlogo.parse.CarefullyVisitor&quot;,{I0:1,d:1,ah:1});function vO(){this.RU=null}vO.prototype=new l;vO.prototype.constructor=vO;function laa(a,b,d){var e=b.pe;if(nr(e))return d.pi((new wO).ks(e.Wc));if(Go(e)){var f=e.va;if(!a.RU.ib(f))return d.pi((new xO).c(f))}return qc(e)&amp;&amp;(Lca||(Lca=(new Vl).b()),e=(new J).j((new ac).ae(e.ve.lk(),yO(e.ve),e.ok)),!e.z())?(a=e.Y().og,d.qp(a)):naa(a,b,d)}vO.prototype.K=function(a){this.RU=a;return this};
vO.prototype.$classData=g({J0:0},!1,&quot;org.nlogo.parse.ClosedVariableFinder&quot;,{J0:1,d:1,Aia:1});function Mo(){}Mo.prototype=new l;Mo.prototype.constructor=Mo;c=Mo.prototype;c.b=function(){return this};c.vh=function(a){return Gb(this,a)};
c.Cg=function(a){var b=a.pe;if(Rt(b)){a=Jb(this,a);var d=(new vO).K(b.ve.lk()),e=a.za.W(0),f=I($e().pt,y()),d=wb(d,e,f),b=rla(b,b.ve,d,b.uc);return(new Kb).Qf(b,a.za,a.ra)}return Fo(b)?(a=Jb(this,a),d=(new vO).K(b.ve.lk()),e=a.za.W(0),f=I($e().pt,y()),d=wb(d,e,f),b=sla(b,b.ve,d,b.uc),(new Kb).Qf(b,a.za,a.ra)):Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({K0:0},!1,&quot;org.nlogo.parse.ClosureTagger&quot;,{K0:1,d:1,ah:1});function zO(){this.a=!1}zO.prototype=new l;
zO.prototype.constructor=zO;zO.prototype.b=function(){AO=this;for(var a=(new af).Ra(38),a=(new A).e(a,&quot;\x26amp;&quot;),b=(new af).Ra(60),b=(new A).e(b,&quot;\x26lt;&quot;),d=(new af).Ra(62),d=(new A).e(d,&quot;\x26gt;&quot;),e=(new af).Ra(34),a=[a,b,d,(new A).e(e,&quot;\x26quot;&quot;)],b=dc(new ec,gc()),d=0,e=a.length|0;d&lt;e;)hc(b,a[d]),d=1+d|0;this.a=!0;return this};zO.prototype.$classData=g({L0:0},!1,&quot;org.nlogo.parse.Colorizer$&quot;,{L0:1,d:1,Lia:1});var AO=void 0;function Po(){this.yC=this.UB=null;this.a=!1}Po.prototype=new l;
Po.prototype.constructor=Po;c=Po.prototype;c.b=function(){this.yC=y();this.a=!0;return this};
c.vh=function(a){if(Jr(a.xd)||BO(a.xd)||Kr(a.xd)){var b=CO(this).$().nx(),d=CO(this).aa();DO(this,Cd(new Dd,b,d))}b=CO(this).$();d=a.xd;if(b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.$A&amp;&amp;BO(d)){kh();var e=[&quot;STOP&quot;],b=rh().Vl.dc(&quot;org.nlogo.prim.etc._stop.notAllowedInsideToReport&quot;);if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f([&quot;coding error, bad translation key: &quot;,&quot; for Errors&quot;])),(new w).f([&quot;org.nlogo.prim.etc._stop.notAllowedInsideToReport&quot;])));throw(new q).j(b);}var d=b.U,f=e.length|0;if(0&gt;=f)var h=
0;else b=f&gt;&gt;31,h=(0===b?-1&lt;(-2147483648^f):0&lt;b)?-1:f;r();Zn();var b=[],k=0,p=e.length|0;0&gt;h&amp;&amp;$n(ao(),0,f,1,!1);for(p=p&lt;h?p:h;k&lt;p;){var t=e[k],x=k;0&gt;h&amp;&amp;$n(ao(),0,f,1,!1);if(0&gt;x||x&gt;=h)throw(new P).c(&quot;&quot;+x);t=(new A).e(t,x);b.push(t);k=1+k|0}e=b.length|0;f=0;h=d;a:for(;;){if(f!==e){d=1+f|0;h=(new A).e(h,b[f]);b:{f=h.kb;p=h.Ab;if(null!==p&amp;&amp;(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),f,u((new v).K((new w).f([&quot;\\\\{&quot;,&quot;\\\\}&quot;])),(new w).f([&quot;&quot;+p])),h);break b}throw(new q).j(h);}f=d;continue a}break}a=a.ra;jh(h,
a.Xa,a.Va,a.ab)}else if(Jr(d)?(e=CO(this),e=EO(zn(e))?!tla(CO(this).$()):!1):e=!1,e){kh();e=[&quot;REPORT&quot;];b=rh().Vl.dc(&quot;org.nlogo.prim._report.canOnlyUseInToReport&quot;);if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f([&quot;coding error, bad translation key: &quot;,&quot; for Errors&quot;])),(new w).f([&quot;org.nlogo.prim._report.canOnlyUseInToReport&quot;])));throw(new q).j(b);}d=b.U;f=e.length|0;0&gt;=f?h=0:(b=f&gt;&gt;31,h=(0===b?-1&lt;(-2147483648^f):0&lt;b)?-1:f);r();Zn();b=[];k=0;p=e.length|0;0&gt;h&amp;&amp;$n(ao(),0,f,1,!1);for(p=p&lt;h?p:
h;k&lt;p;){t=e[k];x=k;0&gt;h&amp;&amp;$n(ao(),0,f,1,!1);if(0&gt;x||x&gt;=h)throw(new P).c(&quot;&quot;+x);t=(new A).e(t,x);b.push(t);k=1+k|0}e=b.length|0;f=0;h=d;a:for(;;){if(f!==e){d=1+f|0;h=(new A).e(h,b[f]);b:{f=h.kb;p=h.Ab;if(null!==p&amp;&amp;(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),f,u((new v).K((new w).f([&quot;\\\\{&quot;,&quot;\\\\}&quot;])),(new w).f([&quot;&quot;+p])),h);break b}throw(new q).j(h);}f=d;continue a}break}a=a.ra;jh(h,a.Xa,a.Va,a.ab)}else if((b&amp;&amp;b.$classData&amp;&amp;b.$classData.n.YA||EO(b))&amp;&amp;Jr(d)){kh();e=[&quot;REPORT&quot;];b=rh().Vl.dc(&quot;org.nlogo.prim._report.mustImmediatelyBeUsedInToReport&quot;);
if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f([&quot;coding error, bad translation key: &quot;,&quot; for Errors&quot;])),(new w).f([&quot;org.nlogo.prim._report.mustImmediatelyBeUsedInToReport&quot;])));throw(new q).j(b);}d=b.U;f=e.length|0;0&gt;=f?h=0:(b=f&gt;&gt;31,h=(0===b?-1&lt;(-2147483648^f):0&lt;b)?-1:f);r();Zn();b=[];k=0;p=e.length|0;0&gt;h&amp;&amp;$n(ao(),0,f,1,!1);for(p=p&lt;h?p:h;k&lt;p;){t=e[k];x=k;0&gt;h&amp;&amp;$n(ao(),0,f,1,!1);if(0&gt;x||x&gt;=h)throw(new P).c(&quot;&quot;+x);t=(new A).e(t,x);b.push(t);k=1+k|0}e=b.length|0;f=0;h=d;a:for(;;){if(f!==e){d=
1+f|0;h=(new A).e(h,b[f]);b:{f=h.kb;p=h.Ab;if(null!==p&amp;&amp;(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),f,u((new v).K((new w).f([&quot;\\\\{&quot;,&quot;\\\\}&quot;])),(new w).f([&quot;&quot;+p])),h);break b}throw(new q).j(h);}f=d;continue a}break}a=a.ra;jh(h,a.Xa,a.Va,a.ab)}else return a.xd.G().rs?(b=(new FO).uk(this,!1),d=CO(this),DO(this,Cd(new Dd,b,d)),b=Gb(this,a),d=CO(this).$(),DO(this,CO(this).aa()),a=a.za,d=m(new n,function(a,b){return function(a){return yb(a)?Bb(new Cb,(new Fb).ns(a.fe.Yr,a.fe.Zf,b.oe),a.ra,a.qj):a}}(this,d)),
e=r(),a=a.xa(d,e.s),(new Hb).cj(b.xd,a,b.ra)):Gb(this,a)};function ula(a){if(null===a.UB&amp;&amp;null===a.UB){var b=new GO;if(null===a)throw Kg(Lg(),null);b.Sa=a;a.UB=b}}c.Cg=function(a){if(Fo(a.pe)){var b=(new HO).uk(this,!1),d=CO(this);DO(this,Cd(new Dd,b,d));a=Jb(this,a);DO(this,CO(this).aa());return a}return Jb(this,a)};function CO(a){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ControlFlowVerifier.scala: 31&quot;);return a.yC}
function DO(a,b){a.yC=b;a.a=!0}c.$g=function(a){if(a.ji.$u.jn)var b=(new IO).uk(this,(ula(this),!0)),d=CO(this);else b=(new JO).uk(this,!1),d=CO(this);b=Cd(new Dd,b,d);DO(this,b);a=Lb(this,a);b=CO(this).$();DO(this,CO(this).aa());return Mb(a.ji,(new Fb).ns(a.fe.Yr,a.fe.Zf,b.oe),a.bz)};c.$classData=g({P0:0},!1,&quot;org.nlogo.parse.ControlFlowVerifier&quot;,{P0:1,d:1,ah:1});function KO(){}KO.prototype=new l;KO.prototype.constructor=KO;KO.prototype.b=function(){return this};
function Kaa(a){return m(new n,function(a){return function(d){return m(new n,function(a,b){return function(a){return Sc(b,a)}}(a,d))}}(a))}
function Yc(a,b,d,e){var f=e.Uj.dc(d);f.z()?f=F():(f=f.Y(),f=(new J).j(Rc(f,a,b,d,e)));if(f.z()){var f=Sc(e.pf,d),h=(new A).e(An(b.pe.G()),b.pe),k=h.Ab;if(!0===!!h.kb){h=b.za.$();h=Nc(a,h,d,0,e);b=b.za;var p=r();return b.sj(p.s).aa().Gb(Tc(Uc(h),&quot;&quot;+f+e.am.y(k)),tb(new ub,function(a,b){return function(d,e){d=(new A).e(d,e);e=d.kb;var f=d.Ab;if(null!==f)return Nc(a,f.la(),b,f.Dc(),e);throw(new q).j(d);}}(a,d)))}if(vla(h.Ab))return e=Tc(Uc(e),&quot;&quot;+Sc(e.pf,d)+wla(e.pf,d)),Oc(a,b,d,e);k=h.Ab;if(!1===!!h.kb&amp;&amp;
Do(k))return e=Tc(Uc(e),&quot;&quot;+Sc(e.pf,d)+wla(e.pf,d)),Oc(a,b,d,e);k=h.Ab;if(!1===!!h.kb&amp;&amp;qc(k)){f=(new Sb).c(e.Wb);f=LO(f);f.z()?f=!0:(f=f.Y(),f=32===(null===f?0:f.X));f=f?&quot;&quot;:&quot; &quot;;h=e.Uj;p=e.pf;Wda();h=Vda(Ho(),h,p);b=Oc(a,b,d,h).Wb;var h=!1,p=null,t=k.ve;a:{if(t&amp;&amp;t.$classData&amp;&amp;t.$classData.n.Qz&amp;&amp;(h=!0,p=t,!0===p.cr)){a=&quot;[ -\x3e&quot;;break a}if(h&amp;&amp;!1===p.cr)a=&quot;[&quot;;else if(yO(t))a=&quot;&quot;;else if(t&amp;&amp;t.$classData&amp;&amp;t.$classData.n.Rz)a=t.li,a=u((new v).K((new w).f([&quot;[ &quot;,&quot; -\x3e&quot;])),(new w).f([a.Wb]));else if(t&amp;&amp;t.$classData&amp;&amp;
t.$classData.n.Pz)h=t.yr,p=(new v).K((new w).f([&quot;[ [&quot;,&quot;] -\x3e&quot;])),a=m(new n,function(){return function(a){return a.Wb}}(a)),t=r(),a=u(p,(new w).f([h.xa(a,t.s).zb(&quot; &quot;)]));else throw(new q).j(t);}h=!Wp(Ia(),a,&quot;\x3e&quot;)||0&lt;=(b.length|0)&amp;&amp;&quot; &quot;===b.substring(0,1)?&quot;&quot;:&quot; &quot;;p=$c(e.pf,d);d=yO(k.ve)?&quot;&quot;:&quot;]&quot;;k=(new Sb).c(b);LO(k).ib((new af).Ra(32))?(k=(new Sb).c(p),k=Uk(k).ib((new af).Ra(32))):k=!1;k?(k=(new Sb).c(p),p=k.R.length|0,k=Ye(Ze(),k.R,1,p)):k=p;return Tc(Uc(e),f+a+h+b+k+d)}k=h.Ab;if(!1===!!h.kb)return f=
Tc(Uc(e),&quot;&quot;+f+e.am.y(k)),d=Oc(a,b,d,f),Vc(new Wc,d.Wb,d.Uj,e.am,d.pf);throw(new q).j(h);}return f.Y()}function Laa(a){return m(new n,function(a){return function(d){return m(new n,function(a,b){return function(a){return $c(b,a)}}(a,d))}}(a))}KO.prototype.$classData=g({U0:0},!1,&quot;org.nlogo.parse.Formatter&quot;,{U0:1,d:1,Xia:1});function MO(){this.yy=null}MO.prototype=new l;MO.prototype.constructor=MO;
function wla(a,b){a=NO(a.yy,b.Fj);return Vk(a)&amp;&amp;(a=a.U,xb(a))?(b=a.pe,Do(b)&amp;&amp;(a=b.X,Zg(a))?(b=Eo(),$b(b,a,!0,!1)):b.H().Wb):&quot;&quot;}function $c(a,b){var d=!1,e=null,f=b.Fj.nn();return Vk(f)&amp;&amp;(d=!0,e=f,OO(e.U))?(b=(new PO).K(b.Fj.Qd(1)),a=NO(a.yy,b.Fj),Vk(a)&amp;&amp;(a=a.U,xb(a)&amp;&amp;(a=vi().Yd(a),!a.z()&amp;&amp;(a=a.Y().gb,Fo(a))))?&quot; &quot;:&quot; ]&quot;):d&amp;&amp;QO(e.U)?&quot; ]&quot;:&quot; &quot;}
function Sc(a,b){var d=!1,e=null,f=b.Fj.nn();return Vk(f)&amp;&amp;(d=!0,e=f,RO(e.U))||d&amp;&amp;SO(e.U)?&quot; &quot;:d&amp;&amp;(f=e.U,OO(f))?(d=f.sc,e=!1,f=null,b=(new PO).K(b.Fj.Qd(1)),a=NO(a.yy,b.Fj),Vk(a)&amp;&amp;(e=!0,f=a,a=f.U,xb(a)&amp;&amp;(a=vi().Yd(a),!a.z()&amp;&amp;(a=a.Y().gb,Fo(a))))||e&amp;&amp;(a=f.U,GF(a)&amp;&amp;(d=a.za.W(d),yb(d)&amp;&amp;d.qj))?&quot;&quot;:&quot; [&quot;):d&amp;&amp;QO(e.U)?&quot; [&quot;:&quot;&quot;}function xla(a){var b=new MO;b.yy=a;return b}MO.prototype.$classData=g({Y0:0},!1,&quot;org.nlogo.parse.LambdaWhitespace&quot;,{Y0:1,d:1,Sia:1});function wc(){}wc.prototype=new l;
wc.prototype.constructor=wc;wc.prototype.b=function(){return this};wc.prototype.qU=function(){return!1};wc.prototype.wY=function(a,b){a:{b=!!b;if(null!==a){var d=a.jb;if(Cm()===d&amp;&amp;b){b=(new TO).b();d=vg();a=(new A).e(Gh(a,b,a.Wb,d),!1);break a}}b:{if(null!==a&amp;&amp;(b=a.jb,d=a.X,Cm()===b&amp;&amp;&quot;LET&quot;===d)){b=!0;break b}if(null!==a&amp;&amp;(b=a.jb,d=a.X,Cm()===b&amp;&amp;&quot;__LET&quot;===d)){b=!0;break b}b=!1}a=b?(new A).e(a,!0):(new A).e(a,!1)}return a};wc.prototype.$classData=g({Z0:0},!1,&quot;org.nlogo.parse.LetNamer$&quot;,{Z0:1,d:1,W1:1});
var vc=void 0;function Ko(){}Ko.prototype=new l;Ko.prototype.constructor=Ko;c=Ko.prototype;c.b=function(){return this};c.vh=function(a){if(no(a.xd)){var b=a.za.aa();return Gb(this,(new Hb).cj(a.xd,b,a.ra))}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({$0:0},!1,&quot;org.nlogo.parse.LetReducer&quot;,{$0:1,d:1,ah:1});function Oo(){this.dx=null;this.a=!1}Oo.prototype=new l;Oo.prototype.constructor=Oo;Oo.prototype.b=function(){this.dx=F();this.a=!0;return this};
Oo.prototype.MY=function(a){var b=a.xd;no(b)?(this.dx=b.Wc,this.a=!0,paa(this,a),this.dx=F(),this.a=!0):paa(this,a)};function yla(a){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/LetVerifier.scala: 13&quot;);return a.dx}
Oo.prototype.VF=function(a){var b=a.pe;if(nr(b)){kh();var d=yla(this).z()||yla(this).Y()!==b.Wc,e=b.H();if(!d){var f=rh(),d=[b.H().Wb.toUpperCase()],b=f.Vl.dc(&quot;compiler.LetVariable.notDefined&quot;);if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f([&quot;coding error, bad translation key: &quot;,&quot; for Errors&quot;])),(new w).f([&quot;compiler.LetVariable.notDefined&quot;])));throw(new q).j(b);}var f=b.U,h=d.length|0;if(0&gt;=h)var k=0;else b=h&gt;&gt;31,k=(0===b?-1&lt;(-2147483648^h):0&lt;b)?-1:h;r();Zn();var b=[],p=0,t=d.length|
0;0&gt;k&amp;&amp;$n(ao(),0,h,1,!1);for(t=t&lt;k?t:k;p&lt;t;){var x=d[p],E=p;0&gt;k&amp;&amp;$n(ao(),0,h,1,!1);if(0&gt;E||E&gt;=k)throw(new P).c(&quot;&quot;+E);x=(new A).e(x,E);b.push(x);p=1+p|0}d=b.length|0;h=0;k=f;a:for(;;){if(h!==d){f=1+h|0;k=(new A).e(k,b[h]);b:{h=k.kb;t=k.Ab;if(null!==t&amp;&amp;(p=t.la(),t=t.Dc(),Qg(p))){k=p;k=Qb(Ia(),h,u((new v).K((new w).f([&quot;\\\\{&quot;,&quot;\\\\}&quot;])),(new w).f([&quot;&quot;+t])),k);break b}throw(new q).j(k);}h=f;continue a}break}e=e.ra;jh(k,e.Xa,e.Va,e.ab)}}qaa(this,a)};
Oo.prototype.$classData=g({d1:0},!1,&quot;org.nlogo.parse.LetVerifier&quot;,{d1:1,d:1,kZ:1});function yc(){this.hh=this.ji=this.ce=this.ec=this.bj=null;this.ya=!1}yc.prototype=new l;yc.prototype.constructor=yc;
function Eaa(a){var b=UO(a.ji),d=Aaa(a.ji),e=r();d.fd(b,e.s).wa(m(new n,function(a){return function(b){var d=zla(a,b);d.z()?d=F():(d=d.Y(),d=(new J).j(d.X));var d=d.Y(),e=Ir(d)||Lt(d)||qr(d);kh();e||(d=Mr(d)?&quot;an extension command&quot;:St(d)?&quot;an extension reporter&quot;:u((new v).K((new w).f([&quot;a &quot;,&quot;&quot;])),(new w).f([Uq(oa(d))])),e=b.Wb.toUpperCase(),b=b.ra,jh(&quot;There is already &quot;+d+&quot; called &quot;+e,b.Xa,b.Va,b.ab))}}(a)))}
function Ala(a){if(!a.ya){var b=r(),d=(new VO).tD(Mp(a.ec.ug));a.bj=I(b,(new w).f([d,(new WO).tD(Mp(a.ec.ug)),(new XO).pD(a.ec),(new YO).pD(a.ec),Bla(a.hh),(new ZO).K(sc(a.ji)),(new $O).$b(a.ce)]));a.ya=!0}a.ce=null;a.hh=null;return a.bj}yc.prototype.qU=function(){};
function zla(a,b){var d=a.ya?a.bj:Ala(a);a=m(new n,function(a,b){return function(a){return a.y(b).ub()}}(a,b));var e=r(),d=d.aj(a,e.s).wg();if(d.z())return F();a=d.Y();if(null!==a)d=a.pa(),b=Jm(new Km,b.Wb,a.la(),d,b.ra),d.L(b);else throw(new q).j(a);return(new J).j(b)}yc.prototype.wY=function(a){var b=a.jb;if(Cm()===b)if(b=zla(this,a),b.z()){var b=(new aP).b(),d=vg();a=Gh(a,b,a.Wb,d)}else a=b.Y();a=(new A).e(a,void 0);return a};
yc.prototype.$classData=g({f1:0},!1,&quot;org.nlogo.parse.Namer&quot;,{f1:1,d:1,W1:1});function bP(){}bP.prototype=new l;bP.prototype.constructor=bP;c=bP.prototype;c.b=function(){return this};c.y=function(a){return Cla(a)};
function Cla(a){var b=a.jb,d=Om();if(null!==b&amp;&amp;b===d)throw(new hd).Ff(a);Ih||(Ih=(new Hh).b());b=a.Wb;d=Ih;if(!d.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Keywords.scala: 8&quot;);if(d.QU.ib(b.toUpperCase())||Wp(Ia(),b.toUpperCase(),&quot;-OWN&quot;))b=cP(),a=Jm(new Km,a.Wb,b,a.X,a.ra);else if(on||(on=(new nn).b()),b=on.es(a.Wb),Vk(b))b=b.U,d=Rm(),a=Jm(new Km,a.Wb,d,b,a.ra);else if(F()!==b)throw(new q).j(b);return a}c.k=function(){return&quot;\x3cfunction1\x3e&quot;};
c.Fa=function(a){return!!Cla(a)};c.Ca=function(a){return qb(this,a)};c.$classData=g({g1:0},!1,&quot;org.nlogo.parse.Namer0$&quot;,{g1:1,d:1,fa:1});var dP=void 0;function Tp(){dP||(dP=(new bP).b());return dP}function eP(){this.zG=null;this.a=!1}eP.prototype=new l;eP.prototype.constructor=eP;eP.prototype.b=function(){this.zG=&quot;Can only have literal agents and agentsets if importing.&quot;;this.a=!0;return this};
function Yda(a){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/NullImportHandler.scala: 10&quot;);return a.zG}eP.prototype.$classData=g({h1:0},!1,&quot;org.nlogo.parse.NullImportHandler$&quot;,{h1:1,d:1,Iia:1});var fP=void 0;function Dda(){fP||(fP=(new eP).b());return fP}function gP(){this.za=this.h=this.va=this.zS=this.iV=this.$u=null;this.a=0}gP.prototype=new l;gP.prototype.constructor=gP;gP.prototype.M=function(a){this.h=a;this.a=(8|this.a)&lt;&lt;24&gt;&gt;24};
function Caa(a,b){a.za=b;a.a=(16|a.a)&lt;&lt;24&gt;&gt;24}function UO(a){if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 12&quot;);return a.iV}function Aaa(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 13&quot;);return a.zS}
gP.prototype.me=function(){if(0===(4&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 21&quot;);return this.va};function sc(a){if(0===(16&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 9&quot;);return a.za}
function Dla(a){var b=new gP;b.$u=a;Baa(b);b.iV=a.ni.aa().$();b.a=(1|b.a)&lt;&lt;24&gt;&gt;24;var d=a.fn,e=m(new n,function(){return function(a){return a.g}}(b)),f=r();b.zS=d.xa(e,f.s);b.a=(2|b.a)&lt;&lt;24&gt;&gt;24;a=a.fn;d=m(new n,function(){return function(a){return a.va}}(b));e=r();Caa(b,a.xa(d,e.s).mg());b.va=UO(b).X;b.a=(4|b.a)&lt;&lt;24&gt;&gt;24;return b}gP.prototype.N=function(){if(0===(8&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 9&quot;);return this.h};
gP.prototype.$classData=g({k1:0},!1,&quot;org.nlogo.parse.RawProcedure&quot;,{k1:1,d:1,Hia:1});function Me(){this.ZC=this.ym=null}Me.prototype=new pka;Me.prototype.constructor=Me;function pba(a,b,d){a.ym=b;a.ZC=d;return a}function hP(a){return a.ym.z()?Ela(new iP,a,2147483647):Ela(new iP,a,a.ZC.y(a.ym.$())|0)}Me.prototype.$classData=g({m1:0},!1,&quot;org.nlogo.parse.SeqReader&quot;,{m1:1,Qoa:1,d:1});function No(){}No.prototype=new l;No.prototype.constructor=No;No.prototype.vh=function(a){return Gb(this,a)};
No.prototype.Cg=function(a){var b=a.pe;if(qc(b)){var d=Jb(this,a);a=Yc((new KO).b(),d,(new PO).K(y()),Vc(new Wc,&quot;&quot;,nh($e().kk,y()),m(new n,function(){return function(a){return Co(Ho(),a)}}(this)),xla(a))).Wb.trim();if(Rt(b))a=(new J).j(a),b=rla(b,b.ve,b.ok,a);else{if(!Fo(b))throw(new q).j(b);a=(new J).j(a);b=sla(b,b.ve,b.ok,a)}return(new Kb).Qf(b,d.za,d.ra)}return Jb(this,a)};No.prototype.$g=function(a){return Lb(this,a)};
No.prototype.$classData=g({o1:0},!1,&quot;org.nlogo.parse.SourceTagger&quot;,{o1:1,d:1,ah:1});function yp(){this.Dw=this.NW=null;this.ya=!1}yp.prototype=new l;yp.prototype.constructor=yp;function jP(a){return kP(lP(a,&quot;identifier&quot;,Cm()),m(new n,function(){return function(a){return mP(a.X,a)}}(a)))}yp.prototype.b=function(){return this};
function Fla(a){return kP(nP(oP(a,&quot;UNDIRECTED-LINK-BREED&quot;),K(function(a){return function(){return pP(a,&quot;UNDIRECTED-LINK-BREED&quot;)}}(a))),m(new n,function(){return function(a){var d=a.Fb.ql,e=a.Fb.Bf;a.Fb;return qP(d,e,!0,!1)}}(a)))}function Gla(a){return kP(nP(Le(a,&quot;\x3cbreed\x3e-own&quot;,(new rP).dq(a)),K(function(a){return function(){return sP(a)}}(a))),m(new n,function(){return function(a){if(null!==a){var d=a.gb,e=new tP,d=mP(d.X,d);a=a.Fb;e.zg=d;e.If=a;return e}throw(new q).j(a);}}(a)))}
function pP(a,b){var d=kP(jP(a).er(K(function(a){return function(){return jP(a)}}(a))),m(new n,function(){return function(a){if(null!==a)return qP(a.gb,a.Fb,!1,!1);throw(new q).j(a);}}(a)));b=Ue(jP(a),m(new n,function(a,b){return function(d){d=u((new v).K((new w).f([&quot;Breed declarations must have plural and singular. &quot;,&quot; [&quot;,&quot;] has only one name.&quot;])),(new w).f([b,d.va]));return Je(a,d)}}(a,b)));return uP(vP(lP(a,&quot;opening bracket&quot;,Am()),K(function(a,b,d){return function(){return Re(b,K(function(a,b){return function(){return b}}(a,
d)))}}(a,d,b))),K(function(a){return function(){return lP(a,&quot;closing bracket&quot;,Bm())}}(a)))}function Hla(a){return vP(lP(a,&quot;opening bracket&quot;,Am()),K(function(a){return function(){return De(a,K(function(a){return function(){return uP(Qe(a,K(function(a){return function(){return Le(a,&quot;string&quot;,(new wP).dq(a))}}(a))),K(function(a){return function(){return lP(a,&quot;closing bracket&quot;,Bm())}}(a)))}}(a)))}}(a)))}function lP(a,b,d){var e=new xP;e.LF=d;return Le(a,b,e)}
function rea(a){null===a.Dw&amp;&amp;null===a.Dw&amp;&amp;(a.Dw=(new mD).To(a));return a.Dw}function oP(a,b){var d=new yP;d.qq=b;return Le(a,b,d)}function pea(a){var b=Qe(a,K(function(a){return function(){return Ila(a)}}(a))).er(K(function(a){return function(){return Re(Jla(a),K(function(a){return function(){return Kla(a)}}(a)))}}(a)));return kP(Lla(a,b),m(new n,function(){return function(a){if(null!==a){var b=a.gb;a=a.Fb;var f=B();return b.Rc(a,f.s)}throw(new q).j(a);}}(a)))}
function Mla(a){return kP(nP(oP(a,&quot;EXTENSIONS&quot;),K(function(a){return function(){return sP(a)}}(a))),m(new n,function(){return function(a){if(null!==a)return(new zP).uD(a.gb,a.Fb);throw(new q).j(a);}}(a)))}function Nla(a){return kP(nP(Le(a,&quot;BREED&quot;,(new AP).dq(a)),K(function(a){return function(){return pP(a,&quot;BREED&quot;)}}(a))),m(new n,function(){return function(a){return a.Fb}}(a)))}
function Ila(a){return Re(Re(Re(Re(Re(Re(Re(Re(Re(Ola(a),K(function(a){return function(){return Mla(a)}}(a))),K(function(a){return function(){return Nla(a)}}(a))),K(function(a){return function(){return Pla(a)}}(a))),K(function(a){return function(){return Fla(a)}}(a))),K(function(a){return function(){return BP(a,&quot;GLOBALS&quot;)}}(a))),K(function(a){return function(){return BP(a,&quot;TURTLES-OWN&quot;)}}(a))),K(function(a){return function(){return BP(a,&quot;PATCHES-OWN&quot;)}}(a))),K(function(a){return function(){return BP(a,
&quot;LINKS-OWN&quot;)}}(a))),K(function(a){return function(){return Gla(a)}}(a)))}function Jla(a){var b=K(function(a){return function(){return Qla(a)}}(a));return uP(qba(a,b,b),K(function(a){return function(){return Re(lP(a,&quot;eof&quot;,Dc()),K(function(a){return function(){return Je(a,&quot;TO or TO-REPORT expected&quot;)}}(a)))}}(a)))}function CP(a){a.ya||a.ya||(a.NW=(new TC).j(F()),a.ya=!0);return a.NW}
function sP(a){return vP(lP(a,&quot;opening bracket&quot;,Am()),K(function(a){return function(){return De(a,K(function(a){return function(){return uP(Qe(a,K(function(a){return function(){return jP(a)}}(a))),K(function(a){return function(){return lP(a,&quot;closing bracket&quot;,Bm())}}(a)))}}(a)))}}(a)))}
function BP(a,b){return kP(nP(oP(a,b),K(function(a){return function(){return sP(a)}}(a))),m(new n,function(a,b){return function(a){if(null!==a){var d=new tP,k=mP(b,a.gb);a=a.Fb;d.zg=k;d.If=a;return d}throw(new q).j(a);}}(a,b)))}function Ola(a){return kP(nP(oP(a,&quot;__INCLUDES&quot;),K(function(a){return function(){return Hla(a)}}(a))),m(new n,function(){return function(a){if(null!==a)return(new DP).uD(a.gb,a.Fb);throw(new q).j(a);}}(a)))}
function Qla(a){return kP(nP(Re(oP(a,&quot;TO&quot;),K(function(a){return function(){return oP(a,&quot;TO-REPORT&quot;)}}(a))),K(function(a){return function(){return jP(a)}}(a))).er(K(function(a){return function(){return Re(kP(sP(a),m(new n,function(){return function(a){return(new J).j(a)}}(a))),K(function(a){return function(){var b=F();return oba(a,b)}}(a)))}}(a))).er(K(function(a){return function(){return Qe(a,K(function(a){return function(){return Le(a,&quot;?&quot;,(new EP).dq(a))}}(a)))}}(a))).er(K(function(a){return function(){return Re(oP(a,
&quot;END&quot;),K(function(a){return function(){return Je(a,&quot;END expected&quot;)}}(a)))}}(a))),m(new n,function(){return function(a){if(null!==a){var d=a.gb,e=a.Fb;if(null!==d){var f=d.gb,h=d.Fb;if(null!==f&amp;&amp;(d=f.gb,f=f.Fb,null!==d)){var k=d.gb;a=d.Fb;var d=k.X,d=null!==d&amp;&amp;Ea(d,&quot;TO-REPORT&quot;),f=f.z()?I(r(),y()):f.Y(),p=a.g,t=B(),h=h.fd(p,t.s),p=B(),k=h.fd(k,p.s),p=B(),h=new FP,e=k.mc(e,p.s);h.va=a;h.jn=d;h.fn=f;h.ni=e;return h}}}throw(new q).j(a);}}(a)))}
function Pla(a){return kP(nP(oP(a,&quot;DIRECTED-LINK-BREED&quot;),K(function(a){return function(){return pP(a,&quot;DIRECTED-LINK-BREED&quot;)}}(a))),m(new n,function(){return function(a){var d=a.Fb.ql,e=a.Fb.Bf;a.Fb;return qP(d,e,!0,!0)}}(a)))}function Kla(a){return Re(kP(lP(a,&quot;eof&quot;,Dc()),m(new n,function(){return function(){return I(r(),y())}}(a))),K(function(a){return function(){return Je(a,&quot;keyword expected&quot;)}}(a)))}yp.prototype.$classData=g({q1:0},!1,&quot;org.nlogo.parse.StructureCombinators&quot;,{q1:1,d:1,Noa:1});
function $p(){this.Ii=null;this.br=0}$p.prototype=new l;$p.prototype.constructor=$p;function mea(a,b){return Zp(new $p,a.Ii.Am(b.Ii),a.br+b.br|0)}function Zp(a,b,d){a.Ii=b;a.br=d;return a}function mn(a,b){a=a.Ii;b=b.toUpperCase();return a.ib(b)}c=$p.prototype;c.o=function(a){if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.TP){a=a.Ii;var b=this.Ii;return null===a?null===b:GP(a,b)}return this===a};c.k=function(){return cc(this.Ii,&quot;&quot;,&quot;, &quot;,&quot;&quot;)};c.Vn=function(a){return Zp(new $p,this.Ii.Pf(a),this.br)};c.wa=function(a){this.Ii.wa(a)};
function Uda(a){for(var b=en(),d=F(),e=a.br;d.z();){var f=(&quot;_&quot;+e).toUpperCase();mn(a,f)?e=1+e|0:d=(new J).j((new A).e(f,e))}a:{if(Vk(d)&amp;&amp;(e=d.U,null!==e)){d=e.Dc();e=e.la();break a}throw(new q).j(d);}d|=0;return(new A).e(e,Zp(new $p,a.Ii.vj((new A).e(e,b)),1+d|0))}function Pda(a,b,d){var e=a.Ii;b=b.toUpperCase();return Zp(new $p,e.vj((new A).e(b,d)),a.br)}c.es=function(a){return this.Ii.dc(a.toUpperCase())};function dn(a,b){return a.Ii.y(b.toUpperCase())}
function rc(a,b,d){var e=a.Ii;d=m(new n,function(a,b){return function(a){a=a.toUpperCase();return(new A).e(a,b)}}(a,d));var f=Lc();return Zp(new $p,e.Am(b.xa(d,f.s).te($e().Fk)),a.br)}c.xa=function(a,b){b=b.Uh();var d=this.Ii,e=ul().s;b.Yb(Wr(d,a,e));return b.Da()};c.$classData=g({TP:0},!1,&quot;org.nlogo.parse.SymbolTable&quot;,{TP:1,d:1,lb:1});function HP(){this.RS=null}HP.prototype=new l;HP.prototype.constructor=HP;function kga(a){var b=new HP;b.RS=a;return b}
HP.prototype.Ye=function(){var a;a=IP();var b=this.RS,d=new JP;d.NY=b.Ni;d=d.Ye();b=b.pp;if(nq(b))a=Rla(0,d,b.ha);else{if(!pq(b))throw(new q).j(b);a=Sla(a,d,b.cc)}return a};HP.prototype.$classData=g({o2:0},!1,&quot;org.nlogo.tortoise.compiler.CompiledWidget$$anon$1&quot;,{o2:1,d:1,Gl:1});function KP(){this.NT=this.vV=this.wV=null;this.a=0}KP.prototype=new l;KP.prototype.constructor=KP;
KP.prototype.b=function(){LP=this;this.wV=(new MP).b();this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;this.vV=(new NP).b();this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;this.NT=ys();this.a=(4|this.a)&lt;&lt;24&gt;&gt;24;return this};function OP(a){if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Compiler.scala: 57&quot;);return a.NT}
function Tla(a,b,d){var e=ega(qga(b.ec,b.Gc,b.Sf,d.uq)),f=Pfa(vt(),b.Gc);Dt||(Dt=(new Ct).b());var h=Yfa(b.Jr);b=b.wu;d=m(new n,function(a){return function(b){if(nq(b))return b.ha;if(!pq(b))throw(new q).j(b);var d=b.cc;b=(new v).K((new w).f(['modelConfig.dialog.notify(&quot;Error(s) in interface global init: ','&quot;)']));var e=function(){return function(a){return a.Kc}}(a);tq();var f=e(d.Fc),d=d.Mc,h=uq().Vd,d=vq(d);a:for(;;){if(!wq(d)){if(xq(d)){var k=d,d=k.dd,k=e(k.$c),h=(new yq).Qb(k,h);continue a}throw(new q).j(d);
}break}e=xt((new zq).Qb(f,h)).ub();return u(b,(new w).f([cc(e,&quot;&quot;,&quot;, &quot;,&quot;&quot;)]))}}(a));var k=r();b=b.xa(d,k.s).zb(&quot;\n&quot;);d=(new tt).vk(&quot;interfaceInit&quot;,b,I(r(),(new w).f([&quot;world&quot;,&quot;procedures&quot;,&quot;modelConfig&quot;])));fu||(fu=(new bu).b());b=fu;k=r();e=e.Rc(f,k.s);f=r();h=e.Rc(h,f.s);e=Ula(a);f=r();h=h.mc(e,f.s);e=Vla(a);f=r();h=h.mc(e,f.s);e=Wla(a);f=r();h=h.mc(e,f.s);e=r();d=h.mc(d,e.s);a=Xla(a);h=r();return Ega(b,d.mc(a,h.s))}
function Ifa(a,b,d){var e=ws(vs()),f=Yla(b),e=Cp(f,e.fk,e.Li,e.hj,e.yi,e.bg,e.Hf,e.ug),f=ph(),f=Zla(a,b,e,f);if(null===f)throw(new q).j(f);var h=f.gb,e=f.Fb,f=f.og,k=(new cs).c(b.Zd),h=Wfa(Vfa(new At,PP(a),d,k),h),k=afa(),k=qb(m(new n,function(a,b){return function(a){return QP(b,a)}}(a,m(new n,function(a,b,d,e){return function(f){return RP(a,f,!0,d,b,!1,e)}}(a,e,f,$la(new SP,d.Lo,d.uq,k,d.bp))))),m(new n,function(a){return function(b){if(nq(b))return b;if(pq(b)){var d=b.cc;b=function(){return function(a){return a}}(a);
tq();var e=b(d.Fc),d=d.Mc,f=uq().Vd,d=vq(d);a:for(;;){if(!wq(d)){if(xq(d)){var h=d,d=h.dd,h=b(h.$c),f=(new yq).Qb(h,f);continue a}throw(new q).j(d);}break}return(new qq).j((new zq).Qb(e,f))}throw(new q).j(b);}}(a))),p=qb(m(new n,function(a,b){return function(a){return QP(b,a)}}(a,m(new n,function(a,b,d,e){return function(f){return RP(a,f,!1,e,d,!1,b)}}(a,d,e,f)))),m(new n,function(a){return function(b){if(nq(b))return b;if(pq(b)){var d=b.cc;b=function(){return function(a){return a}}(a);tq();var e=
b(d.Fc),d=d.Mc,f=uq().Vd,d=vq(d);a:for(;;){if(!wq(d)){if(xq(d)){var h=d,d=h.dd,h=b(h.$c),f=(new yq).Qb(h,f);continue a}throw(new q).j(d);}break}return(new qq).j((new zq).Qb(e,f))}throw(new q).j(b);}}(a))),k=Tga(Sga(k,p),b.Gc);a=m(new n,function(a,b){return function(a){return QP(b,a)}}(a,m(new n,function(a,b,d,e){return function(f){return RP(a,f,!0,e,d,!0,b)}}(a,d,e,f))));d=ama(b);p=r();a=d.xa(a,p.s);return bma(h,k,a,b,f,e)}
function TP(a,b,d){b=u((new v).K((new w).f([&quot;modelConfig.&quot;,&quot;&quot;])),(new w).f([b]));a=m(new n,function(){return function(a){if(null!==a){var b=a.la();a=a.pa();return u((new v).K((new w).f([&quot;&quot;,&quot;: &quot;,&quot;&quot;])),(new w).f([b,a]))}throw(new q).j(a);}}(a));var e=ul().s;d=Wr(d,a,e).Oc(&quot;{\n|    &quot;,&quot;,\n|    &quot;,&quot;\n|  }&quot;);d=u((new v).K((new w).f(['|if (typeof javax !\x3d\x3d &quot;undefined&quot;) {\n          |  ',&quot; \x3d &quot;,&quot;\n          |}&quot;])),(new w).f([b,d]));d=(new Sb).c(d);d=dd(d);return(new tt).vk(b,d,I(r(),(new w).f([&quot;modelConfig&quot;])))}
function Zla(a,b,d,e){b=b.Zd;var f=cma();OP(a);var h=F();OP(a);var k=(new OF).b();a=OP(a);d=xaa(a,b,h,d,!1,e,f,k);if(null===d)throw(new q).j(d);e=d.pa();return(new ac).ae(d.la(),e.ec,e.ce)}function QP(a,b){try{Pq();var d=a.y(b);return Vq().y(d)}catch(e){if(Jq(e))return Pq(),Qq(Gq(),e);throw e;}}
function Xla(a){for(var b=ds(fd(),I(r(),(new w).f([&quot;filename&quot;])),&quot;&quot;),b=(new A).e(&quot;exportOutput&quot;,b),d=ds(fd(),I(r(),(new w).f([&quot;filename&quot;])),&quot;&quot;),b=[b,(new A).e(&quot;exportView&quot;,d)],d=dc(new ec,gc()),e=0,f=b.length|0;e&lt;f;)hc(d,b[e]),e=1+e|0;return TP(a,&quot;exporting&quot;,d.Ma)}function Wla(a){for(var b=ds(fd(),I(r(),(new w).f([&quot;agent&quot;])),&quot;&quot;),b=[(new A).e(&quot;resizeWorld&quot;,b)],d=dc(new ec,gc()),e=0,f=b.length|0;e&lt;f;)hc(d,b[e]),e=1+e|0;return TP(a,&quot;world&quot;,d.Ma)}
function PP(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Compiler.scala: 55&quot;);return a.vV}
function Vla(a){for(var b=ds(fd(),I(r(),(new w).f([&quot;str&quot;])),&quot;return true;&quot;),b=(new A).e(&quot;confirm&quot;,b),d=ds(fd(),I(r(),(new w).f([&quot;str&quot;])),&quot;return 'dummy implementation';&quot;),d=(new A).e(&quot;input&quot;,d),e=ds(fd(),I(r(),(new w).f([&quot;str&quot;])),&quot;&quot;),e=(new A).e(&quot;notify&quot;,e),f=ds(fd(),I(r(),(new w).f([&quot;str&quot;])),&quot;return true;&quot;),b=[b,d,e,(new A).e(&quot;yesOrNo&quot;,f)],d=dc(new ec,gc()),e=0,f=b.length|0;e&lt;f;)hc(d,b[e]),e=1+e|0;return TP(a,&quot;dialog&quot;,d.Ma)}
function Ula(a){for(var b=ds(fd(),I(r(),y()),&quot;&quot;),b=(new A).e(&quot;clear&quot;,b),d=ds(fd(),I(r(),(new w).f([&quot;str&quot;])),&quot;context.getWriter().print(str);&quot;),b=[b,(new A).e(&quot;write&quot;,d)],d=dc(new ec,gc()),e=0,f=b.length|0;e&lt;f;)hc(d,b[e]),e=1+e|0;return TP(a,&quot;output&quot;,d.Ma)}
function RP(a,b,d,e,f,h,k){var p;p=yca();var t=uj();if(!p.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/SourceWrapping.scala: 7&quot;);p=p.uS.y(t);p=d?&quot;to __evaluator [] &quot;+p+&quot; &quot;:&quot;to-report __evaluator [] &quot;+p+&quot; report ( &quot;;yca();t=d?&quot;\n__done end&quot;:&quot;\n) __done end&quot;;t=u((new v).K((new w).f([&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;])),(new w).f([p,b,t]));b=(new cs).c(t);p=new Bt;var x=I(r(),y());p.lq=!h;p.cp=x;x=cma();OP(a);var E=F();OP(a);OP(a);var S=(new OF).b(),U=OP(a);e=xaa(U,t,E,f,
!0,e,x,S);if(null===e)throw(new q).j(e);e=e.la();e=k.bp?Nfa(Ofa(),e.$()):e.$();if(d)return a=PP(a),sr(a,e.fe,!0,!h,k,b,p);h=PP(a);a=e.fe.Zf.W(1).za.W(0);return ir(h,a,k,b,p)}KP.prototype.$classData=g({t2:0},!1,&quot;org.nlogo.tortoise.compiler.Compiler$&quot;,{t2:1,d:1,Zia:1});var LP=void 0;function br(){LP||(LP=(new KP).b());return LP}function UP(){this.bE=null}UP.prototype=new l;UP.prototype.constructor=UP;UP.prototype.kh=function(){var a=Tr(Qr(),(new Rr).ci(this.bE),&quot;name&quot;),b=Sr();return sd(a,b)};
function dma(a){try{var b=Tr(Qr(),(new Rr).ci(a.bE),&quot;prims&quot;),d=cfa(),e=sd(b,d).X,f=m(new n,function(){return function(a){return bfa(hfa(),a)}}(a)),h=Mk().qc;return Wr(e,f,h)}catch(k){a=ko(Lg(),k);if(us(a))throw Kg(Lg(),(new $r).jc(u((new v).K((new w).f([&quot;Problem parsing extension definition JSON.  &quot;,&quot;&quot;])),(new w).f([a.Fh()])),a));throw k;}}UP.prototype.ci=function(a){this.bE=a;return this};UP.prototype.$classData=g({D2:0},!1,&quot;org.nlogo.tortoise.compiler.CreateExtension$$anon$3&quot;,{D2:1,d:1,aja:1});
function VP(){this.NV=this.CT=null;this.a=0}VP.prototype=new l;VP.prototype.constructor=VP;c=VP.prototype;
c.b=function(){WP=this;var a;ifa||(ifa=(new bs).b());a=I(r(),(new w).f(['{ &quot;name&quot;: &quot;codap&quot;, &quot;prims&quot;: [ { &quot;name&quot;: &quot;init&quot;, &quot;actionName&quot;: &quot;init&quot;, &quot;argTypes&quot;: [&quot;command&quot;] }, { &quot;name&quot;: &quot;call&quot;, &quot;actionName&quot;: &quot;call&quot;, &quot;argTypes&quot;: [&quot;wildcard&quot;] } ] }','{ &quot;name&quot;: &quot;nlmap&quot;, &quot;prims&quot;: [ { &quot;name&quot;: &quot;from-list&quot;, &quot;actionName&quot;: &quot;from-list&quot;, &quot;argTypes&quot;: [&quot;list&quot;], &quot;returnType&quot;: &quot;wildcard&quot; }, { &quot;name&quot;: &quot;to-list&quot;, &quot;actionName&quot;: &quot;to-list&quot;, &quot;argTypes&quot;: [&quot;wildcard&quot;], &quot;returnType&quot;: &quot;list&quot; }, { &quot;name&quot;: &quot;is-map?&quot;, &quot;actionName&quot;: &quot;is-map?&quot;, &quot;argTypes&quot;: [&quot;wildcard&quot;], &quot;returnType&quot;: &quot;boolean&quot; }, { &quot;name&quot;: &quot;get&quot;, &quot;actionName&quot;: &quot;get&quot;, &quot;argTypes&quot;: [&quot;wildcard&quot;, &quot;string&quot;], &quot;returnType&quot;: &quot;wildcard&quot; }, { &quot;name&quot;: &quot;remove&quot;, &quot;actionName&quot;: &quot;remove&quot;, &quot;argTypes&quot;: [&quot;wildcard&quot;, &quot;string&quot;], &quot;returnType&quot;: &quot;wildcard&quot; }, { &quot;name&quot;: &quot;add&quot;, &quot;actionName&quot;: &quot;add&quot;, &quot;argTypes&quot;: [&quot;wildcard&quot;, &quot;string&quot;, &quot;wildcard&quot;], &quot;returnType&quot;: &quot;wildcard&quot; }, { &quot;name&quot;: &quot;to-json&quot;, &quot;actionName&quot;: &quot;to-json&quot;, &quot;argTypes&quot;: [&quot;wildcard&quot;], &quot;returnType&quot;: &quot;string&quot; }, { &quot;name&quot;: &quot;to-urlenc&quot;, &quot;actionName&quot;: &quot;to-urlenc&quot;, &quot;argTypes&quot;: [&quot;wildcard&quot;], &quot;returnType&quot;: &quot;string&quot; }, { &quot;name&quot;: &quot;from-json&quot;, &quot;actionName&quot;: &quot;from-json&quot;, &quot;argTypes&quot;: [&quot;string&quot;], &quot;returnType&quot;: &quot;wildcard&quot; } ] }','{ &quot;name&quot;: &quot;logging&quot;, &quot;prims&quot;: [ { &quot;name&quot;: &quot;all-logs&quot;, &quot;actionName&quot;: &quot;all-logs&quot;, &quot;argTypes&quot;: [], &quot;returnType&quot;: &quot;list&quot; }, { &quot;name&quot;: &quot;clear-logs&quot;, &quot;actionName&quot;: &quot;clear-logs&quot;, &quot;argTypes&quot;: [], &quot;returnType&quot;: &quot;unit&quot; }, { &quot;name&quot;: &quot;log-globals&quot;, &quot;actionName&quot;: &quot;log-globals&quot;, &quot;argTypes&quot;: [{ &quot;type&quot;: &quot;string&quot;, &quot;isRepeatable&quot;: true }], &quot;returnType&quot;: &quot;unit&quot; }, { &quot;name&quot;: &quot;log-message&quot;, &quot;actionName&quot;: &quot;log-message&quot;, &quot;argTypes&quot;: [&quot;string&quot;], &quot;returnType&quot;: &quot;unit&quot; } ] }',
'{ &quot;name&quot;: &quot;http-req&quot;, &quot;prims&quot;: [ { &quot;name&quot;: &quot;get&quot;, &quot;actionName&quot;: &quot;get&quot;, &quot;argTypes&quot;: [&quot;string&quot;], &quot;returnType&quot;: &quot;list&quot; }, { &quot;name&quot;: &quot;post&quot;, &quot;actionName&quot;: &quot;post&quot;, &quot;argTypes&quot;: [&quot;string&quot;, &quot;string&quot;, &quot;string&quot;], &quot;returnType&quot;: &quot;list&quot; } ] }']));var b=m(new n,function(){return function(a){hfa();var b=Mha();a=sx(b,ba.JSON.parse(a));return(new UP).ci(a)}}(this)),d=r();a=a.xa(b,d.s);b=m(new n,function(){return function(a){return(new A).e(a.kh(),a)}}(this));d=r();this.CT=a.xa(b,d.s).te($e().Fk);this.a=(1|this.a)&lt;&lt;
24&gt;&gt;24;XP||(XP=(new YP).b());this.NV=nh(XP,y());this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;return this};c.hY=function(){ZP(this).Er()};function ZP(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/NLWExtensionManager.scala: 120&quot;);return a.NV}c.yS=function(){return!0};
c.aW=function(a){var b=ZP(this).dc(a);if(Vk(b))return b.U;if(F()!==b)throw(new q).j(b);-1!==(a.indexOf(&quot;:&quot;)|0)&amp;&amp;ema(u((new v).K((new w).f([&quot;No such primitive: &quot;,&quot;&quot;])),(new w).f([a])));return null};function ema(a){var b=Nm().ra.Xa,d=Nm().ra.Va,e=Nm();throw(new hd).ms(a,b,d,e.ra.ab);}
c.bU=function(a){if(0===(1&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/NLWExtensionManager.scala: 119&quot;);var b=this.CT.dc(a);if(!Vk(b))throw F()===b&amp;&amp;ema(u((new v).K((new w).f([&quot;No such extension: &quot;,&quot;&quot;])),(new w).f([a]))),(new q).j(b);b=b.U;a=dma(b);var b=m(new n,function(a,b){return function(a){return(new A).e(b.kh(),a)}}(this,b)),d=r();a=a.xa(b,d.s);b=m(new n,function(){return function(a){if(null!==a){var b=a.la(),d=a.pa();if(null!==
d)return a=d.Zu,d=d.va,b=u((new v).K((new w).f([&quot;&quot;,&quot;:&quot;,&quot;&quot;])),(new w).f([b,d])),(new A).e(b.toUpperCase(),a)}throw(new q).j(a);}}(this));d=r();a=a.xa(b,d.s);b=ZP(this);ID(b,a)};c.$classData=g({P2:0},!1,&quot;org.nlogo.tortoise.compiler.NLWExtensionManager$&quot;,{P2:1,d:1,FZ:1});var WP=void 0;function cma(){WP||(WP=(new VP).b());return WP}function ct(){}ct.prototype=new l;ct.prototype.constructor=ct;c=ct.prototype;c.b=function(){return this};c.vh=function(a){return Gb(this,a)};
c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Nt(d)&amp;&amp;(r(),d=(new J).j(b),null!==d.U&amp;&amp;0===d.U.Rb(1)&amp;&amp;(d=d.U.W(0),xb(d)&amp;&amp;(b=vi().Yd(d),!b.z()&amp;&amp;(d=b.Y().gb,b=b.Y().Fb,$P(d))))))return d=(new aQ).b(),(new Kb).Qf(d,b,a.ra)}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({S2:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$AnyOtherTransformer$&quot;,{S2:1,d:1,ah:1});var bt=void 0;function Ls(){}Ls.prototype=new l;Ls.prototype.constructor=Ls;c=Ls.prototype;c.b=function(){return this};
c.vh=function(a){return Gb(this,a)};c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Mt(d)&amp;&amp;(r(),d=(new J).j(b),null!==d.U&amp;&amp;0===d.U.Rb(1)&amp;&amp;(d=d.U.W(0),xb(d)&amp;&amp;(b=vi().Yd(d),!b.z()&amp;&amp;(d=b.Y().gb,b=b.Y().Fb,$P(d))))))return d=(new bQ).b(),(new Kb).Qf(d,b,a.ra)}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({T2:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$CountOtherTransformer$&quot;,{T2:1,d:1,ah:1});var Ks=void 0;function Rs(){}Rs.prototype=new l;
Rs.prototype.constructor=Rs;c=Rs.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Cr(d)&amp;&amp;(r(),b=(new J).j(b),null!==b.U&amp;&amp;0===b.U.Rb(2)&amp;&amp;(b=b.U.W(1),yb(b)&amp;&amp;b.fe.Zf.z())))return d=(new cQ).c(d.ja),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({U2:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$CroFastTransformer$&quot;,{U2:1,d:1,ah:1});var Qs=void 0;
function Ps(){}Ps.prototype=new l;Ps.prototype.constructor=Ps;c=Ps.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Br(d)&amp;&amp;(r(),b=(new J).j(b),null!==b.U&amp;&amp;0===b.U.Rb(2)&amp;&amp;(b=b.U.W(1),yb(b)&amp;&amp;b.fe.Zf.z())))return d=(new dQ).c(d.ja),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};
c.$classData=g({V2:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$CrtFastTransformer$&quot;,{V2:1,d:1,ah:1});var Os=void 0;function Hs(){}Hs.prototype=new l;Hs.prototype.constructor=Hs;c=Hs.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(eQ(d)&amp;&amp;(r(),d=(new J).j(b),null!==d.U&amp;&amp;0===d.U.Rb(1)&amp;&amp;(d=d.U.W(0),xb(d)&amp;&amp;(d=vi().Yd(d),!d.z()&amp;&amp;(d=d.Y().gb,Do(d)&amp;&amp;sn(tn(),d.X,1))))))return d=(new fQ).b(),b=I(r(),y()),(new Hb).cj(d,b,a.ra)}return Gb(this,a)};
c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({W2:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$Fd1Transformer$&quot;,{W2:1,d:1,ah:1});var Gs=void 0;function Js(){}Js.prototype=new l;Js.prototype.constructor=Js;c=Js.prototype;c.b=function(){return this};
c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(eQ(d)&amp;&amp;(r(),d=(new J).j(b),null!==d.U&amp;&amp;0===d.U.Rb(1)&amp;&amp;(d=d.U.W(0),xb(d)&amp;&amp;(d=vi().Yd(d),!d.z()&amp;&amp;(d=d.Y().gb,Do(d)&amp;&amp;(d=d.X,&quot;number&quot;===typeof d&amp;&amp;-1&lt;+d&amp;&amp;1&gt;+d))))))return d=(new gQ).b(),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({X2:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$FdLessThan1Transformer$&quot;,{X2:1,d:1,ah:1});var Is=void 0;
function Ts(){}Ts.prototype=new l;Ts.prototype.constructor=Ts;c=Ts.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Gr(d)&amp;&amp;(r(),b=(new J).j(b),null!==b.U&amp;&amp;0===b.U.Rb(2)&amp;&amp;(b=b.U.W(1),yb(b)&amp;&amp;b.fe.Zf.z())))return d=(new hQ).c(d.ja),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};
c.$classData=g({Y2:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$HatchFastTransformer$&quot;,{Y2:1,d:1,ah:1});var Ss=void 0;function iQ(){}iQ.prototype=new l;iQ.prototype.constructor=iQ;function jQ(){}jQ.prototype=iQ.prototype;iQ.prototype.vh=function(a){return Gb(this,a)};iQ.prototype.$g=function(a){return Lb(this,a)};function at(){}at.prototype=new l;at.prototype.constructor=at;c=at.prototype;c.b=function(){return this};c.vh=function(a){return Gb(this,a)};
c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().Fb;if(kQ(b.Y().gb)&amp;&amp;(r(),b=(new J).j(d),null!==b.U&amp;&amp;0===b.U.Rb(1)&amp;&amp;(b=b.U.W(0),xb(b)&amp;&amp;(d=vi().Yd(b),!d.z()&amp;&amp;(b=d.Y().Fb,Qt(d.Y().gb))))))return d=(new lQ).b(),(new Kb).Qf(d,b,a.ra)}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({b3:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$OneOfWithTransformer$&quot;,{b3:1,d:1,ah:1});var $s=void 0;function gt(){}gt.prototype=new l;gt.prototype.constructor=gt;c=gt.prototype;c.b=function(){return this};
c.vh=function(a){return Gb(this,a)};c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().Fb;if($P(b.Y().gb)&amp;&amp;(r(),b=(new J).j(d),null!==b.U&amp;&amp;0===b.U.Rb(1)&amp;&amp;(b=b.U.W(0),xb(b)&amp;&amp;(d=vi().Yd(b),!d.z()&amp;&amp;(b=d.Y().Fb,Qt(d.Y().gb))))))return d=(new mQ).b(),(new Kb).Qf(d,b,a.ra)}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({c3:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$OtherWithTransformer$&quot;,{c3:1,d:1,ah:1});var ft=void 0;function Vs(){}Vs.prototype=new l;
Vs.prototype.constructor=Vs;c=Vs.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Dr(d)&amp;&amp;(r(),b=(new J).j(b),null!==b.U&amp;&amp;0===b.U.Rb(2)&amp;&amp;(b=b.U.W(1),yb(b)&amp;&amp;b.fe.Zf.z())))return d=(new nQ).c(d.ja),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({d3:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$SproutFastTransformer$&quot;,{d3:1,d:1,ah:1});var Us=void 0;
function et(){}et.prototype=new l;et.prototype.constructor=et;c=et.prototype;c.b=function(){return this};c.vh=function(a){return Gb(this,a)};c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().Fb;if(Qt(b.Y().gb)&amp;&amp;(r(),b=(new J).j(d),null!==b.U&amp;&amp;0===b.U.Rb(2)&amp;&amp;(d=b.U.W(0),b=b.U.W(1),xb(d)))){var e=vi().Yd(d);if(!e.z()&amp;&amp;(d=e.Y().Fb,$P(e.Y().gb))){var e=(new mQ).b(),f=r(),b=d.mc(b,f.s);return(new Kb).Qf(e,b,a.ra)}}}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};
c.$classData=g({e3:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$WithOtherTransformer$&quot;,{e3:1,d:1,ah:1});var dt=void 0;function Ns(){this.a=this.TV=this.SV=0}Ns.prototype=new l;Ns.prototype.constructor=Ns;function fma(a){var b=vi().Yd(a);if(!b.z()&amp;&amp;(b=b.Y().gb,Do(b)))return!0;b=vi().Yd(a);if(!b.z()&amp;&amp;(b=b.Y().gb,oQ(b)))return!0;a=vi().Yd(a);return!a.z()&amp;&amp;(a=a.Y().gb,qr(a))?!0:!1}c=Ns.prototype;
c.b=function(){Ms=this;var a=DF(pQ(qQ())),a=Ic(a),b=B().s,a=L(a,b);this.SV=rQ(a,&quot;PXCOR&quot;,0);this.a=(1|this.a)&lt;&lt;24&gt;&gt;24;a=DF(pQ(qQ()));a=Ic(a);b=B().s;a=L(a,b);this.TV=rQ(a,&quot;PYCOR&quot;,0);this.a=(2|this.a)&lt;&lt;24&gt;&gt;24;return this};c.vh=function(a){return Gb(this,a)};
c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Qt(d)&amp;&amp;(r(),d=(new J).j(b),null!==d.U&amp;&amp;0===d.U.Rb(2)&amp;&amp;(b=d.U.W(0),d=d.U.W(1),xb(b)&amp;&amp;(b=vi().Yd(b),!b.z()&amp;&amp;(b=b.Y().gb,sQ(b)&amp;&amp;zb(d)&amp;&amp;(d=xi(zi(),d),!d.z()&amp;&amp;(d=d.Y().la(),kt||(kt=(new it).b()),d=kt.Yd(d),!d.z()))))))){b=d.Y().la();d=d.Y().pa();b=b.Pd;if(0===(1&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Optimizer.scala: 230&quot;);if(this.SV===b&amp;&amp;fma(d))b=(new tQ).b(),d=
I(r(),(new w).f([d])),a=(new Kb).Qf(b,d,a.ra);else{if(0===(2&amp;this.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Optimizer.scala: 231&quot;);this.TV===b&amp;&amp;fma(d)?(b=(new uQ).b(),d=I(r(),(new w).f([d])),a=(new Kb).Qf(b,d,a.ra)):a=Jb(this,a)}return a}}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({f3:0},!1,&quot;org.nlogo.tortoise.compiler.Optimizer$WithTransformer$&quot;,{f3:1,d:1,ah:1});var Ms=void 0;function vQ(){this.ga=null}
vQ.prototype=new l;vQ.prototype.constructor=vQ;vQ.prototype.PF=function(a){a=Oaa(a,&quot;get&quot;);if(a.z())return F();a=a.Y();a:{if(null!==a){var b=a.la(),d=a.pa();if(null!==b&amp;&amp;null!==d){a=u((new v).K((new w).f([&quot;&quot;,&quot;(&quot;,&quot;)&quot;])),(new w).f([b,ed(fd(),d)]));break a}}throw(new q).j(a);}return(new J).j(a)};vQ.prototype.vD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};vQ.prototype.$classData=g({p3:0},!1,&quot;org.nlogo.tortoise.compiler.PrimUtils$VariableReporter$&quot;,{p3:1,d:1,n3:1});
function rr(){this.ga=null}rr.prototype=new l;rr.prototype.constructor=rr;rr.prototype.PF=function(a){a=Oaa(a,&quot;set&quot;);if(a.z())return F();a=a.Y();a:{if(null!==a){var b=a.la(),d=a.pa();if(null!==b&amp;&amp;null!==d){a=m(new n,function(a,b,d){return function(a){return u((new v).K((new w).f([&quot;&quot;,&quot;(&quot;,&quot;, &quot;,&quot;);&quot;])),(new w).f([b,ed(fd(),d),a]))}}(this,b,d));break a}}throw(new q).j(a);}return(new J).j(a)};rr.prototype.vD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};
rr.prototype.$classData=g({q3:0},!1,&quot;org.nlogo.tortoise.compiler.PrimUtils$VariableSetter$&quot;,{q3:1,d:1,n3:1});
function wQ(a){var b=(new Tu).c(a.Mv()),b=(new A).e(&quot;type&quot;,b),d,e=a.Ph.yb;d=e.xq;var f=e.Sp,h=e.Fp,e=e.Cp/255;d=(new Tu).c(u((new v).K((new w).f([&quot;rgba(&quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;)&quot;])),(new w).f([d,f,h,e])));d=(new A).e(&quot;color&quot;,d);f=(new Uu).td(a.Ph.$k());f=(new A).e(&quot;filled&quot;,f);a=(new Uu).td(a.Ph.gc);a=[b,d,f,(new A).e(&quot;marked&quot;,a)];b=dc(new ec,Yu());d=0;for(f=a.length|0;d&lt;f;)hc(b,a[d]),d=1+d|0;return(new Mu).$b(b.Ma)}function xQ(){this.Ky=this.Ly=this.My=this.Jy=this.Hy=this.Iy=this.Xw=null}
xQ.prototype=new l;xQ.prototype.constructor=xQ;xQ.prototype.b=function(){return this};function yQ(){var a=Tq();null===Tq().Xw&amp;&amp;null===Tq().Xw&amp;&amp;(Tq().Xw=(new zQ).Pj(a));return Tq().Xw}function mq(){var a=Tq();null===Tq().Ly&amp;&amp;null===Tq().Ly&amp;&amp;(Tq().Ly=(new AQ).Pj(a));return Tq().Ly}function BQ(){var a=Tq();null===Tq().Iy&amp;&amp;null===Tq().Iy&amp;&amp;(Tq().Iy=(new CQ).Pj(a));return Tq().Iy}function DQ(){var a=Tq();null===Tq().Hy&amp;&amp;null===Tq().Hy&amp;&amp;(Tq().Hy=(new EQ).Pj(a));return Tq().Hy}
function Rea(){var a=Tq();null===Tq().Ky&amp;&amp;null===Tq().Ky&amp;&amp;(Tq().Ky=(new FQ).Pj(a));return Tq().Ky}function GQ(a,b,d,e){return e.Cc(d,b.Pg.dc(d))}function Sq(a){null===Tq().Jy&amp;&amp;null===Tq().Jy&amp;&amp;(Tq().Jy=(new HQ).Pj(a));return Tq().Jy}xQ.prototype.$classData=g({k4:0},!1,&quot;org.nlogo.tortoise.compiler.json.JsonReader$&quot;,{k4:1,d:1,fja:1});var IQ=void 0;function Tq(){IQ||(IQ=(new xQ).b());return IQ}
function JQ(a,b){a=a.Oy().y(b);if(nq(a))return(new sq).j((new J).j(a.ha));if(pq(a))return a;throw(new q).j(a);}function KQ(a,b){b.z()?a=F():(b=b.Y(),a=(new J).j(JQ(a,b)));return a.z()?(Pq(),a=F(),Vq().y(a)):a.Y()}function LQ(){this.Ww=this.hx=this.Cx=this.zy=null}LQ.prototype=new l;LQ.prototype.constructor=LQ;LQ.prototype.b=function(){return this};function MQ(){var a=NQ();null===NQ().Ww&amp;&amp;null===NQ().Ww&amp;&amp;(NQ().Ww=(new OQ).eq(a));return NQ().Ww}
function PQ(){var a=NQ();null===NQ().hx&amp;&amp;null===NQ().hx&amp;&amp;(NQ().hx=(new QQ).eq(a));return NQ().hx}function RQ(){var a=NQ();null===NQ().zy&amp;&amp;null===NQ().zy&amp;&amp;(NQ().zy=(new SQ).eq(a));return NQ().zy}function TQ(){var a=NQ();null===NQ().Cx&amp;&amp;null===NQ().Cx&amp;&amp;(NQ().Cx=(new UQ).eq(a));return NQ().Cx}LQ.prototype.$classData=g({p4:0},!1,&quot;org.nlogo.tortoise.compiler.json.JsonWriter$&quot;,{p4:1,d:1,gja:1});var VQ=void 0;function NQ(){VQ||(VQ=(new LQ).b());return VQ}function WQ(){this.AT=this.pY=null}WQ.prototype=new l;
WQ.prototype.constructor=WQ;function Cq(a,b){var d=new WQ;d.pY=a;d.AT=b;return d}WQ.prototype.Ye=function(){return this.AT.rc(this.pY)};WQ.prototype.$classData=g({q4:0},!1,&quot;org.nlogo.tortoise.compiler.json.JsonWriter$$anon$1&quot;,{q4:1,d:1,Gl:1});function XQ(){this.tY=null;this.a=!1}XQ.prototype=new l;XQ.prototype.constructor=XQ;
function gma(a){var b=new XQ,d=(new Su).tk(a.WF()),d=(new A).e(&quot;x-offset&quot;,d),e=(new Uu).td(a.XD()),e=(new A).e(&quot;is-visible&quot;,e);a=a.BC();var f=m(new n,function(){return function(a){return(new Su).tk(+a)}}(b)),h=r();a=(new Vu).K(a.xa(f,h.s));d=[d,e,(new A).e(&quot;dash-pattern&quot;,a)];e=dc(new ec,Yu());a=0;for(f=d.length|0;a&lt;f;)hc(e,d[a]),a=1+a|0;b.tY=(new Mu).$b(e.Ma);b.a=!0;return b}
XQ.prototype.Ye=function(){if(!this.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/ShapeToJsonConverters.scala: 36&quot;);return this.tY};XQ.prototype.$classData=g({I4:0},!1,&quot;org.nlogo.tortoise.compiler.json.ShapeToJsonConverters$$anon$3&quot;,{I4:1,d:1,Gl:1});function JP(){this.NY=null}JP.prototype=new l;JP.prototype.constructor=JP;
JP.prototype.Ye=function(){var a=this.NY;if(ou(a)){var b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new YQ).eg(this))}return ZQ(a)}if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.tz){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new $Q).eg(this))}return aR(a)}if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.vz){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new bR).eg(this))}return cR(a)}if(qu(a)){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,
(new dR).eg(this))}return eR(a)}if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.xz){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new fR).eg(this))}return gR(a)}if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.yz)return b=(new Ne).b(),(b.La?b.hb:hma(this,b)).dh(a);if(iu(a)){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new hR).eg(this))}return iR(a)}if(ru(a)){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new jR).eg(this))}return kR(a)}if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.Ez){b=
(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new lR).eg(this))}return mR(a)}if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.Fz){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new nR).eg(this))}return oR(a)}if(!pR(a))throw(new q).j(a);b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new qR).eg(this))}return rR(a)};function hma(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,(new sR).eg(a))}
JP.prototype.$classData=g({r5:0},!1,&quot;org.nlogo.tortoise.compiler.json.WidgetToJson$$anon$1&quot;,{r5:1,d:1,Gl:1});function tR(a,b){if(b.z())return F();b=b.Y();b=(new J).j(b);return(new J).j(a.vt(b))}function uR(){this.KS=null}uR.prototype=new l;uR.prototype.constructor=uR;uR.prototype.b=function(){vR=this;this.KS=wR(ba);return this};function ima(a,b){return!!b.Gb(!0,tb(new ub,function(){return function(a,b){return!!a&amp;&amp;!!b}}(a)))}
function jma(a,b,d){d=m(new n,function(a,b){return function(d){d=kma(a,d,b);var e=m(new n,function(){return function(a){return null!==a}}(a)),t=KB();return d.VC(e,t).bl(m(new n,function(a,b){return function(d){if(null!==d){var e=!!d.la();d=d.pa();return jma(a,Yt($e(),d),b).Ih(m(new n,function(a,b){return function(a){return b&amp;&amp;!!a}}(a,e)),KB())}throw(new q).j(d);}}(a,b)),KB())}}(a,d));var e=r();b=b.xa(d,e.s);d=xA();e=r();return QB(d,b,e.s,KB()).Ih(m(new n,function(a){return function(b){return ima(a,
b)}}(a)),KB())}
function lma(a,b,d,e){for(var f=y(),h=wn(f),h=la(Xa(qa),[h]),k=0,k=0,f=Cv(f);f.ta();){var p=f.ma();h.l[k]=p;k=1+k|0}p=y();k=wn(p);k=la(Xa(qa),[k]);f=f=0;for(p=Cv(p);p.ta();){var t=p.ma();k.l[f]=t;f=1+f|0}h=mma(b,h,a.KS);d=nma(h,d.se((new Qn).xg(pa(xR))));return jma(a,Yt($e(),d),e).Ih(m(new n,function(a,b,d,e){return function(a){a=!!a;var b=e.fx(),f=(new Sb).c(b);kd(f)&amp;&amp;(f=d.yn,b=u((new v).K((new w).f([&quot;&quot;,&quot; reported &quot;,&quot;&quot;])),(new w).f([&quot;utest&quot;,b])),Yv(f.Eg,b,Xv(a)));return a}}(a,b,e,h)),KB())}
function oma(a){for(var b=(new Sb).c(ba.document.location.search),d=pma(b),e=!1,b=null,d=QE(Ia(),d,&quot;\x26&quot;),f=null,f=[],h=0,k=d.l.length;h&lt;k;){var p=ba.decodeURIComponent(d.l[h]);f.push(null===p?null:p);h=1+h|0}d=ka(Xa(qa),f);f=B().s.Uh();h=d.l.length;switch(h){case -1:break;default:f.tc(h)}f.Yb((new Fi).Gh(d));d=f.Da();a:{if(Gi(d)&amp;&amp;(e=!0,b=d,d=b.Ia,&quot;i&quot;===b.Bb&amp;&amp;Gi(d))){b=d.Bb;e=d.Ia;d=$l();d=cm(d);e=L(e,d);e=m(new n,function(a,b){return function(a){return b.ib(a.ik)}}(a,e));b=(new Sb).c(b);d=Hi();
d=(new J).j(Ji(d,b.R,10));b=e;e=d;break a}if(e&amp;&amp;(e=b.Ia,&quot;e&quot;===b.Bb)){b=$l();b=cm(b);b=L(e,b);b=m(new n,function(a,b){return function(a){return!b.ib(a.ik)}}(a,b));e=F();break a}b=m(new n,function(){return function(){return!0}}(a));e=F()}d=e;f=tha();e=m(new n,function(){return function(a){return a.pa().Ga()}}(a));h=r();e=f.xa(e,h.s).$f(cw())|0;h=m(new n,function(a,b){return function(a){return a.pa().vf(b)}}(a,b));k=r();h=f.aj(h,k.s);e=pha(h,e);(d.z()?0:(d.Y()|0)!==qma(a,h))&amp;&amp;lha(e);d=f.Vn(m(new n,function(){return function(a){return null!==
a}}(a)));b=m(new n,function(a,b,d){return function(e){if(null!==e)return lma(a,e.la(),e.pa().al(b,!1),d);throw(new q).j(e);}}(a,b,e));f=r();b=d.xa(b,f.s);d=xA();f=r();QB(d,b,f.s,KB()).Ih(m(new n,function(a){return function(b){return ima(a,b)}}(a)),KB()).ap(m(new n,function(a,b){return function(a){b.HC(a)}}(a,e)),KB())}function qma(a,b){V();a=m(new n,function(){return function(a){return a.ik}}(a));var d=r();return hD(0,b.xa(a,d.s).ed())}
function kma(a,b,d){d=nha(d,b.Dv.ik);var e=(new yR).b(),f=(new zR).b();b=wA(xA(),K(function(a,b,d,e,f){return function(){for(var E=(new w).f([d.Lx]),S=E.oa.length|0,S=la(Xa(Raa),[S]),U=0,U=0,E=lf(new mf,E,0,E.oa.length|0);E.ta();){var ga=E.ma();S.l[U]=ga;U=1+U|0}rma(b,e,S,m(new n,function(a,b){return function(a){a=(new CA).j(a);xe(b,a)}}(a,f)))}}(a,b,d,e,f)),(new IE).b()).bl(m(new n,function(a,b,d){return function(){return d.Ih(m(new n,function(a,b){return function(a){return(new A).e(!b.cw,a)}}(a,
b)),KB())}}(a,e,f)),KB());b.Ih(m(new n,function(){return function(a){return!!a.la()}}(a)),KB()).ap(m(new n,function(a,b){return function(a){b.HC(a)}}(a,d)),KB());return b.Es((new AR).b(),KB())}uR.prototype.main=function(){oma(this)};uR.prototype.$classData=g({g6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$&quot;,{g6:1,d:1,lpa:1});var vR=void 0;function yR(){this.cw=!1}yR.prototype=new l;yR.prototype.constructor=yR;yR.prototype.b=function(){this.cw=!1;return this};
yR.prototype.VT=function(a){a=a.zF;this.cw=this.cw?!0:Vv().xV.ib(a);Vv().Lt.Ts(a,1+(Vv().Lt.y(a)|0)|0)};yR.prototype.$classData=g({j6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$EventCounter$Handler&quot;,{j6:1,d:1,h7:1});function BR(){this.ga=this.zV=this.vq=null}BR.prototype=new l;BR.prototype.constructor=BR;BR.prototype.tv=function(a){this.vq.tv(a)};
function qha(a){var b=new BR;if(null===a)throw Kg(Lg(),null);b.ga=a;var d=a.uE.Ga();b.vq=(new hw).mu(a,u((new v).K((new w).f([&quot;Excluded Test Suites (&quot;,&quot;)&quot;])),(new w).f([d])));b.zV=oha(a,a.Su,b.vq.Wh);b.vq.Wh.checked=!1;b.vq.Wh.onclick=mha(a,a.Su,b.vq.Wh);a.uE.wa(m(new n,function(a){return function(b){return a.ga.Su.uj(sma(a,b.ik))}}(b)));return b}BR.prototype.$classData=g({l6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$UI$ExcludedTestBox&quot;,{l6:1,d:1,KQ:1});
function CR(){this.ga=this.Wh=this.lE=this.Ss=null}CR.prototype=new l;CR.prototype.constructor=CR;CR.prototype.FT=function(){return!1};CR.prototype.ZX=function(a){this.Wh.checked=a};CR.prototype.sy=function(){return!!this.Wh.checked};function sma(a,b){var d=new CR;d.Ss=b;if(null===a)throw Kg(Lg(),null);d.ga=a;d.lE=Yv(a.vq,&quot;&quot;,&quot;info&quot;);d.Wh=rha($v(),d.lE,!1);d.Wh.onclick=a.zV;Zv($v(),d.lE,&quot; &quot;+b);return d}
CR.prototype.$classData=g({m6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$UI$ExcludedTestBox$ExcludedTest&quot;,{m6:1,d:1,q6:1});function gw(){this.ga=this.CY=this.AC=this.Eg=null}gw.prototype=new l;gw.prototype.constructor=gw;gw.prototype.tv=function(a){this.Eg.tv(a)};
function tma(a,b){var d=a.ga.Tu,e=a.ga.Su,f=Ec().s,d=au(d,e,f).Bi(b);if(null===d)throw(new q).j(d);b=d.la();d=d.pa();b.Ga()&lt;d.Ga()?(V(),e=m(new n,function(){return function(a){return a.Ss}}(a)),f=Ec().s,d=&quot;&quot;+hD(0,Wr(d,e,f).ed()),d=I(r(),(new w).f([&quot;i&quot;,d])),e=m(new n,function(){return function(a){return a.Ss}}(a)),f=Ec().s,b=Wr(b,e,f),e=r(),b=d.Rc(b,e.s)):(b=m(new n,function(){return function(a){return a.Ss}}(a)),e=Ec().s,b=Wr(d,b,e),d=Ec(),b=b.fd(&quot;e&quot;,d.s));a=m(new n,function(){return function(a){return ba.encodeURIComponent(a)}}(a));
d=r();return b.xa(a,d.s).Oc(&quot;?&quot;,&quot;\x26&quot;,&quot;&quot;)}gw.prototype.gx=function(a){this.Eg.gx(a);this.AC.className=&quot;log &quot;+Xv(a);var b=Yv(this.Eg,&quot;Next: &quot;,Xv(a));a||(aw($v(),b,tma(this,m(new n,function(){return function(a){return a.FT()}}(this))),&quot;Run failed&quot;),Zv($v(),b,&quot; | &quot;));aw($v(),b,&quot;#&quot;,&quot;Run selected&quot;).onclick=function(a){return function(){return uma(a)}}(this);Zv($v(),b,&quot; | &quot;);aw($v(),b,&quot;?&quot;,&quot;Run all&quot;)};
function uma(a){ba.document.location.search=tma(a,m(new n,function(){return function(a){return a.sy()}}(a)));return!1}gw.prototype.$classData=g({n6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$UI$RootBox&quot;,{n6:1,d:1,KQ:1});function DR(){this.ga=null}DR.prototype=new l;DR.prototype.constructor=DR;DR.prototype.OC=function(a){Yv(this.ga.ml,a,&quot;error&quot;);iw(this.ga.ml)};DR.prototype.MF=function(a){this.OC(a.k())};DR.prototype.lD=function(a){Yv(this.ga.ml,a,&quot;info&quot;)};
DR.prototype.$classData=g({p6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$UI$RunningTest$$anon$1&quot;,{p6:1,d:1,yB:1});function hw(){this.rg=this.Wh=this.fD=this.RC=this.fs=this.Eg=null;this.Vr=!1;this.ga=null}hw.prototype=new l;hw.prototype.constructor=hw;hw.prototype.tv=function(a){this.Eg.insertAdjacentElement(&quot;afterend&quot;,a.Eg)};function vma(a){a.Vr=!a.Vr;a.RC.textContent=a.Vr?&quot;[-]&quot;:&quot;[+]&quot;;a.rg.style.display=a.Vr?&quot;block&quot;:&quot;none&quot;}function iw(a){a.Vr||vma(a)}
hw.prototype.gx=function(a){this.fs.className=this.fs.className+&quot; &quot;+Xv(a);this.fD.textContent+=a?&quot; - Passed&quot;:&quot; - Failed&quot;};
hw.prototype.mu=function(a,b){if(null===a)throw Kg(Lg(),null);this.ga=a;a=a.yV;a=this.Eg=fw($v(),a,&quot;test-box&quot;,&quot;&quot;,&quot;div&quot;);this.fs=fw($v(),a,&quot;test-box-header&quot;,&quot;&quot;,&quot;div&quot;);this.RC=aw($v(),this.fs,&quot;#&quot;,&quot;[+]&quot;);this.RC.onclick=function(a){return function(){vma(a);return!1}}(this);this.fD=Zv($v(),this.fs,&quot; &quot;+b);this.Wh=rha($v(),this.fs,!0);b=this.Eg;this.rg=fw($v(),b,&quot;test-box-body&quot;,&quot;&quot;,&quot;div&quot;);this.Vr=!1;return this};
function Yv(a,b,d){return fw($v(),a.rg,u((new v).K((new w).f([&quot;log &quot;,&quot;&quot;])),(new w).f([d])),b,&quot;pre&quot;)}hw.prototype.$classData=g({r6:0},!1,&quot;org.scalajs.testinterface.HTMLRunner$UI$TestBox&quot;,{r6:1,d:1,KQ:1});function ER(){this.jV=null}ER.prototype=new nja;ER.prototype.constructor=ER;function wR(a){var b=new ER;b.jV=a;return b}ER.prototype.$classData=g({LQ:0},!1,&quot;org.scalajs.testinterface.ScalaJSClassLoader&quot;,{LQ:1,coa:1,d:1});function FR(){this.Xj=this.cu=null}FR.prototype=new ww;
FR.prototype.constructor=FR;c=FR.prototype;c.Hx=function(a){return ba.JSON.parse(Ee(a))};
c.UT=function(a,b){if(&quot;newRunner&quot;===a){var d;a:{var e=this.Hx(b),f=e.args,h=f.length|0,h=la(Xa(qa),[h]);a=h.l.length;var k=0,p=0;b=f.length|0;a=b&lt;a?b:a;b=h.l.length;for(a=a&lt;b?a:b;k&lt;a;)h.l[p]=f[k],k=1+k|0,p=1+p|0;e=e.remoteArgs;f=e.length|0;f=la(Xa(qa),[f]);a=f.l.length;p=k=0;b=e.length|0;a=b&lt;a?b:a;b=f.l.length;for(a=a&lt;b?a:b;k&lt;a;)f.l[p]=e[k],k=1+k|0,p=1+p|0;e=wR(aa.exportsNamespace);try{this.Xj=mma(this.cu,h,e),d=(new CA).j(void 0)}catch(x){d=ko(Lg(),x);if(null!==d){h=Fw(Gw(),d);if(!h.z()){d=h.Y();
d=(new BA).ud(d);break a}throw Kg(Lg(),d);}throw x;}}yw(d)}else if(&quot;runnerDone&quot;===a){this.Kp();try{var t=(new CA).j(this.Xj.fx())}catch(x){if(d=ko(Lg(),x),null!==d){h=Fw(Gw(),d);if(h.z())throw Kg(Lg(),d);d=h.Y();t=(new BA).ud(d)}else throw x;}this.Xj=null;yw(t)}else if(&quot;tasks&quot;===a){a:{f=this.Hx(b);this.Kp();d=[];k=0;for(p=f.length|0;k&lt;p;)a=f[k],a=qw(rw(),a),d.push(a),k=1+k|0;f=d.length|0;f=la(Xa(xR),[f]);a=f.l.length;p=k=0;b=d.length|0;a=b&lt;a?b:a;b=f.l.length;for(a=a&lt;b?a:b;k&lt;a;)f.l[p]=d[k],k=1+k|0,
p=1+p|0;try{e=nma(this.Xj,f),h=(new CA).j(ba.JSON.stringify(Bha(e)))}catch(x){d=ko(Lg(),x);if(null!==d){h=Fw(Gw(),d);if(!h.z()){d=h.Y();h=(new BA).ud(d);break a}throw Kg(Lg(),d);}throw x;}}yw(h)}else if(&quot;msg&quot;===a){a:{d=Ee(b);this.Kp();try{k=this.Xj.zE(d),p=k.z()?&quot;:n&quot;:&quot;:s:&quot;+k.Y(),f=(new CA).j(p)}catch(x){d=ko(Lg(),x);if(null!==d){h=Fw(Gw(),d);if(!h.z()){d=h.Y();f=(new BA).ud(d);break a}throw Kg(Lg(),d);}throw x;}}yw(f)}else throw(new df).c(u((new v).K((new w).f([&quot;Unknown command: &quot;,&quot;&quot;])),(new w).f([a])));
};c.Kp=function(){if(null===this.Xj)throw(new ye).c(&quot;No runner created&quot;);};c.c=function(a){vw.prototype.c.call(this,a);return this};c.$classData=g({D6:0},!1,&quot;org.scalajs.testinterface.internal.Master&quot;,{D6:1,w6:1,d:1});function GR(){this.ZV=this.BS=this.cu=null;this.Dt=!1;this.Xj=this.Px=null}GR.prototype=new ww;GR.prototype.constructor=GR;c=GR.prototype;c.Hx=function(a){return ba.JSON.parse(Ee(a))};
c.UT=function(a,b){try{for(this.Dt=!0;!this.Px.z();){var d=this.Px;if(d.z())throw(new Xu).c(&quot;queue empty&quot;);var e=d.cg.Zi;d.cg=d.cg.hi;var f=d;f.gi=-1+f.gi|0;0===f.gi&amp;&amp;(f.Tj=f.cg);wma(this,e)}if(&quot;newRunner&quot;===a)yw(xma(this));else if(&quot;execute&quot;===a)yma(this,this.Hx(b));else if(&quot;stopSlave&quot;===a){this.Kp();try{var h=(new CA).j((this.Xj.fx(),void 0))}catch(ma){var k=ko(Lg(),ma);if(null!==k){var p=Fw(Gw(),k);if(p.z())throw Kg(Lg(),k);var t=p.Y(),h=(new BA).ud(t)}else throw ma;}this.Xj=null;yw(h)}else if(&quot;msg&quot;===
a){var x;a:{var E=Ee(b);this.Kp();try{x=(new CA).j((this.Xj.zE(E),void 0))}catch(ma){var S=ko(Lg(),ma);if(null!==S){var U=Fw(Gw(),S);if(!U.z()){var ga=U.Y();x=(new BA).ud(ga);break a}throw Kg(Lg(),S);}throw ma;}}x.TD()&amp;&amp;yw(x)}else throw(new df).c(u((new v).K((new w).f([&quot;Unknown command: &quot;,&quot;&quot;])),(new w).f([a])));}finally{this.Dt=!1}};function wma(a,b){Nn($e(),a.Dt);ba.scalajsCom.send(u((new v).K((new w).f([&quot;msg:&quot;,&quot;&quot;])),(new w).f([b])))}
function xma(a){var b=wR(aa.exportsNamespace);try{for(var d=a.cu,e=a.BS,f=e.length|0,h=la(Xa(qa),[f]),k=h.l.length,p=f=0,t=e.length|0,k=t&lt;k?t:k,x=h.l.length,x=k&lt;x?k:x;f&lt;x;)h.l[p]=e[f],f=1+f|0,p=1+p|0;for(var E=a.ZV,S=E.length|0,U=la(Xa(qa),[S]),ga=U.l.length,S=e=0,ma=E.length|0,ga=ma&lt;ga?ma:ga,va=U.l.length,va=ga&lt;va?ga:va;e&lt;va;)U.l[S]=E[e],e=1+e|0,S=1+S|0;a.Xj=zma(d,h,b,m(new n,function(a){return function(b){if(a.Dt)wma(a,b);else{var d=a.Px;b=[b];for(var e=0,f=b.length|0;e&lt;f;)HR(d,b[e]),e=1+e|0}}}(a)));
return(new CA).j(void 0)}catch(Fa){a=ko(Lg(),Fa);if(null!==a){b=Fw(Gw(),a);if(!b.z())return a=b.Y(),(new BA).ud(a);throw Kg(Lg(),a);}throw Fa;}}c.Kp=function(){if(null===this.Xj)throw(new ye).c(&quot;No runner created&quot;);};c.oba=function(a,b,d){this.BS=b;this.ZV=d;vw.prototype.c.call(this,a);this.Dt=!1;this.Px=IR().bb().Da();return this};
function yma(a,b){a.Kp();var d=b.serializedTask,d=Ama(a.Xj,qw(rw(),ba.JSON.parse(d))),e=(new JR).yx(a);b=b.loggerColorSupport;for(var f=[],h=b.length|0,k=0;k&lt;h;){var p=(new A).e(b[k],k);f.push(p);k=1+k|0}b=Xb(new Yb,(new mw).f(f),m(new n,function(){return function(a){return null!==a}}(a)));f=m(new n,function(a){return function(b){if(null!==b){var d=new KR;d.Qe=b.Dc();Yw.prototype.yx.call(d,a);return d}throw(new q).j(b);}}(a));h=(new mw).b();b.ga.wa(m(new n,function(a,b,d){return function(e){return a.ol.y(e)?
d.Na(b.y(e)):void 0}}(b,f,h)));b=h.Wd;try{for(var t=b.length|0,x=la(Xa(Raa),[t]),E=x.l.length,f=t=0,S=b.length|0,E=S&lt;E?S:E,U=x.l.length,U=E&lt;U?E:U;t&lt;U;)x.l[f]=b[t],t=1+t|0,f=1+f|0;rma(d,e,x,m(new n,function(a,b,d){return function(a){try{var e=(new CA).j(ba.JSON.stringify(Bha(a)))}catch(f){if(e=ko(Lg(),f),null!==e){a=Fw(Gw(),e);if(a.z())throw Kg(Lg(),e);e=a.Y();e=(new BA).ud(e)}else throw f;}b.Uy=!1;a=0;for(var h=d.length|0;a&lt;h;)d[a].Uy=!1,a=1+a|0;yw(e)}}(a,e,b)));var ga=(new CA).j(void 0)}catch(ma){if(a=
ko(Lg(),ma),null!==a){x=Fw(Gw(),a);if(x.z())throw Kg(Lg(),a);a=x.Y();ga=(new BA).ud(a)}else throw ma;}ga.TD()&amp;&amp;yw(ga)}c.$classData=g({F6:0},!1,&quot;org.scalajs.testinterface.internal.Slave&quot;,{F6:1,w6:1,d:1});
function Bma(a){LR();a.iba=(new MR).cn(m(new n,function(){return function(a){if(Gx(a)){a=a.X;var d=Cma();try{var e,f=pc();0===(1&amp;f.ya)&amp;&amp;0===(1&amp;f.ya)&amp;&amp;(f.eG=ux(),f.ya=(1|f.ya)&lt;&lt;24&gt;&gt;24);e=f.eG;var h=(new NR).c(a),k=(new J).j(OR(new PR,QR(new RR,h,e.Hj)))}catch(t){var p=ko(Lg(),t);if(null!==p){if(d.gy.y(p))throw Kg(Lg(),p);if(d.pl.Ua(p))k=d.pl.y(p);else throw Kg(Lg(),p);}else throw t;}finally{e=d.rx,e.z()||e.Y().uba()}return k.z()?ox(lx(),mx(nx(),&quot;error.expected.numberformatexception&quot;)):k.Y()}return Hx(a)?
(k=a.X,e=ux(),OR(new PR,QR(new RR,k.Ec,e.Hj))):ox(lx(),mx(nx(),&quot;error.expected.jsnumberorjsstring&quot;))}}(a)));LR();a.vba=(new MR).cn(m(new n,function(){return function(a){if(Gx(a)){a=a.X;var d=Cma();try{var e=(new J).j(OR(new PR,(new NR).c(a)))}catch(h){var f=ko(Lg(),h);if(null!==f){if(d.gy.y(f))throw Kg(Lg(),f);if(d.pl.Ua(f))e=d.pl.y(f);else throw Kg(Lg(),f);}else throw h;}finally{f=d.rx,f.z()||f.Y().uba()}return e.z()?ox(lx(),mx(nx(),&quot;error.expected.numberformatexception&quot;)):e.Y()}return Hx(a)?OR(new PR,
a.X.Ec):ox(lx(),mx(nx(),&quot;error.expected.jsnumberorjsstring&quot;))}}(a)));a.sia=Dma(a)}function SR(){}SR.prototype=new l;SR.prototype.constructor=SR;SR.prototype.fq=function(){return this};SR.prototype.Ck=function(a){if(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.tB)return a=!!(new J).j(a.X).U,OR(new PR,a);a=r();var b=TR(),d=I(r(),(new w).f([mx(nx(),&quot;error.expected.jsboolean&quot;)]));return(new UR).K(I(a,(new w).f([(new A).e(b,d)])))};
SR.prototype.$classData=g({M6:0},!1,&quot;play.api.libs.json.DefaultReads$BooleanReads$&quot;,{M6:1,d:1,et:1});function VR(){}VR.prototype=new l;VR.prototype.constructor=VR;VR.prototype.fq=function(){return this};VR.prototype.Ck=function(a){var b=!1;return Hx(a)&amp;&amp;(b=!0,a=a.X,a.Eu())?OR(new PR,a.Ec.wi()):b?Ema(&quot;error.expected.int&quot;):Ema(&quot;error.expected.jsnumber&quot;)};VR.prototype.$classData=g({N6:0},!1,&quot;play.api.libs.json.DefaultReads$IntReads$&quot;,{N6:1,d:1,et:1});function WR(){}WR.prototype=new l;
WR.prototype.constructor=WR;WR.prototype.fq=function(){return this};WR.prototype.Ck=function(a){if(Ix(a))return OR(new PR,a);a=r();var b=TR(),d=I(r(),(new w).f([mx(nx(),&quot;error.expected.jsarray&quot;)]));return(new UR).K(I(a,(new w).f([(new A).e(b,d)])))};WR.prototype.$classData=g({O6:0},!1,&quot;play.api.libs.json.DefaultReads$JsArrayReads$&quot;,{O6:1,d:1,et:1});function XR(){}XR.prototype=new l;XR.prototype.constructor=XR;XR.prototype.fq=function(){return this};
XR.prototype.Ck=function(a){if(Gx(a))return OR(new PR,a.X);a=r();var b=TR(),d=I(r(),(new w).f([mx(nx(),&quot;error.expected.jsstring&quot;)]));return(new UR).K(I(a,(new w).f([(new A).e(b,d)])))};XR.prototype.$classData=g({P6:0},!1,&quot;play.api.libs.json.DefaultReads$StringReads$&quot;,{P6:1,d:1,et:1});function YR(){this.IS=!1;this.ga=null}YR.prototype=new l;YR.prototype.constructor=YR;
YR.prototype.Ck=function(a){if(Gx(a)){a=a.X;try{var b=(new CA).j(Fma(Gma(),a))}catch(e){if(b=ko(Lg(),e),null!==b){var d=Fw(Gw(),b);if(d.z())throw Kg(Lg(),b);b=d.Y();b=(new BA).ud(b)}else throw e;}b=b.uY();this.IS?(b.z()?a=!0:(d=b.Y(),a=null!==d&amp;&amp;a===d.k()),a=a?b:F()):a=b;a.z()?a=F():(a=a.Y(),a=(new J).j(OR(new PR,a)));return a.z()?(a=r(),b=TR(),d=I(r(),(new w).f([mx(nx(),&quot;error.expected.uuid&quot;)])),(new UR).K(I(a,(new w).f([(new A).e(b,d)])))):a.Y()}a=r();b=TR();d=I(r(),(new w).f([mx(nx(),&quot;error.expected.uuid&quot;)]));
return(new UR).K(I(a,(new w).f([(new A).e(b,d)])))};function Dma(a){var b=new YR;b.IS=!1;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}YR.prototype.$classData=g({Q6:0},!1,&quot;play.api.libs.json.DefaultReads$UUIDReader&quot;,{Q6:1,d:1,et:1});function MR(){this.$i=null}MR.prototype=new l;MR.prototype.constructor=MR;MR.prototype.Ck=function(a){return this.$i.y(a)};MR.prototype.cn=function(a){this.$i=a;return this};MR.prototype.$classData=g({c7:0},!1,&quot;play.api.libs.json.Reads$$anon$8&quot;,{c7:1,d:1,et:1});
function ZR(){}ZR.prototype=new l;ZR.prototype.constructor=ZR;ZR.prototype.b=function(){return this};ZR.prototype.$classData=g({d7:0},!1,&quot;play.api.libs.json.Reads$JsArrayMonoid$&quot;,{d7:1,d:1,L6:1});var Hma=void 0;function $R(){}$R.prototype=new l;$R.prototype.constructor=$R;$R.prototype.b=function(){return this};$R.prototype.$classData=g({e7:0},!1,&quot;play.api.libs.json.Reads$JsObjectMonoid$&quot;,{e7:1,d:1,L6:1});var Ima=void 0;function ax(){this.rp=this.ik=null;this.hr=!1;this.ir=null}ax.prototype=new l;
ax.prototype.constructor=ax;ax.prototype.o=function(a){return a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.WQ?this.ik===a.ik&amp;&amp;this.rp===a.rp&amp;&amp;this.hr===a.hr?oja(gB(),this.ir,a.ir):!1:!1};ax.prototype.k=function(){var a=this.ik,b=this.rp,d=this.hr,e=this.ir,f=(new Fm).b(),h;h=!0;js(f,&quot;[&quot;);for(var k=0,p=e.l.length;k&lt;p;){var t=e.l[k];h?(ks(f,t),h=!1):(js(f,&quot;, &quot;),ks(f,t));k=1+k|0}js(f,&quot;]&quot;);return&quot;TaskDef(&quot;+a+&quot;, &quot;+b+&quot;, &quot;+d+&quot;, &quot;+f.vc.Zb+&quot;)&quot;};
ax.prototype.r=function(){var a;a=this.ik;a=da(31,17)+Ha(Ia(),a)|0;var b=this.rp;a=da(31,a)+Ka(b)|0;a=da(31,a)+(this.hr?1:0)|0;a=da(31,a);var b=gB(),d=this.ir,b=pja(b);if(null===d)b=0;else{var d=Dw($e(),d),e=d.sa(),f=0,h=1;b:for(;;){if(f!==e){var k=1+f|0,f=d.W(f),h=da(31,h|0)+(null===f?0:b.y(f)|0)|0,f=k;continue b}break}b=h|0}return a+b|0};var xR=g({WQ:0},!1,&quot;sbt.testing.TaskDef&quot;,{WQ:1,d:1,i:1});ax.prototype.$classData=xR;function aS(a){a.jp(Jma(a))}function bS(a){a.sh((new cS).wD(a))}
function Kma(a,b,d,e){return a.$e(d,K(function(a,b,d){return function(){return a.$e(b,K(function(a,b){return function(){return a.Xc(b,m(new n,function(){return function(a){return sb(a)}}(a)))}}(a,d)))}}(a,b,e)))}function dS(){this.ga=null}dS.prototype=new l;dS.prototype.constructor=dS;function Lma(a){var b=new dS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}dS.prototype.$classData=g({A7:0},!1,&quot;scalaz.Associative$$anon$3&quot;,{A7:1,d:1,Qla:1});function eS(){this.ga=null}eS.prototype=new l;
eS.prototype.constructor=eS;function Saa(a){var b=new eS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}eS.prototype.$classData=g({C7:0},!1,&quot;scalaz.Bifoldable$$anon$8&quot;,{C7:1,d:1,raa:1});function fS(){this.ga=null}fS.prototype=new l;fS.prototype.constructor=fS;function Taa(a){var b=new fS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}fS.prototype.$classData=g({D7:0},!1,&quot;scalaz.Bifunctor$$anon$7&quot;,{D7:1,d:1,saa:1});function cA(a){a.mv(Mma(a))}function gS(a){a.rm(Nma(a))}
function hS(){this.ga=null}hS.prototype=new l;hS.prototype.constructor=hS;function Uaa(a){var b=new hS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}hS.prototype.$classData=g({M7:0},!1,&quot;scalaz.Compose$$anon$4&quot;,{M7:1,d:1,yw:1});function iS(){}iS.prototype=new l;iS.prototype.constructor=iS;c=iS.prototype;c.b=function(){Vd(this);return this};c.Md=function(a){return a};c.Xg=function(a){return a.k()};c.Tg=function(){};c.$classData=g({Q7:0},!1,&quot;scalaz.Cord$$anon$2&quot;,{Q7:1,d:1,ch:1});function jS(){}
jS.prototype=new l;jS.prototype.constructor=jS;jS.prototype.b=function(){zd(this);return this};jS.prototype.Vf=function(){};jS.prototype.$classData=g({R7:0},!1,&quot;scalaz.Cord$$anon$3&quot;,{R7:1,d:1,ag:1});function kS(){this.ga=null}kS.prototype=new l;kS.prototype.constructor=kS;function lS(a){var b=new kS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}kS.prototype.$classData=g({S7:0},!1,&quot;scalaz.Cozip$$anon$1&quot;,{S7:1,d:1,Wla:1});function mS(){}mS.prototype=new Vha;mS.prototype.constructor=mS;
function Oma(){}Oma.prototype=mS.prototype;function Qx(){}Qx.prototype=new l;Qx.prototype.constructor=Qx;Qx.prototype.OE=function(){};Qx.prototype.xD=function(){this.OE(Lma(this));return this};Qx.prototype.$classData=g({U7:0},!1,&quot;scalaz.DisjunctionInstances2$$anon$7&quot;,{U7:1,d:1,z7:1});function nS(){}nS.prototype=new Wha;nS.prototype.constructor=nS;function Pma(){}Pma.prototype=nS.prototype;function oS(){}oS.prototype=new Yha;oS.prototype.constructor=oS;function Qma(){}Qma.prototype=oS.prototype;
function pS(a){a.Lh(Rma(a))}function qS(){this.ga=null}qS.prototype=new l;qS.prototype.constructor=qS;function Vaa(a){var b=new qS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}qS.prototype.$classData=g({c8:0},!1,&quot;scalaz.Equal$$anon$4&quot;,{c8:1,d:1,vR:1});function rS(){}rS.prototype=new jia;rS.prototype.constructor=rS;
function ky(a,b,d,e,f){var h=f.Le(f.Le(f.Al(b),d),e);return Sma(new sS,h,K(function(a,b){return function(){return b}}(a,b)),K(function(a,b){return function(){return b}}(a,d)),K(function(a,b){return function(){return b}}(a,e)),f)}rS.prototype.b=function(){return this};function By(a,b,d,e){return tS(new uS,e.Le(e.Al(b),d),b,d,e)}function hy(a,b,d,e){var f=e.Le(e.Al(b),d);return Tma(new vS,f,K(function(a,b){return function(){return b}}(a,b)),K(function(a,b){return function(){return b}}(a,d)),e)}
function Ay(a,b,d){a=new wS;var e=d.Al(b);a.of=e;a.Aa=b;a.Qg=d;a.Ai=e;return a}function Uma(a,b,d){var e=d.Al(b);return yy(new zy,e,K(function(a,b){return function(){return b}}(a,b)),d)}rS.prototype.$classData=g({d8:0},!1,&quot;scalaz.FingerTree$&quot;,{d8:1,Ija:1,d:1});var xS=void 0;function iy(){xS||(xS=(new rS).b());return xS}function sS(){this.sS=this.rS=this.pS=this.GY=this.Ai=null}sS.prototype=new sz;sS.prototype.constructor=sS;sS.prototype.$C=function(a,b){return Rc(b,this.GY,this.pS,this.rS,this.sS)};
function Sma(a,b,d,e,f,h){a.GY=b;a.pS=d;a.rS=e;a.sS=f;rz.prototype.dj.call(a,h);a.Ai=b;return a}sS.prototype.$classData=g({e8:0},!1,&quot;scalaz.FingerTree$$anon$10&quot;,{e8:1,W8:1,d:1});function zy(){this.nS=this.DY=this.ea=null}zy.prototype=new Yx;zy.prototype.constructor=zy;zy.prototype.ih=function(a,b){return rb(b,this.DY,Ee(this.nS))};function yy(a,b,d,e){a.DY=b;a.nS=d;Xx.prototype.dj.call(a,e);return a}zy.prototype.$classData=g({f8:0},!1,&quot;scalaz.FingerTree$$anon$18&quot;,{f8:1,cR:1,d:1});
function ey(){this.$X=this.LV=this.EY=this.hV=this.ea=null}ey.prototype=new Yx;ey.prototype.constructor=ey;function dy(a,b,d,e,f,h){a.EY=b;a.LV=d;a.$X=f;Xx.prototype.dj.call(a,h);xy(iy(),h);a.hV=(Zx(),(new $x).yc(e));return a}ey.prototype.ih=function(a,b,d){return Rc(d,this.EY,this.LV,K(function(a){return function(){return T(a.hV)}}(this)),this.$X)};ey.prototype.$classData=g({g8:0},!1,&quot;scalaz.FingerTree$$anon$19&quot;,{g8:1,cR:1,d:1});function Td(){this.gV=this.ea=null}Td.prototype=new Yx;
Td.prototype.constructor=Td;Td.prototype.dj=function(a){this.gV=a;Xx.prototype.dj.call(this,a);return this};Td.prototype.ih=function(a){return a.y(this.gV.jl().he())};Td.prototype.$classData=g({h8:0},!1,&quot;scalaz.FingerTree$$anon$8&quot;,{h8:1,cR:1,d:1});function vS(){this.qS=this.oS=this.FY=this.Ai=null}vS.prototype=new sz;vS.prototype.constructor=vS;vS.prototype.$C=function(a){var b=this.FY,d=this.oS,e=this.qS;return(0,a.vi)(b,d,e)};
function Tma(a,b,d,e,f){a.FY=b;a.oS=d;a.qS=e;rz.prototype.dj.call(a,f);a.Ai=b;return a}vS.prototype.$classData=g({i8:0},!1,&quot;scalaz.FingerTree$$anon$9&quot;,{i8:1,W8:1,d:1});function yS(){}yS.prototype=new l;yS.prototype.constructor=yS;c=yS.prototype;c.mi=function(a){return Ad(this,a)};c.ls=function(){Ed(this);return this};c.Hi=function(){};c.Zh=function(a,b,d){return iia(a,b,d)};c.Hg=function(a,b,d){return a.Gb(b,d)};c.$classData=g({j8:0},!1,&quot;scalaz.FingerTreeInstances$$anon$11&quot;,{j8:1,d:1,Wi:1});
function ry(){this.lr=this.Hw=this.fz=null}ry.prototype=new l;ry.prototype.constructor=ry;ry.prototype.Md=function(a){return Vma(this,a)};ry.prototype.Xg=function(a){return this.Md(a).k()};ry.prototype.Tg=function(){};
function Vma(a,b){return b.ih(m(new n,function(a){return function(b){var f=Qd();b=[a.Hw.Md(b),Rd(Qd(),&quot; []&quot;)];var h=b.length|0,k=0,p=Sd((new Td).dj(f.Pq));a:for(;;){if(k!==h){f=1+k|0;p=Ud(p,b[k]);k=f;continue a}return p}}}(a)),tb(new ub,function(a){return function(b,f){var h=Qd();b=[a.Hw.Md(b),Rd(Qd(),&quot; [&quot;),a.lr.Md(f),Rd(Qd(),&quot;]&quot;)];f=b.length|0;var k=0,p=Sd((new Td).dj(h.Pq));a:for(;;){if(k!==f){h=1+k|0;p=Ud(p,b[k]);k=h;continue a}return p}}}(a)),by(function(a){return function(b,f,h,k){h=Qd();b=[a.Hw.Md(b),
Rd(Qd(),&quot; [&quot;),a.fz.Md(f.ub()),Rd(Qd(),&quot;, ?, &quot;),a.fz.Md(k.ub()),Rd(Qd(),&quot;]&quot;)];f=b.length|0;k=0;var p=Sd((new Td).dj(h.Pq));a:for(;;){if(k!==f){h=1+k|0;p=Ud(p,b[k]);k=h;continue a}return p}}}(a)))}ry.prototype.$classData=g({k8:0},!1,&quot;scalaz.FingerTreeInstances$$anon$12&quot;,{k8:1,d:1,ch:1});function wy(){}wy.prototype=new l;wy.prototype.constructor=wy;c=wy.prototype;c.mi=function(a){return Ad(this,a)};c.ls=function(){Ed(this);return this};c.Hi=function(){};c.Zh=function(a,b,d){return a.an(b,d)};
c.Hg=function(a,b,d){return Fd(this,a,b,d)};c.$classData=g({m8:0},!1,&quot;scalaz.FingerTreeInstances$$anon$7&quot;,{m8:1,d:1,Wi:1});function zS(){this.ga=null}zS.prototype=new l;zS.prototype.constructor=zS;function Waa(a){var b=new zS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}zS.prototype.$classData=g({n8:0},!1,&quot;scalaz.Foldable$$anon$6&quot;,{n8:1,d:1,RB:1});function AS(){}AS.prototype=new qia;AS.prototype.constructor=AS;function Wma(){}Wma.prototype=AS.prototype;function BS(){this.ND=null}BS.prototype=new sia;
BS.prototype.constructor=BS;function Xma(){}Xma.prototype=BS.prototype;BS.prototype.b=function(){var a=new CS;Md(a);Ty(a);Ed(a);xz(a);bS(a);DS(a);ES(a);FS(a);Nd(a);Gz(a);GS(a);HS(a);IS(a);Xd(a);Wd(a);aS(a);JS(a);gS(a);this.ND=a;return this};function KS(){this.lr=null}KS.prototype=new l;KS.prototype.constructor=KS;
function Yma(a,b){if(wq(b))b=LS(Qd());else{if(!xq(b))throw(new q).j(b);b=Zma(a,b.dd,a.lr.Md(b.$c))}Qd();b=ay(b.pc,K(function(a,b){return function(){return b}}(b,&quot;[&quot;)));return MS(Sd(b),K(function(){return function(){return&quot;]&quot;}}(a)))}KS.prototype.Md=function(a){return Yma(this,a)};function Zma(a,b,d){for(;;){if(wq(b))return d;if(xq(b)){var e=b;b=e.$c;e=e.dd;d=Ud(MS(d,K(function(){return function(){return&quot;,&quot;}}(a))),a.lr.Md(b));b=e}else throw(new q).j(b);}}KS.prototype.Xg=function(a){return this.Md(a).k()};
KS.prototype.Tg=function(){};KS.prototype.$classData=g({w8:0},!1,&quot;scalaz.IListInstances$$anon$6&quot;,{w8:1,d:1,ch:1});function gA(){this.wx=null}gA.prototype=new l;gA.prototype.constructor=gA;gA.prototype.b=function(){fA=this;this.QE($ma());return this};gA.prototype.QE=function(a){this.wx=a};gA.prototype.$classData=g({x8:0},!1,&quot;scalaz.Id$&quot;,{x8:1,d:1,y8:1});var fA=void 0;function NS(){}NS.prototype=new tia;NS.prototype.constructor=NS;function ana(){}ana.prototype=NS.prototype;
function Uz(){this.IG=this.Io=null}Uz.prototype=new Xy;Uz.prototype.constructor=Uz;function Tz(a,b,d){a.Io=b;a.IG=d;return a}Uz.prototype.bD=function(){return m(new n,function(a){return function(){return a.IG.vd(K(function(a){return function(){return a.Io}}(a)))}}(this))};Uz.prototype.$classData=g({D8:0},!1,&quot;scalaz.IndexedStateT$$anon$10&quot;,{D8:1,C8:1,d:1});function Yy(){this.ET=null}Yy.prototype=new Xy;Yy.prototype.constructor=Yy;Yy.prototype.cn=function(a){this.ET=a;return this};
Yy.prototype.bD=function(){return m(new n,function(a){return function(b){return b.vd(K(function(a,b){return function(){return a.ET.y(b)}}(a,b)))}}(this))};Yy.prototype.$classData=g({E8:0},!1,&quot;scalaz.IndexedStateT$$anon$11&quot;,{E8:1,C8:1,d:1});function OS(){}OS.prototype=new yia;OS.prototype.constructor=OS;function bna(){}bna.prototype=OS.prototype;function PS(){this.ga=null}PS.prototype=new l;PS.prototype.constructor=PS;function aba(a){var b=new PS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}
PS.prototype.$classData=g({F8:0},!1,&quot;scalaz.InvariantFunctor$$anon$2&quot;,{F8:1,d:1,Xi:1});function JS(a){a.Ls(cna(a))}function cz(){this.ga=null}cz.prototype=new l;cz.prototype.constructor=cz;cz.prototype.zD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};cz.prototype.$classData=g({H8:0},!1,&quot;scalaz.Isomorphisms$IsoBifunctorTemplate$$anon$14&quot;,{H8:1,d:1,B7:1});function dz(){this.ga=null}dz.prototype=new l;dz.prototype.constructor=dz;
dz.prototype.zD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};dz.prototype.$classData=g({I8:0},!1,&quot;scalaz.Isomorphisms$IsoBifunctorTemplate$$anon$15&quot;,{I8:1,d:1,B7:1});function fz(){this.ga=null}fz.prototype=new l;fz.prototype.constructor=fz;fz.prototype.AD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};fz.prototype.$classData=g({J8:0},!1,&quot;scalaz.Isomorphisms$IsoFunctorTemplate$$anon$12&quot;,{J8:1,d:1,nR:1});function gz(){this.ga=null}gz.prototype=new l;
gz.prototype.constructor=gz;gz.prototype.AD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};gz.prototype.$classData=g({K8:0},!1,&quot;scalaz.Isomorphisms$IsoFunctorTemplate$$anon$13&quot;,{K8:1,d:1,nR:1});function QS(){}QS.prototype=new zia;QS.prototype.constructor=QS;function dna(){}dna.prototype=QS.prototype;function re(){}re.prototype=new Bia;re.prototype.constructor=re;re.prototype.b=function(){jz.prototype.b.call(this);return this};
re.prototype.$classData=g({M8:0},!1,&quot;scalaz.Leibniz$&quot;,{M8:1,mka:1,d:1});var qe=void 0;function se(){}se.prototype=new Aia;se.prototype.constructor=se;se.prototype.b=function(){return this};se.prototype.$classData=g({N8:0},!1,&quot;scalaz.Leibniz$$anon$2&quot;,{N8:1,lka:1,d:1});function RS(){}RS.prototype=new Cia;RS.prototype.constructor=RS;function ena(){}ena.prototype=RS.prototype;RS.prototype.b=function(){wd(new SS);return this};function SS(){}SS.prototype=new l;SS.prototype.constructor=SS;
SS.prototype.Js=function(){};SS.prototype.$classData=g({P8:0},!1,&quot;scalaz.MapInstances$$anon$5&quot;,{P8:1,d:1,gt:1});function TS(){}TS.prototype=new Eia;TS.prototype.constructor=TS;function fna(){}fna.prototype=TS.prototype;function US(){this.qE=null}US.prototype=new Jia;US.prototype.constructor=US;function gna(){}gna.prototype=US.prototype;US.prototype.b=function(){this.qE=(new VS).gq(this);return this};function Yq(){}Yq.prototype=new l;Yq.prototype.constructor=Yq;
Yq.prototype.Xb=function(a,b){return Zq(a,Ee(b))};Yq.prototype.gq=function(){Od(this);return this};Yq.prototype.ff=function(){};Yq.prototype.$classData=g({Z8:0},!1,&quot;scalaz.NonEmptyListInstances$$anon$2&quot;,{Z8:1,d:1,sf:1});function Hq(){}Hq.prototype=new l;Hq.prototype.constructor=Hq;Hq.prototype.b=function(){return this};Hq.prototype.$classData=g({$8:0},!1,&quot;scalaz.NotNothing$$anon$1&quot;,{$8:1,d:1,uka:1});
function hna(a,b,d,e){return e.Xb(d.y(b.Fc),K(function(a,b,d,e){return function(){return a.Xm.Zh(b.Mc,d,e)}}(a,b,d,e)))}function WS(){}WS.prototype=new Kia;WS.prototype.constructor=WS;function ina(){}ina.prototype=WS.prototype;function XS(){this.ga=null}XS.prototype=new l;XS.prototype.constructor=XS;function jna(a){var b=new XS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}XS.prototype.$classData=g({e9:0},!1,&quot;scalaz.Optional$$anon$1&quot;,{e9:1,d:1,ama:1});function YS(){this.ga=null}YS.prototype=new l;
YS.prototype.constructor=YS;function bba(a){var b=new YS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}YS.prototype.$classData=g({g9:0},!1,&quot;scalaz.Plus$$anon$5&quot;,{g9:1,d:1,zw:1});function ZS(){this.ga=null}ZS.prototype=new l;ZS.prototype.constructor=ZS;function kna(a){var b=new ZS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}ZS.prototype.$classData=g({k9:0},!1,&quot;scalaz.Profunctor$$anon$6&quot;,{k9:1,d:1,TB:1});function Oz(){}Oz.prototype=new Nia;Oz.prototype.constructor=Oz;
Oz.prototype.b=function(){Jz.prototype.b.call(this);return this};Oz.prototype.$classData=g({m9:0},!1,&quot;scalaz.Reducer$&quot;,{m9:1,Gka:1,d:1});var Nz=void 0;function $S(){this.cV=this.dT=this.OF=this.eV=null}$S.prototype=new Iz;$S.prototype.constructor=$S;c=$S.prototype;c.jl=function(){return this.eV};c.Al=function(a){return this.OF.y(a)};c.Le=function(a,b){return this.cV.Xb(a,K(function(a,b){return function(){return a.OF.y(b)}}(this,b)))};c.so=function(a,b){return this.dT.y(a).y(b)};
function Pia(a,b,d){var e=new $S;e.OF=a;e.dT=b;e.cV=d;e.eV=d;return e}c.$classData=g({n9:0},!1,&quot;scalaz.ReducerInstances$$anon$6&quot;,{n9:1,l9:1,d:1});function aT(){this.ga=null}aT.prototype=new l;aT.prototype.constructor=aT;function cba(a){var b=new aT;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}aT.prototype.$classData=g({p9:0},!1,&quot;scalaz.Semigroup$$anon$7&quot;,{p9:1,d:1,Aaa:1});function bT(){this.ga=null}bT.prototype=new l;bT.prototype.constructor=bT;
function dba(a){var b=new bT;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}bT.prototype.$classData=g({s9:0},!1,&quot;scalaz.Show$$anon$2&quot;,{s9:1,d:1,cma:1});function qy(){}qy.prototype=new l;qy.prototype.constructor=qy;c=qy.prototype;c.b=function(){Vd(this);return this};c.Md=function(a){return Pd(this,a)};c.Xg=function(a){return na(a)};c.Tg=function(){};c.$classData=g({t9:0},!1,&quot;scalaz.Show$$anon$3&quot;,{t9:1,d:1,ch:1});function Xz(){}Xz.prototype=new l;Xz.prototype.constructor=Xz;Xz.prototype.b=function(){return this};
Xz.prototype.$classData=g({A9:0},!1,&quot;scalaz.Tag$TagOf&quot;,{A9:1,d:1,nR:1});function cT(){}cT.prototype=new l;cT.prototype.constructor=cT;cT.prototype.b=function(){dT=this;this.XE(lna());return this};function mna(a,b){a=K(function(a,b){return function(){var a=Ee(b);eT();return(new Ny).j(a)}}(a,b));return nna(eT(),a)}cT.prototype.XE=function(){};cT.prototype.$classData=g({C9:0},!1,&quot;scalaz.Trampoline$&quot;,{C9:1,d:1,D9:1});var dT=void 0;function fT(){this.XB=null}fT.prototype=new l;
fT.prototype.constructor=fT;function ona(a){var b=new fT;b.XB=a;return b}fT.prototype.$classData=g({J9:0},!1,&quot;scalaz.Unapply_0$$anon$14&quot;,{J9:1,d:1,Rka:1});function gT(){}gT.prototype=new Ria;gT.prototype.constructor=gT;function pna(){}pna.prototype=gT.prototype;function hT(){}hT.prototype=new Iz;hT.prototype.constructor=hT;function qna(){}qna.prototype=hT.prototype;hT.prototype.Le=function(a,b){return this.jl().Xb(a,K(function(a,b){return function(){return a.Al(b)}}(this,b)))};
hT.prototype.so=function(a,b){return this.jl().Xb(this.Al(a),K(function(a,b){return function(){return b}}(this,b)))};function iT(){this.ga=null}iT.prototype=new l;iT.prototype.constructor=iT;function eba(a){var b=new iT;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}iT.prototype.$classData=g({L9:0},!1,&quot;scalaz.Unzip$$anon$3&quot;,{L9:1,d:1,Ina:1});function jT(){}jT.prototype=new Sia;jT.prototype.constructor=jT;function rna(){}rna.prototype=jT.prototype;function kT(){this.ga=null}kT.prototype=new l;
kT.prototype.constructor=kT;function fba(a){var b=new kT;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}kT.prototype.$classData=g({Q9:0},!1,&quot;scalaz.Zip$$anon$5&quot;,{Q9:1,d:1,Jna:1});function sna(a){a.dX((new lT).BD(a));a.eX((new mT).BD(a))}function ty(){this.Xt=null}ty.prototype=new l;ty.prototype.constructor=ty;ty.prototype.Md=function(a){return tna(this,a)};ty.prototype.Xg=function(a){return this.Md(a).k()};ty.prototype.Tg=function(){};
function tna(a,b){var d=Qd(),e=Rd(Qd(),&quot;,&quot;),f=m(new n,function(a){return function(b){py();return a.Xt.Md(b)}}(a)),h=Lc();b=una(d,e,b.xa(f,h.s).Hc());Qd();b=ay(b.pc,K(function(a,b){return function(){return b}}(b,&quot;[&quot;)));return MS(Sd(b),K(function(){return function(){return&quot;]&quot;}}(a)))}ty.prototype.$classData=g({E$:0},!1,&quot;scalaz.std.IterableInstances$$anon$2&quot;,{E$:1,d:1,ch:1});function nT(){}nT.prototype=new l;nT.prototype.constructor=nT;nT.prototype.OE=function(){};
nT.prototype.ou=function(){this.OE(Lma(this));return this};nT.prototype.$classData=g({U$:0},!1,&quot;scalaz.std.TupleInstances1$$anon$72&quot;,{U$:1,d:1,z7:1});function oT(){this.Dx=this.At=null}oT.prototype=new l;oT.prototype.constructor=oT;c=oT.prototype;c.bX=function(){};c.TW=function(){};c.UW=function(){};c.b=function(){pT=this;gba(this);return this};c.XW=function(a){this.Dx=a};c.cX=function(){};c.RW=function(){};c.aX=function(){};c.QW=function(){};c.VW=function(){};c.SW=function(){};c.WW=function(){};
c.$W=function(){};c.YW=function(){};c.ZW=function(){};c.PW=function(){};c.$classData=g({Z$:0},!1,&quot;scalaz.std.anyVal$&quot;,{Z$:1,d:1,X9:1});var pT=void 0;function Kz(){pT||(pT=(new oT).b());return pT}function sy(){}sy.prototype=new l;sy.prototype.constructor=sy;sy.prototype.b=function(){return this};sy.prototype.$classData=g({aaa:0},!1,&quot;scalaz.std.iterable$&quot;,{aaa:1,d:1,kla:1});var fia=void 0;function qT(){this.$i=null}qT.prototype=new l;qT.prototype.constructor=qT;
qT.prototype.FD=function(a,b,d){this.$i=d;return this};qT.prototype.$classData=g({faa:0},!1,&quot;scalaz.std.java.util.concurrent.CallableInstances$$anon$1$$anon$3&quot;,{faa:1,d:1,NU:1});function rT(){this.ox=null}rT.prototype=new l;rT.prototype.constructor=rT;rT.prototype.FD=function(a,b,d){this.ox=d;return this};rT.prototype.$classData=g({gaa:0},!1,&quot;scalaz.std.java.util.concurrent.CallableInstances$$anon$1$$anon$4&quot;,{gaa:1,d:1,NU:1});function sT(){}sT.prototype=new l;sT.prototype.constructor=sT;
sT.prototype.$classData=g({haa:0},!1,&quot;scalaz.std.java.util.concurrent.CallableInstances$$anon$1$$anon$5&quot;,{haa:1,d:1,NU:1});function Mz(){}Mz.prototype=new l;Mz.prototype.constructor=Mz;Mz.prototype.b=function(){Lz=this;hba(this);return this};Mz.prototype.gX=function(){};Mz.prototype.fX=function(){};Mz.prototype.$classData=g({oaa:0},!1,&quot;scalaz.std.math.bigInt$&quot;,{oaa:1,d:1,laa:1});var Lz=void 0;function pe(){this.nr=this.pc=null}pe.prototype=new l;pe.prototype.constructor=pe;
function jba(a,b,d){a.pc=b;a.nr=d;return a}pe.prototype.$classData=g({vaa:0},!1,&quot;scalaz.syntax.FoldableOps&quot;,{vaa:1,d:1,yaa:1});function tT(){}tT.prototype=new l;tT.prototype.constructor=tT;tT.prototype.pu=function(){return this};tT.prototype.$classData=g({Eaa:0},!1,&quot;scalaz.syntax.Syntaxes$nel$&quot;,{Eaa:1,d:1,Kaa:1});function uT(){this.nr=this.pc=null}uT.prototype=new l;uT.prototype.constructor=uT;
function vna(a,b){return b.XB.uh(a.pc,m(new n,function(){return function(a){qe||(qe=(new re).b());(new se).b();return a}}(a,b)),a.nr)}function wna(a,b){var d=new uT;d.pc=a;d.nr=b;return d}uT.prototype.$classData=g({Naa:0},!1,&quot;scalaz.syntax.TraverseOps&quot;,{Naa:1,d:1,yaa:1});function vT(){this.pE=this.NF=this.aD=null}vT.prototype=new l;vT.prototype.constructor=vT;vT.prototype.b=function(){return this};function xna(){var a=wT();null===wT().NF&amp;&amp;null===wT().NF&amp;&amp;(wT().NF=(new xT).pu(a));wT()}
function Hfa(){var a=wT();null===wT().aD&amp;&amp;null===wT().aD&amp;&amp;(wT().aD=(new yT).pu(a));wT()}vT.prototype.$classData=g({Paa:0},!1,&quot;scalaz.syntax.package$&quot;,{Paa:1,d:1,dma:1});var zT=void 0;function wT(){zT||(zT=(new vT).b());return zT}function AT(){}AT.prototype=new l;AT.prototype.constructor=AT;AT.prototype.b=function(){return this};
AT.prototype.Fs=function(a){var b=yna().NC.Ac;BT(b,&quot;Failure in RunNow async execution: &quot;+a);CT(b,&quot;\n&quot;);b=yna().NC.Ac;wja||(wja=(new BB).b());a=ix(a);var d=zja().iz,e=zja().iz,f=(new Fm).b(),h;h=!0;js(f,&quot;&quot;);for(var k=0,p=a.l.length;k&lt;p;){var t=a.l[k];h?(ks(f,t),h=!1):(js(f,d),ks(f,t));k=1+k|0}js(f,e);BT(b,f.vc.Zb);CT(b,&quot;\n&quot;)};AT.prototype.Yt=function(a){try{a.om()}catch(b){a=ko(Lg(),b);if(null!==a)throw Kg(Lg(),a);throw b;}};
AT.prototype.$classData=g({Taa:0},!1,&quot;utest.framework.ExecutionContext$RunNow$&quot;,{Taa:1,d:1,jy:1});var DT=void 0;function ET(){DT||(DT=(new AT).b());return DT}function FT(){this.qY=this.za=null}FT.prototype=new l;FT.prototype.constructor=FT;function GT(){}GT.prototype=FT.prototype;
function zna(a,b,d,e,f){wha||(wha=(new uw).b());var h=vha(e,a.qY),k=b.zb(&quot;.&quot;),p=&quot;&quot;+u((new v).K((new w).f([&quot;Starting Suite &quot;])),y())+e,t=(new Sb).c(&quot;-&quot;),t=Ana(t,(80-(p.length|0)|0)/2|0);d.wa(m(new n,function(a,b,d){return function(a){a.lD(&quot;&quot;+d+b+d)}}(a,p,t)));HA||(HA=(new GA).b());p=h.ria();p=eja(vA(p),b);if(null===p)throw(new q).j(p);a.tS(p.pa().sa());for(var p=a.za,t=p.l.length,x=0;;){if(x&lt;t)var E=p.l[x],E=!(0&lt;=(E.length|0)&amp;&amp;&quot;--parallel&quot;===E.substring(0,10));else E=!1;if(E)x=1+x|0;else break}t=x;
p=t&lt;p.l.length?(new J).j(p.l[t]):F();p.z()?p=!1:(p=p.Y(),p=(new Sb).c(p),t=10,x=p.R.length|0,p=Ye(Ze(),p.R,t,x),0===(p.length|0)?p=!0:(p=(new Sb).c(p),t=p.R.length|0,p=Ye(Ze(),p.R,1,t),p=(new Sb).c(p),p=Ki(p.R)));p=p?KB():ET();HA||(HA=(new GA).b());t=h.ria();t=vA(t);d=tb(new ub,function(a,b,d,e,f,h,k){return function(p,t){t.X.Ex()?a.dU():a.cU();var x=r();p=h.Zna(b.Rc(p,x.s),t);Bna((new HT).b(),Tv().VB,f,k);p.z()||(x=p.Y(),d.wa(m(new n,function(a,b,d){return function(a){a.lD(&quot;&quot;+b+d)}}(a,e,x))));t=
t.X;if(Aw(t)){t=t.rk;Bna((new HT).ud(t),Tv().hw,f,k);for(var x=ix(t),E=x.l.length,$a=0;;)if($a&lt;E&amp;&amp;&quot;utest.framework.TestThunkTree&quot;!==x.l[$a].xo)$a=1+$a|0;else break;E=$a;E=0&lt;E?E:0;$a=x.l.length;E=E&lt;$a?E:$a;E=0&lt;E?E:0;$a=ZA(aB(),LA(oa(x)),E);0&lt;E&amp;&amp;dw(Rf(),x,0,$a,0,E);Cna(t,$a);a.dC(&quot;&quot;+e+(p.z()?&quot;&quot;:p.Y()));if(Dna(t))p=&quot;&quot;;else{p=ix(t);t=null;t=[];x=0;for(E=p.l.length;x&lt;E;)$a=p.l[x].k(),t.push(null===$a?null:$a),x=1+x|0;p=ka(Xa(qa),t);t=(new Fm).b();x=!1;x=!0;js(t,&quot;&quot;);E=0;for($a=p.l.length;E&lt;$a;){var fc=
p.l[E];x?(ks(t,fc),x=!1):(js(t,&quot;\n&quot;),ks(t,fc));E=1+E|0}js(t,&quot;&quot;);p=t.vc.Zb}a.fC(p)}}}(a,b,d,e,f,h,k));e=m(new n,function(a,b,d){return function(a){return b.wpa(a,d)}}(a,h,p));f=y();return hja(t,d,f,b,e,p).Ih(m(new n,function(a,b){return function(a){return b.aoa(a)}}(a,h)),p).Ih(m(new n,function(a){return function(b){b.z()||(b=b.Y(),a.eC(b))}}(a)),p)}function Bna(a,b,d,e){d.VT(Ena(e,a,b))}
function nma(a,b){var d;d=[];for(var e=0,f=b.l.length;e&lt;f;){var h=Ama(a,b.l[e]);d.push(null===h?null:h);e=1+e|0}return ka(Xa(vd),d)}FT.prototype.fU=function(a,b,d){this.za=a;this.qY=d;return this};function Ama(a,b){var d=Yt($e(),a.za),d=md(new nd,d).Uc(0),d=d.z()||45!==(65535&amp;(d.Y().charCodeAt(0)|0))?d:F(),d=d.z()?&quot;&quot;:d.Y();return Fna(new IT,b,d,by(function(a){return function(b,d,k,p){return zna(a,b,d,k,p)}}(a)))}function JT(){this.zF=this.rV=this.uF=null}JT.prototype=new l;
JT.prototype.constructor=JT;function Ena(a,b,d){var e=new JT;e.uF=a;e.rV=b;e.zF=d;return e}JT.prototype.$classData=g({Zaa:0},!1,&quot;utest.runner.BaseRunner$$anon$2&quot;,{Zaa:1,d:1,oja:1});function KT(){}KT.prototype=new l;KT.prototype.constructor=KT;KT.prototype.b=function(){return this};function uha(){var a=(new w).f([new LT]),b=a.oa.length|0,b=la(Xa(Qaa),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e;d=1+d|0}return b}
function mma(a,b,d){return Gna(new MT,b,d,K(function(){return function(){}}(a)),K(function(){return function(){}}(a)))}function zma(a,b,d,e){return Hna(new NT,b,d,e,K(function(){return function(){}}(a)),K(function(){return function(){}}(a)))}KT.prototype.$classData=g({aba:0},!1,&quot;utest.runner.Framework&quot;,{aba:1,d:1,i7:1});function IT(){this.DE=this.Og=this.Dv=null}IT.prototype=new l;IT.prototype.constructor=IT;
function rma(a,b,d,e){var f=ET();Ina(a,b,d).Es(Jna(d),f).ap(m(new n,function(a,b){return function(){var a=y(),d=wn(a),d=la(Xa(vd),[d]),e;e=0;for(a=Cv(a);a.ta();){var f=a.ma();d.l[e]=f;e=1+e|0}b.y(d)}}(a,e)),f)}function Fna(a,b,d,e){a.Dv=b;a.Og=d;a.DE=e;return a}
function Ina(a,b,d){if(Wp(Ia(),a.Og,&quot;}&quot;)){var e=(new Sb).c(a.Og),f=a.Og.lastIndexOf(&quot;{&quot;)|0,f=Fj(e,f);if(null===f)throw(new q).j(f);var e=f.la(),f=(new Sb).c(f.pa()),h=f.R.length|0,f=Ye(Ze(),f.R,1,h),f=(new Sb).c(f),f=Sm(f,1),f=QE(Ia(),f,&quot;,&quot;);Rf();(new AB).b();var h=Kna().bb(),k=f.l.length;switch(k){case -1:break;default:h.tc(k)}for(var k=0,p=f.l.length;k&lt;p;)h.Na(&quot;&quot;+e+f.l[k].trim()),k=1+k|0;f=h.Da()}else f=I(r(),(new w).f([a.Og]));h=a.Dv.ik;if(f.le(m(new n,function(a,b){return function(a){return 0&lt;=
(b.length|0)&amp;&amp;b.substring(0,a.length|0)===a}}(a,h))))return Rc(a.DE,y(),Yt($e(),d),h,b);e=ET();f=f.al(m(new n,function(a,b){return function(a){return 0&lt;=(a.length|0)&amp;&amp;a.substring(0,b.length|0)===b}}(a,h)),!1);a=m(new n,function(a,b,d,e){return function(f){var h=a.DE;$e();f=(new Sb).c(f);var k=e.length|0,p=f.R.length|0;f=Ye(Ze(),f.R,k,p);f=QE(Ia(),f,&quot;\\.&quot;);for(var k=(new OT).So(Lna(Mna(),LA(oa(f)))),p=0,Fa=f.l.length;p&lt;Fa;){var Va=f.l[p];!1!==0&lt;(Va.length|0)&amp;&amp;Nna(k,Va);p=1+p|0}return Rc(h,Yt(0,Ona(k)),
Yt($e(),d),e,b)}}(a,b,d,h));b=r();a=f.xa(a,b.s);b=xA();d=r();return QB(b,a,d.s,e)}IT.prototype.$classData=g({fba:0},!1,&quot;utest.runner.Task&quot;,{fba:1,d:1,VQ:1});function PT(){}PT.prototype=new l;PT.prototype.constructor=PT;function QT(){}QT.prototype=PT.prototype;function eF(a){return!!(a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.xk||&quot;number&quot;===typeof a)}function RT(){this.Zr=this.xs=this.xo=null;this.Gt=this.vs=0}RT.prototype=new l;RT.prototype.constructor=RT;
RT.prototype.o=function(a){return a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.LU?this.Zr===a.Zr&amp;&amp;this.vs===a.vs&amp;&amp;this.xo===a.xo&amp;&amp;this.xs===a.xs:!1};RT.prototype.k=function(){var a=&quot;&quot;;&quot;\x3cjscode\x3e&quot;!==this.xo&amp;&amp;(a=&quot;&quot;+a+this.xo+&quot;.&quot;);a=&quot;&quot;+a+this.xs;null===this.Zr?a+=&quot;(Unknown Source)&quot;:(a=&quot;&quot;+a+u((new v).K((new w).f([&quot;(&quot;,&quot;&quot;])),(new w).f([this.Zr])),0&lt;=this.vs&amp;&amp;(a=&quot;&quot;+a+u((new v).K((new w).f([&quot;:&quot;,&quot;&quot;])),(new w).f([this.vs])),0&lt;=this.Gt&amp;&amp;(a=&quot;&quot;+a+u((new v).K((new w).f([&quot;:&quot;,&quot;&quot;])),(new w).f([this.Gt])))),a+=&quot;)&quot;);return a};
RT.prototype.r=function(){var a=this.xo,a=Ha(Ia(),a),b=this.xs;return a^Ha(Ia(),b)};RT.prototype.setColumnNumber=function(a){this.Gt=a|0};RT.prototype.getColumnNumber=function(){return this.Gt};var Pna=g({LU:0},!1,&quot;java.lang.StackTraceElement&quot;,{LU:1,d:1,i:1});RT.prototype.$classData=Pna;function VA(){this.va=null}VA.prototype=new l;VA.prototype.constructor=VA;VA.prototype.om=function(){};VA.prototype.$classData=g({Vba:0},!1,&quot;java.lang.Thread&quot;,{Vba:1,d:1,KU:1});
function ST(){this.Rq=this.Me=this.Kc=null}ST.prototype=new l;ST.prototype.constructor=ST;function TT(){}TT.prototype=ST.prototype;ST.prototype.bu=function(){if(void 0===ba.Error.captureStackTrace){try{var a={}.undef()}catch(b){if(a=ko(Lg(),b),null!==a)if(aF(a))a=a.Go;else throw Kg(Lg(),a);else throw b;}this.stackdata=a}else ba.Error.captureStackTrace(this),this.stackdata=this;return this};ST.prototype.Fh=function(){return this.Kc};
ST.prototype.k=function(){var a=oa(this).kh(),b=this.Fh();return null===b?a:a+&quot;: &quot;+b};function Cna(a,b){for(var d=0;d&lt;b.l.length;){if(null===b.l[d])throw(new Oe).b();d=1+d|0}a.Rq=b.MS()}
function ix(a){if(null===a.Rq){XE||(XE=(new UE).b());var b=XE,d=a.stackdata,e;if(d){if(0===(1&amp;b.ya)&amp;&amp;0===(1&amp;b.ya)){a:try{ba.Packages.org.mozilla.javascript.JavaScriptException,e=!0}catch(U){e=ko(Lg(),U);if(null!==e){if(aF(e)){e=!1;break a}throw Kg(Lg(),e);}throw U;}b.vU=e;b.ya=(1|b.ya)&lt;&lt;24&gt;&gt;24}if(b.vU)e=d.stack,e=(void 0===e?&quot;&quot;:e).replace(WE(&quot;^\\s+at\\s+&quot;,&quot;gm&quot;),&quot;&quot;).replace(WE(&quot;^(.+?)(?: \\((.+)\\))?$&quot;,&quot;gm&quot;),&quot;$2@$1&quot;).replace(WE(&quot;\\r\\n?&quot;,&quot;gm&quot;),&quot;\n&quot;).split(&quot;\n&quot;);else if(d.arguments&amp;&amp;d.stack)e=Xka(d);
else if(d.stack&amp;&amp;d.sourceURL)e=d.stack.replace(WE(&quot;\\[native code\\]\\n&quot;,&quot;m&quot;),&quot;&quot;).replace(WE(&quot;^(?\x3d\\w+Error\\:).*$\\n&quot;,&quot;m&quot;),&quot;&quot;).replace(WE(&quot;^@&quot;,&quot;gm&quot;),&quot;{anonymous}()@&quot;).split(&quot;\n&quot;);else if(d.stack&amp;&amp;d.number)e=d.stack.replace(WE(&quot;^\\s*at\\s+(.*)$&quot;,&quot;gm&quot;),&quot;$1&quot;).replace(WE(&quot;^Anonymous function\\s+&quot;,&quot;gm&quot;),&quot;{anonymous}() &quot;).replace(WE(&quot;^([^\\(]+|\\{anonymous\\}\\(\\))\\s+\\((.+)\\)$&quot;,&quot;gm&quot;),&quot;$1@$2&quot;).split(&quot;\n&quot;).slice(1);else if(d.stack&amp;&amp;d.fileName)e=d.stack.replace(WE(&quot;(?:\\n@:0)?\\s+$&quot;,&quot;m&quot;),&quot;&quot;).replace(WE(&quot;^(?:\\((\\S*)\\))?@&quot;,
&quot;gm&quot;),&quot;{anonymous}($1)@&quot;).split(&quot;\n&quot;);else if(d.message&amp;&amp;d[&quot;opera#sourceloc&quot;])if(d.stacktrace)if(-1&lt;d.message.indexOf(&quot;\n&quot;)&amp;&amp;d.message.split(&quot;\n&quot;).length&gt;d.stacktrace.split(&quot;\n&quot;).length)e=bla(d);else{e=WE(&quot;Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$&quot;,&quot;i&quot;);for(var d=d.stacktrace.split(&quot;\n&quot;),f=[],h=0,k=d.length|0;h&lt;k;){var p=e.exec(d[h]);if(null!==p){var t=p[3],t=void 0===t?&quot;{anonymous}&quot;:t,x=p[2];if(void 0===x)throw(new Xu).c(&quot;undefined.get&quot;);p=p[1];if(void 0===p)throw(new Xu).c(&quot;undefined.get&quot;);
f.push(t+&quot;()@&quot;+x+&quot;:&quot;+p)}h=2+h|0}e=f}else e=bla(d);else if(d.message&amp;&amp;d.stack&amp;&amp;d.stacktrace){if(0&gt;d.stacktrace.indexOf(&quot;called from line&quot;))for(e=VE(&quot;^(.*)@(.+):(\\d+)$&quot;),d=d.stacktrace.split(&quot;\n&quot;),f=[],h=0,k=d.length|0;h&lt;k;){p=e.exec(d[h]);if(null!==p){t=p[1];t=void 0===t?&quot;global code&quot;:t+&quot;()&quot;;x=p[2];if(void 0===x)throw(new Xu).c(&quot;undefined.get&quot;);p=p[3];if(void 0===p)throw(new Xu).c(&quot;undefined.get&quot;);f.push(t+&quot;@&quot;+x+&quot;:&quot;+p)}h=1+h|0}else for(e=VE(&quot;^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$&quot;),
d=d.stacktrace.split(&quot;\n&quot;),f=[],h=0,k=d.length|0;h&lt;k;){p=e.exec(d[h]);if(null!==p){t=p[4];if(void 0===t)throw(new Xu).c(&quot;undefined.get&quot;);x=p[1];if(void 0===x)throw(new Xu).c(&quot;undefined.get&quot;);var E=p[2];if(void 0===E)throw(new Xu).c(&quot;undefined.get&quot;);t=t+&quot;:&quot;+x+&quot;:&quot;+E;p=p[2];p=(void 0===p?&quot;global code&quot;:p).replace(VE(&quot;\x3canonymous function: (\\S+)\x3e&quot;),&quot;$1&quot;).replace(VE(&quot;\x3canonymous function\x3e&quot;),&quot;{anonymous}&quot;);f.push(p+&quot;@&quot;+t)|0}h=2+h|0}e=f}else e=d.stack&amp;&amp;!d.fileName?Xka(d):[]}else e=[];f=e;h=VE(&quot;^([^\\@]*)\\@(.*):([0-9]+)$&quot;);
k=VE(&quot;^([^\\@]*)\\@(.*):([0-9]+):([0-9]+)$&quot;);d=[];for(e=0;e&lt;(f.length|0);){p=f[e];if(null===p)throw(new Oe).b();if(&quot;&quot;!==p)if(t=k.exec(p),null!==t){p=t[1];if(void 0===p)throw(new Xu).c(&quot;undefined.get&quot;);x=ala(b,p);if(null===x)throw(new q).j(x);p=x.la();x=x.pa();E=t[2];if(void 0===E)throw(new Xu).c(&quot;undefined.get&quot;);var S=t[3];if(void 0===S)throw(new Xu).c(&quot;undefined.get&quot;);S=(new Sb).c(S);S=Ji(Hi(),S.R,10);t=t[4];if(void 0===t)throw(new Xu).c(&quot;undefined.get&quot;);t=(new Sb).c(t);t=Ji(Hi(),t.R,10);d.push({declaringClass:p,
methodName:x,fileName:E,lineNumber:S,columnNumber:void 0===t?void 0:t})}else if(t=h.exec(p),null!==t){p=t[1];if(void 0===p)throw(new Xu).c(&quot;undefined.get&quot;);x=ala(b,p);if(null===x)throw(new q).j(x);p=x.la();x=x.pa();E=t[2];if(void 0===E)throw(new Xu).c(&quot;undefined.get&quot;);t=t[3];if(void 0===t)throw(new Xu).c(&quot;undefined.get&quot;);t=(new Sb).c(t);t=Ji(Hi(),t.R,10);d.push({declaringClass:p,methodName:x,fileName:E,lineNumber:t,columnNumber:void 0})}else d.push({declaringClass:&quot;\x3cjscode\x3e&quot;,methodName:p,fileName:null,
lineNumber:-1,columnNumber:void 0})|0;e=1+e|0}b=aa.sourceMapper;b=void 0===b?d:b(d);d=la(Xa(Pna),[b.length|0]);for(e=0;e&lt;(b.length|0);)f=b[e],h=f.methodName,k=f.fileName,p=f.lineNumber|0,t=new RT,t.xo=f.declaringClass,t.xs=h,t.Zr=k,t.vs=p,t.Gt=-1,h=t,f=f.columnNumber,void 0!==f&amp;&amp;h.setColumnNumber(f|0),d.l[e]=h,e=1+e|0;a.Rq=d}return a.Rq}
function UT(a){var b=SA().Eo,b=function(a,b){return function(a){BT(b,a);CT(b,&quot;\n&quot;)}}(a,b);ix(a);var d=a.k();b(d);if(0!==a.Rq.l.length)for(d=0;d&lt;a.Rq.l.length;)b(&quot;  at &quot;+a.Rq.l[d]),d=1+d|0;else b(&quot;  \x3cno stack trace available\x3e&quot;);for(;;)if(a!==a.Me&amp;&amp;null!==a.Me){var e=ix(a);a=a.Me;var d=ix(a),f=d.l.length,h=e.l.length,k=&quot;Caused by: &quot;+a.k();b(k);if(0!==f){for(k=0;;){if(k&lt;f&amp;&amp;k&lt;h)var p=d.l[-1+(f-k|0)|0],t=e.l[-1+(h-k|0)|0],p=null===p?null===t:p.o(t);else p=!1;if(p)k=1+k|0;else break}0&lt;k&amp;&amp;(k=-1+k|
0);e=f-k|0;for(f=0;f&lt;e;)b(&quot;  at &quot;+d.l[f]),f=1+f|0;0&lt;k&amp;&amp;b(&quot;  ... &quot;+k+&quot; more&quot;)}else b(&quot;  \x3cno stack trace available\x3e&quot;)}else break}ST.prototype.jc=function(a,b){this.Kc=a;this.Me=b;this.bu();return this};var Oq=g({ad:0},!1,&quot;java.lang.Throwable&quot;,{ad:1,d:1,i:1});ST.prototype.$classData=Oq;function Gg(){this.rU=this.IV=null;this.XV=this.YV=0;this.bm=this.Uo=this.yq=null;this.$w=!1;this.xr=0}Gg.prototype=new l;Gg.prototype.constructor=Gg;
function oi(a){if(a.$w){a.bm=a.yq.exec(a.Uo);if(null!==a.bm){var b=a.bm[0];if(void 0===b)throw(new Xu).c(&quot;undefined.get&quot;);if(null===b)throw(new Oe).b();&quot;&quot;===b&amp;&amp;(b=a.yq,b.lastIndex=1+(b.lastIndex|0)|0)}else a.$w=!1;return null!==a.bm}return!1}function VT(a){if(null===a.bm)throw(new ye).c(&quot;No match available&quot;);return a.bm}function Qna(a,b){a=VT(a)[b];return void 0===a?null:a}c=Gg.prototype;
c.Sq=function(a){if(0===a)return this.vl();var b=VT(this);a=b[a];return void 0===a?-1:this.Uo.indexOf(a,b.index|0)|0};function Pba(a){ro(a);oi(a);null===a.bm||0===a.vl()&amp;&amp;a.Wm()===(a.Uo.length|0)||ro(a);return null!==a.bm}function Rna(a){return-1+(VT(a).length|0)|0}function uo(a,b){WT(b,a.Uo.substring(a.xr));a.xr=a.Uo.length|0}c.Wm=function(){var a=this.vl(),b=pi(this);return a+(b.length|0)|0};
function Fg(a,b,d,e){a.IV=b;a.rU=d;a.YV=0;a.XV=e;b=a.IV;d=new ba.RegExp(b.mq);b=d!==b.mq?d:new ba.RegExp(b.mq.source,(b.mq.global?&quot;g&quot;:&quot;&quot;)+(b.mq.ignoreCase?&quot;i&quot;:&quot;&quot;)+(b.mq.multiline?&quot;m&quot;:&quot;&quot;));a.yq=b;a.Uo=na(Ma(a.rU,a.YV,a.XV));a.bm=null;a.$w=!0;a.xr=0;return a}
function to(a,b,d){var e=a.Uo,f=a.xr,h=a.vl();WT(b,e.substring(f,h));e=d.length|0;for(f=0;f&lt;e;)switch(h=65535&amp;(d.charCodeAt(f)|0),h){case 36:for(h=f=1+f|0;;){if(f&lt;e)var k=65535&amp;(d.charCodeAt(f)|0),k=48&lt;=k&amp;&amp;57&gt;=k;else k=!1;if(k)f=1+f|0;else break}k=Hi();h=d.substring(h,f);h=Ji(k,h,10);WT(b,Qna(a,h));break;case 92:f=1+f|0;f&lt;e&amp;&amp;Sna(b,65535&amp;(d.charCodeAt(f)|0));f=1+f|0;break;default:Sna(b,h),f=1+f|0}a.xr=a.Wm()}function pi(a){a=VT(a)[0];if(void 0===a)throw(new Xu).c(&quot;undefined.get&quot;);return a}
c.vl=function(){return VT(this).index|0};c.Wt=function(a){var b=this.Sq(a);if(-1===b)return-1;a=Qna(this,a);return b+(a.length|0)|0};function ro(a){a.yq.lastIndex=0;a.bm=null;a.$w=!0;a.xr=0}c.$classData=g({uca:0},!1,&quot;java.util.regex.Matcher&quot;,{uca:1,d:1,ioa:1});function em(){}em.prototype=new l;em.prototype.constructor=em;em.prototype.Uh=function(){HF();Lk();return(new IF).b()};em.prototype.af=function(){HF();Lk();return(new IF).b()};
em.prototype.$classData=g({Aca:0},!1,&quot;scala.LowPriorityImplicits$$anon$4&quot;,{Aca:1,d:1,Ps:1});function XT(){}XT.prototype=new l;XT.prototype.constructor=XT;XT.prototype.b=function(){return this};XT.prototype.Uh=function(){return(new Fm).b()};XT.prototype.af=function(){return(new Fm).b()};XT.prototype.$classData=g({Oca:0},!1,&quot;scala.Predef$$anon$3&quot;,{Oca:1,d:1,Ps:1});function YT(){this.fr=null}YT.prototype=new l;YT.prototype.constructor=YT;c=YT.prototype;
c.xv=function(a,b){return(new ZT).No(this.fr,a,b)};c.k=function(){var a=this.fr,b=(new Fm).b(),d;d=!0;js(b,&quot;&quot;);for(var e=0,f=a.l.length;e&lt;f;){var h=(new af).Ra(a.l[e]);d?(ks(b,h),d=!1):(js(b,&quot;&quot;),ks(b,h));e=1+e|0}js(b,&quot;&quot;);return b.vc.Zb};c.Yl=function(a){this.fr=a;return this};c.sa=function(){return this.fr.l.length};c.$classData=g({Pca:0},!1,&quot;scala.Predef$ArrayCharSequence&quot;,{Pca:1,d:1,Fu:1});
function Tna(a,b){switch(b){case 0:return a.gb;case 1:return a.Fb;case 2:return a.og;case 3:return a.gr;default:throw(new P).c(&quot;&quot;+b);}}function $T(){}$T.prototype=new l;$T.prototype.constructor=$T;$T.prototype.b=function(){return this};$T.prototype.$classData=g({ada:0},!1,&quot;scala.concurrent.BlockContext$DefaultBlockContext$&quot;,{ada:1,d:1,mW:1});var Una=void 0;function IA(){this.Is=0}IA.prototype=new l;IA.prototype.constructor=IA;
IA.prototype.o=function(a){KA();return a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.rW?this.Is===a.Is:!1};IA.prototype.Db=function(a){this.Is=a;return this};IA.prototype.r=function(){return this.Is};IA.prototype.$classData=g({rW:0},!1,&quot;scala.concurrent.duration.package$DurationInt&quot;,{rW:1,d:1,yoa:1});function aU(){}aU.prototype=new Kja;aU.prototype.constructor=aU;aU.prototype.ru=function(){return this};aU.prototype.$classData=g({vda:0},!1,&quot;scala.io.Source$RelaxedPosition$&quot;,{vda:1,Aoa:1,d:1});
function bU(){fC.call(this)}bU.prototype=new Nja;bU.prototype.constructor=bU;bU.prototype.ru=function(a){fC.prototype.rba.call(this,a,Vna(a));return this};bU.prototype.$classData=g({wda:0},!1,&quot;scala.io.Source$RelaxedPositioner$&quot;,{wda:1,Coa:1,d:1});function jC(){}jC.prototype=new l;jC.prototype.constructor=jC;jC.prototype.b=function(){return this};jC.prototype.k=function(){return&quot;object AnyRef&quot;};jC.prototype.$classData=g({Kda:0},!1,&quot;scala.package$$anon$1&quot;,{Kda:1,d:1,woa:1});
function ZC(){this.LE=this.va=this.gy=this.rx=this.pl=null}ZC.prototype=new l;ZC.prototype.constructor=ZC;ZC.prototype.k=function(){return this.va+&quot;(&quot;+this.LE+&quot;)&quot;};function YC(a,b,d,e){a.pl=b;a.rx=d;a.gy=e;a.LE=&quot;&quot;;a.va=&quot;Catch&quot;;return a}function Wna(a,b){var d=new cU;if(null===a)throw Kg(Lg(),null);d.ga=a;d.ox=b;return YC(new ZC,d,a.rx,a.gy)}function Cma(){var a=jka();return Wna(a,m(new n,function(){return function(){return F()}}(a)))}
ZC.prototype.$classData=g({pea:0},!1,&quot;scala.util.control.Exception$Catch&quot;,{pea:1,d:1,Koa:1});function dU(){this.uy=this.ZU=this.dk=0}dU.prototype=new lka;dU.prototype.constructor=dU;dU.prototype.b=function(){eU=this;this.dk=Ha(Ia(),&quot;Seq&quot;);this.ZU=Ha(Ia(),&quot;Map&quot;);this.uy=Ha(Ia(),&quot;Set&quot;);return this};function fU(a,b){if(gh(b)){for(var d=0,e=a.dk,f=b;!f.z();)b=f.$(),f=f.aa(),e=a.da(e,hD(V(),b)),d=1+d|0;a=a.tb(e,d)}else a=mka(a,b,a.dk);return a}
dU.prototype.$classData=g({vea:0},!1,&quot;scala.util.hashing.MurmurHash3$&quot;,{vea:1,Loa:1,d:1});var eU=void 0;function Q(){eU||(eU=(new dU).b());return eU}function gU(){this.Mu=this.uc=this.yT=this.iY=null;this.ya=this.Va=this.Xa=0}gU.prototype=new l;gU.prototype.constructor=gU;c=gU.prototype;c.Sq=function(a){return Xna(this).l[a]};c.k=function(){return 0&lt;=this.vl()?na(Ma(this.wF(),this.vl(),this.Wm())):null};c.Wm=function(){return this.Va};
function Yna(a){if(0===(2&amp;a.ya)&amp;&amp;0===(2&amp;a.ya)){var b=Rna(a.Mu),d=0&gt;b;if(d)var e=0;else var e=b&gt;&gt;31,f=1+b|0,e=0===f?1+e|0:e,e=(0===e?-1&lt;(-2147483648^f):0&lt;e)?-1:f;HF();Mk();HF();Lk();f=(new IF).b();0&gt;e&amp;&amp;$n(ao(),0,b,1,!0);if(!d)for(d=0;;){e=a.Mu.Wt(d);KF(f,e);if(d===b)break;d=1+d|0}b=LF(f);d=b.sa();d=la(Xa(db),[d]);tD(b,d,0);a.yT=d;a.ya=(2|a.ya)&lt;&lt;24&gt;&gt;24}return a.yT}c.wF=function(){return this.uc};c.vl=function(){return this.Xa};c.Wt=function(a){return Yna(this).l[a]};
function Xna(a){if(0===(1&amp;a.ya)&amp;&amp;0===(1&amp;a.ya)){var b=Rna(a.Mu),d=0&gt;b;if(d)var e=0;else var e=b&gt;&gt;31,f=1+b|0,e=0===f?1+e|0:e,e=(0===e?-1&lt;(-2147483648^f):0&lt;e)?-1:f;HF();Mk();HF();Lk();f=(new IF).b();0&gt;e&amp;&amp;$n(ao(),0,b,1,!0);if(!d)for(d=0;;){e=a.Mu.Sq(d);KF(f,e);if(d===b)break;d=1+d|0}b=LF(f);d=b.sa();d=la(Xa(db),[d]);tD(b,d,0);a.iY=d;a.ya=(1|a.ya)&lt;&lt;24&gt;&gt;24}return a.iY}c.$classData=g({yea:0},!1,&quot;scala.util.matching.Regex$Match&quot;,{yea:1,d:1,zea:1});function hU(){this.be=this.Bk=this.ga=null}hU.prototype=new oD;
hU.prototype.constructor=hU;function Zna(){}Zna.prototype=hU.prototype;hU.prototype.en=function(a,b,d){this.Bk=b;this.be=d;nD.prototype.To.call(this,a);b=CP(a).Ac;b.z()?b=!1:(b=b.Y(),b.z()?b=!0:(d=b.Y(),b=hP(this.be),d=hP(d.be),b=!(b.sc&lt;d.sc)));b&amp;&amp;(CP(a).Ac=(new J).j((new J).j(this)));return this};hU.prototype.JT=function(){return this};hU.prototype.aV=function(){return this};function iU(){this.ga=this.va=null}iU.prototype=new l;iU.prototype.constructor=iU;function jU(){}jU.prototype=iU.prototype;
function $na(a,b){var d=(new Ne).b();return(new Ae).el(a.ga,m(new n,function(a,b,d){return function(k){return a.si(k).hC(K(function(a,b,d,e){return function(){return(e.La?e.hb:aoa(b,e)).si(d)}}(a,b,k,d)))}}(a,b,d)))}function kP(a,b){return Se(Ve(a,b),a.k()+&quot;^^&quot;)}function boa(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,Ee(a))}
function vP(a,b){var d=(new Ne).b();return Se(Ue(a,m(new n,function(a,b,d){return function(){return Ve(d.La?d.hb:coa(b,d),m(new n,function(){return function(a){return a}}(a)))}}(a,b,d))),&quot;~\x3e&quot;)}c=iU.prototype;c.k=function(){return&quot;Parser (&quot;+this.va+&quot;)&quot;};function Se(a,b){a.va=b;return a}function coa(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,Ee(a))}
function uP(a,b){var d=(new Ne).b();return Se(Ue(a,m(new n,function(a,b,d){return function(k){return Ve(d.La?d.hb:boa(b,d),m(new n,function(a,b){return function(){return b}}(a,k)))}}(a,b,d))),&quot;\x3c~&quot;)}c.er=function(a){var b=(new Ne).b();return Se(Ue(this,m(new n,function(a,b,f){return function(h){return Ve(f.La?f.hb:doa(b,f),m(new n,function(a,b){return function(d){return We(a.ga,b,d)}}(a,h)))}}(this,a,b))),&quot;~&quot;)};c.Fa=function(a){return!!this.si(a)};
function nP(a,b){var d=a.ga;a=Se(Ue(a,m(new n,function(a,b){return function(d){return Ve(De(a.ga,b),m(new n,function(a,b){return function(d){return We(a.ga,b,d)}}(a,d)))}}(a,b))),&quot;~!&quot;);return(new Xe).el(d,a)}function Ue(a,b){return(new Ae).el(a.ga,m(new n,function(a,b){return function(f){return a.si(f).JT(b)}}(a,b)))}function doa(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,Ee(a))}
function Ve(a,b){return(new Ae).el(a.ga,m(new n,function(a,b){return function(f){return a.si(f).aV(b)}}(a,b)))}c.To=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;this.va=&quot;&quot;;return this};c.Ca=function(a){return qb(this,a)};function Re(a,b){return Se($na(a,b),&quot;|&quot;)}function aoa(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,Ee(a))}function eoa(a,b){for(var d=!1;!d&amp;&amp;a.ta();)d=!!b.y(a.ma());return d}function kU(a){return(a.ta()?&quot;non-empty&quot;:&quot;empty&quot;)+&quot; iterator&quot;}
function lU(a,b){for(var d=!0;d&amp;&amp;a.ta();)d=!!b.y(a.ma());return d}function mU(a,b){for(;a.ta();)b.y(a.ma())}function foa(a,b){for(;a.ta();){var d=a.ma();if(b.y(d))return(new J).j(d)}return F()}function As(a){if(a.ta()){var b=a.ma();return MD(new ND,b,K(function(a){return function(){return a.Ic()}}(a)))}Ng();return nU()}function oU(a,b,d,e){var f=d,h=uD(W(),b)-d|0;for(d=d+(e&lt;h?e:h)|0;f&lt;d&amp;&amp;a.ta();)BE(W(),b,f,a.ma()),f=1+f|0}function pU(a,b){for(var d=0;d&lt;b&amp;&amp;a.ta();)a.ma(),d=1+d|0;return a}
function Yb(){this.ga=this.ol=null}Yb.prototype=new l;Yb.prototype.constructor=Yb;Yb.prototype.wa=function(a){this.ga.wa(m(new n,function(a,d){return function(e){return a.ol.y(e)?d.y(e):void 0}}(this,a)))};Yb.prototype.xa=function(a,b){b=b.af(this.ga.Bd());this.ga.wa(m(new n,function(a,b,f){return function(h){return a.ol.y(h)?f.Na(b.y(h)):void 0}}(this,a,b)));return b.Da()};function Xb(a,b,d){a.ol=d;if(null===b)throw Kg(Lg(),null);a.ga=b;return a}
Yb.prototype.$classData=g({cfa:0},!1,&quot;scala.collection.TraversableLike$WithFilter&quot;,{cfa:1,d:1,lb:1});function qU(){}qU.prototype=new rka;qU.prototype.constructor=qU;function goa(){}goa.prototype=qU.prototype;function rU(){}rU.prototype=new HD;rU.prototype.constructor=rU;function hoa(){}hoa.prototype=rU.prototype;function sU(){this.ga=null}sU.prototype=new l;sU.prototype.constructor=sU;sU.prototype.Uh=function(){return this.ga.bb()};
sU.prototype.af=function(a){return a&amp;&amp;a.$classData&amp;&amp;a.$classData.n.lj?a.md().bb():this.ga.bb()};function cm(a){var b=new sU;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}sU.prototype.$classData=g({efa:0},!1,&quot;scala.collection.generic.GenSetFactory$$anon$1&quot;,{efa:1,d:1,Ps:1});function tU(){this.s=null}tU.prototype=new HD;tU.prototype.constructor=tU;function uU(){}uU.prototype=tU.prototype;tU.prototype.b=function(){this.s=(new vU).tu(this);return this};function wU(){this.ga=null}wU.prototype=new l;
wU.prototype.constructor=wU;function xU(){}xU.prototype=wU.prototype;wU.prototype.Uh=function(){return this.ga.bb()};wU.prototype.af=function(a){return a.md().bb()};wU.prototype.tu=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};function yU(){}yU.prototype=new qka;yU.prototype.constructor=yU;function ioa(){}ioa.prototype=yU.prototype;function zU(){this.oE=null}zU.prototype=new KD;zU.prototype.constructor=zU;
function joa(a,b){a.oE=b;b=new AU;if(null===a)throw Kg(Lg(),null);b.Sa=a}zU.prototype.mC=function(a,b){return rb(this.oE,a,b)};zU.prototype.$classData=g({jfa:0},!1,&quot;scala.collection.immutable.HashMap$$anon$2&quot;,{jfa:1,ofa:1,d:1});function AU(){this.Sa=null}AU.prototype=new KD;AU.prototype.constructor=AU;AU.prototype.mC=function(a,b){return rb(this.Sa.oE,b,a)};AU.prototype.$classData=g({kfa:0},!1,&quot;scala.collection.immutable.HashMap$$anon$2$$anon$3&quot;,{kfa:1,ofa:1,d:1});function BU(){}BU.prototype=new l;
BU.prototype.constructor=BU;c=BU.prototype;c.b=function(){return this};c.y=function(){return this};c.k=function(){return&quot;\x3cfunction1\x3e&quot;};c.Fa=function(){return!!this};c.Ca=function(a){return qb(this,a)};c.$classData=g({xfa:0},!1,&quot;scala.collection.immutable.List$$anon$1&quot;,{xfa:1,d:1,fa:1});function CU(){this.Kc=this.ol=this.qx=null;this.ya=!1}CU.prototype=new l;CU.prototype.constructor=CU;CU.prototype.wa=function(a){(this.ya?this.qx:koa(this)).wa(a)};
function loa(a,b,d){a.ol=d;a.Kc=Ee(b);return a}CU.prototype.xa=function(a,b){return(this.ya?this.qx:koa(this)).xa(a,b)};function koa(a){if(!a.ya){var b=DU(a.Kc,a.ol,!1);a.Kc=null;a.qx=b;a.ya=!0}return a.qx}CU.prototype.$classData=g({ega:0},!1,&quot;scala.collection.immutable.Stream$StreamWithFilter&quot;,{ega:1,d:1,lb:1});function moa(a,b){b=b.lf();switch(b){case -1:break;default:a.tc(b)}}function EU(a,b,d){b=b.lf();switch(b){case -1:break;default:a.tc(b+d|0)}}
function FU(a,b,d){d=d.lf();switch(d){case -1:break;default:a.tc(b&lt;d?b:d)}}var Pw=g({Iha:0},!1,&quot;scala.scalajs.js.Dynamic&quot;,{Iha:1,Gha:1,moa:1},!0,void 0,function(){throw new ba.TypeError(&quot;Cannot call isInstance() on a Class representing a raw JS trait/object&quot;);}),Dha=g({Jha:0},!1,&quot;scala.scalajs.js.Object&quot;,{Jha:1,d:1,Gha:1},!0,void 0,function(a){return a instanceof ba.Object});function Cx(){}Cx.prototype=new l;Cx.prototype.constructor=Cx;Cx.prototype.b=function(){return this};Cx.prototype.Uh=function(){return(new GU).b()};
Cx.prototype.af=function(){return(new GU).b()};Cx.prototype.$classData=g({Mha:0},!1,&quot;scala.scalajs.js.WrappedDictionary$$anon$1&quot;,{Mha:1,d:1,Ps:1});function HU(){}HU.prototype=new l;HU.prototype.constructor=HU;function noa(){}noa.prototype=HU.prototype;HU.prototype.k=function(){return&quot;\x3cfunction0\x3e&quot;};function IU(){}IU.prototype=new l;IU.prototype.constructor=IU;function JU(){}JU.prototype=IU.prototype;IU.prototype.k=function(){return&quot;\x3cfunction1\x3e&quot;};IU.prototype.Fa=function(a){return!!this.y(a)};
IU.prototype.Ca=function(a){return qb(this,a)};function KU(){}KU.prototype=new l;KU.prototype.constructor=KU;function ooa(){}ooa.prototype=KU.prototype;KU.prototype.k=function(){return&quot;\x3cfunction2\x3e&quot;};function LU(){}LU.prototype=new l;LU.prototype.constructor=LU;function poa(){}poa.prototype=LU.prototype;LU.prototype.k=function(){return&quot;\x3cfunction3\x3e&quot;};function MU(){}MU.prototype=new l;MU.prototype.constructor=MU;function qoa(){}qoa.prototype=MU.prototype;MU.prototype.k=function(){return&quot;\x3cfunction4\x3e&quot;};
function ZT(){this.Vv=null;this.Va=this.Xa=0}ZT.prototype=new l;ZT.prototype.constructor=ZT;c=ZT.prototype;c.xv=function(a,b){if(0&gt;a)throw(new NU).Db(a);if(b&gt;this.sa())throw(new NU).Db(b);if(b&lt;=a)return(new ZT).No(this.Vv,0,0);var d=this.Xa+a|0;return(new ZT).No(this.Vv,d,d+(b-a|0)|0)};c.k=function(){var a=this.Xa,a=0&lt;a?a:0,b=this.Vv.l.length,d=a+this.sa()|0,b=b&lt;d?b:d;return a&gt;=b?&quot;&quot;:RE(Ia(),this.Vv,a,b-a|0)};c.sa=function(){var a=this.Va-this.Xa|0;return 0&gt;a?0:a};
c.No=function(a,b,d){this.Vv=a;this.Xa=b;this.Va=d;return this};c.$classData=g({aia:0},!1,&quot;scala.runtime.ArrayCharSequence&quot;,{aia:1,d:1,Fu:1});function AD(){this.Ba=!1}AD.prototype=new l;AD.prototype.constructor=AD;AD.prototype.k=function(){return&quot;&quot;+this.Ba};AD.prototype.td=function(a){this.Ba=a;return this};AD.prototype.$classData=g({bia:0},!1,&quot;scala.runtime.BooleanRef&quot;,{bia:1,d:1,i:1});function rF(a){return!!(a&amp;&amp;a.$classData&amp;&amp;1===a.$classData.Br&amp;&amp;a.$classData.Ar.n.fY)}
var Ba=g({fY:0},!1,&quot;scala.runtime.BoxedUnit&quot;,{fY:1,d:1,i:1},void 0,void 0,function(a){return void 0===a});function Wb(){this.Ba=0}Wb.prototype=new l;Wb.prototype.constructor=Wb;Wb.prototype.tk=function(a){this.Ba=a;return this};Wb.prototype.k=function(){return&quot;&quot;+this.Ba};Wb.prototype.$classData=g({dia:0},!1,&quot;scala.runtime.DoubleRef&quot;,{dia:1,d:1,i:1});function jD(){this.Ba=0}jD.prototype=new l;jD.prototype.constructor=jD;jD.prototype.k=function(){return&quot;&quot;+this.Ba};
jD.prototype.Db=function(a){this.Ba=a;return this};jD.prototype.$classData=g({eia:0},!1,&quot;scala.runtime.IntRef&quot;,{eia:1,d:1,i:1});function Ub(){this.Ba=OA()}Ub.prototype=new l;Ub.prototype.constructor=Ub;Ub.prototype.mD=function(a){this.Ba=a;return this};Ub.prototype.k=function(){var a=this.Ba,b=a.ka,a=a.qa;return OU(Ra(),b,a)};Ub.prototype.$classData=g({iia:0},!1,&quot;scala.runtime.LongRef&quot;,{iia:1,d:1,i:1});function nm(){this.Ba=null}nm.prototype=new l;nm.prototype.constructor=nm;
nm.prototype.k=function(){return DB(Ia(),this.Ba)};nm.prototype.j=function(a){this.Ba=a;return this};nm.prototype.$classData=g({lia:0},!1,&quot;scala.runtime.ObjectRef&quot;,{lia:1,d:1,i:1});function PU(){}PU.prototype=new l;PU.prototype.constructor=PU;function roa(){}roa.prototype=PU.prototype;PU.prototype.qo=function(){};function QU(){}QU.prototype=new l;QU.prototype.constructor=QU;function soa(){}soa.prototype=QU.prototype;QU.prototype.Ha=function(a){a.z()||a.Y();return this};
function RU(){this.xU=this.bC=this.fG=this.yU=this.tp=this.ZD=this.Ap=this.Km=this.Bj=null}RU.prototype=new l;RU.prototype.constructor=RU;function SU(a,b,d){return 0===d?toa(a,b):0===b.ka&amp;&amp;0===b.qa&amp;&amp;0&lt;=d&amp;&amp;d&lt;a.bC.l.length?a.bC.l[d]:(new NR).nD(b,d)}
RU.prototype.b=function(){TU=this;this.Bj=(new NR).ia(0,0);this.Km=(new NR).ia(1,0);this.Ap=(new NR).ia(10,0);this.ZD=uoa(28,5);var a=this.ZD.l.length,b;b=[];for(var d=0;d&lt;a;){var e=UU(0,this.ZD.l[d]);b.push(e);d=1+d|0}ka(Xa(db),b);this.tp=uoa(19,10);a=this.tp.l.length;b=[];for(d=0;d&lt;a;)e=UU(0,this.tp.l[d]),b.push(e),d=1+d|0;this.yU=ka(Xa(db),b);a=[];for(b=0;11&gt;b;)d=b,d=(new NR).ia(d,0),a.push(d),b=1+b|0;this.fG=ka(Xa(voa),a);a=[];for(b=0;11&gt;b;)d=b,d=(new NR).ia(0,d),a.push(d),b=1+b|0;this.bC=ka(Xa(voa),
a);a=[];for(b=0;100&gt;b;)a.push(48),b=1+b|0;this.xU=ka(Xa(ab),a);return this};
function woa(a,b,d,e){var f;if(f=e&lt;a.tp.l.length){f=b.Ae;var h=d.Ae+a.yU.l[e]|0;f=64&gt;(1+(f&gt;h?f:h)|0)}if(f){f=d.Kd;d=f.ka;f=f.qa;var h=a.tp.l[e],k=h.ka;e=65535&amp;d;var p=d&gt;&gt;&gt;16|0,t=65535&amp;k,x=k&gt;&gt;&gt;16|0,E=da(e,t),t=da(p,t),S=da(e,x);e=E+((t+S|0)&lt;&lt;16)|0;E=(E&gt;&gt;&gt;16|0)+S|0;d=(((da(d,h.qa)+da(f,k)|0)+da(p,x)|0)+(E&gt;&gt;&gt;16|0)|0)+(((65535&amp;E)+t|0)&gt;&gt;&gt;16|0)|0;h=b.Kd;f=h.ka;h=h.qa;e=f+e|0;return SU(a,(new Vb).ia(e,(-2147483648^e)&lt;(-2147483648^f)?1+(h+d|0)|0:h+d|0),b.Hb)}a=Jf();f=VU(d);d=(new Vb).ia(e,e&gt;&gt;31);e=a.ZB.l.length;
h=e&gt;&gt;31;k=d.qa;(k===h?(-2147483648^d.ka)&lt;(-2147483648^e):k&lt;h)?(d=a.ZB.l[d.ka],a=f.Ub,e=f.bc,f=f.xb,0===a?a=wf().Bj:1===e?(e=f.l[0],f=65535&amp;e,e=e&gt;&gt;&gt;16|0,k=65535&amp;d,d=d&gt;&gt;&gt;16|0,h=da(f,k),k=da(e,k),p=da(f,d),f=h+((k+p|0)&lt;&lt;16)|0,h=(h&gt;&gt;&gt;16|0)+p|0,d=(da(e,d)+(h&gt;&gt;&gt;16|0)|0)+(((65535&amp;h)+k|0)&gt;&gt;&gt;16|0)|0,a=0===d?(new rf).ia(a,f):qf(new rf,a,2,Qf(Rf(),f,(new w).f([d])))):(h=1+e|0,k=la(Xa(db),[h]),k.l[e]=hg(0,k,f,e,d),a=qf(new rf,a,h,k),uf(a))):a=fg(f,kg(a,d));d=VU(b);return(new NR).bq(Pf(Xf(),d,a),b.Hb)}
function xoa(a,b,d,e){a=0&gt;d?-d|0:d;var f=0===d?0:0&gt;d?-1:1;if(cg().aC===e)return f;if(cg().hz===e)return 0;if(cg().gz===e)return 0&lt;f?f:0;if(cg().kz===e)return 0&gt;f?f:0;if(cg().mz===e)return 5&lt;=a?f:0;if(cg().lz===e)return 5&lt;a?f:0;if(cg().jw===e)return 5&lt;(a+b|0)?f:0;if(cg().$B===e){if(0===d)return 0;throw(new WU).c(&quot;Rounding necessary&quot;);}throw(new q).j(e);}
function XU(a,b){a=b.qa;(-1===a?0&gt;(-2147483648^b.ka):-1&gt;a)?a=!0:(a=b.qa,a=0===a?-1&lt;(-2147483648^b.ka):0&lt;a);if(a)throw(new WU).c(&quot;Out of int range: &quot;+b);return b.ka}function toa(a,b){if(0&lt;=b.qa)var d=b.qa,d=0===d?-2147483637&gt;(-2147483648^b.ka):0&gt;d;else d=!1;return d?a.fG.l[b.ka]:(new NR).nD(b,0)}function UU(a,b){b=0&gt;b.qa?(new Vb).ia(~b.ka,~b.qa):b;a=b.ka;b=b.qa;return 64-(0!==b?fa(b):32+fa(a)|0)|0}
function uoa(a,b){a=la(Xa(eb),[-1+a|0]);var d;d=[];var e,f=e=(new Vb).ia(1,0);d.push(null===f?null:f);for(var f=0,h=a.l.length;f&lt;h;){var k=a.l[f],p=k.ka,t=k.qa,k=Qa(e);e=k.ka;k=k.qa;Qa((new Vb).ia(p,t));var p=b&gt;&gt;31,x=65535&amp;e,t=e&gt;&gt;&gt;16|0,E=65535&amp;b,S=b&gt;&gt;&gt;16|0,U=da(x,E),E=da(t,E),ga=da(x,S),x=U+((E+ga|0)&lt;&lt;16)|0,U=(U&gt;&gt;&gt;16|0)+ga|0;e=(((da(e,p)+da(k,b)|0)+da(t,S)|0)+(U&gt;&gt;&gt;16|0)|0)+(((65535&amp;U)+E|0)&gt;&gt;&gt;16|0)|0;k=e=(new Vb).ia(x,e);d.push(null===k?null:k);f=1+f|0}return ka(Xa(eb),d)}
function yoa(a,b){var d=b.ka;return b.ka===d&amp;&amp;b.qa===d&gt;&gt;31?SU(a,OA(),b.ka):0&lt;=b.qa?(new NR).ia(0,2147483647):(new NR).ia(0,-2147483648)}RU.prototype.$classData=g({VY:0},!1,&quot;java.math.BigDecimal$&quot;,{VY:1,d:1,m:1,i:1});var TU=void 0;function YU(){TU||(TU=(new RU).b());return TU}function ZU(){this.YB=this.ZR=this.Bw=this.Bj=this.Ap=this.Km=null}ZU.prototype=new l;ZU.prototype.constructor=ZU;
ZU.prototype.b=function(){$U=this;this.Km=(new rf).ia(1,1);this.Ap=(new rf).ia(1,10);this.Bj=(new rf).ia(0,0);this.Bw=(new rf).ia(-1,1);var a=(new w).f([this.Bj,this.Km,(new rf).ia(1,2),(new rf).ia(1,3),(new rf).ia(1,4),(new rf).ia(1,5),(new rf).ia(1,6),(new rf).ia(1,7),(new rf).ia(1,8),(new rf).ia(1,9),this.Ap]),b=a.oa.length|0,b=la(Xa(kf),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e;d=1+d|0}this.ZR=b;b=[];for(d=0;32&gt;d;)a=d,a=Tf(wf(),(new Vb).ia(0===(32&amp;a)?1&lt;&lt;a:0,
0===(32&amp;a)?0:1&lt;&lt;a)),b.push(null===a?null:a),d=1+d|0;this.YB=ka(Xa(kf),b);return this};function zoa(a,b){if(b&lt;a.YB.l.length)return a.YB.l[b];a=b&gt;&gt;5;b&amp;=31;var d=la(Xa(db),[1+a|0]);d.l[a]=1&lt;&lt;b;return qf(new rf,1,1+a|0,d)}function Tf(a,b){if(0&gt;b.qa)return-1!==b.ka||-1!==b.qa?(a=b.ka,b=b.qa,Aoa(new rf,-1,(new Vb).ia(-a|0,0!==a?~b:-b|0))):a.Bw;var d=b.qa;return(0===d?-2147483638&gt;=(-2147483648^b.ka):0&gt;d)?a.ZR.l[b.ka]:Aoa(new rf,1,b)}
ZU.prototype.$classData=g({WY:0},!1,&quot;java.math.BigInteger$&quot;,{WY:1,d:1,m:1,i:1});var $U=void 0;function wf(){$U||($U=(new ZU).b());return $U}function aV(){this.kr=this.$B=this.jw=this.lz=this.mz=this.kz=this.gz=this.hz=this.aC=null}aV.prototype=new l;aV.prototype.constructor=aV;
aV.prototype.b=function(){bV=this;this.aC=(new cV).zd(&quot;UP&quot;,0);this.hz=(new cV).zd(&quot;DOWN&quot;,1);this.gz=(new cV).zd(&quot;CEILING&quot;,2);this.kz=(new cV).zd(&quot;FLOOR&quot;,3);this.mz=(new cV).zd(&quot;HALF_UP&quot;,4);this.lz=(new cV).zd(&quot;HALF_DOWN&quot;,5);this.jw=(new cV).zd(&quot;HALF_EVEN&quot;,6);this.$B=(new cV).zd(&quot;UNNECESSARY&quot;,7);var a=(new w).f([this.aC,this.hz,this.gz,this.kz,this.mz,this.lz,this.jw,this.$B]),b=a.oa.length|0,b=la(Xa(Boa),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e;d=1+d|0}this.kr=
b;return this};aV.prototype.$classData=g({eZ:0},!1,&quot;java.math.RoundingMode$&quot;,{eZ:1,d:1,m:1,i:1});var bV=void 0;function cg(){bV||(bV=(new aV).b());return bV}function dV(){SF.call(this)}dV.prototype=new fla;dV.prototype.constructor=dV;dV.prototype.b=function(){SF.prototype.cf.call(this,&quot;/system/tokens-core.txt&quot;,&quot;org.nlogo.core.prim.&quot;);return this};dV.prototype.$classData=g({zZ:0},!1,&quot;org.nlogo.core.DefaultTokenMapper$&quot;,{zZ:1,XH:1,d:1,v_:1});var Coa=void 0;function eV(){this.BG=null;this.a=!1}
eV.prototype=new l;eV.prototype.constructor=eV;eV.prototype.b=function(){fV=this;this.BG=(new gV).os(I(pc().Th,y()));this.a=!0;return this};function Xda(a,b){return(new gV).os(I(pc().Th,y()).Rc(b,(Lk(),Mk().qc)))}function Doa(){var a=Qo();if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/LogoList.scala: 9&quot;);return a.BG}eV.prototype.$classData=g({MZ:0},!1,&quot;org.nlogo.core.LogoList$&quot;,{MZ:1,d:1,m:1,i:1});var fV=void 0;
function Qo(){fV||(fV=(new eV).b());return fV}function hV(){this.hT=this.jT=null;this.ya=0}hV.prototype=new l;hV.prototype.constructor=hV;hV.prototype.b=function(){return this};function Eoa(){var a=Foa();if(0===(2&amp;a.ya)&amp;&amp;0===(2&amp;a.ya)){var b=rj(),d=I(r(),(new w).f(&quot;default;0.0;-0.2 0 0.0 1.0;0.0 1 1.0 0.0;0.2 0 0.0 1.0;link direction;true;0;Line -7500403 true 150 150 90 180;Line -7500403 true 150 150 210 180&quot;.split(&quot;;&quot;))).Oa();a.hT=pca(b,d.Ic()).ub();a.ya=(2|a.ya)&lt;&lt;24&gt;&gt;24}return a.hT}
function Goa(){var a=Foa();if(0===(1&amp;a.ya)&amp;&amp;0===(1&amp;a.ya)){var b=rj(),d=I(r(),(new w).f(&quot;default;true;0;Polygon -7500403 true true 150 5 40 250 150 205 260 250;;airplane;true;0;Polygon -7500403 true true 150 0 135 15 120 60 120 105 15 165 15 195 120 180 135 240 105 270 120 285 150 270 180 285 210 270 165 240 180 180 285 195 285 165 180 105 180 60 165 15;;arrow;true;0;Polygon -7500403 true true 150 0 0 150 105 150 105 293 195 293 195 150 300 150;;box;false;0;Polygon -7500403 true true 150 285 285 225 285 75 150 135;Polygon -7500403 true true 150 135 15 75 150 15 285 75;Polygon -7500403 true true 15 75 15 225 150 285 150 135;Line -16777216 false 150 285 150 135;Line -16777216 false 150 135 15 75;Line -16777216 false 150 135 285 75;;bug;true;0;Circle -7500403 true true 96 182 108;Circle -7500403 true true 110 127 80;Circle -7500403 true true 110 75 80;Line -7500403 true 150 100 80 30;Line -7500403 true 150 100 220 30;;butterfly;true;0;Polygon -7500403 true true 150 165 209 199 225 225 225 255 195 270 165 255 150 240;Polygon -7500403 true true 150 165 89 198 75 225 75 255 105 270 135 255 150 240;Polygon -7500403 true true 139 148 100 105 55 90 25 90 10 105 10 135 25 180 40 195 85 194 139 163;Polygon -7500403 true true 162 150 200 105 245 90 275 90 290 105 290 135 275 180 260 195 215 195 162 165;Polygon -16777216 true false 150 255 135 225 120 150 135 120 150 105 165 120 180 150 165 225;Circle -16777216 true false 135 90 30;Line -16777216 false 150 105 195 60;Line -16777216 false 150 105 105 60;;car;false;0;Polygon -7500403 true true 300 180 279 164 261 144 240 135 226 132 213 106 203 84 185 63 159 50 135 50 75 60 0 150 0 165 0 225 300 225 300 180;Circle -16777216 true false 180 180 90;Circle -16777216 true false 30 180 90;Polygon -16777216 true false 162 80 132 78 134 135 209 135 194 105 189 96 180 89;Circle -7500403 true true 47 195 58;Circle -7500403 true true 195 195 58;;circle;false;0;Circle -7500403 true true 0 0 300;;circle 2;false;0;Circle -7500403 true true 0 0 300;Circle -16777216 true false 30 30 240;;cow;false;0;Polygon -7500403 true true 200 193 197 249 179 249 177 196 166 187 140 189 93 191 78 179 72 211 49 209 48 181 37 149 25 120 25 89 45 72 103 84 179 75 198 76 252 64 272 81 293 103 285 121 255 121 242 118 224 167;Polygon -7500403 true true 73 210 86 251 62 249 48 208;Polygon -7500403 true true 25 114 16 195 9 204 23 213 25 200 39 123;;cylinder;false;0;Circle -7500403 true true 0 0 300;;dot;false;0;Circle -7500403 true true 90 90 120;;face happy;false;0;Circle -7500403 true true 8 8 285;Circle -16777216 true false 60 75 60;Circle -16777216 true false 180 75 60;Polygon -16777216 true false 150 255 90 239 62 213 47 191 67 179 90 203 109 218 150 225 192 218 210 203 227 181 251 194 236 217 212 240;;face neutral;false;0;Circle -7500403 true true 8 7 285;Circle -16777216 true false 60 75 60;Circle -16777216 true false 180 75 60;Rectangle -16777216 true false 60 195 240 225;;face sad;false;0;Circle -7500403 true true 8 8 285;Circle -16777216 true false 60 75 60;Circle -16777216 true false 180 75 60;Polygon -16777216 true false 150 168 90 184 62 210 47 232 67 244 90 220 109 205 150 198 192 205 210 220 227 242 251 229 236 206 212 183;;fish;false;0;Polygon -1 true false 44 131 21 87 15 86 0 120 15 150 0 180 13 214 20 212 45 166;Polygon -1 true false 135 195 119 235 95 218 76 210 46 204 60 165;Polygon -1 true false 75 45 83 77 71 103 86 114 166 78 135 60;Polygon -7500403 true true 30 136 151 77 226 81 280 119 292 146 292 160 287 170 270 195 195 210 151 212 30 166;Circle -16777216 true false 215 106 30;;flag;false;0;Rectangle -7500403 true true 60 15 75 300;Polygon -7500403 true true 90 150 270 90 90 30;Line -7500403 true 75 135 90 135;Line -7500403 true 75 45 90 45;;flower;false;0;Polygon -10899396 true false 135 120 165 165 180 210 180 240 150 300 165 300 195 240 195 195 165 135;Circle -7500403 true true 85 132 38;Circle -7500403 true true 130 147 38;Circle -7500403 true true 192 85 38;Circle -7500403 true true 85 40 38;Circle -7500403 true true 177 40 38;Circle -7500403 true true 177 132 38;Circle -7500403 true true 70 85 38;Circle -7500403 true true 130 25 38;Circle -7500403 true true 96 51 108;Circle -16777216 true false 113 68 74;Polygon -10899396 true false 189 233 219 188 249 173 279 188 234 218;Polygon -10899396 true false 180 255 150 210 105 210 75 240 135 240;;house;false;0;Rectangle -7500403 true true 45 120 255 285;Rectangle -16777216 true false 120 210 180 285;Polygon -7500403 true true 15 120 150 15 285 120;Line -16777216 false 30 120 270 120;;leaf;false;0;Polygon -7500403 true true 150 210 135 195 120 210 60 210 30 195 60 180 60 165 15 135 30 120 15 105 40 104 45 90 60 90 90 105 105 120 120 120 105 60 120 60 135 30 150 15 165 30 180 60 195 60 180 120 195 120 210 105 240 90 255 90 263 104 285 105 270 120 285 135 240 165 240 180 270 195 240 210 180 210 165 195;Polygon -7500403 true true 135 195 135 240 120 255 105 255 105 285 135 285 165 240 165 195;;line;true;0;Line -7500403 true 150 0 150 300;;line half;true;0;Line -7500403 true 150 0 150 150;;pentagon;false;0;Polygon -7500403 true true 150 15 15 120 60 285 240 285 285 120;;person;false;0;Circle -7500403 true true 110 5 80;Polygon -7500403 true true 105 90 120 195 90 285 105 300 135 300 150 225 165 300 195 300 210 285 180 195 195 90;Rectangle -7500403 true true 127 79 172 94;Polygon -7500403 true true 195 90 240 150 225 180 165 105;Polygon -7500403 true true 105 90 60 150 75 180 135 105;;plant;false;0;Rectangle -7500403 true true 135 90 165 300;Polygon -7500403 true true 135 255 90 210 45 195 75 255 135 285;Polygon -7500403 true true 165 255 210 210 255 195 225 255 165 285;Polygon -7500403 true true 135 180 90 135 45 120 75 180 135 210;Polygon -7500403 true true 165 180 165 210 225 180 255 120 210 135;Polygon -7500403 true true 135 105 90 60 45 45 75 105 135 135;Polygon -7500403 true true 165 105 165 135 225 105 255 45 210 60;Polygon -7500403 true true 135 90 120 45 150 15 180 45 165 90;;sheep;false;15;Circle -1 true true 203 65 88;Circle -1 true true 70 65 162;Circle -1 true true 150 105 120;Polygon -7500403 true false 218 120 240 165 255 165 278 120;Circle -7500403 true false 214 72 67;Rectangle -1 true true 164 223 179 298;Polygon -1 true true 45 285 30 285 30 240 15 195 45 210;Circle -1 true true 3 83 150;Rectangle -1 true true 65 221 80 296;Polygon -1 true true 195 285 210 285 210 240 240 210 195 210;Polygon -7500403 true false 276 85 285 105 302 99 294 83;Polygon -7500403 true false 219 85 210 105 193 99 201 83;;square;false;0;Rectangle -7500403 true true 30 30 270 270;;square 2;false;0;Rectangle -7500403 true true 30 30 270 270;Rectangle -16777216 true false 60 60 240 240;;star;false;0;Polygon -7500403 true true 151 1 185 108 298 108 207 175 242 282 151 216 59 282 94 175 3 108 116 108;;target;false;0;Circle -7500403 true true 0 0 300;Circle -16777216 true false 30 30 240;Circle -7500403 true true 60 60 180;Circle -16777216 true false 90 90 120;Circle -7500403 true true 120 120 60;;tree;false;0;Circle -7500403 true true 118 3 94;Rectangle -6459832 true false 120 195 180 300;Circle -7500403 true true 65 21 108;Circle -7500403 true true 116 41 127;Circle -7500403 true true 45 90 120;Circle -7500403 true true 104 74 152;;triangle;false;0;Polygon -7500403 true true 150 30 15 255 285 255;;triangle 2;false;0;Polygon -7500403 true true 150 30 15 255 285 255;Polygon -16777216 true false 151 99 225 223 75 224;;truck;false;0;Rectangle -7500403 true true 4 45 195 187;Polygon -7500403 true true 296 193 296 150 259 134 244 104 208 104 207 194;Rectangle -1 true false 195 60 195 105;Polygon -16777216 true false 238 112 252 141 219 141 218 112;Circle -16777216 true false 234 174 42;Rectangle -7500403 true true 181 185 214 194;Circle -16777216 true false 144 174 42;Circle -16777216 true false 24 174 42;Circle -7500403 false true 24 174 42;Circle -7500403 false true 144 174 42;Circle -7500403 false true 234 174 42;;turtle;true;0;Polygon -10899396 true false 215 204 240 233 246 254 228 266 215 252 193 210;Polygon -10899396 true false 195 90 225 75 245 75 260 89 269 108 261 124 240 105 225 105 210 105;Polygon -10899396 true false 105 90 75 75 55 75 40 89 31 108 39 124 60 105 75 105 90 105;Polygon -10899396 true false 132 85 134 64 107 51 108 17 150 2 192 18 192 52 169 65 172 87;Polygon -10899396 true false 85 204 60 233 54 254 72 266 85 252 107 210;Polygon -7500403 true true 119 75 179 75 209 101 224 135 220 225 175 261 128 261 81 224 74 135 88 99;;wheel;false;0;Circle -7500403 true true 3 3 294;Circle -16777216 true false 30 30 240;Line -7500403 true 150 285 150 15;Line -7500403 true 15 150 285 150;Circle -7500403 true true 120 120 60;Line -7500403 true 216 40 79 269;Line -7500403 true 40 84 269 221;Line -7500403 true 40 216 269 79;Line -7500403 true 84 40 221 269;;wolf;false;0;Polygon -16777216 true false 253 133 245 131 245 133;Polygon -7500403 true true 2 194 13 197 30 191 38 193 38 205 20 226 20 257 27 265 38 266 40 260 31 253 31 230 60 206 68 198 75 209 66 228 65 243 82 261 84 268 100 267 103 261 77 239 79 231 100 207 98 196 119 201 143 202 160 195 166 210 172 213 173 238 167 251 160 248 154 265 169 264 178 247 186 240 198 260 200 271 217 271 219 262 207 258 195 230 192 198 210 184 227 164 242 144 259 145 284 151 277 141 293 140 299 134 297 127 273 119 270 105;Polygon -7500403 true true -1 195 14 180 36 166 40 153 53 140 82 131 134 133 159 126 188 115 227 108 236 102 238 98 268 86 269 92 281 87 269 103 269 113;;x;false;0;Polygon -7500403 true true 270 75 225 30 30 225 75 270;Polygon -7500403 true true 30 75 75 30 270 225 225 270&quot;.split(&quot;;&quot;))).Oa();
a.jT=rca(b,d.Ic()).ub();a.ya=(1|a.ya)&lt;&lt;24&gt;&gt;24}return a.jT}hV.prototype.$classData=g({NZ:0},!1,&quot;org.nlogo.core.Model$&quot;,{NZ:1,d:1,m:1,i:1});var Hoa=void 0;function Foa(){Hoa||(Hoa=(new hV).b());return Hoa}function iV(){}iV.prototype=new l;iV.prototype.constructor=iV;iV.prototype.b=function(){return this};iV.prototype.$classData=g({WZ:0},!1,&quot;org.nlogo.core.NumericInput$&quot;,{WZ:1,d:1,m:1,i:1});var Ioa=void 0;function jV(){this.fe=this.ji=null;this.bz=0;this.ra=null;this.a=!1}jV.prototype=new l;
jV.prototype.constructor=jV;jV.prototype.Lc=function(){if(!this.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AstNode.scala: 65&quot;);return this.ra};function Mb(a,b,d){var e=new jV;e.ji=a;e.fe=b;e.bz=d;b=UO(a).ra.Xa;a=UO(a);e.ra=Lm(new Mm,b,d,a.ra.ab);e.a=!0;return e}jV.prototype.$classData=g({uH:0},!1,&quot;org.nlogo.core.ProcedureDefinition&quot;,{uH:1,d:1,up:1,co:1});function kV(){}kV.prototype=new l;kV.prototype.constructor=kV;kV.prototype.b=function(){return this};
function ws(){var a=qQ(),b=CF(pQ(a)),d=DF(pQ(a)),e=EF(pQ(a)),f=I(r(),y()),h=I(r(),y()),k=nh(oh(),y()),p=nh(oh(),y());return Cp(f,h,b,d,e,k,p,a)}kV.prototype.$classData=g({c_:0},!1,&quot;org.nlogo.core.Program$&quot;,{c_:1,d:1,m:1,i:1});var Joa=void 0;function vs(){Joa||(Joa=(new kV).b());return Joa}function lV(){this.uG=null;this.a=!1}lV.prototype=new l;lV.prototype.constructor=lV;lV.prototype.b=function(){this.uG=&quot;default&quot;;this.a=!0;return this};
function Koa(a){if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ShapeList.scala: 10&quot;);return a.uG}function hga(a,b){a=m(new n,function(){return function(a){var b=a.me();return(new A).e(b,a)}}(a));var d=Lc();return b.xa(a,d.s).te($e().Fk)}lV.prototype.$classData=g({h_:0},!1,&quot;org.nlogo.core.ShapeList$&quot;,{h_:1,d:1,m:1,i:1});var Loa=void 0;function Vt(){Loa||(Loa=(new lV).b());return Loa}function Fb(){this.Zf=this.Yr=null;this.oe=!1}Fb.prototype=new l;
Fb.prototype.constructor=Fb;c=Fb.prototype;c.ns=function(a,b,d){this.Yr=a;this.Zf=b;this.oe=d;return this};c.Ro=function(a,b){Fb.prototype.ns.call(this,a,b,!1);return this};c.Lc=function(){if(this.Zf.z())return Lm(new Mm,0,0,this.Yr);var a=this.Zf.W(0).Lc().Xa,b=this.Zf.gd();return Lm(new Mm,a,b.Lc().Va,this.Yr)};c.k=function(){return this.Zf.zb(&quot; &quot;)};c.c=function(a){Fb.prototype.ns.call(this,a,I(r(),y()),!1);return this};c.$classData=g({Dz:0},!1,&quot;org.nlogo.core.Statements&quot;,{Dz:1,d:1,up:1,co:1});
function mV(){}mV.prototype=new l;mV.prototype.constructor=mV;mV.prototype.b=function(){return this};mV.prototype.$classData=g({n_:0},!1,&quot;org.nlogo.core.StringInput$&quot;,{n_:1,d:1,m:1,i:1});var Moa=void 0;function nV(){this.Rd=null;this.a=!1}nV.prototype=new l;nV.prototype.constructor=nV;nV.prototype.b=function(){Noa=this;vs();this.Rd=Gp(new Hp,ws(),(Kp(),ph()),(Kp(),nh($e().kk,y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())));this.a=!0;return this};
nV.prototype.$classData=g({r_:0},!1,&quot;org.nlogo.core.StructureResults$&quot;,{r_:1,d:1,m:1,i:1});var Noa=void 0;function Kp(){Noa||(Noa=(new nV).b())}function oV(){this.a=this.JR=this.qG=this.eS=this.mG=this.NR=this.UR=this.kG=this.VR=this.OR=this.LR=this.iG=this.pG=this.TR=this.mS=this.SR=this.cG=this.WR=this.rG=this.SG=this.PR=this.hS=this.IR=this.dG=this.TG=this.QR=this.iS=this.UG=this.dS=this.jG=this.MR=this.kS=0}oV.prototype=new l;oV.prototype.constructor=oV;
function Rj(a){if(0===(32&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 203&quot;);return a.iS}
oV.prototype.b=function(){pV=this;this.kS=0;this.a|=1;this.MR=1;this.a|=2;this.jG=2;this.a|=4;this.dS=4;this.a|=8;this.UG=8;this.a|=16;this.iS=16;this.a|=32;this.QR=32;this.a|=64;this.TG=64;this.a|=128;this.dG=Rj(this)|Sj(this)|Tj(this);this.a|=256;this.IR=128;this.a|=512;this.hS=256;this.a|=1024;this.PR=512;this.a|=2048;this.SG=1024;this.a|=4096;this.rG=2048;this.a|=8192;this.WR=4096;this.a|=16384;this.cG=Uj(this)|Vj(this)|Wj(this);this.a|=32768;this.SR=N(this)|Nj(this)|Oj(this)|Pj(this)|Mj(this);
this.a|=65536;this.mS=N(this)|Nj(this)|Oj(this)|Pj(this)|Lj(this)|Qj(this)|Mj(this)|Yj(this)|Xj(this);this.a|=131072;this.TR=8192;this.a|=262144;this.pG=16384;this.a|=524288;this.iG=32768;this.a|=1048576;this.LR=65536;this.a|=2097152;this.OR=131072;this.a|=4194304;this.VR=ck(this)|dk(this)|bk(this);this.a|=8388608;this.kG=Pj(this)|Zj(this)|ak(this);this.a|=16777216;this.UR=262144;this.a|=33554432;this.NR=524288;this.a|=67108864;this.mG=1048576;this.a|=134217728;this.eS=2097152;this.a|=268435456;this.qG=
0;this.a|=536870912;this.JR=10;this.a|=1073741824;return this};function Jj(){var a=D();if(0===(262144&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 270&quot;);return a.TR}function oc(a,b,d,e,f,h,k,p){var t=new H;if(0===(536870912&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 318&quot;);return G(t,a.qG,nc(),b,nc(),d,e,!1,f,h,k||h.ba(),p)}
function uk(){var a=D();if(0===(134217728&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 311&quot;);return a.mG}function ck(a){if(0===(1048576&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 278&quot;);return a.iG}
function Kj(){var a=D();if(0===(16777216&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 292&quot;);return a.kG}function Gn(a,b,d){return 0!==(b&amp;d)}function C(){var a=D();if(0===(1073741824&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 319&quot;);return a.JR}
function ak(a){if(0===(8388608&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 291&quot;);return a.VR}function Sj(a){if(0===(64&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 208&quot;);return a.QR}function Ij(){var a=D();if(0===(33554432&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 299&quot;);return a.UR}
function Zr(){var a=D();if(0===(65536&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 261&quot;);return a.SR}function Lj(a){if(0===(32768&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 255&quot;);return a.cG}function xk(){var a=D();if(0===(268435456&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 316&quot;);return a.eS}
function Pj(a){if(0===(16&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 198&quot;);return a.UG}function Wj(a){if(0===(4096&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 239&quot;);return a.SG}function yk(){var a=D();if(0===(67108864&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 306&quot;);return a.NR}
function Uj(a){if(0===(1024&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 229&quot;);return a.hS}function Zj(a){if(0===(524288&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 274&quot;);return a.pG}function bk(a){if(0===(4194304&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 286&quot;);return a.OR}
function N(a){if(0===(2&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 183&quot;);return a.MR}function Xj(a){if(0===(16384&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 249&quot;);return a.WR}function Oj(a){if(0===(8&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 193&quot;);return a.dS}
function Mj(a){if(0===(512&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 224&quot;);return a.IR}function Nj(a){if(0===(4&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 188&quot;);return a.jG}function Tj(a){if(0===(128&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 213&quot;);return a.TG}
function nc(){var a=D();if(0===(1&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 180&quot;);return a.kS}function Vj(a){if(0===(2048&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 234&quot;);return a.PR}function Qj(a){if(0===(256&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 219&quot;);return a.dG}
function dk(a){if(0===(2097152&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 282&quot;);return a.LR}function lc(){var a=D();if(0===(131072&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 268&quot;);return a.mS}function Yj(a){if(0===(8192&amp;a.a))throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 244&quot;);return a.rG}
oV.prototype.$classData=g({t_:0},!1,&quot;org.nlogo.core.Syntax$&quot;,{t_:1,d:1,m:1,i:1});var pV=void 0;function D(){pV||(pV=(new oV).b());return pV}function qV(){this.DG=null;this.a=!1}qV.prototype=new l;qV.prototype.constructor=qV;qV.prototype.b=function(){rV=this;this.DG=Jm(new Km,&quot;&quot;,Dc(),&quot;&quot;,Lm(new Mm,2147483647,2147483647,&quot;&quot;));this.a=!0;return this};
function Nm(){var a;rV||(rV=(new qV).b());a=rV;if(!a.a)throw(new z).c(&quot;Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Token.scala: 15&quot;);return a.DG}qV.prototype.$classData=g({u_:0},!1,&quot;org.nlogo.core.Token$&quot;,{u_:1,d:1,m:1,i:1});var rV=void 0;function sV(){}sV.prototype=new l;sV.prototype.constructor=sV;function Ooa(){}Ooa.prototype=sV.prototype;sV.prototype.Db=function(){return this};function bl(){}bl.prototype=new eO;bl.prototype.constructor=bl;c=bl.prototype;c.b=function(){return this};
c.Jl=function(a){B();a=(new w).f([void 0,a.Wa,a.fb,a.Pa,a.eb,a.Ya,a.uc,a.Ko,void 0,void 0,a.Pm,void 0,a.io,void 0,void 0,a.zo?0:1]);var b=B().s;return L(a,b)};
c.Kl=function(a){a:{B();var b=(new J).j(a);if(null!==b.U&amp;&amp;0===Ig(b.U,16)){var d=b.U.W(1),e=b.U.W(2),f=b.U.W(3),h=b.U.W(4),k=b.U.W(5),p=b.U.W(6),t=b.U.W(7),x=b.U.W(10),E=b.U.W(12),b=b.U.W(15);if(Pa(d)&amp;&amp;(d|=0,Pa(e)&amp;&amp;(e|=0,Pa(f)&amp;&amp;(f|=0,Pa(h)&amp;&amp;(h|=0,tV(k)&amp;&amp;tV(p)&amp;&amp;&quot;boolean&quot;===typeof t&amp;&amp;(t=!!t,x&amp;&amp;x.$classData&amp;&amp;x.$classData.n.nw&amp;&amp;tV(E)&amp;&amp;Pa(b)))))))break a}throw(new q).j(a);}return Poa(p,d|0,e|0,f|0,h|0,k,!!t,x,E,0===(b|0))};c.Pl=function(){return(new Qn).xg(pa(Qoa))};
c.Dh=function(){B();var a=(new uV).c(&quot;BUTTON&quot;),b=(new vV).Ha(F()),d=(new vV).Ha(F()),e=(new vV).Ha(F()),f=(new vV).Ha(F()),h=wV(new xV,(new yV).Ha(F())),k=wV(new xV,(new zV).Ha(F())),p=(new AV).Ha(F()),t=(new BV).c(&quot;1&quot;),x=(new BV).c(&quot;T&quot;);B();var E=uj(),E=(new A).e(&quot;OBSERVER&quot;,E),S=wj(),S=(new A).e(&quot;PATCH&quot;,S),U=vj(),U=(new A).e(&quot;TURTLE&quot;,U),ga=xj(),E=(new w).f([E,S,U,(new A).e(&quot;LINK&quot;,ga)]),S=B().s,a=(new w).f([a,b,d,e,f,h,k,p,t,x,(new CV).hq(L(E,S)),(new BV).c(&quot;NIL&quot;),wV(new xV,(new DV).Ha(F())),(new BV).c(&quot;NIL&quot;),
(new BV).c(&quot;NIL&quot;),(new vV).Ha(F())]),b=B().s;return L(a,b)};c.$classData=g({Q_:0},!1,&quot;org.nlogo.core.model.ButtonReader$&quot;,{Q_:1,Fm:1,d:1,Gm:1});var al=void 0;function nl(){}nl.prototype=new eO;nl.prototype.constructor=nl;c=nl.prototype;c.b=function(){return this};function Roa(a,b){if(Ph()===b)return&quot;nobody&quot;;if(Zg(b)){Qo();var d=Mk().qc,d=Mc(b,d);for(b=Ok(b.Ac);b.qi;){var e=b.ma();d.Na(Roa(a,e))}return Xda(0,d.Da())}return b}
function Soa(a,b){B();var d=b.Wa,e=b.fb,f=b.Pa,h=b.eb,k=b.Ya,p=b.kd,t=b.po;a=function(){return function(a){var b=Eo();a=a.Cl();return $b(b,a,!0,!1)}}(a);var x=B().s;if(x===B().s)if(t===y())a=y();else{for(var x=t.$(),E=x=Cd(new Dd,a(x),y()),t=t.aa();t!==y();)var S=t.$(),S=Cd(new Dd,a(S),y()),E=E.Ia=S,t=t.aa();a=x}else{for(x=Mc(t,x);!t.z();)E=t.$(),x.Na(a(E)),t=t.aa();a=x.Da()}b=(new w).f([void 0,d,e,f,h,k,p,a.zb(&quot; &quot;),b.vo]);d=B().s;return L(b,d)}c.Jl=function(a){return Soa(this,a)};
</P>
c.Kl=function(a){return Toa(this,a)};</LI></DIV></DIV></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
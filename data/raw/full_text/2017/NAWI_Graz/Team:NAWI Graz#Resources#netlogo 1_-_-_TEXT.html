Team:NAWI Graz/Resources/netlogo 1
<style>/* BASICS */
.CodeMirror {
/* Set height, width, borders, and global font properties here */  font-family: monospace;  height: 300px;  color: black;
}
/* PADDING */
.CodeMirror-lines {
padding: 4px 0; /* Vertical padding around content */
} .CodeMirror pre {
padding: 0 4px; /* Horizontal padding of content */
}
.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
background-color: white; /* The little square between H and V scrollbars */
}
/* GUTTER */
.CodeMirror-gutters {
border-right: 1px solid #ddd;  background-color: #f7f7f7;  white-space: nowrap;
} .CodeMirror-linenumbers {} .CodeMirror-linenumber {
padding: 0 3px 0 5px;  min-width: 20px;  text-align: right;  color: #999;  white-space: nowrap;
}
.CodeMirror-guttermarker { color: black; } .CodeMirror-guttermarker-subtle { color: #999; }
/* CURSOR */
.CodeMirror-cursor {
border-left: 1px solid black;  border-right: none;  width: 0;
} /* Shown when moving in bi-directional text */ .CodeMirror div.CodeMirror-secondarycursor {
border-left: 1px solid silver;
} .cm-fat-cursor .CodeMirror-cursor {
width: auto;  border: 0 !important;  background: #7e7;
} .cm-fat-cursor div.CodeMirror-cursors {
z-index: 1;
}
.cm-animate-fat-cursor {
width: auto;  border: 0;  -webkit-animation: blink 1.06s steps(1) infinite;  -moz-animation: blink 1.06s steps(1) infinite;  animation: blink 1.06s steps(1) infinite;  background-color: #7e7;
} @-moz-keyframes blink {
0% {}  50% { background-color: transparent; }  100% {}
} @-webkit-keyframes blink {
0% {}  50% { background-color: transparent; }  100% {}
} @keyframes blink {
0% {}  50% { background-color: transparent; }  100% {}
}
/* Can style cursor different in overwrite (non-insert) mode */ .CodeMirror-overwrite .CodeMirror-cursor {}
.cm-tab { display: inline-block; text-decoration: inherit; }
.CodeMirror-rulers {
position: absolute;  left: 0; right: 0; top: -50px; bottom: -20px;  overflow: hidden;
} .CodeMirror-ruler {
border-left: 1px solid #ccc;  top: 0; bottom: 0;  position: absolute;
}
/* DEFAULT THEME */
.cm-s-default .cm-header {color: blue;} .cm-s-default .cm-quote {color: #090;} .cm-negative {color: #d44;} .cm-positive {color: #292;} .cm-header, .cm-strong {font-weight: bold;} .cm-em {font-style: italic;} .cm-link {text-decoration: underline;} .cm-strikethrough {text-decoration: line-through;}
.cm-s-default .cm-keyword {color: #708;} .cm-s-default .cm-atom {color: #219;} .cm-s-default .cm-number {color: #164;} .cm-s-default .cm-def {color: #00f;} .cm-s-default .cm-variable, .cm-s-default .cm-punctuation, .cm-s-default .cm-property, .cm-s-default .cm-operator {} .cm-s-default .cm-variable-2 {color: #05a;} .cm-s-default .cm-variable-3 {color: #085;} .cm-s-default .cm-comment {color: #a50;} .cm-s-default .cm-string {color: #a11;} .cm-s-default .cm-string-2 {color: #f50;} .cm-s-default .cm-meta {color: #555;} .cm-s-default .cm-qualifier {color: #555;} .cm-s-default .cm-builtin {color: #30a;} .cm-s-default .cm-bracket {color: #997;} .cm-s-default .cm-tag {color: #170;} .cm-s-default .cm-attribute {color: #00c;} .cm-s-default .cm-hr {color: #999;} .cm-s-default .cm-link {color: #00c;}
.cm-s-default .cm-error {color: #f00;} .cm-invalidchar {color: #f00;}
.CodeMirror-composing { border-bottom: 2px solid; }
/* Default styles for common addons */
div.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;} div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;} .CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); } .CodeMirror-activeline-background {background: #e8f2ff;}
/* STOP */
/* The rest of this file contains styles related to the mechanics of
the editor. You probably shouldn't touch them. */
.CodeMirror {
position: relative;  overflow: hidden;  background: white;
}
.CodeMirror-scroll {
overflow: scroll !important; /* Things will break if this is overridden */  /* 30px is the magic margin used to hide the element's real scrollbars */  /* See overflow: hidden in .CodeMirror */  margin-bottom: -30px; margin-right: -30px;  padding-bottom: 30px;  height: 100%;  outline: none; /* Prevent dragging from highlighting the element */  position: relative;
} .CodeMirror-sizer {
position: relative;  border-right: 30px solid transparent;
}
/* The fake, visible scrollbars. Used to force redraw during scrolling
before actual scrolling happens, thus preventing shaking and   flickering artifacts. */
.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
position: absolute;  z-index: 6;  display: none;
} .CodeMirror-vscrollbar {
right: 0; top: 0;  overflow-x: hidden;  overflow-y: scroll;
} .CodeMirror-hscrollbar {
bottom: 0; left: 0;  overflow-y: hidden;  overflow-x: scroll;
} .CodeMirror-scrollbar-filler {
right: 0; bottom: 0;
} .CodeMirror-gutter-filler {
left: 0; bottom: 0;
}
.CodeMirror-gutters {
position: absolute; left: 0; top: 0;  min-height: 100%;  z-index: 3;
} .CodeMirror-gutter {
white-space: normal;  height: 100%;  display: inline-block;  vertical-align: top;  margin-bottom: -30px;
} .CodeMirror-gutter-wrapper {
position: absolute;  z-index: 4;  background: none !important;  border: none !important;
} .CodeMirror-gutter-background {
position: absolute;  top: 0; bottom: 0;  z-index: 4;
} .CodeMirror-gutter-elt {
position: absolute;  cursor: default;  z-index: 4;
} .CodeMirror-gutter-wrapper {
-webkit-user-select: none;  -moz-user-select: none;  user-select: none;
}
.CodeMirror-lines {
cursor: text;  min-height: 1px; /* prevents collapsing before first draw */
} .CodeMirror pre {
/* Reset some styles that the rest of the page might have set */  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;  border-width: 0;  background: transparent;  font-family: inherit;  font-size: inherit;  margin: 0;  white-space: pre;  word-wrap: normal;  line-height: inherit;  color: inherit;  z-index: 2;  position: relative;  overflow: visible;  -webkit-tap-highlight-color: transparent;  -webkit-font-variant-ligatures: contextual;  font-variant-ligatures: contextual;
} .CodeMirror-wrap pre {
word-wrap: break-word;  white-space: pre-wrap;  word-break: normal;
}
.CodeMirror-linebackground {
position: absolute;  left: 0; right: 0; top: 0; bottom: 0;  z-index: 0;
}
.CodeMirror-linewidget {
position: relative;  z-index: 2;  overflow: auto;
}
.CodeMirror-widget {}
.CodeMirror-code {
outline: none;
}
/* Force content-box sizing for the elements where we expect it */ .CodeMirror-scroll, .CodeMirror-sizer, .CodeMirror-gutter, .CodeMirror-gutters, .CodeMirror-linenumber {
-moz-box-sizing: content-box;  box-sizing: content-box;
}
.CodeMirror-measure {
position: absolute;  width: 100%;  height: 0;  overflow: hidden;  visibility: hidden;
}
.CodeMirror-cursor {
position: absolute;  pointer-events: none;
} .CodeMirror-measure pre { position: static; }
div.CodeMirror-cursors {
visibility: hidden;  position: relative;  z-index: 3;
} div.CodeMirror-dragcursors {
visibility: visible;
}
.CodeMirror-focused div.CodeMirror-cursors {
visibility: visible;
}
.CodeMirror-selected { background: #d9d9d9; } .CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; } .CodeMirror-crosshair { cursor: crosshair; } .CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; } .CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }
.cm-searching {
background: #ffa;  background: rgba(255, 255, 0, .4);
}
/* Used to force a border model for a node */ .cm-force-border { padding-right: .1px; }
@media print {
/* Hide the cursor when printing */  .CodeMirror div.CodeMirror-cursors {    visibility: hidden;  }
}
/* See issue #2901 */ .cm-tab-wrap-hack:after { content: ; }
/* Help users use markselection to safely style text background */ span.CodeMirror-selectedtext { background: none; } </style>
<style>.CodeMirror-dialog {  position: absolute;  left: 0; right: 0;  background: inherit;  z-index: 15;  padding: .1em .8em;  overflow: hidden;  color: inherit;
}
.CodeMirror-dialog-top {
border-bottom: 1px solid #eee;  top: 0;
}
.CodeMirror-dialog-bottom {
border-top: 1px solid #eee;  bottom: 0;
}
.CodeMirror-dialog input {
border: none;  outline: none;  background: transparent;  width: 20em;  color: inherit;  font-family: monospace;
}
.CodeMirror-dialog button {
font-size: 70%;
} </style>
<style>/* * This file should contain generally useful css classes - "round the corners", "add the font", etc. * Where possible, css for certain elements should be moved out, although there are clearly some exceptions. */
.hidden {
display: none;
}
.rounded {
border-radius: 10px;
}
.contained {
height: 92%;  min-height: 92%;
}
.normal_font {
font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
}
.monospace_font {
font-family: "Courier New", Courier, monospace;
}
.invisible {
opacity:0;  width: 0;  z-index: -1;
}
.text_input_margin {
margin-top: 10px;  margin-right: 15px;
}
.center {
display: block;  margin: auto;
}
.spacious-entry {
padding: 8px 8px;
}
.index-button {
margin: 2%;  border: 2px solid #347999;  border-radius: 6px;  background-color: #DDF4FB;  transition: background-color 0.25s;  text-align: center;
}
.index-button:hover {
background-color: #E8FFFF;
}
.index-button > h2 {
margin-top: 3%;  margin-bottom: 0;
}
.icon-button {
display: block;  width: 100%;  height: auto;  max-width: 256px;  max-height: 256px;  margin: auto;
}
.index-link {
max-width: 300px;  min-width: 200px;  text-decoration: none !important;  color: inherit;
}
.index-link:hover {
text-decoration: none;  color: inherit;
}
.properties-list {
margin-left: 0;  padding-left: 0;  list-style: none;  margin-bottom: 0;
}
.properties-list > li {
margin: auto;  padding-left: 0;  padding-top: 10px;  padding-bottom: 10px;  border-top: 1px solid #5499B9;
}
.server-error {
margin-top: 20px;  font-size: 20px;  line-height: 25px;  text-align: center;
}
div.link-header {
margin-left: -27px;  margin-bottom: 20px;  display: -ms-flexbox;  display: flex;  -ms-flex-direction: row;      flex-direction: row;  -ms-flex-align: center;      align-items: center;
}
.anchor-header {
visibility: hidden;  display: block;  margin-top: -20px;  padding-bottom: 20px;
}
.anchor-header:target {
margin-top: -40px;  padding-bottom: 40px;
}
div.link-header:hover > a > img.link-img {
visibility: visible;
}
div.link-header > h2 {
margin-top: 0;  margin-bottom: 0;
}
img.link-img {
top: 50%;  max-width: 20px;  visibility: hidden;
}
/*
Flexbox stuff
Much of this could be inlined in styles, but we do this to allow the autoprefixer access to it --JAB 3/30/15
*/
.dynamic-row {
-ms-flex-align: center;      align-items: center;  display: -ms-flexbox;  display: flex;  -ms-flex-wrap: wrap;      flex-wrap: wrap;  -ms-flex-pack: justify;      justify-content: space-between;
}
.dynamic-column-holder {
-ms-flex-align: center;      align-items: center;  display: -ms-flexbox;  display: flex;  -ms-flex-wrap: wrap;      flex-wrap: wrap;  -ms-flex-pack: distribute;      justify-content: space-around;
}
.flex1 {
-ms-flex: 1;      flex: 1;
}
.flex2 {
-ms-flex: 2;      flex: 2;
}
.flex3 {
-ms-flex: 3;      flex: 3;
}
.flex-column {
display: -ms-flexbox;  display: flex;  -ms-flex-direction: column;      flex-direction: column;
}
.flex-row {
display: -ms-flexbox;  display: flex;  -ms-flex-direction: row;      flex-direction: row;
} </style>
<style>/* * General-purpose widget styles, applied regardless of what the widget "theme" is */
.netlogo-model {
display: -ms-flexbox;    display: flex;    padding: 20px;    -ms-flex-flow: column;        flex-flow: column;    font-size: 12px;    font-family: "Lucida Grande", sans-serif;    outline: none;
}
.netlogo-header {
display: -ms-flexbox;    display: flex;    -ms-flex-flow: row;        flex-flow: row;    -ms-flex-align: center;        align-items: center;    -ms-flex-pack: justify;        justify-content: space-between;
}
.netlogo-widget {
box-sizing: border-box;    background-color: #CCC;    border-radius: 4px;    overflow: hidden;
}
.netlogo-command,.netlogo-input {
-webkit-user-select: none;       -moz-user-select: none;        -ms-user-select: none;            user-select: none;
}
.netlogo-command:hover,.netlogo-input:hover {
box-shadow: 0 0 6px 3px rgba(15, 15, 15, .40);  cursor:     pointer;  z-index:    3;
}
.netlogo-command.netlogo-disabled:hover {
box-shadow: none;  cursor:     default;
}
.netlogo-tab-area {
margin-top: 25px;
}
.netlogo-tab {
display: block;  background-color: #BCBCE5;  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyIDEiPjxwb2x5Z29uIHBvaW50cz0iMCwwIDIsMCAxLDEiIGZpbGw9InJnYig4Myw4Myw4MykiLz4gPC9zdmc+");  background-position: 97% 50%;  background-repeat: no-repeat;  background-size: 20px 20px;  border-width: 2px;  border-bottom-width: 0;  border-style: solid;  padding: 7px;  text-align: center;  cursor: pointer;
}
.netlogo-tab.netlogo-active {
background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyIDEiPjxwb2x5Z29uIHBvaW50cz0iMCwxIDIsMSAxLDAiIGZpbGw9InJnYig4Myw4Myw4MykiLz4gPC9zdmc+");
}
.netlogo-tab:first-child {
border-radius: 10px 10px 0px 0px;
}
.netlogo-tab:last-child, .netlogo-tab-content:last-child {
border-radius: 0px 0px 10px 10px;  border-bottom-width: 2px;
}
.netlogo-tab:hover  {
background-color: #D3D3EE;
}
.netlogo-tab.netlogo-active:hover  {
background-color: #9E99FD;
}
.netlogo-tab input[type=checkbox] {
display: none;
}
.netlogo-tab-text {
font-size: 20px;  font-weight: bold;  text-align: center;  -webkit-user-select: none;     -moz-user-select: none;      -ms-user-select: none;          user-select: none;
}
.netlogo-tab-content {
margin-top: 0;  border: 0 solid #242479;  border-left-width: 2px;  border-right-width: 2px;
}
.unselectable {
-webkit-user-select: none;     -moz-user-select: none;      -ms-user-select: none;          user-select: none;
}
.growing {
animation-name: grow;  animation-duration: 0.4s;  animation-timing-function: ease-out;
}
.shrinking {
animation-name: grow;  animation-direction: reverse;  animation-duration: 0.4s;  animation-timing-function: ease-in;
}
@keyframes grow {
0% {    max-height: 0;  }  100% {    max-height: 100%;  }
}
.netlogo-model-text {
background-color: white;
}
.netlogo-model-masthead {
-ms-flex-positive: 1;      flex-grow: 1;  margin: 0 10px 0 0;  width: 350px;
}
.netlogo-model-masthead > form {
margin: 0 auto;
}
.netlogo-model-title {
background-color: initial;  margin: 0 70px;  overflow: hidden;  padding: 0 8px;  text-align: center;  text-overflow: ellipsis;  white-space: nowrap;
}
.hidden {
visibility: hidden;
}
.netlogo-title-input {
font-size: 1.5em;  font-weight: bold;  letter-spacing: normal;  margin: 0 5%;  text-align: center;  width: 350px;
}
.netlogo-code-container {
display: -ms-flexbox;    display: flex;    -ms-flex-flow: column;        flex-flow: column;    background-color: white;    margin-top: 0;
}
.netlogo-ugly-button {
text-align: center;  background-color: rgb(240, 240, 240);  border-color: rgb(238, 238, 238);
}
.netlogo-recompilation-button {
width: 30%;  margin: 12px auto;  font-size: 16px;  font-weight: bold;  cursor: pointer;
}
.netlogo-info-editor {
border: 1px solid black;  height: 500px;
}
.netlogo-toggle-edit-mode {
display: block;  margin: 0;  margin-bottom: 10px;
}
.netlogo-info {
-ms-flex: 1;      flex: 1;  margin-top: 0;  padding-top: 10px;  padding: 15px;
}
.netlogo-command-center {
-ms-flex: 1;      flex: 1;  display: -ms-flexbox;  display: flex;  -ms-flex-direction: column;      flex-direction: column;  height: 175px;  padding: 6px 8px;
}
.netlogo-command-center-editor {
height: 1.25em;  -ms-flex-positive: 1;      flex-grow: 1;
}
.netlogo-command-center-editor .CodeMirror {
border: 1px solid #eee;  height: auto;
}
.netlogo-output-widget {
display: -ms-flexbox;  display: flex;  padding: 5px;
}
.netlogo-output-area {
-ms-flex-positive: 1;      flex-grow: 1;  -ms-flex-direction: column;      flex-direction: column;  background-color: white;  margin: 0px;  overflow: auto;
}
.netlogo-command-center-input {
display: -ms-flexbox;  display: flex;  -ms-flex-negative: 0;      flex-shrink: 0;
}
.netlogo-speed-slider {
background-color: transparent;  border: none;  display: -ms-flexbox;  display: flex;  -ms-flex-direction: column;      flex-direction: column;  margin: 15px auto 0 auto;  width: 75%;
}
.netlogo-widget input[type=range]::-ms-tooltip {
display: none;
}
.netlogo-speed-slider input {
border: none;  width: 100%;
}
.netlogo-model input[type=range] {
cursor: pointer;    cursor: -webkit-grab;    cursor: grab;
}
.netlogo-model input[type=range]:active {
cursor: pointer;    cursor: -webkit-grabbing;    cursor: grabbing;
}
.netlogo-tick-counter {
background-color: #F4F4F4;    font-size: 13px;    margin: 3px;    border: none;    height: 15px;
}
.netlogo-button {
border: inherit;    display: -ms-flexbox;    display: flex;    -ms-flex-pack: distribute;        justify-content: space-around;    -ms-flex-align: center;        align-items: center;    padding: 0px;
}
.netlogo-disabled {
color: grey;
}
.netlogo-button.clear-button {
padding: 5px;
}
.netlogo-button .netlogo-label {
/* For some reason, Safari doesn't like justify-content in buttons,       we have to resort to putting a span in the button that can then be       centered.       BCH 11/14/2014 */    margin: auto;
}
.netlogo-action-key {
color:    grey;  position: absolute;  right:    6px;  top:      5px;
}
.netlogo-action-key.netlogo-focus {
color: black;
}
.netlogo-button:active, .netlogo-forever-button.netlogo-active {
background-color: gray;    color: white;
}
.netlogo-forever-button .netlogo-forever-icon {
background-image:  url(data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDQzOC41NDIgNDM4LjU0MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDM4LjU0MiA0MzguNTQyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnPgoJPHBhdGggZD0iTTQyNy40MDgsMTkuNjk3Yy03LjgwMy0zLjIzLTE0LjQ2My0xLjkwMi0xOS45ODYsMy45OTlsLTM3LjExNiwzNi44MzRDMzQ5Ljk0LDQxLjMwNSwzMjYuNjcyLDI2LjQxMiwzMDAuNSwxNS44NDggICBDMjc0LjMyOCw1LjI4NSwyNDcuMjUxLDAuMDAzLDIxOS4yNzEsMC4wMDNjLTI5LjY5MiwwLTU4LjA1Miw1LjgwOC04NS4wOCwxNy40MTdjLTI3LjAzLDExLjYxLTUwLjM0NywyNy4yMTUtNjkuOTUxLDQ2LjgyICAgYy0xOS42MDUsMTkuNjA3LTM1LjIxNCw0Mi45MjEtNDYuODI0LDY5Ljk0OUM1LjgwNywxNjEuMjE5LDAsMTg5LjU3NSwwLDIxOS4yNzFjMCwyOS42ODcsNS44MDcsNTguMDUsMTcuNDE3LDg1LjA3OSAgIGMxMS42MTMsMjcuMDMxLDI3LjIxOCw1MC4zNDcsNDYuODI0LDY5Ljk1MmMxOS42MDQsMTkuNTk5LDQyLjkyMSwzNS4yMDcsNjkuOTUxLDQ2LjgxOGMyNy4wMjgsMTEuNjExLDU1LjM4OCwxNy40MTksODUuMDgsMTcuNDE5ICAgYzMyLjczNiwwLDYzLjg2NS02Ljg5OSw5My4zNjMtMjAuN2MyOS41LTEzLjc5NSw1NC42MjUtMzMuMjYsNzUuMzc3LTU4LjM4NmMxLjUyLTEuOTAzLDIuMjM0LTQuMDQ1LDIuMTM2LTYuNDI0ICAgYy0wLjA4OS0yLjM3OC0wLjk5OS00LjMyOS0yLjcxMS01Ljg1MmwtMzkuMTA4LTM5LjM5OWMtMi4xMDEtMS43MTEtNC40NzMtMi41NjYtNy4xMzktMi41NjZjLTMuMDQ1LDAuMzgtNS4yMzIsMS41MjYtNi41NjYsMy40MjkgICBjLTEzLjg5NSwxOC4wODYtMzAuOTMsMzIuMDcyLTUxLjEwNyw0MS45NzdjLTIwLjE3Myw5Ljg5NC00MS41ODYsMTQuODM5LTY0LjIzNywxNC44MzljLTE5Ljc5MiwwLTM4LjY4NC0zLjg1NC01Ni42NzEtMTEuNTY0ICAgYy0xNy45ODktNy43MDYtMzMuNTUxLTE4LjEyNy00Ni42ODItMzEuMjYxYy0xMy4xMy0xMy4xMzUtMjMuNTUxLTI4LjY5MS0zMS4yNjEtNDYuNjgyYy03LjcwOC0xNy45ODctMTEuNTYzLTM2Ljg3NC0xMS41NjMtNTYuNjcxICAgYzAtMTkuNzk1LDMuODU4LTM4LjY5MSwxMS41NjMtNTYuNjc0YzcuNzA3LTE3Ljk4NSwxOC4xMjctMzMuNTQ3LDMxLjI2MS00Ni42NzhjMTMuMTM1LTEzLjEzNCwyOC42OTMtMjMuNTU1LDQ2LjY4Mi0zMS4yNjUgICBjMTcuOTgzLTcuNzA3LDM2Ljg3OS0xMS41NjMsNTYuNjcxLTExLjU2M2MzOC4yNTksMCw3MS40NzUsMTMuMDM5LDk5LjY0NiwzOS4xMTZsLTM5LjQwOSwzOS4zOTQgICBjLTUuOTAzLDUuNzExLTcuMjMxLDEyLjI3OS00LjAwMSwxOS43MDFjMy4yNDEsNy42MTQsOC44NTYsMTEuNDIsMTYuODU0LDExLjQyaDEyNy45MDZjNC45NDksMCw5LjIzLTEuODA3LDEyLjg0OC01LjQyNCAgIGMzLjYxMy0zLjYxNiw1LjQyLTcuODk4LDUuNDItMTIuODQ3VjM2LjU1QzQzOC41NDIsMjguNTU4LDQzNC44NCwyMi45NDMsNDI3LjQwOCwxOS42OTd6IiBmaWxsPSIjMDAwMDAwIi8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg==);  background-repeat: no-repeat;  background-size:   10px 10px;  bottom:            5px;  height:            10px;  position:          absolute;  right:             5px;  width:             10px;
}
.netlogo-disabled .netlogo-forever-icon {
background-image: url(data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDQzOC41NDIgNDM4LjU0MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDM4LjU0MiA0MzguNTQyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnPgoJPHBhdGggZD0iTTQyNy40MDgsMTkuNjk3Yy03LjgwMy0zLjIzLTE0LjQ2My0xLjkwMi0xOS45ODYsMy45OTlsLTM3LjExNiwzNi44MzRDMzQ5Ljk0LDQxLjMwNSwzMjYuNjcyLDI2LjQxMiwzMDAuNSwxNS44NDggICBDMjc0LjMyOCw1LjI4NSwyNDcuMjUxLDAuMDAzLDIxOS4yNzEsMC4wMDNjLTI5LjY5MiwwLTU4LjA1Miw1LjgwOC04NS4wOCwxNy40MTdjLTI3LjAzLDExLjYxLTUwLjM0NywyNy4yMTUtNjkuOTUxLDQ2LjgyICAgYy0xOS42MDUsMTkuNjA3LTM1LjIxNCw0Mi45MjEtNDYuODI0LDY5Ljk0OUM1LjgwNywxNjEuMjE5LDAsMTg5LjU3NSwwLDIxOS4yNzFjMCwyOS42ODcsNS44MDcsNTguMDUsMTcuNDE3LDg1LjA3OSAgIGMxMS42MTMsMjcuMDMxLDI3LjIxOCw1MC4zNDcsNDYuODI0LDY5Ljk1MmMxOS42MDQsMTkuNTk5LDQyLjkyMSwzNS4yMDcsNjkuOTUxLDQ2LjgxOGMyNy4wMjgsMTEuNjExLDU1LjM4OCwxNy40MTksODUuMDgsMTcuNDE5ICAgYzMyLjczNiwwLDYzLjg2NS02Ljg5OSw5My4zNjMtMjAuN2MyOS41LTEzLjc5NSw1NC42MjUtMzMuMjYsNzUuMzc3LTU4LjM4NmMxLjUyLTEuOTAzLDIuMjM0LTQuMDQ1LDIuMTM2LTYuNDI0ICAgYy0wLjA4OS0yLjM3OC0wLjk5OS00LjMyOS0yLjcxMS01Ljg1MmwtMzkuMTA4LTM5LjM5OWMtMi4xMDEtMS43MTEtNC40NzMtMi41NjYtNy4xMzktMi41NjZjLTMuMDQ1LDAuMzgtNS4yMzIsMS41MjYtNi41NjYsMy40MjkgICBjLTEzLjg5NSwxOC4wODYtMzAuOTMsMzIuMDcyLTUxLjEwNyw0MS45NzdjLTIwLjE3Myw5Ljg5NC00MS41ODYsMTQuODM5LTY0LjIzNywxNC44MzljLTE5Ljc5MiwwLTM4LjY4NC0zLjg1NC01Ni42NzEtMTEuNTY0ICAgYy0xNy45ODktNy43MDYtMzMuNTUxLTE4LjEyNy00Ni42ODItMzEuMjYxYy0xMy4xMy0xMy4xMzUtMjMuNTUxLTI4LjY5MS0zMS4yNjEtNDYuNjgyYy03LjcwOC0xNy45ODctMTEuNTYzLTM2Ljg3NC0xMS41NjMtNTYuNjcxICAgYzAtMTkuNzk1LDMuODU4LTM4LjY5MSwxMS41NjMtNTYuNjc0YzcuNzA3LTE3Ljk4NSwxOC4xMjctMzMuNTQ3LDMxLjI2MS00Ni42NzhjMTMuMTM1LTEzLjEzNCwyOC42OTMtMjMuNTU1LDQ2LjY4Mi0zMS4yNjUgICBjMTcuOTgzLTcuNzA3LDM2Ljg3OS0xMS41NjMsNTYuNjcxLTExLjU2M2MzOC4yNTksMCw3MS40NzUsMTMuMDM5LDk5LjY0NiwzOS4xMTZsLTM5LjQwOSwzOS4zOTQgICBjLTUuOTAzLDUuNzExLTcuMjMxLDEyLjI3OS00LjAwMSwxOS43MDFjMy4yNDEsNy42MTQsOC44NTYsMTEuNDIsMTYuODU0LDExLjQyaDEyNy45MDZjNC45NDksMCw5LjIzLTEuODA3LDEyLjg0OC01LjQyNCAgIGMzLjYxMy0zLjYxNiw1LjQyLTcuODk4LDUuNDItMTIuODQ3VjM2LjU1QzQzOC41NDIsMjguNTU4LDQzNC44NCwyMi45NDMsNDI3LjQwOCwxOS42OTd6IiBmaWxsPSIjODA4MDgwIi8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg==);
}
.netlogo-button-agent-context {
font-size: 11px;  left:      8px;  position:  absolute;  top:       5px;
}
.netlogo-disabled .netlogo-button-agent-content {
color: #808080;
}
.netlogo-text-box {
background-color: white;    border: none;    margin: 0;    white-space: pre-wrap;    font-family: "Lucida Grande", sans-serif;
}
.netlogo-switcher {
display: -ms-flexbox;    display: flex;    -ms-flex-align: center;        align-items: center;
}
.netlogo-slider {
padding-left: 3px;    padding-right: 3px;
}
.netlogo-slider:hover {
cursor: default;
}
.netlogo-slider input[type=range] {
background-color: transparent;  height: 22px;  margin: 0px;  margin-bottom: -5px;  margin-top: 2px;  padding: 0px;  width: 100%;
}
.netlogo-label {
margin: 0 auto;  overflow: hidden;  text-overflow: ellipsis;  white-space: nowrap;
}
.netlogo-slider-label {
display: -ms-flexbox;  display: flex;  -ms-flex-pack: justify;      justify-content: space-between;
}
.netlogo-slider-label .netlogo-label {
-ms-flex: 1 1 auto;      flex: 1 1 auto;  min-width: 0;
}
.netlogo-slider-label .netlogo-slider-value {
-ms-flex: 0 0 auto;      flex: 0 0 auto;
}
.netlogo-slider-label input[type=number] {
margin: 0px;    border: 1px;    padding: 0px;
}
.netlogo-monitor {
padding: 2px 4px;    display: -ms-flexbox;    display: flex;    -ms-flex-flow: column;        flex-flow: column;    -ms-flex-pack: distribute;        justify-content: space-around;
}
.netlogo-monitor > .netlogo-value {
background-color: white;  min-height: 11px;  padding: 2px 2px;
}
.netlogo-value {
overflow: hidden;
}
.netlogo-code {
border: 1px solid black;
}
.netlogo-code-tab {
height: 500px;
}
.netlogo-input-box {
padding: 2px 4px;    display: -ms-flexbox;    display: flex;    -ms-flex-flow: column;        flex-flow: column;    -ms-flex-pack: distribute;        justify-content: space-around;
}
.netlogo-multiline-input {
-ms-flex-positive: 1;      flex-grow: 1;  margin:    4px;  resize:    none;
}
.netlogo-chooser {
padding: 2px 4px;    display: -ms-flexbox;    display: flex;    -ms-flex-flow: column;        flex-flow: column;    -ms-flex-pack: distribute;        justify-content: space-around;
}
.netlogo-plot {
box-sizing: content-box; /* otherwise border gets cut off -- BCH 11/9/2014 */    border: 1px solid black;
}
.netlogo-forever-button > input {
display: none;
}
.netlogo-subheader {
-ms-flex-align: center;      align-items: center;  display: -ms-flexbox;  display: flex;  -ms-flex-flow: column;      flex-flow: column;  -ms-flex-positive: 0;      flex-grow: 0;  white-space: nowrap;
}
.netlogo-export-wrapper {
-ms-flex-align: center;      align-items: center;  display: -ms-flexbox;  display: flex;  -ms-flex-positive: 0;      flex-grow: 0;  white-space: nowrap;
}
.netlogo-widget-error {
color: red;
}
.netlogo-widget-error:hover {
cursor: pointer;
}
.CodeMirror {
height: auto;
} </style>
<style>/* * Style for things relevant to the widget/interface editor */
.netlogo-interface-unlocker {
height: 20px;  margin: auto 0;  outline: none;  width: 20px;  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAADu0lEQVR4Xu1b0VHcMBDddQMhFeRSQUgFOTo4KgiW+A+pAKgg8I+sUAGXCnJXQUgFuXRAGvBmlhGZA05aS9YZz0WaYRjGsqx92n270hMIAzVr7T4AfGjbdoqIEwDgv9fbLRGtqqpaAMCyruvbIaaG2/yItXYPAD4R0REAsNExbYWIXwHgsq7ru5gXY/puDQBr7SkRnQAAg9Cn3SHiRV3X530G8b2bHQB2dSK6SVhxyT72iMPcoZEVAGPMESJayZI+z4mo1lpzaGRp2QBwLn+WZVbCIIh4lisksgAwxMo/xSSXJ/QG4OrqalZVFcd8p0ZEvxFxTkTM7Cv+jYj7iLhHRDNEfNNpIABo2/bw+Ph43rX/pn69AOA0R0S/OjL9EhFPJBJzJHrBNUMHwxi8t33SZC8AjDE3iDgLTZSI/lRVNavrmguczs1aO23bdo6Ir4Tx51rrw84DP+mYDABPkIi+C5P7WVXVNHWF2MPatl0g4rvQdxDxIBbgh/GSAWiaho2f+iZGRL2Mfxi3IwgLpdRBihckAWCtnbjY3/hN5/a88lnqeeYF5wnecHBcsIoFIQkAY8wJIn4JrP651jprTWCMOUPE08A3P2utmTyjWhIATdMwoW1kabf6k9S4983ehQKXwz4vWCqlvCHpGzcVAArAfK2U4t1f9tY0DZfAH30DK6Wi7Yl+weXpH75J5ChOfGNLRRcivo/lnRQAgukPEV/ndv+1jBAk35R0mB2AFDeMiZWmabzhNwgAUgZ4SQCIKDoTRHuAlI5eGIDo9FsAiIk/7ls8QKjISggkFCMxXhjKAkRUOCB2D1JIMMb9/ksSdCe+6xsQlrhCMlfU0VfsAoQOYfiQ1f3cD0tE15KGIIaAlPYSDBjslS6kWACQlqN4gFD4SAC+5PMSAh0Ko8IBkosWDtgeB1wS0b1uwOIoX6WRFiP2+Sg5gNVhpxU+Ek2c+MFaYGd1WAJklACEzu266I2S0evPRwcA64Va66fX4x7ZZIxh8SOLF4wOAAD4ppQKyukh1Slm9d1eQDwfGDoNivLVrgPAjO8VTiTVeRc8gLeo3hsd0p2DnQDAGfFMQJWEz1jjx8oBDwcVz8hpGxXnGLNAAYAR2CShS9L3ToXApmowdxU4ag7YdJFBunixUx7gk89Cqk8BIAGBUWaB0IbIGHMr3QqNwWGUAPA/RPmus+XcB4yZBPmavO8GKW+V+/6P0T8nGasHxHhxr74FgHIsLl+YGPpApJdLx75cQqCEQAmB0R2KxoZxr/6FAzpwwF8eSx5uwugU8AAAAABJRU5ErkJggg==');  background-size: contain;
}
.netlogo-interface-unlocker:hover {
background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAADQElEQVR4Xu2a8bFNMRDGv1cBKuBVgArQARWgAlSAClABKkAFngpQATqgAubn5c7cuXOym01yzsu7k515f7y5e5Lsl91vN9mcaDu5JemOpLuSbkji/335JumnpDNJXyTx/+pysvIMVyU9kfQoGR2ZDjDeSXoj6Xfkw4jumgA8l/RUEiC0CMa/lvSyZZDct2sAgGt/qNhxzz484kHv0OgNAK7+1rOk8ffHKTQahzn/vCcAuPyLLqvyB2GeLiHRC4Atdv4Qli6e0AOA+ynm/X071/gl6WNiduIakoM3IEvGul46UOIExqqWVgBY9I9Cpie3kxW8/A4YsD41gyeAd9qSJlsBgO3ZNUv+JB0KnIhQMLG7V5yP0CE7VEkLACzwszPr91T51RYyeBjA3XTmuZf0wiC0AIDxgJCTVuN345aAAEiAEJZaAKjlif2c4PaA48V76YLhBYy0wgEugFRDUgsAZPbKmIkc3bsmYDxqjZw8S+S5CQDsRo6l2X08pDbucwYQCuxwzgvIMlZILo5b6wF/DZjfp9NfaCcKlTkdPjR0w/aEP0hFy1djEaSkpuLEGNsrum5HeacGAC/9XVvB/XeYeOQbTodrAFAzZmEE/Fezwm8TALwMcJEAhDNBzWK9dFQzZi8PCKffmsVOAJyCpAbU6QEBBCwSnCEQLcFr3HVywOQA+1RW41UBCjALoVU4gBvf/QMI5Sh/OYlefUWMR9c68XFa3L8T4GDGASorJbvlxXzUgC31XY+YABRsx/QAh/ULMLwwlRkCXmE0OaDAOScHrMQBPH3Z9Q249+cpTW8ZkgPoDnO5edg0AQQuUyPdYQ+wIQGw7u28C1fP4MPfhwOAfuHh87jDRVPK9vKC4QD4VNBOt7pOl94DStpXRw0AO2g1TrzGx6X3AAywXnR4bw6OAgCMWGqgeo3PqPHoD0eCOyOWFrZGxTkBGPUwtNRC91rfRxUCS9Vg7ypwaA5YeshAhWg9vDgqD8jdQ1htrwlABQJDZgHrQMQR2XsVGsFhSACs80DPc8CwJMj7wdwL0t2z+cguW7pDekAv40rGmQCMWgmW7F4PnekB0wOcV+uzM1QQaGuc0wum7aIyOWBygMMB/wCoI9hBlHmMqwAAAABJRU5ErkJggg==');
}
.netlogo-interface-unlocker.interface-unlocked {
background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAADbklEQVR4Xu2b4VXbMBSFdbVA2w3aCZpOUJgAOkGRPABlgtIJSv9HMp0AMkHDBIUJChuEAcjreSGhqWPJsi2wfSyfk3+SrPfp6j5ZUiBG/mDk8YsEIClgYASstR+5ywAmQojXRHQrhLgFcK+Uuq4bTu+nQJ7nHOQBER0COKwI8JaI5gAutdazEBi9BpDn+TERnfJIhwRTKHMN4EQpNffV7SWAPM8nRHQhhHjbIPBiFVbEJ6XUoqyt3gEwxhwByCMEvt0EewRD2PGIXgEwxnwB8D1y8JvmFgD2ixB6A6DuyBPRHQA2vQmAV4HQGMIHpRRnjtXTCwDrOf/LZ3ZEdA/gnH/FUeRM8fDwsCel5CzxuQIGmyMrYeUJvQBgrf0thOC87npmAI5cRrZdKc/zveVyeQbgvasxIvqWZRlnl+4BVEmfiFSWZeeBEl8VW68duM6Box5PhXcMtHMFWGv/uNIdEZ1kWXZWJ/jtssYYlrtLCT+11kedAmC5EhHP/bJnprWuWvl52bASlsslp8Ayk1xord90CsBay6N7XLpAeZTok1u3UMEpgK+Od+x3DcAl/9ajX5gKPOfLVPCjawBUNjJNjM+nEGvtpcMQrzoDsM79nP52nrVDt5b/pmFjjGsadArAaYBa66gDM51OD6WU/HG1C7upubSt58sAsQH43hWVdB0oCYBnDZAUENkD0hTwqC15QB3jilm2Nya42WePGVxIW7yvT0SuL729TRsA7tp+E3g9wFpbuhwNCeIlymxvXjR9XwLwuM1eqjaMQQE+5SQASQEjMMEXmwJEdANgUfOwwmvuMbLAswPgwKWUvG//dPbm2YSolc16D4BPbKSUk7LFim/TM5RC7wEIIZwbmBXb3kEMeg+gqoNts0xV+0EUPYVirANWJyxl7/BtfIZ2fAgA+MISHznvXD4wxlwE3OsZfhYQQuycu8cwQCYzCAVwR4sqsNby5aTVlbY2z2AAFDcyR6eAIoDRLITW8/Qmy7L/bnhUXXwInRZDmQJXWuunbSwOLsYiaEgmuLMWGBUAl0zbrgIHo4DRAwg1tCblhmKCTWILqpMAbF1qDCJWs1CMr8Gar6xXPCkgKeDfvd562gkrnaZAjMVKGOtmpZ7dA/irrVnXXqaWlHJe9cenNj3p7IZIm07HrJsAxKQ5xLZGr4C/ICqoLrwEHLcAAAAASUVORK5CYII=')
}
.netlogo-interface-unlocker.interface-unlocked:hover {
background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAC3klEQVR4Xu2b8TUEMRDGv6sAHVABKuAqQAWoABWgAlSAClABVwEqQAdUwPtW1tu3l2STzaxNLsl7+5cke/ObL5PZSUyQeZtkbj8KgKKA9AhsqZ+8AWAZwLt6vgC8+JqTwhKgkTsAdtVjs5EwngDcA3hwgRE7gCMAZ8rTLvY0+1ANJwqIcWysACjvOwCrvlZr+lMRewA+dXPFCOAAwLWA4c0puDQIYS5GxAbgGMCFsPH1dFTAtA0hJgC+nv9Q0Z/LZckRGiFsqnHVkFgA0IjHjmDHbe5GPW0pc6fYVrvEfgcMjqUSqpgQC4BnAIRgatzSqBBtIGsNIohLAOuW+c7V7hIFgC7pHyqvO6q86kZFUC3MH3SNINcINAYFvFm2O+7j9GbfRrmblHBLVY0NgHLl2tc1yp7ZX0irU2VdkKQKVsYGQO8y29M1SpT7d2hjJnlqmGQ6NgCT/CW837SZ3tap4GpsAN8Gz/QJfDal8ONIFxBnYwLgtsftb0j513OblsGoAGwBUNoxDKb8uJpr0i/yCVj/CcD4rgLAx2XCfYsCLEmQtDLLEjDBlibts0rKEohlCdR1dh/vSfRlImT60qM66lZXfkLeaY0BpnQ05IWSY/+KFwGTZg/AqDYGwRwUYBRPAVAUUJaAaAx4VaVrn8OKruAusQsMHgNoOMvbzQMLWy2uy+jm36MHwBMbelxXwLQVPV0hRA/AVsC05fsLA6DLQ6F5Rtf8riC1/STygOqExfArbIVP1x8ePQAawiNn3QUlFiJDT3eSADB37q6+9EynPq7eZ78kAOhUwLs5Ep/ayQBoV5cktsCkFNAGkE0iRC8xE2zf8Oi6+OAaB5JYAjN1R6dplEQSlMwS0OUCWQEwyTQ0C0xGAdkDcA1offolEQT7GOY6pgCoLzW6EvPpJ/E16PO+Pn2LAooCfv9rZJBWlkA5GBlQXkKaZV2BzyBtzBsigxjkO2kB4Ets0fpnr4Af4sW1RwixQEAAAAAASUVORK5CYII=')
}
.netlogo-widget.interface-unlocked {
-webkit-user-select: none;     -moz-user-select: none;      -ms-user-select: none;          user-select: none;
}
.netlogo-widget.interface-unlocked:hover {
box-shadow: 0 0 6px 3px rgba(15, 15, 15, .40);  cursor:     default;  z-index:    3;
}
.context-menu-item {
border-bottom: solid 1px #dfdfdf;  color:         #0066aa;  cursor:        pointer;  font-size:     18px;  padding:       5px;  -webkit-user-select:   none;     -moz-user-select:   none;      -ms-user-select:   none;          user-select:   none;
}
.context-menu-item:hover {
background-color: #0066aa;  color:            white;
}
.context-menu-item:last-child {
border-bottom: none;
}
.context-menu-list {
list-style: none;  margin:     0;  padding:    0;
}
.widget-context-menu {
background-color: white;  border:           solid 1px #dfdfdf;  box-shadow:       1px 1px 2px #cfcfcf;  display:          none;  margin:           0;  padding:          8px 10px;  position:         absolute;  width:            200px;  z-index:          10;
}
.widget-edit-popup {
background-color: white;  border:           1px solid black;  border-radius:    5px;  box-shadow:       0 0 10px rgba(0,0,0,0.5);  padding:          10px 10px 0 10px;  position:         absolute;  outline:          none;  width:            450px;  z-index:          100;
}
.widget-edit-form {
margin-bottom: 10px;
}
.widget-edit-form label {
-webkit-user-select: none;     -moz-user-select: none;      -ms-user-select: none;          user-select: none;
}
.widget-edit-form-title {
cursor:        default;  font-weight:   bold;  margin-bottom: 10px;  text-align:    center;  -webkit-user-select:   none;     -moz-user-select:   none;      -ms-user-select:   none;          user-select:   none;
}
.widget-edit-form-button-container {
margin-top: 10px;  text-align: center;
}
.widget-edit-closer {
color:       #7F7F7F;  cursor:      pointer;  font-weight: bold;  position:    absolute;  right:       10px;  top:         10px;  -webkit-user-select: none;     -moz-user-select: none;      -ms-user-select: none;          user-select: none;
}
.widget-edit-closer:hover {
color: black;
}
.widget-edit-text {
font-size: 20px;
}
.widget-edit-checkbox {
height: 13px;
}
.widget-edit-input-label {
margin-right: 10px;  white-space:  nowrap;
}
.widget-edit-input {
width: 100%;
}
.widget-edit-input[type="number"] {
text-align: right;
}
.widget-edit-hint-text {
font-size:   12px;  -webkit-user-select: none;     -moz-user-select: none;      -ms-user-select: none;          user-select: none;
}
.widget-edit-dropdown {
font-size: 14px;  height:    20px;  margin:    0 10px;
}
.widget-edit-textbox {
font-size: 14px;  height:    115px;  max-width: 100%;  min-width: 100%;
}
.widget-edit-fieldset {
border-radius: 8px;
}
.widget-edit-legend {
-webkit-user-select: none;     -moz-user-select: none;      -ms-user-select: none;          user-select: none;
} </style>
<style>.netlogo-command {  background-color: #BACFF3;
} .netlogo-command.netlogo-active, .netlogo-command:active {
background-color: #1F6A99;  color: #BACFF3;
} .netlogo-button.netlogo-disabled:active, .netlogo-forever-button.netlogo-disabled.netlogo-active {
background-color: #BCBCE5;  color: #888888;
} .netlogo-input {
background-color: #8FE585;
} .netlogo-output {
background-color: #FFFF9A;  border: 1px solid #E7E741;
}
.netlogo-slider-label .netlogo-label {
background-color: #8FE585;
}
.netlogo-slider-label .netlogo-slider-value {
background-color: #8FE585;
}
.netlogo-tab {
background-color: #BCBCE5;  border-color: #242479;  font-size: 16px;
}
.netlogo-tab.netlogo-active {
background-color: #7C76fD;
}
.netlogo-tab:active {
background-color: #7C76fD;
}
.netlogo-view-container {
background-color: #F4F4F4;  border: 1px solid #CCCCCC;
} </style>
<style>.cm-s-netlogo-default .cm-reporter {    color: #660096;
} .cm-s-netlogo-default .cm-command {
color: #0000AA;
} .cm-s-netlogo-default .cm-keyword {
color: #007F69;
} .cm-s-netlogo-default .cm-comment {
color: #5A5A5A;
} .cm-s-netlogo-default .cm-string, .cm-s-netlogo-default .cm-number, .cm-s-netlogo-default .cm-constant {
color: #963700;
} </style>
<style>/* * Styles for that sweet loading spinner with turtles */
loading-overlay {
display: -ms-flexbox;  display: flex;  -ms-flex-align: center;      align-items: center;  -ms-flex-pack: center;      justify-content: center;
}
.spinner-img {
height: auto;  width: 10px;  z-index: 11;  position: absolute;
}
spinner {
height: 50px;  width:  50px;  transform-origin: 60% 60%;  animation-name: spin;  animation-duration: 1.75s;  animation-iteration-count: infinite;  animation-direction: normal;  animation-timing-function: linear;  animation-fill-mode: forwards;  animation-delay: 0s;  animation-play-state: running;  z-index: 11;
}
.turtle1 {
top: 29%;  left: 29%;
}
.turtle2 {
top: 20%;  left: 50%;
}
.turtle3 {
top: 29%;  left: 71%;
}
.turtle4 {
top:  50%;  left: 80%;
}
.turtle5 {
top:  71%;  left: 71%;
}
.turtle6 {
top:  80%;  left: 50%;
}
.turtle7 {
top:  71%;  left: 29%;
}
.turtle8 {
top: 50%;  left: 20%;
}
@keyframes spin {
from {      transform: rotate(0deg);  }  to {      transform: rotate(360deg);  }
} </style>
<style>/* * styles to use with the "error alert" component */
.dark-overlay {
background-color:rgba(0, 0, 0, 0.7);  width:100%;  height:100%;  z-index:10;  top:0;  left:0;  position: fixed;
}
alert-overlay {
display: -ms-flexbox;  display: flex;  -ms-flex-direction: row;      flex-direction: row;  -ms-flex-pack: center;      justify-content: center;  -ms-flex-align: center;      align-items: center;  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
}
alert-dialog {
-ms-flex-align: center;      align-items: center;  background-color: whitesmoke;  border: 2px black solid;  border-radius: 10px;  display:-ms-flexbox;  display:flex;  -ms-flex-direction: column;      flex-direction: column;  margin: 0 50px;  min-width: 350px;  opacity: 1;  z-index: 15;
}
alert-title {
margin-bottom: 5px;
}
.alert-text {
padding: 10px;  font-size: 16px;
}
.standalone-text {
color: #555555;  display: none;  text-align: center;  max-width: 600px;
}
alert-dismiss-container {
border-top: 1px solid lightgray;  width: 100%;  text-align: center;  padding: 10px 0;
}
.alert-button {
font-size: 14px;  height: 25px;  min-width: 50%;  border-radius: 3px;  border: 1px solid lightgray;  background-color: #e6e6e6;
} </style>
<body style="margin: 0px;">
<svg class="spinner-img turtle1" xmlns=" http://www.w3.org/2000/svg " version="1.1" viewBox="0 0 50 55"> <polygon points="22,0 0,49 22,40 44,49" style="fill: rgba(255, 255, 255, 0.125);" transform="rotate(45.0, 22, 24)"> </polygon> </svg> <svg class="spinner-img turtle2" xmlns=" http://www.w3.org/2000/svg " version="1.1" viewBox="0 0 50 55"> <polygon points="22,0 0,49 22,40 44,49" style="fill: rgba(255, 255, 255, 0.25);" transform="rotate(90.0, 22, 24)"> </polygon> </svg> <svg class="spinner-img turtle3" xmlns=" http://www.w3.org/2000/svg " version="1.1" viewBox="0 0 50 55"> <polygon points="22,0 0,49 22,40 44,49" style="fill: rgba(255, 255, 255, 0.375);" transform="rotate(135.0, 22, 24)"> </polygon> </svg> <svg class="spinner-img turtle4" xmlns=" http://www.w3.org/2000/svg " version="1.1" viewBox="0 0 50 55"> <polygon points="22,0 0,49 22,40 44,49" style="fill: rgba(255, 255, 255, 0.5);" transform="rotate(180.0, 22, 24)"> </polygon> </svg> <svg class="spinner-img turtle5" xmlns=" http://www.w3.org/2000/svg " version="1.1" viewBox="0 0 50 55"> <polygon points="22,0 0,49 22,40 44,49" style="fill: rgba(255, 255, 255, 0.625);" transform="rotate(225.0, 22, 24)"> </polygon> </svg> <svg class="spinner-img turtle6" xmlns=" http://www.w3.org/2000/svg " version="1.1" viewBox="0 0 50 55"> <polygon points="22,0 0,49 22,40 44,49" style="fill: rgba(255, 255, 255, 0.75);" transform="rotate(270.0, 22, 24)"> </polygon> </svg> <svg class="spinner-img turtle7" xmlns=" http://www.w3.org/2000/svg " version="1.1" viewBox="0 0 50 55"> <polygon points="22,0 0,49 22,40 44,49" style="fill: rgba(255, 255, 255, 0.875);" transform="rotate(315.0, 22, 24)"> </polygon> </svg> <svg class="spinner-img turtle8" xmlns=" http://www.w3.org/2000/svg " version="1.1" viewBox="0 0 50 55"> <polygon points="22,0 0,49 22,40 44,49" style="fill: rgba(255, 255, 255, 1.0);" transform="rotate(360.0, 22, 24)"> </polygon> </svg>
Error
NetLogo Web has encountered a problem.
It looks like you're using NetLogo Web in standalone mode.
If the above error is being caused by an unimplemented primitive, we recommend a quick visit to <a href=" https://netlogoweb.org " target="_blank">NetLogoWeb.org</a> to see if the primitive has been implemented in the most up-to-date version.
<button id="alert-dismiss" class="alert-button alert-separator-top" onclick="window.nlwAlerter.hide()"> Dismiss </button>
<script>/*! * jQuery JavaScript Library v3.2.1 * https://jquery.com/ * * Includes Sizzle.js * https://sizzlejs.com/ * * Copyright JS Foundation and other contributors * Released under the MIT license * https://jquery.org/license * * Date: 2017-03-20T18:59Z */
( function( global, factory ) {
"use strict";
if ( typeof module === "object" && typeof module.exports === "object" ) {
// For CommonJS and CommonJS-like environments where a proper `window`   // is present, execute the factory and get jQuery.   // For environments that do not have a `window` with a `document`   // (such as Node.js), expose a factory as module.exports.   // This accentuates the need for the creation of a real `window`.   // e.g. var jQuery = require("jquery")(window);   // See ticket #14549 for more info.   module.exports = global.document ?    factory( global, true ) :    function( w ) {     if ( !w.document ) {      throw new Error( "jQuery requires a window with a document" );     }     return factory( w );    };  } else {   factory( global );  }
// Pass this if window is not defined yet } )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1 // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common // enough that all such attempts are guarded in a try block. "use strict";
var arr = [];
var document = window.document;
var getProto = Object.getPrototypeOf;
var slice = arr.slice;
var concat = arr.concat;
var push = arr.push;
var indexOf = arr.indexOf;
var class2type = {};
var toString = class2type.toString;
var hasOwn = class2type.hasOwnProperty;
var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call( Object );
var support = {};
function DOMEval( code, doc ) {   doc = doc || document;
var script = doc.createElement( "script" );
script.text = code;   doc.head.appendChild( script ).parentNode.removeChild( script );  } /* global Symbol */ // Defining this global in .eslintrc.json would create a danger of using the global // unguarded in another place, it seems safer to define global only for this module
var  version = "3.2.1",
// Define a local copy of jQuery  jQuery = function( selector, context ) {
// The jQuery object is actually just the init constructor 'enhanced'   // Need init if jQuery is called (just allow error to be thrown if not included)   return new jQuery.fn.init( selector, context );  },
// Support: Android <=4.0 only  // Make sure we trim BOM and NBSP  rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
// Matches dashed string for camelizing  rmsPrefix = /^-ms-/,  rdashAlpha = /-([a-z])/g,
// Used by jQuery.camelCase as callback to replace()  fcamelCase = function( all, letter ) {   return letter.toUpperCase();  };
jQuery.fn = jQuery.prototype = {
// The current version of jQuery being used  jquery: version,
constructor: jQuery,
// The default length of a jQuery object is 0  length: 0,
toArray: function() {   return slice.call( this );  },
// Get the Nth element in the matched element set OR  // Get the whole matched element set as a clean array  get: function( num ) {
// Return all the elements in a clean array   if ( num == null ) {    return slice.call( this );   }
// Return just the one element from the set   return num < 0 ? this[ num + this.length ] : this[ num ];  },
// Take an array of elements and push it onto the stack  // (returning the new matched element set)  pushStack: function( elems ) {
// Build a new jQuery matched element set   var ret = jQuery.merge( this.constructor(), elems );
// Add the old object onto the stack (as a reference)   ret.prevObject = this;
// Return the newly-formed element set   return ret;  },
// Execute a callback for every element in the matched set.  each: function( callback ) {   return jQuery.each( this, callback );  },
map: function( callback ) {   return this.pushStack( jQuery.map( this, function( elem, i ) {    return callback.call( elem, i, elem );   } ) );  },
slice: function() {   return this.pushStack( slice.apply( this, arguments ) );  },
first: function() {   return this.eq( 0 );  },
last: function() {   return this.eq( -1 );  },
eq: function( i ) {   var len = this.length,    j = +i + ( i < 0 ? len : 0 );   return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );  },
end: function() {   return this.prevObject || this.constructor();  },
// For internal use only.  // Behaves like an Array's method, not like a jQuery method.  push: push,  sort: arr.sort,  splice: arr.splice };
jQuery.extend = jQuery.fn.extend = function() {  var options, name, src, copy, copyIsArray, clone,   target = arguments[ 0 ] || {},   i = 1,   length = arguments.length,   deep = false;
// Handle a deep copy situation  if ( typeof target === "boolean" ) {   deep = target;
// Skip the boolean and the target   target = arguments[ i ] || {};   i++;  }
// Handle case when target is a string or something (possible in deep copy)  if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {   target = {};  }
// Extend jQuery itself if only one argument is passed  if ( i === length ) {   target = this;   i--;  }
for ( ; i < length; i++ ) {
// Only deal with non-null/undefined values   if ( ( options = arguments[ i ] ) != null ) {
// Extend the base object    for ( name in options ) {     src = target[ name ];     copy = options[ name ];
// Prevent never-ending loop     if ( target === copy ) {      continue;     }
// Recurse if we're merging plain objects or arrays     if ( deep && copy && ( jQuery.isPlainObject( copy ) ||      ( copyIsArray = Array.isArray( copy ) ) ) ) {
if ( copyIsArray ) {       copyIsArray = false;       clone = src && Array.isArray( src ) ? src : [];
} else {       clone = src && jQuery.isPlainObject( src ) ? src : {};      }
// Never move original objects, clone them      target[ name ] = jQuery.extend( deep, clone, copy );
// Don't bring in undefined values     } else if ( copy !== undefined ) {      target[ name ] = copy;     }    }   }  }
// Return the modified object  return target; };
jQuery.extend( {
// Unique for each copy of jQuery on the page  expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
// Assume jQuery is ready without the ready module  isReady: true,
error: function( msg ) {   throw new Error( msg );  },
noop: function() {},
isFunction: function( obj ) {   return jQuery.type( obj ) === "function";  },
isWindow: function( obj ) {   return obj != null && obj === obj.window;  },
isNumeric: function( obj ) {
// As of jQuery 3.0, isNumeric is limited to   // strings and numbers (primitives or objects)   // that can be coerced to finite numbers (gh-2662)   var type = jQuery.type( obj );   return ( type === "number" || type === "string" ) &&
// parseFloat NaNs numeric-cast false positives ("")    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")    // subtraction forces infinities to NaN    !isNaN( obj - parseFloat( obj ) );  },
isPlainObject: function( obj ) {   var proto, Ctor;
// Detect obvious negatives   // Use toString instead of jQuery.type to catch host objects   if ( !obj || toString.call( obj ) !== "[object Object]" ) {    return false;   }
proto = getProto( obj );
// Objects with no prototype (e.g., `Object.create( null )`) are plain   if ( !proto ) {    return true;   }
// Objects with prototype are plain iff they were constructed by a global Object function   Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;   return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;  },
isEmptyObject: function( obj ) {
/* eslint-disable no-unused-vars */   // See https://github.com/eslint/eslint/issues/6125 var name;
for ( name in obj ) {    return false;   }   return true;  },
type: function( obj ) {   if ( obj == null ) {    return obj + "";   }
// Support: Android <=2.3 only (functionish RegExp)   return typeof obj === "object" || typeof obj === "function" ?    class2type[ toString.call( obj ) ] || "object" :    typeof obj;  },
// Evaluates a script in a global context  globalEval: function( code ) {   DOMEval( code );  },
// Convert dashed to camelCase; used by the css and data modules  // Support: IE <=9 - 11, Edge 12 - 13  // Microsoft forgot to hump their vendor prefix (#9572)  camelCase: function( string ) {   return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );  },
each: function( obj, callback ) {   var length, i = 0;
if ( isArrayLike( obj ) ) {    length = obj.length;    for ( ; i < length; i++ ) {     if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {      break;     }    }   } else {    for ( i in obj ) {     if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {      break;     }    }   }
return obj;  },
// Support: Android <=4.0 only  trim: function( text ) {   return text == null ?    "" :    ( text + "" ).replace( rtrim, "" );  },
// results is for internal usage only  makeArray: function( arr, results ) {   var ret = results || [];
if ( arr != null ) {    if ( isArrayLike( Object( arr ) ) ) {     jQuery.merge( ret,      typeof arr === "string" ?      [ arr ] : arr     );    } else {     push.call( ret, arr );    }   }
return ret;  },
inArray: function( elem, arr, i ) {   return arr == null ? -1 : indexOf.call( arr, elem, i );  },
// Support: Android <=4.0 only, PhantomJS 1 only  // push.apply(_, arraylike) throws on ancient WebKit  merge: function( first, second ) {   var len = +second.length,    j = 0,    i = first.length;
for ( ; j < len; j++ ) {    first[ i++ ] = second[ j ];   }
first.length = i;
return first;  },
grep: function( elems, callback, invert ) {   var callbackInverse,    matches = [],    i = 0,    length = elems.length,    callbackExpect = !invert;
// Go through the array, only saving the items   // that pass the validator function   for ( ; i < length; i++ ) {    callbackInverse = !callback( elems[ i ], i );    if ( callbackInverse !== callbackExpect ) {     matches.push( elems[ i ] );    }   }
return matches;  },
// arg is for internal usage only  map: function( elems, callback, arg ) {   var length, value,    i = 0,    ret = [];
// Go through the array, translating each of the items to their new values   if ( isArrayLike( elems ) ) {    length = elems.length;    for ( ; i < length; i++ ) {     value = callback( elems[ i ], i, arg );
if ( value != null ) {      ret.push( value );     }    }
// Go through every key on the object,   } else {    for ( i in elems ) {     value = callback( elems[ i ], i, arg );
if ( value != null ) {      ret.push( value );     }    }   }
// Flatten any nested arrays   return concat.apply( [], ret );  },
// A global GUID counter for objects  guid: 1,
// Bind a function to a context, optionally partially applying any  // arguments. proxy: function( fn, context ) {   var tmp, args, proxy;
if ( typeof context === "string" ) {    tmp = fn[ context ];    context = fn;    fn = tmp;   }
// Quick check to determine if target is callable, in the spec   // this throws a TypeError, but we will just return undefined.   if ( !jQuery.isFunction( fn ) ) {    return undefined;   }
// Simulated bind   args = slice.call( arguments, 2 );   proxy = function() {    return fn.apply( context || this, args.concat( slice.call( arguments ) ) );   };
// Set the guid of unique handler to the same of original handler, so it can be removed   proxy.guid = fn.guid = fn.guid || jQuery.guid++;
return proxy;  },
now: Date.now,
// jQuery.support is not used in Core but other projects attach their  // properties to it so it needs to exist.  support: support } );
if ( typeof Symbol === "function" ) {  jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ]; }
// Populate the class2type map jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ), function( i, name ) {  class2type[ "[object " + name + "]" ] = name.toLowerCase(); } );
function isArrayLike( obj ) {
// Support: real iOS 8.2 only (not reproducible in simulator)  // `in` check used to prevent JIT error (gh-2145)  // hasOwn isn't used here due to false negatives  // regarding Nodelist length in IE  var length = !!obj && "length" in obj && obj.length,   type = jQuery.type( obj );
if ( type === "function" || jQuery.isWindow( obj ) ) {   return false;  }
return type === "array" || length === 0 ||   typeof length === "number" && length > 0 && ( length - 1 ) in obj; } var Sizzle = /*!
* Sizzle CSS Selector Engine v2.3.3 * https://sizzlejs.com/ * * Copyright jQuery Foundation and other contributors * Released under the MIT license * http://jquery.org/license * * Date: 2016-08-08 */
(function( window ) {
var i,  support,  Expr,  getText,  isXML,  tokenize,  compile,  select,  outermostContext,  sortInput,  hasDuplicate,
// Local document vars  setDocument,  document,  docElem,  documentIsHTML,  rbuggyQSA,  rbuggyMatches,  matches,  contains,
// Instance-specific data  expando = "sizzle" + 1 * new Date(),  preferredDoc = window.document,  dirruns = 0,  done = 0,  classCache = createCache(),  tokenCache = createCache(),  compilerCache = createCache(),  sortOrder = function( a, b ) {   if ( a === b ) {    hasDuplicate = true;   }   return 0;  },
// Instance methods  hasOwn = ({}).hasOwnProperty,  arr = [],  pop = arr.pop,  push_native = arr.push,  push = arr.push,  slice = arr.slice,  // Use a stripped-down indexOf as it's faster than native  // https://jsperf.com/thor-indexof-vs-for/5 indexOf = function( list, elem ) {   var i = 0,    len = list.length;   for ( ; i < len; i++ ) {    if ( list[i] === elem ) {     return i;    }   }   return -1;  },
booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
// Regular expressions
// http://www.w3.org/TR/css3-selectors/#whitespace whitespace = "[\\x20\\t\\r\\n\\f]",
// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +   // Operator (capture 2)   "*([*^$|!~]?=)" + whitespace +   // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"   "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +   "*\\]",
pseudos = ":(" + identifier + ")(?:\\((" +   // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:   // 1. quoted (capture 3; capture 4 or capture 5)   "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +   // 2. simple (capture 6)   "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +   // 3. anything else (capture 2)   ".*" +   ")\\)|)",
// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter  rwhitespace = new RegExp( whitespace + "+", "g" ),  rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),  rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
rpseudo = new RegExp( pseudos ),  ridentifier = new RegExp( "^" + identifier + "$" ),
matchExpr = {   "ID": new RegExp( "^#(" + identifier + ")" ),   "CLASS": new RegExp( "^\\.(" + identifier + ")" ),   "TAG": new RegExp( "^(" + identifier + "|[*])" ),   "ATTR": new RegExp( "^" + attributes ),   "PSEUDO": new RegExp( "^" + pseudos ),   "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +    "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +    "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),   "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),   // For use in libraries implementing .is()   // We use this for POS matching in `select`   "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +    whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )  },
rinputs = /^(?:input|select|textarea|button)$/i,  rheader = /^h\d$/i,
rnative = /^[^{]+\{\s*\[native \w/,
// Easily-parseable/retrievable ID or TAG or CLASS selectors  rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
rsibling = /[+~]/,
// CSS escapes  // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),  funescape = function( _, escaped, escapedWhitespace ) {   var high = "0x" + escaped - 0x10000;   // NaN means non-codepoint   // Support: Firefox<24   // Workaround erroneous numeric interpretation of +"0x"   return high !== high || escapedWhitespace ?    escaped :    high < 0 ?     // BMP codepoint     String.fromCharCode( high + 0x10000 ) :     // Supplemental Plane codepoint (surrogate pair)     String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );  },
// CSS string/identifier serialization  // https://drafts.csswg.org/cssom/#common-serializing-idioms rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,  fcssescape = function( ch, asCodePoint ) {   if ( asCodePoint ) {
// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER    if ( ch === "\0" ) {     return "\uFFFD";    }
// Control characters and (dependent upon position) numbers get escaped as code points    return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";   }
// Other potentially-special ASCII characters get backslash-escaped   return "\\" + ch;  },
// Used for iframes  // See setDocument()  // Removing the function wrapper causes a "Permission Denied"  // error in IE  unloadHandler = function() {   setDocument();  },
disabledAncestor = addCombinator(   function( elem ) {    return elem.disabled === true && ("form" in elem || "label" in elem);   },   { dir: "parentNode", next: "legend" }  );
// Optimize for push.apply( _, NodeList ) try {  push.apply(   (arr = slice.call( preferredDoc.childNodes )),   preferredDoc.childNodes  );  // Support: Android<4.0  // Detect silently failing push.apply  arr[ preferredDoc.childNodes.length ].nodeType; } catch ( e ) {  push = { apply: arr.length ?
// Leverage slice if possible   function( target, els ) {    push_native.apply( target, slice.call(els) );   } :
// Support: IE<9   // Otherwise append directly   function( target, els ) {    var j = target.length,     i = 0;    // Can't trust NodeList.length    while ( (target[j++] = els[i++]) ) {}    target.length = j - 1;   }  }; }
function Sizzle( selector, context, results, seed ) {  var m, i, elem, nid, match, groups, newSelector,   newContext = context && context.ownerDocument,
// nodeType defaults to 9, since context defaults to document   nodeType = context ? context.nodeType : 9;
results = results || [];
// Return early from calls with invalid selector or context  if ( typeof selector !== "string" || !selector ||   nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
return results;  }
// Try to shortcut find operations (as opposed to filters) in HTML documents  if ( !seed ) {
if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {    setDocument( context );   }   context = context || document;
if ( documentIsHTML ) {
// If the selector is sufficiently simple, try using a "get*By*" DOM method    // (excepting DocumentFragment context, where the methods don't exist)    if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
// ID selector     if ( (m = match[1]) ) {
// Document context      if ( nodeType === 9 ) {       if ( (elem = context.getElementById( m )) ) {
// Support: IE, Opera, Webkit        // TODO: identify versions        // getElementById can match elements by name instead of ID        if ( elem.id === m ) {         results.push( elem );         return results;        }       } else {        return results;       }
// Element context      } else {
// Support: IE, Opera, Webkit       // TODO: identify versions       // getElementById can match elements by name instead of ID       if ( newContext && (elem = newContext.getElementById( m )) && contains( context, elem ) && elem.id === m ) {
results.push( elem );        return results;       }      }
// Type selector     } else if ( match[2] ) {      push.apply( results, context.getElementsByTagName( selector ) );      return results;
// Class selector     } else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
push.apply( results, context.getElementsByClassName( m ) );      return results;     }    }
// Take advantage of querySelectorAll    if ( support.qsa && !compilerCache[ selector + " " ] && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
if ( nodeType !== 1 ) {      newContext = context;      newSelector = selector;
// qSA looks outside Element context, which is not what we want     // Thanks to Andrew Dupont for this workaround technique     // Support: IE <=8     // Exclude object elements     } else if ( context.nodeName.toLowerCase() !== "object" ) {
// Capture the context ID, setting it first if necessary      if ( (nid = context.getAttribute( "id" )) ) {       nid = nid.replace( rcssescape, fcssescape );      } else {       context.setAttribute( "id", (nid = expando) );      }
// Prefix every selector in the list      groups = tokenize( selector );      i = groups.length;      while ( i-- ) {       groups[i] = "#" + nid + " " + toSelector( groups[i] );      }      newSelector = groups.join( "," );
// Expand context for sibling selectors      newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||       context;     }
if ( newSelector ) {      try {       push.apply( results,        newContext.querySelectorAll( newSelector )       );       return results;      } catch ( qsaError ) {      } finally {       if ( nid === expando ) {        context.removeAttribute( "id" );       }      }     }    }   }  }
// All others  return select( selector.replace( rtrim, "$1" ), context, results, seed ); }
/**
* Create key-value caches of limited size * @returns {function(string, object)} Returns the Object data after storing it on itself with * property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength) * deleting the oldest entry */
function createCache() {  var keys = [];
function cache( key, value ) {   // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)   if ( keys.push( key + " " ) > Expr.cacheLength ) {    // Only keep the most recent entries    delete cache[ keys.shift() ];   }   return (cache[ key + " " ] = value);  }  return cache; }
/**
* Mark a function for special use by Sizzle * @param {Function} fn The function to mark */
function markFunction( fn ) {  fn[ expando ] = true;  return fn; }
/**
* Support testing using an element * @param {Function} fn Passed the created element and returns a boolean result */
function assert( fn ) {  var el = document.createElement("fieldset");
try {   return !!fn( el );  } catch (e) {   return false;  } finally {   // Remove from its parent by default   if ( el.parentNode ) {    el.parentNode.removeChild( el );   }   // release memory in IE   el = null;  } }
/**
* Adds the same handler for all of the specified attrs * @param {String} attrs Pipe-separated list of attributes * @param {Function} handler The method that will be applied */
function addHandle( attrs, handler ) {  var arr = attrs.split("|"),   i = arr.length;
while ( i-- ) {   Expr.attrHandle[ arr[i] ] = handler;  } }
/**
* Checks document order of two siblings * @param {Element} a * @param {Element} b * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b */
function siblingCheck( a, b ) {  var cur = b && a,   diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
// Use IE sourceIndex if available on both nodes  if ( diff ) {   return diff;  }
// Check if b follows a  if ( cur ) {   while ( (cur = cur.nextSibling) ) {    if ( cur === b ) {     return -1;    }   }  }
return a ? 1 : -1; }
/**
* Returns a function to use in pseudos for input types * @param {String} type */
function createInputPseudo( type ) {  return function( elem ) {   var name = elem.nodeName.toLowerCase();   return name === "input" && elem.type === type;  }; }
/**
* Returns a function to use in pseudos for buttons * @param {String} type */
function createButtonPseudo( type ) {  return function( elem ) {   var name = elem.nodeName.toLowerCase();   return (name === "input" || name === "button") && elem.type === type;  }; }
/**
* Returns a function to use in pseudos for :enabled/:disabled * @param {Boolean} disabled true for :disabled; false for :enabled */
function createDisabledPseudo( disabled ) {
// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable  return function( elem ) {
// Only certain elements can match :enabled or :disabled   // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled if ( "form" in elem ) {
// Check for inherited disabledness on relevant non-disabled elements:    // * listed form-associated elements in a disabled fieldset    // https://html.spec.whatwg.org/multipage/forms.html#category-listed // https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled // * option elements in a disabled optgroup    // https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled // All such elements have a "form" property.    if ( elem.parentNode && elem.disabled === false ) {
// Option elements defer to a parent optgroup if present     if ( "label" in elem ) {      if ( "label" in elem.parentNode ) {       return elem.parentNode.disabled === disabled;      } else {       return elem.disabled === disabled;      }     }
// Support: IE 6 - 11     // Use the isDisabled shortcut property to check for disabled fieldset ancestors     return elem.isDisabled === disabled ||
// Where there is no isDisabled, check manually      /* jshint -W018 */      elem.isDisabled !== !disabled && disabledAncestor( elem ) === disabled;    }
return elem.disabled === disabled;
// Try to winnow out elements that can't be disabled before trusting the disabled property.   // Some victims get caught in our net (label, legend, menu, track), but it shouldn't   // even exist on them, let alone have a boolean value.   } else if ( "label" in elem ) {    return elem.disabled === disabled;   }
// Remaining elements are neither :enabled nor :disabled   return false;  }; }
/**
* Returns a function to use in pseudos for positionals * @param {Function} fn */
function createPositionalPseudo( fn ) {  return markFunction(function( argument ) {   argument = +argument;   return markFunction(function( seed, matches ) {    var j,     matchIndexes = fn( [], seed.length, argument ),     i = matchIndexes.length;
// Match elements found at the specified indexes    while ( i-- ) {     if ( seed[ (j = matchIndexes[i]) ] ) {      seed[j] = !(matches[j] = seed[j]);     }    }   });  }); }
/**
* Checks a node for validity as a Sizzle context * @param {Element|Object=} context * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value */
function testContext( context ) {  return context && typeof context.getElementsByTagName !== "undefined" && context; }
// Expose support vars for convenience support = Sizzle.support = {};
/**
* Detects XML nodes * @param {Element|Object} elem An element or a document * @returns {Boolean} True iff elem is a non-HTML XML node */
isXML = Sizzle.isXML = function( elem ) {  // documentElement is verified for cases where it doesn't yet exist  // (such as loading iframes in IE - #4833)  var documentElement = elem && (elem.ownerDocument || elem).documentElement;  return documentElement ? documentElement.nodeName !== "HTML" : false; };
/**
* Sets document-related variables once based on the current document * @param {Element|Object} [doc] An element or document object to use to set the document * @returns {Object} Returns the current document */
setDocument = Sizzle.setDocument = function( node ) {  var hasCompare, subWindow,   doc = node ? node.ownerDocument || node : preferredDoc;
// Return early if doc is invalid or already selected  if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {   return document;  }
// Update global variables  document = doc;  docElem = document.documentElement;  documentIsHTML = !isXML( document );
// Support: IE 9-11, Edge  // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)  if ( preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow ) {
// Support: IE 11, Edge   if ( subWindow.addEventListener ) {    subWindow.addEventListener( "unload", unloadHandler, false );
// Support: IE 9 - 10 only   } else if ( subWindow.attachEvent ) {    subWindow.attachEvent( "onunload", unloadHandler );   }  }
/* Attributes  ---------------------------------------------------------------------- */
// Support: IE<8  // Verify that getAttribute really returns attributes and not properties  // (excepting IE8 booleans)  support.attributes = assert(function( el ) {   el.className = "i";   return !el.getAttribute("className");  });
/* getElement(s)By*  ---------------------------------------------------------------------- */
// Check if getElementsByTagName("*") returns only elements  support.getElementsByTagName = assert(function( el ) {   el.appendChild( document.createComment("") );   return !el.getElementsByTagName("*").length;  });
// Support: IE<9  support.getElementsByClassName = rnative.test( document.getElementsByClassName );
// Support: IE<10  // Check if getElementById returns elements by name  // The broken getElementById methods don't pick up programmatically-set names,  // so use a roundabout getElementsByName test support.getById = assert(function( el ) {   docElem.appendChild( el ).id = expando;   return !document.getElementsByName || !document.getElementsByName( expando ).length;  });
// ID filter and find  if ( support.getById ) {   Expr.filter["ID"] = function( id ) {    var attrId = id.replace( runescape, funescape );    return function( elem ) {     return elem.getAttribute("id") === attrId;    };   };   Expr.find["ID"] = function( id, context ) {    if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {     var elem = context.getElementById( id );     return elem ? [ elem ] : [];    }   };  } else {   Expr.filter["ID"] =  function( id ) {    var attrId = id.replace( runescape, funescape );    return function( elem ) {     var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");     return node && node.value === attrId;    };   };
// Support: IE 6 - 7 only   // getElementById is not reliable as a find shortcut   Expr.find["ID"] = function( id, context ) {    if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {     var node, i, elems,      elem = context.getElementById( id );
if ( elem ) {
// Verify the id attribute      node = elem.getAttributeNode("id");      if ( node && node.value === id ) {       return [ elem ];      }
// Fall back on getElementsByName      elems = context.getElementsByName( id );      i = 0;      while ( (elem = elems[i++]) ) {       node = elem.getAttributeNode("id");       if ( node && node.value === id ) {        return [ elem ];       }      }     }
return [];    }   };  }
// Tag  Expr.find["TAG"] = support.getElementsByTagName ?   function( tag, context ) {    if ( typeof context.getElementsByTagName !== "undefined" ) {     return context.getElementsByTagName( tag );
// DocumentFragment nodes don't have gEBTN    } else if ( support.qsa ) {     return context.querySelectorAll( tag );    }   } :
function( tag, context ) {    var elem,     tmp = [],     i = 0,     // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too     results = context.getElementsByTagName( tag );
// Filter out possible comments    if ( tag === "*" ) {     while ( (elem = results[i++]) ) {      if ( elem.nodeType === 1 ) {       tmp.push( elem );      }     }
return tmp;    }    return results;   };
// Class  Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {   if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {    return context.getElementsByClassName( className );   }  };
/* QSA/matchesSelector  ---------------------------------------------------------------------- */
// QSA and matchesSelector support
// matchesSelector(:active) reports false when true (IE9/Opera 11.5)  rbuggyMatches = [];
// qSa(:focus) reports false when true (Chrome 21)  // We allow this because of a bug in IE8/9 that throws an error  // whenever `document.activeElement` is accessed on an iframe  // So, we allow :focus to pass through QSA all the time to avoid the IE error  // See https://bugs.jquery.com/ticket/13378 rbuggyQSA = [];
if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {   // Build QSA regex   // Regex strategy adopted from Diego Perini   assert(function( el ) {    // Select is set to empty string on purpose    // This is to test IE's treatment of not explicitly    // setting a boolean content attribute,    // since its presence should be enough    // https://bugs.jquery.com/ticket/12359 docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +     "<select id='" + expando + "-\r\\' msallowcapture=>" + "<option selected=></option></select>";
// Support: IE8, Opera 11-12.16    // Nothing should be selected when empty strings follow ^= or $= or *=    // The test attribute must be unknown in Opera but "safe" for WinRT    // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section if ( el.querySelectorAll("[msallowcapture^=]").length ) { rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:|\"\")" ); }
// Support: IE8    // Boolean attributes and "value" are not treated correctly    if ( !el.querySelectorAll("[selected]").length ) {     rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );    }
// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+    if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {     rbuggyQSA.push("~=");    }
// Webkit/Opera - :checked should return selected option elements    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked // IE8 throws error here and will not see later tests    if ( !el.querySelectorAll(":checked").length ) {     rbuggyQSA.push(":checked");    }
// Support: Safari 8+, iOS 8+    // https://bugs.webkit.org/show_bug.cgi?id=136851 // In-page `selector#id sibling-combinator selector` fails    if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {     rbuggyQSA.push(".#.+[+~]");    }   });
assert(function( el ) {    el.innerHTML = "<a href= disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
// Support: Windows 8 Native Apps    // The type and name attributes are restricted during .innerHTML assignment    var input = document.createElement("input");    input.setAttribute( "type", "hidden" );    el.appendChild( input ).setAttribute( "name", "D" );
// Support: IE8    // Enforce case-sensitivity of name attribute    if ( el.querySelectorAll("[name=d]").length ) {     rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );    }
// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)    // IE8 throws error here and will not see later tests    if ( el.querySelectorAll(":enabled").length !== 2 ) {     rbuggyQSA.push( ":enabled", ":disabled" );    }
// Support: IE9-11+    // IE's :disabled selector does not pick up the children of disabled fieldsets    docElem.appendChild( el ).disabled = true;    if ( el.querySelectorAll(":disabled").length !== 2 ) {     rbuggyQSA.push( ":enabled", ":disabled" );    }
// Opera 10-11 does not throw on post-comma invalid pseudos    el.querySelectorAll("*,:x");    rbuggyQSA.push(",.*:");   });  }
if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||   docElem.webkitMatchesSelector ||   docElem.mozMatchesSelector ||   docElem.oMatchesSelector ||   docElem.msMatchesSelector) )) ) {
assert(function( el ) {    // Check to see if it's possible to do matchesSelector    // on a disconnected node (IE 9)    support.disconnectedMatch = matches.call( el, "*" );
// This should fail with an exception    // Gecko does not error, returns false instead    matches.call( el, "[s!=]:x" ); rbuggyMatches.push( "!=", pseudos );   });  }
rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );  rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
/* Contains  ---------------------------------------------------------------------- */  hasCompare = rnative.test( docElem.compareDocumentPosition );
// Element contains another  // Purposefully self-exclusive  // As in, an element does not contain itself  contains = hasCompare || rnative.test( docElem.contains ) ?   function( a, b ) {    var adown = a.nodeType === 9 ? a.documentElement : a,     bup = b && b.parentNode;    return a === bup || !!( bup && bup.nodeType === 1 && (     adown.contains ?      adown.contains( bup ) :      a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16    ));   } :   function( a, b ) {    if ( b ) {     while ( (b = b.parentNode) ) {      if ( b === a ) {       return true;      }     }    }    return false;   };
/* Sorting  ---------------------------------------------------------------------- */
// Document order sorting  sortOrder = hasCompare ?  function( a, b ) {
// Flag for duplicate removal   if ( a === b ) {    hasDuplicate = true;    return 0;   }
// Sort on method existence if only one input has compareDocumentPosition   var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;   if ( compare ) {    return compare;   }
// Calculate position if both inputs belong to the same document   compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?    a.compareDocumentPosition( b ) :
// Otherwise we know they are disconnected    1;
// Disconnected nodes   if ( compare & 1 ||    (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
// Choose the first element that is related to our preferred document    if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {     return -1;    }    if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {     return 1;    }
// Maintain original order    return sortInput ?     ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :     0;   }
return compare & 4 ? -1 : 1;  } :  function( a, b ) {   // Exit early if the nodes are identical   if ( a === b ) {    hasDuplicate = true;    return 0;   }
var cur,    i = 0,    aup = a.parentNode,    bup = b.parentNode,    ap = [ a ],    bp = [ b ];
// Parentless nodes are either documents or disconnected   if ( !aup || !bup ) {    return a === document ? -1 :     b === document ? 1 :     aup ? -1 :     bup ? 1 :     sortInput ?     ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :     0;
// If the nodes are siblings, we can do a quick check   } else if ( aup === bup ) {    return siblingCheck( a, b );   }
// Otherwise we need full lists of their ancestors for comparison   cur = a;   while ( (cur = cur.parentNode) ) {    ap.unshift( cur );   }   cur = b;   while ( (cur = cur.parentNode) ) {    bp.unshift( cur );   }
// Walk down the tree looking for a discrepancy   while ( ap[i] === bp[i] ) {    i++;   }
return i ?    // Do a sibling check if the nodes have a common ancestor    siblingCheck( ap[i], bp[i] ) :
// Otherwise nodes in our document sort first    ap[i] === preferredDoc ? -1 :    bp[i] === preferredDoc ? 1 :    0;  };
return document; };
Sizzle.matches = function( expr, elements ) {  return Sizzle( expr, null, null, elements ); };
Sizzle.matchesSelector = function( elem, expr ) {  // Set document vars if needed  if ( ( elem.ownerDocument || elem ) !== document ) {   setDocument( elem );  }
// Make sure that attribute selectors are quoted  expr = expr.replace( rattributeQuotes, "='$1']" );
if ( support.matchesSelector && documentIsHTML && !compilerCache[ expr + " " ] && ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) && ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
try {    var ret = matches.call( elem, expr );
// IE 9's matchesSelector returns false on disconnected nodes    if ( ret || support.disconnectedMatch ||      // As well, disconnected nodes are said to be in a document      // fragment in IE 9      elem.document && elem.document.nodeType !== 11 ) {     return ret;    }   } catch (e) {}  }
return Sizzle( expr, document, null, [ elem ] ).length > 0; };
Sizzle.contains = function( context, elem ) {  // Set document vars if needed  if ( ( context.ownerDocument || context ) !== document ) {   setDocument( context );  }  return contains( context, elem ); };
Sizzle.attr = function( elem, name ) {  // Set document vars if needed  if ( ( elem.ownerDocument || elem ) !== document ) {   setDocument( elem );  }
var fn = Expr.attrHandle[ name.toLowerCase() ],   // Don't get fooled by Object.prototype properties (jQuery #13807)   val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?    fn( elem, name, !documentIsHTML ) :    undefined;
return val !== undefined ?   val :   support.attributes || !documentIsHTML ?    elem.getAttribute( name ) :    (val = elem.getAttributeNode(name)) && val.specified ?     val.value :     null; };
Sizzle.escape = function( sel ) {  return (sel + "").replace( rcssescape, fcssescape ); };
Sizzle.error = function( msg ) {  throw new Error( "Syntax error, unrecognized expression: " + msg ); };
/**
* Document sorting and removing duplicates * @param {ArrayLike} results */
Sizzle.uniqueSort = function( results ) {  var elem,   duplicates = [],   j = 0,   i = 0;
// Unless we *know* we can detect duplicates, assume their presence  hasDuplicate = !support.detectDuplicates;  sortInput = !support.sortStable && results.slice( 0 );  results.sort( sortOrder );
if ( hasDuplicate ) {   while ( (elem = results[i++]) ) {    if ( elem === results[ i ] ) {     j = duplicates.push( i );    }   }   while ( j-- ) {    results.splice( duplicates[ j ], 1 );   }  }
// Clear input after sorting to release objects  // See https://github.com/jquery/sizzle/pull/225 sortInput = null;
return results; };
/**
* Utility function for retrieving the text value of an array of DOM nodes * @param {Array|Element} elem */
getText = Sizzle.getText = function( elem ) {  var node,   ret = "",   i = 0,   nodeType = elem.nodeType;
if ( !nodeType ) {   // If no nodeType, this is expected to be an array   while ( (node = elem[i++]) ) {    // Do not traverse comment nodes    ret += getText( node );   }  } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {   // Use textContent for elements   // innerText usage removed for consistency of new lines (jQuery #11153)   if ( typeof elem.textContent === "string" ) {    return elem.textContent;   } else {    // Traverse its children    for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {     ret += getText( elem );    }   }  } else if ( nodeType === 3 || nodeType === 4 ) {   return elem.nodeValue;  }  // Do not include comment or processing instruction nodes
return ret; };
Expr = Sizzle.selectors = {
// Can be adjusted by the user  cacheLength: 50,
createPseudo: markFunction,
match: matchExpr,
attrHandle: {},
find: {},
relative: {   ">": { dir: "parentNode", first: true },   " ": { dir: "parentNode" },   "+": { dir: "previousSibling", first: true },   "~": { dir: "previousSibling" }  },
preFilter: {   "ATTR": function( match ) {    match[1] = match[1].replace( runescape, funescape );
// Move the given value to match[3] whether quoted or unquoted    match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
if ( match[2] === "~=" ) {     match[3] = " " + match[3] + " ";    }
return match.slice( 0, 4 );   },
"CHILD": function( match ) {    /* matches from matchExpr["CHILD"]     1 type (only|nth|...)     2 what (child|of-type)     3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)     4 xn-component of xn+y argument ([+-]?\d*n|)     5 sign of xn-component     6 x of xn-component     7 sign of y-component     8 y of y-component    */    match[1] = match[1].toLowerCase();
if ( match[1].slice( 0, 3 ) === "nth" ) {     // nth-* requires argument     if ( !match[3] ) {      Sizzle.error( match[0] );     }
// numeric x and y parameters for Expr.filter.CHILD     // remember that false/true cast respectively to 0/1     match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );     match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
// other types prohibit arguments    } else if ( match[3] ) {     Sizzle.error( match[0] );    }
return match;   },
"PSEUDO": function( match ) {    var excess,     unquoted = !match[6] && match[2];
if ( matchExpr["CHILD"].test( match[0] ) ) {     return null;    }
// Accept quoted arguments as-is    if ( match[3] ) {     match[2] = match[4] || match[5] || "";
// Strip excess characters from unquoted arguments    } else if ( unquoted && rpseudo.test( unquoted ) && // Get excess from tokenize (recursively)     (excess = tokenize( unquoted, true )) && // advance to the next closing parenthesis     (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
// excess is a negative index     match[0] = match[0].slice( 0, excess );     match[2] = unquoted.slice( 0, excess );    }
// Return only captures needed by the pseudo filter method (type and argument)    return match.slice( 0, 3 );   }  },
filter: {
"TAG": function( nodeNameSelector ) {    var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();    return nodeNameSelector === "*" ?     function() { return true; } :     function( elem ) {      return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;     };   },
"CLASS": function( className ) {    var pattern = classCache[ className + " " ];
return pattern ||     (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) && classCache( className, function( elem ) {      return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );     });   },
"ATTR": function( name, operator, check ) {    return function( elem ) {     var result = Sizzle.attr( elem, name );
if ( result == null ) {      return operator === "!=";     }     if ( !operator ) {      return true;     }
result += "";
return operator === "=" ? result === check :      operator === "!=" ? result !== check :      operator === "^=" ? check && result.indexOf( check ) === 0 :      operator === "*=" ? check && result.indexOf( check ) > -1 :      operator === "$=" ? check && result.slice( -check.length ) === check :      operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :      operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :      false;    };   },
"CHILD": function( type, what, argument, first, last ) {    var simple = type.slice( 0, 3 ) !== "nth",     forward = type.slice( -4 ) !== "last",     ofType = what === "of-type";
return first === 1 && last === 0 ?
// Shortcut for :nth-*(n)     function( elem ) {      return !!elem.parentNode;     } :
function( elem, context, xml ) {      var cache, uniqueCache, outerCache, node, nodeIndex, start,       dir = simple !== forward ? "nextSibling" : "previousSibling",       parent = elem.parentNode,       name = ofType && elem.nodeName.toLowerCase(),       useCache = !xml && !ofType,       diff = false;
if ( parent ) {
// :(first|last|only)-(child|of-type)       if ( simple ) {        while ( dir ) {         node = elem;         while ( (node = node[ dir ]) ) {          if ( ofType ?           node.nodeName.toLowerCase() === name :           node.nodeType === 1 ) {
return false;          }         }         // Reverse direction for :only-* (if we haven't yet done so)         start = dir = type === "only" && !start && "nextSibling";        }        return true;       }
start = [ forward ? parent.firstChild : parent.lastChild ];
// non-xml :nth-child(...) stores cache data on `parent`       if ( forward && useCache ) {
// Seek `elem` from a previously-cached index
// ...in a gzip-friendly way        node = parent;        outerCache = node[ expando ] || (node[ expando ] = {});
// Support: IE <9 only        // Defend against cloned attroperties (jQuery gh-1709)        uniqueCache = outerCache[ node.uniqueID ] ||         (outerCache[ node.uniqueID ] = {});
cache = uniqueCache[ type ] || [];        nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];        diff = nodeIndex && cache[ 2 ];        node = nodeIndex && parent.childNodes[ nodeIndex ];
while ( (node = ++nodeIndex && node && node[ dir ] ||
// Fallback to seeking `elem` from the start         (diff = nodeIndex = 0) || start.pop()) ) {
// When found, cache indexes on `parent` and break         if ( node.nodeType === 1 && ++diff && node === elem ) {          uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];          break;         }        }
} else {        // Use previously-cached element index if available        if ( useCache ) {         // ...in a gzip-friendly way         node = elem;         outerCache = node[ expando ] || (node[ expando ] = {});
// Support: IE <9 only         // Defend against cloned attroperties (jQuery gh-1709)         uniqueCache = outerCache[ node.uniqueID ] ||          (outerCache[ node.uniqueID ] = {});
cache = uniqueCache[ type ] || [];         nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];         diff = nodeIndex;        }
// xml :nth-child(...)        // or :nth-last-child(...) or :nth(-last)?-of-type(...)        if ( diff === false ) {         // Use the same loop as above to seek `elem` from the start         while ( (node = ++nodeIndex && node && node[ dir ] ||          (diff = nodeIndex = 0) || start.pop()) ) {
if ( ( ofType ?           node.nodeName.toLowerCase() === name :           node.nodeType === 1 ) && ++diff ) {
// Cache the index of each encountered element           if ( useCache ) {            outerCache = node[ expando ] || (node[ expando ] = {});
// Support: IE <9 only            // Defend against cloned attroperties (jQuery gh-1709)            uniqueCache = outerCache[ node.uniqueID ] ||             (outerCache[ node.uniqueID ] = {});
uniqueCache[ type ] = [ dirruns, diff ];           }
if ( node === elem ) {            break;           }          }         }        }       }
// Incorporate the offset, then check against cycle size       diff -= last;       return diff === first || ( diff % first === 0 && diff / first >= 0 );      }     };   },
"PSEUDO": function( pseudo, argument ) {    // pseudo-class names are case-insensitive    // http://www.w3.org/TR/selectors/#pseudo-classes // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters    // Remember that setFilters inherits from pseudos    var args,     fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||      Sizzle.error( "unsupported pseudo: " + pseudo );
// The user may use createPseudo to indicate that    // arguments are needed to create the filter function    // just as Sizzle does    if ( fn[ expando ] ) {     return fn( argument );    }
// But maintain support for old signatures    if ( fn.length > 1 ) {     args = [ pseudo, pseudo, "", argument ];     return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?      markFunction(function( seed, matches ) {       var idx,        matched = fn( seed, argument ),        i = matched.length;       while ( i-- ) {        idx = indexOf( seed, matched[i] );        seed[ idx ] = !( matches[ idx ] = matched[i] );       }      }) :      function( elem ) {       return fn( elem, 0, args );      };    }
return fn;   }  },
pseudos: {   // Potentially complex pseudos   "not": markFunction(function( selector ) {    // Trim the selector passed to compile    // to avoid treating leading and trailing    // spaces as combinators    var input = [],     results = [],     matcher = compile( selector.replace( rtrim, "$1" ) );
return matcher[ expando ] ?     markFunction(function( seed, matches, context, xml ) {      var elem,       unmatched = matcher( seed, null, xml, [] ),       i = seed.length;
// Match elements unmatched by `matcher`      while ( i-- ) {       if ( (elem = unmatched[i]) ) {        seed[i] = !(matches[i] = elem);       }      }     }) :     function( elem, context, xml ) {      input[0] = elem;      matcher( input, null, xml, results );      // Don't keep the element (issue #299)      input[0] = null;      return !results.pop();     };   }),
"has": markFunction(function( selector ) {    return function( elem ) {     return Sizzle( selector, elem ).length > 0;    };   }),
"contains": markFunction(function( text ) {    text = text.replace( runescape, funescape );    return function( elem ) {     return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;    };   }),
// "Whether an element is represented by a :lang() selector   // is based solely on the element's language value   // being equal to the identifier C,   // or beginning with the identifier C immediately followed by "-".   // The matching of C against the element's language value is performed case-insensitively.   // The identifier C does not have to be a valid language name."   // http://www.w3.org/TR/selectors/#lang-pseudo "lang": markFunction( function( lang ) {    // lang value must be a valid identifier    if ( !ridentifier.test(lang || "") ) {     Sizzle.error( "unsupported lang: " + lang );    }    lang = lang.replace( runescape, funescape ).toLowerCase();    return function( elem ) {     var elemLang;     do {      if ( (elemLang = documentIsHTML ?       elem.lang :       elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
elemLang = elemLang.toLowerCase();       return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;      }     } while ( (elem = elem.parentNode) && elem.nodeType === 1 );     return false;    };   }),
// Miscellaneous   "target": function( elem ) {    var hash = window.location && window.location.hash;    return hash && hash.slice( 1 ) === elem.id;   },
"root": function( elem ) {    return elem === docElem;   },
"focus": function( elem ) {    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);   },
// Boolean properties   "enabled": createDisabledPseudo( false ),   "disabled": createDisabledPseudo( true ),
"checked": function( elem ) {    // In CSS3, :checked should return both checked and selected elements    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked var nodeName = elem.nodeName.toLowerCase();    return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);   },
"selected": function( elem ) {    // Accessing this property makes selected-by-default    // options in Safari work properly    if ( elem.parentNode ) {     elem.parentNode.selectedIndex;    }
return elem.selected === true;   },
// Contents   "empty": function( elem ) {    // http://www.w3.org/TR/selectors/#empty-pseudo // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),    //   but not by others (comment: 8; processing instruction: 7; etc.)    // nodeType < 6 works because attributes (2) do not appear as children    for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {     if ( elem.nodeType < 6 ) {      return false;     }    }    return true;   },
"parent": function( elem ) {    return !Expr.pseudos["empty"]( elem );   },
// Element/input types   "header": function( elem ) {    return rheader.test( elem.nodeName );   },
"input": function( elem ) {    return rinputs.test( elem.nodeName );   },
"button": function( elem ) {    var name = elem.nodeName.toLowerCase();    return name === "input" && elem.type === "button" || name === "button";   },
"text": function( elem ) {    var attr;    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" &&
// Support: IE<8     // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"     ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );   },
// Position-in-collection   "first": createPositionalPseudo(function() {    return [ 0 ];   }),
"last": createPositionalPseudo(function( matchIndexes, length ) {    return [ length - 1 ];   }),
"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {    return [ argument < 0 ? argument + length : argument ];   }),
"even": createPositionalPseudo(function( matchIndexes, length ) {    var i = 0;    for ( ; i < length; i += 2 ) {     matchIndexes.push( i );    }    return matchIndexes;   }),
"odd": createPositionalPseudo(function( matchIndexes, length ) {    var i = 1;    for ( ; i < length; i += 2 ) {     matchIndexes.push( i );    }    return matchIndexes;   }),
"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {    var i = argument < 0 ? argument + length : argument;    for ( ; --i >= 0; ) {     matchIndexes.push( i );    }    return matchIndexes;   }),
"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {    var i = argument < 0 ? argument + length : argument;    for ( ; ++i < length; ) {     matchIndexes.push( i );    }    return matchIndexes;   })  } };
Expr.pseudos["nth"] = Expr.pseudos["eq"];
// Add button/input type pseudos for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {  Expr.pseudos[ i ] = createInputPseudo( i ); } for ( i in { submit: true, reset: true } ) {  Expr.pseudos[ i ] = createButtonPseudo( i ); }
// Easy API for creating new setFilters function setFilters() {} setFilters.prototype = Expr.filters = Expr.pseudos; Expr.setFilters = new setFilters();
tokenize = Sizzle.tokenize = function( selector, parseOnly ) {  var matched, match, tokens, type,   soFar, groups, preFilters,   cached = tokenCache[ selector + " " ];
if ( cached ) {   return parseOnly ? 0 : cached.slice( 0 );  }
soFar = selector;  groups = [];  preFilters = Expr.preFilter;
while ( soFar ) {
// Comma and first run   if ( !matched || (match = rcomma.exec( soFar )) ) {    if ( match ) {     // Don't consume trailing commas as valid     soFar = soFar.slice( match[0].length ) || soFar;    }    groups.push( (tokens = []) );   }
matched = false;
// Combinators   if ( (match = rcombinators.exec( soFar )) ) {    matched = match.shift();    tokens.push({     value: matched,     // Cast descendant combinators to space     type: match[0].replace( rtrim, " " )    });    soFar = soFar.slice( matched.length );   }
// Filters   for ( type in Expr.filter ) {    if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||     (match = preFilters[ type ]( match ))) ) {     matched = match.shift();     tokens.push({      value: matched,      type: type,      matches: match     });     soFar = soFar.slice( matched.length );    }   }
if ( !matched ) {    break;   }  }
// Return the length of the invalid excess  // if we're just parsing  // Otherwise, throw an error or return tokens  return parseOnly ?   soFar.length :   soFar ?    Sizzle.error( selector ) :    // Cache the tokens    tokenCache( selector, groups ).slice( 0 ); };
function toSelector( tokens ) {  var i = 0,   len = tokens.length,   selector = "";  for ( ; i < len; i++ ) {   selector += tokens[i].value;  }  return selector; }
function addCombinator( matcher, combinator, base ) {  var dir = combinator.dir,   skip = combinator.next,   key = skip || dir,   checkNonElements = base && key === "parentNode",   doneName = done++;
return combinator.first ?   // Check against closest ancestor/preceding element   function( elem, context, xml ) {    while ( (elem = elem[ dir ]) ) {     if ( elem.nodeType === 1 || checkNonElements ) {      return matcher( elem, context, xml );     }    }    return false;   } :
// Check against all ancestor/preceding elements   function( elem, context, xml ) {    var oldCache, uniqueCache, outerCache,     newCache = [ dirruns, doneName ];
// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching    if ( xml ) {     while ( (elem = elem[ dir ]) ) {      if ( elem.nodeType === 1 || checkNonElements ) {       if ( matcher( elem, context, xml ) ) {        return true;       }      }     }    } else {     while ( (elem = elem[ dir ]) ) {      if ( elem.nodeType === 1 || checkNonElements ) {       outerCache = elem[ expando ] || (elem[ expando ] = {});
// Support: IE <9 only       // Defend against cloned attroperties (jQuery gh-1709)       uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
if ( skip && skip === elem.nodeName.toLowerCase() ) {        elem = elem[ dir ] || elem;       } else if ( (oldCache = uniqueCache[ key ]) && oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
// Assign to newCache so results back-propagate to previous elements        return (newCache[ 2 ] = oldCache[ 2 ]);       } else {        // Reuse newcache so results back-propagate to previous elements        uniqueCache[ key ] = newCache;
// A match means we're done; a fail means we have to keep checking        if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {         return true;        }       }      }     }    }    return false;   }; }
function elementMatcher( matchers ) {  return matchers.length > 1 ?   function( elem, context, xml ) {    var i = matchers.length;    while ( i-- ) {     if ( !matchers[i]( elem, context, xml ) ) {      return false;     }    }    return true;   } :   matchers[0]; }
function multipleContexts( selector, contexts, results ) {  var i = 0,   len = contexts.length;  for ( ; i < len; i++ ) {   Sizzle( selector, contexts[i], results );  }  return results; }
function condense( unmatched, map, filter, context, xml ) {  var elem,   newUnmatched = [],   i = 0,   len = unmatched.length,   mapped = map != null;
for ( ; i < len; i++ ) {   if ( (elem = unmatched[i]) ) {    if ( !filter || filter( elem, context, xml ) ) {     newUnmatched.push( elem );     if ( mapped ) {      map.push( i );     }    }   }  }
return newUnmatched; }
function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {  if ( postFilter && !postFilter[ expando ] ) {   postFilter = setMatcher( postFilter );  }  if ( postFinder && !postFinder[ expando ] ) {   postFinder = setMatcher( postFinder, postSelector );  }  return markFunction(function( seed, results, context, xml ) {   var temp, i, elem,    preMap = [],    postMap = [],    preexisting = results.length,
// Get initial elements from seed or context    elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
// Prefilter to get matcher input, preserving a map for seed-results synchronization    matcherIn = preFilter && ( seed || !selector ) ?     condense( elems, preMap, preFilter, context, xml ) :     elems,
matcherOut = matcher ?     // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,     postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
// ...intermediate processing is necessary      [] :
// ...otherwise use results directly      results :     matcherIn;
// Find primary matches   if ( matcher ) {    matcher( matcherIn, matcherOut, context, xml );   }
// Apply postFilter   if ( postFilter ) {    temp = condense( matcherOut, postMap );    postFilter( temp, [], context, xml );
// Un-match failing elements by moving them back to matcherIn    i = temp.length;    while ( i-- ) {     if ( (elem = temp[i]) ) {      matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);     }    }   }
if ( seed ) {    if ( postFinder || preFilter ) {     if ( postFinder ) {      // Get the final matcherOut by condensing this intermediate into postFinder contexts      temp = [];      i = matcherOut.length;      while ( i-- ) {       if ( (elem = matcherOut[i]) ) {        // Restore matcherIn since elem is not yet a final match        temp.push( (matcherIn[i] = elem) );       }      }      postFinder( null, (matcherOut = []), temp, xml );     }
// Move matched elements from seed to results to keep them synchronized     i = matcherOut.length;     while ( i-- ) {      if ( (elem = matcherOut[i]) && (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
seed[temp] = !(results[temp] = elem);      }     }    }
// Add elements to results, through postFinder if defined   } else {    matcherOut = condense(     matcherOut === results ?      matcherOut.splice( preexisting, matcherOut.length ) :      matcherOut    );    if ( postFinder ) {     postFinder( null, results, matcherOut, xml );    } else {     push.apply( results, matcherOut );    }   }  }); }
function matcherFromTokens( tokens ) {  var checkContext, matcher, j,   len = tokens.length,   leadingRelative = Expr.relative[ tokens[0].type ],   implicitRelative = leadingRelative || Expr.relative[" "],   i = leadingRelative ? 1 : 0,
// The foundational matcher ensures that elements are reachable from top-level context(s)   matchContext = addCombinator( function( elem ) {    return elem === checkContext;   }, implicitRelative, true ),   matchAnyContext = addCombinator( function( elem ) {    return indexOf( checkContext, elem ) > -1;   }, implicitRelative, true ),   matchers = [ function( elem, context, xml ) {    var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (     (checkContext = context).nodeType ?      matchContext( elem, context, xml ) :      matchAnyContext( elem, context, xml ) );    // Avoid hanging onto element (issue #299)    checkContext = null;    return ret;   } ];
for ( ; i < len; i++ ) {   if ( (matcher = Expr.relative[ tokens[i].type ]) ) {    matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];   } else {    matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
// Return special upon seeing a positional matcher    if ( matcher[ expando ] ) {     // Find the next relative operator (if any) for proper handling     j = ++i;     for ( ; j < len; j++ ) {      if ( Expr.relative[ tokens[j].type ] ) {       break;      }     }     return setMatcher(      i > 1 && elementMatcher( matchers ),      i > 1 && toSelector(       // If the preceding token was a descendant combinator, insert an implicit any-element `*`       tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })      ).replace( rtrim, "$1" ),      matcher,      i < j && matcherFromTokens( tokens.slice( i, j ) ),      j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),      j < len && toSelector( tokens )     );    }    matchers.push( matcher );   }  }
return elementMatcher( matchers ); }
function matcherFromGroupMatchers( elementMatchers, setMatchers ) {  var bySet = setMatchers.length > 0,   byElement = elementMatchers.length > 0,   superMatcher = function( seed, context, xml, results, outermost ) {    var elem, j, matcher,     matchedCount = 0,     i = "0",     unmatched = seed && [],     setMatched = [],     contextBackup = outermostContext,     // We must always have either seed elements or outermost context     elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),     // Use integer dirruns iff this is the outermost matcher     dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),     len = elems.length;
if ( outermost ) {     outermostContext = context === document || context || outermost;    }
// Add elements passing elementMatchers directly to results    // Support: IE<9, Safari    // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id    for ( ; i !== len && (elem = elems[i]) != null; i++ ) {     if ( byElement && elem ) {      j = 0;      if ( !context && elem.ownerDocument !== document ) {       setDocument( elem );       xml = !documentIsHTML;      }      while ( (matcher = elementMatchers[j++]) ) {       if ( matcher( elem, context || document, xml) ) {        results.push( elem );        break;       }      }      if ( outermost ) {       dirruns = dirrunsUnique;      }     }
// Track unmatched elements for set filters     if ( bySet ) {      // They will have gone through all possible matchers      if ( (elem = !matcher && elem) ) {       matchedCount--;      }
// Lengthen the array for every element, matched or not      if ( seed ) {       unmatched.push( elem );      }     }    }
// `i` is now the count of elements visited above, and adding it to `matchedCount`    // makes the latter nonnegative.    matchedCount += i;
// Apply set filters to unmatched elements    // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`    // equals `i`), unless we didn't visit _any_ elements in the above loop because we have    // no element matchers and no seed.    // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that    // case, which will result in a "00" `matchedCount` that differs from `i` but is also    // numerically zero.    if ( bySet && i !== matchedCount ) {     j = 0;     while ( (matcher = setMatchers[j++]) ) {      matcher( unmatched, setMatched, context, xml );     }
if ( seed ) {      // Reintegrate element matches to eliminate the need for sorting      if ( matchedCount > 0 ) {       while ( i-- ) {        if ( !(unmatched[i] || setMatched[i]) ) {         setMatched[i] = pop.call( results );        }       }      }
// Discard index placeholder values to get only actual matches      setMatched = condense( setMatched );     }
// Add matches to results     push.apply( results, setMatched );
// Seedless set matches succeeding multiple successful matchers stipulate sorting     if ( outermost && !seed && setMatched.length > 0 && ( matchedCount + setMatchers.length ) > 1 ) {
Sizzle.uniqueSort( results );     }    }
// Override manipulation of globals by nested matchers    if ( outermost ) {     dirruns = dirrunsUnique;     outermostContext = contextBackup;    }
return unmatched;   };
return bySet ?   markFunction( superMatcher ) :   superMatcher; }
compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {  var i,   setMatchers = [],   elementMatchers = [],   cached = compilerCache[ selector + " " ];
if ( !cached ) {   // Generate a function of recursive functions that can be used to check each element   if ( !match ) {    match = tokenize( selector );   }   i = match.length;   while ( i-- ) {    cached = matcherFromTokens( match[i] );    if ( cached[ expando ] ) {     setMatchers.push( cached );    } else {     elementMatchers.push( cached );    }   }
// Cache the compiled function   cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
// Save selector and tokenization   cached.selector = selector;  }  return cached; };
/**
* A low-level selection function that works with Sizzle's compiled *  selector functions * @param {String|Function} selector A selector or a pre-compiled *  selector function built with Sizzle.compile * @param {Element} context * @param {Array} [results] * @param {Array} [seed] A set of elements to match against */
select = Sizzle.select = function( selector, context, results, seed ) {  var i, tokens, token, type, find,   compiled = typeof selector === "function" && selector,   match = !seed && tokenize( (selector = compiled.selector || selector) );
results = results || [];
// Try to minimize operations if there is only one selector in the list and no seed  // (the latter of which guarantees us context)  if ( match.length === 1 ) {
// Reduce context if the leading compound selector is an ID   tokens = match[0] = match[0].slice( 0 );   if ( tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {
context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];    if ( !context ) {     return results;
// Precompiled matchers will still verify ancestry, so step up a level    } else if ( compiled ) {     context = context.parentNode;    }
selector = selector.slice( tokens.shift().value.length );   }
// Fetch a seed set for right-to-left matching   i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;   while ( i-- ) {    token = tokens[i];
// Abort if we hit a combinator    if ( Expr.relative[ (type = token.type) ] ) {     break;    }    if ( (find = Expr.find[ type ]) ) {     // Search, expanding context for leading sibling combinators     if ( (seed = find(      token.matches[0].replace( runescape, funescape ),      rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context     )) ) {
// If seed is empty or no tokens remain, we can return early      tokens.splice( i, 1 );      selector = seed.length && toSelector( tokens );      if ( !selector ) {       push.apply( results, seed );       return results; }
break;     }    }   }  }
// Compile and execute a filtering function if one is not provided  // Provide `match` to avoid retokenization if we modified the selector above  ( compiled || compile( selector, match ) )(   seed,   context,   !documentIsHTML,   results,   !context || rsibling.test( selector ) && testContext( context.parentNode ) || context  );  return results; };
// One-time assignments
// Sort stability support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
// Support: Chrome 14-35+ // Always assume duplicates if they aren't passed to the comparison function support.detectDuplicates = !!hasDuplicate;
// Initialize against the default document setDocument();
// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27) // Detached nodes confoundingly follow *each other* support.sortDetached = assert(function( el ) {  // Should return 1, but returns 4 (following)  return el.compareDocumentPosition( document.createElement("fieldset") ) & 1; });
// Support: IE<8 // Prevent attribute/property "interpolation" // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx if ( !assert(function( el ) {  el.innerHTML = "<a href='#'></a>";  return el.firstChild.getAttribute("href") === "#" ; }) ) {  addHandle( "type|href|height|width", function( elem, name, isXML ) {   if ( !isXML ) {    return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );   }  }); }
// Support: IE<9 // Use defaultValue in place of getAttribute("value") if ( !support.attributes || !assert(function( el ) {  el.innerHTML = "<input/>";  el.firstChild.setAttribute( "value", "" );  return el.firstChild.getAttribute( "value" ) === ""; }) ) {  addHandle( "value", function( elem, name, isXML ) {   if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {    return elem.defaultValue;   }  }); }
// Support: IE<9 // Use getAttributeNode to fetch booleans when getAttribute lies if ( !assert(function( el ) {  return el.getAttribute("disabled") == null; }) ) {  addHandle( booleans, function( elem, name, isXML ) {   var val;   if ( !isXML ) {    return elem[ name ] === true ? name.toLowerCase() :      (val = elem.getAttributeNode( name )) && val.specified ?      val.value :     null;   }  }); }
return Sizzle;
})( window );
jQuery.find = Sizzle; jQuery.expr = Sizzle.selectors;
// Deprecated jQuery.expr[ ":" ] = jQuery.expr.pseudos; jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort; jQuery.text = Sizzle.getText; jQuery.isXMLDoc = Sizzle.isXML; jQuery.contains = Sizzle.contains; jQuery.escapeSelector = Sizzle.escape;
var dir = function( elem, dir, until ) {  var matched = [],   truncate = until !== undefined;
while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {   if ( elem.nodeType === 1 ) {    if ( truncate && jQuery( elem ).is( until ) ) {     break;    }    matched.push( elem );   }  }  return matched; };
var siblings = function( n, elem ) {  var matched = [];
for ( ; n; n = n.nextSibling ) {   if ( n.nodeType === 1 && n !== elem ) {    matched.push( n );   }  }
return matched; };
var rneedsContext = jQuery.expr.match.needsContext;
function nodeName( elem, name ) {
return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
}; var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
var risSimple = /^.[^:#\[\.,]*$/;
// Implement the identical functionality for filter and not function winnow( elements, qualifier, not ) {  if ( jQuery.isFunction( qualifier ) ) {   return jQuery.grep( elements, function( elem, i ) {    return !!qualifier.call( elem, i, elem ) !== not;   } );  }
// Single element  if ( qualifier.nodeType ) {   return jQuery.grep( elements, function( elem ) {    return ( elem === qualifier ) !== not;   } );  }
// Arraylike of elements (jQuery, arguments, Array)  if ( typeof qualifier !== "string" ) {   return jQuery.grep( elements, function( elem ) {    return ( indexOf.call( qualifier, elem ) > -1 ) !== not;   } );  }
// Simple selector that can be filtered directly, removing non-Elements  if ( risSimple.test( qualifier ) ) {   return jQuery.filter( qualifier, elements, not );  }
// Complex selector, compare the two sets, removing non-Elements  qualifier = jQuery.filter( qualifier, elements );  return jQuery.grep( elements, function( elem ) {   return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;  } ); }
jQuery.filter = function( expr, elems, not ) {  var elem = elems[ 0 ];
if ( not ) {   expr = ":not(" + expr + ")";  }
if ( elems.length === 1 && elem.nodeType === 1 ) {   return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];  }
return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {   return elem.nodeType === 1;  } ) ); };
jQuery.fn.extend( {  find: function( selector ) {   var i, ret,    len = this.length,    self = this;
if ( typeof selector !== "string" ) {    return this.pushStack( jQuery( selector ).filter( function() {     for ( i = 0; i < len; i++ ) {      if ( jQuery.contains( self[ i ], this ) ) {       return true;      }     }    } ) );   }
ret = this.pushStack( [] );
for ( i = 0; i < len; i++ ) {    jQuery.find( selector, self[ i ], ret );   }
return len > 1 ? jQuery.uniqueSort( ret ) : ret;  },  filter: function( selector ) {   return this.pushStack( winnow( this, selector || [], false ) );  },  not: function( selector ) {   return this.pushStack( winnow( this, selector || [], true ) );  },  is: function( selector ) {   return !!winnow(    this,
// If this is a positional/relative selector, check membership in the returned set    // so $("p:first").is("p:last") won't return true for a doc with two "p".    typeof selector === "string" && rneedsContext.test( selector ) ?     jQuery( selector ) :     selector || [],    false   ).length;  } } );
// Initialize a jQuery object
// A central reference to the root jQuery(document) var rootjQuery,
// A simple way to check for HTML strings  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)  // Strict HTML recognition (#11290: must start with <)  // Shortcut simple #id case for speed  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
init = jQuery.fn.init = function( selector, context, root ) {   var match, elem;
// HANDLE: $(""), $(null), $(undefined), $(false)   if ( !selector ) {    return this;   }
// Method init() accepts an alternate rootjQuery   // so migrate can support jQuery.sub (gh-2101)   root = root || rootjQuery;
// Handle HTML strings   if ( typeof selector === "string" ) {    if ( selector[ 0 ] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
// Assume that strings that start and end with <> are HTML and skip the regex check     match = [ null, selector, null ];
} else {     match = rquickExpr.exec( selector );    }
// Match html or make sure no context is specified for #id    if ( match && ( match[ 1 ] || !context ) ) {
// HANDLE: $(html) -> $(array)     if ( match[ 1 ] ) {      context = context instanceof jQuery ? context[ 0 ] : context;
// Option to run scripts is true for back-compat      // Intentionally let the error be thrown if parseHTML is not present      jQuery.merge( this, jQuery.parseHTML(       match[ 1 ],       context && context.nodeType ? context.ownerDocument || context : document,       true      ) );
// HANDLE: $(html, props)      if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {       for ( match in context ) {
// Properties of context are called as methods if possible        if ( jQuery.isFunction( this[ match ] ) ) {         this[ match ]( context[ match ] );
// ...and otherwise set as attributes        } else {         this.attr( match, context[ match ] );        }       }      }
return this;
// HANDLE: $(#id)     } else {      elem = document.getElementById( match[ 2 ] );
if ( elem ) {
// Inject the element directly into the jQuery object       this[ 0 ] = elem;       this.length = 1;      }      return this;     }
// HANDLE: $(expr, $(...))    } else if ( !context || context.jquery ) {     return ( context || root ).find( selector );
// HANDLE: $(expr, context)    // (which is just equivalent to: $(context).find(expr)    } else {     return this.constructor( context ).find( selector );    }
// HANDLE: $(DOMElement)   } else if ( selector.nodeType ) {    this[ 0 ] = selector;    this.length = 1;    return this;
// HANDLE: $(function)   // Shortcut for document ready   } else if ( jQuery.isFunction( selector ) ) {    return root.ready !== undefined ?     root.ready( selector ) :
// Execute immediately if ready is not present     selector( jQuery );   }
return jQuery.makeArray( selector, this );  };
// Give the init function the jQuery prototype for later instantiation init.prototype = jQuery.fn;
// Initialize central reference rootjQuery = jQuery( document );
var rparentsprev = /^(?:parents|prev(?:Until|All))/,
// Methods guaranteed to produce a unique set when starting from a unique set  guaranteedUnique = {   children: true,   contents: true,   next: true,   prev: true  };
jQuery.fn.extend( {  has: function( target ) {   var targets = jQuery( target, this ),    l = targets.length;
return this.filter( function() {    var i = 0;    for ( ; i < l; i++ ) {     if ( jQuery.contains( this, targets[ i ] ) ) {      return true;     }    }   } );  },
closest: function( selectors, context ) {   var cur,    i = 0,    l = this.length,    matched = [],    targets = typeof selectors !== "string" && jQuery( selectors );
// Positional selectors never match, since there's no _selection_ context   if ( !rneedsContext.test( selectors ) ) {    for ( ; i < l; i++ ) {     for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
// Always skip document fragments      if ( cur.nodeType < 11 && ( targets ?       targets.index( cur ) > -1 :
// Don't pass non-elements to Sizzle       cur.nodeType === 1 && jQuery.find.matchesSelector( cur, selectors ) ) ) {
matched.push( cur );       break;      }     }    }   }
return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );  },
// Determine the position of an element within the set  index: function( elem ) {
// No argument, return index in parent   if ( !elem ) {    return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;   }
// Index in selector   if ( typeof elem === "string" ) {    return indexOf.call( jQuery( elem ), this[ 0 ] );   }
// Locate the position of the desired element   return indexOf.call( this,
// If it receives a jQuery object, the first element is used    elem.jquery ? elem[ 0 ] : elem   );  },
add: function( selector, context ) {   return this.pushStack(    jQuery.uniqueSort(     jQuery.merge( this.get(), jQuery( selector, context ) )    )   );  },
addBack: function( selector ) {   return this.add( selector == null ?    this.prevObject : this.prevObject.filter( selector )   );  } } );
function sibling( cur, dir ) {  while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}  return cur; }
jQuery.each( {  parent: function( elem ) {   var parent = elem.parentNode;   return parent && parent.nodeType !== 11 ? parent : null;  },  parents: function( elem ) {   return dir( elem, "parentNode" );  },  parentsUntil: function( elem, i, until ) {   return dir( elem, "parentNode", until );  },  next: function( elem ) {   return sibling( elem, "nextSibling" );  },  prev: function( elem ) {   return sibling( elem, "previousSibling" );  },  nextAll: function( elem ) {   return dir( elem, "nextSibling" );  },  prevAll: function( elem ) {   return dir( elem, "previousSibling" );  },  nextUntil: function( elem, i, until ) {   return dir( elem, "nextSibling", until );  },  prevUntil: function( elem, i, until ) {   return dir( elem, "previousSibling", until );  },  siblings: function( elem ) {   return siblings( ( elem.parentNode || {} ).firstChild, elem );  },  children: function( elem ) {   return siblings( elem.firstChild );  },  contents: function( elem ) {
if ( nodeName( elem, "iframe" ) ) {            return elem.contentDocument;        }
// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only        // Treat the template element as a regular one in browsers that        // don't support it.        if ( nodeName( elem, "template" ) ) {            elem = elem.content || elem;        }
return jQuery.merge( [], elem.childNodes );
} }, function( name, fn ) {  jQuery.fn[ name ] = function( until, selector ) {   var matched = jQuery.map( this, fn, until );
if ( name.slice( -5 ) !== "Until" ) {    selector = until;   }
if ( selector && typeof selector === "string" ) {    matched = jQuery.filter( selector, matched );   }
if ( this.length > 1 ) {
// Remove duplicates    if ( !guaranteedUnique[ name ] ) {     jQuery.uniqueSort( matched );    }
// Reverse order for parents* and prev-derivatives    if ( rparentsprev.test( name ) ) {     matched.reverse();    }   }
return this.pushStack( matched );  }; } ); var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
// Convert String-formatted options into Object-formatted ones function createOptions( options ) {  var object = {};  jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {   object[ flag ] = true;  } );  return object; }
/*
* Create a callback list using the following parameters: * * options: an optional list of space-separated options that will change how *   the callback list behaves or a more traditional option object * * By default a callback list will act like an event callback list and can be * "fired" multiple times. * * Possible options: * * once:   will ensure the callback list can only be fired once (like a Deferred) * * memory:   will keep track of previous values and will call any callback added *     after the list has been fired right away with the latest "memorized" *     values (like a Deferred) * * unique:   will ensure a callback can only be added once (no duplicate in the list) * * stopOnFalse: interrupt callings when a callback returns false * */
jQuery.Callbacks = function( options ) {
// Convert options from String-formatted to Object-formatted if needed  // (we check in cache first)  options = typeof options === "string" ?   createOptions( options ) :   jQuery.extend( {}, options );
var // Flag to know if list is currently firing   firing,
// Last fire value for non-forgettable lists   memory,
// Flag to know if list was already fired   fired,
// Flag to prevent firing   locked,
// Actual callback list   list = [],
// Queue of execution data for repeatable lists   queue = [],
// Index of currently firing callback (modified by add/remove as needed)   firingIndex = -1,
// Fire callbacks   fire = function() {
// Enforce single-firing    locked = locked || options.once;
// Execute callbacks for all pending executions,    // respecting firingIndex overrides and runtime changes    fired = firing = true;    for ( ; queue.length; firingIndex = -1 ) {     memory = queue.shift();     while ( ++firingIndex < list.length ) {
// Run callback and check for early termination      if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false && options.stopOnFalse ) {
// Jump to end and forget the data so .add doesn't re-fire       firingIndex = list.length;       memory = false;      }     }    }
// Forget the data if we're done with it    if ( !options.memory ) {     memory = false;    }
firing = false;
// Clean up if we're done firing for good    if ( locked ) {
// Keep an empty list if we have data for future add calls     if ( memory ) {      list = [];
// Otherwise, this object is spent     } else {      list = "";     }    }   },
// Actual Callbacks object   self = {
// Add a callback or a collection of callbacks to the list    add: function() {     if ( list ) {
// If we have memory from a past run, we should fire after adding      if ( memory && !firing ) {       firingIndex = list.length - 1;       queue.push( memory );      }
( function add( args ) {       jQuery.each( args, function( _, arg ) {        if ( jQuery.isFunction( arg ) ) {         if ( !options.unique || !self.has( arg ) ) {          list.push( arg );         }        } else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
// Inspect recursively         add( arg );        }       } );      } )( arguments );
if ( memory && !firing ) {       fire();      }     }     return this;    },
// Remove a callback from the list    remove: function() {     jQuery.each( arguments, function( _, arg ) {      var index;      while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {       list.splice( index, 1 );
// Handle firing indexes       if ( index <= firingIndex ) {        firingIndex--;       }      }     } );     return this;    },
// Check if a given callback is in the list.    // If no argument is given, return whether or not list has callbacks attached.    has: function( fn ) {     return fn ?      jQuery.inArray( fn, list ) > -1 :      list.length > 0;    },
// Remove all callbacks from the list    empty: function() {     if ( list ) {      list = [];     }     return this;    },
// Disable .fire and .add    // Abort any current/pending executions    // Clear all callbacks and values    disable: function() {     locked = queue = [];     list = memory = "";     return this;    },    disabled: function() {     return !list;    },
// Disable .fire    // Also disable .add unless we have memory (since it would have no effect)    // Abort any pending executions    lock: function() {     locked = queue = [];     if ( !memory && !firing ) {      list = memory = "";     }     return this;    },    locked: function() {     return !!locked;    },
// Call all callbacks with the given context and arguments    fireWith: function( context, args ) {     if ( !locked ) {      args = args || [];      args = [ context, args.slice ? args.slice() : args ];      queue.push( args );      if ( !firing ) {       fire();      }     }     return this;    },
// Call all the callbacks with the given arguments    fire: function() {     self.fireWith( this, arguments );     return this;    },
// To know if the callbacks have already been called at least once    fired: function() {     return !!fired;    }   };
return self; };
function Identity( v ) {  return v; } function Thrower( ex ) {  throw ex; }
function adoptValue( value, resolve, reject, noValue ) {  var method;
try {
// Check for promise aspect first to privilege synchronous behavior   if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {    method.call( value ).done( resolve ).fail( reject );
// Other thenables   } else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {    method.call( value, resolve, reject );
// Other non-thenables   } else {
// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:    // * false: [ value ].slice( 0 ) => resolve( value )    // * true: [ value ].slice( 1 ) => resolve()    resolve.apply( undefined, [ value ].slice( noValue ) );   }
// For Promises/A+, convert exceptions into rejections  // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in  // Deferred#then to conditionally suppress rejection.  } catch ( value ) {
// Support: Android 4.0 only   // Strict mode functions invoked without .call/.apply get global-object context   reject.apply( undefined, [ value ] );  } }
jQuery.extend( {
Deferred: function( func ) {   var tuples = [
// action, add listener, callbacks,     // ... .then handlers, argument index, [final state]     [ "notify", "progress", jQuery.Callbacks( "memory" ),      jQuery.Callbacks( "memory" ), 2 ],     [ "resolve", "done", jQuery.Callbacks( "once memory" ),      jQuery.Callbacks( "once memory" ), 0, "resolved" ],     [ "reject", "fail", jQuery.Callbacks( "once memory" ),      jQuery.Callbacks( "once memory" ), 1, "rejected" ]    ],    state = "pending",    promise = {     state: function() {      return state;     },     always: function() {      deferred.done( arguments ).fail( arguments );      return this;     },     "catch": function( fn ) {      return promise.then( null, fn ); },
// Keep pipe for back-compat     pipe: function( /* fnDone, fnFail, fnProgress */ ) {      var fns = arguments;
return jQuery.Deferred( function( newDefer ) {       jQuery.each( tuples, function( i, tuple ) {
// Map tuples (progress, done, fail) to arguments (done, fail, progress)        var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
// deferred.progress(function() { bind to newDefer or newDefer.notify })        // deferred.done(function() { bind to newDefer or newDefer.resolve })        // deferred.fail(function() { bind to newDefer or newDefer.reject })        deferred[ tuple[ 1 ] ]( function() {         var returned = fn && fn.apply( this, arguments );         if ( returned && jQuery.isFunction( returned.promise ) ) {          returned.promise()           .progress( newDefer.notify )           .done( newDefer.resolve )           .fail( newDefer.reject );         } else {          newDefer[ tuple[ 0 ] + "With" ](           this,           fn ? [ returned ] : arguments          );         }        } );       } );       fns = null;      } ).promise();     },     then: function( onFulfilled, onRejected, onProgress ) {      var maxDepth = 0;      function resolve( depth, deferred, handler, special ) {       return function() {        var that = this,         args = arguments,         mightThrow = function() {          var returned, then;
// Support: Promises/A+ section 2.3.3.3.3          // https://promisesaplus.com/#point-59 // Ignore double-resolution attempts          if ( depth < maxDepth ) {           return;          }
returned = handler.apply( that, args );
// Support: Promises/A+ section 2.3.1          // https://promisesaplus.com/#point-48 if ( returned === deferred.promise() ) {           throw new TypeError( "Thenable self-resolution" );          }
// Support: Promises/A+ sections 2.3.3.1, 3.5          // https://promisesaplus.com/#point-54 // https://promisesaplus.com/#point-75 // Retrieve `then` only once          then = returned &&
// Support: Promises/A+ section 2.3.4           // https://promisesaplus.com/#point-64 // Only check objects and functions for thenability           ( typeof returned === "object" ||            typeof returned === "function" ) && returned.then;
// Handle a returned thenable          if ( jQuery.isFunction( then ) ) {
// Special processors (notify) just wait for resolution           if ( special ) {            then.call(             returned,             resolve( maxDepth, deferred, Identity, special ),             resolve( maxDepth, deferred, Thrower, special )            );
// Normal processors (resolve) also hook into progress           } else {
// ...and disregard older resolution values            maxDepth++;
then.call(             returned,             resolve( maxDepth, deferred, Identity, special ),             resolve( maxDepth, deferred, Thrower, special ),             resolve( maxDepth, deferred, Identity,              deferred.notifyWith )            );           }
// Handle all other returned values          } else {
// Only substitute handlers pass on context           // and multiple values (non-spec behavior)           if ( handler !== Identity ) {            that = undefined;            args = [ returned ];           }
// Process the value(s)           // Default process is resolve           ( special || deferred.resolveWith )( that, args );          }         },
// Only normal processors (resolve) catch and reject exceptions         process = special ?          mightThrow :          function() {           try {            mightThrow();           } catch ( e ) {
if ( jQuery.Deferred.exceptionHook ) {             jQuery.Deferred.exceptionHook( e,              process.stackTrace );            }
// Support: Promises/A+ section 2.3.3.3.4.1            // https://promisesaplus.com/#point-61 // Ignore post-resolution exceptions            if ( depth + 1 >= maxDepth ) {
// Only substitute handlers pass on context             // and multiple values (non-spec behavior)             if ( handler !== Thrower ) {              that = undefined;              args = [ e ];             }
deferred.rejectWith( that, args );            }           }          };
// Support: Promises/A+ section 2.3.3.3.1        // https://promisesaplus.com/#point-57 // Re-resolve promises immediately to dodge false rejection from        // subsequent errors        if ( depth ) {         process();        } else {
// Call an optional hook to record the stack, in case of exception         // since it's otherwise lost when execution goes async         if ( jQuery.Deferred.getStackHook ) {          process.stackTrace = jQuery.Deferred.getStackHook();         }         window.setTimeout( process );        }       };      }
return jQuery.Deferred( function( newDefer ) {
// progress_handlers.add( ... )       tuples[ 0 ][ 3 ].add(        resolve(         0,         newDefer,         jQuery.isFunction( onProgress ) ?          onProgress : Identity,         newDefer.notifyWith        )       );
// fulfilled_handlers.add( ... )       tuples[ 1 ][ 3 ].add(        resolve(         0,         newDefer,         jQuery.isFunction( onFulfilled ) ?          onFulfilled :          Identity        )       );
// rejected_handlers.add( ... )       tuples[ 2 ][ 3 ].add(        resolve(         0,         newDefer,         jQuery.isFunction( onRejected ) ?          onRejected :          Thrower        )       );      } ).promise();     },
// Get a promise for this deferred     // If obj is provided, the promise aspect is added to the object     promise: function( obj ) {      return obj != null ? jQuery.extend( obj, promise ) : promise;     }    },    deferred = {};
// Add list-specific methods   jQuery.each( tuples, function( i, tuple ) {    var list = tuple[ 2 ],     stateString = tuple[ 5 ];
// promise.progress = list.add    // promise.done = list.add    // promise.fail = list.add    promise[ tuple[ 1 ] ] = list.add;
// Handle state    if ( stateString ) {     list.add(      function() {
// state = "resolved" (i.e., fulfilled)       // state = "rejected"       state = stateString;      },
// rejected_callbacks.disable      // fulfilled_callbacks.disable      tuples[ 3 - i ][ 2 ].disable,
// progress_callbacks.lock      tuples[ 0 ][ 2 ].lock     );    }
// progress_handlers.fire    // fulfilled_handlers.fire    // rejected_handlers.fire    list.add( tuple[ 3 ].fire );
// deferred.notify = function() { deferred.notifyWith(...) }    // deferred.resolve = function() { deferred.resolveWith(...) }    // deferred.reject = function() { deferred.rejectWith(...) }    deferred[ tuple[ 0 ] ] = function() {     deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );     return this;    };
// deferred.notifyWith = list.fireWith    // deferred.resolveWith = list.fireWith    // deferred.rejectWith = list.fireWith    deferred[ tuple[ 0 ] + "With" ] = list.fireWith;   } );
// Make the deferred a promise   promise.promise( deferred );
// Call given func if any   if ( func ) {    func.call( deferred, deferred );   }
// All done!   return deferred;  },
// Deferred helper  when: function( singleValue ) {   var
// count of uncompleted subordinates    remaining = arguments.length,
// count of unprocessed arguments    i = remaining,
// subordinate fulfillment data    resolveContexts = Array( i ),    resolveValues = slice.call( arguments ),
// the master Deferred    master = jQuery.Deferred(),
// subordinate callback factory    updateFunc = function( i ) {     return function( value ) {      resolveContexts[ i ] = this;      resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;      if ( !( --remaining ) ) {       master.resolveWith( resolveContexts, resolveValues );      }     };    };
// Single- and empty arguments are adopted like Promise.resolve   if ( remaining <= 1 ) {    adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,     !remaining );
// Use .then() to unwrap secondary thenables (cf. gh-3000)    if ( master.state() === "pending" ||     jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
return master.then();    }   }
// Multiple arguments are aggregated like Promise.all array elements   while ( i-- ) {    adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );   }
return master.promise();  } } );
// These usually indicate a programmer mistake during development, // warn about them ASAP rather than swallowing them by default. var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
jQuery.Deferred.exceptionHook = function( error, stack ) {
// Support: IE 8 - 9 only  // Console exists when dev tools are open, which can happen at any time  if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {   window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );  } };
jQuery.readyException = function( error ) {  window.setTimeout( function() {   throw error;  } ); };
// The deferred used on DOM ready var readyList = jQuery.Deferred();
jQuery.fn.ready = function( fn ) {
readyList   .then( fn )
// Wrap jQuery.readyException in a function so that the lookup   // happens at the time of error handling instead of callback   // registration.   .catch( function( error ) {    jQuery.readyException( error );   } );
return this; };
jQuery.extend( {
// Is the DOM ready to be used? Set to true once it occurs.  isReady: false,
// A counter to track how many items to wait for before  // the ready event fires. See #6781  readyWait: 1,
// Handle when the DOM is ready  ready: function( wait ) {
// Abort if there are pending holds or we're already ready   if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {    return;   }
// Remember that the DOM is ready   jQuery.isReady = true;
// If a normal DOM Ready event fired, decrement, and wait if need be   if ( wait !== true && --jQuery.readyWait > 0 ) {    return;   }
// If there are functions bound, to execute   readyList.resolveWith( document, [ jQuery ] );  } } );
jQuery.ready.then = readyList.then;
// The ready event handler and self cleanup method function completed() {  document.removeEventListener( "DOMContentLoaded", completed );  window.removeEventListener( "load", completed );  jQuery.ready(); }
// Catch cases where $(document).ready() is called // after the browser event has already occurred. // Support: IE <=9 - 10 only // Older IE sometimes signals "interactive" too soon if ( document.readyState === "complete" ||  ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
// Handle it asynchronously to allow scripts the opportunity to delay ready  window.setTimeout( jQuery.ready );
} else {
// Use the handy event callback  document.addEventListener( "DOMContentLoaded", completed );
// A fallback to window.onload, that will always work  window.addEventListener( "load", completed ); }
// Multifunctional method to get and set values of a collection // The value/s can optionally be executed if it's a function var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {  var i = 0,   len = elems.length,   bulk = key == null;
// Sets many values  if ( jQuery.type( key ) === "object" ) {   chainable = true;   for ( i in key ) {    access( elems, fn, i, key[ i ], true, emptyGet, raw );   }
// Sets one value  } else if ( value !== undefined ) {   chainable = true;
if ( !jQuery.isFunction( value ) ) {    raw = true;   }
if ( bulk ) {
// Bulk operations run against the entire set    if ( raw ) {     fn.call( elems, value );     fn = null;
// ...except when executing function values    } else {     bulk = fn;     fn = function( elem, key, value ) {      return bulk.call( jQuery( elem ), value );     };    }   }
if ( fn ) {    for ( ; i < len; i++ ) {     fn(      elems[ i ], key, raw ?      value :      value.call( elems[ i ], i, fn( elems[ i ], key ) )     );    }   }  }
if ( chainable ) {   return elems;  }
// Gets  if ( bulk ) {   return fn.call( elems );  }
return len ? fn( elems[ 0 ], key ) : emptyGet; }; var acceptData = function( owner ) {
// Accepts only:  //  - Node  //    - Node.ELEMENT_NODE  //    - Node.DOCUMENT_NODE  //  - Object  //    - Any  return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType ); };
function Data() {  this.expando = jQuery.expando + Data.uid++; }
Data.uid = 1;
Data.prototype = {
cache: function( owner ) {
// Check if the owner object already has a cache   var value = owner[ this.expando ];
// If not, create one   if ( !value ) {    value = {};
// We can accept data for non-element nodes in modern browsers,    // but we should not, see #8335.    // Always return an empty object.    if ( acceptData( owner ) ) {
// If it is a node unlikely to be stringify-ed or looped over     // use plain assignment     if ( owner.nodeType ) {      owner[ this.expando ] = value;
// Otherwise secure it in a non-enumerable property     // configurable must be true to allow the property to be     // deleted when data is removed     } else {      Object.defineProperty( owner, this.expando, {       value: value,       configurable: true      } );     }    }   }
return value;  },  set: function( owner, data, value ) {   var prop,    cache = this.cache( owner );
// Handle: [ owner, key, value ] args   // Always use camelCase key (gh-2257)   if ( typeof data === "string" ) {    cache[ jQuery.camelCase( data ) ] = value;
// Handle: [ owner, { properties } ] args   } else {
// Copy the properties one-by-one to the cache object    for ( prop in data ) {     cache[ jQuery.camelCase( prop ) ] = data[ prop ];    }   }   return cache;  },  get: function( owner, key ) {   return key === undefined ?    this.cache( owner ) :
// Always use camelCase key (gh-2257)    owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];  },  access: function( owner, key, value ) {
// In cases where either:   //   //   1. No key was specified   //   2. A string key was specified, but no value provided   //   // Take the "read" path and allow the get method to determine   // which value to return, respectively either:   //   //   1. The entire cache object   //   2. The data stored at the key   //   if ( key === undefined ||     ( ( key && typeof key === "string" ) && value === undefined ) ) {
return this.get( owner, key );   }
// When the key is not a string, or both a key and value   // are specified, set or extend (existing objects) with either:   //   //   1. An object of properties   //   2. A key and value   //   this.set( owner, key, value );
// Since the "set" path can have two possible entry points   // return the expected data based on which path was taken[*]   return value !== undefined ? value : key;  },  remove: function( owner, key ) {   var i,    cache = owner[ this.expando ];
if ( cache === undefined ) {    return;   }
if ( key !== undefined ) {
// Support array or space separated string of keys    if ( Array.isArray( key ) ) {
// If key is an array of keys...     // We always set camelCase keys, so remove that.     key = key.map( jQuery.camelCase );    } else {     key = jQuery.camelCase( key );
// If a key with the spaces exists, use it.     // Otherwise, create an array by matching non-whitespace     key = key in cache ?      [ key ] :      ( key.match( rnothtmlwhite ) || [] );    }
i = key.length;
while ( i-- ) {     delete cache[ key[ i ] ];    }   }
// Remove the expando if there's no more data   if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
// Support: Chrome <=35 - 45    // Webkit & Blink performance suffers when deleting properties    // from DOM nodes, so set to undefined instead    // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)    if ( owner.nodeType ) {     owner[ this.expando ] = undefined;    } else {     delete owner[ this.expando ];    }   }  },  hasData: function( owner ) {   var cache = owner[ this.expando ]; return cache !== undefined && !jQuery.isEmptyObject( cache );  } }; var dataPriv = new Data();
var dataUser = new Data();
// Implementation Summary // // 1. Enforce API surface and semantic compatibility with 1.9.x branch // 2. Improve the module's maintainability by reducing the storage //  paths to a single mechanism. // 3. Use the same single mechanism to support "private" and "user" data. // 4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData) // 5. Avoid exposing implementation details on user objects (eg. expando properties) // 6. Provide a clear path for implementation upgrade to WeakMap in 2014
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,  rmultiDash = /[A-Z]/g;
function getData( data ) {  if ( data === "true" ) {   return true;  }
if ( data === "false" ) {   return false;  }
if ( data === "null" ) {   return null;  }
// Only convert to a number if it doesn't change the string  if ( data === +data + "" ) {   return +data;  }
if ( rbrace.test( data ) ) {   return JSON.parse( data );  }
return data; }
function dataAttr( elem, key, data ) {  var name;
// If nothing was found internally, try to fetch any  // data from the HTML5 data-* attribute  if ( data === undefined && elem.nodeType === 1 ) {   name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();   data = elem.getAttribute( name );
if ( typeof data === "string" ) {    try {     data = getData( data );    } catch ( e ) {}
// Make sure we set the data so it isn't changed later    dataUser.set( elem, key, data );   } else {    data = undefined;   }  }  return data; }
jQuery.extend( {  hasData: function( elem ) {   return dataUser.hasData( elem ) || dataPriv.hasData( elem );  },
data: function( elem, name, data ) {   return dataUser.access( elem, name, data );  },
removeData: function( elem, name ) {   dataUser.remove( elem, name );  },
// TODO: Now that all calls to _data and _removeData have been replaced  // with direct calls to dataPriv methods, these can be deprecated.  _data: function( elem, name, data ) {   return dataPriv.access( elem, name, data );  },
_removeData: function( elem, name ) {   dataPriv.remove( elem, name );  } } );
jQuery.fn.extend( {  data: function( key, value ) {   var i, name, data,    elem = this[ 0 ],    attrs = elem && elem.attributes;
// Gets all values   if ( key === undefined ) {    if ( this.length ) {     data = dataUser.get( elem );
if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {      i = attrs.length;      while ( i-- ) {
// Support: IE 11 only       // The attrs elements can be null (#14894)       if ( attrs[ i ] ) {        name = attrs[ i ].name;        if ( name.indexOf( "data-" ) === 0 ) {         name = jQuery.camelCase( name.slice( 5 ) );         dataAttr( elem, name, data[ name ] );        }       }      }      dataPriv.set( elem, "hasDataAttrs", true );     }    }
return data;   }
// Sets multiple values   if ( typeof key === "object" ) {    return this.each( function() {     dataUser.set( this, key );    } );   }
return access( this, function( value ) {    var data;
// The calling jQuery object (element matches) is not empty    // (and therefore has an element appears at this[ 0 ]) and the    // `value` parameter was not undefined. An empty jQuery object    // will result in `undefined` for elem = this[ 0 ] which will    // throw an exception if an attempt to read a data cache is made.    if ( elem && value === undefined ) {
// Attempt to get data from the cache     // The key will always be camelCased in Data     data = dataUser.get( elem, key );     if ( data !== undefined ) {      return data;     }
// Attempt to "discover" the data in     // HTML5 custom data-* attrs     data = dataAttr( elem, key );     if ( data !== undefined ) {      return data;     }
// We tried really hard, but the data doesn't exist.     return;    }
// Set the data...    this.each( function() {
// We always store the camelCased key     dataUser.set( this, key, value );    } );   }, null, value, arguments.length > 1, null, true );  },
removeData: function( key ) {   return this.each( function() {    dataUser.remove( this, key );   } );  } } );
jQuery.extend( {  queue: function( elem, type, data ) {   var queue;
if ( elem ) {    type = ( type || "fx" ) + "queue";    queue = dataPriv.get( elem, type );
// Speed up dequeue by getting out quickly if this is just a lookup    if ( data ) {     if ( !queue || Array.isArray( data ) ) {      queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );     } else {      queue.push( data );     }    }    return queue || [];   }  },
dequeue: function( elem, type ) {   type = type || "fx";
var queue = jQuery.queue( elem, type ),    startLength = queue.length,    fn = queue.shift(),    hooks = jQuery._queueHooks( elem, type ),    next = function() {     jQuery.dequeue( elem, type );    };
// If the fx queue is dequeued, always remove the progress sentinel   if ( fn === "inprogress" ) {    fn = queue.shift();    startLength--;   }
if ( fn ) {
// Add a progress sentinel to prevent the fx queue from being    // automatically dequeued    if ( type === "fx" ) {     queue.unshift( "inprogress" );    }
// Clear up the last queue stop function    delete hooks.stop;    fn.call( elem, next, hooks );   }
if ( !startLength && hooks ) {    hooks.empty.fire();   }  },
// Not public - generate a queueHooks object, or return the current one  _queueHooks: function( elem, type ) {   var key = type + "queueHooks";   return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {    empty: jQuery.Callbacks( "once memory" ).add( function() {     dataPriv.remove( elem, [ type + "queue", key ] );    } )   } );  } } );
jQuery.fn.extend( {  queue: function( type, data ) {   var setter = 2;
if ( typeof type !== "string" ) {    data = type;    type = "fx";    setter--;   }
if ( arguments.length < setter ) {    return jQuery.queue( this[ 0 ], type );   }
return data === undefined ?    this :    this.each( function() {     var queue = jQuery.queue( this, type, data );
// Ensure a hooks for this queue     jQuery._queueHooks( this, type );
if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {      jQuery.dequeue( this, type );     }    } );  },  dequeue: function( type ) {   return this.each( function() {    jQuery.dequeue( this, type );   } );  },  clearQueue: function( type ) {   return this.queue( type || "fx", [] );  },
// Get a promise resolved when queues of a certain type  // are emptied (fx is the type by default)  promise: function( type, obj ) {   var tmp,    count = 1,    defer = jQuery.Deferred(),    elements = this,    i = this.length,    resolve = function() {     if ( !( --count ) ) {      defer.resolveWith( elements, [ elements ] );     }    };
if ( typeof type !== "string" ) {    obj = type;    type = undefined;   }   type = type || "fx";
while ( i-- ) {    tmp = dataPriv.get( elements[ i ], type + "queueHooks" );    if ( tmp && tmp.empty ) {     count++;     tmp.empty.add( resolve );    }   }   resolve();   return defer.promise( obj );  } } ); var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
var isHiddenWithinTree = function( elem, el ) {
// isHiddenWithinTree might be called from jQuery#filter function;   // in that case, element will be second argument   elem = el || elem;
// Inline style trumps all   return elem.style.display === "none" ||    elem.style.display === "" &&
// Otherwise, check computed style    // Support: Firefox <=43 - 45    // Disconnected elements can have computed display: none, so first confirm that elem is    // in the document.    jQuery.contains( elem.ownerDocument, elem ) &&
jQuery.css( elem, "display" ) === "none";  };
var swap = function( elem, options, callback, args ) {  var ret, name,   old = {};
// Remember the old values, and insert the new ones  for ( name in options ) {   old[ name ] = elem.style[ name ];   elem.style[ name ] = options[ name ];  }
ret = callback.apply( elem, args || [] );
// Revert the old values  for ( name in options ) {   elem.style[ name ] = old[ name ];  }
return ret; };
function adjustCSS( elem, prop, valueParts, tween ) {  var adjusted,   scale = 1,   maxIterations = 20,   currentValue = tween ?    function() {     return tween.cur();    } :    function() {     return jQuery.css( elem, prop, "" );    },   initial = currentValue(),   unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
// Starting value computation is required for potential unit mismatches   initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) && rcssNum.exec( jQuery.css( elem, prop ) );
if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
// Trust units reported by jQuery.css   unit = unit || initialInUnit[ 3 ];
// Make sure we update the tween properties later on   valueParts = valueParts || [];
// Iteratively approximate from a nonzero starting point   initialInUnit = +initial || 1;
do {
// If previous iteration zeroed out, double until we get *something*.    // Use string for doubling so we don't accidentally see scale as unchanged below    scale = scale || ".5";
// Adjust and apply    initialInUnit = initialInUnit / scale;    jQuery.style( elem, prop, initialInUnit + unit );
// Update scale, tolerating zero or NaN from tween.cur()   // Break the loop if scale is unchanged or perfect, or if we've just had enough.   } while (    scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations   );  }
if ( valueParts ) {   initialInUnit = +initialInUnit || +initial || 0;
// Apply relative offset (+=/-=) if specified   adjusted = valueParts[ 1 ] ?    initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :    +valueParts[ 2 ];   if ( tween ) {    tween.unit = unit;    tween.start = initialInUnit;    tween.end = adjusted;   }  }  return adjusted; }
var defaultDisplayMap = {};
function getDefaultDisplay( elem ) {  var temp,   doc = elem.ownerDocument,   nodeName = elem.nodeName,   display = defaultDisplayMap[ nodeName ];
if ( display ) {   return display;  }
temp = doc.body.appendChild( doc.createElement( nodeName ) );  display = jQuery.css( temp, "display" );
temp.parentNode.removeChild( temp );
if ( display === "none" ) {   display = "block";  }  defaultDisplayMap[ nodeName ] = display;
return display; }
function showHide( elements, show ) {  var display, elem,   values = [],   index = 0,   length = elements.length;
// Determine new display value for elements that need to change  for ( ; index < length; index++ ) {   elem = elements[ index ];   if ( !elem.style ) {    continue;   }
display = elem.style.display;   if ( show ) {
// Since we force visibility upon cascade-hidden elements, an immediate (and slow)    // check is required in this first loop unless we have a nonempty display value (either    // inline or about-to-be-restored)    if ( display === "none" ) {     values[ index ] = dataPriv.get( elem, "display" ) || null;     if ( !values[ index ] ) {      elem.style.display = "";     }    }    if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {     values[ index ] = getDefaultDisplay( elem );    }   } else {    if ( display !== "none" ) {     values[ index ] = "none";
// Remember what we're overwriting     dataPriv.set( elem, "display", display );    }   }  }
// Set the display of the elements in a second loop to avoid constant reflow  for ( index = 0; index < length; index++ ) {   if ( values[ index ] != null ) {    elements[ index ].style.display = values[ index ];   }  }
return elements; }
jQuery.fn.extend( {  show: function() {   return showHide( this, true );  },  hide: function() {   return showHide( this );  },  toggle: function( state ) {   if ( typeof state === "boolean" ) {    return state ? this.show() : this.hide();   }
return this.each( function() {    if ( isHiddenWithinTree( this ) ) {     jQuery( this ).show();    } else {     jQuery( this ).hide();    }   } );  } } ); var rcheckableType = ( /^(?:checkbox|radio)$/i );
var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
var rscriptType = ( /^$|\/(?:java|ecma)script/i );
// We have to close these tags to support XHTML (#13200) var wrapMap = {
// Support: IE <=9 only  option: [ 1, "<select multiple='multiple'>", "</select>" ],
// XHTML parsers do not magically insert elements in the  // same way that tag soup parsers do. So we cannot shorten  // this by omitting <tbody> or other required elements.
thead: [ 1, "
", "
" ],  col: [ 2, "
<colgroup>", "</colgroup>
" ],  tr: [ 2, "
<tbody>", "</tbody>
" ],  td: [ 3, "
<tbody>
", "
</tbody>
" ],
_default: [ 0, "", "" ] };
// Support: IE <=9 only wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead; wrapMap.th = wrapMap.td;
function getAll( context, tag ) {
// Support: IE <=9 - 11 only  // Use typeof to avoid zero-argument method invocation on host objects (#15151)  var ret;
if ( typeof context.getElementsByTagName !== "undefined" ) {   ret = context.getElementsByTagName( tag || "*" );
} else if ( typeof context.querySelectorAll !== "undefined" ) {   ret = context.querySelectorAll( tag || "*" );
} else {   ret = [];  }
if ( tag === undefined || tag && nodeName( context, tag ) ) {   return jQuery.merge( [ context ], ret );  }
return ret; }
// Mark scripts as having already been evaluated function setGlobalEval( elems, refElements ) {  var i = 0,   l = elems.length;
for ( ; i < l; i++ ) {   dataPriv.set(    elems[ i ],    "globalEval",    !refElements || dataPriv.get( refElements[ i ], "globalEval" )   );  } }
var rhtml = /<|&#?\w+;/;
function buildFragment( elems, context, scripts, selection, ignored ) {  var elem, tmp, tag, wrap, contains, j,   fragment = context.createDocumentFragment(),   nodes = [],   i = 0,   l = elems.length;
for ( ; i < l; i++ ) {   elem = elems[ i ];
if ( elem || elem === 0 ) {
// Add nodes directly    if ( jQuery.type( elem ) === "object" ) {
// Support: Android <=4.0 only, PhantomJS 1 only     // push.apply(_, arraylike) throws on ancient WebKit     jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
// Convert non-html into a text node    } else if ( !rhtml.test( elem ) ) {     nodes.push( context.createTextNode( elem ) );
// Convert html into DOM nodes    } else {     tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
// Deserialize a standard representation     tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();     wrap = wrapMap[ tag ] || wrapMap._default;     tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
// Descend through wrappers to the right content     j = wrap[ 0 ];     while ( j-- ) {      tmp = tmp.lastChild;     }
// Support: Android <=4.0 only, PhantomJS 1 only     // push.apply(_, arraylike) throws on ancient WebKit     jQuery.merge( nodes, tmp.childNodes );
// Remember the top-level container     tmp = fragment.firstChild;
// Ensure the created nodes are orphaned (#12392)     tmp.textContent = "";    }   }  }
// Remove wrapper from fragment  fragment.textContent = "";
i = 0;  while ( ( elem = nodes[ i++ ] ) ) {
// Skip elements already in the context collection (trac-4087)   if ( selection && jQuery.inArray( elem, selection ) > -1 ) {    if ( ignored ) {     ignored.push( elem );    }    continue;   }
contains = jQuery.contains( elem.ownerDocument, elem );
// Append to fragment   tmp = getAll( fragment.appendChild( elem ), "script" );
// Preserve script evaluation history   if ( contains ) {    setGlobalEval( tmp );   }
// Capture executables   if ( scripts ) {    j = 0;    while ( ( elem = tmp[ j++ ] ) ) {     if ( rscriptType.test( elem.type || "" ) ) {      scripts.push( elem );     }    }   }  }
return fragment; }
( function() {  var fragment = document.createDocumentFragment(),   div = fragment.appendChild( document.createElement( "div" ) ),   input = document.createElement( "input" );
// Support: Android 4.0 - 4.3 only  // Check state lost if the name is set (#11217)  // Support: Windows Web Apps (WWA)  // `name` and `type` must use .setAttribute for WWA (#14901)  input.setAttribute( "type", "radio" );  input.setAttribute( "checked", "checked" );  input.setAttribute( "name", "t" );
div.appendChild( input );
// Support: Android <=4.1 only  // Older WebKit doesn't clone checked state correctly in fragments  support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
// Support: IE <=11 only  // Make sure textarea (and checkbox) defaultValue is properly cloned  div.innerHTML = "<textarea>x</textarea>";  support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue; } )(); var documentElement = document.documentElement;
var  rkeyEvent = /^key/,  rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,  rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
function returnTrue() {  return true; }
function returnFalse() {  return false; }
// Support: IE <=9 only // See #13393 for more info function safeActiveElement() {  try {   return document.activeElement;  } catch ( err ) { } }
function on( elem, types, selector, data, fn, one ) {  var origFn, type;
// Types can be a map of types/handlers  if ( typeof types === "object" ) {
// ( types-Object, selector, data )   if ( typeof selector !== "string" ) {
// ( types-Object, data )    data = data || selector;    selector = undefined;   }   for ( type in types ) {    on( elem, type, selector, data, types[ type ], one );   }   return elem;  }
if ( data == null && fn == null ) {
// ( types, fn )   fn = selector;   data = selector = undefined;  } else if ( fn == null ) {   if ( typeof selector === "string" ) {
// ( types, selector, fn )    fn = data;    data = undefined;   } else {
// ( types, data, fn )    fn = data;    data = selector;    selector = undefined;   }  }  if ( fn === false ) {   fn = returnFalse;  } else if ( !fn ) {   return elem;  }
if ( one === 1 ) {   origFn = fn;   fn = function( event ) {
// Can use an empty set, since event contains the info    jQuery().off( event );    return origFn.apply( this, arguments );   };
// Use same guid so caller can remove using origFn   fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );  }  return elem.each( function() {   jQuery.event.add( this, types, fn, data, selector );  } ); }
/*
* Helper functions for managing events -- not part of the public interface. * Props to Dean Edwards' addEvent library for many of the ideas. */
jQuery.event = {
global: {},
add: function( elem, types, handler, data, selector ) {
var handleObjIn, eventHandle, tmp,    events, t, handleObj,    special, handlers, type, namespaces, origType,    elemData = dataPriv.get( elem );
// Don't attach events to noData or text/comment nodes (but allow plain objects)   if ( !elemData ) {    return;   }
// Caller can pass in an object of custom data in lieu of the handler   if ( handler.handler ) {    handleObjIn = handler;    handler = handleObjIn.handler;    selector = handleObjIn.selector;   }
// Ensure that invalid selectors throw exceptions at attach time   // Evaluate against documentElement in case elem is a non-element node (e.g., document)   if ( selector ) {    jQuery.find.matchesSelector( documentElement, selector );   }
// Make sure that the handler has a unique ID, used to find/remove it later   if ( !handler.guid ) {    handler.guid = jQuery.guid++;   }
// Init the element's event structure and main handler, if this is the first   if ( !( events = elemData.events ) ) {    events = elemData.events = {};   }   if ( !( eventHandle = elemData.handle ) ) {    eventHandle = elemData.handle = function( e ) {
// Discard the second event of a jQuery.event.trigger() and     // when an event is called after a page has unloaded     return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?      jQuery.event.dispatch.apply( elem, arguments ) : undefined;    };   }
// Handle multiple events separated by a space   types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];   t = types.length;   while ( t-- ) {    tmp = rtypenamespace.exec( types[ t ] ) || [];    type = origType = tmp[ 1 ];    namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
// There *must* be a type, no attaching namespace-only handlers    if ( !type ) {     continue;    }
// If event changes its type, use the special event handlers for the changed type    special = jQuery.event.special[ type ] || {};
// If selector defined, determine special event api type, otherwise given type    type = ( selector ? special.delegateType : special.bindType ) || type;
// Update special based on newly reset type    special = jQuery.event.special[ type ] || {};
// handleObj is passed to all event handlers    handleObj = jQuery.extend( {     type: type,     origType: origType,     data: data,     handler: handler,     guid: handler.guid,     selector: selector,     needsContext: selector && jQuery.expr.match.needsContext.test( selector ),     namespace: namespaces.join( "." )    }, handleObjIn );
// Init the event handler queue if we're the first    if ( !( handlers = events[ type ] ) ) {     handlers = events[ type ] = [];     handlers.delegateCount = 0;
// Only use addEventListener if the special events handler returns false     if ( !special.setup ||      special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
if ( elem.addEventListener ) {       elem.addEventListener( type, eventHandle );      }     }    }
if ( special.add ) {     special.add.call( elem, handleObj );
if ( !handleObj.handler.guid ) {      handleObj.handler.guid = handler.guid;     }    }
// Add to the element's handler list, delegates in front    if ( selector ) {     handlers.splice( handlers.delegateCount++, 0, handleObj );    } else {     handlers.push( handleObj );    }
// Keep track of which events have ever been used, for event optimization    jQuery.event.global[ type ] = true;   }
},
// Detach an event or set of events from an element  remove: function( elem, types, handler, selector, mappedTypes ) {
var j, origCount, tmp,    events, t, handleObj,    special, handlers, type, namespaces, origType,    elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
if ( !elemData || !( events = elemData.events ) ) {    return;   }
// Once for each type.namespace in types; type may be omitted   types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];   t = types.length;   while ( t-- ) {    tmp = rtypenamespace.exec( types[ t ] ) || [];    type = origType = tmp[ 1 ];    namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
// Unbind all events (on this namespace, if provided) for the element    if ( !type ) {     for ( type in events ) {      jQuery.event.remove( elem, type + types[ t ], handler, selector, true );     }     continue;    }
special = jQuery.event.special[ type ] || {};    type = ( selector ? special.delegateType : special.bindType ) || type;    handlers = events[ type ] || [];    tmp = tmp[ 2 ] && new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
// Remove matching events    origCount = j = handlers.length;    while ( j-- ) {     handleObj = handlers[ j ];
if ( ( mappedTypes || origType === handleObj.origType ) && ( !handler || handler.guid === handleObj.guid ) && ( !tmp || tmp.test( handleObj.namespace ) ) && ( !selector || selector === handleObj.selector ||       selector === "**" && handleObj.selector ) ) {      handlers.splice( j, 1 );
if ( handleObj.selector ) {       handlers.delegateCount--;      }      if ( special.remove ) {       special.remove.call( elem, handleObj );      }     }    }
// Remove generic event handler if we removed something and no more handlers exist    // (avoids potential for endless recursion during removal of special event handlers)    if ( origCount && !handlers.length ) {     if ( !special.teardown ||      special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
jQuery.removeEvent( elem, type, elemData.handle );     }
delete events[ type ];    }   }
// Remove data and the expando if it's no longer used if ( jQuery.isEmptyObject( events ) ) {    dataPriv.remove( elem, "handle events" );   }  },
dispatch: function( nativeEvent ) {
// Make a writable jQuery.Event from the native event object   var event = jQuery.event.fix( nativeEvent );
var i, j, ret, matched, handleObj, handlerQueue,    args = new Array( arguments.length ),    handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],    special = jQuery.event.special[ event.type ] || {};
// Use the fix-ed jQuery.Event rather than the (read-only) native event   args[ 0 ] = event;
for ( i = 1; i < arguments.length; i++ ) {    args[ i ] = arguments[ i ];   }
event.delegateTarget = this;
// Call the preDispatch hook for the mapped type, and let it bail if desired   if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {    return;   }
// Determine handlers   handlerQueue = jQuery.event.handlers.call( this, event, handlers );
// Run delegates first; they may want to stop propagation beneath us   i = 0;   while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {    event.currentTarget = matched.elem;
j = 0;    while ( ( handleObj = matched.handlers[ j++ ] ) && !event.isImmediatePropagationStopped() ) {
// Triggered event must either 1) have no namespace, or 2) have namespace(s)     // a subset or equal to those in the bound event (both can have no namespace).     if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
event.handleObj = handleObj;      event.data = handleObj.data;
ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||       handleObj.handler ).apply( matched.elem, args );
if ( ret !== undefined ) {       if ( ( event.result = ret ) === false ) {        event.preventDefault();        event.stopPropagation();       }      }     }    }   }
// Call the postDispatch hook for the mapped type   if ( special.postDispatch ) {    special.postDispatch.call( this, event );   }
return event.result;  },
handlers: function( event, handlers ) {   var i, handleObj, sel, matchedHandlers, matchedSelectors,    handlerQueue = [],    delegateCount = handlers.delegateCount,    cur = event.target;
// Find delegate handlers   if ( delegateCount &&
// Support: IE <=9    // Black-hole SVG <use> instance trees (trac-13180)    cur.nodeType &&
// Support: Firefox <=42    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click // Support: IE 11 only    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)    !( event.type === "click" && event.button >= 1 ) ) {
for ( ; cur !== this; cur = cur.parentNode || this ) {
// Don't check non-elements (#13208)     // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)     if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {      matchedHandlers = [];      matchedSelectors = {};      for ( i = 0; i < delegateCount; i++ ) {       handleObj = handlers[ i ];
// Don't conflict with Object.prototype properties (#13203)       sel = handleObj.selector + " ";
if ( matchedSelectors[ sel ] === undefined ) {        matchedSelectors[ sel ] = handleObj.needsContext ?         jQuery( sel, this ).index( cur ) > -1 :         jQuery.find( sel, this, null, [ cur ] ).length;       }       if ( matchedSelectors[ sel ] ) {        matchedHandlers.push( handleObj );       }      }      if ( matchedHandlers.length ) {       handlerQueue.push( { elem: cur, handlers: matchedHandlers } );      }     }    }   }
// Add the remaining (directly-bound) handlers   cur = this;   if ( delegateCount < handlers.length ) {    handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );   }
return handlerQueue;  },
addProp: function( name, hook ) {   Object.defineProperty( jQuery.Event.prototype, name, {    enumerable: true,    configurable: true,
get: jQuery.isFunction( hook ) ?     function() {      if ( this.originalEvent ) {        return hook( this.originalEvent );      }     } :     function() {      if ( this.originalEvent ) {        return this.originalEvent[ name ];      }     },
set: function( value ) {     Object.defineProperty( this, name, {      enumerable: true,      configurable: true,      writable: true,      value: value     } );    }   } );  },
fix: function( originalEvent ) {   return originalEvent[ jQuery.expando ] ?    originalEvent :    new jQuery.Event( originalEvent );  },
special: {   load: {
// Prevent triggered image.load events from bubbling to window.load    noBubble: true   },   focus: {
// Fire native event if possible so blur/focus sequence is correct    trigger: function() {     if ( this !== safeActiveElement() && this.focus ) {      this.focus();      return false;     }    },    delegateType: "focusin"   },   blur: {    trigger: function() {     if ( this === safeActiveElement() && this.blur ) {      this.blur();      return false;     }    },    delegateType: "focusout"   },   click: {
// For checkbox, fire native event so checked state will be right    trigger: function() {     if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {      this.click();      return false;     }    },
// For cross-browser consistency, don't fire native .click() on links    _default: function( event ) {     return nodeName( event.target, "a" );    }   },
beforeunload: {    postDispatch: function( event ) {
// Support: Firefox 20+     // Firefox doesn't alert if the returnValue field is not set.     if ( event.result !== undefined && event.originalEvent ) {      event.originalEvent.returnValue = event.result;     }    }   }  } };
jQuery.removeEvent = function( elem, type, handle ) {
// This "if" is needed for plain objects  if ( elem.removeEventListener ) {   elem.removeEventListener( type, handle );  } };
jQuery.Event = function( src, props ) {
// Allow instantiation without the 'new' keyword  if ( !( this instanceof jQuery.Event ) ) {   return new jQuery.Event( src, props );  }
// Event object  if ( src && src.type ) {   this.originalEvent = src;   this.type = src.type;
// Events bubbling up the document may have been marked as prevented   // by a handler lower down the tree; reflect the correct value.   this.isDefaultPrevented = src.defaultPrevented ||     src.defaultPrevented === undefined &&
// Support: Android <=2.3 only     src.returnValue === false ?    returnTrue :    returnFalse;
// Create target properties   // Support: Safari <=6 - 7 only   // Target should not be a text node (#504, #13143)   this.target = ( src.target && src.target.nodeType === 3 ) ?    src.target.parentNode :    src.target;
this.currentTarget = src.currentTarget;   this.relatedTarget = src.relatedTarget;
// Event type  } else {   this.type = src;  }
// Put explicitly provided properties onto the event object  if ( props ) {   jQuery.extend( this, props );  }
// Create a timestamp if incoming event doesn't have one  this.timeStamp = src && src.timeStamp || jQuery.now();
// Mark it as fixed  this[ jQuery.expando ] = true; };
// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html jQuery.Event.prototype = {  constructor: jQuery.Event,  isDefaultPrevented: returnFalse,  isPropagationStopped: returnFalse,  isImmediatePropagationStopped: returnFalse,  isSimulated: false,
preventDefault: function() {   var e = this.originalEvent;
this.isDefaultPrevented = returnTrue;
if ( e && !this.isSimulated ) {    e.preventDefault();   }  },  stopPropagation: function() {   var e = this.originalEvent;
this.isPropagationStopped = returnTrue;
if ( e && !this.isSimulated ) {    e.stopPropagation();   }  },  stopImmediatePropagation: function() {   var e = this.originalEvent;
this.isImmediatePropagationStopped = returnTrue;
if ( e && !this.isSimulated ) {    e.stopImmediatePropagation();   }
this.stopPropagation();  } };
// Includes all common event props including KeyEvent and MouseEvent specific props jQuery.each( {  altKey: true,  bubbles: true,  cancelable: true,  changedTouches: true,  ctrlKey: true,  detail: true,  eventPhase: true,  metaKey: true,  pageX: true,  pageY: true,  shiftKey: true,  view: true,  "char": true,  charCode: true,  key: true,  keyCode: true,  button: true,  buttons: true,  clientX: true,  clientY: true,  offsetX: true,  offsetY: true,  pointerId: true,  pointerType: true,  screenX: true,  screenY: true,  targetTouches: true,  toElement: true,  touches: true,
which: function( event ) {   var button = event.button;
// Add which for key events   if ( event.which == null && rkeyEvent.test( event.type ) ) {    return event.charCode != null ? event.charCode : event.keyCode;   }
// Add which for click: 1 === left; 2 === middle; 3 === right   if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {    if ( button & 1 ) {     return 1;    }
if ( button & 2 ) {     return 3;    }
if ( button & 4 ) {     return 2;    }
return 0;   }
return event.which;  } }, jQuery.event.addProp );
// Create mouseenter/leave events using mouseover/out and event-time checks // so that event delegation works in jQuery. // Do the same for pointerenter/pointerleave and pointerover/pointerout // // Support: Safari 7 only // Safari sends mouseenter too often; see: // https://bugs.chromium.org/p/chromium/issues/detail?id=470258 // for the description of the bug (it existed in older Chrome versions as well). jQuery.each( {  mouseenter: "mouseover",  mouseleave: "mouseout",  pointerenter: "pointerover",  pointerleave: "pointerout" }, function( orig, fix ) {  jQuery.event.special[ orig ] = {   delegateType: fix,   bindType: fix,
handle: function( event ) {    var ret,     target = this,     related = event.relatedTarget,     handleObj = event.handleObj;
// For mouseenter/leave call the handler if related is outside the target.    // NB: No relatedTarget if the mouse left/entered the browser window    if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {     event.type = handleObj.origType;     ret = handleObj.handler.apply( this, arguments );     event.type = fix;    }    return ret;   }  }; } );
jQuery.fn.extend( {
on: function( types, selector, data, fn ) {   return on( this, types, selector, data, fn );  },  one: function( types, selector, data, fn ) {   return on( this, types, selector, data, fn, 1 );  },  off: function( types, selector, fn ) {   var handleObj, type;   if ( types && types.preventDefault && types.handleObj ) {
// ( event )  dispatched jQuery.Event    handleObj = types.handleObj;    jQuery( types.delegateTarget ).off(     handleObj.namespace ?      handleObj.origType + "." + handleObj.namespace :      handleObj.origType,     handleObj.selector,     handleObj.handler    );    return this;   }   if ( typeof types === "object" ) {
// ( types-object [, selector] )    for ( type in types ) {     this.off( type, selector, types[ type ] );    }    return this;   }   if ( selector === false || typeof selector === "function" ) {
// ( types [, fn] )    fn = selector;    selector = undefined;   }   if ( fn === false ) {    fn = returnFalse;   }   return this.each( function() {    jQuery.event.remove( this, types, fn, selector );   } );  } } );
var
/* eslint-disable max-len */
// See https://github.com/eslint/eslint/issues/3229 rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
/* eslint-enable */
// Support: IE <=10 - 11, Edge 12 - 13  // In IE/Edge using regex groups here causes severe slowdowns.  // See https://connect.microsoft.com/IE/feedback/details/1736512/ rnoInnerhtml = /<script|<style|<link/i,
// checked="checked" or checked  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,  rscriptTypeMasked = /^true\/(.*)/,  rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
// Prefer a tbody over its parent table for containing new rows function manipulationTarget( elem, content ) {  if ( nodeName( elem, "table" ) && nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
return jQuery( ">tbody", elem )[ 0 ] || elem;  }
return elem; }
// Replace/restore the type attribute of script elements for safe DOM manipulation function disableScript( elem ) {  elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;  return elem; } function restoreScript( elem ) {  var match = rscriptTypeMasked.exec( elem.type );
if ( match ) {   elem.type = match[ 1 ];  } else {   elem.removeAttribute( "type" );  }
return elem; }
function cloneCopyEvent( src, dest ) {  var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
if ( dest.nodeType !== 1 ) {   return;  }
// 1. Copy private data: events, handlers, etc.  if ( dataPriv.hasData( src ) ) {   pdataOld = dataPriv.access( src );   pdataCur = dataPriv.set( dest, pdataOld );   events = pdataOld.events;
if ( events ) {    delete pdataCur.handle;    pdataCur.events = {};
for ( type in events ) {     for ( i = 0, l = events[ type ].length; i < l; i++ ) {      jQuery.event.add( dest, type, events[ type ][ i ] );     }    }   }  }
// 2. Copy user data  if ( dataUser.hasData( src ) ) {   udataOld = dataUser.access( src );   udataCur = jQuery.extend( {}, udataOld );
dataUser.set( dest, udataCur );  } }
// Fix IE bugs, see support tests function fixInput( src, dest ) {  var nodeName = dest.nodeName.toLowerCase();
// Fails to persist the checked state of a cloned checkbox or radio button.  if ( nodeName === "input" && rcheckableType.test( src.type ) ) {   dest.checked = src.checked;
// Fails to return the selected option to the default selected state when cloning options  } else if ( nodeName === "input" || nodeName === "textarea" ) {   dest.defaultValue = src.defaultValue;  } }
function domManip( collection, args, callback, ignored ) {
// Flatten any nested arrays  args = concat.apply( [], args );
var fragment, first, scripts, hasScripts, node, doc,   i = 0,   l = collection.length,   iNoClone = l - 1,   value = args[ 0 ],   isFunction = jQuery.isFunction( value );
// We can't cloneNode fragments that contain checked, in WebKit  if ( isFunction ||    ( l > 1 && typeof value === "string" && !support.checkClone && rchecked.test( value ) ) ) {   return collection.each( function( index ) {    var self = collection.eq( index );    if ( isFunction ) {     args[ 0 ] = value.call( this, index, self.html() );    }    domManip( self, args, callback, ignored );   } );  }
if ( l ) {   fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );   first = fragment.firstChild;
if ( fragment.childNodes.length === 1 ) {    fragment = first;   }
// Require either new content or an interest in ignored elements to invoke the callback   if ( first || ignored ) {    scripts = jQuery.map( getAll( fragment, "script" ), disableScript );    hasScripts = scripts.length;
// Use the original fragment for the last item    // instead of the first because it can end up    // being emptied incorrectly in certain situations (#8070).    for ( ; i < l; i++ ) {     node = fragment;
if ( i !== iNoClone ) {      node = jQuery.clone( node, true, true );
// Keep references to cloned scripts for later restoration      if ( hasScripts ) {
// Support: Android <=4.0 only, PhantomJS 1 only       // push.apply(_, arraylike) throws on ancient WebKit       jQuery.merge( scripts, getAll( node, "script" ) );      }     }
callback.call( collection[ i ], node, i );    }
if ( hasScripts ) {     doc = scripts[ scripts.length - 1 ].ownerDocument;
// Reenable scripts     jQuery.map( scripts, restoreScript );
// Evaluate executable scripts on first document insertion     for ( i = 0; i < hasScripts; i++ ) {      node = scripts[ i ];      if ( rscriptType.test( node.type || "" ) && !dataPriv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {
if ( node.src ) {
// Optional AJAX dependency, but won't run scripts if not present        if ( jQuery._evalUrl ) {         jQuery._evalUrl( node.src );        }       } else {        DOMEval( node.textContent.replace( rcleanScript, "" ), doc );       }      }     }    }   }  }
return collection; }
function remove( elem, selector, keepData ) {  var node,   nodes = selector ? jQuery.filter( selector, elem ) : elem,   i = 0;
for ( ; ( node = nodes[ i ] ) != null; i++ ) {   if ( !keepData && node.nodeType === 1 ) {    jQuery.cleanData( getAll( node ) );   }
if ( node.parentNode ) {    if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {     setGlobalEval( getAll( node, "script" ) );    }    node.parentNode.removeChild( node );   }  }
return elem; }
jQuery.extend( {  htmlPrefilter: function( html ) {   return html.replace( rxhtmlTag, "<$1></$2>" );  },
clone: function( elem, dataAndEvents, deepDataAndEvents ) {   var i, l, srcElements, destElements,    clone = elem.cloneNode( true ),    inPage = jQuery.contains( elem.ownerDocument, elem );
// Fix IE cloning issues   if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {
// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2 destElements = getAll( clone );    srcElements = getAll( elem );
for ( i = 0, l = srcElements.length; i < l; i++ ) {     fixInput( srcElements[ i ], destElements[ i ] );    }   }
// Copy the events from the original to the clone   if ( dataAndEvents ) {    if ( deepDataAndEvents ) {     srcElements = srcElements || getAll( elem );     destElements = destElements || getAll( clone );
for ( i = 0, l = srcElements.length; i < l; i++ ) {      cloneCopyEvent( srcElements[ i ], destElements[ i ] );     }    } else {     cloneCopyEvent( elem, clone );    }   }
// Preserve script evaluation history   destElements = getAll( clone, "script" );   if ( destElements.length > 0 ) {    setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );   }
// Return the cloned set   return clone;  },
cleanData: function( elems ) {   var data, elem, type,    special = jQuery.event.special,    i = 0;
for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {    if ( acceptData( elem ) ) {     if ( ( data = elem[ dataPriv.expando ] ) ) {      if ( data.events ) {       for ( type in data.events ) {        if ( special[ type ] ) {         jQuery.event.remove( elem, type );
// This is a shortcut to avoid jQuery.event.remove's overhead        } else {         jQuery.removeEvent( elem, type, data.handle );        }       }      }
// Support: Chrome <=35 - 45+      // Assign undefined instead of using delete, see Data#remove      elem[ dataPriv.expando ] = undefined;     }     if ( elem[ dataUser.expando ] ) {
// Support: Chrome <=35 - 45+      // Assign undefined instead of using delete, see Data#remove      elem[ dataUser.expando ] = undefined;     }    }   }  } } );
jQuery.fn.extend( {  detach: function( selector ) {   return remove( this, selector, true );  },
remove: function( selector ) {   return remove( this, selector );  },
text: function( value ) {   return access( this, function( value ) {    return value === undefined ?     jQuery.text( this ) :     this.empty().each( function() {      if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {       this.textContent = value;      }     } );   }, null, value, arguments.length );  },
append: function() {   return domManip( this, arguments, function( elem ) {    if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {     var target = manipulationTarget( this, elem );     target.appendChild( elem );    }   } );  },
prepend: function() {   return domManip( this, arguments, function( elem ) {    if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {     var target = manipulationTarget( this, elem );     target.insertBefore( elem, target.firstChild );    }   } );  },
before: function() {   return domManip( this, arguments, function( elem ) {    if ( this.parentNode ) {     this.parentNode.insertBefore( elem, this );    }   } );  },
after: function() {   return domManip( this, arguments, function( elem ) {    if ( this.parentNode ) {     this.parentNode.insertBefore( elem, this.nextSibling );    }   } );  },
empty: function() {   var elem,    i = 0;
for ( ; ( elem = this[ i ] ) != null; i++ ) {    if ( elem.nodeType === 1 ) {
// Prevent memory leaks     jQuery.cleanData( getAll( elem, false ) );
// Remove any remaining nodes     elem.textContent = "";    }   }
return this;  },
clone: function( dataAndEvents, deepDataAndEvents ) {   dataAndEvents = dataAndEvents == null ? false : dataAndEvents;   deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
return this.map( function() {    return jQuery.clone( this, dataAndEvents, deepDataAndEvents );   } );  },
html: function( value ) {   return access( this, function( value ) {    var elem = this[ 0 ] || {},     i = 0,     l = this.length;
if ( value === undefined && elem.nodeType === 1 ) {     return elem.innerHTML;    }
// See if we can take a shortcut and just use innerHTML    if ( typeof value === "string" && !rnoInnerhtml.test( value ) && !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
value = jQuery.htmlPrefilter( value );
try {      for ( ; i < l; i++ ) {       elem = this[ i ] || {};
// Remove element nodes and prevent memory leaks       if ( elem.nodeType === 1 ) {        jQuery.cleanData( getAll( elem, false ) );        elem.innerHTML = value;       }      }
elem = 0;
// If using innerHTML throws an exception, use the fallback method     } catch ( e ) {}    }
if ( elem ) {     this.empty().append( value );    }   }, null, value, arguments.length );  },
replaceWith: function() {   var ignored = [];
// Make the changes, replacing each non-ignored context element with the new content   return domManip( this, arguments, function( elem ) {    var parent = this.parentNode;
if ( jQuery.inArray( this, ignored ) < 0 ) {     jQuery.cleanData( getAll( this ) );     if ( parent ) {      parent.replaceChild( elem, this );     }    }
// Force callback invocation   }, ignored );  } } );
jQuery.each( {  appendTo: "append",  prependTo: "prepend",  insertBefore: "before",  insertAfter: "after",  replaceAll: "replaceWith" }, function( name, original ) {  jQuery.fn[ name ] = function( selector ) {   var elems,    ret = [],    insert = jQuery( selector ),    last = insert.length - 1,    i = 0;
for ( ; i <= last; i++ ) {    elems = i === last ? this : this.clone( true );    jQuery( insert[ i ] )[ original ]( elems );
// Support: Android <=4.0 only, PhantomJS 1 only    // .get() because push.apply(_, arraylike) throws on ancient WebKit    push.apply( ret, elems.get() );   }
return this.pushStack( ret );  }; } ); var rmargin = ( /^margin/ );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
var getStyles = function( elem ) {
// Support: IE <=11 only, Firefox <=30 (#15098, #14150)   // IE throws on elements created in popups   // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"   var view = elem.ownerDocument.defaultView;
if ( !view || !view.opener ) {    view = window;   }
return view.getComputedStyle( elem );  };
( function() {
// Executing both pixelPosition & boxSizingReliable tests require only one layout  // so they're executed at the same time to save the second computation.  function computeStyleTests() {
// This is a singleton, we need to execute it only once   if ( !div ) {    return; }
div.style.cssText =    "box-sizing:border-box;" +    "position:relative;display:block;" +    "margin:auto;border:1px;padding:1px;" +    "top:1%;width:50%";   div.innerHTML = "";   documentElement.appendChild( container );
var divStyle = window.getComputedStyle( div );   pixelPositionVal = divStyle.top !== "1%";
// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44   reliableMarginLeftVal = divStyle.marginLeft === "2px";   boxSizingReliableVal = divStyle.width === "4px";
// Support: Android 4.0 - 4.3 only   // Some styles come back with percentage values, even though they shouldn't   div.style.marginRight = "50%";   pixelMarginRightVal = divStyle.marginRight === "4px";
documentElement.removeChild( container );
// Nullify the div so it wouldn't be stored in the memory and   // it will also be a sign that checks already performed   div = null;  }
var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,   container = document.createElement( "div" ),   div = document.createElement( "div" );
// Finish early in limited (non-browser) environments  if ( !div.style ) {   return;  }
// Support: IE <=9 - 11 only  // Style of cloned element affects source element cloned (#8908)  div.style.backgroundClip = "content-box";  div.cloneNode( true ).style.backgroundClip = "";  support.clearCloneStyle = div.style.backgroundClip === "content-box";
container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +   "padding:0;margin-top:1px;position:absolute";  container.appendChild( div );
jQuery.extend( support, {   pixelPosition: function() {    computeStyleTests();    return pixelPositionVal;   },   boxSizingReliable: function() {    computeStyleTests();    return boxSizingReliableVal;   },   pixelMarginRight: function() {    computeStyleTests();    return pixelMarginRightVal;   },   reliableMarginLeft: function() {    computeStyleTests();    return reliableMarginLeftVal;   }  } ); } )();
function curCSS( elem, name, computed ) {  var width, minWidth, maxWidth, ret,
// Support: Firefox 51+   // Retrieving style before computed somehow   // fixes an issue with getting wrong values   // on detached elements   style = elem.style;
computed = computed || getStyles( elem );
// getPropertyValue is needed for:  //   .css('filter') (IE 9 only, #12537)  //   .css('--customProperty) (#3144)  if ( computed ) {   ret = computed.getPropertyValue( name ) || computed[ name ];
if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {    ret = jQuery.style( elem, name );   }
// A tribute to the "awesome hack by Dean Edwards"   // Android Browser returns percentage for some values,   // but width seems to be reliably pixels.   // This is against the CSSOM draft spec:   // https://drafts.csswg.org/cssom/#resolved-values if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
// Remember the original values    width = style.width;    minWidth = style.minWidth;    maxWidth = style.maxWidth;
// Put in the new values to get a computed value out    style.minWidth = style.maxWidth = style.width = ret;    ret = computed.width;
// Revert the changed values    style.width = width;    style.minWidth = minWidth;    style.maxWidth = maxWidth;   }  }
return ret !== undefined ?
// Support: IE <=9 - 11 only   // IE returns zIndex value as an integer.   ret + "" :   ret; }
function addGetHookIf( conditionFn, hookFn ) {
// Define the hook, we'll check on the first run if it's really needed.  return {   get: function() {    if ( conditionFn() ) {
// Hook not needed (or it's not possible to use it due     // to missing dependency), remove it.     delete this.get;     return;    }
// Hook needed; redefine it so that the support test is not executed again.    return ( this.get = hookFn ).apply( this, arguments );   }  }; }
var
// Swappable if display is none or starts with table  // except "table", "table-cell", or "table-caption"  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display rdisplayswap = /^(none|table(?!-c[ea]).+)/,  rcustomProp = /^--/,  cssShow = { position: "absolute", visibility: "hidden", display: "block" },  cssNormalTransform = {   letterSpacing: "0",   fontWeight: "400"  },
cssPrefixes = [ "Webkit", "Moz", "ms" ],  emptyStyle = document.createElement( "div" ).style;
// Return a css property mapped to a potentially vendor prefixed property function vendorPropName( name ) {
// Shortcut for names that are not vendor prefixed  if ( name in emptyStyle ) {   return name;  }
// Check for vendor prefixed names  var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),   i = cssPrefixes.length;
while ( i-- ) {   name = cssPrefixes[ i ] + capName;   if ( name in emptyStyle ) {    return name;   }  } }
// Return a property mapped along what jQuery.cssProps suggests or to // a vendor prefixed property. function finalPropName( name ) {  var ret = jQuery.cssProps[ name ];  if ( !ret ) {   ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;  }  return ret; }
function setPositiveNumber( elem, value, subtract ) {
// Any relative (+/-) values have already been  // normalized at this point  var matches = rcssNum.exec( value );  return matches ?
// Guard against undefined "subtract", e.g., when used as in cssHooks   Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :   value; }
function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {  var i,   val = 0;
// If we already have the right measurement, avoid augmentation  if ( extra === ( isBorderBox ? "border" : "content" ) ) {   i = 4;
// Otherwise initialize for horizontal or vertical properties  } else {   i = name === "width" ? 1 : 0;  }
for ( ; i < 4; i += 2 ) {
// Both box models exclude margin, so add it if we want it   if ( extra === "margin" ) {    val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );   }
if ( isBorderBox ) {
// border-box includes padding, so remove it if we want content    if ( extra === "content" ) {     val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );    }
// At this point, extra isn't border nor margin, so remove border    if ( extra !== "margin" ) {     val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );    }   } else {
// At this point, extra isn't content, so add padding    val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
// At this point, extra isn't content nor padding, so add border    if ( extra !== "padding" ) {     val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );    }   }  }
return val; }
function getWidthOrHeight( elem, name, extra ) {
// Start with computed style  var valueIsBorderBox,   styles = getStyles( elem ),   val = curCSS( elem, name, styles ),   isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
// Computed unit is not pixels. Stop here and return.  if ( rnumnonpx.test( val ) ) {   return val;  }
// Check for style in case a browser which returns unreliable values  // for getComputedStyle silently falls back to the reliable elem.style  valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );
// Fall back to offsetWidth/Height when value is "auto"  // This happens for inline elements with no explicit setting (gh-3571)  if ( val === "auto" ) {   val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];  }
// Normalize "", auto, and prepare for extra  val = parseFloat( val ) || 0;
// Use the active box-sizing model to add/subtract irrelevant styles  return ( val +   augmentWidthOrHeight(    elem,    name,    extra || ( isBorderBox ? "border" : "content" ),    valueIsBorderBox,    styles   )  ) + "px"; }
jQuery.extend( {
// Add in style property hooks for overriding the default  // behavior of getting and setting a style property  cssHooks: {   opacity: {    get: function( elem, computed ) {     if ( computed ) {
// We should always get a number back from opacity      var ret = curCSS( elem, "opacity" );      return ret === "" ? "1" : ret;     }    }   }  },
// Don't automatically add "px" to these possibly-unitless properties  cssNumber: {   "animationIterationCount": true,   "columnCount": true,   "fillOpacity": true,   "flexGrow": true,   "flexShrink": true,   "fontWeight": true,   "lineHeight": true,   "opacity": true,   "order": true,   "orphans": true,   "widows": true,   "zIndex": true,   "zoom": true  },
// Add in properties whose names you wish to fix before  // setting or getting the value  cssProps: {   "float": "cssFloat"  },
// Get and set the style property on a DOM Node  style: function( elem, name, value, extra ) {
// Don't set styles on text and comment nodes   if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {    return;   }
// Make sure that we're working with the right name   var ret, type, hooks,    origName = jQuery.camelCase( name ),    isCustomProp = rcustomProp.test( name ),    style = elem.style;
// Make sure that we're working with the right name. We don't   // want to query the value if it is a CSS custom property   // since they are user-defined.   if ( !isCustomProp ) {    name = finalPropName( origName );   }
// Gets hook for the prefixed version, then unprefixed version   hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
// Check if we're setting a value   if ( value !== undefined ) {    type = typeof value;
// Convert "+=" or "-=" to relative numbers (#7345)    if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {     value = adjustCSS( elem, name, ret );
// Fixes bug #9237     type = "number";    }
// Make sure that null and NaN values aren't set (#7116)    if ( value == null || value !== value ) {     return;    }
// If a number was passed in, add the unit (except for certain CSS properties)    if ( type === "number" ) {     value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );    }
// background-* props affect original clone's values    if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {     style[ name ] = "inherit";    }
// If a hook was provided, use that value, otherwise just set the specified value    if ( !hooks || !( "set" in hooks ) ||     ( value = hooks.set( elem, value, extra ) ) !== undefined ) {
if ( isCustomProp ) {      style.setProperty( name, value );     } else {      style[ name ] = value;     }    }
} else {
// If a hook was provided get the non-computed value from there    if ( hooks && "get" in hooks && ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
return ret;    }
// Otherwise just get the value from the style object    return style[ name ];   }  },
css: function( elem, name, extra, styles ) {   var val, num, hooks,    origName = jQuery.camelCase( name ),    isCustomProp = rcustomProp.test( name );
// Make sure that we're working with the right name. We don't   // want to modify the value if it is a CSS custom property   // since they are user-defined.   if ( !isCustomProp ) {    name = finalPropName( origName );   }
// Try prefixed name followed by the unprefixed name   hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
// If a hook was provided get the computed value from there   if ( hooks && "get" in hooks ) {    val = hooks.get( elem, true, extra );   }
// Otherwise, if a way to get the computed value exists, use that   if ( val === undefined ) {    val = curCSS( elem, name, styles );   }
// Convert "normal" to computed value   if ( val === "normal" && name in cssNormalTransform ) {    val = cssNormalTransform[ name ];   }
// Make numeric if forced or a qualifier was provided and val looks numeric   if ( extra === "" || extra ) {    num = parseFloat( val );    return extra === true || isFinite( num ) ? num || 0 : val;   }
return val;  } } );
jQuery.each( [ "height", "width" ], function( i, name ) {  jQuery.cssHooks[ name ] = {   get: function( elem, computed, extra ) {    if ( computed ) {
// Certain elements can have dimension info if we invisibly show them     // but it must have a current display style that would benefit     return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
// Support: Safari 8+      // Table columns in Safari have non-zero offsetWidth & zero      // getBoundingClientRect().width unless display is changed.      // Support: IE <=11 only      // Running getBoundingClientRect on a disconnected node      // in IE throws an error.      ( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?       swap( elem, cssShow, function() {        return getWidthOrHeight( elem, name, extra );       } ) :       getWidthOrHeight( elem, name, extra );    }   },
set: function( elem, value, extra ) {    var matches,     styles = extra && getStyles( elem ),     subtract = extra && augmentWidthOrHeight(      elem,      name,      extra,      jQuery.css( elem, "boxSizing", false, styles ) === "border-box",      styles );
// Convert to pixels if value adjustment is needed    if ( subtract && ( matches = rcssNum.exec( value ) ) && ( matches[ 3 ] || "px" ) !== "px" ) {
elem.style[ name ] = value;     value = jQuery.css( elem, name );    }
return setPositiveNumber( elem, value, subtract );   }  }; } );
jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,  function( elem, computed ) {   if ( computed ) {    return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||     elem.getBoundingClientRect().left -      swap( elem, { marginLeft: 0 }, function() {       return elem.getBoundingClientRect().left;      } )     ) + "px";   }  } );
// These hooks are used by animate to expand properties jQuery.each( {  margin: "",  padding: "",  border: "Width" }, function( prefix, suffix ) {  jQuery.cssHooks[ prefix + suffix ] = {   expand: function( value ) {    var i = 0,     expanded = {},
// Assumes a single number if not a string     parts = typeof value === "string" ? value.split( " " ) : [ value ];
for ( ; i < 4; i++ ) {     expanded[ prefix + cssExpand[ i ] + suffix ] =      parts[ i ] || parts[ i - 2 ] || parts[ 0 ];    }
return expanded;   }  };
if ( !rmargin.test( prefix ) ) {   jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;  } } );
jQuery.fn.extend( {  css: function( name, value ) {   return access( this, function( elem, name, value ) {    var styles, len,     map = {},     i = 0;
if ( Array.isArray( name ) ) {     styles = getStyles( elem );     len = name.length;
for ( ; i < len; i++ ) {      map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );     }
return map;    }
return value !== undefined ?     jQuery.style( elem, name, value ) :     jQuery.css( elem, name );   }, name, value, arguments.length > 1 );  } } );
function Tween( elem, options, prop, end, easing ) {  return new Tween.prototype.init( elem, options, prop, end, easing ); } jQuery.Tween = Tween;
Tween.prototype = {  constructor: Tween,  init: function( elem, options, prop, end, easing, unit ) {   this.elem = elem;   this.prop = prop;   this.easing = easing || jQuery.easing._default;   this.options = options;   this.start = this.now = this.cur();   this.end = end;   this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );  },  cur: function() {   var hooks = Tween.propHooks[ this.prop ];
return hooks && hooks.get ?    hooks.get( this ) :    Tween.propHooks._default.get( this );  },  run: function( percent ) {   var eased,    hooks = Tween.propHooks[ this.prop ];
if ( this.options.duration ) {    this.pos = eased = jQuery.easing[ this.easing ](     percent, this.options.duration * percent, 0, 1, this.options.duration    );   } else {    this.pos = eased = percent;   }   this.now = ( this.end - this.start ) * eased + this.start;
if ( this.options.step ) {    this.options.step.call( this.elem, this.now, this );   }
if ( hooks && hooks.set ) {    hooks.set( this );   } else {    Tween.propHooks._default.set( this );   }   return this;  } };
Tween.prototype.init.prototype = Tween.prototype;
Tween.propHooks = {  _default: {   get: function( tween ) {    var result;
// Use a property on the element directly when it is not a DOM element,    // or when there is no matching style property that exists.    if ( tween.elem.nodeType !== 1 ||     tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {     return tween.elem[ tween.prop ];    }
// Passing an empty string as a 3rd parameter to .css will automatically    // attempt a parseFloat and fallback to a string if the parse fails.    // Simple values such as "10px" are parsed to Float;    // complex values such as "rotate(1rad)" are returned as-is.    result = jQuery.css( tween.elem, tween.prop, "" );
// Empty strings, null, undefined and "auto" are converted to 0.    return !result || result === "auto" ? 0 : result;   },   set: function( tween ) {
// Use step hook for back compat.    // Use cssHook if its there.    // Use .style if available and use plain properties where available.    if ( jQuery.fx.step[ tween.prop ] ) {     jQuery.fx.step[ tween.prop ]( tween );    } else if ( tween.elem.nodeType === 1 && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||      jQuery.cssHooks[ tween.prop ] ) ) {     jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );    } else {     tween.elem[ tween.prop ] = tween.now;    }   }  } };
// Support: IE <=9 only // Panic based approach to setting things on disconnected nodes Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {  set: function( tween ) {   if ( tween.elem.nodeType && tween.elem.parentNode ) {    tween.elem[ tween.prop ] = tween.now;   }  } };
jQuery.easing = {  linear: function( p ) {   return p;  },  swing: function( p ) {   return 0.5 - Math.cos( p * Math.PI ) / 2;  },  _default: "swing" };
jQuery.fx = Tween.prototype.init;
// Back compat <1.8 extension point jQuery.fx.step = {};
var  fxNow, inProgress,  rfxtypes = /^(?:toggle|show|hide)$/,  rrun = /queueHooks$/;
function schedule() {  if ( inProgress ) {   if ( document.hidden === false && window.requestAnimationFrame ) {    window.requestAnimationFrame( schedule );   } else {    window.setTimeout( schedule, jQuery.fx.interval );   }
jQuery.fx.tick();  } }
// Animations created synchronously will run synchronously function createFxNow() {  window.setTimeout( function() {   fxNow = undefined;  } );  return ( fxNow = jQuery.now() ); }
// Generate parameters to create a standard animation function genFx( type, includeWidth ) {  var which,   i = 0,   attrs = { height: type };
// If we include width, step value is 1 to do all cssExpand values, // otherwise step value is 2 to skip over Left and Right  includeWidth = includeWidth ? 1 : 0;  for ( ; i < 4; i += 2 - includeWidth ) {   which = cssExpand[ i ];   attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;  }
if ( includeWidth ) {   attrs.opacity = attrs.width = type;  }
return attrs; }
function createTween( value, prop, animation ) {  var tween,   collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),   index = 0,   length = collection.length;  for ( ; index < length; index++ ) {   if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
// We're done with this property    return tween;   }  } }
function defaultPrefilter( elem, props, opts ) {  var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,   isBox = "width" in props || "height" in props,   anim = this,   orig = {},   style = elem.style,   hidden = elem.nodeType && isHiddenWithinTree( elem ),   dataShow = dataPriv.get( elem, "fxshow" );
// Queue-skipping animations hijack the fx hooks  if ( !opts.queue ) {   hooks = jQuery._queueHooks( elem, "fx" );   if ( hooks.unqueued == null ) {    hooks.unqueued = 0;    oldfire = hooks.empty.fire;    hooks.empty.fire = function() {     if ( !hooks.unqueued ) {      oldfire();     }    };   }   hooks.unqueued++;
anim.always( function() {
// Ensure the complete handler is called before this completes    anim.always( function() {     hooks.unqueued--;     if ( !jQuery.queue( elem, "fx" ).length ) {      hooks.empty.fire();     }    } );   } );  }
// Detect show/hide animations  for ( prop in props ) {   value = props[ prop ];   if ( rfxtypes.test( value ) ) {    delete props[ prop ];    toggle = toggle || value === "toggle";    if ( value === ( hidden ? "hide" : "show" ) ) {
// Pretend to be hidden if this is a "show" and     // there is still data from a stopped show/hide     if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {      hidden = true;
// Ignore all other no-op show/hide data     } else {      continue;     }    }    orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );   }  }
// Bail out if this is a no-op like .hide().hide()  propTween = !jQuery.isEmptyObject( props );  if ( !propTween && jQuery.isEmptyObject( orig ) ) {   return;  }
// Restrict "overflow" and "display" styles during box animations  if ( isBox && elem.nodeType === 1 ) {
// Support: IE <=9 - 11, Edge 12 - 13   // Record all 3 overflow attributes because IE does not infer the shorthand   // from identically-valued overflowX and overflowY   opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
// Identify a display type, preferring old show/hide data over the CSS cascade   restoreDisplay = dataShow && dataShow.display;   if ( restoreDisplay == null ) {    restoreDisplay = dataPriv.get( elem, "display" );   }   display = jQuery.css( elem, "display" );   if ( display === "none" ) {    if ( restoreDisplay ) {     display = restoreDisplay;    } else {
// Get nonempty value(s) by temporarily forcing visibility     showHide( [ elem ], true );     restoreDisplay = elem.style.display || restoreDisplay;     display = jQuery.css( elem, "display" );     showHide( [ elem ] );    }   }
// Animate inline elements as inline-block   if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {    if ( jQuery.css( elem, "float" ) === "none" ) {
// Restore the original display value at the end of pure show/hide animations     if ( !propTween ) {      anim.done( function() {       style.display = restoreDisplay;      } );      if ( restoreDisplay == null ) {       display = style.display;       restoreDisplay = display === "none" ? "" : display;      }     }     style.display = "inline-block";    }   }  }
if ( opts.overflow ) {   style.overflow = "hidden";   anim.always( function() {    style.overflow = opts.overflow[ 0 ];    style.overflowX = opts.overflow[ 1 ];    style.overflowY = opts.overflow[ 2 ];   } );  }
// Implement show/hide animations  propTween = false;  for ( prop in orig ) {
// General show/hide setup for this element animation   if ( !propTween ) {    if ( dataShow ) {     if ( "hidden" in dataShow ) {      hidden = dataShow.hidden;     }    } else {     dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );    }
// Store hidden/visible for toggle so `.stop().toggle()` "reverses"    if ( toggle ) {     dataShow.hidden = !hidden;    }
// Show elements before animating them    if ( hidden ) {     showHide( [ elem ], true );    }
/* eslint-disable no-loop-func */
anim.done( function() {
/* eslint-enable no-loop-func */
// The final step of a "hide" animation is actually hiding the element     if ( !hidden ) {      showHide( [ elem ] );     }     dataPriv.remove( elem, "fxshow" );     for ( prop in orig ) {      jQuery.style( elem, prop, orig[ prop ] );     }    } );   }
// Per-property setup   propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );   if ( !( prop in dataShow ) ) {    dataShow[ prop ] = propTween.start;    if ( hidden ) {     propTween.end = propTween.start;     propTween.start = 0;    }   }  } }
function propFilter( props, specialEasing ) {  var index, name, easing, value, hooks;
// camelCase, specialEasing and expand cssHook pass  for ( index in props ) {   name = jQuery.camelCase( index );   easing = specialEasing[ name ];   value = props[ index ];   if ( Array.isArray( value ) ) {    easing = value[ 1 ];    value = props[ index ] = value[ 0 ];   }
if ( index !== name ) {    props[ name ] = value;    delete props[ index ];   }
hooks = jQuery.cssHooks[ name ];   if ( hooks && "expand" in hooks ) {    value = hooks.expand( value );    delete props[ name ];
// Not quite $.extend, this won't overwrite existing keys.    // Reusing 'index' because we have the correct "name"    for ( index in value ) {     if ( !( index in props ) ) {      props[ index ] = value[ index ];      specialEasing[ index ] = easing;     }    }   } else {    specialEasing[ name ] = easing;   }  } }
function Animation( elem, properties, options ) {  var result,   stopped,   index = 0,   length = Animation.prefilters.length,   deferred = jQuery.Deferred().always( function() {
// Don't match elem in the :animated selector    delete tick.elem;   } ),   tick = function() {    if ( stopped ) {     return false;    }    var currentTime = fxNow || createFxNow(),     remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
// Support: Android 2.3 only     // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)     temp = remaining / animation.duration || 0,     percent = 1 - temp,     index = 0,     length = animation.tweens.length;
for ( ; index < length; index++ ) {     animation.tweens[ index ].run( percent );    }
deferred.notifyWith( elem, [ animation, percent, remaining ] );
// If there's more to do, yield    if ( percent < 1 && length ) {     return remaining;    }
// If this was an empty animation, synthesize a final progress notification    if ( !length ) {     deferred.notifyWith( elem, [ animation, 1, 0 ] );    }
// Resolve the animation and report its conclusion    deferred.resolveWith( elem, [ animation ] );    return false;   },   animation = deferred.promise( {    elem: elem,    props: jQuery.extend( {}, properties ),    opts: jQuery.extend( true, {     specialEasing: {},     easing: jQuery.easing._default    }, options ),    originalProperties: properties,    originalOptions: options,    startTime: fxNow || createFxNow(),    duration: options.duration,    tweens: [],    createTween: function( prop, end ) {     var tween = jQuery.Tween( elem, animation.opts, prop, end,       animation.opts.specialEasing[ prop ] || animation.opts.easing );     animation.tweens.push( tween );     return tween;    },    stop: function( gotoEnd ) {     var index = 0,
// If we are going to the end, we want to run all the tweens      // otherwise we skip this part      length = gotoEnd ? animation.tweens.length : 0;     if ( stopped ) {      return this;     }     stopped = true;     for ( ; index < length; index++ ) {      animation.tweens[ index ].run( 1 );     }
// Resolve when we played the last frame; otherwise, reject     if ( gotoEnd ) {      deferred.notifyWith( elem, [ animation, 1, 0 ] );      deferred.resolveWith( elem, [ animation, gotoEnd ] );     } else {      deferred.rejectWith( elem, [ animation, gotoEnd ] );     }     return this;    }   } ),   props = animation.props;
propFilter( props, animation.opts.specialEasing );
for ( ; index < length; index++ ) {   result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );   if ( result ) {    if ( jQuery.isFunction( result.stop ) ) {     jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =      jQuery.proxy( result.stop, result );    }    return result;   }  }
jQuery.map( props, createTween, animation );
if ( jQuery.isFunction( animation.opts.start ) ) {   animation.opts.start.call( elem, animation );  }
// Attach callbacks from options  animation   .progress( animation.opts.progress )   .done( animation.opts.done, animation.opts.complete )   .fail( animation.opts.fail )   .always( animation.opts.always );
jQuery.fx.timer(   jQuery.extend( tick, {    elem: elem,    anim: animation,    queue: animation.opts.queue   } )  );
return animation; }
jQuery.Animation = jQuery.extend( Animation, {
tweeners: {   "*": [ function( prop, value ) {    var tween = this.createTween( prop, value );    adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );    return tween;   } ]  },
tweener: function( props, callback ) {   if ( jQuery.isFunction( props ) ) {    callback = props;    props = [ "*" ];   } else {    props = props.match( rnothtmlwhite );   }
var prop,    index = 0,    length = props.length;
for ( ; index < length; index++ ) {    prop = props[ index ];    Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];    Animation.tweeners[ prop ].unshift( callback );   }  },
prefilters: [ defaultPrefilter ],
prefilter: function( callback, prepend ) {   if ( prepend ) {    Animation.prefilters.unshift( callback );   } else {    Animation.prefilters.push( callback );   }  } } );
jQuery.speed = function( speed, easing, fn ) {  var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {   complete: fn || !fn && easing ||    jQuery.isFunction( speed ) && speed,   duration: speed,   easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing  };
// Go to the end state if fx are off  if ( jQuery.fx.off ) {   opt.duration = 0;
} else {   if ( typeof opt.duration !== "number" ) {    if ( opt.duration in jQuery.fx.speeds ) {     opt.duration = jQuery.fx.speeds[ opt.duration ];
} else {     opt.duration = jQuery.fx.speeds._default;    }   }  }
// Normalize opt.queue - true/undefined/null -> "fx"  if ( opt.queue == null || opt.queue === true ) {   opt.queue = "fx";  }
// Queueing  opt.old = opt.complete;
opt.complete = function() {   if ( jQuery.isFunction( opt.old ) ) {    opt.old.call( this );   }
if ( opt.queue ) {    jQuery.dequeue( this, opt.queue );   }  };
return opt; };
jQuery.fn.extend( {  fadeTo: function( speed, to, easing, callback ) {
// Show any hidden elements after setting opacity to 0   return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
// Animate to the value specified    .end().animate( { opacity: to }, speed, easing, callback );  },  animate: function( prop, speed, easing, callback ) {   var empty = jQuery.isEmptyObject( prop ),    optall = jQuery.speed( speed, easing, callback ),    doAnimation = function() {
// Operate on a copy of prop so per-property easing won't be lost     var anim = Animation( this, jQuery.extend( {}, prop ), optall );
// Empty animations, or finishing resolves immediately     if ( empty || dataPriv.get( this, "finish" ) ) {      anim.stop( true );     }    };    doAnimation.finish = doAnimation;
return empty || optall.queue === false ?    this.each( doAnimation ) :    this.queue( optall.queue, doAnimation );  },  stop: function( type, clearQueue, gotoEnd ) {   var stopQueue = function( hooks ) {    var stop = hooks.stop;    delete hooks.stop;    stop( gotoEnd );   };
if ( typeof type !== "string" ) {    gotoEnd = clearQueue;    clearQueue = type;    type = undefined;   }   if ( clearQueue && type !== false ) {    this.queue( type || "fx", [] );   }
return this.each( function() {    var dequeue = true,     index = type != null && type + "queueHooks",     timers = jQuery.timers,     data = dataPriv.get( this );
if ( index ) {     if ( data[ index ] && data[ index ].stop ) {      stopQueue( data[ index ] );     }    } else {     for ( index in data ) {      if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {       stopQueue( data[ index ] );      }     }    }
for ( index = timers.length; index--; ) {     if ( timers[ index ].elem === this && ( type == null || timers[ index ].queue === type ) ) {
timers[ index ].anim.stop( gotoEnd );      dequeue = false;      timers.splice( index, 1 );     }    }
// Start the next in the queue if the last step wasn't forced.    // Timers currently will call their complete callbacks, which    // will dequeue but only if they were gotoEnd.    if ( dequeue || !gotoEnd ) {     jQuery.dequeue( this, type );    }   } );  },  finish: function( type ) {   if ( type !== false ) {    type = type || "fx";   }   return this.each( function() {    var index,     data = dataPriv.get( this ),     queue = data[ type + "queue" ],     hooks = data[ type + "queueHooks" ],     timers = jQuery.timers,     length = queue ? queue.length : 0;
// Enable finishing flag on private data    data.finish = true;
// Empty the queue first    jQuery.queue( this, type, [] );
if ( hooks && hooks.stop ) {     hooks.stop.call( this, true );    }
// Look for any active animations, and finish them    for ( index = timers.length; index--; ) {     if ( timers[ index ].elem === this && timers[ index ].queue === type ) {      timers[ index ].anim.stop( true );      timers.splice( index, 1 );     }    }
// Look for any animations in the old queue and finish them    for ( index = 0; index < length; index++ ) {     if ( queue[ index ] && queue[ index ].finish ) {      queue[ index ].finish.call( this );     }    }
// Turn off finishing flag    delete data.finish;   } );  } } );
jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {  var cssFn = jQuery.fn[ name ];  jQuery.fn[ name ] = function( speed, easing, callback ) {   return speed == null || typeof speed === "boolean" ?    cssFn.apply( this, arguments ) :    this.animate( genFx( name, true ), speed, easing, callback );  }; } );
// Generate shortcuts for custom animations jQuery.each( {  slideDown: genFx( "show" ),  slideUp: genFx( "hide" ),  slideToggle: genFx( "toggle" ),  fadeIn: { opacity: "show" },  fadeOut: { opacity: "hide" },  fadeToggle: { opacity: "toggle" } }, function( name, props ) {  jQuery.fn[ name ] = function( speed, easing, callback ) {   return this.animate( props, speed, easing, callback );  }; } );
jQuery.timers = []; jQuery.fx.tick = function() {  var timer,   i = 0,   timers = jQuery.timers;
fxNow = jQuery.now();
for ( ; i < timers.length; i++ ) {   timer = timers[ i ];
// Run the timer and safely remove it when done (allowing for external removal)   if ( !timer() && timers[ i ] === timer ) {    timers.splice( i--, 1 );   }  }
if ( !timers.length ) {   jQuery.fx.stop();  }  fxNow = undefined; };
jQuery.fx.timer = function( timer ) {  jQuery.timers.push( timer );  jQuery.fx.start(); };
jQuery.fx.interval = 13; jQuery.fx.start = function() {  if ( inProgress ) {   return;  }
inProgress = true;  schedule(); };
jQuery.fx.stop = function() {  inProgress = null; };
jQuery.fx.speeds = {  slow: 600,  fast: 200,
// Default speed  _default: 400 };
// Based off of the plugin by Clint Helfers, with permission. // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/ jQuery.fn.delay = function( time, type ) {  time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;  type = type || "fx";
return this.queue( type, function( next, hooks ) {   var timeout = window.setTimeout( next, time );   hooks.stop = function() {    window.clearTimeout( timeout );   };  } ); };
( function() {  var input = document.createElement( "input" ),   select = document.createElement( "select" ),   opt = select.appendChild( document.createElement( "option" ) );
input.type = "checkbox";
// Support: Android <=4.3 only  // Default value for a checkbox should be "on"  support.checkOn = input.value !== "";
// Support: IE <=11 only  // Must access selectedIndex to make default options select  support.optSelected = opt.selected;
// Support: IE <=11 only  // An input loses its value after becoming a radio  input = document.createElement( "input" );  input.value = "t";  input.type = "radio";  support.radioValue = input.value === "t"; } )();
var boolHook,  attrHandle = jQuery.expr.attrHandle;
jQuery.fn.extend( {  attr: function( name, value ) {   return access( this, jQuery.attr, name, value, arguments.length > 1 );  },
removeAttr: function( name ) {   return this.each( function() {    jQuery.removeAttr( this, name );   } );  } } );
jQuery.extend( {  attr: function( elem, name, value ) {   var ret, hooks,    nType = elem.nodeType;
// Don't get/set attributes on text, comment and attribute nodes   if ( nType === 3 || nType === 8 || nType === 2 ) {    return;   }
// Fallback to prop when attributes are not supported   if ( typeof elem.getAttribute === "undefined" ) {    return jQuery.prop( elem, name, value );   }
// Attribute hooks are determined by the lowercase version   // Grab necessary hook if one is defined   if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {    hooks = jQuery.attrHooks[ name.toLowerCase() ] ||     ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );   }
if ( value !== undefined ) {    if ( value === null ) {     jQuery.removeAttr( elem, name );     return;    }
if ( hooks && "set" in hooks && ( ret = hooks.set( elem, value, name ) ) !== undefined ) {     return ret;    }
elem.setAttribute( name, value + "" );    return value;   }
if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {    return ret;   }
ret = jQuery.find.attr( elem, name );
// Non-existent attributes return null, we normalize to undefined   return ret == null ? undefined : ret;  },
attrHooks: {   type: {    set: function( elem, value ) {     if ( !support.radioValue && value === "radio" && nodeName( elem, "input" ) ) { var val = elem.value;      elem.setAttribute( "type", value );      if ( val ) {       elem.value = val;      }      return value;     }    }   }  },
removeAttr: function( elem, value ) {   var name,    i = 0,
// Attribute names can contain non-HTML whitespace characters    // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2 attrNames = value && value.match( rnothtmlwhite );
if ( attrNames && elem.nodeType === 1 ) {    while ( ( name = attrNames[ i++ ] ) ) {     elem.removeAttribute( name );    }   }  } } );
// Hooks for boolean attributes boolHook = {  set: function( elem, value, name ) {   if ( value === false ) {
// Remove boolean attributes when set to false    jQuery.removeAttr( elem, name );   } else {    elem.setAttribute( name, name );   }   return name;  } };
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {  var getter = attrHandle[ name ] || jQuery.find.attr;
attrHandle[ name ] = function( elem, name, isXML ) {   var ret, handle,    lowercaseName = name.toLowerCase();
if ( !isXML ) {
// Avoid an infinite loop by temporarily removing this function from the getter    handle = attrHandle[ lowercaseName ];    attrHandle[ lowercaseName ] = ret;    ret = getter( elem, name, isXML ) != null ?     lowercaseName :     null;    attrHandle[ lowercaseName ] = handle;   }   return ret;  }; } );
var rfocusable = /^(?:input|select|textarea|button)$/i,  rclickable = /^(?:a|area)$/i;
jQuery.fn.extend( {  prop: function( name, value ) {   return access( this, jQuery.prop, name, value, arguments.length > 1 );  },
removeProp: function( name ) {   return this.each( function() {    delete this[ jQuery.propFix[ name ] || name ];   } );  } } );
jQuery.extend( {  prop: function( elem, name, value ) {   var ret, hooks,    nType = elem.nodeType;
// Don't get/set properties on text, comment and attribute nodes   if ( nType === 3 || nType === 8 || nType === 2 ) {    return;   }
if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
// Fix name and attach hooks    name = jQuery.propFix[ name ] || name;    hooks = jQuery.propHooks[ name ];   }
if ( value !== undefined ) {    if ( hooks && "set" in hooks && ( ret = hooks.set( elem, value, name ) ) !== undefined ) {     return ret;    }
return ( elem[ name ] = value );   }
if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {    return ret;   }
return elem[ name ];  },
propHooks: {   tabIndex: {    get: function( elem ) {
// Support: IE <=9 - 11 only     // elem.tabIndex doesn't always return the     // correct value when it hasn't been explicitly set     // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/ // Use proper attribute retrieval(#12072)     var tabindex = jQuery.find.attr( elem, "tabindex" );
if ( tabindex ) {      return parseInt( tabindex, 10 );     }
if (      rfocusable.test( elem.nodeName ) ||      rclickable.test( elem.nodeName ) && elem.href     ) {      return 0;     }
return -1;    }   }  },
propFix: {   "for": "htmlFor",   "class": "className"  } } );
// Support: IE <=11 only // Accessing the selectedIndex property // forces the browser to respect setting selected // on the option // The getter ensures a default option is selected // when in an optgroup // eslint rule "no-unused-expressions" is disabled for this code // since it considers such accessions noop if ( !support.optSelected ) {  jQuery.propHooks.selected = {   get: function( elem ) {
/* eslint no-unused-expressions: "off" */
var parent = elem.parentNode;    if ( parent && parent.parentNode ) {     parent.parentNode.selectedIndex;    }    return null;   },   set: function( elem ) {
/* eslint no-unused-expressions: "off" */
var parent = elem.parentNode;    if ( parent ) {     parent.selectedIndex;
if ( parent.parentNode ) {      parent.parentNode.selectedIndex;     }    }   }  }; }
jQuery.each( [  "tabIndex",  "readOnly",  "maxLength",  "cellSpacing",  "cellPadding",  "rowSpan",  "colSpan",  "useMap",  "frameBorder",  "contentEditable" ], function() {  jQuery.propFix[ this.toLowerCase() ] = this; } );
// Strip and collapse whitespace according to HTML spec  // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace function stripAndCollapse( value ) {   var tokens = value.match( rnothtmlwhite ) || [];   return tokens.join( " " );  }
function getClass( elem ) {  return elem.getAttribute && elem.getAttribute( "class" ) || ""; }
jQuery.fn.extend( {  addClass: function( value ) {   var classes, elem, cur, curValue, clazz, j, finalValue,    i = 0;
if ( jQuery.isFunction( value ) ) {    return this.each( function( j ) {     jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );    } );   }
if ( typeof value === "string" && value ) {    classes = value.match( rnothtmlwhite ) || [];
while ( ( elem = this[ i++ ] ) ) {     curValue = getClass( elem );     cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
if ( cur ) {      j = 0;      while ( ( clazz = classes[ j++ ] ) ) {       if ( cur.indexOf( " " + clazz + " " ) < 0 ) {        cur += clazz + " ";       }      }
// Only assign if different to avoid unneeded rendering.      finalValue = stripAndCollapse( cur );      if ( curValue !== finalValue ) {       elem.setAttribute( "class", finalValue );      }     }    }   }
return this;  },
removeClass: function( value ) {   var classes, elem, cur, curValue, clazz, j, finalValue,    i = 0;
if ( jQuery.isFunction( value ) ) {    return this.each( function( j ) {     jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );    } );   }
if ( !arguments.length ) {    return this.attr( "class", "" );   }
if ( typeof value === "string" && value ) {    classes = value.match( rnothtmlwhite ) || [];
while ( ( elem = this[ i++ ] ) ) {     curValue = getClass( elem );
// This expression is here for better compressibility (see addClass)     cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
if ( cur ) {      j = 0;      while ( ( clazz = classes[ j++ ] ) ) {
// Remove *all* instances       while ( cur.indexOf( " " + clazz + " " ) > -1 ) {        cur = cur.replace( " " + clazz + " ", " " );       }      }
// Only assign if different to avoid unneeded rendering.      finalValue = stripAndCollapse( cur );      if ( curValue !== finalValue ) {       elem.setAttribute( "class", finalValue );      }     }    }   }
return this;  },
toggleClass: function( value, stateVal ) {   var type = typeof value;
if ( typeof stateVal === "boolean" && type === "string" ) {    return stateVal ? this.addClass( value ) : this.removeClass( value );   }
if ( jQuery.isFunction( value ) ) {    return this.each( function( i ) {     jQuery( this ).toggleClass(      value.call( this, i, getClass( this ), stateVal ),      stateVal     );    } );   }
return this.each( function() {    var className, i, self, classNames;
if ( type === "string" ) {
// Toggle individual class names     i = 0;     self = jQuery( this );     classNames = value.match( rnothtmlwhite ) || [];
while ( ( className = classNames[ i++ ] ) ) {
// Check each className given, space separated list      if ( self.hasClass( className ) ) {       self.removeClass( className );      } else {       self.addClass( className );      }     }
// Toggle whole class name    } else if ( value === undefined || type === "boolean" ) {     className = getClass( this );     if ( className ) {
// Store className if set      dataPriv.set( this, "__className__", className );     }
// If the element has a class name or if we're passed `false`,     // then remove the whole classname (if there was one, the above saved it).     // Otherwise bring back whatever was previously saved (if anything),     // falling back to the empty string if nothing was stored.     if ( this.setAttribute ) {      this.setAttribute( "class",       className || value === false ?       "" :       dataPriv.get( this, "__className__" ) || ""      );     }    }   } );  },
hasClass: function( selector ) {   var className, elem,    i = 0;
className = " " + selector + " ";   while ( ( elem = this[ i++ ] ) ) {    if ( elem.nodeType === 1 && ( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {      return true;    }   }
return false;  } } );
var rreturn = /\r/g;
jQuery.fn.extend( {  val: function( value ) {   var hooks, ret, isFunction,    elem = this[ 0 ];
if ( !arguments.length ) {    if ( elem ) {     hooks = jQuery.valHooks[ elem.type ] ||      jQuery.valHooks[ elem.nodeName.toLowerCase() ];
if ( hooks && "get" in hooks && ( ret = hooks.get( elem, "value" ) ) !== undefined     ) {      return ret;     }
ret = elem.value;
// Handle most common string cases     if ( typeof ret === "string" ) {      return ret.replace( rreturn, "" );     }
// Handle cases where value is null/undef or number     return ret == null ? "" : ret;    }
return;   }
isFunction = jQuery.isFunction( value );
return this.each( function( i ) {    var val;
if ( this.nodeType !== 1 ) {     return;    }
if ( isFunction ) {     val = value.call( this, i, jQuery( this ).val() );    } else {     val = value;    }
// Treat null/undefined as ""; convert numbers to string    if ( val == null ) {     val = "";
} else if ( typeof val === "number" ) {     val += "";
} else if ( Array.isArray( val ) ) {     val = jQuery.map( val, function( value ) {      return value == null ? "" : value + "";     } );    }
hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
// If set returns undefined, fall back to normal setting    if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {     this.value = val;    }   } );  } } );
jQuery.extend( {  valHooks: {   option: {    get: function( elem ) {
var val = jQuery.find.attr( elem, "value" );     return val != null ?      val :
// Support: IE <=10 - 11 only      // option.text throws exceptions (#14686, #14858)      // Strip and collapse whitespace      // https://html.spec.whatwg.org/#strip-and-collapse-whitespace stripAndCollapse( jQuery.text( elem ) );    }   },   select: {    get: function( elem ) {     var value, option, i,      options = elem.options,      index = elem.selectedIndex,      one = elem.type === "select-one",      values = one ? null : [],      max = one ? index + 1 : options.length;
if ( index < 0 ) {      i = max;
} else {      i = one ? index : 0;     }
// Loop through all the selected options     for ( ; i < max; i++ ) {      option = options[ i ];
// Support: IE <=9 only      // IE8-9 doesn't update selected after form reset (#2551)      if ( ( option.selected || i === index ) &&
// Don't return options that are disabled or in a disabled optgroup        !option.disabled && ( !option.parentNode.disabled ||         !nodeName( option.parentNode, "optgroup" ) ) ) {
// Get the specific value for the option       value = jQuery( option ).val();
// We don't need an array for one selects       if ( one ) {        return value;       }
// Multi-Selects return an array       values.push( value );      }     }
return values;    },
set: function( elem, value ) {     var optionSet, option,      options = elem.options,      values = jQuery.makeArray( value ),      i = options.length;
while ( i-- ) {      option = options[ i ];
/* eslint-disable no-cond-assign */
if ( option.selected =       jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1      ) {       optionSet = true;      }
/* eslint-enable no-cond-assign */     }
// Force browsers to behave consistently when non-matching value is set     if ( !optionSet ) {      elem.selectedIndex = -1;     }     return values;    }   }  } } );
// Radios and checkboxes getter/setter jQuery.each( [ "radio", "checkbox" ], function() {  jQuery.valHooks[ this ] = {   set: function( elem, value ) {    if ( Array.isArray( value ) ) {     return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );    }   }  };  if ( !support.checkOn ) {   jQuery.valHooks[ this ].get = function( elem ) {    return elem.getAttribute( "value" ) === null ? "on" : elem.value;   };  } } );
// Return jQuery for attributes-only inclusion
var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
jQuery.extend( jQuery.event, {
trigger: function( event, data, elem, onlyHandlers ) {
var i, cur, tmp, bubbleType, ontype, handle, special,    eventPath = [ elem || document ],    type = hasOwn.call( event, "type" ) ? event.type : event,    namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
cur = tmp = elem = elem || document;
// Don't do events on text and comment nodes   if ( elem.nodeType === 3 || elem.nodeType === 8 ) {    return;   }
// focus/blur morphs to focusin/out; ensure we're not firing them right now   if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {    return;   }
if ( type.indexOf( "." ) > -1 ) {
// Namespaced trigger; create a regexp to match event type in handle()    namespaces = type.split( "." );    type = namespaces.shift();    namespaces.sort();   }   ontype = type.indexOf( ":" ) < 0 && "on" + type;
// Caller can pass in a jQuery.Event object, Object, or just an event type string   event = event[ jQuery.expando ] ?    event :    new jQuery.Event( type, typeof event === "object" && event );
// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)   event.isTrigger = onlyHandlers ? 2 : 3;   event.namespace = namespaces.join( "." );   event.rnamespace = event.namespace ?    new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :    null;
// Clean up the event in case it is being reused   event.result = undefined;   if ( !event.target ) {    event.target = elem;   }
// Clone any incoming data and prepend the event, creating the handler arg list   data = data == null ?    [ event ] :    jQuery.makeArray( data, [ event ] );
// Allow special events to draw outside the lines   special = jQuery.event.special[ type ] || {};   if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {    return;   }
// Determine event propagation path in advance, per W3C events spec (#9951)   // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)   if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
bubbleType = special.delegateType || type;    if ( !rfocusMorph.test( bubbleType + type ) ) {     cur = cur.parentNode;    }    for ( ; cur; cur = cur.parentNode ) {     eventPath.push( cur );     tmp = cur;    }
// Only add window if we got to document (e.g., not plain obj or detached DOM)    if ( tmp === ( elem.ownerDocument || document ) ) {     eventPath.push( tmp.defaultView || tmp.parentWindow || window );    }   }
// Fire handlers on the event path   i = 0;   while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
event.type = i > 1 ?     bubbleType :     special.bindType || type;
// jQuery handler    handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] && dataPriv.get( cur, "handle" );    if ( handle ) {     handle.apply( cur, data );    }
// Native handler    handle = ontype && cur[ ontype ];    if ( handle && handle.apply && acceptData( cur ) ) {     event.result = handle.apply( cur, data );     if ( event.result === false ) {      event.preventDefault();     }    }   }   event.type = type;
// If nobody prevented the default action, do it now   if ( !onlyHandlers && !event.isDefaultPrevented() ) {
if ( ( !special._default ||     special._default.apply( eventPath.pop(), data ) === false ) && acceptData( elem ) ) {
// Call a native DOM method on the target with the same name as the event.     // Don't do default actions on window, that's where global variables be (#6170)     if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
// Don't re-trigger an onFOO event when we call its FOO() method      tmp = elem[ ontype ];
if ( tmp ) {       elem[ ontype ] = null;      }
// Prevent re-triggering of the same event, since we already bubbled it above      jQuery.event.triggered = type;      elem[ type ]();      jQuery.event.triggered = undefined;
if ( tmp ) {       elem[ ontype ] = tmp;      }     }    }   }
return event.result;  },
// Piggyback on a donor event to simulate a different one  // Used only for `focus(in | out)` events  simulate: function( type, elem, event ) {   var e = jQuery.extend(    new jQuery.Event(),    event,    {     type: type,     isSimulated: true    }   );
jQuery.event.trigger( e, null, elem );  }
} );
jQuery.fn.extend( {
trigger: function( type, data ) {   return this.each( function() {    jQuery.event.trigger( type, data, this );   } );  },  triggerHandler: function( type, data ) {   var elem = this[ 0 ];   if ( elem ) {    return jQuery.event.trigger( type, data, elem, true );   }  } } );
jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +  "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +  "change select submit keydown keypress keyup contextmenu" ).split( " " ),  function( i, name ) {
// Handle event binding  jQuery.fn[ name ] = function( data, fn ) {   return arguments.length > 0 ?    this.on( name, null, data, fn ) :    this.trigger( name );  }; } );
jQuery.fn.extend( {  hover: function( fnOver, fnOut ) {   return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );  } } );
support.focusin = "onfocusin" in window;
// Support: Firefox <=44 // Firefox doesn't have focus(in | out) events // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787 // // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1 // focus(in | out) events fire after focus & blur events, // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857 if ( !support.focusin ) {  jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
// Attach a single capturing handler on the document while someone wants focusin/focusout   var handler = function( event ) {    jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );   };
jQuery.event.special[ fix ] = {    setup: function() {     var doc = this.ownerDocument || this,      attaches = dataPriv.access( doc, fix );
if ( !attaches ) {      doc.addEventListener( orig, handler, true );     }     dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );    },    teardown: function() {     var doc = this.ownerDocument || this,      attaches = dataPriv.access( doc, fix ) - 1;
if ( !attaches ) {      doc.removeEventListener( orig, handler, true );      dataPriv.remove( doc, fix );
} else {      dataPriv.access( doc, fix, attaches );     }    }   };  } ); } var location = window.location;
var nonce = jQuery.now();
var rquery = ( /\?/ );
// Cross-browser xml parsing jQuery.parseXML = function( data ) {  var xml;  if ( !data || typeof data !== "string" ) {   return null;  }
// Support: IE 9 - 11 only  // IE throws on parseFromString with invalid input.  try {   xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );  } catch ( e ) {   xml = undefined;  }
if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {   jQuery.error( "Invalid XML: " + data );  }  return xml; };
var  rbracket = /\[\]$/,  rCRLF = /\r?\n/g,  rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,  rsubmittable = /^(?:input|select|textarea|keygen)/i;
function buildParams( prefix, obj, traditional, add ) {  var name;
if ( Array.isArray( obj ) ) {
// Serialize array item.   jQuery.each( obj, function( i, v ) {    if ( traditional || rbracket.test( prefix ) ) {
// Treat each array item as a scalar.     add( prefix, v );
} else {
// Item is non-scalar (array or object), encode its numeric index.     buildParams(      prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",      v,      traditional,      add     );    }   } );
} else if ( !traditional && jQuery.type( obj ) === "object" ) {
// Serialize object item.   for ( name in obj ) {    buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );   }
} else {
// Serialize scalar item.   add( prefix, obj );  } }
// Serialize an array of form elements or a set of // key/values into a query string jQuery.param = function( a, traditional ) {  var prefix,   s = [],   add = function( key, valueOrFunction ) {
// If value is a function, invoke it and use its return value    var value = jQuery.isFunction( valueOrFunction ) ?     valueOrFunction() :     valueOrFunction;
s[ s.length ] = encodeURIComponent( key ) + "=" +     encodeURIComponent( value == null ? "" : value );   };
// If an array was passed in, assume that it is an array of form elements.  if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
// Serialize the form elements   jQuery.each( a, function() {    add( this.name, this.value );   } );
} else {
// If traditional, encode the "old" way (the way 1.3.2 or older   // did it), otherwise encode params recursively.   for ( prefix in a ) {    buildParams( prefix, a[ prefix ], traditional, add );   }  }
// Return the resulting serialization  return s.join( "&" ); };
jQuery.fn.extend( {  serialize: function() {   return jQuery.param( this.serializeArray() );  },  serializeArray: function() {   return this.map( function() {
// Can add propHook for "elements" to filter or add form elements    var elements = jQuery.prop( this, "elements" );    return elements ? jQuery.makeArray( elements ) : this;   } )   .filter( function() {    var type = this.type;
// Use .is( ":disabled" ) so that fieldset[disabled] works    return this.name && !jQuery( this ).is( ":disabled" ) && rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) && ( this.checked || !rcheckableType.test( type ) );   } )   .map( function( i, elem ) {    var val = jQuery( this ).val();
if ( val == null ) {     return null;    }
if ( Array.isArray( val ) ) {     return jQuery.map( val, function( val ) {      return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };     } );    }
return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };   } ).get();  } } );
var  r20 = /%20/g,  rhash = /#.*$/,  rantiCache = /([?&])_=[^&]*/,  rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
// #7653, #8125, #8152: local protocol detection  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,  rnoContent = /^(?:GET|HEAD)$/,  rprotocol = /^\/\//,
/* Prefilters   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)   * 2) These are called:   *    - BEFORE asking for a transport   *    - AFTER param serialization (s.data is a string if s.processData is true)   * 3) key is the dataType   * 4) the catchall symbol "*" can be used   * 5) execution will start with transport dataType and THEN continue down to "*" if needed   */  prefilters = {},
/* Transports bindings   * 1) key is the dataType   * 2) the catchall symbol "*" can be used   * 3) selection will start with transport dataType and THEN go to "*" if needed   */  transports = {},
// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression  allTypes = "*/".concat( "*" ),
// Anchor tag for parsing the document origin  originAnchor = document.createElement( "a" );  originAnchor.href = location.href;
// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport function addToPrefiltersOrTransports( structure ) {
// dataTypeExpression is optional and defaults to "*"  return function( dataTypeExpression, func ) {
if ( typeof dataTypeExpression !== "string" ) {    func = dataTypeExpression;    dataTypeExpression = "*";   }
var dataType,    i = 0,    dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
if ( jQuery.isFunction( func ) ) {
// For each dataType in the dataTypeExpression    while ( ( dataType = dataTypes[ i++ ] ) ) {
// Prepend if requested     if ( dataType[ 0 ] === "+" ) {      dataType = dataType.slice( 1 ) || "*";      ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
// Otherwise append     } else {      ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );     }    }   }  }; }
// Base inspection function for prefilters and transports function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
var inspected = {},   seekingTransport = ( structure === transports );
function inspect( dataType ) {   var selected;   inspected[ dataType ] = true;   jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {    var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );    if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
options.dataTypes.unshift( dataTypeOrTransport );     inspect( dataTypeOrTransport );     return false;    } else if ( seekingTransport ) {     return !( selected = dataTypeOrTransport );    }   } );   return selected;  }
return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" ); }
// A special extend for ajax options // that takes "flat" options (not to be deep extended) // Fixes #9887 function ajaxExtend( target, src ) {  var key, deep,   flatOptions = jQuery.ajaxSettings.flatOptions || {};
for ( key in src ) {   if ( src[ key ] !== undefined ) {    ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];   }  }  if ( deep ) {   jQuery.extend( true, target, deep );  }
return target; }
/* Handles responses to an ajax request:
* - finds the right dataType (mediates between content-type and expected dataType) * - returns the corresponding response */
function ajaxHandleResponses( s, jqXHR, responses ) {
var ct, type, finalDataType, firstDataType,   contents = s.contents,   dataTypes = s.dataTypes;
// Remove auto dataType and get content-type in the process  while ( dataTypes[ 0 ] === "*" ) {   dataTypes.shift();   if ( ct === undefined ) {    ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );   }  }
// Check if we're dealing with a known content-type  if ( ct ) {   for ( type in contents ) {    if ( contents[ type ] && contents[ type ].test( ct ) ) {     dataTypes.unshift( type );     break;    }   }  }
// Check to see if we have a response for the expected dataType  if ( dataTypes[ 0 ] in responses ) {   finalDataType = dataTypes[ 0 ];  } else {
// Try convertible dataTypes   for ( type in responses ) {    if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {     finalDataType = type;     break;    }    if ( !firstDataType ) {     firstDataType = type;    }   }
// Or just use first one   finalDataType = finalDataType || firstDataType;  }
// If we found a dataType  // We add the dataType to the list if needed  // and return the corresponding response  if ( finalDataType ) {   if ( finalDataType !== dataTypes[ 0 ] ) {    dataTypes.unshift( finalDataType );   }   return responses[ finalDataType ];  } }
/* Chain conversions given the request and the original response
* Also sets the responseXXX fields on the jqXHR instance */
function ajaxConvert( s, response, jqXHR, isSuccess ) {  var conv2, current, conv, tmp, prev,   converters = {},
// Work with a copy of dataTypes in case we need to modify it for conversion   dataTypes = s.dataTypes.slice();
// Create converters map with lowercased keys  if ( dataTypes[ 1 ] ) {   for ( conv in s.converters ) {    converters[ conv.toLowerCase() ] = s.converters[ conv ];   }  }
current = dataTypes.shift();
// Convert to each sequential dataType  while ( current ) {
if ( s.responseFields[ current ] ) {    jqXHR[ s.responseFields[ current ] ] = response;   }
// Apply the dataFilter if provided   if ( !prev && isSuccess && s.dataFilter ) {    response = s.dataFilter( response, s.dataType );   }
prev = current;   current = dataTypes.shift();
if ( current ) {
// There's only work to do if current dataType is non-auto    if ( current === "*" ) {
current = prev;
// Convert response if prev dataType is non-auto and differs from current    } else if ( prev !== "*" && prev !== current ) {
// Seek a direct converter     conv = converters[ prev + " " + current ] || converters[ "* " + current ];
// If none found, seek a pair     if ( !conv ) {      for ( conv2 in converters ) {
// If conv2 outputs current       tmp = conv2.split( " " );       if ( tmp[ 1 ] === current ) {
// If prev can be converted to accepted input        conv = converters[ prev + " " + tmp[ 0 ] ] ||         converters[ "* " + tmp[ 0 ] ];        if ( conv ) {
// Condense equivalence converters         if ( conv === true ) {          conv = converters[ conv2 ];
// Otherwise, insert the intermediate dataType         } else if ( converters[ conv2 ] !== true ) {          current = tmp[ 0 ];          dataTypes.unshift( tmp[ 1 ] );         }         break;        }       }      }     }
// Apply converter (if not an equivalence)     if ( conv !== true ) {
// Unless errors are allowed to bubble, catch and return them      if ( conv && s.throws ) {       response = conv( response );      } else {       try {        response = conv( response );       } catch ( e ) {        return {         state: "parsererror",         error: conv ? e : "No conversion from " + prev + " to " + current        };       }      }     }    }   }  }
return { state: "success", data: response }; }
jQuery.extend( {
// Counter for holding the number of active queries  active: 0,
// Last-Modified header cache for next request  lastModified: {},  etag: {},
ajaxSettings: {   url: location.href,   type: "GET",   isLocal: rlocalProtocol.test( location.protocol ),   global: true,   processData: true,   async: true,   contentType: "application/x-www-form-urlencoded; charset=UTF-8",
/*   timeout: 0,   data: null,   dataType: null,   username: null,   password: null,   cache: null,   throws: false,   traditional: false,   headers: {},   */
accepts: {    "*": allTypes,    text: "text/plain",    html: "text/html",    xml: "application/xml, text/xml",    json: "application/json, text/javascript"   },
contents: {    xml: /\bxml\b/,    html: /\bhtml/,    json: /\bjson\b/   },
responseFields: {    xml: "responseXML",    text: "responseText",    json: "responseJSON"   },
// Data converters   // Keys separate source (or catchall "*") and destination types with a single space   converters: {
// Convert anything to text    "* text": String,
// Text to html (true = no transformation)    "text html": true,
// Evaluate text as a json expression    "text json": JSON.parse,
// Parse text as xml    "text xml": jQuery.parseXML   },
// For options that shouldn't be deep extended:   // you can add your own custom options here if   // and when you create one that shouldn't be   // deep extended (see ajaxExtend)   flatOptions: {    url: true,    context: true   }  },
// Creates a full fledged settings object into target  // with both ajaxSettings and settings fields.  // If target is omitted, writes into ajaxSettings.  ajaxSetup: function( target, settings ) {   return settings ?
// Building a settings object    ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
// Extending ajaxSettings    ajaxExtend( jQuery.ajaxSettings, target );  },
ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),  ajaxTransport: addToPrefiltersOrTransports( transports ),
// Main method  ajax: function( url, options ) {
// If url is an object, simulate pre-1.5 signature   if ( typeof url === "object" ) {    options = url;    url = undefined;   }
// Force options to be an object   options = options || {};
var transport,
// URL without anti-cache param    cacheURL,
// Response headers    responseHeadersString,    responseHeaders,
// timeout handle    timeoutTimer,
// Url cleanup var    urlAnchor,
// Request state (becomes false upon send and true upon completion)    completed,
// To know if global events are to be dispatched    fireGlobals,
// Loop variable    i,
// uncached part of the url    uncached,
// Create the final options object    s = jQuery.ajaxSetup( {}, options ),
// Callbacks context    callbackContext = s.context || s,
// Context for global events is callbackContext if it is a DOM node or jQuery collection    globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?      jQuery( callbackContext ) :      jQuery.event,
// Deferreds    deferred = jQuery.Deferred(),    completeDeferred = jQuery.Callbacks( "once memory" ),
// Status-dependent callbacks    statusCode = s.statusCode || {},
// Headers (they are sent all at once)    requestHeaders = {},    requestHeadersNames = {},
// Default abort message    strAbort = "canceled",
// Fake xhr    jqXHR = {     readyState: 0,
// Builds headers hashtable if needed     getResponseHeader: function( key ) {      var match;      if ( completed ) {       if ( !responseHeaders ) {        responseHeaders = {};        while ( ( match = rheaders.exec( responseHeadersString ) ) ) {         responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];        }       }       match = responseHeaders[ key.toLowerCase() ];      }      return match == null ? null : match;     },
// Raw string     getAllResponseHeaders: function() {      return completed ? responseHeadersString : null;     },
// Caches the header     setRequestHeader: function( name, value ) {      if ( completed == null ) {       name = requestHeadersNames[ name.toLowerCase() ] =        requestHeadersNames[ name.toLowerCase() ] || name;       requestHeaders[ name ] = value;      }      return this;     },
// Overrides response content-type header     overrideMimeType: function( type ) {      if ( completed == null ) {       s.mimeType = type;      }      return this;     },
// Status-dependent callbacks     statusCode: function( map ) {      var code;      if ( map ) {       if ( completed ) {
// Execute the appropriate callbacks        jqXHR.always( map[ jqXHR.status ] );       } else {
// Lazy-add the new callbacks in a way that preserves old ones        for ( code in map ) {         statusCode[ code ] = [ statusCode[ code ], map[ code ] ];        }       }      }      return this;     },
// Cancel the request     abort: function( statusText ) {      var finalText = statusText || strAbort;      if ( transport ) {       transport.abort( finalText );      }      done( 0, finalText );      return this;     }    };
// Attach deferreds   deferred.promise( jqXHR );
// Add protocol if not provided (prefilters might expect it)   // Handle falsy url in the settings object (#10093: consistency with old signature)   // We also use the url parameter if available   s.url = ( ( url || s.url || location.href ) + "" )    .replace( rprotocol, location.protocol + "//" );
// Alias method option to type as per ticket #12004   s.type = options.method || options.type || s.method || s.type;
// Extract dataTypes list   s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];
// A cross-domain request is in order when the origin doesn't match the current origin.   if ( s.crossDomain == null ) {    urlAnchor = document.createElement( "a" );
// Support: IE <=8 - 11, Edge 12 - 13    // IE throws exception on accessing the href property if url is malformed,    // e.g. http://example.com:80x/ try {     urlAnchor.href = s.url;
// Support: IE <=8 - 11 only     // Anchor's host property isn't correctly set when s.url is relative     urlAnchor.href = urlAnchor.href;     s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==      urlAnchor.protocol + "//" + urlAnchor.host;    } catch ( e ) {
// If there is an error parsing the URL, assume it is crossDomain,     // it can be rejected by the transport if it is invalid     s.crossDomain = true;    }   }
// Convert data if not already a string   if ( s.data && s.processData && typeof s.data !== "string" ) {    s.data = jQuery.param( s.data, s.traditional );   }
// Apply prefilters   inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
// If request was aborted inside a prefilter, stop there   if ( completed ) {    return jqXHR;   }
// We can fire global events as of now if asked to   // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)   fireGlobals = jQuery.event && s.global;
// Watch for a new set of requests   if ( fireGlobals && jQuery.active++ === 0 ) {    jQuery.event.trigger( "ajaxStart" );   }
// Uppercase the type   s.type = s.type.toUpperCase();
// Determine if request has content   s.hasContent = !rnoContent.test( s.type );
// Save the URL in case we're toying with the If-Modified-Since   // and/or If-None-Match header later on   // Remove hash to simplify url manipulation   cacheURL = s.url.replace( rhash, "" );
// More options handling for requests with no content   if ( !s.hasContent ) {
// Remember the hash so we can put it back    uncached = s.url.slice( cacheURL.length );
// If data is available, append data to url    if ( s.data ) {     cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
// #9682: remove data so that it's not used in an eventual retry     delete s.data;    }
// Add or update anti-cache param if needed    if ( s.cache === false ) {     cacheURL = cacheURL.replace( rantiCache, "$1" );     uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;    }
// Put hash and anti-cache on the URL that will be requested (gh-1732)    s.url = cacheURL + uncached;
// Change '%20' to '+' if this is encoded form body content (gh-2658)   } else if ( s.data && s.processData && ( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {    s.data = s.data.replace( r20, "+" );   }
// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.   if ( s.ifModified ) {    if ( jQuery.lastModified[ cacheURL ] ) {     jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );    }    if ( jQuery.etag[ cacheURL ] ) {     jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );    }   }
// Set the correct header, if data is being sent   if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {    jqXHR.setRequestHeader( "Content-Type", s.contentType );   }
// Set the Accepts header for the server, depending on the dataType   jqXHR.setRequestHeader(    "Accept",    s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?     s.accepts[ s.dataTypes[ 0 ] ] +      ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :     s.accepts[ "*" ]   );
// Check for headers option   for ( i in s.headers ) {    jqXHR.setRequestHeader( i, s.headers[ i ] );   }
// Allow custom headers/mimetypes and early abort   if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
// Abort if not done already and return    return jqXHR.abort();   }
// Aborting is no longer a cancellation   strAbort = "abort";
// Install callbacks on deferreds   completeDeferred.add( s.complete );   jqXHR.done( s.success );   jqXHR.fail( s.error );
// Get transport   transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
// If no transport, we auto-abort   if ( !transport ) {    done( -1, "No Transport" );   } else {    jqXHR.readyState = 1;
// Send global event    if ( fireGlobals ) {     globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );    }
// If request was aborted inside ajaxSend, stop there    if ( completed ) {     return jqXHR;    }
// Timeout    if ( s.async && s.timeout > 0 ) {     timeoutTimer = window.setTimeout( function() {      jqXHR.abort( "timeout" );     }, s.timeout );    }
try {     completed = false;     transport.send( requestHeaders, done );    } catch ( e ) {
// Rethrow post-completion exceptions     if ( completed ) {      throw e;     }
// Propagate others as results     done( -1, e );    }   }
// Callback for when everything is done   function done( status, nativeStatusText, responses, headers ) {    var isSuccess, success, error, response, modified,     statusText = nativeStatusText;
// Ignore repeat invocations    if ( completed ) {     return;    }
completed = true;
// Clear timeout if it exists    if ( timeoutTimer ) {     window.clearTimeout( timeoutTimer );    }
// Dereference transport for early garbage collection    // (no matter how long the jqXHR object will be used)    transport = undefined;
// Cache response headers    responseHeadersString = headers || "";
// Set readyState    jqXHR.readyState = status > 0 ? 4 : 0;
// Determine if successful    isSuccess = status >= 200 && status < 300 || status === 304;
// Get response data    if ( responses ) {     response = ajaxHandleResponses( s, jqXHR, responses );    }
// Convert no matter what (that way responseXXX fields are always set)    response = ajaxConvert( s, response, jqXHR, isSuccess );
// If successful, handle type chaining    if ( isSuccess ) {
// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.     if ( s.ifModified ) {      modified = jqXHR.getResponseHeader( "Last-Modified" );      if ( modified ) {       jQuery.lastModified[ cacheURL ] = modified;      }      modified = jqXHR.getResponseHeader( "etag" );      if ( modified ) {       jQuery.etag[ cacheURL ] = modified;      }     }
// if no content     if ( status === 204 || s.type === "HEAD" ) {      statusText = "nocontent";
// if not modified } else if ( status === 304 ) {      statusText = "notmodified";
// If we have data, let's convert it     } else {      statusText = response.state;      success = response.data;      error = response.error;      isSuccess = !error;     }    } else {
// Extract error from statusText and normalize for non-aborts     error = statusText;     if ( status || !statusText ) {      statusText = "error";      if ( status < 0 ) {       status = 0;      }     }    }
// Set data for the fake xhr object    jqXHR.status = status;    jqXHR.statusText = ( nativeStatusText || statusText ) + "";
// Success/Error    if ( isSuccess ) {     deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );    } else {     deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );    }
// Status-dependent callbacks    jqXHR.statusCode( statusCode );    statusCode = undefined;
if ( fireGlobals ) {     globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",      [ jqXHR, s, isSuccess ? success : error ] );    }
// Complete    completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
if ( fireGlobals ) {     globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
// Handle the global AJAX counter     if ( !( --jQuery.active ) ) {      jQuery.event.trigger( "ajaxStop" );     }    }   }
return jqXHR;  },
getJSON: function( url, data, callback ) {   return jQuery.get( url, data, callback, "json" );  },
getScript: function( url, callback ) {   return jQuery.get( url, undefined, callback, "script" );  } } );
jQuery.each( [ "get", "post" ], function( i, method ) {  jQuery[ method ] = function( url, data, callback, type ) {
// Shift arguments if data argument was omitted   if ( jQuery.isFunction( data ) ) {    type = type || callback;    callback = data;    data = undefined;   }
// The url can be an options object (which then must have .url)   return jQuery.ajax( jQuery.extend( {    url: url,    type: method,    dataType: type,    data: data,    success: callback   }, jQuery.isPlainObject( url ) && url ) );  }; } );
jQuery._evalUrl = function( url ) {  return jQuery.ajax( {   url: url,
// Make this explicit, since user can override this through ajaxSetup (#11264)   type: "GET",   dataType: "script",   cache: true,   async: false,   global: false,   "throws": true  } ); };
jQuery.fn.extend( {  wrapAll: function( html ) {   var wrap;
if ( this[ 0 ] ) {    if ( jQuery.isFunction( html ) ) {     html = html.call( this[ 0 ] );    }
// The elements to wrap the target around    wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
if ( this[ 0 ].parentNode ) {     wrap.insertBefore( this[ 0 ] );    }
wrap.map( function() {     var elem = this;
while ( elem.firstElementChild ) {      elem = elem.firstElementChild;     }
return elem;    } ).append( this );   }
return this;  },
wrapInner: function( html ) {   if ( jQuery.isFunction( html ) ) {    return this.each( function( i ) {     jQuery( this ).wrapInner( html.call( this, i ) );    } );   }
return this.each( function() {    var self = jQuery( this ),     contents = self.contents();
if ( contents.length ) {     contents.wrapAll( html );
} else {     self.append( html );    }   } );  },
wrap: function( html ) {   var isFunction = jQuery.isFunction( html );
return this.each( function( i ) {    jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );   } );  },
unwrap: function( selector ) {   this.parent( selector ).not( "body" ).each( function() {    jQuery( this ).replaceWith( this.childNodes );   } );   return this;  } } );
jQuery.expr.pseudos.hidden = function( elem ) {  return !jQuery.expr.pseudos.visible( elem ); }; jQuery.expr.pseudos.visible = function( elem ) {  return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length ); };
jQuery.ajaxSettings.xhr = function() {  try {   return new window.XMLHttpRequest();  } catch ( e ) {} };
var xhrSuccessStatus = {
// File protocol always yields status code 0, assume 200   0: 200,
// Support: IE <=9 only   // #1450: sometimes IE returns 1223 when it should be 204   1223: 204  },  xhrSupported = jQuery.ajaxSettings.xhr();
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported ); support.ajax = xhrSupported = !!xhrSupported;
jQuery.ajaxTransport( function( options ) {  var callback, errorCallback;
// Cross domain only allowed if supported through XMLHttpRequest  if ( support.cors || xhrSupported && !options.crossDomain ) {   return {    send: function( headers, complete ) {     var i,      xhr = options.xhr();
xhr.open(      options.type,      options.url,      options.async,      options.username,      options.password     );
// Apply custom fields if provided     if ( options.xhrFields ) {      for ( i in options.xhrFields ) {       xhr[ i ] = options.xhrFields[ i ];      }     }
// Override mime type if needed     if ( options.mimeType && xhr.overrideMimeType ) {      xhr.overrideMimeType( options.mimeType );     }
// X-Requested-With header     // For cross-domain requests, seeing as conditions for a preflight are     // akin to a jigsaw puzzle, we simply never set it to be sure.     // (it can always be set on a per-request basis or even using ajaxSetup)     // For same-domain requests, won't change header if already provided.     if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {      headers[ "X-Requested-With" ] = "XMLHttpRequest";     }
// Set headers     for ( i in headers ) {      xhr.setRequestHeader( i, headers[ i ] );     }
// Callback     callback = function( type ) {      return function() {       if ( callback ) {        callback = errorCallback = xhr.onload =         xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
if ( type === "abort" ) {         xhr.abort();        } else if ( type === "error" ) {
// Support: IE <=9 only         // On a manual native abort, IE9 throws         // errors on any property access that is not readyState         if ( typeof xhr.status !== "number" ) {          complete( 0, "error" );         } else {          complete(
// File: protocol always yields status 0; see #8605, #14207           xhr.status,           xhr.statusText          );         }        } else {         complete(          xhrSuccessStatus[ xhr.status ] || xhr.status,          xhr.statusText,
// Support: IE <=9 only          // IE9 has no XHR2 but throws on binary (trac-11426)          // For XHR2 non-text, let the caller handle it (gh-2498)          ( xhr.responseType || "text" ) !== "text"  ||          typeof xhr.responseText !== "string" ?           { binary: xhr.response } :           { text: xhr.responseText },          xhr.getAllResponseHeaders()         );        }       }      };     };
// Listen to events     xhr.onload = callback();     errorCallback = xhr.onerror = callback( "error" );
// Support: IE 9 only     // Use onreadystatechange to replace onabort     // to handle uncaught aborts     if ( xhr.onabort !== undefined ) {      xhr.onabort = errorCallback;     } else {      xhr.onreadystatechange = function() {
// Check readyState before timeout as it changes       if ( xhr.readyState === 4 ) {
// Allow onerror to be called first,        // but that will not handle a native abort        // Also, save errorCallback to a variable        // as xhr.onerror cannot be accessed        window.setTimeout( function() {         if ( callback ) {          errorCallback();         }        } );       }      }; }
// Create the abort callback     callback = callback( "abort" );
try {
// Do send the request (this may raise an exception)      xhr.send( options.hasContent && options.data || null );     } catch ( e ) {
// #14683: Only rethrow if this hasn't been notified as an error yet      if ( callback ) {       throw e;      }     }    },
abort: function() {     if ( callback ) {      callback();     }    }   };  } } );
// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432) jQuery.ajaxPrefilter( function( s ) {  if ( s.crossDomain ) {   s.contents.script = false;  } } );
// Install script dataType jQuery.ajaxSetup( {  accepts: {   script: "text/javascript, application/javascript, " +    "application/ecmascript, application/x-ecmascript"  },  contents: {   script: /\b(?:java|ecma)script\b/  },  converters: {   "text script": function( text ) {    jQuery.globalEval( text );    return text;   }  } } );
// Handle cache's special case and crossDomain jQuery.ajaxPrefilter( "script", function( s ) {  if ( s.cache === undefined ) {   s.cache = false;  }  if ( s.crossDomain ) {   s.type = "GET";  } } );
// Bind script tag hack transport jQuery.ajaxTransport( "script", function( s ) {
// This transport only deals with cross domain requests  if ( s.crossDomain ) {   var script, callback;   return {    send: function( _, complete ) {     script = jQuery( "<script>" ).prop( {      charset: s.scriptCharset,      src: s.url     } ).on(      "load error",      callback = function( evt ) {       script.remove();       callback = null;       if ( evt ) {        complete( evt.type === "error" ? 404 : 200, evt.type );       }      }     );
// Use native DOM manipulation to avoid our domManip AJAX trickery     document.head.appendChild( script[ 0 ] );    },    abort: function() {     if ( callback ) {      callback();     }    }   };  } } );
var oldCallbacks = [],  rjsonp = /(=)\?(?=&|$)|\?\?/;
// Default jsonp settings jQuery.ajaxSetup( {  jsonp: "callback",  jsonpCallback: function() {   var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );   this[ callback ] = true;   return callback;  } } );
// Detect, normalize options and install callbacks for jsonp requests jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
var callbackName, overwritten, responseContainer,   jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?    "url" :    typeof s.data === "string" && ( s.contentType || "" )      .indexOf( "application/x-www-form-urlencoded" ) === 0 && rjsonp.test( s.data ) && "data"   );
// Handle iff the expected data type is "jsonp" or we have a parameter to set  if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
// Get callback name, remembering preexisting value associated with it   callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?    s.jsonpCallback() :    s.jsonpCallback;
// Insert callback into url or form data   if ( jsonProp ) {    s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );   } else if ( s.jsonp !== false ) {    s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;   }
// Use data converter to retrieve json after script execution   s.converters[ "script json" ] = function() {    if ( !responseContainer ) {     jQuery.error( callbackName + " was not called" );    }    return responseContainer[ 0 ];   };
// Force json dataType   s.dataTypes[ 0 ] = "json";
// Install callback   overwritten = window[ callbackName ];   window[ callbackName ] = function() {    responseContainer = arguments;   };
// Clean-up function (fires after converters)   jqXHR.always( function() {
// If previous value didn't exist - remove it    if ( overwritten === undefined ) {     jQuery( window ).removeProp( callbackName );
// Otherwise restore preexisting value    } else {     window[ callbackName ] = overwritten;    }
// Save back as free    if ( s[ callbackName ] ) {
// Make sure that re-using the options doesn't screw things around     s.jsonpCallback = originalSettings.jsonpCallback;
// Save the callback name for future use     oldCallbacks.push( callbackName );    }
// Call if it was a function and we have a response    if ( responseContainer && jQuery.isFunction( overwritten ) ) {     overwritten( responseContainer[ 0 ] );    }
responseContainer = overwritten = undefined;   } );
// Delegate to script   return "script";  } } );
// Support: Safari 8 only // In Safari 8 documents created via document.implementation.createHTMLDocument // collapse sibling forms: the second one becomes a child of the first one. // Because of that, this security measure has to be disabled in Safari 8. // https://bugs.webkit.org/show_bug.cgi?id=137337 support.createHTMLDocument = ( function() {  var body = document.implementation.createHTMLDocument( "" ).body;  body.innerHTML = "<form></form><form></form>";  return body.childNodes.length === 2; } )();
// Argument "data" should be string of html // context (optional): If specified, the fragment will be created in this context, // defaults to document // keepScripts (optional): If true, will include scripts passed in the html string jQuery.parseHTML = function( data, context, keepScripts ) {  if ( typeof data !== "string" ) {   return [];  }  if ( typeof context === "boolean" ) {   keepScripts = context;   context = false;  }
var base, parsed, scripts;
if ( !context ) {
// Stop scripts or inline event handlers from being executed immediately   // by using document.implementation   if ( support.createHTMLDocument ) {    context = document.implementation.createHTMLDocument( "" );
// Set the base href for the created document    // so any parsed elements with URLs    // are based on the document's URL (gh-2965)    base = context.createElement( "base" );    base.href = document.location.href;    context.head.appendChild( base );   } else {    context = document;   }  }
parsed = rsingleTag.exec( data );  scripts = !keepScripts && [];
// Single tag  if ( parsed ) {   return [ context.createElement( parsed[ 1 ] ) ];  }
parsed = buildFragment( [ data ], context, scripts );
if ( scripts && scripts.length ) {   jQuery( scripts ).remove();  }
return jQuery.merge( [], parsed.childNodes ); };
/**
* Load a url into a page */
jQuery.fn.load = function( url, params, callback ) {  var selector, type, response,   self = this,   off = url.indexOf( " " );
if ( off > -1 ) {   selector = stripAndCollapse( url.slice( off ) );   url = url.slice( 0, off );  }
// If it's a function  if ( jQuery.isFunction( params ) ) {
// We assume that it's the callback   callback = params;   params = undefined;
// Otherwise, build a param string  } else if ( params && typeof params === "object" ) {   type = "POST";  }
// If we have elements to modify, make the request  if ( self.length > 0 ) {   jQuery.ajax( {    url: url,
// If "type" variable is undefined, then "GET" method will be used.    // Make value of this field explicit since    // user can override it through ajaxSetup method    type: type || "GET",    dataType: "html",    data: params   } ).done( function( responseText ) {
// Save response for use in complete callback    response = arguments;
self.html( selector ?
// If a selector was specified, locate the right elements in a dummy div     // Exclude scripts to avoid IE 'Permission Denied' errors
jQuery( "
" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
// Otherwise use the full result     responseText );
// If the request succeeds, this function gets "data", "status", "jqXHR"   // but they are ignored because response was set above.   // If it fails, this function gets "jqXHR", "status", "error"   } ).always( callback && function( jqXHR, status ) {    self.each( function() {     callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );    } );   } );  }
return this; };
// Attach a bunch of functions for handling common AJAX events jQuery.each( [  "ajaxStart",  "ajaxStop",  "ajaxComplete",  "ajaxError",  "ajaxSuccess",  "ajaxSend" ], function( i, type ) {  jQuery.fn[ type ] = function( fn ) {   return this.on( type, fn );  }; } );
jQuery.expr.pseudos.animated = function( elem ) {  return jQuery.grep( jQuery.timers, function( fn ) {   return elem === fn.elem;  } ).length; };
jQuery.offset = {  setOffset: function( elem, options, i ) {   var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,    position = jQuery.css( elem, "position" ),    curElem = jQuery( elem ),    props = {};
// Set position first, in-case top/left are set even on static elem   if ( position === "static" ) {    elem.style.position = "relative";   }
curOffset = curElem.offset();   curCSSTop = jQuery.css( elem, "top" );   curCSSLeft = jQuery.css( elem, "left" );   calculatePosition = ( position === "absolute" || position === "fixed" ) && ( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
// Need to be able to calculate position if either   // top or left is auto and position is either absolute or fixed   if ( calculatePosition ) {    curPosition = curElem.position();    curTop = curPosition.top;    curLeft = curPosition.left;
} else {    curTop = parseFloat( curCSSTop ) || 0;    curLeft = parseFloat( curCSSLeft ) || 0;   }
if ( jQuery.isFunction( options ) ) {
// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)    options = options.call( elem, i, jQuery.extend( {}, curOffset ) );   }
if ( options.top != null ) {    props.top = ( options.top - curOffset.top ) + curTop;   }   if ( options.left != null ) {    props.left = ( options.left - curOffset.left ) + curLeft;   }
if ( "using" in options ) {    options.using.call( elem, props );
} else {    curElem.css( props );   }  } };
jQuery.fn.extend( {  offset: function( options ) {
// Preserve chaining for setter   if ( arguments.length ) {    return options === undefined ?     this :     this.each( function( i ) {      jQuery.offset.setOffset( this, options, i );     } );   }
var doc, docElem, rect, win,    elem = this[ 0 ];
if ( !elem ) {    return;   }
// Return zeros for disconnected and hidden (display: none) elements (gh-2310)   // Support: IE <=11 only   // Running getBoundingClientRect on a   // disconnected node in IE throws an error   if ( !elem.getClientRects().length ) {    return { top: 0, left: 0 };   }
rect = elem.getBoundingClientRect();
doc = elem.ownerDocument;   docElem = doc.documentElement;   win = doc.defaultView;
return {    top: rect.top + win.pageYOffset - docElem.clientTop,    left: rect.left + win.pageXOffset - docElem.clientLeft   };  },
position: function() {   if ( !this[ 0 ] ) {    return;   }
var offsetParent, offset,    elem = this[ 0 ],    parentOffset = { top: 0, left: 0 };
// Fixed elements are offset from window (parentOffset = {top:0, left: 0},   // because it is its only offset parent   if ( jQuery.css( elem, "position" ) === "fixed" ) {
// Assume getBoundingClientRect is there when computed position is fixed    offset = elem.getBoundingClientRect();
} else {
// Get *real* offsetParent    offsetParent = this.offsetParent();
// Get correct offsets    offset = this.offset();    if ( !nodeName( offsetParent[ 0 ], "html" ) ) {     parentOffset = offsetParent.offset();    }
// Add offsetParent borders    parentOffset = {     top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),     left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )    };   }
// Subtract parent offsets and element margins   return {    top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),    left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )   };  },
// This method will return documentElement in the following cases:  // 1) For the element inside the iframe without offsetParent, this method will return  //    documentElement of the parent window  // 2) For the hidden or detached element  // 3) For body or html element, i.e. in case of the html node - it will return itself  //  // but those exceptions were never presented as a real life use-cases  // and might be considered as more preferable results.  //  // This logic, however, is not guaranteed and can change at any point in the future  offsetParent: function() {   return this.map( function() {    var offsetParent = this.offsetParent;
while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {     offsetParent = offsetParent.offsetParent;    }
return offsetParent || documentElement;   } );  } } );
// Create scrollLeft and scrollTop methods jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {  var top = "pageYOffset" === prop;
jQuery.fn[ method ] = function( val ) {   return access( this, function( elem, method, val ) {
// Coalesce documents and windows    var win;    if ( jQuery.isWindow( elem ) ) {     win = elem;    } else if ( elem.nodeType === 9 ) {     win = elem.defaultView;    }
if ( val === undefined ) { return win ? win[ prop ] : elem[ method ];    }
if ( win ) {     win.scrollTo(      !top ? val : win.pageXOffset,      top ? val : win.pageYOffset     );
} else {     elem[ method ] = val;    }   }, method, val, arguments.length );  }; } );
// Support: Safari <=7 - 9.1, Chrome <=37 - 49 // Add the top/left cssHooks using jQuery.fn.position // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084 // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347 // getComputedStyle returns percent when specified for top/left/bottom/right; // rather than make the css module depend on the offset module, just check for it here jQuery.each( [ "top", "left" ], function( i, prop ) {  jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,   function( elem, computed ) {    if ( computed ) {     computed = curCSS( elem, prop );
// If curCSS returns percentage, fallback to offset     return rnumnonpx.test( computed ) ?      jQuery( elem ).position()[ prop ] + "px" :      computed;    }   }  ); } );
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {  jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },   function( defaultExtra, funcName ) {
// Margin is only for outerHeight, outerWidth   jQuery.fn[ funcName ] = function( margin, value ) {    var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),     extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
return access( this, function( elem, type, value ) {     var doc;
if ( jQuery.isWindow( elem ) ) {
// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)      return funcName.indexOf( "outer" ) === 0 ?       elem[ "inner" + name ] :       elem.document.documentElement[ "client" + name ];     }
// Get document width or height     if ( elem.nodeType === 9 ) {      doc = elem.documentElement;
// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],      // whichever is greatest      return Math.max(       elem.body[ "scroll" + name ], doc[ "scroll" + name ],       elem.body[ "offset" + name ], doc[ "offset" + name ],       doc[ "client" + name ]      );     }
return value === undefined ?
// Get width or height on the element, requesting but not forcing parseFloat      jQuery.css( elem, type, extra ) :
// Set width or height on the element      jQuery.style( elem, type, value, extra );    }, type, chainable ? margin : undefined, chainable );   };  } ); } );
jQuery.fn.extend( {
bind: function( types, data, fn ) {   return this.on( types, null, data, fn );  },  unbind: function( types, fn ) {   return this.off( types, null, fn );  },
delegate: function( selector, types, data, fn ) {   return this.on( types, selector, data, fn );  },  undelegate: function( selector, types, fn ) {
// ( namespace ) or ( selector, types [, fn] )   return arguments.length === 1 ?    this.off( selector, "**" ) :    this.off( types, selector || "**", fn );  } } );
jQuery.holdReady = function( hold ) {  if ( hold ) {   jQuery.readyWait++;  } else {   jQuery.ready( true );  } }; jQuery.isArray = Array.isArray; jQuery.parseJSON = JSON.parse; jQuery.nodeName = nodeName;
// Register as a named AMD module, since jQuery can be concatenated with other // files that may use define, but not via a proper concatenation script that // understands anonymous AMD modules. A named AMD is safest and most robust // way to register. Lowercase jquery is used because AMD module names are // derived from file names, and jQuery is normally delivered in a lowercase // file name. Do this after creating the global so that if an AMD module wants // to call noConflict to hide this version of jQuery, it will work.
// Note that for maximum portability, libraries that are not jQuery should // declare themselves as anonymous modules, and avoid setting a global if an // AMD loader is present. jQuery is a special case. For more information, see // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
if ( typeof define === "function" && define.amd ) {  define( "jquery", [], function() {   return jQuery;  } ); }
var
// Map over jQuery in case of overwrite  _jQuery = window.jQuery,
// Map over the $ in case of overwrite  _$ = window.$;
jQuery.noConflict = function( deep ) {  if ( window.$ === jQuery ) {   window.$ = _$;  }
if ( deep && window.jQuery === jQuery ) {   window.jQuery = _jQuery;  }
return jQuery; };
// Expose jQuery and $ identifiers, even in AMD // (#7102#comment:10, https://github.com/jquery/jquery/pull/557 ) // and CommonJS for browser emulators (#13566) if ( !noGlobal ) {  window.jQuery = window.$ = jQuery; }
return jQuery; } ); </script>
<script>/* FileSaver.js * A saveAs() FileSaver implementation. * 1.3.2 * 2016-06-16 18:25:19 * * By Eli Grey, http://eligrey.com * License: MIT *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md */
/*global self */ /*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs = saveAs || (function(view) {  "use strict";  // IE <10 is explicitly unsupported  if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {   return;  }  var     doc = view.document     // only get URL when necessary in case Blob.js hasn't overridden it yet   , get_URL = function() {    return view.URL || view.webkitURL || view;   }   , save_link = doc.createElementNS(" http://www.w3.org/1999/xhtml ", "a")   , can_use_save_link = "download" in save_link   , click = function(node) {    var event = new MouseEvent("click");    node.dispatchEvent(event);   }   , is_safari = /constructor/i.test(view.HTMLElement) || view.safari   , is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)   , throw_outside = function(ex) {    (view.setImmediate || view.setTimeout)(function() {     throw ex;    }, 0);   }   , force_saveable_type = "application/octet-stream"   // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to   , arbitrary_revoke_timeout = 1000 * 40 // in ms   , revoke = function(file) {    var revoker = function() {     if (typeof file === "string") { // file is an object URL      get_URL().revokeObjectURL(file);     } else { // file is a File      file.remove();     }    };    setTimeout(revoker, arbitrary_revoke_timeout);   }   , dispatch = function(filesaver, event_types, event) {    event_types = [].concat(event_types);    var i = event_types.length;    while (i--) {     var listener = filesaver["on" + event_types[i]];     if (typeof listener === "function") {      try {       listener.call(filesaver, event || filesaver);      } catch (ex) {       throw_outside(ex);      }     }    }   }   , auto_bom = function(blob) {    // prepend BOM for UTF-8 XML and text/* types (including HTML)    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF    if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {     return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});    }    return blob;   }   , FileSaver = function(blob, name, no_auto_bom) {    if (!no_auto_bom) {     blob = auto_bom(blob);    }    // First try a.download, then web filesystem, then object URLs    var       filesaver = this     , type = blob.type     , force = type === force_saveable_type     , object_url     , dispatch_all = function() {      dispatch(filesaver, "writestart progress write writeend".split(" "));     }     // on any filesys errors revert to saving with object URLs     , fs_error = function() {      if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {       // Safari doesn't allow downloading of blob urls       var reader = new FileReader();       reader.onloadend = function() {        var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');        var popup = view.open(url, '_blank');        if(!popup) view.location.href = url;        url=undefined; // release reference before dispatching        filesaver.readyState = filesaver.DONE;        dispatch_all();       };       reader.readAsDataURL(blob);       filesaver.readyState = filesaver.INIT;       return;      }      // don't create more object URLs than needed      if (!object_url) {       object_url = get_URL().createObjectURL(blob);      }      if (force) {       view.location.href = object_url;      } else {       var opened = view.open(object_url, "_blank");       if (!opened) {        // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html view.location.href = object_url;       }      }      filesaver.readyState = filesaver.DONE;      dispatch_all();      revoke(object_url);     }    ;    filesaver.readyState = filesaver.INIT;
if (can_use_save_link) {     object_url = get_URL().createObjectURL(blob);     setTimeout(function() {      save_link.href = object_url;      save_link.download = name;      click(save_link);      dispatch_all();      revoke(object_url);      filesaver.readyState = filesaver.DONE;     });     return;    }
fs_error();   }   , FS_proto = FileSaver.prototype   , saveAs = function(blob, name, no_auto_bom) {    return new FileSaver(blob, name || blob.name || "download", no_auto_bom);   }  ;  // IE 10+ (native saveAs)  if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {   return function(blob, name, no_auto_bom) {    name = name || blob.name || "download";
if (!no_auto_bom) {     blob = auto_bom(blob);    }    return navigator.msSaveOrOpenBlob(blob, name);   };  }
FS_proto.abort = function(){};  FS_proto.readyState = FS_proto.INIT = 0;  FS_proto.WRITING = 1;  FS_proto.DONE = 2;
FS_proto.error =  FS_proto.onwritestart =  FS_proto.onprogress =  FS_proto.onwrite =  FS_proto.onabort =  FS_proto.onerror =  FS_proto.onwriteend =   null;
return saveAs; }(     typeof self !== "undefined" && self  || typeof window !== "undefined" && window  || this.content )); // `self` is undefined in Firefox for Android content script context // while `this` is nsIContentFrameMessageManager // with an attribute `content` that corresponds to the window
if (typeof module !== "undefined" && module.exports) {
module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
define("FileSaver.js", function() {    return saveAs;  });
} </script>
<script>var URI=function(){function parse(uriStr){var m=(""+uriStr).match(URI_RE_);if(!m){return null}return new URI(nullIfAbsent(m[1]),nullIfAbsent(m[2]),nullIfAbsent(m[3]),nullIfAbsent(m[4]),nullIfAbsent(m[5]),nullIfAbsent(m[6]),nullIfAbsent(m[7]))}function create(scheme,credentials,domain,port,path,query,fragment){var uri=new URI(encodeIfExists2(scheme,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),encodeIfExists2(credentials,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),encodeIfExists(domain),port>0?port.toString():null,encodeIfExists2(path,URI_DISALLOWED_IN_PATH_),null,encodeIfExists(fragment));if(query){if("string"===typeof query){uri.setRawQuery(query.replace(/[^?&=0-9A-Za-z_\-~.%]/g,encodeOne))}else{uri.setAllParameters(query)}}return uri}function encodeIfExists(unescapedPart){if("string"==typeof unescapedPart){return encodeURIComponent(unescapedPart)}return null}function encodeIfExists2(unescapedPart,extra){if("string"==typeof unescapedPart){return encodeURI(unescapedPart).replace(extra,encodeOne)}return null}function encodeOne(ch){var n=ch.charCodeAt(0);return"%"+"0123456789ABCDEF".charAt(n>>4&15)+"0123456789ABCDEF".charAt(n&15)}function normPath(path){return path.replace(/(^|\/)\.(?:\/|$)/g,"$1").replace(/\/{2,}/g,"/")}var PARENT_DIRECTORY_HANDLER=new RegExp(""+"(/|^)"+"(?:[^./][^/]*|\\.{2,}(?:[^./][^/]*)|\\.{3,}[^/]*)"+"/\\.\\.(?:/|$)");var PARENT_DIRECTORY_HANDLER_RE=new RegExp(PARENT_DIRECTORY_HANDLER);var EXTRA_PARENT_PATHS_RE=/^(?:\.\.\/)*(?:\.\.$)?/;function collapse_dots(path){if(path===null){return null}var p=normPath(path);var r=PARENT_DIRECTORY_HANDLER_RE;for(var q;(q=p.replace(r,"$1"))!=p;p=q){}return p}function resolve(baseUri,relativeUri){var absoluteUri=baseUri.clone();var overridden=relativeUri.hasScheme();if(overridden){absoluteUri.setRawScheme(relativeUri.getRawScheme())}else{overridden=relativeUri.hasCredentials()}if(overridden){absoluteUri.setRawCredentials(relativeUri.getRawCredentials())}else{overridden=relativeUri.hasDomain()}if(overridden){absoluteUri.setRawDomain(relativeUri.getRawDomain())}else{overridden=relativeUri.hasPort()}var rawPath=relativeUri.getRawPath();var simplifiedPath=collapse_dots(rawPath);if(overridden){absoluteUri.setPort(relativeUri.getPort());simplifiedPath=simplifiedPath&&simplifiedPath.replace(EXTRA_PARENT_PATHS_RE,"")}else{overridden=!!rawPath;if(overridden){if(simplifiedPath.charCodeAt(0)!==47){var absRawPath=collapse_dots(absoluteUri.getRawPath()||"").replace(EXTRA_PARENT_PATHS_RE,"");var slash=absRawPath.lastIndexOf("/")+1;simplifiedPath=collapse_dots((slash?absRawPath.substring(0,slash):"")+collapse_dots(rawPath)).replace(EXTRA_PARENT_PATHS_RE,"")}}else{simplifiedPath=simplifiedPath&&simplifiedPath.replace(EXTRA_PARENT_PATHS_RE,"");if(simplifiedPath!==rawPath){absoluteUri.setRawPath(simplifiedPath)}}}if(overridden){absoluteUri.setRawPath(simplifiedPath)}else{overridden=relativeUri.hasQuery()}if(overridden){absoluteUri.setRawQuery(relativeUri.getRawQuery())}else{overridden=relativeUri.hasFragment()}if(overridden){absoluteUri.setRawFragment(relativeUri.getRawFragment())}return absoluteUri}function URI(rawScheme,rawCredentials,rawDomain,port,rawPath,rawQuery,rawFragment){this.scheme_=rawScheme;this.credentials_=rawCredentials;this.domain_=rawDomain;this.port_=port;this.path_=rawPath;this.query_=rawQuery;this.fragment_=rawFragment;this.paramCache_=null}URI.prototype.toString=function(){var out=[];if(null!==this.scheme_){out.push(this.scheme_,":")}if(null!==this.domain_){out.push("//");if(null!==this.credentials_){out.push(this.credentials_,"@")}out.push(this.domain_);if(null!==this.port_){out.push(":",this.port_.toString())}}if(null!==this.path_){out.push(this.path_)}if(null!==this.query_){out.push("?",this.query_)}if(null!==this.fragment_){out.push("#",this.fragment_)}return out.join("")};URI.prototype.clone=function(){return new URI(this.scheme_,this.credentials_,this.domain_,this.port_,this.path_,this.query_,this.fragment_)};URI.prototype.getScheme=function(){return this.scheme_&&decodeURIComponent(this.scheme_).toLowerCase()};URI.prototype.getRawScheme=function(){return this.scheme_};URI.prototype.setScheme=function(newScheme){this.scheme_=encodeIfExists2(newScheme,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);return this};URI.prototype.setRawScheme=function(newScheme){this.scheme_=newScheme?newScheme:null;return this};URI.prototype.hasScheme=function(){return null!==this.scheme_};URI.prototype.getCredentials=function(){return this.credentials_&&decodeURIComponent(this.credentials_)};URI.prototype.getRawCredentials=function(){return this.credentials_};URI.prototype.setCredentials=function(newCredentials){this.credentials_=encodeIfExists2(newCredentials,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);return this};URI.prototype.setRawCredentials=function(newCredentials){this.credentials_=newCredentials?newCredentials:null;return this};URI.prototype.hasCredentials=function(){return null!==this.credentials_};URI.prototype.getDomain=function(){return this.domain_&&decodeURIComponent(this.domain_)};URI.prototype.getRawDomain=function(){return this.domain_};URI.prototype.setDomain=function(newDomain){return this.setRawDomain(newDomain&&encodeURIComponent(newDomain))};URI.prototype.setRawDomain=function(newDomain){this.domain_=newDomain?newDomain:null;return this.setRawPath(this.path_)};URI.prototype.hasDomain=function(){return null!==this.domain_};URI.prototype.getPort=function(){return this.port_&&decodeURIComponent(this.port_)};URI.prototype.setPort=function(newPort){if(newPort){newPort=Number(newPort);if(newPort!==(newPort&65535)){throw new Error("Bad port number "+newPort)}this.port_=""+newPort}else{this.port_=null}return this};URI.prototype.hasPort=function(){return null!==this.port_};URI.prototype.getPath=function(){return this.path_&&decodeURIComponent(this.path_)};URI.prototype.getRawPath=function(){return this.path_};URI.prototype.setPath=function(newPath){return this.setRawPath(encodeIfExists2(newPath,URI_DISALLOWED_IN_PATH_))};URI.prototype.setRawPath=function(newPath){if(newPath){newPath=String(newPath);this.path_=!this.domain_||/^\//.test(newPath)?newPath:"/"+newPath}else{this.path_=null}return this};URI.prototype.hasPath=function(){return null!==this.path_};URI.prototype.getQuery=function(){return this.query_&&decodeURIComponent(this.query_).replace(/\+/g," ")};URI.prototype.getRawQuery=function(){return this.query_};URI.prototype.setQuery=function(newQuery){this.paramCache_=null;this.query_=encodeIfExists(newQuery);return this};URI.prototype.setRawQuery=function(newQuery){this.paramCache_=null;this.query_=newQuery?newQuery:null;return this};URI.prototype.hasQuery=function(){return null!==this.query_};URI.prototype.setAllParameters=function(params){if(typeof params==="object"){if(!(params instanceof Array)&&(params instanceof Object||Object.prototype.toString.call(params)!=="[object Array]")){var newParams=[];var i=-1;for(var k in params){var v=params[k];if("string"===typeof v){newParams[++i]=k;newParams[++i]=v}}params=newParams}}this.paramCache_=null;var queryBuf=[];var separator="";for(var j=0;j<params.length;){var k=params[j++];var v=params[j++];queryBuf.push(separator,encodeURIComponent(k.toString()));separator="&";if(v){queryBuf.push("=",encodeURIComponent(v.toString()))}}this.query_=queryBuf.join("");return this};URI.prototype.checkParameterCache_=function(){if(!this.paramCache_){var q=this.query_;if(!q){this.paramCache_=[]}else{var cgiParams=q.split(/[&\?]/);var out=[];var k=-1;for(var i=0;i<cgiParams.length;++i){var m=cgiParams[i].match(/^([^=]*)(?:=(.*))?$/);out[++k]=decodeURIComponent(m[1]).replace(/\+/g," ");out[++k]=decodeURIComponent(m[2]||"").replace(/\+/g," ")}this.paramCache_=out}}};URI.prototype.setParameterValues=function(key,values){if(typeof values==="string"){values=[values]}this.checkParameterCache_();var newValueIndex=0;var pc=this.paramCache_;var params=[];for(var i=0,k=0;i<pc.length;i+=2){if(key===pc[i]){if(newValueIndex<values.length){params.push(key,values[newValueIndex++])}}else{params.push(pc[i],pc[i+1])}}while(newValueIndex<values.length){params.push(key,values[newValueIndex++])}this.setAllParameters(params);return this};URI.prototype.removeParameter=function(key){return this.setParameterValues(key,[])};URI.prototype.getAllParameters=function(){this.checkParameterCache_();return this.paramCache_.slice(0,this.paramCache_.length)};URI.prototype.getParameterValues=function(paramNameUnescaped){this.checkParameterCache_();var values=[];for(var i=0;i<this.paramCache_.length;i+=2){if(paramNameUnescaped===this.paramCache_[i]){values.push(this.paramCache_[i+1])}}return values};URI.prototype.getParameterMap=function(paramNameUnescaped){this.checkParameterCache_();var paramMap={};for(var i=0;i<this.paramCache_.length;i+=2){var key=this.paramCache_[i++],value=this.paramCache_[i++];if(!(key in paramMap)){paramMap[key]=[value]}else{paramMap[key].push(value)}}return paramMap};URI.prototype.getParameterValue=function(paramNameUnescaped){this.checkParameterCache_();for(var i=0;i<this.paramCache_.length;i+=2){if(paramNameUnescaped===this.paramCache_[i]){return this.paramCache_[i+1]}}return null};URI.prototype.getFragment=function(){return this.fragment_&&decodeURIComponent(this.fragment_)};URI.prototype.getRawFragment=function(){return this.fragment_};URI.prototype.setFragment=function(newFragment){this.fragment_=newFragment?encodeURIComponent(newFragment):null;return this};URI.prototype.setRawFragment=function(newFragment){this.fragment_=newFragment?newFragment:null;return this};URI.prototype.hasFragment=function(){return null!==this.fragment_};function nullIfAbsent(matchPart){return"string"==typeof matchPart&&matchPart.length>0?matchPart:null}var URI_RE_=new RegExp("^"+"(?:"+"([^:/?#]+)"+":)?"+"(?://"+"(?:([^/?#]*)@)?"+"([^/?#:@]*)"+"(?::([0-9]+))?"+")?"+"([^?#]+)?"+"(?:\\?([^#]*))?"+"(?:#(.*))?"+"$");var URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_=/[#\/\?@]/g;var URI_DISALLOWED_IN_PATH_=/[\#\?]/g;URI.parse=parse;URI.create=create;URI.resolve=resolve;URI.collapse_dots=collapse_dots;URI.utils={mimeTypeOf:function(uri){var uriObj=parse(uri);if(/\.html$/.test(uriObj.getPath())){return"text/html"}else{return"application/javascript"}},resolve:function(base,uri){if(base){return resolve(parse(base),parse(uri)).toString()}else{return""+uri}}};return URI}();if(typeof window!=="undefined"){window["URI"]=URI}var html4={};html4.atype={NONE:0,URI:1,URI_FRAGMENT:11,SCRIPT:2,STYLE:3,HTML:12,ID:4,IDREF:5,IDREFS:6,GLOBAL_NAME:7,LOCAL_NAME:8,CLASSES:9,FRAME_TARGET:10,MEDIA_QUERY:13};html4["atype"]=html4.atype;html4.ATTRIBS={"*::class":9,"*::dir":0,"*::draggable":0,"*::hidden":0,"*::id":4,"*::inert":0,"*::itemprop":0,"*::itemref":6,"*::itemscope":0,"*::lang":0,"*::onblur":2,"*::onchange":2,"*::onclick":2,"*::ondblclick":2,"*::onerror":2,"*::onfocus":2,"*::onkeydown":2,"*::onkeypress":2,"*::onkeyup":2,"*::onload":2,"*::onmousedown":2,"*::onmousemove":2,"*::onmouseout":2,"*::onmouseover":2,"*::onmouseup":2,"*::onreset":2,"*::onscroll":2,"*::onselect":2,"*::onsubmit":2,"*::ontouchcancel":2,"*::ontouchend":2,"*::ontouchenter":2,"*::ontouchleave":2,"*::ontouchmove":2,"*::ontouchstart":2,"*::onunload":2,"*::spellcheck":0,"*::style":3,"*::tabindex":0,"*::title":0,"*::translate":0,"a::accesskey":0,"a::coords":0,"a::href":1,"a::hreflang":0,"a::name":7,"a::onblur":2,"a::onfocus":2,"a::shape":0,"a::target":10,"a::type":0,"area::accesskey":0,"area::alt":0,"area::coords":0,"area::href":1,"area::nohref":0,"area::onblur":2,"area::onfocus":2,"area::shape":0,"area::target":10,"audio::controls":0,"audio::loop":0,"audio::mediagroup":5,"audio::muted":0,"audio::preload":0,"audio::src":1,"bdo::dir":0,"blockquote::cite":1,"br::clear":0,"button::accesskey":0,"button::disabled":0,"button::name":8,"button::onblur":2,"button::onfocus":2,"button::type":0,"button::value":0,"canvas::height":0,"canvas::width":0,"caption::align":0,"col::align":0,"col::char":0,"col::charoff":0,"col::span":0,"col::valign":0,"col::width":0,"colgroup::align":0,"colgroup::char":0,"colgroup::charoff":0,"colgroup::span":0,"colgroup::valign":0,"colgroup::width":0,"command::checked":0,"command::command":5,"command::disabled":0,"command::icon":1,"command::label":0,"command::radiogroup":0,"command::type":0,"data::value":0,"del::cite":1,"del::datetime":0,"details::open":0,"dir::compact":0,"div::align":0,"dl::compact":0,"fieldset::disabled":0,"font::color":0,"font::face":0,"font::size":0,"form::accept":0,"form::action":1,"form::autocomplete":0,"form::enctype":0,"form::method":0,"form::name":7,"form::novalidate":0,"form::onreset":2,"form::onsubmit":2,"form::target":10,"h1::align":0,"h2::align":0,"h3::align":0,"h4::align":0,"h5::align":0,"h6::align":0,"hr::align":0,"hr::noshade":0,"hr::size":0,"hr::width":0,"iframe::align":0,"iframe::frameborder":0,"iframe::height":0,"iframe::marginheight":0,"iframe::marginwidth":0,"iframe::width":0,"img::align":0,"img::alt":0,"img::border":0,"img::height":0,"img::hspace":0,"img::ismap":0,"img::name":7,"img::src":1,"img::usemap":11,"img::vspace":0,"img::width":0,"input::accept":0,"input::accesskey":0,"input::align":0,"input::alt":0,"input::autocomplete":0,"input::checked":0,"input::disabled":0,"input::inputmode":0,"input::ismap":0,"input::list":5,"input::max":0,"input::maxlength":0,"input::min":0,"input::multiple":0,"input::name":8,"input::onblur":2,"input::onchange":2,"input::onfocus":2,"input::onselect":2,"input::pattern":0,"input::placeholder":0,"input::readonly":0,"input::required":0,"input::size":0,"input::src":1,"input::step":0,"input::type":0,"input::usemap":11,"input::value":0,"ins::cite":1,"ins::datetime":0,"label::accesskey":0,"label::for":5,"label::onblur":2,"label::onfocus":2,"legend::accesskey":0,"legend::align":0,"li::type":0,"li::value":0,"map::name":7,"menu::compact":0,"menu::label":0,"menu::type":0,"meter::high":0,"meter::low":0,"meter::max":0,"meter::min":0,"meter::optimum":0,"meter::value":0,"ol::compact":0,"ol::reversed":0,"ol::start":0,"ol::type":0,"optgroup::disabled":0,"optgroup::label":0,"option::disabled":0,"option::label":0,"option::selected":0,"option::value":0,"output::for":6,"output::name":8,"p::align":0,"pre::width":0,"progress::max":0,"progress::min":0,"progress::value":0,"q::cite":1,"select::autocomplete":0,"select::disabled":0,"select::multiple":0,"select::name":8,"select::onblur":2,"select::onchange":2,"select::onfocus":2,"select::required":0,"select::size":0,"source::type":0,"table::align":0,"table::bgcolor":0,"table::border":0,"table::cellpadding":0,"table::cellspacing":0,"table::frame":0,"table::rules":0,"table::summary":0,"table::width":0,"tbody::align":0,"tbody::char":0,"tbody::charoff":0,"tbody::valign":0,"td::abbr":0,"td::align":0,"td::axis":0,"td::bgcolor":0,"td::char":0,"td::charoff":0,"td::colspan":0,"td::headers":6,"td::height":0,"td::nowrap":0,"td::rowspan":0,"td::scope":0,"td::valign":0,"td::width":0,"textarea::accesskey":0,"textarea::autocomplete":0,"textarea::cols":0,"textarea::disabled":0,"textarea::inputmode":0,"textarea::name":8,"textarea::onblur":2,"textarea::onchange":2,"textarea::onfocus":2,"textarea::onselect":2,"textarea::placeholder":0,"textarea::readonly":0,"textarea::required":0,"textarea::rows":0,"textarea::wrap":0,"tfoot::align":0,"tfoot::char":0,"tfoot::charoff":0,"tfoot::valign":0,"th::abbr":0,"th::align":0,"th::axis":0,"th::bgcolor":0,"th::char":0,"th::charoff":0,"th::colspan":0,"th::headers":6,"th::height":0,"th::nowrap":0,"th::rowspan":0,"th::scope":0,"th::valign":0,"th::width":0,"thead::align":0,"thead::char":0,"thead::charoff":0,"thead::valign":0,"tr::align":0,"tr::bgcolor":0,"tr::char":0,"tr::charoff":0,"tr::valign":0,"track::default":0,"track::kind":0,"track::label":0,"track::srclang":0,"ul::compact":0,"ul::type":0,"video::controls":0,"video::height":0,"video::loop":0,"video::mediagroup":5,"video::muted":0,"video::poster":1,"video::preload":0,"video::src":1,"video::width":0};html4["ATTRIBS"]=html4.ATTRIBS;html4.eflags={OPTIONAL_ENDTAG:1,EMPTY:2,CDATA:4,RCDATA:8,UNSAFE:16,FOLDABLE:32,SCRIPT:64,STYLE:128,VIRTUALIZED:256};html4["eflags"]=html4.eflags;html4.ELEMENTS={a:0,abbr:0,acronym:0,address:0,applet:272,area:2,article:0,aside:0,audio:0,b:0,base:274,basefont:274,bdi:0,bdo:0,big:0,blockquote:0,body:305,br:2,button:0,canvas:0,caption:0,center:0,cite:0,code:0,col:2,colgroup:1,command:2,data:0,datalist:0,dd:1,del:0,details:0,dfn:0,dialog:272,dir:0,div:0,dl:0,dt:1,em:0,fieldset:0,figcaption:0,figure:0,font:0,footer:0,form:0,frame:274,frameset:272,h1:0,h2:0,h3:0,h4:0,h5:0,h6:0,head:305,header:0,hgroup:0,hr:2,html:305,i:0,iframe:4,img:2,input:2,ins:0,isindex:274,kbd:0,keygen:274,label:0,legend:0,li:1,link:274,map:0,mark:0,menu:0,meta:274,meter:0,nav:0,nobr:0,noembed:276,noframes:276,noscript:276,object:272,ol:0,optgroup:0,option:1,output:0,p:1,param:274,pre:0,progress:0,q:0,s:0,samp:0,script:84,section:0,select:0,small:0,source:2,span:0,strike:0,strong:0,style:148,sub:0,summary:0,sup:0,table:0,tbody:1,td:1,textarea:8,tfoot:1,th:1,thead:1,time:0,title:280,tr:1,track:2,tt:0,u:0,ul:0,"var":0,video:0,wbr:2};html4["ELEMENTS"]=html4.ELEMENTS;html4.ELEMENT_DOM_INTERFACES={a:"HTMLAnchorElement",abbr:"HTMLElement",acronym:"HTMLElement",address:"HTMLElement",applet:"HTMLAppletElement",area:"HTMLAreaElement",article:"HTMLElement",aside:"HTMLElement",audio:"HTMLAudioElement",b:"HTMLElement",base:"HTMLBaseElement",basefont:"HTMLBaseFontElement",bdi:"HTMLElement",bdo:"HTMLElement",big:"HTMLElement",blockquote:"HTMLQuoteElement",body:"HTMLBodyElement",br:"HTMLBRElement",button:"HTMLButtonElement",canvas:"HTMLCanvasElement",caption:"HTMLTableCaptionElement",center:"HTMLElement",cite:"HTMLElement",code:"HTMLElement",col:"HTMLTableColElement",colgroup:"HTMLTableColElement",command:"HTMLCommandElement",data:"HTMLElement",datalist:"HTMLDataListElement",dd:"HTMLElement",del:"HTMLModElement",details:"HTMLDetailsElement",dfn:"HTMLElement",dialog:"HTMLDialogElement",dir:"HTMLDirectoryElement",div:"HTMLDivElement",dl:"HTMLDListElement",dt:"HTMLElement",em:"HTMLElement",fieldset:"HTMLFieldSetElement",figcaption:"HTMLElement",figure:"HTMLElement",font:"HTMLFontElement",footer:"HTMLElement",form:"HTMLFormElement",frame:"HTMLFrameElement",frameset:"HTMLFrameSetElement",h1:"HTMLHeadingElement",h2:"HTMLHeadingElement",h3:"HTMLHeadingElement",h4:"HTMLHeadingElement",h5:"HTMLHeadingElement",h6:"HTMLHeadingElement",head:"HTMLHeadElement",header:"HTMLElement",hgroup:"HTMLElement",hr:"HTMLHRElement",html:"HTMLHtmlElement",i:"HTMLElement",iframe:"HTMLIFrameElement",img:"HTMLImageElement",input:"HTMLInputElement",ins:"HTMLModElement",isindex:"HTMLUnknownElement",kbd:"HTMLElement",keygen:"HTMLKeygenElement",label:"HTMLLabelElement",legend:"HTMLLegendElement",li:"HTMLLIElement",link:"HTMLLinkElement",map:"HTMLMapElement",mark:"HTMLElement",menu:"HTMLMenuElement",meta:"HTMLMetaElement",meter:"HTMLMeterElement",nav:"HTMLElement",nobr:"HTMLElement",noembed:"HTMLElement",noframes:"HTMLElement",noscript:"HTMLElement",object:"HTMLObjectElement",ol:"HTMLOListElement",optgroup:"HTMLOptGroupElement",option:"HTMLOptionElement",output:"HTMLOutputElement",p:"HTMLParagraphElement",param:"HTMLParamElement",pre:"HTMLPreElement",progress:"HTMLProgressElement",q:"HTMLQuoteElement",s:"HTMLElement",samp:"HTMLElement",script:"HTMLScriptElement",section:"HTMLElement",select:"HTMLSelectElement",small:"HTMLElement",source:"HTMLSourceElement",span:"HTMLSpanElement",strike:"HTMLElement",strong:"HTMLElement",style:"HTMLStyleElement",sub:"HTMLElement",summary:"HTMLElement",sup:"HTMLElement",table:"HTMLTableElement",tbody:"HTMLTableSectionElement",td:"HTMLTableDataCellElement",textarea:"HTMLTextAreaElement",tfoot:"HTMLTableSectionElement",th:"HTMLTableHeaderCellElement",thead:"HTMLTableSectionElement",time:"HTMLTimeElement",title:"HTMLTitleElement",tr:"HTMLTableRowElement",track:"HTMLTrackElement",tt:"HTMLElement",u:"HTMLElement",ul:"HTMLUListElement","var":"HTMLElement",video:"HTMLVideoElement",wbr:"HTMLElement"};html4["ELEMENT_DOM_INTERFACES"]=html4.ELEMENT_DOM_INTERFACES;html4.ueffects={NOT_LOADED:0,SAME_DOCUMENT:1,NEW_DOCUMENT:2};html4["ueffects"]=html4.ueffects;html4.URIEFFECTS={"a::href":2,"area::href":2,"audio::src":1,"blockquote::cite":0,"command::icon":1,"del::cite":0,"form::action":2,"img::src":1,"input::src":1,"ins::cite":0,"q::cite":0,"video::poster":1,"video::src":1};html4["URIEFFECTS"]=html4.URIEFFECTS;html4.ltypes={UNSANDBOXED:2,SANDBOXED:1,DATA:0};html4["ltypes"]=html4.ltypes;html4.LOADERTYPES={"a::href":2,"area::href":2,"audio::src":2,"blockquote::cite":2,"command::icon":1,"del::cite":2,"form::action":2,"img::src":1,"input::src":1,"ins::cite":2,"q::cite":2,"video::poster":1,"video::src":2};html4["LOADERTYPES"]=html4.LOADERTYPES;if(typeof window!=="undefined"){window["html4"]=html4}if("I".toLowerCase()!=="i"){throw"I/i problem"}var defs={};defs.TagPolicyDecision;defs.TagPolicy;var html=function(html4){var parseCssDeclarations,sanitizeCssProperty,cssSchema;if("undefined"!==typeof window){parseCssDeclarations=window["parseCssDeclarations"];sanitizeCssProperty=window["sanitizeCssProperty"];cssSchema=window["cssSchema"]}var ENTITIES={lt:"<",LT:"<",gt:">",GT:">",amp:"&",AMP:"&",quot:'"',apos:"'",nbsp:" "};var decimalEscapeRe=/^#(\d+)$/;var hexEscapeRe=/^#x([0-9A-Fa-f]+)$/;var safeEntityNameRe=/^[A-Za-z][A-za-z0-9]+$/;var entityLookupElement="undefined"!==typeof window&&window["document"]?window["document"].createElement("textarea"):null;function lookupEntity(name){if(ENTITIES.hasOwnProperty(name)){return ENTITIES[name]}var m=name.match(decimalEscapeRe);if(m){return String.fromCharCode(parseInt(m[1],10))}else if(!!(m=name.match(hexEscapeRe))){return String.fromCharCode(parseInt(m[1],16))}else if(entityLookupElement&&safeEntityNameRe.test(name)){entityLookupElement.innerHTML="&"+name+";";var text=entityLookupElement.textContent;ENTITIES[name]=text;return text}else{return"&"+name+";"}}function decodeOneEntity(_,name){return lookupEntity(name)}var nulRe=/\0/g;function stripNULs(s){return s.replace(nulRe,"")}var ENTITY_RE_1=/&(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/g;var ENTITY_RE_2=/^(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/;function unescapeEntities(s){return s.replace(ENTITY_RE_1,decodeOneEntity)}var ampRe=/&/g;var looseAmpRe=/&([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi;var ltRe=/[<]/g;var gtRe=/>/g;var quotRe=/\"/g;function escapeAttrib(s){return(""+s).replace(ampRe,"&").replace(ltRe,"<").replace(gtRe,">").replace(quotRe,""")}function normalizeRCData(rcdata){return rcdata.replace(looseAmpRe,"&$1").replace(ltRe,"<").replace(gtRe,">")}var ATTR_RE=new RegExp("^\\s*"+"([-.:\\w]+)"+"(?:"+("\\s*(=)\\s*"+"("+('(")[^"]*("|$)'+"|"+"(')[^']*('|$)"+"|"+"(?=[a-z][-\\w]*\\s*=)"+"|"+"[^\"'\\s]*")+")")+")?","i");var splitWillCapture="a,b".split(/(,)/).length===3;var EFLAGS_TEXT=html4.eflags["CDATA"]|html4.eflags["RCDATA"];function makeSaxParser(handler){var hcopy={cdata:handler.cdata||handler["cdata"],comment:handler.comment||handler["comment"],endDoc:handler.endDoc||handler["endDoc"],endTag:handler.endTag||handler["endTag"],pcdata:handler.pcdata||handler["pcdata"],rcdata:handler.rcdata||handler["rcdata"],startDoc:handler.startDoc||handler["startDoc"],startTag:handler.startTag||handler["startTag"]};return function(htmlText,param){return parse(htmlText,hcopy,param)}}var continuationMarker={};function parse(htmlText,handler,param){var m,p,tagName;var parts=htmlSplit(htmlText);var state={noMoreGT:false,noMoreEndComments:false};parseCPS(handler,parts,0,state,param)}function continuationMaker(h,parts,initial,state,param){return function(){parseCPS(h,parts,initial,state,param)}}function parseCPS(h,parts,initial,state,param){try{if(h.startDoc&&initial==0){h.startDoc(param)}var m,p,tagName;for(var pos=initial,end=parts.length;pos<end;){var current=parts[pos++];var next=parts[pos];switch(current){case"&":if(ENTITY_RE_2.test(next)){if(h.pcdata){h.pcdata("&"+next,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}pos++}else{if(h.pcdata){h.pcdata("&",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case"</":if(m=/^([-\w:]+)[^\'\"]*/.exec(next)){if(m[0].length===next.length&&parts[pos+1]===">"){pos+=2;tagName=m[1].toLowerCase();if(h.endTag){h.endTag(tagName,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}else{pos=parseEndTag(parts,pos,h,param,continuationMarker,state)}}else{if(h.pcdata){h.pcdata("</",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case"<":if(m=/^([-\w:]+)\s*\/?/.exec(next)){if(m[0].length===next.length&&parts[pos+1]===">"){pos+=2;tagName=m[1].toLowerCase();if(h.startTag){h.startTag(tagName,[],param,continuationMarker,continuationMaker(h,parts,pos,state,param))}var eflags=html4.ELEMENTS[tagName];if(eflags&EFLAGS_TEXT){var tag={name:tagName,next:pos,eflags:eflags};pos=parseText(parts,tag,h,param,continuationMarker,state)}}else{pos=parseStartTag(parts,pos,h,param,continuationMarker,state)}}else{if(h.pcdata){h.pcdata("<",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case"' +                '<style>td{border:none;font-family: Calibri, sans-serif;} .number{mso-number-format:"0.00";}</style>' +                '<meta name=ProgId content=Excel.Sheet>' +                '<meta charset=UTF-8>' +                '</head><body>' +                this.getTable(true) +                '</body></html>',            base64 = function (s) {                 return window.btoa(unescape(encodeURIComponent(s))); // #50            };        getContent(            this,            uri + base64(template),            'xls',            template,            'application/vnd.ms-excel'        );    };
/**     * View the data in a table below the chart     */    Highcharts.Chart.prototype.viewData = function () {        if (!this.insertedTable) {            var div = document.createElement('div');            div.className = 'highcharts-data-table';            // Insert after the chart container            this.renderTo.parentNode.insertBefore(div, this.renderTo.nextSibling);            div.innerHTML = this.getTable(); this.insertedTable = true;        }    };
// Add "Download CSV" to the exporting menu. Use download attribute if supported, else    // run a simple PHP script that returns a file. The source code for the PHP script can be viewed at    // https://raw.github.com/highslide-software/highcharts.com/master/studies/csv-export/csv.php if (Highcharts.getOptions().exporting) {        Highcharts.getOptions().exporting.buttons.contextButton.menuItems.push({            textKey: 'downloadCSV',            onclick: function () { this.downloadCSV(); }        }, {            textKey: 'downloadXLS',            onclick: function () { this.downloadXLS(); }        }, {            textKey: 'viewData',            onclick: function () { this.viewData(); }        });    }
// Series specific    if (seriesTypes.map) {        seriesTypes.map.prototype.exportKey = 'name';    }    if (seriesTypes.mapbubble) {        seriesTypes.mapbubble.prototype.exportKey = 'name';    }
}); </script>
<script>/*
Ractive.js v0.9.0  Build: e2505c5cb8d78ee9e760ea6f91b74ccfb3e8424b  Date: Fri May 26 2017 21:43:30 GMT+0000 (UTC)  Website: http://ractivejs.org License: MIT
/
(function (global, factory) {  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  typeof define === 'function' && define.amd ? define(factory) :  (function() {   var current = global.Ractive;   var exports = factory();   global.Ractive = exports;   exports.noConflict = function() { global.Ractive = current; return exports; };  })(); }(this, (function () { 'use strict';
var defaults = {  // render placement:  el:                     void 0,  append:                 false,  delegate:               true,
// template:  template:               null,
// parse:  delimiters:             [ ' Template:', ' ' ],  tripleDelimiters:       [ '{{{', '}}}' ],  staticDelimiters:       [ ' ', ' ' ],  staticTripleDelimiters: [ '[[[', ']]]' ],  csp:                    true,  interpolate:            false,  preserveWhitespace:     false,  sanitize:               false,  stripComments:          true,  contextLines:           0,  parserTransforms:       [],
// data & binding:  data:                   {},  computed:               {},  syncComputedChildren:   false,  resolveInstanceMembers: true,  warnAboutAmbiguity:     false,  adapt:                  [],  isolated:               true,  twoway:                 true,  lazy:                   false,
// transitions:  noIntro:                false,  noOutro:                false,  transitionsEnabled:     true,  complete:               void 0,  nestedTransitions:      true,
// css:  css:                    null,  noCssTransform:         false };
// These are a subset of the easing equations found at // https://raw.github.com/danro/easing-js - license info // follows:
// -------------------------------------------------- // easing.js v0.5.4 // Generic set of easing functions with AMD support // https://github.com/danro/easing-js // This code may be freely distributed under the MIT license // http://danro.mit-license.org/ // -------------------------------------------------- // All functions adapted from Thomas Fuchs & Jeremy Kahn // Easing Equations (c) 2003 Robert Penner, BSD license // https://raw.github.com/danro/easing-js/master/LICENSE // --------------------------------------------------
// In that library, the functions named easeIn, easeOut, and // easeInOut below are named easeInCubic, easeOutCubic, and // (you guessed it) easeInOutCubic. // // You can add additional easing functions to this list, and they // will be globally available.
var easing = {  linear: function linear ( pos ) { return pos; },  easeIn: function easeIn ( pos ) { return Math.pow( pos, 3 ); },  easeOut: function easeOut ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },  easeInOut: function easeInOut ( pos ) {   if ( ( pos /= 0.5 ) < 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }   return ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );  } };
var toString = Object.prototype.toString;
function isEqual ( a, b ) {  if ( a === null && b === null ) {   return true;  }
if ( typeof a === 'object' || typeof b === 'object' ) {   return false;  }
return a === b; }
// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric function isNumeric ( thing ) {  return !isNaN( parseFloat( thing ) ) && isFinite( thing ); }
function isObject ( thing ) {  return ( thing && toString.call( thing ) === '[object Object]' ); }
function isObjectLike ( thing ) {  if ( !thing ) { return false; }  var type = typeof thing;  if ( type === 'object' || type === 'function' ) { return true; } }
/* eslint no-console:"off" */ var win = typeof window !== 'undefined' ? window : null; var doc = win ? document : null; var isClient = !!doc; var hasConsole = ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' );
var svg = doc ?  doc.implementation.hasFeature( ' http://www.w3.org/TR/SVG11/feature#BasicStructure' , '1.1' ) :  false;
var vendors = [ 'o', 'ms', 'moz', 'webkit' ];
var noop = function () {};
/* global console */ /* eslint no-console:"off" */
var alreadyWarned = {}; var log; var printWarning; var welcome;
if ( hasConsole ) {  var welcomeIntro = [   "%cRactive.js %c0.9.0 %cin debug mode, %cmore...",   'color: rgb(114, 157, 52); font-weight: normal;',   'color: rgb(85, 85, 85); font-weight: normal;',   'color: rgb(85, 85, 85); font-weight: normal;',   'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'  ];  var welcomeMessage = "You're running Ractive 0.9.0 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n http://docs.ractivejs.org\n http://stackoverflow.com/questions/tagged/ractivejs\n http://groups.google.com/forum/#!forum/ractive-js\n http://twitter.com/ractivejs\n\nFound a bug? Raise an issue:\n https://github.com/ractivejs/ractive/issues\n\n ";
welcome = function () {   if ( Ractive.WELCOME_MESSAGE === false ) {    welcome = noop;    return;   }   var message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;   var hasGroup = !!console.groupCollapsed;   if ( hasGroup ) { console.groupCollapsed.apply( console, welcomeIntro ); }   console.log( message );   if ( hasGroup ) {    console.groupEnd( welcomeIntro );   }
welcome = noop;  };
printWarning = function ( message, args ) {   welcome();
// extract information about the instance this message pertains to, if applicable   if ( typeof args[ args.length - 1 ] === 'object' ) {    var options = args.pop();    var ractive = options ? options.ractive : null;
if ( ractive ) {     // if this is an instance of a component that we know the name of, add     // it to the message     var name;     if ( ractive.component && ( name = ractive.component.name ) ) {      message = "<" + name + "> " + message;     }
var node;     if ( node = ( options.node || ( ractive.fragment && ractive.fragment.rendered && ractive.find( '*' ) ) ) ) {      args.push( node );     }    }   }
console.warn.apply( console, [ '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' ].concat( args ) );  };
log = function () {   console.log.apply( console, arguments );  }; } else {  printWarning = log = welcome = noop; }
function format ( message, args ) {  return message.replace( /%s/g, function () { return args.shift(); } ); }
function fatal ( message ) {  var args = [], len = arguments.length - 1;  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
message = format( message, args );  throw new Error( message ); }
function logIfDebug () {  if ( Ractive.DEBUG ) {   log.apply( null, arguments );  } }
function warn ( message ) {  var args = [], len = arguments.length - 1;  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
message = format( message, args );  printWarning( message, args ); }
function warnOnce ( message ) {  var args = [], len = arguments.length - 1;  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
message = format( message, args );
if ( alreadyWarned[ message ] ) {   return;  }
alreadyWarned[ message ] = true;  printWarning( message, args ); }
function warnIfDebug () {  if ( Ractive.DEBUG ) {   warn.apply( null, arguments );  } }
function warnOnceIfDebug () {  if ( Ractive.DEBUG ) {   warnOnce.apply( null, arguments );  } }
// Error messages that are used (or could be) in multiple places var badArguments = 'Bad arguments'; var noRegistryFunctionReturn = 'A function was specified for "%s" %s, but no %s was returned'; var missingPlugin = function ( name, type ) { return ("Missing \"" + name + "\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins# " + type + "s"); };
function findInViewHierarchy ( registryName, ractive, name ) {  var instance = findInstance( registryName, ractive, name );  return instance ? instance[ registryName ][ name ] : null; }
function findInstance ( registryName, ractive, name ) {  while ( ractive ) {   if ( name in ractive[ registryName ] ) {    return ractive;   }
if ( ractive.isolated ) {    return null;   }
ractive = ractive.parent;  } }
function interpolate ( from, to, ractive, type ) {  if ( from === to ) { return null; }
if ( type ) {   var interpol = findInViewHierarchy( 'interpolators', ractive, type );   if ( interpol ) { return interpol( from, to ) || null; }
fatal( missingPlugin( type, 'interpolator' ) );  }
return interpolators.number( from, to ) ||         interpolators.array( from, to ) ||         interpolators.object( from, to ) || null; }
function snap ( to ) {  return function () { return to; }; }
var interpolators = {  number: function number ( from, to ) {   if ( !isNumeric( from ) || !isNumeric( to ) ) {    return null;   }
from = +from;   to = +to;
var delta = to - from;
if ( !delta ) {    return function () { return from; };   }
return function ( t ) {    return from + ( t * delta );   };  },
array: function array ( from, to ) {   var len, i;
if ( !Array.isArray( from ) || !Array.isArray( to ) ) {    return null;   }
var intermediate = [];   var interpolators = [];
i = len = Math.min( from.length, to.length );   while ( i-- ) {    interpolators[i] = interpolate( from[i], to[i] );   }
// surplus values - don't interpolate, but don't exclude them either   for ( i=len; i<from.length; i+=1 ) {    intermediate[i] = from[i];   }
for ( i=len; i<to.length; i+=1 ) {    intermediate[i] = to[i];   }
return function ( t ) {    var i = len;
while ( i-- ) {     intermediate[i] = interpolators[i]( t );    }
return intermediate;   };  },
object: function object ( from, to ) {   if ( !isObject( from ) || !isObject( to ) ) {    return null;   }
var properties = [];   var intermediate = {};   var interpolators = {};
for ( var prop in from ) {    if ( from.hasOwnProperty( prop ) ) {     if ( to.hasOwnProperty( prop ) ) {      properties.push( prop );      interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] ) || snap( to[ prop ] );     }
else {      intermediate[ prop ] = from[ prop ];     }    }   }
for ( var prop$1 in to ) {    if ( to.hasOwnProperty( prop$1 ) && !from.hasOwnProperty( prop$1 ) ) {     intermediate[ prop$1 ] = to[ prop$1 ];    }   }
var len = properties.length;
return function ( t ) {    var i = len;
while ( i-- ) {     var prop = properties[i];
intermediate[ prop ] = interpolators[ prop ]( t );    }
return intermediate;   };  } };
function addToArray ( array, value ) {  var index = array.indexOf( value );
if ( index === -1 ) {   array.push( value );  } }
function arrayContains ( array, value ) {  for ( var i = 0, c = array.length; i < c; i++ ) {   if ( array[i] == value ) {    return true;   }  }
return false; }
function arrayContentsMatch ( a, b ) {  var i;
if ( !Array.isArray( a ) || !Array.isArray( b ) ) {   return false;  }
if ( a.length !== b.length ) {   return false;  }
i = a.length;  while ( i-- ) {   if ( a[i] !== b[i] ) {    return false;   }  }
return true; }
function ensureArray ( x ) {  if ( typeof x === 'string' ) {   return [ x ];  }
if ( x === undefined ) {   return [];  }
return x; }
function lastItem ( array ) {  return array[ array.length - 1 ]; }
function removeFromArray ( array, member ) {  if ( !array ) {   return;  }
var index = array.indexOf( member );
if ( index !== -1 ) {   array.splice( index, 1 );  } }
function combine () {  var arrays = [], len = arguments.length;  while ( len-- ) arrays[ len ] = arguments[ len ];
var res = arrays.concat.apply( [], arrays );  var i = res.length;  while ( i-- ) {   var idx = res.indexOf( res[i] );   if ( ~idx && idx < i ) { res.splice( i, 1 ); }  }
return res; }
function toArray ( arrayLike ) {  var array = [];  var i = arrayLike.length;  while ( i-- ) {   array[i] = arrayLike[i];  }
return array; }
function findMap ( array, fn ) {  var len = array.length;  for ( var i = 0; i < len; i++ ) {   var result = fn( array[i] );   if ( result ) { return result; }  } }
var TransitionManager = function TransitionManager ( callback, parent ) {  this.callback = callback;  this.parent = parent;
this.intros = [];  this.outros = [];
this.children = [];  this.totalChildren = this.outroChildren = 0;
this.detachQueue = [];  this.outrosComplete = false;
if ( parent ) {   parent.addChild( this );  } };
TransitionManager.prototype.add = function add ( transition ) {  var list = transition.isIntro ? this.intros : this.outros;  transition.starting = true;  list.push( transition ); };
TransitionManager.prototype.addChild = function addChild ( child ) {  this.children.push( child );
this.totalChildren += 1;  this.outroChildren += 1; };
TransitionManager.prototype.decrementOutros = function decrementOutros () {  this.outroChildren -= 1;  check( this ); };
TransitionManager.prototype.decrementTotal = function decrementTotal () {  this.totalChildren -= 1;  check( this ); };
TransitionManager.prototype.detachNodes = function detachNodes () {  this.detachQueue.forEach( detach );  this.children.forEach( _detachNodes );  this.detachQueue = []; };
TransitionManager.prototype.ready = function ready () {  if ( this.detachQueue.length ) { detachImmediate( this ); } };
TransitionManager.prototype.remove = function remove ( transition ) {  var list = transition.isIntro ? this.intros : this.outros;  removeFromArray( list, transition );  check( this ); };
TransitionManager.prototype.start = function start () {  this.children.forEach( function (c) { return c.start(); } );  this.intros.concat( this.outros ).forEach( function (t) { return t.start(); } );  this.ready = true;  check( this ); };
function detach ( element ) {  element.detach(); }
function _detachNodes ( tm ) { // _ to avoid transpiler quirk  tm.detachNodes(); }
function check ( tm ) {  if ( !tm.ready || tm.outros.length || tm.outroChildren ) { return; }
// If all outros are complete, and we haven't already done this,  // we notify the parent if there is one, otherwise  // start detaching nodes  if ( !tm.outrosComplete ) {   tm.outrosComplete = true;
if ( tm.parent && !tm.parent.outrosComplete ) {    tm.parent.decrementOutros( tm );   } else {    tm.detachNodes();   }  }
// Once everything is done, we can notify parent transition  // manager and call the callback  if ( !tm.intros.length && !tm.totalChildren ) {   if ( typeof tm.callback === 'function' ) {    tm.callback();   }
if ( tm.parent && !tm.notifiedTotal ) {    tm.notifiedTotal = true;    tm.parent.decrementTotal();   }  } }
// check through the detach queue to see if a node is up or downstream from a // transition and if not, go ahead and detach it function detachImmediate ( manager ) {  var queue = manager.detachQueue;  var outros = collectAllOutros( manager );
var i = queue.length;  var j = 0;  var node, trans;  start: while ( i-- ) {   node = queue[i].node;   j = outros.length;   while ( j-- ) {    trans = outros[j].element.node;    // check to see if the node is, contains, or is contained by the transitioning node    if ( trans === node || trans.contains( node ) || node.contains( trans ) ) { continue start; }   }
// no match, we can drop it   queue[i].detach();   queue.splice( i, 1 );  } }
function collectAllOutros ( manager, _list ) {  var list = _list;
// if there's no list, we're starting at the root to build one  if ( !list ) {   list = [];   var parent = manager;   while ( parent.parent ) { parent = parent.parent; }   return collectAllOutros( parent, list );  } else {   // grab all outros from child managers   var i = manager.children.length;   while ( i-- ) {    list = collectAllOutros( manager.children[i], list );   }
// grab any from this manager if there are any   if ( manager.outros.length ) { list = list.concat( manager.outros ); }
return list;  } }
var batch;
var runloop = {  start: function start ( instance ) {   var fulfilPromise;   var promise = new Promise( function (f) { return ( fulfilPromise = f ); } );
batch = {    previousBatch: batch,    transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),    fragments: [],    tasks: [],    immediateObservers: [],    deferredObservers: [],    instance: instance,    promise: promise   };
return promise;  },
end: function end () {   flushChanges();
if ( !batch.previousBatch ) { batch.transitionManager.start(); }
batch = batch.previousBatch;  },
addFragment: function addFragment ( fragment ) {   addToArray( batch.fragments, fragment );  },
// TODO: come up with a better way to handle fragments that trigger their own update  addFragmentToRoot: function addFragmentToRoot ( fragment ) {   if ( !batch ) { return; }
var b = batch;   while ( b.previousBatch ) {    b = b.previousBatch;   }
addToArray( b.fragments, fragment );  },
addObserver: function addObserver ( observer, defer ) {   if ( !batch ) {    observer.dispatch();   } else {    addToArray( defer ? batch.deferredObservers : batch.immediateObservers, observer );   }  },
registerTransition: function registerTransition ( transition ) {   transition._manager = batch.transitionManager;   batch.transitionManager.add( transition );  },
// synchronise node detachments with transition ends  detachWhenReady: function detachWhenReady ( thing ) {   batch.transitionManager.detachQueue.push( thing );  },
scheduleTask: function scheduleTask ( task, postRender ) {   var _batch;
if ( !batch ) {    task();   } else {    _batch = batch;    while ( postRender && _batch.previousBatch ) {     // this can't happen until the DOM has been fully updated     // otherwise in some situations (with components inside elements)     // transitions and decorators will initialise prematurely     _batch = _batch.previousBatch;    }
_batch.tasks.push( task );   }  },
promise: function promise () {   if ( !batch ) { return Promise.resolve(); }
var target = batch;   while ( target.previousBatch ) {    target = target.previousBatch;   }
return target.promise || Promise.resolve();  } };
function dispatch ( observer ) {  observer.dispatch(); }
function flushChanges () {  var which = batch.immediateObservers;  batch.immediateObservers = [];  which.forEach( dispatch );
// Now that changes have been fully propagated, we can update the DOM  // and complete other tasks  var i = batch.fragments.length;  var fragment;
which = batch.fragments;  batch.fragments = [];
while ( i-- ) {   fragment = which[i];   fragment.update();  }
batch.transitionManager.ready();
which = batch.deferredObservers;  batch.deferredObservers = [];  which.forEach( dispatch );
var tasks = batch.tasks;  batch.tasks = [];
for ( i = 0; i < tasks.length; i += 1 ) {   tasks[i]();  }
// If updating the view caused some model blowback - e.g. a triple  // containing <option> elements caused the binding on the <select> // to update - then we start over  if ( batch.fragments.length || batch.immediateObservers.length || batch.deferredObservers.length || batch.tasks.length ) { return flushChanges(); } }
var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g; var splitPattern = /([^\\](?:\\\\)*)\./; var escapeKeyPattern = /\\|\./g; var unescapeKeyPattern = /((?:\\)+)\1|\\(\.)/g;
function escapeKey ( key ) {  if ( typeof key === 'string' ) {   return key.replace( escapeKeyPattern, '\\$&' );  }
return key; }
function normalise ( ref ) {  return ref ? ref.replace( refPattern, '.$1' ) : ; }
function splitKeypath ( keypath ) {  var result = [];  var match;
keypath = normalise( keypath );
while ( match = splitPattern.exec( keypath ) ) {   var index = match.index + match[1].length;   result.push( keypath.substr( 0, index ) );   keypath = keypath.substr( index + 1 );  }
result.push( keypath );
return result; }
function unescapeKey ( key ) {  if ( typeof key === 'string' ) {   return key.replace( unescapeKeyPattern, '$1$2' );  }
return key; }
var stack = []; var captureGroup;
function startCapturing () {  stack.push( captureGroup = [] ); }
function stopCapturing () {  var dependencies = stack.pop();  captureGroup = stack[ stack.length - 1 ];  return dependencies; }
function capture ( model ) {  if ( captureGroup ) {   captureGroup.push( model );  } }
var KeyModel = function KeyModel ( key, parent ) {  this.value = key;  this.isReadonly = this.isKey = true;  this.deps = [];  this.links = [];  this.parent = parent; };
KeyModel.prototype.get = function get ( shouldCapture ) {  if ( shouldCapture ) { capture( this ); }  return unescapeKey( this.value ); };
KeyModel.prototype.getKeypath = function getKeypath () {  return unescapeKey( this.value ); };
KeyModel.prototype.rebind = function rebind ( next, previous ) {   var this$1 = this;
var i = this.deps.length;  while ( i-- ) { this$1.deps[i].rebind( next, previous, false ); }
i = this.links.length;  while ( i-- ) { this$1.links[i].rebind( next, previous, false ); } };
KeyModel.prototype.register = function register ( dependant ) {  this.deps.push( dependant ); };
KeyModel.prototype.registerLink = function registerLink ( link ) {  addToArray( this.links, link ); };
KeyModel.prototype.unregister = function unregister ( dependant ) {  removeFromArray( this.deps, dependant ); };
KeyModel.prototype.unregisterLink = function unregisterLink ( link ) {  removeFromArray( this.links, link ); };
KeyModel.prototype.reference = noop; KeyModel.prototype.unreference = noop;
function bind               ( x ) { x.bind(); } function cancel             ( x ) { x.cancel(); } function destroyed          ( x ) { x.destroyed(); } function handleChange       ( x ) { x.handleChange(); } function mark               ( x ) { x.mark(); } function marked             ( x ) { x.marked(); } function markedAll          ( x ) { x.markedAll(); } function render ( x ) { x.render(); } function shuffled           ( x ) { x.shuffled(); } function teardown           ( x ) { x.teardown(); } function unbind             ( x ) { x.unbind(); } function unrender           ( x ) { x.unrender(); } function unrenderAndDestroy ( x ) { x.unrender( true ); } function update             ( x ) { x.update(); } function toString$1           ( x ) { return x.toString(); } function toEscapedString    ( x ) { return x.toString( true ); }
var KeypathModel = function KeypathModel ( parent, ractive ) {  this.parent = parent;  this.ractive = ractive;  this.value = ractive ? parent.getKeypath( ractive ) : parent.getKeypath();  this.deps = [];  this.children = {};  this.isReadonly = this.isKeypath = true; };
KeypathModel.prototype.get = function get ( shouldCapture ) {  if ( shouldCapture ) { capture( this ); }  return this.value; };
KeypathModel.prototype.getChild = function getChild ( ractive ) {  if ( !( ractive._guid in this.children ) ) {   var model = new KeypathModel( this.parent, ractive );   this.children[ ractive._guid ] = model;   model.owner = this;  }  return this.children[ ractive._guid ]; };
KeypathModel.prototype.getKeypath = function getKeypath () {  return this.value; };
KeypathModel.prototype.handleChange = function handleChange$1 () {   var this$1 = this;
var keys = Object.keys( this.children );  var i = keys.length;  while ( i-- ) {   this$1.children[ keys[i] ].handleChange();  }
this.deps.forEach( handleChange ); };
KeypathModel.prototype.rebindChildren = function rebindChildren ( next ) {   var this$1 = this;
var keys = Object.keys( this.children );  var i = keys.length;  while ( i-- ) {   var child = this$1.children[keys[i]];   child.value = next.getKeypath( child.ractive );   child.handleChange();  } };
KeypathModel.prototype.rebind = function rebind ( next, previous ) {   var this$1 = this;
var model = next ? next.getKeypathModel( this.ractive ) : undefined;
var keys = Object.keys( this.children );  var i = keys.length;  while ( i-- ) {   this$1.children[ keys[i] ].rebind( next, previous, false );  }
i = this.deps.length;  while ( i-- ) {   this$1.deps[i].rebind( model, this$1, false );  } };
KeypathModel.prototype.register = function register ( dep ) {  this.deps.push( dep ); };
KeypathModel.prototype.removeChild = function removeChild ( model ) {  if ( model.ractive ) { delete this.children[ model.ractive._guid ]; } };
KeypathModel.prototype.teardown = function teardown$$1 () {   var this$1 = this;
if ( this.owner ) { this.owner.removeChild( this ); }
var keys = Object.keys( this.children );  var i = keys.length;  while ( i-- ) {   this$1.children[ keys[i] ].teardown();  } };
KeypathModel.prototype.unregister = function unregister ( dep ) {  removeFromArray( this.deps, dep );  if ( !this.deps.length ) { this.teardown(); } };
KeypathModel.prototype.reference = noop; KeypathModel.prototype.unreference = noop;
var fnBind = Function.prototype.bind;
function bind$1 ( fn, context ) {  if ( !/this/.test( fn.toString() ) ) { return fn; }
var bound = fnBind.call( fn, context );  for ( var prop in fn ) { bound[ prop ] = fn[ prop ]; }
return bound; }
var hasProp = Object.prototype.hasOwnProperty;
var shuffleTasks = { early: [], mark: [] }; var registerQueue = { early: [], mark: [] };
var ModelBase = function ModelBase ( parent ) {  this.deps = [];
this.children = [];  this.childByKey = {};  this.links = [];
this.keyModels = {};
this.bindings = [];  this.patternObservers = [];
if ( parent ) {   this.parent = parent;   this.root = parent.root;  } };
ModelBase.prototype.addShuffleTask = function addShuffleTask ( task, stage ) {  if ( stage === void 0 ) stage = 'early';
shuffleTasks[stage].push( task ); };
ModelBase.prototype.addShuffleRegister = function addShuffleRegister ( item, stage ) {  if ( stage === void 0 ) stage = 'early';
registerQueue[stage].push({ model: this, item: item }); };
ModelBase.prototype.findMatches = function findMatches ( keys ) {  var len = keys.length;
var existingMatches = [ this ];  var matches;  var i;
var loop = function (  ) {   var key = keys[i];
if ( key === '*' ) {    matches = [];    existingMatches.forEach( function (model) {     matches.push.apply( matches, model.getValueChildren( model.get() ) );    });   } else {    matches = existingMatches.map( function (model) { return model.joinKey( key ); } );   }
existingMatches = matches;  };
for ( i = 0; i < len; i += 1 ) loop(  );
return matches; };
ModelBase.prototype.getKeyModel = function getKeyModel ( key, skip ) {  if ( key !== undefined && !skip ) { return this.parent.getKeyModel( key, true ); }
if ( !( key in this.keyModels ) ) { this.keyModels[ key ] = new KeyModel( escapeKey( key ), this ); }
return this.keyModels[ key ]; };
ModelBase.prototype.getKeypath = function getKeypath ( ractive ) {  if ( ractive !== this.ractive && this._link ) { return this._link.target.getKeypath( ractive ); }
if ( !this.keypath ) {   var parent = this.parent && this.parent.getKeypath( ractive );   this.keypath = parent ? ((this.parent.getKeypath( ractive )) + "." + (escapeKey( this.key ))) : escapeKey( this.key );  }
return this.keypath; };
ModelBase.prototype.getValueChildren = function getValueChildren ( value ) {   var this$1 = this;
var children;  if ( Array.isArray( value ) ) {   children = [];   if ( 'length' in this && this.length !== value.length ) {    children.push( this.joinKey( 'length' ) );   }   value.forEach( function ( m, i ) {    children.push( this$1.joinKey( i ) );   });  }
else if ( isObject( value ) || typeof value === 'function' ) {   children = Object.keys( value ).map( function (key) { return this$1.joinKey( key ); } );  }
else if ( value != null ) {   return [];  }
return children; };
ModelBase.prototype.getVirtual = function getVirtual ( shouldCapture ) {   var this$1 = this;
var value = this.get( shouldCapture, { virtual: false } );  if ( isObject( value ) ) {   var result = Array.isArray( value ) ? [] : {};
var keys = Object.keys( value );   var i = keys.length;   while ( i-- ) {    var child = this$1.childByKey[ keys[i] ];    if ( !child ) { result[ keys[i] ] = value[ keys[i] ]; }    else if ( child._link ) { result[ keys[i] ] = child._link.getVirtual(); }    else { result[ keys[i] ] = child.getVirtual(); }   }
i = this.children.length;   while ( i-- ) {    var child$1 = this$1.children[i];    if ( !( child$1.key in result ) && child$1._link ) {     result[ child$1.key ] = child$1._link.getVirtual();    }   }
return result;  } else { return value; } };
ModelBase.prototype.has = function has ( key ) {  if ( this._link ) { return this._link.has( key ); }
var value = this.get();  if ( !value ) { return false; }
key = unescapeKey( key );  if ( hasProp.call( value, key ) ) { return true; }
// We climb up the constructor chain to find if one of them contains the key  var constructor = value.constructor;  while ( constructor !== Function && constructor !== Array && constructor !== Object ) {   if ( hasProp.call( constructor.prototype, key ) ) { return true; }   constructor = constructor.constructor;  }
return false; };
ModelBase.prototype.joinAll = function joinAll ( keys, opts ) {  var model = this;  for ( var i = 0; i < keys.length; i += 1 ) {   if ( opts && opts.lastLink === false && i + 1 === keys.length && model.childByKey[keys[i]] && model.childByKey[keys[i]]._link ) { return model.childByKey[keys[i]]; }   model = model.joinKey( keys[i], opts );  }
return model; };
ModelBase.prototype.notifyUpstream = function notifyUpstream ( startPath ) {   var this$1 = this;
var parent = this.parent;  var path = startPath || [ this.key ];  while ( parent ) {   if ( parent.patternObservers.length ) { parent.patternObservers.forEach( function (o) { return o.notify( path.slice() ); } ); }   path.unshift( parent.key );   parent.links.forEach( function (l) { return l.notifiedUpstream( path, this$1.root ); } );   parent.deps.forEach( handleChange );   parent = parent.parent;  } };
ModelBase.prototype.rebind = function rebind ( next, previous, safe ) {   var this$1 = this;
// tell the deps to move to the new target  var i = this.deps.length;  while ( i-- ) {   if ( this$1.deps[i].rebind ) { this$1.deps[i].rebind( next, previous, safe ); }  }
i = this.links.length;  while ( i-- ) {   var link = this$1.links[i];   // only relink the root of the link tree   if ( link.owner._link ) { link.relinking( next, safe ); }  }
i = this.children.length;  while ( i-- ) {   var child = this$1.children[i];   child.rebind( next ? next.joinKey( child.key ) : undefined, child, safe );  }
if ( this.keypathModel ) { this.keypathModel.rebind( next, previous, false ); }
i = this.bindings.length;  while ( i-- ) {   this$1.bindings[i].rebind( next, previous, safe );  } };
ModelBase.prototype.reference = function reference () {  'refs' in this ? this.refs++ : this.refs = 1; };
ModelBase.prototype.register = function register ( dep ) {  this.deps.push( dep ); };
ModelBase.prototype.registerLink = function registerLink ( link ) {  addToArray( this.links, link ); };
ModelBase.prototype.registerPatternObserver = function registerPatternObserver ( observer ) {  this.patternObservers.push( observer );  this.register( observer ); };
ModelBase.prototype.registerTwowayBinding = function registerTwowayBinding ( binding ) {  this.bindings.push( binding ); };
ModelBase.prototype.unreference = function unreference () {  if ( 'refs' in this ) { this.refs--; } };
ModelBase.prototype.unregister = function unregister ( dep ) {  removeFromArray( this.deps, dep ); };
ModelBase.prototype.unregisterLink = function unregisterLink ( link ) {  removeFromArray( this.links, link ); };
ModelBase.prototype.unregisterPatternObserver = function unregisterPatternObserver ( observer ) {  removeFromArray( this.patternObservers, observer );  this.unregister( observer ); };
ModelBase.prototype.unregisterTwowayBinding = function unregisterTwowayBinding ( binding ) {  removeFromArray( this.bindings, binding ); };
ModelBase.prototype.updateFromBindings = function updateFromBindings$1 ( cascade ) {   var this$1 = this;
var i = this.bindings.length;  while ( i-- ) {   var value = this$1.bindings[i].getValue();   if ( value !== this$1.value ) { this$1.set( value ); }  }
// check for one-way bindings if there are no two-ways  if ( !this.bindings.length ) {   var oneway = findBoundValue( this.deps );   if ( oneway && oneway.value !== this.value ) { this.set( oneway.value ); }  }
if ( cascade ) {   this.children.forEach( updateFromBindings );   this.links.forEach( updateFromBindings );   if ( this._link ) { this._link.updateFromBindings( cascade ); }  } };
// TODO: this may be better handled by overreiding `get` on models with a parent that isRoot function maybeBind ( model, value, shouldBind ) {  if ( shouldBind && typeof value === 'function' && model.parent && model.parent.isRoot ) {   if ( !model.boundValue ) {    model.boundValue = bind$1( value._r_unbound || value, model.parent.ractive );   }
return model.boundValue;  }
return value; }
function updateFromBindings ( model ) {  model.updateFromBindings( true ); }
function findBoundValue( list ) {  var i = list.length;  while ( i-- ) {   if ( list[i].bound ) {    var owner = list[i].owner;    if ( owner ) {     var value = owner.name === 'checked' ?      owner.node.checked : owner.node.value;     return { value: value };    }   }  } }
function fireShuffleTasks ( stage ) {  if ( !stage ) {   fireShuffleTasks( 'early' );   fireShuffleTasks( 'mark' );  } else {   var tasks = shuffleTasks[stage];   shuffleTasks[stage] = [];   var i = tasks.length;   while ( i-- ) { tasks[i](); }
var register = registerQueue[stage];   registerQueue[stage] = [];   i = register.length;   while ( i-- ) { register[i].model.register( register[i].item ); }  } }
function shuffle ( model, newIndices, link ) {  model.shuffling = true;
var i = newIndices.length;  while ( i-- ) {   var idx = newIndices[ i ];   // nothing is actually changing, so move in the index and roll on   if ( i === idx ) {    continue;   }
// rebind the children on i to idx   if ( i in model.childByKey ) { model.childByKey[ i ].rebind( !~idx ? undefined : model.joinKey( idx ), model.childByKey[ i ], true ); }
if ( !~idx && model.keyModels[ i ] ) {    model.keyModels[i].rebind( undefined, model.keyModels[i], false );   } else if ( ~idx && model.keyModels[ i ] ) {    if ( !model.keyModels[ idx ] ) { model.childByKey[ idx ].getKeyModel( idx ); }    model.keyModels[i].rebind( model.keyModels[ idx ], model.keyModels[i], false );   }  }
var upstream = model.source().length !== model.source().value.length;
model.links.forEach( function (l) { return l.shuffle( newIndices ); } );  if ( !link ) { fireShuffleTasks( 'early' ); }
i = model.deps.length;  while ( i-- ) {   if ( model.deps[i].shuffle ) { model.deps[i].shuffle( newIndices ); }  }
model[ link ? 'marked' : 'mark' ]();  if ( !link ) { fireShuffleTasks( 'mark' ); }
if ( upstream ) { model.notifyUpstream(); }
model.shuffling = false; }
KeyModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask; KeyModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister; KeypathModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask; KeypathModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;
// this is the dry method of checking to see if a rebind applies to // a particular keypath because in some cases, a dep may be bound // directly to a particular keypath e.g. foo.bars.0.baz and need // to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted function rebindMatch ( template, next, previous, fragment ) {  var keypath = template.r || template;
// no valid keypath, go with next  if ( !keypath || typeof keypath !== 'string' ) { return next; }
// completely contextual ref, go with next  if ( keypath === '.' || keypath[0] === '@' || ( next || previous ).isKey || ( next || previous ).isKeypath ) { return next; }
var parts = keypath.split( '/' );  var keys = splitKeypath( parts[ parts.length - 1 ] );  var last = keys[ keys.length - 1 ];
// check the keypath against the model keypath to see if it matches  var model = next || previous;
// check to see if this was an alias  if ( model && keys.length === 1 && last !== model.key && fragment ) {   keys = findAlias( last, fragment ) || keys;  }
var i = keys.length;  var match = true;  var shuffling = false;
while ( model && i-- ) {   if ( model.shuffling ) { shuffling = true; }   // non-strict comparison to account for indices in keypaths   if ( keys[i] != model.key ) { match = false; }   model = model.parent;  }
// next is undefined, but keypath is shuffling and previous matches  if ( !next && match && shuffling ) { return previous; }  // next is defined, but doesn't match the keypath  else if ( next && !match && shuffling ) { return previous; }  else { return next; } }
function findAlias ( name, fragment ) {  while ( fragment ) {   var z = fragment.aliases;   if ( z && z[ name ] ) {    var aliases = ( fragment.owner.iterations ? fragment.owner : fragment ).owner.template.z;    for ( var i = 0; i < aliases.length; i++ ) {     if ( aliases[i].n === name ) {      var alias = aliases[i].x;      if ( !alias.r ) { return false; }      var parts = alias.r.split( '/' );      return splitKeypath( parts[ parts.length - 1 ] );     }    }    return;   }
fragment = fragment.componentParent || fragment.parent;  } }
// temporary placeholder target for detached implicit links var Missing = {  key: '@missing',  animate: noop,  applyValue: noop,  get: noop,  getKeypath: function getKeypath () { return this.key; },  joinAll: function joinAll () { return this; },  joinKey: function joinKey () { return this; },  mark: noop,  registerLink: noop,  shufle: noop,  set: noop,  unregisterLink: noop }; Missing.parent = Missing;
var LinkModel = (function (ModelBase$$1) {  function LinkModel ( parent, owner, target, key ) {   ModelBase$$1.call( this, parent );
this.owner = owner;   this.target = target;   this.key = key === undefined ? owner.key : key;   if ( owner.isLink ) { this.sourcePath = (owner.sourcePath) + "." + (this.key); }
target.registerLink( this );
if ( parent ) { this.isReadonly = parent.isReadonly; }
this.isLink = true;  }
if ( ModelBase$$1 ) LinkModel.__proto__ = ModelBase$$1;  LinkModel.prototype = Object.create( ModelBase$$1 && ModelBase$$1.prototype );  LinkModel.prototype.constructor = LinkModel;
LinkModel.prototype.animate = function animate ( from, to, options, interpolator ) {   return this.target.animate( from, to, options, interpolator );  };
LinkModel.prototype.applyValue = function applyValue ( value ) {   if ( this.boundValue ) { this.boundValue = null; }   this.target.applyValue( value );  };
LinkModel.prototype.attach = function attach ( fragment ) {   var model = resolveReference( fragment, this.key );   if ( model ) {    this.relinking( model, false );   } else { // if there is no link available, move everything here to real models    this.owner.unlink();   }  };
LinkModel.prototype.detach = function detach () {   this.relinking( Missing, false );  };
LinkModel.prototype.get = function get ( shouldCapture, opts ) {   if ( opts === void 0 ) opts = {};
if ( shouldCapture ) {    capture( this );
// may need to tell the target to unwrap    opts.unwrap = true;   }
var bind$$1 = 'shouldBind' in opts ? opts.shouldBind : true;   opts.shouldBind = false;
return maybeBind( this, this.target.get( false, opts ), bind$$1 );  };
LinkModel.prototype.getKeypath = function getKeypath ( ractive ) {   if ( ractive && ractive !== this.root.ractive ) { return this.target.getKeypath( ractive ); }
return ModelBase$$1.prototype.getKeypath.call( this, ractive );  };
LinkModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {   if ( !this.keypathModel ) { this.keypathModel = new KeypathModel( this ); }   if ( ractive && ractive !== this.root.ractive ) { return this.keypathModel.getChild( ractive ); }   return this.keypathModel;  };
LinkModel.prototype.handleChange = function handleChange$1 () {   this.deps.forEach( handleChange );   this.links.forEach( handleChange );   this.notifyUpstream();  };
LinkModel.prototype.isDetached = function isDetached () { return this.virtual && this.target === Missing; };
LinkModel.prototype.joinKey = function joinKey ( key ) {   // TODO: handle nested links   if ( key === undefined || key === ) { return this; }
if ( !this.childByKey.hasOwnProperty( key ) ) {    var child = new LinkModel( this, this, this.target.joinKey( key ), key );    this.children.push( child );    this.childByKey[ key ] = child;   }
return this.childByKey[ key ];  };
LinkModel.prototype.mark = function mark$$1 ( force ) {   this.target.mark( force );  };
LinkModel.prototype.marked = function marked$1 () {   if ( this.boundValue ) { this.boundValue = null; }
this.links.forEach( marked );
this.deps.forEach( handleChange );  };
LinkModel.prototype.markedAll = function markedAll$1 () {   this.children.forEach( markedAll );   this.marked();  };
LinkModel.prototype.notifiedUpstream = function notifiedUpstream ( startPath, root ) {   var this$1 = this;
this.links.forEach( function (l) { return l.notifiedUpstream( startPath, this$1.root ); } );   this.deps.forEach( handleChange );   if ( startPath && this.rootLink && this.root !== root ) {    var path = startPath.slice( 1 );    path.unshift( this.key );    this.notifyUpstream( path );   }  };
LinkModel.prototype.relinked = function relinked () {   this.target.registerLink( this );   this.children.forEach( function (c) { return c.relinked(); } );  };
LinkModel.prototype.relinking = function relinking ( target, safe ) {   var this$1 = this;
if ( this.rootLink && this.sourcePath ) { target = rebindMatch( this.sourcePath, target, this.target ); }   if ( !target || this.target === target ) { return; }
this.target.unregisterLink( this );   if ( this.keypathModel ) { this.keypathModel.rebindChildren( target ); }
this.target = target;   this.children.forEach( function (c) {    c.relinking( target.joinKey( c.key ), safe );   });
if ( this.rootLink ) { this.addShuffleTask( function () {    this$1.relinked();    if ( !safe ) { this$1.notifyUpstream(); }   }); }  };
LinkModel.prototype.set = function set ( value ) {   if ( this.boundValue ) { this.boundValue = null; }   this.target.set( value );  };
LinkModel.prototype.shuffle = function shuffle$1 ( newIndices ) {   // watch for extra shuffles caused by a shuffle in a downstream link   if ( this.shuffling ) { return; }
// let the real model handle firing off shuffles   if ( !this.target.shuffling ) {    this.target.shuffle( newIndices );   } else {    shuffle( this, newIndices, true );   }
};
LinkModel.prototype.source = function source () {   if ( this.target.source ) { return this.target.source(); }   else { return this.target; }  };
LinkModel.prototype.teardown = function teardown$1 () {   if ( this._link ) { this._link.teardown(); }   this.target.unregisterLink( this );   this.children.forEach( teardown );  };
return LinkModel; }(ModelBase));
ModelBase.prototype.link = function link ( model, keypath, options ) {  var lnk = this._link || new LinkModel( this.parent, this, model, this.key );  lnk.implicit = options && options.implicit;  lnk.sourcePath = keypath;  lnk.rootLink = true;  if ( this._link ) { this._link.relinking( model, true, false ); }  this.rebind( lnk, this, false );  fireShuffleTasks();
this._link = lnk;  lnk.markedAll();
this.notifyUpstream();  return lnk; };
ModelBase.prototype.unlink = function unlink () {  if ( this._link ) {   var ln = this._link;   this._link = undefined;   ln.rebind( this, this._link );   fireShuffleTasks();   ln.teardown();   this.notifyUpstream();  } };
// TODO what happens if a transition is aborted?
var tickers = []; var running = false;
function tick () {  runloop.start();
var now = performance.now();
var i;  var ticker;
for ( i = 0; i < tickers.length; i += 1 ) {   ticker = tickers[i];
if ( !ticker.tick( now ) ) {    // ticker is complete, remove it from the stack, and decrement i so we don't miss one    tickers.splice( i--, 1 );   }  }
runloop.end();
if ( tickers.length ) {   requestAnimationFrame( tick );  } else {   running = false;  } }
var Ticker = function Ticker ( options ) {  this.duration = options.duration;  this.step = options.step;  this.complete = options.complete;  this.easing = options.easing;
this.start = performance.now();  this.end = this.start + this.duration;
this.running = true;
tickers.push( this );  if ( !running ) { requestAnimationFrame( tick ); } };
Ticker.prototype.tick = function tick ( now ) {  if ( !this.running ) { return false; }
if ( now > this.end ) {   if ( this.step ) { this.step( 1 ); }   if ( this.complete ) { this.complete( 1 ); }
return false;  }
var elapsed = now - this.start;  var eased = this.easing( elapsed / this.duration );
if ( this.step ) { this.step( eased ); }
return true; };
Ticker.prototype.stop = function stop () {  if ( this.abort ) { this.abort(); }  this.running = false; };
var prefixers = {};
// TODO this is legacy. sooner we can replace the old adaptor API the better function prefixKeypath ( obj, prefix ) {  var prefixed = {};
if ( !prefix ) {   return obj;  }
prefix += '.';
for ( var key in obj ) {   if ( obj.hasOwnProperty( key ) ) {    prefixed[ prefix + key ] = obj[ key ];   }  }
return prefixed; }
function getPrefixer ( rootKeypath ) {  var rootDot;
if ( !prefixers[ rootKeypath ] ) {   rootDot = rootKeypath ? rootKeypath + '.' : ;
prefixers[ rootKeypath ] = function ( relativeKeypath, value ) {    var obj;
if ( typeof relativeKeypath === 'string' ) {     obj = {};     obj[ rootDot + relativeKeypath ] = value;     return obj;    }
if ( typeof relativeKeypath === 'object' ) {     // 'relativeKeypath' is in fact a hash, not a keypath     return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;    }   };  }
return prefixers[ rootKeypath ]; }
var Model = (function (ModelBase$$1) {  function Model ( parent, key ) {   ModelBase$$1.call( this, parent );
this.ticker = null;
if ( parent ) {    this.key = unescapeKey( key );    this.isReadonly = parent.isReadonly;
if ( parent.value ) {     this.value = parent.value[ this.key ];     if ( Array.isArray( this.value ) ) { this.length = this.value.length; }     this.adapt();    }   }  }
if ( ModelBase$$1 ) Model.__proto__ = ModelBase$$1;  Model.prototype = Object.create( ModelBase$$1 && ModelBase$$1.prototype );  Model.prototype.constructor = Model;
Model.prototype.adapt = function adapt () {   var this$1 = this;
var adaptors = this.root.adaptors;   var len = adaptors.length;
this.rewrap = false;
// Exit early if no adaptors   if ( len === 0 ) { return; }
var value = this.wrapper ? ( 'newWrapperValue' in this ? this.newWrapperValue : this.wrapperValue ) : this.value;
// TODO remove this legacy nonsense   var ractive = this.root.ractive;   var keypath = this.getKeypath();
// tear previous adaptor down if present   if ( this.wrapper ) {    var shouldTeardown = this.wrapperValue === value ? false : !this.wrapper.reset || this.wrapper.reset( value ) === false;
if ( shouldTeardown ) {     this.wrapper.teardown();     this.wrapper = null;
// don't branch for undefined values     if ( this.value !== undefined ) {      var parentValue = this.parent.value || this.parent.createBranch( this.key );      if ( parentValue[ this.key ] !== value ) { parentValue[ this.key ] = value; }     }    } else {     delete this.newWrapperValue;     this.wrapperValue = value;     this.value = this.wrapper.get();     return;    }   }
var i;
for ( i = 0; i < len; i += 1 ) {    var adaptor = adaptors[i];    if ( adaptor.filter( value, keypath, ractive ) ) {     this$1.wrapper = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );     this$1.wrapperValue = value;     this$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor
this$1.value = this$1.wrapper.get();
break;    }   }  };
Model.prototype.animate = function animate ( from, to, options, interpolator ) {   var this$1 = this;
if ( this.ticker ) { this.ticker.stop(); }
var fulfilPromise;   var promise = new Promise( function (fulfil) { return fulfilPromise = fulfil; } );
this.ticker = new Ticker({    duration: options.duration,    easing: options.easing,    step: function (t) {     var value = interpolator( t );     this$1.applyValue( value );     if ( options.step ) { options.step( t, value ); }    },    complete: function () {     this$1.applyValue( to );     if ( options.complete ) { options.complete( to ); }
this$1.ticker = null;     fulfilPromise();    }   });
promise.stop = this.ticker.stop;   return promise;  };
Model.prototype.applyValue = function applyValue ( value, notify ) {   if ( notify === void 0 ) notify = true;
if ( isEqual( value, this.value ) ) { return; }   if ( this.boundValue ) { this.boundValue = null; }
if ( this.parent.wrapper && this.parent.wrapper.set ) {    this.parent.wrapper.set( this.key, value );    this.parent.value = this.parent.wrapper.get();
this.value = this.parent.value[ this.key ];    if ( this.wrapper ) { this.newWrapperValue = this.value; }    this.adapt();   } else if ( this.wrapper ) {    this.newWrapperValue = value;    this.adapt();   } else {    var parentValue = this.parent.value || this.parent.createBranch( this.key );    if ( isObjectLike( parentValue ) ) {     parentValue[ this.key ] = value;    } else {     warnIfDebug( ("Attempted to set a property of a non-object '" + (this.getKeypath()) + "'") );     return;    }
this.value = value;    this.adapt();   }
// keep track of array stuff   if ( Array.isArray( value ) ) {    this.length = value.length;    this.isArray = true;   } else {    this.isArray = false;   }
// notify dependants   this.links.forEach( handleChange );   this.children.forEach( mark );   this.deps.forEach( handleChange );
if ( notify ) { this.notifyUpstream(); }
if ( this.parent.isArray ) {    if ( this.key === 'length' ) { this.parent.length = value; }    else { this.parent.joinKey( 'length' ).mark(); }   }  };
Model.prototype.createBranch = function createBranch ( key ) {   var branch = isNumeric( key ) ? [] : {};   this.applyValue( branch, false );
return branch;  };
Model.prototype.get = function get ( shouldCapture, opts ) {   if ( this._link ) { return this._link.get( shouldCapture, opts ); }   if ( shouldCapture ) { capture( this ); }   // if capturing, this value needs to be unwrapped because it's for external use   if ( opts && opts.virtual ) { return this.getVirtual( false ); }   return maybeBind( this, ( ( opts && 'unwrap' in opts ) ? opts.unwrap !== false : shouldCapture ) && this.wrapper ? this.wrapperValue : this.value, !opts || opts.shouldBind !== false );  };
Model.prototype.getKeypathModel = function getKeypathModel () {   if ( !this.keypathModel ) { this.keypathModel = new KeypathModel( this ); }   return this.keypathModel;  };
Model.prototype.joinKey = function joinKey ( key, opts ) {   if ( this._link ) {    if ( opts && opts.lastLink !== false && ( key === undefined || key === ) ) { return this; } return this._link.joinKey( key );   }
if ( key === undefined || key === ) { return this; }
if ( !this.childByKey.hasOwnProperty( key ) ) {    var child = new Model( this, key );    this.children.push( child );    this.childByKey[ key ] = child;   }
if ( this.childByKey[ key ]._link && ( !opts || opts.lastLink !== false ) ) { return this.childByKey[ key ]._link; }   return this.childByKey[ key ];  };
Model.prototype.mark = function mark$1 ( force ) {   if ( this._link ) { return this._link.mark(); }
var value = this.retrieve();
if ( force || !isEqual( value, this.value ) ) {    var old = this.value;    this.value = value;    if ( this.boundValue ) { this.boundValue = null; }
// make sure the wrapper stays in sync    if ( old !== value || this.rewrap ) {     if ( this.wrapper ) { this.newWrapperValue = value; }     this.adapt();    }
// keep track of array stuff if ( Array.isArray( value ) ) {     this.length = value.length;     this.isArray = true;    } else {     this.isArray = false;    }
this.children.forEach( mark );    this.links.forEach( marked );
this.deps.forEach( handleChange );   }  };
Model.prototype.merge = function merge ( array, comparator ) {   var oldArray = this.value;   var newArray = array;   if ( oldArray === newArray ) { oldArray = recreateArray( this ); }   if ( comparator ) {    oldArray = oldArray.map( comparator );    newArray = newArray.map( comparator );   }
var oldLength = oldArray.length;
var usedIndices = {};   var firstUnusedIndex = 0;
var newIndices = oldArray.map( function (item) {    var index;    var start = firstUnusedIndex;
do {     index = newArray.indexOf( item, start );
if ( index === -1 ) {      return -1;     }
start = index + 1;    } while ( ( usedIndices[ index ] === true ) && start < oldLength );
// keep track of the first unused index, so we don't search    // the whole of newArray for each item in oldArray unnecessarily    if ( index === firstUnusedIndex ) {     firstUnusedIndex += 1;    }    // allow next instance of next "equal" to be found item    usedIndices[ index ] = true;    return index;   });
this.parent.value[ this.key ] = array;   this.shuffle( newIndices );  };
Model.prototype.retrieve = function retrieve () {   return this.parent.value ? this.parent.value[ this.key ] : undefined;  };
Model.prototype.set = function set ( value ) {   if ( this.ticker ) { this.ticker.stop(); }   this.applyValue( value );  };
Model.prototype.shuffle = function shuffle$1 ( newIndices ) {   shuffle( this, newIndices, false );  };
Model.prototype.source = function source () { return this; };
Model.prototype.teardown = function teardown$1 () {   if ( this._link ) { this._link.teardown(); }   this.children.forEach( teardown );   if ( this.wrapper ) { this.wrapper.teardown(); }   if ( this.keypathModel ) { this.keypathModel.teardown(); }  };
return Model; }(ModelBase));
function recreateArray( model ) {  var array = [];
for ( var i = 0; i < model.length; i++ ) {   array[ i ] = (model.childByKey[i] || {}).value;  }
return array; }
/* global global */ var data = {};
var SharedModel = (function (Model$$1) {  function SharedModel ( value, name ) {   Model$$1.call( this, null, ("@" + name) );   this.key = "@" + name;   this.value = value;   this.isRoot = true;   this.root = this;   this.adaptors = [];  }
if ( Model$$1 ) SharedModel.__proto__ = Model$$1;  SharedModel.prototype = Object.create( Model$$1 && Model$$1.prototype );  SharedModel.prototype.constructor = SharedModel;
SharedModel.prototype.getKeypath = function getKeypath () {   return this.key;  };
return SharedModel; }(Model));
var SharedModel$1 = new SharedModel( data, 'shared' );
var GlobalModel = new SharedModel( typeof global !== 'undefined' ? global : window, 'global' );
function resolveReference ( fragment, ref ) {  var initialFragment = fragment;  // current context ref  if ( ref === '.' ) { return fragment.findContext(); }
// ancestor references  if ( ref[0] === '~' ) { return fragment.ractive.viewmodel.joinAll( splitKeypath( ref.slice( 2 ) ) ); }
// scoped references  if ( ref[0] === '.' || ref[0] === '^' ) {   var frag = fragment;   var parts = ref.split( '/' );   var explicitContext = parts[0] === '^^';   var context$1 = explicitContext ? null : fragment.findContext();
// account for the first context hop   if ( explicitContext ) { parts.unshift( '^^' ); }
// walk up the context chain   while ( parts[0] === '^^' ) {    parts.shift();    context$1 = null;    while ( frag && !context$1 ) {     context$1 = frag.context;     frag = frag.parent.component ? frag.parent.component.parentFragment : frag.parent;    }   }
if ( !context$1 && explicitContext ) {    throw new Error( ("Invalid context parent reference ('" + ref + "'). There is not context at that level.") );   }
// walk up the context path   while ( parts[0] === '.' || parts[0] === '..' ) {    var part = parts.shift();
if ( part === '..' ) {     context$1 = context$1.parent;    }   }
ref = parts.join( '/' );
// special case - ` Template:.foo ` means the same as `{{./foo}}`   if ( ref[0] === '.' ) { ref = ref.slice( 1 ); }   return context$1.joinAll( splitKeypath( ref ) );  }
var keys = splitKeypath( ref );  if ( !keys.length ) { return; }  var base = keys.shift();
// special refs  if ( base[0] === '@' ) {   // shorthand from outside the template   // @this referring to local ractive instance   if ( base === '@this' || base === '@' ) {    return fragment.ractive.viewmodel.getRactiveModel().joinAll( keys );   }
// @index or @key referring to the nearest repeating index or key   else if ( base === '@index' || base === '@key' ) {    if ( keys.length ) { badReference( base ); }    var repeater = fragment.findRepeatingFragment();    // make sure the found fragment is actually an iteration    if ( !repeater.isIteration ) { return; }    return repeater.context.getKeyModel( repeater[ ref[1] === 'i' ? 'index' : 'key' ] );   }
// @global referring to window or global   else if ( base === '@global' ) {    return GlobalModel.joinAll( keys );   }
// @global referring to window or global   else if ( base === '@shared' ) {    return SharedModel$1.joinAll( keys );   }
// @keypath or @rootpath, the current keypath string   else if ( base === '@keypath' || base === '@rootpath' ) {    var root = ref[1] === 'r' ? fragment.ractive.root : null;    var context$2 = fragment.findContext();
// skip over component roots, which provide no context    while ( root && context$2.isRoot && context$2.ractive.component ) {     context$2 = context$2.ractive.component.parentFragment.findContext();    }
return context$2.getKeypathModel( root );   }
else if ( base === '@context' ) {    return new ContextModel( fragment.getContext() );   }
// @context-local data   else if ( base === '@local' ) {    return fragment.getContext()._data.joinAll( keys );   }
// nope   else {    throw new Error( ("Invalid special reference '" + base + "'") );   }  }
var context = fragment.findContext();
// check immediate context for a match  if ( context.has( base ) ) {   return context.joinKey( base ).joinAll( keys );  }
// walk up the fragment hierarchy looking for a matching ref, alias, or key in a context  var createMapping = false;  var shouldWarn = fragment.ractive.warnAboutAmbiguity;
while ( fragment ) {   // repeated fragments   if ( fragment.isIteration ) {    if ( base === fragment.parent.keyRef ) {     if ( keys.length ) { badReference( base ); }     return fragment.context.getKeyModel( fragment.key );    }
if ( base === fragment.parent.indexRef ) {     if ( keys.length ) { badReference( base ); }     return fragment.context.getKeyModel( fragment.index );    }   }
// alias node or iteration   if ( fragment.aliases && fragment.aliases.hasOwnProperty( base ) ) {    var model = fragment.aliases[ base ];
if ( keys.length === 0 ) { return model; }    else if ( typeof model.joinAll === 'function' ) {     return model.joinAll( keys );    }   }
// check fragment context to see if it has the key we need   if ( fragment.context && fragment.context.has( base ) ) {    // this is an implicit mapping    if ( createMapping ) {     if ( shouldWarn ) { warnIfDebug( ("'" + ref + "' resolved but is ambiguous and will create a mapping to a parent component.") ); }     return context.root.createLink( base, fragment.context.joinKey( base ), base, { implicit: true }).joinAll( keys );    }
if ( shouldWarn ) { warnIfDebug( ("'" + ref + "' resolved but is ambiguous.") ); }    return fragment.context.joinKey( base ).joinAll( keys );   }
if ( ( fragment.componentParent || ( !fragment.parent && fragment.ractive.component ) ) && !fragment.ractive.isolated ) {    // ascend through component boundary    fragment = fragment.componentParent || fragment.ractive.component.parentFragment;    createMapping = true;   } else {    fragment = fragment.parent;   }  }
// if enabled, check the instance for a match  if ( initialFragment.ractive.resolveInstanceMembers ) {   var model$1 = initialFragment.ractive.viewmodel.getRactiveModel();   if ( model$1.has( base ) ) {    return model$1.joinKey( base ).joinAll( keys );   }  }
if ( shouldWarn ) {   warnIfDebug( ("'" + ref + "' is ambiguous and did not resolve.") );  }
// didn't find anything, so go ahead and create the key on the local model  return context.joinKey( base ).joinAll( keys ); }
function badReference ( key ) {  throw new Error( ("An index or key reference (" + key + ") cannot have child properties") ); }
var ContextModel = function ContextModel ( context ) {  this.context = context; };
ContextModel.prototype.get = function get () { return this.context; };
var extern = {};
function getRactiveContext ( ractive ) {  var assigns = [], len = arguments.length - 1;  while ( len-- > 0 ) assigns[ len ] = arguments[ len + 1 ];
var fragment = ractive.fragment || ractive._fakeFragment || ( ractive._fakeFragment = new FakeFragment( ractive ) );  return fragment.getContext.apply( fragment, assigns ); }
function getContext () {  var assigns = [], len = arguments.length;  while ( len-- ) assigns[ len ] = arguments[ len ];
if ( !this.ctx ) { this.ctx = new extern.Context( this ); }  assigns.unshift( Object.create( this.ctx ) );  return Object.assign.apply( null, assigns ); }
var FakeFragment = function FakeFragment ( ractive ) {  this.ractive = ractive; };
FakeFragment.prototype.findContext = function findContext () { return this.ractive.viewmodel; }; var proto = FakeFragment.prototype; proto.getContext = getContext; proto.find = proto.findComponent = proto.findAll = proto.findAllComponents = noop;
var keep = false;
function set ( ractive, pairs, options ) {  var k = keep;
var deep = options && options.deep;  var shuffle = options && options.shuffle;  var promise = runloop.start( ractive, true );  if ( options && 'keep' in options ) { keep = options.keep; }
var i = pairs.length;  while ( i-- ) {   var model = pairs[i][0];   var value = pairs[i][1];   var keypath = pairs[i][2];
if ( !model ) {    runloop.end();    throw new Error( ("Failed to set invalid keypath '" + keypath + "'") );   }
if ( deep ) { deepSet( model, value ); }   else if ( shuffle ) {    var array = value;    var target = model.get();    // shuffle target array with itself    if ( !array ) { array = target; }
if ( !Array.isArray( target ) || !Array.isArray( array ) ) {     throw new Error( 'You cannot merge an array with a non-array' );    }
var comparator = getComparator( shuffle );    model.merge( array, comparator );   } else { model.set( value ); }  }
runloop.end();
keep = k;
return promise; }
var star = /\*/; function gather ( ractive, keypath, base, isolated ) {  if ( !base && ( keypath[0] === '.' || keypath[1] === '^' ) ) {   warnIfDebug( "Attempted to set a relative keypath from a non-relative context. You can use a context object to set relative keypaths." );   return [];  }
var keys = splitKeypath( keypath );  var model = base || ractive.viewmodel;
if ( star.test( keypath ) ) {   return model.findMatches( keys );  } else {   if ( model === ractive.viewmodel ) {    // allow implicit mappings    if ( ractive.component && !ractive.isolated && !model.has( keys[0] ) && keypath[0] !== '@' && keypath[0] && !isolated ) {     return [ resolveReference( ractive.fragment || new FakeFragment( ractive ), keypath ) ];    } else {     return [ model.joinAll( keys ) ];    }   } else {    return [ model.joinAll( keys ) ];   }  } }
function build ( ractive, keypath, value, isolated ) {  var sets = [];
// set multiple keypaths in one go  if ( isObject( keypath ) ) {   var loop = function ( k ) {    if ( keypath.hasOwnProperty( k ) ) {     sets.push.apply( sets, gather( ractive, k, null, isolated ).map( function (m) { return [ m, keypath[k], k ]; } ) );    }   };
for ( var k in keypath ) loop( k );
}  // set a single keypath  else {   sets.push.apply( sets, gather( ractive, keypath, null, isolated ).map( function (m) { return [ m, value, keypath ]; } ) );  }
return sets; }
var deepOpts = { virtual: false }; function deepSet( model, value ) {  var dest = model.get( false, deepOpts );
// if dest doesn't exist, just set it  if ( dest == null || typeof value !== 'object' ) { return model.set( value ); }  if ( typeof dest !== 'object' ) { return model.set( value ); }
for ( var k in value ) {   if ( value.hasOwnProperty( k ) ) {    deepSet( model.joinKey( k ), value[k] );   }  } }
var comparators = {}; function getComparator ( option ) {  if ( option === true ) { return null; } // use existing arrays  if ( typeof option === 'function' ) { return option; }
if ( typeof option === 'string' ) {   return comparators[ option ] || ( comparators[ option ] = function (thing) { return thing[ option ]; } );  }
throw new Error( 'If supplied, options.compare must be a string, function, or true' ); // TODO link to docs }
var errorMessage = 'Cannot add to a non-numeric value';
function add ( ractive, keypath, d, options ) {  if ( typeof keypath !== 'string' || !isNumeric( d ) ) {   throw new Error( 'Bad arguments' );  }
var sets = build( ractive, keypath, d, options && options.isolated );
return set( ractive, sets.map( function (pair) {   var model = pair[0];   var add = pair[1];   var value = model.get();   if ( !isNumeric( add ) || !isNumeric( value ) ) { throw new Error( errorMessage ); }   return [ model, value + add ];  })); }
function Ractive$add ( keypath, d, options ) {  var num = typeof d === 'number' ? d : 1;  var opts = typeof d === 'object' ? d : options;  return add( this, keypath, num, opts ); }
var noAnimation = Promise.resolve(); Object.defineProperty( noAnimation, 'stop', { value: noop });
var linear = easing.linear;
function getOptions ( options, instance ) {  options = options || {};
var easing$$1;  if ( options.easing ) {   easing$$1 = typeof options.easing === 'function' ?    options.easing :    instance.easing[ options.easing ];  }
return {   easing: easing$$1 || linear,   duration: 'duration' in options ? options.duration : 400,   complete: options.complete || noop,   step: options.step || noop  }; }
function animate ( ractive, model, to, options ) {  options = getOptions( options, ractive );  var from = model.get();
// don't bother animating values that stay the same  if ( isEqual( from, to ) ) {   options.complete( options.to );   return noAnimation; // TODO should this have .then and .catch methods?  }
var interpolator = interpolate( from, to, ractive, options.interpolator );
// if we can't interpolate the value, set it immediately  if ( !interpolator ) {   runloop.start();   model.set( to );   runloop.end();
return noAnimation;  }
return model.animate( from, to, options, interpolator ); }
function Ractive$animate ( keypath, to, options ) {  if ( typeof keypath === 'object' ) {   var keys = Object.keys( keypath );
throw new Error( ("ractive.animate(...) no longer supports objects. Instead of ractive.animate({\n  " + (keys.map( function (key) { return ("'" + key + "': " + (keypath[ key ])); } ).join( '\n  ' )) + "\n}, {...}), do\n\n" + (keys.map( function (key) { return ("ractive.animate('" + key + "', " + (keypath[ key ]) + ", {...});"); } ).join( '\n' )) + "\n") );  }
return animate( this, this.viewmodel.joinAll( splitKeypath( keypath ) ), to, options ); }
function enqueue ( ractive, event ) {  if ( ractive.event ) {   ractive._eventQueue.push( ractive.event );  }
ractive.event = event; }
function dequeue ( ractive ) {  if ( ractive._eventQueue.length ) {   ractive.event = ractive._eventQueue.pop();  } else {   ractive.event = null;  } }
var initStars = {}; var bubbleStars = {};
// cartesian product of name parts and stars // adjusted appropriately for special cases function variants ( name, initial ) {  var map = initial ? initStars : bubbleStars;  if ( map[ name ] ) { return map[ name ]; }
var parts = name.split( '.' );  var result = [];  var base = false;
// initial events the implicit namespace of 'this'  if ( initial ) {   parts.unshift( 'this' );   base = true;  }
// use max - 1 bits as a bitmap to pick a part or a *  // need to skip the full star case if the namespace is synthetic  var max = Math.pow( 2, parts.length ) - ( initial ? 1 : 0 );  for ( var i = 0; i < max; i++ ) {   var join = [];   for ( var j = 0; j < parts.length; j++ ) {    join.push( 1 & ( i >> j ) ? '*' : parts[j] );   }   result.unshift( join.join( '.' ) );  }
if ( base ) {   // include non-this-namespaced versions   if ( parts.length > 2 ) {    result.push.apply( result, variants( name, false ) );   } else {    result.push( '*' );    result.push( name );   }  }
map[ name ] = result;  return result; }
function fireEvent ( ractive, eventName, context, args ) {  if ( args === void 0 ) args = [];
if ( !eventName ) { return; }
context.name = eventName;  args.unshift( context );
var eventNames = ractive._nsSubs ? variants( eventName, true ) : [ '*', eventName ];
return fireEventAs( ractive, eventNames, context, args, true ); }
function fireEventAs  ( ractive, eventNames, context, args, initialFire ) {  if ( initialFire === void 0 ) initialFire = false;
var bubble = true;
if ( initialFire || ractive._nsSubs ) {   enqueue( ractive, context );
var i = eventNames.length;   while ( i-- ) {    if ( eventNames[ i ] in ractive._subs ) {     bubble = notifySubscribers( ractive, ractive._subs[ eventNames[ i ] ], context, args ) && bubble;    }   }
dequeue( ractive );  }
if ( ractive.parent && bubble ) {   if ( initialFire && ractive.component ) {    var fullName = ractive.component.name + '.' + eventNames[ eventNames.length - 1 ];    eventNames = variants( fullName, false );
if ( context && !context.component ) {     context.component = ractive;    }   }
bubble = fireEventAs( ractive.parent, eventNames, context, args );  }
return bubble; }
function notifySubscribers ( ractive, subscribers, context, args ) {  var originalEvent = null;  var stopEvent = false;
// subscribers can be modified inflight, e.g. "once" functionality  // so we need to copy to make sure everyone gets called  subscribers = subscribers.slice();
for ( var i = 0, len = subscribers.length; i < len; i += 1 ) {   if ( !subscribers[ i ].off && subscribers[ i ].handler.apply( ractive, args ) === false ) {    stopEvent = true;   }  }
if ( context && stopEvent && ( originalEvent = context.event ) ) {   originalEvent.preventDefault && originalEvent.preventDefault();   originalEvent.stopPropagation && originalEvent.stopPropagation();  }
return !stopEvent; }
var Hook = function Hook ( event ) {  this.event = event;  this.method = 'on' + event; };
Hook.prototype.fire = function fire ( ractive, arg ) {  var context = getRactiveContext( ractive );
if ( ractive[ this.method ] ) {   arg ? ractive[ this.method ]( context, arg ) : ractive[ this.method ]( context );  }
fireEvent( ractive, this.event, context, arg ? [ arg, ractive ] : [ ractive ] ); };
function findAnchors ( fragment, name ) {  if ( name === void 0 ) name = null;
var res = [];
findAnchorsIn( fragment, name, res );
return res; }
function findAnchorsIn ( item, name, result ) {  if ( item.isAnchor ) {   if ( !name || item.name === name ) {    result.push( item );   }  } else if ( item.items ) {   item.items.forEach( function (i) { return findAnchorsIn( i, name, result ); } );  } else if ( item.iterations ) {   item.iterations.forEach( function (i) { return findAnchorsIn( i, name, result ); } );  } else if ( item.fragment && !item.component ) {   findAnchorsIn( item.fragment, name, result );  } }
function updateAnchors ( instance, name ) {  if ( name === void 0 ) name = null;
var anchors = findAnchors( instance.fragment, name );  var idxs = {};  var children = instance._children.byName;
anchors.forEach( function (a) {   var name = a.name;   if ( !( name in idxs ) ) { idxs[name] = 0; }   var idx = idxs[name];   var child = ( children[name] || [] )[idx];
if ( child && child.lastBound !== a ) {    if ( child.lastBound ) { child.lastBound.removeChild( child ); }    a.addChild( child );   }
idxs[name]++;  }); }
function unrenderChild ( meta ) {  if ( meta.instance.fragment.rendered ) {   meta.shouldDestroy = true;   meta.instance.unrender();  }  meta.instance.el = null; }
var attachHook = new Hook( 'attachchild' );
function attachChild ( child, options ) {  if ( options === void 0 ) options = {};
var children = this._children;
if ( child.parent && child.parent !== this ) { throw new Error( ("Instance " + (child._guid) + " is already attached to a different instance " + (child.parent._guid) + ". Please detach it from the other instance using detachChild first.") ); }  else if ( child.parent ) { throw new Error( ("Instance " + (child._guid) + " is already attached to this instance.") ); }
var meta = {   instance: child,   ractive: this,   name: options.name || child.constructor.name || 'Ractive',   target: options.target || false,   bubble: bubble,   findNextNode: findNextNode  };  meta.nameOption = options.name;
// child is managing itself  if ( !meta.target ) {   meta.parentFragment = this.fragment;   meta.external = true;  } else {   var list;   if ( !( list = children.byName[ meta.target ] ) ) {    list = [];    this.set( ("@this.children.byName." + (meta.target)), list );   }   var idx = options.prepend ? 0 : options.insertAt !== undefined ? options.insertAt : list.length;   list.splice( idx, 0, meta );  }
child.set({   '@this.parent': this,   '@this.root': this.root  });  child.component = meta;  children.push( meta );
attachHook.fire( child );
var promise = runloop.start( child, true );
if ( meta.target ) {   unrenderChild( meta );   this.set( ("@this.children.byName." + (meta.target)), null, { shuffle: true } );   updateAnchors( this, meta.target );  } else {   if ( !child.isolated ) { child.viewmodel.attached( this.fragment ); }  }
runloop.end();
promise.ractive = child;  return promise.then( function () { return child; } ); }
function bubble () { runloop.addFragment( this.instance.fragment ); }
function findNextNode () {  if ( this.anchor ) { return this.anchor.findNextNode(); } }
var detachHook = new Hook( 'detach' );
function Ractive$detach () {  if ( this.isDetached ) {   return this.el;  }
if ( this.el ) {   removeFromArray( this.el.__ractive_instances__, this );  }
this.el = this.fragment.detach();  this.isDetached = true;
detachHook.fire( this );  return this.el; }
var detachHook$1 = new Hook( 'detachchild' );
function detachChild ( child ) {  var children = this._children;  var meta, index;
var i = children.length;  while ( i-- ) {   if ( children[i].instance === child ) {    index = i;    meta = children[i];    break;   }  }
if ( !meta || child.parent !== this ) { throw new Error( ("Instance " + (child._guid) + " is not attached to this instance.") ); }
var promise = runloop.start( child, true );
if ( meta.anchor ) { meta.anchor.removeChild( meta ); }  if ( !child.isolated ) { child.viewmodel.detached(); }
runloop.end();
children.splice( index, 1 );  if ( meta.target ) {   var list = children.byName[ meta.target ];   list.splice( list.indexOf( meta ), 1 );   this.set( ("@this.children.byName." + (meta.target)), null, { shuffle: true } );   updateAnchors( this, meta.target );  }  child.set({   '@this.parent': undefined,   '@this.root': child  });  child.component = null;
detachHook$1.fire( child );
promise.ractive = child;  return promise.then( function () { return child; } ); }
function Ractive$find ( selector, options ) {  var this$1 = this;  if ( options === void 0 ) options = {};
if ( !this.el ) { throw new Error( ("Cannot call ractive.find('" + selector + "') unless instance is rendered to the DOM") ); }
var node = this.fragment.find( selector, options );  if ( node ) { return node; }
if ( options.remote ) {   for ( var i = 0; i < this._children.length; i++ ) {    if ( !this$1._children[i].instance.fragment.rendered ) { continue; }    node = this$1._children[i].instance.find( selector, options );    if ( node ) { return node; }   }  } }
function Ractive$findAll ( selector, options ) {  if ( options === void 0 ) options = {};
if ( !this.el ) { throw new Error( ("Cannot call ractive.findAll('" + selector + "', ...) unless instance is rendered to the DOM") ); }
if ( !Array.isArray( options.result ) ) { options.result = []; }
this.fragment.findAll( selector, options );
if ( options.remote ) {   // seach non-fragment children   this._children.forEach( function (c) {    if ( !c.target && c.instance.fragment && c.instance.fragment.rendered ) {     c.instance.findAll( selector, options );    }   });  }
return options.result; }
function Ractive$findAllComponents ( selector, options ) {  if ( !options && typeof selector === 'object' ) {   options = selector;   selector = ; }
options = options || {};
if ( !Array.isArray( options.result ) ) { options.result = []; }
this.fragment.findAllComponents( selector, options );
if ( options.remote ) {   // search non-fragment children   this._children.forEach( function (c) {    if ( !c.target && c.instance.fragment && c.instance.fragment.rendered ) {     if ( !selector || c.name === selector ) {      options.result.push( c.instance );     }
c.instance.findAllComponents( selector, options );    }   });  }
return options.result; }
function Ractive$findComponent ( selector, options ) {  var this$1 = this;  if ( options === void 0 ) options = {};
if ( typeof selector === 'object' ) {   options = selector;   selector = ; }
var child = this.fragment.findComponent( selector, options );  if ( child ) { return child; }
if ( options.remote ) {   if ( !selector && this._children.length ) { return this._children[0].instance; }   for ( var i = 0; i < this._children.length; i++ ) {    // skip children that are or should be in an anchor    if ( this$1._children[i].target ) { continue; }    if ( this$1._children[i].name === selector ) { return this$1._children[i].instance; }    child = this$1._children[i].instance.findComponent( selector, options );    if ( child ) { return child; }   }  } }
function Ractive$findContainer ( selector ) {  if ( this.container ) {   if ( this.container.component && this.container.component.name === selector ) {    return this.container;   } else {    return this.container.findContainer( selector );   }  }
return null; }
function Ractive$findParent ( selector ) {
if ( this.parent ) {   if ( this.parent.component && this.parent.component.name === selector ) {    return this.parent;   } else {    return this.parent.findParent ( selector );   }  }
return null; }
// This function takes an array, the name of a mutator method, and the // arguments to call that mutator method with, and returns an array that // maps the old indices to their new indices.
// So if you had something like this... // //     array = [ 'a', 'b', 'c', 'd' ]; //     array.push( 'e' ); // // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices // have changed. If you then did this... // //     array.unshift( 'z' ); // // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved // one higher to make room for the 'z'. If you removed an item, the new index // would be -1... // //     array.splice( 2, 2 ); // // ...this would result in [ 0, 1, -1, -1, 2, 3 ]. // // This information is used to enable fast, non-destructive shuffling of list // sections when you do e.g. `ractive.splice( 'items', 2, 2 );
function getNewIndices ( length, methodName, args ) {  var newIndices = [];
var spliceArguments = getSpliceEquivalent( length, methodName, args );
if ( !spliceArguments ) {   return null; // TODO support reverse and sort?  }
var balance = ( spliceArguments.length - 2 ) - spliceArguments[1];
var removeStart = Math.min( length, spliceArguments[0] );  var removeEnd = removeStart + spliceArguments[1];  newIndices.startIndex = removeStart;
var i;  for ( i = 0; i < removeStart; i += 1 ) {   newIndices.push( i );  }
for ( ; i < removeEnd; i += 1 ) {   newIndices.push( -1 );  }
for ( ; i < length; i += 1 ) {   newIndices.push( i + balance );  }
// there is a net shift for the rest of the array starting with index + balance  if ( balance !== 0 ) {   newIndices.touchedFrom = spliceArguments[0];  } else {   newIndices.touchedFrom = length;  }
return newIndices; }
// The pop, push, shift an unshift methods can all be represented // as an equivalent splice function getSpliceEquivalent ( length, methodName, args ) {  switch ( methodName ) {   case 'splice':    if ( args[0] !== undefined && args[0] < 0 ) {     args[0] = length + Math.max( args[0], -length );    }
if ( args[0] === undefined ) { args[0] = 0; }
while ( args.length < 2 ) {     args.push( length - args[0] );    }
if ( typeof args[1] !== 'number' ) {     args[1] = length - args[0];    }
// ensure we only remove elements that exist    args[1] = Math.min( args[1], length - args[0] );
return args;
case 'sort':   case 'reverse':    return null;
case 'pop':    if ( length ) {     return [ length - 1, 1 ];    }    return [ 0, 0 ];
case 'push':    return [ length, 0 ].concat( args );
case 'shift':    return [ 0, length ? 1 : 0 ];
case 'unshift':    return [ 0, 0 ].concat( args );  } }
var arrayProto = Array.prototype;
var makeArrayMethod = function ( methodName ) {  function path ( keypath ) {   var args = [], len = arguments.length - 1;   while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
return model( this.viewmodel.joinAll( splitKeypath( keypath ) ), args );  }
function model ( mdl, args ) {   var array = mdl.get();
if ( !Array.isArray( array ) ) {    if ( array === undefined ) {     array = [];     var result$1 = arrayProto[ methodName ].apply( array, args );     var promise$1 = runloop.start( this, true ).then( function () { return result$1; } );     mdl.set( array );     runloop.end();     return promise$1;    } else {     throw new Error( ("shuffle array method " + methodName + " called on non-array at " + (mdl.getKeypath())) ); }   }
var newIndices = getNewIndices( array.length, methodName, args );   var result = arrayProto[ methodName ].apply( array, args );
var promise = runloop.start( this, true ).then( function () { return result; } );   promise.result = result;
if ( newIndices ) {    mdl.shuffle( newIndices );   } else {    mdl.set( result );   }
runloop.end();
return promise;  }
return { path: path, model: model }; };
var updateHook = new Hook( 'update' );
function update$1 ( ractive, model, options ) {  // if the parent is wrapped, the adaptor will need to be updated before  // updating on this keypath  if ( model.parent && model.parent.wrapper ) {   model.parent.adapt();  }
var promise = runloop.start( ractive, true );
model.mark( options && options.force );
// notify upstream of changes  model.notifyUpstream();
runloop.end();
updateHook.fire( ractive, model );
return promise; }
function Ractive$update ( keypath, options ) {  var opts, path;
if ( typeof keypath === 'string' ) {   path = splitKeypath( keypath );   opts = options;  } else {   opts = keypath;  }
return update$1( this, path ? this.viewmodel.joinAll( path ) : this.viewmodel, opts ); }
var TEXT              = 1; var INTERPOLATOR      = 2; var TRIPLE            = 3; var SECTION           = 4; var INVERTED          = 5; var CLOSING           = 6; var ELEMENT           = 7; var PARTIAL           = 8; var COMMENT           = 9; var DELIMCHANGE       = 10; var ANCHOR            = 11; var ATTRIBUTE         = 13; var CLOSING_TAG       = 14; var COMPONENT         = 15; var YIELDER           = 16; var INLINE_PARTIAL    = 17; var DOCTYPE           = 18; var ALIAS             = 19;
var NUMBER_LITERAL    = 20; var STRING_LITERAL    = 21; var ARRAY_LITERAL     = 22; var OBJECT_LITERAL    = 23; var BOOLEAN_LITERAL   = 24; var REGEXP_LITERAL    = 25;
var GLOBAL            = 26; var KEY_VALUE_PAIR = 27;
var REFERENCE         = 30; var REFINEMENT        = 31; var MEMBER            = 32; var PREFIX_OPERATOR   = 33; var BRACKETED         = 34; var CONDITIONAL       = 35; var INFIX_OPERATOR    = 36;
var INVOCATION        = 40;
var SECTION_IF        = 50; var SECTION_UNLESS    = 51; var SECTION_EACH      = 52; var SECTION_WITH      = 53; var SECTION_IF_WITH   = 54;
var ELSE              = 60; var ELSEIF            = 61;
var EVENT             = 70; var DECORATOR         = 71; var TRANSITION        = 72; var BINDING_FLAG      = 73; var DELEGATE_FLAG     = 74;
function findElement( start, orComponent, name ) {  if ( orComponent === void 0 ) orComponent = true;
while ( start && ( start.type !== ELEMENT || ( name && start.name !== name ) ) && ( !orComponent || ( start.type !== COMPONENT && start.type !== ANCHOR ) ) ) {   // start is a fragment - look at the owner   if ( start.owner ) { start = start.owner; }   // start is a component or yielder - look at the container   else if ( start.component ) { start = start.containerFragment || start.component.parentFragment; }   // start is an item - look at the parent   else if ( start.parent ) { start = start.parent; }   // start is an item without a parent - look at the parent fragment   else if ( start.parentFragment ) { start = start.parentFragment; }
else { start = undefined; }  }
return start; }
var modelPush = makeArrayMethod( 'push' ).model; var modelPop = makeArrayMethod( 'pop' ).model; var modelShift = makeArrayMethod( 'shift' ).model; var modelUnshift = makeArrayMethod( 'unshift' ).model; var modelSort = makeArrayMethod( 'sort' ).model; var modelSplice = makeArrayMethod( 'splice' ).model; var modelReverse = makeArrayMethod( 'reverse' ).model;
var ContextData = (function (Model$$1) {  function ContextData ( options ) {   Model$$1.call( this, null, null );
this.isRoot = true;   this.root = this;   this.value = {};   this.ractive = options.ractive;   this.adaptors = [];   this.context = options.context;  }
if ( Model$$1 ) ContextData.__proto__ = Model$$1;  ContextData.prototype = Object.create( Model$$1 && Model$$1.prototype );  ContextData.prototype.constructor = ContextData;
ContextData.prototype.getKeypath = function getKeypath () {   return '@context.data';  };
return ContextData; }(Model));
var Context = function Context ( fragment, element ) {  this.fragment = fragment;  this.element = element || findElement( fragment );  this.node = this.element && this.element.node;  this.ractive = fragment.ractive;  this.root = this; };
var prototypeAccessors = { decorators: {},_data: {} };
prototypeAccessors.decorators.get = function () {  var items = {};  if ( !this.element ) { return items; }  this.element.decorators.forEach( function (d) { return items[ d.name ] = d.intermediary; } );  return items; };
prototypeAccessors._data.get = function () {  return this.model || ( this.root.model = new ContextData({ ractive: this.ractive, context: this.root }) ); };
// the usual mutation suspects Context.prototype.add = function add ( keypath, d, options ) {  var num = typeof d === 'number' ? +d : 1;  var opts = typeof d === 'object' ? d : options;  return set( this.ractive, build$1( this, keypath, num ).map( function (pair) {   var model = pair[0];    var val = pair[1];   var value = model.get();   if ( !isNumeric( val ) || !isNumeric( value ) ) { throw new Error( 'Cannot add non-numeric value' ); }   return [ model, value + val ];  }), opts ); };
Context.prototype.animate = function animate$$1 ( keypath, value, options ) {  var model = findModel( this, keypath ).model;  return animate( this.ractive, model, value, options ); };
// get relative keypaths and values Context.prototype.get = function get ( keypath ) {  if ( !keypath ) { return this.fragment.findContext().get( true ); }
var ref = findModel( this, keypath );   var model = ref.model;
return model ? model.get( true ) : undefined; };
Context.prototype.link = function link ( source, dest ) {  var there = findModel( this, source ).model;  var here = findModel( this, dest ).model;  var promise = runloop.start( this.ractive, true );  here.link( there, source );  runloop.end();  return promise; };
Context.prototype.observe = function observe ( keypath, callback, options ) {   if ( options === void 0 ) options = {};
if ( isObject( keypath ) ) { options = callback || {}; }  options.fragment = this.fragment;  return this.ractive.observe( keypath, callback, options ); };
Context.prototype.observeOnce = function observeOnce ( keypath, callback, options ) {   if ( options === void 0 ) options = {};
if ( isObject( keypath ) ) { options = callback || {}; }  options.fragment = this.fragment;  return this.ractive.observeOnce( keypath, callback, options ); };
Context.prototype.pop = function pop ( keypath ) {  return modelPop( findModel( this, keypath ).model, [] ); };
Context.prototype.push = function push ( keypath ) {   var values = [], len = arguments.length - 1;   while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];
return modelPush( findModel( this, keypath ).model, values ); };
Context.prototype.raise = function raise ( name, event ) {   var args = [], len = arguments.length - 2;   while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];
var element = this.element;
while ( element ) {   var events = element.events;   for ( var i = 0; i < events.length; i++ ) {    var ev = events[i];    if ( ~ev.template.n.indexOf( name ) ) {     var ctx = !event || !( 'original' in event ) ?      ev.element.getContext( event || {}, { original: {} } ) :      ev.element.getContext( event || {} );     return ev.fire( ctx, args );    }   }
element = element.parent;  } };
Context.prototype.readLink = function readLink ( keypath, options ) {  return this.ractive.readLink( this.resolve( keypath ), options ); };
Context.prototype.resolve = function resolve ( path, ractive ) {  var ref = findModel( this, path );   var model = ref.model;   var instance = ref.instance;  return model ? model.getKeypath( ractive || instance ) : path; };
Context.prototype.reverse = function reverse ( keypath ) {  return modelReverse( findModel( this, keypath ).model, [] ); };
Context.prototype.set = function set$$1 ( keypath, value, options ) {  return set( this.ractive, build$1( this, keypath, value ), options ); };
Context.prototype.shift = function shift ( keypath ) {  return modelShift( findModel( this, keypath ).model, [] ); };
Context.prototype.splice = function splice ( keypath, index, drop ) {   var add = [], len = arguments.length - 3;   while ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];
add.unshift( index, drop );  return modelSplice( findModel( this, keypath ).model, add ); };
Context.prototype.sort = function sort ( keypath ) {  return modelSort( findModel( this, keypath ).model, [] ); };
Context.prototype.subtract = function subtract ( keypath, d, options ) {  var num = typeof d === 'number' ? d : 1;  var opts = typeof d === 'object' ? d : options;  return set( this.ractive, build$1( this, keypath, num ).map( function (pair) {   var model = pair[0];    var val = pair[1];   var value = model.get();   if ( !isNumeric( val ) || !isNumeric( value ) ) { throw new Error( 'Cannot add non-numeric value' ); }   return [ model, value - val ];  }), opts ); };
Context.prototype.toggle = function toggle ( keypath, options ) {  var ref = findModel( this, keypath );   var model = ref.model;  return set( this.ractive, [ [ model, !model.get() ] ], options ); };
Context.prototype.unlink = function unlink ( dest ) {  var here = findModel( this, dest ).model;  var promise = runloop.start( this.ractive, true );  if ( here.owner && here.owner._link ) { here.owner.unlink(); }  runloop.end();  return promise; };
Context.prototype.unshift = function unshift ( keypath ) {   var add = [], len = arguments.length - 1;   while ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];
return modelUnshift( findModel( this, keypath ).model, add ); };
Context.prototype.update = function update$$1 ( keypath, options ) {  return update$1( this.ractive, findModel( this, keypath ).model, options ); };
Context.prototype.updateModel = function updateModel ( keypath, cascade ) {  var ref = findModel( this, keypath );   var model = ref.model;  var promise = runloop.start( this.ractive, true );  model.updateFromBindings( cascade );  runloop.end();  return promise; };
// two-way binding related helpers Context.prototype.isBound = function isBound () {  var ref = this.getBindingModel( this );   var model = ref.model;  return !!model; };
Context.prototype.getBindingPath = function getBindingPath ( ractive ) {  var ref = this.getBindingModel( this );   var model = ref.model;   var instance = ref.instance;  if ( model ) { return model.getKeypath( ractive || instance ); } };
Context.prototype.getBinding = function getBinding () {  var ref = this.getBindingModel( this );   var model = ref.model;  if ( model ) { return model.get( true ); } };
Context.prototype.getBindingModel = function getBindingModel ( ctx ) {  var el = ctx.element;  return { model: el.binding && el.binding.model, instance: el.parentFragment.ractive }; };
Context.prototype.setBinding = function setBinding ( value ) {  var ref = this.getBindingModel( this );   var model = ref.model;  return set( this.ractive, [ [ model, value ] ] ); };
Object.defineProperties( Context.prototype, prototypeAccessors );
Context.forRactive = getRactiveContext; // circular deps are fun extern.Context = Context;
// TODO: at some point perhaps this could support relative * keypaths? function build$1 ( ctx, keypath, value ) {  var sets = [];
// set multiple keypaths in one go  if ( isObject( keypath ) ) {   for ( var k in keypath ) {    if ( keypath.hasOwnProperty( k ) ) {     sets.push( [ findModel( ctx, k ).model, keypath[k] ] );    }   }
}  // set a single keypath  else {   sets.push( [ findModel( ctx, keypath ).model, value ] );  }
return sets; }
function findModel ( ctx, path ) {  var frag = ctx.fragment;
if ( typeof path !== 'string' ) {   return { model: frag.findContext(), instance: path };  }
return { model: resolveReference( frag, path ), instance: frag.ractive }; }
function Ractive$fire ( eventName ) {  var args = [], len = arguments.length - 1;  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
// watch for reproxy  if ( args[0] instanceof Context ) {   var proto = args.shift();   var ctx = Object.create( proto );   Object.assign( ctx, proto );   return fireEvent( this, eventName, ctx, args );  } else {   return fireEvent( this, eventName, Context.forRactive( this ), args );  } }
function Ractive$get ( keypath, opts ) {  if ( typeof keypath !== 'string' ) { return this.viewmodel.get( true, keypath ); }
var keys = splitKeypath( keypath );  var key = keys[0];
var model;
if ( !this.viewmodel.has( key ) ) {   // if this is an inline component, we may need to create   // an implicit mapping   if ( this.component && !this.isolated ) {    model = resolveReference( this.fragment || new FakeFragment( this ), key );   }  }
model = this.viewmodel.joinAll( keys );  return model.get( true, opts ); }
var query = doc && doc.querySelector;
function getContext$2 ( node ) {  if ( typeof node === 'string' && query ) {   node = query.call( document, node );  }
var instances;  if ( node ) {   if ( node._ractive ) {    return node._ractive.proxy.getContext();   } else if ( ( instances = node.__ractive_instances__ ) && instances.length === 1 ) {    return getRactiveContext( instances[0] );   }  } }
function getNodeInfo$1 ( node ) {  warnOnceIfDebug( "getNodeInfo has been renamed to getContext, and the getNodeInfo alias will be removed in a future release." );  return getContext$2 ( node ); }
function getContext$1 ( node, options ) {  if ( typeof node === 'string' ) {   node = this.find( node, options );  }
return getContext$2( node ); }
function getNodeInfo$$1 ( node, options ) {  if ( typeof node === 'string' ) {   node = this.find( node, options );  }
return getNodeInfo$1( node ); }
var html   = ' http://www.w3.org/1999/xhtml' ; var mathml = ' http://www.w3.org/1998/Math/MathML' ; var svg$1    = ' http://www.w3.org/2000/svg' ; var xlink  = ' http://www.w3.org/1999/xlink' ; var xml    = ' http://www.w3.org/XML/1998/namespace' ; var xmlns  = ' http://www.w3.org/2000/xmlns' ;
var namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };
var createElement; var matches; var div; var methodNames; var unprefixed; var prefixed; var i; var j; var makeFunction;
// Test for SVG support if ( !svg ) {  createElement = function ( type, ns, extend ) {   if ( ns && ns !== html ) {    throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml . The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';   }
return extend ?    doc.createElement( type, extend ) :    doc.createElement( type );  }; } else {  createElement = function ( type, ns, extend ) {   if ( !ns || ns === html ) {    return extend ?     doc.createElement( type, extend ) :     doc.createElement( type );   }
return extend ?    doc.createElementNS( ns, type, extend ) :    doc.createElementNS( ns, type );  }; }
function createDocumentFragment () {  return doc.createDocumentFragment(); }
function getElement ( input ) {  var output;
if ( !input || typeof input === 'boolean' ) { return; }
if ( !win || !doc || !input ) {   return null;  }
// We already have a DOM node - no work to do. (Duck typing alert!)  if ( input.nodeType ) {   return input;  }
// Get node from string  if ( typeof input === 'string' ) {   // try ID first   output = doc.getElementById( input );
// then as selector, if possible   if ( !output && doc.querySelector ) {    output = doc.querySelector( input );   }
// did it work?   if ( output && output.nodeType ) {    return output;   }  }
// If we've been given a collection (jQuery, Zepto etc), extract the first item  if ( input[0] && input[0].nodeType ) {   return input[0];  }
return null; }
if ( !isClient ) {  matches = null; } else {  div = createElement( 'div' );  methodNames = [ 'matches', 'matchesSelector' ];
makeFunction = function ( methodName ) {   return function ( node, selector ) {    return node[ methodName ]( selector );   };  };
i = methodNames.length;
while ( i-- && !matches ) {   unprefixed = methodNames[i];
if ( div[ unprefixed ] ) {    matches = makeFunction( unprefixed );   } else {    j = vendors.length;    while ( j-- ) {     prefixed = vendors[i] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
if ( div[ prefixed ] ) {      matches = makeFunction( prefixed );      break;     }    }   }  }
// IE8...  if ( !matches ) {   matches = function ( node, selector ) {    var parentNode, i;
parentNode = node.parentNode;
if ( !parentNode ) {
// empty dummy
div.innerHTML = ;
parentNode = div;     node = node.cloneNode();
div.appendChild( node );    }
var nodes = parentNode.querySelectorAll( selector );
i = nodes.length;    while ( i-- ) {     if ( nodes[i] === node ) {      return true;     }    }
return false;   };  } }
function detachNode ( node ) {  // stupid ie  if ( node && typeof node.parentNode !== 'unknown' && node.parentNode ) { // eslint-disable-line valid-typeof   node.parentNode.removeChild( node );  }
return node; }
function safeToStringValue ( value ) {  return ( value == null || !value.toString ) ?  : + value; }
function safeAttributeString ( string ) {  return safeToStringValue( string )   .replace( /&/g, '&' )   .replace( /"/g, '"' )   .replace( /'/g, ''' ); }
var insertHook = new Hook( 'insert' );
function Ractive$insert ( target, anchor ) {  if ( !this.fragment.rendered ) {   // TODO create, and link to, documentation explaining this   throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );  }
target = getElement( target );  anchor = getElement( anchor ) || null;
if ( !target ) {   throw new Error( 'You must specify a valid target to insert into' );  }
target.insertBefore( this.detach(), anchor );  this.el = target;
( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );  this.isDetached = false;
fireInsertHook( this ); }
function fireInsertHook( ractive ) {  insertHook.fire( ractive );
ractive.findAllComponents('*').forEach( function (child) {   fireInsertHook( child.instance );  }); }
function link( there, here, options ) {  var model;  var target = ( options && ( options.ractive || options.instance ) ) || this;
// may need to allow a mapping to resolve implicitly  var sourcePath = splitKeypath( there );  if ( !target.viewmodel.has( sourcePath[0] ) && target.component ) {   model = resolveReference( target.component.parentFragment, sourcePath[0] );   model = model.joinAll( sourcePath.slice( 1 ) );  }
var src = model || target.viewmodel.joinAll( sourcePath );  var dest = this.viewmodel.joinAll( splitKeypath( here ), { lastLink: false });
if ( isUpstream( src, dest ) || isUpstream( dest, src ) ) {   throw new Error( 'A keypath cannot be linked to itself.' );  }
var promise = runloop.start();
dest.link( src, there );
runloop.end();
return promise; }
function isUpstream ( check, start ) {  var model = start;  while ( model ) {   if ( model === check ) { return true; }   model = model.target || model.parent;  } }
var Observer = function Observer ( ractive, model, callback, options ) {  this.context = options.context || ractive;  this.callback = callback;  this.ractive = ractive;  this.keypath = options.keypath;  this.options = options;
if ( model ) { this.resolved( model ); }
if ( typeof options.old === 'function' ) {   this.oldContext = Object.create( ractive );   this.old = options.old;  } else {   this.old = old;  }
if ( options.init !== false ) {   this.dirty = true;   this.dispatch();  } else {   this.oldValue = this.old.call( this.oldContext, undefined, this.newValue );  }
this.dirty = false; };
Observer.prototype.cancel = function cancel () {  this.cancelled = true;  if ( this.model ) {   this.model.unregister( this );  } else {   this.resolver.unbind();  }  removeFromArray( this.ractive._observers, this ); };
Observer.prototype.dispatch = function dispatch () {  if ( !this.cancelled ) {   this.callback.call( this.context, this.newValue, this.oldValue, this.keypath );   this.oldValue = this.old.call( this.oldContext, this.oldValue, this.model ? this.model.get() : this.newValue );   this.dirty = false;  } };
Observer.prototype.handleChange = function handleChange () {   var this$1 = this;
if ( !this.dirty ) {   var newValue = this.model.get();   if ( isEqual( newValue, this.oldValue ) ) { return; }
this.newValue = newValue;
if ( this.options.strict && this.newValue === this.oldValue ) { return; }
runloop.addObserver( this, this.options.defer );   this.dirty = true;
if ( this.options.once ) { runloop.scheduleTask( function () { return this$1.cancel(); } ); }  } };
Observer.prototype.rebind = function rebind ( next, previous ) {   var this$1 = this;
next = rebindMatch( this.keypath, next, previous );  // TODO: set up a resolver if next is undefined?  if ( next === this.model ) { return false; }
if ( this.model ) { this.model.unregister( this ); }  if ( next ) { next.addShuffleTask( function () { return this$1.resolved( next ); } ); } };
Observer.prototype.resolved = function resolved ( model ) {  this.model = model;
this.oldValue = undefined;  this.newValue = model.get();
model.register( this ); };
function old ( previous, next ) {  return next; }
var star$1 = /\*+/g;
var PatternObserver = function PatternObserver ( ractive, baseModel, keys, callback, options ) {  var this$1 = this;
this.context = options.context || ractive;  this.ractive = ractive;  this.baseModel = baseModel;  this.keys = keys;  this.callback = callback;
var pattern = keys.join( '\\.' ).replace( star$1, '(.+)' );  var baseKeypath = this.baseKeypath = baseModel.getKeypath( ractive );  this.pattern = new RegExp( ("^" + (baseKeypath ? baseKeypath + '\\.' : ) + pattern + "$") ); this.recursive = keys.length === 1 && keys[0] === '**';  if ( this.recursive ) { this.keys = [ '*' ]; }
this.oldValues = {};  this.newValues = {};
this.defer = options.defer;  this.once = options.once;  this.strict = options.strict;
this.dirty = false;  this.changed = [];  this.partial = false;  this.links = options.links;
var models = baseModel.findMatches( this.keys );
models.forEach( function (model) {   this$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();  });
if ( options.init !== false ) {   this.dispatch();  } else {   this.oldValues = this.newValues;  }
baseModel.registerPatternObserver( this ); };
PatternObserver.prototype.cancel = function cancel () {  this.baseModel.unregisterPatternObserver( this );  removeFromArray( this.ractive._observers, this ); };
PatternObserver.prototype.dispatch = function dispatch () {   var this$1 = this;
var newValues = this.newValues;  this.newValues = {};  Object.keys( newValues ).forEach( function (keypath) {   if ( this$1.newKeys && !this$1.newKeys[ keypath ] ) { return; }
var newValue = newValues[ keypath ];   var oldValue = this$1.oldValues[ keypath ];
if ( this$1.strict && newValue === oldValue ) { return; }   if ( isEqual( newValue, oldValue ) ) { return; }
var args = [ newValue, oldValue, keypath ];   if ( keypath ) {    var wildcards = this$1.pattern.exec( keypath );    if ( wildcards ) {     args = args.concat( wildcards.slice( 1 ) );    }   }
this$1.callback.apply( this$1.context, args );  });
if ( this.partial ) {   for ( var k in newValues ) {    this$1.oldValues[k] = newValues[k];   }  } else {   this.oldValues = newValues;  }
this.newKeys = null;  this.dirty = false; };
PatternObserver.prototype.notify = function notify ( key ) {  this.changed.push( key ); };
PatternObserver.prototype.shuffle = function shuffle ( newIndices ) {   var this$1 = this;
if ( !Array.isArray( this.baseModel.value ) ) { return; }
var base = this.baseKeypath = this.baseModel.getKeypath( this.ractive );  var max = this.baseModel.value.length;  var suffix = this.keys.length > 1 ? '.' + this.keys.slice( 1 ).join( '.' ) : ;
this.newKeys = {};  for ( var i = 0; i < newIndices.length; i++ ) {   if ( newIndices[ i ] === -1 || newIndices[ i ] === i ) { continue; }   this$1.newKeys[ (base + "." + i + suffix) ] = true;  }
for ( var i$1 = newIndices.touchedFrom; i$1 < max; i$1++ ) {   this$1.newKeys[ (base + "." + i$1 + suffix) ] = true;  } };
PatternObserver.prototype.handleChange = function handleChange () {   var this$1 = this;
if ( !this.dirty || this.changed.length ) {   if ( !this.dirty ) { this.newValues = {}; }
if ( !this.changed.length ) {    this.baseModel.findMatches( this.keys ).forEach( function (model) {     var keypath = model.getKeypath( this$1.ractive );     this$1.newValues[ keypath ] = model.get();    });    this.partial = false;   } else {    var count = 0;
if ( this.recursive ) {     this.changed.forEach( function (keys) {      var model = this$1.baseModel.joinAll( keys );      if ( model.isLink && !this$1.links ) { return; }      count++;      this$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();     });    } else {     var ok = this.baseModel.isRoot ?      this.changed.map( function (keys) { return keys.map( escapeKey ).join( '.' ); } ) :      this.changed.map( function (keys) { return this$1.baseKeypath + '.' + keys.map( escapeKey ).join( '.' ); } );
this.baseModel.findMatches( this.keys ).forEach( function (model) {      var keypath = model.getKeypath( this$1.ractive );      var check = function (k) {       return ( k.indexOf( keypath ) === 0 && ( k.length === keypath.length || k[ keypath.length ] === '.' ) ) ||        ( keypath.indexOf( k ) === 0 && ( k.length === keypath.length || keypath[ k.length ] === '.' ) );
};
// is this model on a changed keypath?      if ( ok.filter( check ).length ) {       count++;       this$1.newValues[ keypath ] = model.get();      }     });    }
// no valid change triggered, so bail to avoid breakage    if ( !count ) { return; }
this.partial = true;   }
runloop.addObserver( this, this.defer );   this.dirty = true;   this.changed.length = 0;
if ( this.once ) { this.cancel(); }  } };
function negativeOne () {  return -1; }
var ArrayObserver = function ArrayObserver ( ractive, model, callback, options ) {  this.ractive = ractive;  this.model = model;  this.keypath = model.getKeypath();  this.callback = callback;  this.options = options;
this.pending = null;
model.register( this );
if ( options.init !== false ) {   this.sliced = [];   this.shuffle([]);   this.dispatch();  } else {   this.sliced = this.slice();  } };
ArrayObserver.prototype.cancel = function cancel () {  this.model.unregister( this );  removeFromArray( this.ractive._observers, this ); };
ArrayObserver.prototype.dispatch = function dispatch () {  this.callback( this.pending );  this.pending = null;  if ( this.options.once ) { this.cancel(); } };
ArrayObserver.prototype.handleChange = function handleChange () {  if ( this.pending ) {   // post-shuffle   runloop.addObserver( this, this.options.defer );  } else {   // entire array changed   this.shuffle( this.sliced.map( negativeOne ) );   this.handleChange();  } };
ArrayObserver.prototype.shuffle = function shuffle ( newIndices ) {   var this$1 = this;
var newValue = this.slice();
var inserted = [];  var deleted = [];  var start;
var hadIndex = {};
newIndices.forEach( function ( newIndex, oldIndex ) {   hadIndex[ newIndex ] = true;
if ( newIndex !== oldIndex && start === undefined ) {    start = oldIndex;   }
if ( newIndex === -1 ) {    deleted.push( this$1.sliced[ oldIndex ] );   }  });
if ( start === undefined ) { start = newIndices.length; }
var len = newValue.length;  for ( var i = 0; i < len; i += 1 ) {   if ( !hadIndex[i] ) { inserted.push( newValue[i] ); }  }
this.pending = { inserted: inserted, deleted: deleted, start: start };  this.sliced = newValue; };
ArrayObserver.prototype.slice = function slice () {  var value = this.model.get();  return Array.isArray( value ) ? value.slice() : []; };
function observe ( keypath, callback, options ) {  var this$1 = this;
var observers = [];  var map;  var opts;
if ( isObject( keypath ) ) {   map = keypath;   opts = callback || {};  } else {   if ( typeof keypath === 'function' ) {    map = { : keypath }; opts = callback || {};   } else {    map = {};    map[ keypath ] = callback;    opts = options || {};   }  }
var silent = false;  Object.keys( map ).forEach( function (keypath) {   var callback = map[ keypath ];   var caller = function () {    var args = [], len = arguments.length;    while ( len-- ) args[ len ] = arguments[ len ];
if ( silent ) { return; }    return callback.apply( this, args );   };
var keypaths = keypath.split( ' ' );   if ( keypaths.length > 1 ) { keypaths = keypaths.filter( function (k) { return k; } ); }
keypaths.forEach( function (keypath) {    opts.keypath = keypath;    var observer = createObserver( this$1, keypath, caller, opts );    if ( observer ) { observers.push( observer ); }   });  });
// add observers to the Ractive instance, so they can be  // cancelled on ractive.teardown()  this._observers.push.apply( this._observers, observers );
return {   cancel: function () { return observers.forEach( function (o) { return o.cancel(); } ); },   isSilenced: function () { return silent; },   silence: function () { return silent = true; },   resume: function () { return silent = false; }  }; }
function createObserver ( ractive, keypath, callback, options ) {  var keys = splitKeypath( keypath );  var wildcardIndex = keys.indexOf( '*' );  if ( !~wildcardIndex ) { wildcardIndex = keys.indexOf( '**' ); }
options.fragment = options.fragment || ractive.fragment;
var model;  if ( !options.fragment ) {   model = ractive.viewmodel.joinKey( keys[0] );  } else {   // .*.whatever relative wildcard is a special case because splitkeypath doesn't handle the leading .   if ( ~keys[0].indexOf( '.*' ) ) {    model = options.fragment.findContext();    wildcardIndex = 0;    keys[0] = keys[0].slice( 1 );   } else {    model = wildcardIndex === 0 ? options.fragment.findContext() : resolveReference( options.fragment, keys[0] );   }  }
// the model may not exist key  if ( !model ) { model = ractive.viewmodel.joinKey( keys[0] ); }
if ( !~wildcardIndex ) {   model = model.joinAll( keys.slice( 1 ) );   if ( options.array ) {    return new ArrayObserver( ractive, model, callback, options );   } else {    return new Observer( ractive, model, callback, options );   }  } else {   var double = keys.indexOf( '**' );   if ( ~double ) {    if ( double + 1 !== keys.length || ~keys.indexOf( '*' ) ) {     warnOnceIfDebug( "Recursive observers may only specify a single '**' at the end of the path." );     return;    }   }
model = model.joinAll( keys.slice( 1, wildcardIndex ) );
return new PatternObserver( ractive, model, keys.slice( wildcardIndex ), callback, options );  } }
var onceOptions = { init: false, once: true };
function observeOnce ( keypath, callback, options ) {  if ( isObject( keypath ) || typeof keypath === 'function' ) {   options = Object.assign( callback || {}, onceOptions );   return this.observe( keypath, options );  }
options = Object.assign( options || {}, onceOptions );  return this.observe( keypath, callback, options ); }
var trim = function (str) { return str.trim(); };
var notEmptyString = function (str) { return str !== ; };
function Ractive$off ( eventName, callback ) {  var this$1 = this;
// if no event is specified, remove _all_ event listeners  if ( !eventName ) {   this._subs = {};  } else {   // Handle multiple space-separated event names   var eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
eventNames.forEach( function (event) {    var subs = this$1._subs[ event ];    // if given a specific callback to remove, remove only it    if ( subs && callback ) {     var entry = subs.find( function (s) { return s.callback === callback; } );     if ( entry ) {      removeFromArray( subs, entry );      entry.off = true;
if ( event.indexOf( '.' ) ) { this$1._nsSubs--; }     }    }
// otherwise, remove all listeners for this event    else if ( subs ) {     if ( event.indexOf( '.' ) ) { this$1._nsSubs -= subs.length; }     subs.length = 0;    }   });  }
return this; }
function Ractive$on ( eventName, callback ) {  var this$1 = this;
// eventName may already be a map  var map = typeof eventName === 'object' ? eventName : {};  // or it may be a string along with a callback  if ( typeof eventName === 'string' ) { map[ eventName ] = callback; }
var silent = false;  var events = [];
var loop = function ( k ) {   var callback$1 = map[k];   var caller = function () {    var args = [], len = arguments.length;    while ( len-- ) args[ len ] = arguments[ len ];
if ( !silent ) { return callback$1.apply( this, args ); }   };   var entry = {    callback: callback$1,    handler: caller   };
if ( map.hasOwnProperty( k ) ) {    var names = k.split( ' ' ).map( trim ).filter( notEmptyString );    names.forEach( function (n) {     ( this$1._subs[ n ] || ( this$1._subs[ n ] = [] ) ).push( entry );     if ( n.indexOf( '.' ) ) { this$1._nsSubs++; }     events.push( [ n, entry ] );    });   }  };
for ( var k in map ) loop( k );
return {   cancel: function () { return events.forEach( function (e) { return this$1.off( e[0], e[1].callback ); } ); },   isSilenced: function () { return silent; },   silence: function () { return silent = true; },   resume: function () { return silent = false; }  }; }
function Ractive$once ( eventName, handler ) {  var listener = this.on( eventName, function () {   handler.apply( this, arguments );   listener.cancel();  });
// so we can still do listener.cancel() manually  return listener; }
var pop = makeArrayMethod( 'pop' ).path;
var push = makeArrayMethod( 'push' ).path;
function readLink ( keypath, options ) {  if ( options === void 0 ) options = {};
var path = splitKeypath( keypath );
if ( this.viewmodel.has( path[0] ) ) {   var model = this.viewmodel.joinAll( path );
if ( !model.isLink ) { return; }
while ( ( model = model.target ) && options.canonical !== false ) {    if ( !model.isLink ) { break; }   }
if ( model ) { return { ractive: model.root.ractive, keypath: model.getKeypath() }; }  } }
var PREFIX = '/* Ractive.js component styles */';
// Holds current definitions of styles. var styleDefinitions = [];
// Flag to tell if we need to update the CSS var isDirty = false;
// These only make sense on the browser. See additional setup below. var styleElement = null; var useCssText = null;
function addCSS( styleDefinition ) {  styleDefinitions.push( styleDefinition );  isDirty = true; }
function applyCSS() {
// Apply only seems to make sense when we're in the DOM. Server-side renders  // can call toCSS to get the updated CSS.  if ( !doc || !isDirty ) { return; }
if ( useCssText ) {   styleElement.styleSheet.cssText = getCSS( null );  } else {   styleElement.innerHTML = getCSS( null );  }
isDirty = false; }
function getCSS( cssIds ) {
var filteredStyleDefinitions = cssIds ? styleDefinitions.filter( function (style) { return ~cssIds.indexOf( style.id ); } ) : styleDefinitions;
return filteredStyleDefinitions.reduce( function ( styles, style ) { return (styles + "\n\n/* {" + (style.id) + "} */\n" + (style.styles)); }, PREFIX );
}
// If we're on the browser, additional setup needed. if ( doc && ( !styleElement || !styleElement.parentNode ) ) {
styleElement = doc.createElement( 'style' );  styleElement.type = 'text/css';
doc.getElementsByTagName( 'head' )[ 0 ].appendChild( styleElement );
useCssText = !!styleElement.styleSheet; }
function fillGaps ( target ) {  var sources = [], len = arguments.length - 1;  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];
for (var i = 0; i < sources.length; i++){   var source = sources[i];   for ( var key in source ) {    // Source can be a prototype-less object.    if ( key in target || !Object.prototype.hasOwnProperty.call( source, key ) ) { continue; }    target[ key ] = source[ key ];   }  }
return target; }
function toPairs ( obj ) {  if ( obj === void 0 ) obj = {};
var pairs = [];  for ( var key in obj ) {   // Source can be a prototype-less object.   if ( !Object.prototype.hasOwnProperty.call( obj, key ) ) { continue; }   pairs.push( [ key, obj[ key ] ] );  }  return pairs; }
var adaptConfigurator = {  extend: function ( Parent, proto, options ) {   proto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );  },
init: function init () {} };
var remove = /\/\*(?:[\s\S]*?)\*\//g; var escape = /url\(\s*(['"])(?:\\[\s\S]|(?!\1).)*\1\s*\)|url\((?:\\[\s\S]|[^)])*\)|(['"])(?:\\[\s\S]|(?!\2).)*\2/gi; var value = /\0(\d+)/g;
// Removes comments and strings from the given CSS to make it easier to parse. // Callback receives the cleaned CSS and a function which can be used to put // the removed strings back in place after parsing is done. var cleanCss = function ( css, callback, additionalReplaceRules ) {  if ( additionalReplaceRules === void 0 ) additionalReplaceRules = [];
var values = [];  var reconstruct = function (css) { return css.replace( value, function ( match, n ) { return values[ n ]; } ); };  css = css.replace( escape, function (match) { return ("\u0000" + (values.push( match ) - 1)); }).replace( remove, );
additionalReplaceRules.forEach( function ( pattern ) {   css = css.replace( pattern, function (match) { return ("\u0000" + (values.push( match ) - 1)); } );  });
return callback( css, reconstruct ); };
var selectorsPattern = /(?:^|\}|\{)\s*([^\{\}\0]+)\s*(?=\{)/g; var keyframesDeclarationPattern = /@keyframes\s+[^\{\}]+\s*\{(?:[^{}]+|\{[^{}]+})*}/gi; var selectorUnitPattern = /((?:(?:\ ^\ +\])|(?:[^\s\+\>~:]))+)((?:::?[^\s\+\>\~\(:]+(?:\([^\)]+\))?)*\s*[\s\+\>\~]?)\s*/g; var excludePattern = /^(?:@|\d+%)/; var dataRvcGuidPattern = /\[data-ractive-css~="\{[a-z0-9-]+\}"]/g;
function trim$1 ( str ) {  return str.trim(); }
function extractString ( unit ) {  return unit.str; }
function transformSelector ( selector, parent ) {  var selectorUnits = [];  var match;
while ( match = selectorUnitPattern.exec( selector ) ) {   selectorUnits.push({    str: match[0],    base: match[1],    modifiers: match[2]   });  }
// For each simple selector within the selector, we need to create a version  // that a) combines with the id, and b) is inside the id  var base = selectorUnits.map( extractString );
var transformed = [];  var i = selectorUnits.length;
while ( i-- ) {   var appended = base.slice();
// Pseudo-selectors should go after the attribute selector   var unit = selectorUnits[i];   appended[i] = unit.base + parent + unit.modifiers || ;
var prepended = base.slice();   prepended[i] = parent + ' ' + prepended[i];
transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );  }
return transformed.join( ', ' ); }
function transformCss ( css, id ) {  var dataAttr = "[data-ractive-css~=\"{" + id + "}\"]";
var transformed;
if ( dataRvcGuidPattern.test( css ) ) {   transformed = css.replace( dataRvcGuidPattern, dataAttr );  } else {   transformed = cleanCss( css, function ( css, reconstruct ) {    css = css.replace( selectorsPattern, function ( match, $1 ) {     // don't transform at-rules and keyframe declarations     if ( excludePattern.test( $1 ) ) { return match; }
var selectors = $1.split( ',' ).map( trim$1 );     var transformed = selectors      .map( function (selector) { return transformSelector( selector, dataAttr ); } )      .join( ', ' ) + ' ';
return match.replace( $1, transformed );    });
return reconstruct( css );   }, [ keyframesDeclarationPattern ]);  }
return transformed; }
function s4() {  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); }
function uuid() {  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4(); }
var hasCurly = /\{/; var cssConfigurator = {  name: 'css',
// Called when creating a new component definition  extend: function ( Parent, proto, options ) {   if ( !options.css ) { return; }   var css = typeof options.css === 'string' && !hasCurly.test( options.css ) ?    ( getElement( options.css ) || options.css ) :    options.css;
var id = options.cssId || uuid();
if ( typeof css === 'object' ) {    css = 'textContent' in css ? css.textContent : css.innerHTML;   }
if ( !css ) { return; }
var styles = options.noCssTransform ? css : transformCss( css, id );
proto.cssId = id;
addCSS( { id: id, styles: styles } );  },
// Called when creating a new component instance  init: function ( Parent, target, options ) {   if ( !options.css ) { return; }
warnIfDebug( "\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\n\nconst Component = Ractive.extend({\n\t...\n\tcss: '/* your css */',\n\t...\n});\n\nconst componentInstance = new Component({ ... })\n\t\t" );  }
};
function validate ( data ) {  // Warn if userOptions.data is a non-POJO  if ( data && data.constructor !== Object ) {   if ( typeof data === 'function' ) {    // TODO do we need to support this in the new Ractive() case?   } else if ( typeof data !== 'object' ) {    fatal( ("data option must be an object or a function, `" + data + "` is not valid") );   } else {    warnIfDebug( 'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged' );   }  } }
var dataConfigurator = {  name: 'data',
extend: function ( Parent, proto, options ) {   var key;   var value;
// check for non-primitives, which could cause mutation-related bugs   if ( options.data && isObject( options.data ) ) {    for ( key in options.data ) {     value = options.data[ key ];
if ( value && typeof value === 'object' ) {      if ( isObject( value ) || Array.isArray( value ) ) {       warnIfDebug( "Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }" );      }     }    }   }
proto.data = combine$1( proto.data, options.data );  },
init: function ( Parent, ractive, options ) {   var result = combine$1( Parent.prototype.data, options.data );
if ( typeof result === 'function' ) { result = result.call( ractive ); }
// bind functions to the ractive instance at the top level,   // unless it's a non-POJO (in which case alarm bells should ring)   if ( result && result.constructor === Object ) {    for ( var prop in result ) {     if ( typeof result[ prop ] === 'function' ) {      var value = result[ prop ];      result[ prop ] = bind$1( value, ractive );      result[ prop ]._r_unbound = value;     }    }   }
return result || {};  },
reset: function reset ( ractive ) {   var result = this.init( ractive.constructor, ractive, ractive.viewmodel );   ractive.viewmodel.root.set( result );   return true;  } };
function combine$1 ( parentValue, childValue ) {  validate( childValue );
var parentIsFn = typeof parentValue === 'function';  var childIsFn = typeof childValue === 'function';
// Very important, otherwise child instance can become  // the default data object on Ractive or a component.  // then ractive.set() ends up setting on the prototype!  if ( !childValue && !parentIsFn ) {   childValue = {};  }
// Fast path, where we just need to copy properties from  // parent to child  if ( !parentIsFn && !childIsFn ) {   return fromProperties( childValue, parentValue );  }
return function () {   var child = childIsFn ? callDataFunction( childValue, this ) : childValue;   var parent = parentIsFn ? callDataFunction( parentValue, this ) : parentValue;
return fromProperties( child, parent );  }; }
function callDataFunction ( fn, context ) {  var data = fn.call( context );
if ( !data ) { return; }
if ( typeof data !== 'object' ) {   fatal( 'Data function must return an object' );  }
if ( data.constructor !== Object ) {   warnOnceIfDebug( 'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged' );  }
return data; }
function fromProperties ( primary, secondary ) {  if ( primary && secondary ) {   for ( var key in secondary ) {    if ( !( key in primary ) ) {     primary[ key ] = secondary[ key ];    }   }
return primary;  }
return primary || secondary; }
var TEMPLATE_VERSION = 4;
var pattern = /\$\{([^\}]+)\}/g;
function fromExpression ( body, length ) {  if ( length === void 0 ) length = 0;
var args = new Array( length );
while ( length-- ) {   args[length] = "_" + length;  }
// Functions created directly with new Function() look like this:  //     function anonymous (_0 /**/) { return _0*2 }  //  // With this workaround, we get a little more compact:  //     function (_0){return _0*2}  return new Function( [], ("return function (" + (args.join(',')) + "){return(" + body + ");};") )(); }
function fromComputationString ( str, bindTo ) {  var hasThis;
var functionBody = 'return (' + str.replace( pattern, function ( match, keypath ) {   hasThis = true;   return ("__ractive.get(\"" + keypath + "\")");  }) + ');';
if ( hasThis ) { functionBody = "var __ractive = this; " + functionBody; }  var fn = new Function( functionBody );  return hasThis ? fn.bind( bindTo ) : fn; }
var functions = Object.create( null );
function getFunction ( str, i ) {  if ( functions[ str ] ) { return functions[ str ]; }  return functions[ str ] = createFunction( str, i ); }
function addFunctions( template ) {  if ( !template ) { return; }
var exp = template.e;
if ( !exp ) { return; }
Object.keys( exp ).forEach( function ( str ) {   if ( functions[ str ] ) { return; }   functions[ str ] = exp[ str ];  }); }
var leadingWhitespace = /^\s+/;
var ParseError = function ( message ) {  this.name = 'ParseError';  this.message = message;  try {   throw new Error(message);  } catch (e) {   this.stack = e.stack;  } };
ParseError.prototype = Error.prototype;
var Parser = function ( str, options ) {  var item;  var lineStart = 0;
this.str = str;  this.options = options || {};  this.pos = 0;
this.lines = this.str.split( '\n' );  this.lineEnds = this.lines.map( function (line) {   var lineEnd = lineStart + line.length + 1; // +1 for the newline
lineStart = lineEnd;   return lineEnd;  }, 0 );
// Custom init logic  if ( this.init ) { this.init( str, options ); }
var items = [];
while ( ( this.pos < this.str.length ) && ( item = this.read() ) ) {   items.push( item );  }
this.leftover = this.remaining();  this.result = this.postProcess ? this.postProcess( items, options ) : items; };
Parser.prototype = {  read: function read ( converters ) {   var this$1 = this;
var i, item;
if ( !converters ) { converters = this.converters; }
var pos = this.pos;
var len = converters.length;   for ( i = 0; i < len; i += 1 ) {    this$1.pos = pos; // reset for each attempt
if ( item = converters[i]( this$1 ) ) {     return item;    }   }
return null;  },
getContextMessage: function getContextMessage ( pos, message ) {   var ref = this.getLinePos( pos );   var lineNum = ref[0];   var columnNum = ref[1];   if ( this.options.contextLines === -1 ) {    return [ lineNum, columnNum, (message + " at line " + lineNum + " character " + columnNum) ];   }
var line = this.lines[ lineNum - 1 ];
var contextUp = ; var contextDown = ; if ( this.options.contextLines ) {    var start = lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;    contextUp = this.lines.slice( start, lineNum - 1 - start ).join( '\n' ).replace( /\t/g, '  ' );    contextDown = this.lines.slice( lineNum, lineNum + this.options.contextLines ).join( '\n' ).replace( /\t/g, '  ' );    if ( contextUp ) {     contextUp += '\n';    }    if ( contextDown ) {     contextDown = '\n' + contextDown;    }   }
var numTabs = 0;   var annotation = contextUp + line.replace( /\t/g, function ( match, char ) {    if ( char < columnNum ) {     numTabs += 1;    }
return '  ';   }) + '\n' + new Array( columnNum + numTabs ).join( ' ' ) + '^----' + contextDown;
return [ lineNum, columnNum, (message + " at line " + lineNum + " character " + columnNum + ":\n" + annotation) ];  },
getLinePos: function getLinePos ( char ) {   var this$1 = this;
var lineNum = 0;   var lineStart = 0;
while ( char >= this.lineEnds[ lineNum ] ) {    lineStart = this$1.lineEnds[ lineNum ];    lineNum += 1;   }
var columnNum = char - lineStart;   return [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!  },
error: function error ( message ) {   var ref = this.getContextMessage( this.pos, message );   var lineNum = ref[0];   var columnNum = ref[1];   var msg = ref[2];
var error = new ParseError( msg );
error.line = lineNum;   error.character = columnNum;   error.shortMessage = message;
throw error;  },
matchString: function matchString ( string ) {   if ( this.str.substr( this.pos, string.length ) === string ) {    this.pos += string.length;    return string;   }  },
matchPattern: function matchPattern ( pattern ) {   var match;
if ( match = pattern.exec( this.remaining() ) ) {    this.pos += match[0].length;    return match[1] || match[0];   }  },
allowWhitespace: function allowWhitespace () {   this.matchPattern( leadingWhitespace );  },
remaining: function remaining () {   return this.str.substring( this.pos );  },
nextChar: function nextChar () {   return this.str.charAt( this.pos );  },
warn: function warn$$1 ( message ) {   var msg = this.getContextMessage( this.pos, message )[2];
warnIfDebug( msg );  } };
Parser.extend = function ( proto ) {  var Parent = this;  var Child = function ( str, options ) {   Parser.call( this, str, options );  };
Child.prototype = Object.create( Parent.prototype );
for ( var key in proto ) {   if ( proto.hasOwnProperty( key ) ) {    Child.prototype[ key ] = proto[ key ];   }  }
Child.extend = Parser.extend;  return Child; };
var delimiterChangePattern = /^[^\s=]+/; var whitespacePattern = /^\s+/;
function readDelimiterChange ( parser ) {  if ( !parser.matchString( '=' ) ) {   return null;  }
var start = parser.pos;
// allow whitespace before new opening delimiter  parser.allowWhitespace();
var opening = parser.matchPattern( delimiterChangePattern );  if ( !opening ) {   parser.pos = start;   return null;  }
// allow whitespace (in fact, it's necessary...)  if ( !parser.matchPattern( whitespacePattern ) ) {   return null;  }
var closing = parser.matchPattern( delimiterChangePattern );  if ( !closing ) {   parser.pos = start;   return null;  }
// allow whitespace before closing '='  parser.allowWhitespace();
if ( !parser.matchString( '=' ) ) {   parser.pos = start;   return null;  }
return [ opening, closing ]; }
var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;
function readNumberLiteral ( parser ) {  var result;
if ( result = parser.matchPattern( regexpPattern ) ) {   return {    t: REGEXP_LITERAL,    v: result   };  }
return null; }
var pattern$1 = /[-/\\^$*+?.()|[\]{}]/g;
function escapeRegExp ( str ) {  return str.replace( pattern$1, '\\$&' ); }
var regExpCache = {};
var getLowestIndex = function ( haystack, needles ) {  return haystack.search( regExpCache[needles.join()] || ( regExpCache[needles.join()] = new RegExp( needles.map( escapeRegExp ).join( '|' ) ) ) ); };
// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316 var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i; var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
var htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 }; var controlCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ]; var entityPattern = new RegExp( '&(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' ); var codePointSupport = typeof String.fromCodePoint === 'function'; var codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;
function decodeCharacterReferences ( html ) {  return html.replace( entityPattern, function ( match, entity ) {   var code;
// Handle named entities   if ( entity[0] !== '#' ) {    code = htmlEntities[ entity ];   } else if ( entity[1] === 'x' ) {    code = parseInt( entity.substring( 2 ), 16 );   } else {    code = parseInt( entity.substring( 1 ), 10 );   }
if ( !code ) {    return match;   }
return codeToChar( validateCode( code ) );  }); }
var lessThan = /</g; var greaterThan = />/g; var amp = /&/g; var invalid = 65533;
function escapeHtml ( str ) {  return str   .replace( amp, '&' )   .replace( lessThan, '<' )   .replace( greaterThan, '>' ); }
// some code points are verboten. If we were inserting HTML, the browser would replace the illegal // code points with alternatives in some cases - since we're bypassing that mechanism, we need // to replace them ourselves // // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters function validateCode ( code ) {  if ( !code ) {   return invalid;  }
// line feed becomes generic whitespace  if ( code === 10 ) {   return 32;  }
// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)  if ( code < 128 ) {   return code;  }
// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need  // to correct the mistake or we'll end up with missing € signs and so on  if ( code <= 159 ) {   return controlCharacters[ code - 128 ];  }
// basic multilingual plane  if ( code < 55296 ) {   return code;  }
// UTF-16 surrogate halves  if ( code <= 57343 ) {   return invalid;  }
// rest of the basic multilingual plane  if ( code <= 65535 ) {   return code;  } else if ( !codePointSupport ) {   return invalid;  }
// supplementary multilingual plane 0x10000 - 0x1ffff  if ( code >= 65536 && code <= 131071 ) {   return code;  }
// supplementary ideographic plane 0x20000 - 0x2ffff  if ( code >= 131072 && code <= 196607 ) {   return code;  }
return invalid; }
var expectedExpression = 'Expected a JavaScript expression'; var expectedParen = 'Expected closing paren';
// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330 var numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
function readNumberLiteral$1 ( parser ) {  var result;
if ( result = parser.matchPattern( numberPattern ) ) {   return {    t: NUMBER_LITERAL,    v: result   };  }
return null; }
function readBooleanLiteral ( parser ) {  var remaining = parser.remaining();
if ( remaining.substr( 0, 4 ) === 'true' ) {   parser.pos += 4;   return {    t: BOOLEAN_LITERAL,    v: 'true'   };  }
if ( remaining.substr( 0, 5 ) === 'false' ) {   parser.pos += 5;   return {    t: BOOLEAN_LITERAL,    v: 'false'   };  }
return null; }
// Match one or more characters until: ", ', \, or EOL/EOF. // EOL/EOF is written as (?!.) (meaning there's no non-newline char next). var stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
// Match one escape sequence, including the backslash. var escapeSequencePattern = /^\\(?:[`'"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
// Match one ES5 line continuation (backslash + line terminator). var lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
// Helper for defining getDoubleQuotedString and getSingleQuotedString. var makeQuotedStringMatcher = function ( okQuote ) {  return function ( parser ) {   var literal = '"';   var done = false;   var next;
while ( !done ) {    next = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||     parser.matchString( okQuote ) );    if ( next ) {     if ( next === "\"" ) {      literal += "\\\"";     } else if ( next === "\\'" ) {      literal += "'";     } else {      literal += next;     }    } else {     next = parser.matchPattern( lineContinuationPattern );     if ( next ) {      // convert \(newline-like) into a \u escape, which is allowed in JSON      literal += '\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );     } else {      done = true;     }    }   }
literal += '"';
// use JSON.parse to interpret escapes   return JSON.parse( literal );  }; };
var singleMatcher = makeQuotedStringMatcher( "\"" ); var doubleMatcher = makeQuotedStringMatcher( "'" );
var readStringLiteral = function ( parser ) {  var start = parser.pos;  var quote = parser.matchString( "'" ) || parser.matchString( "\"" );
if ( quote ) {   var string = ( quote === "'" ? singleMatcher : doubleMatcher )( parser );
if ( !parser.matchString( quote ) ) {    parser.pos = start;    return null;   }
return {    t: STRING_LITERAL,    v: string   };  }
return null; };
// Match one or more characters until: ", ', or \ var stringMiddlePattern$1 = /^[^`"\\\$]+?(?:(?=[`"\\\$]))/;
var escapes = /[\r\n\t\b\f]/g; function getString ( literal ) {  return JSON.parse( ("\"" + (literal.replace( escapes, escapeChar )) + "\"") ); }
function escapeChar ( c ) {  switch ( c ) {   case '\n': return '\\n';   case '\r': return '\\r';   case '\t': return '\\t';   case '\b': return '\\b';   case '\f': return '\\f';  } }
function readTemplateStringLiteral ( parser ) {  if ( !parser.matchString( '`' ) ) { return null; }
var literal = ; var done = false;  var next;  var parts = [];
while ( !done ) {   next = parser.matchPattern( stringMiddlePattern$1 ) || parser.matchPattern( escapeSequencePattern ) ||    parser.matchString( '$' ) || parser.matchString( '"' );   if ( next ) {    if ( next === "\"" ) {     literal += "\\\"";    } else if ( next === '\\`' ) {     literal += '`';    } else if ( next === '$' ) {     if ( parser.matchString( '{' ) ) {      parts.push({ t: STRING_LITERAL, v: getString( literal ) });      literal = ;
parser.allowWhitespace();      var expr = readExpression( parser );
if ( !expr ) { parser.error( 'Expected valid expression' ); }
parts.push({ t: BRACKETED, x: expr });
parser.allowWhitespace();      if ( !parser.matchString( '}' ) ) { parser.error( "Expected closing '}' after interpolated expression" ); }     } else {      literal += '$';     }    } else {     literal += next;    }   } else {    next = parser.matchPattern( lineContinuationPattern );    if ( next ) {     // convert \(newline-like) into a \u escape, which is allowed in JSON     literal += '\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );    } else {     done = true;    }   }  }
if ( literal.length ) { parts.push({ t: STRING_LITERAL, v: getString( literal ) }); }
if ( !parser.matchString( '`' ) ) { parser.error( "Expected closing '`'" ); }
if ( parts.length === 1 ) {   return parts[0];  } else {   var result = parts.pop();   var part;
while ( part = parts.pop() ) {    result = {     t: INFIX_OPERATOR,     s: '+',     o: [ part, result ]    };   }
return {    t: BRACKETED,    x: result   };  } }
var name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/; var spreadPattern = /^\s*\.{3}/; var legalReference = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:\.(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/; var relaxedName = /^[a-zA-Z_$][-\/a-zA-Z_$0-9]*(?:\.(?:[a-zA-Z_$][-\/a-zA-Z_$0-9]*))*/;
var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
// http://mathiasbynens.be/notes/javascript-properties // can be any name, string literal, or number literal function readKey ( parser ) {  var token;
if ( token = readStringLiteral( parser ) ) {   return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';  }
if ( token = readNumberLiteral$1( parser ) ) {   return token.v;  }
if ( token = parser.matchPattern( name ) ) {   return token;  }
return null; }
function readKeyValuePair ( parser ) {  var spread;  var start = parser.pos;
// allow whitespace between '{' and key  parser.allowWhitespace();
var refKey = parser.nextChar() !== '\ && parser.nextChar() !== '"'; if ( refKey ) { spread = parser.matchPattern( spreadPattern ); }
var key = spread ? readExpression( parser ) : readKey( parser );  if ( key === null ) {   parser.pos = start;   return null;  }
// allow whitespace between key and ':'  parser.allowWhitespace();
// es2015 shorthand property  if ( refKey && ( parser.nextChar() === ',' || parser.nextChar() === '}' ) ) {   if ( !spread && !name.test( key ) ) {    parser.error( ("Expected a valid reference, but found '" + key + "' instead.") );   }
var pair = {    t: KEY_VALUE_PAIR,    k: key,    v: {     t: REFERENCE,     n: key    }   };
if ( spread ) {    pair.p = true;   }
return pair;  }
// next character must be ':'  if ( !parser.matchString( ':' ) ) {   parser.pos = start;   return null;  }
// allow whitespace between ':' and value  parser.allowWhitespace();
// next expression must be a, well... expression  var value = readExpression( parser );  if ( value === null ) {   parser.pos = start;   return null;  }
return {   t: KEY_VALUE_PAIR,   k: key,   v: value  }; }
function readKeyValuePairs ( parser ) {  var start = parser.pos;
var pair = readKeyValuePair( parser );  if ( pair === null ) {   return null;  }
var pairs = [ pair ];
if ( parser.matchString( ',' ) ) {   var keyValuePairs = readKeyValuePairs( parser );
if ( !keyValuePairs ) {    parser.pos = start;    return null;   }
return pairs.concat( keyValuePairs );  }
return pairs; }
var readObjectLiteral = function ( parser ) {  var start = parser.pos;
// allow whitespace  parser.allowWhitespace();
if ( !parser.matchString( '{' ) ) {   parser.pos = start;   return null;  }
var keyValuePairs = readKeyValuePairs( parser );
// allow whitespace between final value and '}'  parser.allowWhitespace();
if ( !parser.matchString( '}' ) ) {   parser.pos = start;   return null;  }
return {   t: OBJECT_LITERAL,   m: keyValuePairs  }; };
var readArrayLiteral = function ( parser ) {  var start = parser.pos;
// allow whitespace before '['  parser.allowWhitespace();
if ( !parser.matchString( '[' ) ) {   parser.pos = start;   return null;  }
var expressionList = readExpressionList( parser, true );
if ( !parser.matchString( ']' ) ) {   parser.pos = start;   return null;  }
return {   t: ARRAY_LITERAL,   m: expressionList  }; };
function readLiteral ( parser ) {  return readNumberLiteral$1( parser )         ||         readBooleanLiteral( parser )        ||         readStringLiteral( parser )         ||         readTemplateStringLiteral( parser ) ||         readObjectLiteral( parser )         ||         readArrayLiteral( parser )          ||         readNumberLiteral( parser ); }
// if a reference is a browser global, we don't deference it later, so it needs special treatment var globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\b/;
// keywords are not valid references, with the exception of `this` var keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
var prefixPattern = /^(?:\@\.|\@|~\/|(?:\^\^\/(?:\^\^\/)*(?:\.\.\/)*)|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/; var specials = /^(key|index|keypath|rootpath|this|global|shared|context|event|node|local)/;
function readReference ( parser ) {  var prefix, name$$1, global, reference, lastDotIndex;
var startPos = parser.pos;
prefix = parser.matchPattern( prefixPattern ) || ; name$$1 = ( !prefix && parser.relaxedNames && parser.matchPattern( relaxedName ) ) ||    parser.matchPattern( legalReference );  var actual = prefix.length + ( ( name$$1 && name$$1.length ) || 0 );
if ( prefix === '@.' ) {   prefix = '@';   if ( name$$1 ) { name$$1 = 'this.' + name$$1; }   else { name$$1 = 'this'; }  }
if ( !name$$1 && prefix ) {   name$$1 = prefix;   prefix = ; }
if ( !name$$1 ) {   return null;  }
if ( prefix === '@' ) {   if ( !specials.test( name$$1 ) ) {    parser.error( ("Unrecognized special reference @" + name$$1) );   } else if ( ( ~name$$1.indexOf( 'event' ) || ~name$$1.indexOf( 'node' ) ) && !parser.inEvent ) {    parser.error( "@event and @node are only valid references within an event directive" );   } else if ( ~name$$1.indexOf( 'context' ) ) {    parser.pos = parser.pos - ( name$$1.length - 7 );    return {     t: BRACKETED,     x: {      t: REFERENCE,      n: '@context'     }    };   }  }
// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497 )  if ( !prefix && !parser.relaxedNames && keywords.test( name$$1 ) ) {   parser.pos = startPos;   return null;  }
// if this is a browser global, stop here  if ( !prefix && globals.test( name$$1 ) ) {   global = globals.exec( name$$1 )[0];   parser.pos = startPos + global.length;
return {    t: GLOBAL,    v: global   };  }
reference = ( prefix || ) + normalise( name$$1 );
if ( parser.matchString( '(' ) ) {   // if this is a method invocation (as opposed to a function) we need   // to strip the method name from the reference combo, else the context   // will be wrong   // but only if the reference was actually a member and not a refinement   lastDotIndex = reference.lastIndexOf( '.' );   if ( lastDotIndex !== -1 && name$$1[ name$$1.length - 1 ] !== ']' ) {    var refLength = reference.length;    reference = reference.substr( 0, lastDotIndex );    parser.pos = startPos + ( actual - ( refLength - lastDotIndex ) );   } else {    parser.pos -= 1;   }  }
return {   t: REFERENCE,   n: reference.replace( /^this\./, './' ).replace( /^this$/, '.' )  }; }
function readBracketedExpression ( parser ) {  if ( !parser.matchString( '(' ) ) { return null; }
parser.allowWhitespace();
var expr = readExpression( parser );
if ( !expr ) { parser.error( expectedExpression ); }
parser.allowWhitespace();
if ( !parser.matchString( ')' ) ) { parser.error( expectedParen ); }
return {   t: BRACKETED,   x: expr  }; }
var readPrimary = function ( parser ) {  return readLiteral( parser )   || readReference( parser )   || readBracketedExpression( parser ); };
function readRefinement ( parser ) {  // some things call for strict refinement (partial names), meaning no space between reference and refinement  if ( !parser.strictRefinement ) {   parser.allowWhitespace();  }
// "." name  if ( parser.matchString( '.' ) ) {   parser.allowWhitespace();
var name$$1 = parser.matchPattern( name );   if ( name$$1 ) {    return {     t: REFINEMENT,     n: name$$1    };   }
parser.error( 'Expected a property name' );  }
// "[" expression "]"  if ( parser.matchString( '[' ) ) {   parser.allowWhitespace();
var expr = readExpression( parser );   if ( !expr ) { parser.error( expectedExpression ); }
parser.allowWhitespace();
if ( !parser.matchString( ']' ) ) { parser.error( "Expected ']'" ); }
return {    t: REFINEMENT,    x: expr   };  }
return null; }
var readMemberOrInvocation = function ( parser ) {  var expression = readPrimary( parser );
if ( !expression ) { return null; }
while ( expression ) {   var refinement = readRefinement( parser );   if ( refinement ) {    expression = {     t: MEMBER,     x: expression,     r: refinement    };   }
else if ( parser.matchString( '(' ) ) {    parser.allowWhitespace();    var expressionList = readExpressionList( parser, true );
parser.allowWhitespace();
if ( !parser.matchString( ')' ) ) {     parser.error( expectedParen );    }
expression = {     t: INVOCATION,     x: expression    };
if ( expressionList ) { expression.o = expressionList; }   }
else {    break;   }  }
return expression; };
var readTypeOf;
var makePrefixSequenceMatcher = function ( symbol, fallthrough ) {  return function ( parser ) {   var expression;
if ( expression = fallthrough( parser ) ) {    return expression;   }
if ( !parser.matchString( symbol ) ) {    return null;   }
parser.allowWhitespace();
expression = readExpression( parser );   if ( !expression ) {    parser.error( expectedExpression );   }
return {    s: symbol,    o: expression,    t: PREFIX_OPERATOR   };  }; };
// create all prefix sequence matchers, return readTypeOf (function() {  var i, len, matcher, fallthrough;
var prefixOperators = '! ~ + - typeof'.split( ' ' );
fallthrough = readMemberOrInvocation;  for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {   matcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );   fallthrough = matcher;  }
// typeof operator is higher precedence than multiplication, so provides the  // fallthrough for the multiplication sequence matcher we're about to create  // (we're skipping void and delete)  readTypeOf = fallthrough; }());
var readTypeof = readTypeOf;
var readLogicalOr;
var makeInfixSequenceMatcher = function ( symbol, fallthrough ) {  return function ( parser ) {   // > and / have to be quoted   if ( parser.inUnquotedAttribute && ( symbol === '>' || symbol === '/' ) ) { return fallthrough( parser ); }
var start, left, right;
left = fallthrough( parser );   if ( !left ) {    return null;   }
// Loop to handle left-recursion in a case like `a * b * c` and produce   // left association, i.e. `(a * b) * c`.  The matcher can't call itself   // to parse `left` because that would be infinite regress.   while ( true ) {    start = parser.pos;
parser.allowWhitespace();
if ( !parser.matchString( symbol ) ) {     parser.pos = start;     return left;    }
// special case - in operator must not be followed by [a-zA-Z_$0-9]    if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {     parser.pos = start;     return left;    }
parser.allowWhitespace();
// right operand must also consist of only higher-precedence operators    right = fallthrough( parser );    if ( !right ) {     parser.pos = start;     return left;    }
left = {     t: INFIX_OPERATOR,     s: symbol,     o: [ left, right ]    };
// Loop back around.  If we don't see another occurrence of the symbol,    // we'll return left.   }  }; };
// create all infix sequence matchers, and return readLogicalOr (function() {  var i, len, matcher, fallthrough;
// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence )  // Each sequence matcher will initially fall through to its higher precedence  // neighbour, and only attempt to match if one of the higher precedence operators  // (or, ultimately, a literal, reference, or bracketed expression) already matched  var infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
// A typeof operator is higher precedence than multiplication  fallthrough = readTypeof;  for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {   matcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );   fallthrough = matcher;  }
// Logical OR is the fallthrough for the conditional matcher  readLogicalOr = fallthrough; }());
var readLogicalOr$1 = readLogicalOr;
// The conditional operator is the lowest precedence operator, so we start here function getConditional ( parser ) {  var expression = readLogicalOr$1( parser );  if ( !expression ) {   return null;  }
var start = parser.pos;
parser.allowWhitespace();
if ( !parser.matchString( '?' ) ) {   parser.pos = start;   return expression;  }
parser.allowWhitespace();
var ifTrue = readExpression( parser );  if ( !ifTrue ) {   parser.error( expectedExpression );  }
parser.allowWhitespace();
if ( !parser.matchString( ':' ) ) {   parser.error( 'Expected ":"' );  }
parser.allowWhitespace();
var ifFalse = readExpression( parser );  if ( !ifFalse ) {   parser.error( expectedExpression );  }
return {   t: CONDITIONAL,   o: [ expression, ifTrue, ifFalse ]  }; }
function readExpression ( parser ) {  // The conditional operator is the lowest precedence operator (except yield,  // assignment operators, and commas, none of which are supported), so we  // start there. If it doesn't match, it 'falls through' to progressively  // higher precedence operators, until it eventually matches (or fails to  // match) a 'primary' - a literal or a reference. This way, the abstract syntax  // tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.  return getConditional( parser ); }
function readExpressionList ( parser, spread ) {  var isSpread;  var expressions = [];
var pos = parser.pos;
do {   parser.allowWhitespace();
if ( spread ) {    isSpread = parser.matchPattern( spreadPattern );   }
var expr = readExpression( parser );
if ( expr === null && expressions.length ) {    parser.error( expectedExpression );   } else if ( expr === null ) {    parser.pos = pos;    return null;   }
if ( isSpread ) {    expr.p = true;   }
expressions.push( expr );
parser.allowWhitespace();  } while ( parser.matchString( ',' ) );
return expressions; }
function readExpressionOrReference ( parser, expectedFollowers ) {  var start = parser.pos;  var expression = readExpression( parser );
if ( !expression ) {   // valid reference but invalid expression e.g. ` Template:New `?   var ref = parser.matchPattern( /^(\w+)/ );   if ( ref ) {    return {     t: REFERENCE,     n: ref    };   }
return null;  }
for ( var i = 0; i < expectedFollowers.length; i += 1 ) {   if ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {    return expression;   }  }
parser.pos = start;  return readReference( parser ); }
function flattenExpression ( expression ) {  var refs;  var count = 0;
extractRefs( expression, refs = [] );  var stringified = stringify( expression );
return {   r: refs,   s: getVars(stringified)  };
function getVars(expr) {   var vars = [];   for ( var i = count - 1; i >= 0; i-- ) {    vars.push( ("x$" + i) );   }   return vars.length ? ("(function(){var " + (vars.join(',')) + ";return(" + expr + ");})()") : expr;  }
function stringify ( node ) {   if ( typeof node === 'string' ) {    return node;   }
switch ( node.t ) {    case BOOLEAN_LITERAL:    case GLOBAL:    case NUMBER_LITERAL:    case REGEXP_LITERAL:     return node.v;
case STRING_LITERAL:     return JSON.stringify( String( node.v ) );
case ARRAY_LITERAL:     if ( node.m && hasSpread( node.m )) {      return ("[].concat(" + (makeSpread( node.m, '[', ']', stringify )) + ")");     } else {      return '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : ) + ']'; }
case OBJECT_LITERAL:     if ( node.m && hasSpread( node.m ) ) {      return ("Object.assign({}," + (makeSpread( node.m, '{', '}', stringifyPair)) + ")");     } else {      return '{' + ( node.m ? node.m.map( function (n) { return ((n.k) + ":" + (stringify( n.v ))); } ).join( ',' ) : ) + '}'; }
case PREFIX_OPERATOR:     return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );
case INFIX_OPERATOR:     return stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );
case INVOCATION:     if ( node.o && hasSpread( node.o ) ) {      var id = count++;      return ("(x$" + id + "=" + (stringify(node.x)) + ").apply(x$" + id + "," + (stringify({ t: ARRAY_LITERAL, m: node.o })) + ")");     } else {      return stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : ) + ')'; }
case BRACKETED:     return '(' + stringify( node.x ) + ')';
case MEMBER:     return stringify( node.x ) + stringify( node.r );
case REFINEMENT:     return ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );
case CONDITIONAL:     return stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );
case REFERENCE:     return '_' + refs.indexOf( node.n );
default:     throw new Error( 'Expected legal JavaScript' );   }  }
function stringifyPair ( node ) { return node.p ? stringify( node.k ) : ((node.k) + ":" + (stringify( node.v ))); }
function makeSpread ( list, open, close, fn ) {   var out = list.reduce( function ( a, c ) {    if ( c.p ) {     a.str += "" + (a.open ? close + ',' : a.str.length ? ',' : ) + (fn( c )); } else {     a.str += "" + (!a.str.length ? open : !a.open ? ',' + open : ',') + (fn( c ));    }    a.open = !c.p;    return a;   }, { open: false, str: } ); if ( out.open ) { out.str += close; }   return out.str;  } }
function hasSpread ( list ) {  for ( var i = 0; i < list.length; i++ ) {   if ( list[i].p ) { return true; }  }
return false; }
// TODO maybe refactor this? function extractRefs ( node, refs ) {  if ( node.t === REFERENCE && typeof node.n === 'string' ) {   if ( !~refs.indexOf( node.n ) ) {    refs.unshift( node.n );   }  }
var list = node.o || node.m;  if ( list ) {   if ( isObject( list ) ) {    extractRefs( list, refs );   } else {    var i = list.length;    while ( i-- ) {     extractRefs( list[i], refs );    }   }  }
if ( node.k && node.t === KEY_VALUE_PAIR && typeof node.k !== 'string' ) {   extractRefs( node.k, refs );  }
if ( node.x ) {   extractRefs( node.x, refs );  }
if ( node.r ) {   extractRefs( node.r, refs );  }
if ( node.v ) {   extractRefs( node.v, refs );  } }
function refineExpression ( expression, mustache ) {  var referenceExpression;
if ( expression ) {   while ( expression.t === BRACKETED && expression.x ) {    expression = expression.x;   }
if ( expression.t === REFERENCE ) {    var n = expression.n;    if ( !~n.indexOf( '@context' ) ) {     mustache.r = expression.n;    } else {     mustache.x = flattenExpression( expression );    }   } else {    if ( referenceExpression = getReferenceExpression( expression ) ) {     mustache.rx = referenceExpression;    } else {     mustache.x = flattenExpression( expression );    }   }
return mustache;  } }
// TODO refactor this! it's bewildering function getReferenceExpression ( expression ) {  var members = [];  var refinement;
while ( expression.t === MEMBER && expression.r.t === REFINEMENT ) {   refinement = expression.r;
if ( refinement.x ) {    if ( refinement.x.t === REFERENCE ) {     members.unshift( refinement.x );    } else {     members.unshift( flattenExpression( refinement.x ) );    }   } else {    members.unshift( refinement.n );   }
expression = expression.x;  }
if ( expression.t !== REFERENCE ) {   return null;  }
return {   r: expression.n,   m: members  }; }
var attributeNamePattern = /^[^\s"'>\/=]+/; var onPattern = /^on/; var eventPattern = /^on-([a-zA-Z\*\.$_]((?:[a-zA-Z\*\.$_0-9\-]|\\-)+))$/; var reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|complete|unrender|detach|insert|destruct|attachchild|detachchild)$/; var decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/; var transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/; var boundPattern = /^((bind|class)-(([-a-zA-Z0-9_])+))$/; var directives = {  lazy: { t: BINDING_FLAG, v: 'l' },  twoway: { t: BINDING_FLAG, v: 't' },  'no-delegation': { t: DELEGATE_FLAG } }; var unquotedAttributeValueTextPattern = /^[^\s"'=<>\/`]+/; var proxyEvent = /^[^\s"'=<>@\[\]()]*/; var whitespace = /^\s+/;
var slashes = /\\/g; function splitEvent ( str ) {  var result = [];  var s = 0;
for ( var i = 0; i < str.length; i++ ) {   if ( str[i] === '-' && str[ i - 1 ] !== '\\' ) {    result.push( str.substring( s, i ).replace( slashes, ) ); s = i + 1;   }  }
result.push( str.substring( s ).replace( slashes, ) );
return result; }
function readAttribute ( parser ) {  var name, i, nearest, idx;
parser.allowWhitespace();
name = parser.matchPattern( attributeNamePattern );  if ( !name ) {   return null;  }
// check for accidental delimiter consumption e.g. <tag bool{{>attrs}} /> nearest = name.length;  for ( i = 0; i < parser.tags.length; i++ ) {   if ( ~( idx = name.indexOf( parser.tags[ i ].open ) ) ) {    if ( idx < nearest ) { nearest = idx; }   }  }  if ( nearest < name.length ) {   parser.pos -= name.length - nearest;   name = name.substr( 0, nearest );   if ( !name ) { return null; }  }
return { n: name }; }
function readAttributeValue ( parser ) {  var start = parser.pos;
// next character must be `=`, `/`, `>` or whitespace  if ( !/[=\/>\s]/.test( parser.nextChar() ) ) {   parser.error( 'Expected `=`, `/`, `>` or whitespace' );  }
parser.allowWhitespace();
if ( !parser.matchString( '=' ) ) {   parser.pos = start;   return null;  }
parser.allowWhitespace();
var valueStart = parser.pos;  var startDepth = parser.sectionDepth;
var value = readQuotedAttributeValue( parser, "'" ) ||    readQuotedAttributeValue( parser, "\"" ) ||    readUnquotedAttributeValue( parser );
if ( value === null ) {   parser.error( 'Expected valid attribute value' );  }
if ( parser.sectionDepth !== startDepth ) {   parser.pos = valueStart;   parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );  }
if ( !value.length ) {   return ; }
if ( value.length === 1 && typeof value[0] === 'string' ) {   return decodeCharacterReferences( value[0] );  }
return value; }
function readUnquotedAttributeValueToken ( parser ) {  var text, index;
var start = parser.pos;
text = parser.matchPattern( unquotedAttributeValueTextPattern );
if ( !text ) {   return null;  }
var haystack = text;  var needles = parser.tags.map( function (t) { return t.open; } ); // TODO refactor... we do this in readText.js as well
if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {   text = text.substr( 0, index );   parser.pos = start + text.length;  }
return text; }
function readUnquotedAttributeValue ( parser ) {  parser.inAttribute = true;
var tokens = [];
var token = readMustache( parser ) || readUnquotedAttributeValueToken( parser );  while ( token ) {   tokens.push( token );   token = readMustache( parser ) || readUnquotedAttributeValueToken( parser );  }
if ( !tokens.length ) {   return null;  }
parser.inAttribute = false;  return tokens; }
function readQuotedAttributeValue ( parser, quoteMark ) {  var start = parser.pos;
if ( !parser.matchString( quoteMark ) ) {   return null;  }
parser.inAttribute = quoteMark;
var tokens = [];
var token = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );  while ( token !== null ) {   tokens.push( token );   token = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );  }
if ( !parser.matchString( quoteMark ) ) {   parser.pos = start;   return null;  }
parser.inAttribute = false;
return tokens; }
function readQuotedStringToken ( parser, quoteMark ) {  var haystack = parser.remaining();
var needles = parser.tags.map( function (t) { return t.open; } ); // TODO refactor... we do this in readText.js as well  needles.push( quoteMark );
var index = getLowestIndex( haystack, needles );
if ( index === -1 ) {   parser.error( 'Quoted attribute value must have a closing quote' );  }
if ( !index ) {   return null;  }
parser.pos += index;  return haystack.substr( 0, index ); }
function readAttributeOrDirective ( parser ) {  var match, directive;
var attribute = readAttribute( parser, false );
if ( !attribute ) { return null; }
// lazy, twoway  if ( directive = directives[ attribute.n ] ) {   attribute.t = directive.t;   if ( directive.v ) { attribute.v = directive.v; }   delete attribute.n; // no name necessary   parser.allowWhitespace();   if ( parser.nextChar() === '=' ) { attribute.f = readAttributeValue( parser ); }  }
// decorators  else if ( match = decoratorPattern.exec( attribute.n ) ) {   attribute.n = match[1];   attribute.t = DECORATOR;   readArguments( parser, attribute );  }
// transitions  else if ( match = transitionPattern.exec( attribute.n ) ) {   attribute.n = match[1];   attribute.t = TRANSITION;   readArguments( parser, attribute );   attribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';  }
// on-click etc  else if ( match = eventPattern.exec( attribute.n ) ) {   attribute.n = splitEvent( match[1] );   attribute.t = EVENT;
parser.inEvent = true;
// check for a proxy event   if ( !readProxyEvent( parser, attribute ) ) {     // otherwise, it's an expression    readArguments( parser, attribute, true );   } else if ( reservedEventNames.test( attribute.f ) ) {    parser.pos -= attribute.f.length;    parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, complete, detach, insert, destruct, attachchild, detachchild)' );   }
parser.inEvent = false;  }
// bound directives  else if ( match = boundPattern.exec( attribute.n ) ){   var bind = match[2] === 'bind';   attribute.n = bind ? match[3] : match[1];   attribute.t = ATTRIBUTE;   readArguments( parser, attribute, false, true );
if ( !attribute.f && bind ) {    attribute.f = [{ t: INTERPOLATOR, r: match[3] }];   }  }
else {   parser.allowWhitespace();   var value = parser.nextChar() === '=' ? readAttributeValue( parser ) : null;   attribute.f = value != null ? value : attribute.f;
if ( parser.sanitizeEventAttributes && onPattern.test( attribute.n ) ) {    return { exclude: true };   } else {    attribute.f = attribute.f || ( attribute.f ===  ?  : 0 );    attribute.t = ATTRIBUTE;   }  }
return attribute; }
function readProxyEvent ( parser, attribute ) {  var start = parser.pos;  if ( !parser.matchString( '=' ) ) { parser.error( "Missing required directive arguments" ); }
var quote = parser.matchString( "'" ) || parser.matchString( "\"" );  parser.allowWhitespace();  var proxy = parser.matchPattern( proxyEvent );
if ( proxy !== undefined ) {   if ( quote ) {    parser.allowWhitespace();    if ( !parser.matchString( quote ) ) { parser.pos = start; }    else { return ( attribute.f = proxy ) || true; }   } else if ( !parser.matchPattern( whitespace ) ) {    parser.pos = start;   } else {    return ( attribute.f = proxy ) || true;   }  } else {   parser.pos = start;  } }
function readArguments ( parser, attribute, required, single ) {  if ( required === void 0 ) required = false;  if ( single === void 0 ) single = false;
parser.allowWhitespace();  if ( !parser.matchString( '=' ) ) {   if ( required ) { parser.error( "Missing required directive arguments" ); }   return;  }  parser.allowWhitespace();
var quote = parser.matchString( '"' ) || parser.matchString( "'" );  var spread = parser.spreadArgs;  parser.spreadArgs = true;  parser.inUnquotedAttribute = !quote;  var expr = single ? readExpressionOrReference( parser, [ quote || ' ', '/', '>' ] ) : { m: readExpressionList( parser ), t: ARRAY_LITERAL };  parser.inUnquotedAttribute = false;  parser.spreadArgs = spread;
if ( quote ) {   parser.allowWhitespace();   if ( parser.matchString( quote ) !== quote ) { parser.error( ("Expected matching quote '" + quote + "'") ); }  }
if ( single ) {   var interpolator = { t: INTERPOLATOR };   refineExpression( expr, interpolator );   attribute.f = [interpolator];  } else {   attribute.f = flattenExpression( expr );  } }
var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };
function readMustache ( parser ) {  var mustache, i;
// If we're inside a <script> or <style> tag, and we're not  // interpolating, bug out  if ( parser.interpolate[ parser.inside ] === false ) { return null;  }
for ( i = 0; i < parser.tags.length; i += 1 ) {   if ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {    return mustache;   }  }
if ( parser.inTag && !parser.inAttribute ) {   mustache = readAttributeOrDirective( parser );   if ( mustache ) {    parser.allowWhitespace();    return mustache;   }  } }
function readMustacheOfType ( parser, tag ) {  var mustache, reader, i;
var start = parser.pos;
if ( parser.matchString( '\\' + tag.open ) ) {   if ( start === 0 || parser.str[ start - 1 ] !== '\\' ) {    return tag.open;   }  } else if ( !parser.matchString( tag.open ) ) {   return null;  }
// delimiter change?  if ( mustache = readDelimiterChange( parser ) ) {   // find closing delimiter or abort...   if ( !parser.matchString( tag.close ) ) {    return null;   }
// ...then make the switch   tag.open = mustache[0];   tag.close = mustache[1];   parser.sortMustacheTags();
return delimiterChangeToken;  }
parser.allowWhitespace();
// illegal section closer  if ( parser.matchString( '/' ) ) {   parser.pos -= 1;   var rewind = parser.pos;   if ( !readNumberLiteral( parser ) ) {    parser.pos = rewind - ( tag.close.length );    if ( parser.inAttribute ) {     parser.pos = start;     return null;    } else {     parser.error( 'Attempted to close a section that wasn\'t open' );    }   } else {    parser.pos = rewind;   }  }
for ( i = 0; i < tag.readers.length; i += 1 ) {   reader = tag.readers[i];
if ( mustache = reader( parser, tag ) ) {    if ( tag.isStatic ) {     mustache.s = 1;    }
if ( parser.includeLinePositions ) {     mustache.p = parser.getLinePos( start );    }
return mustache;   }  }
parser.pos = start;  return null; }
function readTriple ( parser, tag ) {  var expression = readExpression( parser );
if ( !expression ) {   return null;  }
if ( !parser.matchString( tag.close ) ) {   parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );  }
var triple = { t: TRIPLE };  refineExpression( expression, triple ); // TODO handle this differently - it's mysterious
return triple; }
function readUnescaped ( parser, tag ) {  if ( !parser.matchString( '&' ) ) {   return null;  }
parser.allowWhitespace();
var expression = readExpression( parser );
if ( !expression ) {   return null;  }
if ( !parser.matchString( tag.close ) ) {   parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );  }
var triple = { t: TRIPLE };  refineExpression( expression, triple ); // TODO handle this differently - it's mysterious
return triple; }
var legalAlias = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/; var asRE = /^as/i;
function readAliases( parser ) {  var aliases = [];  var alias;  var start = parser.pos;
parser.allowWhitespace();
alias = readAlias( parser );
if ( alias ) {   alias.x = refineExpression( alias.x, {} );   aliases.push( alias );
parser.allowWhitespace();
while ( parser.matchString(',') ) {    alias = readAlias( parser );
if ( !alias ) {     parser.error( 'Expected another alias.' );    }
alias.x = refineExpression( alias.x, {} );    aliases.push( alias );
parser.allowWhitespace();   }
return aliases;  }
parser.pos = start;  return null; }
function readAlias( parser ) {  var start = parser.pos;
parser.allowWhitespace();
var expr = readExpression( parser, [] );
if ( !expr ) {   parser.pos = start;   return null;  }
parser.allowWhitespace();
if ( !parser.matchPattern( asRE ) ) {   parser.pos = start;   return null;  }
parser.allowWhitespace();
var alias = parser.matchPattern( legalAlias );
if ( !alias ) {   parser.error( 'Expected a legal alias name.' );  }
return { n: alias, x: expr }; }
function readPartial ( parser, tag ) {  var type = parser.matchString( '>' ) || parser.matchString( 'yield' );  var partial = { t: type === '>' ? PARTIAL : YIELDER };  var aliases;
if ( !type ) { return null; }
parser.allowWhitespace();
if ( type === '>' || !( aliases = parser.matchString( 'with' ) ) ) {   // Partial names can include hyphens, so we can't use readExpression   // blindly. Instead, we use the `relaxedNames` flag to indicate that   // `foo-bar` should be read as a single name, rather than 'subtract   // bar from foo'   parser.relaxedNames = parser.strictRefinement = true;   var expression = readExpression( parser );   parser.relaxedNames = parser.strictRefinement = false;
if ( !expression && type === '>' ) { return null; }
if ( expression ) {    refineExpression( expression, partial ); // TODO...    parser.allowWhitespace();    if ( type !== '>' ) { aliases = parser.matchString( 'with' ); }   }  }
parser.allowWhitespace();
// check for alias context e.g. `{{>foo bar as bat, bip as bop}}`  if ( aliases || type === '>' ) {   aliases = readAliases( parser );   if ( aliases && aliases.length ) {    partial.z = aliases;   }
// otherwise check for literal context e.g. `{{>foo bar}}` then   // turn it into `{{#with bar}}{{>foo}} Template:/with `   else if ( type === '>' ) {    var context = readExpression( parser );    if ( context) {     partial.c = {};     refineExpression( context, partial.c );    }   }
else {    // Template:Yield with requires some aliases    parser.error( "Expected one or more aliases" );   }  }
parser.allowWhitespace();
if ( !parser.matchString( tag.close ) ) {   parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );  }
return partial; }
function readComment ( parser, tag ) {  if ( !parser.matchString( '!' ) ) {   return null;  }
var index = parser.remaining().indexOf( tag.close );
if ( index !== -1 ) {   parser.pos += index + tag.close.length;   return { t: COMMENT };  } }
function readInterpolator ( parser, tag ) {  var expression, err;
var start = parser.pos;
// TODO would be good for perf if we could do away with the try-catch  try {   expression = readExpressionOrReference( parser, [ tag.close ] );  } catch ( e ) {   err = e;  }
if ( !expression ) {   if ( parser.str.charAt( start ) === '!' ) {    // special case - comment    parser.pos = start;    return null;   }
if ( err ) {    throw err;   }  }
if ( !parser.matchString( tag.close ) ) {   parser.error( ("Expected closing delimiter '" + (tag.close) + "' after reference") );
if ( !expression ) {    // special case - comment    if ( parser.nextChar() === '!' ) {     return null;    }
parser.error( "Expected expression or legal reference" );   }  }
var interpolator = { t: INTERPOLATOR };  refineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious
return interpolator; }
function readClosing ( parser, tag ) {  var start = parser.pos;
if ( !parser.matchString( tag.open ) ) {   return null;  }
parser.allowWhitespace();
if ( !parser.matchString( '/' ) ) {   parser.pos = start;   return null;  }
parser.allowWhitespace();
var remaining = parser.remaining();  var index = remaining.indexOf( tag.close );
if ( index !== -1 ) {   var closing = {    t: CLOSING,    r: remaining.substr( 0, index ).split( ' ' )[0]   };
parser.pos += index;
if ( !parser.matchString( tag.close ) ) {    parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );   }
return closing;  }
parser.pos = start;  return null; }
var elsePattern = /^\s*else\s*/;
function readElse ( parser, tag ) {  var start = parser.pos;
if ( !parser.matchString( tag.open ) ) {   return null;  }
if ( !parser.matchPattern( elsePattern ) ) {   parser.pos = start;   return null;  }
if ( !parser.matchString( tag.close ) ) {   parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );  }
return {   t: ELSE  }; }
var elsePattern$1 = /^\s*elseif\s+/;
function readElseIf ( parser, tag ) {  var start = parser.pos;
if ( !parser.matchString( tag.open ) ) {   return null;  }
if ( !parser.matchPattern( elsePattern$1 ) ) {   parser.pos = start;   return null;  }
var expression = readExpression( parser );
if ( !parser.matchString( tag.close ) ) {   parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );  }
return {   t: ELSEIF,   x: expression  }; }
var handlebarsBlockCodes = {  each:    SECTION_EACH,  if:      SECTION_IF,  with:    SECTION_IF_WITH,  unless:  SECTION_UNLESS };
var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/; var keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/; var handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' );
function readSection ( parser, tag ) {  var expression, section, child, children, hasElse, block, unlessBlock, closed, i, expectedClose;  var aliasOnly = false;
var start = parser.pos;
if ( parser.matchString( '^' ) ) {   // watch out for parent context refs - Template:^^/^^/foo if ( parser.matchString( '^/' ) ){    parser.pos = start;    return null;   }   section = { t: SECTION, f: [], n: SECTION_UNLESS };  } else if ( parser.matchString( '#' ) ) {   section = { t: SECTION, f: [] };
if ( parser.matchString( 'partial' ) ) {    parser.pos = start - parser.standardDelimiters[0].length;    parser.error( 'Partial definitions can only be at the top level of the template, or immediately inside components' );   }
if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {    expectedClose = block;    section.n = handlebarsBlockCodes[ block ];   }  } else {   return null;  }
parser.allowWhitespace();
if ( block === 'with' ) {   var aliases = readAliases( parser );   if ( aliases ) {    aliasOnly = true;    section.z = aliases;    section.t = ALIAS;   }  } else if ( block === 'each' ) {   var alias = readAlias( parser );   if ( alias ) {    section.z = [ { n: alias.n, x: { r: '.' } } ];    expression = alias.x;   }  }
if ( !aliasOnly ) {   if ( !expression ) { expression = readExpression( parser ); }
if ( !expression ) {    parser.error( 'Expected expression' );   }
// optional index and key references   if ( i = parser.matchPattern( indexRefPattern ) ) {    var extra;
if ( extra = parser.matchPattern( keyIndexRefPattern ) ) {     section.i = i + ',' + extra;    } else {     section.i = i;    }   }
if ( !block && expression.n ) {    expectedClose = expression.n;   }  }
parser.allowWhitespace();
if ( !parser.matchString( tag.close ) ) {   parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );  }
parser.sectionDepth += 1;  children = section.f;
var pos;  do {   pos = parser.pos;   if ( child = readClosing( parser, tag ) ) {    if ( expectedClose && child.r !== expectedClose ) {     if ( !block ) {      if ( child.r ) { parser.warn( ("Expected " + (tag.open) + "/" + expectedClose + (tag.close) + " but found " + (tag.open) + "/" + (child.r) + (tag.close)) ); }     } else {      parser.pos = pos;      parser.error( ("Expected " + (tag.open) + "/" + expectedClose + (tag.close)) );     }    }
parser.sectionDepth -= 1;    closed = true;   }
else if ( !aliasOnly && ( child = readElseIf( parser, tag ) ) ) {    if ( section.n === SECTION_UNLESS ) {     parser.error( ' Template:Else not allowed in {{#unless}}' );    }
if ( hasElse ) {     parser.error( 'illegal Template:Elseif... after Template:Else ' );    }
if ( !unlessBlock ) {     unlessBlock = [];    }
var mustache = {     t: SECTION,     n: SECTION_IF,     f: children = []    };    refineExpression( child.x, mustache );
unlessBlock.push( mustache );   }
else if ( !aliasOnly && ( child = readElse( parser, tag ) ) ) {    if ( section.n === SECTION_UNLESS ) {     parser.error( ' Template:Else not allowed in {{#unless}}' );    }
if ( hasElse ) {     parser.error( 'there can only be one Template:Else block, at the end of a section' );    }
hasElse = true;
// use an unless block if there's no elseif    if ( !unlessBlock ) {     unlessBlock = [];    }
unlessBlock.push({     t: SECTION,     n: SECTION_UNLESS,     f: children = []    });   }
else {    child = parser.read( READERS );
if ( !child ) {     break;    }
children.push( child );   }  } while ( !closed );
if ( unlessBlock ) {   section.l = unlessBlock;  }
if ( !aliasOnly ) {   refineExpression( expression, section );  }
// TODO if a section is empty it should be discarded. Don't do  // that here though - we need to clean everything up first, as  // it may contain removeable whitespace. As a temporary measure,  // to pass the existing tests, remove empty `f` arrays  if ( !section.f.length ) {   delete section.f;  }
return section; }
var OPEN_COMMENT = ;
function readHtmlComment ( parser ) {  var start = parser.pos;
if ( parser.textOnlyMode || !parser.matchString( OPEN_COMMENT ) ) {   return null;  }
var remaining = parser.remaining();  var endIndex = remaining.indexOf( CLOSE_COMMENT );
if ( endIndex === -1 ) {   parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );  }
var content = remaining.substr( 0, endIndex );  parser.pos += endIndex + 3;
var comment = {   t: COMMENT,   c: content  };
if ( parser.includeLinePositions ) {   comment.p = parser.getLinePos( start );  }
return comment; }
var leadingLinebreak = /^[ \t\f\r\n]*\r?\n/; var trailingLinebreak = /\r?\n[ \t\f\r\n]*$/;
var stripStandalones = function ( items ) {  var i, current, backOne, backTwo, lastSectionItem;
for ( i=1; i<items.length; i+=1 ) {   current = items[i];   backOne = items[i-1];   backTwo = items[i-2];
// if we're at the end of a [text][comment][text] sequence...   if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
// ... and the comment is a standalone (i.e. line breaks either side)...    if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
// ... then we want to remove the whitespace after the first line break     items[i-2] = backTwo.replace( trailingLinebreak, '\n' );
// and the leading line break of the second text token     items[i] = current.replace( leadingLinebreak, ); }   }
// if the current item is a section, and it is preceded by a linebreak, and   // its first item is a linebreak...   if ( isSection( current ) && isString( backOne ) ) {    if ( trailingLinebreak.test( backOne ) && isString( current.f[0] ) && leadingLinebreak.test( current.f[0] ) ) {     items[i-1] = backOne.replace( trailingLinebreak, '\n' );     current.f[0] = current.f[0].replace( leadingLinebreak, ); }   }
// if the last item was a section, and it is followed by a linebreak, and   // its last item is a linebreak...   if ( isString( current ) && isSection( backOne ) ) {    lastSectionItem = lastItem( backOne.f );
if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {     backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );     items[i] = current.replace( leadingLinebreak, ); }   }  }
return items; };
function isString ( item ) {  return typeof item === 'string'; }
function isComment ( item ) {  return item.t === COMMENT || item.t === DELIMCHANGE; }
function isSection ( item ) {  return ( item.t === SECTION || item.t === INVERTED ) && item.f; }
var trimWhitespace = function ( items, leadingPattern, trailingPattern ) {  var item;
if ( leadingPattern ) {   item = items[0];   if ( typeof item === 'string' ) {    item = item.replace( leadingPattern, );
if ( !item ) {     items.shift();    } else {     items[0] = item;    }   }  }
if ( trailingPattern ) {   item = lastItem( items );   if ( typeof item === 'string' ) {    item = item.replace( trailingPattern, );
if ( !item ) {     items.pop();    } else {     items[ items.length - 1 ] = item;    }   }  } };
var contiguousWhitespace = /[ \t\f\r\n]+/g; var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i; var leadingWhitespace$1 = /^[ \t\f\r\n]+/; var trailingWhitespace = /[ \t\f\r\n]+$/; var leadingNewLine = /^(?:\r\n|\r|\n)/; var trailingNewLine = /(?:\r\n|\r|\n)$/;
function cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {  if ( typeof items === 'string' ) { return; }
var i,   item,   previousItem,   nextItem,   preserveWhitespaceInsideFragment,   removeLeadingWhitespaceInsideFragment,   removeTrailingWhitespaceInsideFragment;
// First pass - remove standalones and comments etc  stripStandalones( items );
i = items.length;  while ( i-- ) {   item = items[i];
// Remove delimiter changes, unsafe elements etc   if ( item.exclude ) {    items.splice( i, 1 );   }
// Remove comments, unless we want to keep them   else if ( stripComments && item.t === COMMENT ) {    items.splice( i, 1 );   }  }
// If necessary, remove leading and trailing whitespace  trimWhitespace( items, removeLeadingWhitespace ? leadingWhitespace$1 : null, removeTrailingWhitespace ? trailingWhitespace : null );
i = items.length;  while ( i-- ) {   item = items[i];
// Recurse   if ( item.f ) {    var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test( item.e );    preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;
if ( !preserveWhitespace && isPreserveWhitespaceElement ) {     trimWhitespace( item.f, leadingNewLine, trailingNewLine );    }
if ( !preserveWhitespaceInsideFragment ) {     previousItem = items[ i - 1 ];     nextItem = items[ i + 1 ];
// if the previous item was a text item with trailing whitespace,     // remove leading whitespace inside the fragment     if ( !previousItem || ( typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) ) {      removeLeadingWhitespaceInsideFragment = true;     }
// and vice versa     if ( !nextItem || ( typeof nextItem === 'string' && leadingWhitespace$1.test( nextItem ) ) ) {      removeTrailingWhitespaceInsideFragment = true;     }    }
cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );   }
// Split if-else blocks into two (an if, and an unless)   if ( item.l ) {    cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
item.l.forEach( function (s) { return s.l = 1; } );    item.l.unshift( i + 1, 0 );    items.splice.apply( items, item.l );    delete item.l; // TODO would be nice if there was a way around this   }
// Clean up conditional attributes   if ( item.m ) {    cleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );    if ( item.m.length < 1 ) { delete item.m; }   }  }
// final pass - fuse text nodes together  i = items.length;  while ( i-- ) {   if ( typeof items[i] === 'string' ) {    if ( typeof items[i+1] === 'string' ) {     items[i] = items[i] + items[i+1];     items.splice( i + 1, 1 );    }
if ( !preserveWhitespace ) {     items[i] = items[i].replace( contiguousWhitespace, ' ' );    }
if ( items[i] === ) { items.splice( i, 1 );    }   }  } }
var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
function readClosingTag ( parser ) {  var tag;
var start = parser.pos;
// are we looking at a closing tag?  if ( !parser.matchString( '</' ) ) {   return null;  }
if ( tag = parser.matchPattern( closingTagPattern ) ) {   if ( parser.inside && tag !== parser.inside ) {    parser.pos = start;    return null;   }
return {    t: CLOSING_TAG,    e: tag   };  }
// We have an illegal closing tag, report it  parser.pos -= 2;  parser.error( 'Illegal closing tag' ); }
var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/; var anchorPattern = /^[a-zA-Z_$][-a-zA-Z0-9_$]*/; var validTagNameFollower = /^[\s\n\/>]/; var exclude = { exclude: true };
// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission var disallowedContents = {  li: [ 'li' ],  dt: [ 'dt', 'dd' ],  dd: [ 'dt', 'dd' ],  p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),  rt: [ 'rt', 'rp' ],  rp: [ 'rt', 'rp' ],  optgroup: [ 'optgroup' ],  option: [ 'option', 'optgroup' ],  thead: [ 'tbody', 'tfoot' ],  tbody: [ 'tbody', 'tfoot' ],  tfoot: [ 'tbody' ],  tr: [ 'tr', 'tbody' ],  td: [ 'td', 'th', 'tr' ],  th: [ 'td', 'th', 'tr' ] };
function readElement$1 ( parser ) {  var attribute, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag, anchor;
var start = parser.pos;
if ( parser.inside || parser.inAttribute || parser.textOnlyMode ) {   return null;  }
if ( !parser.matchString( '<' ) ) {   return null;  }
// if this is a closing tag, abort straight away  if ( parser.nextChar() === '/' ) {   return null;  }
var element = {};  if ( parser.includeLinePositions ) {   element.p = parser.getLinePos( start );  }
// check for doctype decl  if ( parser.matchString( '!' ) ) {   element.t = DOCTYPE;   if ( !parser.matchPattern( /^doctype/i ) ) {    parser.error( 'Expected DOCTYPE declaration' );   }
element.a = parser.matchPattern( /^(.+?)>/ );   return element;  }  // check for anchor  else if ( anchor = parser.matchString( '#' ) ) {   parser.allowWhitespace();   element.t = ANCHOR;   element.n = parser.matchPattern( anchorPattern );  }  // otherwise, it's an element/component  else {   element.t = ELEMENT;
// element name   element.e = parser.matchPattern( tagNamePattern );   if ( !element.e ) {    return null;   }  }
// next character must be whitespace, closing solidus or '>'  if ( !validTagNameFollower.test( parser.nextChar() ) ) {   parser.error( 'Illegal tag name' );  }
parser.allowWhitespace();
parser.inTag = true;
// directives and attributes  while ( attribute = readMustache( parser ) ) {   if ( attribute !== false ) {    if ( !element.m ) { element.m = []; }    element.m.push( attribute );   }
parser.allowWhitespace();  }
parser.inTag = false;
// allow whitespace before closing solidus  parser.allowWhitespace();
// self-closing solidus?  if ( parser.matchString( '/' ) ) {   selfClosing = true;  }
// closing angle bracket  if ( !parser.matchString( '>' ) ) {   return null;  }
var lowerCaseName = ( element.e || element.n ).toLowerCase();  var preserveWhitespace = parser.preserveWhitespace;
if ( !selfClosing && ( anchor || !voidElementNames.test( element.e ) ) ) {   if ( !anchor ) {    parser.elementStack.push( lowerCaseName );
// Special case - if we open a script element, further tags should    // be ignored unless they're a closing script element    if ( lowerCaseName in parser.interpolate ) {     parser.inside = lowerCaseName;    }   }
children = [];   partials = Object.create( null );
do {    pos = parser.pos;    remaining = parser.remaining();
if ( !remaining ) {     parser.error( ("Missing end " + (parser.elementStack.length > 1 ? 'tags' : 'tag') + " (" + (parser.elementStack.reverse().map( function (x) { return ("</" + x + ">"); } ).join( )) + ")") ); }
// if for example we're in an
element, and we see another    //
tag, close the first so they become siblings    if ( !anchor && !canContain( lowerCaseName, remaining ) ) {     closed = true;    }     // closing tag    else if ( !anchor && ( closingTag = readClosingTag( parser ) ) ) {     closed = true;      var closingTagName = closingTag.e.toLowerCase();      // if this *isn't* the closing tag for the current element...     if ( closingTagName !== lowerCaseName ) {      // rewind parser      parser.pos = pos;       // if it doesn't close a parent tag, error      if ( !~parser.elementStack.indexOf( closingTagName ) ) {       var errorMessage = 'Unexpected closing tag';        // add additional help for void elements, since component names       // might clash with them       if ( voidElementNames.test( closingTagName ) ) {        errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";       }        parser.error( errorMessage );      }     }    }     else if ( anchor && readAnchorClose( parser, element.n ) ) {     closed = true;    }     // implicit close by closing section tag. TODO clean this up    else if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {     closed = true;     parser.pos = pos;    }     else {     if ( child = parser.read( PARTIAL_READERS ) ) {      if ( partials[ child.n ] ) {       parser.pos = pos;       parser.error( 'Duplicate partial definition' );      }       cleanup( child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );       partials[ child.n ] = child.f;      hasPartials = true;     }      else {      if ( child = parser.read( READERS ) ) {       children.push( child );      } else {       closed = true;      }     }    }   } while ( !closed );    if ( children.length ) {    element.f = children;   }    if ( hasPartials ) {    element.p = partials;   }    parser.elementStack.pop();  }   parser.inside = null;   if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {   return exclude;  }   return element; }  function canContain ( name, remaining ) {  var match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );  var disallowed = disallowedContents[ name ];   if ( !match || !disallowed ) {   return true;  }   return !~disallowed.indexOf( match[1].toLowerCase() ); }  function readAnchorClose ( parser, name ) {  var pos = parser.pos;  if ( !parser.matchString( '</' ) ) {   return null;  }   parser.matchString( '#' );  parser.allowWhitespace();   if ( !parser.matchString( name ) ) {   parser.pos = pos;   return null;  }   parser.allowWhitespace();   if ( !parser.matchString( '>' ) ) {   parser.pos = pos;   return null;  }   return true; }  function readText ( parser ) {  var index, disallowed, barrier;   var remaining = parser.remaining();   if ( parser.textOnlyMode ) {   disallowed = parser.tags.map( function (t) { return t.open; } );   disallowed = disallowed.concat( parser.tags.map( function (t) { return '\\' + t.open; } ) );    index = getLowestIndex( remaining, disallowed );  } else {   barrier = parser.inside ? '</' + parser.inside : '<';    if ( parser.inside && !parser.interpolate[ parser.inside ] ) {    index = remaining.indexOf( barrier );   } else {    disallowed = parser.tags.map( function (t) { return t.open; } );    disallowed = disallowed.concat( parser.tags.map( function (t) { return '\\' + t.open; } ) );     // http://developers.whatwg.org/syntax.html#syntax-attributes if ( parser.inAttribute === true ) {     // we're inside an unquoted attribute value     disallowed.push( "\"", "'", "=", "<", ">", '`' );    } else if ( parser.inAttribute ) {     // quoted attribute value     disallowed.push( parser.inAttribute );    } else {     disallowed.push( barrier );    }     index = getLowestIndex( remaining, disallowed );   }  }   if ( !index ) {   return null;  }   if ( index === -1 ) {   index = remaining.length;  }   parser.pos += index;   if ( ( parser.inside && parser.inside !== 'textarea' ) || parser.textOnlyMode ) {   return remaining.substr( 0, index );  } else {   return decodeCharacterReferences( remaining.substr( 0, index ) );  } }  var partialDefinitionSectionPattern = /^\s*#\s*partial\s+/;  function readPartialDefinitionSection ( parser ) {  var child, closed;   var start = parser.pos;   var delimiters = parser.standardDelimiters;   if ( !parser.matchString( delimiters[0] ) ) {   return null;  }   if ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {   parser.pos = start;   return null;  }   var name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\-\/]*/ );   if ( !name ) {   parser.error( 'expected legal partial name' );  }   parser.allowWhitespace();  if ( !parser.matchString( delimiters[1] ) ) {   parser.error( ("Expected closing delimiter '" + (delimiters[1]) + "'") );  }   var content = [];   var open = delimiters[0];  var close = delimiters[1];   do {   if ( child = readClosing( parser, { open: open, close: close }) ) {    if ( child.r !== 'partial' ) {     parser.error( ("Expected " + open + "/partial" + close) );    }     closed = true;   }    else {    child = parser.read( READERS );     if ( !child ) {     parser.error( ("Expected " + open + "/partial" + close) );    }     content.push( child );   }  } while ( !closed );   return {   t: INLINE_PARTIAL,   n: name,   f: content  }; }  function readTemplate ( parser ) {  var fragment = [];  var partials = Object.create( null );  var hasPartials = false;   var preserveWhitespace = parser.preserveWhitespace;   while ( parser.pos < parser.str.length ) {   var pos = parser.pos;   var item = (void 0), partial = (void 0);    if ( partial = parser.read( PARTIAL_READERS ) ) {    if ( partials[ partial.n ] ) {     parser.pos = pos;     parser.error( 'Duplicated partial definition' );    }     cleanup( partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );     partials[ partial.n ] = partial.f;    hasPartials = true;   } else if ( item = parser.read( READERS ) ) {    fragment.push( item );   } else  {    parser.error( 'Unexpected template content' );   }  }   var result = {   v: TEMPLATE_VERSION,   t: fragment  };   if ( hasPartials ) {   result.p = partials;  }   return result; }  function insertExpressions ( obj, expr ) {   Object.keys( obj ).forEach( function (key) {   if  ( isExpression( key, obj ) ) { return addTo( obj, expr ); }    var ref = obj[ key ];   if ( hasChildren( ref ) ) { insertExpressions( ref, expr ); }  }); }  function isExpression( key, obj ) {  return key === 's' && Array.isArray( obj.r ); }  function addTo( obj, expr ) {  var s = obj.s;  var r = obj.r;  if ( !expr[ s ] ) { expr[ s ] = fromExpression( s, r.length ); } }  function hasChildren( ref ) {  return Array.isArray( ref ) || isObject( ref ); }  var shared = {};  // See https://github.com/ractivejs/template-spec for information // about the Ractive template specification  var STANDARD_READERS = [ readPartial, readUnescaped, readSection, readInterpolator, readComment ]; var TRIPLE_READERS = [ readTriple ]; var STATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?  var READERS = [ readMustache, readHtmlComment, readElement$1, readText ]; var PARTIAL_READERS = [ readPartialDefinitionSection ];  var defaultInterpolate = [ 'script', 'style', 'template' ];  var StandardParser = Parser.extend({  init: function init ( str, options ) {   var this$1 = this;    var tripleDelimiters = options.tripleDelimiters || shared.defaults.tripleDelimiters;   var staticDelimiters = options.staticDelimiters || shared.defaults.staticDelimiters;   var staticTripleDelimiters = options.staticTripleDelimiters || shared.defaults.staticTripleDelimiters;    this.standardDelimiters = options.delimiters || shared.defaults.delimiters;    this.tags = [    { isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },    { isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },    { isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },    { isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }   ];    this.contextLines = options.contextLines || shared.defaults.contextLines;    this.sortMustacheTags();    this.sectionDepth = 0;   this.elementStack = [];    this.interpolate = Object.create( options.interpolate || shared.defaults.interpolate || {} );   this.interpolate.textarea = true;   defaultInterpolate.forEach( function (t) { return this$1.interpolate[ t ] = !options.interpolate || options.interpolate[ t ] !== false; } );    if ( options.sanitize === true ) {    options.sanitize = {     // blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),     eventAttributes: true    };   }    this.stripComments = options.stripComments !== false;   this.preserveWhitespace = options.preserveWhitespace;   this.sanitizeElements = options.sanitize && options.sanitize.elements;   this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;   this.includeLinePositions = options.includeLinePositions;   this.textOnlyMode = options.textOnlyMode;   this.csp = options.csp;    this.transforms = options.transforms || options.parserTransforms;   if ( this.transforms ) {    this.transforms = this.transforms.concat( shared.defaults.parserTransforms );   } else {    this.transforms = shared.defaults.parserTransforms;   }  },   postProcess: function postProcess ( result ) {   // special case - empty string   if ( !result.length ) {    return { t: [], v: TEMPLATE_VERSION };   }    if ( this.sectionDepth > 0 ) {    this.error( 'A section was left open' );   }    cleanup( result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace );    var transforms = this.transforms;   if ( transforms.length ) {    var tlen = transforms.length;    var walk = function ( fragment ) {     var len = fragment.length;      for ( var i = 0; i < len; i++ ) {      var node = fragment[i];       if ( node.t === ELEMENT ) {       for ( var j = 0; j < tlen; j++ ) {        var res = transforms[j].call( shared.Ractive, node );        if ( !res ) {         continue;        } else if ( res.remove ) {         fragment.splice( i--, 1 );         len--;         break;        } else if ( res.replace ) {         if ( Array.isArray( res.replace ) ) {          fragment.splice.apply( fragment, [ i--, 1 ].concat( res.replace ) );          len += res.replace.length - 1;         } else {          fragment[i--] = node = res.replace;         }          break;        }       }        // watch for partials       if ( node.p ) {        for ( var k in node.p ) { walk( node.p[k] ); }       }      }       if ( node.f ) { walk( node.f ); }     }    };     // process the root fragment    walk( result[0].t );     // watch for root partials    if ( result[0].p ) {     for ( var k in result[0].p ) { walk( result[0].p[k] ); }    }   }    if ( this.csp !== false ) {    var expr = {};    insertExpressions( result[0].t, expr );    if ( Object.keys( expr ).length ) { result[0].e = expr; }   }    return result[0];  },   converters: [   readTemplate  ],   sortMustacheTags: function sortMustacheTags () {   // Sort in order of descending opening delimiter length (longer first),   // to protect against opening delimiters being substrings of each other this.tags.sort( function ( a, b ) {    return b.open.length - a.open.length;   });  } });  function parse ( template, options ) {  return new StandardParser( template, options || {} ).result; }  var parseOptions = [  'delimiters',  'tripleDelimiters',  'staticDelimiters',  'staticTripleDelimiters',  'csp',  'interpolate',  'preserveWhitespace',  'sanitize',  'stripComments',  'contextLines' ];  var TEMPLATE_INSTRUCTIONS = "Either preparse or use a ractive runtime source that includes the parser. ";  var COMPUTATION_INSTRUCTIONS = "Either include a version of Ractive that can parse or convert your computation strings to functions.";   function throwNoParse ( method, error, instructions ) {  if ( !method ) {   fatal( ("Missing Ractive.parse - cannot parse " + error + ". " + instructions) );  } }  function createFunction ( body, length ) {  throwNoParse( fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS );  return fromExpression( body, length ); }  function createFunctionFromString ( str, bindTo ) {  throwNoParse( fromComputationString, 'compution string "${str}"', COMPUTATION_INSTRUCTIONS );  return fromComputationString( str, bindTo ); }  var parser = {   fromId: function fromId ( id, options ) {   if ( !doc ) {    if ( options && options.noThrow ) { return; }    throw new Error( ("Cannot retrieve template #" + id + " as Ractive is not running in a browser.") );   }    if ( id ) { id = id.replace( /^#/, ); } var template;    if ( !( template = doc.getElementById( id ) )) {    if ( options && options.noThrow ) { return; }    throw new Error( ("Could not find template element with id #" + id) );   }    if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {    if ( options && options.noThrow ) { return; }    throw new Error( ("Template element with id #" + id + ", must be a <script> element") );   }    return ( 'textContent' in template ? template.textContent : template.innerHTML );   },   isParsed: function isParsed ( template) { return !( typeof template === 'string' );  },   getParseOptions: function getParseOptions ( ractive ) {   // Could be Ractive or a Component   if ( ractive.defaults ) { ractive = ractive.defaults; }    return parseOptions.reduce( function ( val, key ) {    val[ key ] = ractive[ key ];    return val;   }, {});  },   parse: function parse$1 ( template, options ) {   throwNoParse( parse, 'template', TEMPLATE_INSTRUCTIONS );   var parsed = parse( template, options );   addFunctions( parsed );   return parsed;  },   parseFor: function parseFor( template, ractive ) {   return this.parse( template, this.getParseOptions( ractive ) );  } };  var templateConfigurator = {  name: 'template',   extend: function extend ( Parent, proto, options ) {   // only assign if exists   if ( 'template' in options ) {    var template = options.template;     if ( typeof template === 'function' ) {     proto.template = template;    } else {     proto.template = parseTemplate( template, proto );    }   }  },   init: function init ( Parent, ractive, options ) {   // TODO because of prototypal inheritance, we might just be able to use   // ractive.template, and not bother passing through the Parent object.   // At present that breaks the test mocks' expectations   var template = 'template' in options ? options.template : Parent.prototype.template;   template = template || { v: TEMPLATE_VERSION, t: [] };    if ( typeof template === 'function' ) {    var fn = template;    template = getDynamicTemplate( ractive, fn );     ractive._config.template = {     fn: fn,     result: template    };   }    template = parseTemplate( template, ractive );    // TODO the naming of this is confusing - ractive.template refers to [...],   // but Component.prototype.template refers to {v:1,t:[],p:[]}...   // it's unnecessary, because the developer never needs to access   // ractive.template   ractive.template = template.t;    if ( template.p ) {    extendPartials( ractive.partials, template.p );   }  },   reset: function reset ( ractive ) {   var result = resetValue( ractive );    if ( result ) {    var parsed = parseTemplate( result, ractive );     ractive.template = parsed.t;    extendPartials( ractive.partials, parsed.p, true );     return true;   }  } };  function resetValue ( ractive ) {  var initial = ractive._config.template;   // If this isn't a dynamic template, there's nothing to do  if ( !initial || !initial.fn ) {   return;  }   var result = getDynamicTemplate( ractive, initial.fn );   // TODO deep equality check to prevent unnecessary re-rendering  // in the case of already-parsed templates  if ( result !== initial.result ) {   initial.result = result;   return result;  } }  function getDynamicTemplate ( ractive, fn ) {  return fn.call( ractive, {   fromId: parser.fromId,   isParsed: parser.isParsed,   parse: function parse ( template, options ) {    if ( options === void 0 ) options = parser.getParseOptions( ractive );     return parser.parse( template, options );   }  }); }  function parseTemplate ( template, ractive ) {  if ( typeof template === 'string' ) {   // parse will validate and add expression functions   template = parseAsString( template, ractive );  }  else {   // need to validate and add exp for already parsed template   validate$1( template );   addFunctions( template );  }   return template; }  function parseAsString ( template, ractive ) {  // ID of an element containing the template?  if ( template[0] === '#' ) {   template = parser.fromId( template );  }   return parser.parseFor( template, ractive ); }  function validate$1( template ) {   // Check that the template even exists  if ( template == undefined ) {   throw new Error( ("The template cannot be " + template + ".") );  }   // Check the parsed template has a version at all  else if ( typeof template.v !== 'number' ) {   throw new Error( 'The template parser was passed a non-string template, but the template doesn\'t have a version.  Make sure you\'re passing in the template you think you are.' );  }   // Check we're using the correct version  else if ( template.v !== TEMPLATE_VERSION ) {   throw new Error( ("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + (template.v) + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app") );  } }  function extendPartials ( existingPartials, newPartials, overwrite ) {  if ( !newPartials ) { return; }   // TODO there's an ambiguity here - we need to overwrite in the `reset()`  // case, but not initially...   for ( var key in newPartials ) {   if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {    existingPartials[ key ] = newPartials[ key ];   }  } }  var registryNames = [  'adaptors',  'components',  'computed',  'decorators',  'easing',  'events',  'interpolators',  'partials',  'transitions' ];  var registriesOnDefaults = [  'computed' ];  var Registry = function Registry ( name, useDefaults ) {  this.name = name;  this.useDefaults = useDefaults; };  Registry.prototype.extend = function extend ( Parent, proto, options ) {  var parent = this.useDefaults ? Parent.defaults : Parent;  var target = this.useDefaults ? proto : proto.constructor;  this.configure( parent, target, options ); };  Registry.prototype.init = function init () {  // noop };  Registry.prototype.configure = function configure ( Parent, target, options ) {  var name = this.name;  var option = options[ name ];   var registry = Object.create( Parent[name] );   for ( var key in option ) {   registry[ key ] = option[ key ];  }   target[ name ] = registry; };  Registry.prototype.reset = function reset ( ractive ) {  var registry = ractive[ this.name ];  var changed = false;   Object.keys( registry ).forEach( function (key) {   var item = registry[ key ];    if ( item._fn ) {    if ( item._fn.isOwner ) {     registry[key] = item._fn;    } else {     delete registry[key];    }    changed = true;   }  });   return changed; };  var registries = registryNames.map( function (name) {  var putInDefaults = registriesOnDefaults.indexOf(name) > -1; return new Registry( name, putInDefaults ); });  function wrap ( parent, name, method ) {  if ( !/_super/.test( method ) ) { return method; }   function wrapper () {   var superMethod = getSuperMethod( wrapper._parent, name );   var hasSuper = '_super' in this;   var oldSuper = this._super;    this._super = superMethod;    var result = method.apply( this, arguments );    if ( hasSuper ) {    this._super = oldSuper;   } else {    delete this._super;   }    return result;  }   wrapper._parent = parent;  wrapper._method = method;   return wrapper; }  function getSuperMethod ( parent, name ) {  if ( name in parent ) {   var value = parent[ name ];    return typeof value === 'function' ?    value :    function () { return value; };  }   return noop; }  function getMessage( deprecated, correct, isError ) {  return "options." + deprecated + " has been deprecated in favour of options." + correct + "."   + ( isError ? (" You cannot specify both options, please use options." + correct + ".") : ); }  function deprecateOption ( options, deprecatedOption, correct ) {  if ( deprecatedOption in options ) {   if( !( correct in options ) ) {    warnIfDebug( getMessage( deprecatedOption, correct ) );    options[ correct ] = options[ deprecatedOption ];   } else {    throw new Error( getMessage( deprecatedOption, correct, true ) );   }  } }  function deprecate ( options ) {  deprecateOption( options, 'beforeInit', 'onconstruct' );  deprecateOption( options, 'init', 'onrender' );  deprecateOption( options, 'complete', 'oncomplete' );  deprecateOption( options, 'eventDefinitions', 'events' );   // Using extend with Component instead of options,  // like Human.extend( Spider ) means adaptors as a registry  // gets copied to options. So we have to check if actually an array  if ( Array.isArray( options.adaptors ) ) {   deprecateOption( options, 'adaptors', 'adapt' );  } }  var custom = {  adapt: adaptConfigurator,  css: cssConfigurator,  data: dataConfigurator,  template: templateConfigurator };  var defaultKeys = Object.keys( defaults );  var isStandardKey = makeObj( defaultKeys.filter( function (key) { return !custom[ key ]; } ) );  // blacklisted keys that we don't double extend var isBlacklisted = makeObj( defaultKeys.concat( registries.map( function (r) { return r.name; } ), [ 'on', 'observe', 'attributes' ] ) );  var order = [].concat(  defaultKeys.filter( function (key) { return !registries[ key ] && !custom[ key ]; } ),  registries,  //custom.data,  custom.template,  custom.css );  var config = {  extend: function ( Parent, proto, options ) { return configure( 'extend', Parent, proto, options ); },  init: function ( Parent, ractive, options ) { return configure( 'init', Parent, ractive, options ); },  reset: function (ractive) { return order.filter( function (c) { return c.reset && c.reset( ractive ); } ).map( function (c) { return c.name; } ); } };  function configure ( method, Parent, target, options ) {  deprecate( options );   for ( var key in options ) {   if ( isStandardKey.hasOwnProperty( key ) ) {    var value = options[ key ];     // warn the developer if they passed a function and ignore its value     // NOTE: we allow some functions on "el" because we duck type element lists    // and some libraries or ef'ed-up virtual browsers (phantomJS) return a    // function object as the result of querySelector methods    if ( key !== 'el' && typeof value === 'function' ) {     warnIfDebug( (key + " is a Ractive option that does not expect a function and will be ignored"),      method === 'init' ? target : null );    }    else {     target[ key ] = value;    }   }  }   // disallow combination of `append` and `enhance`  if ( options.append && options.enhance ) {   throw new Error( 'Cannot use append and enhance at the same time' );  }   registries.forEach( function (registry) {   registry[ method ]( Parent, target, options );  });   adaptConfigurator[ method ]( Parent, target, options );  templateConfigurator[ method ]( Parent, target, options );  cssConfigurator[ method ]( Parent, target, options );   extendOtherMethods( Parent.prototype, target, options ); }  var _super = /\b_super\b/; function extendOtherMethods ( parent, target, options ) {  for ( var key in options ) {   if ( !isBlacklisted[ key ] && options.hasOwnProperty( key ) ) {    var member = options[ key ];     // if this is a method that overwrites a method, wrap it:    if ( typeof member === 'function' ) {     if ( key in RactiveProto && !_super.test( member.toString() ) ) {      warnIfDebug( ("Overriding Ractive prototype function '" + key + "' without calling the '" + _super + "' method can be very dangerous.") );     }     member = wrap( parent, key, member );    }     target[ key ] = member;   }  } }  function makeObj ( array ) {  var obj = {};  array.forEach( function (x) { return obj[x] = true; } );  return obj; }  var Item = function Item ( options ) {  this.parentFragment = options.parentFragment;  this.ractive = options.parentFragment.ractive;   this.template = options.template;  this.index = options.index;  this.type = options.template.t;   this.dirty = false; };  Item.prototype.bubble = function bubble () {  if ( !this.dirty ) {   this.dirty = true;   this.parentFragment.bubble();  } };  Item.prototype.destroyed = function destroyed () {  if ( this.fragment ) { this.fragment.destroyed(); } };  Item.prototype.find = function find () {  return null; };  Item.prototype.findComponent = function findComponent () {  return null; };  Item.prototype.findNextNode = function findNextNode () {  return this.parentFragment.findNextNode( this ); };  Item.prototype.shuffled = function shuffled () {  if ( this.fragment ) { this.fragment.shuffled(); } };  Item.prototype.valueOf = function valueOf () {  return this.toString(); };  Item.prototype.findAll = noop; Item.prototype.findAllComponents = noop;  var ContainerItem = (function (Item) {  function ContainerItem ( options ) {   Item.call( this, options );  }   if ( Item ) ContainerItem.__proto__ = Item; ContainerItem.prototype = Object.create( Item && Item.prototype );  ContainerItem.prototype.constructor = ContainerItem;   ContainerItem.prototype.detach = function detach () {   return this.fragment ? this.fragment.detach() : createDocumentFragment();  };   ContainerItem.prototype.find = function find ( selector ) {   if ( this.fragment ) {    return this.fragment.find( selector );   }  };   ContainerItem.prototype.findAll = function findAll ( selector, options ) {   if ( this.fragment ) {    this.fragment.findAll( selector, options );   }  };   ContainerItem.prototype.findComponent = function findComponent ( name ) {   if ( this.fragment ) {    return this.fragment.findComponent( name );   }  };   ContainerItem.prototype.findAllComponents = function findAllComponents ( name, options ) {   if ( this.fragment ) {    this.fragment.findAllComponents( name, options );   }  };   ContainerItem.prototype.firstNode = function firstNode ( skipParent ) {   return this.fragment && this.fragment.firstNode( skipParent );  };   ContainerItem.prototype.toString = function toString ( escape ) {   return this.fragment ? this.fragment.toString( escape ) : ; };   return ContainerItem; }(Item));  var ComputationChild = (function (Model$$1) {  function ComputationChild ( parent, key ) {   Model$$1.call( this, parent, key );    this.isReadonly = !this.root.ractive.syncComputedChildren;   this.dirty = true;  }   if ( Model$$1 ) ComputationChild.__proto__ = Model$$1;  ComputationChild.prototype = Object.create( Model$$1 && Model$$1.prototype );  ComputationChild.prototype.constructor = ComputationChild;   ComputationChild.prototype.applyValue = function applyValue ( value ) {   Model$$1.prototype.applyValue.call( this, value );    if ( !this.isReadonly ) {    var source = this.parent;    // computed models don't have a shuffle method    while ( source && source.shuffle ) {     source = source.parent;    }     if ( source ) {     source.dependencies.forEach( mark ); }   }  };   ComputationChild.prototype.get = function get ( shouldCapture ) {   if ( shouldCapture ) { capture( this ); }    if ( this.dirty ) {    this.dirty = false;    var parentValue = this.parent.get();    this.value = parentValue ? parentValue[ this.key ] : undefined;   }    return this.value;  };   ComputationChild.prototype.handleChange = function handleChange$1 () {   this.dirty = true;    if ( this.boundValue ) { this.boundValue = null; }    this.links.forEach( marked );   this.deps.forEach( handleChange );   this.children.forEach( handleChange );  };   ComputationChild.prototype.joinKey = function joinKey ( key ) {   if ( key === undefined || key === ) { return this; } if ( !this.childByKey.hasOwnProperty( key ) ) {    var child = new ComputationChild( this, key );    this.children.push( child );    this.childByKey[ key ] = child;   }    return this.childByKey[ key ];  };   return ComputationChild; }(Model));  /* global console */ /* eslint no-console:"off" */  var Computation = (function (Model$$1) {  function Computation ( viewmodel, signature, key ) {   Model$$1.call( this, null, null );    this.root = this.parent = viewmodel;   this.signature = signature;    this.key = key; // not actually used, but helps with debugging   this.isExpression = key && key[0] === '@';    this.isReadonly = !this.signature.setter;    this.context = viewmodel.computationContext;    this.dependencies = [];    this.children = [];   this.childByKey = {};    this.deps = [];    this.dirty = true;    // TODO: is there a less hackish way to do this?   this.shuffle = undefined;  }   if ( Model$$1 ) Computation.__proto__ = Model$$1;  Computation.prototype = Object.create( Model$$1 && Model$$1.prototype );  Computation.prototype.constructor = Computation;   Computation.prototype.get = function get ( shouldCapture ) {   if ( shouldCapture ) { capture( this ); }    if ( this.dirty ) {    this.dirty = false;    var old = this.value;    this.value = this.getValue();    if ( !isEqual( old, this.value ) ) { this.notifyUpstream(); }    if ( this.wrapper ) { this.newWrapperValue = this.value; }    this.adapt();   }    // if capturing, this value needs to be unwrapped because it's for external use   return maybeBind( this, shouldCapture && this.wrapper ? this.wrapperValue : this.value );  };   Computation.prototype.getValue = function getValue () {   startCapturing();   var result;    try {    result = this.signature.getter.call( this.context );   } catch ( err ) {    warnIfDebug( ("Failed to compute " + (this.getKeypath()) + ": " + (err.message || err)) );     // TODO this is all well and good in Chrome, but...    // ...also, should encapsulate this stuff better, and only    // show it if Ractive.DEBUG    if ( hasConsole ) {     if ( console.groupCollapsed ) { console.groupCollapsed( '%cshow details', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;' ); }     var sig = this.signature;     console.error( ((err.name) + ": " + (err.message) + "\n\n" + (sig.getterString) + (sig.getterUseStack ? '\n\n' + err.stack : )) ); if ( console.groupCollapsed ) { console.groupEnd(); }    }   }    var dependencies = stopCapturing();   this.setDependencies( dependencies );    return result;  };   Computation.prototype.mark = function mark () {   this.handleChange();  };   Computation.prototype.rebind = function rebind ( next, previous ) {   // computations will grab all of their deps again automagically   if ( next !== previous ) { this.handleChange(); }  };   Computation.prototype.set = function set ( value ) {   if ( this.isReadonly ) {    throw new Error( ("Cannot set read-only computed value '" + (this.key) + "'") );   }    this.signature.setter( value );   this.mark();  };   Computation.prototype.setDependencies = function setDependencies ( dependencies ) {   var this$1 = this;    // unregister any soft dependencies we no longer have   var i = this.dependencies.length;   while ( i-- ) {    var model = this$1.dependencies[i];    if ( !~dependencies.indexOf( model ) ) { model.unregister( this$1 ); }   }    // and add any new ones   i = dependencies.length;   while ( i-- ) {    var model$1 = dependencies[i];    if ( !~this$1.dependencies.indexOf( model$1 ) ) { model$1.register( this$1 ); }   }    this.dependencies = dependencies;  };   Computation.prototype.teardown = function teardown () {   var this$1 = this;    var i = this.dependencies.length;   while ( i-- ) {    if ( this$1.dependencies[i] ) { this$1.dependencies[i].unregister( this$1 ); }   }   if ( this.root.computations[this.key] === this ) { delete this.root.computations[this.key]; }   Model$$1.prototype.teardown.call(this);  };   return Computation; }(Model));  var prototype$1 = Computation.prototype; var child = ComputationChild.prototype; prototype$1.handleChange = child.handleChange; prototype$1.joinKey = child.joinKey;  var ExpressionProxy = (function (Model$$1) {  function ExpressionProxy ( fragment, template ) {   var this$1 = this;    Model$$1.call( this, fragment.ractive.viewmodel, null );    this.fragment = fragment;   this.template = template;    this.isReadonly = true;   this.dirty = true;    this.fn = getFunction( template.s, template.r.length );    this.models = this.template.r.map( function (ref) {    return resolveReference( this$1.fragment, ref );   });   this.dependencies = [];    this.shuffle = undefined;    this.bubble();  }   if ( Model$$1 ) ExpressionProxy.__proto__ = Model$$1;  ExpressionProxy.prototype = Object.create( Model$$1 && Model$$1.prototype );  ExpressionProxy.prototype.constructor = ExpressionProxy;   ExpressionProxy.prototype.bubble = function bubble ( actuallyChanged ) {   if ( actuallyChanged === void 0 ) actuallyChanged = true;    // refresh the keypath   this.keypath = undefined;    if ( actuallyChanged ) {    this.handleChange();   }  };   ExpressionProxy.prototype.getKeypath = function getKeypath () {   var this$1 = this;    if ( !this.template ) { return '@undefined'; }   if ( !this.keypath ) {    this.keypath = '@' + this.template.s.replace( /_(\d+)/g, function ( match, i ) {     if ( i >= this$1.models.length ) { return match; }      var model = this$1.models[i];     return model ? model.getKeypath() : '@undefined';    });   }    return this.keypath;  };   ExpressionProxy.prototype.getValue = function getValue () {   var this$1 = this;    startCapturing();   var result;    try {    var params = this.models.map( function (m) { return m ? m.get( true ) : undefined; } );    result = this.fn.apply( this.fragment.ractive, params );   } catch ( err ) {    warnIfDebug( ("Failed to compute " + (this.getKeypath()) + ": " + (err.message || err)) );   }    var dependencies = stopCapturing();   // remove missing deps   this.dependencies.filter( function (d) { return !~dependencies.indexOf( d ); } ).forEach( function (d) {    d.unregister( this$1 );    removeFromArray( this$1.dependencies, d );   });   // register new deps   dependencies.filter( function (d) { return !~this$1.dependencies.indexOf( d ); } ).forEach( function (d) {    d.register( this$1 );    this$1.dependencies.push( d );   });    return result;  };   ExpressionProxy.prototype.rebind = function rebind ( next, previous, safe ) {   var idx = this.models.indexOf( previous );    if ( ~idx ) {    next = rebindMatch( this.template.r[idx], next, previous );    if ( next !== previous ) {     previous.unregister( this );     this.models.splice( idx, 1, next );     if ( next ) { next.addShuffleRegister( this, 'mark' ); }    }   }   this.bubble( !safe );  };   ExpressionProxy.prototype.retrieve = function retrieve () {   return this.get();  };   ExpressionProxy.prototype.teardown = function teardown () {   var this$1 = this;    this.unbind();   this.fragment = undefined;   if ( this.dependencies ) { this.dependencies.forEach( function (d) { return d.unregister( this$1 ); } ); }   Model$$1.prototype.teardown.call(this);  };   ExpressionProxy.prototype.unreference = function unreference () {   Model$$1.prototype.unreference.call(this);   if ( !this.deps.length && !this.refs ) { this.teardown(); }  };   ExpressionProxy.prototype.unregister = function unregister ( dep ) {   Model$$1.prototype.unregister.call( this, dep );   if ( !this.deps.length && !this.refs ) { this.teardown(); }  };   return ExpressionProxy; }(Model));  var prototype = ExpressionProxy.prototype; var computation = Computation.prototype; prototype.get = computation.get; prototype.handleChange = computation.handleChange; prototype.joinKey = computation.joinKey; prototype.mark = computation.mark; prototype.unbind = noop;  var ReferenceExpressionChild = (function (Model$$1) {  function ReferenceExpressionChild ( parent, key ) {   Model$$1.call ( this, parent, key );  }   if ( Model$$1 ) ReferenceExpressionChild.__proto__ = Model$$1;  ReferenceExpressionChild.prototype = Object.create( Model$$1 && Model$$1.prototype );  ReferenceExpressionChild.prototype.constructor = ReferenceExpressionChild;   ReferenceExpressionChild.prototype.applyValue = function applyValue ( value ) {   if ( isEqual( value, this.value ) ) { return; }    var parent = this.parent;   var keys = [ this.key ];   while ( parent ) {    if ( parent.base ) {     var target = parent.model.joinAll( keys );     target.applyValue( value );     break;    }     keys.unshift( parent.key );     parent = parent.parent;   }  };   ReferenceExpressionChild.prototype.get = function get ( shouldCapture, opts ) {   this.value = this.retrieve();   return Model$$1.prototype.get.call( this, shouldCapture, opts );  };   ReferenceExpressionChild.prototype.joinKey = function joinKey ( key ) {   if ( key === undefined || key === ) { return this; } if ( !this.childByKey.hasOwnProperty( key ) ) {    var child = new ReferenceExpressionChild( this, key );    this.children.push( child );    this.childByKey[ key ] = child;   }    return this.childByKey[ key ];  };   ReferenceExpressionChild.prototype.retrieve = function retrieve () {   var parent = this.parent.get();   return parent && parent[ this.key ];  };   return ReferenceExpressionChild; }(Model));  var ReferenceExpressionProxy = (function (Model$$1) {  function ReferenceExpressionProxy ( fragment, template ) {   var this$1 = this;    Model$$1.call( this, null, null );   this.dirty = true;   this.root = fragment.ractive.viewmodel;   this.template = template;    this.base = resolve( fragment, template );    var intermediary = this.intermediary = {    handleChange: function () { return this$1.handleChange(); },    rebind: function ( next, previous ) {     if ( previous === this$1.base ) {      next = rebindMatch( template, next, previous );      if ( next !== this$1.base ) {       this$1.base.unregister( intermediary );       this$1.base = next;      }     } else {      var idx = this$1.members.indexOf( previous );      if ( ~idx ) {       // only direct references will rebind... expressions handle themselves       next = rebindMatch( template.m[idx].n, next, previous );       if ( next !== this$1.members[idx] ) {        this$1.members.splice( idx, 1, next );       }      }     }      if ( next !== previous ) { previous.unregister( intermediary ); }     if ( next ) { next.addShuffleTask( function () { return next.register( intermediary ); } ); }      this$1.bubble();    }   };    this.members = template.m.map( function ( template ) {    if ( typeof template === 'string' ) {     return { get: function () { return template; } };    }     var model;     if ( template.t === REFERENCE ) {     model = resolveReference( fragment, template.n );     model.register( intermediary );      return model;    }     model = new ExpressionProxy( fragment, template );    model.register( intermediary );    return model;   });    this.bubble();  }   if ( Model$$1 ) ReferenceExpressionProxy.__proto__ = Model$$1;  ReferenceExpressionProxy.prototype = Object.create( Model$$1 && Model$$1.prototype );  ReferenceExpressionProxy.prototype.constructor = ReferenceExpressionProxy;   ReferenceExpressionProxy.prototype.bubble = function bubble () {   if ( !this.base ) { return; }   if ( !this.dirty ) { this.handleChange(); }  };   ReferenceExpressionProxy.prototype.get = function get ( shouldCapture ) {   if ( this.dirty ) {    this.bubble();     var keys = this.members.map( function (m) { return escapeKey( String( m.get() ) ); } );    var model = this.base.joinAll( keys );     if ( model !== this.model ) {     if ( this.model ) {      this.model.unregister( this );      this.model.unregisterTwowayBinding( this );     }      this.model = model;     this.parent = model.parent;     this.model.register( this );     this.model.registerTwowayBinding( this );      if ( this.keypathModel ) { this.keypathModel.handleChange(); }    }     this.value = this.model.get( shouldCapture );    this.dirty = false;    this.mark();    return this.value;   } else {    return this.model ? this.model.get( shouldCapture ) : undefined;   }  };   // indirect two-way bindings  ReferenceExpressionProxy.prototype.getValue = function getValue () {   var this$1 = this;    this.value = this.model ? this.model.get() : undefined;    var i = this.bindings.length;   while ( i-- ) {    var value = this$1.bindings[i].getValue();    if ( value !== this$1.value ) { return value; }   }    // check one-way bindings   var oneway = findBoundValue( this.deps );   if ( oneway ) { return oneway.value; }    return this.value;  };   ReferenceExpressionProxy.prototype.getKeypath = function getKeypath () {   return this.model ? this.model.getKeypath() : '@undefined';  };   ReferenceExpressionProxy.prototype.handleChange = function handleChange$$1 () {   this.dirty = true;   this.mark();  };   ReferenceExpressionProxy.prototype.joinKey = function joinKey ( key ) {   if ( key === undefined || key === ) { return this; } if ( !this.childByKey.hasOwnProperty( key ) ) {    var child = new ReferenceExpressionChild( this, key );    this.children.push( child );    this.childByKey[ key ] = child;   }    return this.childByKey[ key ];  };   ReferenceExpressionProxy.prototype.mark = function mark$1 () {   if ( this.dirty ) {    this.deps.forEach( handleChange );   }    this.links.forEach( marked );   this.children.forEach( mark );  };   ReferenceExpressionProxy.prototype.retrieve = function retrieve () {   return this.value;  };   ReferenceExpressionProxy.prototype.set = function set ( value ) {   this.model.set( value );  };   ReferenceExpressionProxy.prototype.teardown = function teardown$$1 () {   var this$1 = this;    if ( this.model ) {    this.model.unregister( this );    this.model.unregisterTwowayBinding( this );   }   if ( this.members ) {    this.members.forEach( function (m) { return m && m.unregister && m.unregister( this$1 ); } );   }  };   ReferenceExpressionProxy.prototype.unreference = function unreference () {   Model$$1.prototype.unreference.call(this);   if ( !this.deps.length && !this.refs ) { this.teardown(); }  };   ReferenceExpressionProxy.prototype.unregister = function unregister ( dep ) {   Model$$1.prototype.unregister.call( this, dep );   if ( !this.deps.length && !this.refs ) { this.teardown(); }  };   return ReferenceExpressionProxy; }(Model));  ReferenceExpressionProxy.prototype.rebind = noop;  function resolve ( fragment, template ) {  if ( template.r ) {   return resolveReference( fragment, template.r );  }   else if ( template.x ) {   return new ExpressionProxy( fragment, template.x );  }   else if ( template.rx ) {   return new ReferenceExpressionProxy( fragment, template.rx );  } }  function resolveAliases( aliases, fragment ) {  var resolved = {};   for ( var i = 0; i < aliases.length; i++ ) {   resolved[ aliases[i].n ] = resolve( fragment, aliases[i].x );  }   for ( var k in resolved ) {   resolved[k].reference();  }   return resolved; }  var Alias = (function (ContainerItem$$1) {  function Alias ( options ) {   ContainerItem$$1.call( this, options );    this.fragment = null;  }   if ( ContainerItem$$1 ) Alias.__proto__ = ContainerItem$$1;  Alias.prototype = Object.create( ContainerItem$$1 && ContainerItem$$1.prototype );  Alias.prototype.constructor = Alias;   Alias.prototype.bind = function bind () {   this.fragment = new Fragment({    owner: this,    template: this.template.f   });    this.fragment.aliases = resolveAliases( this.template.z, this.parentFragment );   this.fragment.bind();  };   Alias.prototype.render = function render ( target ) {   this.rendered = true;   if ( this.fragment ) { this.fragment.render( target ); }  };   Alias.prototype.unbind = function unbind () {   var this$1 = this;    for ( var k in this$1.fragment.aliases ) {    this$1.fragment.aliases[k].unreference();   }    this.fragment.aliases = {};   if ( this.fragment ) { this.fragment.unbind(); }  };   Alias.prototype.unrender = function unrender ( shouldDestroy ) {   if ( this.rendered && this.fragment ) { this.fragment.unrender( shouldDestroy ); }   this.rendered = false;  };   Alias.prototype.update = function update () {   if ( this.dirty ) {    this.dirty = false;    this.fragment.update();   }  };   return Alias; }(ContainerItem));  var space = /\s+/;  function readStyle ( css ) {  if ( typeof css !== 'string' ) { return {}; }   return cleanCss( css, function ( css, reconstruct ) {   return css.split( ';' )    .filter( function (rule) { return !!rule.trim(); } )    .map( reconstruct )    .reduce(function ( rules, rule ) {     var i = rule.indexOf(':');     var name = rule.substr( 0, i ).trim();     rules[ name ] = rule.substr( i + 1 ).trim();     return rules;    }, {});  }); }  function readClass ( str ) {  var list = str.split( space );    // remove any empty entries  var i = list.length;  while ( i-- ) {   if ( !list[i] ) { list.splice( i, 1 ); }  }   return list; }  var hyphenateCamel = function ( camelCaseStr ) {  return camelCaseStr.replace( /([A-Z])/g, function ( match, $1 ) {   return '-' + $1.toLowerCase();  }); };  var textTypes = [ undefined, 'text', 'search', 'url', 'email', 'hidden', 'password', 'search', 'reset', 'submit' ];  function getUpdateDelegate ( attribute ) {  var element = attribute.element;  var name = attribute.name;   if ( name === 'value' ) {   if ( attribute.interpolator ) { attribute.interpolator.bound = true; }    // special case - selects   if ( element.name === 'select' && name === 'value' ) {    return element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;   }    if ( element.name === 'textarea' ) { return updateStringValue; }    // special case - contenteditable   if ( element.getAttribute( 'contenteditable' ) != null ) { return updateContentEditableValue; }    // special case - <input> if ( element.name === 'input' ) {    var type = element.getAttribute( 'type' );     // type='file' value=' Template:FileList '> if ( type === 'file' ) { return noop; } // read-only     // type='radio' name=' Template:Twoway '    if ( type === 'radio' && element.binding && element.binding.attribute.name === 'name' ) { return updateRadioValue; }     if ( ~textTypes.indexOf( type ) ) { return updateStringValue; }   }    return updateValue;  }   var node = element.node;   // special case - <input type='radio' name=' Template:Twoway ' value='foo'> if ( attribute.isTwoway && name === 'name' ) {   if ( node.type === 'radio' ) { return updateRadioName; }   if ( node.type === 'checkbox' ) { return updateCheckboxName; }  }   if ( name === 'style' ) { return updateStyleAttribute; }   if ( name.indexOf( 'style-' ) === 0 ) { return updateInlineStyle; }   // special case - class names. IE fucks things up, again  if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === html ) ) { return updateClassName; }   if ( name.indexOf( 'class-' ) === 0 ) { return updateInlineClass; }   if ( attribute.isBoolean ) {   var type$1 = element.getAttribute( 'type' );   if ( attribute.interpolator && name === 'checked' && ( type$1 === 'checkbox' || type$1 === 'radio' ) ) { attribute.interpolator.bound = true; }   return updateBoolean;  }   if ( attribute.namespace && attribute.namespace !== attribute.node.namespaceURI ) { return updateNamespacedAttribute; }   return updateAttribute; }  function updateMultipleSelectValue ( reset ) {  var value = this.getValue();   if ( !Array.isArray( value ) ) { value = [ value ]; }   var options = this.node.options;  var i = options.length;   if ( reset ) {   while ( i-- ) { options[i].selected = false; }  } else {   while ( i-- ) {    var option = options[i];    var optionValue = option._ractive ?     option._ractive.value :     option.value; // options inserted via a triple don't have _ractive     option.selected = arrayContains( value, optionValue );   }  } }  function updateSelectValue ( reset ) {  var value = this.getValue();   if ( !this.locked ) { // TODO is locked still a thing?   this.node._ractive.value = value;    var options = this.node.options;   var i = options.length;   var wasSelected = false;    if ( reset ) {    while ( i-- ) { options[i].selected = false; }   } else {    while ( i-- ) {     var option = options[i];     var optionValue = option._ractive ?      option._ractive.value :      option.value; // options inserted via a triple don't have _ractive     if ( option.disabled && option.selected ) { wasSelected = true; }      if ( optionValue == value ) { // double equals as we may be comparing numbers with strings      option.selected = true;      return;     }    }   }    if ( !wasSelected ) { this.node.selectedIndex = -1; }  } }   function updateContentEditableValue ( reset ) {  var value = this.getValue();   if ( !this.locked ) {   if ( reset ) { this.node.innerHTML = ; } else { this.node.innerHTML = value === undefined ?  : value; } } }  function updateRadioValue ( reset ) {  var node = this.node;  var wasChecked = node.checked;   var value = this.getValue();   if ( reset ) { return node.checked = false; }   //node.value = this.element.getAttribute( 'value' );  node.value = this.node._ractive.value = value;  node.checked = this.element.compare( value, this.element.getAttribute( 'name' ) );   // This is a special case - if the input was checked, and the value  // changed so that it's no longer checked, the twoway binding is  // most likely out of date. To fix it we have to jump through some  // hoops... this is a little kludgy but it works  if ( wasChecked && !node.checked && this.element.binding && this.element.binding.rendered ) {   this.element.binding.group.model.set( this.element.binding.group.getValue() );  } }  function updateValue ( reset ) {  if ( !this.locked ) {   if ( reset ) {    this.node.removeAttribute( 'value' );    this.node.value = this.node._ractive.value = null;   } else {    var value = this.getValue();     this.node.value = this.node._ractive.value = value;    this.node.setAttribute( 'value', safeToStringValue( value ) );   }  } }  function updateStringValue ( reset ) {  if ( !this.locked ) {   if ( reset ) {    this.node._ractive.value = ; this.node.removeAttribute( 'value' );   } else {    var value = this.getValue();     this.node._ractive.value = value;     this.node.value = safeToStringValue( value );    this.node.setAttribute( 'value', safeToStringValue( value ) );   }  } }  function updateRadioName ( reset ) {  if ( reset ) { this.node.checked = false; }  else { this.node.checked = this.element.compare( this.getValue(), this.element.binding.getValue() ); } }  function updateCheckboxName ( reset ) {  var ref = this;  var element = ref.element;  var node = ref.node;  var binding = element.binding;   var value = this.getValue();  var valueAttribute = element.getAttribute( 'value' );   if ( reset ) {   // TODO: WAT?  }   if ( !Array.isArray( value ) ) {   binding.isChecked = node.checked = element.compare( value, valueAttribute );  } else {   var i = value.length;   while ( i-- ) {    if ( element.compare ( valueAttribute, value[i] ) ) {     binding.isChecked = node.checked = true;     return;    }   }   binding.isChecked = node.checked = false;  } }  function updateStyleAttribute ( reset ) {  var props = reset ? {} : readStyle( this.getValue() || ); var style = this.node.style;  var keys = Object.keys( props );  var prev = this.previous || [];   var i = 0;  while ( i < keys.length ) {   if ( keys[i] in style ) {    var safe = props[ keys[i] ].replace( '!important', ); style.setProperty( keys[i], safe, safe.length !== props[ keys[i] ].length ? 'important' : ); }   i++;  }   // remove now-missing attrs  i = prev.length;  while ( i-- ) {   if ( !~keys.indexOf( prev[i] ) && prev[i] in style ) { style.setProperty( prev[i], , ); }  }   this.previous = keys; }  function updateInlineStyle ( reset ) {  if ( !this.style ) {   this.style = hyphenateCamel( this.name.substr( 6 ) );  }   var value = reset ?  : safeToStringValue( this.getValue() ); var safe = value.replace( '!important', ); this.node.style.setProperty( this.style, safe, safe.length !== value.length ? 'important' : ); }  function updateClassName ( reset ) {  var value = reset ? [] : readClass( safeToStringValue( this.getValue() ) );   // watch out for werdo svg elements  var cls = this.node.className;  cls = cls.baseVal !== undefined ? cls.baseVal : cls;   var attr = readClass( cls );  var prev = this.previous || attr.slice( 0 );   var className = value.concat( attr.filter( function (c) { return !~prev.indexOf( c ); } ) ).join( ' ' );   if ( className !== cls ) {   if ( typeof this.node.className !== 'string' ) { this.node.className.baseVal = className;   } else {    this.node.className = className;   }  }   this.previous = value; }  function updateInlineClass ( reset ) {  var name = this.name.substr( 6 );   // watch out for werdo svg elements  var cls = this.node.className;  cls = cls.baseVal !== undefined ? cls.baseVal : cls;   var attr = readClass( cls );  var value = reset ? false : this.getValue();   if ( !this.inlineClass ) { this.inlineClass = name; }   if ( value && !~attr.indexOf( name ) ) { attr.push( name ); }  else if ( !value && ~attr.indexOf( name ) ) { attr.splice( attr.indexOf( name ), 1 ); }   if ( typeof this.node.className !== 'string' ) {   this.node.className.baseVal = attr.join( ' ' );  } else {   this.node.className = attr.join( ' ' );  } }  function updateBoolean ( reset ) {  // with two-way binding, only update if the change wasn't initiated by the user  // otherwise the cursor will often be sent to the wrong place  if ( !this.locked ) {   if ( reset ) {    if ( this.useProperty ) { this.node[ this.propertyName ] = false; }    this.node.removeAttribute( this.propertyName );   } else {    if ( this.useProperty ) {     this.node[ this.propertyName ] = this.getValue();    } else {     if ( this.getValue() ) {      this.node.setAttribute( this.propertyName, ); } else {      this.node.removeAttribute( this.propertyName );     }    }   }  } }  function updateAttribute ( reset ) {  if ( reset ) { this.node.removeAttribute( this.name ); }  else { this.node.setAttribute( this.name, safeToStringValue( this.getString() ) ); } }  function updateNamespacedAttribute ( reset ) {  if ( reset ) { this.node.removeAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ) ); }  else { this.node.setAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ), safeToStringValue( this.getString() ) ); } }  var propertyNames = {  'accept-charset': 'acceptCharset',  accesskey: 'accessKey',  bgcolor: 'bgColor', class: 'className',  codebase: 'codeBase',  colspan: 'colSpan',  contenteditable: 'contentEditable',  datetime: 'dateTime',  dirname: 'dirName',  for: 'htmlFor',  'http-equiv': 'httpEquiv',  ismap: 'isMap',  maxlength: 'maxLength',  novalidate: 'noValidate',  pubdate: 'pubDate',  readonly: 'readOnly',  rowspan: 'rowSpan',  tabindex: 'tabIndex',  usemap: 'useMap' };  var div$1 = doc ? createElement( 'div' ) : null;  var attributes = false; function inAttributes() { return attributes; } function doInAttributes( fn ) {  attributes = true;  fn();  attributes = false; }  var ConditionalAttribute = (function (Item$$1) {  function ConditionalAttribute ( options ) {   Item$$1.call( this, options );    this.attributes = [];    this.owner = options.owner;    this.fragment = new Fragment({    ractive: this.ractive,    owner: this,    template: this.template   });   // this fragment can't participate in node-y things   this.fragment.findNextNode = noop;    this.dirty = false;  }   if ( Item$$1 ) ConditionalAttribute.__proto__ = Item$$1;  ConditionalAttribute.prototype = Object.create( Item$$1 && Item$$1.prototype );  ConditionalAttribute.prototype.constructor = ConditionalAttribute;   ConditionalAttribute.prototype.bind = function bind () {   this.fragment.bind();  };   ConditionalAttribute.prototype.bubble = function bubble () {   if ( !this.dirty ) {    this.dirty = true;    this.owner.bubble();   }  };   ConditionalAttribute.prototype.render = function render () {   this.node = this.owner.node;   if ( this.node ) {    this.isSvg = this.node.namespaceURI === svg$1;   }    attributes = true;   if ( !this.rendered ) { this.fragment.render(); }    this.rendered = true;   this.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js   this.update();   attributes = false;  };   ConditionalAttribute.prototype.toString = function toString () {   return this.fragment.toString();  };   ConditionalAttribute.prototype.unbind = function unbind () {   this.fragment.unbind();  };   ConditionalAttribute.prototype.unrender = function unrender () {   this.rendered = false;   this.fragment.unrender();  };   ConditionalAttribute.prototype.update = function update () {   var this$1 = this;    var str;   var attrs;    if ( this.dirty ) {    this.dirty = false;     var current = attributes;    attributes = true;    this.fragment.update();    attributes = current || false;     if ( this.rendered && this.node ) {     str = this.fragment.toString();     attrs = parseAttributes( str, this.isSvg );      // any attributes that previously existed but no longer do     // must be removed     this.attributes.filter( function (a) { return notIn( attrs, a ); } ).forEach( function (a) {      this$1.node.removeAttribute( a.name );     });      attrs.forEach( function (a) {      this$1.node.setAttribute( a.name, a.value );     });      this.attributes = attrs;    }   }  };   return ConditionalAttribute; }(Item));  function parseAttributes ( str, isSvg ) {  var tagName = isSvg ? 'svg' : 'div';  return str   ? (div$1.innerHTML = "<" + tagName + " " + str + "></" + tagName + ">") && toArray(div$1.childNodes[0].attributes)   : []; }  function notIn ( haystack, needle ) {  var i = haystack.length;   while ( i-- ) {   if ( haystack[i].name === needle.name ) {    return false;   }  }   return true; }  function lookupNamespace ( node, prefix ) {  var qualified = "xmlns:" + prefix;   while ( node ) {   if ( node.hasAttribute && node.hasAttribute( qualified ) ) { return node.getAttribute( qualified ); }   node = node.parentNode;  }   return namespaces[ prefix ]; }  var attribute = false; function inAttribute () { return attribute; }  var Attribute = (function (Item$$1) {  function Attribute ( options ) {   Item$$1.call( this, options );    this.name = options.template.n;   this.namespace = null;    this.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );   this.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );   this.parentFragment = options.parentFragment; // shared   this.ractive = this.parentFragment.ractive;    this.rendered = false;   this.updateDelegate = null;   this.fragment = null;    this.element.attributeByName[ this.name ] = this;    if ( !Array.isArray( options.template.f ) ) {    this.value = options.template.f;    if ( this.value === 0 ) {     this.value = ; } else if ( this.value === undefined ) {     this.value = true;    }   } else {    this.fragment = new Fragment({     owner: this,     template: options.template.f    });   }    this.interpolator = this.fragment && this.fragment.items.length === 1 && this.fragment.items[0].type === INTERPOLATOR && this.fragment.items[0];    if ( this.interpolator ) { this.interpolator.owner = this; }  }   if ( Item$$1 ) Attribute.__proto__ = Item$$1;  Attribute.prototype = Object.create( Item$$1 && Item$$1.prototype );  Attribute.prototype.constructor = Attribute;   Attribute.prototype.bind = function bind () {   if ( this.fragment ) {    this.fragment.bind();   }  };   Attribute.prototype.bubble = function bubble () {   if ( !this.dirty ) {    this.parentFragment.bubble();    this.element.bubble();    this.dirty = true;   }  };   Attribute.prototype.getString = function getString () {   attribute = true;   var value = this.fragment ?    this.fragment.toString() :    this.value != null ? + this.value : ;   attribute = false;   return value;  };   // TODO could getValue ever be called for a static attribute,  // or can we assume that this.fragment exists?  Attribute.prototype.getValue = function getValue () {   attribute = true;   var value = this.fragment ? this.fragment.valueOf() : booleanAttributes.test( this.name ) ? true : this.value;   attribute = false;   return value;  };   Attribute.prototype.render = function render () {   var node = this.element.node;   this.node = node;    // should we use direct property access, or setAttribute?   if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {    this.propertyName = propertyNames[ this.name ] || this.name;     if ( node[ this.propertyName ] !== undefined ) {     this.useProperty = true;    }     // is attribute a boolean attribute or 'value'? If so we're better off doing e.g.    // node.selected = true rather than node.setAttribute( 'selected', ) if ( booleanAttributes.test( this.name ) || this.isTwoway ) {     this.isBoolean = true;    }     if ( this.propertyName === 'value' ) {     node._ractive.value = this.value;    }   }    if ( node.namespaceURI ) {    var index = this.name.indexOf( ':' );    if ( index !== -1 ) {     this.namespace = lookupNamespace( node, this.name.slice( 0, index ) );    } else {     this.namespace = node.namespaceURI;    }   }    this.rendered = true;   this.updateDelegate = getUpdateDelegate( this );   this.updateDelegate();  };   Attribute.prototype.toString = function toString () {   if ( inAttributes() ) { return ; } attribute = true;    var value = this.getValue();    // Special case - select and textarea values (should not be stringified)   if ( this.name === 'value' && ( this.element.getAttribute( 'contenteditable' ) !== undefined || ( this.element.name === 'select' || this.element.name === 'textarea' ) ) ) {    return;   }    // Special case – bound radio `name` attributes   if ( this.name === 'name' && this.element.name === 'input' && this.interpolator && this.element.getAttribute( 'type' ) === 'radio' ) {    return ("name=\" Template:" + (this.interpolator.model.getKeypath()) + " \"");   }    // Special case - style and class attributes and directives   if ( this.owner === this.element && ( this.name === 'style' || this.name === 'class' || this.style || this.inlineClass ) ) {    return;   }    if ( !this.rendered && this.owner === this.element && ( !this.name.indexOf( 'style-' ) || !this.name.indexOf( 'class-' ) ) ) {    if ( !this.name.indexOf( 'style-' ) ) {     this.style = hyphenateCamel( this.name.substr( 6 ) );    } else {     this.inlineClass = this.name.substr( 6 );    }     return;   }    if ( booleanAttributes.test( this.name ) ) { return value ? this.name : ; } if ( value == null ) { return ; } var str = safeAttributeString( this.getString() );   attribute = false;    return str ?    ((this.name) + "=\"" + str + "\"") :    this.name;  };   Attribute.prototype.unbind = function unbind () {   if ( this.fragment ) { this.fragment.unbind(); }  };   Attribute.prototype.unrender = function unrender () {   this.updateDelegate( true );    this.rendered = false;  };   Attribute.prototype.update = function update () {   if ( this.dirty ) {    this.dirty = false;    if ( this.fragment ) { this.fragment.update(); }    if ( this.rendered ) { this.updateDelegate(); }    if ( this.isTwoway && !this.locked ) {     this.interpolator.twowayBinding.lastVal( true, this.interpolator.model.get() );    }   }  };   return Attribute; }(Item));  var BindingFlag = (function (Item$$1) {  function BindingFlag ( options ) {   Item$$1.call( this, options );    this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );   this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );   this.flag = options.template.v === 'l' ? 'lazy' : 'twoway';    if ( this.element.type === ELEMENT ) {    if ( Array.isArray( options.template.f ) ) {     this.fragment = new Fragment({      owner: this,      template: options.template.f     });    }     this.interpolator = this.fragment && this.fragment.items.length === 1 && this.fragment.items[0].type === INTERPOLATOR && this.fragment.items[0];   }  }   if ( Item$$1 ) BindingFlag.__proto__ = Item$$1;  BindingFlag.prototype = Object.create( Item$$1 && Item$$1.prototype );  BindingFlag.prototype.constructor = BindingFlag;   BindingFlag.prototype.bind = function bind () {   if ( this.fragment ) { this.fragment.bind(); }   set$1( this, this.getValue(), true );  };   BindingFlag.prototype.bubble = function bubble () {   if ( !this.dirty ) {    this.element.bubble();    this.dirty = true;   }  };   BindingFlag.prototype.getValue = function getValue () {   if ( this.fragment ) { return this.fragment.valueOf(); }   else if ( 'value' in this ) { return this.value; }   else if ( 'f' in this.template ) { return this.template.f; }   else { return true; }  };   BindingFlag.prototype.render = function render () {   set$1( this, this.getValue(), true );  };   BindingFlag.prototype.toString = function toString () { return ; }; BindingFlag.prototype.unbind = function unbind () {   if ( this.fragment ) { this.fragment.unbind(); }    delete this.element[ this.flag ];  };   BindingFlag.prototype.unrender = function unrender () {   if ( this.element.rendered ) { this.element.recreateTwowayBinding(); }  };   BindingFlag.prototype.update = function update () {   if ( this.dirty ) {    if ( this.fragment ) { this.fragment.update(); }    set$1( this, this.getValue(), true );   }  };   return BindingFlag; }(Item));  function set$1 ( flag, value, update ) {  if ( value === 0 ) {   flag.value = true;  } else if ( value === 'true' ) {   flag.value = true;  } else if ( value === 'false' || value === '0' ) {   flag.value = false;  } else {   flag.value = value;  }   var current = flag.element[ flag.flag ];  flag.element[ flag.flag ] = flag.value;  if ( update && !flag.element.attributes.binding && current !== flag.value ) {   flag.element.recreateTwowayBinding();  }   return flag.value; }  var RactiveModel = (function (Model$$1) {  function RactiveModel ( ractive ) {   Model$$1.call( this, null, ); this.value = ractive;   this.isRoot = true;   this.root = this;   this.adaptors = [];   this.ractive = ractive;  }   if ( Model$$1 ) RactiveModel.__proto__ = Model$$1;  RactiveModel.prototype = Object.create( Model$$1 && Model$$1.prototype );  RactiveModel.prototype.constructor = RactiveModel;   RactiveModel.prototype.joinKey = function joinKey ( key ) {   var model = Model$$1.prototype.joinKey.call( this, key );    if ( ( key === 'root' || key === 'parent' ) && !model.isLink ) { return initLink( model, key ); }   else if ( key === 'data' ) { return this.ractive.viewmodel; }    return model;  };   RactiveModel.prototype.getKeypath = function getKeypath () {   return '@this';  };   RactiveModel.prototype.retrieve = function retrieve () {   return this.ractive;  };   return RactiveModel; }(Model));  function initLink ( model, key ) {  model.applyValue = function ( value ) {   this.parent.value[ key ] = value;   if ( value && value.viewmodel ) {    this.link( value.viewmodel.getRactiveModel(), key );    this._link.markedAll();   } else {    this.link( Object.create( Missing ), key );    this._link.markedAll();   }  };   model.applyValue( model.parent.ractive[ key ], key );  model._link.set = function (v) { return model.applyValue( v ); };  model._link.applyValue = function (v) { return model.applyValue( v ); };  return model._link; }  var hasProp$1 = Object.prototype.hasOwnProperty;  var RootModel = (function (Model$$1) {  function RootModel ( options ) {   Model$$1.call( this, null, null );    this.isRoot = true;   this.root = this;   this.ractive = options.ractive; // TODO sever this link    this.value = options.data;   this.adaptors = options.adapt;   this.adapt();    this.computationContext = options.ractive;   this.computations = {};  }   if ( Model$$1 ) RootModel.__proto__ = Model$$1;  RootModel.prototype = Object.create( Model$$1 && Model$$1.prototype );  RootModel.prototype.constructor = RootModel;   RootModel.prototype.attached = function attached ( fragment ) {   attachImplicits( this, fragment );  };   RootModel.prototype.compute = function compute ( key, signature ) {   var computation = new Computation( this, signature, key );   this.computations[ escapeKey( key ) ] = computation;    return computation;  };   RootModel.prototype.createLink = function createLink ( keypath, target, targetPath, options ) {   var this$1 = this;    var keys = splitKeypath( keypath );    var model = this;   while ( keys.length ) {    var key = keys.shift();    model = this$1.childByKey[ key ] || this$1.joinKey( key );   }    return model.link( target, targetPath, options );  };   RootModel.prototype.detached = function detached () {   detachImplicits( this );  };   RootModel.prototype.get = function get ( shouldCapture, options ) {   var this$1 = this;    if ( shouldCapture ) { capture( this ); }    if ( !options || options.virtual !== false ) {    var result = this.getVirtual();    var keys = Object.keys( this.computations );    var i = keys.length;    while ( i-- ) {     result[ keys[i] ] = this$1.computations[ keys[i] ].get();    }     return result;   } else {    return this.value;   }  };   RootModel.prototype.getKeypath = function getKeypath () {   return ; };   RootModel.prototype.getRactiveModel = function getRactiveModel () {   return this.ractiveModel || ( this.ractiveModel = new RactiveModel( this.ractive ) );  };   RootModel.prototype.getValueChildren = function getValueChildren () {   var this$1 = this;    var children = Model$$1.prototype.getValueChildren.call( this, this.value );    this.children.forEach( function (child) {    if ( child._link ) {     var idx = children.indexOf( child );     if ( ~idx ) { children.splice( idx, 1, child._link ); }     else { children.push( child._link ); }    }   });    for ( var k in this$1.computations ) {    children.push( this$1.computations[k] );   }    return children;  };   RootModel.prototype.has = function has ( key ) {   var value = this.value;   var unescapedKey = unescapeKey( key );    if ( unescapedKey === '@this' || unescapedKey === '@global' || unescapedKey === '@shared' ) { return true; }   if ( unescapedKey[0] === '~' && unescapedKey[1] === '/' ) { unescapedKey = unescapedKey.slice( 2 ); }   if ( hasProp$1.call( value, unescapedKey ) ) { return true; }    // mappings/links and computations   if ( key in this.computations || this.childByKey[unescapedKey] && this.childByKey[unescapedKey]._link ) { return true; }    // We climb up the constructor chain to find if one of them contains the unescapedKey   var constructor = value.constructor;   while ( constructor !== Function && constructor !== Array && constructor !== Object ) {    if ( hasProp$1.call( constructor.prototype, unescapedKey ) ) { return true; }    constructor = constructor.constructor;   }    return false;  };   RootModel.prototype.joinKey = function joinKey ( key, opts ) {   if ( key[0] === '@' ) {    if ( key === '@this' || key === '@' ) { return this.getRactiveModel(); }    if ( key === '@global' ) { return GlobalModel; }    if ( key === '@shared' ) { return SharedModel$1; }    return;   }    if ( key[0] === '~' && key[1] === '/' ) { key = key.slice( 2 ); }    return this.computations.hasOwnProperty( key ) ? this.computations[ key ] :          Model$$1.prototype.joinKey.call( this, key, opts );  };   RootModel.prototype.set = function set ( value ) {   // TODO wrapping root node is a baaaad idea. We should prevent this   var wrapper = this.wrapper;   if ( wrapper ) {    var shouldTeardown = !wrapper.reset || wrapper.reset( value ) === false;     if ( shouldTeardown ) {     wrapper.teardown();     this.wrapper = null;     this.value = value;     this.adapt();    }   } else {    this.value = value;    this.adapt();   }    this.deps.forEach( handleChange );   this.children.forEach( mark );  };   RootModel.prototype.retrieve = function retrieve () {   return this.wrapper ? this.wrapper.get() : this.value; };   RootModel.prototype.teardown = function teardown$$1 () {   var this$1 = this;    Model$$1.prototype.teardown.call(this);   for ( var k in this$1.computations ) {    this$1.computations[ k ].teardown();   }  };   return RootModel; }(Model));  RootModel.prototype.update = noop;  function attachImplicits ( model, fragment ) {  if ( model._link && model._link.implicit && model._link.isDetached() ) {   model.attach( fragment );  }   // look for virtual children to relink and cascade  for ( var k in model.childByKey ) {   if ( k in model.value ) {    attachImplicits( model.childByKey[k], fragment );   } else if ( !model.childByKey[k]._link || model.childByKey[k]._link.isDetached() ) {    var mdl = resolveReference( fragment, k );    if ( mdl ) {     model.childByKey[k].link( mdl, k, { implicit: true } );    }   }  } }  function detachImplicits ( model ) {  if ( model._link && model._link.implicit ) {   model.unlink();  }   for ( var k in model.childByKey ) {   detachImplicits( model.childByKey[k] );  } }  function getComputationSignature ( ractive, key, signature ) {  var getter;  var setter;   // useful for debugging  var getterString;  var getterUseStack;  var setterString;   if ( typeof signature === 'function' ) {   getter = bind$1( signature, ractive );   getterString = signature.toString();   getterUseStack = true;  }   if ( typeof signature === 'string' ) {   getter = createFunctionFromString( signature, ractive );   getterString = signature;  }   if ( typeof signature === 'object' ) {   if ( typeof signature.get === 'string' ) {    getter = createFunctionFromString( signature.get, ractive );    getterString = signature.get;   } else if ( typeof signature.get === 'function' ) {    getter = bind$1( signature.get, ractive );    getterString = signature.get.toString();    getterUseStack = true;   } else {    fatal( '`%s` computation must have a `get()` method', key );   }    if ( typeof signature.set === 'function' ) {    setter = bind$1( signature.set, ractive );    setterString = signature.set.toString();   }  }   return {   getter: getter,   setter: setter,   getterString: getterString,   setterString: setterString,   getterUseStack: getterUseStack  }; }  var constructHook = new Hook( 'construct' );  var registryNames$1 = [  'adaptors',  'components',  'decorators',  'easing',  'events',  'interpolators',  'partials',  'transitions' ];  var uid = 0;  function construct ( ractive, options ) {  if ( Ractive.DEBUG ) { welcome(); }   initialiseProperties( ractive );  handleAttributes( ractive );   // if there's not a delegation setting, inherit from parent if it's not default  if ( !options.hasOwnProperty( 'delegate' ) && ractive.parent && ractive.parent.delegate !== ractive.delegate ) {   ractive.delegate = false;  }   // TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it  constructHook.fire( ractive, options );   // Add registries  var i = registryNames$1.length;  while ( i-- ) {   var name = registryNames$1[ i ];   ractive[ name ] = Object.assign( Object.create( ractive.constructor[ name ] || null ), options[ name ] );  }   if ( ractive._attributePartial ) {   ractive.partials['extra-attributes'] = ractive._attributePartial;   delete ractive._attributePartial;  }   // Create a viewmodel  var viewmodel = new RootModel({   adapt: getAdaptors( ractive, ractive.adapt, options ),   data: dataConfigurator.init( ractive.constructor, ractive, options ),   ractive: ractive  });   ractive.viewmodel = viewmodel;   // Add computed properties  var computed = Object.assign( Object.create( ractive.constructor.prototype.computed ), options.computed );   for ( var key in computed ) {   if ( key === '__proto__' ) { continue; }   var signature = getComputationSignature( ractive, key, computed[ key ] );   viewmodel.compute( key, signature );  } }  function getAdaptors ( ractive, protoAdapt, options ) {  protoAdapt = protoAdapt.map( lookup );  var adapt = ensureArray( options.adapt ).map( lookup );   var srcs = [ protoAdapt, adapt ];  if ( ractive.parent && !ractive.isolated ) {   srcs.push( ractive.parent.viewmodel.adaptors );  }   return combine.apply( null, srcs );   function lookup ( adaptor ) {   if ( typeof adaptor === 'string' ) {    adaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );     if ( !adaptor ) {     fatal( missingPlugin( adaptor, 'adaptor' ) );    }   }    return adaptor;  } }  function initialiseProperties ( ractive ) {  // Generate a unique identifier, for places where you'd use a weak map if it  // existed  ractive._guid = 'r-' + uid++;   // events  ractive._subs = Object.create( null );  ractive._nsSubs = 0;   // storage for item configuration from instantiation to reset,  // like dynamic functions or original values  ractive._config = {};   // events  ractive.event = null;  ractive._eventQueue = [];   // observers  ractive._observers = [];   // external children  ractive._children = [];  ractive._children.byName = {};  ractive.children = ractive._children;   if ( !ractive.component ) {   ractive.root = ractive;   ractive.parent = ractive.container = null; // TODO container still applicable?  } }  function handleAttributes ( ractive ) {  var component = ractive.component;  var attributes = ractive.constructor.attributes;   if ( attributes && component ) {   var tpl = component.template;   var attrs = tpl.m ? tpl.m.slice() : [];    // grab all of the passed attribute names   var props = attrs.filter( function (a) { return a.t === ATTRIBUTE; } ).map( function (a) { return a.n; } );    // warn about missing requireds   attributes.required.forEach( function (p) {    if ( !~props.indexOf( p ) ) {     warnIfDebug( ("Component '" + (component.name) + "' requires attribute '" + p + "' to be provided") );    }   });    // set up a partial containing non-property attributes   var all = attributes.optional.concat( attributes.required );   var partial = [];   var i = attrs.length;   while ( i-- ) {    var a = attrs[i];    if ( a.t === ATTRIBUTE && !~all.indexOf( a.n ) ) {     if ( attributes.mapAll ) {      // map the attribute if requested and make the extra attribute in the partial refer to the mapping      partial.unshift({ t: ATTRIBUTE, n: a.n, f: [{ t: INTERPOLATOR, r: ("~/" + (a.n)) }] });     } else {      // transfer the attribute to the extra attributes partal      partial.unshift( attrs.splice( i, 1 )[0] );     }    }   }    if ( partial.length ) { component.template = { t: tpl.t, e: tpl.e, f: tpl.f, m: attrs, p: tpl.p }; }   ractive._attributePartial = partial;  } }  var teardownHook = new Hook( 'teardown' ); var destructHook = new Hook( 'destruct' );  // Teardown. This goes through the root fragment and all its children, removing observers // and generally cleaning up after itself  function Ractive$teardown () {  var this$1 = this;   if ( this.torndown ) {   warnIfDebug( 'ractive.teardown() was called on a Ractive instance that was already torn down' );   return Promise.resolve();  }   this.shouldDestroy = true;  return teardown$1( this, function () { return this$1.fragment.rendered ? this$1.unrender() : Promise.resolve(); } ); }  function teardown$1 ( instance, getPromise ) {  instance.torndown = true;  instance.viewmodel.teardown();  instance.fragment.unbind();  instance._observers.slice().forEach( cancel );   if ( instance.el && instance.el.__ractive_instances__ ) {   removeFromArray( instance.el.__ractive_instances__, instance );  }   var promise = getPromise();   teardownHook.fire( instance );  promise.then( function () { return destructHook.fire( instance ); } );   return promise; }  var Component = (function (Item$$1) {  function Component ( options, ComponentConstructor ) {   var this$1 = this;    Item$$1.call( this, options );   this.isAnchor = this.template.t === ANCHOR;   this.type = this.isAnchor ? ANCHOR : COMPONENT; // override ELEMENT from super    var partials = options.template.p || {};   if ( !( 'content' in partials ) ) { partials.content = options.template.f || []; }   this._partials = partials; // TEMP    if ( this.isAnchor ) { this.name = options.template.n;     this.addChild = addChild;    this.removeChild = removeChild;   } else {    var instance = Object.create( ComponentConstructor.prototype );     this.instance = instance;    this.name = options.template.e;     if ( instance.el ) {     warnIfDebug( ("The <" + (this.name) + "> component has a default 'el' property; it has been disregarded") );    }     // find container    var fragment = options.parentFragment;    var container;    while ( fragment ) {     if ( fragment.owner.type === YIELDER ) {      container = fragment.owner.container;      break;     }      fragment = fragment.parent;    }     // add component-instance-specific properties    instance.parent = this.parentFragment.ractive;    instance.container = container || null;    instance.root = instance.parent.root;    instance.component = this;     construct( this.instance, { partials: partials });     // for hackability, this could be an open option    // for any ractive instance, but for now, just    // for components and just for ractive...    instance._inlinePartials = partials;   }    this.attributeByName = {};    this.events = [];   this.attributes = [];   var leftovers = [];   ( this.template.m || [] ).forEach( function (template) {    switch ( template.t ) {     case ATTRIBUTE:     case EVENT:      this$1.attributes.push( createItem({       owner: this$1,       parentFragment: this$1.parentFragment,       template: template      }) );      break;      case TRANSITION:     case BINDING_FLAG:     case DECORATOR:      break;      default:      leftovers.push( template );      break;    }   });    if ( leftovers.length ) {    this.attributes.push( new ConditionalAttribute({     owner: this,     parentFragment: this.parentFragment,     template: leftovers    }) );   }    this.eventHandlers = [];  }   if ( Item$$1 ) Component.__proto__ = Item$$1;  Component.prototype = Object.create( Item$$1 && Item$$1.prototype );  Component.prototype.constructor = Component;   Component.prototype.bind = function bind$1 () {   if ( !this.isAnchor ) {    this.attributes.forEach( bind );     initialise( this.instance, {     partials: this._partials    }, {     cssIds: this.parentFragment.cssIds    });     this.eventHandlers.forEach( bind );     this.bound = true;   }  };   Component.prototype.bubble = function bubble () {   if ( !this.dirty ) {    this.dirty = true;    this.parentFragment.bubble();   }  };   Component.prototype.destroyed = function destroyed$$1 () {   if ( !this.isAnchor && this.instance.fragment ) { this.instance.fragment.destroyed(); }  };   Component.prototype.detach = function detach () {   if ( this.isAnchor ) {    if ( this.instance ) { return this.instance.fragment.detach(); }    return createDocumentFragment();   }    return this.instance.fragment.detach();  };   Component.prototype.find = function find ( selector, options ) {   if ( this.instance ) { return this.instance.fragment.find( selector, options ); }  };   Component.prototype.findAll = function findAll ( selector, options ) {   if ( this.instance ) { this.instance.fragment.findAll( selector, options ); }  };   Component.prototype.findComponent = function findComponent ( name, options ) {   if ( !name || this.name === name ) { return this.instance; }    if ( this.instance.fragment ) {    return this.instance.fragment.findComponent( name, options );   }  };   Component.prototype.findAllComponents = function findAllComponents ( name, options ) {   var result = options.result;    if ( this.instance && ( !name || this.name === name ) ) {    result.push( this.instance );   }    if ( this.instance ) { this.instance.findAllComponents( name, options ); }  };   Component.prototype.firstNode = function firstNode ( skipParent ) {   if ( this.instance ) { return this.instance.fragment.firstNode( skipParent ); }  };   Component.prototype.getContext = function getContext$$1 () {   var assigns = [], len = arguments.length;   while ( len-- ) assigns[ len ] = arguments[ len ];    assigns.unshift( this );   return getRactiveContext.apply( null, assigns );  };   Component.prototype.render = function render$1$$1 ( target, occupants ) {   if ( this.isAnchor ) {    this.rendered = true;    this.target = target;     if ( !checking.length ) {     checking.push( this.ractive );     if ( occupants ) {      this.occupants = occupants;      checkAnchors();      this.occupants = null;     } else {      runloop.scheduleTask( checkAnchors, true );     }    }   } else {    render$1( this.instance, target, null, occupants );     this.attributes.forEach( render );    this.eventHandlers.forEach( render );     this.rendered = true;   }  };   Component.prototype.toString = function toString$$1 () {   if ( this.instance ) { return this.instance.toHTML(); }  };   Component.prototype.unbind = function unbind$1 () {   if ( !this.isAnchor ) {    this.bound = false;     this.attributes.forEach( unbind );     teardown$1( this.instance, function () { return runloop.promise(); } );   }  };   Component.prototype.unrender = function unrender$1 ( shouldDestroy ) {   this.shouldDestroy = shouldDestroy;    if ( this.isAnchor ) {    if ( this.item ) { unrenderItem( this, this.item ); }    this.target = null;    if ( !checking.length ) {     checking.push( this.ractive );     runloop.scheduleTask( checkAnchors, true );    }   } else {    this.instance.unrender();    this.instance.el = this.instance.target = null;    this.attributes.forEach( unrender );    this.eventHandlers.forEach( unrender );   }    this.rendered = false;  };   Component.prototype.update = function update$1 () {   this.dirty = false;   if ( this.instance ) {    this.instance.fragment.update();    this.attributes.forEach( update );    this.eventHandlers.forEach( update );   }  };   return Component; }(Item));  function addChild ( meta ) {  if ( this.item ) { this.removeChild( this.item ); }   var child = meta.instance;  meta.anchor = this;   meta.parentFragment = this.parentFragment;  meta.name = meta.nameOption || this.name;  this.name = meta.name;    if ( !child.isolated ) { child.viewmodel.attached( this.parentFragment ); }   // render as necessary  if ( this.rendered ) {   renderItem( this, meta );  } }  function removeChild ( meta ) {  // unrender as necessary  if ( this.item === meta ) {   unrenderItem( this, meta );   this.name = this.template.n;  } }  function renderItem ( anchor, meta ) {  if ( !anchor.rendered ) { return; }   meta.shouldDestroy = false;  meta.parentFragment = anchor.parentFragment;   anchor.item = meta;  anchor.instance = meta.instance;  var nextNode = anchor.parentFragment.findNextNode( anchor );   if ( meta.instance.fragment.rendered ) {   meta.instance.unrender();  }   meta.partials = meta.instance.partials;  meta.instance.partials = Object.assign( {}, meta.partials, anchor._partials );   meta.instance.fragment.unbind();  meta.instance.fragment.bind( meta.instance.viewmodel );   anchor.attributes.forEach( bind );  anchor.eventHandlers.forEach( bind );  anchor.attributes.forEach( render );  anchor.eventHandlers.forEach( render );   var target = anchor.parentFragment.findParentNode();  render$1( meta.instance, target, target.contains( nextNode ) ? nextNode : null, anchor.occupants );   if ( meta.lastBound !== anchor ) {   meta.lastBound = anchor;  } }  function unrenderItem ( anchor, meta ) {  if ( !anchor.rendered ) { return; }   meta.shouldDestroy = true;  meta.instance.unrender();   anchor.eventHandlers.forEach( unrender );  anchor.attributes.forEach( unrender );  anchor.eventHandlers.forEach( unbind );  anchor.attributes.forEach( unbind );   meta.instance.el = meta.instance.anchor = null;  meta.parentFragment = null;  meta.anchor = null;  anchor.item = null;  anchor.instance = null; }  var checking = []; function checkAnchors () {  var list = checking;  checking = [];   list.forEach( updateAnchors ); }  function setupArgsFn ( item, template, fragment, opts ) {  if ( opts === void 0 ) opts = {};   if ( template && template.f && template.f.s ) {   item.fn = getFunction( template.f.s, template.f.r.length );   if ( opts.register === true ) {    item.models = resolveArgs( item, template, fragment, opts );   }  } }  function resolveArgs ( item, template, fragment, opts ) {  if ( opts === void 0 ) opts = {};   return template.f.r.map( function ( ref, i ) {   var model;    if ( opts.specialRef && ( model = opts.specialRef( ref, i ) ) ) { return model; }    model = resolveReference( fragment, ref );   if ( opts.register === true ) {    model.register( item );   }    return model;  }); }  function teardownArgsFn ( item, template ) {  if ( template && template.f && template.f.s ) {   if ( item.models ) { item.models.forEach( function (m) {    if ( m && m.unregister ) { m.unregister( item ); }   }); }   item.models = null;  } }  var missingDecorator = {  update: noop,  teardown: noop };  var Decorator = function Decorator ( options ) {  this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );  this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );  this.parentFragment = this.owner.parentFragment;  this.ractive = this.owner.ractive;  var template = this.template = options.template;   this.name = template.n;   this.node = null;  this.intermediary = null;   this.element.decorators.push( this ); };  Decorator.prototype.bind = function bind () {  setupArgsFn( this, this.template, this.parentFragment, { register: true } ); };  Decorator.prototype.bubble = function bubble () {  if ( !this.dirty ) {   this.dirty = true;   this.owner.bubble();  } };  Decorator.prototype.destroyed = function destroyed () {  if ( this.intermediary ) { this.intermediary.teardown(); }  this.shouldDestroy = true; };  Decorator.prototype.handleChange = function handleChange () { this.bubble(); };  Decorator.prototype.rebind = function rebind ( next, previous, safe ) {  var idx = this.models.indexOf( previous );  if ( !~idx ) { return; }   next = rebindMatch( this.template.f.r[ idx ], next, previous );  if ( next === previous ) { return; }   previous.unregister( this );  this.models.splice( idx, 1, next );  if ( next ) { next.addShuffleRegister( this, 'mark' ); }   if ( !safe ) { this.bubble(); } };  Decorator.prototype.render = function render () {   var this$1 = this;   runloop.scheduleTask( function () {   var fn = findInViewHierarchy( 'decorators', this$1.ractive, this$1.name );    if ( !fn ) {    warnOnce( missingPlugin( this$1.name, 'decorator' ) );    this$1.intermediary = missingDecorator;    return;   }    this$1.node = this$1.element.node;    var args;   if ( this$1.fn ) {    args = this$1.models.map( function (model) {     if ( !model ) { return undefined; }      return model.get();    });    args = this$1.fn.apply( this$1.ractive, args );   }    this$1.intermediary = fn.apply( this$1.ractive, [ this$1.node ].concat( args ) );    if ( !this$1.intermediary || !this$1.intermediary.teardown ) {    throw new Error( ("The '" + (this$1.name) + "' decorator must return an object with a teardown method") );   }    // watch out for decorators that cause their host element to be unrendered   if ( this$1.shouldDestroy ) { this$1.destroyed(); }  }, true );  this.rendered = true; };  Decorator.prototype.toString = function toString () { return ; }; Decorator.prototype.unbind = function unbind () {  teardownArgsFn( this, this.template ); };  Decorator.prototype.unrender = function unrender ( shouldDestroy ) {  if ( ( !shouldDestroy || this.element.rendered ) && this.intermediary ) { this.intermediary.teardown(); }  this.rendered = false; };  Decorator.prototype.update = function update () {  if ( !this.dirty ) { return; }   this.dirty = false;   if ( this.intermediary ) {   if ( !this.intermediary.update ) {    this.unrender();    this.render();   }   else {    var args = this.models.map( function (model) { return model && model.get(); } );    this.intermediary.update.apply( this.ractive, this.fn.apply( this.ractive, args ) );   }  } };  var Doctype = (function (Item$$1) {  function Doctype () {   Item$$1.apply(this, arguments);  }   if ( Item$$1 ) Doctype.__proto__ = Item$$1;  Doctype.prototype = Object.create( Item$$1 && Item$$1.prototype );  Doctype.prototype.constructor = Doctype;   Doctype.prototype.toString = function toString () {   return '<!DOCTYPE' + this.template.a + '>';  };   return Doctype; }(Item));  var proto$1 = Doctype.prototype; proto$1.bind = proto$1.render = proto$1.teardown = proto$1.unbind = proto$1.unrender = proto$1.update = noop;  var Binding = function Binding ( element, name ) {  if ( name === void 0 ) name = 'value';   this.element = element;  this.ractive = element.ractive;  this.attribute = element.attributeByName[ name ];   var interpolator = this.attribute.interpolator;  interpolator.twowayBinding = this;   var model = interpolator.model;   if ( model.isReadonly ) {   var keypath = model.getKeypath().replace( /^@/, ); warnOnceIfDebug( ("Cannot use two-way binding on <" + (element.name) + "> element: " + keypath + " is read-only. To suppress this warning use <" + (element.name) + " twoway='false'...>"), { ractive: this.ractive });   return false;  }   this.attribute.isTwoway = true;  this.model = model;   // initialise value, if it's undefined  var value = model.get();  this.wasUndefined = value === undefined;   if ( value === undefined && this.getInitialValue ) {   value = this.getInitialValue();   model.set( value );  }  this.lastVal( true, value );   var parentForm = findElement( this.element, false, 'form' );  if ( parentForm ) {   this.resetValue = value;   parentForm.formBindings.push( this );  } };  Binding.prototype.bind = function bind () {  this.model.registerTwowayBinding( this ); };  Binding.prototype.handleChange = function handleChange () {   var this$1 = this;   var value = this.getValue();  if ( this.lastVal() === value ) { return; }   runloop.start( this.root );  this.attribute.locked = true;  this.model.set( value );  this.lastVal( true, value );   // if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up  if ( this.model.get() !== value ) { this.attribute.locked = false; }  else { runloop.scheduleTask( function () { return this$1.attribute.locked = false; } ); }   runloop.end(); };  Binding.prototype.lastVal = function lastVal ( setting, value ) {  if ( setting ) { this.lastValue = value; }  else { return this.lastValue; } };  Binding.prototype.rebind = function rebind ( next, previous ) {   var this$1 = this;   if ( this.model && this.model === previous ) { previous.unregisterTwowayBinding( this ); }  if ( next ) {   this.model = next;   runloop.scheduleTask( function () { return next.registerTwowayBinding( this$1 ); } );  } };  Binding.prototype.render = function render () {  this.node = this.element.node;  this.node._ractive.binding = this;  this.rendered = true; // TODO is this used anywhere? };  Binding.prototype.setFromNode = function setFromNode ( node ) {  this.model.set( node.value ); };  Binding.prototype.unbind = function unbind () {  this.model.unregisterTwowayBinding( this ); };  Binding.prototype.unrender = noop;  // This is the handler for DOM events that would lead to a change in the model // (i.e. change, sometimes, input, and occasionally click and keyup) function handleDomEvent () {  this._ractive.binding.handleChange(); }  var CheckboxBinding = (function (Binding$$1) {  function CheckboxBinding ( element ) {   Binding$$1.call( this, element, 'checked' );  }   if ( Binding$$1 ) CheckboxBinding.__proto__ = Binding$$1;  CheckboxBinding.prototype = Object.create( Binding$$1 && Binding$$1.prototype );  CheckboxBinding.prototype.constructor = CheckboxBinding;   CheckboxBinding.prototype.render = function render () {   Binding$$1.prototype.render.call(this);    this.node.addEventListener( 'change', handleDomEvent, false );    if ( this.node.attachEvent ) {    this.node.addEventListener( 'click', handleDomEvent, false );   }  };   CheckboxBinding.prototype.unrender = function unrender () {   this.node.removeEventListener( 'change', handleDomEvent, false );   this.node.removeEventListener( 'click', handleDomEvent, false );  };   CheckboxBinding.prototype.getInitialValue = function getInitialValue () {   return !!this.element.getAttribute( 'checked' );  };   CheckboxBinding.prototype.getValue = function getValue () {   return this.node.checked;  };   CheckboxBinding.prototype.setFromNode = function setFromNode ( node ) {   this.model.set( node.checked );  };   return CheckboxBinding; }(Binding));  function getBindingGroup ( group, model, getValue ) {  var hash = group + "-bindingGroup";  return model[hash] || ( model[ hash ] = new BindingGroup( hash, model, getValue ) ); }  var BindingGroup = function BindingGroup ( hash, model, getValue ) {  var this$1 = this;   this.model = model;  this.hash = hash;  this.getValue = function () {   this$1.value = getValue.call(this$1);   return this$1.value;  };   this.bindings = []; };  BindingGroup.prototype.add = function add ( binding ) {  this.bindings.push( binding ); };  BindingGroup.prototype.bind = function bind () {  this.value = this.model.get();  this.model.registerTwowayBinding( this );  this.bound = true; };  BindingGroup.prototype.remove = function remove ( binding ) {  removeFromArray( this.bindings, binding );  if ( !this.bindings.length ) {   this.unbind();  } };  BindingGroup.prototype.unbind = function unbind () {  this.model.unregisterTwowayBinding( this );  this.bound = false;  delete this.model[this.hash]; };  BindingGroup.prototype.rebind = Binding.prototype.rebind;  var push$1 = [].push;  function getValue() {  var this$1 = this;   var all = this.bindings.filter(function (b) { return b.node && b.node.checked; }).map(function (b) { return b.element.getAttribute( 'value' ); });  var res = [];  all.forEach(function (v) { if ( !this$1.bindings[0].arrayContains( res, v ) ) { res.push( v ); } });  return res; }  var CheckboxNameBinding = (function (Binding$$1) {  function CheckboxNameBinding ( element ) {   Binding$$1.call( this, element, 'name' );    this.checkboxName = true; // so that ractive.updateModel() knows what to do with this    // Each input has a reference to an array containing it and its   // group, as two-way binding depends on being able to ascertain   // the status of all inputs within the group   this.group = getBindingGroup( 'checkboxes', this.model, getValue );   this.group.add( this );    if ( this.noInitialValue ) {    this.group.noInitialValue = true;   }    // If no initial value was set, and this input is checked, we   // update the model   if ( this.group.noInitialValue && this.element.getAttribute( 'checked' ) ) {    var existingValue = this.model.get();    var bindingValue = this.element.getAttribute( 'value' );     if ( !this.arrayContains( existingValue, bindingValue ) ) {     push$1.call( existingValue, bindingValue ); // to avoid triggering runloop with array adaptor    }   }  }   if ( Binding$$1 ) CheckboxNameBinding.__proto__ = Binding$$1;  CheckboxNameBinding.prototype = Object.create( Binding$$1 && Binding$$1.prototype );  CheckboxNameBinding.prototype.constructor = CheckboxNameBinding;   CheckboxNameBinding.prototype.bind = function bind () {   if ( !this.group.bound ) {    this.group.bind();   }  };   CheckboxNameBinding.prototype.getInitialValue = function getInitialValue () {   // This only gets called once per group (of inputs that   // share a name), because it only gets called if there   // isn't an initial value. By the same token, we can make   // a note of that fact that there was no initial value,   // and populate it using any `checked` attributes that   // exist (which users should avoid, but which we should   // support anyway to avoid breaking expectations)   this.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?   return [];  };   CheckboxNameBinding.prototype.getValue = function getValue () {   return this.group.value;  };   CheckboxNameBinding.prototype.handleChange = function handleChange () {   this.isChecked = this.element.node.checked; this.group.value = this.model.get();   var value = this.element.getAttribute( 'value' );   if ( this.isChecked && !this.arrayContains( this.group.value, value ) ) {    this.group.value.push( value );   } else if ( !this.isChecked && this.arrayContains( this.group.value, value ) ) {    this.removeFromArray( this.group.value, value );   }   // make sure super knows there's a change   this.lastValue = null;   Binding$$1.prototype.handleChange.call(this);  };   CheckboxNameBinding.prototype.render = function render () {   Binding$$1.prototype.render.call(this);    var node = this.node;    var existingValue = this.model.get();   var bindingValue = this.element.getAttribute( 'value' );    if ( Array.isArray( existingValue ) ) {    this.isChecked = this.arrayContains( existingValue, bindingValue );   } else {    this.isChecked = this.element.compare( existingValue, bindingValue );   }   node.name = ' Template:' + this.model.getKeypath() + ' ';   node.checked = this.isChecked;    node.addEventListener( 'change', handleDomEvent, false );    // in case of IE emergency, bind to click event as well   if ( node.attachEvent ) {    node.addEventListener( 'click', handleDomEvent, false );   }  };   CheckboxNameBinding.prototype.setFromNode = function setFromNode ( node ) {   this.group.bindings.forEach( function (binding) { return binding.wasUndefined = true; } );    if ( node.checked ) {    var valueSoFar = this.group.getValue();    valueSoFar.push( this.element.getAttribute( 'value' ) );     this.group.model.set( valueSoFar );   }  };   CheckboxNameBinding.prototype.unbind = function unbind () {   this.group.remove( this );  };   CheckboxNameBinding.prototype.unrender = function unrender () {   var node = this.element.node;    node.removeEventListener( 'change', handleDomEvent, false );   node.removeEventListener( 'click', handleDomEvent, false );  };   CheckboxNameBinding.prototype.arrayContains = function arrayContains ( selectValue, optionValue ) {   var this$1 = this;    var i = selectValue.length;   while ( i-- ) {    if ( this$1.element.compare( optionValue, selectValue[i] ) ) { return true; }   }   return false;  };   CheckboxNameBinding.prototype.removeFromArray = function removeFromArray ( array, item ) {   var this$1 = this;    if (!array) { return; }   var i = array.length;   while( i-- ) {    if ( this$1.element.compare( item, array[i] ) ) {     array.splice( i, 1 );    }   }  };   return CheckboxNameBinding; }(Binding));  var ContentEditableBinding = (function (Binding$$1) {  function ContentEditableBinding () {   Binding$$1.apply(this, arguments);  }   if ( Binding$$1 ) ContentEditableBinding.__proto__ = Binding$$1;  ContentEditableBinding.prototype = Object.create( Binding$$1 && Binding$$1.prototype );  ContentEditableBinding.prototype.constructor = ContentEditableBinding;   ContentEditableBinding.prototype.getInitialValue = function getInitialValue () {   return this.element.fragment ? this.element.fragment.toString() : ; };   ContentEditableBinding.prototype.getValue = function getValue () {   return this.element.node.innerHTML;  };   ContentEditableBinding.prototype.render = function render () {   Binding$$1.prototype.render.call(this);    var node = this.node;    node.addEventListener( 'change', handleDomEvent, false );   node.addEventListener( 'blur', handleDomEvent, false );    if ( !this.ractive.lazy ) {    node.addEventListener( 'input', handleDomEvent, false );     if ( node.attachEvent ) {     node.addEventListener( 'keyup', handleDomEvent, false );    }   }  };   ContentEditableBinding.prototype.setFromNode = function setFromNode ( node ) {   this.model.set( node.innerHTML );  };   ContentEditableBinding.prototype.unrender = function unrender () {   var node = this.node;    node.removeEventListener( 'blur', handleDomEvent, false );   node.removeEventListener( 'change', handleDomEvent, false );   node.removeEventListener( 'input', handleDomEvent, false );   node.removeEventListener( 'keyup', handleDomEvent, false );  };   return ContentEditableBinding; }(Binding));  function handleBlur () {  handleDomEvent.call( this );   var value = this._ractive.binding.model.get();  this.value = value == undefined ?  : value; }  function handleDelay ( delay ) {  var timeout;   return function () {   var this$1 = this;    if ( timeout ) { clearTimeout( timeout ); }    timeout = setTimeout( function () {    var binding = this$1._ractive.binding;    if ( binding.rendered ) { handleDomEvent.call( this$1 ); }    timeout = null;   }, delay );  }; }  var GenericBinding = (function (Binding$$1) {  function GenericBinding () {   Binding$$1.apply(this, arguments);  }   if ( Binding$$1 ) GenericBinding.__proto__ = Binding$$1;  GenericBinding.prototype = Object.create( Binding$$1 && Binding$$1.prototype );  GenericBinding.prototype.constructor = GenericBinding;   GenericBinding.prototype.getInitialValue = function getInitialValue () {   return ; };   GenericBinding.prototype.getValue = function getValue () {   return this.node.value;  };   GenericBinding.prototype.render = function render () {   Binding$$1.prototype.render.call(this);    // any lazy setting for this element overrides the root   // if the value is a number, it's a timeout   var lazy = this.ractive.lazy;   var timeout = false;    if ( 'lazy' in this.element ) {    lazy = this.element.lazy;   }    if ( isNumeric( lazy ) ) {    timeout = +lazy;    lazy = false;   }    this.handler = timeout ? handleDelay( timeout ) : handleDomEvent;    var node = this.node;    node.addEventListener( 'change', handleDomEvent, false );    if ( !lazy ) {    node.addEventListener( 'input', this.handler, false );     if ( node.attachEvent ) {     node.addEventListener( 'keyup', this.handler, false );    }   }    node.addEventListener( 'blur', handleBlur, false );  };   GenericBinding.prototype.unrender = function unrender () {   var node = this.element.node;   this.rendered = false;    node.removeEventListener( 'change', handleDomEvent, false );   node.removeEventListener( 'input', this.handler, false );   node.removeEventListener( 'keyup', this.handler, false );   node.removeEventListener( 'blur', handleBlur, false );  };   return GenericBinding; }(Binding));  var FileBinding = (function (GenericBinding$$1) {  function FileBinding () {   GenericBinding$$1.apply(this, arguments);  }   if ( GenericBinding$$1 ) FileBinding.__proto__ = GenericBinding$$1;  FileBinding.prototype = Object.create( GenericBinding$$1 && GenericBinding$$1.prototype );  FileBinding.prototype.constructor = FileBinding;   FileBinding.prototype.getInitialValue = function getInitialValue () {   return undefined;  };   FileBinding.prototype.getValue = function getValue () {   return this.node.files;  };   FileBinding.prototype.render = function render () {   this.element.lazy = false;   GenericBinding$$1.prototype.render.call(this);  };   FileBinding.prototype.setFromNode = function setFromNode ( node ) {   this.model.set( node.files );  };   return FileBinding; }(GenericBinding));  function getSelectedOptions ( select ) {  return select.selectedOptions   ? toArray( select.selectedOptions )   : select.options    ? toArray( select.options ).filter( function (option) { return option.selected; } )    : []; }  var MultipleSelectBinding = (function (Binding$$1) {  function MultipleSelectBinding () {   Binding$$1.apply(this, arguments);  }   if ( Binding$$1 ) MultipleSelectBinding.__proto__ = Binding$$1;  MultipleSelectBinding.prototype = Object.create( Binding$$1 && Binding$$1.prototype );  MultipleSelectBinding.prototype.constructor = MultipleSelectBinding;   MultipleSelectBinding.prototype.getInitialValue = function getInitialValue () {   return this.element.options    .filter( function (option) { return option.getAttribute( 'selected' ); } )    .map( function (option) { return option.getAttribute( 'value' ); } );  };   MultipleSelectBinding.prototype.getValue = function getValue () {   var options = this.element.node.options;   var len = options.length;    var selectedValues = [];    for ( var i = 0; i < len; i += 1 ) {    var option = options[i];     if ( option.selected ) {     var optionValue = option._ractive ? option._ractive.value : option.value;     selectedValues.push( optionValue );    }   }    return selectedValues;  };   MultipleSelectBinding.prototype.handleChange = function handleChange () {   var attribute = this.attribute;   var previousValue = attribute.getValue();    var value = this.getValue();    if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {    Binding$$1.prototype.handleChange.call(this);   }    return this;  };   MultipleSelectBinding.prototype.render = function render () {   Binding$$1.prototype.render.call(this);    this.node.addEventListener( 'change', handleDomEvent, false );    if ( this.model.get() === undefined ) {    // get value from DOM, if possible    this.handleChange();   }  };   MultipleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {   var selectedOptions = getSelectedOptions( node );   var i = selectedOptions.length;   var result = new Array( i );    while ( i-- ) {    var option = selectedOptions[i];    result[i] = option._ractive ? option._ractive.value : option.value;   }    this.model.set( result );  };   MultipleSelectBinding.prototype.unrender = function unrender () {   this.node.removeEventListener( 'change', handleDomEvent, false );  };   return MultipleSelectBinding; }(Binding));  var NumericBinding = (function (GenericBinding$$1) {  function NumericBinding () {   GenericBinding$$1.apply(this, arguments);  }   if ( GenericBinding$$1 ) NumericBinding.__proto__ = GenericBinding$$1;  NumericBinding.prototype = Object.create( GenericBinding$$1 && GenericBinding$$1.prototype );  NumericBinding.prototype.constructor = NumericBinding;   NumericBinding.prototype.getInitialValue = function getInitialValue () { return undefined;  };   NumericBinding.prototype.getValue = function getValue () {   var value = parseFloat( this.node.value );   return isNaN( value ) ? undefined : value;  };   NumericBinding.prototype.setFromNode = function setFromNode ( node ) {   var value = parseFloat( node.value );   if ( !isNaN( value ) ) { this.model.set( value ); }  };   return NumericBinding; }(GenericBinding));  var siblings = {};  function getSiblings ( hash ) {  return siblings[ hash ] || ( siblings[ hash ] = [] ); }  var RadioBinding = (function (Binding$$1) {  function RadioBinding ( element ) {   Binding$$1.call( this, element, 'checked' );    this.siblings = getSiblings( this.ractive._guid + this.element.getAttribute( 'name' ) );   this.siblings.push( this );  }   if ( Binding$$1 ) RadioBinding.__proto__ = Binding$$1;  RadioBinding.prototype = Object.create( Binding$$1 && Binding$$1.prototype );  RadioBinding.prototype.constructor = RadioBinding;   RadioBinding.prototype.getValue = function getValue () {   return this.node.checked;  };   RadioBinding.prototype.handleChange = function handleChange () {   runloop.start( this.root );    this.siblings.forEach( function (binding) {    binding.model.set( binding.getValue() );   });    runloop.end();  };   RadioBinding.prototype.render = function render () {   Binding$$1.prototype.render.call(this);    this.node.addEventListener( 'change', handleDomEvent, false );    if ( this.node.attachEvent ) {    this.node.addEventListener( 'click', handleDomEvent, false );   }  };   RadioBinding.prototype.setFromNode = function setFromNode ( node ) {   this.model.set( node.checked );  };   RadioBinding.prototype.unbind = function unbind () {   removeFromArray( this.siblings, this );  };   RadioBinding.prototype.unrender = function unrender () {   this.node.removeEventListener( 'change', handleDomEvent, false );   this.node.removeEventListener( 'click', handleDomEvent, false );  };   return RadioBinding; }(Binding));  function getValue$1() {  var checked = this.bindings.filter( function (b) { return b.node.checked; } );  if ( checked.length > 0 ) {   return checked[0].element.getAttribute( 'value' );  } }  var RadioNameBinding = (function (Binding$$1) {  function RadioNameBinding ( element ) {   Binding$$1.call( this, element, 'name' );    this.group = getBindingGroup( 'radioname', this.model, getValue$1 );   this.group.add( this );    if ( element.checked ) {    this.group.value = this.getValue();   }  }   if ( Binding$$1 ) RadioNameBinding.__proto__ = Binding$$1;  RadioNameBinding.prototype = Object.create( Binding$$1 && Binding$$1.prototype );  RadioNameBinding.prototype.constructor = RadioNameBinding;   RadioNameBinding.prototype.bind = function bind () {   var this$1 = this;    if ( !this.group.bound ) {    this.group.bind();   }    // update name keypath when necessary   this.nameAttributeBinding = {    handleChange: function () { return this$1.node.name = " Template:" + (this$1.model.getKeypath()) + " "; },    rebind: noop   };    this.model.getKeypathModel().register( this.nameAttributeBinding );  };   RadioNameBinding.prototype.getInitialValue = function getInitialValue () {   if ( this.element.getAttribute( 'checked' ) ) {    return this.element.getAttribute( 'value' );   }  };   RadioNameBinding.prototype.getValue = function getValue () {   return this.element.getAttribute( 'value' );  };   RadioNameBinding.prototype.handleChange = function handleChange () {   // If this <input> is the one that's checked, then the value of its   // `name` model gets set to its value   if ( this.node.checked ) {    this.group.value = this.getValue();    Binding$$1.prototype.handleChange.call(this);   }  };   RadioNameBinding.prototype.lastVal = function lastVal ( setting, value ) {   if ( !this.group ) { return; }   if ( setting ) { this.group.lastValue = value; }   else { return this.group.lastValue; }  };   RadioNameBinding.prototype.render = function render () {   Binding$$1.prototype.render.call(this);    var node = this.node;    node.name = " Template:" + (this.model.getKeypath()) + " ";   node.checked = this.element.compare ( this.model.get(), this.element.getAttribute( 'value' ) );    node.addEventListener( 'change', handleDomEvent, false );    if ( node.attachEvent ) {    node.addEventListener( 'click', handleDomEvent, false );   }  };   RadioNameBinding.prototype.setFromNode = function setFromNode ( node ) {   if ( node.checked ) {    this.group.model.set( this.element.getAttribute( 'value' ) );   }  };   RadioNameBinding.prototype.unbind = function unbind () {   this.group.remove( this );    this.model.getKeypathModel().unregister( this.nameAttributeBinding );  };   RadioNameBinding.prototype.unrender = function unrender () {   var node = this.node;    node.removeEventListener( 'change', handleDomEvent, false );   node.removeEventListener( 'click', handleDomEvent, false );  };   return RadioNameBinding; }(Binding));  var SingleSelectBinding = (function (Binding$$1) {  function SingleSelectBinding () {   Binding$$1.apply(this, arguments);  }   if ( Binding$$1 ) SingleSelectBinding.__proto__ = Binding$$1;  SingleSelectBinding.prototype = Object.create( Binding$$1 && Binding$$1.prototype );  SingleSelectBinding.prototype.constructor = SingleSelectBinding;   SingleSelectBinding.prototype.forceUpdate = function forceUpdate () {   var this$1 = this;    var value = this.getValue();    if ( value !== undefined ) {    this.attribute.locked = true;    runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );    this.model.set( value );   }  };   SingleSelectBinding.prototype.getInitialValue = function getInitialValue () {   if ( this.element.getAttribute( 'value' ) !== undefined ) {    return;   }    var options = this.element.options;   var len = options.length;    if ( !len ) { return; }    var value;   var optionWasSelected;   var i = len;    // take the final selected option...   while ( i-- ) {    var option = options[i];     if ( option.getAttribute( 'selected' ) ) {     if ( !option.getAttribute( 'disabled' ) ) {      value = option.getAttribute( 'value' );     }      optionWasSelected = true;     break;    }   }    // or the first non-disabled option, if none are selected   if ( !optionWasSelected ) {    while ( ++i < len ) {     if ( !options[i].getAttribute( 'disabled' ) ) {      value = options[i].getAttribute( 'value' );      break;     }    }   }    // This is an optimisation (aka hack) that allows us to forgo some   // other more expensive work   // TODO does it still work? seems at odds with new architecture   if ( value !== undefined ) {    this.element.attributeByName.value.value = value;   }    return value;  };   SingleSelectBinding.prototype.getValue = function getValue () {   var options = this.node.options;   var len = options.length;    var i;   for ( i = 0; i < len; i += 1 ) {    var option = options[i];     if ( options[i].selected && !options[i].disabled ) {     return option._ractive ? option._ractive.value : option.value;    }   }  };   SingleSelectBinding.prototype.render = function render () {   Binding$$1.prototype.render.call(this);   this.node.addEventListener( 'change', handleDomEvent, false );  };   SingleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {   var option = getSelectedOptions( node )[0];   this.model.set( option._ractive ? option._ractive.value : option.value );  };   SingleSelectBinding.prototype.unrender = function unrender () {   this.node.removeEventListener( 'change', handleDomEvent, false );  };   return SingleSelectBinding; }(Binding));  function isBindable ( attribute ) {   // The fragment must be a single non-string fragment  if ( !attribute || !attribute.template.f || !attribute.template.f.length === 1 || attribute.template.f[0].s ) { return false; }   // A binding is an interpolator `{{ }}`, yey.  if ( attribute.template.f[0].t === INTERPOLATOR ) { return true; }   // The above is probably the only true case. For the rest, show an appropriate  // warning before returning false.   // You can't bind a triple curly. HTML values on an attribute makes no sense.  if ( attribute.template.f[0].t === TRIPLE ) { warnIfDebug( 'It is not possible create a binding using a triple mustache.' ); }   return false; }  function selectBinding ( element ) {  var name = element.name;  var attributes = element.attributeByName;  var isBindableByValue = isBindable( attributes.value );  var isBindableByContentEditable = isBindable( attributes.contenteditable );  var isContentEditable =  element.getAttribute( 'contenteditable' );   // contenteditable  // Bind if the contenteditable is true or a binding that may become true.  if ( ( isContentEditable || isBindableByContentEditable ) && isBindableByValue ) { return ContentEditableBinding; }   // <input> if ( name === 'input' ) {   var type = element.getAttribute( 'type' );    if ( type === 'radio' ) {    var isBindableByName = isBindable( attributes.name );    var isBindableByChecked = isBindable( attributes.checked );     // For radios we can either bind the name or checked, but not both.    // Name binding is handed instead.    if ( isBindableByName && isBindableByChecked ) {     warnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });     return RadioNameBinding;    }     if ( isBindableByName ) { return RadioNameBinding; }     if ( isBindableByChecked ) { return RadioBinding; }     // Dead end. Unknown binding on radio input.    return null;   }    if ( type === 'checkbox' ) {    var isBindableByName$1 = isBindable( attributes.name );    var isBindableByChecked$1 = isBindable( attributes.checked );     // A checkbox with bindings for both name and checked. Checked treated as    // the checkbox value, name is treated as a regular binding.    //    // See https://github.com/ractivejs/ractive/issues/1749 if ( isBindableByName$1 && isBindableByChecked$1 ) { return CheckboxBinding; }     if ( isBindableByName$1 ) { return CheckboxNameBinding; }     if ( isBindableByChecked$1 ) { return CheckboxBinding; }     // Dead end. Unknown binding on checkbox input.    return null;   }    if ( type === 'file' && isBindableByValue ) { return FileBinding; }    if ( type === 'number' && isBindableByValue ) { return NumericBinding; }    if ( type === 'range' && isBindableByValue ) { return NumericBinding; }    // Some input of unknown type (browser usually falls back to text).   if ( isBindableByValue ) { return GenericBinding; }    // Dead end. Some unknown input and an unbindable.   return null;  }   // <select> if ( name === 'select' && isBindableByValue ){   return element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SingleSelectBinding;  }   // <textarea> if ( name === 'textarea' && isBindableByValue ) { return GenericBinding; }   // Dead end. Some unbindable element.  return null; }  var DOMEvent = function DOMEvent ( name, owner, delegate ) {  if ( name.indexOf( '*' ) !== -1 ) {   fatal( ("Only component proxy-events may contain \"*\" wildcards, <" + (owner.name) + " on-" + name + "=\"...\"/> is not valid") );  }   this.name = name;  this.owner = owner;  this.delegate = delegate;  this.node = null;  this.handler = null; };  DOMEvent.prototype.listen = function listen ( directive ) {  var node = this.node = this.owner.node;  var name = this.name;   // this is probably a custom event fired from a decorator or manually  if ( !( ("on" + name) in node ) ) { return; }   node.addEventListener( name, this.handler = function( event ) {   directive.fire({    node: node,    original: event,    event: event,    name: name   });  }, this.delegate ); };  DOMEvent.prototype.unlisten = function unlisten () {  if ( this.handler ) { this.node.removeEventListener( this.name, this.handler, false ); } };  var CustomEvent = function CustomEvent ( eventPlugin, owner, name ) {  this.eventPlugin = eventPlugin;  this.owner = owner;  this.name = name;  this.handler = null; };  CustomEvent.prototype.listen = function listen ( directive ) {   var this$1 = this;   var node = this.owner.node;   this.handler = this.eventPlugin( node, function ( event ) {    if ( event === void 0 ) event = {};    if ( event.original ) { event.event = event.original; }   else { event.original = event.event; }    event.name = this$1.name;   event.node = event.node || node;   directive.fire( event );  }); };  CustomEvent.prototype.unlisten = function unlisten () {  this.handler.teardown(); };  var RactiveEvent = function RactiveEvent ( component, name ) {  this.component = component;  this.name = name;  this.handler = null; };  RactiveEvent.prototype.listen = function listen ( directive ) {  var ractive = this.component.instance;   this.handler = ractive.on( this.name, function () {    var args = [], len = arguments.length;    while ( len-- ) args[ len ] = arguments[ len ];    // watch for reproxy   if ( args[0] instanceof Context ) {    var ctx = args.shift();    ctx.component = ractive;    directive.fire( ctx, args );   } else {    directive.fire( {}, args );   }    // cancel bubbling   return false;  }); };  RactiveEvent.prototype.unlisten = function unlisten () {  this.handler.cancel(); };  var specialPattern = /^(event|arguments|@node|@event|@context)(\..+)?$/; var dollarArgsPattern = /^\$(\d+)(\..+)?$/;  var DelegateProxy = {  fire: function fire ( event, args ) {   if ( args === void 0 ) args = [];    if ( event && event.event ) {    var ev = event.event;     // TODO if IE<9 needs to be supported here, could probably walk to the element with a ractive proxy with a delegates property    var end = ev.currentTarget;    var node = ev.target;    var name = event.name;    var bubble = true;     // starting with the origin node, walk up the DOM looking for ractive nodes with a matching event listener    while ( bubble && node && node !== end ) {     var el = node._ractive && node._ractive.proxy;      if ( el ) {      // set up the context for the handler      event.node = el.node;      event.name = name;       el.events.forEach( function (ev) {       if ( ev.delegate && ~ev.template.n.indexOf( name ) ) {        bubble = ev.fire( event, args ) !== false && bubble;       }      });     }      node = node.parentNode;    }     return bubble;   }  } };  var EventDirective = function EventDirective ( options ) {  var this$1 = this;   this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );  this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment, true );  this.template = options.template;  this.parentFragment = options.parentFragment;  this.ractive = options.parentFragment.ractive;  var delegate = this.delegate = this.ractive.delegate && options.parentFragment.delegate;  this.events = [];   if ( this.element.type === COMPONENT || this.element.type === ANCHOR ) {   this.template.n.forEach( function (n) {    this$1.events.push( new RactiveEvent( this$1.element, n ) );   });  } else {   // make sure the delegate element has a storag object   if ( delegate && !delegate.delegates ) { delegate.delegates = {}; }    this.template.n.forEach( function (n) {    var fn = findInViewHierarchy( 'events', this$1.ractive, n );    if ( fn ) {     this$1.events.push( new CustomEvent( fn, this$1.element, n ) );    } else {     if ( delegate ) {      if ( !delegate.delegates[n] ) {       var ev = new DOMEvent( n, delegate, true );       delegate.delegates[n] = ev;       // if the element is already rendered, render the event too       if ( delegate.rendered ) { ev.listen( DelegateProxy ); }      }     } else {      this$1.events.push( new DOMEvent( n, this$1.element ) );     }    }   });  }   // method calls  this.models = null; };  EventDirective.prototype.bind = function bind () {  addToArray( this.element.events, this );   setupArgsFn( this, this.template );  if ( !this.fn ) { this.action = this.template.f; } };  EventDirective.prototype.destroyed = function destroyed () {  this.events.forEach( function (e) { return e.unlisten(); } ); };  EventDirective.prototype.fire = function fire ( event, args ) {   var this$1 = this;   if ( args === void 0 ) args = [];   var context = this.element.getContext( event );   if ( this.fn ) {   var values = [];    var models = resolveArgs( this, this.template, this.parentFragment, {    specialRef: function specialRef ( ref ) {     var specialMatch = specialPattern.exec( ref );     if ( specialMatch ) {      // on-click="foo(event.node)"      return {       special: specialMatch[1],       keys: specialMatch[2] ? splitKeypath( specialMatch[2].substr(1) ) : []      };     }      var dollarMatch = dollarArgsPattern.exec( ref );     if ( dollarMatch ) {      // on-click="foo($1)"      return {       special: 'arguments',       keys: [ dollarMatch[1] - 1 ].concat( dollarMatch[2] ? splitKeypath( dollarMatch[2].substr( 1 ) ) : [] )      };     }    }   });    if ( models ) {    models.forEach( function (model) {     if ( !model ) { return values.push( undefined ); }      if ( model.special ) {      var which = model.special;      var obj;       if ( which === '@node' ) {       obj = this$1.element.node;      } else if ( which === '@event' ) {       obj = event && event.event;      } else if ( which === 'event' ) {       warnOnceIfDebug( "The event reference available to event directives is deprecated and should be replaced with @context and @event" );       obj = context;      } else if ( which === '@context' ) {       obj = context; } else {       obj = args;      }       var keys = model.keys.slice();       while ( obj && keys.length ) { obj = obj[ keys.shift() ]; }      return values.push( obj );     }      if ( model.wrapper ) {      return values.push( model.wrapperValue );     }      values.push( model.get() );    });   }    // make event available as `this.event`   var ractive = this.ractive;   var oldEvent = ractive.event;    ractive.event = context;   var returned = this.fn.apply( ractive, values );   var result = returned.pop();    // Auto prevent and stop if return is explicitly false   if ( result === false ) {    var original = event ? event.original : undefined;    if ( original ) {     original.preventDefault && original.preventDefault();     original.stopPropagation && original.stopPropagation();    } else {     warnOnceIfDebug( ("handler '" + (this.template.n.join( ' ' )) + "' returned false, but there is no event available to cancel") );    }   }    // watch for proxy events   else if ( !returned.length && Array.isArray( result ) && typeof result[0] === 'string' ) {    result = fireEvent( this.ractive, result.shift(), context, result );   }    ractive.event = oldEvent;    return result;  }   else {   return fireEvent( this.ractive, this.action, context, args);  } };  EventDirective.prototype.handleChange = function handleChange () {};  EventDirective.prototype.render = function render () {   var this$1 = this;   // render events after everything else, so they fire after bindings  runloop.scheduleTask( function () { return this$1.events.forEach( function (e) { return e.listen( this$1 ); }, true ); } ); };  EventDirective.prototype.toString = function toString () { return ; }; EventDirective.prototype.unbind = function unbind () {  removeFromArray( this.element.events, this ); };  EventDirective.prototype.unrender = function unrender () {  this.events.forEach( function (e) { return e.unlisten(); } ); };  EventDirective.prototype.update = noop;  var endsWithSemi = /;\s*$/;  var Element = (function (ContainerItem$$1) {  function Element ( options ) {   var this$1 = this;    ContainerItem$$1.call( this, options );    this.name = options.template.e.toLowerCase();   this.isVoid = voidElementNames.test( this.name );    // find parent element   this.parent = findElement( this.parentFragment, false );    if ( this.parent && this.parent.name === 'option' ) {    throw new Error( ("An <option> element cannot contain other elements (encountered <" + (this.name) + ">)") );   }    this.decorators = [];   this.events = [];    // create attributes   this.attributeByName = {};    this.attributes = [];   var leftovers = [];   ( this.template.m || [] ).forEach( function (template) {    switch ( template.t ) {     case ATTRIBUTE:     case BINDING_FLAG:     case DECORATOR:     case EVENT:     case TRANSITION:      this$1.attributes.push( createItem({       owner: this$1,       parentFragment: this$1.parentFragment,       template: template      }) );      break;      case DELEGATE_FLAG:       this$1.delegate = false;      break;      default:      leftovers.push( template );      break;    }   });    if ( leftovers.length ) {    this.attributes.push( new ConditionalAttribute({     owner: this,     parentFragment: this.parentFragment,     template: leftovers    }) );   }    this.attributes.sort( sortAttributes );    // create children   if ( options.template.f && !options.deferContent ) {    this.fragment = new Fragment({     template: options.template.f,     owner: this,     cssIds: null    });   }    this.binding = null; // filled in later  }   if ( ContainerItem$$1 ) Element.__proto__ = ContainerItem$$1;  Element.prototype = Object.create( ContainerItem$$1 && ContainerItem$$1.prototype );  Element.prototype.constructor = Element;   Element.prototype.bind = function bind$1 () {   this.attributes.binding = true;   this.attributes.forEach( bind );   this.attributes.binding = false;    if ( this.fragment ) { this.fragment.bind(); }    // create two-way binding if necessary   if ( !this.binding ) { this.recreateTwowayBinding(); }   else { this.binding.bind(); }  };   Element.prototype.createTwowayBinding = function createTwowayBinding () {   if ( 'twoway' in this ? this.twoway : this.ractive.twoway ) {    var Binding = selectBinding( this );    if ( Binding ) {     var binding = new Binding( this );     if ( binding && binding.model ) { return binding; }    }   }  };   Element.prototype.destroyed = function destroyed$1 () {   var this$1 = this;    this.attributes.forEach( destroyed );   for ( var ev in this$1.delegates ) {    this$1.delegates[ev].unlisten();   }   if ( this.fragment ) { this.fragment.destroyed(); }  };   Element.prototype.detach = function detach () {   // if this element is no longer rendered, the transitions are complete and the attributes can be torn down   if ( !this.rendered ) { this.destroyed(); }    return detachNode( this.node );  };   Element.prototype.find = function find ( selector, options ) {   if ( this.node && matches( this.node, selector ) ) { return this.node; }   if ( this.fragment ) {    return this.fragment.find( selector, options );   }  };   Element.prototype.findAll = function findAll ( selector, options ) {   var result = options.result;    if ( matches( this.node, selector ) ) {    result.push( this.node );   }    if ( this.fragment ) {    this.fragment.findAll( selector, options );   }  };   Element.prototype.findNextNode = function findNextNode () {   return null;  };   Element.prototype.firstNode = function firstNode () {   return this.node;  };   Element.prototype.getAttribute = function getAttribute ( name ) {   var attribute = this.attributeByName[ name ];   return attribute ? attribute.getValue() : undefined;  };   Element.prototype.getContext = function getContext () {   var assigns = [], len = arguments.length;   while ( len-- ) assigns[ len ] = arguments[ len ];    if ( this.fragment ) { return (ref = this.fragment).getContext.apply( ref, assigns ); }    if ( !this.ctx ) { this.ctx = new Context( this.parentFragment, this ); }   assigns.unshift( Object.create( this.ctx ) );   return Object.assign.apply( null, assigns );   var ref;  };   Element.prototype.recreateTwowayBinding = function recreateTwowayBinding () {   if ( this.binding ) {    this.binding.unbind();    this.binding.unrender();   }    if ( this.binding = this.createTwowayBinding() ) {    this.binding.bind();    if ( this.rendered ) { this.binding.render(); }   }  };   Element.prototype.render = function render$1 ( target, occupants ) {   var this$1 = this;    // TODO determine correct namespace   this.namespace = getNamespace( this );    var node;   var existing = false;    if ( occupants ) {    var n;    while ( ( n = occupants.shift() ) ) {     if ( n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() && n.namespaceURI === this$1.namespace ) {      this$1.node = node = n;      existing = true;      break;     } else {      detachNode( n );     }    }   }    if ( !node ) {    var name = this.template.e;    node = createElement( this.namespace === html ? name.toLowerCase() : name, this.namespace, this.getAttribute( 'is' ) );    this.node = node;   }    // tie the node to this vdom element   Object.defineProperty( node, '_ractive', {    value: {     proxy: this    }   });    // Is this a top-level node of a component? If so, we may need to add   // a data-ractive-css attribute, for CSS encapsulation   if ( this.parentFragment.cssIds ) {    node.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( function (x) { return ("{" + x + "}"); } ).join( ' ' ) );   }    if ( existing && this.foundNode ) { this.foundNode( node ); }    // register intro before rendering content so children can find the intro   var intro = this.intro;   if ( intro && intro.shouldFire( 'intro' ) ) {    intro.isIntro = true;    intro.isOutro = false;    runloop.registerTransition( intro );   }    if ( this.fragment ) {    var children = existing ? toArray( node.childNodes ) : undefined;     this.fragment.render( node, children );     // clean up leftover children    if ( children ) {     children.forEach( detachNode );    }   }    if ( existing ) {    // store initial values for two-way binding    if ( this.binding && this.binding.wasUndefined ) { this.binding.setFromNode( node ); }    // remove unused attributes    var i = node.attributes.length;    while ( i-- ) {     var name$1 = node.attributes[i].name;     if ( !( name$1 in this$1.attributeByName ) ){ node.removeAttribute( name$1 ); }    }   }    this.attributes.forEach( render );   if ( this.delegates ) {    for ( var ev in this$1.delegates ) {     this$1.delegates[ev].listen( DelegateProxy );    }   }    if ( this.binding ) { this.binding.render(); }    if ( !existing ) {    target.appendChild( node );   }    this.rendered = true;  };   Element.prototype.toString = function toString$$1 () {   var tagName = this.template.e;    var attrs = this.attributes.map( stringifyAttribute ).join( ); // Special case - selected options   if ( this.name === 'option' && this.isSelected() ) {    attrs += ' selected';   }    // Special case - two-way radio name bindings   if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {    attrs += ' checked';   }    // Special case style and class attributes and directives   var style, cls;   this.attributes.forEach( function (attr) {    if ( attr.name === 'class' ) {     cls = ( cls || ) + ( cls ? ' ' : ) + safeAttributeString( attr.getString() );    } else if ( attr.name === 'style' ) {     style = ( style || ) + ( style ? ' ' : ) + safeAttributeString( attr.getString() );     if ( style && !endsWithSemi.test( style ) ) { style += ';'; }    } else if ( attr.style ) {     style = ( style || ) + ( style ? ' ' : ) +  (attr.style) + ": " + (safeAttributeString( attr.getString() )) + ";";    } else if ( attr.inlineClass && attr.getValue() ) {     cls = ( cls || ) + ( cls ? ' ' : ) + attr.inlineClass;    }   });   // put classes first, then inline style   if ( style !== undefined ) { attrs = ' style' + ( style ? ("=\"" + style + "\"") : ) + attrs; } if ( cls !== undefined ) { attrs = ' class' + (cls ? ("=\"" + cls + "\"") : ) + attrs; } if ( this.parentFragment.cssIds ) {    attrs += " data-ractive-css=\"" + (this.parentFragment.cssIds.map( function (x) { return ("{" + x + "}"); } ).join( ' ' )) + "\"";   }    var str = "<" + tagName + attrs + ">";    if ( this.isVoid ) { return str; }    // Special case - textarea   if ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {    str += escapeHtml( this.getAttribute( 'value' ) );   }    // Special case - contenteditable   else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {    str += ( this.getAttribute( 'value' ) || ); }    if ( this.fragment ) {    str += this.fragment.toString( !/^(?:script|style)$/i.test( this.template.e ) ); // escape text unless script/style   }    str += "</" + tagName + ">";   return str;  };   Element.prototype.unbind = function unbind$1 () {   this.attributes.unbinding = true;   this.attributes.forEach( unbind );   this.attributes.unbinding = false;    if ( this.binding ) { this.binding.unbind(); }   if ( this.fragment ) { this.fragment.unbind(); }  };   Element.prototype.unrender = function unrender$$1 ( shouldDestroy ) {   if ( !this.rendered ) { return; }   this.rendered = false;    // unrendering before intro completed? complete it now   // TODO should be an API for aborting transitions   var transition = this.intro;   if ( transition && transition.complete ) { transition.complete(); }    // Detach as soon as we can   if ( this.name === 'option' ) {    // <option> elements detach immediately, so that    // their parent <select> element syncs correctly, and    // since option elements can't have transitions anyway    this.detach(); } else if ( shouldDestroy ) {    runloop.detachWhenReady( this );   }    // outro transition   var outro = this.outro;   if ( outro && outro.shouldFire( 'outro' ) ) {    outro.isIntro = false;    outro.isOutro = true;    runloop.registerTransition( outro );   }    if ( this.fragment ) { this.fragment.unrender(); }    if ( this.binding ) { this.binding.unrender(); }  };   Element.prototype.update = function update$1 () {   if ( this.dirty ) {    this.dirty = false;     this.attributes.forEach( update );     if ( this.fragment ) { this.fragment.update(); }   }  };   return Element; }(ContainerItem));  var toFront = [ 'min', 'max', 'class', 'type' ]; function sortAttributes ( left, right ) {  left = left.name;  right = right.name;  var l = left === 'value' ? 1 : ~toFront.indexOf( left );  var r = right === 'value' ? 1 : ~toFront.indexOf( right );  return l < r ? -1 : l > r ? 1 : 0; }  function inputIsCheckedRadio ( element ) {  var nameAttr = element.attributeByName.name;  return element.getAttribute( 'type' ) === 'radio' && ( nameAttr || {} ).interpolator && element.getAttribute( 'value' ) === nameAttr.interpolator.model.get(); }  function stringifyAttribute ( attribute ) {  var str = attribute.toString();  return str ? ' ' + str : ; }  function getNamespace ( element ) {  // Use specified namespace...  var xmlns$$1 = element.getAttribute( 'xmlns' );  if ( xmlns$$1 ) { return xmlns$$1; }   // ...or SVG namespace, if this is an <svg> element  if ( element.name === 'svg' ) { return svg$1; }   var parent = element.parent;   if ( parent ) {   // ...or HTML, if the parent is a <foreignObject> if ( parent.name === 'foreignobject' ) { return html; }    // ...or inherit from the parent node   return parent.node.namespaceURI;  }   return element.ractive.el.namespaceURI; }  var Form = (function (Element$$1) {  function Form ( options ) {   Element$$1.call( this, options );   this.formBindings = [];  }   if ( Element$$1 ) Form.__proto__ = Element$$1;  Form.prototype = Object.create( Element$$1 && Element$$1.prototype );  Form.prototype.constructor = Form;   Form.prototype.render = function render ( target, occupants ) {   Element$$1.prototype.render.call( this, target, occupants );   this.node.addEventListener( 'reset', handleReset, false );  };   Form.prototype.unrender = function unrender ( shouldDestroy ) {   this.node.removeEventListener( 'reset', handleReset, false );   Element$$1.prototype.unrender.call( this, shouldDestroy );  };   return Form; }(Element));  function handleReset () {  var element = this._ractive.proxy;   runloop.start();  element.formBindings.forEach( updateModel );  runloop.end(); }  function updateModel ( binding ) {  binding.model.set( binding.resetValue ); }  function progressiveText ( item, target, occupants, text ) {  if ( occupants ) {   var n = occupants[0];   if ( n && n.nodeType === 3 ) {    var idx = n.nodeValue.indexOf( text );    occupants.shift();     if ( idx === 0 ) {     if ( n.nodeValue.length !== text.length ) {      occupants.unshift( n.splitText( text.length ) );     }    } else {     n.nodeValue = text;    }   } else {    n = item.node = doc.createTextNode( text );    if ( occupants[0] ) {     target.insertBefore( n, occupants[0] );    } else {     target.appendChild( n );    }   }    item.node = n;  } else {   if ( !item.node ) { item.node = doc.createTextNode( text ); }   target.appendChild( item.node );  } }  var Mustache = (function (Item$$1) {  function Mustache ( options ) {   Item$$1.call( this, options );    this.parentFragment = options.parentFragment;   this.template = options.template;   this.index = options.index;   if ( options.owner ) { this.parent = options.owner; }    this.isStatic = !!options.template.s;    this.model = null;   this.dirty = false;  }   if ( Item$$1 ) Mustache.__proto__ = Item$$1;  Mustache.prototype = Object.create( Item$$1 && Item$$1.prototype );  Mustache.prototype.constructor = Mustache;   Mustache.prototype.bind = function bind () {   // yield mustaches should resolve in container context   var start = this.containerFragment || this.parentFragment;   // try to find a model for this view   var model = resolve( start, this.template );    if ( model ) {    var value = model.get();     if ( this.isStatic ) {     this.model = { get: function () { return value; } };     return;    }     model.register( this );    this.model = model;   }  };   Mustache.prototype.handleChange = function handleChange () {   this.bubble();  };   Mustache.prototype.rebind = function rebind ( next, previous, safe ) {   next = rebindMatch( this.template, next, previous, this.parentFragment );   if ( next === this.model ) { return false; }    if ( this.model ) {    this.model.unregister( this );   }   if ( next ) { next.addShuffleRegister( this, 'mark' ); }   this.model = next;   if ( !safe ) { this.handleChange(); }   return true;  };   Mustache.prototype.unbind = function unbind () {   if ( !this.isStatic ) {    this.model && this.model.unregister( this );    this.model = undefined;   }  };   return Mustache; }(Item));  var MustacheContainer = (function (ContainerItem$$1) {  function MustacheContainer ( options ) {   ContainerItem$$1.call( this, options );  }   if ( ContainerItem$$1 ) MustacheContainer.__proto__ = ContainerItem$$1;  MustacheContainer.prototype = Object.create( ContainerItem$$1 && ContainerItem$$1.prototype );  MustacheContainer.prototype.constructor = MustacheContainer;   return MustacheContainer; }(ContainerItem)); var proto$2 = MustacheContainer.prototype; var mustache = Mustache.prototype; proto$2.bind = mustache.bind; proto$2.handleChange = mustache.handleChange; proto$2.rebind = mustache.rebind; proto$2.unbind = mustache.unbind;  var Interpolator = (function (Mustache$$1) {  function Interpolator () {   Mustache$$1.apply(this, arguments);  }   if ( Mustache$$1 ) Interpolator.__proto__ = Mustache$$1;  Interpolator.prototype = Object.create( Mustache$$1 && Mustache$$1.prototype );  Interpolator.prototype.constructor = Interpolator;   Interpolator.prototype.bubble = function bubble () {   if ( this.owner ) { this.owner.bubble(); }   Mustache$$1.prototype.bubble.call(this);  };   Interpolator.prototype.detach = function detach () {   return detachNode( this.node );  };   Interpolator.prototype.firstNode = function firstNode () {   return this.node;  };   Interpolator.prototype.getString = function getString () {   return this.model ? safeToStringValue( this.model.get() ) : ; };   Interpolator.prototype.render = function render ( target, occupants ) {   if ( inAttributes() ) { return; }   var value = this.getString();    this.rendered = true;    progressiveText( this, target, occupants, value );  };   Interpolator.prototype.toString = function toString ( escape ) {   var string = this.getString();   return escape ? escapeHtml( string ) : string;  };   Interpolator.prototype.unrender = function unrender ( shouldDestroy ) {   if ( shouldDestroy ) { this.detach(); }   this.rendered = false;  };   Interpolator.prototype.update = function update () {   if ( this.dirty ) {    this.dirty = false;    if ( this.rendered ) {     this.node.data = this.getString();    }   }  };   Interpolator.prototype.valueOf = function valueOf () {   return this.model ? this.model.get() : undefined;  };   return Interpolator; }(Mustache));  var Input = (function (Element$$1) {  function Input () {   Element$$1.apply(this, arguments);  }   if ( Element$$1 ) Input.__proto__ = Element$$1;  Input.prototype = Object.create( Element$$1 && Element$$1.prototype );  Input.prototype.constructor = Input;   Input.prototype.render = function render ( target, occupants ) {   Element$$1.prototype.render.call( this, target, occupants );   this.node.defaultValue = this.node.value;  };  Input.prototype.compare = function compare ( value, attrValue ) {   var comparator = this.getAttribute( 'value-comparator' );   if ( comparator ) {    if ( typeof comparator === 'function' ) {     return comparator( value, attrValue );    }    if (value && attrValue) {     return value[comparator] == attrValue[comparator];    }   }   return value == attrValue;  };   return Input; }(Element));  // simple JSON parser, without the restrictions of JSON parse // (i.e. having to double-quote keys). // // If passed a hash of values as the second argument, ${placeholders} // will be replaced with those values  var specials$1 = {  true: true,  false: false,  null: null,  undefined: undefined };  var specialsPattern = new RegExp( '^(?:' + Object.keys( specials$1 ).join( '|' ) + ')' ); var numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/; var placeholderPattern = /\$\{([^\}]+)\}/g; var placeholderAtStartPattern = /^\$\{([^\}]+)\}/; var onlyWhitespace = /^\s*$/;  var JsonParser = Parser.extend({  init: function init ( str, options ) {   this.values = options.values;   this.allowWhitespace();  },   postProcess: function postProcess ( result ) {   if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {    return null;   }    return { value: result[0].v };  },   converters: [   function getPlaceholder ( parser ) {    if ( !parser.values ) { return null; }     var placeholder = parser.matchPattern( placeholderAtStartPattern );     if ( placeholder && ( parser.values.hasOwnProperty( placeholder ) ) ) {     return { v: parser.values[ placeholder ] };    }   },    function getSpecial ( parser ) {    var special = parser.matchPattern( specialsPattern );    if ( special ) { return { v: specials$1[ special ] }; }   },    function getNumber ( parser ) {    var number = parser.matchPattern( numberPattern$1 );    if ( number ) { return { v: +number }; }   },    function getString ( parser ) {    var stringLiteral = readStringLiteral( parser );    var values = parser.values;     if ( stringLiteral && values ) {     return {      v: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) { return ( $1 in values ? values[ $1 ] : $1 ); } )     };    }     return stringLiteral;   },    function getObject ( parser ) {    if ( !parser.matchString( '{' ) ) { return null; }     var result = {};     parser.allowWhitespace();     if ( parser.matchString( '}' ) ) {     return { v: result };    }     var pair;    while ( pair = getKeyValuePair( parser ) ) {     result[ pair.key ] = pair.value;      parser.allowWhitespace();      if ( parser.matchString( '}' ) ) {      return { v: result };     }      if ( !parser.matchString( ',' ) ) {      return null;     }    }     return null;   },    function getArray ( parser ) {    if ( !parser.matchString( '[' ) ) { return null; }     var result = [];     parser.allowWhitespace();     if ( parser.matchString( ']' ) ) {     return { v: result };    }     var valueToken;    while ( valueToken = parser.read() ) {     result.push( valueToken.v );      parser.allowWhitespace();      if ( parser.matchString( ']' ) ) {      return { v: result };     }      if ( !parser.matchString( ',' ) ) {      return null;     }      parser.allowWhitespace();    }     return null;   }  ] });  function getKeyValuePair ( parser ) {  parser.allowWhitespace();   var key = readKey( parser );   if ( !key ) { return null; }   var pair = { key: key };   parser.allowWhitespace();  if ( !parser.matchString( ':' ) ) {   return null;  }  parser.allowWhitespace();   var valueToken = parser.read();   if ( !valueToken ) { return null; }   pair.value = valueToken.v;  return pair; }  var parseJSON = function ( str, values ) {  var parser = new JsonParser( str, { values: values });  return parser.result; };  var Mapping = (function (Item$$1) {  function Mapping ( options ) {   Item$$1.call( this, options );    this.name = options.template.n;    this.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );   this.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );   this.parentFragment = this.element.parentFragment; // shared   this.ractive = this.parentFragment.ractive;    this.fragment = null;    this.element.attributeByName[ this.name ] = this;    this.value = options.template.f;  }   if ( Item$$1 ) Mapping.__proto__ = Item$$1;  Mapping.prototype = Object.create( Item$$1 && Item$$1.prototype );  Mapping.prototype.constructor = Mapping;   Mapping.prototype.bind = function bind () {   if ( this.fragment ) {    this.fragment.bind();   }    var template = this.template.f;   var viewmodel = this.element.instance.viewmodel;    if ( template === 0 ) {    // empty attributes are `true`    viewmodel.joinKey( this.name ).set( true );   }    else if ( typeof template === 'string' ) {    var parsed = parseJSON( template );    viewmodel.joinKey( this.name ).set( parsed ? parsed.value : template );   }    else if ( Array.isArray( template ) ) {    createMapping( this, true );   }  };   Mapping.prototype.render = function render () {};   Mapping.prototype.unbind = function unbind () {   if ( this.fragment ) { this.fragment.unbind(); }   if ( this.model ) { this.model.unregister( this ); }   if ( this.boundFragment ) { this.boundFragment.unbind(); }    if ( this.element.bound ) {    if ( this.link.target === this.model ) { this.link.owner.unlink(); }   }  };   Mapping.prototype.unrender = function unrender () {};   Mapping.prototype.update = function update () {   if ( this.dirty ) {    this.dirty = false;    if ( this.fragment ) { this.fragment.update(); }    if ( this.boundFragment ) { this.boundFragment.update(); }    if ( this.rendered ) { this.updateDelegate(); }   }  };   return Mapping; }(Item));  function createMapping ( item ) {  var template = item.template.f;  var viewmodel = item.element.instance.viewmodel;  var childData = viewmodel.value;   if ( template.length === 1 && template[0].t === INTERPOLATOR ) {   var model = resolve( item.parentFragment, template[0] );   var val = model.get( false );    // if the interpolator is not static   if ( !template[0].s ) {    item.model = model;    item.link = viewmodel.createLink( item.name, model, template[0].r );     // initialize parent side of the mapping from child data    if ( val === undefined && !model.isReadonly && item.name in childData ) {     model.set( childData[ item.name ] );    }   }    // copy non-object, non-computed vals through   else if ( typeof val !== 'object' || template[0].x ) {    viewmodel.joinKey( item.name ).set( val );   }    // warn about trying to copy an object   else {    warnIfDebug( ("Cannot copy non-computed object value from static mapping '" + (item.name) + "'") );   }  }   else {   item.boundFragment = new Fragment({    owner: item,    template: template   }).bind();    item.model = viewmodel.joinKey( item.name );   item.model.set( item.boundFragment.valueOf() );    // item is a *bit* of a hack   item.boundFragment.bubble = function () {    Fragment.prototype.bubble.call( item.boundFragment );    // defer this to avoid mucking around model deps if there happens to be an expression involved    runloop.scheduleTask(function () {     item.boundFragment.update();     item.model.set( item.boundFragment.valueOf() );    });   };  } }  var Option = (function (Element$$1) {  function Option ( options ) {   var template = options.template;   if ( !template.a ) { template.a = {}; }    // If the value attribute is missing, use the element's content,   // as long as it isn't disabled   if ( template.a.value === undefined && !( 'disabled' in template.a ) ) {    template.a.value = template.f || ; }    Element$$1.call( this, options );    this.select = findElement( this.parent || this.parentFragment, false, 'select' );  }   if ( Element$$1 ) Option.__proto__ = Element$$1;  Option.prototype = Object.create( Element$$1 && Element$$1.prototype );  Option.prototype.constructor = Option;   Option.prototype.bind = function bind () {   if ( !this.select ) {    Element$$1.prototype.bind.call(this);    return;   }    // If the select has a value, it overrides the `selected` attribute on   // this option - so we delete the attribute   var selectedAttribute = this.attributeByName.selected;   if ( selectedAttribute && this.select.getAttribute( 'value' ) !== undefined ) {    var index = this.attributes.indexOf( selectedAttribute );    this.attributes.splice( index, 1 );    delete this.attributeByName.selected;   }    Element$$1.prototype.bind.call(this);   this.select.options.push( this );  };   Option.prototype.bubble = function bubble () {   // if we're using content as value, may need to update here   var value = this.getAttribute( 'value' );   if ( this.node && this.node.value !== value ) {    this.node._ractive.value = value;   }   Element$$1.prototype.bubble.call(this);  };   Option.prototype.getAttribute = function getAttribute ( name ) {   var attribute = this.attributeByName[ name ];   return attribute ? attribute.getValue() : name === 'value' && this.fragment ? this.fragment.valueOf() : undefined;  };   Option.prototype.isSelected = function isSelected () {   var this$1 = this;    var optionValue = this.getAttribute( 'value' );    if ( optionValue === undefined || !this.select ) {    return false;   }    var selectValue = this.select.getAttribute( 'value' );    if ( this.select.compare( selectValue, optionValue ) ) {    return true;   }    if ( this.select.getAttribute( 'multiple' ) && Array.isArray( selectValue ) ) {    var i = selectValue.length;    while ( i-- ) {     if ( this$1.select.compare( selectValue[i], optionValue ) ) {      return true;     }    }   }  };   Option.prototype.render = function render ( target, occupants ) {   Element$$1.prototype.render.call( this, target, occupants );    if ( !this.attributeByName.value ) {    this.node._ractive.value = this.getAttribute( 'value' );   }  };   Option.prototype.unbind = function unbind () {   Element$$1.prototype.unbind.call(this);    if ( this.select ) {    removeFromArray( this.select.options, this );   }  };   return Option; }(Element));  function getPartialTemplate ( ractive, name, parentFragment ) {  // If the partial in instance or view heirarchy instances, great  var partial = getPartialFromRegistry( ractive, name, parentFragment || {} );  if ( partial ) { return partial; }   // Does it exist on the page as a script tag?  partial = parser.fromId( name, { noThrow: true } );  if ( partial ) {   // parse and register to this ractive instance   var parsed = parser.parseFor( partial, ractive );    // register extra partials on the ractive instance if they don't already exist   if ( parsed.p ) { fillGaps( ractive.partials, parsed.p ); }    // register (and return main partial if there are others in the template)   return ractive.partials[ name ] = parsed.t;  } }  function getPartialFromRegistry ( ractive, name, parentFragment ) {  // if there was an instance up-hierarchy, cool  var partial = findParentPartial( name, parentFragment.owner );  if ( partial ) { return partial; }   // find first instance in the ractive or view hierarchy that has this partial  var instance = findInstance( 'partials', ractive, name );   if ( !instance ) { return; }   partial = instance.partials[ name ];   // partial is a function?  var fn;  if ( typeof partial === 'function' ) {   fn = partial.bind( instance );   fn.isOwner = instance.partials.hasOwnProperty(name);   partial = fn.call( ractive, parser );  }   if ( !partial && partial !== ) { warnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive: ractive });   return;  }   // If this was added manually to the registry,  // but hasn't been parsed, parse it now  if ( !parser.isParsed( partial ) ) {   // use the parseOptions of the ractive instance on which it was found   var parsed = parser.parseFor( partial, instance );    // Partials cannot contain nested partials!   // TODO add a test for this   if ( parsed.p ) {    warnIfDebug( 'Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });   }    // if fn, use instance to store result, otherwise needs to go   // in the correct point in prototype chain on instance or constructor   var target = fn ? instance : findOwner( instance, name );    // may be a template with partials, which need to be registered and main template extracted   target.partials[ name ] = partial = parsed.t;  }   // store for reset  if ( fn ) { partial._fn = fn; }   return partial.v ? partial.t : partial; }  function findOwner ( ractive, key ) {  return ractive.partials.hasOwnProperty( key )   ? ractive   : findConstructor( ractive.constructor, key); }  function findConstructor ( constructor, key ) {  if ( !constructor ) { return; }  return constructor.partials.hasOwnProperty( key )   ? constructor   : findConstructor( constructor._Parent, key ); }  function findParentPartial( name, parent ) {  if ( parent ) {   if ( parent.template && parent.template.p && parent.template.p[name] ) {    return parent.template.p[name];   } else if ( parent.parentFragment && parent.parentFragment.owner ) {    return findParentPartial( name, parent.parentFragment.owner );   }  } }  var Partial = (function (MustacheContainer$$1) {  function Partial ( options ) {   MustacheContainer$$1.call( this, options );    this.yielder = options.template.t === YIELDER;    if ( this.yielder ) {    this.container = options.parentFragment.ractive;    this.component = this.container.component;     this.containerFragment = options.parentFragment;    this.parentFragment = this.component.parentFragment;     // Template:Yield is equivalent to Template:Yield content if ( !options.template.r && !options.template.rx && !options.template.x ) { options.template.r = 'content'; }   }  }   if ( MustacheContainer$$1 ) Partial.__proto__ = MustacheContainer$$1;  Partial.prototype = Object.create( MustacheContainer$$1 && MustacheContainer$$1.prototype );  Partial.prototype.constructor = Partial;   Partial.prototype.bind = function bind () {   var this$1 = this;    // keep track of the reference name for future resets   this.refName = this.template.r;    // name matches take priority over expressions   var template = this.refName ? getPartialTemplate( this.ractive, this.refName, this.parentFragment ) || null : null;   var templateObj;    if ( template ) {    this.named = true;    this.setTemplate( this.template.r, template );   }    if ( !template ) {    MustacheContainer$$1.prototype.bind.call(this);    if ( ( templateObj = this.model.get() ) && typeof templateObj === 'object' && ( typeof templateObj.template === 'string' || Array.isArray( templateObj.t ) ) ) {     if ( templateObj.template ) {      this.source = templateObj.template;      templateObj = parsePartial( this.template.r, templateObj.template, this.ractive );     } else {      this.source = templateObj.t;     }     this.setTemplate( this.template.r, templateObj.t );    } else if ( typeof this.model.get() !== 'string' && this.refName ) {     this.setTemplate( this.refName, template );    } else {     this.setTemplate( this.model.get() );    }   }    var options = {    owner: this,    template: this.partialTemplate   };    if ( this.template.c ) {    options.template = [{ t: SECTION, n: SECTION_WITH, f: options.template }];    for ( var k in this$1.template.c ) {     options.template[0][k] = this$1.template.c[k];    }   }    if ( this.yielder ) {    options.ractive = this.container.parent;   }    this.fragment = new Fragment(options);   if ( this.template.z ) {    this.fragment.aliases = resolveAliases( this.template.z, this.yielder ? this.containerFragment : this.parentFragment );   }   this.fragment.bind();  };   Partial.prototype.bubble = function bubble () { if ( this.yielder && !this.dirty ) {    this.containerFragment.bubble();    this.dirty = true;   } else {    MustacheContainer$$1.prototype.bubble.call(this);   }  };   Partial.prototype.findNextNode = function findNextNode () {   return this.yielder ? this.containerFragment.findNextNode( this ) : MustacheContainer$$1.prototype.findNextNode.call(this);  };   Partial.prototype.forceResetTemplate = function forceResetTemplate () {   var this$1 = this;    this.partialTemplate = undefined;    // on reset, check for the reference name first   if ( this.refName ) {    this.partialTemplate = getPartialTemplate( this.ractive, this.refName, this.parentFragment );   }    // then look for the resolved name   if ( !this.partialTemplate ) {    this.partialTemplate = getPartialTemplate( this.ractive, this.name, this.parentFragment );   }    if ( !this.partialTemplate ) {    warnOnceIfDebug( ("Could not find template for partial '" + (this.name) + "'") );    this.partialTemplate = [];   }    if ( this.inAttribute ) {    doInAttributes( function () { return this$1.fragment.resetTemplate( this$1.partialTemplate ); } );   } else {    this.fragment.resetTemplate( this.partialTemplate );   }    this.bubble();  };   Partial.prototype.render = function render ( target, occupants ) {   return this.fragment.render( target, occupants );  };   Partial.prototype.setTemplate = function setTemplate ( name, template ) {   this.name = name;    if ( !template && template !== null ) { template = getPartialTemplate( this.ractive, name, this.parentFragment ); }    if ( !template ) {    warnOnceIfDebug( ("Could not find template for partial '" + name + "'") );   }    this.partialTemplate = template || [];  };   Partial.prototype.unbind = function unbind () {   MustacheContainer$$1.prototype.unbind.call(this);   this.fragment.aliases = {};   this.fragment.unbind();  };   Partial.prototype.unrender = function unrender ( shouldDestroy ) {   this.fragment.unrender( shouldDestroy );  };   Partial.prototype.update = function update () {   var template;    if ( this.dirty ) {    this.dirty = false;     if ( !this.named ) {     if ( this.model ) {      template = this.model.get();     }      if ( template && typeof template === 'string' && template !== this.name ) {      this.setTemplate( template );      this.fragment.resetTemplate( this.partialTemplate );     } else if ( template && typeof template === 'object' && ( typeof template.template === 'string' || Array.isArray( template.t ) ) ) {      if ( template.t !== this.source && template.template !== this.source ) {       if ( template.template ) {        this.source = template.template;        template = parsePartial( this.name, template.template, this.ractive );       } else {        this.source = template.t;       }       this.setTemplate( this.name, template.t );       this.fragment.resetTemplate( this.partialTemplate );      }     }    }     this.fragment.update();   }  };   return Partial; }(MustacheContainer));  function parsePartial( name, partial, ractive ) {  var parsed;   try {   parsed = parser.parse( partial, parser.getParseOptions( ractive ) );  } catch (e) {   warnIfDebug( ("Could not parse partial from expression '" + name + "'\n" + (e.message)) );  }   return parsed || { t: [] }; }  var RepeatedFragment = function RepeatedFragment ( options ) {  this.parent = options.owner.parentFragment;   // bit of a hack, so reference resolution works without another  // layer of indirection  this.parentFragment = this;  this.owner = options.owner;  this.ractive = this.parent.ractive;  this.delegate = this.parent.delegate || findElement( options.owner );  // delegation disabled by directive  if ( this.delegate && this.delegate.delegate === false ) { this.delegate = false; }   // encapsulated styles should be inherited until they get applied by an element  this.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );   this.context = null;  this.rendered = false;  this.iterations = [];   this.template = options.template;   this.indexRef = options.indexRef;  this.keyRef = options.keyRef;   this.pendingNewIndices = null;  this.previousIterations = null;   // track array versus object so updates of type rest  this.isArray = false; };  RepeatedFragment.prototype.bind = function bind$$1 ( context ) {   var this$1 = this;   this.context = context;  var value = context.get();   // {{#each array}}...  if ( this.isArray = Array.isArray( value ) ) {   // we can't use map, because of sparse arrays   this.iterations = [];   var max = value.length;   for ( var i = 0; i < max; i += 1 ) {    this$1.iterations[i] = this$1.createIteration( i, i );   }  }   // {{#each object}}...  else if ( isObject( value ) ) {   this.isArray = false;    // TODO this is a dreadful hack. There must be a neater way   if ( this.indexRef ) {    var refs = this.indexRef.split( ',' );    this.keyRef = refs[0];    this.indexRef = refs[1];   }    this.iterations = Object.keys( value ).map( function ( key, index ) {    return this$1.createIteration( key, index );   });  }   return this; };  RepeatedFragment.prototype.bubble = function bubble ( index ) {  if  ( !this.bubbled ) { this.bubbled = []; }  this.bubbled.push( index );   this.owner.bubble(); };  RepeatedFragment.prototype.createIteration = function createIteration ( key, index ) {  var fragment = new Fragment({   owner: this,   template: this.template  });   fragment.key = key;  fragment.index = index;  fragment.isIteration = true;  fragment.delegate = this.delegate;   var model = this.context.joinKey( key );   // set up an iteration alias if there is one  if ( this.owner.template.z ) {   fragment.aliases = {};   fragment.aliases[ this.owner.template.z[0].n ] = model;  }   return fragment.bind( model ); };  RepeatedFragment.prototype.destroyed = function destroyed$1 () {  this.iterations.forEach( destroyed ); };  RepeatedFragment.prototype.detach = function detach () {  var docFrag = createDocumentFragment();  this.iterations.forEach( function (fragment) { return docFrag.appendChild( fragment.detach() ); } );  return docFrag; };  RepeatedFragment.prototype.find = function find ( selector, options ) {  return findMap( this.iterations, function (i) { return i.find( selector, options ); } ); };  RepeatedFragment.prototype.findAll = function findAll ( selector, options ) {  return this.iterations.forEach( function (i) { return i.findAll( selector, options ); } ); };  RepeatedFragment.prototype.findComponent = function findComponent ( name, options ) {  return findMap( this.iterations, function (i) { return i.findComponent( name, options ); } ); };  RepeatedFragment.prototype.findAllComponents = function findAllComponents ( name, options ) {  return this.iterations.forEach( function (i) { return i.findAllComponents( name, options ); } ); };  RepeatedFragment.prototype.findNextNode = function findNextNode ( iteration ) {   var this$1 = this;   if ( iteration.index < this.iterations.length - 1 ) {   for ( var i = iteration.index + 1; i < this.iterations.length; i++ ) {    var node = this$1.iterations[ i ].firstNode( true );    if ( node ) { return node; }   }  }   return this.owner.findNextNode(); };  RepeatedFragment.prototype.firstNode = function firstNode ( skipParent ) {  return this.iterations[0] ? this.iterations[0].firstNode( skipParent ) : null; };  RepeatedFragment.prototype.rebind = function rebind ( next ) {   var this$1 = this;   this.context = next;  this.iterations.forEach( function (fragment) {   var model = next ? next.joinKey( fragment.key ) : undefined;   fragment.context = model;   if ( this$1.owner.template.z ) {    fragment.aliases = {};    fragment.aliases[ this$1.owner.template.z[0].n ] = model;   }  }); };  RepeatedFragment.prototype.render = function render$$1 ( target, occupants ) {  // TODO use docFrag.cloneNode...   var xs = this.iterations;  if ( xs ) {   var len = xs.length;   for ( var i = 0; i < len; i++ ) {    xs[i].render( target, occupants );   }  }   this.rendered = true; };  RepeatedFragment.prototype.shuffle = function shuffle ( newIndices ) {   var this$1 = this;   if ( !this.pendingNewIndices ) { this.previousIterations = this.iterations.slice(); }   if ( !this.pendingNewIndices ) { this.pendingNewIndices = []; }   this.pendingNewIndices.push( newIndices );   var iterations = [];   newIndices.forEach( function ( newIndex, oldIndex ) {   if ( newIndex === -1 ) { return; }    var fragment = this$1.iterations[ oldIndex ];   iterations[ newIndex ] = fragment;    if ( newIndex !== oldIndex && fragment ) { fragment.dirty = true; }  });   this.iterations = iterations;   this.bubble(); };  RepeatedFragment.prototype.shuffled = function shuffled$1 () {  this.iterations.forEach( shuffled ); };  RepeatedFragment.prototype.toString = function toString$1$$1 ( escape ) {  return this.iterations ?   this.iterations.map( escape ? toEscapedString : toString$1 ).join( ) : ; };  RepeatedFragment.prototype.unbind = function unbind$1 () {  this.iterations.forEach( unbind );  return this; };  RepeatedFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {  this.iterations.forEach( shouldDestroy ? unrenderAndDestroy : unrender );  if ( this.pendingNewIndices && this.previousIterations ) {   this.previousIterations.forEach( function (fragment) {    if ( fragment.rendered ) { shouldDestroy ? unrenderAndDestroy( fragment ) : unrender( fragment ); }   });  }  this.rendered = false; };  // TODO smart update RepeatedFragment.prototype.update = function update$1 () {   var this$1 = this;   // skip dirty check, since this is basically just a facade   if ( this.pendingNewIndices ) {   this.bubbled.length = 0;   this.updatePostShuffle();   return;  }   if ( this.updating ) { return; }  this.updating = true;   var value = this.context.get();  var wasArray = this.isArray;   var toRemove;  var oldKeys;  var reset = true;  var i;   if ( this.isArray = Array.isArray( value ) ) {   if ( wasArray ) {    reset = false;    if ( this.iterations.length > value.length ) {     toRemove = this.iterations.splice( value.length );    }   }  } else if ( isObject( value ) && !wasArray ) {   reset = false;   toRemove = [];   oldKeys = {};   i = this.iterations.length;    while ( i-- ) {    var fragment$1 = this$1.iterations[i];    if ( fragment$1.key in value ) {     oldKeys[ fragment$1.key ] = true;    } else {     this$1.iterations.splice( i, 1 );     toRemove.push( fragment$1 );    }   }  }   if ( reset ) {   toRemove = this.iterations;   this.iterations = [];  }   if ( toRemove ) {   toRemove.forEach( function (fragment) {    fragment.unbind();    fragment.unrender( true );   });  }   // update the remaining ones  if ( !reset && this.isArray && this.bubbled && this.bubbled.length ) {   this.bubbled.forEach( function (i) { return this$1.iterations[i] && this$1.iterations[i].update(); } );  } else {   this.iterations.forEach( update );  }   if ( this.bubbled ) { this.bubbled.length = 0; }   // add new iterations  var newLength = Array.isArray( value ) ?   value.length :   isObject( value ) ?    Object.keys( value ).length :    0;   var docFrag;  var fragment;   if ( newLength > this.iterations.length ) {   docFrag = this.rendered ? createDocumentFragment() : null;   i = this.iterations.length;    if ( Array.isArray( value ) ) {    while ( i < value.length ) {     fragment = this$1.createIteration( i, i );      this$1.iterations.push( fragment );     if ( this$1.rendered ) { fragment.render( docFrag ); }      i += 1;    }   }    else if ( isObject( value ) ) {    // TODO this is a dreadful hack. There must be a neater way    if ( this.indexRef && !this.keyRef ) {     var refs = this.indexRef.split( ',' );     this.keyRef = refs[0];     this.indexRef = refs[1];    }     Object.keys( value ).forEach( function (key) {     if ( !oldKeys || !( key in oldKeys ) ) {      fragment = this$1.createIteration( key, i );       this$1.iterations.push( fragment );      if ( this$1.rendered ) { fragment.render( docFrag ); }       i += 1;     }    });   }    if ( this.rendered ) {    var parentNode = this.parent.findParentNode();    var anchor = this.parent.findNextNode( this.owner );     parentNode.insertBefore( docFrag, anchor );   }  }   this.updating = false; };  RepeatedFragment.prototype.updatePostShuffle = function updatePostShuffle () {   var this$1 = this;   var newIndices = this.pendingNewIndices[ 0 ];   // map first shuffle through  this.pendingNewIndices.slice( 1 ).forEach( function (indices) {   newIndices.forEach( function ( newIndex, oldIndex ) {    newIndices[ oldIndex ] = indices[ newIndex ];   });  });   // This algorithm (for detaching incorrectly-ordered fragments from the DOM and  // storing them in a document fragment for later reinsertion) seems a bit hokey,  // but it seems to work for now  var len = this.context.get().length;  var oldLen = this.previousIterations.length;  var removed = {};  var i;   newIndices.forEach( function ( newIndex, oldIndex ) {   var fragment = this$1.previousIterations[ oldIndex ];   this$1.previousIterations[ oldIndex ] = null;    if ( newIndex === -1 ) {    removed[ oldIndex ] = fragment;   } else if ( fragment.index !== newIndex ) {    var model = this$1.context.joinKey( newIndex );    fragment.index = fragment.key = newIndex;    fragment.context = model;    if ( this$1.owner.template.z ) {     fragment.aliases = {};     fragment.aliases[ this$1.owner.template.z[0].n ] = model;    }   }  });   // if the array was spliced outside of ractive, sometimes there are leftover fragments not in the newIndices  this.previousIterations.forEach( function ( frag, i ) {   if ( frag ) { removed[ i ] = frag; }  });   // create new/move existing iterations  var docFrag = this.rendered ? createDocumentFragment() : null;  var parentNode = this.rendered ? this.parent.findParentNode() : null;   var contiguous = 'startIndex' in newIndices;  i = contiguous ? newIndices.startIndex : 0;   for ( i; i < len; i++ ) {   var frag = this$1.iterations[i];    if ( frag && contiguous ) {    // attach any built-up iterations    if ( this$1.rendered ) {     if ( removed[i] ) { docFrag.appendChild( removed[i].detach() ); }     if ( docFrag.childNodes.length  ) { parentNode.insertBefore( docFrag, frag.firstNode() ); }    }    continue;   }    if ( !frag ) { this$1.iterations[i] = this$1.createIteration( i, i ); }    if ( this$1.rendered ) {    if ( removed[i] ) { docFrag.appendChild( removed[i].detach() ); }     if ( frag ) { docFrag.appendChild( frag.detach() ); }    else {     this$1.iterations[i].render( docFrag );    }   }  }   // append any leftovers  if ( this.rendered ) {   for ( i = len; i < oldLen; i++ ) {    if ( removed[i] ) { docFrag.appendChild( removed[i].detach() ); }   }    if ( docFrag.childNodes.length ) {    parentNode.insertBefore( docFrag, this.owner.findNextNode() );   }  }   // trigger removal on old nodes  Object.keys( removed ).forEach( function (k) { return removed[k].unbind().unrender( true ); } );   this.iterations.forEach( update );   this.pendingNewIndices = null;   this.shuffled(); };  function isEmpty ( value ) {  return !value ||         ( Array.isArray( value ) && value.length === 0 ) ||      ( isObject( value ) && Object.keys( value ).length === 0 ); }  function getType ( value, hasIndexRef ) {  if ( hasIndexRef || Array.isArray( value ) ) { return SECTION_EACH; }  if ( isObject( value ) || typeof value === 'function' ) { return SECTION_IF_WITH; }  if ( value === undefined ) { return null; }  return SECTION_IF; }  var Section = (function (MustacheContainer$$1) {  function Section ( options ) {   MustacheContainer$$1.call( this, options );    this.sectionType = options.template.n || null;   this.templateSectionType = this.sectionType;   this.subordinate = options.template.l === 1;   this.fragment = null;  }   if ( MustacheContainer$$1 ) Section.__proto__ = MustacheContainer$$1;  Section.prototype = Object.create( MustacheContainer$$1 && MustacheContainer$$1.prototype );  Section.prototype.constructor = Section;   Section.prototype.bind = function bind () {   MustacheContainer$$1.prototype.bind.call(this);    if ( this.subordinate ) {    this.sibling = this.parentFragment.items[ this.parentFragment.items.indexOf( this ) - 1 ];    this.sibling.nextSibling = this;   }    // if we managed to bind, we need to create children   if ( this.model ) {    this.dirty = true;    this.update();   } else if ( this.sectionType && this.sectionType === SECTION_UNLESS && ( !this.sibling || !this.sibling.isTruthy() ) ) {    this.fragment = new Fragment({     owner: this,     template: this.template.f    }).bind();   }  };   Section.prototype.detach = function detach () {   var frag = this.fragment || this.detached;   return frag ? frag.detach() : MustacheContainer$$1.prototype.detach.call(this);  };   Section.prototype.isTruthy = function isTruthy () {   if ( this.subordinate && this.sibling.isTruthy() ) { return true; }   var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();   return !!value && ( this.templateSectionType === SECTION_IF_WITH || !isEmpty( value ) );  };   Section.prototype.rebind = function rebind ( next, previous, safe ) {   if ( MustacheContainer$$1.prototype.rebind.call( this, next, previous, safe ) ) {    if ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {     this.fragment.rebind( next );    }   }  };   Section.prototype.render = function render ( target, occupants ) {   this.rendered = true;   if ( this.fragment ) { this.fragment.render( target, occupants ); }  };   Section.prototype.shuffle = function shuffle ( newIndices ) {   if ( this.fragment && this.sectionType === SECTION_EACH ) {    this.fragment.shuffle( newIndices );   }  };   Section.prototype.unbind = function unbind () {   MustacheContainer$$1.prototype.unbind.call(this);   if ( this.fragment ) { this.fragment.unbind(); }  };   Section.prototype.unrender = function unrender ( shouldDestroy ) {   if ( this.rendered && this.fragment ) { this.fragment.unrender( shouldDestroy ); }   this.rendered = false;  };   Section.prototype.update = function update () {   var this$1 = this;    if ( !this.dirty ) { return; }    if ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {    this.fragment.context = this.model;   }    if ( !this.model && this.sectionType !== SECTION_UNLESS ) { return; }    this.dirty = false;    var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();   var siblingFalsey = !this.subordinate || !this.sibling.isTruthy();   var lastType = this.sectionType;    // watch for switching section types   if ( this.sectionType === null || this.templateSectionType === null ) { this.sectionType = getType( value, this.template.i ); }   if ( lastType && lastType !== this.sectionType && this.fragment ) {    if ( this.rendered ) {     this.fragment.unbind().unrender( true );    }     this.fragment = null;   }    var newFragment;    var fragmentShouldExist = this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations                               this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment                               ( siblingFalsey && ( this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy() ) ); // if, unless, and if-with depend on siblings and the condition    if ( fragmentShouldExist ) {    if ( !this.fragment ) { this.fragment = this.detached; }     if ( this.fragment ) {     // check for detached fragment     if ( this.detached ) {      attach( this, this.fragment );      this.detached = false;      this.rendered = true;     }      this.fragment.update();    } else {     if ( this.sectionType === SECTION_EACH ) {      newFragment = new RepeatedFragment({       owner: this,       template: this.template.f,       indexRef: this.template.i      }).bind( this.model );     } else {      // only with and if-with provide context - if and unless do not      var context = this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ? this.model : null;      newFragment = new Fragment({       owner: this,       template: this.template.f      }).bind( context );     }    }   } else {    if ( this.fragment && this.rendered ) {     if ( keep !== true ) {      this.fragment.unbind().unrender( true );     } else {      this.unrender( false );      this.detached = this.fragment;      runloop.scheduleTask( function () { return this$1.detach(); } );     }    } else if ( this.fragment ) {     this.fragment.unbind();    }     this.fragment = null;   }    if ( newFragment ) {    if ( this.rendered ) {     attach( this, newFragment );    }     this.fragment = newFragment;   }    if ( this.nextSibling ) {    this.nextSibling.dirty = true;    this.nextSibling.update();   }  };   return Section; }(MustacheContainer));  function attach ( section, fragment ) {  var anchor = section.parentFragment.findNextNode( section );   if ( anchor ) {   var docFrag = createDocumentFragment();   fragment.render( docFrag );    anchor.parentNode.insertBefore( docFrag, anchor );  } else {   fragment.render( section.parentFragment.findParentNode() );  } }  var Select = (function (Element$$1) {  function Select ( options ) {   Element$$1.call( this, options );   this.options = [];  }   if ( Element$$1 ) Select.__proto__ = Element$$1;  Select.prototype = Object.create( Element$$1 && Element$$1.prototype );  Select.prototype.constructor = Select;   Select.prototype.foundNode = function foundNode ( node ) {   if ( this.binding ) {    var selectedOptions = getSelectedOptions( node );     if ( selectedOptions.length > 0 ) {     this.selectedOptions = selectedOptions;    }   }  };   Select.prototype.render = function render ( target, occupants ) {   Element$$1.prototype.render.call( this, target, occupants );   this.sync();    var node = this.node;    var i = node.options.length;   while ( i-- ) {    node.options[i].defaultSelected = node.options[i].selected;   }    this.rendered = true;  };   Select.prototype.sync = function sync () {   var this$1 = this;    var selectNode = this.node;    if ( !selectNode ) { return; }    var options = toArray( selectNode.options );    if ( this.selectedOptions ) {    options.forEach( function (o) {     if ( this$1.selectedOptions.indexOf( o ) >= 0 ) { o.selected = true; }     else { o.selected = false; }    });    this.binding.setFromNode( selectNode );    delete this.selectedOptions;    return;   }    var selectValue = this.getAttribute( 'value' );   var isMultiple = this.getAttribute( 'multiple' );   var array = isMultiple && Array.isArray( selectValue );    // If the <select> has a specified value, that should override   // these options   if ( selectValue !== undefined ) {    var optionWasSelected;     options.forEach( function (o) {     var optionValue = o._ractive ? o._ractive.value : o.value;     var shouldSelect = isMultiple ?      array && this$1.valueContains( selectValue, optionValue ) :      this$1.compare( selectValue, optionValue );      if ( shouldSelect ) {      optionWasSelected = true;     }      o.selected = shouldSelect;    });     if ( !optionWasSelected && !isMultiple ) {     if ( this.binding ) {      this.binding.forceUpdate();     }    }   }    // Otherwise the value should be initialised according to which   // <option> element is selected, if twoway binding is in effect   else if ( this.binding ) {    this.binding.forceUpdate();   }  };  Select.prototype.valueContains = function valueContains ( selectValue, optionValue ) {   var this$1 = this;    var i = selectValue.length;   while ( i-- ) {    if ( this$1.compare( optionValue, selectValue[i] ) ) { return true; }   }  };  Select.prototype.compare = function compare (optionValue, selectValue) {   var comparator = this.getAttribute( 'value-comparator' );   if ( comparator ) {    if (typeof comparator === 'function') {     return comparator( selectValue, optionValue );    }    if ( selectValue && optionValue ) {     return selectValue[comparator] == optionValue[comparator];    }   }   return selectValue == optionValue;  };  Select.prototype.update = function update () {   var dirty = this.dirty;   Element$$1.prototype.update.call(this);   if ( dirty ) {    this.sync();   }  };   return Select; }(Element));  var Textarea = (function (Input$$1) {  function Textarea( options ) {   var template = options.template;    options.deferContent = true;    Input$$1.call( this, options );    // check for single interpolator binding   if ( !this.attributeByName.value ) {    if ( template.f && isBindable( { template: template } ) ) {     this.attributes.push( createItem( {      owner: this,      template: { t: ATTRIBUTE, f: template.f, n: 'value' },      parentFragment: this.parentFragment     } ) );    } else {     this.fragment = new Fragment({ owner: this, cssIds: null, template: template.f });    }   }  }   if ( Input$$1 ) Textarea.__proto__ = Input$$1;  Textarea.prototype = Object.create( Input$$1 && Input$$1.prototype );  Textarea.prototype.constructor = Textarea;   Textarea.prototype.bubble = function bubble () {   var this$1 = this;    if ( !this.dirty ) {    this.dirty = true;     if ( this.rendered && !this.binding && this.fragment ) {     runloop.scheduleTask( function () {      this$1.dirty = false;      this$1.node.value = this$1.fragment.toString();     });    }     this.parentFragment.bubble(); // default behaviour   }  };   return Textarea; }(Input));  var Text = (function (Item$$1) {  function Text ( options ) {   Item$$1.call( this, options );   this.type = TEXT;  }   if ( Item$$1 ) Text.__proto__ = Item$$1;  Text.prototype = Object.create( Item$$1 && Item$$1.prototype );  Text.prototype.constructor = Text;   Text.prototype.detach = function detach () {   return detachNode( this.node );  };   Text.prototype.firstNode = function firstNode () {   return this.node;  };   Text.prototype.render = function render ( target, occupants ) {   if ( inAttributes() ) { return; }   this.rendered = true;    progressiveText( this, target, occupants, this.template );  };   Text.prototype.toString = function toString ( escape ) {   return escape ? escapeHtml( this.template ) : this.template;  };   Text.prototype.unrender = function unrender ( shouldDestroy ) {   if ( this.rendered && shouldDestroy ) { this.detach(); }   this.rendered = false;  };   Text.prototype.valueOf = function valueOf () {   return this.template;  };   return Text; }(Item));  var proto$3 = Text.prototype; proto$3.bind = proto$3.unbind = proto$3.update = noop;  var camelizeHyphenated = function ( hyphenatedStr ) {  return hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {   return $1.toUpperCase();  }); };  var prefix;  if ( !isClient ) {  prefix = null; } else {  var prefixCache = {};  var testStyle = createElement( 'div' ).style;   prefix = function ( prop ) {   prop = camelizeHyphenated( prop );    if ( !prefixCache[ prop ] ) {    if ( testStyle[ prop ] !== undefined ) {     prefixCache[ prop ] = prop;    }     else {     // test vendors...     var capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );      var i = vendors.length;     while ( i-- ) {      var vendor = vendors[i];      if ( testStyle[ vendor + capped ] !== undefined ) {       prefixCache[ prop ] = vendor + capped;       break;      }     }    }   }    return prefixCache[ prop ];  }; }  var prefix$1 = prefix;  var visible; var hidden = 'hidden';  if ( doc ) {  var prefix$2;   if ( hidden in doc ) {   prefix$2 = ; } else {   var i$1 = vendors.length;   while ( i$1-- ) {    var vendor = vendors[i$1];    hidden = vendor + 'Hidden';     if ( hidden in doc ) {     prefix$2 = vendor;     break;    }   }  }   if ( prefix$2 !== undefined ) {   doc.addEventListener( prefix$2 + 'visibilitychange', onChange );   onChange();  } else {   // gah, we're in an old browser   if ( 'onfocusout' in doc ) {    doc.addEventListener( 'focusout', onHide );    doc.addEventListener( 'focusin', onShow );   }    else {    win.addEventListener( 'pagehide', onHide );    win.addEventListener( 'blur', onHide );     win.addEventListener( 'pageshow', onShow );    win.addEventListener( 'focus', onShow );   }    visible = true; // until proven otherwise. Not ideal but hey  } }  function onChange () {  visible = !doc[ hidden ]; }  function onHide () {  visible = false; }  function onShow () {  visible = true; }  var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );  var unprefix = function ( prop ) {  return prop.replace( unprefixPattern, ); };  var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );  var hyphenate = function ( str ) {  if ( !str ) { return ; } // edge case if ( vendorPattern.test( str ) ) { str = '-' + str; }   return str.replace( /[A-Z]/g, function (match) { return '-' + match.toLowerCase(); } ); };  var createTransitions;  if ( !isClient ) {  createTransitions = null; } else {  var testStyle$1 = createElement( 'div' ).style;  var linear$1 = function (x) { return x; };   var canUseCssTransitions = {};  var cannotUseCssTransitions = {};   // determine some facts about our environment  var TRANSITION$1;  var TRANSITIONEND;  var CSS_TRANSITIONS_ENABLED;  var TRANSITION_DURATION;  var TRANSITION_PROPERTY;  var TRANSITION_TIMING_FUNCTION;   if ( testStyle$1.transition !== undefined ) {   TRANSITION$1 = 'transition';   TRANSITIONEND = 'transitionend';   CSS_TRANSITIONS_ENABLED = true;  } else if ( testStyle$1.webkitTransition !== undefined ) {   TRANSITION$1 = 'webkitTransition';   TRANSITIONEND = 'webkitTransitionEnd';   CSS_TRANSITIONS_ENABLED = true;  } else {   CSS_TRANSITIONS_ENABLED = false;  }   if ( TRANSITION$1 ) {   TRANSITION_DURATION = TRANSITION$1 + 'Duration';   TRANSITION_PROPERTY = TRANSITION$1 + 'Property';   TRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';  }   createTransitions = function ( t, to, options, changedProperties, resolve ) {    // Wait a beat (otherwise the target styles will be applied immediately)   // TODO use a fastdom-style mechanism?   setTimeout( function () {    var jsTransitionsComplete;    var cssTransitionsComplete;    var cssTimeout; // eslint-disable-line prefer-const     function transitionDone () { clearTimeout( cssTimeout ); }     function checkComplete () {     if ( jsTransitionsComplete && cssTransitionsComplete ) {      t.unregisterCompleteHandler( transitionDone );      // will changes to events and fire have an unexpected consequence here?      t.ractive.fire( t.name + ':end', t.node, t.isIntro );      resolve();     }    }     // this is used to keep track of which elements can use CSS to animate    // which properties    var hashPrefix = ( t.node.namespaceURI || ) + t.node.tagName; // need to reset transition properties    var style = t.node.style;    var previous = {     property: style[ TRANSITION_PROPERTY ],     timing: style[ TRANSITION_TIMING_FUNCTION ],     duration: style[ TRANSITION_DURATION ]    };     style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix$1 ).map( hyphenate ).join( ',' );    var easingName = hyphenate( options.easing || 'linear' );    style[ TRANSITION_TIMING_FUNCTION ] = easingName;    var cssTiming = style[ TRANSITION_TIMING_FUNCTION ] === easingName;    style[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';     function transitionEndHandler ( event ) {     var index = changedProperties.indexOf( camelizeHyphenated( unprefix( event.propertyName ) ) );      if ( index !== -1 ) {      changedProperties.splice( index, 1 );     }      if ( changedProperties.length ) {      // still transitioning...      return;     }      clearTimeout( cssTimeout );     cssTransitionsDone();    }     function cssTransitionsDone () {     style[ TRANSITION_PROPERTY ] = previous.property;     style[ TRANSITION_TIMING_FUNCTION ] = previous.duration;     style[ TRANSITION_DURATION ] = previous.timing;      t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );      cssTransitionsComplete = true;     checkComplete();    }     t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );     // safety net in case transitionend never fires    cssTimeout = setTimeout( function () {     changedProperties = [];     cssTransitionsDone();    }, options.duration + ( options.delay || 0 ) + 50 );    t.registerCompleteHandler( transitionDone );     setTimeout( function () {     var i = changedProperties.length;     var hash;     var originalValue;     var index;     var propertiesToTransitionInJs = [];     var prop;     var suffix;     var interpolator;      while ( i-- ) {      prop = changedProperties[i];      hash = hashPrefix + prop;       if ( cssTiming && CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {       style[ prefix$1( prop ) ] = to[ prop ];        // If we're not sure if CSS transitions are supported for       // this tag/property combo, find out now       if ( !canUseCssTransitions[ hash ] ) {        originalValue = t.getStyle( prop );         // if this property is transitionable in this browser,        // the current style will be different from the target style        canUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );        cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];         // Reset, if we're going to use timers after all        if ( cannotUseCssTransitions[ hash ] ) {         style[ prefix$1( prop ) ] = originalValue;        }       }      }       if ( !cssTiming || !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {       // we need to fall back to timer-based stuff       if ( originalValue === undefined ) {        originalValue = t.getStyle( prop ); }        // need to remove this from changedProperties, otherwise transitionEndHandler       // will get confused       index = changedProperties.indexOf( prop );       if ( index === -1 ) {        warnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });       } else {        changedProperties.splice( index, 1 );       }        // TODO Determine whether this property is animatable at all        suffix = /[^\d]*$/.exec( to[ prop ] )[0];       interpolator = interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ) || ( function () { return to[ prop ]; } );        // ...then kick off a timer-based transition       propertiesToTransitionInJs.push({        name: prefix$1( prop ),        interpolator: interpolator,        suffix: suffix       });      }     }      // javascript transitions     if ( propertiesToTransitionInJs.length ) {      var easing;       if ( typeof options.easing === 'string' ) {       easing = t.ractive.easing[ options.easing ];        if ( !easing ) {        warnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );        easing = linear$1;       }      } else if ( typeof options.easing === 'function' ) {       easing = options.easing;      } else {       easing = linear$1;      }       new Ticker({       duration: options.duration,       easing: easing,       step: function step ( pos ) {        var i = propertiesToTransitionInJs.length;        while ( i-- ) {         var prop = propertiesToTransitionInJs[i];         t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;        }       },       complete: function complete () {        jsTransitionsComplete = true;        checkComplete();       }      });     } else {      jsTransitionsComplete = true;     }      if ( !changedProperties.length ) {      // We need to cancel the transitionEndHandler, and deal with      // the fact that it will never fire      t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );      cssTransitionsComplete = true;      checkComplete();     }    }, 0 );   }, options.delay || 0 );  }; }  var createTransitions$1 = createTransitions;  function resetStyle ( node, style ) {  if ( style ) {   node.setAttribute( 'style', style );  } else {   // Next line is necessary, to remove empty style attribute!   // See http://stackoverflow.com/a/7167553 node.getAttribute( 'style' );   node.removeAttribute( 'style' );  } }  var getComputedStyle = win && win.getComputedStyle; var resolved = Promise.resolve();  var names = {  t0: 'intro-outro',  t1: 'intro',  t2: 'outro' };  var Transition = function Transition ( options ) {  this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );  this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );  this.ractive = this.owner.ractive;  this.template = options.template;  this.parentFragment = options.parentFragment;  this.options = options;  this.onComplete = []; };  Transition.prototype.animateStyle = function animateStyle ( style, value, options ) {   var this$1 = this;   if ( arguments.length === 4 ) {   throw new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );  }   // Special case - page isn't visible. Don't animate anything, because  // that way you'll never get CSS transitionend events  if ( !visible ) {   this.setStyle( style, value );   return resolved;  }   var to;   if ( typeof style === 'string' ) {   to = {};   to[ style ] = value;  } else {   to = style;    // shuffle arguments   options = value;  }   // As of 0.3.9, transition authors should supply an `option` object with  // `duration` and `easing` properties (and optional `delay`), plus a  // callback function that gets called after the animation completes   // TODO remove this check in a future version  if ( !options ) {   warnOnceIfDebug( 'The "%s" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' , this.name );   options = this;  }   return new Promise( function (fulfil) {   // Edge case - if duration is zero, set style synchronously and complete   if ( !options.duration ) {    this$1.setStyle( to );    fulfil();    return;   }    // Get a list of the properties we're animating   var propertyNames = Object.keys( to );   var changedProperties = [];    // Store the current styles   var computedStyle = getComputedStyle( this$1.node );    var i = propertyNames.length;   while ( i-- ) {    var prop = propertyNames[i];    var current = computedStyle[ prefix$1( prop ) ];     if ( current === '0px' ) { current = 0; }     // we need to know if we're actually changing anything    if ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers     changedProperties.push( prop );      // make the computed style explicit, so we can animate where     // e.g. height='auto'     this$1.node.style[ prefix$1( prop ) ] = current;    }   }    // If we're not actually changing anything, the transitionend event   // will never fire! So we complete early   if ( !changedProperties.length ) {    fulfil();    return;   }    createTransitions$1( this$1, to, options, changedProperties, fulfil );  }); };  Transition.prototype.bind = function bind () {  var options = this.options;  var type = options.template && options.template.v;  if ( type ) {   if ( type === 't0' || type === 't1' ) { this.element.intro = this; }   if ( type === 't0' || type === 't2' ) { this.element.outro = this; }   this.eventName = names[ type ];  }   var ractive = this.owner.ractive;   this.name = options.name || options.template.n;   if ( options.params ) {   this.params = options.params;  }   if ( typeof this.name === 'function' ) {   this._fn = this.name;   this.name = this._fn.name;  } else {   this._fn = findInViewHierarchy( 'transitions', ractive, this.name );  }   if ( !this._fn ) {   warnOnceIfDebug( missingPlugin( this.name, 'transition' ), { ractive: ractive });  }   setupArgsFn( this, options.template ); };  Transition.prototype.getParams = function getParams () {  if ( this.params ) { return this.params; }   // get expression args if supplied  if ( this.fn ) {   var values = resolveArgs( this, this.template, this.parentFragment ).map( function (model) {    if ( !model ) { return undefined; }     return model.get();   });   return this.fn.apply( this.ractive, values );  } };  Transition.prototype.getStyle = function getStyle ( props ) {  var computedStyle = getComputedStyle( this.node );   if ( typeof props === 'string' ) {   var value = computedStyle[ prefix$1( props ) ];   return value === '0px' ? 0 : value;  }   if ( !Array.isArray( props ) ) {   throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );  }   var styles = {};   var i = props.length;  while ( i-- ) {   var prop = props[i];   var value$1 = computedStyle[ prefix$1( prop ) ];    if ( value$1 === '0px' ) { value$1 = 0; }   styles[ prop ] = value$1;  }   return styles; };  Transition.prototype.processParams = function processParams ( params, defaults ) {  if ( typeof params === 'number' ) {   params = { duration: params };  }   else if ( typeof params === 'string' ) {   if ( params === 'slow' ) {    params = { duration: 600 };   } else if ( params === 'fast' ) {    params = { duration: 200 };   } else {    params = { duration: 400 };   }  } else if ( !params ) {   params = {};  }   return Object.assign( {}, defaults, params ); };  Transition.prototype.registerCompleteHandler = function registerCompleteHandler ( fn ) {  addToArray( this.onComplete, fn ); }; Transition.prototype.setStyle = function setStyle ( style, value ) {   var this$1 = this;   if ( typeof style === 'string' ) {   this.node.style[ prefix$1( style ) ] = value;  }   else {   var prop;   for ( prop in style ) {    if ( style.hasOwnProperty( prop ) ) {     this$1.node.style[ prefix$1( prop ) ] = style[ prop ];    }   }  }   return this; };  Transition.prototype.shouldFire = function shouldFire ( type ) {  if ( !this.ractive.transitionsEnabled ) { return false; }   // check for noIntro and noOutro cases, which only apply when the owner ractive is rendering and unrendering, respectively  if ( type === 'intro' && this.ractive.rendering && nearestProp( 'noIntro', this.ractive, true ) ) { return false; }  if ( type === 'outro' && this.ractive.unrendering && nearestProp( 'noOutro', this.ractive, false ) ) { return false; }   var params = this.getParams(); // this is an array, the params object should be the first member  // if there's not a parent element, this can't be nested, so roll on  if ( !this.element.parent ) { return true; }   // if there is a local param, it takes precedent  if ( params && params[0] && 'nested' in params[0] ) {   if ( params[0].nested !== false ) { return true; }  } else { // use the nearest instance setting   // find the nearest instance that actually has a nested setting   if ( nearestProp( 'nestedTransitions', this.ractive ) !== false ) { return true; }  }   // check to see if this is actually a nested transition  var el = this.element.parent;  while ( el ) {   if ( el[type] && el[type].starting ) { return false; }   el = el.parent;  }   return true; };  Transition.prototype.start = function start () {   var this$1 = this;   var node = this.node = this.element.node;  var originalStyle = node.getAttribute( 'style' );   var completed;  var args = this.getParams();   // create t.complete() - we don't want this on the prototype,  // because we don't want `this` silliness when passing it as  // an argument  this.complete = function (noReset) {   this$1.starting = false;   if ( completed ) {    return;   }    this$1.onComplete.forEach( function (fn) { return fn(); } );   if ( !noReset && this$1.isIntro ) {    resetStyle( node, originalStyle);   }    this$1._manager.remove( this$1 );    completed = true;  };   // If the transition function doesn't exist, abort  if ( !this._fn ) {   this.complete();   return;  }   var promise = this._fn.apply( this.ractive, [ this ].concat( args ) );  if ( promise ) { promise.then( this.complete ); } };  Transition.prototype.toString = function toString () { return ; }; Transition.prototype.unbind = function unbind () {  if ( !this.element.attributes.unbinding ) {   var type = this.options && this.options.template && this.options.template.v;   if ( type === 't0' || type === 't1' ) { this.element.intro = null; }   if ( type === 't0' || type === 't2' ) { this.element.outro = null; }  } };  Transition.prototype.unregisterCompleteHandler = function unregisterCompleteHandler ( fn ) {  removeFromArray( this.onComplete, fn ); };  var proto$4 = Transition.prototype; proto$4.destroyed = proto$4.render = proto$4.unrender = proto$4.update = noop;  function nearestProp ( prop, ractive, rendering ) {  var instance = ractive;  while ( instance ) {   if ( instance.hasOwnProperty( prop ) && ( rendering === undefined || rendering ? instance.rendering : instance.unrendering ) ) { return instance[ prop ]; }   instance = instance.component && instance.component.ractive;  }   return ractive[ prop ]; }  var elementCache = {};  var ieBug; var ieBlacklist;  try {  createElement( 'table' ).innerHTML = 'foo'; } catch ( err ) {  ieBug = true;   ieBlacklist = {   TABLE:  [ '
', '
' ],   THEAD:  [ '
<thead class="x">', '</thead>
' ],   TBODY:  [ '
<tbody class="x">', '</tbody>
' ],   TR:     [ '
', '
' ],
SELECT: [ '<select class="x">', '</select>' ]  }; }
var insertHtml = function ( html$$1, node ) {  var nodes = [];
// render 0 and false  if ( html$$1 == null || html$$1 === ) { return nodes; }
var container;  var wrapper;  var selectedOption;
if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {   container = element( 'DIV' );   container.innerHTML = wrapper[0] + html$$1 + wrapper[1];   container = container.querySelector( '.x' );
if ( container.tagName === 'SELECT' ) {    selectedOption = container.options[ container.selectedIndex ];   }  }
else if ( node.namespaceURI === svg$1 ) {   container = element( 'DIV' );   container.innerHTML = '<svg class="x">' + html$$1 + '</svg>';   container = container.querySelector( '.x' );  }
else if ( node.tagName === 'TEXTAREA' ) {   container = createElement( 'div' );
if ( typeof container.textContent !== 'undefined' ) {    container.textContent = html$$1;   } else {    container.innerHTML = html$$1;   }  }
else {   container = element( node.tagName );   container.innerHTML = html$$1;
if ( container.tagName === 'SELECT' ) {    selectedOption = container.options[ container.selectedIndex ];   }  }
var child;  while ( child = container.firstChild ) {   nodes.push( child );   container.removeChild( child );  }
// This is really annoying. Extracting <option> nodes from the  // temporary container <select> causes the remaining ones to  // become selected. So now we have to deselect them. IE8, you  // amaze me. You really do  // ...and now Chrome too  var i;  if ( node.tagName === 'SELECT' ) {   i = nodes.length;   while ( i-- ) {    if ( nodes[i] !== selectedOption ) {     nodes[i].selected = false;    }   }  }
return nodes; };
function element ( tagName ) {  return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) ); }
var Triple = (function (Mustache$$1) {  function Triple ( options ) {   Mustache$$1.call( this, options );  }
if ( Mustache$$1 ) Triple.__proto__ = Mustache$$1;  Triple.prototype = Object.create( Mustache$$1 && Mustache$$1.prototype );  Triple.prototype.constructor = Triple;
Triple.prototype.detach = function detach () {   var docFrag = createDocumentFragment();   if ( this.nodes ) { this.nodes.forEach( function (node) { return docFrag.appendChild( node ); } ); }   return docFrag;  };
Triple.prototype.find = function find ( selector ) {   var this$1 = this;
var len = this.nodes.length;   var i;
for ( i = 0; i < len; i += 1 ) {    var node = this$1.nodes[i];
if ( node.nodeType !== 1 ) { continue; }
if ( matches( node, selector ) ) { return node; }
var queryResult = node.querySelector( selector );    if ( queryResult ) { return queryResult; }   }
return null;  };
Triple.prototype.findAll = function findAll ( selector, options ) {   var this$1 = this;
var result = options.result;   var len = this.nodes.length;   var i;
for ( i = 0; i < len; i += 1 ) {    var node = this$1.nodes[i];
if ( node.nodeType !== 1 ) { continue; }
if ( matches( node, selector ) ) { result.push( node ); }
var queryAllResult = node.querySelectorAll( selector );    if ( queryAllResult ) {     result.push.apply( result, queryAllResult );    }   }  };
Triple.prototype.findComponent = function findComponent () {   return null;  };
Triple.prototype.firstNode = function firstNode () {   return this.rendered && this.nodes[0];  };
Triple.prototype.render = function render ( target, occupants ) {   var this$1 = this;
var parentNode = this.parentFragment.findParentNode();
if ( !this.nodes ) {    var html = this.model ? this.model.get() : ; this.nodes = insertHtml( html, this.parentFragment.findParentNode(), target );   }
var nodes = this.nodes;   var anchor = this.parentFragment.findNextNode( this );
// progressive enhancement   if ( occupants ) {    var i = -1;    var next;
// start with the first node that should be rendered    while ( occupants.length && ( next = this.nodes[ i + 1 ] ) ) {     var n = (void 0);     // look through the occupants until a matching node is found     while ( n = occupants.shift() ) {      var t = n.nodeType;
if ( t === next.nodeType && ( ( t === 1 && n.outerHTML === next.outerHTML ) || ( ( t === 3 || t === 8 ) && n.nodeValue === next.nodeValue ) ) ) {       this$1.nodes.splice( ++i, 1, n ); // replace the generated node with the existing one       break;      } else {       target.removeChild( n ); // remove the non-matching existing node      }     }    }
if ( i >= 0 ) {     // update the list of remaining nodes to attach, excluding any that were replaced by existing nodes     nodes = this.nodes.slice( i );    }
// update the anchor to be the next occupant    if ( occupants.length ) { anchor = occupants[0]; }   }
// attach any remainging nodes to the parent   if ( nodes.length ) {    var frag = createDocumentFragment();    nodes.forEach( function (n) { return frag.appendChild( n ); } );
if ( anchor ) {     anchor.parentNode.insertBefore( frag, anchor );    } else {     parentNode.appendChild( frag );    }   }
this.rendered = true;  };
Triple.prototype.toString = function toString () {   var value = this.model && this.model.get();   value = value != null ? + value : ;
return inAttribute() ? decodeCharacterReferences( value ) : value;  };
Triple.prototype.unrender = function unrender () {   if ( this.nodes ) { this.nodes.forEach( function (node) { return detachNode( node ); } ); }   this.rendered = false;   this.nodes = null;  };
Triple.prototype.update = function update () {   if ( this.rendered && this.dirty ) {    this.dirty = false;
this.unrender();    this.render();   } else {    // make sure to reset the dirty flag even if not rendered    this.dirty = false;   }  };
return Triple; }(Mustache));
// finds the component constructor in the registry or view hierarchy registries function getComponentConstructor ( ractive, name ) {  var instance = findInstance( 'components', ractive, name );  var Component;
if ( instance ) {   Component = instance.components[ name ];
// best test we have for not Ractive.extend   if ( Component && !Component._Parent ) {    // function option, execute and store for reset    var fn = Component.bind( instance );    fn.isOwner = instance.components.hasOwnProperty( name );    Component = fn();
if ( !Component ) {     warnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive: ractive });     return;    }
if ( typeof Component === 'string' ) {     // allow string lookup     Component = getComponentConstructor( ractive, Component );    }
Component._fn = fn;    instance.components[ name ] = Component;   }  }
return Component; }
//import Yielder from './Yielder'; var constructors = {}; constructors[ ALIAS ] = Alias; constructors[ ANCHOR ] = Component; constructors[ DOCTYPE ] = Doctype; constructors[ INTERPOLATOR ] = Interpolator; constructors[ PARTIAL ] = Partial; constructors[ SECTION ] = Section; constructors[ TRIPLE ] = Triple; constructors[ YIELDER ] = Partial;
constructors[ ATTRIBUTE ] = Attribute; constructors[ BINDING_FLAG ] = BindingFlag; constructors[ DECORATOR ] = Decorator; constructors[ EVENT ] = EventDirective; constructors[ TRANSITION ] = Transition;
var specialElements = {  doctype: Doctype,  form: Form,  input: Input,  option: Option,  select: Select,  textarea: Textarea };
function createItem ( options ) {  if ( typeof options.template === 'string' ) {   return new Text( options );  }
if ( options.template.t === ELEMENT ) {   // could be component or element   var ComponentConstructor = getComponentConstructor( options.parentFragment.ractive, options.template.e );   if ( ComponentConstructor ) {    return new Component( options, ComponentConstructor );   }
var tagName = options.template.e.toLowerCase();
var ElementConstructor = specialElements[ tagName ] || Element;   return new ElementConstructor( options );  }
var Item;
// component mappings are a special case of attribute  if ( options.template.t === ATTRIBUTE ) {   var el = options.owner;   if ( !el || ( el.type !== ANCHOR && el.type !== COMPONENT && el.type !== ELEMENT ) ) {    el = findElement( options.parentFragment );   }   options.element = el;
Item = el.type === COMPONENT || el.type === ANCHOR ? Mapping : Attribute;  } else {   Item = constructors[ options.template.t ];  }
if ( !Item ) { throw new Error( ("Unrecognised item type " + (options.template.t)) ); }
return new Item( options ); }
// TODO all this code needs to die function processItems ( items, values, guid, counter ) {  if ( counter === void 0 ) counter = 0;
return items.map( function (item) {   if ( item.type === TEXT ) {    return item.template;   }
if ( item.fragment ) {    if ( item.fragment.iterations ) {     return item.fragment.iterations.map( function (fragment) {      return processItems( fragment.items, values, guid, counter );     }).join( ); } else {     return processItems( item.fragment.items, values, guid, counter );    }   }
var placeholderId = guid + "-" + (counter++);   var model = item.model || item.newModel;
values[ placeholderId ] = model ?    model.wrapper ?     model.wrapperValue :     model.get() :    undefined;
return '${' + placeholderId + '}';  }).join( ); }
function unrenderAndDestroy$1 ( item ) {  item.unrender( true ); }
var Fragment = function Fragment ( options ) {  this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute
this.isRoot = !options.owner.parentFragment;  this.parent = this.isRoot ? null : this.owner.parentFragment;  this.ractive = options.ractive || ( this.isRoot ? options.owner : this.parent.ractive );
this.componentParent = ( this.isRoot && this.ractive.component ) ? this.ractive.component.parentFragment : null;  this.delegate = ( this.parent ? this.parent.delegate : ( this.componentParent && this.componentParent.delegate ) ) ||   ( this.owner.containerFragment && this.owner.containerFragment.delegate );
this.context = null;  this.rendered = false;
// encapsulated styles should be inherited until they get applied by an element  this.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );
this.dirty = false;  this.dirtyValue = true; // used for attribute values
this.template = options.template || [];  this.createItems(); };
Fragment.prototype.bind = function bind$1 ( context ) {  this.context = context;  this.items.forEach( bind );  this.bound = true;
// in rare cases, a forced resolution (or similar) will cause the  // fragment to be dirty before it's even finished binding. In those  // cases we update immediately  if ( this.dirty ) { this.update(); }
return this; };
Fragment.prototype.bubble = function bubble () {  this.dirtyValue = true;
if ( !this.dirty ) {   this.dirty = true;
if ( this.isRoot ) { // TODO encapsulate 'is component root, but not overall root' check?    if ( this.ractive.component ) {     this.ractive.component.bubble();    } else if ( this.bound ) {     runloop.addFragment( this );    }   } else {    this.owner.bubble( this.index );   }  } };
Fragment.prototype.createItems = function createItems () {   var this$1 = this;
// this is a hot code path  var max = this.template.length;  this.items = [];  for ( var i = 0; i < max; i++ ) {   this$1.items[i] = createItem({ parentFragment: this$1, template: this$1.template[i], index: i });  } };
Fragment.prototype.destroyed = function destroyed$1 () {  this.items.forEach( destroyed ); };
Fragment.prototype.detach = function detach () {  var docFrag = createDocumentFragment();  var xs = this.items;  var len = xs.length;  for ( var i = 0; i < len; i++ ) {   docFrag.appendChild( xs[i].detach() );  }  return docFrag; };
Fragment.prototype.find = function find ( selector, options ) {  return findMap( this.items, function (i) { return i.find( selector, options ); } ); };
Fragment.prototype.findAll = function findAll ( selector, options ) {  if ( this.items ) {   this.items.forEach( function (i) { return i.findAll && i.findAll( selector, options ); } );  } };
Fragment.prototype.findComponent = function findComponent ( name, options ) {  return findMap( this.items, function (i) { return i.findComponent( name, options ); } ); };
Fragment.prototype.findAllComponents = function findAllComponents ( name, options ) {  if ( this.items ) {   this.items.forEach( function (i) { return i.findAllComponents && i.findAllComponents( name, options ); } );  } };
Fragment.prototype.findContext = function findContext () {  var fragment = this;  while ( fragment && !fragment.context ) { fragment = fragment.parent; }  if ( !fragment ) { return this.ractive.viewmodel; }  else { return fragment.context; } };
Fragment.prototype.findNextNode = function findNextNode ( item ) {   var this$1 = this;
// search for the next node going forward  if ( item ) {   for ( var i = item.index + 1; i < this.items.length; i++ ) {    if ( !this$1.items[ i ] ) { continue; }
var node = this$1.items[ i ].firstNode( true );    if ( node ) { return node; }   }  }
// if this is the root fragment, and there are no more items,  // it means we're at the end...  if ( this.isRoot ) {   if ( this.ractive.component ) { return this.ractive.component.parentFragment.findNextNode( this.ractive.component );   }
// TODO possible edge case with other content   // appended to this.ractive.el?   return null;  }
if ( this.parent ) { return this.owner.findNextNode( this ); } // the argument is in case the parent is a RepeatedFragment };
Fragment.prototype.findParentNode = function findParentNode () {  var fragment = this;
do {   if ( fragment.owner.type === ELEMENT ) {    return fragment.owner.node;   }
if ( fragment.isRoot && !fragment.ractive.component ) { // TODO encapsulate check    return fragment.ractive.el;   }
if ( fragment.owner.type === YIELDER ) {    fragment = fragment.owner.containerFragment;   } else {    fragment = fragment.componentParent || fragment.parent; // TODO ugh   }  } while ( fragment );
throw new Error( 'Could not find parent node' ); // TODO link to issue tracker };
Fragment.prototype.findRepeatingFragment = function findRepeatingFragment () {  var fragment = this;  // TODO better check than fragment.parent.iterations  while ( ( fragment.parent || fragment.componentParent ) && !fragment.isIteration ) {   fragment = fragment.parent || fragment.componentParent;  }
return fragment; };
Fragment.prototype.firstNode = function firstNode ( skipParent ) {  var node = findMap( this.items, function (i) { return i.firstNode( true ); } );  if ( node ) { return node; }  if ( skipParent ) { return null; }
return this.parent.findNextNode( this.owner ); };
Fragment.prototype.rebind = function rebind ( next ) {  this.context = next; };
Fragment.prototype.render = function render$$1 ( target, occupants ) {  if ( this.rendered ) { throw new Error( 'Fragment is already rendered!' ); }  this.rendered = true;
var xs = this.items;  var len = xs.length;  for ( var i = 0; i < len; i++ ) {   xs[i].render( target, occupants );  } };
Fragment.prototype.resetTemplate = function resetTemplate ( template ) {  var wasBound = this.bound;  var wasRendered = this.rendered;
// TODO ensure transitions are disabled globally during reset
if ( wasBound ) {   if ( wasRendered ) { this.unrender( true ); }   this.unbind();  }
this.template = template;  this.createItems();
if ( wasBound ) {   this.bind( this.context );
if ( wasRendered ) {    var parentNode = this.findParentNode();    var anchor = this.findNextNode();
if ( anchor ) {     var docFrag = createDocumentFragment();     this.render( docFrag );     parentNode.insertBefore( docFrag, anchor );    } else {     this.render( parentNode );    }   }  } };
Fragment.prototype.shuffled = function shuffled$1 () {  this.items.forEach( shuffled ); };
Fragment.prototype.toString = function toString$1$$1 ( escape ) {  return this.items.map( escape ? toEscapedString : toString$1 ).join( ); };
Fragment.prototype.unbind = function unbind$1 () {  this.context = null;  this.items.forEach( unbind );  this.bound = false;
return this; };
Fragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {  this.items.forEach( shouldDestroy ? unrenderAndDestroy$1 : unrender );  this.rendered = false; };
Fragment.prototype.update = function update$1 () {  if ( this.dirty ) {   if ( !this.updating ) {    this.dirty = false;    this.updating = true;    this.items.forEach( update );    this.updating = false;   } else if ( this.isRoot ) {    runloop.addFragmentToRoot( this );   }  } };
Fragment.prototype.valueOf = function valueOf () {  if ( this.items.length === 1 ) {   return this.items[0].valueOf();  }
if ( this.dirtyValue ) {   var values = {};   var source = processItems( this.items, values, this.ractive._guid );   var parsed = parseJSON( source, values );
this.value = parsed ?    parsed.value :    this.toString();
this.dirtyValue = false;  }
return this.value; };
Fragment.prototype.getContext = getContext;
function getChildQueue ( queue, ractive ) {  return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] ); }
function fire ( hookQueue, ractive ) {  var childQueue = getChildQueue( hookQueue.queue, ractive );
hookQueue.hook.fire( ractive );
// queue is "live" because components can end up being  // added while hooks fire on parents that modify data values.  while ( childQueue.length ) {   fire( hookQueue, childQueue.shift() );  }
delete hookQueue.queue[ ractive._guid ]; }
var HookQueue = function HookQueue ( event ) {  this.hook = new Hook( event );  this.inProcess = {};  this.queue = {}; };
HookQueue.prototype.begin = function begin ( ractive ) {  this.inProcess[ ractive._guid ] = true; };
HookQueue.prototype.end = function end ( ractive ) {  var parent = ractive.parent;
// If this is *isn't* a child of a component that's in process,  // it should call methods or fire at this point  if ( !parent || !this.inProcess[ parent._guid ] ) {   fire( this, ractive );  }  // elsewise, handoff to parent to fire when ready  else {   getChildQueue( this.queue, parent ).push( ractive );  }
delete this.inProcess[ ractive._guid ]; };
var configHook = new Hook( 'config' ); var initHook = new HookQueue( 'init' );
function initialise ( ractive, userOptions, options ) {  Object.keys( ractive.viewmodel.computations ).forEach( function (key) {   var computation = ractive.viewmodel.computations[ key ];
if ( ractive.viewmodel.value.hasOwnProperty( key ) ) {    computation.set( ractive.viewmodel.value[ key ] );   }  });
// set up event subscribers  subscribe( ractive, userOptions, 'on' );
// init config from Parent and options  config.init( ractive.constructor, ractive, userOptions );
configHook.fire( ractive );
// general config done, set up observers  subscribe( ractive, userOptions, 'observe' );
initHook.begin( ractive );
var fragment = ractive.fragment = createFragment( ractive, options );  if ( fragment ) { fragment.bind( ractive.viewmodel ); }
initHook.end( ractive );
if ( fragment ) {   // render automatically ( if `el` is specified )   var el = getElement( ractive.el || ractive.target );   if ( el ) {    var promise = ractive.render( el, ractive.append );
if ( Ractive.DEBUG_PROMISES ) {     promise.catch( function (err) {      warnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;' );      warnIfDebug( 'An error happened during rendering', { ractive: ractive });      logIfDebug( err );
throw err;     });    }   }  } }
function createFragment ( ractive, options ) {  if ( options === void 0 ) options = {};
if ( ractive.template ) {   var cssIds;
if ( options.cssIds || ractive.cssId ) {    cssIds = options.cssIds ? options.cssIds.slice() : [];
if ( ractive.cssId ) {     cssIds.push( ractive.cssId );    }   }
return new Fragment({    owner: ractive,    template: ractive.template,    cssIds: cssIds   });  } }
function subscribe ( instance, options, type ) {  var subs = ( instance.constructor[ ("_" + type) ] || [] ).concat( toPairs( options[ type ] || [] ) );  var single = type === 'on' ? 'once' : (type + "Once");
subs.forEach( function (ref) {   var target = ref[0];   var config$$1 = ref[1];
if ( typeof config$$1 === 'function' ) {    instance[type]( target, config$$1 );   } else if ( typeof config$$1 === 'object' && typeof config$$1.handler === 'function' ) {    instance[ config$$1.once ? single : type ]( target, config$$1.handler, config$$1 );   }  }); }
var renderHook = new Hook( 'render' ); var completeHook = new Hook( 'complete' );
function render$1 ( ractive, target, anchor, occupants ) {  // set a flag to let any transitions know that this instance is currently rendering  ractive.rendering = true;
var promise = runloop.start( ractive, true );  runloop.scheduleTask( function () { return renderHook.fire( ractive ); }, true );
if ( ractive.fragment.rendered ) {   throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );  }
if ( ractive.destroyed ) {   ractive.destroyed = false;   ractive.fragment = createFragment( ractive ).bind( ractive.viewmodel );  }
anchor = getElement( anchor ) || ractive.anchor;
ractive.el = ractive.target = target;  ractive.anchor = anchor;
// ensure encapsulated CSS is up-to-date  if ( ractive.cssId ) { applyCSS(); }
if ( target ) {   ( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( ractive );
if ( anchor ) {    var docFrag = doc.createDocumentFragment();    ractive.fragment.render( docFrag );    target.insertBefore( docFrag, anchor );   } else {    ractive.fragment.render( target, occupants );   }  }
runloop.end();  ractive.rendering = false;
return promise.then( function () {   if (ractive.torndown) { return; }
completeHook.fire( ractive );  }); }
function Ractive$render ( target, anchor ) {  if ( this.torndown ) {   warnIfDebug( 'ractive.render() was called on a Ractive instance that was already torn down' );   return Promise.resolve();  }
target = getElement( target ) || this.el;
if ( !this.append && target ) {   // Teardown any existing instances *before* trying to set up the new one -   // avoids certain weird bugs   var others = target.__ractive_instances__;   if ( others ) { others.forEach( teardown ); }
// make sure we are the only occupants   if ( !this.enhance ) {    target.innerHTML = ; // TODO is this quicker than removeChild? Initial research inconclusive }  }
var occupants = this.enhance ? toArray( target.childNodes ) : null;  var promise = render$1( this, target, anchor, occupants );
if ( occupants ) {   while ( occupants.length ) { target.removeChild( occupants.pop() ); }  }
return promise; }
var shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ];
var completeHook$1 = new Hook( 'complete' ); var resetHook = new Hook( 'reset' ); var renderHook$1 = new Hook( 'render' ); var unrenderHook = new Hook( 'unrender' );
function Ractive$reset ( data ) {  data = data || {};
if ( typeof data !== 'object' ) {   throw new Error( 'The reset method takes either no arguments, or an object containing new data' );  }
// TEMP need to tidy this up  data = dataConfigurator.init( this.constructor, this, { data: data });
var promise = runloop.start( this, true );
// If the root object is wrapped, try and use the wrapper's reset value  var wrapper = this.viewmodel.wrapper;  if ( wrapper && wrapper.reset ) {   if ( wrapper.reset( data ) === false ) {    // reset was rejected, we need to replace the object    this.viewmodel.set( data );   }  } else {   this.viewmodel.set( data );  }
// reset config items and track if need to rerender  var changes = config.reset( this );  var rerender;
var i = changes.length;  while ( i-- ) {   if ( shouldRerender.indexOf( changes[i] ) > -1 ) {    rerender = true;    break;   }  }
if ( rerender ) {   unrenderHook.fire( this );   this.fragment.resetTemplate( this.template );   renderHook$1.fire( this );   completeHook$1.fire( this );  }
runloop.end();
resetHook.fire( this, data );
return promise; }
function collect( source, name, attr, dest ) {  source.forEach( function (item) {   // queue to rerender if the item is a partial and the current name matches   if ( item.type === PARTIAL && ( item.refName ===  name || item.name === name ) ) {    item.inAttribute = attr;    dest.push( item );    return; // go no further   }
// if it has a fragment, process its items   if ( item.fragment ) {    collect( item.fragment.iterations || item.fragment.items, name, attr, dest );   }
// or if it is itself a fragment, process its items   else if ( Array.isArray( item.items ) ) {    collect( item.items, name, attr, dest );   }
// or if it is a component, step in and process its items   else if ( item.type === COMPONENT && item.instance ) {    // ...unless the partial is shadowed    if ( item.instance.partials[ name ] ) { return; }    collect( item.instance.fragment.items, name, attr, dest );   }
// if the item is an element, process its attributes too   if ( item.type === ELEMENT ) {    if ( Array.isArray( item.attributes ) ) {     collect( item.attributes, name, true, dest );    }   }  }); }
function forceResetTemplate ( partial ) {  partial.forceResetTemplate(); }
var resetPartial = function ( name, partial ) {  var collection = [];  collect( this.fragment.items, name, false, collection );
var promise = runloop.start( this, true );
this.partials[ name ] = partial;  collection.forEach( forceResetTemplate );
runloop.end();
return promise; };
// TODO should resetTemplate be asynchronous? i.e. should it be a case // of outro, update template, intro? I reckon probably not, since that // could be achieved with unrender-resetTemplate-render. Also, it should // conceptually be similar to resetPartial, which couldn't be async
function Ractive$resetTemplate ( template ) {  templateConfigurator.init( null, this, { template: template });
var transitionsEnabled = this.transitionsEnabled;  this.transitionsEnabled = false;
// Is this is a component, we need to set the `shouldDestroy`  // flag, otherwise it will assume by default that a parent node  // will be detached, and therefore it doesn't need to bother  // detaching its own nodes  var component = this.component;  if ( component ) { component.shouldDestroy = true; }  this.unrender();  if ( component ) { component.shouldDestroy = false; }
var promise = runloop.start();
// remove existing fragment and create new one  this.fragment.unbind().unrender( true );
this.fragment = new Fragment({   template: this.template,   root: this,   owner: this  });
var docFrag = createDocumentFragment();  this.fragment.bind( this.viewmodel ).render( docFrag );
// if this is a component, its el may not be valid, so find a  // target based on the component container  if ( component && !component.external ) {   this.fragment.findParentNode().insertBefore( docFrag, component.findNextNode() );  } else {   this.el.insertBefore( docFrag, this.anchor );  }
runloop.end();
this.transitionsEnabled = transitionsEnabled;
return promise; }
var reverse = makeArrayMethod( 'reverse' ).path;
function Ractive$set ( keypath, value, options ) {  var ractive = this;
var opts = typeof keypath === 'object' ? value : options;
return set( ractive, build( ractive, keypath, value, opts && opts.isolated ), opts ); }
var shift = makeArrayMethod( 'shift' ).path;
var sort = makeArrayMethod( 'sort' ).path;
var splice = makeArrayMethod( 'splice' ).path;
function Ractive$subtract ( keypath, d, options ) {  var num = typeof d === 'number' ? -d : -1;  var opts = typeof d === 'object' ? d : options;  return add( this, keypath, num, opts ); }
function Ractive$toggle ( keypath, options ) {  if ( typeof keypath !== 'string' ) {   throw new TypeError( badArguments );  }
return set( this, gather( this, keypath, null, options && options.isolated ).map( function (m) { return [ m, !m.get() ]; } ), options ); }
function Ractive$toCSS() {  var cssIds = [ this.cssId ].concat( this.findAllComponents().map( function (c) { return c.cssId; } ) );  var uniqueCssIds = Object.keys(cssIds.reduce( function ( ids, id ) { return (ids[id] = true, ids); }, {}));  return getCSS( uniqueCssIds ); }
function Ractive$toHTML () {  return this.fragment.toString( true ); }
function toText () {  return this.fragment.toString( false ); }
function Ractive$transition ( name, node, params ) {
if ( node instanceof HTMLElement ) {   // good to go  }  else if ( isObject( node ) ) {   // omitted, use event node   params = node;  }
// if we allow query selector, then it won't work  // simple params like "fast"
// else if ( typeof node === 'string' ) {  //  // query selector  //  node = this.find( node )  // }
node = node || this.event.node;
if ( !node || !node._ractive ) {   fatal( ("No node was supplied for transition " + name) );  }
params = params || {};  var owner = node._ractive.proxy;  var transition = new Transition({ owner: owner, parentFragment: owner.parentFragment, name: name, params: params });  transition.bind();
var promise = runloop.start( this, true );  runloop.registerTransition( transition );  runloop.end();
promise.then( function () { return transition.unbind(); } );  return promise; }
function unlink( here ) {  var promise = runloop.start();  this.viewmodel.joinAll( splitKeypath( here ), { lastLink: false } ).unlink();  runloop.end();  return promise; }
var unrenderHook$1 = new Hook( 'unrender' );
function Ractive$unrender () {  if ( !this.fragment.rendered ) {   warnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );   return Promise.resolve();  }
this.unrendering = true;  var promise = runloop.start( this, true );
// If this is a component, and the component isn't marked for destruction,  // don't detach nodes from the DOM unnecessarily  var shouldDestroy = !this.component || ( this.component.anchor || {} ).shouldDestroy || this.component.shouldDestroy || this.shouldDestroy;  this.fragment.unrender( shouldDestroy );  if ( shouldDestroy ) { this.destroyed = true; }
removeFromArray( this.el.__ractive_instances__, this );
unrenderHook$1.fire( this );
runloop.end();  this.unrendering = false;
return promise; }
var unshift = makeArrayMethod( 'unshift' ).path;
function Ractive$updateModel ( keypath, cascade ) {  var promise = runloop.start( this, true );
if ( !keypath ) {   this.viewmodel.updateFromBindings( true );  } else {   this.viewmodel.joinAll( splitKeypath( keypath ) ).updateFromBindings( cascade !== false );  }
runloop.end();
return promise; }
var RactiveProto = {  add: Ractive$add,  animate: Ractive$animate,  attachChild: attachChild,  detach: Ractive$detach,  detachChild: detachChild,  find: Ractive$find,  findAll: Ractive$findAll,  findAllComponents: Ractive$findAllComponents,  findComponent: Ractive$findComponent,  findContainer: Ractive$findContainer,  findParent: Ractive$findParent,  fire: Ractive$fire,  get: Ractive$get,  getContext: getContext$1,  getNodeInfo: getNodeInfo$$1,  insert: Ractive$insert,  link: link,  observe: observe,  observeOnce: observeOnce,  off: Ractive$off,  on: Ractive$on,  once: Ractive$once,  pop: pop,  push: push,  readLink: readLink,  render: Ractive$render,  reset: Ractive$reset,  resetPartial: resetPartial,  resetTemplate: Ractive$resetTemplate,  reverse: reverse,  set: Ractive$set,  shift: shift,  sort: sort,  splice: splice,  subtract: Ractive$subtract,  teardown: Ractive$teardown,  toggle: Ractive$toggle,  toCSS: Ractive$toCSS,  toCss: Ractive$toCSS,  toHTML: Ractive$toHTML,  toHtml: Ractive$toHTML,  toText: toText,  transition: Ractive$transition,  unlink: unlink,  unrender: Ractive$unrender,  unshift: unshift,  update: Ractive$update,  updateModel: Ractive$updateModel };
var callsSuper = /super\s\(|\.call\s*\(\s*this/;
function extend () {  var options = [], len = arguments.length;  while ( len-- ) options[ len ] = arguments[ len ];
if( !options.length ) {   return extendOne( this );  } else {   return options.reduce( extendOne, this );  } }
function extendWith ( Class, options ) {  if ( options === void 0 ) options = {};
return extendOne( this, options, Class ); }
function extendOne ( Parent, options, Target ) {  if ( options === void 0 ) options = {};
var proto;  var Child = typeof Target === 'function' && Target;
if ( options.prototype instanceof Ractive ) {   throw new Error( "Ractive no longer supports multiple inheritance." );  }
if ( Child ) {   if ( !( Child.prototype instanceof Parent ) ) {    throw new Error( "Only classes that inherit the appropriate prototype may be used with extend" );   }   if ( !callsSuper.test( Child.toString() ) ) {    throw new Error( "Only classes that call super in their constructor may be used with extend" );   }
proto = Child.prototype;  } else {   Child = function ( options ) {    if ( !( this instanceof Child ) ) { return new Child( options ); }
construct( this, options || {} );    initialise( this, options || {}, {} );   };
proto = Object.create( Parent.prototype );   proto.constructor = Child;
Child.prototype = proto;  }
// Static properties  Object.defineProperties( Child, {   // alias prototype as defaults   defaults: { value: proto },
// extendable   extend: { value: extend, writable: true, configurable: true },   extendClass: { value: extendWith, writable: true, configurable: true },
// Parent - for IE8, can't use Object.getPrototypeOf   _Parent: { value: Parent }  });
// extend configuration  config.extend( Parent, proto, options );
// store event and observer registries on the constructor when extending  Child._on = ( Parent._on || [] ).concat( toPairs( options.on ) );  Child._observe = ( Parent._observe || [] ).concat( toPairs( options.observe ) );
// attribute defs are not inherited, but they need to be stored  if ( options.attributes ) {   var attrs;
// allow an array of optional props or an object with arrays for optional and required props   if ( Array.isArray( options.attributes ) ) {    attrs = { optional: options.attributes, required: [] };   } else {    attrs = options.attributes;   }
// make sure the requisite keys actually store arrays   if ( !Array.isArray( attrs.required ) ) { attrs.required = []; }   if ( !Array.isArray( attrs.optional ) ) { attrs.optional = []; }
Child.attributes = attrs;  }
dataConfigurator.extend( Parent, proto, options );
if ( options.computed ) {   proto.computed = Object.assign( Object.create( Parent.prototype.computed ), options.computed );  }
return Child; }
function joinKeys () {  var keys = [], len = arguments.length;  while ( len-- ) keys[ len ] = arguments[ len ];
return keys.map( escapeKey ).join( '.' ); }
function splitKeypath$1 ( keypath ) {  return splitKeypath( keypath ).map( unescapeKey ); }
function findPlugin(name, type, instance) {  return findInViewHierarchy(type, instance, name); }
function Ractive ( options ) {  if ( !( this instanceof Ractive ) ) { return new Ractive( options ); }
construct( this, options || {} );  initialise( this, options || {}, {} ); }
// check to see if we're being asked to force Ractive as a global for some weird environments if ( win && !win.Ractive ) {  var opts = ; var script = document.currentScript || document.querySelector( 'script[data-ractive-options]' );
if ( script ) { opts = script.getAttribute( 'data-ractive-options' ) || ; }
if ( ~opts.indexOf( 'ForceGlobal' ) ) { win.Ractive = Ractive; } }
Object.assign( Ractive.prototype, RactiveProto, defaults ); Ractive.prototype.constructor = Ractive;
// alias prototype as `defaults` Ractive.defaults = Ractive.prototype;
// share defaults with the parser shared.defaults = Ractive.defaults; shared.Ractive = Ractive;
// static properties Object.defineProperties( Ractive, {
// debug flag  DEBUG:            { writable: true, value: true },  DEBUG_PROMISES:   { writable: true, value: true },
// static methods:  extend:           { value: extend },  extendWith:       { value: extendWith },  escapeKey:        { value: escapeKey },  getContext:       { value: getContext$2 },  getNodeInfo:      { value: getNodeInfo$1 },  joinKeys:         { value: joinKeys },  parse:            { value: parse },  splitKeypath:     { value: splitKeypath$1 },  unescapeKey:      { value: unescapeKey },  getCSS:           { value: getCSS },  normaliseKeypath: { value: normalise },  findPlugin:       { value: findPlugin },  evalObjectString: { value: parseJSON },
// support  enhance:          { writable: true, value: false },  svg:              { value: svg },
// version  VERSION:          { value: '0.9.0' },
// plugins  adaptors:         { writable: true, value: {} },  components:       { writable: true, value: {} },  decorators:       { writable: true, value: {} },  easing:           { writable: true, value: easing },  events:           { writable: true, value: {} },  interpolators:    { writable: true, value: interpolators },  partials:         { writable: true, value: {} },  transitions:      { writable: true, value: {} } });
return Ractive;
}))); //# sourceMappingURL=ractive.js.map </script>
<script>// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
// This is CodeMirror ( http://codemirror.net ), a code editor // implemented in JavaScript on top of the browser's DOM. // // You can find some technical background for some of the code below // at http://marijnhaverbeke.nl/blog/#cm-internals .
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  typeof define === 'function' && define.amd ? define(factory) :  (global.CodeMirror = factory());
}(this, (function () { 'use strict';
// Kludges for bugs and behavior differences that can't be feature // detected are enabled based on userAgent etc sniffing. var userAgent = navigator.userAgent var platform = navigator.platform
var gecko = /gecko\/\d/i.test(userAgent) var ie_upto10 = /MSIE \d/.test(userAgent) var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent) var edge = /Edge\/(\d+)/.exec(userAgent) var ie = ie_upto10 || ie_11up || edge var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]) var webkit = !edge && /WebKit\//.test(userAgent) var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent) var chrome = !edge && /Chrome\//.test(userAgent) var presto = /Opera\//.test(userAgent) var safari = /Apple Computer/.test(navigator.vendor) var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent) var phantom = /PhantomJS/.test(userAgent)
var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent) // This is woefully incomplete. Suggestions for alternative methods welcome. var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent) var mac = ios || /Mac/.test(platform) var chromeOS = /\bCrOS\b/.test(userAgent) var windows = /win/i.test(platform)
var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/) if (presto_version) { presto_version = Number(presto_version[1]) } if (presto_version && presto_version >= 15) { presto = false; webkit = true } // Some browsers use the wrong event properties to signal cmd/ctrl on OS X var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11)) var captureRightClick = gecko || (ie && ie_version >= 9)
function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }
var rmClass = function(node, cls) {
var current = node.className  var match = classTest(cls).exec(current)  if (match) {    var after = current.slice(match.index + match[0].length)    node.className = current.slice(0, match.index) + (after ? match[1] + after : "")  }
}
function removeChildren(e) {
for (var count = e.childNodes.length; count > 0; --count)    { e.removeChild(e.firstChild) }  return e
}
function removeChildrenAndAdd(parent, e) {
return removeChildren(parent).appendChild(e)
}
function elt(tag, content, className, style) {
var e = document.createElement(tag)  if (className) { e.className = className }  if (style) { e.style.cssText = style }  if (typeof content == "string") { e.appendChild(document.createTextNode(content)) }  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]) } }  return e
}
var range if (document.createRange) { range = function(node, start, end, endNode) {
var r = document.createRange()  r.setEnd(endNode || node, end)  r.setStart(node, start)  return r
} } else { range = function(node, start, end) {
var r = document.body.createTextRange()  try { r.moveToElementText(node.parentNode) }  catch(e) { return r }  r.collapse(true)  r.moveEnd("character", end)  r.moveStart("character", start)  return r
} }
function contains(parent, child) {
if (child.nodeType == 3) // Android browser always returns false when child is a textnode    { child = child.parentNode }  if (parent.contains)    { return parent.contains(child) }  do {    if (child.nodeType == 11) { child = child.host }    if (child == parent) { return true }  } while (child = child.parentNode)
}
function activeElt() {
// IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.  // IE < 10 will throw when accessed while the page is loading or in an iframe.  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.  var activeElement  try {    activeElement = document.activeElement  } catch(e) {    activeElement = document.body || null  }  while (activeElement && activeElement.root && activeElement.root.activeElement)    { activeElement = activeElement.root.activeElement }  return activeElement
}
function addClass(node, cls) {
var current = node.className  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls }
} function joinClasses(a, b) {
var as = a.split(" ")  for (var i = 0; i < as.length; i++)    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i] } }  return b
}
var selectInput = function(node) { node.select() } if (ios) // Mobile Safari apparently has a bug where select() is broken.
{ selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length } }
else if (ie) // Suppress mysterious IE10 errors
{ selectInput = function(node) { try { node.select() } catch(_e) {} } }
function bind(f) {
var args = Array.prototype.slice.call(arguments, 1)  return function(){return f.apply(null, args)}
}
function copyObj(obj, target, overwrite) {
if (!target) { target = {} }  for (var prop in obj)    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))      { target[prop] = obj[prop] } }  return target
}
// Counts the column offset in a string, taking tabs into account. // Used mostly to find indentation. function countColumn(string, end, tabSize, startIndex, startValue) {
if (end == null) {    end = string.search(/[^\s\u00a0]/)    if (end == -1) { end = string.length }  }  for (var i = startIndex || 0, n = startValue || 0;;) {    var nextTab = string.indexOf("\t", i)    if (nextTab < 0 || nextTab >= end)      { return n + (end - i) }    n += nextTab - i    n += tabSize - (n % tabSize)    i = nextTab + 1  }
}
var Delayed = function() {this.id = null}; Delayed.prototype.set = function (ms, f) {
clearTimeout(this.id)  this.id = setTimeout(f, ms)
};
function indexOf(array, elt) {
for (var i = 0; i < array.length; ++i)    { if (array[i] == elt) { return i } }  return -1
}
// Number of pixels added to scroller and sizer to hide scrollbar var scrollerGap = 30
// Returned or thrown by various protocols to signal 'I'm not // handling this'. var Pass = {toString: function(){return "CodeMirror.Pass"}}
// Reused option objects for setSelection & friends var sel_dontScroll = {scroll: false}; var sel_mouse = {origin: "*mouse"}; var sel_move = {origin: "+move"}; // The inverse of countColumn -- find the offset that corresponds to // a particular column. function findColumn(string, goal, tabSize) {
for (var pos = 0, col = 0;;) {    var nextTab = string.indexOf("\t", pos)    if (nextTab == -1) { nextTab = string.length }    var skipped = nextTab - pos    if (nextTab == string.length || col + skipped >= goal)      { return pos + Math.min(skipped, goal - col) }    col += nextTab - pos    col += tabSize - (col % tabSize)    pos = nextTab + 1    if (col >= goal) { return pos }  }
}
var spaceStrs = [""] function spaceStr(n) {
while (spaceStrs.length <= n)    { spaceStrs.push(lst(spaceStrs) + " ") }  return spaceStrs[n]
}
function lst(arr) { return arr[arr.length-1] }
function map(array, f) {
var out = []  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i) }  return out
}
function insertSorted(array, value, score) {
var pos = 0, priority = score(value)  while (pos < array.length && score(array[pos]) <= priority) { pos++ } array.splice(pos, 0, value)
}
function nothing() {}
function createObj(base, props) {
var inst  if (Object.create) {    inst = Object.create(base)  } else {    nothing.prototype = base    inst = new nothing()  }  if (props) { copyObj(props, inst) }  return inst
}
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/ function isWordCharBasic(ch) {
return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
} function isWordChar(ch, helper) {
if (!helper) { return isWordCharBasic(ch) }  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }  return helper.test(ch)
}
function isEmpty(obj) {
for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }  return true
}
// Extending unicode characters. A series of a non-extending char + // any number of extending chars is treated as a single unit as far // as editing and measuring is concerned. This is not fully correct, // since some scripts/fonts/browsers also treat other configurations // of code points as a group. var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/ function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }
// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range. function skipExtendingChars(str, pos, dir) {
while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir }  return pos
}
// Returns the value from the range [`from`; `to`] that satisfies // `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`. function findFirst(pred, from, to) {
for (;;) {    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }    var mid = Math.floor((from + to) / 2)    if (pred(mid)) { to = mid }    else { from = mid }  }
}
// The display handles the DOM integration, both for input reading // and content drawing. It holds references to DOM nodes and // display-related state.
function Display(place, doc, input) {
var d = this  this.input = input
// Covers bottom-right square when both scrollbars are present.  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler")  d.scrollbarFiller.setAttribute("cm-not-content", "true")  // Covers bottom of gutter when coverGutterNextToScrollbar is on  // and h scrollbar is present.  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler")  d.gutterFiller.setAttribute("cm-not-content", "true")  // Will contain the actual code, positioned to cover the viewport.  d.lineDiv = elt("div", null, "CodeMirror-code")  // Elements are added to these to represent selection and cursors.  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1")  d.cursorDiv = elt("div", null, "CodeMirror-cursors")  // A visibility: hidden element used to find the size of things.  d.measure = elt("div", null, "CodeMirror-measure")  // When lines outside of the viewport are measured, they are drawn in this.  d.lineMeasure = elt("div", null, "CodeMirror-measure")  // Wraps everything that needs to exist inside the vertically-padded coordinate system  d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],                    null, "position: relative; outline: none")  // Moved around its parent to cover visible view.  d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative")  // Set to the height of the document, allowing scrolling.  d.sizer = elt("div", [d.mover], "CodeMirror-sizer")  d.sizerWidth = null  // Behavior of elts with overflow: auto and padding is  // inconsistent across browsers. This is used to ensure the  // scrollable area is big enough.  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;")  // Will contain the gutters, if any.  d.gutters = elt("div", null, "CodeMirror-gutters")  d.lineGutter = null  // Actual scrollable element.  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll")  d.scroller.setAttribute("tabIndex", "-1")  // The element in which the editor lives.  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror")
// Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0 }  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true }
if (place) {    if (place.appendChild) { place.appendChild(d.wrapper) }    else { place(d.wrapper) }  }
// Current rendered range (may be bigger than the view window).  d.viewFrom = d.viewTo = doc.first  d.reportedViewFrom = d.reportedViewTo = doc.first  // Information about the rendered lines.  d.view = []  d.renderedView = null  // Holds info about a single rendered line when it was rendered  // for measurement, while not in view.  d.externalMeasured = null  // Empty space (in pixels) above the view  d.viewOffset = 0  d.lastWrapHeight = d.lastWrapWidth = 0  d.updateLineNumbers = null
d.nativeBarWidth = d.barHeight = d.barWidth = 0  d.scrollbarsClipped = false
// Used to only resize the line number gutter when necessary (when  // the amount of lines crosses a boundary that makes its width change)  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null  // Set to true when a non-horizontal-scrolling line widget is  // added. As an optimization, line widget aligning is skipped when  // this is false.  d.alignWidgets = false
d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null
// Tracks the maximum line length so that the horizontal scrollbar  // can be kept static when scrolling.  d.maxLine = null  d.maxLineLength = 0  d.maxLineChanged = false
// Used for measuring wheel scrolling granularity  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null
// True when shift is held down.  d.shift = false
// Used to track whether anything happened since the context menu  // was opened.  d.selForContextMenu = null
d.activeTouch = null
input.init(d)
}
// Find the line object corresponding to the given line number. function getLine(doc, n) {
n -= doc.first  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }  var chunk = doc  while (!chunk.lines) {    for (var i = 0;; ++i) {      var child = chunk.children[i], sz = child.chunkSize()      if (n < sz) { chunk = child; break }      n -= sz    }  }  return chunk.lines[n]
}
// Get the part of a document between two positions, as an array of // strings. function getBetween(doc, start, end) {
var out = [], n = start.line  doc.iter(start.line, end.line + 1, function (line) {    var text = line.text    if (n == end.line) { text = text.slice(0, end.ch) }    if (n == start.line) { text = text.slice(start.ch) }    out.push(text)    ++n  })  return out
} // Get the lines between from and to, as array of strings. function getLines(doc, from, to) {
var out = []  doc.iter(from, to, function (line) { out.push(line.text) }) // iter aborts when callback returns truthy value  return out
}
// Update the height of a line, propagating the height change // upwards to parent nodes. function updateLineHeight(line, height) {
var diff = height - line.height  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff } }
}
// Given a line object, find its line number by walking up through // its parent links. function lineNo(line) {
if (line.parent == null) { return null }  var cur = line.parent, no = indexOf(cur.lines, line)  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {    for (var i = 0;; ++i) {      if (chunk.children[i] == cur) { break }      no += chunk.children[i].chunkSize()    }  }  return no + cur.first
}
// Find the line at the given vertical position, using the height // information in the document tree. function lineAtHeight(chunk, h) {
var n = chunk.first  outer: do {    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {      var child = chunk.children[i$1], ch = child.height      if (h < ch) { chunk = child; continue outer }      h -= ch      n += child.chunkSize()    }    return n  } while (!chunk.lines)  var i = 0  for (; i < chunk.lines.length; ++i) {    var line = chunk.lines[i], lh = line.height    if (h < lh) { break }    h -= lh  }  return n + i
}
function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}
function lineNumberFor(options, i) {
return String(options.lineNumberFormatter(i + options.firstLineNumber))
}
// A Pos instance represents a position within the text. function Pos(line, ch, sticky) {
if ( sticky === void 0 ) sticky = null;
if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }  this.line = line  this.ch = ch  this.sticky = sticky
}
// Compare two positions, return 0 if they are the same, a negative // number when a is less, and a positive number otherwise. function cmp(a, b) { return a.line - b.line || a.ch - b.ch }
function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }
function copyPos(x) {return Pos(x.line, x.ch)} function maxPos(a, b) { return cmp(a, b) < 0 ? b : a } function minPos(a, b) { return cmp(a, b) < 0 ? a : b }
// Most of the external API clips given positions to make sure they // actually exist within the document. function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))} function clipPos(doc, pos) {
if (pos.line < doc.first) { return Pos(doc.first, 0) }  var last = doc.first + doc.size - 1  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }  return clipToLen(pos, getLine(doc, pos.line).text.length)
} function clipToLen(pos, linelen) {
var ch = pos.ch  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }  else if (ch < 0) { return Pos(pos.line, 0) }  else { return pos }
} function clipPosArray(doc, array) {
var out = []  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]) }  return out
}
// Optimize some code when these features are not used. var sawReadOnlySpans = false; var sawCollapsedSpans = false; function seeReadOnlySpans() {
sawReadOnlySpans = true
}
function seeCollapsedSpans() {
sawCollapsedSpans = true
}
// TEXTMARKER SPANS
function MarkedSpan(marker, from, to) {
this.marker = marker  this.from = from; this.to = to
}
// Search an array of spans for a span matching the given marker. function getMarkedSpanFor(spans, marker) {
if (spans) { for (var i = 0; i < spans.length; ++i) {    var span = spans[i]    if (span.marker == marker) { return span }  } }
} // Remove a span from an array, returning undefined if no spans are // left (we don't store arrays for lines without spans). function removeMarkedSpan(spans, span) {
var r  for (var i = 0; i < spans.length; ++i)    { if (spans[i] != span) { (r || (r = [])).push(spans[i]) } }  return r
} // Add a span to a line. function addMarkedSpan(line, span) {
line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span]  span.marker.attachLine(line)
}
// Used for the algorithm that adjusts markers for a change in the // document. These functions cut an array of spans at a given // character position, returning an array of remaining chunks (or // undefined if nothing remains). function markedSpansBefore(old, startCh, isInsert) {
var nw  if (old) { for (var i = 0; i < old.length; ++i) {    var span = old[i], marker = span.marker    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh)    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)  ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))    }  } }  return nw
} function markedSpansAfter(old, endCh, isInsert) {
var nw  if (old) { for (var i = 0; i < old.length; ++i) {    var span = old[i], marker = span.marker    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh)    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)  ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,                                            span.to == null ? null : span.to - endCh))    }  } }  return nw
}
// Given a change object, compute the new set of marker spans that // cover the line in which the change took place. Removes spans // entirely within the change, reconnects spans belonging to the // same marker that appear on both sides of the change, and cuts off // spans partially within the change. Returns an array of span // arrays with one element for each line in (after) the change. function stretchSpansOverChange(doc, change) {
if (change.full) { return null }  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans  if (!oldFirst && !oldLast) { return null }
var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0  // Get the spans that 'stick out' on both sides  var first = markedSpansBefore(oldFirst, startCh, isInsert)  var last = markedSpansAfter(oldLast, endCh, isInsert)
// Next, merge those two ends  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0)  if (first) {    // Fix up .to properties of first    for (var i = 0; i < first.length; ++i) {      var span = first[i]      if (span.to == null) {        var found = getMarkedSpanFor(last, span.marker)        if (!found) { span.to = startCh }        else if (sameLine) { span.to = found.to == null ? null : found.to + offset }      }    }  }  if (last) {    // Fix up .from in last (or move them into first in case of sameLine)    for (var i$1 = 0; i$1 < last.length; ++i$1) {      var span$1 = last[i$1]      if (span$1.to != null) { span$1.to += offset }      if (span$1.from == null) {        var found$1 = getMarkedSpanFor(first, span$1.marker)        if (!found$1) {          span$1.from = offset          if (sameLine) { (first || (first = [])).push(span$1) }        }      } else {        span$1.from += offset        if (sameLine) { (first || (first = [])).push(span$1) }      }    }  }  // Make sure we didn't create any zero-length spans  if (first) { first = clearEmptySpans(first) }  if (last && last != first) { last = clearEmptySpans(last) }
var newMarkers = [first]  if (!sameLine) {    // Fill gap with whole-line-spans    var gap = change.text.length - 2, gapMarkers    if (gap > 0 && first)      { for (var i$2 = 0; i$2 < first.length; ++i$2)        { if (first[i$2].to == null)          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)) } } }    for (var i$3 = 0; i$3 < gap; ++i$3)      { newMarkers.push(gapMarkers) }    newMarkers.push(last)  }  return newMarkers
}
// Remove spans that are empty and don't have a clearWhenEmpty // option of false. function clearEmptySpans(spans) {
for (var i = 0; i < spans.length; ++i) {    var span = spans[i]    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)      { spans.splice(i--, 1) }  }  if (!spans.length) { return null }  return spans
}
// Used to 'clip' out readOnly ranges when making a change. function removeReadOnlyRanges(doc, from, to) {
var markers = null  doc.iter(from.line, to.line + 1, function (line) {    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {      var mark = line.markedSpans[i].marker      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))        { (markers || (markers = [])).push(mark) }    } }  })  if (!markers) { return null }  var parts = [{from: from, to: to}]  for (var i = 0; i < markers.length; ++i) {    var mk = markers[i], m = mk.find(0)    for (var j = 0; j < parts.length; ++j) {      var p = parts[j]      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to)      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)        { newParts.push({from: p.from, to: m.from}) }      if (dto > 0 || !mk.inclusiveRight && !dto)        { newParts.push({from: m.to, to: p.to}) }      parts.splice.apply(parts, newParts)      j += newParts.length - 3    }  }  return parts
}
// Connect or disconnect spans from a line. function detachMarkedSpans(line) {
var spans = line.markedSpans  if (!spans) { return }  for (var i = 0; i < spans.length; ++i)    { spans[i].marker.detachLine(line) }  line.markedSpans = null
} function attachMarkedSpans(line, spans) {
if (!spans) { return }  for (var i = 0; i < spans.length; ++i)    { spans[i].marker.attachLine(line) }  line.markedSpans = spans
}
// Helpers used when computing which overlapping collapsed span // counts as the larger one. function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 } function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }
// Returns a number indicating which of two overlapping collapsed // spans is larger (and thus includes the other). Falls back to // comparing ids when the spans cover exactly the same range. function compareCollapsedMarkers(a, b) {
var lenDiff = a.lines.length - b.lines.length  if (lenDiff != 0) { return lenDiff }  var aPos = a.find(), bPos = b.find()  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b)  if (fromCmp) { return -fromCmp }  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b)  if (toCmp) { return toCmp }  return b.id - a.id
}
// Find out whether a line ends or starts in a collapsed span. If // so, return the marker for that span. function collapsedSpanAtSide(line, start) {
var sps = sawCollapsedSpans && line.markedSpans, found  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {    sp = sps[i]    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))      { found = sp.marker }  } }  return found
} function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) } function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }
// Test whether there exists a collapsed span that partially // overlaps (covers the start or end, but not both) of a new span. // Such overlap is not allowed. function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
var line = getLine(doc, lineNo)  var sps = sawCollapsedSpans && line.markedSpans  if (sps) { for (var i = 0; i < sps.length; ++i) {    var sp = sps[i]    if (!sp.marker.collapsed) { continue }    var found = sp.marker.find(0)    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker)    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker)    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))      { return true }  } }
}
// A visual line is a line as drawn on the screen. Folding, for // example, can cause multiple logical lines to appear on the same // visual line. This finds the start of the visual line that the // given line is part of (usually that is the line itself). function visualLine(line) {
var merged  while (merged = collapsedSpanAtStart(line))    { line = merged.find(-1, true).line }  return line
}
function visualLineEnd(line) {
var merged  while (merged = collapsedSpanAtEnd(line))    { line = merged.find(1, true).line }  return line
}
// Returns an array of logical lines that continue the visual line // started by the argument, or undefined if there are no such lines. function visualLineContinued(line) {
var merged, lines  while (merged = collapsedSpanAtEnd(line)) {    line = merged.find(1, true).line  ;(lines || (lines = [])).push(line)  }  return lines
}
// Get the line number of the start of the visual line that the // given line number is part of. function visualLineNo(doc, lineN) {
var line = getLine(doc, lineN), vis = visualLine(line)  if (line == vis) { return lineN }  return lineNo(vis)
}
// Get the line number of the start of the next visual line after // the given line. function visualLineEndNo(doc, lineN) {
if (lineN > doc.lastLine()) { return lineN }  var line = getLine(doc, lineN), merged  if (!lineIsHidden(doc, line)) { return lineN }  while (merged = collapsedSpanAtEnd(line))    { line = merged.find(1, true).line }  return lineNo(line) + 1
}
// Compute whether a line is hidden. Lines count as hidden when they // are part of a visual line that starts with another line, or when // they are entirely covered by collapsed, non-widget span. function lineIsHidden(doc, line) {
var sps = sawCollapsedSpans && line.markedSpans  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {    sp = sps[i]    if (!sp.marker.collapsed) { continue }    if (sp.from == null) { return true }    if (sp.marker.widgetNode) { continue }    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))      { return true }  } }
} function lineIsHiddenInner(doc, line, span) {
if (span.to == null) {    var end = span.marker.find(1, true)    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))  }  if (span.marker.inclusiveRight && span.to == line.text.length)    { return true }  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {    sp = line.markedSpans[i]    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) { return true }  }
}
// Find the height above the given line. function heightAtLine(lineObj) {
lineObj = visualLine(lineObj)
var h = 0, chunk = lineObj.parent  for (var i = 0; i < chunk.lines.length; ++i) {    var line = chunk.lines[i]    if (line == lineObj) { break }    else { h += line.height }  }  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {      var cur = p.children[i$1]      if (cur == chunk) { break }      else { h += cur.height }    }  }  return h
}
// Compute the character length of a line, taking into account // collapsed ranges (see markText) that might hide parts, and join // other lines onto it. function lineLength(line) {
if (line.height == 0) { return 0 }  var len = line.text.length, merged, cur = line  while (merged = collapsedSpanAtStart(cur)) {    var found = merged.find(0, true)    cur = found.from.line    len += found.from.ch - found.to.ch  }  cur = line  while (merged = collapsedSpanAtEnd(cur)) {    var found$1 = merged.find(0, true)    len -= cur.text.length - found$1.from.ch    cur = found$1.to.line    len += cur.text.length - found$1.to.ch  }  return len
}
// Find the longest line in the document. function findMaxLine(cm) {
var d = cm.display, doc = cm.doc  d.maxLine = getLine(doc, doc.first)  d.maxLineLength = lineLength(d.maxLine)  d.maxLineChanged = true  doc.iter(function (line) {    var len = lineLength(line)    if (len > d.maxLineLength) {      d.maxLineLength = len      d.maxLine = line    }  })
}
// BIDI HELPERS
function iterateBidiSections(order, from, to, f) {
if (!order) { return f(from, to, "ltr") }  var found = false  for (var i = 0; i < order.length; ++i) {    var part = order[i]    if (part.from < to && part.to > from || from == to && part.to == from) {      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr")      found = true    }  }  if (!found) { f(from, to, "ltr") }
}
var bidiOther = null function getBidiPartAt(order, ch, sticky) {
var found  bidiOther = null  for (var i = 0; i < order.length; ++i) {    var cur = order[i]    if (cur.from < ch && cur.to > ch) { return i }    if (cur.to == ch) {      if (cur.from != cur.to && sticky == "before") { found = i }      else { bidiOther = i }    }    if (cur.from == ch) {      if (cur.from != cur.to && sticky != "before") { found = i }      else { bidiOther = i }    }  }  return found != null ? found : bidiOther
}
// Bidirectional ordering algorithm // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm // that this (partially) implements.
// One-char codes used for character types: // L (L):   Left-to-Right // R (R):   Right-to-Left // r (AL):  Right-to-Left Arabic // 1 (EN):  European Number // + (ES):  European Number Separator // % (ET):  European Number Terminator // n (AN):  Arabic Number // , (CS):  Common Number Separator // m (NSM): Non-Spacing Mark // b (BN):  Boundary Neutral // s (B):   Paragraph Separator // t (S):   Segment Separator // w (WS):  Whitespace // N (ON):  Other Neutrals
// Returns null if characters are ordered as they appear // (left-to-right), or an array of sections ({from, to, level} // objects) in the order in which they occur visually. var bidiOrdering = (function() {
// Character types for codepoints 0 to 0xff  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"  // Character types for codepoints 0x600 to 0x6f9  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111"  function charType(code) {    if (code <= 0xf7) { return lowTypes.charAt(code) }    else if (0x590 <= code && code <= 0x5f4) { return "R" }    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }    else if (0x6ee <= code && code <= 0x8ac) { return "r" }    else if (0x2000 <= code && code <= 0x200b) { return "w" }    else if (code == 0x200c) { return "b" }    else { return "L" }  }
var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/  // Browsers seem to always treat the boundaries of block elements as being L.  var outerType = "L"
function BidiSpan(level, from, to) {    this.level = level    this.from = from; this.to = to  }
return function(str) {    if (!bidiRE.test(str)) { return false }    var len = str.length, types = []    for (var i = 0; i < len; ++i)      { types.push(charType(str.charCodeAt(i))) }
// W1. Examine each non-spacing mark (NSM) in the level run, and    // change the type of the NSM to the type of the previous    // character. If the NSM is at the start of the level run, it will    // get the type of sor.    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {      var type = types[i$1]      if (type == "m") { types[i$1] = prev }      else { prev = type }    }
// W2. Search backwards from each instance of a European number    // until the first strong type (R, L, AL, or sor) is found. If an    // AL is found, change the type of the European number to Arabic    // number.    // W3. Change all ALs to R.    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {      var type$1 = types[i$2]      if (type$1 == "1" && cur == "r") { types[i$2] = "n" }      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R" } }    }
// W4. A single European separator between two European numbers    // changes to a European number. A single common separator between    // two numbers of the same type changes to that type.    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {      var type$2 = types[i$3]      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1" }      else if (type$2 == "," && prev$1 == types[i$3+1] && (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1 }      prev$1 = type$2    }
// W5. A sequence of European terminators adjacent to European    // numbers changes to all European numbers.    // W6. Otherwise, separators and terminators change to Other    // Neutral.    for (var i$4 = 0; i$4 < len; ++i$4) {      var type$3 = types[i$4]      if (type$3 == ",") { types[i$4] = "N" }      else if (type$3 == "%") {        var end = (void 0)        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N"        for (var j = i$4; j < end; ++j) { types[j] = replace }        i$4 = end - 1      }    }
// W7. Search backwards from each instance of a European number    // until the first strong type (R, L, or sor) is found. If an L is    // found, then change the type of the European number to L.    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {      var type$4 = types[i$5]      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L" }      else if (isStrong.test(type$4)) { cur$1 = type$4 }    }
// N1. A sequence of neutrals takes the direction of the    // surrounding strong text if the text on both sides has the same    // direction. European and Arabic numbers act as if they were R in    // terms of their influence on neutrals. Start-of-level-run (sor)    // and end-of-level-run (eor) are used at level run boundaries.    // N2. Any remaining neutrals take the embedding direction.    for (var i$6 = 0; i$6 < len; ++i$6) {      if (isNeutral.test(types[i$6])) {        var end$1 = (void 0)        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}        var before = (i$6 ? types[i$6-1] : outerType) == "L"        var after = (end$1 < len ? types[end$1] : outerType) == "L"        var replace$1 = before || after ? "L" : "R"        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1 }        i$6 = end$1 - 1      }    }
// Here we depart from the documented algorithm, in order to avoid    // building up an actual levels array. Since there are only three    // levels (0, 1, 2) in an implementation that doesn't take    // explicit embedding into account, we can build up the order on    // the fly, without following the level-based algorithm.    var order = [], m    for (var i$7 = 0; i$7 < len;) {      if (countsAsLeft.test(types[i$7])) {        var start = i$7        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}        order.push(new BidiSpan(0, start, i$7))      } else {        var pos = i$7, at = order.length        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}        for (var j$2 = pos; j$2 < i$7;) {          if (countsAsNum.test(types[j$2])) {            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)) }            var nstart = j$2            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}            order.splice(at, 0, new BidiSpan(2, nstart, j$2))            pos = j$2          } else { ++j$2 }        }        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)) }      }    }    if (order[0].level == 1 && (m = str.match(/^\s+/))) {      order[0].from = m[0].length      order.unshift(new BidiSpan(0, 0, m[0].length))    }    if (lst(order).level == 1 && (m = str.match(/\s+$/))) {      lst(order).to -= m[0].length      order.push(new BidiSpan(0, len - m[0].length, len))    }
return order  }
})()
// Get the bidi ordering for the given line (and cache it). Returns // false for lines that are fully left-to-right, and an array of // BidiSpan objects otherwise. function getOrder(line) {
var order = line.order  if (order == null) { order = line.order = bidiOrdering(line.text) }  return order
}
function moveCharLogically(line, ch, dir) {
var target = skipExtendingChars(line.text, ch + dir, dir)  return target < 0 || target > line.text.length ? null : target
}
function moveLogically(line, start, dir) {
var ch = moveCharLogically(line, start.ch, dir)  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
}
function endOfLine(visually, cm, lineObj, lineNo, dir) {
if (visually) {    var order = getOrder(lineObj)    if (order) {      var part = dir < 0 ? lst(order) : order[0]      var moveInStorageOrder = (dir < 0) == (part.level == 1)      var sticky = moveInStorageOrder ? "after" : "before"      var ch      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),      // it could be that the last bidi part is not on the last visual line,      // since visual lines contain content order-consecutive chunks.      // Thus, in rtl, we are looking for the first (content-order) character      // in the rtl chunk that is on the last line (that is, the same line      // as the last (content-order) character).      if (part.level > 0) {        var prep = prepareMeasureForLine(cm, lineObj)        ch = dir < 0 ? lineObj.text.length - 1 : 0        var targetTop = measureCharPrepared(cm, prep, ch).top        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch)        if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1, true) }      } else { ch = dir < 0 ? part.to : part.from }      return new Pos(lineNo, ch, sticky)    }  }  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
}
function moveVisually(cm, line, start, dir) {
var bidi = getOrder(line)  if (!bidi) { return moveLogically(line, start, dir) }  if (start.ch >= line.text.length) {    start.ch = line.text.length    start.sticky = "before"  } else if (start.ch <= 0) {    start.ch = 0    start.sticky = "after"  }  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos]  if (part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {    // Case 1: We move within an ltr part. Even with wrapped lines,    // nothing interesting happens.    return moveLogically(line, start, dir)  }
var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); }  var prep  var getWrappedLineExtent = function (ch) {    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }    prep = prep || prepareMeasureForLine(cm, line)    return wrappedLineExtentChar(cm, line, prep, ch)  }  var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch)
if (part.level % 2 == 1) {    var ch = mv(start, -dir)    if (ch != null && (dir > 0 ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {      // Case 2: We move within an rtl part on the same visual line      var sticky = dir < 0 ? "before" : "after"      return new Pos(start.line, ch, sticky)    }  }
// Case 3: Could not move within this bidi part in this visual line, so leave  // the current bidi part
var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder  ? new Pos(start.line, mv(ch, 1), "before")  : new Pos(start.line, ch, "after"); }
for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {      var part = bidi[partPos]      var moveInStorageOrder = (dir > 0) == (part.level != 1)      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1)      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }      ch = moveInStorageOrder ? part.from : mv(part.to, -1)      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }    }  }
// Case 3a: Look for other bidi parts on the same visual line  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent)  if (res) { return res }
// Case 3b: Look for other bidi parts on the next visual line  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1)  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh))    if (res) { return res }  }
// Case 4: Nowhere to move  return null
}
// EVENT HANDLING
// Lightweight event framework. on/off also work on DOM nodes, // registering native DOM handlers.
var noHandlers = []
var on = function(emitter, type, f) {
if (emitter.addEventListener) {    emitter.addEventListener(type, f, false)  } else if (emitter.attachEvent) {    emitter.attachEvent("on" + type, f)  } else {    var map = emitter._handlers || (emitter._handlers = {})    map[type] = (map[type] || noHandlers).concat(f)  }
}
function getHandlers(emitter, type) {
return emitter._handlers && emitter._handlers[type] || noHandlers
}
function off(emitter, type, f) {
if (emitter.removeEventListener) {    emitter.removeEventListener(type, f, false)  } else if (emitter.detachEvent) {    emitter.detachEvent("on" + type, f)  } else {    var map = emitter._handlers, arr = map && map[type]    if (arr) {      var index = indexOf(arr, f)      if (index > -1)        { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)) }    }  }
}
function signal(emitter, type /*, values...*/) {
var handlers = getHandlers(emitter, type)  if (!handlers.length) { return }  var args = Array.prototype.slice.call(arguments, 2)  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args) }
}
// The DOM events that CodeMirror handles can be overridden by // registering a (non-DOM) handler on the editor for the event name, // and preventDefault-ing the event in that handler. function signalDOMEvent(cm, e, override) {
if (typeof e == "string")    { e = {type: e, preventDefault: function() { this.defaultPrevented = true }} }  signal(cm, override || e.type, cm, e)  return e_defaultPrevented(e) || e.codemirrorIgnore
}
function signalCursorActivity(cm) {
var arr = cm._handlers && cm._handlers.cursorActivity  if (!arr) { return }  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = [])  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)    { set.push(arr[i]) } }
}
function hasHandler(emitter, type) {
return getHandlers(emitter, type).length > 0
}
// Add on and off methods to a constructor's prototype, to make // registering events on such objects more convenient. function eventMixin(ctor) {
ctor.prototype.on = function(type, f) {on(this, type, f)}  ctor.prototype.off = function(type, f) {off(this, type, f)}
}
// Due to the fact that we still support jurassic IE versions, some // compatibility wrappers are needed.
function e_preventDefault(e) {
if (e.preventDefault) { e.preventDefault() }  else { e.returnValue = false }
} function e_stopPropagation(e) {
if (e.stopPropagation) { e.stopPropagation() }  else { e.cancelBubble = true }
} function e_defaultPrevented(e) {
return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
} function e_stop(e) {e_preventDefault(e); e_stopPropagation(e)}
function e_target(e) {return e.target || e.srcElement} function e_button(e) {
var b = e.which  if (b == null) {    if (e.button & 1) { b = 1 }    else if (e.button & 2) { b = 3 }    else if (e.button & 4) { b = 2 }  }  if (mac && e.ctrlKey && b == 1) { b = 3 }  return b
}
// Detect drag-and-drop var dragAndDrop = function() {
// There is *some* kind of drag-and-drop support in IE6-8, but I  // couldn't get it to work yet.  if (ie && ie_version < 9) { return false }  var div = elt('div')  return "draggable" in div || "dragDrop" in div
}()
var zwspSupported function zeroWidthElement(measure) {
if (zwspSupported == null) {    var test = elt("span", "\u200b")    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]))    if (measure.firstChild.offsetHeight != 0)      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8) }  }  var node = zwspSupported ? elt("span", "\u200b") :    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px")  node.setAttribute("cm-text", "")  return node
}
// Feature-detect IE's crummy client rect reporting for bidi text var badBidiRects function hasBadBidiRects(measure) {
if (badBidiRects != null) { return badBidiRects }  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"))  var r0 = range(txt, 0, 1).getBoundingClientRect()  var r1 = range(txt, 1, 2).getBoundingClientRect()  removeChildren(measure)  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)  return badBidiRects = (r1.right - r0.right < 3)
}
// See if "".split is the broken IE version, if so, provide an // alternative way to split lines. var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
var pos = 0, result = [], l = string.length  while (pos <= l) {    var nl = string.indexOf("\n", pos)    if (nl == -1) { nl = string.length }    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl)    var rt = line.indexOf("\r")    if (rt != -1) {      result.push(line.slice(0, rt))      pos += rt + 1    } else {      result.push(line)      pos = nl + 1    }  }  return result
} : function (string) { return string.split(/\r\n?|\n/); }
var hasSelection = window.getSelection ? function (te) {
try { return te.selectionStart != te.selectionEnd }  catch(e) { return false }
} : function (te) {
var range  try {range = te.ownerDocument.selection.createRange()}  catch(e) {}  if (!range || range.parentElement() != te) { return false }  return range.compareEndPoints("StartToEnd", range) != 0
}
var hasCopyEvent = (function () {
var e = elt("div")  if ("oncopy" in e) { return true }  e.setAttribute("oncopy", "return;")  return typeof e.oncopy == "function"
})()
var badZoomedRects = null function hasBadZoomedRects(measure) {
if (badZoomedRects != null) { return badZoomedRects }  var node = removeChildrenAndAdd(measure, elt("span", "x"))  var normal = node.getBoundingClientRect()  var fromRange = range(node, 0, 1).getBoundingClientRect()  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
}
var modes = {}; var mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is // used by (legacy) mechanisms like loadmode.js to automatically // load a mode. (Preferred mechanism is the require/define calls.) function defineMode(name, mode) {
if (arguments.length > 2)    { mode.dependencies = Array.prototype.slice.call(arguments, 2) }  modes[name] = mode
}
function defineMIME(mime, spec) {
mimeModes[mime] = spec
}
// Given a MIME type, a {name, ...options} config object, or a name // string, return a mode config object. function resolveMode(spec) {
if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {    spec = mimeModes[spec]  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {    var found = mimeModes[spec.name]    if (typeof found == "string") { found = {name: found} }    spec = createObj(found, spec)    spec.name = found.name  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {    return resolveMode("application/xml")  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {    return resolveMode("application/json")  }  if (typeof spec == "string") { return {name: spec} }  else { return spec || {name: "null"} }
}
// Given a mode spec (anything that resolveMode accepts), find and // initialize an actual mode object. function getMode(options, spec) {
spec = resolveMode(spec)  var mfactory = modes[spec.name]  if (!mfactory) { return getMode(options, "text/plain") }  var modeObj = mfactory(options, spec)  if (modeExtensions.hasOwnProperty(spec.name)) {    var exts = modeExtensions[spec.name]    for (var prop in exts) {      if (!exts.hasOwnProperty(prop)) { continue }      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop] }      modeObj[prop] = exts[prop]    }  }  modeObj.name = spec.name  if (spec.helperType) { modeObj.helperType = spec.helperType }  if (spec.modeProps) { for (var prop$1 in spec.modeProps)    { modeObj[prop$1] = spec.modeProps[prop$1] } }
return modeObj
}
// This can be used to attach properties to mode objects from // outside the actual mode definition. var modeExtensions = {} function extendMode(mode, properties) {
var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {})  copyObj(properties, exts)
}
function copyState(mode, state) {
if (state === true) { return state }  if (mode.copyState) { return mode.copyState(state) }  var nstate = {}  for (var n in state) {    var val = state[n]    if (val instanceof Array) { val = val.concat([]) }    nstate[n] = val  }  return nstate
}
// Given a mode and a state (for that mode), find the inner mode and // state at the position that the state refers to. function innerMode(mode, state) {
var info  while (mode.innerMode) {    info = mode.innerMode(state)    if (!info || info.mode == mode) { break }    state = info.state    mode = info.mode  }  return info || {mode: mode, state: state}
}
function startState(mode, a1, a2) {
return mode.startState ? mode.startState(a1, a2) : true
}
// STRING STREAM
// Fed to the mode parsers, provides helper functions to make // parsers more succinct.
var StringStream = function(string, tabSize) {
this.pos = this.start = 0  this.string = string  this.tabSize = tabSize || 8  this.lastColumnPos = this.lastColumnValue = 0  this.lineStart = 0
};
StringStream.prototype.eol = function () {return this.pos >= this.string.length}; StringStream.prototype.sol = function () {return this.pos == this.lineStart}; StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined}; StringStream.prototype.next = function () {
if (this.pos < this.string.length)    { return this.string.charAt(this.pos++) }
}; StringStream.prototype.eat = function (match) {
var ch = this.string.charAt(this.pos)  var ok  if (typeof match == "string") { ok = ch == match }  else { ok = ch && (match.test ? match.test(ch) : match(ch)) } if (ok) {++this.pos; return ch}
}; StringStream.prototype.eatWhile = function (match) {
var start = this.pos  while (this.eat(match)){}  return this.pos > start
}; StringStream.prototype.eatSpace = function () {
var this$1 = this;
var start = this.pos  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos }  return this.pos > start
}; StringStream.prototype.skipToEnd = function () {this.pos = this.string.length}; StringStream.prototype.skipTo = function (ch) {
var found = this.string.indexOf(ch, this.pos)  if (found > -1) {this.pos = found; return true}
}; StringStream.prototype.backUp = function (n) {this.pos -= n}; StringStream.prototype.column = function () {
if (this.lastColumnPos < this.start) {    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)    this.lastColumnPos = this.start  }  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
}; StringStream.prototype.indentation = function () {
return countColumn(this.string, null, this.tabSize) -    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
}; StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
if (typeof pattern == "string") {    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; }    var substr = this.string.substr(this.pos, pattern.length)    if (cased(substr) == cased(pattern)) {      if (consume !== false) { this.pos += pattern.length }      return true    }  } else {    var match = this.string.slice(this.pos).match(pattern)    if (match && match.index > 0) { return null }    if (match && consume !== false) { this.pos += match[0].length }    return match  }
}; StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)}; StringStream.prototype.hideFirstChars = function (n, inner) {
this.lineStart += n  try { return inner() }  finally { this.lineStart -= n }
};
// Compute a style array (an array starting with a mode generation // -- for invalidation -- followed by pairs of end positions and // style strings), which is used to highlight the tokens on the // line. function highlightLine(cm, line, state, forceToEnd) {
// A styles array always starts with a number identifying the  // mode/overlays that it is based on (for easy invalidation).  var st = [cm.state.modeGen], lineClasses = {}  // Compute the base array of styles  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },    lineClasses, forceToEnd)
// Run overlays, adjust style array.  var loop = function ( o ) {    var overlay = cm.state.overlays[o], i = 1, at = 0    runMode(cm, line.text, overlay.mode, true, function (end, style) {      var start = i      // Ensure there's a token end at the current position, and that i points at it      while (at < end) {        var i_end = st[i]        if (i_end > end)          { st.splice(i, 1, end, st[i+1], i_end) }        i += 2        at = Math.min(end, i_end)      }      if (!style) { return }      if (overlay.opaque) {        st.splice(start, i - start, end, "overlay " + style)        i = start + 2      } else {        for (; start < i; start += 2) {          var cur = st[start+1]          st[start+1] = (cur ? cur + " " : "") + "overlay " + style        }      }    }, lineClasses)  };
for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );
return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
}
function getLineStyles(cm, line, updateFrontier) {
if (!line.styles || line.styles[0] != cm.state.modeGen) {    var state = getStateBefore(cm, lineNo(line))    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state)    line.stateAfter = state    line.styles = result.styles    if (result.classes) { line.styleClasses = result.classes }    else if (line.styleClasses) { line.styleClasses = null }    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++ }  }  return line.styles
}
function getStateBefore(cm, n, precise) {
var doc = cm.doc, display = cm.display  if (!doc.mode.startState) { return true }  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter  if (!state) { state = startState(doc.mode) }  else { state = copyState(doc.mode, state) }  doc.iter(pos, n, function (line) {    processLine(cm, line.text, state)    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo    line.stateAfter = save ? copyState(doc.mode, state) : null    ++pos  })  if (precise) { doc.frontier = pos }  return state
}
// Lightweight form of highlight -- proceed over this line and // update state, but don't save a style array. Used for lines that // aren't currently visible. function processLine(cm, text, state, startAt) {
var mode = cm.doc.mode  var stream = new StringStream(text, cm.options.tabSize)  stream.start = stream.pos = startAt || 0  if (text == "") { callBlankLine(mode, state) }  while (!stream.eol()) {    readToken(mode, stream, state)    stream.start = stream.pos  }
}
function callBlankLine(mode, state) {
if (mode.blankLine) { return mode.blankLine(state) }  if (!mode.innerMode) { return }  var inner = innerMode(mode, state)  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
}
function readToken(mode, stream, state, inner) {
for (var i = 0; i < 10; i++) {    if (inner) { inner[0] = innerMode(mode, state).mode }    var style = mode.token(stream, state)    if (stream.pos > stream.start) { return style }  }  throw new Error("Mode " + mode.name + " failed to advance stream.")
}
// Utility for getTokenAt and getLineTokens function takeToken(cm, pos, precise, asArray) {
var getObj = function (copy) { return ({    start: stream.start, end: stream.pos,    string: stream.current(),    type: style || null,    state: copy ? copyState(doc.mode, state) : state  }); }
var doc = cm.doc, mode = doc.mode, style  pos = clipPos(doc, pos)  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise)  var stream = new StringStream(line.text, cm.options.tabSize), tokens  if (asArray) { tokens = [] }  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {    stream.start = stream.pos    style = readToken(mode, stream, state)    if (asArray) { tokens.push(getObj(true)) }  }  return asArray ? tokens : getObj()
}
function extractLineClasses(type, output) {
if (type) { for (;;) {    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/)    if (!lineClass) { break }    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length)    var prop = lineClass[1] ? "bgClass" : "textClass"    if (output[prop] == null)      { output[prop] = lineClass[2] }    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))      { output[prop] += " " + lineClass[2] }  } }  return type
}
// Run the given mode's parser over a line, calling f for each token. function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
var flattenSpans = mode.flattenSpans  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans }  var curStart = 0, curStyle = null  var stream = new StringStream(text, cm.options.tabSize), style  var inner = cm.options.addModeClass && [null]  if (text == "") { extractLineClasses(callBlankLine(mode, state), lineClasses) }  while (!stream.eol()) {    if (stream.pos > cm.options.maxHighlightLength) {      flattenSpans = false      if (forceToEnd) { processLine(cm, text, state, stream.pos) }      stream.pos = text.length      style = null    } else {      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses)    }    if (inner) {      var mName = inner[0].name      if (mName) { style = "m-" + (style ? mName + " " + style : mName) }    }    if (!flattenSpans || curStyle != style) {      while (curStart < stream.start) {        curStart = Math.min(stream.start, curStart + 5000)        f(curStart, curStyle)      }      curStyle = style    }    stream.start = stream.pos  }  while (curStart < stream.pos) {    // Webkit seems to refuse to render text nodes longer than 57444    // characters, and returns inaccurate measurements in nodes    // starting around 5000 chars.    var pos = Math.min(stream.pos, curStart + 5000)    f(pos, curStyle)    curStart = pos  }
}
// Finds the line to start with when starting a parse. Tries to // find a line with a stateAfter, so that it can start with a // valid state. If that fails, it returns the line with the // smallest indentation, which tends to need the least context to // parse correctly. function findStartLine(cm, n, precise) {
var minindent, minline, doc = cm.doc  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)  for (var search = n; search > lim; --search) {    if (search <= doc.first) { return doc.first }    var line = getLine(doc, search - 1)    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }    var indented = countColumn(line.text, null, cm.options.tabSize)    if (minline == null || minindent > indented) {      minline = search - 1      minindent = indented    }  }  return minline
}
// LINE DATA STRUCTURE
// Line objects. These hold state related to a line, including // highlighting info (the styles array). var Line = function(text, markedSpans, estimateHeight) {
this.text = text  attachMarkedSpans(this, markedSpans)  this.height = estimateHeight ? estimateHeight(this) : 1
};
Line.prototype.lineNo = function () { return lineNo(this) }; eventMixin(Line)
// Change the content (text, markers) of a line. Automatically // invalidates cached information and tries to re-estimate the // line's height. function updateLine(line, text, markedSpans, estimateHeight) {
line.text = text  if (line.stateAfter) { line.stateAfter = null }  if (line.styles) { line.styles = null }  if (line.order != null) { line.order = null }  detachMarkedSpans(line)  attachMarkedSpans(line, markedSpans)  var estHeight = estimateHeight ? estimateHeight(line) : 1  if (estHeight != line.height) { updateLineHeight(line, estHeight) }
}
// Detach a line from the document tree and its markers. function cleanUpLine(line) {
line.parent = null  detachMarkedSpans(line)
}
// Convert a style as returned by a mode (either null, or a string // containing one or more styles) to a CSS style. This is cached, // and also looks for line-wide styles. var styleToClassCache = {}; var styleToClassCacheWithMode = {}; function interpretTokenStyle(style, options) {
if (!style || /^\s*$/.test(style)) { return null }  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache  return cache[style] ||    (cache[style] = style.replace(/\S+/g, "cm-$&"))
}
// Render the DOM representation of the text of a line. Also builds // up a 'line map', which points at the DOM nodes that represent // specific stretches of text, and is used by the measuring code. // The returned object contains the DOM node, this map, and // information about line-wide styles that were set by the mode. function buildLineContent(cm, lineView) {
// The padding-right forces the element to have a 'border', which  // is needed on Webkit to be able to get line-level bounding  // rectangles for it (in measureChar).  var content = elt("span", null, null, webkit ? "padding-right: .1px" : null)  var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,                 col: 0, pos: 0, cm: cm,                 trailingSpace: false,                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")}  // hide from accessibility tree  content.setAttribute("role", "presentation")  builder.pre.setAttribute("role", "presentation")  lineView.measure = {}
// Iterate over the logical lines that make up this visual line.  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0)    builder.pos = 0    builder.addToken = buildToken    // Optionally wire in some hacks into the token-rendering    // algorithm, to deal with browser quirks.    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))      { builder.addToken = buildTokenBadBidi(builder.addToken, order) }    builder.map = []    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line)    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate))    if (line.styleClasses) {      if (line.styleClasses.bgClass)        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "") }      if (line.styleClasses.textClass)        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "") }    }
// Ensure at least a single node is present, for measuring.    if (builder.map.length == 0)      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))) }
// Store the map and a cache object for the current logical line    if (i == 0) {      lineView.measure.map = builder.map      lineView.measure.cache = {}    } else {  ;(lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)  ;(lineView.measure.caches || (lineView.measure.caches = [])).push({})    }  }
// See issue #2901  if (webkit) {    var last = builder.content.lastChild    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))      { builder.content.className = "cm-tab-wrap-hack" }  }
signal(cm, "renderLine", cm, lineView.line, builder.pre)  if (builder.pre.className)    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || "") }
return builder
}
function defaultSpecialCharPlaceholder(ch) {
var token = elt("span", "\u2022", "cm-invalidchar")  token.title = "\\u" + ch.charCodeAt(0).toString(16)  token.setAttribute("aria-label", token.title)  return token
}
// Build up the DOM representation for a single token, and add it to // the line map. Takes care to render special characters separately. function buildToken(builder, text, style, startStyle, endStyle, title, css) {
if (!text) { return }  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text  var special = builder.cm.state.specialChars, mustWrap = false  var content  if (!special.test(text)) {    builder.col += text.length    content = document.createTextNode(displayText)    builder.map.push(builder.pos, builder.pos + text.length, content)    if (ie && ie_version < 9) { mustWrap = true }    builder.pos += text.length  } else {    content = document.createDocumentFragment()    var pos = 0    while (true) {      special.lastIndex = pos      var m = special.exec(text)      var skipped = m ? m.index - pos : text.length - pos      if (skipped) {        var txt = document.createTextNode(displayText.slice(pos, pos + skipped))        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])) }        else { content.appendChild(txt) }        builder.map.push(builder.pos, builder.pos + skipped, txt) builder.col += skipped        builder.pos += skipped      }      if (!m) { break }      pos += skipped + 1      var txt$1 = (void 0)      if (m[0] == "\t") {        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"))        txt$1.setAttribute("role", "presentation")        txt$1.setAttribute("cm-text", "\t")        builder.col += tabWidth      } else if (m[0] == "\r" || m[0] == "\n") {        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"))        txt$1.setAttribute("cm-text", m[0])        builder.col += 1      } else {        txt$1 = builder.cm.options.specialCharPlaceholder(m[0])        txt$1.setAttribute("cm-text", m[0])        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])) }        else { content.appendChild(txt$1) }        builder.col += 1      }      builder.map.push(builder.pos, builder.pos + 1, txt$1)      builder.pos++    }  }  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32  if (style || startStyle || endStyle || mustWrap || css) {    var fullStyle = style || ""    if (startStyle) { fullStyle += startStyle }    if (endStyle) { fullStyle += endStyle }    var token = elt("span", [content], fullStyle, css)    if (title) { token.title = title }    return builder.content.appendChild(token)  }  builder.content.appendChild(content)
}
function splitSpaces(text, trailingBefore) {
if (text.length > 1 && !/  /.test(text)) { return text }  var spaceBefore = trailingBefore, result = ""  for (var i = 0; i < text.length; i++) {    var ch = text.charAt(i)    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))      { ch = "\u00a0" }    result += ch    spaceBefore = ch == " "  }  return result
}
// Work around nonsense dimensions being reported for stretches of // right-to-left text. function buildTokenBadBidi(inner, order) {
return function (builder, text, style, startStyle, endStyle, title, css) {    style = style ? style + " cm-force-border" : "cm-force-border"    var start = builder.pos, end = start + text.length    for (;;) {      // Find the part that overlaps with the start of this text      var part = (void 0)      for (var i = 0; i < order.length; i++) {        part = order[i]        if (part.to > start && part.from <= start) { break }      }      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css)      startStyle = null      text = text.slice(part.to - start)      start = part.to    }  }
}
function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
var widget = !ignoreWidget && marker.widgetNode  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget) }  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {    if (!widget)      { widget = builder.content.appendChild(document.createElement("span")) }    widget.setAttribute("cm-marker", marker.id)  }  if (widget) {    builder.cm.display.input.setUneditable(widget)    builder.content.appendChild(widget)  }  builder.pos += size  builder.trailingSpace = false
}
// Outputs a number of spans to make up a line, taking highlighting // and marked text into account. function insertLineContent(line, builder, styles) {
var spans = line.markedSpans, allText = line.text, at = 0  if (!spans) {    for (var i$1 = 1; i$1 < styles.length; i$1+=2)      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)) }    return  }
var len = allText.length, pos = 0, i = 1, text = "", style, css  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed  for (;;) {    if (nextChange == pos) { // Update current marker set      spanStyle = spanEndStyle = spanStartStyle = title = css = ""      collapsed = null; nextChange = Infinity      var foundBookmarks = [], endStyles = (void 0)      for (var j = 0; j < spans.length; ++j) {        var sp = spans[j], m = sp.marker        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {          foundBookmarks.push(m)        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {          if (sp.to != null && sp.to != pos && nextChange > sp.to) {            nextChange = sp.to            spanEndStyle = ""          }          if (m.className) { spanStyle += " " + m.className }          if (m.css) { css = (css ? css + ";" : "") + m.css }          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle }          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to) }          if (m.title && !title) { title = m.title }          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))            { collapsed = sp }        } else if (sp.from > pos && nextChange > sp.from) {          nextChange = sp.from        }      }      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1] } } }
if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]) } }      if (collapsed && (collapsed.from || 0) == pos) {        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,                           collapsed.marker, collapsed.from == null)        if (collapsed.to == null) { return }        if (collapsed.to == pos) { collapsed = false }      }    }    if (pos >= len) { break }
var upto = Math.min(len, nextChange)    while (true) {      if (text) {        var end = pos + text.length        if (!collapsed) {          var tokenText = end > upto ? text.slice(0, upto - pos) : text          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css)        }        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}        pos = end        spanStartStyle = ""      }      text = allText.slice(at, at = styles[i++])      style = interpretTokenStyle(styles[i++], builder.cm.options)    }  }
}
// These objects are used to represent the visible (currently drawn) // part of the document. A LineView may correspond to multiple // logical lines, if those are connected by collapsed ranges. function LineView(doc, line, lineN) {
// The starting line  this.line = line  // Continuing lines, if any  this.rest = visualLineContinued(line)  // Number of logical lines in this visual line  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1  this.node = this.text = null  this.hidden = lineIsHidden(doc, line)
}
// Create a range of LineView objects for the given lines. function buildViewArray(cm, from, to) {
var array = [], nextPos  for (var pos = from; pos < to; pos = nextPos) {    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos)    nextPos = pos + view.size    array.push(view)  }  return array
}
var operationGroup = null
function pushOperation(op) {
if (operationGroup) {    operationGroup.ops.push(op)  } else {    op.ownsGroup = operationGroup = {      ops: [op],      delayedCallbacks: []    }  }
}
function fireCallbacksForOps(group) {
// Calls delayed callbacks and cursorActivity handlers until no // new ones appear  var callbacks = group.delayedCallbacks, i = 0  do {    for (; i < callbacks.length; i++)      { callbacks[i].call(null) }    for (var j = 0; j < group.ops.length; j++) {      var op = group.ops[j]      if (op.cursorActivityHandlers)        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm) } }    }  } while (i < callbacks.length)
}
function finishOperation(op, endCb) {
var group = op.ownsGroup  if (!group) { return }
try { fireCallbacksForOps(group) }  finally {    operationGroup = null    endCb(group)  }
}
var orphanDelayedCallbacks = null
// Often, we want to signal events at a point where we are in the // middle of some work, but don't want the handler to start calling // other methods on the editor, which might be in an inconsistent // state or simply not expect any other events to happen. // signalLater looks whether there are any handlers, and schedules // them to be executed when the last operation ends, or, if no // operation is active, when a timeout fires. function signalLater(emitter, type /*, values...*/) {
var arr = getHandlers(emitter, type)  if (!arr.length) { return }  var args = Array.prototype.slice.call(arguments, 2), list  if (operationGroup) {    list = operationGroup.delayedCallbacks  } else if (orphanDelayedCallbacks) {    list = orphanDelayedCallbacks  } else {    list = orphanDelayedCallbacks = []    setTimeout(fireOrphanDelayed, 0)  }  var loop = function ( i ) {    list.push(function () { return arr[i].apply(null, args); })  };
for (var i = 0; i < arr.length; ++i)    loop( i );
}
function fireOrphanDelayed() {
var delayed = orphanDelayedCallbacks  orphanDelayedCallbacks = null  for (var i = 0; i < delayed.length; ++i) { delayed[i]() }
}
// When an aspect of a line changes, a string is added to // lineView.changes. This updates the relevant part of the line's // DOM structure. function updateLineForChanges(cm, lineView, lineN, dims) {
for (var j = 0; j < lineView.changes.length; j++) {    var type = lineView.changes[j]    if (type == "text") { updateLineText(cm, lineView) }    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims) }    else if (type == "class") { updateLineClasses(lineView) }    else if (type == "widget") { updateLineWidgets(cm, lineView, dims) }  }  lineView.changes = null
}
// Lines with gutter elements, widgets or a background class need to // be wrapped, and have the extra elements added to the wrapper div function ensureLineWrapped(lineView) {
if (lineView.node == lineView.text) {    lineView.node = elt("div", null, null, "position: relative")    if (lineView.text.parentNode)      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text) }    lineView.node.appendChild(lineView.text)    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2 }  }  return lineView.node
}
function updateLineBackground(lineView) {
var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass  if (cls) { cls += " CodeMirror-linebackground" }  if (lineView.background) {    if (cls) { lineView.background.className = cls }    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null }  } else if (cls) {    var wrap = ensureLineWrapped(lineView)    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild)  }
}
// Wrapper around buildLineContent which will reuse the structure // in display.externalMeasured when possible. function getLineContent(cm, lineView) {
var ext = cm.display.externalMeasured  if (ext && ext.line == lineView.line) {    cm.display.externalMeasured = null    lineView.measure = ext.measure    return ext.built  }  return buildLineContent(cm, lineView)
}
// Redraw the line's text. Interacts with the background and text // classes because the mode may output tokens that influence these // classes. function updateLineText(cm, lineView) {
var cls = lineView.text.className  var built = getLineContent(cm, lineView)  if (lineView.text == lineView.node) { lineView.node = built.pre }  lineView.text.parentNode.replaceChild(built.pre, lineView.text)  lineView.text = built.pre  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {    lineView.bgClass = built.bgClass    lineView.textClass = built.textClass    updateLineClasses(lineView)  } else if (cls) {    lineView.text.className = cls  }
}
function updateLineClasses(lineView) {
updateLineBackground(lineView)  if (lineView.line.wrapClass)    { ensureLineWrapped(lineView).className = lineView.line.wrapClass }  else if (lineView.node != lineView.text)    { lineView.node.className = "" }  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass  lineView.text.className = textClass || ""
}
function updateLineGutter(cm, lineView, lineN, dims) {
if (lineView.gutter) {    lineView.node.removeChild(lineView.gutter)    lineView.gutter = null  }  if (lineView.gutterBackground) {    lineView.node.removeChild(lineView.gutterBackground)    lineView.gutterBackground = null  }  if (lineView.line.gutterClass) {    var wrap = ensureLineWrapped(lineView)    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"))    wrap.insertBefore(lineView.gutterBackground, lineView.text)  }  var markers = lineView.line.gutterMarkers  if (cm.options.lineNumbers || markers) {    var wrap$1 = ensureLineWrapped(lineView)    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"))    cm.display.input.setUneditable(gutterWrap)    wrap$1.insertBefore(gutterWrap, lineView.text)    if (lineView.line.gutterClass)      { gutterWrap.className += " " + lineView.line.gutterClass }    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))      { lineView.lineNumber = gutterWrap.appendChild(        elt("div", lineNumberFor(cm.options, lineN),            "CodeMirror-linenumber CodeMirror-gutter-elt",            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))) }    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id]      if (found)        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))) }    } }  }
}
function updateLineWidgets(cm, lineView, dims) {
if (lineView.alignable) { lineView.alignable = null }  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {    next = node.nextSibling    if (node.className == "CodeMirror-linewidget")      { lineView.node.removeChild(node) }  }  insertLineWidgets(cm, lineView, dims)
}
// Build a line's DOM representation from scratch function buildLineElement(cm, lineView, lineN, dims) {
var built = getLineContent(cm, lineView)  lineView.text = lineView.node = built.pre  if (built.bgClass) { lineView.bgClass = built.bgClass }  if (built.textClass) { lineView.textClass = built.textClass }
updateLineClasses(lineView)  updateLineGutter(cm, lineView, lineN, dims)  insertLineWidgets(cm, lineView, dims)  return lineView.node
}
// A lineView may contain multiple logical lines (when merged by // collapsed spans). The widgets for all of them need to be drawn. function insertLineWidgets(cm, lineView, dims) {
insertLineWidgetsFor(cm, lineView.line, lineView, dims, true)  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false) } }
}
function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
if (!line.widgets) { return }  var wrap = ensureLineWrapped(lineView)  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget")    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true") }    positionLineWidget(widget, node, lineView, dims)    cm.display.input.setUneditable(node)    if (allowAbove && widget.above)      { wrap.insertBefore(node, lineView.gutter || lineView.text) }    else      { wrap.appendChild(node) }    signalLater(widget, "redraw")  }
}
function positionLineWidget(widget, node, lineView, dims) {
if (widget.noHScroll) {  ;(lineView.alignable || (lineView.alignable = [])).push(node)    var width = dims.wrapperWidth    node.style.left = dims.fixedPos + "px"    if (!widget.coverGutter) {      width -= dims.gutterTotalWidth      node.style.paddingLeft = dims.gutterTotalWidth + "px"    }    node.style.width = width + "px"  }  if (widget.coverGutter) {    node.style.zIndex = 5    node.style.position = "relative"    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px" }  }
}
function widgetHeight(widget) {
if (widget.height != null) { return widget.height }  var cm = widget.doc.cm  if (!cm) { return 0 }  if (!contains(document.body, widget.node)) {    var parentStyle = "position: relative;"    if (widget.coverGutter)      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;" }    if (widget.noHScroll)      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;" }    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle))  }  return widget.height = widget.node.parentNode.offsetHeight
}
// Return true when the given mouse event happened in a widget function eventInWidget(display, e) {
for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||        (n.parentNode == display.sizer && n != display.mover))      { return true }  }
}
// POSITION MEASUREMENT
function paddingTop(display) {return display.lineSpace.offsetTop} function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight} function paddingH(display) {
if (display.cachedPaddingH) { return display.cachedPaddingH }  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"))  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)}  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data }  return data
}
function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth } function displayWidth(cm) {
return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
} function displayHeight(cm) {
return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
}
// Ensure the lineView.wrapping.heights array is populated. This is // an array of bottom offsets for the lines that make up a drawn // line. When lineWrapping is on, there might be more than one // height. function ensureLineHeights(cm, lineView, rect) {
var wrapping = cm.options.lineWrapping  var curWidth = wrapping && displayWidth(cm)  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {    var heights = lineView.measure.heights = []    if (wrapping) {      lineView.measure.width = curWidth      var rects = lineView.text.firstChild.getClientRects()      for (var i = 0; i < rects.length - 1; i++) {        var cur = rects[i], next = rects[i + 1]        if (Math.abs(cur.bottom - next.bottom) > 2)          { heights.push((cur.bottom + next.top) / 2 - rect.top) }      }    }    heights.push(rect.bottom - rect.top)  }
}
// Find a line map (mapping character offsets to text nodes) and a // measurement cache for the given line number. (A line view might // contain multiple lines when collapsed ranges are present.) function mapFromLineView(lineView, line, lineN) {
if (lineView.line == line)    { return {map: lineView.measure.map, cache: lineView.measure.cache} }  for (var i = 0; i < lineView.rest.length; i++)    { if (lineView.rest[i] == line)      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)    { if (lineNo(lineView.rest[i$1]) > lineN)      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
}
// Render a line into the hidden node display.externalMeasured. Used // when measurement is needed for a line that's not in the viewport. function updateExternalMeasurement(cm, line) {
line = visualLine(line)  var lineN = lineNo(line)  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN)  view.lineN = lineN  var built = view.built = buildLineContent(cm, view)  view.text = built.pre  removeChildrenAndAdd(cm.display.lineMeasure, built.pre)  return view
}
// Get a {top, bottom, left, right} box (in line-local coordinates) // for a given character. function measureChar(cm, line, ch, bias) {
return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
}
// Find a line view that corresponds to the given line number. function findViewForLine(cm, lineN) {
if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)    { return cm.display.view[findViewIndex(cm, lineN)] }  var ext = cm.display.externalMeasured  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)    { return ext }
}
// Measurement can be split in two steps, the set-up work that // applies to the whole line, and the measurement of the actual // character. Functions like coordsChar, that need to do a lot of // measurements in a row, can thus ensure that the set-up work is // only done once. function prepareMeasureForLine(cm, line) {
var lineN = lineNo(line)  var view = findViewForLine(cm, lineN)  if (view && !view.text) {    view = null  } else if (view && view.changes) {    updateLineForChanges(cm, view, lineN, getDimensions(cm))    cm.curOp.forceUpdate = true  }  if (!view)    { view = updateExternalMeasurement(cm, line) }
var info = mapFromLineView(view, line, lineN)  return {    line: line, view: view, rect: null,    map: info.map, cache: info.cache, before: info.before,    hasHeights: false  }
}
// Given a prepared measurement object, measures the position of an // actual character (or fetches it from the cache). function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
if (prepared.before) { ch = -1 }  var key = ch + (bias || ""), found  if (prepared.cache.hasOwnProperty(key)) {    found = prepared.cache[key]  } else {    if (!prepared.rect)      { prepared.rect = prepared.view.text.getBoundingClientRect() }    if (!prepared.hasHeights) {      ensureLineHeights(cm, prepared.view, prepared.rect)      prepared.hasHeights = true    }    found = measureCharInner(cm, prepared, ch, bias)    if (!found.bogus) { prepared.cache[key] = found }  }  return {left: found.left, right: found.right,          top: varHeight ? found.rtop : found.top,          bottom: varHeight ? found.rbottom : found.bottom}
}
var nullRect = {left: 0, right: 0, top: 0, bottom: 0}
function nodeAndOffsetInLineMap(map, ch, bias) {
var node, start, end, collapse, mStart, mEnd  // First, search the line map for the text node corresponding to,  // or closest to, the target character.  for (var i = 0; i < map.length; i += 3) {    mStart = map[i]    mEnd = map[i + 1]    if (ch < mStart) {      start = 0; end = 1      collapse = "left"    } else if (ch < mEnd) {      start = ch - mStart      end = start + 1    } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {      end = mEnd - mStart      start = end - 1      if (ch >= mEnd) { collapse = "right" }    }    if (start != null) {      node = map[i + 2]      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))        { collapse = bias }      if (bias == "left" && start == 0)        { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {          node = map[(i -= 3) + 2]          collapse = "left"        } }      if (bias == "right" && start == mEnd - mStart)        { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {          node = map[(i += 3) + 2]          collapse = "right"        } }      break    }  }  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
}
function getUsefulRect(rects, bias) {
var rect = nullRect  if (bias == "left") { for (var i = 0; i < rects.length; i++) {    if ((rect = rects[i]).left != rect.right) { break }  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {    if ((rect = rects[i$1]).left != rect.right) { break }  } }  return rect
}
function measureCharInner(cm, prepared, ch, bias) {
var place = nodeAndOffsetInLineMap(prepared.map, ch, bias)  var node = place.node, start = place.start, end = place.end, collapse = place.collapse
var rect  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start }      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end }      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)        { rect = node.parentNode.getBoundingClientRect() }      else        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias) }      if (rect.left || rect.right || start == 0) { break }      end = start      start = start - 1      collapse = "right"    }    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect) }  } else { // If it is a widget, simply get the box for the whole widget.    if (start > 0) { collapse = bias = "right" }    var rects    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)      { rect = rects[bias == "right" ? rects.length - 1 : 0] }    else      { rect = node.getBoundingClientRect() }  }  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {    var rSpan = node.parentNode.getClientRects()[0]    if (rSpan)      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom} }    else      { rect = nullRect }  }
var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top  var mid = (rtop + rbot) / 2  var heights = prepared.view.measure.heights  var i = 0  for (; i < heights.length - 1; i++)    { if (mid < heights[i]) { break } }  var top = i ? heights[i - 1] : 0, bot = heights[i]  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,                top: top, bottom: bot}  if (!rect.left && !rect.right) { result.bogus = true }  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot }
return result
}
// Work around problem with bounding client rects on ranges being // returned incorrectly when zoomed on IE10 and below. function maybeUpdateRectForZooming(measure, rect) {
if (!window.screen || screen.logicalXDPI == null ||      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))    { return rect }  var scaleX = screen.logicalXDPI / screen.deviceXDPI  var scaleY = screen.logicalYDPI / screen.deviceYDPI  return {left: rect.left * scaleX, right: rect.right * scaleX,          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
}
function clearLineMeasurementCacheFor(lineView) {
if (lineView.measure) {    lineView.measure.cache = {}    lineView.measure.heights = null    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)      { lineView.measure.caches[i] = {} } }  }
}
function clearLineMeasurementCache(cm) {
cm.display.externalMeasure = null  removeChildren(cm.display.lineMeasure)  for (var i = 0; i < cm.display.view.length; i++)    { clearLineMeasurementCacheFor(cm.display.view[i]) }
}
function clearCaches(cm) {
clearLineMeasurementCache(cm)  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true }  cm.display.lineNumChars = null
}
function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft } function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }
// Converts a {top, bottom, left, right} box from line-local // coordinates into another coordinate system. Context may be one of // "line", "div" (display.lineDiv), "local"./null (editor), "window", // or "page". function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {    var size = widgetHeight(lineObj.widgets[i])    rect.top += size; rect.bottom += size  } } }  if (context == "line") { return rect }  if (!context) { context = "local" }  var yOff = heightAtLine(lineObj)  if (context == "local") { yOff += paddingTop(cm.display) }  else { yOff -= cm.display.viewOffset }  if (context == "page" || context == "window") {    var lOff = cm.display.lineSpace.getBoundingClientRect()    yOff += lOff.top + (context == "window" ? 0 : pageScrollY())    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX())    rect.left += xOff; rect.right += xOff  }  rect.top += yOff; rect.bottom += yOff  return rect
}
// Coverts a box from "div" coords to another coordinate system. // Context may be "window", "page", "div", or "local"./null. function fromCoordSystem(cm, coords, context) {
if (context == "div") { return coords }  var left = coords.left, top = coords.top  // First move into "page" coordinate system  if (context == "page") {    left -= pageScrollX()    top -= pageScrollY()  } else if (context == "local" || !context) {    var localBox = cm.display.sizer.getBoundingClientRect()    left += localBox.left    top += localBox.top  }
var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect()  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
}
function charCoords(cm, pos, context, lineObj, bias) {
if (!lineObj) { lineObj = getLine(cm.doc, pos.line) }  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
}
// Returns a box for a given cursor position, which may have an // 'other' property containing the position of the secondary cursor // on a bidi boundary. // A cursor Pos(line, char, "before") is on the same visual line as `char - 1` // and after `char - 1` in writing order of `char - 1` // A cursor Pos(line, char, "after") is on the same visual line as `char` // and before `char` in writing order of `char` // Examples (upper-case letters are RTL, lower-case are LTR): //     Pos(0, 1, ...) //     before   after // ab     a|b     a|b // aB     a|B     aB| // Ab     |Ab     A|b // AB     B|A     B|A // Every position after the last character on a line is considered to stick // to the last character on the line. function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
lineObj = lineObj || getLine(cm.doc, pos.line)  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj) }  function get(ch, right) {    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight)    if (right) { m.left = m.right; } else { m.right = m.left }    return intoCoordSystem(cm, lineObj, m, context)  }  var order = getOrder(lineObj), ch = pos.ch, sticky = pos.sticky  if (ch >= lineObj.text.length) {    ch = lineObj.text.length    sticky = "before"  } else if (ch <= 0) {    ch = 0    sticky = "after"  }  if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }
function getBidi(ch, partPos, invert) {    var part = order[partPos], right = (part.level % 2) != 0    return get(invert ? ch - 1 : ch, right != invert)  }  var partPos = getBidiPartAt(order, ch, sticky)  var other = bidiOther  var val = getBidi(ch, partPos, sticky == "before")  if (other != null) { val.other = getBidi(ch, other, sticky != "before") }  return val
}
// Used to cheaply estimate the coordinates for a position. Used for // intermediate scroll updates. function estimateCoords(cm, pos) {
var left = 0  pos = clipPos(cm.doc, pos)  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch }  var lineObj = getLine(cm.doc, pos.line)  var top = heightAtLine(lineObj) + paddingTop(cm.display)  return {left: left, right: left, top: top, bottom: top + lineObj.height}
}
// Positions returned by coordsChar contain some extra information. // xRel is the relative x position of the input coordinates compared // to the found position (so xRel > 0 means the coordinates are to // the right of the character position, for example). When outside // is true, that means the coordinates lie outside the line's // vertical range. function PosWithInfo(line, ch, sticky, outside, xRel) {
var pos = Pos(line, ch, sticky)  pos.xRel = xRel  if (outside) { pos.outside = true }  return pos
}
// Compute the character position closest to the given coordinates. // Input must be lineSpace-local ("div" coordinate system). function coordsChar(cm, x, y) {
var doc = cm.doc  y += cm.display.viewOffset  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1  if (lineN > last)    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }  if (x < 0) { x = 0 }
var lineObj = getLine(doc, lineN)  for (;;) {    var found = coordsCharInner(cm, lineObj, lineN, x, y)    var merged = collapsedSpanAtEnd(lineObj)    var mergedPos = merged && merged.find(0, true)    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))      { lineN = lineNo(lineObj = mergedPos.to.line) }    else      { return found }  }
}
function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), "line"); }  var end = lineObj.text.length  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0)  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end)  return {begin: begin, end: end}
}
function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
}
function coordsCharInner(cm, lineObj, lineNo, x, y) {
y -= heightAtLine(lineObj)  var begin = 0, end = lineObj.text.length  var preparedMeasure = prepareMeasureForLine(cm, lineObj)  var pos  var order = getOrder(lineObj)  if (order) {    if (cm.options.lineWrapping) {  ;var assign;      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign))    }    pos = new Pos(lineNo, begin)    var beginLeft = cursorCoords(cm, pos, "line", lineObj, preparedMeasure).left    var dir = beginLeft < x ? 1 : -1    var prevDiff, diff = beginLeft - x, prevPos    do {      prevDiff = diff      prevPos = pos      pos = moveVisually(cm, lineObj, pos, dir)      if (pos == null || pos.ch < begin || end <= (pos.sticky == "before" ? pos.ch - 1 : pos.ch)) {        pos = prevPos        break      }      diff = cursorCoords(cm, pos, "line", lineObj, preparedMeasure).left - x    } while ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))    if (Math.abs(diff) > Math.abs(prevDiff)) {      if ((diff < 0) == (prevDiff < 0)) { throw new Error("Broke out of infinite loop in coordsCharInner") }      pos = prevPos    }  } else {    var ch = findFirst(function (ch) {      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), "line")      if (box.top > y) {        // For the cursor stickiness        end = Math.min(ch, end)        return true      }      else if (box.bottom <= y) { return false }      else if (box.left > x) { return true }      else if (box.right < x) { return false }      else { return (x - box.left < box.right - x) }    }, begin, end)    ch = skipExtendingChars(lineObj.text, ch, 1)    pos = new Pos(lineNo, ch, ch == end ? "before" : "after")  }  var coords = cursorCoords(cm, pos, "line", lineObj, preparedMeasure)  if (y < coords.top || coords.bottom < y) { pos.outside = true }  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0)  return pos
}
var measureText // Compute the default text height. function textHeight(display) {
if (display.cachedTextHeight != null) { return display.cachedTextHeight }  if (measureText == null) {    measureText = elt("pre")    // Measure a bunch of lines, for browsers that compute    // fractional heights.    for (var i = 0; i < 49; ++i) {      measureText.appendChild(document.createTextNode("x"))      measureText.appendChild(elt("br"))    }    measureText.appendChild(document.createTextNode("x"))  }  removeChildrenAndAdd(display.measure, measureText)  var height = measureText.offsetHeight / 50  if (height > 3) { display.cachedTextHeight = height }  removeChildren(display.measure)  return height || 1
}
// Compute the default character width. function charWidth(display) {
if (display.cachedCharWidth != null) { return display.cachedCharWidth }  var anchor = elt("span", "xxxxxxxxxx")  var pre = elt("pre", [anchor])  removeChildrenAndAdd(display.measure, pre)  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10  if (width > 2) { display.cachedCharWidth = width }  return width || 10
}
// Do a bulk-read of the DOM positions and sizes needed to draw the // view, so that we don't interleave reading and writing to the DOM. function getDimensions(cm) {
var d = cm.display, left = {}, width = {}  var gutterLeft = d.gutters.clientLeft  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft    width[cm.options.gutters[i]] = n.clientWidth  }  return {fixedPos: compensateForHScroll(d),          gutterTotalWidth: d.gutters.offsetWidth,          gutterLeft: left,          gutterWidth: width,          wrapperWidth: d.wrapper.clientWidth}
}
// Computes display.scroller.scrollLeft + display.gutters.offsetWidth, // but using getBoundingClientRect to get a sub-pixel-accurate // result. function compensateForHScroll(display) {
return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
}
// Returns a function that estimates the height of a line, to use as // first approximation until the line becomes visible (and is thus // properly measurable). function estimateHeight(cm) {
var th = textHeight(cm.display), wrapping = cm.options.lineWrapping  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3)  return function (line) {    if (lineIsHidden(cm.doc, line)) { return 0 }
var widgetsHeight = 0    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height }    } }
if (wrapping)      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }    else      { return widgetsHeight + th }  }
}
function estimateLineHeights(cm) {
var doc = cm.doc, est = estimateHeight(cm)  doc.iter(function (line) {    var estHeight = est(line)    if (estHeight != line.height) { updateLineHeight(line, estHeight) }  })
}
// Given a mouse event, find the corresponding position. If liberal // is false, it checks whether a gutter or scrollbar was clicked, // and returns null if it was. forRect is used by rectangular // selections, and tries to estimate a character position even for // coordinates beyond the right of the text. function posFromMouse(cm, e, liberal, forRect) {
var display = cm.display  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }
var x, y, space = display.lineSpace.getBoundingClientRect()  // Fails unpredictably on IE[67] when mouse is dragged around quickly.  try { x = e.clientX - space.left; y = e.clientY - space.top }  catch (e) { return null }  var coords = coordsChar(cm, x, y), line  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))  }  return coords
}
// Find the view element corresponding to a given line. Return null // when the line isn't visible. function findViewIndex(cm, n) {
if (n >= cm.display.viewTo) { return null }  n -= cm.display.viewFrom  if (n < 0) { return null }  var view = cm.display.view  for (var i = 0; i < view.length; i++) {    n -= view[i].size    if (n < 0) { return i }  }
}
function updateSelection(cm) {
cm.display.input.showSelection(cm.display.input.prepareSelection())
}
function prepareSelection(cm, primary) {
var doc = cm.doc, result = {}  var curFragment = result.cursors = document.createDocumentFragment()  var selFragment = result.selection = document.createDocumentFragment()
for (var i = 0; i < doc.sel.ranges.length; i++) {    if (primary === false && i == doc.sel.primIndex) { continue }    var range = doc.sel.ranges[i]    if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }    var collapsed = range.empty()    if (collapsed || cm.options.showCursorWhenSelecting)      { drawSelectionCursor(cm, range.head, curFragment) }    if (!collapsed)      { drawSelectionRange(cm, range, selFragment) }  }  return result
}
// Draws a cursor for the given range function drawSelectionCursor(cm, head, output) {
var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine)
var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"))  cursor.style.left = pos.left + "px"  cursor.style.top = pos.top + "px"  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px"
if (pos.other) {    // Secondary cursor, shown when on a 'jump' in bi-directional text    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"))    otherCursor.style.display = ""    otherCursor.style.left = pos.other.left + "px"    otherCursor.style.top = pos.other.top + "px"    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px"  }
}
// Draws the given range as a highlighted selection function drawSelectionRange(cm, range, output) {
var display = cm.display, doc = cm.doc  var fragment = document.createDocumentFragment()  var padding = paddingH(cm.display), leftSide = padding.left  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right
function add(left, top, width, bottom) {    if (top < 0) { top = 0 }    top = Math.round(top)    bottom = Math.round(bottom)    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")))  }
function drawForLine(line, fromArg, toArg) {    var lineObj = getLine(doc, line)    var lineLen = lineObj.text.length    var start, end    function coords(ch, bias) {      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)    }
iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {      var leftPos = coords(from, "left"), rightPos, left, right      if (from == to) {        rightPos = leftPos        left = right = leftPos.left      } else {        rightPos = coords(to - 1, "right")        if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp }        left = leftPos.left        right = rightPos.right      }      if (fromArg == null && from == 0) { left = leftSide }      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part        add(left, leftPos.top, null, leftPos.bottom)        left = leftSide        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top) }      }      if (toArg == null && to == lineLen) { right = rightSide }      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)        { start = leftPos }      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)        { end = rightPos }      if (left < leftSide + 1) { left = leftSide }      add(left, rightPos.top, right - left, rightPos.bottom)    })    return {start: start, end: end}  }
var sFrom = range.from(), sTo = range.to()  if (sFrom.line == sTo.line) {    drawForLine(sFrom.line, sFrom.ch, sTo.ch)  } else {    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line)    var singleVLine = visualLine(fromLine) == visualLine(toLine)    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start    if (singleVLine) {      if (leftEnd.top < rightStart.top - 2) {        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom)        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)      } else {        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)      }    }    if (leftEnd.bottom < rightStart.top)      { add(leftSide, leftEnd.bottom, null, rightStart.top) }  }
output.appendChild(fragment)
}
// Cursor-blinking function restartBlink(cm) {
if (!cm.state.focused) { return }  var display = cm.display  clearInterval(display.blinker)  var on = true  display.cursorDiv.style.visibility = ""  if (cm.options.cursorBlinkRate > 0)    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },      cm.options.cursorBlinkRate) }  else if (cm.options.cursorBlinkRate < 0)    { display.cursorDiv.style.visibility = "hidden" }
}
function ensureFocus(cm) {
if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm) }
}
function delayBlurEvent(cm) {
cm.state.delayingBlurEvent = true  setTimeout(function () { if (cm.state.delayingBlurEvent) {    cm.state.delayingBlurEvent = false    onBlur(cm)  } }, 100)
}
function onFocus(cm, e) {
if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false }
if (cm.options.readOnly == "nocursor") { return }  if (!cm.state.focused) {    signal(cm, "focus", cm, e)    cm.state.focused = true    addClass(cm.display.wrapper, "CodeMirror-focused")    // This test prevents this from firing when a context    // menu is closed (since the input reset would kill the    // select-all detection hack)    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {      cm.display.input.reset()      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20) } // Issue #1730    }    cm.display.input.receivedFocus()  }  restartBlink(cm)
} function onBlur(cm, e) {
if (cm.state.delayingBlurEvent) { return }
if (cm.state.focused) {    signal(cm, "blur", cm, e)    cm.state.focused = false    rmClass(cm.display.wrapper, "CodeMirror-focused")  }  clearInterval(cm.display.blinker)  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false } }, 150)
}
// Re-align line numbers and gutter marks to compensate for // horizontal scrolling. function alignHorizontally(cm) {
var display = cm.display, view = display.view  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft  var gutterW = display.gutters.offsetWidth, left = comp + "px"  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {    if (cm.options.fixedGutter) {      if (view[i].gutter)        { view[i].gutter.style.left = left }      if (view[i].gutterBackground)        { view[i].gutterBackground.style.left = left }    }    var align = view[i].alignable    if (align) { for (var j = 0; j < align.length; j++)      { align[j].style.left = left } }  } }  if (cm.options.fixedGutter)    { display.gutters.style.left = (comp + gutterW) + "px" }
}
// Used to ensure that the line number gutter is still the right // size for the current document size. Returns true when an update // is needed. function maybeUpdateLineNumberWidth(cm) {
if (!cm.options.lineNumbers) { return false }  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display  if (last.length != display.lineNumChars) {    var test = display.measure.appendChild(elt("div", [elt("div", last)],                                               "CodeMirror-linenumber CodeMirror-gutter-elt"))    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW    display.lineGutter.style.width = ""    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1    display.lineNumWidth = display.lineNumInnerWidth + padding    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1    display.lineGutter.style.width = display.lineNumWidth + "px"    updateGutterSpace(cm)    return true  }  return false
}
// Read the actual heights of the rendered lines, and update their // stored heights to match. function updateHeightsInViewport(cm) {
var display = cm.display  var prevBottom = display.lineDiv.offsetTop  for (var i = 0; i < display.view.length; i++) {    var cur = display.view[i], height = (void 0)    if (cur.hidden) { continue }    if (ie && ie_version < 8) {      var bot = cur.node.offsetTop + cur.node.offsetHeight      height = bot - prevBottom      prevBottom = bot    } else {      var box = cur.node.getBoundingClientRect()      height = box.bottom - box.top    }    var diff = cur.line.height - height    if (height < 2) { height = textHeight(display) }    if (diff > .001 || diff < -.001) {      updateLineHeight(cur.line, height)      updateWidgetHeight(cur.line)      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)        { updateWidgetHeight(cur.rest[j]) } }    }  }
}
// Read and store the height of line widgets associated with the // given line. function updateWidgetHeight(line) {
if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight } }
}
// Compute the lines that are visible in a given viewport (defaults // the the current scroll position). viewport may contain top, // height, and ensure (see op.scrollToPos) properties. function visibleLines(display, doc, viewport) {
var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop  top = Math.floor(top - paddingTop(display))  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight
var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom)  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and  // forces those lines into the viewport (if possible).  if (viewport && viewport.ensure) {    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line    if (ensureFrom < from) {      from = ensureFrom      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight)      to = ensureTo    }  }  return {from: from, to: Math.max(to, from + 1)}
}
// Sync the scrollable area and scrollbars, ensure the viewport // covers the visible area. function setScrollTop(cm, val) {
if (Math.abs(cm.doc.scrollTop - val) < 2) { return }  cm.doc.scrollTop = val  if (!gecko) { updateDisplaySimple(cm, {top: val}) }  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val }  cm.display.scrollbars.setScrollTop(val)  if (gecko) { updateDisplaySimple(cm) }  startWorker(cm, 100)
} // Sync scroller and scrollbar, ensure the gutter elements are // aligned. function setScrollLeft(cm, val, isScroller) {
if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) { return }  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth)  cm.doc.scrollLeft = val  alignHorizontally(cm)  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val }  cm.display.scrollbars.setScrollLeft(val)
}
// Since the delta values reported on mouse wheel events are // unstandardized between browsers and even browser versions, and // generally horribly unpredictable, this code starts by measuring // the scroll effect that the first few mouse wheel events have, // and, from that, detects the way it can convert deltas to pixel // offsets afterwards. // // The reason we want to know the amount a wheel event will scroll // is that it gives us a chance to update the display before the // actual scrolling happens, reducing flickering.
var wheelSamples = 0; var wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we // know one. These don't have to be accurate -- the result of them // being wrong would just be a slight flicker on the first wheel // scroll (if it is large enough). if (ie) { wheelPixelsPerUnit = -.53 } else if (gecko) { wheelPixelsPerUnit = 15 } else if (chrome) { wheelPixelsPerUnit = -.7 } else if (safari) { wheelPixelsPerUnit = -1/3 }
function wheelEventDelta(e) {
var dx = e.wheelDeltaX, dy = e.wheelDeltaY  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail }  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail }  else if (dy == null) { dy = e.wheelDelta }  return {x: dx, y: dy}
} function wheelEventPixels(e) {
var delta = wheelEventDelta(e)  delta.x *= wheelPixelsPerUnit  delta.y *= wheelPixelsPerUnit  return delta
}
function onScrollWheel(cm, e) {
var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y
var display = cm.display, scroll = display.scroller  // Quit if there's nothing to scroll here  var canScrollX = scroll.scrollWidth > scroll.clientWidth  var canScrollY = scroll.scrollHeight > scroll.clientHeight  if (!(dx && canScrollX || dy && canScrollY)) { return }
// Webkit browsers on OS X abort momentum scrolls when the target  // of the scroll event is removed from the scrollable element.  // This hack (see related code in patchDisplay) makes sure the  // element is kept around.  if (dy && mac && webkit) {    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {      for (var i = 0; i < view.length; i++) {        if (view[i].node == cur) {          cm.display.currentWheelTarget = cur          break outer        }      }    }  }
// On some browsers, horizontal scrolling will cause redraws to  // happen before the gutter has been realigned, causing it to  // wriggle around in a most unseemly way. When we have an  // estimated pixels/delta value, we just handle horizontal  // scrolling entirely here. It'll be slightly off from native, but  // better than glitching out.  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {    if (dy && canScrollY)      { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))) }    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)))    // Only prevent default scrolling if vertical scrolling is    // actually possible. Otherwise, it causes vertical scroll    // jitter on OSX trackpads when deltaX is small and deltaY    // is large (issue #3579)    if (!dy || (dy && canScrollY))      { e_preventDefault(e) }    display.wheelStartX = null // Abort measurement, if in progress    return  }
// 'Project' the visible viewport to cover the area that is being  // scrolled into view (if we know enough to estimate it).  if (dy && wheelPixelsPerUnit != null) {    var pixels = dy * wheelPixelsPerUnit    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight    if (pixels < 0) { top = Math.max(0, top + pixels - 50) }    else { bot = Math.min(cm.doc.height, bot + pixels + 50) }    updateDisplaySimple(cm, {top: top, bottom: bot})  }
if (wheelSamples < 20) {    if (display.wheelStartX == null) {      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop      display.wheelDX = dx; display.wheelDY = dy      setTimeout(function () {        if (display.wheelStartX == null) { return }        var movedX = scroll.scrollLeft - display.wheelStartX        var movedY = scroll.scrollTop - display.wheelStartY        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||          (movedX && display.wheelDX && movedX / display.wheelDX)        display.wheelStartX = display.wheelStartY = null        if (!sample) { return }        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1)        ++wheelSamples      }, 200)    } else {      display.wheelDX += dx; display.wheelDY += dy    }  }
}
// SCROLLBARS
// Prepare DOM reads needed to update the scrollbars. Done in one // shot to minimize update/measure roundtrips. function measureForScrollbars(cm) {
var d = cm.display, gutterW = d.gutters.offsetWidth  var docH = Math.round(cm.doc.height + paddingVert(cm.display))  return {    clientHeight: d.scroller.clientHeight,    viewHeight: d.wrapper.clientHeight,    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,    viewWidth: d.wrapper.clientWidth,    barLeft: cm.options.fixedGutter ? gutterW : 0,    docHeight: docH,    scrollHeight: docH + scrollGap(cm) + d.barHeight,    nativeBarWidth: d.nativeBarWidth,    gutterWidth: gutterW  }
}
var NativeScrollbars = function(place, scroll, cm) {
this.cm = cm  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar")  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar")  place(vert); place(horiz)
on(vert, "scroll", function () {    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical") }  })  on(horiz, "scroll", function () {    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal") }  })
this.checkedZeroWidth = false  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px" }
};
NativeScrollbars.prototype.update = function (measure) {
var needsH = measure.scrollWidth > measure.clientWidth + 1  var needsV = measure.scrollHeight > measure.clientHeight + 1  var sWidth = measure.nativeBarWidth
if (needsV) {    this.vert.style.display = "block"    this.vert.style.bottom = needsH ? sWidth + "px" : "0"    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0)    // A bug in IE8 can cause this value to be negative, so guard it.    this.vert.firstChild.style.height =      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px"  } else {    this.vert.style.display = ""    this.vert.firstChild.style.height = "0"  }
if (needsH) {    this.horiz.style.display = "block"    this.horiz.style.right = needsV ? sWidth + "px" : "0"    this.horiz.style.left = measure.barLeft + "px"    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0)    this.horiz.firstChild.style.width =      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px"  } else {    this.horiz.style.display = ""    this.horiz.firstChild.style.width = "0"  }
if (!this.checkedZeroWidth && measure.clientHeight > 0) {    if (sWidth == 0) { this.zeroWidthHack() }    this.checkedZeroWidth = true  }
return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
};
NativeScrollbars.prototype.setScrollLeft = function (pos) {
if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos }  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz) }
};
NativeScrollbars.prototype.setScrollTop = function (pos) {
if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos }  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert) }
};
NativeScrollbars.prototype.zeroWidthHack = function () {
var w = mac && !mac_geMountainLion ? "12px" : "18px"  this.horiz.style.height = this.vert.style.width = w  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none"  this.disableHoriz = new Delayed  this.disableVert = new Delayed
};
NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay) {
bar.style.pointerEvents = "auto"  function maybeDisable() {    // To find out whether the scrollbar is still visible, we    // check whether the element under the pixel in the bottom    // left corner of the scrollbar box is the scrollbar box    // itself (when the bar is still visible) or its filler child    // (when the bar is hidden). If it is still visible, we keep    // it enabled, if it's hidden, we disable pointer events.    var box = bar.getBoundingClientRect()    var elt = document.elementFromPoint(box.left + 1, box.bottom - 1)    if (elt != bar) { bar.style.pointerEvents = "none" }    else { delay.set(1000, maybeDisable) }  }  delay.set(1000, maybeDisable)
};
NativeScrollbars.prototype.clear = function () {
var parent = this.horiz.parentNode  parent.removeChild(this.horiz)  parent.removeChild(this.vert)
};
var NullScrollbars = function () {};
NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} }; NullScrollbars.prototype.setScrollLeft = function () {}; NullScrollbars.prototype.setScrollTop = function () {}; NullScrollbars.prototype.clear = function () {};
function updateScrollbars(cm, measure) {
if (!measure) { measure = measureForScrollbars(cm) }  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight  updateScrollbarsInner(cm, measure)  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)      { updateHeightsInViewport(cm) }    updateScrollbarsInner(cm, measureForScrollbars(cm))    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight  }
}
// Re-synchronize the fake scrollbars with the actual size of the // content. function updateScrollbarsInner(cm, measure) {
var d = cm.display  var sizes = d.scrollbars.update(measure)
d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px"  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px"  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"
if (sizes.right && sizes.bottom) {    d.scrollbarFiller.style.display = "block"    d.scrollbarFiller.style.height = sizes.bottom + "px"    d.scrollbarFiller.style.width = sizes.right + "px"  } else { d.scrollbarFiller.style.display = "" }  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {    d.gutterFiller.style.display = "block"    d.gutterFiller.style.height = sizes.bottom + "px"    d.gutterFiller.style.width = measure.gutterWidth + "px"  } else { d.gutterFiller.style.display = "" }
}
var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars}
function initScrollbars(cm) {
if (cm.display.scrollbars) {    cm.display.scrollbars.clear()    if (cm.display.scrollbars.addClass)      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass) }  }
cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller)    // Prevent clicks in the scrollbars from killing focus    on(node, "mousedown", function () {      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0) }    })    node.setAttribute("cm-not-content", "true")  }, function (pos, axis) {    if (axis == "horizontal") { setScrollLeft(cm, pos) }    else { setScrollTop(cm, pos) }  }, cm)  if (cm.display.scrollbars.addClass)    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass) }
}
// SCROLLING THINGS INTO VIEW
// If an editor sits on the top or bottom of the window, partially // scrolled out of view, this ensures that the cursor is visible. function maybeScrollWindow(cm, coords) {
if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }
var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null  if (coords.top + box.top < 0) { doScroll = true }  else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false }  if (doScroll != null && !phantom) {    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (coords.left) + "px; width: 2px;"))    cm.display.lineSpace.appendChild(scrollNode)    scrollNode.scrollIntoView(doScroll)    cm.display.lineSpace.removeChild(scrollNode)  }
}
// Scroll a given position into view (immediately), verifying that // it actually became visible (as line heights are accurately // measured, the position of something may 'drift' during drawing). function scrollPosIntoView(cm, pos, end, margin) {
if (margin == null) { margin = 0 }  var coords  for (var limit = 0; limit < 5; limit++) {    var changed = false    coords = cursorCoords(cm, pos)    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end)    var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),                                       Math.min(coords.top, endCoords.top) - margin,                                       Math.max(coords.left, endCoords.left),                                       Math.max(coords.bottom, endCoords.bottom) + margin)    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft    if (scrollPos.scrollTop != null) {      setScrollTop(cm, scrollPos.scrollTop)      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true }    }    if (scrollPos.scrollLeft != null) {      setScrollLeft(cm, scrollPos.scrollLeft)      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true }    }    if (!changed) { break }  }  return coords
}
// Scroll a given set of coordinates into view (immediately). function scrollIntoView(cm, x1, y1, x2, y2) {
var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2)  if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop) }  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft) }
}
// Calculate a new scroll position needed to scroll the given // rectangle into view. Returns an object with scrollTop and // scrollLeft properties. When these are undefined, the // vertical/horizontal position does not need to be adjusted. function calculateScrollPos(cm, x1, y1, x2, y2) {
var display = cm.display, snapMargin = textHeight(cm.display)  if (y1 < 0) { y1 = 0 }  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop  var screen = displayHeight(cm), result = {}  if (y2 - y1 > screen) { y2 = y1 + screen }  var docBottom = cm.doc.height + paddingVert(display)  var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin  if (y1 < screentop) {    result.scrollTop = atTop ? 0 : y1  } else if (y2 > screentop + screen) {    var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen)    if (newTop != screentop) { result.scrollTop = newTop }  }
var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0)  var tooWide = x2 - x1 > screenw  if (tooWide) { x2 = x1 + screenw }  if (x1 < 10)    { result.scrollLeft = 0 }  else if (x1 < screenleft)    { result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) }  else if (x2 > screenw + screenleft - 3)    { result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw }  return result
}
// Store a relative adjustment to the scroll position in the current // operation (to be applied when the operation finishes). function addToScrollPos(cm, left, top) {
if (left != null || top != null) { resolveScrollToPos(cm) }  if (left != null)    { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left }  if (top != null)    { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top }
}
// Make sure that at the end of the operation the current cursor is // shown. function ensureCursorVisible(cm) {
resolveScrollToPos(cm)  var cur = cm.getCursor(), from = cur, to = cur  if (!cm.options.lineWrapping) {    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur    to = Pos(cur.line, cur.ch + 1)  }  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true}
}
// When an operation has its scrollToPos property set, and another // scroll action is applied before the end of the operation, this // 'simulates' scrolling that position into view in a cheap way, so // that the effect of intermediate scroll commands is not ignored. function resolveScrollToPos(cm) {
var range = cm.curOp.scrollToPos  if (range) {    cm.curOp.scrollToPos = null    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to)    var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),                                  Math.min(from.top, to.top) - range.margin,                                  Math.max(from.right, to.right),                                  Math.max(from.bottom, to.bottom) + range.margin)    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop)  }
}
// Operations are used to wrap a series of changes to the editor // state in such a way that each change won't have to update the // cursor and display (which would be awkward, slow, and // error-prone). Instead, display updates are batched and then all // combined and executed at once.
var nextOpId = 0 // Start a new operation. function startOperation(cm) {
cm.curOp = {    cm: cm,    viewChanged: false,      // Flag that indicates that lines might need to be redrawn    startHeight: cm.doc.height, // Used to detect need to update scrollbar    forceUpdate: false,      // Used to force a redraw    updateInput: null,       // Whether to reset the input textarea    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)    changeObjs: null,        // Accumulated changes, for firing change events    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already    selectionChanged: false, // Whether the selection needs to be redrawn    updateMaxLine: false,    // Set when the widest line needs to be determined anew    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet    scrollToPos: null,       // Used to scroll to a specific position    focus: false,    id: ++nextOpId           // Unique ID  }  pushOperation(cm.curOp)
}
// Finish an operation, updating the display and signalling delayed events function endOperation(cm) {
var op = cm.curOp  finishOperation(op, function (group) {    for (var i = 0; i < group.ops.length; i++)      { group.ops[i].cm.curOp = null }    endOperations(group)  })
}
// The DOM updates done when an operation finishes are batched so // that the minimum number of relayouts are required. function endOperations(group) {
var ops = group.ops  for (var i = 0; i < ops.length; i++) // Read DOM    { endOperation_R1(ops[i]) }  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)    { endOperation_W1(ops[i$1]) }  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM    { endOperation_R2(ops[i$2]) }  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)    { endOperation_W2(ops[i$3]) }  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM    { endOperation_finish(ops[i$4]) }
}
function endOperation_R1(op) {
var cm = op.cm, display = cm.display  maybeClipScrollbars(cm)  if (op.updateMaxLine) { findMaxLine(cm) }
op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||                       op.scrollToPos.to.line >= display.viewTo) ||    display.maxLineChanged && cm.options.lineWrapping  op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate)
}
function endOperation_W1(op) {
op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)
}
function endOperation_R2(op) {
var cm = op.cm, display = cm.display  if (op.updatedDisplay) { updateHeightsInViewport(cm) }
op.barMeasure = measureForScrollbars(cm)
// If the max line changed since it was last measured, measure it,  // and ensure the document's width matches it.  // updateDisplay_W2 will use these properties to do the actual resizing  if (display.maxLineChanged && !cm.options.lineWrapping) {    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3    cm.display.sizerWidth = op.adjustWidthTo    op.barMeasure.scrollWidth =      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth)    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))  }
if (op.updatedDisplay || op.selectionChanged)    { op.preparedSelection = display.input.prepareSelection(op.focus) }
}
function endOperation_W2(op) {
var cm = op.cm
if (op.adjustWidthTo != null) {    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px"    if (op.maxScrollLeft < cm.doc.scrollLeft)      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true) }    cm.display.maxLineChanged = false  }
var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())  if (op.preparedSelection)    { cm.display.input.showSelection(op.preparedSelection, takeFocus) }  if (op.updatedDisplay || op.startHeight != cm.doc.height)    { updateScrollbars(cm, op.barMeasure) }  if (op.updatedDisplay)    { setDocumentHeight(cm, op.barMeasure) }
if (op.selectionChanged) { restartBlink(cm) }
if (cm.state.focused && op.updateInput)    { cm.display.input.reset(op.typing) }  if (takeFocus) { ensureFocus(op.cm) }
}
function endOperation_finish(op) {
var cm = op.cm, display = cm.display, doc = cm.doc
if (op.updatedDisplay) { postUpdateDisplay(cm, op.update) }
// Abort mouse wheel delta measurement, when scrolling explicitly  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))    { display.wheelStartX = display.wheelStartY = null }
// Propagate the scroll position to the actual DOM scroller  if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop))    display.scrollbars.setScrollTop(doc.scrollTop)    display.scroller.scrollTop = doc.scrollTop  }  if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft))    display.scrollbars.setScrollLeft(doc.scrollLeft)    display.scroller.scrollLeft = doc.scrollLeft    alignHorizontally(cm)  }  // If we need to scroll a specific position into view, do so.  if (op.scrollToPos) {    var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin)    if (op.scrollToPos.isCursor && cm.state.focused) { maybeScrollWindow(cm, coords) }  }
// Fire events for markers that are hidden/unidden by editing or  // undoing  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers  if (hidden) { for (var i = 0; i < hidden.length; ++i)    { if (!hidden[i].lines.length) { signal(hidden[i], "hide") } } }  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide") } } }
if (display.wrapper.offsetHeight)    { doc.scrollTop = cm.display.scroller.scrollTop }
// Fire change events, and delayed event handlers  if (op.changeObjs)    { signal(cm, "changes", cm, op.changeObjs) }  if (op.update)    { op.update.finish() }
}
// Run the given function in an operation function runInOp(cm, f) {
if (cm.curOp) { return f() }  startOperation(cm)  try { return f() }  finally { endOperation(cm) }
} // Wraps a function in an operation. Returns the wrapped function. function operation(cm, f) {
return function() {    if (cm.curOp) { return f.apply(cm, arguments) }    startOperation(cm)    try { return f.apply(cm, arguments) }    finally { endOperation(cm) }  }
} // Used to add methods to editor and doc instances, wrapping them in // operations. function methodOp(f) {
return function() {    if (this.curOp) { return f.apply(this, arguments) }    startOperation(this)    try { return f.apply(this, arguments) }    finally { endOperation(this) }  }
} function docMethodOp(f) {
return function() {    var cm = this.cm    if (!cm || cm.curOp) { return f.apply(this, arguments) }    startOperation(cm)    try { return f.apply(this, arguments) }    finally { endOperation(cm) }  }
}
// Updates the display.view data structure for a given change to the // document. From and to are in pre-change coordinates. Lendiff is // the amount of lines added or subtracted by the change. This is // used for changes that span multiple lines, or change the way // lines are divided into visual lines. regLineChange (below) // registers single-line changes. function regChange(cm, from, to, lendiff) {
if (from == null) { from = cm.doc.first }  if (to == null) { to = cm.doc.first + cm.doc.size }  if (!lendiff) { lendiff = 0 }
var display = cm.display  if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from))    { display.updateLineNumbers = from }
cm.curOp.viewChanged = true
if (from >= display.viewTo) { // Change after    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)      { resetView(cm) }  } else if (to <= display.viewFrom) { // Change before    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {      resetView(cm)    } else {      display.viewFrom += lendiff      display.viewTo += lendiff    }  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap    resetView(cm)  } else if (from <= display.viewFrom) { // Top overlap    var cut = viewCuttingPoint(cm, to, to + lendiff, 1)    if (cut) {      display.view = display.view.slice(cut.index)      display.viewFrom = cut.lineN      display.viewTo += lendiff    } else {      resetView(cm)    }  } else if (to >= display.viewTo) { // Bottom overlap    var cut$1 = viewCuttingPoint(cm, from, from, -1)    if (cut$1) {      display.view = display.view.slice(0, cut$1.index) display.viewTo = cut$1.lineN    } else {      resetView(cm)    }  } else { // Gap in the middle    var cutTop = viewCuttingPoint(cm, from, from, -1)    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1)    if (cutTop && cutBot) {      display.view = display.view.slice(0, cutTop.index)        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))        .concat(display.view.slice(cutBot.index))      display.viewTo += lendiff    } else {      resetView(cm)    }  }
var ext = display.externalMeasured  if (ext) {    if (to < ext.lineN)      { ext.lineN += lendiff }    else if (from < ext.lineN + ext.size)      { display.externalMeasured = null }  }
}
// Register a change to a single line. Type must be one of "text", // "gutter", "class", "widget" function regLineChange(cm, line, type) {
cm.curOp.viewChanged = true  var display = cm.display, ext = cm.display.externalMeasured  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)    { display.externalMeasured = null }
if (line < display.viewFrom || line >= display.viewTo) { return }  var lineView = display.view[findViewIndex(cm, line)]  if (lineView.node == null) { return }  var arr = lineView.changes || (lineView.changes = [])  if (indexOf(arr, type) == -1) { arr.push(type) }
}
// Clear the view. function resetView(cm) {
cm.display.viewFrom = cm.display.viewTo = cm.doc.first  cm.display.view = []  cm.display.viewOffset = 0
}
function viewCuttingPoint(cm, oldN, newN, dir) {
var index = findViewIndex(cm, oldN), diff, view = cm.display.view  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)    { return {index: index, lineN: newN} }  var n = cm.display.viewFrom  for (var i = 0; i < index; i++)    { n += view[i].size }  if (n != oldN) {    if (dir > 0) {      if (index == view.length - 1) { return null }      diff = (n + view[index].size) - oldN      index++    } else {      diff = n - oldN    }    oldN += diff; newN += diff  }  while (visualLineNo(cm.doc, newN) != newN) {    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }    newN += dir * view[index - (dir < 0 ? 1 : 0)].size    index += dir  }  return {index: index, lineN: newN}
}
// Force the view to cover a given range, adding empty view element // or clipping off existing ones as needed. function adjustView(cm, from, to) {
var display = cm.display, view = display.view  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {    display.view = buildViewArray(cm, from, to)    display.viewFrom = from  } else {    if (display.viewFrom > from)      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) }    else if (display.viewFrom < from)      { display.view = display.view.slice(findViewIndex(cm, from)) }    display.viewFrom = from    if (display.viewTo < to)      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) }    else if (display.viewTo > to)      { display.view = display.view.slice(0, findViewIndex(cm, to)) }  }  display.viewTo = to
}
// Count the number of lines in the view whose DOM representation is // out of date (or nonexistent). function countDirtyView(cm) {
var view = cm.display.view, dirty = 0  for (var i = 0; i < view.length; i++) {    var lineView = view[i]    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty }  }  return dirty
}
// HIGHLIGHT WORKER
function startWorker(cm, time) {
if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)    { cm.state.highlight.set(time, bind(highlightWorker, cm)) }
}
function highlightWorker(cm) {
var doc = cm.doc  if (doc.frontier < doc.first) { doc.frontier = doc.first }  if (doc.frontier >= cm.display.viewTo) { return }  var end = +new Date + cm.options.workTime  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier))  var changedLines = []
doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {    if (doc.frontier >= cm.display.viewFrom) { // Visible      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true)      line.styles = highlighted.styles      var oldCls = line.styleClasses, newCls = highlighted.classes      if (newCls) { line.styleClasses = newCls }      else if (oldCls) { line.styleClasses = null }      var ischange = !oldStyles || oldStyles.length != line.styles.length ||        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass)      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i] }      if (ischange) { changedLines.push(doc.frontier) }      line.stateAfter = tooLong ? state : copyState(doc.mode, state)    } else {      if (line.text.length <= cm.options.maxHighlightLength)        { processLine(cm, line.text, state) }      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null    }    ++doc.frontier    if (+new Date > end) {      startWorker(cm, cm.options.workDelay)      return true    }  })  if (changedLines.length) { runInOp(cm, function () {    for (var i = 0; i < changedLines.length; i++)      { regLineChange(cm, changedLines[i], "text") }  }) }
}
// DISPLAY DRAWING
var DisplayUpdate = function(cm, viewport, force) {
var display = cm.display
this.viewport = viewport  // Store some values that we'll need later (but don't want to force a relayout for)  this.visible = visibleLines(display, cm.doc, viewport)  this.editorIsHidden = !display.wrapper.offsetWidth  this.wrapperHeight = display.wrapper.clientHeight  this.wrapperWidth = display.wrapper.clientWidth  this.oldDisplayWidth = displayWidth(cm)  this.force = force  this.dims = getDimensions(cm)  this.events = []
};
DisplayUpdate.prototype.signal = function (emitter, type) {
if (hasHandler(emitter, type))    { this.events.push(arguments) }
}; DisplayUpdate.prototype.finish = function () {
var this$1 = this;
for (var i = 0; i < this.events.length; i++)    { signal.apply(null, this$1.events[i]) }
};
function maybeClipScrollbars(cm) {
var display = cm.display  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth    display.heightForcer.style.height = scrollGap(cm) + "px"    display.sizer.style.marginBottom = -display.nativeBarWidth + "px"    display.sizer.style.borderRightWidth = scrollGap(cm) + "px"    display.scrollbarsClipped = true  }
}
// Does the actual updating of the line display. Bails out // (returning false) when there is nothing to be done and forced is // false. function updateDisplayIfNeeded(cm, update) {
var display = cm.display, doc = cm.doc
if (update.editorIsHidden) {    resetView(cm)    return false  }
// Bail out if the visible area is already rendered and nothing changed.  if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0)    { return false }
if (maybeUpdateLineNumberWidth(cm)) {    resetView(cm)    update.dims = getDimensions(cm)  }
// Compute a suitable new viewport (from & to)  var end = doc.first + doc.size  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first)  var to = Math.min(end, update.visible.to + cm.options.viewportMargin)  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom) }  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo) }  if (sawCollapsedSpans) {    from = visualLineNo(cm.doc, from)    to = visualLineEndNo(cm.doc, to)  }
var different = from != display.viewFrom || to != display.viewTo ||    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth  adjustView(cm, from, to)
display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom))  // Position the mover div to align with the current scroll position  cm.display.mover.style.top = display.viewOffset + "px"
var toUpdate = countDirtyView(cm)  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))    { return false }
// For big changes, we hide the enclosing element during the  // update, since that speeds up the operations on most browsers.  var focused = activeElt()  if (toUpdate > 4) { display.lineDiv.style.display = "none" }  patchDisplay(cm, display.updateLineNumbers, update.dims)  if (toUpdate > 4) { display.lineDiv.style.display = "" }  display.renderedView = display.view  // There might have been a widget with a focused element that got  // hidden or updated, if so re-focus it.  if (focused && activeElt() != focused && focused.offsetHeight) { focused.focus() }
// Prevent selection and cursors from interfering with the scroll  // width and height.  removeChildren(display.cursorDiv)  removeChildren(display.selectionDiv)  display.gutters.style.height = display.sizer.style.minHeight = 0
if (different) {    display.lastWrapHeight = update.wrapperHeight    display.lastWrapWidth = update.wrapperWidth    startWorker(cm, 400)  }
display.updateLineNumbers = null
return true
}
function postUpdateDisplay(cm, update) {
var viewport = update.viewport
for (var first = true;; first = false) {    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {      // Clip forced viewport to actual scrollable area.      if (viewport && viewport.top != null)        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)} }      // Updated line heights might result in the drawn area not      // actually covering the viewport. Keep looping until it does.      update.visible = visibleLines(cm.display, cm.doc, viewport)      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)        { break }    }    if (!updateDisplayIfNeeded(cm, update)) { break }    updateHeightsInViewport(cm)    var barMeasure = measureForScrollbars(cm)    updateSelection(cm)    updateScrollbars(cm, barMeasure)    setDocumentHeight(cm, barMeasure)  }
update.signal(cm, "update", cm)  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo)    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo  }
}
function updateDisplaySimple(cm, viewport) {
var update = new DisplayUpdate(cm, viewport)  if (updateDisplayIfNeeded(cm, update)) {    updateHeightsInViewport(cm)    postUpdateDisplay(cm, update)    var barMeasure = measureForScrollbars(cm)    updateSelection(cm)    updateScrollbars(cm, barMeasure)    setDocumentHeight(cm, barMeasure)    update.finish()  }
}
// Sync the actual display DOM structure with display.view, removing // nodes for lines that are no longer in view, and creating the ones // that are not there yet, and updating the ones that are out of // date. function patchDisplay(cm, updateNumbersFrom, dims) {
var display = cm.display, lineNumbers = cm.options.lineNumbers  var container = display.lineDiv, cur = container.firstChild
function rm(node) {    var next = node.nextSibling    // Works around a throw-scroll bug in OS X Webkit    if (webkit && mac && cm.display.currentWheelTarget == node)      { node.style.display = "none" }    else      { node.parentNode.removeChild(node) }    return next  }
var view = display.view, lineN = display.viewFrom  // Loop over the elements in the view, syncing cur (the DOM nodes  // in display.lineDiv) with the view as we go.  for (var i = 0; i < view.length; i++) {    var lineView = view[i]    if (lineView.hidden) {    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet      var node = buildLineElement(cm, lineView, lineN, dims)      container.insertBefore(node, cur)    } else { // Already drawn      while (cur != lineView.node) { cur = rm(cur) }      var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber      if (lineView.changes) {        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false }        updateLineForChanges(cm, lineView, lineN, dims)      }      if (updateNumber) {        removeChildren(lineView.lineNumber)        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))      }      cur = lineView.node.nextSibling    }    lineN += lineView.size  }  while (cur) { cur = rm(cur) }
}
function updateGutterSpace(cm) {
var width = cm.display.gutters.offsetWidth  cm.display.sizer.style.marginLeft = width + "px"
}
function setDocumentHeight(cm, measure) {
cm.display.sizer.style.minHeight = measure.docHeight + "px"  cm.display.heightForcer.style.top = measure.docHeight + "px"  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px"
}
// Rebuild the gutter elements, ensure the margin to the left of the // code matches their width. function updateGutters(cm) {
var gutters = cm.display.gutters, specs = cm.options.gutters  removeChildren(gutters)  var i = 0  for (; i < specs.length; ++i) {    var gutterClass = specs[i]    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass))    if (gutterClass == "CodeMirror-linenumbers") {      cm.display.lineGutter = gElt      gElt.style.width = (cm.display.lineNumWidth || 1) + "px"    }  }  gutters.style.display = i ? "" : "none"  updateGutterSpace(cm)
}
// Make sure the gutters options contains the element // "CodeMirror-linenumbers" when the lineNumbers option is true. function setGuttersForLineNumbers(options) {
var found = indexOf(options.gutters, "CodeMirror-linenumbers")  if (found == -1 && options.lineNumbers) {    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"])  } else if (found > -1 && !options.lineNumbers) {    options.gutters = options.gutters.slice(0)    options.gutters.splice(found, 1)  }
}
// Selection objects are immutable. A new one is created every time // the selection changes. A selection is one or more non-overlapping // (and non-touching) ranges, sorted, and an integer that indicates // which one is the primary selection (the one that's scrolled into // view, that getCursor returns, etc). var Selection = function(ranges, primIndex) {
this.ranges = ranges  this.primIndex = primIndex
};
Selection.prototype.primary = function () { return this.ranges[this.primIndex] };
Selection.prototype.equals = function (other) {
var this$1 = this;
if (other == this) { return true }  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }  for (var i = 0; i < this.ranges.length; i++) {    var here = this$1.ranges[i], there = other.ranges[i]    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }  }  return true
};
Selection.prototype.deepCopy = function () {
var this$1 = this;
var out = []  for (var i = 0; i < this.ranges.length; i++)    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)) }  return new Selection(out, this.primIndex)
};
Selection.prototype.somethingSelected = function () {
var this$1 = this;
for (var i = 0; i < this.ranges.length; i++)    { if (!this$1.ranges[i].empty()) { return true } }  return false
};
Selection.prototype.contains = function (pos, end) {
var this$1 = this;
if (!end) { end = pos }  for (var i = 0; i < this.ranges.length; i++) {    var range = this$1.ranges[i]    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)      { return i }  }  return -1
};
var Range = function(anchor, head) {
this.anchor = anchor; this.head = head
};
Range.prototype.from = function () { return minPos(this.anchor, this.head) }; Range.prototype.to = function () { return maxPos(this.anchor, this.head) }; Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };
// Take an unsorted, potentially overlapping set of ranges, and // build a selection out of it. 'Consumes' ranges array (modifying // it). function normalizeSelection(ranges, primIndex) {
var prim = ranges[primIndex]  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); })  primIndex = indexOf(ranges, prim)  for (var i = 1; i < ranges.length; i++) {    var cur = ranges[i], prev = ranges[i - 1]    if (cmp(prev.to(), cur.from()) >= 0) {      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to())      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head      if (i <= primIndex) { --primIndex }      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))    }  }  return new Selection(ranges, primIndex)
}
function simpleSelection(anchor, head) {
return new Selection([new Range(anchor, head || anchor)], 0)
}
// Compute the position of the end of a change (its 'to' property // refers to the pre-change end). function changeEnd(change) {
if (!change.text) { return change.to }  return Pos(change.from.line + change.text.length - 1,             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
}
// Adjust a position to refer to the post-change position of the // same text, or the end of the change if the change covers it. function adjustForChange(pos, change) {
if (cmp(pos, change.from) < 0) { return pos }  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }
var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch }  return Pos(line, ch)
}
function computeSelAfterChange(doc, change) {
var out = []  for (var i = 0; i < doc.sel.ranges.length; i++) {    var range = doc.sel.ranges[i]    out.push(new Range(adjustForChange(range.anchor, change),                       adjustForChange(range.head, change)))  }  return normalizeSelection(out, doc.sel.primIndex)
}
function offsetPos(pos, old, nw) {
if (pos.line == old.line)    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }  else    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
}
// Used by replaceSelections to allow moving the selection to the // start or around the replaced test. Hint may be "start" or "around". function computeReplacedSel(doc, changes, hint) {
var out = []  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev  for (var i = 0; i < changes.length; i++) {    var change = changes[i]    var from = offsetPos(change.from, oldPrev, newPrev)    var to = offsetPos(changeEnd(change), oldPrev, newPrev)    oldPrev = change.to    newPrev = to    if (hint == "around") {      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0      out[i] = new Range(inv ? to : from, inv ? from : to)    } else {      out[i] = new Range(from, from)    }  }  return new Selection(out, doc.sel.primIndex)
}
// Used to get the editor into a consistent state again when options change.
function loadMode(cm) {
cm.doc.mode = getMode(cm.options, cm.doc.modeOption)  resetModeState(cm)
}
function resetModeState(cm) {
cm.doc.iter(function (line) {    if (line.stateAfter) { line.stateAfter = null }    if (line.styles) { line.styles = null }  })  cm.doc.frontier = cm.doc.first  startWorker(cm, 100)  cm.state.modeGen++  if (cm.curOp) { regChange(cm) }
}
// DOCUMENT DATA STRUCTURE
// By default, updates that start and end at the beginning of a line // are treated specially, in order to make the association of line // widgets and marker elements with the text behave more intuitive. function isWholeLineUpdate(doc, change) {
return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
}
// Perform a change on the document data structure. function updateDoc(doc, change, markedSpans, estimateHeight) {
function spansFor(n) {return markedSpans ? markedSpans[n] : null}  function update(line, text, spans) {    updateLine(line, text, spans, estimateHeight)    signalLater(line, "change", line, change)  }  function linesFor(start, end) {    var result = []    for (var i = start; i < end; ++i)      { result.push(new Line(text[i], spansFor(i), estimateHeight)) }    return result  }
var from = change.from, to = change.to, text = change.text  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line)  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line
// Adjust the line structure  if (change.full) {    doc.insert(0, linesFor(0, text.length))    doc.remove(text.length, doc.size - text.length)  } else if (isWholeLineUpdate(doc, change)) {    // This is a whole-line replace. Treated specially to make    // sure line objects move the way they are supposed to.    var added = linesFor(0, text.length - 1)    update(lastLine, lastLine.text, lastSpans)    if (nlines) { doc.remove(from.line, nlines) }    if (added.length) { doc.insert(from.line, added) }  } else if (firstLine == lastLine) {    if (text.length == 1) {      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans)    } else {      var added$1 = linesFor(1, text.length - 1)      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight))      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))      doc.insert(from.line + 1, added$1)    }  } else if (text.length == 1) {    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0))    doc.remove(from.line + 1, nlines)  } else {    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans)    var added$2 = linesFor(1, text.length - 1)    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1) }    doc.insert(from.line + 1, added$2)  }
signalLater(doc, "change", doc, change)
}
// Call f for all linked documents. function linkedDocs(doc, f, sharedHistOnly) {
function propagate(doc, skip, sharedHist) {    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {      var rel = doc.linked[i]      if (rel.doc == skip) { continue }      var shared = sharedHist && rel.sharedHist      if (sharedHistOnly && !shared) { continue }      f(rel.doc, shared)      propagate(rel.doc, doc, shared)    } }  }  propagate(doc, null, true)
}
// Attach a document to an editor. function attachDoc(cm, doc) {
if (doc.cm) { throw new Error("This document is already in use.") }  cm.doc = doc  doc.cm = cm  estimateLineHeights(cm)  loadMode(cm)  if (!cm.options.lineWrapping) { findMaxLine(cm) }  cm.options.mode = doc.modeOption  regChange(cm)
}
function History(startGen) {
// Arrays of change events and selections. Doing something adds an  // event to done and clears undo. Undoing moves events from done  // to undone, redoing moves them in the other direction.  this.done = []; this.undone = []  this.undoDepth = Infinity  // Used to track when changes can be merged into a single undo  // event  this.lastModTime = this.lastSelTime = 0  this.lastOp = this.lastSelOp = null  this.lastOrigin = this.lastSelOrigin = null  // Used by the isClean() method  this.generation = this.maxGeneration = startGen || 1
}
// Create a history change event from an updateDoc-style change // object. function historyChangeFromChange(doc, change) {
var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)}  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true)  return histChange
}
// Pop all selection events off the end of a history array. Stop at // a change event. function clearSelectionEvents(array) {
while (array.length) {    var last = lst(array)    if (last.ranges) { array.pop() }    else { break }  }
}
// Find the top change event in the history. Pop off selection // events that are in the way. function lastChangeEvent(hist, force) {
if (force) {    clearSelectionEvents(hist.done)    return lst(hist.done)  } else if (hist.done.length && !lst(hist.done).ranges) {    return lst(hist.done)  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {    hist.done.pop()    return lst(hist.done)  }
}
// Register a change in the history. Merges changes that are within // a single operation, or are close together with an origin that // allows merging (starting with "+") into a single event. function addChangeToHistory(doc, change, selAfter, opId) {
var hist = doc.history  hist.undone.length = 0  var time = +new Date, cur  var last
if ((hist.lastOp == opId ||       hist.lastOrigin == change.origin && change.origin && ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||        change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {    // Merge this change into the last event    last = lst(cur.changes)    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {      // Optimized case for simple insertion -- don't want to add      // new changesets for every character typed      last.to = changeEnd(change)    } else {      // Add new sub-event      cur.changes.push(historyChangeFromChange(doc, change))    }  } else {    // Can not be merged, start a new event.    var before = lst(hist.done)    if (!before || !before.ranges)      { pushSelectionToHistory(doc.sel, hist.done) }    cur = {changes: [historyChangeFromChange(doc, change)],           generation: hist.generation}    hist.done.push(cur)    while (hist.done.length > hist.undoDepth) {      hist.done.shift()      if (!hist.done[0].ranges) { hist.done.shift() }    }  }  hist.done.push(selAfter)  hist.generation = ++hist.maxGeneration  hist.lastModTime = hist.lastSelTime = time  hist.lastOp = hist.lastSelOp = opId  hist.lastOrigin = hist.lastSelOrigin = change.origin
if (!last) { signal(doc, "historyAdded") }
}
function selectionEventCanBeMerged(doc, origin, prev, sel) {
var ch = origin.charAt(0)  return ch == "*" ||    ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
}
// Called whenever the selection changes, sets the new selection as // the pending selection in the history, and pushes the old pending // selection into the 'done' array when it was significantly // different (in number of selected ranges, emptiness, or time). function addSelectionToHistory(doc, sel, opId, options) {
var hist = doc.history, origin = options && options.origin
// A new event is started when the previous origin does not match  // the current, or the origins don't allow matching. Origins  // starting with * are always merged, those starting with + are  // merged when similar and close together in time.  if (opId == hist.lastSelOp ||      (origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))    { hist.done[hist.done.length - 1] = sel }  else    { pushSelectionToHistory(sel, hist.done) }
hist.lastSelTime = +new Date  hist.lastSelOrigin = origin  hist.lastSelOp = opId  if (options && options.clearRedo !== false)    { clearSelectionEvents(hist.undone) }
}
function pushSelectionToHistory(sel, dest) {
var top = lst(dest)  if (!(top && top.ranges && top.equals(sel)))    { dest.push(sel) }
}
// Used to store marked span information in the history. function attachLocalSpans(doc, change, from, to) {
var existing = change["spans_" + doc.id], n = 0  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {    if (line.markedSpans)      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans }    ++n  })
}
// When un/re-doing restores text containing marked spans, those // that have been explicitly cleared should not be restored. function removeClearedSpans(spans) {
if (!spans) { return null }  var out  for (var i = 0; i < spans.length; ++i) {    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i) } }    else if (out) { out.push(spans[i]) }  }  return !out ? spans : out.length ? out : null
}
// Retrieve and filter the old marked spans stored in a change event. function getOldSpans(doc, change) {
var found = change["spans_" + doc.id]  if (!found) { return null }  var nw = []  for (var i = 0; i < change.text.length; ++i)    { nw.push(removeClearedSpans(found[i])) }  return nw
}
// Used for un/re-doing changes from the history. Combines the // result of computing the existing spans with the set of spans that // existed in the history (so that deleting around a span and then // undoing brings back the span). function mergeOldSpans(doc, change) {
var old = getOldSpans(doc, change)  var stretched = stretchSpansOverChange(doc, change)  if (!old) { return stretched }  if (!stretched) { return old }
for (var i = 0; i < old.length; ++i) {    var oldCur = old[i], stretchCur = stretched[i]    if (oldCur && stretchCur) {      spans: for (var j = 0; j < stretchCur.length; ++j) {        var span = stretchCur[j]        for (var k = 0; k < oldCur.length; ++k)          { if (oldCur[k].marker == span.marker) { continue spans } }        oldCur.push(span)      }    } else if (stretchCur) {      old[i] = stretchCur    }  }  return old
}
// Used both to provide a JSON-safe object in .getHistory, and, when // detaching a document, to split the history in two function copyHistoryArray(events, newGroup, instantiateSel) {
var copy = []  for (var i = 0; i < events.length; ++i) {    var event = events[i]    if (event.ranges) {      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event)      continue    }    var changes = event.changes, newChanges = []    copy.push({changes: newChanges})    for (var j = 0; j < changes.length; ++j) {      var change = changes[j], m = (void 0)      newChanges.push({from: change.from, to: change.to, text: change.text})      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {        if (indexOf(newGroup, Number(m[1])) > -1) {          lst(newChanges)[prop] = change[prop]          delete change[prop]        }      } } }    }  }  return copy
}
// The 'scroll' parameter given to many of these indicated whether // the new cursor position should be scrolled into view after // modifying the selection.
// If shift is held or the extend flag is set, extends a range to // include a given position (and optionally a second position). // Otherwise, simply returns the range between the given positions. // Used for cursor motion and such. function extendRange(doc, range, head, other) {
if (doc.cm && doc.cm.display.shift || doc.extend) {    var anchor = range.anchor    if (other) {      var posBefore = cmp(head, anchor) < 0      if (posBefore != (cmp(other, anchor) < 0)) {        anchor = head        head = other      } else if (posBefore != (cmp(head, other) < 0)) {        head = other      }    }    return new Range(anchor, head)  } else {    return new Range(other || head, head)  }
}
// Extend the primary selection range, discard the rest. function extendSelection(doc, head, other, options) {
setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options)
}
// Extend all selections (pos is an array of selections with length // equal the number of selections) function extendSelections(doc, heads, options) {
var out = []  for (var i = 0; i < doc.sel.ranges.length; i++)    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null) }  var newSel = normalizeSelection(out, doc.sel.primIndex)  setSelection(doc, newSel, options)
}
// Updates a single range in the selection. function replaceOneSelection(doc, i, range, options) {
var ranges = doc.sel.ranges.slice(0)  ranges[i] = range  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)
}
// Reset the selection to a single range. function setSimpleSelection(doc, anchor, head, options) {
setSelection(doc, simpleSelection(anchor, head), options)
}
// Give beforeSelectionChange handlers a change to influence a // selection update. function filterSelectionChange(doc, sel, options) {
var obj = {    ranges: sel.ranges,    update: function(ranges) {      var this$1 = this;
this.ranges = []      for (var i = 0; i < ranges.length; i++)        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),                                   clipPos(doc, ranges[i].head)) }    },    origin: options && options.origin  }  signal(doc, "beforeSelectionChange", doc, obj)  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj) }  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }  else { return sel }
}
function setSelectionReplaceHistory(doc, sel, options) {
var done = doc.history.done, last = lst(done)  if (last && last.ranges) {    done[done.length - 1] = sel    setSelectionNoUndo(doc, sel, options)  } else {    setSelection(doc, sel, options)  }
}
// Set a new selection. function setSelection(doc, sel, options) {
setSelectionNoUndo(doc, sel, options)  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)
}
function setSelectionNoUndo(doc, sel, options) {
if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))    { sel = filterSelectionChange(doc, sel, options) }
var bias = options && options.bias ||    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1)  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true))
if (!(options && options.scroll === false) && doc.cm)    { ensureCursorVisible(doc.cm) }
}
function setSelectionInner(doc, sel) {
if (sel.equals(doc.sel)) { return }
doc.sel = sel
if (doc.cm) {    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true    signalCursorActivity(doc.cm)  }  signalLater(doc, "cursorActivity", doc)
}
// Verify that the selection does not partially select any atomic // marked ranges. function reCheckSelection(doc) {
setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll)
}
// Return a selection that does not partially select any atomic // ranges. function skipAtomicInSelection(doc, sel, bias, mayClear) {
var out  for (var i = 0; i < sel.ranges.length; i++) {    var range = sel.ranges[i]    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i]    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear)    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear)    if (out || newAnchor != range.anchor || newHead != range.head) {      if (!out) { out = sel.ranges.slice(0, i) }      out[i] = new Range(newAnchor, newHead)    }  }  return out ? normalizeSelection(out, sel.primIndex) : sel
}
function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
var line = getLine(doc, pos.line)  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {    var sp = line.markedSpans[i], m = sp.marker    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {      if (mayClear) {        signal(m, "beforeCursorEnter")        if (m.explicitlyCleared) {          if (!line.markedSpans) { break }          else {--i; continue}        }      }      if (!m.atomic) { continue }
if (oldPos) {        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0)        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null) }        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))          { return skipAtomicInner(doc, near, pos, dir, mayClear) }      }
var far = m.find(dir < 0 ? -1 : 1)      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)        { far = movePos(doc, far, dir, far.line == pos.line ? line : null) }      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null    }  } }  return pos
}
// Ensure a given position is not inside an atomic range. function skipAtomic(doc, pos, oldPos, bias, mayClear) {
var dir = bias || 1  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true))  if (!found) {    doc.cantEdit = true    return Pos(doc.first, 0)  }  return found
}
function movePos(doc, pos, dir, line) {
if (dir < 0 && pos.ch == 0) {    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }    else { return null }  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }    else { return null }  } else {    return new Pos(pos.line, pos.ch + dir)  }
}
function selectAll(cm) {
cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)
}
// UPDATING
// Allow "beforeChange" event handlers to influence a change function filterChange(doc, change, update) {
var obj = {    canceled: false,    from: change.from,    to: change.to,    text: change.text,    origin: change.origin,    cancel: function () { return obj.canceled = true; }  }  if (update) { obj.update = function (from, to, text, origin) {    if (from) { obj.from = clipPos(doc, from) }    if (to) { obj.to = clipPos(doc, to) }    if (text) { obj.text = text }    if (origin !== undefined) { obj.origin = origin }  } }  signal(doc, "beforeChange", doc, obj)  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj) }
if (obj.canceled) { return null }  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
}
// Apply a change to a document, and add it to the document's // history, and propagating it to all linked documents. function makeChange(doc, change, ignoreReadOnly) {
if (doc.cm) {    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }    if (doc.cm.state.suppressEdits) { return }  }
if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {    change = filterChange(doc, change, true)    if (!change) { return }  }
// Possibly split or suppress the update based on the presence  // of read-only spans in its range.  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to)  if (split) {    for (var i = split.length - 1; i >= 0; --i)      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text}) }  } else {    makeChangeInner(doc, change)  }
}
function makeChangeInner(doc, change) {
if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }  var selAfter = computeSelAfterChange(doc, change)  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN)
makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change))  var rebased = []
linkedDocs(doc, function (doc, sharedHist) {    if (!sharedHist && indexOf(rebased, doc.history) == -1) {      rebaseHist(doc.history, change)      rebased.push(doc.history)    }    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))  })
}
// Revert a change stored in a document's history. function makeChangeFromHistory(doc, type, allowSelectionOnly) {
if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }
var hist = doc.history, event, selAfter = doc.sel  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done
// Verify that there is a useable event (so that ctrl-z won't  // needlessly clear selection events)  var i = 0  for (; i < source.length; i++) {    event = source[i]    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)      { break }  }  if (i == source.length) { return }  hist.lastOrigin = hist.lastSelOrigin = null
for (;;) {    event = source.pop()    if (event.ranges) {      pushSelectionToHistory(event, dest)      if (allowSelectionOnly && !event.equals(doc.sel)) {        setSelection(doc, event, {clearRedo: false})        return      }      selAfter = event    }    else { break }  }
// Build up a reverse change object to add to the opposite history  // stack (redo when undoing, and vice versa).  var antiChanges = []  pushSelectionToHistory(selAfter, dest)  dest.push({changes: antiChanges, generation: hist.generation})  hist.generation = event.generation || ++hist.maxGeneration
var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")
var loop = function ( i ) {    var change = event.changes[i]    change.origin = type    if (filter && !filterChange(doc, change, false)) {      source.length = 0      return {}    }
antiChanges.push(historyChangeFromChange(doc, change))
var after = i ? computeSelAfterChange(doc, change) : lst(source)    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change))    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}) }    var rebased = []
// Propagate to the linked documents    linkedDocs(doc, function (doc, sharedHist) {      if (!sharedHist && indexOf(rebased, doc.history) == -1) {        rebaseHist(doc.history, change)        rebased.push(doc.history)      }      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))    })  };
for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {    var returned = loop( i$1 );
if ( returned ) return returned.v;  }
}
// Sub-views need their line numbers shifted when text is added // above or below them in the parent document. function shiftDoc(doc, distance) {
if (distance == 0) { return }  doc.first += distance  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(    Pos(range.anchor.line + distance, range.anchor.ch),    Pos(range.head.line + distance, range.head.ch)  ); }), doc.sel.primIndex)  if (doc.cm) {    regChange(doc.cm, doc.first, doc.first - distance, distance)    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)      { regLineChange(doc.cm, l, "gutter") }  }
}
// More lower-level change function, handling only a single document // (not linked ones). function makeChangeSingleDoc(doc, change, selAfter, spans) {
if (doc.cm && !doc.cm.curOp)    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }
if (change.to.line < doc.first) {    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line))    return  }  if (change.from.line > doc.lastLine()) { return }
// Clip the change to the size of this doc  if (change.from.line < doc.first) {    var shift = change.text.length - 1 - (doc.first - change.from.line)    shiftDoc(doc, shift)    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),              text: [lst(change.text)], origin: change.origin}  }  var last = doc.lastLine()  if (change.to.line > last) {    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),              text: [change.text[0]], origin: change.origin}  }
change.removed = getBetween(doc, change.from, change.to)
if (!selAfter) { selAfter = computeSelAfterChange(doc, change) }  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans) }  else { updateDoc(doc, change, spans) }  setSelectionNoUndo(doc, selAfter, sel_dontScroll)
}
// Handle the interaction of a change to a document with the editor // that this document is part of. function makeChangeSingleDocInEditor(cm, change, spans) {
var doc = cm.doc, display = cm.display, from = change.from, to = change.to
var recomputeMaxLength = false, checkWidthStart = from.line  if (!cm.options.lineWrapping) {    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)))    doc.iter(checkWidthStart, to.line + 1, function (line) {      if (line == display.maxLine) {        recomputeMaxLength = true return true      }    })  }
if (doc.sel.contains(change.from, change.to) > -1)    { signalCursorActivity(cm) }
updateDoc(doc, change, spans, estimateHeight(cm))
if (!cm.options.lineWrapping) {    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {      var len = lineLength(line)      if (len > display.maxLineLength) {        display.maxLine = line        display.maxLineLength = len        display.maxLineChanged = true        recomputeMaxLength = false      }    })    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true }  }
// Adjust frontier, schedule worker  doc.frontier = Math.min(doc.frontier, from.line)  startWorker(cm, 400)
var lendiff = change.text.length - (to.line - from.line) - 1  // Remember that these lines changed, for updating the display  if (change.full)    { regChange(cm) }  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))    { regLineChange(cm, from.line, "text") }  else    { regChange(cm, from.line, to.line + 1, lendiff) }
var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change")  if (changeHandler || changesHandler) {    var obj = {      from: from, to: to,      text: change.text,      removed: change.removed,      origin: change.origin    }    if (changeHandler) { signalLater(cm, "change", cm, obj) }    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj) }  }  cm.display.selForContextMenu = null
}
function replaceRange(doc, code, from, to, origin) {
if (!to) { to = from }  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp }  if (typeof code == "string") { code = doc.splitLines(code) }  makeChange(doc, {from: from, to: to, text: code, origin: origin})
}
// Rebasing/resetting history to deal with externally-sourced changes
function rebaseHistSelSingle(pos, from, to, diff) {
if (to < pos.line) {    pos.line += diff  } else if (from < pos.line) {    pos.line = from    pos.ch = 0  }
}
// Tries to rebase an array of history events given a change in the // document. If the change touches the same lines as the event, the // event, and everything 'behind' it, is discarded. If the change is // before the event, the event's positions are updated. Uses a // copy-on-write scheme for the positions, to avoid having to // reallocate them all on every rebase, but also avoid problems with // shared position objects being unsafely updated. function rebaseHistArray(array, from, to, diff) {
for (var i = 0; i < array.length; ++i) {    var sub = array[i], ok = true    if (sub.ranges) {      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true }      for (var j = 0; j < sub.ranges.length; j++) {        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff)        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)      }      continue    }    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {      var cur = sub.changes[j$1]      if (to < cur.from.line) {        cur.from = Pos(cur.from.line + diff, cur.from.ch)        cur.to = Pos(cur.to.line + diff, cur.to.ch)      } else if (from <= cur.to.line) {        ok = false        break      }    }    if (!ok) {      array.splice(0, i + 1)      i = 0    }  }
}
function rebaseHist(hist, change) {
var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1  rebaseHistArray(hist.done, from, to, diff)  rebaseHistArray(hist.undone, from, to, diff)
}
// Utility for applying a change to a line by handle or number, // returning the number and optionally registering the line as // changed. function changeLine(doc, handle, changeType, op) {
var no = handle, line = handle  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)) }  else { no = lineNo(handle) }  if (no == null) { return null } if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType) }  return line
}
// The document is represented as a BTree consisting of leaves, with // chunk of lines in them, and branches, with up to ten leaves or // other branch nodes below them. The top node is always a branch // node, and is the document object itself (meaning it has // additional methods and properties). // // All nodes have parent links. The tree is used both to go from // line numbers to line objects, and to go from objects to numbers. // It also indexes by height, and is used to convert between height // and line object, and to find the total height of the document. // // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
var LeafChunk = function(lines) {
var this$1 = this;
this.lines = lines  this.parent = null  var height = 0  for (var i = 0; i < lines.length; ++i) {    lines[i].parent = this$1    height += lines[i].height  }  this.height = height
};
LeafChunk.prototype.chunkSize = function () { return this.lines.length };
// Remove the n lines at offset 'at'. LeafChunk.prototype.removeInner = function (at, n) {
var this$1 = this;
for (var i = at, e = at + n; i < e; ++i) {    var line = this$1.lines[i]    this$1.height -= line.height    cleanUpLine(line)    signalLater(line, "delete")  }  this.lines.splice(at, n)
};
// Helper used to collapse a small branch into a single leaf. LeafChunk.prototype.collapse = function (lines) {
lines.push.apply(lines, this.lines)
};
// Insert the given array of lines at offset 'at', count them as // having the given height. LeafChunk.prototype.insertInner = function (at, lines, height) {
var this$1 = this;
this.height += height  this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at))  for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1 }
};
// Used to iterate over a part of the tree. LeafChunk.prototype.iterN = function (at, n, op) {
var this$1 = this;
for (var e = at + n; at < e; ++at)    { if (op(this$1.lines[at])) { return true } }
};
var BranchChunk = function(children) {
var this$1 = this;
this.children = children  var size = 0, height = 0  for (var i = 0; i < children.length; ++i) {    var ch = children[i]    size += ch.chunkSize(); height += ch.height    ch.parent = this$1  }  this.size = size  this.height = height  this.parent = null
};
BranchChunk.prototype.chunkSize = function () { return this.size };
BranchChunk.prototype.removeInner = function (at, n) {
var this$1 = this;
this.size -= n  for (var i = 0; i < this.children.length; ++i) {    var child = this$1.children[i], sz = child.chunkSize()    if (at < sz) {      var rm = Math.min(n, sz - at), oldHeight = child.height      child.removeInner(at, rm)      this$1.height -= oldHeight - child.height      if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null }      if ((n -= rm) == 0) { break }      at = 0    } else { at -= sz }  }  // If the result is smaller than 25 lines, ensure that it is a  // single leaf node.  if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {    var lines = []    this.collapse(lines)    this.children = [new LeafChunk(lines)]    this.children[0].parent = this  }
};
BranchChunk.prototype.collapse = function (lines) {
var this$1 = this;
for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines) }
};
BranchChunk.prototype.insertInner = function (at, lines, height) {
var this$1 = this;
this.size += lines.length  this.height += height  for (var i = 0; i < this.children.length; ++i) {    var child = this$1.children[i], sz = child.chunkSize()    if (at <= sz) {      child.insertInner(at, lines, height)      if (child.lines && child.lines.length > 50) {        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.        var remaining = child.lines.length % 25 + 25        for (var pos = remaining; pos < child.lines.length;) {          var leaf = new LeafChunk(child.lines.slice(pos, pos += 25))          child.height -= leaf.height          this$1.children.splice(++i, 0, leaf)          leaf.parent = this$1        }        child.lines = child.lines.slice(0, remaining)        this$1.maybeSpill()      }      break    }    at -= sz  }
};
// When a node has grown, check whether it should be split. BranchChunk.prototype.maybeSpill = function () {
if (this.children.length <= 10) { return }  var me = this  do {    var spilled = me.children.splice(me.children.length - 5, 5)    var sibling = new BranchChunk(spilled)    if (!me.parent) { // Become the parent node      var copy = new BranchChunk(me.children)      copy.parent = me      me.children = [copy, sibling]      me = copy   } else {      me.size -= sibling.size      me.height -= sibling.height      var myIndex = indexOf(me.parent.children, me)      me.parent.children.splice(myIndex + 1, 0, sibling)    }    sibling.parent = me.parent  } while (me.children.length > 10)  me.parent.maybeSpill()
};
BranchChunk.prototype.iterN = function (at, n, op) {
var this$1 = this;
for (var i = 0; i < this.children.length; ++i) {    var child = this$1.children[i], sz = child.chunkSize()    if (at < sz) {      var used = Math.min(n, sz - at)      if (child.iterN(at, used, op)) { return true }      if ((n -= used) == 0) { break }      at = 0    } else { at -= sz }  }
};
// Line widgets are block elements displayed above or below a line.
var LineWidget = function(doc, node, options) {
var this$1 = this;
if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))    { this$1[opt] = options[opt] } } }  this.doc = doc  this.node = node
};
LineWidget.prototype.clear = function () {
var this$1 = this;
var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line)  if (no == null || !ws) { return }  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1) } }  if (!ws.length) { line.widgets = null }  var height = widgetHeight(this)  updateLineHeight(line, Math.max(0, line.height - height))  if (cm) {    runInOp(cm, function () {      adjustScrollWhenAboveVisible(cm, line, -height)      regLineChange(cm, no, "widget")    })    signalLater(cm, "lineWidgetCleared", cm, this, no)  }
};
LineWidget.prototype.changed = function () {
var this$1 = this;
var oldH = this.height, cm = this.doc.cm, line = this.line  this.height = null  var diff = widgetHeight(this) - oldH  if (!diff) { return }  updateLineHeight(line, line.height + diff)  if (cm) {    runInOp(cm, function () {      cm.curOp.forceUpdate = true      adjustScrollWhenAboveVisible(cm, line, diff)      signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line))    })  }
}; eventMixin(LineWidget)
function adjustScrollWhenAboveVisible(cm, line, diff) {
if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))    { addToScrollPos(cm, null, diff) }
}
function addLineWidget(doc, handle, node, options) {
var widget = new LineWidget(doc, node, options)  var cm = doc.cm  if (cm && widget.noHScroll) { cm.display.alignWidgets = true }  changeLine(doc, handle, "widget", function (line) {    var widgets = line.widgets || (line.widgets = [])    if (widget.insertAt == null) { widgets.push(widget) }    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget) }    widget.line = line    if (cm && !lineIsHidden(doc, line)) {      var aboveVisible = heightAtLine(line) < doc.scrollTop      updateLineHeight(line, line.height + widgetHeight(widget))      if (aboveVisible) { addToScrollPos(cm, null, widget.height) }      cm.curOp.forceUpdate = true    }    return true  })  signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle))  return widget
}
// TEXTMARKERS
// Created with markText and setBookmark methods. A TextMarker is a // handle that can be used to clear or find a marked position in the // document. Line objects hold arrays (markedSpans) containing // {from, to, marker} object pointing to such marker objects, and // indicating that such a marker is present on that line. Multiple // lines may point to the same marker when it spans across lines. // The spans will have null for their from/to properties when the // marker continues beyond the start/end of the line. Markers have // links back to the lines they currently touch.
// Collapsed markers have unique ids, in order to be able to order // them, which is needed for uniquely determining an outer marker // when they overlap (they may nest, but not partially overlap). var nextMarkerId = 0
var TextMarker = function(doc, type) {
this.lines = []  this.type = type  this.doc = doc  this.id = ++nextMarkerId
};
// Clear the marker. TextMarker.prototype.clear = function () {
var this$1 = this;
if (this.explicitlyCleared) { return }  var cm = this.doc.cm, withOp = cm && !cm.curOp  if (withOp) { startOperation(cm) }  if (hasHandler(this, "clear")) {    var found = this.find()    if (found) { signalLater(this, "clear", found.from, found.to) }  }  var min = null, max = null  for (var i = 0; i < this.lines.length; ++i) {    var line = this$1.lines[i]    var span = getMarkedSpanFor(line.markedSpans, this$1)    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text") }    else if (cm) {      if (span.to != null) { max = lineNo(line) }      if (span.from != null) { min = lineNo(line) }    }    line.markedSpans = removeMarkedSpan(line.markedSpans, span)    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)      { updateLineHeight(line, textHeight(cm.display)) }  }  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual)    if (len > cm.display.maxLineLength) {      cm.display.maxLine = visual      cm.display.maxLineLength = len      cm.display.maxLineChanged = true    }  } }
if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1) }  this.lines.length = 0  this.explicitlyCleared = true  if (this.atomic && this.doc.cantEdit) {    this.doc.cantEdit = false    if (cm) { reCheckSelection(cm.doc) }  }  if (cm) { signalLater(cm, "markerCleared", cm, this, min, max) }  if (withOp) { endOperation(cm) }  if (this.parent) { this.parent.clear() }
};
// Find the position of the marker in the document. Returns a {from, // to} object by default. Side can be passed to get a specific side // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the // Pos objects returned contain a line object, rather than a line // number (used to prevent looking up the same line twice). TextMarker.prototype.find = function (side, lineObj) {
var this$1 = this;
if (side == null && this.type == "bookmark") { side = 1 }  var from, to  for (var i = 0; i < this.lines.length; ++i) {    var line = this$1.lines[i]    var span = getMarkedSpanFor(line.markedSpans, this$1)    if (span.from != null) {      from = Pos(lineObj ? line : lineNo(line), span.from)      if (side == -1) { return from }    }    if (span.to != null) {      to = Pos(lineObj ? line : lineNo(line), span.to)      if (side == 1) { return to }    }  }  return from && {from: from, to: to}
};
// Signals that the marker's widget changed, and surrounding layout // should be recomputed. TextMarker.prototype.changed = function () {
var this$1 = this;
var pos = this.find(-1, true), widget = this, cm = this.doc.cm  if (!pos || !cm) { return }  runInOp(cm, function () {    var line = pos.line, lineN = lineNo(pos.line)    var view = findViewForLine(cm, lineN)    if (view) {      clearLineMeasurementCacheFor(view)      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true    }    cm.curOp.updateMaxLine = true    if (!lineIsHidden(widget.doc, line) && widget.height != null) {      var oldHeight = widget.height      widget.height = null      var dHeight = widgetHeight(widget) - oldHeight      if (dHeight)        { updateLineHeight(line, line.height + dHeight) }    }    signalLater(cm, "markerChanged", cm, this$1)  })
};
TextMarker.prototype.attachLine = function (line) {
if (!this.lines.length && this.doc.cm) {    var op = this.doc.cm.curOp    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this) }  }  this.lines.push(line)
};
TextMarker.prototype.detachLine = function (line) {
this.lines.splice(indexOf(this.lines, line), 1)  if (!this.lines.length && this.doc.cm) {    var op = this.doc.cm.curOp  ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)  }
}; eventMixin(TextMarker)
// Create a marker, wire it up to the right lines, and function markText(doc, from, to, options, type) {
// Shared markers (across linked documents) are handled separately  // (markTextShared will call out to this again, once per  // document).  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }  // Ensure we are in an operation.  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }
var marker = new TextMarker(doc, type), diff = cmp(from, to)  if (options) { copyObj(options, marker, false) }  // Don't connect empty markers unless clearWhenEmpty is false  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)    { return marker }  if (marker.replacedWith) {    // Showing up as a widget implies collapsed (widget replaces text)    marker.collapsed = true    marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget")    marker.widgetNode.setAttribute("role", "presentation") // hide from accessibility tree    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true") }    if (options.insertLeft) { marker.widgetNode.insertLeft = true }  }  if (marker.collapsed) {    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }    seeCollapsedSpans()  }
if (marker.addToHistory)    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN) }
var curLine = from.line, cm = doc.cm, updateMaxLine  doc.iter(curLine, to.line + 1, function (line) {    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)      { updateMaxLine = true }    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0) }    addMarkedSpan(line, new MarkedSpan(marker,                                       curLine == from.line ? from.ch : null,                                       curLine == to.line ? to.ch : null))    ++curLine  })  // lineIsHidden depends on the presence of the spans, so needs a second pass  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0) }  }) }
if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }) }
if (marker.readOnly) {    seeReadOnlySpans()    if (doc.history.done.length || doc.history.undone.length)      { doc.clearHistory() }  }  if (marker.collapsed) {    marker.id = ++nextMarkerId    marker.atomic = true  }  if (cm) {    // Sync editor state    if (updateMaxLine) { cm.curOp.updateMaxLine = true }    if (marker.collapsed)      { regChange(cm, from.line, to.line + 1) }    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text") } }    if (marker.atomic) { reCheckSelection(cm.doc) }    signalLater(cm, "markerAdded", cm, marker)  }  return marker
}
// SHARED TEXTMARKERS
// A shared marker spans multiple linked documents. It is // implemented as a meta-marker-object controlling multiple normal // markers. var SharedTextMarker = function(markers, primary) {
var this$1 = this;
this.markers = markers  this.primary = primary  for (var i = 0; i < markers.length; ++i)    { markers[i].parent = this$1 }
};
SharedTextMarker.prototype.clear = function () {
var this$1 = this;
if (this.explicitlyCleared) { return }  this.explicitlyCleared = true  for (var i = 0; i < this.markers.length; ++i)    { this$1.markers[i].clear() }  signalLater(this, "clear")
};
SharedTextMarker.prototype.find = function (side, lineObj) {
return this.primary.find(side, lineObj)
}; eventMixin(SharedTextMarker)
function markTextShared(doc, from, to, options, type) {
options = copyObj(options)  options.shared = false  var markers = [markText(doc, from, to, options, type)], primary = markers[0]  var widget = options.widgetNode  linkedDocs(doc, function (doc) {    if (widget) { options.widgetNode = widget.cloneNode(true) }    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type))    for (var i = 0; i < doc.linked.length; ++i)      { if (doc.linked[i].isParent) { return } }    primary = lst(markers)  })  return new SharedTextMarker(markers, primary)
}
function findSharedMarkers(doc) {
return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
}
function copySharedMarkers(doc, markers) {
for (var i = 0; i < markers.length; i++) {    var marker = markers[i], pos = marker.find()    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to)    if (cmp(mFrom, mTo)) {      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type)      marker.markers.push(subMark)      subMark.parent = marker    }  }
}
function detachSharedMarkers(markers) {
var loop = function ( i ) {    var marker = markers[i], linked = [marker.primary.doc]    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); })    for (var j = 0; j < marker.markers.length; j++) {      var subMarker = marker.markers[j]      if (indexOf(linked, subMarker.doc) == -1) {        subMarker.parent = null        marker.markers.splice(j--, 1)      }    }  };
for (var i = 0; i < markers.length; i++) loop( i );
}
var nextDocId = 0 var Doc = function(text, mode, firstLine, lineSep) {
if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep) }  if (firstLine == null) { firstLine = 0 }
BranchChunk.call(this, [new LeafChunk([new Line("", null)])])  this.first = firstLine  this.scrollTop = this.scrollLeft = 0  this.cantEdit = false  this.cleanGeneration = 1  this.frontier = firstLine  var start = Pos(firstLine, 0)  this.sel = simpleSelection(start)  this.history = new History(null)  this.id = ++nextDocId  this.modeOption = mode  this.lineSep = lineSep  this.extend = false
if (typeof text == "string") { text = this.splitLines(text) }  updateDoc(this, {from: start, to: start, text: text})  setSelection(this, simpleSelection(start), sel_dontScroll)
}
Doc.prototype = createObj(BranchChunk.prototype, {
constructor: Doc,  // Iterate over the document. Supports two forms -- with only one  // argument, it calls that for each line in the document. With  // three, it iterates over the range given by the first two (with  // the second being non-inclusive).  iter: function(from, to, op) {    if (op) { this.iterN(from - this.first, to - from, op) }    else { this.iterN(this.first, this.first + this.size, from) }  },
// Non-public interface for adding and removing lines.  insert: function(at, lines) {    var height = 0    for (var i = 0; i < lines.length; ++i) { height += lines[i].height }    this.insertInner(at - this.first, lines, height)  },  remove: function(at, n) { this.removeInner(at - this.first, n) },
// From here, the methods are part of the public interface. Most  // are also available from CodeMirror (editor) instances.
getValue: function(lineSep) {    var lines = getLines(this, this.first, this.first + this.size)    if (lineSep === false) { return lines }    return lines.join(lineSep || this.lineSeparator())  },  setValue: docMethodOp(function(code) {    var top = Pos(this.first, 0), last = this.first + this.size - 1    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),                      text: this.splitLines(code), origin: "setValue", full: true}, true)    setSelection(this, simpleSelection(top))  }),  replaceRange: function(code, from, to, origin) {    from = clipPos(this, from)    to = to ? clipPos(this, to) : from    replaceRange(this, code, from, to, origin)  },  getRange: function(from, to, lineSep) {    var lines = getBetween(this, clipPos(this, from), clipPos(this, to))    if (lineSep === false) { return lines }    return lines.join(lineSep || this.lineSeparator())  },
getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},
getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},  getLineNumber: function(line) {return lineNo(line)},
getLineHandleVisualStart: function(line) {    if (typeof line == "number") { line = getLine(this, line) }    return visualLine(line)  },
lineCount: function() {return this.size},  firstLine: function() {return this.first},  lastLine: function() {return this.first + this.size - 1},
clipPos: function(pos) {return clipPos(this, pos)},
getCursor: function(start) {    var range = this.sel.primary(), pos    if (start == null || start == "head") { pos = range.head }    else if (start == "anchor") { pos = range.anchor }    else if (start == "end" || start == "to" || start === false) { pos = range.to() }    else { pos = range.from() }    return pos  },  listSelections: function() { return this.sel.ranges },  somethingSelected: function() {return this.sel.somethingSelected()},
setCursor: docMethodOp(function(line, ch, options) {    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options)  }),  setSelection: docMethodOp(function(anchor, head, options) {    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)  }),  extendSelection: docMethodOp(function(head, other, options) {    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options)  }),  extendSelections: docMethodOp(function(heads, options) {    extendSelections(this, clipPosArray(this, heads), options)  }),  extendSelectionsBy: docMethodOp(function(f, options) {    var heads = map(this.sel.ranges, f)    extendSelections(this, clipPosArray(this, heads), options)  }),  setSelections: docMethodOp(function(ranges, primary, options) {    var this$1 = this;
if (!ranges.length) { return }    var out = []    for (var i = 0; i < ranges.length; i++)      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),                         clipPos(this$1, ranges[i].head)) }    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex) }    setSelection(this, normalizeSelection(out, primary), options)  }),  addSelection: docMethodOp(function(anchor, head, options) {    var ranges = this.sel.ranges.slice(0)    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)))    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)  }),
getSelection: function(lineSep) {    var this$1 = this;
var ranges = this.sel.ranges, lines    for (var i = 0; i < ranges.length; i++) {      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())      lines = lines ? lines.concat(sel) : sel    }    if (lineSep === false) { return lines }    else { return lines.join(lineSep || this.lineSeparator()) }  },  getSelections: function(lineSep) {    var this$1 = this;
var parts = [], ranges = this.sel.ranges    for (var i = 0; i < ranges.length; i++) {      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()) }      parts[i] = sel    }    return parts  },  replaceSelection: function(code, collapse, origin) {    var dup = []    for (var i = 0; i < this.sel.ranges.length; i++)      { dup[i] = code }    this.replaceSelections(dup, collapse, origin || "+input")  },  replaceSelections: docMethodOp(function(code, collapse, origin) {    var this$1 = this;
var changes = [], sel = this.sel    for (var i = 0; i < sel.ranges.length; i++) {      var range = sel.ranges[i]      changes[i] = {from: range.from(), to: range.to(), text: this$1.splitLines(code[i]), origin: origin}    }    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse)    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)      { makeChange(this$1, changes[i$1]) }    if (newSel) { setSelectionReplaceHistory(this, newSel) }    else if (this.cm) { ensureCursorVisible(this.cm) }  }),  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo")}),  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo")}),  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true)}),  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true)}),
setExtending: function(val) {this.extend = val},  getExtending: function() {return this.extend},
historySize: function() {    var hist = this.history, done = 0, undone = 0    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done } }    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone } }    return {undo: done, redo: undone}  },  clearHistory: function() {this.history = new History(this.history.maxGeneration)},
markClean: function() {    this.cleanGeneration = this.changeGeneration(true)  },  changeGeneration: function(forceSplit) {    if (forceSplit)      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null }    return this.history.generation  },  isClean: function (gen) {    return this.history.generation == (gen || this.cleanGeneration)  },
getHistory: function() {    return {done: copyHistoryArray(this.history.done),            undone: copyHistoryArray(this.history.undone)}  },  setHistory: function(histData) {    var hist = this.history = new History(this.history.maxGeneration)    hist.done = copyHistoryArray(histData.done.slice(0), null, true)    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)  },
setGutterMarker: docMethodOp(function(line, gutterID, value) {    return changeLine(this, line, "gutter", function (line) {      var markers = line.gutterMarkers || (line.gutterMarkers = {})      markers[gutterID] = value      if (!value && isEmpty(markers)) { line.gutterMarkers = null }      return true    })  }),
clearGutter: docMethodOp(function(gutterID) {    var this$1 = this;
this.iter(function (line) {      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {        changeLine(this$1, line, "gutter", function () {          line.gutterMarkers[gutterID] = null          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null }          return true        })      }    })  }),
lineInfo: function(line) {    var n    if (typeof line == "number") {      if (!isLine(this, line)) { return null }      n = line      line = getLine(this, line)      if (!line) { return null }    } else {      n = lineNo(line)      if (n == null) { return null }    }    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,            widgets: line.widgets}  },
addLineClass: docMethodOp(function(handle, where, cls) {    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {      var prop = where == "text" ? "textClass"  : where == "background" ? "bgClass"  : where == "gutter" ? "gutterClass" : "wrapClass"      if (!line[prop]) { line[prop] = cls }      else if (classTest(cls).test(line[prop])) { return false }      else { line[prop] += " " + cls }      return true    })  }),  removeLineClass: docMethodOp(function(handle, where, cls) {    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {      var prop = where == "text" ? "textClass"  : where == "background" ? "bgClass"  : where == "gutter" ? "gutterClass" : "wrapClass"      var cur = line[prop]      if (!cur) { return false }      else if (cls == null) { line[prop] = null }      else {        var found = cur.match(classTest(cls))        if (!found) { return false }        var end = found.index + found[0].length        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null      }      return true    })  }),
addLineWidget: docMethodOp(function(handle, node, options) {    return addLineWidget(this, handle, node, options)  }),  removeLineWidget: function(widget) { widget.clear() },
markText: function(from, to, options) {    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")  },  setBookmark: function(pos, options) {    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),                    insertLeft: options && options.insertLeft,                    clearWhenEmpty: false, shared: options && options.shared,                    handleMouseEvents: options && options.handleMouseEvents}    pos = clipPos(this, pos)    return markText(this, pos, pos, realOpts, "bookmark")  },  findMarksAt: function(pos) {    pos = clipPos(this, pos)    var markers = [], spans = getLine(this, pos.line).markedSpans    if (spans) { for (var i = 0; i < spans.length; ++i) {      var span = spans[i]      if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))        { markers.push(span.marker.parent || span.marker) }    } }    return markers  },  findMarks: function(from, to, filter) {    from = clipPos(this, from); to = clipPos(this, to)    var found = [], lineNo = from.line    this.iter(from.line, to.line + 1, function (line) {      var spans = line.markedSpans      if (spans) { for (var i = 0; i < spans.length; i++) {        var span = spans[i]        if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||              span.from == null && lineNo != from.line ||              span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))          { found.push(span.marker.parent || span.marker) }      } }      ++lineNo    })    return found  },  getAllMarks: function() {    var markers = []    this.iter(function (line) {      var sps = line.markedSpans      if (sps) { for (var i = 0; i < sps.length; ++i)        { if (sps[i].from != null) { markers.push(sps[i].marker) } } }    })    return markers  },
posFromIndex: function(off) {    var ch, lineNo = this.first, sepSize = this.lineSeparator().length    this.iter(function (line) {      var sz = line.text.length + sepSize      if (sz > off) { ch = off; return true }      off -= sz      ++lineNo    })    return clipPos(this, Pos(lineNo, ch))  },  indexFromPos: function (coords) {    coords = clipPos(this, coords)    var index = coords.ch    if (coords.line < this.first || coords.ch < 0) { return 0 }    var sepSize = this.lineSeparator().length    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value      index += line.text.length + sepSize    })    return index  },
copy: function(copyHistory) {    var doc = new Doc(getLines(this, this.first, this.first + this.size),                      this.modeOption, this.first, this.lineSep)    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft    doc.sel = this.sel    doc.extend = false    if (copyHistory) {      doc.history.undoDepth = this.history.undoDepth      doc.setHistory(this.getHistory())    }    return doc  },
linkedDoc: function(options) {    if (!options) { options = {} }    var from = this.first, to = this.first + this.size    if (options.from != null && options.from > from) { from = options.from }    if (options.to != null && options.to < to) { to = options.to }    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep)    if (options.sharedHist) { copy.history = this.history  ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist})    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}]    copySharedMarkers(copy, findSharedMarkers(this))    return copy  },  unlinkDoc: function(other) {    var this$1 = this;
if (other instanceof CodeMirror) { other = other.doc }    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {      var link = this$1.linked[i]      if (link.doc != other) { continue }      this$1.linked.splice(i, 1)      other.unlinkDoc(this$1)      detachSharedMarkers(findSharedMarkers(this$1))      break    } }    // If the histories were shared, split them again    if (other.history == this.history) {      var splitIds = [other.id]      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true)      other.history = new History(null)      other.history.done = copyHistoryArray(this.history.done, splitIds)      other.history.undone = copyHistoryArray(this.history.undone, splitIds)    }  },  iterLinkedDocs: function(f) {linkedDocs(this, f)},
getMode: function() {return this.mode},  getEditor: function() {return this.cm},
splitLines: function(str) {    if (this.lineSep) { return str.split(this.lineSep) }    return splitLinesAuto(str)  },  lineSeparator: function() { return this.lineSep || "\n" }
})
// Public alias. Doc.prototype.eachLine = Doc.prototype.iter
// Kludge to work around strange IE behavior where it'll sometimes // re-fire a series of drag-related events right after the drop (#1551) var lastDrop = 0
function onDrop(e) {
var cm = this  clearDragCursor(cm)  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))    { return }  e_preventDefault(e)  if (ie) { lastDrop = +new Date }  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files  if (!pos || cm.isReadOnly()) { return }  // Might be a file drop, in which case we simply extract the text  // and insert it.  if (files && files.length && window.FileReader && window.File) {    var n = files.length, text = Array(n), read = 0    var loadFile = function (file, i) {      if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1)        { return }
var reader = new FileReader      reader.onload = operation(cm, function () {        var content = reader.result        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = "" }        text[i] = content        if (++read == n) {          pos = clipPos(cm.doc, pos)          var change = {from: pos, to: pos,                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),                        origin: "paste"}          makeChange(cm.doc, change)          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))        }      })      reader.readAsText(file)    }    for (var i = 0; i < n; ++i) { loadFile(files[i], i) }  } else { // Normal drop    // Don't do a replace if the drop happened inside of the selected text.    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {      cm.state.draggingText(e)      // Ensure the editor is re-focused      setTimeout(function () { return cm.display.input.focus(); }, 20)      return    }    try {      var text$1 = e.dataTransfer.getData("Text")      if (text$1) {        var selected        if (cm.state.draggingText && !cm.state.draggingText.copy)          { selected = cm.listSelections() }        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos))        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag") } }        cm.replaceSelection(text$1, "around", "paste")        cm.display.input.focus() }    }    catch(e){}  }
}
function onDragStart(cm, e) {
if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }
e.dataTransfer.setData("Text", cm.getSelection())  e.dataTransfer.effectAllowed = "copyMove"
// Use dummy image instead of default browsers image.  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.  if (e.dataTransfer.setDragImage && !safari) {    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;")    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="    if (presto) {      img.width = img.height = 1      cm.display.wrapper.appendChild(img)      // Force a relayout, or Opera won't use our image for some obscure reason      img._top = img.offsetTop    }    e.dataTransfer.setDragImage(img, 0, 0)    if (presto) { img.parentNode.removeChild(img) }  }
}
function onDragOver(cm, e) {
var pos = posFromMouse(cm, e)  if (!pos) { return }  var frag = document.createDocumentFragment()  drawSelectionCursor(cm, pos, frag)  if (!cm.display.dragCursor) {    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors")    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)  }  removeChildrenAndAdd(cm.display.dragCursor, frag)
}
function clearDragCursor(cm) {
if (cm.display.dragCursor) {    cm.display.lineSpace.removeChild(cm.display.dragCursor)    cm.display.dragCursor = null  }
}
// These must be handled carefully, because naively registering a // handler for each editor will cause the editors to never be // garbage collected.
function forEachCodeMirror(f) {
if (!document.body.getElementsByClassName) { return }  var byClass = document.body.getElementsByClassName("CodeMirror")  for (var i = 0; i < byClass.length; i++) {    var cm = byClass[i].CodeMirror    if (cm) { f(cm) }  }
}
var globalsRegistered = false function ensureGlobalHandlers() {
if (globalsRegistered) { return }  registerGlobalHandlers()  globalsRegistered = true
} function registerGlobalHandlers() {
// When the window resizes, we need to refresh active editors.  var resizeTimer  on(window, "resize", function () {    if (resizeTimer == null) { resizeTimer = setTimeout(function () {      resizeTimer = null      forEachCodeMirror(onResize)    }, 100) }  })  // When the window loses focus, we want to show the editor as blurred  on(window, "blur", function () { return forEachCodeMirror(onBlur); })
} // Called when the window resizes function onResize(cm) {
var d = cm.display  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)    { return }  // Might be a text scaling operation, clear size caches.  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null  d.scrollbarsClipped = false  cm.setSize()
}
var keyNames = {
3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
}
// Number keys for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i) } // Alphabetic keys for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1) } // Function keys for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2 }
var keyMap = {}
keyMap.basic = {
"Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",  "Tab": "defaultTab", "Shift-Tab": "indentAuto",  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",  "Esc": "singleSelection"
} // Note that the save and find-related commands aren't defined by // default. User code or addons can define them. Unknown commands // are simply ignored. keyMap.pcDefault = {
"Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",  fallthrough: "basic"
} // Very basic readline/emacs-style bindings, which are standard on Mac. keyMap.emacsy = {
"Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",  "Ctrl-O": "openLine"
} keyMap.macDefault = {
"Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",  fallthrough: ["basic", "emacsy"]
} keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault
// KEYMAP DISPATCH
function normalizeKeyName(name) {
var parts = name.split(/-(?!$)/)  name = parts[parts.length - 1]  var alt, ctrl, shift, cmd  for (var i = 0; i < parts.length - 1; i++) {    var mod = parts[i]    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true }    else if (/^a(lt)?$/i.test(mod)) { alt = true }    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }    else if (/^s(hift)?$/i.test(mod)) { shift = true }    else { throw new Error("Unrecognized modifier name: " + mod) }  }  if (alt) { name = "Alt-" + name }  if (ctrl) { name = "Ctrl-" + name }  if (cmd) { name = "Cmd-" + name }  if (shift) { name = "Shift-" + name }  return name
}
// This is a kludge to keep keymaps mostly working as raw objects // (backwards compatibility) while at the same time support features // like normalization and multi-stroke key bindings. It compiles a // new normalized keymap, and then updates the old object to reflect // this. function normalizeKeyMap(keymap) {
var copy = {}  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) { var value = keymap[keyname]    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }    if (value == "...") { delete keymap[keyname]; continue }
var keys = map(keyname.split(" "), normalizeKeyName)    for (var i = 0; i < keys.length; i++) {      var val = (void 0), name = (void 0)      if (i == keys.length - 1) {        name = keys.join(" ")        val = value      } else {        name = keys.slice(0, i + 1).join(" ")        val = "..."      }      var prev = copy[name]      if (!prev) { copy[name] = val }      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }    }    delete keymap[keyname]  } }  for (var prop in copy) { keymap[prop] = copy[prop] }  return keymap
}
function lookupKey(key, map, handle, context) {
map = getKeyMap(map)  var found = map.call ? map.call(key, context) : map[key]  if (found === false) { return "nothing" }  if (found === "...") { return "multi" }  if (found != null && handle(found)) { return "handled" }
if (map.fallthrough) {    if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")      { return lookupKey(key, map.fallthrough, handle, context) }    for (var i = 0; i < map.fallthrough.length; i++) {      var result = lookupKey(key, map.fallthrough[i], handle, context)      if (result) { return result }    }  }
}
// Modifier key presses don't count as 'real' key presses for the // purpose of keymap fallthrough. function isModifierKey(value) {
var name = typeof value == "string" ? value : keyNames[value.keyCode]  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
}
// Look up the name of a key as indicated by an event object. function keyName(event, noShift) {
if (presto && event.keyCode == 34 && event["char"]) { return false }  var base = keyNames[event.keyCode], name = base  if (name == null || event.altGraphKey) { return false }  if (event.altKey && base != "Alt") { name = "Alt-" + name }  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name }  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name }  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name }  return name
}
function getKeyMap(val) {
return typeof val == "string" ? keyMap[val] : val
}
// Helper for deleting text near the selection(s), used to implement // backspace, delete, and similar functionality. function deleteNearSelection(cm, compute) {
var ranges = cm.doc.sel.ranges, kill = []  // Build up a set of ranges to kill first, merging overlapping  // ranges.  for (var i = 0; i < ranges.length; i++) {    var toKill = compute(ranges[i])    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {      var replaced = kill.pop()      if (cmp(replaced.from, toKill.from) < 0) {        toKill.from = replaced.from        break      }    }    kill.push(toKill)  }  // Next, remove those actual ranges.  runInOp(cm, function () {    for (var i = kill.length - 1; i >= 0; i--)      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete") }    ensureCursorVisible(cm)  })
}
// Commands are parameter-less actions that can be performed on an // editor, mostly used for keybindings. var commands = {
selectAll: selectAll,  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },  killLine: function (cm) { return deleteNearSelection(cm, function (range) {    if (range.empty()) {      var len = getLine(cm.doc, range.head.line).text.length      if (range.head.ch == len && range.head.line < cm.lastLine())        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }      else        { return {from: range.head, to: Pos(range.head.line, len)} }    } else {      return {from: range.from(), to: range.to()}    }  }); },  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({    from: Pos(range.from().line, 0),    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))  }); }); },  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({    from: Pos(range.from().line, 0), to: range.from()  }); }); },  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {    var top = cm.charCoords(range.head, "div").top + 5    var leftPos = cm.coordsChar({left: 0, top: top}, "div")    return {from: leftPos, to: range.from()}  }); },  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {    var top = cm.charCoords(range.head, "div").top + 5    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")    return {from: range.from(), to: rightPos }  }); },  undo: function (cm) { return cm.undo(); },  redo: function (cm) { return cm.redo(); },  undoSelection: function (cm) { return cm.undoSelection(); },  redoSelection: function (cm) { return cm.redoSelection(); },  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },    {origin: "+move", bias: 1}  ); },  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },    {origin: "+move", bias: 1}  ); },  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },    {origin: "+move", bias: -1}  ); },  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {    var top = cm.charCoords(range.head, "div").top + 5    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")  }, sel_move); },  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {    var top = cm.charCoords(range.head, "div").top + 5    return cm.coordsChar({left: 0, top: top}, "div")  }, sel_move); },  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {    var top = cm.charCoords(range.head, "div").top + 5    var pos = cm.coordsChar({left: 0, top: top}, "div")    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }    return pos  }, sel_move); },  goLineUp: function (cm) { return cm.moveV(-1, "line"); },  goLineDown: function (cm) { return cm.moveV(1, "line"); },  goPageUp: function (cm) { return cm.moveV(-1, "page"); },  goPageDown: function (cm) { return cm.moveV(1, "page"); },  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },  goCharRight: function (cm) { return cm.moveH(1, "char"); },  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },  goColumnRight: function (cm) { return cm.moveH(1, "column"); },  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },  goGroupRight: function (cm) { return cm.moveH(1, "group"); },  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },  goWordRight: function (cm) { return cm.moveH(1, "word"); },  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },  indentAuto: function (cm) { return cm.indentSelection("smart"); },  indentMore: function (cm) { return cm.indentSelection("add"); },  indentLess: function (cm) { return cm.indentSelection("subtract"); },  insertTab: function (cm) { return cm.replaceSelection("\t"); },  insertSoftTab: function (cm) {    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize    for (var i = 0; i < ranges.length; i++) {      var pos = ranges[i].from()      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize)      spaces.push(spaceStr(tabSize - col % tabSize))    }    cm.replaceSelections(spaces)  },  defaultTab: function (cm) {    if (cm.somethingSelected()) { cm.indentSelection("add") }    else { cm.execCommand("insertTab") }  },  // Swap the two chars left and right of each selection's head.  // Move cursor behind the two swapped characters afterwards.  //  // Doesn't consider line feeds a character.  // Doesn't scan more than one line above to find a character.  // Doesn't do anything on an empty line.  // Doesn't do anything with non-empty selections.  transposeChars: function (cm) { return runInOp(cm, function () {    var ranges = cm.listSelections(), newSel = []    for (var i = 0; i < ranges.length; i++) {      if (!ranges[i].empty()) { continue }      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text      if (line) {        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1) }        if (cur.ch > 0) {          cur = new Pos(cur.line, cur.ch + 1)          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),                          Pos(cur.line, cur.ch - 2), cur, "+transpose")        } else if (cur.line > cm.doc.first) {          var prev = getLine(cm.doc, cur.line - 1).text          if (prev) {            cur = new Pos(cur.line, 1)            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +                            prev.charAt(prev.length - 1),                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose")          }        }      }      newSel.push(new Range(cur, cur))    }    cm.setSelections(newSel)  }); },  newlineAndIndent: function (cm) { return runInOp(cm, function () {    var sels = cm.listSelections()    for (var i = sels.length - 1; i >= 0; i--)      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input") }    sels = cm.listSelections() for (var i$1 = 0; i$1 < sels.length; i$1++)      { cm.indentLine(sels[i$1].from().line, null, true) }    ensureCursorVisible(cm)  }); },  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
}
function lineStart(cm, lineN) {
var line = getLine(cm.doc, lineN)  var visual = visualLine(line)  if (visual != line) { lineN = lineNo(visual) }  return endOfLine(true, cm, visual, lineN, 1)
} function lineEnd(cm, lineN) {
var line = getLine(cm.doc, lineN)  var visual = visualLineEnd(line)  if (visual != line) { lineN = lineNo(visual) }  return endOfLine(true, cm, line, lineN, -1)
} function lineStartSmart(cm, pos) {
var start = lineStart(cm, pos.line)  var line = getLine(cm.doc, start.line)  var order = getOrder(line)  if (!order || order[0].level == 0) {    var firstNonWS = Math.max(0, line.text.search(/\S/))    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)  }  return start
}
// Run a handler that was bound to a key. function doHandleBinding(cm, bound, dropShift) {
if (typeof bound == "string") {    bound = commands[bound]    if (!bound) { return false }  }  // Ensure previous input has been read, so that the handler sees a  // consistent view of the document  cm.display.input.ensurePolled()  var prevShift = cm.display.shift, done = false  try {    if (cm.isReadOnly()) { cm.state.suppressEdits = true }    if (dropShift) { cm.display.shift = false }    done = bound(cm) != Pass  } finally {    cm.display.shift = prevShift    cm.state.suppressEdits = false  }  return done
}
function lookupKeyForEditor(cm, name, handle) {
for (var i = 0; i < cm.state.keyMaps.length; i++) {    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm)    if (result) { return result }  }  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))    || lookupKey(name, cm.options.keyMap, handle, cm)
}
var stopSeq = new Delayed function dispatchKey(cm, name, e, handle) {
var seq = cm.state.keySeq  if (seq) {    if (isModifierKey(name)) { return "handled" }    stopSeq.set(50, function () {      if (cm.state.keySeq == seq) {        cm.state.keySeq = null        cm.display.input.reset()      }    })    name = seq + " " + name  }  var result = lookupKeyForEditor(cm, name, handle)
if (result == "multi")    { cm.state.keySeq = name }  if (result == "handled")    { signalLater(cm, "keyHandled", cm, name, e) }
if (result == "handled" || result == "multi") {    e_preventDefault(e)    restartBlink(cm)  }
if (seq && !result && /\'$/.test(name)) {    e_preventDefault(e)    return true  }  return !!result
}
// Handle a key from the keydown event. function handleKeyBinding(cm, e) {
var name = keyName(e, true)  if (!name) { return false }
if (e.shiftKey && !cm.state.keySeq) {    // First try to resolve full name (including 'Shift-'). Failing    // that, see if there is a cursor-motion command (starting with    // 'go') bound to the keyname without 'Shift-'.    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })        || dispatchKey(cm, name, e, function (b) {             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)               { return doHandleBinding(cm, b) }           })  } else {    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })  }
}
// Handle a key from the keypress event function handleCharBinding(cm, e, ch) {
return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
}
var lastStoppedKey = null function onKeyDown(e) {
var cm = this  cm.curOp.focus = activeElt()  if (signalDOMEvent(cm, e)) { return }  // IE does strange things with escape.  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false }  var code = e.keyCode  cm.display.shift = code == 16 || e.shiftKey  var handled = handleKeyBinding(cm, e)  if (presto) {    lastStoppedKey = handled ? code : null    // Opera has no cut event... we try to at least catch the key combo    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))      { cm.replaceSelection("", null, "cut") }  }
// Turn mouse into crosshair when Alt is held on Mac.  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))    { showCrossHair(cm) }
}
function showCrossHair(cm) {
var lineDiv = cm.display.lineDiv  addClass(lineDiv, "CodeMirror-crosshair")
function up(e) {    if (e.keyCode == 18 || !e.altKey) {      rmClass(lineDiv, "CodeMirror-crosshair")      off(document, "keyup", up)      off(document, "mouseover", up)    }  }  on(document, "keyup", up)  on(document, "mouseover", up)
}
function onKeyUp(e) {
if (e.keyCode == 16) { this.doc.sel.shift = false }  signalDOMEvent(this, e)
}
function onKeyPress(e) {
var cm = this  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }  var keyCode = e.keyCode, charCode = e.charCode  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }  var ch = String.fromCharCode(charCode == null ? keyCode : charCode)  // Some browsers fire keypress events for backspace  if (ch == "\x08") { return }  if (handleCharBinding(cm, e, ch)) { return }  cm.display.input.onKeyPress(e)
}
// A mouse down can be a single click, double click, triple click, // start of selection drag, start of text drag, new cursor // (ctrl-click), rectangle drag (alt-drag), or xwin // middle-click-paste. Or it might be a click on something we should // not interfere with, such as a scrollbar or widget. function onMouseDown(e) {
var cm = this, display = cm.display  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }  display.input.ensurePolled()  display.shift = e.shiftKey
if (eventInWidget(display, e)) {    if (!webkit) {      // Briefly turn off draggability, to allow widgets to do      // normal dragging things.      display.scroller.draggable = false      setTimeout(function () { return display.scroller.draggable = true; }, 100)    }    return  }  if (clickInGutter(cm, e)) { return }  var start = posFromMouse(cm, e)  window.focus()
switch (e_button(e)) {  case 1:    // #3261: make sure, that we're not starting a second selection    if (cm.state.selectingText)      { cm.state.selectingText(e) }    else if (start)      { leftButtonDown(cm, e, start) }    else if (e_target(e) == display.scroller)      { e_preventDefault(e) }    break  case 2:    if (webkit) { cm.state.lastMiddleDown = +new Date }    if (start) { extendSelection(cm.doc, start) }    setTimeout(function () { return display.input.focus(); }, 20)    e_preventDefault(e)    break  case 3:    if (captureRightClick) { onContextMenu(cm, e) }    else { delayBlurEvent(cm) }    break  }
}
var lastClick; var lastDoubleClick; function leftButtonDown(cm, e, start) {
if (ie) { setTimeout(bind(ensureFocus, cm), 0) }  else { cm.curOp.focus = activeElt() }
var now = +new Date, type  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {    type = "triple"  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {    type = "double"    lastDoubleClick = {time: now, pos: start}  } else {    type = "single"    lastClick = {time: now, pos: start}  }
var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && type == "single" && (contained = sel.contains(start)) > -1 && (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) && (cmp(contained.to(), start) > 0 || start.xRel < 0))    { leftButtonStartDrag(cm, e, start, modifier) }  else    { leftButtonSelect(cm, e, start, type, modifier) }
}
// Start a text drag. When it ends, see if any dragging actually // happen, and treat as a click if it didn't. function leftButtonStartDrag(cm, e, start, modifier) {
var display = cm.display, startTime = +new Date  var dragEnd = operation(cm, function (e2) {    if (webkit) { display.scroller.draggable = false }    cm.state.draggingText = false    off(document, "mouseup", dragEnd)    off(display.scroller, "drop", dragEnd)    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {      e_preventDefault(e2)      if (!modifier && +new Date - 200 < startTime)        { extendSelection(cm.doc, start) }      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)      if (webkit || ie && ie_version == 9)        { setTimeout(function () {document.body.focus(); display.input.focus()}, 20) }      else        { display.input.focus() }    }  })  // Let the drag handler handle this.  if (webkit) { display.scroller.draggable = true }  cm.state.draggingText = dragEnd  dragEnd.copy = mac ? e.altKey : e.ctrlKey  // IE's approach to draggable  if (display.scroller.dragDrop) { display.scroller.dragDrop() }  on(document, "mouseup", dragEnd)  on(display.scroller, "drop", dragEnd)
}
// Normal selection, as opposed to text dragging. function leftButtonSelect(cm, e, start, type, addNew) {
var display = cm.display, doc = cm.doc  e_preventDefault(e)
var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges  if (addNew && !e.shiftKey) {    ourIndex = doc.sel.contains(start)    if (ourIndex > -1)      { ourRange = ranges[ourIndex] }    else      { ourRange = new Range(start, start) }  } else {    ourRange = doc.sel.primary()    ourIndex = doc.sel.primIndex  }
if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {    type = "rect"    if (!addNew) { ourRange = new Range(start, start) }    start = posFromMouse(cm, e, true, true)    ourIndex = -1  } else if (type == "double") {    var word = cm.findWordAt(start)    if (cm.display.shift || doc.extend)      { ourRange = extendRange(doc, ourRange, word.anchor, word.head) }    else      { ourRange = word }  } else if (type == "triple") {    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)))    if (cm.display.shift || doc.extend)      { ourRange = extendRange(doc, ourRange, line.anchor, line.head) }    else      { ourRange = line }  } else {    ourRange = extendRange(doc, ourRange, start)  }
if (!addNew) {    ourIndex = 0    setSelection(doc, new Selection([ourRange], 0), sel_mouse)    startSel = doc.sel  } else if (ourIndex == -1) {    ourIndex = ranges.length    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),                 {scroll: false, origin: "*mouse"})  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),                 {scroll: false, origin: "*mouse"})    startSel = doc.sel  } else {    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse)  }
var lastPos = start  function extendTo(pos) {    if (cmp(lastPos, pos) == 0) { return }    lastPos = pos
if (type == "rect") {      var ranges = [], tabSize = cm.options.tabSize      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize)      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize)      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol)      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));           line <= end; line++) {        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize)        if (left == right)          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) }        else if (text.length > leftPos)          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))) }      }      if (!ranges.length) { ranges.push(new Range(start, start)) }      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),                   {origin: "*mouse", scroll: false})      cm.scrollIntoView(pos)    } else {      var oldRange = ourRange      var anchor = oldRange.anchor, head = pos      if (type != "single") {        var range        if (type == "double")          { range = cm.findWordAt(pos) }        else          { range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))) }        if (cmp(range.anchor, anchor) > 0) {          head = range.head          anchor = minPos(oldRange.from(), range.anchor)        } else {          head = range.anchor          anchor = maxPos(oldRange.to(), range.head)        }      }      var ranges$1 = startSel.ranges.slice(0)      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head)      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)    }  }
var editorSize = display.wrapper.getBoundingClientRect()  // Used to ensure timeout re-tries don't fire when another extend  // happened in the meantime (clearTimeout isn't reliable -- at  // least on Chrome, the timeouts still happen even when cleared,  // if the clear happens after their scheduled firing time).  var counter = 0
function extend(e) {    var curCount = ++counter    var cur = posFromMouse(cm, e, true, type == "rect")    if (!cur) { return }    if (cmp(cur, lastPos) != 0) {      cm.curOp.focus = activeElt()      extendTo(cur)      var visible = visibleLines(display, doc)      if (cur.line >= visible.to || cur.line < visible.from)        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e) }}), 150) }    } else {      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0      if (outside) { setTimeout(operation(cm, function () {        if (counter != curCount) { return }        display.scroller.scrollTop += outside        extend(e)      }), 50) }    }  }
function done(e) {    cm.state.selectingText = false    counter = Infinity    e_preventDefault(e)    display.input.focus()    off(document, "mousemove", move)    off(document, "mouseup", up)    doc.history.lastSelOrigin = null  }
var move = operation(cm, function (e) {    if (!e_button(e)) { done(e) }    else { extend(e) }  })  var up = operation(cm, done)  cm.state.selectingText = up  on(document, "mousemove", move)  on(document, "mouseup", up)
}
// Determines whether an event happened in the gutter, and fires the // handlers for the corresponding event. function gutterEvent(cm, e, type, prevent) {
var mX, mY  try { mX = e.clientX; mY = e.clientY }  catch(e) { return false }  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }  if (prevent) { e_preventDefault(e) }
var display = cm.display  var lineBox = display.lineDiv.getBoundingClientRect()
if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }  mY -= lineBox.top - display.viewOffset
for (var i = 0; i < cm.options.gutters.length; ++i) {    var g = display.gutters.childNodes[i]    if (g && g.getBoundingClientRect().right >= mX) {      var line = lineAtHeight(cm.doc, mY)      var gutter = cm.options.gutters[i]      signal(cm, type, cm, line, gutter, e)      return e_defaultPrevented(e)    }  }
}
function clickInGutter(cm, e) {
return gutterEvent(cm, e, "gutterClick", true)
}
// CONTEXT MENU HANDLING
// To make the context menu work, we need to briefly unhide the // textarea (making it as unobtrusive as possible) to let the // right-click take effect on it. function onContextMenu(cm, e) {
if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }  if (signalDOMEvent(cm, e, "contextmenu")) { return }  cm.display.input.onContextMenu(e)
}
function contextMenuInGutter(cm, e) {
if (!hasHandler(cm, "gutterContextMenu")) { return false }  return gutterEvent(cm, e, "gutterContextMenu", false)
}
function themeChanged(cm) {
cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-")  clearCaches(cm)
}
var Init = {toString: function(){return "CodeMirror.Init"}}
var defaults = {} var optionHandlers = {}
function defineOptions(CodeMirror) {
var optionHandlers = CodeMirror.optionHandlers
function option(name, deflt, handle, notOnInit) {    CodeMirror.defaults[name] = deflt    if (handle) { optionHandlers[name] =      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old) }} : handle }  }
CodeMirror.defineOption = option
// Passed to option handlers when there is no old value.  CodeMirror.Init = Init
// These two are, on init, called from the constructor because they  // have to be initialized before the editor can start at all.  option("value", "", function (cm, val) { return cm.setValue(val); }, true)  option("mode", null, function (cm, val) {    cm.doc.modeOption = val loadMode(cm)  }, true)
option("indentUnit", 2, loadMode, true)  option("indentWithTabs", false)  option("smartIndent", true)  option("tabSize", 4, function (cm) {    resetModeState(cm)    clearCaches(cm)    regChange(cm)  }, true)  option("lineSeparator", null, function (cm, val) {    cm.doc.lineSep = val    if (!val) { return }    var newBreaks = [], lineNo = cm.doc.first    cm.doc.iter(function (line) {      for (var pos = 0;;) {        var found = line.text.indexOf(val, pos)        if (found == -1) { break }        pos = found + val.length        newBreaks.push(Pos(lineNo, found))      }      lineNo++    })    for (var i = newBreaks.length - 1; i >= 0; i--)      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)) }  })  option("specialChars", /[\u0000-\u001f\u007f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g")    if (old != Init) { cm.refresh() }  })  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true)  option("electricChars", true)  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME  }, true)  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true)  option("rtlMoveVisually", !windows)  option("wholeLineUpdateBefore", true)
option("theme", "default", function (cm) {    themeChanged(cm)    guttersChanged(cm)  }, true)  option("keyMap", "default", function (cm, val, old) {    var next = getKeyMap(val)    var prev = old != Init && getKeyMap(old)    if (prev && prev.detach) { prev.detach(cm, next) }    if (next.attach) { next.attach(cm, prev || null) }  })  option("extraKeys", null)
option("lineWrapping", false, wrappingChanged, true)  option("gutters", [], function (cm) {    setGuttersForLineNumbers(cm.options)    guttersChanged(cm)  }, true)  option("fixedGutter", true, function (cm, val) {    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0"    cm.refresh()  }, true)  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true)  option("scrollbarStyle", "native", function (cm) {    initScrollbars(cm)    updateScrollbars(cm)    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop)    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)  }, true)  option("lineNumbers", false, function (cm) {    setGuttersForLineNumbers(cm.options)    guttersChanged(cm)  }, true)  option("firstLineNumber", 1, guttersChanged, true)  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true)  option("showCursorWhenSelecting", false, updateSelection, true)
option("resetSelectionOnContextMenu", true)  option("lineWiseCopyCut", true)
option("readOnly", false, function (cm, val) {    if (val == "nocursor") {      onBlur(cm)      cm.display.input.blur()      cm.display.disabled = true    } else {      cm.display.disabled = false    }    cm.display.input.readOnlyChanged(val)  })  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset() }}, true)  option("dragDrop", true, dragDropChanged)  option("allowDropFileTypes", null)
option("cursorBlinkRate", 530)  option("cursorScrollMargin", 0)  option("cursorHeight", 1, updateSelection, true)  option("singleCursorHeightPerLine", true, updateSelection, true)  option("workTime", 100)  option("workDelay", 100)  option("flattenSpans", true, resetModeState, true)  option("addModeClass", false, resetModeState, true)  option("pollInterval", 100)  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; })  option("historyEventDelay", 1250)  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true)  option("maxHighlightLength", 10000, resetModeState, true)  option("moveInputWithCursor", true, function (cm, val) {    if (!val) { cm.display.input.resetPosition() }  })
option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; })  option("autofocus", null)
}
function guttersChanged(cm) {
updateGutters(cm)  regChange(cm)  alignHorizontally(cm)
}
function dragDropChanged(cm, value, old) {
var wasOn = old && old != Init  if (!value != !wasOn) {    var funcs = cm.display.dragFunctions    var toggle = value ? on : off    toggle(cm.display.scroller, "dragstart", funcs.start)    toggle(cm.display.scroller, "dragenter", funcs.enter)    toggle(cm.display.scroller, "dragover", funcs.over)    toggle(cm.display.scroller, "dragleave", funcs.leave)    toggle(cm.display.scroller, "drop", funcs.drop)  }
}
function wrappingChanged(cm) {
if (cm.options.lineWrapping) {    addClass(cm.display.wrapper, "CodeMirror-wrap")    cm.display.sizer.style.minWidth = ""    cm.display.sizerWidth = null  } else {    rmClass(cm.display.wrapper, "CodeMirror-wrap")    findMaxLine(cm)  }  estimateLineHeights(cm)  regChange(cm)  clearCaches(cm)  setTimeout(function () { return updateScrollbars(cm); }, 100)
}
// A CodeMirror instance represents an editor. This is the object // that user code is usually dealing with.
function CodeMirror(place, options) {
var this$1 = this;
if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }
this.options = options = options ? copyObj(options) : {}  // Determine effective options based on given values and defaults.  copyObj(defaults, options, false)  setGuttersForLineNumbers(options)
var doc = options.value  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator) }  this.doc = doc
var input = new CodeMirror.inputStyles[options.inputStyle](this)  var display = this.display = new Display(place, doc, input)  display.wrapper.CodeMirror = this  updateGutters(this)  themeChanged(this)  if (options.lineWrapping)    { this.display.wrapper.className += " CodeMirror-wrap" }  initScrollbars(this)
this.state = {    keyMaps: [],  // stores maps added by addKeyMap    overlays: [], // highlighting overlays, as added by addOverlay    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info    overwrite: false,    delayingBlurEvent: false,    focused: false,    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll    selectingText: false,    draggingText: false,    highlight: new Delayed(), // stores highlight worker timeout    keySeq: null,  // Unfinished key sequence    specialChars: null  }
if (options.autofocus && !mobile) { display.input.focus() }
// Override magic textarea content restore that IE sometimes does  // on our hidden textarea on reload  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20) }
registerEventHandlers(this)  ensureGlobalHandlers()
startOperation(this)  this.curOp.forceUpdate = true  attachDoc(this, doc)
if ((options.autofocus && !mobile) || this.hasFocus())    { setTimeout(bind(onFocus, this), 20) }  else    { onBlur(this) }
for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))    { optionHandlers[opt](this$1, options[opt], Init) } }  maybeUpdateLineNumberWidth(this)  if (options.finishInit) { options.finishInit(this) }  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1) }  endOperation(this)  // Suppress optimizelegibility in Webkit, since it breaks text  // measuring on line wrapping boundaries.  if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")    { display.lineDiv.style.textRendering = "auto" }
}
// The default configuration options. CodeMirror.defaults = defaults // Functions to run when options are changed. CodeMirror.optionHandlers = optionHandlers
// Attach the necessary event handlers when initializing the editor function registerEventHandlers(cm) {
var d = cm.display  on(d.scroller, "mousedown", operation(cm, onMouseDown))  // Older IE's will not fire a second mousedown for a double click  if (ie && ie_version < 11)    { on(d.scroller, "dblclick", operation(cm, function (e) {      if (signalDOMEvent(cm, e)) { return }      var pos = posFromMouse(cm, e)      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }      e_preventDefault(e)      var word = cm.findWordAt(pos)      extendSelection(cm.doc, word.anchor, word.head)    })) }  else    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }) }  // Some browsers fire contextmenu *after* opening the menu, at  // which point we can't mess with it anymore. Context menu is  // handled in onMouseDown for these browsers.  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }) }
// Used to suppress mouse event handling when a touch happens  var touchFinished, prevTouch = {end: 0}  function finishTouch() {    if (d.activeTouch) {      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000)      prevTouch = d.activeTouch      prevTouch.end = +new Date    }  }  function isMouseLikeTouchEvent(e) {    if (e.touches.length != 1) { return false }    var touch = e.touches[0]    return touch.radiusX <= 1 && touch.radiusY <= 1  }  function farAway(touch, other) {    if (other.left == null) { return true }    var dx = other.left - touch.left, dy = other.top - touch.top    return dx * dx + dy * dy > 20 * 20  }  on(d.scroller, "touchstart", function (e) {    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {      d.input.ensurePolled()      clearTimeout(touchFinished)      var now = +new Date      d.activeTouch = {start: now, moved: false,                       prev: now - prevTouch.end <= 300 ? prevTouch : null}      if (e.touches.length == 1) {        d.activeTouch.left = e.touches[0].pageX        d.activeTouch.top = e.touches[0].pageY      }    }  })  on(d.scroller, "touchmove", function () {    if (d.activeTouch) { d.activeTouch.moved = true }  })  on(d.scroller, "touchend", function (e) {    var touch = d.activeTouch    if (touch && !eventInWidget(d, e) && touch.left != null &&  !touch.moved && new Date - touch.start < 300) {      var pos = cm.coordsChar(d.activeTouch, "page"), range      if (!touch.prev || farAway(touch, touch.prev)) // Single tap        { range = new Range(pos, pos) }      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap        { range = cm.findWordAt(pos) }      else // Triple tap        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }      cm.setSelection(range.anchor, range.head)      cm.focus()      e_preventDefault(e)    }    finishTouch()  })  on(d.scroller, "touchcancel", finishTouch)
// Sync scrolling between fake scrollbars and real scrollable  // area, ensure viewport is updated when scrolling.  on(d.scroller, "scroll", function () {    if (d.scroller.clientHeight) {      setScrollTop(cm, d.scroller.scrollTop)      setScrollLeft(cm, d.scroller.scrollLeft, true)      signal(cm, "scroll", cm)    }  })
// Listen to wheel events in order to try and update the viewport on time.  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); })  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); })
// Prevent wrapper from ever scrolling  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; })
d.dragFunctions = {    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e) }},    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e) }},    start: function (e) { return onDragStart(cm, e); },    drop: operation(cm, onDrop),    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm) }}  }
var inp = d.input.getField()  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); })  on(inp, "keydown", operation(cm, onKeyDown))  on(inp, "keypress", operation(cm, onKeyPress))  on(inp, "focus", function (e) { return onFocus(cm, e); })  on(inp, "blur", function (e) { return onBlur(cm, e); })
}
var initHooks = [] CodeMirror.defineInitHook = function (f) { return initHooks.push(f); }
// Indent the given line. The how parameter can be "smart", // "add"/null, "subtract", or "prev". When aggressive is false // (typically set to true for forced single-line indents), empty // lines are not indented, and places where the mode returns Pass // are left alone. function indentLine(cm, n, how, aggressive) {
var doc = cm.doc, state  if (how == null) { how = "add" }  if (how == "smart") {    // Fall back to "prev" when the mode doesn't have an indentation    // method.    if (!doc.mode.indent) { how = "prev" }    else { state = getStateBefore(cm, n) }  }
var tabSize = cm.options.tabSize  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize)  if (line.stateAfter) { line.stateAfter = null }  var curSpaceString = line.text.match(/^\s*/)[0], indentation  if (!aggressive && !/\S/.test(line.text)) {    indentation = 0    how = "not"  } else if (how == "smart") {    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)    if (indentation == Pass || indentation > 150) {      if (!aggressive) { return }      how = "prev"    }  }  if (how == "prev") {    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize) }    else { indentation = 0 }  } else if (how == "add") {    indentation = curSpace + cm.options.indentUnit  } else if (how == "subtract") {    indentation = curSpace - cm.options.indentUnit  } else if (typeof how == "number") {    indentation = curSpace + how  }  indentation = Math.max(0, indentation)
var indentString = "", pos = 0  if (cm.options.indentWithTabs)    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t"} }  if (pos < indentation) { indentString += spaceStr(indentation - pos) }
if (indentString != curSpaceString) {    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input")    line.stateAfter = null    return true  } else {    // Ensure that, if the cursor was in the whitespace at the start    // of the line, it is moved to the end of that space.    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {      var range = doc.sel.ranges[i$1]      if (range.head.line == n && range.head.ch < curSpaceString.length) {        var pos$1 = Pos(n, curSpaceString.length)        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1))        break      }    }  }
}
// This will be set to a {lineWise: bool, text: [string]} object, so // that, when pasting, we know what kind of selections the copied // text was made out of. var lastCopied = null
function setLastCopied(newLastCopied) {
lastCopied = newLastCopied
}
function applyTextInput(cm, inserted, deleted, sel, origin) {
var doc = cm.doc  cm.display.shift = false  if (!sel) { sel = doc.sel }
var paste = cm.state.pasteIncoming || origin == "paste"  var textLines = splitLinesAuto(inserted), multiPaste = null  // When pasing N lines into N selections, insert one line per selection  if (paste && sel.ranges.length > 1) {    if (lastCopied && lastCopied.text.join("\n") == inserted) {      if (sel.ranges.length % lastCopied.text.length == 0) {        multiPaste = []        for (var i = 0; i < lastCopied.text.length; i++)          { multiPaste.push(doc.splitLines(lastCopied.text[i])) }      }    } else if (textLines.length == sel.ranges.length) {      multiPaste = map(textLines, function (l) { return [l]; })    }  }
var updateInput  // Normal behavior is to insert the new text into every selection  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {    var range = sel.ranges[i$1]    var from = range.from(), to = range.to()    if (range.empty()) {      if (deleted && deleted > 0) // Handle deletion        { from = Pos(from.line, from.ch - deleted) }      else if (cm.state.overwrite && !paste) // Handle overwrite        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) }      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)        { from = to = Pos(from.line, 0) }    }    updateInput = cm.curOp.updateInput    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")}    makeChange(cm.doc, changeEvent)    signalLater(cm, "inputRead", cm, changeEvent)  }  if (inserted && !paste)    { triggerElectric(cm, inserted) }
ensureCursorVisible(cm)  cm.curOp.updateInput = updateInput  cm.curOp.typing = true  cm.state.pasteIncoming = cm.state.cutIncoming = false
}
function handlePaste(e, cm) {
var pasted = e.clipboardData && e.clipboardData.getData("Text")  if (pasted) {    e.preventDefault()    if (!cm.isReadOnly() && !cm.options.disableInput)      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }) }    return true  }
}
function triggerElectric(cm, inserted) {
// When an 'electric' character is inserted, immediately trigger a reindent  if (!cm.options.electricChars || !cm.options.smartIndent) { return }  var sel = cm.doc.sel
for (var i = sel.ranges.length - 1; i >= 0; i--) {    var range = sel.ranges[i]    if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }    var mode = cm.getModeAt(range.head)    var indented = false    if (mode.electricChars) {      for (var j = 0; j < mode.electricChars.length; j++)        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {          indented = indentLine(cm, range.head.line, "smart")          break        } }    } else if (mode.electricInput) {      if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))        { indented = indentLine(cm, range.head.line, "smart") }    }    if (indented) { signalLater(cm, "electricInput", cm, range.head.line) }  }
}
function copyableRanges(cm) {
var text = [], ranges = []  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {    var line = cm.doc.sel.ranges[i].head.line    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)}    ranges.push(lineRange)    text.push(cm.getRange(lineRange.anchor, lineRange.head))  }  return {text: text, ranges: ranges}
}
function disableBrowserMagic(field, spellcheck) {
field.setAttribute("autocorrect", "off")  field.setAttribute("autocapitalize", "off")  field.setAttribute("spellcheck", !!spellcheck)
}
function hiddenTextarea() {
var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none")  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;")  // The textarea is kept positioned near the cursor to prevent the  // fact that it'll be scrolled into view on input from scrolling  // our fake cursor out of view. On webkit, when wrap=off, paste is  // very slow. So make the area wide instead.  if (webkit) { te.style.width = "1000px" }  else { te.setAttribute("wrap", "off") }  // If border: 0; -- iOS fails to open keyboard (issue #1287)  if (ios) { te.style.border = "1px solid black" }  disableBrowserMagic(te)  return div
}
// The publicly visible API. Note that methodOp(f) means // 'wrap f in an operation, performed on its `this` parameter'.
// This is not the complete set of editor methods. Most of the // methods defined on the Doc type are also injected into // CodeMirror.prototype, for backwards compatibility and // convenience.
function addEditorMethods(CodeMirror) {
var optionHandlers = CodeMirror.optionHandlers
var helpers = CodeMirror.helpers = {}
CodeMirror.prototype = {    constructor: CodeMirror,    focus: function(){window.focus(); this.display.input.focus()},
setOption: function(option, value) {      var options = this.options, old = options[option]      if (options[option] == value && option != "mode") { return }      options[option] = value      if (optionHandlers.hasOwnProperty(option))        { operation(this, optionHandlers[option])(this, value, old) }      signal(this, "optionChange", this, option)    },
getOption: function(option) {return this.options[option]},    getDoc: function() {return this.doc},
addKeyMap: function(map, bottom) {      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map))    },    removeKeyMap: function(map) {      var maps = this.state.keyMaps      for (var i = 0; i < maps.length; ++i)        { if (maps[i] == map || maps[i].name == map) {          maps.splice(i, 1)          return true        } }    },
addOverlay: methodOp(function(spec, options) {      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec)      if (mode.startState) { throw new Error("Overlays may not be stateful.") }      insertSorted(this.state.overlays,                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,                    priority: (options && options.priority) || 0},                   function (overlay) { return overlay.priority; })      this.state.modeGen++      regChange(this)    }),    removeOverlay: methodOp(function(spec) {      var this$1 = this;
var overlays = this.state.overlays      for (var i = 0; i < overlays.length; ++i) {        var cur = overlays[i].modeSpec        if (cur == spec || typeof spec == "string" && cur.name == spec) {          overlays.splice(i, 1)          this$1.state.modeGen++          regChange(this$1)          return        }      }    }),
indentLine: methodOp(function(n, dir, aggressive) {      if (typeof dir != "string" && typeof dir != "number") {        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev" }        else { dir = dir ? "add" : "subtract" }      }      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive) }    }),    indentSelection: methodOp(function(how) {      var this$1 = this;
var ranges = this.doc.sel.ranges, end = -1      for (var i = 0; i < ranges.length; i++) {        var range = ranges[i]        if (!range.empty()) {          var from = range.from(), to = range.to()          var start = Math.max(end, from.line)          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1          for (var j = start; j < end; ++j)            { indentLine(this$1, j, how) }          var newRanges = this$1.doc.sel.ranges          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll) }        } else if (range.head.line > end) {          indentLine(this$1, range.head.line, how, true)          end = range.head.line          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1) }        } }    }),
// Fetch the parser token for a given character. Useful for hacks    // that want to inspect the mode state (say, for completion).    getTokenAt: function(pos, precise) {      return takeToken(this, pos, precise)    },
getLineTokens: function(line, precise) {      return takeToken(this, Pos(line), precise, true)    },
getTokenTypeAt: function(pos) {      pos = clipPos(this.doc, pos)      var styles = getLineStyles(this, getLine(this.doc, pos.line))      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch      var type      if (ch == 0) { type = styles[2] }      else { for (;;) {        var mid = (before + after) >> 1        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid }        else if (styles[mid * 2 + 1] < ch) { before = mid + 1 }        else { type = styles[mid * 2 + 2]; break }      } }      var cut = type ? type.indexOf("overlay ") : -1      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)    },
getModeAt: function(pos) {      var mode = this.doc.mode      if (!mode.innerMode) { return mode }      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode    },
getHelper: function(pos, type) {      return this.getHelpers(pos, type)[0]    },
getHelpers: function(pos, type) {      var this$1 = this;
var found = []      if (!helpers.hasOwnProperty(type)) { return found }      var help = helpers[type], mode = this.getModeAt(pos)      if (typeof mode[type] == "string") {        if (help[mode[type]]) { found.push(help[mode[type]]) }      } else if (mode[type]) {        for (var i = 0; i < mode[type].length; i++) {          var val = help[mode[type][i]]          if (val) { found.push(val) }        }      } else if (mode.helperType && help[mode.helperType]) {        found.push(help[mode.helperType])      } else if (help[mode.name]) {        found.push(help[mode.name])      }      for (var i$1 = 0; i$1 < help._global.length; i$1++) {        var cur = help._global[i$1]        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)          { found.push(cur.val) }      }      return found    },
getStateAfter: function(line, precise) {      var doc = this.doc      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line)      return getStateBefore(this, line + 1, precise)    },
cursorCoords: function(start, mode) {      var pos, range = this.doc.sel.primary()      if (start == null) { pos = range.head }      else if (typeof start == "object") { pos = clipPos(this.doc, start) }      else { pos = start ? range.from() : range.to() }      return cursorCoords(this, pos, mode || "page")    },
charCoords: function(pos, mode) {      return charCoords(this, clipPos(this.doc, pos), mode || "page")    },
coordsChar: function(coords, mode) {      coords = fromCoordSystem(this, coords, mode || "page")      return coordsChar(this, coords.left, coords.top)    },
lineAtHeight: function(height, mode) {      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top      return lineAtHeight(this.doc, height + this.display.viewOffset)    },    heightAtLine: function(line, mode, includeWidgets) {      var end = false, lineObj      if (typeof line == "number") {        var last = this.doc.first + this.doc.size - 1        if (line < this.doc.first) { line = this.doc.first }        else if (line > last) { line = last; end = true }        lineObj = getLine(this.doc, line)      } else {        lineObj = line      }      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +        (end ? this.doc.height - heightAtLine(lineObj) : 0)    },
defaultTextHeight: function() { return textHeight(this.display) },    defaultCharWidth: function() { return charWidth(this.display) },
getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},
addWidget: function(pos, node, scroll, vert, horiz) {      var display = this.display      pos = cursorCoords(this, clipPos(this.doc, pos))      var top = pos.bottom, left = pos.left      node.style.position = "absolute"      node.setAttribute("cm-ignore-events", "true")      this.display.input.setUneditable(node)      display.sizer.appendChild(node)      if (vert == "over") {        top = pos.top      } else if (vert == "above" || vert == "near") {        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth)        // Default to positioning above (if specified and possible); otherwise default to positioning below        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)          { top = pos.top - node.offsetHeight }        else if (pos.bottom + node.offsetHeight <= vspace)          { top = pos.bottom }        if (left + node.offsetWidth > hspace)          { left = hspace - node.offsetWidth }      }      node.style.top = top + "px"      node.style.left = node.style.right = ""      if (horiz == "right") {        left = display.sizer.clientWidth - node.offsetWidth        node.style.right = "0px"      } else {        if (horiz == "left") { left = 0 }        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2 }        node.style.left = left + "px"      }      if (scroll)        { scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight) }    },
triggerOnKeyDown: methodOp(onKeyDown),    triggerOnKeyPress: methodOp(onKeyPress),    triggerOnKeyUp: onKeyUp,
execCommand: function(cmd) {      if (commands.hasOwnProperty(cmd))        { return commands[cmd].call(null, this) }    },
triggerElectric: methodOp(function(text) { triggerElectric(this, text) }),
findPosH: function(from, amount, unit, visually) {      var this$1 = this;
var dir = 1      if (amount < 0) { dir = -1; amount = -amount }      var cur = clipPos(this.doc, from)      for (var i = 0; i < amount; ++i) {        cur = findPosH(this$1.doc, cur, dir, unit, visually)        if (cur.hitSide) { break }      }      return cur    },
moveH: methodOp(function(dir, unit) {      var this$1 = this;
this.extendSelectionsBy(function (range) {        if (this$1.display.shift || this$1.doc.extend || range.empty())          { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }        else          { return dir < 0 ? range.from() : range.to() }      }, sel_move)    }),
deleteH: methodOp(function(dir, unit) {      var sel = this.doc.sel, doc = this.doc      if (sel.somethingSelected())        { doc.replaceSelection("", null, "+delete") }      else        { deleteNearSelection(this, function (range) {          var other = findPosH(doc, range.head, dir, unit, false)          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}        }) }    }),
findPosV: function(from, amount, unit, goalColumn) {      var this$1 = this;
var dir = 1, x = goalColumn      if (amount < 0) { dir = -1; amount = -amount }      var cur = clipPos(this.doc, from)      for (var i = 0; i < amount; ++i) {        var coords = cursorCoords(this$1, cur, "div")        if (x == null) { x = coords.left }        else { coords.left = x }        cur = findPosV(this$1, coords, dir, unit)        if (cur.hitSide) { break }      }      return cur    },
moveV: methodOp(function(dir, unit) {      var this$1 = this;
var doc = this.doc, goals = []      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected()      doc.extendSelectionsBy(function (range) {        if (collapse)          { return dir < 0 ? range.from() : range.to() }        var headPos = cursorCoords(this$1, range.head, "div")        if (range.goalColumn != null) { headPos.left = range.goalColumn }        goals.push(headPos.left)        var pos = findPosV(this$1, headPos, dir, unit)        if (unit == "page" && range == doc.sel.primary())          { addToScrollPos(this$1, null, charCoords(this$1, pos, "div").top - headPos.top) }        return pos      }, sel_move)      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)        { doc.sel.ranges[i].goalColumn = goals[i] } }    }),
// Find the word at the given position (as returned by coordsChar).    findWordAt: function(pos) {      var doc = this.doc, line = getLine(doc, pos.line).text      var start = pos.ch, end = pos.ch      if (line) {        var helper = this.getHelper(pos, "wordChars")        if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end }        var startChar = line.charAt(start)        var check = isWordChar(startChar, helper)  ? function (ch) { return isWordChar(ch, helper); }  : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }  : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); }        while (start > 0 && check(line.charAt(start - 1))) { --start }        while (end < line.length && check(line.charAt(end))) { ++end }      }      return new Range(Pos(pos.line, start), Pos(pos.line, end))    },
toggleOverwrite: function(value) {      if (value != null && value == this.state.overwrite) { return }      if (this.state.overwrite = !this.state.overwrite)        { addClass(this.display.cursorDiv, "CodeMirror-overwrite") }      else        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite") }
signal(this, "overwriteToggle", this, this.state.overwrite)    },    hasFocus: function() { return this.display.input.getField() == activeElt() },    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },
scrollTo: methodOp(function(x, y) {      if (x != null || y != null) { resolveScrollToPos(this) }      if (x != null) { this.curOp.scrollLeft = x }      if (y != null) { this.curOp.scrollTop = y }    }),    getScrollInfo: function() {      var scroller = this.display.scroller      return {left: scroller.scrollLeft, top: scroller.scrollTop,              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}    },
scrollIntoView: methodOp(function(range, margin) {      if (range == null) {        range = {from: this.doc.sel.primary().head, to: null}        if (margin == null) { margin = this.options.cursorScrollMargin }      } else if (typeof range == "number") {        range = {from: Pos(range, 0), to: null}      } else if (range.from == null) {        range = {from: range, to: null}      }      if (!range.to) { range.to = range.from }      range.margin = margin || 0
if (range.from.line != null) {        resolveScrollToPos(this)        this.curOp.scrollToPos = range      } else {        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),                                      Math.min(range.from.top, range.to.top) - range.margin,                                      Math.max(range.from.right, range.to.right),                                      Math.max(range.from.bottom, range.to.bottom) + range.margin)        this.scrollTo(sPos.scrollLeft, sPos.scrollTop)      }    }),
setSize: methodOp(function(width, height) {      var this$1 = this;
var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; }      if (width != null) { this.display.wrapper.style.width = interpret(width) }      if (height != null) { this.display.wrapper.style.height = interpret(height) }      if (this.options.lineWrapping) { clearLineMeasurementCache(this) }      var lineNo = this.display.viewFrom      this.doc.iter(lineNo, this.display.viewTo, function (line) {        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }        ++lineNo      })      this.curOp.forceUpdate = true      signal(this, "refresh", this)    }),
operation: function(f){return runInOp(this, f)},
refresh: methodOp(function() {      var oldHeight = this.display.cachedTextHeight      regChange(this)      this.curOp.forceUpdate = true      clearCaches(this)      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop)      updateGutterSpace(this)      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)        { estimateLineHeights(this) }      signal(this, "refresh", this)    }),
swapDoc: methodOp(function(doc) {      var old = this.doc      old.cm = null      attachDoc(this, doc)      clearCaches(this)      this.display.input.reset()      this.scrollTo(doc.scrollLeft, doc.scrollTop)      this.curOp.forceScroll = true      signalLater(this, "swapDoc", this, old)      return old    }),
getInputField: function(){return this.display.input.getField()},    getWrapperElement: function(){return this.display.wrapper},    getScrollerElement: function(){return this.display.scroller},    getGutterElement: function(){return this.display.gutters}  }  eventMixin(CodeMirror)
CodeMirror.registerHelper = function(type, name, value) {    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []} }    helpers[type][name] = value  }  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {    CodeMirror.registerHelper(type, name, value)    helpers[type]._global.push({pred: predicate, val: value})  }
}
// Used for horizontal relative motion. Dir is -1 or 1 (left or // right), unit can be "char", "column" (like char, but doesn't // cross line boundaries), "word" (across next word), or "group" (to // the start of next group of word or non-word-non-whitespace // chars). The visually param controls whether, in right-to-left // text, direction 1 means to move towards the next index in the // string, or towards the character to the right of the current // position. The resulting position will have a hitSide=true // property if it reached the end of the document. function findPosH(doc, pos, dir, unit, visually) {
var oldPos = pos  var origDir = dir  var lineObj = getLine(doc, pos.line)  function findNextLine() {    var l = pos.line + dir    if (l < doc.first || l >= doc.first + doc.size) { return false }    pos = new Pos(l, pos.ch, pos.sticky)    return lineObj = getLine(doc, l)  }  function moveOnce(boundToLine) {    var next    if (visually) {      next = moveVisually(doc.cm, lineObj, pos, dir)    } else {      next = moveLogically(lineObj, pos, dir)    }    if (next == null) {      if (!boundToLine && findNextLine())        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir) }      else        { return false }    } else {      pos = next    }    return true  }
if (unit == "char") {    moveOnce()  } else if (unit == "column") {    moveOnce(true)  } else if (unit == "word" || unit == "group") {    var sawType = null, group = unit == "group"    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars")    for (var first = true;; first = false) {      if (dir < 0 && !moveOnce(!first)) { break }      var cur = lineObj.text.charAt(pos.ch) || "\n"      var type = isWordChar(cur, helper) ? "w"  : group && cur == "\n" ? "n"  : !group || /\s/.test(cur) ? null  : "p"      if (group && !first && !type) { type = "s" }      if (sawType && sawType != type) {        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after"}        break      }
if (type) { sawType = type }      if (dir > 0 && !moveOnce(!first)) { break }    }  }  var result = skipAtomic(doc, pos, oldPos, origDir, true)  if (equalCursorPos(oldPos, result)) { result.hitSide = true }  return result
}
// For relative vertical movement. Dir may be -1 or 1. Unit can be // "page" or "line". The resulting position will have a hitSide=true // property if it reached the end of the document. function findPosV(cm, pos, dir, unit) {
var doc = cm.doc, x = pos.left, y  if (unit == "page") {    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight)    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3)    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount
} else if (unit == "line") {    y = dir > 0 ? pos.bottom + 3 : pos.top - 3  }  var target  for (;;) {    target = coordsChar(cm, x, y)    if (!target.outside) { break }    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }    y += dir * 5  }  return target
}
// CONTENTEDITABLE INPUT STYLE
var ContentEditableInput = function(cm) {
this.cm = cm  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null  this.polling = new Delayed()  this.composing = null  this.gracePeriod = false  this.readDOMTimeout = null
};
ContentEditableInput.prototype.init = function (display) {
var this$1 = this;
var input = this, cm = input.cm  var div = input.div = display.lineDiv  disableBrowserMagic(div, cm.options.spellcheck)
on(div, "paste", function (e) {    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }    // IE doesn't fire input events, so we schedule a read for the pasted content in this way    if (ie_version <= 11) { setTimeout(operation(cm, function () {      if (!input.pollContent()) { regChange(cm) }    }), 20) }  })
on(div, "compositionstart", function (e) {    this$1.composing = {data: e.data, done: false}  })  on(div, "compositionupdate", function (e) {    if (!this$1.composing) { this$1.composing = {data: e.data, done: false} }  })  on(div, "compositionend", function (e) {    if (this$1.composing) {      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon() }      this$1.composing.done = true    }  })
on(div, "touchstart", function () { return input.forceCompositionEnd(); })
on(div, "input", function () {    if (!this$1.composing) { this$1.readFromDOMSoon() }  })
function onCopyCut(e) {    if (signalDOMEvent(cm, e)) { return }    if (cm.somethingSelected()) {      setLastCopied({lineWise: false, text: cm.getSelections()})      if (e.type == "cut") { cm.replaceSelection("", null, "cut") }    } else if (!cm.options.lineWiseCopyCut) {      return    } else {      var ranges = copyableRanges(cm)      setLastCopied({lineWise: true, text: ranges.text})      if (e.type == "cut") {        cm.operation(function () {          cm.setSelections(ranges.ranges, 0, sel_dontScroll)          cm.replaceSelection("", null, "cut")        })      }    }    if (e.clipboardData) {      e.clipboardData.clearData()      var content = lastCopied.text.join("\n")      // iOS exposes the clipboard API, but seems to discard content inserted into it      e.clipboardData.setData("Text", content)      if (e.clipboardData.getData("Text") == content) {        e.preventDefault()        return      }    }    // Old-fashioned briefly-focus-a-textarea hack    var kludge = hiddenTextarea(), te = kludge.firstChild    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild)    te.value = lastCopied.text.join("\n")    var hadFocus = document.activeElement    selectInput(te)    setTimeout(function () {      cm.display.lineSpace.removeChild(kludge)      hadFocus.focus()      if (hadFocus == div) { input.showPrimarySelection() }    }, 50)  }  on(div, "copy", onCopyCut)  on(div, "cut", onCopyCut)
};
ContentEditableInput.prototype.prepareSelection = function () {
var result = prepareSelection(this.cm, false)  result.focus = this.cm.state.focused  return result
};
ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
if (!info || !this.cm.display.view.length) { return }  if (info.focus || takeFocus) { this.showPrimarySelection() }  this.showMultipleSelections(info)
};
ContentEditableInput.prototype.showPrimarySelection = function () {
var sel = window.getSelection(), prim = this.cm.doc.sel.primary()  var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset)  var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset)  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), prim.from()) == 0 && cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)    { return }
var start = posToDOM(this.cm, prim.from())  var end = posToDOM(this.cm, prim.to())  if (!start && !end) { return }
var view = this.cm.display.view  var old = sel.rangeCount && sel.getRangeAt(0)  if (!start) {    start = {node: view[0].measure.map[2], offset: 0}  } else if (!end) { // FIXME dangerously hacky    var measure = view[view.length - 1].measure    var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map    end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]}  }
var rng  try { rng = range(start.node, start.offset, end.offset, end.node) }  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible  if (rng) {    if (!gecko && this.cm.state.focused) {      sel.collapse(start.node, start.offset)      if (!rng.collapsed) {        sel.removeAllRanges()        sel.addRange(rng)      }    } else {      sel.removeAllRanges()      sel.addRange(rng)    }    if (old && sel.anchorNode == null) { sel.addRange(old) }    else if (gecko) { this.startGracePeriod() }  }  this.rememberSelection()
};
ContentEditableInput.prototype.startGracePeriod = function () {
var this$1 = this;
clearTimeout(this.gracePeriod)  this.gracePeriod = setTimeout(function () {    this$1.gracePeriod = false    if (this$1.selectionChanged())      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }) }  }, 20)
};
ContentEditableInput.prototype.showMultipleSelections = function (info) {
removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors)  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)
};
ContentEditableInput.prototype.rememberSelection = function () {
var sel = window.getSelection()  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset
};
ContentEditableInput.prototype.selectionInEditor = function () {
var sel = window.getSelection()  if (!sel.rangeCount) { return false }  var node = sel.getRangeAt(0).commonAncestorContainer  return contains(this.div, node)
};
ContentEditableInput.prototype.focus = function () {
if (this.cm.options.readOnly != "nocursor") {    if (!this.selectionInEditor())      { this.showSelection(this.prepareSelection(), true) }    this.div.focus()  }
}; ContentEditableInput.prototype.blur = function () { this.div.blur() }; ContentEditableInput.prototype.getField = function () { return this.div };
ContentEditableInput.prototype.supportsTouch = function () { return true };
ContentEditableInput.prototype.receivedFocus = function () {
var input = this  if (this.selectionInEditor())    { this.pollSelection() }  else    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }) }
function poll() {    if (input.cm.state.focused) {      input.pollSelection()      input.polling.set(input.cm.options.pollInterval, poll)    }  }  this.polling.set(this.cm.options.pollInterval, poll)
};
ContentEditableInput.prototype.selectionChanged = function () {
var sel = window.getSelection()  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
};
ContentEditableInput.prototype.pollSelection = function () {
if (!this.composing && this.readDOMTimeout == null && !this.gracePeriod && this.selectionChanged()) {    var sel = window.getSelection(), cm = this.cm    this.rememberSelection()    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)    var head = domToPos(cm, sel.focusNode, sel.focusOffset)    if (anchor && head) { runInOp(cm, function () {      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll)      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true }    }) }  }
};
ContentEditableInput.prototype.pollContent = function () {
if (this.readDOMTimeout != null) {    clearTimeout(this.readDOMTimeout)    this.readDOMTimeout = null  }
var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary()  var from = sel.from(), to = sel.to()  if (from.ch == 0 && from.line > cm.firstLine())    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length) }  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())    { to = Pos(to.line + 1, 0) }  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }
var fromIndex, fromLine, fromNode  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {    fromLine = lineNo(display.view[0].line)    fromNode = display.view[0].node  } else {    fromLine = lineNo(display.view[fromIndex].line)    fromNode = display.view[fromIndex - 1].node.nextSibling  }  var toIndex = findViewIndex(cm, to.line)  var toLine, toNode  if (toIndex == display.view.length - 1) {    toLine = display.viewTo - 1    toNode = display.lineDiv.lastChild  } else {    toLine = lineNo(display.view[toIndex + 1].line) - 1    toNode = display.view[toIndex + 1].node.previousSibling  }
if (!fromNode) { return false }  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine))  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length))  while (newText.length > 1 && oldText.length > 1) {    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine-- }    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++ }    else { break }  }
var cutFront = 0, cutEnd = 0  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length)  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))    { ++cutFront }  var newBot = lst(newText), oldBot = lst(oldText)  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),                           oldBot.length - (oldText.length == 1 ? cutFront : 0))  while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))    { ++cutEnd }
newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "")  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "")
var chFrom = Pos(fromLine, cutFront)  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0)  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {    replaceRange(cm.doc, newText, chFrom, chTo, "+input")    return true  }
};
ContentEditableInput.prototype.ensurePolled = function () {
this.forceCompositionEnd()
}; ContentEditableInput.prototype.reset = function () {
this.forceCompositionEnd()
}; ContentEditableInput.prototype.forceCompositionEnd = function () {
if (!this.composing) { return }  clearTimeout(this.readDOMTimeout)  this.composing = null  if (!this.pollContent()) { regChange(this.cm) }  this.div.blur()  this.div.focus()
}; ContentEditableInput.prototype.readFromDOMSoon = function () {
var this$1 = this;
if (this.readDOMTimeout != null) { return }  this.readDOMTimeout = setTimeout(function () {    this$1.readDOMTimeout = null    if (this$1.composing) {      if (this$1.composing.done) { this$1.composing = null }      else { return }    }    if (this$1.cm.isReadOnly() || !this$1.pollContent())      { runInOp(this$1.cm, function () { return regChange(this$1.cm); }) }  }, 80)
};
ContentEditableInput.prototype.setUneditable = function (node) {
node.contentEditable = "false"
};
ContentEditableInput.prototype.onKeyPress = function (e) {
if (e.charCode == 0) { return }  e.preventDefault()  if (!this.cm.isReadOnly())    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0) }
};
ContentEditableInput.prototype.readOnlyChanged = function (val) {
this.div.contentEditable = String(val != "nocursor")
};
ContentEditableInput.prototype.onContextMenu = function () {}; ContentEditableInput.prototype.resetPosition = function () {};
ContentEditableInput.prototype.needsContentAttribute = true
function posToDOM(cm, pos) {
var view = findViewForLine(cm, pos.line)  if (!view || view.hidden) { return null }  var line = getLine(cm.doc, pos.line)  var info = mapFromLineView(view, line, pos.line)
var order = getOrder(line), side = "left"  if (order) {    var partPos = getBidiPartAt(order, pos.ch)    side = partPos % 2 ? "right" : "left"  }  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side)  result.offset = result.collapse == "right" ? result.end : result.start  return result
}
function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }
function domTextBetween(cm, from, to, fromLine, toLine) {
var text = "", closing = false, lineSep = cm.doc.lineSeparator()  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }  function walk(node) {    if (node.nodeType == 1) {      var cmText = node.getAttribute("cm-text")      if (cmText != null) {        if (cmText == "") { text += node.textContent.replace(/\u200b/g, "") }        else { text += cmText }        return      }      var markerID = node.getAttribute("cm-marker"), range      if (markerID) {        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID))        if (found.length && (range = found[0].find()))          { text += getBetween(cm.doc, range.from, range.to).join(lineSep) }        return      }      if (node.getAttribute("contenteditable") == "false") { return }      for (var i = 0; i < node.childNodes.length; i++)        { walk(node.childNodes[i]) }      if (/^(pre|div|p)$/i.test(node.nodeName))        { closing = true }    } else if (node.nodeType == 3) {      var val = node.nodeValue      if (!val) { return }      if (closing) {        text += lineSep        closing = false      }      text += val    }  }  for (;;) {    walk(from)    if (from == to) { break }    from = from.nextSibling  }  return text
}
function domToPos(cm, node, offset) {
var lineNode  if (node == cm.display.lineDiv) {    lineNode = cm.display.lineDiv.childNodes[offset]    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }    node = null; offset = 0  } else {    for (lineNode = node;; lineNode = lineNode.parentNode) {      if (!lineNode || lineNode == cm.display.lineDiv) { return null }      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }    }  }  for (var i = 0; i < cm.display.view.length; i++) {    var lineView = cm.display.view[i]    if (lineView.node == lineNode)      { return locateNodeInLineView(lineView, node, offset) }  }
}
function locateNodeInLineView(lineView, node, offset) {
var wrapper = lineView.text.firstChild, bad = false  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }  if (node == wrapper) {    bad = true    node = wrapper.childNodes[offset]    offset = 0    if (!node) {      var line = lineView.rest ? lst(lineView.rest) : lineView.line      return badPos(Pos(lineNo(line), line.text.length), bad)    }  }
var textNode = node.nodeType == 3 ? node : null, topNode = node  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {    textNode = node.firstChild    if (offset) { offset = textNode.nodeValue.length }  }  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode }  var measure = lineView.measure, maps = measure.maps
function find(textNode, topNode, offset) {    for (var i = -1; i < (maps ? maps.length : 0); i++) {      var map = i < 0 ? measure.map : maps[i]      for (var j = 0; j < map.length; j += 3) {        var curNode = map[j + 2]        if (curNode == textNode || curNode == topNode) {          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i])          var ch = map[j] + offset          if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)] }          return Pos(line, ch)        }      }    }  }  var found = find(textNode, topNode, offset)  if (found) { return badPos(found, bad) }
// FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {    found = find(after, after.firstChild, 0)    if (found)      { return badPos(Pos(found.line, found.ch - dist), bad) }    else      { dist += after.textContent.length }  }  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {    found = find(before, before.firstChild, -1)    if (found)      { return badPos(Pos(found.line, found.ch + dist$1), bad) }    else      { dist$1 += before.textContent.length }  }
}
// TEXTAREA INPUT STYLE
var TextareaInput = function(cm) {
this.cm = cm  // See input.poll and input.reset  this.prevInput = ""
// Flag that indicates whether we expect input to appear real soon  // now (after some event like 'keypress' or 'input') and are  // polling intensively.  this.pollingFast = false  // Self-resetting timeout for the poller  this.polling = new Delayed()  // Tracks when input.reset has punted to just putting a short  // string into the textarea instead of the full selection.  this.inaccurateSelection = false  // Used to work around IE issue with selection being forgotten when focus moves away from textarea  this.hasSelection = false  this.composing = null
};
TextareaInput.prototype.init = function (display) {
var this$1 = this;
var input = this, cm = this.cm
// Wraps and hides input textarea  var div = this.wrapper = hiddenTextarea()  // The semihidden textarea that is focused when the editor is  // focused, and receives input.  var te = this.textarea = div.firstChild  display.wrapper.insertBefore(div, display.wrapper.firstChild)
// Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)  if (ios) { te.style.width = "0px" }
on(te, "input", function () {    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null }    input.poll()  })
on(te, "paste", function (e) {    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
cm.state.pasteIncoming = true    input.fastPoll()  })
function prepareCopyCut(e) {    if (signalDOMEvent(cm, e)) { return }    if (cm.somethingSelected()) {      setLastCopied({lineWise: false, text: cm.getSelections()})      if (input.inaccurateSelection) {        input.prevInput = ""        input.inaccurateSelection = false        te.value = lastCopied.text.join("\n")        selectInput(te)      }    } else if (!cm.options.lineWiseCopyCut) {      return    } else {      var ranges = copyableRanges(cm)      setLastCopied({lineWise: true, text: ranges.text})      if (e.type == "cut") {        cm.setSelections(ranges.ranges, null, sel_dontScroll)      } else {        input.prevInput = ""        te.value = ranges.text.join("\n")        selectInput(te)      }    }    if (e.type == "cut") { cm.state.cutIncoming = true }  }  on(te, "cut", prepareCopyCut)  on(te, "copy", prepareCopyCut)
on(display.scroller, "paste", function (e) {    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }    cm.state.pasteIncoming = true    input.focus()  })
// Prevent normal selection in the editor (we handle our own)  on(display.lineSpace, "selectstart", function (e) {    if (!eventInWidget(display, e)) { e_preventDefault(e) }  })
on(te, "compositionstart", function () {    var start = cm.getCursor("from")    if (input.composing) { input.composing.range.clear() }    input.composing = {      start: start,      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})    }  })  on(te, "compositionend", function () {    if (input.composing) {      input.poll()      input.composing.range.clear()      input.composing = null    }  })
};
TextareaInput.prototype.prepareSelection = function () {
// Redraw the selection and/or cursor  var cm = this.cm, display = cm.display, doc = cm.doc  var result = prepareSelection(cm)
// Move the hidden textarea near the cursor to prevent scrolling artifacts  if (cm.options.moveInputWithCursor) {    var headPos = cursorCoords(cm, doc.sel.primary().head, "div")    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect()    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,                                        headPos.top + lineOff.top - wrapOff.top))    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,                                         headPos.left + lineOff.left - wrapOff.left))  }
return result
};
TextareaInput.prototype.showSelection = function (drawn) {
var cm = this.cm, display = cm.display  removeChildrenAndAdd(display.cursorDiv, drawn.cursors)  removeChildrenAndAdd(display.selectionDiv, drawn.selection)  if (drawn.teTop != null) {    this.wrapper.style.top = drawn.teTop + "px"    this.wrapper.style.left = drawn.teLeft + "px"  }
};
// Reset the input to correspond to the selection (or to be empty, // when not typing and nothing is selected) TextareaInput.prototype.reset = function (typing) {
if (this.contextMenuPending) { return }  var minimal, selected, cm = this.cm, doc = cm.doc  if (cm.somethingSelected()) {    this.prevInput = ""    var range = doc.sel.primary()    minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000)    var content = minimal ? "-" : selected || cm.getSelection()    this.textarea.value = content    if (cm.state.focused) { selectInput(this.textarea) }    if (ie && ie_version >= 9) { this.hasSelection = content }  } else if (!typing) {    this.prevInput = this.textarea.value = ""    if (ie && ie_version >= 9) { this.hasSelection = null }  }  this.inaccurateSelection = minimal
};
TextareaInput.prototype.getField = function () { return this.textarea };
TextareaInput.prototype.supportsTouch = function () { return false };
TextareaInput.prototype.focus = function () {
if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {    try { this.textarea.focus() }    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM  }
};
TextareaInput.prototype.blur = function () { this.textarea.blur() };
TextareaInput.prototype.resetPosition = function () {
this.wrapper.style.top = this.wrapper.style.left = 0
};
TextareaInput.prototype.receivedFocus = function () { this.slowPoll() };
// Poll for input changes, using the normal rate of polling. This // runs as long as the editor is focused. TextareaInput.prototype.slowPoll = function () {
var this$1 = this;
if (this.pollingFast) { return }  this.polling.set(this.cm.options.pollInterval, function () {    this$1.poll()    if (this$1.cm.state.focused) { this$1.slowPoll() }  })
};
// When an event has just come in that is likely to add or change // something in the input textarea, we poll faster, to ensure that // the change appears on the screen quickly. TextareaInput.prototype.fastPoll = function () {
var missed = false, input = this  input.pollingFast = true  function p() {    var changed = input.poll()    if (!changed && !missed) {missed = true; input.polling.set(60, p)}    else {input.pollingFast = false; input.slowPoll()}  }  input.polling.set(20, p)
};
// Read input from the textarea, and update the document to match. // When something is selected, it is present in the textarea, and // selected (unless it is huge, in which case a placeholder is // used). When nothing is selected, the cursor sits after previously // seen text (can be empty), which is stored in prevInput (we must // not reset the textarea when typing, because that breaks IME). TextareaInput.prototype.poll = function () {
var this$1 = this;
var cm = this.cm, input = this.textarea, prevInput = this.prevInput  // Since this is called a *lot*, try to bail out as cheaply as  // possible when it is clear that nothing happened. hasSelection  // will be the case when there is a lot of text in the textarea,  // in which case reading its value would be expensive.  if (this.contextMenuPending || !cm.state.focused ||      (hasSelection(input) && !prevInput && !this.composing) ||      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)    { return false }
var text = input.value  // If nothing changed, bail.  if (text == prevInput && !cm.somethingSelected()) { return false }  // Work around nonsensical selection resetting in IE9/10, and  // inexplicable appearance of private area unicode characters on  // some key combos in Mac (#2689).  if (ie && ie_version >= 9 && this.hasSelection === text ||      mac && /[\uf700-\uf7ff]/.test(text)) {    cm.display.input.reset()    return false  }
if (cm.doc.sel == cm.display.selForContextMenu) {    var first = text.charCodeAt(0)    if (first == 0x200b && !prevInput) { prevInput = "\u200b" }    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }  }  // Find the part of the input that is actually new  var same = 0, l = Math.min(prevInput.length, text.length)  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same }
runInOp(cm, function () {    applyTextInput(cm, text.slice(same), prevInput.length - same,                   null, this$1.composing ? "*compose" : null)
// Don't leave long text in the textarea, since it makes further polling slow    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = "" }    else { this$1.prevInput = text }
if (this$1.composing) {      this$1.composing.range.clear()      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),                                         {className: "CodeMirror-composing"})    }  })  return true
};
TextareaInput.prototype.ensurePolled = function () {
if (this.pollingFast && this.poll()) { this.pollingFast = false }
};
TextareaInput.prototype.onKeyPress = function () {
if (ie && ie_version >= 9) { this.hasSelection = null }  this.fastPoll()
};
TextareaInput.prototype.onContextMenu = function (e) {
var input = this, cm = input.cm, display = cm.display, te = input.textarea  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop  if (!pos || presto) { return } // Opera is difficult.
// Reset the current text selection only if the click is done outside of the selection  // and 'resetSelectionOnContextMenu' option is true.  var reset = cm.options.resetSelectionOnContextMenu  if (reset && cm.doc.sel.contains(pos) == -1)    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll) }
var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText  input.wrapper.style.cssText = "position: absolute"  var wrapperBox = input.wrapper.getBoundingClientRect()  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);"  var oldScrollY  if (webkit) { oldScrollY = window.scrollY } // Work around Chrome issue (#2712)  display.input.focus()  if (webkit) { window.scrollTo(null, oldScrollY) }  display.input.reset()  // Adds "Select all" to context menu in FF  if (!cm.somethingSelected()) { te.value = input.prevInput = " " }  input.contextMenuPending = true  display.selForContextMenu = cm.doc.sel  clearTimeout(display.detectingSelectAll)
// Select-all will be greyed out if there's nothing to select, so  // this adds a zero-width space so that we can later check whether  // it got selected.  function prepareSelectAllHack() {    if (te.selectionStart != null) {      var selected = cm.somethingSelected()      var extval = "\u200b" + (selected ? te.value : "")      te.value = "\u21da" // Used to catch context-menu undo      te.value = extval      input.prevInput = selected ? "" : "\u200b"      te.selectionStart = 1; te.selectionEnd = extval.length      // Re-set this, in case some other handler touched the      // selection in the meantime.      display.selForContextMenu = cm.doc.sel    }  }  function rehide() {    input.contextMenuPending = false    input.wrapper.style.cssText = oldWrapperCSS    te.style.cssText = oldCSS    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos) }
// Try to detect the user choosing select-all    if (te.selectionStart != null) {      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack() }      var i = 0, poll = function () {        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200b") {          operation(cm, selectAll)(cm)        } else if (i++ < 10) {          display.detectingSelectAll = setTimeout(poll, 500)        } else {          display.selForContextMenu = null          display.input.reset()        }      }      display.detectingSelectAll = setTimeout(poll, 200)    }  }
if (ie && ie_version >= 9) { prepareSelectAllHack() }  if (captureRightClick) {    e_stop(e)    var mouseup = function () {      off(window, "mouseup", mouseup)      setTimeout(rehide, 20)    }    on(window, "mouseup", mouseup)  } else {    setTimeout(rehide, 50)  }
};
TextareaInput.prototype.readOnlyChanged = function (val) {
if (!val) { this.reset() }
};
TextareaInput.prototype.setUneditable = function () {};
TextareaInput.prototype.needsContentAttribute = false
function fromTextArea(textarea, options) {
options = options ? copyObj(options) : {}  options.value = textarea.value  if (!options.tabindex && textarea.tabIndex)    { options.tabindex = textarea.tabIndex }  if (!options.placeholder && textarea.placeholder)    { options.placeholder = textarea.placeholder }  // Set autofocus to true if this textarea is focused, or if it has  // autofocus and no other element is focused.  if (options.autofocus == null) {    var hasFocus = activeElt()    options.autofocus = hasFocus == textarea ||      textarea.getAttribute("autofocus") != null && hasFocus == document.body  }
function save() {textarea.value = cm.getValue()}
var realSubmit  if (textarea.form) {    on(textarea.form, "submit", save)    // Deplorable hack to make the submit method do the right thing.    if (!options.leaveSubmitMethodAlone) {      var form = textarea.form      realSubmit = form.submit      try {        var wrappedSubmit = form.submit = function () {          save()          form.submit = realSubmit          form.submit()          form.submit = wrappedSubmit        }      } catch(e) {}    }  }
options.finishInit = function (cm) {    cm.save = save    cm.getTextArea = function () { return textarea; }    cm.toTextArea = function () {      cm.toTextArea = isNaN // Prevent this from being ran twice      save()      textarea.parentNode.removeChild(cm.getWrapperElement())      textarea.style.display = ""      if (textarea.form) {        off(textarea.form, "submit", save)        if (typeof textarea.form.submit == "function")          { textarea.form.submit = realSubmit }      }    }  }
textarea.style.display = "none"  var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },    options)  return cm
}
function addLegacyProps(CodeMirror) {
CodeMirror.off = off  CodeMirror.on = on  CodeMirror.wheelEventPixels = wheelEventPixels  CodeMirror.Doc = Doc  CodeMirror.splitLines = splitLinesAuto  CodeMirror.countColumn = countColumn  CodeMirror.findColumn = findColumn  CodeMirror.isWordChar = isWordCharBasic  CodeMirror.Pass = Pass  CodeMirror.signal = signal  CodeMirror.Line = Line  CodeMirror.changeEnd = changeEnd  CodeMirror.scrollbarModel = scrollbarModel  CodeMirror.Pos = Pos  CodeMirror.cmpPos = cmp  CodeMirror.modes = modes  CodeMirror.mimeModes = mimeModes  CodeMirror.resolveMode = resolveMode  CodeMirror.getMode = getMode  CodeMirror.modeExtensions = modeExtensions  CodeMirror.extendMode = extendMode  CodeMirror.copyState = copyState  CodeMirror.startState = startState  CodeMirror.innerMode = innerMode  CodeMirror.commands = commands  CodeMirror.keyMap = keyMap  CodeMirror.keyName = keyName  CodeMirror.isModifierKey = isModifierKey  CodeMirror.lookupKey = lookupKey  CodeMirror.normalizeKeyMap = normalizeKeyMap  CodeMirror.StringStream = StringStream  CodeMirror.SharedTextMarker = SharedTextMarker  CodeMirror.TextMarker = TextMarker  CodeMirror.LineWidget = LineWidget  CodeMirror.e_preventDefault = e_preventDefault  CodeMirror.e_stopPropagation = e_stopPropagation  CodeMirror.e_stop = e_stop  CodeMirror.addClass = addClass  CodeMirror.contains = contains  CodeMirror.rmClass = rmClass  CodeMirror.keyNames = keyNames
}
// EDITOR CONSTRUCTOR
defineOptions(CodeMirror)
addEditorMethods(CodeMirror)
// Set up methods on CodeMirror's prototype to redirect to the editor's document. var dontDelegate = "iter insert remove copy getEditor constructor".split(" ") for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
{ CodeMirror.prototype[prop] = (function(method) {    return function() {return method.apply(this.doc, arguments)}  })(Doc.prototype[prop]) } }
eventMixin(Doc)
// INPUT HANDLING
CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput}
// MODE DEFINITION AND QUERYING
// Extra arguments are stored as the mode's dependencies, which is // used by (legacy) mechanisms like loadmode.js to automatically // load a mode. (Preferred mechanism is the require/define calls.) CodeMirror.defineMode = function(name/*, mode, …*/) {
if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name }  defineMode.apply(this, arguments)
}
CodeMirror.defineMIME = defineMIME
// Minimal default mode. CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); }) CodeMirror.defineMIME("text/plain", "null")
// EXTENSIONS
CodeMirror.defineExtension = function (name, func) {
CodeMirror.prototype[name] = func
} CodeMirror.defineDocExtension = function (name, func) {
Doc.prototype[name] = func
}
CodeMirror.fromTextArea = fromTextArea
addLegacyProps(CodeMirror)
CodeMirror.version = "5.24.2"
return CodeMirror;
})));</script>
<script>// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
// Open simple dialogs on top of an editor. Relies on dialog.css.
(function(mod) {
if (typeof exports == "object" && typeof module == "object") // CommonJS    mod(require("../../lib/codemirror"));  else if (typeof define == "function" && define.amd) // AMD    define(["../../lib/codemirror"], mod);  else // Plain browser env    mod(CodeMirror);
})(function(CodeMirror) {
function dialogDiv(cm, template, bottom) {    var wrap = cm.getWrapperElement();    var dialog;    dialog = wrap.appendChild(document.createElement("div"));    if (bottom)      dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";    else      dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";
if (typeof template == "string") {      dialog.innerHTML = template;    } else { // Assuming it's a detached DOM element.      dialog.appendChild(template);    }    return dialog;  }
function closeNotification(cm, newVal) {    if (cm.state.currentNotificationClose)      cm.state.currentNotificationClose();    cm.state.currentNotificationClose = newVal;  }
CodeMirror.defineExtension("openDialog", function(template, callback, options) {    if (!options) options = {};
closeNotification(this, null);
var dialog = dialogDiv(this, template, options.bottom);    var closed = false, me = this;    function close(newVal) {      if (typeof newVal == 'string') {        inp.value = newVal;      } else {        if (closed) return;        closed = true;        dialog.parentNode.removeChild(dialog);        me.focus();
if (options.onClose) options.onClose(dialog);      }    }
var inp = dialog.getElementsByTagName("input")[0], button;    if (inp) {      inp.focus();
if (options.value) {        inp.value = options.value;        if (options.selectValueOnOpen !== false) {          inp.select();        }      }
if (options.onInput)        CodeMirror.on(inp, "input", function(e) { options.onInput(e, inp.value, close);});      if (options.onKeyUp)        CodeMirror.on(inp, "keyup", function(e) {options.onKeyUp(e, inp.value, close);});
CodeMirror.on(inp, "keydown", function(e) {        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; } if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {          inp.blur();          CodeMirror.e_stop(e);          close();        }        if (e.keyCode == 13) callback(inp.value, e);      });
if (options.closeOnBlur !== false) CodeMirror.on(inp, "blur", close);    } else if (button = dialog.getElementsByTagName("button")[0]) {      CodeMirror.on(button, "click", function() {        close();        me.focus();      });
if (options.closeOnBlur !== false) CodeMirror.on(button, "blur", close);
button.focus();    }    return close;  });
CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {    closeNotification(this, null);    var dialog = dialogDiv(this, template, options && options.bottom);    var buttons = dialog.getElementsByTagName("button");    var closed = false, me = this, blurring = 1;    function close() {      if (closed) return;      closed = true;      dialog.parentNode.removeChild(dialog);      me.focus();    }    buttons[0].focus();    for (var i = 0; i < buttons.length; ++i) {      var b = buttons[i];      (function(callback) {        CodeMirror.on(b, "click", function(e) {          CodeMirror.e_preventDefault(e);          close();          if (callback) callback(me);        });      })(callbacks[i]);      CodeMirror.on(b, "blur", function() {        --blurring;        setTimeout(function() { if (blurring <= 0) close(); }, 200);      });      CodeMirror.on(b, "focus", function() { ++blurring; });    }  });
/*   * openNotification   * Opens a notification, that can be closed with an optional timer   * (default 5000ms timer) and always closes on click.   *   * If a notification is opened while another is opened, it will close the   * currently opened one and open the new one immediately.   */  CodeMirror.defineExtension("openNotification", function(template, options) {    closeNotification(this, close);    var dialog = dialogDiv(this, template, options && options.bottom);    var closed = false, doneTimer;    var duration = options && typeof options.duration !== "undefined" ? options.duration : 5000;
function close() {      if (closed) return;      closed = true;      clearTimeout(doneTimer);      dialog.parentNode.removeChild(dialog);    }
CodeMirror.on(dialog, 'click', function(e) {      CodeMirror.e_preventDefault(e);      close();    });
if (duration)      doneTimer = setTimeout(close, duration);
return close;  });
}); </script>
<script>// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
(function(mod) {
if (typeof exports == "object" && typeof module == "object") // CommonJS    mod(require("../../lib/codemirror"));  else if (typeof define == "function" && define.amd) // AMD    define(["../../lib/codemirror"], mod);  else // Plain browser env    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";
CodeMirror.defineSimpleMode = function(name, states) {    CodeMirror.defineMode(name, function(config) {      return CodeMirror.simpleMode(config, states);    });  };
CodeMirror.simpleMode = function(config, states) {    ensureState(states, "start");    var states_ = {}, meta = states.meta || {}, hasIndentation = false;    for (var state in states) if (state != meta && states.hasOwnProperty(state)) {      var list = states_[state] = [], orig = states[state];      for (var i = 0; i < orig.length; i++) {        var data = orig[i];        list.push(new Rule(data, states));        if (data.indent || data.dedent) hasIndentation = true;      }    }    var mode = {      startState: function() {        return {state: "start", pending: null,                local: null, localState: null,                indent: hasIndentation ? [] : null};      },      copyState: function(state) {        var s = {state: state.state, pending: state.pending,                 local: state.local, localState: null,                 indent: state.indent && state.indent.slice(0)};        if (state.localState)          s.localState = CodeMirror.copyState(state.local.mode, state.localState);        if (state.stack)          s.stack = state.stack.slice(0);        for (var pers = state.persistentStates; pers; pers = pers.next)          s.persistentStates = {mode: pers.mode,                                spec: pers.spec,                                state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),                                next: s.persistentStates};        return s;      },      token: tokenFunction(states_, config),      innerMode: function(state) { return state.local && {mode: state.local.mode, state: state.localState}; },      indent: indentFunction(states_, meta)    };    if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))      mode[prop] = meta[prop];    return mode;  };
function ensureState(states, name) {    if (!states.hasOwnProperty(name))      throw new Error("Undefined state " + name + " in simple mode");  }
function toRegex(val, caret) {    if (!val) return /(?:)/;    var flags = "";    if (val instanceof RegExp) {      if (val.ignoreCase) flags = "i";      val = val.source;    } else {      val = String(val);    }    return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);  }
function asToken(val) {    if (!val) return null;    if (typeof val == "string") return val.replace(/\./g, " ");    var result = [];    for (var i = 0; i < val.length; i++)      result.push(val[i] && val[i].replace(/\./g, " "));    return result;  }
function Rule(data, states) {    if (data.next || data.push) ensureState(states, data.next || data.push);    this.regex = toRegex(data.regex);    this.token = asToken(data.token);    this.data = data;  }
function tokenFunction(states, config) {    return function(stream, state) {      if (state.pending) {        var pend = state.pending.shift();        if (state.pending.length == 0) state.pending = null;        stream.pos += pend.text.length;        return pend.token;      }
if (state.local) {        if (state.local.end && stream.match(state.local.end)) {          var tok = state.local.endToken || null;          state.local = state.localState = null;          return tok;        } else {          var tok = state.local.mode.token(stream, state.localState), m;          if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))            stream.pos = stream.start + m.index;          return tok;        }      }
var curState = states[state.state];      for (var i = 0; i < curState.length; i++) {        var rule = curState[i];        var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);        if (matches) {          if (rule.data.next) {            state.state = rule.data.next;          } else if (rule.data.push) {            (state.stack || (state.stack = [])).push(state.state);            state.state = rule.data.push;          } else if (rule.data.pop && state.stack && state.stack.length) {            state.state = state.stack.pop();          }
if (rule.data.mode)            enterLocalMode(config, state, rule.data.mode, rule.token);          if (rule.data.indent)            state.indent.push(stream.indentation() + config.indentUnit);          if (rule.data.dedent)            state.indent.pop();          if (matches.length > 2) {            state.pending = [];            for (var j = 2; j < matches.length; j++)              if (matches[j])                state.pending.push({text: matches[j], token: rule.token[j - 1]});            stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));            return rule.token[0];          } else if (rule.token && rule.token.join) {            return rule.token[0];          } else {            return rule.token;          }        }      }      stream.next();      return null;    };  }
function cmp(a, b) {    if (a === b) return true;    if (!a || typeof a != "object" || !b || typeof b != "object") return false;    var props = 0;    for (var prop in a) if (a.hasOwnProperty(prop)) {      if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;      props++;    }    for (var prop in b) if (b.hasOwnProperty(prop)) props--;    return props == 0;  }
function enterLocalMode(config, state, spec, token) {    var pers;    if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next)      if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;    var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec);    var lState = pers ? pers.state : CodeMirror.startState(mode);    if (spec.persistent && !pers)      state.persistentStates = {mode: mode, spec: spec.spec, state: lState, next: state.persistentStates};
state.localState = lState;    state.local = {mode: mode,                   end: spec.end && toRegex(spec.end),                   endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),                   endToken: token && token.join ? token[token.length - 1] : token};  }
function indexOf(val, arr) {    for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;  }
function indentFunction(states, meta) {    return function(state, textAfter, line) {      if (state.local && state.local.mode.indent)        return state.local.mode.indent(state.localState, textAfter, line);      if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)        return CodeMirror.Pass;
var pos = state.indent.length - 1, rules = states[state.state];      scan: for (;;) {        for (var i = 0; i < rules.length; i++) {          var rule = rules[i];          if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {            var m = rule.regex.exec(textAfter);            if (m && m[0]) {              pos--;              if (rule.next || rule.push) rules = states[rule.next || rule.push];              textAfter = textAfter.slice(m[0].length);              continue scan;            }          }        }        break;      }      return pos < 0 ? 0 : state.indent[pos];    };  }
}); </script>
<script>// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
(function(mod) {
if (typeof exports == "object" && typeof module == "object") // CommonJS    mod(require("../../lib/codemirror"));  else if (typeof define == "function" && define.amd) // AMD    define(["../../lib/codemirror"], mod);  else // Plain browser env    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";  var Pos = CodeMirror.Pos;
function SearchCursor(doc, query, pos, caseFold) {    this.atOccurrence = false; this.doc = doc;    if (caseFold == null && typeof query == "string") caseFold = false;
pos = pos ? doc.clipPos(pos) : Pos(0, 0);    this.pos = {from: pos, to: pos};
// The matches method is filled in based on the type of query.    // It takes a position and a direction, and returns an object    // describing the next occurrence of the query, or null if no    // more matches were found.    if (typeof query != "string") { // Regexp match      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "ig" : "g");      this.matches = function(reverse, pos) {        if (reverse) {          query.lastIndex = 0;          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;          for (;;) {            query.lastIndex = cutOff;            var newMatch = query.exec(line);            if (!newMatch) break;            match = newMatch;            start = match.index;            cutOff = match.index + (match[0].length || 1);            if (cutOff == line.length) break;          }          var matchLen = (match && match[0].length) || 0;          if (!matchLen) {            if (start == 0 && line.length == 0) {match = undefined;}            else if (start != doc.getLine(pos.line).length) {              matchLen++;            }          }        } else {          query.lastIndex = pos.ch;          var line = doc.getLine(pos.line), match = query.exec(line);          var matchLen = (match && match[0].length) || 0;          var start = match && match.index;          if (start + matchLen != line.length && !matchLen) matchLen = 1;        }        if (match && matchLen)          return {from: Pos(pos.line, start),                  to: Pos(pos.line, start + matchLen),                  match: match};      };    } else { // String query      var origQuery = query;      if (caseFold) query = query.toLowerCase();      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};      var target = query.split("\n");      // Different methods for single-line and multi-line queries      if (target.length == 1) {        if (!query.length) {          // Empty string would match anything and never progress, so          // we define it to match nothing instead.          this.matches = function() {};        } else {          this.matches = function(reverse, pos) {            if (reverse) {              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);              var match = line.lastIndexOf(query);              if (match > -1) {                match = adjustPos(orig, line, match);                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};              }             } else {               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);               var match = line.indexOf(query);               if (match > -1) {                 match = adjustPos(orig, line, match) + pos.ch;                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};               }            }          };        }      } else {        var origTarget = origQuery.split("\n");        this.matches = function(reverse, pos) {          var last = target.length - 1;          if (reverse) {            if (pos.line - (target.length - 1) < doc.firstLine()) return;            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;            var to = Pos(pos.line, origTarget[last].length);            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)              if (target[i] != fold(doc.getLine(ln))) return;            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;            if (fold(line.slice(cut)) != target[0]) return;            return {from: Pos(ln, cut), to: to};          } else {            if (pos.line + (target.length - 1) > doc.lastLine()) return;            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;            if (fold(line.slice(cut)) != target[0]) return;            var from = Pos(pos.line, cut);            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)              if (target[i] != fold(doc.getLine(ln))) return;            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;            return {from: from, to: Pos(ln, origTarget[last].length)};          }        };      }    }  }
SearchCursor.prototype = {    findNext: function() {return this.find(false);},    findPrevious: function() {return this.find(true);},
find: function(reverse) {      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);      function savePosAndFail(line) {        var pos = Pos(line, 0);        self.pos = {from: pos, to: pos};        self.atOccurrence = false;        return false;      }
for (;;) {        if (this.pos = this.matches(reverse, pos)) {          this.atOccurrence = true;          return this.pos.match || true;        }        if (reverse) {          if (!pos.line) return savePosAndFail(0);          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);        }        else {          var maxLine = this.doc.lineCount();          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);          pos = Pos(pos.line + 1, 0);        }      }    },
from: function() {if (this.atOccurrence) return this.pos.from;},    to: function() {if (this.atOccurrence) return this.pos.to;},
replace: function(newText, origin) {      if (!this.atOccurrence) return;      var lines = CodeMirror.splitLines(newText);      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);      this.pos.to = Pos(this.pos.from.line + lines.length - 1,                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));    }  };
// Maps a position in a case-folded line back to a position in the original line  // (compensating for codepoints increasing in number during folding)  function adjustPos(orig, folded, pos) {    if (orig.length == folded.length) return pos;    for (var pos1 = Math.min(pos, orig.length);;) {      var len1 = orig.slice(0, pos1).toLowerCase().length;      if (len1 < pos) ++pos1;      else if (len1 > pos) --pos1;      else return pos1;    }  }
CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {    return new SearchCursor(this.doc, query, pos, caseFold);  });  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {    return new SearchCursor(this, query, pos, caseFold);  });
CodeMirror.defineExtension("selectMatches", function(query, caseFold) {    var ranges = [];    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);    while (cur.findNext()) {      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;      ranges.push({anchor: cur.from(), head: cur.to()});    }    if (ranges.length)      this.setSelections(ranges, 0);  });
}); </script>
<script>// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
// Define search commands. Depends on dialog.js or another // implementation of the openDialog method.
// Replace works a little oddly -- it will do the replace on the next // Ctrl-G (or whatever is bound to findNext) press. You prevent a // replace by making sure the match is no longer selected when hitting // Ctrl-G.
(function(mod) {
if (typeof exports == "object" && typeof module == "object") // CommonJS    mod(require("../../lib/codemirror"), require("./searchcursor"), require("../dialog/dialog"));  else if (typeof define == "function" && define.amd) // AMD    define(["../../lib/codemirror", "./searchcursor", "../dialog/dialog"], mod);  else // Plain browser env    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";
function searchOverlay(query, caseInsensitive) {    if (typeof query == "string")      query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");    else if (!query.global)      query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");
return {token: function(stream) {      query.lastIndex = stream.pos;      var match = query.exec(stream.string);      if (match && match.index == stream.pos) {        stream.pos += match[0].length || 1;        return "searching";      } else if (match) {        stream.pos = match.index;      } else {        stream.skipToEnd();      }    }};  }
function SearchState() {    this.posFrom = this.posTo = this.lastQuery = this.query = null;    this.overlay = null;  }
function getSearchState(cm) {    return cm.state.search || (cm.state.search = new SearchState());  }
function queryCaseInsensitive(query) {    return typeof query == "string" && query == query.toLowerCase();  }
function getSearchCursor(cm, query, pos) {    // Heuristic: if the query string is all lowercase, do a case insensitive search.    return cm.getSearchCursor(query, pos, queryCaseInsensitive(query));  }
function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {    cm.openDialog(text, onEnter, {      value: deflt,      selectValueOnOpen: true,      closeOnEnter: false,      onClose: function() { clearSearch(cm); },      onKeyDown: onKeyDown    });  }
function dialog(cm, text, shortText, deflt, f) {    if (cm.openDialog) cm.openDialog(text, f, {value: deflt, selectValueOnOpen: true});    else f(prompt(shortText, deflt));  }
function confirmDialog(cm, text, shortText, fs) {    if (cm.openConfirm) cm.openConfirm(text, fs);    else if (confirm(shortText)) fs[0]();  }
function parseString(string) {    return string.replace(/\\(.)/g, function(_, ch) {      if (ch == "n") return "\n"      if (ch == "r") return "\r"      return ch    })  }
function parseQuery(query) {    var isRE = query.match(/^\/(.*)\/([a-z]*)$/);    if (isRE) {      try { query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i"); }      catch(e) {} // Not a regular expression after all, do a string search } else {      query = parseString(query)    }    if (typeof query == "string" ? query == "" : query.test(""))      query = /x^/;    return query;  }
var queryDialog =    'Search: <input type="text" style="width: 10em" class="CodeMirror-search-field"/> (Use /re/ syntax for regexp search)';
function startSearch(cm, state, query) {    state.queryText = query;    state.query = parseQuery(query);    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));    cm.addOverlay(state.overlay);    if (cm.showMatchesOnScrollbar) {      if (state.annotate) { state.annotate.clear(); state.annotate = null; }      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));    }  }
function doSearch(cm, rev, persistent, immediate) {    var state = getSearchState(cm);    if (state.query) return findNext(cm, rev);    var q = cm.getSelection() || state.lastQuery;    if (persistent && cm.openDialog) {      var hiding = null      var searchNext = function(query, event) {        CodeMirror.e_stop(event);        if (!query) return;        if (query != state.queryText) {          startSearch(cm, state, query);          state.posFrom = state.posTo = cm.getCursor();        }        if (hiding) hiding.style.opacity = 1        findNext(cm, event.shiftKey, function(_, to) {          var dialog          if (to.line < 3 && document.querySelector && (dialog = cm.display.wrapper.querySelector(".CodeMirror-dialog")) && dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top)            (hiding = dialog).style.opacity = .4        })      };      persistentDialog(cm, queryDialog, q, searchNext, function(event, query) {        var keyName = CodeMirror.keyName(event)        var cmd = CodeMirror.keyMap[cm.getOption("keyMap")][keyName]        if (!cmd) cmd = cm.getOption('extraKeys')[keyName]        if (cmd == "findNext" || cmd == "findPrev" ||          cmd == "findPersistentNext" || cmd == "findPersistentPrev") {          CodeMirror.e_stop(event);          startSearch(cm, getSearchState(cm), query);          cm.execCommand(cmd);        } else if (cmd == "find" || cmd == "findPersistent") {          CodeMirror.e_stop(event);          searchNext(query, event);        }      });      if (immediate && q) {        startSearch(cm, state, q);        findNext(cm, rev);      }    } else {      dialog(cm, queryDialog, "Search for:", q, function(query) {        if (query && !state.query) cm.operation(function() {          startSearch(cm, state, query);          state.posFrom = state.posTo = cm.getCursor();          findNext(cm, rev);        });      });    }  }
function findNext(cm, rev, callback) {cm.operation(function() {    var state = getSearchState(cm);    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);    if (!cursor.find(rev)) {      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));      if (!cursor.find(rev)) return;    }    cm.setSelection(cursor.from(), cursor.to());    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);    state.posFrom = cursor.from(); state.posTo = cursor.to();    if (callback) callback(cursor.from(), cursor.to())  });}
function clearSearch(cm) {cm.operation(function() {    var state = getSearchState(cm);    state.lastQuery = state.query;    if (!state.query) return;    state.query = state.queryText = null;    cm.removeOverlay(state.overlay);    if (state.annotate) { state.annotate.clear(); state.annotate = null; }  });}
var replaceQueryDialog =    ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> (Use /re/ syntax for regexp search)';  var replacementQueryDialog = 'With: <input type="text" style="width: 10em" class="CodeMirror-search-field"/>';  var doReplaceConfirm = "Replace? <button>Yes</button> <button>No</button> <button>All</button> <button>Stop</button>";
function replaceAll(cm, query, text) {    cm.operation(function() {      for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {        if (typeof query != "string") {          var match = cm.getRange(cursor.from(), cursor.to()).match(query);          cursor.replace(text.replace(/\$(\d)/g, function(_, i) {return match[i];}));        } else cursor.replace(text);      }    });  }
function replace(cm, all) {    if (cm.getOption("readOnly")) return;    var query = cm.getSelection() || getSearchState(cm).lastQuery;    var dialogText = all ? "Replace all:" : "Replace:"    dialog(cm, dialogText + replaceQueryDialog, dialogText, query, function(query) {      if (!query) return;      query = parseQuery(query);      dialog(cm, replacementQueryDialog, "Replace with:", "", function(text) {        text = parseString(text)        if (all) {          replaceAll(cm, query, text)        } else {          clearSearch(cm);          var cursor = getSearchCursor(cm, query, cm.getCursor("from"));          var advance = function() {            var start = cursor.from(), match;            if (!(match = cursor.findNext())) {              cursor = getSearchCursor(cm, query);              if (!(match = cursor.findNext()) ||                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;            }            cm.setSelection(cursor.from(), cursor.to());            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});            confirmDialog(cm, doReplaceConfirm, "Replace?",                          [function() {doReplace(match);}, advance,                           function() {replaceAll(cm, query, text)}]);          };          var doReplace = function(match) {            cursor.replace(typeof query == "string" ? text :                           text.replace(/\$(\d)/g, function(_, i) {return match[i];}));            advance();          };          advance();        }      });    });  }
CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};  CodeMirror.commands.findPersistent = function(cm) {clearSearch(cm); doSearch(cm, false, true);};  CodeMirror.commands.findPersistentNext = function(cm) {doSearch(cm, false, true, true);};  CodeMirror.commands.findPersistentPrev = function(cm) {doSearch(cm, true, true, true);};  CodeMirror.commands.findNext = doSearch;  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};  CodeMirror.commands.clearSearch = clearSearch;  CodeMirror.commands.replace = replace;  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};
}); </script>
<script>(function(){'use strict';
var c,aa="object"===typeof __ScalaJSEnv&&__ScalaJSEnv?__ScalaJSEnv:{},ba="object"===typeof aa.global&&aa.global?aa.global:"object"===typeof global&&global&&global.Object===Object?global:this;aa.global=ba;var ca="object"===typeof aa.exportsNamespace&&aa.exportsNamespace?aa.exportsNamespace:ba;aa.exportsNamespace=ca;ba.Object.freeze(aa);var aaa={envInfo:aa,semantics:{asInstanceOfs:2,arrayIndexOutOfBounds:2,moduleInit:2,strictFloats:!1,productionMode:!0},assumingES6:!1,linkerVersion:"0.6.18",globalThis:this}; ba.Object.freeze(aaa);ba.Object.freeze(aaa.semantics);var da=ba.Math.imul||function(a,b){var d=a&65535,e=b&65535;return d*e+((a>>>16&65535)*e+d*(b>>>16&65535)<<16>>>0)|0},ea=ba.Math.fround||function(a){return+a},fa=ba.Math.clz32||function(a){if(0===a)return 32;var b=1;0===(a&4294901760)&&(a<<=16,b+=16);0===(a&4278190080)&&(a<<=8,b+=8);0===(a&4026531840)&&(a<<=4,b+=4);0===(a&3221225472)&&(a<<=2,b+=2);return b+(a>>31)},ha=0,ia=ba.WeakMap?new ba.WeakMap:null; function ja(a){return function(b,d){return!(!b||!b.$classData||b.$classData.Br!==d||b.$classData.Ar!==a)}}function baa(a){for(var b in a)return b}function ka(a,b){return new a.xC(b)}function la(a,b){return caa(a,b,0)}function caa(a,b,d){var e=new a.xC(b[d]);if(d<b.length-1){a=a.It;d+=1;for(var f=e.l,h=0;h<f.length;h++)f[h]=caa(a,b,d)}return e}function na(a){return void 0===a?"undefined":a.toString()} function oa(a){switch(typeof a){case "string":return pa(qa);case "number":var b=a|0;return b===a?ra(b)?pa(sa):ta(b)?pa(ua):pa(wa):xa(a)?pa(ya):pa(za);case "boolean":return pa(Aa);case "undefined":return pa(Ba);default:return null===a?a.boa():Ca(a)?pa(Da):a&&a.$classData?pa(a.$classData):null}}function Ea(a,b){return a&&a.$classData||null===a?a.o(b):"number"===typeof a?"number"===typeof b&&(a===b?0!==a||1/a===1/b:a!==a&&b!==b):a===b} function Ga(a){switch(typeof a){case "string":return Ha(Ia(),a);case "number":return daa(Ja(),a);case "boolean":return a?1231:1237;case "undefined":return 0;default:return a&&a.$classData||null===a?a.r():null===ia?42:Ka(a)}}function La(a){return"string"===typeof a?a.length|0:a.sa()}function Ma(a,b,d){return"string"===typeof a?a.substring(b,d):a.xv(b,d)}function Na(a){return 2147483647<a?2147483647:-2147483648>a?-2147483648:a|0} function eaa(a,b){var d=ba.Object.getPrototypeOf,e=ba.Object.getOwnPropertyDescriptor;for(a=d(a);null!==a;){var f=e(a,b);if(void 0!==f)return f;a=d(a)}}function faa(a,b,d){a=eaa(a,d);if(void 0!==a)return d=a.get,void 0!==d?d.call(b):a.value}function gaa(a,b,d,e){a=eaa(a,d);if(void 0!==a&&(a=a.set,void 0!==a)){a.call(b,e);return}throw new ba.TypeError("super has no setter '"+d+"'.");} function Oa(a,b,d,e,f){a=a.l;d=d.l;if(a!==d||e<b||(b+f|0)<e)for(var h=0;h<f;h=h+1|0)d[e+h|0]=a[b+h|0];else for(h=f-1|0;0<=h;h=h-1|0)d[e+h|0]=a[b+h|0]} var Ka=null!==ia?function(a){switch(typeof a){case "string":case "number":case "boolean":case "undefined":return Ga(a);default:if(null===a)return 0;var b=ia.get(a);void 0===b&&(ha=b=ha+1|0,ia.set(a,b));return b}}:function(a){if(a&&a.$classData){var b=a.$idHashCode$0;if(void 0!==b)return b;if(ba.Object.isSealed(a))return 42;ha=b=ha+1|0;return a.$idHashCode$0=b}return null===a?0:Ga(a)};function ra(a){return"number"===typeof a&&a<<24>>24===a&&1/a!==1/-0} function ta(a){return"number"===typeof a&&a<<16>>16===a&&1/a!==1/-0}function Pa(a){return"number"===typeof a&&(a|0)===a&&1/a!==1/-0}function xa(a){return"number"===typeof a}function Qa(a){return null===a?Ra().Bp:a}function Sa(){this.Xx=this.xC=void 0;this.Ar=this.It=this.n=null;this.Br=0;this.Vy=null;this.Tw="";this.wk=this.Kw=this.Lw=void 0;this.name="";this.isRawJSType=this.isArrayClass=this.isInterface=this.isPrimitive=!1;this.isInstance=void 0} function Ta(a,b,d){var e=new Sa;e.n={};e.It=null;e.Vy=a;e.Tw=b;e.wk=function(){return!1};e.name=d;e.isPrimitive=!0;e.isInstance=function(){return!1};return e}function g(a,b,d,e,f,h,k,p){var t=new Sa,x=baa(a);k=k||function(a){return!!(a&&a.$classData&&a.$classData.n[x])};p=p||function(a,b){return!!(a&&a.$classData&&a.$classData.Br===b&&a.$classData.Ar.n[x])};t.Xx=h;t.n=e;t.Tw="L"+d+";";t.wk=p;t.name=d;t.isInterface=b;t.isRawJSType=!!f;t.isInstance=k;return t} function haa(a){function b(a){if("number"===typeof a){this.l=Array(a);for(var b=0;b<a;b++)this.l[b]=f}else this.l=a}var d=new Sa,e=a.Vy,f="longZero"==e?Ra().Bp:e;b.prototype=new l;b.prototype.constructor=b;b.prototype.MS=function(){return this.l instanceof Array?new b(this.l.slice(0)):new b(new this.l.constructor(this.l))};b.prototype.$classData=d;var e="["+a.Tw,h=a.Ar||a,k=a.Br+1;d.xC=b;d.Xx=Ua;d.n={d:1,Te:1,i:1};d.It=a;d.Ar=h;d.Br=k;d.Vy=null;d.Tw=e;d.Lw=void 0;d.Kw=void 0;d.wk=void 0;d.name=e; d.isPrimitive=!1;d.isInterface=!1;d.isArrayClass=!0;d.isInstance=function(a){return h.wk(a,k)};return d}function pa(a){if(!a.Lw){var b=new Wa;b.ti=a;a.Lw=b}return a.Lw}function Xa(a){a.Kw||(a.Kw=haa(a));return a.Kw}Sa.prototype.getFakeInstance=function(){return this===qa?"some string":this===Aa?!1:this===sa||this===ua||this===wa||this===ya||this===za?0:this===Da?Ra().Bp:this===Ba?void 0:{$classData:this}};Sa.prototype.getSuperclass=function(){return this.Xx?pa(this.Xx):null}; Sa.prototype.getComponentType=function(){return this.It?pa(this.It):null};Sa.prototype.newArrayOfThisClass=function(a){for(var b=this,d=0;d<a.length;d++)b=Xa(b);return la(b,a)};var Ya=Ta(void 0,"V","void"),Za=Ta(!1,"Z","boolean"),ab=Ta(0,"C","char"),bb=Ta(0,"B","byte"),cb=Ta(0,"S","short"),db=Ta(0,"I","int"),eb=Ta("longZero","J","long"),fb=Ta(0,"F","float"),gb=Ta(0,"D","double"),hb=ja(Za);Za.wk=hb;var ib=ja(ab);ab.wk=ib;var jb=ja(bb);bb.wk=jb;var kb=ja(cb);cb.wk=kb;var lb=ja(db);db.wk=lb;var mb=ja(eb); eb.wk=mb;var nb=ja(fb);fb.wk=nb;var ob=ja(gb);gb.wk=ob;function iaa(a,b){return m(new n,function(a,b){return function(f){return a.y(b.y(f))}}(a,b))}function qb(a,b){return m(new n,function(a,b){return function(f){return b.y(a.y(f))}}(a,b))}function jaa(a){return m(new n,function(a){return function(d){if(null!==d)return rb(a,d.la(),d.pa());throw(new q).j(d);}}(a))}function sb(a){return m(new n,function(a){return function(d){return m(new n,function(a,b){return function(d){return rb(a,b,d)}}(a,d))}}(a))} function kaa(a,b,d){return b.za.Gb(d,tb(new ub,function(a){return function(b,d){return wb(a,d,b)}}(a)))}function wb(a,b,d){if(xb(b))return laa(a,b,d);if(yb(b))return maa(a,b.fe,d);if(zb(b))return laa(a,b.Sk,d);throw(new q).j(b);}function maa(a,b,d){return b.Zf.Gb(d,tb(new ub,function(a){return function(b,d){return kaa(a,d,b)}}(a)))}function naa(a,b,d){return b.za.Gb(d,tb(new ub,function(a){return function(b,d){return wb(a,d,b)}}(a)))} function Ab(a,b){if(xb(b))return a.Cg(b);if(yb(b))return a=oaa(a,b.fe),Bb(new Cb,a,b.ra,b.qj);if(zb(b))return a=a.Cg(b.Sk),Db(new Eb,a,b.ra);throw(new q).j(b);}function oaa(a,b){var d=b.Zf;a=m(new n,function(a){return function(b){return a.vh(b)}}(a));var e=r(),d=d.xa(a,e.s);return(new Fb).ns(b.Yr,d,b.oe)}function Gb(a,b){var d=b.za;a=m(new n,function(a){return function(b){return Ab(a,b)}}(a));var e=r(),d=d.xa(a,e.s);return(new Hb).cj(b.xd,d,b.ra)} function Jb(a,b){var d=b.za;a=m(new n,function(a){return function(b){return Ab(a,b)}}(a));var e=r(),d=d.xa(a,e.s);return(new Kb).Qf(b.pe,d,b.ra)}function Lb(a,b){a=oaa(a,b.fe);return Mb(b.ji,a,b.bz)}function paa(a,b){b.za.wa(m(new n,function(a){return function(b){Nb(a,b)}}(a)))}function Ob(a,b){b.Zf.wa(m(new n,function(a){return function(b){a.MY(b)}}(a)))}function qaa(a,b){b.za.wa(m(new n,function(a){return function(b){Nb(a,b)}}(a)))} function Nb(a,b){if(xb(b))a.VF(b);else if(yb(b))Ob(a,b.fe);else if(zb(b))a.VF(b.Sk);else throw(new q).j(b);}function raa(a,b){return-1!==(a.Ld.indexOf("\x3cBREED\x3e")|0)?b.Bf:b.va}function Pb(a){var b=Qb(Ia(),Qb(Ia(),a.Ld,"\\?","\\\\?"),saa(Rb()),"(.+)"),b=u((new v).K((new w).f(["^","$"])),(new w).f([b])),b=(new Sb).c(b),d=y();a.Ux((new Tb).Ro(b.R,d))} function taa(a,b){var d=(new Ub).mD((new Vb).ia(1E8,0)),e=(new Wb).tk(0),f=uaa(a);Xb(new Yb,f,m(new n,function(){return function(a){return null!==a}}(a))).wa(m(new n,function(a,b,d,e){return function(a){if(null!==a){var f=+a.pa(),h;h=Na(+a.la());var U=255&b>>16,ga=255&h>>16;a=U+(ga/2|0)|0;U=U-ga|0;ga=(255&b>>8)-(255&h>>8)|0;h=(255&b)-(255&h)|0;a=((da(da(512+a|0,U),U)>>8)+da(ga<<2,ga)|0)+(da(da(767-a|0,h),h)>>8)|0;h=(new Vb).ia(a,a>>31);a=h.ka;h=h.qa;U=d.Ba;ga=U.qa;if(h===ga?(-2147483648^a)<(-2147483648^ U.ka):h<ga)d.Ba=(new Vb).ia(a,h),e.Ba=f}else throw(new q).j(a);}}(a,b,d,e)));return e.Ba}function vaa(a){var b=Zb,d=uaa(b).dc(a);return+(d.z()?taa(b,a):d.Y())}function $b(a,b,d,e){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Dump.scala: 56");return a.wT.y((new ac).ae(b,d,e))}function waa(a,b,d,e){a=(new bc).Gf(b,m(new n,function(a,b,d){return function(e){return $b(a,e,b,d)}}(a,d,e)));return cc(a,"["," ","]")} function xaa(a,b,d,e,f,h,k,p){var t=[(new A).e("",b)];b=dc(new ec,gc());for(var x=0,E=t.length|0;x<E;)hc(b,t[x]),x=1+x|0;t=yaa;x=new ic;x.Rs=b.Ma;x.hh=k;x.Fr=p;x.Mr=e;x.un=h;x.Hk=f;x.Um=d;return t(a,x)} function zaa(a){B();for(var b=Aaa(a).Ga(),d=(new jc).b(),e=0;e<b;){var f=lc();mc(d,f);e=1+e|0}b=d.ub();if(a.$u.jn){a=lc();d=C();D();e=nc();D();f=F();D();var h=F();D();D();D();var k=F();D();return G(new H,d,e,b,a,f,h,!1,"OTPL",k,k.ba(),!0)}return oc(D(),b,(D(),F()),(D(),F()),(D(),"OTPL"),(D(),F()),(D(),!1),(D(),!0))}function Baa(a){a.M("OTPL");Caa(a,I(pc().Th,y()));a.a=(32|a.a)<<24>>24}function qc(a){return!!(a&&a.$classData&&a.$classData.n.uJ)} function Daa(a,b,d,e,f){var h=a.ep.y(f.me());b=rc(b,sc(f),tc());uc();h=h.Oa();vc||(vc=(new wc).b());var h=xc(0,h,vc),k=new yc;d=zc(d,a.ce);k.ec=a.ec;k.ce=d;k.ji=f;k.hh=e;Eaa(k);a=xc(uc(),h,k);Ac||(Ac=(new Cc).b());e=Ac;a=a.Om();d=Dc();for(h=I(Ec(),y());;)if(k=a.$().jb,null===k||k!==d){b=Fc(e,a,!1,b);if(null===b)throw(new q).j(b);k=b.la();b=b.pa();h.uj(k)}else break;b=h.Hc();e=a.$();b=(new Fb).ns(e.Lc().ab,b,!1);a=2147483647!==a.$().Lc().Va?a.$().Lc().Xa:b.Lc().Va;return Mb(f,b,a)} function Faa(a,b){a=Gaa(Gc(),Hc(a),b);for(var d=Haa(Gc(),a.ec,zc(b.un,a.ce)),e=a.ce,f=Ic(b.un),e=Jc(e,f),f=(new Kc).fg(e),e=Lc().s,e=Mc(f,e),f=f.oi.rj();f.ta();){var h=f.ma();e.Na(Daa(a,d,b.un,b.hh,h))}b=e.Da().Hc();return(new A).e(b,a)}function Iaa(a,b,d,e){b=b.za;var f=r();return b.sj(f.s).Gb(e,tb(new ub,function(a,b){return function(d,e){d=(new A).e(d,e);e=d.kb;var f=d.Ab;if(null!==f)return Nc(a,f.la(),b,f.Dc(),e);throw(new q).j(d);}}(a,d)))} function Oc(a,b,d,e){b=b.za;var f=r();return b.sj(f.s).Gb(e,tb(new ub,function(a,b){return function(d,e){d=(new A).e(d,e);e=d.kb;var f=d.Ab;if(null!==f)return Nc(a,f.la(),b,f.Dc(),e);throw(new q).j(d);}}(a,d)))} function Jaa(a,b,d,e){b=b.Zf;var f=r();return b.sj(f.s).Gb(e,tb(new ub,function(a,b){return function(d,e){e=(new A).e(d,e);d=e.kb;var f=e.Ab;if(null!==f){e=f.la();f=Pc(b,(new Qc).Db(f.Dc()));var E=d.Uj.dc(f);E.z()?E=F():(E=E.Y(),E=(new J).j(Rc(E,a,e,f,d)));E.z()?(E=Sc(d.pf,f),E=Tc(Uc(d),""+E+d.am.y(e.xd)),e=Iaa(a,e,f,E),d=Vc(new Wc,e.Wb,e.Uj,d.am,e.pf)):d=E.Y();return d}throw(new q).j(e);}}(a,d)))} function Nc(a,b,d,e,f){if(xb(b))return d=Pc(d,(new Xc).Db(e)),Yc(a,b,d,f);if(yb(b)){d=Pc(d,(new Zc).Db(e));if(b.qj&&b.fe.Zf.z())f=Tc(Uc(f),Sc(f.pf,d));else if(b.qj)e=f.Uj.dc(d),e.z()?e=F():(e=e.Y(),e=(new J).j(Rc(e,a,b,d,Tc(Uc(f),Sc(f.pf,d))))),e.z()?(e=Tc(Uc(f),Sc(f.pf,d)),a=Jaa(a,b.fe,d,e),f=Tc(Uc(a),$c(f.pf,d))):f=e.Y();else{var h=Kaa(a);e=Laa(a);var k=f.Uj.dc(d);k.z()?k=F():(k=k.Y(),k=(new J).j(Rc(k,a,b,d,Tc(Uc(f),Sc(f.pf,d)))));k.z()?(h=Tc(Uc(f),h.y(f.pf).y(d)),a=Jaa(a,b.fe,d,h),f=Tc(Uc(a),e.y(f.pf).y(d))): f=k.Y()}return f}if(zb(b))return d=Pc(d,(new ad).Db(e)),h=Kaa(a),e=Laa(a),k=f.Uj.dc(d),k.z()?k=F():(k=k.Y(),k=(new J).j(Rc(k,a,b,d,Tc(Uc(f),Sc(f.pf,d))))),k.z()?(h=Tc(Uc(f),h.y(f.pf).y(d)),b=b.Sk,k=Pc(d,(new Xc).Db(0)),a=Yc(a,b,k,h),f=Tc(Uc(a),e.y(f.pf).y(d))):f=k.Y(),f;throw(new q).j(b);} function Maa(a,b,d,e,f){bd(a);d=cd(d,"run");var h=f.cp;a=m(new n,function(a,b){return function(a){return u((new v).K((new w).f(["",'Vars["','"] \x3d ',";"])),(new w).f([b,a,a]))}}(a,d));var k=r(),h=h.xa(a,k.s).zb("\n");!b&&f.lq?(a=u((new v).K((new w).f(["var "," \x3d "])),(new w).f([d])),f=u((new v).K((new w).f(["if(reporterContext \x26\x26 "," !\x3d\x3d undefined) { return ","; }"])),(new w).f([d,d]))):f=a="";b=u((new v).K((new w).f(["|","Prims.runCode(\n        |  ",",\n        |  (function() {\n        |    let ", "Vars \x3d { }; for(var v in letVars) { ","Vars[v] \x3d letVars[v]; }\n        |    ","\n        |    return ","Vars;\n        |  })(),\n        |  ","\n        |)\n        |","\n        |"])),(new w).f([a,b,d,d,h,d,e.zb(", "),f]));b=(new Sb).c(b);return dd(b)}function Naa(a){return u((new v).K((new w).f(["notImplemented(",", undefined)"])),(new w).f([ed(fd(),a)]))}function gd(a,b){throw(new hd).ms(a,b.ra.Xa,b.ra.Va,b.ra.ab);} function id(a){a=jd().Uc(a);if(a.z())var b=!0;else b=a.Y(),b=(new Sb).c(b),b=kd(b);a=b?a:F();return a.z()?"LINKS":a.Y()}function Oaa(a,b){ld();return md(new nd,Paa(b)).Uc(a)}function od(a){return pd(qd(),rd(qd(),a))}function sd(a,b){return a.Mk(b).KT(m(new n,function(){return function(a){throw(new td).K(a);}}(a)),m(new n,function(){return function(a){return a}}(a)))}var Qaa=g({ft:0},!0,"sbt.testing.Fingerprint",{ft:1});function ud(a){return!!(a&&a.$classData&&a.$classData.n.i7)} var Raa=g({yB:0},!0,"sbt.testing.Logger",{yB:1}),vd=g({VQ:0},!0,"sbt.testing.Task",{VQ:1});function wd(a){a.Js(Saa(a))}function xd(a){a.kp(Taa(a))}function yd(a){a.ov(Uaa(a))}function zd(a){a.Vf(Vaa(a))}function Ad(a,b){return Bd(a.Hg(b,y(),tb(new ub,function(){return function(a,b){return Cd(new Dd,b,a)}}(a))))}function Ed(a){a.Hi(Waa(a))} function Xaa(a,b,d,e){return a.Hg(b,e.vd(K(function(){return function(){}}(a))),tb(new ub,function(a,b,d){return function(e,t){return d.$e(K(function(a,b,d){return function(){return b.y(d)}}(a,b,t)),K(function(a,b,d){return function(){return b.Xc(d,m(new n,function(a){return function(){return m(new n,function(){return function(){}}(a))}}(a)))}}(a,d,e)))}}(a,d,e)))} function Fd(a,b,d,e){e=m(new n,function(a,b){return function(a){Gd();var d=Yaa;Hd||(Hd=(new Id).b());d=d(Hd,b);a=sb(d).y(a);return(new Jd).cn(a)}}(a,e));Zaa||(Zaa=(new Kd).b());var f=Gd(),f=(new Ld).yD(f);return a.Zh(b,e,$aa(f)).Cq.y(d)}function Md(a){a.ig(aba(a))}function Nd(a){a.Jq(bba(a))}function Od(a){a.ff(cba(a))}function Pd(a,b){var d=Qd();a=[Rd(Qd(),a.Xg(b))];b=a.length|0;var e=0,f=Sd((new Td).dj(d.Pq));a:for(;;){if(e!==b){d=1+e|0;f=Ud(f,a[e]);e=d;continue a}return f}} function Vd(a){a.Tg(dba(a))}function Wd(a){a.Gn(eba(a))}function Xd(a){a.Hn(fba(a))}function gba(a){a.cX((new Yd).Sd(a));a.QW((new Zd).Sd(a));a.PW((new $d).Sd(a));a.RW((new be).Sd(a));a.SW((new ce).Sd(a));a.TW((new de).Sd(a));a.UW((new ee).Sd(a));a.aX((new fe).Sd(a));a.bX((new ge).Sd(a));a.XW((new he).Sd(a));a.YW((new ie).Sd(a));a.ZW((new je).Sd(a));a.$W((new ke).Sd(a));a.WW((new le).Sd(a));a.VW((new me).Sd(a))}function hba(a){a.fX((new ne).HD(a));a.gX((new oe).HD(a))} function iba(a,b){var d=new pe;qe||(qe=(new re).b());return jba(d,((new se).b(),a),b.XB)}function te(){}function l(){}l.prototype=te.prototype;te.prototype.b=function(){return this};te.prototype.o=function(a){return this===a};te.prototype.k=function(){var a=oa(this).kh(),b=(+(this.r()>>>0)).toString(16);return a+"@"+b};te.prototype.r=function(){return Ka(this)};te.prototype.toString=function(){return this.k()}; function ve(a,b){if(a=a&&a.$classData){var d=a.Br||0;return!(d<b)&&(d>b||!a.Ar.isPrimitive)}return!1}var Ua=g({d:0},!1,"java.lang.Object",{d:1},void 0,void 0,function(a){return null!==a},ve);te.prototype.$classData=Ua;function kba(a,b){b!==a&&b.ap(m(new n,function(a){return function(b){return a.Lv(b)}}(a)),we());return a}function xe(a,b){if(a.Lv(b))return a;throw(new ye).c("Promise already completed.");} function lba(a,b){if(ze(b))return b=null===b?0:b.X,a.VD()&&a.wi()===b;if(ra(b))return b|=0,a.UD()&&a.Zw()===b;if(ta(b))return b|=0,a.WD()&&a.vy()===b;if(Pa(b))return b|=0,a.Eu()&&a.wi()===b;if(Ca(b)){var d=Qa(b);b=d.ka;d=d.qa;a=a.gj();var e=a.qa;return a.ka===b&&e===d}return xa(b)?(b=+b,a.Op()===b):"number"===typeof b?(b=+b,a.Lj()===b):!1}function mba(a,b){a.LE=b;return a}function nba(a,b){return 0<=a.Sq(b)?na(Ma(a.wF(),a.Sq(b),a.Wt(b))):null} function oba(a,b){return(new Ae).el(a,m(new n,function(a,b){return function(f){return Be(new Ce,a,b,f)}}(a,b)))}function De(a,b){return(new Ae).el(a,m(new n,function(a,b){return function(f){f=Ee(b).si(f);if(Fe(f)||Ge(f))return f;if(He(f))return(new Ie).en(a,f.Bk,f.be);throw(new q).j(f);}}(a,b)))}function Je(a,b){return(new Ae).el(a,m(new n,function(a,b){return function(f){return(new Ke).en(a,b,f)}}(a,b)))} function Le(a,b,d){return(new Ae).el(a,m(new n,function(a,b,d){return function(k){var p;if(k.ym.z())p=(new Ke).en(a,"end of input",k);else if(d.Ua(k.ym.$())){p=new Ce;var t=d.y(k.ym.$());k=pba(new Me,k.ym.aa(),k.ZC);p=Be(p,a,t,k)}else p=(new Ke).en(a,b+" expected",k);return p}}(a,b,d)))} function qba(a,b,d){return(new Ae).el(a,m(new n,function(a,b,d){return function(k){var p=(new Ne).b(),t=(new jc).b(),x=Ee(b).si(k);if(Fe(x)){k=x.be;mc(t,x.mm);if(p.La)p=p.hb;else{if(null===p)throw(new Oe).b();p=p.La?p.hb:Pe(p,Ee(d))}a:for(;;)if(x=p.si(k),Fe(x))k=x,x=k.be,mc(t,k.mm),k=x;else{t=Ge(x)?x:Be(new Ce,a,t.ub(),k);break a}return t}if(x&&x.$classData&&x.$classData.n.JE)return x;throw(new q).j(x);}}(a,b,d)))} function Qe(a,b){return Re(qba(a,b,b),K(function(a){return function(){var b=y();return oba(a,b)}}(a)))}function rba(a,b){var d=a.Sa;a=Se(Ue(a,m(new n,function(a,b){return function(d){return Ve(De(a.Sa,b),m(new n,function(a,b){return function(d){return We(a.Sa,b,d)}}(a,d)))}}(a,b))),"~");return(new Xe).el(d,a)} function sba(a){var b=(new Sb).c("");a=-1+a.sc|0;b=Ye(Ze(),b.R,0,a);b=(new Sb).c(b);a=$e().zp;a=Mc(b,a);for(var d=0,e=b.R.length|0;d<e;){var f=b.W(d),f=null===f?0:f.X;a.Na((new af).Ra(9===f?f:32));d=1+d|0}return"\n"+a.Da()+"^"}function bf(a,b){b.wa(m(new n,function(a){return function(b){return a.zm(b)}}(a)));return a}function Jc(a,b){var d=a.Tf();return b.mb().qf(d,tb(new ub,function(){return function(a,b){return a.ue(b)}}(a)))} function cf(a){var b=la(Xa(Ua),[a.l.length]);Oa(a,0,b,0,a.l.length);return b} function tba(a,b,d){if(32>d)return a.ye().l[31&b];if(1024>d)return a.wb().l[31&(b>>>5|0)].l[31&b];if(32768>d)return a.Kb().l[31&(b>>>10|0)].l[31&(b>>>5|0)].l[31&b];if(1048576>d)return a.kc().l[31&(b>>>15|0)].l[31&(b>>>10|0)].l[31&(b>>>5|0)].l[31&b];if(33554432>d)return a.rd().l[31&(b>>>20|0)].l[31&(b>>>15|0)].l[31&(b>>>10|0)].l[31&(b>>>5|0)].l[31&b];if(1073741824>d)return a.Eh().l[31&(b>>>25|0)].l[31&(b>>>20|0)].l[31&(b>>>15|0)].l[31&(b>>>10|0)].l[31&(b>>>5|0)].l[31&b];throw(new df).b();} function uba(a,b,d,e){if(32<=e)if(1024>e)1===a.uf()&&(a.nc(la(Xa(Ua),[32])),a.wb().l[31&(b>>>5|0)]=a.ye(),a.Ij(1+a.uf()|0)),a.Nc(la(Xa(Ua),[32]));else if(32768>e)2===a.uf()&&(a.Vc(la(Xa(Ua),[32])),a.Kb().l[31&(b>>>10|0)]=a.wb(),a.Ij(1+a.uf()|0)),a.nc(a.Kb().l[31&(d>>>10|0)]),null===a.wb()&&a.nc(la(Xa(Ua),[32])),a.Nc(la(Xa(Ua),[32]));else if(1048576>e)3===a.uf()&&(a.ze(la(Xa(Ua),[32])),a.kc().l[31&(b>>>15|0)]=a.Kb(),a.Ij(1+a.uf()|0)),a.Vc(a.kc().l[31&(d>>>15|0)]),null===a.Kb()&&a.Vc(la(Xa(Ua),[32])), a.nc(a.Kb().l[31&(d>>>10|0)]),null===a.wb()&&a.nc(la(Xa(Ua),[32])),a.Nc(la(Xa(Ua),[32]));else if(33554432>e)4===a.uf()&&(a.fh(la(Xa(Ua),[32])),a.rd().l[31&(b>>>20|0)]=a.kc(),a.Ij(1+a.uf()|0)),a.ze(a.rd().l[31&(d>>>20|0)]),null===a.kc()&&a.ze(la(Xa(Ua),[32])),a.Vc(a.kc().l[31&(d>>>15|0)]),null===a.Kb()&&a.Vc(la(Xa(Ua),[32])),a.nc(a.Kb().l[31&(d>>>10|0)]),null===a.wb()&&a.nc(la(Xa(Ua),[32])),a.Nc(la(Xa(Ua),[32]));else if(1073741824>e)5===a.uf()&&(a.Ao(la(Xa(Ua),[32])),a.Eh().l[31&(b>>>25|0)]=a.rd(), a.Ij(1+a.uf()|0)),a.fh(a.Eh().l[31&(d>>>25|0)]),null===a.rd()&&a.fh(la(Xa(Ua),[32])),a.ze(a.rd().l[31&(d>>>20|0)]),null===a.kc()&&a.ze(la(Xa(Ua),[32])),a.Vc(a.kc().l[31&(d>>>15|0)]),null===a.Kb()&&a.Vc(la(Xa(Ua),[32])),a.nc(a.Kb().l[31&(d>>>10|0)]),null===a.wb()&&a.nc(la(Xa(Ua),[32])),a.Nc(la(Xa(Ua),[32]));else throw(new df).b();}function ef(a,b,d){var e=la(Xa(Ua),[32]);Oa(a,b,e,d,32-(d>b?d:b)|0);return e} function vba(a,b,d){if(32<=d)if(1024>d)a.Nc(a.wb().l[31&(b>>>5|0)]);else if(32768>d)a.nc(a.Kb().l[31&(b>>>10|0)]),a.Nc(a.wb().l[31&(b>>>5|0)]);else if(1048576>d)a.Vc(a.kc().l[31&(b>>>15|0)]),a.nc(a.Kb().l[31&(b>>>10|0)]),a.Nc(a.wb().l[31&(b>>>5|0)]);else if(33554432>d)a.ze(a.rd().l[31&(b>>>20|0)]),a.Vc(a.kc().l[31&(b>>>15|0)]),a.nc(a.Kb().l[31&(b>>>10|0)]),a.Nc(a.wb().l[31&(b>>>5|0)]);else if(1073741824>d)a.fh(a.Eh().l[31&(b>>>25|0)]),a.ze(a.rd().l[31&(b>>>20|0)]),a.Vc(a.kc().l[31&(b>>>15|0)]),a.nc(a.Kb().l[31& (b>>>10|0)]),a.Nc(a.wb().l[31&(b>>>5|0)]);else throw(new df).b();} function wba(a,b){var d=-1+a.uf()|0;switch(d){case 5:a.Ao(cf(a.Eh()));a.fh(cf(a.rd()));a.ze(cf(a.kc()));a.Vc(cf(a.Kb()));a.nc(cf(a.wb()));a.Eh().l[31&(b>>>25|0)]=a.rd();a.rd().l[31&(b>>>20|0)]=a.kc();a.kc().l[31&(b>>>15|0)]=a.Kb();a.Kb().l[31&(b>>>10|0)]=a.wb();a.wb().l[31&(b>>>5|0)]=a.ye();break;case 4:a.fh(cf(a.rd()));a.ze(cf(a.kc()));a.Vc(cf(a.Kb()));a.nc(cf(a.wb()));a.rd().l[31&(b>>>20|0)]=a.kc();a.kc().l[31&(b>>>15|0)]=a.Kb();a.Kb().l[31&(b>>>10|0)]=a.wb();a.wb().l[31&(b>>>5|0)]=a.ye();break; case 3:a.ze(cf(a.kc()));a.Vc(cf(a.Kb()));a.nc(cf(a.wb()));a.kc().l[31&(b>>>15|0)]=a.Kb();a.Kb().l[31&(b>>>10|0)]=a.wb();a.wb().l[31&(b>>>5|0)]=a.ye();break;case 2:a.Vc(cf(a.Kb()));a.nc(cf(a.wb()));a.Kb().l[31&(b>>>10|0)]=a.wb();a.wb().l[31&(b>>>5|0)]=a.ye();break;case 1:a.nc(cf(a.wb()));a.wb().l[31&(b>>>5|0)]=a.ye();break;case 0:break;default:throw(new q).j(d);}}function ff(a,b){var d=a.l[b];a.l[b]=null;return cf(d)} function gf(a,b,d){a.Ij(d);d=-1+d|0;switch(d){case -1:break;case 0:a.Nc(b.ye());break;case 1:a.nc(b.wb());a.Nc(b.ye());break;case 2:a.Vc(b.Kb());a.nc(b.wb());a.Nc(b.ye());break;case 3:a.ze(b.kc());a.Vc(b.Kb());a.nc(b.wb());a.Nc(b.ye());break;case 4:a.fh(b.rd());a.ze(b.kc());a.Vc(b.Kb());a.nc(b.wb());a.Nc(b.ye());break;case 5:a.Ao(b.Eh());a.fh(b.rd());a.ze(b.kc());a.Vc(b.Kb());a.nc(b.wb());a.Nc(b.ye());break;default:throw(new q).j(d);}}function hf(a){return null===a?xba():a} function yba(a){return a===xba()?null:a}var zba=g({jF:0},!0,"scala.collection.mutable.HashEntry",{jF:1});function jf(){this.dy=this.ay=null}jf.prototype=new l;jf.prototype.constructor=jf;function Aba(a){var b=(new w).f([a.ay,a.dy]);a=b.oa.length|0;a=la(Xa(kf),[a]);var d;d=0;for(b=lf(new mf,b,0,b.oa.length|0);b.ta();){var e=b.ma();a.l[d]=e;d=1+d|0}return a}function nf(a,b,d){a.ay=b;a.dy=d;return a}jf.prototype.$classData=g({XY:0},!1,"java.math.BigInteger$QuotAndRem",{XY:1,d:1});function of(){} of.prototype=new l;of.prototype.constructor=of;of.prototype.b=function(){return this};function Bba(a,b,d,e){a=0;var f=-1+e|0;if(!(0>=e))for(var h=0;;){var k=h,p=d.l[k];b.l[k]=p<<1|a;a=p>>>31|0;if(h===f)break;h=1+h|0}0!==a&&(b.l[e]=a)}function Cba(a,b,d){a=d>>5;d&=31;var e=(b.bc+a|0)+(0===d?0:1)|0,f=la(Xa(db),[e]);pf(0,f,b.xb,a,d);b=qf(new rf,b.Ub,e,f);uf(b);return b} function Dba(a,b,d){a=d>>5;var e=31&d;if(a>=b.bc)return 0>b.Ub?wf().Bw:wf().Bj;d=b.bc-a|0;var f=la(Xa(db),[1+d|0]);Eba(0,f,d,b.xb,a,e);if(0>b.Ub){for(var h=0;h<a&&0===b.xb.l[h];)h=1+h|0;var k=0!==b.xb.l[h]<<(32-e|0);if(h<a||0<e&&k){for(h=0;h<d&&-1===f.l[h];)f.l[h]=0,h=1+h|0;h===d&&(d=1+d|0);a=h;f.l[a]=1+f.l[a]|0}}b=qf(new rf,b.Ub,d,f);uf(b);return b}function xf(a,b){if(0===b.Ub)return 0;a=b.bc<<5;var d=b.xb.l[-1+b.bc|0];0>b.Ub&&yf(b)===(-1+b.bc|0)&&(d=-1+d|0);return a=a-fa(d)|0} function Eba(a,b,d,e,f,h){for(a=0;a<f;)a=1+a|0;if(0===h)Oa(e,f,b,0,d);else{var k=32-h|0;for(a=0;a<(-1+d|0);)b.l[a]=e.l[a+f|0]>>>h|0|e.l[1+(a+f|0)|0]<<k,a=1+a|0;b.l[a]=e.l[a+f|0]>>>h|0}}function pf(a,b,d,e,f){if(0===f)Oa(d,0,b,e,b.l.length-e|0);else{a=32-f|0;b.l[-1+b.l.length|0]=0;for(var h=-1+b.l.length|0;h>e;){var k=h;b.l[k]=b.l[k]|d.l[-1+(h-e|0)|0]>>>a|0;b.l[-1+h|0]=d.l[-1+(h-e|0)|0]<<f;h=-1+h|0}}d=-1+e|0;if(!(0>=e))for(e=0;;){b.l[e]=0;if(e===d)break;e=1+e|0}} of.prototype.$classData=g({YY:0},!1,"java.math.BitLevel$",{YY:1,d:1});var zf=void 0;function Af(){zf||(zf=(new of).b());return zf}function Bf(){this.gG=this.vG=null}Bf.prototype=new l;Bf.prototype.constructor=Bf; Bf.prototype.b=function(){Cf=this;var a=(new w).f([-1,-1,31,19,15,13,11,11,10,9,9,8,8,8,8,7,7,7,7,7,7,7,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5]),b=a.oa.length|0,b=la(Xa(db),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e|0;d=1+d|0}this.vG=b;a=(new w).f([-2147483648,1162261467,1073741824,1220703125,362797056,1977326743,1073741824,387420489,1E9,214358881,429981696,815730721,1475789056,170859375,268435456,410338673,612220032,893871739,128E7,1801088541,113379904,148035889,191102976, 244140625,308915776,387420489,481890304,594823321,729E6,887503681,1073741824,1291467969,1544804416,1838265625,60466176]);b=a.oa.length|0;b=la(Xa(db),[b]);d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();)e=a.ma(),b.l[d]=e|0,d=1+d|0;this.gG=b;return this}; function Fba(a,b,d){if(0===b.ka&&0===b.qa)switch(d){case 0:return"0";case 1:return"0.0";case 2:return"0.00";case 3:return"0.000";case 4:return"0.0000";case 5:return"0.00000";case 6:return"0.000000";default:return(0>d?"0E+":"0E")+(-2147483648===d?"2147483648":""+(-d|0))}else{a=0>b.qa;var e;e="";var f=18;if(a){var h=b.ka;b=b.qa;b=(new Vb).ia(-h|0,0!==h?~b:-b|0)}for(var h=b.ka,k=b.qa;;){b=h;var p=k,k=Ra(),h=Df(k,h,p,10,0),k=k.Pb,f=-1+f|0,p=k,t=h,x=t>>>16|0,t=da(10,65535&t),x=da(10,x),x=t+(x<<16)|0;da(10, p);e=""+(new af).Ra(65535&(48+(b-x|0)|0))+e;b=k;if(0===h&&0===b)break}b=-1+((18-f|0)-d|0)|0;if(0<d&&-6<=b)if(d=1+b|0,0<d)e=e.substring(0,d)+"."+e.substring(d);else{f=-d|0;d=-1+f|0;if(!(0>=f))for(f=0;;){e=""+(new af).Ra(48)+e;if(f===d)break;f=1+f|0}e="0."+e}else 0!==d&&(d=""+b,0<b&&(d=""+(new af).Ra(43)+d),d=""+(new af).Ra(69)+d,1<(18-f|0)?(f=65535&(e.charCodeAt(0)|0),e=(new af).Ra(f)+"."+e.substring(1)+d):e=""+e+d);return a?""+(new af).Ra(45)+e:e}} function Ef(a,b){a=b.Ub;var d=b.bc,e=b.xb;if(0===a)return"0";if(1===d)return b=(+(e.l[0]>>>0)).toString(10),0>a?"-"+b:b;b="";var f=la(Xa(db),[d]);Oa(e,0,f,0,d);do{for(var h=0,e=-1+d|0;0<=e;){var k=h,h=f.l[e],p=Ff(Ra(),h,k,1E9,0);f.l[e]=p;var k=p>>31,t=65535&p,p=p>>>16|0,x=da(51712,t),t=da(15258,t),E=da(51712,p),x=x+((t+E|0)<<16)|0;da(1E9,k);da(15258,p);h=h-x|0;e=-1+e|0}e=""+h;for(b="000000000".substring(e.length|0)+e+b;0!==d&&0===f.l[-1+d|0];)d=-1+d|0}while(0!==d);f=0;for(d=b.length|0;;)if(f<d&&48=== (65535&(b.charCodeAt(f)|0)))f=1+f|0;else break;b=b.substring(f);return 0>a?""+(new af).Ra(45)+b:b}Bf.prototype.$classData=g({ZY:0},!1,"java.math.Conversion$",{ZY:1,d:1});var Cf=void 0;function Gf(){Cf||(Cf=(new Bf).b());return Cf}function Hf(){}Hf.prototype=new l;Hf.prototype.constructor=Hf;Hf.prototype.b=function(){return this}; function Gba(a,b,d,e,f,h,k){a=la(Xa(db),[1+f|0]);var p=la(Xa(db),[1+k|0]),t=fa(h.l[-1+k|0]);0!==t?(pf(Af(),p,h,0,t),pf(Af(),a,e,0,t)):(Oa(e,0,a,0,f),Oa(h,0,p,0,k));e=p.l[-1+k|0];for(d=-1+d|0;0<=d;){if(a.l[f]===e)h=-1;else{var x=a.l[f],E=a.l[-1+f|0];h=Ra();var S=Ff(h,E,x,e,0),x=h.Pb;h=S;var U=65535&S,S=S>>>16|0,ga=65535&e,ma=e>>>16|0,va=da(U,ga),ga=da(S,ga),U=da(U,ma),U=va+((ga+U|0)<<16)|0;da(x,e);da(S,ma);E=E-U|0;if(0!==h)a:for(h=1+h|0;;){S=h=-1+h|0;ma=p.l[-2+k|0];x=65535&S;S=S>>>16|0;va=65535&ma; ma=ma>>>16|0;U=da(x,va);va=da(S,va);ga=da(x,ma);x=U+((va+ga|0)<<16)|0;U=(U>>>16|0)+ga|0;U=(da(S,ma)+(U>>>16|0)|0)+(((65535&U)+va|0)>>>16|0)|0;ma=E;S=a.l[-2+f|0];va=E+e|0;if(0===((-2147483648^va)<(-2147483648^E)?1:0)&&(E=va,U^=-2147483648,ma^=-2147483648,U===ma?(-2147483648^x)>(-2147483648^S):U>ma))continue a;break}}if(E=0!==h){If();var E=a,x=f-k|0,ma=p,S=k,U=h,Fa;Fa=0;var Va;Va=0;va=-1+S|0;if(!(0>=S))for(ga=0;;){var vb=ga;Jf();var pb=ma.l[vb],Ib=65535&pb,pb=pb>>>16|0,kc=65535&U,$a=U>>>16|0,fc=da(Ib, kc),kc=da(pb,kc),Bc=da(Ib,$a),Ib=fc+((kc+Bc|0)<<16)|0,fc=(fc>>>16|0)+Bc|0,$a=(da(pb,$a)+(fc>>>16|0)|0)+(((65535&fc)+kc|0)>>>16|0)|0,pb=Ib+Fa|0;Fa=(-2147483648^pb)<(-2147483648^Ib)?1+$a|0:$a;$a=E.l[x+vb|0];pb=$a-pb|0;$a=(-2147483648^pb)>(-2147483648^$a)?-1:0;Ib=Va;Va=Ib>>31;Ib=pb+Ib|0;Va=(-2147483648^Ib)<(-2147483648^pb)?1+($a+Va|0)|0:$a+Va|0;E.l[x+vb|0]=Ib;if(ga===va)break;ga=1+ga|0}U=E.l[x+S|0];ma=U-Fa|0;U=(-2147483648^ma)>(-2147483648^U)?-1:0;ga=Va;va=ga>>31;ga=ma+ga|0;E.l[x+S|0]=ga;E=0!==((-2147483648^ ga)<(-2147483648^ma)?1+(U+va|0)|0:U+va|0)}if(E&&(h=-1+h|0,ga=va=0,E=-1+k|0,!(0>=k)))for(x=0;;){S=x;U=a.l[(f-k|0)+S|0];ma=U+p.l[S]|0;U=(-2147483648^ma)<(-2147483648^U)?1:0;ma=va+ma|0;U=(-2147483648^ma)<(-2147483648^va)?1+(ga+U|0)|0:ga+U|0;va=ma;ga=U;a.l[(f-k|0)+S|0]=va;va=ga;ga=0;if(x===E)break;x=1+x|0}null!==b&&(b.l[d]=h);f=-1+f|0;d=-1+d|0}return 0!==t?(Eba(Af(),p,k,a,0,t),p):(Oa(a,0,p,0,k),a)} function Hba(a,b,d,e,f){a=0;for(e=-1+e|0;0<=e;){var h=a;a=d.l[e];var k=Ra(),h=Ff(k,a,h,f,0),k=k.Pb,p=65535&h,t=h>>>16|0,x=65535&f,E=f>>>16|0,S=da(p,x),x=da(t,x),p=da(p,E),S=S+((x+p|0)<<16)|0;da(k,f);da(t,E);a=a-S|0;b.l[e]=h;e=-1+e|0}return a}Hf.prototype.$classData=g({$Y:0},!1,"java.math.Division$",{$Y:1,d:1});var Kf=void 0;function If(){Kf||(Kf=(new Hf).b());return Kf}function Lf(){}Lf.prototype=new l;Lf.prototype.constructor=Lf;Lf.prototype.b=function(){return this}; function Mf(a,b,d,e){for(var f=la(Xa(db),[b]),h=0,k=0;h<e;){var p=a.l[h],t=p-d.l[h]|0,p=(-2147483648^t)>(-2147483648^p)?-1:0,x=k,k=x>>31,x=t+x|0,t=(-2147483648^x)<(-2147483648^t)?1+(p+k|0)|0:p+k|0;f.l[h]=x;k=t;h=1+h|0}for(;h<b;)d=a.l[h],t=k,e=t>>31,t=d+t|0,d=(-2147483648^t)<(-2147483648^d)?1+e|0:e,f.l[h]=t,k=d,h=1+h|0;return f}function Nf(a,b,d,e){for(a=-1+e|0;0<=a&&b.l[a]===d.l[a];)a=-1+a|0;return 0>a?0:(-2147483648^b.l[a])<(-2147483648^d.l[a])?-1:1} function Of(a,b,d,e){var f=la(Xa(db),[1+b|0]),h=1,k=a.l[0],p=k+d.l[0]|0;f.l[0]=p;k=(-2147483648^p)<(-2147483648^k)?1:0;if(b>=e){for(;h<e;){var t=a.l[h],p=t+d.l[h]|0,t=(-2147483648^p)<(-2147483648^t)?1:0,k=p+k|0,p=(-2147483648^k)<(-2147483648^p)?1+t|0:t;f.l[h]=k;k=p;h=1+h|0}for(;h<b;)d=a.l[h],e=d+k|0,d=(-2147483648^e)<(-2147483648^d)?1:0,f.l[h]=e,k=d,h=1+h|0}else{for(;h<b;)t=a.l[h],p=t+d.l[h]|0,t=(-2147483648^p)<(-2147483648^t)?1:0,k=p+k|0,p=(-2147483648^k)<(-2147483648^p)?1+t|0:t,f.l[h]=k,k=p,h=1+ h|0;for(;h<e;)a=d.l[h],b=a+k|0,a=(-2147483648^b)<(-2147483648^a)?1:0,f.l[h]=b,k=a,h=1+h|0}0!==k&&(f.l[h]=k);return f} function Pf(a,b,d){a=b.Ub;var e=d.Ub,f=b.bc,h=d.bc;if(0===a)return d;if(0===e)return b;if(2===(f+h|0)){b=b.xb.l[0];d=d.xb.l[0];if(a===e)return e=b+d|0,d=(-2147483648^e)<(-2147483648^b)?1:0,0===d?(new rf).ia(a,e):qf(new rf,a,2,Qf(Rf(),e,(new w).f([d])));e=wf();0>a?(a=b=d-b|0,d=(-2147483648^b)>(-2147483648^d)?-1:0):(a=d=b-d|0,d=(-2147483648^d)>(-2147483648^b)?-1:0);return Tf(e,(new Vb).ia(a,d))}if(a===e)e=f>=h?Of(b.xb,f,d.xb,h):Of(d.xb,h,b.xb,f);else{var k=f!==h?f>h?1:-1:Nf(0,b.xb,d.xb,f);if(0===k)return wf().Bj; 1===k?e=Mf(b.xb,f,d.xb,h):(d=Mf(d.xb,h,b.xb,f),a=e,e=d)}a=qf(new rf,a|0,e.l.length,e);uf(a);return a} function Wf(a,b,d){var e=b.Ub;a=d.Ub;var f=b.bc,h=d.bc;if(0===a)return b;if(0===e)return Iba(d);if(2===(f+h|0))return b=b.xb.l[0],f=0,d=d.xb.l[0],h=0,0>e&&(e=b,b=-e|0,f=0!==e?~f:-f|0),0>a&&(a=d,e=h,d=-a|0,h=0!==a?~e:-e|0),a=wf(),e=b,b=f,f=h,d=e-d|0,Tf(a,(new Vb).ia(d,(-2147483648^d)>(-2147483648^e)?-1+(b-f|0)|0:b-f|0));var k=f!==h?f>h?1:-1:Nf(Xf(),b.xb,d.xb,f);if(e===a&&0===k)return wf().Bj;-1===k?(d=e===a?Mf(d.xb,h,b.xb,f):Of(d.xb,h,b.xb,f),a=-a|0):(d=e===a?Mf(b.xb,f,d.xb,h):Of(b.xb,f,d.xb,h),a= e);a=qf(new rf,a|0,d.l.length,d);uf(a);return a}Lf.prototype.$classData=g({aZ:0},!1,"java.math.Elementary$",{aZ:1,d:1});var Yf=void 0;function Xf(){Yf||(Yf=(new Lf).b());return Yf}function Zf(){this.Jh=0;this.Bq=null}Zf.prototype=new l;Zf.prototype.constructor=Zf;Zf.prototype.o=function(a){return a&&a.$classData&&a.$classData.n.ZG?this.Jh===a.Jh?this.Bq===a.Bq:!1:!1};Zf.prototype.k=function(){return"precision\x3d"+this.Jh+" roundingMode\x3d"+this.Bq};Zf.prototype.r=function(){return this.Jh<<3|this.Bq.aG}; Zf.prototype.$classData=g({ZG:0},!1,"java.math.MathContext",{ZG:1,d:1});function $f(){this.sG=null}$f.prototype=new l;$f.prototype.constructor=$f;$f.prototype.b=function(){ag=this;bg();var a=cg().jw,b=new Zf;b.Jh=34;b.Bq=a;this.sG=b;bg();cg();bg();cg();bg();cg();return this};$f.prototype.$classData=g({bZ:0},!1,"java.math.MathContext$",{bZ:1,d:1});var ag=void 0;function bg(){ag||(ag=(new $f).b());return ag}function dg(){this.ao=this.bo=this.ZB=null}dg.prototype=new l;dg.prototype.constructor=dg; dg.prototype.b=function(){eg=this;this.ZB=Jba(10,10);Jba(14,5);this.bo=la(Xa(kf),[32]);this.ao=la(Xa(kf),[32]);var a,b;a=1;for(var d=b=0;;){var e=d;if(18>=e){this.ao.l[e]=Tf(wf(),(new Vb).ia(a,b));var f=this.bo,h=wf(),k=a,p=b;f.l[e]=Tf(h,(new Vb).ia(0===(32&e)?k<<e:0,0===(32&e)?(k>>>1|0)>>>(31-e|0)|0|p<<e:k<<e));e=a;a=e>>>16|0;e=da(5,65535&e);f=da(5,a);a=e+(f<<16)|0;e=(e>>>16|0)+f|0;b=da(5,b)+(e>>>16|0)|0}else this.ao.l[e]=fg(this.ao.l[-1+e|0],this.ao.l[1]),this.bo.l[e]=fg(this.bo.l[-1+e|0],wf().Ap); if(31===d)break;d=1+d|0}return this}; function Kba(a,b,d){var e,f=-1+b|0;if(!(0>=b))for(var h=0;;){var k=h;e=0;var p=1+k|0,t=-1+b|0;if(!(p>=b))for(;;){var x=p,E=a.l[k],S=a.l[x],U=d.l[k+x|0],ga=65535&E,E=E>>>16|0,ma=65535&S,S=S>>>16|0,va=da(ga,ma),ma=da(E,ma),Fa=da(ga,S),ga=va+((ma+Fa|0)<<16)|0,va=(va>>>16|0)+Fa|0,E=(da(E,S)+(va>>>16|0)|0)+(((65535&va)+ma|0)>>>16|0)|0,U=ga+U|0,E=(-2147483648^U)<(-2147483648^ga)?1+E|0:E;e=U+e|0;U=(-2147483648^e)<(-2147483648^U)?1+E|0:E;d.l[k+x|0]=e;e=U;if(p===t)break;p=1+p|0}d.l[k+b|0]=e;if(h===f)break; h=1+h|0}Bba(Af(),d,d,b<<1);for(h=f=e=0;f<b;)p=a.l[f],x=a.l[f],t=d.l[h],k=e,e=65535&p,p=p>>>16|0,E=65535&x,x=x>>>16|0,U=da(e,E),E=da(p,E),S=da(e,x),e=U+((E+S|0)<<16)|0,U=(U>>>16|0)+S|0,p=(da(p,x)+(U>>>16|0)|0)+(((65535&U)+E|0)>>>16|0)|0,t=e+t|0,p=(-2147483648^t)<(-2147483648^e)?1+p|0:p,k=t+k|0,t=(-2147483648^k)<(-2147483648^t)?1+p|0:p,d.l[h]=k,h=1+h|0,k=t+d.l[h]|0,t=(-2147483648^k)<(-2147483648^t)?1:0,d.l[h]=k,e=t,f=1+f|0,h=1+h|0;return d} function Jba(a,b){var d=la(Xa(db),[-1+a|0]);a=[];var e,f=e=1;a.push(null===f?0:f);f=0;for(d=d.l.length;f<d;){var h=e=da(e|0,b);a.push(null===h?0:h);f=1+f|0}return ka(Xa(db),a)} function gg(a,b,d){if(d.bc>b.bc)var e=d;else e=b,b=d;d=e;var f=b;if(63>f.bc){var h=d.bc,e=f.bc;b=h+e|0;a=d.Ub!==f.Ub?-1:1;if(2===b){e=d.xb.l[0];b=f.xb.l[0];d=65535&e;var e=e>>>16|0,k=65535&b;b=b>>>16|0;var f=da(d,k),k=da(e,k),p=da(d,b);d=f+((k+p|0)<<16)|0;f=(f>>>16|0)+p|0;e=(da(e,b)+(f>>>16|0)|0)+(((65535&f)+k|0)>>>16|0)|0;a=0===e?(new rf).ia(a,d):qf(new rf,a,2,Qf(Rf(),d,(new w).f([e])))}else{d=d.xb;f=f.xb;k=la(Xa(db),[b]);if(0!==h&&0!==e)if(1===h)k.l[e]=hg(0,k,f,e,d.l[0]);else if(1===e)k.l[h]=hg(0, k,d,h,f.l[0]);else if(d===f&&h===e)Kba(d,h,k);else if(p=-1+h|0,!(0>=h))for(h=0;;){var t=h,x;x=0;var E=d.l[t],S=-1+e|0;if(!(0>=e))for(var U=0;;){var ga=U,ma=f.l[ga],va=k.l[t+ga|0],Fa=65535&E,Va=E>>>16|0,vb=65535&ma,ma=ma>>>16|0,pb=da(Fa,vb),vb=da(Va,vb),Ib=da(Fa,ma),Fa=pb+((vb+Ib|0)<<16)|0,pb=(pb>>>16|0)+Ib|0,Va=(da(Va,ma)+(pb>>>16|0)|0)+(((65535&pb)+vb|0)>>>16|0)|0,va=Fa+va|0,Va=(-2147483648^va)<(-2147483648^Fa)?1+Va|0:Va;x=va+x|0;va=(-2147483648^x)<(-2147483648^va)?1+Va|0:Va;k.l[t+ga|0]=x;x=va;if(U=== S)break;U=1+U|0}k.l[t+e|0]=x;if(h===p)break;h=1+h|0}a=qf(new rf,a,b,k);uf(a)}return a}e=(-2&d.bc)<<4;k=ig(d,e);p=ig(f,e);b=jg(k,e);h=Wf(Xf(),d,b);b=jg(p,e);f=Wf(Xf(),f,b);d=gg(a,k,p);b=gg(a,h,f);a=gg(a,Wf(Xf(),k,h),Wf(Xf(),f,p));f=d;a=Pf(Xf(),a,f);a=Pf(Xf(),a,b);a=jg(a,e);e=d=jg(d,e<<1);a=Pf(Xf(),e,a);return Pf(Xf(),a,b)} function hg(a,b,d,e,f){var h;h=0;a=-1+e|0;if(!(0>=e))for(e=0;;){var k=e,p=d.l[k],t=65535&p,p=p>>>16|0,x=65535&f,E=f>>>16|0,S=da(t,x),x=da(p,x),U=da(t,E),t=S+((x+U|0)<<16)|0,S=(S>>>16|0)+U|0,p=(da(p,E)+(S>>>16|0)|0)+(((65535&S)+x|0)>>>16|0)|0;h=t+h|0;p=(-2147483648^h)<(-2147483648^t)?1+p|0:p;b.l[k]=h;h=p;if(e===a)break;e=1+e|0}return h} function kg(a,b){var d=a.bo.l.length,e=d>>31,f=b.qa;if(f===e?(-2147483648^b.ka)<(-2147483648^d):f<e)return a.bo.l[b.ka];d=b.qa;if(0===d?-2147483598>=(-2147483648^b.ka):0>d)return lg(wf().Ap,b.ka);d=b.qa;if(0===d?-1>=(-2147483648^b.ka):0>d)return jg(lg(a.ao.l[1],b.ka),b.ka);for(var h=lg(a.ao.l[1],2147483647),d=h,f=b.qa,k=-2147483647+b.ka|0,e=k,k=1>(-2147483648^k)?f:-1+f|0,f=mg(Ra(),b.ka,b.qa,2147483647,0);;){var p=e,t=k;if(0===t?-1<(-2147483648^p):0<t)d=fg(d,h),e=-2147483647+e|0,k=1>(-2147483648^e)? k:-1+k|0;else break}d=fg(d,lg(a.ao.l[1],f));d=jg(d,2147483647);a=b.qa;e=b=-2147483647+b.ka|0;for(k=1>(-2147483648^b)?a:-1+a|0;;)if(b=e,a=k,0===a?-1<(-2147483648^b):0<a)d=jg(d,2147483647),b=k,a=-2147483647+e|0,b=1>(-2147483648^a)?b:-1+b|0,e=a,k=b;else break;return jg(d,f)}dg.prototype.$classData=g({cZ:0},!1,"java.math.Multiplication$",{cZ:1,d:1});var eg=void 0;function Jf(){eg||(eg=(new dg).b());return eg}function ng(){this.bj=this.sV=null;this.a=0}ng.prototype=new l;ng.prototype.constructor=ng; ng.prototype.b=function(){sg=this;this.sV="\x3cBREEDS?\x3e";this.a=(1|this.a)<<24>>24;B();var a=(new w).f([(new tg).sd("CREATE-ORDERED-\x3cBREEDS\x3e",ug(),"_createorderedturtles"),(new tg).sd("CREATE-\x3cBREEDS\x3e",ug(),"_createturtles"),(new tg).sd("HATCH-\x3cBREEDS\x3e",ug(),"_hatch"),(new tg).sd("SPROUT-\x3cBREEDS\x3e",ug(),"_sprout"),(new tg).sd("\x3cBREEDS\x3e",vg(),"_breed"),(new tg).sd("\x3cBREEDS\x3e-AT",vg(),"etc._breedat"),(new tg).sd("\x3cBREEDS\x3e-HERE",vg(),"etc._breedhere"),(new tg).sd("\x3cBREEDS\x3e-ON", vg(),"etc._breedon"),(new tg).sd("\x3cBREED\x3e",vg(),"etc._breedsingular"),(new tg).sd("IS-\x3cBREED\x3e?",vg(),"etc._isbreed"),(new wg).sd("CREATE-\x3cBREEDS\x3e-FROM",ug(),"etc._createlinksfrom"),(new wg).sd("CREATE-\x3cBREED\x3e-FROM",ug(),"etc._createlinkfrom"),(new wg).sd("CREATE-\x3cBREEDS\x3e-TO",ug(),"etc._createlinksto"),(new xg).sd("CREATE-\x3cBREEDS\x3e-WITH",ug(),"etc._createlinkswith"),(new wg).sd("CREATE-\x3cBREED\x3e-TO",ug(),"etc._createlinkto"),(new xg).sd("CREATE-\x3cBREED\x3e-WITH", ug(),"etc._createlinkwith"),(new yg).sd("IN-\x3cBREED\x3e-FROM",vg(),"etc._inlinkfrom"),(new yg).sd("IN-\x3cBREED\x3e-NEIGHBOR?",vg(),"etc._inlinkneighbor"),(new yg).sd("IN-\x3cBREED\x3e-NEIGHBORS",vg(),"etc._inlinkneighbors"),(new yg).sd("IS-\x3cBREED\x3e?",vg(),"etc._isbreed"),(new yg).sd("\x3cBREEDS\x3e",vg(),"etc._linkbreed"),(new yg).sd("\x3cBREED\x3e",vg(),"etc._linkbreedsingular"),(new yg).sd("\x3cBREED\x3e-NEIGHBOR?",vg(),"etc._linkneighbor"),(new yg).sd("\x3cBREED\x3e-NEIGHBORS",vg(),"etc._linkneighbors"), (new yg).sd("\x3cBREED\x3e-WITH",vg(),"etc._linkwith"),(new yg).sd("MY-IN-\x3cBREEDS\x3e",vg(),"etc._myinlinks"),(new yg).sd("MY-\x3cBREEDS\x3e",vg(),"etc._mylinks"),(new yg).sd("MY-OUT-\x3cBREEDS\x3e",vg(),"etc._myoutlinks"),(new yg).sd("OUT-\x3cBREED\x3e-NEIGHBOR?",vg(),"etc._outlinkneighbor"),(new yg).sd("OUT-\x3cBREED\x3e-NEIGHBORS",vg(),"etc._outlinkneighbors"),(new yg).sd("OUT-\x3cBREED\x3e-TO",vg(),"etc._outlinkto")]),b=B().s;this.bj=L(a,b);this.a=(2|this.a)<<24>>24;return this}; function Lba(a,b){return Qb(Ia(),Qb(Ia(),b.Ld,"\x3cBREEDS\x3e",a.ql.va),"\x3cBREED\x3e",a.Bf.va)}function zg(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/BreedIdentifierHandler.scala: 16");return a.bj}function Mba(a,b,d){return b.Kg&&b.Jg?(new Ag).iu(a,d):b.Kg?(new Bg).iu(a,d):(new Cg).iu(a,d)} function saa(a){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/BreedIdentifierHandler.scala: 14");return a.sV}function Nba(a,b){var d=zg(a);a=Oba(a,b,vg()).Cj(m(new n,function(a,b){return function(a){return Lba(b,a)}}(a,b)));b=B();return d.ic(a,b.s)} function Oba(a,b,d){return Mba(d,b,m(new n,function(a){return function(b){var d=u((new v).K((new w).f(["^","$"])),(new w).f([saa(a)]));if(null===b)throw(new Oe).b();var k=Dg(),d=Eg(k,d);return!Pba(Fg(new Gg,d,b,La(b)))}}(a)))}function Qba(a,b){var d=zg(a);a=Oba(a,b,ug()).Cj(m(new n,function(a,b){return function(a){return Lba(b,a)}}(a,b)));b=B();return d.ic(a,b.s)} function Rba(a,b,d){return zg(a).Ic().aj(m(new n,function(a,b,d){return function(a){var e=b.X,e=Hg(a.Tx(),e);if(e.z())t=!1;else if(null!==e.Y())var t=e.Y(),t=0===Ig(t,1);else t=!1;if(t){var e=e.Y().W(0),t=(new Kc).fg(a.Yw(d)),x=new Jg;if(null===a)throw Kg(Lg(),null);x.Sa=a;x.qq=e;a=Mg(t,x)}else a=F();return a.ub()}}(a,b,d)),(Ng(),(new Og).b())).wg()}ng.prototype.$classData=g({mZ:0},!1,"org.nlogo.core.BreedIdentifierHandler$",{mZ:1,d:1});var sg=void 0; function Rb(){sg||(sg=(new ng).b());return sg}function Pg(){}Pg.prototype=new l;Pg.prototype.constructor=Pg;Pg.prototype.b=function(){return this};function Sba(a,b){if(Qg(b))return(new Wg).c(b);if("number"===typeof b)return(new Xg).LD(b);if("boolean"===typeof b)return(new Yg).qu(b);if(Zg(b))return Tba(b);throw Kg(Lg(),(new $g).c(u((new v).K((new w).f(["Invalid chooser option ",""])),(new w).f([b]))));}Pg.prototype.$classData=g({rZ:0},!1,"org.nlogo.core.Chooseable$",{rZ:1,d:1});var ah=void 0; function Uba(){ah||(ah=(new Pg).b());return ah}function bh(){this.nG=null;this.lS=this.hG=0;this.oG=null;this.a=0}bh.prototype=new l;bh.prototype.constructor=bh; bh.prototype.b=function(){ch=this;var a=(new w).f("gray red orange brown yellow green lime turquoise cyan sky blue violet magenta pink black white".split(" ")),b=a.oa.length|0,b=la(Xa(qa),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e;d=1+d|0}this.nG=b;this.a=(1|this.a)<<24>>24;this.hG=0;this.a=(2|this.a)<<24>>24;this.lS=9.9;this.a=(4|this.a)<<24>>24;a=(new w).f([5,15,25,35,45,55,65,75,85,95,105,115,125,135,Vba(this),Wba(this)]);b=a.oa.length|0;b=la(Xa(gb),[b]);d=0;for(a= lf(new mf,a,0,a.oa.length|0);a.ta();)e=a.ma(),b.l[d]=+e,d=1+d|0;this.oG=b;this.a=(8|this.a)<<24>>24;return this};function Wba(a){if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ColorConstants.scala: 17");return a.lS}function Xba(){var a=dh();if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ColorConstants.scala: 8");return a.nG} function Vba(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ColorConstants.scala: 16");return a.hG}function Yba(a,b){if(0===(8&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ColorConstants.scala: 19");return a.oG.l[b]}bh.prototype.$classData=g({vZ:0},!1,"org.nlogo.core.ColorConstants$",{vZ:1,d:1});var ch=void 0;function dh(){ch||(ch=(new bh).b());return ch} var $ba=function Zba(b,d){if(Qg(d))return u((new v).K((new w).f(['"','"'])),(new w).f([eh(fh(),d)]));if("boolean"===typeof d)return d?"true":"false";if(gh(d)){b=function(b){return function(d){return Zba(b,d)}}(b);var e=B().s;if(e===B().s)if(d===y())b=y();else{var e=d.$(),f=e=Cd(new Dd,b(e),y());for(d=d.aa();d!==y();){var h=d.$(),h=Cd(new Dd,b(h),y()),f=f.Ia=h;d=d.aa()}b=e}else{for(e=Mc(d,e);!d.z();)f=d.$(),e.Na(b(f)),d=d.aa();b=e.Da()}return b.Oc("["," ","]")}if(Zg(d)){e=B().s;d=L(d,e);b=function(b){return function(d){return Zba(b, d)}}(b);e=B().s;if(e===B().s)if(d===y())b=y();else{e=d.$();f=e=Cd(new Dd,b(e),y());for(d=d.aa();d!==y();)h=d.$(),h=Cd(new Dd,b(h),y()),f=f.Ia=h,d=d.aa();b=e}else{for(e=Mc(d,e);!d.z();)f=d.$(),e.Na(b(f)),d=d.aa();b=e.Da()}return b.Oc("["," ","]")}if(null!==d)return na(d);throw(new q).j(d);};function hh(){this.g=null}hh.prototype=new l;hh.prototype.constructor=hh;hh.prototype.Ff=function(a){this.g=a;return this};hh.prototype.$classData=g({EZ:0},!1,"org.nlogo.core.ErrorSource",{EZ:1,d:1}); function ih(){}ih.prototype=new l;ih.prototype.constructor=ih;ih.prototype.b=function(){return this};function jh(a,b,d,e){throw(new hd).ms(a,b,d,e);}ih.prototype.$classData=g({GZ:0},!1,"org.nlogo.core.Fail$",{GZ:1,d:1});var aca=void 0;function kh(){aca||(aca=(new ih).b())}function lh(){this.HR=null;this.a=!1}lh.prototype=new l;lh.prototype.constructor=lh;lh.prototype.b=function(){mh=this;this.HR=nh(oh(),y());this.a=!0;return this}; function ph(){var a;mh||(mh=(new lh).b());a=mh;if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/FrontEndInterface.scala: 12");return a.HR}lh.prototype.$classData=g({HZ:0},!1,"org.nlogo.core.FrontEndInterface$",{HZ:1,d:1});var mh=void 0;function qh(){this.Fo=null;this.ya=!1}qh.prototype=new l;qh.prototype.constructor=qh;qh.prototype.b=function(){return this}; function rh(){var a;sh||(sh=(new qh).b());a=sh;if(!a.ya&&!a.ya){for(var b=[(new A).e("org.nlogo.prim.$common.expectedBooleanValue","{0} expected a true/false value from {1}, but got {2} instead."),(new A).e("org.nlogo.prim._max.cantFindMaxOfListWithNoNumbers","Cant find the maximum of a list with no numbers: {0}"),(new A).e("org.nlogo.agent.Turtle.cantSetBreedToNonBreedAgentSet","You cant set BREED to a non-breed agentset."),(new A).e("org.nlogo.prim.etc._atpoints.invalidListOfPoints","Invalid list of points: {0}"), (new A).e("org.nlogo.prim.etc.atan.bothInputsCannotBeZero","atan is undefined when both inputs are zero."),(new A).e("org.nlogo.agent.Agent.notADoubleVariable","{0} is not a double variable."),(new A).e("org.nlogo.prim.etc.$common.requestMoreItemsThanInList","Requested {0} random items from a list of length {1}."),(new A).e("org.nlogo.agent.Turtle.cantAccessLinkWithoutSpecifyingLink","A turtle cant access a link variable without specifying which link."),(new A).e("org.nlogo.agent.Patch.cantAccessTurtleWithoutSpecifyingTurtle", "A patch cant access a turtle variable without specifying which turtle."),(new A).e("org.nlogo.agent.Protractor.noHeadingFromAgentToSelf","No heading is defined from an agent to itself."),(new A).e("org.nlogo.prim.etc.$common.divByZero","Division by zero."),(new A).e("org.nlogo.workspace.DefaultFileManager.cannotDeleteNonExistantFile","You cannot delete a non-existent file."),(new A).e("org.nlogo.agent.Topology.cantMoveTurtleBeyondWorldEdge","Cannot move turtle beyond the worlds edge."),(new A).e("org.nlogo.agent.Link.cantSetBreedToNonLinkBreedAgentSet", "You cant set BREED to a non-link-breed agentset."),(new A).e("org.nlogo.prim.etc._foreach.listsMustBeSameLength","All the list arguments to FOREACH must be the same length."),(new A).e("compiler.StructureParser.includeNotFound","Could not find {0}"),(new A).e("org.nlogo.prim.etc._randomNormal.secondInputNotNegative","random-normals second input cant be negative."),(new A).e("org.nlogo.prim.etc.$common.tickCounterNotStarted","The tick counter has not been started yet. Use RESET-TICKS."),(new A).e("org.nlogo.prim._lessorequal.cannotCompareParameters", "The \x3c\x3d operator can only be used on two numbers, two strings, or two agents of the same type, but not on {0} and {1}."),(new A).e("org.nlogo.agent.Protractor.noHeadingFromPointToSelf","No heading is defined from a point ({0},{1}) to that same point."),(new A).e("org.nlogo.agent.Agent.shapeUndefined",'"{0}" is not a currently defined shape.'),(new A).e("org.nlogo.prim.etc._variance.listMustHaveMoreThanOneNumber","Cant find the variance of a list without at least two numbers: {0}."),(new A).e("compiler.LocalsVisitor.notDefined", "Nothing named {0} has been defined."),(new A).e("org.nlogo.prim.etc.$common.cantTakeLogarithmOf","Cant take logarithm of {0}."),(new A).e("org.nlogo.prim.$common.invalidAgentKind.simple","this code cant be run by {0}"),(new A).e("org.nlogo.prim.$common.withExpectedBooleanValue","WITH expected a true/false value from {0}, but got {1} instead."),(new A).e("org.nlogo.prim.etc._linkheading.noLinkHeadingWithSameEndpoints","There is no heading of a link whose endpoints are in the same position."), (new A).e("org.nlogo.prim.$common.agentKind.patch","a patch"),(new A).e("org.nlogo.prim._min.cantFindMinOfListWithNoNumbers","Cant find the minimum of a list with no numbers: {0}"),(new A).e("fileformat.invalidversion",'Invalid NetLogo file. Expected "{0}" formatted model to have version compatible with {1}, but this model had version {2}'),(new A).e("org.nlogo.prim.etc._sublist.endIsGreaterThanListSize","{0} is greater than the length of the input list ({1})."),(new A).e("org.nlogo.prim.etc.$common.indexExceedsStringSize", "Cant find element {0} of the string {1}, which is only of length {2}."),(new A).e("org.nlogo.prim.etc._runresult.failedToReportResult","Failed to report a result."),(new A).e("org.nlogo.agent.Patch.cantChangePatchCoordinates","You cant change a patchs coordinates."),(new A).e("org.nlogo.prim.lambda.missingInput","anonymous procedure expected 1 input, but only got 0"),(new A).e("org.nlogo.prim.etc._exportoutput.emptyPath","Cant export to empty pathname."),(new A).e("org.nlogo.prim.etc._myself.noAgentMyself", "There is no agent for MYSELF to refer to."),(new A).e("org.nlogo.prim.$common.onlyObserverCanAskAllPatches","Only the observer can ASK the set of all patches."),(new A).e("org.nlogo.prim.$common.turtleCantLinkToSelf","A turtle cannot link to itself."),(new A).e("org.nlogo.agent.ChooserConstraint.invalidValue","Value must be one of: {0}"),(new A).e("org.nlogo.agent.Link.cantHaveBreededAndUnbreededLinks","You cannot have both breeded and unbreeded links in the same world."),(new A).e("org.nlogo.prim._returnreport.reportNotCalledInReportProcedure", "Reached end of reporter procedure without REPORT being called."),(new A).e("org.nlogo.prim.etc._turtleset.incorrectInputType","List inputs to {0} must only contain turtle or turtle agentset elements.  The list {1} contained {2} which is NOT a turtle or turtle agentset."),(new A).e("org.nlogo.prim.etc._linkset.invalidLAgentsetTypeInputToList","List inputs to {0} must only contain link, link agentset, or list elements.  The list {1} contained a different type agentset: {2}."),(new A).e("org.nlogo.agent.Patch.cantAccessLinkVarWithoutSpecifyingLink", "A patch cant access a link variable without specifying which link."),(new A).e("org.nlogo.prim.$common.paramOutOfBounds","{0} is not in the range 0.0 to 1.0"),(new A).e("org.nlogo.prim.etc.median.cantFindMedianOfListWithNoNumbers","Cant find the median of a list with no numbers: {0}."),(new A).e("org.nlogo.prim.etc._sqrt.squareRootIsImaginary","The square root of {0} is an imaginary number."),(new A).e("org.nlogo.prim.etc.$common.noNegativeNumber","{0} cannot take a negative number."),(new A).e("compiler.StructureConverter.noBreed", 'There is no breed "{0}"'),(new A).e("org.nlogo.prim.$common.agentKind.observer","the observer"),(new A).e("org.nlogo.prim.etc._setDefaultShape.notADefinedLinkShape",'"{0}" is not a currently defined link shape.'),(new A).e("compiler.LetVariable.notDefined","Nothing named {0} has been defined."),(new A).e("org.nlogo.prim.lambda.missingInputs","anonymous procedure expected {0} inputs, but only got {1}"),(new A).e("org.nlogo.prim.etc._setdefaultshape.canOnlySetDefaultShapeOfEntireBreed","Can only set the default shape of all turtles , all links, or an entire breed."), (new A).e("org.nlogo.workspace.DefaultFileManager.noOpenFile","No file has been opened."),(new A).e("org.nlogo.agent.Patch.cantAccessTurtleOrLinkWithoutSpecifyingAgent","A patch cant access a turtle or link variable without specifying which agent."),(new A).e("org.nlogo.prim.etc.$common.syntaxError","Syntax Error: {0}"),(new A).e("org.nlogo.prim.etc._median.emptyList","Cant find the median of a list with no numbers: {0}"),(new A).e("org.nlogo.agent.Patch.pcolorNotADouble","Pcolor is not a double."), (new A).e("org.nlogo.prim._reduce.emptyListInvalidInput","The list argument to 'reduce' must not be empty."),(new A).e("org.nlogo.prim._lessthan.cantUseLessthanOnDifferentArgs","The \x3c operator can only be used on two numbers, two strings, or two agents of the same type, but not on {0} and {1}."),(new A).e("org.nlogo.prim.etc.$common.noNegativeAngle","{0} cannot take a negative angle."),(new A).e("org.nlogo.prim.etc._resizeworld.worldMustIncludeOrigin","You must include the point (0, 0) in the world."), (new A).e("compiler.TaskVisitor.notDefined","This special variable isnt defined here."),(new A).e("org.nlogo.agent.Agent.wrongTypeOnSetError","cant set {0} variable {1} to non-{2} {3}"),(new A).e("org.nlogo.agent.Agent.cantMoveToLink","You cant move-to a link."),(new A).e("org.nlogo.prim.etc._range.zeroStep","The step-size for range must be non-zero."),(new A).e("org.nlogo.plot.noPlotSelected","There is no current plot. Please select a current plot using the set-current-plot command."),(new A).e("org.nlogo.prim.etc.$common.noAngleGreaterThan360", "{0} cannot take an angle greater than 360."),(new A).e("org.nlogo.prim.etc._setDefaultShape.notADefinedTurtleShape",'"{0}" is not a currently defined turtle shape.'),(new A).e("org.nlogo.prim.etc._substring.endIsGreaterThanListSize","{0} is too big for {1}, which is only of length {2}."),(new A).e("org.nlogo.prim.$common.invalidAgentKind.alternative","this code cant be run by {0}, only {1}"),(new A).e("org.nlogo.prim.etc._setdefaultshape.cantSetDefaultShapeOfPatch","Cannot set the default shape of patches, because patches do not have shapes."), (new A).e("org.nlogo.agent.Agent.cantSetUnknownVariable","Unknown variable {0}."),(new A).e("org.nlogo.prim.etc._standarddeviation.needListGreaterThanOneItem","Cant find the standard deviation of a list without at least two numbers: {0}"),(new A).e("org.nlogo.prim.etc._tickadvance.noNegativeTickAdvances","Cannot advance the tick counter by a negative amount."),(new A).e("org.nlogo.prim.etc.$common.negativeIndex","{0} isnt greater than or equal to zero."),(new A).e("org.nlogo.prim.etc._patchset.listInputNonPatchAgentset", "List inputs to {0} must only contain patch, patch agentset, or list elements.  The list {1} contained a different type agentset: {2}."),(new A).e("org.nlogo.prim.etc._otherend.onlyTurtleCanGetLinkEnd","Only a turtle can get the OTHER-END of a link."),(new A).e("org.nlogo.prim.$common.agentKind.link","a link"),(new A).e("org.nlogo.prim.etc._log.notAValidBase","{0} isnt a valid base for a logarithm."),(new A).e("org.nlogo.prim.etc.$common.noNegativeRadius","{0} cannot take a negative radius."),(new A).e("org.nlogo.agent.ImportPatchColors.unsupportedImageFormat", "The following file is not in a supported image format: {0}"),(new A).e("org.nlogo.agent.Agent.rgbValueError","RGB values must be 0-255"),(new A).e("org.nlogo.prim.etc.$common.emptyListInput","{0} got an empty list as input."),(new A).e("org.nlogo.prim.etc._sublist.endIsLessThanStart","{0} is less than {1}."),(new A).e("org.nlogo.prim.etc._randomgamma.noNegativeInputs","Both inputs to {0} must be positive."),(new A).e("org.nlogo.agent.Turtle.cantChangeWho","You cant change a turtles ID number."), (new A).e("org.nlogo.prim.etc.$common.indexExceedsListSize","Cant find element {0} of the list {1}, which is only of length {2}."),(new A).e("org.nlogo.prim._mean.cantFindMeanOfNonNumbers","Cant find the mean of a list that contains non-numbers : {0} is a {1}."),(new A).e("org.nlogo.prim.etc._sublist.startIsLessThanZero","{0} is less than zero."),(new A).e("org.nlogo.prim.etc.$common.firstInputCantBeNegative","First input to {0} cant be negative."),(new A).e("org.nlogo.prim.etc._otherend.incorrectLink", "{0} is not linked by {1}."),(new A).e("org.nlogo.prim.etc._turtleset.listInputsMustBeTurtleOrTurtleAgentset","List inputs to {0} must only contain turtle or turtle agentset elements.  The list {1} contained a different type agentset: {2}."),(new A).e("compiler.CarefullyVisitor.badNesting","{0} cannot be used outside of CAREFULLY."),(new A).e("org.nlogo.$common.thatAgentIsDead","That {0} is dead."),(new A).e("org.nlogo.prim.etc.$common.expectedLastInputToBeLinkBreed","Expected the last input to be a link breed."), (new A).e("compiler.SetVisitor.notSettable","This isnt something you can use \"set\" on."),(new A).e("org.nlogo.prim.etc._patchset.listInputNonPatch","List inputs to {0} must only contain patch, patch agentset, or list elements.  The list {1} contained {2} which is NOT a patch or patch agentset."),(new A).e("org.nlogo.prim.etc.$common.emptyString","String is empty."),(new A).e("org.nlogo.agent.Agent.rgbListSizeError.3or4","An rgb list must contain 3 or 4 numbers 0-255"),(new A).e("org.nlogo.$common.tooBigForInt", "{0} is too large to be represented exactly as an integer in NetLogo."),(new A).e("org.nlogo.prim.etc._stop.notAllowedInsideToReport","{0} is not allowed inside TO-REPORT."),(new A).e("org.nlogo.agent.Patch.cantSetTurtleWithoutSpecifyingTurtle","A patch cant set a turtle variable without specifying which turtle."),(new A).e("org.nlogo.prim._report.mustImmediatelyBeUsedInToReport","{0} must be immediately inside a TO-REPORT."),(new A).e("org.nlogo.prim._askconcurrent.onlyObserverCanAskAllTurtles", "only the observer can ASK the set of all turtles"),(new A).e("org.nlogo.prim.etc.$common.expectedTurtleOrPatchButGotLink","Expected a turtle or a patch but got a link."),(new A).e("org.nlogo.prim.$common.agentKind.turtle","a turtle"),(new A).e("org.nlogo.agent.Turtle.patchBeyondLimits","Cannot get patch beyond limits of current world."),(new A).e("org.nlogo.prim.etc._linkset.invalidListInputs","List inputs to {0} must only contain link, link agentset, or list elements.  The list {1} contained {2} which is NOT a link or link agentset."), (new A).e("org.nlogo.prim.etc.$common.emptyStringInput","{0} got an empty string as input."),(new A).e("org.nlogo.prim.etc._setxy.pointOutsideWorld","The point [ {0} , {1} ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions."),(new A).e("org.nlogo.prim._greaterorequal.cannotCompareParameters","The \x3e\x3d operator can only be used on two numbers, two strings, or two agents of the same type, but not on {0} and {1}."),(new A).e("org.nlogo.workspace.DefaultFileManager.canOnlyDeleteFiles", "You can only delete files."),(new A).e("org.nlogo.prim._report.canOnlyUseInToReport","{0} can only be used inside TO-REPORT."),(new A).e("org.nlogo.prim.$common.noSumOfListWithNonNumbers","Cant find the sum of a list that contains non-numbers {0} is a {1}."),(new A).e("org.nlogo.prim.etc._layoutcircle.patchesImmovable","Patches are immovable."),(new A).e("org.nlogo.prim.etc.$common.notThatManyAgentsExist","Requested {0} random agents from a set of only {1} agents."),(new A).e("org.nlogo.agent.Agent.rgbListSizeError.3", "An rgb list must contain 3 numbers 0-255"),(new A).e("org.nlogo.prim.etc._otherend.onlyLinkCanGetTurtleEnd","Only a link can get the OTHER-END from a turtle."),(new A).e("org.nlogo.prim.$common.onlyObserverCanAskAllTurtles","Only the observer can ASK the set of all turtles."),(new A).e("org.nlogo.agent.BooleanConstraint.bool","Value must be a boolean."),(new A).e("org.nlogo.prim.etc.$common.emptyList","List is empty."),(new A).e("org.nlogo.prim._greaterthan.cannotCompareParameters","The \x3e operator can only be used on two numbers, two strings, or two agents of the same type, but not on {0} and {1}."), (new A).e("org.nlogo.agent.Agent.breedDoesNotOwnVariable","{0} breed does not own variable {1}")],d=dc(new ec,gc()),e=0,f=b.length|0;e<f;)hc(d,b[e]),e=1+e|0;b=new Dh;b.Vl=d.Ma;a.Fo=b;a.ya=!0}return a.Fo}qh.prototype.$classData=g({JZ:0},!1,"org.nlogo.core.I18N$",{JZ:1,d:1});var sh=void 0;function Dh(){this.Vl=null}Dh.prototype=new l;Dh.prototype.constructor=Dh;Dh.prototype.$classData=g({KZ:0},!1,"org.nlogo.core.I18N$BundleKind",{KZ:1,d:1});function Eh(a){return a.H().Wb.toUpperCase()} function M(a){a.L(null);a.M(a.G().h);a.P(a.G().p)}function Fh(a,b){var d=a.H();b.L(Gh(d,b,d.Wb,d.jb));b.M(a.N());return b}function Hh(){this.QU=null;this.a=!1}Hh.prototype=new l;Hh.prototype.constructor=Hh; Hh.prototype.b=function(){Ih=this;var a="TO TO-REPORT END GLOBALS TURTLES-OWN LINKS-OWN PATCHES-OWN DIRECTED-LINK-BREED UNDIRECTED-LINK-BREED EXTENSIONS __INCLUDES".split(" ");if(0===(a.length|0))a=Jh();else{for(var b=Kh(new Lh,Jh()),d=0,e=a.length|0;d<e;)Mh(b,a[d]),d=1+d|0;a=b.Ma}this.QU=a;this.a=!0;return this};Hh.prototype.$classData=g({LZ:0},!1,"org.nlogo.core.Keywords$",{LZ:1,d:1});var Ih=void 0;function Nh(){}Nh.prototype=new l;Nh.prototype.constructor=Nh;Nh.prototype.b=function(){return this}; Nh.prototype.$classData=g({UZ:0},!1,"org.nlogo.core.Nobody$",{UZ:1,d:1});var Oh=void 0;function Ph(){Oh||(Oh=(new Nh).b());return Oh}function Qh(){this.mV=this.LG=this.QG=this.PG=null;this.a=0}Qh.prototype=new l;Qh.prototype.constructor=Qh; Qh.prototype.b=function(){Rh=this;this.PG="Number too large";this.a=(1|this.a)<<24>>24;this.QG="is too large to be represented exactly as an integer in NetLogo";this.a=(2|this.a)<<24>>24;this.LG="Illegal number format";this.a=(4|this.a)<<24>>24;this.mV=(new Tb).Ro("^-?[0-9]*(\\.[0-9]*)?([Ee]-?[0-9]+)?$",(new w).f([]));this.a=(8|this.a)<<24>>24;return this}; function Sh(a,b){try{var d=(new Sb).c(b).R.length|0;if(0<d){var e=0;45===(65535&(b.charCodeAt(e)|0))&&(e=1+e|0);e<d&&46===(65535&(b.charCodeAt(e)|0))&&(e=1+e|0);if(e<d)var f=65535&(b.charCodeAt(e)|0),h=Th(Uh(),f);else h=!1}else h=!1;if(h){var k=Vh(Wh(),b);if(Infinity===k||-Infinity===k){pc();if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/NumberParser.scala: 12");return(new Xh).j(a.PG)}for(var p=(new Sb).c(".eE"),d=0;;){if(d<(p.R.length|0))var t= p.W(d),x=null===t?0:t.X,E=(new Sb).c(b),S=(new af).Ra(x),U=!1===li(E,S);else U=!1;if(U)d=1+d|0;else break}if(d!==(p.R.length|0))return pc(),(new mi).j(k);var ga=bca(ni(),b),ma=ga.ka,va=ga.qa;if((2097152===va?0!==ma:2097152<va)||-2097152>va){pc();var Fa=u((new v).K((new w).f([""," ",""])),(new w).f([b,cca(a)]));return(new Xh).j(Fa)}pc();return(new mi).j(k)}pc();return(new Xh).j("Illegal number format")}catch(Va){if(Va&&Va.$classData&&Va.$classData.n.aE){if(0===(8&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/NumberParser.scala: 21"); k=Fg(new Gg,a.mV.Xu,b,La(b));if((oi(k)?(new J).j(pi(k)):F()).ba())return pc(),a=u((new v).K((new w).f([""," ",""])),(new w).f([b,cca(a)])),(new Xh).j(a);pc();if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/NumberParser.scala: 15");return(new Xh).j(a.LG)}throw Va;}}function cca(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/NumberParser.scala: 13");return a.QG} Qh.prototype.$classData=g({VZ:0},!1,"org.nlogo.core.NumberParser$",{VZ:1,d:1});var Rh=void 0;function qi(){Rh||(Rh=(new Qh).b());return Rh}function ri(){this.a=0}ri.prototype=new l;ri.prototype.constructor=ri;ri.prototype.b=function(){si=this;this.a=(1|this.a)<<24>>24;this.a=(2|this.a)<<24>>24;this.a=(4|this.a)<<24>>24;this.a=(8|this.a)<<24>>24;this.a=(16|this.a)<<24>>24;return this};ri.prototype.$classData=g({$Z:0},!1,"org.nlogo.core.PlotPenInterface$",{$Z:1,d:1});var si=void 0;function ti(){} ti.prototype=new l;ti.prototype.constructor=ti;ti.prototype.b=function(){return this};ti.prototype.Yd=function(a){return(new J).j((new ac).ae(a.pe,a.za,a.ra))};ti.prototype.$classData=g({d_:0},!1,"org.nlogo.core.ReporterApp$",{d_:1,d:1});var ui=void 0;function vi(){ui||(ui=(new ti).b());return ui}function wi(){}wi.prototype=new l;wi.prototype.constructor=wi;wi.prototype.b=function(){return this};function xi(a,b){return(new J).j((new A).e(b.Sk,b.ra))} wi.prototype.$classData=g({e_:0},!1,"org.nlogo.core.ReporterBlock$",{e_:1,d:1});var yi=void 0;function zi(){yi||(yi=(new wi).b());return yi}function Ai(){this.qk=null;this.a=!1}Ai.prototype=new l;Ai.prototype.constructor=Ai; Ai.prototype.b=function(){Bi=this;var a=[I(r(),(new w).f([0,1])),I(r(),(new w).f([1,0])),I(r(),(new w).f([2,2])),I(r(),(new w).f([4,4])),I(r(),(new w).f([4,4,2,2]))];if(0===(a.length|0))a=Jh();else{for(var b=Kh(new Lh,Jh()),d=0,e=a.length|0;d<e;)Mh(b,a[d]),d=1+d|0;a=b.Ma}this.qk=a;this.a=!0;return this};function dca(){var a;Bi||(Bi=(new Ai).b());a=Bi;if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Shape.scala: 60");return a.qk} Ai.prototype.$classData=g({g_:0},!1,"org.nlogo.core.Shape$LinkLine$",{g_:1,d:1});var Bi=void 0;function eca(a){var b=a.Zx();a=m(new n,function(){return function(a){return a.Dc()}}(a));var d=r();return b.xa(a,d.s)}function fca(a){var b=a.Zx();a=m(new n,function(){return function(a){return a.Vi()}}(a));var d=r();return b.xa(a,d.s)}function Ci(){}Ci.prototype=new l;Ci.prototype.constructor=Ci;Ci.prototype.b=function(){return this}; function gca(a,b){var d=r(),e=b.me(),f=b.Gj,h=b.kE(),k=m(new n,function(){return function(a){var b=a.XD()?"1":"0",b=I(r(),(new w).f([a.WF(),b]));a=a.BC();var d=r();return b.Rc(a,d.s).zb(" ")}}(a)),p=r();return I(d,(new w).f([e,f,h.xa(k,p.s).zb("\n"),hca(a,b.kD())])).zb("\n")}function Di(a){return""+(a.Cp<<24|a.xq<<16|a.Sp<<8|a.Fp)} function ica(a,b){if(b&&b.$classData&&b.$classData.n.zz)return I(r(),(new w).f(["Circle",Di(b.yb),b.$k(),b.gc,b.gk,b.hk,b.EC()])).zb(" ");if(b&&b.$classData&&b.$classData.n.Az)return I(r(),(new w).f(["Line",Di(b.yb),b.gc,b.vv().Vi(),b.vv().Dc(),b.Vt().Vi(),b.Vt().Dc()])).zb(" ");if(b&&b.$classData&&b.$classData.n.Bz){var d=I(r(),(new w).f(["Polygon",Di(b.yb),b.$k(),b.gc]));b=b.Zx();a=m(new n,function(){return function(a){return I(r(),(new w).f([a.Vi(),a.Dc()]))}}(a));var e=r();b=b.aj(a,e.s);a=r(); return d.Rc(b,a.s).zb(" ")}if(b&&b.$classData&&b.$classData.n.Cz)return I(r(),(new w).f(["Rectangle",Di(b.yb),b.$k(),b.gc,b.Pv().Vi(),b.Pv().Dc(),b.Lu().Vi(),b.Lu().Dc()])).zb(" ");throw(new q).j(b);} function jca(a,b){try{var d=!1,e=null,f=(new Sb).c(b),h=Ei(f,32),k=B().s.Uh(),p=h.l.length;switch(p){case -1:break;default:k.tc(p)}k.Yb((new Fi).Gh(h));var t=k.Da();if(Gi(t)){var d=!0,e=t,x=e.Ia;if("Circle"===e.Bb&&Gi(x)){var E=x.Bb,S=x.Ia;if(Gi(S)){var U=S.Bb,ga=S.Ia;if(Gi(ga)){var ma=ga.Bb,va=ga.Ia;if(Gi(va)){var Fa=va.Bb,Va=va.Ia;if(Gi(Va)){var vb=Va.Bb,pb=Va.Ia;if(Gi(pb)){var Ib=pb.Bb,kc=pb.Ia;if(y().o(kc)){var $a=(new Sb).c(E),fc=Hi(),Bc=Ii(Ji(fc,$a.R,10)),sf=(new Sb).c(U),Sf=Ki(sf.R),th=(new Sb).c(ma), Te=Ki(th.R),tf=(new Sb).c(Fa),ek=Ji(Hi(),tf.R,10),og=(new Sb).c(vb),uh=Ji(Hi(),og.R,10),pg=(new Sb).c(Ib),Yh=Hi();return(new Li).qD(Bc,Sf,Te,ek,uh,Ji(Yh,pg.R,10))}}}}}}}}if(d){var Ri=e.Ia;if("Line"===e.Bb&&Gi(Ri)){var fk=Ri.Bb,Si=Ri.Ia;if(Gi(Si)){var gk=Si.Bb,Ti=Si.Ia;if(Gi(Ti)){var vl=Ti.Bb,Ui=Ti.Ia;if(Gi(Ui)){var hk=Ui.Bb,Vi=Ui.Ia;if(Gi(Vi)){var wl=Vi.Bb,vh=Vi.Ia;if(Gi(vh)){var xl=vh.Bb,wh=vh.Ia;if(y().o(wh)){var ik=(new Sb).c(fk),yl=Hi(),Zh=Ii(Ji(yl,ik.R,10)),$h=(new Sb).c(gk),zl=Ki($h.R),Al=(new Sb).c(vl), Bl=Ji(Hi(),Al.R,10),jk=(new Sb).c(hk),Cl=Hi(),Dl=(new Mi).ia(Bl,Ji(Cl,jk.R,10)),El=(new Sb).c(wl),Fl=Ji(Hi(),El.R,10),kk=(new Sb).c(xl),Gl=Hi();return kca(new Ni,Zh,zl,Dl,(new Mi).ia(Fl,Ji(Gl,kk.R,10)))}}}}}}}}if(d){var ai=e.Ia;if("Rectangle"===e.Bb&&Gi(ai)){var lk=ai.Bb,xh=ai.Ia;if(Gi(xh)){var Hl=xh.Bb,Wi=xh.Ia;if(Gi(Wi)){var mk=Wi.Bb,yh=Wi.Ia;if(Gi(yh)){var Uf=yh.Bb,ue=yh.Ia;if(Gi(ue)){var zh=ue.Bb,bi=ue.Ia;if(Gi(bi)){var nk=bi.Bb,Xi=bi.Ia;if(Gi(Xi)){var Il=Xi.Bb,Yi=Xi.Ia;if(y().o(Yi)){var Jl=(new Sb).c(lk), Zi=Hi(),$i=Ii(Ji(Zi,Jl.R,10)),ok=(new Sb).c(Hl),Kl=Ki(ok.R),aj=(new Sb).c(mk),ci=Ki(aj.R),Ll=(new Sb).c(Uf),Rg=Ji(Hi(),Ll.R,10),Sg=(new Sb).c(zh),pk=Hi(),bj=(new Mi).ia(Rg,Ji(pk,Sg.R,10)),Ah=(new Sb).c(nk),qk=Ji(Hi(),Ah.R,10),Ml=(new Sb).c(Il),rk=Hi();return lca(new Oi,$i,Kl,ci,bj,(new Mi).ia(qk,Ji(rk,Ml.R,10)))}}}}}}}}}if(d){var Tg=e.Ia;if("Polygon"===e.Bb&&Gi(Tg)){var Nl=Tg.Bb,cj=Tg.Ia;if(Gi(cj)){var di=cj.Bb,Bh=cj.Ia;if(Gi(Bh)){for(var Ol=Bh.Bb,qg=mca(Bh.Ia),fi=(new bc).Gf(qg,m(new n,function(){return function(a){var b= Pi(a,0),b=(new Sb).c(b),b=Ji(Hi(),b.R,10);a=Pi(a,1);a=(new Sb).c(a);var d=Hi();return(new Mi).ia(b,Ji(d,a.R,10))}}(a))),Ch=null,Ch=I(r(),y());fi.ta();){var dj=fi.ma(),Ug=(new A).e(Ch,dj);a:{var ej=Ug.kb,fj=Ug.Ab;if(null!==fj){var gi=fj.Vi(),hi=fj.Dc();if(0<ej.sa())var gj=ej.$(),Vf=(new Mi).ia(gi,hi),vf=null!==gj&&Ea(gj,Vf);else vf=!1;if(vf){var ae=(new Mi).ia(gi,hi),hj=r(),Ch=ej.fd(ae,hj.s);break a}}var rg=Ug.kb,ij=Ug.Ab;if(null!==ij)var jj=(new Mi).ia(ij.Vi(),ij.Dc()),ii=r(),Ch=rg.fd(jj,ii.s);else throw(new q).j(Ug); }}var ji=Ch.yf(),Pl=(new Sb).c(Nl),sk=Hi(),Vg=Ii(Ji(sk,Pl.R,10)),ki=(new Sb).c(di),Ql=Ki(ki.R),tk=(new Sb).c(Ol);return nca(new Qi,Vg,Ql,Ki(tk.R),ji)}}}}throw(new ye).c(u((new v).K((new w).f(["Invalid shape format in file: ",""])),(new w).f([b])));}catch(ei){if(ei&&ei.$classData&&ei.$classData.n.mn)throw(new ye).c(u((new v).K((new w).f(["Invalid shape format in file: ",""])),(new w).f([b])));throw ei;}} function oca(a,b){a=m(new n,function(a){return function(b){return gca(a,b)}}(a));var d=r();return b.xa(a,d.s).zb("\n\n")} function pca(a,b){var d=function(a){return function(b){return qca(a,b)}}(a);B();var e=(new w).f([y()]),f=B().s;a=b.Gb(L(e,f),tb(new ub,function(){return function(a,b){a=(new A).e(a,b);b=a.kb;var d=a.Ab;if(null!==d&&""===d)return a=y(),Cd(new Dd,a,b);var e=a.kb;b=a.Ab;if(Gi(e)&&(d=e.Bb,e=e.Ia,null!==b))return a=B().s,a=kj(d,b,a),Cd(new Dd,a,e);throw(new q).j(a);}}(a))).Gb(y(),tb(new ub,function(){return function(a,b){if(Gi(a)){var d=a.Bb,e=a.Ia;if(y().o(b))return a=B(),d=d.fd("",a.s),Cd(new Dd,d,e)}return Cd(new Dd, b,a)}}(a))).Pf(m(new n,function(){return function(a){return kd(a)}}(a)));b=B().s;if(b===B().s){if(a===y())return y();b=a.$();e=b=Cd(new Dd,d(b),y());for(a=a.aa();a!==y();)f=a.$(),f=Cd(new Dd,d(f),y()),e=e.Ia=f,a=a.aa();return b}for(b=Mc(a,b);!a.z();)e=a.$(),b.Na(d(e)),a=a.aa();return b.Da()} function rca(a,b){var d=function(a){return function(b){return sca(a,b)}}(a);B();var e=(new w).f([y()]),f=B().s;a=b.Gb(L(e,f),tb(new ub,function(){return function(a,b){a=(new A).e(a,b);b=a.kb;var d=a.Ab;if(null!==d&&""===d)return a=y(),Cd(new Dd,a,b);var e=a.kb;b=a.Ab;if(Gi(e)&&(d=e.Bb,e=e.Ia,null!==b))return a=B().s,a=kj(d,b,a),Cd(new Dd,a,e);throw(new q).j(a);}}(a))).Gb(y(),tb(new ub,function(){return function(a,b){if(Gi(a)){var d=a.Bb,e=a.Ia;if(y().o(b))return a=B(),d=d.fd("",a.s),Cd(new Dd,d,e)}return Cd(new Dd, b,a)}}(a))).Pf(m(new n,function(){return function(a){return kd(a)}}(a)));b=B().s;if(b===B().s){if(a===y())return y();b=a.$();e=b=Cd(new Dd,d(b),y());for(a=a.aa();a!==y();)f=a.$(),f=Cd(new Dd,d(f),y()),e=e.Ia=f,a=a.aa();return b}for(b=Mc(a,b);!a.z();)e=a.$(),b.Na(d(e)),a=a.aa();return b.Da()} function qca(a,b){if(Gi(b)){var d=b.Bb,e=b.Ia;if(Gi(e)){var f=e.Bb,h=e.Ia;if(Gi(h)){var e=h.Bb,k=h.Ia;if(Gi(k)){var h=k.Bb,p=k.Ia;if(Gi(p))return k=p.Bb,b=p.Ia,f=(new Sb).c(f),f=Vh(Wh(),f.R),e=I(r(),(new w).f([e,h,k])),h=m(new n,function(a){return function(b){return tca(a,b)}}(a)),k=r(),uca(new lj,d,f,e.xa(h,k.s),sca(a,b))}}}}throw(new ye).c(u((new v).K((new w).f(["Invalid link shape: ",""])),(new w).f([cc(b,"","\n","")])));}function Ii(a){return vca(new mj,255&a>>16,255&a>>8,255&a,255)} function tca(a,b){var d=!1,e=null,f=(new Sb).c(b),f=Ei(f,32),h=B().s.Uh(),k=f.l.length;switch(k){case -1:break;default:h.tc(k)}h.Yb((new Fi).Gh(f));f=h.Da();if(Gi(f)&&(d=!0,e=f,h=e.Bb,k=e.Ia,Gi(k))){f=k.Ia;if("1"===k.Bb){k=dca();$e();var p=function(){return function(a){a=(new Sb).c(a).R;return ea(Vh(Wh(),a))}}(a),t=B().s;if(t===B().s)if(f===y())p=y();else{for(var t=f.$(),x=t=Cd(new Dd,p(t),y()),E=f.aa();E!==y();)var S=E.$(),S=Cd(new Dd,p(S),y()),x=x.Ia=S,E=E.aa();p=t}else{t=Mc(f,t);for(x=f;!x.z();)E= x.$(),t.Na(p(E)),x=x.aa();p=t.Da()}k=k.ib(wca(p.se(nj())))}else k=!1;if(k){b=(new Sb).c(h);b=Vh(Wh(),b.R);e=function(){return function(a){a=(new Sb).c(a).R;return ea(Vh(Wh(),a))}}(a);a=B().s;if(a===B().s)if(f===y())e=y();else{a=f.$();d=a=Cd(new Dd,e(a),y());for(f=f.aa();f!==y();)h=f.$(),h=Cd(new Dd,e(h),y()),d=d.Ia=h,f=f.aa();e=a}else{for(a=Mc(f,a);!f.z();)d=f.$(),a.Na(e(d)),f=f.aa();e=a.Da()}return(new oj).hu(b,!0,e)}}if(d&&(f=e.Bb,a=e.Ia,Gi(a)&&"1"===a.Bb))return b=(new Sb).c(f),e=Wh(),(new oj).hu(Vh(e, b.R),!0,I(r(),(new w).f([1,0])));if(d&&(f=e.Bb,e=e.Ia,Gi(e)&&"0"===e.Bb))return b=(new Sb).c(f),e=Wh(),(new oj).hu(Vh(e,b.R),!1,I(r(),(new w).f([0,1])));throw(new ye).c(u((new v).K((new w).f(["Invalid link line: ",""])),(new w).f([b])));}function hca(a,b){var d=I(r(),(new w).f([b.me(),b.CE(),b.Nj]));b=b.gh;a=m(new n,function(a){return function(b){return ica(a,b)}}(a));var e=r();b=b.xa(a,e.s);a=r();return d.Rc(b,a.s).zb("\n")} function xca(a,b){a=m(new n,function(a){return function(b){return hca(a,b)}}(a));var d=r();return b.xa(a,d.s).zb("\n\n")} function sca(a,b){if(Gi(b)){var d=b.Bb,e=b.Ia;if(Gi(e)){var f=e.Bb,h=e.Ia;if(Gi(h)){e=h.Ia;b=(new Sb).c(h.Bb);b=Ji(Hi(),b.R,10);a=function(a){return function(b){return jca(a,b)}}(a);h=B().s;if(h===B().s)if(e===y())a=y();else{for(var h=e.$(),k=h=Cd(new Dd,a(h),y()),e=e.aa();e!==y();)var p=e.$(),p=Cd(new Dd,a(p),y()),k=k.Ia=p,e=e.aa();a=h}else{for(h=Mc(e,h);!e.z();)k=e.$(),h.Na(a(k)),e=e.aa();a=h.Da()}return(new pj).JD(d,"true"===f,b,a)}}}throw(new ye).c(u((new v).K((new w).f(["Invalid vector shape:\\n ", ""])),(new w).f([cc(b,"","\n","")])));}Ci.prototype.$classData=g({i_:0},!1,"org.nlogo.core.ShapeParser$",{i_:1,d:1});var qj=void 0;function rj(){qj||(qj=(new Ci).b());return qj}function sj(){this.uS=null;this.a=!1}sj.prototype=new l;sj.prototype.constructor=sj; sj.prototype.b=function(){tj=this;for(var a=uj(),a=(new A).e(a,"__observercode"),b=vj(),b=(new A).e(b,"__turtlecode"),d=wj(),d=(new A).e(d,"__patchcode"),e=xj(),a=[a,b,d,(new A).e(e,"__linkcode")],b=dc(new ec,gc()),d=0,e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.uS=b.Ma;this.a=!0;return this};sj.prototype.$classData=g({j_:0},!1,"org.nlogo.core.SourceWrapping$",{j_:1,d:1});var tj=void 0;function yca(){tj||(tj=(new sj).b());return tj}function yj(){}yj.prototype=new l;yj.prototype.constructor=yj; yj.prototype.b=function(){return this};function zj(a,b){return(new J).j((new ac).ae(b.xd,b.za,b.ra))}yj.prototype.$classData=g({l_:0},!1,"org.nlogo.core.Statement$",{l_:1,d:1});var Aj=void 0;function Bj(){Aj||(Aj=(new yj).b());return Aj}function Cj(){}Cj.prototype=new l;Cj.prototype.constructor=Cj;Cj.prototype.b=function(){return this}; function eh(a,b){a=(new Sb).c(b);b=$e().zp.af(a.R);for(var d=0,e=a.R.length|0;d<e;){var f=a.W(d),f=null===f?0:f.X;switch(f){case 10:f="\\n";break;case 13:f="\\r";break;case 9:f="\\t";break;case 92:f="\\\\";break;case 34:f='\\"';break;default:f=ba.String.fromCharCode(f)}f=(new Sb).c(f).R;b.Yb((new Dj).c(f));d=1+d|0}return b.Da()} function Ej(a,b){for(var d=(new Sb).c(b),e=d.R.length|0,f=0;;){if(f<e)var h=d.W(f),h=92!==(null===h?0:h.X);else h=!1;if(h)f=1+f|0;else break}e=Fj(d,f);if(null===e)throw(new q).j(e);d=e.la();e=e.pa();if(2>((new Sb).c(e).R.length|0))return b;b=zca(65535&(e.charCodeAt(1)|0));b=(new af).Ra(b);e=(new Sb).c(e);f=e.R.length|0;return""+d+b+Ej(a,Ye(Ze(),e.R,2,f))} function zca(a){switch(a){case 110:return 10;case 114:return 13;case 116:return 9;case 92:return 92;case 34:return 34;default:throw(new df).c("invalid escape sequence: \\"+(new af).Ra(a));}}Cj.prototype.$classData=g({m_:0},!1,"org.nlogo.core.StringEscaper$",{m_:1,d:1});var Gj=void 0;function fh(){Gj||(Gj=(new Cj).b());return Gj}function Hj(){}Hj.prototype=new l;Hj.prototype.constructor=Hj;Hj.prototype.b=function(){return this}; function Aca(a,b){var d=Ij();b=b-(b&d)|0;d=Jj();0!==(b&d)?(d=Jj(),b=b-(b&d)|0,d="variable"):(b&Kj())===Kj()?(d=Kj(),b=b-(b&d)|0,d="list or block"):(b&lc())===lc()?(d=lc(),b=b-(b&d)|0,d="anything"):(b&Lj(D()))===Lj(D())?(d=Lj(D())|Mj(D()),b=b-(b&d)|0,d="agent"):(d=N(D()),0!==(b&d)?(d=N(D()),b=b-(b&d)|0,d="number"):(d=Nj(D()),0!==(b&d)?(d=Nj(D()),b=b-(b&d)|0,d="TRUE/FALSE"):(d=Oj(D()),0!==(b&d)?(d=Oj(D()),b=b-(b&d)|0,d="string"):(d=Pj(D()),0!==(b&d)?(d=Pj(D()),b=b-(b&d)|0,d="list"):(b&Qj(D()))===Qj(D())? (d=Qj(D()),b=b-(b&d)|0,d="agentset"):(d=Rj(D()),0!==(b&d)?(d=Rj(D()),b=b-(b&d)|0,d="turtle agentset"):(d=Sj(D()),0!==(b&d)?(d=Sj(D()),b=b-(b&d)|0,d="patch agentset"):(d=Tj(D()),0!==(b&d)?(d=Tj(D()),b=b-(b&d)|0,d="link agentset"):(d=Uj(D()),0!==(b&d)?(d=Uj(D())|Mj(D()),b=b-(b&d)|0,d="turtle"):(d=Vj(D()),0!==(b&d)?(d=Vj(D())|Mj(D()),b=b-(b&d)|0,d="patch"):(d=Wj(D()),0!==(b&d)?(d=Wj(D())|Mj(D()),b=b-(b&d)|0,d="link"):(d=Xj(D()),0!==(b&d)?(d=Xj(D()),b=b-(b&d)|0,d="anonymous reporter"):(d=Yj(D()),0!== (b&d)?(d=Yj(D()),b=b-(b&d)|0,d="anonymous command"):(d=Mj(D()),0!==(b&d)?(d=Mj(D()),b=b-(b&d)|0,d="NOBODY"):(d=Zj(D()),0!==(b&d)?(d=Zj(D()),b=b-(b&d)|0,d="command block"):(b&ak(D()))===ak(D())?(d=ak(D()),b=b-(b&d)|0,d="reporter block"):(d=bk(D()),0!==(b&d)?(d=ak(D()),b=b-(b&d)|0,d="different kind of block"):(d=ck(D()),0!==(b&d)?(d=ck(D()),b=b-(b&d)|0,d="TRUE/FALSE block"):(d=dk(D()),0!==(b&d)?(d=dk(D()),b=b-(b&d)|0,d="number block"):(d=uk(),0!==(b&d)?(d=uk(),b=b-(b&d)|0,d="code block"):(d=xk(),0!== (b&d)?(d=xk(),b=b-(b&d)|0,d="variable"):d="(none)")))))))))))))))))));var e=b;return 0===e?d:yk()===e?d+" (optional)":d+" or "+Aca(a,b)}function zk(a,b){a=Aca(a,b);if("NOBODY"!==a&&"anything"!==a)a:switch(b=(new Sb).c(a),b=Ak(b),b=null===b?0:b.X,Bca(Uh(),b)){case 65:case 69:case 73:case 79:case 85:a="an "+a;break a;default:a="a "+a}return a}Hj.prototype.$classData=g({M_:0},!1,"org.nlogo.core.TypeNames$",{M_:1,d:1});var Bk=void 0;function Ck(){Bk||(Bk=(new Hj).b());return Bk} function Dk(){this.YR=null;this.a=!1}Dk.prototype=new l;Dk.prototype.constructor=Dk;Dk.prototype.b=function(){this.YR="@#$#@#$#@";this.a=!0;return this};function Cca(){var a=Ek();return m(new n,function(){return function(a){return a}}(a))} function Dca(a,b){var d=Fk(),e=nh($e().kk,y()),f=Cca(),h;h=I(pc().Th,y());var k;k=I(pc().Th,y());Gk||(Gk=(new Hk).b());var p;p=Eca;var t=Gk;$e();b=null!==b?(new Dj).c(b):null;p=p(t,b);for(p=(new Ik).ru(p);Jk(p).ta();)t=p.km(),b=Kk(a),0<=(t.length|0)&&t.substring(0,b.length|0)===b?(h=h.mc(k,(Lk(),Mk().qc)),k=I(pc().Th,y())):k=k.mc(t,(Lk(),Mk().qc));h=h.mc(k,(Lk(),Mk().qc));I(pc().Th,y());if(12!==h.sa())throw Kg(Lg(),(new $g).c("Models must have 12 sections, this had "+h.sa()));a=h;var x,E,S,U;pc(); p=(new J).j(a);if(null!==p.U&&0===p.U.Rb(12)){var ga=p.U.W(0),ma=p.U.W(1);a=p.U.W(2);t=p.U.W(3);h=p.U.W(4);k=p.U.W(5);var va=p.U.W(6);b=p.U.W(7);x=p.U.W(8);E=p.U.W(9);S=p.U.W(10);U=p.U.W(11);p=va}else throw(new q).j(a);k;p;b;x;p=E;S;U;k=rca(rj(),t);p=pca(rj(),p);t=cc(ga,"","\n","");x=Fca();E=B().s;b=new Nk;S=L(ma,E);E=I(pc().Th,y());for(ma=I(pc().Th,y());!S.z();){ga=S.$();U=(new Sb).c(ga);if(kd(U))ma=ma.mc(ga,(Lk(),Mk().qc));else{ga=Ok(ma);for(U=!0;U&&ga.qi;){U=ga.ma();if(null===U)throw(new Oe).b(); U=""===U}U||(ga=B().s,E=E.mc(Gca(x,L(ma,ga),d,e,f),(Lk(),Mk().qc)));ma=I(pc().Th,y())}S=S.aa()}S=Ok(ma);for(ga=!0;ga&&S.qi;){ga=S.ma();if(null===ga)throw(new Oe).b();ga=""===ga}ga||(S=B().s,E=E.mc(Gca(x,L(ma,S),d,e,f),(Lk(),Mk().qc)));d=E;e=B().s;d=L(d,e);return Pk(b,t,d,cc(a,"","\n",""),h.$(),k.ub(),p.ub(),I(r(),y()))} function Hca(a,b){return""+b.Zd+u((new v).K((new w).f(["\\n","\\n"])),(new w).f([Kk(a)]))+Ica(Fca(),b.Gc)+u((new v).K((new w).f(["\\n","\\n"])),(new w).f([Kk(a)]))+b.Se+u((new v).K((new w).f(["\\n","\\n"])),(new w).f([Kk(a)]))+xca(rj(),b.Zg)+u((new v).K((new w).f(["\\n","\\n"])),(new w).f([Kk(a)]))+b.Rh+u((new v).K((new w).f(["\\n","\\n"])),(new w).f([Kk(a)]))+u((new v).K((new w).f(["","\\n"])),(new w).f([Kk(a)]))+u((new v).K((new w).f(["","\\n"])),(new w).f([Kk(a)]))+u((new v).K((new w).f(["","\\n"])), (new w).f([Kk(a)]))+u((new v).K((new w).f(["","\\n"])),(new w).f([Kk(a)]))+oca(rj(),b.Lg)+u((new v).K((new w).f(["\\n","\\n"])),(new w).f([Kk(a)]))+u((new v).K((new w).f(["\\n","\\n"])),(new w).f([Kk(a)]))}function Kk(a){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/model/ModelReader.scala: 9");return a.YR}Dk.prototype.$classData=g({V_:0},!1,"org.nlogo.core.model.ModelReader$",{V_:1,d:1});var Qk=void 0; function Ek(){Qk||(Qk=(new Dk).b());return Qk}function Rk(){}Rk.prototype=new l;Rk.prototype.constructor=Rk;Rk.prototype.b=function(){return this}; function Jca(a){var b="";for(;;){var d=a;if(null===d)throw(new Oe).b();if(""===d)return(new A).e(b,a);d=(new Sb).c(a);d=Ak(d);if(34===(null===d?0:d.X))return a=(new Sb).c(a),a=Sk(a),(new A).e(b,a.trim());d=(new Sb).c(a);d=Ye(Ze(),d.R,0,2);null!==d&&'\\"'===d?(a=(new Sb).c(a),d=a.R.length|0,a=Ye(Ze(),a.R,2,d),b+='"'):(d=(new Sb).c(a),d=Sk(d),a=(new Sb).c(a),b=""+b+na(Ak(a)),a=d)}} function Tk(a,b){var d=(new Sb).c(b),d=Uk(d);if(Vk(d)&&(d=d.U,34===(null===d?0:d.X))){b=(new Sb).c(b);d=Jca(Sk(b));if(null===d)throw(new q).j(d);b=d.la();a=Tk(a,d.pa());return Cd(new Dd,b,a)}return y()}function Wk(a){return""+(new af).Ra(34)+a+(new af).Ra(34)}Rk.prototype.$classData=g({Y_:0},!1,"org.nlogo.core.model.PenReader$",{Y_:1,d:1});var Xk=void 0;function Yk(){Xk||(Xk=(new Rk).b());return Xk}function Zk(){this.iT=null;this.a=!1}Zk.prototype=new l;Zk.prototype.constructor=Zk; Zk.prototype.b=function(){$k=this;al||(al=(new bl).b());var a=(new A).e("BUTTON",al);cl||(cl=(new dl).b());var b=(new A).e("SLIDER",cl);el||(el=(new fl).b());var d=(new A).e("GRAPHICS-WINDOW",el);gl||(gl=(new hl).b());var e=(new A).e("MONITOR",gl);il||(il=(new jl).b());var f=(new A).e("SWITCH",il);kl||(kl=(new ll).b());var h=(new A).e("PLOT",kl);ml||(ml=(new nl).b());var k=(new A).e("CHOOSER",ml);ol||(ol=(new pl).b());var p=(new A).e("OUTPUT",ol);ql||(ql=(new rl).b());var t=(new A).e("TEXTBOX",ql); sl||(sl=(new tl).b());a=[a,b,d,e,f,h,k,p,t,(new A).e("INPUTBOX",sl)];b=dc(new ec,gc());d=0;for(e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.iT=b.Ma;this.a=!0;return this};function Gca(a,b,d,e,f){a=Kca(a).Am(e);a=(new Kc).fg(a).oi.rj();a:{for(;a.ta();)if(e=a.ma(),e.RF(b)){a=(new J).j(e);break a}a=F()}if(Vk(a))return a.U.GV(b,d).Ql(f);if(F()===a)throw Kg(Lg(),(new $g).c(u((new v).K((new w).f(["Couldn't find corresponding reader for ",""])),(new w).f([b.$()]))));throw(new q).j(a);} function Ica(a,b){a=m(new n,function(a){return function(b){var d=nh($e().kk,y()),d=Kca(a).Am(d),k=(new Kc).fg(d);Lc();Lc();ul();d=(new jc).b();for(k=k.oi.rj();k.ta();){var p=k.ma(),t;t=p.Pl();var x=b;t=null!==x&&(Rl(t.Cd(),x)||ra(x)&&Sl(t.Cd(),pa(bb))||ta(x)&&Sl(t.Cd(),pa(cb))||ze(x)&&Sl(t.Cd(),pa(ab))||Pa(x)&&Sl(t.Cd(),pa(db))||Ca(x)&&Sl(t.Cd(),pa(eb))||xa(x)&&Sl(t.Cd(),pa(fb))||"number"===typeof x&&Sl(t.Cd(),pa(gb))||"boolean"===typeof x&&Sl(t.Cd(),pa(Za))||void 0===x&&Sl(t.Cd(),pa(Ya)))?(new J).j(x): F();t.z()?p=F():(t=t.Y(),p=(new J).j(p.LT(t)));p=p.ub();Tl(d,p)}d=d.ub();d=Uk(d);if(d.z())throw(new Ul).c("Widget type is not supported: "+oa(b).kh());return d.Y()}}(a));var d=r();return b.xa(a,d.s).zb("\n\n")}function Kca(a){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/model/WidgetReader.scala: 107");return a.iT}Zk.prototype.$classData=g({d0:0},!1,"org.nlogo.core.model.WidgetReader$",{d0:1,d:1});var $k=void 0; function Fca(){$k||($k=(new Zk).b());return $k}function Vl(){}Vl.prototype=new l;Vl.prototype.constructor=Vl;Vl.prototype.b=function(){return this};Vl.prototype.$classData=g({f0:0},!1,"org.nlogo.core.prim.Lambda$",{f0:1,d:1});var Lca=void 0;function Wl(){this.WT=this.lT=this.XT=null;this.a=0}Wl.prototype=new l;Wl.prototype.constructor=Wl; Wl.prototype.b=function(){Xl=this;this.XT="_.?\x3d*!\x3c\x3e:#+/%$^'\x26-";this.a=(1|this.a)<<24>>24;this.lT="0123456789";this.a=(2|this.a)<<24>>24;var a=[(new O).Q(65498,65500,1),(new O).Q(65490,65495,1),(new O).Q(65482,65487,1),(new O).Q(65474,65479,1),(new O).Q(65382,65470,1),(new O).Q(65345,65370,1),(new O).Q(65313,65338,1),(new O).Q(65142,65276,1),(new O).Q(65136,65140,1),(new O).Q(65008,65019,1),(new O).Q(64914,64967,1),(new O).Q(64848,64911,1),(new O).Q(64467,64829,1),(new O).Q(64326,64433, 1),(new O).Q(64323,64324,1),(new O).Q(64320,64321,1),(new O).Q(64318,64318,1),(new O).Q(64312,64316,1),(new O).Q(64298,64310,1),(new O).Q(64287,64296,1),(new O).Q(64285,64285,1),(new O).Q(64275,64279,1),(new O).Q(64256,64262,1),(new O).Q(64112,64217,1),(new O).Q(63744,64109,1),(new O).Q(55243,55291,1),(new O).Q(55216,55238,1),(new O).Q(44032,55203,1),(new O).Q(43968,44002,1),(new O).Q(43816,43822,1),(new O).Q(43808,43814,1),(new O).Q(43793,43798,1),(new O).Q(43785,43790,1),(new O).Q(43777,43782,1), (new O).Q(43762,43764,1),(new O).Q(43744,43754,1),(new O).Q(43739,43741,1),(new O).Q(43714,43714,1),(new O).Q(43712,43712,1),(new O).Q(43705,43709,1),(new O).Q(43701,43702,1),(new O).Q(43697,43697,1),(new O).Q(43648,43695,1),(new O).Q(43642,43642,1),(new O).Q(43616,43638,1),(new O).Q(43588,43595,1),(new O).Q(43584,43586,1),(new O).Q(43520,43560,1),(new O).Q(43471,43471,1),(new O).Q(43396,43442,1),(new O).Q(43360,43388,1),(new O).Q(43312,43334,1),(new O).Q(43274,43301,1),(new O).Q(43259,43259,1),(new O).Q(43250, 43255,1),(new O).Q(43138,43187,1),(new O).Q(43072,43123,1),(new O).Q(43020,43042,1),(new O).Q(43015,43018,1),(new O).Q(43011,43013,1),(new O).Q(43E3,43009,1),(new O).Q(42912,42922,1),(new O).Q(42896,42899,1),(new O).Q(42891,42894,1),(new O).Q(42786,42888,1),(new O).Q(42775,42783,1),(new O).Q(42656,42725,1),(new O).Q(42623,42647,1),(new O).Q(42560,42606,1),(new O).Q(42538,42539,1),(new O).Q(42512,42527,1),(new O).Q(42240,42508,1),(new O).Q(42192,42237,1),(new O).Q(40960,42124,1),(new O).Q(19968,40908, 1),(new O).Q(13312,19893,1),(new O).Q(12784,12799,1),(new O).Q(12704,12730,1),(new O).Q(12593,12686,1),(new O).Q(12549,12589,1),(new O).Q(12540,12543,1),(new O).Q(12449,12538,1),(new O).Q(12445,12447,1),(new O).Q(12353,12438,1),(new O).Q(12347,12348,1),(new O).Q(12337,12341,1),(new O).Q(12293,12294,1),(new O).Q(11823,11823,1),(new O).Q(11736,11742,1),(new O).Q(11728,11734,1),(new O).Q(11720,11726,1),(new O).Q(11712,11718,1),(new O).Q(11704,11710,1),(new O).Q(11696,11702,1),(new O).Q(11688,11694,1), (new O).Q(11680,11686,1),(new O).Q(11648,11670,1),(new O).Q(11631,11631,1),(new O).Q(11568,11623,1),(new O).Q(11565,11565,1),(new O).Q(11559,11559,1),(new O).Q(11520,11557,1),(new O).Q(11506,11507,1),(new O).Q(11499,11502,1),(new O).Q(11360,11492,1),(new O).Q(11312,11358,1),(new O).Q(11264,11310,1),(new O).Q(8579,8580,1),(new O).Q(8526,8526,1),(new O).Q(8517,8521,1),(new O).Q(8508,8511,1),(new O).Q(8495,8505,1),(new O).Q(8490,8493,1),(new O).Q(8488,8488,1),(new O).Q(8486,8486,1),(new O).Q(8484,8484, 1),(new O).Q(8473,8477,1),(new O).Q(8469,8469,1),(new O).Q(8458,8467,1),(new O).Q(8455,8455,1),(new O).Q(8450,8450,1),(new O).Q(8336,8348,1),(new O).Q(8319,8319,1),(new O).Q(8305,8305,1),(new O).Q(8182,8188,1),(new O).Q(8178,8180,1),(new O).Q(8160,8172,1),(new O).Q(8150,8155,1),(new O).Q(8144,8147,1),(new O).Q(8134,8140,1),(new O).Q(8130,8132,1),(new O).Q(8126,8126,1),(new O).Q(8118,8124,1),(new O).Q(8064,8116,1),(new O).Q(8031,8061,1),(new O).Q(8029,8029,1),(new O).Q(8027,8027,1),(new O).Q(8025, 8025,1),(new O).Q(8016,8023,1),(new O).Q(8008,8013,1),(new O).Q(7968,8005,1),(new O).Q(7960,7965,1),(new O).Q(7680,7957,1),(new O).Q(7424,7615,1),(new O).Q(7413,7414,1),(new O).Q(7406,7409,1),(new O).Q(7401,7404,1),(new O).Q(7258,7293,1),(new O).Q(7245,7247,1),(new O).Q(7168,7203,1),(new O).Q(7098,7141,1),(new O).Q(7086,7087,1),(new O).Q(7043,7072,1),(new O).Q(6981,6987,1),(new O).Q(6917,6963,1),(new O).Q(6823,6823,1),(new O).Q(6688,6740,1),(new O).Q(6656,6678,1),(new O).Q(6593,6599,1),(new O).Q(6528, 6571,1),(new O).Q(6512,6516,1),(new O).Q(6480,6509,1),(new O).Q(6400,6428,1),(new O).Q(6320,6389,1),(new O).Q(6314,6314,1),(new O).Q(6272,6312,1),(new O).Q(6176,6263,1),(new O).Q(6108,6108,1),(new O).Q(6103,6103,1),(new O).Q(6016,6067,1),(new O).Q(5998,6E3,1),(new O).Q(5984,5996,1),(new O).Q(5952,5969,1),(new O).Q(5920,5937,1),(new O).Q(5902,5905,1),(new O).Q(5888,5900,1),(new O).Q(5792,5866,1),(new O).Q(5761,5786,1),(new O).Q(5743,5759,1),(new O).Q(5121,5740,1),(new O).Q(5024,5108,1),(new O).Q(4992, 5007,1),(new O).Q(4888,4954,1),(new O).Q(4882,4885,1),(new O).Q(4824,4880,1),(new O).Q(4808,4822,1),(new O).Q(4802,4805,1),(new O).Q(4800,4800,1),(new O).Q(4792,4798,1),(new O).Q(4786,4789,1),(new O).Q(4752,4784,1),(new O).Q(4746,4749,1),(new O).Q(4704,4744,1),(new O).Q(4698,4701,1),(new O).Q(4696,4696,1),(new O).Q(4688,4694,1),(new O).Q(4682,4685,1),(new O).Q(4348,4680,1),(new O).Q(4304,4346,1),(new O).Q(4301,4301,1),(new O).Q(4295,4295,1),(new O).Q(4256,4293,1),(new O).Q(4238,4238,1),(new O).Q(4213, 4225,1),(new O).Q(4206,4208,1),(new O).Q(4197,4198,1),(new O).Q(4193,4193,1),(new O).Q(4186,4189,1),(new O).Q(4176,4181,1),(new O).Q(4159,4159,1),(new O).Q(4096,4138,1),(new O).Q(3976,3980,1),(new O).Q(3913,3948,1),(new O).Q(3904,3911,1),(new O).Q(3840,3840,1),(new O).Q(3804,3807,1),(new O).Q(3782,3782,1),(new O).Q(3776,3780,1),(new O).Q(3773,3773,1),(new O).Q(3762,3763,1),(new O).Q(3757,3760,1),(new O).Q(3754,3755,1),(new O).Q(3751,3751,1),(new O).Q(3749,3749,1),(new O).Q(3745,3747,1),(new O).Q(3737, 3743,1),(new O).Q(3732,3735,1),(new O).Q(3725,3725,1),(new O).Q(3722,3722,1),(new O).Q(3719,3720,1),(new O).Q(3716,3716,1),(new O).Q(3713,3714,1),(new O).Q(3648,3654,1),(new O).Q(3634,3635,1),(new O).Q(3585,3632,1),(new O).Q(3520,3526,1),(new O).Q(3517,3517,1),(new O).Q(3507,3515,1),(new O).Q(3482,3505,1),(new O).Q(3461,3478,1),(new O).Q(3450,3455,1),(new O).Q(3424,3425,1),(new O).Q(3406,3406,1),(new O).Q(3389,3389,1),(new O).Q(3346,3386,1),(new O).Q(3342,3344,1),(new O).Q(3333,3340,1),(new O).Q(3313, 3314,1),(new O).Q(3296,3297,1),(new O).Q(3294,3294,1),(new O).Q(3261,3261,1),(new O).Q(3253,3257,1),(new O).Q(3242,3251,1),(new O).Q(3218,3240,1),(new O).Q(3214,3216,1),(new O).Q(3205,3212,1),(new O).Q(3168,3169,1),(new O).Q(3160,3161,1),(new O).Q(3133,3133,1),(new O).Q(3125,3129,1),(new O).Q(3114,3123,1),(new O).Q(3090,3112,1),(new O).Q(3086,3088,1),(new O).Q(3077,3084,1),(new O).Q(3024,3024,1),(new O).Q(2990,3001,1),(new O).Q(2984,2986,1),(new O).Q(2979,2980,1),(new O).Q(2974,2975,1),(new O).Q(2972, 2972,1),(new O).Q(2969,2970,1),(new O).Q(2962,2965,1),(new O).Q(2958,2960,1),(new O).Q(2949,2954,1),(new O).Q(2947,2947,1),(new O).Q(2929,2929,1),(new O).Q(2911,2913,1),(new O).Q(2908,2909,1),(new O).Q(2877,2877,1),(new O).Q(2869,2873,1),(new O).Q(2866,2867,1),(new O).Q(2858,2864,1),(new O).Q(2835,2856,1),(new O).Q(2831,2832,1),(new O).Q(2821,2828,1),(new O).Q(2784,2785,1),(new O).Q(2768,2768,1),(new O).Q(2749,2749,1),(new O).Q(2741,2745,1),(new O).Q(2738,2739,1),(new O).Q(2730,2736,1),(new O).Q(2707, 2728,1),(new O).Q(2703,2705,1),(new O).Q(2693,2701,1),(new O).Q(2674,2676,1),(new O).Q(2654,2654,1),(new O).Q(2649,2652,1),(new O).Q(2616,2617,1),(new O).Q(2613,2614,1),(new O).Q(2610,2611,1),(new O).Q(2602,2608,1),(new O).Q(2579,2600,1),(new O).Q(2575,2576,1),(new O).Q(2565,2570,1),(new O).Q(2544,2545,1),(new O).Q(2527,2529,1),(new O).Q(2524,2525,1),(new O).Q(2510,2510,1),(new O).Q(2493,2493,1),(new O).Q(2486,2489,1),(new O).Q(2482,2482,1),(new O).Q(2474,2480,1),(new O).Q(2451,2472,1),(new O).Q(2447, 2448,1),(new O).Q(2437,2444,1),(new O).Q(2425,2431,1),(new O).Q(2417,2423,1),(new O).Q(2392,2401,1),(new O).Q(2384,2384,1),(new O).Q(2365,2365,1),(new O).Q(2308,2361,1),(new O).Q(2210,2220,1),(new O).Q(2208,2208,1),(new O).Q(2112,2136,1),(new O).Q(2088,2088,1),(new O).Q(2084,2084,1),(new O).Q(2074,2074,1),(new O).Q(2048,2069,1),(new O).Q(2042,2042,1),(new O).Q(2036,2037,1),(new O).Q(1994,2026,1),(new O).Q(1969,1969,1),(new O).Q(1869,1957,1),(new O).Q(1810,1839,1),(new O).Q(1808,1808,1),(new O).Q(1791, 1791,1),(new O).Q(1786,1788,1),(new O).Q(1774,1775,1),(new O).Q(1765,1766,1),(new O).Q(1749,1749,1),(new O).Q(1649,1747,1),(new O).Q(1646,1647,1),(new O).Q(1568,1610,1),(new O).Q(1520,1522,1),(new O).Q(1488,1514,1),(new O).Q(1377,1415,1),(new O).Q(1369,1369,1),(new O).Q(1329,1366,1),(new O).Q(1162,1319,1),(new O).Q(1015,1153,1),(new O).Q(931,1013,1),(new O).Q(910,929,1),(new O).Q(908,908,1),(new O).Q(904,906,1),(new O).Q(902,902,1),(new O).Q(890,893,1),(new O).Q(886,887,1),(new O).Q(880,884,1),(new O).Q(750, 750,1),(new O).Q(748,748,1),(new O).Q(736,740,1),(new O).Q(710,721,1),(new O).Q(248,705,1),(new O).Q(216,246,1),(new O).Q(192,214,1),(new O).Q(186,186,1),(new O).Q(181,181,1),(new O).Q(170,170,1),(new O).Q(97,122,1),(new O).Q(65,90,1)];if(0===(a.length|0))a=Jh();else{for(var b=Kh(new Lh,Jh()),d=0,e=a.length|0;d<e;)Mh(b,a[d]),d=1+d|0;a=b.Ma}b=I(Yl(),y());a=Zl(a,b,tb(new ub,function(){return function(a,b){var d=$l(),d=cm(d);b=L(b,d);return dm(a,b)}}(this)));if(0===(2&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/lex/Charset.scala: 9"); b=(new Sb).c(this.lT);$e();for(var d=Mc(b,new em),e=0,f=b.R.length|0;e<f;){var h=b.W(e);d.Na(null===h?0:h.X);e=1+e|0}b=d.Da().ed();if(0===(1&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/lex/Charset.scala: 8");d=(new Sb).c(this.XT);$e();e=Mc(d,new em);f=0;for(h=d.R.length|0;f<h;){var k=d.W(f);e.Na(null===k?0:k.X);f=1+f|0}this.WT=a.qp(b.qp(e.Da().ed()));this.a=(4|this.a)<<24>>24;return this}; function Mca(){var a;Xl||(Xl=(new Wl).b());a=Xl;if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/lex/Charset.scala: 11");return a.WT}Wl.prototype.$classData=g({o0:0},!1,"org.nlogo.lex.Charset$",{o0:1,d:1});var Xl=void 0;function fm(){}fm.prototype=new l;fm.prototype.constructor=fm;function Nca(a,b){return m(new n,function(a,b){return function(a){return b.y((new af).Ra(null===a?0:a.X))?gm():hm()}}(a,b))}fm.prototype.b=function(){return this}; function im(a,b){return jm(a,b,tb(new ub,function(){return function(a,b){a:for(b=null===b?0:b.X;;){var f=a.$().y((new af).Ra(b));if(f===hm()&&a.aa().He())a=a.aa();else{a=f===hm()?(new A).e(I(r(),y()),hm()):(new A).e(a,f);break a}}return a}}(a)))}function Oca(a,b){return jm(a,!1,tb(new ub,function(a,b){return function(a,d){d=null===d?0:d.X;return a?(new A).e(!0,hm()):(new A).e(!0,b.y((new af).Ra(d)))}}(a,b)))} function km(a,b){return jm(a,b,tb(new ub,function(a){return function(b,f){f=null===f?0:f.X;if(b.z())return(new A).e(b,hm());f=m(new n,function(a,b){return function(a){return a.y((new af).Ra(b))}}(a,f));var h=r();f=b.xa(f,h.s);h=r();b=b.De(f,h.s).Pf(m(new n,function(){return function(a){a=a.pa();var b=gm();return null!==a&&Ea(a,b)}}(a)));var h=m(new n,function(){return function(a){return a.la()}}(a)),k=r();b=b.xa(h,k.s);return(new A).e(b,f.Wj(tb(new ub,function(){return function(a,b){return a.tE(b)}}(a))))}}(a)))} function lm(a,b){return Oca(a,m(new n,function(a,b){return function(a){return b.y((new af).Ra(null===a?0:a.X))?gm():mm()}}(a,b)))}function jm(a,b,d){b=(new nm).j(b);return m(new n,function(a,b,d){return function(a){a=rb(b,d.Ba,(new af).Ra(null===a?0:a.X));if(null===a)throw(new q).j(a);var e=a.pa();d.Ba=a.la();return e}}(a,d,b))}function Pca(a,b){return im(a,(new w).f([lm(a,b),m(new n,function(a,b){return function(a){return b.y((new af).Ra(null===a?0:a.X))?gm():hm()}}(a,b))]))} fm.prototype.$classData=g({r0:0},!1,"org.nlogo.lex.LexOperations$",{r0:1,d:1});var om=void 0;function pm(){om||(om=(new fm).b());return om}function qm(){}qm.prototype=new l;qm.prototype.constructor=qm;qm.prototype.b=function(){return this};function rm(a){var b;sm||(sm=(new qm).b());b=sm;return jm(pm(),!1,tb(new ub,function(a,b){return function(a,d){d=null===d?0:d.X;return a?(new A).e(!0,hm()):(new A).e(!0,d===b?gm():mm())}}(b,a)))} qm.prototype.$classData=g({s0:0},!1,"org.nlogo.lex.LexOperations$PrefixConversions$",{s0:1,d:1});var sm=void 0;function tm(){this.RV=null;this.a=!1}tm.prototype=new l;tm.prototype.constructor=tm;function Qca(){}Qca.prototype=tm.prototype; tm.prototype.b=function(){um||(um=(new vm).b());var a=(new A).e(",",um),b=Rca(),b=(new A).e("{",b);wm||(wm=(new xm).b());for(var d=(new A).e("}",wm),e=ym(),e=(new A).e("(",e),f=zm(),f=(new A).e(")",f),h=Am(),h=(new A).e("[",h),k=Bm(),a=[a,b,d,e,f,h,(new A).e("]",k)],b=dc(new ec,gc()),d=0,e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.RV=b.Ma;this.a=!0;return this}; function Sca(a){return(new A).e(lm(pm(),m(new n,function(a){return function(d){var e=null===d?0:d.X;d=Tca(a);e=ba.String.fromCharCode(e);return d.ib(e)}}(a))),m(new n,function(a){return function(d){var e=Tca(a).dc(d);if(e.z())return F();e=e.Y();return(new J).j((new ac).ae(d,e,null))}}(a)))} function Uca(a){return(new A).e(Pca(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return Mca().ib(a)}}(a))),m(new n,function(){return function(a){return(new J).j((new ac).ae(a,Cm(),a.toUpperCase()))}}(a)))}function Vca(a){return(new A).e(im(pm(),(new w).f([rm(59),Nca(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return 13!==a&&10!==a}}(a)))])),m(new n,function(){return function(a){return(new J).j((new ac).ae(a,Dm(),null))}}(a)))} tm.prototype.lC=function(a){return a.ta()?(a=I(r(),(new w).f([Wca(this),Sca(this),Vca(this),Xca(this),Yca(this),Uca(this),Zca(this)])).Gb((new A).e(F(),a),tb(new ub,function(){return function(a,d){d=(new A).e(a,d);var e=d.kb;a=d.Ab;if(null!==e){var f=e.la(),e=e.pa();if(Vk(f)&&(f=f.U,null!==a))return(new A).e((new J).j(f),e)}a=d.kb;e=d.Ab;if(null!==a&&(f=a.la(),a=a.pa(),F()===f&&null!==e)){f=e.pa();d=a.Zo;e=e.la();Em(a.nk);b:{var h=(new Fm).b();c:for(;;){var k=$ca(a);if(Vk(k)&&(k=k.U,k=null===k?0: k.X,e.y((new af).Ra(k)).dw())){h=Gm(h,k);continue c}e=h.vc.Zb;break b}}a.nk.zq();k=e.length|0;h=a.nk;k=(new Vb).ia(k,k>>31);h.Cn.uv(k);Hm(h,Im(h)-k.ka|0);a.Zo=a.Zo+(e.length|0)|0;e=(new A).e(e,a);if(null===e)throw(new q).j(e);h=e.la();e=e.pa();if(""===h)f=F();else if(f=f.y(h),f.z())f=F();else{f=f.Y();if(null===f)throw(new q).j(f);f=(new J).j((new A).e(Jm(new Km,f.gb,f.Fb,f.og,Lm(new Mm,d,e.Zo,a.ab)),a))}f.z()?(a.nk.zq(),a.Zo=d,d=F()):d=f;d.z()?d=F():(d=d.Y(),d=(new J).j((new A).e((new J).j(d.la()), d.pa())));return d.z()?(new A).e(F(),a):d.Y()}throw(new q).j(d);}}(this))),(new A).e(a.la().Y(),a.pa())):(new A).e(Nm(),a)};function Zca(a){return(new A).e(Oca(pm(),m(new n,function(){return function(){return gm()}}(a))),m(new n,function(){return function(a){return(new J).j((new ac).ae(a,Om(),"This non-standard character is not allowed."))}}(a)))} function Xca(a){return(new A).e(im(pm(),(new w).f([km(pm(),(new w).f([lm(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return Th(Uh(),a)}}(a))),im(pm(),(new w).f([km(pm(),(new w).f([rm(46),rm(45)])),km(pm(),(new w).f([lm(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return Th(Uh(),a)}}(a))),im(pm(),(new w).f([rm(46),lm(pm(),m(new n,function(){return function(a){a=null===a?0:a.X;return Th(Uh(),a)}}(a)))]))]))]))])),Nca(pm(),m(new n,function(){return function(a){a=null=== a?0:a.X;return Mca().ib(a)}}(a)))])),m(new n,function(){return function(a){a:{for(var d=(new Sb).c(a),e=0;;){if(e<(d.R.length|0))var f=d.W(e),f=null===f?0:f.X,f=!1===Th(Uh(),f);else f=!1;if(f)e=1+e|0;else break}if(e!==(d.R.length|0)){d=Sh(qi(),a);if(Pm(d)){d=d.U;a=(new J).j((new ac).ae(a,Om(),d));break a}if(Qm(d)){d=d.U;a=(new J).j((new ac).ae(a,Rm(),d));break a}throw(new q).j(d);}a=F()}return a}}(a)))} function Yca(a){return(new A).e(im(pm(),(new w).f([rm(34),ada(a),rm(34)])),m(new n,function(){return function(a){var d;var e=(new Sb).c(a),e=Sm(e,1),e=(new Sb).c(e),f=e.R.length|0,h=0,k=!1;b:for(;;){if(h!==f){var p=1+h|0,h=e.W(h),h=null===h?0:h.X,k=!(!0===!!k&&92===h)&&92===h,h=p;continue b}break}e=!!k;try{if(1===(a.length|0))var t=!0;else var x=(new Sb).c(a),E=Tm(x),t=34!==(null===E?0:E.X);if(t||e)d=(new J).j((new ac).ae(u((new v).K((new w).f(["",""])),(new w).f([a])),Om(),"Closing double quote is missing")); else{var S=fh(),U=(new Sb).c(a),ga=U.R.length|0,ma=Ye(Ze(),U.R,1,ga),va=(new Sb).c(ma),Fa=Ej(S,Sm(va,1));d=(new J).j((new ac).ae(u((new v).K((new w).f(["",""])),(new w).f([a])),Rm(),Fa))}}catch(Va){if(Va&&Va.$classData&&Va.$classData.n.mn)d=(new J).j((new ac).ae(u((new v).K((new w).f(["",""])),(new w).f([a])),Om(),"Illegal character after backslash"));else throw Va;}return d}}(a)))} function ada(a){return jm(pm(),(new J).j((new af).Ra(34)),tb(new ub,function(){return function(a,d){d=null===d?0:d.X;if(Vk(a)){var e=a.U;if(92===(null===e?0:e.X)&&34===d)return(new A).e((new J).j((new af).Ra(34)),gm())}return Vk(a)&&(a=a.U,92===(null===a?0:a.X)&&92===d)?(new A).e(F(),gm()):34===d?(new A).e((new J).j((new af).Ra(34)),hm()):10===d?(new A).e(F(),mm()):(new A).e((new J).j((new af).Ra(d)),gm())}}(a)))} function Tca(a){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/TokenLexer.scala: 12");return a.RV} function Wca(a){var b=bda(a);return(new A).e(im(pm(),(new w).f([b,km(pm(),(new w).f([rm(125),rm(10),rm(13)]))])),m(new n,function(){return function(a){var b=(new Sb).c(a),b=Ye(Ze(),b.R,0,2);if(null===b||"{{"!==b)a=F();else if(b=(new Sb).c(a),b=Tm(b),10===(null===b?0:b.X)?b=!0:(b=(new Sb).c(a),b=Tm(b),b=13===(null===b?0:b.X)),b)a=(new J).j((new ac).ae("",Om(),"End of line reached unexpectedly"));else{var b=(new Sb).c(a),f=F(),h=b.R.length|0,k=0,p=0,t=f;b:for(;;){if(k!==h){f=1+k|0;k=b.W(k);k=null=== k?0:k.X;p|=0;c:{if(Vk(t)){var x=t.U;if(123===(null===x?0:x.X)&&123===k){p=1+p|0;t=k=F();break c}}if(Vk(t)&&(t=t.U,125===(null===t?0:t.X)&&125===k)){p=-1+p|0;t=k=F();break c}t=k=(new J).j((new af).Ra(k))}k=f;continue b}break}a=0<(p|0)?(new J).j((new ac).ae("",Om(),"End of file reached unexpectedly")):(new J).j((new ac).ae(a,cda(),a))}return a}}(a,b)))}function Um(){}Um.prototype=new l;Um.prototype.constructor=Um;Um.prototype.b=function(){return this}; function dda(a,b){eda||(eda=(new Vm).b());if((a=(new Wm).c(a))&&a.$classData&&a.$classData.n.VG)b=(new Xm).iU(a,0,b);else{var d=new Xm;Xm.prototype.iU.call(d,fda(a),0,b);b=d}return b}Um.prototype.$classData=g({x0:0},!1,"org.nlogo.lex.WrapStringInput$",{x0:1,d:1});var gda=void 0;function Vm(){}Vm.prototype=new l;Vm.prototype.constructor=Vm;Vm.prototype.b=function(){return this};Vm.prototype.$classData=g({y0:0},!1,"org.nlogo.lex.WrappedInput$",{y0:1,d:1});var eda=void 0;function Ym(){this.CC=null} Ym.prototype=new l;Ym.prototype.constructor=Ym;function hda(a){var b=ida(a);a.CC.wa(m(new n,function(a){return function(b){var d=Zm(a,"OTPL");Ob(d,b.fe);b.ji.M(d.h)}}(a)));var d=ida(a);(null===d?null===b:d.o(b))||hda(a)}function ida(a){var b=a.CC;a=m(new n,function(){return function(a){return a.ji.N()}}(a));var d=r();return b.xa(a,d.s).ub()}Ym.prototype.K=function(a){this.CC=a;return this};Ym.prototype.$classData=g({z0:0},!1,"org.nlogo.parse.AgentTypeChecker",{z0:1,d:1});function $m(){} $m.prototype=new l;$m.prototype.constructor=$m;$m.prototype.b=function(){return this}; function jda(a,b,d){for(;;){var e=b.$(),f=(new an).Ff(e).li.jb,h=Bm();if(null!==f&&f===h)return(new ac).ae((new bn).K(a),b.aa().aa(),d);kda((new an).Ff(e),d)?lda(cn(),dn(d,e.Wb.toUpperCase()),e):("-\x3e"===(new an).Ff(e).li.Wb?f=!0:(f=e.jb,h=vg(),f=!(null!==f&&f===h)),f?(kh(),f=u((new v).K((new w).f(["Expected a variable name here"])),y()),e=e.ra,jh(f,e.Xa,e.Va,e.ab)):(f=r(),a=a.mc(e,f.s),b=b.aa(),f=r(),d=e=rc(d,I(f,(new w).f([e.Wb.toUpperCase()])),en())))}} function mda(a,b){var d=a.$();if(fn((new an).Ff(d)))d=(new J).j(jda(I(r(),y()),a.aa(),b));else if(d=a.$(),"-\x3e"===(new an).Ff(d).li.Wb)d=(new J).j((new ac).ae((new gn).td(!0),a.aa(),b));else if(fn((new an).Ff(d)))d=F();else if(kda((new an).Ff(d),b))d=nda(I(r(),(new w).f([d])),a.aa(),b);else{a=a.aa();var e=r();b=rc(b,I(e,(new w).f([d.Wb.toUpperCase()])),en());e=a.$();if("-\x3e"===(new an).Ff(e).li.Wb){var e=d.jb,f=Cm();null!==e&&e===f||hn(d.X)||oda(d.X)?d=(new J).j((new ac).ae((new jn).Ff(d),a.aa(), b)):(kh(),a=u((new v).K((new w).f(["Expected a variable name here"])),y()),d=d.ra,jh(a,d.Xa,d.Va,d.ab),d=void 0)}else var f=e.jb,h=Am(),d=null!==f&&f===h?F():nda(I(r(),(new w).f([d,e])),a.aa(),b)}return d} function pda(a,b,d){if(b.le(m(new n,function(){return function(a){return"-\x3e"===a.Wb}}(a)))){var e=b.wg();if(e.z())e=!1;else var e=e.Y().jb,f=Am(),e=null!==e&&e===f}else e=!1;e?(e=b.nn(),e.z()?e=!1:(e=e.Y().jb,f=Bm(),e=null!==e&&e===f)):e=!1;if(e){b=b.$d(1).Qd(1);d=mda(b,d);if(d.z())return F();e=d.Y();if(null!==e)d=e.gb,b=e.Fb,e=e.og,a=m(new n,function(a,b){return function(a){if(null!==a){var d=a.Wb,e=a.jb,f=a.X;if(vg()===e&&hn(f)&&b.lk().ib(a.Wb.toUpperCase()))return Gh(a,(new kn).ID(d.toUpperCase(), !1),a.Wb,a.jb)}return a}}(a,d)),f=r(),a=b.xa(a,f.s),a=(new ac).ae(d,a,e);else throw(new q).j(e);return(new J).j(a)}return F()}function nda(a,b,d){for(;;){var e=b.$();if("-\x3e"===(new an).Ff(e).li.Wb)if(1<a.sa()){kh();var f=a.$().Lc().Xa,h=a.gd();jh("An anonymous procedures of two or more arguments must enclose its argument list in brackets",f,h.Lc().Va,e.ra.ab)}else e=a.$(),lda(cn(),dn(d,e.Wb.toUpperCase()),e);else{if(fn((new an).Ff(e)))return F();f=r();a=a.mc(e,f.s);b=b.aa()}}} $m.prototype.$classData=g({E0:0},!1,"org.nlogo.parse.ArrowLambdaScoper$",{E0:1,d:1});var ln=void 0;function an(){this.li=null}an.prototype=new l;an.prototype.constructor=an;function kda(a,b){return mn(b,a.li.Wb.toUpperCase())?!oda(a.li.X):!1}an.prototype.Ff=function(a){this.li=a;return this};function fn(a){a=a.li.jb;var b=Am();return null!==a&&a===b}an.prototype.$classData=g({F0:0},!1,"org.nlogo.parse.ArrowLambdaScoper$RichToken$2",{F0:1,d:1});function nn(){this.ZS=this.AV=this.PS=null;this.a=0} nn.prototype=new l;nn.prototype.constructor=nn; nn.prototype.b=function(){on=this;for(var a=Xba(),b=null,b=[],d=a.l.length,e=0;e<d;){var f=(new A).e(a.l[e],e);b.push(f);e=1+e|0}a=ka(Xa(pn),b);a=Xb(new Yb,(new qn).Gh(a),m(new n,function(){return function(a){return null!==a}}(this)));b=m(new n,function(){return function(a){if(null!==a){var b=a.Dc();a=a.la().toUpperCase();b=Yba(dh(),b);return(new A).e(a,b)}throw(new q).j(a);}}(this));d=(new rn).xg(pa(pn));a.ga.wa(m(new n,function(a,b,d){return function(e){return a.ol.y(e)?d.Na(b.y(e)):void 0}}(a, b,d)));a=d.Da();b=dc(new ec,gc());d=0;for(e=a.l.length;d<e;)hc(b,a.l[d]),d=1+d|0;a=b.Ma;b=dh();d=Xba();e=d.l.length;for(f=0;;){if(f<e)var h=d.l[f],h=!sn(tn(),"gray",h);else h=!1;if(h)f=1+f|0;else break}e=f;b=Yba(b,e>=d.l.length?-1:e);this.PS=a.vj((new A).e("GREY",b));this.a=(1|this.a)<<24>>24;a=(new A).e("FALSE",!1);b=(new A).e("TRUE",!0);d=Ph();a=[a,b,(new A).e("NOBODY",d),(new A).e("E",2.718281828459045),(new A).e("PI",3.141592653589793)];b=dc(new ec,gc());d=0;for(e=a.length|0;d<e;)hc(b,a[d]),d= 1+d|0;this.AV=b.Ma;this.a=(2|this.a)<<24>>24;if(0===(2&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/Constants.scala: 13");this.ZS=this.AV.Am(qda(this));this.a=(4|this.a)<<24>>24;return this};function qda(a){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/Constants.scala: 10");return a.PS} nn.prototype.es=function(a){if(0===(4&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/Constants.scala: 20");return this.ZS.dc(a.toUpperCase())};nn.prototype.$classData=g({O0:0},!1,"org.nlogo.parse.Constants$",{O0:1,d:1});var on=void 0;function un(){}un.prototype=new l;un.prototype.constructor=un;un.prototype.b=function(){return this};un.prototype.$classData=g({R0:0},!1,"org.nlogo.parse.DelayedBlock$",{R0:1,d:1});var rda=void 0; function Cc(){this.DR=0;this.GR=this.FR=this.ER=this.OG=this.HG=this.FG=this.EG=this.GG=null;this.a=0}Cc.prototype=new l;Cc.prototype.constructor=Cc; function sda(a,b,d,e,f,h){var k=I(Ec(),y()),p=vn(b),t=-1+p|0;if(!(0>=p))for(p=0;;){var x=p,E=b.Pa,S=-1+wn(b.Pa)|0;k.uj(xn(a,b,f,d,e,Pi(E,x<S?x:S)|0,h));if(p===t)break;p=1+p|0}yn(b)&&(t=f.$().jb,p=Am(),null!==t&&t===p?d=xn(a,b,f,d,e,zn(b.Pa)|0,h):(a=f.$().Lc().ab,b=k.nn(),b.z()?b=F():(b=b.Y(),b=(new J).j(b.Lc().Va)),d=(b.z()?d.Va:b.Y())|0,d=Bb(new Cb,(new Fb).c(a),Lm(new Mm,d,d,a),!0)),k.uj(d));return k.Hc()} Cc.prototype.b=function(){Ac=this;this.DR=-1;this.a|=1;this.GG="Expected command.";this.a|=2;this.EG="Expected closing bracket.";this.a|=4;this.FG="Expected a closing parenthesis here.";this.a|=8;this.HG="Expected reporter.";this.a|=16;this.OG="To use a non-default number of inputs, you need to put parentheses around this.";this.a|=32;this.ER="No closing bracket for this open bracket.";this.a|=64;this.FR="No closing parenthesis for this open parenthesis.";this.a|=128;this.GR="Missing input on the left."; this.a|=256;return this};function tda(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,An(a)?" on the right":"")} function uda(a,b,d,e,f,h){if(d&&En(b)){d=e.Lc();var k=Eh(e.Bx());a:{var p=b.Pa,t=I(r(),y());for(;;){var x=f.$();if(null!==x){var E=x.jb;if(zm()===E){f=t;break a}}if(null!==x&&(E=x.jb,x=x.X,vg()===E&&x&&x.$classData&&x.$classData.n.ca&&(p.$()|0)!==Xj(D())&&An(x.G()))){kh();if(t.Ga()!==Fn(b)){f=a;if(0===(32&f.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 702");jh(f.OG,d.Xa,d.Va,d.ab)}f=t;break a}x=xn(a,b,f,d,k,p.$()|0,h);p=p.aa().He()? p.aa():p;E=r();t=t.mc(x,E.s)}}}else d=e.Lc(),f=sda(a,b,d,Eh(e.Bx()),f,h);d=e.Lc();return vda(a,b,f,d,Eh(e.Bx()),h)} function wda(a,b,d,e){var f=b.Gy().aa().Oa().Om(),h=!Gn(D(),d,Pj(D()));if(Gn(D(),d,uk())){if(b&&b.$classData&&b.$classData.n.GP)a=b.gC;else{if(!(b&&b.$classData&&b.$classData.n.FP))throw(new q).j(b);a=b.Gy()}d=a.Qd(2);e=I(r(),y());a:for(;;){if(d.z())e.z()||(d=e.$().jb,e=ym(),null!==d&&d===e&&(kh(),d=b.Gy().gd().Lc(),jh("Expected close paren here",d.Xa,d.Va,d.ab)));else{f=d.$().jb;h=Am();null!==f&&f===h?(f=d.aa(),d=d.$(),h=r(),e=e.fd(d,h.s),d=f):(f=d.$().jb,h=ym(),null!==f&&f===h?(f=d.aa(),d=d.$(), h=r(),e=e.fd(d,h.s),d=f):(f=d.$().jb,h=Bm(),null!==f&&f===h?(e.z()?f=!1:(f=e.$().jb,h=ym(),f=null!==f&&f===h),f&&(kh(),f=d.$().Lc(),jh("Expected close paren before close bracket here",f.Xa,f.Va,f.ab)),e.z()?f=!0:(f=e.$().jb,h=Am(),f=!(null!==f&&f===h)),f&&(kh(),f=d.$().Lc(),jh("Closing bracket has no matching open bracket here",f.Xa,f.Va,f.ab)),d=d.aa(),e=e.aa()):(f=d.$().jb,h=zm(),null!==f&&f===h?(e.z()?f=!1:(f=e.$().jb,h=Am(),f=null!==f&&f===h),f&&(kh(),f=d.$().Lc(),jh("Expected close bracket before close paren here", f.Xa,f.Va,f.ab)),e.z()?f=!0:(f=e.$().jb,h=ym(),f=!(null!==f&&f===h)),f&&(kh(),f=d.$().Lc(),jh("Closing paren has no matching open paren here",f.Xa,f.Va,f.ab)),d=d.aa(),e=e.aa()):d=d.aa())));continue a}break}d=(new Hn).K(a.aa().Qd(2));d.L(a.$());e=a.$().Lc().Xa;b=b.Lc().Va;a=a.$();return In(new Kb,d,Lm(new Mm,e,b,a.Lc().ab))}if(b.OD()&&!b.zu())return xda(a,b.ve,b,f);if(b.OD()&&b.zu())return yda(a,b.ve,b,f);if(Gn(D(),d,ak(D()))){a=zda(a,d,e,b,f);if(null===a)throw(new q).j(a);d=a.pa();return Db(new Eb, a.la(),Lm(new Mm,b.Ng.ra.Xa,d.ra.Va,d.ra.ab))}if(Gn(D(),d,Zj(D()))){a=Ada(a,f,e,b);if(null===a)throw(new q).j(a);d=a.pa();return Jn(Lm(new Mm,b.Ng.ra.Xa,d.ra.Va,d.ra.ab),a.la(),!1)}if(Gn(D(),d,Xj(D()))&&!b.zu()&&h)return xda(a,(new gn).td(!1),b,f);if(Gn(D(),d,Yj(D()))&&b.zu()&&h)return yda(a,(new gn).td(!1),b,f);if(Gn(D(),d,Pj(D()))){d=Bda(Cda(new Kn,Dda()),b.Ng,f);if(null===d)throw(new q).j(d);a=d.pa();d=(new Ln).j(d.la());e=Rm();d.L(Jm(new Km,"",e,null,Lm(new Mm,b.Ng.ra.Xa,a.ra.Va,a.ra.ab)));return In(new Kb, d,Lm(new Mm,b.Ng.ra.Xa,a.ra.Va,a.ra.ab))}kh();a=u((new v).K((new w).f(["Expected "," here, rather than a list or block."])),(new w).f([zk(Ck(),d)]));b=b.Lc();jh(a,b.Xa,b.Va,b.ab)}function Mn(a,b,d){return d.La?d.hb:Eda(a,b,d)} function Fda(a,b,d,e,f,h){var k=b.$(),p=f===(Xj(D())|Yj(D())),t=p||f===Xj(D()),x=p||f===Yj(D()),E=k.jb;if(ym()===E){var S=k.ra.ab,U=b.ma();$e();var ga=U.jb,ma=ym();Nn(0,null!==ga&&ga===ma);var va=Gda(a,b,!0,f,h);kh();var Fa=b.$().jb,Va=ug();if(null!==Fa&&Fa===Va){var vb=On(a),pb=k.ra;jh(vb,pb.Xa,pb.Va,pb.ab)}var Ib=b.ma();kh();var kc=Ib.jb,$a=Dc();if(null!==kc&&kc===$a){var fc=On(a),Bc=U.ra;jh(fc,Bc.Xa,Bc.Va,Bc.ab)}kh();var sf=Ib.jb,Sf=zm();if(null===sf||sf!==Sf){var th=Hda(a),Te=Ib.ra;jh(th,Te.Xa, Te.Va,Te.ab)}var tf=va.Et(Lm(new Mm,U.ra.Xa,Ib.ra.Va,S))}else if(Am()===E){var ek;a:{var og=(new Pn).So((new Qn).xg(pa(Ida))),uh=0;for(;;){var pg=b.ma(),Yh=pg.jb,Ri=Am();if(null!==Yh&&Yh===Ri)var fk=og.uj(pg),Si=1+uh|0,og=fk,uh=Si;else{var gk=pg.jb,Ti=Bm();if(null!==gk&&gk===Ti){if(1===uh){ek=og.uj(pg).Hc();break a}var vl=og.uj(pg),Ui=-1+uh|0,og=vl,uh=Ui}else{var hk=pg.jb,Vi=Dc();if(null===hk||hk!==Vi)og=og.uj(pg);else{kh();var wl=Rn(a),vh=k.ra;jh(wl,vh.Xa,vh.Va,vh.ab)}}}}}var xl=ek.Hc();rda||(rda= (new un).b());a:{var wh=xl.aa(),ik;ln||(ln=(new $m).b());ik=ln;var yl=r(),Zh=pda(ik,wh.fd(k,yl.s),h);if(Vk(Zh)){var $h=Zh.U;if(null!==$h){var zl=$h.gb,Al=$h.Fb,Bl=$h.og,jk=wh.gd(),Cl=r(),Dl=wh.fd(k,Cl.s),El=Nm(),Fl=r(),kk=new Sn,Gl=Dl.mc(El,Fl.s);Sn.prototype.jU.call(kk,k,zl,Al,jk,Gl,Bl,Lm(new Mm,k.ra.Xa,jk.ra.Va,k.ra.ab));tf=kk;break a}}if(F()===Zh){var ai=new Tn,lk=wh.nn();if(lk.z())var xh=F();else var Hl=lk.Y(),xh=(new J).j(Hl.ra.Va);var Wi=(xh.z()?k.ra.Va:xh.Y())|0;Tn.prototype.kU.call(ai,k,wh, h,Lm(new Mm,k.ra.Xa,Wi,k.ra.ab));tf=ai}else throw(new q).j(Zh);}}else if(vg()!==E&&ug()!==E||!Gn(D(),f,xk()))if(vg()===E||Rm()===E){b.ma();var mk=k.jb;if(Rm()===mk){var yh=(new Ln).j(k.X);yh.L(k);var Uf=(new A).e(yh.G(),In(new Kb,yh,k.ra))}else{vg()!==mk&&Un(Vn(),"unexpected token type: "+k.jb);var ue=k.X;if(Wn(ue)||hn(ue))if(f===xk())Uf=(new A).e(ue.G(),In(new Kb,ue,k.ra));else{Jda||(Jda=(new Xn).b());var zh;if(hn(ue)){var bi=h.es(k.Wb.toUpperCase()),nk=(new Yn).Ff(k);if(bi.z())Yi=F();else var Xi= md(new nd,nk),Il=bi.Y(),Yi=Xi.Uc(Il);if(Yi.z())zh=F();else{var Jl=Yi.Y();zh=(new J).j((new A).e(Jl,h))}}else zh=F();if(zh.z())var Zi=F();else{var $i=zh.Y();if(null===$i)throw(new q).j($i);var ok=$i.la(),Zi=(new J).j((new A).e(ok.G(),In(new Kb,ok,k.ra)))}if(Zi.z()){kh();var Kl=rh(),aj=[k.Wb.toUpperCase()],ci=Kl.Vl.dc("compiler.LetVariable.notDefined");if(!Vk(ci)){if(F()===ci)throw(new df).c(u((new v).K((new w).f(["coding error, bad translation key: "," for Errors"])),(new w).f(["compiler.LetVariable.notDefined"]))); throw(new q).j(ci);}var Ll=ci.U,Rg=aj.length|0;if(0>=Rg)var Sg=0;else var pk=Rg>>31,Sg=(0===pk?-1<(-2147483648^Rg):0<pk)?-1:Rg;r();Zn();var bj=[],Ah=0,qk=aj.length|0;0>Sg&&$n(ao(),0,Rg,1,!1);for(var Ml=qk<Sg?qk:Sg;Ah<Ml;){var rk=aj[Ah],Tg=Ah;0>Sg&&$n(ao(),0,Rg,1,!1);if(0>Tg||Tg>=Sg)throw(new P).c(""+Tg);var Nl=(new A).e(rk,Tg);bj.push(Nl);Ah=1+Ah|0}var cj=bj.length|0,di=0,Bh=Ll;a:for(;;){if(di!==cj){var Ol=1+di|0,qg=(new A).e(Bh,bj[di]);b:{var fi,Ch=qg.kb,dj=qg.Ab;if(null!==dj){var Ug=dj.la(),ej= dj.Dc();if(Qg(Ug)){var fj=Ug;fi=Qb(Ia(),Ch,u((new v).K((new w).f(["\\\\{","\\\\}"])),(new w).f([""+ej])),fj);break b}}throw(new q).j(qg);}di=Ol;Bh=fi;continue a}break}var gi=k.ra;jh(Bh,gi.Xa,gi.Va,gi.ab)}Uf=Zi.Y()}else if(!An(ue.G())||t)Uf=(new A).e(ue.G(),In(new Kb,ue,k.ra));else{if(!bo(ue)||!d)throw(new co).Ff(k);var hi=(new eo).b();hi.L(k);Uf=(new A).e(hi.G(),In(new Kb,hi,k.ra))}}if(null===Uf)throw(new q).j(Uf);var gj=Uf.la(),Vf=Uf.pa(),vf;if(vf=t&&!d){var ae;a:{var hj=Vf.pe;if(Gn(D(),hj.G().Wa, uk()|xk()))ae=!0;else{for(var rg=hj.G().Pa;!rg.z();){var ij=rg.$()|0;if(Gn(D(),ij,uk()|xk())){ae=!0;break a}rg=rg.aa()}ae=!1}}vf=!ae}var jj;if(vf&&(p||0<Fn(gj))){var ii=Vf.pe,ji=Kda(a,Fn(ii.G()),ii.H(),h);if(null===ji)throw(new q).j(ji);var Pl=ji.pa(),sk=(new fo).ku((new go).K(ji.la()));sk.L(ii.H());jj=(new Kb).Qf(sk,I(r(),(new w).f([Lda(Vf,Pl)])),ii.H().ra)}else jj=Lda(Vf,uda(a,gj,d,Vf,b,h));tf=jj}else{if(ug()!==E||!x)throw(new ho).Ff(k);b.ma();var Vg=k.X;if(!Vg.G().Dr)throw(new ho).Ff(k);var ki= Kda(a,Fn(Vg.G()),Vg.H(),h);if(null===ki)throw(new q).j(ki);var Ql=ki.la(),tk=ki.pa();if(yn(Vg.G()))var ei=Bb(new Cb,(new Fb).c(k.ra.ab),k.ra,!0),qF=r(),xw=tk.mc(ei,qF.s);else xw=tk;var cx=(new io).ku((new go).K(Ql));cx.L(k);var WF=(new Hb).cj(Vg,xw,k.ra),wr=Jn(k.ra,I(r(),(new w).f([WF])),!0),tf=(new Kb).Qf(cx,I(r(),(new w).f([wr])),k.ra)}else{b.ma();var dx=(new jo).b();Gh(k,dx,k.Wb,k.jb);tf=In(new Kb,dx,k.ra)}for(var vk=tf,Bn=!1;!Bn;){var am=b.$(),ex=am.jb,xr=vg();if(null!==ex&&ex===xr){var Cn=am.X, wk=Cn.G();if(An(wk)&&(wk.dp>e||wk.ts&&wk.dp===e)){b.ma();kh();if(null===vk){var YF=Mda(a),yr=am.ra;jh(YF,yr.Xa,yr.Va,yr.ab)}var bm=Lm(new Mm,vk.Lc().Xa,am.ra.Va,am.ra.ab),zr=sda(a,wk,bm,Eh(Cn),b,h),ZF=vk,$F=r(),Dn=vda(a,wk,zr.fd(ZF,$F.s),bm,Eh(Cn),h),aG=Dn.gd().Lc().Va,vk=(new Kb).Qf(Cn,Dn,Lm(new Mm,bm.Xa,aG,bm.ab))}else Bn=!0}else Bn=!0}return vk} function xn(a,b,d,e,f,h,k){try{return Fda(a,d,!1,b.dp,h,k)}catch(p){if(d=ko(Lg(),p),null!==d)if(d&&d.$classData&&d.$classData.n.aB||d&&d.$classData&&d.$classData.n.bB)kh(),a=lo(a,b,f,!0),jh(a,e.Xa,e.Va,e.ab);else throw Kg(Lg(),d);else throw p;}} function Fc(a,b,d,e){var f=b.$(),h=f.jb;if(ym()===h){f=f.ra.ab;d=b.ma();$e();var h=d.jb,k=ym();Nn(0,null!==h&&h===k);e=Fc(a,b,!0,e);b=b.ma();kh();h=b.jb;k=Dc();null!==h&&h===k&&(h=On(a),k=d.ra,jh(h,k.Xa,k.Va,k.ab));kh();h=b.jb;k=zm();if(null===h||h!==k)a=Hda(a),h=b.ra,jh(a,h.Xa,h.Va,h.ab);b=(new A).e(e,Lm(new Mm,d.ra.Xa,b.ra.Va,f));a=b.kb;f=b.Ab;if(null!==a)b=a.pa(),a=a.la();else throw(new q).j(b);return(new A).e((new Hb).cj(a.xd,a.za,f),b)}if(ug()===h){b.ma();var h=f.X,k=b.$().jb,p=Dc(),p=null=== k||k!==p?(new J).j(b.$()):F();Nda||(Nda=(new mo).b());a:{var t=!1,k=null;if(no(h)){var t=!0,k=h,x=k.Wc;if(F()===x){t=!1;x=null;if(Vk(p)&&(t=!0,x=p,p=x.U,null!==p)){var E=p.Wb,S=p.jb;if(vg()===S){t=E.toUpperCase();x=(new oo).c(t);E=e.es(t);E.z()||(E=E.Y(),kh(),E="There is already a "+po(cn(),E)+" called "+t,p=p.ra,jh(E,p.Xa,p.Va,p.ab));k=(new J).j((new A).e(Oda(k,x),Pda(e,t,(new qo).ks(x))));break a}}t&&(k=x.U,kh(),k=k.ra,jh("Expected variable name here",k.Xa,k.Va,k.ab));k=F();break a}}if(t&&(k=k.Wc, Vk(k))){k=k.U;k=(new J).j((new A).e(h,Pda(e,k.va.toUpperCase(),(new qo).ks(k))));break a}k=F()}if(k.z())k=F();else{k=k.Y();if(null===k)throw(new q).j(k);p=k.pa();k=(new J).j((new A).e(Qda(k.la(),f.ra),p))}e=k.z()?(new A).e(Qda(h,f.ra),e):k.Y();if(null===e)throw(new q).j(e);f=e.la();e=e.pa();a=uda(a,h.G(),d,f,b,e);return(new A).e(Rda(f,a),e)}b=f.X;if(!Wn(b)&&!hn(b)||mn(e,f.Wb.toUpperCase())){kh();if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 698"); f=f.ra;jh(a.GG,f.Xa,f.Va,f.ab)}else{kh();a=rh();b=[f.Wb.toUpperCase()];a=a.Vl.dc("compiler.LetVariable.notDefined");if(!Vk(a)){if(F()===a)throw(new df).c(u((new v).K((new w).f(["coding error, bad translation key: "," for Errors"])),(new w).f(["compiler.LetVariable.notDefined"])));throw(new q).j(a);}e=a.U;d=b.length|0;0>=d?h=0:(a=d>>31,h=(0===a?-1<(-2147483648^d):0<a)?-1:d);r();Zn();a=[];k=0;p=b.length|0;0>h&&$n(ao(),0,d,1,!1);for(p=p<h?p:h;k<p;){t=b[k];x=k;0>h&&$n(ao(),0,d,1,!1);if(0>x||x>=h)throw(new P).c(""+ x);t=(new A).e(t,x);a.push(t);k=1+k|0}b=a.length|0;d=0;h=e;a:for(;;){if(d!==b){e=1+d|0;h=(new A).e(h,a[d]);b:{d=h.kb;p=h.Ab;if(null!==p&&(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),d,u((new v).K((new w).f(["\\\\{","\\\\}"])),(new w).f([""+p])),h);break b}throw(new q).j(h);}d=e;continue a}break}f=f.ra;jh(h,f.Xa,f.Va,f.ab)}}function Sda(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,En(a)?" at least":"")} function Eda(a,b,d){if(null===d)throw(new Oe).b();if(d.La)return d.hb;b=b.Pa;a=function(){return function(a){a|=0;Ia();a=zk(Ck(),a);if(null===a)throw(new Oe).b();var b=Eg(Dg(),"anything");a=Fg(new Gg,b,a,a.length|0);ro(a);oi(a)?(b=(new so).b(),to(a,b,"any input"),uo(a,b),a=b.Zb):a=a.Uo;return a}}(a);var e=B().s;if(e===B().s)if(b===y())a=y();else{var e=b.$(),f=e=Cd(new Dd,a(e),y());for(b=b.aa();b!==y();){var h=b.$(),h=Cd(new Dd,a(h),y()),f=f.Ia=h;b=b.aa()}a=e}else{for(e=Mc(b,e);!b.z();)f=b.$(),e.Na(a(f)), b=b.aa();a=e.Da()}return Pe(d,a)}function Jn(a,b,d){b=(new Fb).Ro(a.ab,b);return Bb(new Cb,b,a,d)} function Gda(a,b,d,e,f){try{if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 23");return Fda(a,b,d,a.DR,e,f)}catch(h){if(h&&h.$classData&&h.$classData.n.aB)kh(),a=Mda(a),b=h.Iv.ra,jh(a,b.Xa,b.Va,b.ab);else if(h&&h.$classData&&h.$classData.n.bB){kh();if(0===(16&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 701");b=h.Iv.ra;jh(a.HG,b.Xa,b.Va, b.ab)}else throw h;}}function Tda(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,1<vn(a)?"inputs":"input")}function xda(a,b,d,e){e=zda(a,lc(),d.iq,d,e);if(null===e)throw(new q).j(e);a=e.la();e=e.pa();b=(new fo).ku(b);b.L(d.Ng);a=I(r(),(new w).f([a]));return(new Kb).Qf(b,a,Lm(new Mm,d.Ng.ra.Xa,e.ra.Va,d.Lc().ab))} function vo(a,b,d,e,f){a=d&&d.$classData&&d.$classData.n.QP?wda(a,d,b,f):d;kh();Gn(D(),b,a.Dn())||(d=0===(b&Jj())&&0!==(a.Dn()&~Jj())?a.Dn()&~Jj():a.Dn(),b=u((new v).K((new w).f([""," expected this input to be ",", but got "," instead"])),(new w).f([e,zk(Ck(),b),zk(Ck(),d)])),e=a.Lc(),jh(b,e.Xa,e.Va,e.ab));return a}function On(a){if(0===(128&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 705");return a.FR} function Ada(a,b,d,e){for(var f=Bm(),h=I(Ec(),y());;){var k=b.$().jb;if(null===k||k!==f){kh();var p=b.$().jb,t=Dc(),k=e.Ng;null!==p&&p===t&&(p=Rn(a),k=k.ra,jh(p,k.Xa,k.Va,k.ab));d=Fc(a,b,!1,d);if(null===d)throw(new q).j(d);k=d.la();d=d.pa();h.uj(k)}else break}a=h.Hc();return(new A).e(a,b.ma())} function lo(a,b,d,e){var f=(new Ne).b(),h=(new Ne).b(),k=(new Ne).b(),p=(new Ne).b(),t;if(t=e&&En(b))t=b.ys,t=0===((t.z()?wo(b):t.Y())|0);d=t?u((new v).K((new w).f([""," expected "," "," on the right or any number of inputs when surrounded by parentheses"])),(new w).f([d,vn(b),f.La?f.hb:Tda(b,f)])):e?u((new v).K((new w).f("; expected; ; ;;".split(";"))),(new w).f([d,h.La?h.hb:Sda(b,h),vn(b),f.La?f.hb:Tda(b,f),k.La?k.hb:tda(b,k)])):u((new v).K((new w).f([""," expected "," on the left"])),(new w).f([d, zk(Ck(),b.Wa)]));if(e){a:{for(e=Mn(a,b,p);!e.z();){if("any input"!==e.$()){e=!1;break a}e=e.aa()}e=!0}if(e)return u((new v).K((new w).f(["","."])),(new w).f([d]));e=Mn(a,b,p);if(1===wn(e))return e=(new v).K((new w).f(["",", ","."])),a=Mn(a,b,p),u(e,(new w).f([d,cc(a,"","","")]));e=(new v).K((new w).f(["",", "," and ","."]));f=Mn(a,b,p);f=xo(f,1).zb(", ");a=Mn(a,b,p);return u(e,(new w).f([d,f,zn(a)]))}return d} function Hda(a){if(0===(8&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 700");return a.FG} function Kda(a,b,d,e){var f=1>b,h=null,h=(new A).e(I(r(),y()),e);if(!f)for(e=1;;){h=(new A).e(h,e);f=h.kb;if(null!==f){var h=f.la(),k=Uda(f.pa());if(null===k)throw(new q).j(k);var f=k.la(),k=k.pa(),p=r(),h=(new A).e(h.mc(f,p.s),k)}else throw(new q).j(h);if(e===b)break;e=1+e|0}b=h;if(null===b)throw(new q).j(b);b=b.la();a=m(new n,function(a,b){return function(a){a=(new kn).ID(a,!0);a.L(b);return In(new Kb,a,Lm(new Mm,b.ra.Xa,b.ra.Va,b.ra.ab))}}(a,d));d=r();a=b.xa(a,d.s);return(new A).e(b,a)} function vda(a,b,d,e,f,h){yo||(yo=(new zo).b());var k=I(yo,d),p=0;if(An(b)){p=b.Wa;kh();if(!(1<=d.Ga())){var t=lo(a,b,f,!1);jh(t,e.Xa,e.Va,e.ab)}k.nf(0,vo(a,p,d.W(0),f,h));p=1}for(var t=0,x=b.Pa;;){if(t<wn(x)){D();var E=Ij(),E=!Gn(0,E,Pi(x,t)|0)}else E=!1;if(E){t===(-1+wn(x)|0)&&d.Ga()===(-1+wn(x)|0)?(D(),E=yk(),E=Gn(0,E,Pi(x,t)|0)):E=!1;if(E)return I(Ao(),k);kh();d.Ga()>p||(E=lo(a,b,f,!0),jh(E,e.Xa,e.Va,e.ab));k.nf(p,vo(a,Pi(x,t)|0,d.W(p),f,h));t=1+t|0;p=1+p|0}else break}if(t<wn(x)){for(var E=-1+ d.Ga()|0,S=-1+wn(x)|0;;){if(0<=S){D();var U=Ij(),U=!Gn(0,U,Pi(x,S)|0)}else U=!1;if(U)kh(),d.Ga()>E&&-1<E||(U=lo(a,b,f,!0),jh(U,e.Xa,e.Va,e.ab)),k.nf(E,vo(a,Pi(x,S)|0,d.W(E),f,h)),S=-1+S|0,E=-1+E|0;else break}for(;p<=E;)k.nf(p,vo(a,Pi(x,t)|0,d.W(p),f,h)),p=1+p|0}return I(Ao(),k)} function yda(a,b,d,e){a=Ada(a,e,d.iq,d);if(null===a)throw(new q).j(a);e=a.la();a=a.pa();b=(new io).ku(b);b.L(d.Ng);e=Jn(Lm(new Mm,d.Ng.ra.Xa,a.ra.Va,d.Lc().ab),e,!1);e=I(r(),(new w).f([e]));return(new Kb).Qf(b,e,Lm(new Mm,d.Ng.ra.Xa,a.ra.Va,d.Lc().ab))}function Mda(a){if(0===(256&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 706");return a.GR} function zda(a,b,d,e,f){b=vo(a,lc(),Gda(a,f,!1,b,d),null,d);f=f.ma();kh();d=f.jb;var h=Dc();e=e.Ng;null!==d&&d===h&&(d=Rn(a),e=e.ra,jh(d,e.Xa,e.Va,e.ab));kh();e=f.jb;d=Bm();if(null===e||e!==d){if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 699");e=f.ra;jh(a.EG,e.Xa,e.Va,e.ab)}return(new A).e(b,f)} function Rn(a){if(0===(64&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ExpressionParser.scala: 704");return a.ER}Cc.prototype.$classData=g({S0:0},!1,"org.nlogo.parse.ExpressionParser$",{S0:1,d:1});var Ac=void 0;function Bo(){}Bo.prototype=new l;Bo.prototype.constructor=Bo;Bo.prototype.b=function(){return this}; function Co(a,b){var d=!1,e=null;return Do(b)&&(d=!0,e=b,a=e.X,Zg(a))?(b=Eo(),$b(b,a,!0,!1)):d?e.H().Wb:Fo(b)||Go(b)&&b.qj?"":b.H().Wb}function Vda(a,b,d){return Vc(new Wc,"",b,m(new n,function(){return function(a){return Co(0,a)}}(a)),d)}function Wda(){var a=Ho();m(new n,function(){return function(a){return Co(0,a)}}(a))}Bo.prototype.$classData=g({V0:0},!1,"org.nlogo.parse.Formatter$",{V0:1,d:1});var Io=void 0;function Ho(){Io||(Io=(new Bo).b());return Io}function Jo(){this.qt=null} Jo.prototype=new l;Jo.prototype.constructor=Jo;function Uc(a){var b=new Jo;b.qt=a;return b}function Tc(a,b){return Vc(new Wc,""+a.qt.Wb+b,a.qt.Uj,a.qt.am,a.qt.pf)}Jo.prototype.$classData=g({W0:0},!1,"org.nlogo.parse.Formatter$RichFormat",{W0:1,d:1}); function yaa(a,b){b=Faa(a,b);if(null===b)throw(new q).j(b);var d=b.la();b=b.pa();var d=I(r(),(new w).f([(new Ko).b(),(new Lo).b(),(new Mo).b(),new No])).Gb(d,tb(new ub,function(a){return function(b,d){d=m(new n,function(a,b){return function(a){return b.$g(a)}}(a,d));var e=r();return b.xa(d,e.s)}}(a))),e=(new Oo).b();d.wa(m(new n,function(a,b){return function(a){Ob(b,a.fe)}}(a,e)));hda((new Ym).K(d));e=(new Po).b();a=m(new n,function(a,b){return function(a){return b.$g(a)}}(a,e));e=r();a=d.xa(a,e.s); return(new A).e(a,b)}function mo(){}mo.prototype=new l;mo.prototype.constructor=mo;mo.prototype.b=function(){return this};mo.prototype.$classData=g({a1:0},!1,"org.nlogo.parse.LetScope$",{a1:1,d:1});var Nda=void 0;function Xn(){}Xn.prototype=new l;Xn.prototype.constructor=Xn;Xn.prototype.b=function(){return this};Xn.prototype.$classData=g({b1:0},!1,"org.nlogo.parse.LetVariableScope$",{b1:1,d:1});var Jda=void 0;function Kn(){this.AG=this.yG=this.xG=this.wG=this.hD=null;this.a=0}Kn.prototype=new l; Kn.prototype.constructor=Kn;function Bda(a,b,d){for(var e=Xda(Qo(),y()),f=F();!f.ba();){var h=d.ma(),k=h.jb;if(Bm()===k)f=(new J).j(h);else if(Dc()===k){kh();h=a;if(0===(32&h.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/LiteralParser.scala: 25");k=b.ra;jh(h.AG,k.Xa,k.Va,k.ab)}else e=Ro(e,So(a,h,d))}return(new A).e(e,f.Y())} function So(a,b,d){var e=b.jb;if(cda()===e)a=a.hD,kh(),a=Yda(a),b=b.ra,jh(a,b.Xa,b.Va,b.ab);else{if(Rm()===e)return b.X;if(Am()===e){a=Bda(a,b,d);if(null===a)throw(new q).j(a);return a.la()}if(Rca()===e)a=a.hD,kh(),b=d.ma(),a=Yda(a),b=b.Lc(),jh(a,b.Xa,b.Va,b.ab);else{if(ym()===e){b=So(a,d.ma(),d);d=d.ma();kh();var e=d.jb,f=zm();if(null===e||e!==f){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/LiteralParser.scala: 20");d=d.ra;jh(a.wG,d.Xa, d.Va,d.ab)}return b}if(Dm()===e)return So(a,d.ma(),d);kh();if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/LiteralParser.scala: 21");b=b.ra;jh(a.xG,b.Xa,b.Va,b.ab)}}} function Cda(a,b){a.hD=b;a.wG="Expected a closing parenthesis.";a.a=(1|a.a)<<24>>24;a.xG="Expected a literal value.";a.a=(2|a.a)<<24>>24;a.a=(4|a.a)<<24>>24;a.yG="Extra characters after literal.";a.a=(8|a.a)<<24>>24;a.a=(16|a.a)<<24>>24;a.AG="No closing bracket for this open bracket.";a.a=(32|a.a)<<24>>24;return a}Kn.prototype.$classData=g({e1:0},!1,"org.nlogo.parse.LiteralParser",{e1:1,d:1});function To(){}To.prototype=new l;To.prototype.constructor=To; function Zda(a,b,d){var e=b.wo;if(Uo(e)){var f=Qba(Rb(),e).al(m(new n,function(a,b){return function(a){return mn(b,a.toUpperCase())}}(a,d)),!1),h=m(new n,function(){return function(a){return(new A).e(a,Vo())}}(a)),k=r(),f=f.xa(h,k.s),h=Nba(Rb(),e).al(m(new n,function(a,b){return function(a){return mn(b,a.toUpperCase())}}(a,d)),!1),k=m(new n,function(){return function(a){return(new A).e(a,Wo())}}(a)),p=r(),h=h.xa(k,p.s),k=r();f.Rc(h,k.s).wa(m(new n,function(a,b,d,e){return function(a){if(null!==a){a= a.la();kh();var f=dn(d,a.toUpperCase()),f=po(cn(),f);a=u((new v).K((new w).f(["Defining a breed ["," ","] redefines ",", a ",""])),(new w).f([e.ql.va,e.Bf.va,a,f]));f=b.sk.g.ra;jh(a,f.Xa,f.Va,f.ab)}else throw(new q).j(a);}}(a,b,d,e)))}}To.prototype.b=function(){return this}; function $da(a,b,d){kh();var e=d.sk.va;if(!(e=a.toLowerCase()!==(null===e?null:e.toLowerCase()))){if(a=!!(b&&b.$classData&&b.$classData.n.Hm))a=d.Rn,a=Xo()===b&&Yo(a)||Yo(b)&&Xo()===a?!0:Zo()===b&&$o(a)||$o(b)&&Zo()===a?!0:$o(b)&&$o(a)||Yo(b)&&Yo(a);e=a}a=d.sk.g;e||(d=d.sk.va,b=po(cn(),b),b=u((new v).K((new w).f(["There is already a "," called ",""])),(new w).f([b,d])),d=a.ra,jh(b,d.Xa,d.Va,d.ab))} function aea(a,b){var d=b.Oa();return(new ap).Gf(d,m(new n,function(a,b){return function(d){var k=b.Vn(m(new n,function(a,b){return function(a){return b!==a}}(a,d)));d=m(new n,function(a,b){return function(a){return(new A).e(b,a)}}(a,d));var p=r();return k.xa(d,p.s)}}(a,b)))}function bea(a){kh();var b=a.g;"-\x3e"===a.va&&(a=b.ra,jh("-\x3e can only be used to create anonymous procedures",a.Xa,a.Va,a.ab))} function cea(a,b){return b.Gb(dea(),tb(new ub,function(){return function(a,b){return Uo(b)?rc(rc(a,Qba(Rb(),b),Vo()),Nba(Rb(),b),Wo()):a}}(a)))}function eea(a,b){if(bp(a)&&bp(b)){var d=a.zg,e=b.zg;if(null===d?null===e:d.o(e))return(new J).j((new A).e(a.zg.va,b.zg.g))}return cp(a)&&cp(b)?(new J).j((new A).e("EXTENSIONS",b.g)):dp(a)&&dp(b)?(new J).j((new A).e("INCLUDES",b.g)):F()}function fea(a){return u((new v).K((new w).f(["Redeclaration of ",""])),(new w).f([a]))} function gea(a,b){b.Vn(m(new n,function(){return function(a){return ep(a)}}(a))).wa(m(new n,function(a){return function(b){if(ep(b))b=b.fn,b.wa(m(new n,function(a,b){return function(d){bea(d);kh();var e=1===b.zC(m(new n,function(a,b){return function(a){return a.va===b.va}}(a,d))),f=d.g;e||(d=hea(d),f=f.ra,jh(d,f.Xa,f.Va,f.ab))}}(a,b)));else throw(new q).j(b);}}(a)));b=aea(a,b);for(b=(new fp).Gf(b,m(new n,function(){return function(a){return null!==a}}(a)));b.ta();){var d=b.ma();if(null!==d){var d= eea(d.la(),d.pa()),e=iea(new gp,d,m(new n,function(){return function(a){return null!==a}}(a))),d=e.ga,e=e.ol,d=d.z()||e.y(d.Y())?d:F();if(!d.z())if(e=d.Y(),null!==e)d=e.la(),e=e.pa(),kh(),d=fea(d),e=e.ra,jh(d,e.Xa,e.Va,e.ab);else throw(new q).j(e);}else throw(new q).j(d);}}function hea(a){return u((new v).K((new w).f(["There is already a local variable called "," here"])),(new w).f([a.va]))} function jea(a,b){b=b.Gb(I(r(),y()),tb(new ub,function(a){return function(b,f){if(bp(f)){var h=f.If,k=f.zg.va.toUpperCase();if("TURTLES-OWN"===k)f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,Xo(),!0)}}(a,f)),k=r(),f=h.xa(f,k.s);else if("PATCHES-OWN"===k)f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,jp(),!0)}}(a,f)),k=r(),f=h.xa(f,k.s);else if("LINKS-OWN"===k)f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,Zo(),!0)}}(a,f)),k=r(),f=h.xa(f,k.s);else if("GLOBALS"=== k)f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,kp(),!0)}}(a,f)),k=r(),f=h.xa(f,k.s);else{var k=(new Sb).c(k),k=kea(k),p=b.Oj(m(new n,function(a,b){return function(a){return a.sk.va===b}}(a,k)));p.z()?f=F():(p=p.Y().Rn,lp()===p?(f=m(new n,function(a,b,d){return function(a){return hp(new ip,d,a,(new mp).c(b),!0)}}(a,k,f)),k=r(),f=h.xa(f,k.s)):np()===p?(f=m(new n,function(a,b,d){return function(a){return hp(new ip,d,a,(new op).c(b),!0)}}(a,k,f)),k=r(),f=h.xa(f,k.s)):f=I(r(),y()),f= (new J).j(f));f=f.z()?I(r(),y()):f.Y()}h=r();return b.Rc(f,h.s)}if(ep(f))return k=f.fn,h=hp(new ip,f,f.va,pp(),!0),f=m(new n,function(a,b){return function(a){return hp(new ip,b,a,tc(),!1)}}(a,f)),p=r(),f=k.xa(f,p.s),k=r(),f=f.fd(h,k.s),h=r(),f.Rc(b,h.s);if(Uo(f)){h=f.ql;k=f.Bf;if(f.Kg)var p=lp(),t=qp();else p=np(),t=rp();f=I(r(),(new w).f([hp(new ip,f,h,p,!0),hp(new ip,f,k,t,!0)]));h=r();return b.Rc(f,h.s)}return b}}(a)));a=m(new n,function(){return function(a){return a.Rn}}(a));sp||(sp=(new tp).b()); return up(b,a,sp)} function lea(a,b,d){for(var e=jea(a,b),f=e.Oa(),f=(new fp).Gf(f,m(new n,function(){return function(a){return null!==a&&Uo(a.wo)?!0:!1}}(a)));f.ta();){var h=f.ma();if(null!==h&&Uo(h.wo))Zda(a,h,d);else throw(new q).j(h);}b=mea(d,cea(a,b));for(d=e.Oa();d.ta();)f=d.ma(),bea(f.sk),b.Vn(m(new n,function(){return function(a){return null!==a}}(a))).wa(m(new n,function(a,b){return function(a){if(null!==a)$da(a.la(),a.pa(),b);else throw(new q).j(a);}}(a,f)));b=e.Oa();for(b=(new fp).Gf(b,m(new n,function(){return function(a){return a.ss}}(a)));b.ta();)d= b.ma(),e.Vn(m(new n,function(a,b){return function(a){return a!==b}}(a,d))).wa(m(new n,function(a,b){return function(a){$da(b.sk.va,b.Rn,a)}}(a,d)))}To.prototype.$classData=g({p1:0},!1,"org.nlogo.parse.StructureChecker$",{p1:1,d:1});var vp=void 0;function nea(){vp||(vp=(new To).b());return vp}function wp(){}wp.prototype=new l;wp.prototype.constructor=wp;wp.prototype.b=function(){return this}; function oea(a){var b=xp,d=pba(new Me,a.Ic(),m(new n,function(){return function(a){return a.ra.Xa}}(b))),b=(new yp).b(),d=pea(b).si(d);if(Fe(d))return a=d.mm,pc(),(new mi).j(a);var e=qea(rea(b),d);if(!e.z())return b=e.Y().la(),d=e.Y().pa(),a=d.ym.z()?a.ta()?a.ma():Nm():d.ym.$(),pc(),a=(new A).e(b,a),(new Xh).j(a);throw(new q).j(d);}wp.prototype.$classData=g({r1:0},!1,"org.nlogo.parse.StructureCombinators$",{r1:1,d:1});var xp=void 0;function zp(){}zp.prototype=new l;zp.prototype.constructor=zp; zp.prototype.b=function(){return this};function sea(a,b,d){var e=Ic(b),e=Ap(e);d=b.Ws(d.va,d);b=oh();a=m(new n,function(a,b){return function(a){return(new A).e(a,b.y(a))}}(a,d));d=r();a=nh(b,e.xa(a,d.s).Hc());$e();b=Ic(a);Nn(0,e.Ie(Ap(b)));return a}function tea(a,b,d){return uea(a,vea(a,b,d),d)} function wea(a,b,d,e,f){var h=Ic(b.bg),k=Ic(b.Hf);if(dm(h,k).ib(d)){if(b.Hf.ib(d))return f=b.Hf,d=b.Hf.y(d),f=sea(a,f,Bp(d.va,d.Bf,e,d.Kg,d.Jg)),Cp(b.Qj,b.fk,b.Li,b.hj,b.yi,b.bg,f,b.ug);f=b.bg;d=b.bg.y(d);f=sea(a,f,Bp(d.va,d.Bf,e,d.Kg,d.Jg));return Cp(b.Qj,b.fk,b.Li,b.hj,b.yi,f,b.Hf,b.ug)}b=rh();a=[d];b=b.Vl.dc("compiler.StructureConverter.noBreed");if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f(["coding error, bad translation key: "," for Errors"])),(new w).f(["compiler.StructureConverter.noBreed"]))); throw(new q).j(b);}e=b.U;d=a.length|0;0>=d?h=0:(b=d>>31,h=(0===b?-1<(-2147483648^d):0<b)?-1:d);r();Zn();b=[];var k=0,p=a.length|0;0>h&&$n(ao(),0,d,1,!1);for(p=p<h?p:h;k<p;){var t=a[k],x=k;0>h&&$n(ao(),0,d,1,!1);if(0>x||x>=h)throw(new P).c(""+x);t=(new A).e(t,x);b.push(t);k=1+k|0}a=b.length|0;d=0;h=e;a:for(;;){if(d!==a){e=1+d|0;h=(new A).e(h,b[d]);b:{d=h.kb;p=h.Ab;if(null!==p&&(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),d,u((new v).K((new w).f(["\\\\{","\\\\}"])),(new w).f([""+p])),h);break b}throw(new q).j(h); }d=e;continue a}break}throw(new hd).ms(h,f.ra.Xa,f.ra.Va,f.ra.ab);} function xea(a,b,d,e,f){var h=(new Dp).b(),k=r(),h=b.ic(h,k.s).cs($e().Fk);d=(new Ep).Ha(d);k=r();k=b.ic(d,k.s);k.wa(m(new n,function(){return function(a){a=a.la();a.a=(32|a.a)<<24>>24}}(a,f)));f=tea(a,e.ec,b);d=e.ce;var p=m(new n,function(){return function(a){if(null!==a){a=a.la();var b=a.me();return(new A).e(b,a)}throw(new q).j(a);}}(a)),t=r();d=zc(d,k.xa(p,t.s));p=e.ep;a=m(new n,function(){return function(a){if(null!==a){var b=a.pa();a=a.la().me();return(new A).e(a,b)}throw(new q).j(a);}}(a)); t=r();a=p.Am(k.xa(a,t.s));k=e.Xl;p=r();h=k.Rc(h,p.s);k=e.js;e=e.Mp;p=(new Fp).b();t=r();b=b.ic(p,t.s).cs($e().Fk);p=r();return Gp(new Hp,f,d,a,h,k,e.Rc(b,p.s))}function vea(a,b,d){return d.Gb(b,tb(new ub,function(){return function(a,b){if(Uo(b)){var d=b.Kg,k=b.Jg,p=b.ql.va;b=b.Bf.va;var t=I(r(),y()),k=Bp(p,b,t,d,k);if(d)return d=a.Hf.Ws(k.va,k),Cp(a.Qj,a.fk,a.Li,a.hj,a.yi,a.bg,d,a.ug);d=a.bg.Ws(k.va,k);return Cp(a.Qj,a.fk,a.Li,a.hj,a.yi,d,a.Hf,a.ug)}return a}}(a)))} function uea(a,b,d){return d.Gb(b,tb(new ub,function(a){return function(b,d){if(bp(d)){var k=d.zg,p=d.If;if(null!==k&&"GLOBALS"===k.va){d=b.fk;var k=m(new n,function(){return function(a){return a.va}}(a)),t=r(),p=p.xa(k,t.s),k=r();d=d.Rc(p,k.s);return Cp(b.Qj,d,b.Li,b.hj,b.yi,b.bg,b.Hf,b.ug)}}if(bp(d)&&(k=d.zg,p=d.If,null!==k&&"TURTLES-OWN"===k.va))return d=b.Li,k=m(new n,function(){return function(a){a=a.va;var b=lc();return(new A).e(a,b)}}(a)),t=r(),d=zc(d,p.xa(k,t.s)),Cp(b.Qj,b.fk,d,b.hj,b.yi, b.bg,b.Hf,b.ug);if(bp(d)&&(k=d.zg,p=d.If,null!==k&&"PATCHES-OWN"===k.va))return d=b.hj,k=m(new n,function(){return function(a){a=a.va;var b=lc();return(new A).e(a,b)}}(a)),t=r(),d=zc(d,p.xa(k,t.s)),Cp(b.Qj,b.fk,b.Li,d,b.yi,b.bg,b.Hf,b.ug);if(bp(d)&&(k=d.zg,p=d.If,null!==k&&"LINKS-OWN"===k.va))return d=b.yi,k=m(new n,function(){return function(a){a=a.va;var b=lc();return(new A).e(a,b)}}(a)),t=r(),d=zc(d,p.xa(k,t.s)),Cp(b.Qj,b.fk,b.Li,b.hj,d,b.bg,b.Hf,b.ug);if(bp(d)&&(k=d.zg,d=d.If,null!==k)){var p= k.g,k=(new Sb).c(k.va),k=kea(k),t=m(new n,function(){return function(a){return a.va}}(a)),x=r();return wea(a,b,k,d.xa(t,x.s),p)}return b}}(a)))}zp.prototype.$classData=g({y1:0},!1,"org.nlogo.parse.StructureConverter$",{y1:1,d:1});var Ip=void 0;function yea(){Ip||(Ip=(new zp).b());return Ip}function Jp(){this.Um=null;this.Hk=!1}Jp.prototype=new l;Jp.prototype.constructor=Jp; function zea(a,b,d){xp||(xp=(new wp).b());b=oea(b);if(Qm(b))return b=b.U,gea(nea(),b),lea(nea(),b,Haa(Gc(),d.ec,d.ce)),xea(yea(),b,a.Um,a.Hk?Gp(new Hp,d.ec,(Kp(),ph()),(Kp(),nh($e().kk,y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())),(Kp(),I(r(),y()))):d,a.Hk);Pm(b)&&(d=b.U,null!==d&&(a=d.la(),d=d.pa(),kh(),d=d.ra,jh(a,d.Xa,d.Va,d.ab)));throw(new q).j(b);}function Aea(a,b,d){a.Um=b;a.Hk=d;return a}Jp.prototype.$classData=g({C1:0},!1,"org.nlogo.parse.StructureParser",{C1:1,d:1}); function Lp(){this.MG=null;this.a=!1}Lp.prototype=new l;Lp.prototype.constructor=Lp; function Haa(a,b,d){var e=dea(),f=Bea(Mp(b.ug)),e=rc(e,Ic(f),Np()),f=Cea(Mp(b.ug)),e=rc(rc(rc(rc(e,Ic(f),Op()),Pp(b),kp()),Qp(b),Xo()),Dea(b),jp()),f=Rp(b);a=rc(e,f.al(m(new n,function(a,b){return function(a){return Qp(b).ib(a)}}(a,b)),!0),Zo());f=(new Kc).fg(b.bg);e=Lc().s;e=Mc(f,e);for(f=f.oi.rj();f.ta();){var h=f.ma();e.Na(h.Bf)}a=rc(rc(a,e.Da(),rp()),Ic(b.bg),np());f=(new Kc).fg(b.Hf);e=Lc().s;e=Mc(f,e);for(f=f.oi.rj();f.ta();)h=f.ma(),e.Na(h.Bf);d=rc(rc(rc(a,e.Da(),qp()),Ic(b.Hf),lp()),Ic(d), pp());a=(new Kc).fg(b.bg);b=null;b=d;for(d=a.oi.rj();d.ta();)a=d.ma(),b=a.Kg?rc(b,a.nl,(new mp).c(a.va)):rc(b,a.nl,(new op).c(a.va));return b}Lp.prototype.b=function(){this.MG="Included files must end with .nls";this.a=!0;return this};function Eea(a,b,d,e,f,h){b=Sp(b,e,f);a=(new fp).Gf(b,m(new n,function(){return function(a){a=a.jb;var b=Dm();return!(null!==a&&a===b)}}(a)));b=Tp();a=(new bc).Gf(a,b);return zea(d,a,h)} function Fea(){var a=Gc();return tb(new ub,function(){return function(){return F()}}(a))} function Gaa(a,b,d){var e=Fea();b=function(a,b,d,e){return function(){var t=Aea(new Jp,d.Um,d.Hk),x=d.Rs,E=Gp(new Hp,d.Mr,d.un,(Kp(),nh($e().kk,y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())),(Kp(),I(r(),y()))),x=Zl(x,E,tb(new ub,function(a,b,d){return function(e,f){e=(new A).e(e,f);f=e.kb;var h=e.Ab;if(null!==h)return Eea(a,b,d,h.pa(),h.la(),f);throw(new q).j(e);}}(a,b,t)));if(d.Hk)return x;pc();return(new Up).Gf(Gea(new Vp,x,m(new n,function(a,b,d,e,f){return function(h){var k=h.Xl.$().X;kh();var p=Wp(Ia(), k,".nls"),t=h.Xl.$();if(!p){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/StructureParser.scala: 29");p=a.MG;t=t.Lc();jh(p,t.Xa,t.Va,t.ab)}t=rb(e,d.Fr,k);if(Vk(t)&&(p=t.U,null!==p)){var t=p.la(),p=p.pa(),x=h.Xl.aa(),E=h.js,$a=r(),k=E.mc(k,$a.s);return Eea(a,b,f,p,t,Gp(new Hp,h.ec,h.ce,h.ep,x,k,h.Mp))}if(F()===t){kh();x=rh();p=[k];k=x.Vl.dc("compiler.StructureParser.includeNotFound");if(!Vk(k)){if(F()===k)throw(new df).c(u((new v).K((new w).f(["coding error, bad translation key: ", " for Errors"])),(new w).f(["compiler.StructureParser.includeNotFound"])));throw(new q).j(k);}x=k.U;E=p.length|0;0>=E?$a=0:(k=E>>31,$a=(0===k?-1<(-2147483648^E):0<k)?-1:E);r();Zn();var k=[],fc=0,Bc=p.length|0;0>$a&&$n(ao(),0,E,1,!1);for(Bc=Bc<$a?Bc:$a;fc<Bc;){var sf=p[fc],Sf=fc;0>$a&&$n(ao(),0,E,1,!1);if(0>Sf||Sf>=$a)throw(new P).c(""+Sf);sf=(new A).e(sf,Sf);k.push(sf);fc=1+fc|0}p=k.length|0;E=0;$a=x;a:for(;;){if(E!==p){x=1+E|0;$a=(new A).e($a,k[E]);b:{E=$a.kb;Bc=$a.Ab;if(null!==Bc&&(fc=Bc.la(),Bc= Bc.Dc(),Qg(fc))){$a=fc;$a=Qb(Ia(),E,u((new v).K((new w).f(["\\\\{","\\\\}"])),(new w).f([""+Bc])),$a);break b}throw(new q).j($a);}E=x;continue a}k=$a;break}h=h.Xl.$().Lc();jh(k,h.Xa,h.Va,h.ab)}throw(new q).j(t);}}(a,b,d,e,t))),m(new n,function(){return function(a){return a.Xl.He()}}(a))).ma()}}(a,b,d,e);if(d.Hk)return b();d.hh.hY();b=b();b.Mp.wa(m(new n,function(a,b){return function(a){b.hh.bU(a.Wb.toLowerCase(),(new hh).Ff(a))}}(a,d)));return b} Lp.prototype.$classData=g({D1:0},!1,"org.nlogo.parse.StructureParser$",{D1:1,d:1});var Xp=void 0;function Gc(){Xp||(Xp=(new Lp).b());return Xp}function Yp(){}Yp.prototype=new l;Yp.prototype.constructor=Yp;Yp.prototype.b=function(){return this};function dea(){Hea||(Hea=(new Yp).b());return Zp(new $p,nh(Iea(),y()),0)}Yp.prototype.$classData=g({E1:0},!1,"org.nlogo.parse.SymbolTable$",{E1:1,d:1});var Hea=void 0;function aq(){}aq.prototype=new l;aq.prototype.constructor=aq;aq.prototype.b=function(){return this}; function po(a,b){if(kp()===b)return"global variable";if(Xo()===b)return"turtle variable";if(jp()===b)return"patch variable";if(Zo()===b)return"link variable";if(np()===b)return"breed";if(rp()===b)return"singular breed name";if(lp()===b)return"link breed";if(qp()===b)return"singular link breed name";if(Yo(b)||$o(b))return a=b.ja,u((new v).K((new w).f(["","-OWN variable"])),(new w).f([a]));if(pp()===b)return"procedure";if(Np()===b)return"primitive command";if(Op()===b)return"primitive reporter";if(Vo()=== b)return"breed command";if(Wo()===b)return"breed reporter";if(bq(b)||en()===b||tc()===b)return"local variable here";throw(new q).j(b);}function lda(a,b,d){kh();a="There is already a "+po(cn(),b)+" called "+d.Wb.toUpperCase();d=d.ra;jh(a,d.Xa,d.Va,d.ab)}aq.prototype.$classData=g({F1:0},!1,"org.nlogo.parse.SymbolType$",{F1:1,d:1});var cq=void 0;function cn(){cq||(cq=(new aq).b());return cq}function dq(){}dq.prototype=new l;dq.prototype.constructor=dq;dq.prototype.b=function(){return this}; function xc(a,b,d){a=new eq;var e=new fq;e.ai=b;e.xY=d;e.AF=d.qU();e.a=!0;return gq(a,e)}dq.prototype.$classData=g({X1:0},!1,"org.nlogo.parse.TransformableTokenStream$",{X1:1,d:1});var hq=void 0;function uc(){hq||(hq=(new dq).b());return hq}function iq(){}iq.prototype=new l;iq.prototype.constructor=iq;iq.prototype.b=function(){return this}; function Jea(a,b,d,e,f){var h=m(new n,function(a,b){return function(a){return Kea(b,a)}}(a,e)),k=r();b=b.xa(h,k.s);a=m(new n,function(a,b){return function(a){return Lea(b,a)}}(a,e));e=r();d=d.xa(a,e.s);return jq(new kq,f.Sf,f.Zd,f.Se,f.Gc,b,d)} function Mea(a,b){b=lq(a,b,mq());if(nq(b)){b=b.ha;b=oq().by().y(b);if(!nq(b)){if(!pq(b))throw(new q).j(b);b=(new qq).j(rq(b.cc))}if(nq(b)){b=b.ha;var d=(new sq).j(Hca(Ek(),b.Ey()))}else{if(!pq(b))throw(new q).j(b);d=b}}else{if(!pq(b))throw(new q).j(b);d=b}b=qd();if(nq(d))a=d;else{if(!pq(d))throw(new q).j(d);var e=d.cc;a=function(){return function(a){return a}}(a);tq();var d=a(e.Fc),e=e.Mc,f=uq().Vd,e=vq(e);a:for(;;){if(!wq(e)){if(xq(e)){var h=e,e=h.dd,h=a(h.$c),f=(new yq).Qb(h,f);continue a}throw(new q).j(e); }break}a=(new qq).j((new zq).Qb(d,f))}Aq||(Aq=(new Bq).b());return rd(b,Cq(a,Aq).Ye())}function lq(a,b,d){b=Dq(qd(),b);d=d.Za(b);if(nq(d))return d;if(pq(d)){b=d.cc;a=function(){return function(a){return(new Eq).c(a)}}(a);tq();d=a(b.Fc);b=b.Mc;var e=uq().Vd;b=vq(b);a:for(;;){if(!wq(b)){if(xq(b)){var f=b;b=f.dd;f=a(f.$c);e=(new yq).Qb(f,e);continue a}throw(new q).j(b);}break}return(new qq).j((new zq).Qb(d,e))}throw(new q).j(d);} function Nea(a,b){var d=qd();Fq();var e=Oea(a);Gq();(new Hq).b();try{var f=Pea(Iq(),b);if(nq(f))var h=f;else{if(!pq(f))throw(new q).j(f);var k=f.cc,p=function(){return function(a){if(Jq(a))return Kq(a);if(null!==a)return(new Lq).ud(a);throw(new q).j(a);}}(a);tq();var t=p(k.Fc),x=k.Mc,E=uq().Vd,S=vq(x);a=E;var U;a:for(;;){b=S;if(!wq(b)){if(xq(b)){var ga=b.dd,f=a,ma=p(b.$c),va=(new yq).Qb(ma,f),S=ga;a=va;continue a}throw(new q).j(b);}U=a;break}h=(new qq).j((new zq).Qb(t,U))}if(nq(h))var Fa=h.ha,Va= (new sq).j(rb(e,Fa,Mq(Nq(),Fa)));else if(pq(h))Va=h;else throw(new q).j(h);var vb=(new sq).j(Va)}catch(pb){if(e=ko(Lg(),pb),null!==e)if(Rl(pa(Oq),e))vb=(new qq).j(e);else throw Kg(Lg(),e);else throw pb;}if(nq(vb))e=vb.ha;else{if(!pq(vb))throw(new q).j(vb);e=vb.cc;Pq();e=(new Lq).ud(e);e=Qq(Gq(),e)}return rd(d,Rq(0,e).Ye())}function Oea(a){return tb(new ub,function(){return function(a,d){return d}}(a))} function Qea(a,b,d){var e=Sq(Tq());d=lq(a,d,Rea());if(pq(d))Pq(),d=(new Eq).c(u((new v).K((new w).f([""," must be an Array of ",""])),(new w).f(["commands",Uq(pa(qa))]))),d=Qq(Gq(),d);else if(!nq(d))throw(new q).j(d);if(nq(d)){d=d.ha.Ma;var e=m(new n,function(a,b){return function(a){a=b.Za(a);if(pq(a))return(new qq).j(rq(a.cc));if(nq(a)){a=a.ha;B();a=(new w).f([a]);var d=B().s;return(new sq).j(L(a,d))}throw(new q).j(a);}}(a,e)),f=r(),e=d.xa(e,f.s);Pq();B();d=y();e=e.Gb(Vq().y(d),tb(new ub,function(a){return function(b, d){d=function(a,b){return function(){return b}}(a,d);var e=Wq();(new Xq).nu(e);e=tq();(new Yq).gq(e);if(pq(b)){e=b.cc;d=d();if(pq(d))return(new qq).j(Zq(e,d.cc));if(nq(d))return b;throw(new q).j(d);}if(nq(b)){b=b.ha;d=d();if(pq(d))return d;if(nq(d))return(new sq).j($q(d.ha,b));throw(new q).j(d);}throw(new q).j(b);}}(a)));if(!nq(e)){if(!pq(e))throw(new q).j(e);f=e.cc;e=function(){return function(a){return a}}(a);tq();d=e(f.Fc);var f=f.Mc,h=uq().Vd,f=vq(f);a:for(;;){if(!wq(f)){if(xq(f)){var k=f,f=k.dd, k=e(k.$c),h=(new yq).Qb(k,h);continue a}throw(new q).j(f);}break}e=(new qq).j((new zq).Qb(d,h))}}else{if(!pq(d))throw(new q).j(d);e=d}if(!nq(e)){if(!pq(e))throw(new q).j(e);f=e.cc;e=function(){return function(a){return a}}(a);tq();d=e(f.Fc);f=f.Mc;h=uq().Vd;f=vq(f);a:for(;;){if(!wq(f)){if(xq(f)){k=f;f=k.dd;k=e(k.$c);h=(new yq).Qb(k,h);continue a}throw(new q).j(f);}break}e=(new qq).j((new zq).Qb(d,h))}if(nq(e)){e=e.ha;d=I(r(),y());Gq();(new Hq).b();try{var p=Pea(Iq(),b);if(nq(p))var t=p;else{if(!pq(p))throw(new q).j(p); var x=p.cc,E=function(){return function(a){if(Jq(a))return Kq(a);if(null!==a)return(new Lq).ud(a);throw(new q).j(a);}}(a);tq();var S=E(x.Fc),U=x.Mc,ga=uq().Vd,ma=vq(U);b=ga;var va;a:for(;;){p=ma;if(!wq(p)){if(xq(p)){var Fa=p.dd,x=b,Va=E(p.$c),vb=(new yq).Qb(Va,x),ma=Fa;b=vb;continue a}throw(new q).j(p);}va=b;break}t=(new qq).j((new zq).Qb(S,va))}if(nq(t))var pb=t.ha,Ib=Mq(Nq(),pb),kc=(new sq).j(Jea(a,e,d,pb,Ib));else if(pq(t))kc=t;else throw(new q).j(t);var $a=(new sq).j(kc)}catch(fc){if(a=ko(Lg(), fc),null!==a)if(Rl(pa(Oq),a))$a=(new qq).j(a);else throw Kg(Lg(),a);else throw fc;}if(nq($a))a=$a.ha;else{if(!pq($a))throw(new q).j($a);a=$a.cc;Pq();a=(new Lq).ud(a);a=Qq(Gq(),a)}if(nq(a))a=(new sq).j(a.ha);else if(!pq(a))throw(new q).j(a);}else{if(!pq(e))throw(new q).j(e);a=e}return rd(qd(),Rq(Fq(),a).Ye())} function Sea(a,b){b=lq(a,b,mq());if(nq(b)){b=b.ha;b=ar().by().y(b);if(!nq(b)){if(!pq(b))throw(new q).j(b);b=(new qq).j(rq(b.cc))}if(nq(b)){b=b.ha;Gq();(new Hq).b();try{var d=Tea(Iq(),b.Ey(),br(),cr());if(nq(d))var e=d;else{if(!pq(d))throw(new q).j(d);var f=d.cc,h=function(){return function(a){return a}}(a);tq();var k=h(f.Fc),p=f.Mc,t=uq().Vd,x=vq(p),d=t,E;a:for(;;){f=x;if(!wq(f)){if(xq(f)){var S=f.dd,p=d,U=h(f.$c),ga=(new yq).Qb(U,p),x=S,d=ga;continue a}throw(new q).j(f);}E=d;break}e=(new qq).j((new zq).Qb(k, E))}if(nq(e))var ma=e;else{if(!pq(e))throw(new q).j(e);var va=e.cc,Fa=function(){return function(a){if(Jq(a))return Kq(a);if(null!==a)return(new Lq).ud(a);throw(new q).j(a);}}(a);tq();var Va=Fa(va.Fc),vb=va.Mc,pb=uq().Vd,Ib=vq(vb),e=pb,kc;a:for(;;){h=Ib;if(!wq(h)){if(xq(h)){var $a=h.dd,k=e,fc=Fa(h.$c),Bc=(new yq).Qb(fc,k),Ib=$a,e=Bc;continue a}throw(new q).j(h);}kc=e;break}ma=(new qq).j((new zq).Qb(Va,kc))}if(nq(ma))var sf=ma.ha,Sf=Mq(Nq(),sf),th=(new sq).j(Jea(a,Uea(b),Vea(b),sf,Sf));else if(pq(ma))th= ma;else throw(new q).j(ma);var Te=(new sq).j(th)}catch(tf){if(ma=ko(Lg(),tf),null!==ma)if(Rl(pa(Oq),ma))Te=(new qq).j(ma);else throw Kg(Lg(),ma);else throw tf;}if(nq(Te))ma=Te.ha;else{if(!pq(Te))throw(new q).j(Te);ma=Te.cc;Pq();ma=(new Lq).ud(ma);ma=Qq(Gq(),ma)}if(nq(ma))Fa=(new sq).j(ma.ha);else{if(!pq(ma))throw(new q).j(ma);Fa=ma}}else{if(!pq(b))throw(new q).j(b);Fa=b}}else{if(!pq(b))throw(new q).j(b);Fa=b}ma=qd();Fq();if(nq(Fa))a=Fa;else{if(!pq(Fa))throw(new q).j(Fa);Va=Fa.cc;a=function(){return function(a){return a}}(a); tq();Fa=a(Va.Fc);Va=Va.Mc;Ib=uq().Vd;Va=vq(Va);a:for(;;){if(!wq(Va)){if(xq(Va)){kc=Va;Va=kc.dd;kc=a(kc.$c);Ib=(new yq).Qb(kc,Ib);continue a}throw(new q).j(Va);}break}a=(new qq).j((new zq).Qb(Fa,Ib))}return rd(ma,Rq(0,a).Ye())}iq.prototype.exportNlogo=function(a){return Mea(this,a)}; iq.prototype.fromNlogo=function(a){for(var b=arguments.length|0,d=1,e=[];d<b;)e.push(arguments[d]),d=d+1|0;switch(e.length|0){case 0:return Nea(this,a);case 1:return Qea(this,a,e[0]);default:throw"No matching overload";}};iq.prototype.fromModel=function(a){return Sea(this,a)};iq.prototype.$classData=g({Y1:0},!1,"org.nlogo.tortoise.compiler.BrowserCompiler",{Y1:1,d:1});function dr(){}dr.prototype=new l;dr.prototype.constructor=dr;dr.prototype.b=function(){return this}; function Rq(a,b){if(nq(b))a=b.ha;else{if(!pq(b))throw(new q).j(b);a=b.cc;a=jq(new kq,(Pq(),Wea().y(a)),"","",I(r(),y()),I(r(),y()),I(r(),y()))}er||(er=(new fr).b());return Cq(a,er)}dr.prototype.$classData=g({Z1:0},!1,"org.nlogo.tortoise.compiler.BrowserCompiler$",{Z1:1,d:1});var gr=void 0;function Fq(){gr||(gr=(new dr).b());return gr}function hr(a,b,d,e,f){a=bd(a);b=b.za.W(1);return ir(a,b,d,e,f)} function jr(a,b,d,e,f){b=b.za;var h=new kr;if(null===a)throw Kg(Lg(),null);h.Sa=a;h.WS=d;h.TS=e;h.OV=f;a=r();return b.ic(h,a.s)} function Xea(a,b,d,e,f){var h=b.xd;ld();var k=(new lr).b(),p=md(new nd,k).Uc(h);if(!p.z()){var t=p.Y();if(null===t)throw(new Oe).b();return""===t?"":u((new v).K((new w).f(["",";"])),(new w).f([t]))}ld();var x=(new mr).b(),E=md(new nd,x).Uc(h);if(!E.z()){var S=E.Y();return u((new v).K((new w).f(["","(",");"])),(new w).f([S,jr(a,b,d,e,f).zb(", ")]))}if(h&&h.$classData&&h.$classData.n.Lz){var U;var ga=b.za.W(0).pe;if(nr(ga)){bd(a);var ma=ga.Wc.va,va=or(pr(),ma);U=u((new v).K((new w).f([""," \x3d ","; letVars['", "'] \x3d ",";"])),(new w).f([va,hr(a,b,d,e,f),va,va]))}else if(qr(ga)){var Fa=(new v).K((new w).f([""," \x3d ",";"]));bd(a);var Va=ga.va;U=u(Fa,(new w).f([or(pr(),Va),hr(a,b,d,e,f)]))}else if(Go(ga)){var vb=(new v).K((new w).f([""," \x3d ",";"]));bd(a);var pb=ga.va;U=u(vb,(new w).f([or(pr(),pb),hr(a,b,d,e,f)]))}else{null===a.Jw&&null===a.Jw&&(a.Jw=(new rr).vD(a));var Ib=a.Jw.PF(ga);if(Ib.z()){var kc=b.xd.H();gd('This isn\'t something you can use "set" on.',kc);U=void 0}else U=Ib.Y().y(hr(a,b,d,e, f))}return U}if(h&&h.$classData&&h.$classData.n.yA){var $a=bd(a),fc=b.za.W(0),Bc=sr($a,fc,!0,!1,d,e,f),sf=u((new v).K((new w).f(["|while (true) {\n        |","\n        |};"])),(new w).f([tr(fd(),Bc)])),Sf=(new Sb).c(sf);return dd(Sf)}if(h&&h.$classData&&h.$classData.n.Kz){var th=bd(a),Te=b.za.W(0),tf=ir(th,Te,d,e,f),ek=bd(a),og=b.za.W(1),uh=sr(ek,og,!0,!1,d,e,f);bd(a);var pg=b.xd.H(),Yh=cd(pg,"index");bd(a);var Ri=b.xd.H(),fk=cd(Ri,"repeatcount"),Si=u((new v).K((new w).f(["|for (let "," \x3d 0, ", " \x3d StrictMath.floor(","); "," \x3c ","; ","++){\n        |","\n |}"])),(new w).f([Yh,fk,tf,Yh,fk,Yh,tr(fd(),uh)])),gk=(new Sb).c(Si);return dd(gk)}if(h&&h.$classData&&h.$classData.n.SA){var Ti=bd(a),vl=b.za.W(0),Ui=ir(Ti,vl,d,e,f),hk=bd(a),Vi=b.za.W(1),wl=sr(hk,Vi,!0,!1,d,e,f),vh=u((new v).K((new w).f(["|while (",") {\n        |","\n        |}"])),(new w).f([Ui,tr(fd(),wl)])),xl=(new Sb).c(vh);return dd(xl)}if(h&&h.$classData&&h.$classData.n.lA){var wh=bd(a),ik=b.za.W(0),yl=ir(wh,ik,d, e,f),Zh=bd(a),$h=b.za.W(1),zl=sr(Zh,$h,!0,!1,d,e,f),Al=u((new v).K((new w).f(["|if (",") {\n        |","\n        |}"])),(new w).f([yl,tr(fd(),zl)])),Bl=(new Sb).c(Al);return dd(Bl)}if(h&&h.$classData&&h.$classData.n.mA){var jk=bd(a),Cl=b.za.W(0),Dl=ir(jk,Cl,d,e,f),El=bd(a),Fl=b.za.W(1),kk=sr(El,Fl,!0,!1,d,e,f),Gl=bd(a),ai=b.za.W(2),lk=sr(Gl,ai,!0,!1,d,e,f),xh=u((new v).K((new w).f(["|if (",") {\n        |","\n        |}\n        |else {\n        |","\n        |}"])),(new w).f([Dl,tr(fd(),kk),tr(fd(), lk)])),Hl=(new Sb).c(xh);return dd(Hl)}if(h&&h.$classData&&h.$classData.n.Gz){var Wi=bd(a),mk=b.za.W(0),yh=ir(Wi,mk,d,e,f),Uf=bd(a),ue=b.za.W(1),zh=ur(Uf,ue,!1,d,e,f);return vr(yh,!0,zh)}if(Ar(h)){bd(a);var bi=b.xd.H(),nk=cd(bi,"error"),Xi=bd(a),Il=b.za.W(0),Yi=sr(Xi,Il,!0,!1,d,e,f);Ia();var Jl=bd(a),Zi=b.za.W(1),$i=sr(Jl,Zi,!0,!1,d,e,f),ok=(new v).K((new w).f(["_error_",""])),Kl=Yea(h),aj=Q(),ci=Qb(0,$i,u(ok,(new w).f([R(aj,Kl)])),nk),Ll=u((new v).K((new w).f(["\n       |try {\n       |","\n       |} catch (", ") {\n       |","\n       |}\n     "])),(new w).f([tr(fd(),Yi),nk,tr(fd(),ci)])),Rg=(new Sb).c(Ll);return dd(Rg)}if(Br(h))return Zea(a,b,!1,d,e,f);if(Cr(h))return Zea(a,b,!0,d,e,f);if(h&&h.$classData&&h.$classData.n.kB)return $ea(a,b,!1,d,e,f);if(h&&h.$classData&&h.$classData.n.jB)return $ea(a,b,!0,d,e,f);if(Dr(h)){var Sg=bd(a),pk=b.za.W(0),bj=ir(Sg,pk,d,e,f),Ah=bd(a),qk=b.za.W(1),Ml=ur(Ah,qk,!1,d,e,f),rk=b.xd.ja,Tg=(new Sb).c(rk),Nl=kd(Tg)?rk:"TURTLES",cj=u((new v).K((new w).f(["SelfManager.self().sprout(", ", ",")"])),(new w).f([bj,ed(fd(),Nl)]));return vr(cj,!0,Ml)}if(h&&h.$classData&&h.$classData.n.pB){var di=bd(a),Bh=b.za.W(0),Ol=ir(di,Bh,d,e,f),qg=b.xd;if(!(qg&&qg.$classData&&qg.$classData.n.pB))throw(new df).c(u((new v).K((new w).f(["How did you get here with class of type ",""])),(new w).f([oa(qg).kh()])));var fi=qg.ja,Ch=(new Sb).c(fi),dj=kd(Ch)?fi:"TURTLES";return u((new v).K((new w).f(["SelfManager.self().sprout(",", ",");"])),(new w).f([Ol,ed(fd(),dj)]))}if(h&&h.$classData&&h.$classData.n.Yz)return Er(a, b,"createLinkFrom",h.ja,d,e,f);if(h&&h.$classData&&h.$classData.n.Zz)return Er(a,b,"createLinksFrom",h.ja,d,e,f);if(h&&h.$classData&&h.$classData.n.bA)return Er(a,b,"createLinkTo",h.ja,d,e,f);if(h&&h.$classData&&h.$classData.n.$z)return Er(a,b,"createLinksTo",h.ja,d,e,f);if(h&&h.$classData&&h.$classData.n.cA)return Er(a,b,"createLinkWith",h.ja,d,e,f);if(h&&h.$classData&&h.$classData.n.aA)return Er(a,b,"createLinksWith",h.ja,d,e,f);if(h&&h.$classData&&h.$classData.n.hA){var Ug=bd(a),ej=b.za.W(0),fj= ir(Ug,ej,d,e,f),gi=bd(a),hi=b.za.W(1),gj=sr(gi,hi,!0,!1,d,e,f),Vf,vf=bd(a),ae;if(!vf.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Compiler.scala: 55");ae=vf.Vx;if(null===ae)throw(new q).j(ae);var hj=ae.Vi(),rg=ae.pa(),ij=(new A).e(1+hj|0,rg);vf.Vx=ij;vf.a=!0;Vf=u((new v).K((new w).f(["","_",""])),(new w).f([rg,hj]));var jj=u((new v).K((new w).f(['|if (Prims.isThrottleTimeElapsed("','", workspace.selfManager.self(), ',')) {\n        |  Prims.resetThrottleTimerFor("', '", workspace.selfManager.self());\n        |',"\n        |}"])),(new w).f([Vf,fj,Vf,tr(fd(),gj)])),ii=(new Sb).c(jj);return dd(ii)}if(h&&h.$classData&&h.$classData.n.gA)return u((new v).K((new w).f(["throw new Error(",");"])),(new w).f([Fr(a,0,b,d,e,f)]));if(Gr(h)){var ji=h.ja,Pl=bd(a),sk=b.za.W(0),Vg=ir(Pl,sk,d,e,f),ki=bd(a),Ql=b.za.W(1),tk=ur(ki,Ql,!1,d,e,f),ei=u((new v).K((new w).f(["SelfManager.self().hatch(",", ",")"])),(new w).f([Vg,ed(fd(),ji)]));return vr(ei,!0,tk)}if(h&&h.$classData&&h.$classData.n.hQ){var qF= h.ja,xw=bd(a),cx=b.za.W(0),WF=ir(xw,cx,d,e,f);return u((new v).K((new w).f(["SelfManager.self().hatch(",", ",");"])),(new w).f([WF,ed(fd(),qF)]))}if(h&&h.$classData&&h.$classData.n.Hz)return u((new v).K((new w).f(["SelfManager.self().fd(-",");"])),(new w).f([Fr(a,0,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.sA)return u((new v).K((new w).f(["SelfManager.self().right(-",");"])),(new w).f([Fr(a,0,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.dA)return u((new v).K((new w).f(["world.topology.diffuse(", ", ",")"])),(new w).f([ed(fd(),Hr(b)),Fr(a,1,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.QA)return u((new v).K((new w).f(["Prims.uphill(",")"])),(new w).f([ed(fd(),Hr(b))]));if(h&&h.$classData&&h.$classData.n.RA)return u((new v).K((new w).f(["Prims.uphill4(",")"])),(new w).f([ed(fd(),Hr(b))]));if(h&&h.$classData&&h.$classData.n.eA)return u((new v).K((new w).f(["Prims.downhill(",")"])),(new w).f([ed(fd(),Hr(b))]));if(h&&h.$classData&&h.$classData.n.fA)return u((new v).K((new w).f(["Prims.downhill4(", ")"])),(new w).f([ed(fd(),Hr(b))]));if(h&&h.$classData&&h.$classData.n.NA)return u((new v).K((new w).f(["BreedManager.setDefaultShape(",".getSpecialName(), ",")"])),(new w).f([Fr(a,0,b,d,e,f),Fr(a,1,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.kA)return"SelfManager.self().setVariable('hidden?', true)";if(h&&h.$classData&&h.$classData.n.OA)return"SelfManager.self().setVariable('hidden?', false)";if(Ir(h)){var wr;var dx=jr(a,b,d,e,f),vk=u((new v).K((new w).f(['procedures["','"](',");"])),(new w).f([h.Kh.me(), dx.zb(",")])),Bn=d.Ds,am=afa();if(null!==Bn&&Bn===am&&1===e.no){bd(a);var ex=h.H(),xr=cd(ex,"maybestop"),Cn=u((new v).K((new w).f(["|let "," \x3d ","\n          |if ("," instanceof Exception.StopInterrupt) { return ","; }"])),(new w).f([xr,vk,xr,xr])),wk=(new Sb).c(Cn);wr=dd(wk)}else wr=vk;return wr}if(Jr(h)){var YF=u((new v).K((new w).f(['|if(!reporterContext) { throw new Error("REPORT can only be used inside TO-REPORT.") } else {\n            |  return ',"\n            |}"])),(new w).f([Fr(a,0, b,d,e,f)])),yr=(new Sb).c(YF);return dd(yr)}if(h&&h.$classData&&h.$classData.n.oA)return u((new v).K((new w).f(["",";"])),(new w).f([Fr(a,0,b,d,e,f)]));if(no(h)){var bm=h.Wc;if(bm.z())var zr=F();else{var ZF=bm.Y();bd(a);var $F=ZF.va,Dn=or(pr(),$F),zr=(new J).j(u((new v).K((new w).f(["let "," \x3d ","; letVars['","'] \x3d ",";"])),(new w).f([Dn,Fr(a,0,b,d,e,f),Dn,Dn])))}return zr.z()?"":zr.Y()}if(h&&h.$classData&&h.$classData.n.TA){var aG=(new v).K((new w).f(["workspace.rng.withClone(function() { ", " })"])),e7=bd(a),f7=b.za.W(0);return u(aG,(new w).f([sr(e7,f7,!0,!1,d,e,f)]))}if(Kr(h)){var h7=h.H(),i7=jr(a,b,d,e,f);return Maa(a,!1,h7,i7,f)}if(h&&h.$classData&&h.$classData.n.jA){var j7=jr(a,b,d,e,f).Ge().zb(", ");bd(a);var k7=h.H(),HG=cd(k7,"foreach"),l7=(new v).K((new w).f(["var "," \x3d Tasks.forEach(",", ","); if(reporterContext \x26\x26 "," !\x3d\x3d undefined) { return ","; }"])),m7=-1+b.za.Ga()|0;return u(l7,(new w).f([HG,Fr(a,m7,b,d,e,f),j7,HG,HG]))}if(Mr(h)){var o7=(new Sb).c("_extern\\(([^:]+):([^)]+)\\)"), p7=y(),q7=(new Tb).Ro(o7.R,p7),GZ=h.k();var Lr=Hg(q7,GZ);if(Lr.z())IG=!1;else if(null!==Lr.Y())var r7=Lr.Y(),IG=0===Ig(r7,2);else IG=!1;if(IG)var s7=Lr.Y().W(0),t7=Lr.Y().W(1);else throw(new q).j(GZ);var u7=s7,v7=t7;return u((new v).K((new w).f(["Extensions[","].prims[","](",");"])),(new w).f([ed(fd(),u7),ed(fd(),v7),jr(a,b,d,e,f).zb(", ")]))}if(d.Lo){var w7=(new v).K((new w).f(["",";"])),x7=oa(b.xd).kh(),HZ=(new Sb).c(x7),y7=HZ.R.length|0,z7=Ye(Ze(),HZ.R,1,y7);return u(w7,(new w).f([Naa(z7)]))}var A7= u((new v).K((new w).f(["unimplemented primitive: ",""])),(new w).f([b.xd.H().Wb])),B7=b.xd.H();gd(A7,B7)}function Hr(a){var b=a.za.W(0).pe;if(Nr(b))return Eh(b).toLowerCase();b=u((new v).K((new w).f(["unknown reference: ",""])),(new w).f([oa(b).kh()]));a=a.xd.H();gd(b,a)}function Fr(a,b,d,e,f,h){a=bd(a);b=d.za.W(b);return ir(a,b,e,f,h)} function $ea(a,b,d,e,f,h){a=bd(a);var k=b.za.W(0);e=ir(a,k,e,f,h);d=d?"createOrderedTurtles":"createTurtles";b=b.xd;if(!(b&&b.$classData&&b.$classData.n.kB||b&&b.$classData&&b.$classData.n.jB))throw(new df).c(u((new v).K((new w).f(["How did you get here with class of type ",""])),(new w).f([oa(b).kh()])));b=b.ja;return u((new v).K((new w).f(["world.turtleManager.","(",", ",");"])),(new w).f([d,e,ed(fd(),b)]))} function Er(a,b,d,e,f,h,k){var p=bd(a),t=b.za.W(0),t=ir(p,t,f,h,k),p=b.za.W(1).fe.Zf.He();a=bd(a);b=b.za.W(1);f=ur(a,b,!1,f,h,k);d=u((new v).K((new w).f(["LinkPrims.","(",", ",")"])),(new w).f([d,t,ed(fd(),id(e))]));return vr(d,p,f)} function Zea(a,b,d,e,f,h){var k=bd(a),p=b.za.W(0),k=ir(k,p,e,f,h);d=d?"createOrderedTurtles":"createTurtles";p=b.xd;if(!Br(p)&&!Cr(p))throw(new df).c("How did you get here with class of type "+oa(p).kh());p=p.ja;a=bd(a);b=b.za.W(1);e=ur(a,b,!1,e,f,h);f=u((new v).K((new w).f(["world.turtleManager.","(",", ",")"])),(new w).f([d,k,ed(fd(),p)]));return vr(f,!0,e)}function vr(a,b,d){return u((new v).K((new w).f(["",".ask(",", ",");"])),(new w).f([a,d,b]))}function Or(){}Or.prototype=new l; Or.prototype.constructor=Or;Or.prototype.b=function(){return this}; function bfa(a,b){var d=Pr(Qr(),(new Rr).ci(b),"returnType"),e=Sr(),d=d.Mk(e).xt(),e=d.z()?"unit":d.Y(),d="unit"!==e,f=Tr(Qr(),(new Rr).ci(b),"argTypes"),h=cfa(),f=sd(f,h).X;a=m(new n,function(){return function(a){var b=Pr(Qr(),(new Rr).ci(a),"type"),d=Sr();if((b=Ur(b,d))&&b.$classData&&b.$classData.n.uB)b=Sr(),a=Vr(sd(a,b));else if(b&&b.$classData&&b.$classData.n.wB)b=b.X,a=Pr(Qr(),(new Rr).ci(a),"isRepeatable"),d=dfa(),a=a.Mk(d).xt(),a=!(a.z()||!a.Y()),a=Vr(b)|(a?Ij():0);else throw(new q).j(b); return a}}(a));h=Mk().qc;f=Wr(f,a,h);a=Vr(e);d?(d=Pr(Qr(),(new Rr).ci(b),"isInfix"),e=dfa(),d=d.Mk(e).xt(),(d.z()?0:d.Y())?(d=f.$(),e=f.aa()):(d=nc(),e=f),d|=0,f=Pr(Qr(),(new Rr).ci(b),"precedenceOffset"),h=efa(),f=f.Mk(h).xt(),f=(f.z()?0:f.Y())|0,f=C()+f|0,a=ffa(a,d,e,f)):a=(new Xr).zx(f);d=Tr(Qr(),(new Rr).ci(b),"name");e=Sr();d=sd(d,e);b=Tr(Qr(),(new Rr).ci(b),"actionName");e=Sr();return gfa(new Yr,a,d,sd(b,e))} function Vr(a){if("agentset"===a)return Qj(D());if("agent"===a)return Lj(D());if("booleanblock"===a)return ck(D());if("boolean"===a)return Nj(D());if("bracketed"===a)return Kj();if("codeblock"===a)return uk();if("commandblock"===a)return Zj(D());if("command"===a)return Yj(D());if("linkset"===a)return Tj(D());if("link"===a)return Wj(D());if("list"===a)return Pj(D());if("nobody"===a)return Mj(D());if("numberblock"===a)return dk(D());if("number"===a)return N(D());if("optional"===a)return yk();if("otherblock"=== a)return bk(D());if("patchset"===a)return Sj(D());if("patch"===a)return Vj(D());if("readable"===a)return Zr();if("reference"===a)return Jj();if("repeatable"===a)return Ij();if("reporterblock"===a)return ak(D());if("reporter"===a)return Xj(D());if("string"===a)return Oj(D());if("symbol"===a)return xk();if("turtleset"===a)return Rj(D());if("turtle"===a)return Uj(D());if("wildcard"===a)return lc();if("unit"===a)return nc();throw Kg(Lg(),(new $r).c(u((new v).K((new w).f(["Unknown type given in extension: ", ""])),(new w).f([a]))));}Or.prototype.$classData=g({A2:0},!1,"org.nlogo.tortoise.compiler.CreateExtension$",{A2:1,d:1});var as=void 0;function hfa(){as||(as=(new Or).b());return as}function bs(){}bs.prototype=new l;bs.prototype.constructor=bs;bs.prototype.b=function(){return this};bs.prototype.$classData=g({G2:0},!1,"org.nlogo.tortoise.compiler.ExtDefReader$",{G2:1,d:1});var ifa=void 0; function jfa(a){a=u((new v).K((new w).f(["|try {\n        |  var reporterContext \x3d false;\n        |  var letVars \x3d { };\n        |","\n        |} catch (e) {\n        |  if (e instanceof Exception.StopInterrupt) {\n |    return e;\n        |  } else {\n        |    throw e;\n        |  }\n        |}"])),(new w).f([tr(fd(),a)]));a=(new Sb).c(a);return dd(a)} var sr=function kfa(b,d,e,f,h,k,p){var t=(new cs).Po(1+k.no|0,k.uc);if(yb(d))return kfa(b,d.fe,!0,!1,h,t,p);if(!(d&&d.$classData&&d.$classData.n.Dz))throw(new q).j(d);k=d.Zf;h=m(new n,function(b,d,e,f){return function(h){var k=b.ya?b.$x:lfa(b);return Xea(k,h,d,f,e)}}(b,h,p,t));p=r();b=k.xa(h,p.s).Pf(m(new n,function(){return function(b){b=(new Sb).c(b);return kd(b)}}(b))).zb("\n");return f||e&&d.oe?jfa(b):b}; function ur(a,b,d,e,f,h){a=d?u((new v).K((new w).f(["return ",";"])),(new w).f([ir(a,b,e,f,h)])):sr(a,b,!0,!1,e,f,h);b=I(r(),y());return ds(fd(),b,a)}var nfa=function mfa(b,d){if(Zg(d)){fd();var e=Mk().qc,e=Mc(d,e);for(d=Ok(d.Ac);d.qi;){var f=d.ma();e.Na(mfa(b,f))}return es(0,e.Da()," ")}if(Ph()===d)return"Nobody";b=Eo();return $b(b,d,!0,!1)};function cd(a,b){return u((new v).K((new w).f(["_","_","_",""])),(new w).f([b,a.ra.Xa,a.ra.Va]))} var ir=function ofa(b,d,e,f,h){f=(new cs).Po(1+f.no|0,f.uc);if(zb(d))return ofa(b,d.Sk,e,f,h);if(!xb(d))throw(new q).j(d);b=b.ya?b.$x:lfa(b);return pfa(b,d,e,f,h)}; function qfa(a,b,d,e,f,h,k){a=d?u((new v).K((new w).f(["return ",";"])),(new w).f([ir(a,b,f,h,k)])):sr(a,b,!0,!1,f,h,k);b=1!==e.sa()?"s":"";a=0<e.sa()?u((new v).K((new w).f(["if (arguments.length \x3c ",') {\n          |  throw new Error("anonymous procedure expected '," input",', but only got " + arguments.length);\n          |}\n          |',""])),(new w).f([e.sa(),e.sa(),b,a])):u((new v).K((new w).f(["",""])),(new w).f([a]));a=(new Sb).c(a);a=dd(a);return ds(fd(),e,a)} function fs(){this.RG=this.XR=this.NG=null;this.a=0}fs.prototype=new l;fs.prototype.constructor=fs; fs.prototype.b=function(){gs=this;for(var a=[(new A).e("!","_exclamation_"),(new A).e("#","_pound_"),(new A).e("\\$","_dollar_"),(new A).e("%","_percent_"),(new A).e("\\^","_caret_"),(new A).e("\\\x26","_ampersand_"),(new A).e("\\*","_asterisk_"),(new A).e("\x3c","_lessthan_"),(new A).e("\x3e","_greaterthan_"),(new A).e("/","_slash_"),(new A).e("\\.","_dot_"),(new A).e("\\?","_p"),(new A).e("\x3d","_eq"),(new A).e("\\+","_plus_"),(new A).e(":","_colon_"),(new A).e("'","_prime_")],b=dc(new ec,gc()), d=0,e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.NG=b.Ma;this.a=(1|this.a)<<24>>24;this.XR=I(r(),(new w).f("^(is)([A-Z].*)$ ^(on)([a-z].*)$ ^(screen)([A-Z].*)$ ^(scroll)([A-Zb].*)$ ^(webkit)([A-Z].*)$ ^(moz)([A-Z].*)$ ^(ms)([A-Z].*)$".split(" ")));this.a=(2|this.a)<<24>>24;this.RG=I(r(),(new w).f("alert atob break blur btoa case catch class clear close closed console content copy const confirm console constructor continue crypto debugger default delete do document dump else enum escape eval event export extends external false finally find focus for frames function history if implements import in instanceof inspect interface keys length let location localStorage monitor moveBy moveTo name navigator new null open opener package parent parseFloat parseInt performance print private profile profileEnd prompt protected public return screen scroll setInterval setTimeout static status statusbar stop super switch table this throw toolbar toString top true try typeof updateCommands undefined unescape uneval unmonitor unwatch valueOf values var void while window with yield".split(" "))); this.a=(4|this.a)<<24>>24;return this};function rfa(a){if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/JSIdentProvider.scala: 55");return a.RG} function sfa(a,b){return tfa(a).Gb(b,tb(new ub,function(){return function(a,b){b=(new Sb).c(b);var f=y(),f=(new Tb).Ro(b.R,f),h=f.MW;b=new hs;b.vF=a;b.jba=h;b.dm=Fg(new Gg,f.Xu,a,La(a));b.tn=0;a=new is;if(null===b)throw Kg(Lg(),null);a.Sa=b;for(a.ME=(new so).b();a.ta();)b=ufa(a),b=u((new v).K((new w).f(["","_",""])),(new w).f([nba(b,1),nba(b,2)])),to(a.Sa.dm,a.ME,b);b=(new so).KD(a.ME);uo(a.Sa.dm,b);return b.Zb}}(a)))} function vfa(a,b){var d=wfa(a);return Zl(d,b,tb(new ub,function(){return function(a,b){var d=(new A).e(a,b);a=d.kb;b=d.Ab;if(null!==b)return d=b.la(),b=b.pa(),Qb(Ia(),a,d,b);throw(new q).j(d);}}(a)))}function wfa(a){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/JSIdentProvider.scala: 26");return a.NG} function xfa(a,b){return rfa(a).Gb(b,tb(new ub,function(){return function(a,b){return a!==b?a:u((new v).K((new w).f(["_","_"])),(new w).f([a]))}}(a)))} function or(a,b){return qb(m(new n,function(){return function(a){a=a.toLowerCase();a=(new Sb).c(a);a=Ei(a,45);var b;b=[];for(var f=0,h=a.l.length;f<h;){var k=(new Sb).c(a.l[f]),k=yfa(k);b.push(null===k?null:k);f=1+f|0}a=ka(Xa(qa),b);b=(new Fm).b();f=!0;js(b,"");h=0;for(k=a.l.length;h<k;){var p=a.l[h];f?(ks(b,p),f=!1):(js(b,""),ks(b,p));h=1+h|0}js(b,"");a=b.vc.Zb;b=(new Sb).c(a);b=Ak(b);b=null===b?0:b.X;b=zfa(Uh(),b);b=(new af).Ra(b);a=(new Sb).c(a);return""+b+Sk(a)}}(a)),m(new n,function(a){return function(b){return vfa(a, b)}}(a))).Ca(m(new n,function(a){return function(b){return xfa(a,b)}}(a))).Ca(m(new n,function(a){return function(b){return sfa(a,b)}}(a))).y(b)}function tfa(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/JSIdentProvider.scala: 45");return a.XR}fs.prototype.$classData=g({I2:0},!1,"org.nlogo.tortoise.compiler.JSIdentProvider$",{I2:1,d:1});var gs=void 0;function pr(){gs||(gs=(new fs).b());return gs} function ls(){this.gh=null;this.ya=0}ls.prototype=new l;ls.prototype.constructor=ls;function Afa(a,b){b=ms(b.Pg);var d=m(new n,function(){return function(a){return(new A).e(a.la(),Bfa(a.pa()))}}(a)),e=r();b=b.xa(d,e.s);a=a.gh;d=r();return(new ls).K(b.Rc(a,d.s))}ls.prototype.K=function(a){this.gh=a;return this};ls.prototype.JF=function(){var a=this.gh,b=m(new n,function(){return function(a){return a.pa().$V(a.la())}}(this)),d=r();return a.xa(b,d.s).Oc("{",",","}")}; ls.prototype.$classData=g({J2:0},!1,"org.nlogo.tortoise.compiler.JavascriptObject",{J2:1,d:1});function ns(){}ns.prototype=new l;ns.prototype.constructor=ns;ns.prototype.b=function(){return this};function es(a,b,d){return b.He()?b.Oc("[",u((new v).K((new w).f([",",""])),(new w).f([d])),"]"):"[]"}function Cfa(a,b){a=(new Sb).c(b).R.split("\\").join("\\\\");a=(new Sb).c(a).R.split("\n").join("\\n");a=(new Sb).c(a).R.split('"').join('\\"');return(new Sb).c(a).R.split("'").join("\\'")} function Dfa(a,b){return ed(0,Cfa(0,b))}function Efa(a,b){var d=(new Sb).c(b);return kd(d)?(b=u((new v).K((new w).f(["return ",";"])),(new w).f([b])),d=I(r(),y()),ds(a,d,b)):ds(a,I(r(),y()),"")} function ds(a,b,d){b=b.Oc("(",", ",")");if(0===(d.length|0))return u((new v).K((new w).f(["function"," {}"])),(new w).f([b]));var e=(new Sb).c(d),e=Ffa(e);if(2>os(e)&&100>(d.length|0))return u((new v).K((new w).f(["function"," { "," }"])),(new w).f([b,d]));a=u((new v).K((new w).f(["|function"," {\n          |","\n          |}"])),(new w).f([b,tr(a,d)]));a=(new Sb).c(a);return dd(a)}function ed(a,b){return""+(new af).Ra(34)+b+(new af).Ra(34)} function tr(a,b){b=(new Sb).c(b);b=Ffa(b);a=(new bc).Gf(b,m(new n,function(){return function(a){return"  "+a}}(a)));return cc(a,"","\n","")}function ps(a,b){var d=(new Sb).c(b);return kd(d)?(b=u((new v).K((new w).f(["",";"])),(new w).f([b])),d=I(r(),y()),ds(a,d,b)):ds(a,I(r(),y()),"")}function qs(a){return"NIL"!==a?(new Sb).c(a).R.split("'").join("\\'"):""}ns.prototype.$classData=g({L2:0},!1,"org.nlogo.tortoise.compiler.JsOps$",{L2:1,d:1});var rs=void 0; function fd(){rs||(rs=(new ns).b());return rs}function ss(){}ss.prototype=new l;ss.prototype.constructor=ss;ss.prototype.b=function(){return this}; function Gfa(a,b,d,e,f){b=Dq(qd(),b);b=mq().Za(b);if(!nq(b)){if(!pq(b))throw(new q).j(b);var h=b.cc;b=function(){return function(a){return(new Eq).c(a)}}(a);tq();var k=b(h.Fc),h=h.Mc,p=uq().Vd,h=vq(h);a:for(;;){if(!wq(h)){if(xq(h)){var t=h,h=t.dd,t=b(t.$c),p=(new yq).Qb(t,p);continue a}throw(new q).j(h);}break}b=(new qq).j((new zq).Qb(k,p))}if(nq(b)){b=b.ha;b=ar().by().y(b);if(!nq(b)){if(!pq(b))throw(new q).j(b);b=(new qq).j(rq(b.cc))}if(nq(b))b=(new sq).j(b.ha);else if(!pq(b))throw(new q).j(b);}else if(!pq(b))throw(new q).j(b); if(!nq(b)){if(pq(b)){e=b.cc;Hfa();a=function(){return function(a){return a}}(a);tq();d=a(e.Fc);e=e.Mc;f=uq().Vd;e=vq(e);a:for(;;){if(!wq(e)){if(xq(e)){var x=e;e=x.dd;x=a(x.$c);f=(new yq).Qb(x,f);continue a}throw(new q).j(e);}break}a=(new zq).Qb(d,f);d=tq().qE;a=jba(new pe,a,d);a=a.nr.mi(a.pc);throw(new ts).c(cc(a,"","\n",""));}throw(new q).j(b);}b=b.ha;try{x=Ifa(br(),Jfa(b,e,f,d),cr())}catch(E){a=ko(Lg(),E);if(us(a))throw(new ts).c(a.Fh());throw E;}a=x.Jr.al(m(new n,function(){return function(a){if(null!== a)return a.pa().ib("__run");throw(new q).j(a);}}(a)),!1);switch(a.Ga()){case 1:return a.$().la();case 0:throw(new ts).c("The compiler did not return a procedure for the run primitive, but it also did not throw an error.");default:throw(new ts).c("The compiler returned multiple procedures with the same name for the run primitive.");}} function Jfa(a,b,d,e){b=b?u((new v).K((new w).f(["","\\nto-report __run [","] report (",") end"])),(new w).f([a.Zd,d,e])):u((new v).K((new w).f(["","\\nto __run [","] "," end"])),(new w).f([a.Zd,d,e]));return Kfa(b,a.Se,a.Rh,a.Gc,a.Yi,a.ij,a.Zg,a.Lg).Ey()} ss.prototype.isReporter=function(a){Fk();vs();var b;var d=ws(),e=ph(),f=(new xs).b();try{var h=Sp(Hc(ys()),"to __is-reporter? report "+a+"\nend",(Hc(ys()),"")),k=Tp(),p=(new bc).Gf(h,k),t=zea(Aea(new Jp,F(),!0),p,Gp(new Hp,d,e,(Kp(),nh($e().kk,y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())))),x=(new Kc).fg(t.ce).oi.rj().ma(),E=new yc,S=zc(e,t.ce);E.ec=d;E.ce=S;E.ji=x;E.hh=f;Eaa(E);for(var U=xc(uc(),t.ep.y(x.me()).Oa(),E),ga=zs(As(U),1);;){if(ga.z())Fa=!1;else var ma=ga.$().jb,va=ym(), Fa=null!==ma&&ma===va;if(Fa)ga=ga.aa();else break}var Va=Uk(ga);if(Va.z())b=!1;else{var vb=Va.Y(),pb=vb.jb;b=Am()===pb||Rm()===pb||Cm()===pb?!0:vg()===pb?!(nr(vb.X)||Wn(vb.X)||hn(vb.X)):!1}}catch(Ib){if(Jq(Ib))b=!1;else throw Ib;}return b};ss.prototype.compileRunString=function(a,b,d,e){return Gfa(this,a,b,!!d,e)};ss.prototype.stringToJSValue=function(a){var b;try{var d=(new Bs).b(),e=Lfa(Fk(),a);b=d.db(e,ld().JC)}catch(f){a=ko(Lg(),f);if(us(a))throw(new ts).c(a.Fh());throw f;}return b}; ss.prototype.$classData=g({M2:0},!1,"org.nlogo.tortoise.compiler.LiteralConverter$",{M2:1,d:1});var Cs=void 0;function Ds(){}Ds.prototype=new l;Ds.prototype.constructor=Ds;Ds.prototype.b=function(){return this};Ds.prototype.k=function(){return"nobody"};Ds.prototype.toString=function(){return"nobody"};Ds.prototype.isDead=function(){return!0};Object.defineProperty(Ds.prototype,"id",{get:function(){return-1},configurable:!0});Ds.prototype.ask=function(){}; Ds.prototype.$classData=g({Q2:0},!1,"org.nlogo.tortoise.compiler.Nobody$",{Q2:1,d:1});var Es=void 0;function Mfa(){Es||(Es=(new Ds).b());return Es}function Fs(){}Fs.prototype=new l;Fs.prototype.constructor=Fs;Fs.prototype.b=function(){return this}; function Nfa(a,b){return qb(m(new n,function(){return function(a){Gs||(Gs=(new Hs).b());return Lb(Gs,a)}}(a)),m(new n,function(){return function(a){Is||(Is=(new Js).b());return Lb(Is,a)}}(a))).Ca(m(new n,function(){return function(a){Ks||(Ks=(new Ls).b());return Lb(Ks,a)}}(a))).Ca(m(new n,function(){return function(a){Ms||(Ms=(new Ns).b());return Lb(Ms,a)}}(a))).Ca(m(new n,function(){return function(a){Os||(Os=(new Ps).b());return Lb(Os,a)}}(a))).Ca(m(new n,function(){return function(a){Qs||(Qs=(new Rs).b()); return Lb(Qs,a)}}(a))).Ca(m(new n,function(){return function(a){Ss||(Ss=(new Ts).b());return Lb(Ss,a)}}(a))).Ca(m(new n,function(){return function(a){Us||(Us=(new Vs).b());return Lb(Us,a)}}(a))).Ca(m(new n,function(){return function(a){Ws||(Ws=(new Xs).b());return Lb(Ws,a)}}(a))).Ca(m(new n,function(){return function(a){Ys||(Ys=(new Zs).b());return Lb(Ys,a)}}(a))).Ca(m(new n,function(){return function(a){$s||($s=(new at).b());return Lb($s,a)}}(a))).Ca(m(new n,function(){return function(a){bt||(bt= (new ct).b());return Lb(bt,a)}}(a))).Ca(m(new n,function(){return function(a){dt||(dt=(new et).b());return Lb(dt,a)}}(a))).Ca(m(new n,function(){return function(a){ft||(ft=(new gt).b());return Lb(ft,a)}}(a))).y(b)}Fs.prototype.$classData=g({R2:0},!1,"org.nlogo.tortoise.compiler.Optimizer$",{R2:1,d:1});var ht=void 0;function Ofa(){ht||(ht=(new Fs).b());return ht}function it(){}it.prototype=new l;it.prototype.constructor=it;it.prototype.b=function(){return this}; it.prototype.Yd=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(jt(d)&&(r(),d=(new J).j(b),null!==d.U&&0===d.U.Rb(2)&&(b=d.U.W(0),d=d.U.W(1),xb(b)&&(b=vi().Yd(b),!b.z()&&(b=b.Y().gb,Nr(b)&&xb(d))))))return(new J).j((new A).e(b,d))}d=vi().Yd(a);return!d.z()&&(a=d.Y().gb,d=d.Y().Fb,jt(a)&&(r(),d=(new J).j(d),null!==d.U&&0===d.U.Rb(2)&&(a=d.U.W(0),d=d.U.W(1),xb(a)&&xb(d)&&(d=vi().Yd(d),!d.z()&&(d=d.Y().gb,Nr(d))))))?(new J).j((new A).e(d,a)):F()}; it.prototype.$classData=g({g3:0},!1,"org.nlogo.tortoise.compiler.Optimizer$WithTransformer$PatchVarEqualExpression$",{g3:1,d:1});var kt=void 0;function lt(){}lt.prototype=new l;lt.prototype.constructor=lt;lt.prototype.b=function(){return this}; function Pfa(a,b){var d=(new mt).b(),e=r();b=b.ic(d,e.s);a=m(new n,function(){return function(a){var b=new nt;b.Wk=a;a=b.Wk.pp;if(nq(a))a=a.ha,b=Qfa(b,a.Dj,a.Ej,a.Ir);else{if(!pq(a))throw(new q).j(a);b=Rfa(b,a.cc)}return b}}(a));d=r();a=b.xa(a,d.s);b=(new ot).b();d=r();b=a.ic(b,d.s);d=(new pt).b();e=r();a=a.ic(d,e.s).cs($e().Fk);b=es(fd(),b," ");a=a.z()?"":Sfa(0,a.zb(", "));return I(r(),(new w).f([(new qt).cf("PenBundle","engine/plot/pen"),(new qt).cf("Plot","engine/plot/plot"),(new qt).cf("PlotOps", "engine/plot/plotops"),(new rt).vk("modelConfig",st(0,"window.modelConfig","{}"),I(r(),y())),(new rt).vk("modelPlotOps",st(0,"modelConfig.plotOps","{}"),I(r(),(new w).f(["modelConfig"]))),(new tt).vk("modelConfig.plots",u((new v).K((new w).f(["modelConfig.plots \x3d ",";",""])),(new w).f([b,a])),I(r(),(new w).f(["PenBundle","Plot","PlotOps","modelConfig","modelPlotOps"])))]))}function Sfa(a,b){return u((new v).K((new w).f(['modelConfig.dialog.notify("Error: ','");'])),(new w).f([b]))} function st(a,b,d){return u((new v).K((new w).f(["(typeof ",' !\x3d\x3d "undefined" \x26\x26 '," !\x3d\x3d null) ? "," : ",""])),(new w).f([b,b,b,d]))}lt.prototype.$classData=g({h3:0},!1,"org.nlogo.tortoise.compiler.PlotCompiler$",{h3:1,d:1});var ut=void 0;function vt(){ut||(ut=(new lt).b());return ut}function nt(){this.Wk=null}nt.prototype=new l;nt.prototype.constructor=nt; function Tfa(a,b){a=function(){return function(a){return a.Fh()}}(a);tq();var d=a(b.Fc);b=b.Mc;var e=uq().Vd;b=vq(b);a:for(;;){if(!wq(b)){if(xq(b)){var f=b;b=f.dd;f=a(f.$c);e=(new yq).Qb(f,e);continue a}throw(new q).j(b);}break}return(new wt).K(xt((new zq).Qb(d,e)).ub())}function Ufa(a){var b=(new v).K((new w).f(["PenBundle.DisplayMode.",""]));switch(a){case 0:a="Line";break;case 1:a="Bar";break;case 2:a="Point";break;default:a="Line"}return u(b,(new w).f([a]))} function Rfa(a,b){a=function(){return function(a){return a.Fh()}}(a);tq();var d=a(b.Fc);b=b.Mc;var e=uq().Vd;b=vq(b);a:for(;;){if(!wq(b)){if(xq(b)){var f=b;b=f.dd;f=a(f.$c);e=(new yq).Qb(f,e);continue a}throw(new q).j(b);}break}return(new wt).K(xt((new zq).Qb(d,e)).ub())} function Qfa(a,b,d,e){var f=ps(fd(),""),h=Efa(fd(),f),f=u((new v).K((new w).f("new PlotOps(;, ;, ;, ;, ;, ;, ;)".split(";"))),(new w).f([f,f,f,h,h,h,h])),h=m(new n,function(a){return function(b){var d=b.Us;if(nq(d)){b=b.Cs;var d=d.ha,e=(new v).K((new w).f(["new PenBundle.State(",", ",", ",")"]));Zb||(Zb=(new yt).b());e=u(e,(new w).f([vaa(b.yb),b.fl,Ufa(b.il)]));b=I(r(),(new w).f([u((new v).K((new w).f(["'","'"])),(new w).f([b.Ya])),"plotOps.makePenOps","false",e,d.Dj,d.Ej]));b=(new zt).c(u((new v).K((new w).f(["new PenBundle.Pen(", ")"])),(new w).f([b.zb(", ")])))}else{if(!pq(d))throw(new q).j(d);b=Tfa(a,d.cc)}return b}}(a)),k=r();e=e.xa(h,k.s);var h=(new ot).b(),k=r(),h=e.ic(h,k.s),k=(new pt).b(),p=r(),k=e.ic(k,p.s).cs($e().Fk);e=es(fd(),h,"\n");h=k.z()?"":Sfa(vt(),k.zb(", "));k=r();fd();fd();p=a.Wk.Ni.Wn;p=ed(0,qs(p.z()?"":p.Y()));fd();fd();var t=a.Wk.Ni.Yn,t=ed(0,qs(t.z()?"":t.Y())),k=I(k,(new w).f(["name","pens","plotOps",p,t,a.Wk.Ni.on,a.Wk.Ni.Nm,a.Wk.Ni.Pi,a.Wk.Ni.Oi,a.Wk.Ni.Ri,a.Wk.Ni.Qi,"setup","update"])).zb(", "); a=u((new v).K((new w).f("|var name    \x3d ',';\n            |var plotOps \x3d ,;\n            |var pens    \x3d ,;,\n            |var setup   \x3d ,;\n            |var update  \x3d ,;\n            |return new Plot(,);".split(","))),(new w).f([a.Wk.LS,st(vt(),"modelPlotOps[name]",f),e,h,b,d,k]));a=(new Sb).c(a);a=dd(a);b=(new v).K((new w).f(["(",")()"]));d=I(r(),y());return(new zt).c(u(b,(new w).f([ds(fd(),d,a)])))} nt.prototype.$classData=g({m3:0},!1,"org.nlogo.tortoise.compiler.PlotCompiler$RichCompiledPlot",{m3:1,d:1});function At(){this.SS=this.VS=this.bj=null}At.prototype=new l;At.prototype.constructor=At;function Vfa(a,b,d,e){a.bj=b;a.VS=d;a.SS=e;return a} function Wfa(a,b){a=m(new n,function(a){return function(b){var d=a.VS,k=a.SS,p=d.bp?Nfa(Ofa(),b):b;b=p.ji.me();var t=or(pr(),b),x=a.bj,E=(new A).e(0,t);x.Vx=E;x.a=!0;E=sc(p.ji);Lk();x=Mk().qc;x=Mc(E,x);for(E=Ok(E);E.qi;){var S=E.ma();x.Na(or(pr(),S))}E=x.Da();x=new Bt;x.lq=!0;x.cp=E;p.ji.$u.jn?(d=sr(a.bj,p.fe,!1,!1,d,k,x),d=u((new v).K((new w).f(["|try {\n        |  var reporterContext \x3d true;\n        |  var letVars \x3d { };\n        |",'\n        |  throw new Error("Reached end of reporter procedure without REPORT being called.");\n        |} catch (e) {\n        | if (e instanceof Exception.StopInterrupt) {\n        |    throw new Error("STOP is not allowed inside TO-REPORT.");\n        |  } else {\n        |    throw e;\n        |  }\n        |}'])), (new w).f([tr(fd(),d)])),d=(new Sb).c(d),d=dd(d)):d=sr(a.bj,p.fe,!0,!0,d,k,x);d=u((new v).K((new w).f(["(",")"])),(new w).f([ds(fd(),x.cp,d)]));return(new A).e(d,I(r(),(new w).f([t,b])).ui())}}(a));var d=r();return b.xa(a,d.s)}At.prototype.$classData=g({r3:0},!1,"org.nlogo.tortoise.compiler.ProcedureCompiler",{r3:1,d:1});function Ct(){}Ct.prototype=new l;Ct.prototype.constructor=Ct;Ct.prototype.b=function(){return this}; function Xfa(a,b){a=m(new n,function(a){return function(b){if(null!==b){var d=b.la();b=b.pa();var k=m(new n,function(){return function(a){return u((new v).K((new w).f(['procs["','"] \x3d temp;'])),(new w).f([a]))}}(a)),p=r();return b.xa(k,p.s).Oc(u((new v).K((new w).f(["temp \x3d ",";\\n"])),(new w).f([d])),"\n","")}throw(new q).j(b);}}(a));var d=r();b=b.xa(a,d.s).zb("\n");b=u((new v).K((new w).f(["|var procs \x3d {};\n          |var temp \x3d undefined;\n          |","\n          |return procs;"])), (new w).f([b]));b=(new Sb).c(b);b=dd(b);a=(new v).K((new w).f(["(",")()"]));d=I(r(),y());return u(a,(new w).f([ds(fd(),d,b)]))}function Yfa(a){var b=Dt;return I(r(),(new w).f([(new rt).vk("procedures",Xfa(b,a),I(r(),(new w).f(["workspace","world"])))]))}Ct.prototype.$classData=g({s3:0},!1,"org.nlogo.tortoise.compiler.ProcedureCompiler$",{s3:1,d:1});var Dt=void 0;function Et(a,b,d,e,f){b=b.za;var h=new Ft;if(null===a)throw Kg(Lg(),null);h.Sa=a;h.XS=d;h.US=e;h.PV=f;a=r();return b.ic(h,a.s)} function Zfa(a){r();var b=(new J).j(a);if(null!==b.U&&0===b.U.Rb(1))return a=b.U.W(0),u((new v).K((new w).f(["Prims.rangeUnary(",")"])),(new w).f([a]));r();b=(new J).j(a);if(null!==b.U&&0===b.U.Rb(2))return a=b.U.W(0),b=b.U.W(1),u((new v).K((new w).f(["Prims.rangeBinary(",", ",")"])),(new w).f([a,b]));r();var d=(new J).j(a);if(null!==d.U&&0===d.U.Rb(3))return a=d.U.W(0),b=d.U.W(1),d=d.U.W(2),u((new v).K((new w).f(["Prims.rangeTernary(",", ",", ",")"])),(new w).f([a,b,d]));throw(new df).c("range expects at most three arguments"); }function $fa(a){return u((new v).K((new w).f(["SelfManager.self()._optimalNSum4(",")"])),(new w).f([ed(fd(),a)]))}function Gt(a,b,d,e,f,h){a=bd(a);b=d.za.W(b);return ir(a,b,e,f,h)}function aga(a){return u((new v).K((new w).f(["SelfManager.self()._optimalNSum(",")"])),(new w).f([ed(fd(),a)]))}function bga(a,b,d,e,f){var h=bd(a),k=b.za.W(1),h=ir(h,k,d,e,f);a=bd(a);b=b.za.W(0);d=ur(a,b,!0,d,e,f);return u((new v).K((new w).f(["",".projectionBy(",")"])),(new w).f([h,d]))} function pfa(a,b,d,e,f){var h=b.pe;ld();var k=(new Ht).b(),p=md(new nd,k).Uc(h);if(!p.z())return p.Y();ld();var t=(new It).b(),x=md(new nd,t).Uc(h);if(!x.z()){var E=x.Y();return u((new v).K((new w).f(["("," "," ",")"])),(new w).f([Gt(a,0,b,d,e,f),E,Gt(a,1,b,d,e,f)]))}ld();var S=(new Jt).b(),U=md(new nd,S).Uc(h);if(!U.z()){var ga=U.Y();return u((new v).K((new w).f(["","(",")"])),(new w).f([ga,Et(a,b,d,e,f).zb(", ")]))}ld();var ma=(new Kt).b(),va=md(new nd,ma).Uc(h);if(!va.z()){var Fa=va.Y();return u((new v).K((new w).f(["NLType(", ").",""])),(new w).f([Gt(a,0,b,d,e,f),Fa]))}var Va=cga(a).PF(h);if(!Va.z())return Va.Y();if(Do(h)){var vb=bd(a);return nfa(vb,h.X)}if(nr(h)){bd(a);var pb=h.Wc.va;return or(pr(),pb)}if(qr(h)){bd(a);var Ib=h.va;return or(pr(),Ib)}if(Go(h)){bd(a);var kc=h.va;return or(pr(),kc)}if(Lt(h))return u((new v).K((new w).f(['procedures["','"](',")"])),(new w).f([h.Kh.me(),Et(a,b,d,e,f).zb(",")]));if(h&&h.$classData&&h.$classData.n.Mz)return u((new v).K((new w).f([" -",""])),(new w).f([Gt(a,0,b,d,e,f)]));if(h&& h.$classData&&h.$classData.n.Jz)return u((new v).K((new w).f(["!",""])),(new w).f([Gt(a,0,b,d,e,f)]));if(Mt(h))return u((new v).K((new w).f(["",".size()"])),(new w).f([Gt(a,0,b,d,e,f)]));if(Nt(h))return u((new v).K((new w).f(["!",".isEmpty()"])),(new w).f([Gt(a,0,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.Nz){var $a=Et(a,b,d,e,f),fc=r(),Bc=$a.fd("",fc.s),sf=m(new n,function(){return function(a){return u((new v).K((new w).f(["workspace.dump(",")"])),(new w).f([a]))}}(a)),Sf=r();return Bc.xa(sf, Sf.s).Oc("("," + ",")")}if(Ot(h))return bga(a,b,d,e,f);if(h&&h.$classData&&h.$classData.n.nA)return u((new v).K((new w).f(["("," ? "," : ",")"])),(new w).f([Gt(a,0,b,d,e,f),Gt(a,1,b,d,e,f),Gt(a,2,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.LA)return u((new v).K((new w).f(["",".reduce(",")"])),(new w).f([Gt(a,1,b,d,e,f),Gt(a,0,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.iA)return u((new v).K((new w).f(["",".filter(",")"])),(new w).f([Gt(a,1,b,d,e,f),Gt(a,0,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.GA)return u((new v).K((new w).f(["Tasks.nValues(", ", ",")"])),(new w).f([Gt(a,0,b,d,e,f),Gt(a,1,b,d,e,f)]));if(Pt(h)){var th=h.Wc;if(Vk(th)){var Te=th.U,tf=(new v).K((new w).f(["_error_",".message"])),ek=Q();return u(tf,(new w).f([R(ek,Te)]))}}if(Qt(h)){var og=Gt(a,0,b,d,e,f),uh=(new v).K((new w).f(["",".agentFilter(",")"])),pg=bd(a),Yh=b.za.W(1);return u(uh,(new w).f([og,ur(pg,Yh,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.zA){var Ri=Gt(a,1,b,d,e,f),fk=(new v).K((new w).f(["",".maxNOf(",", ",")"])),Si=Gt(a,0,b,d,e,f),gk=bd(a),Ti=b.za.W(2);return u(fk, (new w).f([Ri,Si,ur(gk,Ti,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.AA){var vl=Gt(a,0,b,d,e,f),Ui=(new v).K((new w).f(["",".maxOneOf(",")"])),hk=bd(a),Vi=b.za.W(1);return u(Ui,(new w).f([vl,ur(hk,Vi,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.BA){var wl=Gt(a,1,b,d,e,f),vh=(new v).K((new w).f(["",".minNOf(",", ",")"])),xl=Gt(a,0,b,d,e,f),wh=bd(a),ik=b.za.W(2);return u(vh,(new w).f([wl,xl,ur(wh,ik,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.CA){var yl=Gt(a,0,b,d,e,f),Zh=(new v).K((new w).f(["", ".minOneOf(",")"])),$h=bd(a),zl=b.za.W(1);return u(Zh,(new w).f([yl,ur($h,zl,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.Sz){var Al=Gt(a,0,b,d,e,f),Bl=(new v).K((new w).f(["",".agentAll(",")"])),jk=bd(a),Cl=b.za.W(1);return u(Bl,(new w).f([Al,ur(jk,Cl,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.UA){var Dl=Gt(a,0,b,d,e,f),El=(new v).K((new w).f(["",".maxesBy(",")"])),Fl=bd(a),kk=b.za.W(1);return u(El,(new w).f([Dl,ur(Fl,kk,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.VA){var Gl=Gt(a,0,b, d,e,f),ai=(new v).K((new w).f(["",".minsBy(",")"])),lk=bd(a),xh=b.za.W(1);return u(ai,(new w).f([Gl,ur(lk,xh,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.Tz){var Hl=Gt(a,0,b,d,e,f);return u((new v).K((new w).f(["",".atPoints(",")"])),(new w).f([Hl,Gt(a,1,b,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.PA){var Wi=Gt(a,1,b,d,e,f),mk=(new v).K((new w).f(["",".sortOn(",")"])),yh=bd(a),Uf=b.za.W(0);return u(mk,(new w).f([Wi,ur(yh,Uf,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.iQ)return aga(h.Ok); if(h&&h.$classData&&h.$classData.n.jQ)return $fa(h.Ok);if(h&&h.$classData&&h.$classData.n.lQ){var ue=Gt(a,0,b,d,e,f),zh=(new v).K((new w).f(["","._optimalOtherWith(",")"])),bi=bd(a),nk=b.za.W(1);return u(zh,(new w).f([ue,ur(bi,nk,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.kQ){var Xi=Gt(a,0,b,d,e,f),Il=(new v).K((new w).f(["","._optimalOneOfWith(",")"])),Yi=bd(a),Jl=b.za.W(1);return u(Il,(new w).f([Xi,ur(Yi,Jl,!0,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.Iz)return u((new v).K((new w).f(["world.turtleManager.turtlesOfBreed(", ")"])),(new w).f([ed(fd(),h.ja)]));if(h&&h.$classData&&h.$classData.n.Xz)return u((new v).K((new w).f(["world.turtleManager.getTurtleOfBreed(",", ",")"])),(new w).f([ed(fd(),h.ja),Gt(a,0,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.tA)return u((new v).K((new w).f(["world.linkManager.linksOfBreed(",")"])),(new w).f([ed(fd(),h.ja)]));if(h&&h.$classData&&h.$classData.n.uA)return u((new v).K((new w).f(["world.linkManager.getLink(",", ",", ",")"])),(new w).f([Gt(a,0,b,d,e,f),Gt(a,1,b,d,e,f),ed(fd(), h.ja)]));if(h&&h.$classData&&h.$classData.n.Uz)return u((new v).K((new w).f(["SelfManager.self().breedAt(",", ",", ",")"])),(new w).f([ed(fd(),h.ja),Gt(a,0,b,d,e,f),Gt(a,1,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.Vz)return u((new v).K((new w).f(["SelfManager.self().breedHere(",")"])),(new w).f([ed(fd(),h.ja)]));if(h&&h.$classData&&h.$classData.n.Wz)return u((new v).K((new w).f(["Prims.breedOn(",", ",")"])),(new w).f([ed(fd(),h.ja),Gt(a,0,b,d,e,f)]));if(h&&h.$classData&&h.$classData.n.pA){var Zi= (new v).K((new w).f(["LinkPrims.inLinkFrom(",", ",")"]));fd();return u(Zi,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.qA){var $i=(new v).K((new w).f(["LinkPrims.isInLinkNeighbor(",", ",")"]));fd();return u($i,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.rA){var ok=(new v).K((new w).f(["LinkPrims.inLinkNeighbors(",")"]));fd();return u(ok,(new w).f([ed(0,id(h.ja))]))}if(h&&h.$classData&&h.$classData.n.vA){var Kl=(new v).K((new w).f(["LinkPrims.isLinkNeighbor(", ", ",")"]));fd();return u(Kl,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.wA){var aj=(new v).K((new w).f(["LinkPrims.linkNeighbors(",")"]));fd();return u(aj,(new w).f([ed(0,id(h.ja))]))}if(h&&h.$classData&&h.$classData.n.xA){var ci=(new v).K((new w).f(["LinkPrims.linkWith(",", ",")"]));fd();return u(ci,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.DA){var Ll=(new v).K((new w).f(["LinkPrims.myInLinks(",")"]));fd();return u(Ll,(new w).f([ed(0, id(h.ja))]))}if(h&&h.$classData&&h.$classData.n.EA){var Rg=(new v).K((new w).f(["LinkPrims.myLinks(",")"]));fd();return u(Rg,(new w).f([ed(0,id(h.ja))]))}if(h&&h.$classData&&h.$classData.n.FA){var Sg=(new v).K((new w).f(["LinkPrims.myOutLinks(",")"]));fd();return u(Sg,(new w).f([ed(0,id(h.ja))]))}if(h&&h.$classData&&h.$classData.n.HA){var pk=(new v).K((new w).f(["LinkPrims.isOutLinkNeighbor(",", ",")"]));fd();return u(pk,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.IA){var bj= (new v).K((new w).f(["LinkPrims.outLinkNeighbors(",")"]));fd();return u(bj,(new w).f([ed(0,id(h.ja))]))}if(h&&h.$classData&&h.$classData.n.JA){var Ah=(new v).K((new w).f(["LinkPrims.outLinkTo(",", ",")"]));fd();return u(Ah,(new w).f([ed(0,id(h.ja)),Gt(a,0,b,d,e,f)]))}if(h&&h.$classData&&h.$classData.n.MA){var qk=h.H(),Ml=Et(a,b,d,e,f);return Maa(a,!0,qk,Ml,f)}if(Rt(h)){var rk=b.za.W(0),Tg=h.ve.lk(),Nl=bd(a),cj=m(new n,function(){return function(a){return or(pr(),a)}}(a,Nl)),di=r(),Bh=Tg.xa(cj,di.s), Ol=dga(a,rk,!0,Bh,h.uc,d,e,f);return u((new v).K((new w).f(["Tasks.reporterTask(",")"])),(new w).f([Ol]))}if(Fo(h)){var qg=b.za.W(0),fi=h.ve.lk(),Ch=bd(a),dj=m(new n,function(){return function(a){return or(pr(),a)}}(a,Ch)),Ug=r(),ej=fi.xa(dj,Ug.s),fj=dga(a,qg,!1,ej,h.uc,d,e,f);return u((new v).K((new w).f(["Tasks.commandTask(",")"])),(new w).f([fj]))}if(St(h)){var gi=(new Sb).c("_externreport\\(([^:]+):([^)]+)\\)"),hi=y(),gj=(new Tb).Ro(gi.R,hi),Vf=h.k();var vf,ae=Hg(gj,Vf);if(ae.z())rg=!1;else if(null!== ae.Y())var hj=ae.Y(),rg=0===Ig(hj,2);else rg=!1;if(rg){var ij=ae.Y().W(0),jj=ae.Y().W(1);vf=(new A).e(ij,jj)}else throw(new q).j(Vf);var ii=vf.la(),ji=vf.pa();return u((new v).K((new w).f(["Extensions[","].prims[","](",")"])),(new w).f([ed(fd(),ii),ed(fd(),ji),Et(a,b,d,e,f).zb(", ")]))}if(h&&h.$classData&&h.$classData.n.KA){var Pl=Et(a,b,d,e,f);return Zfa(Pl)}if(d.Lo){var sk=oa(b.pe).kh(),Vg=(new Sb).c(sk),ki=Vg.R.length|0,Ql=Ye(Ze(),Vg.R,1,ki);return Naa(Ql)}var tk=u((new v).K((new w).f(["unimplemented primitive: ", ""])),(new w).f([b.pe.H().Wb])),ei=b.pe.H();gd(tk,ei)}function dga(a,b,d,e,f,h,k,p){var t=(new v).K((new w).f(["",", ",""]));a=bd(a);return u(t,(new w).f([qfa(a,b,d,e,h,k,p),Dfa(fd(),f.z()?"":f.Y())]))}function Tt(){this.qV=this.Sf=this.Gc=this.ec=null}Tt.prototype=new l;Tt.prototype.constructor=Tt; function ega(a){var b=r(),d=(new rt).vk("turtleShapes",fga(gga(new Ut,vj(),hga(Vt(),a.Sf.Zg))),I(r(),y())),e=(new rt).vk("linkShapes",fga(gga(new Ut,xj(),hga(Vt(),a.Sf.Lg))),I(r(),y())),f=r(),h=I(r(),(new w).f([iga(a)])),k=jga(a),p=I(r(),(new w).f([u((new v).K((new w).f(["'","'"])),(new w).f([Cfa(fd(),a.Sf.Zd)]))])),t=r();fd();var x=a.Gc,E=m(new n,function(){return function(a){a=kga(a).Ye();return od(a)}}(a)),S=r();return I(b,(new w).f([d,e,(new Wt).su(I(f,(new w).f([h,k,p,I(t,(new w).f([es(0,x.xa(E, S.s)," ")])),I(r(),(new w).f(['tortoise_require("extensions/all").dumpers()'])),lga(a)])),I(r(),(new w).f(["turtleShapes","linkShapes"]))),Xt("BreedManager"),Xt("ExportPrims"),Xt("LayoutManager"),Xt("LinkPrims"),Xt("ListPrims"),Xt("MousePrims"),Xt("OutputPrims"),Xt("plotManager"),Xt("Prims"),Xt("PrintPrims"),Xt("SelfPrims"),Xt("SelfManager"),Xt("UserDialogPrims"),Xt("Updater"),Xt("world"),(new qt).cf("Exception","util/exception"),(new qt).cf("NLMath","util/nlmath"),(new qt).cf("notImplemented","util/notimplemented"), (new qt).cf("ColorModel","engine/core/colormodel"),(new qt).cf("Link","engine/core/link"),(new qt).cf("LinkSet","engine/core/linkset"),(new qt).cf("PatchSet","engine/core/patchset"),(new qt).cf("Turtle","engine/core/turtle"),(new qt).cf("TurtleSet","engine/core/turtleset"),(new qt).cf("NLType","engine/core/typechecker"),(new qt).cf("Tasks","engine/prim/tasks"),(new qt).cf("AgentModel","agentmodel"),(new qt).cf("Meta","meta"),(new qt).cf("Random","shim/random"),(new qt).cf("StrictMath","shim/strictmath"), mga()]))} function jga(a){var b=Rp(a.ec),d=Yt($e(),nga()),d=Zt(b,d),b=Qp(a.ec),e=Yt($e(),oga()),b=Zt(b,e);fd();var e=m(new n,function(){return function(a){return a.toLowerCase()}}(a)),f=r(),d=d.xa(e,f.s),e=m(new n,function(){return function(a){return ed(fd(),a)}}(a)),f=r(),d=es(0,d.xa(e,f.s)," ");fd();e=m(new n,function(){return function(a){return a.toLowerCase()}}(a));f=r();b=b.xa(e,f.s);a=m(new n,function(){return function(a){return ed(fd(),a)}}(a));e=r();a=es(0,b.xa(a,e.s)," ");return I(r(),(new w).f([a,d]))} function Xt(a){var b=(new Sb).c(a),b=Ak(b),b=null===b?0:b.X,b=zfa(Uh(),b),b=(new af).Ra(b),d=(new Sb).c(a),b=""+b+Sk(d);return(new rt).vk(a,u((new v).K((new w).f(["workspace.",""])),(new w).f([b])),I(r(),(new w).f(["workspace"])))}function fga(a){var b=Ic(a.Nq);return kd(b)?pga($t(),a):"{}"}function qga(a,b,d,e){var f=new Tt;f.ec=a;f.Gc=b;f.Sf=d;f.qV=e;return f} function lga(a){var b=Dea(a.ec),d=Yt($e(),rga()),b=Zt(b,d);fd();var d=Pp(a.ec),e=m(new n,function(){return function(a){return a.toLowerCase()}}(a)),f=r(),d=d.xa(e,f.s),e=m(new n,function(){return function(a){return ed(fd(),a)}}(a)),f=r(),d=es(0,d.xa(e,f.s)," ");fd();var e=a.ec.Qj,f=m(new n,function(){return function(a){return a.toLowerCase()}}(a)),h=r(),e=e.xa(f,h.s),f=m(new n,function(){return function(a){return ed(fd(),a)}}(a)),h=r(),e=es(0,e.xa(f,h.s)," ");fd();f=m(new n,function(){return function(a){return a.toLowerCase()}}(a)); h=r();b=b.xa(f,h.s);f=m(new n,function(){return function(a){return ed(fd(),a)}}(a));h=r();b=es(0,b.xa(f,h.s)," ");f=sga(a.Sf);b=I(r(),(new w).f([d,e,b,tga(f),uga(f),vga(f),wga(f),xga(f),yga(f),zga(f),"turtleShapes","linkShapes",a.qV]));a=m(new n,function(){return function(a){return na(a)}}(a));d=r();return b.xa(a,d.s)} function iga(a){var b=(new Kc).fg(a.ec.bg),d=(new Kc).fg(a.ec.Hf),e=Lc().s,b=au(b,d,e);a=m(new n,function(a){return function(b){var d=ed(fd(),b.va),e=ed(fd(),b.Bf.toLowerCase());fd();var t=b.nl,x=m(new n,function(){return function(a){return a.toLowerCase()}}(a)),E=r(),t=t.xa(x,E.s),x=m(new n,function(){return function(a){return ed(fd(),a)}}(a)),E=r(),t=es(0,t.xa(x,E.s)," ");b=b.Kg?u((new v).K((new w).f([", isDirected: ",""])),(new w).f([b.Jg])):"";return u((new v).K((new w).f(["{ name: ",", singular: ", ", varNames: ",""," }"])),(new w).f([d,e,t,b]))}}(a));d=Lc();a=b.xa(a,d.s).Hc();return es(fd(),a," ")}Tt.prototype.$classData=g({y3:0},!1,"org.nlogo.tortoise.compiler.RuntimeInit",{y3:1,d:1});function bu(){}bu.prototype=new l;bu.prototype.constructor=bu; function Aga(a,b){var d=m(new n,function(){return function(a){return a.Bn()}}(a)),e=r(),d=b.xa(d,e.s),e=r(),d=d.De(b,e.s).te($e().Fk),e=m(new n,function(a){return function(b){var d=b.Qr();b=m(new n,function(a,b){return function(a){var d=b.Bn();return(new A).e(a,d)}}(a,b));var e=r();return d.xa(b,e.s)}}(a)),f=r();b=b.aj(e,f.s).ed();var e=Ic(d),f=m(new n,function(){return function(a){return cu(a).Me.pa()}}(a)),h=$l(),h=cm(h),f=Wr(b,f,h),e=Jc(e,f);b=Bga(a,I(r(),(new w).f([e])),b);a=m(new n,function(a, b){return function(a){var d=$l(),d=cm(d);a=Wr(a,b,d).Hc();d=(new du).b();return Cga(a,d)}}(a,d));d=r();return b.aj(a,d.s)}bu.prototype.b=function(){return this};function Dga(a,b){var d=m(new n,function(){return function(a){return a.Bn()}}(a)),e=r(),d=b.xa(d,e.s);a=m(new n,function(){return function(a){return a.Qr()}}(a));e=r();b=b.aj(a,e.s).ed();d=d.ed();return Jc(b,d)} function Ega(a,b){var d=Dga(a,b);if(d.z())return b=Aga(a,b),a=m(new n,function(){return function(a){return a.Hv()}}(a)),d=r(),b.xa(a,d.s).Oc("","\n","\n");throw(new df).c(u((new v).K((new w).f(["Please provide the following dependencies: ",""])),(new w).f([cc(d,"",", ","")])));} function Bga(a,b,d){for(;;)if(kd(d)){var e=eu(d,m(new n,function(a,b){return function(a){return b.gd().ib(cu(a).Me.la())}}(a,b)));if(null===e)throw(new q).j(e);var f=e.la(),e=e.pa(),h=m(new n,function(){return function(a){return cu(a).Me.pa()}}(a)),k=$l(),k=cm(k),f=Wr(f,h,k),h=m(new n,function(){return function(a){return cu(a).Me.pa()}}(a)),k=$l(),k=cm(k),f=f.Pk(Wr(e,h,k));if(kd(f))d=r(),b=b.mc(f,d.s),d=e;else throw e=d,a=m(new n,function(){return function(a){return u((new v).K((new w).f(["from ", " to ",""])),(new w).f([a.pa(),a.la()]))}}(a)),b=$l(),b=cm(b),a=Wr(e,a,b).zb(",\n"),(new df).c(u((new v).K((new w).f(["unable to satisfy dependencies: ",""])),(new w).f([a])));}else return b}bu.prototype.$classData=g({H3:0},!1,"org.nlogo.tortoise.compiler.TortoiseLoader$",{H3:1,d:1});var fu=void 0;function gu(){this.Me=null}gu.prototype=new l;gu.prototype.constructor=gu;function cu(a){var b=new gu;b.Me=a;return b} gu.prototype.$classData=g({I3:0},!1,"org.nlogo.tortoise.compiler.TortoiseLoader$RichEdge$2",{I3:1,d:1});function hu(){this.vC=this.uC=null}hu.prototype=new l;hu.prototype.constructor=hu; function Fga(a,b){if(iu(b)){fd();var d=b.Ya,d=qs(d.z()?"":d.Y()),e=r(),f=(new A).e("setup",b.lg),e=I(e,(new w).f([f,(new A).e("update",b.ng)])),f=m(new n,function(a,b){return function(d){if(null!==d){var e=d.la();d=d.pa();ju();d=Gga(a,d,b,F());return ku(lu(d),"plot",b,e)}throw(new q).j(d);}}(a,d)),h=r(),f=e.xa(f,h.s);r();e=(new J).j(f);if(null!==e.U&&0===e.U.Rb(2))f=e.U.W(0),e=e.U.W(1);else throw(new q).j(f);Gq();var h=tq(),h=(new Yq).gq(h),h=mu(h),k=(new sq).j(tb(new ub,function(a,b,d){return function(e, f){var h=d.zn,k=function(a,b){return function(d){return Hga(a,b,d)}}(a,b),p=B().s;if(p===B().s)if(h===y())k=y();else{for(var p=h.$(),t=p=Cd(new Dd,k(p),y()),h=h.aa();h!==y();)var vb=h.$(),vb=Cd(new Dd,k(vb),y()),t=t.Ia=vb,h=h.aa();k=p}else{for(p=Mc(h,p);!h.z();)t=h.$(),p.Na(k(t)),h=h.aa();k=p.Da()}return(new nu).vk(e,f,k)}}(a,d,b))),h=a=h.Ym,k=(new A).e(f,(new sq).j(sb(k.ha)));a:{var p=k.kb,t=k.Ab;if(nq(p)&&(p=p.ha,nq(t))){f=(new sq).j(t.ha.y(p));break a}t=k.kb;p=k.Ab;if(pq(t)&&nq(p))f=t;else if(t= k.Ab,nq(k.kb)&&pq(t))f=t;else{p=k.kb;t=k.Ab;if(pq(p)&&(p=p.cc,pq(t))){f=(new qq).j(h.Xb(t.cc,K(function(a,b){return function(){return b}}(f,p))));break a}throw(new q).j(k);}}f=(new A).e(e,f);a:{k=f.kb;h=f.Ab;if(nq(k)&&(k=k.ha,nq(h))){e=(new sq).j(h.ha.y(k));break a}h=f.kb;k=f.Ab;if(pq(h)&&nq(k))e=h;else if(h=f.Ab,nq(f.kb)&&pq(h))e=h;else{k=f.kb;h=f.Ab;if(pq(k)&&(k=k.cc,pq(h))){e=(new qq).j(a.Xb(h.cc,K(function(a,b){return function(){return b}}(e,k))));break a}throw(new q).j(f);}}return Iga(b,d,e)}if(ou(b))return(new pu).ju(b, Jga(a,b));if(qu(b))return(new pu).ju(b,Kga(a,b));if(ru(b))return(new pu).ju(b,Lga(a,b));Pq();d=Mga();return(new pu).ju(b,Vq().y(d))} function Lga(a,b){var d=r(),e=(new A).e("min",b.sn),f=(new A).e("max",b.em),d=I(d,(new w).f([e,f,(new A).e("step",b.vm)]));b=jaa(tb(new ub,function(a,b){return function(d,e){ju();e=a.vC.y(e);var f=b.Ya;return ku(lu(e),"slider",f.z()?b.Ys():f.Y(),d)}}(a,b)));e=r();b=d.xa(b,e.s);r();d=(new J).j(b);if(null!==d.U&&0===d.U.Rb(3))f=d.U.W(0),b=d.U.W(1),e=d.U.W(2);else throw(new q).j(b);d=b;b=e;Gq();var e=tq(),e=(new Yq).gq(e),e=mu(e),h=K(function(a,b){return function(){return b}}(a,f)),f=(new sq).j(tb(new ub, function(a,b){return function(a,d){var e=a.la();a=a.pa();return(0,b.vi)(e,a,d)}}(e,su(function(){return function(a,b,d){var e=new tu;e.Hr=a;e.Gr=b;e.Lr=d;return e}}(a)))));a=e.Ym;var k=(new sq).j(tb(new ub,function(){return function(a,b){return(new A).e(a,b)}}(e))),d=Nga(d,K(function(a,b,d){return function(){return a.$e(b,K(function(a,b){return function(){return a.Xc(b,m(new n,function(){return function(a){return sb(a)}}(a)))}}(a,d)))}}(e,h,k)),e.Ym),e=e.Ym,f=(new A).e(d,(new sq).j(sb(f.ha)));a:{k= f.kb;h=f.Ab;if(nq(k)&&(k=k.ha,nq(h))){d=(new sq).j(h.ha.y(k));break a}h=f.kb;k=f.Ab;if(pq(h)&&nq(k))d=h;else if(h=f.Ab,nq(f.kb)&&pq(h))d=h;else{k=f.kb;h=f.Ab;if(pq(k)&&(k=k.cc,pq(h))){d=(new qq).j(e.Xb(h.cc,K(function(a,b){return function(){return b}}(d,k))));break a}throw(new q).j(f);}}d=(new A).e(b,d);f=d.kb;e=d.Ab;if(nq(f)&&(f=f.ha,nq(e)))return(new sq).j(e.ha.y(f));e=d.kb;f=d.Ab;if(pq(e)&&nq(f))return e;e=d.Ab;if(nq(d.kb)&&pq(e))return e;f=d.kb;e=d.Ab;if(pq(f)&&(f=f.cc,pq(e)))return(new qq).j(a.Xb(e.cc, K(function(a,b){return function(){return b}}(b,f))));throw(new q).j(d);} function Hga(a,b,d){var e=r(),f=(new A).e("setup",d.lg),e=I(e,(new w).f([f,(new A).e("update",d.ng)]));b=m(new n,function(a,b,d){return function(e){if(null!==e){var f=e.la();e=e.pa();ju();e=Gga(a,e,b,jd().Uc(d.Ya));e=lu(e);var h=jd().Uc(d.Ya);return ku(e,"pen",h.z()?"":h.Y(),f)}throw(new q).j(e);}}(a,b,d));f=r();e=e.xa(b,f.s);r();b=(new J).j(e);if(null!==b.U&&0===b.U.Rb(2))e=b.U.W(0),b=b.U.W(1);else throw(new q).j(e);Gq();var f=tq(),f=(new Yq).gq(f),f=mu(f),h=(new sq).j(tb(new ub,function(){return function(a, b){return(new uu).cf(a,b)}}(a))),f=a=f.Ym,h=(new A).e(e,(new sq).j(sb(h.ha)));a:{var k=h.kb,p=h.Ab;if(nq(k)&&(k=k.ha,nq(p))){e=(new sq).j(p.ha.y(k));break a}p=h.kb;k=h.Ab;if(pq(p)&&nq(k))e=p;else if(p=h.Ab,nq(h.kb)&&pq(p))e=p;else{k=h.kb;p=h.Ab;if(pq(k)&&(k=k.cc,pq(p))){e=(new qq).j(f.Xb(p.cc,K(function(a,b){return function(){return b}}(e,k))));break a}throw(new q).j(h);}}e=(new A).e(b,e);a:{h=e.kb;f=e.Ab;if(nq(h)&&(h=h.ha,nq(f))){b=(new sq).j(f.ha.y(h));break a}f=e.kb;h=e.Ab;if(pq(f)&&nq(h))b=f; else if(f=e.Ab,nq(e.kb)&&pq(f))b=f;else{h=e.kb;f=e.Ab;if(pq(h)&&(h=h.cc,pq(f))){b=(new qq).j(a.Xb(f.cc,K(function(a,b){return function(){return b}}(b,h))));break a}throw(new q).j(e);}}return Oga(d,b)}hu.prototype.Zm=function(a){throw(new df).c(u((new v).K((new w).f(["This type of agent cannot be asked: ",""])),(new w).f([a])));}; function Jga(a,b){ju();var d=a.uC,e=b.Pm.k().toUpperCase(),f=b.uc;a=d.y(Pga(a,e,f.z()?"":f.Y()).split("\\n").join("\n").split("\\\\").join("\\").split('\\"').join('"'));a=lu(a);d=b.Ya;b=d.z()?b.uc:d;b=ku(a,"button",b.z()?"":b.Y(),"source");if(nq(b))return(new sq).j((new vu).c(b.ha));if(pq(b))return b;throw(new q).j(b);} function Gga(a,b,d,e){e.z()?e=F():(e=e.Y(),e=(new J).j(u((new v).K((new w).f(["'","'"])),(new w).f([e]))));e=e.z()?"undefined":e.Y();var f=b.trim();if(null===f)throw(new Oe).b();if(""===f)return Pq(),d=ps(fd(),""),Vq().y(d);a=a.uC.y(b);if(nq(a))a=a.ha,a=(new sq).j(ps(fd(),a));else if(!pq(a))throw(new q).j(a);if(nq(a))a=a.ha,d=u((new v).K((new w).f(["plotManager.withTemporaryContext('","', ",")(",")"])),(new w).f([d,e,a])),d=(new sq).j(ps(fd(),d));else{if(!pq(a))throw(new q).j(a);d=a}if(nq(d))return d= d.ha,d=u((new v).K((new w).f(["workspace.rng.withAux(",")"])),(new w).f([d])),(new sq).j(ps(fd(),d));if(pq(d))return d;throw(new q).j(d);} function Pga(a,b,d){for(var e=(new A).e("OBSERVER",m(new n,function(){return function(a){return a}}(a))),f=(new A).e("TURTLE",m(new n,function(){return function(a){return wu("turtles",a)}}(a))),h=(new A).e("PATCH",m(new n,function(){return function(a){return wu("patches",a)}}(a))),e=[e,f,h,(new A).e("LINK",m(new n,function(){return function(a){return wu("links",a)}}(a)))],f=dc(new ec,gc()),h=0,k=e.length|0;h<k;)hc(f,e[h]),h=1+h|0;e=f.Ma.dc(b);if(!Vk(e))throw F()===e&&a.Zm(b),(new q).j(e);return e.U.y(d)} function Qga(a,b){b=b.al(m(new n,function(){return function(a){return iu(a)}}(a)),!1);b=Rga(b,m(new n,function(){return function(a){if(iu(a))return a.Ya;throw(new q).j(a);}}(a))).Pf(m(new n,function(){return function(a){return 1<a.pa().Ga()}}(a)));if(kd(b)){a=(new v).K((new w).f(["Having multiple plots with same display name is not supported. Duplicate names detected: ",""]));b=Ic(b);a=u(a,(new w).f([cc(b,"",", ","")]));b=Nm().ra.Xa;var d=Nm().ra.Va,e=Nm();throw(new hd).ms(a,b,d,e.ra.ab);}} function Kga(a,b){ju();var d=b.uc;a=a.vC.y(d.z()?"":d.Y());a=lu(a);d=b.Ya;b=d.z()?b.uc:d;b=ku(a,"monitor",b.z()?"":b.Y(),"reporter");if(nq(b))return(new sq).j((new vu).c(b.ha));if(pq(b))return b;throw(new q).j(b);}function wu(a,b){return u((new v).K((new w).f(["ask "," [ "," ]"])),(new w).f([a,b]))}function Sga(a,b){var d=new hu;d.uC=a;d.vC=b;return d}function Tga(a,b){Qga(a,b);a=m(new n,function(a){return function(b){return Fga(a,b)}}(a));var d=r();return b.xa(a,d.s)} hu.prototype.$classData=g({U3:0},!1,"org.nlogo.tortoise.compiler.WidgetCompiler",{U3:1,d:1});function xu(){this.eY=this.dV=null;this.a=0}xu.prototype=new l;xu.prototype.constructor=xu; xu.prototype.b=function(){yu=this;for(var a=[(new A).e("compiledSource","reporter")],b=dc(new ec,gc()),d=0,e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.dV=b.Ma;this.a=(1|this.a)<<24>>24;a=[(new A).e("compiledMin","getMin"),(new A).e("compiledMax","getMax"),(new A).e("compiledStep","getStep")];b=dc(new ec,gc());d=0;for(e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.eY=b.Ma;this.a=(2|this.a)<<24>>24;return this}; function Uga(a,b){fd();a=m(new n,function(a){return function(b){return Vga(a,b).JF()}}(a));var d=r();return es(0,b.xa(a,d.s),"\n")} function Vga(a,b){var d=Afa((new ls).K(y()),kga(b).Ye());if(null!==b){var e=b.pp;if(qu(b.Ni)&&nq(e)&&(e=e.ha,zu(e)))return a=tb(new ub,function(a){return function(b,d){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/WidgetCompiler.scala: 141");return Wga(a.dV,b,d)}}(a)),e.wC().Gb(d,a)}return null!==b&&(e=b.pp,ru(b.Ni)&&nq(e)&&(b=e.ha,Au(b)))?(a=tb(new ub,function(a){return function(b,d){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/WidgetCompiler.scala: 144"); return Wga(a.eY,b,d)}}(a)),b.wC().Gb(d,a)):d}function Wga(a,b,d){if(null!==d){var e=d.pa();a=a.y(d.la());e=(new Bu).su(I(r(),y()),I(r(),(new w).f([u((new v).K((new w).f(["return ",";"])),(new w).f([e]))])));e=(new A).e(a,e);b=b.gh;a=r();return(new ls).K(b.fd(e,a.s))}throw(new q).j(d);}xu.prototype.$classData=g({V3:0},!1,"org.nlogo.tortoise.compiler.WidgetCompiler$",{V3:1,d:1});var yu=void 0;function ju(){yu||(yu=(new xu).b());return yu}function Cu(){this.IY=null}Cu.prototype=new l; Cu.prototype.constructor=Cu;function ku(a,b,d,e){b=u((new v).K((new w).f([""," '","' - ",".",""])),(new w).f([b,d,b,e]));d=a.IY;if(nq(d))return d;if(pq(d)){d=d.cc;a=function(a,b){return function(a){return(new $r).c(u((new v).K((new w).f(["",": ",""])),(new w).f([b,a.Fh()])))}}(a,b);tq();b=a(d.Fc);d=d.Mc;e=uq().Vd;d=vq(d);a:for(;;){if(!wq(d)){if(xq(d)){var f=d;d=f.dd;f=a(f.$c);e=(new yq).Qb(f,e);continue a}throw(new q).j(d);}break}return(new qq).j((new zq).Qb(b,e))}throw(new q).j(d);} function lu(a){var b=new Cu;b.IY=a;return b}Cu.prototype.$classData=g({W3:0},!1,"org.nlogo.tortoise.compiler.WidgetCompiler$ValidationContextualizer",{W3:1,d:1});function Du(){}Du.prototype=new l;Du.prototype.constructor=Du;Du.prototype.b=function(){return this};Du.prototype.$classData=g({X3:0},!1,"org.nlogo.tortoise.compiler.json.ElemToJsonConverters$",{X3:1,d:1});var Eu=void 0;function Fu(){this.dv=null;this.ya=!1}Fu.prototype=new l;Fu.prototype.constructor=Fu;Fu.prototype.b=function(){return this}; Fu.prototype.yE=function(){if(!this.ya&&!this.ya){var a=(new Ne).b();if(a.La)a=a.hb;else{if(null===a)throw(new Oe).b();a=a.La?a.hb:Pe(a,(new Gu).b())}var a=(new A).e("line",a),b=(new Ne).b();if(b.La)b=b.hb;else{if(null===b)throw(new Oe).b();b=b.La?b.hb:Pe(b,(new Hu).b())}var b=(new A).e("circle",b),d=(new Ne).b();if(d.La)d=d.hb;else{if(null===d)throw(new Oe).b();d=d.La?d.hb:Pe(d,(new Iu).b())}var d=(new A).e("rectangle",d),e=(new Ne).b();if(e.La)e=e.hb;else{if(null===e)throw(new Oe).b();e=e.La?e.hb: Pe(e,(new Ju).b())}a=[a,b,d,(new A).e("polygon",e)];b=dc(new ec,gc());d=0;for(e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.dv=b.Ma;this.ya=!0}return this.dv};Fu.prototype.$classData=g({c4:0},!1,"org.nlogo.tortoise.compiler.json.ElementReader$",{c4:1,d:1});var Ku=void 0;function Lu(a){return(new Mu).$b(zc(a.Np().Pg,a.Ep().Pg))}function Xga(){var a=y();return(new Mu).$b(nh(oh(),a))}function Nu(){}Nu.prototype=new l;Nu.prototype.constructor=Nu;Nu.prototype.b=function(){return this}; function pd(a,b){return ba.JSON.stringify(b)} function Dq(a,b){var d=(new A).e(b,typeof b);if(null===d.kb)return Ou();var e=d.Ab;if("undefined"===e||"function"===e)return Ou();e=d.kb;if("number"===d.Ab)return a=+e,Pu(Qu(),a)?(new Ru).Db(Na(a)):(new Su).tk(a);e=d.kb;if("string"===d.Ab)return(new Tu).c(e);e=d.kb;if("boolean"===d.Ab)return(new Uu).td(!!e);var e=d.kb,f=d.Ab;if(e instanceof ba.Array&&"object"===f&&ba.Array.isArray(e)){b=[];d=0;for(f=e.length|0;d<f;){var h=Dq(a,e[d]);b.push(h);d=1+d|0}a=B().s.Uh();d=b.length|0;switch(d){case -1:break; default:a.tc(d)}a.Yb((new w).f(b));return(new Vu).K(a.Da())}if("object"===d.Ab){e=ba.Object.keys(b);Lc();Zn();d=[];f=0;for(h=e.length|0;f<h;){var k=e[f];if(!Wu().qm.call(b,k))throw(new Xu).c("key not found: "+k);var p=Dq(a,b[k]),k=(new A).e(k,p);d.push(k);f=1+f|0}a=dc(new ec,Yu());b=0;for(e=d.length|0;b<e;)hc(a,d[b]),b=1+b|0;return(new Mu).$b(a.Ma)}throw(new q).j(d);} function rd(a,b){if(Ou()===b)return null;if(Zu(b))return b.ai;if($u(b))return b.Rl;if(av(b))return b.Kc;if(bv(b))return b.Ll;if(cv(b)){var d=b.Ma;b=Lg();a=m(new n,function(a){return function(b){return rd(a,b)}}(a));var e=r();a=d.xa(a,e.s);if(dv(a))return a.Wd;if(ev(a))return a.oa;d=[];a.wa(m(new n,function(a,b){return function(a){return b.push(a)|0}}(b,d)));return d}if(fv(b))return d=b.Pg,gv||(gv=(new hv).b()),b=gv,a=(new iv).Ax(d,m(new n,function(a){return function(b){return rd(a,b)}}(a))),Yga(b, ms(a));throw(new q).j(b);}Nu.prototype.$classData=g({j4:0},!1,"org.nlogo.tortoise.compiler.json.JsonLibrary$",{j4:1,d:1});var jv=void 0;function qd(){jv||(jv=(new Nu).b());return jv}function Zga(a,b){Pq();a=u((new v).K((new w).f(["could not convert "," to ",""])),(new w).f([Uq(a),Uq(b)]));return Qq(Gq(),a)} function kv(a,b,d){d=(new lv).Ha(d);mv();d=d.hX;if(Vk(d))b=(new sq).j(d.U);else{if(F()!==d)throw(new q).j(d);tq();b=u((new v).K((new w).f(["could not find key ",""])),(new w).f([b]));d=[];var e=uq().Vd,f=d.length|0;a:for(;;){if(0!==f){e=(new yq).Qb(d[-1+f|0],e);f=-1+f|0;continue a}break}b=(new qq).j((new zq).Qb(b,e))}if(nq(b))return a.Za(b.ha);if(pq(b))return b;throw(new q).j(b);}function nv(){this.OW=this.YU=this.FU=null;this.a=0}nv.prototype=new l;nv.prototype.constructor=nv; nv.prototype.b=function(){ov=this;this.FU=(new pv).b();this.a=(1|this.a)<<24>>24;this.YU=(new qv).b();this.a=(2|this.a)<<24>>24;this.OW=(new rv).b();this.a=(4|this.a)<<24>>24;return this};function $ga(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/JsonSerializer.scala: 99");return a.YU} function aha(a){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/JsonSerializer.scala: 90");return a.FU}function sv(a,b){return aha(a).kl($ga(a)).kl(bha(a)).db(b,m(new n,function(){return function(){return(new Tu).c("XXX IMPLEMENT ME")}}(a)))}function bha(a){if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/JsonSerializer.scala: 108");return a.OW} function pga(a,b){return qb(m(new n,function(a){return function(b){return sv(a,b)}}(a)),m(new n,function(){return function(a){return rd(qd(),a)}}(a))).Ca(m(new n,function(){return function(a){return pd(qd(),a)}}(a))).y(b)}nv.prototype.$classData=g({l4:0},!1,"org.nlogo.tortoise.compiler.json.JsonSerializer$",{l4:1,d:1});var ov=void 0;function $t(){ov||(ov=(new nv).b());return ov}function tv(a,b){return(new J).j(a.rc(b))}function uv(){this.VU=this.LY=null;this.a=0}uv.prototype=new l; uv.prototype.constructor=uv;uv.prototype.b=function(){vv=this;this.LY=(new wv).b();this.a=(1|this.a)<<24>>24;this.VU=(new xv).b();this.a=(2|this.a)<<24>>24;return this};function cha(a,b){return fv(b)?(b=b.Pg,a=(new Tu).c(a),(new Mu).$b(b.Cm((new A).e("name",a)))):b}function yv(a,b){if(fv(b))return a=(new Ne).b(),(a.La?a.hb:dha(a)).cb(b);Pq();b=u((new v).K((new w).f(["Expected shape as json object, got ",""])),(new w).f([b]));return Qq(Gq(),b)} function dha(a){if(null===a)throw(new Oe).b();return a.La?a.hb:Pe(a,(new zv).b())}function eha(a,b){if(b&&b.$classData&&b.$classData.n.BH)return fha(new Av,b);if(b&&b.$classData&&b.$classData.n.zH)return gha(b);throw(new q).j(b);}function hha(a,b){if(fv(b)){var d=b.Pg;b=ul().s;b=Mc(d,b);d=Bv(d);for(d=Cv(d);d.ta();){var e=d.ma();if(null===e)throw(new q).j(e);b.Na(cha(e.la(),e.pa()))}return a.Za((new Vu).K(b.Da().Hc()))}return a.Za(b)} uv.prototype.$classData=g({F4:0},!1,"org.nlogo.tortoise.compiler.json.ShapeToJsonConverters$",{F4:1,d:1});var vv=void 0;function Dv(){vv||(vv=(new uv).b());return vv}function Ev(){this.va=null}Ev.prototype=new l;Ev.prototype.constructor=Ev;Ev.prototype.c=function(a){this.va=a;return this};Ev.prototype.$classData=g({S4:0},!1,"org.nlogo.tortoise.compiler.json.TortoiseJson$JsField",{S4:1,d:1});function Fv(){this.dv=null;this.a=!1}Fv.prototype=new l;Fv.prototype.constructor=Fv; Fv.prototype.b=function(){Gv=this;var a=(new Ne).b();if(a.La)a=a.hb;else{if(null===a)throw(new Oe).b();a=a.La?a.hb:Pe(a,(new Hv).b())}var a=(new A).e("button",a),b=(new Ne).b();if(b.La)b=b.hb;else{if(null===b)throw(new Oe).b();b=b.La?b.hb:Pe(b,(new Iv).b())}var b=(new A).e("chooser",b),d=(new Ne).b();if(d.La)d=d.hb;else{if(null===d)throw(new Oe).b();d=d.La?d.hb:Pe(d,(new Jv).b())}var d=(new A).e("inputBox",d),e=(new Ne).b();if(e.La)e=e.hb;else{if(null===e)throw(new Oe).b();e=e.La?e.hb:Pe(e,(new Kv).b())}var e= (new A).e("monitor",e),f=(new Ne).b();if(f.La)f=f.hb;else{if(null===f)throw(new Oe).b();f=f.La?f.hb:Pe(f,(new Lv).b())}var f=(new A).e("output",f),h=(new Ne).b();if(h.La)h=h.hb;else{if(null===h)throw(new Oe).b();h=h.La?h.hb:Pe(h,(new Mv).b())}var h=(new A).e("plot",h),k=(new Ne).b();if(k.La)k=k.hb;else{if(null===k)throw(new Oe).b();k=k.La?k.hb:Pe(k,(new Nv).b())}var k=(new A).e("slider",k),p=(new Ne).b();if(p.La)p=p.hb;else{if(null===p)throw(new Oe).b();p=p.La?p.hb:Pe(p,(new Ov).b())}var p=(new A).e("switch", p),t=(new Ne).b();if(t.La)t=t.hb;else{if(null===t)throw(new Oe).b();t=t.La?t.hb:Pe(t,(new Pv).b())}var t=(new A).e("textBox",t),x=(new Ne).b();if(x.La)x=x.hb;else{if(null===x)throw(new Oe).b();x=x.La?x.hb:Pe(x,(new Qv).b())}a=[a,b,d,e,f,h,k,p,t,(new A).e("view",x)];b=dc(new ec,gc());d=0;for(e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.dv=b.Ma;this.a=!0;return this}; Fv.prototype.yE=function(){if(!this.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/WidgetRead.scala: 174");return this.dv};Fv.prototype.$classData=g({V4:0},!1,"org.nlogo.tortoise.compiler.json.WidgetRead$",{V4:1,d:1});var Gv=void 0;function Rv(){this.Lt=this.xV=null}Rv.prototype=new l;Rv.prototype.constructor=Rv; Rv.prototype.b=function(){Sv=this;var a=[Tv().jz,Tv().hw];if(0===(a.length|0))a=Jh();else{for(var b=Kh(new Lh,Jh()),d=0,e=a.length|0;d<e;)Mh(b,a[d]),d=1+d|0;a=b.Ma}this.xV=a;a=(new Uv).b();this.Lt=iha(a);return this};Rv.prototype.$classData=g({i6:0},!1,"org.scalajs.testinterface.HTMLRunner$EventCounter$",{i6:1,d:1});var Sv=void 0;function Vv(){Sv||(Sv=(new Rv).b());return Sv}function Wv(){this.uE=null;this.az=!1;this.vE=this.yn=this.yV=this.Su=this.Tu=null}Wv.prototype=new l; Wv.prototype.constructor=Wv;function jha(a,b,d){b.wa(m(new n,function(a,b){return function(a){a.ZX(!!b.checked)}}(a,d)));return!0}function kha(a,b,d){var e=b.jh(m(new n,function(){return function(a){return a.sy()}}(a)));a=!e&&b.le(m(new n,function(){return function(a){return a.sy()}}(a)));(d.indeterminate=a)||(d.checked=e);return!0}function Xv(a){return a?"success":"error"} function lha(a){a=Yv(a.yn.Eg,"","warn");Zv($v(),a,"There are new excluded tests in your project. You may wish to ");aw($v(),a,"?","Run all");Zv($v(),a," to rediscover all available tests.")}function mha(a,b,d){return function(a,b,d){return function(){return jha(a,b,d)}}(a,b,d)} function bw(a){var b=Vv().Lt.KY().$f(cw())|0,b=u((new v).K((new w).f(["Total: ",""])),(new w).f([b])),d;d=Tv().kr.MS();var e;e=[];for(var f=0,h=d.l.length;f<h;){var k=d.l[f],k=u((new v).K((new w).f(["",": ",""])),(new w).f([k,Vv().Lt.y(k)]));e.push(null===k?null:k);f=1+f|0}e=ka(Xa(qa),e);d=1+e.l.length|0;d=la(Xa(qa),[d]);d.l[0]=b;dw(Rf(),e,0,d,1,e.l.length);b=(new Fm).b();e=!0;js(b,"");f=0;for(h=d.l.length;f<h;)k=d.l[f],e?(ks(b,k),e=!1):(js(b,", "),ks(b,k)),f=1+f|0;js(b,"");b=b.vc.Zb;a.yn.AC.textContent= a.az?b:"Running... "+b}function nha(a,b){b=(new ew).mu(a,b);a.Tu.uj(b);return b}function oha(a,b,d){return function(a,b,d){return function(){return kha(a,b,d)}}(a,b,d)} function pha(a,b){var d=new Wv;d.uE=a;d.az=!1;Ec();d.Tu=(new w).b();Ec();d.Su=(new w).b();var e=ba.document.body;d.yV=fw($v(),e,"","","div");var e=new gw,f=a.Ga();if(null===d)throw Kg(Lg(),null);e.ga=d;0===f?b=u((new v).K((new w).f(["Total Test Suites: ",""])),(new w).f([b])):(f=b-f|0,b=u((new v).K((new w).f(["Selected Test Suites "," (Total: ",")"])),(new w).f([f,b])));e.Eg=(new hw).mu(d,b);iw(e.Eg);e.Eg.Wh.onclick=mha(d,d.Tu,e.Eg.Wh);e.AC=Yv(e.Eg,"","info");e.CY=oha(d,d.Tu,e.Eg.Wh);d.yn=e;d.vE= a.He()?qha(d):d.yn;bw(d);return d}Wv.prototype.HC=function(a){this.az=!0;a.TC().wa(m(new n,function(a){return function(d){Yv(a.yn.Eg,"Test framework crashed during execution:","error");var e=a.yn;d=d.k();return Yv(e.Eg,d,"error")}}(this)));this.yn.gx(!!a.dD(K(function(){return function(){return!1}}(this))));bw(this)};Wv.prototype.$classData=g({k6:0},!1,"org.scalajs.testinterface.HTMLRunner$UI",{k6:1,d:1});function jw(){}jw.prototype=new l;jw.prototype.constructor=jw;jw.prototype.b=function(){return this}; function rha(a,b,d){a=fw($v(),b,"","","input");a.setAttribute("type","checkbox");a.checked=d;return a}function fw(a,b,d,e,f){a=ba.document.createElement(f);f=(new Sb).c(d);kd(f)&&(a.className=d);d=(new Sb).c(e);kd(d)&&(a.textContent=e);b.appendChild(a);return a}function Zv(a,b,d){a=ba.document.createTextNode(d);b.appendChild(a);return a}function aw(a,b,d,e){a=fw($v(),b,"",e,"a");a.setAttribute("href",d);return a} jw.prototype.$classData=g({s6:0},!1,"org.scalajs.testinterface.HTMLRunner$dom$RichElement$",{s6:1,d:1});var kw=void 0;function $v(){kw||(kw=(new jw).b());return kw}function lw(){}lw.prototype=new l;lw.prototype.constructor=lw;lw.prototype.b=function(){return this}; function sha(a,b){b=(new mw).f(b);b=lf(new mf,b,0,b.Wd.length|0);a=nw(As(b).xa(m(new n,function(){return function(a){a=(new Sb).c(a);a=Ei(a,46);var b=a.l.length,f=0,h=ba;a:for(;;){if(f!==b){var k=a.l[f],h=void 0===h?void 0:h[k],f=1+f|0;continue a}a=h;break}a=void 0===a?void 0:new a;(new ow).b();a=void 0===a?void 0:ud(a)?a:void 0;return void 0===a?F():(new J).j(a)}}(a)),(Ng(),(new Og).b())),m(new n,function(){return function(a){return a.ub()}}(a)));return Uk(a)} function tha(){var a;pw||(pw=(new lw).b());a=pw;for(var b=ba.definedTests,d=[],e=0,f=b.length|0;e<f;){var h=b[e],h=qw(rw(),h);d.push(h);e=1+e|0}e=ba.testFrameworkNames;b=[];f=0;for(h=e.length|0;f<h;){var k=sha(a,e[f]).ub();if(null!==k)a:for(;;){if(kd(k)){var p=k.$();b.push(p);k=k.aa();continue a}break}else for(;!k.z();)p=k.$(),b.push(p),k=k.aa();f=1+f|0}e=B().s.Uh();f=b.length|0;switch(f){case -1:break;default:e.tc(f)}e.Yb((new w).f(b));b=e.Da();a=function(a,b){return function(a){for(var d=uha(), e=[],f=0,h=b.length|0;f<h;){for(var k=b[f],p=k,t=0;;){var vb;if(vb=t<d.l.length){vb=d.l[t];var pb=p.rp;vb=!1===(sw(vb)&&sw(pb)?vb.Cu()===pb.Cu()&&vb.Av()===pb.Av():tw(vb)&&tw(pb)?vb.kq===pb.kq&&vb.Ow===pb.Ow:!1)}if(vb)t=1+t|0;else break}t!==d.l.length!==!1&&e.push(k);f=1+f|0}return(new A).e(a,(new w).f(e))}}(a,d);d=B().s;if(d===B().s){if(b===y())return y();d=b.$();e=d=Cd(new Dd,a(d),y());for(b=b.aa();b!==y();)f=b.$(),f=Cd(new Dd,a(f),y()),e=e.Ia=f,b=b.aa();return d}for(d=Mc(b,d);!b.z();)e=b.$(),d.Na(a(e)), b=b.aa();return d.Da()}lw.prototype.$classData=g({t6:0},!1,"org.scalajs.testinterface.TestDetector$",{t6:1,d:1});var pw=void 0;function uw(){}uw.prototype=new l;uw.prototype.constructor=uw;uw.prototype.b=function(){return this};function vha(a,b){if(b&&b.$classData&&b.$classData.n.LQ)b=b.jV;else throw(new df).c("Need a ScalaJSClassLoader.");a:{a=(new Sb).c(a);a=Ei(a,46);var d=a.l.length,e=0;for(;;){if(e===d)break a;b=b[a.l[e]];e=1+e|0}}return b()} uw.prototype.$classData=g({v6:0},!1,"org.scalajs.testinterface.TestUtils$",{v6:1,d:1});var wha=void 0;function vw(){this.cu=null}vw.prototype=new l;vw.prototype.constructor=vw;function ww(){}ww.prototype=vw.prototype;function xha(a){ba.scalajsCom.init(function(a){return function(d){yha(a,d)}}(a))} function yw(a){var b=!1,d=null;a:{if(zw(a)&&(b=!0,d=a,void 0===d.U)){ba.scalajsCom.send("ok:");break a}if(b)ba.scalajsCom.send("ok:"+d.U);else if(Aw(a))a=a.rk,a=ba.JSON.stringify(Bw(Cw(),a)),ba.scalajsCom.send("fail:"+a);else throw(new q).j(a);}}vw.prototype.c=function(a){this.cu=zha(Aha(),a);return this}; function Bha(a){var b;b=[];for(var d=0,e=a.l.length;d<e;){var f=a.l[d],h=f.Dv,h=ba.JSON.stringify(Cha(rw(),h)),f=Cha(rw(),f.Dv),k,p=y();k=wn(p);k=la(Xa(qa),[k]);var t;t=0;for(p=Cv(p);p.ta();){var x=p.ma();k.l[t]=x;t=1+t|0}k=Dw($e(),k);if(dv(k))k=k.Wd;else if(ev(k))k=k.oa;else{t=[];p=0;for(x=k.sa();p<x;){var E=k.W(p);t.push(E)|0;p=1+p|0}k=t}h={serializedTask:h,taskDef:f,tags:k};b.push(null===h?null:h);d=1+d|0}a=ka(Xa(Dha),b);a=Dw($e(),a);if(dv(a))return a.Wd;if(ev(a))return a.oa;b=[];d=0;for(e=a.sa();d< e;)h=a.W(d),b.push(h)|0,d=1+d|0;return b}function yha(a,b){var d=Ew(Ia(),b,58),e=-1===d?b:b.substring(0,d);try{a.UT(e,K(function(a,b,d,e){return function(){if(-1===d)throw(new df).c(u((new v).K((new w).f([""," needs args"])),(new w).f([e])));return b.substring(1+d|0)}}(a,b,d,e)))}catch(f){if(a=ko(Lg(),f),null!==a){b=Fw(Gw(),a);if(b.z())throw Kg(Lg(),a);a=b.Y();a=ba.JSON.stringify(Bw(Cw(),a));ba.scalajsCom.send("bad:"+a)}else throw f;}}vw.prototype.init=function(){xha(this)};function Hw(){} Hw.prototype=new l;Hw.prototype.constructor=Hw;Hw.prototype.b=function(){return this};Hw.prototype.$classData=g({x6:0},!1,"org.scalajs.testinterface.internal.EventSerializer$",{x6:1,d:1});var Eha=void 0;function Iw(){}Iw.prototype=new l;Iw.prototype.constructor=Iw;Iw.prototype.b=function(){return this}; function Jw(a,b){if(tw(b))return{fpType:"AnnotatedFingerprint",isModule:b.kq,annotationName:b.Ow};if(sw(b))return{fpType:"SubclassFingerprint",isModule:b.Cu(),superclassName:b.Av(),requireNoArgConstructor:b.BE()};throw(new df).c(u((new v).K((new w).f(["Unknown Fingerprint type: ",""])),(new w).f([oa(b)])));}Iw.prototype.$classData=g({y6:0},!1,"org.scalajs.testinterface.internal.FingerprintSerializer$",{y6:1,d:1});var Kw=void 0;function Lw(){Kw||(Kw=(new Iw).b());return Kw}function Mw(){} Mw.prototype=new l;Mw.prototype.constructor=Mw;Mw.prototype.b=function(){return this};function zha(a,b){a=aa.exportsNamespace;b=(new Sb).c(b);b=Ei(b,46);var d=b.l.length,e=0;a:for(;;){if(e!==d){a=a[b.l[e]];e=1+e|0;continue a}break}return new a}Mw.prototype.$classData=g({B6:0},!1,"org.scalajs.testinterface.internal.FrameworkLoader$",{B6:1,d:1});var Nw=void 0;function Aha(){Nw||(Nw=(new Mw).b());return Nw}function Ow(){this.MT=null}Ow.prototype=new l;Ow.prototype.constructor=Ow; function Fha(a){a=uha(zha(Aha(),a.MT));var b;b=[];for(var d=0,e=a.l.length;d<e;){var f=a.l[d],f=Jw(Lw(),f);b.push(null===f?null:f);d=1+d|0}a=ka(Xa(Pw),b);a=Dw($e(),a);if(dv(a))a=a.Wd;else if(ev(a))a=a.oa;else{b=[];d=0;for(e=a.sa();d<e;)f=a.W(d),b.push(f)|0,d=1+d|0;a=b}ba.scalajsCom.send(ba.JSON.stringify({name:"utest",fingerprints:a}))}function Gha(a){ba.scalajsCom.init(function(){return function(){}}(a));Fha(a);ba.scalajsCom.close()}Ow.prototype.c=function(a){this.MT=a;return this}; Ow.prototype.initAndSend=function(){Gha(this)};Ow.prototype.$classData=g({C6:0},!1,"org.scalajs.testinterface.internal.InfoSender",{C6:1,d:1});function Qw(){}Qw.prototype=new l;Qw.prototype.constructor=Qw;Qw.prototype.b=function(){return this}; function Hha(a,b){if(b&&b.$classData&&b.$classData.n.CB)return{selType:"SuiteSelector"};if(b&&b.$classData&&b.$classData.n.DB)return{selType:"TestSelector",testName:b.xj};if(b&&b.$classData&&b.$classData.n.zB)return{selType:"NestedSuiteSelector",suiteId:b.wj};if(b&&b.$classData&&b.$classData.n.AB)return{selType:"NestedTestSelector",suiteId:b.wj,testName:b.xj};if(b&&b.$classData&&b.$classData.n.EB)return{selType:"TestWildcardSelector",testWildcard:b.jr};throw(new df).c(u((new v).K((new w).f(["Unknown Selector type: ", ""])),(new w).f([oa(b)])));}function Iha(a,b){a=b.selType;if("SuiteSelector"===a)return(new Rw).b();if("TestSelector"===a)return(new Sw).c(b.testName);if("NestedSuiteSelector"===a)return(new Tw).c(b.suiteId);if("NestedTestSelector"===a)return(new Uw).cf(b.suiteId,b.testName);if("TestWildcardSelector"===a)return(new Vw).c(b.testWildcard);throw(new df).c(u((new v).K((new w).f(["Unknown Selector type: ",""])),(new w).f([a])));} Qw.prototype.$classData=g({E6:0},!1,"org.scalajs.testinterface.internal.SelectorSerializer$",{E6:1,d:1});var Ww=void 0;function Xw(){Ww||(Ww=(new Qw).b());return Ww}function Yw(){this.Uy=!1;this.ga=null}Yw.prototype=new l;Yw.prototype.constructor=Yw;function Zw(){}Zw.prototype=Yw.prototype;function Jha(a){if(!a.Uy)throw(new ye).c(u((new v).K((new w).f([""," has been invalidated"])),(new w).f([a])));}Yw.prototype.yx=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;this.Uy=!0;return this}; function $w(){}$w.prototype=new l;$w.prototype.constructor=$w;$w.prototype.b=function(){return this}; function qw(a,b){a=b.selectors;for(var d=[],e=0,f=a.length|0;e<f;){var h=a[e],h=Iha(Xw(),h);d.push(h);e=1+e|0}a=d.length|0;a=la(Xa(Kha),[a]);for(var h=a.l.length,f=e=0,k=d.length|0,h=k<h?k:h,k=a.l.length,h=h<k?h:k;e<h;)a.l[f]=d[e],e=1+e|0,f=1+f|0;d=new ax;e=b.fullyQualifiedName;Lw();f=b.fingerprint;h=f.fpType;if("AnnotatedFingerprint"===h)h=f.annotationName,k=new bx,k.kq=!!f.isModule,k.Ow=h,f=k;else if("SubclassFingerprint"===h){var h=f.superclassName,k=!!f.requireNoArgConstructor,p=new fx;p.kq=!!f.isModule; p.lY=h;p.bW=k;f=p}else throw(new df).c(u((new v).K((new w).f(["Unknown Fingerprint type: ",""])),(new w).f([h])));b=!!b.explicitlySpecified;d.ik=e;d.rp=f;d.hr=b;d.ir=a;if(null===e)throw(new Oe).c("fullyQualifiedName was null");if(null===f)throw(new Oe).c("fingerprint was null");if(null===a)throw(new Oe).c("selectors was null");return d} function Cha(a,b){a=b.ik;var d=Jw(Lw(),b.rp),e=b.hr;b=b.ir;var f;f=[];for(var h=0,k=b.l.length;h<k;){var p=b.l[h],p=Hha(Xw(),p);f.push(null===p?null:p);h=1+h|0}b=ka(Xa(Pw),f);b=Dw($e(),b);if(dv(b))b=b.Wd;else if(ev(b))b=b.oa;else{f=[];h=0;for(k=b.sa();h<k;)p=b.W(h),f.push(p)|0,h=1+h|0;b=f}return{fullyQualifiedName:a,fingerprint:d,explicitlySpecified:e,selectors:b}}$w.prototype.$classData=g({J6:0},!1,"org.scalajs.testinterface.internal.TaskDefSerializer$",{J6:1,d:1});var gx=void 0; function rw(){gx||(gx=(new $w).b());return gx}function hx(){}hx.prototype=new l;hx.prototype.constructor=hx;hx.prototype.b=function(){return this}; function Bw(a,b){var d=oa(b).k(),e=b.Fh(),f=b.k(),h=ix(b),k;k=[];for(var p=0,t=h.l.length;p<t;){var x;x=h.l[p];x={className:x.xo,methodName:x.xs,fileName:x.Zr,lineNumber:x.vs};k.push(null===x?null:x);p=1+p|0}h=ka(Xa(Pw),k);h=Dw($e(),h);if(dv(h))h=h.Wd;else if(ev(h))h=h.oa;else{k=[];p=0;for(t=h.sa();p<t;)x=h.W(p),k.push(x)|0,p=1+p|0;h=k}d={"class":d,message:e,toString:f,stackTrace:h};null!==b.Me&&(d.cause=Bw(a,b.Me));return d} hx.prototype.$classData=g({K6:0},!1,"org.scalajs.testinterface.internal.ThrowableSerializer$",{K6:1,d:1});var jx=void 0;function Cw(){jx||(jx=(new hx).b());return jx}function Ur(a,b){if(kx(a))return b.Ck(a.X);if(a&&a.$classData&&a.$classData.n.xB)return lx(),a=mx(nx(),Ee(a.Eo)),ox(0,a);throw(new q).j(a);}var Lha=g({eo:0},!0,"play.api.libs.json.JsValue",{eo:1,Im:1});function px(){}px.prototype=new l;px.prototype.constructor=px;px.prototype.b=function(){return this}; function qx(a){var b=Mha();return rx(b,a,!1,0,m(new n,function(){return function(){return""}}(b)),!1,":",(new ac).ae("[",",","]"))} function sx(a,b){if(null===b)return Nha();if(Qg(b))return(new tx).c(b);if("number"===typeof b){var d=+b;a=ux();return vx(new wx,xx(d,a.Hj))}if(xa(b))return d=+b,a=ux(),vx(new wx,xx(d,a.Hj));if(Pa(b))return d=b|0,a=ux(),vx(new wx,yx(a,d,a.Hj));if(Ca(b))return a=Qa(b),d=a.ka,a=a.qa,b=ux(),vx(new wx,Oha(b,(new Vb).ia(d,a)));if(sn(tn(),!0,b))return Pha();if(sn(tn(),!1,b))return Qha();if(b instanceof ba.Array){$e();for(var d=[],e=0,f=b.length|0;e<f;){var h=sx(a,b[e]);d.push(h);e=1+e|0}a=d.length|0;a=la(Xa(Lha), [a]);f=a.l.length;e=b=0;h=d.length|0;f=h<f?h:f;h=a.l.length;for(f=f<h?f:h;b<f;)a.l[e]=d[b],b=1+b|0,e=1+e|0;return(new zx).zx(Yt(0,a))}if(b instanceof ba.Object)return Rha||(Rha=(new Ax).b()),d=(new Bx).$l(b),d=Xb(new Yb,d,m(new n,function(){return function(a){return null!==a}}(a))).xa(m(new n,function(a){return function(b){if(null!==b){var d=b.la();b=sx(a,b.pa());return(new A).e(d,b)}throw(new q).j(b);}}(a)),(new Cx).b()),Sha(Dx(d));Un(Vn(),u((new v).K((new w).f(["Unexpected JS value: ",""])),(new w).f([b])))} function Tha(a){a=(new Sb).c(a);for(var b=$e().zp.af(a.R),d=0,e=a.R.length|0;d<e;){var f=a.W(d),h=null===f?0:f.X;if(31<h&&127>h)f=(new J).j((new af).Ra(h)).ub();else{var f=(new v).K((new w).f(["u",""])),h=(+(h>>>0)).toString(16),h=(new Sb).c(h),h=Ex(h),h=(new Sb).c(h),k=(new af).Ra(48),p=$e().zp,p=p.af(h.Bd()),t=h.sa();p.tc(4<t?t:4);t=4-t|0;for(p.Yb(h.Xd());0<t;)p.Na(k),t=-1+t|0;h=p.Da();h=(new Sb).c(h);h=Ex(h);f=u(f,(new w).f([h.toUpperCase()]));f=(new Sb).c(f);h=(new af).Ra(92);k=$e().zp;f=Fx(f, h,k);f=(new Sb).c(f)}b.Yb(f.mb());d=1+d|0}return b.Da()} function rx(a,b,d,e,f,h,k,p){if(Nha()===b)return"null";if(Gx(b))return p=b.X,d?Tha(ba.JSON.stringify(p)):ba.JSON.stringify(p);if(Hx(b))return b.X.Ec.k();if(Pha().o(b))return"true";if(Qha().o(b))return"false";if(Ix(b))return b=b.X,d=m(new n,function(a,b,d,e,f,h,k){return function(p){return rx(a,p,b,k,d,e,f,h)}}(a,d,f,h,k,p,1+e|0)),a=Mk().qc,Wr(b,d,a).Oc(p.gb,p.Fb,p.og);if(Jx(b)){b=b.Nv;var t=1+e|0;if(h){var x=u((new v).K((new w).f(["\\n",""])),(new w).f([f.y(t)])),E=u((new v).K((new w).f(["\\n","}"])), (new w).f([f.y(e)]));e=x;x=E}else e=f.y(t),x="}";p=m(new n,function(a,b,d,e,f,h,k,p){return function(t){if(null!==t){var x=t.la();t=t.pa();return u((new v).K((new w).f(["","","","",""])),(new w).f([p,b?Tha(ba.JSON.stringify(x)):ba.JSON.stringify(x),f,rx(a,t,b,k,d,e,f,h)]))}throw(new q).j(t);}}(a,d,f,h,k,p,t,e));d=Lc().s;return Wr(b,p,d).Oc("{",",",x)}throw(new q).j(b);}px.prototype.$classData=g({f7:0},!1,"play.api.libs.json.StaticBinding$",{f7:1,d:1});var Kx=void 0; function Mha(){Kx||(Kx=(new px).b());return Kx}function tw(a){return!!(a&&a.$classData&&a.$classData.n.g7)}function Lx(){}Lx.prototype=new l;Lx.prototype.constructor=Lx;function Mx(){}Mx.prototype=Lx.prototype;var Kha=g({tr:0},!1,"sbt.testing.Selector",{tr:1,d:1});Lx.prototype.$classData=Kha;function sw(a){return!!(a&&a.$classData&&a.$classData.n.BB)}function Nx(a){a.nv(Uha(a))}function Ox(){}Ox.prototype=new l;Ox.prototype.constructor=Ox;function Vha(){}Vha.prototype=Ox.prototype; Ox.prototype.b=function(){(new Px).xD(this);(new Qx).xD(this);return this};function Rx(){}Rx.prototype=new l;Rx.prototype.constructor=Rx;function Wha(){}Wha.prototype=Rx.prototype;function Xha(a,b,d){var e=a.Dm;d=Ee(d);return e.Xb(d,K(function(a,b){return function(){return b}}(a,b)))}function Sx(){}Sx.prototype=new l;Sx.prototype.constructor=Sx;function Yha(){}Yha.prototype=Sx.prototype;function Tx(){}Tx.prototype=new l;Tx.prototype.constructor=Tx;function Zha(){}Zha.prototype=Tx.prototype; Tx.prototype.b=function(){(new Ux).yD(this);return this};function Vx(){}Vx.prototype=new l;Vx.prototype.constructor=Vx;function Wx(){}Wx.prototype=Vx.prototype;Vx.prototype.ub=function(){return this.Nx(m(new n,function(){return function(a){return a}}(this)),$ha()).ws()};function Xx(){this.ea=null}Xx.prototype=new l;Xx.prototype.constructor=Xx;function Yx(){}Yx.prototype=Xx.prototype; function aia(a,b){Zx();b=(new $x).yc(b);return a.ih(m(new n,function(a,b){return function(){return T(b)}}(a,b)),tb(new ub,function(a,b){return function(f,h){return ay(T(b),K(function(a,b){return function(){return b}}(a,h)))}}(a,b)),by(function(a,b){return function(f,h,k,p){return T(b).ih(m(new n,function(a){return function(){return a}}(a)),tb(new ub,function(a){return function(b,d){return cy(a,K(function(a,b){return function(){return b}}(a,d)))}}(a)),by(function(a,b,d,e,f){return function(h,k,p,Fa){h= a.ea.jl().Xb(b,K(function(a,b){return function(){return b}}(a,h)));return dy(new ey,h,d,K(function(a,b,d,e,f){return function(){return bia(a,Ee(b),d,e,f)}}(a,e,f,k,p)),Fa,a.ea)}}(a,f,h,k,p)))}}(a,b)))} function cia(a,b,d,e,f,h,k){Zx();e=(new $x).yc(e);Zx();f=(new $x).yc(f);Zx();k=(new $x).yc(k);if(fy(d)){d=d.Aa;if(fy(h))return gy(b,K(function(a,b,d){return function(){return hy(iy(),d,T(b),a.ea)}}(a,e,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,f,h.Aa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(jy(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a, h.Aa,h.Qa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(ly(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h.Aa,h.Qa,h.Eb)),K(function(a,b){return function(){return T(b)}}(a,k)));if(my(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Aa,h.Qa)),K(function(a, b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Eb,h.wd)),K(function(a,b){return function(){return T(b)}}(a,k)));throw(new q).j(h);}if(jy(d)){var p=d.Aa;d=d.Qa;if(fy(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,p,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,f,h.Aa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(jy(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,p,d)),K(function(a, b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,f,h.Aa,h.Qa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(ly(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,p,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,f,h.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Qa,h.Eb)),K(function(a,b){return function(){return T(b)}}(a,k)));if(my(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(), d,e,T(b),a.ea)}}(a,e,p,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,f,h.Aa,h.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Eb,h.wd)),K(function(a,b){return function(){return T(b)}}(a,k)));throw(new q).j(h);}if(ly(d)){var p=d.Aa,t=d.Qa;d=d.Eb;if(fy(h))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,e,f,h.Aa)),K(function(a,b){return function(){return T(b)}}(a, k)));if(jy(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,e,f)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Aa,h.Qa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(ly(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,e,f,h.Aa)),K(function(a, b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Qa,h.Eb)),K(function(a,b){return function(){return T(b)}}(a,k)));if(my(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,e,f,h.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h.Qa,h.Eb,h.wd)),K(function(a,b){return function(){return T(b)}}(a,k)));throw(new q).j(h);}if(my(d)){var p=d.Aa,t=d.Qa,x=d.Eb;d=d.wd; if(fy(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,x)),K(function(a,b,d){return function(){return hy(iy(),d,T(b),a.ea)}}(a,e,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,f,h.Aa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(jy(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,x)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(), b,d,a.ea)}}(a,h.Aa,h.Qa)),K(function(a,b){return function(){return T(b)}}(a,k)));if(ly(h))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,x)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h.Aa,h.Qa,h.Eb)),K(function(a,b){return function(){return T(b)}}(a,k)));if(my(h))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p,t,x)), K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Aa,h.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h.Eb,h.wd)),K(function(a,b){return function(){return T(b)}}(a,k)));throw(new q).j(h);}throw(new q).j(d);} function ny(a,b,d,e,f){Zx();f=(new $x).yc(f);Zx();b=(new $x).yc(b);Zx();d=(new $x).yc(d);Zx();e=(new $x).yc(e);return a.ih(m(new n,function(a,b,d,e,f){return function(){var E=T(d),S=T(e),U=T(f);return ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a,U))),K(function(a,b){return function(){return b}}(a,S))),K(function(a,b){return function(){return b}}(a,E)))}}(a,f,b,d,e)),tb(new ub,function(a,b,d,e,f){return function(E,S){E=T(d);var U=T(e),ga=T(f);return ay(ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a, ga))),K(function(a,b){return function(){return b}}(a,U))),K(function(a,b){return function(){return b}}(a,E))),K(function(a,b){return function(){return b}}(a,S)))}}(a,f,b,d,e)),by(function(a,b,d,e,f){return function(E,S,U,ga){return T(b).ih(m(new n,function(a,b,d,e){return function(){return cy(cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return T(b)}}(a,e)))}}(a,d,e,f)),tb(new ub,function(a,b, d,e){return function(f,h){return cy(cy(cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return T(b)}}(a,e))),K(function(a,b){return function(){return b}}(a,h)))}}(a,d,e,f)),by(function(a,b,d,e,f,h,k,p){return function(t,x,E,U){var S=a.ea,ga=a.ea.Le(a.ea.Le(a.ea.Le(f,T(b)),T(d)),T(e));t=S.jl().Xb(ga,K(function(a,b){return function(){return b}}(a,t)));return dy(new ey,t,h,K(function(a,b,d,e,f,h,k, p){return function(){return dia(a,Ee(f),h,K(function(a,b){return function(){return T(b)}}(a,b)),K(function(a,b){return function(){return T(b)}}(a,d)),K(function(a,b){return function(){return T(b)}}(a,e)),k,p)}}(a,b,d,e,k,p,x,E)),U,a.ea)}}(a,d,e,f,E,S,U,ga)))}}(a,f,b,d,e)))}Xx.prototype.dj=function(a){this.ea=a;return this}; function gy(a,b,d,e){Zx();e=(new $x).yc(e);Zx();b=(new $x).yc(b);Zx();d=(new $x).yc(d);return a.ih(m(new n,function(a,b,d,e){return function(){var t=T(d),x=T(e);return ay(ay(T(b),K(function(a,b){return function(){return b}}(a,x))),K(function(a,b){return function(){return b}}(a,t)))}}(a,e,b,d)),tb(new ub,function(a,b,d,e){return function(t,x){t=T(d);var E=T(e);return ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a,E))),K(function(a,b){return function(){return b}}(a,t))),K(function(a,b){return function(){return b}}(a, x)))}}(a,e,b,d)),by(function(a,b,d,e){return function(t,x,E,S){return T(b).ih(m(new n,function(a,b,d){return function(){return cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d)))}}(a,d,e)),tb(new ub,function(a,b,d){return function(e,f){return cy(cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return b}}(a,f)))}}(a,d,e)),by(function(a, b,d,e,f,h,k){return function(p,t,x,E){var S=a.ea,Bc=a.ea.Le(a.ea.Le(e,T(b)),T(d));p=S.jl().Xb(Bc,K(function(a,b){return function(){return b}}(a,p)));return dy(new ey,p,f,K(function(a,b,d,e,f,h,k){return function(){return cia(a,Ee(e),f,K(function(a,b){return function(){return T(b)}}(a,b)),K(function(a,b){return function(){return T(b)}}(a,d)),h,k)}}(a,b,d,h,k,t,x)),E,a.ea)}}(a,d,e,t,x,E,S)))}}(a,e,b,d)))} function oy(a,b,d,e,f,h){Zx();h=(new $x).yc(h);Zx();b=(new $x).yc(b);Zx();d=(new $x).yc(d);Zx();e=(new $x).yc(e);Zx();f=(new $x).yc(f);return a.ih(m(new n,function(a,b,d,e,f,h){return function(){var U=T(d),ga=T(e),ma=T(f),va=T(h);return ay(ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a,va))),K(function(a,b){return function(){return b}}(a,ma))),K(function(a,b){return function(){return b}}(a,ga))),K(function(a,b){return function(){return b}}(a,U)))}}(a,h,b,d,e,f)),tb(new ub,function(a, b,d,e,f,h){return function(U,ga){U=T(d);var ma=T(e),va=T(f),Fa=T(h);return ay(ay(ay(ay(ay(T(b),K(function(a,b){return function(){return b}}(a,Fa))),K(function(a,b){return function(){return b}}(a,va))),K(function(a,b){return function(){return b}}(a,ma))),K(function(a,b){return function(){return b}}(a,U))),K(function(a,b){return function(){return b}}(a,ga)))}}(a,h,b,d,e,f)),by(function(a,b,d,e,f,h){return function(U,ga,ma,va){return T(b).ih(m(new n,function(a,b,d,e,f){return function(){return cy(cy(cy(cy(a, K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return T(b)}}(a,e))),K(function(a,b){return function(){return T(b)}}(a,f)))}}(a,d,e,f,h)),tb(new ub,function(a,b,d,e,f){return function(h,k){return cy(cy(cy(cy(cy(a,K(function(a,b){return function(){return T(b)}}(a,b))),K(function(a,b){return function(){return T(b)}}(a,d))),K(function(a,b){return function(){return T(b)}}(a,e))),K(function(a,b){return function(){return T(b)}}(a, f))),K(function(a,b){return function(){return b}}(a,k)))}}(a,d,e,f,h)),by(function(a,b,d,e,f,h,k,p,t){return function(x,E,U,S){var ga=a.ea,ma=a.ea.Le(a.ea.Le(a.ea.Le(a.ea.Le(h,T(b)),T(d)),T(e)),T(f));x=ga.jl().Xb(ma,K(function(a,b){return function(){return b}}(a,x)));return dy(new ey,x,k,K(function(a,b,d,e,f,h,k,p,t){return function(){return eia(a,Ee(h),k,K(function(a,b){return function(){return T(b)}}(a,b)),K(function(a,b){return function(){return T(b)}}(a,d)),K(function(a,b){return function(){return T(b)}}(a, e)),K(function(a,b){return function(){return T(b)}}(a,f)),p,t)}}(a,b,d,e,f,p,t,E,U)),S,a.ea)}}(a,d,e,f,h,U,ga,ma,va)))}}(a,h,b,d,e,f)))} function dia(a,b,d,e,f,h,k,p){Zx();e=(new $x).yc(e);Zx();f=(new $x).yc(f);Zx();h=(new $x).yc(h);Zx();p=(new $x).yc(p);if(fy(d)){d=d.Aa;if(fy(k))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(jy(k))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(), T(b),d,e,a.ea)}}(a,h,k.Aa,k.Qa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(ly(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Qa,k.Eb)),K(function(a,b){return function(){return T(b)}}(a,p)));if(my(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f, d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,h,k.Aa,k.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Eb,k.wd)),K(function(a,b){return function(){return T(b)}}(a,p)));throw(new q).j(k);}if(jy(d)){var t=d.Aa;d=d.Qa;if(fy(k))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,f,h,k.Aa)),K(function(a,b){return function(){return T(b)}}(a, p)));if(jy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,t,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,f,h)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Aa,k.Qa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(ly(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,f,h,k.Aa)), K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Qa,k.Eb)),K(function(a,b){return function(){return T(b)}}(a,p)));if(my(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,t,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,f,h,k.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k.Qa,k.Eb,k.wd)),K(function(a,b){return function(){return T(b)}}(a,p)));throw(new q).j(k);}if(ly(d)){var t=d.Aa,x= d.Qa;d=d.Eb;if(fy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,e,f)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(jy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)), K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Aa,k.Qa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(ly(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k.Aa,k.Qa,k.Eb)),K(function(a,b){return function(){return T(b)}}(a,p)));if(my(k))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(), b,d,e,a.ea)}}(a,t,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Aa,k.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Eb,k.wd)),K(function(a,b){return function(){return T(b)}}(a,p)));throw(new q).j(k);}if(my(d)){var t=d.Aa,x=d.Qa,E=d.Eb;d=d.wd;if(fy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,E)),K(function(a,b,d,e){return function(){return ky(iy(), e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(jy(k))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,E)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,h,k.Aa,k.Qa)),K(function(a,b){return function(){return T(b)}}(a,p)));if(ly(k))return oy(b, K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,E)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,h,k.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Qa,k.Eb)),K(function(a,b){return function(){return T(b)}}(a,p)));if(my(k))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,t,x,E)),K(function(a,b,d,e){return function(){return ky(iy(), e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,h,k.Aa,k.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,k.Eb,k.wd)),K(function(a,b){return function(){return T(b)}}(a,p)));throw(new q).j(k);}throw(new q).j(d);}Xx.prototype.k=function(){py();var a=(new qy).b();py();var b=(new qy).b();iy();var d=new ry;d.Hw=a;d.lr=b;Vd(d);py();fia||(fia=(new sy).b());a=new ty;a.Xt=b;Vd(a);d.fz=a;return d.Md(this).k()}; function bia(a,b,d,e,f){if(fy(d)){d=d.Aa;if(fy(e))return e=e.Aa,uy(b,hy(iy(),d,e,a.ea),f);if(jy(e)){var h=e.Aa;e=e.Qa;return uy(b,ky(iy(),d,h,e,a.ea),f)}if(ly(e))return gy(b,K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,d,e.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Qa,e.Eb)),f);if(my(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,d,e.Aa,e.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Eb, e.wd)),f);throw(new q).j(e);}if(jy(d)){h=d.Aa;d=d.Qa;if(fy(e))return e=e.Aa,uy(b,ky(iy(),h,d,e,a.ea),f);if(jy(e))return gy(b,K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Aa,e.Qa)),f);if(ly(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,d,e.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Qa,e.Eb)),f);if(my(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(), b,d,e,a.ea)}}(a,h,d,e.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,e.Qa,e.Eb,e.wd)),f);throw(new q).j(e);}if(ly(d)){var h=d.Aa,k=d.Qa;d=d.Eb;if(fy(e))return gy(b,K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,h,k)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,d,e.Aa)),f);if(jy(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a, e.Aa,e.Qa)),f);if(ly(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,d)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,e.Aa,e.Qa,e.Eb)),f);if(my(e))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Aa,e.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Eb,e.wd)),f);throw(new q).j(e);}if(my(d)){var h=d.Aa,k=d.Qa, p=d.Eb;d=d.wd;if(fy(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,p)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,d,e.Aa)),f);if(jy(e))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,p)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,d,e.Aa,e.Qa)),f);if(ly(e))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,p)),K(function(a,b,d){return function(){return hy(iy(), b,d,a.ea)}}(a,d,e.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Qa,e.Eb)),f);if(my(e))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,h,k,p)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,d,e.Aa,e.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,e.Eb,e.wd)),f);throw(new q).j(e);}throw(new q).j(d);} Xx.prototype.Gb=function(a,b){return this.ih(m(new n,function(a,b){return function(){return b}}(this,a)),tb(new ub,function(a,b,f){return function(a,d){return rb(f,b,d)}}(this,a,b)),by(function(a,b,f){return function(h,k,p,t){h=iy();h=(new vy).ls(h);p=Ee(p);var x=iy(),x=(new vy).ls(x);k=p.Gb(Fd(x,k,b,f),tb(new ub,function(a,b){return function(a,d){var e=iy(),e=(new wy).ls(e);return Fd(e,d,a,b)}}(a,f)));return Fd(h,t,k,f)}}(this,a,b)))};Xx.prototype.ws=function(){return gia(iy(),this.ea).Al(this)}; function eia(a,b,d,e,f,h,k,p,t){Zx();e=(new $x).yc(e);Zx();f=(new $x).yc(f);Zx();h=(new $x).yc(h);Zx();k=(new $x).yc(k);Zx();t=(new $x).yc(t);if(fy(d)){d=d.Aa;if(fy(p))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(jy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e, f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,h,k)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Aa,p.Qa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(ly(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Qa,p.Eb)),K(function(a,b){return function(){return T(b)}}(a, t)));if(my(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p.Qa,p.Eb,p.wd)),K(function(a,b){return function(){return T(b)}}(a,t)));throw(new q).j(p);}if(jy(d)){var x=d.Aa;d=d.Qa;if(fy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,x,d)),K(function(a,b,d){return function(){return hy(iy(), T(b),T(d),a.ea)}}(a,f,h)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,k,p.Aa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(jy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,f,h,k)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Aa,p.Qa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(ly(p))return ny(b,K(function(a, b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,f,h,k)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p.Aa,p.Qa,p.Eb)),K(function(a,b){return function(){return T(b)}}(a,t)));if(my(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,x,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,f,h,k)),K(function(a,b,d){return function(){return hy(iy(), b,d,a.ea)}}(a,p.Aa,p.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Eb,p.wd)),K(function(a,b){return function(){return T(b)}}(a,t)));throw(new q).j(p);}if(ly(d)){var x=d.Aa,E=d.Qa;d=d.Eb;if(fy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,k,p.Aa)),K(function(a,b){return function(){return T(b)}}(a, t)));if(jy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,k,p.Aa,p.Qa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(ly(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a, e,f,h)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,k,p.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Qa,p.Eb)),K(function(a,b){return function(){return T(b)}}(a,t)));if(my(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),T(e),a.ea)}}(a,e,f,h)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,k,p.Aa,p.Qa)),K(function(a,b, d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Eb,p.wd)),K(function(a,b){return function(){return T(b)}}(a,t)));throw(new q).j(p);}if(my(d)){var x=d.Aa,E=d.Qa,S=d.Eb;d=d.wd;if(fy(p))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,S)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(jy(p))return oy(b, K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,S)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),T(d),a.ea)}}(a,h,k)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Aa,p.Qa)),K(function(a,b){return function(){return T(b)}}(a,t)));if(ly(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,S)),K(function(a,b,d,e){return function(){return ky(iy(), e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a,h,k,p.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,p.Qa,p.Eb)),K(function(a,b){return function(){return T(b)}}(a,t)));if(my(p))return oy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,x,E,S)),K(function(a,b,d,e){return function(){return ky(iy(),e,T(b),T(d),a.ea)}}(a,e,f,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),T(d),e,a.ea)}}(a, h,k,p.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,p.Qa,p.Eb,p.wd)),K(function(a,b){return function(){return T(b)}}(a,t)));throw(new q).j(p);}throw(new q).j(d);} function cy(a,b){var d=xy(iy(),a.ea);Zx();b=(new $x).yc(b);return a.ih(m(new n,function(a,b){return function(d){d=a.ea.Le(d,T(b));return yy(new zy,d,K(function(a,b){return function(){return T(b)}}(a,b)),a.ea)}}(a,b)),tb(new ub,function(a,b,d){return function(k,p){k=a.ea.Le(k,T(d));p=Ay(iy(),p,a.ea);var t=K(function(a,b){return function(){return(new Td).dj(b)}}(a,b)),x=Ay(iy(),T(d),a.ea);return dy(new ey,k,p,t,x,a.ea)}}(a,d,b)),by(function(a,b){return function(d,k,p,t){p=Ee(p);if(my(t)){var x=t.Aa, E=t.Qa,S=t.Eb;t=t.wd;d=a.ea.Le(d,T(b));p=K(function(a,b,d,e,f){return function(){return cy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,d,e,f)))}}(a,p,x,E,S));t=By(iy(),t,T(b),a.ea);return dy(new ey,d,k,p,t,a.ea)}d=a.ea.Le(d,T(b));p=K(function(a,b){return function(){return b}}(a,p));t=t.Zv(T(b));return dy(new ey,d,k,p,t,a.ea)}}(a,b)))} function hia(a,b,d,e,f,h){Zx();e=(new $x).yc(e);Zx();h=(new $x).yc(h);if(fy(d)){d=d.Aa;if(fy(f))return f=f.Aa,uy(b,ky(iy(),d,T(e),f,a.ea),K(function(a,b){return function(){return T(b)}}(a,h)));if(jy(f))return gy(b,K(function(a,b,d){return function(){return hy(iy(),d,T(b),a.ea)}}(a,e,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Aa,f.Qa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(ly(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,T(b), e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Qa,f.Eb)),K(function(a,b){return function(){return T(b)}}(a,h)));if(my(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,T(b),e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,f.Qa,f.Eb,f.wd)),K(function(a,b){return function(){return T(b)}}(a,h)));throw(new q).j(f);}if(jy(d)){var k=d.Aa;d=d.Qa;if(fy(f))return gy(b,K(function(a,b,d){return function(){return hy(iy(), b,d,a.ea)}}(a,k,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,e,f.Aa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(jy(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,k,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Aa,f.Qa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(ly(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,k,d)),K(function(a,b, d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,f.Aa,f.Qa,f.Eb)),K(function(a,b){return function(){return T(b)}}(a,h)));if(my(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),d,e,T(b),a.ea)}}(a,e,k,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Aa,f.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Eb,f.wd)),K(function(a,b){return function(){return T(b)}}(a,h)));throw(new q).j(f);}if(ly(d)){var k=d.Aa,p=d.Qa;d=d.Eb;if(fy(f))return gy(b, K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,e,f.Aa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(jy(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,e,f.Aa,f.Qa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(ly(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(), b,d,e,a.ea)}}(a,k,p,d)),K(function(a,b,d){return function(){return hy(iy(),T(b),d,a.ea)}}(a,e,f.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Qa,f.Eb)),K(function(a,b){return function(){return T(b)}}(a,h)));if(my(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,d)),K(function(a,b,d,e){return function(){return ky(iy(),T(b),d,e,a.ea)}}(a,e,f.Aa,f.Qa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Eb,f.wd)),K(function(a, b){return function(){return T(b)}}(a,h)));throw(new q).j(f);}if(my(d)){var k=d.Aa,p=d.Qa,t=d.Eb;d=d.wd;if(fy(f))return gy(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,t)),K(function(a,b,d,e){return function(){return ky(iy(),d,T(b),e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(jy(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,t)),K(function(a,b,d){return function(){return hy(iy(),d,T(b),a.ea)}}(a, e,d)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Aa,f.Qa)),K(function(a,b){return function(){return T(b)}}(a,h)));if(ly(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,k,p,t)),K(function(a,b,d,e){return function(){return ky(iy(),d,T(b),e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b,d){return function(){return hy(iy(),b,d,a.ea)}}(a,f.Qa,f.Eb)),K(function(a,b){return function(){return T(b)}}(a,h)));if(my(f))return ny(b,K(function(a,b,d,e){return function(){return ky(iy(), b,d,e,a.ea)}}(a,k,p,t)),K(function(a,b,d,e){return function(){return ky(iy(),d,T(b),e,a.ea)}}(a,e,d,f.Aa)),K(function(a,b,d,e){return function(){return ky(iy(),b,d,e,a.ea)}}(a,f.Qa,f.Eb,f.wd)),K(function(a,b){return function(){return T(b)}}(a,h)));throw(new q).j(f);}throw(new q).j(d);} function uy(a,b,d){Zx();d=(new $x).yc(d);return a.ih(m(new n,function(a,b,d){return function(){return ay(T(d),K(function(a,b){return function(){return b}}(a,b)))}}(a,b,d)),tb(new ub,function(a,b,d){return function(k,p){return ay(ay(T(d),K(function(a,b){return function(){return b}}(a,b))),K(function(a,b){return function(){return b}}(a,p)))}}(a,b,d)),by(function(a,b,d){return function(k,p,t,x){return T(d).ih(m(new n,function(a,b){return function(){return cy(a,K(function(a,b){return function(){return b}}(a, b)))}}(a,b)),tb(new ub,function(a,b){return function(d,e){return cy(cy(a,K(function(a,b){return function(){return b}}(a,b))),K(function(a,b){return function(){return b}}(a,e)))}}(a,b)),by(function(a,b,d,e,f,h){return function(k,p,t,x){var Ib=a.ea,kc=a.ea.Le(d,b);k=Ib.jl().Xb(kc,K(function(a,b){return function(){return b}}(a,k)));return dy(new ey,k,e,K(function(a,b,d,e,f,h){return function(){return hia(a,Ee(d),e,K(function(a,b){return function(){return b}}(a,b)),f,h)}}(a,b,f,h,p,t)),x,a.ea)}}(a,b, k,p,t,x)))}}(a,b,d)))} function ay(a,b){var d=xy(iy(),a.ea);Zx();b=(new $x).yc(b);return a.ih(m(new n,function(a,b){return function(d){d=a.ea.so(T(b),d);return yy(new zy,d,K(function(a,b){return function(){return T(b)}}(a,b)),a.ea)}}(a,b)),tb(new ub,function(a,b,d){return function(k,p){k=a.ea.so(T(d),k);var t=Ay(iy(),T(d),a.ea),x=K(function(a,b){return function(){return(new Td).dj(b)}}(a,b));p=Ay(iy(),p,a.ea);return dy(new ey,k,t,x,p,a.ea)}}(a,d,b)),by(function(a,b){return function(d,k,p,t){p=Ee(p);if(my(k)){var x=k.Aa, E=k.Qa,S=k.Eb;k=k.wd;d=a.ea.so(T(b),d);x=By(iy(),T(b),x,a.ea);return dy(new ey,d,x,K(function(a,b,d,e,f){return function(){var h=ky(iy(),d,e,f,a.ea);return ay(b,K(function(a,b){return function(){return b}}(a,h)))}}(a,p,E,S,k)),t,a.ea)}E=a.ea.so(T(b),d);S=T(b);k=k.bw(S);return dy(new ey,E,k,K(function(a,b){return function(){return b}}(a,p)),t,a.ea)}}(a,b)))} function iia(a,b,d){return a.ih(m(new n,function(a,b){return function(){return b.he()}}(a,d)),tb(new ub,function(a,b){return function(a,d){return b.y(d)}}(a,b)),by(function(a,b,d){return function(k,p,t,x){return d.Xb(d.Xb(p.an(b,d),K(function(a,b,d,e){return function(){return iia(Ee(e),m(new n,function(a,b,d){return function(a){return a.an(b,d)}}(a,b,d)),d)}}(a,b,d,t))),K(function(a,b,d,e){return function(){return e.an(b,d)}}(a,b,d,x)))}}(a,b,d)))}function Cy(){}Cy.prototype=new l; Cy.prototype.constructor=Cy;function jia(){}jia.prototype=Cy.prototype;function xy(a,b){return Dy(new Ey,m(new n,function(a){return function(b){return b.$C(su(function(){return function(a){return a}}(a)),by(function(){return function(a){return a}}(a)))}}(a)),b.jl())} function gia(a,b){return Dy(new Ey,m(new n,function(a){return function(b){return b.ih(m(new n,function(){return function(a){return a}}(a)),tb(new ub,function(){return function(a){return a}}(a)),by(function(){return function(a){return a}}(a)))}}(a)),b.jl())}function kia(a,b,d,e){var f=(new Fy).b();b.wa(m(new n,function(a,b){return function(a){return Gy(b,a)}}(a,f)));for(b=e.he();!f.z();){var h=b;b=lia(f);h=K(function(a,b){return function(){return b}}(a,h));b=e.Xb(d.y(b),h)}return b} function mia(a,b,d,e){a=a.Hg(b,(mv(),F()),tb(new ub,function(a,b,d){return function(a,e){a=(new A).e(a,e);e=a.kb;var f=a.Ab;if(F()===e)return mv(),a=b.y(f),(new J).j(a);f=a.kb;e=a.Ab;if(Vk(f))return a=f.U,mv(),a=rb(d,a,e),(new J).j(a);throw(new q).j(a);}}(a,d,e)));return a.z()?Un(Vn(),"foldMapLeft1"):a.Y()}function nia(a,b,d){return a.sx(b,m(new n,function(){return function(a){return a}}(a)),d)}function Hy(){}Hy.prototype=new l;Hy.prototype.constructor=Hy;function Iy(){}Iy.prototype=Hy.prototype; function oia(a,b){for(;;){var d=a;if(Jy(d))return(new Ky).j(d.ha);if(Ly(d))return(new My).j(b.Xc(d.ha,m(new n,function(){return function(a){return(new Ny).j(a)}}(a))));if(Oy(d)){var e=d.wr;if(Jy(e))a=d.Jo.y(e.ha);else{if(Ly(e))return(new My).j(b.Xc(e.ha,d.Jo));if(Oy(e))a=Py(new Qy,e.wr,m(new n,function(a,b,d){return function(a){a=b.Jo.y(a);return Py(new Qy,a,d.Jo)}}(a,e,d)));else throw(new q).j(e);}}else throw(new q).j(d);}} function pia(a,b){return Py(new Qy,a,m(new n,function(a,b){return function(a){return(new Ny).j(b.y(a))}}(a,b)))}function Ry(){}Ry.prototype=new l;Ry.prototype.constructor=Ry;function qia(){}qia.prototype=Ry.prototype;function Sy(a,b){return m(new n,function(a,b){return function(f){return a.Xc(f,b)}}(a,b))}function Ty(a){a.Sg(ria(a))}function Uy(){}Uy.prototype=new l;Uy.prototype.constructor=Uy;function sia(){}sia.prototype=Uy.prototype;function Vy(){}Vy.prototype=new l;Vy.prototype.constructor=Vy; function tia(){}tia.prototype=Vy.prototype;function Wy(){}Wy.prototype=new l;Wy.prototype.constructor=Wy;function Xy(){}Xy.prototype=Wy.prototype;function uia(a,b){return(new Yy).cn(m(new n,function(a,b){return function(f){return b.y(m(new n,function(a,b){return function(d){return Zy(a,d,b)}}(a,f)))}}(a,b)))}function Zy(a,b,d){return d.ej(d.Xc(a.bD().y(d),m(new n,function(a,b){return function(a){return a.y(b)}}(a,b))))} function via(a,b,d){return uia(a,m(new n,function(a,b,d){return function(k){return m(new n,function(a,b,d,e){return function(f){return d.Xc(e.y(f),m(new n,function(a,b){return function(a){return(new A).e(a.la(),b.y(a.pa()))}}(a,b)))}}(a,b,d,k))}}(a,b,d)))}function wia(a,b){var d=$y();return(new Yy).cn(m(new n,function(a,b,d){return function(){return m(new n,function(a,b,d){return function(e){return d.vd(K(function(a,b,d){return function(){return Zy(a,d,b)}}(a,b,e)))}}(a,b,d))}}(a,b,d)))} function xia(a,b,d){return uia(a,m(new n,function(a,b,d){return function(k){return m(new n,function(a,b,d,e){return function(f){return d.eh(e.y(f),m(new n,function(a,b,d){return function(e){var f=b.y(e.pa()).bD().y(d);return d.eh(f,m(new n,function(a,b){return function(a){return a.y(b.la())}}(a,e)))}}(a,b,d)))}}(a,b,d,k))}}(a,b,d)))}function az(){}az.prototype=new l;az.prototype.constructor=az;function yia(){}yia.prototype=az.prototype;function bz(a){a.Ns((new cz).zD(a));a.Ms((new dz).zD(a))} function ez(a){a.SE((new fz).AD(a));a.RE((new gz).AD(a))}function hz(){}hz.prototype=new l;hz.prototype.constructor=hz;function zia(){}zia.prototype=hz.prototype;function iz(){}iz.prototype=new l;iz.prototype.constructor=iz;function Aia(){}Aia.prototype=iz.prototype;function jz(){}jz.prototype=new l;jz.prototype.constructor=jz;function Bia(){}Bia.prototype=jz.prototype;jz.prototype.b=function(){var a=new kz;yd(a);Nx(a);return this};function lz(){}lz.prototype=new l;lz.prototype.constructor=lz; function Cia(){}Cia.prototype=lz.prototype;function mz(a){a.zf(Dia(a))}function nz(){}nz.prototype=new l;nz.prototype.constructor=nz;function Eia(){}Eia.prototype=nz.prototype;function oz(){}oz.prototype=new l;oz.prototype.constructor=oz;oz.prototype.b=function(){pz=this;(new qz).b();return this};oz.prototype.$classData=g({T8:0},!1,"scalaz.Need$",{T8:1,d:1});var pz=void 0;function Zx(){pz||(pz=(new oz).b())}function rz(){}rz.prototype=new l;rz.prototype.constructor=rz;function sz(){} sz.prototype=rz.prototype;rz.prototype.dj=function(){return this};rz.prototype.an=function(a,b){return this.$C(su(function(a,b,f){return function(h,k,p){return f.Xb(b.y(Ee(k)),K(function(a,b,d){return function(){return b.y(Ee(d))}}(a,b,p)))}}(this,a,b)),by(function(a,b,f){return function(h,k,p,t){return f.Xb(f.Xb(b.y(Ee(k)),K(function(a,b,d){return function(){return b.y(Ee(d))}}(a,b,p))),K(function(a,b,d){return function(){return b.y(Ee(d))}}(a,b,t)))}}(this,a,b)))}; function zq(){this.Mc=this.Fc=null}zq.prototype=new l;zq.prototype.constructor=zq;c=zq.prototype;c.o=function(a){if(a&&a.$classData&&a.$classData.n.oR){var b=xt(this);a=xt(a);return null===b?null===a:b.o(a)}return!1};function xt(a){return(new yq).Qb(a.Fc,a.Mc)}c.k=function(){return"NonEmpty"+(new yq).Qb(this.Fc,this.Mc)}; function Fia(a,b,d){var e=a.Mc;if(wq(e))return d.Xc(b.y(a.Fc),m(new n,function(){return function(a){tq();var b=uq().Vd;return(new zq).Qb(a,b)}}(a)));if(xq(e))return tz(d,K(function(a,b){return function(){return b.y(a.Fc)}}(a,b)),K(function(a,b,d,e,t){return function(){uz||(uz=(new vz).b());var a=uq().ND,f=new wz;f.Xm=a;Md(f);Ty(f);Ed(f);xz(f);f.Iq(yz(f));f.Kq(zz(f));a=(new Az).e(e,t);return Gia(f,a,b,d)}}(a,b,d,e.$c,e.dd)),tb(new ub,function(){return function(a,b){tq();return(new zq).Qb(a,(new yq).Qb(b.Fc, b.Mc))}}(a)));throw(new q).j(e);}function Zq(a,b){var d=xt(a);if(wq(d))a=b;else if(xq(d))a=d.$c,d=d.dd,tq(),b=xt(b),b=Hia(d,b),a=(new zq).Qb(a,b);else throw(new q).j(d);return a}function rq(a){var b;Bz||(Bz=(new Cz).b());b=Bz;tq();var d=b.y(a.Fc);a=Iia(a.Mc,b);return(new zq).Qb(d,a)}c.Qb=function(a,b){this.Fc=a;this.Mc=b;return this};c.r=function(){return xt(this).r()};c.$classData=g({oR:0},!1,"scalaz.NonEmptyList",{oR:1,d:1});function Dz(){}Dz.prototype=new l;Dz.prototype.constructor=Dz; function Jia(){}Jia.prototype=Dz.prototype;function Ez(){}Ez.prototype=new l;Ez.prototype.constructor=Ez;function Kia(){}Kia.prototype=Ez.prototype;function Fz(a){a.jg(Lia(a))}function Gz(a){a.Os(Mia(a))}function Hz(){}Hz.prototype=new l;Hz.prototype.constructor=Hz;function Iz(){}Iz.prototype=Hz.prototype;function Jz(){}Jz.prototype=new l;Jz.prototype.constructor=Jz;function Nia(){}Nia.prototype=Jz.prototype; Jz.prototype.b=function(){Oia();m(new n,function(){return function(a){return!!a}}(this));m(new n,function(){return function(a){return!!a}}(this));Kz();m(new n,function(){return function(a){return a|0}}(this));Kz();m(new n,function(){return function(a){return(new af).Ra(null===a?0:a.X)}}(this));Kz();m(new n,function(){return function(a){return a|0}}(this));Kz();m(new n,function(){return function(a){a=Qa(a);return(new Vb).ia(a.ka,a.qa)}}(this));Kz();m(new n,function(){return function(a){return a|0}}(this)); Kz();m(new n,function(){return function(a){return a}}(this));Lz||(Lz=(new Mz).b());return this};function $ha(){var a;Nz||(Nz=(new Oz).b());a=Nz;var b=m(new n,function(){return function(a){var b=y();return Cd(new Dd,a,b)}}(a));a=m(new n,function(a){return function(b){return m(new n,function(a,b){return function(a){return Cd(new Dd,b,a)}}(a,b))}}(a));var d=Wq(),d=(new Xq).nu(d);return Pia(b,a,d)}function Pz(){}Pz.prototype=new l;Pz.prototype.constructor=Pz; Pz.prototype.b=function(){Qz=this;(new Rz).b();return this};Pz.prototype.$classData=g({q9:0},!1,"scalaz.Show$",{q9:1,d:1});var Qz=void 0;function py(){Qz||(Qz=(new Pz).b())}function Qia(a,b){a=m(new n,function(a,b){return function(a){a=b.y(a);return(new A).e(a,void 0)}}(a,b));b=Sz().dg;return Tz(new Uz,a,b)}function Vz(){}Vz.prototype=new l;Vz.prototype.constructor=Vz; Vz.prototype.b=function(){Wz=this;(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();(new Xz).b();return this};Vz.prototype.$classData=g({B9:0},!1,"scalaz.Tags$",{B9:1,d:1});var Wz=void 0;function Yz(){Wz||(Wz=(new Vz).b())}function Zz(){this.ga=this.JG=null}Zz.prototype=new l;Zz.prototype.constructor=Zz;Zz.prototype.$classData=g({G9:0},!1,"scalaz.Traverse$Traversal",{G9:1,d:1}); function $z(){}$z.prototype=new l;$z.prototype.constructor=$z;function Ria(){}Ria.prototype=$z.prototype;function aA(){}aA.prototype=new l;aA.prototype.constructor=aA;function Sia(){}Sia.prototype=aA.prototype;aA.prototype.b=function(){var a=new bA;xd(a);wd(a);cA(a);return this};function dA(){this.dg=null}dA.prototype=new l;dA.prototype.constructor=dA; dA.prototype.b=function(){eA=this;fA||(fA=(new gA).b());this.dg=fA.wx;Tia||(Tia=(new hA).b());Uia||(Uia=(new iA).b());Via||(Via=(new jA).b());Wia||(Wia=(new kA).b());Xia||(Xia=(new lA).b());Yia||(Yia=(new mA).b());Zia();$ia||($ia=(new nA).b());aja||(aja=(new oA).b());bja||(bja=(new pA).b());return this};dA.prototype.$classData=g({R9:0},!1,"scalaz.package$",{R9:1,d:1});var eA=void 0;function Sz(){eA||(eA=(new dA).b());return eA}function qA(){}qA.prototype=new l;qA.prototype.constructor=qA; qA.prototype.b=function(){return this};function cja(a){tq();var b=[],d=uq().Vd,e=b.length|0;a:for(;;){if(0!==e){d=(new yq).Qb(b[-1+e|0],d);e=-1+e|0;continue a}break}return(new zq).Qb(a,d)}qA.prototype.$classData=g({xaa:0},!1,"scalaz.syntax.NelOps$",{xaa:1,d:1});var dja=void 0;function Id(){}Id.prototype=new l;Id.prototype.constructor=Id;Id.prototype.b=function(){return this};function Yaa(a,b){return tb(new ub,function(a,b){return function(a,d){return rb(b,d,a)}}(a,b))} Id.prototype.$classData=g({Qaa:0},!1,"scalaz.syntax.std.Function2Ops$",{Qaa:1,d:1});var Hd=void 0;function lv(){this.hX=null}lv.prototype=new l;lv.prototype.constructor=lv;lv.prototype.Ha=function(a){this.hX=a;return this};lv.prototype.$classData=g({Raa:0},!1,"scalaz.syntax.std.OptionOps",{Raa:1,d:1});function rA(){}rA.prototype=new l;rA.prototype.constructor=rA;rA.prototype.b=function(){return this};rA.prototype.$classData=g({Saa:0},!1,"utest.PlatformShims$",{Saa:1,d:1});var sA=void 0; function tA(){this.Fv=null}tA.prototype=new l;tA.prototype.constructor=tA;function eja(a,b){Ec();for(var d=(new w).b(),e=a.Fv,f=b.ub();;)if(kd(f)){if(!Gi(f))throw(new q).j(f);for(var h=f.Bb,f=f.Ia,h=e.Qm.jD(m(new n,function(a,b){return function(a){return a.X.me()===b}}(a,h))),k=[h],p=0,t=k.length|0;p<t;)d.oa.push(k[p]),p=1+p|0;if(!e.Qm.Vo(h))throw(new uA).K(b);e=e.Qm.W(h)}else break;return(new A).e(d,e)}function vA(a){var b=new tA;b.Fv=a;return b} function fja(a,b,d,e,f,h,k,p,t,x){var E=b.wg();if(F()===E)return wA(xA(),K(function(a,b){return function(){return b}}(a,d)),t);if(Vk(E)){var S=E.U,E=vA(S),U=r(),U=h.mc(e,U.s),S=S.X.me(),ga=r();return gja(E,f,U,k.mc(S,ga.s),p,x,t).bl(m(new n,function(a,b,d,e,f,h,k,p,t,x){return function(E){var S=p.aa(),U=B().s;return fja(a,S,kj(t,E,U),1+x|0,b,d,e,f,h,k)}}(a,f,h,k,p,t,x,b,d,e)),t)}throw(new q).j(E);} function hja(a,b,d,e,f,h){e=eja(a,e);if(null===e)throw(new q).j(e);a=e.la();e=vA(e.pa());var k=yA(xA(),F());return gja(e,b,a,d,f,k,h)} function gja(a,b,d,e,f,h,k){return wA(xA(),K(function(a,b,d,e,f,h,k){return function(){var ma=ija(),va=f.y(K(function(a,b,d,e){return function(){return d.bl(m(new n,function(a,b,d){return function(e){if(F()===e)return wA(xA(),K(function(a,b){return function(){try{return yA(xA(),a.Fv.X.Yna().joa(b.ub()))}catch(d){var e=ko(Lg(),d);if(null!==e)return xA(),zA||(zA=(new AA).b()),e=(new BA).ud(e),jja(kja(),e);throw d;}}}(a,b)),d).bl(m(new n,function(){return function(a){return a}}(a)),d);if(Vk(e))throw e.U; throw(new q).j(e);}}(a,b,e)),e).bl(m(new n,function(){return function(a){return a&&a.$classData&&a.$classData.n.EE?a:yA(xA(),a)}}(a)),e)}}(a,d,h,k))),Fa=va.Ih(m(new n,function(){return function(){return F()}}(a)),k).Es(lja(a,e),k),Fa=fja(a,a.Fv.Qm,y(),0,b,d,e,f,k,Fa);return va.Ih(m(new n,function(){return function(a){return(new CA).j(a)}}(a)),k).Es(new DA,k).bl(m(new n,function(a,b,d,e,f,h){return function(k){return h.Ih(m(new n,function(a,b,d,e,f){return function(h){a:{var k;if(Aw(f)){var p=f.rk; if(p&&p.$classData&&p.$classData.n.dE&&"Boxed Error"===p.Kc){k=(new BA).ud(p.Me);break a}}k=f}var t=ija(),p=a.Fv.X.me(),t=t.mp,x=t.Sn.Qn(t.Ak),t=x.ka,E=x.qa,x=e.mp,x=x.Sn.Qn(x.Ak),S=x.qa,x=t-x.ka|0,E=(-2147483648^x)>(-2147483648^t)?-1+(E-S|0)|0:E-S|0,t=new EA,x=(new Vb).ia(x,E);t.va=p;t.X=k;t.Nu=x;rb(b,d,t);p=new FA;p.X=t;p.Qm=h;return p}}(a,b,d,f,k)),e)}}(a,b,e,k,ma,Fa)),k)}}(a,b,d,e,f,h,k)),k).bl(m(new n,function(){return function(a){return a}}(a)),k)} tA.prototype.$classData=g({Uaa:0},!1,"utest.framework.TestTreeSeq",{Uaa:1,d:1});function GA(){}GA.prototype=new l;GA.prototype.constructor=GA;GA.prototype.b=function(){HA=this;var a=(new IA).Db(100),b=JA().mt;mja(KA(),a.Is,b);a=(new IA).Db(1);b=JA().ot;mja(KA(),a.Is,b);return this};GA.prototype.$classData=g({Xaa:0},!1,"utest.package$",{Xaa:1,d:1});var HA=void 0;function Wa(){this.ti=null}Wa.prototype=new l;Wa.prototype.constructor=Wa;Wa.prototype.kh=function(){return this.ti.name}; function LA(a){return a.ti.getComponentType()}Wa.prototype.k=function(){return(this.ti.isInterface?"interface ":this.ti.isPrimitive?"":"class ")+this.kh()};function Sl(a,b){return a.ti.isPrimitive||b.ti.isPrimitive?a===b||(a===pa(cb)?b===pa(bb):a===pa(db)?b===pa(bb)||b===pa(cb):a===pa(fb)?b===pa(bb)||b===pa(cb)||b===pa(db):a===pa(gb)&&(b===pa(bb)||b===pa(cb)||b===pa(db)||b===pa(fb))):Rl(a,b.ti.getFakeInstance())}function Rl(a,b){return!!a.ti.isInstance(b)} function Uq(a){a=(new Sb).c(a.ti.name);a=Ei(a,46);a=Tm((new qn).Gh(a));a=(new Sb).c(a);a=Ei(a,36);return Tm((new qn).Gh(a))}Wa.prototype.$classData=g({Bba:0},!1,"java.lang.Class",{Bba:1,d:1});function MA(){}MA.prototype=new l;MA.prototype.constructor=MA;function nja(){}nja.prototype=MA.prototype;function NA(){this.JS=0;this.VV=OA();this.CV=OA()}NA.prototype=new l;NA.prototype.constructor=NA;NA.prototype.$classData=g({Nba:0},!1,"java.lang.Long$StringRadixInfo",{Nba:1,d:1}); function PA(){this.QT=this.Eo=this.BV=null}PA.prototype=new l;PA.prototype.constructor=PA;PA.prototype.b=function(){QA=this;this.BV=(new RA).qu(!1);this.Eo=(new RA).qu(!0);this.QT=ba.performance?ba.performance.now?function(){SA();return+ba.performance.now()}:ba.performance.webkitNow?function(){SA();return+ba.performance.webkitNow()}:function(){SA();return+(new ba.Date).getTime()}:function(){SA();return+(new ba.Date).getTime()};return this}; PA.prototype.$classData=g({Uba:0},!1,"java.lang.System$",{Uba:1,d:1});var QA=void 0;function SA(){QA||(QA=(new PA).b());return QA}function TA(){this.$R=null}TA.prototype=new l;TA.prototype.constructor=TA;TA.prototype.b=function(){UA=this;var a=new VA;a.va="main";this.$R=a;return this};TA.prototype.$classData=g({Wba:0},!1,"java.lang.Thread$",{Wba:1,d:1});var UA=void 0;function WA(){this.Ac=this.tx=null}WA.prototype=new l;WA.prototype.constructor=WA;WA.prototype.b=function(){this.tx=!1;return this}; WA.prototype.Y=function(){this.tx||XA(this,null);return this.Ac};function XA(a,b){a.Ac=b;a.tx=!0}WA.prototype.$classData=g({Xba:0},!1,"java.lang.ThreadLocal",{Xba:1,d:1});function YA(){}YA.prototype=new l;YA.prototype.constructor=YA;YA.prototype.b=function(){return this};function ZA(a,b,d){return b.ti.newArrayOfThisClass([d])}YA.prototype.$classData=g({Zba:0},!1,"java.lang.reflect.Array$",{Zba:1,d:1});var $A=void 0;function aB(){$A||($A=(new YA).b());return $A}function bB(){}bB.prototype=new l; bB.prototype.constructor=bB;function oja(a,b,d){if(b===d)return!0;if(null!==b&&null!==d&&b.l.length===d.l.length){a=Dw($e(),b);a=cB(a);a=lf(new mf,a,0,a.sa());for(var e=!0;e&&a.ta();)e=a.ma()|0,e=sn(tn(),b.l[e],d.l[e]);return e}return!1}bB.prototype.b=function(){return this};function pja(a){return m(new n,function(){return function(a){return Ga(a)}}(a))} function qja(a,b,d,e){d=d-b|0;if(2<=d){if(0<e.pk(a.l[b],a.l[1+b|0])){var f=a.l[b];a.l[b]=a.l[1+b|0];a.l[1+b|0]=f}for(f=2;f<d;){var h=a.l[b+f|0];if(0>e.pk(h,a.l[-1+(b+f|0)|0])){for(var k=b,p=-1+(b+f|0)|0;1<(p-k|0);){var t=(k+p|0)>>>1|0;0>e.pk(h,a.l[t])?p=t:k=t}k=k+(0>e.pk(h,a.l[k])?0:1)|0;for(p=b+f|0;p>k;)a.l[p]=a.l[-1+p|0],p=-1+p|0;a.l[k]=h}f=1+f|0}}}function rja(a,b){a=b.l.length;for(var d=0;d!==a;)b.l[d]=0,d=1+d|0} function sja(a,b,d){var e=new dB;e.OS=d;d=b.l.length;16<d?eB(a,b,la(Xa(Ua),[b.l.length]),0,d,e):qja(b,0,d,e)}function eB(a,b,d,e,f,h){var k=f-e|0;if(16<k){var p=e+(k/2|0)|0;eB(a,b,d,e,p,h);eB(a,b,d,p,f,h);for(var t=a=e,x=p;a<f;)t<p&&(x>=f||0>=h.pk(b.l[t],b.l[x]))?(d.l[a]=b.l[t],t=1+t|0):(d.l[a]=b.l[x],x=1+x|0),a=1+a|0;Oa(d,e,b,e,k)}else qja(b,e,f,h)}bB.prototype.$classData=g({$ba:0},!1,"java.util.Arrays$",{$ba:1,d:1});var fB=void 0;function gB(){fB||(fB=(new bB).b());return fB} function hB(){this.BU=this.AU=this.zU=this.CU=null}hB.prototype=new l;hB.prototype.constructor=hB;hB.prototype.b=function(){iB=this;this.CU=jB(new kB,new ba.RegExp("^[^\\x25]+"));this.zU=jB(new kB,new ba.RegExp("^\\x25{2}"));this.AU=jB(new kB,new ba.RegExp("^\\x25n"));this.BU=jB(new kB,new ba.RegExp("^\\x25(?:([1-9]\\d*)\\$)?([-#+ 0,\\(\x3c]*)(\\d*)(?:\\.(\\d+))?([A-Za-z])"));return this};hB.prototype.$classData=g({dca:0},!1,"java.util.Formatter$",{dca:1,d:1});var iB=void 0; function lB(){iB||(iB=(new hB).b());return iB}function kB(){this.yq=null}kB.prototype=new l;kB.prototype.constructor=kB;function mB(a,b){return jd().Uc(a.yq.exec(b))}function jB(a,b){a.yq=b;return a}kB.prototype.$classData=g({eca:0},!1,"java.util.Formatter$RegExpExtractor",{eca:1,d:1});function nB(){}nB.prototype=new l;nB.prototype.constructor=nB;function tja(){}tja.prototype=nB.prototype;function oB(){}oB.prototype=new l;oB.prototype.constructor=oB;function uja(){}uja.prototype=oB.prototype; function pB(){}pB.prototype=new l;pB.prototype.constructor=pB;function vja(){}vja.prototype=pB.prototype;function Yt(a,b){null===b?a=null:0===b.l.length?(qB||(qB=(new rB).b()),a=qB.CG):a=(new Fi).Gh(b);return a}function wca(a){return null!==a?(new sB).Oo(a):null}function gp(){this.ga=this.ol=null}gp.prototype=new l;gp.prototype.constructor=gp;function iea(a,b,d){a.ol=d;if(null===b)throw Kg(Lg(),null);a.ga=b;return a}gp.prototype.$classData=g({Eca:0},!1,"scala.Option$WithFilter",{Eca:1,d:1}); function tB(a,b){return m(new n,function(a,b){return function(f){f=a.db(f,ld().Eq);return!uB(ld(),f)&&(b.y(f),!0)}}(a,b))}function vB(a,b,d){return a.Ua(b)?a.y(b):d.y(b)}function wB(){this.JC=this.KW=this.Eq=null}wB.prototype=new l;wB.prototype.constructor=wB;wB.prototype.b=function(){xB=this;this.Eq=(new yB).b();this.KW=m(new n,function(){return function(){return!1}}(this));this.JC=(new zB).b();return this};function uB(a,b){return a.Eq===b} wB.prototype.$classData=g({Fca:0},!1,"scala.PartialFunction$",{Fca:1,d:1});var xB=void 0;function ld(){xB||(xB=(new wB).b());return xB}function AB(){}AB.prototype=new l;AB.prototype.constructor=AB;AB.prototype.b=function(){return this};AB.prototype.$classData=g({Qca:0},!1,"scala.Predef$DummyImplicit",{Qca:1,d:1});function BB(){}BB.prototype=new l;BB.prototype.constructor=BB;BB.prototype.b=function(){return this};BB.prototype.$classData=g({Rca:0},!1,"scala.Predef$RichException$",{Rca:1,d:1}); var wja=void 0;function CB(){}CB.prototype=new l;CB.prototype.constructor=CB;CB.prototype.b=function(){return this};function xja(a,b,d){return""+DB(Ia(),b)+d}CB.prototype.$classData=g({Sca:0},!1,"scala.Predef$any2stringadd$",{Sca:1,d:1});var EB=void 0;function yja(){EB||(EB=(new CB).b());return EB}function FB(){this.iz=null}FB.prototype=new l;FB.prototype.constructor=FB;FB.prototype.b=function(){this.iz="\n";return this};FB.prototype.$classData=g({Yca:0},!1,"scala.compat.Platform$",{Yca:1,d:1}); var GB=void 0;function zja(){GB||(GB=(new FB).b());return GB}function HB(){this.Jt=null}HB.prototype=new l;HB.prototype.constructor=HB;HB.prototype.b=function(){IB=this;this.Jt=(new WA).b();return this};HB.prototype.$classData=g({$ca:0},!1,"scala.concurrent.BlockContext$",{$ca:1,d:1});var IB=void 0;function Aja(){IB||(IB=(new HB).b());return IB}function JB(){this.ST=null;this.ya=!1}JB.prototype=new l;JB.prototype.constructor=JB;JB.prototype.b=function(){return this}; function KB(){var a;LB||(LB=(new JB).b());a=LB;a.ya||a.ya||(MB||(MB=(new NB).b()),a.ST=MB.UV,a.ya=!0);return a.ST}JB.prototype.$classData=g({bda:0},!1,"scala.concurrent.ExecutionContext$Implicits$",{bda:1,d:1});var LB=void 0;function Bja(a,b,d){return Cja(a,m(new n,function(a,b){return function(d){if(zw(d))return b.y(d.U);if(Aw(d))return a;throw(new q).j(d);}}(a,b)),d)}function Dja(a,b,d){return Eja(a,m(new n,function(a,b){return function(a){return a.$U(b)}}(a,b)),d)} function Fja(a,b,d,e){return a.bl(m(new n,function(a,b,d,e){return function(t){return b.Ih(m(new n,function(a,b,d){return function(a){return rb(b,d,a)}}(a,d,t)),e)}}(a,b,d,e)),we())}function Gja(a,b,d){return a.Ih(m(new n,function(a,b){return function(a){if(b.y(a))return a;throw(new Xu).c("Future.filter predicate is not satisfied");}}(a,b)),d)}function Hja(a,b,d){return Eja(a,m(new n,function(a,b){return function(a){return a.WV(b)}}(a,b)),d)}function OB(){this.BY=null}OB.prototype=new l; OB.prototype.constructor=OB;OB.prototype.b=function(){PB=this;for(var a=[(new A).e(pa(Za),pa(Aa)),(new A).e(pa(bb),pa(sa)),(new A).e(pa(ab),pa(Ija)),(new A).e(pa(cb),pa(ua)),(new A).e(pa(db),pa(wa)),(new A).e(pa(eb),pa(Da)),(new A).e(pa(fb),pa(ya)),(new A).e(pa(gb),pa(za)),(new A).e(pa(Ya),pa(Ba))],b=dc(new ec,gc()),d=0,e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.BY=yA(0,void 0);return this}; function QB(a,b,d,e){return b.Gb(yA(0,d.af(b)),tb(new ub,function(a,b){return function(d,e){return d.XF(e,tb(new ub,function(){return function(a,b){return a.Na(b)}}(a)),b)}}(a,e))).Ih(m(new n,function(){return function(a){return a.Da()}}(a)),we())}function yA(a,b){zA||(zA=(new AA).b());a=(new CA).j(b);return jja(kja(),a)}function wA(a,b,d){return a.BY.Ih(m(new n,function(a,b){return function(){return Ee(b)}}(a,b)),d)}OB.prototype.$classData=g({cda:0},!1,"scala.concurrent.Future$",{cda:1,d:1}); var PB=void 0;function xA(){PB||(PB=(new OB).b());return PB}function AA(){}AA.prototype=new l;AA.prototype.constructor=AA;AA.prototype.b=function(){return this};AA.prototype.$classData=g({fda:0},!1,"scala.concurrent.Promise$",{fda:1,d:1});var zA=void 0;function RB(){}RB.prototype=new l;RB.prototype.constructor=RB;RB.prototype.b=function(){return this};function mja(a,b,d){SB();a=b>>31;TB(new UB,(new Vb).ia(b,a),d)} RB.prototype.$classData=g({lda:0},!1,"scala.concurrent.duration.package$DurationInt$",{lda:1,d:1});var VB=void 0;function KA(){VB||(VB=(new RB).b());return VB}function WB(){}WB.prototype=new l;WB.prototype.constructor=WB;WB.prototype.b=function(){return this}; function Jja(a){return a&&a.$classData&&a.$classData.n.xF?(new CA).j(a.SF):XB(a)?(new BA).ud((new YB).jc("Boxed ControlThrowable",a)):ZB(a)?(new BA).ud((new YB).jc("Boxed InterruptedException",a)):a&&a.$classData&&a.$classData.n.Fba?(new BA).ud((new YB).jc("Boxed Error",a)):(new BA).ud(a)}WB.prototype.$classData=g({nda:0},!1,"scala.concurrent.impl.Promise$",{nda:1,d:1});var $B=void 0;function aC(){}aC.prototype=new l;aC.prototype.constructor=aC;aC.prototype.b=function(){return this}; function jja(a,b){$B||($B=(new WB).b());a=Aw(b)?Jja(b.rk):b;if(zw(a))return b=new bC,b.Ci=a,b;if(Aw(a))return b=new cC,b.Ci=a,b;throw(new q).j(a);}aC.prototype.$classData=g({oda:0},!1,"scala.concurrent.impl.Promise$KeptPromise$",{oda:1,d:1});var dC=void 0;function kja(){dC||(dC=(new aC).b());return dC}function eC(){}eC.prototype=new l;eC.prototype.constructor=eC;function Kja(){}Kja.prototype=eC.prototype;function Hk(){}Hk.prototype=new l;Hk.prototype.constructor=Hk;Hk.prototype.b=function(){return this}; function Eca(a,b){return Lja(Mja(b),K(function(a,b){return function(){return Eca(a,b)}}(a,b)))}Hk.prototype.$classData=g({sda:0},!1,"scala.io.Source$",{sda:1,d:1});var Gk=void 0;function fC(){this.nY=this.Gp=this.ax=this.sc=this.rC=0;this.ga=null}fC.prototype=new l;fC.prototype.constructor=fC;function Nja(){}Nja.prototype=fC.prototype; fC.prototype.Rx=function(){var a=this.ga.wf.ma();this.rC=null===a?0:a.X;var a=this.ax,b=this.Gp;this.sc=1048575<=a?2147481600:a<<11|(2047<b?2047:b);switch(this.rC){case 10:this.Gp=1;this.ax=1+this.ax|0;break;case 9:this.Gp=this.Gp+this.nY|0;break;default:this.Gp=1+this.Gp|0}return this.rC};fC.prototype.rba=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;this.sc=0;this.Gp=this.ax=1;this.nY=4;return this};function gC(){}gC.prototype=new l;gC.prototype.constructor=gC;gC.prototype.b=function(){return this}; gC.prototype.$classData=g({Eda:0},!1,"scala.math.Ordered$",{Eda:1,d:1});var Oja=void 0;function hC(){this.Th=this.bS=this.eG=null;this.ya=0}hC.prototype=new l;hC.prototype.constructor=hC; hC.prototype.b=function(){iC=this;(new jC).b();kC||(kC=(new lC).b());Lc();r();Mk();mC();B();y();Pja||(Pja=(new nC).b());Qja||(Qja=(new oC).b());Rja||(Rja=(new pC).b());this.bS=Ng();Sja||(Sja=(new qC).b());this.Th=Lk();Tja||(Tja=(new rC).b());ao();Uja||(Uja=(new sC).b());Vja||(Vja=(new tC).b());Wja||(Wja=(new uC).b());Xja||(Xja=(new vC).b());Oja||(Oja=(new gC).b());Yja||(Yja=(new wC).b());Zja||(Zja=(new xC).b());$ja||($ja=(new yC).b());aka||(aka=(new zC).b());return this}; hC.prototype.$classData=g({Jda:0},!1,"scala.package$",{Jda:1,d:1});var iC=void 0;function pc(){iC||(iC=(new hC).b());return iC}function AC(){}AC.prototype=new l;AC.prototype.constructor=AC;AC.prototype.b=function(){BC=this;CC();DC();EC();FC();GC();nj();HC();IC();JC();bka||(bka=(new KC).b());LC();cka||(cka=(new MC).b());dka();eka();return this};AC.prototype.$classData=g({Lda:0},!1,"scala.reflect.ClassManifestFactory$",{Lda:1,d:1});var BC=void 0;function NC(){}NC.prototype=new l; NC.prototype.constructor=NC;NC.prototype.b=function(){return this};NC.prototype.$classData=g({Oda:0},!1,"scala.reflect.ManifestFactory$",{Oda:1,d:1});var fka=void 0;function OC(){}OC.prototype=new l;OC.prototype.constructor=OC;OC.prototype.b=function(){PC=this;BC||(BC=(new AC).b());fka||(fka=(new NC).b());return this};OC.prototype.$classData=g({dea:0},!1,"scala.reflect.package$",{dea:1,d:1});var PC=void 0;function QC(){PC||(PC=(new OC).b())}function RC(){}RC.prototype=new l; RC.prototype.constructor=RC;RC.prototype.b=function(){return this};function Un(a,b){throw Kg(Lg(),(new $g).c(b));}RC.prototype.$classData=g({eea:0},!1,"scala.sys.package$",{eea:1,d:1});var SC=void 0;function Vn(){SC||(SC=(new RC).b());return SC}function TC(){this.Ac=null}TC.prototype=new l;TC.prototype.constructor=TC;TC.prototype.k=function(){return"DynamicVariable("+this.Ac+")"};TC.prototype.j=function(a){this.Ac=a;return this}; TC.prototype.$classData=g({fea:0},!1,"scala.util.DynamicVariable",{fea:1,d:1});function UC(){}UC.prototype=new l;UC.prototype.constructor=UC;UC.prototype.b=function(){(new VC).b();return this};UC.prototype.$classData=g({lea:0},!1,"scala.util.control.Breaks",{lea:1,d:1});function XB(a){return!!(a&&a.$classData&&a.$classData.n.CW)}function WC(){this.lV=null}WC.prototype=new l;WC.prototype.constructor=WC; WC.prototype.b=function(){XC=this;this.lV=gka(m(new n,function(){return function(){return!1}}(this)),m(new n,function(){return function(a){throw Kg(Lg(),a);}}(this)));var a=YC(new ZC,this.lV,F(),hka());mba(a,"\x3cnothing\x3e");return this};function ika(a,b,d){return d.le(m(new n,function(a,b){return function(a){return Sl(a,oa(b))}}(a,b)))} function jka(){var a=$C(),b=(new w).f([pa(kka)]),d=YC(new ZC,(new aD).K(b),F(),hka()),a=m(new n,function(){return function(a){return a.kh()}}(a)),e=r(),b=b.xa(a,e.s).zb(", ");return mba(d,b)}function gka(a,b){var d=(new Qn).xg(pa(Oq)),e=new bD;e.tU=a;e.$i=b;e.Xt=d;return e}WC.prototype.$classData=g({mea:0},!1,"scala.util.control.Exception$",{mea:1,d:1});var XC=void 0;function $C(){XC||(XC=(new WC).b());return XC}function cD(){}cD.prototype=new l;cD.prototype.constructor=cD;cD.prototype.b=function(){return this}; function hka(){dD||(dD=(new cD).b());return m(new n,function(){return function(a){$C();return XB(a)||ZB(a)}}(dD))}cD.prototype.$classData=g({qea:0},!1,"scala.util.control.Exception$Catch$",{qea:1,d:1});var dD=void 0;function eD(){}eD.prototype=new l;eD.prototype.constructor=eD;eD.prototype.b=function(){return this};function Fw(a,b){return b&&b.$classData&&b.$classData.n.goa||b&&b.$classData&&b.$classData.n.foa||ZB(b)||b&&b.$classData&&b.$classData.n.eoa||XB(b)?F():(new J).j(b)} eD.prototype.$classData=g({uea:0},!1,"scala.util.control.NonFatal$",{uea:1,d:1});var fD=void 0;function Gw(){fD||(fD=(new eD).b());return fD}function gD(){}gD.prototype=new l;gD.prototype.constructor=gD;function lka(){}lka.prototype=gD.prototype;gD.prototype.zs=function(a,b){b=da(-862048943,b);b=da(461845907,b<<15|b>>>17|0);return a^b};gD.prototype.da=function(a,b){a=this.zs(a,b);return-430675100+da(5,a<<13|a>>>19|0)|0}; function R(a,b){var d=b.v();if(0===d)return a=b.u(),Ha(Ia(),a);for(var e=-889275714,f=0;f<d;)e=a.da(e,hD(V(),b.w(f))),f=1+f|0;return a.tb(e,d)}function iD(a,b,d){var e=(new jD).Db(0),f=(new jD).Db(0),h=(new jD).Db(0),k=(new jD).Db(1);b.wa(m(new n,function(a,b,d,e,f){return function(a){a=hD(V(),a);b.Ba=b.Ba+a|0;d.Ba^=a;0!==a&&(f.Ba=da(f.Ba,a));e.Ba=1+e.Ba|0}}(a,e,f,h,k)));b=a.da(d,e.Ba);b=a.da(b,f.Ba);b=a.zs(b,k.Ba);return a.tb(b,h.Ba)} gD.prototype.tb=function(a,b){a^=b;a=da(-2048144789,a^(a>>>16|0));a=da(-1028477387,a^(a>>>13|0));return a^(a>>>16|0)};function mka(a,b,d){var e=(new jD).Db(0);d=(new jD).Db(d);b.wa(m(new n,function(a,b,d){return function(e){d.Ba=a.da(d.Ba,hD(V(),e));b.Ba=1+b.Ba|0}}(a,e,d)));return a.tb(d.Ba,e.Ba)}function kD(){}kD.prototype=new l;kD.prototype.constructor=kD;kD.prototype.b=function(){return this}; function nka(a,b){a=da(-1640532531,b);Hi();return da(-1640532531,a<<24|16711680&a<<8|65280&(a>>>8|0)|a>>>24|0)}kD.prototype.$classData=g({wea:0},!1,"scala.util.hashing.package$",{wea:1,d:1});var lD=void 0;function oka(){lD||(lD=(new kD).b());return lD}function mD(){}mD.prototype=new l;mD.prototype.constructor=mD;function qea(a,b){return He(b)?(new J).j((new A).e(b.Bk,b.be)):Ge(b)?(new J).j((new A).e(b.Bk,b.be)):F()}mD.prototype.To=function(){return this}; mD.prototype.$classData=g({Fea:0},!1,"scala.util.parsing.combinator.Parsers$NoSuccess$",{Fea:1,d:1});function nD(){this.ga=null}nD.prototype=new l;nD.prototype.constructor=nD;function oD(){}oD.prototype=nD.prototype;nD.prototype.To=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};function pD(){}pD.prototype=new l;pD.prototype.constructor=pD;function pka(){}pka.prototype=pD.prototype;function pC(){}pC.prototype=new l;pC.prototype.constructor=pC;pC.prototype.b=function(){return this}; pC.prototype.$classData=g({Gea:0},!1,"scala.collection.$colon$plus$",{Gea:1,d:1});var Rja=void 0;function oC(){}oC.prototype=new l;oC.prototype.constructor=oC;oC.prototype.b=function(){return this};oC.prototype.$classData=g({Hea:0},!1,"scala.collection.$plus$colon$",{Hea:1,d:1});var Qja=void 0;function qD(){this.Rd=null}qD.prototype=new l;qD.prototype.constructor=qD;qD.prototype.b=function(){rD=this;this.Rd=(new sD).b();return this}; qD.prototype.$classData=g({Oea:0},!1,"scala.collection.Iterator$",{Oea:1,d:1});var rD=void 0;function mC(){rD||(rD=(new qD).b());return rD}function tD(a,b,d){a.we(b,d,uD(W(),b)-d|0)}function vD(a,b){b=b.Uh();b.Yb(a.mb());return b.Da()}function wD(a,b){var d=(new jD).Db(0);a.wa(m(new n,function(a,b,d){return function(a){b.y(a)&&(d.Ba=1+d.Ba|0)}}(a,b,d)));return d.Ba}function cc(a,b,d,e){return a.Lf((new Fm).b(),b,d,e).vc.Zb} function Zl(a,b,d){b=(new nm).j(b);a.wa(m(new n,function(a,b,d){return function(a){d.Ba=rb(b,d.Ba,a)}}(a,d,b)));return b.Ba}function os(a){var b=(new jD).Db(0);a.wa(m(new n,function(a,b){return function(){b.Ba=1+b.Ba|0}}(a,b)));return b.Ba} function Mg(a,b){var d=(new te).b();try{if(a&&a.$classData&&a.$classData.n.Zc)var e=a;else{if(!(a&&a.$classData&&a.$classData.n.Jb))return a.wa(b.nm(m(new n,function(a,b){return function(a){throw(new xD).e(b,(new J).j(a));}}(a,d)))),F();e=a.Bg()}for(var f=new yD;e.ta();){var h=b.db(e.ma(),f);if(h!==f)return(new J).j(h)}return F()}catch(k){if(k&&k.$classData&&k.$classData.n.xF&&k.PU===d)return k.SF;throw k;}} function zD(a,b,d,e,f){var h=(new AD).td(!0);js(b,d);a.wa(m(new n,function(a,b,d,e){return function(a){if(e.Ba)ks(b,a),e.Ba=!1;else return js(b,d),ks(b,a)}}(a,b,e,h)));js(b,f);return b}function BD(a,b){return a.Gb(0,tb(new ub,function(){return function(a,b){return(a|0)+(b|0)|0}}(a,b)))}function CD(a,b){return a.yg()?(b=b.Mg(a.Ga()),a.tg(b,0),b):a.Nd().se(b)}function kd(a){return!a.z()} function DD(a,b){if(a.z())throw(new Ul).c("empty.reduceLeft");var d=(new AD).td(!0),e=(new nm).j(0);a.wa(m(new n,function(a,b,d,e){return function(a){d.Ba?(e.Ba=a,d.Ba=!1):e.Ba=rb(b,e.Ba,a)}}(a,b,d,e)));return e.Ba}function ED(){}ED.prototype=new l;ED.prototype.constructor=ED;function qka(){}qka.prototype=ED.prototype;function nh(a,b){return a.bb().Yb(b).Da()}ED.prototype.bb=function(){return dc(new ec,this.Ur())};function FD(){}FD.prototype=new l;FD.prototype.constructor=FD;function rka(){} rka.prototype=FD.prototype;function GD(){}GD.prototype=new l;GD.prototype.constructor=GD;function HD(){}HD.prototype=GD.prototype;function I(a,b){if(b.z())return a.Do();a=a.bb();a.Yb(b);return a.Da()}GD.prototype.Do=function(){return this.bb().Da()};function ska(a,b){var d=a.md().bb();a.mb().wa(m(new n,function(a,b,d){return function(a){return d.Yb(b.y(a).mb())}}(a,b,d)));return d.Da()}function tka(a,b){a:for(;;){if(kd(b)){a.ld(b.$());b=b.aa();continue a}break}} function ID(a,b){b&&b.$classData&&b.$classData.n.gp?tka(a,b):b.wa(m(new n,function(a){return function(b){return a.ld(b)}}(a)));return a}function JD(){}JD.prototype=new l;JD.prototype.constructor=JD;function KD(){}KD.prototype=JD.prototype;function qC(){}qC.prototype=new l;qC.prototype.constructor=qC;qC.prototype.b=function(){return this};qC.prototype.$classData=g({aga:0},!1,"scala.collection.immutable.Stream$$hash$colon$colon$",{aga:1,d:1});var Sja=void 0;function LD(){this.IF=null}LD.prototype=new l; LD.prototype.constructor=LD;LD.prototype.yc=function(a){this.IF=a;return this};function uka(a,b){return MD(new ND,b,a.IF)}function vka(a,b){return OD(b,a.IF)}LD.prototype.$classData=g({bga:0},!1,"scala.collection.immutable.Stream$ConsWrapper",{bga:1,d:1});function PD(){this.yF=this.Ac=null;this.ya=!1;this.ga=null}PD.prototype=new l;PD.prototype.constructor=PD;function QD(a,b,d){a.yF=d;if(null===b)throw Kg(Lg(),null);a.ga=b;return a} function RD(a){a.ya||(a.ya||(a.Ac=Ee(a.yF),a.ya=!0),a.yF=null);return a.Ac}PD.prototype.$classData=g({gga:0},!1,"scala.collection.immutable.StreamIterator$LazyCell",{gga:1,d:1});function SD(){}SD.prototype=new l;SD.prototype.constructor=SD;SD.prototype.b=function(){return this};function Ye(a,b,d,e){a=0>d?0:d;return e<=a||a>=(b.length|0)?"":b.substring(a,e>(b.length|0)?b.length|0:e)}SD.prototype.$classData=g({iga:0},!1,"scala.collection.immutable.StringOps$",{iga:1,d:1});var TD=void 0; function Ze(){TD||(TD=(new SD).b());return TD}function UD(){}UD.prototype=new l;UD.prototype.constructor=UD;UD.prototype.b=function(){return this};UD.prototype.bb=function(){var a=(new Fm).b();return VD(new WD,a,m(new n,function(){return function(a){return(new Dj).c(a)}}(this)))};UD.prototype.$classData=g({qga:0},!1,"scala.collection.immutable.WrappedString$",{qga:1,d:1});var XD=void 0;function YD(){}YD.prototype=new l;YD.prototype.constructor=YD;YD.prototype.b=function(){return this}; YD.prototype.$classData=g({uga:0},!1,"scala.collection.mutable.ArrayOps$ofBoolean$",{uga:1,d:1});var wka=void 0;function ZD(){}ZD.prototype=new l;ZD.prototype.constructor=ZD;ZD.prototype.b=function(){return this};ZD.prototype.$classData=g({vga:0},!1,"scala.collection.mutable.ArrayOps$ofByte$",{vga:1,d:1});var xka=void 0;function $D(){}$D.prototype=new l;$D.prototype.constructor=$D;$D.prototype.b=function(){return this}; $D.prototype.$classData=g({wga:0},!1,"scala.collection.mutable.ArrayOps$ofChar$",{wga:1,d:1});var yka=void 0;function aE(){}aE.prototype=new l;aE.prototype.constructor=aE;aE.prototype.b=function(){return this};aE.prototype.$classData=g({xga:0},!1,"scala.collection.mutable.ArrayOps$ofDouble$",{xga:1,d:1});var zka=void 0;function bE(){}bE.prototype=new l;bE.prototype.constructor=bE;bE.prototype.b=function(){return this}; bE.prototype.$classData=g({yga:0},!1,"scala.collection.mutable.ArrayOps$ofFloat$",{yga:1,d:1});var Aka=void 0;function cE(){}cE.prototype=new l;cE.prototype.constructor=cE;cE.prototype.b=function(){return this};cE.prototype.$classData=g({zga:0},!1,"scala.collection.mutable.ArrayOps$ofInt$",{zga:1,d:1});var Bka=void 0;function dE(){}dE.prototype=new l;dE.prototype.constructor=dE;dE.prototype.b=function(){return this}; dE.prototype.$classData=g({Aga:0},!1,"scala.collection.mutable.ArrayOps$ofLong$",{Aga:1,d:1});var Cka=void 0;function eE(){}eE.prototype=new l;eE.prototype.constructor=eE;eE.prototype.b=function(){return this};eE.prototype.$classData=g({Bga:0},!1,"scala.collection.mutable.ArrayOps$ofRef$",{Bga:1,d:1});var Dka=void 0;function fE(){}fE.prototype=new l;fE.prototype.constructor=fE;fE.prototype.b=function(){return this}; fE.prototype.$classData=g({Cga:0},!1,"scala.collection.mutable.ArrayOps$ofShort$",{Cga:1,d:1});var Eka=void 0;function gE(){}gE.prototype=new l;gE.prototype.constructor=gE;gE.prototype.b=function(){return this};gE.prototype.$classData=g({Dga:0},!1,"scala.collection.mutable.ArrayOps$ofUnit$",{Dga:1,d:1});var Fka=void 0;function Gka(a){return hE(Hi(),-1+a.Vb.l.length|0)} function Hka(a,b){for(var d=Ga(b),d=iE(a,d),e=a.Vb.l[d];null!==e;){if(sn(tn(),e,b))return;d=(1+d|0)%a.Vb.l.length|0;e=a.Vb.l[d]}a.Vb.l[d]=b;a.Cf=1+a.Cf|0;null!==a.Jf&&(b=d>>5,d=a.Jf,d.l[b]=1+d.l[b]|0);if(a.Cf>=a.Ik)for(b=a.Vb,a.Vb=la(Xa(Ua),[a.Vb.l.length<<1]),a.Cf=0,null!==a.Jf&&(d=1+(a.Vb.l.length>>5)|0,a.Jf.l.length!==d?a.Jf=la(Xa(db),[d]):rja(gB(),a.Jf)),a.ul=Gka(a),a.Ik=Ika().Ou(a.Fl,a.Vb.l.length),d=0;d<b.l.length;)e=b.l[d],null!==e&&Hka(a,e),d=1+d|0} function iE(a,b){var d=a.ul;b=nka(oka(),b);a=-1+a.Vb.l.length|0;return((b>>>d|0|b<<(-d|0))>>>(32-hE(Hi(),a)|0)|0)&a}function jE(a,b){b=hf(b);for(var d=Ga(b),d=iE(a,d),e=a.Vb.l[d];null!==e&&!sn(tn(),e,b);)d=(1+d|0)%a.Vb.l.length|0,e=a.Vb.l[d];return e}function kE(){}kE.prototype=new l;kE.prototype.constructor=kE;kE.prototype.b=function(){return this}; kE.prototype.Ou=function(a,b){if(!(500>a))throw(new lE).j("assertion failed: loadFactor too large; must be \x3c 0.5");var d=b>>31,e=a>>31,f=65535&b,h=b>>>16|0,k=65535&a,p=a>>>16|0,t=da(f,k),k=da(h,k),x=da(f,p),f=t+((k+x|0)<<16)|0,t=(t>>>16|0)+x|0;a=(((da(b,e)+da(d,a)|0)+da(h,p)|0)+(t>>>16|0)|0)+(((65535&t)+k|0)>>>16|0)|0;return Df(Ra(),f,a,1E3,0)};kE.prototype.$classData=g({Mga:0},!1,"scala.collection.mutable.FlatHashTable$",{Mga:1,d:1});var mE=void 0; function Ika(){mE||(mE=(new kE).b());return mE}function nE(){}nE.prototype=new l;nE.prototype.constructor=nE;nE.prototype.b=function(){return this};nE.prototype.k=function(){return"NullSentinel"};nE.prototype.r=function(){return 0};nE.prototype.$classData=g({Oga:0},!1,"scala.collection.mutable.FlatHashTable$NullSentinel$",{Oga:1,d:1});var oE=void 0;function xba(){oE||(oE=(new nE).b());return oE}function Jka(a){return hE(Hi(),-1+a.Vb.l.length|0)} function Kka(a){for(var b=-1+a.Vb.l.length|0;0<=b;)a.Vb.l[b]=null,b=-1+b|0;a.Uq(0);Lka(a,0)}function Mka(a,b,d){for(a=a.Vb.l[d];;)if(null!==a?(d=a.fj(),d=!sn(tn(),d,b)):d=!1,d)a=a.ma();else break;return a}function pE(a,b){var d=-1+a.Vb.l.length|0,e=fa(d);a=a.ul;b=nka(oka(),b);return((b>>>a|0|b<<(-a|0))>>>e|0)&d}function Nka(a){a.cz(750);qE();a.Ay(la(Xa(zba),[rE(0,16)]));a.Uq(0);var b=a.Fl,d=qE();qE();a.Cy(d.Ou(b,rE(0,16)));a.wy(null);a.tF(Jka(a))} function sE(a,b){var d=hD(V(),b),d=pE(a,d),e=a.Vb.l[d];if(null!==e){var f=e.fj();if(sn(tn(),f,b))return a.Vb.l[d]=e.ma(),a.Uq(-1+a.Cf|0),Oka(a,d),e.As(null),e;for(f=e.ma();;){if(null!==f)var h=f.fj(),h=!sn(tn(),h,b);else h=!1;if(h)e=f,f=f.ma();else break}if(null!==f)return e.As(f.ma()),a.Uq(-1+a.Cf|0),Oka(a,d),f.As(null),f}return null}function tE(a){for(var b=-1+a.Vb.l.length|0;null===a.Vb.l[b]&&0<b;)b=-1+b|0;return b} function uE(a,b,d){var e=hD(V(),b),e=pE(a,e),f=Mka(a,b,e);if(null!==f)return f;b=a.cT(b,d);Pka(a,b,e);return null}function vE(a,b){var d=hD(V(),b),d=pE(a,d);return Mka(a,b,d)} function Pka(a,b,d){b.As(a.Vb.l[d]);a.Vb.l[d]=b;a.Uq(1+a.Cf|0);wE(a,d);if(a.Cf>a.Ik){b=a.Vb.l.length<<1;d=a.Vb;a.Ay(la(Xa(zba),[b]));Lka(a,a.Vb.l.length);for(var e=-1+d.l.length|0;0<=e;){for(var f=d.l[e];null!==f;){var h=f.fj(),h=hD(V(),h),h=pE(a,h),k=f.ma();f.As(a.Vb.l[h]);a.Vb.l[h]=f;f=k;wE(a,h)}e=-1+e|0}a.Cy(qE().Ou(a.Fl,b))}}function Oka(a,b){null!==a.Jf&&(a=a.Jf,b>>=5,a.l[b]=-1+a.l[b]|0)}function Lka(a,b){null!==a.Jf&&(b=1+(b>>5)|0,a.Jf.l.length!==b?a.wy(la(Xa(db),[b])):rja(gB(),a.Jf))} function wE(a,b){null!==a.Jf&&(a=a.Jf,b>>=5,a.l[b]=1+a.l[b]|0)}function xE(){}xE.prototype=new l;xE.prototype.constructor=xE;xE.prototype.b=function(){return this};function rE(a,b){return 1<<(-fa(-1+b|0)|0)}xE.prototype.Ou=function(a,b){var d=b>>31,e=a>>31,f=65535&b,h=b>>>16|0,k=65535&a,p=a>>>16|0,t=da(f,k),k=da(h,k),x=da(f,p),f=t+((k+x|0)<<16)|0,t=(t>>>16|0)+x|0;a=(((da(b,e)+da(d,a)|0)+da(h,p)|0)+(t>>>16|0)|0)+(((65535&t)+k|0)>>>16|0)|0;return Df(Ra(),f,a,1E3,0)}; xE.prototype.$classData=g({Wga:0},!1,"scala.collection.mutable.HashTable$",{Wga:1,d:1});var yE=void 0;function qE(){yE||(yE=(new xE).b());return yE}function zE(){this.pd=0;this.PC=this.qC=this.ne=this.Bh=null}zE.prototype=new l;zE.prototype.constructor=zE;c=zE.prototype;c.hU=function(a,b,d,e,f){this.pd=a;this.Bh=b;this.ne=d;this.qC=e;this.PC=f;return this};c.W=function(a){var b=this;for(;;){if(a<b.pd)return AE(W(),b.Bh,a);a=a-b.pd|0;b=b.ne}}; c.nf=function(a,b){var d=this;a:for(;;){if(a<d.pd)BE(W(),d.Bh,a,b);else{a=a-d.pd|0;d=d.ne;continue a}break}}; c.k=function(){$e();var a=Dw($e(),this.Bh),a=Dw(0,CE(a,0,this.pd)),b=(new Sb).c("Unrolled@%08x"),d=[Ka(this)];Ia();b=b.R;r();Zn();for(var e=[],f=0,h=d.length|0;f<h;){var k=d[f];e.push(DE(k)?k.AY():k);f=1+f|0}LC();for(var d=e.length|0,d=la(Xa(Ua),[d]),k=d.l.length,h=f=0,p=e.length|0,k=p<k?p:k,p=d.l.length,k=k<p?k:p;f<k;)d.l[h]=e[f],f=1+f|0,h=1+h|0;e=(new EE).b();b=Qka(Rka(e,b,d)).k();e.qo();b=b+"["+this.pd+"/"+uD(W(),this.Bh)+"](";return cc(a,b,", ",")")+" -\x3e "+(null!==this.ne?this.ne.k():"")}; c.wa=function(a){for(var b=this,d=0;null!==b;){for(var e=b.Bh,f=b.pd;d<f;){var h=AE(W(),e,d);a.y(h);d=1+d|0}d=0;b=b.ne}};function Ska(a){return null===a.qC?FE().QF:uD(W(),a.Bh)}c.$classData=g({yha:0},!1,"scala.collection.mutable.UnrolledBuffer$Unrolled",{yha:1,d:1});function rB(){this.CG=null}rB.prototype=new l;rB.prototype.constructor=rB;rB.prototype.b=function(){qB=this;this.CG=(new Fi).Gh(la(Xa(Ua),[0]));return this}; rB.prototype.$classData=g({zha:0},!1,"scala.collection.mutable.WrappedArray$",{zha:1,d:1});var qB=void 0;function NB(){this.UV=null}NB.prototype=new l;NB.prototype.constructor=NB;NB.prototype.b=function(){MB=this;Tka||(Tka=(new GE).b());Uka||(Uka=(new HE).b());this.UV=void 0===ba.Promise?(new IE).b():(new JE).b();return this};NB.prototype.$classData=g({Bha:0},!1,"scala.scalajs.concurrent.JSExecutionContext$",{Bha:1,d:1});var MB=void 0;function HE(){}HE.prototype=new l;HE.prototype.constructor=HE; HE.prototype.b=function(){return this};HE.prototype.$classData=g({Cha:0},!1,"scala.scalajs.concurrent.QueueExecutionContext$",{Cha:1,d:1});var Uka=void 0;function hv(){}hv.prototype=new l;hv.prototype.constructor=hv;hv.prototype.b=function(){return this};function Yga(a,b){var d={};b.Vn(m(new n,function(){return function(a){return null!==a}}(a))).wa(m(new n,function(a,b){return function(a){if(null!==a)b[a.la()]=a.pa();else throw(new q).j(a);}}(a,d)));return d} hv.prototype.$classData=g({Hha:0},!1,"scala.scalajs.js.Dictionary$",{Hha:1,d:1});var gv=void 0;function KE(){this.qm=null}KE.prototype=new l;KE.prototype.constructor=KE;KE.prototype.b=function(){LE=this;this.qm=ba.Object.prototype.hasOwnProperty;return this};KE.prototype.$classData=g({Nha:0},!1,"scala.scalajs.js.WrappedDictionary$Cache$",{Nha:1,d:1});var LE=void 0;function Wu(){LE||(LE=(new KE).b());return LE}function ME(){this.ip=!1;this.YC=this.qs=this.wt=null;this.nC=!1;this.mE=this.gD=0} ME.prototype=new l;ME.prototype.constructor=ME;ME.prototype.b=function(){NE=this;this.wt=(this.ip=!!(ba.ArrayBuffer&&ba.Int32Array&&ba.Float32Array&&ba.Float64Array))?new ba.ArrayBuffer(8):null;this.qs=this.ip?new ba.Int32Array(this.wt,0,2):null;this.ip&&new ba.Float32Array(this.wt,0,2);this.YC=this.ip?new ba.Float64Array(this.wt,0,1):null;if(this.ip)this.qs[0]=16909060,a=1===((new ba.Int8Array(this.wt,0,8))[0]|0);else var a=!0;this.gD=(this.nC=a)?0:1;this.mE=this.nC?1:0;return this}; function daa(a,b){var d=b|0;if(d===b&&-Infinity!==1/b)return d;if(a.ip)a.YC[0]=b,a=(new Vb).ia(a.qs[a.mE]|0,a.qs[a.gD]|0);else{if(b!==b)a=!1,b=2047,d=+ba.Math.pow(2,51);else if(Infinity===b||-Infinity===b)a=0>b,b=2047,d=0;else if(0===b)a=-Infinity===1/b,d=b=0;else{var e=(a=0>b)?-b:b;if(e>=+ba.Math.pow(2,-1022)){b=+ba.Math.pow(2,52);var d=+ba.Math.log(e)/.6931471805599453,d=+ba.Math.floor(d)|0,d=1023>d?d:1023,f=+ba.Math.pow(2,d);f>e&&(d=-1+d|0,f/=2);f=e/f*b;e=+ba.Math.floor(f);f-=e;e=.5>f?e:.5<f?1+ e:0!==e%2?1+e:e;2<=e/b&&(d=1+d|0,e=1);1023<d?(d=2047,e=0):(d=1023+d|0,e-=b);b=d;d=e}else b=e/+ba.Math.pow(2,-1074),d=+ba.Math.floor(b),e=b-d,b=0,d=.5>e?d:.5<e?1+d:0!==d%2?1+d:d}d=+d;a=(new Vb).ia(d|0,(a?-2147483648:0)|(b|0)<<20|d/4294967296|0)}return a.ka^a.qa} function Vka(a){var b=a.qa,d=0>b,e=2047&b>>20;a=4294967296*(1048575&b)+ +(a.ka>>>0);return 2047===e?0!==a?NaN:d?-Infinity:Infinity:0<e?(e=+ba.Math.pow(2,-1023+e|0)*(1+a/+ba.Math.pow(2,52)),d?-e:e):0!==a?(e=+ba.Math.pow(2,-1022)*(a/+ba.Math.pow(2,52)),d?-e:e):d?-0:0}ME.prototype.$classData=g({Vha:0},!1,"scala.scalajs.runtime.Bits$",{Vha:1,d:1});var NE=void 0;function Ja(){NE||(NE=(new ME).b());return NE}function OE(){this.ya=!1}OE.prototype=new l;OE.prototype.constructor=OE; function Wp(a,b,d){return b.substring((b.length|0)-(d.length|0)|0)===d}OE.prototype.b=function(){return this};function PE(a,b){a=b.length|0;for(var d=la(Xa(ab),[a]),e=0;e<a;)d.l[e]=65535&(b.charCodeAt(e)|0),e=1+e|0;return d} function QE(a,b,d){if(null===b)throw(new Oe).b();a=Eg(Dg(),d);b=na(b);if(""===b)for(d=(new w).f([""]),b=d.oa.length|0,b=la(Xa(qa),[b]),a=0,d=lf(new mf,d,0,d.oa.length|0);d.ta();){var e=d.ma();b.l[a]=e;a=1+a|0}else{d=Fg(new Gg,a,b,b.length|0);a=[];for(var f=0,e=0;2147483646>e&&oi(d);){if(0!==d.Wm()){var h=d.vl(),f=b.substring(f,h);a.push(null===f?null:f);e=1+e|0}f=d.Wm()}b=b.substring(f);a.push(null===b?null:b);b=ka(Xa(qa),a);for(a=b.l.length;0!==a&&""===b.l[-1+a|0];)a=-1+a|0;a!==b.l.length&&(d=la(Xa(qa), [a]),Oa(b,0,d,0,a),b=d)}return b}function DB(a,b){return null===b?"null":na(b)}function Ew(a,b,d){a=Wka(d);return b.indexOf(a)|0}function RE(a,b,d,e){a=d+e|0;if(0>d||a<d||a>b.l.length)throw(new SE).b();for(e="";d!==a;)e=""+e+ba.String.fromCharCode(b.l[d]),d=1+d|0;return e}function Wka(a){if(0===(-65536&a))return ba.String.fromCharCode(a);if(0>a||1114111<a)throw(new df).b();a=-65536+a|0;return ba.String.fromCharCode(55296|a>>10,56320|1023&a)} function Ha(a,b){a=0;for(var d=1,e=-1+(b.length|0)|0;0<=e;)a=a+da(65535&(b.charCodeAt(e)|0),d)|0,d=da(31,d),e=-1+e|0;return a}function Qb(a,b,d,e){if(null===b)throw(new Oe).b();a=Eg(Dg(),d);b=Fg(new Gg,a,b,b.length|0);ro(b);for(a=(new so).b();oi(b);)to(b,a,e);uo(b,a);return a.Zb}OE.prototype.$classData=g({Xha:0},!1,"scala.scalajs.runtime.RuntimeString$",{Xha:1,d:1});var TE=void 0;function Ia(){TE||(TE=(new OE).b());return TE}function UE(){this.vU=!1;this.YS=this.gT=this.fT=null;this.ya=0} UE.prototype=new l;UE.prototype.constructor=UE;UE.prototype.b=function(){return this};function Xka(a){return(a.stack+"\n").replace(VE("^[\\s\\S]+?\\s+at\\s+")," at ").replace(WE("^\\s+(at eval )?at\\s+","gm"),"").replace(WE("^([^\\(]+?)([\\n])","gm"),"{anonymous}() ($1)$2").replace(WE("^Object.\x3canonymous\x3e\\s*\\(([^\\)]+)\\)","gm"),"{anonymous}() ($1)").replace(WE("^([^\\(]+|\\{anonymous\\}\\(\\)) \\((.+)\\)$","gm"),"$1@$2").split("\n").slice(0,-1)} function Yka(a){0===(8&a.ya)&&0===(8&a.ya)&&(a.YS=ba.Object.keys(Zka(a)),a.ya=(8|a.ya)<<24>>24);return a.YS}function $ka(a){if(0===(2&a.ya)&&0===(2&a.ya)){for(var b={O:"java_lang_Object",T:"java_lang_String",V:"scala_Unit",Z:"scala_Boolean",C:"scala_Char",B:"scala_Byte",S:"scala_Short",I:"scala_Int",J:"scala_Long",F:"scala_Float",D:"scala_Double"},d=0;22>=d;)2<=d&&(b["T"+d]="scala_Tuple"+d),b["F"+d]="scala_Function"+d,d=1+d|0;a.fT=b;a.ya=(2|a.ya)<<24>>24}return a.fT} function ala(a,b){var d=VE("^(?:Object\\.|\\[object Object\\]\\.)?(?:ScalaJS\\.c\\.|\\$c_)([^\\.]+)(?:\\.prototype)?\\.([^\\.]+)$"),e=VE("^(?:Object\\.|\\[object Object\\]\\.)?(?:ScalaJS\\.(?:s|f)\\.|\\$(?:s|f)_)((?:_[^_]|[^_])+)__([^\\.]+)$"),f=VE("^(?:Object\\.|\\[object Object\\]\\.)?(?:ScalaJS\\.m\\.|\\$m_)([^\\.]+)$"),h=!1,d=d.exec(b);null===d&&(d=e.exec(b),null===d&&(d=f.exec(b),h=!0));if(null!==d){b=d[1];if(void 0===b)throw(new Xu).c("undefined.get");b=36===(65535&(b.charCodeAt(0)|0))?b.substring(1): b;e=$ka(a);if(Wu().qm.call(e,b)){a=$ka(a);if(!Wu().qm.call(a,b))throw(new Xu).c("key not found: "+b);a=a[b]}else a:for(f=0;;)if(f<(Yka(a).length|0)){e=Yka(a)[f];if(0<=(b.length|0)&&b.substring(0,e.length|0)===e){a=Zka(a);if(!Wu().qm.call(a,e))throw(new Xu).c("key not found: "+e);a=""+a[e]+b.substring(e.length|0);break a}f=1+f|0}else{a=0<=(b.length|0)&&"L"===b.substring(0,1)?b.substring(1):b;break a}a=a.split("_").join(".").split("$und").join("_");if(h)h="\x3cclinit\x3e";else{h=d[2];if(void 0===h)throw(new Xu).c("undefined.get"); 0<=(h.length|0)&&"init___"===h.substring(0,7)?h="\x3cinit\x3e":(d=h.indexOf("__")|0,h=0>d?h:h.substring(0,d))}return(new A).e(a,h)}return(new A).e("\x3cjscode\x3e",b)}function bla(a){var b=WE("Line (\\d+).*script (?:in )?(\\S+)","i");a=a.message.split("\n");for(var d=[],e=2,f=a.length|0;e<f;){var h=b.exec(a[e]);if(null!==h){var k=h[2];if(void 0===k)throw(new Xu).c("undefined.get");h=h[1];if(void 0===h)throw(new Xu).c("undefined.get");d.push("{anonymous}()@"+k+":"+h)}e=2+e|0}return d} function Zka(a){0===(4&a.ya)&&0===(4&a.ya)&&(a.gT={sjsr_:"scala_scalajs_runtime_",sjs_:"scala_scalajs_",sci_:"scala_collection_immutable_",scm_:"scala_collection_mutable_",scg_:"scala_collection_generic_",sc_:"scala_collection_",sr_:"scala_runtime_",s_:"scala_",jl_:"java_lang_",ju_:"java_util_"},a.ya=(4|a.ya)<<24>>24);return a.gT}UE.prototype.$classData=g({Yha:0},!1,"scala.scalajs.runtime.StackTrace$",{Yha:1,d:1});var XE=void 0;function YE(){}YE.prototype=new l;YE.prototype.constructor=YE; YE.prototype.b=function(){return this};function WE(a,b){ZE||(ZE=(new YE).b());return new ba.RegExp(a,b)}function VE(a){ZE||(ZE=(new YE).b());return new ba.RegExp(a)}YE.prototype.$classData=g({Zha:0},!1,"scala.scalajs.runtime.StackTrace$StringRE$",{Zha:1,d:1});var ZE=void 0;function $E(){}$E.prototype=new l;$E.prototype.constructor=$E;$E.prototype.b=function(){return this};function Kg(a,b){return aF(b)?b.Go:b}function ko(a,b){return b&&b.$classData&&b.$classData.n.ad?b:(new bF).j(b)} $E.prototype.$classData=g({$ha:0},!1,"scala.scalajs.runtime.package$",{$ha:1,d:1});var cF=void 0;function Lg(){cF||(cF=(new $E).b());return cF}function dF(){}dF.prototype=new l;dF.prototype.constructor=dF;dF.prototype.b=function(){return this};function cla(a,b){if(ze(b))return a.X===b.X;if(eF(b)){if("number"===typeof b)return+b===a.X;if(Ca(b)){b=Qa(b);var d=b.qa;a=a.X;return b.ka===a&&d===a>>31}return null===b?null===a:Ea(b,a)}return null===a&&null===b} function sn(a,b,d){if(b===d)d=!0;else if(eF(b))a:if(eF(d))d=fF(0,b,d);else{if(ze(d)){if("number"===typeof b){d=+b===d.X;break a}if(Ca(b)){a=Qa(b);b=a.qa;d=d.X;d=a.ka===d&&b===d>>31;break a}}d=null===b?null===d:Ea(b,d)}else d=ze(b)?cla(b,d):null===b?null===d:Ea(b,d);return d} function fF(a,b,d){if("number"===typeof b)return a=+b,"number"===typeof d?a===+d:Ca(d)?(b=Qa(d),d=b.ka,b=b.qa,a===gF(Ra(),d,b)):DE(d)?d.o(a):!1;if(Ca(b)){b=Qa(b);a=b.ka;b=b.qa;if(Ca(d)){d=Qa(d);var e=d.qa;return a===d.ka&&b===e}return"number"===typeof d?(d=+d,gF(Ra(),a,b)===d):DE(d)?d.o((new Vb).ia(a,b)):!1}return null===b?null===d:Ea(b,d)}dF.prototype.$classData=g({cia:0},!1,"scala.runtime.BoxesRunTime$",{cia:1,d:1});var hF=void 0;function tn(){hF||(hF=(new dF).b());return hF} function iF(){this.hb=this.La=!1}iF.prototype=new l;iF.prototype.constructor=iF;iF.prototype.b=function(){return this};iF.prototype.k=function(){return u((new v).K((new w).f(["LazyBoolean ",""])),(new w).f([this.La?u((new v).K((new w).f(["of: ",""])),(new w).f([this.hb])):"thunk"]))};iF.prototype.$classData=g({fia:0},!1,"scala.runtime.LazyBoolean",{fia:1,d:1});function jF(){this.La=!1;this.hb=0}jF.prototype=new l;jF.prototype.constructor=jF;jF.prototype.b=function(){return this}; jF.prototype.k=function(){return u((new v).K((new w).f(["LazyInt ",""])),(new w).f([this.La?u((new v).K((new w).f(["of: ",""])),(new w).f([this.hb])):"thunk"]))};jF.prototype.$classData=g({gia:0},!1,"scala.runtime.LazyInt",{gia:1,d:1});function Ne(){this.La=!1;this.hb=null}Ne.prototype=new l;Ne.prototype.constructor=Ne;Ne.prototype.b=function(){return this}; Ne.prototype.k=function(){return u((new v).K((new w).f(["LazyRef ",""])),(new w).f([this.La?u((new v).K((new w).f(["of: ",""])),(new w).f([this.hb])):"thunk"]))};function Pe(a,b){a.hb=b;a.La=!0;return b}Ne.prototype.$classData=g({hia:0},!1,"scala.runtime.LazyRef",{hia:1,d:1});var kF=g({kia:0},!1,"scala.runtime.Null$",{kia:1,d:1});function lF(){}lF.prototype=new l;lF.prototype.constructor=lF;lF.prototype.b=function(){return this};function Pu(a,b){return Na(b)===b} lF.prototype.$classData=g({mia:0},!1,"scala.runtime.RichDouble$",{mia:1,d:1});var mF=void 0;function Qu(){mF||(mF=(new lF).b());return mF}function nF(){}nF.prototype=new l;nF.prototype.constructor=nF;nF.prototype.b=function(){return this};nF.prototype.$classData=g({nia:0},!1,"scala.runtime.RichLong$",{nia:1,d:1});var dla=void 0;function oF(){dla||(dla=(new nF).b())}function pF(){}pF.prototype=new l;pF.prototype.constructor=pF;pF.prototype.b=function(){return this}; function uD(a,b){if(ve(b,1)||lb(b,1)||ob(b,1)||mb(b,1)||nb(b,1)||ib(b,1)||jb(b,1)||kb(b,1)||hb(b,1)||rF(b))return b.l.length;if(null===b)throw(new Oe).b();throw(new q).j(b);} function BE(a,b,d,e){if(ve(b,1))b.l[d]=e;else if(lb(b,1))b.l[d]=e|0;else if(ob(b,1))b.l[d]=+e;else if(mb(b,1))b.l[d]=Qa(e);else if(nb(b,1))b.l[d]=+e;else if(ib(b,1))b.l[d]=null===e?0:e.X;else if(jb(b,1))b.l[d]=e|0;else if(kb(b,1))b.l[d]=e|0;else if(hb(b,1))b.l[d]=!!e;else if(rF(b))b.l[d]=void 0;else{if(null===b)throw(new Oe).b();throw(new q).j(b);}}function X(a,b){a=b.x();return cc(a,b.u()+"(",",",")")} function AE(a,b,d){if(ve(b,1)||lb(b,1)||ob(b,1)||mb(b,1)||nb(b,1))return b.l[d];if(ib(b,1))return(new af).Ra(b.l[d]);if(jb(b,1)||kb(b,1)||hb(b,1)||rF(b))return b.l[d];if(null===b)throw(new Oe).b();throw(new q).j(b);}pF.prototype.$classData=g({oia:0},!1,"scala.runtime.ScalaRunTime$",{oia:1,d:1});var sF=void 0;function W(){sF||(sF=(new pF).b());return sF}function tF(){}tF.prototype=new l;tF.prototype.constructor=tF;c=tF.prototype;c.b=function(){return this}; c.zs=function(a,b){b=da(-862048943,b);b=da(461845907,b<<15|b>>>17|0);return a^b};function uF(a,b){a=Na(b);if(a===b)return a;var d=Ra();a=vF(d,b);d=d.Pb;return gF(Ra(),a,d)===b?a^d:daa(Ja(),b)}function hD(a,b){return null===b?0:"number"===typeof b?uF(0,+b):Ca(b)?(a=Qa(b),wF(0,(new Vb).ia(a.ka,a.qa))):Ga(b)}c.da=function(a,b){a=this.zs(a,b);return-430675100+da(5,a<<13|a>>>19|0)|0};function wF(a,b){a=b.ka;b=b.qa;return b===a>>31?a:a^b} c.tb=function(a,b){a^=b;a=da(-2048144789,a^(a>>>16|0));a=da(-1028477387,a^(a>>>13|0));return a^(a>>>16|0)};c.$classData=g({qia:0},!1,"scala.runtime.Statics$",{qia:1,d:1});var xF=void 0;function V(){xF||(xF=(new tF).b());return xF}function yF(){this.ZT=null;this.QS=0;this.RT=this.YT=this.$T=this.aU=null;this.a=0}yF.prototype=new l;yF.prototype.constructor=yF; yF.prototype.b=function(){zF=this;this.ZT=nh(oh(),y());this.a|=1;this.QS=N(D())|Pj(D());this.a|=2;for(var a=N(D()),a=(new A).e("WHO",a),b=AF(this),b=(new A).e("COLOR",b),d=N(D()),d=(new A).e("HEADING",d),e=N(D()),e=(new A).e("XCOR",e),f=N(D()),f=(new A).e("YCOR",f),h=Oj(D()),h=(new A).e("SHAPE",h),k=lc(),k=(new A).e("LABEL",k),p=AF(this),p=(new A).e("LABEL-COLOR",p),t=Qj(D()),t=(new A).e("BREED",t),x=Nj(D()),x=(new A).e("HIDDEN?",x),E=N(D()),E=(new A).e("SIZE",E),S=N(D()),S=(new A).e("PEN-SIZE",S), U=Oj(D()),a=[a,b,d,e,f,h,k,p,t,x,E,S,(new A).e("PEN-MODE",U)],b=dc(new ec,Yu()),d=0,e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.aU=b.Ma;this.a|=4;a=N(D());a=(new A).e("PXCOR",a);b=N(D());b=(new A).e("PYCOR",b);d=AF(this);d=(new A).e("PCOLOR",d);e=lc();e=(new A).e("PLABEL",e);f=AF(this);a=[a,b,d,e,(new A).e("PLABEL-COLOR",f)];b=dc(new ec,Yu());d=0;for(e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.$T=b.Ma;this.a|=8;a=Uj(D());a=(new A).e("END1",a);b=Uj(D());b=(new A).e("END2",b);d=AF(this);d=(new A).e("COLOR", d);e=lc();e=(new A).e("LABEL",e);f=AF(this);f=(new A).e("LABEL-COLOR",f);h=Nj(D());h=(new A).e("HIDDEN?",h);k=Tj(D());k=(new A).e("BREED",k);p=N(D());p=(new A).e("THICKNESS",p);t=Oj(D());t=(new A).e("SHAPE",t);x=Oj(D());a=[a,b,d,e,f,h,k,p,t,(new A).e("TIE-MODE",x)];b=dc(new ec,Yu());d=0;for(e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.YT=b.Ma;this.a|=16;a=BF(this);a=Ic(a);Ap(a);this.a|=32;a=CF(this);a=Ic(a);Ap(a);this.a|=64;a=DF(this);a=Ic(a);Ap(a);this.a|=128;a=EF(this);a=Ic(a);Ap(a);this.a|=256;a= BF(this);a=Ic(a);Ap(a).se((new Qn).xg(pa(qa)));this.a|=512;a=EF(this);a=Ic(a);this.RT=Ap(a).se((new Qn).xg(pa(qa)));this.a|=1024;return this};function CF(a){if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 14");return a.aU}function BF(a){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 9");return a.ZT} function rga(){var a=FF(),a=DF(a),a=Ic(a);return Ap(a).se((new Qn).xg(pa(qa)))}function oga(){var a=FF(),a=CF(a),a=Ic(a);return Ap(a).se((new Qn).xg(pa(qa)))}function AF(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 12");return a.QS}function EF(a){if(0===(16&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 36");return a.YT} function nga(){var a=FF();if(0===(1024&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 56");return a.RT}function DF(a){if(0===(8&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AgentVariables.scala: 29");return a.$T}yF.prototype.$classData=g({jZ:0},!1,"org.nlogo.core.AgentVariables$",{jZ:1,d:1,zia:1});var zF=void 0;function FF(){zF||(zF=(new yF).b());return zF} function GF(a){return!!(a&&a.$classData&&a.$classData.n.$G)}function yt(){this.CR=this.KR=0;this.eW=this.tV=this.uV=null;this.a=0}yt.prototype=new l;yt.prototype.constructor=yt; yt.prototype.b=function(){Zb=this;this.KR=14;this.a=(1|this.a)<<24>>24;if(0===(1&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231");this.CR=da(10,this.KR);this.a=(2|this.a)<<24>>24;this.a=(4|this.a)<<24>>24;Wba(dh());this.a=(8|this.a)<<24>>24;var a=(new w).f([140,140,140,215,48,39,241,105,19,156,109,70,237,237,47,87,176,58,42,209,57,27,158,119,82,196,196,43,140,190,50,92,168,123,78,163,166,25,105,224,126,149,0,0,0,255,255,255]), b=a.oa.length|0,b=la(Xa(db),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e|0;d=1+d|0}this.uV=b;this.a=(16|this.a)<<24>>24;a=da(10,ela(this));if(e=0>=a)var f=0;else b=a>>31,f=(0===b?-1<(-2147483648^a):0<b)?-1:a;b=-1+a|0;HF();Mk();HF();Lk();d=(new IF).b();0>f&&$n(ao(),0,a,1,!1);if(!e)for(a=0;;){var h=a,k=h/100|0,e=JF(this).l[da(3,k)],f=JF(this).l[1+da(3,k)|0],k=JF(this).l[2+da(3,k)|0],h=.012+(-50+(h%100|0)|0)/50.48;0>h?(e=e+Na(e*h)|0,f=f+Na(f*h)|0,k=k+Na(k*h)|0):0<h&&(e= e+Na((255-e|0)*h)|0,f=f+Na((255-f|0)*h)|0,k=k+Na((255-k|0)*h)|0);KF(d,((-16777216+(e<<16)|0)+(f<<8)|0)+k|0);if(a===b)break;a=1+a|0}b=LF(d);d=b.sa();d=la(Xa(db),[d]);tD(b,d,0);d.l[0]=-16777216;d.l[99]=-1;this.tV=d;this.a=(32|this.a)<<24>>24;MF||(MF=(new NF).b());b=nh(MF,y());a=da(10,ela(this));d=-1+a|0;if(!(0>=a))for(a=0;;){f=e=a/10;if(0===(32&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231");b.bv(this.tV.l[Na(10*f)],e);if(a===d)break; a=1+a|0}this.eW=b;this.a=(64|this.a)<<24>>24;return this};function ela(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231");return a.CR}function uaa(a){if(0===(64&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231");return a.eW} function JF(a){if(0===(16&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Color.scala: 231");return a.uV}yt.prototype.$classData=g({uZ:0},!1,"org.nlogo.core.Color$",{uZ:1,d:1,Bia:1});var Zb=void 0;function OF(){}OF.prototype=new l;OF.prototype.constructor=OF;OF.prototype.b=function(){return this};OF.prototype.$classData=g({AZ:0},!1,"org.nlogo.core.DummyCompilationEnvironment",{AZ:1,d:1,Cia:1});function xs(){}xs.prototype=new l; xs.prototype.constructor=xs;c=xs.prototype;c.b=function(){return this};c.hY=function(){};c.yS=function(){return!1};c.aW=function(){return null};c.bU=function(){throw(new Ul).b();};c.$classData=g({BZ:0},!1,"org.nlogo.core.DummyExtensionManager",{BZ:1,d:1,FZ:1});function PF(){this.wT=null;this.a=!1}PF.prototype=new l;PF.prototype.constructor=PF;PF.prototype.b=function(){QF=this;var a=new RF;if(null===this)throw Kg(Lg(),null);a.Sa=this;this.wT=a;this.a=!0;return this}; PF.prototype.$classData=g({CZ:0},!1,"org.nlogo.core.Dump$",{CZ:1,d:1,Fia:1});var QF=void 0;function Eo(){QF||(QF=(new PF).b());return QF}function SF(){this.Yi=this.ij=this.ES=null;this.a=0}SF.prototype=new l;SF.prototype.constructor=SF;function fla(){}fla.prototype=SF.prototype; SF.prototype.cf=function(){var a=$e().kk,b=(new A).e("org.nlogo.core.prim._breed",m(new n,function(){return function(a){return(new TF).c(a)}}(this))),d=(new A).e("org.nlogo.core.prim._breedvariable",m(new n,function(){return function(a){return(new UF).c(a)}}(this))),e=(new A).e("org.nlogo.core.prim._createorderedturtles",m(new n,function(){return function(a){return(new VF).c(a)}}(this))),f=(new A).e("org.nlogo.core.prim._createturtles",m(new n,function(){return function(a){return(new XF).c(a)}}(this))), h=(new A).e("org.nlogo.core.prim._hatch",m(new n,function(){return function(a){return(new bG).c(a)}}(this))),k=(new A).e("org.nlogo.core.prim._lambdavariable",m(new n,function(){return function(a){return(new kn).c(a)}}(this))),p=(new A).e("org.nlogo.core.prim._linkbreedvariable",m(new n,function(){return function(a){return(new cG).c(a)}}(this))),t=(new A).e("org.nlogo.core.prim._sprout",m(new n,function(){return function(a){return(new dG).c(a)}}(this))),x=(new A).e("org.nlogo.core.prim.etc._breedat", m(new n,function(){return function(a){return(new eG).c(a)}}(this))),E=(new A).e("org.nlogo.core.prim.etc._breedhere",m(new n,function(){return function(a){return(new fG).c(a)}}(this))),S=(new A).e("org.nlogo.core.prim.etc._breedon",m(new n,function(){return function(a){return(new gG).c(a)}}(this))),U=(new A).e("org.nlogo.core.prim.etc._breedsingular",m(new n,function(){return function(a){return(new hG).c(a)}}(this))),ga=(new A).e("org.nlogo.core.prim.etc._inlinkfrom",m(new n,function(){return function(a){return(new iG).c(a)}}(this))), ma=(new A).e("org.nlogo.core.prim.etc._inlinkneighbor",m(new n,function(){return function(a){return(new jG).c(a)}}(this))),va=(new A).e("org.nlogo.core.prim.etc._inlinkneighbors",m(new n,function(){return function(a){return(new kG).c(a)}}(this))),Fa=(new A).e("org.nlogo.core.prim.etc._isbreed",m(new n,function(){return function(a){return(new lG).c(a)}}(this))),Va=(new A).e("org.nlogo.core.prim.etc._linkbreed",m(new n,function(){return function(a){return(new mG).c(a)}}(this))),vb=(new A).e("org.nlogo.core.prim.etc._linkbreedsingular", m(new n,function(){return function(a){return(new nG).c(a)}}(this))),pb=(new A).e("org.nlogo.core.prim.etc._linkneighbor",m(new n,function(){return function(a){return(new oG).c(a)}}(this))),Ib=(new A).e("org.nlogo.core.prim.etc._linkneighbors",m(new n,function(){return function(a){return(new pG).c(a)}}(this))),kc=(new A).e("org.nlogo.core.prim.etc._linkwith",m(new n,function(){return function(a){return(new qG).c(a)}}(this))),$a=(new A).e("org.nlogo.core.prim.etc._myinlinks",m(new n,function(){return function(a){return(new rG).c(a)}}(this))), fc=(new A).e("org.nlogo.core.prim.etc._mylinks",m(new n,function(){return function(a){return(new sG).c(a)}}(this))),Bc=(new A).e("org.nlogo.core.prim.etc._myoutlinks",m(new n,function(){return function(a){return(new tG).c(a)}}(this))),sf=(new A).e("org.nlogo.core.prim.etc._outlinkneighbor",m(new n,function(){return function(a){return(new uG).c(a)}}(this))),Sf=(new A).e("org.nlogo.core.prim.etc._outlinkneighbors",m(new n,function(){return function(a){return(new vG).c(a)}}(this))),th=(new A).e("org.nlogo.core.prim.etc._outlinkto", m(new n,function(){return function(a){return(new wG).c(a)}}(this))),Te=(new A).e("org.nlogo.core.prim.etc._createlinkwith",m(new n,function(){return function(a){return(new xG).c(a)}}(this))),tf=(new A).e("org.nlogo.core.prim.etc._createlinkto",m(new n,function(){return function(a){return(new yG).c(a)}}(this))),ek=(new A).e("org.nlogo.core.prim.etc._createlinkfrom",m(new n,function(){return function(a){return(new zG).c(a)}}(this))),og=(new A).e("org.nlogo.core.prim.etc._createlinkswith",m(new n,function(){return function(a){return(new AG).c(a)}}(this))), uh=(new A).e("org.nlogo.core.prim.etc._createlinksto",m(new n,function(){return function(a){return(new BG).c(a)}}(this)));this.ES=nh(a,(new w).f([b,d,e,f,h,k,p,t,x,E,S,U,ga,ma,va,Fa,Va,vb,pb,Ib,kc,$a,fc,Bc,sf,Sf,th,Te,tf,ek,og,uh,(new A).e("org.nlogo.core.prim.etc._createlinksfrom",m(new n,function(){return function(a){return(new CG).c(a)}}(this)))]));this.a=(1|this.a)<<24>>24;var pg=$e().kk,Yh=(new A).e("!\x3d",K(function(){return function(){return(new DG).b()}}(this))),Ri=(new A).e("*",K(function(){return function(){return(new EG).b()}}(this))), fk=(new A).e("+",K(function(){return function(){return(new FG).b()}}(this))),Si=(new A).e("-",K(function(){return function(){return(new GG).b()}}(this))),gk=(new A).e("/",K(function(){return function(){return(new JG).b()}}(this))),Ti=(new A).e("\x3c",K(function(){return function(){return(new KG).b()}}(this))),vl=(new A).e("\x3c\x3d",K(function(){return function(){return(new LG).b()}}(this))),Ui=(new A).e("\x3d",K(function(){return function(){return(new MG).b()}}(this))),hk=(new A).e("\x3e",K(function(){return function(){return(new NG).b()}}(this))), Vi=(new A).e("\x3e\x3d",K(function(){return function(){return(new OG).b()}}(this))),wl=(new A).e("^",K(function(){return function(){return(new PG).b()}}(this))),vh=(new A).e("__APPLY-RESULT",K(function(){return function(){return(new QG).b()}}(this))),xl=(new A).e("__BOOM",K(function(){return function(){return(new RG).b()}}(this))),wh=(new A).e("__BLOCK",K(function(){return function(){return(new SG).b()}}(this))),ik=(new A).e("__CHECK-SYNTAX",K(function(){return function(){return(new TG).b()}}(this))), yl=(new A).e("__CHECKSUM",K(function(){return function(){return(new UG).b()}}(this))),Zh=(new A).e("__DUMP",K(function(){return function(){return(new VG).b()}}(this))),$h=(new A).e("__DUMP-EXTENSION-PRIMS",K(function(){return function(){return(new WG).b()}}(this))),zl=(new A).e("__DUMP-EXTENSIONS",K(function(){return function(){return(new XG).b()}}(this))),Al=(new A).e("__DUMP1",K(function(){return function(){return(new YG).b()}}(this))),Bl=(new A).e("__NANO-TIME",K(function(){return function(){return(new ZG).b()}}(this))), jk=(new A).e("__PROCESSORS",K(function(){return function(){return(new $G).b()}}(this))),Cl=(new A).e("__RANDOM-STATE",K(function(){return function(){return(new aH).b()}}(this))),Dl=(new A).e("__REFERENCE",K(function(){return function(){return(new bH).b()}}(this))),El=(new A).e("__STACK-TRACE",K(function(){return function(){return(new cH).b()}}(this))),Fl=(new A).e("__SYMBOL",K(function(){return function(){return(new dH).b()}}(this))),kk=(new A).e("__TO-STRING",K(function(){return function(){return(new eH).b()}}(this))), Gl=(new A).e("ABS",K(function(){return function(){return(new fH).b()}}(this))),ai=(new A).e("ACOS",K(function(){return function(){return(new gH).b()}}(this))),lk=(new A).e("ALL?",K(function(){return function(){return(new hH).b()}}(this))),xh=(new A).e("AND",K(function(){return function(){return(new iH).b()}}(this))),Hl=(new A).e("ANY?",K(function(){return function(){return(new jH).b()}}(this))),Wi=(new A).e("APPROXIMATE-HSB",K(function(){return function(){return(new kH).b()}}(this))),mk=(new A).e("APPROXIMATE-RGB", K(function(){return function(){return(new lH).b()}}(this))),yh=(new A).e("ASIN",K(function(){return function(){return(new mH).b()}}(this))),Uf=(new A).e("AT-POINTS",K(function(){return function(){return(new nH).b()}}(this))),ue=(new A).e("ATAN",K(function(){return function(){return(new oH).b()}}(this))),zh=(new A).e("AUTOPLOT?",K(function(){return function(){return(new pH).b()}}(this))),bi=(new A).e("BASE-COLORS",K(function(){return function(){return(new qH).b()}}(this))),nk=(new A).e("BEHAVIORSPACE-RUN-NUMBER", K(function(){return function(){return(new rH).b()}}(this))),Xi=(new A).e("BF",K(function(){return function(){return(new sH).b()}}(this))),Il=(new A).e("BL",K(function(){return function(){return(new tH).b()}}(this))),Yi=(new A).e("BOTH-ENDS",K(function(){return function(){return(new uH).b()}}(this))),Jl=(new A).e("BUT-FIRST",K(function(){return function(){return(new sH).b()}}(this))),Zi=(new A).e("BUT-LAST",K(function(){return function(){return(new tH).b()}}(this))),$i=(new A).e("BUTFIRST",K(function(){return function(){return(new sH).b()}}(this))), ok=(new A).e("BUTLAST",K(function(){return function(){return(new tH).b()}}(this))),Kl=(new A).e("CAN-MOVE?",K(function(){return function(){return(new vH).b()}}(this))),aj=(new A).e("CEILING",K(function(){return function(){return(new wH).b()}}(this))),ci=(new A).e("COS",K(function(){return function(){return(new xH).b()}}(this))),Ll=(new A).e("COUNT",K(function(){return function(){return(new yH).b()}}(this))),Rg=(new A).e("DATE-AND-TIME",K(function(){return function(){return(new zH).b()}}(this))),Sg= (new A).e("DISTANCE",K(function(){return function(){return(new AH).b()}}(this))),pk=(new A).e("DISTANCEXY",K(function(){return function(){return(new BH).b()}}(this))),bj=(new A).e("DX",K(function(){return function(){return(new CH).b()}}(this))),Ah=(new A).e("DY",K(function(){return function(){return(new DH).b()}}(this))),qk=(new A).e("EMPTY?",K(function(){return function(){return(new EH).b()}}(this))),Ml=(new A).e("ERROR-MESSAGE",K(function(){return function(){return(new FH).b()}}(this))),rk=(new A).e("EXP", K(function(){return function(){return(new GH).b()}}(this))),Tg=(new A).e("EXTRACT-HSB",K(function(){return function(){return(new HH).b()}}(this))),Nl=(new A).e("EXTRACT-RGB",K(function(){return function(){return(new IH).b()}}(this))),cj=(new A).e("FILE-AT-END?",K(function(){return function(){return(new JH).b()}}(this))),di=(new A).e("FILE-EXISTS?",K(function(){return function(){return(new KH).b()}}(this))),Bh=(new A).e("FILE-READ",K(function(){return function(){return(new LH).b()}}(this))),Ol=(new A).e("FILE-READ-CHARACTERS", K(function(){return function(){return(new MH).b()}}(this))),qg=(new A).e("FILE-READ-LINE",K(function(){return function(){return(new NH).b()}}(this))),fi=(new A).e("FILTER",K(function(){return function(){return(new OH).b()}}(this))),Ch=(new A).e("FIRST",K(function(){return function(){return(new PH).b()}}(this))),dj=(new A).e("FLOOR",K(function(){return function(){return(new QH).b()}}(this))),Ug=(new A).e("FPUT",K(function(){return function(){return(new RH).b()}}(this))),ej=(new A).e("HSB",K(function(){return function(){return(new SH).b()}}(this))), fj=(new A).e("HUBNET-CLIENTS-LIST",K(function(){return function(){return(new TH).b()}}(this))),gi=(new A).e("HUBNET-ENTER-MESSAGE?",K(function(){return function(){return(new UH).b()}}(this))),hi=(new A).e("HUBNET-EXIT-MESSAGE?",K(function(){return function(){return(new VH).b()}}(this))),gj=(new A).e("HUBNET-MESSAGE",K(function(){return function(){return(new WH).b()}}(this))),Vf=(new A).e("HUBNET-MESSAGE-SOURCE",K(function(){return function(){return(new XH).b()}}(this))),vf=(new A).e("HUBNET-MESSAGE-TAG", K(function(){return function(){return(new YH).b()}}(this))),ae=(new A).e("HUBNET-MESSAGE-WAITING?",K(function(){return function(){return(new ZH).b()}}(this))),hj=(new A).e("IFELSE-VALUE",K(function(){return function(){return(new $H).b()}}(this))),rg=(new A).e("IN-CONE",K(function(){return function(){return(new aI).b()}}(this))),ij=(new A).e("IN-LINK-FROM",K(function(){return function(){return(new iG).b()}}(this))),jj=(new A).e("IN-LINK-NEIGHBOR?",K(function(){return function(){return(new jG).b()}}(this))), ii=(new A).e("IN-LINK-NEIGHBORS",K(function(){return function(){return(new kG).b()}}(this))),ji=(new A).e("IN-RADIUS",K(function(){return function(){return(new bI).b()}}(this))),Pl=(new A).e("INSERT-ITEM",K(function(){return function(){return(new cI).b()}}(this))),sk=(new A).e("INT",K(function(){return function(){return(new dI).b()}}(this))),Vg=(new A).e("IS-AGENT?",K(function(){return function(){return(new eI).b()}}(this))),ki=(new A).e("IS-AGENTSET?",K(function(){return function(){return(new fI).b()}}(this))), Ql=(new A).e("IS-ANONYMOUS-COMMAND?",K(function(){return function(){return(new gI).b()}}(this))),tk=(new A).e("IS-ANONYMOUS-REPORTER?",K(function(){return function(){return(new hI).b()}}(this))),ei=(new A).e("IS-BOOLEAN?",K(function(){return function(){return(new iI).b()}}(this))),qF=(new A).e("IS-DIRECTED-LINK?",K(function(){return function(){return(new jI).b()}}(this))),xw=(new A).e("IS-LINK-SET?",K(function(){return function(){return(new kI).b()}}(this))),cx=(new A).e("IS-LINK?",K(function(){return function(){return(new lI).b()}}(this))), WF=(new A).e("IS-LIST?",K(function(){return function(){return(new mI).b()}}(this))),wr=(new A).e("IS-NUMBER?",K(function(){return function(){return(new nI).b()}}(this))),dx=(new A).e("IS-PATCH-SET?",K(function(){return function(){return(new oI).b()}}(this))),vk=(new A).e("IS-PATCH?",K(function(){return function(){return(new pI).b()}}(this))),Bn=(new A).e("IS-STRING?",K(function(){return function(){return(new qI).b()}}(this))),am=(new A).e("IS-TURTLE-SET?",K(function(){return function(){return(new rI).b()}}(this))), ex=(new A).e("IS-TURTLE?",K(function(){return function(){return(new sI).b()}}(this))),xr=(new A).e("IS-UNDIRECTED-LINK?",K(function(){return function(){return(new tI).b()}}(this))),Cn=(new A).e("ITEM",K(function(){return function(){return(new uI).b()}}(this))),wk=(new A).e("LAST",K(function(){return function(){return(new vI).b()}}(this))),YF=(new A).e("LENGTH",K(function(){return function(){return(new wI).b()}}(this))),yr=(new A).e("LINK",K(function(){return function(){return(new xI).b()}}(this))), bm=(new A).e("LINK-HEADING",K(function(){return function(){return(new yI).b()}}(this))),zr=(new A).e("LINK-LENGTH",K(function(){return function(){return(new zI).b()}}(this))),ZF=(new A).e("LINK-NEIGHBOR?",K(function(){return function(){return(new oG).b()}}(this))),$F=(new A).e("LINK-NEIGHBORS",K(function(){return function(){return(new pG).b()}}(this))),Dn=(new A).e("LINK-SET",K(function(){return function(){return(new AI).b()}}(this))),aG=(new A).e("LINK-SHAPES",K(function(){return function(){return(new BI).b()}}(this))), e7=(new A).e("LINK-WITH",K(function(){return function(){return(new qG).b()}}(this))),f7=(new A).e("LINKS",K(function(){return function(){return(new CI).b()}}(this))),h7=(new A).e("LIST",K(function(){return function(){return(new DI).b()}}(this))),i7=(new A).e("LN",K(function(){return function(){return(new EI).b()}}(this))),j7=(new A).e("LOG",K(function(){return function(){return(new FI).b()}}(this))),k7=(new A).e("LPUT",K(function(){return function(){return(new GI).b()}}(this))),HG=(new A).e("MAP", K(function(){return function(){return(new HI).b()}}(this))),l7=(new A).e("MAX",K(function(){return function(){return(new II).b()}}(this))),m7=(new A).e("MAX-N-OF",K(function(){return function(){return(new JI).b()}}(this))),o7=(new A).e("MAX-ONE-OF",K(function(){return function(){return(new KI).b()}}(this))),p7=(new A).e("MAX-PXCOR",K(function(){return function(){return(new LI).b()}}(this))),q7=(new A).e("MAX-PYCOR",K(function(){return function(){return(new MI).b()}}(this))),GZ=(new A).e("MEAN",K(function(){return function(){return(new NI).b()}}(this))), Lr=(new A).e("MEDIAN",K(function(){return function(){return(new OI).b()}}(this))),r7=(new A).e("MEMBER?",K(function(){return function(){return(new PI).b()}}(this))),IG=(new A).e("MIN",K(function(){return function(){return(new QI).b()}}(this))),s7=(new A).e("MIN-N-OF",K(function(){return function(){return(new RI).b()}}(this))),t7=(new A).e("MIN-ONE-OF",K(function(){return function(){return(new SI).b()}}(this))),u7=(new A).e("MIN-PXCOR",K(function(){return function(){return(new TI).b()}}(this))),v7= (new A).e("MIN-PYCOR",K(function(){return function(){return(new UI).b()}}(this))),w7=(new A).e("MOD",K(function(){return function(){return(new VI).b()}}(this))),x7=(new A).e("MODES",K(function(){return function(){return(new WI).b()}}(this))),HZ=(new A).e("MOUSE-DOWN?",K(function(){return function(){return(new XI).b()}}(this))),y7=(new A).e("MOUSE-INSIDE?",K(function(){return function(){return(new YI).b()}}(this))),z7=(new A).e("MOUSE-XCOR",K(function(){return function(){return(new ZI).b()}}(this))), A7=(new A).e("MOUSE-YCOR",K(function(){return function(){return(new $I).b()}}(this))),B7=(new A).e("MY-IN-LINKS",K(function(){return function(){return(new rG).b()}}(this))),kBa=(new A).e("MY-LINKS",K(function(){return function(){return(new sG).b()}}(this))),lBa=(new A).e("MY-OUT-LINKS",K(function(){return function(){return(new tG).b()}}(this))),mBa=(new A).e("MYSELF",K(function(){return function(){return(new aJ).b()}}(this))),nBa=(new A).e("N-OF",K(function(){return function(){return(new bJ).b()}}(this))), oBa=(new A).e("N-VALUES",K(function(){return function(){return(new cJ).b()}}(this))),pBa=(new A).e("NEIGHBORS",K(function(){return function(){return(new dJ).b()}}(this))),qBa=(new A).e("NEIGHBORS4",K(function(){return function(){return(new eJ).b()}}(this))),rBa=(new A).e("NETLOGO-APPLET?",K(function(){return function(){return(new fJ).b()}}(this))),sBa=(new A).e("NETLOGO-VERSION",K(function(){return function(){return(new gJ).b()}}(this))),tBa=(new A).e("NETLOGO-WEB?",K(function(){return function(){return(new hJ).b()}}(this))), uBa=(new A).e("NEW-SEED",K(function(){return function(){return(new iJ).b()}}(this))),vBa=(new A).e("NO-LINKS",K(function(){return function(){return(new jJ).b()}}(this))),wBa=(new A).e("NO-PATCHES",K(function(){return function(){return(new kJ).b()}}(this))),xBa=(new A).e("NO-TURTLES",K(function(){return function(){return(new lJ).b()}}(this))),yBa=(new A).e("NOT",K(function(){return function(){return(new mJ).b()}}(this))),zBa=(new A).e("OF",K(function(){return function(){return(new nJ).b()}}(this))), ABa=(new A).e("ONE-OF",K(function(){return function(){return(new oJ).b()}}(this))),BBa=(new A).e("OR",K(function(){return function(){return(new pJ).b()}}(this))),CBa=(new A).e("OTHER",K(function(){return function(){return(new qJ).b()}}(this))),DBa=(new A).e("OTHER-END",K(function(){return function(){return(new rJ).b()}}(this))),EBa=(new A).e("OUT-LINK-NEIGHBOR?",K(function(){return function(){return(new uG).b()}}(this))),FBa=(new A).e("OUT-LINK-NEIGHBORS",K(function(){return function(){return(new vG).b()}}(this))), GBa=(new A).e("OUT-LINK-TO",K(function(){return function(){return(new wG).b()}}(this))),HBa=(new A).e("PATCH",K(function(){return function(){return(new sJ).b()}}(this))),IBa=(new A).e("PATCH-AHEAD",K(function(){return function(){return(new tJ).b()}}(this))),JBa=(new A).e("PATCH-AT",K(function(){return function(){return(new uJ).b()}}(this))),KBa=(new A).e("PATCH-AT-HEADING-AND-DISTANCE",K(function(){return function(){return(new vJ).b()}}(this))),LBa=(new A).e("PATCH-HERE",K(function(){return function(){return(new wJ).b()}}(this))), MBa=(new A).e("PATCH-LEFT-AND-AHEAD",K(function(){return function(){return(new xJ).b()}}(this))),NBa=(new A).e("PATCH-RIGHT-AND-AHEAD",K(function(){return function(){return(new yJ).b()}}(this))),OBa=(new A).e("PATCH-SET",K(function(){return function(){return(new zJ).b()}}(this))),PBa=(new A).e("PATCH-SIZE",K(function(){return function(){return(new AJ).b()}}(this))),QBa=(new A).e("PATCHES",K(function(){return function(){return(new BJ).b()}}(this))),RBa=(new A).e("PLOT-NAME",K(function(){return function(){return(new CJ).b()}}(this))), SBa=(new A).e("PLOT-PEN-EXISTS?",K(function(){return function(){return(new DJ).b()}}(this))),TBa=(new A).e("PLOT-X-MAX",K(function(){return function(){return(new EJ).b()}}(this))),UBa=(new A).e("PLOT-X-MIN",K(function(){return function(){return(new FJ).b()}}(this))),VBa=(new A).e("PLOT-Y-MAX",K(function(){return function(){return(new GJ).b()}}(this))),WBa=(new A).e("PLOT-Y-MIN",K(function(){return function(){return(new HJ).b()}}(this))),XBa=(new A).e("POSITION",K(function(){return function(){return(new IJ).b()}}(this))), YBa=(new A).e("PRECISION",K(function(){return function(){return(new JJ).b()}}(this))),ZBa=(new A).e("RANDOM",K(function(){return function(){return(new KJ).b()}}(this))),$Ba=(new A).e("RANDOM-EXPONENTIAL",K(function(){return function(){return(new LJ).b()}}(this))),aCa=(new A).e("RANDOM-FLOAT",K(function(){return function(){return(new MJ).b()}}(this))),bCa=(new A).e("RANDOM-GAMMA",K(function(){return function(){return(new NJ).b()}}(this))),cCa=(new A).e("RANDOM-NORMAL",K(function(){return function(){return(new OJ).b()}}(this))), dCa=(new A).e("RANDOM-POISSON",K(function(){return function(){return(new PJ).b()}}(this))),eCa=(new A).e("RANDOM-PXCOR",K(function(){return function(){return(new QJ).b()}}(this))),fCa=(new A).e("RANDOM-PYCOR",K(function(){return function(){return(new RJ).b()}}(this))),gCa=(new A).e("RANDOM-XCOR",K(function(){return function(){return(new SJ).b()}}(this))),hCa=(new A).e("RANDOM-YCOR",K(function(){return function(){return(new TJ).b()}}(this))),iCa=(new A).e("RANGE",K(function(){return function(){return(new UJ).b()}}(this))), jCa=(new A).e("READ-FROM-STRING",K(function(){return function(){return(new VJ).b()}}(this))),kCa=(new A).e("REDUCE",K(function(){return function(){return(new WJ).b()}}(this))),lCa=(new A).e("REMAINDER",K(function(){return function(){return(new XJ).b()}}(this))),mCa=(new A).e("REMOVE",K(function(){return function(){return(new YJ).b()}}(this))),nCa=(new A).e("REMOVE-DUPLICATES",K(function(){return function(){return(new ZJ).b()}}(this))),oCa=(new A).e("REMOVE-ITEM",K(function(){return function(){return(new $J).b()}}(this))), pCa=(new A).e("REPLACE-ITEM",K(function(){return function(){return(new aK).b()}}(this))),qCa=(new A).e("REVERSE",K(function(){return function(){return(new bK).b()}}(this))),rCa=(new A).e("RGB",K(function(){return function(){return(new cK).b()}}(this))),sCa=(new A).e("ROUND",K(function(){return function(){return(new dK).b()}}(this))),tCa=(new A).e("RUN-RESULT",K(function(){return function(){return(new eK).b()}}(this))),uCa=(new A).e("RUNRESULT",K(function(){return function(){return(new eK).b()}}(this))), vCa=(new A).e("SCALE-COLOR",K(function(){return function(){return(new fK).b()}}(this))),wCa=(new A).e("SE",K(function(){return function(){return(new gK).b()}}(this))),xCa=(new A).e("SELF",K(function(){return function(){return(new hK).b()}}(this))),yCa=(new A).e("SENTENCE",K(function(){return function(){return(new gK).b()}}(this))),zCa=(new A).e("SHADE-OF?",K(function(){return function(){return(new iK).b()}}(this))),ACa=(new A).e("SHAPES",K(function(){return function(){return(new jK).b()}}(this))), BCa=(new A).e("SHUFFLE",K(function(){return function(){return(new kK).b()}}(this))),CCa=(new A).e("SIN",K(function(){return function(){return(new lK).b()}}(this))),DCa=(new A).e("SORT",K(function(){return function(){return(new mK).b()}}(this))),ECa=(new A).e("SORT-BY",K(function(){return function(){return(new nK).b()}}(this))),FCa=(new A).e("SORT-ON",K(function(){return function(){return(new oK).b()}}(this))),GCa=(new A).e("SQRT",K(function(){return function(){return(new pK).b()}}(this))),HCa=(new A).e("STANDARD-DEVIATION", K(function(){return function(){return(new qK).b()}}(this))),ICa=(new A).e("SUBJECT",K(function(){return function(){return(new rK).b()}}(this))),JCa=(new A).e("SUBLIST",K(function(){return function(){return(new sK).b()}}(this))),KCa=(new A).e("SUBSTRING",K(function(){return function(){return(new tK).b()}}(this))),LCa=(new A).e("SUBTRACT-HEADINGS",K(function(){return function(){return(new uK).b()}}(this))),MCa=(new A).e("SUM",K(function(){return function(){return(new vK).b()}}(this))),NCa=(new A).e("TAN", K(function(){return function(){return(new wK).b()}}(this))),OCa=(new A).e("TICKS",K(function(){return function(){return(new xK).b()}}(this))),PCa=(new A).e("TIMER",K(function(){return function(){return(new yK).b()}}(this))),QCa=(new A).e("TOWARDS",K(function(){return function(){return(new zK).b()}}(this))),RCa=(new A).e("TOWARDSXY",K(function(){return function(){return(new AK).b()}}(this))),SCa=(new A).e("TURTLE",K(function(){return function(){return(new BK).b()}}(this))),TCa=(new A).e("TURTLE-SET", K(function(){return function(){return(new CK).b()}}(this))),UCa=(new A).e("TURTLES",K(function(){return function(){return(new DK).b()}}(this))),VCa=(new A).e("TURTLES-AT",K(function(){return function(){return(new EK).b()}}(this))),WCa=(new A).e("TURTLES-HERE",K(function(){return function(){return(new FK).b()}}(this))),XCa=(new A).e("TURTLES-ON",K(function(){return function(){return(new GK).b()}}(this))),YCa=(new A).e("USER-DIRECTORY",K(function(){return function(){return(new HK).b()}}(this))),ZCa= (new A).e("USER-FILE",K(function(){return function(){return(new IK).b()}}(this))),$Ca=(new A).e("USER-INPUT",K(function(){return function(){return(new JK).b()}}(this))),aDa=(new A).e("USER-NEW-FILE",K(function(){return function(){return(new KK).b()}}(this))),bDa=(new A).e("USER-ONE-OF",K(function(){return function(){return(new LK).b()}}(this))),cDa=(new A).e("USER-YES-OR-NO?",K(function(){return function(){return(new MK).b()}}(this))),dDa=(new A).e("VARIANCE",K(function(){return function(){return(new NK).b()}}(this))), eDa=(new A).e("WITH",K(function(){return function(){return(new OK).b()}}(this))),fDa=(new A).e("WITH-MAX",K(function(){return function(){return(new PK).b()}}(this))),gDa=(new A).e("WITH-MIN",K(function(){return function(){return(new QK).b()}}(this))),hDa=(new A).e("WORD",K(function(){return function(){return(new RK).b()}}(this))),iDa=(new A).e("WORLD-HEIGHT",K(function(){return function(){return(new SK).b()}}(this))),jDa=(new A).e("WORLD-WIDTH",K(function(){return function(){return(new TK).b()}}(this))), kDa=(new A).e("WRAP-COLOR",K(function(){return function(){return(new UK).b()}}(this)));this.ij=nh(pg,(new w).f([Yh,Ri,fk,Si,gk,Ti,vl,Ui,hk,Vi,wl,vh,xl,wh,ik,yl,Zh,$h,zl,Al,Bl,jk,Cl,Dl,El,Fl,kk,Gl,ai,lk,xh,Hl,Wi,mk,yh,Uf,ue,zh,bi,nk,Xi,Il,Yi,Jl,Zi,$i,ok,Kl,aj,ci,Ll,Rg,Sg,pk,bj,Ah,qk,Ml,rk,Tg,Nl,cj,di,Bh,Ol,qg,fi,Ch,dj,Ug,ej,fj,gi,hi,gj,Vf,vf,ae,hj,rg,ij,jj,ii,ji,Pl,sk,Vg,ki,Ql,tk,ei,qF,xw,cx,WF,wr,dx,vk,Bn,am,ex,xr,Cn,wk,YF,yr,bm,zr,ZF,$F,Dn,aG,e7,f7,h7,i7,j7,k7,HG,l7,m7,o7,p7,q7,GZ,Lr,r7,IG,s7,t7, u7,v7,w7,x7,HZ,y7,z7,A7,B7,kBa,lBa,mBa,nBa,oBa,pBa,qBa,rBa,sBa,tBa,uBa,vBa,wBa,xBa,yBa,zBa,ABa,BBa,CBa,DBa,EBa,FBa,GBa,HBa,IBa,JBa,KBa,LBa,MBa,NBa,OBa,PBa,QBa,RBa,SBa,TBa,UBa,VBa,WBa,XBa,YBa,ZBa,$Ba,aCa,bCa,cCa,dCa,eCa,fCa,gCa,hCa,iCa,jCa,kCa,lCa,mCa,nCa,oCa,pCa,qCa,rCa,sCa,tCa,uCa,vCa,wCa,xCa,yCa,zCa,ACa,BCa,CCa,DCa,ECa,FCa,GCa,HCa,ICa,JCa,KCa,LCa,MCa,NCa,OCa,PCa,QCa,RCa,SCa,TCa,UCa,VCa,WCa,XCa,YCa,ZCa,$Ca,aDa,bDa,cDa,dDa,eDa,fDa,gDa,hDa,iDa,jDa,kDa,(new A).e("XOR",K(function(){return function(){return(new VK).b()}}(this)))])); this.a=(2|this.a)<<24>>24;var lDa=$e().kk,mDa=(new A).e("__APPLY",K(function(){return function(){return(new WK).b()}}(this))),nDa=(new A).e("__BENCH",K(function(){return function(){return(new XK).b()}}(this))),oDa=(new A).e("__CHANGE-TOPOLOGY",K(function(){return function(){return(new YK).b()}}(this))),pDa=(new A).e("__DONE",K(function(){return function(){return(new ZK).b()}}(this))),qDa=(new A).e("__EXPERIMENTSTEPEND",K(function(){return function(){return(new $K).b()}}(this))),rDa=(new A).e("__EXPORT-DRAWING", K(function(){return function(){return(new aL).b()}}(this))),sDa=(new A).e("__FOREVERBUTTONEND",K(function(){return function(){return(new bL).b()}}(this))),tDa=(new A).e("__IGNORE",K(function(){return function(){return(new cL).b()}}(this))),uDa=(new A).e("__LET",K(function(){return function(){return(new dL).b()}}(this))),vDa=(new A).e("__LINKCODE",K(function(){return function(){return(new eL).b()}}(this))),wDa=(new A).e("__MKDIR",K(function(){return function(){return(new fL).b()}}(this))),xDa=(new A).e("__OBSERVERCODE", K(function(){return function(){return(new gL).b()}}(this))),yDa=(new A).e("__PATCHCODE",K(function(){return function(){return(new hL).b()}}(this))),zDa=(new A).e("__PLOT-PEN-HIDE",K(function(){return function(){return(new iL).b()}}(this))),ADa=(new A).e("__PLOT-PEN-SHOW",K(function(){return function(){return(new jL).b()}}(this))),BDa=(new A).e("__PWD",K(function(){return function(){return(new kL).b()}}(this))),CDa=(new A).e("__RELOAD-EXTENSIONS",K(function(){return function(){return(new lL).b()}}(this))), DDa=(new A).e("__SET-LINE-THICKNESS",K(function(){return function(){return(new mL).b()}}(this))),EDa=(new A).e("__STDERR",K(function(){return function(){return(new nL).b()}}(this))),FDa=(new A).e("__STDOUT",K(function(){return function(){return(new oL).b()}}(this))),GDa=(new A).e("__THUNK-DID-FINISH",K(function(){return function(){return(new pL).b()}}(this))),HDa=(new A).e("__TURTLECODE",K(function(){return function(){return(new qL).b()}}(this))),IDa=(new A).e("ASK",K(function(){return function(){return(new rL).b()}}(this))), JDa=(new A).e("ASK-CONCURRENT",K(function(){return function(){return(new sL).b()}}(this))),KDa=(new A).e("AUTO-PLOT-OFF",K(function(){return function(){return(new tL).b()}}(this))),LDa=(new A).e("AUTO-PLOT-ON",K(function(){return function(){return(new uL).b()}}(this))),MDa=(new A).e("BACK",K(function(){return function(){return(new vL).b()}}(this))),NDa=(new A).e("BEEP",K(function(){return function(){return(new wL).b()}}(this))),ODa=(new A).e("BK",K(function(){return function(){return(new vL).b()}}(this))), PDa=(new A).e("CA",K(function(){return function(){return(new xL).b()}}(this))),QDa=(new A).e("CAREFULLY",K(function(){return function(){return(new yL).b()}}(this))),RDa=(new A).e("CD",K(function(){return function(){return(new zL).b()}}(this))),SDa=(new A).e("CLEAR-ALL",K(function(){return function(){return(new xL).b()}}(this))),TDa=(new A).e("CLEAR-ALL-PLOTS",K(function(){return function(){return(new AL).b()}}(this))),UDa=(new A).e("CLEAR-DRAWING",K(function(){return function(){return(new zL).b()}}(this))), VDa=(new A).e("CLEAR-GLOBALS",K(function(){return function(){return(new BL).b()}}(this))),WDa=(new A).e("CLEAR-LINKS",K(function(){return function(){return(new CL).b()}}(this))),XDa=(new A).e("CLEAR-OUTPUT",K(function(){return function(){return(new DL).b()}}(this))),YDa=(new A).e("CLEAR-PATCHES",K(function(){return function(){return(new EL).b()}}(this))),ZDa=(new A).e("CLEAR-PLOT",K(function(){return function(){return(new FL).b()}}(this))),$Da=(new A).e("CLEAR-TICKS",K(function(){return function(){return(new GL).b()}}(this))), aEa=(new A).e("CLEAR-TURTLES",K(function(){return function(){return(new HL).b()}}(this))),bEa=(new A).e("CP",K(function(){return function(){return(new EL).b()}}(this))),cEa=(new A).e("CREATE-LINK-FROM",K(function(){return function(){return(new zG).b()}}(this))),dEa=(new A).e("CREATE-LINK-TO",K(function(){return function(){return(new yG).b()}}(this))),eEa=(new A).e("CREATE-LINK-WITH",K(function(){return function(){return(new xG).b()}}(this))),fEa=(new A).e("CREATE-LINKS-FROM",K(function(){return function(){return(new CG).b()}}(this))), gEa=(new A).e("CREATE-LINKS-TO",K(function(){return function(){return(new BG).b()}}(this))),hEa=(new A).e("CREATE-LINKS-WITH",K(function(){return function(){return(new AG).b()}}(this))),iEa=(new A).e("CREATE-ORDERED-TURTLES",K(function(){return function(){return(new VF).b()}}(this))),jEa=(new A).e("CREATE-TEMPORARY-PLOT-PEN",K(function(){return function(){return(new IL).b()}}(this))),kEa=(new A).e("CREATE-TURTLES",K(function(){return function(){return(new XF).b()}}(this))),lEa=(new A).e("CRO",K(function(){return function(){return(new VF).b()}}(this))), mEa=(new A).e("CRT",K(function(){return function(){return(new XF).b()}}(this))),nEa=(new A).e("CT",K(function(){return function(){return(new HL).b()}}(this))),oEa=(new A).e("DIE",K(function(){return function(){return(new JL).b()}}(this))),pEa=(new A).e("DIFFUSE",K(function(){return function(){return(new KL).b()}}(this))),qEa=(new A).e("DIFFUSE4",K(function(){return function(){return(new LL).b()}}(this))),rEa=(new A).e("DISPLAY",K(function(){return function(){return(new ML).b()}}(this))),sEa=(new A).e("DOWNHILL", K(function(){return function(){return(new NL).b()}}(this))),tEa=(new A).e("DOWNHILL4",K(function(){return function(){return(new OL).b()}}(this))),uEa=(new A).e("ERROR",K(function(){return function(){return(new PL).b()}}(this))),vEa=(new A).e("EVERY",K(function(){return function(){return(new QL).b()}}(this))),wEa=(new A).e("EXPORT-ALL-PLOTS",K(function(){return function(){return(new RL).b()}}(this))),xEa=(new A).e("EXPORT-INTERFACE",K(function(){return function(){return(new SL).b()}}(this))),yEa=(new A).e("EXPORT-OUTPUT", K(function(){return function(){return(new TL).b()}}(this))),zEa=(new A).e("EXPORT-PLOT",K(function(){return function(){return(new UL).b()}}(this))),AEa=(new A).e("EXPORT-VIEW",K(function(){return function(){return(new VL).b()}}(this))),BEa=(new A).e("EXPORT-WORLD",K(function(){return function(){return(new WL).b()}}(this))),CEa=(new A).e("FACE",K(function(){return function(){return(new XL).b()}}(this))),DEa=(new A).e("FACEXY",K(function(){return function(){return(new YL).b()}}(this))),EEa=(new A).e("FD", K(function(){return function(){return(new ZL).b()}}(this))),FEa=(new A).e("FILE-CLOSE",K(function(){return function(){return(new $L).b()}}(this))),GEa=(new A).e("FILE-CLOSE-ALL",K(function(){return function(){return(new aM).b()}}(this))),HEa=(new A).e("FILE-DELETE",K(function(){return function(){return(new bM).b()}}(this))),IEa=(new A).e("FILE-FLUSH",K(function(){return function(){return(new cM).b()}}(this))),JEa=(new A).e("FILE-OPEN",K(function(){return function(){return(new dM).b()}}(this))),KEa= (new A).e("FILE-PRINT",K(function(){return function(){return(new eM).b()}}(this))),LEa=(new A).e("FILE-SHOW",K(function(){return function(){return(new fM).b()}}(this))),MEa=(new A).e("FILE-TYPE",K(function(){return function(){return(new gM).b()}}(this))),NEa=(new A).e("FILE-WRITE",K(function(){return function(){return(new hM).b()}}(this))),OEa=(new A).e("FOLLOW",K(function(){return function(){return(new iM).b()}}(this))),PEa=(new A).e("FOLLOW-ME",K(function(){return function(){return(new jM).b()}}(this))), QEa=(new A).e("FOREACH",K(function(){return function(){return(new kM).b()}}(this))),REa=(new A).e("FORWARD",K(function(){return function(){return(new ZL).b()}}(this))),SEa=(new A).e("HATCH",K(function(){return function(){return(new bG).b()}}(this))),TEa=(new A).e("HIDE-LINK",K(function(){return function(){return(new lM).b()}}(this))),UEa=(new A).e("HIDE-TURTLE",K(function(){return function(){return(new mM).b()}}(this))),VEa=(new A).e("HISTOGRAM",K(function(){return function(){return(new nM).b()}}(this))), WEa=(new A).e("HOME",K(function(){return function(){return(new oM).b()}}(this))),XEa=(new A).e("HT",K(function(){return function(){return(new mM).b()}}(this))),YEa=(new A).e("HUBNET-BROADCAST",K(function(){return function(){return(new pM).b()}}(this))),ZEa=(new A).e("HUBNET-BROADCAST-CLEAR-OUTPUT",K(function(){return function(){return(new qM).b()}}(this))),$Ea=(new A).e("HUBNET-BROADCAST-MESSAGE",K(function(){return function(){return(new rM).b()}}(this))),aFa=(new A).e("HUBNET-CLEAR-OVERRIDE",K(function(){return function(){return(new sM).b()}}(this))), bFa=(new A).e("HUBNET-CLEAR-OVERRIDES",K(function(){return function(){return(new tM).b()}}(this))),cFa=(new A).e("HUBNET-FETCH-MESSAGE",K(function(){return function(){return(new uM).b()}}(this))),dFa=(new A).e("HUBNET-KICK-ALL-CLIENTS",K(function(){return function(){return(new vM).b()}}(this))),eFa=(new A).e("HUBNET-KICK-CLIENT",K(function(){return function(){return(new wM).b()}}(this))),fFa=(new A).e("HUBNET-RESET",K(function(){return function(){return(new xM).b()}}(this))),gFa=(new A).e("HUBNET-RESET-PERSPECTIVE", K(function(){return function(){return(new yM).b()}}(this))),hFa=(new A).e("HUBNET-SEND",K(function(){return function(){return(new zM).b()}}(this))),iFa=(new A).e("HUBNET-SEND-CLEAR-OUTPUT",K(function(){return function(){return(new AM).b()}}(this))),jFa=(new A).e("HUBNET-SEND-FOLLOW",K(function(){return function(){return(new BM).b()}}(this))),kFa=(new A).e("HUBNET-SEND-MESSAGE",K(function(){return function(){return(new CM).b()}}(this))),lFa=(new A).e("HUBNET-SEND-OVERRIDE",K(function(){return function(){return(new DM).b()}}(this))), mFa=(new A).e("HUBNET-SEND-WATCH",K(function(){return function(){return(new EM).b()}}(this))),nFa=(new A).e("IF",K(function(){return function(){return(new FM).b()}}(this))),oFa=(new A).e("IF-ELSE",K(function(){return function(){return(new GM).b()}}(this))),pFa=(new A).e("IFELSE",K(function(){return function(){return(new GM).b()}}(this))),qFa=(new A).e("IMPORT-DRAWING",K(function(){return function(){return(new HM).b()}}(this))),rFa=(new A).e("IMPORT-PCOLORS",K(function(){return function(){return(new IM).b()}}(this))), sFa=(new A).e("IMPORT-PCOLORS-RGB",K(function(){return function(){return(new JM).b()}}(this))),tFa=(new A).e("IMPORT-WORLD",K(function(){return function(){return(new KM).b()}}(this))),uFa=(new A).e("INSPECT",K(function(){return function(){return(new LM).b()}}(this))),vFa=(new A).e("JUMP",K(function(){return function(){return(new MM).b()}}(this))),wFa=(new A).e("LAYOUT-CIRCLE",K(function(){return function(){return(new NM).b()}}(this))),xFa=(new A).e("LAYOUT-RADIAL",K(function(){return function(){return(new OM).b()}}(this))), yFa=(new A).e("LAYOUT-SPRING",K(function(){return function(){return(new PM).b()}}(this))),zFa=(new A).e("LAYOUT-TUTTE",K(function(){return function(){return(new QM).b()}}(this))),AFa=(new A).e("LEFT",K(function(){return function(){return(new RM).b()}}(this))),BFa=(new A).e("LET",K(function(){return function(){return(new dL).b()}}(this))),CFa=(new A).e("LOOP",K(function(){return function(){return(new SM).b()}}(this))),DFa=(new A).e("LT",K(function(){return function(){return(new RM).b()}}(this))),EFa= (new A).e("MOVE-TO",K(function(){return function(){return(new TM).b()}}(this))),FFa=(new A).e("NO-DISPLAY",K(function(){return function(){return(new UM).b()}}(this))),GFa=(new A).e("OUTPUT-PRINT",K(function(){return function(){return(new VM).b()}}(this))),HFa=(new A).e("OUTPUT-SHOW",K(function(){return function(){return(new WM).b()}}(this))),IFa=(new A).e("OUTPUT-TYPE",K(function(){return function(){return(new XM).b()}}(this))),JFa=(new A).e("OUTPUT-WRITE",K(function(){return function(){return(new YM).b()}}(this))), KFa=(new A).e("PD",K(function(){return function(){return(new ZM).b()}}(this))),LFa=(new A).e("PE",K(function(){return function(){return(new $M).b()}}(this))),MFa=(new A).e("PEN-DOWN",K(function(){return function(){return(new ZM).b()}}(this))),NFa=(new A).e("PEN-ERASE",K(function(){return function(){return(new $M).b()}}(this))),OFa=(new A).e("PEN-UP",K(function(){return function(){return(new aN).b()}}(this))),PFa=(new A).e("PENDOWN",K(function(){return function(){return(new ZM).b()}}(this))),QFa=(new A).e("PENUP", K(function(){return function(){return(new aN).b()}}(this))),RFa=(new A).e("PLOT",K(function(){return function(){return(new bN).b()}}(this))),SFa=(new A).e("PLOT-PEN-DOWN",K(function(){return function(){return(new cN).b()}}(this))),TFa=(new A).e("PLOT-PEN-RESET",K(function(){return function(){return(new dN).b()}}(this))),UFa=(new A).e("PLOT-PEN-UP",K(function(){return function(){return(new eN).b()}}(this))),VFa=(new A).e("PLOTXY",K(function(){return function(){return(new fN).b()}}(this))),WFa=(new A).e("PRINT", K(function(){return function(){return(new gN).b()}}(this))),XFa=(new A).e("PU",K(function(){return function(){return(new aN).b()}}(this))),YFa=(new A).e("RANDOM-SEED",K(function(){return function(){return(new hN).b()}}(this))),ZFa=(new A).e("REPEAT",K(function(){return function(){return(new iN).b()}}(this))),$Fa=(new A).e("REPORT",K(function(){return function(){return(new jN).b()}}(this))),aGa=(new A).e("RESET-PERSPECTIVE",K(function(){return function(){return(new kN).b()}}(this))),bGa=(new A).e("RESET-TICKS", K(function(){return function(){return(new lN).b()}}(this))),cGa=(new A).e("RESET-TIMER",K(function(){return function(){return(new mN).b()}}(this))),dGa=(new A).e("RESIZE-WORLD",K(function(){return function(){return(new nN).b()}}(this))),eGa=(new A).e("RIDE",K(function(){return function(){return(new oN).b()}}(this))),fGa=(new A).e("RIDE-ME",K(function(){return function(){return(new pN).b()}}(this))),gGa=(new A).e("RIGHT",K(function(){return function(){return(new qN).b()}}(this))),hGa=(new A).e("RP", K(function(){return function(){return(new kN).b()}}(this))),iGa=(new A).e("RT",K(function(){return function(){return(new qN).b()}}(this))),jGa=(new A).e("RUN",K(function(){return function(){return(new rN).b()}}(this))),kGa=(new A).e("SET",K(function(){return function(){return(new sN).b()}}(this))),lGa=(new A).e("SET-CURRENT-DIRECTORY",K(function(){return function(){return(new tN).b()}}(this))),mGa=(new A).e("SET-CURRENT-PLOT",K(function(){return function(){return(new uN).b()}}(this))),nGa=(new A).e("SET-CURRENT-PLOT-PEN", K(function(){return function(){return(new vN).b()}}(this))),oGa=(new A).e("SET-DEFAULT-SHAPE",K(function(){return function(){return(new wN).b()}}(this))),pGa=(new A).e("SET-HISTOGRAM-NUM-BARS",K(function(){return function(){return(new xN).b()}}(this))),qGa=(new A).e("SET-PATCH-SIZE",K(function(){return function(){return(new yN).b()}}(this))),rGa=(new A).e("SET-PLOT-PEN-COLOR",K(function(){return function(){return(new zN).b()}}(this))),sGa=(new A).e("SET-PLOT-PEN-INTERVAL",K(function(){return function(){return(new AN).b()}}(this))), tGa=(new A).e("SET-PLOT-PEN-MODE",K(function(){return function(){return(new BN).b()}}(this))),uGa=(new A).e("SET-PLOT-X-RANGE",K(function(){return function(){return(new CN).b()}}(this))),vGa=(new A).e("SET-PLOT-Y-RANGE",K(function(){return function(){return(new DN).b()}}(this))),wGa=(new A).e("SETUP-PLOTS",K(function(){return function(){return(new EN).b()}}(this))),xGa=(new A).e("SETXY",K(function(){return function(){return(new FN).b()}}(this))),yGa=(new A).e("SHOW",K(function(){return function(){return(new GN).b()}}(this))), zGa=(new A).e("SHOW-LINK",K(function(){return function(){return(new HN).b()}}(this))),AGa=(new A).e("SHOW-TURTLE",K(function(){return function(){return(new IN).b()}}(this))),BGa=(new A).e("SPROUT",K(function(){return function(){return(new dG).b()}}(this))),CGa=(new A).e("ST",K(function(){return function(){return(new IN).b()}}(this))),DGa=(new A).e("STAMP",K(function(){return function(){return(new JN).b()}}(this))),EGa=(new A).e("STAMP-ERASE",K(function(){return function(){return(new KN).b()}}(this))), FGa=(new A).e("STOP",K(function(){return function(){return(new LN).b()}}(this))),GGa=(new A).e("STOP-INSPECTING",K(function(){return function(){return(new MN).b()}}(this))),HGa=(new A).e("STOP-INSPECTING-DEAD-AGENTS",K(function(){return function(){return(new NN).b()}}(this))),IGa=(new A).e("TICK",K(function(){return function(){return(new ON).b()}}(this))),JGa=(new A).e("TICK-ADVANCE",K(function(){return function(){return(new PN).b()}}(this))),KGa=(new A).e("TIE",K(function(){return function(){return(new QN).b()}}(this))), LGa=(new A).e("TYPE",K(function(){return function(){return(new RN).b()}}(this))),MGa=(new A).e("UNTIE",K(function(){return function(){return(new SN).b()}}(this))),NGa=(new A).e("UPDATE-PLOTS",K(function(){return function(){return(new TN).b()}}(this))),OGa=(new A).e("UPHILL",K(function(){return function(){return(new UN).b()}}(this))),PGa=(new A).e("UPHILL4",K(function(){return function(){return(new VN).b()}}(this))),QGa=(new A).e("USER-MESSAGE",K(function(){return function(){return(new WN).b()}}(this))), RGa=(new A).e("WAIT",K(function(){return function(){return(new XN).b()}}(this))),SGa=(new A).e("WATCH",K(function(){return function(){return(new YN).b()}}(this))),TGa=(new A).e("WATCH-ME",K(function(){return function(){return(new ZN).b()}}(this))),UGa=(new A).e("WHILE",K(function(){return function(){return(new $N).b()}}(this))),VGa=(new A).e("WITH-LOCAL-RANDOMNESS",K(function(){return function(){return(new aO).b()}}(this))),WGa=(new A).e("WITHOUT-INTERRUPTION",K(function(){return function(){return(new bO).b()}}(this))); this.Yi=nh(lDa,(new w).f([mDa,nDa,oDa,pDa,qDa,rDa,sDa,tDa,uDa,vDa,wDa,xDa,yDa,zDa,ADa,BDa,CDa,DDa,EDa,FDa,GDa,HDa,IDa,JDa,KDa,LDa,MDa,NDa,ODa,PDa,QDa,RDa,SDa,TDa,UDa,VDa,WDa,XDa,YDa,ZDa,$Da,aEa,bEa,cEa,dEa,eEa,fEa,gEa,hEa,iEa,jEa,kEa,lEa,mEa,nEa,oEa,pEa,qEa,rEa,sEa,tEa,uEa,vEa,wEa,xEa,yEa,zEa,AEa,BEa,CEa,DEa,EEa,FEa,GEa,HEa,IEa,JEa,KEa,LEa,MEa,NEa,OEa,PEa,QEa,REa,SEa,TEa,UEa,VEa,WEa,XEa,YEa,ZEa,$Ea,aFa,bFa,cFa,dFa,eFa,fFa,gFa,hFa,iFa,jFa,kFa,lFa,mFa,nFa,oFa,pFa,qFa,rFa,sFa,tFa,uFa,vFa,wFa,xFa,yFa, zFa,AFa,BFa,CFa,DFa,EFa,FFa,GFa,HFa,IFa,JFa,KFa,LFa,MFa,NFa,OFa,PFa,QFa,RFa,SFa,TFa,UFa,VFa,WFa,XFa,YFa,ZFa,$Fa,aGa,bGa,cGa,dGa,eGa,fGa,gGa,hGa,iGa,jGa,kGa,lGa,mGa,nGa,oGa,pGa,qGa,rGa,sGa,tGa,uGa,vGa,wGa,xGa,yGa,zGa,AGa,BGa,CGa,DGa,EGa,FGa,GGa,HGa,IGa,JGa,KGa,LGa,MGa,NGa,OGa,PGa,QGa,RGa,SGa,TGa,UGa,VGa,WGa,(new A).e("WRITE",K(function(){return function(){return(new cO).b()}}(this)))]));this.a=(4|this.a)<<24>>24;var XGa=$e().kk,YGa=I(r(),(new w).f(["__APPLY"])),ZGa=(new A).e("etc._apply",YGa),$Ga= I(r(),(new w).f(["__BENCH"])),aHa=(new A).e("etc._bench",$Ga),bHa=I(r(),(new w).f(["__CHANGE-TOPOLOGY"])),cHa=(new A).e("etc._changetopology",bHa),dHa=I(r(),(new w).f(["__DONE"])),eHa=(new A).e("_done",dHa),fHa=I(r(),(new w).f(["__EXPERIMENTSTEPEND"])),gHa=(new A).e("etc._experimentstepend",fHa),hHa=I(r(),(new w).f(["__EXPORT-DRAWING"])),iHa=(new A).e("etc._exportdrawing",hHa),jHa=I(r(),(new w).f(["__FOREVERBUTTONEND"])),kHa=(new A).e("etc._foreverbuttonend",jHa),lHa=I(r(),(new w).f(["__IGNORE"])), mHa=(new A).e("etc._ignore",lHa),nHa=I(r(),(new w).f(["__LET","LET"])),oHa=(new A).e("_let",nHa),pHa=I(r(),(new w).f(["__LINKCODE"])),qHa=(new A).e("etc._linkcode",pHa),rHa=I(r(),(new w).f(["__MKDIR"])),sHa=(new A).e("etc._mkdir",rHa),tHa=I(r(),(new w).f(["__OBSERVERCODE"])),uHa=(new A).e("etc._observercode",tHa),vHa=I(r(),(new w).f(["__PATCHCODE"])),wHa=(new A).e("etc._patchcode",vHa),xHa=I(r(),(new w).f(["__PLOT-PEN-HIDE"])),yHa=(new A).e("etc._plotpenhide",xHa),zHa=I(r(),(new w).f(["__PLOT-PEN-SHOW"])), AHa=(new A).e("etc._plotpenshow",zHa),BHa=I(r(),(new w).f(["__PWD"])),CHa=(new A).e("etc._pwd",BHa),DHa=I(r(),(new w).f(["__RELOAD-EXTENSIONS"])),EHa=(new A).e("etc._reloadextensions",DHa),FHa=I(r(),(new w).f(["__SET-LINE-THICKNESS"])),GHa=(new A).e("etc._setlinethickness",FHa),HHa=I(r(),(new w).f(["__STDERR"])),IHa=(new A).e("etc._stderr",HHa),JHa=I(r(),(new w).f(["__STDOUT"])),KHa=(new A).e("etc._stdout",JHa),LHa=I(r(),(new w).f(["__THUNK-DID-FINISH"])),MHa=(new A).e("etc._thunkdidfinish",LHa), NHa=I(r(),(new w).f(["__TURTLECODE"])),OHa=(new A).e("etc._turtlecode",NHa),PHa=I(r(),(new w).f(["ASK"])),QHa=(new A).e("_ask",PHa),RHa=I(r(),(new w).f(["ASK-CONCURRENT"])),SHa=(new A).e("_askconcurrent",RHa),THa=I(r(),(new w).f(["AUTO-PLOT-OFF"])),UHa=(new A).e("etc._autoplotoff",THa),VHa=I(r(),(new w).f(["AUTO-PLOT-ON"])),WHa=(new A).e("etc._autoploton",VHa),XHa=I(r(),(new w).f(["BACK","BK"])),YHa=(new A).e("_bk",XHa),ZHa=I(r(),(new w).f(["BEEP"])),$Ha=(new A).e("etc._beep",ZHa),aIa=I(r(),(new w).f(["BACK", "BK"])),bIa=(new A).e("_bk",aIa),cIa=I(r(),(new w).f(["CA","CLEAR-ALL"])),dIa=(new A).e("etc._clearall",cIa),eIa=I(r(),(new w).f(["CAREFULLY"])),fIa=(new A).e("_carefully",eIa),gIa=I(r(),(new w).f(["CD","CLEAR-DRAWING"])),hIa=(new A).e("etc._cleardrawing",gIa),iIa=I(r(),(new w).f(["CA","CLEAR-ALL"])),jIa=(new A).e("etc._clearall",iIa),kIa=I(r(),(new w).f(["CLEAR-ALL-PLOTS"])),lIa=(new A).e("etc._clearallplots",kIa),mIa=I(r(),(new w).f(["CD","CLEAR-DRAWING"])),nIa=(new A).e("etc._cleardrawing",mIa), oIa=I(r(),(new w).f(["CLEAR-GLOBALS"])),pIa=(new A).e("etc._clearglobals",oIa),qIa=I(r(),(new w).f(["CLEAR-LINKS"])),rIa=(new A).e("etc._clearlinks",qIa),sIa=I(r(),(new w).f(["CLEAR-OUTPUT"])),tIa=(new A).e("etc._clearoutput",sIa),uIa=I(r(),(new w).f(["CLEAR-PATCHES","CP"])),vIa=(new A).e("etc._clearpatches",uIa),wIa=I(r(),(new w).f(["CLEAR-PLOT"])),xIa=(new A).e("etc._clearplot",wIa),yIa=I(r(),(new w).f(["CLEAR-TICKS"])),zIa=(new A).e("etc._clearticks",yIa),AIa=I(r(),(new w).f(["CLEAR-TURTLES","CT"])), BIa=(new A).e("etc._clearturtles",AIa),CIa=I(r(),(new w).f(["CLEAR-PATCHES","CP"])),DIa=(new A).e("etc._clearpatches",CIa),EIa=I(r(),(new w).f(["CREATE-LINK-FROM"])),FIa=(new A).e("etc._createlinkfrom",EIa),GIa=I(r(),(new w).f(["CREATE-LINK-TO"])),HIa=(new A).e("etc._createlinkto",GIa),IIa=I(r(),(new w).f(["CREATE-LINK-WITH"])),JIa=(new A).e("etc._createlinkwith",IIa),KIa=I(r(),(new w).f(["CREATE-LINKS-FROM"])),LIa=(new A).e("etc._createlinksfrom",KIa),MIa=I(r(),(new w).f(["CREATE-LINKS-TO"])),NIa= (new A).e("etc._createlinksto",MIa),OIa=I(r(),(new w).f(["CREATE-LINKS-WITH"])),PIa=(new A).e("etc._createlinkswith",OIa),QIa=I(r(),(new w).f(["CREATE-ORDERED-TURTLES","CRO"])),RIa=(new A).e("_createorderedturtles",QIa),SIa=I(r(),(new w).f(["CREATE-TEMPORARY-PLOT-PEN"])),TIa=(new A).e("etc._createtemporaryplotpen",SIa),UIa=I(r(),(new w).f(["CREATE-TURTLES","CRT"])),VIa=(new A).e("_createturtles",UIa),WIa=I(r(),(new w).f(["CREATE-ORDERED-TURTLES","CRO"])),XIa=(new A).e("_createorderedturtles",WIa), YIa=I(r(),(new w).f(["CREATE-TURTLES","CRT"])),ZIa=(new A).e("_createturtles",YIa),$Ia=I(r(),(new w).f(["CLEAR-TURTLES","CT"])),aJa=(new A).e("etc._clearturtles",$Ia),bJa=I(r(),(new w).f(["DIE"])),cJa=(new A).e("etc._die",bJa),dJa=I(r(),(new w).f(["DIFFUSE"])),eJa=(new A).e("etc._diffuse",dJa),fJa=I(r(),(new w).f(["DIFFUSE4"])),gJa=(new A).e("etc._diffuse4",fJa),hJa=I(r(),(new w).f(["DISPLAY"])),iJa=(new A).e("etc._display",hJa),jJa=I(r(),(new w).f(["DOWNHILL"])),kJa=(new A).e("etc._downhill",jJa), lJa=I(r(),(new w).f(["DOWNHILL4"])),mJa=(new A).e("etc._downhill4",lJa),nJa=I(r(),(new w).f(["ERROR"])),oJa=(new A).e("etc._error",nJa),pJa=I(r(),(new w).f(["EVERY"])),qJa=(new A).e("etc._every",pJa),rJa=I(r(),(new w).f(["EXPORT-ALL-PLOTS"])),sJa=(new A).e("etc._exportplots",rJa),tJa=I(r(),(new w).f(["EXPORT-INTERFACE"])),uJa=(new A).e("etc._exportinterface",tJa),vJa=I(r(),(new w).f(["EXPORT-OUTPUT"])),wJa=(new A).e("etc._exportoutput",vJa),xJa=I(r(),(new w).f(["EXPORT-PLOT"])),yJa=(new A).e("etc._exportplot", xJa),zJa=I(r(),(new w).f(["EXPORT-VIEW"])),AJa=(new A).e("etc._exportview",zJa),BJa=I(r(),(new w).f(["EXPORT-WORLD"])),CJa=(new A).e("etc._exportworld",BJa),DJa=I(r(),(new w).f(["FACE"])),EJa=(new A).e("etc._face",DJa),FJa=I(r(),(new w).f(["FACEXY"])),GJa=(new A).e("etc._facexy",FJa),HJa=I(r(),(new w).f(["FD","FORWARD"])),IJa=(new A).e("_fd",HJa),JJa=I(r(),(new w).f(["FILE-CLOSE"])),KJa=(new A).e("etc._fileclose",JJa),LJa=I(r(),(new w).f(["FILE-CLOSE-ALL"])),MJa=(new A).e("etc._filecloseall",LJa), NJa=I(r(),(new w).f(["FILE-DELETE"])),OJa=(new A).e("etc._filedelete",NJa),PJa=I(r(),(new w).f(["FILE-FLUSH"])),QJa=(new A).e("etc._fileflush",PJa),RJa=I(r(),(new w).f(["FILE-OPEN"])),SJa=(new A).e("etc._fileopen",RJa),TJa=I(r(),(new w).f(["FILE-PRINT"])),UJa=(new A).e("etc._fileprint",TJa),VJa=I(r(),(new w).f(["FILE-SHOW"])),WJa=(new A).e("etc._fileshow",VJa),XJa=I(r(),(new w).f(["FILE-TYPE"])),YJa=(new A).e("etc._filetype",XJa),ZJa=I(r(),(new w).f(["FILE-WRITE"])),$Ja=(new A).e("etc._filewrite", ZJa),aKa=I(r(),(new w).f(["FOLLOW"])),bKa=(new A).e("etc._follow",aKa),cKa=I(r(),(new w).f(["FOLLOW-ME"])),dKa=(new A).e("etc._followme",cKa),eKa=I(r(),(new w).f(["FOREACH"])),fKa=(new A).e("etc._foreach",eKa),gKa=I(r(),(new w).f(["FD","FORWARD"])),hKa=(new A).e("_fd",gKa),iKa=I(r(),(new w).f(["HATCH"])),jKa=(new A).e("_hatch",iKa),kKa=I(r(),(new w).f(["HIDE-LINK"])),lKa=(new A).e("etc._hidelink",kKa),mKa=I(r(),(new w).f(["HIDE-TURTLE","HT"])),nKa=(new A).e("etc._hideturtle",mKa),oKa=I(r(),(new w).f(["HISTOGRAM"])), pKa=(new A).e("etc._histogram",oKa),qKa=I(r(),(new w).f(["HOME"])),rKa=(new A).e("etc._home",qKa),sKa=I(r(),(new w).f(["HIDE-TURTLE","HT"])),tKa=(new A).e("etc._hideturtle",sKa),uKa=I(r(),(new w).f(["HUBNET-BROADCAST"])),vKa=(new A).e("hubnet._hubnetbroadcast",uKa),wKa=I(r(),(new w).f(["HUBNET-BROADCAST-CLEAR-OUTPUT"])),xKa=(new A).e("hubnet._hubnetbroadcastclearoutput",wKa),yKa=I(r(),(new w).f(["HUBNET-BROADCAST-MESSAGE"])),zKa=(new A).e("hubnet._hubnetbroadcastmessage",yKa),AKa=I(r(),(new w).f(["HUBNET-CLEAR-OVERRIDE"])), BKa=(new A).e("hubnet._hubnetclearoverride",AKa),CKa=I(r(),(new w).f(["HUBNET-CLEAR-OVERRIDES"])),DKa=(new A).e("hubnet._hubnetclearoverrides",CKa),EKa=I(r(),(new w).f(["HUBNET-FETCH-MESSAGE"])),FKa=(new A).e("hubnet._hubnetfetchmessage",EKa),GKa=I(r(),(new w).f(["HUBNET-KICK-ALL-CLIENTS"])),HKa=(new A).e("hubnet._hubnetkickallclients",GKa),IKa=I(r(),(new w).f(["HUBNET-KICK-CLIENT"])),JKa=(new A).e("hubnet._hubnetkickclient",IKa),KKa=I(r(),(new w).f(["HUBNET-RESET"])),LKa=(new A).e("hubnet._hubnetreset", KKa),MKa=I(r(),(new w).f(["HUBNET-RESET-PERSPECTIVE"])),NKa=(new A).e("hubnet._hubnetresetperspective",MKa),OKa=I(r(),(new w).f(["HUBNET-SEND"])),PKa=(new A).e("hubnet._hubnetsend",OKa),QKa=I(r(),(new w).f(["HUBNET-SEND-CLEAR-OUTPUT"])),RKa=(new A).e("hubnet._hubnetsendclearoutput",QKa),SKa=I(r(),(new w).f(["HUBNET-SEND-FOLLOW"])),TKa=(new A).e("hubnet._hubnetsendfollow",SKa),UKa=I(r(),(new w).f(["HUBNET-SEND-MESSAGE"])),VKa=(new A).e("hubnet._hubnetsendmessage",UKa),WKa=I(r(),(new w).f(["HUBNET-SEND-OVERRIDE"])), XKa=(new A).e("hubnet._hubnetsendoverride",WKa),YKa=I(r(),(new w).f(["HUBNET-SEND-WATCH"])),ZKa=(new A).e("hubnet._hubnetsendwatch",YKa),$Ka=I(r(),(new w).f(["IF"])),aLa=(new A).e("etc._if",$Ka),bLa=I(r(),(new w).f(["IF-ELSE","IFELSE"])),cLa=(new A).e("etc._ifelse",bLa),dLa=I(r(),(new w).f(["IF-ELSE","IFELSE"])),eLa=(new A).e("etc._ifelse",dLa),fLa=I(r(),(new w).f(["IMPORT-DRAWING"])),gLa=(new A).e("etc._importdrawing",fLa),hLa=I(r(),(new w).f(["IMPORT-PCOLORS"])),iLa=(new A).e("etc._importpatchcolors", hLa),jLa=I(r(),(new w).f(["IMPORT-PCOLORS-RGB"])),kLa=(new A).e("etc._importpcolorsrgb",jLa),lLa=I(r(),(new w).f(["IMPORT-WORLD"])),mLa=(new A).e("etc._importworld",lLa),nLa=I(r(),(new w).f(["INSPECT"])),oLa=(new A).e("etc._inspect",nLa),pLa=I(r(),(new w).f(["JUMP"])),qLa=(new A).e("_jump",pLa),rLa=I(r(),(new w).f(["LAYOUT-CIRCLE"])),sLa=(new A).e("etc._layoutcircle",rLa),tLa=I(r(),(new w).f(["LAYOUT-RADIAL"])),uLa=(new A).e("etc._layoutradial",tLa),vLa=I(r(),(new w).f(["LAYOUT-SPRING"])),wLa=(new A).e("etc._layoutspring", vLa),xLa=I(r(),(new w).f(["LAYOUT-TUTTE"])),yLa=(new A).e("etc._layouttutte",xLa),zLa=I(r(),(new w).f(["LEFT","LT"])),ALa=(new A).e("etc._left",zLa),BLa=I(r(),(new w).f(["__LET","LET"])),CLa=(new A).e("_let",BLa),DLa=I(r(),(new w).f(["LOOP"])),ELa=(new A).e("etc._loop",DLa),FLa=I(r(),(new w).f(["LEFT","LT"])),GLa=(new A).e("etc._left",FLa),HLa=I(r(),(new w).f(["MOVE-TO"])),ILa=(new A).e("etc._moveto",HLa),JLa=I(r(),(new w).f(["NO-DISPLAY"])),KLa=(new A).e("etc._nodisplay",JLa),LLa=I(r(),(new w).f(["OUTPUT-PRINT"])), MLa=(new A).e("etc._outputprint",LLa),NLa=I(r(),(new w).f(["OUTPUT-SHOW"])),OLa=(new A).e("etc._outputshow",NLa),PLa=I(r(),(new w).f(["OUTPUT-TYPE"])),QLa=(new A).e("etc._outputtype",PLa),RLa=I(r(),(new w).f(["OUTPUT-WRITE"])),SLa=(new A).e("etc._outputwrite",RLa),TLa=I(r(),(new w).f(["PD","PEN-DOWN","PENDOWN"])),ULa=(new A).e("etc._pendown",TLa),VLa=I(r(),(new w).f(["PE","PEN-ERASE"])),WLa=(new A).e("etc._penerase",VLa),XLa=I(r(),(new w).f(["PD","PEN-DOWN","PENDOWN"])),YLa=(new A).e("etc._pendown", XLa),ZLa=I(r(),(new w).f(["PE","PEN-ERASE"])),$La=(new A).e("etc._penerase",ZLa),aMa=I(r(),(new w).f(["PEN-UP","PENUP","PU"])),bMa=(new A).e("etc._penup",aMa),cMa=I(r(),(new w).f(["PD","PEN-DOWN","PENDOWN"])),dMa=(new A).e("etc._pendown",cMa),eMa=I(r(),(new w).f(["PEN-UP","PENUP","PU"])),fMa=(new A).e("etc._penup",eMa),gMa=I(r(),(new w).f(["PLOT"])),hMa=(new A).e("etc._plot",gMa),iMa=I(r(),(new w).f(["PLOT-PEN-DOWN"])),jMa=(new A).e("etc._plotpendown",iMa),kMa=I(r(),(new w).f(["PLOT-PEN-RESET"])), lMa=(new A).e("etc._plotpenreset",kMa),mMa=I(r(),(new w).f(["PLOT-PEN-UP"])),nMa=(new A).e("etc._plotpenup",mMa),oMa=I(r(),(new w).f(["PLOTXY"])),pMa=(new A).e("etc._plotxy",oMa),qMa=I(r(),(new w).f(["PRINT"])),rMa=(new A).e("etc._print",qMa),sMa=I(r(),(new w).f(["PEN-UP","PENUP","PU"])),tMa=(new A).e("etc._penup",sMa),uMa=I(r(),(new w).f(["RANDOM-SEED"])),vMa=(new A).e("etc._randomseed",uMa),wMa=I(r(),(new w).f(["REPEAT"])),xMa=(new A).e("_repeat",wMa),yMa=I(r(),(new w).f(["REPORT"])),zMa=(new A).e("_report", yMa),AMa=I(r(),(new w).f(["RESET-PERSPECTIVE","RP"])),BMa=(new A).e("etc._resetperspective",AMa),CMa=I(r(),(new w).f(["RESET-TICKS"])),DMa=(new A).e("etc._resetticks",CMa),EMa=I(r(),(new w).f(["RESET-TIMER"])),FMa=(new A).e("etc._resettimer",EMa),GMa=I(r(),(new w).f(["RESIZE-WORLD"])),HMa=(new A).e("etc._resizeworld",GMa),IMa=I(r(),(new w).f(["RIDE"])),JMa=(new A).e("etc._ride",IMa),KMa=I(r(),(new w).f(["RIDE-ME"])),LMa=(new A).e("etc._rideme",KMa),MMa=I(r(),(new w).f(["RIGHT","RT"])),NMa=(new A).e("etc._right", MMa),OMa=I(r(),(new w).f(["RESET-PERSPECTIVE","RP"])),PMa=(new A).e("etc._resetperspective",OMa),QMa=I(r(),(new w).f(["RIGHT","RT"])),RMa=(new A).e("etc._right",QMa),SMa=I(r(),(new w).f(["RUN"])),TMa=(new A).e("_run",SMa),UMa=I(r(),(new w).f(["SET"])),VMa=(new A).e("_set",UMa),WMa=I(r(),(new w).f(["SET-CURRENT-DIRECTORY"])),XMa=(new A).e("etc._setcurdir",WMa),YMa=I(r(),(new w).f(["SET-CURRENT-PLOT"])),ZMa=(new A).e("etc._setcurrentplot",YMa),$Ma=I(r(),(new w).f(["SET-CURRENT-PLOT-PEN"])),aNa=(new A).e("etc._setcurrentplotpen", $Ma),bNa=I(r(),(new w).f(["SET-DEFAULT-SHAPE"])),cNa=(new A).e("etc._setdefaultshape",bNa),dNa=I(r(),(new w).f(["SET-HISTOGRAM-NUM-BARS"])),eNa=(new A).e("etc._sethistogramnumbars",dNa),fNa=I(r(),(new w).f(["SET-PATCH-SIZE"])),gNa=(new A).e("etc._setpatchsize",fNa),hNa=I(r(),(new w).f(["SET-PLOT-PEN-COLOR"])),iNa=(new A).e("etc._setplotpencolor",hNa),jNa=I(r(),(new w).f(["SET-PLOT-PEN-INTERVAL"])),kNa=(new A).e("etc._setplotpeninterval",jNa),lNa=I(r(),(new w).f(["SET-PLOT-PEN-MODE"])),mNa=(new A).e("etc._setplotpenmode", lNa),nNa=I(r(),(new w).f(["SET-PLOT-X-RANGE"])),oNa=(new A).e("etc._setplotxrange",nNa),pNa=I(r(),(new w).f(["SET-PLOT-Y-RANGE"])),qNa=(new A).e("etc._setplotyrange",pNa),rNa=I(r(),(new w).f(["SETUP-PLOTS"])),sNa=(new A).e("etc._setupplots",rNa),tNa=I(r(),(new w).f(["SETXY"])),uNa=(new A).e("etc._setxy",tNa),vNa=I(r(),(new w).f(["SHOW"])),wNa=(new A).e("etc._show",vNa),xNa=I(r(),(new w).f(["SHOW-LINK"])),yNa=(new A).e("etc._showlink",xNa),zNa=I(r(),(new w).f(["SHOW-TURTLE","ST"])),ANa=(new A).e("etc._showturtle", zNa),BNa=I(r(),(new w).f(["SPROUT"])),CNa=(new A).e("_sprout",BNa),DNa=I(r(),(new w).f(["SHOW-TURTLE","ST"])),ENa=(new A).e("etc._showturtle",DNa),FNa=I(r(),(new w).f(["STAMP"])),GNa=(new A).e("etc._stamp",FNa),HNa=I(r(),(new w).f(["STAMP-ERASE"])),INa=(new A).e("etc._stamperase",HNa),JNa=I(r(),(new w).f(["STOP"])),KNa=(new A).e("_stop",JNa),LNa=I(r(),(new w).f(["STOP-INSPECTING"])),MNa=(new A).e("etc._stopinspecting",LNa),NNa=I(r(),(new w).f(["STOP-INSPECTING-DEAD-AGENTS"])),ONa=(new A).e("etc._stopinspectingdeadagents", NNa),PNa=I(r(),(new w).f(["TICK"])),QNa=(new A).e("etc._tick",PNa),RNa=I(r(),(new w).f(["TICK-ADVANCE"])),SNa=(new A).e("etc._tickadvance",RNa),TNa=I(r(),(new w).f(["TIE"])),UNa=(new A).e("etc._tie",TNa),VNa=I(r(),(new w).f(["TYPE"])),WNa=(new A).e("etc._type",VNa),XNa=I(r(),(new w).f(["UNTIE"])),YNa=(new A).e("etc._untie",XNa),ZNa=I(r(),(new w).f(["UPDATE-PLOTS"])),$Na=(new A).e("etc._updateplots",ZNa),aOa=I(r(),(new w).f(["UPHILL"])),bOa=(new A).e("etc._uphill",aOa),cOa=I(r(),(new w).f(["UPHILL4"])), dOa=(new A).e("etc._uphill4",cOa),eOa=I(r(),(new w).f(["USER-MESSAGE"])),fOa=(new A).e("etc._usermessage",eOa),gOa=I(r(),(new w).f(["WAIT"])),hOa=(new A).e("etc._wait",gOa),iOa=I(r(),(new w).f(["WATCH"])),jOa=(new A).e("etc._watch",iOa),kOa=I(r(),(new w).f(["WATCH-ME"])),lOa=(new A).e("etc._watchme",kOa),mOa=I(r(),(new w).f(["WHILE"])),nOa=(new A).e("etc._while",mOa),oOa=I(r(),(new w).f(["WITH-LOCAL-RANDOMNESS"])),pOa=(new A).e("etc._withlocalrandomness",oOa),qOa=I(r(),(new w).f(["WITHOUT-INTERRUPTION"])), rOa=(new A).e("etc._withoutinterruption",qOa),sOa=I(r(),(new w).f(["WRITE"])),tOa=(new A).e("etc._write",sOa),uOa=I(r(),(new w).f(["!\x3d"])),vOa=(new A).e("_notequal",uOa),wOa=I(r(),(new w).f(["*"])),xOa=(new A).e("etc._mult",wOa),yOa=I(r(),(new w).f(["+"])),zOa=(new A).e("etc._plus",yOa),AOa=I(r(),(new w).f(["-"])),BOa=(new A).e("_minus",AOa),COa=I(r(),(new w).f(["/"])),DOa=(new A).e("etc._div",COa),EOa=I(r(),(new w).f(["\x3c"])),FOa=(new A).e("_lessthan",EOa),GOa=I(r(),(new w).f(["\x3c\x3d"])), HOa=(new A).e("etc._lessorequal",GOa),IOa=I(r(),(new w).f(["\x3d"])),JOa=(new A).e("_equal",IOa),KOa=I(r(),(new w).f(["\x3e"])),LOa=(new A).e("_greaterthan",KOa),MOa=I(r(),(new w).f(["\x3e\x3d"])),NOa=(new A).e("etc._greaterorequal",MOa),OOa=I(r(),(new w).f(["^"])),POa=(new A).e("etc._pow",OOa),QOa=I(r(),(new w).f(["__APPLY-RESULT"])),ROa=(new A).e("etc._applyresult",QOa),SOa=I(r(),(new w).f(["__BOOM"])),TOa=(new A).e("etc._boom",SOa),UOa=I(r(),(new w).f(["__BLOCK"])),VOa=(new A).e("etc._block",UOa), WOa=I(r(),(new w).f(["__CHECK-SYNTAX"])),XOa=(new A).e("etc._checksyntax",WOa),YOa=I(r(),(new w).f(["__CHECKSUM"])),ZOa=(new A).e("etc._checksum",YOa),$Oa=I(r(),(new w).f(["__DUMP"])),aPa=(new A).e("etc._dump",$Oa),bPa=I(r(),(new w).f(["__DUMP-EXTENSION-PRIMS"])),cPa=(new A).e("etc._dumpextensionprims",bPa),dPa=I(r(),(new w).f(["__DUMP-EXTENSIONS"])),ePa=(new A).e("etc._dumpextensions",dPa),fPa=I(r(),(new w).f(["__DUMP1"])),gPa=(new A).e("etc._dump1",fPa),hPa=I(r(),(new w).f(["__NANO-TIME"])),iPa= (new A).e("etc._nanotime",hPa),jPa=I(r(),(new w).f(["__PROCESSORS"])),kPa=(new A).e("etc._processors",jPa),lPa=I(r(),(new w).f(["__RANDOM-STATE"])),mPa=(new A).e("etc._randomstate",lPa),nPa=I(r(),(new w).f(["__REFERENCE"])),oPa=(new A).e("etc._reference",nPa),pPa=I(r(),(new w).f(["__STACK-TRACE"])),qPa=(new A).e("etc._stacktrace",pPa),rPa=I(r(),(new w).f(["__SYMBOL"])),sPa=(new A).e("etc._symbolstring",rPa),tPa=I(r(),(new w).f(["__TO-STRING"])),uPa=(new A).e("etc._tostring",tPa),vPa=I(r(),(new w).f(["ABS"])), wPa=(new A).e("etc._abs",vPa),xPa=I(r(),(new w).f(["ACOS"])),yPa=(new A).e("etc._acos",xPa),zPa=I(r(),(new w).f(["ALL?"])),APa=(new A).e("etc._all",zPa),BPa=I(r(),(new w).f(["AND"])),CPa=(new A).e("_and",BPa),DPa=I(r(),(new w).f(["ANY?"])),EPa=(new A).e("_any",DPa),FPa=I(r(),(new w).f(["APPROXIMATE-HSB"])),GPa=(new A).e("etc._approximatehsb",FPa),HPa=I(r(),(new w).f(["APPROXIMATE-RGB"])),IPa=(new A).e("etc._approximatergb",HPa),JPa=I(r(),(new w).f(["ASIN"])),KPa=(new A).e("etc._asin",JPa),LPa=I(r(), (new w).f(["AT-POINTS"])),MPa=(new A).e("etc._atpoints",LPa),NPa=I(r(),(new w).f(["ATAN"])),OPa=(new A).e("etc._atan",NPa),PPa=I(r(),(new w).f(["AUTOPLOT?"])),QPa=(new A).e("etc._autoplot",PPa),RPa=I(r(),(new w).f(["BASE-COLORS"])),SPa=(new A).e("etc._basecolors",RPa),TPa=I(r(),(new w).f(["BEHAVIORSPACE-RUN-NUMBER"])),UPa=(new A).e("etc._behaviorspacerunnumber",TPa),VPa=I(r(),(new w).f(["BF","BUT-FIRST","BUTFIRST"])),WPa=(new A).e("etc._butfirst",VPa),XPa=I(r(),(new w).f(["BL","BUT-LAST","BUTLAST"])), YPa=(new A).e("etc._butlast",XPa),ZPa=I(r(),(new w).f(["BOTH-ENDS"])),$Pa=(new A).e("etc._bothends",ZPa),aQa=I(r(),(new w).f(["BF","BUT-FIRST","BUTFIRST"])),bQa=(new A).e("etc._butfirst",aQa),cQa=I(r(),(new w).f(["BL","BUT-LAST","BUTLAST"])),dQa=(new A).e("etc._butlast",cQa),eQa=I(r(),(new w).f(["BF","BUT-FIRST","BUTFIRST"])),fQa=(new A).e("etc._butfirst",eQa),gQa=I(r(),(new w).f(["BL","BUT-LAST","BUTLAST"])),hQa=(new A).e("etc._butlast",gQa),iQa=I(r(),(new w).f(["CAN-MOVE?"])),jQa=(new A).e("etc._canmove", iQa),kQa=I(r(),(new w).f(["CEILING"])),lQa=(new A).e("etc._ceil",kQa),mQa=I(r(),(new w).f(["COS"])),nQa=(new A).e("etc._cos",mQa),oQa=I(r(),(new w).f(["COUNT"])),pQa=(new A).e("_count",oQa),qQa=I(r(),(new w).f(["DATE-AND-TIME"])),rQa=(new A).e("etc._dateandtime",qQa),sQa=I(r(),(new w).f(["DISTANCE"])),tQa=(new A).e("etc._distance",sQa),uQa=I(r(),(new w).f(["DISTANCEXY"])),vQa=(new A).e("etc._distancexy",uQa),wQa=I(r(),(new w).f(["DX"])),xQa=(new A).e("etc._dx",wQa),yQa=I(r(),(new w).f(["DY"])),zQa= (new A).e("etc._dy",yQa),AQa=I(r(),(new w).f(["EMPTY?"])),BQa=(new A).e("etc._empty",AQa),CQa=I(r(),(new w).f(["ERROR-MESSAGE"])),DQa=(new A).e("_errormessage",CQa),EQa=I(r(),(new w).f(["EXP"])),FQa=(new A).e("etc._exp",EQa),GQa=I(r(),(new w).f(["EXTRACT-HSB"])),HQa=(new A).e("etc._extracthsb",GQa),IQa=I(r(),(new w).f(["EXTRACT-RGB"])),JQa=(new A).e("etc._extractrgb",IQa),KQa=I(r(),(new w).f(["FILE-AT-END?"])),LQa=(new A).e("etc._fileatend",KQa),MQa=I(r(),(new w).f(["FILE-EXISTS?"])),NQa=(new A).e("etc._fileexists", MQa),OQa=I(r(),(new w).f(["FILE-READ"])),PQa=(new A).e("etc._fileread",OQa),QQa=I(r(),(new w).f(["FILE-READ-CHARACTERS"])),RQa=(new A).e("etc._filereadchars",QQa),SQa=I(r(),(new w).f(["FILE-READ-LINE"])),TQa=(new A).e("etc._filereadline",SQa),UQa=I(r(),(new w).f(["FILTER"])),VQa=(new A).e("etc._filter",UQa),WQa=I(r(),(new w).f(["FIRST"])),XQa=(new A).e("etc._first",WQa),YQa=I(r(),(new w).f(["FLOOR"])),ZQa=(new A).e("etc._floor",YQa),$Qa=I(r(),(new w).f(["FPUT"])),aRa=(new A).e("etc._fput",$Qa),bRa= I(r(),(new w).f(["HSB"])),cRa=(new A).e("etc._hsb",bRa),dRa=I(r(),(new w).f(["HUBNET-CLIENTS-LIST"])),eRa=(new A).e("hubnet._hubnetclientslist",dRa),fRa=I(r(),(new w).f(["HUBNET-ENTER-MESSAGE?"])),gRa=(new A).e("hubnet._hubnetentermessage",fRa),hRa=I(r(),(new w).f(["HUBNET-EXIT-MESSAGE?"])),iRa=(new A).e("hubnet._hubnetexitmessage",hRa),jRa=I(r(),(new w).f(["HUBNET-MESSAGE"])),kRa=(new A).e("hubnet._hubnetmessage",jRa),lRa=I(r(),(new w).f(["HUBNET-MESSAGE-SOURCE"])),mRa=(new A).e("hubnet._hubnetmessagesource", lRa),nRa=I(r(),(new w).f(["HUBNET-MESSAGE-TAG"])),oRa=(new A).e("hubnet._hubnetmessagetag",nRa),pRa=I(r(),(new w).f(["HUBNET-MESSAGE-WAITING?"])),qRa=(new A).e("hubnet._hubnetmessagewaiting",pRa),rRa=I(r(),(new w).f(["IFELSE-VALUE"])),sRa=(new A).e("etc._ifelsevalue",rRa),tRa=I(r(),(new w).f(["IN-CONE"])),uRa=(new A).e("etc._incone",tRa),vRa=I(r(),(new w).f(["IN-LINK-FROM"])),wRa=(new A).e("etc._inlinkfrom",vRa),xRa=I(r(),(new w).f(["IN-LINK-NEIGHBOR?"])),yRa=(new A).e("etc._inlinkneighbor",xRa), zRa=I(r(),(new w).f(["IN-LINK-NEIGHBORS"])),ARa=(new A).e("etc._inlinkneighbors",zRa),BRa=I(r(),(new w).f(["IN-RADIUS"])),CRa=(new A).e("_inradius",BRa),DRa=I(r(),(new w).f(["INSERT-ITEM"])),ERa=(new A).e("etc._insertitem",DRa),FRa=I(r(),(new w).f(["INT"])),GRa=(new A).e("etc._int",FRa),HRa=I(r(),(new w).f(["IS-AGENT?"])),IRa=(new A).e("etc._isagent",HRa),JRa=I(r(),(new w).f(["IS-AGENTSET?"])),KRa=(new A).e("etc._isagentset",JRa),LRa=I(r(),(new w).f(["IS-ANONYMOUS-COMMAND?"])),MRa=(new A).e("etc._isanonymouscommand", LRa),NRa=I(r(),(new w).f(["IS-ANONYMOUS-REPORTER?"])),ORa=(new A).e("etc._isanonymousreporter",NRa),PRa=I(r(),(new w).f(["IS-BOOLEAN?"])),QRa=(new A).e("etc._isboolean",PRa),RRa=I(r(),(new w).f(["IS-DIRECTED-LINK?"])),SRa=(new A).e("etc._isdirectedlink",RRa),TRa=I(r(),(new w).f(["IS-LINK-SET?"])),URa=(new A).e("etc._islinkset",TRa),VRa=I(r(),(new w).f(["IS-LINK?"])),WRa=(new A).e("etc._islink",VRa),XRa=I(r(),(new w).f(["IS-LIST?"])),YRa=(new A).e("etc._islist",XRa),ZRa=I(r(),(new w).f(["IS-NUMBER?"])), $Ra=(new A).e("etc._isnumber",ZRa),aSa=I(r(),(new w).f(["IS-PATCH-SET?"])),bSa=(new A).e("etc._ispatchset",aSa),cSa=I(r(),(new w).f(["IS-PATCH?"])),dSa=(new A).e("etc._ispatch",cSa),eSa=I(r(),(new w).f(["IS-STRING?"])),fSa=(new A).e("etc._isstring",eSa),gSa=I(r(),(new w).f(["IS-TURTLE-SET?"])),hSa=(new A).e("etc._isturtleset",gSa),iSa=I(r(),(new w).f(["IS-TURTLE?"])),jSa=(new A).e("etc._isturtle",iSa),kSa=I(r(),(new w).f(["IS-UNDIRECTED-LINK?"])),lSa=(new A).e("etc._isundirectedlink",kSa),mSa=I(r(), (new w).f(["ITEM"])),nSa=(new A).e("etc._item",mSa),oSa=I(r(),(new w).f(["LAST"])),pSa=(new A).e("etc._last",oSa),qSa=I(r(),(new w).f(["LENGTH"])),rSa=(new A).e("etc._length",qSa),sSa=I(r(),(new w).f(["LINK"])),tSa=(new A).e("etc._link",sSa),uSa=I(r(),(new w).f(["LINK-HEADING"])),vSa=(new A).e("etc._linkheading",uSa),wSa=I(r(),(new w).f(["LINK-LENGTH"])),xSa=(new A).e("etc._linklength",wSa),ySa=I(r(),(new w).f(["LINK-NEIGHBOR?"])),zSa=(new A).e("etc._linkneighbor",ySa),ASa=I(r(),(new w).f(["LINK-NEIGHBORS"])), BSa=(new A).e("etc._linkneighbors",ASa),CSa=I(r(),(new w).f(["LINK-SET"])),DSa=(new A).e("etc._linkset",CSa),ESa=I(r(),(new w).f(["LINK-SHAPES"])),FSa=(new A).e("etc._linkshapes",ESa),GSa=I(r(),(new w).f(["LINK-WITH"])),HSa=(new A).e("etc._linkwith",GSa),ISa=I(r(),(new w).f(["LINKS"])),JSa=(new A).e("etc._links",ISa),KSa=I(r(),(new w).f(["LIST"])),LSa=(new A).e("_list",KSa),MSa=I(r(),(new w).f(["LN"])),NSa=(new A).e("etc._ln",MSa),OSa=I(r(),(new w).f(["LOG"])),PSa=(new A).e("etc._log",OSa),QSa=I(r(), (new w).f(["LPUT"])),RSa=(new A).e("etc._lput",QSa),SSa=I(r(),(new w).f(["MAP"])),TSa=(new A).e("etc._map",SSa),USa=I(r(),(new w).f(["MAX"])),VSa=(new A).e("etc._max",USa),WSa=I(r(),(new w).f(["MAX-N-OF"])),XSa=(new A).e("etc._maxnof",WSa),YSa=I(r(),(new w).f(["MAX-ONE-OF"])),ZSa=(new A).e("etc._maxoneof",YSa),$Sa=I(r(),(new w).f(["MAX-PXCOR"])),aTa=(new A).e("etc._maxpxcor",$Sa),bTa=I(r(),(new w).f(["MAX-PYCOR"])),cTa=(new A).e("etc._maxpycor",bTa),dTa=I(r(),(new w).f(["MEAN"])),eTa=(new A).e("etc._mean", dTa),fTa=I(r(),(new w).f(["MEDIAN"])),gTa=(new A).e("etc._median",fTa),hTa=I(r(),(new w).f(["MEMBER?"])),iTa=(new A).e("etc._member",hTa),jTa=I(r(),(new w).f(["MIN"])),kTa=(new A).e("etc._min",jTa),lTa=I(r(),(new w).f(["MIN-N-OF"])),mTa=(new A).e("etc._minnof",lTa),nTa=I(r(),(new w).f(["MIN-ONE-OF"])),oTa=(new A).e("etc._minoneof",nTa),pTa=I(r(),(new w).f(["MIN-PXCOR"])),qTa=(new A).e("etc._minpxcor",pTa),rTa=I(r(),(new w).f(["MIN-PYCOR"])),sTa=(new A).e("etc._minpycor",rTa),tTa=I(r(),(new w).f(["MOD"])), uTa=(new A).e("etc._mod",tTa),vTa=I(r(),(new w).f(["MODES"])),wTa=(new A).e("etc._modes",vTa),xTa=I(r(),(new w).f(["MOUSE-DOWN?"])),yTa=(new A).e("etc._mousedown",xTa),zTa=I(r(),(new w).f(["MOUSE-INSIDE?"])),ATa=(new A).e("etc._mouseinside",zTa),BTa=I(r(),(new w).f(["MOUSE-XCOR"])),CTa=(new A).e("etc._mousexcor",BTa),DTa=I(r(),(new w).f(["MOUSE-YCOR"])),ETa=(new A).e("etc._mouseycor",DTa),FTa=I(r(),(new w).f(["MY-IN-LINKS"])),GTa=(new A).e("etc._myinlinks",FTa),HTa=I(r(),(new w).f(["MY-LINKS"])), ITa=(new A).e("etc._mylinks",HTa),JTa=I(r(),(new w).f(["MY-OUT-LINKS"])),KTa=(new A).e("etc._myoutlinks",JTa),LTa=I(r(),(new w).f(["MYSELF"])),MTa=(new A).e("etc._myself",LTa),NTa=I(r(),(new w).f(["N-OF"])),OTa=(new A).e("etc._nof",NTa),PTa=I(r(),(new w).f(["N-VALUES"])),QTa=(new A).e("etc._nvalues",PTa),RTa=I(r(),(new w).f(["NEIGHBORS"])),STa=(new A).e("_neighbors",RTa),TTa=I(r(),(new w).f(["NEIGHBORS4"])),UTa=(new A).e("_neighbors4",TTa),VTa=I(r(),(new w).f(["NETLOGO-APPLET?"])),WTa=(new A).e("etc._netlogoapplet", VTa),XTa=I(r(),(new w).f(["NETLOGO-VERSION"])),YTa=(new A).e("etc._netlogoversion",XTa),ZTa=I(r(),(new w).f(["NETLOGO-WEB?"])),$Ta=(new A).e("etc._netlogoweb",ZTa),aUa=I(r(),(new w).f(["NEW-SEED"])),bUa=(new A).e("etc._newseed",aUa),cUa=I(r(),(new w).f(["NO-LINKS"])),dUa=(new A).e("etc._nolinks",cUa),eUa=I(r(),(new w).f(["NO-PATCHES"])),fUa=(new A).e("etc._nopatches",eUa),gUa=I(r(),(new w).f(["NO-TURTLES"])),hUa=(new A).e("etc._noturtles",gUa),iUa=I(r(),(new w).f(["NOT"])),jUa=(new A).e("_not",iUa), kUa=I(r(),(new w).f(["OF"])),lUa=(new A).e("_of",kUa),mUa=I(r(),(new w).f(["ONE-OF"])),nUa=(new A).e("_oneof",mUa),oUa=I(r(),(new w).f(["OR"])),pUa=(new A).e("_or",oUa),qUa=I(r(),(new w).f(["OTHER"])),rUa=(new A).e("_other",qUa),sUa=I(r(),(new w).f(["OTHER-END"])),tUa=(new A).e("etc._otherend",sUa),uUa=I(r(),(new w).f(["OUT-LINK-NEIGHBOR?"])),vUa=(new A).e("etc._outlinkneighbor",uUa),wUa=I(r(),(new w).f(["OUT-LINK-NEIGHBORS"])),xUa=(new A).e("etc._outlinkneighbors",wUa),yUa=I(r(),(new w).f(["OUT-LINK-TO"])), zUa=(new A).e("etc._outlinkto",yUa),AUa=I(r(),(new w).f(["PATCH"])),BUa=(new A).e("etc._patch",AUa),CUa=I(r(),(new w).f(["PATCH-AHEAD"])),DUa=(new A).e("etc._patchahead",CUa),EUa=I(r(),(new w).f(["PATCH-AT"])),FUa=(new A).e("_patchat",EUa),GUa=I(r(),(new w).f(["PATCH-AT-HEADING-AND-DISTANCE"])),HUa=(new A).e("etc._patchatheadinganddistance",GUa),IUa=I(r(),(new w).f(["PATCH-HERE"])),JUa=(new A).e("etc._patchhere",IUa),KUa=I(r(),(new w).f(["PATCH-LEFT-AND-AHEAD"])),LUa=(new A).e("etc._patchleftandahead", KUa),MUa=I(r(),(new w).f(["PATCH-RIGHT-AND-AHEAD"])),NUa=(new A).e("etc._patchrightandahead",MUa),OUa=I(r(),(new w).f(["PATCH-SET"])),PUa=(new A).e("etc._patchset",OUa),QUa=I(r(),(new w).f(["PATCH-SIZE"])),RUa=(new A).e("etc._patchsize",QUa),SUa=I(r(),(new w).f(["PATCHES"])),TUa=(new A).e("_patches",SUa),UUa=I(r(),(new w).f(["PLOT-NAME"])),VUa=(new A).e("etc._plotname",UUa),WUa=I(r(),(new w).f(["PLOT-PEN-EXISTS?"])),XUa=(new A).e("etc._plotpenexists",WUa),YUa=I(r(),(new w).f(["PLOT-X-MAX"])),ZUa= (new A).e("etc._plotxmax",YUa),$Ua=I(r(),(new w).f(["PLOT-X-MIN"])),aVa=(new A).e("etc._plotxmin",$Ua),bVa=I(r(),(new w).f(["PLOT-Y-MAX"])),cVa=(new A).e("etc._plotymax",bVa),dVa=I(r(),(new w).f(["PLOT-Y-MIN"])),eVa=(new A).e("etc._plotymin",dVa),fVa=I(r(),(new w).f(["POSITION"])),gVa=(new A).e("etc._position",fVa),hVa=I(r(),(new w).f(["PRECISION"])),iVa=(new A).e("etc._precision",hVa),jVa=I(r(),(new w).f(["RANDOM"])),kVa=(new A).e("_random",jVa),lVa=I(r(),(new w).f(["RANDOM-EXPONENTIAL"])),mVa=(new A).e("etc._randomexponential", lVa),nVa=I(r(),(new w).f(["RANDOM-FLOAT"])),oVa=(new A).e("etc._randomfloat",nVa),pVa=I(r(),(new w).f(["RANDOM-GAMMA"])),qVa=(new A).e("etc._randomgamma",pVa),rVa=I(r(),(new w).f(["RANDOM-NORMAL"])),sVa=(new A).e("etc._randomnormal",rVa),tVa=I(r(),(new w).f(["RANDOM-POISSON"])),uVa=(new A).e("etc._randompoisson",tVa),vVa=I(r(),(new w).f(["RANDOM-PXCOR"])),wVa=(new A).e("etc._randompxcor",vVa),xVa=I(r(),(new w).f(["RANDOM-PYCOR"])),yVa=(new A).e("etc._randompycor",xVa),zVa=I(r(),(new w).f(["RANDOM-XCOR"])), AVa=(new A).e("etc._randomxcor",zVa),BVa=I(r(),(new w).f(["RANDOM-YCOR"])),CVa=(new A).e("etc._randomycor",BVa),DVa=I(r(),(new w).f(["RANGE"])),EVa=(new A).e("etc._range",DVa),FVa=I(r(),(new w).f(["READ-FROM-STRING"])),GVa=(new A).e("etc._readfromstring",FVa),HVa=I(r(),(new w).f(["REDUCE"])),IVa=(new A).e("etc._reduce",HVa),JVa=I(r(),(new w).f(["REMAINDER"])),KVa=(new A).e("etc._remainder",JVa),LVa=I(r(),(new w).f(["REMOVE"])),MVa=(new A).e("etc._remove",LVa),NVa=I(r(),(new w).f(["REMOVE-DUPLICATES"])), OVa=(new A).e("etc._removeduplicates",NVa),PVa=I(r(),(new w).f(["REMOVE-ITEM"])),QVa=(new A).e("etc._removeitem",PVa),RVa=I(r(),(new w).f(["REPLACE-ITEM"])),SVa=(new A).e("etc._replaceitem",RVa),TVa=I(r(),(new w).f(["REVERSE"])),UVa=(new A).e("etc._reverse",TVa),VVa=I(r(),(new w).f(["RGB"])),WVa=(new A).e("etc._rgb",VVa),XVa=I(r(),(new w).f(["ROUND"])),YVa=(new A).e("etc._round",XVa),ZVa=I(r(),(new w).f(["RUN-RESULT","RUNRESULT"])),$Va=(new A).e("etc._runresult",ZVa),aWa=I(r(),(new w).f(["RUN-RESULT", "RUNRESULT"])),bWa=(new A).e("etc._runresult",aWa),cWa=I(r(),(new w).f(["SCALE-COLOR"])),dWa=(new A).e("etc._scalecolor",cWa),eWa=I(r(),(new w).f(["SE","SENTENCE"])),fWa=(new A).e("_sentence",eWa),gWa=I(r(),(new w).f(["SELF"])),hWa=(new A).e("etc._self",gWa),iWa=I(r(),(new w).f(["SE","SENTENCE"])),jWa=(new A).e("_sentence",iWa),kWa=I(r(),(new w).f(["SHADE-OF?"])),lWa=(new A).e("etc._shadeof",kWa),mWa=I(r(),(new w).f(["SHAPES"])),nWa=(new A).e("etc._shapes",mWa),oWa=I(r(),(new w).f(["SHUFFLE"])),pWa= (new A).e("etc._shuffle",oWa),qWa=I(r(),(new w).f(["SIN"])),rWa=(new A).e("etc._sin",qWa),sWa=I(r(),(new w).f(["SORT"])),tWa=(new A).e("etc._sort",sWa),uWa=I(r(),(new w).f(["SORT-BY"])),vWa=(new A).e("etc._sortby",uWa),wWa=I(r(),(new w).f(["SORT-ON"])),xWa=(new A).e("etc._sorton",wWa),yWa=I(r(),(new w).f(["SQRT"])),zWa=(new A).e("etc._sqrt",yWa),AWa=I(r(),(new w).f(["STANDARD-DEVIATION"])),BWa=(new A).e("etc._standarddeviation",AWa),CWa=I(r(),(new w).f(["SUBJECT"])),DWa=(new A).e("etc._subject",CWa), EWa=I(r(),(new w).f(["SUBLIST"])),FWa=(new A).e("etc._sublist",EWa),GWa=I(r(),(new w).f(["SUBSTRING"])),HWa=(new A).e("etc._substring",GWa),IWa=I(r(),(new w).f(["SUBTRACT-HEADINGS"])),JWa=(new A).e("etc._subtractheadings",IWa),KWa=I(r(),(new w).f(["SUM"])),LWa=(new A).e("_sum",KWa),MWa=I(r(),(new w).f(["TAN"])),NWa=(new A).e("etc._tan",MWa),OWa=I(r(),(new w).f(["TICKS"])),PWa=(new A).e("etc._ticks",OWa),QWa=I(r(),(new w).f(["TIMER"])),RWa=(new A).e("etc._timer",QWa),SWa=I(r(),(new w).f(["TOWARDS"])), TWa=(new A).e("etc._towards",SWa),UWa=I(r(),(new w).f(["TOWARDSXY"])),VWa=(new A).e("etc._towardsxy",UWa),WWa=I(r(),(new w).f(["TURTLE"])),XWa=(new A).e("_turtle",WWa),YWa=I(r(),(new w).f(["TURTLE-SET"])),ZWa=(new A).e("etc._turtleset",YWa),$Wa=I(r(),(new w).f(["TURTLES"])),aXa=(new A).e("_turtles",$Wa),bXa=I(r(),(new w).f(["TURTLES-AT"])),cXa=(new A).e("etc._turtlesat",bXa),dXa=I(r(),(new w).f(["TURTLES-HERE"])),eXa=(new A).e("etc._turtleshere",dXa),fXa=I(r(),(new w).f(["TURTLES-ON"])),gXa=(new A).e("etc._turtleson", fXa),hXa=I(r(),(new w).f(["USER-DIRECTORY"])),iXa=(new A).e("etc._userdirectory",hXa),jXa=I(r(),(new w).f(["USER-FILE"])),kXa=(new A).e("etc._userfile",jXa),lXa=I(r(),(new w).f(["USER-INPUT"])),mXa=(new A).e("etc._userinput",lXa),nXa=I(r(),(new w).f(["USER-NEW-FILE"])),oXa=(new A).e("etc._usernewfile",nXa),pXa=I(r(),(new w).f(["USER-ONE-OF"])),qXa=(new A).e("etc._useroneof",pXa),rXa=I(r(),(new w).f(["USER-YES-OR-NO?"])),sXa=(new A).e("etc._useryesorno",rXa),tXa=I(r(),(new w).f(["VARIANCE"])),uXa= (new A).e("etc._variance",tXa),vXa=I(r(),(new w).f(["WITH"])),wXa=(new A).e("_with",vXa),xXa=I(r(),(new w).f(["WITH-MAX"])),yXa=(new A).e("etc._withmax",xXa),zXa=I(r(),(new w).f(["WITH-MIN"])),AXa=(new A).e("etc._withmin",zXa),BXa=I(r(),(new w).f(["WORD"])),CXa=(new A).e("_word",BXa),DXa=I(r(),(new w).f(["WORLD-HEIGHT"])),EXa=(new A).e("etc._worldheight",DXa),FXa=I(r(),(new w).f(["WORLD-WIDTH"])),GXa=(new A).e("etc._worldwidth",FXa),HXa=I(r(),(new w).f(["WRAP-COLOR"])),IXa=(new A).e("etc._wrapcolor", HXa),JXa=I(r(),(new w).f(["XOR"]));nh(XGa,(new w).f([ZGa,aHa,cHa,eHa,gHa,iHa,kHa,mHa,oHa,qHa,sHa,uHa,wHa,yHa,AHa,CHa,EHa,GHa,IHa,KHa,MHa,OHa,QHa,SHa,UHa,WHa,YHa,$Ha,bIa,dIa,fIa,hIa,jIa,lIa,nIa,pIa,rIa,tIa,vIa,xIa,zIa,BIa,DIa,FIa,HIa,JIa,LIa,NIa,PIa,RIa,TIa,VIa,XIa,ZIa,aJa,cJa,eJa,gJa,iJa,kJa,mJa,oJa,qJa,sJa,uJa,wJa,yJa,AJa,CJa,EJa,GJa,IJa,KJa,MJa,OJa,QJa,SJa,UJa,WJa,YJa,$Ja,bKa,dKa,fKa,hKa,jKa,lKa,nKa,pKa,rKa,tKa,vKa,xKa,zKa,BKa,DKa,FKa,HKa,JKa,LKa,NKa,PKa,RKa,TKa,VKa,XKa,ZKa,aLa,cLa,eLa,gLa,iLa, kLa,mLa,oLa,qLa,sLa,uLa,wLa,yLa,ALa,CLa,ELa,GLa,ILa,KLa,MLa,OLa,QLa,SLa,ULa,WLa,YLa,$La,bMa,dMa,fMa,hMa,jMa,lMa,nMa,pMa,rMa,tMa,vMa,xMa,zMa,BMa,DMa,FMa,HMa,JMa,LMa,NMa,PMa,RMa,TMa,VMa,XMa,ZMa,aNa,cNa,eNa,gNa,iNa,kNa,mNa,oNa,qNa,sNa,uNa,wNa,yNa,ANa,CNa,ENa,GNa,INa,KNa,MNa,ONa,QNa,SNa,UNa,WNa,YNa,$Na,bOa,dOa,fOa,hOa,jOa,lOa,nOa,pOa,rOa,tOa,vOa,xOa,zOa,BOa,DOa,FOa,HOa,JOa,LOa,NOa,POa,ROa,TOa,VOa,XOa,ZOa,aPa,cPa,ePa,gPa,iPa,kPa,mPa,oPa,qPa,sPa,uPa,wPa,yPa,APa,CPa,EPa,GPa,IPa,KPa,MPa,OPa,QPa,SPa,UPa,WPa, YPa,$Pa,bQa,dQa,fQa,hQa,jQa,lQa,nQa,pQa,rQa,tQa,vQa,xQa,zQa,BQa,DQa,FQa,HQa,JQa,LQa,NQa,PQa,RQa,TQa,VQa,XQa,ZQa,aRa,cRa,eRa,gRa,iRa,kRa,mRa,oRa,qRa,sRa,uRa,wRa,yRa,ARa,CRa,ERa,GRa,IRa,KRa,MRa,ORa,QRa,SRa,URa,WRa,YRa,$Ra,bSa,dSa,fSa,hSa,jSa,lSa,nSa,pSa,rSa,tSa,vSa,xSa,zSa,BSa,DSa,FSa,HSa,JSa,LSa,NSa,PSa,RSa,TSa,VSa,XSa,ZSa,aTa,cTa,eTa,gTa,iTa,kTa,mTa,oTa,qTa,sTa,uTa,wTa,yTa,ATa,CTa,ETa,GTa,ITa,KTa,MTa,OTa,QTa,STa,UTa,WTa,YTa,$Ta,bUa,dUa,fUa,hUa,jUa,lUa,nUa,pUa,rUa,tUa,vUa,xUa,zUa,BUa,DUa,FUa,HUa,JUa, LUa,NUa,PUa,RUa,TUa,VUa,XUa,ZUa,aVa,cVa,eVa,gVa,iVa,kVa,mVa,oVa,qVa,sVa,uVa,wVa,yVa,AVa,CVa,EVa,GVa,IVa,KVa,MVa,OVa,QVa,SVa,UVa,WVa,YVa,$Va,bWa,dWa,fWa,hWa,jWa,lWa,nWa,pWa,rWa,tWa,vWa,xWa,zWa,BWa,DWa,FWa,HWa,JWa,LWa,NWa,PWa,RWa,TWa,VWa,XWa,ZWa,aXa,cXa,eXa,gXa,iXa,kXa,mXa,oXa,qXa,sXa,uXa,wXa,yXa,AXa,CXa,EXa,GXa,IXa,(new A).e("etc._xor",JXa)]));this.a=(8|this.a)<<24>>24;return this}; function Bea(a){if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/TokenMapper.scala: 20");return a.Yi}function Cea(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-js/src/main/core/TokenMapper.scala: 18");return a.ij}SF.prototype.$classData=g({XH:0},!1,"org.nlogo.core.TokenMapper",{XH:1,d:1,v_:1});function dO(){}dO.prototype=new l;dO.prototype.constructor=dO;function eO(){}eO.prototype=dO.prototype; dO.prototype.RF=function(a){var b=wn(a),d=this.Dh();if(b===wn(d))b=!0;else{a:{b=0;for(d=fO(this.Dh(),0);;)if(kd(d)){if(d.$().xh().ba())break a;b=1+b|0;d=d.aa()}else break;b=-1}if(-1!==b){b=wn(a);a:{for(var d=0,e=fO(this.Dh(),0);;)if(kd(e)){if(e.$().xh().ba())break a;d=1+d|0;e=e.aa()}else break;d=-1}b=b>=d}else b=!1}if(b){b=this.Dh();d=B().s;for(a=gO(b,a,d);!a.z();){b=a.$();if(null===b)throw(new q).j(b);if(!b.la().Mi(b.pa()))return!1;a=a.aa()}return!0}return!1}; dO.prototype.LT=function(a){var b=this.Dh();a=this.Jl(a);var d=B().s;a=gO(b,a,d);b=function(){return function(a){if(null!==a)return a.la().$h(a.pa());throw(new q).j(a);}}(this);d=B().s;if(d===B().s)if(a===y())b=y();else{var d=a.$(),e=d=Cd(new Dd,b(d),y());for(a=a.aa();a!==y();){var f=a.$(),f=Cd(new Dd,b(f),y()),e=e.Ia=f;a=a.aa()}b=d}else{for(d=Mc(a,d);!a.z();)e=a.$(),d.Na(b(e)),a=a.aa();b=d.Da()}return b.zb("\n")}; dO.prototype.GV=function(a,b){var d=this.Dh(),e=B().s,d=hO(d,e);a=function(a,b){return function(a){if(null!==a){var d=a.la();a=a.Dc();return a<wn(b)?d.ii(Pi(b,a)):d.xh().Y()}throw(new q).j(a);}}(this,a);e=B().s;if(e===B().s)if(d===y())a=y();else{for(var e=d.$(),f=e=Cd(new Dd,a(e),y()),d=d.aa();d!==y();)var h=d.$(),h=Cd(new Dd,a(h),y()),f=f.Ia=h,d=d.aa();a=e}else{for(e=Mc(d,e);!d.z();)f=d.$(),e.Na(a(f)),d=d.aa();a=e.Da()}return this.Kl(a,b)};function iO(){this.Cn=null;this.a=this.AE=this.nE=0} iO.prototype=new l;iO.prototype.constructor=iO;iO.prototype.zq=function(){this.Cn.zq();Hm(this,jO(this))};function Em(a){gla(a.Cn,jO(a));Hm(a,jO(a))}function hla(a){var b=new iO;b.Cn=a;b.nE=65536;b.a=(1|b.a)<<24>>24;b.AE=0;b.a=(2|b.a)<<24>>24;return b}function Hm(a,b){a.AE=b;a.a=(2|a.a)<<24>>24}function Im(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/AutoGrowingBufferedReader.scala: 9");return a.AE} function jO(a){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/AutoGrowingBufferedReader.scala: 8");return a.nE}iO.prototype.cy=function(){if(0===Im(this)){this.Cn.zq();gla(this.Cn,jO(this)<<1);var a=this.Cn,b=jO(this);a.uv((new Vb).ia(b,b>>31));Hm(this,jO(this));this.nE=jO(this)<<1;this.a=(1|this.a)<<24>>24}a=this.Cn.cy();Hm(this,-1+Im(this)|0);return a}; iO.prototype.$classData=g({m0:0},!1,"org.nlogo.lex.AutoGrowingBufferedReader",{m0:1,d:1,Nia:1});function Xm(){this.nk=null;this.Zo=0;this.ab=null}Xm.prototype=new l;Xm.prototype.constructor=Xm;Xm.prototype.nba=function(a,b,d){this.nk=a;this.Zo=b;this.ab=d;return this};Xm.prototype.ta=function(){Em(this.nk);var a=-1!==this.nk.cy();this.nk.zq();return a};Xm.prototype.iU=function(a,b,d){Xm.prototype.nba.call(this,hla(a),b,d);return this}; function $ca(a){a=a.nk.cy();return-1===a?F():(new J).j((new af).Ra(65535&a))}Xm.prototype.$classData=g({n0:0},!1,"org.nlogo.lex.BufferedInputWrapper",{n0:1,d:1,Qia:1});function kO(){this.SU=null;this.kV=0;this.kT=null;this.a=0;this.ga=null}kO.prototype=new l;kO.prototype.constructor=kO; function bda(a){var b=new kO;if(null===a)throw Kg(Lg(),null);b.ga=a;b.SU=F();b.a=(1|b.a)<<24>>24;b.kV=0;b.a=(2|b.a)<<24>>24;b.kT=jm(pm(),(new A).e(ila(b),jla(b)),tb(new ub,function(){return function(a,b){b=null===b?0:b.X;if(null!==a){var f=a.la(),h=a.Dc();if(F()===f&&0===h&&123===b)return(new A).e((new A).e((new J).j((new af).Ra(123)),0),gm())}return null!==a&&(f=a.Dc(),0>f)?(new A).e((new A).e(F(),f),mm()):null!==a&&(f=a.Dc(),13===b||10===b)?(new A).e((new A).e((new J).j((new af).Ra(b)),f),hm()): null!==a&&(h=a.la(),f=a.Dc(),Vk(h)&&(h=h.U,125===(null===h?0:h.X)&&1===f&&125===b))?(new A).e((new A).e(F(),0),hm()):null!==a&&(h=a.la(),f=a.Dc(),Vk(h)&&(h=h.U,123===(null===h?0:h.X)&&123===b))?(new A).e((new A).e(F(),1+f|0),gm()):null!==a&&(h=a.la(),f=a.Dc(),Vk(h)&&(h=h.U,125===(null===h?0:h.X)&&125===b))?(new A).e((new A).e(F(),-1+f|0),gm()):null!==a&&(h=a.la(),f=a.Dc(),Vk(h)&&(h=h.U,h=null===h?0:h.X,0===f&&123!==h))?(new A).e((new A).e(F(),0),mm()):null!==a?(a=a.Dc(),(new A).e((new A).e((new J).j((new af).Ra(b)), a),gm())):(new A).e((new A).e(F(),0),mm())}}(b)));b.a=(4|b.a)<<24>>24;return b}c=kO.prototype;c.y=function(a){return kla(this,null===a?0:a.X)};function jla(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/TokenLexer.scala: 48");return a.kV}c.k=function(){return"\x3cfunction1\x3e"};c.Fa=function(a){return!!kla(this,a.X)}; function kla(a,b){if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/TokenLexer.scala: 49");return a.kT.y((new af).Ra(b))}function ila(a){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/lex/TokenLexer.scala: 47");return a.SU}c.Ca=function(a){return qb(this,a)};c.$classData=g({u0:0},!1,"org.nlogo.lex.TokenLexer$DoubleBracePairMatcher",{u0:1,d:1,fa:1});function lO(){}lO.prototype=new l; lO.prototype.constructor=lO;lO.prototype.b=function(){return this};function Sp(a,b,d){var e=new mO,f;nO||(nO=(new oO).b());f=nO;gda||(gda=(new Um).b());b=lla(e,f,dda(b,d));return(new bc).Gf(b,m(new n,function(){return function(a){return a.la()}}(a)))}lO.prototype.$classData=g({v0:0},!1,"org.nlogo.lex.Tokenizer$",{v0:1,d:1,Mia:1});var pO=void 0;function qO(){this.ga=this.h=null}qO.prototype=new l;qO.prototype.constructor=qO; function mla(a){a:for(;;){var b=a.pe.G().Aq;if(Uj(D())===b||Rj(D())===b)return"-T--";if(Vj(D())===b||Sj(D())===b)return"--P-";if(Wj(D())===b||Tj(D())===b)return"---L";if(Lj(D())===b||Qj(D())===b)if(a=a.za,r(),a=(new J).j(a),null!==a.U&&0<=a.U.Rb(1)&&(a=a.U.W(0),xb(a)))continue a;return"-TPL"}} function nla(a,b,d){d.wa(m(new n,function(a,b,d){return function(k){if(yb(k)||zb(k)){if("?"!==b)var p=b;else a:{r();p=(new J).j(d);if(null!==p.U&&0<=p.U.Rb(1)&&(p=p.U.W(0),xb(p))){p=mla(p);break a}p="-TPL"}p=Zm(a.ga,p)}else p=a;Nb(p,k)}}(a,b,d)))}function ola(a){return 111===(65535&(a.charCodeAt(0)|0))?u((new v).K((new w).f(["an ",""])),(new w).f([a])):u((new v).K((new w).f(["a ",""])),(new w).f([a]))} qO.prototype.MY=function(a){var b=a.xd;this.h=pla(b,this.h);a=a.za;var d=b.G().Pa,e=r();a=a.De(d,e.s);d=new rO;e=r();a=a.ic(d,e.s);b.G().p.ba()?nla(this,b.G().p.Y(),a):a.wa(m(new n,function(a){return function(b){Nb(a,b)}}(this)));b.M(this.h)}; function sO(a,b,d){var e;e=(new Sb).c(b);for(var f=$e().zp,f=Mc(e,f),h=0,k=e.R.length|0;h<k;){var p=e.W(h),p=null===p?0:p.X,p=45!==p&&-1!==Ew(Ia(),d,p)?p:45;f.Na((new af).Ra(p));h=1+h|0}e=f.Da();"----"===e&&(f=a.H().Wb.toUpperCase(),kh(),Ia(),b=u((new v).K((new w).f(["|You can't use "," in "," context,\n              | because "," is ","-only."])),(new w).f([f,ola(qla(b)),f,qla(d)])),b=(new Sb).c(b),b=Qb(0,dd(b),"\n",""),a=a.H().ra,jh(b,a.Xa,a.Va,a.ab));return e} function Zm(a,b){var d=new qO;d.h=b;if(null===a)throw Kg(Lg(),null);d.ga=a;return d}function pla(a,b){return Ir(a)?sO(a,b,a.Kh.N()):Lt(a)?sO(a,b,a.Kh.N()):sO(a,b,a.N())} qO.prototype.VF=function(a){var b=a.pe;this.h=pla(b,this.h);if(An(b.G()))var d=b.G().Wa,e=b.G().Pa,f=B(),e=e.fd(d,f.s);else e=b.G().Pa;a:{d=0;for(e=fO(e,0);;)if(kd(e)){f=e.$()|0;if(Gn(D(),Jj(),f))break a;d=1+d|0;e=e.aa()}else break;d=-1}e=a.za;f=r();d=e.sj(f.s).Pf(m(new n,function(a,b){return function(a){if(null!==a)return a.Dc()!==b;throw(new q).j(a);}}(this,d)));e=m(new n,function(){return function(a){return a.la()}}(this));f=r();e=d.xa(e,f.s);d=Zm(this.ga,"OTPL");Fo(b)||Rt(b)?(a=a.za.$(),Nb(d, a)):b.G().p.ba()?nla(this,b.G().p.Y(),e):e.wa(m(new n,function(a){return function(b){Nb(a,b)}}(this)));Fo(b)||Rt(b)?b.P((new J).j(d.h)):b.M(this.h)}; function qla(a){for(var b=(new af).Ra(79),b=(new A).e(b,"observer"),d=(new af).Ra(84),d=(new A).e(d,"turtle"),e=(new af).Ra(80),e=(new A).e(e,"patch"),f=(new af).Ra(76),b=[b,d,e,(new A).e(f,"link")],d=dc(new ec,gc()),e=0,f=b.length|0;e<f;)hc(d,b[e]),e=1+e|0;b=d.Ma;a=(new Sb).c(a);d=(new Fm).b();e=0;for(f=a.R.length|0;e<f;){var h=a.W(e);45!==(null===h?0:h.X)!==!1&&tO(d,null===h?0:h.X);e=1+e|0}a=(new Sb).c(d.vc.Zb);$e();d=Mc(a,new em);e=0;for(f=a.R.length|0;e<f;)h=a.W(e),d.Na(b.y((new af).Ra(null=== h?0:h.X))),e=1+e|0;return d.Da().zb("/")}qO.prototype.$classData=g({A0:0},!1,"org.nlogo.parse.AgentTypeChecker$AgentTypeCheckerVisitor",{A0:1,d:1,kZ:1});function Lo(){this.xy=null;this.a=!1}Lo.prototype=new l;Lo.prototype.constructor=Lo;c=Lo.prototype;c.b=function(){this.xy=(B(),y());this.a=!0;return this};function uO(a){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/CarefullyVisitor.scala: 15");return a.xy} c.vh=function(a){var b=a.xd;if(Ar(b)){var d=a.za.W(0),d=Ab(this,d),e=uO(this);this.xy=Cd(new Dd,b,e);this.a=!0;b=a.za.W(1);b=Ab(this,b);this.xy=uO(this).aa();this.a=!0;d=I(r(),(new w).f([d,b]));return(new Hb).cj(a.xd,d,a.ra)}return Gb(this,a)}; c.Cg=function(a){var b=a.pe;if(Pt(b)){if(uO(this).z()){kh();var d=rh(),e=[b.H().Wb],d=d.Vl.dc("compiler.CarefullyVisitor.badNesting");if(!Vk(d)){if(F()===d)throw(new df).c(u((new v).K((new w).f(["coding error, bad translation key: "," for Errors"])),(new w).f(["compiler.CarefullyVisitor.badNesting"])));throw(new q).j(d);}var f=d.U,h=e.length|0;if(0>=h)var k=0;else d=h>>31,k=(0===d?-1<(-2147483648^h):0<d)?-1:h;r();Zn();var d=[],p=0,t=e.length|0;0>k&&$n(ao(),0,h,1,!1);for(t=t<k?t:k;p<t;){var x=e[p], E=p;0>k&&$n(ao(),0,h,1,!1);if(0>E||E>=k)throw(new P).c(""+E);x=(new A).e(x,E);d.push(x);p=1+p|0}e=d.length|0;h=0;k=f;a:for(;;){if(h!==e){f=1+h|0;k=(new A).e(k,d[h]);b:{h=k.kb;t=k.Ab;if(null!==t&&(p=t.la(),t=t.Dc(),Qg(p))){k=p;k=Qb(Ia(),h,u((new v).K((new w).f(["\\\\{","\\\\}"])),(new w).f([""+t])),k);break b}throw(new q).j(k);}h=f;continue a}break}d=a.ra;jh(k,d.Xa,d.Va,d.ab)}d=jd().Uc(Yea(uO(this).$()));d=(new FH).Ha(d);b=Fh(b,d);return(new Kb).Qf(b,a.za,a.ra)}return Jb(this,a)}; c.$g=function(a){return Lb(this,a)};c.$classData=g({I0:0},!1,"org.nlogo.parse.CarefullyVisitor",{I0:1,d:1,ah:1});function vO(){this.RU=null}vO.prototype=new l;vO.prototype.constructor=vO;function laa(a,b,d){var e=b.pe;if(nr(e))return d.pi((new wO).ks(e.Wc));if(Go(e)){var f=e.va;if(!a.RU.ib(f))return d.pi((new xO).c(f))}return qc(e)&&(Lca||(Lca=(new Vl).b()),e=(new J).j((new ac).ae(e.ve.lk(),yO(e.ve),e.ok)),!e.z())?(a=e.Y().og,d.qp(a)):naa(a,b,d)}vO.prototype.K=function(a){this.RU=a;return this}; vO.prototype.$classData=g({J0:0},!1,"org.nlogo.parse.ClosedVariableFinder",{J0:1,d:1,Aia:1});function Mo(){}Mo.prototype=new l;Mo.prototype.constructor=Mo;c=Mo.prototype;c.b=function(){return this};c.vh=function(a){return Gb(this,a)}; c.Cg=function(a){var b=a.pe;if(Rt(b)){a=Jb(this,a);var d=(new vO).K(b.ve.lk()),e=a.za.W(0),f=I($e().pt,y()),d=wb(d,e,f),b=rla(b,b.ve,d,b.uc);return(new Kb).Qf(b,a.za,a.ra)}return Fo(b)?(a=Jb(this,a),d=(new vO).K(b.ve.lk()),e=a.za.W(0),f=I($e().pt,y()),d=wb(d,e,f),b=sla(b,b.ve,d,b.uc),(new Kb).Qf(b,a.za,a.ra)):Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({K0:0},!1,"org.nlogo.parse.ClosureTagger",{K0:1,d:1,ah:1});function zO(){this.a=!1}zO.prototype=new l; zO.prototype.constructor=zO;zO.prototype.b=function(){AO=this;for(var a=(new af).Ra(38),a=(new A).e(a,"\x26amp;"),b=(new af).Ra(60),b=(new A).e(b,"\x26lt;"),d=(new af).Ra(62),d=(new A).e(d,"\x26gt;"),e=(new af).Ra(34),a=[a,b,d,(new A).e(e,"\x26quot;")],b=dc(new ec,gc()),d=0,e=a.length|0;d<e;)hc(b,a[d]),d=1+d|0;this.a=!0;return this};zO.prototype.$classData=g({L0:0},!1,"org.nlogo.parse.Colorizer$",{L0:1,d:1,Lia:1});var AO=void 0;function Po(){this.yC=this.UB=null;this.a=!1}Po.prototype=new l; Po.prototype.constructor=Po;c=Po.prototype;c.b=function(){this.yC=y();this.a=!0;return this}; c.vh=function(a){if(Jr(a.xd)||BO(a.xd)||Kr(a.xd)){var b=CO(this).$().nx(),d=CO(this).aa();DO(this,Cd(new Dd,b,d))}b=CO(this).$();d=a.xd;if(b&&b.$classData&&b.$classData.n.$A&&BO(d)){kh();var e=["STOP"],b=rh().Vl.dc("org.nlogo.prim.etc._stop.notAllowedInsideToReport");if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f(["coding error, bad translation key: "," for Errors"])),(new w).f(["org.nlogo.prim.etc._stop.notAllowedInsideToReport"])));throw(new q).j(b);}var d=b.U,f=e.length|0;if(0>=f)var h= 0;else b=f>>31,h=(0===b?-1<(-2147483648^f):0<b)?-1:f;r();Zn();var b=[],k=0,p=e.length|0;0>h&&$n(ao(),0,f,1,!1);for(p=p<h?p:h;k<p;){var t=e[k],x=k;0>h&&$n(ao(),0,f,1,!1);if(0>x||x>=h)throw(new P).c(""+x);t=(new A).e(t,x);b.push(t);k=1+k|0}e=b.length|0;f=0;h=d;a:for(;;){if(f!==e){d=1+f|0;h=(new A).e(h,b[f]);b:{f=h.kb;p=h.Ab;if(null!==p&&(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),f,u((new v).K((new w).f(["\\\\{","\\\\}"])),(new w).f([""+p])),h);break b}throw(new q).j(h);}f=d;continue a}break}a=a.ra;jh(h, a.Xa,a.Va,a.ab)}else if(Jr(d)?(e=CO(this),e=EO(zn(e))?!tla(CO(this).$()):!1):e=!1,e){kh();e=["REPORT"];b=rh().Vl.dc("org.nlogo.prim._report.canOnlyUseInToReport");if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f(["coding error, bad translation key: "," for Errors"])),(new w).f(["org.nlogo.prim._report.canOnlyUseInToReport"])));throw(new q).j(b);}d=b.U;f=e.length|0;0>=f?h=0:(b=f>>31,h=(0===b?-1<(-2147483648^f):0<b)?-1:f);r();Zn();b=[];k=0;p=e.length|0;0>h&&$n(ao(),0,f,1,!1);for(p=p<h?p: h;k<p;){t=e[k];x=k;0>h&&$n(ao(),0,f,1,!1);if(0>x||x>=h)throw(new P).c(""+x);t=(new A).e(t,x);b.push(t);k=1+k|0}e=b.length|0;f=0;h=d;a:for(;;){if(f!==e){d=1+f|0;h=(new A).e(h,b[f]);b:{f=h.kb;p=h.Ab;if(null!==p&&(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),f,u((new v).K((new w).f(["\\\\{","\\\\}"])),(new w).f([""+p])),h);break b}throw(new q).j(h);}f=d;continue a}break}a=a.ra;jh(h,a.Xa,a.Va,a.ab)}else if((b&&b.$classData&&b.$classData.n.YA||EO(b))&&Jr(d)){kh();e=["REPORT"];b=rh().Vl.dc("org.nlogo.prim._report.mustImmediatelyBeUsedInToReport"); if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f(["coding error, bad translation key: "," for Errors"])),(new w).f(["org.nlogo.prim._report.mustImmediatelyBeUsedInToReport"])));throw(new q).j(b);}d=b.U;f=e.length|0;0>=f?h=0:(b=f>>31,h=(0===b?-1<(-2147483648^f):0<b)?-1:f);r();Zn();b=[];k=0;p=e.length|0;0>h&&$n(ao(),0,f,1,!1);for(p=p<h?p:h;k<p;){t=e[k];x=k;0>h&&$n(ao(),0,f,1,!1);if(0>x||x>=h)throw(new P).c(""+x);t=(new A).e(t,x);b.push(t);k=1+k|0}e=b.length|0;f=0;h=d;a:for(;;){if(f!==e){d= 1+f|0;h=(new A).e(h,b[f]);b:{f=h.kb;p=h.Ab;if(null!==p&&(k=p.la(),p=p.Dc(),Qg(k))){h=k;h=Qb(Ia(),f,u((new v).K((new w).f(["\\\\{","\\\\}"])),(new w).f([""+p])),h);break b}throw(new q).j(h);}f=d;continue a}break}a=a.ra;jh(h,a.Xa,a.Va,a.ab)}else return a.xd.G().rs?(b=(new FO).uk(this,!1),d=CO(this),DO(this,Cd(new Dd,b,d)),b=Gb(this,a),d=CO(this).$(),DO(this,CO(this).aa()),a=a.za,d=m(new n,function(a,b){return function(a){return yb(a)?Bb(new Cb,(new Fb).ns(a.fe.Yr,a.fe.Zf,b.oe),a.ra,a.qj):a}}(this,d)), e=r(),a=a.xa(d,e.s),(new Hb).cj(b.xd,a,b.ra)):Gb(this,a)};function ula(a){if(null===a.UB&&null===a.UB){var b=new GO;if(null===a)throw Kg(Lg(),null);b.Sa=a;a.UB=b}}c.Cg=function(a){if(Fo(a.pe)){var b=(new HO).uk(this,!1),d=CO(this);DO(this,Cd(new Dd,b,d));a=Jb(this,a);DO(this,CO(this).aa());return a}return Jb(this,a)};function CO(a){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/ControlFlowVerifier.scala: 31");return a.yC} function DO(a,b){a.yC=b;a.a=!0}c.$g=function(a){if(a.ji.$u.jn)var b=(new IO).uk(this,(ula(this),!0)),d=CO(this);else b=(new JO).uk(this,!1),d=CO(this);b=Cd(new Dd,b,d);DO(this,b);a=Lb(this,a);b=CO(this).$();DO(this,CO(this).aa());return Mb(a.ji,(new Fb).ns(a.fe.Yr,a.fe.Zf,b.oe),a.bz)};c.$classData=g({P0:0},!1,"org.nlogo.parse.ControlFlowVerifier",{P0:1,d:1,ah:1});function KO(){}KO.prototype=new l;KO.prototype.constructor=KO;KO.prototype.b=function(){return this}; function Kaa(a){return m(new n,function(a){return function(d){return m(new n,function(a,b){return function(a){return Sc(b,a)}}(a,d))}}(a))} function Yc(a,b,d,e){var f=e.Uj.dc(d);f.z()?f=F():(f=f.Y(),f=(new J).j(Rc(f,a,b,d,e)));if(f.z()){var f=Sc(e.pf,d),h=(new A).e(An(b.pe.G()),b.pe),k=h.Ab;if(!0===!!h.kb){h=b.za.$();h=Nc(a,h,d,0,e);b=b.za;var p=r();return b.sj(p.s).aa().Gb(Tc(Uc(h),""+f+e.am.y(k)),tb(new ub,function(a,b){return function(d,e){d=(new A).e(d,e);e=d.kb;var f=d.Ab;if(null!==f)return Nc(a,f.la(),b,f.Dc(),e);throw(new q).j(d);}}(a,d)))}if(vla(h.Ab))return e=Tc(Uc(e),""+Sc(e.pf,d)+wla(e.pf,d)),Oc(a,b,d,e);k=h.Ab;if(!1===!!h.kb&& Do(k))return e=Tc(Uc(e),""+Sc(e.pf,d)+wla(e.pf,d)),Oc(a,b,d,e);k=h.Ab;if(!1===!!h.kb&&qc(k)){f=(new Sb).c(e.Wb);f=LO(f);f.z()?f=!0:(f=f.Y(),f=32===(null===f?0:f.X));f=f?"":" ";h=e.Uj;p=e.pf;Wda();h=Vda(Ho(),h,p);b=Oc(a,b,d,h).Wb;var h=!1,p=null,t=k.ve;a:{if(t&&t.$classData&&t.$classData.n.Qz&&(h=!0,p=t,!0===p.cr)){a="[ -\x3e";break a}if(h&&!1===p.cr)a="[";else if(yO(t))a="";else if(t&&t.$classData&&t.$classData.n.Rz)a=t.li,a=u((new v).K((new w).f(["[ "," -\x3e"])),(new w).f([a.Wb]));else if(t&&t.$classData&& t.$classData.n.Pz)h=t.yr,p=(new v).K((new w).f(["[ [","] -\x3e"])),a=m(new n,function(){return function(a){return a.Wb}}(a)),t=r(),a=u(p,(new w).f([h.xa(a,t.s).zb(" ")]));else throw(new q).j(t);}h=!Wp(Ia(),a,"\x3e")||0<=(b.length|0)&&" "===b.substring(0,1)?"":" ";p=$c(e.pf,d);d=yO(k.ve)?"":"]";k=(new Sb).c(b);LO(k).ib((new af).Ra(32))?(k=(new Sb).c(p),k=Uk(k).ib((new af).Ra(32))):k=!1;k?(k=(new Sb).c(p),p=k.R.length|0,k=Ye(Ze(),k.R,1,p)):k=p;return Tc(Uc(e),f+a+h+b+k+d)}k=h.Ab;if(!1===!!h.kb)return f= Tc(Uc(e),""+f+e.am.y(k)),d=Oc(a,b,d,f),Vc(new Wc,d.Wb,d.Uj,e.am,d.pf);throw(new q).j(h);}return f.Y()}function Laa(a){return m(new n,function(a){return function(d){return m(new n,function(a,b){return function(a){return $c(b,a)}}(a,d))}}(a))}KO.prototype.$classData=g({U0:0},!1,"org.nlogo.parse.Formatter",{U0:1,d:1,Xia:1});function MO(){this.yy=null}MO.prototype=new l;MO.prototype.constructor=MO; function wla(a,b){a=NO(a.yy,b.Fj);return Vk(a)&&(a=a.U,xb(a))?(b=a.pe,Do(b)&&(a=b.X,Zg(a))?(b=Eo(),$b(b,a,!0,!1)):b.H().Wb):""}function $c(a,b){var d=!1,e=null,f=b.Fj.nn();return Vk(f)&&(d=!0,e=f,OO(e.U))?(b=(new PO).K(b.Fj.Qd(1)),a=NO(a.yy,b.Fj),Vk(a)&&(a=a.U,xb(a)&&(a=vi().Yd(a),!a.z()&&(a=a.Y().gb,Fo(a))))?" ":" ]"):d&&QO(e.U)?" ]":" "} function Sc(a,b){var d=!1,e=null,f=b.Fj.nn();return Vk(f)&&(d=!0,e=f,RO(e.U))||d&&SO(e.U)?" ":d&&(f=e.U,OO(f))?(d=f.sc,e=!1,f=null,b=(new PO).K(b.Fj.Qd(1)),a=NO(a.yy,b.Fj),Vk(a)&&(e=!0,f=a,a=f.U,xb(a)&&(a=vi().Yd(a),!a.z()&&(a=a.Y().gb,Fo(a))))||e&&(a=f.U,GF(a)&&(d=a.za.W(d),yb(d)&&d.qj))?"":" ["):d&&QO(e.U)?" [":""}function xla(a){var b=new MO;b.yy=a;return b}MO.prototype.$classData=g({Y0:0},!1,"org.nlogo.parse.LambdaWhitespace",{Y0:1,d:1,Sia:1});function wc(){}wc.prototype=new l; wc.prototype.constructor=wc;wc.prototype.b=function(){return this};wc.prototype.qU=function(){return!1};wc.prototype.wY=function(a,b){a:{b=!!b;if(null!==a){var d=a.jb;if(Cm()===d&&b){b=(new TO).b();d=vg();a=(new A).e(Gh(a,b,a.Wb,d),!1);break a}}b:{if(null!==a&&(b=a.jb,d=a.X,Cm()===b&&"LET"===d)){b=!0;break b}if(null!==a&&(b=a.jb,d=a.X,Cm()===b&&"__LET"===d)){b=!0;break b}b=!1}a=b?(new A).e(a,!0):(new A).e(a,!1)}return a};wc.prototype.$classData=g({Z0:0},!1,"org.nlogo.parse.LetNamer$",{Z0:1,d:1,W1:1}); var vc=void 0;function Ko(){}Ko.prototype=new l;Ko.prototype.constructor=Ko;c=Ko.prototype;c.b=function(){return this};c.vh=function(a){if(no(a.xd)){var b=a.za.aa();return Gb(this,(new Hb).cj(a.xd,b,a.ra))}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({$0:0},!1,"org.nlogo.parse.LetReducer",{$0:1,d:1,ah:1});function Oo(){this.dx=null;this.a=!1}Oo.prototype=new l;Oo.prototype.constructor=Oo;Oo.prototype.b=function(){this.dx=F();this.a=!0;return this}; Oo.prototype.MY=function(a){var b=a.xd;no(b)?(this.dx=b.Wc,this.a=!0,paa(this,a),this.dx=F(),this.a=!0):paa(this,a)};function yla(a){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/LetVerifier.scala: 13");return a.dx} Oo.prototype.VF=function(a){var b=a.pe;if(nr(b)){kh();var d=yla(this).z()||yla(this).Y()!==b.Wc,e=b.H();if(!d){var f=rh(),d=[b.H().Wb.toUpperCase()],b=f.Vl.dc("compiler.LetVariable.notDefined");if(!Vk(b)){if(F()===b)throw(new df).c(u((new v).K((new w).f(["coding error, bad translation key: "," for Errors"])),(new w).f(["compiler.LetVariable.notDefined"])));throw(new q).j(b);}var f=b.U,h=d.length|0;if(0>=h)var k=0;else b=h>>31,k=(0===b?-1<(-2147483648^h):0<b)?-1:h;r();Zn();var b=[],p=0,t=d.length| 0;0>k&&$n(ao(),0,h,1,!1);for(t=t<k?t:k;p<t;){var x=d[p],E=p;0>k&&$n(ao(),0,h,1,!1);if(0>E||E>=k)throw(new P).c(""+E);x=(new A).e(x,E);b.push(x);p=1+p|0}d=b.length|0;h=0;k=f;a:for(;;){if(h!==d){f=1+h|0;k=(new A).e(k,b[h]);b:{h=k.kb;t=k.Ab;if(null!==t&&(p=t.la(),t=t.Dc(),Qg(p))){k=p;k=Qb(Ia(),h,u((new v).K((new w).f(["\\\\{","\\\\}"])),(new w).f([""+t])),k);break b}throw(new q).j(k);}h=f;continue a}break}e=e.ra;jh(k,e.Xa,e.Va,e.ab)}}qaa(this,a)}; Oo.prototype.$classData=g({d1:0},!1,"org.nlogo.parse.LetVerifier",{d1:1,d:1,kZ:1});function yc(){this.hh=this.ji=this.ce=this.ec=this.bj=null;this.ya=!1}yc.prototype=new l;yc.prototype.constructor=yc; function Eaa(a){var b=UO(a.ji),d=Aaa(a.ji),e=r();d.fd(b,e.s).wa(m(new n,function(a){return function(b){var d=zla(a,b);d.z()?d=F():(d=d.Y(),d=(new J).j(d.X));var d=d.Y(),e=Ir(d)||Lt(d)||qr(d);kh();e||(d=Mr(d)?"an extension command":St(d)?"an extension reporter":u((new v).K((new w).f(["a ",""])),(new w).f([Uq(oa(d))])),e=b.Wb.toUpperCase(),b=b.ra,jh("There is already "+d+" called "+e,b.Xa,b.Va,b.ab))}}(a)))} function Ala(a){if(!a.ya){var b=r(),d=(new VO).tD(Mp(a.ec.ug));a.bj=I(b,(new w).f([d,(new WO).tD(Mp(a.ec.ug)),(new XO).pD(a.ec),(new YO).pD(a.ec),Bla(a.hh),(new ZO).K(sc(a.ji)),(new $O).$b(a.ce)]));a.ya=!0}a.ce=null;a.hh=null;return a.bj}yc.prototype.qU=function(){}; function zla(a,b){var d=a.ya?a.bj:Ala(a);a=m(new n,function(a,b){return function(a){return a.y(b).ub()}}(a,b));var e=r(),d=d.aj(a,e.s).wg();if(d.z())return F();a=d.Y();if(null!==a)d=a.pa(),b=Jm(new Km,b.Wb,a.la(),d,b.ra),d.L(b);else throw(new q).j(a);return(new J).j(b)}yc.prototype.wY=function(a){var b=a.jb;if(Cm()===b)if(b=zla(this,a),b.z()){var b=(new aP).b(),d=vg();a=Gh(a,b,a.Wb,d)}else a=b.Y();a=(new A).e(a,void 0);return a}; yc.prototype.$classData=g({f1:0},!1,"org.nlogo.parse.Namer",{f1:1,d:1,W1:1});function bP(){}bP.prototype=new l;bP.prototype.constructor=bP;c=bP.prototype;c.b=function(){return this};c.y=function(a){return Cla(a)}; function Cla(a){var b=a.jb,d=Om();if(null!==b&&b===d)throw(new hd).Ff(a);Ih||(Ih=(new Hh).b());b=a.Wb;d=Ih;if(!d.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Keywords.scala: 8");if(d.QU.ib(b.toUpperCase())||Wp(Ia(),b.toUpperCase(),"-OWN"))b=cP(),a=Jm(new Km,a.Wb,b,a.X,a.ra);else if(on||(on=(new nn).b()),b=on.es(a.Wb),Vk(b))b=b.U,d=Rm(),a=Jm(new Km,a.Wb,d,b,a.ra);else if(F()!==b)throw(new q).j(b);return a}c.k=function(){return"\x3cfunction1\x3e"}; c.Fa=function(a){return!!Cla(a)};c.Ca=function(a){return qb(this,a)};c.$classData=g({g1:0},!1,"org.nlogo.parse.Namer0$",{g1:1,d:1,fa:1});var dP=void 0;function Tp(){dP||(dP=(new bP).b());return dP}function eP(){this.zG=null;this.a=!1}eP.prototype=new l;eP.prototype.constructor=eP;eP.prototype.b=function(){this.zG="Can only have literal agents and agentsets if importing.";this.a=!0;return this}; function Yda(a){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/NullImportHandler.scala: 10");return a.zG}eP.prototype.$classData=g({h1:0},!1,"org.nlogo.parse.NullImportHandler$",{h1:1,d:1,Iia:1});var fP=void 0;function Dda(){fP||(fP=(new eP).b());return fP}function gP(){this.za=this.h=this.va=this.zS=this.iV=this.$u=null;this.a=0}gP.prototype=new l;gP.prototype.constructor=gP;gP.prototype.M=function(a){this.h=a;this.a=(8|this.a)<<24>>24}; function Caa(a,b){a.za=b;a.a=(16|a.a)<<24>>24}function UO(a){if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 12");return a.iV}function Aaa(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 13");return a.zS} gP.prototype.me=function(){if(0===(4&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 21");return this.va};function sc(a){if(0===(16&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 9");return a.za} function Dla(a){var b=new gP;b.$u=a;Baa(b);b.iV=a.ni.aa().$();b.a=(1|b.a)<<24>>24;var d=a.fn,e=m(new n,function(){return function(a){return a.g}}(b)),f=r();b.zS=d.xa(e,f.s);b.a=(2|b.a)<<24>>24;a=a.fn;d=m(new n,function(){return function(a){return a.va}}(b));e=r();Caa(b,a.xa(d,e.s).mg());b.va=UO(b).X;b.a=(4|b.a)<<24>>24;return b}gP.prototype.N=function(){if(0===(8&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/parse/RawProcedure.scala: 9");return this.h}; gP.prototype.$classData=g({k1:0},!1,"org.nlogo.parse.RawProcedure",{k1:1,d:1,Hia:1});function Me(){this.ZC=this.ym=null}Me.prototype=new pka;Me.prototype.constructor=Me;function pba(a,b,d){a.ym=b;a.ZC=d;return a}function hP(a){return a.ym.z()?Ela(new iP,a,2147483647):Ela(new iP,a,a.ZC.y(a.ym.$())|0)}Me.prototype.$classData=g({m1:0},!1,"org.nlogo.parse.SeqReader",{m1:1,Qoa:1,d:1});function No(){}No.prototype=new l;No.prototype.constructor=No;No.prototype.vh=function(a){return Gb(this,a)}; No.prototype.Cg=function(a){var b=a.pe;if(qc(b)){var d=Jb(this,a);a=Yc((new KO).b(),d,(new PO).K(y()),Vc(new Wc,"",nh($e().kk,y()),m(new n,function(){return function(a){return Co(Ho(),a)}}(this)),xla(a))).Wb.trim();if(Rt(b))a=(new J).j(a),b=rla(b,b.ve,b.ok,a);else{if(!Fo(b))throw(new q).j(b);a=(new J).j(a);b=sla(b,b.ve,b.ok,a)}return(new Kb).Qf(b,d.za,d.ra)}return Jb(this,a)};No.prototype.$g=function(a){return Lb(this,a)}; No.prototype.$classData=g({o1:0},!1,"org.nlogo.parse.SourceTagger",{o1:1,d:1,ah:1});function yp(){this.Dw=this.NW=null;this.ya=!1}yp.prototype=new l;yp.prototype.constructor=yp;function jP(a){return kP(lP(a,"identifier",Cm()),m(new n,function(){return function(a){return mP(a.X,a)}}(a)))}yp.prototype.b=function(){return this}; function Fla(a){return kP(nP(oP(a,"UNDIRECTED-LINK-BREED"),K(function(a){return function(){return pP(a,"UNDIRECTED-LINK-BREED")}}(a))),m(new n,function(){return function(a){var d=a.Fb.ql,e=a.Fb.Bf;a.Fb;return qP(d,e,!0,!1)}}(a)))}function Gla(a){return kP(nP(Le(a,"\x3cbreed\x3e-own",(new rP).dq(a)),K(function(a){return function(){return sP(a)}}(a))),m(new n,function(){return function(a){if(null!==a){var d=a.gb,e=new tP,d=mP(d.X,d);a=a.Fb;e.zg=d;e.If=a;return e}throw(new q).j(a);}}(a)))} function pP(a,b){var d=kP(jP(a).er(K(function(a){return function(){return jP(a)}}(a))),m(new n,function(){return function(a){if(null!==a)return qP(a.gb,a.Fb,!1,!1);throw(new q).j(a);}}(a)));b=Ue(jP(a),m(new n,function(a,b){return function(d){d=u((new v).K((new w).f(["Breed declarations must have plural and singular. "," [","] has only one name."])),(new w).f([b,d.va]));return Je(a,d)}}(a,b)));return uP(vP(lP(a,"opening bracket",Am()),K(function(a,b,d){return function(){return Re(b,K(function(a,b){return function(){return b}}(a, d)))}}(a,d,b))),K(function(a){return function(){return lP(a,"closing bracket",Bm())}}(a)))}function Hla(a){return vP(lP(a,"opening bracket",Am()),K(function(a){return function(){return De(a,K(function(a){return function(){return uP(Qe(a,K(function(a){return function(){return Le(a,"string",(new wP).dq(a))}}(a))),K(function(a){return function(){return lP(a,"closing bracket",Bm())}}(a)))}}(a)))}}(a)))}function lP(a,b,d){var e=new xP;e.LF=d;return Le(a,b,e)} function rea(a){null===a.Dw&&null===a.Dw&&(a.Dw=(new mD).To(a));return a.Dw}function oP(a,b){var d=new yP;d.qq=b;return Le(a,b,d)}function pea(a){var b=Qe(a,K(function(a){return function(){return Ila(a)}}(a))).er(K(function(a){return function(){return Re(Jla(a),K(function(a){return function(){return Kla(a)}}(a)))}}(a)));return kP(Lla(a,b),m(new n,function(){return function(a){if(null!==a){var b=a.gb;a=a.Fb;var f=B();return b.Rc(a,f.s)}throw(new q).j(a);}}(a)))} function Mla(a){return kP(nP(oP(a,"EXTENSIONS"),K(function(a){return function(){return sP(a)}}(a))),m(new n,function(){return function(a){if(null!==a)return(new zP).uD(a.gb,a.Fb);throw(new q).j(a);}}(a)))}function Nla(a){return kP(nP(Le(a,"BREED",(new AP).dq(a)),K(function(a){return function(){return pP(a,"BREED")}}(a))),m(new n,function(){return function(a){return a.Fb}}(a)))} function Ila(a){return Re(Re(Re(Re(Re(Re(Re(Re(Re(Ola(a),K(function(a){return function(){return Mla(a)}}(a))),K(function(a){return function(){return Nla(a)}}(a))),K(function(a){return function(){return Pla(a)}}(a))),K(function(a){return function(){return Fla(a)}}(a))),K(function(a){return function(){return BP(a,"GLOBALS")}}(a))),K(function(a){return function(){return BP(a,"TURTLES-OWN")}}(a))),K(function(a){return function(){return BP(a,"PATCHES-OWN")}}(a))),K(function(a){return function(){return BP(a, "LINKS-OWN")}}(a))),K(function(a){return function(){return Gla(a)}}(a)))}function Jla(a){var b=K(function(a){return function(){return Qla(a)}}(a));return uP(qba(a,b,b),K(function(a){return function(){return Re(lP(a,"eof",Dc()),K(function(a){return function(){return Je(a,"TO or TO-REPORT expected")}}(a)))}}(a)))}function CP(a){a.ya||a.ya||(a.NW=(new TC).j(F()),a.ya=!0);return a.NW} function sP(a){return vP(lP(a,"opening bracket",Am()),K(function(a){return function(){return De(a,K(function(a){return function(){return uP(Qe(a,K(function(a){return function(){return jP(a)}}(a))),K(function(a){return function(){return lP(a,"closing bracket",Bm())}}(a)))}}(a)))}}(a)))} function BP(a,b){return kP(nP(oP(a,b),K(function(a){return function(){return sP(a)}}(a))),m(new n,function(a,b){return function(a){if(null!==a){var d=new tP,k=mP(b,a.gb);a=a.Fb;d.zg=k;d.If=a;return d}throw(new q).j(a);}}(a,b)))}function Ola(a){return kP(nP(oP(a,"__INCLUDES"),K(function(a){return function(){return Hla(a)}}(a))),m(new n,function(){return function(a){if(null!==a)return(new DP).uD(a.gb,a.Fb);throw(new q).j(a);}}(a)))} function Qla(a){return kP(nP(Re(oP(a,"TO"),K(function(a){return function(){return oP(a,"TO-REPORT")}}(a))),K(function(a){return function(){return jP(a)}}(a))).er(K(function(a){return function(){return Re(kP(sP(a),m(new n,function(){return function(a){return(new J).j(a)}}(a))),K(function(a){return function(){var b=F();return oba(a,b)}}(a)))}}(a))).er(K(function(a){return function(){return Qe(a,K(function(a){return function(){return Le(a,"?",(new EP).dq(a))}}(a)))}}(a))).er(K(function(a){return function(){return Re(oP(a, "END"),K(function(a){return function(){return Je(a,"END expected")}}(a)))}}(a))),m(new n,function(){return function(a){if(null!==a){var d=a.gb,e=a.Fb;if(null!==d){var f=d.gb,h=d.Fb;if(null!==f&&(d=f.gb,f=f.Fb,null!==d)){var k=d.gb;a=d.Fb;var d=k.X,d=null!==d&&Ea(d,"TO-REPORT"),f=f.z()?I(r(),y()):f.Y(),p=a.g,t=B(),h=h.fd(p,t.s),p=B(),k=h.fd(k,p.s),p=B(),h=new FP,e=k.mc(e,p.s);h.va=a;h.jn=d;h.fn=f;h.ni=e;return h}}}throw(new q).j(a);}}(a)))} function Pla(a){return kP(nP(oP(a,"DIRECTED-LINK-BREED"),K(function(a){return function(){return pP(a,"DIRECTED-LINK-BREED")}}(a))),m(new n,function(){return function(a){var d=a.Fb.ql,e=a.Fb.Bf;a.Fb;return qP(d,e,!0,!0)}}(a)))}function Kla(a){return Re(kP(lP(a,"eof",Dc()),m(new n,function(){return function(){return I(r(),y())}}(a))),K(function(a){return function(){return Je(a,"keyword expected")}}(a)))}yp.prototype.$classData=g({q1:0},!1,"org.nlogo.parse.StructureCombinators",{q1:1,d:1,Noa:1}); function $p(){this.Ii=null;this.br=0}$p.prototype=new l;$p.prototype.constructor=$p;function mea(a,b){return Zp(new $p,a.Ii.Am(b.Ii),a.br+b.br|0)}function Zp(a,b,d){a.Ii=b;a.br=d;return a}function mn(a,b){a=a.Ii;b=b.toUpperCase();return a.ib(b)}c=$p.prototype;c.o=function(a){if(a&&a.$classData&&a.$classData.n.TP){a=a.Ii;var b=this.Ii;return null===a?null===b:GP(a,b)}return this===a};c.k=function(){return cc(this.Ii,"",", ","")};c.Vn=function(a){return Zp(new $p,this.Ii.Pf(a),this.br)};c.wa=function(a){this.Ii.wa(a)}; function Uda(a){for(var b=en(),d=F(),e=a.br;d.z();){var f=("_"+e).toUpperCase();mn(a,f)?e=1+e|0:d=(new J).j((new A).e(f,e))}a:{if(Vk(d)&&(e=d.U,null!==e)){d=e.Dc();e=e.la();break a}throw(new q).j(d);}d|=0;return(new A).e(e,Zp(new $p,a.Ii.vj((new A).e(e,b)),1+d|0))}function Pda(a,b,d){var e=a.Ii;b=b.toUpperCase();return Zp(new $p,e.vj((new A).e(b,d)),a.br)}c.es=function(a){return this.Ii.dc(a.toUpperCase())};function dn(a,b){return a.Ii.y(b.toUpperCase())} function rc(a,b,d){var e=a.Ii;d=m(new n,function(a,b){return function(a){a=a.toUpperCase();return(new A).e(a,b)}}(a,d));var f=Lc();return Zp(new $p,e.Am(b.xa(d,f.s).te($e().Fk)),a.br)}c.xa=function(a,b){b=b.Uh();var d=this.Ii,e=ul().s;b.Yb(Wr(d,a,e));return b.Da()};c.$classData=g({TP:0},!1,"org.nlogo.parse.SymbolTable",{TP:1,d:1,lb:1});function HP(){this.RS=null}HP.prototype=new l;HP.prototype.constructor=HP;function kga(a){var b=new HP;b.RS=a;return b} HP.prototype.Ye=function(){var a;a=IP();var b=this.RS,d=new JP;d.NY=b.Ni;d=d.Ye();b=b.pp;if(nq(b))a=Rla(0,d,b.ha);else{if(!pq(b))throw(new q).j(b);a=Sla(a,d,b.cc)}return a};HP.prototype.$classData=g({o2:0},!1,"org.nlogo.tortoise.compiler.CompiledWidget$$anon$1",{o2:1,d:1,Gl:1});function KP(){this.NT=this.vV=this.wV=null;this.a=0}KP.prototype=new l;KP.prototype.constructor=KP; KP.prototype.b=function(){LP=this;this.wV=(new MP).b();this.a=(1|this.a)<<24>>24;this.vV=(new NP).b();this.a=(2|this.a)<<24>>24;this.NT=ys();this.a=(4|this.a)<<24>>24;return this};function OP(a){if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Compiler.scala: 57");return a.NT} function Tla(a,b,d){var e=ega(qga(b.ec,b.Gc,b.Sf,d.uq)),f=Pfa(vt(),b.Gc);Dt||(Dt=(new Ct).b());var h=Yfa(b.Jr);b=b.wu;d=m(new n,function(a){return function(b){if(nq(b))return b.ha;if(!pq(b))throw(new q).j(b);var d=b.cc;b=(new v).K((new w).f(['modelConfig.dialog.notify("Error(s) in interface global init: ','")']));var e=function(){return function(a){return a.Kc}}(a);tq();var f=e(d.Fc),d=d.Mc,h=uq().Vd,d=vq(d);a:for(;;){if(!wq(d)){if(xq(d)){var k=d,d=k.dd,k=e(k.$c),h=(new yq).Qb(k,h);continue a}throw(new q).j(d); }break}e=xt((new zq).Qb(f,h)).ub();return u(b,(new w).f([cc(e,"",", ","")]))}}(a));var k=r();b=b.xa(d,k.s).zb("\n");d=(new tt).vk("interfaceInit",b,I(r(),(new w).f(["world","procedures","modelConfig"])));fu||(fu=(new bu).b());b=fu;k=r();e=e.Rc(f,k.s);f=r();h=e.Rc(h,f.s);e=Ula(a);f=r();h=h.mc(e,f.s);e=Vla(a);f=r();h=h.mc(e,f.s);e=Wla(a);f=r();h=h.mc(e,f.s);e=r();d=h.mc(d,e.s);a=Xla(a);h=r();return Ega(b,d.mc(a,h.s))} function Ifa(a,b,d){var e=ws(vs()),f=Yla(b),e=Cp(f,e.fk,e.Li,e.hj,e.yi,e.bg,e.Hf,e.ug),f=ph(),f=Zla(a,b,e,f);if(null===f)throw(new q).j(f);var h=f.gb,e=f.Fb,f=f.og,k=(new cs).c(b.Zd),h=Wfa(Vfa(new At,PP(a),d,k),h),k=afa(),k=qb(m(new n,function(a,b){return function(a){return QP(b,a)}}(a,m(new n,function(a,b,d,e){return function(f){return RP(a,f,!0,d,b,!1,e)}}(a,e,f,$la(new SP,d.Lo,d.uq,k,d.bp))))),m(new n,function(a){return function(b){if(nq(b))return b;if(pq(b)){var d=b.cc;b=function(){return function(a){return a}}(a); tq();var e=b(d.Fc),d=d.Mc,f=uq().Vd,d=vq(d);a:for(;;){if(!wq(d)){if(xq(d)){var h=d,d=h.dd,h=b(h.$c),f=(new yq).Qb(h,f);continue a}throw(new q).j(d);}break}return(new qq).j((new zq).Qb(e,f))}throw(new q).j(b);}}(a))),p=qb(m(new n,function(a,b){return function(a){return QP(b,a)}}(a,m(new n,function(a,b,d,e){return function(f){return RP(a,f,!1,e,d,!1,b)}}(a,d,e,f)))),m(new n,function(a){return function(b){if(nq(b))return b;if(pq(b)){var d=b.cc;b=function(){return function(a){return a}}(a);tq();var e= b(d.Fc),d=d.Mc,f=uq().Vd,d=vq(d);a:for(;;){if(!wq(d)){if(xq(d)){var h=d,d=h.dd,h=b(h.$c),f=(new yq).Qb(h,f);continue a}throw(new q).j(d);}break}return(new qq).j((new zq).Qb(e,f))}throw(new q).j(b);}}(a))),k=Tga(Sga(k,p),b.Gc);a=m(new n,function(a,b){return function(a){return QP(b,a)}}(a,m(new n,function(a,b,d,e){return function(f){return RP(a,f,!0,e,d,!0,b)}}(a,d,e,f))));d=ama(b);p=r();a=d.xa(a,p.s);return bma(h,k,a,b,f,e)} function TP(a,b,d){b=u((new v).K((new w).f(["modelConfig.",""])),(new w).f([b]));a=m(new n,function(){return function(a){if(null!==a){var b=a.la();a=a.pa();return u((new v).K((new w).f(["",": ",""])),(new w).f([b,a]))}throw(new q).j(a);}}(a));var e=ul().s;d=Wr(d,a,e).Oc("{\n|    ",",\n|    ","\n|  }");d=u((new v).K((new w).f(['|if (typeof javax !\x3d\x3d "undefined") {\n          |  '," \x3d ","\n          |}"])),(new w).f([b,d]));d=(new Sb).c(d);d=dd(d);return(new tt).vk(b,d,I(r(),(new w).f(["modelConfig"])))} function Zla(a,b,d,e){b=b.Zd;var f=cma();OP(a);var h=F();OP(a);var k=(new OF).b();a=OP(a);d=xaa(a,b,h,d,!1,e,f,k);if(null===d)throw(new q).j(d);e=d.pa();return(new ac).ae(d.la(),e.ec,e.ce)}function QP(a,b){try{Pq();var d=a.y(b);return Vq().y(d)}catch(e){if(Jq(e))return Pq(),Qq(Gq(),e);throw e;}} function Xla(a){for(var b=ds(fd(),I(r(),(new w).f(["filename"])),""),b=(new A).e("exportOutput",b),d=ds(fd(),I(r(),(new w).f(["filename"])),""),b=[b,(new A).e("exportView",d)],d=dc(new ec,gc()),e=0,f=b.length|0;e<f;)hc(d,b[e]),e=1+e|0;return TP(a,"exporting",d.Ma)}function Wla(a){for(var b=ds(fd(),I(r(),(new w).f(["agent"])),""),b=[(new A).e("resizeWorld",b)],d=dc(new ec,gc()),e=0,f=b.length|0;e<f;)hc(d,b[e]),e=1+e|0;return TP(a,"world",d.Ma)} function PP(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Compiler.scala: 55");return a.vV} function Vla(a){for(var b=ds(fd(),I(r(),(new w).f(["str"])),"return true;"),b=(new A).e("confirm",b),d=ds(fd(),I(r(),(new w).f(["str"])),"return 'dummy implementation';"),d=(new A).e("input",d),e=ds(fd(),I(r(),(new w).f(["str"])),""),e=(new A).e("notify",e),f=ds(fd(),I(r(),(new w).f(["str"])),"return true;"),b=[b,d,e,(new A).e("yesOrNo",f)],d=dc(new ec,gc()),e=0,f=b.length|0;e<f;)hc(d,b[e]),e=1+e|0;return TP(a,"dialog",d.Ma)} function Ula(a){for(var b=ds(fd(),I(r(),y()),""),b=(new A).e("clear",b),d=ds(fd(),I(r(),(new w).f(["str"])),"context.getWriter().print(str);"),b=[b,(new A).e("write",d)],d=dc(new ec,gc()),e=0,f=b.length|0;e<f;)hc(d,b[e]),e=1+e|0;return TP(a,"output",d.Ma)} function RP(a,b,d,e,f,h,k){var p;p=yca();var t=uj();if(!p.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/SourceWrapping.scala: 7");p=p.uS.y(t);p=d?"to __evaluator [] "+p+" ":"to-report __evaluator [] "+p+" report ( ";yca();t=d?"\n__done end":"\n) __done end";t=u((new v).K((new w).f(["","","",""])),(new w).f([p,b,t]));b=(new cs).c(t);p=new Bt;var x=I(r(),y());p.lq=!h;p.cp=x;x=cma();OP(a);var E=F();OP(a);OP(a);var S=(new OF).b(),U=OP(a);e=xaa(U,t,E,f, !0,e,x,S);if(null===e)throw(new q).j(e);e=e.la();e=k.bp?Nfa(Ofa(),e.$()):e.$();if(d)return a=PP(a),sr(a,e.fe,!0,!h,k,b,p);h=PP(a);a=e.fe.Zf.W(1).za.W(0);return ir(h,a,k,b,p)}KP.prototype.$classData=g({t2:0},!1,"org.nlogo.tortoise.compiler.Compiler$",{t2:1,d:1,Zia:1});var LP=void 0;function br(){LP||(LP=(new KP).b());return LP}function UP(){this.bE=null}UP.prototype=new l;UP.prototype.constructor=UP;UP.prototype.kh=function(){var a=Tr(Qr(),(new Rr).ci(this.bE),"name"),b=Sr();return sd(a,b)}; function dma(a){try{var b=Tr(Qr(),(new Rr).ci(a.bE),"prims"),d=cfa(),e=sd(b,d).X,f=m(new n,function(){return function(a){return bfa(hfa(),a)}}(a)),h=Mk().qc;return Wr(e,f,h)}catch(k){a=ko(Lg(),k);if(us(a))throw Kg(Lg(),(new $r).jc(u((new v).K((new w).f(["Problem parsing extension definition JSON.  ",""])),(new w).f([a.Fh()])),a));throw k;}}UP.prototype.ci=function(a){this.bE=a;return this};UP.prototype.$classData=g({D2:0},!1,"org.nlogo.tortoise.compiler.CreateExtension$$anon$3",{D2:1,d:1,aja:1}); function VP(){this.NV=this.CT=null;this.a=0}VP.prototype=new l;VP.prototype.constructor=VP;c=VP.prototype; c.b=function(){WP=this;var a;ifa||(ifa=(new bs).b());a=I(r(),(new w).f(['{ "name": "codap", "prims": [ { "name": "init", "actionName": "init", "argTypes": ["command"] }, { "name": "call", "actionName": "call", "argTypes": ["wildcard"] } ] }','{ "name": "nlmap", "prims": [ { "name": "from-list", "actionName": "from-list", "argTypes": ["list"], "returnType": "wildcard" }, { "name": "to-list", "actionName": "to-list", "argTypes": ["wildcard"], "returnType": "list" }, { "name": "is-map?", "actionName": "is-map?", "argTypes": ["wildcard"], "returnType": "boolean" }, { "name": "get", "actionName": "get", "argTypes": ["wildcard", "string"], "returnType": "wildcard" }, { "name": "remove", "actionName": "remove", "argTypes": ["wildcard", "string"], "returnType": "wildcard" }, { "name": "add", "actionName": "add", "argTypes": ["wildcard", "string", "wildcard"], "returnType": "wildcard" }, { "name": "to-json", "actionName": "to-json", "argTypes": ["wildcard"], "returnType": "string" }, { "name": "to-urlenc", "actionName": "to-urlenc", "argTypes": ["wildcard"], "returnType": "string" }, { "name": "from-json", "actionName": "from-json", "argTypes": ["string"], "returnType": "wildcard" } ] }','{ "name": "logging", "prims": [ { "name": "all-logs", "actionName": "all-logs", "argTypes": [], "returnType": "list" }, { "name": "clear-logs", "actionName": "clear-logs", "argTypes": [], "returnType": "unit" }, { "name": "log-globals", "actionName": "log-globals", "argTypes": [{ "type": "string", "isRepeatable": true }], "returnType": "unit" }, { "name": "log-message", "actionName": "log-message", "argTypes": ["string"], "returnType": "unit" } ] }', '{ "name": "http-req", "prims": [ { "name": "get", "actionName": "get", "argTypes": ["string"], "returnType": "list" }, { "name": "post", "actionName": "post", "argTypes": ["string", "string", "string"], "returnType": "list" } ] }']));var b=m(new n,function(){return function(a){hfa();var b=Mha();a=sx(b,ba.JSON.parse(a));return(new UP).ci(a)}}(this)),d=r();a=a.xa(b,d.s);b=m(new n,function(){return function(a){return(new A).e(a.kh(),a)}}(this));d=r();this.CT=a.xa(b,d.s).te($e().Fk);this.a=(1|this.a)<< 24>>24;XP||(XP=(new YP).b());this.NV=nh(XP,y());this.a=(2|this.a)<<24>>24;return this};c.hY=function(){ZP(this).Er()};function ZP(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/NLWExtensionManager.scala: 120");return a.NV}c.yS=function(){return!0}; c.aW=function(a){var b=ZP(this).dc(a);if(Vk(b))return b.U;if(F()!==b)throw(new q).j(b);-1!==(a.indexOf(":")|0)&&ema(u((new v).K((new w).f(["No such primitive: ",""])),(new w).f([a])));return null};function ema(a){var b=Nm().ra.Xa,d=Nm().ra.Va,e=Nm();throw(new hd).ms(a,b,d,e.ra.ab);} c.bU=function(a){if(0===(1&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/NLWExtensionManager.scala: 119");var b=this.CT.dc(a);if(!Vk(b))throw F()===b&&ema(u((new v).K((new w).f(["No such extension: ",""])),(new w).f([a]))),(new q).j(b);b=b.U;a=dma(b);var b=m(new n,function(a,b){return function(a){return(new A).e(b.kh(),a)}}(this,b)),d=r();a=a.xa(b,d.s);b=m(new n,function(){return function(a){if(null!==a){var b=a.la(),d=a.pa();if(null!== d)return a=d.Zu,d=d.va,b=u((new v).K((new w).f(["",":",""])),(new w).f([b,d])),(new A).e(b.toUpperCase(),a)}throw(new q).j(a);}}(this));d=r();a=a.xa(b,d.s);b=ZP(this);ID(b,a)};c.$classData=g({P2:0},!1,"org.nlogo.tortoise.compiler.NLWExtensionManager$",{P2:1,d:1,FZ:1});var WP=void 0;function cma(){WP||(WP=(new VP).b());return WP}function ct(){}ct.prototype=new l;ct.prototype.constructor=ct;c=ct.prototype;c.b=function(){return this};c.vh=function(a){return Gb(this,a)}; c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Nt(d)&&(r(),d=(new J).j(b),null!==d.U&&0===d.U.Rb(1)&&(d=d.U.W(0),xb(d)&&(b=vi().Yd(d),!b.z()&&(d=b.Y().gb,b=b.Y().Fb,$P(d))))))return d=(new aQ).b(),(new Kb).Qf(d,b,a.ra)}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({S2:0},!1,"org.nlogo.tortoise.compiler.Optimizer$AnyOtherTransformer$",{S2:1,d:1,ah:1});var bt=void 0;function Ls(){}Ls.prototype=new l;Ls.prototype.constructor=Ls;c=Ls.prototype;c.b=function(){return this}; c.vh=function(a){return Gb(this,a)};c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Mt(d)&&(r(),d=(new J).j(b),null!==d.U&&0===d.U.Rb(1)&&(d=d.U.W(0),xb(d)&&(b=vi().Yd(d),!b.z()&&(d=b.Y().gb,b=b.Y().Fb,$P(d))))))return d=(new bQ).b(),(new Kb).Qf(d,b,a.ra)}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({T2:0},!1,"org.nlogo.tortoise.compiler.Optimizer$CountOtherTransformer$",{T2:1,d:1,ah:1});var Ks=void 0;function Rs(){}Rs.prototype=new l; Rs.prototype.constructor=Rs;c=Rs.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Cr(d)&&(r(),b=(new J).j(b),null!==b.U&&0===b.U.Rb(2)&&(b=b.U.W(1),yb(b)&&b.fe.Zf.z())))return d=(new cQ).c(d.ja),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({U2:0},!1,"org.nlogo.tortoise.compiler.Optimizer$CroFastTransformer$",{U2:1,d:1,ah:1});var Qs=void 0; function Ps(){}Ps.prototype=new l;Ps.prototype.constructor=Ps;c=Ps.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Br(d)&&(r(),b=(new J).j(b),null!==b.U&&0===b.U.Rb(2)&&(b=b.U.W(1),yb(b)&&b.fe.Zf.z())))return d=(new dQ).c(d.ja),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)}; c.$classData=g({V2:0},!1,"org.nlogo.tortoise.compiler.Optimizer$CrtFastTransformer$",{V2:1,d:1,ah:1});var Os=void 0;function Hs(){}Hs.prototype=new l;Hs.prototype.constructor=Hs;c=Hs.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(eQ(d)&&(r(),d=(new J).j(b),null!==d.U&&0===d.U.Rb(1)&&(d=d.U.W(0),xb(d)&&(d=vi().Yd(d),!d.z()&&(d=d.Y().gb,Do(d)&&sn(tn(),d.X,1))))))return d=(new fQ).b(),b=I(r(),y()),(new Hb).cj(d,b,a.ra)}return Gb(this,a)}; c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({W2:0},!1,"org.nlogo.tortoise.compiler.Optimizer$Fd1Transformer$",{W2:1,d:1,ah:1});var Gs=void 0;function Js(){}Js.prototype=new l;Js.prototype.constructor=Js;c=Js.prototype;c.b=function(){return this}; c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(eQ(d)&&(r(),d=(new J).j(b),null!==d.U&&0===d.U.Rb(1)&&(d=d.U.W(0),xb(d)&&(d=vi().Yd(d),!d.z()&&(d=d.Y().gb,Do(d)&&(d=d.X,"number"===typeof d&&-1<+d&&1>+d))))))return d=(new gQ).b(),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({X2:0},!1,"org.nlogo.tortoise.compiler.Optimizer$FdLessThan1Transformer$",{X2:1,d:1,ah:1});var Is=void 0; function Ts(){}Ts.prototype=new l;Ts.prototype.constructor=Ts;c=Ts.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Gr(d)&&(r(),b=(new J).j(b),null!==b.U&&0===b.U.Rb(2)&&(b=b.U.W(1),yb(b)&&b.fe.Zf.z())))return d=(new hQ).c(d.ja),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)}; c.$classData=g({Y2:0},!1,"org.nlogo.tortoise.compiler.Optimizer$HatchFastTransformer$",{Y2:1,d:1,ah:1});var Ss=void 0;function iQ(){}iQ.prototype=new l;iQ.prototype.constructor=iQ;function jQ(){}jQ.prototype=iQ.prototype;iQ.prototype.vh=function(a){return Gb(this,a)};iQ.prototype.$g=function(a){return Lb(this,a)};function at(){}at.prototype=new l;at.prototype.constructor=at;c=at.prototype;c.b=function(){return this};c.vh=function(a){return Gb(this,a)}; c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().Fb;if(kQ(b.Y().gb)&&(r(),b=(new J).j(d),null!==b.U&&0===b.U.Rb(1)&&(b=b.U.W(0),xb(b)&&(d=vi().Yd(b),!d.z()&&(b=d.Y().Fb,Qt(d.Y().gb))))))return d=(new lQ).b(),(new Kb).Qf(d,b,a.ra)}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({b3:0},!1,"org.nlogo.tortoise.compiler.Optimizer$OneOfWithTransformer$",{b3:1,d:1,ah:1});var $s=void 0;function gt(){}gt.prototype=new l;gt.prototype.constructor=gt;c=gt.prototype;c.b=function(){return this}; c.vh=function(a){return Gb(this,a)};c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().Fb;if($P(b.Y().gb)&&(r(),b=(new J).j(d),null!==b.U&&0===b.U.Rb(1)&&(b=b.U.W(0),xb(b)&&(d=vi().Yd(b),!d.z()&&(b=d.Y().Fb,Qt(d.Y().gb))))))return d=(new mQ).b(),(new Kb).Qf(d,b,a.ra)}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({c3:0},!1,"org.nlogo.tortoise.compiler.Optimizer$OtherWithTransformer$",{c3:1,d:1,ah:1});var ft=void 0;function Vs(){}Vs.prototype=new l; Vs.prototype.constructor=Vs;c=Vs.prototype;c.b=function(){return this};c.vh=function(a){var b=zj(Bj(),a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Dr(d)&&(r(),b=(new J).j(b),null!==b.U&&0===b.U.Rb(2)&&(b=b.U.W(1),yb(b)&&b.fe.Zf.z())))return d=(new nQ).c(d.ja),(new Hb).cj(d,a.za,a.ra)}return Gb(this,a)};c.Cg=function(a){return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({d3:0},!1,"org.nlogo.tortoise.compiler.Optimizer$SproutFastTransformer$",{d3:1,d:1,ah:1});var Us=void 0; function et(){}et.prototype=new l;et.prototype.constructor=et;c=et.prototype;c.b=function(){return this};c.vh=function(a){return Gb(this,a)};c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().Fb;if(Qt(b.Y().gb)&&(r(),b=(new J).j(d),null!==b.U&&0===b.U.Rb(2)&&(d=b.U.W(0),b=b.U.W(1),xb(d)))){var e=vi().Yd(d);if(!e.z()&&(d=e.Y().Fb,$P(e.Y().gb))){var e=(new mQ).b(),f=r(),b=d.mc(b,f.s);return(new Kb).Qf(e,b,a.ra)}}}return Jb(this,a)};c.$g=function(a){return Lb(this,a)}; c.$classData=g({e3:0},!1,"org.nlogo.tortoise.compiler.Optimizer$WithOtherTransformer$",{e3:1,d:1,ah:1});var dt=void 0;function Ns(){this.a=this.TV=this.SV=0}Ns.prototype=new l;Ns.prototype.constructor=Ns;function fma(a){var b=vi().Yd(a);if(!b.z()&&(b=b.Y().gb,Do(b)))return!0;b=vi().Yd(a);if(!b.z()&&(b=b.Y().gb,oQ(b)))return!0;a=vi().Yd(a);return!a.z()&&(a=a.Y().gb,qr(a))?!0:!1}c=Ns.prototype; c.b=function(){Ms=this;var a=DF(pQ(qQ())),a=Ic(a),b=B().s,a=L(a,b);this.SV=rQ(a,"PXCOR",0);this.a=(1|this.a)<<24>>24;a=DF(pQ(qQ()));a=Ic(a);b=B().s;a=L(a,b);this.TV=rQ(a,"PYCOR",0);this.a=(2|this.a)<<24>>24;return this};c.vh=function(a){return Gb(this,a)}; c.Cg=function(a){var b=vi().Yd(a);if(!b.z()){var d=b.Y().gb,b=b.Y().Fb;if(Qt(d)&&(r(),d=(new J).j(b),null!==d.U&&0===d.U.Rb(2)&&(b=d.U.W(0),d=d.U.W(1),xb(b)&&(b=vi().Yd(b),!b.z()&&(b=b.Y().gb,sQ(b)&&zb(d)&&(d=xi(zi(),d),!d.z()&&(d=d.Y().la(),kt||(kt=(new it).b()),d=kt.Yd(d),!d.z()))))))){b=d.Y().la();d=d.Y().pa();b=b.Pd;if(0===(1&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Optimizer.scala: 230");if(this.SV===b&&fma(d))b=(new tQ).b(),d= I(r(),(new w).f([d])),a=(new Kb).Qf(b,d,a.ra);else{if(0===(2&this.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/Optimizer.scala: 231");this.TV===b&&fma(d)?(b=(new uQ).b(),d=I(r(),(new w).f([d])),a=(new Kb).Qf(b,d,a.ra)):a=Jb(this,a)}return a}}return Jb(this,a)};c.$g=function(a){return Lb(this,a)};c.$classData=g({f3:0},!1,"org.nlogo.tortoise.compiler.Optimizer$WithTransformer$",{f3:1,d:1,ah:1});var Ms=void 0;function vQ(){this.ga=null} vQ.prototype=new l;vQ.prototype.constructor=vQ;vQ.prototype.PF=function(a){a=Oaa(a,"get");if(a.z())return F();a=a.Y();a:{if(null!==a){var b=a.la(),d=a.pa();if(null!==b&&null!==d){a=u((new v).K((new w).f(["","(",")"])),(new w).f([b,ed(fd(),d)]));break a}}throw(new q).j(a);}return(new J).j(a)};vQ.prototype.vD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};vQ.prototype.$classData=g({p3:0},!1,"org.nlogo.tortoise.compiler.PrimUtils$VariableReporter$",{p3:1,d:1,n3:1}); function rr(){this.ga=null}rr.prototype=new l;rr.prototype.constructor=rr;rr.prototype.PF=function(a){a=Oaa(a,"set");if(a.z())return F();a=a.Y();a:{if(null!==a){var b=a.la(),d=a.pa();if(null!==b&&null!==d){a=m(new n,function(a,b,d){return function(a){return u((new v).K((new w).f(["","(",", ",");"])),(new w).f([b,ed(fd(),d),a]))}}(this,b,d));break a}}throw(new q).j(a);}return(new J).j(a)};rr.prototype.vD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this}; rr.prototype.$classData=g({q3:0},!1,"org.nlogo.tortoise.compiler.PrimUtils$VariableSetter$",{q3:1,d:1,n3:1}); function wQ(a){var b=(new Tu).c(a.Mv()),b=(new A).e("type",b),d,e=a.Ph.yb;d=e.xq;var f=e.Sp,h=e.Fp,e=e.Cp/255;d=(new Tu).c(u((new v).K((new w).f(["rgba(",", ",", ",", ",")"])),(new w).f([d,f,h,e])));d=(new A).e("color",d);f=(new Uu).td(a.Ph.$k());f=(new A).e("filled",f);a=(new Uu).td(a.Ph.gc);a=[b,d,f,(new A).e("marked",a)];b=dc(new ec,Yu());d=0;for(f=a.length|0;d<f;)hc(b,a[d]),d=1+d|0;return(new Mu).$b(b.Ma)}function xQ(){this.Ky=this.Ly=this.My=this.Jy=this.Hy=this.Iy=this.Xw=null} xQ.prototype=new l;xQ.prototype.constructor=xQ;xQ.prototype.b=function(){return this};function yQ(){var a=Tq();null===Tq().Xw&&null===Tq().Xw&&(Tq().Xw=(new zQ).Pj(a));return Tq().Xw}function mq(){var a=Tq();null===Tq().Ly&&null===Tq().Ly&&(Tq().Ly=(new AQ).Pj(a));return Tq().Ly}function BQ(){var a=Tq();null===Tq().Iy&&null===Tq().Iy&&(Tq().Iy=(new CQ).Pj(a));return Tq().Iy}function DQ(){var a=Tq();null===Tq().Hy&&null===Tq().Hy&&(Tq().Hy=(new EQ).Pj(a));return Tq().Hy} function Rea(){var a=Tq();null===Tq().Ky&&null===Tq().Ky&&(Tq().Ky=(new FQ).Pj(a));return Tq().Ky}function GQ(a,b,d,e){return e.Cc(d,b.Pg.dc(d))}function Sq(a){null===Tq().Jy&&null===Tq().Jy&&(Tq().Jy=(new HQ).Pj(a));return Tq().Jy}xQ.prototype.$classData=g({k4:0},!1,"org.nlogo.tortoise.compiler.json.JsonReader$",{k4:1,d:1,fja:1});var IQ=void 0;function Tq(){IQ||(IQ=(new xQ).b());return IQ} function JQ(a,b){a=a.Oy().y(b);if(nq(a))return(new sq).j((new J).j(a.ha));if(pq(a))return a;throw(new q).j(a);}function KQ(a,b){b.z()?a=F():(b=b.Y(),a=(new J).j(JQ(a,b)));return a.z()?(Pq(),a=F(),Vq().y(a)):a.Y()}function LQ(){this.Ww=this.hx=this.Cx=this.zy=null}LQ.prototype=new l;LQ.prototype.constructor=LQ;LQ.prototype.b=function(){return this};function MQ(){var a=NQ();null===NQ().Ww&&null===NQ().Ww&&(NQ().Ww=(new OQ).eq(a));return NQ().Ww} function PQ(){var a=NQ();null===NQ().hx&&null===NQ().hx&&(NQ().hx=(new QQ).eq(a));return NQ().hx}function RQ(){var a=NQ();null===NQ().zy&&null===NQ().zy&&(NQ().zy=(new SQ).eq(a));return NQ().zy}function TQ(){var a=NQ();null===NQ().Cx&&null===NQ().Cx&&(NQ().Cx=(new UQ).eq(a));return NQ().Cx}LQ.prototype.$classData=g({p4:0},!1,"org.nlogo.tortoise.compiler.json.JsonWriter$",{p4:1,d:1,gja:1});var VQ=void 0;function NQ(){VQ||(VQ=(new LQ).b());return VQ}function WQ(){this.AT=this.pY=null}WQ.prototype=new l; WQ.prototype.constructor=WQ;function Cq(a,b){var d=new WQ;d.pY=a;d.AT=b;return d}WQ.prototype.Ye=function(){return this.AT.rc(this.pY)};WQ.prototype.$classData=g({q4:0},!1,"org.nlogo.tortoise.compiler.json.JsonWriter$$anon$1",{q4:1,d:1,Gl:1});function XQ(){this.tY=null;this.a=!1}XQ.prototype=new l;XQ.prototype.constructor=XQ; function gma(a){var b=new XQ,d=(new Su).tk(a.WF()),d=(new A).e("x-offset",d),e=(new Uu).td(a.XD()),e=(new A).e("is-visible",e);a=a.BC();var f=m(new n,function(){return function(a){return(new Su).tk(+a)}}(b)),h=r();a=(new Vu).K(a.xa(f,h.s));d=[d,e,(new A).e("dash-pattern",a)];e=dc(new ec,Yu());a=0;for(f=d.length|0;a<f;)hc(e,d[a]),a=1+a|0;b.tY=(new Mu).$b(e.Ma);b.a=!0;return b} XQ.prototype.Ye=function(){if(!this.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/Tortoise/compiler/shared/src/main/scala/json/ShapeToJsonConverters.scala: 36");return this.tY};XQ.prototype.$classData=g({I4:0},!1,"org.nlogo.tortoise.compiler.json.ShapeToJsonConverters$$anon$3",{I4:1,d:1,Gl:1});function JP(){this.NY=null}JP.prototype=new l;JP.prototype.constructor=JP; JP.prototype.Ye=function(){var a=this.NY;if(ou(a)){var b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new YQ).eg(this))}return ZQ(a)}if(a&&a.$classData&&a.$classData.n.tz){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new $Q).eg(this))}return aR(a)}if(a&&a.$classData&&a.$classData.n.vz){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new bR).eg(this))}return cR(a)}if(qu(a)){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b, (new dR).eg(this))}return eR(a)}if(a&&a.$classData&&a.$classData.n.xz){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new fR).eg(this))}return gR(a)}if(a&&a.$classData&&a.$classData.n.yz)return b=(new Ne).b(),(b.La?b.hb:hma(this,b)).dh(a);if(iu(a)){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new hR).eg(this))}return iR(a)}if(ru(a)){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new jR).eg(this))}return kR(a)}if(a&&a.$classData&&a.$classData.n.Ez){b= (new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new lR).eg(this))}return mR(a)}if(a&&a.$classData&&a.$classData.n.Fz){b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new nR).eg(this))}return oR(a)}if(!pR(a))throw(new q).j(a);b=(new Ne).b();if(!b.La){if(null===b)throw(new Oe).b();b.La||Pe(b,(new qR).eg(this))}return rR(a)};function hma(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,(new sR).eg(a))} JP.prototype.$classData=g({r5:0},!1,"org.nlogo.tortoise.compiler.json.WidgetToJson$$anon$1",{r5:1,d:1,Gl:1});function tR(a,b){if(b.z())return F();b=b.Y();b=(new J).j(b);return(new J).j(a.vt(b))}function uR(){this.KS=null}uR.prototype=new l;uR.prototype.constructor=uR;uR.prototype.b=function(){vR=this;this.KS=wR(ba);return this};function ima(a,b){return!!b.Gb(!0,tb(new ub,function(){return function(a,b){return!!a&&!!b}}(a)))} function jma(a,b,d){d=m(new n,function(a,b){return function(d){d=kma(a,d,b);var e=m(new n,function(){return function(a){return null!==a}}(a)),t=KB();return d.VC(e,t).bl(m(new n,function(a,b){return function(d){if(null!==d){var e=!!d.la();d=d.pa();return jma(a,Yt($e(),d),b).Ih(m(new n,function(a,b){return function(a){return b&&!!a}}(a,e)),KB())}throw(new q).j(d);}}(a,b)),KB())}}(a,d));var e=r();b=b.xa(d,e.s);d=xA();e=r();return QB(d,b,e.s,KB()).Ih(m(new n,function(a){return function(b){return ima(a, b)}}(a)),KB())} function lma(a,b,d,e){for(var f=y(),h=wn(f),h=la(Xa(qa),[h]),k=0,k=0,f=Cv(f);f.ta();){var p=f.ma();h.l[k]=p;k=1+k|0}p=y();k=wn(p);k=la(Xa(qa),[k]);f=f=0;for(p=Cv(p);p.ta();){var t=p.ma();k.l[f]=t;f=1+f|0}h=mma(b,h,a.KS);d=nma(h,d.se((new Qn).xg(pa(xR))));return jma(a,Yt($e(),d),e).Ih(m(new n,function(a,b,d,e){return function(a){a=!!a;var b=e.fx(),f=(new Sb).c(b);kd(f)&&(f=d.yn,b=u((new v).K((new w).f([""," reported ",""])),(new w).f(["utest",b])),Yv(f.Eg,b,Xv(a)));return a}}(a,b,e,h)),KB())} function oma(a){for(var b=(new Sb).c(ba.document.location.search),d=pma(b),e=!1,b=null,d=QE(Ia(),d,"\x26"),f=null,f=[],h=0,k=d.l.length;h<k;){var p=ba.decodeURIComponent(d.l[h]);f.push(null===p?null:p);h=1+h|0}d=ka(Xa(qa),f);f=B().s.Uh();h=d.l.length;switch(h){case -1:break;default:f.tc(h)}f.Yb((new Fi).Gh(d));d=f.Da();a:{if(Gi(d)&&(e=!0,b=d,d=b.Ia,"i"===b.Bb&&Gi(d))){b=d.Bb;e=d.Ia;d=$l();d=cm(d);e=L(e,d);e=m(new n,function(a,b){return function(a){return b.ib(a.ik)}}(a,e));b=(new Sb).c(b);d=Hi(); d=(new J).j(Ji(d,b.R,10));b=e;e=d;break a}if(e&&(e=b.Ia,"e"===b.Bb)){b=$l();b=cm(b);b=L(e,b);b=m(new n,function(a,b){return function(a){return!b.ib(a.ik)}}(a,b));e=F();break a}b=m(new n,function(){return function(){return!0}}(a));e=F()}d=e;f=tha();e=m(new n,function(){return function(a){return a.pa().Ga()}}(a));h=r();e=f.xa(e,h.s).$f(cw())|0;h=m(new n,function(a,b){return function(a){return a.pa().vf(b)}}(a,b));k=r();h=f.aj(h,k.s);e=pha(h,e);(d.z()?0:(d.Y()|0)!==qma(a,h))&&lha(e);d=f.Vn(m(new n,function(){return function(a){return null!== a}}(a)));b=m(new n,function(a,b,d){return function(e){if(null!==e)return lma(a,e.la(),e.pa().al(b,!1),d);throw(new q).j(e);}}(a,b,e));f=r();b=d.xa(b,f.s);d=xA();f=r();QB(d,b,f.s,KB()).Ih(m(new n,function(a){return function(b){return ima(a,b)}}(a)),KB()).ap(m(new n,function(a,b){return function(a){b.HC(a)}}(a,e)),KB())}function qma(a,b){V();a=m(new n,function(){return function(a){return a.ik}}(a));var d=r();return hD(0,b.xa(a,d.s).ed())} function kma(a,b,d){d=nha(d,b.Dv.ik);var e=(new yR).b(),f=(new zR).b();b=wA(xA(),K(function(a,b,d,e,f){return function(){for(var E=(new w).f([d.Lx]),S=E.oa.length|0,S=la(Xa(Raa),[S]),U=0,U=0,E=lf(new mf,E,0,E.oa.length|0);E.ta();){var ga=E.ma();S.l[U]=ga;U=1+U|0}rma(b,e,S,m(new n,function(a,b){return function(a){a=(new CA).j(a);xe(b,a)}}(a,f)))}}(a,b,d,e,f)),(new IE).b()).bl(m(new n,function(a,b,d){return function(){return d.Ih(m(new n,function(a,b){return function(a){return(new A).e(!b.cw,a)}}(a, b)),KB())}}(a,e,f)),KB());b.Ih(m(new n,function(){return function(a){return!!a.la()}}(a)),KB()).ap(m(new n,function(a,b){return function(a){b.HC(a)}}(a,d)),KB());return b.Es((new AR).b(),KB())}uR.prototype.main=function(){oma(this)};uR.prototype.$classData=g({g6:0},!1,"org.scalajs.testinterface.HTMLRunner$",{g6:1,d:1,lpa:1});var vR=void 0;function yR(){this.cw=!1}yR.prototype=new l;yR.prototype.constructor=yR;yR.prototype.b=function(){this.cw=!1;return this}; yR.prototype.VT=function(a){a=a.zF;this.cw=this.cw?!0:Vv().xV.ib(a);Vv().Lt.Ts(a,1+(Vv().Lt.y(a)|0)|0)};yR.prototype.$classData=g({j6:0},!1,"org.scalajs.testinterface.HTMLRunner$EventCounter$Handler",{j6:1,d:1,h7:1});function BR(){this.ga=this.zV=this.vq=null}BR.prototype=new l;BR.prototype.constructor=BR;BR.prototype.tv=function(a){this.vq.tv(a)}; function qha(a){var b=new BR;if(null===a)throw Kg(Lg(),null);b.ga=a;var d=a.uE.Ga();b.vq=(new hw).mu(a,u((new v).K((new w).f(["Excluded Test Suites (",")"])),(new w).f([d])));b.zV=oha(a,a.Su,b.vq.Wh);b.vq.Wh.checked=!1;b.vq.Wh.onclick=mha(a,a.Su,b.vq.Wh);a.uE.wa(m(new n,function(a){return function(b){return a.ga.Su.uj(sma(a,b.ik))}}(b)));return b}BR.prototype.$classData=g({l6:0},!1,"org.scalajs.testinterface.HTMLRunner$UI$ExcludedTestBox",{l6:1,d:1,KQ:1}); function CR(){this.ga=this.Wh=this.lE=this.Ss=null}CR.prototype=new l;CR.prototype.constructor=CR;CR.prototype.FT=function(){return!1};CR.prototype.ZX=function(a){this.Wh.checked=a};CR.prototype.sy=function(){return!!this.Wh.checked};function sma(a,b){var d=new CR;d.Ss=b;if(null===a)throw Kg(Lg(),null);d.ga=a;d.lE=Yv(a.vq,"","info");d.Wh=rha($v(),d.lE,!1);d.Wh.onclick=a.zV;Zv($v(),d.lE," "+b);return d} CR.prototype.$classData=g({m6:0},!1,"org.scalajs.testinterface.HTMLRunner$UI$ExcludedTestBox$ExcludedTest",{m6:1,d:1,q6:1});function gw(){this.ga=this.CY=this.AC=this.Eg=null}gw.prototype=new l;gw.prototype.constructor=gw;gw.prototype.tv=function(a){this.Eg.tv(a)}; function tma(a,b){var d=a.ga.Tu,e=a.ga.Su,f=Ec().s,d=au(d,e,f).Bi(b);if(null===d)throw(new q).j(d);b=d.la();d=d.pa();b.Ga()<d.Ga()?(V(),e=m(new n,function(){return function(a){return a.Ss}}(a)),f=Ec().s,d=""+hD(0,Wr(d,e,f).ed()),d=I(r(),(new w).f(["i",d])),e=m(new n,function(){return function(a){return a.Ss}}(a)),f=Ec().s,b=Wr(b,e,f),e=r(),b=d.Rc(b,e.s)):(b=m(new n,function(){return function(a){return a.Ss}}(a)),e=Ec().s,b=Wr(d,b,e),d=Ec(),b=b.fd("e",d.s));a=m(new n,function(){return function(a){return ba.encodeURIComponent(a)}}(a)); d=r();return b.xa(a,d.s).Oc("?","\x26","")}gw.prototype.gx=function(a){this.Eg.gx(a);this.AC.className="log "+Xv(a);var b=Yv(this.Eg,"Next: ",Xv(a));a||(aw($v(),b,tma(this,m(new n,function(){return function(a){return a.FT()}}(this))),"Run failed"),Zv($v(),b," | "));aw($v(),b,"#","Run selected").onclick=function(a){return function(){return uma(a)}}(this);Zv($v(),b," | ");aw($v(),b,"?","Run all")}; function uma(a){ba.document.location.search=tma(a,m(new n,function(){return function(a){return a.sy()}}(a)));return!1}gw.prototype.$classData=g({n6:0},!1,"org.scalajs.testinterface.HTMLRunner$UI$RootBox",{n6:1,d:1,KQ:1});function DR(){this.ga=null}DR.prototype=new l;DR.prototype.constructor=DR;DR.prototype.OC=function(a){Yv(this.ga.ml,a,"error");iw(this.ga.ml)};DR.prototype.MF=function(a){this.OC(a.k())};DR.prototype.lD=function(a){Yv(this.ga.ml,a,"info")}; DR.prototype.$classData=g({p6:0},!1,"org.scalajs.testinterface.HTMLRunner$UI$RunningTest$$anon$1",{p6:1,d:1,yB:1});function hw(){this.rg=this.Wh=this.fD=this.RC=this.fs=this.Eg=null;this.Vr=!1;this.ga=null}hw.prototype=new l;hw.prototype.constructor=hw;hw.prototype.tv=function(a){this.Eg.insertAdjacentElement("afterend",a.Eg)};function vma(a){a.Vr=!a.Vr;a.RC.textContent=a.Vr?"[-]":"[+]";a.rg.style.display=a.Vr?"block":"none"}function iw(a){a.Vr||vma(a)} hw.prototype.gx=function(a){this.fs.className=this.fs.className+" "+Xv(a);this.fD.textContent+=a?" - Passed":" - Failed"}; hw.prototype.mu=function(a,b){if(null===a)throw Kg(Lg(),null);this.ga=a;a=a.yV;a=this.Eg=fw($v(),a,"test-box","","div");this.fs=fw($v(),a,"test-box-header","","div");this.RC=aw($v(),this.fs,"#","[+]");this.RC.onclick=function(a){return function(){vma(a);return!1}}(this);this.fD=Zv($v(),this.fs," "+b);this.Wh=rha($v(),this.fs,!0);b=this.Eg;this.rg=fw($v(),b,"test-box-body","","div");this.Vr=!1;return this}; function Yv(a,b,d){return fw($v(),a.rg,u((new v).K((new w).f(["log ",""])),(new w).f([d])),b,"pre")}hw.prototype.$classData=g({r6:0},!1,"org.scalajs.testinterface.HTMLRunner$UI$TestBox",{r6:1,d:1,KQ:1});function ER(){this.jV=null}ER.prototype=new nja;ER.prototype.constructor=ER;function wR(a){var b=new ER;b.jV=a;return b}ER.prototype.$classData=g({LQ:0},!1,"org.scalajs.testinterface.ScalaJSClassLoader",{LQ:1,coa:1,d:1});function FR(){this.Xj=this.cu=null}FR.prototype=new ww; FR.prototype.constructor=FR;c=FR.prototype;c.Hx=function(a){return ba.JSON.parse(Ee(a))}; c.UT=function(a,b){if("newRunner"===a){var d;a:{var e=this.Hx(b),f=e.args,h=f.length|0,h=la(Xa(qa),[h]);a=h.l.length;var k=0,p=0;b=f.length|0;a=b<a?b:a;b=h.l.length;for(a=a<b?a:b;k<a;)h.l[p]=f[k],k=1+k|0,p=1+p|0;e=e.remoteArgs;f=e.length|0;f=la(Xa(qa),[f]);a=f.l.length;p=k=0;b=e.length|0;a=b<a?b:a;b=f.l.length;for(a=a<b?a:b;k<a;)f.l[p]=e[k],k=1+k|0,p=1+p|0;e=wR(aa.exportsNamespace);try{this.Xj=mma(this.cu,h,e),d=(new CA).j(void 0)}catch(x){d=ko(Lg(),x);if(null!==d){h=Fw(Gw(),d);if(!h.z()){d=h.Y(); d=(new BA).ud(d);break a}throw Kg(Lg(),d);}throw x;}}yw(d)}else if("runnerDone"===a){this.Kp();try{var t=(new CA).j(this.Xj.fx())}catch(x){if(d=ko(Lg(),x),null!==d){h=Fw(Gw(),d);if(h.z())throw Kg(Lg(),d);d=h.Y();t=(new BA).ud(d)}else throw x;}this.Xj=null;yw(t)}else if("tasks"===a){a:{f=this.Hx(b);this.Kp();d=[];k=0;for(p=f.length|0;k<p;)a=f[k],a=qw(rw(),a),d.push(a),k=1+k|0;f=d.length|0;f=la(Xa(xR),[f]);a=f.l.length;p=k=0;b=d.length|0;a=b<a?b:a;b=f.l.length;for(a=a<b?a:b;k<a;)f.l[p]=d[k],k=1+k|0, p=1+p|0;try{e=nma(this.Xj,f),h=(new CA).j(ba.JSON.stringify(Bha(e)))}catch(x){d=ko(Lg(),x);if(null!==d){h=Fw(Gw(),d);if(!h.z()){d=h.Y();h=(new BA).ud(d);break a}throw Kg(Lg(),d);}throw x;}}yw(h)}else if("msg"===a){a:{d=Ee(b);this.Kp();try{k=this.Xj.zE(d),p=k.z()?":n":":s:"+k.Y(),f=(new CA).j(p)}catch(x){d=ko(Lg(),x);if(null!==d){h=Fw(Gw(),d);if(!h.z()){d=h.Y();f=(new BA).ud(d);break a}throw Kg(Lg(),d);}throw x;}}yw(f)}else throw(new df).c(u((new v).K((new w).f(["Unknown command: ",""])),(new w).f([a]))); };c.Kp=function(){if(null===this.Xj)throw(new ye).c("No runner created");};c.c=function(a){vw.prototype.c.call(this,a);return this};c.$classData=g({D6:0},!1,"org.scalajs.testinterface.internal.Master",{D6:1,w6:1,d:1});function GR(){this.ZV=this.BS=this.cu=null;this.Dt=!1;this.Xj=this.Px=null}GR.prototype=new ww;GR.prototype.constructor=GR;c=GR.prototype;c.Hx=function(a){return ba.JSON.parse(Ee(a))}; c.UT=function(a,b){try{for(this.Dt=!0;!this.Px.z();){var d=this.Px;if(d.z())throw(new Xu).c("queue empty");var e=d.cg.Zi;d.cg=d.cg.hi;var f=d;f.gi=-1+f.gi|0;0===f.gi&&(f.Tj=f.cg);wma(this,e)}if("newRunner"===a)yw(xma(this));else if("execute"===a)yma(this,this.Hx(b));else if("stopSlave"===a){this.Kp();try{var h=(new CA).j((this.Xj.fx(),void 0))}catch(ma){var k=ko(Lg(),ma);if(null!==k){var p=Fw(Gw(),k);if(p.z())throw Kg(Lg(),k);var t=p.Y(),h=(new BA).ud(t)}else throw ma;}this.Xj=null;yw(h)}else if("msg"=== a){var x;a:{var E=Ee(b);this.Kp();try{x=(new CA).j((this.Xj.zE(E),void 0))}catch(ma){var S=ko(Lg(),ma);if(null!==S){var U=Fw(Gw(),S);if(!U.z()){var ga=U.Y();x=(new BA).ud(ga);break a}throw Kg(Lg(),S);}throw ma;}}x.TD()&&yw(x)}else throw(new df).c(u((new v).K((new w).f(["Unknown command: ",""])),(new w).f([a])));}finally{this.Dt=!1}};function wma(a,b){Nn($e(),a.Dt);ba.scalajsCom.send(u((new v).K((new w).f(["msg:",""])),(new w).f([b])))} function xma(a){var b=wR(aa.exportsNamespace);try{for(var d=a.cu,e=a.BS,f=e.length|0,h=la(Xa(qa),[f]),k=h.l.length,p=f=0,t=e.length|0,k=t<k?t:k,x=h.l.length,x=k<x?k:x;f<x;)h.l[p]=e[f],f=1+f|0,p=1+p|0;for(var E=a.ZV,S=E.length|0,U=la(Xa(qa),[S]),ga=U.l.length,S=e=0,ma=E.length|0,ga=ma<ga?ma:ga,va=U.l.length,va=ga<va?ga:va;e<va;)U.l[S]=E[e],e=1+e|0,S=1+S|0;a.Xj=zma(d,h,b,m(new n,function(a){return function(b){if(a.Dt)wma(a,b);else{var d=a.Px;b=[b];for(var e=0,f=b.length|0;e<f;)HR(d,b[e]),e=1+e|0}}}(a))); return(new CA).j(void 0)}catch(Fa){a=ko(Lg(),Fa);if(null!==a){b=Fw(Gw(),a);if(!b.z())return a=b.Y(),(new BA).ud(a);throw Kg(Lg(),a);}throw Fa;}}c.Kp=function(){if(null===this.Xj)throw(new ye).c("No runner created");};c.oba=function(a,b,d){this.BS=b;this.ZV=d;vw.prototype.c.call(this,a);this.Dt=!1;this.Px=IR().bb().Da();return this}; function yma(a,b){a.Kp();var d=b.serializedTask,d=Ama(a.Xj,qw(rw(),ba.JSON.parse(d))),e=(new JR).yx(a);b=b.loggerColorSupport;for(var f=[],h=b.length|0,k=0;k<h;){var p=(new A).e(b[k],k);f.push(p);k=1+k|0}b=Xb(new Yb,(new mw).f(f),m(new n,function(){return function(a){return null!==a}}(a)));f=m(new n,function(a){return function(b){if(null!==b){var d=new KR;d.Qe=b.Dc();Yw.prototype.yx.call(d,a);return d}throw(new q).j(b);}}(a));h=(new mw).b();b.ga.wa(m(new n,function(a,b,d){return function(e){return a.ol.y(e)? d.Na(b.y(e)):void 0}}(b,f,h)));b=h.Wd;try{for(var t=b.length|0,x=la(Xa(Raa),[t]),E=x.l.length,f=t=0,S=b.length|0,E=S<E?S:E,U=x.l.length,U=E<U?E:U;t<U;)x.l[f]=b[t],t=1+t|0,f=1+f|0;rma(d,e,x,m(new n,function(a,b,d){return function(a){try{var e=(new CA).j(ba.JSON.stringify(Bha(a)))}catch(f){if(e=ko(Lg(),f),null!==e){a=Fw(Gw(),e);if(a.z())throw Kg(Lg(),e);e=a.Y();e=(new BA).ud(e)}else throw f;}b.Uy=!1;a=0;for(var h=d.length|0;a<h;)d[a].Uy=!1,a=1+a|0;yw(e)}}(a,e,b)));var ga=(new CA).j(void 0)}catch(ma){if(a= ko(Lg(),ma),null!==a){x=Fw(Gw(),a);if(x.z())throw Kg(Lg(),a);a=x.Y();ga=(new BA).ud(a)}else throw ma;}ga.TD()&&yw(ga)}c.$classData=g({F6:0},!1,"org.scalajs.testinterface.internal.Slave",{F6:1,w6:1,d:1}); function Bma(a){LR();a.iba=(new MR).cn(m(new n,function(){return function(a){if(Gx(a)){a=a.X;var d=Cma();try{var e,f=pc();0===(1&f.ya)&&0===(1&f.ya)&&(f.eG=ux(),f.ya=(1|f.ya)<<24>>24);e=f.eG;var h=(new NR).c(a),k=(new J).j(OR(new PR,QR(new RR,h,e.Hj)))}catch(t){var p=ko(Lg(),t);if(null!==p){if(d.gy.y(p))throw Kg(Lg(),p);if(d.pl.Ua(p))k=d.pl.y(p);else throw Kg(Lg(),p);}else throw t;}finally{e=d.rx,e.z()||e.Y().uba()}return k.z()?ox(lx(),mx(nx(),"error.expected.numberformatexception")):k.Y()}return Hx(a)? (k=a.X,e=ux(),OR(new PR,QR(new RR,k.Ec,e.Hj))):ox(lx(),mx(nx(),"error.expected.jsnumberorjsstring"))}}(a)));LR();a.vba=(new MR).cn(m(new n,function(){return function(a){if(Gx(a)){a=a.X;var d=Cma();try{var e=(new J).j(OR(new PR,(new NR).c(a)))}catch(h){var f=ko(Lg(),h);if(null!==f){if(d.gy.y(f))throw Kg(Lg(),f);if(d.pl.Ua(f))e=d.pl.y(f);else throw Kg(Lg(),f);}else throw h;}finally{f=d.rx,f.z()||f.Y().uba()}return e.z()?ox(lx(),mx(nx(),"error.expected.numberformatexception")):e.Y()}return Hx(a)?OR(new PR, a.X.Ec):ox(lx(),mx(nx(),"error.expected.jsnumberorjsstring"))}}(a)));a.sia=Dma(a)}function SR(){}SR.prototype=new l;SR.prototype.constructor=SR;SR.prototype.fq=function(){return this};SR.prototype.Ck=function(a){if(a&&a.$classData&&a.$classData.n.tB)return a=!!(new J).j(a.X).U,OR(new PR,a);a=r();var b=TR(),d=I(r(),(new w).f([mx(nx(),"error.expected.jsboolean")]));return(new UR).K(I(a,(new w).f([(new A).e(b,d)])))}; SR.prototype.$classData=g({M6:0},!1,"play.api.libs.json.DefaultReads$BooleanReads$",{M6:1,d:1,et:1});function VR(){}VR.prototype=new l;VR.prototype.constructor=VR;VR.prototype.fq=function(){return this};VR.prototype.Ck=function(a){var b=!1;return Hx(a)&&(b=!0,a=a.X,a.Eu())?OR(new PR,a.Ec.wi()):b?Ema("error.expected.int"):Ema("error.expected.jsnumber")};VR.prototype.$classData=g({N6:0},!1,"play.api.libs.json.DefaultReads$IntReads$",{N6:1,d:1,et:1});function WR(){}WR.prototype=new l; WR.prototype.constructor=WR;WR.prototype.fq=function(){return this};WR.prototype.Ck=function(a){if(Ix(a))return OR(new PR,a);a=r();var b=TR(),d=I(r(),(new w).f([mx(nx(),"error.expected.jsarray")]));return(new UR).K(I(a,(new w).f([(new A).e(b,d)])))};WR.prototype.$classData=g({O6:0},!1,"play.api.libs.json.DefaultReads$JsArrayReads$",{O6:1,d:1,et:1});function XR(){}XR.prototype=new l;XR.prototype.constructor=XR;XR.prototype.fq=function(){return this}; XR.prototype.Ck=function(a){if(Gx(a))return OR(new PR,a.X);a=r();var b=TR(),d=I(r(),(new w).f([mx(nx(),"error.expected.jsstring")]));return(new UR).K(I(a,(new w).f([(new A).e(b,d)])))};XR.prototype.$classData=g({P6:0},!1,"play.api.libs.json.DefaultReads$StringReads$",{P6:1,d:1,et:1});function YR(){this.IS=!1;this.ga=null}YR.prototype=new l;YR.prototype.constructor=YR; YR.prototype.Ck=function(a){if(Gx(a)){a=a.X;try{var b=(new CA).j(Fma(Gma(),a))}catch(e){if(b=ko(Lg(),e),null!==b){var d=Fw(Gw(),b);if(d.z())throw Kg(Lg(),b);b=d.Y();b=(new BA).ud(b)}else throw e;}b=b.uY();this.IS?(b.z()?a=!0:(d=b.Y(),a=null!==d&&a===d.k()),a=a?b:F()):a=b;a.z()?a=F():(a=a.Y(),a=(new J).j(OR(new PR,a)));return a.z()?(a=r(),b=TR(),d=I(r(),(new w).f([mx(nx(),"error.expected.uuid")])),(new UR).K(I(a,(new w).f([(new A).e(b,d)])))):a.Y()}a=r();b=TR();d=I(r(),(new w).f([mx(nx(),"error.expected.uuid")])); return(new UR).K(I(a,(new w).f([(new A).e(b,d)])))};function Dma(a){var b=new YR;b.IS=!1;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}YR.prototype.$classData=g({Q6:0},!1,"play.api.libs.json.DefaultReads$UUIDReader",{Q6:1,d:1,et:1});function MR(){this.$i=null}MR.prototype=new l;MR.prototype.constructor=MR;MR.prototype.Ck=function(a){return this.$i.y(a)};MR.prototype.cn=function(a){this.$i=a;return this};MR.prototype.$classData=g({c7:0},!1,"play.api.libs.json.Reads$$anon$8",{c7:1,d:1,et:1}); function ZR(){}ZR.prototype=new l;ZR.prototype.constructor=ZR;ZR.prototype.b=function(){return this};ZR.prototype.$classData=g({d7:0},!1,"play.api.libs.json.Reads$JsArrayMonoid$",{d7:1,d:1,L6:1});var Hma=void 0;function $R(){}$R.prototype=new l;$R.prototype.constructor=$R;$R.prototype.b=function(){return this};$R.prototype.$classData=g({e7:0},!1,"play.api.libs.json.Reads$JsObjectMonoid$",{e7:1,d:1,L6:1});var Ima=void 0;function ax(){this.rp=this.ik=null;this.hr=!1;this.ir=null}ax.prototype=new l; ax.prototype.constructor=ax;ax.prototype.o=function(a){return a&&a.$classData&&a.$classData.n.WQ?this.ik===a.ik&&this.rp===a.rp&&this.hr===a.hr?oja(gB(),this.ir,a.ir):!1:!1};ax.prototype.k=function(){var a=this.ik,b=this.rp,d=this.hr,e=this.ir,f=(new Fm).b(),h;h=!0;js(f,"[");for(var k=0,p=e.l.length;k<p;){var t=e.l[k];h?(ks(f,t),h=!1):(js(f,", "),ks(f,t));k=1+k|0}js(f,"]");return"TaskDef("+a+", "+b+", "+d+", "+f.vc.Zb+")"}; ax.prototype.r=function(){var a;a=this.ik;a=da(31,17)+Ha(Ia(),a)|0;var b=this.rp;a=da(31,a)+Ka(b)|0;a=da(31,a)+(this.hr?1:0)|0;a=da(31,a);var b=gB(),d=this.ir,b=pja(b);if(null===d)b=0;else{var d=Dw($e(),d),e=d.sa(),f=0,h=1;b:for(;;){if(f!==e){var k=1+f|0,f=d.W(f),h=da(31,h|0)+(null===f?0:b.y(f)|0)|0,f=k;continue b}break}b=h|0}return a+b|0};var xR=g({WQ:0},!1,"sbt.testing.TaskDef",{WQ:1,d:1,i:1});ax.prototype.$classData=xR;function aS(a){a.jp(Jma(a))}function bS(a){a.sh((new cS).wD(a))} function Kma(a,b,d,e){return a.$e(d,K(function(a,b,d){return function(){return a.$e(b,K(function(a,b){return function(){return a.Xc(b,m(new n,function(){return function(a){return sb(a)}}(a)))}}(a,d)))}}(a,b,e)))}function dS(){this.ga=null}dS.prototype=new l;dS.prototype.constructor=dS;function Lma(a){var b=new dS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}dS.prototype.$classData=g({A7:0},!1,"scalaz.Associative$$anon$3",{A7:1,d:1,Qla:1});function eS(){this.ga=null}eS.prototype=new l; eS.prototype.constructor=eS;function Saa(a){var b=new eS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}eS.prototype.$classData=g({C7:0},!1,"scalaz.Bifoldable$$anon$8",{C7:1,d:1,raa:1});function fS(){this.ga=null}fS.prototype=new l;fS.prototype.constructor=fS;function Taa(a){var b=new fS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}fS.prototype.$classData=g({D7:0},!1,"scalaz.Bifunctor$$anon$7",{D7:1,d:1,saa:1});function cA(a){a.mv(Mma(a))}function gS(a){a.rm(Nma(a))} function hS(){this.ga=null}hS.prototype=new l;hS.prototype.constructor=hS;function Uaa(a){var b=new hS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}hS.prototype.$classData=g({M7:0},!1,"scalaz.Compose$$anon$4",{M7:1,d:1,yw:1});function iS(){}iS.prototype=new l;iS.prototype.constructor=iS;c=iS.prototype;c.b=function(){Vd(this);return this};c.Md=function(a){return a};c.Xg=function(a){return a.k()};c.Tg=function(){};c.$classData=g({Q7:0},!1,"scalaz.Cord$$anon$2",{Q7:1,d:1,ch:1});function jS(){} jS.prototype=new l;jS.prototype.constructor=jS;jS.prototype.b=function(){zd(this);return this};jS.prototype.Vf=function(){};jS.prototype.$classData=g({R7:0},!1,"scalaz.Cord$$anon$3",{R7:1,d:1,ag:1});function kS(){this.ga=null}kS.prototype=new l;kS.prototype.constructor=kS;function lS(a){var b=new kS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}kS.prototype.$classData=g({S7:0},!1,"scalaz.Cozip$$anon$1",{S7:1,d:1,Wla:1});function mS(){}mS.prototype=new Vha;mS.prototype.constructor=mS; function Oma(){}Oma.prototype=mS.prototype;function Qx(){}Qx.prototype=new l;Qx.prototype.constructor=Qx;Qx.prototype.OE=function(){};Qx.prototype.xD=function(){this.OE(Lma(this));return this};Qx.prototype.$classData=g({U7:0},!1,"scalaz.DisjunctionInstances2$$anon$7",{U7:1,d:1,z7:1});function nS(){}nS.prototype=new Wha;nS.prototype.constructor=nS;function Pma(){}Pma.prototype=nS.prototype;function oS(){}oS.prototype=new Yha;oS.prototype.constructor=oS;function Qma(){}Qma.prototype=oS.prototype; function pS(a){a.Lh(Rma(a))}function qS(){this.ga=null}qS.prototype=new l;qS.prototype.constructor=qS;function Vaa(a){var b=new qS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}qS.prototype.$classData=g({c8:0},!1,"scalaz.Equal$$anon$4",{c8:1,d:1,vR:1});function rS(){}rS.prototype=new jia;rS.prototype.constructor=rS; function ky(a,b,d,e,f){var h=f.Le(f.Le(f.Al(b),d),e);return Sma(new sS,h,K(function(a,b){return function(){return b}}(a,b)),K(function(a,b){return function(){return b}}(a,d)),K(function(a,b){return function(){return b}}(a,e)),f)}rS.prototype.b=function(){return this};function By(a,b,d,e){return tS(new uS,e.Le(e.Al(b),d),b,d,e)}function hy(a,b,d,e){var f=e.Le(e.Al(b),d);return Tma(new vS,f,K(function(a,b){return function(){return b}}(a,b)),K(function(a,b){return function(){return b}}(a,d)),e)} function Ay(a,b,d){a=new wS;var e=d.Al(b);a.of=e;a.Aa=b;a.Qg=d;a.Ai=e;return a}function Uma(a,b,d){var e=d.Al(b);return yy(new zy,e,K(function(a,b){return function(){return b}}(a,b)),d)}rS.prototype.$classData=g({d8:0},!1,"scalaz.FingerTree$",{d8:1,Ija:1,d:1});var xS=void 0;function iy(){xS||(xS=(new rS).b());return xS}function sS(){this.sS=this.rS=this.pS=this.GY=this.Ai=null}sS.prototype=new sz;sS.prototype.constructor=sS;sS.prototype.$C=function(a,b){return Rc(b,this.GY,this.pS,this.rS,this.sS)}; function Sma(a,b,d,e,f,h){a.GY=b;a.pS=d;a.rS=e;a.sS=f;rz.prototype.dj.call(a,h);a.Ai=b;return a}sS.prototype.$classData=g({e8:0},!1,"scalaz.FingerTree$$anon$10",{e8:1,W8:1,d:1});function zy(){this.nS=this.DY=this.ea=null}zy.prototype=new Yx;zy.prototype.constructor=zy;zy.prototype.ih=function(a,b){return rb(b,this.DY,Ee(this.nS))};function yy(a,b,d,e){a.DY=b;a.nS=d;Xx.prototype.dj.call(a,e);return a}zy.prototype.$classData=g({f8:0},!1,"scalaz.FingerTree$$anon$18",{f8:1,cR:1,d:1}); function ey(){this.$X=this.LV=this.EY=this.hV=this.ea=null}ey.prototype=new Yx;ey.prototype.constructor=ey;function dy(a,b,d,e,f,h){a.EY=b;a.LV=d;a.$X=f;Xx.prototype.dj.call(a,h);xy(iy(),h);a.hV=(Zx(),(new $x).yc(e));return a}ey.prototype.ih=function(a,b,d){return Rc(d,this.EY,this.LV,K(function(a){return function(){return T(a.hV)}}(this)),this.$X)};ey.prototype.$classData=g({g8:0},!1,"scalaz.FingerTree$$anon$19",{g8:1,cR:1,d:1});function Td(){this.gV=this.ea=null}Td.prototype=new Yx; Td.prototype.constructor=Td;Td.prototype.dj=function(a){this.gV=a;Xx.prototype.dj.call(this,a);return this};Td.prototype.ih=function(a){return a.y(this.gV.jl().he())};Td.prototype.$classData=g({h8:0},!1,"scalaz.FingerTree$$anon$8",{h8:1,cR:1,d:1});function vS(){this.qS=this.oS=this.FY=this.Ai=null}vS.prototype=new sz;vS.prototype.constructor=vS;vS.prototype.$C=function(a){var b=this.FY,d=this.oS,e=this.qS;return(0,a.vi)(b,d,e)}; function Tma(a,b,d,e,f){a.FY=b;a.oS=d;a.qS=e;rz.prototype.dj.call(a,f);a.Ai=b;return a}vS.prototype.$classData=g({i8:0},!1,"scalaz.FingerTree$$anon$9",{i8:1,W8:1,d:1});function yS(){}yS.prototype=new l;yS.prototype.constructor=yS;c=yS.prototype;c.mi=function(a){return Ad(this,a)};c.ls=function(){Ed(this);return this};c.Hi=function(){};c.Zh=function(a,b,d){return iia(a,b,d)};c.Hg=function(a,b,d){return a.Gb(b,d)};c.$classData=g({j8:0},!1,"scalaz.FingerTreeInstances$$anon$11",{j8:1,d:1,Wi:1}); function ry(){this.lr=this.Hw=this.fz=null}ry.prototype=new l;ry.prototype.constructor=ry;ry.prototype.Md=function(a){return Vma(this,a)};ry.prototype.Xg=function(a){return this.Md(a).k()};ry.prototype.Tg=function(){}; function Vma(a,b){return b.ih(m(new n,function(a){return function(b){var f=Qd();b=[a.Hw.Md(b),Rd(Qd()," []")];var h=b.length|0,k=0,p=Sd((new Td).dj(f.Pq));a:for(;;){if(k!==h){f=1+k|0;p=Ud(p,b[k]);k=f;continue a}return p}}}(a)),tb(new ub,function(a){return function(b,f){var h=Qd();b=[a.Hw.Md(b),Rd(Qd()," ["),a.lr.Md(f),Rd(Qd(),"]")];f=b.length|0;var k=0,p=Sd((new Td).dj(h.Pq));a:for(;;){if(k!==f){h=1+k|0;p=Ud(p,b[k]);k=h;continue a}return p}}}(a)),by(function(a){return function(b,f,h,k){h=Qd();b=[a.Hw.Md(b), Rd(Qd()," ["),a.fz.Md(f.ub()),Rd(Qd(),", ?, "),a.fz.Md(k.ub()),Rd(Qd(),"]")];f=b.length|0;k=0;var p=Sd((new Td).dj(h.Pq));a:for(;;){if(k!==f){h=1+k|0;p=Ud(p,b[k]);k=h;continue a}return p}}}(a)))}ry.prototype.$classData=g({k8:0},!1,"scalaz.FingerTreeInstances$$anon$12",{k8:1,d:1,ch:1});function wy(){}wy.prototype=new l;wy.prototype.constructor=wy;c=wy.prototype;c.mi=function(a){return Ad(this,a)};c.ls=function(){Ed(this);return this};c.Hi=function(){};c.Zh=function(a,b,d){return a.an(b,d)}; c.Hg=function(a,b,d){return Fd(this,a,b,d)};c.$classData=g({m8:0},!1,"scalaz.FingerTreeInstances$$anon$7",{m8:1,d:1,Wi:1});function zS(){this.ga=null}zS.prototype=new l;zS.prototype.constructor=zS;function Waa(a){var b=new zS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}zS.prototype.$classData=g({n8:0},!1,"scalaz.Foldable$$anon$6",{n8:1,d:1,RB:1});function AS(){}AS.prototype=new qia;AS.prototype.constructor=AS;function Wma(){}Wma.prototype=AS.prototype;function BS(){this.ND=null}BS.prototype=new sia; BS.prototype.constructor=BS;function Xma(){}Xma.prototype=BS.prototype;BS.prototype.b=function(){var a=new CS;Md(a);Ty(a);Ed(a);xz(a);bS(a);DS(a);ES(a);FS(a);Nd(a);Gz(a);GS(a);HS(a);IS(a);Xd(a);Wd(a);aS(a);JS(a);gS(a);this.ND=a;return this};function KS(){this.lr=null}KS.prototype=new l;KS.prototype.constructor=KS; function Yma(a,b){if(wq(b))b=LS(Qd());else{if(!xq(b))throw(new q).j(b);b=Zma(a,b.dd,a.lr.Md(b.$c))}Qd();b=ay(b.pc,K(function(a,b){return function(){return b}}(b,"[")));return MS(Sd(b),K(function(){return function(){return"]"}}(a)))}KS.prototype.Md=function(a){return Yma(this,a)};function Zma(a,b,d){for(;;){if(wq(b))return d;if(xq(b)){var e=b;b=e.$c;e=e.dd;d=Ud(MS(d,K(function(){return function(){return","}}(a))),a.lr.Md(b));b=e}else throw(new q).j(b);}}KS.prototype.Xg=function(a){return this.Md(a).k()}; KS.prototype.Tg=function(){};KS.prototype.$classData=g({w8:0},!1,"scalaz.IListInstances$$anon$6",{w8:1,d:1,ch:1});function gA(){this.wx=null}gA.prototype=new l;gA.prototype.constructor=gA;gA.prototype.b=function(){fA=this;this.QE($ma());return this};gA.prototype.QE=function(a){this.wx=a};gA.prototype.$classData=g({x8:0},!1,"scalaz.Id$",{x8:1,d:1,y8:1});var fA=void 0;function NS(){}NS.prototype=new tia;NS.prototype.constructor=NS;function ana(){}ana.prototype=NS.prototype; function Uz(){this.IG=this.Io=null}Uz.prototype=new Xy;Uz.prototype.constructor=Uz;function Tz(a,b,d){a.Io=b;a.IG=d;return a}Uz.prototype.bD=function(){return m(new n,function(a){return function(){return a.IG.vd(K(function(a){return function(){return a.Io}}(a)))}}(this))};Uz.prototype.$classData=g({D8:0},!1,"scalaz.IndexedStateT$$anon$10",{D8:1,C8:1,d:1});function Yy(){this.ET=null}Yy.prototype=new Xy;Yy.prototype.constructor=Yy;Yy.prototype.cn=function(a){this.ET=a;return this}; Yy.prototype.bD=function(){return m(new n,function(a){return function(b){return b.vd(K(function(a,b){return function(){return a.ET.y(b)}}(a,b)))}}(this))};Yy.prototype.$classData=g({E8:0},!1,"scalaz.IndexedStateT$$anon$11",{E8:1,C8:1,d:1});function OS(){}OS.prototype=new yia;OS.prototype.constructor=OS;function bna(){}bna.prototype=OS.prototype;function PS(){this.ga=null}PS.prototype=new l;PS.prototype.constructor=PS;function aba(a){var b=new PS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b} PS.prototype.$classData=g({F8:0},!1,"scalaz.InvariantFunctor$$anon$2",{F8:1,d:1,Xi:1});function JS(a){a.Ls(cna(a))}function cz(){this.ga=null}cz.prototype=new l;cz.prototype.constructor=cz;cz.prototype.zD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};cz.prototype.$classData=g({H8:0},!1,"scalaz.Isomorphisms$IsoBifunctorTemplate$$anon$14",{H8:1,d:1,B7:1});function dz(){this.ga=null}dz.prototype=new l;dz.prototype.constructor=dz; dz.prototype.zD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};dz.prototype.$classData=g({I8:0},!1,"scalaz.Isomorphisms$IsoBifunctorTemplate$$anon$15",{I8:1,d:1,B7:1});function fz(){this.ga=null}fz.prototype=new l;fz.prototype.constructor=fz;fz.prototype.AD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};fz.prototype.$classData=g({J8:0},!1,"scalaz.Isomorphisms$IsoFunctorTemplate$$anon$12",{J8:1,d:1,nR:1});function gz(){this.ga=null}gz.prototype=new l; gz.prototype.constructor=gz;gz.prototype.AD=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};gz.prototype.$classData=g({K8:0},!1,"scalaz.Isomorphisms$IsoFunctorTemplate$$anon$13",{K8:1,d:1,nR:1});function QS(){}QS.prototype=new zia;QS.prototype.constructor=QS;function dna(){}dna.prototype=QS.prototype;function re(){}re.prototype=new Bia;re.prototype.constructor=re;re.prototype.b=function(){jz.prototype.b.call(this);return this}; re.prototype.$classData=g({M8:0},!1,"scalaz.Leibniz$",{M8:1,mka:1,d:1});var qe=void 0;function se(){}se.prototype=new Aia;se.prototype.constructor=se;se.prototype.b=function(){return this};se.prototype.$classData=g({N8:0},!1,"scalaz.Leibniz$$anon$2",{N8:1,lka:1,d:1});function RS(){}RS.prototype=new Cia;RS.prototype.constructor=RS;function ena(){}ena.prototype=RS.prototype;RS.prototype.b=function(){wd(new SS);return this};function SS(){}SS.prototype=new l;SS.prototype.constructor=SS; SS.prototype.Js=function(){};SS.prototype.$classData=g({P8:0},!1,"scalaz.MapInstances$$anon$5",{P8:1,d:1,gt:1});function TS(){}TS.prototype=new Eia;TS.prototype.constructor=TS;function fna(){}fna.prototype=TS.prototype;function US(){this.qE=null}US.prototype=new Jia;US.prototype.constructor=US;function gna(){}gna.prototype=US.prototype;US.prototype.b=function(){this.qE=(new VS).gq(this);return this};function Yq(){}Yq.prototype=new l;Yq.prototype.constructor=Yq; Yq.prototype.Xb=function(a,b){return Zq(a,Ee(b))};Yq.prototype.gq=function(){Od(this);return this};Yq.prototype.ff=function(){};Yq.prototype.$classData=g({Z8:0},!1,"scalaz.NonEmptyListInstances$$anon$2",{Z8:1,d:1,sf:1});function Hq(){}Hq.prototype=new l;Hq.prototype.constructor=Hq;Hq.prototype.b=function(){return this};Hq.prototype.$classData=g({$8:0},!1,"scalaz.NotNothing$$anon$1",{$8:1,d:1,uka:1}); function hna(a,b,d,e){return e.Xb(d.y(b.Fc),K(function(a,b,d,e){return function(){return a.Xm.Zh(b.Mc,d,e)}}(a,b,d,e)))}function WS(){}WS.prototype=new Kia;WS.prototype.constructor=WS;function ina(){}ina.prototype=WS.prototype;function XS(){this.ga=null}XS.prototype=new l;XS.prototype.constructor=XS;function jna(a){var b=new XS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}XS.prototype.$classData=g({e9:0},!1,"scalaz.Optional$$anon$1",{e9:1,d:1,ama:1});function YS(){this.ga=null}YS.prototype=new l; YS.prototype.constructor=YS;function bba(a){var b=new YS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}YS.prototype.$classData=g({g9:0},!1,"scalaz.Plus$$anon$5",{g9:1,d:1,zw:1});function ZS(){this.ga=null}ZS.prototype=new l;ZS.prototype.constructor=ZS;function kna(a){var b=new ZS;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}ZS.prototype.$classData=g({k9:0},!1,"scalaz.Profunctor$$anon$6",{k9:1,d:1,TB:1});function Oz(){}Oz.prototype=new Nia;Oz.prototype.constructor=Oz; Oz.prototype.b=function(){Jz.prototype.b.call(this);return this};Oz.prototype.$classData=g({m9:0},!1,"scalaz.Reducer$",{m9:1,Gka:1,d:1});var Nz=void 0;function $S(){this.cV=this.dT=this.OF=this.eV=null}$S.prototype=new Iz;$S.prototype.constructor=$S;c=$S.prototype;c.jl=function(){return this.eV};c.Al=function(a){return this.OF.y(a)};c.Le=function(a,b){return this.cV.Xb(a,K(function(a,b){return function(){return a.OF.y(b)}}(this,b)))};c.so=function(a,b){return this.dT.y(a).y(b)}; function Pia(a,b,d){var e=new $S;e.OF=a;e.dT=b;e.cV=d;e.eV=d;return e}c.$classData=g({n9:0},!1,"scalaz.ReducerInstances$$anon$6",{n9:1,l9:1,d:1});function aT(){this.ga=null}aT.prototype=new l;aT.prototype.constructor=aT;function cba(a){var b=new aT;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}aT.prototype.$classData=g({p9:0},!1,"scalaz.Semigroup$$anon$7",{p9:1,d:1,Aaa:1});function bT(){this.ga=null}bT.prototype=new l;bT.prototype.constructor=bT; function dba(a){var b=new bT;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}bT.prototype.$classData=g({s9:0},!1,"scalaz.Show$$anon$2",{s9:1,d:1,cma:1});function qy(){}qy.prototype=new l;qy.prototype.constructor=qy;c=qy.prototype;c.b=function(){Vd(this);return this};c.Md=function(a){return Pd(this,a)};c.Xg=function(a){return na(a)};c.Tg=function(){};c.$classData=g({t9:0},!1,"scalaz.Show$$anon$3",{t9:1,d:1,ch:1});function Xz(){}Xz.prototype=new l;Xz.prototype.constructor=Xz;Xz.prototype.b=function(){return this}; Xz.prototype.$classData=g({A9:0},!1,"scalaz.Tag$TagOf",{A9:1,d:1,nR:1});function cT(){}cT.prototype=new l;cT.prototype.constructor=cT;cT.prototype.b=function(){dT=this;this.XE(lna());return this};function mna(a,b){a=K(function(a,b){return function(){var a=Ee(b);eT();return(new Ny).j(a)}}(a,b));return nna(eT(),a)}cT.prototype.XE=function(){};cT.prototype.$classData=g({C9:0},!1,"scalaz.Trampoline$",{C9:1,d:1,D9:1});var dT=void 0;function fT(){this.XB=null}fT.prototype=new l; fT.prototype.constructor=fT;function ona(a){var b=new fT;b.XB=a;return b}fT.prototype.$classData=g({J9:0},!1,"scalaz.Unapply_0$$anon$14",{J9:1,d:1,Rka:1});function gT(){}gT.prototype=new Ria;gT.prototype.constructor=gT;function pna(){}pna.prototype=gT.prototype;function hT(){}hT.prototype=new Iz;hT.prototype.constructor=hT;function qna(){}qna.prototype=hT.prototype;hT.prototype.Le=function(a,b){return this.jl().Xb(a,K(function(a,b){return function(){return a.Al(b)}}(this,b)))}; hT.prototype.so=function(a,b){return this.jl().Xb(this.Al(a),K(function(a,b){return function(){return b}}(this,b)))};function iT(){this.ga=null}iT.prototype=new l;iT.prototype.constructor=iT;function eba(a){var b=new iT;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}iT.prototype.$classData=g({L9:0},!1,"scalaz.Unzip$$anon$3",{L9:1,d:1,Ina:1});function jT(){}jT.prototype=new Sia;jT.prototype.constructor=jT;function rna(){}rna.prototype=jT.prototype;function kT(){this.ga=null}kT.prototype=new l; kT.prototype.constructor=kT;function fba(a){var b=new kT;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}kT.prototype.$classData=g({Q9:0},!1,"scalaz.Zip$$anon$5",{Q9:1,d:1,Jna:1});function sna(a){a.dX((new lT).BD(a));a.eX((new mT).BD(a))}function ty(){this.Xt=null}ty.prototype=new l;ty.prototype.constructor=ty;ty.prototype.Md=function(a){return tna(this,a)};ty.prototype.Xg=function(a){return this.Md(a).k()};ty.prototype.Tg=function(){}; function tna(a,b){var d=Qd(),e=Rd(Qd(),","),f=m(new n,function(a){return function(b){py();return a.Xt.Md(b)}}(a)),h=Lc();b=una(d,e,b.xa(f,h.s).Hc());Qd();b=ay(b.pc,K(function(a,b){return function(){return b}}(b,"[")));return MS(Sd(b),K(function(){return function(){return"]"}}(a)))}ty.prototype.$classData=g({E$:0},!1,"scalaz.std.IterableInstances$$anon$2",{E$:1,d:1,ch:1});function nT(){}nT.prototype=new l;nT.prototype.constructor=nT;nT.prototype.OE=function(){}; nT.prototype.ou=function(){this.OE(Lma(this));return this};nT.prototype.$classData=g({U$:0},!1,"scalaz.std.TupleInstances1$$anon$72",{U$:1,d:1,z7:1});function oT(){this.Dx=this.At=null}oT.prototype=new l;oT.prototype.constructor=oT;c=oT.prototype;c.bX=function(){};c.TW=function(){};c.UW=function(){};c.b=function(){pT=this;gba(this);return this};c.XW=function(a){this.Dx=a};c.cX=function(){};c.RW=function(){};c.aX=function(){};c.QW=function(){};c.VW=function(){};c.SW=function(){};c.WW=function(){}; c.$W=function(){};c.YW=function(){};c.ZW=function(){};c.PW=function(){};c.$classData=g({Z$:0},!1,"scalaz.std.anyVal$",{Z$:1,d:1,X9:1});var pT=void 0;function Kz(){pT||(pT=(new oT).b());return pT}function sy(){}sy.prototype=new l;sy.prototype.constructor=sy;sy.prototype.b=function(){return this};sy.prototype.$classData=g({aaa:0},!1,"scalaz.std.iterable$",{aaa:1,d:1,kla:1});var fia=void 0;function qT(){this.$i=null}qT.prototype=new l;qT.prototype.constructor=qT; qT.prototype.FD=function(a,b,d){this.$i=d;return this};qT.prototype.$classData=g({faa:0},!1,"scalaz.std.java.util.concurrent.CallableInstances$$anon$1$$anon$3",{faa:1,d:1,NU:1});function rT(){this.ox=null}rT.prototype=new l;rT.prototype.constructor=rT;rT.prototype.FD=function(a,b,d){this.ox=d;return this};rT.prototype.$classData=g({gaa:0},!1,"scalaz.std.java.util.concurrent.CallableInstances$$anon$1$$anon$4",{gaa:1,d:1,NU:1});function sT(){}sT.prototype=new l;sT.prototype.constructor=sT; sT.prototype.$classData=g({haa:0},!1,"scalaz.std.java.util.concurrent.CallableInstances$$anon$1$$anon$5",{haa:1,d:1,NU:1});function Mz(){}Mz.prototype=new l;Mz.prototype.constructor=Mz;Mz.prototype.b=function(){Lz=this;hba(this);return this};Mz.prototype.gX=function(){};Mz.prototype.fX=function(){};Mz.prototype.$classData=g({oaa:0},!1,"scalaz.std.math.bigInt$",{oaa:1,d:1,laa:1});var Lz=void 0;function pe(){this.nr=this.pc=null}pe.prototype=new l;pe.prototype.constructor=pe; function jba(a,b,d){a.pc=b;a.nr=d;return a}pe.prototype.$classData=g({vaa:0},!1,"scalaz.syntax.FoldableOps",{vaa:1,d:1,yaa:1});function tT(){}tT.prototype=new l;tT.prototype.constructor=tT;tT.prototype.pu=function(){return this};tT.prototype.$classData=g({Eaa:0},!1,"scalaz.syntax.Syntaxes$nel$",{Eaa:1,d:1,Kaa:1});function uT(){this.nr=this.pc=null}uT.prototype=new l;uT.prototype.constructor=uT; function vna(a,b){return b.XB.uh(a.pc,m(new n,function(){return function(a){qe||(qe=(new re).b());(new se).b();return a}}(a,b)),a.nr)}function wna(a,b){var d=new uT;d.pc=a;d.nr=b;return d}uT.prototype.$classData=g({Naa:0},!1,"scalaz.syntax.TraverseOps",{Naa:1,d:1,yaa:1});function vT(){this.pE=this.NF=this.aD=null}vT.prototype=new l;vT.prototype.constructor=vT;vT.prototype.b=function(){return this};function xna(){var a=wT();null===wT().NF&&null===wT().NF&&(wT().NF=(new xT).pu(a));wT()} function Hfa(){var a=wT();null===wT().aD&&null===wT().aD&&(wT().aD=(new yT).pu(a));wT()}vT.prototype.$classData=g({Paa:0},!1,"scalaz.syntax.package$",{Paa:1,d:1,dma:1});var zT=void 0;function wT(){zT||(zT=(new vT).b());return zT}function AT(){}AT.prototype=new l;AT.prototype.constructor=AT;AT.prototype.b=function(){return this}; AT.prototype.Fs=function(a){var b=yna().NC.Ac;BT(b,"Failure in RunNow async execution: "+a);CT(b,"\n");b=yna().NC.Ac;wja||(wja=(new BB).b());a=ix(a);var d=zja().iz,e=zja().iz,f=(new Fm).b(),h;h=!0;js(f,"");for(var k=0,p=a.l.length;k<p;){var t=a.l[k];h?(ks(f,t),h=!1):(js(f,d),ks(f,t));k=1+k|0}js(f,e);BT(b,f.vc.Zb);CT(b,"\n")};AT.prototype.Yt=function(a){try{a.om()}catch(b){a=ko(Lg(),b);if(null!==a)throw Kg(Lg(),a);throw b;}}; AT.prototype.$classData=g({Taa:0},!1,"utest.framework.ExecutionContext$RunNow$",{Taa:1,d:1,jy:1});var DT=void 0;function ET(){DT||(DT=(new AT).b());return DT}function FT(){this.qY=this.za=null}FT.prototype=new l;FT.prototype.constructor=FT;function GT(){}GT.prototype=FT.prototype; function zna(a,b,d,e,f){wha||(wha=(new uw).b());var h=vha(e,a.qY),k=b.zb("."),p=""+u((new v).K((new w).f(["Starting Suite "])),y())+e,t=(new Sb).c("-"),t=Ana(t,(80-(p.length|0)|0)/2|0);d.wa(m(new n,function(a,b,d){return function(a){a.lD(""+d+b+d)}}(a,p,t)));HA||(HA=(new GA).b());p=h.ria();p=eja(vA(p),b);if(null===p)throw(new q).j(p);a.tS(p.pa().sa());for(var p=a.za,t=p.l.length,x=0;;){if(x<t)var E=p.l[x],E=!(0<=(E.length|0)&&"--parallel"===E.substring(0,10));else E=!1;if(E)x=1+x|0;else break}t=x; p=t<p.l.length?(new J).j(p.l[t]):F();p.z()?p=!1:(p=p.Y(),p=(new Sb).c(p),t=10,x=p.R.length|0,p=Ye(Ze(),p.R,t,x),0===(p.length|0)?p=!0:(p=(new Sb).c(p),t=p.R.length|0,p=Ye(Ze(),p.R,1,t),p=(new Sb).c(p),p=Ki(p.R)));p=p?KB():ET();HA||(HA=(new GA).b());t=h.ria();t=vA(t);d=tb(new ub,function(a,b,d,e,f,h,k){return function(p,t){t.X.Ex()?a.dU():a.cU();var x=r();p=h.Zna(b.Rc(p,x.s),t);Bna((new HT).b(),Tv().VB,f,k);p.z()||(x=p.Y(),d.wa(m(new n,function(a,b,d){return function(a){a.lD(""+b+d)}}(a,e,x))));t= t.X;if(Aw(t)){t=t.rk;Bna((new HT).ud(t),Tv().hw,f,k);for(var x=ix(t),E=x.l.length,$a=0;;)if($a<E&&"utest.framework.TestThunkTree"!==x.l[$a].xo)$a=1+$a|0;else break;E=$a;E=0<E?E:0;$a=x.l.length;E=E<$a?E:$a;E=0<E?E:0;$a=ZA(aB(),LA(oa(x)),E);0<E&&dw(Rf(),x,0,$a,0,E);Cna(t,$a);a.dC(""+e+(p.z()?"":p.Y()));if(Dna(t))p="";else{p=ix(t);t=null;t=[];x=0;for(E=p.l.length;x<E;)$a=p.l[x].k(),t.push(null===$a?null:$a),x=1+x|0;p=ka(Xa(qa),t);t=(new Fm).b();x=!1;x=!0;js(t,"");E=0;for($a=p.l.length;E<$a;){var fc= p.l[E];x?(ks(t,fc),x=!1):(js(t,"\n"),ks(t,fc));E=1+E|0}js(t,"");p=t.vc.Zb}a.fC(p)}}}(a,b,d,e,f,h,k));e=m(new n,function(a,b,d){return function(a){return b.wpa(a,d)}}(a,h,p));f=y();return hja(t,d,f,b,e,p).Ih(m(new n,function(a,b){return function(a){return b.aoa(a)}}(a,h)),p).Ih(m(new n,function(a){return function(b){b.z()||(b=b.Y(),a.eC(b))}}(a)),p)}function Bna(a,b,d,e){d.VT(Ena(e,a,b))} function nma(a,b){var d;d=[];for(var e=0,f=b.l.length;e<f;){var h=Ama(a,b.l[e]);d.push(null===h?null:h);e=1+e|0}return ka(Xa(vd),d)}FT.prototype.fU=function(a,b,d){this.za=a;this.qY=d;return this};function Ama(a,b){var d=Yt($e(),a.za),d=md(new nd,d).Uc(0),d=d.z()||45!==(65535&(d.Y().charCodeAt(0)|0))?d:F(),d=d.z()?"":d.Y();return Fna(new IT,b,d,by(function(a){return function(b,d,k,p){return zna(a,b,d,k,p)}}(a)))}function JT(){this.zF=this.rV=this.uF=null}JT.prototype=new l; JT.prototype.constructor=JT;function Ena(a,b,d){var e=new JT;e.uF=a;e.rV=b;e.zF=d;return e}JT.prototype.$classData=g({Zaa:0},!1,"utest.runner.BaseRunner$$anon$2",{Zaa:1,d:1,oja:1});function KT(){}KT.prototype=new l;KT.prototype.constructor=KT;KT.prototype.b=function(){return this};function uha(){var a=(new w).f([new LT]),b=a.oa.length|0,b=la(Xa(Qaa),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e;d=1+d|0}return b} function mma(a,b,d){return Gna(new MT,b,d,K(function(){return function(){}}(a)),K(function(){return function(){}}(a)))}function zma(a,b,d,e){return Hna(new NT,b,d,e,K(function(){return function(){}}(a)),K(function(){return function(){}}(a)))}KT.prototype.$classData=g({aba:0},!1,"utest.runner.Framework",{aba:1,d:1,i7:1});function IT(){this.DE=this.Og=this.Dv=null}IT.prototype=new l;IT.prototype.constructor=IT; function rma(a,b,d,e){var f=ET();Ina(a,b,d).Es(Jna(d),f).ap(m(new n,function(a,b){return function(){var a=y(),d=wn(a),d=la(Xa(vd),[d]),e;e=0;for(a=Cv(a);a.ta();){var f=a.ma();d.l[e]=f;e=1+e|0}b.y(d)}}(a,e)),f)}function Fna(a,b,d,e){a.Dv=b;a.Og=d;a.DE=e;return a} function Ina(a,b,d){if(Wp(Ia(),a.Og,"}")){var e=(new Sb).c(a.Og),f=a.Og.lastIndexOf("{")|0,f=Fj(e,f);if(null===f)throw(new q).j(f);var e=f.la(),f=(new Sb).c(f.pa()),h=f.R.length|0,f=Ye(Ze(),f.R,1,h),f=(new Sb).c(f),f=Sm(f,1),f=QE(Ia(),f,",");Rf();(new AB).b();var h=Kna().bb(),k=f.l.length;switch(k){case -1:break;default:h.tc(k)}for(var k=0,p=f.l.length;k<p;)h.Na(""+e+f.l[k].trim()),k=1+k|0;f=h.Da()}else f=I(r(),(new w).f([a.Og]));h=a.Dv.ik;if(f.le(m(new n,function(a,b){return function(a){return 0<= (b.length|0)&&b.substring(0,a.length|0)===a}}(a,h))))return Rc(a.DE,y(),Yt($e(),d),h,b);e=ET();f=f.al(m(new n,function(a,b){return function(a){return 0<=(a.length|0)&&a.substring(0,b.length|0)===b}}(a,h)),!1);a=m(new n,function(a,b,d,e){return function(f){var h=a.DE;$e();f=(new Sb).c(f);var k=e.length|0,p=f.R.length|0;f=Ye(Ze(),f.R,k,p);f=QE(Ia(),f,"\\.");for(var k=(new OT).So(Lna(Mna(),LA(oa(f)))),p=0,Fa=f.l.length;p<Fa;){var Va=f.l[p];!1!==0<(Va.length|0)&&Nna(k,Va);p=1+p|0}return Rc(h,Yt(0,Ona(k)), Yt($e(),d),e,b)}}(a,b,d,h));b=r();a=f.xa(a,b.s);b=xA();d=r();return QB(b,a,d.s,e)}IT.prototype.$classData=g({fba:0},!1,"utest.runner.Task",{fba:1,d:1,VQ:1});function PT(){}PT.prototype=new l;PT.prototype.constructor=PT;function QT(){}QT.prototype=PT.prototype;function eF(a){return!!(a&&a.$classData&&a.$classData.n.xk||"number"===typeof a)}function RT(){this.Zr=this.xs=this.xo=null;this.Gt=this.vs=0}RT.prototype=new l;RT.prototype.constructor=RT; RT.prototype.o=function(a){return a&&a.$classData&&a.$classData.n.LU?this.Zr===a.Zr&&this.vs===a.vs&&this.xo===a.xo&&this.xs===a.xs:!1};RT.prototype.k=function(){var a="";"\x3cjscode\x3e"!==this.xo&&(a=""+a+this.xo+".");a=""+a+this.xs;null===this.Zr?a+="(Unknown Source)":(a=""+a+u((new v).K((new w).f(["(",""])),(new w).f([this.Zr])),0<=this.vs&&(a=""+a+u((new v).K((new w).f([":",""])),(new w).f([this.vs])),0<=this.Gt&&(a=""+a+u((new v).K((new w).f([":",""])),(new w).f([this.Gt])))),a+=")");return a}; RT.prototype.r=function(){var a=this.xo,a=Ha(Ia(),a),b=this.xs;return a^Ha(Ia(),b)};RT.prototype.setColumnNumber=function(a){this.Gt=a|0};RT.prototype.getColumnNumber=function(){return this.Gt};var Pna=g({LU:0},!1,"java.lang.StackTraceElement",{LU:1,d:1,i:1});RT.prototype.$classData=Pna;function VA(){this.va=null}VA.prototype=new l;VA.prototype.constructor=VA;VA.prototype.om=function(){};VA.prototype.$classData=g({Vba:0},!1,"java.lang.Thread",{Vba:1,d:1,KU:1}); function ST(){this.Rq=this.Me=this.Kc=null}ST.prototype=new l;ST.prototype.constructor=ST;function TT(){}TT.prototype=ST.prototype;ST.prototype.bu=function(){if(void 0===ba.Error.captureStackTrace){try{var a={}.undef()}catch(b){if(a=ko(Lg(),b),null!==a)if(aF(a))a=a.Go;else throw Kg(Lg(),a);else throw b;}this.stackdata=a}else ba.Error.captureStackTrace(this),this.stackdata=this;return this};ST.prototype.Fh=function(){return this.Kc}; ST.prototype.k=function(){var a=oa(this).kh(),b=this.Fh();return null===b?a:a+": "+b};function Cna(a,b){for(var d=0;d<b.l.length;){if(null===b.l[d])throw(new Oe).b();d=1+d|0}a.Rq=b.MS()} function ix(a){if(null===a.Rq){XE||(XE=(new UE).b());var b=XE,d=a.stackdata,e;if(d){if(0===(1&b.ya)&&0===(1&b.ya)){a:try{ba.Packages.org.mozilla.javascript.JavaScriptException,e=!0}catch(U){e=ko(Lg(),U);if(null!==e){if(aF(e)){e=!1;break a}throw Kg(Lg(),e);}throw U;}b.vU=e;b.ya=(1|b.ya)<<24>>24}if(b.vU)e=d.stack,e=(void 0===e?"":e).replace(WE("^\\s+at\\s+","gm"),"").replace(WE("^(.+?)(?: \\((.+)\\))?$","gm"),"$2@$1").replace(WE("\\r\\n?","gm"),"\n").split("\n");else if(d.arguments&&d.stack)e=Xka(d); else if(d.stack&&d.sourceURL)e=d.stack.replace(WE("\\[native code\\]\\n","m"),"").replace(WE("^(?\x3d\\w+Error\\:).*$\\n","m"),"").replace(WE("^@","gm"),"{anonymous}()@").split("\n");else if(d.stack&&d.number)e=d.stack.replace(WE("^\\s*at\\s+(.*)$","gm"),"$1").replace(WE("^Anonymous function\\s+","gm"),"{anonymous}() ").replace(WE("^([^\\(]+|\\{anonymous\\}\\(\\))\\s+\\((.+)\\)$","gm"),"$1@$2").split("\n").slice(1);else if(d.stack&&d.fileName)e=d.stack.replace(WE("(?:\\n@:0)?\\s+$","m"),"").replace(WE("^(?:\\((\\S*)\\))?@", "gm"),"{anonymous}($1)@").split("\n");else if(d.message&&d["opera#sourceloc"])if(d.stacktrace)if(-1<d.message.indexOf("\n")&&d.message.split("\n").length>d.stacktrace.split("\n").length)e=bla(d);else{e=WE("Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$","i");for(var d=d.stacktrace.split("\n"),f=[],h=0,k=d.length|0;h<k;){var p=e.exec(d[h]);if(null!==p){var t=p[3],t=void 0===t?"{anonymous}":t,x=p[2];if(void 0===x)throw(new Xu).c("undefined.get");p=p[1];if(void 0===p)throw(new Xu).c("undefined.get"); f.push(t+"()@"+x+":"+p)}h=2+h|0}e=f}else e=bla(d);else if(d.message&&d.stack&&d.stacktrace){if(0>d.stacktrace.indexOf("called from line"))for(e=VE("^(.*)@(.+):(\\d+)$"),d=d.stacktrace.split("\n"),f=[],h=0,k=d.length|0;h<k;){p=e.exec(d[h]);if(null!==p){t=p[1];t=void 0===t?"global code":t+"()";x=p[2];if(void 0===x)throw(new Xu).c("undefined.get");p=p[3];if(void 0===p)throw(new Xu).c("undefined.get");f.push(t+"@"+x+":"+p)}h=1+h|0}else for(e=VE("^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$"), d=d.stacktrace.split("\n"),f=[],h=0,k=d.length|0;h<k;){p=e.exec(d[h]);if(null!==p){t=p[4];if(void 0===t)throw(new Xu).c("undefined.get");x=p[1];if(void 0===x)throw(new Xu).c("undefined.get");var E=p[2];if(void 0===E)throw(new Xu).c("undefined.get");t=t+":"+x+":"+E;p=p[2];p=(void 0===p?"global code":p).replace(VE("\x3canonymous function: (\\S+)\x3e"),"$1").replace(VE("\x3canonymous function\x3e"),"{anonymous}");f.push(p+"@"+t)|0}h=2+h|0}e=f}else e=d.stack&&!d.fileName?Xka(d):[]}else e=[];f=e;h=VE("^([^\\@]*)\\@(.*):([0-9]+)$"); k=VE("^([^\\@]*)\\@(.*):([0-9]+):([0-9]+)$");d=[];for(e=0;e<(f.length|0);){p=f[e];if(null===p)throw(new Oe).b();if(""!==p)if(t=k.exec(p),null!==t){p=t[1];if(void 0===p)throw(new Xu).c("undefined.get");x=ala(b,p);if(null===x)throw(new q).j(x);p=x.la();x=x.pa();E=t[2];if(void 0===E)throw(new Xu).c("undefined.get");var S=t[3];if(void 0===S)throw(new Xu).c("undefined.get");S=(new Sb).c(S);S=Ji(Hi(),S.R,10);t=t[4];if(void 0===t)throw(new Xu).c("undefined.get");t=(new Sb).c(t);t=Ji(Hi(),t.R,10);d.push({declaringClass:p, methodName:x,fileName:E,lineNumber:S,columnNumber:void 0===t?void 0:t})}else if(t=h.exec(p),null!==t){p=t[1];if(void 0===p)throw(new Xu).c("undefined.get");x=ala(b,p);if(null===x)throw(new q).j(x);p=x.la();x=x.pa();E=t[2];if(void 0===E)throw(new Xu).c("undefined.get");t=t[3];if(void 0===t)throw(new Xu).c("undefined.get");t=(new Sb).c(t);t=Ji(Hi(),t.R,10);d.push({declaringClass:p,methodName:x,fileName:E,lineNumber:t,columnNumber:void 0})}else d.push({declaringClass:"\x3cjscode\x3e",methodName:p,fileName:null, lineNumber:-1,columnNumber:void 0})|0;e=1+e|0}b=aa.sourceMapper;b=void 0===b?d:b(d);d=la(Xa(Pna),[b.length|0]);for(e=0;e<(b.length|0);)f=b[e],h=f.methodName,k=f.fileName,p=f.lineNumber|0,t=new RT,t.xo=f.declaringClass,t.xs=h,t.Zr=k,t.vs=p,t.Gt=-1,h=t,f=f.columnNumber,void 0!==f&&h.setColumnNumber(f|0),d.l[e]=h,e=1+e|0;a.Rq=d}return a.Rq} function UT(a){var b=SA().Eo,b=function(a,b){return function(a){BT(b,a);CT(b,"\n")}}(a,b);ix(a);var d=a.k();b(d);if(0!==a.Rq.l.length)for(d=0;d<a.Rq.l.length;)b("  at "+a.Rq.l[d]),d=1+d|0;else b("  \x3cno stack trace available\x3e");for(;;)if(a!==a.Me&&null!==a.Me){var e=ix(a);a=a.Me;var d=ix(a),f=d.l.length,h=e.l.length,k="Caused by: "+a.k();b(k);if(0!==f){for(k=0;;){if(k<f&&k<h)var p=d.l[-1+(f-k|0)|0],t=e.l[-1+(h-k|0)|0],p=null===p?null===t:p.o(t);else p=!1;if(p)k=1+k|0;else break}0<k&&(k=-1+k| 0);e=f-k|0;for(f=0;f<e;)b("  at "+d.l[f]),f=1+f|0;0<k&&b("  ... "+k+" more")}else b("  \x3cno stack trace available\x3e")}else break}ST.prototype.jc=function(a,b){this.Kc=a;this.Me=b;this.bu();return this};var Oq=g({ad:0},!1,"java.lang.Throwable",{ad:1,d:1,i:1});ST.prototype.$classData=Oq;function Gg(){this.rU=this.IV=null;this.XV=this.YV=0;this.bm=this.Uo=this.yq=null;this.$w=!1;this.xr=0}Gg.prototype=new l;Gg.prototype.constructor=Gg; function oi(a){if(a.$w){a.bm=a.yq.exec(a.Uo);if(null!==a.bm){var b=a.bm[0];if(void 0===b)throw(new Xu).c("undefined.get");if(null===b)throw(new Oe).b();""===b&&(b=a.yq,b.lastIndex=1+(b.lastIndex|0)|0)}else a.$w=!1;return null!==a.bm}return!1}function VT(a){if(null===a.bm)throw(new ye).c("No match available");return a.bm}function Qna(a,b){a=VT(a)[b];return void 0===a?null:a}c=Gg.prototype; c.Sq=function(a){if(0===a)return this.vl();var b=VT(this);a=b[a];return void 0===a?-1:this.Uo.indexOf(a,b.index|0)|0};function Pba(a){ro(a);oi(a);null===a.bm||0===a.vl()&&a.Wm()===(a.Uo.length|0)||ro(a);return null!==a.bm}function Rna(a){return-1+(VT(a).length|0)|0}function uo(a,b){WT(b,a.Uo.substring(a.xr));a.xr=a.Uo.length|0}c.Wm=function(){var a=this.vl(),b=pi(this);return a+(b.length|0)|0}; function Fg(a,b,d,e){a.IV=b;a.rU=d;a.YV=0;a.XV=e;b=a.IV;d=new ba.RegExp(b.mq);b=d!==b.mq?d:new ba.RegExp(b.mq.source,(b.mq.global?"g":"")+(b.mq.ignoreCase?"i":"")+(b.mq.multiline?"m":""));a.yq=b;a.Uo=na(Ma(a.rU,a.YV,a.XV));a.bm=null;a.$w=!0;a.xr=0;return a} function to(a,b,d){var e=a.Uo,f=a.xr,h=a.vl();WT(b,e.substring(f,h));e=d.length|0;for(f=0;f<e;)switch(h=65535&(d.charCodeAt(f)|0),h){case 36:for(h=f=1+f|0;;){if(f<e)var k=65535&(d.charCodeAt(f)|0),k=48<=k&&57>=k;else k=!1;if(k)f=1+f|0;else break}k=Hi();h=d.substring(h,f);h=Ji(k,h,10);WT(b,Qna(a,h));break;case 92:f=1+f|0;f<e&&Sna(b,65535&(d.charCodeAt(f)|0));f=1+f|0;break;default:Sna(b,h),f=1+f|0}a.xr=a.Wm()}function pi(a){a=VT(a)[0];if(void 0===a)throw(new Xu).c("undefined.get");return a} c.vl=function(){return VT(this).index|0};c.Wt=function(a){var b=this.Sq(a);if(-1===b)return-1;a=Qna(this,a);return b+(a.length|0)|0};function ro(a){a.yq.lastIndex=0;a.bm=null;a.$w=!0;a.xr=0}c.$classData=g({uca:0},!1,"java.util.regex.Matcher",{uca:1,d:1,ioa:1});function em(){}em.prototype=new l;em.prototype.constructor=em;em.prototype.Uh=function(){HF();Lk();return(new IF).b()};em.prototype.af=function(){HF();Lk();return(new IF).b()}; em.prototype.$classData=g({Aca:0},!1,"scala.LowPriorityImplicits$$anon$4",{Aca:1,d:1,Ps:1});function XT(){}XT.prototype=new l;XT.prototype.constructor=XT;XT.prototype.b=function(){return this};XT.prototype.Uh=function(){return(new Fm).b()};XT.prototype.af=function(){return(new Fm).b()};XT.prototype.$classData=g({Oca:0},!1,"scala.Predef$$anon$3",{Oca:1,d:1,Ps:1});function YT(){this.fr=null}YT.prototype=new l;YT.prototype.constructor=YT;c=YT.prototype; c.xv=function(a,b){return(new ZT).No(this.fr,a,b)};c.k=function(){var a=this.fr,b=(new Fm).b(),d;d=!0;js(b,"");for(var e=0,f=a.l.length;e<f;){var h=(new af).Ra(a.l[e]);d?(ks(b,h),d=!1):(js(b,""),ks(b,h));e=1+e|0}js(b,"");return b.vc.Zb};c.Yl=function(a){this.fr=a;return this};c.sa=function(){return this.fr.l.length};c.$classData=g({Pca:0},!1,"scala.Predef$ArrayCharSequence",{Pca:1,d:1,Fu:1}); function Tna(a,b){switch(b){case 0:return a.gb;case 1:return a.Fb;case 2:return a.og;case 3:return a.gr;default:throw(new P).c(""+b);}}function $T(){}$T.prototype=new l;$T.prototype.constructor=$T;$T.prototype.b=function(){return this};$T.prototype.$classData=g({ada:0},!1,"scala.concurrent.BlockContext$DefaultBlockContext$",{ada:1,d:1,mW:1});var Una=void 0;function IA(){this.Is=0}IA.prototype=new l;IA.prototype.constructor=IA; IA.prototype.o=function(a){KA();return a&&a.$classData&&a.$classData.n.rW?this.Is===a.Is:!1};IA.prototype.Db=function(a){this.Is=a;return this};IA.prototype.r=function(){return this.Is};IA.prototype.$classData=g({rW:0},!1,"scala.concurrent.duration.package$DurationInt",{rW:1,d:1,yoa:1});function aU(){}aU.prototype=new Kja;aU.prototype.constructor=aU;aU.prototype.ru=function(){return this};aU.prototype.$classData=g({vda:0},!1,"scala.io.Source$RelaxedPosition$",{vda:1,Aoa:1,d:1}); function bU(){fC.call(this)}bU.prototype=new Nja;bU.prototype.constructor=bU;bU.prototype.ru=function(a){fC.prototype.rba.call(this,a,Vna(a));return this};bU.prototype.$classData=g({wda:0},!1,"scala.io.Source$RelaxedPositioner$",{wda:1,Coa:1,d:1});function jC(){}jC.prototype=new l;jC.prototype.constructor=jC;jC.prototype.b=function(){return this};jC.prototype.k=function(){return"object AnyRef"};jC.prototype.$classData=g({Kda:0},!1,"scala.package$$anon$1",{Kda:1,d:1,woa:1}); function ZC(){this.LE=this.va=this.gy=this.rx=this.pl=null}ZC.prototype=new l;ZC.prototype.constructor=ZC;ZC.prototype.k=function(){return this.va+"("+this.LE+")"};function YC(a,b,d,e){a.pl=b;a.rx=d;a.gy=e;a.LE="";a.va="Catch";return a}function Wna(a,b){var d=new cU;if(null===a)throw Kg(Lg(),null);d.ga=a;d.ox=b;return YC(new ZC,d,a.rx,a.gy)}function Cma(){var a=jka();return Wna(a,m(new n,function(){return function(){return F()}}(a)))} ZC.prototype.$classData=g({pea:0},!1,"scala.util.control.Exception$Catch",{pea:1,d:1,Koa:1});function dU(){this.uy=this.ZU=this.dk=0}dU.prototype=new lka;dU.prototype.constructor=dU;dU.prototype.b=function(){eU=this;this.dk=Ha(Ia(),"Seq");this.ZU=Ha(Ia(),"Map");this.uy=Ha(Ia(),"Set");return this};function fU(a,b){if(gh(b)){for(var d=0,e=a.dk,f=b;!f.z();)b=f.$(),f=f.aa(),e=a.da(e,hD(V(),b)),d=1+d|0;a=a.tb(e,d)}else a=mka(a,b,a.dk);return a} dU.prototype.$classData=g({vea:0},!1,"scala.util.hashing.MurmurHash3$",{vea:1,Loa:1,d:1});var eU=void 0;function Q(){eU||(eU=(new dU).b());return eU}function gU(){this.Mu=this.uc=this.yT=this.iY=null;this.ya=this.Va=this.Xa=0}gU.prototype=new l;gU.prototype.constructor=gU;c=gU.prototype;c.Sq=function(a){return Xna(this).l[a]};c.k=function(){return 0<=this.vl()?na(Ma(this.wF(),this.vl(),this.Wm())):null};c.Wm=function(){return this.Va}; function Yna(a){if(0===(2&a.ya)&&0===(2&a.ya)){var b=Rna(a.Mu),d=0>b;if(d)var e=0;else var e=b>>31,f=1+b|0,e=0===f?1+e|0:e,e=(0===e?-1<(-2147483648^f):0<e)?-1:f;HF();Mk();HF();Lk();f=(new IF).b();0>e&&$n(ao(),0,b,1,!0);if(!d)for(d=0;;){e=a.Mu.Wt(d);KF(f,e);if(d===b)break;d=1+d|0}b=LF(f);d=b.sa();d=la(Xa(db),[d]);tD(b,d,0);a.yT=d;a.ya=(2|a.ya)<<24>>24}return a.yT}c.wF=function(){return this.uc};c.vl=function(){return this.Xa};c.Wt=function(a){return Yna(this).l[a]}; function Xna(a){if(0===(1&a.ya)&&0===(1&a.ya)){var b=Rna(a.Mu),d=0>b;if(d)var e=0;else var e=b>>31,f=1+b|0,e=0===f?1+e|0:e,e=(0===e?-1<(-2147483648^f):0<e)?-1:f;HF();Mk();HF();Lk();f=(new IF).b();0>e&&$n(ao(),0,b,1,!0);if(!d)for(d=0;;){e=a.Mu.Sq(d);KF(f,e);if(d===b)break;d=1+d|0}b=LF(f);d=b.sa();d=la(Xa(db),[d]);tD(b,d,0);a.iY=d;a.ya=(1|a.ya)<<24>>24}return a.iY}c.$classData=g({yea:0},!1,"scala.util.matching.Regex$Match",{yea:1,d:1,zea:1});function hU(){this.be=this.Bk=this.ga=null}hU.prototype=new oD; hU.prototype.constructor=hU;function Zna(){}Zna.prototype=hU.prototype;hU.prototype.en=function(a,b,d){this.Bk=b;this.be=d;nD.prototype.To.call(this,a);b=CP(a).Ac;b.z()?b=!1:(b=b.Y(),b.z()?b=!0:(d=b.Y(),b=hP(this.be),d=hP(d.be),b=!(b.sc<d.sc)));b&&(CP(a).Ac=(new J).j((new J).j(this)));return this};hU.prototype.JT=function(){return this};hU.prototype.aV=function(){return this};function iU(){this.ga=this.va=null}iU.prototype=new l;iU.prototype.constructor=iU;function jU(){}jU.prototype=iU.prototype; function $na(a,b){var d=(new Ne).b();return(new Ae).el(a.ga,m(new n,function(a,b,d){return function(k){return a.si(k).hC(K(function(a,b,d,e){return function(){return(e.La?e.hb:aoa(b,e)).si(d)}}(a,b,k,d)))}}(a,b,d)))}function kP(a,b){return Se(Ve(a,b),a.k()+"^^")}function boa(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,Ee(a))} function vP(a,b){var d=(new Ne).b();return Se(Ue(a,m(new n,function(a,b,d){return function(){return Ve(d.La?d.hb:coa(b,d),m(new n,function(){return function(a){return a}}(a)))}}(a,b,d))),"~\x3e")}c=iU.prototype;c.k=function(){return"Parser ("+this.va+")"};function Se(a,b){a.va=b;return a}function coa(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,Ee(a))} function uP(a,b){var d=(new Ne).b();return Se(Ue(a,m(new n,function(a,b,d){return function(k){return Ve(d.La?d.hb:boa(b,d),m(new n,function(a,b){return function(){return b}}(a,k)))}}(a,b,d))),"\x3c~")}c.er=function(a){var b=(new Ne).b();return Se(Ue(this,m(new n,function(a,b,f){return function(h){return Ve(f.La?f.hb:doa(b,f),m(new n,function(a,b){return function(d){return We(a.ga,b,d)}}(a,h)))}}(this,a,b))),"~")};c.Fa=function(a){return!!this.si(a)}; function nP(a,b){var d=a.ga;a=Se(Ue(a,m(new n,function(a,b){return function(d){return Ve(De(a.ga,b),m(new n,function(a,b){return function(d){return We(a.ga,b,d)}}(a,d)))}}(a,b))),"~!");return(new Xe).el(d,a)}function Ue(a,b){return(new Ae).el(a.ga,m(new n,function(a,b){return function(f){return a.si(f).JT(b)}}(a,b)))}function doa(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,Ee(a))} function Ve(a,b){return(new Ae).el(a.ga,m(new n,function(a,b){return function(f){return a.si(f).aV(b)}}(a,b)))}c.To=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;this.va="";return this};c.Ca=function(a){return qb(this,a)};function Re(a,b){return Se($na(a,b),"|")}function aoa(a,b){if(null===b)throw(new Oe).b();return b.La?b.hb:Pe(b,Ee(a))}function eoa(a,b){for(var d=!1;!d&&a.ta();)d=!!b.y(a.ma());return d}function kU(a){return(a.ta()?"non-empty":"empty")+" iterator"} function lU(a,b){for(var d=!0;d&&a.ta();)d=!!b.y(a.ma());return d}function mU(a,b){for(;a.ta();)b.y(a.ma())}function foa(a,b){for(;a.ta();){var d=a.ma();if(b.y(d))return(new J).j(d)}return F()}function As(a){if(a.ta()){var b=a.ma();return MD(new ND,b,K(function(a){return function(){return a.Ic()}}(a)))}Ng();return nU()}function oU(a,b,d,e){var f=d,h=uD(W(),b)-d|0;for(d=d+(e<h?e:h)|0;f<d&&a.ta();)BE(W(),b,f,a.ma()),f=1+f|0}function pU(a,b){for(var d=0;d<b&&a.ta();)a.ma(),d=1+d|0;return a} function Yb(){this.ga=this.ol=null}Yb.prototype=new l;Yb.prototype.constructor=Yb;Yb.prototype.wa=function(a){this.ga.wa(m(new n,function(a,d){return function(e){return a.ol.y(e)?d.y(e):void 0}}(this,a)))};Yb.prototype.xa=function(a,b){b=b.af(this.ga.Bd());this.ga.wa(m(new n,function(a,b,f){return function(h){return a.ol.y(h)?f.Na(b.y(h)):void 0}}(this,a,b)));return b.Da()};function Xb(a,b,d){a.ol=d;if(null===b)throw Kg(Lg(),null);a.ga=b;return a} Yb.prototype.$classData=g({cfa:0},!1,"scala.collection.TraversableLike$WithFilter",{cfa:1,d:1,lb:1});function qU(){}qU.prototype=new rka;qU.prototype.constructor=qU;function goa(){}goa.prototype=qU.prototype;function rU(){}rU.prototype=new HD;rU.prototype.constructor=rU;function hoa(){}hoa.prototype=rU.prototype;function sU(){this.ga=null}sU.prototype=new l;sU.prototype.constructor=sU;sU.prototype.Uh=function(){return this.ga.bb()}; sU.prototype.af=function(a){return a&&a.$classData&&a.$classData.n.lj?a.md().bb():this.ga.bb()};function cm(a){var b=new sU;if(null===a)throw Kg(Lg(),null);b.ga=a;return b}sU.prototype.$classData=g({efa:0},!1,"scala.collection.generic.GenSetFactory$$anon$1",{efa:1,d:1,Ps:1});function tU(){this.s=null}tU.prototype=new HD;tU.prototype.constructor=tU;function uU(){}uU.prototype=tU.prototype;tU.prototype.b=function(){this.s=(new vU).tu(this);return this};function wU(){this.ga=null}wU.prototype=new l; wU.prototype.constructor=wU;function xU(){}xU.prototype=wU.prototype;wU.prototype.Uh=function(){return this.ga.bb()};wU.prototype.af=function(a){return a.md().bb()};wU.prototype.tu=function(a){if(null===a)throw Kg(Lg(),null);this.ga=a;return this};function yU(){}yU.prototype=new qka;yU.prototype.constructor=yU;function ioa(){}ioa.prototype=yU.prototype;function zU(){this.oE=null}zU.prototype=new KD;zU.prototype.constructor=zU; function joa(a,b){a.oE=b;b=new AU;if(null===a)throw Kg(Lg(),null);b.Sa=a}zU.prototype.mC=function(a,b){return rb(this.oE,a,b)};zU.prototype.$classData=g({jfa:0},!1,"scala.collection.immutable.HashMap$$anon$2",{jfa:1,ofa:1,d:1});function AU(){this.Sa=null}AU.prototype=new KD;AU.prototype.constructor=AU;AU.prototype.mC=function(a,b){return rb(this.Sa.oE,b,a)};AU.prototype.$classData=g({kfa:0},!1,"scala.collection.immutable.HashMap$$anon$2$$anon$3",{kfa:1,ofa:1,d:1});function BU(){}BU.prototype=new l; BU.prototype.constructor=BU;c=BU.prototype;c.b=function(){return this};c.y=function(){return this};c.k=function(){return"\x3cfunction1\x3e"};c.Fa=function(){return!!this};c.Ca=function(a){return qb(this,a)};c.$classData=g({xfa:0},!1,"scala.collection.immutable.List$$anon$1",{xfa:1,d:1,fa:1});function CU(){this.Kc=this.ol=this.qx=null;this.ya=!1}CU.prototype=new l;CU.prototype.constructor=CU;CU.prototype.wa=function(a){(this.ya?this.qx:koa(this)).wa(a)}; function loa(a,b,d){a.ol=d;a.Kc=Ee(b);return a}CU.prototype.xa=function(a,b){return(this.ya?this.qx:koa(this)).xa(a,b)};function koa(a){if(!a.ya){var b=DU(a.Kc,a.ol,!1);a.Kc=null;a.qx=b;a.ya=!0}return a.qx}CU.prototype.$classData=g({ega:0},!1,"scala.collection.immutable.Stream$StreamWithFilter",{ega:1,d:1,lb:1});function moa(a,b){b=b.lf();switch(b){case -1:break;default:a.tc(b)}}function EU(a,b,d){b=b.lf();switch(b){case -1:break;default:a.tc(b+d|0)}} function FU(a,b,d){d=d.lf();switch(d){case -1:break;default:a.tc(b<d?b:d)}}var Pw=g({Iha:0},!1,"scala.scalajs.js.Dynamic",{Iha:1,Gha:1,moa:1},!0,void 0,function(){throw new ba.TypeError("Cannot call isInstance() on a Class representing a raw JS trait/object");}),Dha=g({Jha:0},!1,"scala.scalajs.js.Object",{Jha:1,d:1,Gha:1},!0,void 0,function(a){return a instanceof ba.Object});function Cx(){}Cx.prototype=new l;Cx.prototype.constructor=Cx;Cx.prototype.b=function(){return this};Cx.prototype.Uh=function(){return(new GU).b()}; Cx.prototype.af=function(){return(new GU).b()};Cx.prototype.$classData=g({Mha:0},!1,"scala.scalajs.js.WrappedDictionary$$anon$1",{Mha:1,d:1,Ps:1});function HU(){}HU.prototype=new l;HU.prototype.constructor=HU;function noa(){}noa.prototype=HU.prototype;HU.prototype.k=function(){return"\x3cfunction0\x3e"};function IU(){}IU.prototype=new l;IU.prototype.constructor=IU;function JU(){}JU.prototype=IU.prototype;IU.prototype.k=function(){return"\x3cfunction1\x3e"};IU.prototype.Fa=function(a){return!!this.y(a)}; IU.prototype.Ca=function(a){return qb(this,a)};function KU(){}KU.prototype=new l;KU.prototype.constructor=KU;function ooa(){}ooa.prototype=KU.prototype;KU.prototype.k=function(){return"\x3cfunction2\x3e"};function LU(){}LU.prototype=new l;LU.prototype.constructor=LU;function poa(){}poa.prototype=LU.prototype;LU.prototype.k=function(){return"\x3cfunction3\x3e"};function MU(){}MU.prototype=new l;MU.prototype.constructor=MU;function qoa(){}qoa.prototype=MU.prototype;MU.prototype.k=function(){return"\x3cfunction4\x3e"}; function ZT(){this.Vv=null;this.Va=this.Xa=0}ZT.prototype=new l;ZT.prototype.constructor=ZT;c=ZT.prototype;c.xv=function(a,b){if(0>a)throw(new NU).Db(a);if(b>this.sa())throw(new NU).Db(b);if(b<=a)return(new ZT).No(this.Vv,0,0);var d=this.Xa+a|0;return(new ZT).No(this.Vv,d,d+(b-a|0)|0)};c.k=function(){var a=this.Xa,a=0<a?a:0,b=this.Vv.l.length,d=a+this.sa()|0,b=b<d?b:d;return a>=b?"":RE(Ia(),this.Vv,a,b-a|0)};c.sa=function(){var a=this.Va-this.Xa|0;return 0>a?0:a}; c.No=function(a,b,d){this.Vv=a;this.Xa=b;this.Va=d;return this};c.$classData=g({aia:0},!1,"scala.runtime.ArrayCharSequence",{aia:1,d:1,Fu:1});function AD(){this.Ba=!1}AD.prototype=new l;AD.prototype.constructor=AD;AD.prototype.k=function(){return""+this.Ba};AD.prototype.td=function(a){this.Ba=a;return this};AD.prototype.$classData=g({bia:0},!1,"scala.runtime.BooleanRef",{bia:1,d:1,i:1});function rF(a){return!!(a&&a.$classData&&1===a.$classData.Br&&a.$classData.Ar.n.fY)} var Ba=g({fY:0},!1,"scala.runtime.BoxedUnit",{fY:1,d:1,i:1},void 0,void 0,function(a){return void 0===a});function Wb(){this.Ba=0}Wb.prototype=new l;Wb.prototype.constructor=Wb;Wb.prototype.tk=function(a){this.Ba=a;return this};Wb.prototype.k=function(){return""+this.Ba};Wb.prototype.$classData=g({dia:0},!1,"scala.runtime.DoubleRef",{dia:1,d:1,i:1});function jD(){this.Ba=0}jD.prototype=new l;jD.prototype.constructor=jD;jD.prototype.k=function(){return""+this.Ba}; jD.prototype.Db=function(a){this.Ba=a;return this};jD.prototype.$classData=g({eia:0},!1,"scala.runtime.IntRef",{eia:1,d:1,i:1});function Ub(){this.Ba=OA()}Ub.prototype=new l;Ub.prototype.constructor=Ub;Ub.prototype.mD=function(a){this.Ba=a;return this};Ub.prototype.k=function(){var a=this.Ba,b=a.ka,a=a.qa;return OU(Ra(),b,a)};Ub.prototype.$classData=g({iia:0},!1,"scala.runtime.LongRef",{iia:1,d:1,i:1});function nm(){this.Ba=null}nm.prototype=new l;nm.prototype.constructor=nm; nm.prototype.k=function(){return DB(Ia(),this.Ba)};nm.prototype.j=function(a){this.Ba=a;return this};nm.prototype.$classData=g({lia:0},!1,"scala.runtime.ObjectRef",{lia:1,d:1,i:1});function PU(){}PU.prototype=new l;PU.prototype.constructor=PU;function roa(){}roa.prototype=PU.prototype;PU.prototype.qo=function(){};function QU(){}QU.prototype=new l;QU.prototype.constructor=QU;function soa(){}soa.prototype=QU.prototype;QU.prototype.Ha=function(a){a.z()||a.Y();return this}; function RU(){this.xU=this.bC=this.fG=this.yU=this.tp=this.ZD=this.Ap=this.Km=this.Bj=null}RU.prototype=new l;RU.prototype.constructor=RU;function SU(a,b,d){return 0===d?toa(a,b):0===b.ka&&0===b.qa&&0<=d&&d<a.bC.l.length?a.bC.l[d]:(new NR).nD(b,d)} RU.prototype.b=function(){TU=this;this.Bj=(new NR).ia(0,0);this.Km=(new NR).ia(1,0);this.Ap=(new NR).ia(10,0);this.ZD=uoa(28,5);var a=this.ZD.l.length,b;b=[];for(var d=0;d<a;){var e=UU(0,this.ZD.l[d]);b.push(e);d=1+d|0}ka(Xa(db),b);this.tp=uoa(19,10);a=this.tp.l.length;b=[];for(d=0;d<a;)e=UU(0,this.tp.l[d]),b.push(e),d=1+d|0;this.yU=ka(Xa(db),b);a=[];for(b=0;11>b;)d=b,d=(new NR).ia(d,0),a.push(d),b=1+b|0;this.fG=ka(Xa(voa),a);a=[];for(b=0;11>b;)d=b,d=(new NR).ia(0,d),a.push(d),b=1+b|0;this.bC=ka(Xa(voa), a);a=[];for(b=0;100>b;)a.push(48),b=1+b|0;this.xU=ka(Xa(ab),a);return this}; function woa(a,b,d,e){var f;if(f=e<a.tp.l.length){f=b.Ae;var h=d.Ae+a.yU.l[e]|0;f=64>(1+(f>h?f:h)|0)}if(f){f=d.Kd;d=f.ka;f=f.qa;var h=a.tp.l[e],k=h.ka;e=65535&d;var p=d>>>16|0,t=65535&k,x=k>>>16|0,E=da(e,t),t=da(p,t),S=da(e,x);e=E+((t+S|0)<<16)|0;E=(E>>>16|0)+S|0;d=(((da(d,h.qa)+da(f,k)|0)+da(p,x)|0)+(E>>>16|0)|0)+(((65535&E)+t|0)>>>16|0)|0;h=b.Kd;f=h.ka;h=h.qa;e=f+e|0;return SU(a,(new Vb).ia(e,(-2147483648^e)<(-2147483648^f)?1+(h+d|0)|0:h+d|0),b.Hb)}a=Jf();f=VU(d);d=(new Vb).ia(e,e>>31);e=a.ZB.l.length; h=e>>31;k=d.qa;(k===h?(-2147483648^d.ka)<(-2147483648^e):k<h)?(d=a.ZB.l[d.ka],a=f.Ub,e=f.bc,f=f.xb,0===a?a=wf().Bj:1===e?(e=f.l[0],f=65535&e,e=e>>>16|0,k=65535&d,d=d>>>16|0,h=da(f,k),k=da(e,k),p=da(f,d),f=h+((k+p|0)<<16)|0,h=(h>>>16|0)+p|0,d=(da(e,d)+(h>>>16|0)|0)+(((65535&h)+k|0)>>>16|0)|0,a=0===d?(new rf).ia(a,f):qf(new rf,a,2,Qf(Rf(),f,(new w).f([d])))):(h=1+e|0,k=la(Xa(db),[h]),k.l[e]=hg(0,k,f,e,d),a=qf(new rf,a,h,k),uf(a))):a=fg(f,kg(a,d));d=VU(b);return(new NR).bq(Pf(Xf(),d,a),b.Hb)} function xoa(a,b,d,e){a=0>d?-d|0:d;var f=0===d?0:0>d?-1:1;if(cg().aC===e)return f;if(cg().hz===e)return 0;if(cg().gz===e)return 0<f?f:0;if(cg().kz===e)return 0>f?f:0;if(cg().mz===e)return 5<=a?f:0;if(cg().lz===e)return 5<a?f:0;if(cg().jw===e)return 5<(a+b|0)?f:0;if(cg().$B===e){if(0===d)return 0;throw(new WU).c("Rounding necessary");}throw(new q).j(e);} function XU(a,b){a=b.qa;(-1===a?0>(-2147483648^b.ka):-1>a)?a=!0:(a=b.qa,a=0===a?-1<(-2147483648^b.ka):0<a);if(a)throw(new WU).c("Out of int range: "+b);return b.ka}function toa(a,b){if(0<=b.qa)var d=b.qa,d=0===d?-2147483637>(-2147483648^b.ka):0>d;else d=!1;return d?a.fG.l[b.ka]:(new NR).nD(b,0)}function UU(a,b){b=0>b.qa?(new Vb).ia(~b.ka,~b.qa):b;a=b.ka;b=b.qa;return 64-(0!==b?fa(b):32+fa(a)|0)|0} function uoa(a,b){a=la(Xa(eb),[-1+a|0]);var d;d=[];var e,f=e=(new Vb).ia(1,0);d.push(null===f?null:f);for(var f=0,h=a.l.length;f<h;){var k=a.l[f],p=k.ka,t=k.qa,k=Qa(e);e=k.ka;k=k.qa;Qa((new Vb).ia(p,t));var p=b>>31,x=65535&e,t=e>>>16|0,E=65535&b,S=b>>>16|0,U=da(x,E),E=da(t,E),ga=da(x,S),x=U+((E+ga|0)<<16)|0,U=(U>>>16|0)+ga|0;e=(((da(e,p)+da(k,b)|0)+da(t,S)|0)+(U>>>16|0)|0)+(((65535&U)+E|0)>>>16|0)|0;k=e=(new Vb).ia(x,e);d.push(null===k?null:k);f=1+f|0}return ka(Xa(eb),d)} function yoa(a,b){var d=b.ka;return b.ka===d&&b.qa===d>>31?SU(a,OA(),b.ka):0<=b.qa?(new NR).ia(0,2147483647):(new NR).ia(0,-2147483648)}RU.prototype.$classData=g({VY:0},!1,"java.math.BigDecimal$",{VY:1,d:1,m:1,i:1});var TU=void 0;function YU(){TU||(TU=(new RU).b());return TU}function ZU(){this.YB=this.ZR=this.Bw=this.Bj=this.Ap=this.Km=null}ZU.prototype=new l;ZU.prototype.constructor=ZU; ZU.prototype.b=function(){$U=this;this.Km=(new rf).ia(1,1);this.Ap=(new rf).ia(1,10);this.Bj=(new rf).ia(0,0);this.Bw=(new rf).ia(-1,1);var a=(new w).f([this.Bj,this.Km,(new rf).ia(1,2),(new rf).ia(1,3),(new rf).ia(1,4),(new rf).ia(1,5),(new rf).ia(1,6),(new rf).ia(1,7),(new rf).ia(1,8),(new rf).ia(1,9),this.Ap]),b=a.oa.length|0,b=la(Xa(kf),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e;d=1+d|0}this.ZR=b;b=[];for(d=0;32>d;)a=d,a=Tf(wf(),(new Vb).ia(0===(32&a)?1<<a:0, 0===(32&a)?0:1<<a)),b.push(null===a?null:a),d=1+d|0;this.YB=ka(Xa(kf),b);return this};function zoa(a,b){if(b<a.YB.l.length)return a.YB.l[b];a=b>>5;b&=31;var d=la(Xa(db),[1+a|0]);d.l[a]=1<<b;return qf(new rf,1,1+a|0,d)}function Tf(a,b){if(0>b.qa)return-1!==b.ka||-1!==b.qa?(a=b.ka,b=b.qa,Aoa(new rf,-1,(new Vb).ia(-a|0,0!==a?~b:-b|0))):a.Bw;var d=b.qa;return(0===d?-2147483638>=(-2147483648^b.ka):0>d)?a.ZR.l[b.ka]:Aoa(new rf,1,b)} ZU.prototype.$classData=g({WY:0},!1,"java.math.BigInteger$",{WY:1,d:1,m:1,i:1});var $U=void 0;function wf(){$U||($U=(new ZU).b());return $U}function aV(){this.kr=this.$B=this.jw=this.lz=this.mz=this.kz=this.gz=this.hz=this.aC=null}aV.prototype=new l;aV.prototype.constructor=aV; aV.prototype.b=function(){bV=this;this.aC=(new cV).zd("UP",0);this.hz=(new cV).zd("DOWN",1);this.gz=(new cV).zd("CEILING",2);this.kz=(new cV).zd("FLOOR",3);this.mz=(new cV).zd("HALF_UP",4);this.lz=(new cV).zd("HALF_DOWN",5);this.jw=(new cV).zd("HALF_EVEN",6);this.$B=(new cV).zd("UNNECESSARY",7);var a=(new w).f([this.aC,this.hz,this.gz,this.kz,this.mz,this.lz,this.jw,this.$B]),b=a.oa.length|0,b=la(Xa(Boa),[b]),d;d=0;for(a=lf(new mf,a,0,a.oa.length|0);a.ta();){var e=a.ma();b.l[d]=e;d=1+d|0}this.kr= b;return this};aV.prototype.$classData=g({eZ:0},!1,"java.math.RoundingMode$",{eZ:1,d:1,m:1,i:1});var bV=void 0;function cg(){bV||(bV=(new aV).b());return bV}function dV(){SF.call(this)}dV.prototype=new fla;dV.prototype.constructor=dV;dV.prototype.b=function(){SF.prototype.cf.call(this,"/system/tokens-core.txt","org.nlogo.core.prim.");return this};dV.prototype.$classData=g({zZ:0},!1,"org.nlogo.core.DefaultTokenMapper$",{zZ:1,XH:1,d:1,v_:1});var Coa=void 0;function eV(){this.BG=null;this.a=!1} eV.prototype=new l;eV.prototype.constructor=eV;eV.prototype.b=function(){fV=this;this.BG=(new gV).os(I(pc().Th,y()));this.a=!0;return this};function Xda(a,b){return(new gV).os(I(pc().Th,y()).Rc(b,(Lk(),Mk().qc)))}function Doa(){var a=Qo();if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/LogoList.scala: 9");return a.BG}eV.prototype.$classData=g({MZ:0},!1,"org.nlogo.core.LogoList$",{MZ:1,d:1,m:1,i:1});var fV=void 0; function Qo(){fV||(fV=(new eV).b());return fV}function hV(){this.hT=this.jT=null;this.ya=0}hV.prototype=new l;hV.prototype.constructor=hV;hV.prototype.b=function(){return this};function Eoa(){var a=Foa();if(0===(2&a.ya)&&0===(2&a.ya)){var b=rj(),d=I(r(),(new w).f("default;0.0;-0.2 0 0.0 1.0;0.0 1 1.0 0.0;0.2 0 0.0 1.0;link direction;true;0;Line -7500403 true 150 150 90 180;Line -7500403 true 150 150 210 180".split(";"))).Oa();a.hT=pca(b,d.Ic()).ub();a.ya=(2|a.ya)<<24>>24}return a.hT} function Goa(){var a=Foa();if(0===(1&a.ya)&&0===(1&a.ya)){var b=rj(),d=I(r(),(new w).f("default;true;0;Polygon -7500403 true true 150 5 40 250 150 205 260 250;;airplane;true;0;Polygon -7500403 true true 150 0 135 15 120 60 120 105 15 165 15 195 120 180 135 240 105 270 120 285 150 270 180 285 210 270 165 240 180 180 285 195 285 165 180 105 180 60 165 15;;arrow;true;0;Polygon -7500403 true true 150 0 0 150 105 150 105 293 195 293 195 150 300 150;;box;false;0;Polygon -7500403 true true 150 285 285 225 285 75 150 135;Polygon -7500403 true true 150 135 15 75 150 15 285 75;Polygon -7500403 true true 15 75 15 225 150 285 150 135;Line -16777216 false 150 285 150 135;Line -16777216 false 150 135 15 75;Line -16777216 false 150 135 285 75;;bug;true;0;Circle -7500403 true true 96 182 108;Circle -7500403 true true 110 127 80;Circle -7500403 true true 110 75 80;Line -7500403 true 150 100 80 30;Line -7500403 true 150 100 220 30;;butterfly;true;0;Polygon -7500403 true true 150 165 209 199 225 225 225 255 195 270 165 255 150 240;Polygon -7500403 true true 150 165 89 198 75 225 75 255 105 270 135 255 150 240;Polygon -7500403 true true 139 148 100 105 55 90 25 90 10 105 10 135 25 180 40 195 85 194 139 163;Polygon -7500403 true true 162 150 200 105 245 90 275 90 290 105 290 135 275 180 260 195 215 195 162 165;Polygon -16777216 true false 150 255 135 225 120 150 135 120 150 105 165 120 180 150 165 225;Circle -16777216 true false 135 90 30;Line -16777216 false 150 105 195 60;Line -16777216 false 150 105 105 60;;car;false;0;Polygon -7500403 true true 300 180 279 164 261 144 240 135 226 132 213 106 203 84 185 63 159 50 135 50 75 60 0 150 0 165 0 225 300 225 300 180;Circle -16777216 true false 180 180 90;Circle -16777216 true false 30 180 90;Polygon -16777216 true false 162 80 132 78 134 135 209 135 194 105 189 96 180 89;Circle -7500403 true true 47 195 58;Circle -7500403 true true 195 195 58;;circle;false;0;Circle -7500403 true true 0 0 300;;circle 2;false;0;Circle -7500403 true true 0 0 300;Circle -16777216 true false 30 30 240;;cow;false;0;Polygon -7500403 true true 200 193 197 249 179 249 177 196 166 187 140 189 93 191 78 179 72 211 49 209 48 181 37 149 25 120 25 89 45 72 103 84 179 75 198 76 252 64 272 81 293 103 285 121 255 121 242 118 224 167;Polygon -7500403 true true 73 210 86 251 62 249 48 208;Polygon -7500403 true true 25 114 16 195 9 204 23 213 25 200 39 123;;cylinder;false;0;Circle -7500403 true true 0 0 300;;dot;false;0;Circle -7500403 true true 90 90 120;;face happy;false;0;Circle -7500403 true true 8 8 285;Circle -16777216 true false 60 75 60;Circle -16777216 true false 180 75 60;Polygon -16777216 true false 150 255 90 239 62 213 47 191 67 179 90 203 109 218 150 225 192 218 210 203 227 181 251 194 236 217 212 240;;face neutral;false;0;Circle -7500403 true true 8 7 285;Circle -16777216 true false 60 75 60;Circle -16777216 true false 180 75 60;Rectangle -16777216 true false 60 195 240 225;;face sad;false;0;Circle -7500403 true true 8 8 285;Circle -16777216 true false 60 75 60;Circle -16777216 true false 180 75 60;Polygon -16777216 true false 150 168 90 184 62 210 47 232 67 244 90 220 109 205 150 198 192 205 210 220 227 242 251 229 236 206 212 183;;fish;false;0;Polygon -1 true false 44 131 21 87 15 86 0 120 15 150 0 180 13 214 20 212 45 166;Polygon -1 true false 135 195 119 235 95 218 76 210 46 204 60 165;Polygon -1 true false 75 45 83 77 71 103 86 114 166 78 135 60;Polygon -7500403 true true 30 136 151 77 226 81 280 119 292 146 292 160 287 170 270 195 195 210 151 212 30 166;Circle -16777216 true false 215 106 30;;flag;false;0;Rectangle -7500403 true true 60 15 75 300;Polygon -7500403 true true 90 150 270 90 90 30;Line -7500403 true 75 135 90 135;Line -7500403 true 75 45 90 45;;flower;false;0;Polygon -10899396 true false 135 120 165 165 180 210 180 240 150 300 165 300 195 240 195 195 165 135;Circle -7500403 true true 85 132 38;Circle -7500403 true true 130 147 38;Circle -7500403 true true 192 85 38;Circle -7500403 true true 85 40 38;Circle -7500403 true true 177 40 38;Circle -7500403 true true 177 132 38;Circle -7500403 true true 70 85 38;Circle -7500403 true true 130 25 38;Circle -7500403 true true 96 51 108;Circle -16777216 true false 113 68 74;Polygon -10899396 true false 189 233 219 188 249 173 279 188 234 218;Polygon -10899396 true false 180 255 150 210 105 210 75 240 135 240;;house;false;0;Rectangle -7500403 true true 45 120 255 285;Rectangle -16777216 true false 120 210 180 285;Polygon -7500403 true true 15 120 150 15 285 120;Line -16777216 false 30 120 270 120;;leaf;false;0;Polygon -7500403 true true 150 210 135 195 120 210 60 210 30 195 60 180 60 165 15 135 30 120 15 105 40 104 45 90 60 90 90 105 105 120 120 120 105 60 120 60 135 30 150 15 165 30 180 60 195 60 180 120 195 120 210 105 240 90 255 90 263 104 285 105 270 120 285 135 240 165 240 180 270 195 240 210 180 210 165 195;Polygon -7500403 true true 135 195 135 240 120 255 105 255 105 285 135 285 165 240 165 195;;line;true;0;Line -7500403 true 150 0 150 300;;line half;true;0;Line -7500403 true 150 0 150 150;;pentagon;false;0;Polygon -7500403 true true 150 15 15 120 60 285 240 285 285 120;;person;false;0;Circle -7500403 true true 110 5 80;Polygon -7500403 true true 105 90 120 195 90 285 105 300 135 300 150 225 165 300 195 300 210 285 180 195 195 90;Rectangle -7500403 true true 127 79 172 94;Polygon -7500403 true true 195 90 240 150 225 180 165 105;Polygon -7500403 true true 105 90 60 150 75 180 135 105;;plant;false;0;Rectangle -7500403 true true 135 90 165 300;Polygon -7500403 true true 135 255 90 210 45 195 75 255 135 285;Polygon -7500403 true true 165 255 210 210 255 195 225 255 165 285;Polygon -7500403 true true 135 180 90 135 45 120 75 180 135 210;Polygon -7500403 true true 165 180 165 210 225 180 255 120 210 135;Polygon -7500403 true true 135 105 90 60 45 45 75 105 135 135;Polygon -7500403 true true 165 105 165 135 225 105 255 45 210 60;Polygon -7500403 true true 135 90 120 45 150 15 180 45 165 90;;sheep;false;15;Circle -1 true true 203 65 88;Circle -1 true true 70 65 162;Circle -1 true true 150 105 120;Polygon -7500403 true false 218 120 240 165 255 165 278 120;Circle -7500403 true false 214 72 67;Rectangle -1 true true 164 223 179 298;Polygon -1 true true 45 285 30 285 30 240 15 195 45 210;Circle -1 true true 3 83 150;Rectangle -1 true true 65 221 80 296;Polygon -1 true true 195 285 210 285 210 240 240 210 195 210;Polygon -7500403 true false 276 85 285 105 302 99 294 83;Polygon -7500403 true false 219 85 210 105 193 99 201 83;;square;false;0;Rectangle -7500403 true true 30 30 270 270;;square 2;false;0;Rectangle -7500403 true true 30 30 270 270;Rectangle -16777216 true false 60 60 240 240;;star;false;0;Polygon -7500403 true true 151 1 185 108 298 108 207 175 242 282 151 216 59 282 94 175 3 108 116 108;;target;false;0;Circle -7500403 true true 0 0 300;Circle -16777216 true false 30 30 240;Circle -7500403 true true 60 60 180;Circle -16777216 true false 90 90 120;Circle -7500403 true true 120 120 60;;tree;false;0;Circle -7500403 true true 118 3 94;Rectangle -6459832 true false 120 195 180 300;Circle -7500403 true true 65 21 108;Circle -7500403 true true 116 41 127;Circle -7500403 true true 45 90 120;Circle -7500403 true true 104 74 152;;triangle;false;0;Polygon -7500403 true true 150 30 15 255 285 255;;triangle 2;false;0;Polygon -7500403 true true 150 30 15 255 285 255;Polygon -16777216 true false 151 99 225 223 75 224;;truck;false;0;Rectangle -7500403 true true 4 45 195 187;Polygon -7500403 true true 296 193 296 150 259 134 244 104 208 104 207 194;Rectangle -1 true false 195 60 195 105;Polygon -16777216 true false 238 112 252 141 219 141 218 112;Circle -16777216 true false 234 174 42;Rectangle -7500403 true true 181 185 214 194;Circle -16777216 true false 144 174 42;Circle -16777216 true false 24 174 42;Circle -7500403 false true 24 174 42;Circle -7500403 false true 144 174 42;Circle -7500403 false true 234 174 42;;turtle;true;0;Polygon -10899396 true false 215 204 240 233 246 254 228 266 215 252 193 210;Polygon -10899396 true false 195 90 225 75 245 75 260 89 269 108 261 124 240 105 225 105 210 105;Polygon -10899396 true false 105 90 75 75 55 75 40 89 31 108 39 124 60 105 75 105 90 105;Polygon -10899396 true false 132 85 134 64 107 51 108 17 150 2 192 18 192 52 169 65 172 87;Polygon -10899396 true false 85 204 60 233 54 254 72 266 85 252 107 210;Polygon -7500403 true true 119 75 179 75 209 101 224 135 220 225 175 261 128 261 81 224 74 135 88 99;;wheel;false;0;Circle -7500403 true true 3 3 294;Circle -16777216 true false 30 30 240;Line -7500403 true 150 285 150 15;Line -7500403 true 15 150 285 150;Circle -7500403 true true 120 120 60;Line -7500403 true 216 40 79 269;Line -7500403 true 40 84 269 221;Line -7500403 true 40 216 269 79;Line -7500403 true 84 40 221 269;;wolf;false;0;Polygon -16777216 true false 253 133 245 131 245 133;Polygon -7500403 true true 2 194 13 197 30 191 38 193 38 205 20 226 20 257 27 265 38 266 40 260 31 253 31 230 60 206 68 198 75 209 66 228 65 243 82 261 84 268 100 267 103 261 77 239 79 231 100 207 98 196 119 201 143 202 160 195 166 210 172 213 173 238 167 251 160 248 154 265 169 264 178 247 186 240 198 260 200 271 217 271 219 262 207 258 195 230 192 198 210 184 227 164 242 144 259 145 284 151 277 141 293 140 299 134 297 127 273 119 270 105;Polygon -7500403 true true -1 195 14 180 36 166 40 153 53 140 82 131 134 133 159 126 188 115 227 108 236 102 238 98 268 86 269 92 281 87 269 103 269 113;;x;false;0;Polygon -7500403 true true 270 75 225 30 30 225 75 270;Polygon -7500403 true true 30 75 75 30 270 225 225 270".split(";"))).Oa(); a.jT=rca(b,d.Ic()).ub();a.ya=(1|a.ya)<<24>>24}return a.jT}hV.prototype.$classData=g({NZ:0},!1,"org.nlogo.core.Model$",{NZ:1,d:1,m:1,i:1});var Hoa=void 0;function Foa(){Hoa||(Hoa=(new hV).b());return Hoa}function iV(){}iV.prototype=new l;iV.prototype.constructor=iV;iV.prototype.b=function(){return this};iV.prototype.$classData=g({WZ:0},!1,"org.nlogo.core.NumericInput$",{WZ:1,d:1,m:1,i:1});var Ioa=void 0;function jV(){this.fe=this.ji=null;this.bz=0;this.ra=null;this.a=!1}jV.prototype=new l; jV.prototype.constructor=jV;jV.prototype.Lc=function(){if(!this.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/AstNode.scala: 65");return this.ra};function Mb(a,b,d){var e=new jV;e.ji=a;e.fe=b;e.bz=d;b=UO(a).ra.Xa;a=UO(a);e.ra=Lm(new Mm,b,d,a.ra.ab);e.a=!0;return e}jV.prototype.$classData=g({uH:0},!1,"org.nlogo.core.ProcedureDefinition",{uH:1,d:1,up:1,co:1});function kV(){}kV.prototype=new l;kV.prototype.constructor=kV;kV.prototype.b=function(){return this}; function ws(){var a=qQ(),b=CF(pQ(a)),d=DF(pQ(a)),e=EF(pQ(a)),f=I(r(),y()),h=I(r(),y()),k=nh(oh(),y()),p=nh(oh(),y());return Cp(f,h,b,d,e,k,p,a)}kV.prototype.$classData=g({c_:0},!1,"org.nlogo.core.Program$",{c_:1,d:1,m:1,i:1});var Joa=void 0;function vs(){Joa||(Joa=(new kV).b());return Joa}function lV(){this.uG=null;this.a=!1}lV.prototype=new l;lV.prototype.constructor=lV;lV.prototype.b=function(){this.uG="default";this.a=!0;return this}; function Koa(a){if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/ShapeList.scala: 10");return a.uG}function hga(a,b){a=m(new n,function(){return function(a){var b=a.me();return(new A).e(b,a)}}(a));var d=Lc();return b.xa(a,d.s).te($e().Fk)}lV.prototype.$classData=g({h_:0},!1,"org.nlogo.core.ShapeList$",{h_:1,d:1,m:1,i:1});var Loa=void 0;function Vt(){Loa||(Loa=(new lV).b());return Loa}function Fb(){this.Zf=this.Yr=null;this.oe=!1}Fb.prototype=new l; Fb.prototype.constructor=Fb;c=Fb.prototype;c.ns=function(a,b,d){this.Yr=a;this.Zf=b;this.oe=d;return this};c.Ro=function(a,b){Fb.prototype.ns.call(this,a,b,!1);return this};c.Lc=function(){if(this.Zf.z())return Lm(new Mm,0,0,this.Yr);var a=this.Zf.W(0).Lc().Xa,b=this.Zf.gd();return Lm(new Mm,a,b.Lc().Va,this.Yr)};c.k=function(){return this.Zf.zb(" ")};c.c=function(a){Fb.prototype.ns.call(this,a,I(r(),y()),!1);return this};c.$classData=g({Dz:0},!1,"org.nlogo.core.Statements",{Dz:1,d:1,up:1,co:1}); function mV(){}mV.prototype=new l;mV.prototype.constructor=mV;mV.prototype.b=function(){return this};mV.prototype.$classData=g({n_:0},!1,"org.nlogo.core.StringInput$",{n_:1,d:1,m:1,i:1});var Moa=void 0;function nV(){this.Rd=null;this.a=!1}nV.prototype=new l;nV.prototype.constructor=nV;nV.prototype.b=function(){Noa=this;vs();this.Rd=Gp(new Hp,ws(),(Kp(),ph()),(Kp(),nh($e().kk,y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())),(Kp(),I(r(),y())));this.a=!0;return this}; nV.prototype.$classData=g({r_:0},!1,"org.nlogo.core.StructureResults$",{r_:1,d:1,m:1,i:1});var Noa=void 0;function Kp(){Noa||(Noa=(new nV).b())}function oV(){this.a=this.JR=this.qG=this.eS=this.mG=this.NR=this.UR=this.kG=this.VR=this.OR=this.LR=this.iG=this.pG=this.TR=this.mS=this.SR=this.cG=this.WR=this.rG=this.SG=this.PR=this.hS=this.IR=this.dG=this.TG=this.QR=this.iS=this.UG=this.dS=this.jG=this.MR=this.kS=0}oV.prototype=new l;oV.prototype.constructor=oV; function Rj(a){if(0===(32&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 203");return a.iS} oV.prototype.b=function(){pV=this;this.kS=0;this.a|=1;this.MR=1;this.a|=2;this.jG=2;this.a|=4;this.dS=4;this.a|=8;this.UG=8;this.a|=16;this.iS=16;this.a|=32;this.QR=32;this.a|=64;this.TG=64;this.a|=128;this.dG=Rj(this)|Sj(this)|Tj(this);this.a|=256;this.IR=128;this.a|=512;this.hS=256;this.a|=1024;this.PR=512;this.a|=2048;this.SG=1024;this.a|=4096;this.rG=2048;this.a|=8192;this.WR=4096;this.a|=16384;this.cG=Uj(this)|Vj(this)|Wj(this);this.a|=32768;this.SR=N(this)|Nj(this)|Oj(this)|Pj(this)|Mj(this); this.a|=65536;this.mS=N(this)|Nj(this)|Oj(this)|Pj(this)|Lj(this)|Qj(this)|Mj(this)|Yj(this)|Xj(this);this.a|=131072;this.TR=8192;this.a|=262144;this.pG=16384;this.a|=524288;this.iG=32768;this.a|=1048576;this.LR=65536;this.a|=2097152;this.OR=131072;this.a|=4194304;this.VR=ck(this)|dk(this)|bk(this);this.a|=8388608;this.kG=Pj(this)|Zj(this)|ak(this);this.a|=16777216;this.UR=262144;this.a|=33554432;this.NR=524288;this.a|=67108864;this.mG=1048576;this.a|=134217728;this.eS=2097152;this.a|=268435456;this.qG= 0;this.a|=536870912;this.JR=10;this.a|=1073741824;return this};function Jj(){var a=D();if(0===(262144&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 270");return a.TR}function oc(a,b,d,e,f,h,k,p){var t=new H;if(0===(536870912&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 318");return G(t,a.qG,nc(),b,nc(),d,e,!1,f,h,k||h.ba(),p)} function uk(){var a=D();if(0===(134217728&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 311");return a.mG}function ck(a){if(0===(1048576&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 278");return a.iG} function Kj(){var a=D();if(0===(16777216&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 292");return a.kG}function Gn(a,b,d){return 0!==(b&d)}function C(){var a=D();if(0===(1073741824&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 319");return a.JR} function ak(a){if(0===(8388608&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 291");return a.VR}function Sj(a){if(0===(64&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 208");return a.QR}function Ij(){var a=D();if(0===(33554432&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 299");return a.UR} function Zr(){var a=D();if(0===(65536&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 261");return a.SR}function Lj(a){if(0===(32768&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 255");return a.cG}function xk(){var a=D();if(0===(268435456&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 316");return a.eS} function Pj(a){if(0===(16&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 198");return a.UG}function Wj(a){if(0===(4096&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 239");return a.SG}function yk(){var a=D();if(0===(67108864&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 306");return a.NR} function Uj(a){if(0===(1024&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 229");return a.hS}function Zj(a){if(0===(524288&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 274");return a.pG}function bk(a){if(0===(4194304&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 286");return a.OR} function N(a){if(0===(2&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 183");return a.MR}function Xj(a){if(0===(16384&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 249");return a.WR}function Oj(a){if(0===(8&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 193");return a.dS} function Mj(a){if(0===(512&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 224");return a.IR}function Nj(a){if(0===(4&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 188");return a.jG}function Tj(a){if(0===(128&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 213");return a.TG} function nc(){var a=D();if(0===(1&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 180");return a.kS}function Vj(a){if(0===(2048&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 234");return a.PR}function Qj(a){if(0===(256&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 219");return a.dG} function dk(a){if(0===(2097152&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 282");return a.LR}function lc(){var a=D();if(0===(131072&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 268");return a.mS}function Yj(a){if(0===(8192&a.a))throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Syntax.scala: 244");return a.rG} oV.prototype.$classData=g({t_:0},!1,"org.nlogo.core.Syntax$",{t_:1,d:1,m:1,i:1});var pV=void 0;function D(){pV||(pV=(new oV).b());return pV}function qV(){this.DG=null;this.a=!1}qV.prototype=new l;qV.prototype.constructor=qV;qV.prototype.b=function(){rV=this;this.DG=Jm(new Km,"",Dc(),"",Lm(new Mm,2147483647,2147483647,""));this.a=!0;return this}; function Nm(){var a;rV||(rV=(new qV).b());a=rV;if(!a.a)throw(new z).c("Uninitialized field: /Users/el_ergo/Github/NetLogo/parser-core/src/main/core/Token.scala: 15");return a.DG}qV.prototype.$classData=g({u_:0},!1,"org.nlogo.core.Token$",{u_:1,d:1,m:1,i:1});var rV=void 0;function sV(){}sV.prototype=new l;sV.prototype.constructor=sV;function Ooa(){}Ooa.prototype=sV.prototype;sV.prototype.Db=function(){return this};function bl(){}bl.prototype=new eO;bl.prototype.constructor=bl;c=bl.prototype;c.b=function(){return this}; c.Jl=function(a){B();a=(new w).f([void 0,a.Wa,a.fb,a.Pa,a.eb,a.Ya,a.uc,a.Ko,void 0,void 0,a.Pm,void 0,a.io,void 0,void 0,a.zo?0:1]);var b=B().s;return L(a,b)}; c.Kl=function(a){a:{B();var b=(new J).j(a);if(null!==b.U&&0===Ig(b.U,16)){var d=b.U.W(1),e=b.U.W(2),f=b.U.W(3),h=b.U.W(4),k=b.U.W(5),p=b.U.W(6),t=b.U.W(7),x=b.U.W(10),E=b.U.W(12),b=b.U.W(15);if(Pa(d)&&(d|=0,Pa(e)&&(e|=0,Pa(f)&&(f|=0,Pa(h)&&(h|=0,tV(k)&&tV(p)&&"boolean"===typeof t&&(t=!!t,x&&x.$classData&&x.$classData.n.nw&&tV(E)&&Pa(b)))))))break a}throw(new q).j(a);}return Poa(p,d|0,e|0,f|0,h|0,k,!!t,x,E,0===(b|0))};c.Pl=function(){return(new Qn).xg(pa(Qoa))}; c.Dh=function(){B();var a=(new uV).c("BUTTON"),b=(new vV).Ha(F()),d=(new vV).Ha(F()),e=(new vV).Ha(F()),f=(new vV).Ha(F()),h=wV(new xV,(new yV).Ha(F())),k=wV(new xV,(new zV).Ha(F())),p=(new AV).Ha(F()),t=(new BV).c("1"),x=(new BV).c("T");B();var E=uj(),E=(new A).e("OBSERVER",E),S=wj(),S=(new A).e("PATCH",S),U=vj(),U=(new A).e("TURTLE",U),ga=xj(),E=(new w).f([E,S,U,(new A).e("LINK",ga)]),S=B().s,a=(new w).f([a,b,d,e,f,h,k,p,t,x,(new CV).hq(L(E,S)),(new BV).c("NIL"),wV(new xV,(new DV).Ha(F())),(new BV).c("NIL"), (new BV).c("NIL"),(new vV).Ha(F())]),b=B().s;return L(a,b)};c.$classData=g({Q_:0},!1,"org.nlogo.core.model.ButtonReader$",{Q_:1,Fm:1,d:1,Gm:1});var al=void 0;function nl(){}nl.prototype=new eO;nl.prototype.constructor=nl;c=nl.prototype;c.b=function(){return this};function Roa(a,b){if(Ph()===b)return"nobody";if(Zg(b)){Qo();var d=Mk().qc,d=Mc(b,d);for(b=Ok(b.Ac);b.qi;){var e=b.ma();d.Na(Roa(a,e))}return Xda(0,d.Da())}return b} function Soa(a,b){B();var d=b.Wa,e=b.fb,f=b.Pa,h=b.eb,k=b.Ya,p=b.kd,t=b.po;a=function(){return function(a){var b=Eo();a=a.Cl();return $b(b,a,!0,!1)}}(a);var x=B().s;if(x===B().s)if(t===y())a=y();else{for(var x=t.$(),E=x=Cd(new Dd,a(x),y()),t=t.aa();t!==y();)var S=t.$(),S=Cd(new Dd,a(S),y()),E=E.Ia=S,t=t.aa();a=x}else{for(x=Mc(t,x);!t.z();)E=t.$(),x.Na(a(E)),t=t.aa();a=x.Da()}b=(new w).f([void 0,d,e,f,h,k,p,a.zb(" "),b.vo]);d=B().s;return L(b,d)}c.Jl=function(a){return Soa(this,a)};
c.Kl=function(a){return Toa(this,a)};

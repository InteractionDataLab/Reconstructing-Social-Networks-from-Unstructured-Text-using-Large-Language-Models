Team:NAWI Graz/FlourescenceChamber
Description Design Demonstrate Model Application Results InterLab Measurement Study
Components
Parts Arena Bioreactor Robot Control System Temperature Interaction Module Temperature Plasmid pH Interaction Module pH Plasmid Flourescence Measurement Chamber
Team
NAWI_Graz 2017 Collaborations Attributions
Lab Book
Notebook Working Protocols
Human Practices
Public Engagement Integrated Human Practices Discussions Education Interviews
Safety
Judging Form
Go to Top
FLOURESCENCE MEASUREMENT CHAMBER
A 3D printed case housing a cuvette (with in- and outflow tubes), LEDs to excite the fluorescent proteins, optical filters and two camera-modules. We look into the raw RGB data in a region of interest to detect bacterial fluorescence. The information from both cameras is aggregated into a single output: the next command to the robot.
Fig. 1: Overview of all parts constituting the fluorescence measurement chamber. See detailed description of all parts below.
Casing
The chamber is a two-part 3D-printed enclosure (see Fig. 2) with two facing walls housing sockets for LEDs that are all directed towards the center of the chamber. The outer two LED sockets of each row of three are oriented diagonally, their convergence in the interior can be seen in the bottom part of Fig. 2. The other two facing walls each contain one socket for a camera. If the two parts are plugged together, a rectangular tunnel passes through the chamber, leaving just enough space for the UV-cuvette and the placement of optical filters on each side.
Fig. 2: The two parts of the casing are shown from two different perspectives.
LEDs and Optical Filters
Because of the expressed fluorescent proteins’ spectral characteristics we chose unmounted 5 mm LEDs emitting light of two different wavelengths, 490 and 600 nm respectively, three of each. Between camera and cuvette, we placed optical filters to exclude the exciting frequencies from influencing the quality of the fluorescence detection. The filters we used were 101 YELLOW (LEE Filters, see Fig. 3) for the protein excited at 490 nm (mNeonGreen), and 795 MAGICAL MAGENTA (LEE Filters, see Fig. 4) for the one with peak excition at 604 nm (mCardinal).
Fig. 3: Characteristics of the filter 101 YELLOW (LEE Filters).
Fig. 4: Characteristics of the filter 795 MAGICAL MAGENTA (LEE Filters).
UV-Cuvette Compartment
A UV-permissible quartz cuvette modified such as to connect to tubes on both ends to allow for the controlled transition and residence of bacterial suspension. Even though all wavelengths we used in all our experiments were in the visible spectrum, we chose this type of cuvette to enable the system to be used in a more general context.
Cameras
Two cameras ( Raspberry Pi Camera Module v2 ) are attached to their appropriate slots in the casing of the fluorescence measurement chamber, each one dedicated to measuring the fluorescence of a specific protein. The master camera is connected directly to the control system RPi , while the second slave camera is controlled by a separate RPi, but connected to the control system RPi via two GPIO connections.
To interface the cameras, we use the Python picamera library (v 1.13) . Each camera is calibrated and set separately to maximize the difference between idle and activated state (i.e., basic and enhanced expression of fluorescent proteins). The raw RGB-data is recorded, the best channel is kept (e.g. the green channel when recording the fluorescence of mNeonGreen, the red channel when measuring mCardinal) and cropped to our region of interest—the bacterial suspension. The median intensity of this region is then compared to a threshold to decipher the bacterial command to the robot.
Function
After having passed an interaction module , bacterial suspension is transferred into the UV-cuvette in the interior of the chamber. The control system first excites the sample with one type of LED, records the fluorescence in the according camera, then switches to the other set of LEDs and the second camera (to avoid cross-polluting the readings). After the measurements are taken, the bacterial suspension is discarded.
Fig. 5: A view of the assembled fluorescence measurement chamber with LEDs emitting blue light. The white ribbon cable at the bottom of the module indicates the connection to the second camera.
Software
The code for the cameras is written as a module that can be imported and employed by the control system . Additionally, a debug mode was implemented that allows to export the camera recordings as images and elaborate logfiles. The control system only needs to start both scripts (the script for the master camera on the control system RPi itself and the slave camera on a different RPi). To measure, the control system only needs to invoke the dedicated method of the master camera object, which handles the control of and communication with the slave camera. Both scripts are shown below.
Camera Master:
1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387
#!/usr/bin/env python """ Code for the master-camera. It is connected to the slave-camera via 2 GPIO pins and outputs the total detected bacterial state (aggregated from both cameras). @author: Daniel Hofstadler, 2017 """ import os import csv import time import argparse import gpiozero from datetime import datetime from fractions import Fraction import numpy as np import picamera import picamera.array from matplotlib import pyplot as plt # import warnings # warnings.filterwarnings('error', category=DeprecationWarning) # globals # LOCAL_TZ = pytz.timezone("Etc/UTC")  # read from cams.csv OUT_APPEND = "_coli" CSV_NAME = "colicam" CSV_HEADER = ["framerate", "exposure_time_us", "iso", "g1", "g2", "g3", "g4", "timestamp", "time_utc", "tag", "red", "green", "blue"] # RESOLUTION = (2592, 1944) RESOLUTION = (1280, 720) # REGION_OF_INTEREST = (0.35, 0.4, 0.5, 0.7) ROI = [200, 520, 480, 800] # Y0, Y1, X0, X1 DETECTION_THRESHOLD = 150 PIN_RX = 17 PIN_TX = 18 SETTINGS_FIXED = { 'name': "fixed", 'ss': 1000000, # 1000 milliseconds = 1 sec 'fps': Fraction(1, 2), # (1, 2) 'iso': 800, # 800 'g': (Fraction(2, 1), Fraction(1, 1)), # 'g': (Fraction(345, 256), Fraction(167, 128)), 'sleep': 15} # 10 SETTINGS_SENSITIVE = { 'name': "sensitive", 'ss': 6000000, # 6 seconds 'fps': Fraction(1, 6), 'iso': 800, 'g': None, 'sleep': 30} SETTINGS_AUTO = { 'name': "auto", 'ss': None, 'fps': 30, 'iso': 0, 'g': None, 'sleep': 2} SETTINGS_DEFAULT = "fixed" # argument parsing parser = argparse.ArgumentParser( description="Colibot Photometer Camera.") parser.add_argument("-d", "--debug", action="store_true", help="debug mode") parser.add_argument("-m", "--mode", type=str, default="fixed", choices=["f", "fixed", "s", "sensitive", "a", "auto"], help="set the camera mode") parser.add_argument("-p", "--postfix", type=str, default="", help="add string to filename") # args = vars(ap.parse_args()) args = parser.parse_args() if not args.postfix == "" and not args.postfix.startswith("_"): args.postfix = "_" + args.postfix def now_str(pattern="_%y%m%d-%H%M%S_utc"): # return time.strftime(pattern, time.gmtime()) return datetime.utcnow().strftime(pattern) def from_timestamp(ts, pattern="%y%m%d-%H%M%S_utc"): return datetime.utcfromtimestamp(ts).strftime(pattern) def safename(s, s_type): """Check whether a given file or folder 's' exists, return a non-existing filename. s ........ (full) filename or directory s_type ... 'file' or 'f' for files, 'directory' or 'dir' or 'd' for folders Returns a file- or pathname that is supposedly safe to save without overwriting data. """ low_type = str.lower(s_type) if low_type == 'file' or low_type == 'f': if os.path.isfile(s): s2 = s.split('.') s_base = s2[0] s_ext = s2[-1] counter = 0 while os.path.isfile(s): s = s_base + "-{:02d}.".format(counter) + s_ext counter += 1 elif low_type == 'directory' or low_type == 'dir' or low_type == 'd': if os.path.isdir(s): s_base = s counter = 0 while os.path.isdir(s): s = s_base + "-{:02d}".format(counter) counter += 1 return s class ColiCamMaster: global RESOLUTION global ROI # REGION_OF_INTEREST global DETECTION_THRESHOLD global SETTINGS_FIXED global SETTINGS_SENSITIVE global SETTINGS_AUTO global DEF_SETTINGS_NAME global PIN_RX global PIN_TX def __init__(self, resolution=RESOLUTION, mode=DEF_SETTINGS_NAME): try: self.cam = picamera.PiCamera(resolution=resolution) self.set_cam(mode) except Exception as err: self.cam = "" print("couldn't initialize camera, error: {}".format(err)) self.rx = gpiozero.InputDevice(PIN_RX) self.tx = gpiozero.OutputDevice(PIN_TX) def set_cam(self, mode="fixed"): if mode.lower().startswith("f"): settings = SETTINGS_FIXED elif mode.lower().startswith("s"): settings = SETTINGS_SENSITIVE elif mode.lower().startswith("a"): settings = SETTINGS_AUTO else: print("wrong camera mode") # switch on auto mode self.cam.awb_mode = 'auto' self.cam.exposure_mode = 'auto' # settings = dict with fields: name, ss, fps, iso, g, sleep self.cam.framerate = settings['fps'] if settings['ss']: self.cam.shutter_speed = settings['ss'] self.cam.iso = settings['iso'] # Wait for the automatic gain control to settle time.sleep(settings['sleep']) # Now fix the values if not settings['ss']: self.cam.shutter_speed = self.cam.exposure_speed self.cam.exposure_mode = 'off' if settings['g']: g = settings['g'] else: g = self.cam.awb_gains self.cam.awb_mode = 'off' self.cam.awb_gains = g def measure(self, roi=ROI, channel_name="green", threshold=DETECTION_THRESHOLD, dir_out=None, csv_out=None, postfix=""): # notify other camera to take a picture self.tx.on() # check whether channel is valid if channel_name.lower().startswith("r"): channel = 0 channel_name = "red" elif channel_name.lower().startswith("g"): channel = 1 channel_name = "green" elif channel_name.lower().startswith("b"): channel = 2 channel_name = "blue" else: print("wrong channel_name: '{}'".format(channel_name)) # get camera settings time.sleep(1) fps = float(self.cam.framerate) ss = self.cam.exposure_speed g = self.cam.awb_gains g1 = g[0].numerator g2 = g[0].denominator g3 = g[1].numerator g4 = g[1].denominator iso = self.cam.iso settings_str = "ss{}_g{}-{}_{}-{}_iso{}_".format( ss, g1, g2, g3, g4, iso) csv_row = [fps, ss, iso, g1, g2, g3, g4] print("taking photos with settings: {}".format( settings_str)) # with picamera.PiCamera(resolution=RESOLUTION) as cam: # https://picamera.readthedocs.io/en/latest/ #         api_array.html#module-picamera.array with picamera.array.PiRGBArray(self.cam) as output: # cam.zoom = REGION_OF_INTEREST # cam.start_preview() # take picture t0 = time.time() self.cam.capture(output, format="rgb") a = output.array t1 = time.time() print("recorded for {} sec".format(round(t1-t0, 2))) t_pic = int(round(np.mean([t0, t1]))) # re-empty output (to reuse next iteration) # output.truncate(0) # crop to region of interest roi = a[ROI[0]:ROI[1], ROI[2]:ROI[3], :] vals = [] vals.append(np.median(roi[:, :, 0])) vals.append(np.median(roi[:, :, 1])) vals.append(np.median(roi[:, :, 2])) print(("roi.shape={},\n" + # "sum(red)={}, sum(green)={}, sum(blue)={},\n" + "med(red)={}, med(green)={}, med(blue)={}").format( roi.shape, vals[0], vals[1], vals[2])) val = vals[channel] print("reading the {} channel...\nvalue: {}".format( channel_name, val)) if val >= threshold: activated = True else: activated = False print("active={} (threshold: {})".format(activated, threshold)) # debug mode: # output images and csv if output directory exists if dir_out: names = ["1-red", "2-green", "3-blue"] # whole images fn = "full_{}{}_0-rgb{}.png".format( settings_str, postfix, now_str()) ffn = safename(os.path.join(dir_out, fn), "file") plt.imsave(ffn, a) for i in range(3): fn = "full_{}{}_{}{}.png".format( settings_str, postfix, names[i], now_str()) ffn = safename(os.path.join(dir_out, fn), "file") plt.imsave(ffn, a[:, :, i], vmin=0, vmax=255) # cropped to ROI fn = "roi_{}{}_0-rgb{}.png".format( settings_str, postfix, now_str()) ffn = safename(os.path.join(dir_out, fn), "file") plt.imsave(ffn, roi) for i in range(3): fn = "roi_{}{}_{}{}.png".format( settings_str, postfix, names[i], now_str()) ffn = safename(os.path.join(dir_out, fn), "file") plt.imsave(ffn, roi[:, :, i], vmin=0, vmax=255) csv_row.extend([t_pic, from_timestamp(t_pic), postfix, vals[0], vals[1], vals[2]]) with open(csv_out, "at") as csvfile: csvwriter = csv.writer(csvfile) csvwriter.writerow(csv_row) print("wrote csv_row: {}".format(csv_row)) # read state of the slave-camera other_activated = False # impossible that both are active! if not activated: timeout = time.time() + 2 # seconds while not other_activated and time.time() < timeout: other_activated = self.rx.is_active self.tx.off() # determine final state if activated: output = 1 elif other_activated: output = -1 else: output = 0 return output def exit_clean(self): if not self.cam == "": self.cam.close() def main(args): global CSV_NAME global CSV_HEADER # t0 = time.time() cam = ColiCamMaster(mode=args.mode) # t_cam = time.time() - t0 # select mode (camera settings) current_mode = args.mode # optionally create output directory for debugging if args.debug: # setup output directory (and copy over the code?) dir_out = "/home/pi/ColiCam_{}".format(now_str("%y%m%d")) dir_out = safename(dir_out, "dir") if not os.path.isdir(dir_out): os.mkdir(dir_out) print("outputting to '{}'".format(dir_out)) # initialize csv-log csv_fn = "{}{}{}.csv".format(CSV_NAME, args.postfix, now_str()) csv_out = safename(os.path.join(dir_out, csv_fn), 'file') # write header with open(csv_out, "wt") as csvfile: csvwriter = csv.writer(csvfile) csvwriter.writerow(CSV_HEADER) print("initialized {} with header {}".format( csv_out, CSV_HEADER)) else: dir_out = None csv_out = None # it = 0 try: while True: # it += 1 # update mode new_mode = args.mode if not current_mode == new_mode: cam.set_cam(mode=new_mode) # cam.set_cam(mode=args.mode) print("measuring in {} mode (default):".format(args.mode)) # measure with both cams val = cam.measure(dir_out=dir_out, csv_out=csv_out, postfix=args.postfix) if val == -1: print("wall on the left\n") elif val == 0: print("no wall detected\n") elif val == 1: print("wall on the right\n") except KeyboardInterrupt: print("manually interrupted program") finally: cam.exit_clean() print("camera closed, done!") if __name__ == "__main__": main(args)
Camera Slave:
1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399
#!/usr/bin/env python """ Code for the slave-camera It is connected to the master-camera via 2 GPIO pins and outputs the detected bacterial state via the GPIO-connection to the master-camera. In order to constantly listen for commands from the master camera, it needs to start a background- thread. @author: Daniel Hofstadler, 2017 """ import os import csv import time import argparse import gpiozero import threading from datetime import datetime from fractions import Fraction import numpy as np import picamera import picamera.array from matplotlib import pyplot as plt # import warnings # warnings.filterwarnings('error', category=DeprecationWarning) # globals # LOCAL_TZ = pytz.timezone("Etc/UTC")  # read from cams.csv OUT_APPEND = "_coli" CSV_NAME = "colicam" CSV_HEADER = ["framerate", "exposure_time_us", "iso", "g1", "g2", "g3", "g4", "timestamp", "time_utc", "tag", "red", "green", "blue"] # RESOLUTION = (2592, 1944) RESOLUTION = (1280, 720) # REGION_OF_INTEREST = (0.35, 0.4, 0.5, 0.7) ROI = [200, 520, 480, 800] # Y0, Y1, X0, X1 DETECTION_THRESHOLD = 150 PIN_RX = 17 PIN_TX = 18 SETTINGS_FIXED = { 'name': "fixed", 'ss': 1000000, # 1000 milliseconds = 1 sec 'fps': Fraction(1, 2), # (1, 2) 'iso': 800, # 800 'g': (Fraction(2, 1), Fraction(1, 1)), # 'g': (Fraction(345, 256), Fraction(167, 128)), 'sleep': 15} # 10 SETTINGS_SENSITIVE = { 'name': "sensitive", 'ss': 6000000, # 6 seconds 'fps': Fraction(1, 6), 'iso': 800, 'g': None, 'sleep': 30} SETTINGS_AUTO = { 'name': "auto", 'ss': None, 'fps': 30, 'iso': 0, 'g': None, 'sleep': 2} SETTINGS_DEFAULT = "fixed" # argument parsing parser = argparse.ArgumentParser( description="Colibot Photometer Camera.") parser.add_argument("-d", "--debug", action="store_true", help="debug mode") parser.add_argument("-m", "--mode", type=str, default="fixed", choices=["f", "fixed", "s", "sensitive", "a", "auto"], help="set the camera mode") parser.add_argument("-p", "--postfix", type=str, default="", help="add string to filename") # args = vars(ap.parse_args()) args = parser.parse_args() if not args.postfix == "" and not args.postfix.startswith("_"): args.postfix = "_" + args.postfix def now_str(pattern="_%y%m%d-%H%M%S_utc"): # return time.strftime(pattern, time.gmtime()) return datetime.utcnow().strftime(pattern) def from_timestamp(ts, pattern="%y%m%d-%H%M%S_utc"): return datetime.utcfromtimestamp(ts).strftime(pattern) def safename(s, s_type): """Check whether a given file or folder 's' exists, return a non-existing filename. s ........ (full) filename or directory s_type ... 'file' or 'f' for files, 'directory' or 'dir' or 'd' for folders Returns a file- or pathname that is supposedly safe to save without overwriting data. """ low_type = str.lower(s_type) if low_type == 'file' or low_type == 'f': if os.path.isfile(s): s2 = s.split('.') s_base = s2[0] s_ext = s2[-1] counter = 0 while os.path.isfile(s): s = s_base + "-{:02d}.".format(counter) + s_ext counter += 1 elif low_type == 'directory' or low_type == 'dir' or low_type == 'd': if os.path.isdir(s): s_base = s counter = 0 while os.path.isdir(s): s = s_base + "-{:02d}".format(counter) counter += 1 return s def thread_listener(cam): """Background thread listening on the receive-pin whether to make a measurement.""" try: while cam.active: if cam.rx.is_active: cam.measure_slave() time.sleep(0.5) finally: print("listener thread shutting down") class ColiCamSlave: global RESOLUTION global ROI # REGION_OF_INTEREST global DETECTION_THRESHOLD global SETTINGS_FIXED global SETTINGS_SENSITIVE global SETTINGS_AUTO global DEF_SETTINGS_NAME global PIN_RX global PIN_TX def __init__(self, resolution=RESOLUTION, mode=DEF_SETTINGS_NAME): try: self.cam = picamera.PiCamera(resolution=resolution) self.set_cam(mode) except Exception as err: self.cam = "" print("couldn't initialize camera, error: {}".format(err)) self.rx = gpiozero.InputDevice(PIN_RX) self.tx = gpiozero.OutputDevice(PIN_TX) self.active = True # start the listening thread listener = threading.Thread( target=thread_listener, args=(self)) listener.daemon = True listener.start() self.listener = listener def set_cam(self, mode="fixed"): if mode.lower().startswith("f"): settings = SETTINGS_FIXED elif mode.lower().startswith("s"): settings = SETTINGS_SENSITIVE elif mode.lower().startswith("a"): settings = SETTINGS_AUTO else: print("wrong camera mode") # switch on auto mode self.cam.awb_mode = 'auto' self.cam.exposure_mode = 'auto' # settings = dict with fields: name, ss, fps, iso, g, sleep self.cam.framerate = settings['fps'] if settings['ss']: self.cam.shutter_speed = settings['ss'] self.cam.iso = settings['iso'] # Wait for the automatic gain control to settle time.sleep(settings['sleep']) # Now fix the values if not settings['ss']: self.cam.shutter_speed = self.cam.exposure_speed self.cam.exposure_mode = 'off' if settings['g']: g = settings['g'] else: g = self.cam.awb_gains self.cam.awb_mode = 'off' self.cam.awb_gains = g def measure_slave(self, roi=ROI, channel_name="green", threshold=DETECTION_THRESHOLD, dir_out=None, csv_out=None, postfix=""): # check whether channel is valid if channel_name.lower().startswith("r"): channel = 0 channel_name = "red" elif channel_name.lower().startswith("g"): channel = 1 channel_name = "green" elif channel_name.lower().startswith("b"): channel = 2 channel_name = "blue" else: print("wrong channel_name: '{}'".format(channel_name)) # get camera settings time.sleep(1) fps = float(self.cam.framerate) ss = self.cam.exposure_speed g = self.cam.awb_gains g1 = g[0].numerator g2 = g[0].denominator g3 = g[1].numerator g4 = g[1].denominator iso = self.cam.iso settings_str = "ss{}_g{}-{}_{}-{}_iso{}_".format( ss, g1, g2, g3, g4, iso) csv_row = [fps, ss, iso, g1, g2, g3, g4] print("taking photos with settings: {}".format( settings_str)) # with picamera.PiCamera(resolution=RESOLUTION) as cam: # https://picamera.readthedocs.io/en/latest/ #         api_array.html#module-picamera.array with picamera.array.PiRGBArray(self.cam) as output: # cam.zoom = REGION_OF_INTEREST # cam.start_preview() # take picture t0 = time.time() self.cam.capture(output, format="rgb") a = output.array t1 = time.time() print("recorded for {} sec".format(round(t1-t0, 2))) t_pic = int(round(np.mean([t0, t1]))) # re-empty output (to reuse next iteration) # output.truncate(0) # crop to region of interest roi = a[ROI[0]:ROI[1], ROI[2]:ROI[3], :] vals = [] vals.append(np.median(roi[:, :, 0])) vals.append(np.median(roi[:, :, 1])) vals.append(np.median(roi[:, :, 2])) print(("roi.shape={},\n" + # "sum(red)={}, sum(green)={}, sum(blue)={},\n" + "med(red)={}, med(green)={}, med(blue)={}").format( roi.shape, vals[0], vals[1], vals[2])) val = vals[channel] print("reading the {} channel...\nvalue: {}".format( channel_name, val)) # checking whether threshold is crossed and #   signalling the master-camera if val >= threshold: activated = True self.tx.on() else: activated = False self.tx.off() print("active={} (threshold: {})".format(activated, threshold)) # debug mode: # output images and csv if output directory exists if dir_out: names = ["1-red", "2-green", "3-blue"] # whole images fn = "full_{}{}_0-rgb{}.png".format( settings_str, postfix, now_str()) ffn = safename(os.path.join(dir_out, fn), "file") plt.imsave(ffn, a) for i in range(3): fn = "full_{}{}_{}{}.png".format( settings_str, postfix, names[i], now_str()) ffn = safename(os.path.join(dir_out, fn), "file") plt.imsave(ffn, a[:, :, i], vmin=0, vmax=255) # cropped to ROI fn = "roi_{}{}_0-rgb{}.png".format( settings_str, postfix, now_str()) ffn = safename(os.path.join(dir_out, fn), "file") plt.imsave(ffn, roi) for i in range(3): fn = "roi_{}{}_{}{}.png".format( settings_str, postfix, names[i], now_str()) ffn = safename(os.path.join(dir_out, fn), "file") plt.imsave(ffn, roi[:, :, i], vmin=0, vmax=255) csv_row.extend([t_pic, from_timestamp(t_pic), postfix, vals[0], vals[1], vals[2]]) with open(csv_out, "at") as csvfile: csvwriter = csv.writer(csvfile) csvwriter.writerow(csv_row) print("wrote csv_row: {}".format(csv_row)) return None def exit_clean(self): if not self.cam == "": self.cam.close() self.active = False self.listener.join() def main(args): global CSV_NAME global CSV_HEADER # t0 = time.time() cam = ColiCamSlave(mode=args.mode) # t_cam = time.time() - t0 # select mode (camera settings) current_mode = args.mode # optionally create output directory for debugging if args.debug: # setup output directory (and copy over the code?) dir_out = "/home/pi/ColiCam_{}".format(now_str("%y%m%d")) dir_out = safename(dir_out, "dir") if not os.path.isdir(dir_out): os.mkdir(dir_out) print("outputting to '{}'".format(dir_out)) # initialize csv-log csv_fn = "{}{}{}.csv".format(CSV_NAME, args.postfix, now_str()) csv_out = safename(os.path.join(dir_out, csv_fn), 'file') # write header with open(csv_out, "wt") as csvfile: csvwriter = csv.writer(csvfile) csvwriter.writerow(CSV_HEADER) print("initialized {} with header {}".format( csv_out, CSV_HEADER)) else: dir_out = None csv_out = None # it = 0 try: while True: # it += 1 # update mode new_mode = args.mode if not current_mode == new_mode: cam.set_cam(mode=new_mode) # cam.set_cam(mode=args.mode) print("measuring in {} mode (default):".format(args.mode)) # measure with both cams val = cam.measure(dir_out=dir_out, csv_out=csv_out, postfix=args.postfix) if val == -1: print("wall on the left\n") elif val == 0: print("no wall detected\n") elif val == 1: print("wall on the right\n") except KeyboardInterrupt: print("manually interrupted program") finally: cam.exit_clean() print("camera closed, done!") if __name__ == "__main__": main(args)

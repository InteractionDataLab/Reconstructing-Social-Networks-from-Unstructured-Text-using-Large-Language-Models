<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Edinburgh_lightboxprototype"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu"><UL><LI class="selected"><A href="/Team:Edinburgh/lightboxprototype">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Edinburgh/lightboxprototype&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Edinburgh/lightboxprototype&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Edinburgh/lightboxprototype&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Edinburgh/lightboxprototype" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Edinburgh/lightboxprototype</H1><DIV id="bodyContent"><H3 id="siteSub">From 2009.igem.org</H3><P>/*  Prototype JavaScript framework, version 1.6.0.2
</P><PRE>*  (c) 2005-2008 Sam Stephenson
*
*  Prototype is freely distributable under the terms of an MIT-style license.
*  For details, see the Prototype web site: <A href="http://www.prototypejs.org/" class="external free" rel="nofollow">http://www.prototypejs.org/</A>
*
*--------------------------------------------------------------------------*/
</PRE><P>var Prototype = {
</P><PRE> Version: '1.6.0.2',
</PRE><PRE> Browser: {
   IE:     !!(window.attachEvent &amp;&amp; !window.opera),
   Opera:  !!window.opera,
   WebKit: navigator.userAgent.indexOf('AppleWebKit/') &gt; -1,
   Gecko:  navigator.userAgent.indexOf('Gecko') &gt; -1 &amp;&amp; navigator.userAgent.indexOf('KHTML') == -1,
   MobileSafari: !!navigator.userAgent.match(/Apple.*Mobile.*Safari/)
 },
</PRE><PRE> BrowserFeatures: {
   XPath: !!document.evaluate,
   ElementExtensions: !!window.HTMLElement,
   SpecificElementExtensions:
     document.createElement('div').__proto__ &amp;&amp;
     document.createElement('div').__proto__ !==
       document.createElement('form').__proto__
 },
</PRE><PRE> ScriptFragment: '&lt;script[^&gt;]*&gt;([\\S\\s]*?)&lt;\/script&gt;',
 JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/,
</PRE><PRE> emptyFunction: function() { },
 K: function(x) { return x }
</PRE><P>};
</P><P>if (Prototype.Browser.MobileSafari)
</P><PRE> Prototype.BrowserFeatures.SpecificElementExtensions = false;
</PRE><P>
/* Based on Alex Arnell's inheritance implementation. */
var Class = {
</P><PRE> create: function() {
   var parent = null, properties = $A(arguments);
   if (Object.isFunction(properties[0]))
     parent = properties.shift();
</PRE><PRE>   function klass() {
     this.initialize.apply(this, arguments);
   }
</PRE><PRE>   Object.extend(klass, Class.Methods);
   klass.superclass = parent;
   klass.subclasses = [];
</PRE><PRE>   if (parent) {
     var subclass = function() { };
     subclass.prototype = parent.prototype;
     klass.prototype = new subclass;
     parent.subclasses.push(klass);
   }
</PRE><PRE>   for (var i = 0; i &lt; properties.length; i++)
     klass.addMethods(properties[i]);
</PRE><PRE>   if (!klass.prototype.initialize)
     klass.prototype.initialize = Prototype.emptyFunction;
</PRE><PRE>   klass.prototype.constructor = klass;
</PRE><PRE>   return klass;
 }
</PRE><P>};
</P><P>Class.Methods = {
</P><PRE> addMethods: function(source) {
   var ancestor   = this.superclass &amp;&amp; this.superclass.prototype;
   var properties = Object.keys(source);
</PRE><PRE>   if (!Object.keys({ toString: true }).length)
     properties.push(&quot;toString&quot;, &quot;valueOf&quot;);
</PRE><PRE>   for (var i = 0, length = properties.length; i &lt; length; i++) {
     var property = properties[i], value = source[property];
     if (ancestor &amp;&amp; Object.isFunction(value) &amp;&amp;
         value.argumentNames().first() == &quot;$super&quot;) {
       var method = value, value = Object.extend((function(m) {
         return function() { return ancestor[m].apply(this, arguments) };
       })(property).wrap(method), {
         valueOf:  function() { return method },
         toString: function() { return method.toString() }
       });
     }
     this.prototype[property] = value;
   }
</PRE><PRE>   return this;
 }
</PRE><P>};
</P><P>var Abstract = { };
</P><P>Object.extend = function(destination, source) {
</P><PRE> for (var property in source)
   destination[property] = source[property];
 return destination;
</PRE><P>};
</P><P>Object.extend(Object, {
</P><PRE> inspect: function(object) {
   try {
     if (Object.isUndefined(object)) return 'undefined';
     if (object === null) return 'null';
     return object.inspect ? object.inspect() : String(object);
   } catch (e) {
     if (e instanceof RangeError) return '...';
     throw e;
   }
 },
</PRE><PRE> toJSON: function(object) {
   var type = typeof object;
   switch (type) {
     case 'undefined':
     case 'function':
     case 'unknown': return;
     case 'boolean': return object.toString();
   }
</PRE><PRE>   if (object === null) return 'null';
   if (object.toJSON) return object.toJSON();
   if (Object.isElement(object)) return;
</PRE><PRE>   var results = [];
   for (var property in object) {
     var value = Object.toJSON(object[property]);
     if (!Object.isUndefined(value))
       results.push(property.toJSON() + ': ' + value);
   }
</PRE><PRE>   return '{' + results.join(', ') + '}';
 },
</PRE><PRE> toQueryString: function(object) {
   return $H(object).toQueryString();
 },
</PRE><PRE> toHTML: function(object) {
   return object &amp;&amp; object.toHTML ? object.toHTML() : String.interpret(object);
 },
</PRE><PRE> keys: function(object) {
   var keys = [];
   for (var property in object)
     keys.push(property);
   return keys;
 },
</PRE><PRE> values: function(object) {
   var values = [];
   for (var property in object)
     values.push(object[property]);
   return values;
 },
</PRE><PRE> clone: function(object) {
   return Object.extend({ }, object);
 },
</PRE><PRE> isElement: function(object) {
   return object &amp;&amp; object.nodeType == 1;
 },
</PRE><PRE> isArray: function(object) {
   return object != null &amp;&amp; typeof object == &quot;object&quot; &amp;&amp;
     'splice' in object &amp;&amp; 'join' in object;
 },
</PRE><PRE> isHash: function(object) {
   return object instanceof Hash;
 },
</PRE><PRE> isFunction: function(object) {
   return typeof object == &quot;function&quot;;
 },
</PRE><PRE> isString: function(object) {
   return typeof object == &quot;string&quot;;
 },
</PRE><PRE> isNumber: function(object) {
   return typeof object == &quot;number&quot;;
 },
</PRE><PRE> isUndefined: function(object) {
   return typeof object == &quot;undefined&quot;;
 }
</PRE><P>});
</P><P>Object.extend(Function.prototype, {
</P><PRE> argumentNames: function() {
   var names = this.toString().match(/^[\s\(]*function[^(]*\((.*?)\)/)[1].split(&quot;,&quot;).invoke(&quot;strip&quot;);
   return names.length == 1 &amp;&amp; !names[0] ? [] : names;
 },
</PRE><PRE> bind: function() {
   if (arguments.length &lt; 2 &amp;&amp; Object.isUndefined(arguments[0])) return this;
   var __method = this, args = $A(arguments), object = args.shift();
   return function() {
     return __method.apply(object, args.concat($A(arguments)));
   }
 },
</PRE><PRE> bindAsEventListener: function() {
   var __method = this, args = $A(arguments), object = args.shift();
   return function(event) {
     return __method.apply(object, [event || window.event].concat(args));
   }
 },
</PRE><PRE> curry: function() {
   if (!arguments.length) return this;
   var __method = this, args = $A(arguments);
   return function() {
     return __method.apply(this, args.concat($A(arguments)));
   }
 },
</PRE><PRE> delay: function() {
   var __method = this, args = $A(arguments), timeout = args.shift() * 1000;
   return window.setTimeout(function() {
     return __method.apply(__method, args);
   }, timeout);
 },
</PRE><PRE> wrap: function(wrapper) {
   var __method = this;
   return function() {
     return wrapper.apply(this, [__method.bind(this)].concat($A(arguments)));
   }
 },
</PRE><PRE> methodize: function() {
   if (this._methodized) return this._methodized;
   var __method = this;
   return this._methodized = function() {
     return __method.apply(null, [this].concat($A(arguments)));
   };
 }
</PRE><P>});
</P><P>Function.prototype.defer = Function.prototype.delay.curry(0.01);
</P><P>Date.prototype.toJSON = function() {
</P><PRE> return '&quot;' + this.getUTCFullYear() + '-' +
   (this.getUTCMonth() + 1).toPaddedString(2) + '-' +
   this.getUTCDate().toPaddedString(2) + 'T' +
   this.getUTCHours().toPaddedString(2) + ':' +
   this.getUTCMinutes().toPaddedString(2) + ':' +
   this.getUTCSeconds().toPaddedString(2) + 'Z&quot;';
</PRE><P>};
</P><P>var Try = {
</P><PRE> these: function() {
   var returnValue;
</PRE><PRE>   for (var i = 0, length = arguments.length; i &lt; length; i++) {
     var lambda = arguments[i];
     try {
       returnValue = lambda();
       break;
     } catch (e) { }
   }
</PRE><PRE>   return returnValue;
 }
</PRE><P>};
</P><P>RegExp.prototype.match = RegExp.prototype.test;
</P><P>RegExp.escape = function(str) {
</P><PRE> return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
</PRE><P>};
</P><P>/*--------------------------------------------------------------------------*/
</P><P>var PeriodicalExecuter = Class.create({
</P><PRE> initialize: function(callback, frequency) {
   this.callback = callback;
   this.frequency = frequency;
   this.currentlyExecuting = false;
</PRE><PRE>   this.registerCallback();
 },
</PRE><PRE> registerCallback: function() {
   this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
 },
</PRE><PRE> execute: function() {
   this.callback(this);
 },
</PRE><PRE> stop: function() {
   if (!this.timer) return;
   clearInterval(this.timer);
   this.timer = null;
 },
</PRE><PRE> onTimerEvent: function() {
   if (!this.currentlyExecuting) {
     try {
       this.currentlyExecuting = true;
       this.execute();
     } finally {
       this.currentlyExecuting = false;
     }
   }
 }
</PRE><P>});
Object.extend(String, {
</P><PRE> interpret: function(value) {
   return value == null ? <I> : String(value);</I>
 },
 specialChar: {
   '\b': '\\b',
   '\t': '\\t',
   '\n': '\\n',
   '\f': '\\f',
   '\r': '\\r',
   '\\': '\\\\'
 }
</PRE><P>});
</P><P>Object.extend(String.prototype, {
</P><PRE> gsub: function(pattern, replacement) {
   var result = <I>, source = this, match;</I>
   replacement = arguments.callee.prepareReplacement(replacement);
</PRE><PRE>   while (source.length &gt; 0) {
     if (match = source.match(pattern)) {
       result += source.slice(0, match.index);
       result += String.interpret(replacement(match));
       source  = source.slice(match.index + match[0].length);
     } else {
       result += source, source = <I>;</I>
     }
   }
   return result;
 },
</PRE><PRE> sub: function(pattern, replacement, count) {
   replacement = this.gsub.prepareReplacement(replacement);
   count = Object.isUndefined(count) ? 1 : count;
</PRE><PRE>   return this.gsub(pattern, function(match) {
     if (--count &lt; 0) return match[0];
     return replacement(match);
   });
 },
</PRE><PRE> scan: function(pattern, iterator) {
   this.gsub(pattern, iterator);
   return String(this);
 },
</PRE><PRE> truncate: function(length, truncation) {
   length = length || 30;
   truncation = Object.isUndefined(truncation) ? '...' : truncation;
   return this.length &gt; length ?
     this.slice(0, length - truncation.length) + truncation : String(this);
 },
</PRE><PRE> strip: function() {
   return this.replace(/^\s+/, <I>).replace(/\s+$/, </I>);
 },
</PRE><PRE> stripTags: function() {
   return this.replace(/&lt;\/?[^&gt;]+&gt;/gi, <I>);</I>
 },
</PRE><PRE> stripScripts: function() {
   return this.replace(new RegExp(Prototype.ScriptFragment, 'img'), <I>);</I>
 },
</PRE><PRE> extractScripts: function() {
   var matchAll = new RegExp(Prototype.ScriptFragment, 'img');
   var matchOne = new RegExp(Prototype.ScriptFragment, 'im');
   return (this.match(matchAll) || []).map(function(scriptTag) {
     return (scriptTag.match(matchOne) || [<I>, </I>])[1];
   });
 },
</PRE><PRE> evalScripts: function() {
   return this.extractScripts().map(function(script) { return eval(script) });
 },
</PRE><PRE> escapeHTML: function() {
   var self = arguments.callee;
   self.text.data = this;
   return self.div.innerHTML;
 },
</PRE><PRE> unescapeHTML: function() {
   var div = new Element('div');
   div.innerHTML = this.stripTags();
   return div.childNodes[0] ? (div.childNodes.length &gt; 1 ?
     $A(div.childNodes).inject(<I>, function(memo, node) { return memo+node.nodeValue }) :</I>
     div.childNodes[0].nodeValue) : <I>;</I>
 },
</PRE><PRE> toQueryParams: function(separator) {
   var match = this.strip().match(/([^?#]*)(#.*)?$/);
   if (!match) return { };
</PRE><PRE>   return match[1].split(separator || '&amp;').inject({ }, function(hash, pair) {
     if ((pair = pair.split('='))[0]) {
       var key = decodeURIComponent(pair.shift());
       var value = pair.length &gt; 1 ? pair.join('=') : pair[0];
       if (value != undefined) value = decodeURIComponent(value);
</PRE><PRE>       if (key in hash) {
         if (!Object.isArray(hash[key])) hash[key] = [hash[key]];
         hash[key].push(value);
       }
       else hash[key] = value;
     }
     return hash;
   });
 },
</PRE><PRE> toArray: function() {
   return this.split(<I>);</I>
 },
</PRE><PRE> succ: function() {
   return this.slice(0, this.length - 1) +
     String.fromCharCode(this.charCodeAt(this.length - 1) + 1);
 },
</PRE><PRE> times: function(count) {
   return count &lt; 1 ? <I> : new Array(count + 1).join(this);</I>
 },
</PRE><PRE> camelize: function() {
   var parts = this.split('-'), len = parts.length;
   if (len == 1) return parts[0];
</PRE><PRE>   var camelized = this.charAt(0) == '-'
     ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1)
     : parts[0];
</PRE><PRE>   for (var i = 1; i &lt; len; i++)
     camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
</PRE><PRE>   return camelized;
 },
</PRE><PRE> capitalize: function() {
   return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
 },
</PRE><PRE> underscore: function() {
   return this.gsub(/::/, '/').gsub(/([A-Z]+)([A-Z][a-z])/,'#{1}_#{2}').gsub(/([a-z\d])([A-Z])/,'#{1}_#{2}').gsub(/-/,'_').toLowerCase();
 },
</PRE><PRE> dasherize: function() {
   return this.gsub(/_/,'-');
 },
</PRE><PRE> inspect: function(useDoubleQuotes) {
   var escapedString = this.gsub(/[\x00-\x1f\\]/, function(match) {
     var character = String.specialChar[match[0]];
     return character ? character : '\\u00' + match[0].charCodeAt().toPaddedString(2, 16);
   });
   if (useDoubleQuotes) return '&quot;' + escapedString.replace(/&quot;/g, '\\&quot;') + '&quot;';
   return &quot;'&quot; + escapedString.replace(/'/g, '\\\<I>) + &quot;'&quot;;</I>
 },
</PRE><PRE> toJSON: function() {
   return this.inspect(true);
 },
</PRE><PRE> unfilterJSON: function(filter) {
   return this.sub(filter || Prototype.JSONFilter, '#{1}');
 },
</PRE><PRE> isJSON: function() {
   var str = this;
   if (str.blank()) return false;
   str = this.replace(/\\./g, '@').replace(/&quot;[^&quot;\\\n\r]*&quot;/g, <I>);</I>
   return (/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(str);
 },
</PRE><PRE> evalJSON: function(sanitize) {
   var json = this.unfilterJSON();
   try {
     if (!sanitize || json.isJSON()) return eval('(' + json + ')');
   } catch (e) { }
   throw new SyntaxError('Badly formed JSON string: ' + this.inspect());
 },
</PRE><PRE> include: function(pattern) {
   return this.indexOf(pattern) &gt; -1;
 },
</PRE><PRE> startsWith: function(pattern) {
   return this.indexOf(pattern) === 0;
 },
</PRE><PRE> endsWith: function(pattern) {
   var d = this.length - pattern.length;
   return d &gt;= 0 &amp;&amp; this.lastIndexOf(pattern) === d;
 },
</PRE><PRE> empty: function() {
   return this == <I>;</I>
 },
</PRE><PRE> blank: function() {
   return /^\s*$/.test(this);
 },
</PRE><PRE> interpolate: function(object, pattern) {
   return new Template(this, pattern).evaluate(object);
 }
</PRE><P>});
</P><P>if (Prototype.Browser.WebKit || Prototype.Browser.IE) Object.extend(String.prototype, {
</P><PRE> escapeHTML: function() {
   return this.replace(/&amp;/g,'&amp;').replace(/&lt;/g,'&lt;').replace(/&gt;/g,'&gt;');
 },
 unescapeHTML: function() {
   return this.replace(/&amp;/g,'&amp;').replace(/&lt;/g,'&lt;').replace(/&gt;/g,'&gt;');
 }
</PRE><P>});
</P><P>String.prototype.gsub.prepareReplacement = function(replacement) {
</P><PRE> if (Object.isFunction(replacement)) return replacement;
 var template = new Template(replacement);
 return function(match) { return template.evaluate(match) };
</PRE><P>};
</P><P>String.prototype.parseQuery = String.prototype.toQueryParams;
</P><P>Object.extend(String.prototype.escapeHTML, {
</P><PRE> div:  document.createElement('div'),
 text: document.createTextNode(<I>)</I></PRE><P>});
</P><P>with (String.prototype.escapeHTML) div.appendChild(text);
</P><P>var Template = Class.create({
</P><PRE> initialize: function(template, pattern) {
   this.template = template.toString();
   this.pattern = pattern || Template.Pattern;
 },
</PRE><PRE> evaluate: function(object) {
   if (Object.isFunction(object.toTemplateReplacements))
     object = object.toTemplateReplacements();
</PRE><PRE>   return this.template.gsub(this.pattern, function(match) {
     if (object == null) return <I>;</I></PRE><PRE>     var before = match[1] || <I>;</I>
     if (before == '\\') return match[2];
</PRE><PRE>     var ctx = object, expr = match[3];
     var pattern = /^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/;
     match = pattern.exec(expr);
     if (match == null) return before;
</PRE><PRE>     while (match != null) {
       var comp = match[1].startsWith('[') ? match[2].gsub('\\\\]', ']') : match[1];
       ctx = ctx[comp];
       if (null == ctx || <I> == match[3]) break;</I>
       expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
       match = pattern.exec(expr);
     }
</PRE><PRE>     return before + String.interpret(ctx);
   });
 }
</PRE><P>});
Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;
</P><P>var $break = { };
</P><P>var Enumerable = {
</P><PRE> each: function(iterator, context) {
   var index = 0;
   iterator = iterator.bind(context);
   try {
     this._each(function(value) {
       iterator(value, index++);
     });
   } catch (e) {
     if (e != $break) throw e;
   }
   return this;
 },
</PRE><PRE> eachSlice: function(number, iterator, context) {
   iterator = iterator ? iterator.bind(context) : Prototype.K;
   var index = -number, slices = [], array = this.toArray();
   while ((index += number) &lt; array.length)
     slices.push(array.slice(index, index+number));
   return slices.collect(iterator, context);
 },
</PRE><PRE> all: function(iterator, context) {
   iterator = iterator ? iterator.bind(context) : Prototype.K;
   var result = true;
   this.each(function(value, index) {
     result = result &amp;&amp; !!iterator(value, index);
     if (!result) throw $break;
   });
   return result;
 },
</PRE><PRE> any: function(iterator, context) {
   iterator = iterator ? iterator.bind(context) : Prototype.K;
   var result = false;
   this.each(function(value, index) {
     if (result = !!iterator(value, index))
       throw $break;
   });
   return result;
 },
</PRE><PRE> collect: function(iterator, context) {
   iterator = iterator ? iterator.bind(context) : Prototype.K;
   var results = [];
   this.each(function(value, index) {
     results.push(iterator(value, index));
   });
   return results;
 },
</PRE><PRE> detect: function(iterator, context) {
   iterator = iterator.bind(context);
   var result;
   this.each(function(value, index) {
     if (iterator(value, index)) {
       result = value;
       throw $break;
     }
   });
   return result;
 },
</PRE><PRE> findAll: function(iterator, context) {
   iterator = iterator.bind(context);
   var results = [];
   this.each(function(value, index) {
     if (iterator(value, index))
       results.push(value);
   });
   return results;
 },
</PRE><PRE> grep: function(filter, iterator, context) {
   iterator = iterator ? iterator.bind(context) : Prototype.K;
   var results = [];
</PRE><PRE>   if (Object.isString(filter))
     filter = new RegExp(filter);
</PRE><PRE>   this.each(function(value, index) {
     if (filter.match(value))
       results.push(iterator(value, index));
   });
   return results;
 },
</PRE><PRE> include: function(object) {
   if (Object.isFunction(this.indexOf))
     if (this.indexOf(object) != -1) return true;
</PRE><PRE>   var found = false;
   this.each(function(value) {
     if (value == object) {
       found = true;
       throw $break;
     }
   });
   return found;
 },
</PRE><PRE> inGroupsOf: function(number, fillWith) {
   fillWith = Object.isUndefined(fillWith) ? null : fillWith;
   return this.eachSlice(number, function(slice) {
     while(slice.length &lt; number) slice.push(fillWith);
     return slice;
   });
 },
</PRE><PRE> inject: function(memo, iterator, context) {
   iterator = iterator.bind(context);
   this.each(function(value, index) {
     memo = iterator(memo, value, index);
   });
   return memo;
 },
</PRE><PRE> invoke: function(method) {
   var args = $A(arguments).slice(1);
   return this.map(function(value) {
     return value[method].apply(value, args);
   });
 },
</PRE><PRE> max: function(iterator, context) {
   iterator = iterator ? iterator.bind(context) : Prototype.K;
   var result;
   this.each(function(value, index) {
     value = iterator(value, index);
     if (result == null || value &gt;= result)
       result = value;
   });
   return result;
 },
</PRE><PRE> min: function(iterator, context) {
   iterator = iterator ? iterator.bind(context) : Prototype.K;
   var result;
   this.each(function(value, index) {
     value = iterator(value, index);
     if (result == null || value &lt; result)
       result = value;
   });
   return result;
 },
</PRE><PRE> partition: function(iterator, context) {
   iterator = iterator ? iterator.bind(context) : Prototype.K;
   var trues = [], falses = [];
   this.each(function(value, index) {
     (iterator(value, index) ?
       trues : falses).push(value);
   });
   return [trues, falses];
 },
</PRE><PRE> pluck: function(property) {
   var results = [];
   this.each(function(value) {
     results.push(value[property]);
   });
   return results;
 },
</PRE><PRE> reject: function(iterator, context) {
   iterator = iterator.bind(context);
   var results = [];
   this.each(function(value, index) {
     if (!iterator(value, index))
       results.push(value);
   });
   return results;
 },
</PRE><PRE> sortBy: function(iterator, context) {
   iterator = iterator.bind(context);
   return this.map(function(value, index) {
     return {value: value, criteria: iterator(value, index)};
   }).sort(function(left, right) {
     var a = left.criteria, b = right.criteria;
     return a &lt; b ? -1 : a &gt; b ? 1 : 0;
   }).pluck('value');
 },
</PRE><PRE> toArray: function() {
   return this.map();
 },
</PRE><PRE> zip: function() {
   var iterator = Prototype.K, args = $A(arguments);
   if (Object.isFunction(args.last()))
     iterator = args.pop();
</PRE><PRE>   var collections = [this].concat(args).map($A);
   return this.map(function(value, index) {
     return iterator(collections.pluck(index));
   });
 },
</PRE><PRE> size: function() {
   return this.toArray().length;
 },
</PRE><PRE> inspect: function() {
   return '#&lt;Enumerable:' + this.toArray().inspect() + '&gt;';
 }
</PRE><P>};
</P><P>Object.extend(Enumerable, {
</P><PRE> map:     Enumerable.collect,
 find:    Enumerable.detect,
 select:  Enumerable.findAll,
 filter:  Enumerable.findAll,
 member:  Enumerable.include,
 entries: Enumerable.toArray,
 every:   Enumerable.all,
 some:    Enumerable.any
</PRE><P>});
function $A(iterable) {
</P><PRE> if (!iterable) return [];
 if (iterable.toArray) return iterable.toArray();
 var length = iterable.length || 0, results = new Array(length);
 while (length--) results[length] = iterable[length];
 return results;
</PRE><P>}
</P><P>if (Prototype.Browser.WebKit) {
</P><PRE> $A = function(iterable) {
   if (!iterable) return [];
   if (!(Object.isFunction(iterable) &amp;&amp; iterable == '[object NodeList]') &amp;&amp;
       iterable.toArray) return iterable.toArray();
   var length = iterable.length || 0, results = new Array(length);
   while (length--) results[length] = iterable[length];
   return results;
 };
</PRE><P>}
</P><P>Array.from = $A;
</P><P>Object.extend(Array.prototype, Enumerable);
</P><P>if (!Array.prototype._reverse) Array.prototype._reverse = Array.prototype.reverse;
</P><P>Object.extend(Array.prototype, {
</P><PRE> _each: function(iterator) {
   for (var i = 0, length = this.length; i &lt; length; i++)
     iterator(this[i]);
 },
</PRE><PRE> clear: function() {
   this.length = 0;
   return this;
 },
</PRE><PRE> first: function() {
   return this[0];
 },
</PRE><PRE> last: function() {
   return this[this.length - 1];
 },
</PRE><PRE> compact: function() {
   return this.select(function(value) {
     return value != null;
   });
 },
</PRE><PRE> flatten: function() {
   return this.inject([], function(array, value) {
     return array.concat(Object.isArray(value) ?
       value.flatten() : [value]);
   });
 },
</PRE><PRE> without: function() {
   var values = $A(arguments);
   return this.select(function(value) {
     return !values.include(value);
   });
 },
</PRE><PRE> reverse: function(inline) {
   return (inline !== false ? this : this.toArray())._reverse();
 },
</PRE><PRE> reduce: function() {
   return this.length &gt; 1 ? this : this[0];
 },
</PRE><PRE> uniq: function(sorted) {
   return this.inject([], function(array, value, index) {
     if (0 == index || (sorted ? array.last() != value : !array.include(value)))
       array.push(value);
     return array;
   });
 },
</PRE><PRE> intersect: function(array) {
   return this.uniq().findAll(function(item) {
     return array.detect(function(value) { return item === value });
   });
 },
</PRE><PRE> clone: function() {
   return [].concat(this);
 },
</PRE><PRE> size: function() {
   return this.length;
 },
</PRE><PRE> inspect: function() {
   return '[' + this.map(Object.inspect).join(', ') + ']';
 },
</PRE><PRE> toJSON: function() {
   var results = [];
   this.each(function(object) {
     var value = Object.toJSON(object);
     if (!Object.isUndefined(value)) results.push(value);
   });
   return '[' + results.join(', ') + ']';
 }
</PRE><P>});
</P><P>// use native browser JS 1.6 implementation if available
if (Object.isFunction(Array.prototype.forEach))
</P><PRE> Array.prototype._each = Array.prototype.forEach;
</PRE><P>if (!Array.prototype.indexOf) Array.prototype.indexOf = function(item, i) {
</P><PRE> i || (i = 0);
 var length = this.length;
 if (i &lt; 0) i = length + i;
 for (; i &lt; length; i++)
   if (this[i] === item) return i;
 return -1;
</PRE><P>};
</P><P>if (!Array.prototype.lastIndexOf) Array.prototype.lastIndexOf = function(item, i) {
</P><PRE> i = isNaN(i) ? this.length : (i &lt; 0 ? this.length + i : i) + 1;
 var n = this.slice(0, i).reverse().indexOf(item);
 return (n &lt; 0) ? n : i - n - 1;
</PRE><P>};
</P><P>Array.prototype.toArray = Array.prototype.clone;
</P><P>function $w(string) {
</P><PRE> if (!Object.isString(string)) return [];
 string = string.strip();
 return string ? string.split(/\s+/) : [];
</PRE><P>}
</P><P>if (Prototype.Browser.Opera){
</P><PRE> Array.prototype.concat = function() {
   var array = [];
   for (var i = 0, length = this.length; i &lt; length; i++) array.push(this[i]);
   for (var i = 0, length = arguments.length; i &lt; length; i++) {
     if (Object.isArray(arguments[i])) {
       for (var j = 0, arrayLength = arguments[i].length; j &lt; arrayLength; j++)
         array.push(arguments[i][j]);
     } else {
       array.push(arguments[i]);
     }
   }
   return array;
 };
</PRE><P>}
Object.extend(Number.prototype, {
</P><PRE> toColorPart: function() {
   return this.toPaddedString(2, 16);
 },
</PRE><PRE> succ: function() {
   return this + 1;
 },
</PRE><PRE> times: function(iterator) {
   $R(0, this, true).each(iterator);
   return this;
 },
</PRE><PRE> toPaddedString: function(length, radix) {
   var string = this.toString(radix || 10);
   return '0'.times(length - string.length) + string;
 },
</PRE><PRE> toJSON: function() {
   return isFinite(this) ? this.toString() : 'null';
 }
</PRE><P>});
</P><P>$w('abs round ceil floor').each(function(method){
</P><PRE> Number.prototype[method] = Math[method].methodize();
</PRE><P>});
function $H(object) {
</P><PRE> return new Hash(object);
</PRE><P>};
</P><P>var Hash = Class.create(Enumerable, (function() {
</P><PRE> function toQueryPair(key, value) {
   if (Object.isUndefined(value)) return key;
   return key + '=' + encodeURIComponent(String.interpret(value));
 }
</PRE><PRE> return {
   initialize: function(object) {
     this._object = Object.isHash(object) ? object.toObject() : Object.clone(object);
   },
</PRE><PRE>   _each: function(iterator) {
     for (var key in this._object) {
       var value = this._object[key], pair = [key, value];
       pair.key = key;
       pair.value = value;
       iterator(pair);
     }
   },
</PRE><PRE>   set: function(key, value) {
     return this._object[key] = value;
   },
</PRE><PRE>   get: function(key) {
     return this._object[key];
   },
</PRE><PRE>   unset: function(key) {
     var value = this._object[key];
     delete this._object[key];
     return value;
   },
</PRE><PRE>   toObject: function() {
     return Object.clone(this._object);
   },
</PRE><PRE>   keys: function() {
     return this.pluck('key');
   },
</PRE><PRE>   values: function() {
     return this.pluck('value');
   },
</PRE><PRE>   index: function(value) {
     var match = this.detect(function(pair) {
       return pair.value === value;
     });
     return match &amp;&amp; match.key;
   },
</PRE><PRE>   merge: function(object) {
     return this.clone().update(object);
   },
</PRE><PRE>   update: function(object) {
     return new Hash(object).inject(this, function(result, pair) {
       result.set(pair.key, pair.value);
       return result;
     });
   },
</PRE><PRE>   toQueryString: function() {
     return this.map(function(pair) {
       var key = encodeURIComponent(pair.key), values = pair.value;
</PRE><PRE>       if (values &amp;&amp; typeof values == 'object') {
         if (Object.isArray(values))
           return values.map(toQueryPair.curry(key)).join('&amp;');
       }
       return toQueryPair(key, values);
     }).join('&amp;');
   },
</PRE><PRE>   inspect: function() {
     return '#&lt;Hash:{' + this.map(function(pair) {
       return pair.map(Object.inspect).join(': ');
     }).join(', ') + '}&gt;';
   },
</PRE><PRE>   toJSON: function() {
     return Object.toJSON(this.toObject());
   },
</PRE><PRE>   clone: function() {
     return new Hash(this);
   }
 }
</PRE><P>})());
</P><P>Hash.prototype.toTemplateReplacements = Hash.prototype.toObject;
Hash.from = $H;
var ObjectRange = Class.create(Enumerable, {
</P><PRE> initialize: function(start, end, exclusive) {
   this.start = start;
   this.end = end;
   this.exclusive = exclusive;
 },
</PRE><PRE> _each: function(iterator) {
   var value = this.start;
   while (this.include(value)) {
     iterator(value);
     value = value.succ();
   }
 },
</PRE><PRE> include: function(value) {
   if (value &lt; this.start)
     return false;
   if (this.exclusive)
     return value &lt; this.end;
   return value &lt;= this.end;
 }
</PRE><P>});
</P><P>var $R = function(start, end, exclusive) {
</P><PRE> return new ObjectRange(start, end, exclusive);
</PRE><P>};
</P><P>var Ajax = {
</P><PRE> getTransport: function() {
   return Try.these(
     function() {return new XMLHttpRequest()},
     function() {return new ActiveXObject('Msxml2.XMLHTTP')},
     function() {return new ActiveXObject('Microsoft.XMLHTTP')}
   ) || false;
 },
</PRE><PRE> activeRequestCount: 0
</PRE><P>};
</P><P>Ajax.Responders = {
</P><PRE> responders: [],
</PRE><PRE> _each: function(iterator) {
   this.responders._each(iterator);
 },
</PRE><PRE> register: function(responder) {
   if (!this.include(responder))
     this.responders.push(responder);
 },
</PRE><PRE> unregister: function(responder) {
   this.responders = this.responders.without(responder);
 },
</PRE><PRE> dispatch: function(callback, request, transport, json) {
   this.each(function(responder) {
     if (Object.isFunction(responder[callback])) {
       try {
         responder[callback].apply(responder, [request, transport, json]);
       } catch (e) { }
     }
   });
 }
</PRE><P>};
</P><P>Object.extend(Ajax.Responders, Enumerable);
</P><P>Ajax.Responders.register({
</P><PRE> onCreate:   function() { Ajax.activeRequestCount++ },
 onComplete: function() { Ajax.activeRequestCount-- }
</PRE><P>});
</P><P>Ajax.Base = Class.create({
</P><PRE> initialize: function(options) {
   this.options = {
     method:       'post',
     asynchronous: true,
     contentType:  'application/x-www-form-urlencoded',
     encoding:     'UTF-8',
     parameters:   <I>,</I>
     evalJSON:     true,
     evalJS:       true
   };
   Object.extend(this.options, options || { });
</PRE><PRE>   this.options.method = this.options.method.toLowerCase();
</PRE><PRE>   if (Object.isString(this.options.parameters))
     this.options.parameters = this.options.parameters.toQueryParams();
   else if (Object.isHash(this.options.parameters))
     this.options.parameters = this.options.parameters.toObject();
 }
</PRE><P>});
</P><P>Ajax.Request = Class.create(Ajax.Base, {
</P><PRE> _complete: false,
</PRE><PRE> initialize: function($super, url, options) {
   $super(options);
   this.transport = Ajax.getTransport();
   this.request(url);
 },
</PRE><PRE> request: function(url) {
   this.url = url;
   this.method = this.options.method;
   var params = Object.clone(this.options.parameters);
</PRE><PRE>   if (!['get', 'post'].include(this.method)) {
     // simulate other verbs over post
     params['_method'] = this.method;
     this.method = 'post';
   }
</PRE><PRE>   this.parameters = params;
</PRE><PRE>   if (params = Object.toQueryString(params)) {
     // when GET, append parameters to URL
     if (this.method == 'get')
       this.url += (this.url.include('?') ? '&amp;' : '?') + params;
     else if (/Konqueror|Safari|KHTML/.test(navigator.userAgent))
       params += '&amp;_=';
   }
</PRE><PRE>   try {
     var response = new Ajax.Response(this);
     if (this.options.onCreate) this.options.onCreate(response);
     Ajax.Responders.dispatch('onCreate', this, response);
</PRE><PRE>     this.transport.open(this.method.toUpperCase(), this.url,
       this.options.asynchronous);
</PRE><PRE>     if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);
</PRE><PRE>     this.transport.onreadystatechange = this.onStateChange.bind(this);
     this.setRequestHeaders();
</PRE><PRE>     this.body = this.method == 'post' ? (this.options.postBody || params) : null;
     this.transport.send(this.body);
</PRE><PRE>     /* Force Firefox to handle ready state 4 for synchronous requests */
     if (!this.options.asynchronous &amp;&amp; this.transport.overrideMimeType)
       this.onStateChange();
</PRE><PRE>   }
   catch (e) {
     this.dispatchException(e);
   }
 },
</PRE><PRE> onStateChange: function() {
   var readyState = this.transport.readyState;
   if (readyState &gt; 1 &amp;&amp; !((readyState == 4) &amp;&amp; this._complete))
     this.respondToReadyState(this.transport.readyState);
 },
</PRE><PRE> setRequestHeaders: function() {
   var headers = {
     'X-Requested-With': 'XMLHttpRequest',
     'X-Prototype-Version': Prototype.Version,
     'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
   };
</PRE><PRE>   if (this.method == 'post') {
     headers['Content-type'] = this.options.contentType +
       (this.options.encoding ? '; charset=' + this.options.encoding : <I>);</I></PRE><PRE>     /* Force &quot;Connection: close&quot; for older Mozilla browsers to work
      * around a bug where XMLHttpRequest sends an incorrect
      * Content-length header. See Mozilla Bugzilla #246651.
      */
     if (this.transport.overrideMimeType &amp;&amp;
         (navigator.userAgent.match(/Gecko\/(\d{4})/) || [0,2005])[1] &lt; 2005)
           headers['Connection'] = 'close';
   }
</PRE><PRE>   // user-defined headers
   if (typeof this.options.requestHeaders == 'object') {
     var extras = this.options.requestHeaders;
</PRE><PRE>     if (Object.isFunction(extras.push))
       for (var i = 0, length = extras.length; i &lt; length; i += 2)
         headers[extras[i]] = extras[i+1];
     else
       $H(extras).each(function(pair) { headers[pair.key] = pair.value });
   }
</PRE><PRE>   for (var name in headers)
     this.transport.setRequestHeader(name, headers[name]);
 },
</PRE><PRE> success: function() {
   var status = this.getStatus();
   return !status || (status &gt;= 200 &amp;&amp; status &lt; 300);
 },
</PRE><PRE> getStatus: function() {
   try {
     return this.transport.status || 0;
   } catch (e) { return 0 }
 },
</PRE><PRE> respondToReadyState: function(readyState) {
   var state = Ajax.Request.Events[readyState], response = new Ajax.Response(this);
</PRE><PRE>   if (state == 'Complete') {
     try {
       this._complete = true;
       (this.options['on' + response.status]
        || this.options['on' + (this.success() ? 'Success' : 'Failure')]
        || Prototype.emptyFunction)(response, response.headerJSON);
     } catch (e) {
       this.dispatchException(e);
     }
</PRE><PRE>     var contentType = response.getHeader('Content-type');
     if (this.options.evalJS == 'force'
         || (this.options.evalJS &amp;&amp; this.isSameOrigin() &amp;&amp; contentType
         &amp;&amp; contentType.match(/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i)))
       this.evalResponse();
   }
</PRE><PRE>   try {
     (this.options['on' + state] || Prototype.emptyFunction)(response, response.headerJSON);
     Ajax.Responders.dispatch('on' + state, this, response, response.headerJSON);
   } catch (e) {
     this.dispatchException(e);
   }
</PRE><PRE>   if (state == 'Complete') {
     // avoid memory leak in MSIE: clean up
     this.transport.onreadystatechange = Prototype.emptyFunction;
   }
 },
</PRE><PRE> isSameOrigin: function() {
   var m = this.url.match(/^\s*https?:\/\/[^\/]*/);
   return !m || (m[0] == '#{protocol}//#{domain}#{port}'.interpolate({
     protocol: location.protocol,
     domain: document.domain,
     port: location.port ? ':' + location.port : 
   }));
 },
</PRE><PRE> getHeader: function(name) {
   try {
     return this.transport.getResponseHeader(name) || null;
   } catch (e) { return null }
 },
</PRE><PRE> evalResponse: function() {
   try {
     return eval((this.transport.responseText || <I>).unfilterJSON());</I>
   } catch (e) {
     this.dispatchException(e);
   }
 },
</PRE><PRE> dispatchException: function(exception) {
   (this.options.onException || Prototype.emptyFunction)(this, exception);
   Ajax.Responders.dispatch('onException', this, exception);
 }
</PRE><P>});
</P><P>Ajax.Request.Events =
</P><PRE> ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];
</PRE><P>Ajax.Response = Class.create({
</P><PRE> initialize: function(request){
   this.request = request;
   var transport  = this.transport  = request.transport,
       readyState = this.readyState = transport.readyState;
</PRE><PRE>   if((readyState &gt; 2 &amp;&amp; !Prototype.Browser.IE) || readyState == 4) {
     this.status       = this.getStatus();
     this.statusText   = this.getStatusText();
     this.responseText = String.interpret(transport.responseText);
     this.headerJSON   = this._getHeaderJSON();
   }
</PRE><PRE>   if(readyState == 4) {
     var xml = transport.responseXML;
     this.responseXML  = Object.isUndefined(xml) ? null : xml;
     this.responseJSON = this._getResponseJSON();
   }
 },
</PRE><PRE> status:      0,
 statusText: <I>,</I></PRE><PRE> getStatus: Ajax.Request.prototype.getStatus,
</PRE><PRE> getStatusText: function() {
   try {
     return this.transport.statusText || <I>;</I>
   } catch (e) { return <I> }</I>
 },
</PRE><PRE> getHeader: Ajax.Request.prototype.getHeader,
</PRE><PRE> getAllHeaders: function() {
   try {
     return this.getAllResponseHeaders();
   } catch (e) { return null }
 },
</PRE><PRE> getResponseHeader: function(name) {
   return this.transport.getResponseHeader(name);
 },
</PRE><PRE> getAllResponseHeaders: function() {
   return this.transport.getAllResponseHeaders();
 },
</PRE><PRE> _getHeaderJSON: function() {
   var json = this.getHeader('X-JSON');
   if (!json) return null;
   json = decodeURIComponent(escape(json));
   try {
     return json.evalJSON(this.request.options.sanitizeJSON ||
       !this.request.isSameOrigin());
   } catch (e) {
     this.request.dispatchException(e);
   }
 },
</PRE><PRE> _getResponseJSON: function() {
   var options = this.request.options;
   if (!options.evalJSON || (options.evalJSON != 'force' &amp;&amp; !(this.getHeader('Content-type') || <I>).include('application/json')) ||</I>
       this.responseText.blank())
         return null;
   try {
     return this.responseText.evalJSON(options.sanitizeJSON ||
       !this.request.isSameOrigin());
   } catch (e) {
     this.request.dispatchException(e);
   }
 }
</PRE><P>});
</P><P>Ajax.Updater = Class.create(Ajax.Request, {
</P><PRE> initialize: function($super, container, url, options) {
   this.container = {
     success: (container.success || container),
     failure: (container.failure || (container.success ? null : container))
   };
</PRE><PRE>   options = Object.clone(options);
   var onComplete = options.onComplete;
   options.onComplete = (function(response, json) {
     this.updateContent(response.responseText);
     if (Object.isFunction(onComplete)) onComplete(response, json);
   }).bind(this);
</PRE><PRE>   $super(url, options);
 },
</PRE><PRE> updateContent: function(responseText) {
   var receiver = this.container[this.success() ? 'success' : 'failure'],
       options = this.options;
</PRE><PRE>   if (!options.evalScripts) responseText = responseText.stripScripts();
</PRE><PRE>   if (receiver = $(receiver)) {
     if (options.insertion) {
       if (Object.isString(options.insertion)) {
         var insertion = { }; insertion[options.insertion] = responseText;
         receiver.insert(insertion);
       }
       else options.insertion(receiver, responseText);
     }
     else receiver.update(responseText);
   }
 }
</PRE><P>});
</P><P>Ajax.PeriodicalUpdater = Class.create(Ajax.Base, {
</P><PRE> initialize: function($super, container, url, options) {
   $super(options);
   this.onComplete = this.options.onComplete;
</PRE><PRE>   this.frequency = (this.options.frequency || 2);
   this.decay = (this.options.decay || 1);
</PRE><PRE>   this.updater = { };
   this.container = container;
   this.url = url;
</PRE><PRE>   this.start();
 },
</PRE><PRE> start: function() {
   this.options.onComplete = this.updateComplete.bind(this);
   this.onTimerEvent();
 },
</PRE><PRE> stop: function() {
   this.updater.options.onComplete = undefined;
   clearTimeout(this.timer);
   (this.onComplete || Prototype.emptyFunction).apply(this, arguments);
 },
</PRE><PRE> updateComplete: function(response) {
   if (this.options.decay) {
     this.decay = (response.responseText == this.lastText ?
       this.decay * this.options.decay : 1);
</PRE><PRE>     this.lastText = response.responseText;
   }
   this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);
 },
</PRE><PRE> onTimerEvent: function() {
   this.updater = new Ajax.Updater(this.container, this.url, this.options);
 }
</PRE><P>});
function $(element) {
</P><PRE> if (arguments.length &gt; 1) {
   for (var i = 0, elements = [], length = arguments.length; i &lt; length; i++)
     elements.push($(arguments[i]));
   return elements;
 }
 if (Object.isString(element))
   element = document.getElementById(element);
 return Element.extend(element);
</PRE><P>}
</P><P>if (Prototype.BrowserFeatures.XPath) {
</P><PRE> document._getElementsByXPath = function(expression, parentElement) {
   var results = [];
   var query = document.evaluate(expression, $(parentElement) || document,
     null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
   for (var i = 0, length = query.snapshotLength; i &lt; length; i++)
     results.push(Element.extend(query.snapshotItem(i)));
   return results;
 };
</PRE><P>}
</P><P>/*--------------------------------------------------------------------------*/
</P><P>if (!window.Node) var Node = { };
</P><P>if (!Node.ELEMENT_NODE) {
</P><PRE> // DOM level 2 ECMAScript Language Binding
 Object.extend(Node, {
   ELEMENT_NODE: 1,
   ATTRIBUTE_NODE: 2,
   TEXT_NODE: 3,
   CDATA_SECTION_NODE: 4,
   ENTITY_REFERENCE_NODE: 5,
   ENTITY_NODE: 6,
   PROCESSING_INSTRUCTION_NODE: 7,
   COMMENT_NODE: 8,
   DOCUMENT_NODE: 9,
   DOCUMENT_TYPE_NODE: 10,
   DOCUMENT_FRAGMENT_NODE: 11,
   NOTATION_NODE: 12
 });
</PRE><P>}
</P><P>(function() {
</P><PRE> var element = this.Element;
 this.Element = function(tagName, attributes) {
   attributes = attributes || { };
   tagName = tagName.toLowerCase();
   var cache = Element.cache;
   if (Prototype.Browser.IE &amp;&amp; attributes.name) {
     tagName = '&lt;' + tagName + ' name=&quot;' + attributes.name + '&quot;&gt;';
     delete attributes.name;
     return Element.writeAttribute(document.createElement(tagName), attributes);
   }
   if (!cache[tagName]) cache[tagName] = Element.extend(document.createElement(tagName));
   return Element.writeAttribute(cache[tagName].cloneNode(false), attributes);
 };
 Object.extend(this.Element, element || { });
</PRE><P>}).call(window);
</P><P>Element.cache = { };
</P><P>Element.Methods = {
</P><PRE> visible: function(element) {
   return $(element).style.display != 'none';
 },
</PRE><PRE> toggle: function(element) {
   element = $(element);
   Element[Element.visible(element) ? 'hide' : 'show'](element);
   return element;
 },
</PRE><PRE> hide: function(element) {
   $(element).style.display = 'none';
   return element;
 },
</PRE><PRE> show: function(element) {
   $(element).style.display = <I>;</I>
   return element;
 },
</PRE><PRE> remove: function(element) {
   element = $(element);
   element.parentNode.removeChild(element);
   return element;
 },
</PRE><PRE> update: function(element, content) {
   element = $(element);
   if (content &amp;&amp; content.toElement) content = content.toElement();
   if (Object.isElement(content)) return element.update().insert(content);
   content = Object.toHTML(content);
   element.innerHTML = content.stripScripts();
   content.evalScripts.bind(content).defer();
   return element;
 },
</PRE><PRE> replace: function(element, content) {
   element = $(element);
   if (content &amp;&amp; content.toElement) content = content.toElement();
   else if (!Object.isElement(content)) {
     content = Object.toHTML(content);
     var range = element.ownerDocument.createRange();
     range.selectNode(element);
     content.evalScripts.bind(content).defer();
     content = range.createContextualFragment(content.stripScripts());
   }
   element.parentNode.replaceChild(content, element);
   return element;
 },
</PRE><PRE> insert: function(element, insertions) {
   element = $(element);
</PRE><PRE>   if (Object.isString(insertions) || Object.isNumber(insertions) ||
       Object.isElement(insertions) || (insertions &amp;&amp; (insertions.toElement || insertions.toHTML)))
         insertions = {bottom:insertions};
</PRE><PRE>   var content, insert, tagName, childNodes;
</PRE><PRE>   for (var position in insertions) {
     content  = insertions[position];
     position = position.toLowerCase();
     insert = Element._insertionTranslations[position];
</PRE><PRE>     if (content &amp;&amp; content.toElement) content = content.toElement();
     if (Object.isElement(content)) {
       insert(element, content);
       continue;
     }
</PRE><PRE>     content = Object.toHTML(content);
</PRE><PRE>     tagName = ((position == 'before' || position == 'after')
       ? element.parentNode : element).tagName.toUpperCase();
</PRE><PRE>     childNodes = Element._getContentFromAnonymousElement(tagName, content.stripScripts());
</PRE><PRE>     if (position == 'top' || position == 'after') childNodes.reverse();
     childNodes.each(insert.curry(element));
</PRE><PRE>     content.evalScripts.bind(content).defer();
   }
</PRE><PRE>   return element;
 },
</PRE><PRE> wrap: function(element, wrapper, attributes) {
   element = $(element);
   if (Object.isElement(wrapper))
     $(wrapper).writeAttribute(attributes || { });
   else if (Object.isString(wrapper)) wrapper = new Element(wrapper, attributes);
   else wrapper = new Element('div', wrapper);
   if (element.parentNode)
     element.parentNode.replaceChild(wrapper, element);
   wrapper.appendChild(element);
   return wrapper;
 },
</PRE><PRE> inspect: function(element) {
   element = $(element);
   var result = '&lt;' + element.tagName.toLowerCase();
   $H({'id': 'id', 'className': 'class'}).each(function(pair) {
     var property = pair.first(), attribute = pair.last();
     var value = (element[property] || <I>).toString();</I>
     if (value) result += ' ' + attribute + '=' + value.inspect(true);
   });
   return result + '&gt;';
 },
</PRE><PRE> recursivelyCollect: function(element, property) {
   element = $(element);
   var elements = [];
   while (element = element[property])
     if (element.nodeType == 1)
       elements.push(Element.extend(element));
   return elements;
 },
</PRE><PRE> ancestors: function(element) {
   return $(element).recursivelyCollect('parentNode');
 },
</PRE><PRE> descendants: function(element) {
   return $(element).select(&quot;*&quot;);
 },
</PRE><PRE> firstDescendant: function(element) {
   element = $(element).firstChild;
   while (element &amp;&amp; element.nodeType != 1) element = element.nextSibling;
   return $(element);
 },
</PRE><PRE> immediateDescendants: function(element) {
   if (!(element = $(element).firstChild)) return [];
   while (element &amp;&amp; element.nodeType != 1) element = element.nextSibling;
   if (element) return [element].concat($(element).nextSiblings());
   return [];
 },
</PRE><PRE> previousSiblings: function(element) {
   return $(element).recursivelyCollect('previousSibling');
 },
</PRE><PRE> nextSiblings: function(element) {
   return $(element).recursivelyCollect('nextSibling');
 },
</PRE><PRE> siblings: function(element) {
   element = $(element);
   return element.previousSiblings().reverse().concat(element.nextSiblings());
 },
</PRE><PRE> match: function(element, selector) {
   if (Object.isString(selector))
     selector = new Selector(selector);
   return selector.match($(element));
 },
</PRE><PRE> up: function(element, expression, index) {
   element = $(element);
   if (arguments.length == 1) return $(element.parentNode);
   var ancestors = element.ancestors();
   return Object.isNumber(expression) ? ancestors[expression] :
     Selector.findElement(ancestors, expression, index);
 },
</PRE><PRE> down: function(element, expression, index) {
   element = $(element);
   if (arguments.length == 1) return element.firstDescendant();
   return Object.isNumber(expression) ? element.descendants()[expression] :
     element.select(expression)[index || 0];
 },
</PRE><PRE> previous: function(element, expression, index) {
   element = $(element);
   if (arguments.length == 1) return $(Selector.handlers.previousElementSibling(element));
   var previousSiblings = element.previousSiblings();
   return Object.isNumber(expression) ? previousSiblings[expression] :
     Selector.findElement(previousSiblings, expression, index);
 },
</PRE><PRE> next: function(element, expression, index) {
   element = $(element);
   if (arguments.length == 1) return $(Selector.handlers.nextElementSibling(element));
   var nextSiblings = element.nextSiblings();
   return Object.isNumber(expression) ? nextSiblings[expression] :
     Selector.findElement(nextSiblings, expression, index);
 },
</PRE><PRE> select: function() {
   var args = $A(arguments), element = $(args.shift());
   return Selector.findChildElements(element, args);
 },
</PRE><PRE> adjacent: function() {
   var args = $A(arguments), element = $(args.shift());
   return Selector.findChildElements(element.parentNode, args).without(element);
 },
</PRE><PRE> identify: function(element) {
   element = $(element);
   var id = element.readAttribute('id'), self = arguments.callee;
   if (id) return id;
   do { id = 'anonymous_element_' + self.counter++ } while ($(id));
   element.writeAttribute('id', id);
   return id;
 },
</PRE><PRE> readAttribute: function(element, name) {
   element = $(element);
   if (Prototype.Browser.IE) {
     var t = Element._attributeTranslations.read;
     if (t.values[name]) return t.values[name](element, name);
     if (t.names[name]) name = t.names[name];
     if (name.include(':')) {
       return (!element.attributes || !element.attributes[name]) ? null :
        element.attributes[name].value;
     }
   }
   return element.getAttribute(name);
 },
</PRE><PRE> writeAttribute: function(element, name, value) {
   element = $(element);
   var attributes = { }, t = Element._attributeTranslations.write;
</PRE><PRE>   if (typeof name == 'object') attributes = name;
   else attributes[name] = Object.isUndefined(value) ? true : value;
</PRE><PRE>   for (var attr in attributes) {
     name = t.names[attr] || attr;
     value = attributes[attr];
     if (t.values[attr]) name = t.values[attr](element, value);
     if (value === false || value === null)
       element.removeAttribute(name);
     else if (value === true)
       element.setAttribute(name, name);
     else element.setAttribute(name, value);
   }
   return element;
 },
</PRE><PRE> getHeight: function(element) {
   return $(element).getDimensions().height;
 },
</PRE><PRE> getWidth: function(element) {
   return $(element).getDimensions().width;
 },
</PRE><PRE> classNames: function(element) {
   return new Element.ClassNames(element);
 },
</PRE><PRE> hasClassName: function(element, className) {
   if (!(element = $(element))) return;
   var elementClassName = element.className;
   return (elementClassName.length &gt; 0 &amp;&amp; (elementClassName == className ||
     new RegExp(&quot;(^|\\s)&quot; + className + &quot;(\\s|$)&quot;).test(elementClassName)));
 },
</PRE><PRE> addClassName: function(element, className) {
   if (!(element = $(element))) return;
   if (!element.hasClassName(className))
     element.className += (element.className ? ' ' : <I>) + className;</I>
   return element;
 },
</PRE><PRE> removeClassName: function(element, className) {
   if (!(element = $(element))) return;
   element.className = element.className.replace(
     new RegExp(&quot;(^|\\s+)&quot; + className + &quot;(\\s+|$)&quot;), ' ').strip();
   return element;
 },
</PRE><PRE> toggleClassName: function(element, className) {
   if (!(element = $(element))) return;
   return element[element.hasClassName(className) ?
     'removeClassName' : 'addClassName'](className);
 },
</PRE><PRE> // removes whitespace-only text node children
 cleanWhitespace: function(element) {
   element = $(element);
   var node = element.firstChild;
   while (node) {
     var nextNode = node.nextSibling;
     if (node.nodeType == 3 &amp;&amp; !/\S/.test(node.nodeValue))
       element.removeChild(node);
     node = nextNode;
   }
   return element;
 },
</PRE><PRE> empty: function(element) {
   return $(element).innerHTML.blank();
 },
</PRE><PRE> descendantOf: function(element, ancestor) {
   element = $(element), ancestor = $(ancestor);
   var originalAncestor = ancestor;
</PRE><PRE>   if (element.compareDocumentPosition)
     return (element.compareDocumentPosition(ancestor) &amp; 8) === 8;
</PRE><PRE>   if (element.sourceIndex &amp;&amp; !Prototype.Browser.Opera) {
     var e = element.sourceIndex, a = ancestor.sourceIndex,
      nextAncestor = ancestor.nextSibling;
     if (!nextAncestor) {
       do { ancestor = ancestor.parentNode; }
       while (!(nextAncestor = ancestor.nextSibling) &amp;&amp; ancestor.parentNode);
     }
     if (nextAncestor &amp;&amp; nextAncestor.sourceIndex)
      return (e &gt; a &amp;&amp; e &lt; nextAncestor.sourceIndex);
   }
</PRE><PRE>   while (element = element.parentNode)
     if (element == originalAncestor) return true;
   return false;
 },
</PRE><PRE> scrollTo: function(element) {
   element = $(element);
   var pos = element.cumulativeOffset();
   window.scrollTo(pos[0], pos[1]);
   return element;
 },
</PRE><PRE> getStyle: function(element, style) {
   element = $(element);
   style = style == 'float' ? 'cssFloat' : style.camelize();
   var value = element.style[style];
   if (!value) {
     var css = document.defaultView.getComputedStyle(element, null);
     value = css ? css[style] : null;
   }
   if (style == 'opacity') return value ? parseFloat(value) : 1.0;
   return value == 'auto' ? null : value;
 },
</PRE><PRE> getOpacity: function(element) {
   return $(element).getStyle('opacity');
 },
</PRE><PRE> setStyle: function(element, styles) {
   element = $(element);
   var elementStyle = element.style, match;
   if (Object.isString(styles)) {
     element.style.cssText += ';' + styles;
     return styles.include('opacity') ?
       element.setOpacity(styles.match(/opacity:\s*(\d?\.?\d*)/)[1]) : element;
   }
   for (var property in styles)
     if (property == 'opacity') element.setOpacity(styles[property]);
     else
       elementStyle[(property == 'float' || property == 'cssFloat') ?
         (Object.isUndefined(elementStyle.styleFloat) ? 'cssFloat' : 'styleFloat') :
           property] = styles[property];
</PRE><PRE>   return element;
 },
</PRE><PRE> setOpacity: function(element, value) {
   element = $(element);
   element.style.opacity = (value == 1 || value === <I>) ? </I> :
     (value &lt; 0.00001) ? 0 : value;
   return element;
 },
</PRE><PRE> getDimensions: function(element) {
   element = $(element);
   var display = $(element).getStyle('display');
   if (display != 'none' &amp;&amp; display != null) // Safari bug
     return {width: element.offsetWidth, height: element.offsetHeight};
</PRE><PRE>   // All *Width and *Height properties give 0 on elements with display none,
   // so enable the element temporarily
   var els = element.style;
   var originalVisibility = els.visibility;
   var originalPosition = els.position;
   var originalDisplay = els.display;
   els.visibility = 'hidden';
   els.position = 'absolute';
   els.display = 'block';
   var originalWidth = element.clientWidth;
   var originalHeight = element.clientHeight;
   els.display = originalDisplay;
   els.position = originalPosition;
   els.visibility = originalVisibility;
   return {width: originalWidth, height: originalHeight};
 },
</PRE><PRE> makePositioned: function(element) {
   element = $(element);
   var pos = Element.getStyle(element, 'position');
   if (pos == 'static' || !pos) {
     element._madePositioned = true;
     element.style.position = 'relative';
     // Opera returns the offset relative to the positioning context, when an
     // element is position relative but top and left have not been defined
     if (window.opera) {
       element.style.top = 0;
       element.style.left = 0;
     }
   }
   return element;
 },
</PRE><PRE> undoPositioned: function(element) {
   element = $(element);
   if (element._madePositioned) {
     element._madePositioned = undefined;
     element.style.position =
       element.style.top =
       element.style.left =
       element.style.bottom =
       element.style.right = <I>;</I>
   }
   return element;
 },
</PRE><PRE> makeClipping: function(element) {
   element = $(element);
   if (element._overflow) return element;
   element._overflow = Element.getStyle(element, 'overflow') || 'auto';
   if (element._overflow !== 'hidden')
     element.style.overflow = 'hidden';
   return element;
 },
</PRE><PRE> undoClipping: function(element) {
   element = $(element);
   if (!element._overflow) return element;
   element.style.overflow = element._overflow == 'auto' ? <I> : element._overflow;</I>
   element._overflow = null;
   return element;
 },
</PRE><PRE> cumulativeOffset: function(element) {
   var valueT = 0, valueL = 0;
   do {
     valueT += element.offsetTop  || 0;
     valueL += element.offsetLeft || 0;
     element = element.offsetParent;
   } while (element);
   return Element._returnOffset(valueL, valueT);
 },
</PRE><PRE> positionedOffset: function(element) {
   var valueT = 0, valueL = 0;
   do {
     valueT += element.offsetTop  || 0;
     valueL += element.offsetLeft || 0;
     element = element.offsetParent;
     if (element) {
       if (element.tagName == 'BODY') break;
       var p = Element.getStyle(element, 'position');
       if (p !== 'static') break;
     }
   } while (element);
   return Element._returnOffset(valueL, valueT);
 },
</PRE><PRE> absolutize: function(element) {
   element = $(element);
   if (element.getStyle('position') == 'absolute') return;
   // Position.prepare(); // To be done manually by Scripty when it needs it.
</PRE><PRE>   var offsets = element.positionedOffset();
   var top     = offsets[1];
   var left    = offsets[0];
   var width   = element.clientWidth;
   var height  = element.clientHeight;
</PRE><PRE>   element._originalLeft   = left - parseFloat(element.style.left  || 0);
   element._originalTop    = top  - parseFloat(element.style.top || 0);
   element._originalWidth  = element.style.width;
   element._originalHeight = element.style.height;
</PRE><PRE>   element.style.position = 'absolute';
   element.style.top    = top + 'px';
   element.style.left   = left + 'px';
   element.style.width  = width + 'px';
   element.style.height = height + 'px';
   return element;
 },
</PRE><PRE> relativize: function(element) {
   element = $(element);
   if (element.getStyle('position') == 'relative') return;
   // Position.prepare(); // To be done manually by Scripty when it needs it.
</PRE><PRE>   element.style.position = 'relative';
   var top  = parseFloat(element.style.top  || 0) - (element._originalTop || 0);
   var left = parseFloat(element.style.left || 0) - (element._originalLeft || 0);
</PRE><PRE>   element.style.top    = top + 'px';
   element.style.left   = left + 'px';
   element.style.height = element._originalHeight;
   element.style.width  = element._originalWidth;
   return element;
 },
</PRE><PRE> cumulativeScrollOffset: function(element) {
   var valueT = 0, valueL = 0;
   do {
     valueT += element.scrollTop  || 0;
     valueL += element.scrollLeft || 0;
     element = element.parentNode;
   } while (element);
   return Element._returnOffset(valueL, valueT);
 },
</PRE><PRE> getOffsetParent: function(element) {
   if (element.offsetParent) return $(element.offsetParent);
   if (element == document.body) return $(element);
</PRE><PRE>   while ((element = element.parentNode) &amp;&amp; element != document.body)
     if (Element.getStyle(element, 'position') != 'static')
       return $(element);
</PRE><PRE>   return $(document.body);
 },
</PRE><PRE> viewportOffset: function(forElement) {
   var valueT = 0, valueL = 0;
</PRE><PRE>   var element = forElement;
   do {
     valueT += element.offsetTop  || 0;
     valueL += element.offsetLeft || 0;
</PRE><PRE>     // Safari fix
     if (element.offsetParent == document.body &amp;&amp;
       Element.getStyle(element, 'position') == 'absolute') break;
</PRE><PRE>   } while (element = element.offsetParent);
</PRE><PRE>   element = forElement;
   do {
     if (!Prototype.Browser.Opera || element.tagName == 'BODY') {
       valueT -= element.scrollTop  || 0;
       valueL -= element.scrollLeft || 0;
     }
   } while (element = element.parentNode);
</PRE><PRE>   return Element._returnOffset(valueL, valueT);
 },
</PRE><PRE> clonePosition: function(element, source) {
   var options = Object.extend({
     setLeft:    true,
     setTop:     true,
     setWidth:   true,
     setHeight:  true,
     offsetTop:  0,
     offsetLeft: 0
   }, arguments[2] || { });
</PRE><PRE>   // find page position of source
   source = $(source);
   var p = source.viewportOffset();
</PRE><PRE>   // find coordinate system to use
   element = $(element);
   var delta = [0, 0];
   var parent = null;
   // delta [0,0] will do fine with position: fixed elements,
   // position:absolute needs offsetParent deltas
   if (Element.getStyle(element, 'position') == 'absolute') {
     parent = element.getOffsetParent();
     delta = parent.viewportOffset();
   }
</PRE><PRE>   // correct by body offsets (fixes Safari)
   if (parent == document.body) {
     delta[0] -= document.body.offsetLeft;
     delta[1] -= document.body.offsetTop;
   }
</PRE><PRE>   // set position
   if (options.setLeft)   element.style.left  = (p[0] - delta[0] + options.offsetLeft) + 'px';
   if (options.setTop)    element.style.top   = (p[1] - delta[1] + options.offsetTop) + 'px';
   if (options.setWidth)  element.style.width = source.offsetWidth + 'px';
   if (options.setHeight) element.style.height = source.offsetHeight + 'px';
   return element;
 }
</PRE><P>};
</P><P>Element.Methods.identify.counter = 1;
</P><P>Object.extend(Element.Methods, {
</P><PRE> getElementsBySelector: Element.Methods.select,
 childElements: Element.Methods.immediateDescendants
</PRE><P>});
</P><P>Element._attributeTranslations = {
</P><PRE> write: {
   names: {
     className: 'class',
     htmlFor:   'for'
   },
   values: { }
 }
</PRE><P>};
</P><P>if (Prototype.Browser.Opera) {
</P><PRE> Element.Methods.getStyle = Element.Methods.getStyle.wrap(
   function(proceed, element, style) {
     switch (style) {
       case 'left': case 'top': case 'right': case 'bottom':
         if (proceed(element, 'position') === 'static') return null;
       case 'height': case 'width':
         // returns '0px' for hidden elements; we want it to return null
         if (!Element.visible(element)) return null;
</PRE><PRE>         // returns the border-box dimensions rather than the content-box
         // dimensions, so we subtract padding and borders from the value
         var dim = parseInt(proceed(element, style), 10);
</PRE><PRE>         if (dim !== element['offset' + style.capitalize()])
           return dim + 'px';
</PRE><PRE>         var properties;
         if (style === 'height') {
           properties = ['border-top-width', 'padding-top',
            'padding-bottom', 'border-bottom-width'];
         }
         else {
           properties = ['border-left-width', 'padding-left',
            'padding-right', 'border-right-width'];
         }
         return properties.inject(dim, function(memo, property) {
           var val = proceed(element, property);
           return val === null ? memo : memo - parseInt(val, 10);
         }) + 'px';
       default: return proceed(element, style);
     }
   }
 );
</PRE><PRE> Element.Methods.readAttribute = Element.Methods.readAttribute.wrap(
   function(proceed, element, attribute) {
     if (attribute === 'title') return element.title;
     return proceed(element, attribute);
   }
 );
</PRE><P>}
</P><P>else if (Prototype.Browser.IE) {
</P><PRE> // IE doesn't report offsets correctly for static elements, so we change them
 // to &quot;relative&quot; to get the values, then change them back.
 Element.Methods.getOffsetParent = Element.Methods.getOffsetParent.wrap(
   function(proceed, element) {
     element = $(element);
     var position = element.getStyle('position');
     if (position !== 'static') return proceed(element);
     element.setStyle({ position: 'relative' });
     var value = proceed(element);
     element.setStyle({ position: position });
     return value;
   }
 );
</PRE><PRE> $w('positionedOffset viewportOffset').each(function(method) {
   Element.Methods[method] = Element.Methods[method].wrap(
     function(proceed, element) {
       element = $(element);
       var position = element.getStyle('position');
       if (position !== 'static') return proceed(element);
       // Trigger hasLayout on the offset parent so that IE6 reports
       // accurate offsetTop and offsetLeft values for position: fixed.
       var offsetParent = element.getOffsetParent();
       if (offsetParent &amp;&amp; offsetParent.getStyle('position') === 'fixed')
         offsetParent.setStyle({ zoom: 1 });
       element.setStyle({ position: 'relative' });
       var value = proceed(element);
       element.setStyle({ position: position });
       return value;
     }
   );
 });
</PRE><PRE> Element.Methods.getStyle = function(element, style) {
   element = $(element);
   style = (style == 'float' || style == 'cssFloat') ? 'styleFloat' : style.camelize();
   var value = element.style[style];
   if (!value &amp;&amp; element.currentStyle) value = element.currentStyle[style];
</PRE><PRE>   if (style == 'opacity') {
     if (value = (element.getStyle('filter') || <I>).match(/alpha\(opacity=(.*)\)/))</I>
       if (value[1]) return parseFloat(value[1]) / 100;
     return 1.0;
   }
</PRE><PRE>   if (value == 'auto') {
     if ((style == 'width' || style == 'height') &amp;&amp; (element.getStyle('display') != 'none'))
       return element['offset' + style.capitalize()] + 'px';
     return null;
   }
   return value;
 };
</PRE><PRE> Element.Methods.setOpacity = function(element, value) {
   function stripAlpha(filter){
     return filter.replace(/alpha\([^\)]*\)/gi,<I>);</I>
   }
   element = $(element);
   var currentStyle = element.currentStyle;
   if ((currentStyle &amp;&amp; !currentStyle.hasLayout) ||
     (!currentStyle &amp;&amp; element.style.zoom == 'normal'))
       element.style.zoom = 1;
</PRE><PRE>   var filter = element.getStyle('filter'), style = element.style;
   if (value == 1 || value === <I>) {</I>
     (filter = stripAlpha(filter)) ?
       style.filter = filter : style.removeAttribute('filter');
     return element;
   } else if (value &lt; 0.00001) value = 0;
   style.filter = stripAlpha(filter) +
     'alpha(opacity=' + (value * 100) + ')';
   return element;
 };
</PRE><PRE> Element._attributeTranslations = {
   read: {
     names: {
       'class': 'className',
       'for':   'htmlFor'
     },
     values: {
       _getAttr: function(element, attribute) {
         return element.getAttribute(attribute, 2);
       },
       _getAttrNode: function(element, attribute) {
         var node = element.getAttributeNode(attribute);
         return node ? node.value : &quot;&quot;;
       },
       _getEv: function(element, attribute) {
         attribute = element.getAttribute(attribute);
         return attribute ? attribute.toString().slice(23, -2) : null;
       },
       _flag: function(element, attribute) {
         return $(element).hasAttribute(attribute) ? attribute : null;
       },
       style: function(element) {
         return element.style.cssText.toLowerCase();
       },
       title: function(element) {
         return element.title;
       }
     }
   }
 };
</PRE><PRE> Element._attributeTranslations.write = {
   names: Object.extend({
     cellpadding: 'cellPadding',
     cellspacing: 'cellSpacing'
   }, Element._attributeTranslations.read.names),
   values: {
     checked: function(element, value) {
       element.checked = !!value;
     },
</PRE><PRE>     style: function(element, value) {
       element.style.cssText = value ? value : <I>;</I>
     }
   }
 };
</PRE><PRE> Element._attributeTranslations.has = {};
</PRE><PRE> $w('colSpan rowSpan vAlign dateTime accessKey tabIndex ' +
     'encType maxLength readOnly longDesc').each(function(attr) {
   Element._attributeTranslations.write.names[attr.toLowerCase()] = attr;
   Element._attributeTranslations.has[attr.toLowerCase()] = attr;
 });
</PRE><PRE> (function(v) {
   Object.extend(v, {
     href:        v._getAttr,
     src:         v._getAttr,
     type:        v._getAttr,
     action:      v._getAttrNode,
     disabled:    v._flag,
     checked:     v._flag,
     readonly:    v._flag,
     multiple:    v._flag,
     onload:      v._getEv,
     onunload:    v._getEv,
     onclick:     v._getEv,
     ondblclick:  v._getEv,
     onmousedown: v._getEv,
     onmouseup:   v._getEv,
     onmouseover: v._getEv,
     onmousemove: v._getEv,
     onmouseout:  v._getEv,
     onfocus:     v._getEv,
     onblur:      v._getEv,
     onkeypress:  v._getEv,
     onkeydown:   v._getEv,
     onkeyup:     v._getEv,
     onsubmit:    v._getEv,
     onreset:     v._getEv,
     onselect:    v._getEv,
     onchange:    v._getEv
   });
 })(Element._attributeTranslations.read.values);
</PRE><P>}
</P><P>else if (Prototype.Browser.Gecko &amp;&amp; /rv:1\.8\.0/.test(navigator.userAgent)) {
</P><PRE> Element.Methods.setOpacity = function(element, value) {
   element = $(element);
   element.style.opacity = (value == 1) ? 0.999999 :
     (value === <I>) ? </I> : (value &lt; 0.00001) ? 0 : value;
   return element;
 };
</PRE><P>}
</P><P>else if (Prototype.Browser.WebKit) {
</P><PRE> Element.Methods.setOpacity = function(element, value) {
   element = $(element);
   element.style.opacity = (value == 1 || value === <I>) ? </I> :
     (value &lt; 0.00001) ? 0 : value;
</PRE><PRE>   if (value == 1)
     if(element.tagName == 'IMG' &amp;&amp; element.width) {
       element.width++; element.width--;
     } else try {
       var n = document.createTextNode(' ');
       element.appendChild(n);
       element.removeChild(n);
     } catch (e) { }
</PRE><PRE>   return element;
 };
</PRE><PRE> // Safari returns margins on body which is incorrect if the child is absolutely
 // positioned.  For performance reasons, redefine Element#cumulativeOffset for
 // KHTML/WebKit only.
 Element.Methods.cumulativeOffset = function(element) {
   var valueT = 0, valueL = 0;
   do {
     valueT += element.offsetTop  || 0;
     valueL += element.offsetLeft || 0;
     if (element.offsetParent == document.body)
       if (Element.getStyle(element, 'position') == 'absolute') break;
</PRE><PRE>     element = element.offsetParent;
   } while (element);
</PRE><PRE>   return Element._returnOffset(valueL, valueT);
 };
</PRE><P>}
</P><P>if (Prototype.Browser.IE || Prototype.Browser.Opera) {
</P><PRE> // IE and Opera are missing .innerHTML support for TABLE-related and SELECT elements
 Element.Methods.update = function(element, content) {
   element = $(element);
</PRE><PRE>   if (content &amp;&amp; content.toElement) content = content.toElement();
   if (Object.isElement(content)) return element.update().insert(content);
</PRE><PRE>   content = Object.toHTML(content);
   var tagName = element.tagName.toUpperCase();</PRE><PRE>   if (tagName in Element._insertionTranslations.tags) {
     $A(element.childNodes).each(function(node) { element.removeChild(node) });
     Element._getContentFromAnonymousElement(tagName, content.stripScripts())
       .each(function(node) { element.appendChild(node) });
   }
   else element.innerHTML = content.stripScripts();
</PRE><PRE>   content.evalScripts.bind(content).defer();
   return element;
 };
</PRE><P>}
</P><P>if ('outerHTML' in document.createElement('div')) {
</P><PRE> Element.Methods.replace = function(element, content) {
   element = $(element);
</PRE><PRE>   if (content &amp;&amp; content.toElement) content = content.toElement();
   if (Object.isElement(content)) {
     element.parentNode.replaceChild(content, element);
     return element;
   }
</PRE><PRE>   content = Object.toHTML(content);
   var parent = element.parentNode, tagName = parent.tagName.toUpperCase();
</PRE><PRE>   if (Element._insertionTranslations.tags[tagName]) {
     var nextSibling = element.next();
     var fragments = Element._getContentFromAnonymousElement(tagName, content.stripScripts());
     parent.removeChild(element);
     if (nextSibling)
       fragments.each(function(node) { parent.insertBefore(node, nextSibling) });
     else
       fragments.each(function(node) { parent.appendChild(node) });
   }
   else element.outerHTML = content.stripScripts();
</PRE><PRE>   content.evalScripts.bind(content).defer();
   return element;
 };
</PRE><P>}
</P><P>Element._returnOffset = function(l, t) {
</P><PRE> var result = [l, t];
 result.left = l;
 result.top = t;
 return result;
</PRE><P>};
</P><P>Element._getContentFromAnonymousElement = function(tagName, html) {
</P><PRE> var div = new Element('div'), t = Element._insertionTranslations.tags[tagName];
 if (t) {
   div.innerHTML = t[0] + html + t[1];
   t[2].times(function() { div = div.firstChild });
 } else div.innerHTML = html;
 return $A(div.childNodes);
</PRE><P>};
</P><P>Element._insertionTranslations = {
</P><PRE> before: function(element, node) {
   element.parentNode.insertBefore(node, element);
 },
 top: function(element, node) {
   element.insertBefore(node, element.firstChild);
 },
 bottom: function(element, node) {
   element.appendChild(node);
 },
 after: function(element, node) {
   element.parentNode.insertBefore(node, element.nextSibling);
 },
 tags: {
</PRE>
    TABLE:  ['<TABLE>',                '</TABLE>',                   1],
    TBODY:  ['<TABLE>&lt;tbody&gt;',         '&lt;/tbody&gt;</TABLE>',           2],
    TR:     ['<TABLE>&lt;tbody&gt;<TBODY><TR>',     '</TR>&lt;/tbody&gt;</TBODY></TABLE>',      3],
    TD:     ['<TABLE>&lt;tbody&gt;<TBODY><TR><TD>', '</TD></TR>&lt;/tbody&gt;</TBODY></TABLE>', 4],
<PRE>   SELECT: ['&lt;select&gt;',               '&lt;/select&gt;',                  1]
 }
</PRE><P>};
</P><P>(function() {
</P><PRE> Object.extend(this.tags, {
   THEAD: this.tags.TBODY,
   TFOOT: this.tags.TBODY,
   TH:    this.tags.TD
 });
</PRE><P>}).call(Element._insertionTranslations);
</P><P>Element.Methods.Simulated = {
</P><PRE> hasAttribute: function(element, attribute) {
   attribute = Element._attributeTranslations.has[attribute] || attribute;
   var node = $(element).getAttributeNode(attribute);
   return node &amp;&amp; node.specified;
 }
</PRE><P>};
</P><P>Element.Methods.ByTag = { };
</P><P>Object.extend(Element, Element.Methods);
</P><P>if (!Prototype.BrowserFeatures.ElementExtensions &amp;&amp;</P><PRE>   document.createElement('div').__proto__) {
 window.HTMLElement = { };
 window.HTMLElement.prototype = document.createElement('div').__proto__;
 Prototype.BrowserFeatures.ElementExtensions = true;
</PRE><P>}
</P><P>Element.extend = (function() {
</P><PRE> if (Prototype.BrowserFeatures.SpecificElementExtensions)
   return Prototype.K;
</PRE><PRE> var Methods = { }, ByTag = Element.Methods.ByTag;
</PRE><PRE> var extend = Object.extend(function(element) {
   if (!element || element._extendedByPrototype ||
       element.nodeType != 1 || element == window) return element;
</PRE><PRE>   var methods = Object.clone(Methods),
     tagName = element.tagName, property, value;
</PRE><PRE>   // extend methods for specific tags
   if (ByTag[tagName]) Object.extend(methods, ByTag[tagName]);
</PRE><PRE>   for (property in methods) {
     value = methods[property];
     if (Object.isFunction(value) &amp;&amp; !(property in element))
       element[property] = value.methodize();
   }
</PRE><PRE>   element._extendedByPrototype = Prototype.emptyFunction;
   return element;
</PRE><PRE> }, {
   refresh: function() {
     // extend methods for all tags (Safari doesn't need this)
     if (!Prototype.BrowserFeatures.ElementExtensions) {
       Object.extend(Methods, Element.Methods);
       Object.extend(Methods, Element.Methods.Simulated);
     }
   }
 });
</PRE><PRE> extend.refresh();
 return extend;
</PRE><P>})();
</P><P>Element.hasAttribute = function(element, attribute) {
</P><PRE> if (element.hasAttribute) return element.hasAttribute(attribute);
 return Element.Methods.Simulated.hasAttribute(element, attribute);
</PRE><P>};
</P><P>Element.addMethods = function(methods) {
</P><PRE> var F = Prototype.BrowserFeatures, T = Element.Methods.ByTag;
</PRE><PRE> if (!methods) {
   Object.extend(Form, Form.Methods);
   Object.extend(Form.Element, Form.Element.Methods);
   Object.extend(Element.Methods.ByTag, {
     &quot;FORM&quot;:     Object.clone(Form.Methods),
     &quot;INPUT&quot;:    Object.clone(Form.Element.Methods),
     &quot;SELECT&quot;:   Object.clone(Form.Element.Methods),
     &quot;TEXTAREA&quot;: Object.clone(Form.Element.Methods)
   });
 }
</PRE><PRE> if (arguments.length == 2) {
   var tagName = methods;
   methods = arguments[1];
 }
</PRE><PRE> if (!tagName) Object.extend(Element.Methods, methods || { });
 else {
   if (Object.isArray(tagName)) tagName.each(extend);
   else extend(tagName);
 }
</PRE><PRE> function extend(tagName) {
   tagName = tagName.toUpperCase();
   if (!Element.Methods.ByTag[tagName])
     Element.Methods.ByTag[tagName] = { };
   Object.extend(Element.Methods.ByTag[tagName], methods);
 }
</PRE><PRE> function copy(methods, destination, onlyIfAbsent) {
   onlyIfAbsent = onlyIfAbsent || false;
   for (var property in methods) {
     var value = methods[property];
     if (!Object.isFunction(value)) continue;
     if (!onlyIfAbsent || !(property in destination))
       destination[property] = value.methodize();
   }
 }
</PRE><PRE> function findDOMClass(tagName) {
   var klass;
   var trans = {
     &quot;OPTGROUP&quot;: &quot;OptGroup&quot;, &quot;TEXTAREA&quot;: &quot;TextArea&quot;, &quot;P&quot;: &quot;Paragraph&quot;,
     &quot;FIELDSET&quot;: &quot;FieldSet&quot;, &quot;UL&quot;: &quot;UList&quot;, &quot;OL&quot;: &quot;OList&quot;, &quot;DL&quot;: &quot;DList&quot;,
     &quot;DIR&quot;: &quot;Directory&quot;, &quot;H1&quot;: &quot;Heading&quot;, &quot;H2&quot;: &quot;Heading&quot;, &quot;H3&quot;: &quot;Heading&quot;,
     &quot;H4&quot;: &quot;Heading&quot;, &quot;H5&quot;: &quot;Heading&quot;, &quot;H6&quot;: &quot;Heading&quot;, &quot;Q&quot;: &quot;Quote&quot;,
     &quot;INS&quot;: &quot;Mod&quot;, &quot;DEL&quot;: &quot;Mod&quot;, &quot;A&quot;: &quot;Anchor&quot;, &quot;IMG&quot;: &quot;Image&quot;, &quot;CAPTION&quot;:
     &quot;TableCaption&quot;, &quot;COL&quot;: &quot;TableCol&quot;, &quot;COLGROUP&quot;: &quot;TableCol&quot;, &quot;THEAD&quot;:
     &quot;TableSection&quot;, &quot;TFOOT&quot;: &quot;TableSection&quot;, &quot;TBODY&quot;: &quot;TableSection&quot;, &quot;TR&quot;:
     &quot;TableRow&quot;, &quot;TH&quot;: &quot;TableCell&quot;, &quot;TD&quot;: &quot;TableCell&quot;, &quot;FRAMESET&quot;:
     &quot;FrameSet&quot;, &quot;IFRAME&quot;: &quot;IFrame&quot;
   };
   if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
   if (window[klass]) return window[klass];
   klass = 'HTML' + tagName + 'Element';
   if (window[klass]) return window[klass];
   klass = 'HTML' + tagName.capitalize() + 'Element';
   if (window[klass]) return window[klass];
</PRE><PRE>   window[klass] = { };
   window[klass].prototype = document.createElement(tagName).__proto__;
   return window[klass];
 }
</PRE><PRE> if (F.ElementExtensions) {
   copy(Element.Methods, HTMLElement.prototype);
   copy(Element.Methods.Simulated, HTMLElement.prototype, true);
 }
</PRE><PRE> if (F.SpecificElementExtensions) {
   for (var tag in Element.Methods.ByTag) {
     var klass = findDOMClass(tag);
     if (Object.isUndefined(klass)) continue;
     copy(T[tag], klass.prototype);
   }
 }
</PRE><PRE> Object.extend(Element, Element.Methods);
 delete Element.ByTag;
</PRE><PRE> if (Element.extend.refresh) Element.extend.refresh();
 Element.cache = { };
</PRE><P>};
</P><P>document.viewport = {
</P><PRE> getDimensions: function() {
   var dimensions = { };
   var B = Prototype.Browser;
   $w('width height').each(function(d) {
     var D = d.capitalize();
     dimensions[d] = (B.WebKit &amp;&amp; !document.evaluate) ? self['inner' + D] :
       (B.Opera) ? document.body['client' + D] : document.documentElement['client' + D];
   });
   return dimensions;
 },
</PRE><PRE> getWidth: function() {
   return this.getDimensions().width;
 },
</PRE><PRE> getHeight: function() {
   return this.getDimensions().height;
 },
</PRE><PRE> getScrollOffsets: function() {
   return Element._returnOffset(
     window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,
     window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
 }
</PRE><P>};
/* Portions of the Selector class are derived from Jack Slocumâ€™s DomQuery,
</P><PRE>* part of YUI-Ext version 0.40, distributed under the terms of an MIT-style
* license.  Please see <A href="http://www.yui-ext.com/" class="external free" rel="nofollow">http://www.yui-ext.com/</A> for more information. */
</PRE><P>var Selector = Class.create({
</P><PRE> initialize: function(expression) {
   this.expression = expression.strip();
   this.compileMatcher();
 },
</PRE><PRE> shouldUseXPath: function() {
   if (!Prototype.BrowserFeatures.XPath) return false;
</PRE><PRE>   var e = this.expression;
</PRE><PRE>   // Safari 3 chokes on :*-of-type and :empty
   if (Prototype.Browser.WebKit &amp;&amp;
    (e.include(&quot;-of-type&quot;) || e.include(&quot;:empty&quot;)))
     return false;
</PRE><PRE>   // XPath can't do namespaced attributes, nor can it read
   // the &quot;checked&quot; property from DOM nodes
   if ((/(\[[\w-]*?:|:checked)/).test(this.expression))
     return false;
</PRE><PRE>   return true;
 },
</PRE><PRE> compileMatcher: function() {
   if (this.shouldUseXPath())
     return this.compileXPathMatcher();
</PRE><PRE>   var e = this.expression, ps = Selector.patterns, h = Selector.handlers,
       c = Selector.criteria, le, p, m;
</PRE><PRE>   if (Selector._cache[e]) {
     this.matcher = Selector._cache[e];
     return;
   }
</PRE><PRE>   this.matcher = [&quot;this.matcher = function(root) {&quot;,
                   &quot;var r = root, h = Selector.handlers, c = false, n;&quot;];
</PRE><PRE>   while (e &amp;&amp; le != e &amp;&amp; (/\S/).test(e)) {
     le = e;
     for (var i in ps) {
       p = ps[i];
       if (m = e.match(p)) {
         this.matcher.push(Object.isFunction(c[i]) ? c[i](m) :
   	      new Template(c[i]).evaluate(m));
         e = e.replace(m[0], <I>);</I>
         break;
       }
     }
   }
</PRE><PRE>   this.matcher.push(&quot;return h.unique(n);\n}&quot;);
   eval(this.matcher.join('\n'));
   Selector._cache[this.expression] = this.matcher;
 },
</PRE><PRE> compileXPathMatcher: function() {
   var e = this.expression, ps = Selector.patterns,
       x = Selector.xpath, le, m;
</PRE><PRE>   if (Selector._cache[e]) {
     this.xpath = Selector._cache[e]; return;
   }
</PRE><PRE>   this.matcher = ['.//*'];
   while (e &amp;&amp; le != e &amp;&amp; (/\S/).test(e)) {
     le = e;
     for (var i in ps) {
       if (m = e.match(ps[i])) {
         this.matcher.push(Object.isFunction(x[i]) ? x[i](m) :
           new Template(x[i]).evaluate(m));
         e = e.replace(m[0], <I>);</I>
         break;
       }
     }
   }
</PRE><PRE>   this.xpath = this.matcher.join(<I>);</I>
   Selector._cache[this.expression] = this.xpath;
 },
</PRE><PRE> findElements: function(root) {
   root = root || document;
   if (this.xpath) return document._getElementsByXPath(this.xpath, root);
   return this.matcher(root);
 },
</PRE><PRE> match: function(element) {
   this.tokens = [];
</PRE><PRE>   var e = this.expression, ps = Selector.patterns, as = Selector.assertions;
   var le, p, m;
</PRE><PRE>   while (e &amp;&amp; le !== e &amp;&amp; (/\S/).test(e)) {
     le = e;
     for (var i in ps) {
       p = ps[i];
       if (m = e.match(p)) {
         // use the Selector.assertions methods unless the selector
         // is too complex.
         if (as[i]) {
           this.tokens.push([i, Object.clone(m)]);
           e = e.replace(m[0], <I>);</I>
         } else {
           // reluctantly do a document-wide search
           // and look for a match in the array
           return this.findElements(document).include(element);
         }
       }
     }
   }
</PRE><PRE>   var match = true, name, matches;
   for (var i = 0, token; token = this.tokens[i]; i++) {
     name = token[0], matches = token[1];
     if (!Selector.assertions[name](element, matches)) {
       match = false; break;
     }
   }
</PRE><PRE>   return match;
 },
</PRE><PRE> toString: function() {
   return this.expression;
 },
</PRE><PRE> inspect: function() {
   return &quot;#&lt;Selector:&quot; + this.expression.inspect() + &quot;&gt;&quot;;
 }
</PRE><P>});
</P><P>Object.extend(Selector, {
</P><PRE> _cache: { },
</PRE><PRE> xpath: {
   descendant:   &quot;//*&quot;,
   child:        &quot;/*&quot;,
   adjacent:     &quot;/following-sibling::*[1]&quot;,
   laterSibling: '/following-sibling::*',
   tagName:      function(m) {
     if (m[1] == '*') return <I>;</I>
     return &quot;[local-name()='&quot; + m[1].toLowerCase() +
            &quot;' or local-name()='&quot; + m[1].toUpperCase() + &quot;']&quot;;
   },
   className:    &quot;[contains(concat(' ', @class, ' '), ' #{1} ')]&quot;,
   id:           &quot;[@id='#{1}']&quot;,
   attrPresence: function(m) {
     m[1] = m[1].toLowerCase();
     return new Template(&quot;[@#{1}]&quot;).evaluate(m);
   },
   attr: function(m) {
     m[1] = m[1].toLowerCase();
     m[3] = m[5] || m[6];
     return new Template(Selector.xpath.operators[m[2]]).evaluate(m);
   },
   pseudo: function(m) {
     var h = Selector.xpath.pseudos[m[1]];
     if (!h) return <I>;</I>
     if (Object.isFunction(h)) return h(m);
     return new Template(Selector.xpath.pseudos[m[1]]).evaluate(m);
   },
   operators: {
     '=':  &quot;[@#{1}='#{3}']&quot;,
     '!=': &quot;[@#{1}!='#{3}']&quot;,
     '^=': &quot;[starts-with(@#{1}, '#{3}')]&quot;,
     '$=': &quot;[substring(@#{1}, (string-length(@#{1}) - string-length('#{3}') + 1))='#{3}']&quot;,
     '*=': &quot;[contains(@#{1}, '#{3}')]&quot;,
     '~=': &quot;[contains(concat(' ', @#{1}, ' '), ' #{3} ')]&quot;,
     '|=': &quot;[contains(concat('-', @#{1}, '-'), '-#{3}-')]&quot;
   },
   pseudos: {
     'first-child': '[not(preceding-sibling::*)]',
     'last-child':  '[not(following-sibling::*)]',
     'only-child':  '[not(preceding-sibling::* or following-sibling::*)]',
     'empty':       &quot;[count(*) = 0 and (count(text()) = 0 or translate(text(), ' \t\r\n', <I>) = </I>)]&quot;,
     'checked':     &quot;[@checked]&quot;,
     'disabled':    &quot;[@disabled]&quot;,
     'enabled':     &quot;[not(@disabled)]&quot;,
     'not': function(m) {
       var e = m[6], p = Selector.patterns,
           x = Selector.xpath, le, v;
</PRE><PRE>       var exclusion = [];
       while (e &amp;&amp; le != e &amp;&amp; (/\S/).test(e)) {
         le = e;
         for (var i in p) {
           if (m = e.match(p[i])) {
             v = Object.isFunction(x[i]) ? x[i](m) : new Template(x[i]).evaluate(m);
             exclusion.push(&quot;(&quot; + v.substring(1, v.length - 1) + &quot;)&quot;);
             e = e.replace(m[0], <I>);</I>
             break;
           }
         }
       }
       return &quot;[not(&quot; + exclusion.join(&quot; and &quot;) + &quot;)]&quot;;
     },
     'nth-child':      function(m) {
       return Selector.xpath.pseudos.nth(&quot;(count(./preceding-sibling::*) + 1) &quot;, m);
     },
     'nth-last-child': function(m) {
       return Selector.xpath.pseudos.nth(&quot;(count(./following-sibling::*) + 1) &quot;, m);
     },
     'nth-of-type':    function(m) {
       return Selector.xpath.pseudos.nth(&quot;position() &quot;, m);
     },
     'nth-last-of-type': function(m) {
       return Selector.xpath.pseudos.nth(&quot;(last() + 1 - position()) &quot;, m);
     },
     'first-of-type':  function(m) {
       m[6] = &quot;1&quot;; return Selector.xpath.pseudos['nth-of-type'](m);
     },
     'last-of-type':   function(m) {
       m[6] = &quot;1&quot;; return Selector.xpath.pseudos['nth-last-of-type'](m);
     },
     'only-of-type':   function(m) {
       var p = Selector.xpath.pseudos; return p['first-of-type'](m) + p['last-of-type'](m);
     },
     nth: function(fragment, m) {
       var mm, formula = m[6], predicate;
       if (formula == 'even') formula = '2n+0';
       if (formula == 'odd')  formula = '2n+1';
       if (mm = formula.match(/^(\d+)$/)) // digit only
         return '[' + fragment + &quot;= &quot; + mm[1] + ']';
       if (mm = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
         if (mm[1] == &quot;-&quot;) mm[1] = -1;
         var a = mm[1] ? Number(mm[1]) : 1;
         var b = mm[2] ? Number(mm[2]) : 0;
         predicate = &quot;[((#{fragment} - #{b}) mod #{a} = 0) and &quot; +
         &quot;((#{fragment} - #{b}) div #{a} &gt;= 0)]&quot;;
         return new Template(predicate).evaluate({
           fragment: fragment, a: a, b: b });
       }
     }
   }
 },
</PRE><PRE> criteria: {
   tagName:      'n = h.tagName(n, r, &quot;#{1}&quot;, c);      c = false;',
   className:    'n = h.className(n, r, &quot;#{1}&quot;, c);    c = false;',
   id:           'n = h.id(n, r, &quot;#{1}&quot;, c);           c = false;',
   attrPresence: 'n = h.attrPresence(n, r, &quot;#{1}&quot;, c); c = false;',
   attr: function(m) {
     m[3] = (m[5] || m[6]);
     return new Template('n = h.attr(n, r, &quot;#{1}&quot;, &quot;#{3}&quot;, &quot;#{2}&quot;, c); c = false;').evaluate(m);
   },
   pseudo: function(m) {
     if (m[6]) m[6] = m[6].replace(/&quot;/g, '\\&quot;');
     return new Template('n = h.pseudo(n, &quot;#{1}&quot;, &quot;#{6}&quot;, r, c); c = false;').evaluate(m);
   },
   descendant:   'c = &quot;descendant&quot;;',
   child:        'c = &quot;child&quot;;',
   adjacent:     'c = &quot;adjacent&quot;;',
   laterSibling: 'c = &quot;laterSibling&quot;;'
 },
</PRE><PRE> patterns: {
   // combinators must be listed first
   // (and descendant needs to be last combinator)
   laterSibling: /^\s*~\s*/,
   child:        /^\s*&gt;\s*/,
   adjacent:     /^\s*\+\s*/,
   descendant:   /^\s/,
</PRE><PRE>   // selectors follow
   tagName:      /^\s*(\*|[\w\-]+)(\b|$)?/,
   id:           /^#([\w\-\*]+)(\b|$)/,
   className:    /^\.([\w\-\*]+)(\b|$)/,
   pseudo:
</PRE><P>/^:((first|last|nth|nth-last|only)(-child|-of-type)|empty|checked|(en|dis)abled|not)(\((.*?)\))?(\b|$|(?=\s|[:+~&gt;]))/,
</P><PRE>   attrPresence: /^\[([\w]+)\]/,
   attr:         /\[((?:[\w-]*:)?[\w-]+)\s*(?:([!^$*~|]?=)\s*((['&quot;])([^\4]*?)\4|([^'&quot;][^\]]*?)))?\]/
 },
</PRE><PRE> // for Selector.match and Element#match
 assertions: {
   tagName: function(element, matches) {
     return matches[1].toUpperCase() == element.tagName.toUpperCase();
   },
</PRE><PRE>   className: function(element, matches) {
     return Element.hasClassName(element, matches[1]);
   },
</PRE><PRE>   id: function(element, matches) {
     return element.id === matches[1];
   },
</PRE><PRE>   attrPresence: function(element, matches) {
     return Element.hasAttribute(element, matches[1]);
   },
</PRE><PRE>   attr: function(element, matches) {
     var nodeValue = Element.readAttribute(element, matches[1]);
     return nodeValue &amp;&amp; Selector.operators[matches[2]](nodeValue, matches[5] || matches[6]);
   }
 },
</PRE><PRE> handlers: {
   // UTILITY FUNCTIONS
   // joins two collections
   concat: function(a, b) {
     for (var i = 0, node; node = b[i]; i++)
       a.push(node);
     return a;
   },
</PRE><PRE>   // marks an array of nodes for counting
   mark: function(nodes) {
     var _true = Prototype.emptyFunction;
     for (var i = 0, node; node = nodes[i]; i++)
       node._countedByPrototype = _true;
     return nodes;
   },
</PRE><PRE>   unmark: function(nodes) {
     for (var i = 0, node; node = nodes[i]; i++)
       node._countedByPrototype = undefined;
     return nodes;
   },
</PRE><PRE>   // mark each child node with its position (for nth calls)
   // &quot;ofType&quot; flag indicates whether we're indexing for nth-of-type
   // rather than nth-child
   index: function(parentNode, reverse, ofType) {
     parentNode._countedByPrototype = Prototype.emptyFunction;
     if (reverse) {
       for (var nodes = parentNode.childNodes, i = nodes.length - 1, j = 1; i &gt;= 0; i--) {
         var node = nodes[i];
         if (node.nodeType == 1 &amp;&amp; (!ofType || node._countedByPrototype)) node.nodeIndex = j++;
       }
     } else {
       for (var i = 0, j = 1, nodes = parentNode.childNodes; node = nodes[i]; i++)
         if (node.nodeType == 1 &amp;&amp; (!ofType || node._countedByPrototype)) node.nodeIndex = j++;
     }
   },
</PRE><PRE>   // filters out duplicates and extends all nodes
   unique: function(nodes) {
     if (nodes.length == 0) return nodes;
     var results = [], n;
     for (var i = 0, l = nodes.length; i &lt; l; i++)
       if (!(n = nodes[i])._countedByPrototype) {
         n._countedByPrototype = Prototype.emptyFunction;
         results.push(Element.extend(n));
       }
     return Selector.handlers.unmark(results);
   },
</PRE><PRE>   // COMBINATOR FUNCTIONS
   descendant: function(nodes) {
     var h = Selector.handlers;
     for (var i = 0, results = [], node; node = nodes[i]; i++)
       h.concat(results, node.getElementsByTagName('*'));
     return results;
   },
</PRE><PRE>   child: function(nodes) {
     var h = Selector.handlers;
     for (var i = 0, results = [], node; node = nodes[i]; i++) {
       for (var j = 0, child; child = node.childNodes[j]; j++)
         if (child.nodeType == 1 &amp;&amp; child.tagName != '!') results.push(child);
     }
     return results;
   },
</PRE><PRE>   adjacent: function(nodes) {
     for (var i = 0, results = [], node; node = nodes[i]; i++) {
       var next = this.nextElementSibling(node);
       if (next) results.push(next);
     }
     return results;
   },
</PRE><PRE>   laterSibling: function(nodes) {
     var h = Selector.handlers;
     for (var i = 0, results = [], node; node = nodes[i]; i++)
       h.concat(results, Element.nextSiblings(node));
     return results;
   },
</PRE><PRE>   nextElementSibling: function(node) {
     while (node = node.nextSibling)
</PRE><P>	      if (node.nodeType == 1) return node;
</P><PRE>     return null;
   },
</PRE><PRE>   previousElementSibling: function(node) {
     while (node = node.previousSibling)
       if (node.nodeType == 1) return node;
     return null;
   },
</PRE><PRE>   // TOKEN FUNCTIONS
   tagName: function(nodes, root, tagName, combinator) {
     var uTagName = tagName.toUpperCase();
     var results = [], h = Selector.handlers;
     if (nodes) {
       if (combinator) {
         // fastlane for ordinary descendant combinators
         if (combinator == &quot;descendant&quot;) {
           for (var i = 0, node; node = nodes[i]; i++)
             h.concat(results, node.getElementsByTagName(tagName));
           return results;
         } else nodes = this[combinator](nodes);
         if (tagName == &quot;*&quot;) return nodes;
       }
       for (var i = 0, node; node = nodes[i]; i++)
         if (node.tagName.toUpperCase() === uTagName) results.push(node);
       return results;
     } else return root.getElementsByTagName(tagName);
   },
</PRE><PRE>   id: function(nodes, root, id, combinator) {
     var targetNode = $(id), h = Selector.handlers;
     if (!targetNode) return [];
     if (!nodes &amp;&amp; root == document) return [targetNode];
     if (nodes) {
       if (combinator) {
         if (combinator == 'child') {
           for (var i = 0, node; node = nodes[i]; i++)
             if (targetNode.parentNode == node) return [targetNode];
         } else if (combinator == 'descendant') {
           for (var i = 0, node; node = nodes[i]; i++)
             if (Element.descendantOf(targetNode, node)) return [targetNode];
         } else if (combinator == 'adjacent') {
           for (var i = 0, node; node = nodes[i]; i++)
             if (Selector.handlers.previousElementSibling(targetNode) == node)
               return [targetNode];
         } else nodes = h[combinator](nodes);
       }
       for (var i = 0, node; node = nodes[i]; i++)
         if (node == targetNode) return [targetNode];
       return [];
     }
     return (targetNode &amp;&amp; Element.descendantOf(targetNode, root)) ? [targetNode] : [];
   },
</PRE><PRE>   className: function(nodes, root, className, combinator) {
     if (nodes &amp;&amp; combinator) nodes = this[combinator](nodes);
     return Selector.handlers.byClassName(nodes, root, className);
   },
</PRE><PRE>   byClassName: function(nodes, root, className) {
     if (!nodes) nodes = Selector.handlers.descendant([root]);
     var needle = ' ' + className + ' ';
     for (var i = 0, results = [], node, nodeClassName; node = nodes[i]; i++) {
       nodeClassName = node.className;
       if (nodeClassName.length == 0) continue;
       if (nodeClassName == className || (' ' + nodeClassName + ' ').include(needle))
         results.push(node);
     }
     return results;
   },
</PRE><PRE>   attrPresence: function(nodes, root, attr, combinator) {
     if (!nodes) nodes = root.getElementsByTagName(&quot;*&quot;);
     if (nodes &amp;&amp; combinator) nodes = this[combinator](nodes);
     var results = [];
     for (var i = 0, node; node = nodes[i]; i++)
       if (Element.hasAttribute(node, attr)) results.push(node);
     return results;
   },
</PRE><PRE>   attr: function(nodes, root, attr, value, operator, combinator) {
     if (!nodes) nodes = root.getElementsByTagName(&quot;*&quot;);
     if (nodes &amp;&amp; combinator) nodes = this[combinator](nodes);
     var handler = Selector.operators[operator], results = [];
     for (var i = 0, node; node = nodes[i]; i++) {
       var nodeValue = Element.readAttribute(node, attr);
       if (nodeValue === null) continue;
       if (handler(nodeValue, value)) results.push(node);
     }
     return results;
   },
</PRE><PRE>   pseudo: function(nodes, name, value, root, combinator) {
     if (nodes &amp;&amp; combinator) nodes = this[combinator](nodes);
     if (!nodes) nodes = root.getElementsByTagName(&quot;*&quot;);
     return Selector.pseudos[name](nodes, value, root);
   }
 },
</PRE><PRE> pseudos: {
   'first-child': function(nodes, value, root) {
     for (var i = 0, results = [], node; node = nodes[i]; i++) {
       if (Selector.handlers.previousElementSibling(node)) continue;
         results.push(node);
     }
     return results;
   },
   'last-child': function(nodes, value, root) {
     for (var i = 0, results = [], node; node = nodes[i]; i++) {
       if (Selector.handlers.nextElementSibling(node)) continue;
         results.push(node);
     }
     return results;
   },
   'only-child': function(nodes, value, root) {
     var h = Selector.handlers;
     for (var i = 0, results = [], node; node = nodes[i]; i++)
       if (!h.previousElementSibling(node) &amp;&amp; !h.nextElementSibling(node))
         results.push(node);
     return results;
   },
   'nth-child':        function(nodes, formula, root) {
     return Selector.pseudos.nth(nodes, formula, root);
   },
   'nth-last-child':   function(nodes, formula, root) {
     return Selector.pseudos.nth(nodes, formula, root, true);
   },
   'nth-of-type':      function(nodes, formula, root) {
     return Selector.pseudos.nth(nodes, formula, root, false, true);
   },
   'nth-last-of-type': function(nodes, formula, root) {
     return Selector.pseudos.nth(nodes, formula, root, true, true);
   },
   'first-of-type':    function(nodes, formula, root) {
     return Selector.pseudos.nth(nodes, &quot;1&quot;, root, false, true);
   },
   'last-of-type':     function(nodes, formula, root) {
     return Selector.pseudos.nth(nodes, &quot;1&quot;, root, true, true);
   },
   'only-of-type':     function(nodes, formula, root) {
     var p = Selector.pseudos;
     return p['last-of-type'](p['first-of-type'](nodes, formula, root), formula, root);
   },
</PRE><PRE>   // handles the an+b logic
   getIndices: function(a, b, total) {
     if (a == 0) return b &gt; 0 ? [b] : [];
     return $R(1, total).inject([], function(memo, i) {
       if (0 == (i - b) % a &amp;&amp; (i - b) / a &gt;= 0) memo.push(i);
       return memo;
     });
   },
</PRE><PRE>   // handles nth(-last)-child, nth(-last)-of-type, and (first|last)-of-type
   nth: function(nodes, formula, root, reverse, ofType) {
     if (nodes.length == 0) return [];
     if (formula == 'even') formula = '2n+0';
     if (formula == 'odd')  formula = '2n+1';
     var h = Selector.handlers, results = [], indexed = [], m;
     h.mark(nodes);
     for (var i = 0, node; node = nodes[i]; i++) {
       if (!node.parentNode._countedByPrototype) {
         h.index(node.parentNode, reverse, ofType);
         indexed.push(node.parentNode);
       }
     }
     if (formula.match(/^\d+$/)) { // just a number
       formula = Number(formula);
       for (var i = 0, node; node = nodes[i]; i++)
         if (node.nodeIndex == formula) results.push(node);
     } else if (m = formula.match(/^(-?\d*)?n(([+-])(\d+))?/)) { // an+b
       if (m[1] == &quot;-&quot;) m[1] = -1;
       var a = m[1] ? Number(m[1]) : 1;
       var b = m[2] ? Number(m[2]) : 0;
       var indices = Selector.pseudos.getIndices(a, b, nodes.length);
       for (var i = 0, node, l = indices.length; node = nodes[i]; i++) {
         for (var j = 0; j &lt; l; j++)
           if (node.nodeIndex == indices[j]) results.push(node);
       }
     }
     h.unmark(nodes);
     h.unmark(indexed);
     return results;
   },
</PRE><PRE>   'empty': function(nodes, value, root) {
     for (var i = 0, results = [], node; node = nodes[i]; i++) {
       // IE treats comments as element nodes
       if (node.tagName == '!' || (node.firstChild &amp;&amp; !node.innerHTML.match(/^\s*$/))) continue;
       results.push(node);
     }
     return results;
   },
</PRE><PRE>   'not': function(nodes, selector, root) {
     var h = Selector.handlers, selectorType, m;
     var exclusions = new Selector(selector).findElements(root);
     h.mark(exclusions);
     for (var i = 0, results = [], node; node = nodes[i]; i++)
       if (!node._countedByPrototype) results.push(node);
     h.unmark(exclusions);
     return results;
   },
</PRE><PRE>   'enabled': function(nodes, value, root) {
     for (var i = 0, results = [], node; node = nodes[i]; i++)
       if (!node.disabled) results.push(node);
     return results;
   },
</PRE><PRE>   'disabled': function(nodes, value, root) {
     for (var i = 0, results = [], node; node = nodes[i]; i++)
       if (node.disabled) results.push(node);
     return results;
   },
</PRE><PRE>   'checked': function(nodes, value, root) {
     for (var i = 0, results = [], node; node = nodes[i]; i++)
       if (node.checked) results.push(node);
     return results;
   }
 },
</PRE><PRE> operators: {
   '=':  function(nv, v) { return nv == v; },
   '!=': function(nv, v) { return nv != v; },
   '^=': function(nv, v) { return nv.startsWith(v); },
   '$=': function(nv, v) { return nv.endsWith(v); },
   '*=': function(nv, v) { return nv.include(v); },
   '~=': function(nv, v) { return (' ' + nv + ' ').include(' ' + v + ' '); },
   '|=': function(nv, v) { return ('-' + nv.toUpperCase() + '-').include('-' + v.toUpperCase() + '-'); }
 },
</PRE><PRE> split: function(expression) {
   var expressions = [];
   expression.scan(/(([\w#:.~&gt;+()\s-]+|\*|\[.*?\])+)\s*(,|$)/, function(m) {
     expressions.push(m[1].strip());
   });
   return expressions;
 },
</PRE><PRE> matchElements: function(elements, expression) {
   var matches = $$(expression), h = Selector.handlers;
   h.mark(matches);
   for (var i = 0, results = [], element; element = elements[i]; i++)
     if (element._countedByPrototype) results.push(element);
   h.unmark(matches);
   return results;
 },
</PRE><PRE> findElement: function(elements, expression, index) {
   if (Object.isNumber(expression)) {
     index = expression; expression = false;
   }
   return Selector.matchElements(elements, expression || '*')[index || 0];
 },
</PRE><PRE> findChildElements: function(element, expressions) {
   expressions = Selector.split(expressions.join(','));
   var results = [], h = Selector.handlers;
   for (var i = 0, l = expressions.length, selector; i &lt; l; i++) {
     selector = new Selector(expressions[i].strip());
     h.concat(results, selector.findElements(element));
   }
   return (l &gt; 1) ? h.unique(results) : results;
 }
</PRE><P>});
</P><P>if (Prototype.Browser.IE) {
</P><PRE> Object.extend(Selector.handlers, {
   // IE returns comment nodes on getElementsByTagName(&quot;*&quot;).
   // Filter them out.
   concat: function(a, b) {
     for (var i = 0, node; node = b[i]; i++)
       if (node.tagName !== &quot;!&quot;) a.push(node);
     return a;
   },
</PRE><PRE>   // IE improperly serializes _countedByPrototype in (inner|outer)HTML.
   unmark: function(nodes) {
     for (var i = 0, node; node = nodes[i]; i++)
       node.removeAttribute('_countedByPrototype');
     return nodes;
   }
 });
</PRE><P>}
</P><P>function $$() {
</P><PRE> return Selector.findChildElements(document, $A(arguments));
</PRE><P>}
var Form = {
</P><PRE> reset: function(form) {
   $(form).reset();
   return form;
 },
</PRE><PRE> serializeElements: function(elements, options) {
   if (typeof options != 'object') options = { hash: !!options };
   else if (Object.isUndefined(options.hash)) options.hash = true;
   var key, value, submitted = false, submit = options.submit;
</PRE><PRE>   var data = elements.inject({ }, function(result, element) {
     if (!element.disabled &amp;&amp; element.name) {
       key = element.name; value = $(element).getValue();
       if (value != null &amp;&amp; (element.type != 'submit' || (!submitted &amp;&amp;
           submit !== false &amp;&amp; (!submit || key == submit) &amp;&amp; (submitted = true)))) {
         if (key in result) {
           // a key is already present; construct an array of values
           if (!Object.isArray(result[key])) result[key] = [result[key]];
           result[key].push(value);
         }
         else result[key] = value;
       }
     }
     return result;
   });
</PRE><PRE>   return options.hash ? data : Object.toQueryString(data);
 }
</PRE><P>};
</P><P>Form.Methods = {
</P><PRE> serialize: function(form, options) {
   return Form.serializeElements(Form.getElements(form), options);
 },
</PRE><PRE> getElements: function(form) {
   return $A($(form).getElementsByTagName('*')).inject([],
     function(elements, child) {
       if (Form.Element.Serializers[child.tagName.toLowerCase()])
         elements.push(Element.extend(child));
       return elements;
     }
   );
 },
</PRE><PRE> getInputs: function(form, typeName, name) {
   form = $(form);
   var inputs = form.getElementsByTagName('input');
</PRE><PRE>   if (!typeName &amp;&amp; !name) return $A(inputs).map(Element.extend);
</PRE><PRE>   for (var i = 0, matchingInputs = [], length = inputs.length; i &lt; length; i++) {
     var input = inputs[i];
     if ((typeName &amp;&amp; input.type != typeName) || (name &amp;&amp; input.name != name))
       continue;
     matchingInputs.push(Element.extend(input));
   }
</PRE><PRE>   return matchingInputs;
 },
</PRE><PRE> disable: function(form) {
   form = $(form);
   Form.getElements(form).invoke('disable');
   return form;
 },
</PRE><PRE> enable: function(form) {
   form = $(form);
   Form.getElements(form).invoke('enable');
   return form;
 },
</PRE><PRE> findFirstElement: function(form) {
   var elements = $(form).getElements().findAll(function(element) {
     return 'hidden' != element.type &amp;&amp; !element.disabled;
   });
   var firstByIndex = elements.findAll(function(element) {
     return element.hasAttribute('tabIndex') &amp;&amp; element.tabIndex &gt;= 0;
   }).sortBy(function(element) { return element.tabIndex }).first();
</PRE><PRE>   return firstByIndex ? firstByIndex : elements.find(function(element) {
     return ['input', 'select', 'textarea'].include(element.tagName.toLowerCase());
   });
 },
</PRE><PRE> focusFirstElement: function(form) {
   form = $(form);
   form.findFirstElement().activate();
   return form;
 },
</PRE><PRE> request: function(form, options) {
   form = $(form), options = Object.clone(options || { });
</PRE><PRE>   var params = options.parameters, action = form.readAttribute('action') || <I>;</I>
   if (action.blank()) action = window.location.href;
   options.parameters = form.serialize(true);
</PRE><PRE>   if (params) {
     if (Object.isString(params)) params = params.toQueryParams();
     Object.extend(options.parameters, params);
   }
</PRE><PRE>   if (form.hasAttribute('method') &amp;&amp; !options.method)
     options.method = form.method;
</PRE><PRE>   return new Ajax.Request(action, options);
 }
</PRE><P>};
</P><P>/*--------------------------------------------------------------------------*/
</P><P>Form.Element = {
</P><PRE> focus: function(element) {
   $(element).focus();
   return element;
 },
</PRE><PRE> select: function(element) {
   $(element).select();
   return element;
 }
</PRE><P>};
</P><P>Form.Element.Methods = {
</P><PRE> serialize: function(element) {
   element = $(element);
   if (!element.disabled &amp;&amp; element.name) {
     var value = element.getValue();
     if (value != undefined) {
       var pair = { };
       pair[element.name] = value;
       return Object.toQueryString(pair);
     }
   }
   return <I>;</I>
 },
</PRE><PRE> getValue: function(element) {
   element = $(element);
   var method = element.tagName.toLowerCase();
   return Form.Element.Serializers[method](element);
 },
</PRE><PRE> setValue: function(element, value) {
   element = $(element);
   var method = element.tagName.toLowerCase();
   Form.Element.Serializers[method](element, value);
   return element;
 },
</PRE><PRE> clear: function(element) {
   $(element).value = <I>;</I>
   return element;
 },
</PRE><PRE> present: function(element) {
   return $(element).value != <I>;</I>
 },
</PRE><PRE> activate: function(element) {
   element = $(element);
   try {
     element.focus();
     if (element.select &amp;&amp; (element.tagName.toLowerCase() != 'input' ||
         !['button', 'reset', 'submit'].include(element.type)))
       element.select();
   } catch (e) { }
   return element;
 },
</PRE><PRE> disable: function(element) {
   element = $(element);
   element.blur();
   element.disabled = true;
   return element;
 },
</PRE><PRE> enable: function(element) {
   element = $(element);
   element.disabled = false;
   return element;
 }
</PRE><P>};
</P><P>/*--------------------------------------------------------------------------*/
</P><P>var Field = Form.Element;
var $F = Form.Element.Methods.getValue;
</P><P>/*--------------------------------------------------------------------------*/
</P><P>Form.Element.Serializers = {
</P><PRE> input: function(element, value) {
   switch (element.type.toLowerCase()) {
     case 'checkbox':
     case 'radio':
       return Form.Element.Serializers.inputSelector(element, value);
     default:
       return Form.Element.Serializers.textarea(element, value);
   }
 },
</PRE><PRE> inputSelector: function(element, value) {
   if (Object.isUndefined(value)) return element.checked ? element.value : null;
   else element.checked = !!value;
 },
</PRE><PRE> textarea: function(element, value) {
   if (Object.isUndefined(value)) return element.value;
   else element.value = value;
 },
</PRE><PRE> select: function(element, index) {
   if (Object.isUndefined(index))
     return this[element.type == 'select-one' ?
       'selectOne' : 'selectMany'](element);
   else {
     var opt, value, single = !Object.isArray(index);
     for (var i = 0, length = element.length; i &lt; length; i++) {
       opt = element.options[i];
       value = this.optionValue(opt);
       if (single) {
         if (value == index) {
           opt.selected = true;
           return;
         }
       }
       else opt.selected = index.include(value);
     }
   }
 },
</PRE><PRE> selectOne: function(element) {
   var index = element.selectedIndex;
   return index &gt;= 0 ? this.optionValue(element.options[index]) : null;
 },
</PRE><PRE> selectMany: function(element) {
   var values, length = element.length;
   if (!length) return null;
</PRE><PRE>   for (var i = 0, values = []; i &lt; length; i++) {
     var opt = element.options[i];
     if (opt.selected) values.push(this.optionValue(opt));
   }
   return values;
 },
</PRE><PRE> optionValue: function(opt) {
   // extend element because hasAttribute may not be native
   return Element.extend(opt).hasAttribute('value') ? opt.value : opt.text;
 }
</PRE><P>};
</P><P>/*--------------------------------------------------------------------------*/
</P><P>Abstract.TimedObserver = Class.create(PeriodicalExecuter, {
</P><PRE> initialize: function($super, element, frequency, callback) {
   $super(callback, frequency);
   this.element   = $(element);
   this.lastValue = this.getValue();
 },
</PRE><PRE> execute: function() {
   var value = this.getValue();
   if (Object.isString(this.lastValue) &amp;&amp; Object.isString(value) ?
       this.lastValue != value : String(this.lastValue) != String(value)) {
     this.callback(this.element, value);
     this.lastValue = value;
   }
 }
</PRE><P>});
</P><P>Form.Element.Observer = Class.create(Abstract.TimedObserver, {
</P><PRE> getValue: function() {
   return Form.Element.getValue(this.element);
 }
</PRE><P>});
</P><P>Form.Observer = Class.create(Abstract.TimedObserver, {
</P><PRE> getValue: function() {
   return Form.serialize(this.element);
 }
</PRE><P>});
</P><P>/*--------------------------------------------------------------------------*/
</P><P>Abstract.EventObserver = Class.create({
</P><PRE> initialize: function(element, callback) {
   this.element  = $(element);
   this.callback = callback;
</PRE><PRE>   this.lastValue = this.getValue();
   if (this.element.tagName.toLowerCase() == 'form')
     this.registerFormCallbacks();
   else
     this.registerCallback(this.element);
 },
</PRE><PRE> onElementEvent: function() {
   var value = this.getValue();
   if (this.lastValue != value) {
     this.callback(this.element, value);
     this.lastValue = value;
   }
 },
</PRE><PRE> registerFormCallbacks: function() {
   Form.getElements(this.element).each(this.registerCallback, this);
 },
</PRE><PRE> registerCallback: function(element) {
   if (element.type) {
     switch (element.type.toLowerCase()) {
       case 'checkbox':
       case 'radio':
         Event.observe(element, 'click', this.onElementEvent.bind(this));
         break;
       default:
         Event.observe(element, 'change', this.onElementEvent.bind(this));
         break;
     }
   }
 }
</PRE><P>});
</P><P>Form.Element.EventObserver = Class.create(Abstract.EventObserver, {
</P><PRE> getValue: function() {
   return Form.Element.getValue(this.element);
 }
</PRE><P>});
</P><P>Form.EventObserver = Class.create(Abstract.EventObserver, {
</P><PRE> getValue: function() {
   return Form.serialize(this.element);
 }
</PRE><P>});
if (!window.Event) var Event = { };
</P><P>Object.extend(Event, {
</P><PRE> KEY_BACKSPACE: 8,
 KEY_TAB:       9,
 KEY_RETURN:   13,
 KEY_ESC:      27,
 KEY_LEFT:     37,
 KEY_UP:       38,
 KEY_RIGHT:    39,
 KEY_DOWN:     40,
 KEY_DELETE:   46,
 KEY_HOME:     36,
 KEY_END:      35,
 KEY_PAGEUP:   33,
 KEY_PAGEDOWN: 34,
 KEY_INSERT:   45,
</PRE><PRE> cache: { },
</PRE><PRE> relatedTarget: function(event) {
   var element;
   switch(event.type) {
     case 'mouseover': element = event.fromElement; break;
     case 'mouseout':  element = event.toElement;   break;
     default: return null;
   }
   return Element.extend(element);
 }
</PRE><P>});
</P><P>Event.Methods = (function() {
</P><PRE> var isButton;
</PRE><PRE> if (Prototype.Browser.IE) {
   var buttonMap = { 0: 1, 1: 4, 2: 2 };
   isButton = function(event, code) {
     return event.button == buttonMap[code];
   };
</PRE><PRE> } else if (Prototype.Browser.WebKit) {
   isButton = function(event, code) {
     switch (code) {
       case 0: return event.which == 1 &amp;&amp; !event.metaKey;
       case 1: return event.which == 1 &amp;&amp; event.metaKey;
       default: return false;
     }
   };
</PRE><PRE> } else {
   isButton = function(event, code) {
     return event.which ? (event.which === code + 1) : (event.button === code);
   };
 }
</PRE><PRE> return {
   isLeftClick:   function(event) { return isButton(event, 0) },
   isMiddleClick: function(event) { return isButton(event, 1) },
   isRightClick:  function(event) { return isButton(event, 2) },
</PRE><PRE>   element: function(event) {
     var node = Event.extend(event).target;
     return Element.extend(node.nodeType == Node.TEXT_NODE ? node.parentNode : node);
   },
</PRE><PRE>   findElement: function(event, expression) {
     var element = Event.element(event);
     if (!expression) return element;
     var elements = [element].concat(element.ancestors());
     return Selector.findElement(elements, expression, 0);
   },
</PRE><PRE>   pointer: function(event) {
     return {
       x: event.pageX || (event.clientX +
         (document.documentElement.scrollLeft || document.body.scrollLeft)),
       y: event.pageY || (event.clientY +
         (document.documentElement.scrollTop || document.body.scrollTop))
     };
   },
</PRE><PRE>   pointerX: function(event) { return Event.pointer(event).x },
   pointerY: function(event) { return Event.pointer(event).y },
</PRE><PRE>   stop: function(event) {
     Event.extend(event);
     event.preventDefault();
     event.stopPropagation();
     event.stopped = true;
   }
 };
</PRE><P>})();
</P><P>Event.extend = (function() {
</P><PRE> var methods = Object.keys(Event.Methods).inject({ }, function(m, name) {
   m[name] = Event.Methods[name].methodize();
   return m;
 });
</PRE><PRE> if (Prototype.Browser.IE) {
   Object.extend(methods, {
     stopPropagation: function() { this.cancelBubble = true },
     preventDefault:  function() { this.returnValue = false },
     inspect: function() { return &quot;[object Event]&quot; }
   });
</PRE><PRE>   return function(event) {
     if (!event) return false;
     if (event._extendedByPrototype) return event;
</PRE><PRE>     event._extendedByPrototype = Prototype.emptyFunction;
     var pointer = Event.pointer(event);
     Object.extend(event, {
       target: event.srcElement,
       relatedTarget: Event.relatedTarget(event),
       pageX:  pointer.x,
       pageY:  pointer.y
     });
     return Object.extend(event, methods);
   };
</PRE><PRE> } else {
   Event.prototype = Event.prototype || document.createEvent(&quot;HTMLEvents&quot;).__proto__;
   Object.extend(Event.prototype, methods);
   return Prototype.K;
 }
</PRE><P>})();
</P><P>Object.extend(Event, (function() {
</P><PRE> var cache = Event.cache;
</PRE><PRE> function getEventID(element) {
   if (element._prototypeEventID) return element._prototypeEventID[0];
   arguments.callee.id = arguments.callee.id || 1;
   return element._prototypeEventID = [++arguments.callee.id];
 }
</PRE><PRE> function getDOMEventName(eventName) {
   if (eventName &amp;&amp; eventName.include(':')) return &quot;dataavailable&quot;;
   return eventName;
 }
</PRE><PRE> function getCacheForID(id) {
   return cache[id] = cache[id] || { };
 }
</PRE><PRE> function getWrappersForEventName(id, eventName) {
   var c = getCacheForID(id);
   return c[eventName] = c[eventName] || [];
 }
</PRE><PRE> function createWrapper(element, eventName, handler) {
   var id = getEventID(element);
   var c = getWrappersForEventName(id, eventName);
   if (c.pluck(&quot;handler&quot;).include(handler)) return false;
</PRE><PRE>   var wrapper = function(event) {
     if (!Event || !Event.extend ||
       (event.eventName &amp;&amp; event.eventName != eventName))
         return false;
</PRE><PRE>     Event.extend(event);
     handler.call(element, event);
   };
</PRE><PRE>   wrapper.handler = handler;
   c.push(wrapper);
   return wrapper;
 }
</PRE><PRE> function findWrapper(id, eventName, handler) {
   var c = getWrappersForEventName(id, eventName);
   return c.find(function(wrapper) { return wrapper.handler == handler });
 }
</PRE><PRE> function destroyWrapper(id, eventName, handler) {
   var c = getCacheForID(id);
   if (!c[eventName]) return false;
   c[eventName] = c[eventName].without(findWrapper(id, eventName, handler));
 }
</PRE><PRE> function destroyCache() {
   for (var id in cache)
     for (var eventName in cache[id])
       cache[id][eventName] = null;
 }
</PRE><PRE> if (window.attachEvent) {
   window.attachEvent(&quot;onunload&quot;, destroyCache);
 }
</PRE><PRE> return {
   observe: function(element, eventName, handler) {
     element = $(element);
     var name = getDOMEventName(eventName);
</PRE><PRE>     var wrapper = createWrapper(element, eventName, handler);
     if (!wrapper) return element;
</PRE><PRE>     if (element.addEventListener) {
       element.addEventListener(name, wrapper, false);
     } else {
       element.attachEvent(&quot;on&quot; + name, wrapper);
     }
</PRE><PRE>     return element;
   },
</PRE><PRE>   stopObserving: function(element, eventName, handler) {
     element = $(element);
     var id = getEventID(element), name = getDOMEventName(eventName);
</PRE><PRE>     if (!handler &amp;&amp; eventName) {
       getWrappersForEventName(id, eventName).each(function(wrapper) {
         element.stopObserving(eventName, wrapper.handler);
       });
       return element;
</PRE><PRE>     } else if (!eventName) {
       Object.keys(getCacheForID(id)).each(function(eventName) {
         element.stopObserving(eventName);
       });
       return element;
     }
</PRE><PRE>     var wrapper = findWrapper(id, eventName, handler);
     if (!wrapper) return element;
</PRE><PRE>     if (element.removeEventListener) {
       element.removeEventListener(name, wrapper, false);
     } else {
       element.detachEvent(&quot;on&quot; + name, wrapper);
     }
</PRE><PRE>     destroyWrapper(id, eventName, handler);
</PRE><PRE>     return element;
   },
</PRE><PRE>   fire: function(element, eventName, memo) {
     element = $(element);
     if (element == document &amp;&amp; document.createEvent &amp;&amp; !element.dispatchEvent)
       element = document.documentElement;
</PRE><PRE>     var event;
     if (document.createEvent) {
       event = document.createEvent(&quot;HTMLEvents&quot;);
       event.initEvent(&quot;dataavailable&quot;, true, true);
     } else {
       event = document.createEventObject();
       event.eventType = &quot;ondataavailable&quot;;
     }
</PRE><PRE>     event.eventName = eventName;
     event.memo = memo || { };
</PRE><PRE>     if (document.createEvent) {
       element.dispatchEvent(event);
     } else {
       element.fireEvent(event.eventType, event);
     }
</PRE><PRE>     return Event.extend(event);
   }
 };
</PRE><P>})());
</P><P>Object.extend(Event, Event.Methods);
</P><P>Element.addMethods({
</P><PRE> fire:          Event.fire,
 observe:       Event.observe,
 stopObserving: Event.stopObserving
</PRE><P>});
</P><P>Object.extend(document, {
</P><PRE> fire:          Element.Methods.fire.methodize(),
 observe:       Element.Methods.observe.methodize(),
 stopObserving: Element.Methods.stopObserving.methodize(),
 loaded:        false
</PRE><P>});
</P><P>(function() {
</P><PRE> /* Support for the DOMContentLoaded event is based on work by Dan Webb,
    Matthias Miller, Dean Edwards and John Resig. */
</PRE><PRE> var timer;
</PRE><PRE> function fireContentLoadedEvent() {
   if (document.loaded) return;
   if (timer) window.clearInterval(timer);
   document.fire(&quot;dom:loaded&quot;);
   document.loaded = true;
 }
</PRE><PRE> if (document.addEventListener) {
   if (Prototype.Browser.WebKit) {
     timer = window.setInterval(function() {
       if (/loaded|complete/.test(document.readyState))
         fireContentLoadedEvent();
     }, 0);
</PRE><PRE>     Event.observe(window, &quot;load&quot;, fireContentLoadedEvent);
</PRE><PRE>   } else {
     document.addEventListener(&quot;DOMContentLoaded&quot;,
       fireContentLoadedEvent, false);
   }
</PRE><PRE> } else {
   document.write(&quot;&lt;script id=__onDOMContentLoaded defer src=//:&gt;&lt;\/script&gt;&quot;);
   $(&quot;__onDOMContentLoaded&quot;).onreadystatechange = function() {
     if (this.readyState == &quot;complete&quot;) {
       this.onreadystatechange = null;
       fireContentLoadedEvent();
     }
   };
 }
</PRE><P>})();
/*------------------------------- DEPRECATED -------------------------------*/
</P><P>Hash.toQueryString = Object.toQueryString;
</P><P>var Toggle = { display: Element.toggle };
</P><P>Element.Methods.childOf = Element.Methods.descendantOf;
</P><P>var Insertion = {
</P><PRE> Before: function(element, content) {
   return Element.insert(element, {before:content});
 },
</PRE><PRE> Top: function(element, content) {
   return Element.insert(element, {top:content});
 },
</PRE><PRE> Bottom: function(element, content) {
   return Element.insert(element, {bottom:content});
 },
</PRE><PRE> After: function(element, content) {
   return Element.insert(element, {after:content});
 }
</PRE><P>};
</P><P>var $continue = new Error('&quot;throw $continue&quot; is deprecated, use &quot;return&quot; instead');
</P><P>// This should be moved to script.aculo.us; notice the deprecated methods
// further below, that map to the newer Element methods.
var Position = {
</P><PRE> // set to true if needed, warning: firefox performance problems
 // NOT neeeded for page scrolling, only if draggable contained in
 // scrollable elements
 includeScrollOffsets: false,
</PRE><PRE> // must be called before calling withinIncludingScrolloffset, every time the
 // page is scrolled
 prepare: function() {
   this.deltaX =  window.pageXOffset
               || document.documentElement.scrollLeft
               || document.body.scrollLeft
               || 0;
   this.deltaY =  window.pageYOffset
               || document.documentElement.scrollTop
               || document.body.scrollTop
               || 0;
 },
</PRE><PRE> // caches x/y coordinate pair to use with overlap
 within: function(element, x, y) {
   if (this.includeScrollOffsets)
     return this.withinIncludingScrolloffsets(element, x, y);
   this.xcomp = x;
   this.ycomp = y;
   this.offset = Element.cumulativeOffset(element);
</PRE><PRE>   return (y &gt;= this.offset[1] &amp;&amp;
           y &lt;  this.offset[1] + element.offsetHeight &amp;&amp;
           x &gt;= this.offset[0] &amp;&amp;
           x &lt;  this.offset[0] + element.offsetWidth);
 },
</PRE><PRE> withinIncludingScrolloffsets: function(element, x, y) {
   var offsetcache = Element.cumulativeScrollOffset(element);
</PRE><PRE>   this.xcomp = x + offsetcache[0] - this.deltaX;
   this.ycomp = y + offsetcache[1] - this.deltaY;
   this.offset = Element.cumulativeOffset(element);
</PRE><PRE>   return (this.ycomp &gt;= this.offset[1] &amp;&amp;
           this.ycomp &lt;  this.offset[1] + element.offsetHeight &amp;&amp;
           this.xcomp &gt;= this.offset[0] &amp;&amp;
           this.xcomp &lt;  this.offset[0] + element.offsetWidth);
 },
</PRE><PRE> // within must be called directly before
 overlap: function(mode, element) {
   if (!mode) return 0;
   if (mode == 'vertical')
     return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
       element.offsetHeight;
   if (mode == 'horizontal')
     return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
       element.offsetWidth;
 },
</PRE><PRE> // Deprecation layer -- use newer Element methods now (1.5.2).
</PRE><PRE> cumulativeOffset: Element.Methods.cumulativeOffset,
</PRE><PRE> positionedOffset: Element.Methods.positionedOffset,
</PRE><PRE> absolutize: function(element) {
   Position.prepare();
   return Element.absolutize(element);
 },
</PRE><PRE> relativize: function(element) {
   Position.prepare();
   return Element.relativize(element);
 },
</PRE><PRE> realOffset: Element.Methods.cumulativeScrollOffset,
</PRE><PRE> offsetParent: Element.Methods.getOffsetParent,
</PRE><PRE> page: Element.Methods.viewportOffset,
</PRE><PRE> clone: function(source, target, options) {
   options = options || { };
   return Element.clonePosition(target, source, options);
 }
</PRE><P>};
</P><P>/*--------------------------------------------------------------------------*/
</P><P>if (!document.getElementsByClassName) document.getElementsByClassName = function(instanceMethods){
</P><PRE> function iter(name) {
   return name.blank() ? null : &quot;[contains(concat(' ', @class, ' '), ' &quot; + name + &quot; ')]&quot;;
 }
</PRE><PRE> instanceMethods.getElementsByClassName = Prototype.BrowserFeatures.XPath ?
 function(element, className) {
   className = className.toString().strip();
   var cond = /\s/.test(className) ? $w(className).map(iter).join(<I>) : iter(className);</I>
   return cond ? document._getElementsByXPath('.//*' + cond, element) : [];
 } : function(element, className) {
   className = className.toString().strip();
   var elements = [], classNames = (/\s/.test(className) ? $w(className) : null);
   if (!classNames &amp;&amp; !className) return elements;
</PRE><PRE>   var nodes = $(element).getElementsByTagName('*');
   className = ' ' + className + ' ';
</PRE><PRE>   for (var i = 0, child, cn; child = nodes[i]; i++) {
     if (child.className &amp;&amp; (cn = ' ' + child.className + ' ') &amp;&amp; (cn.include(className) ||
         (classNames &amp;&amp; classNames.all(function(name) {
           return !name.toString().blank() &amp;&amp; cn.include(' ' + name + ' ');
         }))))
       elements.push(Element.extend(child));
   }
   return elements;
 };
</PRE><PRE> return function(className, parentElement) {
   return $(parentElement || document.body).getElementsByClassName(className);
 };
</PRE><P>}(Element.Methods);
</P><P>/*--------------------------------------------------------------------------*/
</P><P>Element.ClassNames = Class.create();
Element.ClassNames.prototype = {
</P><PRE> initialize: function(element) {
   this.element = $(element);
 },
</PRE><PRE> _each: function(iterator) {
   this.element.className.split(/\s+/).select(function(name) {
     return name.length &gt; 0;
   })._each(iterator);
 },
</PRE><PRE> set: function(className) {
   this.element.className = className;
 },
</PRE><PRE> add: function(classNameToAdd) {
   if (this.include(classNameToAdd)) return;
   this.set($A(this).concat(classNameToAdd).join(' '));
 },
</PRE><PRE> remove: function(classNameToRemove) {
   if (!this.include(classNameToRemove)) return;
   this.set($A(this).without(classNameToRemove).join(' '));
 },
</PRE><PRE> toString: function() {
   return $A(this).join(' ');
 }
</PRE><P>};
</P><P>Object.extend(Element.ClassNames.prototype, Enumerable);
</P><P>/*--------------------------------------------------------------------------*/
</P><P>Element.addMethods();
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2009.igem.org/Team:Edinburgh/lightboxprototype">http://2009.igem.org/Team:Edinburgh/lightboxprototype</A>&quot;</DIV></DIV></DIV><DIV id="footer-box"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Edinburgh/lightboxprototype" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Edinburgh/lightboxprototype" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Edinburgh/lightboxprototype&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Edinburgh/lightboxprototype&amp;oldid=48371" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2009.igem.org:Privacy_policy" title="2009.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2009.igem.org:General_disclaimer" title="2009.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
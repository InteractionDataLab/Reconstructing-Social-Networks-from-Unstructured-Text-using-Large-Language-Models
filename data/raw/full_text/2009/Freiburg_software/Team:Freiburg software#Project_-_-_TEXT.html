"
Page
Discussion
View source
History
teams
Log in
 
Team:Freiburg software/Project
From 2009.igem.org
Home
The Team
The Project
The Code
User Guide
Notebook
Miscellaneous
Watch a high resolution version here
Contents
1Motivation
2Highlights
2.1A collaborative web based software for synthetic biology research
2.2Creating a software interface on top of Google Wave
2.3Access to a large pool of sequence data
2.4Extendable software suite
2.5Pioneering spirit
3Existing technologies
3.1Google Wave
3.2BioJava
3.3Qooxdoo
4Software
4.1Architecture
4.1.1Robots
4.1.2Gadgets
4.2Bring it together: The qooxWave protocol
4.2.1Client side implementation
4.2.2Server side implementation
4.3Extending Google Wave I/O
4.3.1Sequence file import/export
4.3.2Database access
4.3.3Internal Database
4.4How to display sequences
5Perspective
5.1Future releases
5.1.1Version 0.2
5.1.2Version 0.3
5.1.3Later Versions
6References
Motivation
Nowadays, the web offers a wide range of tools to communicate, collaborate and share personal data. People share their pictures with Flickr, students interact in social networks like Facebook, programmers contribute to software projects using platforms like Sourceforge. In contrast, science communication is still making little use of the collaborative world wide web. In particular, synthetic biology is highly inter-disciplinary and requires many scientists to work together in order to build complex biological systems like genes, gene assemblies, synthetic protein devices or later even genomes. From the outset, the synthetic biology community has made efforts to cross-link the results of their research in open repositories and wikis.  We want to push this process to the next level: Why only store and share results? Why not making use of the web to collaborate? Scientist could make the whole process transparent, or even better, design and create data together.
Highlights
A collaborative web based software for synthetic biology research
We have created an open-source, synthetic biological software suite called SynBioWave. Based on Google's communication tool Wave, SynBioWave is made for collaborative synthetic biology research comprising parts design and documentation. Moreover, biologists can record and share the process of creating research data and perform basic tasks using SynBioWave.
For example, users can start conversations, invite participants, import sequences from several resources, comment data, perform some tasks and display or export the results. Each participant experiences the others' actions in real time. New participants can track back the whole process using the playback function. And all you need is a browser connected to the internet. Could it be easier to invite colleges to your research?
Creating a software interface on top of Google Wave
We created three ways to display sequence data , a short sequence view, a gadget view and a circular view.
We extended Wave's user interface (ui) with a highly dynamic menu system and added new ui-elements such as an upload form for sequence files.
To realize an easy to use interface for generating user interfaces, we invented the qooxWave protocol . This protocol defines a client-to-server and server-to-client communication for building ui-elements, event reporting and data transmission.
The client-side implementation of the qooxWave protocol makes use of the RIA framework qooxdoo . To ensure a proper implementation of qooxWave , we designed a robust store-model-view-controller concept .
Even though SynBioWave is a web application, its look and feel reminds the user of a desktop application.
Access to a large pool of sequence data
SynBioWave inherits Wave's feature to handle common data like rich text documents, graphics, music/video and many more.
We spend much effort to implement support for a large range of sequence formats, such as FASTA, GenBank and EMBL.
SynBioWave imports and exports sequence data from/into files.
SynBioWave supports DAS access to the iGEM related BioBrick database.
SynBioWave uses an internal database to track all sequences produced or imported in the working flow.
Have a look at the I/O section to learn more about the features mentioned above.
Extendable software suite
To lay ground for an successful open source project, we wrapped our efforts into an easy to implement framework, allowing developers to contribute to SynBioWave. One key feature of this framework is an abstract template class that allows the user to create robots, providing new features, without thinking about sequence I/O, GUI or display issues.
To demonstrate this extensible concept, we added one additional robot providing the feature of a Blast search. It turned out, that our concept works! The implementation is really easy. Have a look at the code .
Have a look at the software architecture to explore our framework.
Pioneering spirit
To our knowledge, SynBioWave is currently the only approach to write a collaborative web-based biological software, as well as the only bigger project based on Google Wave.
When we first heard of Google Wave, we instantly noticed it could be the solid basis we were looking for to build such a next level biological software suite. When we got access to its developer preview version later, it confirmed our choice, but soon we noticed that we would need a lot of features not yet build-in in Wave, some not yet even planned.
We are the first (and maybe only) developers creating a project consisting of multiple Wave-Robots and therefore had to think about a way to make these robots communicate with each other. Google has not foreseen this need of Robot-Robot-Communication and has not even decided to add this to their Robot-API.
Existing technologies
Google Wave
Google Wave is "a personal communication and collaboration tool" developed by Google. It is a web-based service, computing platform, and communication protocol designed to merge e-mail, instant messaging, wikis, and social networking. It has a strong collaborative and real-time focus and provides several ways to extend its functionality.
[1]
Wave basically consists of an open communication protocol similar to email, as well as of client- and server-software. Like email, the protocol aims to be open, decentralized and easy to adapt, but includes modern achievements like multi-user-, real-time-communication and rich formated text with embedded data as well. At the moment, the only working server and client software for Wave is also written by Google, but with the protocol being open-source already, other - Google independent - servers and clients will soon be available.
Practically, a typical Wave-conversations - called a wavelet - usually works like this:  User Alice creates a new Wavelet. She than invites her friend Bob to join the conversation. Bob accepts and can now write messages to the wave. Each message creates a so-called Blip. What differentiates Wave from normal instant-messaging is, that if Alice and Bob decide to write a document together, they can start to edit the same Blip together. Each change they make to the text there is shown to the other one in real time. If they want, they can also use a build-in playback feature similar to the version-history in wikis to review the changes made to the wavelet.
In addition, Google has published an API for writing so-called Robots and Gadgets for Wave. While Robots are small programs written in Python or Java, which can participate in Wave similar to normal users, Gadgets are small web pages that can be embedded into a wave conversation.
If you want to know more about how we extend and modified this tool to match the needs of synthetic biologists, have a look at the Software section of this document.
BioJava
BioJava is an open source project dedicated to providing a Java framework for processing biological data. It provides analytical and statistical routines, parsers for common file formats and allows the manipulation of sequences and 3D structures. The goal of the BioJava project is to facilitate rapid application development for bioinformatics.
Having the choice between BioJava und BioPhyton (the only two programming languages supported by Google Wave), we decided to use BioJava because of its faster growing and better supported library and the scalable, cross-platform and network-aware nature of the Java programming language.
For insights into the usage of BioJava in our software, have a look at section Extending Google Wave I/O .  We plan to integrate support for Python in later versions of SynBioWave.
Qooxdoo
Qooxdoo is one of the leading frameworks for creating rich internet application (RIAs). RIAs are web applications which are accessed from the browser and commonly made for multi user tasks. In contrast to usual web sites, RIAs look and feel like desktop applications. Building a RIA from scratch is nearly impossible. Therefore qooxdoo provides a platform-independent development tool chain, a state-of-the-art GUI toolkit and an advanced client-server communication layer.
Because Wave's user interface is only weakly customizable, qooxdoo is a perfect candidate to extend Wave's user interface with custom toolbars, buttons, forms, context-menus and much more.
Have a look at the qooxWave protocol we created to learn more about how we used qooxdoo in our project.
Software
Architecture
SynBioWave turns Google Wave into a biosynthetic software suite. There are currently two available methods for extending Google Wave, and we are making use of both (See Google Wave for an introduction):
Robots
Gadgets
Robots
Robots are automated participants, able to modify the wavelets' contents they have joined and interact with real participants. Using Google's Java client library for Robots gives us the possibility to implement biosynthetic functionality provided by the BioJava library. We created the SynBioWave Robot as the core of our extension. Adding this robot to a wavelet activates SynBioWave. There are additional robots providing specific functions when added to a wavelet. The SynBioWave Robot is responsible for:
Organization of all SynBioWave functions represented by additional robots
Extending Wave's user interface with SynBioWave specific elements using our qooxWave protocol
Storing the important information written to the wave in an external database
Providing basic functionality like
Import/export of sequences
Rendering and displaying of sequences
Circular view
BioBrick communication (searching and importing biological parts)
Additional robots extending SynBioWave functionality
To extend SynBioWave with new biosynthetic functions, one can use additional robots. Adding such a robot to an active SynBioWave wavelet (a wavelet that contains the SynBioWave Robot), enables this function to all users participating in this wave. For SynBioWave users it is very easy to customize and extend SynBioWave. A user searches the robot representing a certain function and adds it to the wavelet he is working with. But this is not the only benefit! This modular architectures makes it very easy for other developers to create additional robots. To facilitate contribution, we provide an abstract SynBioWave Template class. Using this class dramatically simplifies additional robot creation. The developer neither needs to worry about Wave development nor about SynBioWave integration (a minimal understanding of both is still needed). Therefore, one can concentrate on biosynthetic developments.
Organizing a multi robot system
As we were testing this concept of multiple robots in one and the same conversation, it became quite clear that we needed to organize the way the robots work and interact: With different robots all listening to different (or maybe even the same) events - editing text, writing messages and so on - we ended up in great chaos in our initial tests. So we decided to extend our framework to provide a standard in- and output for robots. For the input part, we created a menu, which dynamically displays all the functions of the robots in the current wave. As Google has not foreseen this need of a standardized and easy-to-use input method for Wave robots, we had to create this from scratch and implemented it using a Gadget. Moreover, we invented the so-called qooxWave protocol for a standardized communication between the robots and this menu gadget.
To organize the output of the robots, we created a standardized sequence display. At the moment, the user can choose if he likes to have the sequences either directly in the wave, which feels more "natural", or inside a Gadget, which is currently much more usable because of strict limitations to text-formatting inside Google Wave. Most likely, all sequences will be written directly in the wave in the future as Google has announced to boost the layout options of Wave dramatically.
Gadgets
The SynBioWave robots could be thought of some kind of program logic. They are running somewhere in the cloud, process and organize data. Gadgets come into play, when data such as sequences are displayed inside a Wave. Moreover Gadgets offer the possibility to insert custom user interfaces which are essential for manipulating and managing the biological data. Gadgets are little websites included in a wavelet and communicating with it via Google's Wave API. So you could think of gadgets as some kind of visible objects, that are essential for the integration of biological data into Wave.
SynBioWave's user interface
The possibilities Google Wave currently provides to customize its user interface are less then weak. To realize some advanced features like upload forms for DNA sequence files or ,toolbars bundling SynBioWave's functionality we used Gadgets. The SynBioWave robot dynamically creates a gadget containing a toolbar. It adds all user-interface-elements that correspond to functions provided by the SynBioWave robot itself and by additional robots. The Gadgets sends events and input data from the user back to the robots. For this purpose, we introduced the qooxWave protocol .
Bring it together: The qooxWave protocol
We invented the qooxWave protocol to realize an easy to use interface for creating graphical user interfaces (GUI) inside a wave from a robot. The general goal is to provide one abstract robot class for implementing new function into SynBioWave (each function is provided by a robot ). The programmer who uses this class does not need to worry about the client side GUI implementation. This protocol ensures easy to use server side function, that automatically builds the client side GUI.
The protocol defines a server-to-client and client-to-server communication. This communication contains
a server-to-client communication for building client-side GUI elements from server side (so a server side robot can create a client side button for example)
a client-to-server communication for reporting events fired in the client side GUI and to transfer user input data to the robots (so the server knows when the user clicks a button for example)
The communication is realized via JSON-Strings that are stored inside a gadgets state object. Both, server (robot) and client (gadget) can access the state object and they can both react on changes of this state object (this is provided by the google wave API).
For a detailed description/definition of the qooxWave protocol, we created an external page , which might be interesting for those deeply interested or planning to write SynBioWave robots.
Client side implementation
qooxdoo inside a gadget
The client-side implementation of qooxWave is based on a qooxdoo application loaded into a gadget inside the Wave (have a look at the screenshot on the right). This qooxdoo application - written entirely in JavaScript - communicates with the SynBioWave Robot via JSON-Strings using a state object provided by the Wave API. The state object is actually designed for gadget-robot communication. But it only supports String-Data. This is why we use JSON to transmit more complex objects.
The qooxdoo application receives a JSON-object from the robot containing a GUI-structure. It parses this object and dynamically adds the ui-elements. On the other hand, the application sends user input back to the robot, also in form of JSON-Strings.
As an example, the robot could send a JSON-String containing information about a toolbar, its menu items - let's say just a button labeled upload - and information for an upload form that opens when clicking the button. The JSON-String is modeled into a certain JavaScript object (to be precise: qooxdoo objects) and then displayed by the qooxdoo application. When the user submits the upload form, its data is converted back to a model again, than to a JSON-representation and sent to the robot.
A Model-View-Controller concept (MVC) for a proper implementation
The qooxWave protocol enables a complex structure of ui-elements containing each other.
Moreover, there are complex events causing complex user input to be sent to the robots. To ensure a proper client-side implementation, we created a model-view-controler concept inside the qooxdoo application. Qooxdoo brings nice classes and interfaces for realizing a MVC layout. To only mention one: you can use data-binding to bind form data to a javascript object automatically. Have a look at the qooxdoo manual for this fancy feature.
Moreover, we created a store object, that converts the application data into a model; this model is converted into a JSON-String and the other way round. The store receives and sends this JSON-String on any server- or client-side event. This is an additional useful abstraction of the application layout. Again, we use data-binding to bind the model (stored in the store) to the actual user interface objects in the qooxdoo application.
As you can see, the client side implementation has a very robust layout and can be easily extended with new features.
Classes related to the client side implementation
The client-side implementation is actually a whole qooxdoo application. The entire project can be found at the sourcefourge project side . The main classes we created for this application are the following:
Application.js (main application class)
Store.js (store object to handle and transfer model)
Upload.js (upload gadget)
Download.js (download gadget)
In addition, we created some Wave objects for debugging outside the Wave (Thanks to Fabian Jakobs from the qooxdoo developer team):
Wave.js
WaveFactory.js
State.js
Participant.js
Server side implementation
On the server side i.e. in robots the MenuItem.java class is used to generate menus, which are just recursively stored MenuItem instances. As the menu system was and is under rapid development, this class is hold as flexible as possible and therefore not as comfortable as it could be. The class also contains the functions for creating JSON-String out of these menus, which can be sent to the menu gadget via the wave. Currently, our main SynBioWave-Robot reads these strings of all other robots in the Wave, translates them back into a Java object, and merges all these objects into one menu object, which is finally transmitted to the gadget.  All these processes are automatically performed within our abstract robot class, developers writing SynBioWave robots do not have to care about that.
Extending Google Wave I/O
Over the past few decades rapid developments in genomic and other molecular research technologies and developments in information technologies have merged to produce a tremendous amount of information related to molecular biology. These huge amounts of data lay the ground for the work of synthetic biologists. By analyzing, modifying and extending these sequences, the synthetic biologists are enabled to build new functionalities and potentially whole genomes. Consequently, one basic feature for the work in synthetic biology is to have full access to this pool of sequence data, provided in different formats. As only file sharing was intended for Google Wave, we were forced to extend the build-in servlet functionality of the Google Wave Java API with the needs for file import/export as well as methods for database access.
Sequence file import/export
Google Wave robots written in the Java programming language are specialized forms of Java HttpServlets.  We extended the Google Wave robot servlet class capabilities not only to serve robot events but to serve file upload and downloads as well. To assure a very threadsave and robust upload functionality, we based the file upload on the well known apache commons-upload project. To avoid any abuse of the file upload, the file upload is directly connected to the sequence creation and is only used if the file contains sequence information in a supported format. Using the newest BioJava classes for parsing the file upload provides an easy way to extend the amount of supported file formats in the near future.
Don't be afraid your sequences could be readable to uninvited people.
Although an additional GnuPG encryption is not implemented yet, all data transfers are enciphered by secure Http (SSL/TLS) connections.
Database access
SynBioWave currently supports DAS access to the iGEM related BioBrick database. SynBioWave implements a simple name browser for the biological parts and allows the user to directly import the fully annotated sequence into the working process.
Internal Database
SynBioWave uses an internal database to track all sequences produced or imported in the working flow. With the datastore browser, SynBioWave provides an intuitive user interface to search and reload these sequences. In this early state, Google Wave only supports robots hosted on Google's own AppEngine application server. Thus, we are currently using Google's Datastore to store the sequences. Google announced that this restriction will be retreated in the future, and robots can be hosted anywhere. To ensure the compatibility to any other database provided by the chosen host, we make use of Suns JDO specification or more precisely the apache JDO2 library.
How to display sequences
Nowadays, every application displays text and pictures. A lot of of applications additionally play audio and video data. But there is no native support for displaying sequence data. SynBioWave currently supports three different ways to display your sequences. There is a simple view for short sequences typed or copied directly to the Wave and an embedded gadget view for longer sequences and sequence comparisons like for example in multiple sequence alignments. Both views provide a clearly represented scaling and increased readability by automatically coloring the sequences according to the sequence type. And in the end there is a circular view for displaying fully featured circular DNA as needed for example in displaying vectors and plasmids.
Perspective
Future releases
Currently, we are planing to continue focusing on the improvement of the framework while Google Wave is still a Preview Version, and adapt it to the new functions Wave will hopefully get in the future.
Version 0.2
By the time when Wave goes to public and has reached final beta state, we will release Version 0.2 of SynBioWave, which will have a mostly completed, stable and well-documented framework that enables developers to create additional robots even more easily than for the iGEM release.
Improvements planed:
Framework
Improved Robot-Robot communication, both via Wave and direct URL-connections
(1)
Native bidirectional Robot-Gadget communication without refreshing the gadget
(1)
More simple menu creation in robots i.e. changing the MenuItem-class to an interface and create a class implementation for every available menu item.
Integrate Callback functions for menu items
Improved sequence display and manipulation, either in a properly-styled
(1)
Inline-Blip
(1)
with scroll bar
(1)
or in a "wave-y" Gadget.
Improving the Model-View-Controller-Concept of the menu-Gadget
Heavily improving the usability with lots of testing and feedback from biologist
(1)
Improving documentation
BioBrick-Robot
Integration of assembly algorithms
Support for different Biobrick standards
Direct part upload to the iGEM server
Blast-Robot
Process the received Blast hits
Other
Some more robots to prove the concept and examples for developers
Version 0.3
Versions 0.3 will make SynBioWave attractive to even more developers by offering them the possibility to write additional robots in Python and by further simplifying the creation of robots with a SynBioWave-Eclipse-plugin. With hopefully many more robots being available at that point, this could be the first release that can be used in labs.
A Python implementation of the SynBioWave framework
An Eclipse-plugin for SynBioWave developing
Many, many more robots
Later Versions
Support for own Wave- and Robot-Servers
(1)
All functions typically needed in Synthetic Biology
(1)
(1)
 : currently not supported by Google Wave and/or Google AppEngine, but announced for the future.
References
[1] Inspired by Wikipedia. Link .
Retrieved from " http://2009.igem.org/Team:Freiburg_software/Project "
Recent changes
What links here
Related changes
Special pages
My preferences
Printable version
Permanent link
Privacy policy
Disclaimers

<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Freiburg_software_Project"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu"><UL><LI class="selected"><A href="/Team:Freiburg_software/Project">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Freiburg_software/Project&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Freiburg_software/Project&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Freiburg_software/Project&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Freiburg_software/Project" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Freiburg software/Project</H1><DIV id="bodyContent"><H3 id="siteSub">From 2009.igem.org</H3><DIV id="custom-header"><DIV id="tabs"><UL><LI><A class="home_active" href="https://2009.igem.org/Team:Freiburg_software"><SPAN>Home</SPAN></A></LI><LI><A class="team_active" href="https://2009.igem.org/Team:Freiburg_software/Team"><SPAN>The Team</SPAN></A></LI><LI><A class="project_active" href="https://2009.igem.org/Team:Freiburg_software/Project"><SPAN>The Project</SPAN></A></LI><LI><A class="code_active" href="https://2009.igem.org/Team:Freiburg_software/Code"><SPAN>The Code</SPAN></A></LI><LI><A class="guide_active" href="https://2009.igem.org/Team:Freiburg_software/UserGuide"><SPAN>User Guide</SPAN></A></LI><LI><A class="notebook_active" href="https://2009.igem.org/Team:Freiburg_software/Notebook"><SPAN>Notebook</SPAN></A></LI><LI><A class="miscellaneous_active" href="https://2009.igem.org/Team:Freiburg_software/Miscellaneous"><SPAN>Miscellaneous</SPAN></A></LI></UL></DIV></DIV><DIV style="text-align: center; margin-top: 15px; float: right;"><P><A href="http://davidn.de/youtube.php?url=large" class="external text" rel="nofollow">Watch a high resolution version here</A></P></DIV><TABLE id="toc" class="toc"><TBODY><TR><TD><DIV id="toctitle"><H2>Contents</H2></DIV><UL><LI class="toclevel-1 tocsection-1"><A href="#Motivation"><SPAN class="tocnumber">1</SPAN><SPAN class="toctext">Motivation</SPAN></A></LI><LI class="toclevel-1 tocsection-2"><A href="#Highlights"><SPAN class="tocnumber">2</SPAN><SPAN class="toctext">Highlights</SPAN></A></LI><LI class="toclevel-2 tocsection-3"><A href="#A_collaborative_web_based_software_for_synthetic_biology_research"><SPAN class="tocnumber">2.1</SPAN><SPAN class="toctext">A collaborative web based software for synthetic biology research</SPAN></A></LI><LI class="toclevel-2 tocsection-4"><A href="#Creating_a_software_interface_on_top_of_Google_Wave"><SPAN class="tocnumber">2.2</SPAN><SPAN class="toctext">Creating a software interface on top of Google Wave</SPAN></A></LI><LI class="toclevel-2 tocsection-5"><A href="#Access_to_a_large_pool_of_sequence_data"><SPAN class="tocnumber">2.3</SPAN><SPAN class="toctext">Access to a large pool of sequence data</SPAN></A></LI><LI class="toclevel-2 tocsection-6"><A href="#Extendable_software_suite"><SPAN class="tocnumber">2.4</SPAN><SPAN class="toctext">Extendable software suite</SPAN></A></LI><LI class="toclevel-2 tocsection-7"><A href="#Pioneering_spirit"><SPAN class="tocnumber">2.5</SPAN><SPAN class="toctext">Pioneering spirit</SPAN></A></LI></UL><LI class="toclevel-1 tocsection-8"><A href="#Existing_technologies"><SPAN class="tocnumber">3</SPAN><SPAN class="toctext">Existing technologies</SPAN></A></LI><LI class="toclevel-2 tocsection-9"><A href="#Google_Wave"><SPAN class="tocnumber">3.1</SPAN><SPAN class="toctext">Google Wave</SPAN></A></LI><LI class="toclevel-2 tocsection-10"><A href="#BioJava"><SPAN class="tocnumber">3.2</SPAN><SPAN class="toctext">BioJava</SPAN></A></LI><LI class="toclevel-2 tocsection-11"><A href="#Qooxdoo"><SPAN class="tocnumber">3.3</SPAN><SPAN class="toctext">Qooxdoo</SPAN></A></LI><LI class="toclevel-1 tocsection-12"><A href="#Software"><SPAN class="tocnumber">4</SPAN><SPAN class="toctext">Software</SPAN></A></LI><LI class="toclevel-2 tocsection-13"><A href="#Architecture"><SPAN class="tocnumber">4.1</SPAN><SPAN class="toctext">Architecture</SPAN></A></LI><LI class="toclevel-3 tocsection-14"><A href="#Robots"><SPAN class="tocnumber">4.1.1</SPAN><SPAN class="toctext">Robots</SPAN></A></LI><LI class="toclevel-3 tocsection-15"><A href="#Gadgets"><SPAN class="tocnumber">4.1.2</SPAN><SPAN class="toctext">Gadgets</SPAN></A></LI><LI class="toclevel-2 tocsection-16"><A href="#Bring_it_together:_The_qooxWave_protocol"><SPAN class="tocnumber">4.2</SPAN><SPAN class="toctext">Bring it together: The qooxWave protocol</SPAN></A></LI><LI class="toclevel-3 tocsection-17"><A href="#Client_side_implementation"><SPAN class="tocnumber">4.2.1</SPAN><SPAN class="toctext">Client side implementation</SPAN></A></LI><LI class="toclevel-3 tocsection-18"><A href="#Server_side_implementation"><SPAN class="tocnumber">4.2.2</SPAN><SPAN class="toctext">Server side implementation</SPAN></A></LI><LI class="toclevel-2 tocsection-19"><A href="#Extending_Google_Wave_I.2FO"><SPAN class="tocnumber">4.3</SPAN><SPAN class="toctext">Extending Google Wave I/O</SPAN></A></LI><LI class="toclevel-3 tocsection-20"><A href="#Sequence_file_import.2Fexport"><SPAN class="tocnumber">4.3.1</SPAN><SPAN class="toctext">Sequence file import/export</SPAN></A></LI><LI class="toclevel-3 tocsection-21"><A href="#Database_access"><SPAN class="tocnumber">4.3.2</SPAN><SPAN class="toctext">Database access</SPAN></A></LI><LI class="toclevel-3 tocsection-22"><A href="#Internal_Database"><SPAN class="tocnumber">4.3.3</SPAN><SPAN class="toctext">Internal Database</SPAN></A></LI><LI class="toclevel-2 tocsection-23"><A href="#How_to_display_sequences"><SPAN class="tocnumber">4.4</SPAN><SPAN class="toctext">How to display sequences</SPAN></A></LI><LI class="toclevel-1 tocsection-24"><A href="#Perspective"><SPAN class="tocnumber">5</SPAN><SPAN class="toctext">Perspective</SPAN></A></LI><LI class="toclevel-2 tocsection-25"><A href="#Future_releases"><SPAN class="tocnumber">5.1</SPAN><SPAN class="toctext">Future releases</SPAN></A></LI><LI class="toclevel-3 tocsection-26"><A href="#Version_0.2"><SPAN class="tocnumber">5.1.1</SPAN><SPAN class="toctext">Version 0.2</SPAN></A></LI><LI class="toclevel-3 tocsection-27"><A href="#Version_0.3"><SPAN class="tocnumber">5.1.2</SPAN><SPAN class="toctext">Version 0.3</SPAN></A></LI><LI class="toclevel-3 tocsection-28"><A href="#Later_Versions"><SPAN class="tocnumber">5.1.3</SPAN><SPAN class="toctext">Later Versions</SPAN></A></LI><LI class="toclevel-1 tocsection-29"><A href="#References"><SPAN class="tocnumber">6</SPAN><SPAN class="toctext">References</SPAN></A></LI></TD></TR></TBODY></TABLE><H1><SPAN class="mw-headline" id="Motivation">Motivation</SPAN></H1><P>Nowadays, the web offers a wide range of tools to communicate, collaborate and share personal data. People share their pictures with Flickr, students interact in social networks like Facebook, programmers contribute to software projects using platforms like Sourceforge. In contrast, science communication is still making little use of the collaborative world wide web. In particular, synthetic biology is highly inter-disciplinary and requires many scientists to work together in order to build complex biological systems like genes, gene assemblies, synthetic protein devices or later even genomes. From the outset, the synthetic biology community has made efforts to cross-link the results of their research in open repositories and wikis. 
We want to push this process to the next level: Why only store and share results? Why not making use of the web to collaborate? Scientist could make the whole process transparent, or even better, design and create data together.
</P><H1><SPAN class="mw-headline" id="Highlights">Highlights</SPAN></H1><H2><SPAN class="mw-headline" id="A_collaborative_web_based_software_for_synthetic_biology_research"> A collaborative web based software for synthetic biology research </SPAN></H2><P>We have created an open-source, synthetic biological software suite called SynBioWave. Based on Google's communication tool Wave, SynBioWave is made for collaborative synthetic biology research comprising parts design and documentation. Moreover, biologists can record and share the process of creating research data and perform basic tasks using SynBioWave. 
</P><P>For example, users can start conversations, invite participants, import sequences from several resources, comment data, perform some tasks and display or export the results. Each participant experiences the others' actions in real time. New participants can track back the whole process using the playback function. And all you need is a browser connected to the internet. Could it be easier to invite colleges to your research?
</P><H2><SPAN class="mw-headline" id="Creating_a_software_interface_on_top_of_Google_Wave"> Creating a software interface on top of Google Wave </SPAN></H2><UL><LI> We created three ways to <A href="/Team:Freiburg_software/Project#How_to_display_sequences" title="Team:Freiburg software/Project">display sequence data</A>, a short sequence view, a gadget view and a circular view.
</LI><LI> We extended Wave's user interface (ui) with a highly dynamic menu system and added new ui-elements such as an upload form for sequence files.
</LI><LI> To realize an easy to use interface for generating user interfaces, we invented the <A href="/Team:Freiburg_software/Project#Bring_it_together:_The_qooxWave_protocol" title="Team:Freiburg software/Project">qooxWave protocol</A>. This protocol defines a client-to-server and server-to-client communication for building ui-elements, event reporting and data transmission.
</LI><LI> The client-side implementation of the <A href="/Team:Freiburg_software/Project#Bring_it_together:_The_qooxWave_protocol" title="Team:Freiburg software/Project">qooxWave protocol</A> makes use of the RIA framework <A href="/Team:Freiburg_software/Project#Qooxdoo" title="Team:Freiburg software/Project">qooxdoo</A>. To ensure a proper implementation of <A href="/Team:Freiburg_software/Project#Bring_it_together:_The_qooxWave_protocol" title="Team:Freiburg software/Project">qooxWave</A>, we designed a robust <A href="/Team:Freiburg_software/Project#Client_side_implementation" title="Team:Freiburg software/Project">store-model-view-controller concept</A>.
</LI><LI> Even though SynBioWave is a web application, its look and feel reminds the user of a desktop application.
</LI></UL><H2><SPAN class="mw-headline" id="Access_to_a_large_pool_of_sequence_data"> Access to a large pool of sequence data </SPAN></H2><UL><LI> SynBioWave inherits Wave's feature to handle common data like rich text documents, graphics, music/video and many more.
</LI><LI> We spend much effort to implement support for a large range of sequence formats, such as FASTA, GenBank and EMBL.
</LI><LI> SynBioWave imports and exports sequence data from/into files.
</LI><LI> SynBioWave supports DAS access to the iGEM related BioBrick database.
</LI><LI> SynBioWave uses an internal database to track all sequences produced or imported in the working flow.
</LI></UL><P>Have a look at the <A href="/Team:Freiburg_software/Project#Extending_Google_Wave_I.2FO" title="Team:Freiburg software/Project">I/O section</A> to learn more about the features mentioned above.
</P><H2><SPAN class="mw-headline" id="Extendable_software_suite"> Extendable software suite  </SPAN></H2><P>To lay ground for an successful open source project, we wrapped our efforts into an easy to implement framework, allowing developers to contribute to SynBioWave. One key feature of this framework is an abstract template class that allows the user to create robots, providing new features, without thinking about sequence I/O, GUI or display issues.
</P><P>To demonstrate this extensible concept, we added one additional robot providing the feature of a Blast search. It turned out, that our concept works! The implementation is really easy. Have a look at the <A href="/Team:Freiburg_software/Code/BlastRobotServlet.java" title="Team:Freiburg software/Code/BlastRobotServlet.java">code</A>.
</P><P>Have a look at the <A href="/Team:Freiburg_software/Project#Architecture" title="Team:Freiburg software/Project">software architecture</A> to explore our framework.
</P><H2><SPAN class="mw-headline" id="Pioneering_spirit"> Pioneering spirit </SPAN></H2><P>To our knowledge, SynBioWave is currently the only approach to write a collaborative web-based biological software, as well as the only bigger project based on Google Wave. 
</P><P>When we first heard of Google Wave, we instantly noticed it could be the solid basis we were looking for to build such a next level biological software suite. When we got access to its developer preview version later, it confirmed our choice, but soon we noticed that we would need a lot of features not yet build-in in Wave, some not yet even planned. 
</P><P>We are the first (and maybe only) developers creating a project consisting of multiple Wave-Robots and therefore had to think about a way to make these robots communicate with each other. Google has not foreseen this need of Robot-Robot-Communication and has not even decided to add this to their Robot-API.
</P><H1><SPAN class="mw-headline" id="Existing_technologies">Existing technologies</SPAN></H1><H2><SPAN class="mw-headline" id="Google_Wave">Google Wave</SPAN></H2><P>Google Wave is &quot;a personal communication and collaboration tool&quot; developed by Google. It is a web-based service, computing platform, and communication protocol designed to merge e-mail, instant messaging, wikis, and social networking. It has a strong collaborative and real-time focus and provides several ways to extend its functionality.<A href="#References"><SMALL><SUP>[1]</SUP></SMALL></A></P><P>Wave basically consists of an open communication protocol similar to email, as well as of client- and server-software. Like email, the protocol aims to be open, decentralized and easy to adapt, but includes modern achievements like multi-user-, real-time-communication and rich formated text with embedded data as well. At the moment, the only working server and client software for Wave is also written by Google, but with the protocol being open-source already, other - Google independent - servers and clients will soon be available.
</P><P>Practically, a typical Wave-conversations - called a wavelet - usually works like this: 
User Alice creates a new Wavelet. She than invites her friend Bob to join the conversation. Bob accepts and can now write messages to the wave. Each message creates a so-called Blip. What differentiates Wave from normal instant-messaging is, that if Alice and Bob decide to write a document together, they can start to edit the same Blip together. Each change they make to the text there is shown to the other one in real time. If they want, they can also use a build-in playback feature similar to the version-history in wikis to review the changes made to the wavelet.
</P><P>In addition, Google has published an API for writing so-called Robots and Gadgets for Wave. While Robots are small programs written in Python or Java, which can participate in Wave similar to normal users, Gadgets are small web pages that can be embedded into a wave conversation.
</P><P>If you want to know more about how we extend and modified this tool to match the needs of synthetic biologists, have a look at the <A href="/Team:Freiburg_software/Project#Software" title="Team:Freiburg software/Project">Software</A> section of this document.
</P><H2><SPAN class="mw-headline" id="BioJava">BioJava</SPAN></H2><P><A href="http://www.biojava.org" class="external text" rel="nofollow">BioJava</A> is an open source project dedicated to providing a Java framework for processing biological data. It provides analytical and statistical routines, parsers for common file formats and allows the manipulation of sequences and 3D structures. The goal of the BioJava project is to facilitate rapid application development for bioinformatics.
</P><P>Having the choice between BioJava und <A href="http://biopython.org" class="external text" rel="nofollow">BioPhyton</A> (the only two programming languages supported by Google Wave), we decided to use BioJava because of its faster growing and better supported library and the scalable, cross-platform and network-aware nature of the Java programming language.
</P><P>For insights into the usage of BioJava in our software, have a look at section <A href="/Team:Freiburg_software/Project#Extending_Google_Wave_I.2FO" title="Team:Freiburg software/Project">Extending Google Wave I/O</A>. 
We plan to integrate support for Python in later versions of SynBioWave.
</P><H2><SPAN class="mw-headline" id="Qooxdoo">Qooxdoo</SPAN></H2><P><A href="http://www.qooxdoo.org" class="external text" rel="nofollow">Qooxdoo</A> is one of the leading frameworks for creating rich internet application (RIAs). RIAs are web applications which are accessed from the browser and commonly made for multi user tasks. In contrast to usual web sites, RIAs look and feel like desktop applications. Building a RIA from scratch is nearly impossible. Therefore qooxdoo provides a platform-independent development tool chain, a state-of-the-art GUI toolkit and an advanced client-server communication layer.
</P><P>Because Wave's user interface is only weakly customizable, qooxdoo is a perfect candidate to extend Wave's user interface with custom toolbars, buttons, forms, context-menus and much more.
</P><P>Have a look at the <A href="/Team:Freiburg_software/Project#Bring_it_together:_The_qooxWave_protocol" title="Team:Freiburg software/Project">qooxWave protocol</A> we created to learn more about how we used qooxdoo in our project.
</P><H1><SPAN class="mw-headline" id="Software">Software</SPAN></H1><H2><SPAN class="mw-headline" id="Architecture">Architecture</SPAN></H2><P>SynBioWave turns Google Wave into a biosynthetic software suite. There are currently two available methods for extending Google Wave, and we are making use of both (See <A href="/Team:Freiburg_software/Project#Google_Wave" title="Team:Freiburg software/Project"> Google Wave</A> for an introduction):
</P><OL><LI> Robots
</LI><LI> Gadgets
</LI></OL><H3><SPAN class="mw-headline" id="Robots">Robots</SPAN></H3><P>Robots are automated participants, able to modify the wavelets' contents they have joined and interact with real participants. Using Google's Java client library for Robots gives us the possibility to implement biosynthetic functionality provided by the BioJava library. We created the <B>SynBioWave Robot</B> as the core of our extension. Adding this robot to a wavelet activates SynBioWave. There are <I>additional robots</I> providing specific functions when added to a wavelet. The <I>SynBioWave Robot</I> is responsible for:
</P><UL><LI> Organization of all SynBioWave functions represented by <I>additional robots</I></LI><LI> Extending Wave's user interface with SynBioWave specific elements using our <A href="/Team:Freiburg_software/Project#Bring_it_together:_The_qooxWave_protocol" title="Team:Freiburg software/Project">qooxWave protocol</A></LI><LI> Storing the important information written to the wave in an external database
</LI><LI> Providing basic functionality like 
</LI><LI> Import/export of sequences
</LI><LI> Rendering and displaying of sequences
</LI><LI> Circular view
</LI><LI> BioBrick communication (searching and importing biological parts)
</LI></UL><P><B>Additional robots extending SynBioWave functionality</B></P><P>To extend SynBioWave with new biosynthetic functions, one can use additional robots. Adding such a robot to an active SynBioWave wavelet (a wavelet that contains the <I>SynBioWave Robot</I>), enables this function to all users participating in this wave. For SynBioWave users it is very easy to customize and extend SynBioWave. A user searches the robot representing a certain function and adds it to the wavelet he is working with. But this is not the only benefit! This modular architectures makes it very easy for other developers to create additional robots. To facilitate contribution, we provide an abstract <B>SynBioWave Template</B> class. Using this class dramatically simplifies additional robot creation. The developer neither needs to worry about Wave development nor about SynBioWave integration (a minimal understanding of both is still needed). Therefore, one can concentrate on biosynthetic developments.
</P><P><B>Organizing a multi robot system</B></P><P>As we were testing this concept of multiple robots in one and the same conversation, it became quite clear that we needed to organize the way the robots work and interact: With different robots all listening to different (or maybe even the same) events - editing text, writing messages and so on - we ended up in great chaos in our initial tests. So we decided to extend our framework to provide a standard in- and output for robots.
For the input part, we created a menu, which dynamically displays all the functions of the robots in the current wave. As Google has not foreseen this need of a standardized and easy-to-use input method for Wave robots, we had to create this from scratch and implemented it using a Gadget. Moreover, we invented the so-called <A href="/Team:Freiburg_software/Project#Bring_it_together:_The_qooxWave_protocol" title="Team:Freiburg software/Project">qooxWave protocol</A> for a standardized communication between the robots and this menu gadget.
</P><P>To organize the output of the robots, we created a standardized sequence display. At the moment, the user can choose if he likes to have the sequences either directly in the wave, which feels more &quot;natural&quot;, or inside a Gadget, which is currently much more usable because of strict limitations to text-formatting inside Google Wave. Most likely, all sequences will be written directly in the wave in the future as Google has announced to boost the layout options of Wave dramatically.
</P><H3><SPAN class="mw-headline" id="Gadgets">Gadgets</SPAN></H3><P>The SynBioWave robots could be thought of some kind of program logic. They are running somewhere in the cloud, process and organize data. Gadgets come into play, when data such as sequences are displayed inside a Wave. Moreover Gadgets offer the possibility to insert custom user interfaces which are essential for manipulating and managing the biological data. Gadgets are little websites included in a wavelet and communicating with it via Google's Wave API. So you could think of gadgets as some kind of visible objects, that are essential for the integration of biological data into Wave.
</P><P><B>SynBioWave's user interface</B></P><P>The possibilities Google Wave currently provides to customize its user interface are less then weak. To realize some advanced features like upload forms for DNA sequence files or ,toolbars bundling SynBioWave's functionality we used Gadgets. The SynBioWave robot dynamically creates a gadget containing a toolbar. It adds all user-interface-elements that correspond to functions provided by the SynBioWave robot itself and by additional robots. The Gadgets sends events and input data from the user back to the robots. For this purpose, we introduced the <A href="/Team:Freiburg_software/Project#Bring_it_together:_The_qooxWave_protocol" title="Team:Freiburg software/Project"> qooxWave protocol</A>.
</P><H2><SPAN class="mw-headline" id="Bring_it_together:_The_qooxWave_protocol">Bring it together: The qooxWave protocol</SPAN></H2><P>We invented the qooxWave protocol to realize an easy to use interface for creating graphical user interfaces (GUI) inside a wave from a robot. The general goal is to provide one abstract robot class for implementing new function into SynBioWave (each function is provided by a <A href="/Team:Freiburg_software/Project#Robots" title="Team:Freiburg software/Project">robot</A>). The programmer who uses this class does not need to worry about the client side GUI implementation. This protocol ensures easy to use server side function, that automatically builds the client side GUI.
</P><P>The protocol defines a server-to-client and client-to-server communication. This communication contains
</P><UL><LI> a server-to-client communication for building client-side GUI elements from server side (so a server side robot can create a client side button for example)
</LI><LI> a client-to-server communication for reporting events fired in the client side GUI and to transfer user input data to the robots (so the server knows when the user clicks a button for example)
</LI></UL><P>The communication is realized via JSON-Strings that are stored inside a gadgets state object. Both, server (robot) and client (gadget) can access the state object and they can both react on changes of this state object (this is provided by the google wave API). 
</P><P>For a detailed description/definition of the qooxWave protocol, we created an <A href="/Team:Freiburg_software/Project/qooxWave-details" title="Team:Freiburg software/Project/qooxWave-details">external page</A>, which might be interesting for those deeply interested or planning to write SynBioWave robots.
</P><H3><SPAN class="mw-headline" id="Client_side_implementation">Client side implementation</SPAN></H3><DIV class="thumb tright"><DIV class="thumbinner" style="width:182px;"><DIV class="thumbcaption">qooxdoo inside a gadget</DIV></DIV></DIV><P>The client-side implementation of qooxWave is based on a <A href="/Team:Freiburg_software/Project#Qooxdoo" title="Team:Freiburg software/Project">qooxdoo</A> application loaded into a gadget inside the Wave (have a look at the screenshot on the right). This qooxdoo application - written entirely in JavaScript - communicates with the <A href="/Team:Freiburg_software/Project#Robots" title="Team:Freiburg software/Project">SynBioWave Robot</A> via JSON-Strings using a state object provided by the Wave API. The state object is actually designed for gadget-robot communication. But it only supports String-Data. This is why we use JSON to transmit more complex objects.
</P><P>The qooxdoo application receives a JSON-object from the robot containing a GUI-structure. It parses this object and dynamically adds the ui-elements. On the other hand, the application sends user input back to the robot, also in form of JSON-Strings.
</P><P>As an example, the robot could send a JSON-String containing information about a toolbar, its menu items - let's say just a button labeled upload - and information for an upload form that opens when clicking the button. The JSON-String is modeled into a certain JavaScript object (to be precise: qooxdoo objects) and then displayed by the qooxdoo application. When the user submits the upload form, its data is converted back to a model again, than to a JSON-representation and sent to the robot.
</P><P><B>A Model-View-Controller concept (MVC) for a proper implementation</B></P><P>The qooxWave protocol enables a complex structure of ui-elements containing each other. Moreover, there are complex events causing complex user input to be sent to the robots. To ensure a proper client-side implementation, we created a model-view-controler concept inside the qooxdoo application. Qooxdoo brings nice classes and interfaces for realizing a MVC layout. To only mention one: you can use data-binding to bind form data to a javascript object automatically. Have a look at the <A href="http://qooxdoo.org/documentation/0.8/data_binding" class="external text" rel="nofollow">qooxdoo manual</A> for this fancy feature.
</P><P>Moreover, we created a store object, that converts the application data into a model; this model is converted into a JSON-String and the other way round. The store receives and sends this JSON-String on any server- or client-side event. This is an additional useful abstraction of the application layout. Again, we use data-binding to bind the model (stored in the store) to the actual user interface objects in the qooxdoo application.
</P><P>As you can see, the client side implementation has a very robust layout and can be easily extended with new features.
</P><P><B>Classes related to the client side implementation</B></P><P>The client-side implementation is actually a whole qooxdoo application. The entire project can be found at the <A href="http://synbiowave.svn.sourceforge.net/viewvc/synbiowave/trunk/gui/qooxwaveClient/" class="external text" rel="nofollow">sourcefourge project side</A>. The main classes we created for this application are the following:
</P><UL><LI><A href="/Team:Team:Freiburg_software/Code/qooxdoo/Application.js" title="Team:Team:Freiburg software/Code/qooxdoo/Application.js">Application.js</A> (main application class)
</LI><LI><A href="/Team:Team:Freiburg_software/Code/qooxdoo/Store.js" title="Team:Team:Freiburg software/Code/qooxdoo/Store.js">Store.js</A> (store object to handle and transfer model)
</LI><LI><A href="/Team:Team:Freiburg_software/Code/qooxdoo/Upload.js" title="Team:Team:Freiburg software/Code/qooxdoo/Upload.js">Upload.js</A> (upload gadget)
</LI><LI><A href="/Team:Team:Freiburg_software/Code/qooxdoo/Download.js" title="Team:Team:Freiburg software/Code/qooxdoo/Download.js">Download.js</A> (download gadget)
</LI></UL><P>In addition, we created some Wave objects for debugging outside the Wave (Thanks to Fabian Jakobs from the qooxdoo developer team):
</P><UL><LI><A href="/Team:Team:Freiburg_software/Code/qooxdoo/Wave.js" title="Team:Team:Freiburg software/Code/qooxdoo/Wave.js">Wave.js</A></LI><LI><A href="/Team:Team:Freiburg_software/Code/qooxdoo/WaveFactory.js" title="Team:Team:Freiburg software/Code/qooxdoo/WaveFactory.js">WaveFactory.js</A></LI><LI><A href="/Team:Team:Freiburg_software/Code/qooxdoo/State.js" title="Team:Team:Freiburg software/Code/qooxdoo/State.js">State.js</A></LI><LI><A href="/Team:Team:Freiburg_software/Code/qooxdoo/Participant.js" title="Team:Team:Freiburg software/Code/qooxdoo/Participant.js">Participant.js</A></LI></UL><H3><SPAN class="mw-headline" id="Server_side_implementation">Server side implementation</SPAN></H3><P>On the server side i.e. in robots the <A href="/Team:Freiburg_software/Code/MenuItem.java" title="Team:Freiburg software/Code/MenuItem.java">MenuItem.java</A> class is used to generate menus, which are just recursively stored MenuItem instances. As the menu system was and is under rapid development, this class is hold as flexible as possible and therefore not as comfortable as it could be.
The class also contains the functions for creating JSON-String out of these menus, which can be sent to the menu gadget via the wave. Currently, our main SynBioWave-Robot reads these strings of all other robots in the Wave, translates them back into a Java object, and merges all these objects into one menu object, which is finally transmitted to the gadget. 
All these processes are automatically performed within our abstract robot class, developers writing SynBioWave robots do not have to care about that.
</P><H2><SPAN class="mw-headline" id="Extending_Google_Wave_I.2FO">Extending Google Wave I/O</SPAN></H2><P>Over the past few decades rapid developments in genomic and other molecular research technologies and developments in information technologies have merged to produce a tremendous amount of information related to molecular biology. These huge amounts of data lay the ground for the work of synthetic biologists. By analyzing, modifying and extending these sequences, the synthetic biologists are enabled to build new functionalities and potentially whole genomes. Consequently, one basic feature for the work in synthetic biology is to have full access to this pool of sequence data, provided in different formats. As only file sharing was intended for Google Wave, we were forced to extend the build-in servlet functionality of the Google Wave Java API with the needs for file import/export as well as methods for database access.
</P><H3><SPAN class="mw-headline" id="Sequence_file_import.2Fexport">Sequence file import/export</SPAN></H3><P>Google Wave robots written in the Java programming language are specialized forms of Java HttpServlets. 
We extended the Google Wave robot servlet class capabilities not only to serve robot events but to serve file upload and downloads as well. To assure a very threadsave and robust upload functionality, we based the file upload on the well known apache commons-upload project. To avoid any abuse of the file upload, the file upload is directly connected to the sequence creation and is only used if the file contains sequence information in a supported format. Using the newest BioJava classes for parsing the file upload provides an easy way to extend the amount of supported file formats in the near future.
</P><P>Don't be afraid your sequences could be readable to uninvited people.
Although an additional GnuPG encryption is not implemented yet, all data transfers are enciphered by secure Http (SSL/TLS) connections.
</P><H3><SPAN class="mw-headline" id="Database_access">Database access</SPAN></H3><P>
SynBioWave currently supports DAS access to the iGEM related BioBrick database. SynBioWave implements a simple name browser for the biological parts and allows the user to directly import the fully annotated sequence into the working process.
</P><H3><SPAN class="mw-headline" id="Internal_Database">Internal Database</SPAN></H3><P>
SynBioWave uses an internal database to track all sequences produced or imported in the working flow. With the datastore browser, SynBioWave provides an intuitive user interface to search and reload these sequences. In this early state, Google Wave only supports robots hosted on Google's own AppEngine application server. Thus, we are currently using Google's Datastore to store the sequences. Google announced that this restriction will be retreated in the future, and robots can be hosted anywhere. To ensure the compatibility to any other database provided by the chosen host, we make use of Suns JDO specification or more precisely the apache JDO2 library.</P><H2><SPAN class="mw-headline" id="How_to_display_sequences">How to display sequences</SPAN></H2><P>
Nowadays, every application displays text and pictures. A lot of of applications additionally play audio and video data. But there is no native support for displaying sequence data. SynBioWave currently supports three different ways to display your sequences. There is a simple view for short sequences typed or copied directly to the Wave and an embedded gadget view for longer sequences and sequence comparisons like for example in multiple sequence alignments. Both views provide a clearly represented scaling and increased readability by automatically coloring the sequences according to the sequence type. And in the end there is a circular view for displaying fully featured circular DNA as needed for example in displaying vectors and plasmids.</P><H1><SPAN class="mw-headline" id="Perspective">Perspective</SPAN></H1><H2><SPAN class="mw-headline" id="Future_releases">Future releases</SPAN></H2><P>Currently, we are planing to continue focusing on the improvement of the framework while Google Wave is still a Preview Version, and adapt it to the new functions Wave will hopefully get in the future. 
</P><H3><SPAN class="mw-headline" id="Version_0.2">Version 0.2</SPAN></H3><P>By the time when Wave goes to public and has reached final beta state, we will release Version 0.2 of SynBioWave, which will have a mostly completed, stable and well-documented framework that enables developers to create additional robots even more easily than for the iGEM release.  
</P><P>Improvements planed:
</P><P><B>Framework</B></P><UL><LI> Improved Robot-Robot communication, both via Wave and direct URL-connections <SUP><SMALL>(1)</SMALL></SUP></LI><LI> Native bidirectional Robot-Gadget communication without refreshing the gadget <SUP><SMALL>(1)</SMALL></SUP></LI><LI> More simple menu creation in robots i.e. changing the MenuItem-class to an interface and create a class implementation for every available menu item. 
</LI><LI> Integrate Callback functions for menu items
</LI><LI> Improved sequence display and manipulation, either in a properly-styled<SUP><SMALL>(1)</SMALL></SUP> Inline-Blip<SUP><SMALL>(1)</SMALL></SUP> with scroll bar<SUP><SMALL>(1)</SMALL></SUP> or in a &quot;wave-y&quot; Gadget.  
</LI><LI> Improving the Model-View-Controller-Concept of the menu-Gadget 
</LI><LI> Heavily improving the usability with lots of testing and feedback from biologist<SUP><SMALL>(1)</SMALL></SUP></LI><LI> Improving documentation 
</LI></UL><P><B>BioBrick-Robot </B></P><UL><LI> Integration of assembly algorithms
</LI><LI> Support for different Biobrick standards 
</LI><LI> Direct part upload to the iGEM server
</LI></UL><P><B>Blast-Robot</B></P><UL><LI> Process the received Blast hits
</LI></UL><P><B>Other</B></P><UL><LI> Some more robots to prove the concept and examples for developers
</LI></UL><H3><SPAN class="mw-headline" id="Version_0.3">Version 0.3</SPAN></H3><P>Versions 0.3 will make SynBioWave attractive to even more developers by offering them the possibility to write additional robots in Python and by further simplifying the creation of robots with a SynBioWave-Eclipse-plugin. With hopefully many more robots being available at that point, this could be the first release that can be used in labs. 
</P><UL><LI> A Python implementation of the SynBioWave framework
</LI><LI> An Eclipse-plugin for SynBioWave developing
</LI><LI> Many, many more robots
</LI></UL><H3><SPAN class="mw-headline" id="Later_Versions">Later Versions</SPAN></H3><UL><LI> Support for own Wave- and Robot-Servers <SUP><SMALL>(1)</SMALL></SUP></LI><LI> All functions typically needed in Synthetic Biology <SUP><SMALL>(1)</SMALL></SUP></LI></UL><P><SUP><SMALL>(1)</SMALL></SUP> : currently not supported by Google Wave and/or Google AppEngine, but announced for the future.
</P><H1><SPAN class="mw-headline" id="References">References</SPAN></H1><P>[1] Inspired by Wikipedia. <A href="http://en.wikipedia.org/w/index.php?title=Google_Wave&amp;oldid=320807113" class="external text" rel="nofollow">Link</A>.
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2009.igem.org/Team:Freiburg_software/Project">http://2009.igem.org/Team:Freiburg_software/Project</A>&quot;</DIV></DIV></DIV><DIV id="footer-box"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Freiburg_software/Project" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Freiburg_software/Project" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Freiburg_software/Project&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Freiburg_software/Project&amp;oldid=168388" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2009.igem.org:Privacy_policy" title="2009.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2009.igem.org:General_disclaimer" title="2009.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
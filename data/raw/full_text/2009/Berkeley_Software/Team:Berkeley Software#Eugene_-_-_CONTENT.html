<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Berkeley_Software_Eugene"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu"><UL><LI class="selected"><A href="/Team:Berkeley_Software/Eugene">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Berkeley_Software/Eugene&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Berkeley_Software/Eugene&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Berkeley_Software/Eugene&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Berkeley_Software/Eugene" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Berkeley Software/Eugene</H1><DIV id="bodyContent"><H3 id="siteSub">From 2009.igem.org</H3><P><UL id="links"><LI><A title="Home" href="https://2009.igem.org/Team:Berkeley_Software">Home</A></LI><LI><A title="Project" href="https://2009.igem.org/Team:Berkeley_Software/Project">Project</A></LI><LI><A title="Team" href="https://2009.igem.org/Team:Berkeley_Software/Team">Team</A></LI><LI><A title="Notebooks" href="https://2009.igem.org/Team:Berkeley_Software/Notebook">Notebooks</A></LI><LI><A title="Downloads" href="https://2009.igem.org/Team:Berkeley_Software/Downloads">Downloads</A></LI><LI><A title="Misc" href="https://2009.igem.org/Team:Berkeley_Software/Misc">Miscellaneous</A></LI></UL></P><DIV id="rightSideBox"><P><UL id="imap"><LI id="Eugene"><STRONG class="selflink">Eugene</STRONG></LI><LI id="Spectacles"><A href="/Team:Berkeley_Software/Spectacles" title="Team:Berkeley Software/Spectacles">Spectacles</A></LI><LI id="Kepler"><A href="/Team:Berkeley_Software/Kepler" title="Team:Berkeley Software/Kepler">Kepler</A></LI><LI id="DataModel"><A href="/Team:Berkeley_Software/Data_Model" title="Team:Berkeley Software/Data Model">Data Model</A></LI></UL></P></DIV><H1 id="sectionTitle">
Eugene
</H1><H3><SPAN class="mw-headline" id="Introduction">Introduction</SPAN></H3><DIV id="intro"><DIV class="thumb tright"><DIV class="thumbinner" style="width:114px;"><DIV class="thumbcaption"><SPAN style="font-family: Georgia, serif;">Eugene - Red-headed stepchild and language (Courtesy of <A href="http://christinetsin.designbinder.com/" class="external text" rel="nofollow">Christine Tsin</A>)</SPAN></DIV></DIV></DIV><P><FONT size="4">W</FONT>ith the rise of partification in synthetic biology, there needs to be a formal specification to describe standard biological parts, especially when designing complex devices. The specification needs to be both human-writable and human-readable, a language that raises the level of abstraction where bioengineers can work. Eugene is such a language. Engineering at the part level requires both flexibility and rigidity. Eugene allows the user to mix custom parts with predefined parts from established databases. Parts can encapsulate an arbitrary amount of information, anything from a DNA sequence to experimental history. When designing a device in Eugene, parts can be freely stitched together on a whim, or strictly joined together based on rules. The design process is meant to be systematic yet intuitive. The user considers what information parts include, constructs parts to be used in the design, enforces restrictions on how parts can interact, and creates devices that are composites of the parts or other devices. Being a textual design, a device specified in Eugene is portable and easily lends itself to being translated into other formats, such as XML. In synthetic biology, the notion of a part changes regularly and is debated tirelessly. Thus, Eugene tries to be adaptable and expressive in any climate. This page goes into the language specification in detail. We break the discussion up into four sections. We first discuss the language definition. Here we provide the basics of the language and how to construct a design using Eugene. Next we discuss some <A href="https://2009.igem.org/Team:Berkeley_Software/Eugene_Examples" class="external text" rel="nofollow">example designs created with Eugene</A>. This is followed by a discussion on how the language is <A href="https://2009.igem.org/Team:Berkeley_Software/Eugene_Implementation" class="external text" rel="nofollow">implemented and the data structures required</A>. Finally we provide some <A href="https://2009.igem.org/Team:Berkeley_Software/Eugene_Results" class="external text" rel="nofollow">sample results</A> which illustrate the power of Eugene when applied to a number of published designs. Each section can be accessed with the buttons provided. Enjoy!</P></DIV><DIV id="sectionContent"><SPAN id="Language_Definition"><H3><SPAN class="mw-headline" id="Language_Definition">Language Definition</SPAN></H3></SPAN><P>In this section we describe the elements in the language. These involve: <A href="#Primitives">primitive data types</A>, <A href="#Properties">properties</A>, <A href="#Parts">parts</A>, <A href="#Devices">devices</A>, <A href="#Rules">rules</A>, <A href="#ConditionalSt">conditional execution</A>, and <A href="#Functions">functions</A>. The relationships between these language elements are shown in Figure 1. Here you can see that each subsequent category is built upon the previous category.
</P><DIV class="thumb tleft"><DIV class="thumbinner" style="width:452px;"><DIV class="thumbcaption"><P style="text-align: center;"><FONT size="2"><SPAN style="font-family: Georgia, serif;">Figure 1: Relationship between Eugene Categories</SPAN></FONT></P></DIV></DIV></DIV><P><SPAN id="Primitives"><B><FONT size="3">Primitives </FONT></B></SPAN>
The language supports five predefined primitives. These are txt, num, boolean, txt[], and num[]. Strings (sequences of characters) are represented through the data type “txt”, where the actual text is specified in double quotes. Real numbers and integers are supported by the data type “num” and logical values by the data type “boolean”.  Ordered lists of num and txt values can be created and individual members inside a list accessed by specifying an integer in the range from 0 to |List| - 1. 
Examples (1) and (2) are two real code snippets of how primitives can be specified in Eugene. “listOfSequences” is simply a list of 3 arbitrary DNA sequences. “specificSequence” is the last element of “listOfSequences” (i.e. “ATCG”). Examples (3) and (4) show how the data type “num” can support integers and decimals.</P><P style="text-align: right;"><A href="#Language_Definition">Back Up</A></P><P><SPAN id="Properties"><B><FONT size="3">Properties</FONT></B></SPAN>
Properties represent characteristics of interest and are defined by primitives and associated with Parts. For example a user could define a property “Sequence” (the DNA sequence), ID (the uuid for a relational database which may hold the part), or Orientation (e.g. a forward or backward promoter). Examples 5-8 show how such properties would be defined. Property definitions must be defined by the five primitive types. In <A href="#Part_Definition">Part definitions</A> properties will be bound to that Part as placeholders for the instantiation of values in <A href="#Part_Declaration">Part declarations</A>. Properties have to be defined before Parts can use them. The user can create new Property labels or use those created by other users and captured in <A href="#Header_Files">header files</A>. For example, the following Properties are predefined in the header file PropertyDefinition.h and do not need to be defined again if the header file is included in the main program:</P><P style="text-align: right;"><A href="#Language_Definition">Back Up</A></P><P><SPAN id="Parts"><B><FONT size="3">Parts</FONT></B></SPAN>
The data type Part represents a standard biological Part. A Part can be defined empty initially and then property labels can be added through the function addProperties() or properties can be bound to a Part during the definition. </P><P><SPAN id="Part_Definition"><FONT size="3"><I>Part Definition</I></FONT></SPAN>
Part definitions do not construct any Parts, but rather specify which Parts can be constructed. This can be done in the header file or in the main program. When the header file PartDefintion.h and PropertyDefintion.h are included, the following Parts and their corresponding property labels are predefined. For instance, the Part “Promoter” will have three properties associated with it and all instances of Promoter will inherit ID, Sequence and Orientation:</P><P>If the properties are unknown during Part Definition process, the Part can be defined either empty or with the known properties. Later property labels can be added through the function addProperties() provided the property labels have been created beforehand. RBS will have four property labels after the following statement:</P><P><SPAN id="Part_Declaration"><FONT size="3"><I>Part Declaration</I></FONT></SPAN>
Part declarations make instances of predefined Parts and assign values to their properties. If the declaration specifies a list of values, it is assumed that every property will be assigned a value, where the order of the values corresponds to the order of the properties in the Part Definition as shown in example (17). Otherwise, a “dot notation“ followed by the name of the property can be employed, where the order becomes irrelevant as specified in the example below (16). The Part instance BBa_K112234_rbs has three properties associated with the Part RBS. These are ID, Sequence and Orientation. The identification label of a particular part from a database is stored in the ID placeholder to allow future access to the database. Sequence stores the DNA of a Part, while Orientation specifies the direction of the Part. Since dot notation is used, the ID value instantiation can be left out from the statement. Part declarations can be found in the header file PartDeclarations.h and are predefined if the header files are included in the main program. 
</P><P style="text-align: right;"><A href="#Language_Definition">Back Up</A></P><P><SPAN id="Devices"><B><FONT size="3">Devices</FONT></B></SPAN>
Devices represent a composite of standard biological Parts and/or other Devices. In a Device declaration, the same Part and/or device can be used more than once. Property values of devices can be accessed with the dot operator; however, the value is the union of the property values of its members returned as a list. If the property is a txt or num, a txt[] or a num[] is returned. If the property is a txt[] or a num[], a txt[] or a num[] is also returned that consists of the lists appended together. For example the sequence of Device BBa_K112133 is the ordered union of the sequence of Part BBa_K112126 and the Device BBa_K112234. These two Devices are shown in Figures 2a and 2b, where the icon figures use true <A href="http://openwetware.org/wiki/Endy:Notebook/BioBrick_Open_Graphical_Language" class="external text" rel="nofollow">Visual BioBrick Open Language symbols (vBOL)</A> icon graphic.</P><P align="center"><B>Table 1: Relationship between vBOL and Eugene</B></P><TABLE border="1" cellpadding="8" align="center"><FONT size="2"><SPAN style="font-family: Georgia, serif;"><TBODY><TR><TH>vBOL</TH><TH>Description</TH><TH>Eugene</TH></TR><TR><TD><B>Figure 2a:</B><A href="http://partsregistry.org/Part:BBa_K112133" class="external text" rel="nofollow">Device BBa_K112133</A>, consisting of one <A href="http://partsregistry.org/Part:BBa_K112126" class="external text" rel="nofollow">Part Promoter BBa_K112126</A> and one <A href="http://partsregistry.org/Part:BBa_K112234" class="external text" rel="nofollow">Device BBa_K112234</A></TD><TD>Device BBa_K112133(BBa_K112126, BBa_K112234);  </TD></TR><TR><TD><B>Figure 2b</B>: <A href="http://partsregistry.org/Part:BBa_K112234" class="external text" rel="nofollow">Device BBa_K112234</A>, consisting of one  Part Ribosome Binding Site and one Part Open Reading Frame</TD><TD>Device BBa_K112234(BBa_K112234_rbs, BBa_K112234_orf); </TD></TR></TBODY></SPAN></FONT></TABLE><P>Individual Parts can be accessed through the use of square brackets and an index. The first member is indexed at zero. Square brackets can be stacked in the case of devices within devices. To access the first element BBa_K112234_rbs of Device BBa_K112234 through Device BBa_K112133, the following notation is supported:</P><P style="text-align: right;"><A href="#Language_Definition">Back Up</A></P><P><SPAN id="Rules"><B><FONT size="3">Rules</FONT></B></SPAN>
The specification of rules provides the ability to validate Device declarations. Rule declarations in themselves do not perform the validation. They have to be “noted”, “asserted” or used as expressions inside an if-statement to give meaning. Rule declarations are single statements consisting of a left and right operand and one rule operator. The rule operators BEFORE, AFTER, WITH, NOTWITH, NEXTTO, NOTCONTAINS, NOTMORETHAN can be applied to Part instances or Device instances. Property values of Part/Device instances or primitives in relation with one Part/Device can be operators in rule declarations when using the relational operators &lt;, &lt;=, &gt;, &gt;=, !=, ==. These operators are overloaded when evaluating text and the text is compared according to alphabetical meaning. Table 2 provides a summary of the operators for Eugene rules.</P><P align="center"><B>Table 2: Eugene Operators for Specifying Rules</B></P><TABLE border="1" align="center" cellpadding="8"><FONT size="2"><SPAN style="font-family: Georgia, serif;"><TBODY><TR><TH colspan="2" align="left">Compositional Operators</TH></TR><TR><TD>BEFORE</TD><TD>operand 1 appears before operand 2 on devices</TD></TR><TR><TD>AFTER</TD><TD>operand 1 appears after operand 2 on devices</TD></TR><TR><TD>WITH</TD><TD>operand 1 appears with operand 2 on devices</TD></TR><TR><TD>NOTWITH</TD><TD>operand 1 does not appear with operand 2 on devices</TD></TR><TR><TD>NEXTTO</TD><TD>operand 1 is adjacent to operand 2 on devices</TD></TR><TR><TD>NOTMORETHAN</TD><TD>operand 1 (a part instance) occurs not more than operand 2 times in a device</TD></TR><TR><TD>NOTCONTAINS</TD><TD>unary operator, where operand 2 is not contained in device</TD></TR><TR><TH align="left" colspan="2">Comparison Operators</TH></TR><TR><TD>&lt;</TD><TD>less than for numbers, comes before alphabetically for text</TD></TR><TR><TD>&lt;=</TD><TD>less than or equal to for numbers, comes before alphabetically or is equal to for text</TD></TR><TR><TD>&gt;</TD><TD>greater than for numbers, comes after alphabetically for text</TD></TR><TR><TD>&gt;=</TD><TD>greater than or equal for numbers, comes after alphabetically or is equal to for text</TD></TR><TR><TD>!=</TD><TD>not equal to</TD></TR><TR><TD>==</TD><TD>equal to</TD></TR><TR><TH align="left" colspan="2">Boolean Operators</TH></TR><TR><TD>AND</TD><TD>operand 1 AND operand 2</TD></TR><TR><TD>OR</TD><TD>operand 1 OR operand 2</TD></TR><TR><TD>NOT</TD><TD>NOT operand</TD></TR></TBODY></SPAN></FONT></TABLE><P align="center"><B>Table 3: Examples of Rule Declarations</B></P><TABLE border="1" align="center" cellpadding="8"><FONT size="2"><SPAN style="font-family: Georgia, serif;"><TBODY><TR><TH>Eugene Syntax</TH><TH width="50%">Description</TH></TR><TR><TD>Rule r1(BBa_K112234_rbs BEFORE BBa_K11223_orf);</TD><TD>Illustrates a rule where all Parts BBa_K112234_rbs have to come before all Parts BBa_K11223_orf</TD></TR><TR><TD>Rule r2(BBa_K112234_rbs WITH BBa_K112234_orf);</TD><TD>Illustrates a rule where the Part BBa_K112234_rbs has to be contained together with BBa_K112234_orf inside a Device</TD></TR><TR><TD>Rule r3(BBa_K112126 NEXTTO BBa_K112234);</TD><TD>Illustrates a rule where the Part BBa_K112126 has to be next to BBa_K112234 when a Device is declared</TD></TR><TR><TD>num x = 2; 
Rule r4(BBa_K112234_rbs NOTMORETHAN x);</TD><TD>Illustrates a rule where the Part BBa_K112234_rbs cannot occur more than x (=2) times in a Devie</TD></TR><TR><TD>Rule r5(NOTCONTAINS BBa_B0032);</TD><TD>Illustrates a rule where a Device cannot contain the Part BBa_B0032</TD></TR><TR><TD>Rule r6(BBa_K112234_rbs.Sequence != BBa_K112234_orf.Sequence);</TD><TD>Illustrates a rule that checks whether the sequence of BBa_K112234_rbs is equivalent to the sequence of BBa_K112234_orf</TD></TR><TR><TD>Rule r7(BBa_K112234_rbs.RelativeStrength &gt; BBa_B0032.RelativeStrength);</TD><TD>Illustrates the comparison of Property values of Parts, where the “RelativeStrength” Property value for Part BBa_K112234_rbs has to be greater than the “RelativeStrength” Property value for Part BBa_B0032</TD></TR><TR><TD>num relativeS = BBa_B0032.RelativeStrength; Rule r8(p.RelativeStrength &gt; relativeS);</TD><TD>Shows a similar comparison but uses the variable “relativeS” for comparison</TD></TR></TBODY></SPAN></FONT></TABLE><P style="text-align: right;"><A href="#Language_Definition">Back Up</A></P><P><B><FONT size="3">Asserting and Noting Rules</FONT></B>
In order to take effect, rules need to be “asserted” or “noted”, once they are declared. The scopes of all assert or note statements encompass every new Device. Every time a new Device is declared and provided “Assertions” and “Note” statements exist, the validation process is performed on the newly created Device. Rule instances can be combined with each other through the use of the logical operators AND, OR, NOT in the statements. The difference between rule assertions and rule notes lies in the strength of the consequence once a violation is found. If no violation is found the program continues running.<FONT size="3"><I>Rule Assertion</I></FONT>
These statements are strong assertions and the program terminates with an error once a Device composition violates the statement. The following statement will check if BBa_K112234_rbs is not contained together with BBa_K112234_orf in the Device and their sequences should not be equal. In this case an error will terminate the program since both parts are components of the device, therefore violating the Assert statement.</P><P><FONT size="3"><I>Rule Notes</I></FONT>
Notes issue warnings in the output when the violation occurs. But the program continues running. In the following example the Device BBa_K112133 meets the first note’s condition. However, the next note is violated and the program will issue a warning.</P><P style="text-align: right;"><A href="#Language_Definition">Back Up</A></P><P><SPAN id="ConditionalSt"><B><FONT size="3">Conditional Statements</FONT></B></SPAN>
The use of conditional statements breaks up the flow of execution and allows certain blocks of code to be executed.  Eugene supports two kinds of if-statements to achieve this: Rule validating if-statement and standard if-statement. The three logical operators AND, OR, NOT can combine statements of each type but not together.<FONT size="3"><I>Rule validating if-Statement</I></FONT>
Rules can be checked not just through Assert and Note statements but also in an if-statement. In this approach only specific rules will be considered, as they might not apply to all Devices.  The notation should specify a list of Devices and a logical combination of rule instances pertaining to that list. Suppose we would like to test a rule only on the specific Device instance BBa_K112133, where the Promoter BBa_K112126 comes before the Ribosome Binding Site BBa_K112234_rbs. Then the following conditional statement can achieve such conditional evaluation. In this case, the if statement will evaluate to true:</P><P><FONT size="3"><I>Standard if-Statement</I></FONT>
Expressions not pertaining to rules and Devices can be evaluated by the standard if-statement which supports the relational operators &lt;, &lt;=, &gt;, &gt;=, !=, == as well as the logical operators AND, OR, NOT.</P><P style="text-align: right;"><A href="#Language_Definition">Back Up</A></P><P><SPAN id="Functions"><B><FONT size="3">Functions</FONT></B></SPAN>
Functions are convenient actions users can invoke that are processed during runtime. The print function simply prints the argument to the console on a new line. The permute function automates the specification of many devices that share the same structure. It creates a device for every combination of predefined parts, maintaining the part type of each component in the argument device. If a component of the device is a device, even ones with only one part, it is not changed and appears in every permutation. Permutations are named &lt;original device name&gt;_&lt;x&gt; where &lt;original device name&gt; is the name of the argument device, and x is a number starting at 1. They can be accessed and manipulated like normally instantiated devices.</P><P style="text-align: right;"><A href="#Language_Definition">Back Up</A></P><P><SPAN id="Header_Files"><B><FONT size="3">Header Files</FONT></B></SPAN>
The inclusion of header files allows the use of predefined Properties, Parts and Part Instances in the program. The manageability of code in the main file is more efficient by hiding the low level implementation of sequence and Parts. The user needs only to define Devices in the main file. On such a level the program can be written quickly and it is less error prone. Also, this allows each lab to have their own header file libraries. At the same time the option to change or declare other Properties, Parts and Part instances exists in the language.</P><P style="text-align: right;"><A href="#Language_Definition">Back Up</A></P></DIV><DIV class="printfooter">
Retrieved from &quot;<A href="http://2009.igem.org/Team:Berkeley_Software/Eugene">http://2009.igem.org/Team:Berkeley_Software/Eugene</A>&quot;</DIV></DIV></DIV><DIV id="footer-box"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Berkeley_Software/Eugene" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Berkeley_Software/Eugene" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Berkeley_Software/Eugene&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Berkeley_Software/Eugene&amp;oldid=169747" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2009.igem.org:Privacy_policy" title="2009.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2009.igem.org:General_disclaimer" title="2009.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
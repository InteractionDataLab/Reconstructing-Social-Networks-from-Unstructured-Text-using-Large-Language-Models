<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Tongji_Shanghai_javascript_TJjquery-flexslider skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Tongji Shanghai/javascript/TJjquery-flexslider</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*
</P><PRE>* jQuery FlexSlider v2.0
* <A rel="nofollow" class="external free" href="http://www.woothemes.com/flexslider/">http://www.woothemes.com/flexslider/</A>
*
* Copyright 2012 WooThemes
* Free to use under the GPLv2 license.
* <A rel="nofollow" class="external free" href="http://www.gnu.org/licenses/gpl-2.0.html">http://www.gnu.org/licenses/gpl-2.0.html</A>
*
* Contributing author: Tyler Smith (@mbmufffin)
*/
</PRE><DL><DT>(function ($) {</DT></DL><PRE> //FlexSlider: Object Instance
 $.flexslider = function(el, options) {
   var slider = $(el),
       vars = $.extend({}, $.flexslider.defaults, options),
       namespace = vars.namespace,
       touch = (&quot;ontouchstart&quot; in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch,
       eventType = (touch) ? &quot;touchend&quot; : &quot;click&quot;,
       vertical = vars.direction === &quot;vertical&quot;,
       reverse = vars.reverse,
       carousel = (vars.itemWidth &gt; 0),
       fade = vars.animation === &quot;fade&quot;,
       asNav = vars.asNavFor !== &quot;&quot;,
       methods = {};
   
   // Store a reference to the slider object
   $.data(el, &quot;flexslider&quot;, slider);
   
   // Privat slider methods
   methods = {
     init: function() {
       slider.animating = false;
       slider.currentSlide = vars.startAt;
       slider.animatingTo = slider.currentSlide;
       slider.atEnd = (slider.currentSlide === 0 || slider.currentSlide === slider.last);
       slider.containerSelector = vars.selector.substr(0,vars.selector.search(' '));
       slider.slides = $(vars.selector, slider);
       slider.container = $(slider.containerSelector, slider);
       slider.count = slider.slides.length;
       // SYNC:
       slider.syncExists = $(vars.sync).length &gt; 0;
       // SLIDE:
       if (vars.animation === &quot;slide&quot;) vars.animation = &quot;swing&quot;;
       slider.prop = (vertical) ? &quot;top&quot; : &quot;marginLeft&quot;;
       slider.args = {};
       // SLIDESHOW:
       slider.manualPause = false;
       // TOUCH/USECSS:
       slider.transitions = !vars.video &amp;&amp; !fade &amp;&amp; vars.useCSS &amp;&amp; (function() {
         var obj = document.createElement('div'),
             props = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
         for (var i in props) {
           if ( obj.style[ props[i] ] !== undefined ) {
             slider.pfx = props[i].replace('Perspective',<I>).toLowerCase();</I>
             slider.prop = &quot;-&quot; + slider.pfx + &quot;-transform&quot;;
             return true;
           }
         }
         return false;
       }());
       // CONTROLSCONTAINER:
       if (vars.controlsContainer !== &quot;&quot;) slider.controlsContainer = $(vars.controlsContainer).length &gt; 0 &amp;&amp; $(vars.controlsContainer);
       // MANUAL:
       if (vars.manualControls !== &quot;&quot;) slider.manualControls = $(vars.manualControls).length &gt; 0 &amp;&amp; $(vars.manualControls);
       
       // RANDOMIZE:
       if (vars.randomize) {
         slider.slides.sort(function() { return (Math.round(Math.random())-0.5); });
         slider.container.empty().append(slider.slides);
       }
       
       slider.doMath();
       
       // ASNAV:
       if (asNav) methods.asNav.setup();
       
       // INIT
       slider.setup(&quot;init&quot;);
       
       // CONTROLNAV:
       if (vars.controlNav) methods.controlNav.setup();
       
       // DIRECTIONNAV:
       if (vars.directionNav) methods.directionNav.setup();
       
       // KEYBOARD:
       if (vars.keyboard &amp;&amp; ($(slider.containerSelector).length === 1 || vars.multipleKeyboard)) {
         $(document).bind('keyup', function(event) {
           var keycode = event.keyCode;
           if (!slider.animating &amp;&amp; (keycode === 39 || keycode === 37)) {
             var target = (keycode === 39) ? slider.getTarget('next') :
                          (keycode === 37) ? slider.getTarget('prev') : false;
             slider.flexAnimate(target, vars.pauseOnAction);
           }
         });
       }
       // MOUSEWHEEL:
       if (vars.mousewheel) {
         slider.bind('mousewheel', function(event, delta, deltaX, deltaY) {
           event.preventDefault();
           var target = (delta &lt; 0) ? slider.getTarget('next') : slider.getTarget('prev');
           slider.flexAnimate(target, vars.pauseOnAction);
         });
       }
       
       // PAUSEPLAY
       if (vars.pausePlay) methods.pausePlay.setup();
       
       // SLIDSESHOW
       if (vars.slideshow) {
         if (vars.pauseOnHover) {
           slider.hover(function() {
             slider.pause();
           }, function() {
             if (!slider.manualPause) slider.play();
           });
         }
         // initialize animation
         (vars.initDelay &gt; 0) ? setTimeout(slider.play, vars.initDelay) : slider.play();
       }
       
       // TOUCH
       if (touch &amp;&amp; vars.touch) methods.touch();
       
       // FADE&amp;&amp;SMOOTHHEIGHT || SLIDE:
       if (!fade || (fade &amp;&amp; vars.smoothHeight)) $(window).bind(&quot;resize focus&quot;, methods.resize);
       
       
       // API: start() Callback
       setTimeout(function(){
         vars.start(slider);
       }, 200);
     },
     asNav: {
       setup: function() {
         slider.asNav = true;
         slider.animatingTo = Math.floor(slider.currentSlide/slider.move);
         slider.currentItem = slider.currentSlide;
         slider.slides.removeClass(namespace + &quot;active-slide&quot;).eq(slider.currentItem).addClass(namespace + &quot;active-slide&quot;);
         slider.slides.click(function(e){
           e.preventDefault();
           var $slide = $(this),
               target = $slide.index();
           if (!$(vars.asNavFor).data('flexslider').animating &amp;&amp; !$slide.hasClass('active')) {
             slider.direction = (slider.currentItem &lt; target) ? &quot;next&quot; : &quot;prev&quot;;
             slider.flexAnimate(target, vars.pauseOnAction, false, true, true);
           }
         });
       }
     },
     controlNav: {
       setup: function() {
         if (!slider.manualControls) {
           methods.controlNav.setupPaging();
         } else { // MANUALCONTROLS:
           methods.controlNav.setupManual();
         }
       },
       setupPaging: function() {
         var type = (vars.controlNav === &quot;thumbnails&quot;) ? 'control-thumbs' : 'control-paging',
             j = 1,
             item;
         
</PRE>
          slider.controlNavScaffold = $('');
<PRE>         if (slider.pagingCount &gt; 1) {
           for (var i = 0; i &lt; slider.pagingCount; i++) {
             item = (vars.controlNav === &quot;thumbnails&quot;) ? '&lt;img src=&quot;' + slider.slides.eq(i).attr(&quot;data-thumb&quot;) + '&quot;/&gt;' : '&lt;a&gt;' + j + '&lt;/a&gt;';
</PRE>
              slider.controlNavScaffold.append('<LI>' + item + '</LI>');
<PRE>             j++;
           }
         }
         
         // CONTROLSCONTAINER:
         (slider.controlsContainer) ? $(slider.controlsContainer).append(slider.controlNavScaffold) : slider.append(slider.controlNavScaffold);
         methods.controlNav.set();
         
         methods.controlNav.active();
       
         slider.controlNavScaffold.delegate('a, img', eventType, function(event) {
           event.preventDefault();
           var $this = $(this),
               target = slider.controlNav.index($this);
</PRE><PRE>           if (!$this.hasClass(namespace + 'active')) {
             slider.direction = (target &gt; slider.currentSlide) ? &quot;next&quot; : &quot;prev&quot;;
             slider.flexAnimate(target, vars.pauseOnAction);
           }
         });
         // Prevent iOS click event bug
         if (touch) {
           slider.controlNavScaffold.delegate('a', &quot;click touchstart&quot;, function(event) {
             event.preventDefault();
           });
         }
       },
       setupManual: function() {
         slider.controlNav = slider.manualControls;
         methods.controlNav.active();
         
         slider.controlNav.live(eventType, function(event) {
           event.preventDefault();
           var $this = $(this),
               target = slider.controlNav.index($this);
               
           if (!$this.hasClass(namespace + 'active')) {
             (target &gt; slider.currentSlide) ? slider.direction = &quot;next&quot; : slider.direction = &quot;prev&quot;;
             slider.flexAnimate(target, vars.pauseOnAction);
           }
         });
         // Prevent iOS click event bug
         if (touch) {
           slider.controlNav.live(&quot;click touchstart&quot;, function(event) {
             event.preventDefault();
           });
         }
       },
       set: function() {
         var selector = (vars.controlNav === &quot;thumbnails&quot;) ? 'img' : 'a';
         slider.controlNav = $('.' + namespace + 'control-nav li ' + selector, (slider.controlsContainer) ? slider.controlsContainer : slider);
       },
       active: function() {
         slider.controlNav.removeClass(namespace + &quot;active&quot;).eq(slider.animatingTo).addClass(namespace + &quot;active&quot;);
       },
       update: function(action, pos) {
         if (slider.pagingCount &gt; 1 &amp;&amp; action === &quot;add&quot;) {
</PRE>
            slider.controlNavScaffold.append($('<LI>&lt;a&gt;' + slider.count + '&lt;/a&gt;</LI>'));
<PRE>         } else if (slider.pagingCount === 1) {
           slider.controlNavScaffold.find('li').remove();
         } else {
           slider.controlNav.eq(pos).closest('li').remove();
         }
         methods.controlNav.set();
         (slider.pagingCount &gt; 1 &amp;&amp; slider.pagingCount !== slider.controlNav.length) ? slider.update(pos, action) : methods.controlNav.active();
       }
     },
     directionNav: {
       setup: function() {
</PRE>
          var directionNavScaffold = $('<UL class="' + namespace + 'direction-nav"><LI>&lt;a class=&quot;' + namespace + 'prev&quot; href=&quot;#&quot;&gt;' + vars.prevText + '&lt;/a&gt;</LI><LI>&lt;a class=&quot;' + namespace + 'next&quot; href=&quot;#&quot;&gt;' + vars.nextText + '&lt;/a&gt;</LI></UL>');
<PRE>         // CONTROLSCONTAINER:
         if (slider.controlsContainer) {
           $(slider.controlsContainer).append(directionNavScaffold);
           slider.directionNav = $('.' + namespace + 'direction-nav li a', slider.controlsContainer);
         } else {
           slider.append(directionNavScaffold);
           slider.directionNav = $('.' + namespace + 'direction-nav li a', slider);
         }
       
         methods.directionNav.update();
       
         slider.directionNav.bind(eventType, function(event) {
           event.preventDefault();
           var target = ($(this).hasClass(namespace + 'next')) ? slider.getTarget('next') : slider.getTarget('prev');
           slider.flexAnimate(target, vars.pauseOnAction);
         });
         // Prevent iOS click event bug
         if (touch) {
           slider.directionNav.bind(&quot;click touchstart&quot;, function(event) {
             event.preventDefault();
           });
         }
       },
       update: function() {
         var disabledClass = namespace + 'disabled';
         if (!vars.animationLoop) {
           if (slider.pagingCount === 1) {
            slider.directionNav.addClass(disabledClass);
           } else if (slider.animatingTo === 0) {
             slider.directionNav.removeClass(disabledClass).filter('.' + namespace + &quot;prev&quot;).addClass(disabledClass);
           } else if (slider.animatingTo === slider.last) {
             slider.directionNav.removeClass(disabledClass).filter('.' + namespace + &quot;next&quot;).addClass(disabledClass);
           } else {
             slider.directionNav.removeClass(disabledClass);
           }
         }
       }
     },
     pausePlay: {
       setup: function() {
</PRE>
          var pausePlayScaffold = $('<DIV class="' + namespace + 'pauseplay">&lt;a&gt;&lt;/a&gt;</DIV>');
<PRE>         // CONTROLSCONTAINER:
         if (slider.controlsContainer) {
           slider.controlsContainer.append(pausePlayScaffold);
           slider.pausePlay = $('.' + namespace + 'pauseplay a', slider.controlsContainer);
         } else {
           slider.append(pausePlayScaffold);
           slider.pausePlay = $('.' + namespace + 'pauseplay a', slider);
         }
       
         // slider.pausePlay.addClass(pausePlayState).text((pausePlayState == 'pause') ? vars.pauseText : vars.playText);
         methods.pausePlay.update((vars.slideshow) ? namespace + 'pause' : namespace + 'play');
       
         slider.pausePlay.bind(eventType, function(event) {
           event.preventDefault();
           if ($(this).hasClass(namespace + 'pause')) {
             slider.pause();
             slider.manualPause = true;
           } else {
             slider.play();
             slider.manualPause = false;
           }
         });
         // Prevent iOS click event bug
         if (touch) {
           slider.pausePlay.bind(&quot;click touchstart&quot;, function(event) {
             event.preventDefault();
           });
         }
       },
       update: function(state) {
         (state === &quot;play&quot;) ? slider.pausePlay.removeClass(namespace + 'pause').addClass(namespace + 'play').text(vars.playText) : slider.pausePlay.removeClass(namespace + 'play').addClass(namespace + 'pause').text(vars.pauseText);
       }
     },
     touch: function() {
       var startX,
         startY,
         offset,
         cwidth,
         dx,
         startT,
         scrolling = false;
             
       el.addEventListener('touchstart', onTouchStart, false);
       function onTouchStart(e) {
         if (slider.animating) {
           e.preventDefault();
         } else if (e.touches.length === 1) {
           slider.pause();
           // CAROUSEL: 
           cwidth = (vertical) ? slider.h : slider. w;
           startT = Number(new Date());
           // CAROUSEL:
           offset = (carousel &amp;&amp; reverse &amp;&amp; slider.animatingTo === slider.last) ? 0 :
                    (carousel &amp;&amp; reverse) ? slider.limit - (((slider.itemW + vars.itemMargin) * slider.move) * slider.animatingTo) :
                    (carousel &amp;&amp; slider.currentSlide === slider.last) ? slider.limit :
                    (carousel) ? ((slider.itemW + vars.itemMargin) * slider.move) * slider.currentSlide : 
                    (reverse) ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
           startX = (vertical) ? e.touches[0].pageY : e.touches[0].pageX;
           startY = (vertical) ? e.touches[0].pageX : e.touches[0].pageY;
</PRE><PRE>           el.addEventListener('touchmove', onTouchMove, false);
           el.addEventListener('touchend', onTouchEnd, false);
         }
       }
</PRE><PRE>       function onTouchMove(e) {
         dx = (vertical) ? startX - e.touches[0].pageY : startX - e.touches[0].pageX;
         scrolling = (vertical) ? (Math.abs(dx) &lt; Math.abs(e.touches[0].pageX - startY)) : (Math.abs(dx) &lt; Math.abs(e.touches[0].pageY - startY));
         
         if (!scrolling || Number(new Date()) - startT &gt; 500) {
           e.preventDefault();
           if (!fade &amp;&amp; slider.transitions) {
             if (!vars.animationLoop) {
               dx = dx/((slider.currentSlide === 0 &amp;&amp; dx &lt; 0 || slider.currentSlide === slider.last &amp;&amp; dx &gt; 0) ? (Math.abs(dx)/cwidth+2) : 1);
             }
             slider.setProps(offset + dx, &quot;setTouch&quot;);
           }
         }
       }
       
       function onTouchEnd(e) {
         if (slider.animatingTo === slider.currentSlide &amp;&amp; !scrolling &amp;&amp; !(dx === null)) {
           var updateDx = (reverse) ? -dx : dx,
               target = (updateDx &gt; 0) ? slider.getTarget('next') : slider.getTarget('prev');
           
           if (slider.canAdvance(target) &amp;&amp; (Number(new Date()) - startT &lt; 550 &amp;&amp; Math.abs(updateDx) &gt; 20 || Math.abs(updateDx) &gt; cwidth/2)) {
             slider.flexAnimate(target, vars.pauseOnAction);
           } else {
             slider.flexAnimate(slider.currentSlide, vars.pauseOnAction, true);
           }
         }
         // finish the touch by undoing the touch session
         el.removeEventListener('touchmove', onTouchMove, false);
         el.removeEventListener('touchend', onTouchEnd, false);
         startX = null;
         startY = null;
         dx = null;
         offset = null;
       }
     },
     resize: function() {
       if (!slider.animating &amp;&amp; slider.is(':visible')) {
         if (!carousel) slider.doMath();
         
         if (fade) {
           // SMOOTH HEIGHT:
           methods.smoothHeight();
         } else if (carousel) { //CAROUSEL:
           slider.slides.width(slider.computedW);
           slider.update(slider.pagingCount);
           slider.setProps();
         }
         else if (vertical) { //VERTICAL:
           slider.viewport.height(slider.h);
           slider.setProps(slider.h, &quot;setTotal&quot;);
         } else {
           // SMOOTH HEIGHT:
           if (vars.smoothHeight) methods.smoothHeight();
           slider.newSlides.width(slider.computedW);
           slider.setProps(slider.computedW, &quot;setTotal&quot;);
         }
       }
     },
     smoothHeight: function(dur) {
       if (!vertical || fade) {
         var $obj = (fade) ? slider : slider.viewport;
         (dur) ? $obj.animate({&quot;height&quot;: slider.slides.eq(slider.animatingTo).height()}, dur) : $obj.height(slider.slides.eq(slider.animatingTo).height());
       }
     },
     sync: function(action) {
       var $obj = $(vars.sync).data(&quot;flexslider&quot;),
           target = slider.animatingTo;
       
       switch (action) {
         case &quot;animate&quot;: $obj.flexAnimate(target, vars.pauseOnAction, false, true); break;
         case &quot;play&quot;: if (!$obj.playing &amp;&amp; !$obj.asNav) { $obj.play(); } break;
         case &quot;pause&quot;: $obj.pause(); break;
       }
     }
   }
   
   // public methods
   slider.flexAnimate = function(target, pause, override, withSync, fromNav) {
     if (!slider.animating &amp;&amp; (slider.canAdvance(target) || override) &amp;&amp; slider.is(&quot;:visible&quot;)) {
       if (asNav &amp;&amp; withSync) {
         var master = $(vars.asNavFor).data('flexslider');
         slider.atEnd = target === 0 || target === slider.count - 1;
         master.flexAnimate(target, true, false, true, fromNav);
         slider.direction = (slider.currentItem &lt; target) ? &quot;next&quot; : &quot;prev&quot;;
         master.direction = slider.direction;
         
         if (Math.ceil((target + 1)/slider.visible) - 1 !== slider.currentSlide &amp;&amp; target !== 0) {
           slider.currentItem = target;
           slider.slides.removeClass(namespace + &quot;active-slide&quot;).eq(target).addClass(namespace + &quot;active-slide&quot;);
           target = Math.floor(target/slider.visible);
         } else {
           slider.currentItem = target;
           slider.slides.removeClass(namespace + &quot;active-slide&quot;).eq(target).addClass(namespace + &quot;active-slide&quot;);
           return false;
         }
       }
       
       slider.animating = true;
       slider.animatingTo = target;
       // API: before() animation Callback
       vars.before(slider);
       
       // SLIDESHOW:
       if (pause) slider.pause();
       
       // SYNC:
       if (slider.syncExists &amp;&amp; !fromNav) methods.sync(&quot;animate&quot;);
       
       // CONTROLNAV
       if (vars.controlNav) methods.controlNav.active();
       
       // !CAROUSEL:
       // CANDIDATE: slide active class (for add/remove slide)
       if (!carousel) slider.slides.removeClass(namespace + 'active-slide').eq(target).addClass(namespace + 'active-slide');
       
       // INFINITE LOOP:
       // CANDIDATE: atEnd
       slider.atEnd = target === 0 || target === slider.last;
       
       // DIRECTIONNAV:
       if (vars.directionNav) methods.directionNav.update();
       
       if (target === slider.last) {
         // API: end() of cycle Callback
         vars.end(slider);
         // SLIDESHOW &amp;&amp; !INFINITE LOOP:
         if (!vars.animationLoop) slider.pause();
       }
       
       // SLIDE:
       if (!fade) {
         var dimension = (vertical) ? slider.slides.filter(':first').height() : slider.computedW,
             margin, slideString, calcNext;
         
         // INFINITE LOOP / REVERSE:
         if (carousel) {
           margin = (vars.itemWidth &gt; slider.w) ? vars.itemMargin * 2 : vars.itemMargin;
           calcNext = ((slider.itemW + margin) * slider.move) * slider.animatingTo;
           slideString = (calcNext &gt; slider.limit &amp;&amp; slider.visible !== 1) ? slider.limit : calcNext;
         } else if (slider.currentSlide === 0 &amp;&amp; target === slider.count - 1 &amp;&amp; vars.animationLoop &amp;&amp; slider.direction !== &quot;next&quot;) {
           slideString = (reverse) ? (slider.count + slider.cloneOffset) * dimension : 0;
         } else if (slider.currentSlide === slider.last &amp;&amp; target === 0 &amp;&amp; vars.animationLoop &amp;&amp; slider.direction !== &quot;prev&quot;) {
           slideString = (reverse) ? 0 : (slider.count + 1) * dimension;
         } else {
           slideString = (reverse) ? ((slider.count - 1) - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;
         }
         slider.setProps(slideString, &quot;&quot;, vars.animationSpeed);
         if (slider.transitions) {
           if (!vars.animationLoop || !slider.atEnd) {
             slider.animating = false;
             slider.currentSlide = slider.animatingTo;
           }
           slider.container.unbind(&quot;webkitTransitionEnd transitionend&quot;);
           slider.container.bind(&quot;webkitTransitionEnd transitionend&quot;, function() {
             slider.wrapup(dimension);
           });
         } else {
           slider.container.animate(slider.args, vars.animationSpeed, vars.easing, function(){
             slider.wrapup(dimension);
           });
         }
       } else { // FADE:
         slider.slides.eq(slider.currentSlide).fadeOut(vars.animationSpeed, vars.easing);
         slider.slides.eq(target).fadeIn(vars.animationSpeed, vars.easing, slider.wrapup);
       }
       // SMOOTH HEIGHT:
       if (vars.smoothHeight) methods.smoothHeight(vars.animationSpeed);
     }
   } 
   slider.wrapup = function(dimension) {
     // SLIDE:
     if (!fade &amp;&amp; !carousel) {
       if (slider.currentSlide === 0 &amp;&amp; slider.animatingTo === slider.last &amp;&amp; vars.animationLoop) {
         slider.setProps(dimension, &quot;jumpEnd&quot;);
       } else if (slider.currentSlide === slider.last &amp;&amp; slider.animatingTo === 0 &amp;&amp; vars.animationLoop) {
         slider.setProps(dimension, &quot;jumpStart&quot;);
       }
     }
     slider.animating = false;
     slider.currentSlide = slider.animatingTo;
     // API: after() animation Callback
     vars.after(slider);
   }
   
   // SLIDESHOW:
   slider.animateSlides = function() {
     if (!slider.animating) slider.flexAnimate(slider.getTarget(&quot;next&quot;));
   }
   // SLIDESHOW:
   slider.pause = function() {
     clearInterval(slider.animatedSlides);
     slider.playing = false;
     // PAUSEPLAY:
     if (vars.pausePlay) methods.pausePlay.update(&quot;play&quot;);
     // SYNC:
     if (slider.syncExists) methods.sync(&quot;pause&quot;);
   }
   // SLIDESHOW:
   slider.play = function() {
     slider.animatedSlides = setInterval(slider.animateSlides, vars.slideshowSpeed);
     slider.playing = true;
     // PAUSEPLAY:
     if (vars.pausePlay) methods.pausePlay.update(&quot;pause&quot;);
     // SYNC:
     if (slider.syncExists) methods.sync(&quot;play&quot;);
   }
   slider.canAdvance = function(target) {
     // ASNAV:
     var last = (asNav) ? slider.pagingCount - 1 : slider.last;
     return (asNav &amp;&amp; slider.currentItem === 0 &amp;&amp; target === slider.pagingCount - 1 &amp;&amp; slider.direction !== &quot;next&quot;) ? false :
            (target === slider.currentSlide &amp;&amp; !asNav) ? false :
            (vars.animationLoop) ? true :
            (slider.atEnd &amp;&amp; slider.currentSlide === 0 &amp;&amp; target === last &amp;&amp; slider.direction !== &quot;next&quot;) ? false :
            (slider.atEnd &amp;&amp; slider.currentSlide === last &amp;&amp; target === 0 &amp;&amp; slider.direction === &quot;next&quot;) ? false :
            true;
   }
   slider.getTarget = function(dir) {
     slider.direction = dir; 
     if (dir === &quot;next&quot;) {
       return (slider.currentSlide === slider.last) ? 0 : slider.currentSlide + 1;
     } else {
       return (slider.currentSlide === 0) ? slider.last : slider.currentSlide - 1;
     }
   }
   
   // SLIDE:
   slider.setProps = function(pos, special, dur) {
     var target = (function() {
       var posCheck = (pos) ? pos : ((slider.itemW + vars.itemMargin) * slider.move) * slider.animatingTo,
           posCalc = (function() {
             if (carousel) {
               return (special === &quot;setTouch&quot;) ? pos :
                      (reverse &amp;&amp; slider.animatingTo === slider.last) ? 0 :
                      (reverse) ? slider.limit - (((slider.itemW + vars.itemMargin) * slider.move) * slider.animatingTo) :
                      (slider.animatingTo === slider.last) ? slider.limit : posCheck;
             } else {
               switch (special) {
                 case &quot;setTotal&quot;: return (reverse) ? ((slider.count - 1) - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;
                 case &quot;setTouch&quot;: return (reverse) ? pos : pos;
                 case &quot;jumpEnd&quot;: return (reverse) ? pos : slider.count * pos;
                 case &quot;jumpStart&quot;: return (reverse) ? slider.count * pos : pos;
                 default: return pos;
               }
             }
           }());
           return (posCalc * -1) + &quot;px&quot;;
         }());
</PRE><PRE>     if (slider.transitions) {
       target = (vertical) ? &quot;translate3d(0,&quot; + target + &quot;,0)&quot; : &quot;translate3d(&quot; + target + &quot;,0,0)&quot;;
       dur = (dur !== undefined) ? (dur/1000) + &quot;s&quot; : &quot;0s&quot;;
       slider.container.css(&quot;-&quot; + slider.pfx + &quot;-transition-duration&quot;, dur);
     }
     
     slider.args[slider.prop] = target;
     if (slider.transitions || dur === undefined) slider.container.css(slider.args);
   }
   
   slider.setup = function(type) {
     // SLIDE:
     if (!fade) {
       var sliderOffset, arr;
           
       if (type === &quot;init&quot;) {
</PRE>
          slider.viewport = $('').css({&quot;overflow&quot;: &quot;hidden&quot;, &quot;position&quot;: &quot;relative&quot;}).appendTo(slider).append(slider.container);
<PRE>         // INFINITE LOOP:
         slider.cloneCount = 0;
         slider.cloneOffset = 0;
         // REVERSE:
         if (reverse) {
           arr = $.makeArray(slider.slides).reverse();
           slider.slides = $(arr);
           slider.container.empty().append(slider.slides);
         }
       }
       // INFINITE LOOP &amp;&amp; !CAROUSEL:
       if (vars.animationLoop &amp;&amp; !carousel) {
         slider.cloneCount = 2;
         slider.cloneOffset = 1;
         // clear out old clones
         if (type !== &quot;init&quot;) slider.container.find('.clone').remove();
         slider.container.append(slider.slides.first().clone().addClass('clone')).prepend(slider.slides.last().clone().addClass('clone'));
       }
       slider.newSlides = $(vars.selector, slider);
       
       sliderOffset = (reverse) ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset;
       // VERTICAL:
       if (vertical &amp;&amp; !carousel) {
         slider.container.height((slider.count + slider.cloneCount) * 200 + &quot;%&quot;).css(&quot;position&quot;, &quot;absolute&quot;).width(&quot;100%&quot;);
         setTimeout(function(){
           slider.newSlides.css({&quot;display&quot;: &quot;block&quot;});
           slider.doMath();
           slider.viewport.height(slider.h);
           slider.setProps(sliderOffset * slider.h, &quot;init&quot;);
         }, (type === &quot;init&quot;) ? 100 : 0);
       } else {
         slider.container.width((slider.count + slider.cloneCount) * 200 + &quot;%&quot;);
         slider.setProps(sliderOffset * slider.computedW, &quot;init&quot;);
         setTimeout(function(){
           slider.doMath();
           slider.newSlides.css({&quot;width&quot;: slider.computedW, &quot;float&quot;: &quot;left&quot;, &quot;display&quot;: &quot;block&quot;});
           // SMOOTH HEIGHT:
           if (vars.smoothHeight) methods.smoothHeight();
         }, (type === &quot;init&quot;) ? 100 : 0);
       }
     } else { // FADE: 
       slider.slides.css({&quot;width&quot;: &quot;100%&quot;, &quot;float&quot;: &quot;left&quot;, &quot;marginRight&quot;: &quot;-100%&quot;, &quot;position&quot;: &quot;relative&quot;});
       if (type === &quot;init&quot;) slider.slides.eq(slider.currentSlide).fadeIn(vars.animationSpeed, vars.easing);
       // SMOOTH HEIGHT:
       if (vars.smoothHeight) methods.smoothHeight();
     }
     // !CAROUSEL:
     // CANDIDATE: active slide
     if (!carousel) slider.slides.removeClass(namespace + &quot;active-slide&quot;).eq(slider.currentSlide).addClass(namespace + &quot;active-slide&quot;);
   }
   
   slider.doMath = function() {
     var slide = slider.slides.first(),
         slideMargin = vars.itemMargin,
         minItems = vars.minItems,
         maxItems = vars.maxItems;
     
     slider.w = slider.width();
     slider.h = slide.height();
     slider.boxPadding = slide.outerWidth() - slide.width();
</PRE><PRE>     // CAROUSEL:
     if (carousel) {
       slider.itemT = vars.itemWidth + slideMargin;
       slider.minW = (minItems) ? minItems * slider.itemT : slider.w;
       slider.maxW = (maxItems) ? maxItems * slider.itemT : slider.w;
       slider.itemW = (slider.minW &gt; slider.w) ? (slider.w - (slideMargin * minItems))/minItems :
                      (slider.maxW &lt; slider.w) ? (slider.w - (slideMargin * maxItems))/maxItems :
                      (vars.itemWidth &gt; slider.w) ? slider.w : vars.itemWidth;
       slider.visible = Math.floor(slider.w/(slider.itemW + slideMargin));
       slider.move = (vars.move &gt; 0 &amp;&amp; vars.move &lt; slider.visible ) ? vars.move : slider.visible;
       slider.pagingCount = Math.ceil(((slider.count - slider.visible)/slider.move) + 1);
       slider.last =  slider.pagingCount - 1;
       slider.limit = (slider.pagingCount === 1) ? 0 :
                      (vars.itemWidth &gt; slider.w) ? ((slider.itemW + (slideMargin * 2)) * slider.count) - slider.w - slideMargin : ((slider.itemW + slideMargin) * slider.count) - slider.w;
     } else {
       slider.itemW = slider.w;
       slider.pagingCount = slider.count;
       slider.last = slider.count - 1;
     }
     slider.computedW = slider.itemW - slider.boxPadding;
   }
   
   slider.update = function(pos, action) {
     slider.doMath();
     
     // update currentSlide and slider.animatingTo if necessary
     if (!carousel) {
       if (pos &lt; slider.currentSlide) {
         slider.currentSlide += 1;
       } else if (pos &lt;= slider.currentSlide &amp;&amp; pos !== 0) {
         slider.currentSlide -= 1;
       }
       slider.animatingTo = slider.currentSlide;
     }
     
     // update controlNav
     if (vars.controlNav &amp;&amp; !slider.manualControls) {
       if ((action === &quot;add&quot; &amp;&amp; !carousel) || slider.pagingCount &gt; slider.controlNav.length) {
         methods.controlNav.update(&quot;add&quot;);
       } else if ((action === &quot;remove&quot; &amp;&amp; !carousel) || slider.pagingCount &lt; slider.controlNav.length) {
         if (carousel &amp;&amp; slider.currentSlide &gt; slider.last) {
           slider.currentSlide -= 1;
           slider.animatingTo -= 1;
         }
         methods.controlNav.update(&quot;remove&quot;, slider.last);
       }
     }
     // update directionNav
     if (vars.directionNav) methods.directionNav.update();
     
   }
   
   slider.addSlide = function(obj, pos) {
     var $obj = $(obj);
     
     slider.count += 1;
     slider.last = slider.count - 1;
     
     // append new slide
     if (vertical &amp;&amp; reverse) {
       (pos !== undefined) ? slider.slides.eq(slider.count - pos).after($obj) : slider.container.prepend($obj);
     } else {
       (pos !== undefined) ? slider.slides.eq(pos).before($obj) : slider.container.append($obj);
     }
     
     // update currentSlide, animatingTo, controlNav, and directionNav
     slider.update(pos, &quot;add&quot;);
     
     // update slider.slides
     slider.slides = $(vars.selector + ':not(.clone)', slider);
     // re-setup the slider to accomdate new slide
     slider.setup();
     
     //FlexSlider: added() Callback
     vars.added(slider);
   }
   slider.removeSlide = function(obj) {
     var pos = (isNaN(obj)) ? slider.slides.index($(obj)) : obj;
     
     // update count
     slider.count -= 1;
     slider.last = slider.count - 1;
     
     // remove slide
     if (isNaN(obj)) {
       $(obj, slider.slides).remove();
     } else {
       (vertical &amp;&amp; reverse) ? slider.slides.eq(slider.last).remove() : slider.slides.eq(obj).remove();
     }
     
     // update currentSlide, animatingTo, controlNav, and directionNav
     slider.doMath();
     slider.update(pos, &quot;remove&quot;);
     
     // update slider.slides
     slider.slides = $(vars.selector + ':not(.clone)', slider);
     // re-setup the slider to accomdate new slide
     slider.setup();
     
     // FlexSlider: removed() Callback
     vars.removed(slider);
   }
   
   //FlexSlider: Initialize
   methods.init();
 }
 
 //FlexSlider: Default Settings
 $.flexslider.defaults = {
   namespace: &quot;flex-&quot;,             //{NEW} String: Prefix string attached to the class of every element generated by the plugin
   selector: &quot;.slides &gt; li&quot;,       //{NEW} Selector: Must match a simple pattern. '{container} &gt; {slide}' -- Ignore pattern at your own peril
   animation: &quot;fade&quot;,              //String: Select your animation type, &quot;fade&quot; or &quot;slide&quot;
   easing: &quot;swing&quot;,               //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
   direction: &quot;horizontal&quot;,        //String: Select the sliding direction, &quot;horizontal&quot; or &quot;vertical&quot;
   reverse: false,                 //{NEW} Boolean: Reverse the animation direction
   animationLoop: true,             //Boolean: Should the animation loop? If false, directionNav will received &quot;disable&quot; classes at either end
   smoothHeight: false,            //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode  
   startAt: 0,                     //Integer: The slide that the slider should start on. Array notation (0 = first slide)
   slideshow: true,                //Boolean: Animate slider automatically
   slideshowSpeed: 7000,           //Integer: Set the speed of the slideshow cycling, in milliseconds
   animationSpeed: 600,            //Integer: Set the speed of animations, in milliseconds
   initDelay: 0,                   //{NEW} Integer: Set an initialization delay, in milliseconds
   randomize: false,               //Boolean: Randomize slide order
   
   // Usability features
   pauseOnAction: true,            //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
   pauseOnHover: false,            //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
   useCSS: true,                   //{NEW} Boolean: Slider will use CSS3 transitions if available
   touch: true,                    //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
   video: false,                   //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches
   
   // Primary Controls
   controlNav: true,               //Boolean: Create navigation for paging control of each clide? Note: Leave true for manualControls usage
   directionNav: true,             //Boolean: Create navigation for previous/next navigation? (true/false)
   prevText: &quot;Previous&quot;,           //String: Set the text for the &quot;previous&quot; directionNav item
   nextText: &quot;Next&quot;,               //String: Set the text for the &quot;next&quot; directionNav item
   
   // Secondary Navigation
   keyboard: true,                 //Boolean: Allow slider navigating via keyboard left/right keys
   multipleKeyboard: false,        //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
   mousewheel: false,              //{UPDATED} Boolean: Requires jquery.mousewheel.js (<A rel="nofollow" class="external free" href="https://github.com/brandonaaron/jquery-mousewheel">https://github.com/brandonaaron/jquery-mousewheel</A>) - Allows slider navigating via mousewheel
   pausePlay: false,               //Boolean: Create pause/play dynamic element
   pauseText: &quot;Pause&quot;,             //String: Set the text for the &quot;pause&quot; pausePlay item
   playText: &quot;Play&quot;,               //String: Set the text for the &quot;play&quot; pausePlay item
   
   // Special properties
   controlsContainer: &quot;&quot;,          //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(&quot;.flexslider-container&quot;). Property is ignored if given element is not found.
   manualControls: &quot;&quot;,             //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(&quot;.flex-control-nav li&quot;) or &quot;#tabs-nav li img&quot;, etc. The number of elements in your controlNav should match the number of slides/tabs.
   sync: &quot;&quot;,                       //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
   asNavFor: &quot;&quot;,                   //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider
   
   // Carousel Options
   itemWidth: 0,                   //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
   itemMargin: 0,                  //{NEW} Integer: Margin between carousel items.
   minItems: 0,                    //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
   maxItems: 0,                    //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
   move: 0,                        //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
                                   
   // Callback API
   start: function(){},            //Callback: function(slider) - Fires when the slider loads the first slide
   before: function(){},           //Callback: function(slider) - Fires asynchronously with each slider animation
   after: function(){},            //Callback: function(slider) - Fires after each slider animation completes
   end: function(){},              //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
   added: function(){},            //{NEW} Callback: function(slider) - Fires after a slide is added
   removed: function(){}           //{NEW} Callback: function(slider) - Fires after a slide is removed
 }
</PRE><PRE> //FlexSlider: Plugin Function
 $.fn.flexslider = function(options) {
   options = options || {};
   if (typeof options === &quot;object&quot;) {
     return this.each(function() {
       var $this = $(this),
           selector = (options.selector) ? options.selector : &quot;.slides &gt; li&quot;,
           $slides = $this.find(selector);
</PRE><PRE>       if ($slides.length === 1) {
         $slides.fadeIn(400);
         if (options.start) options.start($this);
       } else if ($this.data('flexslider') === undefined) {
         new $.flexslider(this, options);
       }
     });
   } else {
     // Helper strings to quickly perform functions on the slider
     var $slider = $(this).data('flexslider');
     switch (options) {
       case &quot;play&quot;: $slider.play(); break;
       case &quot;pause&quot;: $slider.pause(); break;
       case &quot;next&quot;: $slider.flexAnimate($slider.getTarget(&quot;next&quot;), true); break;
       case &quot;prev&quot;:
       case &quot;previous&quot;: $slider.flexAnimate($slider.getTarget(&quot;prev&quot;), true); break;
       default: if (typeof options === &quot;number&quot;) $slider.flexAnimate(options, true);
     }
   }
 }  
</PRE><P>})(jQuery);
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_SYSU-CHINA_lib_materializejs skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:SYSU-CHINA/lib/materializejs</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE>* Materialize v0.97.7 (<A rel="nofollow" class="external free" href="http://materializecss.com">http://materializecss.com</A>)
* Copyright 2014-2015 Materialize
* MIT License (<A rel="nofollow" class="external free" href="https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE">https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE</A>)
*/
</PRE><P>// Check for jQuery.
if (typeof(jQuery) === 'undefined') {
</P><PRE> var jQuery;
 // Check if require is a defined function.
 if (typeof(require) === 'function') {
   jQuery = $ = require('jquery');
 // Else use the dollar sign alias.
 } else {
   jQuery = $;
 }
</PRE><P>}
</P><DL><DT>/*</DT></DL><PRE>* jQuery Easing v1.3 - <A rel="nofollow" class="external free" href="http://gsgd.co.uk/sandbox/jquery/easing/">http://gsgd.co.uk/sandbox/jquery/easing/</A>
*
* Uses the built in easing capabilities added In jQuery 1.1
* to offer multiple easing options
*
* TERMS OF USE - jQuery Easing
*
* Open source under the BSD License.
*
* Copyright © 2008 George McGinley Smith
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
* Redistributions of source code must retain the above copyright notice, this list of
* conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list
* of conditions and the following disclaimer in the documentation and/or other materials
* provided with the distribution.
*
* Neither the name of the author nor the names of contributors may be used to endorse
* or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
*  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
</PRE><UL><LI>/</LI></UL><P>// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing['jswing'] = jQuery.easing['swing'];
</P><P>jQuery.extend( jQuery.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		//alert(jQuery.easing.default);
		return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) &lt; 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) &lt; 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a &lt; Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a &lt; Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a &lt; Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t &lt; 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) &lt; 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) &lt; (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t &lt; (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t &lt; (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t &lt; d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});
</P><P>/*
</P><PRE>*
* TERMS OF USE - EASING EQUATIONS
*
* Open source under the BSD License.
*
* Copyright © 2001 Robert Penner
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
* Redistributions of source code must retain the above copyright notice, this list of
* conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list
* of conditions and the following disclaimer in the documentation and/or other materials
* provided with the distribution.
*
* Neither the name of the author nor the names of contributors may be used to endorse
* or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
*  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/;    // Custom Easing
   jQuery.extend( jQuery.easing,
   {
     easeInOutMaterial: function (x, t, b, c, d) {
       if ((t/=d/2) &lt; 1) return c/2*t*t + b;
       return c/4*((t-=2)*t*t + 2) + b;
     }
   });
</PRE><DL><DT>/*! VelocityJS.org (1.2.3). (C) 2014 Julian Shapiro. MIT @license</DT><DD> en.wikipedia.org/wiki/MIT_License */</DD></DL><P>/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
/*! Note that this has been modified by Materialize to confirm that Velocity is not already being imported. */
jQuery.Velocity?console.log(&quot;Velocity is already loaded. You may be needlessly importing Velocity again; note that Materialize includes Velocity.&quot;):(!function(e){function t(e){var t=e.length,a=r.type(e);return&quot;function&quot;===a||r.isWindow(e)?!1:1===e.nodeType&amp;&amp;t?!0:&quot;array&quot;===a||0===t||&quot;number&quot;==typeof t&amp;&amp;t&gt;0&amp;&amp;t-1 in e}if(!e.jQuery){var r=function(e,t){return new r.fn.init(e,t)};r.isWindow=function(e){return null!=e&amp;&amp;e==e.window},r.type=function(e){return null==e?e+&quot;&quot;:&quot;object&quot;==typeof e||&quot;function&quot;==typeof e?n[i.call(e)]||&quot;object&quot;:typeof e},r.isArray=Array.isArray||function(e){return&quot;array&quot;===r.type(e)},r.isPlainObject=function(e){var t;if(!e||&quot;object&quot;!==r.type(e)||e.nodeType||r.isWindow(e))return!1;try{if(e.constructor&amp;&amp;!o.call(e,&quot;constructor&quot;)&amp;&amp;!o.call(e.constructor.prototype,&quot;isPrototypeOf&quot;))return!1}catch(a){return!1}for(t in e);return void 0===t||o.call(e,t)},r.each=function(e,r,a){var n,o=0,i=e.length,s=t(e);if(a){if(s)for(;i&gt;o&amp;&amp;(n=r.apply(e[o],a),n!==!1);o++);else for(o in e)if(n=r.apply(e[o],a),n===!1)break}else if(s)for(;i&gt;o&amp;&amp;(n=r.call(e[o],o,e[o]),n!==!1);o++);else for(o in e)if(n=r.call(e[o],o,e[o]),n===!1)break;return e},r.data=function(e,t,n){if(void 0===n){var o=e[r.expando],i=o&amp;&amp;a[o];if(void 0===t)return i;if(i&amp;&amp;t in i)return i[t]}else if(void 0!==t){var o=e[r.expando]||(e[r.expando]=++r.uuid);return a[o]=a[o]||{},a[o][t]=n,n}},r.removeData=function(e,t){var n=e[r.expando],o=n&amp;&amp;a[n];o&amp;&amp;r.each(t,function(e,t){delete o[t]})},r.extend=function(){var e,t,a,n,o,i,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for(&quot;boolean&quot;==typeof s&amp;&amp;(c=s,s=arguments[l]||{},l++),&quot;object&quot;!=typeof s&amp;&amp;&quot;function&quot;!==r.type(s)&amp;&amp;(s={}),l===u&amp;&amp;(s=this,l--);u&gt;l;l++)if(null!=(o=arguments[l]))for(n in o)e=s[n],a=o[n],s!==a&amp;&amp;(c&amp;&amp;a&amp;&amp;(r.isPlainObject(a)||(t=r.isArray(a)))?(t?(t=!1,i=e&amp;&amp;r.isArray(e)?e:[]):i=e&amp;&amp;r.isPlainObject(e)?e:{},s[n]=r.extend(c,i,a)):void 0!==a&amp;&amp;(s[n]=a));return s},r.queue=function(e,a,n){function o(e,r){var a=r||[];return null!=e&amp;&amp;(t(Object(e))?!function(e,t){for(var r=+t.length,a=0,n=e.length;r&gt;a;)e[n++]=t[a++];if(r!==r)for(;void 0!==t[a];)e[n++]=t[a++];return e.length=n,e}(a,&quot;string&quot;==typeof e?[e]:e):[].push.call(a,e)),a}if(e){a=(a||&quot;fx&quot;)+&quot;queue&quot;;var i=r.data(e,a);return n?(!i||r.isArray(n)?i=r.data(e,a,o(n)):i.push(n),i):i||[]}},r.dequeue=function(e,t){r.each(e.nodeType?[e]:e,function(e,a){t=t||&quot;fx&quot;;var n=r.queue(a,t),o=n.shift();&quot;inprogress&quot;===o&amp;&amp;(o=n.shift()),o&amp;&amp;(&quot;fx&quot;===t&amp;&amp;n.unshift(&quot;inprogress&quot;),o.call(a,function(){r.dequeue(a,t)}))})},r.fn=r.prototype={init:function(e){if(e.nodeType)return this[0]=e,this;throw new Error(&quot;Not a DOM node.&quot;)},offset:function(){var t=this[0].getBoundingClientRect?this[0].getBoundingClientRect():{top:0,left:0};return{top:t.top+(e.pageYOffset||document.scrollTop||0)-(document.clientTop||0),left:t.left+(e.pageXOffset||document.scrollLeft||0)-(document.clientLeft||0)}},position:function(){function e(){for(var e=this.offsetParent||document;e&amp;&amp;&quot;html&quot;===!e.nodeType.toLowerCase&amp;&amp;&quot;static&quot;===e.style.position;)e=e.offsetParent;return e||document}var t=this[0],e=e.apply(t),a=this.offset(),n=/^(?:body|html)$/i.test(e.nodeName)?{top:0,left:0}:r(e).offset();return a.top-=parseFloat(t.style.marginTop)||0,a.left-=parseFloat(t.style.marginLeft)||0,e.style&amp;&amp;(n.top+=parseFloat(e.style.borderTopWidth)||0,n.left+=parseFloat(e.style.borderLeftWidth)||0),{top:a.top-n.top,left:a.left-n.left}}};var a={};r.expando=&quot;velocity&quot;+(new Date).getTime(),r.uuid=0;for(var n={},o=n.hasOwnProperty,i=n.toString,s=&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;),l=0;l&lt;s.length;l++)n[&quot;[object &quot;+s[l]+&quot;]&quot;]=s[l].toLowerCase();r.fn.init.prototype=r.fn,e.Velocity={Utilities:r}}}(window),function(e){&quot;object&quot;==typeof module&amp;&amp;&quot;object&quot;==typeof module.exports?module.exports=e():&quot;function&quot;==typeof define&amp;&amp;define.amd?define(e):e()}(function(){return function(e,t,r,a){function n(e){for(var t=-1,r=e?e.length:0,a=[];++t&lt;r;){var n=e[t];n&amp;&amp;a.push(n)}return a}function o(e){return m.isWrapped(e)?e=[].slice.call(e):m.isNode(e)&amp;&amp;(e=[e]),e}function i(e){var t=f.data(e,&quot;velocity&quot;);return null===t?a:t}function s(e){return function(t){return Math.round(t*e)*(1/e)}}function l(e,r,a,n){function o(e,t){return 1-3*t+3*e}function i(e,t){return 3*t-6*e}function s(e){return 3*e}function l(e,t,r){return((o(t,r)*e+i(t,r))*e+s(t))*e}function u(e,t,r){return 3*o(t,r)*e*e+2*i(t,r)*e+s(t)}function c(t,r){for(var n=0;m&gt;n;++n){var o=u(r,e,a);if(0===o)return r;var i=l(r,e,a)-t;r-=i/o}return r}function p(){for(var t=0;b&gt;t;++t)w[t]=l(t*x,e,a)}function f(t,r,n){var o,i,s=0;do i=r+(n-r)/2,o=l(i,e,a)-t,o&gt;0?n=i:r=i;while(Math.abs(o)&gt;h&amp;&amp;++s&lt;v);return i}function d(t){for(var r=0,n=1,o=b-1;n!=o&amp;&amp;w[n]&lt;=t;++n)r+=x;--n;var i=(t-w[n])/(w[n+1]-w[n]),s=r+i*x,l=u(s,e,a);return l&gt;=y?c(t,s):0==l?s:f(t,r,r+x)}function g(){V=!0,(e!=r||a!=n)&amp;&amp;p()}var m=4,y=.001,h=1e-7,v=10,b=11,x=1/(b-1),S=&quot;Float32Array&quot;in t;if(4!==arguments.length)return!1;for(var P=0;4&gt;P;++P)if(&quot;number&quot;!=typeof arguments[P]||isNaN(arguments[P])||!isFinite(arguments[P]))return!1;e=Math.min(e,1),a=Math.min(a,1),e=Math.max(e,0),a=Math.max(a,0);var w=S?new Float32Array(b):new Array(b),V=!1,C=function(t){return V||g(),e===r&amp;&amp;a===n?t:0===t?0:1===t?1:l(d(t),r,n)};C.getControlPoints=function(){return[{x:e,y:r},{x:a,y:n}]};var T=&quot;generateBezier(&quot;+[e,r,a,n]+&quot;)&quot;;return C.toString=function(){return T},C}function u(e,t){var r=e;return m.isString(e)?b.Easings[e]||(r=!1):r=m.isArray(e)&amp;&amp;1===e.length?s.apply(null,e):m.isArray(e)&amp;&amp;2===e.length?x.apply(null,e.concat([t])):m.isArray(e)&amp;&amp;4===e.length?l.apply(null,e):!1,r===!1&amp;&amp;(r=b.Easings[b.defaults.easing]?b.defaults.easing:v),r}function c(e){if(e){var t=(new Date).getTime(),r=b.State.calls.length;r&gt;1e4&amp;&amp;(b.State.calls=n(b.State.calls));for(var o=0;r&gt;o;o++)if(b.State.calls[o]){var s=b.State.calls[o],l=s[0],u=s[2],d=s[3],g=!!d,y=null;d||(d=b.State.calls[o][3]=t-16);for(var h=Math.min((t-d)/u.duration,1),v=0,x=l.length;x&gt;v;v++){var P=l[v],V=P.element;if(i(V)){var C=!1;if(u.display!==a&amp;&amp;null!==u.display&amp;&amp;&quot;none&quot;!==u.display){if(&quot;flex&quot;===u.display){var T=[&quot;-webkit-box&quot;,&quot;-moz-box&quot;,&quot;-ms-flexbox&quot;,&quot;-webkit-flex&quot;];f.each(T,function(e,t){S.setPropertyValue(V,&quot;display&quot;,t)})}S.setPropertyValue(V,&quot;display&quot;,u.display)}u.visibility!==a&amp;&amp;&quot;hidden&quot;!==u.visibility&amp;&amp;S.setPropertyValue(V,&quot;visibility&quot;,u.visibility);for(var k in P)if(&quot;element&quot;!==k){var A,F=P[k],j=m.isString(F.easing)?b.Easings[F.easing]:F.easing;if(1===h)A=F.endValue;else{var E=F.endValue-F.startValue;if(A=F.startValue+E*j(h,u,E),!g&amp;&amp;A===F.currentValue)continue}if(F.currentValue=A,&quot;tween&quot;===k)y=A;else{if(S.Hooks.registered[k]){var H=S.Hooks.getRoot(k),N=i(V).rootPropertyValueCache[H];N&amp;&amp;(F.rootPropertyValue=N)}var L=S.setPropertyValue(V,k,F.currentValue+(0===parseFloat(A)?&quot;&quot;:F.unitType),F.rootPropertyValue,F.scrollData);S.Hooks.registered[k]&amp;&amp;(i(V).rootPropertyValueCache[H]=S.Normalizations.registered[H]?S.Normalizations.registered[H](&quot;extract&quot;,null,L[1]):L[1]),&quot;transform&quot;===L[0]&amp;&amp;(C=!0)}}u.mobileHA&amp;&amp;i(V).transformCache.translate3d===a&amp;&amp;(i(V).transformCache.translate3d=&quot;(0px, 0px, 0px)&quot;,C=!0),C&amp;&amp;S.flushTransformCache(V)}}u.display!==a&amp;&amp;&quot;none&quot;!==u.display&amp;&amp;(b.State.calls[o][2].display=!1),u.visibility!==a&amp;&amp;&quot;hidden&quot;!==u.visibility&amp;&amp;(b.State.calls[o][2].visibility=!1),u.progress&amp;&amp;u.progress.call(s[1],s[1],h,Math.max(0,d+u.duration-t),d,y),1===h&amp;&amp;p(o)}}b.State.isTicking&amp;&amp;w(c)}function p(e,t){if(!b.State.calls[e])return!1;for(var r=b.State.calls[e][0],n=b.State.calls[e][1],o=b.State.calls[e][2],s=b.State.calls[e][4],l=!1,u=0,c=r.length;c&gt;u;u++){var p=r[u].element;if(t||o.loop||(&quot;none&quot;===o.display&amp;&amp;S.setPropertyValue(p,&quot;display&quot;,o.display),&quot;hidden&quot;===o.visibility&amp;&amp;S.setPropertyValue(p,&quot;visibility&quot;,o.visibility)),o.loop!==!0&amp;&amp;(f.queue(p)[1]===a||!/\.velocityQueueEntryFlag/i.test(f.queue(p)[1]))&amp;&amp;i(p)){i(p).isAnimating=!1,i(p).rootPropertyValueCache={};var d=!1;f.each(S.Lists.transforms3D,function(e,t){var r=/^scale/.test(t)?1:0,n=i(p).transformCache[t];i(p).transformCache[t]!==a&amp;&amp;new RegExp(&quot;^\\(&quot;+r+&quot;[^.]&quot;).test(n)&amp;&amp;(d=!0,delete i(p).transformCache[t])}),o.mobileHA&amp;&amp;(d=!0,delete i(p).transformCache.translate3d),d&amp;&amp;S.flushTransformCache(p),S.Values.removeClass(p,&quot;velocity-animating&quot;)}if(!t&amp;&amp;o.complete&amp;&amp;!o.loop&amp;&amp;u===c-1)try{o.complete.call(n,n)}catch(g){setTimeout(function(){throw g},1)}s&amp;&amp;o.loop!==!0&amp;&amp;s(n),i(p)&amp;&amp;o.loop===!0&amp;&amp;!t&amp;&amp;(f.each(i(p).tweensContainer,function(e,t){/^rotate/.test(e)&amp;&amp;360===parseFloat(t.endValue)&amp;&amp;(t.endValue=0,t.startValue=360),/^backgroundPosition/.test(e)&amp;&amp;100===parseFloat(t.endValue)&amp;&amp;&quot;%&quot;===t.unitType&amp;&amp;(t.endValue=0,t.startValue=100)}),b(p,&quot;reverse&quot;,{loop:!0,delay:o.delay})),o.queue!==!1&amp;&amp;f.dequeue(p,o.queue)}b.State.calls[e]=!1;for(var m=0,y=b.State.calls.length;y&gt;m;m++)if(b.State.calls[m]!==!1){l=!0;break}l===!1&amp;&amp;(b.State.isTicking=!1,delete b.State.calls,b.State.calls=[])}var f,d=function(){if(r.documentMode)return r.documentMode;for(var e=7;e&gt;4;e--){var t=r.createElement(&quot;div&quot;);if(t.innerHTML=&quot;&quot;,t.getElementsByTagName(&quot;span&quot;).length)return t=null,e}return a}(),g=function(){var e=0;return t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||function(t){var r,a=(new Date).getTime();return r=Math.max(0,16-(a-e)),e=a+r,setTimeout(function(){t(a+r)},r)}}(),m={isString:function(e){return&quot;string&quot;==typeof e},isArray:Array.isArray||function(e){return&quot;[object Array]&quot;===Object.prototype.toString.call(e)},isFunction:function(e){return&quot;[object Function]&quot;===Object.prototype.toString.call(e)},isNode:function(e){return e&amp;&amp;e.nodeType},isNodeList:function(e){return&quot;object&quot;==typeof e&amp;&amp;/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e))&amp;&amp;e.length!==a&amp;&amp;(0===e.length||&quot;object&quot;==typeof e[0]&amp;&amp;e[0].nodeType&gt;0)},isWrapped:function(e){return e&amp;&amp;(e.jquery||t.Zepto&amp;&amp;t.Zepto.zepto.isZ(e))},isSVG:function(e){return t.SVGElement&amp;&amp;e instanceof t.SVGElement},isEmptyObject:function(e){for(var t in e)return!1;return!0}},y=!1;if(e.fn&amp;&amp;e.fn.jquery?(f=e,y=!0):f=t.Velocity.Utilities,8&gt;=d&amp;&amp;!y)throw new Error(&quot;Velocity: IE8 and below require jQuery to be loaded before Velocity.&quot;);if(7&gt;=d)return void(jQuery.fn.velocity=jQuery.fn.animate);var h=400,v=&quot;swing&quot;,b={State:{isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),isAndroid:/Android/i.test(navigator.userAgent),isGingerbread:/Android 2\.3\.[3-7]/i.test(navigator.userAgent),isChrome:t.chrome,isFirefox:/Firefox/i.test(navigator.userAgent),prefixElement:r.createElement(&quot;div&quot;),prefixMatches:{},scrollAnchor:null,scrollPropertyLeft:null,scrollPropertyTop:null,isTicking:!1,calls:[]},CSS:{},Utilities:f,Redirects:{},Easings:{},Promise:t.Promise,defaults:{queue:&quot;&quot;,duration:h,easing:v,begin:a,complete:a,progress:a,display:a,visibility:a,loop:!1,delay:!1,mobileHA:!0,_cacheValues:!0},init:function(e){f.data(e,&quot;velocity&quot;,{isSVG:m.isSVG(e),isAnimating:!1,computedStyle:null,tweensContainer:null,rootPropertyValueCache:{},transformCache:{}})},hook:null,mock:!1,version:{major:1,minor:2,patch:2},debug:!1};t.pageYOffset!==a?(b.State.scrollAnchor=t,b.State.scrollPropertyLeft=&quot;pageXOffset&quot;,b.State.scrollPropertyTop=&quot;pageYOffset&quot;):(b.State.scrollAnchor=r.documentElement||r.body.parentNode||r.body,b.State.scrollPropertyLeft=&quot;scrollLeft&quot;,b.State.scrollPropertyTop=&quot;scrollTop&quot;);var x=function(){function e(e){return-e.tension*e.x-e.friction*e.v}function t(t,r,a){var n={x:t.x+a.dx*r,v:t.v+a.dv*r,tension:t.tension,friction:t.friction};return{dx:n.v,dv:e(n)}}function r(r,a){var n={dx:r.v,dv:e(r)},o=t(r,.5*a,n),i=t(r,.5*a,o),s=t(r,a,i),l=1/6*(n.dx+2*(o.dx+i.dx)+s.dx),u=1/6*(n.dv+2*(o.dv+i.dv)+s.dv);return r.x=r.x+l*a,r.v=r.v+u*a,r}return function a(e,t,n){var o,i,s,l={x:-1,v:0,tension:null,friction:null},u=[0],c=0,p=1e-4,f=.016;for(e=parseFloat(e)||500,t=parseFloat(t)||20,n=n||null,l.tension=e,l.friction=t,o=null!==n,o?(c=a(e,t),i=c/n*f):i=f;s=r(s||l,i),u.push(1+s.x),c+=16,Math.abs(s.x)&gt;p&amp;&amp;Math.abs(s.v)&gt;p;);return o?function(e){return u[e*(u.length-1)|0]}:c}}();b.Easings={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},spring:function(e){return 1-Math.cos(4.5*e*Math.PI)*Math.exp(6*-e)}},f.each([[&quot;ease&quot;,[.25,.1,.25,1]],[&quot;ease-in&quot;,[.42,0,1,1]],[&quot;ease-out&quot;,[0,0,.58,1]],[&quot;ease-in-out&quot;,[.42,0,.58,1]],[&quot;easeInSine&quot;,[.47,0,.745,.715]],[&quot;easeOutSine&quot;,[.39,.575,.565,1]],[&quot;easeInOutSine&quot;,[.445,.05,.55,.95]],[&quot;easeInQuad&quot;,[.55,.085,.68,.53]],[&quot;easeOutQuad&quot;,[.25,.46,.45,.94]],[&quot;easeInOutQuad&quot;,[.455,.03,.515,.955]],[&quot;easeInCubic&quot;,[.55,.055,.675,.19]],[&quot;easeOutCubic&quot;,[.215,.61,.355,1]],[&quot;easeInOutCubic&quot;,[.645,.045,.355,1]],[&quot;easeInQuart&quot;,[.895,.03,.685,.22]],[&quot;easeOutQuart&quot;,[.165,.84,.44,1]],[&quot;easeInOutQuart&quot;,[.77,0,.175,1]],[&quot;easeInQuint&quot;,[.755,.05,.855,.06]],[&quot;easeOutQuint&quot;,[.23,1,.32,1]],[&quot;easeInOutQuint&quot;,[.86,0,.07,1]],[&quot;easeInExpo&quot;,[.95,.05,.795,.035]],[&quot;easeOutExpo&quot;,[.19,1,.22,1]],[&quot;easeInOutExpo&quot;,[1,0,0,1]],[&quot;easeInCirc&quot;,[.6,.04,.98,.335]],[&quot;easeOutCirc&quot;,[.075,.82,.165,1]],[&quot;easeInOutCirc&quot;,[.785,.135,.15,.86]]],function(e,t){b.Easings[t[0]]=l.apply(null,t[1])});var S=b.CSS={RegEx:{isHex:/^#([A-f\d]{3}){1,2}$/i,valueUnwrap:/^[A-z]+\((.*)\)$/i,wrappedValueAlreadyExtracted:/[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,valueSplit:/([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi},Lists:{colors:[&quot;fill&quot;,&quot;stroke&quot;,&quot;stopColor&quot;,&quot;color&quot;,&quot;backgroundColor&quot;,&quot;borderColor&quot;,&quot;borderTopColor&quot;,&quot;borderRightColor&quot;,&quot;borderBottomColor&quot;,&quot;borderLeftColor&quot;,&quot;outlineColor&quot;],transformsBase:[&quot;translateX&quot;,&quot;translateY&quot;,&quot;scale&quot;,&quot;scaleX&quot;,&quot;scaleY&quot;,&quot;skewX&quot;,&quot;skewY&quot;,&quot;rotateZ&quot;],transforms3D:[&quot;transformPerspective&quot;,&quot;translateZ&quot;,&quot;scaleZ&quot;,&quot;rotateX&quot;,&quot;rotateY&quot;]},Hooks:{templates:{textShadow:[&quot;Color X Y Blur&quot;,&quot;black 0px 0px 0px&quot;],boxShadow:[&quot;Color X Y Blur Spread&quot;,&quot;black 0px 0px 0px 0px&quot;],clip:[&quot;Top Right Bottom Left&quot;,&quot;0px 0px 0px 0px&quot;],backgroundPosition:[&quot;X Y&quot;,&quot;0% 0%&quot;],transformOrigin:[&quot;X Y Z&quot;,&quot;50% 50% 0px&quot;],perspectiveOrigin:[&quot;X Y&quot;,&quot;50% 50%&quot;]},registered:{},register:function(){for(var e=0;e&lt;S.Lists.colors.length;e++){var t=&quot;color&quot;===S.Lists.colors[e]?&quot;0 0 0 1&quot;:&quot;255 255 255 1&quot;;S.Hooks.templates[S.Lists.colors[e]]=[&quot;Red Green Blue Alpha&quot;,t]}var r,a,n;if(d)for(r in S.Hooks.templates){a=S.Hooks.templates[r],n=a[0].split(&quot; &quot;);var o=a[1].match(S.RegEx.valueSplit);&quot;Color&quot;===n[0]&amp;&amp;(n.push(n.shift()),o.push(o.shift()),S.Hooks.templates[r]=[n.join(&quot; &quot;),o.join(&quot; &quot;)])}for(r in S.Hooks.templates){a=S.Hooks.templates[r],n=a[0].split(&quot; &quot;);for(var e in n){var i=r+n[e],s=e;S.Hooks.registered[i]=[r,s]}}},getRoot:function(e){var t=S.Hooks.registered[e];return t?t[0]:e},cleanRootPropertyValue:function(e,t){return S.RegEx.valueUnwrap.test(t)&amp;&amp;(t=t.match(S.RegEx.valueUnwrap)[1]),S.Values.isCSSNullValue(t)&amp;&amp;(t=S.Hooks.templates[e][1]),t},extractValue:function(e,t){var r=S.Hooks.registered[e];if(r){var a=r[0],n=r[1];return t=S.Hooks.cleanRootPropertyValue(a,t),t.toString().match(S.RegEx.valueSplit)[n]}return t},injectValue:function(e,t,r){var a=S.Hooks.registered[e];if(a){var n,o,i=a[0],s=a[1];return r=S.Hooks.cleanRootPropertyValue(i,r),n=r.toString().match(S.RegEx.valueSplit),n[s]=t,o=n.join(&quot; &quot;)}return r}},Normalizations:{registered:{clip:function(e,t,r){switch(e){case&quot;name&quot;:return&quot;clip&quot;;case&quot;extract&quot;:var a;return S.RegEx.wrappedValueAlreadyExtracted.test(r)?a=r:(a=r.toString().match(S.RegEx.valueUnwrap),a=a?a[1].replace(/,(\s+)?/g,&quot; &quot;):r),a;case&quot;inject&quot;:return&quot;rect(&quot;+r+&quot;)&quot;}},blur:function(e,t,r){switch(e){case&quot;name&quot;:return b.State.isFirefox?&quot;filter&quot;:&quot;-webkit-filter&quot;;case&quot;extract&quot;:var a=parseFloat(r);if(!a&amp;&amp;0!==a){var n=r.toString().match(/blur\(([0-9]+[A-z]+)\)/i);a=n?n[1]:0}return a;case&quot;inject&quot;:return parseFloat(r)?&quot;blur(&quot;+r+&quot;)&quot;:&quot;none&quot;}},opacity:function(e,t,r){if(8&gt;=d)switch(e){case&quot;name&quot;:return&quot;filter&quot;;case&quot;extract&quot;:var a=r.toString().match(/alpha\(opacity=(.*)\)/i);return r=a?a[1]/100:1;case&quot;inject&quot;:return t.style.zoom=1,parseFloat(r)&gt;=1?&quot;&quot;:&quot;alpha(opacity=&quot;+parseInt(100*parseFloat(r),10)+&quot;)&quot;}else switch(e){case&quot;name&quot;:return&quot;opacity&quot;;case&quot;extract&quot;:return r;case&quot;inject&quot;:return r}}},register:function(){9&gt;=d||b.State.isGingerbread||(S.Lists.transformsBase=S.Lists.transformsBase.concat(S.Lists.transforms3D));for(var e=0;e&lt;S.Lists.transformsBase.length;e++)!function(){var t=S.Lists.transformsBase[e];S.Normalizations.registered[t]=function(e,r,n){switch(e){case&quot;name&quot;:return&quot;transform&quot;;case&quot;extract&quot;:return i(r)===a||i(r).transformCache[t]===a?/^scale/i.test(t)?1:0:i(r).transformCache[t].replace(/[()]/g,&quot;&quot;);case&quot;inject&quot;:var o=!1;switch(t.substr(0,t.length-1)){case&quot;translate&quot;:o=!/(%|px|em|rem|vw|vh|\d)$/i.test(n);break;case&quot;scal&quot;:case&quot;scale&quot;:b.State.isAndroid&amp;&amp;i(r).transformCache[t]===a&amp;&amp;1&gt;n&amp;&amp;(n=1),o=!/(\d)$/i.test(n);break;case&quot;skew&quot;:o=!/(deg|\d)$/i.test(n);break;case&quot;rotate&quot;:o=!/(deg|\d)$/i.test(n)}return o||(i(r).transformCache[t]=&quot;(&quot;+n+&quot;)&quot;),i(r).transformCache[t]}}}();for(var e=0;e&lt;S.Lists.colors.length;e++)!function(){var t=S.Lists.colors[e];S.Normalizations.registered[t]=function(e,r,n){switch(e){case&quot;name&quot;:return t;case&quot;extract&quot;:var o;if(S.RegEx.wrappedValueAlreadyExtracted.test(n))o=n;else{var i,s={black:&quot;rgb(0, 0, 0)&quot;,blue:&quot;rgb(0, 0, 255)&quot;,gray:&quot;rgb(128, 128, 128)&quot;,green:&quot;rgb(0, 128, 0)&quot;,red:&quot;rgb(255, 0, 0)&quot;,white:&quot;rgb(255, 255, 255)&quot;};/^[A-z]+$/i.test(n)?i=s[n]!==a?s[n]:s.black:S.RegEx.isHex.test(n)?i=&quot;rgb(&quot;+S.Values.hexToRgb(n).join(&quot; &quot;)+&quot;)&quot;:/^rgba?\(/i.test(n)||(i=s.black),o=(i||n).toString().match(S.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g,&quot; &quot;)}return 8&gt;=d||3!==o.split(&quot; &quot;).length||(o+=&quot; 1&quot;),o;case&quot;inject&quot;:return 8&gt;=d?4===n.split(&quot; &quot;).length&amp;&amp;(n=n.split(/\s+/).slice(0,3).join(&quot; &quot;)):3===n.split(&quot; &quot;).length&amp;&amp;(n+=&quot; 1&quot;),(8&gt;=d?&quot;rgb&quot;:&quot;rgba&quot;)+&quot;(&quot;+n.replace(/\s+/g,&quot;,&quot;).replace(/\.(\d)+(?=,)/g,&quot;&quot;)+&quot;)&quot;}}}()}},Names:{camelCase:function(e){return e.replace(/-(\w)/g,function(e,t){return t.toUpperCase()})},SVGAttribute:function(e){var t=&quot;width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2&quot;;return(d||b.State.isAndroid&amp;&amp;!b.State.isChrome)&amp;&amp;(t+=&quot;|transform&quot;),new RegExp(&quot;^(&quot;+t+&quot;)$&quot;,&quot;i&quot;).test(e)},prefixCheck:function(e){if(b.State.prefixMatches[e])return[b.State.prefixMatches[e],!0];for(var t=[&quot;&quot;,&quot;Webkit&quot;,&quot;Moz&quot;,&quot;ms&quot;,&quot;O&quot;],r=0,a=t.length;a&gt;r;r++){var n;if(n=0===r?e:t[r]+e.replace(/^\w/,function(e){return e.toUpperCase()}),m.isString(b.State.prefixElement.style[n]))return b.State.prefixMatches[e]=n,[n,!0]}return[e,!1]}},Values:{hexToRgb:function(e){var t,r=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,a=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;return e=e.replace(r,function(e,t,r,a){return t+t+r+r+a+a}),t=a.exec(e),t?[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]:[0,0,0]},isCSSNullValue:function(e){return 0==e||/^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e)},getUnitType:function(e){return/^(rotate|skew)/i.test(e)?&quot;deg&quot;:/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e)?&quot;&quot;:&quot;px&quot;},getDisplayType:function(e){var t=e&amp;&amp;e.tagName.toString().toLowerCase();return/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t)?&quot;inline&quot;:/^(li)$/i.test(t)?&quot;list-item&quot;:/^(tr)$/i.test(t)?&quot;table-row&quot;:/^(table)$/i.test(t)?&quot;table&quot;:/^(tbody)$/i.test(t)?&quot;table-row-group&quot;:&quot;block&quot;},addClass:function(e,t){e.classList?e.classList.add(t):e.className+=(e.className.length?&quot; &quot;:&quot;&quot;)+t},removeClass:function(e,t){e.classList?e.classList.remove(t):e.className=e.className.toString().replace(new RegExp(&quot;(^|\\s)&quot;+t.split(&quot; &quot;).join(&quot;|&quot;)+&quot;(\\s|$)&quot;,&quot;gi&quot;),&quot; &quot;)}},getPropertyValue:function(e,r,n,o){function s(e,r){function n(){u&amp;&amp;S.setPropertyValue(e,&quot;display&quot;,&quot;none&quot;)}var l=0;if(8&gt;=d)l=f.css(e,r);else{var u=!1;if(/^(width|height)$/.test(r)&amp;&amp;0===S.getPropertyValue(e,&quot;display&quot;)&amp;&amp;(u=!0,S.setPropertyValue(e,&quot;display&quot;,S.Values.getDisplayType(e))),!o){if(&quot;height&quot;===r&amp;&amp;&quot;border-box&quot;!==S.getPropertyValue(e,&quot;boxSizing&quot;).toString().toLowerCase()){var c=e.offsetHeight-(parseFloat(S.getPropertyValue(e,&quot;borderTopWidth&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;borderBottomWidth&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;paddingTop&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;paddingBottom&quot;))||0);return n(),c}if(&quot;width&quot;===r&amp;&amp;&quot;border-box&quot;!==S.getPropertyValue(e,&quot;boxSizing&quot;).toString().toLowerCase()){var p=e.offsetWidth-(parseFloat(S.getPropertyValue(e,&quot;borderLeftWidth&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;borderRightWidth&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;paddingLeft&quot;))||0)-(parseFloat(S.getPropertyValue(e,&quot;paddingRight&quot;))||0);return n(),p}}var g;g=i(e)===a?t.getComputedStyle(e,null):i(e).computedStyle?i(e).computedStyle:i(e).computedStyle=t.getComputedStyle(e,null),&quot;borderColor&quot;===r&amp;&amp;(r=&quot;borderTopColor&quot;),l=9===d&amp;&amp;&quot;filter&quot;===r?g.getPropertyValue(r):g[r],(&quot;&quot;===l||null===l)&amp;&amp;(l=e.style[r]),n()}if(&quot;auto&quot;===l&amp;&amp;/^(top|right|bottom|left)$/i.test(r)){var m=s(e,&quot;position&quot;);(&quot;fixed&quot;===m||&quot;absolute&quot;===m&amp;&amp;/top|left/i.test(r))&amp;&amp;(l=f(e).position()[r]+&quot;px&quot;)}return l}var l;if(S.Hooks.registered[r]){var u=r,c=S.Hooks.getRoot(u);n===a&amp;&amp;(n=S.getPropertyValue(e,S.Names.prefixCheck(c)[0])),S.Normalizations.registered[c]&amp;&amp;(n=S.Normalizations.registered[c](&quot;extract&quot;,e,n)),l=S.Hooks.extractValue(u,n)}else if(S.Normalizations.registered[r]){var p,g;p=S.Normalizations.registered[r](&quot;name&quot;,e),&quot;transform&quot;!==p&amp;&amp;(g=s(e,S.Names.prefixCheck(p)[0]),S.Values.isCSSNullValue(g)&amp;&amp;S.Hooks.templates[r]&amp;&amp;(g=S.Hooks.templates[r][1])),l=S.Normalizations.registered[r](&quot;extract&quot;,e,g)}if(!/^[\d-]/.test(l))if(i(e)&amp;&amp;i(e).isSVG&amp;&amp;S.Names.SVGAttribute(r))if(/^(height|width)$/i.test(r))try{l=e.getBBox()[r]}catch(m){l=0}else l=e.getAttribute(r);else l=s(e,S.Names.prefixCheck(r)[0]);return S.Values.isCSSNullValue(l)&amp;&amp;(l=0),b.debug&gt;=2&amp;&amp;console.log(&quot;Get &quot;+r+&quot;: &quot;+l),l},setPropertyValue:function(e,r,a,n,o){var s=r;if(&quot;scroll&quot;===r)o.container?o.container[&quot;scroll&quot;+o.direction]=a:&quot;Left&quot;===o.direction?t.scrollTo(a,o.alternateValue):t.scrollTo(o.alternateValue,a);else if(S.Normalizations.registered[r]&amp;&amp;&quot;transform&quot;===S.Normalizations.registered[r](&quot;name&quot;,e))S.Normalizations.registered[r](&quot;inject&quot;,e,a),s=&quot;transform&quot;,a=i(e).transformCache[r];else{if(S.Hooks.registered[r]){var l=r,u=S.Hooks.getRoot(r);n=n||S.getPropertyValue(e,u),a=S.Hooks.injectValue(l,a,n),r=u}if(S.Normalizations.registered[r]&amp;&amp;(a=S.Normalizations.registered[r](&quot;inject&quot;,e,a),r=S.Normalizations.registered[r](&quot;name&quot;,e)),s=S.Names.prefixCheck(r)[0],8&gt;=d)try{e.style[s]=a}catch(c){b.debug&amp;&amp;console.log(&quot;Browser does not support [&quot;+a+&quot;] for [&quot;+s+&quot;]&quot;)}else i(e)&amp;&amp;i(e).isSVG&amp;&amp;S.Names.SVGAttribute(r)?e.setAttribute(r,a):e.style[s]=a;b.debug&gt;=2&amp;&amp;console.log(&quot;Set &quot;+r+&quot; (&quot;+s+&quot;): &quot;+a)}return[s,a]},flushTransformCache:function(e){function t(t){return parseFloat(S.getPropertyValue(e,t))}var r=&quot;&quot;;if((d||b.State.isAndroid&amp;&amp;!b.State.isChrome)&amp;&amp;i(e).isSVG){var a={translate:[t(&quot;translateX&quot;),t(&quot;translateY&quot;)],skewX:[t(&quot;skewX&quot;)],skewY:[t(&quot;skewY&quot;)],scale:1!==t(&quot;scale&quot;)?[t(&quot;scale&quot;),t(&quot;scale&quot;)]:[t(&quot;scaleX&quot;),t(&quot;scaleY&quot;)],rotate:[t(&quot;rotateZ&quot;),0,0]};f.each(i(e).transformCache,function(e){/^translate/i.test(e)?e=&quot;translate&quot;:/^scale/i.test(e)?e=&quot;scale&quot;:/^rotate/i.test(e)&amp;&amp;(e=&quot;rotate&quot;),a[e]&amp;&amp;(r+=e+&quot;(&quot;+a[e].join(&quot; &quot;)+&quot;) &quot;,delete a[e])})}else{var n,o;f.each(i(e).transformCache,function(t){return n=i(e).transformCache[t],&quot;transformPerspective&quot;===t?(o=n,!0):(9===d&amp;&amp;&quot;rotateZ&quot;===t&amp;&amp;(t=&quot;rotate&quot;),void(r+=t+n+&quot; &quot;))}),o&amp;&amp;(r=&quot;perspective&quot;+o+&quot; &quot;+r)}S.setPropertyValue(e,&quot;transform&quot;,r)}};S.Hooks.register(),S.Normalizations.register(),b.hook=function(e,t,r){var n=a;return e=o(e),f.each(e,function(e,o){if(i(o)===a&amp;&amp;b.init(o),r===a)n===a&amp;&amp;(n=b.CSS.getPropertyValue(o,t));else{var s=b.CSS.setPropertyValue(o,t,r);&quot;transform&quot;===s[0]&amp;&amp;b.CSS.flushTransformCache(o),n=s}}),n};var P=function(){function e(){return s?k.promise||null:l}function n(){function e(e){function p(e,t){var r=a,n=a,i=a;return m.isArray(e)?(r=e[0],!m.isArray(e[1])&amp;&amp;/^[\d-]/.test(e[1])||m.isFunction(e[1])||S.RegEx.isHex.test(e[1])?i=e[1]:(m.isString(e[1])&amp;&amp;!S.RegEx.isHex.test(e[1])||m.isArray(e[1]))&amp;&amp;(n=t?e[1]:u(e[1],s.duration),e[2]!==a&amp;&amp;(i=e[2]))):r=e,t||(n=n||s.easing),m.isFunction(r)&amp;&amp;(r=r.call(o,V,w)),m.isFunction(i)&amp;&amp;(i=i.call(o,V,w)),[r||0,n,i]}function d(e,t){var r,a;return a=(t||&quot;0&quot;).toString().toLowerCase().replace(/[%A-z]+$/,function(e){return r=e,&quot;&quot;}),r||(r=S.Values.getUnitType(e)),[a,r]}function h(){var e={myParent:o.parentNode||r.body,position:S.getPropertyValue(o,&quot;position&quot;),fontSize:S.getPropertyValue(o,&quot;fontSize&quot;)},a=e.position===L.lastPosition&amp;&amp;e.myParent===L.lastParent,n=e.fontSize===L.lastFontSize;L.lastParent=e.myParent,L.lastPosition=e.position,L.lastFontSize=e.fontSize;var s=100,l={};if(n&amp;&amp;a)l.emToPx=L.lastEmToPx,l.percentToPxWidth=L.lastPercentToPxWidth,l.percentToPxHeight=L.lastPercentToPxHeight;else{var u=i(o).isSVG?r.createElementNS(&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot;,&quot;rect&quot;):r.createElement(&quot;div&quot;);b.init(u),e.myParent.appendChild(u),f.each([&quot;overflow&quot;,&quot;overflowX&quot;,&quot;overflowY&quot;],function(e,t){b.CSS.setPropertyValue(u,t,&quot;hidden&quot;)}),b.CSS.setPropertyValue(u,&quot;position&quot;,e.position),b.CSS.setPropertyValue(u,&quot;fontSize&quot;,e.fontSize),b.CSS.setPropertyValue(u,&quot;boxSizing&quot;,&quot;content-box&quot;),f.each([&quot;minWidth&quot;,&quot;maxWidth&quot;,&quot;width&quot;,&quot;minHeight&quot;,&quot;maxHeight&quot;,&quot;height&quot;],function(e,t){b.CSS.setPropertyValue(u,t,s+&quot;%&quot;)}),b.CSS.setPropertyValue(u,&quot;paddingLeft&quot;,s+&quot;em&quot;),l.percentToPxWidth=L.lastPercentToPxWidth=(parseFloat(S.getPropertyValue(u,&quot;width&quot;,null,!0))||1)/s,l.percentToPxHeight=L.lastPercentToPxHeight=(parseFloat(S.getPropertyValue(u,&quot;height&quot;,null,!0))||1)/s,l.emToPx=L.lastEmToPx=(parseFloat(S.getPropertyValue(u,&quot;paddingLeft&quot;))||1)/s,e.myParent.removeChild(u)}return null===L.remToPx&amp;&amp;(L.remToPx=parseFloat(S.getPropertyValue(r.body,&quot;fontSize&quot;))||16),null===L.vwToPx&amp;&amp;(L.vwToPx=parseFloat(t.innerWidth)/100,L.vhToPx=parseFloat(t.innerHeight)/100),l.remToPx=L.remToPx,l.vwToPx=L.vwToPx,l.vhToPx=L.vhToPx,b.debug&gt;=1&amp;&amp;console.log(&quot;Unit ratios: &quot;+JSON.stringify(l),o),l}if(s.begin&amp;&amp;0===V)try{s.begin.call(g,g)}catch(x){setTimeout(function(){throw x},1)}if(&quot;scroll&quot;===A){var P,C,T,F=/^x$/i.test(s.axis)?&quot;Left&quot;:&quot;Top&quot;,j=parseFloat(s.offset)||0;s.container?m.isWrapped(s.container)||m.isNode(s.container)?(s.container=s.container[0]||s.container,P=s.container[&quot;scroll&quot;+F],T=P+f(o).position()[F.toLowerCase()]+j):s.container=null:(P=b.State.scrollAnchor[b.State[&quot;scrollProperty&quot;+F]],C=b.State.scrollAnchor[b.State[&quot;scrollProperty&quot;+(&quot;Left&quot;===F?&quot;Top&quot;:&quot;Left&quot;)]],T=f(o).offset()[F.toLowerCase()]+j),l={scroll:{rootPropertyValue:!1,startValue:P,currentValue:P,endValue:T,unitType:&quot;&quot;,easing:s.easing,scrollData:{container:s.container,direction:F,alternateValue:C}},element:o},b.debug&amp;&amp;console.log(&quot;tweensContainer (scroll): &quot;,l.scroll,o)}else if(&quot;reverse&quot;===A){if(!i(o).tweensContainer)return void f.dequeue(o,s.queue);&quot;none&quot;===i(o).opts.display&amp;&amp;(i(o).opts.display=&quot;auto&quot;),&quot;hidden&quot;===i(o).opts.visibility&amp;&amp;(i(o).opts.visibility=&quot;visible&quot;),i(o).opts.loop=!1,i(o).opts.begin=null,i(o).opts.complete=null,v.easing||delete s.easing,v.duration||delete s.duration,s=f.extend({},i(o).opts,s);var E=f.extend(!0,{},i(o).tweensContainer);for(var H in E)if(&quot;element&quot;!==H){var N=E[H].startValue;E[H].startValue=E[H].currentValue=E[H].endValue,E[H].endValue=N,m.isEmptyObject(v)||(E[H].easing=s.easing),b.debug&amp;&amp;console.log(&quot;reverse tweensContainer (&quot;+H+&quot;): &quot;+JSON.stringify(E[H]),o)}l=E}else if(&quot;start&quot;===A){var E;i(o).tweensContainer&amp;&amp;i(o).isAnimating===!0&amp;&amp;(E=i(o).tweensContainer),f.each(y,function(e,t){if(RegExp(&quot;^&quot;+S.Lists.colors.join(&quot;$|^&quot;)+&quot;$&quot;).test(e)){var r=p(t,!0),n=r[0],o=r[1],i=r[2];if(S.RegEx.isHex.test(n)){for(var s=[&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;],l=S.Values.hexToRgb(n),u=i?S.Values.hexToRgb(i):a,c=0;c&lt;s.length;c++){var f=[l[c]];o&amp;&amp;f.push(o),u!==a&amp;&amp;f.push(u[c]),y[e+s[c]]=f}delete y[e]}}});for(var z in y){var O=p(y[z]),q=O[0],$=O[1],M=O[2];z=S.Names.camelCase(z);var I=S.Hooks.getRoot(z),B=!1;if(i(o).isSVG||&quot;tween&quot;===I||S.Names.prefixCheck(I)[1]!==!1||S.Normalizations.registered[I]!==a){(s.display!==a&amp;&amp;null!==s.display&amp;&amp;&quot;none&quot;!==s.display||s.visibility!==a&amp;&amp;&quot;hidden&quot;!==s.visibility)&amp;&amp;/opacity|filter/.test(z)&amp;&amp;!M&amp;&amp;0!==q&amp;&amp;(M=0),s._cacheValues&amp;&amp;E&amp;&amp;E[z]?(M===a&amp;&amp;(M=E[z].endValue+E[z].unitType),B=i(o).rootPropertyValueCache[I]):S.Hooks.registered[z]?M===a?(B=S.getPropertyValue(o,I),M=S.getPropertyValue(o,z,B)):B=S.Hooks.templates[I][1]:M===a&amp;&amp;(M=S.getPropertyValue(o,z));var W,G,Y,D=!1;if(W=d(z,M),M=W[0],Y=W[1],W=d(z,q),q=W[0].replace(/^([+-\/*])=/,function(e,t){return D=t,&quot;&quot;}),G=W[1],M=parseFloat(M)||0,q=parseFloat(q)||0,&quot;%&quot;===G&amp;&amp;(/^(fontSize|lineHeight)$/.test(z)?(q/=100,G=&quot;em&quot;):/^scale/.test(z)?(q/=100,G=&quot;&quot;):/(Red|Green|Blue)$/i.test(z)&amp;&amp;(q=q/100*255,G=&quot;&quot;)),/[\/*]/.test(D))G=Y;else if(Y!==G&amp;&amp;0!==M)if(0===q)G=Y;else{n=n||h();var Q=/margin|padding|left|right|width|text|word|letter/i.test(z)||/X$/.test(z)||&quot;x&quot;===z?&quot;x&quot;:&quot;y&quot;;switch(Y){case&quot;%&quot;:M*=&quot;x&quot;===Q?n.percentToPxWidth:n.percentToPxHeight;break;case&quot;px&quot;:break;default:M*=n[Y+&quot;ToPx&quot;]}switch(G){case&quot;%&quot;:M*=1/(&quot;x&quot;===Q?n.percentToPxWidth:n.percentToPxHeight);break;case&quot;px&quot;:break;default:M*=1/n[G+&quot;ToPx&quot;]}}switch(D){case&quot;+&quot;:q=M+q;break;case&quot;-&quot;:q=M-q;break;case&quot;*&quot;:q=M*q;break;case&quot;/&quot;:q=M/q}l[z]={rootPropertyValue:B,startValue:M,currentValue:M,endValue:q,unitType:G,easing:$},b.debug&amp;&amp;console.log(&quot;tweensContainer (&quot;+z+&quot;): &quot;+JSON.stringify(l[z]),o)}else b.debug&amp;&amp;console.log(&quot;Skipping [&quot;+I+&quot;] due to a lack of browser support.&quot;)}l.element=o}l.element&amp;&amp;(S.Values.addClass(o,&quot;velocity-animating&quot;),R.push(l),&quot;&quot;===s.queue&amp;&amp;(i(o).tweensContainer=l,i(o).opts=s),i(o).isAnimating=!0,V===w-1?(b.State.calls.push([R,g,s,null,k.resolver]),b.State.isTicking===!1&amp;&amp;(b.State.isTicking=!0,c())):V++)}var n,o=this,s=f.extend({},b.defaults,v),l={};switch(i(o)===a&amp;&amp;b.init(o),parseFloat(s.delay)&amp;&amp;s.queue!==!1&amp;&amp;f.queue(o,s.queue,function(e){b.velocityQueueEntryFlag=!0,i(o).delayTimer={setTimeout:setTimeout(e,parseFloat(s.delay)),next:e}}),s.duration.toString().toLowerCase()){case&quot;fast&quot;:s.duration=200;break;case&quot;normal&quot;:s.duration=h;break;case&quot;slow&quot;:s.duration=600;break;default:s.duration=parseFloat(s.duration)||1}b.mock!==!1&amp;&amp;(b.mock===!0?s.duration=s.delay=1:(s.duration*=parseFloat(b.mock)||1,s.delay*=parseFloat(b.mock)||1)),s.easing=u(s.easing,s.duration),s.begin&amp;&amp;!m.isFunction(s.begin)&amp;&amp;(s.begin=null),s.progress&amp;&amp;!m.isFunction(s.progress)&amp;&amp;(s.progress=null),s.complete&amp;&amp;!m.isFunction(s.complete)&amp;&amp;(s.complete=null),s.display!==a&amp;&amp;null!==s.display&amp;&amp;(s.display=s.display.toString().toLowerCase(),&quot;auto&quot;===s.display&amp;&amp;(s.display=b.CSS.Values.getDisplayType(o))),s.visibility!==a&amp;&amp;null!==s.visibility&amp;&amp;(s.visibility=s.visibility.toString().toLowerCase()),s.mobileHA=s.mobileHA&amp;&amp;b.State.isMobile&amp;&amp;!b.State.isGingerbread,s.queue===!1?s.delay?setTimeout(e,s.delay):e():f.queue(o,s.queue,function(t,r){return r===!0?(k.promise&amp;&amp;k.resolver(g),!0):(b.velocityQueueEntryFlag=!0,void e(t))}),&quot;&quot;!==s.queue&amp;&amp;&quot;fx&quot;!==s.queue||&quot;inprogress&quot;===f.queue(o)[0]||f.dequeue(o)}var s,l,d,g,y,v,x=arguments[0]&amp;&amp;(arguments[0].p||f.isPlainObject(arguments[0].properties)&amp;&amp;!arguments[0].properties.names||m.isString(arguments[0].properties));if(m.isWrapped(this)?(s=!1,d=0,g=this,l=this):(s=!0,d=1,g=x?arguments[0].elements||arguments[0].e:arguments[0]),g=o(g)){x?(y=arguments[0].properties||arguments[0].p,v=arguments[0].options||arguments[0].o):(y=arguments[d],v=arguments[d+1]);var w=g.length,V=0;if(!/^(stop|finish)$/i.test(y)&amp;&amp;!f.isPlainObject(v)){var C=d+1;v={};for(var T=C;T&lt;arguments.length;T++)m.isArray(arguments[T])||!/^(fast|normal|slow)$/i.test(arguments[T])&amp;&amp;!/^\d/.test(arguments[T])?m.isString(arguments[T])||m.isArray(arguments[T])?v.easing=arguments[T]:m.isFunction(arguments[T])&amp;&amp;(v.complete=arguments[T]):v.duration=arguments[T]}var k={promise:null,resolver:null,rejecter:null};s&amp;&amp;b.Promise&amp;&amp;(k.promise=new b.Promise(function(e,t){k.resolver=e,k.rejecter=t}));var A;switch(y){case&quot;scroll&quot;:A=&quot;scroll&quot;;break;case&quot;reverse&quot;:A=&quot;reverse&quot;;break;case&quot;finish&quot;:case&quot;stop&quot;:f.each(g,function(e,t){i(t)&amp;&amp;i(t).delayTimer&amp;&amp;(clearTimeout(i(t).delayTimer.setTimeout),i(t).delayTimer.next&amp;&amp;i(t).delayTimer.next(),delete i(t).delayTimer)});var F=[];return f.each(b.State.calls,function(e,t){t&amp;&amp;f.each(t[1],function(r,n){var o=v===a?&quot;&quot;:v;return o===!0||t[2].queue===o||v===a&amp;&amp;t[2].queue===!1?void f.each(g,function(r,a){a===n&amp;&amp;((v===!0||m.isString(v))&amp;&amp;(f.each(f.queue(a,m.isString(v)?v:&quot;&quot;),function(e,t){
m.isFunction(t)&amp;&amp;t(null,!0)}),f.queue(a,m.isString(v)?v:&quot;&quot;,[])),&quot;stop&quot;===y?(i(a)&amp;&amp;i(a).tweensContainer&amp;&amp;o!==!1&amp;&amp;f.each(i(a).tweensContainer,function(e,t){t.endValue=t.currentValue}),F.push(e)):&quot;finish&quot;===y&amp;&amp;(t[2].duration=1))}):!0})}),&quot;stop&quot;===y&amp;&amp;(f.each(F,function(e,t){p(t,!0)}),k.promise&amp;&amp;k.resolver(g)),e();default:if(!f.isPlainObject(y)||m.isEmptyObject(y)){if(m.isString(y)&amp;&amp;b.Redirects[y]){var j=f.extend({},v),E=j.duration,H=j.delay||0;return j.backwards===!0&amp;&amp;(g=f.extend(!0,[],g).reverse()),f.each(g,function(e,t){parseFloat(j.stagger)?j.delay=H+parseFloat(j.stagger)*e:m.isFunction(j.stagger)&amp;&amp;(j.delay=H+j.stagger.call(t,e,w)),j.drag&amp;&amp;(j.duration=parseFloat(E)||(/^(callout|transition)/.test(y)?1e3:h),j.duration=Math.max(j.duration*(j.backwards?1-e/w:(e+1)/w),.75*j.duration,200)),b.Redirects[y].call(t,t,j||{},e,w,g,k.promise?k:a)}),e()}var N=&quot;Velocity: First argument (&quot;+y+&quot;) was not a property map, a known action, or a registered redirect. Aborting.&quot;;return k.promise?k.rejecter(new Error(N)):console.log(N),e()}A=&quot;start&quot;}var L={lastParent:null,lastPosition:null,lastFontSize:null,lastPercentToPxWidth:null,lastPercentToPxHeight:null,lastEmToPx:null,remToPx:null,vwToPx:null,vhToPx:null},R=[];f.each(g,function(e,t){m.isNode(t)&amp;&amp;n.call(t)});var z,j=f.extend({},b.defaults,v);if(j.loop=parseInt(j.loop),z=2*j.loop-1,j.loop)for(var O=0;z&gt;O;O++){var q={delay:j.delay,progress:j.progress};O===z-1&amp;&amp;(q.display=j.display,q.visibility=j.visibility,q.complete=j.complete),P(g,&quot;reverse&quot;,q)}return e()}};b=f.extend(P,b),b.animate=P;var w=t.requestAnimationFrame||g;return b.State.isMobile||r.hidden===a||r.addEventListener(&quot;visibilitychange&quot;,function(){r.hidden?(w=function(e){return setTimeout(function(){e(!0)},16)},c()):w=t.requestAnimationFrame||g}),e.Velocity=b,e!==t&amp;&amp;(e.fn.velocity=P,e.fn.velocity.defaults=b.defaults),f.each([&quot;Down&quot;,&quot;Up&quot;],function(e,t){b.Redirects[&quot;slide&quot;+t]=function(e,r,n,o,i,s){var l=f.extend({},r),u=l.begin,c=l.complete,p={height:&quot;&quot;,marginTop:&quot;&quot;,marginBottom:&quot;&quot;,paddingTop:&quot;&quot;,paddingBottom:&quot;&quot;},d={};l.display===a&amp;&amp;(l.display=&quot;Down&quot;===t?&quot;inline&quot;===b.CSS.Values.getDisplayType(e)?&quot;inline-block&quot;:&quot;block&quot;:&quot;none&quot;),l.begin=function(){u&amp;&amp;u.call(i,i);for(var r in p){d[r]=e.style[r];var a=b.CSS.getPropertyValue(e,r);p[r]=&quot;Down&quot;===t?[a,0]:[0,a]}d.overflow=e.style.overflow,e.style.overflow=&quot;hidden&quot;},l.complete=function(){for(var t in d)e.style[t]=d[t];c&amp;&amp;c.call(i,i),s&amp;&amp;s.resolver(i)},b(e,p,l)}}),f.each([&quot;In&quot;,&quot;Out&quot;],function(e,t){b.Redirects[&quot;fade&quot;+t]=function(e,r,n,o,i,s){var l=f.extend({},r),u={opacity:&quot;In&quot;===t?1:0},c=l.complete;l.complete=n!==o-1?l.begin=null:function(){c&amp;&amp;c.call(i,i),s&amp;&amp;s.resolver(i)},l.display===a&amp;&amp;(l.display=&quot;In&quot;===t?&quot;auto&quot;:&quot;none&quot;),b(this,u,l)}}),b}(window.jQuery||window.Zepto||window,window,document)}));
</P><DL><DT>!function(a,b,c,d){&quot;use strict&quot;;function k(a,b,c){return setTimeout(q(a,c),b)}function l(a,b,c){return Array.isArray(a)?(m(a,c[b],c),!0)</DT><DD>!1}function m(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e&lt;a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&amp;&amp;b.call(c,a[e],e,a)}function n(a,b,c){for(var e=Object.keys(b),f=0;f&lt;e.length;)(!c||c&amp;&amp;a[e[f]]===d)&amp;&amp;(a[e[f]]=b[e[f]]),f++;return a}function o(a,b){return n(a,b,!0)}function p(a,b,c){var e,d=b.prototype;e=a.prototype=Object.create(d),e.constructor=a,e._super=d,c&amp;&amp;n(e,c)}function q(a,b){return function(){return a.apply(b,arguments)}}function r(a,b){return typeof a==g?a.apply(b?b[0]||d:d,b):a}function s(a,b){return a===d?b:a}function t(a,b,c){m(x(b),function(b){a.addEventListener(b,c,!1)})}function u(a,b,c){m(x(b),function(b){a.removeEventListener(b,c,!1)})}function v(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function w(a,b){return a.indexOf(b)&gt;-1}function x(a){return a.trim().split(/\s+/g)}function y(a,b,c){if(a.indexOf&amp;&amp;!c)return a.indexOf(b);for(var d=0;d&lt;a.length;){if(c&amp;&amp;a[d][c]==b||!c&amp;&amp;a[d]===b)return d;d++}return-1}function z(a){return Array.prototype.slice.call(a,0)}function A(a,b,c){for(var d=[],e=[],f=0;f&lt;a.length;){var g=b?a[f][b]:a[f];y(e,g)&lt;0&amp;&amp;d.push(a[f]),e[f]=g,f++}return c&amp;&amp;(d=b?d.sort(function(a,c){return a[b]&gt;c[b]}):d.sort()),d}function B(a,b){for(var c,f,g=b[0].toUpperCase()+b.slice(1),h=0;h&lt;e.length;){if(c=e[h],f=c?c+g:b,f in a)return f;h++}return d}function D(){return C++}function E(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function ab(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){r(a.options.enable,[a])&amp;&amp;c.handler(b)},this.init()}function bb(a){var b,c=a.options.inputClass;return b=c?c:H?wb:I?Eb:G?Gb:rb,new b(a,cb)}function cb(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&amp;O&amp;&amp;0===d-e,g=b&amp;(Q|R)&amp;&amp;0===d-e;c.isFirst=!!f,c.isFinal=!!g,f&amp;&amp;(a.session={}),c.eventType=b,db(a,c),a.emit(&quot;hammer.input&quot;,c),a.recognize(c),a.session.prevInput=c}function db(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=gb(b)),e&gt;1&amp;&amp;!c.firstMultiple?c.firstMultiple=gb(b):1===e&amp;&amp;(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=hb(d);b.timeStamp=j(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=lb(h,i),b.distance=kb(h,i),eb(c,b),b.offsetDirection=jb(b.deltaX,b.deltaY),b.scale=g?nb(g.pointers,d):1,b.rotation=g?mb(g.pointers,d):0,fb(c,b);var k=a.element;v(b.srcEvent.target,k)&amp;&amp;(k=b.srcEvent.target),b.target=k}function eb(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===O||f.eventType===Q)&amp;&amp;(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function fb(a,b){var f,g,h,j,c=a.lastInterval||b,e=b.timeStamp-c.timeStamp;if(b.eventType!=R&amp;&amp;(e&gt;N||c.velocity===d)){var k=c.deltaX-b.deltaX,l=c.deltaY-b.deltaY,m=ib(e,k,l);g=m.x,h=m.y,f=i(m.x)&gt;i(m.y)?m.x:m.y,j=jb(k,l),a.lastInterval=b}else f=c.velocity,g=c.velocityX,h=c.velocityY,j=c.direction;b.velocity=f,b.velocityX=g,b.velocityY=h,b.direction=j}function gb(a){for(var b=[],c=0;c&lt;a.pointers.length;)b[c]={clientX:h(a.pointers[c].clientX),clientY:h(a.pointers[c].clientY)},c++;return{timeStamp:j(),pointers:b,center:hb(b),deltaX:a.deltaX,deltaY:a.deltaY}}function hb(a){var b=a.length;if(1===b)return{x:h(a[0].clientX),y:h(a[0].clientY)};for(var c=0,d=0,e=0;b&gt;e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:h(c/b),y:h(d/b)}}function ib(a,b,c){return{x:b/a||0,y:c/a||0}}function jb(a,b){return a===b?S:i(a)&gt;=i(b)?a&gt;0?T:U:b&gt;0?V:W}function kb(a,b,c){c||(c=$);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function lb(a,b,c){c||(c=$);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function mb(a,b){return lb(b[1],b[0],_)-lb(a[1],a[0],_)}function nb(a,b){return kb(b[0],b[1],_)/kb(a[0],a[1],_)}function rb(){this.evEl=pb,this.evWin=qb,this.allow=!0,this.pressed=!1,ab.apply(this,arguments)}function wb(){this.evEl=ub,this.evWin=vb,ab.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function Ab(){this.evTarget=yb,this.evWin=zb,this.started=!1,ab.apply(this,arguments)}function Bb(a,b){var c=z(a.touches),d=z(a.changedTouches);return b&amp;(Q|R)&amp;&amp;(c=A(c.concat(d),&quot;identifier&quot;,!0)),[c,d]}function Eb(){this.evTarget=Db,this.targetIds={},ab.apply(this,arguments)}function Fb(a,b){var c=z(a.touches),d=this.targetIds;if(b&amp;(O|P)&amp;&amp;1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=z(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return v(a.target,i)}),b===O)for(e=0;e&lt;f.length;)d[f[e].identifier]=!0,e++;for(e=0;e&lt;g.length;)d[g[e].identifier]&amp;&amp;h.push(g[e]),b&amp;(Q|R)&amp;&amp;delete d[g[e].identifier],e++;return h.length?[A(f.concat(h),&quot;identifier&quot;,!0),h]:void 0}function Gb(){ab.apply(this,arguments);var a=q(this.handler,this);this.touch=new Eb(this.manager,a),this.mouse=new rb(this.manager,a)}function Pb(a,b){this.manager=a,this.set(b)}function Qb(a){if(w(a,Mb))return Mb;var b=w(a,Nb),c=w(a,Ob);return b&amp;&amp;c?Nb+&quot; &quot;+Ob:b||c?b?Nb:Ob:w(a,Lb)?Lb:Kb}function Yb(a){this.id=D(),this.manager=null,this.options=o(a||{},this.defaults),this.options.enable=s(this.options.enable,!0),this.state=Rb,this.simultaneous={},this.requireFail=[]}function Zb(a){return a&amp;Wb?&quot;cancel&quot;:a&amp;Ub?&quot;end&quot;:a&amp;Tb?&quot;move&quot;:a&amp;Sb?&quot;start&quot;:&quot;&quot;}function $b(a){return a==W?&quot;down&quot;:a==V?&quot;up&quot;:a==T?&quot;left&quot;:a==U?&quot;right&quot;:&quot;&quot;}function _b(a,b){var c=b.manager;return c?c.get(a):a}function ac(){Yb.apply(this,arguments)}function bc(){ac.apply(this,arguments),this.pX=null,this.pY=null}function cc(){ac.apply(this,arguments)}function dc(){Yb.apply(this,arguments),this._timer=null,this._input=null}function ec(){ac.apply(this,arguments)}function fc(){ac.apply(this,arguments)}function gc(){Yb.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function hc(a,b){return b=b||{},b.recognizers=s(b.recognizers,hc.defaults.preset),new kc(a,b)}function kc(a,b){b=b||{},this.options=o(b,hc.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=bb(this),this.touchAction=new Pb(this,this.options.touchAction),lc(this,!0),m(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&amp;&amp;b.recognizeWith(a[2]),a[3]&amp;&amp;b.requireFailure(a[3])},this)}function lc(a,b){var c=a.element;m(a.options.cssProps,function(a,d){c.style[B(c.style,d)]=b?a:&quot;&quot;})}function mc(a,c){var d=b.createEvent(&quot;Event&quot;);d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var e=[&quot;&quot;,&quot;webkit&quot;,&quot;moz&quot;,&quot;MS&quot;,&quot;ms&quot;,&quot;o&quot;],f=b.createElement(&quot;div&quot;),g=&quot;function&quot;,h=Math.round,i=Math.abs,j=Date.now,C=1,F=/mobile|tablet|ip(ad|hone|od)|android/i,G=&quot;ontouchstart&quot;in a,H=B(a,&quot;PointerEvent&quot;)!==d,I=G&amp;&amp;F.test(navigator.userAgent),J=&quot;touch&quot;,K=&quot;pen&quot;,L=&quot;mouse&quot;,M=&quot;kinect&quot;,N=25,O=1,P=2,Q=4,R=8,S=1,T=2,U=4,V=8,W=16,X=T|U,Y=V|W,Z=X|Y,$=[&quot;x&quot;,&quot;y&quot;],_=[&quot;clientX&quot;,&quot;clientY&quot;];ab.prototype={handler:function(){},init:function(){this.evEl&amp;&amp;t(this.element,this.evEl,this.domHandler),this.evTarget&amp;&amp;t(this.target,this.evTarget,this.domHandler),this.evWin&amp;&amp;t(E(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&amp;&amp;u(this.element,this.evEl,this.domHandler),this.evTarget&amp;&amp;u(this.target,this.evTarget,this.domHandler),this.evWin&amp;&amp;u(E(this.element),this.evWin,this.domHandler)}};var ob={mousedown:O,mousemove:P,mouseup:Q},pb=&quot;mousedown&quot;,qb=&quot;mousemove mouseup&quot;;p(rb,ab,{handler:function(a){var b=ob[a.type];b&amp;O&amp;&amp;0===a.button&amp;&amp;(this.pressed=!0),b&amp;P&amp;&amp;1!==a.which&amp;&amp;(b=Q),this.pressed&amp;&amp;this.allow&amp;&amp;(b&amp;Q&amp;&amp;(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:L,srcEvent:a}))}});var sb={pointerdown:O,pointermove:P,pointerup:Q,pointercancel:R,pointerout:R},tb={2:J,3:K,4:L,5:M},ub=&quot;pointerdown&quot;,vb=&quot;pointermove pointerup pointercancel&quot;;a.MSPointerEvent&amp;&amp;(ub=&quot;MSPointerDown&quot;,vb=&quot;MSPointerMove MSPointerUp MSPointerCancel&quot;),p(wb,ab,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace(&quot;ms&quot;,&quot;&quot;),e=sb[d],f=tb[a.pointerType]||a.pointerType,g=f==J,h=y(b,a.pointerId,&quot;pointerId&quot;);e&amp;O&amp;&amp;(0===a.button||g)?0&gt;h&amp;&amp;(b.push(a),h=b.length-1):e&amp;(Q|R)&amp;&amp;(c=!0),0&gt;h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&amp;&amp;b.splice(h,1))}});var xb={touchstart:O,touchmove:P,touchend:Q,touchcancel:R},yb=&quot;touchstart&quot;,zb=&quot;touchstart touchmove touchend touchcancel&quot;;p(Ab,ab,{handler:function(a){var b=xb[a.type];if(b===O&amp;&amp;(this.started=!0),this.started){var c=Bb.call(this,a,b);b&amp;(Q|R)&amp;&amp;0===c[0].length-c[1].length&amp;&amp;(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:J,srcEvent:a})}}});var Cb={touchstart:O,touchmove:P,touchend:Q,touchcancel:R},Db=&quot;touchstart touchmove touchend touchcancel&quot;;p(Eb,ab,{handler:function(a){var b=Cb[a.type],c=Fb.call(this,a,b);c&amp;&amp;this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:J,srcEvent:a})}}),p(Gb,ab,{handler:function(a,b,c){var d=c.pointerType==J,e=c.pointerType==L;if(d)this.mouse.allow=!1;else if(e&amp;&amp;!this.mouse.allow)return;b&amp;(Q|R)&amp;&amp;(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Hb=B(f.style,&quot;touchAction&quot;),Ib=Hb!==d,Jb=&quot;compute&quot;,Kb=&quot;auto&quot;,Lb=&quot;manipulation&quot;,Mb=&quot;none&quot;,Nb=&quot;pan-x&quot;,Ob=&quot;pan-y&quot;;Pb.prototype={set:function(a){a==Jb&amp;&amp;(a=this.compute()),Ib&amp;&amp;(this.manager.element.style[Hb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return m(this.manager.recognizers,function(b){r(b.options.enable,[b])&amp;&amp;(a=a.concat(b.getTouchAction()))}),Qb(a.join(&quot; &quot;))},preventDefaults:function(a){if(!Ib){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return b.preventDefault(),void 0;var d=this.actions,e=w(d,Mb),f=w(d,Ob),g=w(d,Nb);return e||f&amp;&amp;c&amp;X||g&amp;&amp;c&amp;Y?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var Rb=1,Sb=2,Tb=4,Ub=8,Vb=Ub,Wb=16,Xb=32;Yb.prototype={defaults:{},set:function(a){return n(this.options,a),this.manager&amp;&amp;this.manager.touchAction.update(),this},recognizeWith:function(a){if(l(a,&quot;recognizeWith&quot;,this))return this;var b=this.simultaneous;return a=_b(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return l(a,&quot;dropRecognizeWith&quot;,this)?this:(a=_b(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(l(a,&quot;requireFailure&quot;,this))return this;var b=this.requireFail;return a=_b(a,this),-1===y(b,a)&amp;&amp;(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(l(a,&quot;dropRequireFailure&quot;,this))return this;a=_b(a,this);var b=y(this.requireFail,a);return b&gt;-1&amp;&amp;this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length&gt;0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function d(d){b.manager.emit(b.options.event+(d?Zb(c):&quot;&quot;),a)}var b=this,c=this.state;Ub&gt;c&amp;&amp;d(!0),d(),c&gt;=Ub&amp;&amp;d(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):(this.state=Xb,void 0)},canEmit:function(){for(var a=0;a&lt;this.requireFail.length;){if(!(this.requireFail[a].state&amp;(Xb|Rb)))return!1;a++}return!0},recognize:function(a){var b=n({},a);return r(this.options.enable,[this,b])?(this.state&amp;(Vb|Wb|Xb)&amp;&amp;(this.state=Rb),this.state=this.process(b),this.state&amp;(Sb|Tb|Ub|Wb)&amp;&amp;this.tryEmit(b),void 0):(this.reset(),this.state=Xb,void 0)},process:function(){},getTouchAction:function(){},reset:function(){}},p(ac,Yb,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&amp;(Sb|Tb),e=this.attrTest(a);return d&amp;&amp;(c&amp;R||!e)?b|Wb:d||e?c&amp;Q?b|Ub:b&amp;Sb?b|Tb:Sb:Xb}}),p(bc,ac,{defaults:{event:&quot;pan&quot;,threshold:10,pointers:1,direction:Z},getTouchAction:function(){var a=this.options.direction,b=[];return a&amp;X&amp;&amp;b.push(Ob),a&amp;Y&amp;&amp;b.push(Nb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&amp;b.direction||(b.direction&amp;X?(e=0===f?S:0&gt;f?T:U,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?S:0&gt;g?V:W,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&amp;&amp;d&gt;b.threshold&amp;&amp;e&amp;b.direction},attrTest:function(a){return ac.prototype.attrTest.call(this,a)&amp;&amp;(this.state&amp;Sb||!(this.state&amp;Sb)&amp;&amp;this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$b(a.direction);b&amp;&amp;this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),p(cc,ac,{defaults:{event:&quot;pinch&quot;,threshold:0,pointers:2},getTouchAction:function(){return[Mb]},attrTest:function(a){return this._super.attrTest.call(this,a)&amp;&amp;(Math.abs(a.scale-1)&gt;this.options.threshold||this.state&amp;Sb)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale&lt;1?&quot;in&quot;:&quot;out&quot;;this.manager.emit(this.options.event+b,a)}}}),p(dc,Yb,{defaults:{event:&quot;press&quot;,pointers:1,time:500,threshold:5},getTouchAction:function(){return[Kb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance&lt;b.threshold,e=a.deltaTime&gt;b.time;if(this._input=a,!d||!c||a.eventType&amp;(Q|R)&amp;&amp;!e)this.reset();else if(a.eventType&amp;O)this.reset(),this._timer=k(function(){this.state=Vb,this.tryEmit()},b.time,this);else if(a.eventType&amp;Q)return Vb;return Xb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===Vb&amp;&amp;(a&amp;&amp;a.eventType&amp;Q?this.manager.emit(this.options.event+&quot;up&quot;,a):(this._input.timeStamp=j(),this.manager.emit(this.options.event,this._input)))}}),p(ec,ac,{defaults:{event:&quot;rotate&quot;,threshold:0,pointers:2},getTouchAction:function(){return[Mb]},attrTest:function(a){return this._super.attrTest.call(this,a)&amp;&amp;(Math.abs(a.rotation)&gt;this.options.threshold||this.state&amp;Sb)}}),p(fc,ac,{defaults:{event:&quot;swipe&quot;,threshold:10,velocity:.65,direction:X|Y,pointers:1},getTouchAction:function(){return bc.prototype.getTouchAction.call(this)},attrTest:function(a){var c,b=this.options.direction;return b&amp;(X|Y)?c=a.velocity:b&amp;X?c=a.velocityX:b&amp;Y&amp;&amp;(c=a.velocityY),this._super.attrTest.call(this,a)&amp;&amp;b&amp;a.direction&amp;&amp;a.distance&gt;this.options.threshold&amp;&amp;i(c)&gt;this.options.velocity&amp;&amp;a.eventType&amp;Q},emit:function(a){var b=$b(a.direction);b&amp;&amp;this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),p(gc,Yb,{defaults:{event:&quot;tap&quot;,pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[Lb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance&lt;b.threshold,e=a.deltaTime&lt;b.time;if(this.reset(),a.eventType&amp;O&amp;&amp;0===this.count)return this.failTimeout();if(d&amp;&amp;e&amp;&amp;c){if(a.eventType!=Q)return this.failTimeout();var f=this.pTime?a.timeStamp-this.pTime&lt;b.interval:!0,g=!this.pCenter||kb(this.pCenter,a.center)&lt;b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,g&amp;&amp;f?this.count+=1:this.count=1,this._input=a;var h=this.count%b.taps;if(0===h)return this.hasRequireFailures()?(this._timer=k(function(){this.state=Vb,this.tryEmit()},b.interval,this),Sb):Vb}return Xb},failTimeout:function(){return this._timer=k(function(){this.state=Xb},this.options.interval,this),Xb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==Vb&amp;&amp;(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),hc.VERSION=&quot;2.0.4&quot;,hc.defaults={domEvents:!1,touchAction:Jb,enable:!0,inputTarget:null,inputClass:null,preset:[[ec,{enable:!1}],[cc,{enable:!1},[&quot;rotate&quot;]],[fc,{direction:X}],[bc,{direction:X},[&quot;swipe&quot;]],[gc],[gc,{event:&quot;doubletap&quot;,taps:2},[&quot;tap&quot;]],[dc]],cssProps:{userSelect:&quot;default&quot;,touchSelect:&quot;none&quot;,touchCallout:&quot;none&quot;,contentZooming:&quot;none&quot;,userDrag:&quot;none&quot;,tapHighlightColor:&quot;rgba(0,0,0,0)&quot;}};var ic=1,jc=2;kc.prototype={set:function(a){return n(this.options,a),a.touchAction&amp;&amp;this.touchAction.update(),a.inputTarget&amp;&amp;(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?jc:ic},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&amp;&amp;e.state&amp;Vb)&amp;&amp;(e=b.curRecognizer=null);for(var f=0;f&lt;d.length;)c=d[f],b.stopped===jc||e&amp;&amp;c!=e&amp;&amp;!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&amp;&amp;c.state&amp;(Sb|Tb|Ub)&amp;&amp;(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Yb)return a;for(var b=this.recognizers,c=0;c&lt;b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(l(a,&quot;add&quot;,this))return this;var b=this.get(a.options.event);return b&amp;&amp;this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(l(a,&quot;remove&quot;,this))return this;var b=this.recognizers;return a=this.get(a),b.splice(y(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return m(x(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return m(x(a),function(a){b?c[a].splice(y(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&amp;&amp;mc(a,b);var c=this.handlers[a]&amp;&amp;this.handlers[a].slice();if(c&amp;&amp;c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d&lt;c.length;)c[d](b),d++}},destroy:function(){this.element&amp;&amp;lc(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},n(hc,{INPUT_START:O,INPUT_MOVE:P,INPUT_END:Q,INPUT_CANCEL:R,STATE_POSSIBLE:Rb,STATE_BEGAN:Sb,STATE_CHANGED:Tb,STATE_ENDED:Ub,STATE_RECOGNIZED:Vb,STATE_CANCELLED:Wb,STATE_FAILED:Xb,DIRECTION_NONE:S,DIRECTION_LEFT:T,DIRECTION_RIGHT:U,DIRECTION_UP:V,DIRECTION_DOWN:W,DIRECTION_HORIZONTAL:X,DIRECTION_VERTICAL:Y,DIRECTION_ALL:Z,Manager:kc,Input:ab,TouchAction:Pb,TouchInput:Eb,MouseInput:rb,PointerEventInput:wb,TouchMouseInput:Gb,SingleTouchInput:Ab,Recognizer:Yb,AttrRecognizer:ac,Tap:gc,Pan:bc,Swipe:fc,Pinch:cc,Rotate:ec,Press:dc,on:t,off:u,each:m,merge:o,extend:n,inherit:p,bindFn:q,prefixed:B}),typeof define==g&amp;&amp;define.amd?define(function(){return hc}):&quot;undefined&quot;!=typeof module&amp;&amp;module.exports?module.exports=hc:a[c]=hc}(window,document,&quot;Hammer&quot;);;(function(factory) {</DD></DL><PRE>   if (typeof define === 'function' &amp;&amp; define.amd) {
       define(['jquery', 'hammerjs'], factory);
   } else if (typeof exports === 'object') {
       factory(require('jquery'), require('hammerjs'));
   } else {
       factory(jQuery, Hammer);
   }
</PRE><P>}(function($, Hammer) {
</P><PRE>   function hammerify(el, options) {
       var $el = $(el);
       if(!$el.data(&quot;hammer&quot;)) {
           $el.data(&quot;hammer&quot;, new Hammer($el[0], options));
       }
   }
</PRE><PRE>   $.fn.hammer = function(options) {
       return this.each(function() {
           hammerify(this, options);
       });
   };
</PRE><PRE>   // extend the emit method to also trigger jQuery events
   Hammer.Manager.prototype.emit = (function(originalEmit) {
       return function(type, data) {
           originalEmit.call(this, type, data);
           $(this.element).trigger({
               type: type,
               gesture: data
           });
       };
   })(Hammer.Manager.prototype.emit);
</PRE><P>}));
</P><DL><DT>// Required for Meteor package, the use of window prevents export by Meteor</DT></DL><P>(function(window){
</P><PRE> if(window.Package){
   Materialize = {};
 } else {
   window.Materialize = {};
 }
</PRE><P>})(window);
</P><P>
// Unique ID
Materialize.guid = (function() {
</P><PRE> function s4() {
   return Math.floor((1 + Math.random()) * 0x10000)
     .toString(16)
     .substring(1);
 }
 return function() {
   return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
          s4() + '-' + s4() + s4() + s4();
 };
</PRE><P>})();
</P><P>Materialize.elementOrParentIsFixed = function(element) {
</P><PRE>   var $element = $(element);
   var $checkElements = $element.add($element.parents());
   var isFixed = false;
   $checkElements.each(function(){
       if ($(this).css(&quot;position&quot;) === &quot;fixed&quot;) {
           isFixed = true;
           return false;
       }
   });
   return isFixed;
</PRE><P>};
</P><P>// Velocity has conflicts when loaded with jQuery, this will check for it
var Vel;
if ($) {
</P><PRE> Vel = $.Velocity;
</PRE><P>} else if (jQuery) {
</P><PRE> Vel = jQuery.Velocity;
</PRE><P>} else {
</P><PRE> Vel = Velocity;
</PRE><P>}
</P><DL><DT>(function ($) {</DT></DL><PRE> $.fn.collapsible = function(options) {
   var defaults = {
       accordion: undefined
   };
</PRE><PRE>   options = $.extend(defaults, options);
</PRE><PRE>   return this.each(function() {
</PRE><PRE>     var $this = $(this);
</PRE><PRE>     var $panel_headers = $(this).find('&gt; li &gt; .collapsible-header');
</PRE><PRE>     var collapsible_type = $this.data(&quot;collapsible&quot;);
</PRE><PRE>     // Turn off any existing event handlers
      $this.off('click.collapse', '&gt; li &gt; .collapsible-header');
      $panel_headers.off('click.collapse');
</PRE><PRE>      /****************
      Helper Functions
      ****************/
</PRE><PRE>     // Accordion Open
     function accordionOpen(object) {
       $panel_headers = $this.find('&gt; li &gt; .collapsible-header');
       if (object.hasClass('active')) {
           object.parent().addClass('active');
       }
       else {
           object.parent().removeClass('active');
       }
       if (object.parent().hasClass('active')){
         object.siblings('.collapsible-body').stop(true,false).slideDown({ duration: 350, easing: &quot;easeOutQuart&quot;, queue: false, complete: function() {$(this).css('height', <I>);}});</I>
       }
       else{
         object.siblings('.collapsible-body').stop(true,false).slideUp({ duration: 350, easing: &quot;easeOutQuart&quot;, queue: false, complete: function() {$(this).css('height', <I>);}});</I>
       }
</PRE><PRE>       $panel_headers.not(object).removeClass('active').parent().removeClass('active');
       $panel_headers.not(object).parent().children('.collapsible-body').stop(true,false).slideUp(
         {
           duration: 350,
           easing: &quot;easeOutQuart&quot;,
           queue: false,
           complete:
             function() {
               $(this).css('height', <I>);</I>
             }
         });
     }
</PRE><PRE>     // Expandable Open
     function expandableOpen(object) {
       if (object.hasClass('active')) {
           object.parent().addClass('active');
       }
       else {
           object.parent().removeClass('active');
       }
       if (object.parent().hasClass('active')){
         object.siblings('.collapsible-body').stop(true,false).slideDown({ duration: 350, easing: &quot;easeOutQuart&quot;, queue: false, complete: function() {$(this).css('height', <I>);}});</I>
       }
       else{
         object.siblings('.collapsible-body').stop(true,false).slideUp({ duration: 350, easing: &quot;easeOutQuart&quot;, queue: false, complete: function() {$(this).css('height', <I>);}});</I>
       }
     }
</PRE><PRE>     /**
      * Check if object is children of panel header
      * @param  {Object}  object Jquery object
      * @return {Boolean} true if it is children
      */
     function isChildrenOfPanelHeader(object) {
</PRE><PRE>       var panelHeader = getPanelHeader(object);
</PRE><PRE>       return panelHeader.length &gt; 0;
     }
</PRE><PRE>     /**
      * Get panel header from a children element
      * @param  {Object} object Jquery object
      * @return {Object} panel header object
      */
     function getPanelHeader(object) {
</PRE><PRE>       return object.closest('li &gt; .collapsible-header');
     }
</PRE><PRE>     /*****  End Helper Functions  *****/
</PRE><PRE>     // Add click handler to only direct collapsible header children
     $this.on('click.collapse', '&gt; li &gt; .collapsible-header', function(e) {
       var $header = $(this),
           element = $(e.target);
</PRE><PRE>       if (isChildrenOfPanelHeader(element)) {
         element = getPanelHeader(element);
       }
</PRE><PRE>       element.toggleClass('active');
</PRE><PRE>       if (options.accordion || collapsible_type === &quot;accordion&quot; || collapsible_type === undefined) { // Handle Accordion
         accordionOpen(element);
       } else { // Handle Expandables
         expandableOpen(element);
</PRE><PRE>         if ($header.hasClass('active')) {
           expandableOpen($header);
         }
       }
     });
</PRE><PRE>     // Open first active
     var $panel_headers = $this.find('&gt; li &gt; .collapsible-header');
     if (options.accordion || collapsible_type === &quot;accordion&quot; || collapsible_type === undefined) { // Handle Accordion
       accordionOpen($panel_headers.filter('.active').first());
     }
     else { // Handle Expandables
       $panel_headers.filter('.active').each(function() {
         expandableOpen($(this));
       });
     }
</PRE><PRE>   });
 };
</PRE><PRE> $(document).ready(function(){
   $('.collapsible').collapsible();
 });
</PRE><P>}( jQuery ));;(function ($) {
</P><PRE> // Add posibility to scroll to selected option
 // usefull for select for example
 $.fn.scrollTo = function(elem) {
   $(this).scrollTop($(this).scrollTop() - $(this).offset().top + $(elem).offset().top);
   return this;
 };
</PRE><PRE> $.fn.dropdown = function (options) {
   var defaults = {
     inDuration: 300,
     outDuration: 225,
     constrain_width: true, // Constrains width of dropdown to the activator
     hover: false,
     gutter: 0, // Spacing from edge
     belowOrigin: false,
     alignment: 'left',
     stopPropagation: false
   };
</PRE><PRE>   // Open dropdown.
   if (options === &quot;open&quot;) {
     this.each(function() {
       $(this).trigger('open');
     });
     return false;
   }
</PRE><PRE>   // Close dropdown.
   if (options === &quot;close&quot;) {
     this.each(function() {
       $(this).trigger('close');
     });
     return false;
   }
</PRE><PRE>   this.each(function(){
     var origin = $(this);
     var options = $.extend({}, defaults, options);
     var isFocused = false;
</PRE><PRE>     // Dropdown menu
     var activates = $(&quot;#&quot;+ origin.attr('data-activates'));
</PRE><PRE>     function updateOptions() {
       if (origin.data('induration') !== undefined)
         options.inDuration = origin.data('induration');
       if (origin.data('outduration') !== undefined)
         options.outDuration = origin.data('outduration');
       if (origin.data('constrainwidth') !== undefined)
         options.constrain_width = origin.data('constrainwidth');
       if (origin.data('hover') !== undefined)
         options.hover = origin.data('hover');
       if (origin.data('gutter') !== undefined)
         options.gutter = origin.data('gutter');
       if (origin.data('beloworigin') !== undefined)
         options.belowOrigin = origin.data('beloworigin');
       if (origin.data('alignment') !== undefined)
         options.alignment = origin.data('alignment');
       if (origin.data('stoppropagation') !== undefined)
         options.stopPropagation = origin.data('stoppropagation');
     }
</PRE><PRE>     updateOptions();
</PRE><PRE>     // Attach dropdown to its activator
     origin.after(activates);
</PRE><PRE>     /*
       Helper function to position and resize dropdown.
       Used in hover and click handler.
     */
     function placeDropdown(eventType) {
       // Check for simultaneous focus and click events.
       if (eventType === 'focus') {
         isFocused = true;
       }
</PRE><PRE>       // Check html data attributes
       updateOptions();
</PRE><PRE>       // Set Dropdown state
       activates.addClass('active');
       origin.addClass('active');
</PRE><PRE>       // Constrain width
       if (options.constrain_width === true) {
         activates.css('width', origin.outerWidth());
</PRE><PRE>       } else {
         activates.css('white-space', 'nowrap');
       }
</PRE><PRE>       // Offscreen detection
       var windowHeight = window.innerHeight;
       var originHeight = origin.innerHeight();
       var offsetLeft = origin.offset().left;
       var offsetTop = origin.offset().top - $(window).scrollTop();
       var currAlignment = options.alignment;
       var gutterSpacing = 0;
       var leftPosition = 0;
</PRE><PRE>       // Below Origin
       var verticalOffset = 0;
       if (options.belowOrigin === true) {
         verticalOffset = originHeight;
       }
</PRE><PRE>       // Check for scrolling positioned container.
       var scrollYOffset = 0;
       var scrollXOffset = 0;
       var wrapper = origin.parent();
       if (!wrapper.is('body')) {
         if (wrapper[0].scrollHeight &gt; wrapper[0].clientHeight) {
           scrollYOffset = wrapper[0].scrollTop;
         }
         if (wrapper[0].scrollWidth &gt; wrapper[0].clientWidth) {
           scrollXOffset = wrapper[0].scrollLeft;
         }
       }
</PRE><PRE>       if (offsetLeft + activates.innerWidth() &gt; $(window).width()) {
         // Dropdown goes past screen on right, force right alignment
         currAlignment = 'right';
</PRE><PRE>       } else if (offsetLeft - activates.innerWidth() + origin.innerWidth() &lt; 0) {
         // Dropdown goes past screen on left, force left alignment
         currAlignment = 'left';
       }
       // Vertical bottom offscreen detection
       if (offsetTop + activates.innerHeight() &gt; windowHeight) {
         // If going upwards still goes offscreen, just crop height of dropdown.
         if (offsetTop + originHeight - activates.innerHeight() &lt; 0) {
           var adjustedHeight = windowHeight - offsetTop - verticalOffset;
           activates.css('max-height', adjustedHeight);
         } else {
           // Flow upwards.
           if (!verticalOffset) {
             verticalOffset += originHeight;
           }
           verticalOffset -= activates.innerHeight();
         }
       }
</PRE><PRE>       // Handle edge alignment
       if (currAlignment === 'left') {
         gutterSpacing = options.gutter;
         leftPosition = origin.position().left + gutterSpacing;
       }
       else if (currAlignment === 'right') {
         var offsetRight = origin.position().left + origin.outerWidth() - activates.outerWidth();
         gutterSpacing = -options.gutter;
         leftPosition =  offsetRight + gutterSpacing;
       }
</PRE><PRE>       // Position dropdown
       activates.css({
         position: 'absolute',
         top: origin.position().top + verticalOffset + scrollYOffset,
         left: leftPosition + scrollXOffset
       });
</PRE><PRE>       // Show dropdown
       activates.stop(true, true).css('opacity', 0)
         .slideDown({
           queue: false,
           duration: options.inDuration,
           easing: 'easeOutCubic',
           complete: function() {
             $(this).css('height', <I>);</I>
           }
         })
         .animate( {opacity: 1}, {queue: false, duration: options.inDuration, easing: 'easeOutSine'});
     }
</PRE><PRE>     function hideDropdown() {
       // Check for simultaneous focus and click events.
       isFocused = false;
       activates.fadeOut(options.outDuration);
       activates.removeClass('active');
       origin.removeClass('active');
       setTimeout(function() { activates.css('max-height', <I>); }, options.outDuration);</I>
     }
</PRE><PRE>     // Hover
     if (options.hover) {
       var open = false;
       origin.unbind('click.' + origin.attr('id'));
       // Hover handler to show dropdown
       origin.on('mouseenter', function(e){ // Mouse over
         if (open === false) {
           placeDropdown();
           open = true;
         }
       });
       origin.on('mouseleave', function(e){
         // If hover on origin then to something other than dropdown content, then close
         var toEl = e.toElement || e.relatedTarget; // added browser compatibility for target element
         if(!$(toEl).closest('.dropdown-content').is(activates)) {
           activates.stop(true, true);
           hideDropdown();
           open = false;
         }
       });
</PRE><PRE>       activates.on('mouseleave', function(e){ // Mouse out
         var toEl = e.toElement || e.relatedTarget;
         if(!$(toEl).closest('.dropdown-button').is(origin)) {
           activates.stop(true, true);
           hideDropdown();
           open = false;
         }
       });
</PRE><PRE>       // Click
     } else {
       // Click handler to show dropdown
       origin.unbind('click.' + origin.attr('id'));
       origin.bind('click.'+origin.attr('id'), function(e){
         if (!isFocused) {
           if ( origin[0] == e.currentTarget &amp;&amp; !origin.hasClass('active') &amp;&amp;
                ($(e.target).closest('.dropdown-content').length === 0)) {
             e.preventDefault(); // Prevents button click from moving window
             if (options.stopPropagation) {
               e.stopPropagation();
             }
             placeDropdown('click');
           }
           // If origin is clicked and menu is open, close menu
           else if (origin.hasClass('active')) {
             hideDropdown();
             $(document).unbind('click.'+ activates.attr('id') + ' touchstart.' + activates.attr('id'));
           }
           // If menu open, add click close handler to document
           if (activates.hasClass('active')) {
             $(document).bind('click.'+ activates.attr('id') + ' touchstart.' + activates.attr('id'), function (e) {
               if (!activates.is(e.target) &amp;&amp; !origin.is(e.target) &amp;&amp; (!origin.find(e.target).length) ) {
                 hideDropdown();
                 $(document).unbind('click.'+ activates.attr('id') + ' touchstart.' + activates.attr('id'));
               }
             });
           }
         }
       });
</PRE><PRE>     } // End else
</PRE><PRE>     // Listen to open and close event - useful for select component
     origin.on('open', function(e, eventType) {
       placeDropdown(eventType);
     });
     origin.on('close', hideDropdown);
</PRE><PRE>   });
 }; // End dropdown plugin
</PRE><PRE> $(document).ready(function(){
   $('.dropdown-button').dropdown();
 });
</PRE><P>}( jQuery ));
</P><DL><DT>(function($) {</DT></DL><PRE>   var _stack = 0,
   _lastID = 0,
   _generateID = function() {
     _lastID++;
     return 'materialize-lean-overlay-' + _lastID;
   };
</PRE><PRE> $.fn.extend({
   openModal: function(options) {
</PRE><PRE>     var $body = $('body');
     var oldWidth = $body.innerWidth();
     $body.css('overflow', 'hidden');
     $body.width(oldWidth);
</PRE><PRE>     var defaults = {
       opacity: 0.5,
       in_duration: 350,
       out_duration: 250,
       ready: undefined,
       complete: undefined,
       dismissible: true,
       starting_top: '4%',
       ending_top: '10%'
     };
     var $modal = $(this);
</PRE><PRE>     if ($modal.hasClass('open')) {
       return;
     }
</PRE><PRE>     var overlayID = _generateID();
</PRE>
      var $overlay = $('');
<PRE>     lStack = (++_stack);
</PRE><PRE>     // Store a reference of the overlay
     $overlay.attr('id', overlayID).css('z-index', 1000 + lStack * 2);
     $modal.data('overlay-id', overlayID).css('z-index', 1000 + lStack * 2 + 1);
     $modal.addClass('open');
</PRE><PRE>     $(&quot;body&quot;).append($overlay);
</PRE><PRE>     // Override defaults
     options = $.extend(defaults, options);
</PRE><PRE>     if (options.dismissible) {
       $overlay.click(function() {
         $modal.closeModal(options);
       });
       // Return on ESC
       $(document).on('keyup.leanModal' + overlayID, function(e) {
         if (e.keyCode === 27) {   // ESC key
           $modal.closeModal(options);
         }
       });
     }
</PRE><PRE>     $modal.find(&quot;.modal-close&quot;).on('click.close', function(e) {
       $modal.closeModal(options);
     });
</PRE><PRE>     $overlay.css({ display : &quot;block&quot;, opacity : 0 });
</PRE><PRE>     $modal.css({
       display : &quot;block&quot;,
       opacity: 0
     });
</PRE><PRE>     $overlay.velocity({opacity: options.opacity}, {duration: options.in_duration, queue: false, ease: &quot;easeOutCubic&quot;});
     $modal.data('associated-overlay', $overlay[0]);
</PRE><PRE>     // Define Bottom Sheet animation
     if ($modal.hasClass('bottom-sheet')) {
       $modal.velocity({bottom: &quot;0&quot;, opacity: 1}, {
         duration: options.in_duration,
         queue: false,
         ease: &quot;easeOutCubic&quot;,
         // Handle modal ready callback
         complete: function() {
           if (typeof(options.ready) === &quot;function&quot;) {
             options.ready();
           }
         }
       });
     }
     else {
       $.Velocity.hook($modal, &quot;scaleX&quot;, 0.7);
       $modal.css({ top: options.starting_top });
       $modal.velocity({top: options.ending_top, opacity: 1, scaleX: '1'}, {
         duration: options.in_duration,
         queue: false,
         ease: &quot;easeOutCubic&quot;,
         // Handle modal ready callback
         complete: function() {
           if (typeof(options.ready) === &quot;function&quot;) {
             options.ready();
           }
         }
       });
     }
</PRE><PRE>   }
 });
</PRE><PRE> $.fn.extend({
   closeModal: function(options) {
     var defaults = {
       out_duration: 250,
       complete: undefined
     };
     var $modal = $(this);
     var overlayID = $modal.data('overlay-id');
     var $overlay = $('#' + overlayID);
     $modal.removeClass('open');
</PRE><PRE>     options = $.extend(defaults, options);
</PRE><PRE>     // Enable scrolling
     $('body').css({
       overflow: <I>,</I>
       width: 
     });
</PRE><PRE>     $modal.find('.modal-close').off('click.close');
     $(document).off('keyup.leanModal' + overlayID);
</PRE><PRE>     $overlay.velocity( { opacity: 0}, {duration: options.out_duration, queue: false, ease: &quot;easeOutQuart&quot;});
</PRE><PRE>     // Define Bottom Sheet animation
     if ($modal.hasClass('bottom-sheet')) {
       $modal.velocity({bottom: &quot;-100%&quot;, opacity: 0}, {
         duration: options.out_duration,
         queue: false,
         ease: &quot;easeOutCubic&quot;,
         // Handle modal ready callback
         complete: function() {
           $overlay.css({display:&quot;none&quot;});
</PRE><PRE>           // Call complete callback
           if (typeof(options.complete) === &quot;function&quot;) {
             options.complete();
           }
           $overlay.remove();
           _stack--;
         }
       });
     }
     else {
       $modal.velocity(
         { top: options.starting_top, opacity: 0, scaleX: 0.7}, {
         duration: options.out_duration,
         complete:
           function() {
</PRE><PRE>             $(this).css('display', 'none');
             // Call complete callback
             if (typeof(options.complete) === &quot;function&quot;) {
               options.complete();
             }
             $overlay.remove();
             _stack--;
           }
         }
       );
     }
   }
 });
</PRE><PRE> $.fn.extend({
   leanModal: function(option) {
     return this.each(function() {
</PRE><PRE>       var defaults = {
         starting_top: '4%'
       },
       // Override defaults
       options = $.extend(defaults, option);
</PRE><PRE>       // Close Handlers
       $(this).click(function(e) {
         options.starting_top = ($(this).offset().top - $(window).scrollTop()) /1.15;
         var modal_id = $(this).attr(&quot;href&quot;) || '#' + $(this).data('target');
         $(modal_id).openModal(options);
         e.preventDefault();
       }); // done set on click
     }); // done return
   }
 });
</PRE><P>})(jQuery);
</P><DL><DT>(function ($) {</DT></DL><PRE> $.fn.materialbox = function () {
</PRE><PRE>   return this.each(function() {
</PRE><PRE>     if ($(this).hasClass('initialized')) {
       return;
     }
</PRE><PRE>     $(this).addClass('initialized');
</PRE><PRE>     var overlayActive = false;
     var doneAnimating = true;
     var inDuration = 275;
     var outDuration = 200;
     var origin = $(this);
</PRE>
      var placeholder = $('').addClass('material-placeholder');
<PRE>     var originalWidth = 0;
     var originalHeight = 0;
     var ancestorsChanged;
     var ancestor;
     origin.wrap(placeholder);
</PRE><PRE>     origin.on('click', function(){
       var placeholder = origin.parent('.material-placeholder');
       var windowWidth = window.innerWidth;
       var windowHeight = window.innerHeight;
       var originalWidth = origin.width();
       var originalHeight = origin.height();
</PRE><PRE>       // If already modal, return to original
       if (doneAnimating === false) {
         returnToOriginal();
         return false;
       }
       else if (overlayActive &amp;&amp; doneAnimating===true) {
         returnToOriginal();
         return false;
       }
</PRE><PRE>       // Set states
       doneAnimating = false;
       origin.addClass('active');
       overlayActive = true;
</PRE><PRE>       // Set positioning for placeholder
       placeholder.css({
         width: placeholder[0].getBoundingClientRect().width,
         height: placeholder[0].getBoundingClientRect().height,
         position: 'relative',
         top: 0,
         left: 0
       });
</PRE><PRE>       // Find ancestor with overflow: hidden; and remove it
       ancestorsChanged = undefined;
       ancestor = placeholder[0].parentNode;
       var count = 0;
       while (ancestor !== null &amp;&amp; !$(ancestor).is(document)) {
         var curr = $(ancestor);
         if (curr.css('overflow') !== 'visible') {
           curr.css('overflow', 'visible');
           if (ancestorsChanged === undefined) {
             ancestorsChanged = curr;
           }
           else {
             ancestorsChanged = ancestorsChanged.add(curr);
           }
         }
         ancestor = ancestor.parentNode;
       }
</PRE><PRE>       // Set css on origin
       origin.css({position: 'absolute', 'z-index': 1000})
       .data('width', originalWidth)
       .data('height', originalHeight);
</PRE><PRE>       // Add overlay
</PRE>
        var overlay = $('')
<PRE>         .css({
           opacity: 0
         })
         .click(function(){
           if (doneAnimating === true)
           returnToOriginal();
         });
         // Animate Overlay
         // Put before in origin image to preserve z-index layering.
         origin.before(overlay);
         overlay.velocity({opacity: 1},
                          {duration: inDuration, queue: false, easing: 'easeOutQuad'} );
</PRE><PRE>       // Add and animate caption if it exists
       if (origin.data('caption') !== &quot;&quot;) {
</PRE>
          var $photo_caption = $('');
<PRE>         $photo_caption.text(origin.data('caption'));
         $('body').append($photo_caption);
         $photo_caption.css({ &quot;display&quot;: &quot;inline&quot; });
         $photo_caption.velocity({opacity: 1}, {duration: inDuration, queue: false, easing: 'easeOutQuad'});
       }
</PRE><PRE>       // Resize Image
       var ratio = 0;
       var widthPercent = originalWidth / windowWidth;
       var heightPercent = originalHeight / windowHeight;
       var newWidth = 0;
       var newHeight = 0;
</PRE><PRE>       if (widthPercent &gt; heightPercent) {
         ratio = originalHeight / originalWidth;
         newWidth = windowWidth * 0.9;
         newHeight = windowWidth * 0.9 * ratio;
       }
       else {
         ratio = originalWidth / originalHeight;
         newWidth = (windowHeight * 0.9) * ratio;
         newHeight = windowHeight * 0.9;
       }
</PRE><PRE>       // Animate image + set z-index
       if(origin.hasClass('responsive-img')) {
         origin.velocity({'max-width': newWidth, 'width': originalWidth}, {duration: 0, queue: false,
           complete: function(){
             origin.css({left: 0, top: 0})
             .velocity(
               {
                 height: newHeight,
                 width: newWidth,
                 left: $(document).scrollLeft() + windowWidth/2 - origin.parent('.material-placeholder').offset().left - newWidth/2,
                 top: $(document).scrollTop() + windowHeight/2 - origin.parent('.material-placeholder').offset().top - newHeight/ 2
               },
               {
                 duration: inDuration,
                 queue: false,
                 easing: 'easeOutQuad',
                 complete: function(){doneAnimating = true;}
               }
             );
           } // End Complete
         }); // End Velocity
       }
       else {
         origin.css('left', 0)
         .css('top', 0)
         .velocity(
           {
             height: newHeight,
             width: newWidth,
             left: $(document).scrollLeft() + windowWidth/2 - origin.parent('.material-placeholder').offset().left - newWidth/2,
             top: $(document).scrollTop() + windowHeight/2 - origin.parent('.material-placeholder').offset().top - newHeight/ 2
           },
           {
             duration: inDuration,
             queue: false,
             easing: 'easeOutQuad',
             complete: function(){doneAnimating = true;}
           }
           ); // End Velocity
       }
</PRE><PRE>   }); // End origin on click
</PRE><PRE>     // Return on scroll
     $(window).scroll(function() {
       if (overlayActive) {
         returnToOriginal();
       }
     });
</PRE><PRE>     // Return on ESC
     $(document).keyup(function(e) {
</PRE><PRE>       if (e.keyCode === 27 &amp;&amp; doneAnimating === true) {   // ESC key
         if (overlayActive) {
           returnToOriginal();
         }
       }
     });
</PRE><PRE>     // This function returns the modaled image to the original spot
     function returnToOriginal() {
</PRE><PRE>         doneAnimating = false;
</PRE><PRE>         var placeholder = origin.parent('.material-placeholder');
         var windowWidth = window.innerWidth;
         var windowHeight = window.innerHeight;
         var originalWidth = origin.data('width');
         var originalHeight = origin.data('height');
</PRE><PRE>         origin.velocity(&quot;stop&quot;, true);
         $('#materialbox-overlay').velocity(&quot;stop&quot;, true);
         $('.materialbox-caption').velocity(&quot;stop&quot;, true);
</PRE><PRE>         $('#materialbox-overlay').velocity({opacity: 0}, {
           duration: outDuration, // Delay prevents animation overlapping
           queue: false, easing: 'easeOutQuad',
           complete: function(){
             // Remove Overlay
             overlayActive = false;
             $(this).remove();
           }
         });
</PRE><PRE>         // Resize Image
         origin.velocity(
           {
             width: originalWidth,
             height: originalHeight,
             left: 0,
             top: 0
           },
           {
             duration: outDuration,
             queue: false, easing: 'easeOutQuad'
           }
         );
</PRE><PRE>         // Remove Caption + reset css settings on image
         $('.materialbox-caption').velocity({opacity: 0}, {
           duration: outDuration, // Delay prevents animation overlapping
           queue: false, easing: 'easeOutQuad',
           complete: function(){
             placeholder.css({
               height: <I>,</I>
               width: <I>,</I>
               position: <I>,</I>
               top: <I>,</I>
               left: 
             });
</PRE><PRE>             origin.css({
               height: <I>,</I>
               top: <I>,</I>
               left: <I>,</I>
               width: <I>,</I>
               'max-width': <I>,</I>
               position: <I>,</I>
               'z-index': 
             });
</PRE><PRE>             // Remove class
             origin.removeClass('active');
             doneAnimating = true;
             $(this).remove();
</PRE><PRE>             // Remove overflow overrides on ancestors
             if (ancestorsChanged) {
               ancestorsChanged.css('overflow', <I>);</I>
             }
           }
         });
</PRE><PRE>       }
       });
</PRE><P>};
</P><P>$(document).ready(function(){
</P><PRE> $('.materialboxed').materialbox();
</PRE><P>});
</P><P>}( jQuery ));
</P><DL><DT>(function ($) {</DT></DL><PRE>   $.fn.parallax = function () {
     var window_width = $(window).width();
     // Parallax Scripts
     return this.each(function(i) {
       var $this = $(this);
       $this.addClass('parallax');
</PRE><PRE>       function updateParallax(initial) {
         var container_height;
         if (window_width &lt; 601) {
           container_height = ($this.height() &gt; 0) ? $this.height() : $this.children(&quot;img&quot;).height();
         }
         else {
           container_height = ($this.height() &gt; 0) ? $this.height() : 500;
         }
         var $img = $this.children(&quot;img&quot;).first();
         var img_height = $img.height();
         var parallax_dist = img_height - container_height;
         var bottom = $this.offset().top + container_height;
         var top = $this.offset().top;
         var scrollTop = $(window).scrollTop();
         var windowHeight = window.innerHeight;
         var windowBottom = scrollTop + windowHeight;
         var percentScrolled = (windowBottom - top) / (container_height + windowHeight);
         var parallax = Math.round((parallax_dist * percentScrolled));
</PRE><PRE>         if (initial) {
           $img.css('display', 'block');
         }
         if ((bottom &gt; scrollTop) &amp;&amp; (top &lt; (scrollTop + windowHeight))) {
           $img.css('transform', &quot;translate3D(-50%,&quot; + parallax + &quot;px, 0)&quot;);
         }
</PRE><PRE>       }
</PRE><PRE>       // Wait for image load
       $this.children(&quot;img&quot;).one(&quot;load&quot;, function() {
         updateParallax(true);
       }).each(function() {
         if(this.complete) $(this).load();
       });
</PRE><PRE>       $(window).scroll(function() {
         window_width = $(window).width();
         updateParallax(false);
       });
</PRE><PRE>       $(window).resize(function() {
         window_width = $(window).width();
         updateParallax(false);
       });
</PRE><PRE>     });
</PRE><PRE>   };
</PRE><P>}( jQuery ));;(function ($) {
</P><PRE> var methods = {
   init : function(options) {
     var defaults = {
       onShow: null
     };
     options = $.extend(defaults, options);
</PRE><PRE>     return this.each(function() {
</PRE><PRE>     // For each set of tabs, we want to keep track of
     // which tab is active and its associated content
     var $this = $(this),
         window_width = $(window).width();
</PRE><PRE>     $this.width('100%');
     var $active, $content, $links = $this.find('li.tab a'),
         $tabs_width = $this.width(),
         $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length,
         $index = 0;
</PRE><PRE>     // If the location.hash matches one of the links, use that as the active tab.
     $active = $($links.filter('[href=&quot;'+location.hash+'&quot;]'));
</PRE><PRE>     // If no match is found, use the first link or any with class 'active' as the initial active tab.
     if ($active.length === 0) {
       $active = $(this).find('li.tab a.active').first();
     }
     if ($active.length === 0) {
       $active = $(this).find('li.tab a').first();
     }
</PRE><PRE>     $active.addClass('active');
     $index = $links.index($active);
     if ($index &lt; 0) {
       $index = 0;
     }
</PRE><PRE>     if ($active[0] !== undefined) {
       $content = $($active[0].hash);
     }
</PRE><PRE>     // append indicator then set indicator width to tab width
</PRE>
      $this.append('');
<PRE>     var $indicator = $this.find('.indicator');
     if ($this.is(&quot;:visible&quot;)) {
       $indicator.css({&quot;right&quot;: $tabs_width - (($index + 1) * $tab_width)});
       $indicator.css({&quot;left&quot;: $index * $tab_width});
     }
     $(window).resize(function () {
       $tabs_width = $this.width();
       $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;
       if ($index &lt; 0) {
         $index = 0;
       }
       if ($tab_width !== 0 &amp;&amp; $tabs_width !== 0) {
         $indicator.css({&quot;right&quot;: $tabs_width - (($index + 1) * $tab_width)});
         $indicator.css({&quot;left&quot;: $index * $tab_width});
       }
     });
</PRE><PRE>     // Hide the remaining content
     $links.not($active).each(function () {
       $(this.hash).hide();
     });
</PRE><PRE>     // Bind the click event handler
     $this.on('click', 'a', function(e) {
       if ($(this).parent().hasClass('disabled')) {
         e.preventDefault();
         return;
       }
</PRE><PRE>       // Act as regular link if target attribute is specified.
       if (!!$(this).attr(&quot;target&quot;)) {
         return;
       }
</PRE><PRE>       $tabs_width = $this.width();
       $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;
</PRE><PRE>       // Make the old tab inactive.
       $active.removeClass('active');
       if ($content !== undefined) {
         $content.hide();
       }
</PRE><PRE>       // Update the variables with the new link and content
       $active = $(this);
       $content = $(this.hash);
       $links = $this.find('li.tab a');
</PRE><PRE>       // Make the tab active.
       $active.addClass('active');
       var $prev_index = $index;
       $index = $links.index($(this));
       if ($index &lt; 0) {
         $index = 0;
       }
       // Change url to current tab
       // window.location.hash = $active.attr('href');
</PRE><PRE>       if ($content !== undefined) {
         $content.show();
         if (typeof(options.onShow) === &quot;function&quot;) {
           options.onShow.call(this, $content);
         }
       }
</PRE><PRE>       // Update indicator
       if (($index - $prev_index) &gt;= 0) {
         $indicator.velocity({&quot;right&quot;: $tabs_width - (($index + 1) * $tab_width)}, { duration: 300, queue: false, easing: 'easeOutQuad'});
         $indicator.velocity({&quot;left&quot;: $index * $tab_width}, {duration: 300, queue: false, easing: 'easeOutQuad', delay: 90});
</PRE><PRE>       }
       else {
         $indicator.velocity({&quot;left&quot;: $index * $tab_width}, { duration: 300, queue: false, easing: 'easeOutQuad'});
         $indicator.velocity({&quot;right&quot;: $tabs_width - (($index + 1) * $tab_width)}, {duration: 300, queue: false, easing: 'easeOutQuad', delay: 90});
       }
</PRE><PRE>       // Prevent the anchor's default click action
       e.preventDefault();
     });
   });
</PRE><PRE>   },
   select_tab : function( id ) {
     this.find('a[href=&quot;#' + id + '&quot;]').trigger('click');
   }
 };
</PRE><PRE> $.fn.tabs = function(methodOrOptions) {
   if ( methods[methodOrOptions] ) {
     return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
   } else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {
     // Default to &quot;init&quot;
     return methods.init.apply( this, arguments );
   } else {
     $.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.tooltip' );
   }
 };
</PRE><PRE> $(document).ready(function(){
   $('ul.tabs').tabs();
 });
</PRE><P>}( jQuery ));
</P><DL><DT>(function ($) {</DT></DL><PRE>   $.fn.tooltip = function (options) {
     var timeout = null,
     margin = 5;
</PRE><PRE>     // Defaults
     var defaults = {
       delay: 350,
       tooltip: <I>,</I>
       position: 'bottom',
       html: false
     };
</PRE><PRE>     // Remove tooltip from the activator
     if (options === &quot;remove&quot;) {
       this.each(function() {
         $('#' + $(this).attr('data-tooltip-id')).remove();
         $(this).off('mouseenter.tooltip mouseleave.tooltip');
       });
       return false;
     }
</PRE><PRE>     options = $.extend(defaults, options);
</PRE><PRE>     return this.each(function() {
       var tooltipId = Materialize.guid();
       var origin = $(this);
       origin.attr('data-tooltip-id', tooltipId);
</PRE><PRE>       // Get attributes.
       var allowHtml,
           tooltipDelay,
           tooltipPosition,
           tooltipText,
           tooltipEl,
           backdrop;
       var setAttributes = function() {
         allowHtml = origin.attr('data-html') ? origin.attr('data-html') === 'true' : options.html;
         tooltipDelay = origin.attr('data-delay');
         tooltipDelay = (tooltipDelay === undefined || tooltipDelay === <I>) ?</I>
             options.delay : tooltipDelay;
         tooltipPosition = origin.attr('data-position');
         tooltipPosition = (tooltipPosition === undefined || tooltipPosition === <I>) ?</I>
             options.position : tooltipPosition;
         tooltipText = origin.attr('data-tooltip');
         tooltipText = (tooltipText === undefined || tooltipText === <I>) ?</I>
             options.tooltip : tooltipText;
       };
       setAttributes();
</PRE><PRE>       var renderTooltipEl = function() {
</PRE>
          var tooltip = $('');
<PRE>         // Create Text span
         if (allowHtml) {
           tooltipText = $('').html(tooltipText);
         } else{
           tooltipText = $('').text(tooltipText);
         }
</PRE><PRE>         // Create tooltip
         tooltip.append(tooltipText)
           .appendTo($('body'))
           .attr('id', tooltipId);
</PRE><PRE>         // Create backdrop
</PRE>
          backdrop = $('');
<PRE>         backdrop.appendTo(tooltip);
         return tooltip;
       };
       tooltipEl = renderTooltipEl();
</PRE><PRE>       // Destroy previously binded events
       origin.off('mouseenter.tooltip mouseleave.tooltip');
       // Mouse In
       var started = false, timeoutRef;
       origin.on({'mouseenter.tooltip': function(e) {
         var showTooltip = function() {
           setAttributes();
           started = true;
           tooltipEl.velocity('stop');
           backdrop.velocity('stop');
           tooltipEl.css({ display: 'block', left: '0px', top: '0px' });
</PRE><PRE>           // Tooltip positioning
           var originWidth = origin.outerWidth();
           var originHeight = origin.outerHeight();
</PRE><PRE>           var tooltipHeight = tooltipEl.outerHeight();
           var tooltipWidth = tooltipEl.outerWidth();
           var tooltipVerticalMovement = '0px';
           var tooltipHorizontalMovement = '0px';
           var scaleXFactor = 8;
           var scaleYFactor = 8;
           var targetTop, targetLeft, newCoordinates;
</PRE><PRE>           if (tooltipPosition === &quot;top&quot;) {
             // Top Position
             targetTop = origin.offset().top - tooltipHeight - margin;
             targetLeft = origin.offset().left + originWidth/2 - tooltipWidth/2;
             newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
</PRE><PRE>         tooltipVerticalMovement = '-10px';
             backdrop.css({
               bottom: 0,
               left: 0,
               borderRadius: '14px 14px 0 0',
               transformOrigin: '50% 100%',
               marginTop: tooltipHeight,
               marginLeft: (tooltipWidth/2) - (backdrop.width()/2)
             });
           }
           // Left Position
           else if (tooltipPosition === &quot;left&quot;) {
             targetTop = origin.offset().top + originHeight/2 - tooltipHeight/2;
             targetLeft =  origin.offset().left - tooltipWidth - margin;
             newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
</PRE><PRE>             tooltipHorizontalMovement = '-10px';
             backdrop.css({
               top: '-7px',
               right: 0,
               width: '14px',
               height: '14px',
               borderRadius: '14px 0 0 14px',
               transformOrigin: '95% 50%',
               marginTop: tooltipHeight/2,
               marginLeft: tooltipWidth
             });
           }
           // Right Position
           else if (tooltipPosition === &quot;right&quot;) {
             targetTop = origin.offset().top + originHeight/2 - tooltipHeight/2;
             targetLeft = origin.offset().left + originWidth + margin;
             newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
</PRE><PRE>             tooltipHorizontalMovement = '+10px';
             backdrop.css({
               top: '-7px',
               left: 0,
               width: '14px',
               height: '14px',
               borderRadius: '0 14px 14px 0',
               transformOrigin: '5% 50%',
               marginTop: tooltipHeight/2,
               marginLeft: '0px'
             });
           }
           else {
             // Bottom Position
             targetTop = origin.offset().top + origin.outerHeight() + margin;
             targetLeft = origin.offset().left + originWidth/2 - tooltipWidth/2;
             newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
             tooltipVerticalMovement = '+10px';
             backdrop.css({
               top: 0,
               left: 0,
               marginLeft: (tooltipWidth/2) - (backdrop.width()/2)
             });
           }
</PRE><PRE>           // Set tooptip css placement
           tooltipEl.css({
             top: newCoordinates.y,
             left: newCoordinates.x
           });
</PRE><PRE>           // Calculate Scale to fill
           scaleXFactor = Math.SQRT2 * tooltipWidth / parseInt(backdrop.css('width'));
           scaleYFactor = Math.SQRT2 * tooltipHeight / parseInt(backdrop.css('height'));
</PRE><PRE>           tooltipEl.velocity({ marginTop: tooltipVerticalMovement, marginLeft: tooltipHorizontalMovement}, { duration: 350, queue: false })
             .velocity({opacity: 1}, {duration: 300, delay: 50, queue: false});
           backdrop.css({ display: 'block' })
             .velocity({opacity:1},{duration: 55, delay: 0, queue: false})
             .velocity({scaleX: scaleXFactor, scaleY: scaleYFactor}, {duration: 300, delay: 0, queue: false, easing: 'easeInOutQuad'});
         };
</PRE><PRE>         timeoutRef = setTimeout(showTooltip, tooltipDelay); // End Interval
</PRE><PRE>       // Mouse Out
       },
       'mouseleave.tooltip': function(){
         // Reset State
         started = false;
         clearTimeout(timeoutRef);
</PRE><PRE>         // Animate back
         setTimeout(function() {
           if (started !== true) {
             tooltipEl.velocity({
               opacity: 0, marginTop: 0, marginLeft: 0}, { duration: 225, queue: false});
             backdrop.velocity({opacity: 0, scaleX: 1, scaleY: 1}, {
               duration:225,
               queue: false,
               complete: function(){
                 backdrop.css('display', 'none');
                 tooltipEl.css('display', 'none');
                 started = false;}
             });
           }
         },225);
       }
       });
   });
 };
</PRE><PRE> var repositionWithinScreen = function(x, y, width, height) {
   var newX = x;
   var newY = y;
</PRE><PRE>   if (newX &lt; 0) {
     newX = 4;
   } else if (newX + width &gt; window.innerWidth) {
     newX -= newX + width - window.innerWidth;
   }
</PRE><PRE>   if (newY &lt; 0) {
     newY = 4;
   } else if (newY + height &gt; window.innerHeight + $(window).scrollTop) {
     newY -= newY + height - window.innerHeight;
   }
</PRE><PRE>   return {x: newX, y: newY};
 };
</PRE><PRE> $(document).ready(function(){
    $('.tooltipped').tooltip();
  });
</PRE><P>}( jQuery ));
</P><DL><DT>/*!</DT></DL><PRE>* Waves v0.6.4
* <A rel="nofollow" class="external free" href="http://fian.my.id/Waves">http://fian.my.id/Waves</A>
*
* Copyright 2014 Alfiana E. Sibuea and other contributors
* Released under the MIT license
* <A rel="nofollow" class="external free" href="https://github.com/fians/Waves/blob/master/LICENSE">https://github.com/fians/Waves/blob/master/LICENSE</A>
*/
</PRE><DL><DT>(function(window) {</DT></DL><PRE>   'use strict';
</PRE><PRE>   var Waves = Waves || {};
   var $$ = document.querySelectorAll.bind(document);
</PRE><PRE>   // Find exact position of element
   function isWindow(obj) {
       return obj !== null &amp;&amp; obj === obj.window;
   }
</PRE><PRE>   function getWindow(elem) {
       return isWindow(elem) ? elem : elem.nodeType === 9 &amp;&amp; elem.defaultView;
   }
</PRE><PRE>   function offset(elem) {
       var docElem, win,
           box = {top: 0, left: 0},
           doc = elem &amp;&amp; elem.ownerDocument;
</PRE><PRE>       docElem = doc.documentElement;
</PRE><PRE>       if (typeof elem.getBoundingClientRect !== typeof undefined) {
           box = elem.getBoundingClientRect();
       }
       win = getWindow(doc);
       return {
           top: box.top + win.pageYOffset - docElem.clientTop,
           left: box.left + win.pageXOffset - docElem.clientLeft
       };
   }
</PRE><PRE>   function convertStyle(obj) {
       var style = <I>;</I></PRE><PRE>       for (var a in obj) {
           if (obj.hasOwnProperty(a)) {
               style += (a + ':' + obj[a] + ';');
           }
       }
</PRE><PRE>       return style;
   }
</PRE><PRE>   var Effect = {
</PRE><PRE>       // Effect delay
       duration: 750,
</PRE><PRE>       show: function(e, element) {
</PRE><PRE>           // Disable right click
           if (e.button === 2) {
               return false;
           }
</PRE><PRE>           var el = element || this;
</PRE><PRE>           // Create ripple
           var ripple = document.createElement('div');
           ripple.className = 'waves-ripple';
           el.appendChild(ripple);
</PRE><PRE>           // Get click coordinate and element witdh
           var pos         = offset(el);
           var relativeY   = (e.pageY - pos.top);
           var relativeX   = (e.pageX - pos.left);
           var scale       = 'scale('+((el.clientWidth / 100) * 10)+')';
</PRE><PRE>           // Support for touch devices
           if ('touches' in e) {
             relativeY   = (e.touches[0].pageY - pos.top);
             relativeX   = (e.touches[0].pageX - pos.left);
           }
</PRE><PRE>           // Attach data to element
           ripple.setAttribute('data-hold', Date.now());
           ripple.setAttribute('data-scale', scale);
           ripple.setAttribute('data-x', relativeX);
           ripple.setAttribute('data-y', relativeY);
</PRE><PRE>           // Set ripple position
           var rippleStyle = {
               'top': relativeY+'px',
               'left': relativeX+'px'
           };
</PRE><PRE>           ripple.className = ripple.className + ' waves-notransition';
           ripple.setAttribute('style', convertStyle(rippleStyle));
           ripple.className = ripple.className.replace('waves-notransition', <I>);</I></PRE><PRE>           // Scale the ripple
           rippleStyle['-webkit-transform'] = scale;
           rippleStyle['-moz-transform'] = scale;
           rippleStyle['-ms-transform'] = scale;
           rippleStyle['-o-transform'] = scale;
           rippleStyle.transform = scale;
           rippleStyle.opacity   = '1';
</PRE><PRE>           rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';
           rippleStyle['-moz-transition-duration']    = Effect.duration + 'ms';
           rippleStyle['-o-transition-duration']      = Effect.duration + 'ms';
           rippleStyle['transition-duration']         = Effect.duration + 'ms';
</PRE><PRE>           rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
           rippleStyle['-moz-transition-timing-function']    = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
           rippleStyle['-o-transition-timing-function']      = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
           rippleStyle['transition-timing-function']         = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
</PRE><PRE>           ripple.setAttribute('style', convertStyle(rippleStyle));
       },
</PRE><PRE>       hide: function(e) {
           TouchHandler.touchup(e);
</PRE><PRE>           var el = this;
           var width = el.clientWidth * 1.4;
</PRE><PRE>           // Get first ripple
           var ripple = null;
           var ripples = el.getElementsByClassName('waves-ripple');
           if (ripples.length &gt; 0) {
               ripple = ripples[ripples.length - 1];
           } else {
               return false;
           }
</PRE><PRE>           var relativeX   = ripple.getAttribute('data-x');
           var relativeY   = ripple.getAttribute('data-y');
           var scale       = ripple.getAttribute('data-scale');
</PRE><PRE>           // Get delay beetween mousedown and mouse leave
           var diff = Date.now() - Number(ripple.getAttribute('data-hold'));
           var delay = 350 - diff;
</PRE><PRE>           if (delay &lt; 0) {
               delay = 0;
           }
</PRE><PRE>           // Fade out ripple after delay
           setTimeout(function() {
               var style = {
                   'top': relativeY+'px',
                   'left': relativeX+'px',
                   'opacity': '0',
</PRE><PRE>                   // Duration
                   '-webkit-transition-duration': Effect.duration + 'ms',
                   '-moz-transition-duration': Effect.duration + 'ms',
                   '-o-transition-duration': Effect.duration + 'ms',
                   'transition-duration': Effect.duration + 'ms',
                   '-webkit-transform': scale,
                   '-moz-transform': scale,
                   '-ms-transform': scale,
                   '-o-transform': scale,
                   'transform': scale,
               };
</PRE><PRE>               ripple.setAttribute('style', convertStyle(style));
</PRE><PRE>               setTimeout(function() {
                   try {
                       el.removeChild(ripple);
                   } catch(e) {
                       return false;
                   }
               }, Effect.duration);
           }, delay);
       },
</PRE><PRE>       // Little hack to make &lt;input&gt; can perform waves effect
       wrapInput: function(elements) {
           for (var a = 0; a &lt; elements.length; a++) {
               var el = elements[a];
</PRE><PRE>               if (el.tagName.toLowerCase() === 'input') {
                   var parent = el.parentNode;
</PRE><PRE>                   // If input already have parent just pass through
                   if (parent.tagName.toLowerCase() === 'i' &amp;&amp; parent.className.indexOf('waves-effect') !== -1) {
                       continue;
                   }
</PRE><PRE>                   // Put element class and style to the specified parent
                   var wrapper = document.createElement('i');
                   wrapper.className = el.className + ' waves-input-wrapper';
</PRE><PRE>                   var elementStyle = el.getAttribute('style');
</PRE><PRE>                   if (!elementStyle) {
                       elementStyle = <I>;</I>
                   }
</PRE><PRE>                   wrapper.setAttribute('style', elementStyle);
</PRE><PRE>                   el.className = 'waves-button-input';
                   el.removeAttribute('style');
</PRE><PRE>                   // Put element as child
                   parent.replaceChild(wrapper, el);
                   wrapper.appendChild(el);
               }
           }
       }
   };
</PRE><PRE>   /**
    * Disable mousedown event for 500ms during and after touch
    */
   var TouchHandler = {
       /* uses an integer rather than bool so there's no issues with
        * needing to clear timeouts if another touch event occurred
        * within the 500ms. Cannot mouseup between touchstart and
        * touchend, nor in the 500ms after touchend. */
       touches: 0,
       allowEvent: function(e) {
           var allow = true;
</PRE><PRE>           if (e.type === 'touchstart') {
               TouchHandler.touches += 1; //push
           } else if (e.type === 'touchend' || e.type === 'touchcancel') {
               setTimeout(function() {
                   if (TouchHandler.touches &gt; 0) {
                       TouchHandler.touches -= 1; //pop after 500ms
                   }
               }, 500);
           } else if (e.type === 'mousedown' &amp;&amp; TouchHandler.touches &gt; 0) {
               allow = false;
           }
</PRE><PRE>           return allow;
       },
       touchup: function(e) {
           TouchHandler.allowEvent(e);
       }
   };
</PRE><PRE>   /**
    * Delegated click handler for .waves-effect element.
    * returns null when .waves-effect element not in &quot;click tree&quot;
    */
   function getWavesEffectElement(e) {
       if (TouchHandler.allowEvent(e) === false) {
           return null;
       }
</PRE><PRE>       var element = null;
       var target = e.target || e.srcElement;
</PRE><PRE>       while (target.parentElement !== null) {
           if (!(target instanceof SVGElement) &amp;&amp; target.className.indexOf('waves-effect') !== -1) {
               element = target;
               break;
           } else if (target.classList.contains('waves-effect')) {
               element = target;
               break;
           }
           target = target.parentElement;
       }
</PRE><PRE>       return element;
   }
</PRE><PRE>   /**
    * Bubble the click and show effect if .waves-effect elem was found
    */
   function showEffect(e) {
       var element = getWavesEffectElement(e);
</PRE><PRE>       if (element !== null) {
           Effect.show(e, element);
</PRE><PRE>           if ('ontouchstart' in window) {
               element.addEventListener('touchend', Effect.hide, false);
               element.addEventListener('touchcancel', Effect.hide, false);
           }
</PRE><PRE>           element.addEventListener('mouseup', Effect.hide, false);
           element.addEventListener('mouseleave', Effect.hide, false);
       }
   }
</PRE><PRE>   Waves.displayEffect = function(options) {
       options = options || {};
</PRE><PRE>       if ('duration' in options) {
           Effect.duration = options.duration;
       }
</PRE><PRE>       //Wrap input inside <I> tag
       Effect.wrapInput($$('.waves-effect'));
</I></PRE><PRE>       if ('ontouchstart' in window) {
           document.body.addEventListener('touchstart', showEffect, false);
       }
</PRE><PRE>       document.body.addEventListener('mousedown', showEffect, false);
   };
</PRE><PRE>   /**
    * Attach Waves to an input element (or any element which doesn't
    * bubble mouseup/mousedown events).
    *   Intended to be used with dynamically loaded forms/inputs, or
    * where the user doesn't want a delegated click handler.
    */
   Waves.attach = function(element) {
       //FUTURE: automatically add waves classes and allow users
       // to specify them with an options param? Eg. light/classic/button
       if (element.tagName.toLowerCase() === 'input') {
           Effect.wrapInput([element]);
           element = element.parentElement;
       }
</PRE><PRE>       if ('ontouchstart' in window) {
           element.addEventListener('touchstart', showEffect, false);
       }
</PRE><PRE>       element.addEventListener('mousedown', showEffect, false);
   };
</PRE><PRE>   window.Waves = Waves;
</PRE><PRE>   document.addEventListener('DOMContentLoaded', function() {
       Waves.displayEffect();
   }, false);
</PRE><P>})(window);
</P><DL><DT>Materialize.toast = function (message, displayLength, className, completeCallback) {</DT></DL><PRE>   className = className || &quot;&quot;;
</PRE><PRE>   var container = document.getElementById('toast-container');
</PRE><PRE>   // Create toast container if it does not exist
   if (container === null) {
       // create notification container
       container = document.createElement('div');
       container.id = 'toast-container';
       document.body.appendChild(container);
   }
</PRE><PRE>   // Select and append toast
   var newToast = createToast(message);
</PRE><PRE>   // only append toast if message is not undefined
   if(message){
       container.appendChild(newToast);
   }
</PRE><PRE>   newToast.style.top = '35px';
   newToast.style.opacity = 0;
</PRE><PRE>   // Animate toast in
   Vel(newToast, { &quot;top&quot; : &quot;0px&quot;, opacity: 1 }, {duration: 300,
     easing: 'easeOutCubic',
     queue: false});
</PRE><PRE>   // Allows timer to be pause while being panned
   var timeLeft = displayLength;
   var counterInterval = setInterval (function(){
</PRE><PRE>     if (newToast.parentNode === null)
       window.clearInterval(counterInterval);
</PRE><PRE>     // If toast is not being dragged, decrease its time remaining
     if (!newToast.classList.contains('panning')) {
       timeLeft -= 20;
     }
</PRE><PRE>     if (timeLeft &lt;= 0) {
       // Animate toast out
       Vel(newToast, {&quot;opacity&quot;: 0, marginTop: '-40px'}, { duration: 375,
           easing: 'easeOutExpo',
           queue: false,
           complete: function(){
             // Call the optional callback
             if(typeof(completeCallback) === &quot;function&quot;)
               completeCallback();
             // Remove toast after it times out
             this[0].parentNode.removeChild(this[0]);
           }
         });
       window.clearInterval(counterInterval);
     }
   }, 20);
</PRE><PRE>   function createToast(html) {
</PRE><PRE>       // Create toast
       var toast = document.createElement('div');
       toast.classList.add('toast');
       if (className) {
           var classes = className.split(' ');
</PRE><PRE>           for (var i = 0, count = classes.length; i &lt; count; i++) {
               toast.classList.add(classes[i]);
           }
       }
       // If type of parameter is HTML Element
       if ( typeof HTMLElement === &quot;object&quot; ? html instanceof HTMLElement : html &amp;&amp; typeof html === &quot;object&quot; &amp;&amp; html !== null &amp;&amp; html.nodeType === 1 &amp;&amp; typeof html.nodeName===&quot;string&quot;
</PRE><P>) {
</P><PRE>         toast.appendChild(html);
       }
       else if (html instanceof jQuery) {
         // Check if it is jQuery object
         toast.appendChild(html[0]);
       }
       else {
         // Insert as text;
         toast.innerHTML = html; 
       }
       // Bind hammer
       var hammerHandler = new Hammer(toast, {prevent_default: false});
       hammerHandler.on('pan', function(e) {
         var deltaX = e.deltaX;
         var activationDistance = 80;
</PRE><PRE>         // Change toast state
         if (!toast.classList.contains('panning')){
           toast.classList.add('panning');
         }
</PRE><PRE>         var opacityPercent = 1-Math.abs(deltaX / activationDistance);
         if (opacityPercent &lt; 0)
           opacityPercent = 0;
</PRE><PRE>         Vel(toast, {left: deltaX, opacity: opacityPercent }, {duration: 50, queue: false, easing: 'easeOutQuad'});
</PRE><PRE>       });
</PRE><PRE>       hammerHandler.on('panend', function(e) {
         var deltaX = e.deltaX;
         var activationDistance = 80;
</PRE><PRE>         // If toast dragged past activation point
         if (Math.abs(deltaX) &gt; activationDistance) {
           Vel(toast, {marginTop: '-40px'}, { duration: 375,
               easing: 'easeOutExpo',
               queue: false,
               complete: function(){
                 if(typeof(completeCallback) === &quot;function&quot;) {
                   completeCallback();
                 }
                 toast.parentNode.removeChild(toast);
               }
           });
</PRE><PRE>         } else {
           toast.classList.remove('panning');
           // Put toast back into original position
           Vel(toast, { left: 0, opacity: 1 }, { duration: 300,
             easing: 'easeOutExpo',
             queue: false
           });
</PRE><PRE>         }
       });
</PRE><PRE>       return toast;
   }
</PRE><P>};
</P><DL><DT>(function ($) {</DT></DL><PRE> var methods = {
   init : function(options) {
     var defaults = {
       menuWidth: 300,
       edge: 'left',
       closeOnClick: false
     };
     options = $.extend(defaults, options);
</PRE><PRE>     $(this).each(function(){
       var $this = $(this);
       var menu_id = $(&quot;#&quot;+ $this.attr('data-activates'));
</PRE><PRE>       // Set to width
       if (options.menuWidth != 300) {
         menu_id.css('width', options.menuWidth);
       }
</PRE><PRE>       // Add Touch Area
</PRE>
        var dragTarget = $('');
<PRE>       $('body').append(dragTarget);
</PRE><PRE>       if (options.edge == 'left') {
         menu_id.css('transform', 'translateX(-100%)');
         dragTarget.css({'left': 0}); // Add Touch Area
       }
       else {
         menu_id.addClass('right-aligned') // Change text-alignment to right
           .css('transform', 'translateX(100%)');
         dragTarget.css({'right': 0}); // Add Touch Area
       }
</PRE><PRE>       // If fixed sidenav, bring menu out
       if (menu_id.hasClass('fixed')) {
           if (window.innerWidth &gt; 992) {
             menu_id.css('transform', 'translateX(0)');
           }
         }
</PRE><PRE>  // Window resize to reset on large screens fixed
       if (menu_id.hasClass('fixed')) {
         $(window).resize( function() {
           if (window.innerWidth &gt; 992) {
             // Close menu if window is resized bigger than 992 and user has fixed sidenav
             if ($('#sidenav-overlay').length !== 0 &amp;&amp; menuOut) {
               removeMenu(true);
             }
             else {
               // menu_id.removeAttr('style');
               menu_id.css('transform', 'translateX(0%)');
               // menu_id.css('width', options.menuWidth);
             }
           }
           else if (menuOut === false){
             if (options.edge === 'left') {
               menu_id.css('transform', 'translateX(-100%)');
             } else {
               menu_id.css('transform', 'translateX(100%)');
             }
</PRE><PRE>           }
</PRE><PRE>         });
       }
</PRE><PRE>       // if closeOnClick, then add close event for all a tags in side sideNav
       if (options.closeOnClick === true) {
         menu_id.on(&quot;click.itemclick&quot;, &quot;a:not(.collapsible-header)&quot;, function(){
           removeMenu();
         });
       }
</PRE><PRE>       function removeMenu(restoreNav) {
         panning = false;
         menuOut = false;
         // Reenable scrolling
         $('body').css({
           overflow: <I>,</I>
           width: 
         });
</PRE><PRE>         $('#sidenav-overlay').velocity({opacity: 0}, {duration: 200,
             queue: false, easing: 'easeOutQuad',
           complete: function() {
             $(this).remove();
           } });
         if (options.edge === 'left') {
           // Reset phantom div
           dragTarget.css({width: <I>, right: </I>, left: '0'});
           menu_id.velocity(
             {'translateX': '-100%'},
             { duration: 200,
               queue: false,
               easing: 'easeOutCubic',
               complete: function() {
                 if (restoreNav === true) {
                   // Restore Fixed sidenav
                   menu_id.removeAttr('style');
                   menu_id.css('width', options.menuWidth);
                 }
               }
</PRE><PRE>           });
         }
         else {
           // Reset phantom div
           dragTarget.css({width: <I>, right: '0', left: </I>});
           menu_id.velocity(
             {'translateX': '100%'},
             { duration: 200,
               queue: false,
               easing: 'easeOutCubic',
               complete: function() {
                 if (restoreNav === true) {
                   // Restore Fixed sidenav
                   menu_id.removeAttr('style');
                   menu_id.css('width', options.menuWidth);
                 }
               }
             });
         }
       }
</PRE><PRE>       // Touch Event
       var panning = false;
       var menuOut = false;
</PRE><PRE>       dragTarget.on('click', function(){
         if (menuOut) {
           removeMenu();
         }
       });
</PRE><PRE>       dragTarget.hammer({
         prevent_default: false
       }).bind('pan', function(e) {
</PRE><PRE>         if (e.gesture.pointerType == &quot;touch&quot;) {
</PRE><PRE>           var direction = e.gesture.direction;
           var x = e.gesture.center.x;
           var y = e.gesture.center.y;
           var velocityX = e.gesture.velocityX;
</PRE><PRE>           // Disable Scrolling
           var $body = $('body');
           var oldWidth = $body.innerWidth();
           $body.css('overflow', 'hidden');
           $body.width(oldWidth);
</PRE><PRE>           // If overlay does not exist, create one and if it is clicked, close menu
           if ($('#sidenav-overlay').length === 0) {
</PRE>
              var overlay = $('');
<PRE>             overlay.css('opacity', 0).click( function(){
               removeMenu();
             });
             $('body').append(overlay);
           }
</PRE><PRE>           // Keep within boundaries
           if (options.edge === 'left') {
             if (x &gt; options.menuWidth) { x = options.menuWidth; }
             else if (x &lt; 0) { x = 0; }
           }
</PRE><PRE>           if (options.edge === 'left') {
             // Left Direction
             if (x &lt; (options.menuWidth / 2)) { menuOut = false; }
             // Right Direction
             else if (x &gt;= (options.menuWidth / 2)) { menuOut = true; }
             menu_id.css('transform', 'translateX(' + (x - options.menuWidth) + 'px)');
           }
           else {
             // Left Direction
             if (x &lt; (window.innerWidth - options.menuWidth / 2)) {
               menuOut = true;
             }
             // Right Direction
             else if (x &gt;= (window.innerWidth - options.menuWidth / 2)) {
              menuOut = false;
            }
             var rightPos = (x - options.menuWidth / 2);
             if (rightPos &lt; 0) {
               rightPos = 0;
             }
</PRE><PRE>             menu_id.css('transform', 'translateX(' + rightPos + 'px)');
           }
</PRE><PRE>           // Percentage overlay
           var overlayPerc;
           if (options.edge === 'left') {
             overlayPerc = x / options.menuWidth;
             $('#sidenav-overlay').velocity({opacity: overlayPerc }, {duration: 10, queue: false, easing: 'easeOutQuad'});
           }
           else {
             overlayPerc = Math.abs((x - window.innerWidth) / options.menuWidth);
             $('#sidenav-overlay').velocity({opacity: overlayPerc }, {duration: 10, queue: false, easing: 'easeOutQuad'});
           }
         }
</PRE><PRE>       }).bind('panend', function(e) {
</PRE><PRE>         if (e.gesture.pointerType == &quot;touch&quot;) {
           var velocityX = e.gesture.velocityX;
           var x = e.gesture.center.x;
           var leftPos = x - options.menuWidth;
           var rightPos = x - options.menuWidth / 2;
           if (leftPos &gt; 0 ) {
             leftPos = 0;
           }
           if (rightPos &lt; 0) {
             rightPos = 0;
           }
           panning = false;
</PRE><PRE>           if (options.edge === 'left') {
             // If velocityX &lt;= 0.3 then the user is flinging the menu closed so ignore menuOut
             if ((menuOut &amp;&amp; velocityX &lt;= 0.3) || velocityX &lt; -0.5) {
               // Return menu to open
               if (leftPos !== 0) {
                 menu_id.velocity({'translateX': [0, leftPos]}, {duration: 300, queue: false, easing: 'easeOutQuad'});
               }
</PRE><PRE>               $('#sidenav-overlay').velocity({opacity: 1 }, {duration: 50, queue: false, easing: 'easeOutQuad'});
               dragTarget.css({width: '50%', right: 0, left: <I>});</I>
               menuOut = true;
             }
             else if (!menuOut || velocityX &gt; 0.3) {
               // Enable Scrolling
               $('body').css({
                 overflow: <I>,</I>
                 width: 
               });
               // Slide menu closed
               menu_id.velocity({'translateX': [-1 * options.menuWidth - 10, leftPos]}, {duration: 200, queue: false, easing: 'easeOutQuad'});
               $('#sidenav-overlay').velocity({opacity: 0 }, {duration: 200, queue: false, easing: 'easeOutQuad',
                 complete: function () {
                   $(this).remove();
                 }});
               dragTarget.css({width: '10px', right: <I>, left: 0});</I>
             }
           }
           else {
             if ((menuOut &amp;&amp; velocityX &gt;= -0.3) || velocityX &gt; 0.5) {
               // Return menu to open
               if (rightPos !== 0) {
                 menu_id.velocity({'translateX': [0, rightPos]}, {duration: 300, queue: false, easing: 'easeOutQuad'});
               }
</PRE><PRE>               $('#sidenav-overlay').velocity({opacity: 1 }, {duration: 50, queue: false, easing: 'easeOutQuad'});
               dragTarget.css({width: '50%', right: <I>, left: 0});</I>
               menuOut = true;
             }
             else if (!menuOut || velocityX &lt; -0.3) {
               // Enable Scrolling
               $('body').css({
                 overflow: <I>,</I>
                 width: 
               });
</PRE><PRE>               // Slide menu closed
               menu_id.velocity({'translateX': [options.menuWidth + 10, rightPos]}, {duration: 200, queue: false, easing: 'easeOutQuad'});
               $('#sidenav-overlay').velocity({opacity: 0 }, {duration: 200, queue: false, easing: 'easeOutQuad',
                 complete: function () {
                   $(this).remove();
                 }});
               dragTarget.css({width: '10px', right: 0, left: <I>});</I>
             }
           }
</PRE><PRE>         }
       });
</PRE><PRE>         $this.click(function() {
           if (menuOut === true) {
             menuOut = false;
             panning = false;
             removeMenu();
           }
           else {
</PRE><PRE>             // Disable Scrolling
             var $body = $('body');
             var oldWidth = $body.innerWidth();
             $body.css('overflow', 'hidden');
             $body.width(oldWidth);
</PRE><PRE>             // Push current drag target on top of DOM tree
             $('body').append(dragTarget);
</PRE><PRE>             if (options.edge === 'left') {
               dragTarget.css({width: '50%', right: 0, left: <I>});</I>
               menu_id.velocity({'translateX': [0, -1 * options.menuWidth]}, {duration: 300, queue: false, easing: 'easeOutQuad'});
             }
             else {
               dragTarget.css({width: '50%', right: <I>, left: 0});</I>
               menu_id.velocity({'translateX': [0, options.menuWidth]}, {duration: 300, queue: false, easing: 'easeOutQuad'});
             }
</PRE>
              var overlay = $('');
<PRE>             overlay.css('opacity', 0)
             .click(function(){
               menuOut = false;
               panning = false;
               removeMenu();
               overlay.velocity({opacity: 0}, {duration: 300, queue: false, easing: 'easeOutQuad',
                 complete: function() {
                   $(this).remove();
                 } });
</PRE><PRE>             });
             $('body').append(overlay);
             overlay.velocity({opacity: 1}, {duration: 300, queue: false, easing: 'easeOutQuad',
               complete: function () {
                 menuOut = true;
                 panning = false;
               }
             });
           }
</PRE><PRE>           return false;
         });
     });
</PRE><PRE>   },
   show : function() {
     this.trigger('click');
   },
   hide : function() {
     $('#sidenav-overlay').trigger('click');
   }
 };
</PRE><PRE>   $.fn.sideNav = function(methodOrOptions) {
     if ( methods[methodOrOptions] ) {
       return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
     } else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {
       // Default to &quot;init&quot;
       return methods.init.apply( this, arguments );
     } else {
       $.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.sideNav' );
     }
   }; // Plugin end
</PRE><P>}( jQuery ));
</P><DL><DT>/**</DT></DL><PRE>* Extend jquery with a scrollspy plugin.
* This watches the window scroll and fires events when elements are scrolled into viewport.
*
* throttle() and getTime() taken from Underscore.js
* <A rel="nofollow" class="external free" href="https://github.com/jashkenas/underscore">https://github.com/jashkenas/underscore</A>
*
* @author Copyright 2013 John Smart
* @license <A rel="nofollow" class="external free" href="https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE">https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE</A>
* @see <A rel="nofollow" class="external free" href="https://github.com/thesmart">https://github.com/thesmart</A>
* @version 0.1.2
*/
</PRE><P>(function($) {
</P><P>	var jWindow = $(window);
	var elements = [];
	var elementsInView = [];
	var isSpying = false;
	var ticks = 0;
	var unique_id = 1;
	var offset = {
		top : 0,
		right : 0,
		bottom : 0,
		left : 0,
	}
</P><P>	/**
	 * Find elements that are within the boundary
	 * @param {number} top
	 * @param {number} right
	 * @param {number} bottom
	 * @param {number} left
	 * @return {jQuery}		A collection of elements
	 */
	function findElements(top, right, bottom, left) {
		var hits = $();
		$.each(elements, function(i, element) {
			if (element.height() &gt; 0) {
				var elTop = element.offset().top,
					elLeft = element.offset().left,
					elRight = elLeft + element.width(),
					elBottom = elTop + element.height();
</P><P>				var isIntersect = !(elLeft &gt; right ||
					elRight &lt; left ||
					elTop &gt; bottom ||
					elBottom &lt; top);
</P><P>				if (isIntersect) {
					hits.push(element);
				}
			}
		});
</P><P>		return hits;
	}
</P><P>
	/**
	 * Called when the user scrolls the window
	 */
	function onScroll() {
		// unique tick id
		++ticks;
</P><P>		// viewport rectangle
		var top = jWindow.scrollTop(),
			left = jWindow.scrollLeft(),
			right = left + jWindow.width(),
			bottom = top + jWindow.height();
</P><P>		// determine which elements are in view
//        + 60 accounts for fixed nav
		var intersections = findElements(top+offset.top + 200, right+offset.right, bottom+offset.bottom, left+offset.left);
		$.each(intersections, function(i, element) {
</P><P>			var lastTick = element.data('scrollSpy:ticks');
			if (typeof lastTick != 'number') {
				// entered into view
				element.triggerHandler('scrollSpy:enter');
			}
</P><P>			// update tick id
			element.data('scrollSpy:ticks', ticks);
		});
</P><P>		// determine which elements are no longer in view
		$.each(elementsInView, function(i, element) {
			var lastTick = element.data('scrollSpy:ticks');
			if (typeof lastTick == 'number' &amp;&amp; lastTick !== ticks) {
				// exited from view
				element.triggerHandler('scrollSpy:exit');
				element.data('scrollSpy:ticks', null);
			}
		});
</P><P>		// remember elements in view for next tick
		elementsInView = intersections;
	}
</P><P>	/**
	 * Called when window is resized
	*/
	function onWinSize() {
		jWindow.trigger('scrollSpy:winSize');
	}
</P><P>	/**
	 * Get time in ms
</P><PRE>  * @license <A rel="nofollow" class="external free" href="https://raw.github.com/jashkenas/underscore/master/LICENSE">https://raw.github.com/jashkenas/underscore/master/LICENSE</A></PRE><P>	 * @type {function}
	 * @return {number}
	 */
	var getTime = (Date.now || function () {
		return new Date().getTime();
	});
</P><P>	/**
	 * Returns a function, that, when invoked, will only be triggered at most once
	 * during a given window of time. Normally, the throttled function will run
	 * as much as it can, without ever going more than once per `wait` duration;
	 * but if you'd like to disable the execution on the leading edge, pass
	 * `{leading: false}`. To disable execution on the trailing edge, ditto.
	 * @license <A rel="nofollow" class="external free" href="https://raw.github.com/jashkenas/underscore/master/LICENSE">https://raw.github.com/jashkenas/underscore/master/LICENSE</A>
	 * @param {function} func
	 * @param {number} wait
	 * @param {Object=} options
	 * @returns {Function}
	 */
	function throttle(func, wait, options) {
		var context, args, result;
		var timeout = null;
		var previous = 0;
		options || (options = {});
		var later = function () {
			previous = options.leading === false ? 0 : getTime();
			timeout = null;
			result = func.apply(context, args);
			context = args = null;
		};
		return function () {
			var now = getTime();
			if (!previous &amp;&amp; options.leading === false) previous = now;
			var remaining = wait - (now - previous);
			context = this;
			args = arguments;
			if (remaining &lt;= 0) {
				clearTimeout(timeout);
				timeout = null;
				previous = now;
				result = func.apply(context, args);
				context = args = null;
			} else if (!timeout &amp;&amp; options.trailing !== false) {
				timeout = setTimeout(later, remaining);
			}
			return result;
		};
	};
</P><P>	/**
	 * Enables ScrollSpy using a selector
	 * @param {jQuery|string} selector  The elements collection, or a selector
	 * @param {Object=} options	Optional.
</P><PRE>       throttle : number -&gt; scrollspy throttling. Default: 100 ms
       offsetTop : number -&gt; offset from top. Default: 0
       offsetRight : number -&gt; offset from right. Default: 0
       offsetBottom : number -&gt; offset from bottom. Default: 0
       offsetLeft : number -&gt; offset from left. Default: 0
</PRE><P>	 * @returns {jQuery}
	 */
	$.scrollSpy = function(selector, options) {
	  var defaults = {
			throttle: 100,
			scrollOffset: 200 // offset - 200 allows elements near bottom of page to scroll
</P><PRE>   };
   options = $.extend(defaults, options);
</PRE><P>		var visible = [];
		selector = $(selector);
		selector.each(function(i, element) {
			elements.push($(element));
			$(element).data(&quot;scrollSpy:id&quot;, i);
			// Smooth scroll to section
		  $('a[href=&quot;#' + $(element).attr('id') + '&quot;]').click(function(e) {
		    e.preventDefault();
		    var offset = $(this.hash).offset().top + 1;
	    	$('html, body').animate({ scrollTop: offset - options.scrollOffset }, {duration: 400, queue: false, easing: 'easeOutCubic'});
		  });
		});
</P><P>		offset.top = options.offsetTop || 0;
		offset.right = options.offsetRight || 0;
		offset.bottom = options.offsetBottom || 0;
		offset.left = options.offsetLeft || 0;
</P><P>		var throttledScroll = throttle(onScroll, options.throttle || 100);
		var readyScroll = function(){
			$(document).ready(throttledScroll);
		};
</P><P>		if (!isSpying) {
			jWindow.on('scroll', readyScroll);
			jWindow.on('resize', readyScroll);
			isSpying = true;
		}
</P><P>		// perform a scan once, after current execution context, and after dom is ready
		setTimeout(readyScroll, 0);
</P><P>
		selector.on('scrollSpy:enter', function() {
			visible = $.grep(visible, function(value) {
	      return value.height() != 0;
	    });
</P><P>			var $this = $(this);
</P><P>			if (visible[0]) {
				$('a[href=&quot;#' + visible[0].attr('id') + '&quot;]').removeClass('active');
				if ($this.data('scrollSpy:id') &lt; visible[0].data('scrollSpy:id')) {
					visible.unshift($(this));
				}
				else {
					visible.push($(this));
				}
			}
			else {
				visible.push($(this));
			}
</P><P>
			$('a[href=&quot;#' + visible[0].attr('id') + '&quot;]').addClass('active');
		});
		selector.on('scrollSpy:exit', function() {
			visible = $.grep(visible, function(value) {
	      return value.height() != 0;
	    });
</P><P>			if (visible[0]) {
				$('a[href=&quot;#' + visible[0].attr('id') + '&quot;]').removeClass('active');
				var $this = $(this);
				visible = $.grep(visible, function(value) {
	        return value.attr('id') != $this.attr('id');
	      });
	      if (visible[0]) { // Check if empty
					$('a[href=&quot;#' + visible[0].attr('id') + '&quot;]').addClass('active');
	      }
			}
		});
</P><P>		return selector;
	};
</P><P>	/**
	 * Listen for window resize events
	 * @param {Object=} options						Optional. Set { throttle: number } to change throttling. Default: 100 ms
	 * @returns {jQuery}		$(window)
	 */
	$.winSizeSpy = function(options) {
		$.winSizeSpy = function() { return jWindow; }; // lock from multiple calls
		options = options || {
			throttle: 100
		};
		return jWindow.on('resize', throttle(onWinSize, options.throttle || 100));
	};
</P><P>	/**
	 * Enables ScrollSpy on a collection of elements
	 * e.g. $('.scrollSpy').scrollSpy()
	 * @param {Object=} options	Optional.
											throttle : number -&gt; scrollspy throttling. Default: 100 ms
											offsetTop : number -&gt; offset from top. Default: 0
											offsetRight : number -&gt; offset from right. Default: 0
											offsetBottom : number -&gt; offset from bottom. Default: 0
											offsetLeft : number -&gt; offset from left. Default: 0
	 * @returns {jQuery}
	 */
	$.fn.scrollSpy = function(options) {
		return $.scrollSpy($(this), options);
	};
</P><P>})(jQuery);
</P><DL><DT>(function ($) {</DT></DL><PRE> $(document).ready(function() {
</PRE><PRE> // Function to update labels of text fields
   Materialize.updateTextFields = function() {
     var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea';
     $(input_selector).each(function(index, element) {
       if ($(element).val().length &gt; 0 || element.autofocus ||$(this).attr('placeholder') !== undefined || $(element)[0].validity.badInput === true) {
         $(this).siblings('label').addClass('active');
       }
       else {
         $(this).siblings('label').removeClass('active');
       }
     });
   };
</PRE><PRE>   // Text based inputs
   var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea';
</PRE><PRE>   // Add active if form auto complete
   $(document).on('change', input_selector, function () {
     if($(this).val().length !== 0 || $(this).attr('placeholder') !== undefined) {
       $(this).siblings('label').addClass('active');
     }
     validate_field($(this));
   });
</PRE><PRE>   // Add active if input element has been pre-populated on document ready
   $(document).ready(function() {
     Materialize.updateTextFields();
   });
</PRE><PRE>   // HTML DOM FORM RESET handling
   $(document).on('reset', function(e) {
     var formReset = $(e.target);
     if (formReset.is('form')) {
       formReset.find(input_selector).removeClass('valid').removeClass('invalid');
       formReset.find(input_selector).each(function () {
         if ($(this).attr('value') === <I>) {</I>
           $(this).siblings('label').removeClass('active');
         }
       });
</PRE><PRE>       // Reset select
       formReset.find('select.initialized').each(function () {
         var reset_text = formReset.find('option[selected]').text();
         formReset.siblings('input.select-dropdown').val(reset_text);
       });
     }
   });
</PRE><PRE>   // Add active when element has focus
   $(document).on('focus', input_selector, function () {
     $(this).siblings('label, .prefix').addClass('active');
   });
</PRE><PRE>   $(document).on('blur', input_selector, function () {
     var $inputElement = $(this);
     var selector = &quot;.prefix&quot;;
</PRE><PRE>     if ($inputElement.val().length === 0 &amp;&amp; $inputElement[0].validity.badInput !== true &amp;&amp; $inputElement.attr('placeholder') === undefined) {
       selector += &quot;, label&quot;;
     }
</PRE><PRE>     $inputElement.siblings(selector).removeClass('active');
</PRE><PRE>     validate_field($inputElement);
   });
</PRE><PRE>   window.validate_field = function(object) {
     var hasLength = object.attr('length') !== undefined;
     var lenAttr = parseInt(object.attr('length'));
     var len = object.val().length;
</PRE><PRE>     if (object.val().length === 0 &amp;&amp; object[0].validity.badInput === false) {
       if (object.hasClass('validate')) {
         object.removeClass('valid');
         object.removeClass('invalid');
       }
     }
     else {
       if (object.hasClass('validate')) {
         // Check for character counter attributes
         if ((object.is(':valid') &amp;&amp; hasLength &amp;&amp; (len &lt;= lenAttr)) || (object.is(':valid') &amp;&amp; !hasLength)) {
           object.removeClass('invalid');
           object.addClass('valid');
         }
         else {
           object.removeClass('valid');
           object.addClass('invalid');
         }
       }
     }
   };
</PRE><PRE>   // Radio and Checkbox focus class
   var radio_checkbox = 'input[type=radio], input[type=checkbox]';
   $(document).on('keyup.radio', radio_checkbox, function(e) {
     // TAB, check if tabbing to radio or checkbox.
     if (e.which === 9) {
       $(this).addClass('tabbed');
       var $this = $(this);
       $this.one('blur', function(e) {
</PRE><PRE>         $(this).removeClass('tabbed');
       });
       return;
     }
   });
</PRE><PRE>   // Textarea Auto Resize
   var hiddenDiv = $('.hiddendiv').first();
   if (!hiddenDiv.length) {
</PRE>
      hiddenDiv = $('');
<PRE>     $('body').append(hiddenDiv);
   }
   var text_area_selector = '.materialize-textarea';
</PRE><PRE>   function textareaAutoResize($textarea) {
     // Set font properties of hiddenDiv
</PRE><PRE>     var fontFamily = $textarea.css('font-family');
     var fontSize = $textarea.css('font-size');
     var lineHeight = $textarea.css('line-height');
</PRE><PRE>     if (fontSize) { hiddenDiv.css('font-size', fontSize); }
     if (fontFamily) { hiddenDiv.css('font-family', fontFamily); }
     if (lineHeight) { hiddenDiv.css('line-height', lineHeight); }
</PRE><PRE>     if ($textarea.attr('wrap') === &quot;off&quot;) {
       hiddenDiv.css('overflow-wrap', &quot;normal&quot;)
                .css('white-space', &quot;pre&quot;);
     }
</PRE><PRE>     hiddenDiv.text($textarea.val() + '\n');
     var content = hiddenDiv.html().replace(/\n/g, '');
     hiddenDiv.html(content);
</PRE><PRE>     // When textarea is hidden, width goes crazy.
     // Approximate with half of window size
</PRE><PRE>     if ($textarea.is(':visible')) {
       hiddenDiv.css('width', $textarea.width());
     }
     else {
       hiddenDiv.css('width', $(window).width()/2);
     }
</PRE><PRE>     $textarea.css('height', hiddenDiv.height());
   }
</PRE><PRE>   $(text_area_selector).each(function () {
     var $textarea = $(this);
     if ($textarea.val().length) {
       textareaAutoResize($textarea);
     }
   });
</PRE><PRE>   $('body').on('keyup keydown autoresize', text_area_selector, function () {
     textareaAutoResize($(this));
   });
</PRE><PRE>   // File Input Path
   $(document).on('change', '.file-field input[type=&quot;file&quot;]', function () {
     var file_field = $(this).closest('.file-field');
     var path_input = file_field.find('input.file-path');
     var files      = $(this)[0].files;
     var file_names = [];
     for (var i = 0; i &lt; files.length; i++) {
       file_names.push(files[i].name);
     }
     path_input.val(file_names.join(&quot;, &quot;));
     path_input.trigger('change');
   });
</PRE><PRE>   /****************
   *  Range Input  *
   ****************/
</PRE><PRE>   var range_type = 'input[type=range]';
   var range_mousedown = false;
   var left;
</PRE><PRE>   $(range_type).each(function () {
     var thumb = $('');
     $(this).after(thumb);
   });
</PRE><PRE>   var range_wrapper = '.range-field';
   $(document).on('change', range_type, function(e) {
     var thumb = $(this).siblings('.thumb');
     thumb.find('.value').html($(this).val());
   });
</PRE><PRE>   $(document).on('input mousedown touchstart', range_type, function(e) {
     var thumb = $(this).siblings('.thumb');
     var width = $(this).outerWidth();
</PRE><PRE>     // If thumb indicator does not exist yet, create it
     if (thumb.length &lt;= 0) {
       thumb = $('');
       $(this).after(thumb);
     }
</PRE><PRE>     // Set indicator value
     thumb.find('.value').html($(this).val());
</PRE><PRE>     range_mousedown = true;
     $(this).addClass('active');
</PRE><PRE>     if (!thumb.hasClass('active')) {
       thumb.velocity({ height: &quot;30px&quot;, width: &quot;30px&quot;, top: &quot;-20px&quot;, marginLeft: &quot;-15px&quot;}, { duration: 300, easing: 'easeOutExpo' });
     }
</PRE><PRE>     if (e.type !== 'input') {
       if(e.pageX === undefined || e.pageX === null){//mobile
          left = e.originalEvent.touches[0].pageX - $(this).offset().left;
       }
       else{ // desktop
          left = e.pageX - $(this).offset().left;
       }
       if (left &lt; 0) {
         left = 0;
       }
       else if (left &gt; width) {
         left = width;
       }
       thumb.addClass('active').css('left', left);
     }
</PRE><PRE>     thumb.find('.value').html($(this).val());
   });
</PRE><PRE>   $(document).on('mouseup touchend', range_wrapper, function() {
     range_mousedown = false;
     $(this).removeClass('active');
   });
</PRE><PRE>   $(document).on('mousemove touchmove', range_wrapper, function(e) {
     var thumb = $(this).children('.thumb');
     var left;
     if (range_mousedown) {
       if (!thumb.hasClass('active')) {
         thumb.velocity({ height: '30px', width: '30px', top: '-20px', marginLeft: '-15px'}, { duration: 300, easing: 'easeOutExpo' });
       }
       if (e.pageX === undefined || e.pageX === null) { //mobile
         left = e.originalEvent.touches[0].pageX - $(this).offset().left;
       }
       else{ // desktop
         left = e.pageX - $(this).offset().left;
       }
       var width = $(this).outerWidth();
</PRE><PRE>       if (left &lt; 0) {
         left = 0;
       }
       else if (left &gt; width) {
         left = width;
       }
       thumb.addClass('active').css('left', left);
       thumb.find('.value').html(thumb.siblings(range_type).val());
     }
   });
</PRE><PRE>   $(document).on('mouseout touchleave', range_wrapper, function() {
     if (!range_mousedown) {
</PRE><PRE>       var thumb = $(this).children('.thumb');
</PRE><PRE>       if (thumb.hasClass('active')) {
         thumb.velocity({ height: '0', width: '0', top: '10px', marginLeft: '-6px'}, { duration: 100 });
       }
       thumb.removeClass('active');
     }
   });
</PRE><PRE>   /**************************
    * Auto complete plugin  *
    *************************/
   $.fn.autocomplete = function (options) {
     // Defaults
     var defaults = {
       data: {}
     };
</PRE><PRE>     options = $.extend(defaults, options);
</PRE><PRE>     return this.each(function() {
       var $input = $(this);
       var data = options.data,
           $inputDiv = $input.closest('.input-field'); // Div to append on
</PRE><PRE>       // Check if data isn't empty
       if (!$.isEmptyObject(data)) {
         // Create autocomplete element
</PRE>
          var $autocomplete = $('');
<PRE>         // Append autocomplete element
         if ($inputDiv.length) {
           $inputDiv.append($autocomplete); // Set ul in body
         } else {
           $input.after($autocomplete);
         }
</PRE><PRE>         var highlight = function(string, $el) {
           var img = $el.find('img');
           var matchStart = $el.text().toLowerCase().indexOf(&quot;&quot; + string.toLowerCase() + &quot;&quot;),
               matchEnd = matchStart + string.length - 1,
               beforeMatch = $el.text().slice(0, matchStart),
               matchText = $el.text().slice(matchStart, matchEnd + 1),
               afterMatch = $el.text().slice(matchEnd + 1);
           $el.html(&quot;<SPAN>&quot; + beforeMatch + &quot;<SPAN class="highlight">&quot; + matchText + &quot;</SPAN>&quot; + afterMatch + &quot;</SPAN>&quot;);
           if (img.length) {
             $el.prepend(img);
           }
         };
</PRE><PRE>         // Perform search
         $input.on('keyup', function (e) {
           // Capture Enter
           if (e.which === 13) {
             $autocomplete.find('li').first().click();
             return;
           }
</PRE><PRE>           var val = $input.val().toLowerCase();
           $autocomplete.empty();
</PRE><PRE>           // Check if the input isn't empty
           if (val !== <I>) {</I>
             for(var key in data) {
               if (data.hasOwnProperty(key) &amp;&amp;
                   key.toLowerCase().indexOf(val) !== -1 &amp;&amp;
                   key.toLowerCase() !== val) {
</PRE>
                  var autocompleteOption = $('');
<PRE>                 if(!!data[key]) {
                   autocompleteOption.append('&lt;img src=&quot;'+ data[key] +'&quot; class=&quot;right circle&quot;&gt;<SPAN>'+ key +'</SPAN>');
                 } else {
                   autocompleteOption.append('<SPAN>'+ key +'</SPAN>');
                 }
                 $autocomplete.append(autocompleteOption);
</PRE><PRE>                 highlight(val, autocompleteOption);
               }
             }
           }
         });
</PRE><PRE>         // Set input value
         $autocomplete.on('click', 'li', function () {
           $input.val($(this).text().trim());
           $autocomplete.empty();
         });
       }
     });
   };
</PRE><PRE> }); // End of $(document).ready
</PRE><PRE> /*******************
  *  Select Plugin  *
  ******************/
 $.fn.material_select = function (callback) {
   $(this).each(function(){
     var $select = $(this);
</PRE><PRE>     if ($select.hasClass('browser-default')) {
       return; // Continue to next (return false breaks out of entire loop)
     }
</PRE><PRE>     var multiple = $select.attr('multiple') ? true : false,
         lastID = $select.data('select-id'); // Tear down structure if Select needs to be rebuilt
</PRE><PRE>     if (lastID) {
       $select.parent().find('span.caret').remove();
       $select.parent().find('input').remove();
</PRE><PRE>       $select.unwrap();
       $('ul#select-options-'+lastID).remove();
     }
</PRE><PRE>     // If destroying the select, remove the selelct-id and reset it to it's uninitialized state.
     if(callback === 'destroy') {
       $select.data('select-id', null).removeClass('initialized');
       return;
     }
</PRE><PRE>     var uniqueID = Materialize.guid();
     $select.data('select-id', uniqueID);
</PRE>
      var wrapper = $('');
<PRE>     wrapper.addClass($select.attr('class'));
</PRE>
      var options = $(''),
<PRE>         selectChildren = $select.children('option, optgroup'),
         valuesSelected = [],
         optionsHover = false;
</PRE><PRE>     var label = $select.find('option:selected').html() || $select.find('option:first').html() || &quot;&quot;;
</PRE><PRE>     // Function that renders and appends the option taking into
     // account type and possible image icon.
     var appendOptionWithIcon = function(select, option, type) {
       // Add disabled attr if disabled
       var disabledClass = (option.is(':disabled')) ? 'disabled ' : <I>;</I>
       var optgroupClass = (type === 'optgroup-option') ? 'optgroup-option ' : <I>;</I></PRE><PRE>       // add icons
       var icon_url = option.data('icon');
       var classes = option.attr('class');
       if (!!icon_url) {
         var classString = <I>;</I>
         if (!!classes) classString = ' class=&quot;' + classes + '&quot;';
</PRE><PRE>         // Check for multiple type.
         if (type === 'multiple') {
</PRE>
            options.append($('<LI class="' + disabledClass + '">&lt;img src=&quot;' + icon_url + '&quot;' + classString + '&gt;<SPAN>&lt;input type=&quot;checkbox&quot;' + disabledClass + '/&gt;&lt;label&gt;&lt;/label&gt;' + option.html() + '</SPAN></LI>'));
<PRE>         } else {
</PRE>
            options.append($('<LI class="' + disabledClass + optgroupClass + '">&lt;img src=&quot;' + icon_url + '&quot;' + classString + '&gt;<SPAN>' + option.html() + '</SPAN></LI>'));
<PRE>         }
         return true;
       }
</PRE><PRE>       // Check for multiple type.
       if (type === 'multiple') {
</PRE>
          options.append($('<LI class="' + disabledClass + '"><SPAN>&lt;input type=&quot;checkbox&quot;' + disabledClass + '/&gt;&lt;label&gt;&lt;/label&gt;' + option.html() + '</SPAN></LI>'));
<PRE>       } else {
</PRE>
          options.append($('<LI class="' + disabledClass + optgroupClass + '"><SPAN>' + option.html() + '</SPAN></LI>'));
<PRE>       }
     };
</PRE><PRE>     /* Create dropdown structure. */
     if (selectChildren.length) {
       selectChildren.each(function() {
         if ($(this).is('option')) {
           // Direct descendant option.
           if (multiple) {
             appendOptionWithIcon($select, $(this), 'multiple');
</PRE><PRE>           } else {
             appendOptionWithIcon($select, $(this));
           }
         } else if ($(this).is('optgroup')) {
           // Optgroup.
           var selectOptions = $(this).children('option');
</PRE>
            options.append($('<LI class="optgroup"><SPAN>' + $(this).attr('label') + '</SPAN></LI>'));
<PRE>           selectOptions.each(function() {
             appendOptionWithIcon($select, $(this), 'optgroup-option');
           });
         }
       });
     }
</PRE><PRE>     options.find('li:not(.optgroup)').each(function (i) {
       $(this).click(function (e) {
         // Check if option element is disabled
         if (!$(this).hasClass('disabled') &amp;&amp; !$(this).hasClass('optgroup')) {
           var selected = true;
</PRE><PRE>           if (multiple) {
             $('input[type=&quot;checkbox&quot;]', this).prop('checked', function(i, v) { return !v; });
             selected = toggleEntryFromArray(valuesSelected, $(this).index(), $select);
             $newSelect.trigger('focus');
           } else {
             options.find('li').removeClass('active');
             $(this).toggleClass('active');
             $newSelect.val($(this).text());
           }
</PRE><PRE>           activateOption(options, $(this));
           $select.find('option').eq(i).prop('selected', selected);
           // Trigger onchange() event
           $select.trigger('change');
           if (typeof callback !== 'undefined') callback();
         }
</PRE><PRE>         e.stopPropagation();
       });
     });
</PRE><PRE>     // Wrap Elements
     $select.wrap(wrapper);
     // Add Select Display Element
     var dropdownIcon = $('<SPAN class="caret">▼</SPAN>');
     if ($select.is(':disabled'))
       dropdownIcon.addClass('disabled');
</PRE><PRE>     // escape double quotes
     var sanitizedLabelHtml = label.replace(/&quot;/g, '&quot;');
</PRE><PRE>     var $newSelect = $('&lt;input type=&quot;text&quot; class=&quot;select-dropdown&quot; readonly=&quot;true&quot; ' + (($select.is(':disabled')) ? 'disabled' : <I>) + ' data-activates=&quot;select-options-' + uniqueID +'&quot; value=&quot;'+ sanitizedLabelHtml +'&quot;/&gt;');</I>
     $select.before($newSelect);
     $newSelect.before(dropdownIcon);
</PRE><PRE>     $newSelect.after(options);
     // Check if section element is disabled
     if (!$select.is(':disabled')) {
       $newSelect.dropdown({'hover': false, 'closeOnClick': false});
     }
</PRE><PRE>     // Copy tabindex
     if ($select.attr('tabindex')) {
       $($newSelect[0]).attr('tabindex', $select.attr('tabindex'));
     }
</PRE><PRE>     $select.addClass('initialized');
</PRE><PRE>     $newSelect.on({
       'focus': function (){
         if ($('ul.select-dropdown').not(options[0]).is(':visible')) {
           $('input.select-dropdown').trigger('close');
         }
         if (!options.is(':visible')) {
           $(this).trigger('open', ['focus']);
           var label = $(this).val();
           var selectedOption = options.find('li').filter(function() {
             return $(this).text().toLowerCase() === label.toLowerCase();
           })[0];
           activateOption(options, selectedOption);
         }
       },
       'click': function (e){
         e.stopPropagation();
       }
     });
</PRE><PRE>     $newSelect.on('blur', function() {
       if (!multiple) {
         $(this).trigger('close');
       }
       options.find('li.selected').removeClass('selected');
     });
</PRE><PRE>     options.hover(function() {
       optionsHover = true;
     }, function () {
       optionsHover = false;
     });
</PRE><PRE>     $(window).on({
       'click': function () {
         multiple &amp;&amp; (optionsHover || $newSelect.trigger('close'));
       }
     });
</PRE><PRE>     // Add initial multiple selections.
     if (multiple) {
       $select.find(&quot;option:selected:not(:disabled)&quot;).each(function () {
         var index = $(this).index();
</PRE><PRE>         toggleEntryFromArray(valuesSelected, index, $select);
         options.find(&quot;li&quot;).eq(index).find(&quot;:checkbox&quot;).prop(&quot;checked&quot;, true);
       });
     }
</PRE><PRE>     // Make option as selected and scroll to selected position
     var activateOption = function(collection, newOption) {
       if (newOption) {
         collection.find('li.selected').removeClass('selected');
         var option = $(newOption);
         option.addClass('selected');
         options.scrollTo(option);
       }
     };
</PRE><PRE>     // Allow user to search by typing
     // this array is cleared after 1 second
     var filterQuery = [],
         onKeyDown = function(e){
           // TAB - switch to another input
           if(e.which == 9){
             $newSelect.trigger('close');
             return;
           }
</PRE><PRE>           // ARROW DOWN WHEN SELECT IS CLOSED - open select options
           if(e.which == 40 &amp;&amp; !options.is(':visible')){
             $newSelect.trigger('open');
             return;
           }
</PRE><PRE>           // ENTER WHEN SELECT IS CLOSED - submit form
           if(e.which == 13 &amp;&amp; !options.is(':visible')){
             return;
           }
</PRE><PRE>           e.preventDefault();
</PRE><PRE>           // CASE WHEN USER TYPE LETTERS
           var letter = String.fromCharCode(e.which).toLowerCase(),
               nonLetters = [9,13,27,38,40];
           if (letter &amp;&amp; (nonLetters.indexOf(e.which) === -1)) {
             filterQuery.push(letter);
</PRE><PRE>             var string = filterQuery.join(<I>),</I>
                 newOption = options.find('li').filter(function() {
                   return $(this).text().toLowerCase().indexOf(string) === 0;
                 })[0];
</PRE><PRE>             if (newOption) {
               activateOption(options, newOption);
             }
           }
</PRE><PRE>           // ENTER - select option and close when select options are opened
           if (e.which == 13) {
             var activeOption = options.find('li.selected:not(.disabled)')[0];
             if(activeOption){
               $(activeOption).trigger('click');
               if (!multiple) {
                 $newSelect.trigger('close');
               }
             }
           }
</PRE><PRE>           // ARROW DOWN - move to next not disabled option
           if (e.which == 40) {
             if (options.find('li.selected').length) {
               newOption = options.find('li.selected').next('li:not(.disabled)')[0];
             } else {
               newOption = options.find('li:not(.disabled)')[0];
             }
             activateOption(options, newOption);
           }
</PRE><PRE>           // ESC - close options
           if (e.which == 27) {
             $newSelect.trigger('close');
           }
</PRE><PRE>           // ARROW UP - move to previous not disabled option
           if (e.which == 38) {
             newOption = options.find('li.selected').prev('li:not(.disabled)')[0];
             if(newOption)
               activateOption(options, newOption);
           }
</PRE><PRE>           // Automaticaly clean filter query so user can search again by starting letters
           setTimeout(function(){ filterQuery = []; }, 1000);
         };
</PRE><PRE>     $newSelect.on('keydown', onKeyDown);
   });
</PRE><PRE>   function toggleEntryFromArray(entriesArray, entryIndex, select) {
     var index = entriesArray.indexOf(entryIndex),
         notAdded = index === -1;
</PRE><PRE>     if (notAdded) {
       entriesArray.push(entryIndex);
     } else {
       entriesArray.splice(index, 1);
     }
</PRE><PRE>     select.siblings('ul.dropdown-content').find('li').eq(entryIndex).toggleClass('active');
</PRE><PRE>     // use notAdded instead of true (to detect if the option is selected or not)
     select.find('option').eq(entryIndex).prop('selected', notAdded);
     setValueToInput(entriesArray, select);
</PRE><PRE>     return notAdded;
   }
</PRE><PRE>   function setValueToInput(entriesArray, select) {
     var value = <I>;</I></PRE><PRE>     for (var i = 0, count = entriesArray.length; i &lt; count; i++) {
       var text = select.find('option').eq(entriesArray[i]).text();
</PRE><PRE>       i === 0 ? value += text : value += ', ' + text;
     }
</PRE><PRE>     if (value === <I>) {</I>
       value = select.find('option:disabled').eq(0).text();
     }
</PRE><PRE>     select.siblings('input.select-dropdown').val(value);
   }
 };
</PRE><P>}( jQuery ));
</P><DL><DT>(function ($) {</DT></DL><PRE> var methods = {
</PRE><PRE>   init : function(options) {
     var defaults = {
       indicators: true,
       height: 400,
       transition: 500,
       interval: 6000
     };
     options = $.extend(defaults, options);
</PRE><PRE>     return this.each(function() {
</PRE><PRE>       // For each slider, we want to keep track of
       // which slide is active and its associated content
       var $this = $(this);
       var $slider = $this.find('ul.slides').first();
       var $slides = $slider.find('&gt; li');
       var $active_index = $slider.find('.active').index();
       var $active, $indicators, $interval;
       if ($active_index != -1) { $active = $slides.eq($active_index); }
</PRE><PRE>       // Transitions the caption depending on alignment
       function captionTransition(caption, duration) {
         if (caption.hasClass(&quot;center-align&quot;)) {
           caption.velocity({opacity: 0, translateY: -100}, {duration: duration, queue: false});
         }
         else if (caption.hasClass(&quot;right-align&quot;)) {
           caption.velocity({opacity: 0, translateX: 100}, {duration: duration, queue: false});
         }
         else if (caption.hasClass(&quot;left-align&quot;)) {
           caption.velocity({opacity: 0, translateX: -100}, {duration: duration, queue: false});
         }
       }
</PRE><PRE>       // This function will transition the slide to any index of the next slide
       function moveToSlide(index) {
         // Wrap around indices.
         if (index &gt;= $slides.length) index = 0;
         else if (index &lt; 0) index = $slides.length -1;
</PRE><PRE>         $active_index = $slider.find('.active').index();
</PRE><PRE>         // Only do if index changes
         if ($active_index != index) {
           $active = $slides.eq($active_index);
           $caption = $active.find('.caption');
</PRE><PRE>           $active.removeClass('active');
           $active.velocity({opacity: 0}, {duration: options.transition, queue: false, easing: 'easeOutQuad',
                             complete: function() {
                               $slides.not('.active').velocity({opacity: 0, translateX: 0, translateY: 0}, {duration: 0, queue: false});
                             } });
           captionTransition($caption, options.transition);
</PRE><PRE>           // Update indicators
           if (options.indicators) {
             $indicators.eq($active_index).removeClass('active');
           }
</PRE><PRE>           $slides.eq(index).velocity({opacity: 1}, {duration: options.transition, queue: false, easing: 'easeOutQuad'});
           $slides.eq(index).find('.caption').velocity({opacity: 1, translateX: 0, translateY: 0}, {duration: options.transition, delay: options.transition, queue: false, easing: 'easeOutQuad'});
           $slides.eq(index).addClass('active');
</PRE><PRE>           // Update indicators
           if (options.indicators) {
             $indicators.eq(index).addClass('active');
           }
         }
       }
</PRE><PRE>       // Set height of slider
       // If fullscreen, do nothing
       if (!$this.hasClass('fullscreen')) {
         if (options.indicators) {
           // Add height if indicators are present
           $this.height(options.height + 40);
         }
         else {
           $this.height(options.height);
         }
         $slider.height(options.height);
       }
</PRE><PRE>       // Set initial positions of captions
       $slides.find('.caption').each(function () {
         captionTransition($(this), 0);
       });
</PRE><PRE>       // Move img src into background-image
       $slides.find('img').each(function () {
         var placeholderBase64 = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
         if ($(this).attr('src') !== placeholderBase64) {
           $(this).css('background-image', 'url(' + $(this).attr('src') + ')' );
           $(this).attr('src', placeholderBase64);
         }
       });
</PRE><PRE>       // dynamically add indicators
       if (options.indicators) {</PRE>
          $indicators = $('');
<PRE>         $slides.each(function( index ) {
</PRE>
            var $indicator = $('');
<PRE>           // Handle clicks on indicators
           $indicator.click(function () {
             var $parent = $slider.parent();
             var curr_index = $parent.find($(this)).index();
             moveToSlide(curr_index);
</PRE><PRE>             // reset interval
             clearInterval($interval);
             $interval = setInterval(
               function(){
                 $active_index = $slider.find('.active').index();
                 if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
                 else $active_index += 1;
</PRE><PRE>                 moveToSlide($active_index);
</PRE><PRE>               }, options.transition + options.interval
             );
           });
           $indicators.append($indicator);
         });
         $this.append($indicators);
         $indicators = $this.find('ul.indicators').find('li.indicator-item');
       }
</PRE><PRE>       if ($active) {
         $active.show();
       }
       else {
         $slides.first().addClass('active').velocity({opacity: 1}, {duration: options.transition, queue: false, easing: 'easeOutQuad'});
</PRE><PRE>         $active_index = 0;
         $active = $slides.eq($active_index);
</PRE><PRE>         // Update indicators
         if (options.indicators) {
           $indicators.eq($active_index).addClass('active');
         }
       }
</PRE><PRE>       // Adjust height to current slide
       $active.find('img').each(function() {
         $active.find('.caption').velocity({opacity: 1, translateX: 0, translateY: 0}, {duration: options.transition, queue: false, easing: 'easeOutQuad'});
       });
</PRE><PRE>       // auto scroll
       $interval = setInterval(
         function(){
           $active_index = $slider.find('.active').index();
           moveToSlide($active_index + 1);
</PRE><PRE>         }, options.transition + options.interval
       );
</PRE><PRE>       // HammerJS, Swipe navigation
</PRE><PRE>       // Touch Event
       var panning = false;
       var swipeLeft = false;
       var swipeRight = false;
</PRE><PRE>       $this.hammer({
           prevent_default: false
       }).bind('pan', function(e) {
         if (e.gesture.pointerType === &quot;touch&quot;) {
</PRE><PRE>           // reset interval
           clearInterval($interval);
</PRE><PRE>           var direction = e.gesture.direction;
           var x = e.gesture.deltaX;
           var velocityX = e.gesture.velocityX;
</PRE><PRE>           $curr_slide = $slider.find('.active');
           $curr_slide.velocity({ translateX: x
               }, {duration: 50, queue: false, easing: 'easeOutQuad'});
</PRE><PRE>           // Swipe Left
           if (direction === 4 &amp;&amp; (x &gt; ($this.innerWidth() / 2) || velocityX &lt; -0.65)) {
             swipeRight = true;
           }
           // Swipe Right
           else if (direction === 2 &amp;&amp; (x &lt; (-1 * $this.innerWidth() / 2) || velocityX &gt; 0.65)) {
             swipeLeft = true;
           }
</PRE><PRE>           // Make Slide Behind active slide visible
           var next_slide;
           if (swipeLeft) {
             next_slide = $curr_slide.next();
             if (next_slide.length === 0) {
               next_slide = $slides.first();
             }
             next_slide.velocity({ opacity: 1
                 }, {duration: 300, queue: false, easing: 'easeOutQuad'});
           }
           if (swipeRight) {
             next_slide = $curr_slide.prev();
             if (next_slide.length === 0) {
               next_slide = $slides.last();
             }
             next_slide.velocity({ opacity: 1
                 }, {duration: 300, queue: false, easing: 'easeOutQuad'});
           }
</PRE><PRE>         }
</PRE><PRE>       }).bind('panend', function(e) {
         if (e.gesture.pointerType === &quot;touch&quot;) {
</PRE><PRE>           $curr_slide = $slider.find('.active');
           panning = false;
           curr_index = $slider.find('.active').index();
</PRE><PRE>           if (!swipeRight &amp;&amp; !swipeLeft || $slides.length &lt;=1) {
             // Return to original spot
             $curr_slide.velocity({ translateX: 0
                 }, {duration: 300, queue: false, easing: 'easeOutQuad'});
           }
           else if (swipeLeft) {
             moveToSlide(curr_index + 1);
             $curr_slide.velocity({translateX: -1 * $this.innerWidth() }, {duration: 300, queue: false, easing: 'easeOutQuad',
                                   complete: function() {
                                     $curr_slide.velocity({opacity: 0, translateX: 0}, {duration: 0, queue: false});
                                   } });
           }
           else if (swipeRight) {
             moveToSlide(curr_index - 1);
             $curr_slide.velocity({translateX: $this.innerWidth() }, {duration: 300, queue: false, easing: 'easeOutQuad',
                                   complete: function() {
                                     $curr_slide.velocity({opacity: 0, translateX: 0}, {duration: 0, queue: false});
                                   } });
           }
           swipeLeft = false;
           swipeRight = false;
</PRE><PRE>           // Restart interval
           clearInterval($interval);
           $interval = setInterval(
             function(){
               $active_index = $slider.find('.active').index();
               if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
               else $active_index += 1;
</PRE><PRE>               moveToSlide($active_index);
</PRE><PRE>             }, options.transition + options.interval
           );
         }
       });
</PRE><PRE>       $this.on('sliderPause', function() {
         clearInterval($interval);
       });
</PRE><PRE>       $this.on('sliderStart', function() {
         clearInterval($interval);
         $interval = setInterval(
           function(){
             $active_index = $slider.find('.active').index();
             if ($slides.length == $active_index + 1) $active_index = 0; // loop to start
             else $active_index += 1;
</PRE><PRE>             moveToSlide($active_index);
</PRE><PRE>           }, options.transition + options.interval
         );
       });
</PRE><PRE>       $this.on('sliderNext', function() {
         $active_index = $slider.find('.active').index();
         moveToSlide($active_index + 1);
       });
</PRE><PRE>       $this.on('sliderPrev', function() {
         $active_index = $slider.find('.active').index();
         moveToSlide($active_index - 1);
       });
</PRE><PRE>     });
</PRE><PRE>   },
   pause : function() {
     $(this).trigger('sliderPause');
   },
   start : function() {
     $(this).trigger('sliderStart');
   },
   next : function() {
     $(this).trigger('sliderNext');
   },
   prev : function() {
     $(this).trigger('sliderPrev');
   }
 };
</PRE><PRE>   $.fn.slider = function(methodOrOptions) {
     if ( methods[methodOrOptions] ) {
       return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
     } else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {
       // Default to &quot;init&quot;
       return methods.init.apply( this, arguments );
     } else {
       $.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.tooltip' );
     }
   }; // Plugin end
</PRE><P>}( jQuery ));
</P><DL><DT>(function ($) {</DT></DL><PRE> $(document).ready(function() {
</PRE><PRE>   $(document).on('click.card', '.card', function (e) {
     if ($(this).find('&gt; .card-reveal').length) {
       if ($(e.target).is($('.card-reveal .card-title')) || $(e.target).is($('.card-reveal .card-title i'))) {
         // Make Reveal animate down and display none
         $(this).find('.card-reveal').velocity(
           {translateY: 0}, {
             duration: 225,
             queue: false,
             easing: 'easeInOutQuad',
             complete: function() { $(this).css({ display: 'none'}); }
           }
         );
       }
       else if ($(e.target).is($('.card .activator')) ||
                $(e.target).is($('.card .activator i')) ) {
         $(e.target).closest('.card').css('overflow', 'hidden');
         $(this).find('.card-reveal').css({ display: 'block'}).velocity(&quot;stop&quot;, false).velocity({translateY: '-100%'}, {duration: 300, queue: false, easing: 'easeInOutQuad'});
       }
     }
   });
</PRE><PRE> });
</PRE><P>}( jQuery ));;(function ($) {
</P><PRE> var chipsHandleEvents = false;
 var materialChipsDefaults = {
   data: [],
   placeholder: <I>,</I>
   secondaryPlaceholder: <I>,</I>
 };
</PRE><PRE> $(document).ready(function(){
   // Handle removal of static chips.
   $(document).on('click', '.chip .close', function(e){
     var $chips = $(this).closest('.chips');
     if ($chips.data('initialized')) {
       return;
     }
     $(this).closest('.chip').remove();
   });
 });
</PRE><PRE> $.fn.material_chip = function (options) {
   var self = this;
   this.$el = $(this);
   this.$document = $(document);
   this.SELS = {
     CHIPS: '.chips',
     CHIP: '.chip',
     INPUT: 'input',
     DELETE: '.material-icons',
     SELECTED_CHIP: '.selected',
   };
</PRE><PRE>   if ('data' === options) {
     return this.$el.data('chips');
   }
</PRE><PRE>   if ('options' === options) {
     return this.$el.data('options');
   }
</PRE><PRE>   this.$el.data('options', $.extend({}, materialChipsDefaults, options));
</PRE><PRE>   // Initialize
   this.init = function() {
     var i = 0;
     var chips;
     self.$el.each(function(){
       var $chips = $(this);
       if ($chips.data('initialized')) {
         // Prevent double initialization.
         return;
       }
       var options = $chips.data('options');
       if (!options.data || !options.data instanceof Array) {
         options.data = [];
       }
       $chips.data('chips', options.data);
       $chips.data('index', i);
       $chips.data('initialized', true);
</PRE><PRE>       if (!$chips.hasClass(self.SELS.CHIPS)) {
         $chips.addClass('chips');
       }
</PRE><PRE>       self.chips($chips);
       i++;
     });
   };
</PRE><PRE>   this.handleEvents = function(){
     var SELS = self.SELS;
</PRE><PRE>     self.$document.on('click', SELS.CHIPS, function(e){
       $(e.target).find(SELS.INPUT).focus();
     });
</PRE><PRE>     self.$document.on('click', SELS.CHIP, function(e){
       $(SELS.CHIP).removeClass('selected');
       $(this).toggleClass('selected');
     });
</PRE><PRE>     self.$document.on('keydown', function(e){
       if ($(e.target).is('input, textarea')) {
         return;
       }
</PRE><PRE>       // delete
       var $chip = self.$document.find(SELS.CHIP + SELS.SELECTED_CHIP);
       var $chips = $chip.closest(SELS.CHIPS);
       var length = $chip.siblings(SELS.CHIP).length;
       var index;
</PRE><PRE>       if (!$chip.length) {
         return;
       }
</PRE><PRE>       if (e.which === 8 || e.which === 46) {
         e.preventDefault();
         var chipsIndex = $chips.data('index');
</PRE><PRE>         index = $chip.index();
         self.deleteChip(chipsIndex, index, $chips);
</PRE><PRE>         var selectIndex = null;
         if ((index + 1) &lt; length) {
           selectIndex = index;
         } else if (index === length || (index + 1) === length) {
           selectIndex = length - 1;
         }
</PRE><PRE>         if (selectIndex &lt; 0) selectIndex = null;
</PRE><PRE>         if (null !== selectIndex) {
           self.selectChip(chipsIndex, selectIndex, $chips);
         }
         if (!length) $chips.find('input').focus();
</PRE><PRE>       // left
       } else if (e.which === 37) {
         index = $chip.index() - 1;
         if (index &lt; 0) {
           return;
         }
         $(SELS.CHIP).removeClass('selected');
         self.selectChip($chips.data('index'), index, $chips);
</PRE><PRE>       // right
       } else if (e.which === 39) {
         index = $chip.index() + 1;
         $(SELS.CHIP).removeClass('selected');
         if (index &gt; length) {
           $chips.find('input').focus();
           return;
         }
         self.selectChip($chips.data('index'), index, $chips);
       }
     });
</PRE><PRE>     self.$document.on('focusin', SELS.CHIPS + ' ' + SELS.INPUT, function(e){
       $(e.target).closest(SELS.CHIPS).addClass('focus');
       $(SELS.CHIP).removeClass('selected');
     });
</PRE><PRE>     self.$document.on('focusout', SELS.CHIPS + ' ' + SELS.INPUT, function(e){
       $(e.target).closest(SELS.CHIPS).removeClass('focus');
     });
</PRE><PRE>     self.$document.on('keydown', SELS.CHIPS + ' ' + SELS.INPUT, function(e){
       var $target = $(e.target);
       var $chips = $target.closest(SELS.CHIPS);
       var chipsIndex = $chips.data('index');
       var chipsLength = $chips.children(SELS.CHIP).length;
</PRE><PRE>       // enter
       if (13 === e.which) {
         e.preventDefault();
         self.addChip(chipsIndex, {tag: $target.val()}, $chips);
         $target.val(<I>);</I>
         return;
       }
</PRE><PRE>       // delete or left
        if ((8 === e.keyCode || 37 === e.keyCode) &amp;&amp;<I> === $target.val() &amp;&amp; chipsLength) {</I>
         self.selectChip(chipsIndex, chipsLength - 1, $chips);
         $target.blur();
         return;
       }
     });
</PRE><PRE>     self.$document.on('click', SELS.CHIPS + ' ' + SELS.DELETE, function(e) {
       var $target = $(e.target);
       var $chips = $target.closest(SELS.CHIPS);
       var $chip = $target.closest(SELS.CHIP);
       e.stopPropagation();
       self.deleteChip(
         $chips.data('index'),
         $chip.index(),
         $chips
       );
       $chips.find('input').focus();
     });
   };
</PRE><PRE>   this.chips = function($chips) {
     var html = <I>;</I>
     var options = $chips.data('options');
     $chips.data('chips').forEach(function(elem){
       html += self.renderChip(elem);
     });
     html += '&lt;input class=&quot;input&quot; placeholder=&quot;&quot;&gt;';
     $chips.html(html);
     self.setPlaceholder($chips);
   };
</PRE><PRE>   this.renderChip = function(elem) {
     if (!elem.tag) return;
</PRE>
      var html = '<DIV class="chip">' + elem.tag;
<PRE>     if (elem.image) {
       html += ' &lt;img src=&quot;' + elem.image + '&quot;&gt; ';
     }
     html += '&lt;i class=&quot;material-icons close&quot;&gt;close&lt;/i&gt;';
</PRE>
      html += '</DIV>';
<PRE>     return html;
   };
</PRE><PRE>   this.setPlaceholder = function($chips) {
     var options = $chips.data('options');
     if ($chips.data('chips').length &amp;&amp; options.placeholder) {
       $chips.find('input').prop('placeholder', options.placeholder);
     } else if (!$chips.data('chips').length &amp;&amp; options.secondaryPlaceholder) {
       $chips.find('input').prop('placeholder', options.secondaryPlaceholder);
     }
   };
</PRE><PRE>   this.isValid = function($chips, elem) {
     var chips = $chips.data('chips');
     var exists = false;
     for (var i=0; i &lt; chips.length; i++) {
       if (chips[i].tag === elem.tag) {
           exists = true;
           return;
       }
     }
     return <I> !== elem.tag &amp;&amp; !exists;</I>
   };
</PRE><PRE>   this.addChip = function(chipsIndex, elem, $chips) {
     if (!self.isValid($chips, elem)) {
       return;
     }
     var options = $chips.data('options');
     var chipHtml = self.renderChip(elem);
     $chips.data('chips').push(elem);
     $(chipHtml).insertBefore($chips.find('input'));
     $chips.trigger('chip.add', elem);
     self.setPlaceholder($chips);
   };
</PRE><PRE>   this.deleteChip = function(chipsIndex, chipIndex, $chips) {
     var chip = $chips.data('chips')[chipIndex];
     $chips.find('.chip').eq(chipIndex).remove();
     $chips.data('chips').splice(chipIndex, 1);
     $chips.trigger('chip.delete', chip);
     self.setPlaceholder($chips);
   };
</PRE><PRE>   this.selectChip = function(chipsIndex, chipIndex, $chips) {
     var $chip = $chips.find('.chip').eq(chipIndex);
     if ($chip &amp;&amp; false === $chip.hasClass('selected')) {
       $chip.addClass('selected');
       $chips.trigger('chip.select', $chips.data('chips')[chipIndex]);
     }
   };
</PRE><PRE>   this.getChipsElement = function(index, $chips) {
     return $chips.eq(index);
   };
</PRE><PRE>   // init
   this.init();
</PRE><PRE>   if (!chipsHandleEvents) {
     this.handleEvents();
     chipsHandleEvents = true;
   }
 };
</PRE><P>}( jQuery ));;(function ($) {
</P><PRE> $.fn.pushpin = function (options) {
   // Defaults
   var defaults = {
     top: 0,
     bottom: Infinity,
     offset: 0
   };
</PRE><PRE>   // Remove pushpin event and classes
   if (options === &quot;remove&quot;) {
     this.each(function () {
       if (id = $(this).data('pushpin-id')) {
         $(window).off('scroll.' + id);
         $(this).removeData('pushpin-id').removeClass('pin-top pinned pin-bottom').removeAttr('style');
       }
     });
     return false;
   }
</PRE><PRE>   options = $.extend(defaults, options);
</PRE><PRE>   $index = 0;
   return this.each(function() {
     var $uniqueId = Materialize.guid(),
         $this = $(this),
         $original_offset = $(this).offset().top;
</PRE><PRE>     function removePinClasses(object) {
       object.removeClass('pin-top');
       object.removeClass('pinned');
       object.removeClass('pin-bottom');
     }
</PRE><PRE>     function updateElements(objects, scrolled) {
       objects.each(function () {
         // Add position fixed (because its between top and bottom)
         if (options.top &lt;= scrolled &amp;&amp; options.bottom &gt;= scrolled &amp;&amp; !$(this).hasClass('pinned')) {
           removePinClasses($(this));
           $(this).css('top', options.offset);
           $(this).addClass('pinned');
         }
</PRE><PRE>         // Add pin-top (when scrolled position is above top)
         if (scrolled &lt; options.top &amp;&amp; !$(this).hasClass('pin-top')) {
           removePinClasses($(this));
           $(this).css('top', 0);
           $(this).addClass('pin-top');
         }
</PRE><PRE>         // Add pin-bottom (when scrolled position is below bottom)
         if (scrolled &gt; options.bottom &amp;&amp; !$(this).hasClass('pin-bottom')) {
           removePinClasses($(this));
           $(this).addClass('pin-bottom');
           $(this).css('top', options.bottom - $original_offset);
         }
       });
     }
</PRE><PRE>     $(this).data('pushpin-id', $uniqueId);
     updateElements($this, $(window).scrollTop());
     $(window).on('scroll.' + $uniqueId, function () {
       var $scrolled = $(window).scrollTop() + options.offset;
       updateElements($this, $scrolled);
     });
</PRE><PRE>   });
</PRE><PRE> };
</PRE><P>}( jQuery ));;(function ($) {
</P><PRE> $(document).ready(function() {
</PRE><PRE>   // jQuery reverse
   $.fn.reverse = [].reverse;
</PRE><PRE>   // Hover behaviour: make sure this doesn't work on .click-to-toggle FABs!
   $(document).on('mouseenter.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle)', function(e) {
     var $this = $(this);
     openFABMenu($this);
   });
   $(document).on('mouseleave.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle)', function(e) {
     var $this = $(this);
     closeFABMenu($this);
   });
</PRE><PRE>   // Toggle-on-click behaviour.
   $(document).on('click.fixedActionBtn', '.fixed-action-btn.click-to-toggle &gt; a', function(e) {
     var $this = $(this);
     var $menu = $this.parent();
     if ($menu.hasClass('active')) {
       closeFABMenu($menu);
     } else {
       openFABMenu($menu);
     }
   });
</PRE><PRE> });
</PRE><PRE> $.fn.extend({
   openFAB: function() {
     openFABMenu($(this));
   },
   closeFAB: function() {
     closeFABMenu($(this));
   }
 });
</PRE><PRE> var openFABMenu = function (btn) {
   $this = btn;
   if ($this.hasClass('active') === false) {
</PRE><PRE>     // Get direction option
     var horizontal = $this.hasClass('horizontal');
     var offsetY, offsetX;
</PRE><PRE>     if (horizontal === true) {
       offsetX = 40;
     } else {
       offsetY = 40;
     }
</PRE><PRE>     $this.addClass('active');
     $this.find('ul .btn-floating').velocity(
       { scaleY: &quot;.4&quot;, scaleX: &quot;.4&quot;, translateY: offsetY + 'px', translateX: offsetX + 'px'},
       { duration: 0 });
</PRE><PRE>     var time = 0;
     $this.find('ul .btn-floating').reverse().each( function () {
       $(this).velocity(
         { opacity: &quot;1&quot;, scaleX: &quot;1&quot;, scaleY: &quot;1&quot;, translateY: &quot;0&quot;, translateX: '0'},
         { duration: 80, delay: time });
       time += 40;
     });
   }
 };
</PRE><PRE> var closeFABMenu = function (btn) {
   $this = btn;
   // Get direction option
   var horizontal = $this.hasClass('horizontal');
   var offsetY, offsetX;
</PRE><PRE>   if (horizontal === true) {
     offsetX = 40;
   } else {
     offsetY = 40;
   }
</PRE><PRE>   $this.removeClass('active');
   var time = 0;
   $this.find('ul .btn-floating').velocity(&quot;stop&quot;, true);
   $this.find('ul .btn-floating').velocity(
     { opacity: &quot;0&quot;, scaleX: &quot;.4&quot;, scaleY: &quot;.4&quot;, translateY: offsetY + 'px', translateX: offsetX + 'px'},
     { duration: 80 }
   );
 };
</PRE><P>
}( jQuery ));
</P><DL><DT>(function ($) {</DT></DL><PRE> // Image transition function
 Materialize.fadeInImage =  function(selectorOrEl) {
   var element;
   if (typeof(selectorOrEl) === 'string') {
     element = $(selectorOrEl);
   } else if (typeof(selectorOrEl) === 'object') {
     element = selectorOrEl;
   } else {
     return;
   }
   element.css({opacity: 0});
   $(element).velocity({opacity: 1}, {
       duration: 650,
       queue: false,
       easing: 'easeOutSine'
     });
   $(element).velocity({opacity: 1}, {
         duration: 1300,
         queue: false,
         easing: 'swing',
         step: function(now, fx) {
             fx.start = 100;
             var grayscale_setting = now/100;
             var brightness_setting = 150 - (100 - now)/1.75;
</PRE><PRE>             if (brightness_setting &lt; 100) {
               brightness_setting = 100;
             }
             if (now &gt;= 0) {
               $(this).css({
                   &quot;-webkit-filter&quot;: &quot;grayscale(&quot;+grayscale_setting+&quot;)&quot; + &quot;brightness(&quot;+brightness_setting+&quot;%)&quot;,
                   &quot;filter&quot;: &quot;grayscale(&quot;+grayscale_setting+&quot;)&quot; + &quot;brightness(&quot;+brightness_setting+&quot;%)&quot;
               });
             }
         }
     });
 };
</PRE><PRE> // Horizontal staggered list
 Materialize.showStaggeredList = function(selectorOrEl) {
   var element;
   if (typeof(selectorOrEl) === 'string') {
     element = $(selectorOrEl);
   } else if (typeof(selectorOrEl) === 'object') {
     element = selectorOrEl;
   } else {
     return;
   }
   var time = 0;
   element.find('li').velocity(
       { translateX: &quot;-100px&quot;},
       { duration: 0 });
</PRE><PRE>   element.find('li').each(function() {
     $(this).velocity(
       { opacity: &quot;1&quot;, translateX: &quot;0&quot;},
       { duration: 800, delay: time, easing: [60, 10] });
     time += 120;
   });
 };
</PRE><PRE> $(document).ready(function() {
   // Hardcoded .staggered-list scrollFire
   // var staggeredListOptions = [];
   // $('ul.staggered-list').each(function (i) {
</PRE><PRE>   //   var label = 'scrollFire-' + i;
   //   $(this).addClass(label);
   //   staggeredListOptions.push(
   //     {selector: 'ul.staggered-list.' + label,
   //      offset: 200,
   //      callback: 'showStaggeredList(&quot;ul.staggered-list.' + label + '&quot;)'});
   // });
   // scrollFire(staggeredListOptions);
</PRE><PRE>   // HammerJS, Swipe navigation
</PRE><PRE>   // Touch Event
   var swipeLeft = false;
   var swipeRight = false;
</PRE><PRE>   // Dismissible Collections
   $('.dismissable').each(function() {
     $(this).hammer({
       prevent_default: false
     }).bind('pan', function(e) {
       if (e.gesture.pointerType === &quot;touch&quot;) {
         var $this = $(this);
         var direction = e.gesture.direction;
         var x = e.gesture.deltaX;
         var velocityX = e.gesture.velocityX;
</PRE><PRE>         $this.velocity({ translateX: x
             }, {duration: 50, queue: false, easing: 'easeOutQuad'});
</PRE><PRE>         // Swipe Left
         if (direction === 4&amp;&amp; (x &gt; ($this.innerWidth() / 2) || velocityX &lt; -0.75)) {
           swipeLeft = true;
         }
</PRE><PRE>         // Swipe Right
         if (direction === 2 &amp;&amp; (x &lt; (-1 * $this.innerWidth() / 2) || velocityX &gt; 0.75)) {
           swipeRight = true;
         }
       }
     }).bind('panend', function(e) {
       // Reset if collection is moved back into original position
       if (Math.abs(e.gesture.deltaX) &lt; ($(this).innerWidth() / 2)) {
         swipeRight = false;
         swipeLeft = false;
       }
</PRE><PRE>       if (e.gesture.pointerType === &quot;touch&quot;) {
         var $this = $(this);
         if (swipeLeft || swipeRight) {
           var fullWidth;
           if (swipeLeft) { fullWidth = $this.innerWidth(); }
           else { fullWidth = -1 * $this.innerWidth(); }
</PRE><PRE>           $this.velocity({ translateX: fullWidth,
             }, {duration: 100, queue: false, easing: 'easeOutQuad', complete:
             function() {
               $this.css('border', 'none');
               $this.velocity({ height: 0, padding: 0,
                 }, {duration: 200, queue: false, easing: 'easeOutQuad', complete:
                   function() { $this.remove(); }
                 });
             }
           });
         }
         else {
           $this.velocity({ translateX: 0,
             }, {duration: 100, queue: false, easing: 'easeOutQuad'});
         }
         swipeLeft = false;
         swipeRight = false;
       }
     });
</PRE><PRE>   });
</PRE><PRE>   // time = 0
   // // Vertical Staggered list
   // $('ul.staggered-list.vertical li').velocity(
   //     { translateY: &quot;100px&quot;},
   //     { duration: 0 });
</PRE><PRE>   // $('ul.staggered-list.vertical li').each(function() {
   //   $(this).velocity(
   //     { opacity: &quot;1&quot;, translateY: &quot;0&quot;},
   //     { duration: 800, delay: time, easing: [60, 25] });
   //   time += 120;
   // });
</PRE><PRE>   // // Fade in and Scale
   // $('.fade-in.scale').velocity(
   //     { scaleX: .4, scaleY: .4, translateX: -600},
   //     { duration: 0});
   // $('.fade-in').each(function() {
   //   $(this).velocity(
   //     { opacity: &quot;1&quot;, scaleX: 1, scaleY: 1, translateX: 0},
   //     { duration: 800, easing: [60, 10] });
   // });
 });
</PRE><P>}( jQuery ));
</P><DL><DT>(function($) {</DT></DL><PRE> // Input: Array of JSON objects {selector, offset, callback}
</PRE><PRE> Materialize.scrollFire = function(options) {
</PRE><PRE>   var didScroll = false;
</PRE><PRE>   window.addEventListener(&quot;scroll&quot;, function() {
     didScroll = true;
   });
</PRE><PRE>   // Rate limit to 100ms
   setInterval(function() {
     if(didScroll) {
         didScroll = false;
</PRE><PRE>         var windowScroll = window.pageYOffset + window.innerHeight;
</PRE><PRE>         for (var i = 0 ; i &lt; options.length; i++) {
           // Get options from each line
           var value = options[i];
           var selector = value.selector,
               offset = value.offset,
               callback = value.callback;
</PRE><PRE>           var currentElement = document.querySelector(selector);
           if ( currentElement !== null) {
             var elementOffset = currentElement.getBoundingClientRect().top + window.pageYOffset;
</PRE><PRE>             if (windowScroll &gt; (elementOffset + offset)) {
               if (value.done !== true) {
                 if (typeof(callback) === 'function') {
                   callback.call(this, currentElement);
                 } else if (typeof(callback) === 'string') {
                   var callbackFunc = new Function(callback);
                   callbackFunc(currentElement);
                 }
                 value.done = true;
               }
             }
           }
         }
     }
   }, 100);
 };
</PRE><P>})(jQuery);
</P><DL><DT>/*!</DT></DL><PRE>* pickadate.js v3.5.0, 2014/04/13
* By Amsul, <A rel="nofollow" class="external free" href="http://amsul.ca">http://amsul.ca</A>
* Hosted on <A rel="nofollow" class="external free" href="http://amsul.github.io/pickadate.js">http://amsul.github.io/pickadate.js</A>
* Licensed under MIT
*/
</PRE><P>(function ( factory ) {
</P><PRE>   // AMD.
   if ( typeof define == 'function' &amp;&amp; define.amd )
       define( 'picker', ['jquery'], factory )
</PRE><PRE>   // Node.js/browserify.
   else if ( typeof exports == 'object' )
       module.exports = factory( require('jquery') )
</PRE><PRE>   // Browser globals.
   else this.Picker = factory( jQuery )
</PRE><P>}(function( $ ) {
</P><P>var $window = $( window )
var $document = $( document )
var $html = $( document.documentElement )
</P><P>
/**
</P><PRE>* The picker constructor that creates a blank picker.
*/
</PRE><P>function PickerConstructor( ELEMENT, NAME, COMPONENT, OPTIONS ) {
</P><PRE>   // If there’s no element, return the picker constructor.
   if ( !ELEMENT ) return PickerConstructor
</PRE><PRE>   var
       IS_DEFAULT_THEME = false,
</PRE><PRE>       // The state of the picker.
       STATE = {
           id: ELEMENT.id || 'P' + Math.abs( ~~(Math.random() * new Date()) )
       },
</PRE><PRE>       // Merge the defaults and options passed.
       SETTINGS = COMPONENT ? $.extend( true, {}, COMPONENT.defaults, OPTIONS ) : OPTIONS || {},
</PRE><PRE>       // Merge the default classes with the settings classes.
       CLASSES = $.extend( {}, PickerConstructor.klasses(), SETTINGS.klass ),
</PRE><PRE>       // The element node wrapper into a jQuery object.
       $ELEMENT = $( ELEMENT ),
</PRE><PRE>       // Pseudo picker constructor.
       PickerInstance = function() {
           return this.start()
       },
</PRE><PRE>       // The picker prototype.
       P = PickerInstance.prototype = {
</PRE><PRE>           constructor: PickerInstance,
</PRE><PRE>           $node: $ELEMENT,
</PRE><PRE>           /**
            * Initialize everything
            */
           start: function() {
</PRE><PRE>  // If it’s already started, do nothing.
               if ( STATE &amp;&amp; STATE.start ) return P
</PRE><PRE>               // Update the picker states.
               STATE.methods = {}
               STATE.start = true
               STATE.open = false
               STATE.type = ELEMENT.type
</PRE><PRE>               // Confirm focus state, convert into text input to remove UA stylings,
               // and set as readonly to prevent keyboard popup.
               ELEMENT.autofocus = ELEMENT == getActiveElement()
               ELEMENT.readOnly = !SETTINGS.editable
               ELEMENT.id = ELEMENT.id || STATE.id
               if ( ELEMENT.type != 'text' ) {
                   ELEMENT.type = 'text'
               }
</PRE><PRE>               // Create a new picker component with the settings.
               P.component = new COMPONENT(P, SETTINGS)
</PRE><PRE>               // Create the picker root with a holder and then prepare it.
               P.$root = $( PickerConstructor._.node('div', createWrappedComponent(), CLASSES.picker, 'id=&quot;' + ELEMENT.id + '_root&quot; tabindex=&quot;0&quot;') )
               prepareElementRoot()
</PRE><PRE>               // If there’s a format for the hidden input element, create the element.
               if ( SETTINGS.formatSubmit ) {
                   prepareElementHidden()
               }
</PRE><PRE>               // Prepare the input element.
               prepareElement()
</PRE><PRE>               // Insert the root as specified in the settings.
               if ( SETTINGS.container ) $( SETTINGS.container ).append( P.$root )
               else $ELEMENT.after( P.$root )
</PRE><PRE>               // Bind the default component and settings events.
               P.on({
                   start: P.component.onStart,
                   render: P.component.onRender,
                   stop: P.component.onStop,
                   open: P.component.onOpen,
                   close: P.component.onClose,
                   set: P.component.onSet
               }).on({
                   start: SETTINGS.onStart,
                   render: SETTINGS.onRender,
                   stop: SETTINGS.onStop,
                   open: SETTINGS.onOpen,
                   close: SETTINGS.onClose,
                   set: SETTINGS.onSet
               })
</PRE><PRE>               // Once we’re all set, check the theme in use.
               IS_DEFAULT_THEME = isUsingDefaultTheme( P.$root.children()[ 0 ] )
</PRE><PRE>               // If the element has autofocus, open the picker.
               if ( ELEMENT.autofocus ) {
                   P.open()
               }
</PRE><PRE>               // Trigger queued the “start” and “render” events.
               return P.trigger( 'start' ).trigger( 'render' )
           }, //start
</PRE><PRE>           /**
            * Render a new picker
            */
           render: function( entireComponent ) {
</PRE><PRE>               // Insert a new component holder in the root or box.
               if ( entireComponent ) P.$root.html( createWrappedComponent() )
               else P.$root.find( '.' + CLASSES.box ).html( P.component.nodes( STATE.open ) )
</PRE><PRE>               // Trigger the queued “render” events.
               return P.trigger( 'render' )
           }, //render
</PRE><PRE>           /**
            * Destroy everything
            */
           stop: function() {
</PRE><PRE>               // If it’s already stopped, do nothing.
               if ( !STATE.start ) return P
</PRE><PRE>               // Then close the picker.
               P.close()
</PRE><PRE>               // Remove the hidden field.
               if ( P._hidden ) {
                   P._hidden.parentNode.removeChild( P._hidden )
               }
</PRE><PRE>               // Remove the root.
               P.$root.remove()
</PRE><PRE>               // Remove the input class, remove the stored data, and unbind
               // the events (after a tick for IE - see `P.close`).
               $ELEMENT.removeClass( CLASSES.input ).removeData( NAME )
               setTimeout( function() {
                   $ELEMENT.off( '.' + STATE.id )
               }, 0)
</PRE><PRE>               // Restore the element state
               ELEMENT.type = STATE.type
               ELEMENT.readOnly = false
</PRE><PRE>               // Trigger the queued “stop” events.
               P.trigger( 'stop' )
</PRE><PRE>               // Reset the picker states.
               STATE.methods = {}
               STATE.start = false
</PRE><PRE>               return P
           }, //stop
</PRE><PRE>           /**
            * Open up the picker
            */
           open: function( dontGiveFocus ) {
</PRE><PRE>               // If it’s already open, do nothing.
               if ( STATE.open ) return P
</PRE><PRE>               // Add the “active” class.
               $ELEMENT.addClass( CLASSES.active )
               aria( ELEMENT, 'expanded', true )
</PRE><PRE>               // * A Firefox bug, when `html` has `overflow:hidden`, results in
               //   killing transitions :(. So add the “opened” state on the next tick.
               //   Bug: <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=625289">https://bugzilla.mozilla.org/show_bug.cgi?id=625289</A>
               setTimeout( function() {
</PRE><PRE>                   // Add the “opened” class to the picker root.
                   P.$root.addClass( CLASSES.opened )
                   aria( P.$root[0], 'hidden', false )
</PRE><PRE>               }, 0 )
</PRE><PRE>               // If we have to give focus, bind the element and doc events.
               if ( dontGiveFocus !== false ) {
</PRE><PRE>                   // Set it as open.
                   STATE.open = true
</PRE><PRE>                   // Prevent the page from scrolling.
                   if ( IS_DEFAULT_THEME ) {
                       $html.
                           css( 'overflow', 'hidden' ).
                           css( 'padding-right', '+=' + getScrollbarWidth() )
                   }
</PRE><PRE>                   // Pass focus to the root element’s jQuery object.
                   // * Workaround for iOS8 to bring the picker’s root into view.
                   P.$root.eq(0).focus()
</PRE><PRE>                   // Bind the document events.
                   $document.on( 'click.' + STATE.id + ' focusin.' + STATE.id, function( event ) {
</PRE><PRE>                       var target = event.target
</PRE><PRE>                       // If the target of the event is not the element, close the picker picker.
                       // * Don’t worry about clicks or focusins on the root because those don’t bubble up.
                       //   Also, for Firefox, a click on an `option` element bubbles up directly
                       //   to the doc. So make sure the target wasn't the doc.
                       // * In Firefox stopPropagation() doesn’t prevent right-click events from bubbling,
                       //   which causes the picker to unexpectedly close when right-clicking it. So make
                       //   sure the event wasn’t a right-click.
                       if ( target != ELEMENT &amp;&amp; target != document &amp;&amp; event.which != 3 ) {
</PRE><PRE>                           // If the target was the holder that covers the screen,
                           // keep the element focused to maintain tabindex.
                           P.close( target === P.$root.children()[0] )
                       }
</PRE><PRE>                   }).on( 'keydown.' + STATE.id, function( event ) {
</PRE><PRE>                       var
                           // Get the keycode.
                           keycode = event.keyCode,
</PRE><PRE>                           // Translate that to a selection change.
                           keycodeToMove = P.component.key[ keycode ],
</PRE><PRE>                           // Grab the target.
                           target = event.target
</PRE><PRE>                       // On escape, close the picker and give focus.
                       if ( keycode == 27 ) {
                           P.close( true )
                       }
</PRE><PRE>                       // Check if there is a key movement or “enter” keypress on the element.
                       else if ( target == P.$root[0] &amp;&amp; ( keycodeToMove || keycode == 13 ) ) {
</PRE><PRE>                           // Prevent the default action to stop page movement.
                           event.preventDefault()
</PRE><PRE>                           // Trigger the key movement action.
                           if ( keycodeToMove ) {
                               PickerConstructor._.trigger( P.component.key.go, P, [ PickerConstructor._.trigger( keycodeToMove ) ] )
                           }
</PRE><PRE>                           // On “enter”, if the highlighted item isn’t disabled, set the value and close.
                           else if ( !P.$root.find( '.' + CLASSES.highlighted ).hasClass( CLASSES.disabled ) ) {
                               P.set( 'select', P.component.item.highlight ).close()
                           }
                       }
</PRE><PRE>                       // If the target is within the root and “enter” is pressed,
                       // prevent the default action and trigger a click on the target instead.
                       else if ( $.contains( P.$root[0], target ) &amp;&amp; keycode == 13 ) {
                           event.preventDefault()
                           target.click()
                       }
                   })
               }
</PRE><PRE>               // Trigger the queued “open” events.
               return P.trigger( 'open' )
           }, //open
</PRE><PRE>           /**
            * Close the picker
            */
           close: function( giveFocus ) {
</PRE><PRE>               // If we need to give focus, do it before changing states.
               if ( giveFocus ) {
                   // ....ah yes! It would’ve been incomplete without a crazy workaround for IE :|
                   // The focus is triggered *after* the close has completed - causing it
                   // to open again. So unbind and rebind the event at the next tick.
                   P.$root.off( 'focus.toOpen' ).eq(0).focus()
                   setTimeout( function() {
                       P.$root.on( 'focus.toOpen', handleFocusToOpenEvent )
                   }, 0 )
               }
</PRE><PRE>               // Remove the “active” class.
               $ELEMENT.removeClass( CLASSES.active )
               aria( ELEMENT, 'expanded', false )
</PRE><PRE>               // * A Firefox bug, when `html` has `overflow:hidden`, results in
               //   killing transitions :(. So remove the “opened” state on the next tick.
               //   Bug: <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=625289">https://bugzilla.mozilla.org/show_bug.cgi?id=625289</A>
               setTimeout( function() {
</PRE><PRE>                   // Remove the “opened” and “focused” class from the picker root.
                   P.$root.removeClass( CLASSES.opened + ' ' + CLASSES.focused )
                   aria( P.$root[0], 'hidden', true )
</PRE><PRE>               }, 0 )
</PRE><PRE>               // If it’s already closed, do nothing more.
               if ( !STATE.open ) return P
</PRE><PRE>               // Set it as closed.
               STATE.open = false
</PRE><PRE>               // Allow the page to scroll.
               if ( IS_DEFAULT_THEME ) {
                   $html.
                       css( 'overflow', <I> ).</I>
                       css( 'padding-right', '-=' + getScrollbarWidth() )
               }
</PRE><PRE>               // Unbind the document events.
               $document.off( '.' + STATE.id )
</PRE><PRE>               // Trigger the queued “close” events.
               return P.trigger( 'close' )
           }, //close
</PRE><PRE>           /**
            * Clear the values
            */
           clear: function( options ) {
               return P.set( 'clear', null, options )
           }, //clear
</PRE><PRE>           /**
            * Set something
            */
           set: function( thing, value, options ) {
</PRE><PRE>               var thingItem, thingValue,
                   thingIsObject = $.isPlainObject( thing ),
                   thingObject = thingIsObject ? thing : {}
</PRE><PRE>               // Make sure we have usable options.
               options = thingIsObject &amp;&amp; $.isPlainObject( value ) ? value : options || {}
</PRE><PRE>               if ( thing ) {
</PRE><PRE>                   // If the thing isn’t an object, make it one.
                   if ( !thingIsObject ) {
                       thingObject[ thing ] = value
                   }
</PRE><PRE>                   // Go through the things of items to set.
                   for ( thingItem in thingObject ) {
</PRE><PRE>                       // Grab the value of the thing.
                       thingValue = thingObject[ thingItem ]
</PRE><PRE>                       // First, if the item exists and there’s a value, set it.
                       if ( thingItem in P.component.item ) {
                           if ( thingValue === undefined ) thingValue = null
                           P.component.set( thingItem, thingValue, options )
                       }
</PRE><PRE>                       // Then, check to update the element value and broadcast a change.
                       if ( thingItem == 'select' || thingItem == 'clear' ) {
                           $ELEMENT.
                               val( thingItem == 'clear' ? <I> : P.get( thingItem, SETTINGS.format ) ).</I>              trigger( 'change' )
                       }
                   }
</PRE><PRE>                   // Render a new picker.
                   P.render()
               }
</PRE><PRE>               // When the method isn’t muted, trigger queued “set” events and pass the `thingObject`.
               return options.muted ? P : P.trigger( 'set', thingObject )
           }, //set
</PRE><PRE>           /**
            * Get something
            */
           get: function( thing, format ) {
</PRE><PRE>               // Make sure there’s something to get.
               thing = thing || 'value'
</PRE><PRE>               // If a picker state exists, return that.
               if ( STATE[ thing ] != null ) {
                   return STATE[ thing ]
               }
</PRE><PRE>               // Return the submission value, if that.
               if ( thing == 'valueSubmit' ) {
                   if ( P._hidden ) {
                       return P._hidden.value
                   }
                   thing = 'value'
               }
</PRE><PRE>               // Return the value, if that.
               if ( thing == 'value' ) {
                   return ELEMENT.value
               }
</PRE><PRE>               // Check if a component item exists, return that.
               if ( thing in P.component.item ) {
                   if ( typeof format == 'string' ) {
                       var thingValue = P.component.get( thing )
                       return thingValue ?
                           PickerConstructor._.trigger(
                               P.component.formats.toString,
                               P.component,
                               [ format, thingValue ]
                           ) : 
                   }
                   return P.component.get( thing )
               }
           }, //get
</PRE><PRE>           /**
            * Bind events on the things.
            */
           on: function( thing, method, internal ) {
</PRE><PRE>               var thingName, thingMethod,
                   thingIsObject = $.isPlainObject( thing ),
                   thingObject = thingIsObject ? thing : {}
</PRE><PRE>               if ( thing ) {
</PRE><PRE>                   // If the thing isn’t an object, make it one.
                   if ( !thingIsObject ) {
                       thingObject[ thing ] = method
                   }
</PRE><PRE>                   // Go through the things to bind to.
                   for ( thingName in thingObject ) {
</PRE><PRE>                       // Grab the method of the thing.
                       thingMethod = thingObject[ thingName ]
</PRE><PRE>                       // If it was an internal binding, prefix it.
                       if ( internal ) {
                           thingName = '_' + thingName
                       }
</PRE><PRE>                       // Make sure the thing methods collection exists.
                       STATE.methods[ thingName ] = STATE.methods[ thingName ] || []
</PRE><PRE>                       // Add the method to the relative method collection.
                       STATE.methods[ thingName ].push( thingMethod )
                   }
               }
</PRE><PRE>               return P
           }, //on
</PRE><PRE>           /**
            * Unbind events on the things.
            */
           off: function() {
               var i, thingName,
                   names = arguments;
               for ( i = 0, namesCount = names.length; i &lt; namesCount; i += 1 ) {
                   thingName = names[i]
                   if ( thingName in STATE.methods ) {
                       delete STATE.methods[thingName]
                   }
               }
               return P
           },
</PRE><PRE>           /**
            * Fire off method events.
            */
           trigger: function( name, data ) {
               var _trigger = function( name ) {
                   var methodList = STATE.methods[ name ]
                   if ( methodList ) {
                       methodList.map( function( method ) {
                           PickerConstructor._.trigger( method, P, [ data ] )
                       })
                   }
               }
               _trigger( '_' + name )
               _trigger( name )
               return P
           } //trigger
       } //PickerInstance.prototype
</PRE><PRE>   /**
    * Wrap the picker holder components together.
    */
   function createWrappedComponent() {
</PRE><PRE>       // Create a picker wrapper holder
       return PickerConstructor._.node( 'div',
</PRE><PRE>           // Create a picker wrapper node
           PickerConstructor._.node( 'div',
</PRE><PRE>               // Create a picker frame
               PickerConstructor._.node( 'div',
</PRE><PRE>                   // Create a picker box node
                   PickerConstructor._.node( 'div',
</PRE><PRE>                       // Create the components nodes.
                       P.component.nodes( STATE.open ),
</PRE><PRE>                       // The picker box class
                       CLASSES.box
                   ),
</PRE><PRE>                   // Picker wrap class
                   CLASSES.wrap
               ),
</PRE><PRE>               // Picker frame class
               CLASSES.frame
           ),
</PRE><PRE>           // Picker holder class
           CLASSES.holder
       ) //endreturn
   } //createWrappedComponent
</PRE><PRE>   /**
    * Prepare the input element with all bindings.
    */
   function prepareElement() {
</PRE><PRE>       $ELEMENT.
</PRE><PRE>           // Store the picker data by component name.
           data(NAME, P).
</PRE><PRE>           // Add the “input” class name.
           addClass(CLASSES.input).
</PRE><PRE>           // Remove the tabindex.
           attr('tabindex', -1).
</PRE><PRE>           // If there’s a `data-value`, update the value of the element.
           val( $ELEMENT.data('value') ?
               P.get('select', SETTINGS.format) :
               ELEMENT.value
           )
</PRE><PRE>       // Only bind keydown events if the element isn’t editable.
       if ( !SETTINGS.editable ) {
</PRE><PRE>           $ELEMENT.
</PRE><PRE>               // On focus/click, focus onto the root to open it up.
               on( 'focus.' + STATE.id + ' click.' + STATE.id, function( event ) {
                   event.preventDefault()
                   P.$root.eq(0).focus()
               }).
</PRE><PRE>               // Handle keyboard event based on the picker being opened or not.
               on( 'keydown.' + STATE.id, handleKeydownEvent )
       }
</PRE><PRE>       // Update the aria attributes.
       aria(ELEMENT, {
           haspopup: true,
           expanded: false,
           readonly: false,
           owns: ELEMENT.id + '_root'
       })
   }
</PRE><PRE>   /**
    * Prepare the root picker element with all bindings.
    */
   function prepareElementRoot() {
</PRE><PRE>       P.$root.
</PRE><PRE>           on({
</PRE><PRE>               // For iOS8.
               keydown: handleKeydownEvent,
</PRE><PRE>               // When something within the root is focused, stop from bubbling
               // to the doc and remove the “focused” state from the root.
               focusin: function( event ) {
                   P.$root.removeClass( CLASSES.focused )
                   event.stopPropagation()
               },
</PRE><PRE>               // When something within the root holder is clicked, stop it
               // from bubbling to the doc.
               'mousedown click': function( event ) {
</PRE><PRE>                   var target = event.target
</PRE><PRE>                   // Make sure the target isn’t the root holder so it can bubble up.
                   if ( target != P.$root.children()[ 0 ] ) {
</PRE><PRE>                       event.stopPropagation()
</PRE><PRE>                       // * For mousedown events, cancel the default action in order to
                       //   prevent cases where focus is shifted onto external elements
                       //   when using things like jQuery mobile or MagnificPopup (ref: #249 &amp; #120).
                       //   Also, for Firefox, don’t prevent action on the `option` element.
                       if ( event.type == 'mousedown' &amp;&amp; !$( target ).is( 'input, select, textarea, button, option' )) {
</PRE><PRE>                           event.preventDefault()
</PRE><PRE>                           // Re-focus onto the root so that users can click away
                           // from elements focused within the picker.
                           P.$root.eq(0).focus()
                       }
                   }
               }
           }).
</PRE><PRE>           // Add/remove the “target” class on focus and blur.
           on({
               focus: function() {
                   $ELEMENT.addClass( CLASSES.target )
               },
               blur: function() {
                   $ELEMENT.removeClass( CLASSES.target )
               }
           }).
</PRE><PRE>           // Open the picker and adjust the root “focused” state
           on( 'focus.toOpen', handleFocusToOpenEvent ).
</PRE><PRE>           // If there’s a click on an actionable element, carry out the actions.
           on( 'click', '[data-pick], [data-nav], [data-clear], [data-close]', function() {
</PRE><PRE>               var $target = $( this ),
                   targetData = $target.data(),
                   targetDisabled = $target.hasClass( CLASSES.navDisabled ) || $target.hasClass( CLASSES.disabled ),
</PRE><PRE>                   // * For IE, non-focusable elements can be active elements as well
                   //   (<A rel="nofollow" class="external free" href="http://stackoverflow.com/a/2684561">http://stackoverflow.com/a/2684561</A>).
                   activeElement = getActiveElement()
                   activeElement = activeElement &amp;&amp; ( activeElement.type || activeElement.href )
</PRE><PRE>               // If it’s disabled or nothing inside is actively focused, re-focus the element.
               if ( targetDisabled || activeElement &amp;&amp; !$.contains( P.$root[0], activeElement ) ) {
                   P.$root.eq(0).focus()
               }
</PRE><PRE>               // If something is superficially changed, update the `highlight` based on the `nav`.
               if ( !targetDisabled &amp;&amp; targetData.nav ) {
                   P.set( 'highlight', P.component.item.highlight, { nav: targetData.nav } )
               }
</PRE><PRE>               // If something is picked, set `select` then close with focus.
               else if ( !targetDisabled &amp;&amp; 'pick' in targetData ) {
                   P.set( 'select', targetData.pick )
               }
</PRE><PRE>               // If a “clear” button is pressed, empty the values and close with focus.
               else if ( targetData.clear ) {
                   P.clear().close( true )
               }
</PRE><PRE>               else if ( targetData.close ) {
                   P.close( true )
               }
</PRE><PRE>           }) //P.$root
</PRE><PRE>       aria( P.$root[0], 'hidden', true )
   }
</PRE><PRE>    /**
     * Prepare the hidden input element along with all bindings.
     */
   function prepareElementHidden() {
</PRE><PRE>       var name
</PRE><PRE>       if ( SETTINGS.hiddenName === true ) {
           name = ELEMENT.name
           ELEMENT.name = 
       }
       else {
           name = [
               typeof SETTINGS.hiddenPrefix == 'string' ? SETTINGS.hiddenPrefix : <I>,</I>
               typeof SETTINGS.hiddenSuffix == 'string' ? SETTINGS.hiddenSuffix : '_submit'
           ]
           name = name[0] + ELEMENT.name + name[1]
       }
</PRE><PRE>       P._hidden = $(
           '&lt;input ' +
           'type=hidden ' +
</PRE><PRE>           // Create the name using the original input’s with a prefix and suffix.
           'name=&quot;' + name + '&quot;' +
</PRE><PRE>           // If the element has a value, set the hidden value as well.
           (
               $ELEMENT.data('value') || ELEMENT.value ?
                   ' value=&quot;' + P.get('select', SETTINGS.formatSubmit) + '&quot;' :
                   
           ) +
           '&gt;'
       )[0]
</PRE><PRE>       $ELEMENT.
</PRE><PRE>           // If the value changes, update the hidden input with the correct format.
           on('change.' + STATE.id, function() {
               P._hidden.value = ELEMENT.value ?
                   P.get('select', SETTINGS.formatSubmit) :
                   
           })
</PRE><PRE>       // Insert the hidden input as specified in the settings.
       if ( SETTINGS.container ) $( SETTINGS.container ).append( P._hidden )
       else $ELEMENT.after( P._hidden )
   }
</PRE><PRE>   // For iOS8.
   function handleKeydownEvent( event ) {
</PRE><PRE>       var keycode = event.keyCode,
</PRE><PRE>           // Check if one of the delete keys was pressed.
           isKeycodeDelete = /^(8|46)$/.test(keycode)
</PRE><PRE>       // For some reason IE clears the input value on “escape”.
       if ( keycode == 27 ) {
           P.close()
           return false
       }
</PRE><PRE>       // Check if `space` or `delete` was pressed or the picker is closed with a key movement.
       if ( keycode == 32 || isKeycodeDelete || !STATE.open &amp;&amp; P.component.key[keycode] ) {
</PRE><PRE>           // Prevent it from moving the page and bubbling to doc.
           event.preventDefault()
           event.stopPropagation()
</PRE><PRE>           // If `delete` was pressed, clear the values and close the picker.
           // Otherwise open the picker.
           if ( isKeycodeDelete ) { P.clear().close() }
           else { P.open() }
       }
   }
</PRE><PRE>   // Separated for IE
   function handleFocusToOpenEvent( event ) {
</PRE><PRE>       // Stop the event from propagating to the doc.
       event.stopPropagation()
</PRE><PRE>       // If it’s a focus event, add the “focused” class to the root.
       if ( event.type == 'focus' ) {
           P.$root.addClass( CLASSES.focused )
       }
</PRE><PRE>       // And then finally open the picker.
       P.open()
   }
</PRE><PRE>   // Return a new picker instance.
   return new PickerInstance()
</PRE><P>} //PickerConstructor
</P><P>/**
</P><PRE>* The default classes and prefix to use for the HTML classes.
*/
</PRE><P>PickerConstructor.klasses = function( prefix ) {
</P><PRE>   prefix = prefix || 'picker'
   return {
</PRE><PRE>       picker: prefix,
       opened: prefix + '--opened',
       focused: prefix + '--focused',
</PRE><PRE>       input: prefix + '__input',
       active: prefix + '__input--active',
       target: prefix + '__input--target',
</PRE><PRE>       holder: prefix + '__holder',
</PRE><PRE>       frame: prefix + '__frame',
       wrap: prefix + '__wrap',
</PRE><PRE>       box: prefix + '__box'
   }
</PRE><P>} //PickerConstructor.klasses
</P><P>/**
</P><PRE>* Check if the default theme is being used.
*/
</PRE><P>function isUsingDefaultTheme( element ) {
</P><PRE>   var theme,
       prop = 'position'
</PRE><PRE>   // For IE.
   if ( element.currentStyle ) {
       theme = element.currentStyle[prop]
   }
</PRE><PRE>   // For normal browsers.
   else if ( window.getComputedStyle ) {
       theme = getComputedStyle( element )[prop]
   }
</PRE><PRE>   return theme == 'fixed'
</PRE><P>}
</P><P>/**
</P><PRE>* Get the width of the browser’s scrollbar.
* Taken from: <A rel="nofollow" class="external free" href="https://github.com/VodkaBears/Remodal/blob/master/src/jquery.remodal.js">https://github.com/VodkaBears/Remodal/blob/master/src/jquery.remodal.js</A>
*/
</PRE><P>function getScrollbarWidth() {
</P><PRE>   if ( $html.height() &lt;= $window.height() ) {
       return 0
   }
</PRE><PRE>   var $outer = $( '&lt;div style=&quot;visibility:hidden;width:100px&quot; /&gt;' ).
       appendTo( 'body' )
</PRE><PRE>   // Get the width without scrollbars.
   var widthWithoutScroll = $outer[0].offsetWidth
</PRE><PRE>   // Force adding scrollbars.
   $outer.css( 'overflow', 'scroll' )
</PRE><PRE>   // Add the inner div.
   var $inner = $( '&lt;div style=&quot;width:100%&quot; /&gt;' ).appendTo( $outer )
</PRE><PRE>   // Get the width with scrollbars.
   var widthWithScroll = $inner[0].offsetWidth
</PRE><PRE>   // Remove the divs.
   $outer.remove()
</PRE><PRE>   // Return the difference between the widths.
   return widthWithoutScroll - widthWithScroll
</PRE><P>}
</P><P>/**
</P><PRE>* PickerConstructor helper methods.
*/
</PRE><P>PickerConstructor._ = {
</P><PRE>   /**
    * Create a group of nodes. Expects:
    * `
       {
           min:    {Integer},
           max:    {Integer},
           i:      {Integer},
           node:   {String},
           item:   {Function}
       }
    * `
    */
   group: function( groupObject ) {
</PRE><PRE>       var
           // Scope for the looped object
           loopObjectScope,
</PRE><PRE>           // Create the nodes list
           nodesList = <I>,</I></PRE><PRE>           // The counter starts from the `min`
           counter = PickerConstructor._.trigger( groupObject.min, groupObject )
</PRE><PRE>       // Loop from the `min` to `max`, incrementing by `i`
       for ( ; counter &lt;= PickerConstructor._.trigger( groupObject.max, groupObject, [ counter ] ); counter += groupObject.i ) {
</PRE><PRE>           // Trigger the `item` function within scope of the object
           loopObjectScope = PickerConstructor._.trigger( groupObject.item, groupObject, [ counter ] )
</PRE><PRE>           // Splice the subgroup and create nodes out of the sub nodes
           nodesList += PickerConstructor._.node(
               groupObject.node,
               loopObjectScope[ 0 ],   // the node
               loopObjectScope[ 1 ],   // the classes
               loopObjectScope[ 2 ]    // the attributes
           )
       }
</PRE><PRE>       // Return the list of nodes
       return nodesList
   }, //group
</PRE><PRE>   /**
    * Create a dom node string
    */
   node: function( wrapper, item, klass, attribute ) {
</PRE><PRE>       // If the item is false-y, just return an empty string
       if ( !item ) return 
</PRE><PRE>       // If the item is an array, do a join
       item = $.isArray( item ) ? item.join( <I> ) : item</I></PRE><PRE>       // Check for the class
       klass = klass ? ' class=&quot;' + klass + '&quot;' : 
</PRE><PRE>       // Check for any attributes
       attribute = attribute ? ' ' + attribute : 
</PRE><PRE>       // Return the wrapped item
       return '&lt;' + wrapper + klass + attribute + '&gt;' + item + '&lt;/' + wrapper + '&gt;'
   }, //node
</PRE><PRE>   /**
    * Lead numbers below 10 with a zero.
    */
   lead: function( number ) {
       return ( number &lt; 10 ? '0': <I> ) + number</I>
   },
</PRE><PRE>   /**
    * Trigger a function otherwise return the value.
    */
   trigger: function( callback, scope, args ) {
       return typeof callback == 'function' ? callback.apply( scope, args || [] ) : callback
   },
</PRE><PRE>   /**
    * If the second character is a digit, length is 2 otherwise 1.
    */
   digits: function( string ) {
       return ( /\d/ ).test( string[ 1 ] ) ? 2 : 1
   },
</PRE><PRE>   /**
    * Tell if something is a date object.
    */
   isDate: function( value ) {
       return {}.toString.call( value ).indexOf( 'Date' ) &gt; -1 &amp;&amp; this.isInteger( value.getDate() )
   },
</PRE><PRE>   /**
    * Tell if something is an integer.
    */
   isInteger: function( value ) {
       return {}.toString.call( value ).indexOf( 'Number' ) &gt; -1 &amp;&amp; value % 1 === 0
   },
</PRE><PRE>   /**
    * Create ARIA attribute strings.
    */
   ariaAttr: ariaAttr
</PRE><P>} //PickerConstructor._
</P><P>/**
</P><PRE>* Extend the picker with a component and defaults.
*/
</PRE><P>PickerConstructor.extend = function( name, Component ) {
</P><PRE>   // Extend jQuery.
   $.fn[ name ] = function( options, action ) {
</PRE><PRE>       // Grab the component data.
       var componentData = this.data( name )
</PRE><PRE>       // If the picker is requested, return the data object.
       if ( options == 'picker' ) {
           return componentData
       }
</PRE><PRE>       // If the component data exists and `options` is a string, carry out the action.
       if ( componentData &amp;&amp; typeof options == 'string' ) {
           return PickerConstructor._.trigger( componentData[ options ], componentData, [ action ] )
       }
</PRE><PRE>       // Otherwise go through each matched element and if the component
       // doesn’t exist, create a new picker using `this` element
       // and merging the defaults and options with a deep copy.
       return this.each( function() {
           var $this = $( this )
           if ( !$this.data( name ) ) {
               new PickerConstructor( this, name, Component, options )
           }
       })
   }
</PRE><PRE>   // Set the defaults.
   $.fn[ name ].defaults = Component.defaults
</PRE><P>} //PickerConstructor.extend
</P><P>function aria(element, attribute, value) {
</P><PRE>   if ( $.isPlainObject(attribute) ) {
       for ( var key in attribute ) {
           ariaSet(element, key, attribute[key])
       }
   }
   else {
       ariaSet(element, attribute, value)
   }
</PRE><P>}
function ariaSet(element, attribute, value) {
</P><PRE>   element.setAttribute(
       (attribute == 'role' ? <I> : 'aria-') + attribute,</I>
       value
   )
</PRE><P>}
function ariaAttr(attribute, data) {
</P><PRE>   if ( !$.isPlainObject(attribute) ) {
       attribute = { attribute: data }
   }
   data = 
   for ( var key in attribute ) {
       var attr = (key == 'role' ? <I> : 'aria-') + key,</I>
           attrVal = attribute[key]
       data += attrVal == null ? <I> : attr + '=&quot;' + attribute[key] + '&quot;'</I>
   }
   return data
</PRE><P>}
</P><P>// IE8 bug throws an error for activeElements within iframes.
function getActiveElement() {
</P><PRE>   try {
       return document.activeElement
   } catch ( err ) { }
</PRE><P>}
</P><P>// Expose the picker constructor.
return PickerConstructor
</P><P>
}));
</P><DL><DT>/*!</DT></DL><PRE>* Date picker for pickadate.js v3.5.0
* <A rel="nofollow" class="external free" href="http://amsul.github.io/pickadate.js/date.htm">http://amsul.github.io/pickadate.js/date.htm</A>
*/
</PRE><P>(function ( factory ) {
</P><PRE>   // AMD.
   if ( typeof define == 'function' &amp;&amp; define.amd )
       define( ['picker', 'jquery'], factory )
</PRE><PRE>   // Node.js/browserify.
   else if ( typeof exports == 'object' )
       module.exports = factory( require('./picker.js'), require('jquery') )
</PRE><PRE>   // Browser globals.
   else factory( Picker, jQuery )
</PRE><P>}(function( Picker, $ ) {
</P><P>
/**
</P><PRE>* Globals and constants
*/
</PRE><P>var DAYS_IN_WEEK = 7,
</P><PRE>   WEEKS_IN_CALENDAR = 6,
   _ = Picker._
</PRE><P>/**
</P><PRE>* The date picker constructor
*/
</PRE><P>function DatePicker( picker, settings ) {
</P><PRE>   var calendar = this,
       element = picker.$node[ 0 ],
       elementValue = element.value,
       elementDataValue = picker.$node.data( 'value' ),
       valueString = elementDataValue || elementValue,
       formatString = elementDataValue ? settings.formatSubmit : settings.format,
       isRTL = function() {
</PRE><PRE>           return element.currentStyle ?
</PRE><PRE>               // For IE.
               element.currentStyle.direction == 'rtl' :
</PRE><PRE>               // For normal browsers.
               getComputedStyle( picker.$root[0] ).direction == 'rtl'
       }
</PRE><PRE>   calendar.settings = settings
   calendar.$node = picker.$node</PRE><PRE>   // The queue of methods that will be used to build item objects.
   calendar.queue = {
       min: 'measure create',
       max: 'measure create',
       now: 'now create',
       select: 'parse create validate',
       highlight: 'parse navigate create validate',
       view: 'parse create validate viewset',
       disable: 'deactivate',
       enable: 'activate'
   }
</PRE><PRE>   // The component's item object.
   calendar.item = {}
</PRE><PRE>   calendar.item.clear = null
   calendar.item.disable = ( settings.disable || [] ).slice( 0 )
   calendar.item.enable = -(function( collectionDisabled ) {
       return collectionDisabled[ 0 ] === true ? collectionDisabled.shift() : -1
   })( calendar.item.disable )
</PRE><PRE>   calendar.
       set( 'min', settings.min ).
       set( 'max', settings.max ).
       set( 'now' )
</PRE><PRE>   // When there’s a value, set the `select`, which in turn
   // also sets the `highlight` and `view`.
   if ( valueString ) {
       calendar.set( 'select', valueString, { format: formatString })
   }
</PRE><PRE>   // If there’s no value, default to highlighting “today”.
   else {
       calendar.
           set( 'select', null ).
           set( 'highlight', calendar.item.now )
   }
</PRE><PRE>   // The keycode to movement mapping.
   calendar.key = {
       40: 7, // Down
       38: -7, // Up
       39: function() { return isRTL() ? -1 : 1 }, // Right
       37: function() { return isRTL() ? 1 : -1 }, // Left
       go: function( timeChange ) {
           var highlightedObject = calendar.item.highlight,
               targetDate = new Date( highlightedObject.year, highlightedObject.month, highlightedObject.date + timeChange )
           calendar.set(
               'highlight',
               targetDate,
               { interval: timeChange }
           )
           this.render()
       }
   }
</PRE><PRE>   // Bind some picker events.
   picker.
       on( 'render', function() {
           picker.$root.find( '.' + settings.klass.selectMonth ).on( 'change', function() {
               var value = this.value
               if ( value ) {
                   picker.set( 'highlight', [ picker.get( 'view' ).year, value, picker.get( 'highlight' ).date ] )
                   picker.$root.find( '.' + settings.klass.selectMonth ).trigger( 'focus' )
               }
           })
           picker.$root.find( '.' + settings.klass.selectYear ).on( 'change', function() {
               var value = this.value
               if ( value ) {
                   picker.set( 'highlight', [ value, picker.get( 'view' ).month, picker.get( 'highlight' ).date ] )
                   picker.$root.find( '.' + settings.klass.selectYear ).trigger( 'focus' )
               }
           })
       }, 1 ).
       on( 'open', function() {
           var includeToday = 
           if ( calendar.disabled( calendar.get('now') ) ) {
               includeToday = ':not(.' + settings.klass.buttonToday + ')'
           }
           picker.$root.find( 'button' + includeToday + ', select' ).attr( 'disabled', false )
       }, 1 ).
       on( 'close', function() {
           picker.$root.find( 'button, select' ).attr( 'disabled', true )
       }, 1 )
</PRE><P>} //DatePicker
</P><P>
/**
</P><PRE>* Set a datepicker item object.
*/
</PRE><P>DatePicker.prototype.set = function( type, value, options ) {
</P><PRE>   var calendar = this,
       calendarItem = calendar.item
</PRE><PRE>   // If the value is `null` just set it immediately.
   if ( value === null ) {
       if ( type == 'clear' ) type = 'select'
       calendarItem[ type ] = value
       return calendar
   }
</PRE><PRE>   // Otherwise go through the queue of methods, and invoke the functions.
   // Update this as the time unit, and set the final value as this item.
   // * In the case of `enable`, keep the queue but set `disable` instead.
   //   And in the case of `flip`, keep the queue but set `enable` instead.
   calendarItem[ ( type == 'enable' ? 'disable' : type == 'flip' ? 'enable' : type ) ] = calendar.queue[ type ].split( ' ' ).map( function( method ) {
       value = calendar[ method ]( type, value, options )
       return value
   }).pop()
</PRE><PRE>   // Check if we need to cascade through more updates.
   if ( type == 'select' ) {
       calendar.set( 'highlight', calendarItem.select, options )
   }
   else if ( type == 'highlight' ) {
       calendar.set( 'view', calendarItem.highlight, options )
   }
   else if ( type.match( /^(flip|min|max|disable|enable)$/ ) ) {
       if ( calendarItem.select &amp;&amp; calendar.disabled( calendarItem.select ) ) {
           calendar.set( 'select', calendarItem.select, options )
       }
       if ( calendarItem.highlight &amp;&amp; calendar.disabled( calendarItem.highlight ) ) {
           calendar.set( 'highlight', calendarItem.highlight, options )
       }
   }
</PRE><PRE>   return calendar
</PRE><P>} //DatePicker.prototype.set
</P><P>
/**
</P><PRE>* Get a datepicker item object.
*/
</PRE><P>DatePicker.prototype.get = function( type ) {
</P><PRE>   return this.item[ type ]
</PRE><P>} //DatePicker.prototype.get
</P><P>
/**
</P><PRE>* Create a picker date object.
*/
</PRE><P>DatePicker.prototype.create = function( type, value, options ) {
</P><PRE>   var isInfiniteValue,
       calendar = this
</PRE><PRE>   // If there’s no value, use the type as the value.
   value = value === undefined ? type : value
</PRE><PRE>   // If it’s infinity, update the value.
   if ( value == -Infinity || value == Infinity ) {
       isInfiniteValue = value
   }
</PRE><PRE>   // If it’s an object, use the native date object.
   else if ( $.isPlainObject( value ) &amp;&amp; _.isInteger( value.pick ) ) {
       value = value.obj
   }
</PRE><PRE>   // If it’s an array, convert it into a date and make sure
   // that it’s a valid date – otherwise default to today.
   else if ( $.isArray( value ) ) {
       value = new Date( value[ 0 ], value[ 1 ], value[ 2 ] )
       value = _.isDate( value ) ? value : calendar.create().obj
   }
</PRE><PRE>   // If it’s a number or date object, make a normalized date.
   else if ( _.isInteger( value ) || _.isDate( value ) ) {
       value = calendar.normalize( new Date( value ), options )
   }
</PRE><PRE>   // If it’s a literal true or any other case, set it to now.
   else /*if ( value === true )*/ {
       value = calendar.now( type, value, options )
   }
</PRE><PRE>   // Return the compiled object.
   return {
       year: isInfiniteValue || value.getFullYear(),
       month: isInfiniteValue || value.getMonth(),
       date: isInfiniteValue || value.getDate(),
       day: isInfiniteValue || value.getDay(),
       obj: isInfiniteValue || value,
       pick: isInfiniteValue || value.getTime()
   }
</PRE><P>} //DatePicker.prototype.create
</P><P>
/**
</P><PRE>* Create a range limit object using an array, date object,
* literal “true”, or integer relative to another time.
*/
</PRE><P>DatePicker.prototype.createRange = function( from, to ) {
</P><PRE>   var calendar = this,
       createDate = function( date ) {
           if ( date === true || $.isArray( date ) || _.isDate( date ) ) {
               return calendar.create( date )
           }
           return date
       }
</PRE><PRE>   // Create objects if possible.
   if ( !_.isInteger( from ) ) {
       from = createDate( from )
   }
   if ( !_.isInteger( to ) ) {
       to = createDate( to )
   }
</PRE><PRE>   // Create relative dates.
   if ( _.isInteger( from ) &amp;&amp; $.isPlainObject( to ) ) {
       from = [ to.year, to.month, to.date + from ];
   }
   else if ( _.isInteger( to ) &amp;&amp; $.isPlainObject( from ) ) {
       to = [ from.year, from.month, from.date + to ];
   }
</PRE><PRE>   return {
       from: createDate( from ),
       to: createDate( to )
   }
</PRE><P>} //DatePicker.prototype.createRange
</P><P>
/**
</P><PRE>* Check if a date unit falls within a date range object.
*/
</PRE><P>DatePicker.prototype.withinRange = function( range, dateUnit ) {
</P><PRE>   range = this.createRange(range.from, range.to)
   return dateUnit.pick &gt;= range.from.pick &amp;&amp; dateUnit.pick &lt;= range.to.pick
</PRE><P>}
</P><P>
/**
</P><PRE>* Check if two date range objects overlap.
*/
</PRE><P>DatePicker.prototype.overlapRanges = function( one, two ) {
</P><PRE>   var calendar = this
</PRE><PRE>   // Convert the ranges into comparable dates.
   one = calendar.createRange( one.from, one.to )
   two = calendar.createRange( two.from, two.to )
</PRE><PRE>   return calendar.withinRange( one, two.from ) || calendar.withinRange( one, two.to ) ||
       calendar.withinRange( two, one.from ) || calendar.withinRange( two, one.to )
</PRE><P>}
</P><P>
/**
</P><PRE>* Get the date today.
*/
</PRE><P>DatePicker.prototype.now = function( type, value, options ) {
</P><PRE>   value = new Date()
   if ( options &amp;&amp; options.rel ) {
       value.setDate( value.getDate() + options.rel )
   }
   return this.normalize( value, options )
</PRE><P>}
</P><P>
/**
</P><PRE>* Navigate to next/prev month.
*/
</PRE><P>DatePicker.prototype.navigate = function( type, value, options ) {
</P><PRE>   var targetDateObject,
       targetYear,
       targetMonth,
       targetDate,
       isTargetArray = $.isArray( value ),
       isTargetObject = $.isPlainObject( value ),
       viewsetObject = this.item.view/*,
       safety = 100*/
</PRE><PRE>   if ( isTargetArray || isTargetObject ) {
</PRE><PRE>       if ( isTargetObject ) {
           targetYear = value.year
           targetMonth = value.month
           targetDate = value.date
       }
       else {
           targetYear = +value[0]
           targetMonth = +value[1]
           targetDate = +value[2]
       }
</PRE><PRE>       // If we’re navigating months but the view is in a different
       // month, navigate to the view’s year and month.
       if ( options &amp;&amp; options.nav &amp;&amp; viewsetObject &amp;&amp; viewsetObject.month !== targetMonth ) {
           targetYear = viewsetObject.year
           targetMonth = viewsetObject.month
       }
</PRE><PRE>       // Figure out the expected target year and month.
       targetDateObject = new Date( targetYear, targetMonth + ( options &amp;&amp; options.nav ? options.nav : 0 ), 1 )
       targetYear = targetDateObject.getFullYear()
       targetMonth = targetDateObject.getMonth()
</PRE><PRE>       // If the month we’re going to doesn’t have enough days,
       // keep decreasing the date until we reach the month’s last date.
       while ( /*safety &amp;&amp;*/ new Date( targetYear, targetMonth, targetDate ).getMonth() !== targetMonth ) {
           targetDate -= 1
           /*safety -= 1
           if ( !safety ) {
               throw 'Fell into an infinite loop while navigating to ' + new Date( targetYear, targetMonth, targetDate ) + '.'
           }*/
       }
</PRE><PRE>       value = [ targetYear, targetMonth, targetDate ]
   }
</PRE><PRE>   return value
</PRE><P>} //DatePicker.prototype.navigate
</P><P>
/**
</P><PRE>* Normalize a date by setting the hours to midnight.
*/
</PRE><P>DatePicker.prototype.normalize = function( value/*, options*/ ) {
</P><PRE>   value.setHours( 0, 0, 0, 0 )
   return value
</PRE><P>}
</P><P>
/**
</P><PRE>* Measure the range of dates.
*/
</PRE><P>DatePicker.prototype.measure = function( type, value/*, options*/ ) {
</P><PRE>   var calendar = this
</PRE><PRE>   // If it’s anything false-y, remove the limits.
   if ( !value ) {
       value = type == 'min' ? -Infinity : Infinity
   }
</PRE><PRE>   // If it’s a string, parse it.
   else if ( typeof value == 'string' ) {
       value = calendar.parse( type, value )
   }
</PRE><PRE>   // If it's an integer, get a date relative to today.
   else if ( _.isInteger( value ) ) {
       value = calendar.now( type, value, { rel: value } )
   }
</PRE><PRE>   return value
</PRE><P>} ///DatePicker.prototype.measure
</P><P>
/**
</P><PRE>* Create a viewset object based on navigation.
*/
</PRE><P>DatePicker.prototype.viewset = function( type, dateObject/*, options*/ ) {
</P><PRE>   return this.create([ dateObject.year, dateObject.month, 1 ])
</PRE><P>}
</P><P>
/**
</P><PRE>* Validate a date as enabled and shift if needed.
*/
</PRE><P>DatePicker.prototype.validate = function( type, dateObject, options ) {
</P><PRE>   var calendar = this,
</PRE><PRE>       // Keep a reference to the original date.
       originalDateObject = dateObject,
</PRE><PRE>       // Make sure we have an interval.
       interval = options &amp;&amp; options.interval ? options.interval : 1,
</PRE><PRE>       // Check if the calendar enabled dates are inverted.
       isFlippedBase = calendar.item.enable === -1,
</PRE><PRE>       // Check if we have any enabled dates after/before now.
       hasEnabledBeforeTarget, hasEnabledAfterTarget,
</PRE><PRE>       // The min &amp; max limits.
       minLimitObject = calendar.item.min,
       maxLimitObject = calendar.item.max,
</PRE><PRE>       // Check if we’ve reached the limit during shifting.
       reachedMin, reachedMax,
</PRE><PRE>       // Check if the calendar is inverted and at least one weekday is enabled.
       hasEnabledWeekdays = isFlippedBase &amp;&amp; calendar.item.disable.filter( function( value ) {
</PRE><PRE>           // If there’s a date, check where it is relative to the target.
           if ( $.isArray( value ) ) {
               var dateTime = calendar.create( value ).pick
               if ( dateTime &lt; dateObject.pick ) hasEnabledBeforeTarget = true
               else if ( dateTime &gt; dateObject.pick ) hasEnabledAfterTarget = true
           }
</PRE><PRE>           // Return only integers for enabled weekdays.
           return _.isInteger( value )
       }).length/*,
</PRE><PRE>       safety = 100*/
</PRE><PRE>   // Cases to validate for:
   // [1] Not inverted and date disabled.
   // [2] Inverted and some dates enabled.
   // [3] Not inverted and out of range.
   //
   // Cases to **not** validate for:
   // • Navigating months.
   // • Not inverted and date enabled.
   // • Inverted and all dates disabled.
   // • ..and anything else.
   if ( !options || !options.nav ) if (
       /* 1 */ ( !isFlippedBase &amp;&amp; calendar.disabled( dateObject ) ) ||
       /* 2 */ ( isFlippedBase &amp;&amp; calendar.disabled( dateObject ) &amp;&amp; ( hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget ) ) ||
       /* 3 */ ( !isFlippedBase &amp;&amp; (dateObject.pick &lt;= minLimitObject.pick || dateObject.pick &gt;= maxLimitObject.pick) )
   ) {
</PRE><PRE>       // When inverted, flip the direction if there aren’t any enabled weekdays
       // and there are no enabled dates in the direction of the interval.
       if ( isFlippedBase &amp;&amp; !hasEnabledWeekdays &amp;&amp; ( ( !hasEnabledAfterTarget &amp;&amp; interval &gt; 0 ) || ( !hasEnabledBeforeTarget &amp;&amp; interval &lt; 0 ) ) ) {
           interval *= -1
       }
</PRE><PRE>       // Keep looping until we reach an enabled date.
       while ( /*safety &amp;&amp;*/ calendar.disabled( dateObject ) ) {
</PRE><PRE>           /*safety -= 1
           if ( !safety ) {
               throw 'Fell into an infinite loop while validating ' + dateObject.obj + '.'
           }*/
</PRE><PRE>           // If we’ve looped into the next/prev month with a large interval, return to the original date and flatten the interval.
           if ( Math.abs( interval ) &gt; 1 &amp;&amp; ( dateObject.month &lt; originalDateObject.month || dateObject.month &gt; originalDateObject.month ) ) {
               dateObject = originalDateObject
               interval = interval &gt; 0 ? 1 : -1
           }
</PRE><PRE>           // If we’ve reached the min/max limit, reverse the direction, flatten the interval and set it to the limit.
           if ( dateObject.pick &lt;= minLimitObject.pick ) {
               reachedMin = true
               interval = 1
               dateObject = calendar.create([
                   minLimitObject.year,
                   minLimitObject.month,
                   minLimitObject.date + (dateObject.pick === minLimitObject.pick ? 0 : -1)
               ])
           }
           else if ( dateObject.pick &gt;= maxLimitObject.pick ) {
               reachedMax = true
               interval = -1
               dateObject = calendar.create([
                   maxLimitObject.year,
                   maxLimitObject.month,
                   maxLimitObject.date + (dateObject.pick === maxLimitObject.pick ? 0 : 1)
               ])
           }
</PRE><PRE>           // If we’ve reached both limits, just break out of the loop.
           if ( reachedMin &amp;&amp; reachedMax ) {
               break
           }
</PRE><PRE>           // Finally, create the shifted date using the interval and keep looping.
           dateObject = calendar.create([ dateObject.year, dateObject.month, dateObject.date + interval ])
       }
</PRE><PRE>   } //endif
</PRE><PRE>   // Return the date object settled on.
   return dateObject
</PRE><P>} //DatePicker.prototype.validate
</P><P>
/**
</P><PRE>* Check if a date is disabled.
*/
</PRE><P>DatePicker.prototype.disabled = function( dateToVerify ) {
</P><PRE>   var
       calendar = this,
</PRE><PRE>       // Filter through the disabled dates to check if this is one.
       isDisabledMatch = calendar.item.disable.filter( function( dateToDisable ) {
</PRE><PRE>           // If the date is a number, match the weekday with 0index and `firstDay` check.
           if ( _.isInteger( dateToDisable ) ) {
               return dateToVerify.day === ( calendar.settings.firstDay ? dateToDisable : dateToDisable - 1 ) % 7
           }
</PRE><PRE>           // If it’s an array or a native JS date, create and match the exact date.
           if ( $.isArray( dateToDisable ) || _.isDate( dateToDisable ) ) {
               return dateToVerify.pick === calendar.create( dateToDisable ).pick
           }
</PRE><PRE>           // If it’s an object, match a date within the “from” and “to” range.
           if ( $.isPlainObject( dateToDisable ) ) {
               return calendar.withinRange( dateToDisable, dateToVerify )
           }
       })
</PRE><PRE>   // If this date matches a disabled date, confirm it’s not inverted.
   isDisabledMatch = isDisabledMatch.length &amp;&amp; !isDisabledMatch.filter(function( dateToDisable ) {
       return $.isArray( dateToDisable ) &amp;&amp; dateToDisable[3] == 'inverted' ||
           $.isPlainObject( dateToDisable ) &amp;&amp; dateToDisable.inverted
   }).length
</PRE><PRE>   // Check the calendar “enabled” flag and respectively flip the
   // disabled state. Then also check if it’s beyond the min/max limits.
   return calendar.item.enable === -1 ? !isDisabledMatch : isDisabledMatch ||
       dateToVerify.pick &lt; calendar.item.min.pick ||
       dateToVerify.pick &gt; calendar.item.max.pick
</PRE><P>} //DatePicker.prototype.disabled
</P><P>
/**
</P><PRE>* Parse a string into a usable type.
*/
</PRE><P>DatePicker.prototype.parse = function( type, value, options ) {
</P><PRE>   var calendar = this,
       parsingObject = {}
</PRE><PRE>   // If it’s already parsed, we’re good.
   if ( !value || typeof value != 'string' ) {
       return value
   }
</PRE><PRE>   // We need a `.format` to parse the value with.
   if ( !( options &amp;&amp; options.format ) ) {
       options = options || {}
       options.format = calendar.settings.format
   }
</PRE><PRE>   // Convert the format into an array and then map through it.
   calendar.formats.toArray( options.format ).map( function( label ) {
</PRE><PRE>       var
           // Grab the formatting label.
           formattingLabel = calendar.formats[ label ],
</PRE><PRE>           // The format length is from the formatting label function or the
           // label length without the escaping exclamation (!) mark.
           formatLength = formattingLabel ? _.trigger( formattingLabel, calendar, [ value, parsingObject ] ) : label.replace( /^!/, <I> ).length</I></PRE><PRE>       // If there's a format label, split the value up to the format length.
       // Then add it to the parsing object with appropriate label.
       if ( formattingLabel ) {
           parsingObject[ label ] = value.substr( 0, formatLength )
       }
</PRE><PRE>       // Update the value as the substring from format length to end.
       value = value.substr( formatLength )
   })
</PRE><PRE>   // Compensate for month 0index.
   return [
       parsingObject.yyyy || parsingObject.yy,
       +( parsingObject.mm || parsingObject.m ) - 1,
       parsingObject.dd || parsingObject.d
   ]
</PRE><P>} //DatePicker.prototype.parse
</P><P>
/**
</P><PRE>* Various formats to display the object in.
*/
</PRE><P>DatePicker.prototype.formats = (function() {
</P><PRE>   // Return the length of the first word in a collection.
   function getWordLengthFromCollection( string, collection, dateObject ) {
</PRE><PRE>       // Grab the first word from the string.
       var word = string.match( /\w+/ )[ 0 ]
</PRE><PRE>       // If there's no month index, add it to the date object
       if ( !dateObject.mm &amp;&amp; !dateObject.m ) {
           dateObject.m = collection.indexOf( word ) + 1
       }
</PRE><PRE>       // Return the length of the word.
       return word.length
   }
</PRE><PRE>   // Get the length of the first word in a string.
   function getFirstWordLength( string ) {
       return string.match( /\w+/ )[ 0 ].length
   }
</PRE><PRE>   return {
</PRE><PRE>       d: function( string, dateObject ) {
</PRE><PRE>           // If there's string, then get the digits length.
           // Otherwise return the selected date.
           return string ? _.digits( string ) : dateObject.date
       },
       dd: function( string, dateObject ) {
</PRE><PRE>           // If there's a string, then the length is always 2.
           // Otherwise return the selected date with a leading zero.
           return string ? 2 : _.lead( dateObject.date )
       },
       ddd: function( string, dateObject ) {
</PRE><PRE>           // If there's a string, then get the length of the first word.
           // Otherwise return the short selected weekday.
           return string ? getFirstWordLength( string ) : this.settings.weekdaysShort[ dateObject.day ]
       },
       dddd: function( string, dateObject ) {
</PRE><PRE>           // If there's a string, then get the length of the first word.
           // Otherwise return the full selected weekday.
           return string ? getFirstWordLength( string ) : this.settings.weekdaysFull[ dateObject.day ]
       },
       m: function( string, dateObject ) {
</PRE><PRE>           // If there's a string, then get the length of the digits
           // Otherwise return the selected month with 0index compensation.
           return string ? _.digits( string ) : dateObject.month + 1
       },
       mm: function( string, dateObject ) {
</PRE><PRE>           // If there's a string, then the length is always 2.
           // Otherwise return the selected month with 0index and leading zero.
           return string ? 2 : _.lead( dateObject.month + 1 )
       },
       mmm: function( string, dateObject ) {
</PRE><PRE>           var collection = this.settings.monthsShort
</PRE><PRE>           // If there's a string, get length of the relevant month from the short
           // months collection. Otherwise return the selected month from that collection.
           return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]
       },
       mmmm: function( string, dateObject ) {
</PRE><PRE>           var collection = this.settings.monthsFull
</PRE><PRE>           // If there's a string, get length of the relevant month from the full
           // months collection. Otherwise return the selected month from that collection.
           return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]
       },
       yy: function( string, dateObject ) {
</PRE><PRE>           // If there's a string, then the length is always 2.
           // Otherwise return the selected year by slicing out the first 2 digits.
           return string ? 2 : ( <I> + dateObject.year ).slice( 2 )</I>
       },
       yyyy: function( string, dateObject ) {
</PRE><PRE>           // If there's a string, then the length is always 4.
           // Otherwise return the selected year.
           return string ? 4 : dateObject.year
       },
</PRE><PRE>       // Create an array by splitting the formatting string passed.
       toArray: function( formatString ) { return formatString.split( /(d{1,4}|m{1,4}|y{4}|yy|!.)/g ) },
</PRE><PRE>       // Format an object into a string using the formatting options.
       toString: function ( formatString, itemObject ) {
           var calendar = this
           return calendar.formats.toArray( formatString ).map( function( label ) {
               return _.trigger( calendar.formats[ label ], calendar, [ 0, itemObject ] ) || label.replace( /^!/, <I> )</I>
           }).join( <I> )</I>
       }
   }
</PRE><P>})() //DatePicker.prototype.formats
</P><P>
/**
</P><PRE>* Check if two date units are the exact.
*/
</PRE><P>DatePicker.prototype.isDateExact = function( one, two ) {
</P><PRE>   var calendar = this
</PRE><PRE>   // When we’re working with weekdays, do a direct comparison.
   if (
       ( _.isInteger( one ) &amp;&amp; _.isInteger( two ) ) ||
       ( typeof one == 'boolean' &amp;&amp; typeof two == 'boolean' )
    ) {
       return one === two
   }
</PRE><PRE>   // When we’re working with date representations, compare the “pick” value.
   if (
       ( _.isDate( one ) || $.isArray( one ) ) &amp;&amp;
       ( _.isDate( two ) || $.isArray( two ) )
   ) {
       return calendar.create( one ).pick === calendar.create( two ).pick
   }
</PRE><PRE>   // When we’re working with range objects, compare the “from” and “to”.
   if ( $.isPlainObject( one ) &amp;&amp; $.isPlainObject( two ) ) {
       return calendar.isDateExact( one.from, two.from ) &amp;&amp; calendar.isDateExact( one.to, two.to )
   }
</PRE><PRE>   return false
</PRE><P>}
</P><P>
/**
</P><PRE>* Check if two date units overlap.
*/
</PRE><P>DatePicker.prototype.isDateOverlap = function( one, two ) {
</P><PRE>   var calendar = this,
       firstDay = calendar.settings.firstDay ? 1 : 0
</PRE><PRE>   // When we’re working with a weekday index, compare the days.
   if ( _.isInteger( one ) &amp;&amp; ( _.isDate( two ) || $.isArray( two ) ) ) {
       one = one % 7 + firstDay
       return one === calendar.create( two ).day + 1
   }
   if ( _.isInteger( two ) &amp;&amp; ( _.isDate( one ) || $.isArray( one ) ) ) {
       two = two % 7 + firstDay
       return two === calendar.create( one ).day + 1
   }
</PRE><PRE>   // When we’re working with range objects, check if the ranges overlap.
   if ( $.isPlainObject( one ) &amp;&amp; $.isPlainObject( two ) ) {
       return calendar.overlapRanges( one, two )
   }
</PRE><PRE>   return false
</PRE><P>}
</P><P>
/**
</P><PRE>* Flip the “enabled” state.
*/
</PRE><P>DatePicker.prototype.flipEnable = function(val) {
</P><PRE>   var itemObject = this.item
   itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1)
</PRE><P>}
</P><P>
/**
</P><PRE>* Mark a collection of dates as “disabled”.
*/
</PRE><P>DatePicker.prototype.deactivate = function( type, datesToDisable ) {
</P><PRE>   var calendar = this,
       disabledItems = calendar.item.disable.slice(0)
</PRE><PRE>   // If we’re flipping, that’s all we need to do.
   if ( datesToDisable == 'flip' ) {
       calendar.flipEnable()
   }
</PRE><PRE>   else if ( datesToDisable === false ) {
       calendar.flipEnable(1)
       disabledItems = []
   }
</PRE><PRE>   else if ( datesToDisable === true ) {
       calendar.flipEnable(-1)
       disabledItems = []
   }
</PRE><PRE>   // Otherwise go through the dates to disable.
   else {
</PRE><PRE>       datesToDisable.map(function( unitToDisable ) {
</PRE><PRE>           var matchFound
</PRE><PRE>           // When we have disabled items, check for matches.
           // If something is matched, immediately break out.
           for ( var index = 0; index &lt; disabledItems.length; index += 1 ) {
               if ( calendar.isDateExact( unitToDisable, disabledItems[index] ) ) {
                   matchFound = true
                   break
               }
           }
</PRE><PRE>           // If nothing was found, add the validated unit to the collection.
           if ( !matchFound ) {
               if (
                   _.isInteger( unitToDisable ) ||
                   _.isDate( unitToDisable ) ||
                   $.isArray( unitToDisable ) ||
                   ( $.isPlainObject( unitToDisable ) &amp;&amp; unitToDisable.from &amp;&amp; unitToDisable.to )
               ) {
                   disabledItems.push( unitToDisable )
               }
           }
       })
   }
</PRE><PRE>   // Return the updated collection.
   return disabledItems
</PRE><P>} //DatePicker.prototype.deactivate
</P><P>
/**
</P><PRE>* Mark a collection of dates as “enabled”.
*/
</PRE><P>DatePicker.prototype.activate = function( type, datesToEnable ) {
</P><PRE>   var calendar = this,
       disabledItems = calendar.item.disable,
       disabledItemsCount = disabledItems.length
</PRE><PRE>   // If we’re flipping, that’s all we need to do.
   if ( datesToEnable == 'flip' ) {
       calendar.flipEnable()
   }
</PRE><PRE>   else if ( datesToEnable === true ) {
       calendar.flipEnable(1)
       disabledItems = []
   }
</PRE><PRE>   else if ( datesToEnable === false ) {
       calendar.flipEnable(-1)
       disabledItems = []
   }
</PRE><PRE>   // Otherwise go through the disabled dates.
   else {
</PRE><PRE>       datesToEnable.map(function( unitToEnable ) {
</PRE><PRE>           var matchFound,
               disabledUnit,
               index,
               isExactRange
</PRE><PRE>           // Go through the disabled items and try to find a match.
           for ( index = 0; index &lt; disabledItemsCount; index += 1 ) {
</PRE><PRE>               disabledUnit = disabledItems[index]
</PRE><PRE>               // When an exact match is found, remove it from the collection.
               if ( calendar.isDateExact( disabledUnit, unitToEnable ) ) {
                   matchFound = disabledItems[index] = null
                   isExactRange = true
                   break
               }
</PRE><PRE>               // When an overlapped match is found, add the “inverted” state to it.
               else if ( calendar.isDateOverlap( disabledUnit, unitToEnable ) ) {
                   if ( $.isPlainObject( unitToEnable ) ) {
                       unitToEnable.inverted = true
                       matchFound = unitToEnable
                   }
                   else if ( $.isArray( unitToEnable ) ) {
                       matchFound = unitToEnable
                       if ( !matchFound[3] ) matchFound.push( 'inverted' )
                   }
                   else if ( _.isDate( unitToEnable ) ) {
                       matchFound = [ unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), 'inverted' ]
                   }
                   break
               }
           }
</PRE><PRE>           // If a match was found, remove a previous duplicate entry.
           if ( matchFound ) for ( index = 0; index &lt; disabledItemsCount; index += 1 ) {
               if ( calendar.isDateExact( disabledItems[index], unitToEnable ) ) {
                   disabledItems[index] = null
                   break
               }
           }
</PRE><PRE>           // In the event that we’re dealing with an exact range of dates,
           // make sure there are no “inverted” dates because of it.
           if ( isExactRange ) for ( index = 0; index &lt; disabledItemsCount; index += 1 ) {
               if ( calendar.isDateOverlap( disabledItems[index], unitToEnable ) ) {
                   disabledItems[index] = null
                   break
               }
           }
</PRE><PRE>           // If something is still matched, add it into the collection.
           if ( matchFound ) {
               disabledItems.push( matchFound )
           }
       })
   }
</PRE><PRE>   // Return the updated collection.
   return disabledItems.filter(function( val ) { return val != null })
</PRE><P>} //DatePicker.prototype.activate
</P><P>
/**
</P><PRE>* Create a string for the nodes in the picker.
*/
</PRE><P>DatePicker.prototype.nodes = function( isOpen ) {
</P><PRE>   var
       calendar = this,
       settings = calendar.settings,
       calendarItem = calendar.item,
       nowObject = calendarItem.now,
       selectedObject = calendarItem.select,
       highlightedObject = calendarItem.highlight,
       viewsetObject = calendarItem.view,
       disabledCollection = calendarItem.disable,
       minLimitObject = calendarItem.min,
       maxLimitObject = calendarItem.max,
</PRE><PRE>       // Create the calendar table head using a copy of weekday labels collection.
       // * We do a copy so we don't mutate the original array.
       tableHead = (function( collection, fullCollection ) {
</PRE><PRE>           // If the first day should be Monday, move Sunday to the end.
           if ( settings.firstDay ) {
               collection.push( collection.shift() )
               fullCollection.push( fullCollection.shift() )
           }
</PRE><PRE>           // Create and return the table head group.
           return _.node(
               'thead',
               _.node(
                   'tr',
                   _.group({
                       min: 0,
                       max: DAYS_IN_WEEK - 1,
                       i: 1,
                       node: 'th',
                       item: function( counter ) {
                           return [
                               collection[ counter ],
                               settings.klass.weekdays,
                               'scope=col title=&quot;' + fullCollection[ counter ] + '&quot;'
                           ]
                       }
                   })
               )
           ) //endreturn
</PRE><PRE>       // Materialize modified
       })( ( settings.showWeekdaysFull ? settings.weekdaysFull : settings.weekdaysLetter ).slice( 0 ), settings.weekdaysFull.slice( 0 ) ), //tableHead
</PRE><PRE>       // Create the nav for next/prev month.
       createMonthNav = function( next ) {
</PRE><PRE>           // Otherwise, return the created month tag.
           return _.node(
               'div',
               ' ',
               settings.klass[ 'nav' + ( next ? 'Next' : 'Prev' ) ] + (
</PRE><PRE>                   // If the focused month is outside the range, disabled the button.
                   ( next &amp;&amp; viewsetObject.year &gt;= maxLimitObject.year &amp;&amp; viewsetObject.month &gt;= maxLimitObject.month ) ||
                   ( !next &amp;&amp; viewsetObject.year &lt;= minLimitObject.year &amp;&amp; viewsetObject.month &lt;= minLimitObject.month ) ?
                   ' ' + settings.klass.navDisabled : 
               ),
               'data-nav=' + ( next || -1 ) + ' ' +
               _.ariaAttr({
                   role: 'button',
                   controls: calendar.$node[0].id + '_table'
               }) + ' ' +
               'title=&quot;' + (next ? settings.labelMonthNext : settings.labelMonthPrev ) + '&quot;'
           ) //endreturn
       }, //createMonthNav
</PRE><PRE>       // Create the month label.
       //Materialize modified
       createMonthLabel = function(override) {
</PRE><PRE>           var monthsCollection = settings.showMonthsShort ? settings.monthsShort : settings.monthsFull
</PRE><PRE>            // Materialize modified
           if (override == &quot;short_months&quot;) {
             monthsCollection = settings.monthsShort;
           }
</PRE><PRE>           // If there are months to select, add a dropdown menu.
           if ( settings.selectMonths  &amp;&amp; override == undefined) {
</PRE><PRE>               return _.node( 'select',
                   _.group({
                       min: 0,
                       max: 11,
                       i: 1,
                       node: 'option',
                       item: function( loopedMonth ) {
</PRE><PRE>                           return [
</PRE><PRE>                               // The looped month and no classes.
                               monthsCollection[ loopedMonth ], 0,
</PRE><PRE>                               // Set the value and selected index.
                               'value=' + loopedMonth +
                               ( viewsetObject.month == loopedMonth ? ' selected' : <I> ) +</I>
                               (
                                   (
                                       ( viewsetObject.year == minLimitObject.year &amp;&amp; loopedMonth &lt; minLimitObject.month ) ||
                                       ( viewsetObject.year == maxLimitObject.year &amp;&amp; loopedMonth &gt; maxLimitObject.month )
                                   ) ?
                                   ' disabled' : 
                               )
                           ]
                       }
                   }),
                   settings.klass.selectMonth + ' browser-default',
                   ( isOpen ? <I> : 'disabled' ) + ' ' +</I>
                   _.ariaAttr({ controls: calendar.$node[0].id + '_table' }) + ' ' +
                   'title=&quot;' + settings.labelMonthSelect + '&quot;'
               )
           }
</PRE><PRE>           // Materialize modified
           if (override == &quot;short_months&quot;)
               if (selectedObject != null)
               return _.node( 'div', monthsCollection[ selectedObject.month ] );
               else return _.node( 'div', monthsCollection[ viewsetObject.month ] );
</PRE><PRE>           // If there's a need for a month selector
           return _.node( 'div', monthsCollection[ viewsetObject.month ], settings.klass.month )
       }, //createMonthLabel
</PRE><PRE>       // Create the year label.
       // Materialize modified
       createYearLabel = function(override) {
</PRE><PRE>           var focusedYear = viewsetObject.year,
</PRE><PRE>           // If years selector is set to a literal &quot;true&quot;, set it to 5. Otherwise
           // divide in half to get half before and half after focused year.
           numberYears = settings.selectYears === true ? 5 : ~~( settings.selectYears / 2 )
</PRE><PRE>           // If there are years to select, add a dropdown menu.
           if ( numberYears ) {
</PRE><PRE>               var
                   minYear = minLimitObject.year,
                   maxYear = maxLimitObject.year,
                   lowestYear = focusedYear - numberYears,
                   highestYear = focusedYear + numberYears
</PRE><PRE>               // If the min year is greater than the lowest year, increase the highest year
               // by the difference and set the lowest year to the min year.
               if ( minYear &gt; lowestYear ) {
                   highestYear += minYear - lowestYear
                   lowestYear = minYear
               }
</PRE><PRE>               // If the max year is less than the highest year, decrease the lowest year
               // by the lower of the two: available and needed years. Then set the
               // highest year to the max year.
               if ( maxYear &lt; highestYear ) {
</PRE><PRE>                   var availableYears = lowestYear - minYear,
                       neededYears = highestYear - maxYear
</PRE><PRE>                   lowestYear -= availableYears &gt; neededYears ? neededYears : availableYears
                   highestYear = maxYear
               }
</PRE><PRE>               if ( settings.selectYears  &amp;&amp; override == undefined ) {
                   return _.node( 'select',
                       _.group({
                           min: lowestYear,
                           max: highestYear,
                           i: 1,
                           node: 'option',
                           item: function( loopedYear ) {
                               return [
</PRE><PRE>                                   // The looped year and no classes.
                                   loopedYear, 0,
</PRE><PRE>                                   // Set the value and selected index.
                                   'value=' + loopedYear + ( focusedYear == loopedYear ? ' selected' : <I> )</I>
                               ]
                           }
                       }),
                       settings.klass.selectYear + ' browser-default',
                       ( isOpen ? <I> : 'disabled' ) + ' ' + _.ariaAttr({ controls: calendar.$node[0].id + '_table' }) + ' ' +</I>
                       'title=&quot;' + settings.labelYearSelect + '&quot;'
                   )
               }
           }
</PRE><PRE>           // Materialize modified
           if (override == &quot;raw&quot;)
               return _.node( 'div', focusedYear )
</PRE><PRE>           // Otherwise just return the year focused
           return _.node( 'div', focusedYear, settings.klass.year )
       } //createYearLabel
</PRE><PRE>       // Materialize modified
       createDayLabel = function() {
               if (selectedObject != null)
                   return _.node( 'div', selectedObject.date)
               else return _.node( 'div', nowObject.date)
           }
       createWeekdayLabel = function() {
           var display_day;
</PRE><PRE>           if (selectedObject != null)
               display_day = selectedObject.day;
           else
               display_day = nowObject.day;
           var weekday = settings.weekdaysFull[ display_day ]
           return weekday
       }
</PRE><PRE>   // Create and return the entire calendar.
</PRE><P>return _.node(
</P><PRE>       // Date presentation View
       'div',
           _.node(
               'div',
               createWeekdayLabel(),
               &quot;picker__weekday-display&quot;
           )+
           _.node(
               // Div for short Month
               'div',
               createMonthLabel(&quot;short_months&quot;),
               settings.klass.month_display
           )+
           _.node(
               // Div for Day
               'div',
               createDayLabel() ,
               settings.klass.day_display
           )+
           _.node(
               // Div for Year
               'div',
               createYearLabel(&quot;raw&quot;) ,
               settings.klass.year_display
           ),
       settings.klass.date_display
   )+
   // Calendar container
   _.node('div',
       _.node('div',
       ( settings.selectYears ?  createMonthLabel() + createYearLabel() : createMonthLabel() + createYearLabel() ) +
       createMonthNav() + createMonthNav( 1 ),
       settings.klass.header
   ) + _.node(
       'table',
       tableHead +
       _.node(
           'tbody',
           _.group({
               min: 0,
               max: WEEKS_IN_CALENDAR - 1,
               i: 1,
               node: 'tr',
               item: function( rowCounter ) {
</PRE><PRE>                   // If Monday is the first day and the month starts on Sunday, shift the date back a week.
                   var shiftDateBy = settings.firstDay &amp;&amp; calendar.create([ viewsetObject.year, viewsetObject.month, 1 ]).day === 0 ? -7 : 0
</PRE><PRE>                   return [
                       _.group({
                           min: DAYS_IN_WEEK * rowCounter - viewsetObject.day + shiftDateBy + 1, // Add 1 for weekday 0index
                           max: function() {
                               return this.min + DAYS_IN_WEEK - 1
                           },
                           i: 1,
                           node: 'td',
                           item: function( targetDate ) {
</PRE><PRE>                               // Convert the time date from a relative date to a target date.
                               targetDate = calendar.create([ viewsetObject.year, viewsetObject.month, targetDate + ( settings.firstDay ? 1 : 0 ) ])
</PRE><PRE>                               var isSelected = selectedObject &amp;&amp; selectedObject.pick == targetDate.pick,
                                   isHighlighted = highlightedObject &amp;&amp; highlightedObject.pick == targetDate.pick,
                                   isDisabled = disabledCollection &amp;&amp; calendar.disabled( targetDate ) || targetDate.pick &lt; minLimitObject.pick || targetDate.pick &gt; maxLimitObject.pick,
                                   formattedDate = _.trigger( calendar.formats.toString, calendar, [ settings.format, targetDate ] )
</PRE><PRE>                               return [
                                   _.node(
                                       'div',
                                       targetDate.date,
                                       (function( klasses ) {
</PRE><PRE>                                           // Add the `infocus` or `outfocus` classes based on month in view.
                                           klasses.push( viewsetObject.month == targetDate.month ? settings.klass.infocus : settings.klass.outfocus )
</PRE><PRE>                                           // Add the `today` class if needed.
                                           if ( nowObject.pick == targetDate.pick ) {
                                               klasses.push( settings.klass.now )
                                           }
</PRE><PRE>                                           // Add the `selected` class if something's selected and the time matches.
                                           if ( isSelected ) {
                                               klasses.push( settings.klass.selected )
                                           }
</PRE><PRE>                                           // Add the `highlighted` class if something's highlighted and the time matches.
                                           if ( isHighlighted ) {
                                               klasses.push( settings.klass.highlighted )
                                           }
</PRE><PRE>                                           // Add the `disabled` class if something's disabled and the object matches.
                                           if ( isDisabled ) {
                                               klasses.push( settings.klass.disabled )
                                           }
</PRE><PRE>                                           return klasses.join( ' ' )
                                       })([ settings.klass.day ]),
                                       'data-pick=' + targetDate.pick + ' ' + _.ariaAttr({
                                           role: 'gridcell',
                                           label: formattedDate,
                                           selected: isSelected &amp;&amp; calendar.$node.val() === formattedDate ? true : null,
                                           activedescendant: isHighlighted ? true : null,
                                           disabled: isDisabled ? true : null
                                       })
                                   ),
                                   <I>,</I>
                                   _.ariaAttr({ role: 'presentation' })
                               ] //endreturn
                           }
                       })
                   ] //endreturn
               }
           })
       ),
       settings.klass.table,
       'id=&quot;' + calendar.$node[0].id + '_table' + '&quot; ' + _.ariaAttr({
           role: 'grid',
           controls: calendar.$node[0].id,
           readonly: true
       })
   )
   , settings.klass.calendar_container) // end calendar
</PRE><PRE>    +
</PRE><PRE>   // * For Firefox forms to submit, make sure to set the buttons’ `type` attributes as “button”.
   _.node(
       'div',
       _.node( 'button', settings.today, &quot;btn-flat picker__today&quot;,
           'type=button data-pick=' + nowObject.pick +
           ( isOpen &amp;&amp; !calendar.disabled(nowObject) ? <I> : ' disabled' ) + ' ' +</I>
           _.ariaAttr({ controls: calendar.$node[0].id }) ) +
       _.node( 'button', settings.clear, &quot;btn-flat picker__clear&quot;,
           'type=button data-clear=1' +
           ( isOpen ? <I> : ' disabled' ) + ' ' +</I>
           _.ariaAttr({ controls: calendar.$node[0].id }) ) +
       _.node('button', settings.close, &quot;btn-flat picker__close&quot;,
           'type=button data-close=true ' +
           ( isOpen ? <I> : ' disabled' ) + ' ' +</I>
           _.ariaAttr({ controls: calendar.$node[0].id }) ),
       settings.klass.footer
   ) //endreturn
</PRE><P>} //DatePicker.prototype.nodes
</P><P>
/**
</P><PRE>* The date picker defaults.
*/
</PRE><P>DatePicker.defaults = (function( prefix ) {
</P><PRE>   return {
</PRE><PRE>       // The title label to use for the month nav buttons
       labelMonthNext: 'Next month',
       labelMonthPrev: 'Previous month',
</PRE><PRE>       // The title label to use for the dropdown selectors
       labelMonthSelect: 'Select a month',
       labelYearSelect: 'Select a year',
</PRE><PRE>       // Months and weekdays
       monthsFull: [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ],
       monthsShort: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ],
       weekdaysFull: [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],
       weekdaysShort: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ],
</PRE><PRE>       // Materialize modified
       weekdaysLetter: [ 'S', 'M', 'T', 'W', 'T', 'F', 'S' ],
</PRE><PRE>       // Today and clear
       today: 'Today',
       clear: 'Clear',
       close: 'Close',
</PRE><PRE>       // The format to show on the `input` element
       format: 'd mmmm, yyyy',
</PRE><PRE>       // Classes
       klass: {
</PRE><PRE>           table: prefix + 'table',
</PRE><PRE>           header: prefix + 'header',
</PRE><PRE>           // Materialize Added klasses
           date_display: prefix + 'date-display',
           day_display: prefix + 'day-display',
           month_display: prefix + 'month-display',
           year_display: prefix + 'year-display',
           calendar_container: prefix + 'calendar-container',
           // end
</PRE><PRE>           navPrev: prefix + 'nav--prev',
           navNext: prefix + 'nav--next',
           navDisabled: prefix + 'nav--disabled',
</PRE><PRE>           month: prefix + 'month',
           year: prefix + 'year',
</PRE><PRE>           selectMonth: prefix + 'select--month',
           selectYear: prefix + 'select--year',
</PRE><PRE>           weekdays: prefix + 'weekday',
</PRE><PRE>           day: prefix + 'day',
           disabled: prefix + 'day--disabled',
           selected: prefix + 'day--selected',
           highlighted: prefix + 'day--highlighted',
           now: prefix + 'day--today',
           infocus: prefix + 'day--infocus',
           outfocus: prefix + 'day--outfocus',
</PRE><PRE>           footer: prefix + 'footer',
</PRE><PRE>           buttonClear: prefix + 'button--clear',
           buttonToday: prefix + 'button--today',
           buttonClose: prefix + 'button--close'
       }
   }
</PRE><P>})( Picker.klasses().picker + '__' )
</P><P>/**
</P><PRE>* Extend the picker to add the date picker.
*/
</PRE><P>Picker.extend( 'pickadate', DatePicker )
</P><P>
}));
</P><DL><DT>(function ($) {</DT></DL><PRE> $.fn.characterCounter = function(){
   return this.each(function(){
     var $input = $(this);
     var $counterElement = $input.parent().find('span[class=&quot;character-counter&quot;]');
</PRE><PRE>     // character counter has already been added appended to the parent container
     if ($counterElement.length) {
       return;
     }
</PRE><PRE>     var itHasLengthAttribute = $input.attr('length') !== undefined;
</PRE><PRE>     if(itHasLengthAttribute){
       $input.on('input', updateCounter);
       $input.on('focus', updateCounter);
       $input.on('blur', removeCounterElement);
</PRE><PRE>       addCounterElement($input);
     }
</PRE><PRE>   });
 };
</PRE><PRE> function updateCounter(){
   var maxLength     = +$(this).attr('length'),
   actualLength      = +$(this).val().length,
   isValidLength     = actualLength &lt;= maxLength;
</PRE><PRE>   $(this).parent().find('span[class=&quot;character-counter&quot;]')
                   .html( actualLength + '/' + maxLength);
</PRE><PRE>   addInputStyle(isValidLength, $(this));
 }
</PRE><PRE> function addCounterElement($input) {
   var $counterElement = $input.parent().find('span[class=&quot;character-counter&quot;]');
</PRE><PRE>   if ($counterElement.length) {
     return;
   }
</PRE><PRE>   $counterElement = $('&lt;span/&gt;')
                       .addClass('character-counter')
                       .css('float','right')
                       .css('font-size','12px')
                       .css('height', 1);
</PRE><PRE>   $input.parent().append($counterElement);
 }
</PRE><PRE> function removeCounterElement(){
   $(this).parent().find('span[class=&quot;character-counter&quot;]').html(<I>);</I>
 }
</PRE><PRE> function addInputStyle(isValidLength, $input){
   var inputHasInvalidClass = $input.hasClass('invalid');
   if (isValidLength &amp;&amp; inputHasInvalidClass) {
     $input.removeClass('invalid');
   }
   else if(!isValidLength &amp;&amp; !inputHasInvalidClass){
     $input.removeClass('valid');
     $input.addClass('invalid');
   }
 }
</PRE><PRE> $(document).ready(function(){
   $('input, textarea').characterCounter();
 });
</PRE><P>}( jQuery ));
</P><DL><DT>(function ($) {</DT></DL><PRE> var methods = {
</PRE><PRE>   init : function(options) {
     var defaults = {
       time_constant: 200, // ms
       dist: -100, // zoom scale TODO: make this more intuitive as an option
       shift: 0, // spacing for center image
       padding: 0, // Padding between non center items
       full_width: false, // Change to full width styles
       indicators: false, // Toggle indicators
       no_wrap: false // Don't wrap around and cycle through items.
     };
     options = $.extend(defaults, options);
</PRE><PRE>     return this.each(function() {
</PRE><PRE>       var images, offset, center, pressed, dim, count,
           reference, referenceY, amplitude, target, velocity,
           xform, frame, timestamp, ticker, dragged, vertical_dragged;
</PRE>
        var $indicators = $('');
<PRE>       // Initialize
       var view = $(this);
       var showIndicators = view.attr('data-indicators') || options.indicators;
</PRE><PRE>       // Don't double initialize.
       if (view.hasClass('initialized')) {
         // Redraw carousel.
         $(this).trigger('carouselNext', [0.000001]);
         return true;
       }
</PRE><PRE>       // Options
       if (options.full_width) {
         options.dist = 0;
         var firstImage = view.find('.carousel-item img').first();
         if (firstImage.length) {
           imageHeight = firstImage.load(function(){
             view.css('height', $(this).height());
           });
         } else {
           imageHeight = view.find('.carousel-item').first().height();
           view.css('height', imageHeight);
         }
</PRE><PRE>         // Offset fixed items when indicators.
         if (showIndicators) {
           view.find('.carousel-fixed-item').addClass('with-indicators');
         }
       }
</PRE><PRE>       view.addClass('initialized');
       pressed = false;
       offset = target = 0;
       images = [];
       item_width = view.find('.carousel-item').first().innerWidth();
       dim = item_width * 2 + options.padding;
</PRE><PRE>       view.find('.carousel-item').each(function (i) {
         images.push($(this)[0]);
         if (showIndicators) {
</PRE>
            var $indicator = $('');
<PRE>           // Add active to first by default.
           if (i === 0) {
             $indicator.addClass('active');
           }
</PRE><PRE>           // Handle clicks on indicators.
           $indicator.click(function () {
             var index = $(this).index();
             cycleTo(index);
           });
           $indicators.append($indicator);
         }
       });
</PRE><PRE>       if (showIndicators) {
         view.append($indicators);
       }
       count = images.length;
</PRE><PRE>       function setupEvents() {
         if (typeof window.ontouchstart !== 'undefined') {
           view[0].addEventListener('touchstart', tap);
           view[0].addEventListener('touchmove', drag);
           view[0].addEventListener('touchend', release);
         }
         view[0].addEventListener('mousedown', tap);
         view[0].addEventListener('mousemove', drag);
         view[0].addEventListener('mouseup', release);
         view[0].addEventListener('mouseleave', release);
         view[0].addEventListener('click', click);
       }
</PRE><PRE>       function xpos(e) {
         // touch event
         if (e.targetTouches &amp;&amp; (e.targetTouches.length &gt;= 1)) {
           return e.targetTouches[0].clientX;
         }
</PRE><PRE>         // mouse event
         return e.clientX;
       }
</PRE><PRE>       function ypos(e) {
         // touch event
         if (e.targetTouches &amp;&amp; (e.targetTouches.length &gt;= 1)) {
           return e.targetTouches[0].clientY;
         }
</PRE><PRE>         // mouse event
         return e.clientY;
       }
</PRE><PRE>       function wrap(x) {
         return (x &gt;= count) ? (x % count) : (x &lt; 0) ? wrap(count + (x % count)) : x;
       }
</PRE><PRE>       function scroll(x) {
         var i, half, delta, dir, tween, el, alignment, xTranslation;
</PRE><PRE>         offset = (typeof x === 'number') ? x : offset;
         center = Math.floor((offset + dim / 2) / dim);
         delta = offset - center * dim;
         dir = (delta &lt; 0) ? 1 : -1;
         tween = -dir * delta * 2 / dim;
         half = count &gt;&gt; 1;
</PRE><PRE>         if (!options.full_width) {
           alignment = 'translateX(' + (view[0].clientWidth - item_width) / 2 + 'px) ';
           alignment += 'translateY(' + (view[0].clientHeight - item_width) / 2 + 'px)';
         } else {
           alignment = 'translateX(0)';
         }
</PRE><PRE>         // Set indicator active
         if (showIndicators) {
           var diff = (center % count);
           var activeIndicator = $indicators.find('.indicator-item.active');
           if (activeIndicator.index() !== diff) {
             activeIndicator.removeClass('active');
             $indicators.find('.indicator-item').eq(diff).addClass('active');
           }
         }
</PRE><PRE>         // center
         // Don't show wrapped items.
         if (!options.no_wrap || (center &gt;= 0 &amp;&amp; center &lt; count)) {
           el = images[wrap(center)];
           el.style[xform] = alignment +
             ' translateX(' + (-delta / 2) + 'px)' +
             ' translateX(' + (dir * options.shift * tween * i) + 'px)' +
             ' translateZ(' + (options.dist * tween) + 'px)';
           el.style.zIndex = 0;
           if (options.full_width) { tweenedOpacity = 1; }
           else { tweenedOpacity = 1 - 0.2 * tween; }
           el.style.opacity = tweenedOpacity;
           el.style.display = 'block';
         }
</PRE><PRE>         for (i = 1; i &lt;= half; ++i) {
           // right side
           if (options.full_width) {
             zTranslation = options.dist;
             tweenedOpacity = (i === half &amp;&amp; delta &lt; 0) ? 1 - tween : 1;
           } else {
             zTranslation = options.dist * (i * 2 + tween * dir);
             tweenedOpacity = 1 - 0.2 * (i * 2 + tween * dir);
           }
           // Don't show wrapped items.
           if (!options.no_wrap || center + i &lt; count) {
             el = images[wrap(center + i)];
             el.style[xform] = alignment +
               ' translateX(' + (options.shift + (dim * i - delta) / 2) + 'px)' +
               ' translateZ(' + zTranslation + 'px)';
             el.style.zIndex = -i;
             el.style.opacity = tweenedOpacity;
             el.style.display = 'block';
           }
</PRE><PRE>           // left side
           if (options.full_width) {
             zTranslation = options.dist;
             tweenedOpacity = (i === half &amp;&amp; delta &gt; 0) ? 1 - tween : 1;
           } else {
             zTranslation = options.dist * (i * 2 - tween * dir);
             tweenedOpacity = 1 - 0.2 * (i * 2 - tween * dir);
           }
           // Don't show wrapped items.
           if (!options.no_wrap || center - i &gt;= 0) {
             el = images[wrap(center - i)];
             el.style[xform] = alignment +
               ' translateX(' + (-options.shift + (-dim * i - delta) / 2) + 'px)' +
               ' translateZ(' + zTranslation + 'px)';
             el.style.zIndex = -i;
             el.style.opacity = tweenedOpacity;
             el.style.display = 'block';
           }
         }
</PRE><PRE>         // center
         // Don't show wrapped items.
         if (!options.no_wrap || (center &gt;= 0 &amp;&amp; center &lt; count)) {
           el = images[wrap(center)];
           el.style[xform] = alignment +
             ' translateX(' + (-delta / 2) + 'px)' +
             ' translateX(' + (dir * options.shift * tween) + 'px)' +
             ' translateZ(' + (options.dist * tween) + 'px)';
           el.style.zIndex = 0;
           if (options.full_width) { tweenedOpacity = 1; }
           else { tweenedOpacity = 1 - 0.2 * tween; }
           el.style.opacity = tweenedOpacity;
           el.style.display = 'block';
         }
       }
</PRE><PRE>       function track() {
         var now, elapsed, delta, v;
</PRE><PRE>         now = Date.now();
         elapsed = now - timestamp;
         timestamp = now;
         delta = offset - frame;
         frame = offset;
</PRE><PRE>         v = 1000 * delta / (1 + elapsed);
         velocity = 0.8 * v + 0.2 * velocity;
       }
</PRE><PRE>       function autoScroll() {
         var elapsed, delta;
</PRE><PRE>         if (amplitude) {
           elapsed = Date.now() - timestamp;
           delta = amplitude * Math.exp(-elapsed / options.time_constant);
           if (delta &gt; 2 || delta &lt; -2) {
               scroll(target - delta);
               requestAnimationFrame(autoScroll);
           } else {
               scroll(target);
           }
         }
       }
</PRE><PRE>       function click(e) {
         // Disable clicks if carousel was dragged.
         if (dragged) {
           e.preventDefault();
           e.stopPropagation();
           return false;
</PRE><PRE>         } else if (!options.full_width) {
           var clickedIndex = $(e.target).closest('.carousel-item').index();
           var diff = (center % count) - clickedIndex;
</PRE><PRE>           // Disable clicks if carousel was shifted by click
           if (diff !== 0) {
             e.preventDefault();
             e.stopPropagation();
           }
           cycleTo(clickedIndex);
         }
       }
</PRE><PRE>       function cycleTo(n) {
         var diff = (center % count) - n;
</PRE><PRE>         // Account for wraparound.
         if (!options.no_wrap) {
           if (diff &lt; 0) {
             if (Math.abs(diff + count) &lt; Math.abs(diff)) { diff += count; }
</PRE><PRE>           } else if (diff &gt; 0) {
             if (Math.abs(diff - count) &lt; diff) { diff -= count; }
           }
         }
</PRE><PRE>         // Call prev or next accordingly.
         if (diff &lt; 0) {
           view.trigger('carouselNext', [Math.abs(diff)]);
</PRE><PRE>         } else if (diff &gt; 0) {
           view.trigger('carouselPrev', [diff]);
         }
       }
</PRE><PRE>       function tap(e) {
         pressed = true;
         dragged = false;
         vertical_dragged = false;
         reference = xpos(e);
         referenceY = ypos(e);
</PRE><PRE>         velocity = amplitude = 0;
         frame = offset;
         timestamp = Date.now();
         clearInterval(ticker);
         ticker = setInterval(track, 100);
</PRE><PRE>       }
</PRE><PRE>       function drag(e) {
         var x, delta, deltaY;
         if (pressed) {
           x = xpos(e);
           y = ypos(e);
           delta = reference - x;
           deltaY = Math.abs(referenceY - y);
           if (deltaY &lt; 30 &amp;&amp; !vertical_dragged) {
             // If vertical scrolling don't allow dragging.
             if (delta &gt; 2 || delta &lt; -2) {
               dragged = true;
               reference = x;
               scroll(offset + delta);
             }
</PRE><PRE>           } else if (dragged) {
             // If dragging don't allow vertical scroll.
             e.preventDefault();
             e.stopPropagation();
             return false;
</PRE><PRE>           } else {
             // Vertical scrolling.
             vertical_dragged = true;
           }
         }
</PRE><PRE>         if (dragged) {
           // If dragging don't allow vertical scroll.
           e.preventDefault();
           e.stopPropagation();
           return false;
         }
       }
</PRE><PRE>       function release(e) {
         if (pressed) {
           pressed = false;
         } else {
           return;
         }
</PRE><PRE>         clearInterval(ticker);
         target = offset;
         if (velocity &gt; 10 || velocity &lt; -10) {
           amplitude = 0.9 * velocity;
           target = offset + amplitude;
         }
         target = Math.round(target / dim) * dim;
</PRE><PRE>         // No wrap of items.
         if (options.no_wrap) {
           if (target &gt;= dim * (count - 1)) {
             target = dim * (count - 1);
           } else if (target &lt; 0) {
             target = 0;
           }
         }
         amplitude = target - offset;
         timestamp = Date.now();
         requestAnimationFrame(autoScroll);
</PRE><PRE>         if (dragged) {
           e.preventDefault();
           e.stopPropagation();
         }
         return false;
       }
</PRE><PRE>       xform = 'transform';
       ['webkit', 'Moz', 'O', 'ms'].every(function (prefix) {
         var e = prefix + 'Transform';
         if (typeof document.body.style[e] !== 'undefined') {
           xform = e;
           return false;
         }
         return true;
       });
</PRE><PRE>       window.onresize = scroll;
</PRE><PRE>       setupEvents();
       scroll(offset);
</PRE><PRE>       $(this).on('carouselNext', function(e, n) {
         if (n === undefined) {
           n = 1;
         }
         target = offset + dim * n;
         if (offset !== target) {
           amplitude = target - offset;
           timestamp = Date.now();
           requestAnimationFrame(autoScroll);
         }
       });
</PRE><PRE>       $(this).on('carouselPrev', function(e, n) {
         if (n === undefined) {
           n = 1;
         }
         target = offset - dim * n;
         if (offset !== target) {
           amplitude = target - offset;
           timestamp = Date.now();
           requestAnimationFrame(autoScroll);
         }
       });
</PRE><PRE>       $(this).on('carouselSet', function(e, n) {
         if (n === undefined) {
           n = 0;
         }
         cycleTo(n);
       });
</PRE><PRE>     });
</PRE><PRE>   },
   next : function(n) {
     $(this).trigger('carouselNext', [n]);
   },
   prev : function(n) {
     $(this).trigger('carouselPrev', [n]);
   },
   set : function(n) {
     $(this).trigger('carouselSet', [n]);
   }
 };
</PRE><PRE>   $.fn.carousel = function(methodOrOptions) {
     if ( methods[methodOrOptions] ) {
       return methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));
     } else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {
       // Default to &quot;init&quot;
       return methods.init.apply( this, arguments );
     } else {
       $.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.carousel' );
     }
   }; // Plugin end
</PRE><P>}( jQuery ));</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_SUSTech_Shenzhen_js_flip-clock-js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:SUSTech Shenzhen/js/flip-clock-js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>//! moment.js
//! version : 2.15.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
</P><DL><DT>(function (global, factory) {</DT></DL><PRE>   typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' &amp;&amp; define.amd ? define(factory) :
   global.moment = factory()
</PRE><P>}(this, function () { 'use strict';
</P><PRE>   var hookCallback;
</PRE><PRE>   function utils_hooks__hooks () {
       return hookCallback.apply(null, arguments);
   }
</PRE><PRE>   // This is done to register the method called with moment()
   // without creating circular dependencies.
   function setHookCallback (callback) {
       hookCallback = callback;
   }
</PRE><PRE>   function isArray(input) {
       return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
   }
</PRE><PRE>   function isObject(input) {
       // IE8 will treat undefined and null as object if it wasn't for
       // input != null
       return input != null &amp;&amp; Object.prototype.toString.call(input) === '[object Object]';
   }
</PRE><PRE>   function isObjectEmpty(obj) {
       var k;
       for (k in obj) {
           // even if its not own property I'd still call it non-empty
           return false;
       }
       return true;
   }
</PRE><PRE>   function isDate(input) {
       return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
   }
</PRE><PRE>   function map(arr, fn) {
       var res = [], i;
       for (i = 0; i &lt; arr.length; ++i) {
           res.push(fn(arr[i], i));
       }
       return res;
   }
</PRE><PRE>   function hasOwnProp(a, b) {
       return Object.prototype.hasOwnProperty.call(a, b);
   }
</PRE><PRE>   function extend(a, b) {
       for (var i in b) {
           if (hasOwnProp(b, i)) {
               a[i] = b[i];
           }
       }
</PRE><PRE>       if (hasOwnProp(b, 'toString')) {
           a.toString = b.toString;
       }
</PRE><PRE>       if (hasOwnProp(b, 'valueOf')) {
           a.valueOf = b.valueOf;
       }
</PRE><PRE>       return a;
   }
</PRE><PRE>   function create_utc__createUTC (input, format, locale, strict) {
       return createLocalOrUTC(input, format, locale, strict, true).utc();
   }
</PRE><PRE>   function defaultParsingFlags() {
       // We need to deep clone this object.
       return {
           empty           : false,
           unusedTokens    : [],
           unusedInput     : [],
           overflow        : -2,
           charsLeftOver   : 0,
           nullInput       : false,
           invalidMonth    : null,
           invalidFormat   : false,
           userInvalidated : false,
           iso             : false,
           parsedDateParts : [],
           meridiem        : null
       };
   }
</PRE><PRE>   function getParsingFlags(m) {
       if (m._pf == null) {
           m._pf = defaultParsingFlags();
       }
       return m._pf;
   }
</PRE><PRE>   var some;
   if (Array.prototype.some) {
       some = Array.prototype.some;
   } else {
       some = function (fun) {
           var t = Object(this);
           var len = t.length &gt;&gt;&gt; 0;
</PRE><PRE>           for (var i = 0; i &lt; len; i++) {
               if (i in t &amp;&amp; fun.call(this, t[i], i, t)) {
                   return true;
               }
           }
</PRE><PRE>           return false;
       };
   }
</PRE><PRE>   function valid__isValid(m) {
       if (m._isValid == null) {
           var flags = getParsingFlags(m);
           var parsedParts = some.call(flags.parsedDateParts, function (i) {
               return i != null;
           });
           var isNowValid = !isNaN(m._d.getTime()) &amp;&amp;
               flags.overflow &lt; 0 &amp;&amp; !flags.empty &amp;&amp; !flags.invalidMonth &amp;&amp; !flags.invalidWeekday &amp;&amp; !flags.nullInput &amp;&amp; !flags.invalidFormat &amp;&amp; !flags.userInvalidated &amp;&amp;
               (!flags.meridiem || (flags.meridiem &amp;&amp; parsedParts));
</PRE><PRE>           if (m._strict) {
               isNowValid = isNowValid &amp;&amp;
                   flags.charsLeftOver === 0 &amp;&amp;
                   flags.unusedTokens.length === 0 &amp;&amp;
                   flags.bigHour === undefined;
           }
</PRE><PRE>           if (Object.isFrozen == null || !Object.isFrozen(m)) {
               m._isValid = isNowValid;
           }
           else {
               return isNowValid;
           }
       }
       return m._isValid;
   }
</PRE><PRE>   function valid__createInvalid (flags) {
       var m = create_utc__createUTC(NaN);
       if (flags != null) {
           extend(getParsingFlags(m), flags);
       }
       else {
           getParsingFlags(m).userInvalidated = true;
       }
</PRE><PRE>       return m;
   }
</PRE><PRE>   function isUndefined(input) {
       return input === void 0;
   }
</PRE><PRE>   // Plugins that add properties should also add the key here (null value),
   // so we can properly clone ourselves.
   var momentProperties = utils_hooks__hooks.momentProperties = [];
</PRE><PRE>   function copyConfig(to, from) {
       var i, prop, val;
</PRE><PRE>       if (!isUndefined(from._isAMomentObject)) {
           to._isAMomentObject = from._isAMomentObject;
       }
       if (!isUndefined(from._i)) {
           to._i = from._i;
       }
       if (!isUndefined(from._f)) {
           to._f = from._f;
       }
       if (!isUndefined(from._l)) {
           to._l = from._l;
       }
       if (!isUndefined(from._strict)) {
           to._strict = from._strict;
       }
       if (!isUndefined(from._tzm)) {
           to._tzm = from._tzm;
       }
       if (!isUndefined(from._isUTC)) {
           to._isUTC = from._isUTC;
       }
       if (!isUndefined(from._offset)) {
           to._offset = from._offset;
       }
       if (!isUndefined(from._pf)) {
           to._pf = getParsingFlags(from);
       }
       if (!isUndefined(from._locale)) {
           to._locale = from._locale;
       }
</PRE><PRE>       if (momentProperties.length &gt; 0) {
           for (i in momentProperties) {
               prop = momentProperties[i];
               val = from[prop];
               if (!isUndefined(val)) {
                   to[prop] = val;
               }
           }
       }
</PRE><PRE>       return to;
   }
</PRE><PRE>   var updateInProgress = false;
</PRE><PRE>   // Moment prototype object
   function Moment(config) {
       copyConfig(this, config);
       this._d = new Date(config._d != null ? config._d.getTime() : NaN);
       // Prevent infinite loop in case updateOffset creates new moment
       // objects.
       if (updateInProgress === false) {
           updateInProgress = true;
           utils_hooks__hooks.updateOffset(this);
           updateInProgress = false;
       }
   }
</PRE><PRE>   function isMoment (obj) {
       return obj instanceof Moment || (obj != null &amp;&amp; obj._isAMomentObject != null);
   }
</PRE><PRE>   function absFloor (number) {
       if (number &lt; 0) {
           // -0 -&gt; 0
           return Math.ceil(number) || 0;
       } else {
           return Math.floor(number);
       }
   }
</PRE><PRE>   function toInt(argumentForCoercion) {
       var coercedNumber = +argumentForCoercion,
           value = 0;
</PRE><PRE>       if (coercedNumber !== 0 &amp;&amp; isFinite(coercedNumber)) {
           value = absFloor(coercedNumber);
       }
</PRE><PRE>       return value;
   }
</PRE><PRE>   // compare two arrays, return the number of differences
   function compareArrays(array1, array2, dontConvert) {
       var len = Math.min(array1.length, array2.length),
           lengthDiff = Math.abs(array1.length - array2.length),
           diffs = 0,
           i;
       for (i = 0; i &lt; len; i++) {
           if ((dontConvert &amp;&amp; array1[i] !== array2[i]) ||
               (!dontConvert &amp;&amp; toInt(array1[i]) !== toInt(array2[i]))) {
               diffs++;
           }
       }
       return diffs + lengthDiff;
   }
</PRE><PRE>   function warn(msg) {
       if (utils_hooks__hooks.suppressDeprecationWarnings === false &amp;&amp;
               (typeof console !==  'undefined') &amp;&amp; console.warn) {
           console.warn('Deprecation warning: ' + msg);
       }
   }
</PRE><PRE>   function deprecate(msg, fn) {
       var firstTime = true;
</PRE><PRE>       return extend(function () {
           if (utils_hooks__hooks.deprecationHandler != null) {
               utils_hooks__hooks.deprecationHandler(null, msg);
           }
           if (firstTime) {
               var args = [];
               var arg;
               for (var i = 0; i &lt; arguments.length; i++) {
                   arg = <I>;</I>
                   if (typeof arguments[i] === 'object') {
                       arg += '\n[' + i + '] ';
                       for (var key in arguments[0]) {
                           arg += key + ': ' + arguments[0][key] + ', ';
                       }
                       arg = arg.slice(0, -2); // Remove trailing comma and space
                   } else {
                       arg = arguments[i];
                   }
                   args.push(arg);
               }
               warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join(<I>) + '\n' + (new Error()).stack);</I>
               firstTime = false;
           }
           return fn.apply(this, arguments);
       }, fn);
   }
</PRE><PRE>   var deprecations = {};
</PRE><PRE>   function deprecateSimple(name, msg) {
       if (utils_hooks__hooks.deprecationHandler != null) {
           utils_hooks__hooks.deprecationHandler(name, msg);
       }
       if (!deprecations[name]) {
           warn(msg);
           deprecations[name] = true;
       }
   }
</PRE><PRE>   utils_hooks__hooks.suppressDeprecationWarnings = false;
   utils_hooks__hooks.deprecationHandler = null;
</PRE><PRE>   function isFunction(input) {
       return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
   }
</PRE><PRE>   function locale_set__set (config) {
       var prop, i;
       for (i in config) {
           prop = config[i];
           if (isFunction(prop)) {
               this[i] = prop;
           } else {
               this['_' + i] = prop;
           }
       }
       this._config = config;
       // Lenient ordinal parsing accepts just a number in addition to
       // number + (possibly) stuff coming from _ordinalParseLenient.
       this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
   }
</PRE><PRE>   function mergeConfigs(parentConfig, childConfig) {
       var res = extend({}, parentConfig), prop;
       for (prop in childConfig) {
           if (hasOwnProp(childConfig, prop)) {
               if (isObject(parentConfig[prop]) &amp;&amp; isObject(childConfig[prop])) {
                   res[prop] = {};
                   extend(res[prop], parentConfig[prop]);
                   extend(res[prop], childConfig[prop]);
               } else if (childConfig[prop] != null) {
                   res[prop] = childConfig[prop];
               } else {
                   delete res[prop];
               }
           }
       }
       for (prop in parentConfig) {
           if (hasOwnProp(parentConfig, prop) &amp;&amp; !hasOwnProp(childConfig, prop) &amp;&amp;
                   isObject(parentConfig[prop])) {
               // make sure changes to properties don't modify parent config
               res[prop] = extend({}, res[prop]);
           }
       }
       return res;
   }
</PRE><PRE>   function Locale(config) {
       if (config != null) {
           this.set(config);
       }
   }
</PRE><PRE>   var keys;
</PRE><PRE>   if (Object.keys) {
       keys = Object.keys;
   } else {
       keys = function (obj) {
           var i, res = [];
           for (i in obj) {
               if (hasOwnProp(obj, i)) {
                   res.push(i);
               }
           }
           return res;
       };
   }
</PRE><PRE>   var defaultCalendar = {
       sameDay : '[Today at] LT',
       nextDay : '[Tomorrow at] LT',
       nextWeek : 'dddd [at] LT',
       lastDay : '[Yesterday at] LT',
       lastWeek : '[Last] dddd [at] LT',
       sameElse : 'L'
   };
</PRE><PRE>   function locale_calendar__calendar (key, mom, now) {
       var output = this._calendar[key] || this._calendar['sameElse'];
       return isFunction(output) ? output.call(mom, now) : output;
   }
</PRE><PRE>   var defaultLongDateFormat = {
       LTS  : 'h:mm:ss A',
       LT   : 'h:mm A',
       L    : 'MM/DD/YYYY',
       LL   : 'MMMM D, YYYY',
       LLL  : 'MMMM D, YYYY h:mm A',
       LLLL : 'dddd, MMMM D, YYYY h:mm A'
   };
</PRE><PRE>   function longDateFormat (key) {
       var format = this._longDateFormat[key],
           formatUpper = this._longDateFormat[key.toUpperCase()];
</PRE><PRE>       if (format || !formatUpper) {
           return format;
       }
</PRE><PRE>       this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
           return val.slice(1);
       });
</PRE><PRE>       return this._longDateFormat[key];
   }
</PRE><PRE>   var defaultInvalidDate = 'Invalid date';
</PRE><PRE>   function invalidDate () {
       return this._invalidDate;
   }
</PRE><PRE>   var defaultOrdinal = '%d';
   var defaultOrdinalParse = /\d{1,2}/;
</PRE><PRE>   function ordinal (number) {
       return this._ordinal.replace('%d', number);
   }
</PRE><PRE>   var defaultRelativeTime = {
       future : 'in %s',
       past   : '%s ago',
       s  : 'a few seconds',
       m  : 'a minute',
       mm : '%d minutes',
       h  : 'an hour',
       hh : '%d hours',
       d  : 'a day',
       dd : '%d days',
       M  : 'a month',
       MM : '%d months',
       y  : 'a year',
       yy : '%d years'
   };
</PRE><PRE>   function relative__relativeTime (number, withoutSuffix, string, isFuture) {
       var output = this._relativeTime[string];
       return (isFunction(output)) ?
           output(number, withoutSuffix, string, isFuture) :
           output.replace(/%d/i, number);
   }
</PRE><PRE>   function pastFuture (diff, output) {
       var format = this._relativeTime[diff &gt; 0 ? 'future' : 'past'];
       return isFunction(format) ? format(output) : format.replace(/%s/i, output);
   }
</PRE><PRE>   var aliases = {};
</PRE><PRE>   function addUnitAlias (unit, shorthand) {
       var lowerCase = unit.toLowerCase();
       aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
   }
</PRE><PRE>   function normalizeUnits(units) {
       return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
   }
</PRE><PRE>   function normalizeObjectUnits(inputObject) {
       var normalizedInput = {},
           normalizedProp,
           prop;
</PRE><PRE>       for (prop in inputObject) {
           if (hasOwnProp(inputObject, prop)) {
               normalizedProp = normalizeUnits(prop);
               if (normalizedProp) {
                   normalizedInput[normalizedProp] = inputObject[prop];
               }
           }
       }
</PRE><PRE>       return normalizedInput;
   }
</PRE><PRE>   var priorities = {};
</PRE><PRE>   function addUnitPriority(unit, priority) {
       priorities[unit] = priority;
   }
</PRE><PRE>   function getPrioritizedUnits(unitsObj) {
       var units = [];
       for (var u in unitsObj) {
           units.push({unit: u, priority: priorities[u]});
       }
       units.sort(function (a, b) {
           return a.priority - b.priority;
       });
       return units;
   }
</PRE><PRE>   function makeGetSet (unit, keepTime) {
       return function (value) {
           if (value != null) {
               get_set__set(this, unit, value);
               utils_hooks__hooks.updateOffset(this, keepTime);
               return this;
           } else {
               return get_set__get(this, unit);
           }
       };
   }
</PRE><PRE>   function get_set__get (mom, unit) {
       return mom.isValid() ?
           mom._d['get' + (mom._isUTC ? 'UTC' : <I>) + unit]() : NaN;</I>
   }
</PRE><PRE>   function get_set__set (mom, unit, value) {
       if (mom.isValid()) {
           mom._d['set' + (mom._isUTC ? 'UTC' : <I>) + unit](value);</I>
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function stringGet (units) {
       units = normalizeUnits(units);
       if (isFunction(this[units])) {
           return this[units]();
       }
       return this;
   }
</PRE><PRE>   function stringSet (units, value) {
       if (typeof units === 'object') {
           units = normalizeObjectUnits(units);
           var prioritized = getPrioritizedUnits(units);
           for (var i = 0; i &lt; prioritized.length; i++) {
               this[prioritized[i].unit](units[prioritized[i].unit]);
           }
       } else {
           units = normalizeUnits(units);
           if (isFunction(this[units])) {
               return this[units](value);
           }
       }
       return this;
   }
</PRE><PRE>   function zeroFill(number, targetLength, forceSign) {
       var absNumber = <I> + Math.abs(number),</I>
           zerosToFill = targetLength - absNumber.length,
           sign = number &gt;= 0;
       return (sign ? (forceSign ? '+' : <I>) : '-') +</I>
           Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
   }
</PRE><PRE>   var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
</PRE><PRE>   var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
</PRE><PRE>   var formatFunctions = {};
</PRE><PRE>   var formatTokenFunctions = {};
</PRE><PRE>   // token:    'M'
   // padded:   ['MM', 2]
   // ordinal:  'Mo'
   // callback: function () { this.month() + 1 }
   function addFormatToken (token, padded, ordinal, callback) {
       var func = callback;
       if (typeof callback === 'string') {
           func = function () {
               return this[callback]();
           };
       }
       if (token) {
           formatTokenFunctions[token] = func;
       }
       if (padded) {
           formatTokenFunctions[padded[0]] = function () {
               return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
           };
       }
       if (ordinal) {
           formatTokenFunctions[ordinal] = function () {
               return this.localeData().ordinal(func.apply(this, arguments), token);
           };
       }
   }
</PRE><PRE>   function removeFormattingTokens(input) {
       if (input.match(/\[[\s\S]/)) {
           return input.replace(/^\[|\]$/g, <I>);</I>
       }
       return input.replace(/\\/g, <I>);</I>
   }
</PRE><PRE>   function makeFormatFunction(format) {
       var array = format.match(formattingTokens), i, length;
</PRE><PRE>       for (i = 0, length = array.length; i &lt; length; i++) {
           if (formatTokenFunctions[array[i]]) {
               array[i] = formatTokenFunctions[array[i]];
           } else {
               array[i] = removeFormattingTokens(array[i]);
           }
       }
</PRE><PRE>       return function (mom) {
           var output = <I>, i;</I>
           for (i = 0; i &lt; length; i++) {
               output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
           }
           return output;
       };
   }
</PRE><PRE>   // format date using native date object
   function formatMoment(m, format) {
       if (!m.isValid()) {
           return m.localeData().invalidDate();
       }
</PRE><PRE>       format = expandFormat(format, m.localeData());
       formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
</PRE><PRE>       return formatFunctions[format](m);
   }
</PRE><PRE>   function expandFormat(format, locale) {
       var i = 5;
</PRE><PRE>       function replaceLongDateFormatTokens(input) {
           return locale.longDateFormat(input) || input;
       }
</PRE><PRE>       localFormattingTokens.lastIndex = 0;
       while (i &gt;= 0 &amp;&amp; localFormattingTokens.test(format)) {
           format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
           localFormattingTokens.lastIndex = 0;
           i -= 1;
       }
</PRE><PRE>       return format;
   }
</PRE><PRE>   var match1         = /\d/;            //       0 - 9
   var match2         = /\d\d/;          //      00 - 99
   var match3         = /\d{3}/;         //     000 - 999
   var match4         = /\d{4}/;         //    0000 - 9999
   var match6         = /[+-]?\d{6}/;    // -999999 - 999999
   var match1to2      = /\d\d?/;         //       0 - 99
   var match3to4      = /\d\d\d\d?/;     //     999 - 9999
   var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
   var match1to3      = /\d{1,3}/;       //       0 - 999
   var match1to4      = /\d{1,4}/;       //       0 - 9999
   var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
</PRE><PRE>   var matchUnsigned  = /\d+/;           //       0 - inf
   var matchSigned    = /[+-]?\d+/;      //    -inf - inf
</PRE><PRE>   var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
   var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
</PRE><PRE>   var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
</PRE><PRE>   // any word (or two) characters or numbers including two/three word month in arabic.
   // includes scottish gaelic two word and hyphenated months
   var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
</PRE><PRE>   var regexes = {};
</PRE><PRE>   function addRegexToken (token, regex, strictRegex) {
       regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
           return (isStrict &amp;&amp; strictRegex) ? strictRegex : regex;
       };
   }
</PRE><PRE>   function getParseRegexForToken (token, config) {
       if (!hasOwnProp(regexes, token)) {
           return new RegExp(unescapeFormat(token));
       }
</PRE><PRE>       return regexes[token](config._strict, config._locale);
   }
</PRE><PRE>   // Code from <A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript">http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript</A>
   function unescapeFormat(s) {
       return regexEscape(s.replace('\\', <I>).replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {</I>
           return p1 || p2 || p3 || p4;
       }));
   }
</PRE><PRE>   function regexEscape(s) {
       return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&amp;');
   }
</PRE><PRE>   var tokens = {};
</PRE><PRE>   function addParseToken (token, callback) {
       var i, func = callback;
       if (typeof token === 'string') {
           token = [token];
       }
       if (typeof callback === 'number') {
           func = function (input, array) {
               array[callback] = toInt(input);
           };
       }
       for (i = 0; i &lt; token.length; i++) {
           tokens[token[i]] = func;
       }
   }
</PRE><PRE>   function addWeekParseToken (token, callback) {
       addParseToken(token, function (input, array, config, token) {
           config._w = config._w || {};
           callback(input, config._w, config, token);
       });
   }
</PRE><PRE>   function addTimeToArrayFromToken(token, input, config) {
       if (input != null &amp;&amp; hasOwnProp(tokens, token)) {
           tokens[token](input, config._a, config, token);
       }
   }
</PRE><PRE>   var YEAR = 0;
   var MONTH = 1;
   var DATE = 2;
   var HOUR = 3;
   var MINUTE = 4;
   var SECOND = 5;
   var MILLISECOND = 6;
   var WEEK = 7;
   var WEEKDAY = 8;
</PRE><PRE>   var indexOf;
</PRE><PRE>   if (Array.prototype.indexOf) {
       indexOf = Array.prototype.indexOf;
   } else {
       indexOf = function (o) {
           // I know
           var i;
           for (i = 0; i &lt; this.length; ++i) {
               if (this[i] === o) {
                   return i;
               }
           }
           return -1;
       };
   }
</PRE><PRE>   function daysInMonth(year, month) {
       return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('M', ['MM', 2], 'Mo', function () {
       return this.month() + 1;
   });
</PRE><PRE>   addFormatToken('MMM', 0, 0, function (format) {
       return this.localeData().monthsShort(this, format);
   });
</PRE><PRE>   addFormatToken('MMMM', 0, 0, function (format) {
       return this.localeData().months(this, format);
   });
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('month', 'M');
</PRE><PRE>   // PRIORITY
</PRE><PRE>   addUnitPriority('month', 8);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('M',    match1to2);
   addRegexToken('MM',   match1to2, match2);
   addRegexToken('MMM',  function (isStrict, locale) {
       return locale.monthsShortRegex(isStrict);
   });
   addRegexToken('MMMM', function (isStrict, locale) {
       return locale.monthsRegex(isStrict);
   });
</PRE><PRE>   addParseToken(['M', 'MM'], function (input, array) {
       array[MONTH] = toInt(input) - 1;
   });
</PRE><PRE>   addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
       var month = config._locale.monthsParse(input, token, config._strict);
       // if we didn't find a month name, mark the date as invalid.
       if (month != null) {
           array[MONTH] = month;
       } else {
           getParsingFlags(config).invalidMonth = input;
       }
   });
</PRE><PRE>   // LOCALES
</PRE><PRE>   var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
   var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
   function localeMonths (m, format) {
       if (!m) {
           return this._months;
       }
       return isArray(this._months) ? this._months[m.month()] :
           this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
   }
</PRE><PRE>   var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
   function localeMonthsShort (m, format) {
       if (!m) {
           return this._monthsShort;
       }
       return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
           this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
   }
</PRE><PRE>   function units_month__handleStrictParse(monthName, format, strict) {
       var i, ii, mom, llc = monthName.toLocaleLowerCase();
       if (!this._monthsParse) {
           // this is not used
           this._monthsParse = [];
           this._longMonthsParse = [];
           this._shortMonthsParse = [];
           for (i = 0; i &lt; 12; ++i) {
               mom = create_utc__createUTC([2000, i]);
               this._shortMonthsParse[i] = this.monthsShort(mom, <I>).toLocaleLowerCase();</I>
               this._longMonthsParse[i] = this.months(mom, <I>).toLocaleLowerCase();</I>
           }
       }
</PRE><PRE>       if (strict) {
           if (format === 'MMM') {
               ii = indexOf.call(this._shortMonthsParse, llc);
               return ii !== -1 ? ii : null;
           } else {
               ii = indexOf.call(this._longMonthsParse, llc);
               return ii !== -1 ? ii : null;
           }
       } else {
           if (format === 'MMM') {
               ii = indexOf.call(this._shortMonthsParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._longMonthsParse, llc);
               return ii !== -1 ? ii : null;
           } else {
               ii = indexOf.call(this._longMonthsParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._shortMonthsParse, llc);
               return ii !== -1 ? ii : null;
           }
       }
   }
</PRE><PRE>   function localeMonthsParse (monthName, format, strict) {
       var i, mom, regex;
</PRE><PRE>       if (this._monthsParseExact) {
           return units_month__handleStrictParse.call(this, monthName, format, strict);
       }
</PRE><PRE>       if (!this._monthsParse) {
           this._monthsParse = [];
           this._longMonthsParse = [];
           this._shortMonthsParse = [];
       }
</PRE><PRE>       // TODO: add sorting
       // Sorting makes sure if one month (or abbr) is a prefix of another
       // see sorting in computeMonthsParse
       for (i = 0; i &lt; 12; i++) {
           // make the regex if we don't have it already
           mom = create_utc__createUTC([2000, i]);
           if (strict &amp;&amp; !this._longMonthsParse[i]) {
               this._longMonthsParse[i] = new RegExp('^' + this.months(mom, <I>).replace('.', </I>) + '$', 'i');
               this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, <I>).replace('.', </I>) + '$', 'i');
           }
           if (!strict &amp;&amp; !this._monthsParse[i]) {
               regex = '^' + this.months(mom, <I>) + '|^' + this.monthsShort(mom, </I>);
               this._monthsParse[i] = new RegExp(regex.replace('.', <I>), 'i');</I>
           }
           // test the regex
           if (strict &amp;&amp; format === 'MMMM' &amp;&amp; this._longMonthsParse[i].test(monthName)) {
               return i;
           } else if (strict &amp;&amp; format === 'MMM' &amp;&amp; this._shortMonthsParse[i].test(monthName)) {
               return i;
           } else if (!strict &amp;&amp; this._monthsParse[i].test(monthName)) {
               return i;
           }
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function setMonth (mom, value) {
       var dayOfMonth;
</PRE><PRE>       if (!mom.isValid()) {
           // No op
           return mom;
       }
</PRE><PRE>       if (typeof value === 'string') {
           if (/^\d+$/.test(value)) {
               value = toInt(value);
           } else {
               value = mom.localeData().monthsParse(value);
               // TODO: Another silent failure?
               if (typeof value !== 'number') {
                   return mom;
               }
           }
       }
</PRE><PRE>       dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
       mom._d['set' + (mom._isUTC ? 'UTC' : <I>) + 'Month'](value, dayOfMonth);</I>
       return mom;
   }
</PRE><PRE>   function getSetMonth (value) {
       if (value != null) {
           setMonth(this, value);
           utils_hooks__hooks.updateOffset(this, true);
           return this;
       } else {
           return get_set__get(this, 'Month');
       }
   }
</PRE><PRE>   function getDaysInMonth () {
       return daysInMonth(this.year(), this.month());
   }
</PRE><PRE>   var defaultMonthsShortRegex = matchWord;
   function monthsShortRegex (isStrict) {
       if (this._monthsParseExact) {
           if (!hasOwnProp(this, '_monthsRegex')) {
               computeMonthsParse.call(this);
           }
           if (isStrict) {
               return this._monthsShortStrictRegex;
           } else {
               return this._monthsShortRegex;
           }
       } else {
           if (!hasOwnProp(this, '_monthsShortRegex')) {
               this._monthsShortRegex = defaultMonthsShortRegex;
           }
           return this._monthsShortStrictRegex &amp;&amp; isStrict ?
               this._monthsShortStrictRegex : this._monthsShortRegex;
       }
   }
</PRE><PRE>   var defaultMonthsRegex = matchWord;
   function monthsRegex (isStrict) {
       if (this._monthsParseExact) {
           if (!hasOwnProp(this, '_monthsRegex')) {
               computeMonthsParse.call(this);
           }
           if (isStrict) {
               return this._monthsStrictRegex;
           } else {
               return this._monthsRegex;
           }
       } else {
           if (!hasOwnProp(this, '_monthsRegex')) {
               this._monthsRegex = defaultMonthsRegex;
           }
           return this._monthsStrictRegex &amp;&amp; isStrict ?
               this._monthsStrictRegex : this._monthsRegex;
       }
   }
</PRE><PRE>   function computeMonthsParse () {
       function cmpLenRev(a, b) {
           return b.length - a.length;
       }
</PRE><PRE>       var shortPieces = [], longPieces = [], mixedPieces = [],
           i, mom;
       for (i = 0; i &lt; 12; i++) {
           // make the regex if we don't have it already
           mom = create_utc__createUTC([2000, i]);
           shortPieces.push(this.monthsShort(mom, <I>));</I>
           longPieces.push(this.months(mom, <I>));</I>
           mixedPieces.push(this.months(mom, <I>));</I>
           mixedPieces.push(this.monthsShort(mom, <I>));</I>
       }
       // Sorting makes sure if one month (or abbr) is a prefix of another it
       // will match the longer piece.
       shortPieces.sort(cmpLenRev);
       longPieces.sort(cmpLenRev);
       mixedPieces.sort(cmpLenRev);
       for (i = 0; i &lt; 12; i++) {
           shortPieces[i] = regexEscape(shortPieces[i]);
           longPieces[i] = regexEscape(longPieces[i]);
       }
       for (i = 0; i &lt; 24; i++) {
           mixedPieces[i] = regexEscape(mixedPieces[i]);
       }
</PRE><PRE>       this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
       this._monthsShortRegex = this._monthsRegex;
       this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
       this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('Y', 0, 0, function () {
       var y = this.year();
       return y &lt;= 9999 ? <I> + y : '+' + y;</I>
   });
</PRE><PRE>   addFormatToken(0, ['YY', 2], 0, function () {
       return this.year() % 100;
   });
</PRE><PRE>   addFormatToken(0, ['YYYY',   4],       0, 'year');
   addFormatToken(0, ['YYYYY',  5],       0, 'year');
   addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('year', 'y');
</PRE><PRE>   // PRIORITIES
</PRE><PRE>   addUnitPriority('year', 1);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('Y',      matchSigned);
   addRegexToken('YY',     match1to2, match2);
   addRegexToken('YYYY',   match1to4, match4);
   addRegexToken('YYYYY',  match1to6, match6);
   addRegexToken('YYYYYY', match1to6, match6);
</PRE><PRE>   addParseToken(['YYYYY', 'YYYYYY'], YEAR);
   addParseToken('YYYY', function (input, array) {
       array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
   });
   addParseToken('YY', function (input, array) {
       array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
   });
   addParseToken('Y', function (input, array) {
       array[YEAR] = parseInt(input, 10);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   function daysInYear(year) {
       return isLeapYear(year) ? 366 : 365;
   }
</PRE><PRE>   function isLeapYear(year) {
       return (year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0;
   }
</PRE><PRE>   // HOOKS
</PRE><PRE>   utils_hooks__hooks.parseTwoDigitYear = function (input) {
       return toInt(input) + (toInt(input) &gt; 68 ? 1900 : 2000);
   };
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetYear = makeGetSet('FullYear', true);
</PRE><PRE>   function getIsLeapYear () {
       return isLeapYear(this.year());
   }
</PRE><PRE>   function createDate (y, m, d, h, M, s, ms) {
       //can't just apply() to create a date:
       //<A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply">http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply</A>
       var date = new Date(y, m, d, h, M, s, ms);
</PRE><PRE>       //the date constructor remaps years 0-99 to 1900-1999
       if (y &lt; 100 &amp;&amp; y &gt;= 0 &amp;&amp; isFinite(date.getFullYear())) {
           date.setFullYear(y);
       }
       return date;
   }
</PRE><PRE>   function createUTCDate (y) {
       var date = new Date(Date.UTC.apply(null, arguments));
</PRE><PRE>       //the Date.UTC function remaps years 0-99 to 1900-1999
       if (y &lt; 100 &amp;&amp; y &gt;= 0 &amp;&amp; isFinite(date.getUTCFullYear())) {
           date.setUTCFullYear(y);
       }
       return date;
   }
</PRE><PRE>   // start-of-first-week - start-of-year
   function firstWeekOffset(year, dow, doy) {
       var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
           fwd = 7 + dow - doy,
           // first-week day local weekday -- which local weekday is fwd
           fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
</PRE><PRE>       return -fwdlw + fwd - 1;
   }
</PRE><PRE>   //<A rel="nofollow" class="external free" href="http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday">http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday</A>
   function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
       var localWeekday = (7 + weekday - dow) % 7,
           weekOffset = firstWeekOffset(year, dow, doy),
           dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
           resYear, resDayOfYear;
</PRE><PRE>       if (dayOfYear &lt;= 0) {
           resYear = year - 1;
           resDayOfYear = daysInYear(resYear) + dayOfYear;
       } else if (dayOfYear &gt; daysInYear(year)) {
           resYear = year + 1;
           resDayOfYear = dayOfYear - daysInYear(year);
       } else {
           resYear = year;
           resDayOfYear = dayOfYear;
       }
</PRE><PRE>       return {
           year: resYear,
           dayOfYear: resDayOfYear
       };
   }
</PRE><PRE>   function weekOfYear(mom, dow, doy) {
       var weekOffset = firstWeekOffset(mom.year(), dow, doy),
           week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
           resWeek, resYear;
</PRE><PRE>       if (week &lt; 1) {
           resYear = mom.year() - 1;
           resWeek = week + weeksInYear(resYear, dow, doy);
       } else if (week &gt; weeksInYear(mom.year(), dow, doy)) {
           resWeek = week - weeksInYear(mom.year(), dow, doy);
           resYear = mom.year() + 1;
       } else {
           resYear = mom.year();
           resWeek = week;
       }
</PRE><PRE>       return {
           week: resWeek,
           year: resYear
       };
   }
</PRE><PRE>   function weeksInYear(year, dow, doy) {
       var weekOffset = firstWeekOffset(year, dow, doy),
           weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
       return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('w', ['ww', 2], 'wo', 'week');
   addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('week', 'w');
   addUnitAlias('isoWeek', 'W');
</PRE><PRE>   // PRIORITIES
</PRE><PRE>   addUnitPriority('week', 5);
   addUnitPriority('isoWeek', 5);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('w',  match1to2);
   addRegexToken('ww', match1to2, match2);
   addRegexToken('W',  match1to2);
   addRegexToken('WW', match1to2, match2);
</PRE><PRE>   addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
       week[token.substr(0, 1)] = toInt(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   // LOCALES
</PRE><PRE>   function localeWeek (mom) {
       return weekOfYear(mom, this._week.dow, this._week.doy).week;
   }
</PRE><PRE>   var defaultLocaleWeek = {
       dow : 0, // Sunday is the first day of the week.
       doy : 6  // The week that contains Jan 1st is the first week of the year.
   };
</PRE><PRE>   function localeFirstDayOfWeek () {
       return this._week.dow;
   }
</PRE><PRE>   function localeFirstDayOfYear () {
       return this._week.doy;
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetWeek (input) {
       var week = this.localeData().week(this);
       return input == null ? week : this.add((input - week) * 7, 'd');
   }
</PRE><PRE>   function getSetISOWeek (input) {
       var week = weekOfYear(this, 1, 4).week;
       return input == null ? week : this.add((input - week) * 7, 'd');
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('d', 0, 'do', 'day');
</PRE><PRE>   addFormatToken('dd', 0, 0, function (format) {
       return this.localeData().weekdaysMin(this, format);
   });
</PRE><PRE>   addFormatToken('ddd', 0, 0, function (format) {
       return this.localeData().weekdaysShort(this, format);
   });
</PRE><PRE>   addFormatToken('dddd', 0, 0, function (format) {
       return this.localeData().weekdays(this, format);
   });
</PRE><PRE>   addFormatToken('e', 0, 0, 'weekday');
   addFormatToken('E', 0, 0, 'isoWeekday');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('day', 'd');
   addUnitAlias('weekday', 'e');
   addUnitAlias('isoWeekday', 'E');
</PRE><PRE>   // PRIORITY
   addUnitPriority('day', 11);
   addUnitPriority('weekday', 11);
   addUnitPriority('isoWeekday', 11);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('d',    match1to2);
   addRegexToken('e',    match1to2);
   addRegexToken('E',    match1to2);
   addRegexToken('dd',   function (isStrict, locale) {
       return locale.weekdaysMinRegex(isStrict);
   });
   addRegexToken('ddd',   function (isStrict, locale) {
       return locale.weekdaysShortRegex(isStrict);
   });
   addRegexToken('dddd',   function (isStrict, locale) {
       return locale.weekdaysRegex(isStrict);
   });
</PRE><PRE>   addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
       var weekday = config._locale.weekdaysParse(input, token, config._strict);
       // if we didn't get a weekday name, mark the date as invalid
       if (weekday != null) {
           week.d = weekday;
       } else {
           getParsingFlags(config).invalidWeekday = input;
       }
   });
</PRE><PRE>   addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
       week[token] = toInt(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   function parseWeekday(input, locale) {
       if (typeof input !== 'string') {
           return input;
       }
</PRE><PRE>       if (!isNaN(input)) {
           return parseInt(input, 10);
       }
</PRE><PRE>       input = locale.weekdaysParse(input);
       if (typeof input === 'number') {
           return input;
       }
</PRE><PRE>       return null;
   }
</PRE><PRE>   function parseIsoWeekday(input, locale) {
       if (typeof input === 'string') {
           return locale.weekdaysParse(input) % 7 || 7;
       }
       return isNaN(input) ? null : input;
   }
</PRE><PRE>   // LOCALES
</PRE><PRE>   var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
   function localeWeekdays (m, format) {
       if (!m) {
           return this._weekdays;
       }
       return isArray(this._weekdays) ? this._weekdays[m.day()] :
           this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
   }
</PRE><PRE>   var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
   function localeWeekdaysShort (m) {
       return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
   }
</PRE><PRE>   var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
   function localeWeekdaysMin (m) {
       return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
   }
</PRE><PRE>   function day_of_week__handleStrictParse(weekdayName, format, strict) {
       var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
       if (!this._weekdaysParse) {
           this._weekdaysParse = [];
           this._shortWeekdaysParse = [];
           this._minWeekdaysParse = [];
</PRE><PRE>           for (i = 0; i &lt; 7; ++i) {
               mom = create_utc__createUTC([2000, 1]).day(i);
               this._minWeekdaysParse[i] = this.weekdaysMin(mom, <I>).toLocaleLowerCase();</I>
               this._shortWeekdaysParse[i] = this.weekdaysShort(mom, <I>).toLocaleLowerCase();</I>
               this._weekdaysParse[i] = this.weekdays(mom, <I>).toLocaleLowerCase();</I>
           }
       }
</PRE><PRE>       if (strict) {
           if (format === 'dddd') {
               ii = indexOf.call(this._weekdaysParse, llc);
               return ii !== -1 ? ii : null;
           } else if (format === 'ddd') {
               ii = indexOf.call(this._shortWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           } else {
               ii = indexOf.call(this._minWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           }
       } else {
           if (format === 'dddd') {
               ii = indexOf.call(this._weekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._shortWeekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._minWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           } else if (format === 'ddd') {
               ii = indexOf.call(this._shortWeekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._weekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._minWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           } else {
               ii = indexOf.call(this._minWeekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._weekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._shortWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           }
       }
   }
</PRE><PRE>   function localeWeekdaysParse (weekdayName, format, strict) {
       var i, mom, regex;
</PRE><PRE>       if (this._weekdaysParseExact) {
           return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
       }
</PRE><PRE>       if (!this._weekdaysParse) {
           this._weekdaysParse = [];
           this._minWeekdaysParse = [];
           this._shortWeekdaysParse = [];
           this._fullWeekdaysParse = [];
       }
</PRE><PRE>       for (i = 0; i &lt; 7; i++) {
           // make the regex if we don't have it already
</PRE><PRE>           mom = create_utc__createUTC([2000, 1]).day(i);
           if (strict &amp;&amp; !this._fullWeekdaysParse[i]) {
               this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, <I>).replace('.', '\.?') + '$', 'i');</I>
               this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, <I>).replace('.', '\.?') + '$', 'i');</I>
               this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, <I>).replace('.', '\.?') + '$', 'i');</I>
           }
           if (!this._weekdaysParse[i]) {
               regex = '^' + this.weekdays(mom, <I>) + '|^' + this.weekdaysShort(mom, </I>) + '|^' + this.weekdaysMin(mom, <I>);</I>
               this._weekdaysParse[i] = new RegExp(regex.replace('.', <I>), 'i');</I>
           }
           // test the regex
           if (strict &amp;&amp; format === 'dddd' &amp;&amp; this._fullWeekdaysParse[i].test(weekdayName)) {
               return i;
           } else if (strict &amp;&amp; format === 'ddd' &amp;&amp; this._shortWeekdaysParse[i].test(weekdayName)) {
               return i;
           } else if (strict &amp;&amp; format === 'dd' &amp;&amp; this._minWeekdaysParse[i].test(weekdayName)) {
               return i;
           } else if (!strict &amp;&amp; this._weekdaysParse[i].test(weekdayName)) {
               return i;
           }
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetDayOfWeek (input) {
       if (!this.isValid()) {
           return input != null ? this : NaN;
       }
       var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
       if (input != null) {
           input = parseWeekday(input, this.localeData());
           return this.add(input - day, 'd');
       } else {
           return day;
       }
   }
</PRE><PRE>   function getSetLocaleDayOfWeek (input) {
       if (!this.isValid()) {
           return input != null ? this : NaN;
       }
       var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
       return input == null ? weekday : this.add(input - weekday, 'd');
   }
</PRE><PRE>   function getSetISODayOfWeek (input) {
       if (!this.isValid()) {
           return input != null ? this : NaN;
       }
</PRE><PRE>       // behaves the same as moment#day except
       // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
       // as a setter, sunday should belong to the previous week.
</PRE><PRE>       if (input != null) {
           var weekday = parseIsoWeekday(input, this.localeData());
           return this.day(this.day() % 7 ? weekday : weekday - 7);
       } else {
           return this.day() || 7;
       }
   }
</PRE><PRE>   var defaultWeekdaysRegex = matchWord;
   function weekdaysRegex (isStrict) {
       if (this._weekdaysParseExact) {
           if (!hasOwnProp(this, '_weekdaysRegex')) {
               computeWeekdaysParse.call(this);
           }
           if (isStrict) {
               return this._weekdaysStrictRegex;
           } else {
               return this._weekdaysRegex;
           }
       } else {
           if (!hasOwnProp(this, '_weekdaysRegex')) {
               this._weekdaysRegex = defaultWeekdaysRegex;
           }
           return this._weekdaysStrictRegex &amp;&amp; isStrict ?
               this._weekdaysStrictRegex : this._weekdaysRegex;
       }
   }
</PRE><PRE>   var defaultWeekdaysShortRegex = matchWord;
   function weekdaysShortRegex (isStrict) {
       if (this._weekdaysParseExact) {
           if (!hasOwnProp(this, '_weekdaysRegex')) {
               computeWeekdaysParse.call(this);
           }
           if (isStrict) {
               return this._weekdaysShortStrictRegex;
           } else {
               return this._weekdaysShortRegex;
           }
       } else {
           if (!hasOwnProp(this, '_weekdaysShortRegex')) {
               this._weekdaysShortRegex = defaultWeekdaysShortRegex;
           }
           return this._weekdaysShortStrictRegex &amp;&amp; isStrict ?
               this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
       }
   }
</PRE><PRE>   var defaultWeekdaysMinRegex = matchWord;
   function weekdaysMinRegex (isStrict) {
       if (this._weekdaysParseExact) {
           if (!hasOwnProp(this, '_weekdaysRegex')) {
               computeWeekdaysParse.call(this);
           }
           if (isStrict) {
               return this._weekdaysMinStrictRegex;
           } else {
               return this._weekdaysMinRegex;
           }
       } else {
           if (!hasOwnProp(this, '_weekdaysMinRegex')) {
               this._weekdaysMinRegex = defaultWeekdaysMinRegex;
           }
           return this._weekdaysMinStrictRegex &amp;&amp; isStrict ?
               this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
       }
   }
</PRE><PRE>   function computeWeekdaysParse () {
       function cmpLenRev(a, b) {
           return b.length - a.length;
       }
</PRE><PRE>       var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
           i, mom, minp, shortp, longp;
       for (i = 0; i &lt; 7; i++) {
           // make the regex if we don't have it already
           mom = create_utc__createUTC([2000, 1]).day(i);
           minp = this.weekdaysMin(mom, <I>);</I>
           shortp = this.weekdaysShort(mom, <I>);</I>
           longp = this.weekdays(mom, <I>);</I>
           minPieces.push(minp);
           shortPieces.push(shortp);
           longPieces.push(longp);
           mixedPieces.push(minp);
           mixedPieces.push(shortp);
           mixedPieces.push(longp);
       }
       // Sorting makes sure if one weekday (or abbr) is a prefix of another it
       // will match the longer piece.
       minPieces.sort(cmpLenRev);
       shortPieces.sort(cmpLenRev);
       longPieces.sort(cmpLenRev);
       mixedPieces.sort(cmpLenRev);
       for (i = 0; i &lt; 7; i++) {
           shortPieces[i] = regexEscape(shortPieces[i]);
           longPieces[i] = regexEscape(longPieces[i]);
           mixedPieces[i] = regexEscape(mixedPieces[i]);
       }
</PRE><PRE>       this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
       this._weekdaysShortRegex = this._weekdaysRegex;
       this._weekdaysMinRegex = this._weekdaysRegex;
</PRE><PRE>       this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
       this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
       this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   function hFormat() {
       return this.hours() % 12 || 12;
   }
</PRE><PRE>   function kFormat() {
       return this.hours() || 24;
   }
</PRE><PRE>   addFormatToken('H', ['HH', 2], 0, 'hour');
   addFormatToken('h', ['hh', 2], 0, hFormat);
   addFormatToken('k', ['kk', 2], 0, kFormat);
</PRE><PRE>   addFormatToken('hmm', 0, 0, function () {
       return <I> + hFormat.apply(this) + zeroFill(this.minutes(), 2);</I>
   });
</PRE><PRE>   addFormatToken('hmmss', 0, 0, function () {
       return <I> + hFormat.apply(this) + zeroFill(this.minutes(), 2) +</I>
           zeroFill(this.seconds(), 2);
   });
</PRE><PRE>   addFormatToken('Hmm', 0, 0, function () {
       return <I> + this.hours() + zeroFill(this.minutes(), 2);</I>
   });
</PRE><PRE>   addFormatToken('Hmmss', 0, 0, function () {
       return <I> + this.hours() + zeroFill(this.minutes(), 2) +</I>
           zeroFill(this.seconds(), 2);
   });
</PRE><PRE>   function meridiem (token, lowercase) {
       addFormatToken(token, 0, 0, function () {
           return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
       });
   }
</PRE><PRE>   meridiem('a', true);
   meridiem('A', false);
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('hour', 'h');
</PRE><PRE>   // PRIORITY
   addUnitPriority('hour', 13);
</PRE><PRE>   // PARSING
</PRE><PRE>   function matchMeridiem (isStrict, locale) {
       return locale._meridiemParse;
   }
</PRE><PRE>   addRegexToken('a',  matchMeridiem);
   addRegexToken('A',  matchMeridiem);
   addRegexToken('H',  match1to2);
   addRegexToken('h',  match1to2);
   addRegexToken('HH', match1to2, match2);
   addRegexToken('hh', match1to2, match2);
</PRE><PRE>   addRegexToken('hmm', match3to4);
   addRegexToken('hmmss', match5to6);
   addRegexToken('Hmm', match3to4);
   addRegexToken('Hmmss', match5to6);
</PRE><PRE>   addParseToken(['H', 'HH'], HOUR);
   addParseToken(['a', 'A'], function (input, array, config) {
       config._isPm = config._locale.isPM(input);
       config._meridiem = input;
   });
   addParseToken(['h', 'hh'], function (input, array, config) {
       array[HOUR] = toInt(input);
       getParsingFlags(config).bigHour = true;
   });
   addParseToken('hmm', function (input, array, config) {
       var pos = input.length - 2;
       array[HOUR] = toInt(input.substr(0, pos));
       array[MINUTE] = toInt(input.substr(pos));
       getParsingFlags(config).bigHour = true;
   });
   addParseToken('hmmss', function (input, array, config) {
       var pos1 = input.length - 4;
       var pos2 = input.length - 2;
       array[HOUR] = toInt(input.substr(0, pos1));
       array[MINUTE] = toInt(input.substr(pos1, 2));
       array[SECOND] = toInt(input.substr(pos2));
       getParsingFlags(config).bigHour = true;
   });
   addParseToken('Hmm', function (input, array, config) {
       var pos = input.length - 2;
       array[HOUR] = toInt(input.substr(0, pos));
       array[MINUTE] = toInt(input.substr(pos));
   });
   addParseToken('Hmmss', function (input, array, config) {
       var pos1 = input.length - 4;
       var pos2 = input.length - 2;
       array[HOUR] = toInt(input.substr(0, pos1));
       array[MINUTE] = toInt(input.substr(pos1, 2));
       array[SECOND] = toInt(input.substr(pos2));
   });
</PRE><PRE>   // LOCALES
</PRE><PRE>   function localeIsPM (input) {
       // IE8 Quirks Mode &amp; IE7 Standards Mode do not allow accessing strings like arrays
       // Using charAt should be more compatible.
       return ((input + <I>).toLowerCase().charAt(0) === 'p');</I>
   }
</PRE><PRE>   var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
   function localeMeridiem (hours, minutes, isLower) {
       if (hours &gt; 11) {
           return isLower ? 'pm' : 'PM';
       } else {
           return isLower ? 'am' : 'AM';
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   // Setting the hour should keep the time, because the user explicitly
   // specified which hour he wants. So trying to maintain the same hour (in
   // a new timezone) makes sense. Adding/subtracting hours does not follow
   // this rule.
   var getSetHour = makeGetSet('Hours', true);
</PRE><PRE>   var baseConfig = {
       calendar: defaultCalendar,
       longDateFormat: defaultLongDateFormat,
       invalidDate: defaultInvalidDate,
       ordinal: defaultOrdinal,
       ordinalParse: defaultOrdinalParse,
       relativeTime: defaultRelativeTime,
</PRE><PRE>       months: defaultLocaleMonths,
       monthsShort: defaultLocaleMonthsShort,
</PRE><PRE>       week: defaultLocaleWeek,
</PRE><PRE>       weekdays: defaultLocaleWeekdays,
       weekdaysMin: defaultLocaleWeekdaysMin,
       weekdaysShort: defaultLocaleWeekdaysShort,
</PRE><PRE>       meridiemParse: defaultLocaleMeridiemParse
   };
</PRE><PRE>   // internal storage for locale config files
   var locales = {};
   var globalLocale;
</PRE><PRE>   function normalizeLocale(key) {
       return key ? key.toLowerCase().replace('_', '-') : key;
   }
</PRE><PRE>   // pick the locale from the array
   // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
   // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
   function chooseLocale(names) {
       var i = 0, j, next, locale, split;
</PRE><PRE>       while (i &lt; names.length) {
           split = normalizeLocale(names[i]).split('-');
           j = split.length;
           next = normalizeLocale(names[i + 1]);
           next = next ? next.split('-') : null;
           while (j &gt; 0) {
               locale = loadLocale(split.slice(0, j).join('-'));
               if (locale) {
                   return locale;
               }
               if (next &amp;&amp; next.length &gt;= j &amp;&amp; compareArrays(split, next, true) &gt;= j - 1) {
                   //the next array item is better than a shallower substring of this one
                   break;
               }
               j--;
           }
           i++;
       }
       return null;
   }
</PRE><PRE>   function loadLocale(name) {
       var oldLocale = null;
       // TODO: Find a better way to register and load all the locales in Node
       if (!locales[name] &amp;&amp; (typeof module !== 'undefined') &amp;&amp;
               module &amp;&amp; module.exports) {
           try {
               oldLocale = globalLocale._abbr;
               require('./locale/' + name);
               // because defineLocale currently also sets the global locale, we
               // want to undo that for lazy loaded locales
               locale_locales__getSetGlobalLocale(oldLocale);
           } catch (e) { }
       }
       return locales[name];
   }
</PRE><PRE>   // This function will load locale and then set the global locale.  If
   // no arguments are passed in, it will simply return the current global
   // locale key.
   function locale_locales__getSetGlobalLocale (key, values) {
       var data;
       if (key) {
           if (isUndefined(values)) {
               data = locale_locales__getLocale(key);
           }
           else {
               data = defineLocale(key, values);
           }
</PRE><PRE>           if (data) {
               // moment.duration._locale = moment._locale = data;
               globalLocale = data;
           }
       }
</PRE><PRE>       return globalLocale._abbr;
   }
</PRE><PRE>   function defineLocale (name, config) {
       if (config !== null) {
           var parentConfig = baseConfig;
           config.abbr = name;
           if (locales[name] != null) {
               deprecateSimple('defineLocaleOverride',
                       'use moment.updateLocale(localeName, config) to change ' +
                       'an existing locale. moment.defineLocale(localeName, ' +
                       'config) should only be used for creating a new locale ' +
                       'See <A rel="nofollow" class="external free" href="http://momentjs.com/guides/#/warnings/define-locale/">http://momentjs.com/guides/#/warnings/define-locale/</A> for more info.');
               parentConfig = locales[name]._config;
           } else if (config.parentLocale != null) {
               if (locales[config.parentLocale] != null) {
                   parentConfig = locales[config.parentLocale]._config;
               } else {
                   // treat as if there is no base config
                   deprecateSimple('parentLocaleUndefined',
                           'specified parentLocale is not defined yet. See <A rel="nofollow" class="external free" href="http://momentjs.com/guides/#/warnings/parent-locale/'">http://momentjs.com/guides/#/warnings/parent-locale/'</A>);
               }
           }
           locales[name] = new Locale(mergeConfigs(parentConfig, config));
</PRE><PRE>           // backwards compat for now: also set the locale
           locale_locales__getSetGlobalLocale(name);
</PRE><PRE>           return locales[name];
       } else {
           // useful for testing
           delete locales[name];
           return null;
       }
   }
</PRE><PRE>   function updateLocale(name, config) {
       if (config != null) {
           var locale, parentConfig = baseConfig;
           // MERGE
           if (locales[name] != null) {
               parentConfig = locales[name]._config;
           }
           config = mergeConfigs(parentConfig, config);
           locale = new Locale(config);
           locale.parentLocale = locales[name];
           locales[name] = locale;
</PRE><PRE>           // backwards compat for now: also set the locale
           locale_locales__getSetGlobalLocale(name);
       } else {
           // pass null for config to unupdate, useful for tests
           if (locales[name] != null) {
               if (locales[name].parentLocale != null) {
                   locales[name] = locales[name].parentLocale;
               } else if (locales[name] != null) {
                   delete locales[name];
               }
           }
       }
       return locales[name];
   }
</PRE><PRE>   // returns locale data
   function locale_locales__getLocale (key) {
       var locale;
</PRE><PRE>       if (key &amp;&amp; key._locale &amp;&amp; key._locale._abbr) {
           key = key._locale._abbr;
       }
</PRE><PRE>       if (!key) {
           return globalLocale;
       }
</PRE><PRE>       if (!isArray(key)) {
           //short-circuit everything else
           locale = loadLocale(key);
           if (locale) {
               return locale;
           }
           key = [key];
       }
</PRE><PRE>       return chooseLocale(key);
   }
</PRE><PRE>   function locale_locales__listLocales() {
       return keys(locales);
   }
</PRE><PRE>   function checkOverflow (m) {
       var overflow;
       var a = m._a;
</PRE><PRE>       if (a &amp;&amp; getParsingFlags(m).overflow === -2) {
           overflow =
               a[MONTH]       &lt; 0 || a[MONTH]       &gt; 11  ? MONTH :
               a[DATE]        &lt; 1 || a[DATE]        &gt; daysInMonth(a[YEAR], a[MONTH]) ? DATE :
               a[HOUR]        &lt; 0 || a[HOUR]        &gt; 24 || (a[HOUR] === 24 &amp;&amp; (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
               a[MINUTE]      &lt; 0 || a[MINUTE]      &gt; 59  ? MINUTE :
               a[SECOND]      &lt; 0 || a[SECOND]      &gt; 59  ? SECOND :
               a[MILLISECOND] &lt; 0 || a[MILLISECOND] &gt; 999 ? MILLISECOND :
               -1;
</PRE><PRE>           if (getParsingFlags(m)._overflowDayOfYear &amp;&amp; (overflow &lt; YEAR || overflow &gt; DATE)) {
               overflow = DATE;
           }
           if (getParsingFlags(m)._overflowWeeks &amp;&amp; overflow === -1) {
               overflow = WEEK;
           }
           if (getParsingFlags(m)._overflowWeekday &amp;&amp; overflow === -1) {
               overflow = WEEKDAY;
           }
</PRE><PRE>           getParsingFlags(m).overflow = overflow;
       }
</PRE><PRE>       return m;
   }
</PRE><PRE>   // iso 8601 regex
   // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
   var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
   var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
</PRE><PRE>   var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
</PRE><PRE>   var isoDates = [
       ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
       ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
       ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
       ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
       ['YYYY-DDD', /\d{4}-\d{3}/],
       ['YYYY-MM', /\d{4}-\d\d/, false],
       ['YYYYYYMMDD', /[+-]\d{10}/],
       ['YYYYMMDD', /\d{8}/],
       // YYYYMM is NOT allowed by the standard
       ['GGGG[W]WWE', /\d{4}W\d{3}/],
       ['GGGG[W]WW', /\d{4}W\d{2}/, false],
       ['YYYYDDD', /\d{7}/]
   ];
</PRE><PRE>   // iso time formats and regexes
   var isoTimes = [
       ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
       ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
       ['HH:mm:ss', /\d\d:\d\d:\d\d/],
       ['HH:mm', /\d\d:\d\d/],
       ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
       ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
       ['HHmmss', /\d\d\d\d\d\d/],
       ['HHmm', /\d\d\d\d/],
       ['HH', /\d\d/]
   ];
</PRE><PRE>   var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
</PRE><PRE>   // date from iso format
   function configFromISO(config) {
       var i, l,
           string = config._i,
           match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
           allowTime, dateFormat, timeFormat, tzFormat;
</PRE><PRE>       if (match) {
           getParsingFlags(config).iso = true;
</PRE><PRE>           for (i = 0, l = isoDates.length; i &lt; l; i++) {
               if (isoDates[i][1].exec(match[1])) {
                   dateFormat = isoDates[i][0];
                   allowTime = isoDates[i][2] !== false;
                   break;
               }
           }
           if (dateFormat == null) {
               config._isValid = false;
               return;
           }
           if (match[3]) {
               for (i = 0, l = isoTimes.length; i &lt; l; i++) {
                   if (isoTimes[i][1].exec(match[3])) {
                       // match[2] should be 'T' or space
                       timeFormat = (match[2] || ' ') + isoTimes[i][0];
                       break;
                   }
               }
               if (timeFormat == null) {
                   config._isValid = false;
                   return;
               }
           }
           if (!allowTime &amp;&amp; timeFormat != null) {
               config._isValid = false;
               return;
           }
           if (match[4]) {
               if (tzRegex.exec(match[4])) {
                   tzFormat = 'Z';
               } else {
                   config._isValid = false;
                   return;
               }
           }
           config._f = dateFormat + (timeFormat || <I>) + (tzFormat || </I>);
           configFromStringAndFormat(config);
       } else {
           config._isValid = false;
       }
   }
</PRE><PRE>   // date from iso format or fallback
   function configFromString(config) {
       var matched = aspNetJsonRegex.exec(config._i);
</PRE><PRE>       if (matched !== null) {
           config._d = new Date(+matched[1]);
           return;
       }
</PRE><PRE>       configFromISO(config);
       if (config._isValid === false) {
           delete config._isValid;
           utils_hooks__hooks.createFromInputFallback(config);
       }
   }
</PRE><PRE>   utils_hooks__hooks.createFromInputFallback = deprecate(
       'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
       'which is not reliable across all browsers and versions. Non ISO date formats are ' +
       'discouraged and will be removed in an upcoming major release. Please refer to ' +
       '<A rel="nofollow" class="external free" href="http://momentjs.com/guides/#/warnings/js-date/">http://momentjs.com/guides/#/warnings/js-date/</A> for more info.',
       function (config) {
           config._d = new Date(config._i + (config._useUTC ? ' UTC' : <I>));</I>
       }
   );
</PRE><PRE>   // Pick the first defined of two or three arguments.
   function defaults(a, b, c) {
       if (a != null) {
           return a;
       }
       if (b != null) {
           return b;
       }
       return c;
   }
</PRE><PRE>   function currentDateArray(config) {
       // hooks is actually the exported moment object
       var nowValue = new Date(utils_hooks__hooks.now());
       if (config._useUTC) {
           return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
       }
       return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
   }
</PRE><PRE>   // convert an array to a date.
   // the array should mirror the parameters below
   // note: all values past the year are optional and will default to the lowest possible value.
   // [year, month, day , hour, minute, second, millisecond]
   function configFromArray (config) {
       var i, date, input = [], currentDate, yearToUse;
</PRE><PRE>       if (config._d) {
           return;
       }
</PRE><PRE>       currentDate = currentDateArray(config);
</PRE><PRE>       //compute day of the year from weeks and weekdays
       if (config._w &amp;&amp; config._a[DATE] == null &amp;&amp; config._a[MONTH] == null) {
           dayOfYearFromWeekInfo(config);
       }
</PRE><PRE>       //if the day of the year is set, figure out what it is
       if (config._dayOfYear) {
           yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
</PRE><PRE>           if (config._dayOfYear &gt; daysInYear(yearToUse)) {
               getParsingFlags(config)._overflowDayOfYear = true;
           }
</PRE><PRE>           date = createUTCDate(yearToUse, 0, config._dayOfYear);
           config._a[MONTH] = date.getUTCMonth();
           config._a[DATE] = date.getUTCDate();
       }
</PRE><PRE>       // Default to current date.
       // * if no year, month, day of month are given, default to today
       // * if day of month is given, default month and year
       // * if month is given, default only year
       // * if year is given, don't default anything
       for (i = 0; i &lt; 3 &amp;&amp; config._a[i] == null; ++i) {
           config._a[i] = input[i] = currentDate[i];
       }
</PRE><PRE>       // Zero out whatever was not defaulted, including time
       for (; i &lt; 7; i++) {
           config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
       }
</PRE><PRE>       // Check for 24:00:00.000
       if (config._a[HOUR] === 24 &amp;&amp;
               config._a[MINUTE] === 0 &amp;&amp;
               config._a[SECOND] === 0 &amp;&amp;
               config._a[MILLISECOND] === 0) {
           config._nextDay = true;
           config._a[HOUR] = 0;
       }
</PRE><PRE>       config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
       // Apply timezone offset from input. The actual utcOffset can be changed
       // with parseZone.
       if (config._tzm != null) {
           config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
       }
</PRE><PRE>       if (config._nextDay) {
           config._a[HOUR] = 24;
       }
   }
</PRE><PRE>   function dayOfYearFromWeekInfo(config) {
       var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
</PRE><PRE>       w = config._w;
       if (w.GG != null || w.W != null || w.E != null) {
           dow = 1;
           doy = 4;
</PRE><PRE>           // TODO: We need to take the current isoWeekYear, but that depends on
           // how we interpret now (local, utc, fixed offset). So create
           // a now version of current config (take local/utc/offset flags, and
           // create now).
           weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
           week = defaults(w.W, 1);
           weekday = defaults(w.E, 1);
           if (weekday &lt; 1 || weekday &gt; 7) {
               weekdayOverflow = true;
           }
       } else {
           dow = config._locale._week.dow;
           doy = config._locale._week.doy;
</PRE><PRE>           weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
           week = defaults(w.w, 1);
</PRE><PRE>           if (w.d != null) {
               // weekday -- low day numbers are considered next week
               weekday = w.d;
               if (weekday &lt; 0 || weekday &gt; 6) {
                   weekdayOverflow = true;
               }
           } else if (w.e != null) {
               // local weekday -- counting starts from begining of week
               weekday = w.e + dow;
               if (w.e &lt; 0 || w.e &gt; 6) {
                   weekdayOverflow = true;
               }
           } else {
               // default to begining of week
               weekday = dow;
           }
       }
       if (week &lt; 1 || week &gt; weeksInYear(weekYear, dow, doy)) {
           getParsingFlags(config)._overflowWeeks = true;
       } else if (weekdayOverflow != null) {
           getParsingFlags(config)._overflowWeekday = true;
       } else {
           temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
           config._a[YEAR] = temp.year;
           config._dayOfYear = temp.dayOfYear;
       }
   }
</PRE><PRE>   // constant that refers to the ISO standard
   utils_hooks__hooks.ISO_8601 = function () {};
</PRE><PRE>   // date from string and format string
   function configFromStringAndFormat(config) {
       // TODO: Move this to another part of the creation flow to prevent circular deps
       if (config._f === utils_hooks__hooks.ISO_8601) {
           configFromISO(config);
           return;
       }
</PRE><PRE>       config._a = [];
       getParsingFlags(config).empty = true;
</PRE><PRE>       // This array is used to make a Date, either with `new Date` or `Date.UTC`
       var string = <I> + config._i,</I>
           i, parsedInput, tokens, token, skipped,
           stringLength = string.length,
           totalParsedInputLength = 0;
</PRE><PRE>       tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
</PRE><PRE>       for (i = 0; i &lt; tokens.length; i++) {
           token = tokens[i];
           parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
           // console.log('token', token, 'parsedInput', parsedInput,
           //         'regex', getParseRegexForToken(token, config));
           if (parsedInput) {
               skipped = string.substr(0, string.indexOf(parsedInput));
               if (skipped.length &gt; 0) {
                   getParsingFlags(config).unusedInput.push(skipped);
               }
               string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
               totalParsedInputLength += parsedInput.length;
           }
           // don't parse if it's not a known token
           if (formatTokenFunctions[token]) {
               if (parsedInput) {
                   getParsingFlags(config).empty = false;
               }
               else {
                   getParsingFlags(config).unusedTokens.push(token);
               }
               addTimeToArrayFromToken(token, parsedInput, config);
           }
           else if (config._strict &amp;&amp; !parsedInput) {
               getParsingFlags(config).unusedTokens.push(token);
           }
       }
</PRE><PRE>       // add remaining unparsed input length to the string
       getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
       if (string.length &gt; 0) {
           getParsingFlags(config).unusedInput.push(string);
       }
</PRE><PRE>       // clear _12h flag if hour is &lt;= 12
       if (config._a[HOUR] &lt;= 12 &amp;&amp;
           getParsingFlags(config).bigHour === true &amp;&amp;
           config._a[HOUR] &gt; 0) {
           getParsingFlags(config).bigHour = undefined;
       }
</PRE><PRE>       getParsingFlags(config).parsedDateParts = config._a.slice(0);
       getParsingFlags(config).meridiem = config._meridiem;
       // handle meridiem
       config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
</PRE><PRE>       configFromArray(config);
       checkOverflow(config);
   }
</PRE><PRE>   function meridiemFixWrap (locale, hour, meridiem) {
       var isPm;
</PRE><PRE>       if (meridiem == null) {
           // nothing to do
           return hour;
       }
       if (locale.meridiemHour != null) {
           return locale.meridiemHour(hour, meridiem);
       } else if (locale.isPM != null) {
           // Fallback
           isPm = locale.isPM(meridiem);
           if (isPm &amp;&amp; hour &lt; 12) {
               hour += 12;
           }
           if (!isPm &amp;&amp; hour === 12) {
               hour = 0;
           }
           return hour;
       } else {
           // this is not supposed to happen
           return hour;
       }
   }
</PRE><PRE>   // date from string and array of format strings
   function configFromStringAndArray(config) {
       var tempConfig,
           bestMoment,
</PRE><PRE>           scoreToBeat,
           i,
           currentScore;
</PRE><PRE>       if (config._f.length === 0) {
           getParsingFlags(config).invalidFormat = true;
           config._d = new Date(NaN);
           return;
       }
</PRE><PRE>       for (i = 0; i &lt; config._f.length; i++) {
           currentScore = 0;
           tempConfig = copyConfig({}, config);
           if (config._useUTC != null) {
               tempConfig._useUTC = config._useUTC;
           }
           tempConfig._f = config._f[i];
           configFromStringAndFormat(tempConfig);
</PRE><PRE>           if (!valid__isValid(tempConfig)) {
               continue;
           }
</PRE><PRE>           // if there is any input that was not parsed add a penalty for that format
           currentScore += getParsingFlags(tempConfig).charsLeftOver;
</PRE><PRE>           //or tokens
           currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
</PRE><PRE>           getParsingFlags(tempConfig).score = currentScore;
</PRE><PRE>if (scoreToBeat == null || currentScore &lt; scoreToBeat) {
               scoreToBeat = currentScore;
               bestMoment = tempConfig;
           }
       }
</PRE><PRE>       extend(config, bestMoment || tempConfig);
   }
</PRE><PRE>   function configFromObject(config) {
       if (config._d) {
           return;
       }
</PRE><PRE>       var i = normalizeObjectUnits(config._i);
       config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
           return obj &amp;&amp; parseInt(obj, 10);
       });
</PRE><PRE>       configFromArray(config);
   }
</PRE><PRE>   function createFromConfig (config) {
       var res = new Moment(checkOverflow(prepareConfig(config)));
       if (res._nextDay) {
           // Adding is smart enough around DST
           res.add(1, 'd');
           res._nextDay = undefined;
       }
</PRE><PRE>       return res;
   }
</PRE><PRE>   function prepareConfig (config) {
       var input = config._i,
           format = config._f;
</PRE><PRE>       config._locale = config._locale || locale_locales__getLocale(config._l);
</PRE><PRE>       if (input === null || (format === undefined &amp;&amp; input === <I>)) {</I>
           return valid__createInvalid({nullInput: true});
       }
</PRE><PRE>       if (typeof input === 'string') {
           config._i = input = config._locale.preparse(input);
       }
</PRE><PRE>       if (isMoment(input)) {
           return new Moment(checkOverflow(input));
       } else if (isArray(format)) {
           configFromStringAndArray(config);
       } else if (isDate(input)) {
           config._d = input;
       } else if (format) {
           configFromStringAndFormat(config);
       }  else {
           configFromInput(config);
       }
</PRE><PRE>       if (!valid__isValid(config)) {
           config._d = null;
       }
</PRE><PRE>       return config;
   }
</PRE><PRE>   function configFromInput(config) {
       var input = config._i;
       if (input === undefined) {
           config._d = new Date(utils_hooks__hooks.now());
       } else if (isDate(input)) {
           config._d = new Date(input.valueOf());
       } else if (typeof input === 'string') {
           configFromString(config);
       } else if (isArray(input)) {
           config._a = map(input.slice(0), function (obj) {
               return parseInt(obj, 10);
           });
           configFromArray(config);
       } else if (typeof(input) === 'object') {
           configFromObject(config);
       } else if (typeof(input) === 'number') {
           // from milliseconds
           config._d = new Date(input);
       } else {
           utils_hooks__hooks.createFromInputFallback(config);
       }
   }
</PRE><PRE>   function createLocalOrUTC (input, format, locale, strict, isUTC) {
       var c = {};
</PRE><PRE>       if (typeof(locale) === 'boolean') {
           strict = locale;
           locale = undefined;
       }
</PRE><PRE>       if ((isObject(input) &amp;&amp; isObjectEmpty(input)) ||
               (isArray(input) &amp;&amp; input.length === 0)) {
           input = undefined;
       }
       // object construction must be done this way.
       // <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1423">https://github.com/moment/moment/issues/1423</A>
       c._isAMomentObject = true;
       c._useUTC = c._isUTC = isUTC;
       c._l = locale;
       c._i = input;
       c._f = format;
       c._strict = strict;
</PRE><PRE>       return createFromConfig(c);
   }
</PRE><PRE>   function local__createLocal (input, format, locale, strict) {
       return createLocalOrUTC(input, format, locale, strict, false);
   }
</PRE><PRE>   var prototypeMin = deprecate(
       'moment().min is deprecated, use moment.max instead. <A rel="nofollow" class="external free" href="http://momentjs.com/guides/#/warnings/min-max/'">http://momentjs.com/guides/#/warnings/min-max/'</A>,
       function () {
           var other = local__createLocal.apply(null, arguments);
           if (this.isValid() &amp;&amp; other.isValid()) {
               return other &lt; this ? this : other;
           } else {
               return valid__createInvalid();
           }
       }
   );
</PRE><PRE>   var prototypeMax = deprecate(
       'moment().max is deprecated, use moment.min instead. <A rel="nofollow" class="external free" href="http://momentjs.com/guides/#/warnings/min-max/'">http://momentjs.com/guides/#/warnings/min-max/'</A>,
       function () {
           var other = local__createLocal.apply(null, arguments);
           if (this.isValid() &amp;&amp; other.isValid()) {
               return other &gt; this ? this : other;
           } else {
               return valid__createInvalid();
           }
       }
   );
</PRE><PRE>   // Pick a moment m from moments so that m[fn](other) is true for all
   // other. This relies on the function fn to be transitive.
   //
   // moments should either be an array of moment objects or an array, whose
   // first element is an array of moment objects.
   function pickBy(fn, moments) {
       var res, i;
       if (moments.length === 1 &amp;&amp; isArray(moments[0])) {
           moments = moments[0];
       }
       if (!moments.length) {
           return local__createLocal();
       }
       res = moments[0];
       for (i = 1; i &lt; moments.length; ++i) {
           if (!moments[i].isValid() || moments[i][fn](res)) {
               res = moments[i];
           }
       }
       return res;
   }
</PRE><PRE>   // TODO: Use [].sort instead?
   function min () {
       var args = [].slice.call(arguments, 0);
</PRE><PRE>       return pickBy('isBefore', args);
   }
</PRE><PRE>   function max () {
       var args = [].slice.call(arguments, 0);
</PRE><PRE>       return pickBy('isAfter', args);
   }
</PRE><PRE>   var now = function () {
       return Date.now ? Date.now() : +(new Date());
   };
</PRE><PRE>   function Duration (duration) {
       var normalizedInput = normalizeObjectUnits(duration),
           years = normalizedInput.year || 0,
           quarters = normalizedInput.quarter || 0,
           months = normalizedInput.month || 0,
           weeks = normalizedInput.week || 0,
           days = normalizedInput.day || 0,
           hours = normalizedInput.hour || 0,
           minutes = normalizedInput.minute || 0,
           seconds = normalizedInput.second || 0,
           milliseconds = normalizedInput.millisecond || 0;
</PRE><PRE>       // representation for dateAddRemove
       this._milliseconds = +milliseconds +
           seconds * 1e3 + // 1000
           minutes * 6e4 + // 1000 * 60
           hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/2978">https://github.com/moment/moment/issues/2978</A>
       // Because of dateAddRemove treats 24 hours as different from a
       // day when working around DST, we need to store them separately
       this._days = +days +
           weeks * 7;
       // It is impossible translate months into days without knowing
       // which months you are are talking about, so we have to store
       // it separately.
       this._months = +months +
           quarters * 3 +
           years * 12;
</PRE><PRE>       this._data = {};
</PRE><PRE>       this._locale = locale_locales__getLocale();
</PRE><PRE>       this._bubble();
   }
</PRE><PRE>   function isDuration (obj) {
       return obj instanceof Duration;
   }
</PRE><PRE>   function absRound (number) {
       if (number &lt; 0) {
           return Math.round(-1 * number) * -1;
       } else {
           return Math.round(number);
       }
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   function offset (token, separator) {
       addFormatToken(token, 0, 0, function () {
           var offset = this.utcOffset();
           var sign = '+';
           if (offset &lt; 0) {
               offset = -offset;
               sign = '-';
           }
           return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
       });
   }
</PRE><PRE>   offset('Z', ':');
   offset('ZZ', <I>);</I></PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('Z',  matchShortOffset);
   addRegexToken('ZZ', matchShortOffset);
   addParseToken(['Z', 'ZZ'], function (input, array, config) {
       config._useUTC = true;
       config._tzm = offsetFromString(matchShortOffset, input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   // timezone chunker
   // '+10:00' &gt; ['10',  '00']
   // '-1530'  &gt; ['-15', '30']
   var chunkOffset = /([\+\-]|\d\d)/gi;
</PRE><PRE>   function offsetFromString(matcher, string) {
       var matches = ((string || <I>).match(matcher) || []);</I>
       var chunk   = matches[matches.length - 1] || [];
       var parts   = (chunk + <I>).match(chunkOffset) || ['-', 0, 0];</I>
       var minutes = +(parts[1] * 60) + toInt(parts[2]);
</PRE><PRE>       return parts[0] === '+' ? minutes : -minutes;
   }
</PRE><PRE>   // Return a moment from input, that is local/utc/zone equivalent to model.
   function cloneWithOffset(input, model) {
       var res, diff;
       if (model._isUTC) {
           res = model.clone();
           diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
           // Use low-level api, because this fn is low-level api.
           res._d.setTime(res._d.valueOf() + diff);
           utils_hooks__hooks.updateOffset(res, false);
           return res;
       } else {
           return local__createLocal(input).local();
       }
   }
</PRE><PRE>   function getDateOffset (m) {
       // On Firefox.24 Date#getTimezoneOffset returns a floating point.
       // <A rel="nofollow" class="external free" href="https://github.com/moment/moment/pull/1871">https://github.com/moment/moment/pull/1871</A>
       return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
   }
</PRE><PRE>   // HOOKS
</PRE><PRE>   // This function will be called whenever a moment is mutated.
   // It is intended to keep the offset in sync with the timezone.
   utils_hooks__hooks.updateOffset = function () {};
</PRE><PRE>   // MOMENTS
</PRE><PRE>   // keepLocalTime = true means only change the timezone, without
   // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--&gt;
   // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
   // +0200, so we adjust the time as needed, to be valid.
   //
   // Keeping the time actually adds/subtracts (one hour)
   // from the actual represented time. That is why we call updateOffset
   // a second time. In case it wants us to change the offset again
   // _changeInProgress == true case, then we have to adjust, because
   // there is no such time in the given timezone.
   function getSetOffset (input, keepLocalTime) {
       var offset = this._offset || 0,
           localAdjust;
       if (!this.isValid()) {
           return input != null ? this : NaN;
       }
       if (input != null) {
           if (typeof input === 'string') {
               input = offsetFromString(matchShortOffset, input);
           } else if (Math.abs(input) &lt; 16) {
               input = input * 60;
           }
           if (!this._isUTC &amp;&amp; keepLocalTime) {
               localAdjust = getDateOffset(this);
           }
           this._offset = input;
           this._isUTC = true;
           if (localAdjust != null) {
               this.add(localAdjust, 'm');
           }
           if (offset !== input) {
               if (!keepLocalTime || this._changeInProgress) {
                   add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
               } else if (!this._changeInProgress) {
                   this._changeInProgress = true;
                   utils_hooks__hooks.updateOffset(this, true);
                   this._changeInProgress = null;
               }
           }
           return this;
       } else {
           return this._isUTC ? offset : getDateOffset(this);
       }
   }
</PRE><PRE>   function getSetZone (input, keepLocalTime) {
       if (input != null) {
           if (typeof input !== 'string') {
               input = -input;
           }
</PRE><PRE>           this.utcOffset(input, keepLocalTime);
</PRE><PRE>           return this;
       } else {
           return -this.utcOffset();
       }
   }
</PRE><PRE>   function setOffsetToUTC (keepLocalTime) {
       return this.utcOffset(0, keepLocalTime);
   }
</PRE><PRE>   function setOffsetToLocal (keepLocalTime) {
       if (this._isUTC) {
           this.utcOffset(0, keepLocalTime);
           this._isUTC = false;
</PRE><PRE>           if (keepLocalTime) {
               this.subtract(getDateOffset(this), 'm');
           }
       }
       return this;
   }
</PRE><PRE>   function setOffsetToParsedOffset () {
       if (this._tzm) {
           this.utcOffset(this._tzm);
       } else if (typeof this._i === 'string') {
           var tZone = offsetFromString(matchOffset, this._i);
</PRE><PRE>           if (tZone === 0) {
               this.utcOffset(0, true);
           } else {
               this.utcOffset(offsetFromString(matchOffset, this._i));
           }
       }
       return this;
   }
</PRE><PRE>   function hasAlignedHourOffset (input) {
       if (!this.isValid()) {
           return false;
       }
       input = input ? local__createLocal(input).utcOffset() : 0;
</PRE><PRE>       return (this.utcOffset() - input) % 60 === 0;
   }
</PRE><PRE>   function isDaylightSavingTime () {
       return (
           this.utcOffset() &gt; this.clone().month(0).utcOffset() ||
           this.utcOffset() &gt; this.clone().month(5).utcOffset()
       );
   }
</PRE><PRE>   function isDaylightSavingTimeShifted () {
       if (!isUndefined(this._isDSTShifted)) {
           return this._isDSTShifted;
       }
</PRE><PRE>       var c = {};
</PRE><PRE>       copyConfig(c, this);
       c = prepareConfig(c);
</PRE><PRE>       if (c._a) {
           var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
           this._isDSTShifted = this.isValid() &amp;&amp;
               compareArrays(c._a, other.toArray()) &gt; 0;
       } else {
           this._isDSTShifted = false;
       }
</PRE><PRE>       return this._isDSTShifted;
   }
</PRE><PRE>   function isLocal () {
       return this.isValid() ? !this._isUTC : false;
   }
</PRE><PRE>   function isUtcOffset () {
       return this.isValid() ? this._isUTC : false;
   }
</PRE><PRE>   function isUtc () {
       return this.isValid() ? this._isUTC &amp;&amp; this._offset === 0 : false;
   }
</PRE><PRE>   // ASP.NET json date format regex
   var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
</PRE><PRE>   // from <A rel="nofollow" class="external free" href="http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html">http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html</A>
   // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
   // and further modified to allow for strings containing both week and day
   var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
</PRE><PRE>   function create__createDuration (input, key) {
       var duration = input,
           // matching against regexp is expensive, do it on demand
           match = null,
           sign,
           ret,
           diffRes;
</PRE><PRE>       if (isDuration(input)) {
           duration = {
               ms : input._milliseconds,
               d  : input._days,
               M  : input._months
           };
       } else if (typeof input === 'number') {
           duration = {};
           if (key) {
               duration[key] = input;
           } else {
               duration.milliseconds = input;
           }
       } else if (!!(match = aspNetRegex.exec(input))) {
           sign = (match[1] === '-') ? -1 : 1;
           duration = {
               y  : 0,
               d  : toInt(match[DATE])                         * sign,
               h  : toInt(match[HOUR])                         * sign,
               m  : toInt(match[MINUTE])                       * sign,
               s  : toInt(match[SECOND])                       * sign,
               ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
           };
       } else if (!!(match = isoRegex.exec(input))) {
           sign = (match[1] === '-') ? -1 : 1;
           duration = {
               y : parseIso(match[2], sign),
               M : parseIso(match[3], sign),
               w : parseIso(match[4], sign),
               d : parseIso(match[5], sign),
               h : parseIso(match[6], sign),
               m : parseIso(match[7], sign),
               s : parseIso(match[8], sign)
           };
       } else if (duration == null) {// checks for null or undefined
           duration = {};
       } else if (typeof duration === 'object' &amp;&amp; ('from' in duration || 'to' in duration)) {
           diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
</PRE><PRE>           duration = {};
           duration.ms = diffRes.milliseconds;
           duration.M = diffRes.months;
       }
</PRE><PRE>       ret = new Duration(duration);
</PRE><PRE>       if (isDuration(input) &amp;&amp; hasOwnProp(input, '_locale')) {
           ret._locale = input._locale;
       }
</PRE><PRE>       return ret;
   }
</PRE><PRE>   create__createDuration.fn = Duration.prototype;
</PRE><PRE>   function parseIso (inp, sign) {
       // We'd normally use ~~inp for this, but unfortunately it also
       // converts floats to ints.
       // inp may be undefined, so careful calling replace on it.
       var res = inp &amp;&amp; parseFloat(inp.replace(',', '.'));
       // apply sign while we're at it
       return (isNaN(res) ? 0 : res) * sign;
   }
</PRE><PRE>   function positiveMomentsDifference(base, other) {
       var res = {milliseconds: 0, months: 0};
</PRE><PRE>       res.months = other.month() - base.month() +
           (other.year() - base.year()) * 12;
       if (base.clone().add(res.months, 'M').isAfter(other)) {
           --res.months;
       }
</PRE><PRE>       res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
</PRE><PRE>       return res;
   }
</PRE><PRE>   function momentsDifference(base, other) {
       var res;
       if (!(base.isValid() &amp;&amp; other.isValid())) {
           return {milliseconds: 0, months: 0};
       }
</PRE><PRE>       other = cloneWithOffset(other, base);
       if (base.isBefore(other)) {
           res = positiveMomentsDifference(base, other);
       } else {
           res = positiveMomentsDifference(other, base);
           res.milliseconds = -res.milliseconds;
           res.months = -res.months;
       }
</PRE><PRE>       return res;
   }
</PRE><PRE>   // TODO: remove 'name' arg after deprecation is removed
   function createAdder(direction, name) {
       return function (val, period) {
           var dur, tmp;
           //invert the arguments, but complain about it
           if (period !== null &amp;&amp; !isNaN(+period)) {
               deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
               'See <A rel="nofollow" class="external free" href="http://momentjs.com/guides/#/warnings/add-inverted-param/">http://momentjs.com/guides/#/warnings/add-inverted-param/</A> for more info.');
               tmp = val; val = period; period = tmp;
           }
</PRE><PRE>           val = typeof val === 'string' ? +val : val;
           dur = create__createDuration(val, period);
           add_subtract__addSubtract(this, dur, direction);
           return this;
       };
   }
</PRE><PRE>   function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
       var milliseconds = duration._milliseconds,
           days = absRound(duration._days),
           months = absRound(duration._months);
</PRE><PRE>       if (!mom.isValid()) {
           // No op
           return;
       }
</PRE><PRE>       updateOffset = updateOffset == null ? true : updateOffset;
</PRE><PRE>       if (milliseconds) {
           mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
       }
       if (days) {
           get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
       }
       if (months) {
           setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
       }
       if (updateOffset) {
           utils_hooks__hooks.updateOffset(mom, days || months);
       }
   }
</PRE><PRE>   var add_subtract__add      = createAdder(1, 'add');
   var add_subtract__subtract = createAdder(-1, 'subtract');
</PRE><PRE>   function getCalendarFormat(myMoment, now) {
       var diff = myMoment.diff(now, 'days', true);
       return diff &lt; -6 ? 'sameElse' :
               diff &lt; -1 ? 'lastWeek' :
               diff &lt; 0 ? 'lastDay' :
               diff &lt; 1 ? 'sameDay' :
               diff &lt; 2 ? 'nextDay' :
               diff &lt; 7 ? 'nextWeek' : 'sameElse';
   }
</PRE><PRE>   function moment_calendar__calendar (time, formats) {
       // We want to compare the start of today, vs this.
       // Getting start-of-today depends on whether we're local/utc/offset or not.
       var now = time || local__createLocal(),
           sod = cloneWithOffset(now, this).startOf('day'),
           format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';
</PRE><PRE>       var output = formats &amp;&amp; (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
</PRE><PRE>       return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
   }
</PRE><PRE>   function clone () {
       return new Moment(this);
   }
</PRE><PRE>   function isAfter (input, units) {
       var localInput = isMoment(input) ? input : local__createLocal(input);
       if (!(this.isValid() &amp;&amp; localInput.isValid())) {
           return false;
       }
       units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
       if (units === 'millisecond') {
           return this.valueOf() &gt; localInput.valueOf();
       } else {
           return localInput.valueOf() &lt; this.clone().startOf(units).valueOf();
       }
   }
</PRE><PRE>   function isBefore (input, units) {
       var localInput = isMoment(input) ? input : local__createLocal(input);
       if (!(this.isValid() &amp;&amp; localInput.isValid())) {
           return false;
       }
       units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
       if (units === 'millisecond') {
           return this.valueOf() &lt; localInput.valueOf();
       } else {
           return this.clone().endOf(units).valueOf() &lt; localInput.valueOf();
       }
   }
</PRE><PRE>   function isBetween (from, to, units, inclusivity) {
       inclusivity = inclusivity || '()';
       return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &amp;&amp;
           (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
   }
</PRE><PRE>   function isSame (input, units) {
       var localInput = isMoment(input) ? input : local__createLocal(input),
           inputMs;
       if (!(this.isValid() &amp;&amp; localInput.isValid())) {
           return false;
       }
       units = normalizeUnits(units || 'millisecond');
       if (units === 'millisecond') {
           return this.valueOf() === localInput.valueOf();
       } else {
           inputMs = localInput.valueOf();
           return this.clone().startOf(units).valueOf() &lt;= inputMs &amp;&amp; inputMs &lt;= this.clone().endOf(units).valueOf();
       }
   }
</PRE><PRE>   function isSameOrAfter (input, units) {
       return this.isSame(input, units) || this.isAfter(input,units);
   }
</PRE><PRE>   function isSameOrBefore (input, units) {
       return this.isSame(input, units) || this.isBefore(input,units);
   }
</PRE><PRE>   function diff (input, units, asFloat) {
       var that,
           zoneDelta,
           delta, output;
</PRE><PRE>       if (!this.isValid()) {
           return NaN;
       }
</PRE><PRE>       that = cloneWithOffset(input, this);
</PRE><PRE>       if (!that.isValid()) {
           return NaN;
       }
</PRE><PRE>       zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
</PRE><PRE>       units = normalizeUnits(units);
</PRE><PRE>       if (units === 'year' || units === 'month' || units === 'quarter') {
           output = monthDiff(this, that);
           if (units === 'quarter') {
               output = output / 3;
           } else if (units === 'year') {
               output = output / 12;
           }
       } else {
           delta = this - that;
           output = units === 'second' ? delta / 1e3 : // 1000
               units === 'minute' ? delta / 6e4 : // 1000 * 60
               units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
               units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
               units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
               delta;
       }
       return asFloat ? output : absFloor(output);
   }
</PRE><PRE>   function monthDiff (a, b) {
       // difference in months
       var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
           // b is in (anchor - 1 month, anchor + 1 month)
           anchor = a.clone().add(wholeMonthDiff, 'months'),
           anchor2, adjust;
</PRE><PRE>       if (b - anchor &lt; 0) {
           anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
           // linear across the month
           adjust = (b - anchor) / (anchor - anchor2);
       } else {
           anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
           // linear across the month
           adjust = (b - anchor) / (anchor2 - anchor);
       }
</PRE><PRE>       //check for negative zero, return zero if negative zero
       return -(wholeMonthDiff + adjust) || 0;
   }
</PRE><PRE>   utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
   utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
</PRE><PRE>   function toString () {
       return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
   }
</PRE><PRE>   function moment_format__toISOString () {
       var m = this.clone().utc();
       if (0 &lt; m.year() &amp;&amp; m.year() &lt;= 9999) {
           if (isFunction(Date.prototype.toISOString)) {
               // native implementation is ~50x faster, use it when we can
               return this.toDate().toISOString();
           } else {
               return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
           }
       } else {
           return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
       }
   }
</PRE><PRE>   function format (inputString) {
       if (!inputString) {
           inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
       }
       var output = formatMoment(this, inputString);
       return this.localeData().postformat(output);
   }
</PRE><PRE>   function from (time, withoutSuffix) {
       if (this.isValid() &amp;&amp;
               ((isMoment(time) &amp;&amp; time.isValid()) ||
                local__createLocal(time).isValid())) {
           return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
       } else {
           return this.localeData().invalidDate();
       }
   }
</PRE><PRE>   function fromNow (withoutSuffix) {
       return this.from(local__createLocal(), withoutSuffix);
   }
</PRE><PRE>   function to (time, withoutSuffix) {
       if (this.isValid() &amp;&amp;
               ((isMoment(time) &amp;&amp; time.isValid()) ||
                local__createLocal(time).isValid())) {
           return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
       } else {
           return this.localeData().invalidDate();
       }
   }
</PRE><PRE>   function toNow (withoutSuffix) {
       return this.to(local__createLocal(), withoutSuffix);
   }
</PRE><PRE>   // If passed a locale key, it will set the locale for this
   // instance.  Otherwise, it will return the locale configuration
   // variables for this instance.
   function locale (key) {
       var newLocaleData;
</PRE><PRE>       if (key === undefined) {
           return this._locale._abbr;
       } else {
           newLocaleData = locale_locales__getLocale(key);
           if (newLocaleData != null) {
               this._locale = newLocaleData;
           }
           return this;
       }
   }
</PRE><PRE>   var lang = deprecate(
       'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
       function (key) {
           if (key === undefined) {
               return this.localeData();
           } else {
               return this.locale(key);
           }
       }
   );
</PRE><PRE>   function localeData () {
       return this._locale;
   }
</PRE><PRE>   function startOf (units) {
       units = normalizeUnits(units);
       // the following switch intentionally omits break keywords
       // to utilize falling through the cases.
       switch (units) {
           case 'year':
               this.month(0);
               /* falls through */
           case 'quarter':
           case 'month':
               this.date(1);
               /* falls through */
           case 'week':
           case 'isoWeek':
           case 'day':
           case 'date':
               this.hours(0);
               /* falls through */
           case 'hour':
               this.minutes(0);
               /* falls through */
           case 'minute':
               this.seconds(0);
               /* falls through */
           case 'second':
               this.milliseconds(0);
       }
</PRE><PRE>       // weeks are a special case
       if (units === 'week') {
           this.weekday(0);
       }
       if (units === 'isoWeek') {
           this.isoWeekday(1);
       }
</PRE><PRE>       // quarters are also special
       if (units === 'quarter') {
           this.month(Math.floor(this.month() / 3) * 3);
       }
</PRE><PRE>       return this;
   }
</PRE><PRE>   function endOf (units) {
       units = normalizeUnits(units);
       if (units === undefined || units === 'millisecond') {
           return this;
       }
</PRE><PRE>       // 'date' is an alias for 'day', so it should be considered as such.
       if (units === 'date') {
           units = 'day';
       }
</PRE><PRE>       return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
   }
</PRE><PRE>   function to_type__valueOf () {
       return this._d.valueOf() - ((this._offset || 0) * 60000);
   }
</PRE><PRE>   function unix () {
       return Math.floor(this.valueOf() / 1000);
   }
</PRE><PRE>   function toDate () {
       return new Date(this.valueOf());
   }
</PRE><PRE>   function toArray () {
       var m = this;
       return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
   }
</PRE><PRE>   function toObject () {
       var m = this;
       return {
           years: m.year(),
           months: m.month(),
           date: m.date(),
           hours: m.hours(),
           minutes: m.minutes(),
           seconds: m.seconds(),
           milliseconds: m.milliseconds()
       };
   }
</PRE><PRE>   function toJSON () {
       // new Date(NaN).toJSON() === null
       return this.isValid() ? this.toISOString() : null;
   }
</PRE><PRE>   function moment_valid__isValid () {
       return valid__isValid(this);
   }
</PRE><PRE>   function parsingFlags () {
       return extend({}, getParsingFlags(this));
   }
</PRE><PRE>   function invalidAt () {
       return getParsingFlags(this).overflow;
   }
</PRE><PRE>   function creationData() {
       return {
           input: this._i,
           format: this._f,
           locale: this._locale,
           isUTC: this._isUTC,
           strict: this._strict
       };
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken(0, ['gg', 2], 0, function () {
       return this.weekYear() % 100;
   });
</PRE><PRE>   addFormatToken(0, ['GG', 2], 0, function () {
       return this.isoWeekYear() % 100;
   });
</PRE><PRE>   function addWeekYearFormatToken (token, getter) {
       addFormatToken(0, [token, token.length], 0, getter);
   }
</PRE><PRE>   addWeekYearFormatToken('gggg',     'weekYear');
   addWeekYearFormatToken('ggggg',    'weekYear');
   addWeekYearFormatToken('GGGG',  'isoWeekYear');
   addWeekYearFormatToken('GGGGG', 'isoWeekYear');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('weekYear', 'gg');
   addUnitAlias('isoWeekYear', 'GG');
</PRE><PRE>   // PRIORITY
</PRE><PRE>   addUnitPriority('weekYear', 1);
   addUnitPriority('isoWeekYear', 1);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('G',      matchSigned);
   addRegexToken('g',      matchSigned);
   addRegexToken('GG',     match1to2, match2);
   addRegexToken('gg',     match1to2, match2);
   addRegexToken('GGGG',   match1to4, match4);
   addRegexToken('gggg',   match1to4, match4);
   addRegexToken('GGGGG',  match1to6, match6);
   addRegexToken('ggggg',  match1to6, match6);
</PRE><PRE>   addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
       week[token.substr(0, 2)] = toInt(input);
   });
</PRE><PRE>   addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
       week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
   });
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetWeekYear (input) {
       return getSetWeekYearHelper.call(this,
               input,
               this.week(),
               this.weekday(),
               this.localeData()._week.dow,
               this.localeData()._week.doy);
   }
</PRE><PRE>   function getSetISOWeekYear (input) {
       return getSetWeekYearHelper.call(this,
               input, this.isoWeek(), this.isoWeekday(), 1, 4);
   }
</PRE><PRE>   function getISOWeeksInYear () {
       return weeksInYear(this.year(), 1, 4);
   }
</PRE><PRE>   function getWeeksInYear () {
       var weekInfo = this.localeData()._week;
       return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
   }
</PRE><PRE>   function getSetWeekYearHelper(input, week, weekday, dow, doy) {
       var weeksTarget;
       if (input == null) {
           return weekOfYear(this, dow, doy).year;
       } else {
           weeksTarget = weeksInYear(input, dow, doy);
           if (week &gt; weeksTarget) {
               week = weeksTarget;
           }
           return setWeekAll.call(this, input, week, weekday, dow, doy);
       }
   }
</PRE><PRE>   function setWeekAll(weekYear, week, weekday, dow, doy) {
       var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
           date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
</PRE><PRE>       this.year(date.getUTCFullYear());
       this.month(date.getUTCMonth());
       this.date(date.getUTCDate());
       return this;
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('Q', 0, 'Qo', 'quarter');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('quarter', 'Q');
</PRE><PRE>   // PRIORITY
</PRE><PRE>   addUnitPriority('quarter', 7);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('Q', match1);
   addParseToken('Q', function (input, array) {
       array[MONTH] = (toInt(input) - 1) * 3;
   });
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetQuarter (input) {
       return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('D', ['DD', 2], 'Do', 'date');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('date', 'D');
</PRE><PRE>   // PRIOROITY
   addUnitPriority('date', 9);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('D',  match1to2);
   addRegexToken('DD', match1to2, match2);
   addRegexToken('Do', function (isStrict, locale) {
       return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
   });
</PRE><PRE>   addParseToken(['D', 'DD'], DATE);
   addParseToken('Do', function (input, array) {
       array[DATE] = toInt(input.match(match1to2)[0], 10);
   });
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetDayOfMonth = makeGetSet('Date', true);
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('dayOfYear', 'DDD');
</PRE><PRE>   // PRIORITY
   addUnitPriority('dayOfYear', 4);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('DDD',  match1to3);
   addRegexToken('DDDD', match3);
   addParseToken(['DDD', 'DDDD'], function (input, array, config) {
       config._dayOfYear = toInt(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetDayOfYear (input) {
       var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
       return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('m', ['mm', 2], 0, 'minute');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('minute', 'm');
</PRE><PRE>   // PRIORITY
</PRE><PRE>   addUnitPriority('minute', 14);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('m',  match1to2);
   addRegexToken('mm', match1to2, match2);
   addParseToken(['m', 'mm'], MINUTE);
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetMinute = makeGetSet('Minutes', false);
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('s', ['ss', 2], 0, 'second');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('second', 's');
</PRE><PRE>   // PRIORITY
</PRE><PRE>   addUnitPriority('second', 15);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('s',  match1to2);
   addRegexToken('ss', match1to2, match2);
   addParseToken(['s', 'ss'], SECOND);
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetSecond = makeGetSet('Seconds', false);
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('S', 0, 0, function () {
       return ~~(this.millisecond() / 100);
   });
</PRE><PRE>   addFormatToken(0, ['SS', 2], 0, function () {
       return ~~(this.millisecond() / 10);
   });
</PRE><PRE>   addFormatToken(0, ['SSS', 3], 0, 'millisecond');
   addFormatToken(0, ['SSSS', 4], 0, function () {
       return this.millisecond() * 10;
   });
   addFormatToken(0, ['SSSSS', 5], 0, function () {
       return this.millisecond() * 100;
   });
   addFormatToken(0, ['SSSSSS', 6], 0, function () {
       return this.millisecond() * 1000;
   });
   addFormatToken(0, ['SSSSSSS', 7], 0, function () {
       return this.millisecond() * 10000;
   });
   addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
       return this.millisecond() * 100000;
   });
   addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
       return this.millisecond() * 1000000;
   });
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('millisecond', 'ms');
</PRE><PRE>   // PRIORITY
</PRE><PRE>   addUnitPriority('millisecond', 16);
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('S',    match1to3, match1);
   addRegexToken('SS',   match1to3, match2);
   addRegexToken('SSS',  match1to3, match3);
</PRE><PRE>   var token;
   for (token = 'SSSS'; token.length &lt;= 9; token += 'S') {
       addRegexToken(token, matchUnsigned);
   }
</PRE><PRE>   function parseMs(input, array) {
       array[MILLISECOND] = toInt(('0.' + input) * 1000);
   }
</PRE><PRE>   for (token = 'S'; token.length &lt;= 9; token += 'S') {
       addParseToken(token, parseMs);
   }
   // MOMENTS
</PRE><PRE>   var getSetMillisecond = makeGetSet('Milliseconds', false);
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('z',  0, 0, 'zoneAbbr');
   addFormatToken('zz', 0, 0, 'zoneName');
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getZoneAbbr () {
       return this._isUTC ? 'UTC' : <I>;</I>
   }
</PRE><PRE>   function getZoneName () {
       return this._isUTC ? 'Coordinated Universal Time' : <I>;</I>
   }
</PRE><PRE>   var momentPrototype__proto = Moment.prototype;
</PRE><PRE>   momentPrototype__proto.add               = add_subtract__add;
   momentPrototype__proto.calendar          = moment_calendar__calendar;
   momentPrototype__proto.clone             = clone;
   momentPrototype__proto.diff              = diff;
   momentPrototype__proto.endOf             = endOf;
   momentPrototype__proto.format            = format;
   momentPrototype__proto.from              = from;
   momentPrototype__proto.fromNow           = fromNow;
   momentPrototype__proto.to                = to;
   momentPrototype__proto.toNow             = toNow;
   momentPrototype__proto.get               = stringGet;
   momentPrototype__proto.invalidAt         = invalidAt;
   momentPrototype__proto.isAfter           = isAfter;
   momentPrototype__proto.isBefore          = isBefore;
   momentPrototype__proto.isBetween         = isBetween;
   momentPrototype__proto.isSame            = isSame;
   momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
   momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
   momentPrototype__proto.isValid           = moment_valid__isValid;
   momentPrototype__proto.lang              = lang;
   momentPrototype__proto.locale            = locale;
   momentPrototype__proto.localeData        = localeData;
   momentPrototype__proto.max               = prototypeMax;
   momentPrototype__proto.min               = prototypeMin;
   momentPrototype__proto.parsingFlags      = parsingFlags;
   momentPrototype__proto.set               = stringSet;
   momentPrototype__proto.startOf           = startOf;
   momentPrototype__proto.subtract          = add_subtract__subtract;
   momentPrototype__proto.toArray           = toArray;
   momentPrototype__proto.toObject          = toObject;
   momentPrototype__proto.toDate            = toDate;
   momentPrototype__proto.toISOString       = moment_format__toISOString;
   momentPrototype__proto.toJSON            = toJSON;
   momentPrototype__proto.toString          = toString;
   momentPrototype__proto.unix              = unix;
   momentPrototype__proto.valueOf           = to_type__valueOf;
   momentPrototype__proto.creationData      = creationData;
</PRE><PRE>   // Year
   momentPrototype__proto.year       = getSetYear;
   momentPrototype__proto.isLeapYear = getIsLeapYear;
</PRE><PRE>   // Week Year
   momentPrototype__proto.weekYear    = getSetWeekYear;
   momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
</PRE><PRE>   // Quarter
   momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
</PRE><PRE>   // Month
   momentPrototype__proto.month       = getSetMonth;
   momentPrototype__proto.daysInMonth = getDaysInMonth;
</PRE><PRE>   // Week
   momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
   momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
   momentPrototype__proto.weeksInYear    = getWeeksInYear;
   momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
</PRE><PRE>   // Day
   momentPrototype__proto.date       = getSetDayOfMonth;
   momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
   momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
   momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
   momentPrototype__proto.dayOfYear  = getSetDayOfYear;
</PRE><PRE>   // Hour
   momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
</PRE><PRE>   // Minute
   momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
</PRE><PRE>   // Second
   momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
</PRE><PRE>   // Millisecond
   momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
</PRE><PRE>   // Offset
   momentPrototype__proto.utcOffset            = getSetOffset;
   momentPrototype__proto.utc                  = setOffsetToUTC;
   momentPrototype__proto.local                = setOffsetToLocal;
   momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
   momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
   momentPrototype__proto.isDST                = isDaylightSavingTime;
   momentPrototype__proto.isLocal              = isLocal;
   momentPrototype__proto.isUtcOffset          = isUtcOffset;
   momentPrototype__proto.isUtc                = isUtc;
   momentPrototype__proto.isUTC                = isUtc;
</PRE><PRE>   // Timezone
   momentPrototype__proto.zoneAbbr = getZoneAbbr;
   momentPrototype__proto.zoneName = getZoneName;
</PRE><PRE>   // Deprecations
   momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
   momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
   momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
   momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. <A rel="nofollow" class="external free" href="http://momentjs.com/guides/#/warnings/zone/'">http://momentjs.com/guides/#/warnings/zone/'</A>, getSetZone);
   momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See <A rel="nofollow" class="external free" href="http://momentjs.com/guides/#/warnings/dst-shifted/">http://momentjs.com/guides/#/warnings/dst-shifted/</A> for more information', isDaylightSavingTimeShifted);
</PRE><PRE>   var momentPrototype = momentPrototype__proto;
</PRE><PRE>   function moment__createUnix (input) {
       return local__createLocal(input * 1000);
   }
</PRE><PRE>   function moment__createInZone () {
       return local__createLocal.apply(null, arguments).parseZone();
   }
</PRE><PRE>   function preParsePostFormat (string) {
       return string;
   }
</PRE><PRE>   var prototype__proto = Locale.prototype;
</PRE><PRE>   prototype__proto.calendar        = locale_calendar__calendar;
   prototype__proto.longDateFormat  = longDateFormat;
   prototype__proto.invalidDate     = invalidDate;
   prototype__proto.ordinal         = ordinal;
   prototype__proto.preparse        = preParsePostFormat;
   prototype__proto.postformat      = preParsePostFormat;
   prototype__proto.relativeTime    = relative__relativeTime;
   prototype__proto.pastFuture      = pastFuture;
   prototype__proto.set             = locale_set__set;
</PRE><PRE>   // Month
   prototype__proto.months            =        localeMonths;
   prototype__proto.monthsShort       =        localeMonthsShort;
   prototype__proto.monthsParse       =        localeMonthsParse;
   prototype__proto.monthsRegex       = monthsRegex;
   prototype__proto.monthsShortRegex  = monthsShortRegex;
</PRE><PRE>   // Week
   prototype__proto.week = localeWeek;
   prototype__proto.firstDayOfYear = localeFirstDayOfYear;
   prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
</PRE><PRE>   // Day of Week
   prototype__proto.weekdays       =        localeWeekdays;
   prototype__proto.weekdaysMin    =        localeWeekdaysMin;
   prototype__proto.weekdaysShort  =        localeWeekdaysShort;
   prototype__proto.weekdaysParse  =        localeWeekdaysParse;
</PRE><PRE>   prototype__proto.weekdaysRegex       =        weekdaysRegex;
   prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
   prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;
</PRE><PRE>   // Hours
   prototype__proto.isPM = localeIsPM;
   prototype__proto.meridiem = localeMeridiem;
</PRE><PRE>   function lists__get (format, index, field, setter) {
       var locale = locale_locales__getLocale();
       var utc = create_utc__createUTC().set(setter, index);
       return locale[field](utc, format);
   }
</PRE><PRE>   function listMonthsImpl (format, index, field) {
       if (typeof format === 'number') {
           index = format;
           format = undefined;
       }
</PRE><PRE>       format = format || <I>;</I></PRE><PRE>       if (index != null) {
           return lists__get(format, index, field, 'month');
       }
</PRE><PRE>       var i;
       var out = [];
       for (i = 0; i &lt; 12; i++) {
           out[i] = lists__get(format, i, field, 'month');
       }
       return out;
   }
</PRE><PRE>   // ()
   // (5)
   // (fmt, 5)
   // (fmt)
   // (true)
   // (true, 5)
   // (true, fmt, 5)
   // (true, fmt)
   function listWeekdaysImpl (localeSorted, format, index, field) {
       if (typeof localeSorted === 'boolean') {
           if (typeof format === 'number') {
               index = format;
               format = undefined;
           }
</PRE><PRE>           format = format || <I>;</I>
       } else {
           format = localeSorted;
           index = format;
           localeSorted = false;
</PRE><PRE>           if (typeof format === 'number') {
               index = format;
               format = undefined;
           }
</PRE><PRE>           format = format || <I>;</I>
       }
</PRE><PRE>       var locale = locale_locales__getLocale(),
           shift = localeSorted ? locale._week.dow : 0;
</PRE><PRE>       if (index != null) {
           return lists__get(format, (index + shift) % 7, field, 'day');
       }
</PRE><PRE>       var i;
       var out = [];
       for (i = 0; i &lt; 7; i++) {
           out[i] = lists__get(format, (i + shift) % 7, field, 'day');
       }
       return out;
   }
</PRE><PRE>   function lists__listMonths (format, index) {
       return listMonthsImpl(format, index, 'months');
   }
</PRE><PRE>   function lists__listMonthsShort (format, index) {
       return listMonthsImpl(format, index, 'monthsShort');
   }
</PRE><PRE>   function lists__listWeekdays (localeSorted, format, index) {
       return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
   }
</PRE><PRE>   function lists__listWeekdaysShort (localeSorted, format, index) {
       return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
   }
</PRE><PRE>   function lists__listWeekdaysMin (localeSorted, format, index) {
       return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
   }
</PRE><PRE>   locale_locales__getSetGlobalLocale('en', {
       ordinalParse: /\d{1,2}(th|st|nd|rd)/,
       ordinal : function (number) {
           var b = number % 10,
               output = (toInt(number % 100 / 10) === 1) ? 'th' :
               (b === 1) ? 'st' :
               (b === 2) ? 'nd' :
               (b === 3) ? 'rd' : 'th';
           return number + output;
       }
   });
</PRE><PRE>   // Side effect imports
   utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
   utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
</PRE><PRE>   var mathAbs = Math.abs;
</PRE><PRE>   function duration_abs__abs () {
       var data           = this._data;
</PRE><PRE>       this._milliseconds = mathAbs(this._milliseconds);
       this._days         = mathAbs(this._days);
       this._months       = mathAbs(this._months);
</PRE><PRE>       data.milliseconds  = mathAbs(data.milliseconds);
       data.seconds       = mathAbs(data.seconds);
       data.minutes       = mathAbs(data.minutes);
       data.hours         = mathAbs(data.hours);
       data.months        = mathAbs(data.months);
       data.years         = mathAbs(data.years);
</PRE><PRE>       return this;
   }
</PRE><PRE>   function duration_add_subtract__addSubtract (duration, input, value, direction) {
       var other = create__createDuration(input, value);
</PRE><PRE>       duration._milliseconds += direction * other._milliseconds;
       duration._days         += direction * other._days;
       duration._months       += direction * other._months;
</PRE><PRE>       return duration._bubble();
   }
</PRE><PRE>   // supports only 2.0-style add(1, 's') or add(duration)
   function duration_add_subtract__add (input, value) {
       return duration_add_subtract__addSubtract(this, input, value, 1);
   }
</PRE><PRE>   // supports only 2.0-style subtract(1, 's') or subtract(duration)
   function duration_add_subtract__subtract (input, value) {
       return duration_add_subtract__addSubtract(this, input, value, -1);
   }
</PRE><PRE>   function absCeil (number) {
       if (number &lt; 0) {
           return Math.floor(number);
       } else {
           return Math.ceil(number);
       }
   }
</PRE><PRE>   function bubble () {
       var milliseconds = this._milliseconds;
       var days         = this._days;
       var months       = this._months;
       var data         = this._data;
       var seconds, minutes, hours, years, monthsFromDays;
</PRE><PRE>       // if we have a mix of positive and negative values, bubble down first
       // check: <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/2166">https://github.com/moment/moment/issues/2166</A>
       if (!((milliseconds &gt;= 0 &amp;&amp; days &gt;= 0 &amp;&amp; months &gt;= 0) ||
               (milliseconds &lt;= 0 &amp;&amp; days &lt;= 0 &amp;&amp; months &lt;= 0))) {
           milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
           days = 0;
           months = 0;
       }
</PRE><PRE>       // The following code bubbles up values, see the tests for
       // examples of what that means.
       data.milliseconds = milliseconds % 1000;
</PRE><PRE>       seconds           = absFloor(milliseconds / 1000);
       data.seconds      = seconds % 60;
</PRE><PRE>      minutes           = absFloor(seconds / 60);
       data.minutes      = minutes % 60;
</PRE><PRE>       hours             = absFloor(minutes / 60);
       data.hours        = hours % 24;
</PRE><PRE>       days += absFloor(hours / 24);
</PRE><PRE>       // convert days to months
       monthsFromDays = absFloor(daysToMonths(days));
       months += monthsFromDays;
       days -= absCeil(monthsToDays(monthsFromDays));
</PRE><PRE>       // 12 months -&gt; 1 year
       years = absFloor(months / 12);
       months %= 12;
</PRE><PRE>       data.days   = days;
       data.months = months;
       data.years  = years;
</PRE><PRE>       return this;
   }
</PRE><PRE>   function daysToMonths (days) {
       // 400 years have 146097 days (taking into account leap year rules)
       // 400 years have 12 months === 4800
       return days * 4800 / 146097;
   }
</PRE><PRE>   function monthsToDays (months) {
       // the reverse of daysToMonths
       return months * 146097 / 4800;
   }
</PRE><PRE>   function as (units) {
       var days;
       var months;
       var milliseconds = this._milliseconds;
</PRE><PRE>       units = normalizeUnits(units);
</PRE><PRE>       if (units === 'month' || units === 'year') {
           days   = this._days   + milliseconds / 864e5;
           months = this._months + daysToMonths(days);
           return units === 'month' ? months : months / 12;
       } else {
           // handle milliseconds separately because of floating point math errors (issue #1867)
           days = this._days + Math.round(monthsToDays(this._months));
           switch (units) {
               case 'week'   : return days / 7     + milliseconds / 6048e5;
               case 'day'    : return days         + milliseconds / 864e5;
               case 'hour'   : return days * 24    + milliseconds / 36e5;
               case 'minute' : return days * 1440  + milliseconds / 6e4;
               case 'second' : return days * 86400 + milliseconds / 1000;
               // Math.floor prevents floating point math errors here
               case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
               default: throw new Error('Unknown unit ' + units);
           }
       }
   }
</PRE><PRE>   // TODO: Use this.as('ms')?
   function duration_as__valueOf () {
       return (
           this._milliseconds +
           this._days * 864e5 +
           (this._months % 12) * 2592e6 +
           toInt(this._months / 12) * 31536e6
       );
   }
</PRE><PRE>   function makeAs (alias) {
       return function () {
           return this.as(alias);
       };
   }
</PRE><PRE>   var asMilliseconds = makeAs('ms');
   var asSeconds      = makeAs('s');
   var asMinutes      = makeAs('m');
   var asHours        = makeAs('h');
   var asDays         = makeAs('d');
   var asWeeks        = makeAs('w');
   var asMonths       = makeAs('M');
   var asYears        = makeAs('y');
</PRE><PRE>   function duration_get__get (units) {
       units = normalizeUnits(units);
       return this[units + 's']();
   }
</PRE><PRE>   function makeGetter(name) {
       return function () {
           return this._data[name];
       };
   }
</PRE><PRE>   var milliseconds = makeGetter('milliseconds');
   var seconds      = makeGetter('seconds');
   var minutes      = makeGetter('minutes');
   var hours        = makeGetter('hours');
   var days         = makeGetter('days');
   var months       = makeGetter('months');
   var years        = makeGetter('years');
</PRE><PRE>   function weeks () {
       return absFloor(this.days() / 7);
   }
</PRE><PRE>   var round = Math.round;
   var thresholds = {
       s: 45,  // seconds to minute
       m: 45,  // minutes to hour
       h: 22,  // hours to day
       d: 26,  // days to month
       M: 11   // months to year
   };
</PRE><PRE>   // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
   function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
       return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
   }
</PRE><PRE>   function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
       var duration = create__createDuration(posNegDuration).abs();
       var seconds  = round(duration.as('s'));
       var minutes  = round(duration.as('m'));
       var hours    = round(duration.as('h'));
       var days     = round(duration.as('d'));
       var months   = round(duration.as('M'));
       var years    = round(duration.as('y'));
</PRE><PRE>       var a = seconds &lt; thresholds.s &amp;&amp; ['s', seconds]  ||
               minutes &lt;= 1           &amp;&amp; ['m']           ||
               minutes &lt; thresholds.m &amp;&amp; ['mm', minutes] ||
               hours   &lt;= 1           &amp;&amp; ['h']           ||
               hours   &lt; thresholds.h &amp;&amp; ['hh', hours]   ||
               days    &lt;= 1           &amp;&amp; ['d']           ||
               days    &lt; thresholds.d &amp;&amp; ['dd', days]    ||
               months  &lt;= 1           &amp;&amp; ['M']           ||
               months  &lt; thresholds.M &amp;&amp; ['MM', months]  ||
               years   &lt;= 1           &amp;&amp; ['y']           || ['yy', years];
</PRE><PRE>       a[2] = withoutSuffix;
       a[3] = +posNegDuration &gt; 0;
       a[4] = locale;
       return substituteTimeAgo.apply(null, a);
   }
</PRE><PRE>   // This function allows you to set the rounding function for relative time strings
   function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
       if (roundingFunction === undefined) {
           return round;
       }
       if (typeof(roundingFunction) === 'function') {
           round = roundingFunction;
           return true;
       }
       return false;
   }
</PRE><PRE>   // This function allows you to set a threshold for relative time strings
   function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
       if (thresholds[threshold] === undefined) {
           return false;
       }
       if (limit === undefined) {
           return thresholds[threshold];
       }
       thresholds[threshold] = limit;
       return true;
   }
</PRE><PRE>   function humanize (withSuffix) {
       var locale = this.localeData();
       var output = duration_humanize__relativeTime(this, !withSuffix, locale);
</PRE><PRE>       if (withSuffix) {
           output = locale.pastFuture(+this, output);
       }
</PRE><PRE>       return locale.postformat(output);
   }
</PRE><PRE>   var iso_string__abs = Math.abs;
</PRE><PRE>   function iso_string__toISOString() {
       // for ISO strings we do not use the normal bubbling rules:
       //  * milliseconds bubble up until they become hours
       //  * days do not bubble at all
       //  * months bubble up until they become years
       // This is because there is no context-free conversion between hours and days
       // (think of clock changes)
       // and also not between days and months (28-31 days per month)
       var seconds = iso_string__abs(this._milliseconds) / 1000;
       var days         = iso_string__abs(this._days);
       var months       = iso_string__abs(this._months);
       var minutes, hours, years;
</PRE><PRE>       // 3600 seconds -&gt; 60 minutes -&gt; 1 hour
       minutes           = absFloor(seconds / 60);
       hours             = absFloor(minutes / 60);
       seconds %= 60;
       minutes %= 60;
</PRE><PRE>       // 12 months -&gt; 1 year
       years  = absFloor(months / 12);
       months %= 12;
</PRE><PRE>       // inspired by <A rel="nofollow" class="external free" href="https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js">https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js</A>
       var Y = years;
       var M = months;
       var D = days;
       var h = hours;
       var m = minutes;
       var s = seconds;
       var total = this.asSeconds();
</PRE><PRE>       if (!total) {
           // this is the same as C#'s (Noda) and python (isodate)...
           // but not other JS (goog.date)
           return 'P0D';
       }
</PRE><PRE>       return (total &lt; 0 ? '-' : <I>) +</I>
           'P' +
           (Y ? Y + 'Y' : <I>) +</I>
           (M ? M + 'M' : <I>) +</I>
           (D ? D + 'D' : <I>) +</I>
           ((h || m || s) ? 'T' : <I>) +</I>
           (h ? h + 'H' : <I>) +</I>
           (m ? m + 'M' : <I>) +</I>
           (s ? s + 'S' : <I>);</I>
   }
</PRE><PRE>   var duration_prototype__proto = Duration.prototype;
</PRE><PRE>   duration_prototype__proto.abs            = duration_abs__abs;
   duration_prototype__proto.add            = duration_add_subtract__add;
   duration_prototype__proto.subtract       = duration_add_subtract__subtract;
   duration_prototype__proto.as             = as;
   duration_prototype__proto.asMilliseconds = asMilliseconds;
   duration_prototype__proto.asSeconds      = asSeconds;
   duration_prototype__proto.asMinutes      = asMinutes;
   duration_prototype__proto.asHours        = asHours;
   duration_prototype__proto.asDays         = asDays;
   duration_prototype__proto.asWeeks        = asWeeks;
   duration_prototype__proto.asMonths       = asMonths;
   duration_prototype__proto.asYears        = asYears;
   duration_prototype__proto.valueOf        = duration_as__valueOf;
   duration_prototype__proto._bubble        = bubble;
   duration_prototype__proto.get            = duration_get__get;
   duration_prototype__proto.milliseconds   = milliseconds;
   duration_prototype__proto.seconds        = seconds;
   duration_prototype__proto.minutes        = minutes;
   duration_prototype__proto.hours          = hours;
   duration_prototype__proto.days           = days;
   duration_prototype__proto.weeks          = weeks;
   duration_prototype__proto.months         = months;
   duration_prototype__proto.years          = years;
   duration_prototype__proto.humanize       = humanize;
   duration_prototype__proto.toISOString    = iso_string__toISOString;
   duration_prototype__proto.toString       = iso_string__toISOString;
   duration_prototype__proto.toJSON         = iso_string__toISOString;
   duration_prototype__proto.locale         = locale;
   duration_prototype__proto.localeData     = localeData;
</PRE><PRE>   // Deprecations
   duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
   duration_prototype__proto.lang = lang;
</PRE><PRE>   // Side effect imports
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('X', 0, 0, 'unix');
   addFormatToken('x', 0, 0, 'valueOf');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('x', matchSigned);
   addRegexToken('X', matchTimestamp);
   addParseToken('X', function (input, array, config) {
       config._d = new Date(parseFloat(input, 10) * 1000);
   });
   addParseToken('x', function (input, array, config) {
       config._d = new Date(toInt(input));
   });
</PRE><PRE>   // Side effect imports
</PRE><PRE>   utils_hooks__hooks.version = '2.15.1';
</PRE><PRE>   setHookCallback(local__createLocal);
</PRE><PRE>   utils_hooks__hooks.fn                    = momentPrototype;
   utils_hooks__hooks.min                   = min;
   utils_hooks__hooks.max                   = max;
   utils_hooks__hooks.now                   = now;
   utils_hooks__hooks.utc                   = create_utc__createUTC;
   utils_hooks__hooks.unix                  = moment__createUnix;
   utils_hooks__hooks.months                = lists__listMonths;
   utils_hooks__hooks.isDate                = isDate;
   utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
   utils_hooks__hooks.invalid               = valid__createInvalid;
   utils_hooks__hooks.duration              = create__createDuration;
   utils_hooks__hooks.isMoment              = isMoment;
   utils_hooks__hooks.weekdays              = lists__listWeekdays;
   utils_hooks__hooks.parseZone             = moment__createInZone;
   utils_hooks__hooks.localeData            = locale_locales__getLocale;
   utils_hooks__hooks.isDuration            = isDuration;
   utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
   utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
   utils_hooks__hooks.defineLocale          = defineLocale;
   utils_hooks__hooks.updateLocale          = updateLocale;
   utils_hooks__hooks.locales               = locale_locales__listLocales;
   utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
   utils_hooks__hooks.normalizeUnits        = normalizeUnits;
   utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
   utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
   utils_hooks__hooks.calendarFormat        = getCalendarFormat;
   utils_hooks__hooks.prototype             = momentPrototype;
</PRE><PRE>   var _moment = utils_hooks__hooks;
</PRE><PRE>   return _moment;
</PRE><P>}));
/*! flipclock 2015-08-31 */
</P>
var Base=function(){};Base.extend=function(a,b){&quot;use strict&quot;;var c=Base.prototype.extend;Base._prototyping=!0;var d=new this;c.call(d,a),d.base=function(){},delete Base._prototyping;var e=d.constructor,f=d.constructor=function(){if(!Base._prototyping)if(this._constructing||this.constructor==f)this._constructing=!0,e.apply(this,arguments),delete this._constructing;else if(null!==arguments[0])return(arguments[0].extend||c).call(arguments[0],d)};return f.ancestor=this,f.extend=this.extend,f.forEach=this.forEach,f.implement=this.implement,f.prototype=d,f.toString=this.toString,f.valueOf=function(a){return&quot;object&quot;==a?f:e.valueOf()},c.call(f,b),&quot;function&quot;==typeof f.init&amp;&amp;f.init(),f},Base.prototype={extend:function(a,b){if(arguments.length&gt;1){var c=this[a];if(c&amp;&amp;&quot;function&quot;==typeof b&amp;&amp;(!c.valueOf||c.valueOf()!=b.valueOf())&amp;&amp;/\bbase\b/.test(b)){var d=b.valueOf();b=function(){var a=this.base||Base.prototype.base;this.base=c;var b=d.apply(this,arguments);return this.base=a,b},b.valueOf=function(a){return&quot;object&quot;==a?b:d},b.toString=Base.toString}this[a]=b}else if(a){var e=Base.prototype.extend;Base._prototyping||&quot;function&quot;==typeof this||(e=this.extend||e);for(var f={toSource:null},g=[&quot;constructor&quot;,&quot;toString&quot;,&quot;valueOf&quot;],h=Base._prototyping?0:1;i=g[h++];)a[i]!=f[i]&amp;&amp;e.call(this,i,a[i]);for(var i in a)f[i]||e.call(this,i,a[i])}return this}},Base=Base.extend({constructor:function(){this.extend(arguments[0])}},{ancestor:Object,version:&quot;1.1&quot;,forEach:function(a,b,c){for(var d in a)void 0===this.prototype[d]&amp;&amp;b.call(c,a[d],d,a)},implement:function(){for(var a=0;a&lt;arguments.length;a++)&quot;function&quot;==typeof arguments[a]?arguments[a](this.prototype):this.prototype.extend(arguments[a]);return this},toString:function(){return String(this.valueOf())}});var FlipClock;!function(a){&quot;use strict&quot;;FlipClock=function(a,b,c){return b instanceof Object&amp;&amp;b instanceof Date==!1&amp;&amp;(c=b,b=0),new FlipClock.Factory(a,b,c)},FlipClock.Lang={},FlipClock.Base=Base.extend({buildDate:&quot;2014-12-12&quot;,version:&quot;0.7.7&quot;,constructor:function(b,c){&quot;object&quot;!=typeof b&amp;&amp;(b={}),&quot;object&quot;!=typeof c&amp;&amp;(c={}),this.setOptions(a.extend(!0,{},b,c))},callback:function(a){if(&quot;function&quot;==typeof a){for(var b=[],c=1;c&lt;=arguments.length;c++)arguments[c]&amp;&amp;b.push(arguments[c]);a.apply(this,b)}},log:function(a){window.console&amp;&amp;console.log&amp;&amp;console.log(a)},getOption:function(a){return this[a]?this[a]:!1},getOptions:function(){return this},setOption:function(a,b){this[a]=b},setOptions:function(a){for(var b in a)&quot;undefined&quot;!=typeof a[b]&amp;&amp;this.setOption(b,a[b])}})}(jQuery),function(a){&quot;use strict&quot;;FlipClock.Face=FlipClock.Base.extend({autoStart:!0,dividers:[],factory:!1,lists:[],constructor:function(a,b){this.dividers=[],this.lists=[],this.base(b),this.factory=a},build:function(){this.autoStart&amp;&amp;this.start()},createDivider:function(b,c,d){&quot;boolean&quot;!=typeof c&amp;&amp;c||(d=c,c=b);var e=['',''].join(&quot;&quot;);d&amp;&amp;(e=&quot;&quot;),b=this.factory.localize(b);var f=['<SPAN class="'+this.factory.classes.divider+">','<SPAN class="'+this.factory.classes.label+'">'+(b?b:&quot;&quot;)+&quot;</SPAN>&quot;,e,&quot;</SPAN>&quot;],g=a(f.join(&quot;&quot;));return this.dividers.push(g),g},createList:function(a,b){&quot;object&quot;==typeof a&amp;&amp;(b=a,a=0);var c=new FlipClock.List(this.factory,a,b);return this.lists.push(c),c},reset:function(){this.factory.time=new FlipClock.Time(this.factory,this.factory.original?Math.round(this.factory.original):0,{minimumDigits:this.factory.minimumDigits}),this.flip(this.factory.original,!1)},appendDigitToClock:function(a){a.$el.append(!1)},addDigit:function(a){var b=this.createList(a,{classes:{active:this.factory.classes.active,before:this.factory.classes.before,flip:this.factory.classes.flip}});this.appendDigitToClock(b)},start:function(){},stop:function(){},autoIncrement:function(){this.factory.countdown?this.decrement():this.increment()},increment:function(){this.factory.time.addSecond()},decrement:function(){0==this.factory.time.getTimeSeconds()?this.factory.stop():this.factory.time.subSecond()},flip:function(b,c){var d=this;a.each(b,function(a,b){var e=d.lists[a];e?(c||b==e.digit||e.play(),e.select(b)):d.addDigit(b)})}})}(jQuery),function(a){&quot;use strict&quot;;FlipClock.Factory=FlipClock.Base.extend({animationRate:1e3,autoStart:!0,callbacks:{destroy:!1,create:!1,init:!1,interval:!1,start:!1,stop:!1,reset:!1},classes:{active:&quot;flip-clock-active&quot;,before:&quot;flip-clock-before&quot;,divider:&quot;flip-clock-divider&quot;,dot:&quot;flip-clock-dot&quot;,label:&quot;flip-clock-label&quot;,flip:&quot;flip&quot;,play:&quot;play&quot;,wrapper:&quot;flip-clock-wrapper&quot;},clockFace:&quot;HourlyCounter&quot;,countdown:!1,defaultClockFace:&quot;HourlyCounter&quot;,defaultLanguage:&quot;english&quot;,$el:!1,face:!0,lang:!1,language:&quot;english&quot;,minimumDigits:0,original:!1,running:!1,time:!1,timer:!1,$wrapper:!1,constructor:function(b,c,d){d||(d={}),this.lists=[],this.running=!1,this.base(d),this.$el=a(b).addClass(this.classes.wrapper),this.$wrapper=this.$el,this.original=c instanceof Date?c:c?Math.round(c):0,this.time=new FlipClock.Time(this,this.original,{minimumDigits:this.minimumDigits,animationRate:this.animationRate}),this.timer=new FlipClock.Timer(this,d),this.loadLanguage(this.language),this.loadClockFace(this.clockFace,d),this.autoStart&amp;&amp;this.start()},loadClockFace:function(a,b){var c,d=&quot;Face&quot;,e=!1;return a=a.ucfirst()+d,this.face.stop&amp;&amp;(this.stop(),e=!0),this.$el.html(&quot;&quot;),this.time.minimumDigits=this.minimumDigits,c=FlipClock[a]?new FlipClock[a](this,b):new FlipClock[this.defaultClockFace+d](this,b),c.build(),this.face=c,e&amp;&amp;this.start(),this.face},loadLanguage:function(a){var b;return b=FlipClock.Lang[a.ucfirst()]?FlipClock.Lang[a.ucfirst()]:FlipClock.Lang[a]?FlipClock.Lang[a]:FlipClock.Lang[this.defaultLanguage],this.lang=b},localize:function(a,b){var c=this.lang;if(!a)return null;var d=a.toLowerCase();return&quot;object&quot;==typeof b&amp;&amp;(c=b),c&amp;&amp;c[d]?c[d]:a},start:function(a){var b=this;b.running||b.countdown&amp;&amp;!(b.countdown&amp;&amp;b.time.time&gt;0)?b.log(&quot;Trying to start timer when countdown already at 0&quot;):(b.face.start(b.time),b.timer.start(function(){b.flip(),&quot;function&quot;==typeof a&amp;&amp;a()}))},stop:function(a){this.face.stop(),this.timer.stop(a);for(var b in this.lists)this.lists.hasOwnProperty(b)&amp;&amp;this.lists[b].stop()},reset:function(a){this.timer.reset(a),this.face.reset()},setTime:function(a){this.time.time=a,this.flip(!0)},getTime:function(a){return this.time},setCountdown:function(a){var b=this.running;this.countdown=a?!0:!1,b&amp;&amp;(this.stop(),this.start())},flip:function(a){this.face.flip(!1,a)}})}(jQuery),function(a){&quot;use strict&quot;;FlipClock.List=FlipClock.Base.extend({digit:0,classes:{active:&quot;flip-clock-active&quot;,before:&quot;flip-clock-before&quot;,flip:&quot;flip&quot;},factory:!1,$el:!1,$obj:!1,items:[],lastDigit:0,constructor:function(a,b,c){this.factory=a,this.digit=b,this.lastDigit=b,this.$el=this.createList(),this.$obj=this.$el,b&gt;0&amp;&amp;this.select(b),this.factory.$el.append(this.$el)},select:function(a){if(&quot;undefined&quot;==typeof a?a=this.digit:this.digit=a,this.digit!=this.lastDigit){var b=this.$el.find(&quot;.&quot;+this.classes.before).removeClass(this.classes.before);this.$el.find(&quot;.&quot;+this.classes.active).removeClass(this.classes.active).addClass(this.classes.before),this.appendListItem(this.classes.active,this.digit),b.remove(),this.lastDigit=this.digit}},play:function(){this.$el.addClass(this.factory.classes.play)},stop:function(){var a=this;setTimeout(function(){a.$el.removeClass(a.factory.classes.play)},this.factory.timer.interval)},createListItem:function(a,b){return['<LI>','&lt;a href=&quot;#&quot;&gt;','<DIV class="up">','','<DIV class="inn">'+(b?b:&quot;&quot;)+&quot;</DIV>&quot;,&quot;</DIV>&quot;,'<DIV class="down">','','<DIV class="inn">'+(b?b:&quot;&quot;)+&quot;</DIV>&quot;,&quot;</DIV>&quot;,&quot;&lt;/a&gt;&quot;,&quot;</LI>&quot;].join(&quot;&quot;)},appendListItem:function(a,b){var c=this.createListItem(a,b);this.$el.append(c)},createList:function(){var b=this.getPrevDigit()?this.getPrevDigit():this.digit,c=a(['<UL class="'+this.classes.flip+">',this.createListItem(this.classes.before,b),this.createListItem(this.classes.active,this.digit),&quot;</UL>&quot;].join(&quot;&quot;));return c},getNextDigit:function(){return 9==this.digit?0:this.digit+1},getPrevDigit:function(){return 0==this.digit?9:this.digit-1}})}(jQuery),function(a){&quot;use strict&quot;;String.prototype.ucfirst=function(){return this.substr(0,1).toUpperCase()+this.substr(1)},a.fn.FlipClock=function(b,c){return new FlipClock(a(this),b,c)},a.fn.flipClock=function(b,c){return a.fn.FlipClock(b,c)}}(jQuery),function(a){&quot;use strict&quot;;FlipClock.Time=FlipClock.Base.extend({time:0,factory:!1,minimumDigits:0,constructor:function(a,b,c){&quot;object&quot;!=typeof c&amp;&amp;(c={}),c.minimumDigits||(c.minimumDigits=a.minimumDigits),this.base(c),this.factory=a,b&amp;&amp;(this.time=b)},convertDigitsToArray:function(a){var b=[];a=a.toString();for(var c=0;c&lt;a.length;c++)a[c].match(/^\d*$/g)&amp;&amp;b.push(a[c]);return b},digit:function(a){var b=this.toString(),c=b.length;return b[c-a]?b[c-a]:!1},digitize:function(b){var c=[];if(a.each(b,function(a,b){b=b.toString(),1==b.length&amp;&amp;(b=&quot;0&quot;+b);for(var d=0;d&lt;b.length;d++)c.push(b.charAt(d))}),c.length&gt;this.minimumDigits&amp;&amp;(this.minimumDigits=c.length),this.minimumDigits&gt;c.length)for(var d=c.length;d&lt;this.minimumDigits;d++)c.unshift(&quot;0&quot;);return c},getDateObject:function(){return this.time instanceof Date?this.time:new Date((new Date).getTime()+1e3*this.getTimeSeconds())},getDayCounter:function(a){var b=[this.getDays(),this.getHours(!0),this.getMinutes(!0)];return a&amp;&amp;b.push(this.getSeconds(!0)),this.digitize(b)},getDays:function(a){var b=this.getTimeSeconds()/60/60/24;return a&amp;&amp;(b%=7),Math.floor(b)},getHourCounter:function(){var a=this.digitize([this.getHours(),this.getMinutes(!0),this.getSeconds(!0)]);return a},getHourly:function(){return this.getHourCounter()},getHours:function(a){var b=this.getTimeSeconds()/60/60;return a&amp;&amp;(b%=24),Math.floor(b)},getMilitaryTime:function(a,b){&quot;undefined&quot;==typeof b&amp;&amp;(b=!0),a||(a=this.getDateObject());var c=[a.getHours(),a.getMinutes()];return b===!0&amp;&amp;c.push(a.getSeconds()),this.digitize(c)},getMinutes:function(a){var b=this.getTimeSeconds()/60;return a&amp;&amp;(b%=60),Math.floor(b)},getMinuteCounter:function(){var a=this.digitize([this.getMinutes(),this.getSeconds(!0)]);return a},getTimeSeconds:function(a){return a||(a=new Date),this.time instanceof Date?this.factory.countdown?Math.max(this.time.getTime()/1e3-a.getTime()/1e3,0):a.getTime()/1e3-this.time.getTime()/1e3:this.time},getTime:function(a,b){&quot;undefined&quot;==typeof b&amp;&amp;(b=!0),a||(a=this.getDateObject()),console.log(a);var c=a.getHours(),d=[c&gt;12?c-12:0===c?12:c,a.getMinutes()];return b===!0&amp;&amp;d.push(a.getSeconds()),this.digitize(d)},getSeconds:function(a){var b=this.getTimeSeconds();return a&amp;&amp;(60==b?b=0:b%=60),Math.ceil(b)},getWeeks:function(a){var b=this.getTimeSeconds()/60/60/24/7;return a&amp;&amp;(b%=52),Math.floor(b)},removeLeadingZeros:function(b,c){var d=0,e=[];return a.each(c,function(a,f){b&gt;a?d+=parseInt(c[a],10):e.push(c[a])}),0===d?e:c},addSeconds:function(a){this.time instanceof Date?this.time.setSeconds(this.time.getSeconds()+a):this.time+=a},addSecond:function(){this.addSeconds(1)},subSeconds:function(a){this.time instanceof Date?this.time.setSeconds(this.time.getSeconds()-a):this.time-=a},subSecond:function(){this.subSeconds(1)},toString:function(){return this.getTimeSeconds().toString()}})}(jQuery),function(a){&quot;use strict&quot;;FlipClock.Timer=FlipClock.Base.extend({callbacks:{destroy:!1,create:!1,init:!1,interval:!1,start:!1,stop:!1,reset:!1},count:0,factory:!1,interval:1e3,animationRate:1e3,constructor:function(a,b){this.base(b),this.factory=a,this.callback(this.callbacks.init),this.callback(this.callbacks.create)},getElapsed:function(){return this.count*this.interval},getElapsedTime:function(){return new Date(this.time+this.getElapsed())},reset:function(a){clearInterval(this.timer),this.count=0,this._setInterval(a),this.callback(this.callbacks.reset)},start:function(a){this.factory.running=!0,this._createTimer(a),this.callback(this.callbacks.start)},stop:function(a){this.factory.running=!1,this._clearInterval(a),this.callback(this.callbacks.stop),this.callback(a)},_clearInterval:function(){clearInterval(this.timer)},_createTimer:function(a){this._setInterval(a)},_destroyTimer:function(a){this._clearInterval(),this.timer=!1,this.callback(a),this.callback(this.callbacks.destroy)},_interval:function(a){this.callback(this.callbacks.interval),this.callback(a),this.count++},_setInterval:function(a){var b=this;b._interval(a),b.timer=setInterval(function(){b._interval(a)},this.interval)}})}(jQuery),function(a){FlipClock.TwentyFourHourClockFace=FlipClock.Face.extend({constructor:function(a,b){this.base(a,b)},build:function(b){var c=this,d=this.factory.$el.find(&quot;ul&quot;);this.factory.time.time||(this.factory.original=new Date,this.factory.time=new FlipClock.Time(this.factory,this.factory.original));var b=b?b:this.factory.time.getMilitaryTime(!1,this.showSeconds);b.length&gt;d.length&amp;&amp;a.each(b,function(a,b){c.createList(b)}),this.createDivider(),this.createDivider(),a(this.dividers[0]).insertBefore(this.lists[this.lists.length-2].$el),a(this.dividers[1]).insertBefore(this.lists[this.lists.length-4].$el),this.base()},flip:function(a,b){this.autoIncrement(),a=a?a:this.factory.time.getMilitaryTime(!1,this.showSeconds),this.base(a,b)}})}(jQuery),function(a){FlipClock.CounterFace=FlipClock.Face.extend({shouldAutoIncrement:!1,constructor:function(a,b){&quot;object&quot;!=typeof b&amp;&amp;(b={}),a.autoStart=b.autoStart?!0:!1,b.autoStart&amp;&amp;(this.shouldAutoIncrement=!0),a.increment=function(){a.countdown=!1,a.setTime(a.getTime().getTimeSeconds()+1)},a.decrement=function(){a.countdown=!0;var b=a.getTime().getTimeSeconds();b&gt;0&amp;&amp;a.setTime(b-1)},a.setValue=function(b){a.setTime(b)},a.setCounter=function(b){a.setTime(b)},this.base(a,b)},build:function(){var b=this,c=this.factory.$el.find(&quot;ul&quot;),d=this.factory.getTime().digitize([this.factory.getTime().time]);d.length&gt;c.length&amp;&amp;a.each(d,function(a,c){var d=b.createList(c);d.select(c)}),a.each(this.lists,function(a,b){b.play()}),this.base()},flip:function(a,b){this.shouldAutoIncrement&amp;&amp;this.autoIncrement(),a||(a=this.factory.getTime().digitize([this.factory.getTime().time])),this.base(a,b)},reset:function(){this.factory.time=new FlipClock.Time(this.factory,this.factory.original?Math.round(this.factory.original):0),this.flip()}})}(jQuery),function(a){FlipClock.DailyCounterFace=FlipClock.Face.extend({showSeconds:!0,constructor:function(a,b){this.base(a,b)},build:function(b){var c=this,d=this.factory.$el.find(&quot;ul&quot;),e=0;b=b?b:this.factory.time.getDayCounter(this.showSeconds),b.length&gt;d.length&amp;&amp;a.each(b,function(a,b){c.createList(b)}),this.showSeconds?a(this.createDivider(&quot;Seconds&quot;)).insertBefore(this.lists[this.lists.length-2].$el):e=2,a(this.createDivider(&quot;Minutes&quot;)).insertBefore(this.lists[this.lists.length-4+e].$el),a(this.createDivider(&quot;Hours&quot;)).insertBefore(this.lists[this.lists.length-6+e].$el),a(this.createDivider(&quot;Days&quot;,!0)).insertBefore(this.lists[0].$el),this.base()},flip:function(a,b){a||(a=this.factory.time.getDayCounter(this.showSeconds)),this.autoIncrement(),this.base(a,b)}})}(jQuery),function(a){FlipClock.HourlyCounterFace=FlipClock.Face.extend({constructor:function(a,b){this.base(a,b)},build:function(b,c){var d=this,e=this.factory.$el.find(&quot;ul&quot;);c=c?c:this.factory.time.getHourCounter(),c.length&gt;e.length&amp;&amp;a.each(c,function(a,b){d.createList(b)}),a(this.createDivider(&quot;Seconds&quot;)).insertBefore(this.lists[this.lists.length-2].$el),a(this.createDivider(&quot;Minutes&quot;)).insertBefore(this.lists[this.lists.length-4].$el),b||a(this.createDivider(&quot;Hours&quot;,!0)).insertBefore(this.lists[0].$el),this.base()},flip:function(a,b){a||(a=this.factory.time.getHourCounter()),this.autoIncrement(),this.base(a,b)},appendDigitToClock:function(a){this.base(a),this.dividers[0].insertAfter(this.dividers[0].next())}})}(jQuery),function(a){FlipClock.MinuteCounterFace=FlipClock.HourlyCounterFace.extend({clearExcessDigits:!1,constructor:function(a,b){this.base(a,b)},build:function(){this.base(!0,this.factory.time.getMinuteCounter())},flip:function(a,b){a||(a=this.factory.time.getMinuteCounter()),this.base(a,b)}})}(jQuery),function(a){FlipClock.TwelveHourClockFace=FlipClock.TwentyFourHourClockFace.extend({meridium:!1,meridiumText:&quot;AM&quot;,build:function(){var b=this.factory.time.getTime(!1,this.showSeconds);this.base(b),this.meridiumText=this.getMeridium(),this.meridium=a(['<UL class="flip-clock-meridium">',&quot;<LI>&quot;,'&lt;a href=&quot;#&quot;&gt;'+this.meridiumText+&quot;&lt;/a&gt;&quot;,&quot;</LI>&quot;,&quot;</UL>&quot;].join(&quot;&quot;)),this.meridium.insertAfter(this.lists[this.lists.length-1].$el)},flip:function(a,b){this.meridiumText!=this.getMeridium()&amp;&amp;(this.meridiumText=this.getMeridium(),this.meridium.find(&quot;a&quot;).html(this.meridiumText)),this.base(this.factory.time.getTime(!1,this.showSeconds),b)},getMeridium:function(){return(new Date).getHours()&gt;=12?&quot;PM&quot;:&quot;AM&quot;},isPM:function(){return&quot;PM&quot;==this.getMeridium()?!0:!1},isAM:function(){return&quot;AM&quot;==this.getMeridium()?!0:!1}})}(jQuery),function(a){FlipClock.Lang.Arabic={years:&quot;سنوات&quot;,months:&quot;شهور&quot;,days:&quot;أيام&quot;,hours:&quot;ساعات&quot;,minutes:&quot;دقائق&quot;,seconds:&quot;ثواني&quot;},FlipClock.Lang.ar=FlipClock.Lang.Arabic,FlipClock.Lang[&quot;ar-ar&quot;]=FlipClock.Lang.Arabic,FlipClock.Lang.arabic=FlipClock.Lang.Arabic}(jQuery),function(a){FlipClock.Lang.Danish={years:&quot;År&quot;,months:&quot;Måneder&quot;,days:&quot;Dage&quot;,hours:&quot;Timer&quot;,minutes:&quot;Minutter&quot;,seconds:&quot;Sekunder&quot;},FlipClock.Lang.da=FlipClock.Lang.Danish,FlipClock.Lang[&quot;da-dk&quot;]=FlipClock.Lang.Danish,FlipClock.Lang.danish=FlipClock.Lang.Danish}(jQuery),function(a){FlipClock.Lang.German={years:&quot;Jahre&quot;,months:&quot;Monate&quot;,days:&quot;Tage&quot;,hours:&quot;Stunden&quot;,minutes:&quot;Minuten&quot;,seconds:&quot;Sekunden&quot;},FlipClock.Lang.de=FlipClock.Lang.German,FlipClock.Lang[&quot;de-de&quot;]=FlipClock.Lang.German,FlipClock.Lang.german=FlipClock.Lang.German}(jQuery),function(a){FlipClock.Lang.English={years:&quot;Years&quot;,months:&quot;Months&quot;,days:&quot;Days&quot;,hours:&quot;Hours&quot;,minutes:&quot;Minutes&quot;,seconds:&quot;Seconds&quot;},FlipClock.Lang.en=FlipClock.Lang.English,FlipClock.Lang[&quot;en-us&quot;]=FlipClock.Lang.English,FlipClock.Lang.english=FlipClock.Lang.English}(jQuery),function(a){FlipClock.Lang.Spanish={years:&quot;Años&quot;,months:&quot;Meses&quot;,days:&quot;Días&quot;,hours:&quot;Horas&quot;,minutes:&quot;Minutos&quot;,seconds:&quot;Segundos&quot;},FlipClock.Lang.es=FlipClock.Lang.Spanish,FlipClock.Lang[&quot;es-es&quot;]=FlipClock.Lang.Spanish,FlipClock.Lang.spanish=FlipClock.Lang.Spanish}(jQuery),function(a){FlipClock.Lang.Finnish={years:&quot;Vuotta&quot;,months:&quot;Kuukautta&quot;,days:&quot;Päivää&quot;,hours:&quot;Tuntia&quot;,minutes:&quot;Minuuttia&quot;,seconds:&quot;Sekuntia&quot;},FlipClock.Lang.fi=FlipClock.Lang.Finnish,FlipClock.Lang[&quot;fi-fi&quot;]=FlipClock.Lang.Finnish,FlipClock.Lang.finnish=FlipClock.Lang.Finnish}(jQuery),function(a){FlipClock.Lang.French={years:&quot;Ans&quot;,months:&quot;Mois&quot;,days:&quot;Jours&quot;,hours:&quot;Heures&quot;,minutes:&quot;Minutes&quot;,seconds:&quot;Secondes&quot;},FlipClock.Lang.fr=FlipClock.Lang.French,FlipClock.Lang[&quot;fr-ca&quot;]=FlipClock.Lang.French,FlipClock.Lang.french=FlipClock.Lang.French}(jQuery),function(a){FlipClock.Lang.Italian={years:&quot;Anni&quot;,months:&quot;Mesi&quot;,days:&quot;Giorni&quot;,hours:&quot;Ore&quot;,minutes:&quot;Minuti&quot;,seconds:&quot;Secondi&quot;},FlipClock.Lang.it=FlipClock.Lang.Italian,FlipClock.Lang[&quot;it-it&quot;]=FlipClock.Lang.Italian,FlipClock.Lang.italian=FlipClock.Lang.Italian}(jQuery),function(a){FlipClock.Lang.Latvian={years:&quot;Gadi&quot;,months:&quot;Mēneši&quot;,days:&quot;Dienas&quot;,hours:&quot;Stundas&quot;,minutes:&quot;Minūtes&quot;,seconds:&quot;Sekundes&quot;},FlipClock.Lang.lv=FlipClock.Lang.Latvian,FlipClock.Lang[&quot;lv-lv&quot;]=FlipClock.Lang.Latvian,FlipClock.Lang.latvian=FlipClock.Lang.Latvian}(jQuery),function(a){FlipClock.Lang.Dutch={years:&quot;Jaren&quot;,months:&quot;Maanden&quot;,days:&quot;Dagen&quot;,hours:&quot;Uren&quot;,minutes:&quot;Minuten&quot;,seconds:&quot;Seconden&quot;},FlipClock.Lang.nl=FlipClock.Lang.Dutch,FlipClock.Lang[&quot;nl-be&quot;]=FlipClock.Lang.Dutch,FlipClock.Lang.dutch=FlipClock.Lang.Dutch}(jQuery),function(a){FlipClock.Lang.Norwegian={years:&quot;År&quot;,months:&quot;Måneder&quot;,days:&quot;Dager&quot;,hours:&quot;Timer&quot;,minutes:&quot;Minutter&quot;,seconds:&quot;Sekunder&quot;},FlipClock.Lang.no=FlipClock.Lang.Norwegian,FlipClock.Lang.nb=FlipClock.Lang.Norwegian,FlipClock.Lang[&quot;no-nb&quot;]=FlipClock.Lang.Norwegian,FlipClock.Lang.norwegian=FlipClock.Lang.Norwegian}(jQuery),function(a){FlipClock.Lang.Portuguese={years:&quot;Anos&quot;,months:&quot;Meses&quot;,days:&quot;Dias&quot;,hours:&quot;Horas&quot;,minutes:&quot;Minutos&quot;,seconds:&quot;Segundos&quot;},FlipClock.Lang.pt=FlipClock.Lang.Portuguese,FlipClock.Lang[&quot;pt-br&quot;]=FlipClock.Lang.Portuguese,FlipClock.Lang.portuguese=FlipClock.Lang.Portuguese}(jQuery),function(a){FlipClock.Lang.Russian={years:&quot;лет&quot;,months:&quot;месяцев&quot;,days:&quot;дней&quot;,hours:&quot;часов&quot;,minutes:&quot;минут&quot;,seconds:&quot;секунд&quot;},FlipClock.Lang.ru=FlipClock.Lang.Russian,FlipClock.Lang[&quot;ru-ru&quot;]=FlipClock.Lang.Russian,FlipClock.Lang.russian=FlipClock.Lang.Russian}(jQuery),function(a){FlipClock.Lang.Swedish={years:&quot;År&quot;,months:&quot;Månader&quot;,days:&quot;Dagar&quot;,hours:&quot;Timmar&quot;,minutes:&quot;Minuter&quot;,seconds:&quot;Sekunder&quot;},FlipClock.Lang.sv=FlipClock.Lang.Swedish,FlipClock.Lang[&quot;sv-se&quot;]=FlipClock.Lang.Swedish,FlipClock.Lang.swedish=FlipClock.Lang.Swedish}(jQuery),function(a){FlipClock.Lang.Chinese={years:&quot;年&quot;,months:&quot;月&quot;,days:&quot;日&quot;,hours:&quot;时&quot;,minutes:&quot;分&quot;,seconds:&quot;秒&quot;},FlipClock.Lang.zh=FlipClock.Lang.Chinese,FlipClock.Lang[&quot;zh-cn&quot;]=FlipClock.Lang.Chinese,FlipClock.Lang.chinese=FlipClock.Lang.Chinese}(jQuery);

</DIV></DIV></DIV></DIV></DIV></BODY></HTML>
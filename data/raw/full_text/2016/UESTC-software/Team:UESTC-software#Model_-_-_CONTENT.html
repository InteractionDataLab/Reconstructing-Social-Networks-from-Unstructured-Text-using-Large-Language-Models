<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_UESTC-software_Model skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:UESTC-software/Model</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P><TITLE>three</TITLE></P><DIV class="header-content"><NAV class="main-nav"><UL><LI><A href="https://2016.igem.org/Team:UESTC-software">HOME</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Project?id=0">PROJECT</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Description">Description</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Design">Design</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Features">Features</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Model">Modeling</A></LI><LI class="three-nav"><A href="https://2016.igem.org/Team:UESTC-software/Proof">Proof</A></LI><LI class="three-nav"><A href="https://2016.igem.org/Team:UESTC-software/Demonstrate">Results</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Future">Future</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Parts">Parts</A></LI><LI class="three-nav"><A href="https://2016.igem.org/Team:UESTC-software/Extra_work">Extra Work—Bio2048</A></LI></UL><LI><A href="https://2016.igem.org/Team:UESTC-software/Judging?id=1">JUDGING</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Medal_requirements">Medal Requirements</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Safety?">Safety</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Team?id=2">TEAM</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Members?id=2&amp;index=0">Team</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Collaborations">Collaborations</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Notebooks">Notebooks</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/HP">HUMAN PRACTICES</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/HP/Silver">Silver</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/HP/Gold">Gold</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Integrated_Practices">Integrated Practices</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Engagement">Engagement</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Document">DOCUMENTS</A></LI><LI><A href="https://2016.igem.org/Team:UESTC-software/Attributions">ATTRIBUTIONS</A></LI></NAV></DIV><DIV class="content-top"><P class="title">Modeling</P></DIV><DIV class="detail-content"><P>Our project is mainly centered on how to improve the storage density and avoid the mistakes that may occur during the process of designing a stable, high-density DNA information storage system. There are two main technological processes, encoding and decoding, in the system.</P><P class="img-p" style="font-size:13px;"><B>Fig.1.</B>system flow diagram.</P><H2 id="Encoding">Encoding</H2><STRONG>Compression: bzip2 algorithm <SUP>[1]</SUP></STRONG><P>We used bzip2 algorithm which renowned as a high-quality data compression algorithm to compress the file. It typically compresses files to within 10% to 15% of the best available techniques, whilst being around twice faster at compression and six times faster at decompression. After this process, we get a bz2 compression file.</P><STRONG>Encryption: ISAAC64 encryption algorithm <SUP>[2]</SUP></STRONG><P>Next, we use ISAAC64 encryption algorithm to encrypt the bz2 file. After you input your own password, ISAAC generates a pseudorandom stream of bits (a keystream). As with any stream cipher, these can be used for encryption by combining it with the plaintext using bit-wise exclusive-or; decryption is performed the same way (since exclusive-or with given data is an involution). After this process, we can get a sufficiently random binary file.</P><P class="img-p" style="font-size:13px;"><B>Fig.2.</B> encryption process.</P><STRONG>Bit-to-nt conversion: quanternary system</STRONG><P>In bit-to-nt conversion process, we use the idea of quaternary system. As we all know, there are four basic groups—A, T, C, G, and it can be seen as a quaternary system. In bit-to-nt conversion, one byte of bits converts into four bytes of A, T, C, G, using the scheme illustrated in Table 1.</P><P class="img-p" style="font-size:13px;"><B>Tab.1.</B>Bit-to-nt conversion.</P><P>We read out the binary string S0 of the binary file generated in the last process. Use bit-to-nt conversion to convert S0 into a DNA string S1. We get a long DNA sequence. </P><STRONG>Fragmenting &amp; indexing</STRONG><P>Write len( ) for the function that computes the length of a string, and define n=len(S<SUB>1</SUB>). Represent n in base-4 and prepend ‘0’s to generate a string S<SUB>2</SUB> of quaternary such that len(S<SUB>2</SUB>)=15. Form the string concatenation</P><P style="text-align:center;"><B><I>S<SUB>4</SUB>=S<SUB>1</SUB>.S<SUB>3</SUB>.S<SUB>2</SUB></I></B><I style="float:right;">(1)</I></P><P style="text-align:center;">(the symbol ‘ <B>.</B> ’ means the connection of two strings)</P><P>where S<SUB>3</SUB> is a string of at most 49 ‘0’s chosen so that len(S<SUB>4</SUB>) is an integer multiple of 50.</P><P>Convert S<SUB>2</SUB>  and S<SUB>3</SUB> to DNA strings S<SUB>2</SUB>’  and S<SUB>3</SUB>’using the scheme illustrated in Table 2. </P><P class="img-p" style="font-size:13px;"><B>Tab.2.</B>Quaternary-to-nt conversion.</P><P>Recode the DNA string S<SUB>3</SUB>’.S<SUB>2</SUB>’ from the second character to S<SUB>2</SUB>’’ with repeated nucleotides as few as possible using the scheme illustrated in Table 3.</P><P class="img-p" style="font-size:13px;"><B>Tab.3.</B>Recoding table.</P><P>From</P><P style="text-align:center;"><B><I>S<SUB>5</SUB>=S<SUB>1</SUB>.S<SUB>2</SUB>’’</I></B><I style="float:right;">(2)</I></P><P>Define N=len(S<SUB>5</SUB>). Split S<SUB>5</SUB> into overlapping segments of length 200 nt, each offset from the previous by 50 nt. This means there will be N/50-3 segments, conveniently indexed</P><P style="text-align:center;"><B><I>i = 0 , 1······, N/50-4 </I></B><I style="float:right;">(3)</I></P><P>segment i is denoted F_i and contains (DNA) characters</P><P style="text-align:center;"><B><I>50i, …, 50i+199</I></B><I style="float:right;">(4)</I></P><P>of S<SUB>5</SUB>. If i is odd, reverse complement F<SUB>i</SUB>.</P><P>Let i4 be the base-4 representation of i, appending enough leading ‘0’s so that</P><P style="text-align:center;"><B><I>len(i4)=12</I></B><I style="float:right;">(5)</I></P><P>Recode i4 using the same strategy in Table 2 &amp; Table 3 above, and i4 is represented in nt.</P><STRONG>Even-odd check</STRONG><P>Compute P as the sum(mod 4) of the even-positioned quaternary in i4.</P><P style="text-align:center;"><B><I>P=(i4<SUB>2</SUB>+i4<SUB>4</SUB>+i4<SUB>6</SUB>+i4<SUB>8</SUB>+i4<SUB>10</SUB>+i4<SUB>12</SUB>)mod 4</I></B><I style="float:right;">(6)</I></P><P>P acts as a ‘parity quaternary’—analogous to a parity bit—to check for errors in the encoded information about i.Form the indexing information string </P><P style="text-align:center;"><B><I>IX=i4.P </I></B><I style="float:right;">(7)</I></P><P>segment i is denoted F<SUB>i</SUB> and contains (DNA) characters </P><P style="text-align:center;"><B><I>50i, ......, 50i+199</I></B><I style="float:right;">(8)</I></P><P>of S<SUB>5</SUB>. If i is odd, reverse complement F<SUB>i</SUB>.</P><P>Let i4 be the base-4 representation of i, appending enough leading ‘0’s so that</P><P style="text-align:center;"><B><I>len(i4) = 12</I></B><I style="float:right;">(9)</I></P><P>Recode i4 using the same strategy in Table 2 &amp; Table 3 above, and i4 is represented in nt.</P><P>Compute P as the sum(mod 4) of the even-positioned quaternary in i4. </P><P style="text-align:center;"><B><I>P = (i4<SUB>2</SUB>+i4<SUB>4</SUB>+i4<SUB>6</SUB>+i4<SUB>8</SUB>+i4<SUB>10</SUB>+i4<SUB>12</SUB> )  mod 4</I></B><I style="float:right;">(10)</I></P><P>P acts as a ‘parity quaternary’—analogous to a parity bit—to check for errors in the encoded information about i.Form the indexing information string </P><P style="text-align:center;"><B><I>IX = i4.P</I></B><I style="float:right;">(11)</I></P><P style="margin-left:290px;">(comprising 12+1=13 nt)</P><P>Append the DNA-encoded version of IX to F<SUB>i</SUB> to give indexed segment F<SUB>i</SUB>’. </P><STRONG>Direction tag</STRONG><P>Then form F<SUB>i</SUB>’’ by prepending A or T and appending C or G to F<SUB>i</SUB>’ —choosing between A and T, and between C and G, randomly if possible but always such that there is no repeated nt. This ensures that we can distinguish a DNA segment that has been reverse complemented during DNA sequencing from one that has not—the former will start with G|C and end with T|A; the latter will start A|T and end C|G. </P><P>The segment F<SUB>i</SUB>’’ are synthesized as actual DNA oligonucleotides and stored, and may be supplied for sequencing. </P><P class="img-p" style="font-size:13px;"><B>Fig.3.</B>Fragmenting &amp; Indexing.</P><STRONG>Safety testing: BLAST</STRONG><P>In order to check whether the sequences we generated are safe, we use BLAST for sequence alignment. We do sequence alignment via the NCBI database to ensure accuracy. At the same time of generating the DNA sequences file, we also provide the BLAST report for downloading. </P><H2 id="Decoding">Decoding </H2><STRONG>Recognition of the front and the end of a sequence</STRONG><P>Reverse complementation during the DNA sequencing procedure(e.g. during PCR reactions) can be identified for subsequent reversal by observing whether fragments start with A|T and end with C|G, or start with G|C and end with T|A. </P><STRONG>Reading and checking of index</STRONG><P>With these two ‘orientation’ nt removed, the remaining 213 nt of each segment can be split into the first 200 ‘message’ nt and the remaining 13 ‘indexing’ nt. Decode  the ‘indexing’ nt to quanternary using the reverse of the encoding tables in in Table 2 &amp; Table 3 above, and use P to check the correctness of i4.</P><STRONG>Correction of segments through four-fold redundancy</STRONG><P>Use i to determine the location of each fragment. Split each fragment into segments of length 50 nt. As we provide a four-fold redundancy, we compare the 50-nt segments which are in the same location and inaccurate bases can be corrected by using majority vote. Connect all the segments to a whole DNA sequence.</P><STRONG>Decoding, decryption and decompression</STRONG><P>Decode the DNA sequence by using the reverse of the encoding table in Table 1 above, and use ISAAC64 to decrypt it, and then decompress. We get the original file.</P><STRONG>Fuzzy matching with high-throughput sequencing</STRONG><P>Errors introduced during DNA synthesis, storage or sequencing could lead to various nt insertion, deletion or substitution. Recovery of information from fragments with such errors may be possible via PCR amplification and high-throughput sequencing.</P><H2 id="Example">Example</H2><P>In order to make our encoding process more understandable and clearer, we show an example here.</P><P>With a given text file, we read out its binary file, then compress it with bzip2 algorithm, and use a pseudorandom stream of bits to encrypt it. Then use bit-to-nt conversion to convert the binary numbers to bases. Shown in Figure 4.</P><P class="img-p" style="font-size:13px;"><B>Fig.4.</B>Schematic of DNA information storage system.</P><P>The computer file (in any format, e.g. text) shown in (a) is read in binary format (b), and use bzip2 to compress it (c). Then through ISAAC encryption algorithm use pseudorandom stream of bits (d) and exclusive-or to generate a new binary string (e). Then one byte of bits converts into four bytes of A, T, C, G (e).</P><P>1. Towards the text file “IGEM UESTC-SOFTWARE”, its binary coding is</P><P>2. After compressing, its compressed coding is:</P><P>3. With the pseudorandom stream of bits that ISAAC64 generated (password: uestc-software):</P><P style="text-align:center; color:#0c1bfc;"><B>10111100 00011010 11000010 01101101 ......</B></P><P>Using XOR operation: </P><P style="text-align:center;">S’  XOR (pseudorandom stream of bits)</P><P>We get a new binary string S<SUB>0</SUB>:</P><P>4. Using the scheme illustrated in Table 1, we convert the bytes of S<SUB>0</SUB> into bases—A, T, C, G.</P><P>5.  n=len(S<SUB>1</SUB> )=3376, which is 310300 in base-4. S<SUB>o</SUB>:</P><P style="text-align:center;"><I><B>len(S<SUB>4</SUB> )=len(S<SUB>1</SUB> )+len(S<SUB>2</SUB> )+len(S<SUB>3</SUB> ) = 3376 + 15 + 9 = 3400 = 50 * 68</B></I></P><P>6.  Using the scheme illustrated in Table 2, convert S<SUB>2</SUB> and S<SUB>3</SUB> to DNA:</P><P>Recode the DNA string S<SUB>3</SUB>’ . S<SUB>2</SUB>’ from the second character to S<SUB>2</SUB>’’ with repeated nucleotides as few as possible, using the scheme illustrated in Table 3.</P><P>7.  N=len(S<SUB>5</SUB> )=3400. We split S<SUB>5</SUB> into overlapping segments of length 200 nt, each offset from the previous by 50 nt.</P><P>S<SUB>5</SUB> will be split into overlapping segments F<SUB>i</SUB> of length 200 nt for</P><P style="text-align:center;"><I><B>i=0......(3400/50)-4, i=0,1,......,64</B></I></P><P>With overlapping parts underlined for illustration, F<SUB>0</SUB> to F<SUB>i</SUB> are:</P><P>8.  Only i=1,3,...,63 are odd, so F<SUB>i</SUB> is reverse complemented: </P><P>9.  For i=0,i4=000000000000 (length 12) and the sum (mod 4) of the even-positioned quaternaries of i4 is </P><P style="text-align:center;"><I><B>P = (0+0+0+0+0+0)(mod 4) = 0</B></I></P><P>For i=1,i4=000000000001</P><P style="text-align:center;"><I><B>P = (0+0+0+0+0+1)(mod 4) = 1</B></I></P><P>For i=0,IX=i4.P=0000000000000</P><P>For i=0,IX=i4.P=0000000000011.</P><P>So: </P><P>11.  Prepend A|T and append C|G (in this example we have three random choice, at the front of F<SUB>0</SUB>’’, the end of F<SUB>0</SUB>’’, and the end of F<SUB>1</SUB>’’):</P><H2 id="A system which enable random access and information rewriting">A system which enable random access and information rewriting</H2><P>As a perfect information storage system, random access and information rewriting are essential. So we design another set of system which enable users recompose information stored in DNA sequences easily. </P><STRONG>Fragmenting</STRONG><P>We read the binary code of a file, and divide the binary number into blocks of length 32 bytes. </P><STRONG>Encrypting independently</STRONG><P>With regard to each binary block, we use ISAAC algorithm to randomize it, which is different from encrypting the file as a whole. This ensure that we can edit the targeted data without influence other file data.</P><STRONG>Bit-to-nt conversion</STRONG><P>Transform each binary block to DNA sequences S1, using the same scheme in Table 1. One binary block of 32 bytes transforms into a DNA sequence of length 128 bp. </P><STRONG>Indexing</STRONG><P>Define</P><P style="text-align: center;"><B><I>N=total number of nucleotides</I></B></P><P>With regard to each segment, conveniently indexed</P><P style="text-align:center;"><B><I>i = 0,1,2,......, [N/128]</I></B><I style="float:right;">(7)</I></P><P style="text-align: center;">([ ] means round down)</P><P>Let i4 be the base-4 representation of i, appending enough leading ‘0’s so that</P><P style="text-align: center;"><B><I>len(i4)=12</I></B></P><P>Recode i4 to nucleotide sequence using the same strategy above. Then compute the ‘parity quaternary’—P. </P><P style="text-align:center;"><B><I>P = (i4<SUB>2</SUB>+i4<SUB>4</SUB>+i4<SUB>6</SUB>+i4<SUB>8</SUB>+i4<SUB>10</SUB>+i4<SUB>12</SUB> )  mod 4</I></B></P><P>Form the indexing information string </P><P style="text-align:center;"><B><I>IX=i4.P    (length 13 bp)</I></B></P><P>Suffix PAM site ‘GG’ to IX, and prefix IX to each segment. (IX length = 15 bp)
                prepending A or T and appending C or G to each segment using the same scheme above. 
                </P><P style="text-align:center;"><B><I>One sequence length = 1+15+128+1=145 bp</I></B></P><STRONG>Design of sgRNA</STRONG><P>Towards the sequence needed to be edited, find the location of PAM site, and read out its downstream sequence of length 20 bp as the guide region. </P><P>To realize information edit function, we need to target and damage specific DNA segment in order to replace it by new supplement DNA. We introduce Cas9, which is an RNA-guided DNA endonuclease enzyme associated with the CRISP. SgRNA which consists of guide region (sgRNA coding aspect) and dCas9 handle(Cas9 binding aspect), can help Cas9 to identify specific DNA binding sites then guide Cas9 to bind with this site, generating a sgRNA-Cas9-dsDNA  CMPX. This Cas9 cut dsDNA and destroy it. We design sgRNA’s biobrick part according to edited DNA segment, whose transcription sgRNA can guide Cas9 cut this segment specifically.</P><H2 id="References">References</H2><UL><LI style="font-size:13px;">[1]  bzip2 [online] http://www.bzip.org/</LI><LI style="font-size:13px;">[2]  Robert J. Jenkins Jr. (1996) ISAAC: a fast cryptographic random number generator FSE 1996: 41-49  http://burtleburtle.net/bob/rand/isaacafa.html</LI><LI style="font-size:13px;">[3]  NCBI Basic Local Alignment Search Tool [online] https://blast.ncbi.nlm.nih.gov/Blast.cgi</LI><LI style="font-size:13px;">[4]  Alec AK Nielsen &amp; Christopher A Voigt (2014) Multi-input CRISPR/Cas genetic circuits that interface host regulatory networks.  Molecular Systems Biology 10: 763 | 2014</LI></UL></DIV></DIV><FOOTER class="footer"><DIV class="footer-top"><P>FOLLOW US：
            </P><P>UESTC-SOFTWARE</P></DIV><DIV class="footer-bottom">© 2016 University of Electronic Science and Technology of China</DIV></FOOTER><DIV class="catalog"><SPAN>CATALOGUE</SPAN></DIV><DIV class="catalog-area"><DIV class="title">CATALOGUE</DIV><UL><LI><A href="#Encoding">
               Encoding
            </A></LI><LI><A href="#Decoding">
               Dcoding
            </A></LI><LI><A href="#Example">
               Example
            </A></LI></UL></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
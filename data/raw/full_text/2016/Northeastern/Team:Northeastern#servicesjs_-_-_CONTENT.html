<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Northeastern_servicesjs skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Northeastern/servicesjs</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*global angular*/
(function () {
</P><PRE>   'use strict';
</PRE><PRE>   angular.module(&quot;angularplasmid.services&quot;, [])
</PRE><PRE>        .factory(&quot;SVGUtil&quot;, function () {
           /*
               PUBLIC API
               -----------------------------------------------------------------------
               api - API for working with AngularPlasmid objects on a page
               util - General utilities
               svg - SVG node, path calculations
           */
</PRE><PRE>           var plasmids = [], tracks = [], markers = [];
</PRE><PRE>           // Decimal round with precision
           function round10(value, exp) {
               var type = 'round';
               // If the exp is undefined or zero...
               if (typeof exp === 'undefined' || +exp === 0) {
                   return Math[type](value);
               }
               value = +value;
               exp = +exp;
               // If the value is not a number or the exp is not an integer...
               if (isNaN(value) || !(typeof exp === 'number' &amp;&amp; exp % 1 === 0)) {
                   return NaN;
               }
               // Shift
               value = value.toString().split('e');
               value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
               // Shift back
               value = value.toString().split('e');
               return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
           }
</PRE><PRE>           function addPlasmid(plasmid) {
               plasmids.push(plasmid);
           }
            
           function plasmid(id) {
               var i;
               for (i = 0; i &lt; plasmids.length; i += 1) {
                   if (plasmids[i].id === id) {
                       return plasmids[i];
                   }
               }
           }
            
           function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
               var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
               return {
                   x: centerX + (radius * Math.cos(angleInRadians)),
                   y: centerY + (radius * Math.sin(angleInRadians))
               };
           }
</PRE><PRE>           function swapProperties(elemFrom, elemTo) {
               var property, fromProp, i,
                   PROPLIST = ['id', 'name', 'class', 'style', 'filter', 'ng-attr-style', 'ng-attr-class','ng-class'];
</PRE><PRE>               for (i = 0; i &lt; PROPLIST.length; i += 1) {
                   property = PROPLIST[i];
                   if (elemFrom[0].hasAttribute(property)) {
                       elemTo.attr(property, elemFrom.attr(property));
                       elemFrom.removeAttr(property);
                   }
               }
           }
</PRE><PRE>           function createNode(name, settings, excludeSettings) {
               var namespace = '<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg'">http://www.w3.org/2000/svg'</A>,
                   node = document.createElementNS(namespace, name),
                   attribute,
                   value;
</PRE><PRE>               excludeSettings = excludeSettings || [];
               angular.forEach(settings, function (attribute) {
                   if (excludeSettings.indexOf(attribute) &lt; 0) {
                       value = settings[attribute];
                       if (value !== null &amp;&amp; !attribute.match(/\$/) &amp;&amp; (typeof value !== 'string' || value !== <I>)) {</I>
                           node.setAttribute(attribute, value);
                       }
                   }
               });
               return node;
           }
</PRE><PRE>           function removeAttributes(element) {
               angular.forEach(['id', 'class', 'style'], function (a) {
                   element.removeAttribute(a);
               });
           }
</PRE><PRE>           function pathDonut(x, y, radius, width) {
               var innerRing, outerRing, path;
</PRE><PRE>               x = Number(x || 0);
               y = Number(y || 0);
               radius = Number(radius || 0);
               width = Number(width || 0);
</PRE><PRE>               innerRing = {
                   start : polarToCartesian(x, y, radius, 359.99),
                   end : polarToCartesian(x, y, radius, 0)
               };
</PRE><PRE>               outerRing = {
                   start : polarToCartesian(x, y, radius + width, 359.99),
                   end : polarToCartesian(x, y, radius + width, 0)
               };
</PRE><PRE>               path = [    &quot;M&quot;, innerRing.start.x, innerRing.start.y,
                               &quot;A&quot;, radius, radius, 0, 1, 0, innerRing.end.x, innerRing.end.y,
                               &quot;M&quot;, outerRing.start.x, outerRing.start.y,
                               &quot;A&quot;, radius + width, radius + width, 0, 1, 0, outerRing.end.x, outerRing.end.y
                           ].join(&quot; &quot;);
</PRE><PRE>               return path;
           }
</PRE><PRE>           function pathArc(x, y, radius, startAngle, endAngle, width, arrowStart, arrowEnd) {
               var d, start, start2, end, arcSweep, arrow_start_1, arrow_start_2, arrow_start_3, arrow_start_4, arrow_end_1, arrow_end_2, arrow_end_3, arrow_end_4;
</PRE><PRE>               x = Number(x);
               y = Number(y);
               radius = Number(radius);
               startAngle = Number(startAngle);
               endAngle = Number(endAngle);
               width = Number(width);
               arrowStart = arrowStart || {width : 0, length : 0, angle: 0};
               arrowEnd = arrowEnd || {width : 0, length : 0, angle: 0};
</PRE><PRE>               if (startAngle === endAngle) {
                   // Draw a line
                   start = polarToCartesian(x, y, radius, startAngle);
                   end = polarToCartesian(x, y, radius + width, startAngle);
                   d = [&quot;M&quot;, start.x, start.y, &quot;L&quot;, end.x, end.y].join(&quot; &quot;);
               } else {
                   //Draw a &quot;simple&quot; arc if the width is 1
                   if (width === 1) {
                       start = polarToCartesian(x, y, radius, startAngle);
                       end = polarToCartesian(x, y, radius, endAngle);
                       if (startAngle &lt; endAngle) {
                           arcSweep = endAngle - startAngle &lt;= 180 ? &quot;0&quot; : &quot;1&quot;;
                       } else {
                           arcSweep = endAngle - startAngle &lt;= 180 ? &quot;1&quot; : &quot;0&quot;;
                       }
                       d = [&quot;M&quot;, start.x, start.y, &quot;A&quot;, radius, radius, 0, arcSweep, 1, end.x, end.y].join(&quot; &quot;);
                   } else {
</PRE><PRE>                       // Draw a &quot;complex&quot; arc (We start drawing in reverse, which is why start uses endAngle)
                       endAngle = endAngle - (arrowEnd.length &lt; 0 ? 0 : arrowEnd.length);
                       startAngle = startAngle + (arrowStart.length &lt; 0 ? 0 : arrowStart.length);
                       start = polarToCartesian(x, y, radius, endAngle);
                       end = polarToCartesian(x, y, radius, startAngle);
                       arrow_start_1 = polarToCartesian(x, y, radius - arrowStart.width, startAngle + arrowStart.angle);
                       arrow_start_2 = polarToCartesian(x, y, radius + (width / 2), startAngle - arrowStart.length);
                       arrow_start_3 = polarToCartesian(x, y, radius + width + arrowStart.width, startAngle + arrowStart.angle);
                       arrow_start_4 = polarToCartesian(x, y, radius + width, startAngle);
                       arrow_end_1 = polarToCartesian(x, y, radius + width + arrowEnd.width, endAngle - arrowEnd.angle);
                       arrow_end_2 = polarToCartesian(x, y, radius + (width / 2), endAngle + arrowEnd.length);
                       arrow_end_3 = polarToCartesian(x, y, radius - arrowEnd.width, endAngle - arrowEnd.angle);
                       arrow_end_4 = polarToCartesian(x, y, radius, endAngle);
                       start2 = polarToCartesian(x, y, radius + width, endAngle);
                       arcSweep = endAngle - startAngle &lt;= 180 ? &quot;0&quot; : &quot;1&quot;;
                       d = [&quot;M&quot;, start.x, start.y, &quot;A&quot;, radius, radius, 0, arcSweep, 0, end.x, end.y, &quot;L&quot;, arrow_start_1.x, arrow_start_1.y, &quot;L&quot;, arrow_start_2.x, arrow_start_2.y, &quot;L&quot;, arrow_start_3.x, arrow_start_3.y, &quot;L&quot;, arrow_start_4.x, arrow_start_4.y, &quot;A&quot;, radius + width, radius + width, 0, arcSweep, 1, start2.x, start2.y, &quot;L&quot;, arrow_end_1.x, arrow_end_1.y, &quot;L&quot;, arrow_end_2.x, arrow_end_2.y, &quot;L&quot;, arrow_end_3.x, arrow_end_3.y, &quot;L&quot;, arrow_end_4.x, arrow_end_4.y, &quot;z&quot;].join(&quot; &quot;);
                   }
               }
</PRE><PRE>               return d;
           }
</PRE><PRE>           function pathScale(x, y, radius, interval, total, tickLength) {
</PRE><PRE>               x = Number(x || 0);
               y = Number(y || 0);
               radius = Number(radius || 0);
               interval = Number(interval || 0);
               total = Number(total || 0);
               tickLength = Number(tickLength || 2);
</PRE><PRE>               var alpha, sin, cos, i,
                   numTicks = Number(interval) &gt; 0 ? Number(total) / Number(interval) : 0,
                   beta = 2 * Math.PI / numTicks,
                   precision = -1,
                   d = <I>;</I></PRE><PRE>               for (i = 0; i &lt; numTicks; i += 1) {
                   alpha = beta * i - Math.PI / 2;
                   cos = Math.cos(alpha);
                   sin = Math.sin(alpha);
                   d += &quot;M&quot; + round10((x + (radius * cos)), precision) + &quot;,&quot; + round10((y + (radius * sin)), precision) + &quot; L&quot; + round10((x + ((radius + tickLength) * cos)), precision) + &quot;,&quot; + round10((y + ((radius + tickLength) * sin)), precision) + &quot; &quot;;
               }
               d = d || &quot;M 0,0&quot;;
               return d;
</PRE><PRE>           }
</PRE><PRE>           function elementScaleLabels(x, y, radius, interval, total) {
</PRE><PRE>               x = Number(x);
               y = Number(y);
               radius = Number(radius);
               interval = Number(interval);
               total = Number(total);
</PRE><PRE>               var alpha, sin, cos, i,
                   numTicks = Number(interval) &gt; 0 ? Number(total) / Number(interval) : 0,
                   beta = 2 * Math.PI / numTicks,
                   precision = -1,
                   labelArr = [];
</PRE><PRE>               for (i = 0; i &lt; numTicks; i += 1) {
                   alpha = beta * i - Math.PI / 2;
                   cos = Math.cos(alpha);
                   sin = Math.sin(alpha);
                   labelArr.push({
                       x : round10((x + (radius * cos)), precision),
                       y : round10((y + (radius * sin)), precision),
                       text : interval * i
                   });
               }
               return labelArr;
</PRE><PRE>           }
</PRE><PRE>           function Numeric(numberVal, numberDefault) {
               return isNaN(numberVal) ? numberDefault || 0 : Number(numberVal);
           }
</PRE><PRE>           return {
               api : {
                   addPlasmid : addPlasmid,
                   plasmids : plasmids,
                   plasmid : plasmid,
                   plasmidtracks : tracks,
                   trackmarkers : markers
               },
               util : {
                   polarToCartesian : polarToCartesian,
                   swapProperties : swapProperties,
                   Numeric : Numeric
               },
               svg : {
                   createNode : createNode,
                   removeAttributes : removeAttributes,
                   path : {
                       donut : pathDonut,
                       arc : pathArc,
                       scale : pathScale
                   },
                   element : {
                       scalelabels : elementScaleLabels
                   }
               }
           };
</PRE><PRE>       });
</PRE><P>}());
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Newcastle_libs_synthesis-js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Newcastle/libs/synthesis-js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>var SYNTHESIS_SIM_CONSTS = {
	C : 0.1,
	degr : 0.2,
	translational_constant : 0.2,
	degp : 0.1,
	tmax : 50,
	sigmas : [],
	ps : [],
	rs : [],
	sigma2mRNA_tick : 0.25,
	sigma_production_tick : 2
}
</P><P>var PSIM_OUT = {
	p : 0,
	r : 0,
	sigma : 5,
	elapsedt: 0
}
</P><P>var PROMOTER = {
	STRONG: 0.1,
	MEDIUM: 0.03,
	WEAK: 0.0058
}
</P><P>var BIONUMBERS = {
	CELLS_PER_ML: 1 * Math.pow(10, 9)
}
</P><P>var STD_CONSTS = {
	k_transcription: PROMOTER.STRONG,
	k_translation: 0.1,
	kdeg_rna: 0.0058,
	kdeg_protein: 0.0012,
}
</P><P>var ION_BINDING_CONSTS = {
	k_ion_binding: 0.9
}
var STD_OUT = {
</P><P>}
</P><P>// Determined from trend fitted to the data in CRC Chemistry Handbook.
function zinc_conductivity(num_zinc_molecules)
{
	var m = 3 * Math.pow(10, -23);
	var c = 2 * Math.pow(10, -15);
</P><P>	return (m * num_zinc_molecules) + c;
}
</P><P>// Simulator with positive feedback :)
function sim_tick(dt, out, consts)
{
	// Sigma32
</P><PRE>   out.r = out.r + (consts.sigma2mRNA_tick * out.sigma);
   out.sigma = out.sigma - (consts.sigma2mRNA_tick * out.sigma);
   // Compute change in quantity.
   var dr = ((consts.C*out.p) - (consts.degr * out.r)) * dt;
   var dp = ((consts.translational_constant * out.r) - (consts.degp * out.p)) * dt;
   // Change quantities
   out.p = out.p + dp;
   out.r = out.r + dr;
</PRE><P>	out.elapsedt += dt;
}
</P><P>// Standard Simulator
// Refer to the original MATLAB code...
</P><P>function std_sim_tick(dt, out, consts)
{
</P><PRE>var dMRNA = ((consts.k_transcription - consts.kdeg_rna * out.r) * dt);
out.r = out.r + dMRNA;
var dProtein = ((consts.k_translation * out.r - consts.kdeg_protein * out.p) * dt);
out.p = out.p + dProtein;
out.elapsedt += dt;
</PRE><P>}
</P><P>function pulse_sim_tick(dt, out, consts)
{
	var dMRNA = ((consts.k_transcription - consts.kdeg_rna * out.r) * dt);
	out.r = out.r + dMRNA;
	var dRep = ((consts.k_translation * out.r - consts.kdeg_protein * out.repressor) * dt);
	out.repressor = out.repressor + (2 * dRep);
	var dInd = ((consts.k_translation * out.r - consts.kdeg_protein * out.inducer) * dt);
	out.inducer = out.inducer + dInd;
</P><P>	var out_translation = 0.1;
	if (out.repressor &gt; out.inducer)
	{
		out_translation = 0.001;
	}
	var dOut = ((out_translation * out.r - consts.kdeg_protein * out.p) * dt);
	out.p = out.p + dOut;
	out.elapsedt += dt;
}
</P><P>// Ion Uptake Xtra
// Tracks Ion uptake for a cell population.
function ion_uptake_pop(per_protein, k_ion_binding, out, consts, CELL_COUNT, dt) 
{
	var dBoundIon = ((per_protein * k_ion_binding * out.p) - (per_protein * consts.kdeg_protein * out.p)) * dt;
	out.boundIon = out.boundIon + (dBoundIon * CELL_COUNT);
}
</P><P>var SECONDS = 1000;
var TICK_C = 1;
var TIME_RATIO = 1; // 1sec = nsec (1ms).
</P><P>// Post function is to do anything after the update, like log the new values for a graph.
function registerSimulator(id, out, consts, post, sim_tick)
{
	// Call once so that t=0 values are in the graph.
	post(id, out);
	return setInterval(function() 
	{ 
		for (var i = 0; i &lt; Math.floor(TIME_RATIO/TICK_C); i++)
		{
			sim_tick(TICK_C, out, consts);
		}
		// console.log(out.p + &quot;,&quot; + out.r);
		post(id, out)
	}, 1 * SECONDS);
}
</P><P>// var SIM_INTERVAL_HANDLE = registerSimulator(PSIM_OUT, SYNTHESIS_SIM_CONSTS);
</P><P>function stopPSimulator()
{
	clearInterval(SIM_INTERVAL_HANDLE);
}
</P><P>function promoter_step(strength)
{
	// x = -b +/- sqrt(b^2 - 4ac)/2a
	var c = -strength;
	var l = Math.sqrt(0.0018*0.0018 - 4 * 0.0008 * c);
	l /= (2*0.0008);
	var a1 = -0.0018 + l;
	var a2 = -0.0018 - l;
	var ans = Math.floor(Math.max(a1, a2));
	return ans &gt; 10 ? 10: ans;
}
// Converts a 10-point scale into a promoter strength.
function promoter_strength(step)
{
	// Equation represents trend from standard promoter values STRONG/MED/WEAK used in models.
	return (0.0008 * (step*step)) + (0.0018 * step);
}
</P><P>$(function () {
</P><PRE>  $(&quot;#timeratio&quot;).on(/*change*/ &quot;input&quot;,
</PRE><P>	// This is the function that is invoked.
	function()
	{
		TIME_RATIO = $('#timeratio').val();
		$('#timesliderval').text(TIME_RATIO);
	});
});
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Newcastle_libs_chart-bundle-js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Newcastle/libs/chart-bundle-js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE>* Chart.js
* <A rel="nofollow" class="external free" href="http://chartjs.org/">http://chartjs.org/</A>
* Version: 2.1.6
*
* Copyright 2016 Nick Downie
* Released under the MIT license
* <A rel="nofollow" class="external free" href="https://github.com/chartjs/Chart.js/blob/master/LICENSE.md">https://github.com/chartjs/Chart.js/blob/master/LICENSE.md</A>
*/
</PRE><P>(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module '&quot;+o+&quot;'&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* MIT license */
var colorNames = require(5);
</P><P>module.exports = {
</P><PRE>  getRgba: getRgba,
  getHsla: getHsla,
  getRgb: getRgb,
  getHsl: getHsl,
  getHwb: getHwb,
  getAlpha: getAlpha,
</PRE><PRE>  hexString: hexString,
  rgbString: rgbString,
  rgbaString: rgbaString,
  percentString: percentString,
  percentaString: percentaString,
  hslString: hslString,
  hslaString: hslaString,
  hwbString: hwbString,
  keyword: keyword
</PRE><P>}
</P><P>function getRgba(string) {
</P><PRE>  if (!string) {
     return;
  }
  var abbr =  /^#([a-fA-F0-9]{3})$/,
      hex =  /^#([a-fA-F0-9]{6})$/,
      rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
      per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
      keyword = /(\w+)/;
</PRE><PRE>  var rgb = [0, 0, 0],
      a = 1,
      match = string.match(abbr);
  if (match) {
     match = match[1];
     for (var i = 0; i &lt; rgb.length; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
     }
  }
  else if (match = string.match(hex)) {
     match = match[1];
     for (var i = 0; i &lt; rgb.length; i++) {
        rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
     }
  }
  else if (match = string.match(rgba)) {
     for (var i = 0; i &lt; rgb.length; i++) {
        rgb[i] = parseInt(match[i + 1]);
     }
     a = parseFloat(match[4]);
  }
  else if (match = string.match(per)) {
     for (var i = 0; i &lt; rgb.length; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
     }
     a = parseFloat(match[4]);
  }
  else if (match = string.match(keyword)) {
     if (match[1] == &quot;transparent&quot;) {
        return [0, 0, 0, 0];
     }
     rgb = colorNames[match[1]];
     if (!rgb) {
        return;
     }
  }
</PRE><PRE>  for (var i = 0; i &lt; rgb.length; i++) {
     rgb[i] = scale(rgb[i], 0, 255);
  }
  if (!a &amp;&amp; a != 0) {
     a = 1;
  }
  else {
     a = scale(a, 0, 1);
  }
  rgb[3] = a;
  return rgb;
</PRE><P>}
</P><P>function getHsla(string) {
</P><PRE>  if (!string) {
     return;
  }
  var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
  var match = string.match(hsl);
  if (match) {
     var alpha = parseFloat(match[4]);
     var h = scale(parseInt(match[1]), 0, 360),
         s = scale(parseFloat(match[2]), 0, 100),
         l = scale(parseFloat(match[3]), 0, 100),
         a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
     return [h, s, l, a];
  }
</PRE><P>}
</P><P>function getHwb(string) {
</P><PRE>  if (!string) {
     return;
  }
  var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
  var match = string.match(hwb);
  if (match) {
   var alpha = parseFloat(match[4]);
     var h = scale(parseInt(match[1]), 0, 360),
         w = scale(parseFloat(match[2]), 0, 100),
         b = scale(parseFloat(match[3]), 0, 100),
         a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
     return [h, w, b, a];
  }
</PRE><P>}
</P><P>function getRgb(string) {
</P><PRE>  var rgba = getRgba(string);
  return rgba &amp;&amp; rgba.slice(0, 3);
</PRE><P>}
</P><P>function getHsl(string) {
</P><PRE> var hsla = getHsla(string);
 return hsla &amp;&amp; hsla.slice(0, 3);
</PRE><P>}
</P><P>function getAlpha(string) {
</P><PRE>  var vals = getRgba(string);
  if (vals) {
     return vals[3];
  }
  else if (vals = getHsla(string)) {
     return vals[3];
  }
  else if (vals = getHwb(string)) {
     return vals[3];
  }
</PRE><P>}
</P><P>// generators
function hexString(rgb) {
</P><PRE>  return &quot;#&quot; + hexDouble(rgb[0]) + hexDouble(rgb[1])
             + hexDouble(rgb[2]);
</PRE><P>}
</P><P>function rgbString(rgba, alpha) {
</P><PRE>  if (alpha &lt; 1 || (rgba[3] &amp;&amp; rgba[3] &lt; 1)) {
     return rgbaString(rgba, alpha);
  }
  return &quot;rgb(&quot; + rgba[0] + &quot;, &quot; + rgba[1] + &quot;, &quot; + rgba[2] + &quot;)&quot;;
</PRE><P>}
</P><P>function rgbaString(rgba, alpha) {
</P><PRE>  if (alpha === undefined) {
     alpha = (rgba[3] !== undefined ? rgba[3] : 1);
  }
  return &quot;rgba(&quot; + rgba[0] + &quot;, &quot; + rgba[1] + &quot;, &quot; + rgba[2]
          + &quot;, &quot; + alpha + &quot;)&quot;;
</PRE><P>}
</P><P>function percentString(rgba, alpha) {
</P><PRE>  if (alpha &lt; 1 || (rgba[3] &amp;&amp; rgba[3] &lt; 1)) {
     return percentaString(rgba, alpha);
  }
  var r = Math.round(rgba[0]/255 * 100),
      g = Math.round(rgba[1]/255 * 100),
      b = Math.round(rgba[2]/255 * 100);
</PRE><PRE>  return &quot;rgb(&quot; + r + &quot;%, &quot; + g + &quot;%, &quot; + b + &quot;%)&quot;;
</PRE><P>}
</P><P>function percentaString(rgba, alpha) {
</P><PRE>  var r = Math.round(rgba[0]/255 * 100),
      g = Math.round(rgba[1]/255 * 100),
      b = Math.round(rgba[2]/255 * 100);
  return &quot;rgba(&quot; + r + &quot;%, &quot; + g + &quot;%, &quot; + b + &quot;%, &quot; + (alpha || rgba[3] || 1) + &quot;)&quot;;
</PRE><P>}
</P><P>function hslString(hsla, alpha) {
</P><PRE>  if (alpha &lt; 1 || (hsla[3] &amp;&amp; hsla[3] &lt; 1)) {
     return hslaString(hsla, alpha);
  }
  return &quot;hsl(&quot; + hsla[0] + &quot;, &quot; + hsla[1] + &quot;%, &quot; + hsla[2] + &quot;%)&quot;;
</PRE><P>}
</P><P>function hslaString(hsla, alpha) {
</P><PRE>  if (alpha === undefined) {
     alpha = (hsla[3] !== undefined ? hsla[3] : 1);
  }
  return &quot;hsla(&quot; + hsla[0] + &quot;, &quot; + hsla[1] + &quot;%, &quot; + hsla[2] + &quot;%, &quot;
          + alpha + &quot;)&quot;;
</PRE><P>}
</P><P>// hwb is a bit different than rgb(a) &amp; hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional &amp; 1 is default value)
function hwbString(hwb, alpha) {
</P><PRE>  if (alpha === undefined) {
     alpha = (hwb[3] !== undefined ? hwb[3] : 1);
  }
  return &quot;hwb(&quot; + hwb[0] + &quot;, &quot; + hwb[1] + &quot;%, &quot; + hwb[2] + &quot;%&quot;
          + (alpha !== undefined &amp;&amp; alpha !== 1 ? &quot;, &quot; + alpha : &quot;&quot;) + &quot;)&quot;;
</PRE><P>}
</P><P>function keyword(rgb) {
</P><PRE> return reverseNames[rgb.slice(0, 3)];
</PRE><P>}
</P><P>// helpers
function scale(num, min, max) {
</P><PRE>  return Math.min(Math.max(min, num), max);
</PRE><P>}
</P><P>function hexDouble(num) {
</P><PRE> var str = num.toString(16).toUpperCase();
 return (str.length &lt; 2) ? &quot;0&quot; + str : str;
</PRE><P>}
</P><P>
//create a list of reverse color names
var reverseNames = {};
for (var name in colorNames) {
</P><PRE>  reverseNames[colorNames[name]] = name;
</PRE><P>}
</P><P>},{&quot;5&quot;:5}],2:[function(require,module,exports){
/* MIT license */
var convert = require(4);
var string = require(1);
</P><P>var Color = function (obj) {
	if (obj instanceof Color) {
		return obj;
	}
	if (!(this instanceof Color)) {
		return new Color(obj);
	}
</P><P>	this.values = {
		rgb: [0, 0, 0],
		hsl: [0, 0, 0],
		hsv: [0, 0, 0],
		hwb: [0, 0, 0],
		cmyk: [0, 0, 0, 0],
		alpha: 1
	};
</P><P>	// parse Color() argument
	var vals;
	if (typeof obj === 'string') {
		vals = string.getRgba(obj);
		if (vals) {
			this.setValues('rgb', vals);
		} else if (vals = string.getHsla(obj)) {
			this.setValues('hsl', vals);
		} else if (vals = string.getHwb(obj)) {
			this.setValues('hwb', vals);
		} else {
			throw new Error('Unable to parse color from string &quot;' + obj + '&quot;');
		}
	} else if (typeof obj === 'object') {
		vals = obj;
		if (vals.r !== undefined || vals.red !== undefined) {
			this.setValues('rgb', vals);
		} else if (vals.l !== undefined || vals.lightness !== undefined) {
			this.setValues('hsl', vals);
		} else if (vals.v !== undefined || vals.value !== undefined) {
			this.setValues('hsv', vals);
		} else if (vals.w !== undefined || vals.whiteness !== undefined) {
			this.setValues('hwb', vals);
		} else if (vals.c !== undefined || vals.cyan !== undefined) {
			this.setValues('cmyk', vals);
		} else {
			throw new Error('Unable to parse color from object ' + JSON.stringify(obj));
		}
	}
};
</P><P>Color.prototype = {
	rgb: function () {
		return this.setSpace('rgb', arguments);
	},
	hsl: function () {
		return this.setSpace('hsl', arguments);
	},
	hsv: function () {
		return this.setSpace('hsv', arguments);
	},
	hwb: function () {
		return this.setSpace('hwb', arguments);
	},
	cmyk: function () {
		return this.setSpace('cmyk', arguments);
	},
</P><P>	rgbArray: function () {
		return this.values.rgb;
	},
	hslArray: function () {
		return this.values.hsl;
	},
	hsvArray: function () {
		return this.values.hsv;
	},
	hwbArray: function () {
		var values = this.values;
		if (values.alpha !== 1) {
			return values.hwb.concat([values.alpha]);
		}
		return values.hwb;
	},
	cmykArray: function () {
		return this.values.cmyk;
	},
	rgbaArray: function () {
		var values = this.values;
		return values.rgb.concat([values.alpha]);
	},
	hslaArray: function () {
		var values = this.values;
		return values.hsl.concat([values.alpha]);
	},
	alpha: function (val) {
		if (val === undefined) {
			return this.values.alpha;
		}
		this.setValues('alpha', val);
		return this;
	},
</P><P>	red: function (val) {
		return this.setChannel('rgb', 0, val);
	},
	green: function (val) {
		return this.setChannel('rgb', 1, val);
	},
	blue: function (val) {
		return this.setChannel('rgb', 2, val);
	},
	hue: function (val) {
		if (val) {
			val %= 360;
			val = val &lt; 0 ? 360 + val : val;
		}
		return this.setChannel('hsl', 0, val);
	},
	saturation: function (val) {
		return this.setChannel('hsl', 1, val);
	},
	lightness: function (val) {
		return this.setChannel('hsl', 2, val);
	},
	saturationv: function (val) {
		return this.setChannel('hsv', 1, val);
	},
	whiteness: function (val) {
		return this.setChannel('hwb', 1, val);
	},
	blackness: function (val) {
		return this.setChannel('hwb', 2, val);
	},
	value: function (val) {
		return this.setChannel('hsv', 2, val);
	},
	cyan: function (val) {
		return this.setChannel('cmyk', 0, val);
	},
	magenta: function (val) {
		return this.setChannel('cmyk', 1, val);
	},
	yellow: function (val) {
		return this.setChannel('cmyk', 2, val);
	},
	black: function (val) {
		return this.setChannel('cmyk', 3, val);
	},
</P><P>	hexString: function () {
		return string.hexString(this.values.rgb);
	},
	rgbString: function () {
		return string.rgbString(this.values.rgb, this.values.alpha);
	},
	rgbaString: function () {
		return string.rgbaString(this.values.rgb, this.values.alpha);
	},
	percentString: function () {
		return string.percentString(this.values.rgb, this.values.alpha);
	},
	hslString: function () {
		return string.hslString(this.values.hsl, this.values.alpha);
	},
	hslaString: function () {
		return string.hslaString(this.values.hsl, this.values.alpha);
	},
	hwbString: function () {
		return string.hwbString(this.values.hwb, this.values.alpha);
	},
	keyword: function () {
		return string.keyword(this.values.rgb, this.values.alpha);
	},
</P><P>	rgbNumber: function () {
		var rgb = this.values.rgb;
		return (rgb[0] &lt;&lt; 16) | (rgb[1] &lt;&lt; 8) | rgb[2];
	},
</P><P>	luminosity: function () {
		// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/WCAG20/#relativeluminancedef">http://www.w3.org/TR/WCAG20/#relativeluminancedef</A>
		var rgb = this.values.rgb;
		var lum = [];
		for (var i = 0; i &lt; rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan &lt;= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}
		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},
</P><P>	contrast: function (color2) {
		// <A rel="nofollow" class="external free" href="http://www.w3.org/TR/WCAG20/#contrast-ratiodef">http://www.w3.org/TR/WCAG20/#contrast-ratiodef</A>
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();
		if (lum1 &gt; lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}
		return (lum2 + 0.05) / (lum1 + 0.05);
	},
</P><P>	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio &gt;= 7.1) {
			return 'AAA';
		}
</P><P>		return (contrastRatio &gt;= 4.5) ? 'AA' : <I>;</I>
	},
</P><P>	dark: function () {
		// YIQ equation from <A rel="nofollow" class="external free" href="http://24ways.org/2010/calculating-color-contrast">http://24ways.org/2010/calculating-color-contrast</A>
		var rgb = this.values.rgb;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq &lt; 128;
	},
</P><P>	light: function () {
		return !this.dark();
	},
</P><P>	negate: function () {
		var rgb = [];
		for (var i = 0; i &lt; 3; i++) {
			rgb[i] = 255 - this.values.rgb[i];
		}
		this.setValues('rgb', rgb);
		return this;
	},
</P><P>	lighten: function (ratio) {
		var hsl = this.values.hsl;
		hsl[2] += hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},
</P><P>	darken: function (ratio) {
		var hsl = this.values.hsl;
		hsl[2] -= hsl[2] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},
</P><P>	saturate: function (ratio) {
		var hsl = this.values.hsl;
		hsl[1] += hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},
</P><P>	desaturate: function (ratio) {
		var hsl = this.values.hsl;
		hsl[1] -= hsl[1] * ratio;
		this.setValues('hsl', hsl);
		return this;
	},
</P><P>	whiten: function (ratio) {
		var hwb = this.values.hwb;
		hwb[1] += hwb[1] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},
</P><P>	blacken: function (ratio) {
		var hwb = this.values.hwb;
		hwb[2] += hwb[2] * ratio;
		this.setValues('hwb', hwb);
		return this;
	},
</P><P>	greyscale: function () {
		var rgb = this.values.rgb;
		// <A rel="nofollow" class="external free" href="http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale">http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale</A>
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		this.setValues('rgb', [val, val, val]);
		return this;
	},
</P><P>	clearer: function (ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha - (alpha * ratio));
		return this;
	},
</P><P>	opaquer: function (ratio) {
		var alpha = this.values.alpha;
		this.setValues('alpha', alpha + (alpha * ratio));
		return this;
	},
</P><P>	rotate: function (degrees) {
		var hsl = this.values.hsl;
		var hue = (hsl[0] + degrees) % 360;
		hsl[0] = hue &lt; 0 ? 360 + hue : hue;
		this.setValues('hsl', hsl);
		return this;
	},
</P><P>	/**
	 * Ported from sass implementation in C
	 * <A rel="nofollow" class="external free" href="https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209">https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209</A>
	 */
	mix: function (mixinColor, weight) {
		var color1 = this;
		var color2 = mixinColor;
		var p = weight === undefined ? 0.5 : weight;
</P><P>		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();
</P><P>		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;
</P><P>		return this
			.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue()
			)
			.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
	},
</P><P>	toJSON: function () {
		return this.rgb();
	},
</P><P>	clone: function () {
		// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
		// making the final build way to big to embed in Chart.js. So let's do it manually,
		// assuming that values to clone are 1 dimension arrays containing only numbers,
		// except 'alpha' which is a number.
		var result = new Color();
		var source = this.values;
		var target = result.values;
		var value, type;
</P><P>		for (var prop in source) {
			if (source.hasOwnProperty(prop)) {
				value = source[prop];
				type = ({}).toString.call(value);
				if (type === '[object Array]') {
					target[prop] = value.slice(0);
				} else if (type === '[object Number]') {
					target[prop] = value;
				} else {
					console.error('unexpected color value:', value);
				}
			}
		}
</P><P>		return result;
	}
};
</P><P>Color.prototype.spaces = {
	rgb: ['red', 'green', 'blue'],
	hsl: ['hue', 'saturation', 'lightness'],
	hsv: ['hue', 'saturation', 'value'],
	hwb: ['hue', 'whiteness', 'blackness'],
	cmyk: ['cyan', 'magenta', 'yellow', 'black']
};
</P><P>Color.prototype.maxes = {
	rgb: [255, 255, 255],
	hsl: [360, 100, 100],
	hsv: [360, 100, 100],
	hwb: [360, 100, 100],
	cmyk: [100, 100, 100, 100]
};
</P><P>Color.prototype.getValues = function (space) {
	var values = this.values;
	var vals = {};
</P><P>	for (var i = 0; i &lt; space.length; i++) {
		vals[space.charAt(i)] = values[space][i];
	}
</P><P>	if (values.alpha !== 1) {
		vals.a = values.alpha;
	}
</P><P>	// {r: 255, g: 255, b: 255, a: 0.4}
	return vals;
};
</P><P>Color.prototype.setValues = function (space, vals) {
	var values = this.values;
	var spaces = this.spaces;
	var maxes = this.maxes;
	var alpha = 1;
	var i;
</P><P>	if (space === 'alpha') {
		alpha = vals;
	} else if (vals.length) {
		// [10, 10, 10]
		values[space] = vals.slice(0, space.length);
		alpha = vals[space.length];
	} else if (vals[space.charAt(0)] !== undefined) {
		// {r: 10, g: 10, b: 10}
		for (i = 0; i &lt; space.length; i++) {
			values[space][i] = vals[space.charAt(i)];
		}
</P><P>		alpha = vals.a;
	} else if (vals[spaces[space][0]] !== undefined) {
		// {red: 10, green: 10, blue: 10}
		var chans = spaces[space];
</P><P>		for (i = 0; i &lt; space.length; i++) {
			values[space][i] = vals[chans[i]];
		}
</P><P>		alpha = vals.alpha;
	}
</P><P>	values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));
</P><P>	if (space === 'alpha') {
		return false;
	}
</P><P>	var capped;
</P><P>	// cap values of the space prior converting all values
	for (i = 0; i &lt; space.length; i++) {
		capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
		values[space][i] = Math.round(capped);
	}
</P><P>	// convert to all the other color spaces
	for (var sname in spaces) {
		if (sname !== space) {
			values[sname] = convert[space][sname](values[space]);
		}
	}
</P><P>	return true;
};
</P><P>Color.prototype.setSpace = function (space, args) {
	var vals = args[0];
</P><P>	if (vals === undefined) {
		// color.rgb()
		return this.getValues(space);
	}
</P><P>	// color.rgb(10, 10, 10)
	if (typeof vals === 'number') {
		vals = Array.prototype.slice.call(args);
	}
</P><P>	this.setValues(space, vals);
	return this;
};
</P><P>Color.prototype.setChannel = function (space, index, val) {
	var svalues = this.values[space];
	if (val === undefined) {
		// color.red()
		return svalues[index];
	} else if (val === svalues[index]) {
		// color.red(color.red())
		return this;
	}
</P><P>	// color.red(100)
	svalues[index] = val;
	this.setValues(space, svalues);
</P><P>	return this;
};
</P><P>if (typeof window !== 'undefined') {
	window.Color = Color;
}
</P><P>module.exports = Color;
</P><P>},{&quot;1&quot;:1,&quot;4&quot;:4}],3:[function(require,module,exports){
/* MIT license */
</P><P>module.exports = {
</P><PRE> rgb2hsl: rgb2hsl,
 rgb2hsv: rgb2hsv,
 rgb2hwb: rgb2hwb,
 rgb2cmyk: rgb2cmyk,
 rgb2keyword: rgb2keyword,
 rgb2xyz: rgb2xyz,
 rgb2lab: rgb2lab,
 rgb2lch: rgb2lch,
</PRE><PRE> hsl2rgb: hsl2rgb,
 hsl2hsv: hsl2hsv,
 hsl2hwb: hsl2hwb,
 hsl2cmyk: hsl2cmyk,
 hsl2keyword: hsl2keyword,
</PRE><PRE> hsv2rgb: hsv2rgb,
 hsv2hsl: hsv2hsl,
 hsv2hwb: hsv2hwb,
 hsv2cmyk: hsv2cmyk,
 hsv2keyword: hsv2keyword,
</PRE><PRE> hwb2rgb: hwb2rgb,
 hwb2hsl: hwb2hsl,
 hwb2hsv: hwb2hsv,
 hwb2cmyk: hwb2cmyk,
 hwb2keyword: hwb2keyword,
</PRE><PRE> cmyk2rgb: cmyk2rgb,
 cmyk2hsl: cmyk2hsl,
 cmyk2hsv: cmyk2hsv,
 cmyk2hwb: cmyk2hwb,
 cmyk2keyword: cmyk2keyword,
</PRE><PRE> keyword2rgb: keyword2rgb,
 keyword2hsl: keyword2hsl,
 keyword2hsv: keyword2hsv,
 keyword2hwb: keyword2hwb,
 keyword2cmyk: keyword2cmyk,
 keyword2lab: keyword2lab,
 keyword2xyz: keyword2xyz,
</PRE><PRE> xyz2rgb: xyz2rgb,
 xyz2lab: xyz2lab,
 xyz2lch: xyz2lch,
</PRE><PRE> lab2xyz: lab2xyz,
 lab2rgb: lab2rgb,
 lab2lch: lab2lch,
</PRE><PRE> lch2lab: lch2lab,
 lch2xyz: lch2xyz,
 lch2rgb: lch2rgb
</PRE><P>}
</P><P>
function rgb2hsl(rgb) {
</P><PRE> var r = rgb[0]/255,
     g = rgb[1]/255,
     b = rgb[2]/255,
     min = Math.min(r, g, b),
     max = Math.max(r, g, b),
     delta = max - min,
     h, s, l;
</PRE><PRE> if (max == min)
   h = 0;
 else if (r == max)
   h = (g - b) / delta;
 else if (g == max)
   h = 2 + (b - r) / delta;
 else if (b == max)
   h = 4 + (r - g)/ delta;
</PRE><PRE> h = Math.min(h * 60, 360);
</PRE><PRE> if (h &lt; 0)
   h += 360;
</PRE><PRE> l = (min + max) / 2;
</PRE><PRE> if (max == min)
   s = 0;
 else if (l &lt;= 0.5)
   s = delta / (max + min);
 else
   s = delta / (2 - max - min);
</PRE><PRE> return [h, s * 100, l * 100];
</PRE><P>}
</P><P>function rgb2hsv(rgb) {
</P><PRE> var r = rgb[0],
     g = rgb[1],
     b = rgb[2],
     min = Math.min(r, g, b),
     max = Math.max(r, g, b),
     delta = max - min,
     h, s, v;
</PRE><PRE> if (max == 0)
   s = 0;
 else
   s = (delta/max * 1000)/10;
</PRE><PRE> if (max == min)
   h = 0;
 else if (r == max)
   h = (g - b) / delta;
 else if (g == max)
   h = 2 + (b - r) / delta;
 else if (b == max)
   h = 4 + (r - g) / delta;
</PRE><PRE> h = Math.min(h * 60, 360);
</PRE><PRE> if (h &lt; 0)
   h += 360;
</PRE><PRE> v = ((max / 255) * 1000) / 10;
</PRE><PRE> return [h, s, v];
</PRE><P>}
</P><P>function rgb2hwb(rgb) {
</P><PRE> var r = rgb[0],
     g = rgb[1],
     b = rgb[2],
     h = rgb2hsl(rgb)[0],
     w = 1/255 * Math.min(r, Math.min(g, b)),
     b = 1 - 1/255 * Math.max(r, Math.max(g, b));
</PRE><PRE> return [h, w * 100, b * 100];
</PRE><P>}
</P><P>function rgb2cmyk(rgb) {
</P><PRE> var r = rgb[0] / 255,
     g = rgb[1] / 255,
     b = rgb[2] / 255,
     c, m, y, k;
</PRE><PRE> k = Math.min(1 - r, 1 - g, 1 - b);
 c = (1 - r - k) / (1 - k) || 0;
 m = (1 - g - k) / (1 - k) || 0;
 y = (1 - b - k) / (1 - k) || 0;
 return [c * 100, m * 100, y * 100, k * 100];
</PRE><P>}
</P><P>function rgb2keyword(rgb) {
</P><PRE> return reverseKeywords[JSON.stringify(rgb)];
</PRE><P>}
</P><P>function rgb2xyz(rgb) {
</P><PRE> var r = rgb[0] / 255,
     g = rgb[1] / 255,
     b = rgb[2] / 255;
</PRE><PRE> // assume sRGB
 r = r &gt; 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
 g = g &gt; 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
 b = b &gt; 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);
</PRE><PRE> var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
 var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
 var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
</PRE><PRE> return [x * 100, y *100, z * 100];
</PRE><P>}
</P><P>function rgb2lab(rgb) {
</P><PRE> var xyz = rgb2xyz(rgb),
       x = xyz[0],
       y = xyz[1],
       z = xyz[2],
       l, a, b;
</PRE><PRE> x /= 95.047;
 y /= 100;
 z /= 108.883;
</PRE><PRE> x = x &gt; 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
 y = y &gt; 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
 z = z &gt; 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);
</PRE><PRE> l = (116 * y) - 16;
 a = 500 * (x - y);
 b = 200 * (y - z);
</PRE><PRE> return [l, a, b];
</PRE><P>}
</P><P>function rgb2lch(args) {
</P><PRE> return lab2lch(rgb2lab(args));
</PRE><P>}
</P><P>function hsl2rgb(hsl) {
</P><PRE> var h = hsl[0] / 360,
     s = hsl[1] / 100,
     l = hsl[2] / 100,
     t1, t2, t3, rgb, val;
</PRE><PRE> if (s == 0) {
   val = l * 255;
   return [val, val, val];
 }
</PRE><PRE> if (l &lt; 0.5)
   t2 = l * (1 + s);
 else
   t2 = l + s - l * s;
 t1 = 2 * l - t2;
</PRE><PRE> rgb = [0, 0, 0];
 for (var i = 0; i &lt; 3; i++) {
   t3 = h + 1 / 3 * - (i - 1);
   t3 &lt; 0 &amp;&amp; t3++;
   t3 &gt; 1 &amp;&amp; t3--;
</PRE><PRE>   if (6 * t3 &lt; 1)
     val = t1 + (t2 - t1) * 6 * t3;
   else if (2 * t3 &lt; 1)
     val = t2;
   else if (3 * t3 &lt; 2)
     val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
   else
     val = t1;
</PRE><PRE>   rgb[i] = val * 255;
 }
</PRE><PRE> return rgb;
</PRE><P>}
</P><P>function hsl2hsv(hsl) {
</P><PRE> var h = hsl[0],
     s = hsl[1] / 100,
     l = hsl[2] / 100,
     sv, v;
</PRE><PRE> if(l === 0) {
     // no need to do calc on black
     // also avoids divide by 0 error
     return [0, 0, 0];
 }
</PRE><PRE> l *= 2;
 s *= (l &lt;= 1) ? l : 2 - l;
 v = (l + s) / 2;
 sv = (2 * s) / (l + s);
 return [h, sv * 100, v * 100];
</PRE><P>}
</P><P>function hsl2hwb(args) {
</P><PRE> return rgb2hwb(hsl2rgb(args));
</PRE><P>}
</P><P>function hsl2cmyk(args) {
</P><PRE> return rgb2cmyk(hsl2rgb(args));
</PRE><P>}
</P><P>function hsl2keyword(args) {
</P><PRE> return rgb2keyword(hsl2rgb(args));
</PRE><P>}
</P><P>
function hsv2rgb(hsv) {
</P><PRE> var h = hsv[0] / 60,
     s = hsv[1] / 100,
     v = hsv[2] / 100,
     hi = Math.floor(h) % 6;
</PRE><PRE> var f = h - Math.floor(h),
     p = 255 * v * (1 - s),
     q = 255 * v * (1 - (s * f)),
     t = 255 * v * (1 - (s * (1 - f))),
     v = 255 * v;
</PRE><PRE> switch(hi) {
   case 0:
     return [v, t, p];
   case 1:
     return [q, v, p];
   case 2:
     return [p, v, t];
   case 3:
     return [p, q, v];
   case 4:
     return [t, p, v];
   case 5:
     return [v, p, q];
 }
</PRE><P>}
</P><P>function hsv2hsl(hsv) {
</P><PRE> var h = hsv[0],
     s = hsv[1] / 100,
     v = hsv[2] / 100,
     sl, l;
</PRE><PRE> l = (2 - s) * v;
 sl = s * v;
 sl /= (l &lt;= 1) ? l : 2 - l;
 sl = sl || 0;
 l /= 2;
 return [h, sl * 100, l * 100];
</PRE><P>}
</P><P>function hsv2hwb(args) {
</P><PRE> return rgb2hwb(hsv2rgb(args))
</PRE><P>}
</P><P>function hsv2cmyk(args) {
</P><PRE> return rgb2cmyk(hsv2rgb(args));
</PRE><P>}
</P><P>function hsv2keyword(args) {
</P><PRE> return rgb2keyword(hsv2rgb(args));
</PRE><P>}
</P><P>// <A rel="nofollow" class="external free" href="http://dev.w3.org/csswg/css-color/#hwb-to-rgb">http://dev.w3.org/csswg/css-color/#hwb-to-rgb</A>
function hwb2rgb(hwb) {
</P><PRE> var h = hwb[0] / 360,
     wh = hwb[1] / 100,
     bl = hwb[2] / 100,
     ratio = wh + bl,
     i, v, f, n;
</PRE><PRE> // wh + bl cant be &gt; 1
 if (ratio &gt; 1) {
   wh /= ratio;
   bl /= ratio;
 }
</PRE><PRE> i = Math.floor(6 * h);
 v = 1 - bl;
 f = 6 * h - i;
 if ((i &amp; 0x01) != 0) {
   f = 1 - f;
 }
 n = wh + f * (v - wh);  // linear interpolation
</PRE><PRE> switch (i) {
   default:
   case 6:
   case 0: r = v; g = n; b = wh; break;
   case 1: r = n; g = v; b = wh; break;
   case 2: r = wh; g = v; b = n; break;
   case 3: r = wh; g = n; b = v; break;
   case 4: r = n; g = wh; b = v; break;
   case 5: r = v; g = wh; b = n; break;
 }
</PRE><PRE> return [r * 255, g * 255, b * 255];
</PRE><P>}
</P><P>function hwb2hsl(args) {
</P><PRE> return rgb2hsl(hwb2rgb(args));
</PRE><P>}
</P><P>function hwb2hsv(args) {
</P><PRE> return rgb2hsv(hwb2rgb(args));
</PRE><P>}
</P><P>function hwb2cmyk(args) {
</P><PRE> return rgb2cmyk(hwb2rgb(args));
</PRE><P>}
</P><P>function hwb2keyword(args) {
</P><PRE> return rgb2keyword(hwb2rgb(args));
</PRE><P>}
</P><P>function cmyk2rgb(cmyk) {
</P><PRE> var c = cmyk[0] / 100,
     m = cmyk[1] / 100,
     y = cmyk[2] / 100,
     k = cmyk[3] / 100,
     r, g, b;
</PRE><PRE> r = 1 - Math.min(1, c * (1 - k) + k);
 g = 1 - Math.min(1, m * (1 - k) + k);
 b = 1 - Math.min(1, y * (1 - k) + k);
 return [r * 255, g * 255, b * 255];
</PRE><P>}
</P><P>function cmyk2hsl(args) {
</P><PRE> return rgb2hsl(cmyk2rgb(args));
</PRE><P>}
</P><P>function cmyk2hsv(args) {
</P><PRE> return rgb2hsv(cmyk2rgb(args));
</PRE><P>}
</P><P>function cmyk2hwb(args) {
</P><PRE> return rgb2hwb(cmyk2rgb(args));
</PRE><P>}
</P><P>function cmyk2keyword(args) {
</P><PRE> return rgb2keyword(cmyk2rgb(args));
</PRE><P>}
</P><P>
function xyz2rgb(xyz) {
</P><PRE> var x = xyz[0] / 100,
     y = xyz[1] / 100,
     z = xyz[2] / 100,
     r, g, b;
</PRE><PRE> r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
 g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
 b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
</PRE><PRE> // assume sRGB
 r = r &gt; 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
   : r = (r * 12.92);
</PRE><PRE> g = g &gt; 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
   : g = (g * 12.92);
</PRE><PRE> b = b &gt; 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
   : b = (b * 12.92);
</PRE><PRE> r = Math.min(Math.max(0, r), 1);
 g = Math.min(Math.max(0, g), 1);
 b = Math.min(Math.max(0, b), 1);
</PRE><PRE> return [r * 255, g * 255, b * 255];
</PRE><P>}
</P><P>function xyz2lab(xyz) {
</P><PRE> var x = xyz[0],
     y = xyz[1],
     z = xyz[2],
     l, a, b;
</PRE><PRE> x /= 95.047;
 y /= 100;
 z /= 108.883;
</PRE><PRE> x = x &gt; 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
 y = y &gt; 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
 z = z &gt; 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);
</PRE><PRE> l = (116 * y) - 16;
 a = 500 * (x - y);
 b = 200 * (y - z);
</PRE><PRE> return [l, a, b];
</PRE><P>}
</P><P>function xyz2lch(args) {
</P><PRE> return lab2lch(xyz2lab(args));
</PRE><P>}
</P><P>function lab2xyz(lab) {
</P><PRE> var l = lab[0],
     a = lab[1],
     b = lab[2],
     x, y, z, y2;
</PRE><PRE> if (l &lt;= 8) {
   y = (l * 100) / 903.3;
   y2 = (7.787 * (y / 100)) + (16 / 116);
 } else {
   y = 100 * Math.pow((l + 16) / 116, 3);
   y2 = Math.pow(y / 100, 1/3);
 }
</PRE><PRE> x = x / 95.047 &lt;= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);
</PRE><PRE> z = z / 108.883 &lt;= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);
</PRE><PRE> return [x, y, z];
</PRE><P>}
</P><P>function lab2lch(lab) {
</P><PRE> var l = lab[0],
     a = lab[1],
     b = lab[2],
     hr, h, c;
</PRE><PRE> hr = Math.atan2(b, a);
 h = hr * 360 / 2 / Math.PI;
 if (h &lt; 0) {
   h += 360;
 }
 c = Math.sqrt(a * a + b * b);
 return [l, c, h];
</PRE><P>}
</P><P>function lab2rgb(args) {
</P><PRE> return xyz2rgb(lab2xyz(args));
</PRE><P>}
</P><P>function lch2lab(lch) {
</P><PRE> var l = lch[0],
     c = lch[1],
     h = lch[2],
     a, b, hr;
</PRE><PRE> hr = h / 360 * 2 * Math.PI;
 a = c * Math.cos(hr);
 b = c * Math.sin(hr);
 return [l, a, b];
</PRE><P>}
</P><P>function lch2xyz(args) {
</P><PRE> return lab2xyz(lch2lab(args));
</PRE><P>}
</P><P>function lch2rgb(args) {
</P><PRE> return lab2rgb(lch2lab(args));
</PRE><P>}
</P><P>function keyword2rgb(keyword) {
</P><PRE> return cssKeywords[keyword];
</PRE><P>}
</P><P>function keyword2hsl(args) {
</P><PRE> return rgb2hsl(keyword2rgb(args));
</PRE><P>}
</P><P>function keyword2hsv(args) {
</P><PRE> return rgb2hsv(keyword2rgb(args));
</PRE><P>}
</P><P>function keyword2hwb(args) {
</P><PRE> return rgb2hwb(keyword2rgb(args));
</PRE><P>}
</P><P>function keyword2cmyk(args) {
</P><PRE> return rgb2cmyk(keyword2rgb(args));
</PRE><P>}
</P><P>function keyword2lab(args) {
</P><PRE> return rgb2lab(keyword2rgb(args));
</PRE><P>}
</P><P>function keyword2xyz(args) {
</P><PRE> return rgb2xyz(keyword2rgb(args));
</PRE><P>}
</P><P>var cssKeywords = {
</P><PRE> aliceblue:  [240,248,255],
 antiquewhite: [250,235,215],
 aqua: [0,255,255],
 aquamarine: [127,255,212],
 azure:  [240,255,255],
 beige:  [245,245,220],
 bisque: [255,228,196],
 black:  [0,0,0],
 blanchedalmond: [255,235,205],
 blue: [0,0,255],
 blueviolet: [138,43,226],
 brown:  [165,42,42],
 burlywood:  [222,184,135],
 cadetblue:  [95,158,160],
 chartreuse: [127,255,0],
 chocolate:  [210,105,30],
 coral:  [255,127,80],
 cornflowerblue: [100,149,237],
 cornsilk: [255,248,220],
 crimson:  [220,20,60],
 cyan: [0,255,255],
 darkblue: [0,0,139],
 darkcyan: [0,139,139],
 darkgoldenrod:  [184,134,11],
 darkgray: [169,169,169],
 darkgreen:  [0,100,0],
 darkgrey: [169,169,169],
 darkkhaki:  [189,183,107],
 darkmagenta:  [139,0,139],
 darkolivegreen: [85,107,47],
 darkorange: [255,140,0],
 darkorchid: [153,50,204],
 darkred:  [139,0,0],
 darksalmon: [233,150,122],
 darkseagreen: [143,188,143],
 darkslateblue:  [72,61,139],
 darkslategray:  [47,79,79],
 darkslategrey:  [47,79,79],
 darkturquoise:  [0,206,209],
 darkviolet: [148,0,211],
 deeppink: [255,20,147],
 deepskyblue:  [0,191,255],
 dimgray:  [105,105,105],
 dimgrey:  [105,105,105],
 dodgerblue: [30,144,255],
 firebrick:  [178,34,34],
 floralwhite:  [255,250,240],
 forestgreen:  [34,139,34],
 fuchsia:  [255,0,255],
 gainsboro:  [220,220,220],
 ghostwhite: [248,248,255],
 gold: [255,215,0],
 goldenrod:  [218,165,32],
 gray: [128,128,128],
 green:  [0,128,0],
 greenyellow:  [173,255,47],
 grey: [128,128,128],
 honeydew: [240,255,240],
 hotpink:  [255,105,180],
 indianred:  [205,92,92],
 indigo: [75,0,130],
 ivory:  [255,255,240],
 khaki:  [240,230,140],
 lavender: [230,230,250],
 lavenderblush:  [255,240,245],
 lawngreen:  [124,252,0],
 lemonchiffon: [255,250,205],
 lightblue:  [173,216,230],
 lightcoral: [240,128,128],
 lightcyan:  [224,255,255],
 lightgoldenrodyellow: [250,250,210],
 lightgray:  [211,211,211],
 lightgreen: [144,238,144],
 lightgrey:  [211,211,211],
 lightpink:  [255,182,193],
 lightsalmon:  [255,160,122],
 lightseagreen:  [32,178,170],
 lightskyblue: [135,206,250],
 lightslategray: [119,136,153],
 lightslategrey: [119,136,153],
 lightsteelblue: [176,196,222],
 lightyellow:  [255,255,224],
 lime: [0,255,0],
 limegreen:  [50,205,50],
 linen:  [250,240,230],
 magenta:  [255,0,255],
 maroon: [128,0,0],
 mediumaquamarine: [102,205,170],
 mediumblue: [0,0,205],
 mediumorchid: [186,85,211],
 mediumpurple: [147,112,219],
 mediumseagreen: [60,179,113],
 mediumslateblue:  [123,104,238],
 mediumspringgreen:  [0,250,154],
 mediumturquoise:  [72,209,204],
 mediumvioletred:  [199,21,133],
 midnightblue: [25,25,112],
 mintcream:  [245,255,250],
 mistyrose:  [255,228,225],
 moccasin: [255,228,181],
 navajowhite:  [255,222,173],
 navy: [0,0,128],
 oldlace:  [253,245,230],
 olive:  [128,128,0],
 olivedrab:  [107,142,35],
 orange: [255,165,0],
 orangered:  [255,69,0],
 orchid: [218,112,214],
 palegoldenrod:  [238,232,170],
 palegreen:  [152,251,152],
 paleturquoise:  [175,238,238],
 palevioletred:  [219,112,147],
 papayawhip: [255,239,213],
 peachpuff:  [255,218,185],
 peru: [205,133,63],
 pink: [255,192,203],
 plum: [221,160,221],
 powderblue: [176,224,230],
 purple: [128,0,128],
 rebeccapurple: [102, 51, 153],
 red:  [255,0,0],
 rosybrown:  [188,143,143],
 royalblue:  [65,105,225],
 saddlebrown:  [139,69,19],
 salmon: [250,128,114],
 sandybrown: [244,164,96],
 seagreen: [46,139,87],
 seashell: [255,245,238],
 sienna: [160,82,45],
 silver: [192,192,192],
 skyblue:  [135,206,235],
 slateblue:  [106,90,205],
 slategray:  [112,128,144],
 slategrey:  [112,128,144],
 snow: [255,250,250],
 springgreen:  [0,255,127],
 steelblue:  [70,130,180],
 tan:  [210,180,140],
 teal: [0,128,128],
 thistle:  [216,191,216],
 tomato: [255,99,71],
 turquoise:  [64,224,208],
 violet: [238,130,238],
 wheat:  [245,222,179],
 white:  [255,255,255],
 whitesmoke: [245,245,245],
 yellow: [255,255,0],
 yellowgreen:  [154,205,50]
</PRE><P>};
</P><P>var reverseKeywords = {};
for (var key in cssKeywords) {
</P><PRE> reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
</PRE><P>}
</P><P>},{}],4:[function(require,module,exports){
var conversions = require(3);
</P><P>var convert = function() {
</P><PRE>  return new Converter();
</PRE><P>}
</P><P>for (var func in conversions) {
</P><PRE> // export Raw versions
 convert[func + &quot;Raw&quot;] =  (function(func) {
   // accept array or plain args
   return function(arg) {
     if (typeof arg == &quot;number&quot;)
       arg = Array.prototype.slice.call(arguments);
     return conversions[func](arg);
   }
 })(func);
</PRE><PRE> var pair = /(\w+)2(\w+)/.exec(func),
     from = pair[1],
     to = pair[2];
</PRE><PRE> // export rgb2hsl and [&quot;rgb&quot;][&quot;hsl&quot;]
 convert[from] = convert[from] || {};
</PRE><PRE> convert[from][to] = convert[func] = (function(func) { 
   return function(arg) {
     if (typeof arg == &quot;number&quot;)
       arg = Array.prototype.slice.call(arguments);
     
     var val = conversions[func](arg);
     if (typeof val == &quot;string&quot; || val === undefined)
       return val; // keyword
</PRE><PRE>     for (var i = 0; i &lt; val.length; i++)
       val[i] = Math.round(val[i]);
     return val;
   }
 })(func);
</PRE><P>}
</P><P>
/* Converter does lazy conversion and caching */
var Converter = function() {
</P><PRE>  this.convs = {};
</PRE><P>};
</P><P>/* Either get the values for a space or
</P><PRE> set the values for a space, depending on args */
</PRE><P>Converter.prototype.routeSpace = function(space, args) {
</P><PRE>  var values = args[0];
  if (values === undefined) {
     // color.rgb()
     return this.getValues(space);
  }
  // color.rgb(10, 10, 10)
  if (typeof values == &quot;number&quot;) {
     values = Array.prototype.slice.call(args);        
  }
</PRE><PRE>  return this.setValues(space, values);
</PRE><P>};
</P><P>/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
</P><PRE>  this.space = space;
  this.convs = {};
  this.convs[space] = values;
  return this;
</PRE><P>};
</P><P>/* Get the values for a space. If there's already
</P><PRE> a conversion for the space, fetch it, otherwise
 compute it */
</PRE><P>Converter.prototype.getValues = function(space) {
</P><PRE>  var vals = this.convs[space];
  if (!vals) {
     var fspace = this.space,
         from = this.convs[fspace];
     vals = convert[fspace][space](from);
</PRE><PRE>     this.convs[space] = vals;
  }
 return vals;
</PRE><P>};
</P><P>[&quot;rgb&quot;, &quot;hsl&quot;, &quot;hsv&quot;, &quot;cmyk&quot;, &quot;keyword&quot;].forEach(function(space) {
</P><PRE>  Converter.prototype[space] = function(vals) {
     return this.routeSpace(space, arguments);
  }
</PRE><P>});
</P><P>module.exports = convert;
},{&quot;3&quot;:3}],5:[function(require,module,exports){
module.exports = {
	&quot;aliceblue&quot;: [240, 248, 255],
	&quot;antiquewhite&quot;: [250, 235, 215],
	&quot;aqua&quot;: [0, 255, 255],
	&quot;aquamarine&quot;: [127, 255, 212],
	&quot;azure&quot;: [240, 255, 255],
	&quot;beige&quot;: [245, 245, 220],
	&quot;bisque&quot;: [255, 228, 196],
	&quot;black&quot;: [0, 0, 0],
	&quot;blanchedalmond&quot;: [255, 235, 205],
	&quot;blue&quot;: [0, 0, 255],
	&quot;blueviolet&quot;: [138, 43, 226],
	&quot;brown&quot;: [165, 42, 42],
	&quot;burlywood&quot;: [222, 184, 135],
	&quot;cadetblue&quot;: [95, 158, 160],
	&quot;chartreuse&quot;: [127, 255, 0],
	&quot;chocolate&quot;: [210, 105, 30],
	&quot;coral&quot;: [255, 127, 80],
	&quot;cornflowerblue&quot;: [100, 149, 237],
	&quot;cornsilk&quot;: [255, 248, 220],
	&quot;crimson&quot;: [220, 20, 60],
	&quot;cyan&quot;: [0, 255, 255],
	&quot;darkblue&quot;: [0, 0, 139],
	&quot;darkcyan&quot;: [0, 139, 139],
	&quot;darkgoldenrod&quot;: [184, 134, 11],
	&quot;darkgray&quot;: [169, 169, 169],
	&quot;darkgreen&quot;: [0, 100, 0],
	&quot;darkgrey&quot;: [169, 169, 169],
	&quot;darkkhaki&quot;: [189, 183, 107],
	&quot;darkmagenta&quot;: [139, 0, 139],
	&quot;darkolivegreen&quot;: [85, 107, 47],
	&quot;darkorange&quot;: [255, 140, 0],
	&quot;darkorchid&quot;: [153, 50, 204],
	&quot;darkred&quot;: [139, 0, 0],
	&quot;darksalmon&quot;: [233, 150, 122],
	&quot;darkseagreen&quot;: [143, 188, 143],
	&quot;darkslateblue&quot;: [72, 61, 139],
	&quot;darkslategray&quot;: [47, 79, 79],
	&quot;darkslategrey&quot;: [47, 79, 79],
	&quot;darkturquoise&quot;: [0, 206, 209],
	&quot;darkviolet&quot;: [148, 0, 211],
	&quot;deeppink&quot;: [255, 20, 147],
	&quot;deepskyblue&quot;: [0, 191, 255],
	&quot;dimgray&quot;: [105, 105, 105],
	&quot;dimgrey&quot;: [105, 105, 105],
	&quot;dodgerblue&quot;: [30, 144, 255],
	&quot;firebrick&quot;: [178, 34, 34],
	&quot;floralwhite&quot;: [255, 250, 240],
	&quot;forestgreen&quot;: [34, 139, 34],
	&quot;fuchsia&quot;: [255, 0, 255],
	&quot;gainsboro&quot;: [220, 220, 220],
	&quot;ghostwhite&quot;: [248, 248, 255],
	&quot;gold&quot;: [255, 215, 0],
	&quot;goldenrod&quot;: [218, 165, 32],
	&quot;gray&quot;: [128, 128, 128],
	&quot;green&quot;: [0, 128, 0],
	&quot;greenyellow&quot;: [173, 255, 47],
	&quot;grey&quot;: [128, 128, 128],
	&quot;honeydew&quot;: [240, 255, 240],
	&quot;hotpink&quot;: [255, 105, 180],
	&quot;indianred&quot;: [205, 92, 92],
	&quot;indigo&quot;: [75, 0, 130],
	&quot;ivory&quot;: [255, 255, 240],
	&quot;khaki&quot;: [240, 230, 140],
	&quot;lavender&quot;: [230, 230, 250],
	&quot;lavenderblush&quot;: [255, 240, 245],
	&quot;lawngreen&quot;: [124, 252, 0],
	&quot;lemonchiffon&quot;: [255, 250, 205],
	&quot;lightblue&quot;: [173, 216, 230],
	&quot;lightcoral&quot;: [240, 128, 128],
	&quot;lightcyan&quot;: [224, 255, 255],
	&quot;lightgoldenrodyellow&quot;: [250, 250, 210],
	&quot;lightgray&quot;: [211, 211, 211],
	&quot;lightgreen&quot;: [144, 238, 144],
	&quot;lightgrey&quot;: [211, 211, 211],
	&quot;lightpink&quot;: [255, 182, 193],
	&quot;lightsalmon&quot;: [255, 160, 122],
	&quot;lightseagreen&quot;: [32, 178, 170],
	&quot;lightskyblue&quot;: [135, 206, 250],
	&quot;lightslategray&quot;: [119, 136, 153],
	&quot;lightslategrey&quot;: [119, 136, 153],
	&quot;lightsteelblue&quot;: [176, 196, 222],
	&quot;lightyellow&quot;: [255, 255, 224],
	&quot;lime&quot;: [0, 255, 0],
	&quot;limegreen&quot;: [50, 205, 50],
	&quot;linen&quot;: [250, 240, 230],
	&quot;magenta&quot;: [255, 0, 255],
	&quot;maroon&quot;: [128, 0, 0],
	&quot;mediumaquamarine&quot;: [102, 205, 170],
	&quot;mediumblue&quot;: [0, 0, 205],
	&quot;mediumorchid&quot;: [186, 85, 211],
	&quot;mediumpurple&quot;: [147, 112, 219],
	&quot;mediumseagreen&quot;: [60, 179, 113],
	&quot;mediumslateblue&quot;: [123, 104, 238],
	&quot;mediumspringgreen&quot;: [0, 250, 154],
	&quot;mediumturquoise&quot;: [72, 209, 204],
	&quot;mediumvioletred&quot;: [199, 21, 133],
	&quot;midnightblue&quot;: [25, 25, 112],
	&quot;mintcream&quot;: [245, 255, 250],
	&quot;mistyrose&quot;: [255, 228, 225],
	&quot;moccasin&quot;: [255, 228, 181],
	&quot;navajowhite&quot;: [255, 222, 173],
	&quot;navy&quot;: [0, 0, 128],
	&quot;oldlace&quot;: [253, 245, 230],
	&quot;olive&quot;: [128, 128, 0],
	&quot;olivedrab&quot;: [107, 142, 35],
	&quot;orange&quot;: [255, 165, 0],
	&quot;orangered&quot;: [255, 69, 0],
	&quot;orchid&quot;: [218, 112, 214],
	&quot;palegoldenrod&quot;: [238, 232, 170],
	&quot;palegreen&quot;: [152, 251, 152],
	&quot;paleturquoise&quot;: [175, 238, 238],
	&quot;palevioletred&quot;: [219, 112, 147],
	&quot;papayawhip&quot;: [255, 239, 213],
	&quot;peachpuff&quot;: [255, 218, 185],
	&quot;peru&quot;: [205, 133, 63],
	&quot;pink&quot;: [255, 192, 203],
	&quot;plum&quot;: [221, 160, 221],
	&quot;powderblue&quot;: [176, 224, 230],
	&quot;purple&quot;: [128, 0, 128],
	&quot;rebeccapurple&quot;: [102, 51, 153],
	&quot;red&quot;: [255, 0, 0],
	&quot;rosybrown&quot;: [188, 143, 143],
	&quot;royalblue&quot;: [65, 105, 225],
	&quot;saddlebrown&quot;: [139, 69, 19],
	&quot;salmon&quot;: [250, 128, 114],
	&quot;sandybrown&quot;: [244, 164, 96],
	&quot;seagreen&quot;: [46, 139, 87],
	&quot;seashell&quot;: [255, 245, 238],
	&quot;sienna&quot;: [160, 82, 45],
	&quot;silver&quot;: [192, 192, 192],
	&quot;skyblue&quot;: [135, 206, 235],
	&quot;slateblue&quot;: [106, 90, 205],
	&quot;slategray&quot;: [112, 128, 144],
	&quot;slategrey&quot;: [112, 128, 144],
	&quot;snow&quot;: [255, 250, 250],
	&quot;springgreen&quot;: [0, 255, 127],
	&quot;steelblue&quot;: [70, 130, 180],
	&quot;tan&quot;: [210, 180, 140],
	&quot;teal&quot;: [0, 128, 128],
	&quot;thistle&quot;: [216, 191, 216],
	&quot;tomato&quot;: [255, 99, 71],
	&quot;turquoise&quot;: [64, 224, 208],
	&quot;violet&quot;: [238, 130, 238],
	&quot;wheat&quot;: [245, 222, 179],
	&quot;white&quot;: [255, 255, 255],
	&quot;whitesmoke&quot;: [245, 245, 245],
	&quot;yellow&quot;: [255, 255, 0],
	&quot;yellowgreen&quot;: [154, 205, 50]
};
},{}],6:[function(require,module,exports){
//! moment.js
//! version : 2.13.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
</P><DL><DT>(function (global, factory) {</DT></DL><PRE>   typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' &amp;&amp; define.amd ? define(factory) :
   global.moment = factory()
</PRE><P>}(this, function () { 'use strict';
</P><PRE>   var hookCallback;
</PRE><PRE>   function utils_hooks__hooks () {
       return hookCallback.apply(null, arguments);
   }
</PRE><PRE>   // This is done to register the method called with moment()
   // without creating circular dependencies.
   function setHookCallback (callback) {
       hookCallback = callback;
   }
</PRE><PRE>   function isArray(input) {
       return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
   }
</PRE><PRE>   function isDate(input) {
       return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
   }
</PRE><PRE>   function map(arr, fn) {
       var res = [], i;
       for (i = 0; i &lt; arr.length; ++i) {
           res.push(fn(arr[i], i));
       }
       return res;
   }
</PRE><PRE>   function hasOwnProp(a, b) {
       return Object.prototype.hasOwnProperty.call(a, b);
   }
</PRE><PRE>   function extend(a, b) {
       for (var i in b) {
           if (hasOwnProp(b, i)) {
               a[i] = b[i];
           }
       }
</PRE><PRE>       if (hasOwnProp(b, 'toString')) {
           a.toString = b.toString;
       }
</PRE><PRE>       if (hasOwnProp(b, 'valueOf')) {
           a.valueOf = b.valueOf;
       }
</PRE><PRE>       return a;
   }
</PRE><PRE>   function create_utc__createUTC (input, format, locale, strict) {
       return createLocalOrUTC(input, format, locale, strict, true).utc();
   }
</PRE><PRE>   function defaultParsingFlags() {
       // We need to deep clone this object.
       return {
           empty           : false,
           unusedTokens    : [],
           unusedInput     : [],
           overflow        : -2,
           charsLeftOver   : 0,
           nullInput       : false,
           invalidMonth    : null,
           invalidFormat   : false,
           userInvalidated : false,
           iso             : false,
           parsedDateParts : [],
           meridiem        : null
       };
   }
</PRE><PRE>   function getParsingFlags(m) {
       if (m._pf == null) {
           m._pf = defaultParsingFlags();
       }
       return m._pf;
   }
</PRE><PRE>   var some;
   if (Array.prototype.some) {
       some = Array.prototype.some;
   } else {
       some = function (fun) {
           var t = Object(this);
           var len = t.length &gt;&gt;&gt; 0;
</PRE><PRE>           for (var i = 0; i &lt; len; i++) {
               if (i in t &amp;&amp; fun.call(this, t[i], i, t)) {
                   return true;
               }
           }
</PRE><PRE>           return false;
       };
   }
</PRE><PRE>   function valid__isValid(m) {
       if (m._isValid == null) {
           var flags = getParsingFlags(m);
           var parsedParts = some.call(flags.parsedDateParts, function (i) {
               return i != null;
           });
           m._isValid = !isNaN(m._d.getTime()) &amp;&amp;
               flags.overflow &lt; 0 &amp;&amp; !flags.empty &amp;&amp; !flags.invalidMonth &amp;&amp; !flags.invalidWeekday &amp;&amp; !flags.nullInput &amp;&amp; !flags.invalidFormat &amp;&amp; !flags.userInvalidated &amp;&amp;
               (!flags.meridiem || (flags.meridiem &amp;&amp; parsedParts));
</PRE><PRE>           if (m._strict) {
               m._isValid = m._isValid &amp;&amp;
                   flags.charsLeftOver === 0 &amp;&amp;
                   flags.unusedTokens.length === 0 &amp;&amp;
                   flags.bigHour === undefined;
           }
       }
       return m._isValid;
   }
</PRE><PRE>   function valid__createInvalid (flags) {
       var m = create_utc__createUTC(NaN);
       if (flags != null) {
           extend(getParsingFlags(m), flags);
       }
       else {
           getParsingFlags(m).userInvalidated = true;
       }
</PRE><PRE>       return m;
   }
</PRE><PRE>   function isUndefined(input) {
       return input === void 0;
   }
</PRE><PRE>   // Plugins that add properties should also add the key here (null value),
   // so we can properly clone ourselves.
   var momentProperties = utils_hooks__hooks.momentProperties = [];
</PRE><PRE>   function copyConfig(to, from) {
       var i, prop, val;
</PRE><PRE>       if (!isUndefined(from._isAMomentObject)) {
           to._isAMomentObject = from._isAMomentObject;
       }
       if (!isUndefined(from._i)) {
           to._i = from._i;
       }
       if (!isUndefined(from._f)) {
           to._f = from._f;
       }
       if (!isUndefined(from._l)) {
           to._l = from._l;
       }
       if (!isUndefined(from._strict)) {
           to._strict = from._strict;
       }
       if (!isUndefined(from._tzm)) {
           to._tzm = from._tzm;
       }
       if (!isUndefined(from._isUTC)) {
           to._isUTC = from._isUTC;
       }
       if (!isUndefined(from._offset)) {
           to._offset = from._offset;
       }
       if (!isUndefined(from._pf)) {
           to._pf = getParsingFlags(from);
       }
       if (!isUndefined(from._locale)) {
           to._locale = from._locale;
       }
</PRE><PRE>       if (momentProperties.length &gt; 0) {
           for (i in momentProperties) {
               prop = momentProperties[i];
               val = from[prop];
               if (!isUndefined(val)) {
                   to[prop] = val;
               }
           }
       }
</PRE><PRE>       return to;
   }
</PRE><PRE>   var updateInProgress = false;
</PRE><PRE>   // Moment prototype object
   function Moment(config) {
       copyConfig(this, config);
       this._d = new Date(config._d != null ? config._d.getTime() : NaN);
       // Prevent infinite loop in case updateOffset creates new moment
       // objects.
       if (updateInProgress === false) {
           updateInProgress = true;
           utils_hooks__hooks.updateOffset(this);
           updateInProgress = false;
       }
   }
</PRE><PRE>   function isMoment (obj) {
       return obj instanceof Moment || (obj != null &amp;&amp; obj._isAMomentObject != null);
   }
</PRE><PRE>   function absFloor (number) {
       if (number &lt; 0) {
           return Math.ceil(number);
       } else {
           return Math.floor(number);
       }
   }
</PRE><PRE>   function toInt(argumentForCoercion) {
       var coercedNumber = +argumentForCoercion,
           value = 0;
</PRE><PRE>       if (coercedNumber !== 0 &amp;&amp; isFinite(coercedNumber)) {
           value = absFloor(coercedNumber);
       }
</PRE><PRE>       return value;
   }
</PRE><PRE>   // compare two arrays, return the number of differences
   function compareArrays(array1, array2, dontConvert) {
       var len = Math.min(array1.length, array2.length),
           lengthDiff = Math.abs(array1.length - array2.length),
           diffs = 0,
           i;
       for (i = 0; i &lt; len; i++) {
           if ((dontConvert &amp;&amp; array1[i] !== array2[i]) ||
               (!dontConvert &amp;&amp; toInt(array1[i]) !== toInt(array2[i]))) {
               diffs++;
           }
       }
       return diffs + lengthDiff;
   }
</PRE><PRE>   function warn(msg) {
       if (utils_hooks__hooks.suppressDeprecationWarnings === false &amp;&amp;
               (typeof console !==  'undefined') &amp;&amp; console.warn) {
           console.warn('Deprecation warning: ' + msg);
       }
   }
</PRE><PRE>   function deprecate(msg, fn) {
       var firstTime = true;
</PRE><PRE>       return extend(function () {
           if (utils_hooks__hooks.deprecationHandler != null) {
               utils_hooks__hooks.deprecationHandler(null, msg);
           }
           if (firstTime) {
               warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
               firstTime = false;
           }
           return fn.apply(this, arguments);
       }, fn);
   }
</PRE><PRE>   var deprecations = {};
</PRE><PRE>   function deprecateSimple(name, msg) {
       if (utils_hooks__hooks.deprecationHandler != null) {
           utils_hooks__hooks.deprecationHandler(name, msg);
       }
       if (!deprecations[name]) {
           warn(msg);
           deprecations[name] = true;
       }
   }
</PRE><PRE>   utils_hooks__hooks.suppressDeprecationWarnings = false;
   utils_hooks__hooks.deprecationHandler = null;
</PRE><PRE>   function isFunction(input) {
       return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
   }
</PRE><PRE>   function isObject(input) {
       return Object.prototype.toString.call(input) === '[object Object]';
   }
</PRE><PRE>   function locale_set__set (config) {
       var prop, i;
       for (i in config) {
           prop = config[i];
           if (isFunction(prop)) {
               this[i] = prop;
           } else {
               this['_' + i] = prop;
           }
       }
       this._config = config;
       // Lenient ordinal parsing accepts just a number in addition to
       // number + (possibly) stuff coming from _ordinalParseLenient.
       this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
   }
</PRE><PRE>   function mergeConfigs(parentConfig, childConfig) {
       var res = extend({}, parentConfig), prop;
       for (prop in childConfig) {
           if (hasOwnProp(childConfig, prop)) {
               if (isObject(parentConfig[prop]) &amp;&amp; isObject(childConfig[prop])) {
                   res[prop] = {};
                   extend(res[prop], parentConfig[prop]);
                   extend(res[prop], childConfig[prop]);
               } else if (childConfig[prop] != null) {
                   res[prop] = childConfig[prop];
               } else {
                   delete res[prop];
               }
           }
       }
       return res;
   }
</PRE><PRE>   function Locale(config) {
       if (config != null) {
           this.set(config);
       }
   }
</PRE><PRE>   var keys;
</PRE><PRE>   if (Object.keys) {
       keys = Object.keys;
   } else {
       keys = function (obj) {
           var i, res = [];
           for (i in obj) {
               if (hasOwnProp(obj, i)) {
                   res.push(i);
               }
           }
           return res;
       };
   }
</PRE><PRE>   // internal storage for locale config files
   var locales = {};
   var globalLocale;
</PRE><PRE>   function normalizeLocale(key) {
       return key ? key.toLowerCase().replace('_', '-') : key;
   }
</PRE><PRE>   // pick the locale from the array
   // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
   // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
   function chooseLocale(names) {
       var i = 0, j, next, locale, split;
</PRE><PRE>       while (i &lt; names.length) {
           split = normalizeLocale(names[i]).split('-');
           j = split.length;
           next = normalizeLocale(names[i + 1]);
           next = next ? next.split('-') : null;
           while (j &gt; 0) {
               locale = loadLocale(split.slice(0, j).join('-'));
               if (locale) {
                   return locale;
               }
               if (next &amp;&amp; next.length &gt;= j &amp;&amp; compareArrays(split, next, true) &gt;= j - 1) {
                   //the next array item is better than a shallower substring of this one
                   break;
               }
               j--;
           }
           i++;
       }
       return null;
   }
</PRE><PRE>   function loadLocale(name) {
       var oldLocale = null;
       // TODO: Find a better way to register and load all the locales in Node
       if (!locales[name] &amp;&amp; (typeof module !== 'undefined') &amp;&amp;
               module &amp;&amp; module.exports) {
           try {
               oldLocale = globalLocale._abbr;
               require('./locale/' + name);
               // because defineLocale currently also sets the global locale, we
               // want to undo that for lazy loaded locales
               locale_locales__getSetGlobalLocale(oldLocale);
           } catch (e) { }
       }
       return locales[name];
   }
</PRE><PRE>   // This function will load locale and then set the global locale.  If
   // no arguments are passed in, it will simply return the current global
   // locale key.
   function locale_locales__getSetGlobalLocale (key, values) {
       var data;
       if (key) {
           if (isUndefined(values)) {
               data = locale_locales__getLocale(key);
           }
           else {
               data = defineLocale(key, values);
           }
</PRE><PRE>           if (data) {
               // moment.duration._locale = moment._locale = data;
               globalLocale = data;
           }
       }
</PRE><PRE>       return globalLocale._abbr;
   }
</PRE><PRE>   function defineLocale (name, config) {
       if (config !== null) {
           config.abbr = name;
           if (locales[name] != null) {
               deprecateSimple('defineLocaleOverride',
                       'use moment.updateLocale(localeName, config) to change ' +
                       'an existing locale. moment.defineLocale(localeName, ' +
                       'config) should only be used for creating a new locale');
               config = mergeConfigs(locales[name]._config, config);
           } else if (config.parentLocale != null) {
               if (locales[config.parentLocale] != null) {
                   config = mergeConfigs(locales[config.parentLocale]._config, config);
               } else {
                   // treat as if there is no base config
                   deprecateSimple('parentLocaleUndefined',
                           'specified parentLocale is not defined yet');
               }
           }
           locales[name] = new Locale(config);
</PRE><PRE>           // backwards compat for now: also set the locale
           locale_locales__getSetGlobalLocale(name);
</PRE><PRE>           return locales[name];
       } else {
           // useful for testing
           delete locales[name];
           return null;
       }
   }
</PRE><PRE>   function updateLocale(name, config) {
       if (config != null) {
           var locale;
           if (locales[name] != null) {
               config = mergeConfigs(locales[name]._config, config);
           }
           locale = new Locale(config);
           locale.parentLocale = locales[name];
           locales[name] = locale;
</PRE><PRE>           // backwards compat for now: also set the locale
           locale_locales__getSetGlobalLocale(name);
       } else {
           // pass null for config to unupdate, useful for tests
           if (locales[name] != null) {
               if (locales[name].parentLocale != null) {
                   locales[name] = locales[name].parentLocale;
               } else if (locales[name] != null) {
                   delete locales[name];
               }
           }
       }
       return locales[name];
   }
</PRE><PRE>   // returns locale data
   function locale_locales__getLocale (key) {
       var locale;
</PRE><PRE>       if (key &amp;&amp; key._locale &amp;&amp; key._locale._abbr) {
           key = key._locale._abbr;
       }
</PRE><PRE>       if (!key) {
           return globalLocale;
       }
</PRE><PRE>       if (!isArray(key)) {
           //short-circuit everything else
           locale = loadLocale(key);
           if (locale) {
               return locale;
           }
           key = [key];
       }
</PRE><PRE>       return chooseLocale(key);
   }
</PRE><PRE>   function locale_locales__listLocales() {
       return keys(locales);
   }
</PRE><PRE>   var aliases = {};
</PRE><PRE>   function addUnitAlias (unit, shorthand) {
       var lowerCase = unit.toLowerCase();
       aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
   }
</PRE><PRE>   function normalizeUnits(units) {
       return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
   }
</PRE><PRE>   function normalizeObjectUnits(inputObject) {
       var normalizedInput = {},
           normalizedProp,
           prop;
</PRE><PRE>       for (prop in inputObject) {
           if (hasOwnProp(inputObject, prop)) {
               normalizedProp = normalizeUnits(prop);
               if (normalizedProp) {
                   normalizedInput[normalizedProp] = inputObject[prop];
               }
           }
       }
</PRE><PRE>       return normalizedInput;
   }
</PRE><PRE>   function makeGetSet (unit, keepTime) {
       return function (value) {
           if (value != null) {
               get_set__set(this, unit, value);
               utils_hooks__hooks.updateOffset(this, keepTime);
               return this;
           } else {
               return get_set__get(this, unit);
           }
       };
   }
</PRE><PRE>   function get_set__get (mom, unit) {
       return mom.isValid() ?
           mom._d['get' + (mom._isUTC ? 'UTC' : <I>) + unit]() : NaN;</I>
   }
</PRE><PRE>   function get_set__set (mom, unit, value) {
       if (mom.isValid()) {
           mom._d['set' + (mom._isUTC ? 'UTC' : <I>) + unit](value);</I>
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSet (units, value) {
       var unit;
       if (typeof units === 'object') {
           for (unit in units) {
               this.set(unit, units[unit]);
           }
       } else {
           units = normalizeUnits(units);
           if (isFunction(this[units])) {
               return this[units](value);
           }
       }
       return this;
   }
</PRE><PRE>   function zeroFill(number, targetLength, forceSign) {
       var absNumber = <I> + Math.abs(number),</I>
           zerosToFill = targetLength - absNumber.length,
           sign = number &gt;= 0;
       return (sign ? (forceSign ? '+' : <I>) : '-') +</I>
           Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
   }
</PRE><PRE>   var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
</PRE><PRE>   var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
</PRE><PRE>   var formatFunctions = {};
</PRE><PRE>   var formatTokenFunctions = {};
</PRE><PRE>   // token:    'M'
   // padded:   ['MM', 2]
   // ordinal:  'Mo'
   // callback: function () { this.month() + 1 }
   function addFormatToken (token, padded, ordinal, callback) {
       var func = callback;
       if (typeof callback === 'string') {
           func = function () {
               return this[callback]();
           };
       }
       if (token) {
           formatTokenFunctions[token] = func;
       }
       if (padded) {
           formatTokenFunctions[padded[0]] = function () {
               return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
           };
       }
       if (ordinal) {
           formatTokenFunctions[ordinal] = function () {
               return this.localeData().ordinal(func.apply(this, arguments), token);
           };
       }
   }
</PRE><PRE>   function removeFormattingTokens(input) {
       if (input.match(/\[[\s\S]/)) {
           return input.replace(/^\[|\]$/g, <I>);</I>
       }
       return input.replace(/\\/g, <I>);</I>
   }
</PRE><PRE>   function makeFormatFunction(format) {
       var array = format.match(formattingTokens), i, length;
</PRE><PRE>       for (i = 0, length = array.length; i &lt; length; i++) {
           if (formatTokenFunctions[array[i]]) {
               array[i] = formatTokenFunctions[array[i]];
           } else {
               array[i] = removeFormattingTokens(array[i]);
           }
       }
</PRE><PRE>       return function (mom) {
           var output = <I>, i;</I>
           for (i = 0; i &lt; length; i++) {
               output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
           }
           return output;
       };
   }
</PRE><PRE>   // format date using native date object
   function formatMoment(m, format) {
       if (!m.isValid()) {
           return m.localeData().invalidDate();
       }
</PRE><PRE>       format = expandFormat(format, m.localeData());
       formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
</PRE><PRE>       return formatFunctions[format](m);
   }
</PRE><PRE>   function expandFormat(format, locale) {
       var i = 5;
</PRE><PRE>       function replaceLongDateFormatTokens(input) {
           return locale.longDateFormat(input) || input;
       }
</PRE><PRE>       localFormattingTokens.lastIndex = 0;
       while (i &gt;= 0 &amp;&amp; localFormattingTokens.test(format)) {
           format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
           localFormattingTokens.lastIndex = 0;
           i -= 1;
       }
</PRE><PRE>       return format;
   }
</PRE><PRE>   var match1         = /\d/;            //       0 - 9
   var match2         = /\d\d/;          //      00 - 99
   var match3         = /\d{3}/;         //     000 - 999
   var match4         = /\d{4}/;         //    0000 - 9999
   var match6         = /[+-]?\d{6}/;    // -999999 - 999999
   var match1to2      = /\d\d?/;         //       0 - 99
   var match3to4      = /\d\d\d\d?/;     //     999 - 9999
   var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
   var match1to3      = /\d{1,3}/;       //       0 - 999
   var match1to4      = /\d{1,4}/;       //       0 - 9999
   var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
</PRE><PRE>   var matchUnsigned  = /\d+/;           //       0 - inf
   var matchSigned    = /[+-]?\d+/;      //    -inf - inf
</PRE><PRE>   var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
   var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
</PRE><PRE>   var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
</PRE><PRE>   // any word (or two) characters or numbers including two/three word month in arabic.
   // includes scottish gaelic two word and hyphenated months
   var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
</PRE><PRE>   var regexes = {};
</PRE><PRE>   function addRegexToken (token, regex, strictRegex) {
       regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
           return (isStrict &amp;&amp; strictRegex) ? strictRegex : regex;
       };
   }
</PRE><PRE>   function getParseRegexForToken (token, config) {
       if (!hasOwnProp(regexes, token)) {
           return new RegExp(unescapeFormat(token));
       }
</PRE><PRE>       return regexes[token](config._strict, config._locale);
   }
</PRE><PRE>   // Code from <A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript">http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript</A>
   function unescapeFormat(s) {
       return regexEscape(s.replace('\\', <I>).replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {</I>
           return p1 || p2 || p3 || p4;
       }));
   }
</PRE><PRE>   function regexEscape(s) {
       return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&amp;');
   }
</PRE><PRE>   var tokens = {};
</PRE><PRE>   function addParseToken (token, callback) {
       var i, func = callback;
       if (typeof token === 'string') {
           token = [token];
       }
       if (typeof callback === 'number') {
           func = function (input, array) {
               array[callback] = toInt(input);
           };
       }
       for (i = 0; i &lt; token.length; i++) {
           tokens[token[i]] = func;
       }
   }
</PRE><PRE>   function addWeekParseToken (token, callback) {
       addParseToken(token, function (input, array, config, token) {
           config._w = config._w || {};
           callback(input, config._w, config, token);
       });
   }
</PRE><PRE>   function addTimeToArrayFromToken(token, input, config) {
       if (input != null &amp;&amp; hasOwnProp(tokens, token)) {
           tokens[token](input, config._a, config, token);
       }
   }
</PRE><PRE>   var YEAR = 0;
   var MONTH = 1;
   var DATE = 2;
   var HOUR = 3;
   var MINUTE = 4;
   var SECOND = 5;
   var MILLISECOND = 6;
   var WEEK = 7;
   var WEEKDAY = 8;
</PRE><PRE>   var indexOf;
</PRE><PRE>   if (Array.prototype.indexOf) {
       indexOf = Array.prototype.indexOf;
   } else {
       indexOf = function (o) {
           // I know
           var i;
           for (i = 0; i &lt; this.length; ++i) {
               if (this[i] === o) {
                   return i;
               }
           }
           return -1;
       };
   }
</PRE><PRE>   function daysInMonth(year, month) {
       return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>  addFormatToken('M', ['MM', 2], 'Mo', function () {
       return this.month() + 1;
   });
</PRE><PRE>   addFormatToken('MMM', 0, 0, function (format) {
       return this.localeData().monthsShort(this, format);
   });
</PRE><PRE>   addFormatToken('MMMM', 0, 0, function (format) {
       return this.localeData().months(this, format);
   });
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('month', 'M');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('M',    match1to2);
   addRegexToken('MM',   match1to2, match2);
   addRegexToken('MMM',  function (isStrict, locale) {
       return locale.monthsShortRegex(isStrict);
   });
   addRegexToken('MMMM', function (isStrict, locale) {
       return locale.monthsRegex(isStrict);
   });
</PRE><PRE>   addParseToken(['M', 'MM'], function (input, array) {
       array[MONTH] = toInt(input) - 1;
   });
</PRE><PRE>   addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
       var month = config._locale.monthsParse(input, token, config._strict);
       // if we didn't find a month name, mark the date as invalid.
       if (month != null) {
           array[MONTH] = month;
       } else {
           getParsingFlags(config).invalidMonth = input;
       }
   });
</PRE><PRE>   // LOCALES
</PRE><PRE>   var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
   var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
   function localeMonths (m, format) {
       return isArray(this._months) ? this._months[m.month()] :
           this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
   }
</PRE><PRE>   var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
   function localeMonthsShort (m, format) {
       return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
           this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
   }
</PRE><PRE>   function units_month__handleStrictParse(monthName, format, strict) {
       var i, ii, mom, llc = monthName.toLocaleLowerCase();
       if (!this._monthsParse) {
           // this is not used
           this._monthsParse = [];
           this._longMonthsParse = [];
           this._shortMonthsParse = [];
           for (i = 0; i &lt; 12; ++i) {
               mom = create_utc__createUTC([2000, i]);
               this._shortMonthsParse[i] = this.monthsShort(mom, <I>).toLocaleLowerCase();</I>
               this._longMonthsParse[i] = this.months(mom, <I>).toLocaleLowerCase();</I>
           }
       }
</PRE><PRE>       if (strict) {
           if (format === 'MMM') {
               ii = indexOf.call(this._shortMonthsParse, llc);
               return ii !== -1 ? ii : null;
           } else {
               ii = indexOf.call(this._longMonthsParse, llc);
               return ii !== -1 ? ii : null;
           }
       } else {
           if (format === 'MMM') {
               ii = indexOf.call(this._shortMonthsParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._longMonthsParse, llc);
               return ii !== -1 ? ii : null;
           } else {
               ii = indexOf.call(this._longMonthsParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._shortMonthsParse, llc);
               return ii !== -1 ? ii : null;
           }
       }
   }
</PRE><PRE>   function localeMonthsParse (monthName, format, strict) {
       var i, mom, regex;
</PRE><PRE>       if (this._monthsParseExact) {
           return units_month__handleStrictParse.call(this, monthName, format, strict);
       }
</PRE><PRE>       if (!this._monthsParse) {
           this._monthsParse = [];
           this._longMonthsParse = [];
           this._shortMonthsParse = [];
       }
</PRE><PRE>       // TODO: add sorting
       // Sorting makes sure if one month (or abbr) is a prefix of another
       // see sorting in computeMonthsParse
       for (i = 0; i &lt; 12; i++) {
           // make the regex if we don't have it already
           mom = create_utc__createUTC([2000, i]);
           if (strict &amp;&amp; !this._longMonthsParse[i]) {
               this._longMonthsParse[i] = new RegExp('^' + this.months(mom, <I>).replace('.', </I>) + '$', 'i');
               this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, <I>).replace('.', </I>) + '$', 'i');
           }
           if (!strict &amp;&amp; !this._monthsParse[i]) {
               regex = '^' + this.months(mom, <I>) + '|^' + this.monthsShort(mom, </I>);
               this._monthsParse[i] = new RegExp(regex.replace('.', <I>), 'i');</I>
           }
           // test the regex
           if (strict &amp;&amp; format === 'MMMM' &amp;&amp; this._longMonthsParse[i].test(monthName)) {
               return i;
           } else if (strict &amp;&amp; format === 'MMM' &amp;&amp; this._shortMonthsParse[i].test(monthName)) {
               return i;
           } else if (!strict &amp;&amp; this._monthsParse[i].test(monthName)) {
               return i;
           }
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function setMonth (mom, value) {
       var dayOfMonth;
</PRE><PRE>       if (!mom.isValid()) {
           // No op
           return mom;
       }
</PRE><PRE>       if (typeof value === 'string') {
           if (/^\d+$/.test(value)) {
               value = toInt(value);
           } else {
               value = mom.localeData().monthsParse(value);
               // TODO: Another silent failure?
               if (typeof value !== 'number') {
                   return mom;
               }
           }
       }
</PRE><PRE>       dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
       mom._d['set' + (mom._isUTC ? 'UTC' : <I>) + 'Month'](value, dayOfMonth);</I>
       return mom;
   }
</PRE><PRE>   function getSetMonth (value) {
       if (value != null) {
           setMonth(this, value);
           utils_hooks__hooks.updateOffset(this, true);
           return this;
       } else {
           return get_set__get(this, 'Month');
       }
   }
</PRE><PRE>   function getDaysInMonth () {
       return daysInMonth(this.year(), this.month());
   }
</PRE><PRE>   var defaultMonthsShortRegex = matchWord;
   function monthsShortRegex (isStrict) {
       if (this._monthsParseExact) {
           if (!hasOwnProp(this, '_monthsRegex')) {
               computeMonthsParse.call(this);
           }
           if (isStrict) {
               return this._monthsShortStrictRegex;
           } else {
               return this._monthsShortRegex;
           }
       } else {
           return this._monthsShortStrictRegex &amp;&amp; isStrict ?
               this._monthsShortStrictRegex : this._monthsShortRegex;
       }
   }
</PRE><PRE>   var defaultMonthsRegex = matchWord;
   function monthsRegex (isStrict) {
       if (this._monthsParseExact) {
           if (!hasOwnProp(this, '_monthsRegex')) {
               computeMonthsParse.call(this);
           }
           if (isStrict) {
               return this._monthsStrictRegex;
           } else {
               return this._monthsRegex;
           }
       } else {
           return this._monthsStrictRegex &amp;&amp; isStrict ?
               this._monthsStrictRegex : this._monthsRegex;
       }
   }
</PRE><PRE>   function computeMonthsParse () {
       function cmpLenRev(a, b) {
           return b.length - a.length;
       }
</PRE><PRE>       var shortPieces = [], longPieces = [], mixedPieces = [],
           i, mom;
       for (i = 0; i &lt; 12; i++) {
           // make the regex if we don't have it already
           mom = create_utc__createUTC([2000, i]);
           shortPieces.push(this.monthsShort(mom, <I>));</I>
           longPieces.push(this.months(mom, <I>));</I>
           mixedPieces.push(this.months(mom, <I>));</I>   mixedPieces.push(this.monthsShort(mom, <I>));</I>
       }
       // Sorting makes sure if one month (or abbr) is a prefix of another it
       // will match the longer piece.
       shortPieces.sort(cmpLenRev);
       longPieces.sort(cmpLenRev);
       mixedPieces.sort(cmpLenRev);
       for (i = 0; i &lt; 12; i++) {
           shortPieces[i] = regexEscape(shortPieces[i]);
           longPieces[i] = regexEscape(longPieces[i]);
           mixedPieces[i] = regexEscape(mixedPieces[i]);
       }
</PRE><PRE>       this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
       this._monthsShortRegex = this._monthsRegex;
       this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
       this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
   }
</PRE><PRE>   function checkOverflow (m) {
       var overflow;
       var a = m._a;
</PRE><PRE>       if (a &amp;&amp; getParsingFlags(m).overflow === -2) {
           overflow =
               a[MONTH]       &lt; 0 || a[MONTH]       &gt; 11  ? MONTH :
               a[DATE]        &lt; 1 || a[DATE]        &gt; daysInMonth(a[YEAR], a[MONTH]) ? DATE :
               a[HOUR]        &lt; 0 || a[HOUR]        &gt; 24 || (a[HOUR] === 24 &amp;&amp; (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
               a[MINUTE]      &lt; 0 || a[MINUTE]      &gt; 59  ? MINUTE :
               a[SECOND]      &lt; 0 || a[SECOND]      &gt; 59  ? SECOND :
               a[MILLISECOND] &lt; 0 || a[MILLISECOND] &gt; 999 ? MILLISECOND :
               -1;
</PRE><PRE>           if (getParsingFlags(m)._overflowDayOfYear &amp;&amp; (overflow &lt; YEAR || overflow &gt; DATE)) {
               overflow = DATE;
           }
           if (getParsingFlags(m)._overflowWeeks &amp;&amp; overflow === -1) {
               overflow = WEEK;
           }
           if (getParsingFlags(m)._overflowWeekday &amp;&amp; overflow === -1) {
               overflow = WEEKDAY;
           }
</PRE><PRE>           getParsingFlags(m).overflow = overflow;
       }
</PRE><PRE>       return m;
   }
</PRE><PRE>   // iso 8601 regex
   // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
   var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
   var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
</PRE><PRE>   var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
</PRE><PRE>   var isoDates = [
       ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
       ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
       ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
       ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
       ['YYYY-DDD', /\d{4}-\d{3}/],
       ['YYYY-MM', /\d{4}-\d\d/, false],
       ['YYYYYYMMDD', /[+-]\d{10}/],
       ['YYYYMMDD', /\d{8}/],
       // YYYYMM is NOT allowed by the standard
       ['GGGG[W]WWE', /\d{4}W\d{3}/],
       ['GGGG[W]WW', /\d{4}W\d{2}/, false],
       ['YYYYDDD', /\d{7}/]
   ];
</PRE><PRE>   // iso time formats and regexes
   var isoTimes = [
       ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
       ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
       ['HH:mm:ss', /\d\d:\d\d:\d\d/],
       ['HH:mm', /\d\d:\d\d/],
       ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
       ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
       ['HHmmss', /\d\d\d\d\d\d/],
       ['HHmm', /\d\d\d\d/],
       ['HH', /\d\d/]
   ];
</PRE><PRE>   var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
</PRE><PRE>   // date from iso format
   function configFromISO(config) {
       var i, l,
           string = config._i,
           match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
           allowTime, dateFormat, timeFormat, tzFormat;
</PRE><PRE>       if (match) {
           getParsingFlags(config).iso = true;
</PRE><PRE>           for (i = 0, l = isoDates.length; i &lt; l; i++) {
               if (isoDates[i][1].exec(match[1])) {
                   dateFormat = isoDates[i][0];
                   allowTime = isoDates[i][2] !== false;
                   break;
               }
           }
           if (dateFormat == null) {
               config._isValid = false;
               return;
           }
           if (match[3]) {
               for (i = 0, l = isoTimes.length; i &lt; l; i++) {
                   if (isoTimes[i][1].exec(match[3])) {
                       // match[2] should be 'T' or space
                       timeFormat = (match[2] || ' ') + isoTimes[i][0];
                       break;
                   }
               }
               if (timeFormat == null) {
                   config._isValid = false;
                   return;
               }
           }
           if (!allowTime &amp;&amp; timeFormat != null) {
               config._isValid = false;
               return;
           }
           if (match[4]) {
               if (tzRegex.exec(match[4])) {
                   tzFormat = 'Z';
               } else {
                   config._isValid = false;
                   return;
               }
           }
           config._f = dateFormat + (timeFormat || <I>) + (tzFormat || </I>);
           configFromStringAndFormat(config);
       } else {
           config._isValid = false;
       }
   }
</PRE><PRE>   // date from iso format or fallback
   function configFromString(config) {
       var matched = aspNetJsonRegex.exec(config._i);
</PRE><PRE>       if (matched !== null) {
           config._d = new Date(+matched[1]);
           return;
       }
</PRE><PRE>       configFromISO(config);
       if (config._isValid === false) {
           delete config._isValid;
           utils_hooks__hooks.createFromInputFallback(config);
       }
   }
</PRE><PRE>   utils_hooks__hooks.createFromInputFallback = deprecate(
       'moment construction falls back to js Date. This is ' +
       'discouraged and will be removed in upcoming major ' +
       'release. Please refer to ' +
       '<A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1407">https://github.com/moment/moment/issues/1407</A> for more info.',
       function (config) {
           config._d = new Date(config._i + (config._useUTC ? ' UTC' : <I>));</I>
       }
   );
</PRE><PRE>   function createDate (y, m, d, h, M, s, ms) {
       //can't just apply() to create a date:
       //<A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply">http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply</A>
       var date = new Date(y, m, d, h, M, s, ms);
</PRE><PRE>       //the date constructor remaps years 0-99 to 1900-1999
       if (y &lt; 100 &amp;&amp; y &gt;= 0 &amp;&amp; isFinite(date.getFullYear())) {
           date.setFullYear(y);
       }
       return date;
   }
</PRE><PRE>   function createUTCDate (y) {
       var date = new Date(Date.UTC.apply(null, arguments));
</PRE><PRE>       //the Date.UTC function remaps years 0-99 to 1900-1999
       if (y &lt; 100 &amp;&amp; y &gt;= 0 &amp;&amp; isFinite(date.getUTCFullYear())) {
           date.setUTCFullYear(y);
       }
       return date;
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('Y', 0, 0, function () {
       var y = this.year();
       return y &lt;= 9999 ? <I> + y : '+' + y;</I>
   });
</PRE><PRE>   addFormatToken(0, ['YY', 2], 0, function () {
       return this.year() % 100;
   });
</PRE><PRE>   addFormatToken(0, ['YYYY',   4],       0, 'year');
   addFormatToken(0, ['YYYYY',  5],       0, 'year');
   addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('year', 'y');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('Y',      matchSigned);
   addRegexToken('YY',     match1to2, match2);
   addRegexToken('YYYY',   match1to4, match4);
   addRegexToken('YYYYY',  match1to6, match6);
   addRegexToken('YYYYYY', match1to6, match6);
</PRE><PRE>   addParseToken(['YYYYY', 'YYYYYY'], YEAR);
   addParseToken('YYYY', function (input, array) {
       array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
   });
   addParseToken('YY', function (input, array) {
       array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
   });
   addParseToken('Y', function (input, array) {
       array[YEAR] = parseInt(input, 10);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   function daysInYear(year) {
       return isLeapYear(year) ? 366 : 365;
   }
</PRE><PRE>   function isLeapYear(year) {
       return (year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0;
   }
</PRE><PRE>   // HOOKS
</PRE><PRE>   utils_hooks__hooks.parseTwoDigitYear = function (input) {
       return toInt(input) + (toInt(input) &gt; 68 ? 1900 : 2000);
   };
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetYear = makeGetSet('FullYear', true);
</PRE><PRE>   function getIsLeapYear () {
       return isLeapYear(this.year());
   }
</PRE><PRE>   // start-of-first-week - start-of-year
   function firstWeekOffset(year, dow, doy) {
       var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
           fwd = 7 + dow - doy,
           // first-week day local weekday -- which local weekday is fwd
           fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
</PRE><PRE>       return -fwdlw + fwd - 1;
   }
</PRE><PRE>   //<A rel="nofollow" class="external free" href="http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday">http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday</A>
   function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
       var localWeekday = (7 + weekday - dow) % 7,
           weekOffset = firstWeekOffset(year, dow, doy),
           dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
           resYear, resDayOfYear;
</PRE><PRE>       if (dayOfYear &lt;= 0) {
           resYear = year - 1;
           resDayOfYear = daysInYear(resYear) + dayOfYear;
       } else if (dayOfYear &gt; daysInYear(year)) {
           resYear = year + 1;
           resDayOfYear = dayOfYear - daysInYear(year);
       } else {
           resYear = year;
           resDayOfYear = dayOfYear;
       }
</PRE><PRE>       return {
           year: resYear,
           dayOfYear: resDayOfYear
       };
   }
</PRE><PRE>   function weekOfYear(mom, dow, doy) {
       var weekOffset = firstWeekOffset(mom.year(), dow, doy),
           week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
           resWeek, resYear;
</PRE><PRE>       if (week &lt; 1) {
           resYear = mom.year() - 1;
           resWeek = week + weeksInYear(resYear, dow, doy);
       } else if (week &gt; weeksInYear(mom.year(), dow, doy)) {
           resWeek = week - weeksInYear(mom.year(), dow, doy);
           resYear = mom.year() + 1;
       } else {
           resYear = mom.year();
           resWeek = week;
       }
</PRE><PRE>       return {
           week: resWeek,
           year: resYear
       };
   }
</PRE><PRE>   function weeksInYear(year, dow, doy) {
       var weekOffset = firstWeekOffset(year, dow, doy),
           weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
       return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
   }
</PRE><PRE>   // Pick the first defined of two or three arguments.
   function defaults(a, b, c) {
       if (a != null) {
           return a;
       }
       if (b != null) {
           return b;
       }
       return c;
   }
</PRE><PRE>   function currentDateArray(config) {
       // hooks is actually the exported moment object
       var nowValue = new Date(utils_hooks__hooks.now());
       if (config._useUTC) {
           return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
       }
       return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
   }
</PRE><PRE>   // convert an array to a date.
   // the array should mirror the parameters below
   // note: all values past the year are optional and will default to the lowest possible value.
   // [year, month, day , hour, minute, second, millisecond]
   function configFromArray (config) {
       var i, date, input = [], currentDate, yearToUse;
</PRE><PRE>       if (config._d) {
           return;
       }
</PRE><PRE>       currentDate = currentDateArray(config);
</PRE><PRE>       //compute day of the year from weeks and weekdays
       if (config._w &amp;&amp; config._a[DATE] == null &amp;&amp; config._a[MONTH] == null) {
           dayOfYearFromWeekInfo(config);
       }
</PRE><PRE>       //if the day of the year is set, figure out what it is
       if (config._dayOfYear) {
           yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
</PRE><PRE>           if (config._dayOfYear &gt; daysInYear(yearToUse)) {
               getParsingFlags(config)._overflowDayOfYear = true;
           }
</PRE><PRE>           date = createUTCDate(yearToUse, 0, config._dayOfYear);
           config._a[MONTH] = date.getUTCMonth();
           config._a[DATE] = date.getUTCDate();
       }
</PRE><PRE>       // Default to current date.
       // * if no year, month, day of month are given, default to today
       // * if day of month is given, default month and year
       // * if month is given, default only year
       // * if year is given, don't default anything
       for (i = 0; i &lt; 3 &amp;&amp; config._a[i] == null; ++i) {
           config._a[i] = input[i] = currentDate[i];
       }
</PRE><PRE>       // Zero out whatever was not defaulted, including time
       for (; i &lt; 7; i++) {
           config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
       }
</PRE><PRE>       // Check for 24:00:00.000
       if (config._a[HOUR] === 24 &amp;&amp;
               config._a[MINUTE] === 0 &amp;&amp;
               config._a[SECOND] === 0 &amp;&amp;
               config._a[MILLISECOND] === 0) {
           config._nextDay = true;
           config._a[HOUR] = 0;
       }
</PRE><PRE>       config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
       // Apply timezone offset from input. The actual utcOffset can be changed
       // with parseZone.
       if (config._tzm != null) {
           config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
       }
</PRE><PRE>       if (config._nextDay) {
           config._a[HOUR] = 24;
       }
   }
</PRE><PRE>   function dayOfYearFromWeekInfo(config) {
       var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
</PRE><PRE>       w = config._w;
       if (w.GG != null || w.W != null || w.E != null) {
           dow = 1;
           doy = 4;
</PRE><PRE>           // TODO: We need to take the current isoWeekYear, but that depends on
           // how we interpret now (local, utc, fixed offset). So create
           // a now version of current config (take local/utc/offset flags, and
           // create now).
           weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
           week = defaults(w.W, 1);
           weekday = defaults(w.E, 1);
           if (weekday &lt; 1 || weekday &gt; 7) {
               weekdayOverflow = true;
           }
       } else {
           dow = config._locale._week.dow;
           doy = config._locale._week.doy;
</PRE><PRE>           weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
           week = defaults(w.w, 1);
</PRE><PRE>           if (w.d != null) {
               // weekday -- low day numbers are considered next week
               weekday = w.d;
               if (weekday &lt; 0 || weekday &gt; 6) {
                   weekdayOverflow = true;
               }
           } else if (w.e != null) {
               // local weekday -- counting starts from begining of week
               weekday = w.e + dow;
               if (w.e &lt; 0 || w.e &gt; 6) {
                   weekdayOverflow = true;
               }
           } else {
               // default to begining of week
               weekday = dow;
           }
       }
       if (week &lt; 1 || week &gt; weeksInYear(weekYear, dow, doy)) {
           getParsingFlags(config)._overflowWeeks = true;
       } else if (weekdayOverflow != null) {
           getParsingFlags(config)._overflowWeekday = true;
       } else {
           temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
           config._a[YEAR] = temp.year;
           config._dayOfYear = temp.dayOfYear;
       }
   }
</PRE><PRE>   // constant that refers to the ISO standard
   utils_hooks__hooks.ISO_8601 = function () {};
</PRE><PRE>   // date from string and format string
   function configFromStringAndFormat(config) {
       // TODO: Move this to another part of the creation flow to prevent circular deps
       if (config._f === utils_hooks__hooks.ISO_8601) {
           configFromISO(config);
           return;
       }
</PRE><PRE>       config._a = [];
       getParsingFlags(config).empty = true;
</PRE><PRE>       // This array is used to make a Date, either with `new Date` or `Date.UTC`
       var string = <I> + config._i,</I>
           i, parsedInput, tokens, token, skipped,
           stringLength = string.length,
           totalParsedInputLength = 0;
</PRE><PRE>       tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
</PRE><PRE>       for (i = 0; i &lt; tokens.length; i++) {
           token = tokens[i];
           parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
           // console.log('token', token, 'parsedInput', parsedInput,
           //         'regex', getParseRegexForToken(token, config));
           if (parsedInput) {
               skipped = string.substr(0, string.indexOf(parsedInput));
               if (skipped.length &gt; 0) {
                   getParsingFlags(config).unusedInput.push(skipped);
               }
               string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
               totalParsedInputLength += parsedInput.length;
           }
           // don't parse if it's not a known token
           if (formatTokenFunctions[token]) {
               if (parsedInput) {
                   getParsingFlags(config).empty = false;
               }
               else {
                   getParsingFlags(config).unusedTokens.push(token);
               }
               addTimeToArrayFromToken(token, parsedInput, config);
           }
           else if (config._strict &amp;&amp; !parsedInput) {
               getParsingFlags(config).unusedTokens.push(token);
           }
       }
</PRE><PRE>       // add remaining unparsed input length to the string
       getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
       if (string.length &gt; 0) {
           getParsingFlags(config).unusedInput.push(string);
       }
</PRE><PRE>       // clear _12h flag if hour is &lt;= 12
       if (getParsingFlags(config).bigHour === true &amp;&amp;
               config._a[HOUR] &lt;= 12 &amp;&amp;
               config._a[HOUR] &gt; 0) {
           getParsingFlags(config).bigHour = undefined;
       }
</PRE><PRE>       getParsingFlags(config).parsedDateParts = config._a.slice(0);
       getParsingFlags(config).meridiem = config._meridiem;
       // handle meridiem
       config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
</PRE><PRE>       configFromArray(config);
       checkOverflow(config);
   }
</PRE><PRE>   function meridiemFixWrap (locale, hour, meridiem) {
       var isPm;
</PRE><PRE>       if (meridiem == null) {
           // nothing to do
           return hour;
       }
       if (locale.meridiemHour != null) {
           return locale.meridiemHour(hour, meridiem);
       } else if (locale.isPM != null) {
           // Fallback
           isPm = locale.isPM(meridiem);
           if (isPm &amp;&amp; hour &lt; 12) {
               hour += 12;
           }
           if (!isPm &amp;&amp; hour === 12) {
               hour = 0;
           }
           return hour;
       } else {
           // this is not supposed to happen
           return hour;
       }
   }
</PRE><PRE>   // date from string and array of format strings
   function configFromStringAndArray(config) {
       var tempConfig,
           bestMoment,
</PRE><PRE>           scoreToBeat,
           i,
           currentScore;
</PRE><PRE>       if (config._f.length === 0) {
           getParsingFlags(config).invalidFormat = true;
           config._d = new Date(NaN);
           return;
       }
</PRE><PRE>       for (i = 0; i &lt; config._f.length; i++) {
           currentScore = 0;
           tempConfig = copyConfig({}, config);
           if (config._useUTC != null) {
               tempConfig._useUTC = config._useUTC;
           }
           tempConfig._f = config._f[i];
           configFromStringAndFormat(tempConfig);
</PRE><PRE>           if (!valid__isValid(tempConfig)) {
               continue;
           }
</PRE><PRE>           // if there is any input that was not parsed add a penalty for that format
           currentScore += getParsingFlags(tempConfig).charsLeftOver;
</PRE><PRE>           //or tokens
           currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
</PRE><PRE>           getParsingFlags(tempConfig).score = currentScore;
</PRE><PRE>           if (scoreToBeat == null || currentScore &lt; scoreToBeat) {
               scoreToBeat = currentScore;
               bestMoment = tempConfig;
           }
       }
</PRE><PRE>       extend(config, bestMoment || tempConfig);
   }
</PRE><PRE>   function configFromObject(config) {
       if (config._d) {
           return;
       }
</PRE><PRE>       var i = normalizeObjectUnits(config._i);
       config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
           return obj &amp;&amp; parseInt(obj, 10);
       });
</PRE><PRE>       configFromArray(config);
   }
</PRE><PRE>   function createFromConfig (config) {
       var res = new Moment(checkOverflow(prepareConfig(config)));
       if (res._nextDay) {
           // Adding is smart enough around DST
           res.add(1, 'd');
           res._nextDay = undefined;
       }
</PRE><PRE>       return res;
   }
</PRE><PRE>   function prepareConfig (config) {
       var input = config._i,
           format = config._f;
</PRE><PRE>       config._locale = config._locale || locale_locales__getLocale(config._l);
</PRE><PRE>       if (input === null || (format === undefined &amp;&amp; input === <I>)) {</I>
           return valid__createInvalid({nullInput: true});
       }
</PRE><PRE>       if (typeof input === 'string') {
           config._i = input = config._locale.preparse(input);
       }
</PRE><PRE>       if (isMoment(input)) {
           return new Moment(checkOverflow(input));
       } else if (isArray(format)) {
           configFromStringAndArray(config);
       } else if (format) {
           configFromStringAndFormat(config);
       } else if (isDate(input)) {
           config._d = input;
       } else {
           configFromInput(config);
       }
</PRE><PRE>       if (!valid__isValid(config)) {
           config._d = null;
       }
</PRE><PRE>       return config;
   }
</PRE><PRE>   function configFromInput(config) {
       var input = config._i;
       if (input === undefined) {
           config._d = new Date(utils_hooks__hooks.now());
       } else if (isDate(input)) {
           config._d = new Date(input.valueOf());
       } else if (typeof input === 'string') {
           configFromString(config);
       } else if (isArray(input)) {
           config._a = map(input.slice(0), function (obj) {
               return parseInt(obj, 10);
           });
           configFromArray(config);
       } else if (typeof(input) === 'object') {
           configFromObject(config);
       } else if (typeof(input) === 'number') {
           // from milliseconds
           config._d = new Date(input);
       } else {
           utils_hooks__hooks.createFromInputFallback(config);
       }
   }
</PRE><PRE>   function createLocalOrUTC (input, format, locale, strict, isUTC) {
       var c = {};
</PRE><PRE>       if (typeof(locale) === 'boolean') {
           strict = locale;
           locale = undefined;
       }
       // object construction must be done this way.
       // <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1423">https://github.com/moment/moment/issues/1423</A>
       c._isAMomentObject = true;
       c._useUTC = c._isUTC = isUTC;
       c._l = locale;
       c._i = input;
       c._f = format;
       c._strict = strict;
</PRE><PRE>       return createFromConfig(c);
   }
</PRE><PRE>   function local__createLocal (input, format, locale, strict) {
       return createLocalOrUTC(input, format, locale, strict, false);
   }
</PRE><PRE>   var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1548'">https://github.com/moment/moment/issues/1548'</A>,
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() &amp;&amp; other.isValid()) {
                return other &lt; this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );
</PRE><PRE>   var prototypeMax = deprecate(
       'moment().max is deprecated, use moment.min instead. <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1548'">https://github.com/moment/moment/issues/1548'</A>,
       function () {
           var other = local__createLocal.apply(null, arguments);
           if (this.isValid() &amp;&amp; other.isValid()) {
               return other &gt; this ? this : other;
           } else {
               return valid__createInvalid();
           }
       }
   );
</PRE><PRE>   // Pick a moment m from moments so that m[fn](other) is true for all
   // other. This relies on the function fn to be transitive.
   //
   // moments should either be an array of moment objects or an array, whose
   // first element is an array of moment objects.
   function pickBy(fn, moments) {
       var res, i;
       if (moments.length === 1 &amp;&amp; isArray(moments[0])) {
           moments = moments[0];
       }
       if (!moments.length) {
           return local__createLocal();
       }
       res = moments[0];
       for (i = 1; i &lt; moments.length; ++i) {
           if (!moments[i].isValid() || moments[i][fn](res)) {
               res = moments[i];
           }
       }
       return res;
   }
</PRE><PRE>   // TODO: Use [].sort instead?
   function min () {
       var args = [].slice.call(arguments, 0);
</PRE><PRE>       return pickBy('isBefore', args);
   }
</PRE><PRE>   function max () {
       var args = [].slice.call(arguments, 0);
</PRE><PRE>       return pickBy('isAfter', args);
   }
</PRE><PRE>   var now = function () {
       return Date.now ? Date.now() : +(new Date());
   };
</PRE><PRE>   function Duration (duration) {
       var normalizedInput = normalizeObjectUnits(duration),
           years = normalizedInput.year || 0,
           quarters = normalizedInput.quarter || 0,
           months = normalizedInput.month || 0,
           weeks = normalizedInput.week || 0,
           days = normalizedInput.day || 0,
           hours = normalizedInput.hour || 0,
           minutes = normalizedInput.minute || 0,
           seconds = normalizedInput.second || 0,
           milliseconds = normalizedInput.millisecond || 0;
</PRE><PRE>       // representation for dateAddRemove
       this._milliseconds = +milliseconds +
           seconds * 1e3 + // 1000
           minutes * 6e4 + // 1000 * 60
           hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/2978">https://github.com/moment/moment/issues/2978</A>
       // Because of dateAddRemove treats 24 hours as different from a
       // day when working around DST, we need to store them separately
       this._days = +days +
           weeks * 7;
       // It is impossible translate months into days without knowing
       // which months you are are talking about, so we have to store
       // it separately.
       this._months = +months +
           quarters * 3 +
           years * 12;
</PRE><PRE>       this._data = {};
</PRE><PRE>       this._locale = locale_locales__getLocale();
</PRE><PRE>       this._bubble();
   }
</PRE><PRE>   function isDuration (obj) {
       return obj instanceof Duration;
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   function offset (token, separator) {
       addFormatToken(token, 0, 0, function () {
           var offset = this.utcOffset();
           var sign = '+';
           if (offset &lt; 0) {
               offset = -offset;
               sign = '-';
           }
           return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
       });
   }
</PRE><PRE>   offset('Z', ':');
   offset('ZZ', <I>);</I></PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('Z',  matchShortOffset);
   addRegexToken('ZZ', matchShortOffset);
   addParseToken(['Z', 'ZZ'], function (input, array, config) {
       config._useUTC = true;
       config._tzm = offsetFromString(matchShortOffset, input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   // timezone chunker
   // '+10:00' &gt; ['10',  '00']
   // '-1530'  &gt; ['-15', '30']
   var chunkOffset = /([\+\-]|\d\d)/gi;
</PRE><PRE>   function offsetFromString(matcher, string) {
       var matches = ((string || <I>).match(matcher) || []);</I>
       var chunk   = matches[matches.length - 1] || [];
       var parts   = (chunk + <I>).match(chunkOffset) || ['-', 0, 0];</I>
       var minutes = +(parts[1] * 60) + toInt(parts[2]);
</PRE><PRE>       return parts[0] === '+' ? minutes : -minutes;
   }
</PRE><PRE>   // Return a moment from input, that is local/utc/zone equivalent to model.
   function cloneWithOffset(input, model) {
       var res, diff;
       if (model._isUTC) {
           res = model.clone();
           diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
           // Use low-level api, because this fn is low-level api.
           res._d.setTime(res._d.valueOf() + diff);
           utils_hooks__hooks.updateOffset(res, false);
           return res;
       } else {
           return local__createLocal(input).local();
       }
   }
</PRE><PRE>   function getDateOffset (m) {
       // On Firefox.24 Date#getTimezoneOffset returns a floating point.
       // <A rel="nofollow" class="external free" href="https://github.com/moment/moment/pull/1871">https://github.com/moment/moment/pull/1871</A>
       return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
   }
</PRE><PRE>   // HOOKS
</PRE><PRE>   // This function will be called whenever a moment is mutated.
   // It is intended to keep the offset in sync with the timezone.
   utils_hooks__hooks.updateOffset = function () {};
</PRE><PRE>   // MOMENTS
</PRE><PRE>   // keepLocalTime = true means only change the timezone, without
   // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--&gt;
   // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
   // +0200, so we adjust the time as needed, to be valid.
   //
   // Keeping the time actually adds/subtracts (one hour)
   // from the actual represented time. That is why we call updateOffset
   // a second time. In case it wants us to change the offset again
   // _changeInProgress == true case, then we have to adjust, because
   // there is no such time in the given timezone.
   function getSetOffset (input, keepLocalTime) {
       var offset = this._offset || 0,
           localAdjust;
       if (!this.isValid()) {
           return input != null ? this : NaN;
       }
       if (input != null) {
           if (typeof input === 'string') {
               input = offsetFromString(matchShortOffset, input);
           } else if (Math.abs(input) &lt; 16) {
               input = input * 60;
           }
           if (!this._isUTC &amp;&amp; keepLocalTime) {
               localAdjust = getDateOffset(this);
           }
           this._offset = input;
           this._isUTC = true;
           if (localAdjust != null) {
               this.add(localAdjust, 'm');
           }
           if (offset !== input) {
               if (!keepLocalTime || this._changeInProgress) {
                   add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
               } else if (!this._changeInProgress) {
                   this._changeInProgress = true;
                   utils_hooks__hooks.updateOffset(this, true);
                   this._changeInProgress = null;
               }
           }
           return this;
       } else {
           return this._isUTC ? offset : getDateOffset(this);
       }
   }
</PRE><PRE>   function getSetZone (input, keepLocalTime) {
       if (input != null) {
           if (typeof input !== 'string') {
               input = -input;
           }
</PRE><PRE>           this.utcOffset(input, keepLocalTime);
</PRE><PRE>           return this;
       } else {
           return -this.utcOffset();
       }
   }
</PRE><PRE>   function setOffsetToUTC (keepLocalTime) {
       return this.utcOffset(0, keepLocalTime);
   }
</PRE><PRE>   function setOffsetToLocal (keepLocalTime) {
       if (this._isUTC) {
           this.utcOffset(0, keepLocalTime);
           this._isUTC = false;
</PRE><PRE>           if (keepLocalTime) {
               this.subtract(getDateOffset(this), 'm');
           }
       }
       return this;
   }
</PRE><PRE>   function setOffsetToParsedOffset () {
       if (this._tzm) {
           this.utcOffset(this._tzm);
       } else if (typeof this._i === 'string') {
           this.utcOffset(offsetFromString(matchOffset, this._i));
       }
       return this;
   }
</PRE><PRE>   function hasAlignedHourOffset (input) {
       if (!this.isValid()) {
           return false;
       }
       input = input ? local__createLocal(input).utcOffset() : 0;
</PRE><PRE>       return (this.utcOffset() - input) % 60 === 0;
   }
</PRE><PRE>   function isDaylightSavingTime () {
       return (
           this.utcOffset() &gt; this.clone().month(0).utcOffset() ||
           this.utcOffset() &gt; this.clone().month(5).utcOffset()
       );
   }
</PRE><PRE>   function isDaylightSavingTimeShifted () {
       if (!isUndefined(this._isDSTShifted)) {
           return this._isDSTShifted;
       }
</PRE><PRE>       var c = {};
</PRE><PRE>       copyConfig(c, this);
       c = prepareConfig(c);
</PRE><PRE>       if (c._a) {
           var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
           this._isDSTShifted = this.isValid() &amp;&amp;
               compareArrays(c._a, other.toArray()) &gt; 0;
       } else {
           this._isDSTShifted = false;
       }
</PRE><PRE>       return this._isDSTShifted;
   }
</PRE><PRE>   function isLocal () {
       return this.isValid() ? !this._isUTC : false;
   }
</PRE><PRE>   function isUtcOffset () {
       return this.isValid() ? this._isUTC : false;
   }
</PRE><PRE>   function isUtc () {
       return this.isValid() ? this._isUTC &amp;&amp; this._offset === 0 : false;
   }
</PRE><PRE>   // ASP.NET json date format regex
   var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;
</PRE><PRE>   // from <A rel="nofollow" class="external free" href="http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html">http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html</A>
   // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
   // and further modified to allow for strings containing both week and day
   var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
</PRE><PRE>   function create__createDuration (input, key) {
       var duration = input,
           // matching against regexp is expensive, do it on demand
           match = null,
           sign,
           ret,
           diffRes;
</PRE><PRE>       if (isDuration(input)) {
           duration = {
               ms : input._milliseconds,
               d  : input._days,
               M  : input._months
           };
       } else if (typeof input === 'number') {
           duration = {};
           if (key) {
               duration[key] = input;
           } else {
               duration.milliseconds = input;
           }
       } else if (!!(match = aspNetRegex.exec(input))) {
           sign = (match[1] === '-') ? -1 : 1;
           duration = {
               y  : 0,
               d  : toInt(match[DATE])        * sign,
               h  : toInt(match[HOUR])        * sign,
               m  : toInt(match[MINUTE])      * sign,
               s  : toInt(match[SECOND])      * sign,
               ms : toInt(match[MILLISECOND]) * sign
           };
       } else if (!!(match = isoRegex.exec(input))) {
           sign = (match[1] === '-') ? -1 : 1;
           duration = {
               y : parseIso(match[2], sign),
               M : parseIso(match[3], sign),
               w : parseIso(match[4], sign),
               d : parseIso(match[5], sign),
               h : parseIso(match[6], sign),
               m : parseIso(match[7], sign),
               s : parseIso(match[8], sign)
           };
       } else if (duration == null) {// checks for null or undefined
           duration = {};
       } else if (typeof duration === 'object' &amp;&amp; ('from' in duration || 'to' in duration)) {
           diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
</PRE><PRE>           duration = {};
           duration.ms = diffRes.milliseconds;
           duration.M = diffRes.months;
       }
</PRE><PRE>       ret = new Duration(duration);
</PRE><PRE>       if (isDuration(input) &amp;&amp; hasOwnProp(input, '_locale')) {
           ret._locale = input._locale;
       }
</PRE><PRE>       return ret;
   }
</PRE><PRE>   create__createDuration.fn = Duration.prototype;
</PRE><PRE>   function parseIso (inp, sign) {
       // We'd normally use ~~inp for this, but unfortunately it also
       // converts floats to ints.
       // inp may be undefined, so careful calling replace on it.
       var res = inp &amp;&amp; parseFloat(inp.replace(',', '.'));
       // apply sign while we're at it
       return (isNaN(res) ? 0 : res) * sign;
   }
</PRE><PRE>   function positiveMomentsDifference(base, other) {
       var res = {milliseconds: 0, months: 0};
</PRE><PRE>       res.months = other.month() - base.month() +
           (other.year() - base.year()) * 12;
       if (base.clone().add(res.months, 'M').isAfter(other)) {
           --res.months;
       }
</PRE><PRE>       res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
</PRE><PRE>       return res;
   }
</PRE><PRE>   function momentsDifference(base, other) {
       var res;
       if (!(base.isValid() &amp;&amp; other.isValid())) {
           return {milliseconds: 0, months: 0};
       }
</PRE><PRE>       other = cloneWithOffset(other, base);
       if (base.isBefore(other)) {
           res = positiveMomentsDifference(base, other);
       } else {
           res = positiveMomentsDifference(other, base);
           res.milliseconds = -res.milliseconds;
           res.months = -res.months;
       }
</PRE><PRE>       return res;
   }
</PRE><PRE>   function absRound (number) {
       if (number &lt; 0) {
           return Math.round(-1 * number) * -1;
       } else {
           return Math.round(number);
       }
   }
</PRE><PRE>   // TODO: remove 'name' arg after deprecation is removed
   function createAdder(direction, name) {
       return function (val, period) {
           var dur, tmp;
           //invert the arguments, but complain about it
           if (period !== null &amp;&amp; !isNaN(+period)) {
               deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
               tmp = val; val = period; period = tmp;
           }
</PRE><PRE>           val = typeof val === 'string' ? +val : val;
           dur = create__createDuration(val, period);
           add_subtract__addSubtract(this, dur, direction);
           return this;
       };
   }
</PRE><PRE>   function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
       var milliseconds = duration._milliseconds,
           days = absRound(duration._days),
           months = absRound(duration._months);
</PRE><PRE>       if (!mom.isValid()) {
           // No op
           return;
       }
</PRE><PRE>       updateOffset = updateOffset == null ? true : updateOffset;
</PRE><PRE>       if (milliseconds) {
           mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
       }
       if (days) {
           get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
       }
       if (months) {
           setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
       }
       if (updateOffset) {
           utils_hooks__hooks.updateOffset(mom, days || months);
       }
   }
</PRE><PRE>   var add_subtract__add      = createAdder(1, 'add');
   var add_subtract__subtract = createAdder(-1, 'subtract');
</PRE><PRE>   function moment_calendar__calendar (time, formats) {
       // We want to compare the start of today, vs this.
       // Getting start-of-today depends on whether we're local/utc/offset or not.
       var now = time || local__createLocal(),
           sod = cloneWithOffset(now, this).startOf('day'),
           diff = this.diff(sod, 'days', true),
           format = diff &lt; -6 ? 'sameElse' :
               diff &lt; -1 ? 'lastWeek' :
               diff &lt; 0 ? 'lastDay' :
               diff &lt; 1 ? 'sameDay' :
               diff &lt; 2 ? 'nextDay' :
               diff &lt; 7 ? 'nextWeek' : 'sameElse';
</PRE><PRE>       var output = formats &amp;&amp; (isFunction(formats[format]) ? formats[format]() : formats[format]);
</PRE><PRE>       return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
   }
</PRE><PRE>   function clone () {
       return new Moment(this);
   }
</PRE><PRE>   function isAfter (input, units) {
       var localInput = isMoment(input) ? input : local__createLocal(input);
       if (!(this.isValid() &amp;&amp; localInput.isValid())) {
           return false;
       }
       units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
       if (units === 'millisecond') {
           return this.valueOf() &gt; localInput.valueOf();
       } else {
           return localInput.valueOf() &lt; this.clone().startOf(units).valueOf();
       }
   }
</PRE><PRE>   function isBefore (input, units) {
       var localInput = isMoment(input) ? input : local__createLocal(input);
       if (!(this.isValid() &amp;&amp; localInput.isValid())) {
           return false;
       }
       units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
       if (units === 'millisecond') {
           return this.valueOf() &lt; localInput.valueOf();
       } else {
           return this.clone().endOf(units).valueOf() &lt; localInput.valueOf();
       }
   }
</PRE><PRE>   function isBetween (from, to, units, inclusivity) {
       inclusivity = inclusivity || '()';
       return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &amp;&amp;
           (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
   }
</PRE><PRE>   function isSame (input, units) {
       var localInput = isMoment(input) ? input : local__createLocal(input),
           inputMs;
       if (!(this.isValid() &amp;&amp; localInput.isValid())) {
           return false;
       }
       units = normalizeUnits(units || 'millisecond');
       if (units === 'millisecond') {
           return this.valueOf() === localInput.valueOf();
       } else {
           inputMs = localInput.valueOf();
           return this.clone().startOf(units).valueOf() &lt;= inputMs &amp;&amp; inputMs &lt;= this.clone().endOf(units).valueOf();
       }
   }
</PRE><PRE>   function isSameOrAfter (input, units) {
       return this.isSame(input, units) || this.isAfter(input,units);
   }
</PRE><PRE>   function isSameOrBefore (input, units) {
       return this.isSame(input, units) || this.isBefore(input,units);
   }
</PRE><PRE>   function diff (input, units, asFloat) {
       var that,
           zoneDelta,
           delta, output;
</PRE><PRE>       if (!this.isValid()) {
           return NaN;
       }
</PRE><PRE>       that = cloneWithOffset(input, this);
</PRE><PRE>       if (!that.isValid()) {
           return NaN;
       }
</PRE><PRE>       zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
</PRE><PRE>       units = normalizeUnits(units);
</PRE><PRE>       if (units === 'year' || units === 'month' || units === 'quarter') {
           output = monthDiff(this, that);
           if (units === 'quarter') {
               output = output / 3;
           } else if (units === 'year') {
               output = output / 12;
           }
       } else {
           delta = this - that;
           output = units === 'second' ? delta / 1e3 : // 1000
               units === 'minute' ? delta / 6e4 : // 1000 * 60
               units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
               units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
               units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
               delta;
       }
       return asFloat ? output : absFloor(output);
   }
</PRE><PRE>   function monthDiff (a, b) {
       // difference in months
       var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
           // b is in (anchor - 1 month, anchor + 1 month)
           anchor = a.clone().add(wholeMonthDiff, 'months'),
           anchor2, adjust;
</PRE><PRE>       if (b - anchor &lt; 0) {
           anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
           // linear across the month
           adjust = (b - anchor) / (anchor - anchor2);
       } else {
           anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
           // linear across the month
           adjust = (b - anchor) / (anchor2 - anchor);
       }
</PRE><PRE>       //check for negative zero, return zero if negative zero
       return -(wholeMonthDiff + adjust) || 0;
   }
</PRE><PRE>   utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
   utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
</PRE><PRE>   function toString () {
       return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
   }
</PRE><PRE>   function moment_format__toISOString () {
       var m = this.clone().utc();
       if (0 &lt; m.year() &amp;&amp; m.year() &lt;= 9999) {
           if (isFunction(Date.prototype.toISOString)) {
               // native implementation is ~50x faster, use it when we can
               return this.toDate().toISOString();
           } else {
               return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
           }
       } else {
           return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
       }
   }
</PRE><PRE>   function format (inputString) {
       if (!inputString) {
           inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
       }
       var output = formatMoment(this, inputString);
       return this.localeData().postformat(output);
   }
</PRE><PRE>   function from (time, withoutSuffix) {
       if (this.isValid() &amp;&amp;
               ((isMoment(time) &amp;&amp; time.isValid()) ||
                local__createLocal(time).isValid())) {
           return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
       } else {
           return this.localeData().invalidDate();
       }
   }
</PRE><PRE>   function fromNow (withoutSuffix) {
       return this.from(local__createLocal(), withoutSuffix);
   }
</PRE><PRE>   function to (time, withoutSuffix) {
       if (this.isValid() &amp;&amp;
               ((isMoment(time) &amp;&amp; time.isValid()) ||
                local__createLocal(time).isValid())) {
           return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
       } else {
           return this.localeData().invalidDate();
       }
   }
</PRE><PRE>   function toNow (withoutSuffix) {
       return this.to(local__createLocal(), withoutSuffix);
   }
</PRE><PRE>   // If passed a locale key, it will set the locale for this
   // instance.  Otherwise, it will return the locale configuration
   // variables for this instance.
   function locale (key) {
       var newLocaleData;
</PRE><PRE>       if (key === undefined) {
           return this._locale._abbr;
       } else {
           newLocaleData = locale_locales__getLocale(key);
           if (newLocaleData != null) {
               this._locale = newLocaleData;
           }
           return this;
       }
   }
</PRE><PRE>   var lang = deprecate(
       'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
       function (key) {
           if (key === undefined) {
               return this.localeData();
           } else {
               return this.locale(key);
           }
       }
   );
</PRE><PRE>   function localeData () {
       return this._locale;
   }
</PRE><PRE>   function startOf (units) {
       units = normalizeUnits(units);
       // the following switch intentionally omits break keywords
       // to utilize falling through the cases.
       switch (units) {
       case 'year':
           this.month(0);
           /* falls through */
       case 'quarter':
       case 'month':
           this.date(1);
           /* falls through */
       case 'week':
       case 'isoWeek':
       case 'day':
       case 'date':
           this.hours(0);
           /* falls through */
       case 'hour':
           this.minutes(0);
           /* falls through */
       case 'minute':
           this.seconds(0);
           /* falls through */
       case 'second':
           this.milliseconds(0);
       }
</PRE><PRE>       // weeks are a special case
       if (units === 'week') {
           this.weekday(0);
       }
       if (units === 'isoWeek') {
           this.isoWeekday(1);
       }
</PRE><PRE>       // quarters are also special
       if (units === 'quarter') {
           this.month(Math.floor(this.month() / 3) * 3);
       }
</PRE><PRE>       return this;
   }
</PRE><PRE>   function endOf (units) {
       units = normalizeUnits(units);
       if (units === undefined || units === 'millisecond') {
           return this;
       }
</PRE><PRE>       // 'date' is an alias for 'day', so it should be considered as such.
       if (units === 'date') {
           units = 'day';
       }
</PRE><PRE>       return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
   }
</PRE><PRE>   function to_type__valueOf () {
       return this._d.valueOf() - ((this._offset || 0) * 60000);
   }
</PRE><PRE>   function unix () {
       return Math.floor(this.valueOf() / 1000);
   }
</PRE><PRE>   function toDate () {
       return this._offset ? new Date(this.valueOf()) : this._d;
   }
</PRE><PRE>   function toArray () {
       var m = this;
       return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
   }
</PRE><PRE>   function toObject () {
       var m = this;
       return {
           years: m.year(),
           months: m.month(),
           date: m.date(),
           hours: m.hours(),
           minutes: m.minutes(),
           seconds: m.seconds(),
           milliseconds: m.milliseconds()
       };
   }
</PRE><PRE>   function toJSON () {
       // new Date(NaN).toJSON() === null
       return this.isValid() ? this.toISOString() : null;
   }
</PRE><PRE>   function moment_valid__isValid () {
       return valid__isValid(this);
   }
</PRE><PRE>   function parsingFlags () {
       return extend({}, getParsingFlags(this));
   }
</PRE><PRE>   function invalidAt () {
       return getParsingFlags(this).overflow;
   }
</PRE><PRE>   function creationData() {
       return {
           input: this._i,
           format: this._f,
           locale: this._locale,
           isUTC: this._isUTC,
           strict: this._strict
       };
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken(0, ['gg', 2], 0, function () {
       return this.weekYear() % 100;
   });
</PRE><PRE>   addFormatToken(0, ['GG', 2], 0, function () {
       return this.isoWeekYear() % 100;
   });
</PRE><PRE>   function addWeekYearFormatToken (token, getter) {
       addFormatToken(0, [token, token.length], 0, getter);
   }
</PRE><PRE>   addWeekYearFormatToken('gggg',     'weekYear');
   addWeekYearFormatToken('ggggg',    'weekYear');
   addWeekYearFormatToken('GGGG',  'isoWeekYear');
   addWeekYearFormatToken('GGGGG', 'isoWeekYear');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('weekYear', 'gg');
   addUnitAlias('isoWeekYear', 'GG');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('G',      matchSigned);
   addRegexToken('g',      matchSigned);
   addRegexToken('GG',     match1to2, match2);
   addRegexToken('gg',     match1to2, match2);
   addRegexToken('GGGG',   match1to4, match4);
   addRegexToken('gggg',   match1to4, match4);
   addRegexToken('GGGGG',  match1to6, match6);
   addRegexToken('ggggg',  match1to6, match6);
</PRE><PRE>   addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
       week[token.substr(0, 2)] = toInt(input);
   });
</PRE><PRE>   addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
       week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
   });
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetWeekYear (input) {
       return getSetWeekYearHelper.call(this,
               input,
               this.week(),
               this.weekday(),
               this.localeData()._week.dow,
               this.localeData()._week.doy);
   }
</PRE><PRE>   function getSetISOWeekYear (input) {
       return getSetWeekYearHelper.call(this,
               input, this.isoWeek(), this.isoWeekday(), 1, 4);
   }
</PRE><PRE>   function getISOWeeksInYear () {
       return weeksInYear(this.year(), 1, 4);
   }
</PRE><PRE>   function getWeeksInYear () {
       var weekInfo = this.localeData()._week;
       return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
   }
</PRE><PRE>   function getSetWeekYearHelper(input, week, weekday, dow, doy) {
       var weeksTarget;
       if (input == null) {
           return weekOfYear(this, dow, doy).year;
       } else {
           weeksTarget = weeksInYear(input, dow, doy);
           if (week &gt; weeksTarget) {
               week = weeksTarget;
           }
           return setWeekAll.call(this, input, week, weekday, dow, doy);
       }
   }
</PRE><PRE>   function setWeekAll(weekYear, week, weekday, dow, doy) {
       var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
           date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
</PRE><PRE>       this.year(date.getUTCFullYear());
       this.month(date.getUTCMonth());
       this.date(date.getUTCDate());
       return this;
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('Q', 0, 'Qo', 'quarter');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('quarter', 'Q');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('Q', match1);
   addParseToken('Q', function (input, array) {
       array[MONTH] = (toInt(input) - 1) * 3;
   });
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetQuarter (input) {
       return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('w', ['ww', 2], 'wo', 'week');
   addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('week', 'w');
   addUnitAlias('isoWeek', 'W');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('w',  match1to2);
   addRegexToken('ww', match1to2, match2);
   addRegexToken('W',  match1to2);
   addRegexToken('WW', match1to2, match2);
</PRE><PRE>   addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
       week[token.substr(0, 1)] = toInt(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   // LOCALES
</PRE><PRE>   function localeWeek (mom) {
       return weekOfYear(mom, this._week.dow, this._week.doy).week;
   }
</PRE><PRE>   var defaultLocaleWeek = {
       dow : 0, // Sunday is the first day of the week.
       doy : 6  // The week that contains Jan 1st is the first week of the year.
   };
</PRE><PRE>   function localeFirstDayOfWeek () {
       return this._week.dow;
   }
</PRE><PRE>   function localeFirstDayOfYear () {
       return this._week.doy;
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetWeek (input) {
       var week = this.localeData().week(this);
       return input == null ? week : this.add((input - week) * 7, 'd');
   }
</PRE><PRE>   function getSetISOWeek (input) {
       var week = weekOfYear(this, 1, 4).week;
       return input == null ? week : this.add((input - week) * 7, 'd');
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('D', ['DD', 2], 'Do', 'date');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('date', 'D');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('D',  match1to2);
   addRegexToken('DD', match1to2, match2);
   addRegexToken('Do', function (isStrict, locale) {
       return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
   });
</PRE><PRE>   addParseToken(['D', 'DD'], DATE);
   addParseToken('Do', function (input, array) {
       array[DATE] = toInt(input.match(match1to2)[0], 10);
   });
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetDayOfMonth = makeGetSet('Date', true);
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('d', 0, 'do', 'day');
</PRE><PRE>   addFormatToken('dd', 0, 0, function (format) {
       return this.localeData().weekdaysMin(this, format);
   });
</PRE><PRE>   addFormatToken('ddd', 0, 0, function (format) {
       return this.localeData().weekdaysShort(this, format);
   });
</PRE><PRE>   addFormatToken('dddd', 0, 0, function (format) {
       return this.localeData().weekdays(this, format);
   });
</PRE><PRE>   addFormatToken('e', 0, 0, 'weekday');
   addFormatToken('E', 0, 0, 'isoWeekday');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('day', 'd');
   addUnitAlias('weekday', 'e');
   addUnitAlias('isoWeekday', 'E');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('d',    match1to2);
   addRegexToken('e',    match1to2);
   addRegexToken('E',    match1to2);
   addRegexToken('dd',   function (isStrict, locale) {
       return locale.weekdaysMinRegex(isStrict);
   });
   addRegexToken('ddd',   function (isStrict, locale) {
       return locale.weekdaysShortRegex(isStrict);
   });
   addRegexToken('dddd',   function (isStrict, locale) {
       return locale.weekdaysRegex(isStrict);
   });
</PRE><PRE>   addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
       var weekday = config._locale.weekdaysParse(input, token, config._strict);
       // if we didn't get a weekday name, mark the date as invalid
       if (weekday != null) {
           week.d = weekday;
       } else {
           getParsingFlags(config).invalidWeekday = input;
       }
   });
</PRE><PRE>   addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
       week[token] = toInt(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   function parseWeekday(input, locale) {
       if (typeof input !== 'string') {
           return input;
       }
</PRE><PRE>       if (!isNaN(input)) {
           return parseInt(input, 10);
       }
</PRE><PRE>       input = locale.weekdaysParse(input);
       if (typeof input === 'number') {
           return input;
       }
</PRE><PRE>       return null;
   }
</PRE><PRE>   // LOCALES
</PRE><PRE>   var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
   function localeWeekdays (m, format) {
       return isArray(this._weekdays) ? this._weekdays[m.day()] :
           this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
   }
</PRE><PRE>   var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
   function localeWeekdaysShort (m) {
       return this._weekdaysShort[m.day()];
   }
</PRE><PRE>   var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
   function localeWeekdaysMin (m) {
       return this._weekdaysMin[m.day()];
   }
</PRE><PRE>   function day_of_week__handleStrictParse(weekdayName, format, strict) {
       var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
       if (!this._weekdaysParse) {
           this._weekdaysParse = [];
           this._shortWeekdaysParse = [];
           this._minWeekdaysParse = [];
</PRE><PRE>           for (i = 0; i &lt; 7; ++i) {
               mom = create_utc__createUTC([2000, 1]).day(i);
               this._minWeekdaysParse[i] = this.weekdaysMin(mom, <I>).toLocaleLowerCase();</I>      this._shortWeekdaysParse[i] = this.weekdaysShort(mom, <I>).toLocaleLowerCase();</I>
               this._weekdaysParse[i] = this.weekdays(mom, <I>).toLocaleLowerCase();</I>
           }
       }
</PRE><PRE>       if (strict) {
           if (format === 'dddd') {
               ii = indexOf.call(this._weekdaysParse, llc);
               return ii !== -1 ? ii : null;
           } else if (format === 'ddd') {
               ii = indexOf.call(this._shortWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           } else {
               ii = indexOf.call(this._minWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           }
       } else {
           if (format === 'dddd') {
               ii = indexOf.call(this._weekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._shortWeekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._minWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           } else if (format === 'ddd') {
               ii = indexOf.call(this._shortWeekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._weekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._minWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           } else {
               ii = indexOf.call(this._minWeekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._weekdaysParse, llc);
               if (ii !== -1) {
                   return ii;
               }
               ii = indexOf.call(this._shortWeekdaysParse, llc);
               return ii !== -1 ? ii : null;
           }
       }
   }
</PRE><PRE>   function localeWeekdaysParse (weekdayName, format, strict) {
       var i, mom, regex;
</PRE><PRE>       if (this._weekdaysParseExact) {
           return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
       }
</PRE><PRE>       if (!this._weekdaysParse) {
           this._weekdaysParse = [];
           this._minWeekdaysParse = [];
           this._shortWeekdaysParse = [];
           this._fullWeekdaysParse = [];
       }
</PRE><PRE>       for (i = 0; i &lt; 7; i++) {
           // make the regex if we don't have it already
</PRE><PRE>           mom = create_utc__createUTC([2000, 1]).day(i);
           if (strict &amp;&amp; !this._fullWeekdaysParse[i]) {
               this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, <I>).replace('.', '\.?') + '$', 'i');</I>
               this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, <I>).replace('.', '\.?') + '$', 'i');</I>
               this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, <I>).replace('.', '\.?') + '$', 'i');</I>
           }
           if (!this._weekdaysParse[i]) {
               regex = '^' + this.weekdays(mom, <I>) + '|^' + this.weekdaysShort(mom, </I>) + '|^' + this.weekdaysMin(mom, <I>);</I>
               this._weekdaysParse[i] = new RegExp(regex.replace('.', <I>), 'i');</I>
           }
           // test the regex
           if (strict &amp;&amp; format === 'dddd' &amp;&amp; this._fullWeekdaysParse[i].test(weekdayName)) {
               return i;
           } else if (strict &amp;&amp; format === 'ddd' &amp;&amp; this._shortWeekdaysParse[i].test(weekdayName)) {
               return i;
           } else if (strict &amp;&amp; format === 'dd' &amp;&amp; this._minWeekdaysParse[i].test(weekdayName)) {
               return i;
           } else if (!strict &amp;&amp; this._weekdaysParse[i].test(weekdayName)) {
               return i;
           }
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>  function getSetDayOfWeek (input) {
       if (!this.isValid()) {
           return input != null ? this : NaN;
       }
       var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
       if (input != null) {
           input = parseWeekday(input, this.localeData());
           return this.add(input - day, 'd');
       } else {
           return day;
       }
   }
</PRE><PRE>   function getSetLocaleDayOfWeek (input) {
       if (!this.isValid()) {
           return input != null ? this : NaN;
       }
       var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
       return input == null ? weekday : this.add(input - weekday, 'd');
   }
</PRE><PRE>   function getSetISODayOfWeek (input) {
       if (!this.isValid()) {
           return input != null ? this : NaN;
       }
       // behaves the same as moment#day except
       // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
       // as a setter, sunday should belong to the previous week.
       return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
   }
</PRE><PRE>   var defaultWeekdaysRegex = matchWord;
   function weekdaysRegex (isStrict) {
       if (this._weekdaysParseExact) {
           if (!hasOwnProp(this, '_weekdaysRegex')) {
               computeWeekdaysParse.call(this);
           }
           if (isStrict) {
               return this._weekdaysStrictRegex;
           } else {
               return this._weekdaysRegex;
           }
       } else {
           return this._weekdaysStrictRegex &amp;&amp; isStrict ?
               this._weekdaysStrictRegex : this._weekdaysRegex;
       }
   }
</PRE><PRE>   var defaultWeekdaysShortRegex = matchWord;
   function weekdaysShortRegex (isStrict) {
       if (this._weekdaysParseExact) {
           if (!hasOwnProp(this, '_weekdaysRegex')) {
               computeWeekdaysParse.call(this);
           }
           if (isStrict) {
               return this._weekdaysShortStrictRegex;
           } else {
               return this._weekdaysShortRegex;
           }
       } else {
           return this._weekdaysShortStrictRegex &amp;&amp; isStrict ?
               this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
       }
   }
</PRE><PRE>   var defaultWeekdaysMinRegex = matchWord;
   function weekdaysMinRegex (isStrict) {
       if (this._weekdaysParseExact) {
           if (!hasOwnProp(this, '_weekdaysRegex')) {
               computeWeekdaysParse.call(this);
           }
           if (isStrict) {
               return this._weekdaysMinStrictRegex;
           } else {
               return this._weekdaysMinRegex;
           }
       } else {
           return this._weekdaysMinStrictRegex &amp;&amp; isStrict ?
               this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
       }
   }
</PRE><PRE>   function computeWeekdaysParse () {
       function cmpLenRev(a, b) {
           return b.length - a.length;
       }
</PRE><PRE>       var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
           i, mom, minp, shortp, longp;
       for (i = 0; i &lt; 7; i++) {
           // make the regex if we don't have it already
           mom = create_utc__createUTC([2000, 1]).day(i);
           minp = this.weekdaysMin(mom, <I>);</I>
           shortp = this.weekdaysShort(mom, <I>);</I>
           longp = this.weekdays(mom, <I>);</I>
           minPieces.push(minp);
           shortPieces.push(shortp);
           longPieces.push(longp);
           mixedPieces.push(minp);
           mixedPieces.push(shortp);
           mixedPieces.push(longp);
       }
       // Sorting makes sure if one weekday (or abbr) is a prefix of another it
       // will match the longer piece.
       minPieces.sort(cmpLenRev);
       shortPieces.sort(cmpLenRev);
       longPieces.sort(cmpLenRev);
       mixedPieces.sort(cmpLenRev);
       for (i = 0; i &lt; 7; i++) {
           shortPieces[i] = regexEscape(shortPieces[i]);
           longPieces[i] = regexEscape(longPieces[i]);
           mixedPieces[i] = regexEscape(mixedPieces[i]);
       }
</PRE><PRE>       this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
       this._weekdaysShortRegex = this._weekdaysRegex;
       this._weekdaysMinRegex = this._weekdaysRegex;
</PRE><PRE>       this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
       this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
       this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('dayOfYear', 'DDD');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('DDD',  match1to3);
   addRegexToken('DDDD', match3);
   addParseToken(['DDD', 'DDDD'], function (input, array, config) {
       config._dayOfYear = toInt(input);
   });
</PRE><PRE>   // HELPERS
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getSetDayOfYear (input) {
       var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
       return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
   }
</PRE><PRE>   // FORMATTING
</PRE><PRE>   function hFormat() {
       return this.hours() % 12 || 12;
   }
</PRE><PRE>   function kFormat() {
       return this.hours() || 24;
   }
</PRE><PRE>   addFormatToken('H', ['HH', 2], 0, 'hour');
   addFormatToken('h', ['hh', 2], 0, hFormat);
   addFormatToken('k', ['kk', 2], 0, kFormat);
</PRE><PRE>   addFormatToken('hmm', 0, 0, function () {
       return <I> + hFormat.apply(this) + zeroFill(this.minutes(), 2);</I>
   });
</PRE><PRE>   addFormatToken('hmmss', 0, 0, function () {
       return <I> + hFormat.apply(this) + zeroFill(this.minutes(), 2) +</I>
           zeroFill(this.seconds(), 2);
   });
</PRE><PRE>   addFormatToken('Hmm', 0, 0, function () {
       return <I> + this.hours() + zeroFill(this.minutes(), 2);</I>
   });
</PRE><PRE>   addFormatToken('Hmmss', 0, 0, function () {
       return <I> + this.hours() + zeroFill(this.minutes(), 2) +</I>
           zeroFill(this.seconds(), 2);
   });
</PRE><PRE>   function meridiem (token, lowercase) {
       addFormatToken(token, 0, 0, function () {
           return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
       });
   }
</PRE><PRE>   meridiem('a', true);
   meridiem('A', false);
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('hour', 'h');
</PRE><PRE>   // PARSING
</PRE><PRE>   function matchMeridiem (isStrict, locale) {
       return locale._meridiemParse;
   }
</PRE><PRE>   addRegexToken('a',  matchMeridiem);
   addRegexToken('A',  matchMeridiem);
   addRegexToken('H',  match1to2);
   addRegexToken('h',  match1to2);
   addRegexToken('HH', match1to2, match2);
   addRegexToken('hh', match1to2, match2);
</PRE><PRE>   addRegexToken('hmm', match3to4);
   addRegexToken('hmmss', match5to6);
   addRegexToken('Hmm', match3to4);
   addRegexToken('Hmmss', match5to6);
</PRE><PRE>   addParseToken(['H', 'HH'], HOUR);
   addParseToken(['a', 'A'], function (input, array, config) {
       config._isPm = config._locale.isPM(input);
       config._meridiem = input;
   });
   addParseToken(['h', 'hh'], function (input, array, config) {
       array[HOUR] = toInt(input);
       getParsingFlags(config).bigHour = true;
   });
   addParseToken('hmm', function (input, array, config) {
       var pos = input.length - 2;
       array[HOUR] = toInt(input.substr(0, pos));
       array[MINUTE] = toInt(input.substr(pos));
       getParsingFlags(config).bigHour = true;
   });
   addParseToken('hmmss', function (input, array, config) {
       var pos1 = input.length - 4;
       var pos2 = input.length - 2;
       array[HOUR] = toInt(input.substr(0, pos1));
       array[MINUTE] = toInt(input.substr(pos1, 2));
       array[SECOND] = toInt(input.substr(pos2));
       getParsingFlags(config).bigHour = true;
   });
   addParseToken('Hmm', function (input, array, config) {
       var pos = input.length - 2;
       array[HOUR] = toInt(input.substr(0, pos));
       array[MINUTE] = toInt(input.substr(pos));
   });
   addParseToken('Hmmss', function (input, array, config) {
       var pos1 = input.length - 4;
       var pos2 = input.length - 2;
       array[HOUR] = toInt(input.substr(0, pos1));
       array[MINUTE] = toInt(input.substr(pos1, 2));
       array[SECOND] = toInt(input.substr(pos2));
   });
</PRE><PRE>   // LOCALES
</PRE><PRE>   function localeIsPM (input) {
       // IE8 Quirks Mode &amp; IE7 Standards Mode do not allow accessing strings like arrays
       // Using charAt should be more compatible.
       return ((input + <I>).toLowerCase().charAt(0) === 'p');</I>
   }
</PRE><PRE>   var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
   function localeMeridiem (hours, minutes, isLower) {
       if (hours &gt; 11) {
           return isLower ? 'pm' : 'PM';
       } else {
           return isLower ? 'am' : 'AM';
       }
   }
</PRE><PRE>   // MOMENTS
</PRE><PRE>   // Setting the hour should keep the time, because the user explicitly
   // specified which hour he wants. So trying to maintain the same hour (in
   // a new timezone) makes sense. Adding/subtracting hours does not follow
   // this rule.
   var getSetHour = makeGetSet('Hours', true);
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('m', ['mm', 2], 0, 'minute');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('minute', 'm');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('m',  match1to2);
   addRegexToken('mm', match1to2, match2);
   addParseToken(['m', 'mm'], MINUTE);
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetMinute = makeGetSet('Minutes', false);
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('s', ['ss', 2], 0, 'second');
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('second', 's');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('s',  match1to2);
   addRegexToken('ss', match1to2, match2);
   addParseToken(['s', 'ss'], SECOND);
</PRE><PRE>   // MOMENTS
</PRE><PRE>   var getSetSecond = makeGetSet('Seconds', false);
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('S', 0, 0, function () {
       return ~~(this.millisecond() / 100);
   });
</PRE><PRE>   addFormatToken(0, ['SS', 2], 0, function () {
       return ~~(this.millisecond() / 10);
   });
</PRE><PRE>   addFormatToken(0, ['SSS', 3], 0, 'millisecond');
   addFormatToken(0, ['SSSS', 4], 0, function () {
       return this.millisecond() * 10;
   });
   addFormatToken(0, ['SSSSS', 5], 0, function () {
       return this.millisecond() * 100;
   });
   addFormatToken(0, ['SSSSSS', 6], 0, function () {
       return this.millisecond() * 1000;
   });
   addFormatToken(0, ['SSSSSSS', 7], 0, function () {
       return this.millisecond() * 10000;
   });
   addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
       return this.millisecond() * 100000;
   });
   addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
       return this.millisecond() * 1000000;
   });
</PRE><PRE>   // ALIASES
</PRE><PRE>   addUnitAlias('millisecond', 'ms');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('S',    match1to3, match1);
   addRegexToken('SS',   match1to3, match2);
   addRegexToken('SSS',  match1to3, match3);
</PRE><PRE>   var token;
   for (token = 'SSSS'; token.length &lt;= 9; token += 'S') {
       addRegexToken(token, matchUnsigned);
   }
</PRE><PRE>   function parseMs(input, array) {
       array[MILLISECOND] = toInt(('0.' + input) * 1000);
   }
</PRE><PRE>   for (token = 'S'; token.length &lt;= 9; token += 'S') {
       addParseToken(token, parseMs);
   }
   // MOMENTS
</PRE><PRE>   var getSetMillisecond = makeGetSet('Milliseconds', false);
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('z',  0, 0, 'zoneAbbr');
   addFormatToken('zz', 0, 0, 'zoneName');
</PRE><PRE>   // MOMENTS
</PRE><PRE>   function getZoneAbbr () {
       return this._isUTC ? 'UTC' : <I>;</I>
   }
</PRE><PRE>   function getZoneName () {
       return this._isUTC ? 'Coordinated Universal Time' : <I>;</I>
   }
</PRE><PRE>   var momentPrototype__proto = Moment.prototype;
</PRE><PRE>   momentPrototype__proto.add               = add_subtract__add;
   momentPrototype__proto.calendar          = moment_calendar__calendar;
   momentPrototype__proto.clone             = clone;
   momentPrototype__proto.diff              = diff;
   momentPrototype__proto.endOf             = endOf;
   momentPrototype__proto.format            = format;
   momentPrototype__proto.from              = from;
   momentPrototype__proto.fromNow           = fromNow;
   momentPrototype__proto.to                = to;
   momentPrototype__proto.toNow             = toNow;
   momentPrototype__proto.get               = getSet;
   momentPrototype__proto.invalidAt         = invalidAt;
   momentPrototype__proto.isAfter           = isAfter;
   momentPrototype__proto.isBefore          = isBefore;
   momentPrototype__proto.isBetween         = isBetween;
   momentPrototype__proto.isSame            = isSame;
   momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
   momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
   momentPrototype__proto.isValid           = moment_valid__isValid;
   momentPrototype__proto.lang              = lang;
   momentPrototype__proto.locale            = locale;
   momentPrototype__proto.localeData        = localeData;
   momentPrototype__proto.max               = prototypeMax;
   momentPrototype__proto.min               = prototypeMin;
   momentPrototype__proto.parsingFlags      = parsingFlags;
   momentPrototype__proto.set               = getSet;
   momentPrototype__proto.startOf           = startOf;
   momentPrototype__proto.subtract          = add_subtract__subtract;
   momentPrototype__proto.toArray           = toArray;
   momentPrototype__proto.toObject          = toObject;
   momentPrototype__proto.toDate            = toDate;
   momentPrototype__proto.toISOString       = moment_format__toISOString;
   momentPrototype__proto.toJSON            = toJSON;
   momentPrototype__proto.toString          = toString;
   momentPrototype__proto.unix              = unix;
   momentPrototype__proto.valueOf           = to_type__valueOf;
   momentPrototype__proto.creationData      = creationData;
</PRE><PRE>   // Year
   momentPrototype__proto.year       = getSetYear;
   momentPrototype__proto.isLeapYear = getIsLeapYear;
</PRE><PRE>   // Week Year
   momentPrototype__proto.weekYear    = getSetWeekYear;
   momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
</PRE><PRE>   // Quarter
   momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
</PRE><PRE>   // Month
   momentPrototype__proto.month       = getSetMonth;
   momentPrototype__proto.daysInMonth = getDaysInMonth;
</PRE><PRE>   // Week
   momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
   momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
   momentPrototype__proto.weeksInYear    = getWeeksInYear;
   momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
</PRE><PRE>   // Day
   momentPrototype__proto.date       = getSetDayOfMonth;
   momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
   momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
   momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
   momentPrototype__proto.dayOfYear  = getSetDayOfYear;
</PRE><PRE>   // Hour
   momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
</PRE><PRE>   // Minute
   momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
</PRE><PRE>   // Second
   momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
</PRE><PRE>   // Millisecond
   momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
</PRE><PRE>   // Offset
   momentPrototype__proto.utcOffset            = getSetOffset;
   momentPrototype__proto.utc                  = setOffsetToUTC;
   momentPrototype__proto.local                = setOffsetToLocal;
   momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
   momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
   momentPrototype__proto.isDST                = isDaylightSavingTime;
   momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
   momentPrototype__proto.isLocal              = isLocal;
   momentPrototype__proto.isUtcOffset          = isUtcOffset;
   momentPrototype__proto.isUtc                = isUtc;
   momentPrototype__proto.isUTC                = isUtc;
</PRE><PRE>   // Timezone
   momentPrototype__proto.zoneAbbr = getZoneAbbr;
   momentPrototype__proto.zoneName = getZoneName;
</PRE><PRE>   // Deprecations
   momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
   momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
   momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
   momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/1779'">https://github.com/moment/moment/issues/1779'</A>, getSetZone);
</PRE><PRE>   var momentPrototype = momentPrototype__proto;
</PRE><PRE>   function moment__createUnix (input) {
       return local__createLocal(input * 1000);
   }
</PRE><PRE>   function moment__createInZone () {
       return local__createLocal.apply(null, arguments).parseZone();
   }
</PRE><PRE>   var defaultCalendar = {
       sameDay : '[Today at] LT',
       nextDay : '[Tomorrow at] LT',
       nextWeek : 'dddd [at] LT',
       lastDay : '[Yesterday at] LT',
       lastWeek : '[Last] dddd [at] LT',
       sameElse : 'L'
   };
</PRE><PRE>   function locale_calendar__calendar (key, mom, now) {
       var output = this._calendar[key];
       return isFunction(output) ? output.call(mom, now) : output;
   }
</PRE><PRE>   var defaultLongDateFormat = {
       LTS  : 'h:mm:ss A',
       LT   : 'h:mm A',
       L    : 'MM/DD/YYYY',
       LL   : 'MMMM D, YYYY',
       LLL  : 'MMMM D, YYYY h:mm A',
       LLLL : 'dddd, MMMM D, YYYY h:mm A'
   };
</PRE><PRE>   function longDateFormat (key) {
       var format = this._longDateFormat[key],
           formatUpper = this._longDateFormat[key.toUpperCase()];
</PRE><PRE>       if (format || !formatUpper) {
           return format;
       }
</PRE><PRE>       this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
           return val.slice(1);
       });
</PRE><PRE>       return this._longDateFormat[key];
   }
</PRE><PRE>   var defaultInvalidDate = 'Invalid date';
</PRE><PRE>   function invalidDate () {
       return this._invalidDate;
   }
</PRE><PRE>   var defaultOrdinal = '%d';
   var defaultOrdinalParse = /\d{1,2}/;
</PRE><PRE>   function ordinal (number) {
       return this._ordinal.replace('%d', number);
   }
</PRE><PRE>   function preParsePostFormat (string) {
       return string;
   }
</PRE><PRE>   var defaultRelativeTime = {
       future : 'in %s',
       past   : '%s ago',
       s  : 'a few seconds',
       m  : 'a minute',
       mm : '%d minutes',
       h  : 'an hour',
       hh : '%d hours',
       d  : 'a day',
       dd : '%d days',
       M  : 'a month',
       MM : '%d months',
       y  : 'a year',
       yy : '%d years'
   };
</PRE><PRE>   function relative__relativeTime (number, withoutSuffix, string, isFuture) {
       var output = this._relativeTime[string];
       return (isFunction(output)) ?
           output(number, withoutSuffix, string, isFuture) :
           output.replace(/%d/i, number);
   }
</PRE><PRE>   function pastFuture (diff, output) {
       var format = this._relativeTime[diff &gt; 0 ? 'future' : 'past'];
       return isFunction(format) ? format(output) : format.replace(/%s/i, output);
   }
</PRE><PRE>   var prototype__proto = Locale.prototype;
</PRE><PRE>   prototype__proto._calendar       = defaultCalendar;
   prototype__proto.calendar        = locale_calendar__calendar;
   prototype__proto._longDateFormat = defaultLongDateFormat;
   prototype__proto.longDateFormat  = longDateFormat;
   prototype__proto._invalidDate    = defaultInvalidDate;
   prototype__proto.invalidDate     = invalidDate;
   prototype__proto._ordinal        = defaultOrdinal;
   prototype__proto.ordinal         = ordinal;
   prototype__proto._ordinalParse   = defaultOrdinalParse;
   prototype__proto.preparse        = preParsePostFormat;
   prototype__proto.postformat      = preParsePostFormat;
   prototype__proto._relativeTime   = defaultRelativeTime;
   prototype__proto.relativeTime    = relative__relativeTime;
   prototype__proto.pastFuture      = pastFuture;
   prototype__proto.set             = locale_set__set;
</PRE><PRE>   // Month
   prototype__proto.months            =        localeMonths;
   prototype__proto._months           = defaultLocaleMonths;
   prototype__proto.monthsShort       =        localeMonthsShort;
   prototype__proto._monthsShort      = defaultLocaleMonthsShort;
   prototype__proto.monthsParse       =        localeMonthsParse;
   prototype__proto._monthsRegex      = defaultMonthsRegex;
   prototype__proto.monthsRegex       = monthsRegex;
   prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
   prototype__proto.monthsShortRegex  = monthsShortRegex;
</PRE><PRE>   // Week
   prototype__proto.week = localeWeek;
   prototype__proto._week = defaultLocaleWeek;
   prototype__proto.firstDayOfYear = localeFirstDayOfYear;
   prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
</PRE><PRE>   // Day of Week
   prototype__proto.weekdays       =        localeWeekdays;
   prototype__proto._weekdays      = defaultLocaleWeekdays;
   prototype__proto.weekdaysMin    =        localeWeekdaysMin;
   prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
   prototype__proto.weekdaysShort  =        localeWeekdaysShort;
   prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
   prototype__proto.weekdaysParse  =        localeWeekdaysParse;
</PRE><PRE>   prototype__proto._weekdaysRegex      = defaultWeekdaysRegex;
   prototype__proto.weekdaysRegex       =        weekdaysRegex;
   prototype__proto._weekdaysShortRegex = defaultWeekdaysShortRegex;
   prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
   prototype__proto._weekdaysMinRegex   = defaultWeekdaysMinRegex;
   prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;
</PRE><PRE>   // Hours
   prototype__proto.isPM = localeIsPM;
   prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
   prototype__proto.meridiem = localeMeridiem;
</PRE><PRE>   function lists__get (format, index, field, setter) {
       var locale = locale_locales__getLocale();
       var utc = create_utc__createUTC().set(setter, index);
       return locale[field](utc, format);
   }
</PRE><PRE>   function listMonthsImpl (format, index, field) {
       if (typeof format === 'number') {
           index = format;
           format = undefined;
       }
</PRE><PRE>       format = format || <I>;</I></PRE><PRE>       if (index != null) {
           return lists__get(format, index, field, 'month');
       }
</PRE><PRE>       var i;
       var out = [];
       for (i = 0; i &lt; 12; i++) {
           out[i] = lists__get(format, i, field, 'month');
       }
       return out;
   }
</PRE><PRE>   // ()
   // (5)
   // (fmt, 5)
   // (fmt)
   // (true)
   // (true, 5)
   // (true, fmt, 5)
   // (true, fmt)
   function listWeekdaysImpl (localeSorted, format, index, field) {
       if (typeof localeSorted === 'boolean') {
           if (typeof format === 'number') {
               index = format;
               format = undefined;
           }
</PRE><PRE>           format = format || <I>;</I>
       } else {
           format = localeSorted;
           index = format;
           localeSorted = false;
</PRE><PRE>           if (typeof format === 'number') {
               index = format;
               format = undefined;
           }
</PRE><PRE>           format = format || <I>;</I>
       }
</PRE><PRE>       var locale = locale_locales__getLocale(),
           shift = localeSorted ? locale._week.dow : 0;
</PRE><PRE>       if (index != null) {
           return lists__get(format, (index + shift) % 7, field, 'day');
       }
</PRE><PRE>       var i;
       var out = [];
       for (i = 0; i &lt; 7; i++) {
           out[i] = lists__get(format, (i + shift) % 7, field, 'day');
       }
       return out;
   }
</PRE><PRE>   function lists__listMonths (format, index) {
       return listMonthsImpl(format, index, 'months');
   }
</PRE><PRE>   function lists__listMonthsShort (format, index) {
       return listMonthsImpl(format, index, 'monthsShort');
   }
</PRE><PRE>   function lists__listWeekdays (localeSorted, format, index) {
       return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
   }
</PRE><PRE>   function lists__listWeekdaysShort (localeSorted, format, index) {
       return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
   }
</PRE><PRE>   function lists__listWeekdaysMin (localeSorted, format, index) {
       return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
   }
</PRE><PRE>   locale_locales__getSetGlobalLocale('en', {
       ordinalParse: /\d{1,2}(th|st|nd|rd)/,
       ordinal : function (number) {
           var b = number % 10,
               output = (toInt(number % 100 / 10) === 1) ? 'th' :
               (b === 1) ? 'st' :
               (b === 2) ? 'nd' :
               (b === 3) ? 'rd' : 'th';
           return number + output;
       }
   });
</PRE><PRE>   // Side effect imports
   utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
   utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
</PRE><PRE>   var mathAbs = Math.abs;
</PRE><PRE>   function duration_abs__abs () {
       var data           = this._data;
</PRE><PRE>       this._milliseconds = mathAbs(this._milliseconds);
       this._days         = mathAbs(this._days);
       this._months       = mathAbs(this._months);
</PRE><PRE>       data.milliseconds  = mathAbs(data.milliseconds);
       data.seconds       = mathAbs(data.seconds);
       data.minutes       = mathAbs(data.minutes);
       data.hours         = mathAbs(data.hours);
       data.months        = mathAbs(data.months);
       data.years         = mathAbs(data.years);
</PRE><PRE>       return this;
   }
</PRE><PRE>   function duration_add_subtract__addSubtract (duration, input, value, direction) {
       var other = create__createDuration(input, value);
</PRE><PRE>       duration._milliseconds += direction * other._milliseconds;
       duration._days         += direction * other._days;
       duration._months       += direction * other._months;
</PRE><PRE>       return duration._bubble();
   }
</PRE><PRE>   // supports only 2.0-style add(1, 's') or add(duration)
   function duration_add_subtract__add (input, value) {
       return duration_add_subtract__addSubtract(this, input, value, 1);
   }
</PRE><PRE>   // supports only 2.0-style subtract(1, 's') or subtract(duration)
   function duration_add_subtract__subtract (input, value) {
       return duration_add_subtract__addSubtract(this, input, value, -1);
   }
</PRE><PRE>   function absCeil (number) {
       if (number &lt; 0) {
           return Math.floor(number);
       } else {
           return Math.ceil(number);
       }
   }
</PRE><PRE>   function bubble () {
       var milliseconds = this._milliseconds;
       var days         = this._days;
       var months       = this._months;
       var data         = this._data;
       var seconds, minutes, hours, years, monthsFromDays;
</PRE><PRE>       // if we have a mix of positive and negative values, bubble down first
       // check: <A rel="nofollow" class="external free" href="https://github.com/moment/moment/issues/2166">https://github.com/moment/moment/issues/2166</A>
       if (!((milliseconds &gt;= 0 &amp;&amp; days &gt;= 0 &amp;&amp; months &gt;= 0) ||
               (milliseconds &lt;= 0 &amp;&amp; days &lt;= 0 &amp;&amp; months &lt;= 0))) {
           milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
           days = 0;
           months = 0;
       }
</PRE><PRE>       // The following code bubbles up values, see the tests for
       // examples of what that means.
       data.milliseconds = milliseconds % 1000;
</PRE><PRE>       seconds           = absFloor(milliseconds / 1000);
       data.seconds      = seconds % 60;
</PRE><PRE>       minutes           = absFloor(seconds / 60);
       data.minutes      = minutes % 60;
</PRE><PRE>       hours             = absFloor(minutes / 60);
       data.hours        = hours % 24;
</PRE><PRE>       days += absFloor(hours / 24);
</PRE><PRE>       // convert days to months
       monthsFromDays = absFloor(daysToMonths(days));
       months += monthsFromDays;
       days -= absCeil(monthsToDays(monthsFromDays));
</PRE><PRE>       // 12 months -&gt; 1 year
       years = absFloor(months / 12);
       months %= 12;
</PRE><PRE>       data.days   = days;
       data.months = months;
       data.years  = years;
</PRE><PRE>       return this;
   }
</PRE><PRE>   function daysToMonths (days) {
       // 400 years have 146097 days (taking into account leap year rules)
       // 400 years have 12 months === 4800
       return days * 4800 / 146097;
   }
</PRE><PRE>   function monthsToDays (months) {
       // the reverse of daysToMonths
       return months * 146097 / 4800;
   }
</PRE><PRE>   function as (units) {
       var days;
       var months;
       var milliseconds = this._milliseconds;
</PRE><PRE>       units = normalizeUnits(units);
</PRE><PRE>       if (units === 'month' || units === 'year') {
           days   = this._days   + milliseconds / 864e5;
           months = this._months + daysToMonths(days);
           return units === 'month' ? months : months / 12;
       } else {
           // handle milliseconds separately because of floating point math errors (issue #1867)
           days = this._days + Math.round(monthsToDays(this._months));
           switch (units) {
               case 'week'   : return days / 7     + milliseconds / 6048e5;
               case 'day'    : return days         + milliseconds / 864e5;
               case 'hour'   : return days * 24    + milliseconds / 36e5;
               case 'minute' : return days * 1440  + milliseconds / 6e4;
               case 'second' : return days * 86400 + milliseconds / 1000;
               // Math.floor prevents floating point math errors here
               case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
               default: throw new Error('Unknown unit ' + units);
           }
       }
   }
</PRE><PRE>   // TODO: Use this.as('ms')?
   function duration_as__valueOf () {
       return (
           this._milliseconds +
           this._days * 864e5 +
           (this._months % 12) * 2592e6 +
           toInt(this._months / 12) * 31536e6
       );
   }
</PRE><PRE>   function makeAs (alias) {
       return function () {
           return this.as(alias);
       };
   }
</PRE><PRE>   var asMilliseconds = makeAs('ms');
   var asSeconds      = makeAs('s');
   var asMinutes      = makeAs('m');
   var asHours        = makeAs('h');
   var asDays         = makeAs('d');
   var asWeeks        = makeAs('w');
   var asMonths       = makeAs('M');
   var asYears        = makeAs('y');
</PRE><PRE>   function duration_get__get (units) {
       units = normalizeUnits(units);
       return this[units + 's']();
   }
</PRE><PRE>   function makeGetter(name) {
       return function () {
           return this._data[name];
       };
   }
</PRE><PRE>   var milliseconds = makeGetter('milliseconds');
   var seconds      = makeGetter('seconds');
   var minutes      = makeGetter('minutes');
   var hours        = makeGetter('hours');
   var days         = makeGetter('days');
   var months       = makeGetter('months');
   var years        = makeGetter('years');
</PRE><PRE>   function weeks () {
       return absFloor(this.days() / 7);
   }
</PRE><PRE>   var round = Math.round;
   var thresholds = {
       s: 45,  // seconds to minute
       m: 45,  // minutes to hour
       h: 22,  // hours to day
       d: 26,  // days to month
       M: 11   // months to year
   };
</PRE><PRE>   // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
   function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
       return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
   }
</PRE><PRE>   function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
       var duration = create__createDuration(posNegDuration).abs();
       var seconds  = round(duration.as('s'));
       var minutes  = round(duration.as('m'));
       var hours    = round(duration.as('h'));
       var days     = round(duration.as('d'));
       var months   = round(duration.as('M'));
       var years    = round(duration.as('y'));
</PRE><PRE>       var a = seconds &lt; thresholds.s &amp;&amp; ['s', seconds]  ||
               minutes &lt;= 1           &amp;&amp; ['m']           ||
               minutes &lt; thresholds.m &amp;&amp; ['mm', minutes] ||
               hours   &lt;= 1           &amp;&amp; ['h']           ||
               hours   &lt; thresholds.h &amp;&amp; ['hh', hours]   ||
               days    &lt;= 1           &amp;&amp; ['d']           ||
               days    &lt; thresholds.d &amp;&amp; ['dd', days]    ||
               months  &lt;= 1           &amp;&amp; ['M']           ||
               months  &lt; thresholds.M &amp;&amp; ['MM', months]  ||
               years   &lt;= 1           &amp;&amp; ['y']           || ['yy', years];
</PRE><PRE>       a[2] = withoutSuffix;
       a[3] = +posNegDuration &gt; 0;
       a[4] = locale;
       return substituteTimeAgo.apply(null, a);
   }
</PRE><PRE>   // This function allows you to set a threshold for relative time strings
   function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
       if (thresholds[threshold] === undefined) {
           return false;
       }
       if (limit === undefined) {
           return thresholds[threshold];
       }
       thresholds[threshold] = limit;
       return true;
   }
</PRE><PRE>   function humanize (withSuffix) {
       var locale = this.localeData();
       var output = duration_humanize__relativeTime(this, !withSuffix, locale);
</PRE><PRE>       if (withSuffix) {
           output = locale.pastFuture(+this, output);
       }
</PRE><PRE>       return locale.postformat(output);
   }
</PRE><PRE>   var iso_string__abs = Math.abs;
</PRE><PRE>   function iso_string__toISOString() {
       // for ISO strings we do not use the normal bubbling rules:
       //  * milliseconds bubble up until they become hours
       //  * days do not bubble at all
       //  * months bubble up until they become years
       // This is because there is no context-free conversion between hours and days
       // (think of clock changes)
       // and also not between days and months (28-31 days per month)
       var seconds = iso_string__abs(this._milliseconds) / 1000;
       var days         = iso_string__abs(this._days);
       var months       = iso_string__abs(this._months);
       var minutes, hours, years;
</PRE><PRE>       // 3600 seconds -&gt; 60 minutes -&gt; 1 hour
       minutes           = absFloor(seconds / 60);
       hours             = absFloor(minutes / 60);
       seconds %= 60;
       minutes %= 60;
</PRE><PRE>       // 12 months -&gt; 1 year
       years  = absFloor(months / 12);
       months %= 12;
</PRE><PRE>// inspired by <A rel="nofollow" class="external free" href="https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js">https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js</A>
       var Y = years;
       var M = months;
       var D = days;
       var h = hours;
       var m = minutes;
       var s = seconds;
       var total = this.asSeconds();
</PRE><PRE>       if (!total) {
           // this is the same as C#'s (Noda) and python (isodate)...
           // but not other JS (goog.date)
           return 'P0D';
       }
</PRE><PRE>       return (total &lt; 0 ? '-' : <I>) +</I>
           'P' +
           (Y ? Y + 'Y' : <I>) +</I>
           (M ? M + 'M' : <I>) +</I>
           (D ? D + 'D' : <I>) +</I>
           ((h || m || s) ? 'T' : <I>) +</I>
           (h ? h + 'H' : <I>) +</I>
           (m ? m + 'M' : <I>) +</I>
           (s ? s + 'S' : <I>);</I>
   }
</PRE><PRE>   var duration_prototype__proto = Duration.prototype;
</PRE><PRE>   duration_prototype__proto.abs            = duration_abs__abs;
   duration_prototype__proto.add            = duration_add_subtract__add;
   duration_prototype__proto.subtract       = duration_add_subtract__subtract;
   duration_prototype__proto.as             = as;
   duration_prototype__proto.asMilliseconds = asMilliseconds;
   duration_prototype__proto.asSeconds      = asSeconds;
   duration_prototype__proto.asMinutes      = asMinutes;
   duration_prototype__proto.asHours        = asHours;
   duration_prototype__proto.asDays         = asDays;
   duration_prototype__proto.asWeeks        = asWeeks;
   duration_prototype__proto.asMonths       = asMonths;
   duration_prototype__proto.asYears        = asYears;
   duration_prototype__proto.valueOf        = duration_as__valueOf;
   duration_prototype__proto._bubble        = bubble;
   duration_prototype__proto.get            = duration_get__get;
   duration_prototype__proto.milliseconds   = milliseconds;
   duration_prototype__proto.seconds        = seconds;
   duration_prototype__proto.minutes        = minutes;
   duration_prototype__proto.hours          = hours;
   duration_prototype__proto.days           = days;
   duration_prototype__proto.weeks          = weeks;
   duration_prototype__proto.months         = months;
   duration_prototype__proto.years          = years;
   duration_prototype__proto.humanize       = humanize;
   duration_prototype__proto.toISOString    = iso_string__toISOString;
   duration_prototype__proto.toString       = iso_string__toISOString;
   duration_prototype__proto.toJSON         = iso_string__toISOString;
   duration_prototype__proto.locale         = locale;
   duration_prototype__proto.localeData     = localeData;
</PRE><PRE>   // Deprecations
   duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
   duration_prototype__proto.lang = lang;
</PRE><PRE>   // Side effect imports
</PRE><PRE>   // FORMATTING
</PRE><PRE>   addFormatToken('X', 0, 0, 'unix');
   addFormatToken('x', 0, 0, 'valueOf');
</PRE><PRE>   // PARSING
</PRE><PRE>   addRegexToken('x', matchSigned);
   addRegexToken('X', matchTimestamp);
   addParseToken('X', function (input, array, config) {
       config._d = new Date(parseFloat(input, 10) * 1000);
   });
   addParseToken('x', function (input, array, config) {
       config._d = new Date(toInt(input));
   });
</PRE><PRE>   // Side effect imports
</PRE><PRE>   utils_hooks__hooks.version = '2.13.0';
</PRE><PRE>   setHookCallback(local__createLocal);
</PRE><PRE>   utils_hooks__hooks.fn                    = momentPrototype;
   utils_hooks__hooks.min                   = min;
   utils_hooks__hooks.max                   = max;
   utils_hooks__hooks.now                   = now;
   utils_hooks__hooks.utc                   = create_utc__createUTC;
   utils_hooks__hooks.unix                  = moment__createUnix;
   utils_hooks__hooks.months                = lists__listMonths;
   utils_hooks__hooks.isDate                = isDate;
   utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
   utils_hooks__hooks.invalid               = valid__createInvalid;
   utils_hooks__hooks.duration              = create__createDuration;
   utils_hooks__hooks.isMoment              = isMoment;
   utils_hooks__hooks.weekdays              = lists__listWeekdays;
   utils_hooks__hooks.parseZone             = moment__createInZone;
   utils_hooks__hooks.localeData            = locale_locales__getLocale;
   utils_hooks__hooks.isDuration            = isDuration;
   utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
   utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
   utils_hooks__hooks.defineLocale          = defineLocale;
   utils_hooks__hooks.updateLocale          = updateLocale;
   utils_hooks__hooks.locales               = locale_locales__listLocales;
   utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
   utils_hooks__hooks.normalizeUnits        = normalizeUnits;
   utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
   utils_hooks__hooks.prototype             = momentPrototype;
</PRE><PRE>   var _moment = utils_hooks__hooks;
</PRE><PRE>   return _moment;
</PRE><P>}));
},{}],7:[function(require,module,exports){
/**
</P><PRE>* @namespace Chart
*/
</PRE><P>var Chart = require(26)();
</P><P>require(25)(Chart);
require(24)(Chart);
require(21)(Chart);
require(22)(Chart);
require(23)(Chart);
require(27)(Chart);
require(31)(Chart);
require(29)(Chart);
require(30)(Chart);
require(32)(Chart);
require(28)(Chart);
require(33)(Chart);
</P><P>require(34)(Chart);
require(35)(Chart);
require(36)(Chart);
require(37)(Chart);
</P><P>require(40)(Chart);
require(38)(Chart);
require(39)(Chart);
require(41)(Chart);
require(42)(Chart);
require(43)(Chart);
</P><P>// Controllers must be loaded after elements
// See Chart.core.datasetController.dataElementType
require(15)(Chart);
require(16)(Chart);
require(17)(Chart);
require(18)(Chart);
require(19)(Chart);
require(20)(Chart);
</P><P>require(8)(Chart);
require(9)(Chart);
require(10)(Chart);
require(11)(Chart);
require(12)(Chart);
require(13)(Chart);
require(14)(Chart);
</P><P>window.Chart = module.exports = Chart;
</P><P>},{&quot;10&quot;:10,&quot;11&quot;:11,&quot;12&quot;:12,&quot;13&quot;:13,&quot;14&quot;:14,&quot;15&quot;:15,&quot;16&quot;:16,&quot;17&quot;:17,&quot;18&quot;:18,&quot;19&quot;:19,&quot;20&quot;:20,&quot;21&quot;:21,&quot;22&quot;:22,&quot;23&quot;:23,&quot;24&quot;:24,&quot;25&quot;:25,&quot;26&quot;:26,&quot;27&quot;:27,&quot;28&quot;:28,&quot;29&quot;:29,&quot;30&quot;:30,&quot;31&quot;:31,&quot;32&quot;:32,&quot;33&quot;:33,&quot;34&quot;:34,&quot;35&quot;:35,&quot;36&quot;:36,&quot;37&quot;:37,&quot;38&quot;:38,&quot;39&quot;:39,&quot;40&quot;:40,&quot;41&quot;:41,&quot;42&quot;:42,&quot;43&quot;:43,&quot;8&quot;:8,&quot;9&quot;:9}],8:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	Chart.Bar = function(context, config) {
		config.type = 'bar';
</P><P>		return new Chart(context, config);
	};
</P><P>};
},{}],9:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	Chart.Bubble = function(context, config) {
		config.type = 'bubble';
		return new Chart(context, config);
	};
</P><P>};
},{}],10:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	Chart.Doughnut = function(context, config) {
		config.type = 'doughnut';
</P><P>		return new Chart(context, config);
	};
</P><P>};
},{}],11:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	Chart.Line = function(context, config) {
		config.type = 'line';
</P><P>		return new Chart(context, config);
	};
</P><P>};
},{}],12:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	Chart.PolarArea = function(context, config) {
		config.type = 'polarArea';
</P><P>		return new Chart(context, config);
	};
</P><P>};
},{}],13:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	Chart.Radar = function(context, config) {
		config.options = Chart.helpers.configMerge({ aspectRatio: 1 }, config.options);
		config.type = 'radar';
</P><P>		return new Chart(context, config);
	};
</P><P>};
</P><P>},{}],14:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var defaultConfig = {
		hover: {
			mode: 'single'
		},
</P><P>		scales: {
			xAxes: [{
				type: &quot;linear&quot;, // scatter should not use a category axis
				position: &quot;bottom&quot;,
				id: &quot;x-axis-1&quot; // need an ID so datasets can reference the scale
			}],
			yAxes: [{
				type: &quot;linear&quot;,
				position: &quot;left&quot;,
				id: &quot;y-axis-1&quot;
			}]
		},
</P><P>		tooltips: {
			callbacks: {
				title: function(tooltipItems, data) {
					// Title doesn't make sense for scatter since we format the data as a point
					return <I>;</I>
				},
				label: function(tooltipItem, data) {
					return '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';
				}
			}
		}
	};
</P><P>	// Register the default config for this type
	Chart.defaults.scatter = defaultConfig;
</P><P>	// Scatter charts use line controllers
	Chart.controllers.scatter = Chart.controllers.line;
</P><P>	Chart.Scatter = function(context, config) {
		config.type = 'scatter';
		return new Chart(context, config);
	};
</P><P>};
},{}],15:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.defaults.bar = {
		hover: {
			mode: &quot;label&quot;
		},
</P><P>		scales: {
			xAxes: [{
				type: &quot;category&quot;,
</P><P>				// Specific to Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,
</P><P>				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}],
			yAxes: [{
				type: &quot;linear&quot;
			}]
		}
	};
</P><P>	Chart.controllers.bar = Chart.DatasetController.extend({
</P><P>		dataElementType: Chart.elements.Rectangle,
</P><P>		initialize: function(chart, datasetIndex) {
			Chart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);
</P><P>			// Use this to indicate that this is a bar dataset.
			this.getMeta().bar = true;
		},
</P><P>		// Get the number of datasets that display bars. We use this to correctly calculate the bar width
		getBarCount: function getBarCount() {
			var me = this;
			var barCount = 0;
			helpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {
				var meta = me.chart.getDatasetMeta(datasetIndex);
				if (meta.bar &amp;&amp; me.chart.isDatasetVisible(datasetIndex)) {
					++barCount;
				}
			}, me);
			return barCount;
		},
</P><P>		update: function update(reset) {
			var me = this;
			helpers.each(me.getMeta().data, function(rectangle, index) {
				me.updateElement(rectangle, index, reset);
			}, me);
		},
</P><P>		updateElement: function updateElement(rectangle, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var xScale = me.getScaleForId(meta.xAxisID);
			var yScale = me.getScaleForId(meta.yAxisID);
			var scaleBase = yScale.getBasePixel();
			var rectangleElementOptions = me.chart.options.elements.rectangle;
			var custom = rectangle.custom || {};
			var dataset = me.getDataset();
</P><P>			helpers.extend(rectangle, {
				// Utility
				_xScale: xScale,
				_yScale: yScale,
				_datasetIndex: me.index,
				_index: index,
</P><P>				// Desired view properties
				_model: {
					x: me.calculateBarX(index, me.index),
					y: reset ? scaleBase : me.calculateBarY(index, me.index),
</P><P>					// Tooltip
					label: me.chart.data.labels[index],
					datasetLabel: dataset.label,
</P><P>					// Appearance
					base: reset ? scaleBase : me.calculateBarBase(me.index, index),
					width: me.calculateBarWidth(index),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),
					borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,
					borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)
				}
			});
			rectangle.pivot();
		},
</P><P>		calculateBarBase: function(datasetIndex, index) {
			var me = this;
			var meta = me.getMeta();
			var yScale = me.getScaleForId(meta.yAxisID);
			var base = 0;
</P><P>			if (yScale.options.stacked) {
				var chart = me.chart;
				var datasets = chart.data.datasets;
				var value = datasets[datasetIndex].data[index];
</P><P>				if (value &lt; 0) {
					for (var i = 0; i &lt; datasetIndex; i++) {
						var negDS = datasets[i];
						var negDSMeta = chart.getDatasetMeta(i);
						if (negDSMeta.bar &amp;&amp; negDSMeta.yAxisID === yScale.id &amp;&amp; chart.isDatasetVisible(i)) {
							base += negDS.data[index] &lt; 0 ? negDS.data[index] : 0;
						}
					}
				} else {
					for (var j = 0; j &lt; datasetIndex; j++) {
						var posDS = datasets[j];
						var posDSMeta = chart.getDatasetMeta(j);
						if (posDSMeta.bar &amp;&amp; posDSMeta.yAxisID === yScale.id &amp;&amp; chart.isDatasetVisible(j)) {
							base += posDS.data[index] &gt; 0 ? posDS.data[index] : 0;
						}
					}
				}
</P><P>				return yScale.getPixelForValue(base);
			}
</P><P>			return yScale.getBasePixel();
		},
</P><P>		getRuler: function(index) {
			var me = this;
			var meta = me.getMeta();
			var xScale = me.getScaleForId(meta.xAxisID);
			var datasetCount = me.getBarCount();
</P><P>			var tickWidth;
</P><P>			if (xScale.options.type === 'category') {
				tickWidth = xScale.getPixelForTick(index + 1) - xScale.getPixelForTick(index);
			} else {
				// Average width
				tickWidth = xScale.width / xScale.ticks.length;
			}
			var categoryWidth = tickWidth * xScale.options.categoryPercentage;
			var categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;
			var fullBarWidth = categoryWidth / datasetCount;
</P><P>			if (xScale.ticks.length !== me.chart.data.labels.length) {
			    var perc = xScale.ticks.length / me.chart.data.labels.length;
			    fullBarWidth = fullBarWidth * perc;
			}
</P><P>			var barWidth = fullBarWidth * xScale.options.barPercentage;
			var barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);
</P><P>			return {
				datasetCount: datasetCount,
				tickWidth: tickWidth,
				categoryWidth: categoryWidth,
				categorySpacing: categorySpacing,
				fullBarWidth: fullBarWidth,
				barWidth: barWidth,
				barSpacing: barSpacing
			};
		},
</P><P>		calculateBarWidth: function(index) {
			var xScale = this.getScaleForId(this.getMeta().xAxisID);
			var ruler = this.getRuler(index);
			return xScale.options.stacked ? ruler.categoryWidth : ruler.barWidth;
		},
</P><P>		// Get bar index from the given dataset index accounting for the fact that not all bars are visible
		getBarIndex: function(datasetIndex) {
			var barIndex = 0;
			var meta, j;
</P><P>			for (j = 0; j &lt; datasetIndex; ++j) {
				meta = this.chart.getDatasetMeta(j);
				if (meta.bar &amp;&amp; this.chart.isDatasetVisible(j)) {
					++barIndex;
				}
			}
</P><P>			return barIndex;
		},
</P><P>		calculateBarX: function(index, datasetIndex) {
			var me = this;
			var meta = me.getMeta();
			var xScale = me.getScaleForId(meta.xAxisID);
			var barIndex = me.getBarIndex(datasetIndex);
</P><P>			var ruler = me.getRuler(index);
			var leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);
			leftTick -= me.chart.isCombo ? (ruler.tickWidth / 2) : 0;
</P><P>			if (xScale.options.stacked) {
				return leftTick + (ruler.categoryWidth / 2) + ruler.categorySpacing;
			}
</P><P>			return leftTick +
				(ruler.barWidth / 2) +
				ruler.categorySpacing +
				(ruler.barWidth * barIndex) +
				(ruler.barSpacing / 2) +
				(ruler.barSpacing * barIndex);
		},
</P><P>		calculateBarY: function(index, datasetIndex) {
			var me = this;
			var meta = me.getMeta();
			var yScale = me.getScaleForId(meta.yAxisID);
			var value = me.getDataset().data[index];
</P><P>			if (yScale.options.stacked) {
</P><P>				var sumPos = 0,
					sumNeg = 0;
</P><P>				for (var i = 0; i &lt; datasetIndex; i++) {
					var ds = me.chart.data.datasets[i];
					var dsMeta = me.chart.getDatasetMeta(i);
					if (dsMeta.bar &amp;&amp; dsMeta.yAxisID === yScale.id &amp;&amp; me.chart.isDatasetVisible(i)) {
						if (ds.data[index] &lt; 0) {
							sumNeg += ds.data[index] || 0;
						} else {
							sumPos += ds.data[index] || 0;
						}
					}
				}
</P><P>				if (value &lt; 0) {
					return yScale.getPixelForValue(sumNeg + value);
				} else {
					return yScale.getPixelForValue(sumPos + value);
				}
			}
</P><P>			return yScale.getPixelForValue(value);
		},
</P><P>		draw: function(ease) {
			var me = this;
			var easingDecimal = ease || 1;
			helpers.each(me.getMeta().data, function(rectangle, index) {
				var d = me.getDataset().data[index];
				if (d !== null &amp;&amp; d !== undefined &amp;&amp; !isNaN(d)) {
					rectangle.transition(easingDecimal).draw();
				}
			}, me);
		},
</P><P>		setHoverStyle: function(rectangle) {
			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
			var index = rectangle._index;
</P><P>			var custom = rectangle.custom || {};
			var model = rectangle._model;
			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
		},
</P><P>		removeHoverStyle: function(rectangle) {
			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
			var index = rectangle._index;
			var custom = rectangle.custom || {};
			var model = rectangle._model;
			var rectangleElementOptions = this.chart.options.elements.rectangle;
</P><P>			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
		}
</P><P>	});
</P><P>
	// including horizontalBar in the bar file, instead of a file of its own
	// it extends bar (like pie extends doughnut)
	Chart.defaults.horizontalBar = {
		hover: {
			mode: &quot;label&quot;
		},
</P><P>		scales: {
			xAxes: [{
				type: &quot;linear&quot;,
				position: &quot;bottom&quot;
			}],
			yAxes: [{
				position: &quot;left&quot;,
				type: &quot;category&quot;,
</P><P>				// Specific to Horizontal Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,
</P><P>				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}]
		},
		elements: {
			rectangle: {
				borderSkipped: 'left'
			}
		},
		tooltips: {
			callbacks: {
				title: function(tooltipItems, data) {
					// Pick first xLabel for now
					var title = <I>;</I></P><P>					if (tooltipItems.length &gt; 0) {
						if (tooltipItems[0].yLabel) {
							title = tooltipItems[0].yLabel;
						} else if (data.labels.length &gt; 0 &amp;&amp; tooltipItems[0].index &lt; data.labels.length) {
							title = data.labels[tooltipItems[0].index];
						}
					}
</P><P>					return title;
				},
				label: function(tooltipItem, data) {
					var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || <I>;</I>
				return datasetLabel + ': ' + tooltipItem.xLabel;
				}
			}
		}
	};
</P><P>	Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
		updateElement: function updateElement(rectangle, index, reset, numBars) {
			var me = this;
			var meta = me.getMeta();
			var xScale = me.getScaleForId(meta.xAxisID);
			var yScale = me.getScaleForId(meta.yAxisID);
			var scaleBase = xScale.getBasePixel();
			var custom = rectangle.custom || {};
			var dataset = me.getDataset();
			var rectangleElementOptions = me.chart.options.elements.rectangle;
</P><P>			helpers.extend(rectangle, {
				// Utility
				_xScale: xScale,
				_yScale: yScale,
				_datasetIndex: me.index,
				_index: index,
</P><P>				// Desired view properties
				_model: {
					x: reset ? scaleBase : me.calculateBarX(index, me.index),
					y: me.calculateBarY(index, me.index),
</P><P>					// Tooltip
					label: me.chart.data.labels[index],
					datasetLabel: dataset.label,
</P><P>					// Appearance
					base: reset ? scaleBase : me.calculateBarBase(me.index, index),
					height: me.calculateBarHeight(index),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),
					borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,
					borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)
				},
</P><P>				draw: function () {
					var ctx = this._chart.ctx;
					var vm = this._view;
</P><P>					var halfHeight = vm.height / 2,
						topY = vm.y - halfHeight,
						bottomY = vm.y + halfHeight,
						right = vm.base - (vm.base - vm.x),
						halfStroke = vm.borderWidth / 2;
</P><P>					// Canvas doesn't allow us to stroke inside the width so we can
					// adjust the sizes to fit if we're setting a stroke on the line
					if (vm.borderWidth) {
						topY += halfStroke;
						bottomY -= halfStroke;
						right += halfStroke;
					}
</P><P>					ctx.beginPath();
</P><P>					ctx.fillStyle = vm.backgroundColor;
					ctx.strokeStyle = vm.borderColor;
					ctx.lineWidth = vm.borderWidth;
</P><P>					// Corner points, from bottom-left to bottom-right clockwise
					// | 1 2 |
					// | 0 3 |
					var corners = [
						[vm.base, bottomY],
						[vm.base, topY],
						[right, topY],
						[right, bottomY]
					];
</P><P>					// Find first (starting) corner with fallback to 'bottom'
					var borders = ['bottom', 'left', 'top', 'right'];
					var startCorner = borders.indexOf(vm.borderSkipped, 0);
					if (startCorner === -1)
						startCorner = 0;
</P><P>					function cornerAt(index) {
						return corners[(startCorner + index) % 4];
					}
</P><P>					// Draw rectangle from 'startCorner'
					ctx.moveTo.apply(ctx, cornerAt(0));
					for (var i = 1; i &lt; 4; i++)
						ctx.lineTo.apply(ctx, cornerAt(i));
</P><P>					ctx.fill();
					if (vm.borderWidth) {
						ctx.stroke();
					}
				},
</P><P>				inRange: function (mouseX, mouseY) {
					var vm = this._view;
					var inRange = false;
</P><P>					if (vm) {
						if (vm.x &lt; vm.base) {
							inRange = (mouseY &gt;= vm.y - vm.height / 2 &amp;&amp; mouseY &lt;= vm.y + vm.height / 2) &amp;&amp; (mouseX &gt;= vm.x &amp;&amp; mouseX &lt;= vm.base);
						} else {
							inRange = (mouseY &gt;= vm.y - vm.height / 2 &amp;&amp; mouseY &lt;= vm.y + vm.height / 2) &amp;&amp; (mouseX &gt;= vm.base &amp;&amp; mouseX &lt;= vm.x);
						}
					}
</P><P>					return inRange;
				}
			});
</P><P>			rectangle.pivot();
		},
</P><P>		calculateBarBase: function (datasetIndex, index) {
			var me = this;
			var meta = me.getMeta();
			var xScale = me.getScaleForId(meta.xAxisID);
			var base = 0;
</P><P>			if (xScale.options.stacked) {
</P><P>				var value = me.chart.data.datasets[datasetIndex].data[index];
</P><P>				if (value &lt; 0) {
					for (var i = 0; i &lt; datasetIndex; i++) {
						var negDS = me.chart.data.datasets[i];
						var negDSMeta = me.chart.getDatasetMeta(i);
						if (negDSMeta.bar &amp;&amp; negDSMeta.xAxisID === xScale.id &amp;&amp; me.chart.isDatasetVisible(i)) {
							base += negDS.data[index] &lt; 0 ? negDS.data[index] : 0;
						}
					}
				} else {
					for (var j = 0; j &lt; datasetIndex; j++) {
						var posDS = me.chart.data.datasets[j];
						var posDSMeta = me.chart.getDatasetMeta(j);
						if (posDSMeta.bar &amp;&amp; posDSMeta.xAxisID === xScale.id &amp;&amp; me.chart.isDatasetVisible(j)) {
							base += posDS.data[index] &gt; 0 ? posDS.data[index] : 0;
						}
					}
				}
</P><P>				return xScale.getPixelForValue(base);
			}
</P><P>			return xScale.getBasePixel();
		},
</P><P>		getRuler: function (index) {
			var me = this;
			var meta = me.getMeta();
			var yScale = me.getScaleForId(meta.yAxisID);
			var datasetCount = me.getBarCount();
</P><P>			var tickHeight;
			if (yScale.options.type === 'category') {
				tickHeight = yScale.getPixelForTick(index + 1) - yScale.getPixelForTick(index);
			} else {
				// Average width
				tickHeight = yScale.width / yScale.ticks.length;
			}
			var categoryHeight = tickHeight * yScale.options.categoryPercentage;
			var categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;
			var fullBarHeight = categoryHeight / datasetCount;
</P><P>			if (yScale.ticks.length !== me.chart.data.labels.length) {
				var perc = yScale.ticks.length / me.chart.data.labels.length;
				fullBarHeight = fullBarHeight * perc;
			}
</P><P>			var barHeight = fullBarHeight * yScale.options.barPercentage;
			var barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);
</P><P>			return {
				datasetCount: datasetCount,
				tickHeight: tickHeight,
				categoryHeight: categoryHeight,
				categorySpacing: categorySpacing,
				fullBarHeight: fullBarHeight,
				barHeight: barHeight,
				barSpacing: barSpacing,
			};
		},
</P><P>		calculateBarHeight: function (index) {
			var me = this;
			var yScale = me.getScaleForId(me.getMeta().yAxisID);
			var ruler = me.getRuler(index);
			return yScale.options.stacked ? ruler.categoryHeight : ruler.barHeight;
		},</P><P>		calculateBarX: function (index, datasetIndex) {
			var me = this;
			var meta = me.getMeta();
			var xScale = me.getScaleForId(meta.xAxisID);
			var value = me.getDataset().data[index];
</P><P>			if (xScale.options.stacked) {
</P><P>				var sumPos = 0,
					sumNeg = 0;
</P><P>				for (var i = 0; i &lt; datasetIndex; i++) {
					var ds = me.chart.data.datasets[i];
					var dsMeta = me.chart.getDatasetMeta(i);
					if (dsMeta.bar &amp;&amp; dsMeta.xAxisID === xScale.id &amp;&amp; me.chart.isDatasetVisible(i)) {
						if (ds.data[index] &lt; 0) {
							sumNeg += ds.data[index] || 0;
						} else {
							sumPos += ds.data[index] || 0;
						}
					}
				}
</P><P>				if (value &lt; 0) {
					return xScale.getPixelForValue(sumNeg + value);
				} else {
					return xScale.getPixelForValue(sumPos + value);
				}
			}
</P><P>			return xScale.getPixelForValue(value);
		},
</P><P>		calculateBarY: function (index, datasetIndex) {
			var me = this;
			var meta = me.getMeta();
			var yScale = me.getScaleForId(meta.yAxisID);
			var barIndex = me.getBarIndex(datasetIndex);
</P><P>			var ruler = me.getRuler(index);
			var topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);
			topTick -= me.chart.isCombo ? (ruler.tickHeight / 2) : 0;
</P><P>			if (yScale.options.stacked) {
				return topTick + (ruler.categoryHeight / 2) + ruler.categorySpacing;
			}
</P><P>			return topTick +
				(ruler.barHeight / 2) +
				ruler.categorySpacing +
				(ruler.barHeight * barIndex) +
				(ruler.barSpacing / 2) +
				(ruler.barSpacing * barIndex);
		}
	});
};
</P><P>},{}],16:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.defaults.bubble = {
		hover: {
			mode: &quot;single&quot;
		},
</P><P>		scales: {
			xAxes: [{
				type: &quot;linear&quot;, // bubble should probably use a linear scale by default
				position: &quot;bottom&quot;,
				id: &quot;x-axis-0&quot; // need an ID so datasets can reference the scale
			}],
			yAxes: [{
				type: &quot;linear&quot;,
				position: &quot;left&quot;,
				id: &quot;y-axis-0&quot;
			}]
		},
</P><P>		tooltips: {
			callbacks: {
				title: function(tooltipItems, data) {
					// Title doesn't make sense for scatter since we format the data as a point
					return <I>;</I>
				},
				label: function(tooltipItem, data) {
					var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || <I>;</I>
					var dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
					return datasetLabel + ': (' + dataPoint.x + ', ' + dataPoint.y + ', ' + dataPoint.r + ')';
				}
			}
		}
	};
</P><P>	Chart.controllers.bubble = Chart.DatasetController.extend({
</P><P>		dataElementType: Chart.elements.Point,
</P><P>		update: function update(reset) {
			var me = this;
			var meta = me.getMeta();
			var points = meta.data;
</P><P>			// Update Points
			helpers.each(points, function(point, index) {
				me.updateElement(point, index, reset);
			});
		},
</P><P>		updateElement: function(point, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var xScale = me.getScaleForId(meta.xAxisID);
			var yScale = me.getScaleForId(meta.yAxisID);
</P><P>			var custom = point.custom || {};
			var dataset = me.getDataset();
			var data = dataset.data[index];
			var pointElementOptions = me.chart.options.elements.point;
			var dsIndex = me.index;
</P><P>			helpers.extend(point, {
				// Utility
				_xScale: xScale,
				_yScale: yScale,
				_datasetIndex: dsIndex,
				_index: index,
</P><P>				// Desired view properties
				_model: {
					x: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(data, index, dsIndex, me.chart.isCombo),
					y: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),
					// Appearance
					radius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),
</P><P>					// Tooltip
					hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)
				}
			});
</P><P>			// Trick to reset the styles of the point
			Chart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);
</P><P>			var model = point._model;
			model.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));
</P><P>			point.pivot();
		},
</P><P>		getRadius: function(value) {
			return value.r || this.chart.options.elements.point.radius;
		},
</P><P>		setHoverStyle: function(point) {
			var me = this;
			Chart.DatasetController.prototype.setHoverStyle.call(me, point);
</P><P>			// Radius
			var dataset = me.chart.data.datasets[point._datasetIndex];
			var index = point._index;
			var custom = point.custom || {};
			var model = point._model;
			model.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);
		},
</P><P>		removeHoverStyle: function(point) {
			var me = this;
			Chart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);
</P><P>			var dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];
			var custom = point.custom || {};
			var model = point._model;
</P><P>			model.radius = custom.radius ? custom.radius : me.getRadius(dataVal);
		}
	});
};
</P><P>},{}],17:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers,
		defaults = Chart.defaults;
</P><P>	defaults.doughnut = {
		animation: {
			//Boolean - Whether we animate the rotation of the Doughnut
			animateRotate: true,
			//Boolean - Whether we animate scaling the Doughnut from the centre
			animateScale: false
		},
		aspectRatio: 1,
		hover: {
			mode: 'single'
		},
		legendCallback: function(chart) {
			var text = [];
</P>
			text.push('<UL class="' + chart.id + '-legend">');

			var data = chart.data;
			var datasets = data.datasets;
			var labels = data.labels;

			if (datasets.length) {
				for (var i = 0; i &lt; datasets[0].data.length; ++i) {
					text.push('<LI>');
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push('</LI>');
<P>				}
			}
</P>
			text.push('</UL>');
<P>			return text.join(&quot;&quot;);
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data = chart.data;
					if (data.labels.length &amp;&amp; data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta = chart.getDatasetMeta(0);
							var ds = data.datasets[0];
							var arc = meta.data[i];
							var custom = arc.custom || {};
							var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
							var arcOpts = chart.options.elements.arc;
							var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
</P><P>							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
</P><P>								// Extra data used for toggling the correct item
								index: i
							};
						});
					} else {
						return [];
					}
				}
			},
</P><P>			onClick: function(e, legendItem) {
				var index = legendItem.index;
				var chart = this.chart;
				var i, ilen, meta;
</P><P>				for (i = 0, ilen = (chart.data.datasets || []).length; i &lt; ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					meta.data[index].hidden = !meta.data[index].hidden;
				}
</P><P>				chart.update();
			}
		},
</P><P>		//The percentage of the chart that we cut out of the middle.
		cutoutPercentage: 50,
</P><P>		//The rotation of the chart, where the first data arc begins.
		rotation: Math.PI * -0.5,
</P><P>		//The total circumference of the chart.
		circumference: Math.PI * 2.0,
</P><P>		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return <I>;</I>
				},
				label: function(tooltipItem, data) {
					return data.labels[tooltipItem.index] + ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
				}
			}
		}
	};
</P><P>	defaults.pie = helpers.clone(defaults.doughnut);
	helpers.extend(defaults.pie, {
		cutoutPercentage: 0
	});
</P><P>
	Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
</P><P>		dataElementType: Chart.elements.Arc,
</P><P>		linkScales: helpers.noop,
</P><P>		// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
		getRingIndex: function getRingIndex(datasetIndex) {
			var ringIndex = 0;
</P><P>			for (var j = 0; j &lt; datasetIndex; ++j) {
				if (this.chart.isDatasetVisible(j)) {
					++ringIndex;
				}
			}
</P><P>			return ringIndex;
		},
</P><P>		update: function update(reset) {
			var me = this;
			var chart = me.chart,
				chartArea = chart.chartArea,
				opts = chart.options,
				arcOpts = opts.elements.arc,
				availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,
				availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,
				minSize = Math.min(availableWidth, availableHeight),
				offset = {
					x: 0,
					y: 0
				},
				meta = me.getMeta(),
				cutoutPercentage = opts.cutoutPercentage,
				circumference = opts.circumference;
</P><P>			// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
			if (circumference &lt; Math.PI * 2.0) {
				var startAngle = opts.rotation % (Math.PI * 2.0);
				startAngle += Math.PI * 2.0 * (startAngle &gt;= Math.PI ? -1 : startAngle &lt; -Math.PI ? 1 : 0);
				var endAngle = startAngle + circumference;
				var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
				var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
				var contains0 = (startAngle &lt;= 0 &amp;&amp; 0 &lt;= endAngle) || (startAngle &lt;= Math.PI * 2.0 &amp;&amp; Math.PI * 2.0 &lt;= endAngle);
				var contains90 = (startAngle &lt;= Math.PI * 0.5 &amp;&amp; Math.PI * 0.5 &lt;= endAngle) || (startAngle &lt;= Math.PI * 2.5 &amp;&amp; Math.PI * 2.5 &lt;= endAngle);
				var contains180 = (startAngle &lt;= -Math.PI &amp;&amp; -Math.PI &lt;= endAngle) || (startAngle &lt;= Math.PI &amp;&amp; Math.PI &lt;= endAngle);
				var contains270 = (startAngle &lt;= -Math.PI * 0.5 &amp;&amp; -Math.PI * 0.5 &lt;= endAngle) || (startAngle &lt;= Math.PI * 1.5 &amp;&amp; Math.PI * 1.5 &lt;= endAngle);
				var cutout = cutoutPercentage / 100.0;
				var min = {x: contains180 ? -1 : Math.min(start.x * (start.x &lt; 0 ? 1 : cutout), end.x * (end.x &lt; 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y &lt; 0 ? 1 : cutout), end.y * (end.y &lt; 0 ? 1 : cutout))};
				var max = {x: contains0 ? 1 : Math.max(start.x * (start.x &gt; 0 ? 1 : cutout), end.x * (end.x &gt; 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y &gt; 0 ? 1 : cutout), end.y * (end.y &gt; 0 ? 1 : cutout))};
				var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
				minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
				offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
			}
</P><P>			chart.outerRadius = Math.max(minSize / 2, 0);
			chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 1, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
			chart.offsetX = offset.x * chart.outerRadius;
			chart.offsetY = offset.y * chart.outerRadius;
</P><P>			meta.total = me.calculateTotal();
</P><P>			me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
			me.innerRadius = me.outerRadius - chart.radiusLength;
</P><P>			helpers.each(meta.data, function(arc, index) {
				me.updateElement(arc, index, reset);
			});
		},
</P><P>		updateElement: function(arc, index, reset) {
			var me = this;
			var chart = me.chart,
				chartArea = chart.chartArea,
				opts = chart.options,
				animationOpts = opts.animation,
				arcOpts = opts.elements.arc,
				centerX = (chartArea.left + chartArea.right) / 2,
				centerY = (chartArea.top + chartArea.bottom) / 2,
				startAngle = opts.rotation, // non reset case handled later
				endAngle = opts.rotation, // non reset case handled later
				dataset = me.getDataset(),
				circumference = reset &amp;&amp; animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
				innerRadius = reset &amp;&amp; animationOpts.animateScale ? 0 : me.innerRadius,
				outerRadius = reset &amp;&amp; animationOpts.animateScale ? 0 : me.outerRadius,
				custom = arc.custom || {},
				valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
</P><P>			helpers.extend(arc, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
</P><P>				// Desired view properties
				_model: {
					x: centerX + chart.offsetX,
					y: centerY + chart.offsetY,
					startAngle: startAngle,
					endAngle: endAngle,
					circumference: circumference,
					outerRadius: outerRadius,
					innerRadius: innerRadius,
					label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
				}
			});
</P><P>			var model = arc._model;
			// Resets the visual styles
			this.removeHoverStyle(arc);
</P><P>			// Set correct angles if not resetting
			if (!reset || !animationOpts.animateRotate) {
				if (index === 0) {
					model.startAngle = opts.rotation;
				} else {
					model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
				}
</P><P>				model.endAngle = model.startAngle + model.circumference;
			}
</P><P>			arc.pivot();
		},
</P><P>		removeHoverStyle: function(arc) {
			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
		},
</P><P>		calculateTotal: function() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			var total = 0;
			var value;
</P><P>			helpers.each(meta.data, function(element, index) {
				value = dataset.data[index];
				if (!isNaN(value) &amp;&amp; !element.hidden) {
					total += Math.abs(value);
				}
			});
</P><P>			return total;
		},
</P><P>		calculateCircumference: function(value) {
			var total = this.getMeta().total;
			if (total &gt; 0 &amp;&amp; !isNaN(value)) {
				return (Math.PI * 2.0) * (value / total);
			} else {
				return 0;
			}
		}
	});
};
</P><P>},{}],18:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.defaults.line = {
		showLines: true,
</P><P>		hover: {
			mode: &quot;label&quot;
		},
</P><P>		scales: {
			xAxes: [{
				type: &quot;category&quot;,
				id: 'x-axis-0'
			}],
			yAxes: [{
				type: &quot;linear&quot;,
				id: 'y-axis-0'
			}]
		}
	};
</P><P>	function lineEnabled(dataset, options) {
		return helpers.getValueOrDefault(dataset.showLine, options.showLines);
	}
</P><P>	Chart.controllers.line = Chart.DatasetController.extend({
</P><P>		datasetElementType: Chart.elements.Line,
</P><P>		dataElementType: Chart.elements.Point,
</P><P>		addElementAndReset: function(index) {
			var me = this;
			var options = me.chart.options;
			var meta = me.getMeta();
</P><P>			Chart.DatasetController.prototype.addElementAndReset.call(me, index);
</P><P>			// Make sure bezier control points are updated
			if (lineEnabled(me.getDataset(), options) &amp;&amp; meta.dataset._model.tension !== 0) {
				me.updateBezierControlPoints();
			}
		},
</P><P>		update: function update(reset) {
			var me = this;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = meta.data || [];
			var options = me.chart.options;
			var lineElementOptions = options.elements.line;
			var scale = me.getScaleForId(meta.yAxisID);
			var i, ilen, custom;
			var dataset = me.getDataset();
			var showLine = lineEnabled(dataset, options);
</P><P>			// Update Line
			if (showLine) {
				custom = line.custom || {};
</P><P>				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.tension !== undefined) &amp;&amp; (dataset.lineTension === undefined)) {
					dataset.lineTension = dataset.tension;
				}
</P><P>				// Utility
				line._scale = scale;
				line._datasetIndex = me.index;
				// Data
				line._children = points;
				// Model
				line._model = {
					// Appearance
					// The default behavior of lines is to break at null values, according
					// to <A rel="nofollow" class="external free" href="https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158">https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158</A>
					// This option gives linse the ability to span gaps
					spanGaps: dataset.spanGaps ? dataset.spanGaps : false,
					tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
					// Scale
					scaleTop: scale.top,
					scaleBottom: scale.bottom,
					scaleZero: scale.getBasePixel()
				};
</P><P>				line.pivot();
			}
</P><P>			// Update Points
			for (i=0, ilen=points.length; i&lt;ilen; ++i) {
				me.updateElement(points[i], i, reset);
			}
</P><P>			if (showLine &amp;&amp; line._model.tension !== 0) {
				me.updateBezierControlPoints();
			}
</P><P>			// Now pivot the point for animation
			for (i=0, ilen=points.length; i&lt;ilen; ++i) {
				points[i].pivot();
			}
		},
</P><P>		getPointBackgroundColor: function(point, index) {
			var backgroundColor = this.chart.options.elements.point.backgroundColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};
</P><P>			if (custom.backgroundColor) {
				backgroundColor = custom.backgroundColor;
			} else if (dataset.pointBackgroundColor) {
				backgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
			} else if (dataset.backgroundColor) {
				backgroundColor = dataset.backgroundColor;
			}
</P><P>			return backgroundColor;
		},
</P><P>		getPointBorderColor: function(point, index) {
			var borderColor = this.chart.options.elements.point.borderColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};
</P><P>			if (custom.borderColor) {
				borderColor = custom.borderColor;
			} else if (dataset.pointBorderColor) {
				borderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
			} else if (dataset.borderColor) {
				borderColor = dataset.borderColor;
			}
</P><P>			return borderColor;
		},
</P><P>		getPointBorderWidth: function(point, index) {
			var borderWidth = this.chart.options.elements.point.borderWidth;
			var dataset = this.getDataset();
			var custom = point.custom || {};
</P><P>			if (custom.borderWidth) {
				borderWidth = custom.borderWidth;
			} else if (dataset.pointBorderWidth) {
				borderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
			} else if (dataset.borderWidth) {
				borderWidth = dataset.borderWidth;
			}
</P><P>			return borderWidth;
		},
</P><P>		updateElement: function(point, index, reset) {
			var me = this;
			var meta = me.getMeta();
			var custom = point.custom || {};
			var dataset = me.getDataset();
			var datasetIndex = me.index;
			var value = dataset.data[index];
			var yScale = me.getScaleForId(meta.yAxisID);
			var xScale = me.getScaleForId(meta.xAxisID);
			var pointOptions = me.chart.options.elements.point;
			var x, y;
</P><P>			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.radius !== undefined) &amp;&amp; (dataset.pointRadius === undefined)) {
				dataset.pointRadius = dataset.radius;
			}
			if ((dataset.hitRadius !== undefined) &amp;&amp; (dataset.pointHitRadius === undefined)) {
				dataset.pointHitRadius = dataset.hitRadius;
			}
</P><P>			x = xScale.getPixelForValue(value, index, datasetIndex, me.chart.isCombo);
			y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex, me.chart.isCombo);
</P><P>			// Utility
			point._xScale = xScale;
			point._yScale = yScale;
			point._datasetIndex = datasetIndex;
			point._index = index;
</P><P>			// Desired view properties
			point._model = {
				x: x,
				y: y,
				skip: custom.skip || isNaN(x) || isNaN(y),
				// Appearance
				radius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
				pointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
				backgroundColor: me.getPointBackgroundColor(point, index),
				borderColor: me.getPointBorderColor(point, index),
				borderWidth: me.getPointBorderWidth(point, index),
				tension: meta.dataset._model ? meta.dataset._model.tension : 0,
				// Tooltip
				hitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
			};
		},
</P><P>		calculatePointY: function(value, index, datasetIndex, isCombo) {
			var me = this;
			var chart = me.chart;
			var meta = me.getMeta();
			var yScale = me.getScaleForId(meta.yAxisID);
			var sumPos = 0;
			var sumNeg = 0;
			var i, ds, dsMeta;
</P><P>			if (yScale.options.stacked) {
				for (i = 0; i &lt; datasetIndex; i++) {
					ds = chart.data.datasets[i];
					dsMeta = chart.getDatasetMeta(i);
					if (dsMeta.type === 'line' &amp;&amp; chart.isDatasetVisible(i)) {
						if (ds.data[index] &lt; 0) {
							sumNeg += ds.data[index] || 0;
						} else {
							sumPos += ds.data[index] || 0;
						}
					}
				}
</P><P>				if (value &lt; 0) {
					return yScale.getPixelForValue(sumNeg + value);
				} else {
					return yScale.getPixelForValue(sumPos + value);
				}
			}
</P><P>			return yScale.getPixelForValue(value);
		},
</P><P>		updateBezierControlPoints: function() {
			var meta = this.getMeta();
			var area = this.chart.chartArea;
			var points = meta.data || [];
			var i, ilen, point, model, controlPoints;
</P><P>			for (i=0, ilen=points.length; i&lt;ilen; ++i) {
				point = points[i];
				model = point._model;
				controlPoints = helpers.splineCurve(
					helpers.previousItem(points, i)._model,
					model,
					helpers.nextItem(points, i)._model,
					meta.dataset._model.tension
				);
</P><P>				model.controlPointPreviousX = controlPoints.previous.x;
				model.controlPointPreviousY = controlPoints.previous.y;
				model.controlPointNextX = controlPoints.next.x;
				model.controlPointNextY = controlPoints.next.y;
			}
		},
</P><P>		draw: function(ease) {
			var me = this;
			var meta = me.getMeta();
			var points = meta.data || [];
			var easingDecimal = ease || 1;
			var i, ilen;
</P><P>	// Transition Point Locations
			for (i=0, ilen=points.length; i&lt;ilen; ++i) {
				points[i].transition(easingDecimal);
			}
</P><P>			// Transition and Draw the line
			if (lineEnabled(me.getDataset(), me.chart.options)) {
				meta.dataset.transition(easingDecimal).draw();
			}
</P><P>			// Draw the points
			for (i=0, ilen=points.length; i&lt;ilen; ++i) {
				points[i].draw();
			}
		},
</P><P>		setHoverStyle: function(point) {
			// Point
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var index = point._index;
			var custom = point.custom || {};
			var model = point._model;
</P><P>			model.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
			model.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
		},
</P><P>		removeHoverStyle: function(point) {
			var me = this;
			var dataset = me.chart.data.datasets[point._datasetIndex];
			var index = point._index;
			var custom = point.custom || {};
			var model = point._model;
</P><P>			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.radius !== undefined) &amp;&amp; (dataset.pointRadius === undefined)) {
				dataset.pointRadius = dataset.radius;
			}
</P><P>			model.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
			model.backgroundColor = me.getPointBackgroundColor(point, index);
			model.borderColor = me.getPointBorderColor(point, index);
			model.borderWidth = me.getPointBorderWidth(point, index);
		}
	});
};
</P><P>},{}],19:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.defaults.polarArea = {
</P><P>		scale: {
			type: &quot;radialLinear&quot;,
			lineArc: true // so that lines are circular
		},
</P><P>		//Boolean - Whether to animate the rotation of the chart
		animation: {
			animateRotate: true,
			animateScale: true
		},
</P><P>		aspectRatio: 1,
		legendCallback: function(chart) {
			var text = [];
</P>
			text.push('<UL class="' + chart.id + '-legend">');

			var data = chart.data;
			var datasets = data.datasets;
			var labels = data.labels;

			if (datasets.length) {
				for (var i = 0; i &lt; datasets[0].data.length; ++i) {
					text.push('<LI><SPAN style="background-color:' + datasets[0].backgroundColor[i] + '">');
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push('</SPAN></LI>');
<P>				}
			}
</P>
			text.push('</UL>');
<P>			return text.join(&quot;&quot;);
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data = chart.data;
					if (data.labels.length &amp;&amp; data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta = chart.getDatasetMeta(0);
							var ds = data.datasets[0];
							var arc = meta.data[i];
							var custom = arc.custom || {};
							var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
							var arcOpts = chart.options.elements.arc;
							var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
</P><P>							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
</P><P>								// Extra data used for toggling the correct item
								index: i
							};
						});
					} else {
						return [];
					}
				}
			},
</P><P>			onClick: function(e, legendItem) {
				var index = legendItem.index;
				var chart = this.chart;
				var i, ilen, meta;
</P><P>				for (i = 0, ilen = (chart.data.datasets || []).length; i &lt; ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					meta.data[index].hidden = !meta.data[index].hidden;
				}
</P><P>				chart.update();
			}
		},
</P><P>		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return <I>;</I>
				},
				label: function(tooltipItem, data) {
					return data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;
				}
			}
		}
	};
</P><P>	Chart.controllers.polarArea = Chart.DatasetController.extend({
</P><P>		dataElementType: Chart.elements.Arc,
</P><P>		linkScales: helpers.noop,
</P><P>		update: function update(reset) {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var meta = me.getMeta();
			var opts = chart.options;
			var arcOpts = opts.elements.arc;
			var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
			chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
			chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
</P><P>			me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
			me.innerRadius = me.outerRadius - chart.radiusLength;
</P><P>			meta.count = me.countVisibleElements();
</P><P>			helpers.each(meta.data, function(arc, index) {
				me.updateElement(arc, index, reset);
			});
		},
</P><P>		updateElement: function(arc, index, reset) {
			var me = this;
			var chart = me.chart;
			var chartArea = chart.chartArea;
			var dataset = me.getDataset();
			var opts = chart.options;
			var animationOpts = opts.animation;
			var arcOpts = opts.elements.arc;
			var custom = arc.custom || {};
			var scale = chart.scale;
			var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
			var labels = chart.data.labels;
</P><P>			var circumference = me.calculateCircumference(dataset.data[index]);
			var centerX = (chartArea.left + chartArea.right) / 2;
			var centerY = (chartArea.top + chartArea.bottom) / 2;
</P><P>			// If there is NaN data before us, we need to calculate the starting angle correctly.
			// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
			var visibleCount = 0;
			var meta = me.getMeta();
			for (var i = 0; i &lt; index; ++i) {
				if (!isNaN(dataset.data[i]) &amp;&amp; !meta.data[i].hidden) {
					++visibleCount;
				}
			}
</P><P>			var negHalfPI = -0.5 * Math.PI;
			var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
			var startAngle = (negHalfPI) + (circumference * visibleCount);
			var endAngle = startAngle + (arc.hidden ? 0 : circumference);
</P><P>			var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
</P><P>			helpers.extend(arc, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
				_scale: scale,
</P><P>				// Desired view properties
				_model: {
					x: centerX,
					y: centerY,
					innerRadius: 0,
					outerRadius: reset ? resetRadius : distance,
					startAngle: reset &amp;&amp; animationOpts.animateRotate ? negHalfPI : startAngle,
					endAngle: reset &amp;&amp; animationOpts.animateRotate ? negHalfPI : endAngle,
					label: getValueAtIndexOrDefault(labels, index, labels[index])
				}
			});
</P><P>			// Apply border and fill style
			me.removeHoverStyle(arc);
</P><P>			arc.pivot();
		},
</P><P>		removeHoverStyle: function(arc) {
			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
		},
</P><P>		countVisibleElements: function() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			var count = 0;
</P><P>			helpers.each(meta.data, function(element, index) {
				if (!isNaN(dataset.data[index]) &amp;&amp; !element.hidden) {
					count++;
				}
			});
</P><P>			return count;
		},
</P><P>		calculateCircumference: function(value) {
			var count = this.getMeta().count;
			if (count &gt; 0 &amp;&amp; !isNaN(value)) {
				return (2 * Math.PI) / count;
			} else {
				return 0;
			}
		}
	});
};
</P><P>},{}],20:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.defaults.radar = {
		scale: {
			type: &quot;radialLinear&quot;
		},
		elements: {
			line: {
				tension: 0 // no bezier in radar
			}
		}
	};
</P><P>	Chart.controllers.radar = Chart.DatasetController.extend({
</P><P>		datasetElementType: Chart.elements.Line,
</P><P>		dataElementType: Chart.elements.Point,
</P><P>		linkScales: helpers.noop,
</P><P>		addElementAndReset: function(index) {
			Chart.DatasetController.prototype.addElementAndReset.call(this, index);
</P><P>			// Make sure bezier control points are updated
			this.updateBezierControlPoints();
		},
</P><P>		update: function update(reset) {
			var me = this;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = meta.data;
			var custom = line.custom || {};
			var dataset = me.getDataset();
			var lineElementOptions = me.chart.options.elements.line;
			var scale = me.chart.scale;
</P><P>			// Compatibility: If the properties are defined with only the old name, use those values
			if ((dataset.tension !== undefined) &amp;&amp; (dataset.lineTension === undefined)) {
				dataset.lineTension = dataset.tension;
			}
</P><P>			helpers.extend(meta.dataset, {
				// Utility
				_datasetIndex: me.index,
				// Data
				_children: points,
				_loop: true,
				// Model
				_model: {
					// Appearance
					tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
</P><P>					// Scale
					scaleTop: scale.top,
					scaleBottom: scale.bottom,
					scaleZero: scale.getBasePosition()
				}
			});
</P><P>			meta.dataset.pivot();
</P><P>			// Update Points
			helpers.each(points, function(point, index) {
				me.updateElement(point, index, reset);
			}, me);
</P><P>
			// Update bezier control points
			me.updateBezierControlPoints();
		},
		updateElement: function(point, index, reset) {
			var me = this;
			var custom = point.custom || {};
			var dataset = me.getDataset();
			var scale = me.chart.scale;
			var pointElementOptions = me.chart.options.elements.point;
			var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
</P><P>			helpers.extend(point, {
				// Utility
				_datasetIndex: me.index,
				_index: index,
				_scale: scale,
</P><P>				// Desired view properties
				_model: {
					x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
					y: reset ? scale.yCenter : pointPosition.y,
</P><P>					// Appearance
					tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.tension, me.chart.options.elements.line.tension),
					radius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
					borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
					pointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
</P><P>					// Tooltip
					hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)
				}
			});
</P><P>			point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
		},
		updateBezierControlPoints: function() {
			var chartArea = this.chart.chartArea;
			var meta = this.getMeta();
</P><P>			helpers.each(meta.data, function(point, index) {
				var model = point._model;
				var controlPoints = helpers.splineCurve(
					helpers.previousItem(meta.data, index, true)._model,
					model,
					helpers.nextItem(meta.data, index, true)._model,
					model.tension
				);
</P><P>				// Prevent the bezier going outside of the bounds of the graph
				model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
				model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
</P><P>				model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
				model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);
</P><P>				// Now pivot the point for animation
				point.pivot();
			});
		},
</P><P>		draw: function(ease) {
			var meta = this.getMeta();
			var easingDecimal = ease || 1;
</P><P>			// Transition Point Locations
			helpers.each(meta.data, function(point, index) {
				point.transition(easingDecimal);
			});
</P><P>			// Transition and Draw the line
			meta.dataset.transition(easingDecimal).draw();
</P><P>			// Draw the points
			helpers.each(meta.data, function(point) {
				point.draw();
			});
		},
</P><P>		setHoverStyle: function(point) {
			// Point
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var custom = point.custom || {};
			var index = point._index;
			var model = point._model;
</P><P>			model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
		},
</P><P>		removeHoverStyle: function(point) {
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var custom = point.custom || {};
			var index = point._index;
			var model = point._model;
			var pointElementOptions = this.chart.options.elements.point;
</P><P>			model.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);
			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
		}
	});
};
</P><P>},{}],21:[function(require,module,exports){
/*global window: false */
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.defaults.global.animation = {
		duration: 1000,
		easing: &quot;easeOutQuart&quot;,
		onProgress: helpers.noop,
		onComplete: helpers.noop
	};
</P><P>	Chart.Animation = Chart.Element.extend({
		currentStep: null, // the current animation step
		numSteps: 60, // default number of steps
		easing: &quot;&quot;, // the easing to use for this animation
		render: null, // render function used by the animation service
</P><P>		onAnimationProgress: null, // user specified callback to fire on each step of the animation
		onAnimationComplete: null // user specified callback to fire when the animation finishes
	});
</P><P>	Chart.animationService = {
		frameDuration: 17,
		animations: [],
		dropFrames: 0,
		request: null,
		addAnimation: function(chartInstance, animationObject, duration, lazy) {
			var me = this;
</P><P>			if (!lazy) {
				chartInstance.animating = true;
			}
</P><P>			for (var index = 0; index &lt; me.animations.length; ++index) {
				if (me.animations[index].chartInstance === chartInstance) {
					// replacing an in progress animation
					me.animations[index].animationObject = animationObject;
					return;
				}
			}
</P><P>			me.animations.push({
				chartInstance: chartInstance,
				animationObject: animationObject
			});
</P><P>			// If there are no animations queued, manually kickstart a digest, for lack of a better word
			if (me.animations.length === 1) {
				me.requestAnimationFrame();
			}
		},
		// Cancel the animation for a given chart instance
		cancelAnimation: function(chartInstance) {
			var index = helpers.findIndex(this.animations, function(animationWrapper) {
				return animationWrapper.chartInstance === chartInstance;
			});
</P><P>			if (index !== -1) {
				this.animations.splice(index, 1);
				chartInstance.animating = false;
			}
		},
		requestAnimationFrame: function() {
			var me = this;
			if (me.request === null) {
				// Skip animation frame requests until the active one is executed.
				// This can happen when processing mouse events, e.g. 'mousemove'
				// and 'mouseout' events will trigger multiple renders.
				me.request = helpers.requestAnimFrame.call(window, function() {
					me.request = null;
					me.startDigest();
				});
			}
		},
		startDigest: function() {
			var me = this;
</P><P>			var startTime = Date.now();
			var framesToDrop = 0;
</P><P>			if (me.dropFrames &gt; 1) {
				framesToDrop = Math.floor(me.dropFrames);
				me.dropFrames = me.dropFrames % 1;
			}
</P><P>			var i = 0;
			while (i &lt; me.animations.length) {
				if (me.animations[i].animationObject.currentStep === null) {
					me.animations[i].animationObject.currentStep = 0;
				}
</P><P>				me.animations[i].animationObject.currentStep += 1 + framesToDrop;
</P><P>				if (me.animations[i].animationObject.currentStep &gt; me.animations[i].animationObject.numSteps) {
					me.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;
				}
</P><P>				me.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);
				if (me.animations[i].animationObject.onAnimationProgress &amp;&amp; me.animations[i].animationObject.onAnimationProgress.call) {
					me.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);
				}
</P><P>				if (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {
					if (me.animations[i].animationObject.onAnimationComplete &amp;&amp; me.animations[i].animationObject.onAnimationComplete.call) {
						me.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);
					}
</P><P>					// executed the last frame. Remove the animation.
					me.animations[i].chartInstance.animating = false;
</P><P>					me.animations.splice(i, 1);
				} else {
					++i;
				}
			}
</P><P>			var endTime = Date.now();
			var dropFrames = (endTime - startTime) / me.frameDuration;
</P><P>			me.dropFrames += dropFrames;
</P><P>			// Do we have more stuff to animate?
			if (me.animations.length &gt; 0) {
				me.requestAnimationFrame();
			}
		}
	};
};
},{}],22:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
	//Create a dictionary of chart types, to allow for extension of existing types
	Chart.types = {};
</P><P>	//Store a reference to each instance - allowing us to globally resize chart instances on window resize.
	//Destroy method on the chart will remove the instance of the chart from this reference.
	Chart.instances = {};
</P><P>	// Controllers available for dataset visualization eg. bar, line, slice, etc.
	Chart.controllers = {};
</P><P>	/**
	 * @class Chart.Controller
	 * The main controller of a chart.
	 */
	Chart.Controller = function(instance) {
</P><P>		this.chart = instance;
		this.config = instance.config;
		this.options = this.config.options = helpers.configMerge(Chart.defaults.global, Chart.defaults[this.config.type], this.config.options || {});
		this.id = helpers.uid();
</P><P>		Object.defineProperty(this, 'data', {
			get: function() {
				return this.config.data;
			}
		});
</P><P>		//Add the chart instance to the global namespace
		Chart.instances[this.id] = this;
</P><P>		if (this.options.responsive) {
			// Silent resize before chart draws
			this.resize(true);
		}
</P><P>		this.initialize();
</P><P>		return this;
	};
</P><P>	helpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller */ {
</P><P>		initialize: function initialize() {
			var me = this;
			// Before init plugin notification
			Chart.plugins.notify('beforeInit', [me]);
</P><P>			me.bindEvents();
</P><P>			// Make sure controllers are built first so that each dataset is bound to an axis before the scales
			// are built
			me.ensureScalesHaveIDs();
			me.buildOrUpdateControllers();
			me.buildScales();
			me.updateLayout();
			me.resetElements();
			me.initToolTip();
			me.update();
</P><P>			// After init plugin notification
			Chart.plugins.notify('afterInit', [me]);
</P><P>			return me;
		},
</P><P>		clear: function clear() {
			helpers.clear(this.chart);
			return this;
		},
</P><P>		stop: function stop() {
			// Stops any current animation loop occuring
			Chart.animationService.cancelAnimation(this);
			return this;
		},
</P><P>		resize: function resize(silent) {
			var me = this;
			var chart = me.chart;
			var canvas = chart.canvas;
			var newWidth = helpers.getMaximumWidth(canvas);
			var aspectRatio = chart.aspectRatio;
			var newHeight = (me.options.maintainAspectRatio &amp;&amp; isNaN(aspectRatio) === false &amp;&amp; isFinite(aspectRatio) &amp;&amp; aspectRatio !== 0) ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas);
</P><P>			var sizeChanged = chart.width !== newWidth || chart.height !== newHeight;
</P><P>			if (!sizeChanged) {
				return me;
			}
</P><P>			canvas.width = chart.width = newWidth;
			canvas.height = chart.height = newHeight;
</P><P>			helpers.retinaScale(chart);
</P><P>			// Notify any plugins about the resize
			var newSize = { width: newWidth, height: newHeight };
			Chart.plugins.notify('resize', [me, newSize]);
</P><P>			// Notify of resize
			if (me.options.onResize) {
				me.options.onResize(me, newSize);
			}
</P><P>			if (!silent) {
				me.stop();
				me.update(me.options.responsiveAnimationDuration);
			}
</P><P>			return me;
		},
</P><P>		ensureScalesHaveIDs: function ensureScalesHaveIDs() {
			var options = this.options;
			var scalesOptions = options.scales || {};
			var scaleOptions = options.scale;
</P><P>			helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
				xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
			});
</P><P>			helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
				yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
			});
</P><P>			if (scaleOptions) {
				scaleOptions.id = scaleOptions.id || 'scale';
			}
		},
</P><P>		/**
		 * Builds a map of scale ID to scale object for future lookup.
		 */
		buildScales: function buildScales() {
			var me = this;
			var options = me.options;
			var scales = me.scales = {};
			var items = [];
</P><P>			if (options.scales) {
				items = items.concat(
					(options.scales.xAxes || []).map(function(xAxisOptions) {
						return { options: xAxisOptions, dtype: 'category' }; }),
					(options.scales.yAxes || []).map(function(yAxisOptions) {
						return { options: yAxisOptions, dtype: 'linear' }; }));
			}
</P><P>			if (options.scale) {
				items.push({ options: options.scale, dtype: 'radialLinear', isDefault: true });
			}
</P><P>			helpers.each(items, function(item, index) {
				var scaleOptions = item.options;
				var scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);
				var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
				if (!scaleClass) {
					return;
				}
</P><P>				var scale = new scaleClass({
					id: scaleOptions.id,
					options: scaleOptions,
					ctx: me.chart.ctx,
					chart: me
				});
</P><P>				scales[scale.id] = scale;
</P><P>				// TODO(SB): I think we should be able to remove this custom case (options.scale)
				// and consider it as a regular scale part of the &quot;scales&quot;&quot; map only! This would
				// make the logic easier and remove some useless? custom code.
				if (item.isDefault) {
					me.scale = scale;
				}
			});
</P><P>			Chart.scaleService.addScalesToLayout(this);
		},
</P><P>		updateLayout: function() {
			Chart.layoutService.update(this, this.chart.width, this.chart.height);
		},
</P><P>		buildOrUpdateControllers: function buildOrUpdateControllers() {
			var me = this;
			var types = [];
			var newControllers = [];
</P><P>			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				var meta = me.getDatasetMeta(datasetIndex);
				if (!meta.type) {
					meta.type = dataset.type || me.config.type;
				}
</P><P>				types.push(meta.type);
</P><P>				if (meta.controller) {
					meta.controller.updateIndex(datasetIndex);
				} else {
					meta.controller = new Chart.controllers[meta.type](me, datasetIndex);
					newControllers.push(meta.controller);
				}
			}, me);
</P><P>			if (types.length &gt; 1) {
				for (var i = 1; i &lt; types.length; i++) {
					if (types[i] !== types[i - 1]) {
						me.isCombo = true;
						break;
					}
				}
			}
</P><P>			return newControllers;
		},
</P><P>		resetElements: function resetElements() {
			var me = this;
			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				me.getDatasetMeta(datasetIndex).controller.reset();
			}, me);
		},
</P><P>		update: function update(animationDuration, lazy) {
			var me = this;
			Chart.plugins.notify('beforeUpdate', [me]);
</P><P>			// In case the entire data object changed
			me.tooltip._data = me.data;
</P><P>			// Make sure dataset controllers are updated and new controllers are reset
			var newControllers = me.buildOrUpdateControllers();
</P><P>			// Make sure all dataset controllers have correct meta data counts
			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
			}, me);
</P><P>			Chart.layoutService.update(me, me.chart.width, me.chart.height);
</P><P>			// Apply changes to the dataets that require the scales to have been calculated i.e BorderColor chages
			Chart.plugins.notify('afterScaleUpdate', [me]);
</P><P>			// Can only reset the new controllers after the scales have been updated
			helpers.each(newControllers, function(controller) {
				controller.reset();
			});
</P><P>			me.updateDatasets();
</P><P>			// Do this before render so that any plugins that need final scale updates can use it
			Chart.plugins.notify('afterUpdate', [me]);
</P><P>			me.render(animationDuration, lazy);
		},
</P><P>		/**
		 * @method beforeDatasetsUpdate
		 * @description Called before all datasets are updated. If a plugin returns false,
		 * the datasets update will be cancelled until another chart update is triggered.
		 * @param {Object} instance the chart instance being updated.
		 * @returns {Boolean} false to cancel the datasets update.
		 * @memberof Chart.PluginBase
		 * @since version 2.1.5
		 * @instance
		 */
</P><P>		/**
		 * @method afterDatasetsUpdate
		 * @description Called after all datasets have been updated. Note that this
		 * extension will not be called if the datasets update has been cancelled.
		 * @param {Object} instance the chart instance being updated.
		 * @memberof Chart.PluginBase
		 * @since version 2.1.5
		 * @instance
		 */
</P><P>		/**
		 * Updates all datasets unless a plugin returns false to the beforeDatasetsUpdate
		 * extension, in which case no datasets will be updated and the afterDatasetsUpdate
		 * notification will be skipped.
		 * @protected
		 * @instance
		 */
		updateDatasets: function() {
			var me = this;
			var i, ilen;
</P><P>			if (Chart.plugins.notify('beforeDatasetsUpdate', [ me ])) {
				for (i = 0, ilen = me.data.datasets.length; i &lt; ilen; ++i) {
					me.getDatasetMeta(i).controller.update();
				}
</P><P>				Chart.plugins.notify('afterDatasetsUpdate', [ me ]);
			}
		},
</P><P>		render: function render(duration, lazy) {
			var me = this;
			Chart.plugins.notify('beforeRender', [me]);
</P><P>			var animationOptions = me.options.animation;
			if (animationOptions &amp;&amp; ((typeof duration !== 'undefined' &amp;&amp; duration !== 0) || (typeof duration === 'undefined' &amp;&amp; animationOptions.duration !== 0))) {
				var animation = new Chart.Animation();
				animation.numSteps = (duration || animationOptions.duration) / 16.66; //60 fps
				animation.easing = animationOptions.easing;
</P><P>				// render function
				animation.render = function(chartInstance, animationObject) {
					var easingFunction = helpers.easingEffects[animationObject.easing];
					var stepDecimal = animationObject.currentStep / animationObject.numSteps;
					var easeDecimal = easingFunction(stepDecimal);
</P><P>					chartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);
				};
</P><P>				// user events
				animation.onAnimationProgress = animationOptions.onProgress;
				animation.onAnimationComplete = animationOptions.onComplete;
</P><P>				Chart.animationService.addAnimation(me, animation, duration, lazy);
			} else {
				me.draw();
				if (animationOptions &amp;&amp; animationOptions.onComplete &amp;&amp; animationOptions.onComplete.call) {
					animationOptions.onComplete.call(me);
				}
			}
			return me;
		},
</P><P>		draw: function(ease) {
			var me = this;
			var easingDecimal = ease || 1;
			me.clear();
</P><P>			Chart.plugins.notify('beforeDraw', [me, easingDecimal]);
</P><P>			// Draw all the scales
			helpers.each(me.boxes, function(box) {
				box.draw(me.chartArea);
			}, me);
			if (me.scale) {
				me.scale.draw();
			}
</P><P>			Chart.plugins.notify('beforeDatasetsDraw', [me, easingDecimal]);
</P><P>			// Draw each dataset via its respective controller (reversed to support proper line stacking)
			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				if (me.isDatasetVisible(datasetIndex)) {
					me.getDatasetMeta(datasetIndex).controller.draw(ease);
				}
			}, me, true);
</P><P>			Chart.plugins.notify('afterDatasetsDraw', [me, easingDecimal]);
</P><P>			// Finally draw the tooltip
			me.tooltip.transition(easingDecimal).draw();
</P><P>			Chart.plugins.notify('afterDraw', [me, easingDecimal]);
		},
</P><P>		// Get the single element that was clicked on
		// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
		getElementAtEvent: function(e) {
			var me = this;
			var eventPosition = helpers.getRelativePosition(e, me.chart);
			var elementsArray = [];
</P><P>			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				if (me.isDatasetVisible(datasetIndex)) {
					var meta = me.getDatasetMeta(datasetIndex);
					helpers.each(meta.data, function(element, index) {
						if (element.inRange(eventPosition.x, eventPosition.y)) {
							elementsArray.push(element);
							return elementsArray;
						}
					});
				}
			});
</P><P>			return elementsArray;
		},
</P><P>		getElementsAtEvent: function(e) {
			var me = this;
			var eventPosition = helpers.getRelativePosition(e, me.chart);
			var elementsArray = [];
</P><P>			var found = (function() {
				if (me.data.datasets) {
					for (var i = 0; i &lt; me.data.datasets.length; i++) {
						var meta = me.getDatasetMeta(i);
						if (me.isDatasetVisible(i)) {
							for (var j = 0; j &lt; meta.data.length; j++) {
								if (meta.data[j].inRange(eventPosition.x, eventPosition.y)) {
									return meta.data[j];
								}
							}
						}
					}
				}
			}).call(me);
</P><P>			if (!found) {
				return elementsArray;
			}
</P><P>			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				if (me.isDatasetVisible(datasetIndex)) {
					var meta = me.getDatasetMeta(datasetIndex);
					elementsArray.push(meta.data[found._index]);
				}
			}, me);
</P><P>			return elementsArray;
		},
</P><P>		getElementsAtEventForMode: function(e, mode) {
			var me = this;
			switch (mode) {
			case 'single':
				return me.getElementAtEvent(e);
			case 'label':
				return me.getElementsAtEvent(e);
			case 'dataset':
				return me.getDatasetAtEvent(e);
			default:
				return e;
			}
		},
</P><P>		getDatasetAtEvent: function(e) {
			var elementsArray = this.getElementAtEvent(e);
</P><P>			if (elementsArray.length &gt; 0) {
				elementsArray = this.getDatasetMeta(elementsArray[0]._datasetIndex).data;
			}
</P><P>			return elementsArray;
		},
</P><P>		getDatasetMeta: function(datasetIndex) {
			var me = this;
			var dataset = me.data.datasets[datasetIndex];
			if (!dataset._meta) {
				dataset._meta = {};
			}
</P><P>			var meta = dataset._meta[me.id];
			if (!meta) {
				meta = dataset._meta[me.id] = {
				type: null,
				data: [],
				dataset: null,
				controller: null,
				hidden: null,			// See isDatasetVisible() comment
				xAxisID: null,
				yAxisID: null
			};
			}
</P><P>			return meta;
		},
</P><P>		getVisibleDatasetCount: function() {
			var count = 0;
			for (var i = 0, ilen = this.data.datasets.length; i&lt;ilen; ++i) {
				 if (this.isDatasetVisible(i)) {
					count++;
				}
			}
			return count;
		},
</P><P>		isDatasetVisible: function(datasetIndex) {
			var meta = this.getDatasetMeta(datasetIndex);
</P><P>			// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
			// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
			return typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
		},
</P><P>		generateLegend: function generateLegend() {
			return this.options.legendCallback(this);
		},
</P><P>		destroy: function destroy() {
			var me = this;
			me.stop();
			me.clear();
			helpers.unbindEvents(me, me.events);
			helpers.removeResizeListener(me.chart.canvas.parentNode);
</P><P>			// Reset canvas height/width attributes
			var canvas = me.chart.canvas;
			canvas.width = me.chart.width;
			canvas.height = me.chart.height;
</P><P>			// if we scaled the canvas in response to a devicePixelRatio !== 1, we need to undo that transform here
			if (me.chart.originalDevicePixelRatio !== undefined) {
				me.chart.ctx.scale(1 / me.chart.originalDevicePixelRatio, 1 / me.chart.originalDevicePixelRatio);
			}
</P><P>			// Reset to the old style since it may have been changed by the device pixel ratio changes
			canvas.style.width = me.chart.originalCanvasStyleWidth;
			canvas.style.height = me.chart.originalCanvasStyleHeight;
</P><P>			Chart.plugins.notify('destroy', [me]);
</P><P>			delete Chart.instances[me.id];
		},
</P><P>		toBase64Image: function toBase64Image() {
			return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);
		},
</P><P>		initToolTip: function initToolTip() {
			var me = this;
			me.tooltip = new Chart.Tooltip({
				_chart: me.chart,
				_chartInstance: me,
				_data: me.data,
				_options: me.options.tooltips
			}, me);
		},
</P><P>		bindEvents: function bindEvents() {
			var me = this;
			helpers.bindEvents(me, me.options.events, function(evt) {
				me.eventHandler(evt);
			});
		},
</P><P>		updateHoverStyle: function(elements, mode, enabled) {
			var method = enabled? 'setHoverStyle' : 'removeHoverStyle';
			var element, i, ilen;
</P><P>			switch (mode) {
			case 'single':
				elements = [ elements[0] ];
				break;
			case 'label':
			case 'dataset':
				// elements = elements;
				break;
			default:
				// unsupported mode
				return;
			}
</P><P>			for (i=0, ilen=elements.length; i&lt;ilen; ++i) {
				element = elements[i];
				if (element) {
					this.getDatasetMeta(element._datasetIndex).controller[method](element);
				}
			}
		},
</P><P>		eventHandler: function eventHandler(e) {
			var me = this;
			var tooltip = me.tooltip;
			var options = me.options || {};
			var hoverOptions = options.hover;
			var tooltipsOptions = options.tooltips;
</P><P>			me.lastActive = me.lastActive || [];
			me.lastTooltipActive = me.lastTooltipActive || [];
</P><P>			// Find Active Elements for hover and tooltips
			if (e.type === 'mouseout') {
				me.active = [];
				me.tooltipActive = [];
			} else {
				me.active = me.getElementsAtEventForMode(e, hoverOptions.mode);
				me.tooltipActive =  me.getElementsAtEventForMode(e, tooltipsOptions.mode);
			}
</P><P>			// On Hover hook
			if (hoverOptions.onHover) {
				hoverOptions.onHover.call(me, me.active);
			}
</P><P>			if (e.type === 'mouseup' || e.type === 'click') {
				if (options.onClick) {
					options.onClick.call(me, e, me.active);
				}
				if (me.legend &amp;&amp; me.legend.handleEvent) {
					me.legend.handleEvent(e);
				}
			}
</P><P>			// Remove styling for last active (even if it may still be active)
			if (me.lastActive.length) {
				me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
			}
</P><P>			// Built in hover styling
			if (me.active.length &amp;&amp; hoverOptions.mode) {
				me.updateHoverStyle(me.active, hoverOptions.mode, true);
			}
</P><P>			// Built in Tooltips
			if (tooltipsOptions.enabled || tooltipsOptions.custom) {
				tooltip.initialize();
				tooltip._active = me.tooltipActive;
				tooltip.update(true);
			}
</P><P>			// Hover animations
			tooltip.pivot();
</P><P>			if (!me.animating) {
				// If entering, leaving, or changing elements, animate the change via pivot
				if (!helpers.arrayEquals(me.active, me.lastActive) ||
					!helpers.arrayEquals(me.tooltipActive, me.lastTooltipActive)) {
</P><P>					me.stop();
</P><P>					if (tooltipsOptions.enabled || tooltipsOptions.custom) {
						tooltip.update(true);
					}
</P><P>					// We only need to render at this point. Updating will cause scales to be
					// recomputed generating flicker &amp; using more memory than necessary.
					me.render(hoverOptions.animationDuration, true);
				}
			}
</P><P>			// Remember Last Actives
			me.lastActive = me.active;
			me.lastTooltipActive = me.tooltipActive;
			return me;
		}
	});
};
</P><P>},{}],23:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
	var noop = helpers.noop;
</P><P>	// Base class for all dataset controllers (line, bar, etc)
	Chart.DatasetController = function(chart, datasetIndex) {
		this.initialize.call(this, chart, datasetIndex);
	};
</P><P>	helpers.extend(Chart.DatasetController.prototype, {
</P><P>		/**
		 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
		 * @type {Chart.core.element}
		 */
		datasetElementType: null,
</P><P>		/**
		 * Element type used to generate a meta data (e.g. Chart.element.Point).
		 * @type {Chart.core.element}
		 */
		dataElementType: null,
</P><P>		initialize: function(chart, datasetIndex) {
			var me = this;
			me.chart = chart;
			me.index = datasetIndex;
			me.linkScales();
			me.addElements();
		},
</P><P>		updateIndex: function(datasetIndex) {
			this.index = datasetIndex;
		},
</P><P>		linkScales: function() {
			var me = this;
			var meta = me.getMeta();
			var dataset = me.getDataset();
</P><P>			if (meta.xAxisID === null) {
				meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
			}
			if (meta.yAxisID === null) {
				meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
			}
		},
</P><P>		getDataset: function() {
			return this.chart.data.datasets[this.index];
		},
</P><P>		getMeta: function() {
			return this.chart.getDatasetMeta(this.index);
		},
</P><P>		getScaleForId: function(scaleID) {
			return this.chart.scales[scaleID];
		},
</P><P>		reset: function() {
			this.update(true);
		},
</P><P>		createMetaDataset: function() {
			var me = this;
			var type = me.datasetElementType;
			return type &amp;&amp; new type({
				_chart: me.chart.chart,
				_datasetIndex: me.index
			});
		},
</P><P>		createMetaData: function(index) {
			var me = this;
			var type = me.dataElementType;
			return type &amp;&amp; new type({
				_chart: me.chart.chart,
				_datasetIndex: me.index,
				_index: index
			});
		},
</P><P>		addElements: function() {
			var me = this;
			var meta = me.getMeta();
			var data = me.getDataset().data || [];
			var metaData = meta.data;
			var i, ilen;
</P><P>			for (i=0, ilen=data.length; i&lt;ilen; ++i) {
				metaData[i] = metaData[i] || me.createMetaData(meta, i);
			}
</P><P>			meta.dataset = meta.dataset || me.createMetaDataset();
		},
</P><P>		addElementAndReset: function(index) {
			var me = this;
			var element = me.createMetaData(index);
			me.getMeta().data.splice(index, 0, element);
			me.updateElement(element, index, true);
		},
</P><P>		buildOrUpdateElements: function buildOrUpdateElements() {
			// Handle the number of data points changing
			var meta = this.getMeta(),
				md = meta.data,
				numData = this.getDataset().data.length,
				numMetaData = md.length;
</P><P>			// Make sure that we handle number of datapoints changing
			if (numData &lt; numMetaData) {
				// Remove excess bars for data points that have been removed
				md.splice(numData, numMetaData - numData);
			} else if (numData &gt; numMetaData) {
				// Add new elements
				for (var index = numMetaData; index &lt; numData; ++index) {
					this.addElementAndReset(index);
				}
			}
		},
</P><P>		update: noop,
</P><P>		draw: function(ease) {
			var easingDecimal = ease || 1;
			helpers.each(this.getMeta().data, function(element, index) {
				element.transition(easingDecimal).draw();
			});
		},
</P><P>		removeHoverStyle: function(element, elementOpts) {
			var dataset = this.chart.data.datasets[element._datasetIndex],
				index = element._index,
				custom = element.custom || {},
				valueOrDefault = helpers.getValueAtIndexOrDefault,
				color = helpers.color,
				model = element._model;
</P><P>			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
		},
</P><P>		setHoverStyle: function(element) {
			var dataset = this.chart.data.datasets[element._datasetIndex],
				index = element._index,
				custom = element.custom || {},
				valueOrDefault = helpers.getValueAtIndexOrDefault,
				color = helpers.color,
				getHoverColor = helpers.getHoverColor,
				model = element._model;
</P><P>			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
		}
	});
</P><P>	Chart.DatasetController.extend = helpers.inherits;
};
},{}],24:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><PRE> var helpers = Chart.helpers;
</PRE><PRE> Chart.elements = {};
</PRE><PRE> Chart.Element = function(configuration) {
   helpers.extend(this, configuration);
   this.initialize.apply(this, arguments);
 };
</PRE><PRE> helpers.extend(Chart.Element.prototype, {
</PRE><PRE>   initialize: function() {
     this.hidden = false;
   },
</PRE><PRE>   pivot: function() {
     var me = this;
     if (!me._view) {
       me._view = helpers.clone(me._model);
     }
     me._start = helpers.clone(me._view);
     return me;
   },
</PRE><PRE>   transition: function(ease) {
     var me = this;
     
     if (!me._view) {
       me._view = helpers.clone(me._model);
     }
</PRE><PRE>     // No animation -&gt; No Transition
     if (ease === 1) {
       me._view = me._model;
       me._start = null;
       return me;
     }
</PRE><PRE>     if (!me._start) {
       me.pivot();
     }
</PRE><PRE>     helpers.each(me._model, function(value, key) {
</PRE><PRE>       if (key[0] === '_') {
         // Only non-underscored properties
       }
</PRE><PRE>       // Init if doesn't exist
       else if (!me._view.hasOwnProperty(key)) {
         if (typeof value === 'number' &amp;&amp; !isNaN(me._view[key])) {
           me._view[key] = value * ease;
         } else {
           me._view[key] = value;
         }
       }
</PRE><PRE>       // No unnecessary computations
       else if (value === me._view[key]) {
         // It's the same! Woohoo!
       }
</PRE><PRE>       // Color transitions if possible
       else if (typeof value === 'string') {
         try {
           var color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);
           me._view[key] = color.rgbString();
         } catch (err) {
           me._view[key] = value;
         }
       }
       // Number transitions
       else if (typeof value === 'number') {
         var startVal = me._start[key] !== undefined &amp;&amp; isNaN(me._start[key]) === false ? me._start[key] : 0;
         me._view[key] = ((me._model[key] - startVal) * ease) + startVal;
       }
       // Everything else
       else {
         me._view[key] = value;
       }
     }, me);
</PRE><PRE>     return me;
   },
</PRE><PRE>   tooltipPosition: function() {
     return {
       x: this._model.x,
       y: this._model.y
     };
   },
</PRE><PRE>   hasValue: function() {
     return helpers.isNumber(this._model.x) &amp;&amp; helpers.isNumber(this._model.y);
   }
 });
</PRE><PRE> Chart.Element.extend = helpers.inherits;
</PRE><P>};
</P><P>},{}],25:[function(require,module,exports){
/*global window: false */
/*global document: false */
&quot;use strict&quot;;
</P><P>var color = require(2);
</P><P>module.exports = function(Chart) {
	//Global Chart helpers object for utility methods and classes
	var helpers = Chart.helpers = {};
</P><P>	//-- Basic js utility methods
	helpers.each = function(loopable, callback, self, reverse) {
		// Check to see if null or undefined firstly.
		var i, len;
		if (helpers.isArray(loopable)) {
			len = loopable.length;
			if (reverse) {
				for (i = len - 1; i &gt;= 0; i--) {
					callback.call(self, loopable[i], i);
				}
			} else {
				for (i = 0; i &lt; len; i++) {
					callback.call(self, loopable[i], i);
				}
			}
		} else if (typeof loopable === 'object') {
			var keys = Object.keys(loopable);
			len = keys.length;
			for (i = 0; i &lt; len; i++) {
				callback.call(self, loopable[keys[i]], keys[i]);
			}
		}
	};
	helpers.clone = function(obj) {
		var objClone = {};
		helpers.each(obj, function(value, key) {
			if (helpers.isArray(value)) {
				objClone[key] = value.slice(0);
			} else if (typeof value === 'object' &amp;&amp; value !== null) {
				objClone[key] = helpers.clone(value);
			} else {
				objClone[key] = value;
			}
		});
		return objClone;
	};
	helpers.extend = function(base) {
		var setFn = function(value, key) { base[key] = value; };
		for (var i = 1, ilen = arguments.length; i &lt; ilen; i++) {
			helpers.each(arguments[i], setFn);
		}
		return base;
	};
	// Need a special merge function to chart configs since they are now grouped
	helpers.configMerge = function(_base) {
		var base = helpers.clone(_base);
		helpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {
			helpers.each(extension, function(value, key) {
				if (key === 'scales') {
					// Scale config merging is complex. Add out own function here for that
					base[key] = helpers.scaleMerge(base.hasOwnProperty(key) ? base[key] : {}, value);
</P><P>				} else if (key === 'scale') {
					// Used in polar area &amp; radar charts since there is only one scale
					base[key] = helpers.configMerge(base.hasOwnProperty(key) ? base[key] : {}, Chart.scaleService.getScaleDefaults(value.type), value);
				} else if (base.hasOwnProperty(key) &amp;&amp; helpers.isArray(base[key]) &amp;&amp; helpers.isArray(value)) {
					// In this case we have an array of objects replacing another array. Rather than doing a strict replace,
					// merge. This allows easy scale option merging
					var baseArray = base[key];
</P><P>					helpers.each(value, function(valueObj, index) {
</P><P>						if (index &lt; baseArray.length) {
							if (typeof baseArray[index] === 'object' &amp;&amp; baseArray[index] !== null &amp;&amp; typeof valueObj === 'object' &amp;&amp; valueObj !== null) {
								// Two objects are coming together. Do a merge of them.
								baseArray[index] = helpers.configMerge(baseArray[index], valueObj);
							} else {
								// Just overwrite in this case since there is nothing to merge
								baseArray[index] = valueObj;
							}
						} else {
							baseArray.push(valueObj); // nothing to merge
						}
					});
</P><P>				} else if (base.hasOwnProperty(key) &amp;&amp; typeof base[key] === &quot;object&quot; &amp;&amp; base[key] !== null &amp;&amp; typeof value === &quot;object&quot;) {
					// If we are overwriting an object with an object, do a merge of the properties.
					base[key] = helpers.configMerge(base[key], value);
</P><P>				} else {
					// can just overwrite the value in this case
					base[key] = value;
				}
			});
		});
</P><P>		return base;
	};
	helpers.scaleMerge = function(_base, extension) {
		var base = helpers.clone(_base);
</P><P>		helpers.each(extension, function(value, key) {
			if (key === 'xAxes' || key === 'yAxes') {
				// These properties are arrays of items
				if (base.hasOwnProperty(key)) {
					helpers.each(value, function(valueObj, index) {
						var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
						var axisDefaults = Chart.scaleService.getScaleDefaults(axisType);
						if (index &gt;= base[key].length || !base[key][index].type) {
							base[key].push(helpers.configMerge(axisDefaults, valueObj));
						} else if (valueObj.type &amp;&amp; valueObj.type !== base[key][index].type) {
							// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults
							base[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);
						} else {
							// Type is the same
							base[key][index] = helpers.configMerge(base[key][index], valueObj);
						}
					});
				} else {
					base[key] = [];
					helpers.each(value, function(valueObj) {
						var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');
						base[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));
					});
				}
			} else if (base.hasOwnProperty(key) &amp;&amp; typeof base[key] === &quot;object&quot; &amp;&amp; base[key] !== null &amp;&amp; typeof value === &quot;object&quot;) {
				// If we are overwriting an object with an object, do a merge of the properties.
				base[key] = helpers.configMerge(base[key], value);
</P><P>			} else {
				// can just overwrite the value in this case
				base[key] = value;
			}
		});
</P><P>		return base;
	};
	helpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {
		if (value === undefined || value === null) {
			return defaultValue;
		}
</P><P>		if (helpers.isArray(value)) {
			return index &lt; value.length ? value[index] : defaultValue;
		}
</P><P>		return value;
	};
	helpers.getValueOrDefault = function(value, defaultValue) {
		return value === undefined ? defaultValue : value;
	};
	helpers.indexOf = Array.prototype.indexOf?
		function(array, item) { return array.indexOf(item); } :
		function(array, item) {
			for (var i = 0, ilen = array.length; i &lt; ilen; ++i) {
				if (array[i] === item) {
					return i;
				}
			}
			return -1;
		};
	helpers.where = function(collection, filterCallback) {
		if (helpers.isArray(collection) &amp;&amp; Array.prototype.filter) {
			return collection.filter(filterCallback);
		} else {
			var filtered = [];
</P><P>			helpers.each(collection, function(item) {
				if (filterCallback(item)) {
					filtered.push(item);
				}
			});
</P><P>			return filtered;
		}
	};
	helpers.findIndex = Array.prototype.findIndex?
		function(array, callback, scope) { return array.findIndex(callback, scope); } :
		function(array, callback, scope) {
			scope = scope === undefined? array : scope;
			for (var i = 0, ilen = array.length; i &lt; ilen; ++i) {
				if (callback.call(scope, array[i], i, array)) {
					return i;
				}
			}
			return -1;
		};
	helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
		// Default to start of the array
		if (startIndex === undefined || startIndex === null) {
			startIndex = -1;
		}
		for (var i = startIndex + 1; i &lt; arrayToSearch.length; i++) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};
	helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
		// Default to end of the array
		if (startIndex === undefined || startIndex === null) {
			startIndex = arrayToSearch.length;
		}
		for (var i = startIndex - 1; i &gt;= 0; i--) {
			var currentItem = arrayToSearch[i];
			if (filterCallback(currentItem)) {
				return currentItem;
			}
		}
	};
	helpers.inherits = function(extensions) {
		//Basic javascript inheritance based on the model created in Backbone.js
		var parent = this;
		var ChartElement = (extensions &amp;&amp; extensions.hasOwnProperty(&quot;constructor&quot;)) ? extensions.constructor : function() {
			return parent.apply(this, arguments);
		};
</P><P>		var Surrogate = function() {
			this.constructor = ChartElement;
		};
		Surrogate.prototype = parent.prototype;
		ChartElement.prototype = new Surrogate();
</P><P>		ChartElement.extend = helpers.inherits;
</P><P>		if (extensions) {
			helpers.extend(ChartElement.prototype, extensions);
		}
</P><P>		ChartElement.__super__ = parent.prototype;
</P><P>		return ChartElement;
	};
	helpers.noop = function() {};
	helpers.uid = (function() {
		var id = 0;
		return function() {
			return id++;
		};
	})();
	//-- Math methods
	helpers.isNumber = function(n) {
		return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
	};
	helpers.almostEquals = function(x, y, epsilon) {
		return Math.abs(x - y) &lt; epsilon;
	};
	helpers.max = function(array) {
		return array.reduce(function(max, value) {
			if (!isNaN(value)) {
				return Math.max(max, value);
			} else {
				return max;
			}
		}, Number.NEGATIVE_INFINITY);
	};
	helpers.min = function(array) {
		return array.reduce(function(min, value) {
			if (!isNaN(value)) {
				return Math.min(min, value);
			} else {
				return min;
			}
		}, Number.POSITIVE_INFINITY);
	};
	helpers.sign = Math.sign?
		function(x) { return Math.sign(x); } :
		function(x) {
			x = +x; // convert to a number
			if (x === 0 || isNaN(x)) {
				return x;
			}
			return x &gt; 0 ? 1 : -1;
		};
	helpers.log10 = Math.log10?
		function(x) { return Math.log10(x); } :
		function(x) {
			return Math.log(x) / Math.LN10;
		};
	helpers.toRadians = function(degrees) {
		return degrees * (Math.PI / 180);
	};
	helpers.toDegrees = function(radians) {
		return radians * (180 / Math.PI);
	};
	// Gets the angle from vertical upright to the point about a centre.
	helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
		var distanceFromXCenter = anglePoint.x - centrePoint.x,
			distanceFromYCenter = anglePoint.y - centrePoint.y,
			radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
</P><P>		var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
</P><P>		if (angle &lt; (-0.5 * Math.PI)) {
			angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
		}
</P><P>		return {
			angle: angle,
			distance: radialDistanceFromCenter
		};
	};
	helpers.aliasPixel = function(pixelWidth) {
		return (pixelWidth % 2 === 0) ? 0 : 0.5;
	};
	helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
		//Props to Rob Spencer at scaled innovation for his post on splining between points
		//<A rel="nofollow" class="external free" href="http://scaledinnovation.com/analytics/splines/aboutSplines.html">http://scaledinnovation.com/analytics/splines/aboutSplines.html</A></P><P>		// This function must also respect &quot;skipped&quot; points
</P><P>		var previous = firstPoint.skip ? middlePoint : firstPoint,
			current = middlePoint,
			next = afterPoint.skip ? middlePoint : afterPoint;
</P><P>		var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
		var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
</P><P>		var s01 = d01 / (d01 + d12);
		var s12 = d12 / (d01 + d12);
</P><P>		// If all points are the same, s01 &amp; s02 will be inf
		s01 = isNaN(s01) ? 0 : s01;
		s12 = isNaN(s12) ? 0 : s12;
</P><P>		var fa = t * s01; // scaling factor for triangle Ta
		var fb = t * s12;
</P><P>		return {
			previous: {
				x: current.x - fa * (next.x - previous.x),
				y: current.y - fa * (next.y - previous.y)
			},
			next: {
				x: current.x + fb * (next.x - previous.x),
				y: current.y + fb * (next.y - previous.y)
			}
		};
	};
	helpers.nextItem = function(collection, index, loop) {
		if (loop) {
			return index &gt;= collection.length - 1 ? collection[0] : collection[index + 1];
		}
</P><P>		return index &gt;= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
	};
	helpers.previousItem = function(collection, index, loop) {
		if (loop) {
			return index &lt;= 0 ? collection[collection.length - 1] : collection[index - 1];
		}
		return index &lt;= 0 ? collection[0] : collection[index - 1];
	};
	// Implementation of the nice number algorithm used in determining where axis labels will go
	helpers.niceNum = function(range, round) {
		var exponent = Math.floor(helpers.log10(range));
		var fraction = range / Math.pow(10, exponent);
		var niceFraction;
</P><P>		if (round) {
			if (fraction &lt; 1.5) {
				niceFraction = 1;
			} else if (fraction &lt; 3) {
				niceFraction = 2;
			} else if (fraction &lt; 7) {
				niceFraction = 5;
			} else {
				niceFraction = 10;
			}
		} else {
			if (fraction &lt;= 1.0) {
				niceFraction = 1;
			} else if (fraction &lt;= 2) {
				niceFraction = 2;
			} else if (fraction &lt;= 5) {
				niceFraction = 5;
			} else {
				niceFraction = 10;
			}
		}
</P><P>		return niceFraction * Math.pow(10, exponent);
	};
	//Easing functions adapted from Robert Penner's easing equations
	//<A rel="nofollow" class="external free" href="http://www.robertpenner.com/easing/">http://www.robertpenner.com/easing/</A>
	var easingEffects = helpers.easingEffects = {
		linear: function(t) {
			return t;
		},
		easeInQuad: function(t) {
			return t * t;
		},
		easeOutQuad: function(t) {
			return -1 * t * (t - 2);
		},
		easeInOutQuad: function(t) {
			if ((t /= 1 / 2) &lt; 1) {
				return 1 / 2 * t * t;
			}
			return -1 / 2 * ((--t) * (t - 2) - 1);
		},
		easeInCubic: function(t) {
			return t * t * t;
		},
		easeOutCubic: function(t) {
			return 1 * ((t = t / 1 - 1) * t * t + 1);
		},
		easeInOutCubic: function(t) {
			if ((t /= 1 / 2) &lt; 1) {
				return 1 / 2 * t * t * t;
			}
			return 1 / 2 * ((t -= 2) * t * t + 2);
		},
		easeInQuart: function(t) {
			return t * t * t * t;
		},
		easeOutQuart: function(t) {
			return -1 * ((t = t / 1 - 1) * t * t * t - 1);
		},
		easeInOutQuart: function(t) {
			if ((t /= 1 / 2) &lt; 1) {
				return 1 / 2 * t * t * t * t;
			}
			return -1 / 2 * ((t -= 2) * t * t * t - 2);
		},
		easeInQuint: function(t) {
			return 1 * (t /= 1) * t * t * t * t;
		},
		easeOutQuint: function(t) {
			return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);
		},
		easeInOutQuint: function(t) {
			if ((t /= 1 / 2) &lt; 1) {
				return 1 / 2 * t * t * t * t * t;
			}
			return 1 / 2 * ((t -= 2) * t * t * t * t + 2);
		},
		easeInSine: function(t) {
			return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;
		},
		easeOutSine: function(t) {
			return 1 * Math.sin(t / 1 * (Math.PI / 2));
		},
		easeInOutSine: function(t) {
			return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);
		},
		easeInExpo: function(t) {
			return (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));
		},
		easeOutExpo: function(t) {
			return (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);
		},
		easeInOutExpo: function(t) {
			if (t === 0) {
				return 0;
			}
			if (t === 1) {
				return 1;
			}
			if ((t /= 1 / 2) &lt; 1) {
				return 1 / 2 * Math.pow(2, 10 * (t - 1));
			}
			return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);
		},
		easeInCirc: function(t) {
			if (t &gt;= 1) {
				return t;
			}
			return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);
		},
		easeOutCirc: function(t) {
			return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);
		},
		easeInOutCirc: function(t) {
			if ((t /= 1 / 2) &lt; 1) {
				return -1 / 2 * (Math.sqrt(1 - t * t) - 1);
			}
			return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);
		},
		easeInElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if ((t /= 1) === 1) {
				return 1;
			}
			if (!p) {
				p = 1 * 0.3;
			}
			if (a &lt; Math.abs(1)) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
		},
		easeOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if ((t /= 1) === 1) {
				return 1;
			}
			if (!p) {
				p = 1 * 0.3;
			}
			if (a &lt; Math.abs(1)) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;
		},
		easeInOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if ((t /= 1 / 2) === 2) {
				return 1;
			}
			if (!p) {
				p = 1 * (0.3 * 1.5);
			}
			if (a &lt; Math.abs(1)) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			if (t &lt; 1) {
				return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
			}
			return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
		},
		easeInBack: function(t) {
			var s = 1.70158;
			return 1 * (t /= 1) * t * ((s + 1) * t - s);
		},
		easeOutBack: function(t) {
			var s = 1.70158;
			return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);
		},
		easeInOutBack: function(t) {
			var s = 1.70158;
			if ((t /= 1 / 2) &lt; 1) {
				return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));
			}
			return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
		},
		easeInBounce: function(t) {
			return 1 - easingEffects.easeOutBounce(1 - t);
		},
		easeOutBounce: function(t) {
			if ((t /= 1) &lt; (1 / 2.75)) {
				return 1 * (7.5625 * t * t);
			} else if (t &lt; (2 / 2.75)) {
				return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);
			} else if (t &lt; (2.5 / 2.75)) {
				return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);
			} else {
				return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);
			}
		},
		easeInOutBounce: function(t) {
			if (t &lt; 1 / 2) {
				return easingEffects.easeInBounce(t * 2) * 0.5;
			}
			return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;
		}
	};
	//Request animation polyfill - <A rel="nofollow" class="external free" href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/">http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/</A>
	helpers.requestAnimFrame = (function() {
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) {
				return window.setTimeout(callback, 1000 / 60);
			};
	})();
	helpers.cancelAnimFrame = (function() {
		return window.cancelAnimationFrame ||
			window.webkitCancelAnimationFrame ||
			window.mozCancelAnimationFrame ||
			window.oCancelAnimationFrame ||
			window.msCancelAnimationFrame ||
			function(callback) {
				return window.clearTimeout(callback, 1000 / 60);
			};
	})();
	//-- DOM methods
	helpers.getRelativePosition = function(evt, chart) {
		var mouseX, mouseY;
		var e = evt.originalEvent || evt,
			canvas = evt.currentTarget || evt.srcElement,
			boundingRect = canvas.getBoundingClientRect();
</P><P>		var touches = e.touches;
		if (touches &amp;&amp; touches.length &gt; 0) {
			mouseX = touches[0].clientX;
			mouseY = touches[0].clientY;
</P><P>		} else {
			mouseX = e.clientX;
			mouseY = e.clientY;
		}
</P><P>		// Scale mouse coordinates into canvas coordinates
		// by following the pattern laid out by 'jerryj' in the comments of
		// <A rel="nofollow" class="external free" href="http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/">http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/</A>
		var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
		var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
		var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
		var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
		var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
		var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
</P><P>		// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
		// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
		mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
		mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);
</P><P>		return {
			x: mouseX,
			y: mouseY
		};
</P><P>	};
	helpers.addEvent = function(node, eventType, method) {
		if (node.addEventListener) {
			node.addEventListener(eventType, method);
		} else if (node.attachEvent) {
			node.attachEvent(&quot;on&quot; + eventType, method);
		} else {
			node[&quot;on&quot; + eventType] = method;
		}
	};
	helpers.removeEvent = function(node, eventType, handler) {
		if (node.removeEventListener) {
			node.removeEventListener(eventType, handler, false);
		} else if (node.detachEvent) {
			node.detachEvent(&quot;on&quot; + eventType, handler);
		} else {
			node[&quot;on&quot; + eventType] = helpers.noop;
		}
	};
	helpers.bindEvents = function(chartInstance, arrayOfEvents, handler) {
		// Create the events object if it's not already present
		var events = chartInstance.events = chartInstance.events || {};
</P><P>		helpers.each(arrayOfEvents, function(eventName) {
			events[eventName] = function() {
				handler.apply(chartInstance, arguments);
			};
			helpers.addEvent(chartInstance.chart.canvas, eventName, events[eventName]);
		});
	};
	helpers.unbindEvents = function(chartInstance, arrayOfEvents) {
		var canvas = chartInstance.chart.canvas;
		helpers.each(arrayOfEvents, function(handler, eventName) {
			helpers.removeEvent(canvas, eventName, handler);
		});
	};
</P><P>	// Private helper function to convert max-width/max-height values that may be percentages into a number
	function parseMaxStyle(styleValue, node, parentProperty) {
		var valueInPixels;
		if (typeof(styleValue) === 'string') {
			valueInPixels = parseInt(styleValue, 10);
</P><P>			if (styleValue.indexOf('%') != -1) {
				// percentage * size in dimension
				valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
			}
		} else {
			valueInPixels = styleValue;
		}
</P><P>		return valueInPixels;
	}
</P><P>	/**
	 * Returns if the given value contains an effective constraint.
	 * @private
	 */
	function isConstrainedValue(value) {
		return value !== undefined &amp;&amp;  value !== null &amp;&amp; value !== 'none';
	}
</P><P>	// Private helper to get a constraint dimension
	// @param domNode : the node to check the constraint on
	// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
	// @param percentageProperty : property of parent to use when calculating width as a percentage
	// @see <A rel="nofollow" class="external free" href="http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser">http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser</A>
	function getConstraintDimension(domNode, maxStyle, percentageProperty) {
		var view = document.defaultView;
		var parentNode = domNode.parentNode;
		var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
		var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
		var hasCNode = isConstrainedValue(constrainedNode);
		var hasCContainer = isConstrainedValue(constrainedContainer);
		var infinity = Number.POSITIVE_INFINITY;
</P><P>		if (hasCNode || hasCContainer) {
			return Math.min(
				hasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
				hasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
		}
</P><P>		return 'none';
	}
	// returns Number or undefined if no constraint
	helpers.getConstraintWidth = function(domNode) {
		return getConstraintDimension(domNode, 'max-width', 'clientWidth');
	};
	// returns Number or undefined if no constraint
	helpers.getConstraintHeight = function(domNode) {
		return getConstraintDimension(domNode, 'max-height', 'clientHeight');
	};
	helpers.getMaximumWidth = function(domNode) {
		var container = domNode.parentNode;
		var padding = parseInt(helpers.getStyle(container, 'padding-left')) + parseInt(helpers.getStyle(container, 'padding-right'));
		var w = container.clientWidth - padding;
		var cw = helpers.getConstraintWidth(domNode);
		return isNaN(cw)? w : Math.min(w, cw);
	};
	helpers.getMaximumHeight = function(domNode) {
		var container = domNode.parentNode;
		var padding = parseInt(helpers.getStyle(container, 'padding-top')) + parseInt(helpers.getStyle(container, 'padding-bottom'));
		var h = container.clientHeight - padding;
		var ch = helpers.getConstraintHeight(domNode);
		return isNaN(ch)? h : Math.min(h, ch);
	};
	helpers.getStyle = function(el, property) {
		return el.currentStyle ?
			el.currentStyle[property] :
			document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
	};
	helpers.retinaScale = function(chart) {
		var ctx = chart.ctx;
		var canvas = chart.canvas;
		var width = canvas.width;
		var height = canvas.height;
		var pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;
</P><P>		if (pixelRatio !== 1) {
			canvas.height = height * pixelRatio;
			canvas.width = width * pixelRatio;
			ctx.scale(pixelRatio, pixelRatio);
</P><P>			// Store the device pixel ratio so that we can go backwards in `destroy`.
			// The devicePixelRatio changes with zoom, so there are no guarantees that it is the same
			// when destroy is called
			chart.originalDevicePixelRatio = chart.originalDevicePixelRatio || pixelRatio;
		}
</P><P>		canvas.style.width = width + 'px';
		canvas.style.height = height + 'px';
	};
	//-- Canvas methods
	helpers.clear = function(chart) {
		chart.ctx.clearRect(0, 0, chart.width, chart.height);
	};
	helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
		return fontStyle + &quot; &quot; + pixelSize + &quot;px &quot; + fontFamily;
	};
	helpers.longestText = function(ctx, font, arrayOfThings, cache) {
		cache = cache || {};
		var data = cache.data = cache.data || {};
		var gc = cache.garbageCollect = cache.garbageCollect || [];
</P><P>		if (cache.font !== font) {
			data = cache.data = {};
			gc = cache.garbageCollect = [];
			cache.font = font;
		}
</P><P>		ctx.font = font;
		var longest = 0;
		helpers.each(arrayOfThings, function(thing) {
			// Undefined strings and arrays should not be measured
			if (thing !== undefined &amp;&amp; thing !== null &amp;&amp; helpers.isArray(thing) !== true) {
				longest = helpers.measureText(ctx, data, gc, longest, thing);
			} else if (helpers.isArray(thing)) {
				// if it is an array lets measure each element
				// to do maybe simplify this function a bit so we can do this more recursively?
				helpers.each(thing, function(nestedThing) {
					// Undefined strings and arrays should not be measured
					if (nestedThing !== undefined &amp;&amp; nestedThing !== null &amp;&amp; !helpers.isArray(nestedThing)) {
						longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
					}
				});
			}
		});
</P><P>		var gcLen = gc.length / 2;
		if (gcLen &gt; arrayOfThings.length) {
			for (var i = 0; i &lt; gcLen; i++) {
				delete data[gc[i]];
			}
			gc.splice(0, gcLen);
		}
		return longest;
	};
	helpers.measureText = function (ctx, data, gc, longest, string) {
		var textWidth = data[string];
		if (!textWidth) {
			textWidth = data[string] = ctx.measureText(string).width;
			gc.push(string);
		}
		if (textWidth &gt; longest) {
			longest = textWidth;
		}
		return longest;
	};
	helpers.numberOfLabelLines = function(arrayOfThings) {
		var numberOfLines = 1;
		helpers.each(arrayOfThings, function(thing) {
			if (helpers.isArray(thing)) {
				if (thing.length &gt; numberOfLines) {
					numberOfLines = thing.length;
				}
			}
		});
		return numberOfLines;
	};
	helpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {
		ctx.beginPath();
		ctx.moveTo(x + radius, y);
		ctx.lineTo(x + width - radius, y);
		ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
		ctx.lineTo(x + width, y + height - radius);
		ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
		ctx.lineTo(x + radius, y + height);
		ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
		ctx.lineTo(x, y + radius);
		ctx.quadraticCurveTo(x, y, x + radius, y);
		ctx.closePath();
	};
	helpers.color = function(c) {
		if (!color) {
			console.log('Color.js not found!');
			return c;
		}
</P><P>		/* global CanvasGradient */
		if (c instanceof CanvasGradient) {
			return color(Chart.defaults.global.defaultColor);
		}
</P><P>		return color(c);
	};
	helpers.addResizeListener = function(node, callback) {
		// Hide an iframe before the node
		var hiddenIframe = document.createElement('iframe');
		var hiddenIframeClass = 'chartjs-hidden-iframe';
</P><P>		if (hiddenIframe.classlist) {
			// can use classlist
			hiddenIframe.classlist.add(hiddenIframeClass);
		} else {
			hiddenIframe.setAttribute('class', hiddenIframeClass);
		}
</P><P>		// Set the style
		var style = hiddenIframe.style;
		style.width = '100%';
		style.display = 'block';
		style.border = 0;
		style.height = 0;
		style.margin = 0;
		style.position = 'absolute';
		style.left = 0;
		style.right = 0;
		style.top = 0;
		style.bottom = 0;
</P><P>		// Insert the iframe so that contentWindow is available
		node.insertBefore(hiddenIframe, node.firstChild);
</P><P>		(hiddenIframe.contentWindow || hiddenIframe).onresize = function() {
			if (callback) {
				callback();
			}
		};
	};
	helpers.removeResizeListener = function(node) {
		var hiddenIframe = node.querySelector('.chartjs-hidden-iframe');
</P><P>		// Remove the resize detect iframe
		if (hiddenIframe) {
			hiddenIframe.parentNode.removeChild(hiddenIframe);
		}
	};
	helpers.isArray = Array.isArray?
		function(obj) { return Array.isArray(obj); } :
		function(obj) {
			return Object.prototype.toString.call(obj) === '[object Array]';
		};
	//! @see <A rel="nofollow" class="external free" href="http://stackoverflow.com/a/14853974">http://stackoverflow.com/a/14853974</A>
	helpers.arrayEquals = function(a0, a1) {
		var i, ilen, v0, v1;
</P><P>		if (!a0 || !a1 || a0.length != a1.length) {
			return false;
		}
</P><P>		for (i = 0, ilen=a0.length; i &lt; ilen; ++i) {
			v0 = a0[i];
			v1 = a1[i];
</P><P>			if (v0 instanceof Array &amp;&amp; v1 instanceof Array) {
				if (!helpers.arrayEquals(v0, v1)) {
					return false;
				}
			} else if (v0 != v1) {
				// NOTE: two different object instances will never be equal: {x:20} != {x:20}
				return false;
			}
		}
</P><P>		return true;
	};
	helpers.callCallback = function(fn, args, _tArg) {
		if (fn &amp;&amp; typeof fn.call === 'function') {
			fn.apply(_tArg, args);
		}
	};
	helpers.getHoverColor = function(color) {
		/* global CanvasPattern */
		return (color instanceof CanvasPattern) ?
			color :
			helpers.color(color).saturate(0.5).darken(0.1).rgbString();
	};
};
</P><P>},{&quot;2&quot;:2}],26:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function() {
</P><P>	//Occupy the global variable of Chart, and create a simple base class
	var Chart = function(context, config) {
		var me = this;
		var helpers = Chart.helpers;
		me.config = config;
</P><P>		// Support a jQuery'd canvas element
		if (context.length &amp;&amp; context[0].getContext) {
			context = context[0];
		}
</P><P>		// Support a canvas domnode
		if (context.getContext) {
			context = context.getContext(&quot;2d&quot;);
		}
</P><P>		me.ctx = context;
		me.canvas = context.canvas;
</P><P>		context.canvas.style.display = context.canvas.style.display || 'block';
</P><P>		// Figure out what the size of the chart will be.
		// If the canvas has a specified width and height, we use those else
		// we look to see if the canvas node has a CSS width and height.
		// If there is still no height, fill the parent container
		me.width = context.canvas.width || parseInt(helpers.getStyle(context.canvas, 'width'), 10) || helpers.getMaximumWidth(context.canvas);
		me.height = context.canvas.height || parseInt(helpers.getStyle(context.canvas, 'height'), 10) || helpers.getMaximumHeight(context.canvas);
</P><P>		me.aspectRatio = me.width / me.height;
</P><P>		if (isNaN(me.aspectRatio) || isFinite(me.aspectRatio) === false) {
			// If the canvas has no size, try and figure out what the aspect ratio will be.
			// Some charts prefer square canvases (pie, radar, etc). If that is specified, use that
			// else use the canvas default ratio of 2
			me.aspectRatio = config.aspectRatio !== undefined ? config.aspectRatio : 2;
		}
</P><P>		// Store the original style of the element so we can set it back
		me.originalCanvasStyleWidth = context.canvas.style.width;
		me.originalCanvasStyleHeight = context.canvas.style.height;
</P><P>		// High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.
		helpers.retinaScale(me);
</P><P>		if (config) {
			me.controller = new Chart.Controller(me);
		}
</P><P>		// Always bind this so that if the responsive state changes we still work
		helpers.addResizeListener(context.canvas.parentNode, function() {
			if (me.controller &amp;&amp; me.controller.config.options.responsive) {
				me.controller.resize();
			}
		});
</P><P>		return me.controller ? me.controller : me;
</P><P>	};
</P><P>	//Globally expose the defaults to allow for user updating/changing
	Chart.defaults = {
		global: {
			responsive: true,
			responsiveAnimationDuration: 0,
			maintainAspectRatio: true,
			events: [&quot;mousemove&quot;, &quot;mouseout&quot;, &quot;click&quot;, &quot;touchstart&quot;, &quot;touchmove&quot;],
			hover: {
				onHover: null,
				mode: 'single',
				animationDuration: 400
			},
			onClick: null,
			defaultColor: 'rgba(0,0,0,0.1)',
			defaultFontColor: '#666',
			defaultFontFamily: &quot;'Helvetica Neue', 'Helvetica', 'Arial', sans-serif&quot;,
			defaultFontSize: 12,
			defaultFontStyle: 'normal',
			showLines: true,
</P><P>			// Element defaults defined in element extensions
			elements: {},
</P><P>			// Legend callback string
			legendCallback: function(chart) {
				var text = [];
</P>
				text.push('<UL class="' + chart.id + '-legend">');
				for (var i = 0; i &lt; chart.data.datasets.length; i++) {
					text.push('<LI>');
					if (chart.data.datasets[i].label) {
						text.push(chart.data.datasets[i].label);
					}
					text.push('</LI>');
<P>				}
</P>
				text.push('</UL>');
<P>				return text.join(&quot;&quot;);
			}
		}
	};
</P><P>	Chart.Chart = Chart;
</P><P>	return Chart;
</P><P>};
</P><P>},{}],27:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	// The layout service is very self explanatory.  It's responsible for the layout within a chart.
	// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
	// It is this service's responsibility of carrying out that layout.
	Chart.layoutService = {
		defaults: {},
</P><P>		// Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.
		addBox: function(chartInstance, box) {
			if (!chartInstance.boxes) {
				chartInstance.boxes = [];
			}
			chartInstance.boxes.push(box);
		},
</P><P>		removeBox: function(chartInstance, box) {
			if (!chartInstance.boxes) {
				return;
			}
			chartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);
		},
</P><P>		// The most important function
		update: function(chartInstance, width, height) {
</P><P>			if (!chartInstance) {
				return;
			}
</P><P>			var xPadding = 0;
			var yPadding = 0;
</P><P>			var leftBoxes = helpers.where(chartInstance.boxes, function(box) {
				return box.options.position === &quot;left&quot;;
			});
			var rightBoxes = helpers.where(chartInstance.boxes, function(box) {
				return box.options.position === &quot;right&quot;;
			});
			var topBoxes = helpers.where(chartInstance.boxes, function(box) {
				return box.options.position === &quot;top&quot;;
			});
			var bottomBoxes = helpers.where(chartInstance.boxes, function(box) {
				return box.options.position === &quot;bottom&quot;;
			});
</P><P>			// Boxes that overlay the chartarea such as the radialLinear scale
			var chartAreaBoxes = helpers.where(chartInstance.boxes, function(box) {
				return box.options.position === &quot;chartArea&quot;;
			});
</P><P>			// Ensure that full width boxes are at the very top / bottom
			topBoxes.sort(function(a, b) {
				return (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);
			});
			bottomBoxes.sort(function(a, b) {
				return (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);
			});
</P><P>			// Essentially we now have any number of boxes on each of the 4 sides.
			// Our canvas looks like the following.
			// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
			// B1 is the bottom axis
			// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
			// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
			// an error will be thrown.
			//
			// |----------------------------------------------------|
			// |                  T1 (Full Width)                   |
			// |----------------------------------------------------|
			// |    |    |                 T2                  |    |
			// |    |----|-------------------------------------|----|
			// |    |    | C1 |                           | C2 |    |
			// |    |    |----|                           |----|    |
			// |    |    |                                     |    |
			// | L1 | L2 |           ChartArea (C0)            | R1 |
			// |    |    |                                     |    |
			// |    |    |----|                           |----|    |
			// |    |    | C3 |                           | C4 |    |
			// |    |----|-------------------------------------|----|
			// |    |    |                 B1                  |    |
			// |----------------------------------------------------|
			// |                  B2 (Full Width)                   |
			// |----------------------------------------------------|
			//
			// What we do to find the best sizing, we do the following
			// 1. Determine the minimum size of the chart area.
			// 2. Split the remaining width equally between each vertical axis
			// 3. Split the remaining height equally between each horizontal axis
			// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
			// 5. Adjust the sizes of each axis based on it's minimum reported size.
			// 6. Refit each axis
			// 7. Position each axis in the final location
			// 8. Tell the chart the final location of the chart area
			// 9. Tell any axes that overlay the chart area the positions of the chart area
</P><P>			// Step 1
			var chartWidth = width - (2 * xPadding);
			var chartHeight = height - (2 * yPadding);
			var chartAreaWidth = chartWidth / 2; // min 50%
			var chartAreaHeight = chartHeight / 2; // min 50%
</P><P>			// Step 2
			var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);
</P><P>			// Step 3
			var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);
</P><P>			// Step 4
			var maxChartAreaWidth = chartWidth;
			var maxChartAreaHeight = chartHeight;
			var minBoxSizes = [];
</P><P>			helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);
</P><P>			function getMinimumBoxSize(box) {
				var minSize;
				var isHorizontal = box.isHorizontal();
</P><P>				if (isHorizontal) {
					minSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
					maxChartAreaHeight -= minSize.height;
				} else {
					minSize = box.update(verticalBoxWidth, chartAreaHeight);
					maxChartAreaWidth -= minSize.width;
				}
</P><P>				minBoxSizes.push({
					horizontal: isHorizontal,
					minSize: minSize,
					box: box
				});
			}
</P><P>			// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
			// be if the axes are drawn at their minimum sizes.
</P><P>			// Steps 5 &amp; 6
			var totalLeftBoxesWidth = xPadding;
			var totalRightBoxesWidth = xPadding;
			var totalTopBoxesHeight = yPadding;
			var totalBottomBoxesHeight = yPadding;
</P><P>			// Update, and calculate the left and right margins for the horizontal boxes
			helpers.each(leftBoxes.concat(rightBoxes), fitBox);
</P><P>			helpers.each(leftBoxes, function(box) {
				totalLeftBoxesWidth += box.width;
			});
</P><P>			helpers.each(rightBoxes, function(box) {
				totalRightBoxesWidth += box.width;
			});
</P><P>			// Set the Left and Right margins for the horizontal boxes
			helpers.each(topBoxes.concat(bottomBoxes), fitBox);
</P><P>			// Function to fit a box
			function fitBox(box) {
				var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBoxSize) {
					return minBoxSize.box === box;
				});
</P><P>				if (minBoxSize) {
					if (box.isHorizontal()) {
						var scaleMargin = {
							left: totalLeftBoxesWidth,
							right: totalRightBoxesWidth,
							top: 0,
							bottom: 0
						};
</P><P>						// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
						// on the margin. Sometimes they need to increase in size slightly
						box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
					} else {
						box.update(minBoxSize.minSize.width, maxChartAreaHeight);
					}
				}
			}
</P><P>			// Figure out how much margin is on the top and bottom of the vertical boxes
			helpers.each(topBoxes, function(box) {
				totalTopBoxesHeight += box.height;
			});
</P><P>			helpers.each(bottomBoxes, function(box) {
				totalBottomBoxesHeight += box.height;
			});
</P><P>			// Let the left layout know the final margin
			helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);
</P><P>			function finalFitVerticalBox(box) {
				var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBoxSize) {
					return minBoxSize.box === box;
				});
</P><P>				var scaleMargin = {
					left: 0,
					right: 0,
					top: totalTopBoxesHeight,
					bottom: totalBottomBoxesHeight
				};
</P><P>				if (minBoxSize) {
					box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
				}
			}
</P><P>			// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
			totalLeftBoxesWidth = xPadding;
			totalRightBoxesWidth = xPadding;
			totalTopBoxesHeight = yPadding;
			totalBottomBoxesHeight = yPadding;
</P><P>			helpers.each(leftBoxes, function(box) {
				totalLeftBoxesWidth += box.width;
			});
</P><P>			helpers.each(rightBoxes, function(box) {
				totalRightBoxesWidth += box.width;
			});
</P><P>			helpers.each(topBoxes, function(box) {
				totalTopBoxesHeight += box.height;
			});
			helpers.each(bottomBoxes, function(box) {
				totalBottomBoxesHeight += box.height;
			});
</P><P>			// Figure out if our chart area changed. This would occur if the dataset layout label rotation
			// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
			// without calling `fit` again
			var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
			var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;
</P><P>			if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
				helpers.each(leftBoxes, function(box) {
					box.height = newMaxChartAreaHeight;
				});
</P><P>				helpers.each(rightBoxes, function(box) {
					box.height = newMaxChartAreaHeight;
				});
</P><P>				helpers.each(topBoxes, function(box) {
					if (!box.options.fullWidth) {
						box.width = newMaxChartAreaWidth;
					}
				});
</P><P>				helpers.each(bottomBoxes, function(box) {
					if (!box.options.fullWidth) {
						box.width = newMaxChartAreaWidth;
					}
				});
</P><P>				maxChartAreaHeight = newMaxChartAreaHeight;
				maxChartAreaWidth = newMaxChartAreaWidth;
			}
</P><P>			// Step 7 - Position the boxes
			var left = xPadding;
			var top = yPadding;
			var right = 0;
			var bottom = 0;
</P><P>			helpers.each(leftBoxes.concat(topBoxes), placeBox);
</P><P>			// Account for chart width and height
			left += maxChartAreaWidth;
			top += maxChartAreaHeight;
</P><P>			helpers.each(rightBoxes, placeBox);
			helpers.each(bottomBoxes, placeBox);
</P><P>			function placeBox(box) {
				if (box.isHorizontal()) {
					box.left = box.options.fullWidth ? xPadding : totalLeftBoxesWidth;
					box.right = box.options.fullWidth ? width - xPadding : totalLeftBoxesWidth + maxChartAreaWidth;
					box.top = top;
					box.bottom = top + box.height;
</P><P>					// Move to next point
					top = box.bottom;
</P><P>				} else {
</P><P>					box.left = left;
					box.right = left + box.width;
					box.top = totalTopBoxesHeight;
					box.bottom = totalTopBoxesHeight + maxChartAreaHeight;
</P><P>					// Move to next point
					left = box.right;
				}
			}
</P><P>			// Step 8
			chartInstance.chartArea = {
				left: totalLeftBoxesWidth,
				top: totalTopBoxesHeight,
				right: totalLeftBoxesWidth + maxChartAreaWidth,
				bottom: totalTopBoxesHeight + maxChartAreaHeight
			};
</P><P>			// Step 9
			helpers.each(chartAreaBoxes, function(box) {
				box.left = chartInstance.chartArea.left;
				box.top = chartInstance.chartArea.top;
				box.right = chartInstance.chartArea.right;
				box.bottom = chartInstance.chartArea.bottom;
</P><P>				box.update(maxChartAreaWidth, maxChartAreaHeight);
			});
		}
	};
};
</P><P>},{}],28:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
	var noop = helpers.noop;
</P><P>	Chart.defaults.global.legend = {
</P><P>		display: true,
		position: 'top',
		fullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)
		reverse: false,
</P><P>		// a callback that will handle
		onClick: function(e, legendItem) {
			var index = legendItem.datasetIndex;
			var ci = this.chart;
			var meta = ci.getDatasetMeta(index);
</P><P>			// See controller.isDatasetVisible comment
			meta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;
</P><P>			// We hid a dataset ... rerender the chart
			ci.update();
		},
</P><P>		labels: {
			boxWidth: 40,
			padding: 10,
			// Generates labels shown in the legend
			// Valid properties to return:
			// text : text to display
			// fillStyle : fill of coloured box
			// strokeStyle: stroke of coloured box
			// hidden : if this legend item refers to a hidden item
			// lineCap : cap style for line
			// lineDash
			// lineDashOffset :
			// lineJoin :
			// lineWidth :
			generateLabels: function(chart) {
				var data = chart.data;
				return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
					return {
						text: dataset.label,
						fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
						hidden: !chart.isDatasetVisible(i),
						lineCap: dataset.borderCapStyle,
						lineDash: dataset.borderDash,
						lineDashOffset: dataset.borderDashOffset,
						lineJoin: dataset.borderJoinStyle,
						lineWidth: dataset.borderWidth,
						strokeStyle: dataset.borderColor,
</P><P>						// Below is extra data used for toggling the datasets
						datasetIndex: i
					};
				}, this) : [];
			}
		}
	};
</P><P>	Chart.Legend = Chart.Element.extend({
</P><P>		initialize: function(config) {
			helpers.extend(this, config);
</P><P>			// Contains hit boxes for each dataset (in dataset order)
			this.legendHitBoxes = [];
</P><P>			// Are we in doughnut mode which has a different data type
			this.doughnutMode = false;
		},
</P><P>		// These methods are ordered by lifecyle. Utilities then follow.
		// Any function defined here is inherited by all legend types.
		// Any function can be extended by the legend type
</P><P>		beforeUpdate: noop,
		update: function(maxWidth, maxHeight, margins) {
			var me = this;
</P><P>			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
			me.beforeUpdate();
</P><P>			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = margins;
</P><P>			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();
</P><P>			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();
</P><P>			return me.minSize;
		},
		afterUpdate: noop,
</P><P>		//
</P><P>		beforeSetDimensions: noop,
		setDimensions: function() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;
</P><P>				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}
</P><P>			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;
</P><P>			// Reset minSize
			me.minSize = {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,
</P><P>		//
</P><P>		beforeBuildLabels: noop,
		buildLabels: function() {
			var me = this;
			me.legendItems = me.options.labels.generateLabels.call(me, me.chart);
			if(me.options.reverse){
				me.legendItems.reverse();
			}
		},
		afterBuildLabels: noop,
</P><P>		//
</P><P>		beforeFit: noop,
		fit: function() {
			var me = this;
			var opts = me.options;
			var labelOpts = opts.labels;
			var display = opts.display;
</P><P>			var ctx = me.ctx;
</P><P>			var globalDefault = Chart.defaults.global,
				itemOrDefault = helpers.getValueOrDefault,
				fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),
				fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),
				fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),
				labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
</P><P>			// Reset hit boxes
			var hitboxes = me.legendHitBoxes = [];
</P><P>			var minSize = me.minSize;
			var isHorizontal = me.isHorizontal();
</P><P>			if (isHorizontal) {
				minSize.width = me.maxWidth; // fill all the width
				minSize.height = display ? 10 : 0;
			} else {
				minSize.width = display ? 10 : 0;
				minSize.height = me.maxHeight; // fill all the height
			}
</P><P>			// Increase sizes here
			if (display) {
				ctx.font = labelFont;
</P><P>				if (isHorizontal) {
					// Labels
</P><P>					// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
					var lineWidths = me.lineWidths = [0];
					var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;
</P><P>					ctx.textAlign = &quot;left&quot;;
					ctx.textBaseline = 'top';
</P><P>					helpers.each(me.legendItems, function(legendItem, i) {
						var width = labelOpts.boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
						if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding &gt;= me.width) {
							totalHeight += fontSize + (labelOpts.padding);
							lineWidths[lineWidths.length] = me.left;
						}
</P><P>						// Store the hitbox width and height here. Final position will be updated in `draw`
						hitboxes[i] = {
							left: 0,
							top: 0,
							width: width,
							height: fontSize
						};
</P><P>						lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
					});
</P><P>					minSize.height += totalHeight;
</P><P>				} else {
					var vPadding = labelOpts.padding;
					var columnWidths = me.columnWidths = [];
					var totalWidth = labelOpts.padding;
					var currentColWidth = 0;
					var currentColHeight = 0;
					var itemHeight = fontSize + vPadding;
</P><P>					helpers.each(me.legendItems, function(legendItem, i) {
						var itemWidth = labelOpts.boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
</P><P>						// If too tall, go to new column
						if (currentColHeight + itemHeight &gt; minSize.height) {
							totalWidth += currentColWidth + labelOpts.padding;
							columnWidths.push(currentColWidth); // previous column width
</P><P>							currentColWidth = 0;
							currentColHeight = 0;
						}
</P><P>						// Get max width
						currentColWidth = Math.max(currentColWidth, itemWidth);
						currentColHeight += itemHeight;
</P><P>						// Store the hitbox width and height here. Final position will be updated in `draw`
						hitboxes[i] = {
							left: 0,
							top: 0,
							width: itemWidth,
							height: fontSize
						};
					});
</P><P>					totalWidth += currentColWidth;
					columnWidths.push(currentColWidth);
					minSize.width += totalWidth;
				}
			}
</P><P>			me.width = minSize.width;
			me.height = minSize.height;
		},
		afterFit: noop,
</P><P>		// Shared Methods
		isHorizontal: function() {
			return this.options.position === &quot;top&quot; || this.options.position === &quot;bottom&quot;;
		},
</P><P>		// Actualy draw the legend on the canvas
		draw: function() {
			var me = this;
			var opts = me.options;
			var labelOpts = opts.labels;
			var globalDefault = Chart.defaults.global,
				lineDefault = globalDefault.elements.line,
				legendWidth = me.width,
				legendHeight = me.height,
				lineWidths = me.lineWidths;
</P><P>			if (opts.display) {
				var ctx = me.ctx,
					cursor,
					itemOrDefault = helpers.getValueOrDefault,
					fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),
					fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),
					fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),
					fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),
					labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
</P><P>				// Canvas setup
				ctx.textAlign = &quot;left&quot;;
				ctx.textBaseline = 'top';
				ctx.lineWidth = 0.5;
				ctx.strokeStyle = fontColor; // for strikethrough effect
				ctx.fillStyle = fontColor; // render in correct colour
				ctx.font = labelFont;
</P><P>				var boxWidth = labelOpts.boxWidth,
					hitboxes = me.legendHitBoxes;
</P><P>				// current position
				var drawLegendBox = function(x, y, legendItem) {
					// Set the ctx for the box
					ctx.save();
</P><P>					ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
					ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
					ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
					ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
					ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
					ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
</P><P>					if (ctx.setLineDash) {
						// IE 9 and 10 do not support line dash
						ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));
					}
</P><P>					// Draw the box
					ctx.strokeRect(x, y, boxWidth, fontSize);
					ctx.fillRect(x, y, boxWidth, fontSize);
</P><P>					ctx.restore();
				};
				var fillText = function(x, y, legendItem, textWidth) {
					ctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);
</P><P>					if (legendItem.hidden) {
						// Strikethrough the text if hidden
						ctx.beginPath();
						ctx.lineWidth = 2;
						ctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));
						ctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));
						ctx.stroke();
					}
				};
</P><P>				// Horizontal
				var isHorizontal = me.isHorizontal();
				if (isHorizontal) {
					cursor = {
						x: me.left + ((legendWidth - lineWidths[0]) / 2),
						y: me.top + labelOpts.padding,
						line: 0
					};
				} else {
					cursor = {
						x: me.left + labelOpts.padding,
						y: me.top,
						line: 0
					};
				}
</P><P>				var itemHeight = fontSize + labelOpts.padding;
				helpers.each(me.legendItems, function(legendItem, i) {
					var textWidth = ctx.measureText(legendItem.text).width,
						width = boxWidth + (fontSize / 2) + textWidth,
						x = cursor.x,
						y = cursor.y;
</P><P>					if (isHorizontal) {
						if (x + width &gt;= legendWidth) {
							y = cursor.y += fontSize + (labelOpts.padding);
							cursor.line++;
							x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
						}
					} else {
						if (y + itemHeight &gt; me.bottom) {
							x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
							y = cursor.y = me.top;
							cursor.line++;
						}
					}
</P><P>
					drawLegendBox(x, y, legendItem);
</P><P>					hitboxes[i].left = x;
					hitboxes[i].top = y;
</P><P>					// Fill the actual label
					fillText(x, y, legendItem, textWidth);
</P><P>					if (isHorizontal) {
						cursor.x += width + (labelOpts.padding);
					} else {
						cursor.y += itemHeight;
					}
</P><P>				});
			}
		},
</P><P>		// Handle an event
		handleEvent: function(e) {
			var me = this;
			var position = helpers.getRelativePosition(e, me.chart.chart),
				x = position.x,
				y = position.y,
				opts = me.options;
</P><P>			if (x &gt;= me.left &amp;&amp; x &lt;= me.right &amp;&amp; y &gt;= me.top &amp;&amp; y &lt;= me.bottom) {
				// See if we are touching one of the dataset boxes
				var lh = me.legendHitBoxes;
				for (var i = 0; i &lt; lh.length; ++i) {
					var hitBox = lh[i];
</P><P>					if (x &gt;= hitBox.left &amp;&amp; x &lt;= hitBox.left + hitBox.width &amp;&amp; y &gt;= hitBox.top &amp;&amp; y &lt;= hitBox.top + hitBox.height) {
						// Touching an element
						if (opts.onClick) {
							opts.onClick.call(me, e, me.legendItems[i]);
						}
						break;
					}
				}
			}
		}
	});
</P><P>	// Register the legend plugin
	Chart.plugins.register({
		beforeInit: function(chartInstance) {
			var opts = chartInstance.options;
			var legendOpts = opts.legend;
</P><P>			if (legendOpts) {
				chartInstance.legend = new Chart.Legend({
					ctx: chartInstance.chart.ctx,
					options: legendOpts,
					chart: chartInstance
				});
</P><P>				Chart.layoutService.addBox(chartInstance, chartInstance.legend);
			}
		}
	});
};
</P><P>},{}],29:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var noop = Chart.helpers.noop;
</P><P>	/**
	 * The plugin service singleton
	 * @namespace Chart.plugins
	 * @since 2.1.0
	 */
	Chart.plugins = {
		_plugins: [],
</P><P>		/**
		 * Registers the given plugin(s) if not already registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
		register: function(plugins) {
			var p = this._plugins;
			([]).concat(plugins).forEach(function(plugin) {
				if (p.indexOf(plugin) === -1) {
					p.push(plugin);
				}
			});
		},
</P><P>		/**
		 * Unregisters the given plugin(s) only if registered.
		 * @param {Array|Object} plugins plugin instance(s).
		 */
		unregister: function(plugins) {
			var p = this._plugins;
			([]).concat(plugins).forEach(function(plugin) {
				var idx = p.indexOf(plugin);
				if (idx !== -1) {
					p.splice(idx, 1);
				}
			});
		},
</P><P>		/**
		 * Remove all registered p^lugins.
		 * @since 2.1.5
		 */
		clear: function() {
			this._plugins = [];
		},
</P><P>		/**
		 * Returns the number of registered plugins?
		 * @returns {Number}
		 * @since 2.1.5
		 */
		count: function() {
			return this._plugins.length;
		},
</P><P>		/**
		 * Returns all registered plugin intances.
		 * @returns {Array} array of plugin objects.
		 * @since 2.1.5
		 */
		getAll: function() {
			return this._plugins;
		},
</P><P>		/**
		 * Calls registered plugins on the specified extension, with the given args. This
		 * method immediately returns as soon as a plugin explicitly returns false. The
		 * returned value can be used, for instance, to interrupt the current action.
		 * @param {String} extension the name of the plugin method to call (e.g. 'beforeUpdate').
		 * @param {Array} [args] extra arguments to apply to the extension call.
		 * @returns {Boolean} false if any of the plugins return false, else returns true.
		 */
		notify: function(extension, args) {
			var plugins = this._plugins;
			var ilen = plugins.length;
			var i, plugin;
</P><P>			for (i=0; i&lt;ilen; ++i) {
				plugin = plugins[i];
				if (typeof plugin[extension] === 'function') {
					if (plugin[extension].apply(plugin, args || []) === false) {
						return false;
					}
				}
			}
</P><P>			return true;
		}
	};
</P><P>	/**
	 * Plugin extension methods.
	 * @interface Chart.PluginBase
	 * @since 2.1.0
	 */
	Chart.PluginBase = Chart.Element.extend({
		// Called at start of chart init
		beforeInit: noop,
</P><P>		// Called at end of chart init
		afterInit: noop,
</P><P>		// Called at start of update
		beforeUpdate: noop,
</P><P>		// Called at end of update
		afterUpdate: noop,
</P><P>		// Called at start of draw
		beforeDraw: noop,
</P><P>		// Called at end of draw
		afterDraw: noop,
</P><P>		// Called during destroy
		destroy: noop
	});
</P><P>	/**
	 * Provided for backward compatibility, use Chart.plugins instead
	 * @namespace Chart.pluginService
	 * @deprecated since version 2.1.5
	 * @todo remove me at version 3
	 */
	Chart.pluginService = Chart.plugins;
};</P><P>},{}],30:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.defaults.scale = {
		display: true,
		position: &quot;left&quot;,
</P><P>		// grid line settings
		gridLines: {
			display: true,
			color: &quot;rgba(0, 0, 0, 0.1)&quot;,
			lineWidth: 1,
			drawBorder: true,
			drawOnChartArea: true,
			drawTicks: true,
			tickMarkLength: 10,
			zeroLineWidth: 1,
			zeroLineColor: &quot;rgba(0,0,0,0.25)&quot;,
			offsetGridLines: false
		},
</P><P>		// scale label
		scaleLabel: {
			// actual label
			labelString: <I>,</I></P><P>			// display property
			display: false
		},
</P><P>		// label settings
		ticks: {
			beginAtZero: false,
			minRotation: 0,
			maxRotation: 50,
			mirror: false,
			padding: 10,
			reverse: false,
			display: true,
			autoSkip: true,
			autoSkipPadding: 0,
			labelOffset: 0,
			// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
			callback: function(value) {
				return helpers.isArray(value) ? value : <I> + value;</I>
			}
		}
	};
</P><P>	Chart.Scale = Chart.Element.extend({
</P><P>		// These methods are ordered by lifecyle. Utilities then follow.
		// Any function defined here is inherited by all scale types.
		// Any function can be extended by the scale type
</P><P>		beforeUpdate: function() {
			helpers.callCallback(this.options.beforeUpdate, [this]);
		},
		update: function(maxWidth, maxHeight, margins) {
			var me = this;
</P><P>			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
			me.beforeUpdate();
</P><P>			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = helpers.extend({
				left: 0,
				right: 0,
				top: 0,
				bottom: 0
			}, margins);
</P><P>			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
</P><P>			// Data min/max
			me.beforeDataLimits();
			me.determineDataLimits();
			me.afterDataLimits();
</P><P>			// Ticks
			me.beforeBuildTicks();
			me.buildTicks();
			me.afterBuildTicks();
</P><P>			me.beforeTickToLabelConversion();
			me.convertTicksToLabels();
			me.afterTickToLabelConversion();
</P><P>			// Tick Rotation
			me.beforeCalculateTickRotation();
			me.calculateTickRotation();
			me.afterCalculateTickRotation();
			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();
</P><P>			return me.minSize;
</P><P>		},
		afterUpdate: function() {
			helpers.callCallback(this.options.afterUpdate, [this]);
		},
</P><P>		//
</P><P>		beforeSetDimensions: function() {
			helpers.callCallback(this.options.beforeSetDimensions, [this]);
		},
		setDimensions: function() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;
</P><P>				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}
</P><P>			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;
		},
		afterSetDimensions: function() {
			helpers.callCallback(this.options.afterSetDimensions, [this]);
		},
</P><P>		// Data limits
		beforeDataLimits: function() {
			helpers.callCallback(this.options.beforeDataLimits, [this]);
		},
		determineDataLimits: helpers.noop,
		afterDataLimits: function() {
			helpers.callCallback(this.options.afterDataLimits, [this]);
		},
</P><P>		//
		beforeBuildTicks: function() {
			helpers.callCallback(this.options.beforeBuildTicks, [this]);
		},
		buildTicks: helpers.noop,
		afterBuildTicks: function() {
			helpers.callCallback(this.options.afterBuildTicks, [this]);
		},
</P><P>		beforeTickToLabelConversion: function() {
			helpers.callCallback(this.options.beforeTickToLabelConversion, [this]);
		},
		convertTicksToLabels: function() {
			var me = this;
			// Convert ticks to strings
			me.ticks = me.ticks.map(function(numericalTick, index, ticks) {
					if (me.options.ticks.userCallback) {
						return me.options.ticks.userCallback(numericalTick, index, ticks);
					}
					return me.options.ticks.callback(numericalTick, index, ticks);
				},
				me);
		},
		afterTickToLabelConversion: function() {
			helpers.callCallback(this.options.afterTickToLabelConversion, [this]);
		},
</P><P>		//
</P><P>		beforeCalculateTickRotation: function() {
			helpers.callCallback(this.options.beforeCalculateTickRotation, [this]);
		},
		calculateTickRotation: function() {
			var me = this;
			var context = me.ctx;
			var globalDefaults = Chart.defaults.global;
			var optionTicks = me.options.ticks;
</P><P>			//Get the width of each grid by calculating the difference
			//between x offsets between 0 and 1.
			var tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);
			var tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);
			var tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);
			var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
			context.font = tickLabelFont;
</P><P>			var firstWidth = context.measureText(me.ticks[0]).width;
			var lastWidth = context.measureText(me.ticks[me.ticks.length - 1]).width;
			var firstRotated;
</P><P>			me.labelRotation = optionTicks.minRotation || 0;
			me.paddingRight = 0;
			me.paddingLeft = 0;
</P><P>			if (me.options.display) {
				if (me.isHorizontal()) {
					me.paddingRight = lastWidth / 2 + 3;
					me.paddingLeft = firstWidth / 2 + 3;
</P><P>					if (!me.longestTextCache) {
						me.longestTextCache = {};
					}
					var originalLabelWidth = helpers.longestText(context, tickLabelFont, me.ticks, me.longestTextCache);
					var labelWidth = originalLabelWidth;
					var cosRotation;
					var sinRotation;
</P><P>					// Allow 3 pixels x2 padding either side for label readability
					// only the index matters for a dataset scale, but we want a consistent interface between scales
					var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;
</P><P>					//Max label rotation can be set or default to 90 - also act as a loop counter
					while (labelWidth &gt; tickWidth &amp;&amp; me.labelRotation &lt; optionTicks.maxRotation) {
						cosRotation = Math.cos(helpers.toRadians(me.labelRotation));
						sinRotation = Math.sin(helpers.toRadians(me.labelRotation));
</P><P>						firstRotated = cosRotation * firstWidth;
</P><P>						// We're right aligning the text now.
						if (firstRotated + tickFontSize / 2 &gt; me.yLabelWidth) {
							me.paddingLeft = firstRotated + tickFontSize / 2;
						}
</P><P>						me.paddingRight = tickFontSize / 2;
</P><P>						if (sinRotation * originalLabelWidth &gt; me.maxHeight) {
							// go back one step
							me.labelRotation--;
							break;
						}
</P><P>						me.labelRotation++;
						labelWidth = cosRotation * originalLabelWidth;
					}
				}
			}
</P><P>			if (me.margins) {
				me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
				me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
			}
		},
		afterCalculateTickRotation: function() {
			helpers.callCallback(this.options.afterCalculateTickRotation, [this]);
		},
</P><P>		//
</P><P>		beforeFit: function() {
			helpers.callCallback(this.options.beforeFit, [this]);
		},
		fit: function() {
			var me = this;
			// Reset
			var minSize = me.minSize = {
				width: 0,
				height: 0
			};
</P><P>			var opts = me.options;
			var globalDefaults = Chart.defaults.global;
			var tickOpts = opts.ticks;
			var scaleLabelOpts = opts.scaleLabel;
			var display = opts.display;
			var isHorizontal = me.isHorizontal();
</P><P>			var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			var tickFontStyle = helpers.getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
			var tickFontFamily = helpers.getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
			var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
</P><P>			var scaleLabelFontSize = helpers.getValueOrDefault(scaleLabelOpts.fontSize, globalDefaults.defaultFontSize);
			var scaleLabelFontStyle = helpers.getValueOrDefault(scaleLabelOpts.fontStyle, globalDefaults.defaultFontStyle);
			var scaleLabelFontFamily = helpers.getValueOrDefault(scaleLabelOpts.fontFamily, globalDefaults.defaultFontFamily);
			var scaleLabelFont = helpers.fontString(scaleLabelFontSize, scaleLabelFontStyle, scaleLabelFontFamily);
</P><P>			var tickMarkLength = opts.gridLines.tickMarkLength;
</P><P>			// Width
			if (isHorizontal) {
				// subtract the margins to line up with the chartArea if we are a full width scale
				minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
			} else {
				minSize.width = display ? tickMarkLength : 0;
			}
</P><P>			// height
			if (isHorizontal) {
				minSize.height = display ? tickMarkLength : 0;
			} else {
				minSize.height = me.maxHeight; // fill all the height
			}
</P><P>			// Are we showing a title for the scale?
			if (scaleLabelOpts.display &amp;&amp; display) {
				if (isHorizontal) {
					minSize.height += (scaleLabelFontSize * 1.5);
				} else {
					minSize.width += (scaleLabelFontSize * 1.5);
				}
			}
</P><P>			if (tickOpts.display &amp;&amp; display) {
				// Don't bother fitting the ticks if we are not showing them
				if (!me.longestTextCache) {
					me.longestTextCache = {};
				}
</P><P>				var largestTextWidth = helpers.longestText(me.ctx, tickLabelFont, me.ticks, me.longestTextCache);
				var tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);
				var lineSpace = tickFontSize * 0.5;
</P><P>				if (isHorizontal) {
					// A horizontal axis is more constrained by the height.
					me.longestLabelWidth = largestTextWidth;
</P><P>					// TODO - improve this calculation
					var labelHeight = (Math.sin(helpers.toRadians(me.labelRotation)) * me.longestLabelWidth) + (tickFontSize * tallestLabelHeightInLines) + (lineSpace * tallestLabelHeightInLines);
</P><P>					minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);
					me.ctx.font = tickLabelFont;
</P><P>					var firstLabelWidth = me.ctx.measureText(me.ticks[0]).width;
					var lastLabelWidth = me.ctx.measureText(me.ticks[me.ticks.length - 1]).width;
</P><P>					// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated
					// by the font height
					var cosRotation = Math.cos(helpers.toRadians(me.labelRotation));
					var sinRotation = Math.sin(helpers.toRadians(me.labelRotation));
					me.paddingLeft = me.labelRotation !== 0 ? (cosRotation * firstLabelWidth) + 3 : firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
					me.paddingRight = me.labelRotation !== 0 ? (sinRotation * (tickFontSize / 2)) + 3 : lastLabelWidth / 2 + 3; // when rotated
				} else {
					// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first
					var maxLabelWidth = me.maxWidth - minSize.width;
</P><P>					// Account for padding
					var mirror = tickOpts.mirror;
					if (!mirror) {
						largestTextWidth += me.options.ticks.padding;
					} else {
						// If mirrored text is on the inside so don't expand
						largestTextWidth = 0;
					}
</P><P>					if (largestTextWidth &lt; maxLabelWidth) {
						// We don't need all the room
						minSize.width += largestTextWidth;
					} else {
						// Expand to max size
						minSize.width = me.maxWidth;
					}
</P><P>					me.paddingTop = tickFontSize / 2;
					me.paddingBottom = tickFontSize / 2;
				}
			}
</P><P>			if (me.margins) {
				me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
				me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
				me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
				me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
			}
</P><P>			me.width = minSize.width;
			me.height = minSize.height;
</P><P>		},
		afterFit: function() {
			helpers.callCallback(this.options.afterFit, [this]);
		},
</P><P>		// Shared Methods
		isHorizontal: function() {
			return this.options.position === &quot;top&quot; || this.options.position === &quot;bottom&quot;;
		},
		isFullWidth: function() {
			return (this.options.fullWidth);
		},
</P><P>		// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
		getRightValue: function getRightValue(rawValue) {
			// Null and undefined values first
			if (rawValue === null || typeof(rawValue) === 'undefined') {
				return NaN;
			}
			// isNaN(object) returns true, so make sure NaN is checking for a number
			if (typeof(rawValue) === 'number' &amp;&amp; isNaN(rawValue)) {
				return NaN;
			}
			// If it is in fact an object, dive in one more level
			if (typeof(rawValue) === &quot;object&quot;) {
				if ((rawValue instanceof Date) || (rawValue.isValid)) {
					return rawValue;
				} else {
					return getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);
				}
			}
</P><P>			// Value is good, return it
			return rawValue;
		},
</P><P>		// Used to get the value to display in the tooltip for the data at the given index
		// function getLabelForIndex(index, datasetIndex)
		getLabelForIndex: helpers.noop,
</P><P>		// Used to get data value locations.  Value can either be an index or a numerical value
		getPixelForValue: helpers.noop,
</P><P>		// Used to get the data value from a given pixel. This is the inverse of getPixelForValue
		getValueForPixel: helpers.noop,
</P><P>		// Used for tick location, should
		getPixelForTick: function(index, includeOffset) {
			var me = this;
			if (me.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
				var pixel = (tickWidth * index) + me.paddingLeft;
</P><P>				if (includeOffset) {
					pixel += tickWidth / 2;
				}
</P><P>				var finalVal = me.left + Math.round(pixel);
				finalVal += me.isFullWidth() ? me.margins.left : 0;
				return finalVal;
			} else {
				var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
				return me.top + (index * (innerHeight / (me.ticks.length - 1)));
			}
		},
</P><P>		// Utility for getting the pixel location of a percentage of scale
		getPixelForDecimal: function(decimal /*, includeOffset*/ ) {
			var me = this;
			if (me.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var valueOffset = (innerWidth * decimal) + me.paddingLeft;
</P><P>				var finalVal = me.left + Math.round(valueOffset);
				finalVal += me.isFullWidth() ? me.margins.left : 0;
				return finalVal;
			} else {
				return me.top + (decimal * me.height);
			}
		},
</P><P>		getBasePixel: function() {
			var me = this;
			var min = me.min;
			var max = me.max;
</P><P>			return me.getPixelForValue(
				me.beginAtZero? 0:
				min &lt; 0 &amp;&amp; max &lt; 0? max :
				min &gt; 0 &amp;&amp; max &gt; 0? min :
				0);
		},
</P><P>		// Actualy draw the scale on the canvas
		// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
		draw: function(chartArea) {
			var me = this;
			var options = me.options;
			if (!options.display) {
				return;
			}
</P><P>			var context = me.ctx;
			var globalDefaults = Chart.defaults.global;
			var optionTicks = options.ticks;
			var gridLines = options.gridLines;
			var scaleLabel = options.scaleLabel;
</P><P>			var isRotated = me.labelRotation !== 0;
			var skipRatio;
			var useAutoskipper = optionTicks.autoSkip;
			var isHorizontal = me.isHorizontal();
</P><P>			// figure out the maximum number of gridlines to show
			var maxTicks;
			if (optionTicks.maxTicksLimit) {
				maxTicks = optionTicks.maxTicksLimit;
			}
</P><P>			var tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
			var tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);
			var tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);
			var tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);
			var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
			var tl = gridLines.tickMarkLength;
</P><P>			var scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
			var scaleLabelFontSize = helpers.getValueOrDefault(scaleLabel.fontSize, globalDefaults.defaultFontSize);
			var scaleLabelFontStyle = helpers.getValueOrDefault(scaleLabel.fontStyle, globalDefaults.defaultFontStyle);
			var scaleLabelFontFamily = helpers.getValueOrDefault(scaleLabel.fontFamily, globalDefaults.defaultFontFamily);
			var scaleLabelFont = helpers.fontString(scaleLabelFontSize, scaleLabelFontStyle, scaleLabelFontFamily);
</P><P>			var labelRotationRadians = helpers.toRadians(me.labelRotation);
			var cosRotation = Math.cos(labelRotationRadians);
			var sinRotation = Math.sin(labelRotationRadians);
			var longestRotatedLabel = me.longestLabelWidth * cosRotation;
			var rotatedLabelHeight = tickFontSize * sinRotation;
</P><P>			// Make sure we draw text in the correct color and font
			context.fillStyle = tickFontColor;
</P><P>			var itemsToDraw = [];
</P><P>			if (isHorizontal) {
				skipRatio = false;
</P><PRE>               // Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation
               // See #2584
               if (isRotated) {
                   longestRotatedLabel /= 2;
               }
</PRE><P>				if ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length &gt; (me.width - (me.paddingLeft + me.paddingRight))) {
					skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));
				}
</P><P>				// if they defined a max number of optionTicks,
				// increase skipRatio until that number is met
				if (maxTicks &amp;&amp; me.ticks.length &gt; maxTicks) {
					while (!skipRatio || me.ticks.length / (skipRatio || 1) &gt; maxTicks) {
						if (!skipRatio) {
							skipRatio = 1;
						}
						skipRatio += 1;
					}
				}
</P><P>				if (!useAutoskipper) {
					skipRatio = false;
				}
			}
</P><P>
			var xTickStart = options.position === &quot;right&quot; ? me.left : me.right - tl;
			var xTickEnd = options.position === &quot;right&quot; ? me.left + tl : me.right;
			var yTickStart = options.position === &quot;bottom&quot; ? me.top : me.bottom - tl;
			var yTickEnd = options.position === &quot;bottom&quot; ? me.top + tl : me.bottom;
</P><P>			helpers.each(me.ticks, function(label, index) {
				// If the callback returned a null or undefined value, do not draw this line
				if (label === undefined || label === null) {
					return;
				}
</P><P>				var isLastTick = me.ticks.length === index + 1;
</P><P>				// Since we always show the last tick,we need may need to hide the last shown one before
				var shouldSkip = (skipRatio &gt; 1 &amp;&amp; index % skipRatio &gt; 0) || (index % skipRatio === 0 &amp;&amp; index + skipRatio &gt;= me.ticks.length);
				if (shouldSkip &amp;&amp; !isLastTick || (label === undefined || label === null)) {
					return;
				}
</P><P>				var lineWidth, lineColor;
				if (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {
					// Draw the first index specially
					lineWidth = gridLines.zeroLineWidth;
					lineColor = gridLines.zeroLineColor;
				} else  {
					lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);
					lineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);
				}
</P><P>				// Common properties
				var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
				var textAlign, textBaseline = 'middle';
</P><P>				if (isHorizontal) {
					if (!isRotated) {
						textBaseline = options.position === 'top' ? 'bottom' : 'top';
					}
</P><P>					textAlign = isRotated ? 'right' : 'center';
</P><P>					var xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines
					labelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)
					labelY = (isRotated) ? me.top + 12 : options.position === 'top' ? me.bottom - tl : me.top + tl;
</P><P>					tx1 = tx2 = x1 = x2 = xLineValue;
					ty1 = yTickStart;
					ty2 = yTickEnd;
					y1 = chartArea.top;
					y2 = chartArea.bottom;
				} else {
					if (options.position === 'left') {
						if (optionTicks.mirror) {
							labelX = me.right + optionTicks.padding;
							textAlign = 'left';
						} else {
							labelX = me.right - optionTicks.padding;
							textAlign = 'right';
						}
					} else {
						// right side
						if (optionTicks.mirror) {
							labelX = me.left - optionTicks.padding;
							textAlign = 'right';
						} else {
							labelX = me.left + optionTicks.padding;
							textAlign = 'left';
						}
					}
</P><P>					var yLineValue = me.getPixelForTick(index); // xvalues for grid lines
					yLineValue += helpers.aliasPixel(lineWidth);
					labelY = me.getPixelForTick(index, gridLines.offsetGridLines);
</P><P>					tx1 = xTickStart;
					tx2 = xTickEnd;
					x1 = chartArea.left;
					x2 = chartArea.right;
					ty1 = ty2 = y1 = y2 = yLineValue;
				}
</P><P>				itemsToDraw.push({
					tx1: tx1,
					ty1: ty1,
					tx2: tx2,
					ty2: ty2,
					x1: x1,
					y1: y1,
					x2: x2,
					y2: y2,
					labelX: labelX,
					labelY: labelY,
					glWidth: lineWidth,
					glColor: lineColor,
					rotation: -1 * labelRotationRadians,
					label: label,
					textBaseline: textBaseline,
					textAlign: textAlign
				});
			});
</P><P>			// Draw all of the tick labels, tick marks, and grid lines at the correct places
			helpers.each(itemsToDraw, function(itemToDraw) {
				if (gridLines.display) {
					context.lineWidth = itemToDraw.glWidth;
					context.strokeStyle = itemToDraw.glColor;
</P><P>					context.beginPath();
</P><P>					if (gridLines.drawTicks) {
						context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
						context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
					}
</P><P>					if (gridLines.drawOnChartArea) {
						context.moveTo(itemToDraw.x1, itemToDraw.y1);
						context.lineTo(itemToDraw.x2, itemToDraw.y2);
					}
</P><P>					context.stroke();
				}
</P><P>				if (optionTicks.display) {
					context.save();
					context.translate(itemToDraw.labelX, itemToDraw.labelY);
					context.rotate(itemToDraw.rotation);
					context.font = tickLabelFont;
					context.textBaseline = itemToDraw.textBaseline;
					context.textAlign = itemToDraw.textAlign;
</P><P>					var label = itemToDraw.label;
					if (helpers.isArray(label)) {
						for (var i = 0, y = 0; i &lt; label.length; ++i) {
							// We just make sure the multiline element is a string here..
							context.fillText(<I> + label[i], 0, y);</I>
							// apply same lineSpacing as calculated @ L#320
							y += (tickFontSize * 1.5);
						}
					} else {
						context.fillText(label, 0, 0);
					}
					context.restore();
				}
			});
</P><P>			if (scaleLabel.display) {
				// Draw the scale label
				var scaleLabelX;
				var scaleLabelY;
				var rotation = 0;
</P><P>				if (isHorizontal) {
					scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
					scaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFontSize / 2) : me.top + (scaleLabelFontSize / 2);
				} else {
					var isLeft = options.position === 'left';
					scaleLabelX = isLeft ? me.left + (scaleLabelFontSize / 2) : me.right - (scaleLabelFontSize / 2);
					scaleLabelY = me.top + ((me.bottom - me.top) / 2);
					rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
				}
</P><P>				context.save();
				context.translate(scaleLabelX, scaleLabelY);
				context.rotate(rotation);
				context.textAlign = 'center';
				context.textBaseline = 'middle';
				context.fillStyle = scaleLabelFontColor; // render in correct colour
				context.font = scaleLabelFont;
				context.fillText(scaleLabel.labelString, 0, 0);
				context.restore();
			}
</P><P>			if (gridLines.drawBorder) {
				// Draw the line at the edge of the axis
				context.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);
				context.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);
				var x1 = me.left,
					x2 = me.right,
					y1 = me.top,
					y2 = me.bottom;
</P><P>				var aliasPixel = helpers.aliasPixel(context.lineWidth);
				if (isHorizontal) {
					y1 = y2 = options.position === 'top' ? me.bottom : me.top;
					y1 += aliasPixel;
					y2 += aliasPixel;
				} else {
					x1 = x2 = options.position === 'left' ? me.right : me.left;
					x1 += aliasPixel;
					x2 += aliasPixel;
				}
</P><P>				context.beginPath();
				context.moveTo(x1, y1);
				context.lineTo(x2, y2);
				context.stroke();
			}
		}
	});
};
</P><P>},{}],31:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.scaleService = {
		// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
		// use the new chart options to grab the correct scale
		constructors: {},
		// Use a registration function so that we can move to an ES6 map when we no longer need to support
		// old browsers
</P><P>		// Scale config defaults
		defaults: {},
		registerScaleType: function(type, scaleConstructor, defaults) {
			this.constructors[type] = scaleConstructor;
			this.defaults[type] = helpers.clone(defaults);
		},
		getScaleConstructor: function(type) {
			return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
		},
		getScaleDefaults: function(type) {
			// Return the scale defaults merged with the global settings so that we always use the latest ones
			return this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};
		},
		updateScaleDefaults: function(type, additions) {
			var defaults = this.defaults;
			if (defaults.hasOwnProperty(type)) {
				defaults[type] = helpers.extend(defaults[type], additions);
			}
		},
		addScalesToLayout: function(chartInstance) {
			// Adds each scale to the chart.boxes array to be sized accordingly
			helpers.each(chartInstance.scales, function(scale) {
				Chart.layoutService.addBox(chartInstance, scale);
			});
		}
	};
};
},{}],32:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.defaults.global.title = {
		display: false,
		position: 'top',
		fullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)
</P><P>		fontStyle: 'bold',
		padding: 10,
</P><P>		// actual title
		text: 
	};
</P><P>	var noop = helpers.noop;
	Chart.Title = Chart.Element.extend({
</P><P>		initialize: function(config) {
			var me = this;
			helpers.extend(me, config);
			me.options = helpers.configMerge(Chart.defaults.global.title, config.options);
</P><P>			// Contains hit boxes for each dataset (in dataset order)
			me.legendHitBoxes = [];
		},
</P><P>		// These methods are ordered by lifecyle. Utilities then follow.
</P><P>		beforeUpdate: function () {
			var chartOpts = this.chart.options;
			if (chartOpts &amp;&amp; chartOpts.title) {
				this.options = helpers.configMerge(Chart.defaults.global.title, chartOpts.title);
			}
		},
		update: function(maxWidth, maxHeight, margins) {
			var me = this;
</P><P>			// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
			me.beforeUpdate();
</P><P>			// Absorb the master measurements
			me.maxWidth = maxWidth;
			me.maxHeight = maxHeight;
			me.margins = margins;
</P><P>			// Dimensions
			me.beforeSetDimensions();
			me.setDimensions();
			me.afterSetDimensions();
			// Labels
			me.beforeBuildLabels();
			me.buildLabels();
			me.afterBuildLabels();
</P><P>			// Fit
			me.beforeFit();
			me.fit();
			me.afterFit();
			//
			me.afterUpdate();
</P><P>			return me.minSize;
</P><P>		},
		afterUpdate: noop,
</P><P>		//
</P><P>		beforeSetDimensions: noop,
		setDimensions: function() {
			var me = this;
			// Set the unconstrained dimension before label rotation
			if (me.isHorizontal()) {
				// Reset position before calculating rotation
				me.width = me.maxWidth;
				me.left = 0;
				me.right = me.width;
			} else {
				me.height = me.maxHeight;
</P><P>				// Reset position before calculating rotation
				me.top = 0;
				me.bottom = me.height;
			}
</P><P>			// Reset padding
			me.paddingLeft = 0;
			me.paddingTop = 0;
			me.paddingRight = 0;
			me.paddingBottom = 0;
</P><P>			// Reset minSize
			me.minSize = {
				width: 0,
				height: 0
			};
		},
		afterSetDimensions: noop,
</P><P>		//
</P><P>		beforeBuildLabels: noop,
		buildLabels: noop,
		afterBuildLabels: noop,
</P><P>		//
</P><P>		beforeFit: noop,
		fit: function() {
</P><P>			var me = this,
				ctx = me.ctx,
				valueOrDefault = helpers.getValueOrDefault,
				opts = me.options,
				globalDefaults = Chart.defaults.global,
				display = opts.display,
				fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),
				minSize = me.minSize;
</P><P>			if (me.isHorizontal()) {
				minSize.width = me.maxWidth; // fill all the width
				minSize.height = display ? fontSize + (opts.padding * 2) : 0;
			} else {
				minSize.width = display ? fontSize + (opts.padding * 2) : 0;
				minSize.height = me.maxHeight; // fill all the height
			}
</P><P>			me.width = minSize.width;
			me.height = minSize.height;
</P><P>		},
		afterFit: noop,
</P><P>		// Shared Methods
		isHorizontal: function() {
			var pos = this.options.position;
			return pos === &quot;top&quot; || pos === &quot;bottom&quot;;
		},
</P><P>		// Actualy draw the title block on the canvas
		draw: function() {
			var me = this,
				ctx = me.ctx,
				valueOrDefault = helpers.getValueOrDefault,
				opts = me.options,
				globalDefaults = Chart.defaults.global;
</P><P>			if (opts.display) {
				var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),
					fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),
					fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),
					titleFont = helpers.fontString(fontSize, fontStyle, fontFamily),
					rotation = 0,
					titleX,
					titleY,
					top = me.top,
					left = me.left,
					bottom = me.bottom,
					right = me.right;
</P><P>				ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
				ctx.font = titleFont;
</P><P>				// Horizontal
				if (me.isHorizontal()) {
					titleX = left + ((right - left) / 2); // midpoint of the width
					titleY = top + ((bottom - top) / 2); // midpoint of the height
				} else {
					titleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);
					titleY = top + ((bottom - top) / 2);
					rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
				}
</P><P>				ctx.save();
				ctx.translate(titleX, titleY);
				ctx.rotate(rotation);
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText(opts.text, 0, 0);
				ctx.restore();
			}
		}
	});
</P><P>	// Register the title plugin
	Chart.plugins.register({
		beforeInit: function(chartInstance) {
			var opts = chartInstance.options;
			var titleOpts = opts.title;
</P><P>			if (titleOpts) {
				chartInstance.titleBlock = new Chart.Title({
					ctx: chartInstance.chart.ctx,
					options: titleOpts,
					chart: chartInstance
				});
</P><P>				Chart.layoutService.addBox(chartInstance, chartInstance.titleBlock);
			}
		}
	});
};
</P><P>},{}],33:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	Chart.defaults.global.tooltips = {
		enabled: true,
		custom: null,
		mode: 'single',
		backgroundColor: &quot;rgba(0,0,0,0.8)&quot;,
		titleFontStyle: &quot;bold&quot;,
		titleSpacing: 2,
		titleMarginBottom: 6,
		titleFontColor: &quot;#fff&quot;,
		titleAlign: &quot;left&quot;,
		bodySpacing: 2,
		bodyFontColor: &quot;#fff&quot;,
		bodyAlign: &quot;left&quot;,
		footerFontStyle: &quot;bold&quot;,
		footerSpacing: 2,
		footerMarginTop: 6,
		footerFontColor: &quot;#fff&quot;,
		footerAlign: &quot;left&quot;,
		yPadding: 6,
		xPadding: 6,
		yAlign : 'center',
		xAlign : 'center',
		caretSize: 5,
		cornerRadius: 6,
		multiKeyBackground: '#fff',
		callbacks: {
			// Args are: (tooltipItems, data)
			beforeTitle: helpers.noop,
			title: function(tooltipItems, data) {
				// Pick first xLabel for now
				var title = <I>;</I>
				var labels = data.labels;
				var labelCount = labels ? labels.length : 0;
</P><P>				if (tooltipItems.length &gt; 0) {
					var item = tooltipItems[0];
</P><P>					if (item.xLabel) {
						title = item.xLabel;
					} else if (labelCount &gt; 0 &amp;&amp; item.index &lt; labelCount) {
						title = labels[item.index];
					}
				}
</P><P>				return title;
			},
			afterTitle: helpers.noop,
</P><P>			// Args are: (tooltipItems, data)
			beforeBody: helpers.noop,
</P><P>			// Args are: (tooltipItem, data)
			beforeLabel: helpers.noop,
			label: function(tooltipItem, data) {
				var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || <I>;</I>
				return datasetLabel + ': ' + tooltipItem.yLabel;
			},
			labelColor: function(tooltipItem, chartInstance) {
				var meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);
				var activeElement = meta.data[tooltipItem.index];
				var view = activeElement._view;
				return {
					borderColor: view.borderColor,
					backgroundColor: view.backgroundColor
				};
			},
			afterLabel: helpers.noop,
</P><P>			// Args are: (tooltipItems, data)
			afterBody: helpers.noop,
</P><P>			// Args are: (tooltipItems, data)
			beforeFooter: helpers.noop,
			footer: helpers.noop,
			afterFooter: helpers.noop
		}
	};
</P><P>	// Helper to push or concat based on if the 2nd parameter is an array or not
	function pushOrConcat(base, toPush) {
		if (toPush) {
			if (helpers.isArray(toPush)) {
				//base = base.concat(toPush);
				Array.prototype.push.apply(base, toPush);
			} else {
				base.push(toPush);
			}
		}
</P><P>		return base;
	}
</P><P>	function getAveragePosition(elements) {
		if (!elements.length) {
			return false;
		}
</P><P>		var i, len;
		var xPositions = [];
		var yPositions = [];
</P><P>		for (i = 0, len = elements.length; i &lt; len; ++i) {
			var el = elements[i];
			if (el &amp;&amp; el.hasValue()){
				var pos = el.tooltipPosition();
				xPositions.push(pos.x);
				yPositions.push(pos.y);
			}
		}
</P><P>		var x = 0,
			y = 0;
		for (i = 0, len - xPositions.length; i &lt; len; ++i) {
			x += xPositions[i];
			y += yPositions[i];
		}
</P><P>		return {
			x: Math.round(x / xPositions.length),
			y: Math.round(y / xPositions.length)
		};
	}
</P><P>	// Private helper to create a tooltip iteam model
	// @param element : the chart element (point, arc, bar) to create the tooltip item for
	// @return : new tooltip item
	function createTooltipItem(element) {
		var xScale = element._xScale;
		var yScale = element._yScale || element._scale; // handle radar || polarArea charts
		var index = element._index,
			datasetIndex = element._datasetIndex;
</P><P>		return {
			xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : <I>,</I>
			yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : <I>,</I>
			index: index,
			datasetIndex: datasetIndex
		};
	}
</P><P>	Chart.Tooltip = Chart.Element.extend({
		initialize: function() {
			var me = this;
			var globalDefaults = Chart.defaults.global;
			var tooltipOpts = me._options;
			var getValueOrDefault = helpers.getValueOrDefault;
</P><P>			helpers.extend(me, {
				_model: {
					// Positioning
					xPadding: tooltipOpts.xPadding,
					yPadding: tooltipOpts.yPadding,
					xAlign : tooltipOpts.yAlign,
					yAlign : tooltipOpts.xAlign,
</P><P>					// Body
					bodyFontColor: tooltipOpts.bodyFontColor,
					_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
					_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
					_bodyAlign: tooltipOpts.bodyAlign,
					bodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
					bodySpacing: tooltipOpts.bodySpacing,
</P><P>					// Title
					titleFontColor: tooltipOpts.titleFontColor,
					_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
					_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
					titleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
					_titleAlign: tooltipOpts.titleAlign,
					titleSpacing: tooltipOpts.titleSpacing,
					titleMarginBottom: tooltipOpts.titleMarginBottom,
</P><P>					// Footer
					footerFontColor: tooltipOpts.footerFontColor,
					_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
					_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
					footerFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
					_footerAlign: tooltipOpts.footerAlign,
					footerSpacing: tooltipOpts.footerSpacing,
					footerMarginTop: tooltipOpts.footerMarginTop,
</P><P>					// Appearance
					caretSize: tooltipOpts.caretSize,
					cornerRadius: tooltipOpts.cornerRadius,
					backgroundColor: tooltipOpts.backgroundColor,
					opacity: 0,
					legendColorBackground: tooltipOpts.multiKeyBackground
				}
			});
		},
</P><P>		// Get the title
		// Args are: (tooltipItem, data)
		getTitle: function() {
			var me = this;
			var opts = me._options;
			var callbacks = opts.callbacks;
</P><P>			var beforeTitle = callbacks.beforeTitle.apply(me, arguments),
				title = callbacks.title.apply(me, arguments),
				afterTitle = callbacks.afterTitle.apply(me, arguments);
</P><P>			var lines = [];
			lines = pushOrConcat(lines, beforeTitle);
			lines = pushOrConcat(lines, title);
			lines = pushOrConcat(lines, afterTitle);
</P><P>			return lines;
		},
</P><P>		// Args are: (tooltipItem, data)
		getBeforeBody: function() {
			var lines = this._options.callbacks.beforeBody.apply(this, arguments);
			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
		},
</P><P>		// Args are: (tooltipItem, data)
		getBody: function(tooltipItems, data) {
			var me = this;
			var callbacks = me._options.callbacks;
			var bodyItems = [];
</P><P>			helpers.each(tooltipItems, function(tooltipItem) {
				var bodyItem = {
					before: [],
					lines: [],
					after: []
				};
				pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
				pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
				pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));
</P><P>				bodyItems.push(bodyItem);
			});
</P><P>			return bodyItems;
		},
</P><P>		// Args are: (tooltipItem, data)
		getAfterBody: function() {
			var lines = this._options.callbacks.afterBody.apply(this, arguments);
			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
		},
</P><P>		// Get the footer and beforeFooter and afterFooter lines
		// Args are: (tooltipItem, data)
		getFooter: function() {
			var me = this;
			var callbacks = me._options.callbacks;
</P><P>			var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
			var footer = callbacks.footer.apply(me, arguments);
			var afterFooter = callbacks.afterFooter.apply(me, arguments);
</P><P>			var lines = [];
			lines = pushOrConcat(lines, beforeFooter);
			lines = pushOrConcat(lines, footer);
			lines = pushOrConcat(lines, afterFooter);
</P><P>			return lines;
		},
</P><P>		update: function(changed) {
			var me = this;
			var opts = me._options;
			var model = me._model;
			var active = me._active;
</P><P>			var data = me._data;
			var chartInstance = me._chartInstance;
</P><P>			var i, len;
</P><P>			if (active.length) {
				model.opacity = 1;
</P><P>				var labelColors = [],
					tooltipPosition = getAveragePosition(active);
</P><P>				var tooltipItems = [];
				for (i = 0, len = active.length; i &lt; len; ++i) {
					tooltipItems.push(createTooltipItem(active[i]));
				}
</P><P>				// If the user provided a sorting function, use it to modify the tooltip items
				if (opts.itemSort) {
					tooltipItems = tooltipItems.sort(opts.itemSort);
				}
</P><P>				// If there is more than one item, show color items
				if (active.length &gt; 1) {
					helpers.each(tooltipItems, function(tooltipItem) {
						labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance));
					});
				}
</P><P>				// Build the Text Lines
				helpers.extend(model, {
					title: me.getTitle(tooltipItems, data),
					beforeBody: me.getBeforeBody(tooltipItems, data),
					body: me.getBody(tooltipItems, data),
					afterBody: me.getAfterBody(tooltipItems, data),
					footer: me.getFooter(tooltipItems, data),
					x: Math.round(tooltipPosition.x),
					y: Math.round(tooltipPosition.y),
					caretPadding: helpers.getValueOrDefault(tooltipPosition.padding, 2),
					labelColors: labelColors
				});
</P><P>				// We need to determine alignment of
				var tooltipSize = me.getTooltipSize(model);
				me.determineAlignment(tooltipSize); // Smart Tooltip placement to stay on the canvas
</P><P>				helpers.extend(model, me.getBackgroundPoint(model, tooltipSize));
			} else {
				me._model.opacity = 0;
			}
</P><P>			if (changed &amp;&amp; opts.custom) {
				opts.custom.call(me, model);
			}
</P><P>			return me;
		},
		getTooltipSize: function getTooltipSize(vm) {
			var ctx = this._chart.ctx;
</P><P>			var size = {
				height: vm.yPadding * 2, // Tooltip Padding
				width: 0
			};
</P><P>			// Count of all lines in the body
			var body = vm.body;
			var combinedBodyLength = body.reduce(function(count, bodyItem) {
				return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
			}, 0);
			combinedBodyLength += vm.beforeBody.length + vm.afterBody.length;
</P><P>			var titleLineCount = vm.title.length;
			var footerLineCount = vm.footer.length;
			var titleFontSize = vm.titleFontSize,
				bodyFontSize = vm.bodyFontSize,
				footerFontSize = vm.footerFontSize;
</P><P>			size.height += titleLineCount * titleFontSize; // Title Lines
			size.height += (titleLineCount - 1) * vm.titleSpacing; // Title Line Spacing
			size.height += titleLineCount ? vm.titleMarginBottom : 0; // Title's bottom Margin
			size.height += combinedBodyLength * bodyFontSize; // Body Lines
			size.height += combinedBodyLength ? (combinedBodyLength - 1) * vm.bodySpacing : 0; // Body Line Spacing
			size.height += footerLineCount ? vm.footerMarginTop : 0; // Footer Margin
			size.height += footerLineCount * (footerFontSize); // Footer Lines
			size.height += footerLineCount ? (footerLineCount - 1) * vm.footerSpacing : 0; // Footer Line Spacing
</P><P>			// Title width
			var widthPadding = 0;
			var maxLineWidth = function(line) {
				size.width = Math.max(size.width, ctx.measureText(line).width + widthPadding);
			};
</P><P>			ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
			helpers.each(vm.title, maxLineWidth);
</P><P>			// Body width
			ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
			helpers.each(vm.beforeBody.concat(vm.afterBody), maxLineWidth);
</P><P>			// Body lines may include some extra width due to the color box
			widthPadding = body.length &gt; 1 ? (bodyFontSize + 2) : 0;
			helpers.each(body, function(bodyItem) {
				helpers.each(bodyItem.before, maxLineWidth);
				helpers.each(bodyItem.lines, maxLineWidth);
				helpers.each(bodyItem.after, maxLineWidth);
			});
</P><P>			// Reset back to 0
			widthPadding = 0;
</P><P>			// Footer width
			ctx.font = helpers.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
			helpers.each(vm.footer, maxLineWidth);
</P><P>			// Add padding
			size.width += 2 * vm.xPadding;
</P><P>			return size;
		},
		determineAlignment: function determineAlignment(size) {
			var me = this;
			var model = me._model;
			var chart = me._chart;
			var chartArea = me._chartInstance.chartArea;
</P><P>			if (model.y &lt; size.height) {
				model.yAlign = 'top';
			} else if (model.y &gt; (chart.height - size.height)) {
				model.yAlign = 'bottom';
			}
</P><P>			var lf, rf; // functions to determine left, right alignment
			var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
			var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
			var midX = (chartArea.left + chartArea.right) / 2;
			var midY = (chartArea.top + chartArea.bottom) / 2;
</P><P>			if (model.yAlign === 'center') {
				lf = function(x) {
					return x &lt;= midX;
				};
				rf = function(x) {
					return x &gt; midX;
				};
			} else {
				lf = function(x) {
					return x &lt;= (size.width / 2);
				};
				rf = function(x) {
					return x &gt;= (chart.width - (size.width / 2));
				};
			}
</P><P>			olf = function(x) {
				return x + size.width &gt; chart.width;
			};
			orf = function(x) {
				return x - size.width &lt; 0;
			};
			yf = function(y) {
				return y &lt;= midY ? 'top' : 'bottom';
			};
</P><P>			if (lf(model.x)) {
				model.xAlign = 'left';
</P><P>				// Is tooltip too wide and goes over the right side of the chart.?
				if (olf(model.x)) {
					model.xAlign = 'center';
					model.yAlign = yf(model.y);
				}
			} else if (rf(model.x)) {
				model.xAlign = 'right';
</P><P>				// Is tooltip too wide and goes outside left edge of canvas?
				if (orf(model.x)) {
					model.xAlign = 'center';
					model.yAlign = yf(model.y);
				}
			}
		},
		getBackgroundPoint: function getBackgroundPoint(vm, size) {
			// Background Position
			var pt = {
				x: vm.x,
				y: vm.y
			};
</P><P>			var caretSize = vm.caretSize,
				caretPadding = vm.caretPadding,
				cornerRadius = vm.cornerRadius,
				xAlign = vm.xAlign,
				yAlign = vm.yAlign,
				paddingAndSize = caretSize + caretPadding,
				radiusAndPadding = cornerRadius + caretPadding;
</P><P>			if (xAlign === 'right') {
				pt.x -= size.width;
			} else if (xAlign === 'center') {
				pt.x -= (size.width / 2);
			}
</P><P>			if (yAlign === 'top') {
				pt.y += paddingAndSize;
			} else if (yAlign === 'bottom') {
				pt.y -= size.height + paddingAndSize;
			} else {
				pt.y -= (size.height / 2);
			}
</P><P>			if (yAlign === 'center') {
				if (xAlign === 'left') {
					pt.x += paddingAndSize;
				} else if (xAlign === 'right') {
					pt.x -= paddingAndSize;
				}
			} else {
				if (xAlign === 'left') {
					pt.x -= radiusAndPadding;
				} else if (xAlign === 'right') {
					pt.x += radiusAndPadding;
				}
			}
</P><P>			return pt;
		},
		drawCaret: function drawCaret(tooltipPoint, size, opacity, caretPadding) {
			var vm = this._view;
			var ctx = this._chart.ctx;
			var x1, x2, x3;
			var y1, y2, y3;
			var caretSize = vm.caretSize;
			var cornerRadius = vm.cornerRadius;
			var xAlign = vm.xAlign,
				yAlign = vm.yAlign;
			var ptX = tooltipPoint.x,
				ptY = tooltipPoint.y;
			var width = size.width,
				height = size.height;
</P><P>			if (yAlign === 'center') {
				// Left or right side
				if (xAlign === 'left') {
					x1 = ptX;
					x2 = x1 - caretSize;
					x3 = x1;
				} else {
					x1 = ptX + width;
					x2 = x1 + caretSize;
					x3 = x1;
				}
</P><P>				y2 = ptY + (height / 2);
				y1 = y2 - caretSize;
				y3 = y2 + caretSize;
			} else {
				if (xAlign === 'left') {
					x1 = ptX + cornerRadius;
					x2 = x1 + caretSize;
					x3 = x2 + caretSize;
				} else if (xAlign === 'right') {
					x1 = ptX + width - cornerRadius;
					x2 = x1 - caretSize;
					x3 = x2 - caretSize;
				} else {
					x2 = ptX + (width / 2);
					x1 = x2 - caretSize;
					x3 = x2 + caretSize;
				}
</P><P>				if (yAlign === 'top') {
					y1 = ptY;
					y2 = y1 - caretSize;
					y3 = y1;
				} else {
					y1 = ptY + height;
					y2 = y1 + caretSize;
					y3 = y1;
				}
			}
</P><P>			var bgColor = helpers.color(vm.backgroundColor);
			ctx.fillStyle = bgColor.alpha(opacity * bgColor.alpha()).rgbString();
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.lineTo(x3, y3);
			ctx.closePath();
			ctx.fill();
		},
		drawTitle: function drawTitle(pt, vm, ctx, opacity) {
			var title = vm.title;
</P><P>			if (title.length) {
				ctx.textAlign = vm._titleAlign;
				ctx.textBaseline = &quot;top&quot;;
</P><P>				var titleFontSize = vm.titleFontSize,
					titleSpacing = vm.titleSpacing;
</P><P>				var titleFontColor = helpers.color(vm.titleFontColor);
				ctx.fillStyle = titleFontColor.alpha(opacity * titleFontColor.alpha()).rgbString();
				ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
</P><P>				var i, len;
				for (i = 0, len = title.length; i &lt; len; ++i) {
					ctx.fillText(title[i], pt.x, pt.y);
					pt.y += titleFontSize + titleSpacing; // Line Height and spacing
</P><P>					if (i + 1 === title.length) {
						pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
					}
				}
			}
		},
		drawBody: function drawBody(pt, vm, ctx, opacity) {
			var bodyFontSize = vm.bodyFontSize;
			var bodySpacing = vm.bodySpacing;
			var body = vm.body;
</P><P>			ctx.textAlign = vm._bodyAlign;
			ctx.textBaseline = &quot;top&quot;;
</P><P>			var bodyFontColor = helpers.color(vm.bodyFontColor);
			var textColor = bodyFontColor.alpha(opacity * bodyFontColor.alpha()).rgbString();
			ctx.fillStyle = textColor;
			ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
</P><P>			// Before Body
			var xLinePadding = 0;
			var fillLineOfText = function(line) {
				ctx.fillText(line, pt.x + xLinePadding, pt.y);
				pt.y += bodyFontSize + bodySpacing;
			};
</P><P>			// Before body lines
			helpers.each(vm.beforeBody, fillLineOfText);
</P><P>			var drawColorBoxes = body.length &gt; 1;
			xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;
</P><P>			// Draw body lines now
			helpers.each(body, function(bodyItem, i) {
				helpers.each(bodyItem.before, fillLineOfText);
</P><P>				helpers.each(bodyItem.lines, function(line) {
					// Draw Legend-like boxes if needed
					if (drawColorBoxes) {
						// Fill a white rect so that colours merge nicely if the opacity is &lt; 1
						ctx.fillStyle = helpers.color(vm.legendColorBackground).alpha(opacity).rgbaString();
						ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
</P><P>						// Border
						ctx.strokeStyle = helpers.color(vm.labelColors[i].borderColor).alpha(opacity).rgbaString();
						ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
</P><P>						// Inner square
						ctx.fillStyle = helpers.color(vm.labelColors[i].backgroundColor).alpha(opacity).rgbaString();
						ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
</P><P>						ctx.fillStyle = textColor;
					}
</P><P>					fillLineOfText(line);
				});
</P><P>				helpers.each(bodyItem.after, fillLineOfText);
			});
</P><P>			// Reset back to 0 for after body
			xLinePadding = 0;
</P><P>			// After body lines
			helpers.each(vm.afterBody, fillLineOfText);
			pt.y -= bodySpacing; // Remove last body spacing
		},
		drawFooter: function drawFooter(pt, vm, ctx, opacity) {
			var footer = vm.footer;
</P><P>			if (footer.length) {
				pt.y += vm.footerMarginTop;
</P><P>				ctx.textAlign = vm._footerAlign;
				ctx.textBaseline = &quot;top&quot;;
</P><P>				var footerFontColor = helpers.color(vm.footerFontColor);
				ctx.fillStyle = footerFontColor.alpha(opacity * footerFontColor.alpha()).rgbString();
				ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
</P><P>				helpers.each(footer, function(line) {
					ctx.fillText(line, pt.x, pt.y);
					pt.y += vm.footerFontSize + vm.footerSpacing;
				});
			}
		},
		draw: function draw() {
			var ctx = this._chart.ctx;
			var vm = this._view;
</P><P>			if (vm.opacity === 0) {
				return;
			}
</P><P>			var tooltipSize = this.getTooltipSize(vm);
			var pt = {
				x: vm.x,
				y: vm.y
			};
</P><P>			// IE11/Edge does not like very small opacities, so snap to 0
			var opacity = Math.abs(vm.opacity &lt; 1e-3) ? 0 : vm.opacity;
</P><P>			if (this._options.enabled) {
				// Draw Background
				var bgColor = helpers.color(vm.backgroundColor);
				ctx.fillStyle = bgColor.alpha(opacity * bgColor.alpha()).rgbString();
				helpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);
				ctx.fill();
</P><P>				// Draw Caret
				this.drawCaret(pt, tooltipSize, opacity, vm.caretPadding);
</P><P>				// Draw Title, Body, and Footer
				pt.x += vm.xPadding;
				pt.y += vm.yPadding;
</P><P>				// Titles
				this.drawTitle(pt, vm, ctx, opacity);
</P><P>				// Body
				this.drawBody(pt, vm, ctx, opacity);
</P><P>				// Footer
				this.drawFooter(pt, vm, ctx, opacity);
			}
		}
	});
};
</P><P>},{}],34:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart, moment) {
</P><PRE> var helpers = Chart.helpers,
   globalOpts = Chart.defaults.global;
</PRE><PRE> globalOpts.elements.arc = {
   backgroundColor: globalOpts.defaultColor,
   borderColor: &quot;#fff&quot;,
   borderWidth: 2
 };
</PRE><PRE> Chart.elements.Arc = Chart.Element.extend({
   inLabelRange: function(mouseX) {
     var vm = this._view;
</PRE><PRE>     if (vm) {
       return (Math.pow(mouseX - vm.x, 2) &lt; Math.pow(vm.radius + vm.hoverRadius, 2));
     } else {
       return false;
     }
   },
   inRange: function(chartX, chartY) {
     var vm = this._view;
</PRE><PRE>     if (vm) {
       var pointRelativePosition = helpers.getAngleFromPoint(vm, {
           x: chartX,
           y: chartY
         }),
         angle = pointRelativePosition.angle,
         distance = pointRelativePosition.distance;
</PRE><PRE>       //Sanitise angle range
       var startAngle = vm.startAngle;
       var endAngle = vm.endAngle;
       while (endAngle &lt; startAngle) {
         endAngle += 2.0 * Math.PI;
       }
       while (angle &gt; endAngle) {
         angle -= 2.0 * Math.PI;
       }
       while (angle &lt; startAngle) {
         angle += 2.0 * Math.PI;
       }
</PRE><PRE>       //Check if within the range of the open/close angle
       var betweenAngles = (angle &gt;= startAngle &amp;&amp; angle &lt;= endAngle),
         withinRadius = (distance &gt;= vm.innerRadius &amp;&amp; distance &lt;= vm.outerRadius);
</PRE><PRE>       return (betweenAngles &amp;&amp; withinRadius);
     } else {
       return false;
     }
   },
   tooltipPosition: function() {
     var vm = this._view;
</PRE><PRE>     var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),
       rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
     return {
       x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
       y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
     };
   },
   draw: function() {
</PRE><PRE>     var ctx = this._chart.ctx,
       vm = this._view,
       sA = vm.startAngle,
       eA = vm.endAngle;
</PRE><PRE>     ctx.beginPath();
</PRE><PRE>     ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
     ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
</PRE><PRE>     ctx.closePath();
     ctx.strokeStyle = vm.borderColor;
     ctx.lineWidth = vm.borderWidth;
</PRE><PRE>     ctx.fillStyle = vm.backgroundColor;
</PRE><PRE>     ctx.fill();
     ctx.lineJoin = 'bevel';
</PRE><PRE>     if (vm.borderWidth) {
       ctx.stroke();
     }
   }
 });
</PRE><P>};
</P><P>},{}],35:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
	var globalDefaults = Chart.defaults.global;
</P><P>	Chart.defaults.global.elements.line = {
		tension: 0.4,
		backgroundColor: globalDefaults.defaultColor,
		borderWidth: 3,
		borderColor: globalDefaults.defaultColor,
		borderCapStyle: 'butt',
		borderDash: [],
		borderDashOffset: 0.0,
		borderJoinStyle: 'miter',
		fill: true // do we fill in the area between the line and its base axis
	};
</P><P>	Chart.elements.Line = Chart.Element.extend({
		lineToNextPoint: function(previousPoint, point, nextPoint, skipHandler, previousSkipHandler) {
			var me = this;
			var ctx = me._chart.ctx;
			var spanGaps = me._view ? me._view.spanGaps : false;
</P><P>			if (point._view.skip &amp;&amp; !spanGaps) {
				skipHandler.call(me, previousPoint, point, nextPoint);
			} else if (previousPoint._view.skip &amp;&amp; !spanGaps) {
				previousSkipHandler.call(me, previousPoint, point, nextPoint);
			} else if (point._view.tension === 0) {
				ctx.lineTo(point._view.x, point._view.y);
			} else {
				// Line between points
				ctx.bezierCurveTo(
					previousPoint._view.controlPointNextX,
					previousPoint._view.controlPointNextY,
					point._view.controlPointPreviousX,
					point._view.controlPointPreviousY,
					point._view.x,
					point._view.y
				);
			}
		},
</P><P>		draw: function() {
			var me = this;
</P><P>			var vm = me._view;
			var ctx = me._chart.ctx;
			var first = me._children[0];
			var last = me._children[me._children.length - 1];
</P><P>			function loopBackToStart(drawLineToCenter) {
				if (!first._view.skip &amp;&amp; !last._view.skip) {
					// Draw a bezier line from last to first
					ctx.bezierCurveTo(
						last._view.controlPointNextX,
						last._view.controlPointNextY,
						first._view.controlPointPreviousX,
						first._view.controlPointPreviousY,
						first._view.x,
						first._view.y
					);
				} else if (drawLineToCenter) {
					// Go to center
					ctx.lineTo(me._view.scaleZero.x, me._view.scaleZero.y);
				}
			}
</P><P>			ctx.save();
</P><P>			// If we had points and want to fill this line, do so.
			if (me._children.length &gt; 0 &amp;&amp; vm.fill) {
				// Draw the background first (so the border is always on top)
				ctx.beginPath();
</P><P>				helpers.each(me._children, function(point, index) {
					var previous = helpers.previousItem(me._children, index);
					var next = helpers.nextItem(me._children, index);
</P><P>					// First point moves to it's starting position no matter what
					if (index === 0) {
						if (me._loop) {
							ctx.moveTo(vm.scaleZero.x, vm.scaleZero.y);
						} else {
							ctx.moveTo(point._view.x, vm.scaleZero);
						}
</P><P>						if (point._view.skip) {
							if (!me._loop) {
								ctx.moveTo(next._view.x, me._view.scaleZero);
							}
						} else {
							ctx.lineTo(point._view.x, point._view.y);
						}
					} else {
						me.lineToNextPoint(previous, point, next, function(previousPoint, point, nextPoint) {
							if (me._loop) {
								// Go to center
								ctx.lineTo(me._view.scaleZero.x, me._view.scaleZero.y);
							} else {
								ctx.lineTo(previousPoint._view.x, me._view.scaleZero);
								ctx.moveTo(nextPoint._view.x, me._view.scaleZero);
							}
						}, function(previousPoint, point) {
							// If we skipped the last point, draw a line to ourselves so that the fill is nice
							ctx.lineTo(point._view.x, point._view.y);
						});
					}
				}, me);
</P><P>				// For radial scales, loop back around to the first point
				if (me._loop) {
					loopBackToStart(true);
				} else {
					//Round off the line by going to the base of the chart, back to the start, then fill.
					ctx.lineTo(me._children[me._children.length - 1]._view.x, vm.scaleZero);
					ctx.lineTo(me._children[0]._view.x, vm.scaleZero);
				}
</P><P>				ctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;
				ctx.closePath();
				ctx.fill();
			}
</P><P>			var globalOptionLineElements = globalDefaults.elements.line;
			// Now draw the line between all the points with any borders
			ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
</P><P>			// IE 9 and 10 do not support line dash
			if (ctx.setLineDash) {
				ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
			}
</P><P>			ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
			ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
			ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
			ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
			ctx.beginPath();
</P><P>			helpers.each(me._children, function(point, index) {
				var previous = helpers.previousItem(me._children, index);
				var next = helpers.nextItem(me._children, index);
</P><P>				if (index === 0) {
					ctx.moveTo(point._view.x, point._view.y);
				} else {
					me.lineToNextPoint(previous, point, next, function(previousPoint, point, nextPoint) {
						ctx.moveTo(nextPoint._view.x, nextPoint._view.y);
					}, function(previousPoint, point) {
						// If we skipped the last point, move up to our point preventing a line from being drawn
						ctx.moveTo(point._view.x, point._view.y);
					});
				}
			}, me);
</P><P>			if (me._loop &amp;&amp; me._children.length &gt; 0) {
				loopBackToStart();
			}
</P><P>			ctx.stroke();
			ctx.restore();
		}
	});
};
},{}],36:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers,
		globalOpts = Chart.defaults.global,
		defaultColor = globalOpts.defaultColor;
</P><P>	globalOpts.elements.point = {
		radius: 3,
		pointStyle: 'circle',
		backgroundColor: defaultColor,
		borderWidth: 1,
		borderColor: defaultColor,
		// Hover
		hitRadius: 1,
		hoverRadius: 4,
		hoverBorderWidth: 1
	};
</P><P>	Chart.elements.Point = Chart.Element.extend({
		inRange: function(mouseX, mouseY) {
			var vm = this._view;
			return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) &lt; Math.pow(vm.hitRadius + vm.radius, 2)) : false;
		},
		inLabelRange: function(mouseX) {
			var vm = this._view;
			return vm ? (Math.pow(mouseX - vm.x, 2) &lt; Math.pow(vm.radius + vm.hitRadius, 2)) : false;
		},
		tooltipPosition: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y,
				padding: vm.radius + vm.borderWidth
			};
		},
		draw: function() {
			var vm = this._view;
			var ctx = this._chart.ctx;
			var pointStyle = vm.pointStyle;
			var radius = vm.radius;
			var x = vm.x;
			var y = vm.y;
			var type, edgeLength, xOffset, yOffset, height, size;
</P><P>			if (vm.skip) {
				return;
			}
</P><P>			if (typeof pointStyle === 'object') {
				type = pointStyle.toString();
				if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
					ctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);
					return;
				}
			}
</P><P>			if (isNaN(radius) || radius &lt;= 0) {
				return;
			}
</P><P>			ctx.strokeStyle = vm.borderColor || defaultColor;
			ctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);
			ctx.fillStyle = vm.backgroundColor || defaultColor;
</P><P>			switch (pointStyle) {
			// Default includes circle
			default:
				ctx.beginPath();
				ctx.arc(x, y, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.fill();
				break;
			case 'triangle':
				ctx.beginPath();
				edgeLength = 3 * radius / Math.sqrt(3);
				height = edgeLength * Math.sqrt(3) / 2;
				ctx.moveTo(x - edgeLength / 2, y + height / 3);
				ctx.lineTo(x + edgeLength / 2, y + height / 3);
				ctx.lineTo(x, y - 2 * height / 3);
				ctx.closePath();
				ctx.fill();
				break;
			case 'rect':
				size = 1 / Math.SQRT2 * radius;
				ctx.fillRect(x - size, y - size, 2 * size,  2 * size);
				ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
				break;
			case 'rectRot':
				size = 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.moveTo(x - size, y);
				ctx.lineTo(x, y + size);
				ctx.lineTo(x + size, y);
				ctx.lineTo(x, y - size);
				ctx.closePath();
				ctx.fill();
				break;
			case 'cross':
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case 'crossRot':
				ctx.beginPath();
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case 'star':
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case 'line':
				ctx.beginPath();
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case 'dash':
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			}
</P><P>			ctx.stroke();
		}
	});
};
</P><P>},{}],37:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers,
		globalOpts = Chart.defaults.global;
</P><P>	globalOpts.elements.rectangle = {
		backgroundColor: globalOpts.defaultColor,
		borderWidth: 0,
		borderColor: globalOpts.defaultColor,
		borderSkipped: 'bottom'
	};
</P><P>	Chart.elements.Rectangle = Chart.Element.extend({
		draw: function() {
			var ctx = this._chart.ctx;
			var vm = this._view;
</P><P>			var halfWidth = vm.width / 2,
				leftX = vm.x - halfWidth,
				rightX = vm.x + halfWidth,
				top = vm.base - (vm.base - vm.y),
				halfStroke = vm.borderWidth / 2;
</P><P>			// Canvas doesn't allow us to stroke inside the width so we can
			// adjust the sizes to fit if we're setting a stroke on the line
			if (vm.borderWidth) {
				leftX += halfStroke;
				rightX -= halfStroke;
				top += halfStroke;
			}
</P><P>			ctx.beginPath();
			ctx.fillStyle = vm.backgroundColor;
			ctx.strokeStyle = vm.borderColor;
			ctx.lineWidth = vm.borderWidth;
</P><P>			// Corner points, from bottom-left to bottom-right clockwise
			// | 1 2 |
			// | 0 3 |
			var corners = [
				[leftX, vm.base],
				[leftX, top],
				[rightX, top],
				[rightX, vm.base]
			];
</P><P>			// Find first (starting) corner with fallback to 'bottom' 
			var borders = ['bottom', 'left', 'top', 'right'];
			var startCorner = borders.indexOf(vm.borderSkipped, 0);
			if (startCorner === -1)
				startCorner = 0;
</P><P>			function cornerAt(index) {
				return corners[(startCorner + index) % 4];
			}
</P><P>			// Draw rectangle from 'startCorner'
			ctx.moveTo.apply(ctx, cornerAt(0));
			for (var i = 1; i &lt; 4; i++)
				ctx.lineTo.apply(ctx, cornerAt(i));
</P><P>			ctx.fill();
			if (vm.borderWidth) {
				ctx.stroke();
			}
		},
		height: function() {
			var vm = this._view;
			return vm.base - vm.y;
		},
		inRange: function(mouseX, mouseY) {
			var vm = this._view;
			return vm ? 
					(vm.y &lt; vm.base ? 
						(mouseX &gt;= vm.x - vm.width / 2 &amp;&amp; mouseX &lt;= vm.x + vm.width / 2) &amp;&amp; (mouseY &gt;= vm.y &amp;&amp; mouseY &lt;= vm.base) :
						(mouseX &gt;= vm.x - vm.width / 2 &amp;&amp; mouseX &lt;= vm.x + vm.width / 2) &amp;&amp; (mouseY &gt;= vm.base &amp;&amp; mouseY &lt;= vm.y)) :
					false;
		},
		inLabelRange: function(mouseX) {
			var vm = this._view;
			return vm ? (mouseX &gt;= vm.x - vm.width / 2 &amp;&amp; mouseX &lt;= vm.x + vm.width / 2) : false;
		},
		tooltipPosition: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		}
	});
</P><P>};
},{}],38:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
	// Default config for a category scale
	var defaultConfig = {
		position: &quot;bottom&quot;
	};
</P><P>	var DatasetScale = Chart.Scale.extend({
		// Implement this so that 
		determineDataLimits: function() {
			var me = this;
			me.minIndex = 0;
			me.maxIndex = me.chart.data.labels.length - 1;
			var findIndex;
</P><P>			if (me.options.ticks.min !== undefined) {
				// user specified min value
				findIndex = helpers.indexOf(me.chart.data.labels, me.options.ticks.min);
				me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
			}
</P><P>			if (me.options.ticks.max !== undefined) {
				// user specified max value
				findIndex = helpers.indexOf(me.chart.data.labels, me.options.ticks.max);
				me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
			}
</P><P>			me.min = me.chart.data.labels[me.minIndex];
			me.max = me.chart.data.labels[me.maxIndex];
		},
</P><P>		buildTicks: function(index) {
			var me = this;
			// If we are viewing some subset of labels, slice the original array
			me.ticks = (me.minIndex === 0 &amp;&amp; me.maxIndex === me.chart.data.labels.length - 1) ? me.chart.data.labels : me.chart.data.labels.slice(me.minIndex, me.maxIndex + 1);
		},
</P><P>		getLabelForIndex: function(index, datasetIndex) {
			return this.ticks[index];
		},
</P><P>		// Used to get data value locations.  Value can either be an index or a numerical value
		getPixelForValue: function(value, index, datasetIndex, includeOffset) {
			var me = this;
			// 1 is added because we need the length but we have the indexes
			var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
</P><P>			if (me.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var valueWidth = innerWidth / offsetAmt;
				var widthOffset = (valueWidth * (index - me.minIndex)) + me.paddingLeft;
</P><P>				if (me.options.gridLines.offsetGridLines &amp;&amp; includeOffset) {
					widthOffset += (valueWidth / 2);
				}
</P><P>				return me.left + Math.round(widthOffset);
			} else {
				var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
				var valueHeight = innerHeight / offsetAmt;
				var heightOffset = (valueHeight * (index - me.minIndex)) + me.paddingTop;
</P><P>				if (me.options.gridLines.offsetGridLines &amp;&amp; includeOffset) {
					heightOffset += (valueHeight / 2);
				}
</P><P>				return me.top + Math.round(heightOffset);
			}
		},
		getPixelForTick: function(index, includeOffset) {
			return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var value;
			var offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);
			var horz = me.isHorizontal();
			var innerDimension = horz ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);
			var valueDimension = innerDimension / offsetAmt;
</P><P>			if (me.options.gridLines.offsetGridLines) {
				pixel -= (valueDimension / 2);
			}
			pixel -= horz ? me.paddingLeft : me.paddingTop;
</P><P>			if (pixel &lt;= 0) {
				value = 0;
			} else {
				value = Math.round(pixel / valueDimension);
			}
</P><P>			return value;
		}
	});
</P><P>	Chart.scaleService.registerScaleType(&quot;category&quot;, DatasetScale, defaultConfig);
</P><P>};
},{}],39:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	var defaultConfig = {
		position: &quot;left&quot;,
		ticks: {
			callback: function(tickValue, index, ticks) {
				// If we have lots of ticks, don't use the ones
				var delta = ticks.length &gt; 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
</P><P>				// If we have a number like 2.5 as the delta, figure out how many decimal places we need
				if (Math.abs(delta) &gt; 1) {
					if (tickValue !== Math.floor(tickValue)) {
						// not an integer
						delta = tickValue - Math.floor(tickValue);
					}
				}
</P><P>				var logDelta = helpers.log10(Math.abs(delta));
				var tickString = <I>;</I></P><P>				if (tickValue !== 0) {
					var numDecimal = -1 * Math.floor(logDelta);
					numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
					tickString = tickValue.toFixed(numDecimal);
				} else {
					tickString = '0'; // never show decimal places for 0
				}
</P><P>				return tickString;
			}
		}
	};
</P><P>	var LinearScale = Chart.LinearScaleBase.extend({
		determineDataLimits: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			var chart = me.chart;
			var data = chart.data;
			var datasets = data.datasets;
			var isHorizontal = me.isHorizontal();
</P><P>			function IDMatches(meta) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}
</P><P>			// First Calculate the range
			me.min = null;
			me.max = null;
</P><P>			if (opts.stacked) {
				var valuesPerType = {};
				var hasPositiveValues = false;
				var hasNegativeValues = false;
</P><P>				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (valuesPerType[meta.type] === undefined) {
						valuesPerType[meta.type] = {
							positiveValues: [],
							negativeValues: []
						};
					}
</P><P>					// Store these per type
					var positiveValues = valuesPerType[meta.type].positiveValues;
					var negativeValues = valuesPerType[meta.type].negativeValues;
</P><P>					if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}
</P><P>							positiveValues[index] = positiveValues[index] || 0;
							negativeValues[index] = negativeValues[index] || 0;
</P><P>							if (opts.relativePoints) {
								positiveValues[index] = 100;
							} else {
								if (value &lt; 0) {
									hasNegativeValues = true;
									negativeValues[index] += value;
								} else {
									hasPositiveValues = true;
									positiveValues[index] += value;
								}
							}
						});
					}
				});
</P><P>				helpers.each(valuesPerType, function(valuesForType) {
					var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
					var minVal = helpers.min(values);
					var maxVal = helpers.max(values);
					me.min = me.min === null ? minVal : Math.min(me.min, minVal);
					me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
				});
</P><P>			} else {
				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}
</P><P>							if (me.min === null) {
								me.min = value;
							} else if (value &lt; me.min) {
								me.min = value;
							}
</P><P>							if (me.max === null) {
								me.max = value;
							} else if (value &gt; me.max) {
								me.max = value;
							}
						});
					}
				});
			}
</P><P>			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
			this.handleTickRangeOptions();
		},
		getTickLimit: function() {
			var maxTicks;
			var me = this;
			var tickOpts = me.options.ticks;
</P><P>			if (me.isHorizontal()) {
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
			} else {
				// The factor of 2 used to scale the font size has been experimentally determined.
				var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
			}
</P><P>			return maxTicks;
		},
		// Called after the ticks are built. We need 
		handleDirectionalChanges: function() {
			if (!this.isHorizontal()) {
				// We are in a vertical orientation. The top value is the highest. So reverse the array
				this.ticks.reverse();
			}
		},
		getLabelForIndex: function(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		// Utils
		getPixelForValue: function(value, index, datasetIndex, includeOffset) {
			// This must be called after fit has been run so that
			//      this.left, this.top, this.right, and this.bottom have been defined
			var me = this;
			var paddingLeft = me.paddingLeft;
			var paddingBottom = me.paddingBottom;
			var start = me.start;
</P><P>			var rightValue = +me.getRightValue(value);
			var pixel;
			var innerDimension;
			var range = me.end - start;
</P><P>			if (me.isHorizontal()) {
				innerDimension = me.width - (paddingLeft + me.paddingRight);
				pixel = me.left + (innerDimension / range * (rightValue - start));
				return Math.round(pixel + paddingLeft);
			} else {
				innerDimension = me.height - (me.paddingTop + paddingBottom);
				pixel = (me.bottom - paddingBottom) - (innerDimension / range * (rightValue - start));
				return Math.round(pixel);
			}
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var isHorizontal = me.isHorizontal();
			var paddingLeft = me.paddingLeft;
			var paddingBottom = me.paddingBottom;
			var innerDimension = isHorizontal ? me.width - (paddingLeft + me.paddingRight) : me.height - (me.paddingTop + paddingBottom);
			var offset = (isHorizontal ? pixel - me.left - paddingLeft : me.bottom - paddingBottom - pixel) / innerDimension;
			return me.start + ((me.end - me.start) * offset);
		},
		getPixelForTick: function(index, includeOffset) {
			return this.getPixelForValue(this.ticksAsNumbers[index], null, null, includeOffset);
		}
	});
	Chart.scaleService.registerScaleType(&quot;linear&quot;, LinearScale, defaultConfig);
</P><P>};
},{}],40:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers,
		noop = helpers.noop;
</P><P>	Chart.LinearScaleBase = Chart.Scale.extend({
		handleTickRangeOptions: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
</P><P>			// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
			// do nothing since that would make the chart weird. If the user really wants a weird chart
			// axis, they can manually override it
			if (tickOpts.beginAtZero) {
				var minSign = helpers.sign(me.min);
				var maxSign = helpers.sign(me.max);
</P><P>				if (minSign &lt; 0 &amp;&amp; maxSign &lt; 0) {
					// move the top up to 0
					me.max = 0;
				} else if (minSign &gt; 0 &amp;&amp; maxSign &gt; 0) {
					// move the botttom down to 0
					me.min = 0;
				}
			}
</P><P>			if (tickOpts.min !== undefined) {
				me.min = tickOpts.min;
			} else if (tickOpts.suggestedMin !== undefined) {
				me.min = Math.min(me.min, tickOpts.suggestedMin);
			}
</P><P>			if (tickOpts.max !== undefined) {
				me.max = tickOpts.max;
			} else if (tickOpts.suggestedMax !== undefined) {
				me.max = Math.max(me.max, tickOpts.suggestedMax);
			}
</P><P>			if (me.min === me.max) {
				me.max++;
</P><P>				if (!tickOpts.beginAtZero) {
					me.min--;
				}
			}
		},
		getTickLimit: noop,
		handleDirectionalChanges: noop,
</P><P>		buildTicks: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			var getValueOrDefault = helpers.getValueOrDefault;
			var isHorizontal = me.isHorizontal();
</P><P>			var ticks = me.ticks = [];
</P><P>			// Figure out what the max number of ticks we can support it is based on the size of
			// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
			// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
			// the graph
</P><P>			var maxTicks = me.getTickLimit();
</P><P>			// Make sure we always have at least 2 ticks
			maxTicks = Math.max(2, maxTicks);
</P><P>			// To get a &quot;nice&quot; value for the tick spacing, we will use the appropriately named
			// &quot;nice number&quot; algorithm. See <A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks">http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks</A>
			// for details.
</P><P>			var spacing;
			var fixedStepSizeSet = (tickOpts.fixedStepSize &amp;&amp; tickOpts.fixedStepSize &gt; 0) || (tickOpts.stepSize &amp;&amp; tickOpts.stepSize &gt; 0);
			if (fixedStepSizeSet) {
				spacing = getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize);
			} else {
				var niceRange = helpers.niceNum(me.max - me.min, false);
				spacing = helpers.niceNum(niceRange / (maxTicks - 1), true);
			}
			var niceMin = Math.floor(me.min / spacing) * spacing;
			var niceMax = Math.ceil(me.max / spacing) * spacing;
			var numSpaces = (niceMax - niceMin) / spacing;
</P><P>			// If very close to our rounded value, use it.
			if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
				numSpaces = Math.round(numSpaces);
			} else {
				numSpaces = Math.ceil(numSpaces);
			}
</P><P>			// Put the values into the ticks array
			ticks.push(tickOpts.min !== undefined ? tickOpts.min : niceMin);
			for (var j = 1; j &lt; numSpaces; ++j) {
				ticks.push(niceMin + (j * spacing));
			}
			ticks.push(tickOpts.max !== undefined ? tickOpts.max : niceMax);
</P><P>			me.handleDirectionalChanges();
</P><P>			// At this point, we need to update our max and min given the tick values since we have expanded the
			// range of the scale
			me.max = helpers.max(ticks);
			me.min = helpers.min(ticks);
</P><P>			if (tickOpts.reverse) {
				ticks.reverse();
</P><P>				me.start = me.max;
				me.end = me.min;
			} else {
				me.start = me.min;
				me.end = me.max;
			}
		},
		convertTicksToLabels: function() {
			var me = this;
			me.ticksAsNumbers = me.ticks.slice();
			me.zeroLineIndex = me.ticks.indexOf(0);
</P><P>			Chart.Scale.prototype.convertTicksToLabels.call(me);
		},
	});
};
},{}],41:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
</P><P>	var defaultConfig = {
		position: &quot;left&quot;,
</P><P>		// label settings
		ticks: {
			callback: function(value, index, arr) {
				var remain = value / (Math.pow(10, Math.floor(helpers.log10(value))));
</P><P>				if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === arr.length - 1) {
					return value.toExponential();
				} else {
					return <I>;</I>
				}
			}
		}
	};
</P><P>	var LogarithmicScale = Chart.Scale.extend({
		determineDataLimits: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			var chart = me.chart;
			var data = chart.data;
			var datasets = data.datasets;
			var getValueOrDefault = helpers.getValueOrDefault;
			var isHorizontal = me.isHorizontal();
			function IDMatches(meta) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}
</P><P>			// Calculate Range
			me.min = null;
			me.max = null;
</P><P>			if (opts.stacked) {
				var valuesPerType = {};
</P><P>				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
						if (valuesPerType[meta.type] === undefined) {
							valuesPerType[meta.type] = [];
						}
</P><P>						helpers.each(dataset.data, function(rawValue, index) {
							var values = valuesPerType[meta.type];
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}
</P><P>							values[index] = values[index] || 0;
</P><P>							if (opts.relativePoints) {
								values[index] = 100;
							} else {
								// Don't need to split positive and negative since the log scale can't handle a 0 crossing
								values[index] += value;
							}
						});
					}
				});
</P><P>				helpers.each(valuesPerType, function(valuesForType) {
					var minVal = helpers.min(valuesForType);
					var maxVal = helpers.max(valuesForType);
					me.min = me.min === null ? minVal : Math.min(me.min, minVal);
					me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
				});
</P><P>			} else {
				helpers.each(datasets, function(dataset, datasetIndex) {
					var meta = chart.getDatasetMeta(datasetIndex);
					if (chart.isDatasetVisible(datasetIndex) &amp;&amp; IDMatches(meta)) {
						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}
</P><P>							if (me.min === null) {
								me.min = value;
							} else if (value &lt; me.min) {
								me.min = value;
							}
</P><P>							if (me.max === null) {
								me.max = value;
							} else if (value &gt; me.max) {
								me.max = value;
							}
						});
					}
				});
			}
</P><P>			me.min = getValueOrDefault(tickOpts.min, me.min);
			me.max = getValueOrDefault(tickOpts.max, me.max);
</P><P>			if (me.min === me.max) {
				if (me.min !== 0 &amp;&amp; me.min !== null) {
					me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
					me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
				} else {
					me.min = 1;
					me.max = 10;
				}
			}
		},
		buildTicks: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			var getValueOrDefault = helpers.getValueOrDefault;
</P><P>			// Reset the ticks array. Later on, we will draw a grid line at these positions
			// The array simply contains the numerical value of the spots where ticks will be
			var ticks = me.ticks = [];
</P><P>			// Figure out what the max number of ticks we can support it is based on the size of
			// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
			// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
			// the graph
</P><P>			var tickVal = getValueOrDefault(tickOpts.min, Math.pow(10, Math.floor(helpers.log10(me.min))));
</P><P>			while (tickVal &lt; me.max) {
				ticks.push(tickVal);
</P><P>				var exp = Math.floor(helpers.log10(tickVal));
				var significand = Math.floor(tickVal / Math.pow(10, exp)) + 1;
</P><P>				if (significand === 10) {
					significand = 1;
					++exp;
				}
</P><P>				tickVal = significand * Math.pow(10, exp);
			}
</P><P>			var lastTick = getValueOrDefault(tickOpts.max, tickVal);
			ticks.push(lastTick);
</P><P>			if (!me.isHorizontal()) {
				// We are in a vertical orientation. The top value is the highest. So reverse the array
				ticks.reverse();
			}
</P><P>			// At this point, we need to update our max and min given the tick values since we have expanded the
			// range of the scale
			me.max = helpers.max(ticks);
			me.min = helpers.min(ticks);
</P><P>			if (tickOpts.reverse) {
				ticks.reverse();
</P><P>				me.start = me.max;
				me.end = me.min;
			} else {
				me.start = me.min;
				me.end = me.max;
			}
		},
		convertTicksToLabels: function() {
			this.tickValues = this.ticks.slice();
</P><P>			Chart.Scale.prototype.convertTicksToLabels.call(this);
		},
		// Get the correct tooltip label
		getLabelForIndex: function(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		getPixelForTick: function(index, includeOffset) {
			return this.getPixelForValue(this.tickValues[index], null, null, includeOffset);
		},
		getPixelForValue: function(value, index, datasetIndex, includeOffset) {
			var me = this;
			var innerDimension;
			var pixel;
</P><P>			var start = me.start;
			var newVal = +me.getRightValue(value);
			var range = helpers.log10(me.end) - helpers.log10(start);
			var paddingTop = me.paddingTop;
			var paddingBottom = me.paddingBottom;
			var paddingLeft = me.paddingLeft;
</P><P>			if (me.isHorizontal()) {
</P><P>				if (newVal === 0) {
					pixel = me.left + paddingLeft;
				} else {
					innerDimension = me.width - (paddingLeft + me.paddingRight);
					pixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
					pixel += paddingLeft;
				}
			} else {
				// Bottom - top since pixels increase downard on a screen
				if (newVal === 0) {
					pixel = me.top + paddingTop;
				} else {
					innerDimension = me.height - (paddingTop + paddingBottom);
					pixel = (me.bottom - paddingBottom) - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
				}
			}
</P><P>			return pixel;
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var offset;
			var range = helpers.log10(me.end) - helpers.log10(me.start);
			var value;
			var innerDimension;
</P><P>			if (me.isHorizontal()) {
				innerDimension = me.width - (me.paddingLeft + me.paddingRight);
				value = me.start * Math.pow(10, (pixel - me.left - me.paddingLeft) * range / innerDimension);
			} else {
				innerDimension = me.height - (me.paddingTop + me.paddingBottom);
				value = Math.pow(10, (me.bottom - me.paddingBottom - pixel) * range / innerDimension) / me.start;
			}
</P><P>			return value;
		}
	});
	Chart.scaleService.registerScaleType(&quot;logarithmic&quot;, LogarithmicScale, defaultConfig);
</P><P>};
},{}],42:[function(require,module,exports){
&quot;use strict&quot;;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
	var globalDefaults = Chart.defaults.global;
</P><P>	var defaultConfig = {
		display: true,
</P><P>		//Boolean - Whether to animate scaling the chart from the centre
		animate: true,
		lineArc: false,
		position: &quot;chartArea&quot;,
</P><P>		angleLines: {
			display: true,
			color: &quot;rgba(0, 0, 0, 0.1)&quot;,
			lineWidth: 1
		},
</P><P>		// label settings
		ticks: {
			//Boolean - Show a backdrop to the scale label
			showLabelBackdrop: true,
</P><P>			//String - The colour of the label backdrop
			backdropColor: &quot;rgba(255,255,255,0.75)&quot;,
</P><P>			//Number - The backdrop padding above &amp; below the label in pixels
			backdropPaddingY: 2,
</P><P>			//Number - The backdrop padding to the side of the label in pixels
			backdropPaddingX: 2
		},
</P><P>		pointLabels: {
			//Number - Point label font size in pixels
			fontSize: 10,
</P><P>			//Function - Used to convert point labels
			callback: function(label) {
				return label;
			}
		}
	};
</P><P>	var LinearRadialScale = Chart.LinearScaleBase.extend({
		getValueCount: function() {
			return this.chart.data.labels.length;
		},
		setDimensions: function() {
			var me = this;
			var opts = me.options;
			var tickOpts = opts.ticks;
			// Set the unconstrained dimension before label rotation
			me.width = me.maxWidth;
			me.height = me.maxHeight;
			me.xCenter = Math.round(me.width / 2);
			me.yCenter = Math.round(me.height / 2);
</P><P>			var minSize = helpers.min([me.height, me.width]);
			var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
		},
		determineDataLimits: function() {
			var me = this;
			var chart = me.chart;
			me.min = null;
			me.max = null;
</P><P>
			helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
				if (chart.isDatasetVisible(datasetIndex)) {
					var meta = chart.getDatasetMeta(datasetIndex);
</P><P>					helpers.each(dataset.data, function(rawValue, index) {
						var value = +me.getRightValue(rawValue);
						if (isNaN(value) || meta.data[index].hidden) {
							return;
						}
</P><P>						if (me.min === null) {
							me.min = value;
						} else if (value &lt; me.min) {
							me.min = value;
						}
</P><P>						if (me.max === null) {
							me.max = value;
						} else if (value &gt; me.max) {
							me.max = value;
						}
					});
				}
			});
</P><P>			// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
			me.handleTickRangeOptions();
		},
		getTickLimit: function() {
			var tickOpts = this.options.ticks;
			var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
		},
		convertTicksToLabels: function() {
			var me = this;
			Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);
</P><P>			// Point labels
			me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
		},
		getLabelForIndex: function(index, datasetIndex) {
			return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		fit: function() {
			/*
			 * Right, this is really confusing and there is a lot of maths going on here
			 * The gist of the problem is here: <A rel="nofollow" class="external free" href="https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9">https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9</A>
			 *
			 * Reaction: 
			 *
			 * Solution:
			 *
			 * We assume the radius of the polygon is half the size of the canvas at first
			 * at each index we check if the text overlaps.
			 *
			 * Where it does, we store that angle and that index.
			 *
			 * After finding the largest index and angle we calculate how much we need to remove
			 * from the shape radius to move the point inwards by that x.
			 *
			 * We average the left and right distances to get the maximum shape radius that can fit in the box
			 * along with labels.
			 *
			 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
			 * on each side, removing that from the size, halving it and adding the left x protrusion width.
			 *
			 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
			 * and position it in the most space efficient manner
			 *
			 * 
			 */
</P><P>			var pointLabels = this.options.pointLabels;
			var pointLabelFontSize = helpers.getValueOrDefault(pointLabels.fontSize, globalDefaults.defaultFontSize);
			var pointLabeFontStyle = helpers.getValueOrDefault(pointLabels.fontStyle, globalDefaults.defaultFontStyle);
			var pointLabeFontFamily = helpers.getValueOrDefault(pointLabels.fontFamily, globalDefaults.defaultFontFamily);
			var pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);
</P><P>			// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
			// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
			var largestPossibleRadius = helpers.min([(this.height / 2 - pointLabelFontSize - 5), this.width / 2]),
				pointPosition,
				i,
				textWidth,
				halfTextWidth,
				furthestRight = this.width,
				furthestRightIndex,
				furthestRightAngle,
				furthestLeft = 0,
				furthestLeftIndex,
				furthestLeftAngle,
				xProtrusionLeft,
				xProtrusionRight,
				radiusReductionRight,
				radiusReductionLeft,
				maxWidthRadius;
			this.ctx.font = pointLabeFont;
</P><P>			for (i = 0; i &lt; this.getValueCount(); i++) {
				// 5px to space the text slightly out - similar to what we do in the draw function.
				pointPosition = this.getPointPosition(i, largestPossibleRadius);
				textWidth = this.ctx.measureText(this.pointLabels[i] ? this.pointLabels[i] : <I>).width + 5;</I>
				if (i === 0 || i === this.getValueCount() / 2) {
					// If we're at index zero, or exactly the middle, we're at exactly the top/bottom
					// of the radar chart, so text will be aligned centrally, so we'll half it and compare
					// w/left and right text sizes
					halfTextWidth = textWidth / 2;
					if (pointPosition.x + halfTextWidth &gt; furthestRight) {
						furthestRight = pointPosition.x + halfTextWidth;
						furthestRightIndex = i;
					}
					if (pointPosition.x - halfTextWidth &lt; furthestLeft) {
						furthestLeft = pointPosition.x - halfTextWidth;
						furthestLeftIndex = i;
					}
				} else if (i &lt; this.getValueCount() / 2) {
					// Less than half the values means we'll left align the text
					if (pointPosition.x + textWidth &gt; furthestRight) {
						furthestRight = pointPosition.x + textWidth;
						furthestRightIndex = i;
					}
				} else if (i &gt; this.getValueCount() / 2) {
					// More than half the values means we'll right align the text
					if (pointPosition.x - textWidth &lt; furthestLeft) {
						furthestLeft = pointPosition.x - textWidth;
						furthestLeftIndex = i;
					}
				}
			}
</P><P>			xProtrusionLeft = furthestLeft;
			xProtrusionRight = Math.ceil(furthestRight - this.width);
</P><P>			furthestRightAngle = this.getIndexAngle(furthestRightIndex);
			furthestLeftAngle = this.getIndexAngle(furthestLeftIndex);
</P><P>			radiusReductionRight = xProtrusionRight / Math.sin(furthestRightAngle + Math.PI / 2);
			radiusReductionLeft = xProtrusionLeft / Math.sin(furthestLeftAngle + Math.PI / 2);
</P><P>			// Ensure we actually need to reduce the size of the chart
			radiusReductionRight = (helpers.isNumber(radiusReductionRight)) ? radiusReductionRight : 0;
			radiusReductionLeft = (helpers.isNumber(radiusReductionLeft)) ? radiusReductionLeft : 0;
</P><P>			this.drawingArea = Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2);
			this.setCenterPoint(radiusReductionLeft, radiusReductionRight);
		},
		setCenterPoint: function(leftMovement, rightMovement) {
			var me = this;
			var maxRight = me.width - rightMovement - me.drawingArea,
				maxLeft = leftMovement + me.drawingArea;
</P><P>			me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
			// Always vertically in the centre as the text height doesn't change
			me.yCenter = Math.round((me.height / 2) + me.top);
		},
</P><P>		getIndexAngle: function(index) {
			var angleMultiplier = (Math.PI * 2) / this.getValueCount();
			// Start from the top instead of right, so remove a quarter of the circle
</P><P>			return index * angleMultiplier - (Math.PI / 2);
		},
		getDistanceFromCenterForValue: function(value) {
			var me = this;
</P><P>			if (value === null) {
				return 0; // null always in center
			}
</P><P>			// Take into account half font size + the yPadding of the top value
			var scalingFactor = me.drawingArea / (me.max - me.min);
			if (me.options.reverse) {
				return (me.max - value) * scalingFactor;
			} else {
				return (value - me.min) * scalingFactor;
			}
		},
		getPointPosition: function(index, distanceFromCenter) {
			var me = this;
			var thisAngle = me.getIndexAngle(index);
			return {
				x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
				y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
			};
		},
		getPointPositionForValue: function(index, value) {
			return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
		},
</P><P>		getBasePosition: function() {
			var me = this;
			var min = me.min;
			var max = me.max;
</P><P>			return me.getPointPositionForValue(0,
				me.beginAtZero? 0:
				min &lt; 0 &amp;&amp; max &lt; 0? max :
				min &gt; 0 &amp;&amp; max &gt; 0? min :
				0);
		},
</P><P>		draw: function() {
			var me = this;
			var opts = me.options;
			var gridLineOpts = opts.gridLines;
			var tickOpts = opts.ticks;
			var angleLineOpts = opts.angleLines;
			var pointLabelOpts = opts.pointLabels;
			var getValueOrDefault = helpers.getValueOrDefault;
</P><P>			if (opts.display) {
				var ctx = me.ctx;
</P><P>				// Tick Font
				var tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				var tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
				var tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
				var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
</P><P>				helpers.each(me.ticks, function(label, index) {
					// Don't draw a centre value (if it is minimum)
					if (index &gt; 0 || opts.reverse) {
						var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
						var yHeight = me.yCenter - yCenterOffset;
</P><P>						// Draw circular lines around the scale
						if (gridLineOpts.display &amp;&amp; index !== 0) {
							ctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);
							ctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);
</P><P>							if (opts.lineArc) {
								// Draw circular arcs between the points
								ctx.beginPath();
								ctx.arc(me.xCenter, me.yCenter, yCenterOffset, 0, Math.PI * 2);
								ctx.closePath();
								ctx.stroke();
							} else {
								// Draw straight lines connecting each index
								ctx.beginPath();
								for (var i = 0; i &lt; me.getValueCount(); i++) {
									var pointPosition = me.getPointPosition(i, yCenterOffset);
									if (i === 0) {
										ctx.moveTo(pointPosition.x, pointPosition.y);
									} else {
										ctx.lineTo(pointPosition.x, pointPosition.y);
									}
								}
								ctx.closePath();
								ctx.stroke();
							}
						}
</P><P>						if (tickOpts.display) {
							var tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
							ctx.font = tickLabelFont;
</P><P>							if (tickOpts.showLabelBackdrop) {
								var labelWidth = ctx.measureText(label).width;
								ctx.fillStyle = tickOpts.backdropColor;
								ctx.fillRect(
									me.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,
									yHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,
									labelWidth + tickOpts.backdropPaddingX * 2,
									tickFontSize + tickOpts.backdropPaddingY * 2
								);
							}
</P><P>							ctx.textAlign = 'center';
							ctx.textBaseline = &quot;middle&quot;;
							ctx.fillStyle = tickFontColor;
							ctx.fillText(label, me.xCenter, yHeight);
						}
					}
				});
</P><P>				if (!opts.lineArc) {
					ctx.lineWidth = angleLineOpts.lineWidth;
					ctx.strokeStyle = angleLineOpts.color;
</P><P>					var outerDistance = me.getDistanceFromCenterForValue(opts.reverse ? me.min : me.max);
</P><P>					// Point Label Font
					var pointLabelFontSize = getValueOrDefault(pointLabelOpts.fontSize, globalDefaults.defaultFontSize);
					var pointLabeFontStyle = getValueOrDefault(pointLabelOpts.fontStyle, globalDefaults.defaultFontStyle);
					var pointLabeFontFamily = getValueOrDefault(pointLabelOpts.fontFamily, globalDefaults.defaultFontFamily);
					var pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);
</P><P>					for (var i = me.getValueCount() - 1; i &gt;= 0; i--) {
						if (angleLineOpts.display) {
							var outerPosition = me.getPointPosition(i, outerDistance);
							ctx.beginPath();
							ctx.moveTo(me.xCenter, me.yCenter);
							ctx.lineTo(outerPosition.x, outerPosition.y);
							ctx.stroke();
							ctx.closePath();
						}
						// Extra 3px out for some label spacing
						var pointLabelPosition = me.getPointPosition(i, outerDistance + 5);
</P><P>						// Keep this in loop since we may support array properties here
						var pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
						ctx.font = pointLabeFont;
						ctx.fillStyle = pointLabelFontColor;
</P><P>						var pointLabels = me.pointLabels,
							labelsCount = pointLabels.length,
							halfLabelsCount = pointLabels.length / 2,
							quarterLabelsCount = halfLabelsCount / 2,
							upperHalf = (i &lt; quarterLabelsCount || i &gt; labelsCount - quarterLabelsCount),
							exactQuarter = (i === quarterLabelsCount || i === labelsCount - quarterLabelsCount);
						if (i === 0) {
							ctx.textAlign = 'center';
						} else if (i === halfLabelsCount) {
							ctx.textAlign = 'center';
						} else if (i &lt; halfLabelsCount) {
							ctx.textAlign = 'left';
						} else {
							ctx.textAlign = 'right';
						}
</P><P>						// Set the correct text baseline based on outer positioning
						if (exactQuarter) {
							ctx.textBaseline = 'middle';
						} else if (upperHalf) {
							ctx.textBaseline = 'bottom';
						} else {
							ctx.textBaseline = 'top';
						}
</P><P>						ctx.fillText(pointLabels[i] ? pointLabels[i] : <I>, pointLabelPosition.x, pointLabelPosition.y);</I>
					}
				}
			}
		}
	});
	Chart.scaleService.registerScaleType(&quot;radialLinear&quot;, LinearRadialScale, defaultConfig);
</P><P>};
</P><P>},{}],43:[function(require,module,exports){
/*global window: false */
&quot;use strict&quot;;
</P><P>var moment = require(6);
moment = typeof(moment) === 'function' ? moment : window.moment;
</P><P>module.exports = function(Chart) {
</P><P>	var helpers = Chart.helpers;
	var time = {
		units: [{
			name: 'millisecond',
			steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
		}, {
			name: 'second',
			steps: [1, 2, 5, 10, 30]
		}, {
			name: 'minute',
			steps: [1, 2, 5, 10, 30]
		}, {
			name: 'hour',
			steps: [1, 2, 3, 6, 12]
		}, {
			name: 'day',
			steps: [1, 2, 5]
		}, {
			name: 'week',
			maxStep: 4
		}, {
			name: 'month',
			maxStep: 3
		}, {
			name: 'quarter',
			maxStep: 4
		}, {
			name: 'year',
			maxStep: false
		}]
	};
</P><P>	var defaultConfig = {
		position: &quot;bottom&quot;,
</P><P>		time: {
			parser: false, // false == a pattern string from <A rel="nofollow" class="external free" href="http://momentjs.com/docs/#/parsing/string-format/">http://momentjs.com/docs/#/parsing/string-format/</A> or a custom callback that converts its argument to a moment
			format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from <A rel="nofollow" class="external free" href="http://momentjs.com/docs/#/parsing/string-format/">http://momentjs.com/docs/#/parsing/string-format/</A>
			unit: false, // false == automatic or override with week, month, year, etc.
			round: false, // none, or override with week, month, year, etc.
			displayFormat: false, // DEPRECATED
			isoWeekday: false, // override week start day - see <A rel="nofollow" class="external free" href="http://momentjs.com/docs/#/get-set/iso-weekday/">http://momentjs.com/docs/#/get-set/iso-weekday/</A></P><P>			// defaults to unit's corresponding unitFormat below or override using pattern string from <A rel="nofollow" class="external free" href="http://momentjs.com/docs/#/displaying/format/">http://momentjs.com/docs/#/displaying/format/</A>
			displayFormats: {
				'millisecond': 'h:mm:ss.SSS a', // 11:20:01.123 AM,
				'second': 'h:mm:ss a', // 11:20:01 AM
				'minute': 'h:mm:ss a', // 11:20:01 AM
				'hour': 'MMM D, hA', // Sept 4, 5PM
				'day': 'll', // Sep 4 2015
				'week': 'll', // Week 46, or maybe &quot;[W]WW - YYYY&quot; ?
				'month': 'MMM YYYY', // Sept 2015
				'quarter': '[Q]Q - YYYY', // Q3
				'year': 'YYYY' // 2015
			}
		},
		ticks: {
			autoSkip: false
		}
	};
</P><P>	var TimeScale = Chart.Scale.extend({
		initialize: function() {
			if (!moment) {
				throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at <A rel="nofollow" class="external free" href="https://momentjs.com'">https://momentjs.com'</A>);
			}
</P><P>			Chart.Scale.prototype.initialize.call(this);
		},
		getLabelMoment: function(datasetIndex, index) {
			return this.labelMoments[datasetIndex][index];
		},
		getMomentStartOf: function(tick) {
			var me = this;
			if (me.options.time.unit === 'week' &amp;&amp; me.options.time.isoWeekday !== false) {
				return tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);
			} else {
				return tick.clone().startOf(me.tickUnit);
			}
		},
		determineDataLimits: function() {
			var me = this;
			me.labelMoments = [];
</P><P>			// Only parse these once. If the dataset does not have data as x,y pairs, we will use
			// these
			var scaleLabelMoments = [];
			if (me.chart.data.labels &amp;&amp; me.chart.data.labels.length &gt; 0) {
				helpers.each(me.chart.data.labels, function(label, index) {
					var labelMoment = me.parseTime(label);
</P><P>					if (labelMoment.isValid()) {
						if (me.options.time.round) {
							labelMoment.startOf(me.options.time.round);
						}
						scaleLabelMoments.push(labelMoment);
					}
				}, me);
</P><P>				me.firstTick = moment.min.call(me, scaleLabelMoments);
				me.lastTick = moment.max.call(me, scaleLabelMoments);
			} else {
				me.firstTick = null;
				me.lastTick = null;
			}
</P><P>			helpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {
				var momentsForDataset = [];
				var datasetVisible = me.chart.isDatasetVisible(datasetIndex);
</P><P>				if (typeof dataset.data[0] === 'object' &amp;&amp; dataset.data[0] !== null) {
					helpers.each(dataset.data, function(value, index) {
						var labelMoment = me.parseTime(me.getRightValue(value));
</P><P>						if (labelMoment.isValid()) {
							if (me.options.time.round) {
								labelMoment.startOf(me.options.time.round);
							}
							momentsForDataset.push(labelMoment);
</P><P>							if (datasetVisible) {
								// May have gone outside the scale ranges, make sure we keep the first and last ticks updated
								me.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;
								me.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;
							}
						}
					}, me);
				} else {
					// We have no labels. Use the ones from the scale
					momentsForDataset = scaleLabelMoments;
				}
</P><P>				me.labelMoments.push(momentsForDataset);
			}, me);
</P><P>			// Set these after we've done all the data
			if (me.options.time.min) {
				me.firstTick = me.parseTime(me.options.time.min);
			}
</P><P>			if (me.options.time.max) {
				me.lastTick = me.parseTime(me.options.time.max);
			}
</P><P>			// We will modify these, so clone for later
			me.firstTick = (me.firstTick || moment()).clone();
			me.lastTick = (me.lastTick || moment()).clone();
		},
		buildTicks: function(index) {
			var me = this;
</P><P>			me.ctx.save();
			var tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);
			var tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);
			var tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);
			var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
			me.ctx.font = tickLabelFont;
</P><P>			me.ticks = [];
			me.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step
			me.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)
</P><P>			// Set unit override if applicable
			if (me.options.time.unit) {
				me.tickUnit = me.options.time.unit || 'day';
				me.displayFormat = me.options.time.displayFormats[me.tickUnit];
				me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);
				me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);
			} else {
				// Determine the smallest needed unit of the time
				var innerWidth = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);
</P><P>				// Crude approximation of what the label length might be
				var tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);
				var tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;
				var cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));
				var sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));
				tickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
				var labelCapacity = innerWidth / (tickLabelWidth);
</P><P>				// Start as small as possible
				me.tickUnit = 'millisecond';
				me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);
				me.displayFormat = me.options.time.displayFormats[me.tickUnit];
</P><P>				var unitDefinitionIndex = 0;
				var unitDefinition = time.units[unitDefinitionIndex];
</P><P>				// While we aren't ideal and we don't have units left
				while (unitDefinitionIndex &lt; time.units.length) {
					// Can we scale this unit. If `false` we can scale infinitely
					me.unitScale = 1;
</P><P>					if (helpers.isArray(unitDefinition.steps) &amp;&amp; Math.ceil(me.scaleSizeInUnits / labelCapacity) &lt; helpers.max(unitDefinition.steps)) {
						// Use one of the prefedined steps
						for (var idx = 0; idx &lt; unitDefinition.steps.length; ++idx) {
							if (unitDefinition.steps[idx] &gt;= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {
								me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);
								break;
							}
						}
</P><P>						break;
					} else if ((unitDefinition.maxStep === false) || (Math.ceil(me.scaleSizeInUnits / labelCapacity) &lt; unitDefinition.maxStep)) {
						// We have a max step. Scale this unit
						me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));
						break;
					} else {
						// Move to the next unit up
						++unitDefinitionIndex;
						unitDefinition = time.units[unitDefinitionIndex];
</P><P>						me.tickUnit = unitDefinition.name;
						var leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);
						var trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);
						me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;
						me.displayFormat = me.options.time.displayFormats[unitDefinition.name];
					}
				}
			}
</P><P>			var roundedStart;
</P><P>			// Only round the first tick if we have no hard minimum
			if (!me.options.time.min) {
				me.firstTick = me.getMomentStartOf(me.firstTick);
				roundedStart = me.firstTick;
			} else {
				roundedStart = me.getMomentStartOf(me.firstTick);
			}
</P><P>			// Only round the last tick if we have no hard maximum
			if (!me.options.time.max) {
				var roundedEnd = me.getMomentStartOf(me.lastTick);
				if (roundedEnd.diff(me.lastTick, me.tickUnit, true) !== 0) {
					// Do not use end of because we need me to be in the next time unit
					me.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));
				}
			}
</P><P>			me.smallestLabelSeparation = me.width;
</P><P>			helpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {
				for (var i = 1; i &lt; me.labelMoments[datasetIndex].length; i++) {
					me.smallestLabelSeparation = Math.min(me.smallestLabelSeparation, me.labelMoments[datasetIndex][i].diff(me.labelMoments[datasetIndex][i - 1], me.tickUnit, true));
				}
			}, me);
</P><P>			// Tick displayFormat override
			if (me.options.time.displayFormat) {
				me.displayFormat = me.options.time.displayFormat;
			}
</P><P>			// first tick. will have been rounded correctly if options.time.min is not specified
			me.ticks.push(me.firstTick.clone());
</P><P>			// For every unit in between the first and last moment, create a moment and add it to the ticks tick
			for (var i = 1; i &lt;= me.scaleSizeInUnits; ++i) {
				var newTick = roundedStart.clone().add(i, me.tickUnit);
</P><P>				// Are we greater than the max time
				if (me.options.time.max &amp;&amp; newTick.diff(me.lastTick, me.tickUnit, true) &gt;= 0) {
					break;
				}
</P><P>				if (i % me.unitScale === 0) {
					me.ticks.push(newTick);
				}
			}
</P><P>			// Always show the right tick
			var diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);
			if (diff !== 0 || me.scaleSizeInUnits === 0) {
				// this is a weird case. If the &lt;max&gt; option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart
				// but the last tick was not rounded.
				if (me.options.time.max) {
					me.ticks.push(me.lastTick.clone());
					me.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);
				} else {
					me.ticks.push(me.lastTick.clone());
					me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);
				}
			}
</P><P>			me.ctx.restore();
		},
		// Get tooltip label
		getLabelForIndex: function(index, datasetIndex) {
			var me = this;
			var label = me.chart.data.labels &amp;&amp; index &lt; me.chart.data.labels.length ? me.chart.data.labels[index] : <I>;</I></P><P>			if (typeof me.chart.data.datasets[datasetIndex].data[0] === 'object') {
				label = me.getRightValue(me.chart.data.datasets[datasetIndex].data[index]);
			}
</P><P>			// Format nicely
			if (me.options.time.tooltipFormat) {
				label = me.parseTime(label).format(me.options.time.tooltipFormat);
			}
</P><P>			return label;
		},
		// Function to format an individual tick mark
		tickFormatFunction: function tickFormatFunction(tick, index, ticks) {
			var formattedTick = tick.format(this.displayFormat);
			var tickOpts = this.options.ticks;
			var callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);
</P><P>			if (callback) {
				return callback(formattedTick, index, ticks);
			} else {
				return formattedTick;
			}
		},
		convertTicksToLabels: function() {
			var me = this;
			me.tickMoments = me.ticks;
			me.ticks = me.ticks.map(me.tickFormatFunction, me);
		},
		getPixelForValue: function(value, index, datasetIndex, includeOffset) {
			var me = this;
			var labelMoment = value &amp;&amp; value.isValid &amp;&amp; value.isValid() ? value : me.getLabelMoment(datasetIndex, index);
</P><P>			if (labelMoment) {
				var offset = labelMoment.diff(me.firstTick, me.tickUnit, true);
</P><P>				var decimal = offset / me.scaleSizeInUnits;
</P><P>				if (me.isHorizontal()) {
					var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
					var valueWidth = innerWidth / Math.max(me.ticks.length - 1, 1);
					var valueOffset = (innerWidth * decimal) + me.paddingLeft;
</P><P>					return me.left + Math.round(valueOffset);
				} else {
					var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
					var valueHeight = innerHeight / Math.max(me.ticks.length - 1, 1);
					var heightOffset = (innerHeight * decimal) + me.paddingTop;
</P><P>					return me.top + Math.round(heightOffset);
				}
			}
		},
		getPixelForTick: function(index, includeOffset) {
			return this.getPixelForValue(this.tickMoments[index], null, null, includeOffset);
		},
		getValueForPixel: function(pixel) {
			var me = this;
			var innerDimension = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);
			var offset = (pixel - (me.isHorizontal() ? me.left + me.paddingLeft : me.top + me.paddingTop)) / innerDimension;
			offset *= me.scaleSizeInUnits;
			return me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');
		},
		parseTime: function(label) {
			var me = this;
			if (typeof me.options.time.parser === 'string') {
				return moment(label, me.options.time.parser);
			}
			if (typeof me.options.time.parser === 'function') {
				return me.options.time.parser(label);
			}
			// Date objects
			if (typeof label.getMonth === 'function' || typeof label === 'number') {
				return moment(label);
			}
			// Moment support
			if (label.isValid &amp;&amp; label.isValid()) {
				return label;
			}
			// Custom parsing (return an instance of moment)
			if (typeof me.options.time.format !== 'string' &amp;&amp; me.options.time.format.call) {
				console.warn(&quot;options.time.format is deprecated and replaced by options.time.parser. See <A rel="nofollow" class="external free" href="http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale">http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale</A>&quot;);
				return me.options.time.format(label);
			}
			// Moment format parsing
			return moment(label, me.options.time.format);
		}
	});
	Chart.scaleService.registerScaleType(&quot;time&quot;, TimeScale, defaultConfig);
</P><P>};
</P><P>},{&quot;6&quot;:6}]},{},[7])(7)
});
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
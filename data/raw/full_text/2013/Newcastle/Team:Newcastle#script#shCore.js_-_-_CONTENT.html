<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Newcastle_script_shCore_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:Newcastle/script/shCore.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Newcastle/script/shCore.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Newcastle/script/shCore.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Newcastle/script/shCore.js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Newcastle/script/shCore.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Newcastle/script/shCore.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2013.igem.org</H3><P>/**
</P><PRE>* SyntaxHighlighter
* <A href="http://alexgorbatchev.com/" class="external free" rel="nofollow">http://alexgorbatchev.com/</A>
*
* SyntaxHighlighter is donationware. If you are using it, please donate.
* <A href="http://alexgorbatchev.com/wiki/SyntaxHighlighter:Donate" class="external free" rel="nofollow">http://alexgorbatchev.com/wiki/SyntaxHighlighter:Donate</A>
*
* @version
* 2.1.382 (June 24 2010)
* 
* @copyright
* Copyright (C) 2004-2009 Alex Gorbatchev.
*
* @license
* This file is part of SyntaxHighlighter.
* 
* SyntaxHighlighter is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SyntaxHighlighter is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SyntaxHighlighter.  If not, see &lt;<A href="http://www.gnu.org/copyleft/lesser.html" class="external free" rel="nofollow">http://www.gnu.org/copyleft/lesser.html</A>&gt;.
*/
</PRE><P>//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
if (!window.SyntaxHighlighter) var SyntaxHighlighter = function() { 
</P><P>// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : <I>,</I></P><P>		/** First line number. */
		'first-line' : 1,
</P><P>		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : true,
</P><P>		/** Lines to highlight. */
		'highlight' : null,
</P><P>		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
</P><P>		/** Gets or sets tab size. */
		'tab-size' : 4,
</P><P>		/** Enables or disables gutter. */
		'gutter' : true,
</P><P>		/** Enables or disables toolbar. */
		'toolbar' : true,
</P><P>		/** Forces code view to be collapsed. */
		'collapse' : false,
</P><P>		/** Enables or disables automatic links. */
		'auto-links' : true,
</P><P>		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
</P><P>		/** Enables or disables automatic line wrapping. */
		'wrap-lines' : true,
</P><P>		'html-script' : false
	},
</P><P>	config : {
		/** Enables use of &lt;SCRIPT type=&quot;syntaxhighlighter&quot; /&gt; tags. */
		useScriptTags : true,
</P><P>		/** Path to the copy to clipboard SWF file. */
		clipboardSwf : null,
</P><P>		/** Width of an item in the toolbar. */
		toolbarItemWidth : 16,
</P><P>		/** Height of an item in the toolbar. */
		toolbarItemHeight : 16,
</P><P>		/** Blogger mode flag. */
		bloggerMode : false,
</P><P>		stripBrs : false,
</P><P>		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
</P><P>		strings : {
			expandSource : 'show source',
			viewSource : 'view source',
			copyToClipboard : 'copy to clipboard',
			copyToClipboardConfirmation : 'The code is in your clipboard now',
			print : 'print',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
</P><P>			// this is populated by the build script
			aboutDialog : '&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;<A href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" class="external free" rel="nofollow">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</A>&quot;&gt;<TITLE>About SyntaxHighlighter</TITLE></P><DIV style="text-align:center;margin-top:3em;"><DIV style="font-size:xx-large;">SyntaxHighlighter</DIV><DIV style="font-size:.75em;margin-bottom:4em;"><DIV>version 2.1.382 (June 24 2010)</DIV><DIV><A href="http://alexgorbatchev.com" target="_blank" style="color:#0099FF;text-decoration:none;">http://alexgorbatchev.com</A></DIV><DIV>If you like this script, please <A href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=2930402" style="color:#0099FF;text-decoration:none;">donate</A> to keep development active!</DIV></DIV><DIV>JavaScript code syntax highlighter.</DIV><DIV>Copyright 2004-2009 Alex Gorbatchev.</DIV></DIV>'
		},
<P>		/** If true, output will show HTML produces instead. */
		debug : false
	},
</P><P>	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		spaceWidth : null,
		printFrame : null,
		highlighters : {}
	},
</P><P>	/** This object is populated by user included external brush files. */
	brushes : {},
</P><P>	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /&quot;([^\\&quot;\n]|\\.)*&quot;/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: /&quot;([^\\&quot;]|\\.)*&quot;/g,
		multiLineSingleQuotedString	: /'([^\\']|\\.)*'/g,
		xmlComments					: /(&lt;|&lt;)!--[\s\S]*?--(&gt;|&gt;)/gm,
		url							: /&lt;\w+:\/\/[\w-.\/?%&amp;=@:;]*&gt;|\w+:\/\/[\w-.\/?%&amp;=@:;]*/g,
</P><P>		/** &lt;?= ?&gt; tags. */
		phpScriptTags 				: { left: /(&lt;|&lt;)\?=?/g, right: /\?(&gt;|&gt;)/g },
</P><P>		/** &lt;%= %&gt; tags. */
		aspScriptTags				: { left: /(&lt;|&lt;)%=?/g, right: /%(&gt;|&gt;)/g },
</P><P>		/** &lt;script&gt;&lt;/script&gt; tags. */
		scriptScriptTags			: { left: /(&lt;|&lt;)\s*script.*?(&gt;|&gt;)/gi, right: /(&lt;|&lt;)\/\s*script\s*(&gt;|&gt;)/gi }
	},
</P><P>	toolbar : {
		/**
		 * Creates new toolbar for a highlighter.
		 * @param {Highlighter} highlighter    Target highlighter.
		 */
		create : function(highlighter)
		{
			var div = document.createElement('DIV'),
				items = sh.toolbar.items
				;
</P><P>			div.className = 'toolbar';
</P><P>			for (var name in items) 
			{
				var constructor = items[name],
					command = new constructor(highlighter),
					element = command.create()
					;
</P><P>				highlighter.toolbarCommands[name] = command;
</P><P>				if (element == null)
					continue;
</P><P>				if (typeof(element) == 'string')
					element = sh.toolbar.createButton(element, highlighter.id, name);
</P><P>				element.className += 'item ' + name;
				div.appendChild(element);
			}
</P><P>			return div;
		},
</P><P>		/**
		 * Create a standard anchor button for the toolbar.
		 * @param {String} label			Label text to display.
		 * @param {String} highlighterId	Highlighter ID that this button would belong to.
		 * @param {String} commandName		Command name that would be executed.
		 * @return {Element}				Returns an 'A' element.
		 */
		createButton : function(label, highlighterId, commandName)
		{
			var a = document.createElement('a'),
				style = a.style,
				config = sh.config,
				width = config.toolbarItemWidth,
				height = config.toolbarItemHeight
				;
</P><P>			a.href = '#' + commandName;
			a.title = label;
			a.highlighterId = highlighterId;
			a.commandName = commandName;
			a.innerHTML = label;
</P><P>			if (isNaN(width) == false)
				style.width = width + 'px';
</P><P>			if (isNaN(height) == false)
				style.height = height + 'px';
</P><P>			a.onclick = function(e)
			{
				try
				{
					sh.toolbar.executeCommand(
						this, 
						e || window.event,
						this.highlighterId, 
						this.commandName
					);
				}
				catch(e)
				{
					sh.utils.alert(e.message);
				}
</P><P>				return false;
			};
</P><P>			return a;
		},
</P><P>		/**
		 * Executes a toolbar command.
		 * @param {Element}		sender  		Sender element.
		 * @param {MouseEvent}	event			Original mouse event object.
		 * @param {String}		highlighterId	Highlighter DIV element ID.
		 * @param {String}		commandName		Name of the command to execute.
		 * @return {Object} Passes out return value from command execution.
		 */
		executeCommand : function(sender, event, highlighterId, commandName, args)
		{
			var highlighter = sh.vars.highlighters[highlighterId], 
				command
				;
</P><P>			if (highlighter == null || (command = highlighter.toolbarCommands[commandName]) == null) 
				return null;
</P><P>			return command.execute(sender, event, args);
		},
</P><P>		/** Collection of toolbar items. */
		items : {
			expandSource : function(highlighter)
			{
				this.create = function()
				{
					if (highlighter.getParam('collapse') != true)
						return;
</P><P>					return sh.config.strings.expandSource;
				};
</P><P>				this.execute = function(sender, event, args)
				{
					var div = highlighter.div;
</P><P>					sender.parentNode.removeChild(sender);
					div.className = div.className.replace('collapsed', <I>);</I>
				};
			},
</P><P>			/** 
			 * Command to open a new window and display the original unformatted source code inside.
			 */
			viewSource : function(highlighter)
			{
				this.create = function()
				{
					return sh.config.strings.viewSource;
				};
</P><P>				this.execute = function(sender, event, args)
				{
					var code = sh.utils.fixInputString(highlighter.originalCode).replace(/&lt;/g, '&lt;'),
						wnd = sh.utils.popup(<I>, '_blank', 750, 400, 'location=0, resizable=1, menubar=0, scrollbars=1')</I>
						;
</P><P>					code = sh.utils.unindent(code);
</P>
					wnd.document.write('<PRE>' + code + '</PRE>');
<P>					wnd.document.close();
				};
			},
</P><P>			/**
			 * Command to copy the original source code in to the clipboard.
			 * Uses Flash method if <CODE>clipboardSwf</CODE> is configured.
			 */
			copyToClipboard : function(highlighter)
			{
				var flashDiv, flashSwf,
					highlighterId = highlighter.id
					;
</P><P>				this.create = function()
				{
					var config = sh.config;
</P><P>					// disable functionality if running locally
					if (config.clipboardSwf == null)
						return null;
</P><P>					function params(list)
					{
						var result = <I>;</I></P><P>						for (var name in list)
							result += &quot;&lt;param name='&quot; + name + &quot;' value='&quot; + list[name] + &quot;'/&gt;&quot;;
</P><P>						return result;
					};
</P><P>					function attributes(list)
					{
						var result = <I>;</I></P><P>						for (var name in list)
							result += &quot; &quot; + name + &quot;='&quot; + list[name] + &quot;'&quot;;
</P><P>						return result;
					};
</P><P>					var args1 = {
							width				: config.toolbarItemWidth,
							height				: config.toolbarItemHeight,
							id					: highlighterId + '_clipboard',
							type				: 'application/x-shockwave-flash',
							title				: sh.config.strings.copyToClipboard
						},
</P><P>						// these arguments are used in IE's &lt;param /&gt; collection
						args2 = {
							allowScriptAccess	: 'always',
							wmode				: 'transparent',
							flashVars			: 'highlighterId=' + highlighterId,
							menu				: 'false'
						},
						swf = config.clipboardSwf,
						html
					;
</P><P>					if (/msie/i.test(navigator.userAgent))
					{
						html = '&lt;object'
							+ attributes({
								classid : 'clsid:d27cdb6e-ae6d-11cf-96b8-444553540000',
								codebase : '<A href="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0'" class="external free" rel="nofollow">http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0'</A>
							})
							+ attributes(args1)
							+ '&gt;'
							+ params(args2)
							+ params({ movie : swf })
							+ '&lt;/object&gt;'
						;
					}
					else
					{
						html = '&lt;embed'
							+ attributes(args1)
							+ attributes(args2)
							+ attributes({ src : swf })
							+ '/&gt;'
						;
					}
</P><P>					flashDiv = document.createElement('div');
					flashDiv.innerHTML = html;
</P><P>					return flashDiv;
				};
</P><P>				this.execute = function(sender, event, args)
				{
					var command = args.command;
</P><P>					switch (command)
					{
						case 'get':
							var code = sh.utils.unindent(
								sh.utils.fixInputString(highlighter.originalCode)
									.replace(/&lt;/g, '&lt;')
									.replace(/&gt;/g, '&gt;')
									.replace(/&amp;/g, '&amp;')
								);
</P><P>							if(window.clipboardData)
								// will fall through to the confirmation because there isn't a break
								window.clipboardData.setData('text', code);
							else
								return sh.utils.unindent(code);
</P><P>						case 'ok':
							sh.utils.alert(sh.config.strings.copyToClipboardConfirmation);
							break;
</P><P>						case 'error':
							sh.utils.alert(args.message);
							break;
					}
				};
			},
</P><P>			/** Command to print the colored source code. */
			printSource : function(highlighter)
			{
				this.create = function()
				{
					return sh.config.strings.print;
				};
</P><P>				this.execute = function(sender, event, args)
				{
					var iframe = document.createElement('IFRAME'),
						doc = null
						;
</P><P>					// make sure there is never more than one hidden iframe created by SH
					if (sh.vars.printFrame != null)
						document.body.removeChild(sh.vars.printFrame);
</P><P>					sh.vars.printFrame = iframe;
</P><P>					// this hides the iframe
					iframe.style.cssText = 'position:absolute;width:0px;height:0px;left:-500px;top:-500px;';
</P><P>					document.body.appendChild(iframe);
					doc = iframe.contentWindow.document;
</P><P>					copyStyles(doc, window.document);
</P>
					doc.write('<DIV class="' + highlighter.div.className.replace('collapsed', '') + ' printing">' + highlighter.div.innerHTML + '</DIV>');
<P>					doc.close();
</P><P>					iframe.contentWindow.focus();
					iframe.contentWindow.print();
</P><P>					function copyStyles(destDoc, sourceDoc)
					{
						var links = sourceDoc.getElementsByTagName('link');
</P><P>						for(var i = 0; i &lt; links.length; i++)
							if(links[i].rel.toLowerCase() == 'stylesheet' &amp;&amp; /shCore\.css$/.test(links[i].href))
								destDoc.write('&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;' + links[i].href + '&quot;&gt;&lt;/link&gt;');
					};
				};
			},
</P><P>			/** Command to display the about dialog window. */
			about : function(highlighter)
			{
				this.create = function()
				{	
					return sh.config.strings.help;
				};
</P><P>				this.execute = function(sender, event)
				{	
					var wnd = sh.utils.popup(<I>, '_blank', 500, 250, 'scrollbars=0'),</I>
						doc = wnd.document
						;
</P><P>					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				};
			}
		}
	},
</P><P>	utils : {
		/**
		 * Finds an index of element in the array.
		 * @ignore
		 * @param {Object} searchElement
		 * @param {Number} fromIndex
		 * @return {Number} Returns index of element if found; -1 otherwise.
		 */
		indexOf : function(array, searchElement, fromIndex)
		{
			fromIndex = Math.max(fromIndex || 0, 0);
</P><P>			for (var i = fromIndex; i &lt; array.length; i++)
				if(array[i] == searchElement)
					return i;
</P><P>			return -1;
		},
</P><P>		/**
		 * Generates a unique element ID.
		 */
		guid : function(prefix)
		{
			return prefix + Math.round(Math.random() * 1000000).toString();
		},
</P><P>		/**
		 * Merges two objects. Values from obj2 override values in obj1.
		 * Function is NOT recursive and works only for one dimensional objects.
		 * @param {Object} obj1 First object.
		 * @param {Object} obj2 Second object.
		 * @return {Object} Returns combination of both objects.
		 */
		merge: function(obj1, obj2)
		{
			var result = {}, name;
</P><P>			for (name in obj1) 
				result[name] = obj1[name];
</P><P>			for (name in obj2) 
				result[name] = obj2[name];
</P><P>			return result;
		},
</P><P>		/**
		 * Attempts to convert string to boolean.
		 * @param {String} value Input string.
		 * @return {Boolean} Returns true if input was &quot;true&quot;, false if input was &quot;false&quot; and value otherwise.
		 */
		toBoolean: function(value)
		{
			switch (value)
			{
				case &quot;true&quot;:
					return true;
</P><P>				case &quot;false&quot;:
					return false;
			}
</P><P>			return value;
		},
</P><P>		/**
		 * Opens up a centered popup window.
		 * @param {String} url		URL to open in the window.
		 * @param {String} name		Popup name.
		 * @param {int} width		Popup width.
		 * @param {int} height		Popup height.
		 * @param {String} options	window.open() options.
		 * @return {Window}			Returns window instance.
		 */
		popup: function(url, name, width, height, options)
		{
			var x = (screen.width - width) / 2,
				y = (screen.height - height) / 2
				;
</P><P>			options +=	', left=' + x + 
						', top=' + y +
						', width=' + width +
						', height=' + height
				;
			options = options.replace(/^,/, <I>);</I></P><P>			var win = window.open(url, name, options);
			win.focus();
			return win;
		},
</P><P>		/**
		 * Adds event handler to the target object.
		 * @param {Object} obj		Target object.
		 * @param {String} type		Name of the event.
		 * @param {Function} func	Handling function.
		 */
		addEvent: function(obj, type, func)
		{
			if (obj.attachEvent) 
			{
				obj['e' + type + func] = func;
				obj[type + func] = function()
				{
					obj['e' + type + func](window.event);
				}
				obj.attachEvent('on' + type, obj[type + func]);
			}
			else 
			{
				obj.addEventListener(type, func, false);
			}
		},
</P><P>		/**
		 * Displays an alert.
		 * @param {String} str String to display.
		 */
		alert: function(str)
		{
			alert(sh.config.strings.alert + str)
		},
</P><P>		/**
		 * Finds a brush by its alias.
		 *
		 * @param {String} alias	Brush alias.
		 * @param {Boolean} alert	Suppresses the alert if false.
		 * @return {Brush}			Returns bursh constructor if found, null otherwise.
		 */
		findBrush: function(alias, alert)
		{
			var brushes = sh.vars.discoveredBrushes,
				result = null
				;
</P><P>			if (brushes == null) 
			{
				brushes = {};
</P><P>				// Find all brushes
				for (var brush in sh.brushes) 
				{
					var aliases = sh.brushes[brush].aliases;
</P><P>					if (aliases == null) 
						continue;
</P><P>					// keep the brush name
					sh.brushes[brush].name = brush.toLowerCase();
</P><P>					for (var i = 0; i &lt; aliases.length; i++) 
						brushes[aliases[i]] = brush;
				}
</P><P>				sh.vars.discoveredBrushes = brushes;
			}
</P><P>			result = sh.brushes[brushes[alias]];
</P><P>			if (result == null &amp;&amp; alert != false)
				sh.utils.alert(sh.config.strings.noBrush + alias);
</P><P>			return result;
		},
</P><P>		/**
		 * Executes a callback on each line and replaces each line with result from the callback.
		 * @param {Object} str			Input string.
		 * @param {Object} callback		Callback function taking one string argument and returning a string.
		 */
		eachLine: function(str, callback)
		{
			var lines = str.split('\n');
</P><P>			for (var i = 0; i &lt; lines.length; i++)
				lines[i] = callback(lines[i]);
</P><P>			return lines.join('\n');
		},
</P><P>		/**
		 * This is a special trim which only removes first and last empty lines
		 * and doesn't affect valid leading space on the first line.
		 * 
		 * @param {String} str   Input string
		 * @return {String}      Returns string without empty first and last lines.
		 */
		trimFirstAndLastLines: function(str)
		{
			return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, <I>);</I>
		},
</P><P>		/**
		 * Parses key/value pairs into hash object.
		 * 
		 * Understands the following formats:
		 * - name: word;
		 * - name: [word, word];
		 * - name: &quot;string&quot;;
		 * - name: 'string';
		 * 
		 * For example:
		 *   name1: value; name2: [value, value]; name3: 'value'
		 *   
		 * @param {String} str    Input string.
		 * @return {Object}       Returns deserialized object.
		 */
		parseParams: function(str)
		{
			var match, 
				result = {},
				arrayRegex = new XRegExp(&quot;^\\[(?&lt;values&gt;(.*?))\\]$&quot;),
				regex = new XRegExp(
					&quot;(?&lt;name&gt;[\\w-]+)&quot; +
					&quot;\\s*:\\s*&quot; +
					&quot;(?&lt;value&gt;&quot; +
						&quot;[\\w-%#]+|&quot; +		// word
						&quot;\\[.*?\\]|&quot; +		// [] array
						'&quot;.*?&quot;|' +			// &quot;&quot; string
						&quot;'.*?'&quot; +			// <I> string</I>
					&quot;)\\s*;?&quot;,
					&quot;g&quot;
				)
				;
</P><P>			while ((match = regex.exec(str)) != null) 
			{
				var value = match.value
					.replace(/^['&quot;]|['&quot;]$/g, <I>) // strip quotes from end of strings</I>
					;
</P><P>				// try to parse array value
				if (value != null &amp;&amp; arrayRegex.test(value))
				{
					var m = arrayRegex.exec(value);
					value = m.values.length &gt; 0 ? m.values.split(/\s*,\s*/) : [];
				}
</P><P>				result[match.name] = value;
			}
</P><P>			return result;
		},
</P><P>		/**
		 * Wraps each line of the string into &lt;code/&gt; tag with given style applied to it.
		 * 
		 * @param {String} str   Input string.
		 * @param {String} css   Style name to apply to the string.
		 * @return {String}      Returns input string with each line surrounded by &lt;span/&gt; tag.
		 */
		decorate: function(str, css)
		{
			if (str == null || str.length == 0 || str == '\n') 
				return str;
</P><P>			str = str.replace(/&lt;/g, '&lt;');
</P><P>			// Replace two or more sequential spaces with   leaving last space untouched.
			str = str.replace(/ {2,}/g, function(m)
			{
				var spaces = <I>;</I></P><P>				for (var i = 0; i &lt; m.length - 1; i++)
					spaces += ' ';
</P><P>				return spaces + ' ';
			});
</P><P>			// Split each line and apply <SPAN class="...">...</SPAN> to them so that
			// leading spaces aren't included.
			if (css != null) 
				str = sh.utils.eachLine(str, function(line)
				{
					if (line.length == 0) 
						return <I>;</I></P><P>					var spaces = <I>;</I></P><P>					line = line.replace(/^( | )+/, function(s)
					{
						spaces = s;
						return <I>;</I>
					});
</P><P>					if (line.length == 0) 
						return spaces;
</P><P>					return spaces + '<CODE class="' + css + '">' + line + '</CODE>';
				});
</P><P>			return str;
		},
</P><P>		/**
		 * Pads number with zeros until it's length is the same as given length.
		 * 
		 * @param {Number} number	Number to pad.
		 * @param {Number} length	Max string length with.
		 * @return {String}			Returns a string padded with proper amount of '0'.
		 */
		padNumber : function(number, length)
		{
			var result = number.toString();
</P><P>			while (result.length &lt; length)
				result = '0' + result;
</P><P>			return result;
		},
</P><P>		/**
		 * Measures width of a single space character.
		 * @return {Number} Returns width of a single space character.
		 */
		measureSpace : function()
		{
			var container = document.createElement('div'),
				span,
				result = 0,
				body = document.body,
				id = sh.utils.guid('measureSpace'),
</P><P>				// variable names will be compressed, so it's better than a plain string
				divOpen = '&lt;div class=&quot;',
				closeDiv = '&lt;/div&gt;',
				closeSpan = '&lt;/span&gt;'
				;
</P><P>			// we have to duplicate highlighter nested structure in order to get an acurate space measurment
			container.innerHTML = 
				divOpen + 'syntaxhighlighter&quot;&gt;' 
					+ divOpen + 'lines&quot;&gt;' 
						+ divOpen + 'line&quot;&gt;' 
							+ divOpen + 'content'
								+ '&quot;&gt;<SPAN class="block"><SPAN id=".27_.2B_id_.2B_.27"> ' + closeSpan + closeSpan
							+ closeDiv 
						+ closeDiv 
					+ closeDiv 
				+ closeDiv
				;
</SPAN></SPAN></P><P>			body.appendChild(container);
			span = document.getElementById(id);
</P><P>			if (/opera/i.test(navigator.userAgent))
			{
				var style = window.getComputedStyle(span, null);
				result = parseInt(style.getPropertyValue(&quot;width&quot;));
			}
			else
			{
				result = span.offsetWidth;
			}
</P><P>			body.removeChild(container);
</P><P>			return result;
		},
</P><P>		/**
		 * Replaces tabs with spaces.
		 * 
		 * @param {String} code		Source code.
		 * @param {Number} tabSize	Size of the tab.
		 * @return {String}			Returns code with all tabs replaces by spaces.
		 */
		processTabs : function(code, tabSize)
		{
			var tab = <I>;</I></P><P>			for (var i = 0; i &lt; tabSize; i++)
				tab += ' ';
</P><P>			return code.replace(/\t/g, tab);
		},
</P><P>		/**
		 * Replaces tabs with smart spaces.
		 * 
		 * @param {String} code    Code to fix the tabs in.
		 * @param {Number} tabSize Number of spaces in a column.
		 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
		 */
		processSmartTabs : function(code, tabSize)
		{
			var lines = code.split('\n'),
				tab = '\t',
				spaces = 
				;
</P><P>			// Create a string with 1000 spaces to copy spaces from... 
			// It's assumed that there would be no indentation longer than that.
			for (var i = 0; i &lt; 50; i++) 
				spaces += '                    '; // 20 spaces * 50
</P><P>			// This function inserts specified amount of spaces in the string
			// where a tab is while removing that given tab.
			function insertSpaces(line, pos, count)
			{
				return line.substr(0, pos)
					+ spaces.substr(0, count)
					+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
					;
			};
</P><P>			// Go through all the lines and do the 'smart tabs' magic.
			code = sh.utils.eachLine(code, function(line)
			{
				if (line.indexOf(tab) == -1) 
					return line;
</P><P>				var pos = 0;
</P><P>				while ((pos = line.indexOf(tab)) != -1) 
				{
					// This is pretty much all there is to the 'smart tabs' logic.
					// Based on the position within the line and size of a tab,
					// calculate the amount of spaces we need to insert.
					var spaces = tabSize - pos % tabSize;
					line = insertSpaces(line, pos, spaces);
				}
</P><P>				return line;
			});
</P><P>			return code;
		},
</P><P>		/**
		 * Performs various string fixes based on configuration.
		 */
		fixInputString : function(str)
		{
			var br = /|&lt;br\s*\/?&gt;/gi;
</P><P>			if (sh.config.bloggerMode == true)
				str = str.replace(br, '\n');
</P><P>			if (sh.config.stripBrs == true)
				str = str.replace(br, <I>);</I></P><P>			return str;
		},
</P><P>		/**
		 * Removes all white space at the begining and end of a string.
		 * 
		 * @param {String} str   String to trim.
		 * @return {String}      Returns string without leading and following white space characters.
		 */
		trim: function(str)
		{
			return str.replace(/^\s+|\s+$/g, <I>);</I>
		},
</P><P>		/**
		 * Unindents a block of text by the lowest common indent amount.
		 * @param {String} str   Text to unindent.
		 * @return {String}      Returns unindented text block.
		 */
		unindent: function(str)
		{
			var lines = sh.utils.fixInputString(str).split('\n'),
				indents = new Array(),
				regex = /^\s*/,
				min = 1000
				;
</P><P>			// go through every line and check for common number of indents
			for (var i = 0; i &lt; lines.length &amp;&amp; min &gt; 0; i++) 
			{
				var line = lines[i];
</P><P>				if (sh.utils.trim(line).length == 0) 
					continue;
</P><P>				var matches = regex.exec(line);
</P><P>				// In the event that just one line doesn't have leading white space
				// we can't unindent anything, so bail completely.
				if (matches == null) 
					return str;
</P><P>				min = Math.min(matches[0].length, min);
			}
</P><P>			// trim minimum common number of white space from the begining of every line
			if (min &gt; 0) 
				for (var i = 0; i &lt; lines.length; i++) 
					lines[i] = lines[i].substr(min);
</P><P>			return lines.join('\n');
		},
</P><P>		/**
		 * Callback method for Array.sort() which sorts matches by
		 * index position and then by length.
		 * 
		 * @param {Match} m1	Left object.
		 * @param {Match} m2    Right object.
		 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
		 */
		matchesSortCallback: function(m1, m2)
		{
			// sort matches by index first
			if(m1.index &lt; m2.index)
				return -1;
			else if(m1.index &gt; m2.index)
				return 1;
			else
			{
				// if index is the same, sort by length
				if(m1.length &lt; m2.length)
					return -1;
				else if(m1.length &gt; m2.length)
					return 1;
			}
</P><P>			return 0;
		},
</P><P>		/**
		 * Executes given regular expression on provided code and returns all
		 * matches that are found.
		 * 
		 * @param {String} code    Code to execute regular expression on.
		 * @param {Object} regex   Regular expression item info from <CODE>regexList</CODE> collection.
		 * @return {Array}         Returns a list of Match objects.
		 */ 
		getMatches: function(code, regexInfo)
		{
			function defaultAdd(match, regexInfo)
			{
				return [new sh.Match(match[0], match.index, regexInfo.css)];
			};
</P><P>			var index = 0,
				match = null,
				result = [],
				func = regexInfo.func ? regexInfo.func : defaultAdd
				;
</P><P>			while((match = regexInfo.regex.exec(code)) != null)
				result = result.concat(func(match, regexInfo));
</P><P>			return result;
		},
</P><P>		processUrls: function(code)
		{
			var lt = '&lt;',
				gt = '&gt;'
				;
</P><P>			return code.replace(sh.regexLib.url, function(m)
			{
				var suffix = <I>, prefix = </I>;
</P><P>				// We include &lt; and &gt; in the URL for the common cases like &lt;<A href="http://google.com" class="external free" rel="nofollow">http://google.com</A>&gt;
				// The problem is that they get transformed into &lt;<A href="http://google.com" class="external free" rel="nofollow">http://google.com</A>&gt;
				// Where as &gt; easily looks like part of the URL string.
</P><P>				if (m.indexOf(lt) == 0)
				{
					prefix = lt;
					m = m.substring(lt.length);
				}
</P><P>				if (m.indexOf(gt) == m.length - gt.length)
				{
					m = m.substring(0, m.length - gt.length);
					suffix = gt;
				}
</P><P>				return prefix + '&lt;a href=&quot;' + m + '&quot;&gt;' + m + '&lt;/a&gt;' + suffix;
			});
		},
</P><P>		/**
		 * Finds all &lt;SCRIPT TYPE=&quot;syntaxhighlighter&quot; /&gt; elements.
		 * @return {Array} Returns array of all found SyntaxHighlighter tags.
		 */
		getSyntaxHighlighterScriptTags: function()
		{
			var tags = document.getElementsByTagName('script'),
				result = []
				;
</P><P>			for (var i = 0; i &lt; tags.length; i++)
				if (tags[i].type == 'syntaxhighlighter')
					result.push(tags[i]);
</P><P>			return result;
		},
</P><P>		/**
		 * Strips &lt;![CDATA[]]&gt; from &lt;SCRIPT /&gt; content because it should be used
		 * there in most cases for XHTML compliance.
		 * @param {String} original	Input code.
		 * @return {String} Returns code without leading &lt;![CDATA[]]&gt; tags.
		 */
		stripCData: function(original)
		{
			var left = '&lt;![CDATA[',
				right = ']]&gt;',
				// for some reason IE inserts some leading blanks here
				copy = sh.utils.trim(original),
				changed = false
				;
</P><P>			if (copy.indexOf(left) == 0)
			{
				copy = copy.substring(left.length);
				changed = true;
			}
</P><P>			if (copy.indexOf(right) == copy.length - right.length)
			{
				copy = copy.substring(0, copy.length - right.length);
				changed = true;
			}
</P><P>			return changed ? copy : original;
		}
	}, // end of utils
</P><P>	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight : function(globalParams, element)
	{
		function toArray(source)
		{
			var result = [];
</P><P>			for (var i = 0; i &lt; source.length; i++) 
				result.push(source[i]);
</P><P>			return result;
		};
</P><P>		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;
</P><P>		// support for &lt;SCRIPT TYPE=&quot;syntaxhighlighter&quot; /&gt; feature
		if (conf.useScriptTags)
			elements = elements.concat(sh.utils.getSyntaxHighlighterScriptTags());
</P><P>		if (elements.length === 0) 
			return;
</P><P>		for (var i = 0; i &lt; elements.length; i++) 
		{
			var target = elements[i], 
				params = sh.utils.parseParams(target.className),
				brushName,
				code,
				result
				;
</P><P>			// local params take precedence over globals
			params = sh.utils.merge(globalParams, params);
			brushName = params['brush'];
</P><P>			if (brushName == null)
				continue;
</P><P>			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = sh.utils.findBrush(brushName);
</P><P>				if (brush)
				{
					brushName = brush.name;
					highlighter = new brush();
				}
				else
				{
					continue;
				}
			}
</P><P>			code = target[propertyName];
</P><P>			// remove CDATA from &lt;SCRIPT/&gt; tags if it's present
			if (conf.useScriptTags)
				code = sh.utils.stripCData(code);
</P><P>			params['brush-name'] = brushName;
			highlighter.highlight(code, params);
</P><P>			result = highlighter.div;
</P><P>			if (sh.config.debug) 
			{
				result = document.createElement('textarea');
				result.value = highlighter.div.innerHTML;
				result.style.width = '70em';
				result.style.height = '30em';
			}
</P><P>			target.parentNode.replaceChild(result, target);
		}
	},
</P><P>	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all : function(params)
	{
		sh.utils.addEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh
</P><P>/**
</P><PRE>* Match object.
*/
</PRE><P>sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};
</P><P>sh.Match.prototype.toString = function()
{
	return this.value;
};
</P><P>/**
</P><PRE>* Simulates HTML code with a scripting language embedded.
* 
* @param {String} scriptBrushName Brush name of the scripting language.
*/
</PRE><P>sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = sh.utils.findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null
		;
</P><P>	if (brushClass == null)
		return;
</P><P>	scriptBrush = new brushClass();
	this.xmlBrush = xmlBrush;
</P><P>	if (scriptBrush.htmlScript == null)
	{
		sh.utils.alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
</P><P>	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
</P><P>	function offsetMatches(matches, offset)
	{
		for (var j = 0; j &lt; matches.length; j++) 
			matches[j].index += offset;
	}
</P><P>	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;
</P><P>		// add all matches from the code
		for (var i = 0; i &lt; regexList.length; i++)
		{
			result = sh.utils.getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
</P><P>		// add left script bracket
		if (htmlScript.left != null &amp;&amp; match.left != null)
		{
			result = sh.utils.getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
</P><P>		// add right script bracket
		if (htmlScript.right != null &amp;&amp; match.right != null)
		{
			result = sh.utils.getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
</P><P>		for (var j = 0; j &lt; matches.length; j++)
			matches[j].brushName = brushClass.name;
</P><P>		return matches;
	}
};
</P><P>sh.HtmlScript.prototype.highlight = function(code, params)
{
	this.xmlBrush.highlight(code, params);
	this.div = this.xmlBrush.div;
}
</P><P>/**
</P><PRE>* Main Highlither class.
* @constructor
*/
</PRE><P>sh.Highlighter = function()
{
};
</P><P>sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam : function(name, defaultValue)
	{
		var result = this.params[name];
		return sh.utils.toBoolean(result == null ? defaultValue : result);
	},
</P><P>	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
</P><P>	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
</P><P>		if (regexList != null)
			for (var i = 0; i &lt; regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == &quot;object&quot;)
					result = result.concat(sh.utils.getMatches(code, regexList[i]));
</P><P>		// sort the matches
		return result.sort(sh.utils.matchesSortCallback);
	},
</P><P>	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function()
	{
		var matches = this.matches;
</P><P>		// Optimized by Jose Prado (<A href="http://joseprado.com" class="external free" rel="nofollow">http://joseprado.com</A>)
		for (var i = 0; i &lt; matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
</P><P>			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
</P><P>			for (var j = i + 1; j &lt; matches.length &amp;&amp; matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
</P><P>				if (itemJ === null) 
					continue;
				else if (itemJ.index &gt; itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index &amp;&amp; itemJ.length &gt; itemI.length)
					this.matches[i] = null;
				else if (itemJ.index &gt;= itemI.index &amp;&amp; itemJ.index &lt; itemIEndPos) 
					this.matches[j] = null;
			}
		}
	},
</P><P>	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code     Code to highlight.
	 * @return {String}         Returns highlighted code in HTML form.
	 */
	createDisplayLines : function(code)
	{
		var lines = code.split('\n'),
			firstLine = parseInt(this.getParam('first-line')),
			padLength = this.getParam('pad-line-numbers'),
			highlightedLines = this.getParam('highlight', []),
			hasGutter = this.getParam('gutter')
			;
</P><P>		code = <I>;</I></P><P>		if (padLength == true)
			padLength = (firstLine + lines.length - 1).toString().length;
		else if (isNaN(padLength) == true)
			padLength = 0;
</P><P>		for (var i = 0; i &lt; lines.length; i++)
		{
			var line = lines[i],
				indent = /^( |\s)+/.exec(line),
				lineClass = 'alt' + (i % 2 == 0 ? 1 : 2),
				lineNumber = sh.utils.padNumber(firstLine + i, padLength),
				highlighted = sh.utils.indexOf(highlightedLines, (firstLine + i).toString()) != -1,
				spaces = null
				;
</P><P>			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
			}
</P><P>			line = sh.utils.trim(line);
</P><P>			if (line.length == 0)
				line = ' ';
</P><P>			if (highlighted)
				lineClass += ' highlighted';
</P><P>			code += 
</P>
				'<DIV class="line ' + lineClass + '">'
					+ '<TABLE>'
						+ '<TBODY><TR>'
							+ (hasGutter ? '<TD class="number"><CODE>' + lineNumber + '</CODE></TD>' : <I>)</I>
							+ '<TD class="content">'
<P>								+ (spaces != null ? '<CODE class="spaces">' + spaces.replace(' ', ' ') + '</CODE>' : <I>)</I>
								+ line
</P>
							+ '</TD>'
						+ '</TR>'
					+ '</TBODY></TABLE>'
				+ '</DIV>'
<P>				;
		}
</P><P>		return code;
	},
</P><P>	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	processMatches: function(code, matches)
	{
		var pos = 0, 
			result = <I>,</I>
			decorate = sh.utils.decorate, // make an alias to save some bytes
			brushName = this.getParam('brush-name', <I>)</I>
			;
</P><P>		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : <I>;</I>
		};
</P><P>		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i &lt; matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
</P><P>			if (match === null || match.length === 0) 
				continue;
</P><P>			matchBrushName = getBrushNameCss(match);
</P><P>			result += decorate(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ decorate(match.value, matchBrushName + match.css)
					;
</P><P>			pos = match.index + match.length;
		}
</P><P>		// don't forget to add whatever's remaining in the string
		result += decorate(code.substr(pos), getBrushNameCss() + 'plain');
</P><P>		return result;
	},
</P><P>	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @param {Object} params   Parameters object.
	 */
	highlight: function(code, params)
	{
		// using variables for shortcuts because JS compressor will shorten local variable names
		var conf = sh.config,
			vars = sh.vars,
			div,
			divClassName,
			tabSize,
			important = 'important'
			;
</P><P>		this.params = {};
		this.div = null;
		this.lines = null;
		this.code = null;
		this.bar = null;
		this.toolbarCommands = {};
		this.id = sh.utils.guid('highlighter_');
</P><P>		// register this instance in the highlighters list
		vars.highlighters[this.id] = this;
</P><P>		if (code === null) 
			code = <I>;</I></P><P>		// local params take precedence over defaults
		this.params = sh.utils.merge(sh.defaults, params || {});
</P><P>		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
</P><P>		this.div = div = this.create('DIV');
		this.lines = this.create('DIV');
		this.lines.className = 'lines';
</P><P>		className = 'syntaxhighlighter';
		div.id = this.id;
</P><P>		// make collapsed
		if (this.getParam('collapse'))
			className += ' collapsed';
</P><P>		// disable gutter
		if (this.getParam('gutter') == false)
			className += ' nogutter';
</P><P>		// disable line wrapping
		if (this.getParam('wrap-lines') == false)
		 	this.lines.className += ' no-wrap';
</P><P>		// add custom user style name
		className += ' ' + this.getParam('class-name');
</P><P>		// add brush alias to the class name for custom CSS
		className += ' ' + this.getParam('brush-name');
</P><P>		div.className = className;
</P><P>		this.originalCode = code;
		this.code = sh.utils.trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;
</P><P>		tabSize = this.getParam('tab-size');
</P><P>		// replace tabs with spaces
		this.code = this.getParam('smart-tabs') == true
			? sh.utils.processSmartTabs(this.code, tabSize)
			: sh.utils.processTabs(this.code, tabSize)
			;
</P><P>		this.code = sh.utils.unindent(this.code);
</P><P>		// add controls toolbar
		if (this.getParam('toolbar')) 
		{
			this.bar = this.create('DIV');
			this.bar.className = 'bar';
			this.bar.appendChild(sh.toolbar.create(this));
			div.appendChild(this.bar);
</P><P>			// set up toolbar rollover
			var bar = this.bar;
			function hide() { bar.className = bar.className.replace('show', <I>); }</I>
			div.onmouseover = function() { hide(); bar.className += ' show'; };
			div.onmouseout = function() { hide(); }
		}
</P><P>		div.appendChild(this.lines);
</P><P>		this.matches = this.findMatches(this.regexList, this.code);
		this.removeNestedMatches();
</P><P>		code = this.processMatches(this.code, this.matches);
</P><P>		// finally, split all lines so that they wrap well
		code = this.createDisplayLines(sh.utils.trim(code));
</P><P>		// finally, process the links
		if (this.getParam('auto-links'))
			code = sh.utils.processUrls(code);
</P><P>		this.lines.innerHTML = code;
	},
</P><P>	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */	
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, <I>)</I>
			.replace(/\s+/g, '|')
			;
</P><P>		return '\\b(?:' + str + ')\\b';
	},
</P><P>	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				&quot;(?&lt;left&gt;&quot; + regexGroup.left.source + &quot;)&quot; +
				&quot;(?<CODE>.*?)&quot; +
				&quot;(?&lt;right&gt;&quot; + regexGroup.right.source + &quot;)&quot;,
				&quot;sgi&quot;
				)
		};
	}
}; // end of Highlighter
</CODE></P><P>return sh;
}(); // end of anonymous function
</P><P>
/**
</P><PRE>* XRegExp 0.6.1
* (c) 2007-2008 Steven Levithan
* &lt;<A href="http://stevenlevithan.com/regex/xregexp/" class="external free" rel="nofollow">http://stevenlevithan.com/regex/xregexp/</A>&gt;
* MIT License
* 
* provides an augmented, cross-browser implementation of regular expressions
* including support for additional modifiers and syntax. several convenience
* methods and a recursive-construct parser are also included.
*/
</PRE><P>// prevent running twice, which would break references to native globals
if (!window.XRegExp) {
// anonymous function to avoid global variables
(function () {
// copy various native globals for reference. can't use the name ``native``
// because it's a reserved JavaScript keyword.
var real = {
</P><PRE>       exec:    RegExp.prototype.exec,
       match:   String.prototype.match,
       replace: String.prototype.replace,
       split:   String.prototype.split
   },
   /* regex syntax parsing with support for all the necessary cross-
      browser and context issues (escapings, character classes, etc.) */
   lib = {
       part:       /(?:[^\\([#\s.]+|\\(?!k&lt;[\w$]+&gt;|[pP]{[^}]+})[\S\s]?|\((?=\?(?!#|&lt;[\w$]+&gt;)))+|(\()(?:\?(?:(#)[^)]*\)|&lt;([$\w]+)&gt;))?|\\(?:k&lt;([\w$]+)&gt;|[pP]{([^}]+)})|(\[\^?)|([\S\s])/g,
       replaceVar: /(?:[^$]+|\$(?![1-9$&amp;`']|{[$\w]+}))+|\$(?:([1-9]\d*|[$&amp;`'])|{([$\w]+)})/g,
       extended:   /^(?:\s+|#.*)+/,
       quantifier: /^(?:[?*+]|{\d+(?:,\d*)?})/,
       classLeft:  /&amp;&amp;\[\^?/g,
       classRight: /]/g
   },
   indexOf = function (array, item, from) {
       for (var i = from || 0; i &lt; array.length; i++)
           if (array[i] === item) return i;
       return -1;
   },
   brokenExecUndef = /()??/.exec(&quot;&quot;)[1] !== undefined,
   plugins = {};
</PRE><P>/**
</P><PRE>* Accepts a pattern and flags, returns a new, extended RegExp object.
* differs from a native regex in that additional flags and syntax are
* supported and browser inconsistencies are ameliorated.
* @ignore
*/
</PRE><P>XRegExp = function (pattern, flags) {
</P><PRE>   if (pattern instanceof RegExp) {
       if (flags !== undefined)
           throw TypeError(&quot;can't supply flags when constructing one RegExp from another&quot;);
       return pattern.addFlags(); // new copy
   }
</PRE><PRE>   var flags           = flags || &quot;&quot;,
       singleline      = flags.indexOf(&quot;s&quot;) &gt; -1,
       extended        = flags.indexOf(&quot;x&quot;) &gt; -1,
       hasNamedCapture = false,
       captureNames    = [],
       output          = [],
       part            = lib.part,
       match, cc, len, index, regex;
</PRE><PRE>   part.lastIndex = 0; // in case the last XRegExp compilation threw an error (unbalanced character class)
</PRE><PRE>   while (match = real.exec.call(part, pattern)) {
       // comment pattern. this check must come before the capturing group check,
       // because both match[1] and match[2] will be non-empty.
       if (match[2]) {
           // keep tokens separated unless the following token is a quantifier
           if (!lib.quantifier.test(pattern.slice(part.lastIndex)))
               output.push(&quot;(?:)&quot;);
       // capturing group
       } else if (match[1]) {
           captureNames.push(match[3] || null);
           if (match[3])
               hasNamedCapture = true;
           output.push(&quot;(&quot;);
       // named backreference
       } else if (match[4]) {
           index = indexOf(captureNames, match[4]);
           // keep backreferences separate from subsequent literal numbers
           // preserve backreferences to named groups that are undefined at this point as literal strings
           output.push(index &gt; -1 ?
               &quot;\\&quot; + (index + 1) + (isNaN(pattern.charAt(part.lastIndex)) ? &quot;&quot; : &quot;(?:)&quot;) :
               match[0]
           );
       // unicode element (requires plugin)
       } else if (match[5]) {
           output.push(plugins.unicode ?
               plugins.unicode.get(match[5], match[0].charAt(1) === &quot;P&quot;) :
               match[0]
           );
       // character class opening delimiter (&quot;[&quot; or &quot;[^&quot;)
       // (non-native unicode elements are not supported within character classes)
       } else if (match[6]) {
           if (pattern.charAt(part.lastIndex) === &quot;]&quot;) {
               // for cross-browser compatibility with ECMA-262 v3 behavior,
               // convert [] to (?!) and [^] to [\S\s].
               output.push(match[6] === &quot;[&quot; ? &quot;(?!)&quot; : &quot;[\\S\\s]&quot;);
               part.lastIndex++;
           } else {
               // parse the character class with support for inner escapes and
               // ES4's infinitely nesting intersection syntax ([&amp;&amp;[^&amp;&amp;[]]]).
               cc = XRegExp.matchRecursive(&quot;&amp;&amp;&quot; + pattern.slice(match.index), lib.classLeft, lib.classRight, &quot;&quot;, {escapeChar: &quot;\\&quot;})[0];
               output.push(match[6] + cc + &quot;]&quot;);
               part.lastIndex += cc.length + 1;
           }
       // dot (&quot;.&quot;), pound sign (&quot;#&quot;), or whitespace character
       } else if (match[7]) {
           if (singleline &amp;&amp; match[7] === &quot;.&quot;) {
               output.push(&quot;[\\S\\s]&quot;);
           } else if (extended &amp;&amp; lib.extended.test(match[7])) {
               len = real.exec.call(lib.extended, pattern.slice(part.lastIndex - 1))[0].length;
               // keep tokens separated unless the following token is a quantifier
               if (!lib.quantifier.test(pattern.slice(part.lastIndex - 1 + len)))
                   output.push(&quot;(?:)&quot;);
               part.lastIndex += len - 1;
           } else {
               output.push(match[7]);
           }
       } else {
           output.push(match[0]);
       }
   }
</PRE><PRE>   regex = RegExp(output.join(&quot;&quot;), real.replace.call(flags, /[sx]+/g, &quot;&quot;));
   regex._x = {
       source:       pattern,
       captureNames: hasNamedCapture ? captureNames : null
   };
   return regex;
</PRE><P>};
</P><P>/**
</P><PRE>* Barebones plugin support for now (intentionally undocumented)
* @ignore
* @param {Object} name
* @param {Object} o
*/
</PRE><P>XRegExp.addPlugin = function (name, o) {
</P><PRE>   plugins[name] = o;
</PRE><P>};
</P><P>/**
</P><PRE>* Adds named capture support, with values returned as ``result.name``.
* 
* Also fixes two cross-browser issues, following the ECMA-262 v3 spec:
*  - captured values for non-participating capturing groups should be returned
*    as ``undefined``, rather than the empty string.
*  - the regex's ``lastIndex`` should not be incremented after zero-length
*    matches.
* @ignore
*/
</PRE><P>RegExp.prototype.exec = function (str) {
</P><PRE>   var match = real.exec.call(this, str),
       name, i, r2;
   if (match) {
       // fix browsers whose exec methods don't consistently return
       // undefined for non-participating capturing groups
       if (brokenExecUndef &amp;&amp; match.length &gt; 1) {
           // r2 doesn't need /g or /y, but they shouldn't hurt
           r2 = new RegExp(&quot;^&quot; + this.source + &quot;$(?!\\s)&quot;, this.getNativeFlags());
           real.replace.call(match[0], r2, function () {
               for (i = 1; i &lt; arguments.length - 2; i++) {
                   if (arguments[i] === undefined) match[i] = undefined;
               }
           });
       }
       // attach named capture properties
       if (this._x &amp;&amp; this._x.captureNames) {
           for (i = 1; i &lt; match.length; i++) {
               name = this._x.captureNames[i - 1];
               if (name) match[name] = match[i];
           }
       }
       // fix browsers that increment lastIndex after zero-length matches
       if (this.global &amp;&amp; this.lastIndex &gt; (match.index + match[0].length))
           this.lastIndex--;
   }
   return match;
</PRE><P>};
})(); // end anonymous function
} // end if(!window.XRegExp)
</P><P>/**
</P><PRE>* intentionally undocumented
* @ignore
*/
</PRE><P>RegExp.prototype.getNativeFlags = function () {
</P><PRE>   return (this.global     ? &quot;g&quot; : &quot;&quot;) +
          (this.ignoreCase ? &quot;i&quot; : &quot;&quot;) +
          (this.multiline  ? &quot;m&quot; : &quot;&quot;) +
          (this.extended   ? &quot;x&quot; : &quot;&quot;) +
          (this.sticky     ? &quot;y&quot; : &quot;&quot;);
</PRE><P>};
</P><P>/**
</P><PRE>* Accepts flags; returns a new XRegExp object generated by recompiling
* the regex with the additional flags (may include non-native flags).
* The original regex object is not altered.
* @ignore
*/
</PRE><P>RegExp.prototype.addFlags = function (flags) {
</P><PRE>   var regex = new XRegExp(this.source, (flags || &quot;&quot;) + this.getNativeFlags());
   if (this._x) {
       regex._x = {
           source:       this._x.source,
           captureNames: this._x.captureNames ? this._x.captureNames.slice(0) : null
       };
   }
   return regex;
</PRE><P>};
</P><P>/**
</P><PRE>* Accepts a context object and string; returns the result of calling
* ``exec`` with the provided string. the context is ignored but is
* accepted for congruity with ``Function.prototype.call``.
* @ignore
*/
</PRE><P>RegExp.prototype.call = function (context, str) {
</P><PRE>   return this.exec(str);
</PRE><P>};
</P><P>/**
</P><PRE>* Accepts a context object and arguments array; returns the result of
* calling ``exec`` with the first value in the arguments array. the context
* is ignored but is accepted for congruity with ``Function.prototype.apply``.
* @ignore
*/
</PRE><P>RegExp.prototype.apply = function (context, args) {
</P><PRE>   return this.exec(args[0]);
</PRE><P>};
</P><P>/**
</P><PRE>* Accepts a pattern and flags; returns an XRegExp object. if the pattern
* and flag combination has previously been cached, the cached copy is
* returned, otherwise the new object is cached.
* @ignore
*/
</PRE><P>XRegExp.cache = function (pattern, flags) {
</P><PRE>   var key = &quot;/&quot; + pattern + &quot;/&quot; + (flags || &quot;&quot;);
   return XRegExp.cache[key] || (XRegExp.cache[key] = new XRegExp(pattern, flags));
</PRE><P>};
</P><P>/**
</P><PRE>* Accepts a string; returns the string with regex metacharacters escaped.
* the returned string can safely be used within a regex to match a literal
* string. escaped characters are [, ], {, }, (, ), -, *, +, ?, ., \, ^, $,
* |, #, [comma], and whitespace.
* @ignore
*/
</PRE><P>XRegExp.escape = function (str) {
</P><PRE>   return str.replace(/[-[\]{}()*+?.\\^$|,#\s]/g, &quot;\\$&amp;&quot;);
</PRE><P>};
</P><P>/**
</P><PRE>* Accepts a string to search, left and right delimiters as regex pattern
* strings, optional regex flags (may include non-native s, x, and y flags),
* and an options object which allows setting an escape character and changing
* the return format from an array of matches to a two-dimensional array of
* string parts with extended position data. returns an array of matches
* (optionally with extended data), allowing nested instances of left and right
* delimiters. use the g flag to return all matches, otherwise only the first
* is returned. if delimiters are unbalanced within the subject data, an error
* is thrown.
* 
* This function admittedly pushes the boundaries of what can be accomplished
* sensibly without a &quot;real&quot; parser. however, by doing so it provides flexible
* and powerful recursive parsing capabilities with minimal code weight.
* 
* Warning: the ``escapeChar`` option is considered experimental and might be
* changed or removed in future versions of XRegExp.
* 
* unsupported features:
*  - backreferences within delimiter patterns when using ``escapeChar``.
*  - although providing delimiters as regex objects adds the minor feature of
*    independent delimiter flags, it introduces other limitations and is only
*    intended to be done by the ``XRegExp`` constructor (which can't call
*    itself while building a regex).
* 
* @ignore
*/
</PRE><P>XRegExp.matchRecursive = function (str, left, right, flags, options) {
</P><PRE>   var options      = options || {},
       escapeChar   = options.escapeChar,
       vN           = options.valueNames,
       flags        = flags || &quot;&quot;,
       global       = flags.indexOf(&quot;g&quot;) &gt; -1,
       ignoreCase   = flags.indexOf(&quot;i&quot;) &gt; -1,
       multiline    = flags.indexOf(&quot;m&quot;) &gt; -1,
       sticky       = flags.indexOf(&quot;y&quot;) &gt; -1,
       /* sticky mode has its own handling in this function, which means you
          can use flag &quot;y&quot; even in browsers which don't support it natively */
       flags        = flags.replace(/y/g, &quot;&quot;),
       left         = left  instanceof RegExp ? (left.global  ? left  : left.addFlags(&quot;g&quot;))  : new XRegExp(left,  &quot;g&quot; + flags),
       right        = right instanceof RegExp ? (right.global ? right : right.addFlags(&quot;g&quot;)) : new XRegExp(right, &quot;g&quot; + flags),
       output       = [],
       openTokens   = 0,
       delimStart   = 0,
       delimEnd     = 0,
       lastOuterEnd = 0,
       outerStart, innerStart, leftMatch, rightMatch, escaped, esc;
</PRE><PRE>   if (escapeChar) {
       if (escapeChar.length &gt; 1) throw SyntaxError(&quot;can't supply more than one escape character&quot;);
       if (multiline)             throw TypeError(&quot;can't supply escape character when using the multiline flag&quot;);
       escaped = XRegExp.escape(escapeChar);
       /* Escape pattern modifiers:
           /g - not needed here
           /i - included
           /m - **unsupported**, throws error
           /s - handled by XRegExp when delimiters are provided as strings
           /x - handled by XRegExp when delimiters are provided as strings
           /y - not needed here; supported by other handling in this function
       */
       esc = new RegExp(
           &quot;^(?:&quot; + escaped + &quot;[\\S\\s]|(?:(?!&quot; + left.source + &quot;|&quot; + right.source + &quot;)[^&quot; + escaped + &quot;])+)+&quot;,
           ignoreCase ? &quot;i&quot; : &quot;&quot;
       );
   }
</PRE><PRE>   while (true) {
       /* advance the starting search position to the end of the last delimiter match.
          a couple special cases are also covered:
           - if using an escape character, advance to the next delimiter's starting position,
             skipping any escaped characters
           - first time through, reset lastIndex in case delimiters were provided as regexes
       */
       left.lastIndex = right.lastIndex = delimEnd +
           (escapeChar ? (esc.exec(str.slice(delimEnd)) || [&quot;&quot;])[0].length : 0);
</PRE><PRE>       leftMatch  = left.exec(str);
       rightMatch = right.exec(str);
</PRE><PRE>       // only keep the result which matched earlier in the string
       if (leftMatch &amp;&amp; rightMatch) {
           if (leftMatch.index &lt;= rightMatch.index)
                rightMatch = null;
           else leftMatch  = null;
       }
</PRE><PRE>       /* paths*:
       leftMatch | rightMatch | openTokens | result
       1         | 0          | 1          | ...
       1         | 0          | 0          | ...
       0         | 1          | 1          | ...
       0         | 1          | 0          | throw
       0         | 0          | 1          | throw
       0         | 0          | 0          | break
       * - does not include the sticky mode special case
         - the loop ends after the first completed match if not in global mode
       */
</PRE><PRE>       if (leftMatch || rightMatch) {
           delimStart = (leftMatch || rightMatch).index;
           delimEnd   = (leftMatch ? left : right).lastIndex;
       } else if (!openTokens) {
           break;
       }
</PRE><PRE>       if (sticky &amp;&amp; !openTokens &amp;&amp; delimStart &gt; lastOuterEnd)
           break;
</PRE><PRE>       if (leftMatch) {
           if (!openTokens++) {
               outerStart = delimStart;
               innerStart = delimEnd;
           }
       } else if (rightMatch &amp;&amp; openTokens) {
           if (!--openTokens) {
               if (vN) {
                   if (vN[0] &amp;&amp; outerStart &gt; lastOuterEnd)
                              output.push([vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart]);
                   if (vN[1]) output.push([vN[1], str.slice(outerStart,   innerStart), outerStart,   innerStart]);
                   if (vN[2]) output.push([vN[2], str.slice(innerStart,   delimStart), innerStart,   delimStart]);
                   if (vN[3]) output.push([vN[3], str.slice(delimStart,   delimEnd),   delimStart,   delimEnd]);
               } else {
                   output.push(str.slice(innerStart, delimStart));
               }
               lastOuterEnd = delimEnd;
               if (!global)
                   break;
           }
       } else {
           // reset lastIndex in case delimiters were provided as regexes
           left.lastIndex = right.lastIndex = 0;
           throw Error(&quot;subject data contains unbalanced delimiters&quot;);
       }
</PRE><PRE>       // if the delimiter matched an empty string, advance delimEnd to avoid an infinite loop
       if (delimStart === delimEnd)
           delimEnd++;
   }
</PRE><PRE>   if (global &amp;&amp; !sticky &amp;&amp; vN &amp;&amp; vN[0] &amp;&amp; str.length &gt; lastOuterEnd)
       output.push([vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length]);
</PRE><PRE>   // reset lastIndex in case delimiters were provided as regexes
   left.lastIndex = right.lastIndex = 0;
</PRE><PRE>   return output;
</PRE><P>};</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2013.igem.org/Team:Newcastle/script/shCore.js">http://2013.igem.org/Team:Newcastle/script/shCore.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Newcastle/script/shCore.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Newcastle/script/shCore.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Newcastle/script/shCore.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Newcastle/script/shCore.js&amp;oldid=261718" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2013.igem.org:Privacy_policy" title="2013.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2013.igem.org:General_disclaimer" title="2013.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
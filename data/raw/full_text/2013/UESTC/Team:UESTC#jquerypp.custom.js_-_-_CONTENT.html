<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_UESTC_jquerypp_custom_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:UESTC/jquerypp.custom.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:UESTC/jquerypp.custom.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:UESTC/jquerypp.custom.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:UESTC/jquerypp.custom.js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:UESTC/jquerypp.custom.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:UESTC/jquerypp.custom.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2013.igem.org</H3><P>(function() {
</P><P>	var event = jQuery.event,
</P><P>		//helper that finds handlers by type and calls back a function, this is basically handle
		// events - the events object
		// types - an array of event types to look for
		// callback(type, handlerFunc, selector) - a callback
		// selector - an optional selector to filter with, if there, matches by selector
		//     if null, matches anything, otherwise, matches with no selector
		findHelper = function( events, types, callback, selector ) {
			var t, type, typeHandlers, all, h, handle, 
				namespaces, namespace,
				match;
			for ( t = 0; t &lt; types.length; t++ ) {
				type = types[t];
				all = type.indexOf(&quot;.&quot;) &lt; 0;
				if (!all ) {
					namespaces = type.split(&quot;.&quot;);
					type = namespaces.shift();
					namespace = new RegExp(&quot;(^|\\.)&quot; + namespaces.slice(0).sort().join(&quot;\\.(?:.*\\.)?&quot;) + &quot;(\\.|$)&quot;);
				}
				typeHandlers = (events[type] || []).slice(0);
</P><P>				for ( h = 0; h &lt; typeHandlers.length; h++ ) {
					handle = typeHandlers[h];
</P><P>					match = (all || namespace.test(handle.namespace));
</P><P>					if(match){
						if(selector){
							if (handle.selector === selector  ) {
								callback(type, handle.origHandler || handle.handler);
							}
						} else if (selector === null){
							callback(type, handle.origHandler || handle.handler, handle.selector);
						}
						else if (!handle.selector ) {
							callback(type, handle.origHandler || handle.handler);
</P><P>						} 
					}
</P><P>					
				}
			}
		};
</P><P>	/**
	 * Finds event handlers of a given type on an element.
	 * @param {HTMLElement} el
	 * @param {Array} types an array of event names
	 * @param {String} [selector] optional selector
	 * @return {Array} an array of event handlers
	 */
	event.find = function( el, types, selector ) {
		var events = ( $jq183._data(el) || {} ).events,
			handlers = [],
			t, liver, live;
</P><P>		if (!events ) {
			return handlers;
		}
		findHelper(events, types, function( type, handler ) {
			handlers.push(handler);
		}, selector);
		return handlers;
	};
	/**
	 * Finds all events.  Group by selector.
	 * @param {HTMLElement} el the element
	 * @param {Array} types event types
	 */
	event.findBySelector = function( el, types ) {
		var events = $._data(el).events,
			selectors = {},
			//adds a handler for a given selector and event
			add = function( selector, event, handler ) {
				var select = selectors[selector] || (selectors[selector] = {}),
					events = select[event] || (select[event] = []);
				events.push(handler);
			};
</P><P>		if (!events ) {
			return selectors;
		}
		//first check live:
		/*$.each(events.live || [], function( i, live ) {
			if ( $.inArray(live.origType, types) !== -1 ) {
				add(live.selector, live.origType, live.origHandler || live.handler);
			}
		});*/
		//then check straight binds
		findHelper(events, types, function( type, handler, selector ) {
			add(selector || &quot;&quot;, type, handler);
		}, null);
</P><P>		return selectors;
	};
	event.supportTouch = &quot;ontouchend&quot; in document;
</P><P>	$.fn.respondsTo = function( events ) {
		if (!this.length ) {
			return false;
		} else {
			//add default ?
			return event.find(this[0], $.isArray(events) ? events : [events]).length &gt; 0;
		}
	};
	$.fn.triggerHandled = function( event, data ) {
		event = (typeof event == &quot;string&quot; ? $.Event(event) : event);
		this.trigger(event, data);
		return event.handled;
	};
	/**
	 * Only attaches one event handler for all types ...
	 * @param {Array} types llist of types that will delegate here
	 * @param {Object} startingEvent the first event to start listening to
	 * @param {Object} onFirst a function to call 
	 */
	event.setupHelper = function( types, startingEvent, onFirst ) {
		if (!onFirst ) {
			onFirst = startingEvent;
			startingEvent = null;
		}
		var add = function( handleObj ) {
</P><P>			var bySelector, selector = handleObj.selector || &quot;&quot;;
			if ( selector ) {
				bySelector = event.find(this, types, selector);
				if (!bySelector.length ) {
					$(this).delegate(selector, startingEvent, onFirst);
				}
			}
			else {
				//var bySelector = event.find(this, types, selector);
				if (!event.find(this, types, selector).length ) {
					event.add(this, startingEvent, onFirst, {
						selector: selector,
						delegate: this
					});
				}
</P><P>			}
</P><P>		},
			remove = function( handleObj ) {
				var bySelector, selector = handleObj.selector || &quot;&quot;;
				if ( selector ) {
					bySelector = event.find(this, types, selector);
					if (!bySelector.length ) {
						$(this).undelegate(selector, startingEvent, onFirst);
					}
				}
				else {
					if (!event.find(this, types, selector).length ) {
						event.remove(this, startingEvent, onFirst, {
							selector: selector,
							delegate: this
						});
					}
				}
			};
		$.each(types, function() {
			event.special[this] = {
				add: add,
				remove: remove,
				setup: function() {},
				teardown: function() {}
			};
		});
	};
})(jQuery);
(function($){
var isPhantom = /Phantom/.test(navigator.userAgent),
	supportTouch = !isPhantom &amp;&amp; &quot;ontouchend&quot; in document,
	scrollEvent = &quot;touchmove scroll&quot;,
	// Use touch events or map it to mouse events
	touchStartEvent = supportTouch ? &quot;touchstart&quot; : &quot;mousedown&quot;,
	touchStopEvent = supportTouch ? &quot;touchend&quot; : &quot;mouseup&quot;,
	touchMoveEvent = supportTouch ? &quot;touchmove&quot; : &quot;mousemove&quot;,
	data = function(event){
		var d = event.originalEvent.touches ?
			event.originalEvent.touches[ 0 ] :
			event;
		return {
			time: (new Date).getTime(),
			coords: [ d.pageX, d.pageY ],
			origin: $( event.target )
		};
	};
</P><P>/**
</P><PRE>* @add jQuery.event.swipe
*/
</PRE><P>var swipe = $.event.swipe = {
	/**
	 * @attribute delay
	 * Delay is the upper limit of time the swipe motion can take in milliseconds.  This defaults to 500.
	 * 
	 * A user must perform the swipe motion in this much time.
	 */
	delay : 500,
	/**
	 * @attribute max
	 * The maximum distance the pointer must travel in pixels.  The default is 75 pixels.
	 */
	max : 75,
	/**
	 * @attribute min
	 * The minimum distance the pointer must travel in pixels.  The default is 30 pixels.
	 */
	min : 30
};
</P><P>$.event.setupHelper( [
</P><P>/**
</P><PRE>* @hide
* @attribute swipe
*/
</PRE><P>&quot;swipe&quot;,
/**
</P><PRE>* @hide
* @attribute swipeleft
*/
</PRE><P>'swipeleft',
/**
</P><PRE>* @hide
* @attribute swiperight
*/
</PRE><P>'swiperight',
/**
</P><PRE>* @hide
* @attribute swipeup
*/
</PRE><P>'swipeup',
/**
</P><PRE>* @hide
* @attribute swipedown
*/
</PRE><P>'swipedown'], touchStartEvent, function(ev){
	var
		// update with data when the event was started
		start = data(ev),
		stop,
		delegate = ev.delegateTarget || ev.currentTarget,
		selector = ev.handleObj.selector,
		entered = this;
</P><P>	function moveHandler(event){
		if ( !start ) {
			return;
		}
		// update stop with the data from the current event
		stop = data(event);
</P><P>		// prevent scrolling
		if ( Math.abs( start.coords[0] - stop.coords[0] ) &gt; 10 ) {
			event.preventDefault();
		}
	};
</P><P>	// Attach to the touch move events
	$(document.documentElement).bind(touchMoveEvent, moveHandler)
		.one(touchStopEvent, function(event){
			$(this).unbind( touchMoveEvent, moveHandler);
			// if start and stop contain data figure out if we have a swipe event
			if ( start &amp;&amp; stop ) {
				// calculate the distance between start and stop data
				var deltaX = Math.abs(start.coords[0] - stop.coords[0]),
					deltaY = Math.abs(start.coords[1] - stop.coords[1]),
					distance = Math.sqrt(deltaX*deltaX+deltaY*deltaY);
</P><P>				// check if the delay and distance are matched
				if ( stop.time - start.time &lt; swipe.delay &amp;&amp; distance &gt;= swipe.min ) {
					var events = ['swipe'];
					// check if we moved horizontally
					if( deltaX &gt;= swipe.min &amp;&amp; deltaY &lt; swipe.min) {
						// based on the x coordinate check if we moved left or right
						events.push( start.coords[0] &gt; stop.coords[0] ? &quot;swipeleft&quot; : &quot;swiperight&quot; );
					} else
					// check if we moved vertically
					if(deltaY &gt;= swipe.min &amp;&amp; deltaX &lt; swipe.min){
						// based on the y coordinate check if we moved up or down
						events.push( start.coords[1] &lt; stop.coords[1] ? &quot;swipedown&quot; : &quot;swipeup&quot; );
					}
</P><P>					// trigger swipe events on this guy
					$.each($.event.find(delegate, events, selector), function(){
						this.call(entered, ev, {start : start, end: stop})
					})
</P><P>				}
			}
			// reset start and stop
			start = stop = undefined;
		})
});
</P><P>})(jQuery)
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2013.igem.org/Team:UESTC/jquerypp.custom.js">http://2013.igem.org/Team:UESTC/jquerypp.custom.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:UESTC/jquerypp.custom.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:UESTC/jquerypp.custom.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:UESTC/jquerypp.custom.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:UESTC/jquerypp.custom.js&amp;oldid=85628" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2013.igem.org:Privacy_policy" title="2013.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2013.igem.org:General_disclaimer" title="2013.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_TU-Eindhoven_JS_Flot"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:TU-Eindhoven/JS:Flot">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:TU-Eindhoven/JS:Flot&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:TU-Eindhoven/JS:Flot&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:TU-Eindhoven/JS:Flot&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:TU-Eindhoven/JS:Flot" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:TU-Eindhoven/JS:Flot</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2013.igem.org</H3><P>/* Javascript plotting library for jQuery, version 0.8.1.
</P><P>Copyright (c) 2007-2013 IOLA and Ole Laursen.
Licensed under the MIT license.
</P><UL><LI>/
</LI></UL><P>// first an inline dependency, jquery.colorhelpers.js, we inline it here
// for convenience
</P><P>/* Plugin for jQuery for working with colors.
</P><PRE>*
* Version 1.1.
*
* Inspiration from jQuery color animation plugin by John Resig.
*
* Released under the MIT license by Ole Laursen, October 2009.
*
* Examples:
*
*   $.color.parse(&quot;#fff&quot;).scale('rgb', 0.25).add('a', -0.5).toString()
*   var c = $.color.extract($(&quot;#mydiv&quot;), 'background-color');
*   console.log(c.r, c.g, c.b, c.a);
*   $.color.make(100, 50, 25, 0.4).toString() // returns &quot;rgba(100,50,25,0.4)&quot;
*
* Note that .scale() and .add() return the same modified object
* instead of making a new one.
*
* V. 1.1: Fix error handling so e.g. parsing an empty string does
* produce a color rather than just crashing.
*/
</PRE><P>(function(B){B.color={};B.color.make=function(F,E,C,D){var G={};G.r=F||0;G.g=E||0;G.b=C||0;G.a=D!=null?D:1;G.add=function(J,I){for(var H=0;H&lt;J.length;++H){G[J.charAt(H)]+=I}return G.normalize()};G.scale=function(J,I){for(var H=0;H&lt;J.length;++H){G[J.charAt(H)]*=I}return G.normalize()};G.toString=function(){if(G.a&gt;=1){return&quot;rgb(&quot;+[G.r,G.g,G.b].join(&quot;,&quot;)+&quot;)&quot;}else{return&quot;rgba(&quot;+[G.r,G.g,G.b,G.a].join(&quot;,&quot;)+&quot;)&quot;}};G.normalize=function(){function H(J,K,I){return K&lt;J?J:(K&gt;I?I:K)}G.r=H(0,parseInt(G.r),255);G.g=H(0,parseInt(G.g),255);G.b=H(0,parseInt(G.b),255);G.a=H(0,G.a,1);return G};G.clone=function(){return B.color.make(G.r,G.b,G.g,G.a)};return G.normalize()};B.color.extract=function(D,C){var E;do{E=D.css(C).toLowerCase();if(E!=&quot;&quot;&amp;&amp;E!=&quot;transparent&quot;){break}D=D.parent()}while(!B.nodeName(D.get(0),&quot;body&quot;));if(E==&quot;rgba(0, 0, 0, 0)&quot;){E=&quot;transparent&quot;}return B.color.parse(E)};B.color.parse=function(F){var E,C=B.color.make;if(E=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(F)){
	return C(parseInt(E[1],10),parseInt(E[2],10),parseInt(E[3],10))}if(E=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(F)){return C(parseInt(E[1],10),parseInt(E[2],10),parseInt(E[3],10),parseFloat(E[4]))}if(E=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(F)){return C(parseFloat(E[1])*2.55,parseFloat(E[2])*2.55,parseFloat(E[3])*2.55)}if(E=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(F)){return C(parseFloat(E[1])*2.55,parseFloat(E[2])*2.55,parseFloat(E[3])*2.55,parseFloat(E[4]))}if(E=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(F)){return C(parseInt(E[1],16),parseInt(E[2],16),parseInt(E[3],16))}if(E=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(F)){return C(parseInt(E[1]+E[1],16),parseInt(E[2]+E[2],16),parseInt(E[3]+E[3],16))}var D=B.trim(F).toLowerCase();if(D==&quot;transparent&quot;){return C(255,255,255,0)}else{E=A[D]||[0,0,0];
return C(E[0],E[1],E[2])}};var A={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);
</P><P>// the actual Flot code
(function($) {
</P><P>	// Cache the prototype hasOwnProperty for faster access
</P><P>	var hasOwnProperty = Object.prototype.hasOwnProperty;
</P><P>	///////////////////////////////////////////////////////////////////////////
	// The Canvas object is a wrapper around an HTML5 &lt;canvas&gt; tag.
	//
	// @constructor
	// @param {string} cls List of classes to apply to the canvas.
	// @param {element} container Element onto which to append the canvas.
	//
	// Requiring a container is a little iffy, but unfortunately canvas
	// operations don't work unless the canvas is attached to the DOM.
</P><P>	function Canvas(cls, container) {
</P><P>		var element = container.children(&quot;.&quot; + cls)[0];
</P><P>		if (element == null) {
</P><P>			element = document.createElement(&quot;canvas&quot;);
			element.className = cls;
</P><P>			$(element).css({ direction: &quot;ltr&quot;, position: &quot;absolute&quot;, left: 0, top: 0 })
				.appendTo(container);
</P><P>			// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas
</P><P>			if (!element.getContext) {
				if (window.G_vmlCanvasManager) {
					element = window.G_vmlCanvasManager.initElement(element);
				} else {
					throw new Error(&quot;Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.&quot;);
				}
			}
		}
</P><P>		this.element = element;
</P><P>		var context = this.context = element.getContext(&quot;2d&quot;);
</P><P>		// Determine the screen's ratio of physical to device-independent
		// pixels.  This is the ratio between the canvas width that the browser
		// advertises and the number of pixels actually present in that space.
</P><P>		// The iPhone 4, for example, has a device-independent width of 320px,
		// but its screen is actually 640px wide.  It therefore has a pixel
		// ratio of 2, while most normal devices have a ratio of 1.
</P><P>		var devicePixelRatio = window.devicePixelRatio || 1,
			backingStoreRatio =
				context.webkitBackingStorePixelRatio ||
				context.mozBackingStorePixelRatio ||
				context.msBackingStorePixelRatio ||
				context.oBackingStorePixelRatio ||
				context.backingStorePixelRatio || 1;
</P><P>		this.pixelRatio = devicePixelRatio / backingStoreRatio;
</P><P>		// Size the canvas to match the internal dimensions of its container
</P><P>		this.resize(container.width(), container.height());
</P><P>		// Collection of HTML div layers for text overlaid onto the canvas
</P><P>		this.textContainer = null;
		this.text = {};
</P><P>		// Cache of text fragments and metrics, so we can avoid expensively
		// re-calculating them when the plot is re-rendered in a loop.
</P><P>		this._textCache = {};
	}
</P><P>	// Resizes the canvas to the given dimensions.
	//
	// @param {number} width New width of the canvas, in pixels.
	// @param {number} width New height of the canvas, in pixels.
</P><P>	Canvas.prototype.resize = function(width, height) {
</P><P>		if (width &lt;= 0 || height &lt;= 0) {
			throw new Error(&quot;Invalid dimensions for plot, width = &quot; + width + &quot;, height = &quot; + height);
		}
</P><P>		var element = this.element,
			context = this.context,
			pixelRatio = this.pixelRatio;
</P><P>		// Resize the canvas, increasing its density based on the display's
		// pixel ratio; basically giving it more pixels without increasing the
		// size of its element, to take advantage of the fact that retina
		// displays have that many more pixels in the same advertised space.
</P><P>		// Resizing should reset the state (excanvas seems to be buggy though)
</P><P>		if (this.width != width) {
			element.width = width * pixelRatio;
			element.style.width = width + &quot;px&quot;;
			this.width = width;
		}
</P><P>		if (this.height != height) {
			element.height = height * pixelRatio;
			element.style.height = height + &quot;px&quot;;
			this.height = height;
		}
</P><P>		// Save the context, so we can reset in case we get replotted.  The
		// restore ensure that we're really back at the initial state, and
		// should be safe even if we haven't saved the initial state yet.
</P><P>		context.restore();
		context.save();
</P><P>		// Scale the coordinate space to match the display density; so even though we
		// may have twice as many pixels, we still want lines and other drawing to
		// appear at the same size; the extra pixels will just make them crisper.
</P><P>		context.scale(pixelRatio, pixelRatio);
	};
</P><P>	// Clears the entire canvas area, not including any overlaid HTML text
</P><P>	Canvas.prototype.clear = function() {
		this.context.clearRect(0, 0, this.width, this.height);
	};
</P><P>	// Finishes rendering the canvas, including managing the text overlay.
</P><P>	Canvas.prototype.render = function() {
</P><P>		var cache = this._textCache;
</P><P>		// For each text layer, add elements marked as active that haven't
		// already been rendered, and remove those that are no longer active.
</P><P>		for (var layerKey in cache) {
			if (hasOwnProperty.call(cache, layerKey)) {
</P><P>				var layer = this.getTextLayer(layerKey),
					layerCache = cache[layerKey];
</P><P>				layer.hide();
</P><P>				for (var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for (var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {
</P><P>								var positions = styleCache[key].positions;
</P><P>								for (var i = 0, position; position = positions[i]; i++) {
									if (position.active) {
										if (!position.rendered) {
											layer.append(position.element);
											position.rendered = true;
										}
									} else {
										positions.splice(i--, 1);
										if (position.rendered) {
											position.element.detach();
										}
									}
								}
</P><P>								if (positions.length == 0) {
									delete styleCache[key];
								}
							}
						}
					}
				}
</P><P>				layer.show();
			}
		}
	};
</P><P>	// Creates (if necessary) and returns the text overlay container.
	//
	// @param {string} classes String of space-separated CSS classes used to
	//     uniquely identify the text layer.
	// @return {object} The jQuery-wrapped text-layer div.
</P><P>	Canvas.prototype.getTextLayer = function(classes) {
</P><P>		var layer = this.text[classes];
</P><P>		// Create the text layer if it doesn't exist
</P><P>		if (layer == null) {
</P><P>			// Create the text layer container, if it doesn't exist
</P><P>			if (this.textContainer == null) {
</P>
				this.textContainer = $(&quot;&quot;)
<P>					.css({
						position: &quot;absolute&quot;,
						top: 0,
						left: 0,
						bottom: 0,
						right: 0,
						'font-size': &quot;smaller&quot;,
						color: &quot;#545454&quot;
					})
					.insertAfter(this.element);
			}
</P>
			layer = this.text[classes] = $(&quot;&quot;)
<P>				.addClass(classes)
				.css({
					position: &quot;absolute&quot;,
					top: 0,
					left: 0,
					bottom: 0,
					right: 0
				})
				.appendTo(this.textContainer);
		}
</P><P>		return layer;
	};
</P><P>	// Creates (if necessary) and returns a text info object.
	//
	// The object looks like this:
	//
	// {
	//     width: Width of the text's wrapper div.
	//     height: Height of the text's wrapper div.
	//     element: The jQuery-wrapped HTML div containing the text.
	//     positions: Array of positions at which this text is drawn.
	// }
	//
	// The positions array contains objects that look like this:
	//
	// {
	//     active: Flag indicating whether the text should be visible.
	//     rendered: Flag indicating whether the text is currently visible.
	//     element: The jQuery-wrapped HTML div containing the text.
	//     x: X coordinate at which to draw the text.
	//     y: Y coordinate at which to draw the text.
	// }
	//
	// Each position after the first receives a clone of the original element.
	//
	// The idea is that that the width, height, and general 'identity' of the
	// text is constant no matter where it is placed; the placements are a
	// secondary property.
	//
	// Canvas maintains a cache of recently-used text info objects; getTextInfo
	// either returns the cached element or creates a new entry.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {string} text Text string to retrieve info for.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which to rotate the text, in degrees.
	//     Angle is currently unused, it will be implemented in the future.
	// @param {number=} width Maximum width of the text before it wraps.
	// @return {object} a text info object.
</P><P>	Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {
</P><P>		var textStyle, layerCache, styleCache, info;
</P><P>		// Cast the value to a string, in case we were given a number or such
</P><P>		text = &quot;&quot; + text;
</P><P>		// If the font is a font-spec object, generate a CSS font definition
</P><P>		if (typeof font === &quot;object&quot;) {
			textStyle = font.style + &quot; &quot; + font.variant + &quot; &quot; + font.weight + &quot; &quot; + font.size + &quot;px/&quot; + font.lineHeight + &quot;px &quot; + font.family;
		} else {
			textStyle = font;
		}
</P><P>		// Retrieve (or create) the cache for the text's layer and styles
</P><P>		layerCache = this._textCache[layer];
</P><P>		if (layerCache == null) {
			layerCache = this._textCache[layer] = {};
		}
</P><P>		styleCache = layerCache[textStyle];
</P><P>		if (styleCache == null) {
			styleCache = layerCache[textStyle] = {};
		}
</P><P>		info = styleCache[text];
</P><P>		// If we can't find a matching element in our cache, create a new one
</P><P>		if (info == null) {
</P>
			var element = $(&quot;&quot;).html(text)
<P>				.css({
					position: &quot;absolute&quot;,
					'max-width': width,
					top: -9999
				})
				.appendTo(this.getTextLayer(layer));
</P><P>			if (typeof font === &quot;object&quot;) {
				element.css({
					font: textStyle,
					color: font.color
				});
			} else if (typeof font === &quot;string&quot;) {
				element.addClass(font);
			}
</P><P>			info = styleCache[text] = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				element: element,
				positions: []
			};
</P><P>			element.detach();
		}
</P><P>		return info;
	};
</P><P>	// Adds a text string to the canvas text overlay.
	//
	// The text isn't drawn immediately; it is marked as rendering, which will
	// result in its addition to the canvas on the next render pass.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {number} x X coordinate at which to draw the text.
	// @param {number} y Y coordinate at which to draw the text.
	// @param {string} text Text string to draw.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which to rotate the text, in degrees.
	//     Angle is currently unused, it will be implemented in the future.
	// @param {number=} width Maximum width of the text before it wraps.
	// @param {string=} halign Horizontal alignment of the text; either &quot;left&quot;,
	//     &quot;center&quot; or &quot;right&quot;.
	// @param {string=} valign Vertical alignment of the text; either &quot;top&quot;,
	//     &quot;middle&quot; or &quot;bottom&quot;.
</P><P>	Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {
</P><P>		var info = this.getTextInfo(layer, text, font, angle, width),
			positions = info.positions;
</P><P>		// Tweak the div's position to match the text's alignment
</P><P>		if (halign == &quot;center&quot;) {
			x -= info.width / 2;
		} else if (halign == &quot;right&quot;) {
			x -= info.width;
		}
</P><P>		if (valign == &quot;middle&quot;) {
			y -= info.height / 2;
		} else if (valign == &quot;bottom&quot;) {
			y -= info.height;
		}
</P><P>		// Determine whether this text already exists at this position.
		// If so, mark it for inclusion in the next render pass.
</P><P>		for (var i = 0, position; position = positions[i]; i++) {
			if (position.x == x &amp;&amp; position.y == y) {
				position.active = true;
				return;
			}
		}
</P><P>		// If the text doesn't exist at this position, create a new entry
</P><P>		// For the very first position we'll re-use the original element,
		// while for subsequent ones we'll clone it.
</P><P>		position = {
			active: true,
			rendered: false,
			element: positions.length ? info.element.clone() : info.element,
			x: x,
			y: y
		}
</P><P>		positions.push(position);
</P><P>		// Move the element to its final position within the container
</P><P>		position.element.css({
			top: Math.round(y),
			left: Math.round(x),
			'text-align': halign	// In case the text wraps
		});
	};
</P><P>	// Removes one or more text strings from the canvas text overlay.
	//
	// If no parameters are given, all text within the layer is removed.
	//
	// Note that the text is not immediately removed; it is simply marked as
	// inactive, which will result in its removal on the next render pass.
	// This avoids the performance penalty for 'clear and redraw' behavior,
	// where we potentially get rid of all text on a layer, but will likely
	// add back most or all of it later, as when redrawing axes, for example.
	//
	// @param {string} layer A string of space-separated CSS classes uniquely
	//     identifying the layer containing this text.
	// @param {number=} x X coordinate of the text.
	// @param {number=} y Y coordinate of the text.
	// @param {string=} text Text string to remove.
	// @param {(string|object)=} font Either a string of space-separated CSS
	//     classes or a font-spec object, defining the text's font and style.
	// @param {number=} angle Angle at which the text is rotated, in degrees.
	//     Angle is currently unused, it will be implemented in the future.
</P><P>	Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {
		if (text == null) {
			var layerCache = this._textCache[layer];
			if (layerCache != null) {
				for (var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for (var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {
								var positions = styleCache[key].positions;
								for (var i = 0, position; position = positions[i]; i++) {
									position.active = false;
								}
							}
						}
					}
				}
			}
		} else {
			var positions = this.getTextInfo(layer, text, font, angle).positions;
			for (var i = 0, position; position = positions[i]; i++) {
				if (position.x == x &amp;&amp; position.y == y) {
					position.active = false;
				}
			}
		}
	};
</P><P>	///////////////////////////////////////////////////////////////////////////
	// The top-level container for the entire plot.
</P><PRE>   function Plot(placeholder, data_, options_, plugins) {
       // data is on the form:
       //   [ series1, series2 ... ]
       // where series is either just the data as [ [x1, y1], [x2, y2], ... ]
       // or { data: [ [x1, y1], [x2, y2], ... ], label: &quot;some label&quot;, ... }
</PRE><PRE>       var series = [],
           options = {
               // the color theme used for graphs
               colors: [&quot;#edc240&quot;, &quot;#afd8f8&quot;, &quot;#cb4b4b&quot;, &quot;#4da74d&quot;, &quot;#9440ed&quot;],
               legend: {
                   show: true,
                   noColumns: 1, // number of colums in legend table
                   labelFormatter: null, // fn: string -&gt; string
                   labelBoxBorderColor: &quot;#ccc&quot;, // border color for the little label boxes
                   container: null, // container (as jQuery object) to put legend in, null means default on top of graph
                   position: &quot;ne&quot;, // position of default legend container within plot
                   margin: 5, // distance from grid edge to default legend container within plot
                   backgroundColor: null, // null means auto-detect
                   backgroundOpacity: 0.85, // set to 0 to avoid background
                   sorted: null    // default to no legend sorting
               },
               xaxis: {
                   show: null, // null = auto-detect, true = always, false = never
                   position: &quot;bottom&quot;, // or &quot;top&quot;
                   mode: null, // null or &quot;time&quot;
                   font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: &quot;italic&quot;, weight: &quot;bold&quot;, family: &quot;sans-serif&quot;, variant: &quot;small-caps&quot; }
                   color: null, // base color, labels, ticks
                   tickColor: null, // possibly different color of ticks, e.g. &quot;rgba(0,0,0,0.15)&quot;
                   transform: null, // null or f: number -&gt; number to transform axis
                   inverseTransform: null, // if transform is set, this should be the inverse function
                   min: null, // min. value to show, null means set automatically
                   max: null, // max. value to show, null means set automatically
                   autoscaleMargin: null, // margin in % to add if auto-setting min/max
                   ticks: null, // either [1, 3] or [[1, &quot;a&quot;], 3] or (fn: axis info -&gt; ticks) or app. number of ticks for auto-ticks
                   tickFormatter: null, // fn: number -&gt; string
                   labelWidth: null, // size of tick labels in pixels
                   labelHeight: null,
                   reserveSpace: null, // whether to reserve space even if axis isn't shown
                   tickLength: null, // size in pixels of ticks, or &quot;full&quot; for whole line
                   alignTicksWithAxis: null, // axis number or null for no sync
                   tickDecimals: null, // no. of decimals, null means auto
                   tickSize: null, // number or [number, &quot;unit&quot;]
                   minTickSize: null // number or [number, &quot;unit&quot;]
               },
               yaxis: {
                   autoscaleMargin: 0.02,
                   position: &quot;left&quot; // or &quot;right&quot;
               },
               xaxes: [],
               yaxes: [],
               series: {
                   points: {
                       show: false,
                       radius: 3,
                       lineWidth: 2, // in pixels
                       fill: true,
                       fillColor: &quot;#ffffff&quot;,
                       symbol: &quot;circle&quot; // or callback
                   },
                   lines: {
                       // we don't put in show: false so we can see
                       // whether lines were actively disabled
                       lineWidth: 2, // in pixels
                       fill: false,
                       fillColor: null,
                       steps: false
                       // Omit 'zero', so we can later default its value to
                       // match that of the 'fill' option.
                   },
                   bars: {
                       show: false,
                       lineWidth: 2, // in pixels
                       barWidth: 1, // in units of the x axis
                       fill: true,
                       fillColor: null,
                       align: &quot;left&quot;, // &quot;left&quot;, &quot;right&quot;, or &quot;center&quot;
                       horizontal: false,
                       zero: true
                   },
                   shadowSize: 3,
                   highlightColor: null
               },
               grid: {
                   show: true,
                   aboveData: false,
                   color: &quot;#545454&quot;, // primary color used for outline and labels
                   backgroundColor: null, // null for transparent, else color
                   borderColor: null, // set if different from the grid color
                   tickColor: null, // color for the ticks, e.g. &quot;rgba(0,0,0,0.15)&quot;
                   margin: 0, // distance from the canvas edge to the grid
                   labelMargin: 5, // in pixels
                   axisMargin: 8, // in pixels
                   borderWidth: 2, // in pixels
                   minBorderMargin: null, // in pixels, null means taken from points radius
                   markings: null, // array of ranges or fn: axes -&gt; array of ranges
                   markingsColor: &quot;#f4f4f4&quot;,
                   markingsLineWidth: 2,
                   // interactive stuff
                   clickable: false,
                   hoverable: false,
                   autoHighlight: true, // highlight in case mouse is near
                   mouseActiveRadius: 10 // how far the mouse can be away to activate an item
               },
               interaction: {
                   redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow
               },
               hooks: {}
           },
       surface = null,     // the canvas for the plot itself
       overlay = null,     // canvas for interactive stuff on top of plot
       eventHolder = null, // jQuery object that events should be bound to
       ctx = null, octx = null,
       xaxes = [], yaxes = [],
       plotOffset = { left: 0, right: 0, top: 0, bottom: 0},
       plotWidth = 0, plotHeight = 0,
       hooks = {
           processOptions: [],
           processRawData: [],
           processDatapoints: [],
           processOffset: [],
           drawBackground: [],
           drawSeries: [],
           draw: [],
           bindEvents: [],
           drawOverlay: [],
           shutdown: []
       },
       plot = this;
</PRE><PRE>       // public functions
       plot.setData = setData;
       plot.setupGrid = setupGrid;
       plot.draw = draw;
       plot.getPlaceholder = function() { return placeholder; };
       plot.getCanvas = function() { return surface.element; };
       plot.getPlotOffset = function() { return plotOffset; };
       plot.width = function () { return plotWidth; };
       plot.height = function () { return plotHeight; };
       plot.offset = function () {
           var o = eventHolder.offset();
           o.left += plotOffset.left;
           o.top += plotOffset.top;
           return o;
       };
       plot.getData = function () { return series; };
       plot.getAxes = function () {
           var res = {}, i;
           $.each(xaxes.concat(yaxes), function (_, axis) {
               if (axis)
                   res[axis.direction + (axis.n != 1 ? axis.n : &quot;&quot;) + &quot;axis&quot;] = axis;
           });
           return res;
       };
       plot.getXAxes = function () { return xaxes; };
       plot.getYAxes = function () { return yaxes; };
       plot.c2p = canvasToAxisCoords;
       plot.p2c = axisToCanvasCoords;
       plot.getOptions = function () { return options; };
       plot.highlight = highlight;
       plot.unhighlight = unhighlight;
       plot.triggerRedrawOverlay = triggerRedrawOverlay;
       plot.pointOffset = function(point) {
           return {
               left: parseInt(xaxes[axisNumber(point, &quot;x&quot;) - 1].p2c(+point.x) + plotOffset.left, 10),
               top: parseInt(yaxes[axisNumber(point, &quot;y&quot;) - 1].p2c(+point.y) + plotOffset.top, 10)
           };
       };
       plot.shutdown = shutdown;
       plot.resize = function () {
       	var width = placeholder.width(),
       		height = placeholder.height();
           surface.resize(width, height);
           overlay.resize(width, height);
       };
</PRE><PRE>       // public attributes
       plot.hooks = hooks;
</PRE><PRE>       // initialize
       initPlugins(plot);
       parseOptions(options_);
       setupCanvases();
       setData(data_);
       setupGrid();
       draw();
       bindEvents();
</PRE><PRE>       function executeHooks(hook, args) {
           args = [plot].concat(args);
           for (var i = 0; i &lt; hook.length; ++i)
               hook[i].apply(this, args);
       }
</PRE><PRE>       function initPlugins() {
</PRE><PRE>           // References to key classes, allowing plugins to modify them
</PRE><PRE>           var classes = {
               Canvas: Canvas
           };
</PRE><PRE>           for (var i = 0; i &lt; plugins.length; ++i) {
               var p = plugins[i];
               p.init(plot, classes);
               if (p.options)
                   $.extend(true, options, p.options);
           }
       }
</PRE><PRE>       function parseOptions(opts) {
</PRE><PRE>           $.extend(true, options, opts);
</PRE><PRE>           // $.extend merges arrays, rather than replacing them.  When less
           // colors are provided than the size of the default palette, we
           // end up with those colors plus the remaining defaults, which is
           // not expected behavior; avoid it by replacing them here.
</PRE><PRE>           if (opts &amp;&amp; opts.colors) {
           	options.colors = opts.colors;
           }
</PRE><PRE>           if (options.xaxis.color == null)
               options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
           if (options.yaxis.color == null)
               options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();
</PRE><PRE>           if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility
               options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;
           if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility
               options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;
</PRE><PRE>           if (options.grid.borderColor == null)
               options.grid.borderColor = options.grid.color;
           if (options.grid.tickColor == null)
               options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();
</PRE><PRE>           // Fill in defaults for axis options, including any unspecified
           // font-spec fields, if a font-spec was provided.
</PRE><PRE>           // If no x/y axis options were provided, create one of each anyway,
           // since the rest of the code assumes that they exist.
</PRE><PRE>           var i, axisOptions, axisCount,
               fontDefaults = {
                   style: placeholder.css(&quot;font-style&quot;),
                   size: Math.round(0.8 * (+placeholder.css(&quot;font-size&quot;).replace(&quot;px&quot;, &quot;&quot;) || 13)),
                   variant: placeholder.css(&quot;font-variant&quot;),
                   weight: placeholder.css(&quot;font-weight&quot;),
                   family: placeholder.css(&quot;font-family&quot;)
               };
</PRE><PRE>           fontDefaults.lineHeight = fontDefaults.size * 1.15;
</PRE><PRE>           axisCount = options.xaxes.length || 1;
           for (i = 0; i &lt; axisCount; ++i) {
</PRE><PRE>               axisOptions = options.xaxes[i];
               if (axisOptions &amp;&amp; !axisOptions.tickColor) {
                   axisOptions.tickColor = axisOptions.color;
               }
</PRE><PRE>               axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
               options.xaxes[i] = axisOptions;
</PRE><PRE>               if (axisOptions.font) {
                   axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                   if (!axisOptions.font.color) {
                       axisOptions.font.color = axisOptions.color;
                   }
               }
           }
</PRE><PRE>           axisCount = options.yaxes.length || 1;
           for (i = 0; i &lt; axisCount; ++i) {
</PRE><PRE>               axisOptions = options.yaxes[i];
               if (axisOptions &amp;&amp; !axisOptions.tickColor) {
                   axisOptions.tickColor = axisOptions.color;
               }
</PRE><PRE>               axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
               options.yaxes[i] = axisOptions;
</PRE><PRE>               if (axisOptions.font) {
                   axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);
                   if (!axisOptions.font.color) {
                       axisOptions.font.color = axisOptions.color;
                   }
               }
           }
</PRE><PRE>           // backwards compatibility, to be removed in future
           if (options.xaxis.noTicks &amp;&amp; options.xaxis.ticks == null)
               options.xaxis.ticks = options.xaxis.noTicks;
           if (options.yaxis.noTicks &amp;&amp; options.yaxis.ticks == null)
               options.yaxis.ticks = options.yaxis.noTicks;
           if (options.x2axis) {
               options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);
               options.xaxes[1].position = &quot;top&quot;;
           }
           if (options.y2axis) {
               options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);
               options.yaxes[1].position = &quot;right&quot;;
           }
           if (options.grid.coloredAreas)
               options.grid.markings = options.grid.coloredAreas;
           if (options.grid.coloredAreasColor)
               options.grid.markingsColor = options.grid.coloredAreasColor;
           if (options.lines)
               $.extend(true, options.series.lines, options.lines);
           if (options.points)
               $.extend(true, options.series.points, options.points);
           if (options.bars)
               $.extend(true, options.series.bars, options.bars);
           if (options.shadowSize != null)
               options.series.shadowSize = options.shadowSize;
           if (options.highlightColor != null)
               options.series.highlightColor = options.highlightColor;
</PRE><PRE>           // save options on axes for future reference
           for (i = 0; i &lt; options.xaxes.length; ++i)
               getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];
           for (i = 0; i &lt; options.yaxes.length; ++i)
               getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];
</PRE><PRE>           // add hooks from options
           for (var n in hooks)
               if (options.hooks[n] &amp;&amp; options.hooks[n].length)
                   hooks[n] = hooks[n].concat(options.hooks[n]);
</PRE><PRE>           executeHooks(hooks.processOptions, [options]);
       }
</PRE><PRE>       function setData(d) {
           series = parseData(d);
           fillInSeriesOptions();
           processData();
       }
</PRE><PRE>       function parseData(d) {
           var res = [];
           for (var i = 0; i &lt; d.length; ++i) {
               var s = $.extend(true, {}, options.series);
</PRE><PRE>               if (d[i].data != null) {
                   s.data = d[i].data; // move the data instead of deep-copy
                   delete d[i].data;
</PRE><PRE>                   $.extend(true, s, d[i]);
</PRE><PRE>                   d[i].data = s.data;
               }
               else
                   s.data = d[i];
               res.push(s);
           }
</PRE><PRE>           return res;
       }
</PRE><PRE>       function axisNumber(obj, coord) {
           var a = obj[coord + &quot;axis&quot;];
           if (typeof a == &quot;object&quot;) // if we got a real axis, extract number
               a = a.n;
           if (typeof a != &quot;number&quot;)
               a = 1; // default to first axis
           return a;
       }
</PRE><PRE>       function allAxes() {
           // return flat array without annoying null entries
           return $.grep(xaxes.concat(yaxes), function (a) { return a; });
       }
</PRE><PRE>       function canvasToAxisCoords(pos) {
           // return an object with x/y corresponding to all used axes
           var res = {}, i, axis;
           for (i = 0; i &lt; xaxes.length; ++i) {
               axis = xaxes[i];
               if (axis &amp;&amp; axis.used)
                   res[&quot;x&quot; + axis.n] = axis.c2p(pos.left);
           }
</PRE><PRE>           for (i = 0; i &lt; yaxes.length; ++i) {
               axis = yaxes[i];
               if (axis &amp;&amp; axis.used)
                   res[&quot;y&quot; + axis.n] = axis.c2p(pos.top);
           }
</PRE><PRE>           if (res.x1 !== undefined)
               res.x = res.x1;
           if (res.y1 !== undefined)
               res.y = res.y1;
</PRE><PRE>           return res;
       }
</PRE><PRE>       function axisToCanvasCoords(pos) {
           // get canvas coords from the first pair of x/y found in pos
           var res = {}, i, axis, key;
</PRE><PRE>           for (i = 0; i &lt; xaxes.length; ++i) {
               axis = xaxes[i];
               if (axis &amp;&amp; axis.used) {
                   key = &quot;x&quot; + axis.n;
                   if (pos[key] == null &amp;&amp; axis.n == 1)
                       key = &quot;x&quot;;
</PRE><PRE>                   if (pos[key] != null) {
                       res.left = axis.p2c(pos[key]);
                       break;
                   }
               }
           }
</PRE><PRE>           for (i = 0; i &lt; yaxes.length; ++i) {
               axis = yaxes[i];
               if (axis &amp;&amp; axis.used) {
                   key = &quot;y&quot; + axis.n;
                   if (pos[key] == null &amp;&amp; axis.n == 1)
                       key = &quot;y&quot;;
</PRE><PRE>                   if (pos[key] != null) {
                       res.top = axis.p2c(pos[key]);
                       break;
                   }
               }
           }
</PRE><PRE>           return res;
       }
</PRE><PRE>       function getOrCreateAxis(axes, number) {
           if (!axes[number - 1])
               axes[number - 1] = {
                   n: number, // save the number for future reference
                   direction: axes == xaxes ? &quot;x&quot; : &quot;y&quot;,
                   options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)
               };
</PRE><PRE>           return axes[number - 1];
       }
</PRE><PRE>       function fillInSeriesOptions() {
</PRE><PRE>           var neededColors = series.length, maxIndex = -1, i;
</PRE><PRE>           // Subtract the number of series that already have fixed colors or
           // color indexes from the number that we still need to generate.
</PRE><PRE>           for (i = 0; i &lt; series.length; ++i) {
               var sc = series[i].color;
               if (sc != null) {
                   neededColors--;
                   if (typeof sc == &quot;number&quot; &amp;&amp; sc &gt; maxIndex) {
                       maxIndex = sc;
                   }
               }
           }
</PRE><PRE>           // If any of the series have fixed color indexes, then we need to
           // generate at least as many colors as the highest index.
</PRE><PRE>           if (neededColors &lt;= maxIndex) {
               neededColors = maxIndex + 1;
           }
</PRE><PRE>           // Generate all the colors, using first the option colors and then
           // variations on those colors once they're exhausted.
</PRE><PRE>           var c, colors = [], colorPool = options.colors,
               colorPoolSize = colorPool.length, variation = 0;
</PRE><PRE>           for (i = 0; i &lt; neededColors; i++) {
</PRE><PRE>               c = $.color.parse(colorPool[i % colorPoolSize] || &quot;#666&quot;);
</PRE><PRE>               // Each time we exhaust the colors in the pool we adjust
               // a scaling factor used to produce more variations on
               // those colors. The factor alternates negative/positive
               // to produce lighter/darker colors.
</PRE><PRE>               // Reset the variation after every few cycles, or else
               // it will end up producing only white or black colors.
</PRE><PRE>               if (i % colorPoolSize == 0 &amp;&amp; i) {
                   if (variation &gt;= 0) {
                       if (variation &lt; 0.5) {
                           variation = -variation - 0.2;
                       } else variation = 0;
                   } else variation = -variation;
               }
</PRE><PRE>               colors[i] = c.scale('rgb', 1 + variation);
           }
</PRE><PRE>           // Finalize the series options, filling in their colors
</PRE><PRE>           var colori = 0, s;
           for (i = 0; i &lt; series.length; ++i) {
               s = series[i];
</PRE><PRE>               // assign colors
               if (s.color == null) {
                   s.color = colors[colori].toString();
                   ++colori;
               }
               else if (typeof s.color == &quot;number&quot;)
                   s.color = colors[s.color].toString();
</PRE><PRE>               // turn on lines automatically in case nothing is set
               if (s.lines.show == null) {
                   var v, show = true;
                   for (v in s)
                       if (s[v] &amp;&amp; s[v].show) {
                           show = false;
                           break;
                       }
                   if (show)
                       s.lines.show = true;
               }
</PRE><PRE>               // If nothing was provided for lines.zero, default it to match
               // lines.fill, since areas by default should extend to zero.
</PRE><PRE>               if (s.lines.zero == null) {
                   s.lines.zero = !!s.lines.fill;
               }
</PRE><PRE>               // setup axes
               s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, &quot;x&quot;));
               s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, &quot;y&quot;));
           }
       }
</PRE><PRE>       function processData() {
           var topSentry = Number.POSITIVE_INFINITY,
               bottomSentry = Number.NEGATIVE_INFINITY,
               fakeInfinity = Number.MAX_VALUE,
               i, j, k, m, length,
               s, points, ps, x, y, axis, val, f, p,
               data, format;
</PRE><PRE>           function updateAxis(axis, min, max) {
               if (min &lt; axis.datamin &amp;&amp; min != -fakeInfinity)
                   axis.datamin = min;
               if (max &gt; axis.datamax &amp;&amp; max != fakeInfinity)
                   axis.datamax = max;
           }
</PRE><PRE>           $.each(allAxes(), function (_, axis) {
               // init axis
               axis.datamin = topSentry;
               axis.datamax = bottomSentry;
               axis.used = false;
           });
</PRE><PRE>           for (i = 0; i &lt; series.length; ++i) {
               s = series[i];
               s.datapoints = { points: [] };
</PRE><PRE>               executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);
           }
</PRE><PRE>           // first pass: clean and copy data
           for (i = 0; i &lt; series.length; ++i) {
               s = series[i];
</PRE><PRE>               data = s.data;
               format = s.datapoints.format;
</PRE><PRE>               if (!format) {
                   format = [];
                   // find out how to copy
                   format.push({ x: true, number: true, required: true });
                   format.push({ y: true, number: true, required: true });
</PRE><PRE>                   if (s.bars.show || (s.lines.show &amp;&amp; s.lines.fill)) {
                       var autoscale = !!((s.bars.show &amp;&amp; s.bars.zero) || (s.lines.show &amp;&amp; s.lines.zero));
                       format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });
                       if (s.bars.horizontal) {
                           delete format[format.length - 1].y;
                           format[format.length - 1].x = true;
                       }
                   }
</PRE><PRE>                   s.datapoints.format = format;
               }
</PRE><PRE>               if (s.datapoints.pointsize != null)
                   continue; // already filled in
</PRE><PRE>               s.datapoints.pointsize = format.length;
</PRE><PRE>           ps = s.datapoints.pointsize;
               points = s.datapoints.points;
</PRE><PRE>               var insertSteps = s.lines.show &amp;&amp; s.lines.steps;
               s.xaxis.used = s.yaxis.used = true;
</PRE><PRE>               for (j = k = 0; j &lt; data.length; ++j, k += ps) {
                   p = data[j];
</PRE><PRE>                   var nullify = p == null;
                   if (!nullify) {
                       for (m = 0; m &lt; ps; ++m) {
                           val = p[m];
                           f = format[m];
</PRE><PRE>                           if (f) {
                               if (f.number &amp;&amp; val != null) {
                                   val = +val; // convert to number
                                   if (isNaN(val))
                                       val = null;
                                   else if (val == Infinity)
                                       val = fakeInfinity;
                                   else if (val == -Infinity)
                                       val = -fakeInfinity;
                               }
</PRE><PRE>                               if (val == null) {
                                   if (f.required)
                                       nullify = true;
</PRE><PRE>                                   if (f.defaultValue != null)
                                       val = f.defaultValue;
                               }
                           }
</PRE><PRE>                           points[k + m] = val;
                       }
                   }
</PRE><PRE>                   if (nullify) {
                       for (m = 0; m &lt; ps; ++m) {
                           val = points[k + m];
                           if (val != null) {
                               f = format[m];
                               // extract min/max info
                               if (f.autoscale) {
                                   if (f.x) {
                                       updateAxis(s.xaxis, val, val);
                                   }
                                   if (f.y) {
                                       updateAxis(s.yaxis, val, val);
                                   }
                               }
                           }
                           points[k + m] = null;
                       }
                   }
                   else {
                       // a little bit of line specific stuff that
                       // perhaps shouldn't be here, but lacking
                       // better means...
                       if (insertSteps &amp;&amp; k &gt; 0
                           &amp;&amp; points[k - ps] != null
                           &amp;&amp; points[k - ps] != points[k]
                           &amp;&amp; points[k - ps + 1] != points[k + 1]) {
                           // copy the point to make room for a middle point
                           for (m = 0; m &lt; ps; ++m)
                               points[k + ps + m] = points[k + m];
</PRE><PRE>                           // middle point has same y
                           points[k + 1] = points[k - ps + 1];
</PRE><PRE>                           // we've added a point, better reflect that
                           k += ps;
                       }
                   }
               }
           }
</PRE><PRE>           // give the hooks a chance to run
           for (i = 0; i &lt; series.length; ++i) {
               s = series[i];
</PRE><PRE>               executeHooks(hooks.processDatapoints, [ s, s.datapoints]);
           }
</PRE><PRE>           // second pass: find datamax/datamin for auto-scaling
           for (i = 0; i &lt; series.length; ++i) {
               s = series[i];
               points = s.datapoints.points;
               ps = s.datapoints.pointsize;
               format = s.datapoints.format;
</PRE><PRE>               var xmin = topSentry, ymin = topSentry,
                   xmax = bottomSentry, ymax = bottomSentry;
</PRE><PRE>    for (j = 0; j &lt; points.length; j += ps) {
                   if (points[j] == null)
                       continue;
</PRE><PRE>                   for (m = 0; m &lt; ps; ++m) {
                       val = points[j + m];
                       f = format[m];
                       if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)
                           continue;
</PRE><PRE>                       if (f.x) {
                           if (val &lt; xmin)
                               xmin = val;
                           if (val &gt; xmax)
                               xmax = val;
                       }
                       if (f.y) {
                           if (val &lt; ymin)
                               ymin = val;
                           if (val &gt; ymax)
                               ymax = val;
                       }
                   }
               }
</PRE><PRE>               if (s.bars.show) {
                   // make sure we got room for the bar on the dancing floor
                   var delta;
</PRE><PRE>                   switch (s.bars.align) {
                       case &quot;left&quot;:
                           delta = 0;
                           break;
                       case &quot;right&quot;:
                           delta = -s.bars.barWidth;
                           break;
                       case &quot;center&quot;:
                           delta = -s.bars.barWidth / 2;
                           break;
                       default:
                           throw new Error(&quot;Invalid bar alignment: &quot; + s.bars.align);
                   }
</PRE><PRE>                   if (s.bars.horizontal) {
                       ymin += delta;
                       ymax += delta + s.bars.barWidth;
                   }
                   else {
                       xmin += delta;
                       xmax += delta + s.bars.barWidth;
                   }
               }
</PRE><PRE>               updateAxis(s.xaxis, xmin, xmax);
               updateAxis(s.yaxis, ymin, ymax);
           }
</PRE><PRE>           $.each(allAxes(), function (_, axis) {
               if (axis.datamin == topSentry)
                   axis.datamin = null;
               if (axis.datamax == bottomSentry)
                   axis.datamax = null;
           });
       }
</PRE><PRE>       function setupCanvases() {
</PRE><PRE>           // Make sure the placeholder is clear of everything except canvases
           // from a previous plot in this container that we'll try to re-use.
</PRE><PRE>           placeholder.css(&quot;padding&quot;, 0) // padding messes up the positioning
               .children(&quot;:not(.flot-base,.flot-overlay)&quot;).remove();
</PRE><PRE>           if (placeholder.css(&quot;position&quot;) == 'static')
               placeholder.css(&quot;position&quot;, &quot;relative&quot;); // for positioning labels and overlay
</PRE><PRE>           surface = new Canvas(&quot;flot-base&quot;, placeholder);
           overlay = new Canvas(&quot;flot-overlay&quot;, placeholder); // overlay canvas for interactive features
</PRE><PRE>           ctx = surface.context;
           octx = overlay.context;
</PRE><PRE>           // define which element we're listening for events on
           eventHolder = $(overlay.element).unbind();
</PRE><PRE>           // If we're re-using a plot object, shut down the old one
</PRE><PRE>           var existing = placeholder.data(&quot;plot&quot;);
</PRE><PRE>           if (existing) {
               existing.shutdown();
               overlay.clear();
           }
</PRE><PRE>           // save in case we get replotted
           placeholder.data(&quot;plot&quot;, plot);
       }
</PRE><PRE>       function bindEvents() {
           // bind events
           if (options.grid.hoverable) {
               eventHolder.mousemove(onMouseMove);
</PRE><PRE>               // Use bind, rather than .mouseleave, because we officially
               // still support jQuery 1.2.6, which doesn't define a shortcut
               // for mouseenter or mouseleave.  This was a bug/oversight that
               // was fixed somewhere around 1.3.x.  We can return to using
               // .mouseleave when we drop support for 1.2.6.
</PRE><PRE>               eventHolder.bind(&quot;mouseleave&quot;, onMouseLeave);
           }
</PRE><PRE>           if (options.grid.clickable)
               eventHolder.click(onClick);
</PRE><PRE>           executeHooks(hooks.bindEvents, [eventHolder]);
       }
</PRE><PRE>       function shutdown() {
           if (redrawTimeout)
               clearTimeout(redrawTimeout);
</PRE><PRE>           eventHolder.unbind(&quot;mousemove&quot;, onMouseMove);
           eventHolder.unbind(&quot;mouseleave&quot;, onMouseLeave);
           eventHolder.unbind(&quot;click&quot;, onClick);
</PRE><PRE>           executeHooks(hooks.shutdown, [eventHolder]);
       }
</PRE><PRE>       function setTransformationHelpers(axis) {
           // set helper functions on the axis, assumes plot area
           // has been computed already
</PRE><PRE>           function identity(x) { return x; }
</PRE><PRE>           var s, m, t = axis.options.transform || identity,
               it = axis.options.inverseTransform;
</PRE><PRE>           // precompute how much the axis is scaling a point
           // in canvas space
           if (axis.direction == &quot;x&quot;) {
               s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));
               m = Math.min(t(axis.max), t(axis.min));
           }
           else {
               s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));
               s = -s;
               m = Math.max(t(axis.max), t(axis.min));
           }
</PRE><PRE>           // data point to canvas coordinate
           if (t == identity) // slight optimization
               axis.p2c = function (p) { return (p - m) * s; };
           else
               axis.p2c = function (p) { return (t(p) - m) * s; };
           // canvas coordinate to data point
           if (!it)
               axis.c2p = function (c) { return m + c / s; };
           else
               axis.c2p = function (c) { return it(m + c / s); };
       }
</PRE><PRE>    function measureTickLabels(axis) {
</PRE><PRE>           var opts = axis.options,
               ticks = axis.ticks || [],
               labelWidth = opts.labelWidth || 0,
               labelHeight = opts.labelHeight || 0,
               maxWidth = labelWidth || axis.direction == &quot;x&quot; ? Math.floor(surface.width / (ticks.length || 1)) : null;
               legacyStyles = axis.direction + &quot;Axis &quot; + axis.direction + axis.n + &quot;Axis&quot;,
               layer = &quot;flot-&quot; + axis.direction + &quot;-axis flot-&quot; + axis.direction + axis.n + &quot;-axis &quot; + legacyStyles,
               font = opts.font || &quot;flot-tick-label tickLabel&quot;;
</PRE><PRE>           for (var i = 0; i &lt; ticks.length; ++i) {
</PRE><PRE>               var t = ticks[i];
</PRE><PRE>               if (!t.label)
                   continue;
</PRE><PRE>               var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);
</PRE><PRE>               labelWidth = Math.max(labelWidth, info.width);
               labelHeight = Math.max(labelHeight, info.height);
           }
</PRE><PRE>           axis.labelWidth = opts.labelWidth || labelWidth;
           axis.labelHeight = opts.labelHeight || labelHeight;
       }
</PRE><PRE>       function allocateAxisBoxFirstPhase(axis) {
           // find the bounding box of the axis by looking at label
           // widths/heights and ticks, make room by diminishing the
           // plotOffset; this first phase only looks at one
           // dimension per axis, the other dimension depends on the
           // other axes so will have to wait
</PRE><PRE>           var lw = axis.labelWidth,
               lh = axis.labelHeight,
               pos = axis.options.position,
               tickLength = axis.options.tickLength,
               axisMargin = options.grid.axisMargin,
               padding = options.grid.labelMargin,
               all = axis.direction == &quot;x&quot; ? xaxes : yaxes,
               index, innermost;
</PRE><PRE>           // determine axis margin
           var samePosition = $.grep(all, function (a) {
               return a &amp;&amp; a.options.position == pos &amp;&amp; a.reserveSpace;
           });
           if ($.inArray(axis, samePosition) == samePosition.length - 1)
               axisMargin = 0; // outermost
</PRE><PRE>           // determine tick length - if we're innermost, we can use &quot;full&quot;
           if (tickLength == null) {
               var sameDirection = $.grep(all, function (a) {
                   return a &amp;&amp; a.reserveSpace;
               });
</PRE><PRE>               innermost = $.inArray(axis, sameDirection) == 0;
               if (innermost)
                   tickLength = &quot;full&quot;;
               else
                   tickLength = 5;
           }
</PRE><PRE>           if (!isNaN(+tickLength))
               padding += +tickLength;
</PRE><PRE>           // compute box
           if (axis.direction == &quot;x&quot;) {
               lh += padding;
</PRE><PRE>               if (pos == &quot;bottom&quot;) {
                   plotOffset.bottom += lh + axisMargin;
                   axis.box = { top: surface.height - plotOffset.bottom, height: lh };
               }
               else {
                   axis.box = { top: plotOffset.top + axisMargin, height: lh };
                   plotOffset.top += lh + axisMargin;
               }
           }
           else {
               lw += padding;
</PRE><PRE>               if (pos == &quot;left&quot;) {
                   axis.box = { left: plotOffset.left + axisMargin, width: lw };
                   plotOffset.left += lw + axisMargin;
               }
               else {
                   plotOffset.right += lw + axisMargin;
                   axis.box = { left: surface.width - plotOffset.right, width: lw };
               }
           }
</PRE><PRE>            // save for future reference
           axis.position = pos;
           axis.tickLength = tickLength;
           axis.box.padding = padding;
           axis.innermost = innermost;
       }
</PRE><PRE>       function allocateAxisBoxSecondPhase(axis) {
           // now that all axis boxes have been placed in one
           // dimension, we can set the remaining dimension coordinates
           if (axis.direction == &quot;x&quot;) {
               axis.box.left = plotOffset.left - axis.labelWidth / 2;
               axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;
           }
           else {
               axis.box.top = plotOffset.top - axis.labelHeight / 2;
               axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;
           }
       }
</PRE><PRE>       function adjustLayoutForThingsStickingOut() {
           // possibly adjust plot offset to ensure everything stays
           // inside the canvas and isn't clipped off
</PRE><PRE>           var minMargin = options.grid.minBorderMargin,
               margins = { x: 0, y: 0 }, i, axis;
</PRE><PRE>           // check stuff from the plot (FIXME: this should just read
           // a value from the series, otherwise it's impossible to
           // customize)
           if (minMargin == null) {
               minMargin = 0;
               for (i = 0; i &lt; series.length; ++i)
                   minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));
           }
</PRE><PRE>           margins.x = margins.y = Math.ceil(minMargin);
</PRE><PRE>           // check axis labels, note we don't check the actual
           // labels but instead use the overall width/height to not
           // jump as much around with replots
           $.each(allAxes(), function (_, axis) {
               var dir = axis.direction;
               if (axis.reserveSpace)
                   margins[dir] = Math.ceil(Math.max(margins[dir], (dir == &quot;x&quot; ? axis.labelWidth : axis.labelHeight) / 2));
           });
</PRE><PRE>           plotOffset.left = Math.max(margins.x, plotOffset.left);
           plotOffset.right = Math.max(margins.x, plotOffset.right);
           plotOffset.top = Math.max(margins.y, plotOffset.top);
           plotOffset.bottom = Math.max(margins.y, plotOffset.bottom);
       }
</PRE><PRE>       function setupGrid() {
           var i, axes = allAxes(), showGrid = options.grid.show;
</PRE><PRE>           // Initialize the plot's offset from the edge of the canvas
</PRE><PRE>           for (var a in plotOffset) {
               var margin = options.grid.margin || 0;
               plotOffset[a] = typeof margin == &quot;number&quot; ? margin : margin[a] || 0;
           }
</PRE><PRE>           executeHooks(hooks.processOffset, [plotOffset]);
</PRE><PRE>           // If the grid is visible, add its border width to the offset
</PRE><PRE>           for (var a in plotOffset) {
               if(typeof(options.grid.borderWidth) == &quot;object&quot;) {
                   plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;
               }
               else {
                   plotOffset[a] += showGrid ? options.grid.borderWidth : 0;
               }
           }
</PRE><PRE>           // init axes
           $.each(axes, function (_, axis) {
               axis.show = axis.options.show;
               if (axis.show == null)
                   axis.show = axis.used; // by default an axis is visible if it's got data
</PRE><PRE>               axis.reserveSpace = axis.show || axis.options.reserveSpace;
</PRE><PRE>               setRange(axis);
           });
</PRE><PRE>           if (showGrid) {
</PRE><PRE>               var allocatedAxes = $.grep(axes, function (axis) { return axis.reserveSpace; });
</PRE><PRE>               $.each(allocatedAxes, function (_, axis) {
                   // make the ticks
                   setupTickGeneration(axis);
                   setTicks(axis);
                   snapRangeToTicks(axis, axis.ticks);
                   // find labelWidth/Height for axis
                   measureTickLabels(axis);
               });
</PRE><PRE>               // with all dimensions calculated, we can compute the
               // axis bounding boxes, start from the outside
               // (reverse order)
               for (i = allocatedAxes.length - 1; i &gt;= 0; --i)
                   allocateAxisBoxFirstPhase(allocatedAxes[i]);
</PRE><PRE>               // make sure we've got enough space for things that
               // might stick out
               adjustLayoutForThingsStickingOut();
</PRE><PRE>               $.each(allocatedAxes, function (_, axis) {
                   allocateAxisBoxSecondPhase(axis);
               });
           }
</PRE><PRE>           plotWidth = surface.width - plotOffset.left - plotOffset.right;
           plotHeight = surface.height - plotOffset.bottom - plotOffset.top;
</PRE><PRE>           // now we got the proper plot dimensions, we can compute the scaling
           $.each(axes, function (_, axis) {
               setTransformationHelpers(axis);
           });
</PRE><PRE>           if (showGrid) {
               drawAxisLabels();
           }
</PRE><PRE>           insertLegend();
       }
</PRE><PRE>       function setRange(axis) {
           var opts = axis.options,
               min = +(opts.min != null ? opts.min : axis.datamin),
               max = +(opts.max != null ? opts.max : axis.datamax),
               delta = max - min;
</PRE><PRE>           if (delta == 0.0) {
               // degenerate case
               var widen = max == 0 ? 1 : 0.01;
</PRE><PRE>               if (opts.min == null)
                   min -= widen;
               // always widen max if we couldn't widen min to ensure we
               // don't fall into min == max which doesn't work
               if (opts.max == null || opts.min != null)
                   max += widen;
           }
           else {
               // consider autoscaling
               var margin = opts.autoscaleMargin;
               if (margin != null) {
                   if (opts.min == null) {
                       min -= delta * margin;
                       // make sure we don't go below zero if all values
                       // are positive
                       if (min &lt; 0 &amp;&amp; axis.datamin != null &amp;&amp; axis.datamin &gt;= 0)
                           min = 0;
                   }
                   if (opts.max == null) {
                       max += delta * margin;
                       if (max &gt; 0 &amp;&amp; axis.datamax != null &amp;&amp; axis.datamax &lt;= 0)
                           max = 0;
                   }
               }
           }
           axis.min = min;
           axis.max = max;
       }
</PRE><PRE>       function setupTickGeneration(axis) {
           var opts = axis.options;
</PRE><PRE>           // estimate number of ticks
           var noTicks;
           if (typeof opts.ticks == &quot;number&quot; &amp;&amp; opts.ticks &gt; 0)
               noTicks = opts.ticks;
           else
               // heuristic based on the model a*sqrt(x) fitted to
               // some data points that seemed reasonable
               noTicks = 0.3 * Math.sqrt(axis.direction == &quot;x&quot; ? surface.width : surface.height);
</PRE><PRE>           var delta = (axis.max - axis.min) / noTicks,
               dec = -Math.floor(Math.log(delta) / Math.LN10),
               maxDec = opts.tickDecimals;
</PRE><PRE>           if (maxDec != null &amp;&amp; dec &gt; maxDec) {
               dec = maxDec;
           }
</PRE><PRE>           var magn = Math.pow(10, -dec),
               norm = delta / magn, // norm is between 1.0 and 10.0
               size;
</PRE><PRE>           if (norm &lt; 1.5) {
               size = 1;
           } else if (norm &lt; 3) {
               size = 2;
               // special case for 2.5, requires an extra decimal
               if (norm &gt; 2.25 &amp;&amp; (maxDec == null || dec + 1 &lt;= maxDec)) {
                   size = 2.5;
                   ++dec;
               }
           } else if (norm &lt; 7.5) {
               size = 5;
           } else {
               size = 10;
           }
</PRE><PRE>           size *= magn;
</PRE><PRE>           if (opts.minTickSize != null &amp;&amp; size &lt; opts.minTickSize) {
               size = opts.minTickSize;
           }
</PRE><PRE>           axis.delta = delta;
           axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
           axis.tickSize = opts.tickSize || size;
</PRE><PRE>           // Time mode was moved to a plug-in in 0.8, but since so many people use this
           // we'll add an especially friendly make sure they remembered to include it.
</PRE><PRE>           if (opts.mode == &quot;time&quot; &amp;&amp; !axis.tickGenerator) {
               throw new Error(&quot;Time mode requires the flot.time plugin.&quot;);
           }
</PRE><PRE>           // Flot supports base-10 axes; any other mode else is handled by a plug-in,
           // like flot.time.js.
</PRE><PRE>           if (!axis.tickGenerator) {
</PRE><PRE>               axis.tickGenerator = function (axis) {
</PRE><PRE>                   var ticks = [],
                       start = floorInBase(axis.min, axis.tickSize),
                       i = 0,
                       v = Number.NaN,
                       prev;
</PRE><PRE>                   do {
                       prev = v;
                       v = start + i * axis.tickSize;
                       ticks.push(v);
                       ++i;
                   } while (v &lt; axis.max &amp;&amp; v != prev);
                   return ticks;
               };
</PRE><P>				axis.tickFormatter = function (value, axis) {
</P><P>					var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;
					var formatted = &quot;&quot; + Math.round(value * factor) / factor;
</P><P>					// If tickDecimals was specified, ensure that we have exactly that
					// much precision; otherwise default to the value's own precision.
</P><P>					if (axis.tickDecimals != null) {
						var decimal = formatted.indexOf(&quot;.&quot;);
						var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;
						if (precision &lt; axis.tickDecimals) {
							return (precision ? formatted : formatted + &quot;.&quot;) + (&quot;&quot; + factor).substr(1, axis.tickDecimals - precision);
						}
					}
</P><PRE>                   return formatted;
               };
           }
</PRE><PRE>           if ($.isFunction(opts.tickFormatter))
               axis.tickFormatter = function (v, axis) { return &quot;&quot; + opts.tickFormatter(v, axis); };
</PRE><PRE>           if (opts.alignTicksWithAxis != null) {
               var otherAxis = (axis.direction == &quot;x&quot; ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
               if (otherAxis &amp;&amp; otherAxis.used &amp;&amp; otherAxis != axis) {
                   // consider snapping min/max to outermost nice ticks
                   var niceTicks = axis.tickGenerator(axis);
                   if (niceTicks.length &gt; 0) {
                       if (opts.min == null)
                           axis.min = Math.min(axis.min, niceTicks[0]);
                       if (opts.max == null &amp;&amp; niceTicks.length &gt; 1)
                           axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);
                   }
</PRE><PRE>                   axis.tickGenerator = function (axis) {
                       // copy ticks, scaled to this axis
                       var ticks = [], v, i;
                       for (i = 0; i &lt; otherAxis.ticks.length; ++i) {
                           v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);
                           v = axis.min + v * (axis.max - axis.min);
                           ticks.push(v);
                       }
                       return ticks;
                   };
</PRE><PRE>                   // we might need an extra decimal since forced
                   // ticks don't necessarily fit naturally
                   if (!axis.mode &amp;&amp; opts.tickDecimals == null) {
                       var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),
                           ts = axis.tickGenerator(axis);
</PRE><PRE>                       // only proceed if the tick interval rounded
                       // with an extra decimal doesn't give us a
                       // zero at end
                       if (!(ts.length &gt; 1 &amp;&amp; /\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))
                           axis.tickDecimals = extraDec;
                   }
               }
           }
       }
</PRE><PRE>       function setTicks(axis) {
           var oticks = axis.options.ticks, ticks = [];
           if (oticks == null || (typeof oticks == &quot;number&quot; &amp;&amp; oticks &gt; 0))
               ticks = axis.tickGenerator(axis);
           else if (oticks) {
               if ($.isFunction(oticks))
                   // generate the ticks
                   ticks = oticks(axis);
               else
                   ticks = oticks;
           }
</PRE><PRE>           // clean up/labelify the supplied ticks, copy them over
           var i, v;
           axis.ticks = [];
           for (i = 0; i &lt; ticks.length; ++i) {
               var label = null;
               var t = ticks[i];
               if (typeof t == &quot;object&quot;) {
                   v = +t[0];
                   if (t.length &gt; 1)
                       label = t[1];
               }
               else
                   v = +t;
               if (label == null)
                   label = axis.tickFormatter(v, axis);
               if (!isNaN(v))
                   axis.ticks.push({ v: v, label: label });
           }
       }
</PRE><PRE>       function snapRangeToTicks(axis, ticks) {
           if (axis.options.autoscaleMargin &amp;&amp; ticks.length &gt; 0) {
               // snap to ticks
               if (axis.options.min == null)
                   axis.min = Math.min(axis.min, ticks[0].v);
               if (axis.options.max == null &amp;&amp; ticks.length &gt; 1)
                   axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);
           }
       }
</PRE><PRE>       function draw() {
</PRE><PRE>           surface.clear();
</PRE><PRE>           executeHooks(hooks.drawBackground, [ctx]);
</PRE><PRE>           var grid = options.grid;
</PRE><PRE>           // draw background, if any
           if (grid.show &amp;&amp; grid.backgroundColor)
               drawBackground();
</PRE><PRE>           if (grid.show &amp;&amp; !grid.aboveData) {
               drawGrid();
           }
</PRE><PRE>           for (var i = 0; i &lt; series.length; ++i) {
               executeHooks(hooks.drawSeries, [ctx, series[i]]);
               drawSeries(series[i]);
           }
</PRE><PRE>           executeHooks(hooks.draw, [ctx]);
</PRE><PRE>           if (grid.show &amp;&amp; grid.aboveData) {
               drawGrid();
           }
</PRE><PRE>           surface.render();
</PRE><PRE>           // A draw implies that either the axes or data have changed, so we
           // should probably update the overlay highlights as well.
</PRE><PRE>           triggerRedrawOverlay();
       }
</PRE><PRE>       function extractRange(ranges, coord) {
           var axis, from, to, key, axes = allAxes();
</PRE><PRE>           for (var i = 0; i &lt; axes.length; ++i) {
               axis = axes[i];
               if (axis.direction == coord) {
                   key = coord + axis.n + &quot;axis&quot;;
                   if (!ranges[key] &amp;&amp; axis.n == 1)
                       key = coord + &quot;axis&quot;; // support x1axis as xaxis
                   if (ranges[key]) {
                       from = ranges[key].from;
                       to = ranges[key].to;
                       break;
                   }
               }
           }
</PRE><PRE>           // backwards-compat stuff - to be removed in future
           if (!ranges[key]) {
               axis = coord == &quot;x&quot; ? xaxes[0] : yaxes[0];
               from = ranges[coord + &quot;1&quot;];
               to = ranges[coord + &quot;2&quot;];
           }
</PRE><PRE>           // auto-reverse as an added bonus
           if (from != null &amp;&amp; to != null &amp;&amp; from &gt; to) {
               var tmp = from;
               from = to;
               to = tmp;
           }
</PRE><PRE>           return { from: from, to: to, axis: axis };
       }
</PRE><PRE>       function drawBackground() {
           ctx.save();
           ctx.translate(plotOffset.left, plotOffset.top);
</PRE><PRE>           ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, &quot;rgba(255, 255, 255, 0)&quot;);
           ctx.fillRect(0, 0, plotWidth, plotHeight);
           ctx.restore();
       }
</PRE><PRE>       function drawGrid() {
           var i, axes, bw, bc;
</PRE><PRE>           ctx.save();
           ctx.translate(plotOffset.left, plotOffset.top);
</PRE><PRE>           // draw markings
           var markings = options.grid.markings;
           if (markings) {
               if ($.isFunction(markings)) {
                   axes = plot.getAxes();
                   // xmin etc. is backwards compatibility, to be
                   // removed in the future
                   axes.xmin = axes.xaxis.min;
                   axes.xmax = axes.xaxis.max;
                   axes.ymin = axes.yaxis.min;
                   axes.ymax = axes.yaxis.max;
</PRE><PRE>                   markings = markings(axes);
               }
</PRE><PRE>               for (i = 0; i &lt; markings.length; ++i) {
                   var m = markings[i],
                       xrange = extractRange(m, &quot;x&quot;),
                       yrange = extractRange(m, &quot;y&quot;);
</PRE><PRE>                   // fill in missing
                   if (xrange.from == null)
                       xrange.from = xrange.axis.min;
                   if (xrange.to == null)
                       xrange.to = xrange.axis.max;
                   if (yrange.from == null)
                       yrange.from = yrange.axis.min;
                   if (yrange.to == null)
                       yrange.to = yrange.axis.max;
</PRE><PRE>                   // clip
                   if (xrange.to &lt; xrange.axis.min || xrange.from &gt; xrange.axis.max ||
                       yrange.to &lt; yrange.axis.min || yrange.from &gt; yrange.axis.max)
                       continue;
</PRE><PRE>                   xrange.from = Math.max(xrange.from, xrange.axis.min);
                   xrange.to = Math.min(xrange.to, xrange.axis.max);
                   yrange.from = Math.max(yrange.from, yrange.axis.min);
                   yrange.to = Math.min(yrange.to, yrange.axis.max);
</PRE><PRE>                   if (xrange.from == xrange.to &amp;&amp; yrange.from == yrange.to)
                       continue;
</PRE><PRE>                   // then draw
                   xrange.from = xrange.axis.p2c(xrange.from);
                   xrange.to = xrange.axis.p2c(xrange.to);
                   yrange.from = yrange.axis.p2c(yrange.from);
                   yrange.to = yrange.axis.p2c(yrange.to);
</PRE><PRE>                   if (xrange.from == xrange.to || yrange.from == yrange.to) {
                       // draw line
                       ctx.beginPath();
                       ctx.strokeStyle = m.color || options.grid.markingsColor;
                       ctx.lineWidth = m.lineWidth || options.grid.markingsLineWidth;
                       ctx.moveTo(xrange.from, yrange.from);
                       ctx.lineTo(xrange.to, yrange.to);
                       ctx.stroke();
                   }
                   else {
                       // fill area
                       ctx.fillStyle = m.color || options.grid.markingsColor;
                       ctx.fillRect(xrange.from, yrange.to,
                                    xrange.to - xrange.from,
                                    yrange.from - yrange.to);
                   }
               }
           }
</PRE><PRE>           // draw the ticks
           axes = allAxes();
           bw = options.grid.borderWidth;
</PRE><PRE>           for (var j = 0; j &lt; axes.length; ++j) {
               var axis = axes[j], box = axis.box,
                   t = axis.tickLength, x, y, xoff, yoff;
               if (!axis.show || axis.ticks.length == 0)
                   continue;
</PRE><PRE>               ctx.lineWidth = 1;
</PRE><PRE>               // find the edges
               if (axis.direction == &quot;x&quot;) {
                   x = 0;
                   if (t == &quot;full&quot;)
                       y = (axis.position == &quot;top&quot; ? 0 : plotHeight);
                   else
                       y = box.top - plotOffset.top + (axis.position == &quot;top&quot; ? box.height : 0);
               }
               else {
                   y = 0;
                   if (t == &quot;full&quot;)
                       x = (axis.position == &quot;left&quot; ? 0 : plotWidth);
                   else
                       x = box.left - plotOffset.left + (axis.position == &quot;left&quot; ? box.width : 0);
               }
</PRE><PRE>               // draw tick bar
               if (!axis.innermost) {
                   ctx.strokeStyle = axis.options.color;
                   ctx.beginPath();
                   xoff = yoff = 0;
                   if (axis.direction == &quot;x&quot;)
                       xoff = plotWidth + 1;
                   else
                       yoff = plotHeight + 1;
</PRE><PRE>                   if (ctx.lineWidth == 1) {
                       if (axis.direction == &quot;x&quot;) {
                           y = Math.floor(y) + 0.5;
                       } else {
                           x = Math.floor(x) + 0.5;
                       }
                   }
</PRE><PRE>                   ctx.moveTo(x, y);
                   ctx.lineTo(x + xoff, y + yoff);
                   ctx.stroke();
               }
</PRE><PRE>               // draw ticks
</PRE><PRE>               ctx.strokeStyle = axis.options.tickColor;
</PRE><PRE>               ctx.beginPath();
               for (i = 0; i &lt; axis.ticks.length; ++i) {
                   var v = axis.ticks[i].v;
</PRE><PRE>                   xoff = yoff = 0;
</PRE><PRE>                   if (isNaN(v) || v &lt; axis.min || v &gt; axis.max
                       // skip those lying on the axes if we got a border
                       || (t == &quot;full&quot;
                           &amp;&amp; ((typeof bw == &quot;object&quot; &amp;&amp; bw[axis.position] &gt; 0) || bw &gt; 0)
                           &amp;&amp; (v == axis.min || v == axis.max)))
                       continue;
</PRE><PRE>                   if (axis.direction == &quot;x&quot;) {
                       x = axis.p2c(v);
                       yoff = t == &quot;full&quot; ? -plotHeight : t;
</PRE><PRE>                       if (axis.position == &quot;top&quot;)
                           yoff = -yoff;
                   }
                   else {
                       y = axis.p2c(v);
                       xoff = t == &quot;full&quot; ? -plotWidth : t;
</PRE><PRE>                       if (axis.position == &quot;left&quot;)
                           xoff = -xoff;
                   }
</PRE><PRE>                   if (ctx.lineWidth == 1) {
                       if (axis.direction == &quot;x&quot;)
                           x = Math.floor(x) + 0.5;
                       else
                           y = Math.floor(y) + 0.5;
                   }
</PRE><PRE>                   ctx.moveTo(x, y);
                   ctx.lineTo(x + xoff, y + yoff);
               }
</PRE><PRE>               ctx.stroke();
           }
</PRE><PRE>           // draw border
           if (bw) {
               // If either borderWidth or borderColor is an object, then draw the border
               // line by line instead of as one rectangle
               bc = options.grid.borderColor;
               if(typeof bw == &quot;object&quot; || typeof bc == &quot;object&quot;) {
                   if (typeof bw !== &quot;object&quot;) {
                       bw = {top: bw, right: bw, bottom: bw, left: bw};
                   }
                   if (typeof bc !== &quot;object&quot;) {
                       bc = {top: bc, right: bc, bottom: bc, left: bc};
                   }
</PRE><PRE>                   if (bw.top &gt; 0) {
                       ctx.strokeStyle = bc.top;
                       ctx.lineWidth = bw.top;
                       ctx.beginPath();
                       ctx.moveTo(0 - bw.left, 0 - bw.top/2);
                       ctx.lineTo(plotWidth, 0 - bw.top/2);
                       ctx.stroke();
                   }
</PRE><PRE>                   if (bw.right &gt; 0) {
                       ctx.strokeStyle = bc.right;
                       ctx.lineWidth = bw.right;
                       ctx.beginPath();
                       ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
                       ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
                       ctx.stroke();
                   }
</PRE><PRE>                   if (bw.bottom &gt; 0) {
                       ctx.strokeStyle = bc.bottom;
                       ctx.lineWidth = bw.bottom;
                       ctx.beginPath();
                       ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);
                       ctx.lineTo(0, plotHeight + bw.bottom / 2);
                       ctx.stroke();
                   }
</PRE><PRE>                   if (bw.left &gt; 0) {
                       ctx.strokeStyle = bc.left;
                       ctx.lineWidth = bw.left;
                       ctx.beginPath();
                       ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);
                       ctx.lineTo(0- bw.left/2, 0);
                       ctx.stroke();
                   }
               }
               else {
                   ctx.lineWidth = bw;
                   ctx.strokeStyle = options.grid.borderColor;
                   ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);
               }
           }
</PRE><PRE>           ctx.restore();
       }
</PRE><PRE>       function drawAxisLabels() {
</PRE><PRE>           $.each(allAxes(), function (_, axis) {
               if (!axis.show || axis.ticks.length == 0)
                   return;
</PRE><PRE>               var box = axis.box,
                   legacyStyles = axis.direction + &quot;Axis &quot; + axis.direction + axis.n + &quot;Axis&quot;,
                   layer = &quot;flot-&quot; + axis.direction + &quot;-axis flot-&quot; + axis.direction + axis.n + &quot;-axis &quot; + legacyStyles,
                   font = axis.options.font || &quot;flot-tick-label tickLabel&quot;,
                   tick, x, y, halign, valign;
</PRE><PRE>               surface.removeText(layer);
</PRE><PRE>               for (var i = 0; i &lt; axis.ticks.length; ++i) {
</PRE><PRE>                   tick = axis.ticks[i];
                   if (!tick.label || tick.v &lt; axis.min || tick.v &gt; axis.max)
                       continue;
</PRE><PRE>                   if (axis.direction == &quot;x&quot;) {
                       halign = &quot;center&quot;;
                       x = plotOffset.left + axis.p2c(tick.v);
                       if (axis.position == &quot;bottom&quot;) {
                           y = box.top + box.padding;
                       } else {
                           y = box.top + box.height - box.padding;
                           valign = &quot;bottom&quot;;
                       }
                   } else {
                       valign = &quot;middle&quot;;
                       y = plotOffset.top + axis.p2c(tick.v);
                       if (axis.position == &quot;left&quot;) {
                           x = box.left + box.width - box.padding;
                           halign = &quot;right&quot;;
                       } else {
                           x = box.left + box.padding;
                       }
                   }
</PRE><PRE>                   surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);
               }
           });
       }
</PRE><PRE>       function drawSeries(series) {
           if (series.lines.show)
               drawSeriesLines(series);
           if (series.bars.show)
               drawSeriesBars(series);
           if (series.points.show)
               drawSeriesPoints(series);
       }
</PRE><PRE>       function drawSeriesLines(series) {
           function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
               var points = datapoints.points,
                   ps = datapoints.pointsize,
                   prevx = null, prevy = null;
</PRE><PRE>               ctx.beginPath();
               for (var i = ps; i &lt; points.length; i += ps) {
                   var x1 = points[i - ps], y1 = points[i - ps + 1],
                       x2 = points[i], y2 = points[i + 1];
</PRE><PRE>                   if (x1 == null || x2 == null)
                       continue;
</PRE><PRE>                   // clip with ymin
                   if (y1 &lt;= y2 &amp;&amp; y1 &lt; axisy.min) {
                       if (y2 &lt; axisy.min)
                           continue;   // line segment is outside
                       // compute new intersection point
                       x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                       y1 = axisy.min;
                   }
                   else if (y2 &lt;= y1 &amp;&amp; y2 &lt; axisy.min) {
                       if (y1 &lt; axisy.min)
                           continue;
                       x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                       y2 = axisy.min;
                   }
</PRE><PRE>                   // clip with ymax
                   if (y1 &gt;= y2 &amp;&amp; y1 &gt; axisy.max) {
                       if (y2 &gt; axisy.max)
                           continue;
                       x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                       y1 = axisy.max;
                   }
                   else if (y2 &gt;= y1 &amp;&amp; y2 &gt; axisy.max) {
                       if (y1 &gt; axisy.max)
                           continue;
                       x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                       y2 = axisy.max;
                   }
</PRE><PRE>                   // clip with xmin
                   if (x1 &lt;= x2 &amp;&amp; x1 &lt; axisx.min) {
                       if (x2 &lt; axisx.min)
                           continue;
                       y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                       x1 = axisx.min;
                   }
                   else if (x2 &lt;= x1 &amp;&amp; x2 &lt; axisx.min) {
                       if (x1 &lt; axisx.min)
                           continue;
                       y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                       x2 = axisx.min;
                   }
</PRE><PRE>                   // clip with xmax
                   if (x1 &gt;= x2 &amp;&amp; x1 &gt; axisx.max) {
                       if (x2 &gt; axisx.max)
                           continue;
                       y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                       x1 = axisx.max;
                   }
                   else if (x2 &gt;= x1 &amp;&amp; x2 &gt; axisx.max) {
                       if (x1 &gt; axisx.max)
                           continue;
                       y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                       x2 = axisx.max;
                   }
</PRE><PRE>                   if (x1 != prevx || y1 != prevy)
                       ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);
</PRE><PRE>                   prevx = x2;
                   prevy = y2;
                   ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);
               }
               ctx.stroke();
           }
</PRE><PRE>           function plotLineArea(datapoints, axisx, axisy) {
               var points = datapoints.points,
                   ps = datapoints.pointsize,
                   bottom = Math.min(Math.max(0, axisy.min), axisy.max),
                   i = 0, top, areaOpen = false,
                   ypos = 1, segmentStart = 0, segmentEnd = 0;
</PRE><PRE>               // we process each segment in two turns, first forward
               // direction to sketch out top, then once we hit the
               // end we go backwards to sketch the bottom
               while (true) {
                   if (ps &gt; 0 &amp;&amp; i &gt; points.length + ps)
                       break;
</PRE><PRE>                   i += ps; // ps is negative if going backwards
</PRE><PRE>                   var x1 = points[i - ps],
                       y1 = points[i - ps + ypos],
                       x2 = points[i], y2 = points[i + ypos];
</PRE><PRE>                   if (areaOpen) {
                       if (ps &gt; 0 &amp;&amp; x1 != null &amp;&amp; x2 == null) {
                           // at turning point
                           segmentEnd = i;
                           ps = -ps;
                           ypos = 2;
                           continue;
                       }
</PRE><PRE>                       if (ps &lt; 0 &amp;&amp; i == segmentStart + ps) {
                           // done with the reverse sweep
                           ctx.fill();
                           areaOpen = false;
                           ps = -ps;
                           ypos = 1;
                           i = segmentStart = segmentEnd + ps;
                           continue;
                       }
                   }
</PRE><PRE>                   if (x1 == null || x2 == null)
                       continue;
</PRE><PRE>                   // clip x values
</PRE><PRE>                   // clip with xmin
                   if (x1 &lt;= x2 &amp;&amp; x1 &lt; axisx.min) {
                       if (x2 &lt; axisx.min)
                           continue;
                       y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                       x1 = axisx.min;
                   }
                   else if (x2 &lt;= x1 &amp;&amp; x2 &lt; axisx.min) {
                       if (x1 &lt; axisx.min)
                           continue;
                       y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
                       x2 = axisx.min;
                   }
</PRE><PRE>                   // clip with xmax
                   if (x1 &gt;= x2 &amp;&amp; x1 &gt; axisx.max) {
                       if (x2 &gt; axisx.max)
                           continue;
                       y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                       x1 = axisx.max;
                   }
                   else if (x2 &gt;= x1 &amp;&amp; x2 &gt; axisx.max) {
                       if (x1 &gt; axisx.max)
                           continue;
                       y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
                       x2 = axisx.max;
                   }
</PRE><PRE>                   if (!areaOpen) {
                       // open area
                       ctx.beginPath();
                       ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
                       areaOpen = true;
                   }
</PRE><PRE>                   // now first check the case where both is outside
                   if (y1 &gt;= axisy.max &amp;&amp; y2 &gt;= axisy.max) {
                       ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
                       ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
                       continue;
                   }
                   else if (y1 &lt;= axisy.min &amp;&amp; y2 &lt;= axisy.min) {
                       ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
                       ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
                       continue;
                   }
</PRE><PRE>                   // else it's a bit more complicated, there might
                   // be a flat maxed out rectangle first, then a
                   // triangular cutout or reverse; to find these
                   // keep track of the current x values
                   var x1old = x1, x2old = x2;
</PRE><PRE>                   // clip the y values, without shortcutting, we
                   // go through all cases in turn
</PRE><PRE>                   // clip with ymin
                   if (y1 &lt;= y2 &amp;&amp; y1 &lt; axisy.min &amp;&amp; y2 &gt;= axisy.min) {
                       x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                       y1 = axisy.min;
                   }
                   else if (y2 &lt;= y1 &amp;&amp; y2 &lt; axisy.min &amp;&amp; y1 &gt;= axisy.min) {
                       x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
                       y2 = axisy.min;
                   }
</PRE><PRE>                   // clip with ymax
                   if (y1 &gt;= y2 &amp;&amp; y1 &gt; axisy.max &amp;&amp; y2 &lt;= axisy.max) {
                       x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                       y1 = axisy.max;
                   }
                   else if (y2 &gt;= y1 &amp;&amp; y2 &gt; axisy.max &amp;&amp; y1 &lt;= axisy.max) {
                       x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
                       y2 = axisy.max;
                   }
</PRE><PRE>                   // if the x value was changed we got a rectangle
                   // to fill
                   if (x1 != x1old) {
                       ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));
                       // it goes to (x1, y1), but we fill that below
                   }
</PRE><PRE>                   // fill triangular section, this sometimes result
                   // in redundant points if (x1, y1) hasn't changed
                   // from previous line to, but we just ignore that
                   ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
                   ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
</PRE><PRE>                   // fill the other rectangle if it's there
                   if (x2 != x2old) {
                       ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
                       ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));
                   }
               }
           }
</PRE><PRE>           ctx.save();
           ctx.translate(plotOffset.left, plotOffset.top);
           ctx.lineJoin = &quot;round&quot;;
</PRE><PRE>           var lw = series.lines.lineWidth,
               sw = series.shadowSize;
           // FIXME: consider another form of shadow when filling is turned on
           if (lw &gt; 0 &amp;&amp; sw &gt; 0) {
               // draw shadow as a thick and thin line with transparency
               ctx.lineWidth = sw;
               ctx.strokeStyle = &quot;rgba(0,0,0,0.1)&quot;;
               // position shadow at angle from the mid of line
               var angle = Math.PI/18;
               plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);
               ctx.lineWidth = sw/2;
               plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);
           }
</PRE><PRE>           ctx.lineWidth = lw;
           ctx.strokeStyle = series.color;
           var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);
           if (fillStyle) {
               ctx.fillStyle = fillStyle;
               plotLineArea(series.datapoints, series.xaxis, series.yaxis);
           }
</PRE><PRE>           if (lw &gt; 0)
               plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);
           ctx.restore();
       }
</PRE><PRE>       function drawSeriesPoints(series) {
           function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {
               var points = datapoints.points, ps = datapoints.pointsize;
</PRE><PRE>               for (var i = 0; i &lt; points.length; i += ps) {
                   var x = points[i], y = points[i + 1];
                   if (x == null || x &lt; axisx.min || x &gt; axisx.max || y &lt; axisy.min || y &gt; axisy.max)
                       continue;
</PRE><PRE>                   ctx.beginPath();
                   x = axisx.p2c(x);
                   y = axisy.p2c(y) + offset;
                   if (symbol == &quot;circle&quot;)
                       ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);
                   else
                       symbol(ctx, x, y, radius, shadow);
                   ctx.closePath();
</PRE><PRE>                   if (fillStyle) {
                       ctx.fillStyle = fillStyle;
                       ctx.fill();
                   }
                   ctx.stroke();
               }
           }
</PRE><PRE>           ctx.save();
           ctx.translate(plotOffset.left, plotOffset.top);
</PRE><PRE>           var lw = series.points.lineWidth,
               sw = series.shadowSize,
               radius = series.points.radius,
               symbol = series.points.symbol;
</PRE><PRE>           // If the user sets the line width to 0, we change it to a very 
           // small value. A line width of 0 seems to force the default of 1.
           // Doing the conditional here allows the shadow setting to still be 
           // optional even with a lineWidth of 0.
</PRE><PRE>           if( lw == 0 )
               lw = 0.0001;
</PRE><PRE>           if (lw &gt; 0 &amp;&amp; sw &gt; 0) {
               // draw shadow in two steps
               var w = sw / 2;
               ctx.lineWidth = w;
               ctx.strokeStyle = &quot;rgba(0,0,0,0.1)&quot;;
               plotPoints(series.datapoints, radius, null, w + w/2, true,
                          series.xaxis, series.yaxis, symbol);
</PRE><PRE>               ctx.strokeStyle = &quot;rgba(0,0,0,0.2)&quot;;
               plotPoints(series.datapoints, radius, null, w/2, true,
                          series.xaxis, series.yaxis, symbol);
           }
</PRE><PRE>           ctx.lineWidth = lw;
           ctx.strokeStyle = series.color;
           plotPoints(series.datapoints, radius,
                      getFillStyle(series.points, series.color), 0, false,
                      series.xaxis, series.yaxis, symbol);
           ctx.restore();
       }
</PRE><PRE>       function drawBar(x, y, b, barLeft, barRight, offset, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {
           var left, right, bottom, top,
               drawLeft, drawRight, drawTop, drawBottom,
               tmp;
</PRE><PRE>           // in horizontal mode, we start the bar from the left
           // instead of from the bottom so it appears to be
           // horizontal rather than vertical
           if (horizontal) {
               drawBottom = drawRight = drawTop = true;
               drawLeft = false;
               left = b;
               right = x;
               top = y + barLeft;
               bottom = y + barRight;
</PRE><PRE>               // account for negative bars
               if (right &lt; left) {
                   tmp = right;
                   right = left;
                   left = tmp;
                   drawLeft = true;
                   drawRight = false;
               }
           }
           else {
               drawLeft = drawRight = drawTop = true;
               drawBottom = false;
               left = x + barLeft;
               right = x + barRight;
               bottom = b;
               top = y;
</PRE><PRE>               // account for negative bars
               if (top &lt; bottom) {
                   tmp = top;
                   top = bottom;
                   bottom = tmp;
                   drawBottom = true;
                   drawTop = false;
               }
           }
</PRE><PRE>           // clip
           if (right &lt; axisx.min || left &gt; axisx.max ||
               top &lt; axisy.min || bottom &gt; axisy.max)
               return;
</PRE><PRE>           if (left &lt; axisx.min) {
               left = axisx.min;
               drawLeft = false;
           }
</PRE><PRE>           if (right &gt; axisx.max) {
               right = axisx.max;
               drawRight = false;
           }
</PRE><PRE>           if (bottom &lt; axisy.min) {
               bottom = axisy.min;
               drawBottom = false;
           }
</PRE><PRE>           if (top &gt; axisy.max) {
               top = axisy.max;
               drawTop = false;
           }
</PRE><PRE>           left = axisx.p2c(left);
           bottom = axisy.p2c(bottom);
           right = axisx.p2c(right);
           top = axisy.p2c(top);
</PRE><PRE>           // fill the bar
           if (fillStyleCallback) {
               c.beginPath();
               c.moveTo(left, bottom);
               c.lineTo(left, top);
               c.lineTo(right, top);
               c.lineTo(right, bottom);
               c.fillStyle = fillStyleCallback(bottom, top);
               c.fill();
           }
</PRE><PRE>           // draw outline
           if (lineWidth &gt; 0 &amp;&amp; (drawLeft || drawRight || drawTop || drawBottom)) {
               c.beginPath();
</PRE><PRE>               // FIXME: inline moveTo is buggy with excanvas
               c.moveTo(left, bottom + offset);
               if (drawLeft)
                   c.lineTo(left, top + offset);
               else
                   c.moveTo(left, top + offset);
               if (drawTop)
                   c.lineTo(right, top + offset);
               else
                   c.moveTo(right, top + offset);
               if (drawRight)
                   c.lineTo(right, bottom + offset);
               else
                   c.moveTo(right, bottom + offset);
               if (drawBottom)
                   c.lineTo(left, bottom + offset);
               else
                   c.moveTo(left, bottom + offset);
               c.stroke();
           }
       }
</PRE><PRE>       function drawSeriesBars(series) {
           function plotBars(datapoints, barLeft, barRight, offset, fillStyleCallback, axisx, axisy) {
               var points = datapoints.points, ps = datapoints.pointsize;
</PRE><PRE>               for (var i = 0; i &lt; points.length; i += ps) {
                   if (points[i] == null)
                       continue;
                   drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, offset, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);
               }
           }
</PRE><PRE>           ctx.save();
           ctx.translate(plotOffset.left, plotOffset.top);
</PRE><PRE>           // FIXME: figure out a way to add shadows (for instance along the right edge)
           ctx.lineWidth = series.bars.lineWidth;
           ctx.strokeStyle = series.color;
</PRE><PRE>           var barLeft;
</PRE><PRE>           switch (series.bars.align) {
               case &quot;left&quot;:
                   barLeft = 0;
                   break;
               case &quot;right&quot;:
                   barLeft = -series.bars.barWidth;
                   break;
               case &quot;center&quot;:
                   barLeft = -series.bars.barWidth / 2;
                   break;
               default:
                   throw new Error(&quot;Invalid bar alignment: &quot; + series.bars.align);
           }
</PRE><PRE>           var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;
           plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, 0, fillStyleCallback, series.xaxis, series.yaxis);
           ctx.restore();
       }
</PRE><PRE>       function getFillStyle(filloptions, seriesColor, bottom, top) {
           var fill = filloptions.fill;
           if (!fill)
               return null;
</PRE><PRE>           if (filloptions.fillColor)
               return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);
</PRE><PRE>           var c = $.color.parse(seriesColor);
           c.a = typeof fill == &quot;number&quot; ? fill : 0.4;
           c.normalize();
           return c.toString();
       }
</PRE><PRE>       function insertLegend() {
</PRE><PRE>           placeholder.find(&quot;.legend&quot;).remove();
</PRE><PRE>           if (!options.legend.show)
               return;
</PRE><PRE>           var fragments = [], entries = [], rowStarted = false,
               lf = options.legend.labelFormatter, s, label;
</PRE><PRE>           // Build a list of legend entries, with each having a label and a color
</PRE><PRE>           for (var i = 0; i &lt; series.length; ++i) {
               s = series[i];
               if (s.label) {
                   label = lf ? lf(s.label, s) : s.label;
                   if (label) {
                       entries.push({
                           label: label,
                           color: s.color
                       });
                   }
               }
           }
</PRE><PRE>           // Sort the legend using either the default or a custom comparator
</PRE><PRE>           if (options.legend.sorted) {
               if ($.isFunction(options.legend.sorted)) {
                   entries.sort(options.legend.sorted);
               } else if (options.legend.sorted == &quot;reverse&quot;) {
               	entries.reverse();
               } else {
                   var ascending = options.legend.sorted != &quot;descending&quot;;
                   entries.sort(function(a, b) {
                       return a.label == b.label ? 0 : (
                           (a.label &lt; b.label) != ascending ? 1 : -1   // Logical XOR
                       );
                   });
               }
           }
</PRE><PRE>           // Generate markup for the list of entries, in their final order
</PRE><PRE>           for (var i = 0; i &lt; entries.length; ++i) {
</PRE><PRE>               var entry = entries[i];
</PRE><PRE>               if (i % options.legend.noColumns == 0) {
                   if (rowStarted)
                       fragments.push('&lt;/tr&gt;');
                   fragments.push('&lt;tr&gt;');
                   rowStarted = true;
               }
</PRE><PRE>               fragments.push(
</PRE>
                    '&lt;td class=&quot;legendColorBox&quot;&gt;&lt;/td&gt;' +
<PRE>                   '&lt;td class=&quot;legendLabel&quot;&gt;' + entry.label + '&lt;/td&gt;'
               );
           }
</PRE><PRE>           if (rowStarted)
               fragments.push('&lt;/tr&gt;');
</PRE><PRE>           if (fragments.length == 0)
               return;
</PRE>
            var table = '<TABLE style="font-size:smaller;color:' + options.grid.color + '">' + fragments.join(&quot;&quot;) + '</TABLE>';
<PRE>     if (options.legend.container != null)
               $(options.legend.container).html(table);
           else {
               var pos = &quot;&quot;,
                   p = options.legend.position,
                   m = options.legend.margin;
               if (m[0] == null)
                   m = [m, m];
               if (p.charAt(0) == &quot;n&quot;)
                   pos += 'top:' + (m[1] + plotOffset.top) + 'px;';
               else if (p.charAt(0) == &quot;s&quot;)
                   pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';
               if (p.charAt(1) == &quot;e&quot;)
                   pos += 'right:' + (m[0] + plotOffset.right) + 'px;';
               else if (p.charAt(1) == &quot;w&quot;)
                   pos += 'left:' + (m[0] + plotOffset.left) + 'px;';
</PRE>
                var legend = $('<DIV class="legend">' + table.replace('style=&quot;', 'style=&quot;position:absolute;' + pos +';') + '</DIV>').appendTo(placeholder);
<PRE>               if (options.legend.backgroundOpacity != 0.0) {
                   // put in the transparent background
                   // separately to avoid blended labels and
                   // label boxes
                   var c = options.legend.backgroundColor;
                   if (c == null) {
                       c = options.grid.backgroundColor;
                       if (c &amp;&amp; typeof c == &quot;string&quot;)
                           c = $.color.parse(c);
                       else
                           c = $.color.extract(legend, 'background-color');
                       c.a = 1;
                       c = c.toString();
                   }
                   var div = legend.children();
</PRE>
                    $('').prependTo(legend).css('opacity', options.legend.backgroundOpacity);
<PRE>               }
           }
       }
</PRE><PRE>       // interactive features
</PRE><PRE>       var highlights = [],
           redrawTimeout = null;
</PRE><PRE>       // returns the data item the mouse is over, or null if none is found
       function findNearbyItem(mouseX, mouseY, seriesFilter) {
           var maxDistance = options.grid.mouseActiveRadius,
               smallestDistance = maxDistance * maxDistance + 1,
               item = null, foundPoint = false, i, j, ps;
</PRE><PRE>           for (i = series.length - 1; i &gt;= 0; --i) {
               if (!seriesFilter(series[i]))
                   continue;
</PRE><PRE>               var s = series[i],
                   axisx = s.xaxis,
                   axisy = s.yaxis,
                   points = s.datapoints.points,
                   mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster
                   my = axisy.c2p(mouseY),
                   maxx = maxDistance / axisx.scale,
                   maxy = maxDistance / axisy.scale;
</PRE><PRE>               ps = s.datapoints.pointsize;
               // with inverse transforms, we can't use the maxx/maxy
               // optimization, sadly
               if (axisx.options.inverseTransform)
                   maxx = Number.MAX_VALUE;
               if (axisy.options.inverseTransform)
                   maxy = Number.MAX_VALUE;
</PRE><PRE>               if (s.lines.show || s.points.show) {
                   for (j = 0; j &lt; points.length; j += ps) {
                       var x = points[j], y = points[j + 1];
                       if (x == null)
                           continue;
</PRE><PRE>                       // For points and lines, the cursor must be within a
                       // certain distance to the data point
                       if (x - mx &gt; maxx || x - mx &lt; -maxx ||
                           y - my &gt; maxy || y - my &lt; -maxy)
                           continue;
</PRE><PRE>                       // We have to calculate distances in pixels, not in
                       // data units, because the scales of the axes may be different
                       var dx = Math.abs(axisx.p2c(x) - mouseX),
                           dy = Math.abs(axisy.p2c(y) - mouseY),
                           dist = dx * dx + dy * dy; // we save the sqrt
</PRE><PRE>                       // use &lt;= to ensure last point takes precedence
                       // (last generally means on top of)
                       if (dist &lt; smallestDistance) {
                           smallestDistance = dist;
                           item = [i, j / ps];
                       }
                   }
               }
</PRE><PRE>               if (s.bars.show &amp;&amp; !item) { // no other point can be nearby
                   var barLeft = s.bars.align == &quot;left&quot; ? 0 : -s.bars.barWidth/2,
                       barRight = barLeft + s.bars.barWidth;
</PRE><PRE>                   for (j = 0; j &lt; points.length; j += ps) {
                       var x = points[j], y = points[j + 1], b = points[j + 2];
                       if (x == null)
                           continue;
</PRE><PRE>                       // for a bar graph, the cursor must be inside the bar
                       if (series[i].bars.horizontal ?
                           (mx &lt;= Math.max(b, x) &amp;&amp; mx &gt;= Math.min(b, x) &amp;&amp;
                            my &gt;= y + barLeft &amp;&amp; my &lt;= y + barRight) :
                           (mx &gt;= x + barLeft &amp;&amp; mx &lt;= x + barRight &amp;&amp;
                            my &gt;= Math.min(b, y) &amp;&amp; my &lt;= Math.max(b, y)))
                               item = [i, j / ps];
                   }
               }
           }
</PRE><PRE>           if (item) {
               i = item[0];
               j = item[1];
               ps = series[i].datapoints.pointsize;
</PRE><PRE>               return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),
                        dataIndex: j,
                        series: series[i],
                        seriesIndex: i };
           }
</PRE><PRE>           return null;
       }
</PRE><PRE>       function onMouseMove(e) {
           if (options.grid.hoverable)
               triggerClickHoverEvent(&quot;plothover&quot;, e,
                                      function (s) { return s[&quot;hoverable&quot;] != false; });
       }
</PRE><PRE>       function onMouseLeave(e) {
           if (options.grid.hoverable)
               triggerClickHoverEvent(&quot;plothover&quot;, e,
                                      function (s) { return false; });
       }
</PRE><PRE>       function onClick(e) {
           triggerClickHoverEvent(&quot;plotclick&quot;, e,
                                  function (s) { return s[&quot;clickable&quot;] != false; });
       }
</PRE><PRE>       // trigger click or hover event (they send the same parameters
       // so we share their code)
       function triggerClickHoverEvent(eventname, event, seriesFilter) {
           var offset = eventHolder.offset(),
               canvasX = event.pageX - offset.left - plotOffset.left,
               canvasY = event.pageY - offset.top - plotOffset.top,
           pos = canvasToAxisCoords({ left: canvasX, top: canvasY });
</PRE><PRE>           pos.pageX = event.pageX;
           pos.pageY = event.pageY;
</PRE><PRE>           var item = findNearbyItem(canvasX, canvasY, seriesFilter);
</PRE><PRE>           if (item) {
               // fill in mouse pos for any listeners out there
               item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);
               item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);
           }
</PRE><PRE>           if (options.grid.autoHighlight) {
               // clear auto-highlights
               for (var i = 0; i &lt; highlights.length; ++i) {
                   var h = highlights[i];
                   if (h.auto == eventname &amp;&amp; !(item &amp;&amp; h.series == item.series &amp;&amp;
                         h.point[0] == item.datapoint[0] &amp;&amp;
                         h.point[1] == item.datapoint[1]))
                       unhighlight(h.series, h.point);
               }
</PRE><PRE>               if (item)
                   highlight(item.series, item.datapoint, eventname);
           }
</PRE><PRE>           placeholder.trigger(eventname, [ pos, item ]);
       }
</PRE><PRE>       function triggerRedrawOverlay() {
           var t = options.interaction.redrawOverlayInterval;
           if (t == -1) {      // skip event queue
               drawOverlay();
               return;
           }
</PRE><PRE>           if (!redrawTimeout)
               redrawTimeout = setTimeout(drawOverlay, t);
       }
</PRE><PRE>       function drawOverlay() {
           redrawTimeout = null;
</PRE><PRE>           // draw highlights
           octx.save();
           overlay.clear();
           octx.translate(plotOffset.left, plotOffset.top);
</PRE><PRE>           var i, hi;
           for (i = 0; i &lt; highlights.length; ++i) {
               hi = highlights[i];
</PRE><PRE>               if (hi.series.bars.show)
                   drawBarHighlight(hi.series, hi.point);
               else
                   drawPointHighlight(hi.series, hi.point);
           }
           octx.restore();
</PRE><PRE>           executeHooks(hooks.drawOverlay, [octx]);
       }
</PRE><PRE>       function highlight(s, point, auto) {
           if (typeof s == &quot;number&quot;)
               s = series[s];
</PRE><PRE>           if (typeof point == &quot;number&quot;) {
               var ps = s.datapoints.pointsize;
               point = s.datapoints.points.slice(ps * point, ps * (point + 1));
           }
</PRE><PRE>           var i = indexOfHighlight(s, point);
           if (i == -1) {
               highlights.push({ series: s, point: point, auto: auto });
</PRE><PRE>               triggerRedrawOverlay();
           }
           else if (!auto)
               highlights[i].auto = false;
       }
</PRE><PRE>       function unhighlight(s, point) {
           if (s == null &amp;&amp;point == null) {
               highlights = [];
               triggerRedrawOverlay();
               return;
           }
</PRE><PRE>           if (typeof s == &quot;number&quot;)
               s = series[s];
</PRE><PRE>           if (typeof point == &quot;number&quot;) {
               var ps = s.datapoints.pointsize;
               point = s.datapoints.points.slice(ps * point, ps * (point + 1));
           }
</PRE><PRE>           var i = indexOfHighlight(s, point);
           if (i != -1) {
               highlights.splice(i, 1);
</PRE><PRE>               triggerRedrawOverlay();
           }
       }
</PRE><PRE>       function indexOfHighlight(s, p) {
           for (var i = 0; i &lt; highlights.length; ++i) {
               var h = highlights[i];
               if (h.series == s &amp;&amp; h.point[0] == p[0]
                   &amp;&amp; h.point[1] == p[1])
                   return i;
           }
           return -1;
       }
</PRE><PRE>       function drawPointHighlight(series, point) {
           var x = point[0], y = point[1],
               axisx = series.xaxis, axisy = series.yaxis,
               highlightColor = (typeof series.highlightColor === &quot;string&quot;) ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();
</PRE><PRE>           if (x &lt; axisx.min || x &gt; axisx.max || y &lt; axisy.min || y &gt; axisy.max)
               return;
</PRE><PRE>           var pointRadius = series.points.radius + series.points.lineWidth / 2;
           octx.lineWidth = pointRadius;
           octx.strokeStyle = highlightColor;
           var radius = 1.5 * pointRadius;
           x = axisx.p2c(x);
           y = axisy.p2c(y);
</PRE><PRE>           octx.beginPath();
           if (series.points.symbol == &quot;circle&quot;)
               octx.arc(x, y, radius, 0, 2 * Math.PI, false);
           else
               series.points.symbol(octx, x, y, radius, false);
           octx.closePath();
           octx.stroke();
       }
</PRE><PRE>       function drawBarHighlight(series, point) {
           var highlightColor = (typeof series.highlightColor === &quot;string&quot;) ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),
               fillStyle = highlightColor,
               barLeft = series.bars.align == &quot;left&quot; ? 0 : -series.bars.barWidth/2;
</PRE><PRE>           octx.lineWidth = series.bars.lineWidth;
           octx.strokeStyle = highlightColor;
</PRE><PRE>           drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,
                   0, function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);
       }
</PRE><PRE>       function getColorOrGradient(spec, bottom, top, defaultColor) {
           if (typeof spec == &quot;string&quot;)
               return spec;
           else {
               // assume this is a gradient spec; IE currently only
               // supports a simple vertical gradient properly, so that's
               // what we support too
               var gradient = ctx.createLinearGradient(0, top, 0, bottom);
</PRE><PRE>               for (var i = 0, l = spec.colors.length; i &lt; l; ++i) {
                   var c = spec.colors[i];
                   if (typeof c != &quot;string&quot;) {
                       var co = $.color.parse(defaultColor);
                       if (c.brightness != null)
                           co = co.scale('rgb', c.brightness);
                       if (c.opacity != null)
                           co.a *= c.opacity;
                       c = co.toString();
                   }
                   gradient.addColorStop(i / (l - 1), c);
               }
</PRE><PRE>               return gradient;
           }
       }
   }
</PRE><PRE>   // Add the plot function to the top level of the jQuery object
</PRE><PRE>   $.plot = function(placeholder, data, options) {
       //var t0 = new Date();
       var plot = new Plot($(placeholder), data, options, $.plot.plugins);
       //(window.console ? console.log : alert)(&quot;time used (msecs): &quot; + ((new Date()).getTime() - t0.getTime()));
       return plot;
   };
</PRE><PRE>   $.plot.version = &quot;0.8.1&quot;;
</PRE><PRE>   $.plot.plugins = [];
</PRE><PRE>   // Also add the plot function as a chainable property
</PRE><PRE>   $.fn.plot = function(data, options) {
       return this.each(function() {
           $.plot(this, data, options);
       });
   };
</PRE><PRE>   // round to nearby lower multiple of base
   function floorInBase(n, base) {
       return base * Math.floor(n / base);
   }
</PRE><P>})(jQuery);
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2013.igem.org/Team:TU-Eindhoven/JS:Flot">http://2013.igem.org/Team:TU-Eindhoven/JS:Flot</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:TU-Eindhoven/JS:Flot" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:TU-Eindhoven/JS:Flot" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:TU-Eindhoven/JS:Flot&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:TU-Eindhoven/JS:Flot&amp;oldid=75606" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2013.igem.org:Privacy_policy" title="2013.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2013.igem.org:General_disclaimer" title="2013.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
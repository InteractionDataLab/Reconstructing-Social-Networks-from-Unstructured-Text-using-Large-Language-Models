<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_TU-Munich_Chart_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:TU-Munich/Chart.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:TU-Munich/Chart.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:TU-Munich/Chart.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:TU-Munich/Chart.js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:TU-Munich/Chart.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:TU-Munich/Chart.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2013.igem.org</H3><P>/*!
</P><PRE>* Chart.js
* <A href="http://chartjs.org/" class="external free" rel="nofollow">http://chartjs.org/</A>
*
* Copyright 2013 Nick Downie
* Released under the MIT license
* <A href="https://github.com/nnnick/Chart.js/blob/master/LICENSE.md" class="external free" rel="nofollow">https://github.com/nnnick/Chart.js/blob/master/LICENSE.md</A>
*/
</PRE><P>//Define the global Chart Variable as a class.
window.Chart = function(context){
</P><P>	var chart = this;
</P><P>
	//Easing functions adapted from Robert Penner's easing equations
	//<A href="http://www.robertpenner.com/easing/" class="external free" rel="nofollow">http://www.robertpenner.com/easing/</A></P><P>	var animationOptions = {
		linear : function (t){
			return t;
		},
		easeInQuad: function (t) {
			return t*t;
		},
		easeOutQuad: function (t) {
			return -1 *t*(t-2);
		},
		easeInOutQuad: function (t) {
			if ((t/=1/2) &lt; 1) return 1/2*t*t;
			return -1/2 * ((--t)*(t-2) - 1);
		},
		easeInCubic: function (t) {
			return t*t*t;
		},
		easeOutCubic: function (t) {
			return 1*((t=t/1-1)*t*t + 1);
		},
		easeInOutCubic: function (t) {
			if ((t/=1/2) &lt; 1) return 1/2*t*t*t;
			return 1/2*((t-=2)*t*t + 2);
		},
		easeInQuart: function (t) {
			return t*t*t*t;
		},
		easeOutQuart: function (t) {
			return -1 * ((t=t/1-1)*t*t*t - 1);
		},
		easeInOutQuart: function (t) {
			if ((t/=1/2) &lt; 1) return 1/2*t*t*t*t;
			return -1/2 * ((t-=2)*t*t*t - 2);
		},
		easeInQuint: function (t) {
			return 1*(t/=1)*t*t*t*t;
		},
		easeOutQuint: function (t) {
			return 1*((t=t/1-1)*t*t*t*t + 1);
		},
		easeInOutQuint: function (t) {
			if ((t/=1/2) &lt; 1) return 1/2*t*t*t*t*t;
			return 1/2*((t-=2)*t*t*t*t + 2);
		},
		easeInSine: function (t) {
			return -1 * Math.cos(t/1 * (Math.PI/2)) + 1;
		},
		easeOutSine: function (t) {
			return 1 * Math.sin(t/1 * (Math.PI/2));
		},
		easeInOutSine: function (t) {
			return -1/2 * (Math.cos(Math.PI*t/1) - 1);
		},
		easeInExpo: function (t) {
			return (t==0) ? 1 : 1 * Math.pow(2, 10 * (t/1 - 1));
		},
		easeOutExpo: function (t) {
			return (t==1) ? 1 : 1 * (-Math.pow(2, -10 * t/1) + 1);
		},
		easeInOutExpo: function (t) {
			if (t==0) return 0;
			if (t==1) return 1;
			if ((t/=1/2) &lt; 1) return 1/2 * Math.pow(2, 10 * (t - 1));
			return 1/2 * (-Math.pow(2, -10 * --t) + 2);
			},
		easeInCirc: function (t) {
			if (t&gt;=1) return t;
			return -1 * (Math.sqrt(1 - (t/=1)*t) - 1);
		},
		easeOutCirc: function (t) {
			return 1 * Math.sqrt(1 - (t=t/1-1)*t);
		},
		easeInOutCirc: function (t) {
			if ((t/=1/2) &lt; 1) return -1/2 * (Math.sqrt(1 - t*t) - 1);
			return 1/2 * (Math.sqrt(1 - (t-=2)*t) + 1);
		},
		easeInElastic: function (t) {
			var s=1.70158;var p=0;var a=1;
			if (t==0) return 0;  if ((t/=1)==1) return 1;  if (!p) p=1*.3;
			if (a &lt; Math.abs(1)) { a=1; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (1/a);
			return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p ));
		},
		easeOutElastic: function (t) {
			var s=1.70158;var p=0;var a=1;
			if (t==0) return 0;  if ((t/=1)==1) return 1;  if (!p) p=1*.3;
			if (a &lt; Math.abs(1)) { a=1; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (1/a);
			return a*Math.pow(2,-10*t) * Math.sin( (t*1-s)*(2*Math.PI)/p ) + 1;
		},
		easeInOutElastic: function (t) {
			var s=1.70158;var p=0;var a=1;
			if (t==0) return 0;  if ((t/=1/2)==2) return 1;  if (!p) p=1*(.3*1.5);
			if (a &lt; Math.abs(1)) { a=1; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (1/a);
			if (t &lt; 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p ));
			return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p )*.5 + 1;
		},
		easeInBack: function (t) {
			var s = 1.70158;
			return 1*(t/=1)*t*((s+1)*t - s);
		},
		easeOutBack: function (t) {
			var s = 1.70158;
			return 1*((t=t/1-1)*t*((s+1)*t + s) + 1);
		},
		easeInOutBack: function (t) {
			var s = 1.70158; 
			if ((t/=1/2) &lt; 1) return 1/2*(t*t*(((s*=(1.525))+1)*t - s));
			return 1/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
		},
		easeInBounce: function (t) {
			return 1 - animationOptions.easeOutBounce (1-t);
		},
		easeOutBounce: function (t) {
			if ((t/=1) &lt; (1/2.75)) {
				return 1*(7.5625*t*t);
			} else if (t &lt; (2/2.75)) {
				return 1*(7.5625*(t-=(1.5/2.75))*t + .75);
			} else if (t &lt; (2.5/2.75)) {
				return 1*(7.5625*(t-=(2.25/2.75))*t + .9375);
			} else {
				return 1*(7.5625*(t-=(2.625/2.75))*t + .984375);
			}
		},
		easeInOutBounce: function (t) {
			if (t &lt; 1/2) return animationOptions.easeInBounce (t*2) * .5;
			return animationOptions.easeOutBounce (t*2-1) * .5 + 1*.5;
		}
	};
</P><P>	//Variables global to the chart
	var width = context.canvas.width;
	var height = context.canvas.height;
</P><P>
	//High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.
	if (window.devicePixelRatio) {
		context.canvas.style.width = width + &quot;px&quot;;
		context.canvas.style.height = height + &quot;px&quot;;
		context.canvas.height = height * window.devicePixelRatio;
		context.canvas.width = width * window.devicePixelRatio;
		context.scale(window.devicePixelRatio, window.devicePixelRatio);
	}
</P><P>	this.PolarArea = function(data,options){
</P><P>		chart.PolarArea.defaults = {
			scaleOverlay : true,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			scaleShowLine : true,
			scaleLineColor : &quot;rgba(0,0,0,.1)&quot;,
			scaleLineWidth : 1,
			scaleShowLabels : true,
			scaleLabel : &quot;&lt;%=value%&gt;&quot;,
			scaleFontFamily : &quot;'Arial'&quot;,
			scaleFontSize : 12,
			scaleFontStyle : &quot;normal&quot;,
			scaleFontColor : &quot;#666&quot;,
			scaleShowLabelBackdrop : true,
			scaleBackdropColor : &quot;rgba(255,255,255,0.75)&quot;,
			scaleBackdropPaddingY : 2,
			scaleBackdropPaddingX : 2,
			segmentShowStroke : true,
			segmentStrokeColor : &quot;#fff&quot;,
			segmentStrokeWidth : 2,
			animation : true,
			animationSteps : 100,
			animationEasing : &quot;easeOutBounce&quot;,
			animateRotate : true,
			animateScale : false,
			onAnimationComplete : null
		};
</P><P>		var config = (options)? mergeChartConfig(chart.PolarArea.defaults,options) : chart.PolarArea.defaults;
</P><P>		return new PolarArea(data,config,context);
	};
</P><P>	this.Radar = function(data,options){
</P><P>		chart.Radar.defaults = {
			scaleOverlay : false,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			scaleShowLine : true,
			scaleLineColor : &quot;rgba(0,0,0,.1)&quot;,
			scaleLineWidth : 1,
			scaleShowLabels : false,
			scaleLabel : &quot;&lt;%=value%&gt;&quot;,
			scaleFontFamily : &quot;'Arial'&quot;,
			scaleFontSize : 12,
			scaleFontStyle : &quot;normal&quot;,
			scaleFontColor : &quot;#666&quot;,
			scaleShowLabelBackdrop : true,
			scaleBackdropColor : &quot;rgba(255,255,255,0.75)&quot;,
			scaleBackdropPaddingY : 2,
			scaleBackdropPaddingX : 2,
			angleShowLineOut : true,
			angleLineColor : &quot;rgba(0,0,0,.1)&quot;,
			angleLineWidth : 1,			
			pointLabelFontFamily : &quot;'Arial'&quot;,
			pointLabelFontStyle : &quot;normal&quot;,
			pointLabelFontSize : 12,
			pointLabelFontColor : &quot;#666&quot;,
			pointDot : true,
			pointDotRadius : 3,
			pointDotStrokeWidth : 1,
			datasetStroke : true,
			datasetStrokeWidth : 2,
			datasetFill : true,
			animation : true,
			animationSteps : 60,
			animationEasing : &quot;easeOutQuart&quot;,
			onAnimationComplete : null
		};
</P><P>		var config = (options)? mergeChartConfig(chart.Radar.defaults,options) : chart.Radar.defaults;
</P><P>		return new Radar(data,config,context);
	};
</P><P>	this.Pie = function(data,options){
		chart.Pie.defaults = {
			segmentShowStroke : true,
			segmentStrokeColor : &quot;#fff&quot;,
			segmentStrokeWidth : 2,
			animation : true,
			animationSteps : 100,
			animationEasing : &quot;easeOutBounce&quot;,
			animateRotate : true,
			animateScale : false,
			onAnimationComplete : null
		};		
</P><P>		var config = (options)? mergeChartConfig(chart.Pie.defaults,options) : chart.Pie.defaults;
</P><P>		return new Pie(data,config,context);				
	};
</P><P>	this.Doughnut = function(data,options){
</P><P>		chart.Doughnut.defaults = {
			segmentShowStroke : true,
			segmentStrokeColor : &quot;#fff&quot;,
			segmentStrokeWidth : 2,
			percentageInnerCutout : 50,
			animation : true,
			animationSteps : 100,
			animationEasing : &quot;easeOutBounce&quot;,
			animateRotate : true,
			animateScale : false,
			onAnimationComplete : null
		};		
</P><P>		var config = (options)? mergeChartConfig(chart.Doughnut.defaults,options) : chart.Doughnut.defaults;
</P><P>		return new Doughnut(data,config,context);			
</P><P>	};
</P><P>	this.Line = function(data,options){
</P><P>		chart.Line.defaults = {
			scaleOverlay : false,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			scaleLineColor : &quot;rgba(0,0,0,.1)&quot;,
			scaleLineWidth : 1,
			scaleShowLabels : true,
			scaleLabel : &quot;&lt;%=value%&gt;&quot;,
			scaleFontFamily : &quot;'Arial'&quot;,
			scaleFontSize : 12,
			scaleFontStyle : &quot;normal&quot;,
			scaleFontColor : &quot;#666&quot;,
			scaleShowGridLines : true,
			scaleGridLineColor : &quot;rgba(0,0,0,.05)&quot;,
			scaleGridLineWidth : 1,
			bezierCurve : true,
			pointDot : true,
			pointDotRadius : 4,
			pointDotStrokeWidth : 2,
			datasetStroke : true,
			datasetStrokeWidth : 2,
			datasetFill : true,
			animation : true,
			animationSteps : 60,
			animationEasing : &quot;easeOutQuart&quot;,
			onAnimationComplete : null
		};		
		var config = (options) ? mergeChartConfig(chart.Line.defaults,options) : chart.Line.defaults;
</P><P>		return new Line(data,config,context);
	}
</P><P>	this.Bar = function(data,options){
		chart.Bar.defaults = {
			scaleOverlay : false,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			scaleLineColor : &quot;rgba(0,0,0,.1)&quot;,
			scaleLineWidth : 1,
			scaleShowLabels : true,
			scaleLabel : &quot;&lt;%=value%&gt;&quot;,
			scaleFontFamily : &quot;'Arial'&quot;,
			scaleFontSize : 12,
			scaleFontStyle : &quot;normal&quot;,
			scaleFontColor : &quot;#666&quot;,
			scaleShowGridLines : true,
			scaleGridLineColor : &quot;rgba(0,0,0,.05)&quot;,
			scaleGridLineWidth : 1,
			barShowStroke : true,
			barStrokeWidth : 2,
			barValueSpacing : 5,
			barDatasetSpacing : 1,
			animation : true,
			animationSteps : 60,
			animationEasing : &quot;easeOutQuart&quot;,
			onAnimationComplete : null
		};		
		var config = (options) ? mergeChartConfig(chart.Bar.defaults,options) : chart.Bar.defaults;
</P><P>		return new Bar(data,config,context);		
	}
</P><P>	var clear = function(c){
		c.clearRect(0, 0, width, height);
	};
</P><P>	var PolarArea = function(data,config,ctx){
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString;		
</P><P>
		calculateDrawingSizes();
</P><P>		valueBounds = getValueBounds();
</P><P>		labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : null;
</P><P>		//Check and set the scale
		if (!config.scaleOverride){
</P><P>			calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
		}
		else {
			calculatedScale = {
				steps : config.scaleSteps,
				stepValue : config.scaleStepWidth,
				graphMin : config.scaleStartValue,
				labels : []
			}
			populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
		}
</P><P>		scaleHop = maxSize/(calculatedScale.steps);
</P><P>		//Wrap in an animation loop wrapper
		animationLoop(config,drawScale,drawAllSegments,ctx);
</P><P>		function calculateDrawingSizes(){
			maxSize = (Min([width,height])/2);
			//Remove whatever is larger - the font size or line width.
</P><P>			maxSize -= Max([config.scaleFontSize*0.5,config.scaleLineWidth*0.5]);
</P><P>			labelHeight = config.scaleFontSize*2;
			//If we're drawing the backdrop - add the Y padding to the label height and remove from drawing region.
			if (config.scaleShowLabelBackdrop){
				labelHeight += (2 * config.scaleBackdropPaddingY);
				maxSize -= config.scaleBackdropPaddingY*1.5;
			}
</P><P>			scaleHeight = maxSize;
			//If the label height is less than 5, set it to 5 so we don't have lines on top of each other.
			labelHeight = Default(labelHeight,5);
		}
		function drawScale(){
			for (var i=0; i&lt;calculatedScale.steps; i++){
				//If the line object is there
				if (config.scaleShowLine){
					ctx.beginPath();
					ctx.arc(width/2, height/2, scaleHop * (i + 1), 0, (Math.PI * 2), true);
					ctx.strokeStyle = config.scaleLineColor;
					ctx.lineWidth = config.scaleLineWidth;
					ctx.stroke();
				}
</P><P>				if (config.scaleShowLabels){
					ctx.textAlign = &quot;center&quot;;
					ctx.font = config.scaleFontStyle + &quot; &quot; + config.scaleFontSize + &quot;px &quot; + config.scaleFontFamily;
</P><PRE>					var label =  calculatedScale.labels[i];
</PRE><P>					//If the backdrop object is within the font object
					if (config.scaleShowLabelBackdrop){
						var textWidth = ctx.measureText(label).width;
						ctx.fillStyle = config.scaleBackdropColor;
						ctx.beginPath();
						ctx.rect(
							Math.round(width/2 - textWidth/2 - config.scaleBackdropPaddingX),     //X
							Math.round(height/2 - (scaleHop * (i + 1)) - config.scaleFontSize*0.5 - config.scaleBackdropPaddingY),//Y
							Math.round(textWidth + (config.scaleBackdropPaddingX*2)), //Width
							Math.round(config.scaleFontSize + (config.scaleBackdropPaddingY*2)) //Height
						);
						ctx.fill();
					}
					ctx.textBaseline = &quot;middle&quot;;
					ctx.fillStyle = config.scaleFontColor;
					ctx.fillText(label,width/2,height/2 - (scaleHop * (i + 1)));
				}
			}
		}
		function drawAllSegments(animationDecimal){
			var startAngle = -Math.PI/2,
			angleStep = (Math.PI*2)/data.length,
			scaleAnimation = 1,
			rotateAnimation = 1;
			if (config.animation) {
				if (config.animateScale) {
					scaleAnimation = animationDecimal;
				}
				if (config.animateRotate){
					rotateAnimation = animationDecimal;
				}
			}
</P><P>			for (var i=0; i&lt;data.length; i++){
</P><P>				ctx.beginPath();
				ctx.arc(width/2,height/2,scaleAnimation * calculateOffset(data[i].value,calculatedScale,scaleHop),startAngle, startAngle + rotateAnimation*angleStep, false);
				ctx.lineTo(width/2,height/2);
				ctx.closePath();
				ctx.fillStyle = data[i].color;
				ctx.fill();
</P><P>				if(config.segmentShowStroke){
					ctx.strokeStyle = config.segmentStrokeColor;
					ctx.lineWidth = config.segmentStrokeWidth;
					ctx.stroke();
				}
				startAngle += rotateAnimation*angleStep;
			}
		}
		function getValueBounds() {
			var upperValue = Number.MIN_VALUE;
			var lowerValue = Number.MAX_VALUE;
			for (var i=0; i&lt;data.length; i++){
				if (data[i].value &gt; upperValue) {upperValue = data[i].value;}
				if (data[i].value &lt; lowerValue) {lowerValue = data[i].value;}
			};
</P><P>			var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight*0.5));
</P><P>			return {
				maxValue : upperValue,
				minValue : lowerValue,
				maxSteps : maxSteps,
				minSteps : minSteps
			};
</P><P>
		}
	}
</P><P>	var Radar = function (data,config,ctx) {
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString;	
</P><P>		//If no labels are defined set to an empty array, so referencing length for looping doesn't blow up.
		if (!data.labels) data.labels = [];
</P><P>		calculateDrawingSizes();
</P><P>		var valueBounds = getValueBounds();
</P><P>		labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : null;
</P><P>		//Check and set the scale
		if (!config.scaleOverride){
</P><P>			calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
		}
		else {
			calculatedScale = {
				steps : config.scaleSteps,
				stepValue : config.scaleStepWidth,
				graphMin : config.scaleStartValue,
				labels : []
			}
			populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
		}
</P><P>		scaleHop = maxSize/(calculatedScale.steps);
</P><P>		animationLoop(config,drawScale,drawAllDataPoints,ctx);
</P><P>		//Radar specific functions.
		function drawAllDataPoints(animationDecimal){
			var rotationDegree = (2*Math.PI)/data.datasets[0].data.length;
</P><P>			ctx.save();
			//translate to the centre of the canvas.
			ctx.translate(width/2,height/2);
</P><P>			//We accept multiple data sets for radar charts, so show loop through each set
			for (var i=0; i&lt;data.datasets.length; i++){
				ctx.beginPath();
</P><P>				ctx.moveTo(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[0],calculatedScale,scaleHop)));
				for (var j=1; j&lt;data.datasets[i].data.length; j++){
					ctx.rotate(rotationDegree);	
					ctx.lineTo(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)));
</P><P>				}
				ctx.closePath();
</P><P>
				ctx.fillStyle = data.datasets[i].fillColor;
				ctx.strokeStyle = data.datasets[i].strokeColor;
				ctx.lineWidth = config.datasetStrokeWidth;
				ctx.fill();
				ctx.stroke();
</P><P>
				if (config.pointDot){
					ctx.fillStyle = data.datasets[i].pointColor;
					ctx.strokeStyle = data.datasets[i].pointStrokeColor;
					ctx.lineWidth = config.pointDotStrokeWidth;
					for (var k=0; k&lt;data.datasets[i].data.length; k++){
						ctx.rotate(rotationDegree);
						ctx.beginPath();
						ctx.arc(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[k],calculatedScale,scaleHop)),config.pointDotRadius,2*Math.PI,false);
						ctx.fill();
						ctx.stroke();
					}					
</P><P>				}
				ctx.rotate(rotationDegree);
</P><P>			}
			ctx.restore();
</P><P>
		}
		function drawScale(){
			var rotationDegree = (2*Math.PI)/data.datasets[0].data.length;
			ctx.save();
		    ctx.translate(width / 2, height / 2);	
</P><P>			if (config.angleShowLineOut){
				ctx.strokeStyle = config.angleLineColor;		    	    
				ctx.lineWidth = config.angleLineWidth;
				for (var h=0; h&lt;data.datasets[0].data.length; h++){
</P><P>				    ctx.rotate(rotationDegree);
					ctx.beginPath();
					ctx.moveTo(0,0);
					ctx.lineTo(0,-maxSize);
					ctx.stroke();
				}
			}
</P><P>			for (var i=0; i&lt;calculatedScale.steps; i++){
				ctx.beginPath();
</P><P>				if(config.scaleShowLine){
					ctx.strokeStyle = config.scaleLineColor;
					ctx.lineWidth = config.scaleLineWidth;
					ctx.moveTo(0,-scaleHop * (i+1));					
					for (var j=0; j&lt;data.datasets[0].data.length; j++){
					    ctx.rotate(rotationDegree);
						ctx.lineTo(0,-scaleHop * (i+1));
					}
					ctx.closePath();
					ctx.stroke();			
</P><P>				}
</P><P>				if (config.scaleShowLabels){				
					ctx.textAlign = 'center';
					ctx.font = config.scaleFontStyle + &quot; &quot; + config.scaleFontSize+&quot;px &quot; + config.scaleFontFamily; 
					ctx.textBaseline = &quot;middle&quot;;
</P><P>					if (config.scaleShowLabelBackdrop){
						var textWidth = ctx.measureText(calculatedScale.labels[i]).width;
						ctx.fillStyle = config.scaleBackdropColor;
						ctx.beginPath();
						ctx.rect(
							Math.round(- textWidth/2 - config.scaleBackdropPaddingX),     //X
							Math.round((-scaleHop * (i + 1)) - config.scaleFontSize*0.5 - config.scaleBackdropPaddingY),//Y
							Math.round(textWidth + (config.scaleBackdropPaddingX*2)), //Width
							Math.round(config.scaleFontSize + (config.scaleBackdropPaddingY*2)) //Height
						);
						ctx.fill();
					}						
					ctx.fillStyle = config.scaleFontColor;
					ctx.fillText(calculatedScale.labels[i],0,-scaleHop*(i+1));
				}
</P><P>			}
			for (var k=0; k&lt;data.labels.length; k++){				
			ctx.font = config.pointLabelFontStyle + &quot; &quot; + config.pointLabelFontSize+&quot;px &quot; + config.pointLabelFontFamily;
			ctx.fillStyle = config.pointLabelFontColor;
				var opposite = Math.sin(rotationDegree*k) * (maxSize + config.pointLabelFontSize);
				var adjacent = Math.cos(rotationDegree*k) * (maxSize + config.pointLabelFontSize);
</P><P>				if(rotationDegree*k == Math.PI || rotationDegree*k == 0){
					ctx.textAlign = &quot;center&quot;;
				}
				else if(rotationDegree*k &gt; Math.PI){
					ctx.textAlign = &quot;right&quot;;
				}
				else{
					ctx.textAlign = &quot;left&quot;;
				}
</P><P>				ctx.textBaseline = &quot;middle&quot;;
</P><P>				ctx.fillText(data.labels[k],opposite,-adjacent);
</P><P>			}
			ctx.restore();
		};
		function calculateDrawingSizes(){
			maxSize = (Min([width,height])/2);
</P><P>			labelHeight = config.scaleFontSize*2;
</P><P>			var labelLength = 0;
			for (var i=0; i&lt;data.labels.length; i++){
				ctx.font = config.pointLabelFontStyle + &quot; &quot; + config.pointLabelFontSize+&quot;px &quot; + config.pointLabelFontFamily;
				var textMeasurement = ctx.measureText(data.labels[i]).width;
				if(textMeasurement&gt;labelLength) labelLength = textMeasurement;
			}
</P><P>			//Figure out whats the largest - the height of the text or the width of what's there, and minus it from the maximum usable size.
			maxSize -= Max([labelLength,((config.pointLabelFontSize/2)*1.5)]);				
</P><P>			maxSize -= config.pointLabelFontSize;
			maxSize = CapValue(maxSize, null, 0);
			scaleHeight = maxSize;
			//If the label height is less than 5, set it to 5 so we don't have lines on top of each other.
			labelHeight = Default(labelHeight,5);
		};
		function getValueBounds() {
			var upperValue = Number.MIN_VALUE;
			var lowerValue = Number.MAX_VALUE;
</P><P>			for (var i=0; i&lt;data.datasets.length; i++){
				for (var j=0; j&lt;data.datasets[i].data.length; j++){
					if (data.datasets[i].data[j] &gt; upperValue){upperValue = data.datasets[i].data[j]}
					if (data.datasets[i].data[j] &lt; lowerValue){lowerValue = data.datasets[i].data[j]}
				}
			}
</P><P>			var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight*0.5));
</P><P>			return {
				maxValue : upperValue,
				minValue : lowerValue,
				maxSteps : maxSteps,
				minSteps : minSteps
			};
</P><P>
		}
	}
</P><P>	var Pie = function(data,config,ctx){
		var segmentTotal = 0;
</P><P>		//In case we have a canvas that is not a square. Minus 5 pixels as padding round the edge.
		var pieRadius = Min([height/2,width/2]) - 5;
</P><P>		for (var i=0; i&lt;data.length; i++){
			segmentTotal += data[i].value;
		}
</P><P>
		animationLoop(config,null,drawPieSegments,ctx);
</P><P>		function drawPieSegments (animationDecimal){
			var cumulativeAngle = -Math.PI/2,
			scaleAnimation = 1,
			rotateAnimation = 1;
			if (config.animation) {
				if (config.animateScale) {
					scaleAnimation = animationDecimal;
				}
				if (config.animateRotate){
					rotateAnimation = animationDecimal;
				}
			}
			for (var i=0; i&lt;data.length; i++){
				var segmentAngle = rotateAnimation * ((data[i].value/segmentTotal) * (Math.PI*2));
				ctx.beginPath();
				ctx.arc(width/2,height/2,scaleAnimation * pieRadius,cumulativeAngle,cumulativeAngle + segmentAngle);
				ctx.lineTo(width/2,height/2);
				ctx.closePath();
				ctx.fillStyle = data[i].color;
				ctx.fill();
</P><P>				if(config.segmentShowStroke){
					ctx.lineWidth = config.segmentStrokeWidth;
					ctx.strokeStyle = config.segmentStrokeColor;
					ctx.stroke();
				}
				cumulativeAngle += segmentAngle;
			}			
		}		
	}
</P><P>	var Doughnut = function(data,config,ctx){
		var segmentTotal = 0;
</P><P>		//In case we have a canvas that is not a square. Minus 5 pixels as padding round the edge.
		var doughnutRadius = Min([height/2,width/2]) - 5;
</P><P>		var cutoutRadius = doughnutRadius * (config.percentageInnerCutout/100);
</P><P>		for (var i=0; i&lt;data.length; i++){
			segmentTotal += data[i].value;
		}
</P><P>
		animationLoop(config,null,drawPieSegments,ctx);
</P><P>
		function drawPieSegments (animationDecimal){
			var cumulativeAngle = -Math.PI/2,
			scaleAnimation = 1,
			rotateAnimation = 1;
			if (config.animation) {
				if (config.animateScale) {
					scaleAnimation = animationDecimal;
				}
				if (config.animateRotate){
					rotateAnimation = animationDecimal;
				}
			}
			for (var i=0; i&lt;data.length; i++){
				var segmentAngle = rotateAnimation * ((data[i].value/segmentTotal) * (Math.PI*2));
				ctx.beginPath();
				ctx.arc(width/2,height/2,scaleAnimation * doughnutRadius,cumulativeAngle,cumulativeAngle + segmentAngle,false);
				ctx.arc(width/2,height/2,scaleAnimation * cutoutRadius,cumulativeAngle + segmentAngle,cumulativeAngle,true);
				ctx.closePath();
				ctx.fillStyle = data[i].color;
				ctx.fill();
</P><P>				if(config.segmentShowStroke){
					ctx.lineWidth = config.segmentStrokeWidth;
					ctx.strokeStyle = config.segmentStrokeColor;
					ctx.stroke();
				}
				cumulativeAngle += segmentAngle;
			}			
		}			
</P><P>	}
</P><P>	var Line = function(data,config,ctx){
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop,widestXLabel, xAxisLength,yAxisPosX,xAxisPosY, rotateLabels = 0;
</P><P>		calculateDrawingSizes();
</P><P>		valueBounds = getValueBounds();
		//Check and set the scale
		labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : &quot;&quot;;
		if (!config.scaleOverride){
</P><P>			calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
		}
		else {
			calculatedScale = {
				steps : config.scaleSteps,
				stepValue : config.scaleStepWidth,
				graphMin : config.scaleStartValue,
				labels : []
			}
			populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
		}
</P><P>		scaleHop = Math.floor(scaleHeight/calculatedScale.steps);
		calculateXAxisSize();
		animationLoop(config,drawScale,drawLines,ctx);		
</P><P>		function drawLines(animPc){
			for (var i=0; i&lt;data.datasets.length; i++){
				ctx.strokeStyle = data.datasets[i].strokeColor;
				ctx.lineWidth = config.datasetStrokeWidth;
				ctx.beginPath();
				ctx.moveTo(yAxisPosX, xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[0],calculatedScale,scaleHop)))
</P><P>				for (var j=1; j&lt;data.datasets[i].data.length; j++){
					if (config.bezierCurve){
						ctx.bezierCurveTo(xPos(j-0.5),yPos(i,j-1),xPos(j-0.5),yPos(i,j),xPos(j),yPos(i,j));
					}
					else{
						ctx.lineTo(xPos(j),yPos(i,j));
					}
				}
				ctx.stroke();
				if (config.datasetFill){
					ctx.lineTo(yAxisPosX + (valueHop*(data.datasets[i].data.length-1)),xAxisPosY);
					ctx.lineTo(yAxisPosX,xAxisPosY);
					ctx.closePath();
					ctx.fillStyle = data.datasets[i].fillColor;
					ctx.fill();
				}
				else{
					ctx.closePath();
				}
				if(config.pointDot){
					ctx.fillStyle = data.datasets[i].pointColor;
					ctx.strokeStyle = data.datasets[i].pointStrokeColor;
					ctx.lineWidth = config.pointDotStrokeWidth;
					for (var k=0; k&lt;data.datasets[i].data.length; k++){
						ctx.beginPath();
						ctx.arc(yAxisPosX + (valueHop *k),xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[k],calculatedScale,scaleHop)),config.pointDotRadius,0,Math.PI*2,true);
						ctx.fill();
						ctx.stroke();
					}
				}
			}
</P><P>			function yPos(dataSet,iteration){
				return xAxisPosY - animPc*(calculateOffset(data.datasets[dataSet].data[iteration],calculatedScale,scaleHop));			
			}
			function xPos(iteration){
				return yAxisPosX + (valueHop * iteration);
			}
		}
		function drawScale(){
			//X axis line
			ctx.lineWidth = config.scaleLineWidth;
			ctx.strokeStyle = config.scaleLineColor;
			ctx.beginPath();
			ctx.moveTo(width-widestXLabel/2+5,xAxisPosY);
			ctx.lineTo(width-(widestXLabel/2)-xAxisLength-5,xAxisPosY);
			ctx.stroke();
</P><P>
			if (rotateLabels &gt; 0){
				ctx.save();
				ctx.textAlign = &quot;right&quot;;
			}
			else{
				ctx.textAlign = &quot;center&quot;;
			}
			ctx.fillStyle = config.scaleFontColor;
			for (var i=0; i&lt;data.labels.length; i++){
				ctx.save();
				if (rotateLabels &gt; 0){
					ctx.translate(yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize);
					ctx.rotate(-(rotateLabels * (Math.PI/180)));
					ctx.fillText(data.labels[i], 0,0);
					ctx.restore();
				}
</P><P>				else{
					ctx.fillText(data.labels[i], yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize+3);					
				}
</P><P>				ctx.beginPath();
				ctx.moveTo(yAxisPosX + i * valueHop, xAxisPosY+3);
</P><P>				//Check i isnt 0, so we dont go over the Y axis twice.
				if(config.scaleShowGridLines &amp;&amp; i&gt;0){
					ctx.lineWidth = config.scaleGridLineWidth;
					ctx.strokeStyle = config.scaleGridLineColor;					
					ctx.lineTo(yAxisPosX + i * valueHop, 5);
				}
				else{
					ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY+3);				
				}
				ctx.stroke();
			}
</P><P>			//Y axis
			ctx.lineWidth = config.scaleLineWidth;
			ctx.strokeStyle = config.scaleLineColor;
			ctx.beginPath();
			ctx.moveTo(yAxisPosX,xAxisPosY+5);
			ctx.lineTo(yAxisPosX,5);
			ctx.stroke();
</P><P>			ctx.textAlign = &quot;right&quot;;
			ctx.textBaseline = &quot;middle&quot;;
			for (var j=0; j&lt;calculatedScale.steps; j++){
				ctx.beginPath();
				ctx.moveTo(yAxisPosX-3,xAxisPosY - ((j+1) * scaleHop));
				if (config.scaleShowGridLines){
					ctx.lineWidth = config.scaleGridLineWidth;
					ctx.strokeStyle = config.scaleGridLineColor;
					ctx.lineTo(yAxisPosX + xAxisLength + 5,xAxisPosY - ((j+1) * scaleHop));					
				}
				else{
					ctx.lineTo(yAxisPosX-0.5,xAxisPosY - ((j+1) * scaleHop));
				}
</P><P>				ctx.stroke();
</P><P>				if (config.scaleShowLabels){
					ctx.fillText(calculatedScale.labels[j],yAxisPosX-8,xAxisPosY - ((j+1) * scaleHop));
				}
			}
</P><P>
		}
		function calculateXAxisSize(){
			var longestText = 1;
			//if we are showing the labels
			if (config.scaleShowLabels){
				ctx.font = config.scaleFontStyle + &quot; &quot; + config.scaleFontSize+&quot;px &quot; + config.scaleFontFamily;
				for (var i=0; i&lt;calculatedScale.labels.length; i++){
					var measuredText = ctx.measureText(calculatedScale.labels[i]).width;
					longestText = (measuredText &gt; longestText)? measuredText : longestText;
				}
				//Add a little extra padding from the y axis
				longestText +=10;
			}
			xAxisLength = width - longestText - widestXLabel;
			valueHop = Math.floor(xAxisLength/(data.labels.length-1));	
</P><P>			yAxisPosX = width-widestXLabel/2-xAxisLength;
			xAxisPosY = scaleHeight + config.scaleFontSize/2;				
		}		
		function calculateDrawingSizes(){
			maxSize = height;
</P><P>			//Need to check the X axis first - measure the length of each text metric, and figure out if we need to rotate by 45 degrees.
			ctx.font = config.scaleFontStyle + &quot; &quot; + config.scaleFontSize+&quot;px &quot; + config.scaleFontFamily;
			widestXLabel = 1;
			for (var i=0; i&lt;data.labels.length; i++){
				var textLength = ctx.measureText(data.labels[i]).width;
				//If the text length is longer - make that equal to longest text!
				widestXLabel = (textLength &gt; widestXLabel)? textLength : widestXLabel;
			}
			if (width/data.labels.length &lt; widestXLabel){
				rotateLabels = 45;
				if (width/data.labels.length &lt; Math.cos(rotateLabels) * widestXLabel){
					rotateLabels = 90;
					maxSize -= widestXLabel; 
				}
				else{
					maxSize -= Math.sin(rotateLabels) * widestXLabel;
				}
			}
			else{
				maxSize -= config.scaleFontSize;
			}
</P><P>			//Add a little padding between the x line and the text
			maxSize -= 5;
</P><P>
			labelHeight = config.scaleFontSize;
</P><P>			maxSize -= labelHeight;
			//Set 5 pixels greater than the font size to allow for a little padding from the X axis.
</P><P>			scaleHeight = maxSize;
</P><P>			//Then get the area above we can safely draw on.
</P><P>		}		
		function getValueBounds() {
			var upperValue = Number.MIN_VALUE;
			var lowerValue = Number.MAX_VALUE;
			for (var i=0; i&lt;data.datasets.length; i++){
				for (var j=0; j&lt;data.datasets[i].data.length; j++){
					if ( data.datasets[i].data[j] &gt; upperValue) { upperValue = data.datasets[i].data[j] };
					if ( data.datasets[i].data[j] &lt; lowerValue) { lowerValue = data.datasets[i].data[j] };
				}
			};
</P><P>			var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight*0.5));
</P><P>			return {
				maxValue : upperValue,
				minValue : lowerValue,
				maxSteps : maxSteps,
				minSteps : minSteps
			};
</P><P>
		}
</P><P>
	}
</P><P>	var Bar = function(data,config,ctx){
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop,widestXLabel, xAxisLength,yAxisPosX,xAxisPosY,barWidth, rotateLabels = 0;
</P><P>		calculateDrawingSizes();
</P><P>		valueBounds = getValueBounds();
		//Check and set the scale
		labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : &quot;&quot;;
		if (!config.scaleOverride){
</P><P>			calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
		}
		else {
			calculatedScale = {
				steps : config.scaleSteps,
				stepValue : config.scaleStepWidth,
				graphMin : config.scaleStartValue,
				labels : []
			}
			populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
		}
</P><P>		scaleHop = Math.floor(scaleHeight/calculatedScale.steps);
		calculateXAxisSize();
		animationLoop(config,drawScale,drawBars,ctx);		
</P><P>		function drawBars(animPc){
			ctx.lineWidth = config.barStrokeWidth;
			for (var i=0; i&lt;data.datasets.length; i++){
					ctx.fillStyle = data.datasets[i].fillColor;
					ctx.strokeStyle = data.datasets[i].strokeColor;
				for (var j=0; j&lt;data.datasets[i].data.length; j++){
					var barOffset = yAxisPosX + config.barValueSpacing + valueHop*j + barWidth*i + config.barDatasetSpacing*i + config.barStrokeWidth*i;
</P><P>					ctx.beginPath();
					ctx.moveTo(barOffset, xAxisPosY);
					ctx.lineTo(barOffset, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
					ctx.lineTo(barOffset + barWidth, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
					ctx.lineTo(barOffset + barWidth, xAxisPosY);
					if(config.barShowStroke){
						ctx.stroke();
					}
					ctx.closePath();
					ctx.fill();
				}
			}
</P><P>		}
		function drawScale(){
			//X axis line
			ctx.lineWidth = config.scaleLineWidth;
			ctx.strokeStyle = config.scaleLineColor;
			ctx.beginPath();
			ctx.moveTo(width-widestXLabel/2+5,xAxisPosY);
			ctx.lineTo(width-(widestXLabel/2)-xAxisLength-5,xAxisPosY);
			ctx.stroke();
</P><P>
			if (rotateLabels &gt; 0){
				ctx.save();
				ctx.textAlign = &quot;right&quot;;
			}
			else{
				ctx.textAlign = &quot;center&quot;;
			}
			ctx.fillStyle = config.scaleFontColor;
			for (var i=0; i&lt;data.labels.length; i++){
				ctx.save();
				if (rotateLabels &gt; 0){
					ctx.translate(yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize);
					ctx.rotate(-(rotateLabels * (Math.PI/180)));
					ctx.fillText(data.labels[i], 0,0);
					ctx.restore();
				}
</P><P>				else{
					ctx.fillText(data.labels[i], yAxisPosX + i*valueHop + valueHop/2,xAxisPosY + config.scaleFontSize+3);					
				}
</P><P>				ctx.beginPath();
				ctx.moveTo(yAxisPosX + (i+1) * valueHop, xAxisPosY+3);
</P><P>				//Check i isnt 0, so we dont go over the Y axis twice.
					ctx.lineWidth = config.scaleGridLineWidth;
					ctx.strokeStyle = config.scaleGridLineColor;					
					ctx.lineTo(yAxisPosX + (i+1) * valueHop, 5);
				ctx.stroke();
			}
</P><P>			//Y axis
			ctx.lineWidth = config.scaleLineWidth;
			ctx.strokeStyle = config.scaleLineColor;
			ctx.beginPath();
			ctx.moveTo(yAxisPosX,xAxisPosY+5);
			ctx.lineTo(yAxisPosX,5);
			ctx.stroke();
</P><P>			ctx.textAlign = &quot;right&quot;;
			ctx.textBaseline = &quot;middle&quot;;
			for (var j=0; j&lt;calculatedScale.steps; j++){
				ctx.beginPath();
				ctx.moveTo(yAxisPosX-3,xAxisPosY - ((j+1) * scaleHop));
				if (config.scaleShowGridLines){
					ctx.lineWidth = config.scaleGridLineWidth;
					ctx.strokeStyle = config.scaleGridLineColor;
					ctx.lineTo(yAxisPosX + xAxisLength + 5,xAxisPosY - ((j+1) * scaleHop));					
				}
				else{
					ctx.lineTo(yAxisPosX-0.5,xAxisPosY - ((j+1) * scaleHop));
				}
</P><P>				ctx.stroke();
				if (config.scaleShowLabels){
					ctx.fillText(calculatedScale.labels[j],yAxisPosX-8,xAxisPosY - ((j+1) * scaleHop));
				}
			}
</P><P>
		}
		function calculateXAxisSize(){
			var longestText = 1;
			//if we are showing the labels
			if (config.scaleShowLabels){
				ctx.font = config.scaleFontStyle + &quot; &quot; + config.scaleFontSize+&quot;px &quot; + config.scaleFontFamily;
				for (var i=0; i&lt;calculatedScale.labels.length; i++){
					var measuredText = ctx.measureText(calculatedScale.labels[i]).width;
					longestText = (measuredText &gt; longestText)? measuredText : longestText;
				}
				//Add a little extra padding from the y axis
				longestText +=10;
			}
			xAxisLength = width - longestText - widestXLabel;
			valueHop = Math.floor(xAxisLength/(data.labels.length));	
</P><P>			barWidth = (valueHop - config.scaleGridLineWidth*2 - (config.barValueSpacing*2) - (config.barDatasetSpacing*data.datasets.length-1) - ((config.barStrokeWidth/2)*data.datasets.length-1))/data.datasets.length;
</P><P>			yAxisPosX = width-widestXLabel/2-xAxisLength;
			xAxisPosY = scaleHeight + config.scaleFontSize/2;				
		}		
		function calculateDrawingSizes(){
			maxSize = height;
</P><P>			//Need to check the X axis first - measure the length of each text metric, and figure out if we need to rotate by 45 degrees.
			ctx.font = config.scaleFontStyle + &quot; &quot; + config.scaleFontSize+&quot;px &quot; + config.scaleFontFamily;
			widestXLabel = 1;
			for (var i=0; i&lt;data.labels.length; i++){
				var textLength = ctx.measureText(data.labels[i]).width;
				//If the text length is longer - make that equal to longest text!
				widestXLabel = (textLength &gt; widestXLabel)? textLength : widestXLabel;
			}
			if (width/data.labels.length &lt; widestXLabel){
				rotateLabels = 45;
				if (width/data.labels.length &lt; Math.cos(rotateLabels) * widestXLabel){
					rotateLabels = 90;
					maxSize -= widestXLabel; 
				}
				else{
					maxSize -= Math.sin(rotateLabels) * widestXLabel;
				}
			}
			else{
				maxSize -= config.scaleFontSize;
			}
</P><P>			//Add a little padding between the x line and the text
			maxSize -= 5;
</P><P>
			labelHeight = config.scaleFontSize;
</P><P>			maxSize -= labelHeight;
			//Set 5 pixels greater than the font size to allow for a little padding from the X axis.
</P><P>			scaleHeight = maxSize;
</P><P>			//Then get the area above we can safely draw on.
</P><P>		}		
		function getValueBounds() {
			var upperValue = Number.MIN_VALUE;
			var lowerValue = Number.MAX_VALUE;
			for (var i=0; i&lt;data.datasets.length; i++){
				for (var j=0; j&lt;data.datasets[i].data.length; j++){
					if ( data.datasets[i].data[j] &gt; upperValue) { upperValue = data.datasets[i].data[j] };
					if ( data.datasets[i].data[j] &lt; lowerValue) { lowerValue = data.datasets[i].data[j] };
				}
			};
</P><P>			var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight*0.5));
</P><P>			return {
				maxValue : upperValue,
				minValue : lowerValue,
				maxSteps : maxSteps,
				minSteps : minSteps
			};
</P><P>
		}
	}
</P><P>	function calculateOffset(val,calculatedScale,scaleHop){
		var outerValue = calculatedScale.steps * calculatedScale.stepValue;
		var adjustedValue = val - calculatedScale.graphMin;
		var scalingFactor = CapValue(adjustedValue/outerValue,1,0);
		return (scaleHop*calculatedScale.steps) * scalingFactor;
	}
</P><P>	function animationLoop(config,drawScale,drawData,ctx){
		var animFrameAmount = (config.animation)? 1/CapValue(config.animationSteps,Number.MAX_VALUE,1) : 1,
			easingFunction = animationOptions[config.animationEasing],
			percentAnimComplete =(config.animation)? 0 : 1;
</P><P>		if (typeof drawScale !== &quot;function&quot;) drawScale = function(){};
</P><P>		requestAnimFrame(animLoop);
</P><P>		function animateFrame(){
			var easeAdjustedAnimationPercent =(config.animation)? CapValue(easingFunction(percentAnimComplete),null,0) : 1;
			clear(ctx);
			if(config.scaleOverlay){
				drawData(easeAdjustedAnimationPercent);
				drawScale();
			} else {
				drawScale();
				drawData(easeAdjustedAnimationPercent);
			}				
		}
		function animLoop(){
			//We need to check if the animation is incomplete (less than 1), or complete (1).
				percentAnimComplete += animFrameAmount;
				animateFrame();	
				//Stop the loop continuing forever
				if (percentAnimComplete &lt;= 1){
					requestAnimFrame(animLoop);
				}
				else{
					if (typeof config.onAnimationComplete == &quot;function&quot;) config.onAnimationComplete();
				}
</P><P>		}		
</P><P>	}
</P><P>	//Declare global functions to be called within this namespace here.
</P><P>
	// shim layer with setTimeout fallback
	var requestAnimFrame = (function(){
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) {
				window.setTimeout(callback, 1000 / 60);
			};
	})();
</P><P>	function calculateScale(drawingHeight,maxSteps,minSteps,maxValue,minValue,labelTemplateString){
			var graphMin,graphMax,graphRange,stepValue,numberOfSteps,valueRange,rangeOrderOfMagnitude,decimalNum;
</P><P>			valueRange = maxValue - minValue;
</P><P>			rangeOrderOfMagnitude = calculateOrderOfMagnitude(valueRange);
</P><PRE>       	graphMin = Math.floor(minValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);
           
           graphMax = Math.ceil(maxValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);
           
           graphRange = graphMax - graphMin;
           
           stepValue = Math.pow(10, rangeOrderOfMagnitude);
           
</PRE><P>	        numberOfSteps = Math.round(graphRange / stepValue);
</P><P>	        //Compare number of steps to the max and min for that size graph, and add in half steps if need be.	        
	        while(numberOfSteps &lt; minSteps || numberOfSteps &gt; maxSteps) {
	        	if (numberOfSteps &lt; minSteps){
			        stepValue /= 2;
			        numberOfSteps = Math.round(graphRange/stepValue);
		        }
		        else{
			        stepValue *=2;
			        numberOfSteps = Math.round(graphRange/stepValue);
		        }
	        };
</P><P>	        var labels = [];
	        populateLabels(labelTemplateString, labels, numberOfSteps, graphMin, stepValue);
</P><P>	        return {
		        steps : numberOfSteps,
				stepValue : stepValue,
				graphMin : graphMin,
				labels : labels		        
</P><P>	        }
</P><P>			function calculateOrderOfMagnitude(val){
			  return Math.floor(Math.log(val) / Math.LN10);
			}		
</P><P>
	}
</P><PRE>   //Populate an array of all the labels by interpolating the string.
   function populateLabels(labelTemplateString, labels, numberOfSteps, graphMin, stepValue) {
       if (labelTemplateString) {
           //Fix floating point errors by setting to fixed the on the same decimal as the stepValue.
           for (var i = 1; i &lt; numberOfSteps + 1; i++) {
               labels.push(tmpl(labelTemplateString, {value: (graphMin + (stepValue * i)).toFixed(getDecimalPlaces(stepValue))}));
           }
       }
   }
</PRE><P>	//Max value from array
	function Max( array ){
		return Math.max.apply( Math, array );
	};
	//Min value from array
	function Min( array ){
		return Math.min.apply( Math, array );
	};
	//Default if undefined
	function Default(userDeclared,valueIfFalse){
		if(!userDeclared){
			return valueIfFalse;
		} else {
			return userDeclared;
		}
	};
	//Is a number function
	function isNumber(n) {
		return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
	}
	//Apply cap a value at a high or low number
	function CapValue(valueToCap, maxValue, minValue){
		if(isNumber(maxValue)) {
			if( valueToCap &gt; maxValue ) {
				return maxValue;
			}
		}
		if(isNumber(minValue)){
			if ( valueToCap &lt; minValue ){
				return minValue;
			}
		}
		return valueToCap;
	}
	function getDecimalPlaces (num){
		var numberOfDecimalPlaces;
		if (num%1!=0){
			return num.toString().split(&quot;.&quot;)[1].length
		}
		else{
			return 0;
		}
</P><P>	} 
</P><P>	function mergeChartConfig(defaults,userDefined){
		var returnObj = {};
	    for (var attrname in defaults) { returnObj[attrname] = defaults[attrname]; }
	    for (var attrname in userDefined) { returnObj[attrname] = userDefined[attrname]; }
	    return returnObj;
	}
</P><P>	//Javascript micro templating by John Resig - source at <A href="http://ejohn.org/blog/javascript-micro-templating/" class="external free" rel="nofollow">http://ejohn.org/blog/javascript-micro-templating/</A>
	  var cache = {};
</P><P>	  function tmpl(str, data){
	    // Figure out if we're getting a template, or if we need to
	    // load the template - and be sure to cache the result.
	    var fn = !/\W/.test(str) ?
	      cache[str] = cache[str] ||
	        tmpl(document.getElementById(str).innerHTML) :
</P><P>	      // Generate a reusable function that will serve as a template
	      // generator (and which will be cached).
	      new Function(&quot;obj&quot;,
	        &quot;var p=[],print=function(){p.push.apply(p,arguments);};&quot; +
</P><P>	        // Introduce the data as local variables using with(){}
	        &quot;with(obj){p.push('&quot; +
</P><P>	        // Convert the template into pure JavaScript
	        str
	          .replace(/[\r\t\n]/g, &quot; &quot;)
	          .split(&quot;&lt;%&quot;).join(&quot;\t&quot;)
	          .replace(/((^|%&gt;)[^\t]*)'/g, &quot;$1\r&quot;)
	          .replace(/\t=(.*?)%&gt;/g, &quot;',$1,'&quot;)
	          .split(&quot;\t&quot;).join(&quot;');&quot;)
	          .split(&quot;%&gt;&quot;).join(&quot;p.push('&quot;)
	          .split(&quot;\r&quot;).join(&quot;\\'&quot;)
	      + &quot;');}return p.join(<I>);&quot;);</I></P><P>	    // Provide some basic currying to the user
	    return data ? fn( data ) : fn;
	  };
}
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2013.igem.org/Team:TU-Munich/Chart.js">http://2013.igem.org/Team:TU-Munich/Chart.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:TU-Munich/Chart.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:TU-Munich/Chart.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:TU-Munich/Chart.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:TU-Munich/Chart.js&amp;oldid=322511" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2013.igem.org:Privacy_policy" title="2013.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2013.igem.org:General_disclaimer" title="2013.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
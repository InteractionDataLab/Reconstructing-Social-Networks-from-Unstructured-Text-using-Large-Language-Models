<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_WHU-China_js_Home_bootstrap_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:WHU-China/js/Home/bootstrap.js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>(function (global, factory) {
	typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? factory(exports, require('jquery'), require('popper.js')) :
	typeof define === 'function' &amp;&amp; define.amd ? define(['exports', 'jquery', 'popper.js'], factory) :
	(factory((global.bootstrap = {}),global.jQuery,global.Popper));
}(this, (function (exports,$,Popper) { 'use strict';
</P><P>$ = $ &amp;&amp; $.hasOwnProperty('default') ? $['default'] : $;
Popper = Popper &amp;&amp; Popper.hasOwnProperty('default') ? Popper['default'] : Popper;
</P><P>function _defineProperties(target, props) {
</P><PRE> for (var i = 0; i &lt; props.length; i++) {
   var descriptor = props[i];
   descriptor.enumerable = descriptor.enumerable || false;
   descriptor.configurable = true;
   if (&quot;value&quot; in descriptor) descriptor.writable = true;
   Object.defineProperty(target, descriptor.key, descriptor);
 }
</PRE><P>}
</P><P>function _createClass(Constructor, protoProps, staticProps) {
</P><PRE> if (protoProps) _defineProperties(Constructor.prototype, protoProps);
 if (staticProps) _defineProperties(Constructor, staticProps);
 return Constructor;
</PRE><P>}
</P><P>function _extends() {
</P><PRE> _extends = Object.assign || function (target) {
   for (var i = 1; i &lt; arguments.length; i++) {
     var source = arguments[i];
</PRE><PRE>     for (var key in source) {
       if (Object.prototype.hasOwnProperty.call(source, key)) {
         target[key] = source[key];
       }
     }
   }
</PRE><PRE>   return target;
 };
</PRE><PRE> return _extends.apply(this, arguments);
</PRE><P>}
</P><P>function _inheritsLoose(subClass, superClass) {
</P><PRE> subClass.prototype = Object.create(superClass.prototype);
 subClass.prototype.constructor = subClass;
 subClass.__proto__ = superClass;
</PRE><P>}
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): util.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var Util = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Private TransitionEnd Helpers
  * ------------------------------------------------------------------------
  */
 var transition = false;
 var MAX_UID = 1000000; // Shoutout AngusCroll (<A rel="nofollow" class="external free" href="https://goo.gl/pxwQGp">https://goo.gl/pxwQGp</A>)
</PRE><PRE> function toType(obj) {
   return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
 }
</PRE><PRE> function getSpecialTransitionEndEvent() {
   return {
     bindType: transition.end,
     delegateType: transition.end,
     handle: function handle(event) {
       if ($$$1(event.target).is(this)) {
         return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
       }
</PRE><PRE>       return undefined; // eslint-disable-line no-undefined
     }
   };
 }
</PRE><PRE> function transitionEndTest() {
   if (typeof window !== 'undefined' &amp;&amp; window.QUnit) {
     return false;
   }
</PRE><PRE>   return {
     end: 'transitionend'
   };
 }
</PRE><PRE> function transitionEndEmulator(duration) {
   var _this = this;
</PRE><PRE>   var called = false;
   $$$1(this).one(Util.TRANSITION_END, function () {
     called = true;
   });
   setTimeout(function () {
     if (!called) {
       Util.triggerTransitionEnd(_this);
     }
   }, duration);
   return this;
 }
</PRE><PRE> function setTransitionEndSupport() {
   transition = transitionEndTest();
   $$$1.fn.emulateTransitionEnd = transitionEndEmulator;
</PRE><PRE>   if (Util.supportsTransitionEnd()) {
     $$$1.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
   }
 }
</PRE><PRE> function escapeId(selector) {
   // We escape IDs in case of special selectors (selector = '#myId:something')
   // $.escapeSelector does not exist in jQuery &lt; 3
   selector = typeof $$$1.escapeSelector === 'function' ? $$$1.escapeSelector(selector).substr(1) : selector.replace(/(:|\.|\[|\]|,|=|@)/g, '\\$1');
   return selector;
 }
 /**
  * --------------------------------------------------------------------------
  * Public Util Api
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Util = {
   TRANSITION_END: 'bsTransitionEnd',
   getUID: function getUID(prefix) {
     do {
       // eslint-disable-next-line no-bitwise
       prefix += ~~(Math.random() * MAX_UID); // &quot;~~&quot; acts like a faster Math.floor() here
     } while (document.getElementById(prefix));
</PRE><PRE>     return prefix;
   },
   getSelectorFromElement: function getSelectorFromElement(element) {
     var selector = element.getAttribute('data-target');
</PRE><PRE>     if (!selector || selector === '#') {
       selector = element.getAttribute('href') || <I>;</I>
     } // If it's an ID
</PRE><PRE>     if (selector.charAt(0) === '#') {
       selector = escapeId(selector);
     }
</PRE><PRE>     try {
       var $selector = $$$1(document).find(selector);
       return $selector.length &gt; 0 ? selector : null;
     } catch (err) {
       return null;
     }
   },
   reflow: function reflow(element) {
     return element.offsetHeight;
   },
   triggerTransitionEnd: function triggerTransitionEnd(element) {
     $$$1(element).trigger(transition.end);
   },
   supportsTransitionEnd: function supportsTransitionEnd() {
     return Boolean(transition);
   },
   isElement: function isElement(obj) {
     return (obj[0] || obj).nodeType;
   },
   typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
     for (var property in configTypes) {
       if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
         var expectedTypes = configTypes[property];
         var value = config[property];
         var valueType = value &amp;&amp; Util.isElement(value) ? 'element' : toType(value);
</PRE><PRE>         if (!new RegExp(expectedTypes).test(valueType)) {
           throw new Error(componentName.toUpperCase() + &quot;: &quot; + (&quot;Option \&quot;&quot; + property + &quot;\&quot; provided type \&quot;&quot; + valueType + &quot;\&quot; &quot;) + (&quot;but expected type \&quot;&quot; + expectedTypes + &quot;\&quot;.&quot;));
         }
       }
     }
   }
 };
 setTransitionEndSupport();
 return Util;
</PRE><P>}($);
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): alert.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var Alert = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Constants
  * ------------------------------------------------------------------------
  */
 var NAME = 'alert';
 var VERSION = '4.0.0';
 var DATA_KEY = 'bs.alert';
 var EVENT_KEY = &quot;.&quot; + DATA_KEY;
 var DATA_API_KEY = '.data-api';
 var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
 var TRANSITION_DURATION = 150;
 var Selector = {
   DISMISS: '[data-dismiss=&quot;alert&quot;]'
 };
 var Event = {
   CLOSE: &quot;close&quot; + EVENT_KEY,
   CLOSED: &quot;closed&quot; + EVENT_KEY,
   CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
 };
 var ClassName = {
   ALERT: 'alert',
   FADE: 'fade',
   SHOW: 'show'
   /**
    * ------------------------------------------------------------------------
    * Class Definition
    * ------------------------------------------------------------------------
    */
</PRE><PRE> };
</PRE><PRE> var Alert =
 /*#__PURE__*/
 function () {
   function Alert(element) {
     this._element = element;
   } // Getters
</PRE><PRE>   var _proto = Alert.prototype;
</PRE><PRE>   // Public
   _proto.close = function close(element) {
     element = element || this._element;
</PRE><PRE>     var rootElement = this._getRootElement(element);
</PRE><PRE>     var customEvent = this._triggerCloseEvent(rootElement);
</PRE><PRE>     if (customEvent.isDefaultPrevented()) {
       return;
     }
</PRE><PRE>     this._removeElement(rootElement);
   };
</PRE><PRE>   _proto.dispose = function dispose() {
     $$$1.removeData(this._element, DATA_KEY);
     this._element = null;
   }; // Private
</PRE><PRE>   _proto._getRootElement = function _getRootElement(element) {
     var selector = Util.getSelectorFromElement(element);
     var parent = false;
</PRE><PRE>     if (selector) {
       parent = $$$1(selector)[0];
     }
</PRE><PRE>     if (!parent) {
       parent = $$$1(element).closest(&quot;.&quot; + ClassName.ALERT)[0];
     }
</PRE><PRE>     return parent;
   };
</PRE><PRE>   _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
     var closeEvent = $$$1.Event(Event.CLOSE);
     $$$1(element).trigger(closeEvent);
     return closeEvent;
   };
</PRE><PRE>   _proto._removeElement = function _removeElement(element) {
     var _this = this;
</PRE><PRE>     $$$1(element).removeClass(ClassName.SHOW);
</PRE><PRE>     if (!Util.supportsTransitionEnd() || !$$$1(element).hasClass(ClassName.FADE)) {
       this._destroyElement(element);
</PRE><PRE>       return;
     }
</PRE><PRE>     $$$1(element).one(Util.TRANSITION_END, function (event) {
       return _this._destroyElement(element, event);
     }).emulateTransitionEnd(TRANSITION_DURATION);
   };
</PRE><PRE>   _proto._destroyElement = function _destroyElement(element) {
     $$$1(element).detach().trigger(Event.CLOSED).remove();
   }; // Static
</PRE><PRE>   Alert._jQueryInterface = function _jQueryInterface(config) {
     return this.each(function () {
       var $element = $$$1(this);
       var data = $element.data(DATA_KEY);
</PRE><PRE>       if (!data) {
         data = new Alert(this);
         $element.data(DATA_KEY, data);
       }
</PRE><PRE>       if (config === 'close') {
         data[config](this);
       }
     });
   };
</PRE><PRE>   Alert._handleDismiss = function _handleDismiss(alertInstance) {
     return function (event) {
       if (event) {
         event.preventDefault();
       }
</PRE><PRE>       alertInstance.close(this);
     };
   };
</PRE><PRE>   _createClass(Alert, null, [{
     key: &quot;VERSION&quot;,
     get: function get() {
       return VERSION;
     }
   }]);
   return Alert;
 }();
 /**
  * ------------------------------------------------------------------------
  * Data Api implementation
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
 /**
  * ------------------------------------------------------------------------
  * jQuery
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1.fn[NAME] = Alert._jQueryInterface;
 $$$1.fn[NAME].Constructor = Alert;
</PRE><PRE> $$$1.fn[NAME].noConflict = function () {
   $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
   return Alert._jQueryInterface;
 };
</PRE><PRE> return Alert;
</PRE><P>}($);
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): button.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var Button = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Constants
  * ------------------------------------------------------------------------
  */
 var NAME = 'button';
 var VERSION = '4.0.0';
 var DATA_KEY = 'bs.button';
 var EVENT_KEY = &quot;.&quot; + DATA_KEY;
 var DATA_API_KEY = '.data-api';
 var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
 var ClassName = {
   ACTIVE: 'active',
   BUTTON: 'btn',
   FOCUS: 'focus'
 };
 var Selector = {
   DATA_TOGGLE_CARROT: '[data-toggle^=&quot;button&quot;]',
   DATA_TOGGLE: '[data-toggle=&quot;buttons&quot;]',
   INPUT: 'input',
   ACTIVE: '.active',
   BUTTON: '.btn'
 };
 var Event = {
   CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
   FOCUS_BLUR_DATA_API: &quot;focus&quot; + EVENT_KEY + DATA_API_KEY + &quot; &quot; + (&quot;blur&quot; + EVENT_KEY + DATA_API_KEY)
   /**
    * ------------------------------------------------------------------------
    * Class Definition
    * ------------------------------------------------------------------------
    */
</PRE><PRE> };
</PRE><PRE> var Button =
 /*#__PURE__*/
 function () {
   function Button(element) {
     this._element = element;
   } // Getters
</PRE><PRE>   var _proto = Button.prototype;
</PRE><PRE>   // Public
   _proto.toggle = function toggle() {
     var triggerChangeEvent = true;
     var addAriaPressed = true;
     var rootElement = $$$1(this._element).closest(Selector.DATA_TOGGLE)[0];
</PRE><PRE>     if (rootElement) {
       var input = $$$1(this._element).find(Selector.INPUT)[0];
</PRE><PRE>       if (input) {
         if (input.type === 'radio') {
           if (input.checked &amp;&amp; $$$1(this._element).hasClass(ClassName.ACTIVE)) {
             triggerChangeEvent = false;
           } else {
             var activeElement = $$$1(rootElement).find(Selector.ACTIVE)[0];
</PRE><PRE>             if (activeElement) {
               $$$1(activeElement).removeClass(ClassName.ACTIVE);
             }
           }
         }
</PRE><PRE>         if (triggerChangeEvent) {
           if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
             return;
           }
</PRE><PRE>           input.checked = !$$$1(this._element).hasClass(ClassName.ACTIVE);
           $$$1(input).trigger('change');
         }
</PRE><PRE>         input.focus();
         addAriaPressed = false;
       }
     }
</PRE><PRE>     if (addAriaPressed) {
       this._element.setAttribute('aria-pressed', !$$$1(this._element).hasClass(ClassName.ACTIVE));
     }
</PRE><PRE>     if (triggerChangeEvent) {
       $$$1(this._element).toggleClass(ClassName.ACTIVE);
     }
   };
</PRE><PRE>   _proto.dispose = function dispose() {
     $$$1.removeData(this._element, DATA_KEY);
     this._element = null;
   }; // Static
</PRE><PRE>   Button._jQueryInterface = function _jQueryInterface(config) {
     return this.each(function () {
       var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>       if (!data) {
         data = new Button(this);
         $$$1(this).data(DATA_KEY, data);
       }
</PRE><PRE>       if (config === 'toggle') {
         data[config]();
       }
     });
   };
</PRE><PRE>   _createClass(Button, null, [{
     key: &quot;VERSION&quot;,
     get: function get() {
       return VERSION;
     }
   }]);
   return Button;
 }();
 /**
  * ------------------------------------------------------------------------
  * Data Api implementation
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
   event.preventDefault();
   var button = event.target;
</PRE><PRE>   if (!$$$1(button).hasClass(ClassName.BUTTON)) {
     button = $$$1(button).closest(Selector.BUTTON);
   }
</PRE><PRE>   Button._jQueryInterface.call($$$1(button), 'toggle');
 }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
   var button = $$$1(event.target).closest(Selector.BUTTON)[0];
   $$$1(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
 });
 /**
  * ------------------------------------------------------------------------
  * jQuery
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1.fn[NAME] = Button._jQueryInterface;
 $$$1.fn[NAME].Constructor = Button;
</PRE><PRE> $$$1.fn[NAME].noConflict = function () {
   $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
   return Button._jQueryInterface;
 };
</PRE><PRE> return Button;
</PRE><P>}($);
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): carousel.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var Carousel = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Constants
  * ------------------------------------------------------------------------
  */
 var NAME = 'carousel';
 var VERSION = '4.0.0';
 var DATA_KEY = 'bs.carousel';
 var EVENT_KEY = &quot;.&quot; + DATA_KEY;
 var DATA_API_KEY = '.data-api';
 var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
 var TRANSITION_DURATION = 600;
 var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key
</PRE><PRE> var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key
</PRE><PRE> var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch
</PRE><PRE> var Default = {
   interval: 5000,
   keyboard: true,
   slide: false,
   pause: 'hover',
   wrap: true
 };
 var DefaultType = {
   interval: '(number|boolean)',
   keyboard: 'boolean',
   slide: '(boolean|string)',
   pause: '(string|boolean)',
   wrap: 'boolean'
 };
 var Direction = {
   NEXT: 'next',
   PREV: 'prev',
   LEFT: 'left',
   RIGHT: 'right'
 };
 var Event = {
   SLIDE: &quot;slide&quot; + EVENT_KEY,
   SLID: &quot;slid&quot; + EVENT_KEY,
   KEYDOWN: &quot;keydown&quot; + EVENT_KEY,
   MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
   MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY,
   TOUCHEND: &quot;touchend&quot; + EVENT_KEY,
   LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY,
   CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
 };
 var ClassName = {
   CAROUSEL: 'carousel',
   ACTIVE: 'active',
   SLIDE: 'slide',
   RIGHT: 'carousel-item-right',
   LEFT: 'carousel-item-left',
   NEXT: 'carousel-item-next',
   PREV: 'carousel-item-prev',
   ITEM: 'carousel-item'
 };
 var Selector = {
   ACTIVE: '.active',
   ACTIVE_ITEM: '.active.carousel-item',
   ITEM: '.carousel-item',
   NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
   INDICATORS: '.carousel-indicators',
   DATA_SLIDE: '[data-slide], [data-slide-to]',
   DATA_RIDE: '[data-ride=&quot;carousel&quot;]'
   /**
    * ------------------------------------------------------------------------
    * Class Definition
    * ------------------------------------------------------------------------
    */
</PRE><PRE> };
</PRE><PRE> var Carousel =
 /*#__PURE__*/
 function () {
   function Carousel(element, config) {
     this._items = null;
     this._interval = null;
     this._activeElement = null;
     this._isPaused = false;
     this._isSliding = false;
     this.touchTimeout = null;
     this._config = this._getConfig(config);
     this._element = $$$1(element)[0];
     this._indicatorsElement = $$$1(this._element).find(Selector.INDICATORS)[0];
</PRE><PRE>     this._addEventListeners();
   } // Getters
</PRE><PRE>   var _proto = Carousel.prototype;
</PRE><PRE>   // Public
   _proto.next = function next() {
     if (!this._isSliding) {
       this._slide(Direction.NEXT);
     }
   };
</PRE><PRE>   _proto.nextWhenVisible = function nextWhenVisible() {
     // Don't call next when the page isn't visible
     // or the carousel or its parent isn't visible
     if (!document.hidden &amp;&amp; $$$1(this._element).is(':visible') &amp;&amp; $$$1(this._element).css('visibility') !== 'hidden') {
       this.next();
     }
   };
</PRE><PRE>   _proto.prev = function prev() {
     if (!this._isSliding) {
       this._slide(Direction.PREV);
     }
   };
</PRE><PRE>   _proto.pause = function pause(event) {
     if (!event) {
       this._isPaused = true;
     }
</PRE><PRE>     if ($$$1(this._element).find(Selector.NEXT_PREV)[0] &amp;&amp; Util.supportsTransitionEnd()) {
       Util.triggerTransitionEnd(this._element);
       this.cycle(true);
     }
</PRE><PRE>     clearInterval(this._interval);
     this._interval = null;
   };
</PRE><PRE>   _proto.cycle = function cycle(event) {
     if (!event) {
       this._isPaused = false;
     }
</PRE><PRE> if (this._interval) {
       clearInterval(this._interval);
       this._interval = null;
     }
</PRE><PRE>     if (this._config.interval &amp;&amp; !this._isPaused) {
       this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
     }
   };
</PRE><PRE>   _proto.to = function to(index) {
     var _this = this;
</PRE><PRE>     this._activeElement = $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];
</PRE><PRE>     var activeIndex = this._getItemIndex(this._activeElement);
</PRE><PRE>     if (index &gt; this._items.length - 1 || index &lt; 0) {
       return;
     }
</PRE><PRE>     if (this._isSliding) {
       $$$1(this._element).one(Event.SLID, function () {
         return _this.to(index);
       });
       return;
     }
</PRE><PRE>     if (activeIndex === index) {
       this.pause();
       this.cycle();
       return;
     }
</PRE><PRE>     var direction = index &gt; activeIndex ? Direction.NEXT : Direction.PREV;
</PRE><PRE>     this._slide(direction, this._items[index]);
   };
</PRE><PRE>   _proto.dispose = function dispose() {
     $$$1(this._element).off(EVENT_KEY);
     $$$1.removeData(this._element, DATA_KEY);
     this._items = null;
     this._config = null;
     this._element = null;
     this._interval = null;
     this._isPaused = null;
     this._isSliding = null;
     this._activeElement = null;
     this._indicatorsElement = null;
   }; // Private
</PRE><PRE>   _proto._getConfig = function _getConfig(config) {
     config = _extends({}, Default, config);
     Util.typeCheckConfig(NAME, config, DefaultType);
     return config;
   };
</PRE><PRE>   _proto._addEventListeners = function _addEventListeners() {
     var _this2 = this;
</PRE><PRE>     if (this._config.keyboard) {
       $$$1(this._element).on(Event.KEYDOWN, function (event) {
         return _this2._keydown(event);
       });
     }
</PRE><PRE>     if (this._config.pause === 'hover') {
       $$$1(this._element).on(Event.MOUSEENTER, function (event) {
         return _this2.pause(event);
       }).on(Event.MOUSELEAVE, function (event) {
         return _this2.cycle(event);
       });
</PRE><PRE>       if ('ontouchstart' in document.documentElement) {
         // If it's a touch-enabled device, mouseenter/leave are fired as
         // part of the mouse compatibility events on first tap - the carousel
         // would stop cycling until user tapped out of it;
         // here, we listen for touchend, explicitly pause the carousel
         // (as if it's the second time we tap on it, mouseenter compat event
         // is NOT fired) and after a timeout (to allow for mouse compatibility
         // events to fire) we explicitly restart cycling
         $$$1(this._element).on(Event.TOUCHEND, function () {
           _this2.pause();
</PRE><PRE>           if (_this2.touchTimeout) {
             clearTimeout(_this2.touchTimeout);
           }
</PRE><PRE>           _this2.touchTimeout = setTimeout(function (event) {
             return _this2.cycle(event);
           }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);
         });
       }
     }
   };
</PRE><PRE>   _proto._keydown = function _keydown(event) {
     if (/input|textarea/i.test(event.target.tagName)) {
       return;
     }
</PRE><PRE>     switch (event.which) {
       case ARROW_LEFT_KEYCODE:
         event.preventDefault();
         this.prev();
         break;
</PRE><PRE>       case ARROW_RIGHT_KEYCODE:
         event.preventDefault();
         this.next();
         break;
</PRE><PRE>       default:
     }
   };
</PRE><PRE>   _proto._getItemIndex = function _getItemIndex(element) {
     this._items = $$$1.makeArray($$$1(element).parent().find(Selector.ITEM));
     return this._items.indexOf(element);
   };
</PRE><PRE>   _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
     var isNextDirection = direction === Direction.NEXT;
     var isPrevDirection = direction === Direction.PREV;
</PRE><PRE>     var activeIndex = this._getItemIndex(activeElement);
</PRE><PRE>     var lastItemIndex = this._items.length - 1;
     var isGoingToWrap = isPrevDirection &amp;&amp; activeIndex === 0 || isNextDirection &amp;&amp; activeIndex === lastItemIndex;
</PRE><PRE>     if (isGoingToWrap &amp;&amp; !this._config.wrap) {
       return activeElement;
     }
</PRE><PRE>     var delta = direction === Direction.PREV ? -1 : 1;
     var itemIndex = (activeIndex + delta) % this._items.length;
     return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
   };
</PRE><PRE>   _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
     var targetIndex = this._getItemIndex(relatedTarget);
</PRE><PRE>     var fromIndex = this._getItemIndex($$$1(this._element).find(Selector.ACTIVE_ITEM)[0]);
</PRE><PRE>     var slideEvent = $$$1.Event(Event.SLIDE, {
       relatedTarget: relatedTarget,
       direction: eventDirectionName,
       from: fromIndex,
       to: targetIndex
     });
     $$$1(this._element).trigger(slideEvent);
     return slideEvent;
   };
</PRE><PRE>   _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
     if (this._indicatorsElement) {
       $$$1(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
</PRE><PRE>       var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];
</PRE><PRE>       if (nextIndicator) {
         $$$1(nextIndicator).addClass(ClassName.ACTIVE);
       }
     }
   };
</PRE><PRE>   _proto._slide = function _slide(direction, element) {
     var _this3 = this;
</PRE><PRE>     var activeElement = $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];
</PRE><PRE>     var activeElementIndex = this._getItemIndex(activeElement);
</PRE><PRE>     var nextElement = element || activeElement &amp;&amp; this._getItemByDirection(direction, activeElement);
</PRE><PRE>     var nextElementIndex = this._getItemIndex(nextElement);
</PRE><PRE>   var isCycling = Boolean(this._interval);
     var directionalClassName;
     var orderClassName;
     var eventDirectionName;
</PRE><PRE>     if (direction === Direction.NEXT) {
       directionalClassName = ClassName.LEFT;
       orderClassName = ClassName.NEXT;
       eventDirectionName = Direction.LEFT;
     } else {
       directionalClassName = ClassName.RIGHT;
       orderClassName = ClassName.PREV;
       eventDirectionName = Direction.RIGHT;
     }
</PRE><PRE>     if (nextElement &amp;&amp; $$$1(nextElement).hasClass(ClassName.ACTIVE)) {
       this._isSliding = false;
       return;
     }
</PRE><PRE>     var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
</PRE><PRE>     if (slideEvent.isDefaultPrevented()) {
       return;
     }
</PRE><PRE>     if (!activeElement || !nextElement) {
       // Some weirdness is happening, so we bail
       return;
     }
</PRE><PRE>     this._isSliding = true;
</PRE><PRE>     if (isCycling) {
       this.pause();
     }
</PRE><PRE>     this._setActiveIndicatorElement(nextElement);
</PRE><PRE>     var slidEvent = $$$1.Event(Event.SLID, {
       relatedTarget: nextElement,
       direction: eventDirectionName,
       from: activeElementIndex,
       to: nextElementIndex
     });
</PRE><PRE>     if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.SLIDE)) {
       $$$1(nextElement).addClass(orderClassName);
       Util.reflow(nextElement);
       $$$1(activeElement).addClass(directionalClassName);
       $$$1(nextElement).addClass(directionalClassName);
       $$$1(activeElement).one(Util.TRANSITION_END, function () {
         $$$1(nextElement).removeClass(directionalClassName + &quot; &quot; + orderClassName).addClass(ClassName.ACTIVE);
         $$$1(activeElement).removeClass(ClassName.ACTIVE + &quot; &quot; + orderClassName + &quot; &quot; + directionalClassName);
         _this3._isSliding = false;
         setTimeout(function () {
           return $$$1(_this3._element).trigger(slidEvent);
         }, 0);
       }).emulateTransitionEnd(TRANSITION_DURATION);
     } else {
       $$$1(activeElement).removeClass(ClassName.ACTIVE);
       $$$1(nextElement).addClass(ClassName.ACTIVE);
       this._isSliding = false;
       $$$1(this._element).trigger(slidEvent);
     }
</PRE><PRE>     if (isCycling) {
       this.cycle();
     }
   }; // Static
</PRE><PRE>   Carousel._jQueryInterface = function _jQueryInterface(config) {
     return this.each(function () {
       var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>       var _config = _extends({}, Default, $$$1(this).data());
</PRE><PRE>       if (typeof config === 'object') {
         _config = _extends({}, _config, config);
       }
</PRE><PRE>       var action = typeof config === 'string' ? config : _config.slide;
</PRE><PRE>       if (!data) {
         data = new Carousel(this, _config);
         $$$1(this).data(DATA_KEY, data);
       }
</PRE><PRE>       if (typeof config === 'number') {
         data.to(config);
       } else if (typeof action === 'string') {
         if (typeof data[action] === 'undefined') {
           throw new TypeError(&quot;No method named \&quot;&quot; + action + &quot;\&quot;&quot;);
         }
</PRE><PRE>         data[action]();
       } else if (_config.interval) {
         data.pause();
         data.cycle();
       }
     });
   };
</PRE><PRE>   Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
     var selector = Util.getSelectorFromElement(this);
</PRE><PRE>     if (!selector) {
       return;
     }
</PRE><PRE>     var target = $$$1(selector)[0];
</PRE><PRE>     if (!target || !$$$1(target).hasClass(ClassName.CAROUSEL)) {
       return;
     }
</PRE><PRE>     var config = _extends({}, $$$1(target).data(), $$$1(this).data());
     var slideIndex = this.getAttribute('data-slide-to');
</PRE><PRE>     if (slideIndex) {
       config.interval = false;
     }
</PRE><PRE>     Carousel._jQueryInterface.call($$$1(target), config);
</PRE><PRE>     if (slideIndex) {
       $$$1(target).data(DATA_KEY).to(slideIndex);
     }
</PRE><PRE>     event.preventDefault();
   };
</PRE><PRE>   _createClass(Carousel, null, [{
     key: &quot;VERSION&quot;,
     get: function get() {
       return VERSION;
     }
   }, {
     key: &quot;Default&quot;,
     get: function get() {
       return Default;
     }
   }]);
   return Carousel;
 }();
 /**
  * ------------------------------------------------------------------------
  * Data Api implementation
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);
 $$$1(window).on(Event.LOAD_DATA_API, function () {
   $$$1(Selector.DATA_RIDE).each(function () {
     var $carousel = $$$1(this);
</PRE><PRE>     Carousel._jQueryInterface.call($carousel, $carousel.data());
   });
 });
 /**
  * ------------------------------------------------------------------------
  * jQuery
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1.fn[NAME] = Carousel._jQueryInterface;
 $$$1.fn[NAME].Constructor = Carousel;
</PRE><PRE> $$$1.fn[NAME].noConflict = function () {
   $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
   return Carousel._jQueryInterface;
 };
</PRE><PRE> return Carousel;
</PRE><P>}($);
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): collapse.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var Collapse = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Constants
  * ------------------------------------------------------------------------
  */
 var NAME = 'collapse';
 var VERSION = '4.0.0';
 var DATA_KEY = 'bs.collapse';
 var EVENT_KEY = &quot;.&quot; + DATA_KEY;
 var DATA_API_KEY = '.data-api';
 var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
 var TRANSITION_DURATION = 600;
 var Default = {
   toggle: true,
   parent: 
 };
 var DefaultType = {
   toggle: 'boolean',
   parent: '(string|element)'
 };
 var Event = {
   SHOW: &quot;show&quot; + EVENT_KEY,
   SHOWN: &quot;shown&quot; + EVENT_KEY,
   HIDE: &quot;hide&quot; + EVENT_KEY,
   HIDDEN: &quot;hidden&quot; + EVENT_KEY,
   CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
 };
 var ClassName = {
   SHOW: 'show',
   COLLAPSE: 'collapse',
   COLLAPSING: 'collapsing',
   COLLAPSED: 'collapsed'
 };
 var Dimension = {
   WIDTH: 'width',
   HEIGHT: 'height'
 };
 var Selector = {
   ACTIVES: '.show, .collapsing',
   DATA_TOGGLE: '[data-toggle=&quot;collapse&quot;]'
   /**
    * ------------------------------------------------------------------------
    * Class Definition
    * ------------------------------------------------------------------------
    */
</PRE><PRE> };
</PRE><PRE> var Collapse =
 /*#__PURE__*/
 function () {
   function Collapse(element, config) {
     this._isTransitioning = false;
     this._element = element;
     this._config = this._getConfig(config);
     this._triggerArray = $$$1.makeArray($$$1(&quot;[data-toggle=\&quot;collapse\&quot;][href=\&quot;#&quot; + element.id + &quot;\&quot;],&quot; + (&quot;[data-toggle=\&quot;collapse\&quot;][data-target=\&quot;#&quot; + element.id + &quot;\&quot;]&quot;)));
     var tabToggles = $$$1(Selector.DATA_TOGGLE);
</PRE><PRE>     for (var i = 0; i &lt; tabToggles.length; i++) {
       var elem = tabToggles[i];
       var selector = Util.getSelectorFromElement(elem);
</PRE><PRE>       if (selector !== null &amp;&amp; $$$1(selector).filter(element).length &gt; 0) {
         this._selector = selector;
</PRE><PRE>         this._triggerArray.push(elem);
       }
     }
</PRE><PRE>     this._parent = this._config.parent ? this._getParent() : null;
</PRE><PRE>     if (!this._config.parent) {
       this._addAriaAndCollapsedClass(this._element, this._triggerArray);
     }
</PRE><PRE>     if (this._config.toggle) {
       this.toggle();
     }
   } // Getters
</PRE><PRE>   var _proto = Collapse.prototype;
</PRE><PRE>   // Public
   _proto.toggle = function toggle() {
     if ($$$1(this._element).hasClass(ClassName.SHOW)) {
       this.hide();
     } else {
       this.show();
     }
   };
</PRE><PRE>   _proto.show = function show() {
     var _this = this;
</PRE><PRE>     if (this._isTransitioning || $$$1(this._element).hasClass(ClassName.SHOW)) {
       return;
     }
</PRE><PRE>     var actives;
     var activesData;
</PRE><PRE>     if (this._parent) {
       actives = $$$1.makeArray($$$1(this._parent).find(Selector.ACTIVES).filter(&quot;[data-parent=\&quot;&quot; + this._config.parent + &quot;\&quot;]&quot;));
</PRE><PRE>       if (actives.length === 0) {
         actives = null;
       }
     }
</PRE><PRE>     if (actives) {
       activesData = $$$1(actives).not(this._selector).data(DATA_KEY);
</PRE><PRE>       if (activesData &amp;&amp; activesData._isTransitioning) {
         return;
       }
     }
</PRE><PRE>     var startEvent = $$$1.Event(Event.SHOW);
     $$$1(this._element).trigger(startEvent);
</PRE><PRE>     if (startEvent.isDefaultPrevented()) {
       return;
     }
</PRE><PRE>     if (actives) {
       Collapse._jQueryInterface.call($$$1(actives).not(this._selector), 'hide');
</PRE><PRE>       if (!activesData) {
         $$$1(actives).data(DATA_KEY, null);
       }
     }
</PRE><PRE>     var dimension = this._getDimension();
</PRE><PRE>     $$$1(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
     this._element.style[dimension] = 0;
</PRE><PRE>     if (this._triggerArray.length &gt; 0) {
       $$$1(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
     }
</PRE><PRE>     this.setTransitioning(true);
</PRE><PRE>     var complete = function complete() {
       $$$1(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
       _this._element.style[dimension] = <I>;</I></PRE><PRE>       _this.setTransitioning(false);
</PRE><PRE>       $$$1(_this._element).trigger(Event.SHOWN);
     };
</PRE><PRE>   if (!Util.supportsTransitionEnd()) {
       complete();
       return;
     }
</PRE><PRE>     var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
     var scrollSize = &quot;scroll&quot; + capitalizedDimension;
     $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
     this._element.style[dimension] = this._element[scrollSize] + &quot;px&quot;;
   };
</PRE><PRE>   _proto.hide = function hide() {
     var _this2 = this;
</PRE><PRE>     if (this._isTransitioning || !$$$1(this._element).hasClass(ClassName.SHOW)) {
       return;
     }
</PRE><PRE>     var startEvent = $$$1.Event(Event.HIDE);
     $$$1(this._element).trigger(startEvent);
</PRE><PRE>     if (startEvent.isDefaultPrevented()) {
       return;
     }
</PRE><PRE>     var dimension = this._getDimension();
</PRE><PRE>     this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + &quot;px&quot;;
     Util.reflow(this._element);
     $$$1(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);
</PRE><PRE>     if (this._triggerArray.length &gt; 0) {
       for (var i = 0; i &lt; this._triggerArray.length; i++) {
         var trigger = this._triggerArray[i];
         var selector = Util.getSelectorFromElement(trigger);
</PRE><PRE>         if (selector !== null) {
           var $elem = $$$1(selector);
</PRE><PRE>           if (!$elem.hasClass(ClassName.SHOW)) {
             $$$1(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
           }
         }
       }
     }
</PRE><PRE>     this.setTransitioning(true);
</PRE><PRE>     var complete = function complete() {
       _this2.setTransitioning(false);
</PRE><PRE>       $$$1(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
     };
</PRE><PRE>     this._element.style[dimension] = <I>;</I></PRE><PRE>     if (!Util.supportsTransitionEnd()) {
       complete();
       return;
     }
</PRE><PRE>  $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
   };
</PRE><PRE>   _proto.setTransitioning = function setTransitioning(isTransitioning) {
     this._isTransitioning = isTransitioning;
   };
</PRE><PRE>   _proto.dispose = function dispose() {
     $$$1.removeData(this._element, DATA_KEY);
     this._config = null;
     this._parent = null;
     this._element = null;
     this._triggerArray = null;
     this._isTransitioning = null;
   }; // Private
</PRE><PRE>   _proto._getConfig = function _getConfig(config) {
     config = _extends({}, Default, config);
     config.toggle = Boolean(config.toggle); // Coerce string values
</PRE><PRE>     Util.typeCheckConfig(NAME, config, DefaultType);
     return config;
   };
</PRE><PRE>   _proto._getDimension = function _getDimension() {
     var hasWidth = $$$1(this._element).hasClass(Dimension.WIDTH);
     return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
   };
</PRE><PRE>   _proto._getParent = function _getParent() {
     var _this3 = this;
</PRE><PRE>     var parent = null;
</PRE><PRE>     if (Util.isElement(this._config.parent)) {
       parent = this._config.parent; // It's a jQuery object
</PRE><PRE>       if (typeof this._config.parent.jquery !== 'undefined') {
         parent = this._config.parent[0];
       }
     } else {
       parent = $$$1(this._config.parent)[0];
     }
</PRE><PRE>     var selector = &quot;[data-toggle=\&quot;collapse\&quot;][data-parent=\&quot;&quot; + this._config.parent + &quot;\&quot;]&quot;;
     $$$1(parent).find(selector).each(function (i, element) {
       _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
     });
     return parent;
   };
</PRE><PRE>   _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
     if (element) {
       var isOpen = $$$1(element).hasClass(ClassName.SHOW);
</PRE><PRE>       if (triggerArray.length &gt; 0) {
         $$$1(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
       }
     }
   }; // Static
</PRE><PRE>   Collapse._getTargetFromElement = function _getTargetFromElement(element) {
     var selector = Util.getSelectorFromElement(element);
     return selector ? $$$1(selector)[0] : null;
   };
</PRE><PRE>   Collapse._jQueryInterface = function _jQueryInterface(config) {
     return this.each(function () {
       var $this = $$$1(this);
       var data = $this.data(DATA_KEY);
</PRE><PRE>       var _config = _extends({}, Default, $this.data(), typeof config === 'object' &amp;&amp; config);
</PRE><PRE>       if (!data &amp;&amp; _config.toggle &amp;&amp; /show|hide/.test(config)) {
         _config.toggle = false;
       }
</PRE><PRE>       if (!data) {
         data = new Collapse(this, _config);
         $this.data(DATA_KEY, data);
       }
</PRE><PRE>       if (typeof config === 'string') {
         if (typeof data[config] === 'undefined') {
           throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
         }
</PRE><PRE>         data[config]();
       }
     });
   };
</PRE><PRE>   _createClass(Collapse, null, [{
     key: &quot;VERSION&quot;,
     get: function get() {
       return VERSION;
     }
   }, {
     key: &quot;Default&quot;,
     get: function get() {
       return Default;
     }
   }]);
   return Collapse;
 }();
 /**
  * ------------------------------------------------------------------------
  * Data Api implementation
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
   // preventDefault only for &lt;a&gt; elements (which change the URL) not inside the collapsible element
   if (event.currentTarget.tagName === 'A') {
     event.preventDefault();
   }
</PRE><PRE>   var $trigger = $$$1(this);
   var selector = Util.getSelectorFromElement(this);
   $$$1(selector).each(function () {
     var $target = $$$1(this);
     var data = $target.data(DATA_KEY);
     var config = data ? 'toggle' : $trigger.data();
</PRE><PRE>     Collapse._jQueryInterface.call($target, config);
   });
 });
 /**
  * ------------------------------------------------------------------------
  * jQuery
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1.fn[NAME] = Collapse._jQueryInterface;
 $$$1.fn[NAME].Constructor = Collapse;
</PRE><PRE> $$$1.fn[NAME].noConflict = function () {
   $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
   return Collapse._jQueryInterface;
 };
</PRE><PRE> return Collapse;
</PRE><P>}($);
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): dropdown.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var Dropdown = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Constants
  * ------------------------------------------------------------------------
  */
 var NAME = 'dropdown';
 var VERSION = '4.0.0';
 var DATA_KEY = 'bs.dropdown';
 var EVENT_KEY = &quot;.&quot; + DATA_KEY;
 var DATA_API_KEY = '.data-api';
 var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
 var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key
</PRE><PRE> var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key
</PRE><PRE> var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key
</PRE><PRE> var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key
</PRE><PRE> var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key
</PRE><PRE> var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)
</PRE><PRE> var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + &quot;|&quot; + ARROW_DOWN_KEYCODE + &quot;|&quot; + ESCAPE_KEYCODE);
 var Event = {
   HIDE: &quot;hide&quot; + EVENT_KEY,
   HIDDEN: &quot;hidden&quot; + EVENT_KEY,
   SHOW: &quot;show&quot; + EVENT_KEY,
   SHOWN: &quot;shown&quot; + EVENT_KEY,
   CLICK: &quot;click&quot; + EVENT_KEY,
   CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
   KEYDOWN_DATA_API: &quot;keydown&quot; + EVENT_KEY + DATA_API_KEY,
   KEYUP_DATA_API: &quot;keyup&quot; + EVENT_KEY + DATA_API_KEY
 };
 var ClassName = {
   DISABLED: 'disabled',
   SHOW: 'show',
   DROPUP: 'dropup',
   DROPRIGHT: 'dropright',
   DROPLEFT: 'dropleft',
   MENURIGHT: 'dropdown-menu-right',
   MENULEFT: 'dropdown-menu-left',
   POSITION_STATIC: 'position-static'
 };
 var Selector = {
   DATA_TOGGLE: '[data-toggle=&quot;dropdown&quot;]',
   FORM_CHILD: '.dropdown form',
   MENU: '.dropdown-menu',
   NAVBAR_NAV: '.navbar-nav',
   VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled)'
 };
 var AttachmentMap = {
   TOP: 'top-start',
   TOPEND: 'top-end',
   BOTTOM: 'bottom-start',
   BOTTOMEND: 'bottom-end',
   RIGHT: 'right-start',
   RIGHTEND: 'right-end',
   LEFT: 'left-start',
   LEFTEND: 'left-end'
 };
 var Default = {
   offset: 0,
   flip: true,
   boundary: 'scrollParent'
 };
 var DefaultType = {
   offset: '(number|string|function)',
   flip: 'boolean',
   boundary: '(string|element)'
   /**
    * ------------------------------------------------------------------------
    * Class Definition
    * ------------------------------------------------------------------------
    */
</PRE><PRE> };
</PRE><PRE> var Dropdown =
 /*#__PURE__*/
 function () {
   function Dropdown(element, config) {
     this._element = element;
     this._popper = null;
     this._config = this._getConfig(config);
     this._menu = this._getMenuElement();
     this._inNavbar = this._detectNavbar();
</PRE><PRE>     this._addEventListeners();
   } // Getters
</PRE><PRE>   var _proto = Dropdown.prototype;
</PRE><PRE>   // Public
   _proto.toggle = function toggle() {
     if (this._element.disabled || $$$1(this._element).hasClass(ClassName.DISABLED)) {
       return;
     }
</PRE><PRE>     var parent = Dropdown._getParentFromElement(this._element);
</PRE><PRE>     var isActive = $$$1(this._menu).hasClass(ClassName.SHOW);
</PRE><PRE>     Dropdown._clearMenus();
</PRE><PRE>     if (isActive) {
       return;
     }
</PRE><PRE>     var relatedTarget = {
       relatedTarget: this._element
     };
     var showEvent = $$$1.Event(Event.SHOW, relatedTarget);
     $$$1(parent).trigger(showEvent);
</PRE><PRE>     if (showEvent.isDefaultPrevented()) {
       return;
     } // Disable totally Popper.js for Dropdown in Navbar
</PRE><PRE>     if (!this._inNavbar) {
       /**
        * Check for Popper dependency
        * Popper - <A rel="nofollow" class="external free" href="https://popper.js.org">https://popper.js.org</A>
        */
       if (typeof Popper === 'undefined') {
         throw new TypeError('Bootstrap dropdown require Popper.js (<A rel="nofollow" class="external free" href="https://popper.js.org)'">https://popper.js.org)'</A>);
       }
</PRE><PRE>       var element = this._element; // For dropup with alignment we use the parent as popper container
</PRE><PRE>       if ($$$1(parent).hasClass(ClassName.DROPUP)) {
         if ($$$1(this._menu).hasClass(ClassName.MENULEFT) || $$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
           element = parent;
         }
       } // If boundary is not `scrollParent`, then set position to `static`
       // to allow the menu to &quot;escape&quot; the scroll parent's boundaries
       // <A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/issues/24251">https://github.com/twbs/bootstrap/issues/24251</A></PRE><PRE>       if (this._config.boundary !== 'scrollParent') {
         $$$1(parent).addClass(ClassName.POSITION_STATIC);
       }
</PRE><PRE>       this._popper = new Popper(element, this._menu, this._getPopperConfig());
     } // If this is a touch-enabled device we add extra
     // empty mouseover listeners to the body's immediate children;
     // only needed because of broken event delegation on iOS
     // <A rel="nofollow" class="external free" href="https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html">https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html</A></PRE><PRE>     if ('ontouchstart' in document.documentElement &amp;&amp; $$$1(parent).closest(Selector.NAVBAR_NAV).length === 0) {
       $$$1('body').children().on('mouseover', null, $$$1.noop);
     }
</PRE><PRE>     this._element.focus();
</PRE><PRE>     this._element.setAttribute('aria-expanded', true);
</PRE><PRE>     $$$1(this._menu).toggleClass(ClassName.SHOW);
     $$$1(parent).toggleClass(ClassName.SHOW).trigger($$$1.Event(Event.SHOWN, relatedTarget));
   };
</PRE><PRE>   _proto.dispose = function dispose() {
     $$$1.removeData(this._element, DATA_KEY);
     $$$1(this._element).off(EVENT_KEY);
     this._element = null;
     this._menu = null;
</PRE><PRE>     if (this._popper !== null) {
       this._popper.destroy();
</PRE><PRE>       this._popper = null;
     }
   };
</PRE><PRE>   _proto.update = function update() {
     this._inNavbar = this._detectNavbar();
</PRE><PRE>     if (this._popper !== null) {
       this._popper.scheduleUpdate();
     }
   }; // Private
</PRE><PRE>   _proto._addEventListeners = function _addEventListeners() {
     var _this = this;
</PRE><PRE>     $$$1(this._element).on(Event.CLICK, function (event) {
       event.preventDefault();
       event.stopPropagation();
</PRE><PRE>       _this.toggle();
     });
   };
</PRE><PRE>   _proto._getConfig = function _getConfig(config) {
     config = _extends({}, this.constructor.Default, $$$1(this._element).data(), config);
     Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
     return config;
   };
</PRE><PRE>   _proto._getMenuElement = function _getMenuElement() {
     if (!this._menu) {
       var parent = Dropdown._getParentFromElement(this._element);
</PRE><PRE>       this._menu = $$$1(parent).find(Selector.MENU)[0];
     }
</PRE><PRE>     return this._menu;
   };
</PRE><PRE>   _proto._getPlacement = function _getPlacement() {
     var $parentDropdown = $$$1(this._element).parent();
     var placement = AttachmentMap.BOTTOM; // Handle dropup
</PRE><PRE>     if ($parentDropdown.hasClass(ClassName.DROPUP)) {
       placement = AttachmentMap.TOP;
</PRE><PRE>       if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
         placement = AttachmentMap.TOPEND;
       }
     } else if ($parentDropdown.hasClass(ClassName.DROPRIGHT)) {
       placement = AttachmentMap.RIGHT;
     } else if ($parentDropdown.hasClass(ClassName.DROPLEFT)) {
       placement = AttachmentMap.LEFT;
     } else if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
       placement = AttachmentMap.BOTTOMEND;
     }
</PRE><PRE>     return placement;
   };
</PRE><PRE>   _proto._detectNavbar = function _detectNavbar() {
     return $$$1(this._element).closest('.navbar').length &gt; 0;
   };
</PRE><PRE>   _proto._getPopperConfig = function _getPopperConfig() {
     var _this2 = this;
</PRE><PRE>     var offsetConf = {};
</PRE><PRE>     if (typeof this._config.offset === 'function') {
       offsetConf.fn = function (data) {
         data.offsets = _extends({}, data.offsets, _this2._config.offset(data.offsets) || {});
         return data;
       };
     } else {
       offsetConf.offset = this._config.offset;
     }
</PRE><PRE>     var popperConfig = {
       placement: this._getPlacement(),
       modifiers: {
         offset: offsetConf,
         flip: {
           enabled: this._config.flip
         },
         preventOverflow: {
           boundariesElement: this._config.boundary
         }
       }
     };
     return popperConfig;
   }; // Static
</PRE><PRE>   Dropdown._jQueryInterface = function _jQueryInterface(config) {
     return this.each(function () {
       var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>       var _config = typeof config === 'object' ? config : null;
</PRE><PRE>       if (!data) {
         data = new Dropdown(this, _config);
         $$$1(this).data(DATA_KEY, data);
       }
</PRE><PRE>       if (typeof config === 'string') {
         if (typeof data[config] === 'undefined') {
           throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
         }
</PRE><PRE>         data[config]();
       }
     });
   };
</PRE><PRE>   Dropdown._clearMenus = function _clearMenus(event) {
     if (event &amp;&amp; (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' &amp;&amp; event.which !== TAB_KEYCODE)) {
       return;
     }
</PRE><PRE>     var toggles = $$$1.makeArray($$$1(Selector.DATA_TOGGLE));
</PRE><PRE>     for (var i = 0; i &lt; toggles.length; i++) {
       var parent = Dropdown._getParentFromElement(toggles[i]);
</PRE><PRE>       var context = $$$1(toggles[i]).data(DATA_KEY);
       var relatedTarget = {
         relatedTarget: toggles[i]
       };
</PRE><PRE>       if (!context) {
         continue;
       }
</PRE><PRE>       var dropdownMenu = context._menu;
</PRE><PRE>       if (!$$$1(parent).hasClass(ClassName.SHOW)) {
         continue;
       }
</PRE><PRE>       if (event &amp;&amp; (event.type === 'click' &amp;&amp; /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' &amp;&amp; event.which === TAB_KEYCODE) &amp;&amp; $$$1.contains(parent, event.target)) {
         continue;
       }
</PRE><PRE>       var hideEvent = $$$1.Event(Event.HIDE, relatedTarget);
       $$$1(parent).trigger(hideEvent);
</PRE><PRE>       if (hideEvent.isDefaultPrevented()) {
         continue;
       } // If this is a touch-enabled device we remove the extra
       // empty mouseover listeners we added for iOS support
</PRE><PRE>       if ('ontouchstart' in document.documentElement) {
         $$$1('body').children().off('mouseover', null, $$$1.noop);
       }
</PRE><PRE>       toggles[i].setAttribute('aria-expanded', 'false');
       $$$1(dropdownMenu).removeClass(ClassName.SHOW);
       $$$1(parent).removeClass(ClassName.SHOW).trigger($$$1.Event(Event.HIDDEN, relatedTarget));
     }
   };
</PRE><PRE>   Dropdown._getParentFromElement = function _getParentFromElement(element) {
     var parent;
     var selector = Util.getSelectorFromElement(element);
</PRE><PRE>     if (selector) {
       parent = $$$1(selector)[0];
     }
</PRE><PRE>     return parent || element.parentNode;
   }; // eslint-disable-next-line complexity
</PRE><PRE>   Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
     // If not input/textarea:
     //  - And not a key in REGEXP_KEYDOWN =&gt; not a dropdown command
     // If input/textarea:
     //  - If space key =&gt; not a dropdown command
     //  - If key is other than escape
     //    - If key is not up or down =&gt; not a dropdown command
     //    - If trigger inside the menu =&gt; not a dropdown command
     if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE &amp;&amp; (event.which !== ARROW_DOWN_KEYCODE &amp;&amp; event.which !== ARROW_UP_KEYCODE || $$$1(event.target).closest(Selector.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
       return;
     }
</PRE><PRE>     event.preventDefault();
     event.stopPropagation();
</PRE><PRE>     if (this.disabled || $$$1(this).hasClass(ClassName.DISABLED)) {
       return;
     }
</PRE><PRE>     var parent = Dropdown._getParentFromElement(this);
</PRE><PRE>     var isActive = $$$1(parent).hasClass(ClassName.SHOW);
</PRE><PRE>     if (!isActive &amp;&amp; (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive &amp;&amp; (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
       if (event.which === ESCAPE_KEYCODE) {
         var toggle = $$$1(parent).find(Selector.DATA_TOGGLE)[0];
         $$$1(toggle).trigger('focus');
       }
</PRE><PRE>       $$$1(this).trigger('click');
       return;
     }
</PRE><PRE>     var items = $$$1(parent).find(Selector.VISIBLE_ITEMS).get();
</PRE><PRE>     if (items.length === 0) {
       return;
     }
</PRE><PRE>     var index = items.indexOf(event.target);
</PRE><PRE>     if (event.which === ARROW_UP_KEYCODE &amp;&amp; index &gt; 0) {
       // Up
       index--;
     }
</PRE><PRE>     if (event.which === ARROW_DOWN_KEYCODE &amp;&amp; index &lt; items.length - 1) {
       // Down
       index++;
     }
</PRE><PRE>     if (index &lt; 0) {
       index = 0;
     }
</PRE><PRE>     items[index].focus();
   };
</PRE><PRE>   _createClass(Dropdown, null, [{
     key: &quot;VERSION&quot;,
     get: function get() {
       return VERSION;
     }
   }, {
     key: &quot;Default&quot;,
     get: function get() {
       return Default;
     }
   }, {
     key: &quot;DefaultType&quot;,
     get: function get() {
       return DefaultType;
     }
   }]);
   return Dropdown;
 }();
 /**
  * ------------------------------------------------------------------------
  * Data Api implementation
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + &quot; &quot; + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
   event.preventDefault();
   event.stopPropagation();
</PRE><PRE>   Dropdown._jQueryInterface.call($$$1(this), 'toggle');
 }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
   e.stopPropagation();
 });
 /**
  * ------------------------------------------------------------------------
  * jQuery
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1.fn[NAME] = Dropdown._jQueryInterface;
 $$$1.fn[NAME].Constructor = Dropdown;
</PRE><PRE> $$$1.fn[NAME].noConflict = function () {
   $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
   return Dropdown._jQueryInterface;
 };
</PRE><PRE> return Dropdown;
</PRE><P>}($, Popper);
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): modal.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var Modal = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Constants
  * ------------------------------------------------------------------------
  */
 var NAME = 'modal';
 var VERSION = '4.0.0';
 var DATA_KEY = 'bs.modal';
 var EVENT_KEY = &quot;.&quot; + DATA_KEY;
 var DATA_API_KEY = '.data-api';
 var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
 var TRANSITION_DURATION = 300;
 var BACKDROP_TRANSITION_DURATION = 150;
 var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key
</PRE><PRE> var Default = {
   backdrop: true,
   keyboard: true,
   focus: true,
   show: true
 };
 var DefaultType = {
   backdrop: '(boolean|string)',
   keyboard: 'boolean',
   focus: 'boolean',
   show: 'boolean'
 };
 var Event = {
   HIDE: &quot;hide&quot; + EVENT_KEY,
   HIDDEN: &quot;hidden&quot; + EVENT_KEY,
   SHOW: &quot;show&quot; + EVENT_KEY,
   SHOWN: &quot;shown&quot; + EVENT_KEY,
   FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
   RESIZE: &quot;resize&quot; + EVENT_KEY,
   CLICK_DISMISS: &quot;click.dismiss&quot; + EVENT_KEY,
   KEYDOWN_DISMISS: &quot;keydown.dismiss&quot; + EVENT_KEY,
   MOUSEUP_DISMISS: &quot;mouseup.dismiss&quot; + EVENT_KEY,
   MOUSEDOWN_DISMISS: &quot;mousedown.dismiss&quot; + EVENT_KEY,
   CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
 };
 var ClassName = {
   SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
   BACKDROP: 'modal-backdrop',
   OPEN: 'modal-open',
   FADE: 'fade',
   SHOW: 'show'
 };
 var Selector = {
   DIALOG: '.modal-dialog',
   DATA_TOGGLE: '[data-toggle=&quot;modal&quot;]',
   DATA_DISMISS: '[data-dismiss=&quot;modal&quot;]',
   FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
   STICKY_CONTENT: '.sticky-top',
   NAVBAR_TOGGLER: '.navbar-toggler'
   /**
    * ------------------------------------------------------------------------
    * Class Definition
    * ------------------------------------------------------------------------
    */
</PRE><PRE> };
</PRE><PRE> var Modal =
 /*#__PURE__*/
 function () {
   function Modal(element, config) {
     this._config = this._getConfig(config);
     this._element = element;
     this._dialog = $$$1(element).find(Selector.DIALOG)[0];
     this._backdrop = null;
     this._isShown = false;
     this._isBodyOverflowing = false;
     this._ignoreBackdropClick = false;
     this._originalBodyPadding = 0;
     this._scrollbarWidth = 0;
   } // Getters
</PRE><PRE>   var _proto = Modal.prototype;
</PRE><PRE>   // Public
   _proto.toggle = function toggle(relatedTarget) {
     return this._isShown ? this.hide() : this.show(relatedTarget);
   };
</PRE><PRE>   _proto.show = function show(relatedTarget) {
     var _this = this;
</PRE><PRE>     if (this._isTransitioning || this._isShown) {
       return;
     }
</PRE><PRE>     if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE)) {
       this._isTransitioning = true;
     }
</PRE><PRE>     var showEvent = $$$1.Event(Event.SHOW, {
       relatedTarget: relatedTarget
     });
     $$$1(this._element).trigger(showEvent);
</PRE><PRE>     if (this._isShown || showEvent.isDefaultPrevented()) {
       return;
     }
</PRE><PRE>     this._isShown = true;
</PRE><PRE>     this._checkScrollbar();
</PRE><PRE>     this._setScrollbar();
</PRE><PRE>     this._adjustDialog();
</PRE><PRE>     $$$1(document.body).addClass(ClassName.OPEN);
</PRE><PRE>     this._setEscapeEvent();
</PRE><PRE>     this._setResizeEvent();
</PRE><PRE>     $$$1(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
       return _this.hide(event);
     });
     $$$1(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
       $$$1(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {
         if ($$$1(event.target).is(_this._element)) {
           _this._ignoreBackdropClick = true;
         }
       });
     });
</PRE><PRE>     this._showBackdrop(function () {
       return _this._showElement(relatedTarget);
     });
   };
</PRE><PRE>   _proto.hide = function hide(event) {
     var _this2 = this;
</PRE><PRE>     if (event) {
       event.preventDefault();
     }
</PRE><PRE>     if (this._isTransitioning || !this._isShown) {
       return;
     }
</PRE><PRE>     var hideEvent = $$$1.Event(Event.HIDE);
     $$$1(this._element).trigger(hideEvent);
</PRE><PRE>     if (!this._isShown || hideEvent.isDefaultPrevented()) {
       return;
     }
</PRE><PRE>     this._isShown = false;
     var transition = Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE);
</PRE><PRE>     if (transition) {
       this._isTransitioning = true;
     }
</PRE><PRE>     this._setEscapeEvent();
</PRE><PRE>     this._setResizeEvent();
</PRE><PRE>     $$$1(document).off(Event.FOCUSIN);
     $$$1(this._element).removeClass(ClassName.SHOW);
     $$$1(this._element).off(Event.CLICK_DISMISS);
     $$$1(this._dialog).off(Event.MOUSEDOWN_DISMISS);
</PRE><PRE>     if (transition) {
       $$$1(this._element).one(Util.TRANSITION_END, function (event) {
         return _this2._hideModal(event);
       }).emulateTransitionEnd(TRANSITION_DURATION);
     } else {
       this._hideModal();
     }
   };
</PRE><PRE>   _proto.dispose = function dispose() {
     $$$1.removeData(this._element, DATA_KEY);
     $$$1(window, document, this._element, this._backdrop).off(EVENT_KEY);
     this._config = null;
     this._element = null;
     this._dialog = null;
     this._backdrop = null;
     this._isShown = null;
     this._isBodyOverflowing = null;
     this._ignoreBackdropClick = null;
     this._scrollbarWidth = null;
   };
</PRE><PRE>   _proto.handleUpdate = function handleUpdate() {
     this._adjustDialog();
   }; // Private
</PRE><PRE>   _proto._getConfig = function _getConfig(config) {
     config = _extends({}, Default, config);
     Util.typeCheckConfig(NAME, config, DefaultType);
     return config;
   };
</PRE><PRE>   _proto._showElement = function _showElement(relatedTarget) {
     var _this3 = this;
</PRE><PRE>     var transition = Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE);
</PRE><PRE>     if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
       // Don't move modal's DOM position
       document.body.appendChild(this._element);
     }
</PRE><PRE>     this._element.style.display = 'block';
</PRE><PRE>     this._element.removeAttribute('aria-hidden');
</PRE><PRE>     this._element.scrollTop = 0;
</PRE><PRE>     if (transition) {
       Util.reflow(this._element);
     }
</PRE><PRE>     $$$1(this._element).addClass(ClassName.SHOW);
</PRE><PRE>     if (this._config.focus) {
       this._enforceFocus();
     }
</PRE><PRE>     var shownEvent = $$$1.Event(Event.SHOWN, {
       relatedTarget: relatedTarget
     });
</PRE><PRE>     var transitionComplete = function transitionComplete() {
       if (_this3._config.focus) {
         _this3._element.focus();
       }
</PRE><PRE>       _this3._isTransitioning = false;
       $$$1(_this3._element).trigger(shownEvent);
     };
</PRE><PRE>     if (transition) {
       $$$1(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);
     } else {
       transitionComplete();
     }
   };
</PRE><PRE>   _proto._enforceFocus = function _enforceFocus() {
     var _this4 = this;
</PRE><PRE>     $$$1(document).off(Event.FOCUSIN) // Guard against infinite focus loop
     .on(Event.FOCUSIN, function (event) {
       if (document !== event.target &amp;&amp; _this4._element !== event.target &amp;&amp; $$$1(_this4._element).has(event.target).length === 0) {
         _this4._element.focus();
       }
     });
   };
</PRE><PRE>   _proto._setEscapeEvent = function _setEscapeEvent() {
     var _this5 = this;
</PRE><PRE>     if (this._isShown &amp;&amp; this._config.keyboard) {
       $$$1(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
         if (event.which === ESCAPE_KEYCODE) {
           event.preventDefault();
</PRE><PRE>           _this5.hide();
         }
       });
     } else if (!this._isShown) {
       $$$1(this._element).off(Event.KEYDOWN_DISMISS);
     }
   };
</PRE><PRE>   _proto._setResizeEvent = function _setResizeEvent() {
     var _this6 = this;
</PRE><PRE>     if (this._isShown) {
       $$$1(window).on(Event.RESIZE, function (event) {
         return _this6.handleUpdate(event);
       });
     } else {
       $$$1(window).off(Event.RESIZE);
     }
   };
</PRE><PRE>   _proto._hideModal = function _hideModal() {
     var _this7 = this;
</PRE><PRE>     this._element.style.display = 'none';
</PRE><PRE>     this._element.setAttribute('aria-hidden', true);
</PRE><PRE>     this._isTransitioning = false;
</PRE><PRE>     this._showBackdrop(function () {
       $$$1(document.body).removeClass(ClassName.OPEN);
</PRE><PRE>       _this7._resetAdjustments();
</PRE><PRE>       _this7._resetScrollbar();
</PRE><PRE>       $$$1(_this7._element).trigger(Event.HIDDEN);
     });
   };
</PRE><PRE>   _proto._removeBackdrop = function _removeBackdrop() {
     if (this._backdrop) {
       $$$1(this._backdrop).remove();
       this._backdrop = null;
     }
   };
</PRE><PRE>   _proto._showBackdrop = function _showBackdrop(callback) {
     var _this8 = this;
</PRE><PRE>     var animate = $$$1(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : <I>;</I></PRE><PRE>     if (this._isShown &amp;&amp; this._config.backdrop) {
       var doAnimate = Util.supportsTransitionEnd() &amp;&amp; animate;
       this._backdrop = document.createElement('div');
       this._backdrop.className = ClassName.BACKDROP;
</PRE><PRE>       if (animate) {
         $$$1(this._backdrop).addClass(animate);
       }
</PRE><PRE>       $$$1(this._backdrop).appendTo(document.body);
       $$$1(this._element).on(Event.CLICK_DISMISS, function (event) {
         if (_this8._ignoreBackdropClick) {
           _this8._ignoreBackdropClick = false;
           return;
         }
</PRE><PRE>         if (event.target !== event.currentTarget) {
           return;
         }
</PRE><PRE>         if (_this8._config.backdrop === 'static') {
           _this8._element.focus();
         } else {
           _this8.hide();
         }
       });
</PRE><PRE>       if (doAnimate) {
         Util.reflow(this._backdrop);
       }
</PRE><PRE>       $$$1(this._backdrop).addClass(ClassName.SHOW);
</PRE><PRE>       if (!callback) {
         return;
       }
</PRE><PRE>       if (!doAnimate) {
         callback();
         return;
       }
</PRE><PRE>       $$$1(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
     } else if (!this._isShown &amp;&amp; this._backdrop) {
       $$$1(this._backdrop).removeClass(ClassName.SHOW);
</PRE><PRE>       var callbackRemove = function callbackRemove() {
         _this8._removeBackdrop();
</PRE><PRE>         if (callback) {
           callback();
         }
       };
</PRE><PRE>       if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this._element).hasClass(ClassName.FADE)) {
         $$$1(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
       } else {
         callbackRemove();
       }
     } else if (callback) {
       callback();
     }
   }; // ----------------------------------------------------------------------
   // the following methods are used to handle overflowing modals
   // todo (fat): these should probably be refactored out of modal.js
   // ----------------------------------------------------------------------
</PRE><PRE>   _proto._adjustDialog = function _adjustDialog() {
     var isModalOverflowing = this._element.scrollHeight &gt; document.documentElement.clientHeight;
</PRE><PRE>     if (!this._isBodyOverflowing &amp;&amp; isModalOverflowing) {
       this._element.style.paddingLeft = this._scrollbarWidth + &quot;px&quot;;
     }
</PRE><PRE>     if (this._isBodyOverflowing &amp;&amp; !isModalOverflowing) {
       this._element.style.paddingRight = this._scrollbarWidth + &quot;px&quot;;
     }
   };
</PRE><PRE>   _proto._resetAdjustments = function _resetAdjustments() {
     this._element.style.paddingLeft = <I>;</I>
     this._element.style.paddingRight = <I>;</I>
   };
</PRE><PRE>   _proto._checkScrollbar = function _checkScrollbar() {
     var rect = document.body.getBoundingClientRect();
     this._isBodyOverflowing = rect.left + rect.right &lt; window.innerWidth;
     this._scrollbarWidth = this._getScrollbarWidth();
   };
</PRE><PRE>   _proto._setScrollbar = function _setScrollbar() {
     var _this9 = this;
</PRE><PRE>     if (this._isBodyOverflowing) {
       // Note: DOMNode.style.paddingRight returns the actual value or <I> if not set</I>
       //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
       // Adjust fixed content padding
       $$$1(Selector.FIXED_CONTENT).each(function (index, element) {
         var actualPadding = $$$1(element)[0].style.paddingRight;
         var calculatedPadding = $$$1(element).css('padding-right');
         $$$1(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + &quot;px&quot;);
       }); // Adjust sticky content margin
</PRE><PRE>       $$$1(Selector.STICKY_CONTENT).each(function (index, element) {
         var actualMargin = $$$1(element)[0].style.marginRight;
         var calculatedMargin = $$$1(element).css('margin-right');
         $$$1(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + &quot;px&quot;);
       }); // Adjust navbar-toggler margin
</PRE><PRE>       $$$1(Selector.NAVBAR_TOGGLER).each(function (index, element) {
         var actualMargin = $$$1(element)[0].style.marginRight;
         var calculatedMargin = $$$1(element).css('margin-right');
         $$$1(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this9._scrollbarWidth + &quot;px&quot;);
       }); // Adjust body padding
</PRE><PRE>       var actualPadding = document.body.style.paddingRight;
       var calculatedPadding = $$$1('body').css('padding-right');
       $$$1('body').data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + &quot;px&quot;);
     }
   };
</PRE><PRE>   _proto._resetScrollbar = function _resetScrollbar() {
     // Restore fixed content padding
     $$$1(Selector.FIXED_CONTENT).each(function (index, element) {
       var padding = $$$1(element).data('padding-right');
</PRE><PRE>       if (typeof padding !== 'undefined') {
         $$$1(element).css('padding-right', padding).removeData('padding-right');
       }
     }); // Restore sticky content and navbar-toggler margin
</PRE><PRE>     $$$1(Selector.STICKY_CONTENT + &quot;, &quot; + Selector.NAVBAR_TOGGLER).each(function (index, element) {
       var margin = $$$1(element).data('margin-right');
</PRE><PRE>       if (typeof margin !== 'undefined') {
         $$$1(element).css('margin-right', margin).removeData('margin-right');
       }
     }); // Restore body padding
</PRE><PRE>     var padding = $$$1('body').data('padding-right');
</PRE><PRE>     if (typeof padding !== 'undefined') {
       $$$1('body').css('padding-right', padding).removeData('padding-right');
     }
   };
</PRE><PRE>   _proto._getScrollbarWidth = function _getScrollbarWidth() {
     // thx d.walsh
     var scrollDiv = document.createElement('div');
     scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
     document.body.appendChild(scrollDiv);
     var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
     document.body.removeChild(scrollDiv);
     return scrollbarWidth;
   }; // Static
</PRE><PRE>   Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
     return this.each(function () {
       var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>       var _config = _extends({}, Modal.Default, $$$1(this).data(), typeof config === 'object' &amp;&amp; config);
</PRE><PRE>       if (!data) {
         data = new Modal(this, _config);
         $$$1(this).data(DATA_KEY, data);
       }
</PRE><PRE>       if (typeof config === 'string') {
         if (typeof data[config] === 'undefined') {
           throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
         }
</PRE><PRE>         data[config](relatedTarget);
       } else if (_config.show) {
         data.show(relatedTarget);
       }
     });
   };
</PRE><PRE>   _createClass(Modal, null, [{
     key: &quot;VERSION&quot;,
     get: function get() {
       return VERSION;
     }
   }, {
     key: &quot;Default&quot;,
     get: function get() {
       return Default;
     }
   }]);
   return Modal;
 }();
 /**
  * ------------------------------------------------------------------------
  * Data Api implementation
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
   var _this10 = this;
</PRE><PRE>   var target;
   var selector = Util.getSelectorFromElement(this);
</PRE><PRE>   if (selector) {
     target = $$$1(selector)[0];
   }
</PRE><PRE>   var config = $$$1(target).data(DATA_KEY) ? 'toggle' : _extends({}, $$$1(target).data(), $$$1(this).data());
</PRE><PRE>   if (this.tagName === 'A' || this.tagName === 'AREA') {
     event.preventDefault();
   }
</PRE><PRE>   var $target = $$$1(target).one(Event.SHOW, function (showEvent) {
     if (showEvent.isDefaultPrevented()) {
       // Only register focus restorer if modal will actually get shown
       return;
     }
</PRE><PRE>     $target.one(Event.HIDDEN, function () {
       if ($$$1(_this10).is(':visible')) {
         _this10.focus();
       }
     });
   });
</PRE><PRE>   Modal._jQueryInterface.call($$$1(target), config, this);
 });
 /**
  * ------------------------------------------------------------------------
  * jQuery
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1.fn[NAME] = Modal._jQueryInterface;
 $$$1.fn[NAME].Constructor = Modal;
</PRE><PRE> $$$1.fn[NAME].noConflict = function () {
   $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
   return Modal._jQueryInterface;
 };
</PRE><PRE> return Modal;
</PRE><P>}($);
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): tooltip.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var Tooltip = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Constants
  * ------------------------------------------------------------------------
  */
 var NAME = 'tooltip';
 var VERSION = '4.0.0';
 var DATA_KEY = 'bs.tooltip';
 var EVENT_KEY = &quot;.&quot; + DATA_KEY;
 var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
 var TRANSITION_DURATION = 150;
 var CLASS_PREFIX = 'bs-tooltip';
 var BSCLS_PREFIX_REGEX = new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, 'g');
 var DefaultType = {
   animation: 'boolean',
   template: 'string',
   title: '(string|element|function)',
   trigger: 'string',
   delay: '(number|object)',
   html: 'boolean',
   selector: '(string|boolean)',
   placement: '(string|function)',
   offset: '(number|string)',
   container: '(string|element|boolean)',
   fallbackPlacement: '(string|array)',
   boundary: '(string|element)'
 };
 var AttachmentMap = {
   AUTO: 'auto',
   TOP: 'top',
   RIGHT: 'right',
   BOTTOM: 'bottom',
   LEFT: 'left'
 };
 var Default = {
   animation: true,
</PRE>
    template: '<DIV class="tooltip">' + '' + '</DIV>',
<PRE>   trigger: 'hover focus',
   title: <I>,</I>
   delay: 0,
   html: false,
   selector: false,
   placement: 'top',
   offset: 0,
   container: false,
   fallbackPlacement: 'flip',
   boundary: 'scrollParent'
 };
 var HoverState = {
   SHOW: 'show',
   OUT: 'out'
 };
 var Event = {
   HIDE: &quot;hide&quot; + EVENT_KEY,
   HIDDEN: &quot;hidden&quot; + EVENT_KEY,
   SHOW: &quot;show&quot; + EVENT_KEY,
   SHOWN: &quot;shown&quot; + EVENT_KEY,
   INSERTED: &quot;inserted&quot; + EVENT_KEY,
   CLICK: &quot;click&quot; + EVENT_KEY,
   FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
   FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
   MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
   MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
 };
 var ClassName = {
   FADE: 'fade',
   SHOW: 'show'
 };
 var Selector = {
   TOOLTIP: '.tooltip',
   TOOLTIP_INNER: '.tooltip-inner',
   ARROW: '.arrow'
 };
 var Trigger = {
   HOVER: 'hover',
   FOCUS: 'focus',
   CLICK: 'click',
   MANUAL: 'manual'
   /**
    * ------------------------------------------------------------------------
    * Class Definition
    * ------------------------------------------------------------------------
    */
</PRE><PRE> };
</PRE><PRE> var Tooltip =
 /*#__PURE__*/
 function () {
   function Tooltip(element, config) {
     /**
      * Check for Popper dependency
      * Popper - <A rel="nofollow" class="external free" href="https://popper.js.org">https://popper.js.org</A>
      */
     if (typeof Popper === 'undefined') {
       throw new TypeError('Bootstrap tooltips require Popper.js (<A rel="nofollow" class="external free" href="https://popper.js.org)'">https://popper.js.org)'</A>);
     } // private
</PRE><PRE>     this._isEnabled = true;
     this._timeout = 0;
     this._hoverState = <I>;</I>
     this._activeTrigger = {};
     this._popper = null; // Protected
</PRE><PRE>     this.element = element;
     this.config = this._getConfig(config);
     this.tip = null;
</PRE><PRE>     this._setListeners();
   } // Getters
</PRE><PRE>   var _proto = Tooltip.prototype;
</PRE><PRE>   // Public
   _proto.enable = function enable() {
     this._isEnabled = true;
   };
</PRE><PRE>   _proto.disable = function disable() {
     this._isEnabled = false;
   };
</PRE><PRE>   _proto.toggleEnabled = function toggleEnabled() {
     this._isEnabled = !this._isEnabled;
   };
</PRE><PRE>   _proto.toggle = function toggle(event) {
     if (!this._isEnabled) {
       return;
     }
</PRE><PRE>     if (event) {
       var dataKey = this.constructor.DATA_KEY;
       var context = $$$1(event.currentTarget).data(dataKey);
</PRE><PRE>       if (!context) {
         context = new this.constructor(event.currentTarget, this._getDelegateConfig());
         $$$1(event.currentTarget).data(dataKey, context);
       }
</PRE><PRE>       context._activeTrigger.click = !context._activeTrigger.click;
</PRE><PRE>       if (context._isWithActiveTrigger()) {
         context._enter(null, context);
       } else {
         context._leave(null, context);
       }
     } else {
       if ($$$1(this.getTipElement()).hasClass(ClassName.SHOW)) {
         this._leave(null, this);
</PRE><PRE>         return;
       }
</PRE><PRE>       this._enter(null, this);
     }
   };
</PRE><PRE>   _proto.dispose = function dispose() {
     clearTimeout(this._timeout);
     $$$1.removeData(this.element, this.constructor.DATA_KEY);
     $$$1(this.element).off(this.constructor.EVENT_KEY);
     $$$1(this.element).closest('.modal').off('hide.bs.modal');
</PRE><PRE>     if (this.tip) {
       $$$1(this.tip).remove();
     }
</PRE><PRE>     this._isEnabled = null;
     this._timeout = null;
     this._hoverState = null;
     this._activeTrigger = null;
</PRE><PRE>     if (this._popper !== null) {
       this._popper.destroy();
     }
</PRE><PRE>     this._popper = null;
     this.element = null;
     this.config = null;
     this.tip = null;
   };
</PRE><PRE>   _proto.show = function show() {
     var _this = this;
</PRE><PRE>     if ($$$1(this.element).css('display') === 'none') {
       throw new Error('Please use show on visible elements');
     }
</PRE><PRE>     var showEvent = $$$1.Event(this.constructor.Event.SHOW);
</PRE><PRE>     if (this.isWithContent() &amp;&amp; this._isEnabled) {
       $$$1(this.element).trigger(showEvent);
       var isInTheDom = $$$1.contains(this.element.ownerDocument.documentElement, this.element);
</PRE><PRE>       if (showEvent.isDefaultPrevented() || !isInTheDom) {
         return;
       }
</PRE><PRE>       var tip = this.getTipElement();
       var tipId = Util.getUID(this.constructor.NAME);
       tip.setAttribute('id', tipId);
       this.element.setAttribute('aria-describedby', tipId);
       this.setContent();
</PRE><PRE>       if (this.config.animation) {
         $$$1(tip).addClass(ClassName.FADE);
       }
</PRE><PRE>       var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;
</PRE><PRE>       var attachment = this._getAttachment(placement);
</PRE><PRE>       this.addAttachmentClass(attachment);
       var container = this.config.container === false ? document.body : $$$1(this.config.container);
       $$$1(tip).data(this.constructor.DATA_KEY, this);
</PRE><PRE>       if (!$$$1.contains(this.element.ownerDocument.documentElement, this.tip)) {
         $$$1(tip).appendTo(container);
       }
</PRE><PRE>       $$$1(this.element).trigger(this.constructor.Event.INSERTED);
       this._popper = new Popper(this.element, tip, {
         placement: attachment,
         modifiers: {
           offset: {
             offset: this.config.offset
           },
           flip: {
             behavior: this.config.fallbackPlacement
           },
           arrow: {
             element: Selector.ARROW
           },
           preventOverflow: {
             boundariesElement: this.config.boundary
           }
         },
         onCreate: function onCreate(data) {
           if (data.originalPlacement !== data.placement) {
             _this._handlePopperPlacementChange(data);
           }
         },
         onUpdate: function onUpdate(data) {
           _this._handlePopperPlacementChange(data);
         }
       });
       $$$1(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra
       // empty mouseover listeners to the body's immediate children;
       // only needed because of broken event delegation on iOS
       // <A rel="nofollow" class="external free" href="https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html">https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html</A></PRE><PRE>       if ('ontouchstart' in document.documentElement) {
         $$$1('body').children().on('mouseover', null, $$$1.noop);
       }
</PRE><PRE>       var complete = function complete() {
         if (_this.config.animation) {
           _this._fixTransition();
         }
</PRE><PRE>         var prevHoverState = _this._hoverState;
         _this._hoverState = null;
         $$$1(_this.element).trigger(_this.constructor.Event.SHOWN);
</PRE><PRE>         if (prevHoverState === HoverState.OUT) {
           _this._leave(null, _this);
         }
       };
</PRE><PRE>       if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this.tip).hasClass(ClassName.FADE)) {
         $$$1(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
       } else {
         complete();
       }
     }
   };
</PRE><PRE>   _proto.hide = function hide(callback) {
     var _this2 = this;
</PRE><PRE>     var tip = this.getTipElement();
     var hideEvent = $$$1.Event(this.constructor.Event.HIDE);
</PRE><PRE>     var complete = function complete() {
       if (_this2._hoverState !== HoverState.SHOW &amp;&amp; tip.parentNode) {
         tip.parentNode.removeChild(tip);
       }
</PRE><PRE>       _this2._cleanTipClass();
</PRE><PRE>       _this2.element.removeAttribute('aria-describedby');
</PRE><PRE>       $$$1(_this2.element).trigger(_this2.constructor.Event.HIDDEN);
</PRE><PRE>       if (_this2._popper !== null) {
         _this2._popper.destroy();
       }
</PRE><PRE>       if (callback) {
         callback();
       }
     };
</PRE><PRE>     $$$1(this.element).trigger(hideEvent);
</PRE><PRE>     if (hideEvent.isDefaultPrevented()) {
       return;
     }
</PRE><PRE>     $$$1(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra
     // empty mouseover listeners we added for iOS support
</PRE><PRE>     if ('ontouchstart' in document.documentElement) {
       $$$1('body').children().off('mouseover', null, $$$1.noop);
     }
</PRE><PRE>     this._activeTrigger[Trigger.CLICK] = false;
     this._activeTrigger[Trigger.FOCUS] = false;
     this._activeTrigger[Trigger.HOVER] = false;
</PRE><PRE>     if (Util.supportsTransitionEnd() &amp;&amp; $$$1(this.tip).hasClass(ClassName.FADE)) {
       $$$1(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
     } else {
       complete();
     }
</PRE><PRE>     this._hoverState = <I>;</I>
   };
</PRE><PRE>   _proto.update = function update() {
     if (this._popper !== null) {
       this._popper.scheduleUpdate();
     }
   }; // Protected
</PRE><PRE>   _proto.isWithContent = function isWithContent() {
     return Boolean(this.getTitle());
   };
</PRE><PRE>   _proto.addAttachmentClass = function addAttachmentClass(attachment) {
     $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
   };
</PRE><PRE>   _proto.getTipElement = function getTipElement() {
     this.tip = this.tip || $$$1(this.config.template)[0];
     return this.tip;
   };
</PRE><PRE>   _proto.setContent = function setContent() {
     var $tip = $$$1(this.getTipElement());
     this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
     $tip.removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
   };
</PRE><PRE>   _proto.setElementContent = function setElementContent($element, content) {
     var html = this.config.html;
</PRE><PRE>     if (typeof content === 'object' &amp;&amp; (content.nodeType || content.jquery)) {
       // Content is a DOM node or a jQuery
       if (html) {
         if (!$$$1(content).parent().is($element)) {
           $element.empty().append(content);
         }
       } else {
         $element.text($$$1(content).text());
       }
     } else {
       $element[html ? 'html' : 'text'](content);
     }
   };
</PRE><PRE>   _proto.getTitle = function getTitle() {
     var title = this.element.getAttribute('data-original-title');
</PRE><PRE>     if (!title) {
       title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
     }
</PRE><PRE>     return title;
   }; // Private
</PRE><PRE>   _proto._getAttachment = function _getAttachment(placement) {
     return AttachmentMap[placement.toUpperCase()];
   };
</PRE><PRE>   _proto._setListeners = function _setListeners() {
     var _this3 = this;
</PRE><PRE>     var triggers = this.config.trigger.split(' ');
     triggers.forEach(function (trigger) {
       if (trigger === 'click') {
         $$$1(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
           return _this3.toggle(event);
         });
       } else if (trigger !== Trigger.MANUAL) {
         var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
         var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
         $$$1(_this3.element).on(eventIn, _this3.config.selector, function (event) {
           return _this3._enter(event);
         }).on(eventOut, _this3.config.selector, function (event) {
           return _this3._leave(event);
         });
       }
</PRE><PRE>       $$$1(_this3.element).closest('.modal').on('hide.bs.modal', function () {
         return _this3.hide();
       });
     });
</PRE><PRE>     if (this.config.selector) {
       this.config = _extends({}, this.config, {
         trigger: 'manual',
         selector: 
       });
     } else {
       this._fixTitle();
     }
   };
</PRE><PRE>   _proto._fixTitle = function _fixTitle() {
     var titleType = typeof this.element.getAttribute('data-original-title');
</PRE><PRE>     if (this.element.getAttribute('title') || titleType !== 'string') {
       this.element.setAttribute('data-original-title', this.element.getAttribute('title') || <I>);</I>
       this.element.setAttribute('title', <I>);</I>
     }
   };
</PRE><PRE>   _proto._enter = function _enter(event, context) {
     var dataKey = this.constructor.DATA_KEY;
     context = context || $$$1(event.currentTarget).data(dataKey);
</PRE><PRE>     if (!context) {
       context = new this.constructor(event.currentTarget, this._getDelegateConfig());
       $$$1(event.currentTarget).data(dataKey, context);
     }
</PRE><PRE>     if (event) {
       context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
     }
</PRE><PRE>     if ($$$1(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
       context._hoverState = HoverState.SHOW;
       return;
     }
</PRE><PRE>     clearTimeout(context._timeout);
     context._hoverState = HoverState.SHOW;
</PRE><PRE>     if (!context.config.delay || !context.config.delay.show) {
       context.show();
       return;
     }
</PRE><PRE>     context._timeout = setTimeout(function () {
       if (context._hoverState === HoverState.SHOW) {
         context.show();
       }
     }, context.config.delay.show);
   };
</PRE><PRE>   _proto._leave = function _leave(event, context) {
     var dataKey = this.constructor.DATA_KEY;
     context = context || $$$1(event.currentTarget).data(dataKey);
</PRE><PRE>     if (!context) {
       context = new this.constructor(event.currentTarget, this._getDelegateConfig());
       $$$1(event.currentTarget).data(dataKey, context);
     }
</PRE><PRE>     if (event) {
       context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
     }
</PRE><PRE>     if (context._isWithActiveTrigger()) {
       return;
     }
</PRE><PRE>     clearTimeout(context._timeout);
     context._hoverState = HoverState.OUT;
</PRE><PRE>     if (!context.config.delay || !context.config.delay.hide) {
       context.hide();
       return;
     }
</PRE><PRE>     context._timeout = setTimeout(function () {
       if (context._hoverState === HoverState.OUT) {
         context.hide();
       }
     }, context.config.delay.hide);
   };
</PRE><PRE>   _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
     for (var trigger in this._activeTrigger) {
       if (this._activeTrigger[trigger]) {
         return true;
       }
     }
</PRE><PRE>     return false;
   };
</PRE><PRE>   _proto._getConfig = function _getConfig(config) {
     config = _extends({}, this.constructor.Default, $$$1(this.element).data(), config);
</PRE><PRE>     if (typeof config.delay === 'number') {
       config.delay = {
         show: config.delay,
         hide: config.delay
       };
     }
</PRE><PRE>     if (typeof config.title === 'number') {
       config.title = config.title.toString();
     }
</PRE><PRE>     if (typeof config.content === 'number') {
       config.content = config.content.toString();
     }
</PRE><PRE>     Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
     return config;
   };
</PRE><PRE>   _proto._getDelegateConfig = function _getDelegateConfig() {
     var config = {};
</PRE><PRE>     if (this.config) {
       for (var key in this.config) {
         if (this.constructor.Default[key] !== this.config[key]) {
           config[key] = this.config[key];
         }
       }
     }
</PRE><PRE>     return config;
   };
</PRE><PRE>   _proto._cleanTipClass = function _cleanTipClass() {
     var $tip = $$$1(this.getTipElement());
     var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
</PRE><PRE>     if (tabClass !== null &amp;&amp; tabClass.length &gt; 0) {
       $tip.removeClass(tabClass.join(<I>));</I>
     }
   };
</PRE><PRE>   _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {
     this._cleanTipClass();
</PRE><PRE>     this.addAttachmentClass(this._getAttachment(data.placement));
   };
</PRE><PRE>   _proto._fixTransition = function _fixTransition() {
     var tip = this.getTipElement();
     var initConfigAnimation = this.config.animation;
</PRE><PRE>     if (tip.getAttribute('x-placement') !== null) {
       return;
     }
</PRE><PRE>     $$$1(tip).removeClass(ClassName.FADE);
     this.config.animation = false;
     this.hide();
     this.show();
     this.config.animation = initConfigAnimation;
   }; // Static
</PRE><PRE>   Tooltip._jQueryInterface = function _jQueryInterface(config) {
     return this.each(function () {
       var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>       var _config = typeof config === 'object' &amp;&amp; config;
</PRE><PRE>       if (!data &amp;&amp; /dispose|hide/.test(config)) {
         return;
       }
</PRE><PRE>       if (!data) {
         data = new Tooltip(this, _config);
         $$$1(this).data(DATA_KEY, data);
       }
</PRE><PRE>       if (typeof config === 'string') {
         if (typeof data[config] === 'undefined') {
           throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
         }
</PRE><PRE>         data[config]();
       }
     });
   };
</PRE><PRE>   _createClass(Tooltip, null, [{
     key: &quot;VERSION&quot;,
     get: function get() {
       return VERSION;
     }
   }, {
     key: &quot;Default&quot;,
     get: function get() {
       return Default;
     }
   }, {
     key: &quot;NAME&quot;,
     get: function get() {
       return NAME;
     }
   }, {
     key: &quot;DATA_KEY&quot;,
     get: function get() {
       return DATA_KEY;
     }
   }, {
     key: &quot;Event&quot;,
     get: function get() {
       return Event;
     }
   }, {
     key: &quot;EVENT_KEY&quot;,
     get: function get() {
       return EVENT_KEY;
     }
   }, {
     key: &quot;DefaultType&quot;,
     get: function get() {
       return DefaultType;
     }
   }]);
   return Tooltip;
 }();
 /**
  * ------------------------------------------------------------------------
  * jQuery
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1.fn[NAME] = Tooltip._jQueryInterface;
 $$$1.fn[NAME].Constructor = Tooltip;
</PRE><PRE> $$$1.fn[NAME].noConflict = function () {
   $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
   return Tooltip._jQueryInterface;
 };
</PRE><PRE> return Tooltip;
</PRE><P>}($, Popper);
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): popover.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var Popover = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Constants
  * ------------------------------------------------------------------------
  */
 var NAME = 'popover';
 var VERSION = '4.0.0';
 var DATA_KEY = 'bs.popover';
 var EVENT_KEY = &quot;.&quot; + DATA_KEY;
 var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
 var CLASS_PREFIX = 'bs-popover';
 var BSCLS_PREFIX_REGEX = new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, 'g');
 var Default = _extends({}, Tooltip.Default, {
   placement: 'right',
   trigger: 'click',
   content: <I>,</I></PRE>
    template: '<DIV class="popover">' + '' + '' + '</DIV>'
<PRE> });
 var DefaultType = _extends({}, Tooltip.DefaultType, {
   content: '(string|element|function)'
 });
 var ClassName = {
   FADE: 'fade',
   SHOW: 'show'
 };
 var Selector = {
   TITLE: '.popover-header',
   CONTENT: '.popover-body'
 };
 var Event = {
   HIDE: &quot;hide&quot; + EVENT_KEY,
   HIDDEN: &quot;hidden&quot; + EVENT_KEY,
   SHOW: &quot;show&quot; + EVENT_KEY,
   SHOWN: &quot;shown&quot; + EVENT_KEY,
   INSERTED: &quot;inserted&quot; + EVENT_KEY,
   CLICK: &quot;click&quot; + EVENT_KEY,
   FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
   FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
   MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
   MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
   /**
    * ------------------------------------------------------------------------
    * Class Definition
    * ------------------------------------------------------------------------
    */
</PRE><PRE> };
</PRE><PRE> var Popover =
 /*#__PURE__*/
 function (_Tooltip) {
   _inheritsLoose(Popover, _Tooltip);
</PRE><PRE>   function Popover() {
     return _Tooltip.apply(this, arguments) || this;
   }
</PRE><PRE>   var _proto = Popover.prototype;
</PRE><PRE>   // Overrides
   _proto.isWithContent = function isWithContent() {
     return this.getTitle() || this._getContent();
   };
</PRE><PRE>   _proto.addAttachmentClass = function addAttachmentClass(attachment) {
     $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
   };
</PRE><PRE>   _proto.getTipElement = function getTipElement() {
     this.tip = this.tip || $$$1(this.config.template)[0];
     return this.tip;
   };
</PRE><PRE>   _proto.setContent = function setContent() {
     var $tip = $$$1(this.getTipElement()); // We use append for html objects to maintain js events
</PRE><PRE>     this.setElementContent($tip.find(Selector.TITLE), this.getTitle());
</PRE><PRE>     var content = this._getContent();
</PRE><PRE>     if (typeof content === 'function') {
       content = content.call(this.element);
     }
</PRE><PRE>     this.setElementContent($tip.find(Selector.CONTENT), content);
     $tip.removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
   }; // Private
</PRE><PRE>   _proto._getContent = function _getContent() {
     return this.element.getAttribute('data-content') || this.config.content;
   };
</PRE><PRE>   _proto._cleanTipClass = function _cleanTipClass() {
     var $tip = $$$1(this.getTipElement());
     var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
</PRE><PRE>     if (tabClass !== null &amp;&amp; tabClass.length &gt; 0) {
       $tip.removeClass(tabClass.join(<I>));</I>
     }
   }; // Static
</PRE><PRE>   Popover._jQueryInterface = function _jQueryInterface(config) {
     return this.each(function () {
       var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>       var _config = typeof config === 'object' ? config : null;
</PRE><PRE>       if (!data &amp;&amp; /destroy|hide/.test(config)) {
         return;
       }
</PRE><PRE>       if (!data) {
         data = new Popover(this, _config);
         $$$1(this).data(DATA_KEY, data);
       }
</PRE><PRE>       if (typeof config === 'string') {
         if (typeof data[config] === 'undefined') {
           throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
         }
</PRE><PRE>         data[config]();
       }
     });
   };
</PRE><PRE>   _createClass(Popover, null, [{
     key: &quot;VERSION&quot;,
     // Getters
     get: function get() {
       return VERSION;
     }
   }, {
     key: &quot;Default&quot;,
     get: function get() {
       return Default;
     }
   }, {
     key: &quot;NAME&quot;,
     get: function get() {
       return NAME;
     }
   }, {
     key: &quot;DATA_KEY&quot;,
     get: function get() {
       return DATA_KEY;
     }
   }, {
     key: &quot;Event&quot;,
     get: function get() {
       return Event;
     }
   }, {
     key: &quot;EVENT_KEY&quot;,
     get: function get() {
       return EVENT_KEY;
     }
   }, {
     key: &quot;DefaultType&quot;,
     get: function get() {
       return DefaultType;
     }
   }]);
   return Popover;
 }(Tooltip);
 /**
  * ------------------------------------------------------------------------
  * jQuery
  * ------------------------------------------------------------------------
  */
</PRE><PRE> $$$1.fn[NAME] = Popover._jQueryInterface;
 $$$1.fn[NAME].Constructor = Popover;
</PRE><PRE> $$$1.fn[NAME].noConflict = function () {
   $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
   return Popover._jQueryInterface;
 };
</PRE><PRE> return Popover;
</PRE><P>}($);
</P><P>/**
</P><PRE>* --------------------------------------------------------------------------
* Bootstrap (v4.0.0): scrollspy.js
* Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
* --------------------------------------------------------------------------
*/
</PRE><P>var ScrollSpy = function ($$$1) {
</P><PRE> /**
  * ------------------------------------------------------------------------
  * Constants
  * ------------------------------------------------------------------------
  */
 var NAME = 'scrollspy';
 var VERSION = '4.0.0';
 var DATA_KEY = 'bs.scrollspy';
 var EVENT_KEY = &quot;.&quot; + DATA_KEY;
 var DATA_API_KEY = '.data-api';
 var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
 var Default = {
   offset: 10,
   method: 'auto',
   target: 
 };
 var DefaultType = {
   offset: 'number',
   method: 'string',
   target: '(string|element)'
 };
 var Event = {
   ACTIVATE: &quot;activate&quot; + EVENT_KEY,
   SCROLL: &quot;scroll&quot; + EVENT_KEY,
   LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY
 };
 var ClassName = {
   DROPDOWN_ITEM: 'dropdown-item',
   DROPDOWN_MENU: 'dropdown-menu',
   ACTIVE: 'active'
 };
 var Selector = {
   DATA_SPY: '[data-spy=&quot;scroll&quot;]',
   ACTIVE: '.active',
   NAV_LIST_GROUP: '.nav, .list-group',
   NAV_LINKS: '.nav-link',
   NAV_ITEMS: '.nav-item',
   LIST_ITEMS: '.list-group-item',
   DROPDOWN: '.dropdown',
   DROPDOWN_ITEMS: '.dropdown-item',
   DROPDOWN_TOGGLE: '.dropdown-toggle'
 };
 var OffsetMethod = {
   OFFSET: 'offset',
   POSITION: 'position'
   /**
    * ------------------------------------------------------------------------
    * Class Definition
    * ------------------------------------------------------------------------
    */
</PRE><PRE> };
</PRE><PRE> var ScrollSpy =
 /*#__PURE__*/
 function () {
   function ScrollSpy(element, config) {
     var _this = this;
</PRE><PRE>     this._element = element;
     this._scrollElement = element.tagName === 'BODY' ? window : element;
     this._config = this._getConfig(config);
     this._selector = this._config.target + &quot; &quot; + Selector.NAV_LINKS + &quot;,&quot; + (this._config.target + &quot; &quot; + Selector.LIST_ITEMS + &quot;,&quot;) + (this._config.target + &quot; &quot; + Selector.DROPDOWN_ITEMS);
     this._offsets = [];
     this._targets = [];
     this._activeTarget = null;
     this._scrollHeight = 0;
     $$$1(this._scrollElement).on(Event.SCROLL, function (event) {
       return _this._process(event);
     });
     this.refresh();
</PRE><PRE>     this._process();
   } // Getters
</PRE><PRE>   var _proto = ScrollSpy.prototype;
</PRE><PRE>   // Public
   _proto.refresh = function refresh() {
     var _this2 = this;
</PRE><PRE>     var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
     var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
     var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
     this._offsets = [];
     this._targets = [];
     this._scrollHeight = this._getScrollHeight();
     var targets = $$$1.makeArray($$$1(this._selector));
     targets.map(function (element) {
       var target;
       var targetSelector = Util.getSelectorFromElement(element);
</PRE><PRE>       if (targetSelector) {
         target = $$$1(targetSelector)[0];
       }
</PRE><PRE>       if (target) {
         var targetBCR = target.getBoundingClientRect();
</PRE><PRE>         if (targetBCR.width || targetBCR.height) {
           // TODO (fat): remove sketch reliance on jQuery position/offset
           return [$$$1(target)[offsetMethod]().top + offsetBase, targetSelector];
         }
       }
</PRE><PRE>       return null;
     }).filter(function (item) {
       return item;
     }).sort(function (a, b) {
       return a[0] - b[0];
     }).forEach(function (item) {
       _this2._offsets.push(item[0]);
</PRE><PRE>       _this2._targets.push(item[1]);
     });
   };
</PRE><PRE>   _proto.dispose = function dispose() {
     $$$1.removeData(this._element, DATA_KEY);
     $$$1(this._scrollElement).off(EVENT_KEY);
     this._element = null;
     this._scrollElement = null;
     this._config = null;
     this._selector = null;
     this._offsets = null;
     this._targets = null;
     this._activeTarget = null;
     this._scrollHeight = null;
   }; // Private
</PRE><PRE>   _proto._getConfig = function _getConfig(config) {
     config = _extends({}, Default, config);
</PRE><PRE>     if (typeof config.target !== 'string') {
       var id = $$$1(config.target).attr('id');
</PRE><PRE>       if (!id) {
         id = Util.getUID(NAME);
         $$$1(config.target).attr('id', id);
       }
</PRE><PRE>       config.target = &quot;#&quot; + id;
     }
</PRE><PRE>     Util.typeCheckConfig(NAME, config, DefaultType);
     return config;
   };
</PRE><PRE>   _proto._getScrollTop = function _getScrollTop() {
     return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
   };
</PRE><PRE>   _proto._getScrollHeight = function _getScrollHeight() {
     return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
   };
</PRE><PRE>   _proto._getOffsetHeight = function _getOffsetHeight() {
     return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
   };
</PRE><PRE>   _proto._process = function _process() {
     var scrollTop = this._getScrollTop() + this._config.offset;
</PRE><PRE>     var scrollHeight = this._getScrollHeight();
</PRE><PRE>     var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
</PRE><PRE>     if (this._scrollHeight !== scrollHeight) {
       this.refresh();
     }
</PRE><PRE>     if (scrollTop &gt;= maxScroll) {
       var target = this._targets[this._targets.length - 1];
</PRE><PRE>       if (this._activeTarget !== target) {
         this._activate(target);
       }
</PRE><PRE>       return;
     }
</PRE><PRE>     if (this._activeTarget &amp;&amp; scrollTop &lt; this._offsets[0] &amp;&amp; this._offsets[0] &gt; 0) {
       this._activeTarget = null;
</PRE><PRE>       this._clear();
</PRE><PRE>       return;
     }
</PRE><PRE>     for (var i = this._offsets.length; i--;) {
       var isActiveTarget = this._activeTarget !== this._targets[i] &amp;&amp; scrollTop &gt;= this._offsets[i] &amp;&amp; (typeof this._offsets[i + 1] === 'undefined' || scrollTop &lt; this._offsets[i + 1]);
</PRE><PRE>       if (isActiveTarget) {
         this._activate(this._targets[i]);
       }
     }
   };
</PRE><PRE>   _proto._activate = function _activate(target) {
     this._activeTarget = target;
</PRE><PRE>     this._clear();
</PRE><PRE>     var queries = this._selector.split(','); // eslint-disable-next-line arrow-body-style
</PRE><PRE>     queries = queries.map(function (selector) {
       return selector + &quot;[data-target=\&quot;&quot; + target + &quot;\&quot;],&quot; + (selector + &quot;[href=\&quot;&quot; + target + &quot;\&quot;]&quot;);
     });
     var $link = $$$1(queries.join(','));
</PRE><PRE>     if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
       $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
       $link.addClass(ClassName.ACTIVE);
     } else {
       // Set triggered link as active
       $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active
</PRE>
        // With both <UL> and &lt;nav&gt; markup a parent is the previous sibling of any nav ancestor

        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + &quot;, &quot; + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item

        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
      }

      $$$1(this._scrollElement).trigger(Event.ACTIVATE, {
        relatedTarget: target
      });
    };

    _proto._clear = function _clear() {
      $$$1(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
    }; // Static


    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $$$1(this).data(DATA_KEY);

        var _config = typeof config === 'object' &amp;&amp; config;

        if (!data) {
          data = new ScrollSpy(this, _config);
          $$$1(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
          }

          data[config]();
        }
      });
    };

    _createClass(ScrollSpy, null, [{
      key: &quot;VERSION&quot;,
      get: function get() {
        return VERSION;
      }
    }, {
      key: &quot;Default&quot;,
      get: function get() {
        return Default;
      }
    }]);
    return ScrollSpy;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $$$1(window).on(Event.LOAD_DATA_API, function () {
    var scrollSpys = $$$1.makeArray($$$1(Selector.DATA_SPY));

    for (var i = scrollSpys.length; i--;) {
      var $spy = $$$1(scrollSpys[i]);

      ScrollSpy._jQueryInterface.call($spy, $spy.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $$$1.fn[NAME] = ScrollSpy._jQueryInterface;
  $$$1.fn[NAME].Constructor = ScrollSpy;

  $$$1.fn[NAME].noConflict = function () {
    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
    return ScrollSpy._jQueryInterface;
  };

  return ScrollSpy;
}($);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0): tab.js
 * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
 * --------------------------------------------------------------------------
 */

var Tab = function ($$$1) {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'tab';
  var VERSION = '4.0.0';
  var DATA_KEY = 'bs.tab';
  var EVENT_KEY = &quot;.&quot; + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
  var TRANSITION_DURATION = 150;
  var Event = {
    HIDE: &quot;hide&quot; + EVENT_KEY,
    HIDDEN: &quot;hidden&quot; + EVENT_KEY,
    SHOW: &quot;show&quot; + EVENT_KEY,
    SHOWN: &quot;shown&quot; + EVENT_KEY,
    CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active',
    DISABLED: 'disabled',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector = {
    DROPDOWN: '.dropdown',
    NAV_LIST_GROUP: '.nav, .list-group',
    ACTIVE: '.active',
    ACTIVE_UL: '&gt; li &gt; .active',
    DATA_TOGGLE: '[data-toggle=&quot;tab&quot;], [data-toggle=&quot;pill&quot;], [data-toggle=&quot;list&quot;]',
    DROPDOWN_TOGGLE: '.dropdown-toggle',
    DROPDOWN_ACTIVE_CHILD: '&gt; .dropdown-menu .active'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(element) {
      this._element = element;
    } // Getters


    var _proto = Tab.prototype;

    // Public
    _proto.show = function show() {
      var _this = this;

      if (this._element.parentNode &amp;&amp; this._element.parentNode.nodeType === Node.ELEMENT_NODE &amp;&amp; $$$1(this._element).hasClass(ClassName.ACTIVE) || $$$1(this._element).hasClass(ClassName.DISABLED)) {
        return;
      }

      var target;
      var previous;
      var listElement = $$$1(this._element).closest(Selector.NAV_LIST_GROUP)[0];
      var selector = Util.getSelectorFromElement(this._element);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;
        previous = $$$1.makeArray($$$1(listElement).find(itemSelector));
        previous = previous[previous.length - 1];
      }

      var hideEvent = $$$1.Event(Event.HIDE, {
        relatedTarget: this._element
      });
      var showEvent = $$$1.Event(Event.SHOW, {
        relatedTarget: previous
      });

      if (previous) {
        $$$1(previous).trigger(hideEvent);
      }

      $$$1(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
        return;
      }

      if (selector) {
        target = $$$1(selector)[0];
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        var hiddenEvent = $$$1.Event(Event.HIDDEN, {
          relatedTarget: _this._element
        });
        var shownEvent = $$$1.Event(Event.SHOWN, {
          relatedTarget: previous
        });
        $$$1(previous).trigger(hiddenEvent);
        $$$1(_this._element).trigger(shownEvent);
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    };

    _proto.dispose = function dispose() {
      $$$1.removeData(this._element, DATA_KEY);
      this._element = null;
    }; // Private


    _proto._activate = function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements;

      if (container.nodeName === 'UL') {
        activeElements = $$$1(container).find(Selector.ACTIVE_UL);
      } else {
        activeElements = $$$1(container).children(Selector.ACTIVE);
      }

      var active = activeElements[0];
      var isTransitioning = callback &amp;&amp; Util.supportsTransitionEnd() &amp;&amp; active &amp;&amp; $$$1(active).hasClass(ClassName.FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, callback);
      };

      if (active &amp;&amp; isTransitioning) {
        $$$1(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        complete();
      }
    };

    _proto._transitionComplete = function _transitionComplete(element, active, callback) {
      if (active) {
        $$$1(active).removeClass(ClassName.SHOW + &quot; &quot; + ClassName.ACTIVE);
        var dropdownChild = $$$1(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

        if (dropdownChild) {
          $$$1(dropdownChild).removeClass(ClassName.ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      $$$1(element).addClass(ClassName.ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      Util.reflow(element);
      $$$1(element).addClass(ClassName.SHOW);

      if (element.parentNode &amp;&amp; $$$1(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
        var dropdownElement = $$$1(element).closest(Selector.DROPDOWN)[0];

        if (dropdownElement) {
          $$$1(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    }; // Static


    Tab._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $$$1(this);
        var data = $this.data(DATA_KEY);

        if (!data) {
          data = new Tab(this);
          $this.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
          }

          data[config]();
        }
      });
    };

    _createClass(Tab, null, [{
      key: &quot;VERSION&quot;,
      get: function get() {
        return VERSION;
      }
    }]);
    return Tab;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
    event.preventDefault();

    Tab._jQueryInterface.call($$$1(this), 'show');
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $$$1.fn[NAME] = Tab._jQueryInterface;
  $$$1.fn[NAME].Constructor = Tab;

  $$$1.fn[NAME].noConflict = function () {
    $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
    return Tab._jQueryInterface;
  };

  return Tab;
}($);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-alpha.6): index.js
 * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
 * --------------------------------------------------------------------------
 */

(function ($$$1) {
  if (typeof $$$1 === 'undefined') {
    throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
  }

  var version = $$$1.fn.jquery.split(' ')[0].split('.');
  var minMajor = 1;
  var ltMajor = 2;
  var minMinor = 9;
  var minPatch = 1;
  var maxMajor = 4;

  if (version[0] &lt; ltMajor &amp;&amp; version[1] &lt; minMinor || version[0] === minMajor &amp;&amp; version[1] === minMinor &amp;&amp; version[2] &lt; minPatch || version[0] &gt;= maxMajor) {
    throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
  }
})($);

exports.Util = Util;
exports.Alert = Alert;
exports.Button = Button;
exports.Carousel = Carousel;
exports.Collapse = Collapse;
exports.Dropdown = Dropdown;
exports.Modal = Modal;
exports.Popover = Popover;
exports.Scrollspy = ScrollSpy;
exports.Tab = Tab;
exports.Tooltip = Tooltip;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=bootstrap.js.map</UL></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
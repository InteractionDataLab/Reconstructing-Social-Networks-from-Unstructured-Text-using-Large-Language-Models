<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_SBS_SH_112144_js_masonry_pkgd_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:SBS SH 112144/js/masonry.pkgd.js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE>* Masonry PACKAGED v4.2.0
* Cascading grid layout library
* <A rel="nofollow" class="external free" href="http://masonry.desandro.com">http://masonry.desandro.com</A>
* MIT License
* by David DeSandro
*/
</PRE><P>/**
</P><PRE>* Bridget makes jQuery widgets
* v2.0.1
* MIT license
*/
</PRE><P>/* jshint browser: true, strict: true, undef: true, unused: true */
</P><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /*jshint strict: false */ /* globals define, module, require */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'jquery-bridget/jquery-bridget',[ 'jquery' ], function( jQuery ) {
     return factory( window, jQuery );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('jquery')
   );
 } else {
   // browser global
   window.jQueryBridget = factory(
     window,
     window.jQuery
   );
 }
</PRE><P>}( window, function factory( window, jQuery ) {
'use strict';
</P><P>// ----- utils ----- //
</P><P>var arraySlice = Array.prototype.slice;
</P><P>// helper function for logging errors
// $.error breaks jQuery chaining
var console = window.console;
var logError = typeof console == 'undefined' ? function() {} :
</P><PRE> function( message ) {
   console.error( message );
 };
</PRE><P>// ----- jQueryBridget ----- //
</P><P>function jQueryBridget( namespace, PluginClass, $ ) {
</P><PRE> $ = $ || jQuery || window.jQuery;
 if ( !$ ) {
   return;
 }
</PRE><PRE> // add option method -&gt; $().plugin('option', {...})
 if ( !PluginClass.prototype.option ) {
   // option setter
   PluginClass.prototype.option = function( opts ) {
     // bail out if not an object
     if ( !$.isPlainObject( opts ) ){
       return;
     }
     this.options = $.extend( true, this.options, opts );
   };
 }
</PRE><PRE> // make jQuery plugin
 $.fn[ namespace ] = function( arg0 /*, arg1 */ ) {
   if ( typeof arg0 == 'string' ) {
     // method call $().plugin( 'methodName', { options } )
     // shift arguments by 1
     var args = arraySlice.call( arguments, 1 );
     return methodCall( this, arg0, args );
   }
   // just $().plugin({ options })
   plainCall( this, arg0 );
   return this;
 };
</PRE><PRE> // $().plugin('methodName')
 function methodCall( $elems, methodName, args ) {
   var returnValue;
   var pluginMethodStr = '$().' + namespace + '(&quot;' + methodName + '&quot;)';
</PRE><PRE>   $elems.each( function( i, elem ) {
     // get instance
     var instance = $.data( elem, namespace );
     if ( !instance ) {
       logError( namespace + ' not initialized. Cannot call methods, i.e. ' +
         pluginMethodStr );
       return;
     }
</PRE><PRE>     var method = instance[ methodName ];
     if ( !method || methodName.charAt(0) == '_' ) {
       logError( pluginMethodStr + ' is not a valid method' );
       return;
     }
</PRE><PRE>     // apply method, get return value
     var value = method.apply( instance, args );
     // set return value if value is returned, use only first value
     returnValue = returnValue === undefined ? value : returnValue;
   });
</PRE><PRE>   return returnValue !== undefined ? returnValue : $elems;
 }
</PRE><PRE> function plainCall( $elems, options ) {
   $elems.each( function( i, elem ) {
     var instance = $.data( elem, namespace );
     if ( instance ) {
       // set options &amp; init
       instance.option( options );
       instance._init();
     } else {
       // initialize new instance
       instance = new PluginClass( elem, options );
       $.data( elem, namespace, instance );
     }
   });
 }
</PRE><PRE> updateJQuery( $ );
</PRE><P>}
</P><P>// ----- updateJQuery ----- //
</P><P>// set $.bridget for v1 backwards compatibility
function updateJQuery( $ ) {
</P><PRE> if ( !$ || ( $ &amp;&amp; $.bridget ) ) {
   return;
 }
 $.bridget = jQueryBridget;
</PRE><P>}
</P><P>updateJQuery( jQuery || window.jQuery );
</P><P>// -----  ----- //
</P><P>return jQueryBridget;
</P><P>}));
</P><P>/**
</P><PRE>* EvEmitter v1.0.3
* Lil' event emitter
* MIT License
*/
</PRE><P>/* jshint unused: true, undef: true, strict: true */
</P><P>( function( global, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */ /* globals define, module, window */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD - RequireJS
   define( 'ev-emitter/ev-emitter',factory );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS - Browserify, Webpack
   module.exports = factory();
 } else {
   // Browser globals
   global.EvEmitter = factory();
 }
</PRE><P>}( typeof window != 'undefined' ? window : this, function() {
</P><P>function EvEmitter() {}
</P><P>var proto = EvEmitter.prototype;
</P><P>proto.on = function( eventName, listener ) {
</P><PRE> if ( !eventName || !listener ) {
   return;
 }
 // set events hash
 var events = this._events = this._events || {};
 // set listeners array
 var listeners = events[ eventName ] = events[ eventName ] || [];
 // only add once
 if ( listeners.indexOf( listener ) == -1 ) {
   listeners.push( listener );
 }
</PRE><PRE> return this;
</PRE><P>};
</P><P>proto.once = function( eventName, listener ) {
</P><PRE> if ( !eventName || !listener ) {
   return;
 }
 // add event
 this.on( eventName, listener );
 // set once flag
 // set onceEvents hash
 var onceEvents = this._onceEvents = this._onceEvents || {};
 // set onceListeners object
 var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
 // set flag
 onceListeners[ listener ] = true;
</PRE><PRE> return this;
</PRE><P>};
</P><P>proto.off = function( eventName, listener ) {
</P><PRE> var listeners = this._events &amp;&amp; this._events[ eventName ];
 if ( !listeners || !listeners.length ) {
   return;
 }
 var index = listeners.indexOf( listener );
 if ( index != -1 ) {
   listeners.splice( index, 1 );
 }
</PRE><PRE> return this;
</PRE><P>};
</P><P>proto.emitEvent = function( eventName, args ) {
</P><PRE> var listeners = this._events &amp;&amp; this._events[ eventName ];
 if ( !listeners || !listeners.length ) {
   return;
 }
 var i = 0;
 var listener = listeners[i];
 args = args || [];
 // once stuff
 var onceListeners = this._onceEvents &amp;&amp; this._onceEvents[ eventName ];
</PRE><PRE> while ( listener ) {
   var isOnce = onceListeners &amp;&amp; onceListeners[ listener ];
   if ( isOnce ) {
     // remove listener
     // remove before trigger to prevent recursion
     this.off( eventName, listener );
     // unset once flag
     delete onceListeners[ listener ];
   }
   // trigger listener
   listener.apply( this, args );
   // get next listener
   i += isOnce ? 0 : 1;
   listener = listeners[i];
 }
</PRE><PRE> return this;
</PRE><P>};
</P><P>return EvEmitter;
</P><P>}));
</P><P>/*!
</P><PRE>* getSize v2.0.2
* measure size of elements
* MIT license
*/
</PRE><P>/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, module: false, console: false */
</P><P>( function( window, factory ) {
</P><PRE> 'use strict';
</PRE><PRE> if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'get-size/get-size',[],function() {
     return factory();
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory();
 } else {
   // browser global
   window.getSize = factory();
 }
</PRE><P>})( window, function factory() {
'use strict';
</P><P>// -------------------------- helpers -------------------------- //
</P><P>// get a number from a string, not a percentage
function getStyleSize( value ) {
</P><PRE> var num = parseFloat( value );
 // not a percent like '100%', and a number
 var isValid = value.indexOf('%') == -1 &amp;&amp; !isNaN( num );
 return isValid &amp;&amp; num;
</PRE><P>}
</P><P>function noop() {}
</P><P>var logError = typeof console == 'undefined' ? noop :
</P><PRE> function( message ) {
   console.error( message );
 };
</PRE><P>// -------------------------- measurements -------------------------- //
</P><P>var measurements = [
</P><PRE> 'paddingLeft',
 'paddingRight',
 'paddingTop',
 'paddingBottom',
 'marginLeft',
 'marginRight',
 'marginTop',
 'marginBottom',
 'borderLeftWidth',
 'borderRightWidth',
 'borderTopWidth',
 'borderBottomWidth'
</PRE><P>];
</P><P>var measurementsLength = measurements.length;
</P><P>function getZeroSize() {
</P><PRE> var size = {
   width: 0,
   height: 0,
   innerWidth: 0,
   innerHeight: 0,
   outerWidth: 0,
   outerHeight: 0
 };
 for ( var i=0; i &lt; measurementsLength; i++ ) {
   var measurement = measurements[i];
   size[ measurement ] = 0;
 }
 return size;
</PRE><P>}
</P><P>// -------------------------- getStyle -------------------------- //
</P><P>/**
</P><PRE>* getStyle, get style of element, check for Firefox bug
* <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=548397">https://bugzilla.mozilla.org/show_bug.cgi?id=548397</A>
*/
</PRE><P>function getStyle( elem ) {
</P><PRE> var style = getComputedStyle( elem );
 if ( !style ) {
   logError( 'Style returned ' + style +
     '. Are you running this code in a hidden iframe on Firefox? ' +
     'See <A rel="nofollow" class="external free" href="http://bit.ly/getsizebug1'">http://bit.ly/getsizebug1'</A> );
 }
 return style;
</PRE><P>}
</P><P>// -------------------------- setup -------------------------- //
</P><P>var isSetup = false;
</P><P>var isBoxSizeOuter;
</P><P>/**
</P><PRE>* setup
* check isBoxSizerOuter
* do on first getSize() rather than on page load for Firefox bug
*/
</PRE><P>function setup() {
</P><PRE> // setup once
 if ( isSetup ) {
   return;
 }
 isSetup = true;
</PRE><PRE> // -------------------------- box sizing -------------------------- //
</PRE><PRE> /**
  * WebKit measures the outer-width on style.width on border-box elems
  * IE &amp; Firefox&lt;29 measures the inner-width
  */
 var div = document.createElement('div');
 div.style.width = '200px';
 div.style.padding = '1px 2px 3px 4px';
 div.style.borderStyle = 'solid';
 div.style.borderWidth = '1px 2px 3px 4px';
 div.style.boxSizing = 'border-box';
</PRE><PRE> var body = document.body || document.documentElement;
 body.appendChild( div );
 var style = getStyle( div );
</PRE><PRE> getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize( style.width ) == 200;
 body.removeChild( div );
</PRE><P>}
</P><P>// -------------------------- getSize -------------------------- //
</P><P>function getSize( elem ) {
</P><PRE> setup();
</PRE><PRE> // use querySeletor if elem is string
 if ( typeof elem == 'string' ) {
   elem = document.querySelector( elem );
 }
</PRE><PRE> // do not proceed on non-objects
 if ( !elem || typeof elem != 'object' || !elem.nodeType ) {
   return;
 }
</PRE><PRE> var style = getStyle( elem );
</PRE><PRE> // if hidden, everything is 0
 if ( style.display == 'none' ) {
   return getZeroSize();
 }
</PRE><PRE> var size = {};
 size.width = elem.offsetWidth;
 size.height = elem.offsetHeight;
</PRE><PRE> var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';
</PRE><PRE> // get all measurements
 for ( var i=0; i &lt; measurementsLength; i++ ) {
   var measurement = measurements[i];
   var value = style[ measurement ];
   var num = parseFloat( value );
   // any 'auto', 'medium' value will be 0
   size[ measurement ] = !isNaN( num ) ? num : 0;
 }
</PRE><PRE> var paddingWidth = size.paddingLeft + size.paddingRight;
 var paddingHeight = size.paddingTop + size.paddingBottom;
 var marginWidth = size.marginLeft + size.marginRight;
 var marginHeight = size.marginTop + size.marginBottom;
 var borderWidth = size.borderLeftWidth + size.borderRightWidth;
 var borderHeight = size.borderTopWidth + size.borderBottomWidth;
</PRE><PRE> var isBorderBoxSizeOuter = isBorderBox &amp;&amp; isBoxSizeOuter;
</PRE><PRE> // overwrite width and height if we can get it from style
 var styleWidth = getStyleSize( style.width );
 if ( styleWidth !== false ) {
   size.width = styleWidth +
     // add padding and border unless it's already including it
     ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
 }
</PRE><PRE> var styleHeight = getStyleSize( style.height );
 if ( styleHeight !== false ) {
   size.height = styleHeight +
     // add padding and border unless it's already including it
     ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
 }
</PRE><PRE> size.innerWidth = size.width - ( paddingWidth + borderWidth );
 size.innerHeight = size.height - ( paddingHeight + borderHeight );
</PRE><PRE> size.outerWidth = size.width + marginWidth;
 size.outerHeight = size.height + marginHeight;
</PRE><PRE> return size;
</PRE><P>}
</P><P>return getSize;
</P><P>});
</P><P>/**
</P><PRE>* matchesSelector v2.0.2
* matchesSelector( element, '.selector' )
* MIT license
*/
</PRE><P>/*jshint browser: true, strict: true, undef: true, unused: true */
</P><P>( function( window, factory ) {
</P><PRE> /*global define: false, module: false */
 'use strict';
 // universal module definition
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'desandro-matches-selector/matches-selector',factory );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory();
 } else {
   // browser global
   window.matchesSelector = factory();
 }
</PRE><P>}( window, function factory() {
</P><PRE> 'use strict';
</PRE><PRE> var matchesMethod = ( function() {
   var ElemProto = window.Element.prototype;
   // check for the standard method name first
   if ( ElemProto.matches ) {
     return 'matches';
   }
   // check un-prefixed
   if ( ElemProto.matchesSelector ) {
     return 'matchesSelector';
   }
   // check vendor prefixes
   var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];
</PRE><PRE>   for ( var i=0; i &lt; prefixes.length; i++ ) {
     var prefix = prefixes[i];
     var method = prefix + 'MatchesSelector';
     if ( ElemProto[ method ] ) {
       return method;
     }
   }
 })();
</PRE><PRE> return function matchesSelector( elem, selector ) {
   return elem[ matchesMethod ]( selector );
 };
</PRE><P>}));
</P><P>/**
</P><PRE>* Fizzy UI utils v2.0.4
* MIT license
*/
</PRE><P>/*jshint browser: true, undef: true, unused: true, strict: true */
</P><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /*jshint strict: false */ /*globals define, module, require */
</PRE><PRE> if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'fizzy-ui-utils/utils',[
     'desandro-matches-selector/matches-selector'
   ], function( matchesSelector ) {
     return factory( window, matchesSelector );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('desandro-matches-selector')
   );
 } else {
   // browser global
   window.fizzyUIUtils = factory(
     window,
     window.matchesSelector
   );
 }
</PRE><P>}( window, function factory( window, matchesSelector ) {
</P><P>var utils = {};
</P><P>// ----- extend ----- //
</P><P>// extends objects
utils.extend = function( a, b ) {
</P><PRE> for ( var prop in b ) {
   a[ prop ] = b[ prop ];
 }
 return a;
</PRE><P>};
</P><P>// ----- modulo ----- //
</P><P>utils.modulo = function( num, div ) {
</P><PRE> return ( ( num % div ) + div ) % div;
</PRE><P>};
</P><P>// ----- makeArray ----- //
</P><P>// turn element or nodeList into an array
utils.makeArray = function( obj ) {
</P><PRE> var ary = [];
 if ( Array.isArray( obj ) ) {
   // use object if already an array
   ary = obj;
 } else if ( obj &amp;&amp; typeof obj == 'object' &amp;&amp;
   typeof obj.length == 'number' ) {
   // convert nodeList to array
   for ( var i=0; i &lt; obj.length; i++ ) {
     ary.push( obj[i] );
   }
 } else {
   // array of single index
   ary.push( obj );
 }
 return ary;
</PRE><P>};
</P><P>// ----- removeFrom ----- //
</P><P>utils.removeFrom = function( ary, obj ) {
</P><PRE> var index = ary.indexOf( obj );
 if ( index != -1 ) {
   ary.splice( index, 1 );
 }
</PRE><P>};
</P><P>// ----- getParent ----- //
</P><P>utils.getParent = function( elem, selector ) {
</P><PRE> while ( elem != document.body ) {
   elem = elem.parentNode;
   if ( matchesSelector( elem, selector ) ) {
     return elem;
   }
 }
</PRE><P>};
</P><P>// ----- getQueryElement ----- //
</P><P>// use element as selector string
utils.getQueryElement = function( elem ) {
</P><PRE> if ( typeof elem == 'string' ) {
   return document.querySelector( elem );
 }
 return elem;
</PRE><P>};
</P><P>// ----- handleEvent ----- //
</P><P>// enable .ontype to trigger from .addEventListener( elem, 'type' )
utils.handleEvent = function( event ) {
</P><PRE> var method = 'on' + event.type;
 if ( this[ method ] ) {
   this[ method ]( event );
 }
</PRE><P>};
</P><P>// ----- filterFindElements ----- //
</P><P>utils.filterFindElements = function( elems, selector ) {
</P><PRE> // make array of elems
 elems = utils.makeArray( elems );
 var ffElems = [];
</PRE><PRE> elems.forEach( function( elem ) {
   // check that elem is an actual element
   if ( !( elem instanceof HTMLElement ) ) {
     return;
   }
   // add elem if no selector
   if ( !selector ) {
     ffElems.push( elem );
     return;
   }
   // filter &amp; find items if we have a selector
   // filter
   if ( matchesSelector( elem, selector ) ) {
     ffElems.push( elem );
   }
   // find children
   var childElems = elem.querySelectorAll( selector );
   // concat childElems to filterFound array
   for ( var i=0; i &lt; childElems.length; i++ ) {
     ffElems.push( childElems[i] );
   }
 });
</PRE><PRE> return ffElems;
</PRE><P>};
</P><P>// ----- debounceMethod ----- //
</P><P>utils.debounceMethod = function( _class, methodName, threshold ) {
</P><PRE> // original method
 var method = _class.prototype[ methodName ];
 var timeoutName = methodName + 'Timeout';
</PRE><PRE> _class.prototype[ methodName ] = function() {
   var timeout = this[ timeoutName ];
   if ( timeout ) {
     clearTimeout( timeout );
   }
   var args = arguments;
</PRE><PRE>   var _this = this;
   this[ timeoutName ] = setTimeout( function() {
     method.apply( _this, args );
     delete _this[ timeoutName ];
   }, threshold || 100 );
 };
</PRE><P>};
</P><P>// ----- docReady ----- //
</P><P>utils.docReady = function( callback ) {
</P><PRE> var readyState = document.readyState;
 if ( readyState == 'complete' || readyState == 'interactive' ) {
   // do async to allow for other scripts to run. metafizzy/flickity#441
   setTimeout( callback );
 } else {
   document.addEventListener( 'DOMContentLoaded', callback );
 }
</PRE><P>};
</P><P>// ----- htmlInit ----- //
</P><P>// <A rel="nofollow" class="external free" href="http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/">http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/</A>
utils.toDashed = function( str ) {
</P><PRE> return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
   return $1 + '-' + $2;
 }).toLowerCase();
</PRE><P>};
</P><P>var console = window.console;
/**
</P><PRE>* allow user to initialize classes via [data-namespace] or .js-namespace class
* htmlInit( Widget, 'widgetName' )
* options are parsed from data-namespace-options
*/
</PRE><P>utils.htmlInit = function( WidgetClass, namespace ) {
</P><PRE> utils.docReady( function() {
   var dashedNamespace = utils.toDashed( namespace );
   var dataAttr = 'data-' + dashedNamespace;
   var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );
   var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );
   var elems = utils.makeArray( dataAttrElems )
     .concat( utils.makeArray( jsDashElems ) );
   var dataOptionsAttr = dataAttr + '-options';
   var jQuery = window.jQuery;
</PRE><PRE>   elems.forEach( function( elem ) {
     var attr = elem.getAttribute( dataAttr ) ||
       elem.getAttribute( dataOptionsAttr );
     var options;
     try {
       options = attr &amp;&amp; JSON.parse( attr );
     } catch ( error ) {
       // log error, do not initialize
       if ( console ) {
         console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +
         ': ' + error );
       }
       return;
     }
     // initialize
     var instance = new WidgetClass( elem, options );
     // make available via $().data('namespace')
     if ( jQuery ) {
       jQuery.data( elem, namespace, instance );
     }
   });
</PRE><PRE> });
</PRE><P>};
</P><P>// -----  ----- //
</P><P>return utils;
</P><P>}));
</P><P>/**
</P><PRE>* Outlayer Item
*/
</PRE><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */ /* globals define, module, require */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD - RequireJS
   define( 'outlayer/item',[
       'ev-emitter/ev-emitter',
       'get-size/get-size'
     ],
     factory
   );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS - Browserify, Webpack
   module.exports = factory(
     require('ev-emitter'),
     require('get-size')
   );
 } else {
   // browser global
   window.Outlayer = {};
   window.Outlayer.Item = factory(
     window.EvEmitter,
     window.getSize
   );
 }
</PRE><P>}( window, function factory( EvEmitter, getSize ) {
'use strict';
</P><P>// ----- helpers ----- //
</P><P>function isEmptyObj( obj ) {
</P><PRE> for ( var prop in obj ) {
   return false;
 }
 prop = null;
 return true;
</PRE><P>}
</P><P>// -------------------------- CSS3 support -------------------------- //
</P><P>
var docElemStyle = document.documentElement.style;
</P><P>var transitionProperty = typeof docElemStyle.transition == 'string' ?
</P><PRE> 'transition' : 'WebkitTransition';
</PRE><P>var transformProperty = typeof docElemStyle.transform == 'string' ?
</P><PRE> 'transform' : 'WebkitTransform';
</PRE><P>var transitionEndEvent = {
</P><PRE> WebkitTransition: 'webkitTransitionEnd',
 transition: 'transitionend'
</PRE><P>}[ transitionProperty ];
</P><P>// cache all vendor properties that could have vendor prefix
var vendorProperties = {
</P><PRE> transform: transformProperty,
 transition: transitionProperty,
 transitionDuration: transitionProperty + 'Duration',
 transitionProperty: transitionProperty + 'Property',
 transitionDelay: transitionProperty + 'Delay'
</PRE><P>};
</P><P>// -------------------------- Item -------------------------- //
</P><P>function Item( element, layout ) {
</P><PRE> if ( !element ) {
   return;
 }
</PRE><PRE> this.element = element;
 // parent layout class, i.e. Masonry, Isotope, or Packery
 this.layout = layout;
 this.position = {
   x: 0,
   y: 0
 };
</PRE><PRE> this._create();
</PRE><P>}
</P><P>// inherit EvEmitter
var proto = Item.prototype = Object.create( EvEmitter.prototype );
proto.constructor = Item;
</P><P>proto._create = function() {
</P><PRE> // transition objects
 this._transn = {
   ingProperties: {},
   clean: {},
   onEnd: {}
 };
</PRE><PRE> this.css({
   position: 'absolute'
 });
</PRE><P>};
</P><P>// trigger specified handler for event type
proto.handleEvent = function( event ) {
</P><PRE> var method = 'on' + event.type;
 if ( this[ method ] ) {
   this[ method ]( event );
 }
</PRE><P>};
</P><P>proto.getSize = function() {
</P><PRE> this.size = getSize( this.element );
</PRE><P>};
</P><P>/**
</P><PRE>* apply CSS styles to element
* @param {Object} style
*/
</PRE><P>proto.css = function( style ) {
</P><PRE> var elemStyle = this.element.style;
</PRE><PRE> for ( var prop in style ) {
   // use vendor property if available
   var supportedProp = vendorProperties[ prop ] || prop;
   elemStyle[ supportedProp ] = style[ prop ];
 }
</PRE><P>};
</P><PRE>// measure position, and sets it
</PRE><P>proto.getPosition = function() {
</P><PRE> var style = getComputedStyle( this.element );
 var isOriginLeft = this.layout._getOption('originLeft');
 var isOriginTop = this.layout._getOption('originTop');
 var xValue = style[ isOriginLeft ? 'left' : 'right' ];
 var yValue = style[ isOriginTop ? 'top' : 'bottom' ];
 // convert percent to pixels
 var layoutSize = this.layout.size;
 var x = xValue.indexOf('%') != -1 ?
   ( parseFloat( xValue ) / 100 ) * layoutSize.width : parseInt( xValue, 10 );
 var y = yValue.indexOf('%') != -1 ?
   ( parseFloat( yValue ) / 100 ) * layoutSize.height : parseInt( yValue, 10 );
</PRE><PRE> // clean up 'auto' or other non-integer values
 x = isNaN( x ) ? 0 : x;
 y = isNaN( y ) ? 0 : y;
 // remove padding from measurement
 x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
 y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;
</PRE><PRE> this.position.x = x;
 this.position.y = y;
</PRE><P>};
</P><P>// set settled position, apply padding
proto.layoutPosition = function() {
</P><PRE> var layoutSize = this.layout.size;
 var style = {};
 var isOriginLeft = this.layout._getOption('originLeft');
 var isOriginTop = this.layout._getOption('originTop');
</PRE><PRE> // x
 var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';
 var xProperty = isOriginLeft ? 'left' : 'right';
 var xResetProperty = isOriginLeft ? 'right' : 'left';
</PRE><PRE> var x = this.position.x + layoutSize[ xPadding ];
 // set in percentage or pixels
 style[ xProperty ] = this.getXValue( x );
 // reset other property
 style[ xResetProperty ] = <I>;</I></PRE><PRE> // y
 var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';
 var yProperty = isOriginTop ? 'top' : 'bottom';
 var yResetProperty = isOriginTop ? 'bottom' : 'top';
</PRE><PRE> var y = this.position.y + layoutSize[ yPadding ];
 // set in percentage or pixels
 style[ yProperty ] = this.getYValue( y );
 // reset other property
 style[ yResetProperty ] = <I>;</I></PRE><PRE> this.css( style );
 this.emitEvent( 'layout', [ this ] );
</PRE><P>};
</P><P>proto.getXValue = function( x ) {
</P><PRE> var isHorizontal = this.layout._getOption('horizontal');
 return this.layout.options.percentPosition &amp;&amp; !isHorizontal ?
   ( ( x / this.layout.size.width ) * 100 ) + '%' : x + 'px';
</PRE><P>};
</P><P>proto.getYValue = function( y ) {
</P><PRE> var isHorizontal = this.layout._getOption('horizontal');
 return this.layout.options.percentPosition &amp;&amp; isHorizontal ?
   ( ( y / this.layout.size.height ) * 100 ) + '%' : y + 'px';
</PRE><P>};
</P><P>proto._transitionTo = function( x, y ) {
</P><PRE> this.getPosition();
 // get current x &amp; y from top/left
 var curX = this.position.x;
 var curY = this.position.y;
</PRE><PRE> var compareX = parseInt( x, 10 );
 var compareY = parseInt( y, 10 );
 var didNotMove = compareX === this.position.x &amp;&amp; compareY === this.position.y;
</PRE><PRE> // save end position
 this.setPosition( x, y );
</PRE><PRE> // if did not move and not transitioning, just go to layout
 if ( didNotMove &amp;&amp; !this.isTransitioning ) {
   this.layoutPosition();
   return;
 }
</PRE><PRE> var transX = x - curX;
 var transY = y - curY;
 var transitionStyle = {};
 transitionStyle.transform = this.getTranslate( transX, transY );
</PRE><PRE> this.transition({
   to: transitionStyle,
   onTransitionEnd: {
     transform: this.layoutPosition
   },
   isCleaning: true
 });
</PRE><P>};
</P><P>proto.getTranslate = function( x, y ) {
</P><PRE> // flip cooridinates if origin on right or bottom
 var isOriginLeft = this.layout._getOption('originLeft');
 var isOriginTop = this.layout._getOption('originTop');
 x = isOriginLeft ? x : -x;
 y = isOriginTop ? y : -y;
 return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
</PRE><P>};
</P><P>// non transition + transform support
proto.goTo = function( x, y ) {
</P><PRE> this.setPosition( x, y );
 this.layoutPosition();
</PRE><P>};
</P><P>proto.moveTo = proto._transitionTo;
</P><P>proto.setPosition = function( x, y ) {
</P><PRE> this.position.x = parseInt( x, 10 );
 this.position.y = parseInt( y, 10 );
</PRE><P>};
</P><P>// ----- transition ----- //
</P><P>/**
</P><PRE>* @param {Object} style - CSS
* @param {Function} onTransitionEnd
*/
</PRE><P>// non transition, just trigger callback
proto._nonTransition = function( args ) {
</P><PRE> this.css( args.to );
 if ( args.isCleaning ) {
   this._removeStyles( args.to );
 }
 for ( var prop in args.onTransitionEnd ) {
   args.onTransitionEnd[ prop ].call( this );
 }
</PRE><P>};
</P><P>/**
</P><PRE>* proper transition
* @param {Object} args - arguments
*   @param {Object} to - style to transition to
*   @param {Object} from - style to start transition from
*   @param {Boolean} isCleaning - removes transition styles after transition
*   @param {Function} onTransitionEnd - callback
*/
</PRE><P>proto.transition = function( args ) {
</P><PRE> // redirect to nonTransition if no transition duration
 if ( !parseFloat( this.layout.options.transitionDuration ) ) {
   this._nonTransition( args );
   return;
 }
</PRE><PRE> var _transition = this._transn;
 // keep track of onTransitionEnd callback by css property
 for ( var prop in args.onTransitionEnd ) {
   _transition.onEnd[ prop ] = args.onTransitionEnd[ prop ];
 }
 // keep track of properties that are transitioning
 for ( prop in args.to ) {
   _transition.ingProperties[ prop ] = true;
   // keep track of properties to clean up when transition is done
   if ( args.isCleaning ) {
     _transition.clean[ prop ] = true;
   }
 }
</PRE><PRE> // set from styles
 if ( args.from ) {
   this.css( args.from );
   // force redraw. <A rel="nofollow" class="external free" href="http://blog.alexmaccaw.com/css-transitions">http://blog.alexmaccaw.com/css-transitions</A>
   var h = this.element.offsetHeight;
   // hack for JSHint to hush about unused var
   h = null;
 }
 // enable transition
 this.enableTransition( args.to );
 // set styles that are transitioning
 this.css( args.to );
</PRE><PRE> this.isTransitioning = true;
</PRE><P>};
</P><P>// dash before all cap letters, including first for
// WebkitTransform =&gt; -webkit-transform
function toDashedAll( str ) {
</P><PRE> return str.replace( /([A-Z])/g, function( $1 ) {
   return '-' + $1.toLowerCase();
 });
</PRE><P>}
</P><P>var transitionProps = 'opacity,' + toDashedAll( transformProperty );
</P><P>proto.enableTransition = function(/* style */) {
</P><PRE> // HACK changing transitionProperty during a transition
 // will cause transition to jump
 if ( this.isTransitioning ) {
   return;
 }
</PRE><PRE> // make `transition: foo, bar, baz` from style object
 // HACK un-comment this when enableTransition can work
 // while a transition is happening
 // var transitionValues = [];
 // for ( var prop in style ) {
 //   // dash-ify camelCased properties like WebkitTransition
 //   prop = vendorProperties[ prop ] || prop;
 //   transitionValues.push( toDashedAll( prop ) );
 // }
 // munge number to millisecond, to match stagger
 var duration = this.layout.options.transitionDuration;
 duration = typeof duration == 'number' ? duration + 'ms' : duration;
 // enable transition styles
 this.css({
   transitionProperty: transitionProps,
   transitionDuration: duration,
   transitionDelay: this.staggerDelay || 0
 });
 // listen for transition end event
 this.element.addEventListener( transitionEndEvent, this, false );
</PRE><P>};
</P><P>// ----- events ----- //
</P><P>proto.onwebkitTransitionEnd = function( event ) {
</P><PRE> this.ontransitionend( event );
</PRE><P>};
</P><P>proto.onotransitionend = function( event ) {
</P><PRE> this.ontransitionend( event );
</PRE><P>};
</P><P>// properties that I munge to make my life easier
var dashedVendorProperties = {
</P><PRE> '-webkit-transform': 'transform'
</PRE><P>};
</P><P>proto.ontransitionend = function( event ) {
</P><PRE> // disregard bubbled events from children
 if ( event.target !== this.element ) {
   return;
 }
 var _transition = this._transn;
 // get property name of transitioned property, convert to prefix-free
 var propertyName = dashedVendorProperties[ event.propertyName ] || event.propertyName;
</PRE><PRE> // remove property that has completed transitioning
 delete _transition.ingProperties[ propertyName ];
 // check if any properties are still transitioning
 if ( isEmptyObj( _transition.ingProperties ) ) {
   // all properties have completed transitioning
   this.disableTransition();
 }
 // clean style
 if ( propertyName in _transition.clean ) {
   // clean up style
   this.element.style[ event.propertyName ] = <I>;</I>
   delete _transition.clean[ propertyName ];
 }
 // trigger onTransitionEnd callback
 if ( propertyName in _transition.onEnd ) {
   var onTransitionEnd = _transition.onEnd[ propertyName ];
   onTransitionEnd.call( this );
   delete _transition.onEnd[ propertyName ];
 }
</PRE><PRE> this.emitEvent( 'transitionEnd', [ this ] );
</PRE><P>};
</P><P>proto.disableTransition = function() {
</P><PRE> this.removeTransitionStyles();
 this.element.removeEventListener( transitionEndEvent, this, false );
 this.isTransitioning = false;
</PRE><P>};
</P><P>/**
</P><PRE>* removes style property from element
* @param {Object} style
</PRE><UL><LI>/</LI></UL><P>proto._removeStyles = function( style ) {
</P><PRE> // clean up transition styles
 var cleanStyle = {};
 for ( var prop in style ) {
   cleanStyle[ prop ] = <I>;</I>
 }
 this.css( cleanStyle );
</PRE><P>};
</P><P>var cleanTransitionStyle = {
</P><PRE> transitionProperty: <I>,</I>
 transitionDuration: <I>,</I>
 transitionDelay: 
</PRE><P>};
</P><P>proto.removeTransitionStyles = function() {
</P><PRE> // remove transition
 this.css( cleanTransitionStyle );
</PRE><P>};
</P><P>// ----- stagger ----- //
</P><P>proto.stagger = function( delay ) {
</P><PRE> delay = isNaN( delay ) ? 0 : delay;
 this.staggerDelay = delay + 'ms';
</PRE><P>};
</P><P>// ----- show/hide/remove ----- //
</P><P>// remove element from DOM
proto.removeElem = function() {
</P><PRE> this.element.parentNode.removeChild( this.element );
 // remove display: none
 this.css({ display: <I> });</I>
 this.emitEvent( 'remove', [ this ] );
</PRE><P>};
</P><P>proto.remove = function() {
</P><PRE> // just remove element if no transition support or no transition
 if ( !transitionProperty || !parseFloat( this.layout.options.transitionDuration ) ) {
   this.removeElem();
   return;
 }
</PRE><PRE> // start transition
 this.once( 'transitionEnd', function() {
   this.removeElem();
 });
 this.hide();
</PRE><P>};
</P><P>proto.reveal = function() {
</P><PRE> delete this.isHidden;
 // remove display: none
 this.css({ display: <I> });</I></PRE><PRE> var options = this.layout.options;
</PRE><PRE> var onTransitionEnd = {};
 var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');
 onTransitionEnd[ transitionEndProperty ] = this.onRevealTransitionEnd;
</PRE><PRE> this.transition({
   from: options.hiddenStyle,
   to: options.visibleStyle,
   isCleaning: true,
   onTransitionEnd: onTransitionEnd
 });
</PRE><P>};
</P><P>proto.onRevealTransitionEnd = function() {
</P><PRE> // check if still visible
 // during transition, item may have been hidden
 if ( !this.isHidden ) {
   this.emitEvent('reveal');
 }
</PRE><P>};
</P><P>/**
</P><PRE>* get style property use for hide/reveal transition end
* @param {String} styleProperty - hiddenStyle/visibleStyle
* @returns {String}
*/
</PRE><P>proto.getHideRevealTransitionEndProperty = function( styleProperty ) {
</P><PRE> var optionStyle = this.layout.options[ styleProperty ];
 // use opacity
 if ( optionStyle.opacity ) {
   return 'opacity';
 }
 // get first property
 for ( var prop in optionStyle ) {
   return prop;
 }
</PRE><P>};
</P><P>proto.hide = function() {
</P><PRE> // set flag
 this.isHidden = true;
 // remove display: none
 this.css({ display: <I> });</I></PRE><PRE> var options = this.layout.options;
</PRE><PRE> var onTransitionEnd = {};
 var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');
 onTransitionEnd[ transitionEndProperty ] = this.onHideTransitionEnd;
</PRE><PRE> this.transition({
   from: options.visibleStyle,
   to: options.hiddenStyle,
   // keep hidden stuff hidden
   isCleaning: true,
   onTransitionEnd: onTransitionEnd
 });
</PRE><P>};
</P><P>proto.onHideTransitionEnd = function() {
</P><PRE> // check if still hidden
 // during transition, item may have been un-hidden
 if ( this.isHidden ) {
   this.css({ display: 'none' });
   this.emitEvent('hide');
 }
</PRE><P>};
</P><P>proto.destroy = function() {
</P><PRE> this.css({
   position: <I>,</I>
   left: <I>,</I>
   right: <I>,</I>
   top: <I>,</I>
   bottom: <I>,</I>
   transition: <I>,</I>
   transform: 
 });
</PRE><P>};
</P><P>return Item;
</P><P>}));
</P><P>/*!
</P><PRE>* Outlayer v2.1.0
* the brains and guts of a layout library
* MIT license
*/
</PRE><P>( function( window, factory ) {
</P><PRE> 'use strict';
 // universal module definition
 /* jshint strict: false */ /* globals define, module, require */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD - RequireJS
   define( 'outlayer/outlayer',[
       'ev-emitter/ev-emitter',
       'get-size/get-size',
       'fizzy-ui-utils/utils',
       './item'
     ],
     function( EvEmitter, getSize, utils, Item ) {
       return factory( window, EvEmitter, getSize, utils, Item);
     }
   );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS - Browserify, Webpack
   module.exports = factory(
     window,
     require('ev-emitter'),
     require('get-size'),
     require('fizzy-ui-utils'),
     require('./item')
   );
 } else {
   // browser global
   window.Outlayer = factory(
     window,
     window.EvEmitter,
     window.getSize,
     window.fizzyUIUtils,
     window.Outlayer.Item
   );
 }
</PRE><P>}( window, function factory( window, EvEmitter, getSize, utils, Item ) {
'use strict';
</P><P>// ----- vars ----- //
</P><P>var console = window.console;
var jQuery = window.jQuery;
var noop = function() {};
</P><P>// -------------------------- Outlayer -------------------------- //
</P><P>// globally unique identifiers
var GUID = 0;
// internal store of all Outlayer intances
var instances = {};
</P><P>
/**
</P><PRE>* @param {Element, String} element
* @param {Object} options
* @constructor
*/
</PRE><P>function Outlayer( element, options ) {
</P><PRE> var queryElement = utils.getQueryElement( element );
 if ( !queryElement ) {
   if ( console ) {
     console.error( 'Bad element for ' + this.constructor.namespace +
       ': ' + ( queryElement || element ) );
   }
   return;
 }
 this.element = queryElement;
 // add jQuery
 if ( jQuery ) {
   this.$element = jQuery( this.element );
 }
</PRE><PRE> // options
 this.options = utils.extend( {}, this.constructor.defaults );
 this.option( options );
</PRE><PRE> // add id for Outlayer.getFromElement
 var id = ++GUID;
 this.element.outlayerGUID = id; // expando
 instances[ id ] = this; // associate via id
</PRE><PRE> // kick it off
 this._create();
</PRE><PRE> var isInitLayout = this._getOption('initLayout');
 if ( isInitLayout ) {
   this.layout();
 }
</PRE><P>}
</P><P>// settings are for internal use only
Outlayer.namespace = 'outlayer';
Outlayer.Item = Item;
</P><P>// default options
Outlayer.defaults = {
</P><PRE> containerStyle: {
   position: 'relative'
 },
 initLayout: true,
 originLeft: true,
 originTop: true,
 resize: true,
 resizeContainer: true,
 // item options
 transitionDuration: '0.4s',
 hiddenStyle: {
   opacity: 0,
   transform: 'scale(0.001)'
 },
 visibleStyle: {
   opacity: 1,
   transform: 'scale(1)'
 }
</PRE><P>};
</P><P>var proto = Outlayer.prototype;
// inherit EvEmitter
utils.extend( proto, EvEmitter.prototype );
</P><P>/**
</P><PRE>* set options
* @param {Object} opts
*/
</PRE><P>proto.option = function( opts ) {
</P><PRE> utils.extend( this.options, opts );
</PRE><P>};
</P><P>/**
</P><PRE>* get backwards compatible option value, check old name
*/
</PRE><P>proto._getOption = function( option ) {
</P><PRE> var oldOption = this.constructor.compatOptions[ option ];
 return oldOption &amp;&amp; this.options[ oldOption ] !== undefined ?
   this.options[ oldOption ] : this.options[ option ];
</PRE><P>};
</P><P>Outlayer.compatOptions = {
</P><PRE> // currentName: oldName
 initLayout: 'isInitLayout',
 horizontal: 'isHorizontal',
 layoutInstant: 'isLayoutInstant',
 originLeft: 'isOriginLeft',
 originTop: 'isOriginTop',
 resize: 'isResizeBound',
 resizeContainer: 'isResizingContainer'
</PRE><P>};
</P><P>proto._create = function() {
</P><PRE> // get items from children
 this.reloadItems();
 // elements that affect layout, but are not laid out
 this.stamps = [];
 this.stamp( this.options.stamp );
 // set container style
 utils.extend( this.element.style, this.options.containerStyle );
</PRE><PRE> // bind resize method
 var canBindResize = this._getOption('resize');
 if ( canBindResize ) {
   this.bindResize();
 }
</PRE><P>};
</P><P>// goes through all children again and gets bricks in proper order
proto.reloadItems = function() {
</P><PRE> // collection of item elements
 this.items = this._itemize( this.element.children );
</PRE><P>};
</P><P>
/**
</P><PRE>* turn elements into Outlayer.Items to be used in layout
* @param {Array or NodeList or HTMLElement} elems
* @returns {Array} items - collection of new Outlayer Items
*/
</PRE><P>proto._itemize = function( elems ) {
</P><PRE> var itemElems = this._filterFindItemElements( elems );
 var Item = this.constructor.Item;
</PRE><PRE> // create new Outlayer Items for collection
 var items = [];
 for ( var i=0; i &lt; itemElems.length; i++ ) {
   var elem = itemElems[i];
   var item = new Item( elem, this );
   items.push( item );
 }
</PRE><PRE> return items;
</PRE><P>};
</P><P>/**
</P><PRE>* get item elements to be used in layout
* @param {Array or NodeList or HTMLElement} elems
* @returns {Array} items - item elements
*/
</PRE><P>proto._filterFindItemElements = function( elems ) {
</P><PRE> return utils.filterFindElements( elems, this.options.itemSelector );
</PRE><P>};
</P><P>/**
</P><PRE>* getter method for getting item elements
* @returns {Array} elems - collection of item elements
*/
</PRE><P>proto.getItemElements = function() {
</P><PRE> return this.items.map( function( item ) {
   return item.element;
 });
</PRE><P>};
</P><P>// ----- init &amp; layout ----- //
</P><P>/**
</P><PRE>* lays out all items
*/
</PRE><P>proto.layout = function() {
</P><PRE> this._resetLayout();
 this._manageStamps();
</PRE><PRE> // don't animate first layout
 var layoutInstant = this._getOption('layoutInstant');
 var isInstant = layoutInstant !== undefined ?
   layoutInstant : !this._isLayoutInited;
 this.layoutItems( this.items, isInstant );
</PRE><PRE> // flag for initalized
 this._isLayoutInited = true;
</PRE><P>};
</P><P>// _init is alias for layout
proto._init = proto.layout;
</P><P>/**
</P><PRE>* logic before any new layout
*/
</PRE><P>proto._resetLayout = function() {
</P><PRE> this.getSize();
</PRE><P>};
</P><P>
proto.getSize = function() {
</P><PRE> this.size = getSize( this.element );
</PRE><P>};
</P><P>/**
</P><PRE>* get measurement from option, for columnWidth, rowHeight, gutter
* if option is String -&gt; get element from selector string, &amp; get size of element
* if option is Element -&gt; get size of element
* else use option as a number
*
* @param {String} measurement
* @param {String} size - width or height
* @private
*/
</PRE><P>proto._getMeasurement = function( measurement, size ) {
</P><PRE> var option = this.options[ measurement ];
 var elem;
 if ( !option ) {
   // default to 0
   this[ measurement ] = 0;
 } else {
   // use option as an element
   if ( typeof option == 'string' ) {
     elem = this.element.querySelector( option );
   } else if ( option instanceof HTMLElement ) {
     elem = option;
   }
   // use size of element, if element
   this[ measurement ] = elem ? getSize( elem )[ size ] : option;
 }
</PRE><P>};
</P><P>/**
</P><PRE>* layout a collection of item elements
* @api public
*/
</PRE><P>proto.layoutItems = function( items, isInstant ) {
</P><PRE> items = this._getItemsForLayout( items );
</PRE><PRE> this._layoutItems( items, isInstant );
</PRE><PRE> this._postLayout();
</PRE><P>};
</P><P>/**
</P><PRE>* get the items to be laid out
* you may want to skip over some items
* @param {Array} items
* @returns {Array} items
*/
</PRE><P>proto._getItemsForLayout = function( items ) {
</P><PRE> return items.filter( function( item ) {
   return !item.isIgnored;
 });
</PRE><P>};
</P><P>/**
</P><PRE>* layout items
* @param {Array} items
* @param {Boolean} isInstant
*/
</PRE><P>proto._layoutItems = function( items, isInstant ) {
</P><PRE> this._emitCompleteOnItems( 'layout', items );
</PRE><PRE> if ( !items || !items.length ) {
   // no items, emit event with empty array
   return;
 }
</PRE><PRE> var queue = [];
</PRE><PRE> items.forEach( function( item ) {
   // get x/y object from method
   var position = this._getItemLayoutPosition( item );
   // enqueue
   position.item = item;
   position.isInstant = isInstant || item.isLayoutInstant;
   queue.push( position );
 }, this );
</PRE><PRE> this._processLayoutQueue( queue );
</PRE><P>};
</P><P>/**
</P><PRE>* get item layout position
* @param {Outlayer.Item} item
* @returns {Object} x and y position
*/
</PRE><P>proto._getItemLayoutPosition = function( /* item */ ) {
</P><PRE> return {
   x: 0,
   y: 0
 };
</PRE><P>};
</P><P>/**
</P><PRE>* iterate over array and position each item
* Reason being - separating this logic prevents 'layout invalidation'
* thx @paul_irish
* @param {Array} queue
*/
</PRE><P>proto._processLayoutQueue = function( queue ) {
</P><PRE> this.updateStagger();
 queue.forEach( function( obj, i ) {
   this._positionItem( obj.item, obj.x, obj.y, obj.isInstant, i );
 }, this );
</PRE><P>};
</P><P>// set stagger from option in milliseconds number
proto.updateStagger = function() {
</P><PRE> var stagger = this.options.stagger;
 if ( stagger === null || stagger === undefined ) {
   this.stagger = 0;
   return;
 }
 this.stagger = getMilliseconds( stagger );
 return this.stagger;
</PRE><P>};
</P><P>/**
</P><PRE>* Sets position of item in DOM
* @param {Outlayer.Item} item
* @param {Number} x - horizontal position
* @param {Number} y - vertical position
* @param {Boolean} isInstant - disables transitions
*/
</PRE><P>proto._positionItem = function( item, x, y, isInstant, i ) {
</P><PRE> if ( isInstant ) {
   // if not transition, just set CSS
   item.goTo( x, y );
 } else {
   item.stagger( i * this.stagger );
   item.moveTo( x, y );
 }
</PRE><P>};
</P><P>/**
</P><PRE>* Any logic you want to do after each layout,
* i.e. size the container
*/
</PRE><P>proto._postLayout = function() {
</P><PRE> this.resizeContainer();
</PRE><P>};
</P><P>proto.resizeContainer = function() {
</P><PRE> var isResizingContainer = this._getOption('resizeContainer');
 if ( !isResizingContainer ) {
   return;
 }
 var size = this._getContainerSize();
 if ( size ) {
   this._setContainerMeasure( size.width, true );
   this._setContainerMeasure( size.height, false );
 }
</PRE><P>};
</P><P>/**
</P><PRE>* Sets width or height of container if returned
* @returns {Object} size
*   @param {Number} width
*   @param {Number} height
*/
</PRE><P>proto._getContainerSize = noop;
</P><P>/**
</P><PRE>* @param {Number} measure - size of width or height
* @param {Boolean} isWidth
*/
</PRE><P>proto._setContainerMeasure = function( measure, isWidth ) {
</P><PRE> if ( measure === undefined ) {
   return;
 }
</PRE><PRE> var elemSize = this.size;
 // add padding and border width if border box
 if ( elemSize.isBorderBox ) {
   measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
     elemSize.borderLeftWidth + elemSize.borderRightWidth :
     elemSize.paddingBottom + elemSize.paddingTop +
     elemSize.borderTopWidth + elemSize.borderBottomWidth;
 }
</PRE><PRE> measure = Math.max( measure, 0 );
 this.element.style[ isWidth ? 'width' : 'height' ] = measure + 'px';
</PRE><P>};
</P><P>/**
</P><PRE>* emit eventComplete on a collection of items events
* @param {String} eventName
* @param {Array} items - Outlayer.Items
*/
</PRE><P>proto._emitCompleteOnItems = function( eventName, items ) {
</P><PRE> var _this = this;
 function onComplete() {
   _this.dispatchEvent( eventName + 'Complete', null, [ items ] );
 }
</PRE><PRE> var count = items.length;
 if ( !items || !count ) {
   onComplete();
   return;
 }
</PRE><PRE> var doneCount = 0;
 function tick() {
   doneCount++;
   if ( doneCount == count ) {
     onComplete();
   }
 }
</PRE><PRE> // bind callback
 items.forEach( function( item ) {
   item.once( eventName, tick );
 });
</PRE><P>};
</P><P>/**
</P><PRE>* emits events via EvEmitter and jQuery events
* @param {String} type - name of event
* @param {Event} event - original event
* @param {Array} args - extra arguments
*/
</PRE><P>proto.dispatchEvent = function( type, event, args ) {
</P><PRE> // add original event to arguments
 var emitArgs = event ? [ event ].concat( args ) : args;
 this.emitEvent( type, emitArgs );
</PRE><PRE> if ( jQuery ) {
   // set this.$element
   this.$element = this.$element || jQuery( this.element );
   if ( event ) {
     // create jQuery event
     var $event = jQuery.Event( event );
     $event.type = type;
     this.$element.trigger( $event, args );
   } else {
     // just trigger with type if no event available
     this.$element.trigger( type, args );
   }
 }
</PRE><P>};
</P><P>// -------------------------- ignore &amp; stamps -------------------------- //
</P><P>
/**
</P><PRE>* keep item in collection, but do not lay it out
* ignored items do not get skipped in layout
* @param {Element} elem
*/
</PRE><P>proto.ignore = function( elem ) {
</P><PRE> var item = this.getItem( elem );
 if ( item ) {
   item.isIgnored = true;
 }
</PRE><P>};
</P><P>/**
</P><PRE>* return item to layout collection
* @param {Element} elem
*/
</PRE><P>proto.unignore = function( elem ) {
</P><PRE> var item = this.getItem( elem );
 if ( item ) {
   delete item.isIgnored;
 }
</PRE><P>};
</P><P>/**
</P><PRE>* adds elements to stamps
* @param {NodeList, Array, Element, or String} elems
*/
</PRE><P>proto.stamp = function( elems ) {
</P><PRE> elems = this._find( elems );
 if ( !elems ) {
   return;
 }
</PRE><PRE> this.stamps = this.stamps.concat( elems );
 // ignore
 elems.forEach( this.ignore, this );
</PRE><P>};
</P><P>/**
</P><PRE>* removes elements to stamps
* @param {NodeList, Array, or Element} elems
*/
</PRE><P>proto.unstamp = function( elems ) {
</P><PRE> elems = this._find( elems );
 if ( !elems ){
   return;
 }
</PRE><PRE> elems.forEach( function( elem ) {
   // filter out removed stamp elements
   utils.removeFrom( this.stamps, elem );
   this.unignore( elem );
 }, this );
</PRE><P>};
</P><P>/**
</P><PRE>* finds child elements
* @param {NodeList, Array, Element, or String} elems
* @returns {Array} elems
*/
</PRE><P>proto._find = function( elems ) {
</P><PRE> if ( !elems ) {
   return;
 }
 // if string, use argument as selector string
 if ( typeof elems == 'string' ) {
   elems = this.element.querySelectorAll( elems );
 }
 elems = utils.makeArray( elems );
 return elems;
</PRE><P>};
</P><P>proto._manageStamps = function() {
</P><PRE> if ( !this.stamps || !this.stamps.length ) {
   return;
 }
</PRE><PRE> this._getBoundingRect();
</PRE><PRE> this.stamps.forEach( this._manageStamp, this );
</PRE><P>};
</P><P>// update boundingLeft / Top
proto._getBoundingRect = function() {
</P><PRE> // get bounding rect for container element
 var boundingRect = this.element.getBoundingClientRect();
 var size = this.size;
 this._boundingRect = {
   left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
   top: boundingRect.top + size.paddingTop + size.borderTopWidth,
   right: boundingRect.right - ( size.paddingRight + size.borderRightWidth ),
   bottom: boundingRect.bottom - ( size.paddingBottom + size.borderBottomWidth )
 };
</PRE><P>};
</P><P>/**
</P><PRE>* @param {Element} stamp
</PRE><UL><LI>/</LI></UL><P>proto._manageStamp = noop;
</P><P>/**
</P><PRE>* get x/y position of element relative to container element
* @param {Element} elem
* @returns {Object} offset - has left, top, right, bottom
*/
</PRE><P>proto._getElementOffset = function( elem ) {
</P><PRE> var boundingRect = elem.getBoundingClientRect();
 var thisRect = this._boundingRect;
 var size = getSize( elem );
 var offset = {
   left: boundingRect.left - thisRect.left - size.marginLeft,
   top: boundingRect.top - thisRect.top - size.marginTop,
   right: thisRect.right - boundingRect.right - size.marginRight,
   bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
 };
 return offset;
</PRE><P>};
</P><P>// -------------------------- resize -------------------------- //
</P><P>// enable event handlers for listeners
// i.e. resize -&gt; onresize
proto.handleEvent = utils.handleEvent;
</P><P>/**
</P><PRE>* Bind layout to window resizing
*/
</PRE><P>proto.bindResize = function() {
</P><PRE> window.addEventListener( 'resize', this );
 this.isResizeBound = true;
</PRE><P>};
</P><P>/**
</P><PRE>* Unbind layout to window resizing
*/
</PRE><P>proto.unbindResize = function() {
</P><PRE> window.removeEventListener( 'resize', this );
 this.isResizeBound = false;
</PRE><P>};
</P><P>proto.onresize = function() {
</P><PRE> this.resize();
</PRE><P>};
</P><P>utils.debounceMethod( Outlayer, 'onresize', 100 );
</P><P>proto.resize = function() {
</P><PRE> // don't trigger if size did not change
 // or if resize was unbound. See #9
 if ( !this.isResizeBound || !this.needsResizeLayout() ) {
   return;
 }
</PRE><PRE> this.layout();
</PRE><P>};
</P><P>/**
</P><PRE>* check if layout is needed post layout
* @returns Boolean
*/
</PRE><P>proto.needsResizeLayout = function() {
</P><PRE> var size = getSize( this.element );
 // check that this.size and size are there
 // IE8 triggers resize on body size change, so they might not be
 var hasSizes = this.size &amp;&amp; size;
 return hasSizes &amp;&amp; size.innerWidth !== this.size.innerWidth;
</PRE><P>};
</P><P>// -------------------------- methods -------------------------- //
</P><P>/**
</P><PRE>* add items to Outlayer instance
* @param {Array or NodeList or Element} elems
* @returns {Array} items - Outlayer.Items
</PRE><UL><LI>/</LI></UL><P>proto.addItems = function( elems ) {
</P><PRE> var items = this._itemize( elems );
 // add items to collection
 if ( items.length ) {
   this.items = this.items.concat( items );
 }
 return items;
</PRE><P>};
</P><P>/**
</P><PRE>* Layout newly-appended item elements
* @param {Array or NodeList or Element} elems
*/
</PRE><P>proto.appended = function( elems ) {
</P><PRE> var items = this.addItems( elems );
 if ( !items.length ) {
   return;
 }
 // layout and reveal just the new items
 this.layoutItems( items, true );
 this.reveal( items );
</PRE><P>};
</P><P>/**
</P><PRE>* Layout prepended elements
* @param {Array or NodeList or Element} elems
*/
</PRE><P>proto.prepended = function( elems ) {
</P><PRE> var items = this._itemize( elems );
 if ( !items.length ) {
   return;
 }
 // add items to beginning of collection
 var previousItems = this.items.slice(0);
 this.items = items.concat( previousItems );
 // start new layout
 this._resetLayout();
 this._manageStamps();
 // layout new stuff without transition
 this.layoutItems( items, true );
 this.reveal( items );
 // layout previous items
 this.layoutItems( previousItems );
</PRE><P>};
</P><P>/**
</P><PRE>* reveal a collection of items
* @param {Array of Outlayer.Items} items
*/
</PRE><P>proto.reveal = function( items ) {
</P><PRE> this._emitCompleteOnItems( 'reveal', items );
 if ( !items || !items.length ) {
   return;
 }
 var stagger = this.updateStagger();
 items.forEach( function( item, i ) {
   item.stagger( i * stagger );
   item.reveal();
 });
</PRE><P>};
</P><P>/**
</P><PRE>* hide a collection of items
* @param {Array of Outlayer.Items} items
*/
</PRE><P>proto.hide = function( items ) {
</P><PRE> this._emitCompleteOnItems( 'hide', items );
 if ( !items || !items.length ) {
   return;
 }
 var stagger = this.updateStagger();
 items.forEach( function( item, i ) {
   item.stagger( i * stagger );
   item.hide();
 });
</PRE><P>};
</P><P>/**
</P><PRE>* reveal item elements
* @param {Array}, {Element}, {NodeList} items
*/
</PRE><P>proto.revealItemElements = function( elems ) {
</P><PRE> var items = this.getItems( elems );
 this.reveal( items );
</PRE><P>};
</P><P>/**
</P><PRE>* hide item elements
* @param {Array}, {Element}, {NodeList} items
*/
</PRE><P>proto.hideItemElements = function( elems ) {
</P><PRE> var items = this.getItems( elems );
 this.hide( items );
</PRE><P>};
</P><P>/**
</P><PRE>* get Outlayer.Item, given an Element
* @param {Element} elem
* @param {Function} callback
* @returns {Outlayer.Item} item
*/
</PRE><P>proto.getItem = function( elem ) {
</P><PRE> // loop through items to get the one that matches
 for ( var i=0; i &lt; this.items.length; i++ ) {
   var item = this.items[i];
   if ( item.element == elem ) {
     // return item
     return item;
   }
 }
</PRE><P>};
</P><P>/**
</P><PRE>* get collection of Outlayer.Items, given Elements
* @param {Array} elems
* @returns {Array} items - Outlayer.Items
*/
</PRE><P>proto.getItems = function( elems ) {
</P><PRE> elems = utils.makeArray( elems );
 var items = [];
 elems.forEach( function( elem ) {
   var item = this.getItem( elem );
   if ( item ) {
     items.push( item );
   }
 }, this );
</PRE><PRE> return items;
</PRE><P>};
</P><P>/**
</P><PRE>* remove element(s) from instance and DOM
* @param {Array or NodeList or Element} elems
*/
</PRE><P>proto.remove = function( elems ) {
</P><PRE> var removeItems = this.getItems( elems );
</PRE><PRE> this._emitCompleteOnItems( 'remove', removeItems );
</PRE><PRE> // bail if no items to remove
 if ( !removeItems || !removeItems.length ) {
   return;
 }
</PRE><PRE> removeItems.forEach( function( item ) {
   item.remove();
   // remove item from collection
   utils.removeFrom( this.items, item );
 }, this );
</PRE><P>};
</P><P>// ----- destroy ----- //
</P><P>// remove and disable Outlayer instance
proto.destroy = function() {
</P><PRE> // clean up dynamic styles
 var style = this.element.style;
 style.height = <I>;</I>
 style.position = <I>;</I>
 style.width = <I>;</I>
 // destroy items
 this.items.forEach( function( item ) {
   item.destroy();
 });
</PRE><PRE> this.unbindResize();
</PRE><PRE> var id = this.element.outlayerGUID;
 delete instances[ id ]; // remove reference to instance by id
 delete this.element.outlayerGUID;
 // remove data for jQuery
 if ( jQuery ) {
   jQuery.removeData( this.element, this.constructor.namespace );
 }
</PRE><P>};
</P><P>// -------------------------- data -------------------------- //
</P><P>/**
</P><PRE>* get Outlayer instance from element
* @param {Element} elem
* @returns {Outlayer}
*/
</PRE><P>Outlayer.data = function( elem ) {
</P><PRE> elem = utils.getQueryElement( elem );
 var id = elem &amp;&amp; elem.outlayerGUID;
 return id &amp;&amp; instances[ id ];
</PRE><P>};
</P><P>
// -------------------------- create Outlayer class -------------------------- //
</P><P>/**
</P><PRE>* create a layout class
* @param {String} namespace
*/
</PRE><P>Outlayer.create = function( namespace, options ) {
</P><PRE> // sub-class Outlayer
 var Layout = subclass( Outlayer );
 // apply new options and compatOptions
 Layout.defaults = utils.extend( {}, Outlayer.defaults );
 utils.extend( Layout.defaults, options );
 Layout.compatOptions = utils.extend( {}, Outlayer.compatOptions  );
</PRE><PRE> Layout.namespace = namespace;
</PRE><PRE> Layout.data = Outlayer.data;
</PRE><PRE> // sub-class Item
 Layout.Item = subclass( Item );
</PRE><PRE> // -------------------------- declarative -------------------------- //
</PRE><PRE> utils.htmlInit( Layout, namespace );
</PRE><PRE> // -------------------------- jQuery bridge -------------------------- //
</PRE><PRE> // make into jQuery plugin
 if ( jQuery &amp;&amp; jQuery.bridget ) {
   jQuery.bridget( namespace, Layout );
 }
</PRE><PRE> return Layout;
</PRE><P>};
</P><P>function subclass( Parent ) {
</P><PRE> function SubClass() {
   Parent.apply( this, arguments );
 }
</PRE><PRE> SubClass.prototype = Object.create( Parent.prototype );
 SubClass.prototype.constructor = SubClass;
</PRE><PRE> return SubClass;
</PRE><P>}
</P><P>// ----- helpers ----- //
</P><P>// how many milliseconds are in each unit
var msUnits = {
</P><PRE> ms: 1,
 s: 1000
</PRE><P>};
</P><P>// munge time-like parameter into millisecond number
// '0.4s' -&gt; 40
function getMilliseconds( time ) {
</P><PRE> if ( typeof time == 'number' ) {
   return time;
 }
 var matches = time.match( /(^\d*\.?\d*)(\w*)/ );
 var num = matches &amp;&amp; matches[1];
 var unit = matches &amp;&amp; matches[2];
 if ( !num.length ) {
   return 0;
 }
 num = parseFloat( num );
 var mult = msUnits[ unit ] || 1;
 return num * mult;
</PRE><P>}
</P><P>// ----- fin ----- //
</P><P>// back in global
Outlayer.Item = Item;
</P><P>return Outlayer;
</P><P>}));
</P><P>/*!
</P><PRE>* Masonry v4.2.0
* Cascading grid layout library
* <A rel="nofollow" class="external free" href="http://masonry.desandro.com">http://masonry.desandro.com</A>
* MIT License
* by David DeSandro
*/
</PRE><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */ /*globals define, module, require */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( [
       'outlayer/outlayer',
       'get-size/get-size'
     ],
     factory );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     require('outlayer'),
     require('get-size')
   );
 } else {
   // browser global
   window.Masonry = factory(
     window.Outlayer,
     window.getSize
   );
 }
</PRE><P>}( window, function factory( Outlayer, getSize ) {
</P><P>// -------------------------- masonryDefinition -------------------------- //
</P><PRE> // create an Outlayer layout class
 var Masonry = Outlayer.create('masonry');
 // isFitWidth -&gt; fitWidth
 Masonry.compatOptions.fitWidth = 'isFitWidth';
</PRE><PRE> var proto = Masonry.prototype;
</PRE><PRE> proto._resetLayout = function() {
   this.getSize();
   this._getMeasurement( 'columnWidth', 'outerWidth' );
   this._getMeasurement( 'gutter', 'outerWidth' );
   this.measureColumns();
</PRE><PRE>   // reset column Y
   this.colYs = [];
   for ( var i=0; i &lt; this.cols; i++ ) {
     this.colYs.push( 0 );
   }
</PRE><PRE>   this.maxY = 0;
   this.horizontalColIndex = 0;
 };
</PRE><PRE> proto.measureColumns = function() {
   this.getContainerWidth();
   // if columnWidth is 0, default to outerWidth of first item
   if ( !this.columnWidth ) {
     var firstItem = this.items[0];
     var firstItemElem = firstItem &amp;&amp; firstItem.element;
     // columnWidth fall back to item of first element
     this.columnWidth = firstItemElem &amp;&amp; getSize( firstItemElem ).outerWidth ||
       // if first elem has no width, default to size of container
       this.containerWidth;
   }
</PRE><PRE>   var columnWidth = this.columnWidth += this.gutter;
</PRE><PRE>   // calculate columns
   var containerWidth = this.containerWidth + this.gutter;
   var cols = containerWidth / columnWidth;
   // fix rounding errors, typically with gutters
   var excess = columnWidth - containerWidth % columnWidth;
   // if overshoot is less than a pixel, round up, otherwise floor it
   var mathMethod = excess &amp;&amp; excess &lt; 1 ? 'round' : 'floor';
   cols = Math[ mathMethod ]( cols );
   this.cols = Math.max( cols, 1 );
 };
</PRE><PRE> proto.getContainerWidth = function() {
   // container is parent if fit width
   var isFitWidth = this._getOption('fitWidth');
   var container = isFitWidth ? this.element.parentNode : this.element;
   // check that this.size and size are there
   // IE8 triggers resize on body size change, so they might not be
   var size = getSize( container );
   this.containerWidth = size &amp;&amp; size.innerWidth;
 };
</PRE><PRE> proto._getItemLayoutPosition = function( item ) {
   item.getSize();
   // how many columns does this brick span
   var remainder = item.size.outerWidth % this.columnWidth;
   var mathMethod = remainder &amp;&amp; remainder &lt; 1 ? 'round' : 'ceil';
   // round if off by 1 pixel, otherwise use ceil
   var colSpan = Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );
   colSpan = Math.min( colSpan, this.cols );
   // use horizontal or top column position
   var colPosMethod = this.options.horizontalOrder ?
     '_getHorizontalColPosition' : '_getTopColPosition';
   var colPosition = this[ colPosMethod ]( colSpan, item );
   // position the brick
   var position = {
     x: this.columnWidth * colPosition.col,
     y: colPosition.y
   };
   // apply setHeight to necessary columns
   var setHeight = colPosition.y + item.size.outerHeight;
   var setMax = colSpan + colPosition.col;
   for ( var i = colPosition.col; i &lt; setMax; i++ ) {
     this.colYs[i] = setHeight;
   }
</PRE><PRE>   return position;
 };
</PRE><PRE> proto._getTopColPosition = function( colSpan ) {
   var colGroup = this._getTopColGroup( colSpan );
   // get the minimum Y value from the columns
   var minimumY = Math.min.apply( Math, colGroup );
</PRE><PRE>   return {
     col: colGroup.indexOf( minimumY ),
     y: minimumY,
   };
 };
</PRE><PRE> /**
  * @param {Number} colSpan - number of columns the element spans
  * @returns {Array} colGroup
  */
 proto._getTopColGroup = function( colSpan ) {
   if ( colSpan &lt; 2 ) {
     // if brick spans only one column, use all the column Ys
     return this.colYs;
   }
</PRE><PRE>   var colGroup = [];
   // how many different places could this brick fit horizontally
   var groupCount = this.cols + 1 - colSpan;
   // for each group potential horizontal position
   for ( var i = 0; i &lt; groupCount; i++ ) {
     colGroup[i] = this._getColGroupY( i, colSpan );
   }
   return colGroup;
 };
</PRE><PRE> proto._getColGroupY = function( col, colSpan ) {
   if ( colSpan &lt; 2 ) {
     return this.colYs[ col ];
   }
   // make an array of colY values for that one group
   var groupColYs = this.colYs.slice( col, col + colSpan );
   // and get the max value of the array
   return Math.max.apply( Math, groupColYs );
 };
</PRE><PRE> // get column position based on horizontal index. #873
 proto._getHorizontalColPosition = function( colSpan, item ) {
   var col = this.horizontalColIndex % this.cols;
   var isOver = colSpan &gt; 1 &amp;&amp; col + colSpan &gt; this.cols;
   // shift to next row if item can't fit on current row
   col = isOver ? 0 : col;
   // don't let zero-size items take up space
   var hasSize = item.size.outerWidth &amp;&amp; item.size.outerHeight;
   this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;
</PRE><PRE>   return {
     col: col,
     y: this._getColGroupY( col, colSpan ),
   };
 };
</PRE><PRE> proto._manageStamp = function( stamp ) {
   var stampSize = getSize( stamp );
   var offset = this._getElementOffset( stamp );
   // get the columns that this stamp affects
   var isOriginLeft = this._getOption('originLeft');
   var firstX = isOriginLeft ? offset.left : offset.right;
   var lastX = firstX + stampSize.outerWidth;
   var firstCol = Math.floor( firstX / this.columnWidth );
   firstCol = Math.max( 0, firstCol );
   var lastCol = Math.floor( lastX / this.columnWidth );
   // lastCol should not go over if multiple of columnWidth #425
   lastCol -= lastX % this.columnWidth ? 0 : 1;
   lastCol = Math.min( this.cols - 1, lastCol );
   // set colYs to bottom of the stamp
</PRE><PRE>   var isOriginTop = this._getOption('originTop');
   var stampMaxY = ( isOriginTop ? offset.top : offset.bottom ) +
     stampSize.outerHeight;
   for ( var i = firstCol; i &lt;= lastCol; i++ ) {
     this.colYs[i] = Math.max( stampMaxY, this.colYs[i] );
   }
 };
</PRE><PRE> proto._getContainerSize = function() {
   this.maxY = Math.max.apply( Math, this.colYs );
   var size = {
     height: this.maxY
   };
</PRE><PRE>   if ( this._getOption('fitWidth') ) {
     size.width = this._getContainerFitWidth();
   }
</PRE><PRE>   return size;
 };
</PRE><PRE> proto._getContainerFitWidth = function() {
   var unusedCols = 0;
   // count unused columns
   var i = this.cols;
   while ( --i ) {
     if ( this.colYs[i] !== 0 ) {
       break;
     }
     unusedCols++;
   }
   // fit container to columns that have been used
   return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;
 };
</PRE><PRE> proto.needsResizeLayout = function() {
   var previousWidth = this.containerWidth;
   this.getContainerWidth();
   return previousWidth != this.containerWidth;
 };
</PRE><PRE> return Masonry;
</PRE><P>}));
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Marburg_Model skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Marburg/Model</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><DIV class="header_wrapper"><DIV class="menu_wrapper" role="navigation" aria-label="Main Menu"><UL class="menu"><LI><A href="#">Team ▾</A></LI><LI><A href="/Team:Marburg/Team">Team</A></LI><LI><A href="/Team:Marburg/Collaborations">Collaborations</A></LI><LI><A href="/Team:Marburg/Attributions">Attributions</A></LI></UL><LI><A href="#">Project ▾</A></LI><LI><A href="/Team:Marburg/Description">Description</A></LI><LI><A href="/Team:Marburg/Design">Design</A></LI><LI><A href="/Team:Marburg/Experiments">Experiments</A></LI><LI><A href="/Team:Marburg/Notebook">Notebook</A></LI><LI><A href="/Team:Marburg/InterLab">InterLab</A></LI><LI><A href="/Team:Marburg/Model">Model</A></LI><LI><A href="/Team:Marburg/Results">Results</A></LI><LI><A href="/Team:Marburg/Demonstrate">Demonstrate</A></LI><LI><A href="/Team:Marburg/Measurement">Measurement</A></LI><LI><A href="/Team:Marburg/Labautomation">Labautomation</A></LI><LI><A href="#">Parts ▾</A></LI><LI><A href="/Team:Marburg/Parts">Parts Overview</A></LI><LI><A href="/Team:Marburg/Basic_Part">Basic Parts</A></LI><LI><A href="/Team:Marburg/Composite_Part">Composite Part</A></LI><LI><A href="/Team:Marburg/Part_Collection">Part Collection</A></LI><LI><A href="/Team:Marburg/Improve">Improve</A></LI><LI><A href="/Team:Marburg/Safety">Safety</A></LI><LI><A href="#">Human Practices ▾</A></LI><LI><A href="/Team:Marburg/Human_Practices">Human Practices</A></LI><LI><A href="/Team:Marburg/Public_Engagement">Public Engagement</A></LI><LI><A href="#">Awards ▾</A></LI><LI><A href="/Team:Marburg/Human_Practices">Integrated Human Practices</A></LI><LI><A href="/Team:Marburg/Public_Engagement">Education and Public Engagement</A></LI><LI><A href="/Team:Marburg/Model">Model</A></LI><LI><A href="/Team:Marburg/Measurement">Measurement</A></LI><LI><A href="/Team:Marburg/Basic_Part">Best New Basic Part</A></LI><LI><A href="/Team:Marburg/Composite_Part">Best New Composite Part</A></LI><LI><A href="/Team:Marburg/Part_Collection">Best Part Collection</A></LI><LI><A href="/Team:Marburg/Software">Software</A></LI><LI><A href="https://igem.org/2018_Judging_Form?id=2560">Judging Form</A></LI></DIV></DIV><MAIN><DIV class="titleWrapper"><DIV class="title">Modeling</DIV></DIV><ARTICLE><P><I>It is also a good rule not to put too much confidence in
 experimental results until they have been confirmed by
 Theory.</I><B>   -- Sir Arthur Eddington</B></P>
        This wordplay by Sir Arthur Eddington highlights the importance of modeling in every discipline of science. Imagine bringing the predictability of physics, the exact measures of chemistry, and the rationality of maths into synthetic biology! The last decades have seen great strides towards this vision, but we still see  potential for future improvement. We want to see this dream become a reality in the near future through modeling. 
        Unlike the other sciences, biology has just begun realizing the vast potential of modeling. 
        
        With our model, we want to join a new generation of interdisciplinarity scientists working at, and exploring on the boundaries of what synthetic biology can deliver.
        With time nowadays being more precious than ever, we centred our project around saving it, streamlining processes and making these advances accessible to the research community.
        
        We accelerated processes in many regards, but the most efficient way to save time is to know beforehand which experiments to conduct. The predictive powers needed for that can be harnessed by computer-based modeling.
        We harvested this prediction power with two independent modeling approaches, one predicting the metabolism of Vibrio Natriegens and the other designing an enzyme capable of a novel reaction,  decarboxylating malate to 3-hydroxypropionic acid (<DFN data-info="3-hydroxypropionic acid">3HPA</DFN>).   
<DIV style="display: inline-block; align-items: center;"><DIV style="float:left; width: 49%; text-align: justify;"><H2>Metabolic Model</H2>


           In order to be able to fine-tune synthetic pathways and utilize the well-characterized parts of our cloning toolbox to its fullest potential, we need a model which gives useful predictions of metabolic fluxes. 
	We decided to use a reaction kinetic based model and investigate the enzymes that we have the most control over – the ones that we introduce to the organism. 
	With the help of our model we are able to obtain a detailed insight into how the concentration of <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> and <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> change the product concentration. 
	To improve the precision of our model, we also took the metabolic fluxes that the educt of our pathway is a part of into consideration.
	We applied this data to the Marburg Toolbox and calculated what the optimal promotors are for our metabolic engineering efforts.   
	We could directly implement this data into our synthetic pathway to produce <DFN data-info="3-hydroxypropionic acid">3HPA</DFN>. 
	
	Using the thereby consolidated theoretical knowledge we can complete the Design-Build-Test-Learn cycle for our metabolic engineering project and use it to iteratively improve our project. 
	With the prediction power of our model, we not only save a lot of time in the lab but we manage to improve the efficiency and productivity, the skill ceiling of our pathway.

        </DIV><DIV style="float:right; width: 49%; text-align: justify;"><H2>Structural model</H2>
            The pathway we used for production of     <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> 
            (<A href="https://2018.igem.org/Team:Marburg/Description">for details see the description part of the metabolic engineering subgroup</A>)
             has been explored previously and is based on a combination of known reactions and known enzymes. 
            Combination of different enzymes to make a synthetic pathway is a well-established method in the field of metabolic engineering, but limited to existing reactions and known enzymes. 
            With our structural model, we tried to build a new energetically more favorable pathway which was previously impossible.
            To accomplish that, we needed to implement a reaction with no known enzyme to catalyse it, the decarboxylation reaction of malate to <DFN data-info="3-hydroxypropionic acid">3HPA</DFN>.  
            To build this pathway we decided to engineer an enzyme capable of catalysing this reaction.
            We investigated the enzyme family of Carboxy-lyases and developed an idea on how to build a binding pocket catalysing this reaction.
            To evaluate if our binding pocket works, we performed electronic structure calculations. 
            With that, we were able to calculate the activation barrier of the reaction and therefore evaluate if it is possible for the reaction to take place. 
            To advance from a binding pocket to a full enzyme we evaluated <I>in silico</I> mutated versions of acetolactate decarboxylase (<DFN data-info="Acetolactate Decarboxylase">ALD</DFN>). 
            For evaluating which mutants perform best we used <DFN data-info="Molecular Dynamics">MD</DFN> simulations and checked how well the binding pocket assumed in the electronic structure calculations is represented in the simulations. 
            With the help of these <I>in silico</I> approaches we chose a mutant and tested it in the wetlab. 
        </DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">Metabolic model</DIV><DIV class="content"><H2>Kinetics of the Enzyme Catalysed Reactions for our Pathway</H2><H3>Introduction</H3><H3>Motivation</H3>

			For our pathway we need to introduce two new enzymes into <I>V. natriegens</I>.
			
			In order to do this inteligently we must understand the mechanism which makes our pathway work - and for that we need to model its enzyme catalysed reactions and their response to variable changes.
		<P>
		Acetyl-CoA carboxylase (<DFN data-info="Acetyl-CoA carboxylase">Acc</DFN>) catalyses the irreversible carboxylation of acetyl-CoA to malonyl-CoA.  
		Malonyl-CoA reductase (<DFN data-info="Malonyl-CoA reductase">Mcr</DFN>) catalyses two reactions,  the reduction of malonyl-CoA to malonate semi-aldehyde and its reduction to 3-hydroxipropionic acid (<DFN data-info="3-hydroxypropionic acid">3HPA</DFN>). <A href="https://2018.igem.org/Team:Marburg/Description">More about it can be learned here under metabolic engineering page</A>.
	</P><FIGURE style="float:center; width: 700px" class="center"><FIGCAPTION><B>Figure 1:</B> The pathway we integrated into <I>V. natriegens</I> The red reaction is catalysed by <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> - more about which can be learned <A href="https://2018.igem.org/Team:Marburg/Description">here under Metabolic Engineering.</A></FIGCAPTION></FIGURE><DIV class="collapsible"><DIV class="btn_expand">Foray into Reaction Kinetics</DIV><DIV class="content"><P>
			Reaction kinetics is the study of reaction rates of chemical processes. It investigates how different experimental conditions influence the speed of a reaction by transcribing that reaction's mechanism into a mathematical model.
		</P><P>
			There are many different experimental variables that have an impact on the reaction velocity as well as many possible mathematical representations of these impacts.
			
			For example important for chemical reactions is the collision of the reactant molecules – which depends on their concentrations. To model this, one mathematically formulates the rate equations 
			
			in which the rate r of a reaction is given by the product of its substrate concentrations and a reaction specific factor k. There are different kinds of reactions which are denoted by the exponents x and y.
			
			If a reaction mechanism is unknown one can experimentally determine reaction velocity and a rate constant for different substrate concentrations to acquire information about it.
		</P><P>
			Some reactions are however catalysed by enzymes not only dependant on the substrate concentration but also catalysed by enzymes.
			
			One of the best-known models which describes the rate of such reactions is Michaelis-Menten kinetics.
		</P><P>
			To describe the rate of the enzymatic reactions Michaelis-Menten uses an equation relating the reaction velocity v to the concentration of the substrate as well as enzyme specific variables K<SUB>m</SUB> and k<SUB>cat</SUB>. K<SUB>m</SUB> is the substrate concentration at which the reaction rate is half of its possible maximum and has to be acquired experimentally – k<SUB>cat</SUB> is the catalytic rate – also acquired through experiment – that is the number of converted substrate molecules per enzyme molecule per second.
		</P><P>
			There are different possible mechanisms for enzyme kinetics.
			
			Some incorporate reversible or irreversible inhibition - whereby the velocity of the Michaelis-Menten equations is moderated by the inhibitor concentration and an inhibition enzyme.
			
			Other describe reactions with multiple substrates like the ternary-complex mechanism or the Ping-pong mechanism.
			In these the reaction rate is also dependant on the concentration of substrates and their reaction affinity with the enzyme.
			Multi-substrate reactions have additional Michaelis constants for the additional substrates.
			
			If these constants are sufficiently small a multi substrate reaction can be approximated as a single substrate one.
		</P></DIV></DIV><P>
		We use Michaelis-Menten style reaction kinetics to describe the rate of the enzyme mediated reactions.
		
		Most experimental enzyme measurements focus on getting the Michaelis constant K<SUB>m</SUB>. To use this we need the derivation of Michaelis-Menten kinetics which uses the quasi-steady-state approximation. This is the assumption that the concentration of the enzyme-substrate complex does not change whilst the reaction is going.
	</P><P>
		The equations of the reaction rates are Ordinary Differential Equations – these can be solved through integration to get the product concentration at all time points. For this we use Matlab – a numerical computing environment – which allows us to solve the <DFN data-info="Ordinary Differential Equations">ODE's</DFN> and plot the solutions as well as write algorithms with which to analyse the model further.
	</P><H3>Methods</H3><P>
		To start analysing our pathway we first need to know the K<SUB>m</SUB> and k<SUB>cat</SUB> values of the enzymes involved. 
	</P><P>
		For <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> we encountered a lack of exact enzyme measurements within a sufficiently similar organism. 
		However, we found ranges in which they could be expected. This would allow us to model the system and then put it through an error sensitivity analysis.
	</P><DIV class="center wrapper"><TABLE style=" width:70%" cellspacing="5" border="1" class="horzcent"><CAPTION><B>Table 1:</B> Enzyme values used in the model</CAPTION><TBODY><TR><TH>Enzyme</TH><TH>Organism</TH><TH>K<SUB>m</SUB> in μM</TH><TH>k<SUB>cat</SUB> in s<SUP>-1</SUP></TH><TH>Source</TH></TR><TR><TD>Acc</TD><TD><I>E. coli</I></TD><TD>200 - 400</TD><TD>1 - 5</TD><TD><A href="https://www.pnas.org/content/pnas/68/7/1512.full.pdf"><ABBR title="R. R. Fall, A. M. Nervi, A. W. Alberts, P. R. Vagelos. Acetyl CoA Carboxylase: Isolation and Characterization of Native Biotin Carboxyl Carrier Protein. 1971.">Fall <I>et al.</I> 1971</ABBR></A></TD></TR><TR><TD>Mcr</TD><TD><I>Chloroflexus aurantiacus</I></TD><TD>41.7</TD><TD>7.81</TD><TD><A href="http://doi.org/10.1016/j.jbiotec.2011.06.008"><ABBR title="C. Rathnasingha, S. M. Raj, Y. Lee, C. Catherinea, S. Ashoka, S. Park . 2012. Production of 3-hydroxypropionic acid via malonyl-CoA pathway using recombinant Escherichia coli strains. 2012.">Rathnasingha <I>et al.</I> 2012</ABBR></A><A href="http://doi.org/10.1016/j.jbiotec.2011.06.008"><ABBR title="J. K. Rogers, G. M. Church. Production of 3-hydroxypropionic acid via malonyl-CoA pathway using recombinant Escherichia coli strains. 2016.">Rogers <I>et al.</I> 2016</ABBR></A></TD></TR></TBODY></TABLE></DIV><P>
		For both <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> and <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> we chose a single substrate reaction. 
	</P><P>
		Purely reaction rate based Michaelis-Menten kinetics are derived using the law of mass action. This results for the single substrate mechanism four non-linear <DFN data-info="Ordinary Differential Equations">ODE's</DFN>.
	</P><P>
		We decided to use the derivation through quasi-steady-state approximation. Most experimental measurements on reactions use the approach of measuring reaction velocity in dependence of the enzyme concentration. Hereby the Michaelis constant K<SUB>m</SUB> – with which the reaction velocity is half of the maximal velocity – as well as the catalytic constant k<SUB>cat</SUB>.
	</P><P>
		The initial and therefore maximal velocity of a reaction is a product of the initial enzyme concentration and the catalytic constant k<SUB>cat</SUB> which quantifies the number of catalysed product molecules by an enzyme molecule per time. This allows us to rewrite the equation.
	</P><P>
		So K<SUB>m</SUB> and k<SUB>cat</SUB>  can then be used to make the velocity of a reaction only dependant on the enzyme and substrate concentrations. Here our resulting equations for both reactions:
	</P><DIV style="display: inline-block; align-items: center;"><DIV style="float:left; width: 49%; text-align: justify;"><P>
			Since we were not only interested in a qualitative but also a quantitative analysis, we needed to find realistic additional and secondary fluxes for the pathway we used for our metabolic engineering efforts in <I>V. natriegens</I>.
			
			These fluxes into and from Acetyl-CoA were measured in <I>V. natriegens</I> by <SUP>13</SUP>C labelled Metabolic Flux Analysis. <A href="http://doi.org/10.1016/j.ymben.2017.10.008"><ABBR title="Metabolism of the fast-growing bacterium Vibrio natriegens elucidated by 13C metabolic flux analysis by Christopher P.Long, Jacqueline E.Gonzalez, Robert M.Cipolla, Maciek R.Antoniewicz">(Long <I>et al.</I>2017)</ABBR></A></P></DIV><DIV style="float:right; width: 49%; text-align: justify;"><FIGURE><FIGCAPTION style="float: right;"><B>Figure 2:</B><SUP>13</SUP>C elucidated fluxes for the metabolism of <I>V. natriegens </I><A href="http://doi.org/10.1016/j.ymben.2017.10.008"><ABBR title="Metabolism of the fast-growing bacterium Vibrio natriegens elucidated by 13C metabolic flux analysis by C. P. Long, J. E. Gonzalez, R. M. Cipolla, M. R. Antoniewicz">(Long <I>et al.</I>2017)</ABBR></A></FIGCAPTION></FIGURE></DIV></DIV><DIV class="collapsible"><DIV class="btn_expand"><SUP>13</SUP>C elucidated flux data we use</DIV><DIV class="content"><TABLE style="width:100%" cellspacing="5" border="1"><CAPTION><B>Table 2:</B><SUP>13</SUP>C elucidated flux data important to us<A href="http://doi.org/10.1016/j.ymben.2017.10.008"><ABBR title="Metabolism of the fast-growing bacterium Vibrio natriegens elucidated by 13C metabolic flux analysis by Christopher P.Long, Jacqueline E.Gonzalez, Robert M.Cipolla, Maciek R.Antoniewicz">(Long <I>et al.</I>2017)</ABBR></A></CAPTION><TBODY><TR><TH>Reaction</TH><TH>Normed to glucose uptake</TH><TH>Flux in mmol/h/g<SUB>DW</SUB></TH></TR><TR><TD>Glucose Uptake</TD><TD>100</TD><TD>21.4</TD></TR><TR><TD>Pyr -&gt; AcCoA</TD><TD>110</TD><TD>23.5</TD></TR><TR><TD>AcCoA -&gt; Acetate</TD><TD>69</TD><TD>14.8</TD></TR><TR><TD>AcCoA - &gt; Cit cyclus</TD><TD>17</TD><TD>3.6</TD></TR></TBODY></TABLE></DIV></DIV><P>
		The exact Matlab scripts that we use can be found in dropdowns.
	</P><DIV class="collapsible"><DIV class="btn_expand">Basic Matlab Scripts</DIV><DIV class="content"><DIV class="collapsible"><DIV class="btn_expand">ODE's as a Matlab Function</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">function</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> [dS] = Mechanism(~, S, E, K, k)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Function containing reaction velocities</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% meant to be integrated through ode15s or similar</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">S1 = S(1); S2 = S(2); S3 = S(3);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">E1 = E(1); E2 = E(2);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">K1 = K(1); K2 = K(2);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">k1 = k(1); k2 = k(2);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">v1 = (k1*E1*S1)/(K1+S1);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">v2 = (k2*E2*S2)/(K2+S2);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Secondary flows</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">F0 = 6.4;  </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%into Acetyl-CoA</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">F1 = 5;    </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%out of Maylonyl-CoA</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">dS1 = F0 -F1;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">dS2 = +v1 -v2 -F2;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">dS3 = +v2;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">dS(1,:) = dS1;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">dS(2,:) = dS2;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">dS(3,:) = dS3;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN></P></DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">Declaring Values</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Creates a structure array with the inputed values that is imported into</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% other functions and scripts</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">S = [6.4 0 0]; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Substrate Conc.</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">E = [10 10]; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Enzyme Conc.</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">K = [400 41.7]; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Km</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">k = [5 7.8]; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% kcat</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">tspan = [0 60];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">options = odeset(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'NonNegative'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,1:3);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Values.title        = </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values for KinMod SV'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Values.date         = datetime;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Values.S            = S;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Values.E            = E;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Values.K            = K;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Values.k            = k;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Values.tspan        = tspan;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Values.options      = options;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">save(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values.mat'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN></P></DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">ODE solving and Production</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Calculates Production through time by solving Mechnism with ode15s</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">load(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values.mat'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">[t,y] = ode15s(@(t,y)Mechanism(t,y,Values.E,Values.K,Values.k), Values.tspan, Values.S, Values.options);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">figure</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">plot(t, y);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">xlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Time in s'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">ylabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Concentration in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">title(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Simple Normed Version'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">legend(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'AcetylCoA'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">, </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'MalonylCoA'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">, </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HP'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">set(legend,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Location'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'northwest'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN></P></DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">Utility Functions</DIV><DIV class="content"><DIV class="collapsible"><DIV class="btn_expand">Variation of one variable</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">function</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> [inputs, results] = VarOf1Var(Bounds,Scalation,Function,Values,Index)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%Variation of one variable in a ODE Function [Values manuel input still needed]</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%{</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Inputs different values for a variable into a ODE function and returns</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    a matrix of the results as well as imput scala</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    these can then be plotted against each other</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Scalation = 0.1 means values looked at in 0.1 steps</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Function gives ode solver as well as function it should solve</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    ODE function should be imputed with a &quot;variable&quot; in place of the variable to be</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    variied</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Values struct file with other values the function uses, needs to be</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    adressed in Function</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Index is index of ODE return vector that needs to be looked at</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    this allows looking at different metabolites</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%}  </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">inputs = [Bounds(1):Scalation:Bounds(2)];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">results = [];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> i = inputs</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        Y = ODE(i);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">       </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%results(1,i) = Y;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        results = [results Y];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">function</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> [Y] = ODE(i)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    variable = i;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    [tout,yout] = eval(Function);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    N = [tout,yout];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    Y = N(end,Index);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;"> </SPAN></P></DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">Variation of two variables</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">function</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> [inputs1, inputs2, results] = VarOf2Var(Bounds1,Bounds2,Scalation1,Scalation2,Function,Values,Index)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%Variation of one variable in a ODE Function [Values manuel input still needed]</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%{</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Inputs different values for a variable into a ODE function and returns</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    a matrix of the results as well as imput scala</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    these can then be plotted against each other</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Scalation = 0.1 means values looked at in 0.1 steps</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Function gives ode solver as well as function it should solve</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    ODE function should be imputed with a &quot;var1&quot; in place of the first</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    variable to be variied</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    var1 is row index var2 is column inedx</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Values struct file with other values the function uses, needs to be</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    adressed in Function</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    Index is index of ODE return vector that needs to be looked at</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    this allows looking at different metabolites</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%}  </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">inputs1 = [Bounds1(1):Scalation1:Bounds1(2)];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">inputs2 = [Bounds2(1):Scalation2:Bounds2(2)];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%   Can add option for inputing specific values instead of bounds</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%{</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">Could add following to chose between bounds and single values</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    needs finishing</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">if length(Bounds1) == 2</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    inputs1 = [Bounds1(1):Scalation1:Bounds1(2)];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">else</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    continue</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">if length(Bounds2) == 2</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    inputs2 = [Bounds2(1):Scalation2:Bounds2(2)];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">else</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">    continue</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%}</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">results = [];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> i = inputs1</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    Yrow = [];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> j = inputs2</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        Y = ODE(i,j);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        Yrow = [Yrow, Y]; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%Yrow is row vector of column variable outputs</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    results = [results; Yrow];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">function</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> [Y] = ODE(i,j)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    var1 = i;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    var2 = j;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    [tout,yout] = eval(Function);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    N = [tout,yout];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    Y = N(end,Index);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;"> </SPAN></P></DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">Getting 95% of leveling value</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">function</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> [x] = FindXforLevel95(Y,s)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%   Takes Vektor Y and gives index x for which value is 95% of last value</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%   in vector</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%   also takes index scalation s to give back real value and not index for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%   when index isn't real value</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">level = Y(end);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">level95 = level/100*95;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">l = length(Y);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> i = 1:1:l</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">if</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> Y(i) &gt;= level95</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        x = i./s;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">       </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">break</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">else</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">       </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">continue</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN></P></DIV></DIV></DIV></DIV></DIV></DIV><P>
		We used matlabs intern stiff differential equation solver ode15s to integrate the <DFN data-info="Ordinary Differential Equations">ODE's</DFN> over a chosen period of time. 
		
		This mechanism we implemented into Matlab functions and scripts and its solution builds the basis of all further analysis. 	
	</P><P>
		With this we are able to elucidate the kinetics of our pathway while being able to vary things like enzyme concentration or the K<SUB>m</SUB> and k<SUB>cat</SUB>values of the enzymes.
		The production of <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> was calculated for a time period of 60 seconds for normalisation purposes and to limit the computational demand. 
	</P><FIGURE style="width: 500px" class="center wrapper"><FIGCAPTION><B>Figure 3:</B> In the above figure we calculated the production of <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> over a period of 60 seconds. The Acc and Mcr were both at 10μM Shown are also the concentrations over time of Acetyl-CoA and Malonyl-CoA.
			</FIGCAPTION></FIGURE><H3>Enzyme Concentration and Optimal Enzyme Ratio</H3><P>
		The first thing that we investigated to optimize our pathway is the dependence of the production of <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> to the expression levels of the enzymes. 
		
		To investigate the effects resulting from the changes in <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> and <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> concentrations we calculated the velocity of each reaction for various concentration values. 
	</P><DIV class="collapsible"><DIV class="btn_expand">Matlab scripts for the variation of the enzyme expression</DIV><DIV class="content"><DIV class="collapsible"><DIV class="btn_expand">Variation of both enzyme concentrations</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Enzyme Expression     General Comments</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%{</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">Value for 3HPA is taken 60 sec after Reaction begins</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">Other variables are taken from Values.mat by loading it and then using the</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">structure array called Values and giving it on to VarOf2Var</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%}</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%%  Getting Matrix</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Bounds1 = [0 100]; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%acc in µM</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Bounds2 = [0 50]; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%mcr in µM</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Scalation1 = 1;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Scalation2 = 0.1;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Function = </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'ode15s(@(t,y)Mechanism(t,y,[var1 var2],Values.K,Values.k), Values.tspan, Values.S, Values.options)'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">load(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values.mat'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Index = 4; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%3HPA %Index of resulting vector, can be used to &quot;sample&quot; different substances from it</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">[acc_scala, mcr_scala, results] = VarOf2Var(Bounds1,Bounds2,Scalation1,Scalation2,Function,Values,Index);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%%  Getting 95%Level Points</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%{</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">results consists of (i,j) where i is acc and j is mcr -&gt; results(acc,mcr)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">surf() uses [y, x] = size(Z) - so you need results.' (.' is transpose)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">95% points of mcr in loop over acc row vectors from results(acc,mcr)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%}</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">mcr_points = [];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">index_mcr_points = [];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">index_acc = 1:1:length(acc_scala);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> i = index_acc</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    index_mcr = 1:1:length(mcr_scala);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    index_mcr_point = FindXforLevel95(results(i,index_mcr),1);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%index_point corresponds to index after which mcr is &gt; 95% of level</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    index_mcr_points =  [index_mcr_points index_mcr_point];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    mcr_point = mcr_scala(index_mcr_point);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    mcr_points = [mcr_points mcr_point];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">points = nan(length(index_acc),length(index_mcr));</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> i = index_acc</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    point = results(i,index_mcr_points(i));</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">    points(i,index_mcr_points(i)) = point;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%%  Plotting Results</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">figure(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Name'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'EE variation'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">hold </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">on</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Allows for plot3 to be in same figure</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">s = surf(acc_scala,mcr_scala,results.'); </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Plots a surface</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">title(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA by enzyme expression variation'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">view(-45,30); </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Sets point of view</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">colorbar; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Adds a colorbar beside the figure</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">s.EdgeColor = </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'none'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Removes net from the plot surface</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">xlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'acc in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">ylabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'mcr in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">zlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%Plot Points</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">plot3(acc_scala,mcr_points,points,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'o'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Color'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'k'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%%  Linear fiting of Points and resulting formula and plot of it</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">P = polyfit(acc_scala,mcr_points,1);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">yfit = P(1)*acc_scala + P(2); </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Gets Slope and y-Intercept from polyfit</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">figure(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Name'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Linear fit'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">plot(acc_scala, yfit,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'r-.'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">title(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Linear fiting of saturation points'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">str = {</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Slope = '</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">+string(P(1)), </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'y-Intercept = '</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">+string(P(2))};</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">ylim = get(gca,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'ylim'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">xlim = get(gca,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'xlim'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">text(0.25,0.75,str,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Units'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'normalized'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">) </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Positions text</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">xlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'acc in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">ylabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Saturation point of mcr in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN></P></DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">Variation of one enzyme concentration whilst other is held</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Single Enzyme Expression</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%3HPA Value taken 60 sec after Reaction begin</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%The other enzyme expression is held as given in Values struct</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%% acc with held mcr</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Bounds = [0 1000];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Scalation = 1;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">load(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values.mat'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Index = 4;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">E_held = [10 25 50 75 100 150 200];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">figure(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Name'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'varied acc concentration with held mcr concentration'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> i_E_held = E_held</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        hold </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">on</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        Function = </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'ode15s(@(t,y)Mechanism(t,y,[variable '</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">+string(i_E_held)+</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'],Values.K,Values.k), Values.tspan, Values.S, Values.options);'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        [inputs, results] = VarOf1Var(Bounds,Scalation,Function,Values,Index);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        plot(inputs, results);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">title(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA by acc concentration with mcr concentration held (legend)'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">xlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'acc in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">ylabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">legend(string(E_held));</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%% mcr with held acc</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Bounds = [0 50];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Scalation = 0.1;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">load(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values.mat'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Index = 4;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">E_held = [10 25 50 75 100 150 200];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">figure(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Name'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'varied mcr concentration with held acc concentration'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> i_E_held = E_held</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        hold </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">on</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        Function = </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'ode15s(@(t,y)Mechanism(t,y,['</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">+string(i_E_held)+</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">' variable],Values.K,Values.k), Values.tspan, Values.S, Values.options);'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        [inputs, results] = VarOf1Var(Bounds,Scalation,Function,Values,Index);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        plot(inputs, results);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">title(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA by mcr concentration with acc concentration held (legend)'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">xlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'mcr in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">ylabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">legend(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'10'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">, </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'25'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">, </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'50'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">, </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'75'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">, </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'100'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">, </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'150'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">, </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'200'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN></P></DIV></DIV></DIV></DIV><DIV><FIGURE style="float:left; width: 550px" class="wrapper"><FIGCAPTION class="horzcent"><B>Figure 4:</B> 3HPA production for a variation of Acc concentration</FIGCAPTION></FIGURE><FIGURE style="float:right; width: 550px" class="wrapper"><FIGCAPTION class="horzcent"><B>Figure 5:</B> 3HPA production for a variation of Mcr concentration</FIGCAPTION></FIGURE></DIV><P>
			In Figure 4 we can observe the production of <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> for different <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> concentrations with a fixed mcr concentrations. We can see that for every <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> concentration there exists a point after which more <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> doesn't produce more <DFN data-info="3-hydroxypropionic acid">3HPA</DFN>. At this saturation point <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> becomes a rate limiting step.
		</P><P>
	  		In Figure 5 we can observe the production of <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> for different mcr concentrations with a fixed acc concentration. 
	  		In this figure we also notice even more clearly that there exists a saturation point after which more <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> doesn't increase the <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> production and <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> becomes the rate limiting step.
	  		
			The saturation point is reached much earlier than before, indicating that we need more acc expression than mcr. 	  	</P><DIV class="wrapper"><FIGURE style="width: 550px" class="left" class="wrapper"><FIGCAPTION class="horzcent"><B>Figure 6:</B> Simultaneous variation of both enzyme concentrations and Mcr saturation points</FIGCAPTION></FIGURE><FIGURE style="width: 550px" class="right" class="wrapper"><FIGCAPTION class="horzcent"><B>Figure 7:</B> Linear regression of Mcr saturation points</FIGCAPTION></FIGURE></DIV><P>
		As can be observed in Figure 4 and 5  more <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> than <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> is needed.
		This means that <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> is the prime rate limiting step of <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> production.
	</P><P>
		Furthermore we looked at the points of saturation of <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> after which a stronger expression of it would be negligible for better production. For this we utilize the points at which <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> reaches 95% of the value that it levels at. 
		We then plotted these saturation points as can bee seen in Figure 6. We performed a linear regression on these data points to determine their relation.
	</P><P>
		The slope of this linear regression corresponds to the <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> concentration divided by the <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN>concentration.
		We concluded that the ratio of enzyme expression of optimal efficiency is situated along this line and is 0.10416. We can then use this in the next step.
	</P><H3>Comparison of Relative Promoter Strengths</H3><P>
		Our Part Collection team has developed the Marburg toolbox featuring many different promoters.
		
		This well characterized toolbox made it possible for the metabolic engineering team to fine tune the enzyme expression ratios with the help of different promotor combinations.
		
		For this we needed to investigate which promoter combinations would lead to the best <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> production.
	</P><P>
		We needed to look at the optimal ratio (without looking solely for best prodcution) of the promoter pairs – so as not to burden the cell metabolism unnecessarily through the expression of uneccesary enzymes –  as well as get the promoter combination with the highest possible production. 
		To find a good balance these then needed to be combined to lessen the metabolic burden whilst preferably still keeping a high production.
	</P><P>
		To find the optimal ratio of promoter usage the point of saturation for <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> after which its increase doesn't lead to a noticeable increase in <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> production was used. It was assumed that the ratio of the expression of <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> and <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> at this point is optimal. 

	</P><P>
		The promoters are ordered from the strongest, J23100, whose relative strength has been normed as 1, to the weakest J23103. A representation of every relative strength can be found here.
	</P><P>
		Figure 8 shows all possible ratios relative similarity to the optimal. It has been normed to between 0 and 1. The values on the z-axis have been plotted on a logarithmic scale with exponent 100 so as to get a better sense of the scale broadness as well as to clearly recognise the best combination.
	</P><FIGURE style="float:center; width: 700px" class="center"><FIGCAPTION style="white-space:nowrap; overflow:hidden"><B>Figure 8:</B> Combinations of the relative promoter strengths have been compared to the optimal ratio</FIGCAPTION></FIGURE><P>
		For a theoretical optimal ratio of 0.10416 the best promoters are J23106 for <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> and J23109 for <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> with 97.981% similarity to the optimal ratio.
	</P><H3>Relative Promoter Production</H3><P>
		Since we only knew the relative strengths of promotors and no absolute values we do not know at which concentration the enzymes would be expressed. 
		The outcome of the model is changing with the order of magnitude at which the enzymes are expressed. 
		To investigate this we attributed different real enzyme concentrations to the normal promoter strengths. 
		Hereby we chose to associate the strongest promotor with different decimal magnitudes of enzyme epression and therefore concentration. 
		It has been assumed that the same promoter would have the same expression for  <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> and <DFN data-info="Malonyl-CoA reductase">Mcr</DFN>. And thus no combinations of different orders of magnitude have been shown.
	</P><P>
		As can be observed in the Graphs for 100nM as well as 100μM – for very small and very big concentrations – there occur boundary effects.
		
		These are caused by the fluxes to and from Acetyl-CoA as well as the K<SUB>m</SUB> and k<SUB>cat</SUB> values of both enzymes. Due to the similarity in the Figure for 1μM and Figure 10μM we concluded that all concentrations between the ones investigated are not influenced by boundary conditions.
		
		This range without effects from boundary conditions is not exhaustive and due to limited time we did not investigate it fully.
	</P><P>
		Since physiological enzyme concentrations also lie within the lower μM concentrations we strongly believe that our model is a reasonable approximation.
	</P><FIGURE style="width: 80%;" class="center" class="wrapper"><FIGCAPTION class="horzcent"><B>Figure 9:</B> Relative production for different assumed real enzyme concentrations</FIGCAPTION></FIGURE><H3>Impact of Acc variables</H3><P>
		Since we couldn't find trustworthy K<SUB>m</SUB> and k<SUB>cat</SUB> values for <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> – only a range within which the real ones probably are – it was important to look at the impact of the resulting error on the model.
	</P><P>
		For this reason we first looked at the impact of the simultaneous variation of <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> values for K<SUB>m</SUB> and k<SUB>cat</SUB> on the <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> production. Every <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> value was taken at 60 seconds from reaction begin for the solutions of <DFN data-info="Ordinary Differential Equations">ODE's</DFN> containing the corresponding values on the axes.
	</P><P>
		For the scripts we used to determine these changes click below:
	</P><DIV class="collapsible"><DIV class="btn_expand">Matlab scripts for the variation of the K<SUB>m</SUB> and k<SUB>cat</SUB> values for Acc</DIV><DIV class="content"><DIV class="collapsible"><DIV class="btn_expand">Variation of both values</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Single Enzyme Expression</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%3HPA Value taken 60 sec after Reaction begin</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%The other enzyme expression is held as given in Values struct</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%EE held for both at 10 µM</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%% acc with mcr values held</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%%{</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Bounds1 = [200 400]; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%Km in µM</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Bounds2 = [0 5]; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%kcat in s^-1</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Scalation1 = 10;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Scalation2 = 0.1;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Function = </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'ode15s(@(t,y)Mechanism(t,y,Values.E,[var1 Values.K(2)],[var2 Values.k(2)]), Values.tspan, Values.S, Values.options)'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">load(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values.mat'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Index = 4; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%3HPA %Index of resulting vector, can be used to &quot;sample&quot; different substances from it</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">[acc_scala, mcr_scala, results] = VarOf2Var(Bounds1,Bounds2,Scalation1,Scalation2,Function,Values,Index);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">figure(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Name'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'acc Km and kcat variation for held enzyme expression'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">s = surf(acc_scala,mcr_scala,results.'); </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Plots a surface</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">title(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA by acc Km and kcat variation for held enzyme expression'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">view(-45,30); </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Sets point of view</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">colorbar; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Adds a colorbar beside the figure</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">s.EdgeColor = </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'none'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">; </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">% Removes net from the plot surface</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">xlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Km in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">ylabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'kcat in s^{-1}'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">zlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%}</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN></P></DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">Variation of one value whilst other is held</DIV><DIV class="content"><P><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%%  acc with variation in only one</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%%{</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%   Km</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Bounds = [200 400];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Scalation = 10;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">load(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values.mat'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Index = 4;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">kcat_held = [1 2 3 5];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">figure(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Name'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'acc Km variation for different kcat'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> i_kcat_held = kcat_held</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        hold </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">on</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        Function = </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'ode15s(@(t,y)Mechanism(t,y,Values.E,[variable Values.K(2)],['</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">+string(i_kcat_held)+</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">' Values.k(2)]), Values.tspan, Values.S, Values.options);'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        [inputs, results] = VarOf1Var(Bounds,Scalation,Function,Values,Index);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        plot(inputs, results);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">title(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA by acc Km variation for different kcat (legend)'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">xlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'acc Km in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">ylabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">legend(string(kcat_held));</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%   kcat</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Bounds = [0 5];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Scalation = 0.1;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">load(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Values.mat'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Index = 4;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">Km_held = [200 250 300 400];</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">figure(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'Name'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">,</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'acc kcat variation for different Km'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">for</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> i_Km_held = Km_held</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        hold </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">on</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        Function = </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'ode15s(@(t,y)Mechanism(t,y,Values.E,['</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">+string(i_Km_held)+</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">' Values.K(2)],[variable Values.k(2)]), Values.tspan, Values.S, Values.options);'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">;</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        [inputs, results] = VarOf1Var(Bounds,Scalation,Function,Values,Index);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">        plot(inputs, results);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">   </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: blue;">end</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">title(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA by acc kcat variation for different Km (legend)'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">);</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">xlabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'acc kcat in s^{-1}'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">ylabel(</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: #a020f0;">'3HPA in µM'</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">)</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;">legend(string(Km_held));</SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: black;"> </SPAN><SPAN style="font-size: 10.0pt; font-family: 'Courier New'; color: forestgreen;">%}</SPAN></P></DIV></DIV></DIV></DIV><FIGURE style="float:center; width: 700px" class="center"><FIGCAPTION><B>Figure 10:</B> 3HPA production for the simultaneous variation of K<SUB>m</SUB> and k<SUB>cat values of Acc</SUB></FIGCAPTION></FIGURE><P>
		The bounds for K<SUB>m</SUB> and k<SUB>cat</SUB> which were plotted have been chosen as the likely ranges for the values as mentioned above.
	</P><DIV><FIGURE style="width: 550px" class="left"><FIGCAPTION><B>Figure 11:</B> Lienar 3HPA production dependancy on the k<SUB>cat</SUB> value of Acc</FIGCAPTION></FIGURE><FIGURE style="width: 550px" class="right"><FIGCAPTION><B>Figure 12:</B> Logarithmic decrease of 3HPA production dependant on the K<SUB>m</SUB> value of Acc</FIGCAPTION></FIGURE></DIV><P>
		In figure 11 we are only changing the value of k<SUB>cat</SUB> to exactly how the model responds.
		Hereby we can observe linear increase in total <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> production.
	</P><P>
		In figure 12 we have looked at the variation of K<SUB>m</SUB> whilst k<SUB>cat</SUB> is constant.
		The change of the K<SUB>m</SUB> value causes a logarithmic decrease of total <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> production. Furthermore this decrease is greater with increasing k<SUB>cat</SUB>. This exacerbates the sensitivity of the model which is caused by k<SUB>cat</SUB> alone. The model is thus much more sensitive towards a change in k<SUB>cat</SUB> as opposed to a change in K<SUB>m</SUB>. Which means that it is more important for us to have a good approximation of <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> k<SUB>cat</SUB> values.
	</P><H3>Summary</H3><P>
		With our metabolic model we investigated the enzyme kinetics of the pathway that we introduced into <I>V. natriegens</I>. Hereby we took into account all pathways that lead to and from Acetyl-CoA, the starting point of our pathway.
	</P><P>
		We examined the effects of enzyme concentration on the pathway and discerned that <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> is the prime rate limiting step and that there exists a linear relationship between <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> and the <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> saturation points.
	</P><P>
		With this, we were able compare the relative promoter strengths characterised in our Marburg Toolbox to find the best promoter combination.
		
		Additionally we looked at results of possible real enzyme concentrations for the relative promoter strengths.
		
		Hereby we ascertained that promoters J23106 for <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> and J23109 for <DFN data-info="Malonyl-CoA reductase">Mcr</DFN> had the best ratio of enzyme expression.
	</P><P>
		Furthermore we investigated the effects of uncertainty in the values of <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> and found that k<SUB>cat</SUB> has the highest impact on changes in the <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> production.
	</P><P>
		This is where our project showed its full potential because we were able to use the well-characterized Marburg Toolbox and calculate which promotor combination yields the most expression of <DFN data-info="3-hydroxypropionic acid">3HPA</DFN>. 
	</P><H3>Outlook</H3><P>
		To be able to increase the accuracy of our model, we need to improve the accuracy of the enzyme specific constants that we feed it with. 
		
		For this we need to calibrate the model with real measured concentrations.
	</P><P>
		To do this we implemented a biosensor with which to measure the production of <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> as well as Malonyl-CoA.
		<A href="https://2018.igem.org/Team:Marburg/Description">More about it can be learned here under Metabolic Engineering.</A></P><P>
		The bio sensor data can be used to measure production across time and this data can be used to first see which values for <DFN data-info="Acetyl-CoA carboxylase">Acc</DFN> are most compatible and then also be used to maybe look for better fitting mechanisms for the enzyme kinetics.
	</P><P>
		Going a step further we planed on adding a Metabolic Flux Analysis using a novel method which combines Flux Balance Analysis and <SUP>13</SUP>C labelled Metabolic Flux Analysis.
		
		With this method, we would not only be able to observe how well our pathway works, but also how our pathway influences the metabolism of the whole cell. 
		This would allow us to make statements with high accuracy not only how to make the best possible pathway to produce <DFN data-info="3-hydroxypropionic acid">3HPA</DFN>, but also how to do this in a way that is feasible for the organism. 
	</P></DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">Structural model</DIV><DIV class="content"><H2>Teach the rabbit to quack   Expanding the scope of metabolic engineering through novel enzyme engineering</H2><H3>Infrastructure</H3><P>
    We want to thank Prof. Kolb and Prof. Klebe for kindly providing us with the necessary infrastructure and software access to perform our calculations. 
    We also want to thank the Marc-2 and the HRZ for the computational resources.
    For our <DFN data-info="Quantum Mechanics">QM</DFN> calculations, we used the program GAUSSIAN09 and Chemcraft to set up our systems. 
    For a foray to how these kinds of calculations work, please click below. 

    </P><DIV class="collapsible"><DIV class="btn_expand">Foray to <DFN data-info="Quantum Mechanics">QM</DFN> Calculations</DIV><DIV class="content"><H3>Foray to <DFN data-info="Quantum Mechanics">QM</DFN> Calculations </H3><P><DFN data-info="Quantum Mechanics">QM</DFN> Calculations are the pinnacle of precision compared to all other methods used for calculating molecular systems, but this precision comes with very high computational costs. 
        All <DFN data-info="Quantum Mechanics">QM</DFN> calculation try to solve the Schroedinger Equation :
        <FIGURE style="height: 70px; float: top;"><FIGCAPTION>H Hamiltonian, Ψ Wavefunction , E Energy</FIGCAPTION></FIGURE>
        They do that by calculating the Hamiltonian of the system. 
        The Hamiltonian is an operator that if applied to the wavefunction of a system results in the same wavefunction times its energy.
        <DFN data-info="Quantum Mechanics">QM</DFN> calculations are characterized by two important things: the functional and the basis set used.  
        The functional is characterized by the way the Hamiltonian is calculated. 
        For all calculations that we do, we also need a starting point to describe orbitals or the density function (we will go into more detail to this later) and the basis set describes the number and type of the orbital functions that we use to calculate the system. 
    </P><H3>Born Oppenheimer Approximation</H3><P>
        A necessary assumption to use <DFN data-info="Quantum Mechanics">QM</DFN> methods is the Born Oppenheimer Approximation. 
        This is the approximation that due to the vast difference in speed between the electrons and the nucleus of the atoms the movement of both can be investigated apart from each other. 
        For <DFN data-info="Quantum Mechanics">QM</DFN> Methods this means that we only look at the movement of electrons and neglect the very slow movements of the nuclei when solving the Schroedinger Equation. 
    </P><H3>Functionals and Basis sets</H3><H3>Functionals</H3><P>
        There are two fundamentally different types of functionals, wave function based and density function based methods. 
        We only used density function based methods, to be precise B3LYP. 
        Density Function Theory (DFT) is centered not on the wavefunction but on the square of the wave function, i.e. the electron density.
        It is based on the theorem of Hohenberg and Kohn and modern DFT is also based on the Kohn Sham approach. 
        The electron density is a measurable quantity that is dependent on the cartesian coordinates of the electrons.
        In the first days of DFT (when invented by physicists) mostly the Linear Density Approach (LDA) was used and this approach works fine for metallic solids, in which the electrons are evenly distributed. 
        However, this is a poor approximation when we want to model molecular systems. 
        As a further Development of this approximation, Gradient corrected methods (GGA) have been invented. 
        These methods consider the electron density not to be uniform. 
        
        There are multiple terms in the Hamiltonian that have to be calculated. 
        The most troublesome one is the so-called &quot;Exchange-Correlation&quot; term. 
        There is a class of DFT functionals, the so-called Hybrid Functionals, that use a combination of exchange-correlation terms of different methods. 
        The method we used, B3LYP, uses a combination of LDA, GGA, and Hartree Fock (A wavefunction based method) exchange-correlation. 

    </P><H3>Basis Sets</H3><P>
        Now that we know which method we use we can take a look at the second important characteristic of our <DFN data-info="Quantum Mechanics">QM</DFN> calculations, the basis set. 
        All methods described previously, even if based on DFT, use Orbitals in their calculations. 
        By combining a certain number of orbitals the molecular orbitals of the system have to be expressed. 
        This starting number of orbitals is called the basis set. 
        Obviously, the more orbitals we have the more accurate the calculations become, but they also get more demanding. 
        As a small basis set we used the 6-31g* variant and as a bigger basis set, we used cc-pVDZ. 
        In a perfect scenario, the use of a bigger basis set should only improve the accuracy of the result, but it is possible that using a different basis set yields completely different results.
    </P><H3>Summary</H3><UL><LI>Based on Quantum Mechanics</LI><LI>All electrons investigated</LI><LI>Bond cleavage and formation can be calculated</LI><LI>Slow Calculations and limited to small Systems</LI></UL></DIV></DIV>
    To perform <DFN data-info="Molecular Dynamics">MD</DFN> Simulations we used the program package AMBER16. 
    For a foray how <DFN data-info="Molecular Dynamics">MD</DFN> Simulations work, please click below.
<DIV class="collapsible"><DIV class="btn_expand">Foray to <DFN data-info="Molecular Dynamics">MD</DFN> Simulations</DIV><DIV class="content"><H3>Foray to Molecular Mechanics </H3><P>
        Molecular Mechanics  (<DFN data-info="Molecular Mechanics">MM</DFN> ) uses the laws of classical mechanics to model molecular systems. It can be used to calculate anything ranging between small molecules to big proteins. 
        Each atom is simulated as one single particle, with a radius and charge. 
        Bonded interactions are treated by the famous Hooke's law (i.e. they are springs).
        This approximation allows us to simulate very big systems, but it is very important to asses which properties we can simulate correctly and therefore investigate.  
        Because classical Molecular Dynamics (<DFN data-info="Molecular Dynamics">MD</DFN>) Simulations are based on <DFN data-info="Molecular Mechanics">MM</DFN>
, we cannot simulate bond breaking or bond formation which also means that protonation states cannot change during simulation. 

    </P><H3>
        Force Fields
    </H3><P>
        To calculate inter- and intramolecular interactions, so-called force fields are used. 
        With these FF all of these interactions are reduced to single additive terms. 
        It consists of terms for bond stretching, angle bending, torsions, Lennard-Jones potential (for Van-der-Waals interactions) and electrostatic potential. 
        It is necessary to parametrize these terms very carefully and this is done by using experimental data or <DFN data-info="Quantum Mechanics">QM</DFN> calculations. 
        There are many FF available and we used a force field from the AMBER family called ff14SB <A href="https://pubs.acs.org/doi/abs/10.1021/acs.jctc.5b00255"><ABBR title="James A. Maier, Carmenza Martinez, Koushik Kasavajhala, Lauren Wickstrom, Kevin E. Hauser, and Carlos Simmerling, ff14SB: Improving the Accuracy of Protein Side Chain and Backbone Parameters from ff99SB
, J. Chem. Theory Comput., 2015, 11 (8), pp 3696–3713
">(Maier <I>et al.</I>2015)</ABBR></A>. 

        The complete potential function is given in the following equation:  

        </P><H3>
        Kinetic Energy and Time Evolution of a molecular system
    </H3><P>
        If we would just apply all of the physical principles and assumptions mentioned previously, we would minimize the system to the closest potential energy minimum.
        For the system to overcome potential energy barriers given by the FF, we have to introduce kinetic energy. 
        The kinetic energy of all particles in the system is dependent on their temperature and given by a Maxwell-Boltzmann velocity distribution function. 
        

        This distribution function contains the kinetic energy of a particle, which is expressed as its momentum.
        
        The total energy of the system is given as the sum of the potential energy (given by the force field) and the kinetic energy. 
        Each particle in every <DFN data-info="Molecular Dynamics">MD</DFN> timestep that we investigate has, therefore, three positional coordinates, three momentum coordinates, and a corresponding total energy. 
        
        To now introduce time evolution in the system we use classical mechanics and newtons laws of motion in combination with the kinetic energies introduced previously. 
        
        To further reduce the computational cost a so-called leapfrog algorithm is used. 
        As mentioned previously, every particle in the system is described using three positional coordinates, three momentum coordinates, and its corresponding energy. 
        With the leapfrog algorithm for each step of the <DFN data-info="Molecular Dynamics">MD</DFN> we only calculate either the positinal coordinates or the momentum coordinates and &quot;leap over&quot; the other. 
    </P><H3>
    Periodic Box
    </H3><P><DFN data-info="Molecular Dynamics">MD</DFN> Simulations are performed within a confined volume, called a unit cell. 
        This unit cell contains all particles that we simulate (i.e. protein, water, ligand).
        This introduces the problem of boundary effects because atoms and molecules close to these boundaries of the unit cell have fewer interaction partners than those in the middle of it. 
        To avoid boundary effects at the edges of the unit cell we repeat the unit cell periodically. 
        Thus, the shape of the unit cell has to allow such that a regular space filling lattice of unit cells can be arranged. 
        In our study, we used a truncated octahedron.
        <FIGURE><FIGCAPTION>Source:<A href="https://de.wikipedia.org/wiki/Datei:Truncatedoctahedron.gif">Wikipedia truncated octahedron</A></FIGCAPTION></FIGURE></P><H3>Summary</H3><UL><LI>Based on Classical Physics</LI><LI>No Electrons investigated</LI><LI>No Bond cleavage or formation</LI><LI>Fast Calculations and big Systems</LI></UL></DIV></DIV><H3>Motivation</H3><P> 
                   We went to great lengths to develop a workflow for metabolic engineering that utilizes the power of directed evolution and is worthy of synthetic biology in the not so early 21st century.
                   With the very recent Nobel Prize in chemistry towards directed evolution we think we have struck a nerve, and with <I>Vibrio Natriegens</I> this process can be streamlined even further.
                   Traditional Chemistry with Synthesis as its supreme discipline and its implications in the industry is one of the driving forces behind the modern wealth and is being improved on a daily basis.
                   Synthetic Biology and in particular metabolic engineering as a chemical producing science can use that well-established knowledge and expand on it.
                   Due to the completely different approach to synthesizing chemicals, we can mend the problems that classical organic chemistry is facing (e.g. natural products with many stereocenters, necessary purification of products after most reaction steps) and create compounds previously not synthesizable (e.g. Artemisinic acid) or ones that were too costly.
                   Using metabolic engineering also has the advantage to produce chemicals out of renewable resources while many chemicals right now are synthesized starting with fossil oil. 
                   To further improve this opportunity to make more of the chemical space synthesizable in a cheap, easy and renewable manner we need to go beyond &quot;mix and match&quot; pathways and explore novel enzymatic reactions. 
                    According to 

                <A href="https://www.sciencedirect.com/science/article/pii/S1367593116302071"><ABBR title="Tobias J Erb, Patrik R Jones, Arren Bar-Even, Synthetic metabolism: metabolic engineering meets enzyme design, Current Opinion in Chemical Biology (2017) 56-62">(Erb <I>et al.</I>2017)</ABBR></A> 

                metabolic engineering has been categorized in 5 different levels, depending on the methods employed. 
                These levels and the corresponding metabolic space is displayed in Figure 1. 
                We tried to expand on what we already did in our metabolic engineering project and tap the huge advantages using novel pathways offer.
                We tried to enable a novel pathway by engineering an enzyme to catalyse a new reaction which corresponds to the 4th level of metabolic engineering.
</P><FIGURE style="float: right; width: 400px"><FIGCAPTION style="float: right;"><B>Figure 1:</B> Different levels of metabolic engineering and their respective biochemical space.<A href="https://www.sciencedirect.com/science/article/pii/S1367593116302071"><ABBR title="Tobias J Erb, Patrik R Jones, Arren Bar-Even, Synthetic metabolism: metabolic engineering meets enzyme design, Current Opinion in Chemical Biology (2017) 56-62">(Erb <I>et al</I>2017)</ABBR></A></FIGCAPTION></FIGURE><H3>Design of the binding pocket</H3><P>
    The pathway we chose for our metabolic engineering efforts was - in our opinion - the best pathway that has been explored previously. 
    But there are much more possible theoretical 
    <A href="https://link.springer.com/article/10.1007/s00253-013-4802-4"><ABBR title="Kris Niño G. Valdehuesa, Huaiwei Liu, Grace M. Nisola, Wook-Jin Chung, Seung Hwan Lee, Si Jae Park, Recent advances in the metabolic engineering of microorganisms for the production of 3-hydroxypropionic acid as C3 platform chemical, Applied Microbiology and Biotechnology (2013), Volume 97, Issue 8, pp 3309–332">(Valdehuesa <I>et al</I>,2013)</ABBR></A> 
    pathways with remarkable properties that have not been explored yet.
    The reason is most of the times that it involves one or more reactions with no known enzyme to catalyse them.
    One theoretical pathway is from a free energy standpoint much more favorable, but there is one step without a known enzyme to catalyse it. We performed an intense literature research and decided to build an enzyme capable of decarboxylating malate to     <DFN data-info="3-hydroxypropionic acid">3HPA</DFN>. Even with <I> Vibrio natriegens </I> if we would engineer an enzyme to catalyse the wanted reaction using random mutagenesis it would take ages if it succeeds at all. That is why we decided to use a combination of <I>in silico</I> as well as wet lab methods to boost our chances of succeeding. 
</P><FIGURE style="width: 600px; float: right;"><FIGCAPTION><B>Figure 2:</B> Comparison between established and theoretical pathway using free energy. Reaction with no enzyme to catalyse marked with a green star.</FIGCAPTION></FIGURE><P> 
    The pathway that we plan to enable is displayed in Figure 2. The step that has to be catalysed is the decarboxylation reaction of malate to our final product, <DFN data-info="3-hydroxypropionic acid">3HPA</DFN>. As a starting point, we investigated the enzyme family of Carboxy-lyases (EC Number 4.1.1). We - in accordance with literature - were not able to find an enzyme that can catalyse this reaction. 
    However, there were some that we thought could help us to develop a binding pocket capable of decarboxylating malate.

    One of those was acetolactate decarboxylase (<DFN data-info="Acetolactate Decarboxylase">ALD</DFN> 4.1.1.5). 
    The important difference from its natural substrate to malate being that there is a carboxy group in β position (see Figure 4). 
    In this enzyme with the help of this carboxy group a double bond is formed to an intermediate product (see Figure 4) that we cannot form with malate as substrate. But the zinc cation that is used as a cofactor should be able to bind to malate in a similar way as it does with the natural substrate.  
    This could be a promising starting point because we would be able to sustain a specific conformation of the substrate and alter the electronic structure of the substrate at the same time. 
    The complex of malate inside the <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> binding pocket is shown in Figure 3. 
    The zinc cofactor is bound by three histidines and the zinc binds to the malate (or the substrate analog in the real crystal structure) with three interactions. 
    There is another important residue close to this complex, Arg145. 
    After the double bond and with it the intermediate product is formed, this residue is protonating the intermediate to form the product.
</P><FIGURE style="width: 500px; float: left;"><FIGCAPTION><B>Figure 3:</B> Complex of Malate with the Zn Cofactor inside the <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> binding pocket [PDB 4BT3]. .</FIGCAPTION></FIGURE><P>
    Another enzyme with an enzyme mechanism that might help us to find a way to catalyse this reaction is Orotidine 5'-phosphate decarboxylase (<DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> 4.1.1.23). 
    The reaction <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN>  catalyses compared to the reaction of <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> and the one we want to catalyse is shown in Figure 4. 
    <FIGURE style="width: 400px; float: right;"><FIGCAPTION><B>Figure 4:</B> Comparison between the reaction catalysed by <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> , <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> and the reaction that we want to catalyse. .</FIGCAPTION></FIGURE>
    In one study conducted by <A href="https://pubs.acs.org/doi/abs/10.1021/jp074858n"><ABBR title="Courtney L. Stanton, I-Feng W. Kuo, Christopher J. Mundy, Teodoro Laino, and K. N. Houk, QM/MM Metadynamics Study of the Direct Decarboxylation Mechanism for Orotidine-5‘-monophosphate Decarboxylase Using Two Different QM Regions:  Acceleration Too Small To Explain Rate of Enzyme Catalysis, J. Phys. Chem. B, &lt;b&gt;2007 &lt;/b&gt;, 111 (43), pp 12573–12581">(Courtney <I>et al.</I>2007)</ABBR></A> using 
     <DFN data-info="Quantum Mechanics">QM</DFN>/<DFN data-info="Molecular Mechanics">MM</DFN><DFN data-info="Molecular Dynamics">MD</DFN> 
     simulations, the decarboxylation mechanism of <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> has been investigated. 
    They have proposed a direct decarboxylation mechanism and calculated a free energy activation barrier that is in good agreement with experimentally obtained values.
    The reaction is split into two steps, first the decarboxylation and a simultaneous salt bridge between a lysine and the resulting carbanion. 
    After this, the lysine protonates the carbanion to yield the final product. 
    The most important difference between the substrate of <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> and malate is, that the carbanion stabilized (Figure 4) in the former one whilst there is nearly no stabilization in the latter one. 
    The idea of our enzyme design is that we use the direct decarboxylation of <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> and stabilize the carbanion with the cofactor of <DFN data-info="Acetolactate Decarboxylase">ALD</DFN>. 
    With this plan, we need to engineer the pocket in a way that a lysine side chain can get to the C2-carbon of malate (see Figure 5 for numbering) that shall be protonated. 
    <FIGURE style="float: left;width: 50%;"><FIGCAPTION><B>Figure 5:</B> Carbon chain numbering of malate (left). Highlighted bonds around which the dihedral angle 1 (red) and dihedral angle 2 (green) are centered (right). 
        </FIGCAPTION></FIGURE>
    Even if we can place a lysine near to the substrate, the reaction is not automatically working since the transition state energy is probably too high. 
    We need to calculate the transition state energy of our engineered systems and compare it to the literature to estimate the feasibility of our reaction.
    If the reaction is not feasible with a single lysine in the binding pocket, we need to alter the binding pocket to lower the transition state energy. 
    After that, we need to mutate an enzyme to resemble the binding pocket.

    As a starting point, we looked at all single point mutations to lysine that can be done where the protonated nitrogen of lysine has the possibility to get as close to the malate since this is required for reprotonation. All Mutations investigated are displayed in Table 1. 
    In the natural binding pocket of <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> there is an arginine residue that is used for reprotonation of the natural substrate. 
    Because of the possibility that this disturbs the lysine we mutated it in each binding pocket where it is not already mutated to a glycine. 

</P><TABLE align="center" style="width:100%"><CAPTION><B>Table 1:</B> All point mutations to <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> (PDB 4BT3) that have been investigated. The aminoacids are displayed as single character with the residue number in between. All mutations besides R145K also include R145G. </CAPTION><TBODY><TR><TH>L34K</TH><TH>G57K</TH><TH>T58K</TH><TH>L62K</TH></TR><TR><TH>E65K</TH><TH>G64K</TH><TH>R145K</TH><TH>V147K</TH></TR></TBODY></TABLE><H3><I>in silico</I> enzyme design</H3><P> 
    We developed a double modeling approach to investigate the whole system. First, we investigated the reaction using quantum mechanical calculations (<DFN data-info="Quantum Mechanics">QM</DFN>) and model the best possible system. 
    Then we control how well this system is retained if we make certain mutations in the <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> with the help of molecular dynamic (<DFN data-info="Molecular Dynamics">MD</DFN> ) Simulations. 
</P><H3>Quantum mechanics calculations</H3><P> 
    First, we modeled the reaction that we plan to catalyse using <DFN data-info="Quantum Mechanics">QM</DFN> level calculations. We used density functional theory based method b3-lyp with different basis sets. With these calculations, we tried to get a further insight into the reaction coordinate and all corresponding energies, most importantly the activation energy of the reaction.
    The activation energy can be calculated as the difference between the energy of the starting compounds and the transition state energy. 
    The activation energy is crucial for the activity of the final enzyme and high activation energies correspond to low or no activity of the final enzyme.
    According to 
    <A href="https://pubs.acs.org/doi/abs/10.1021/jp074858n"><ABBR title="Courtney L. Stanton, I-Feng W. Kuo, Christopher J. Mundy, Teodoro Laino, and K. N. Houk, QM/MM Metadynamics Study of the Direct Decarboxylation Mechanism for Orotidine-5‘-monophosphate Decarboxylase Using Two Different QM Regions:  Acceleration Too Small To Explain Rate of Enzyme Catalysis, J. Phys. Chem. B, &lt;b&gt;2007 &lt;/b&gt;, 111 (43), pp 12573–12581">(Courtney <I>et al.</I>2007)</ABBR></A>
     the reaction is split into two steps. 
    First, the decarboxylation happens and a salt bridge is formed between the positively charged lysine and negatively charged carbanion. 
    In a second step one of the protons of the lysine is protonating the negatively charged carbanion and with that the reaction is complete. 
    The first step of the reaction is the rate-limiting step of the reaction 
    <A href="https://pubs.acs.org/doi/abs/10.1021/jp074858n"><ABBR title="Courtney L. Stanton, I-Feng W. Kuo, Christopher J. Mundy, Teodoro Laino, and K. N. Houk, QM/MM Metadynamics Study of the Direct Decarboxylation Mechanism for Orotidine-5‘-monophosphate Decarboxylase Using Two Different QM Regions:  Acceleration Too Small To Explain Rate of Enzyme Catalysis, J. Phys. Chem. B, &lt;b&gt;2007 &lt;/b&gt;, 111 (43), pp 12573–12581">(Courtney <I>et al.</I>2007)</ABBR></A>
     and because of this, we decided to focus on it. 
</P><H4>Building of binding pockets</H4><P> As a starting point we used the <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> crystal         structure of 
    <A href="https://pubs.acs.org/doi/abs/10.1021/cb400429h"><ABBR title="Victoria A. Marlow, Dean Rea, Shabir Najmudin, Martin Wills, and Vilmos Fülöp, PStructure and Mechanism of Acetolactate Decarboxylase, ACS Chem. Biol., 2013, 8 (10), pp 2339–2344">(Marlow <I>et al.</I>2013)</ABBR></A> 
    (PDB CODE 4BT3). 
    From that, we extracted the position of the three zinc coordinating histidines, the zinc cation, and the substrate and changed the substrate analog ((2R,3R)-2,3-Dihydroxy-2-methylbutanoic acid) to malate.
    We then built multiple different binding pockets that are displayed in Table [2]. 
</P><TABLE style="width:100%" cellspacing="5" border="1"><CAPTION><B>Table 2:</B> The differently setup systems with the changes made and names given.</CAPTION><TBODY><TR><TH>Type of Binding Pocket</TH><TH>Abbreviation used in Graphs</TH><TH>Residues/Molecules involved</TH></TR><TR><TD>Binding Pocket without Cofactor</TD><TD>Complex</TD><TD>Lysine, Substrate</TD></TR><TR><TD>Binding Pocket</TD><TD>Nor_1</TD><TD>Three Histidines, Zinc cation, Lysine, Glutamate, Substrate</TD></TR><TR><TD>Binding Pocket pre-optimized</TD><TD>Nor_2</TD><TD>Three Histidines, Zinc cation, Lysine, Glutamate, Substrate</TD></TR><TR><TD>Minimal Binding Pocket</TD><TD>Min</TD><TD>Three Histidines, Zinc cation, Lysine, Substrate</TD></TR><TR><TD>Binding Pocket with two lysine residues</TD><TD>2lys</TD><TD>Three Histidines, Zinc cation, Lysine, Lysine, Substrate</TD></TR></TBODY></TABLE><P>
    Because we want to resemble the binding pocket to the best of our knowledge we made a system in which we kept Glu253 and added a lysine close to the C2-carbon that it should protonate.
    Later we used a pre-optimized structure of previous calculations and used this pre-optimized structure to build a minimal binding pocket where we removed Glu. 
    We also made one system with two lysine residues. 
    We will go into detail on why and how we designed this system when we explain the hypothesis.  
    As a start point, we also used a structure of malate and lysine, referred to as complex in Table 2. 
    The final systems are displayed in Figure 6. 

    </P><DIV class="imageContainer2x2"><DIV>a</DIV><DIV>b</DIV><DIV>c</DIV><DIV>d</DIV></DIV><FIGCAPTION>
        Figure 6 : Displayed of the different binding pockets. a) pre converged full binding pocket b) post converged full binding pocket c) minimal binding pocket d) binding pocket with two lysine residues
        </FIGCAPTION></DIV></DIV></ARTICLE>    
    To evaluate the transition state energy and the overall energy profile of the reaction an investigation of the reaction path is necessary. 
    Since we investigated a decarboxylation reaction, which is a c-c bond break, we chose to set up multiple calculations at different c-c bond lengths to evaluate the energy necessary to split that bond. 
    This way we sample the reaction coordinate of the systems.
    We screened the bond length in 0.1 Angstroem steps and added between 0 and 2 Angstroem to the starting c-c distance, this results in 20 calculations per screen.    
    With this method, we performed calculations for the starting system (no added c-c distance), the transition state (varying c-c distances depending on the system) and the final product (high c-c distances).
<H4>Results of <DFN data-info="Quantum Mechanics">QM</DFN> Calculations</H4><DIV class="imageContainer2x2"><DIV>a</DIV><DIV>b</DIV><DIV>c</DIV><DIV>d</DIV></DIV><FIGCAPTION><B>Figure 7:</B> Energy Profiles of C-C bond lengthening</FIGCAPTION></MAIN>
     The results of the calculations can be seen in Figure 7.
     
    The calculated activation barrier for the complex (cc-pVDZ basis set) is 59.04 kcal/mol [Figure 7a]. 
    This is far over the free energy barrier of <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> in the literature (15.54 kcal/mol <A href="https://pubs.acs.org/doi/abs/10.1021/jp074858n"><ABBR title="Courtney L. Stanton, I-Feng W. Kuo, Christopher J. Mundy, Teodoro Laino, and K. N. Houk, QM/MM Metadynamics Study of the Direct Decarboxylation Mechanism for Orotidine-5‘-monophosphate Decarboxylase Using Two Different QM Regions:  Acceleration Too Small To Explain Rate of Enzyme Catalysis, J. Phys. Chem. B, &lt;b&gt;2007 &lt;/b&gt;, 111 (43), pp 12573–12581">(Courtney <I>et al.</I>2007)</ABBR></A>). 


    The addition of the zinc complex that shall stabilize the carbanion (53.48 kcal/mol) [Figure 7c] only benefits the reaction with around 6 kcal/mol. 
    The transition states that we calculate are confirmed using frequency calculations. 
    If there is just one negative frequency calculated for an optimized structure, this means that it is a transition state. 
    The frequency can then be animated, to show the movement that is enforced by it. 
    An animation of the negative frequency of the minimal binding pocket transition state can be seen in Figure 8. 
     <FIGURE style="width: 600px; float: left;"><FIGCAPTION><B>Figure 8:</B> Animation of negative frequency of the transition state of the nor_1 binding pocket.</FIGCAPTION></FIGURE>
     Since all electronic structure calculations conducted in this study are computationally quite demanding, starting structures were pregenerated by structure optimizations on a low level of theory. The optimized structures are then used to build the starting structures for high-level calculations on the normal binding pocket and the minimal binding pocket.    
    As geometric optimizations are heavily dependent on the starting structure, we got different results with these structures than we got previously. 
    The Nor_2 (cc-pVDZ basis set) [Figure 7b] and the min (6-31g* basis set) [Figure 7d] electronic structure calculations were set up using a pre converged structure.
    For these two calculations, the activation barrier was approximately 7 kcal/mol less than in the previous calculations. 
    This was due to the fact that the lysine was not in the intended place at the end of the minimization. 
    Rather than building the salt bridge with the carbanion, it was interacting with both carboxy moieties, which was lowering the activation energy. 
    
    This was boosting our hope that if we introduce the correct changes to the binding pocket, we could change the electronic structure of malate in a way to sufficiently reduce the activation barrier. 
    To use this knowledge we set up another system with two lysine residues, one interacting with both carboxy moieties (lys1) and one that shall protonate the C2-carbon (lys2).
    The activation barrier (2lys 631g*) was slightly lower than before (~ 43 kcal/mol), but lys2 was not reprotonating the carbanion but interacting with the hydroxy moiety. 
    Even more interesting was the fact that the carbanion formed a covalent bond with the zinc cation with ca. 10 kcal/mol less energy than the transition state. 
    The optimized structure with the covalent bond between the zinc cation and the malate is displayed in Figure 9. 
         <FIGURE style="width: 400px; float: right;"><FIGCAPTION><B>Figure 9:</B> Intermediate state of the reaction with covalent bond between zinc cation and malate.</FIGCAPTION></FIGURE>
    This adds a new way at which the reaction can take place that can be used as an alternative approach without the need of direct reprotonation.  
<H3>Molecular Dynamic (<DFN data-info="Molecular Dynamics">MD</DFN> ) Simulations </H3><P>
    To evaluate how well the system that we tried to engineer in the <DFN data-info="Quantum Mechanics">QM</DFN> calculations is represented in the complete enzyme systems we performed <DFN data-info="Molecular Dynamics">MD</DFN>  simulations with <I>in silico</I> mutated enzyme versions. 
    We performed 200 ns <DFN data-info="Molecular Dynamics">MD</DFN>  Simulations of all previously mentioned mutated systems as well as the wild-type enzyme with 3 replicas each. 
    With the help of these <DFN data-info="Molecular Dynamics">MD</DFN>  simulations, we are able to evaluate how well the different mutations resemble the system that we designed for the <DFN data-info="Quantum Mechanics">QM</DFN> calculations.</P><H4>Setup of <DFN data-info="Molecular Dynamics">MD</DFN>  Simulations</H4><P>
    For the <DFN data-info="Molecular Dynamics">MD</DFN>  simulations, we used the <DFN data-info="Acetolactate Decarboxylase">ALD</DFN>  crystal structure of [Reference] (PDB CODE 4BT3). 
    We changed the substrate to malate and made the corresponding mutations for each system. 
    Then we capped the termini of the enzyme, checked for missing residues and protonated all residues according to pH 7.0. 
    We visually inspected the residues close to the binding pocket to make sure that all protonation states are correctly assigned. 
    For a more detailed description of our preparation protocol please click below.</P><DIV class="collapsible"><DIV class="btn_expand">MD preparation protocol </DIV><DIV class="content">
        Crystal structures of <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> were prepared using 
        <A href="https://www.chemcomp.com/MOE-Molecular_Operating_Environment.htm"><ABBR title="Molecular Operating Environment (MOE), 2013.08; Chemical Computing Group ULC, 1010 Sherbooke St. West, Suite #910, Montreal, QC, Canada, H3A 2R7, 2018.">MOE</ABBR></A>. 
        Ligand partial charges are derived using AM1-bcc calculations. 
        The programs <I>antechamber</I> and <I>parmchk2</I> are used for assignment of <I>gaff</I> atom types and missing force field parameters. 
        Then <I>tLEaP</I> is uesed to assign ff14SB <A href="https://pubs.acs.org/doi/abs/10.1021/acs.jctc.5b00255"><ABBR title="James A. Maier, Carmenza Martinez, Koushik Kasavajhala, Lauren Wickstrom, Kevin E. Hauser, and Carlos Simmerling, ff14SB: Improving the Accuracy of Protein Side Chain and Backbone Parameters from ff99SB
        , J. Chem. Theory Comput., 2015, 11 (8), pp 3696–3713
        ">(Maier <I>et al.</I>2015)</ABBR></A> force field parameters to the protein and counterions (Na<SUP>+</SUP>, Cl<SUP>-</SUP>) are added to ensure charge neutrality. 
        After building the truncated octahedron TIP3P-Ew water box, parameter and starting structure files are saved to disk. 
        
        In the following, all minimization steps are carried out using <I>pmemd</I> and all <DFN data-info="Molecular Dynamics">MD</DFN> runs are carried out using <I>pmemd.cuda</I> from the <I><A href="http://ambermd.org/"><ABBR title="D.A. Case, R.M. Betz, D.S. Cerutti, T.E. Cheatham, III, T.A. Darden, R.E. Duke, T.J. Giese, H. Gohlke,
        A.W. Goetz, N. Homeyer, S. Izadi, P. Janowski, J. Kaus, A. Kovalenko, T.S. Lee, S. LeGrand, P. Li, C.
        Lin, T. Luchko, R. Luo, B. Madej, D. Mermelstein, K.M. Merz, G. Monard, H. Nguyen, H.T. Nguyen, I.
        Omelyan, A. Onufriev, D.R. Roe, A. Roitberg, C. Sagui, C.L. Simmerling, W.M. Botello-Smith, J. Swails,
        R.C. Walker, J. Wang, R.M. Wolf, X. Wu, L. Xiao and P.A. Kollman (2016), AMBER 2016, University of
        California, San Francisco">AMBER 16</ABBR></A></I> package.
        Before the <DFN data-info="Molecular Dynamics">MD</DFN> run is started, we first heat and equilibrate the system. 
        For that, we minimize the system first with fixed solute heavy atoms and afterwards with constrained solute heavy atoms. 
        The system is annealed to 300K within 25 ps.
        After that, the density is equilibrated to approximately 1g/ml within 25 ps while lowering the constraints on the solute heavy atoms. 
        A final 5 ns equilibration with fixed volume and temperature is carried out before starting the productive <DFN data-info="Molecular Dynamics">MD</DFN>.

    </DIV></DIV><H4>Results of <DFN data-info="Molecular Dynamics">MD</DFN>  Simulations</H4><P>
    We previously established the mutations we introduced <I>in silico</I> (Table 1) to <DFN data-info="Acetolactate Decarboxylase">ALD</DFN>. 
    For evaluating how well the mutants resemble the binding pocket developed with the help of the <DFN data-info="Quantum Mechanics">QM</DFN> we developed a mechanical descriptor.
    The distance between the binding pockets lysine side chain and the malate is used. 
    We measured the distance between the lysine sidechains nitrogen atom and the C2-carbon that should be protonated of the malate for every frame of every <DFN data-info="Molecular Dynamics">MD</DFN>  Simulation.
    This way we can evaluate if the lysine is close enough to the C2-Carbon for reprotonation as well as interaction with the carboxy moieties.
    An animation of one <DFN data-info="Molecular Dynamics">MD</DFN>  Simulation (L34K Replica 1) with the distance highlighted is shown in Figure 10. 

<FIGURE style="float: top"><VIDEO controls="controls" width="800" height="600"><FIGCAPTION><B>Figure 10:</B><DFN data-info="Molecular Dynamics">MD</DFN>  Simulation of the L34K mutated system (replica 1) with the Malate-Lysine distance highlighted.</FIGCAPTION></VIDEO>



    To display this data we chose to use normalized histograms. 
    This way we can display the variation of this one variable.
    Normalization means that we do not display the number of observations on the y-axis, but rather the density of observations in each bin. 
    The total area of the histogram is normalized to one. 
    This helps to compare different histograms. 
    We also colored the three replicas that we simulated for each mutated enzyme differently, so that we can compare the different replicas. 
    The data is displayed in Figure [10]. 

</FIGURE></P><DIV class="imageContainer3x3"><DIV>a</DIV><DIV>b</DIV><DIV>c</DIV><DIV>d</DIV><DIV>e</DIV><DIV>f</DIV></DIV><FIGCAPTION><B>Figure 11:</B> Histograms of all simulated trajectories. Histograms colored differently for each replica a) L34K enzyme mutant b) R145K enzyme mutant c) V147K enzyme mutant d) L62K enzyme mutant e T58K enzyme mutant f) E65K enzyme mutant</FIGCAPTION>
    The first thing that stood out to us is that all histograms show mostly low distance ( &lt; 6 Angstroem) and most replicas (besides E65K_c [Figure 11e] and R145K_b [Figure 11c]) are in good agreement to each other. 
    Apart from R145K and V147K all variants show distances under 4 Angstroem. 
    Especially L34K, T58K, and E65K have stable and low distances.
     
    This is very promising because it means that there is not only one potential position to introduce point mutations, which opens up further possibilities for enzyme design. 
    To further distinguish between the different variations we decided to look at two dihedral angles of the lysine sidechain to evaluate its flexibility. 
    To display this we used two-dimensional histograms. 
    The 2d histograms we developed contain all the information the 1d histograms had. 
    However, they do not &quot;just&quot; count how many instances of an investigation we have in a bin, but rather how many combinations of investigations we have in a small two-dimensional box. 
    This way we can not only investigate which distances each mutated enzyme has, but also pair this together with the corresponding dihedral angle(s) [Figure 5].
    We also use normalized 2d-histograms, which means that the total area of the 2d-histogram is normalized to one.
    What we are looking for is a mutated enzyme which consistently shows low lysine-malate distances while simultaneously showing some flexibility in the dihedral angles.
    If the side chain of lysine shows too much flexibility (i.e. Figure 13d), the sidechains stability at the correct position is unfavorable.
    A ligand that shows too low flexibility (i.e. Figure 12b) the position is entropically unbeneficial.
    The results are displayed in Figure 12 and 13. 
    

 <FIGURE><DIV class="imageContainer3x3"><DIV>a</DIV><DIV>b</DIV><DIV>c</DIV><DIV>d</DIV><DIV>e</DIV><DIV>f</DIV></DIV><FIGCAPTION><B>Figure 12:</B>2D Histogram Lysine-Malate Distance vs Dihedral angle 1. a) L34K enzyme mutant b) R145K enzyme mutant c) V147K enzyme mutant d) L62K enzyme mutant e T58K enzyme mutant f) E65K enzyme mutant</FIGCAPTION></FIGURE><FIGURE><DIV class="imageContainer3x3"><DIV>a</DIV><DIV>b</DIV><DIV>c</DIV><DIV>d</DIV><DIV>e</DIV><DIV>f</DIV></DIV><FIGCAPTION><B>Figure 13:</B> 2D Histogram Lysine-Malate Distance vs Dihedral angle 2. a) L34K enzyme mutant b) R145K enzyme mutant c) V147K enzyme mutant d) L62K enzyme mutant e T58K enzyme mutant f) E65K enzyme mutant</FIGCAPTION></FIGURE><P>
    We can observe high densities for R145K (Figure 12b), which means that the single state it is in is also very stable. 
    The very stable dihedral angles indicate an entropically unbeneficial conformation of the side chain. 
    For T58K we observe a stable conformation at a low distance, but also that it is stable at a broad range of distances. 
    L34K has multiple stable angles for dihedral angle 2, whilst having only one for dihedral angle 1 and a small and low distance range. 
    If we take the 1d as well as the 2d histograms into account, L34K seems to be the most promising of all of the different mutated enzymes. 

</P><H3>Wetlab</H3><P>

 Even though our QM calculations did predict that the mutated enzyme won’t show activity, we decided to test this hypothesis in the lab.
 
  For validation we planned to express it in <I>V. natriegens</I>. 
  ALD is an enzyme involved in mixed acid fermentation, a metabolism which is widespread in the domain of bacteria. 
  To lower the risk of implementing an enzyme which isn’t functional in our strain, we decided to use the <I>ald</I> gene of an organism closely related to <I>V. natriegens</I>. 
  We decided for <I>ald</I> from <I>Enterobacter cloacae</I> ATCC 29006, because it is a model organism for studying mixed acid fermentation, is also a γ-proteobacterium and has biosafety level 1. 
  We codon-optimized the gene sequence of the L34K ALD mutant for <I>V. natriegens</I> and ordered it. 
  
  Our plan was to clone it into an expression vector and transform it into our chassis.  
  By using the <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> biosensor 

  (<A href="https://2018.igem.org/Team:Marburg/Design">See our metabolic engineering biosensor part for more details</A>)



   we then can visually see if <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> is produced. 
  To quantify the amount of produced <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> we planned to perform plate reader measurements detecting fluorescence of GFP/RFP or luminescence, triggered by the lux operon, depending on which reporter is used. To further analyze enzyme activity, we planned to perform a coupled enzyme assay, where we overexpress the protein and break the cells to get cell extract. 
  As described in the section about product screening 


  (<A href="https://2018.igem.org/Team:Marburg/Design">See our metabolic engineering product screening part for more details</A>)


   cell extract can be used in a photometric assay together with an NAD(P)H-dependent reaction to quantify substrate conversion. In this case we decided to use propionyl-CoA synthase (PCS) from <I>Chloroflexus aurantiacus</I> as indicator enzyme. 
  PCS catalyzes the NADPH-dependent conversion of <DFN data-info="3-hydroxypropionic acid">3HPA</DFN> to propionyl-CoA. The reaction mix consists of ATP, MgCl2, CoA, NADPH and cell extract of ALD L34K producing cells. 
  To start the reaction, we add malate and by determining the slope we then can calculate the specific activity. 
  Figure 14 illustrates the route, to measure NADPH consumption by ALD and Pcs. 
  To confirm, that the measured NADPH consumption origins definitely from PCS and therefore indirectly from ALD L34K, we also decided to detect propionyl-CoA as product of the overall reaction via mass spectrometry 


    (<A href="https://2018.igem.org/Team:Marburg/Design">See our metabolic engineering product screening part for more details.</A>).


<FIGURE style="width: 80%; float: center;"><FIGCAPTION><B>Figure 14:</B> Indicator pathway to measure enzyme activity. To directly measure the production of 3HP we use propionyl-CoA synthase (Pcs) as indicator enzyme. It converts 3HP to propionyl-CoA, thereby consuming NADPH. Decrease of absorption of NADPH at a wavelength of 365nm can be screened to quantify substrate conversion and enzyme activity.</FIGCAPTION></FIGURE>


Unfortunately, we struggled with cloning the <I>ald</I> L34K gene into the expression vector pET16b and finally lack of time forced us to finish trying to construct the expression system. Nevertheless, we have the synthesized gene and also prepared all enzymes necessary for doing the in vitro activity assay. Also, we recently got first results for our 3HP biosensor and as soon as the sensor is working, it will be possible to screen in vivo for 3HP production by ALD.

</P><H3>Summary</H3><P>
      We have developed an <I>in silico</I> workflow to design a novel decarboxylase that with minor changes can be adapted for other carbon-carbon bond cleavage enzyme designs, <I>de novo</I> or not. 
     We predicted that the activation barrier for the reaction is too high for successful catalysis.
     Because of time and resources we were only able to look at single point and double mutations, but the reduction in the activation barrier when using lysine to interact with the carboxy functions showed that there are possibilities to change the electronic structure of the substrate.
     With the covalent bond between the zinc cation and the substrate we also showed that we can and should dare to think outside the box to find novel ways that could help to create a novel enzyme mechanism. 
     With the data obtained through our <DFN data-info="Molecular Dynamics">MD</DFN>  Simulations we showed that there are multiple positions in the binding pocket of <DFN data-info="Acetolactate Decarboxylase">ALD</DFN> where we can introduce point mutations that interact with the substrate.
 </P><H3>Outlook</H3>

The next <I>in silico</I> steps are further exploring the possibilities of multiple mutations (and therefore multiple sidechains in the binding pocket). 
We have shown that the interaction of charged side chains, in our case lysine, can lower the activation energy.
We think multiple sidechains with the possibility of building salt bridges or hydrogen bonds with malate will alter the electronic structure even further.
We have also shown that the nor_1 system (with zinc cation) has only an about ~6kcal/mol smaller activation barrier than the complex (without zinc cation). 
Even though the zinc cofactor offers the opportunity to stabilize malate in the binding pocket in a very specific conformation it is probably worthwhile to investigate a more <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> style binding pocket without a cofactor. 
<DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> speeds the reaction of the natural substrate up by a factor of 10^17 without a cofactor and is a fascinating enzyme because of that. 
We strongly believe that there is a possibility to design a binding pocket capable to catalyse this reaction using a <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> style binding pocket.
We do not need to engineer an enzyme capable of such a reaction speedup as in <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN>, it is fully sufficient to make an enzyme that is capable to catalyse measurable quantities and improve it using our metabolic engineering workflow.
Due to the vast differences between the substrates the binding pocket of <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> is too big for Malate. 
The binding pocket could only be utilized for malate if we would introduce multiple changes and maybe the backbone of the protein is not suited to design the functioning, yet unknown binding pocket.
It is possible to design a binding pocket without cofactor using the method we established and to design an enzyme starting from the binding pocket we could either engineer <DFN data-info="Orotidine 5′-monophosphate decarboxylase">ODCase</DFN> or use a programm like <A href="https://www.rosettacommons.org/software
"><ABBR title="Rosetta"> Rosetta </ABBR></A> to screen for other possible candidates with fitting binding pockets. 
 <I>&quot;I have not failed. I've just found 10.000 ways that won't work.&quot; - <B>Thomas A. Edison</B></I>
 Overall, even though we were not able to design a working enzyme, we are very optimistic about the prospect of it in the future and think that our results can function as a fundament that others can build on.

    </DIV></DIV><DIV class="collapsible"><DIV class="btn_expand">Sources</DIV><DIV class="content"><H4>Metabolic model</H4><P>
	C. Rathnasingha, S. M. Raj, Y. Lee, C. Catherinea, S. Ashoka, S. Park . 2012. Production of 3-hydroxypropionic acid via malonyl-CoA pathway using recombinant Escherichia coli strains. 2012. http://doi.org/10.1016/j.jbiotec.2011.06.008
</P><P>
	J. K. Rogers, G. M. Church. Production of 3-hydroxypropionic acid via malonyl-CoA pathway using recombinant Escherichia coli strains. 2016. http://doi.org/10.1016/j.jbiotec.2011.06.008
</P><P>
	R. R. Fall, A. M. Nervi, A. W. Alberts, P. R. Vagelos. Acetyl CoA Carboxylase: Isolation and Characterization of Native Biotin Carboxyl Carrier Protein. 1971. http://www.pnas.org/content/pnas/68/7/1512.full.pdf
</P><P>
	C. P. Long, J. E. Gonzalez, R. M. Cipolla, M. R. Antoniewicz. Metabolism of the fast-growing bacterium Vibrio natriegens elucidated by 13C metabolic flux analysis. 2017. http://doi.org/10.1016/j.ymben.2017.10.008
</P><P>
	W. W. Chen, M. Niepel, P. K. Sorger. Classic and contemporary approaches to modeling biochemical reactions. 2010. http://dx.doi.org/10.1101%2Fgad.1945410
</P><P>
	L. A. Segel, M. Slemrod. The Quasi-Steady-State Assumption: A Case Study in Perturbation. 1989. http://doi.org/10.1137/1031091
</P><P>
	C. T. Goudar, J. R. Sonnad, R. G. Duggleby. Parameter estimation using a direct solution of the integrated Michaelis-Menten equation. 1999. http://doi.org/10.1016/S0167-4838(98)00247-7
</P><H4>Structural model</H4>
Courtney L. Stanton, I-Feng W. Kuo, Christopher J. Mundy, Teodoro Laino, and K. N. Houk, QM/MM Metadynamics Study of the Direct Decarboxylation Mechanism for Orotidine-5‘-monophosphate Decarboxylase Using Two Different QM Regions:  Acceleration Too Small To Explain Rate of Enzyme Catalysis, J. Phys. Chem. B, <B>2007 </B>, 111 (43), pp 12573–12581

Tobias J Erb, Patrik R Jones, Arren Bar-Even, Synthetic metabolism: metabolic engineering meets enzyme design, Current Opinion in Chemical Biology (2017) 56-62

Victoria A. Marlow, Dean Rea, Shabir Najmudin, Martin Wills, and Vilmos Fülöp, PStructure and Mechanism of Acetolactate Decarboxylase, ACS Chem. Biol., 2013, 8 (10), pp 2339–2344

James A. Maier, Carmenza Martinez, Koushik Kasavajhala, Lauren Wickstrom, Kevin E. Hauser, and Carlos Simmerling, ff14SB: Improving the Accuracy of Protein Side Chain and Backbone Parameters from ff99SB
, J. Chem. Theory Comput., 2015, 11 (8), pp 3696–3713

Kris Niño G. Valdehuesa, Huaiwei Liu, Grace M. Nisola, Wook-Jin Chung, Seung Hwan Lee, Si Jae Park, Recent advances in the metabolic engineering of microorganisms for the production of 3-hydroxypropionic acid as C3 platform chemical, Applied Microbiology and Biotechnology (2013), Volume 97, Issue 8, pp 3309–332

M. Born  R. Oppenheimer
, Zur Quantentheorie der Molekeln (1927), Annalen der Physik



    </DIV></DIV><FOOTER><DIV style="position: absolute;left: 0;bottom: 0;color: #b1b1b1;margin: 0.5%;font-size: 0.8em;">B. Marchal</DIV></FOOTER></DIV></DIV></DIV></BODY></HTML>
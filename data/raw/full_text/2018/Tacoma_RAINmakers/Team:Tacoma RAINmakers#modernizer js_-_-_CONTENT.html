<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Tacoma_RAINmakers_modernizer_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Tacoma RAINmakers/modernizer js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE>* Modernizr v2.7.1
* www.modernizr.com
*
* Copyright (c) Faruk Ates, Paul Irish, Alex Sexton
* Available under the BSD and MIT licenses: www.modernizr.com/license/
*/
</PRE><P>window.Modernizr = (function( window, document, undefined ) {
</P><PRE>   var version = '2.7.1',
</PRE><PRE>   Modernizr = {},
</PRE><PRE>   /*&gt;&gt;cssclasses*/
   // option for enabling the HTML classes to be added
   enableClasses = true,
   /*&gt;&gt;cssclasses*/
</PRE><PRE>   docElement = document.documentElement,
</PRE><PRE>   /**
    * Create our &quot;modernizr&quot; element that we do most feature tests on.
    */
   mod = 'modernizr',
   modElem = document.createElement(mod),
   mStyle = modElem.style,
</PRE><PRE>   /**
    * Create the input element for various Web Forms feature tests.
    */
   inputElem /*&gt;&gt;inputelem*/ = document.createElement('input') /*&gt;&gt;inputelem*/ ,
</PRE><PRE>   /*&gt;&gt;smile*/
   smile = ':)',
   /*&gt;&gt;smile*/
</PRE><PRE>   toString = {}.toString,
</PRE><PRE>   // TODO :: make the prefixes more granular
   /*&gt;&gt;prefixes*/
   // List of property values to set for css tests. See ticket #21
   prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),
   /*&gt;&gt;prefixes*/
</PRE><PRE>   /*&gt;&gt;domprefixes*/
   // Following spec is to expose vendor-specific style properties as:
   //   elem.style.WebkitBorderRadius
   // and the following would be incorrect:
   //   elem.style.webkitBorderRadius
</PRE><PRE>   // Webkit ghosts their properties in lowercase but Opera &amp; Moz do not.
   // Microsoft uses a lowercase `ms` instead of the correct `Ms` in IE8+
   //   erik.eae.net/archives/2008/03/10/21.48.10/
</PRE><PRE>   // More here: github.com/Modernizr/Modernizr/issues/issue/21
   omPrefixes = 'Webkit Moz O ms',
</PRE><PRE>   cssomPrefixes = omPrefixes.split(' '),
</PRE><PRE>   domPrefixes = omPrefixes.toLowerCase().split(' '),
   /*&gt;&gt;domprefixes*/
</PRE><PRE>   /*&gt;&gt;ns*/
   ns = {'svg': '<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg'}">http://www.w3.org/2000/svg'}</A>,
   /*&gt;&gt;ns*/
</PRE><PRE>   tests = {},
   inputs = {},
   attrs = {},
</PRE><PRE>   classes = [],
</PRE><PRE>   slice = classes.slice,
</PRE><PRE>   featureName, // used in testing loop
</PRE><PRE>   /*&gt;&gt;teststyles*/
   // Inject element with style element and some CSS rules
   injectElementWithStyles = function( rule, callback, nodes, testnames ) {
</PRE><PRE>     var style, ret, node, docOverflow,
         div = document.createElement('div'),
         // After page load injecting a fake body doesn't work so check if body exists
         body = document.body,
         // IE6 and 7 won't return offsetWidth or offsetHeight unless it's in the body element, so we fake it.
         fakeBody = body || document.createElement('body');
</PRE><PRE>     if ( parseInt(nodes, 10) ) {
         // In order not to give false positives we create a node for each test
         // This also allows the method to scale for unspecified uses
         while ( nodes-- ) {
             node = document.createElement('div');
             node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
             div.appendChild(node);
         }
     }
</PRE><PRE>     // &lt;style&gt; elements in IE6-9 are considered 'NoScope' elements and therefore will be removed
     // when injected with innerHTML. To get around this you need to prepend the 'NoScope' element
     // with a 'scoped' element, in our case the soft-hyphen entity as it won't mess with our measurements.
     // msdn.microsoft.com/en-us/library/ms533897%28VS.85%29.aspx
     // Documents served as xml will throw if using ­ so use xml friendly encoded version. See issue #277
     style = ['­','&lt;style id=&quot;s', mod, '&quot;&gt;', rule, '&lt;/style&gt;'].join(<I>);</I>
     div.id = mod;
     // IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
     // Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
     (body ? div : fakeBody).innerHTML += style;
     fakeBody.appendChild(div);
     if ( !body ) {
         //avoid crashing IE8, if background image is used
         fakeBody.style.background = <I>;</I>
         //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
         fakeBody.style.overflow = 'hidden';
         docOverflow = docElement.style.overflow;
         docElement.style.overflow = 'hidden';
         docElement.appendChild(fakeBody);
     }
</PRE><PRE>     ret = callback(div, rule);
     // If this is done after page load we don't want to remove the body so check if body exists
     if ( !body ) {
         fakeBody.parentNode.removeChild(fakeBody);
         docElement.style.overflow = docOverflow;
     } else {
         div.parentNode.removeChild(div);
     }
</PRE><PRE>     return !!ret;
</PRE><PRE>   },
   /*&gt;&gt;teststyles*/
</PRE><PRE>   /*&gt;&gt;mq*/
   // adapted from matchMedia polyfill
   // by Scott Jehl and Paul Irish
   // gist.github.com/786768
   testMediaQuery = function( mq ) {
</PRE><PRE>     var matchMedia = window.matchMedia || window.msMatchMedia;
     if ( matchMedia ) {
       return matchMedia(mq).matches;
     }
</PRE><PRE>     var bool;
</PRE><PRE>     injectElementWithStyles('@media ' + mq + ' { #' + mod + ' { position: absolute; } }', function( node ) {
       bool = (window.getComputedStyle ?
                 getComputedStyle(node, null) :
                 node.currentStyle)['position'] == 'absolute';
     });
</PRE><PRE>     return bool;
</PRE><PRE>    },
    /*&gt;&gt;mq*/
</PRE><PRE>   /*&gt;&gt;hasevent*/
   //
   // isEventSupported determines if a given element supports the given event
   // kangax.github.com/iseventsupported/
   //
   // The following results are known incorrects:
   //   Modernizr.hasEvent(&quot;webkitTransitionEnd&quot;, elem) // false negative
   //   Modernizr.hasEvent(&quot;textInput&quot;) // in Webkit. github.com/Modernizr/Modernizr/issues/333
   //   ...
   isEventSupported = (function() {
</PRE><PRE>     var TAGNAMES = {
       'select': 'input', 'change': 'input',
       'submit': 'form', 'reset': 'form',
       'error': 'img', 'load': 'img', 'abort': 'img'
     };
</PRE><PRE>     function isEventSupported( eventName, element ) {
</PRE><PRE>       element = element || document.createElement(TAGNAMES[eventName] || 'div');
       eventName = 'on' + eventName;
</PRE><PRE>       // When using `setAttribute`, IE skips &quot;unload&quot;, WebKit skips &quot;unload&quot; and &quot;resize&quot;, whereas `in` &quot;catches&quot; those
       var isSupported = eventName in element;
</PRE><PRE>       if ( !isSupported ) {
         // If it has no `setAttribute` (i.e. doesn't implement Node interface), try generic element
         if ( !element.setAttribute ) {
           element = document.createElement('div');
         }
         if ( element.setAttribute &amp;&amp; element.removeAttribute ) {
           element.setAttribute(eventName, <I>);</I>
           isSupported = is(element[eventName], 'function');
</PRE><PRE>           // If property was created, &quot;remove it&quot; (by setting value to `undefined`)
           if ( !is(element[eventName], 'undefined') ) {
             element[eventName] = undefined;
           }
           element.removeAttribute(eventName);
         }
       }
</PRE><PRE>       element = null;
       return isSupported;
     }
     return isEventSupported;
   })(),
   /*&gt;&gt;hasevent*/
</PRE><PRE>   // TODO :: Add flag for hasownprop ? didn't last time
</PRE><PRE>   // hasOwnProperty shim by kangax needed for Safari 2.0 support
   _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;
</PRE><PRE>   if ( !is(_hasOwnProperty, 'undefined') &amp;&amp; !is(_hasOwnProperty.call, 'undefined') ) {
     hasOwnProp = function (object, property) {
       return _hasOwnProperty.call(object, property);
     };
   }
   else {
     hasOwnProp = function (object, property) { /* yes, this can give false positives/negatives, but most of the time we don't care about those */
       return ((property in object) &amp;&amp; is(object.constructor.prototype[property], 'undefined'));
     };
   }
</PRE><PRE>   // Adapted from ES5-shim <A rel="nofollow" class="external free" href="https://github.com/kriskowal/es5-shim/blob/master/es5-shim.js">https://github.com/kriskowal/es5-shim/blob/master/es5-shim.js</A>
   // es5.github.com/#x15.3.4.5
</PRE><PRE>   if (!Function.prototype.bind) {
     Function.prototype.bind = function bind(that) {
</PRE><PRE>       var target = this;
</PRE><PRE>       if (typeof target != &quot;function&quot;) {
           throw new TypeError();
       }
</PRE><PRE>       var args = slice.call(arguments, 1),
           bound = function () {
</PRE><PRE>           if (this instanceof bound) {
</PRE><PRE>             var F = function(){};
             F.prototype = target.prototype;
             var self = new F();
</PRE><PRE>             var result = target.apply(
                 self,
                 args.concat(slice.call(arguments))
             );
             if (Object(result) === result) {
                 return result;
             }
             return self;
</PRE><PRE>           } else {
</PRE><PRE>             return target.apply(
                 that,
                 args.concat(slice.call(arguments))
             );
</PRE><PRE>           }
</PRE><PRE>       };
</PRE><PRE>       return bound;
     };
   }
</PRE><PRE>   /**
    * setCss applies given styles to the Modernizr DOM node.
    */
   function setCss( str ) {
       mStyle.cssText = str;
   }
</PRE><PRE>   /**
    * setCssAll extrapolates all vendor-specific css strings.
    */
   function setCssAll( str1, str2 ) {
       return setCss(prefixes.join(str1 + ';') + ( str2 || <I> ));</I>
   }
</PRE><PRE>   /**
    * is returns a boolean for if typeof obj is exactly type.
    */
   function is( obj, type ) {
       return typeof obj === type;
   }
</PRE><PRE>   /**
    * contains returns a boolean for if substr is found within str.
    */
   function contains( str, substr ) {
       return !!~(<I> + str).indexOf(substr);</I>
   }
</PRE><PRE>   /*&gt;&gt;testprop*/
</PRE><PRE>   // testProps is a generic CSS / DOM property test.
</PRE><PRE>   // In testing support for a given CSS property, it's legit to test:
   //    `elem.style[styleName] !== undefined`
   // If the property is supported it will return an empty string,
   // if unsupported it will return undefined.
</PRE><PRE>   // We'll take advantage of this quick test and skip setting a style
   // on our modernizr element, but instead just testing undefined vs
   // empty string.
</PRE><PRE>   // Because the testing of the CSS property names (with &quot;-&quot;, as
   // opposed to the camelCase DOM properties) is non-portable and
   // non-standard but works in WebKit and IE (but not Gecko or Opera),
   // we explicitly reject properties with dashes so that authors
   // developing in WebKit or IE first don't end up with
   // browser-specific content by accident.
</PRE><PRE>   function testProps( props, prefixed ) {
       for ( var i in props ) {
           var prop = props[i];
           if ( !contains(prop, &quot;-&quot;) &amp;&amp; mStyle[prop] !== undefined ) {
               return prefixed == 'pfx' ? prop : true;
           }
       }
       return false;
   }
   /*&gt;&gt;testprop*/
</PRE><PRE>   // TODO :: add testDOMProps
   /**
    * testDOMProps is a generic DOM property test; if a browser supports
    *   a certain property, it won't return undefined for it.
    */
   function testDOMProps( props, obj, elem ) {
       for ( var i in props ) {
           var item = obj[props[i]];
           if ( item !== undefined) {
</PRE><PRE>               // return the property name as a string
               if (elem === false) return props[i];
</PRE><PRE>               // let's bind a function
               if (is(item, 'function')){
                 // default to autobind unless override
                 return item.bind(elem || obj);
               }
</PRE><PRE>               // return the unbound function or obj or value
               return item;
           }
       }
       return false;
   }
</PRE><PRE>   /*&gt;&gt;testallprops*/
   /**
    * testPropsAll tests a list of DOM properties we want to check against.
    *   We specify literally ALL possible (known and/or likely) properties on
    *   the element including the non-vendor prefixed one, for forward-
    *   compatibility.
    */
   function testPropsAll( prop, prefixed, elem ) {
</PRE><PRE>       var ucProp  = prop.charAt(0).toUpperCase() + prop.slice(1),
           props   = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');
</PRE><PRE>       // did they call .prefixed('boxSizing') or are we just testing a prop?
       if(is(prefixed, &quot;string&quot;) || is(prefixed, &quot;undefined&quot;)) {
         return testProps(props, prefixed);
</PRE><PRE>       // otherwise, they called .prefixed('requestAnimationFrame', window[, elem])
       } else {
         props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
         return testDOMProps(props, prefixed, elem);
       }
   }
   /*&gt;&gt;testallprops*/
</PRE><PRE>   /**
    * Tests
    * -----
    */
</PRE><PRE>   // The *new* flexbox
   // dev.w3.org/csswg/css3-flexbox
</PRE><PRE>   tests['flexbox'] = function() {
     return testPropsAll('flexWrap');
   };
</PRE><PRE>   // The *old* flexbox
   // www.w3.org/TR/2009/WD-css3-flexbox-20090723/
</PRE><PRE>   tests['flexboxlegacy'] = function() {
       return testPropsAll('boxDirection');
   };
</PRE><PRE>   // On the S60 and BB Storm, getContext exists, but always returns undefined
   // so we actually have to call getContext() to verify
   // github.com/Modernizr/Modernizr/issues/issue/97/
</PRE><PRE>   tests['canvas'] = function() {
       var elem = document.createElement('canvas');
       return !!(elem.getContext &amp;&amp; elem.getContext('2d'));
   };
</PRE><PRE>   tests['canvastext'] = function() {
       return !!(Modernizr['canvas'] &amp;&amp; is(document.createElement('canvas').getContext('2d').fillText, 'function'));
   };
</PRE><PRE>   // webk.it/70117 is tracking a legit WebGL feature detect proposal
</PRE><PRE>   // We do a soft detect which may false positive in order to avoid
   // an expensive context creation: bugzil.la/732441
</PRE><PRE>   tests['webgl'] = function() {
       return !!window.WebGLRenderingContext;
   };
</PRE><PRE>   /*
    * The Modernizr.touch test only indicates if the browser supports
    *    touch events, which does not necessarily reflect a touchscreen
    *    device, as evidenced by tablets running Windows 7 or, alas,
    *    the Palm Pre / WebOS (touch) phones.
    *
    * Additionally, Chrome (desktop) used to lie about its support on this,
    *    but that has since been rectified: crbug.com/36415
    *
    * We also test for Firefox 4 Multitouch Support.
    *
    * For more info, see: modernizr.github.com/Modernizr/touch.html
    */
</PRE><PRE>   tests['touch'] = function() {
       var bool;
</PRE><PRE>       if(('ontouchstart' in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch) {
         bool = true;
       } else {
         injectElementWithStyles(['@media (',prefixes.join('touch-enabled),('),mod,')','{#modernizr{top:9px;position:absolute}}'].join(<I>), function( node ) {</I>
           bool = node.offsetTop === 9;
         });
       }
</PRE><PRE>       return bool;
   };
</PRE><PRE>   // geolocation is often considered a trivial feature detect...
   // Turns out, it's quite tricky to get right:
   //
   // Using !!navigator.geolocation does two things we don't want. It:
   //   1. Leaks memory in IE9: github.com/Modernizr/Modernizr/issues/513
   //   2. Disables page caching in WebKit: webk.it/43956
   //
   // Meanwhile, in Firefox &lt; 8, an about:config setting could expose
   // a false positive that would throw an exception: bugzil.la/688158
</PRE><PRE>   tests['geolocation'] = function() {
       return 'geolocation' in navigator;
   };
</PRE><PRE>   tests['postmessage'] = function() {
     return !!window.postMessage;
   };
</PRE><PRE>   // Chrome incognito mode used to throw an exception when using openDatabase
   // It doesn't anymore.
   tests['websqldatabase'] = function() {
     return !!window.openDatabase;
   };
</PRE><PRE>   // Vendors had inconsistent prefixing with the experimental Indexed DB:
   // - Webkit's implementation is accessible through webkitIndexedDB
   // - Firefox shipped moz_indexedDB before FF4b9, but since then has been mozIndexedDB
   // For speed, we don't test the legacy (and beta-only) indexedDB
   tests['indexedDB'] = function() {
     return !!testPropsAll(&quot;indexedDB&quot;, window);
   };
</PRE><PRE>   // documentMode logic from YUI to filter out IE8 Compat Mode
   //   which false positives.
   tests['hashchange'] = function() {
     return isEventSupported('hashchange', window) &amp;&amp; (document.documentMode === undefined || document.documentMode &gt; 7);
   };
</PRE><PRE>   // Per 1.6:
   // This used to be Modernizr.historymanagement but the longer
   // name has been deprecated in favor of a shorter and property-matching one.
   // The old API is still available in 1.6, but as of 2.0 will throw a warning,
   // and in the first release thereafter disappear entirely.
   tests['history'] = function() {
     return !!(window.history &amp;&amp; history.pushState);
   };
</PRE><PRE>   tests['draganddrop'] = function() {
       var div = document.createElement('div');
       return ('draggable' in div) || ('ondragstart' in div &amp;&amp; 'ondrop' in div);
   };
</PRE><PRE>   // FF3.6 was EOL'ed on 4/24/12, but the ESR version of FF10
   // will be supported until FF19 (2/12/13), at which time, ESR becomes FF17.
   // FF10 still uses prefixes, so check for it until then.
   // for more ESR info, see: mozilla.org/en-US/firefox/organizations/faq/
   tests['websockets'] = function() {
       return 'WebSocket' in window || 'MozWebSocket' in window;
   };
</PRE><PRE>   // css-tricks.com/rgba-browser-support/
   tests['rgba'] = function() {
       // Set an rgba() color and check the returned value
</PRE><PRE>       setCss('background-color:rgba(150,255,150,.5)');
</PRE><PRE>       return contains(mStyle.backgroundColor, 'rgba');
   };
</PRE><PRE>   tests['hsla'] = function() {
       // Same as rgba(), in fact, browsers re-map hsla() to rgba() internally,
       //   except IE9 who retains it as hsla
</PRE><PRE>       setCss('background-color:hsla(120,40%,100%,.5)');
</PRE><PRE>       return contains(mStyle.backgroundColor, 'rgba') || contains(mStyle.backgroundColor, 'hsla');
   };
</PRE><PRE>   tests['multiplebgs'] = function() {
       // Setting multiple images AND a color on the background shorthand property
       //  and then querying the style.background property value for the number of
       //  occurrences of &quot;url(&quot; is a reliable method for detecting ACTUAL support for this!
</PRE><PRE>       setCss('background:url(<A rel="nofollow" class="external free" href="https://),url(https://),red">https://),url(https://),red</A> url(<A rel="nofollow" class="external free" href="https://)'">https://)'</A>);
</PRE><PRE>       // If the UA supports multiple backgrounds, there should be three occurrences
       //   of the string &quot;url(&quot; in the return value for elemStyle.background
</PRE><PRE>       return (/(url\s*\(.*?){3}/).test(mStyle.background);
   };
</PRE><PRE>   // this will false positive in Opera Mini
   //   github.com/Modernizr/Modernizr/issues/396
</PRE><PRE>   tests['backgroundsize'] = function() {
       return testPropsAll('backgroundSize');
   };
</PRE><PRE>   tests['borderimage'] = function() {
       return testPropsAll('borderImage');
   };
</PRE><PRE>   // Super comprehensive table about all the unique implementations of
   // border-radius: muddledramblings.com/table-of-css3-border-radius-compliance
</PRE><PRE>   tests['borderradius'] = function() {
       return testPropsAll('borderRadius');
   };
</PRE><PRE>   // WebOS unfortunately false positives on this test.
   tests['boxshadow'] = function() {
       return testPropsAll('boxShadow');
   };
</PRE><PRE>   // FF3.0 will false positive on this test
   tests['textshadow'] = function() {
       return document.createElement('div').style.textShadow === <I>;</I>
   };
</PRE><PRE>   tests['opacity'] = function() {
       // Browsers that actually have CSS Opacity implemented have done so
       //  according to spec, which means their return values are within the
       //  range of [0.0,1.0] - including the leading zero.
</PRE><PRE>       setCssAll('opacity:.55');
</PRE><PRE>       // The non-literal . in this regex is intentional:
       //   German Chrome returns this value as 0,55
       // github.com/Modernizr/Modernizr/issues/#issue/59/comment/516632
       return (/^0.55$/).test(mStyle.opacity);
   };
</PRE><PRE>   // Note, Android &lt; 4 will pass this test, but can only animate
   //   a single property at a time
   //   daneden.me/2011/12/putting-up-with-androids-bullshit/
   tests['cssanimations'] = function() {
       return testPropsAll('animationName');
   };
</PRE><PRE>   tests['csscolumns'] = function() {
       return testPropsAll('columnCount');
   };
</PRE><PRE>   tests['cssgradients'] = function() {
       /**
        * For CSS Gradients syntax, please see:
        * webkit.org/blog/175/introducing-css-gradients/
        * developer.mozilla.org/en/CSS/-moz-linear-gradient
        * developer.mozilla.org/en/CSS/-moz-radial-gradient
        * dev.w3.org/csswg/css3-images/#gradients-
        */
</PRE><PRE>       var str1 = 'background-image:',
           str2 = 'gradient(linear,left top,right bottom,from(#9f9),to(white));',
           str3 = 'linear-gradient(left top,#9f9, white);';
</PRE><PRE>       setCss(
            // legacy webkit syntax (FIXME: remove when syntax not in use anymore)
             (str1 + '-webkit- '.split(' ').join(str2 + str1) +
            // standard syntax             // trailing 'background-image:'
             prefixes.join(str3 + str1)).slice(0, -str1.length)
       );
</PRE><PRE>       return contains(mStyle.backgroundImage, 'gradient');
   };
</PRE><PRE>   tests['cssreflections'] = function() {
       return testPropsAll('boxReflect');
   };
</PRE><PRE>   tests['csstransforms'] = function() {
       return !!testPropsAll('transform');
   };
</PRE><PRE>   tests['csstransforms3d'] = function() {
</PRE><PRE>       var ret = !!testPropsAll('perspective');
</PRE><PRE>       // Webkit's 3D transforms are passed off to the browser's own graphics renderer.
       //   It works fine in Safari on Leopard and Snow Leopard, but not in Chrome in
       //   some conditions. As a result, Webkit typically recognizes the syntax but
       //   will sometimes throw a false positive, thus we must do a more thorough check:
       if ( ret &amp;&amp; 'webkitPerspective' in docElement.style ) {
</PRE><PRE>         // Webkit allows this media query to succeed only if the feature is enabled.
         // `@media (transform-3d),(-webkit-transform-3d){ ... }`
         injectElementWithStyles('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function( node, rule ) {
           ret = node.offsetLeft === 9 &amp;&amp; node.offsetHeight === 3;
         });
       }
       return ret;
   };
</PRE><PRE>   tests['csstransitions'] = function() {
       return testPropsAll('transition');
   };
</PRE><PRE>   /*&gt;&gt;fontface*/
   // @font-face detection routine by Diego Perini
   // javascript.nwbox.com/CSSSupport/
</PRE><PRE>   // false positives:
   //   WebOS github.com/Modernizr/Modernizr/issues/342
   //   WP7   github.com/Modernizr/Modernizr/issues/538
   tests['fontface'] = function() {
       var bool;
</PRE><PRE>       injectElementWithStyles('@font-face {font-family:&quot;font&quot;;src:url(&quot;https://&quot;)}', function( node, rule ) {
         var style = document.getElementById('smodernizr'),
             sheet = style.sheet || style.styleSheet,
             cssText = sheet ? (sheet.cssRules &amp;&amp; sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || <I>) : </I>;
</PRE><PRE>         bool = /src/i.test(cssText) &amp;&amp; cssText.indexOf(rule.split(' ')[0]) === 0;
       });
</PRE><PRE>       return bool;
   };
   /*&gt;&gt;fontface*/
</PRE><PRE>   // CSS generated content detection
   tests['generatedcontent'] = function() {
       var bool;
</PRE><PRE>       injectElementWithStyles(['#',mod,'{font:0/0 a}#',mod,':after{content:&quot;',smile,'&quot;;visibility:hidden;font:3px/1 a}'].join(<I>), function( node ) {</I>
         bool = node.offsetHeight &gt;= 3;
       });
</PRE><PRE>       return bool;
   };
</PRE><PRE>   // These tests evaluate support of the video/audio elements, as well as
   // testing what types of content they support.
   //
   // We're using the Boolean constructor here, so that we can extend the value
   // e.g.  Modernizr.video     // true
   //       Modernizr.video.ogg // 'probably'
   //
   // Codec values from : github.com/NielsLeenheer/html5test/blob/9106a8/index.html#L845
   //                     thx to NielsLeenheer and zcorpan
</PRE><PRE>   // Note: in some older browsers, &quot;no&quot; was a return value instead of empty string.
   //   It was live in FF3.5.0 and 3.5.1, but fixed in 3.5.2
   //   It was also live in Safari 4.0.0 - 4.0.4, but fixed in 4.0.5
</PRE><PRE>   tests['video'] = function() {
       var elem = document.createElement('video'),
           bool = false;
</PRE><PRE>       // IE9 Running on Windows Server SKU can cause an exception to be thrown, bug #224
       try {
           if ( bool = !!elem.canPlayType ) {
               bool      = new Boolean(bool);
               bool.ogg  = elem.canPlayType('video/ogg; codecs=&quot;theora&quot;')      .replace(/^no$/,<I>);</I></PRE><PRE>               // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
               bool.h264 = elem.canPlayType('video/mp4; codecs=&quot;avc1.42E01E&quot;') .replace(/^no$/,<I>);</I></PRE><PRE>               bool.webm = elem.canPlayType('video/webm; codecs=&quot;vp8, vorbis&quot;').replace(/^no$/,<I>);</I>
           }
</PRE><PRE>       } catch(e) { }
</PRE><PRE>       return bool;
   };
</PRE><PRE>   tests['audio'] = function() {
       var elem = document.createElement('audio'),
           bool = false;
</PRE><PRE>       try {
           if ( bool = !!elem.canPlayType ) {
               bool      = new Boolean(bool);
               bool.ogg  = elem.canPlayType('audio/ogg; codecs=&quot;vorbis&quot;').replace(/^no$/,<I>);</I>
               bool.mp3  = elem.canPlayType('audio/mpeg;')               .replace(/^no$/,<I>);</I></PRE><PRE>               // Mimetypes accepted:
               //   developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
               //   bit.ly/iphoneoscodecs
               bool.wav  = elem.canPlayType('audio/wav; codecs=&quot;1&quot;')     .replace(/^no$/,<I>);</I>
               bool.m4a  = ( elem.canPlayType('audio/x-m4a;')            ||
                             elem.canPlayType('audio/aac;'))             .replace(/^no$/,<I>);</I>
           }
       } catch(e) { }
</PRE><PRE>       return bool;
   };
</PRE><PRE>   // In FF4, if disabled, window.localStorage should === null.
</PRE><PRE>   // Normally, we could not test that directly and need to do a
   //   `('localStorage' in window) &amp;&amp; ` test first because otherwise Firefox will
   //   throw bugzil.la/365772 if cookies are disabled
</PRE><PRE>   // Also in iOS5 Private Browsing mode, attempting to use localStorage.setItem
   // will throw the exception:
   //   QUOTA_EXCEEDED_ERRROR DOM Exception 22.
   // Peculiarly, getItem and removeItem calls do not throw.
</PRE><PRE>   // Because we are forced to try/catch this, we'll go aggressive.
</PRE><PRE>   // Just FWIW: IE8 Compat mode supports these features completely:
   //   www.quirksmode.org/dom/html5.html
   // But IE8 doesn't support either with local files
</PRE><PRE>   tests['localstorage'] = function() {
       try {
           localStorage.setItem(mod, mod);
           localStorage.removeItem(mod);
           return true;
       } catch(e) {
           return false;
       }
   };
</PRE><PRE>   tests['sessionstorage'] = function() {
       try {
           sessionStorage.setItem(mod, mod);
           sessionStorage.removeItem(mod);
           return true;
       } catch(e) {
           return false;
       }
   };
</PRE><PRE>   tests['webworkers'] = function() {
       return !!window.Worker;
   };
</PRE><PRE>   tests['applicationcache'] = function() {
       return !!window.applicationCache;
   };
</PRE><PRE>   // Thanks to Erik Dahlstrom
   tests['svg'] = function() {
       return !!document.createElementNS &amp;&amp; !!document.createElementNS(ns.svg, 'svg').createSVGRect;
   };
</PRE><PRE>   // specifically for SVG inline in HTML, not within XHTML
   // test page: paulirish.com/demo/inline-svg
   tests['inlinesvg'] = function() {
     var div = document.createElement('div');
     div.innerHTML = '&lt;svg/&gt;';
     return (div.firstChild &amp;&amp; div.firstChild.namespaceURI) == ns.svg;
   };
</PRE><PRE>   // SVG SMIL animation
   tests['smil'] = function() {
       return !!document.createElementNS &amp;&amp; /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, 'animate')));
   };
</PRE><PRE>   // This test is only for clip paths in SVG proper, not clip paths on HTML content
   // demo: srufaculty.sru.edu/david.dailey/svg/newstuff/clipPath4.svg
</PRE><PRE>   // However read the comments to dig into applying SVG clippaths to HTML content here:
   //   github.com/Modernizr/Modernizr/issues/213#issuecomment-1149491
   tests['svgclippaths'] = function() {
       return !!document.createElementNS &amp;&amp; /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, 'clipPath')));
   };
</PRE><PRE>   /*&gt;&gt;webforms*/
   // input features and input types go directly onto the ret object, bypassing the tests loop.
   // Hold this guy to execute in a moment.
   function webforms() {
       /*&gt;&gt;input*/
       // Run through HTML5's new input attributes to see if the UA understands any.
       // We're using f which is the &lt;input&gt; element created early on
       // Mike Taylr has created a comprehensive resource for testing these attributes
       //   when applied to all input types:
       //   miketaylr.com/code/input-type-attr.html
       // spec: www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
</PRE><PRE>       // Only input placeholder is tested while textarea's placeholder is not.
       // Currently Safari 4 and Opera 11 have support only for the input placeholder
       // Both tests are available in feature-detects/forms-placeholder.js
       Modernizr['input'] = (function( props ) {
           for ( var i = 0, len = props.length; i &lt; len; i++ ) {
               attrs[ props[i] ] = !!(props[i] in inputElem);
           }
           if (attrs.list){
             // safari false positive's on datalist: webk.it/74252
             // see also github.com/Modernizr/Modernizr/issues/146
             attrs.list = !!(document.createElement('datalist') &amp;&amp; window.HTMLDataListElement);
           }
           return attrs;
       })('autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '));
       /*&gt;&gt;input*/
</PRE><PRE>       /*&gt;&gt;inputtypes*/
       // Run through HTML5's new input types to see if the UA understands any.
       //   This is put behind the tests runloop because it doesn't return a
       //   true/false like all the other tests; instead, it returns an object
       //   containing each input type with its corresponding true/false value
</PRE><PRE>       // Big thanks to @miketaylr for the html5 forms expertise. miketaylr.com/
       Modernizr['inputtypes'] = (function(props) {
</PRE><PRE>           for ( var i = 0, bool, inputElemType, defaultView, len = props.length; i &lt; len; i++ ) {
</PRE><PRE>               inputElem.setAttribute('type', inputElemType = props[i]);
               bool = inputElem.type !== 'text';
</PRE><PRE>               // We first check to see if the type we give it sticks..
               // If the type does, we feed it a textual value, which shouldn't be valid.
               // If the value doesn't stick, we know there's input sanitization which infers a custom UI
               if ( bool ) {
</PRE><PRE>                   inputElem.value         = smile;
                   inputElem.style.cssText = 'position:absolute;visibility:hidden;';
</PRE><PRE>                   if ( /^range$/.test(inputElemType) &amp;&amp; inputElem.style.WebkitAppearance !== undefined ) {
</PRE><PRE>                     docElement.appendChild(inputElem);
                     defaultView = document.defaultView;
</PRE><PRE>                     // Safari 2-4 allows the smiley as a value, despite making a slider
                     bool =  defaultView.getComputedStyle &amp;&amp;
                             defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' &amp;&amp;
                             // Mobile android web browser has false positive, so must
                             // check the height to see if the widget is actually there.
                             (inputElem.offsetHeight !== 0);
</PRE><PRE>                     docElement.removeChild(inputElem);
</PRE><PRE>                   } else if ( /^(search|tel)$/.test(inputElemType) ){
                     // Spec doesn't define any special parsing or detectable UI
                     //   behaviors so we pass these through as true
</PRE><PRE>                     // Interestingly, opera fails the earlier test, so it doesn't
                     //  even make it here.
</PRE><PRE>                   } else if ( /^(url|email)$/.test(inputElemType) ) {
                     // Real url and email support comes with prebaked validation.
                     bool = inputElem.checkValidity &amp;&amp; inputElem.checkValidity() === false;
</PRE><PRE>                   } else {
                     // If the upgraded input compontent rejects the :) text, we got a winner
                     bool = inputElem.value != smile;
                   }
               }
</PRE><PRE>               inputs[ props[i] ] = !!bool;
           }
           return inputs;
       })('search tel url email datetime date month week time datetime-local number range color'.split(' '));
       /*&gt;&gt;inputtypes*/
   }
   /*&gt;&gt;webforms*/
</PRE><PRE>   // End of test definitions
   // -----------------------
</PRE><PRE>   // Run through all tests and detect their support in the current UA.
   // todo: hypothetically we could be doing an array of tests and use a basic loop here.
   for ( var feature in tests ) {
       if ( hasOwnProp(tests, feature) ) {
           // run the test, throw the return value into the Modernizr,
           //   then based on that boolean, define an appropriate className
           //   and push it into an array of classes we'll join later.
           featureName  = feature.toLowerCase();
           Modernizr[featureName] = tests[feature]();
</PRE><PRE>           classes.push((Modernizr[featureName] ? <I> : 'no-') + featureName);</I>
       }
   }
</PRE><PRE>   /*&gt;&gt;webforms*/
   // input tests need to run.
   Modernizr.input || webforms();
   /*&gt;&gt;webforms*/
</PRE><PRE>   /**
    * addTest allows the user to define their own feature tests
    * the result will be added onto the Modernizr object,
    * as well as an appropriate className set on the html element
    *
    * @param feature - String naming the feature
    * @param test - Function returning true if feature is supported, false if not
    */
    Modernizr.addTest = function ( feature, test ) {
      if ( typeof feature == 'object' ) {
        for ( var key in feature ) {
          if ( hasOwnProp( feature, key ) ) {
            Modernizr.addTest( key, feature[ key ] );
          }
        }
      } else {
</PRE><PRE>        feature = feature.toLowerCase();
</PRE><PRE>        if ( Modernizr[feature] !== undefined ) {
          // we're going to quit if you're trying to overwrite an existing test
          // if we were to allow it, we'd do this:
          //   var re = new RegExp(&quot;\\b(no-)?&quot; + feature + &quot;\\b&quot;);
          //   docElement.className = docElement.className.replace( re, <I> );</I>
          // but, no rly, stuff 'em.
          return Modernizr;
        }
</PRE><PRE>        test = typeof test == 'function' ? test() : test;
</PRE><PRE>        if (typeof enableClasses !== &quot;undefined&quot; &amp;&amp; enableClasses) {
          docElement.className += ' ' + (test ? <I> : 'no-') + feature;</I>
        }
        Modernizr[feature] = test;
</PRE><PRE>      }
</PRE><PRE>      return Modernizr; // allow chaining.
    };
</PRE><PRE>   // Reset modElem.cssText to nothing to reduce memory footprint.
   setCss(<I>);</I>
   modElem = inputElem = null;
</PRE><PRE>   /*&gt;&gt;shiv*/
   /**
    * @preserve HTML5 Shiv prev3.7.1 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
    */
   ;(function(window, document) {
       /*jshint evil:true */
       /** version */
       var version = '3.7.0';
</PRE><PRE>       /** Preset options */
       var options = window.html5 || {};
</PRE><PRE>       /** Used to skip problem elements */
       var reSkip = /^&lt;|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;
</PRE><PRE>       /** Not all elements can be cloned in IE **/
       var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;
</PRE><PRE>       /** Detect whether the browser supports default html5 styles */
       var supportsHtml5Styles;
</PRE><PRE>       /** Name of the expando, to work with multiple documents or to re-shiv one document */
       var expando = '_html5shiv';
</PRE><PRE>       /** The id for the the documents expando */
       var expanID = 0;
</PRE><PRE>       /** Cached data for each document */
       var expandoData = {};
</PRE><PRE>       /** Detect whether the browser supports unknown elements */
       var supportsUnknownElements;
</PRE><PRE>       (function() {
         try {
           var a = document.createElement('a');
           a.innerHTML = '&lt;xyz&gt;&lt;/xyz&gt;';
           //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
           supportsHtml5Styles = ('hidden' in a);
</PRE><PRE>           supportsUnknownElements = a.childNodes.length == 1 || (function() {
             // assign a false positive if unable to shiv
             (document.createElement)('a');
             var frag = document.createDocumentFragment();
             return (
               typeof frag.cloneNode == 'undefined' ||
               typeof frag.createDocumentFragment == 'undefined' ||
               typeof frag.createElement == 'undefined'
             );
           }());
         } catch(e) {
           // assign a false positive if detection fails =&gt; unable to shiv
           supportsHtml5Styles = true;
           supportsUnknownElements = true;
         }
</PRE><PRE>       }());
</PRE><PRE>       /*--------------------------------------------------------------------------*/
</PRE><PRE>       /**
        * Creates a style sheet with the given CSS text and adds it to the document.
        * @private
        * @param {Document} ownerDocument The document.
        * @param {String} cssText The CSS text.
        * @returns {StyleSheet} The style element.
        */
       function addStyleSheet(ownerDocument, cssText) {
         var p = ownerDocument.createElement('p'),
         parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;
</PRE><PRE>         p.innerHTML = 'x&lt;style&gt;' + cssText + '&lt;/style&gt;';
         return parent.insertBefore(p.lastChild, parent.firstChild);
       }
</PRE><PRE>       /**
        * Returns the value of `html5.elements` as an array.
        * @private
        * @returns {Array} An array of shived element node names.
        */
       function getElements() {
         var elements = html5.elements;
         return typeof elements == 'string' ? elements.split(' ') : elements;
       }
</PRE><PRE>       /**
        * Returns the data associated to the given document
        * @private
        * @param {Document} ownerDocument The document.
        * @returns {Object} An object of data.
        */
       function getExpandoData(ownerDocument) {
         var data = expandoData[ownerDocument[expando]];
         if (!data) {
           data = {};
           expanID++;
           ownerDocument[expando] = expanID;
           expandoData[expanID] = data;
         }
         return data;
       }
</PRE><PRE>       /**
        * returns a shived element for the given nodeName and document
        * @memberOf html5
        * @param {String} nodeName name of the element
        * @param {Document} ownerDocument The context document.
        * @returns {Object} The shived element.
        */
       function createElement(nodeName, ownerDocument, data){
         if (!ownerDocument) {
           ownerDocument = document;
         }
         if(supportsUnknownElements){
           return ownerDocument.createElement(nodeName);
         }
         if (!data) {
           data = getExpandoData(ownerDocument);
         }
         var node;
</PRE><PRE>         if (data.cache[nodeName]) {
           node = data.cache[nodeName].cloneNode();
         } else if (saveClones.test(nodeName)) {
           node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
         } else {
           node = data.createElem(nodeName);
         }
</PRE><PRE>         // Avoid adding some elements to fragments in IE &lt; 9 because
         // * Attributes like `name` or `type` cannot be set/changed once an element
         //   is inserted into a document/fragment
         // * Link elements with `src` attributes that are inaccessible, as with
         //   a 403 response, will cause the tab/window to crash
         // * Script elements appended to fragments will execute when their `src`
         //   or `text` property is set
         return node.canHaveChildren &amp;&amp; !reSkip.test(nodeName) &amp;&amp; !node.tagUrn ? data.frag.appendChild(node) : node;
       }
</PRE><PRE>       /**
        * returns a shived DocumentFragment for the given document
        * @memberOf html5
        * @param {Document} ownerDocument The context document.
        * @returns {Object} The shived DocumentFragment.
        */
       function createDocumentFragment(ownerDocument, data){
         if (!ownerDocument) {
           ownerDocument = document;
         }
         if(supportsUnknownElements){
           return ownerDocument.createDocumentFragment();
         }
         data = data || getExpandoData(ownerDocument);
         var clone = data.frag.cloneNode(),
         i = 0,
         elems = getElements(),
         l = elems.length;
         for(;i&lt;l;i++){
           clone.createElement(elems[i]);
         }
         return clone;
       }
</PRE><PRE>       /**
        * Shivs the `createElement` and `createDocumentFragment` methods of the document.
        * @private
        * @param {Document|DocumentFragment} ownerDocument The document.
        * @param {Object} data of the document.
        */
       function shivMethods(ownerDocument, data) {
         if (!data.cache) {
           data.cache = {};
           data.createElem = ownerDocument.createElement;
           data.createFrag = ownerDocument.createDocumentFragment;
           data.frag = data.createFrag();
         }
</PRE><PRE>         ownerDocument.createElement = function(nodeName) {
           //abort shiv
           if (!html5.shivMethods) {
             return data.createElem(nodeName);
           }
           return createElement(nodeName, ownerDocument, data);
         };
</PRE><PRE>         ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
                                                         'var n=f.cloneNode(),c=n.createElement;' +
                                                         'h.shivMethods&amp;&amp;(' +
                                                         // unroll the `createElement` calls
                                                         getElements().join().replace(/[\w\-]+/g, function(nodeName) {
           data.createElem(nodeName);
           data.frag.createElement(nodeName);
           return 'c(&quot;' + nodeName + '&quot;)';
         }) +
           ');return n}'
                                                        )(html5, data.frag);
       }
</PRE><PRE>       /*--------------------------------------------------------------------------*/
</PRE><PRE>       /**
        * Shivs the given document.
        * @memberOf html5
        * @param {Document} ownerDocument The document to shiv.
        * @returns {Document} The shived document.
        */
       function shivDocument(ownerDocument) {
         if (!ownerDocument) {
           ownerDocument = document;
         }
         var data = getExpandoData(ownerDocument);
</PRE><PRE>         if (html5.shivCSS &amp;&amp; !supportsHtml5Styles &amp;&amp; !data.hasCSS) {
           data.hasCSS = !!addStyleSheet(ownerDocument,
                                         // corrects block display not defined in IE6/7/8/9
                                         'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
                                           // adds styling not present in IE6/7/8/9
                                           'mark{background:#FF0;color:#000}' +
                                           // hides non-rendered elements
                                           'template{display:none}'
                                        );
         }
         if (!supportsUnknownElements) {
           shivMethods(ownerDocument, data);
         }
         return ownerDocument;
       }
</PRE><PRE>       /*--------------------------------------------------------------------------*/
</PRE><PRE>       /**
        * The `html5` object is exposed so that more elements can be shived and
        * existing shiving can be detected on iframes.
        * @type Object
        * @example
        *
        * // options can be changed before the script is included
        * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
        */
       var html5 = {
</PRE><PRE>         /**
          * An array or space separated string of node names of the elements to shiv.
          * @memberOf html5
          * @type Array|String
          */
         'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video',
</PRE><PRE>         /**
          * current version of html5shiv
          */
         'version': version,
</PRE><PRE>         /**
          * A flag to indicate that the HTML5 style sheet should be inserted.
          * @memberOf html5
          * @type Boolean
          */
         'shivCSS': (options.shivCSS !== false),
</PRE><PRE>         /**
          * Is equal to true if a browser supports creating unknown/HTML5 elements
          * @memberOf html5
          * @type boolean
          */
         'supportsUnknownElements': supportsUnknownElements,
</PRE><PRE>         /**
          * A flag to indicate that the document's `createElement` and `createDocumentFragment`
          * methods should be overwritten.
          * @memberOf html5
          * @type Boolean
          */
         'shivMethods': (options.shivMethods !== false),
</PRE><PRE>         /**
          * A string to describe the type of `html5` object (&quot;default&quot; or &quot;default print&quot;).
          * @memberOf html5
          * @type String
          */
         'type': 'default',
</PRE><PRE>         // shivs the document according to the specified `html5` object options
         'shivDocument': shivDocument,
</PRE><PRE>         //creates a shived element
         createElement: createElement,
</PRE><PRE>         //creates a shived documentFragment
         createDocumentFragment: createDocumentFragment
       };
</PRE><PRE>       /*--------------------------------------------------------------------------*/
</PRE><PRE>       // expose html5
       window.html5 = html5;
</PRE><PRE>       // shiv the document
       shivDocument(document);
</PRE><PRE>   }(this, document));
   /*&gt;&gt;shiv*/
</PRE><PRE>   // Assign private properties to the return object with prefix
   Modernizr._version      = version;
</PRE><PRE>   // expose these for the plugin API. Look in the source for how to join() them against your input
   /*&gt;&gt;prefixes*/
   Modernizr._prefixes     = prefixes;
   /*&gt;&gt;prefixes*/
   /*&gt;&gt;domprefixes*/
   Modernizr._domPrefixes  = domPrefixes;
   Modernizr._cssomPrefixes  = cssomPrefixes;
   /*&gt;&gt;domprefixes*/
</PRE><PRE>   /*&gt;&gt;mq*/
   // Modernizr.mq tests a given media query, live against the current state of the window
   // A few important notes:
   //   * If a browser does not support media queries at all (eg. oldIE) the mq() will always return false
   //   * A max-width or orientation query will be evaluated against the current state, which may change later.
   //   * You must specify values. Eg. If you are testing support for the min-width media query use:
   //       Modernizr.mq('(min-width:0)')
   // usage:
   // Modernizr.mq('only screen and (max-width:768)')
   Modernizr.mq            = testMediaQuery;
   /*&gt;&gt;mq*/
</PRE><PRE>   /*&gt;&gt;hasevent*/
   // Modernizr.hasEvent() detects support for a given event, with an optional element to test on
   // Modernizr.hasEvent('gesturestart', elem)
   Modernizr.hasEvent      = isEventSupported;
   /*&gt;&gt;hasevent*/
</PRE><PRE>   /*&gt;&gt;testprop*/
   // Modernizr.testProp() investigates whether a given style property is recognized
   // Note that the property names must be provided in the camelCase variant.
   // Modernizr.testProp('pointerEvents')
   Modernizr.testProp      = function(prop){
       return testProps([prop]);
   };
   /*&gt;&gt;testprop*/
</PRE><PRE>   /*&gt;&gt;testallprops*/
   // Modernizr.testAllProps() investigates whether a given style property,
   //   or any of its vendor-prefixed variants, is recognized
   // Note that the property names must be provided in the camelCase variant.
   // Modernizr.testAllProps('boxSizing')
   Modernizr.testAllProps  = testPropsAll;
   /*&gt;&gt;testallprops*/
</PRE><PRE>   /*&gt;&gt;teststyles*/
   // Modernizr.testStyles() allows you to add custom styles to the document and test an element afterwards
   // Modernizr.testStyles('#modernizr { position:absolute }', function(elem, rule){ ... })
   Modernizr.testStyles    = injectElementWithStyles;
   /*&gt;&gt;teststyles*/
</PRE><PRE>   /*&gt;&gt;prefixed*/
   // Modernizr.prefixed() returns the prefixed or nonprefixed property name variant of your input
   // Modernizr.prefixed('boxSizing') // 'MozBoxSizing'
</PRE><PRE>   // Properties must be passed as dom-style camelcase, rather than `box-sizing` hypentated style.
   // Return values will also be the camelCase variant, if you need to translate that to hypenated style use:
   //
   //     str.replace(/([A-Z])/g, function(str,m1){ return '-' + m1.toLowerCase(); }).replace(/^ms-/,'-ms-');
</PRE><PRE>   // If you're trying to ascertain which transition end event to bind to, you might do something like...
   //
   //     var transEndEventNames = {
   //       'WebkitTransition' : 'webkitTransitionEnd',
   //       'MozTransition'    : 'transitionend',
   //       'OTransition'      : 'oTransitionEnd',
   //       'msTransition'     : 'MSTransitionEnd',
   //       'transition'       : 'transitionend'
   //     },
   //     transEndEventName = transEndEventNames[ Modernizr.prefixed('transition') ];
</PRE><PRE>   Modernizr.prefixed      = function(prop, obj, elem){
     if(!obj) {
       return testPropsAll(prop, 'pfx');
     } else {
       // Testing DOM property e.g. Modernizr.prefixed('requestAnimationFrame', window) // 'mozRequestAnimationFrame'
       return testPropsAll(prop, obj, elem);
     }
   };
   /*&gt;&gt;prefixed*/
</PRE><PRE>   /*&gt;&gt;cssclasses*/
   // Remove &quot;no-js&quot; class from  element, if it exists:
    docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') +

                            // Add the new classes to the  element.
                            (enableClasses ? ' js ' + classes.join(' ') : '');
    /*&gt;&gt;cssclasses*/

    return Modernizr;

})(this, this.document);
</PRE></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
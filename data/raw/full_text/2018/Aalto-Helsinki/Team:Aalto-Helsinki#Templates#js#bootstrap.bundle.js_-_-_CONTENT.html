<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Aalto-Helsinki_Templates_js_bootstrap_bundle_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Aalto-Helsinki/Templates/js/bootstrap.bundle.js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE> * Bootstrap v4.1.3 (<A rel="nofollow" class="external free" href="https://getbootstrap.com/">https://getbootstrap.com/</A>)
 * Copyright 2011-2018 The Bootstrap Authors (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/graphs/contributors">https://github.com/twbs/bootstrap/graphs/contributors</A>)
 * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
 */
</PRE><P>(function (global, factory) {
</P><PRE> typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? factory(exports, require('jquery')) :
 typeof define === 'function' &amp;&amp; define.amd ? define(['exports', 'jquery'], factory) :
 (factory((global.bootstrap = {}),global.jQuery));
</PRE><P>}(this, (function (exports,$) { 'use strict';
</P><PRE> $ = $ &amp;&amp; $.hasOwnProperty('default') ? $['default'] : $;
</PRE><PRE> function _defineProperties(target, props) {
   for (var i = 0; i &lt; props.length; i++) {
     var descriptor = props[i];
     descriptor.enumerable = descriptor.enumerable || false;
     descriptor.configurable = true;
     if (&quot;value&quot; in descriptor) descriptor.writable = true;
     Object.defineProperty(target, descriptor.key, descriptor);
   }
 }
</PRE><PRE> function _createClass(Constructor, protoProps, staticProps) {
   if (protoProps) _defineProperties(Constructor.prototype, protoProps);
   if (staticProps) _defineProperties(Constructor, staticProps);
   return Constructor;
 }
</PRE><PRE> function _defineProperty(obj, key, value) {
   if (key in obj) {
     Object.defineProperty(obj, key, {
       value: value,
       enumerable: true,
       configurable: true,
       writable: true
     });
   } else {
     obj[key] = value;
   }
</PRE><PRE>   return obj;
 }
</PRE><PRE> function _objectSpread(target) {
   for (var i = 1; i &lt; arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
     var ownKeys = Object.keys(source);
</PRE><PRE>     if (typeof Object.getOwnPropertySymbols === 'function') {
       ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
         return Object.getOwnPropertyDescriptor(source, sym).enumerable;
       }));
     }
</PRE><PRE>     ownKeys.forEach(function (key) {
       _defineProperty(target, key, source[key]);
     });
   }
</PRE><PRE>   return target;
 }
</PRE><PRE> function _inheritsLoose(subClass, superClass) {
   subClass.prototype = Object.create(superClass.prototype);
   subClass.prototype.constructor = subClass;
   subClass.__proto__ = superClass;
 }
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): util.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Util = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Private TransitionEnd Helpers
    * ------------------------------------------------------------------------
    */
   var TRANSITION_END = 'transitionend';
   var MAX_UID = 1000000;
   var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (<A rel="nofollow" class="external free" href="https://goo.gl/pxwQGp">https://goo.gl/pxwQGp</A>)
</PRE><PRE>   function toType(obj) {
     return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
   }
</PRE><PRE>   function getSpecialTransitionEndEvent() {
     return {
       bindType: TRANSITION_END,
       delegateType: TRANSITION_END,
       handle: function handle(event) {
         if ($$$1(event.target).is(this)) {
           return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
         }
</PRE><PRE>         return undefined; // eslint-disable-line no-undefined
       }
     };
   }
</PRE><PRE>   function transitionEndEmulator(duration) {
     var _this = this;
</PRE><PRE>     var called = false;
     $$$1(this).one(Util.TRANSITION_END, function () {
       called = true;
     });
     setTimeout(function () {
       if (!called) {
         Util.triggerTransitionEnd(_this);
       }
     }, duration);
     return this;
   }
</PRE><PRE>   function setTransitionEndSupport() {
     $$$1.fn.emulateTransitionEnd = transitionEndEmulator;
     $$$1.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
   }
   /**
    * --------------------------------------------------------------------------
    * Public Util Api
    * --------------------------------------------------------------------------
    */
</PRE><PRE>   var Util = {
     TRANSITION_END: 'bsTransitionEnd',
     getUID: function getUID(prefix) {
       do {
         // eslint-disable-next-line no-bitwise
         prefix += ~~(Math.random() * MAX_UID); // &quot;~~&quot; acts like a faster Math.floor() here
       } while (document.getElementById(prefix));
</PRE><PRE>       return prefix;
     },
     getSelectorFromElement: function getSelectorFromElement(element) {
       var selector = element.getAttribute('data-target');
</PRE><PRE>       if (!selector || selector === '#') {
         selector = element.getAttribute('href') || <I>;</I>
       }
</PRE><PRE>       try {
         return document.querySelector(selector) ? selector : null;
       } catch (err) {
         return null;
       }
     },
     getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
       if (!element) {
         return 0;
       } // Get transition-duration of the element
</PRE><PRE>       var transitionDuration = $$$1(element).css('transition-duration');
       var floatTransitionDuration = parseFloat(transitionDuration); // Return 0 if element or transition duration is not found
</PRE><PRE>       if (!floatTransitionDuration) {
         return 0;
       } // If multiple durations are defined, take the first
</PRE><PRE>       transitionDuration = transitionDuration.split(',')[0];
       return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;
     },
     reflow: function reflow(element) {
       return element.offsetHeight;
     },
     triggerTransitionEnd: function triggerTransitionEnd(element) {
       $$$1(element).trigger(TRANSITION_END);
     },
     // TODO: Remove in v5
     supportsTransitionEnd: function supportsTransitionEnd() {
       return Boolean(TRANSITION_END);
     },
     isElement: function isElement(obj) {
       return (obj[0] || obj).nodeType;
     },
     typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
       for (var property in configTypes) {
         if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
           var expectedTypes = configTypes[property];
           var value = config[property];
           var valueType = value &amp;&amp; Util.isElement(value) ? 'element' : toType(value);
</PRE><PRE>           if (!new RegExp(expectedTypes).test(valueType)) {
             throw new Error(componentName.toUpperCase() + &quot;: &quot; + (&quot;Option \&quot;&quot; + property + &quot;\&quot; provided type \&quot;&quot; + valueType + &quot;\&quot; &quot;) + (&quot;but expected type \&quot;&quot; + expectedTypes + &quot;\&quot;.&quot;));
           }
         }
       }
     }
   };
   setTransitionEndSupport();
   return Util;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): alert.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Alert = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'alert';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.alert';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var Selector = {
     DISMISS: '[data-dismiss=&quot;alert&quot;]'
   };
   var Event = {
     CLOSE: &quot;close&quot; + EVENT_KEY,
     CLOSED: &quot;closed&quot; + EVENT_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     ALERT: 'alert',
     FADE: 'fade',
     SHOW: 'show'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Alert =
   /*#__PURE__*/
   function () {
     function Alert(element) {
       this._element = element;
     } // Getters
</PRE><PRE>     var _proto = Alert.prototype;
</PRE><PRE>     // Public
     _proto.close = function close(element) {
       var rootElement = this._element;
</PRE><PRE>       if (element) {
         rootElement = this._getRootElement(element);
       }
</PRE><PRE>       var customEvent = this._triggerCloseEvent(rootElement);
</PRE><PRE>       if (customEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       this._removeElement(rootElement);
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       this._element = null;
     }; // Private
</PRE><PRE>     _proto._getRootElement = function _getRootElement(element) {
       var selector = Util.getSelectorFromElement(element);
       var parent = false;
</PRE><PRE>       if (selector) {
         parent = document.querySelector(selector);
       }
</PRE><PRE>       if (!parent) {
         parent = $$$1(element).closest(&quot;.&quot; + ClassName.ALERT)[0];
       }
</PRE><PRE>       return parent;
     };
</PRE><PRE>     _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
       var closeEvent = $$$1.Event(Event.CLOSE);
       $$$1(element).trigger(closeEvent);
       return closeEvent;
     };
</PRE><PRE>  _proto._removeElement = function _removeElement(element) {
       var _this = this;
</PRE><PRE>       $$$1(element).removeClass(ClassName.SHOW);
</PRE><PRE>       if (!$$$1(element).hasClass(ClassName.FADE)) {
         this._destroyElement(element);
</PRE><PRE>         return;
       }
</PRE><PRE>       var transitionDuration = Util.getTransitionDurationFromElement(element);
       $$$1(element).one(Util.TRANSITION_END, function (event) {
         return _this._destroyElement(element, event);
       }).emulateTransitionEnd(transitionDuration);
     };
</PRE><PRE>     _proto._destroyElement = function _destroyElement(element) {
       $$$1(element).detach().trigger(Event.CLOSED).remove();
     }; // Static
</PRE><PRE>     Alert._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var $element = $$$1(this);
         var data = $element.data(DATA_KEY);
</PRE><PRE>         if (!data) {
           data = new Alert(this);
           $element.data(DATA_KEY, data);
         }
</PRE><PRE>         if (config === 'close') {
           data[config](this);
         }
       });
     };
</PRE><PRE>     Alert._handleDismiss = function _handleDismiss(alertInstance) {
       return function (event) {
         if (event) {
           event.preventDefault();
         }
</PRE><PRE>         alertInstance.close(this);
       };
     };
</PRE><PRE>     _createClass(Alert, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }]);
</PRE><PRE>     return Alert;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Alert._jQueryInterface;
   $$$1.fn[NAME].Constructor = Alert;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Alert._jQueryInterface;
   };
</PRE><PRE>   return Alert;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): button.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Button = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'button';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.button';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var ClassName = {
     ACTIVE: 'active',
     BUTTON: 'btn',
     FOCUS: 'focus'
   };
   var Selector = {
     DATA_TOGGLE_CARROT: '[data-toggle^=&quot;button&quot;]',
     DATA_TOGGLE: '[data-toggle=&quot;buttons&quot;]',
     INPUT: 'input',
     ACTIVE: '.active',
     BUTTON: '.btn'
   };
   var Event = {
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
     FOCUS_BLUR_DATA_API: &quot;focus&quot; + EVENT_KEY + DATA_API_KEY + &quot; &quot; + (&quot;blur&quot; + EVENT_KEY + DATA_API_KEY)
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Button =
   /*#__PURE__*/
   function () {
     function Button(element) {
       this._element = element;
     } // Getters
</PRE><PRE>     var _proto = Button.prototype;
</PRE><PRE>    // Public
     _proto.toggle = function toggle() {
       var triggerChangeEvent = true;
       var addAriaPressed = true;
       var rootElement = $$$1(this._element).closest(Selector.DATA_TOGGLE)[0];
</PRE><PRE>       if (rootElement) {
         var input = this._element.querySelector(Selector.INPUT);
</PRE><PRE>         if (input) {
           if (input.type === 'radio') {
             if (input.checked &amp;&amp; this._element.classList.contains(ClassName.ACTIVE)) {
               triggerChangeEvent = false;
             } else {
               var activeElement = rootElement.querySelector(Selector.ACTIVE);
</PRE><PRE>               if (activeElement) {
                 $$$1(activeElement).removeClass(ClassName.ACTIVE);
               }
             }
           }
</PRE><PRE>           if (triggerChangeEvent) {
             if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
               return;
             }
</PRE><PRE>             input.checked = !this._element.classList.contains(ClassName.ACTIVE);
             $$$1(input).trigger('change');
           }
</PRE><PRE>           input.focus();
           addAriaPressed = false;
         }
       }
</PRE><PRE>       if (addAriaPressed) {
         this._element.setAttribute('aria-pressed', !this._element.classList.contains(ClassName.ACTIVE));
       }
</PRE><PRE>       if (triggerChangeEvent) {
         $$$1(this._element).toggleClass(ClassName.ACTIVE);
       }
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       this._element = null;
     }; // Static
</PRE><PRE>     Button._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         if (!data) {
           data = new Button(this);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (config === 'toggle') {
           data[config]();
         }
       });
     };
</PRE><PRE>     _createClass(Button, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }]);
</PRE><PRE>     return Button;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
     event.preventDefault();
     var button = event.target;
</PRE><PRE>     if (!$$$1(button).hasClass(ClassName.BUTTON)) {
       button = $$$1(button).closest(Selector.BUTTON);
     }
</PRE><PRE>     Button._jQueryInterface.call($$$1(button), 'toggle');
   }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
     var button = $$$1(event.target).closest(Selector.BUTTON)[0];
     $$$1(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Button._jQueryInterface;
   $$$1.fn[NAME].Constructor = Button;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Button._jQueryInterface;
   };
</PRE><PRE>   return Button;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): carousel.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Carousel = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'carousel';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.carousel';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key
</PRE><PRE>   var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key
</PRE><PRE>   var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch
</PRE><PRE>   var Default = {
     interval: 5000,
     keyboard: true,
     slide: false,
     pause: 'hover',
     wrap: true
   };
   var DefaultType = {
     interval: '(number|boolean)',
     keyboard: 'boolean',
     slide: '(boolean|string)',
     pause: '(string|boolean)',
     wrap: 'boolean'
   };
   var Direction = {
     NEXT: 'next',
     PREV: 'prev',
     LEFT: 'left',
     RIGHT: 'right'
   };
   var Event = {
     SLIDE: &quot;slide&quot; + EVENT_KEY,
     SLID: &quot;slid&quot; + EVENT_KEY,
     KEYDOWN: &quot;keydown&quot; + EVENT_KEY,
     MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
     MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY,
     TOUCHEND: &quot;touchend&quot; + EVENT_KEY,
     LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     CAROUSEL: 'carousel',
     ACTIVE: 'active',
     SLIDE: 'slide',
     RIGHT: 'carousel-item-right',
     LEFT: 'carousel-item-left',
     NEXT: 'carousel-item-next',
     PREV: 'carousel-item-prev',
     ITEM: 'carousel-item'
   };
   var Selector = {
     ACTIVE: '.active',
     ACTIVE_ITEM: '.active.carousel-item',
     ITEM: '.carousel-item',
     NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
     INDICATORS: '.carousel-indicators',
     DATA_SLIDE: '[data-slide], [data-slide-to]',
     DATA_RIDE: '[data-ride=&quot;carousel&quot;]'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Carousel =
   /*#__PURE__*/
   function () {
     function Carousel(element, config) {
       this._items = null;
       this._interval = null;
       this._activeElement = null;
       this._isPaused = false;
       this._isSliding = false;
       this.touchTimeout = null;
       this._config = this._getConfig(config);
       this._element = $$$1(element)[0];
       this._indicatorsElement = this._element.querySelector(Selector.INDICATORS);
</PRE><PRE>       this._addEventListeners();
     } // Getters
</PRE><PRE>     var _proto = Carousel.prototype;
</PRE><PRE>     // Public
     _proto.next = function next() {
       if (!this._isSliding) {
         this._slide(Direction.NEXT);
       }
     };
</PRE><PRE>     _proto.nextWhenVisible = function nextWhenVisible() {
       // Don't call next when the page isn't visible
       // or the carousel or its parent isn't visible
       if (!document.hidden &amp;&amp; $$$1(this._element).is(':visible') &amp;&amp; $$$1(this._element).css('visibility') !== 'hidden') {
         this.next();
       }
     };
</PRE><PRE>     _proto.prev = function prev() {
       if (!this._isSliding) {
         this._slide(Direction.PREV);
       }
     };
</PRE><PRE>     _proto.pause = function pause(event) {
       if (!event) {
         this._isPaused = true;
       }
</PRE><PRE>       if (this._element.querySelector(Selector.NEXT_PREV)) {
         Util.triggerTransitionEnd(this._element);
         this.cycle(true);
       }
</PRE><PRE>       clearInterval(this._interval);
       this._interval = null;
     };
</PRE><PRE>     _proto.cycle = function cycle(event) {
       if (!event) {
         this._isPaused = false;
       }
</PRE><PRE>       if (this._interval) {
         clearInterval(this._interval);
         this._interval = null;
       }
</PRE><PRE>       if (this._config.interval &amp;&amp; !this._isPaused) {
         this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
       }
     };
</PRE><PRE>     _proto.to = function to(index) {
       var _this = this;
</PRE><PRE>       this._activeElement = this._element.querySelector(Selector.ACTIVE_ITEM);
</PRE><PRE>       var activeIndex = this._getItemIndex(this._activeElement);
</PRE><PRE>       if (index &gt; this._items.length - 1 || index &lt; 0) {
         return;
       }
</PRE><PRE>       if (this._isSliding) {
         $$$1(this._element).one(Event.SLID, function () {
           return _this.to(index);
         });
         return;
       }
</PRE><PRE>       if (activeIndex === index) {
         this.pause();
         this.cycle();
         return;
       }
</PRE><PRE>       var direction = index &gt; activeIndex ? Direction.NEXT : Direction.PREV;
</PRE><PRE>       this._slide(direction, this._items[index]);
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1(this._element).off(EVENT_KEY);
       $$$1.removeData(this._element, DATA_KEY);
       this._items = null;
       this._config = null;
       this._element = null;
       this._interval = null;
       this._isPaused = null;
       this._isSliding = null;
       this._activeElement = null;
       this._indicatorsElement = null;
     }; // Private
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, Default, config);
       Util.typeCheckConfig(NAME, config, DefaultType);
       return config;
     };
</PRE><PRE>     _proto._addEventListeners = function _addEventListeners() {
       var _this2 = this;
</PRE><PRE>       if (this._config.keyboard) {
         $$$1(this._element).on(Event.KEYDOWN, function (event) {
           return _this2._keydown(event);
         });
       }
</PRE><PRE>       if (this._config.pause === 'hover') {
         $$$1(this._element).on(Event.MOUSEENTER, function (event) {
           return _this2.pause(event);
         }).on(Event.MOUSELEAVE, function (event) {
           return _this2.cycle(event);
         });
</PRE><PRE>         if ('ontouchstart' in document.documentElement) {
           // If it's a touch-enabled device, mouseenter/leave are fired as
           // part of the mouse compatibility events on first tap - the carousel
           // would stop cycling until user tapped out of it;
           // here, we listen for touchend, explicitly pause the carousel
           // (as if it's the second time we tap on it, mouseenter compat event
           // is NOT fired) and after a timeout (to allow for mouse compatibility
           // events to fire) we explicitly restart cycling
           $$$1(this._element).on(Event.TOUCHEND, function () {
             _this2.pause();
</PRE><PRE>             if (_this2.touchTimeout) {
               clearTimeout(_this2.touchTimeout);
             }
</PRE><PRE>             _this2.touchTimeout = setTimeout(function (event) {
               return _this2.cycle(event);
             }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);
           });
         }
       }
     };
</PRE><PRE>     _proto._keydown = function _keydown(event) {
       if (/input|textarea/i.test(event.target.tagName)) {
         return;
       }
</PRE><PRE>       switch (event.which) {
         case ARROW_LEFT_KEYCODE:
           event.preventDefault();
           this.prev();
           break;
</PRE><PRE>         case ARROW_RIGHT_KEYCODE:
           event.preventDefault();
           this.next();
           break;
</PRE><PRE>         default:
       }
     };
</PRE><PRE>     _proto._getItemIndex = function _getItemIndex(element) {
       this._items = element &amp;&amp; element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector.ITEM)) : [];
       return this._items.indexOf(element);
     };
</PRE><PRE>     _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
       var isNextDirection = direction === Direction.NEXT;
       var isPrevDirection = direction === Direction.PREV;
</PRE><PRE>       var activeIndex = this._getItemIndex(activeElement);
</PRE><PRE>       var lastItemIndex = this._items.length - 1;
       var isGoingToWrap = isPrevDirection &amp;&amp; activeIndex === 0 || isNextDirection &amp;&amp; activeIndex === lastItemIndex;
</PRE><PRE>       if (isGoingToWrap &amp;&amp; !this._config.wrap) {
         return activeElement;
       }
</PRE><PRE>       var delta = direction === Direction.PREV ? -1 : 1;
       var itemIndex = (activeIndex + delta) % this._items.length;
       return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
     };
</PRE><PRE>     _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
       var targetIndex = this._getItemIndex(relatedTarget);
</PRE><PRE>       var fromIndex = this._getItemIndex(this._element.querySelector(Selector.ACTIVE_ITEM));
</PRE><PRE>       var slideEvent = $$$1.Event(Event.SLIDE, {
         relatedTarget: relatedTarget,
         direction: eventDirectionName,
         from: fromIndex,
         to: targetIndex
       });
       $$$1(this._element).trigger(slideEvent);
       return slideEvent;
     };
</PRE><PRE>     _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
       if (this._indicatorsElement) {
         var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector.ACTIVE));
         $$$1(indicators).removeClass(ClassName.ACTIVE);
</PRE><PRE>         var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];
</PRE><PRE>         if (nextIndicator) {
           $$$1(nextIndicator).addClass(ClassName.ACTIVE);
         }
       }
     };
</PRE><PRE>     _proto._slide = function _slide(direction, element) {
       var _this3 = this;
</PRE><PRE>       var activeElement = this._element.querySelector(Selector.ACTIVE_ITEM);
</PRE><PRE>       var activeElementIndex = this._getItemIndex(activeElement);
</PRE><PRE>       var nextElement = element || activeElement &amp;&amp; this._getItemByDirection(direction, activeElement);
</PRE><PRE>       var nextElementIndex = this._getItemIndex(nextElement);
</PRE><PRE>       var isCycling = Boolean(this._interval);
       var directionalClassName;
       var orderClassName;
       var eventDirectionName;
</PRE><PRE>       if (direction === Direction.NEXT) {
         directionalClassName = ClassName.LEFT;
         orderClassName = ClassName.NEXT;
         eventDirectionName = Direction.LEFT;
       } else {
         directionalClassName = ClassName.RIGHT;
         orderClassName = ClassName.PREV;
         eventDirectionName = Direction.RIGHT;
       }
</PRE><PRE>       if (nextElement &amp;&amp; $$$1(nextElement).hasClass(ClassName.ACTIVE)) {
         this._isSliding = false;
         return;
       }
</PRE><PRE>       var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
</PRE><PRE>       if (slideEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       if (!activeElement || !nextElement) {
         // Some weirdness is happening, so we bail
         return;
       }
</PRE><PRE>       this._isSliding = true;
</PRE><PRE>       if (isCycling) {
         this.pause();
       }
</PRE><PRE>       this._setActiveIndicatorElement(nextElement);
</PRE><PRE>       var slidEvent = $$$1.Event(Event.SLID, {
         relatedTarget: nextElement,
         direction: eventDirectionName,
         from: activeElementIndex,
         to: nextElementIndex
       });
</PRE><PRE>       if ($$$1(this._element).hasClass(ClassName.SLIDE)) {
         $$$1(nextElement).addClass(orderClassName);
         Util.reflow(nextElement);
         $$$1(activeElement).addClass(directionalClassName);
         $$$1(nextElement).addClass(directionalClassName);
         var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
         $$$1(activeElement).one(Util.TRANSITION_END, function () {
           $$$1(nextElement).removeClass(directionalClassName + &quot; &quot; + orderClassName).addClass(ClassName.ACTIVE);
           $$$1(activeElement).removeClass(ClassName.ACTIVE + &quot; &quot; + orderClassName + &quot; &quot; + directionalClassName);
           _this3._isSliding = false;
           setTimeout(function () {
             return $$$1(_this3._element).trigger(slidEvent);
           }, 0);
         }).emulateTransitionEnd(transitionDuration);
       } else {
         $$$1(activeElement).removeClass(ClassName.ACTIVE);
         $$$1(nextElement).addClass(ClassName.ACTIVE);
         this._isSliding = false;
         $$$1(this._element).trigger(slidEvent);
       }
</PRE><PRE>       if (isCycling) {
         this.cycle();
       }
     }; // Static
</PRE><PRE>     Carousel._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = _objectSpread({}, Default, $$$1(this).data());
</PRE><PRE>         if (typeof config === 'object') {
           _config = _objectSpread({}, _config, config);
         }
</PRE><PRE>         var action = typeof config === 'string' ? config : _config.slide;
</PRE><PRE>         if (!data) {
           data = new Carousel(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'number') {
           data.to(config);
         } else if (typeof action === 'string') {
           if (typeof data[action] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + action + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[action]();
         } else if (_config.interval) {
           data.pause();
           data.cycle();
         }
       });
     };
</PRE><PRE>     Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
       var selector = Util.getSelectorFromElement(this);
</PRE><PRE>       if (!selector) {
         return;
       }
</PRE><PRE>       var target = $$$1(selector)[0];
</PRE><PRE>       if (!target || !$$$1(target).hasClass(ClassName.CAROUSEL)) {
         return;
       }
</PRE><PRE>       var config = _objectSpread({}, $$$1(target).data(), $$$1(this).data());
</PRE><PRE>       var slideIndex = this.getAttribute('data-slide-to');
</PRE><PRE>       if (slideIndex) {
         config.interval = false;
       }
</PRE><PRE>       Carousel._jQueryInterface.call($$$1(target), config);
</PRE><PRE>       if (slideIndex) {
         $$$1(target).data(DATA_KEY).to(slideIndex);
       }
</PRE><PRE>       event.preventDefault();
     };
</PRE><PRE>     _createClass(Carousel, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }]);
</PRE><PRE>     return Carousel;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);
   $$$1(window).on(Event.LOAD_DATA_API, function () {
     var carousels = [].slice.call(document.querySelectorAll(Selector.DATA_RIDE));
</PRE><PRE>     for (var i = 0, len = carousels.length; i &lt; len; i++) {
       var $carousel = $$$1(carousels[i]);
</PRE><PRE>       Carousel._jQueryInterface.call($carousel, $carousel.data());
     }
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Carousel._jQueryInterface;
   $$$1.fn[NAME].Constructor = Carousel;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Carousel._jQueryInterface;
   };
</PRE><PRE>   return Carousel;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): collapse.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Collapse = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'collapse';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.collapse';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var Default = {
     toggle: true,
     parent: 
   };
   var DefaultType = {
     toggle: 'boolean',
     parent: '(string|element)'
   };
   var Event = {
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     SHOW: 'show',
     COLLAPSE: 'collapse',
     COLLAPSING: 'collapsing',
     COLLAPSED: 'collapsed'
   };
   var Dimension = {
     WIDTH: 'width',
     HEIGHT: 'height'
   };
   var Selector = {
     ACTIVES: '.show, .collapsing',
     DATA_TOGGLE: '[data-toggle=&quot;collapse&quot;]'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Collapse =
   /*#__PURE__*/
   function () {
     function Collapse(element, config) {
       this._isTransitioning = false;
       this._element = element;
       this._config = this._getConfig(config);
       this._triggerArray = $$$1.makeArray(document.querySelectorAll(&quot;[data-toggle=\&quot;collapse\&quot;][href=\&quot;#&quot; + element.id + &quot;\&quot;],&quot; + (&quot;[data-toggle=\&quot;collapse\&quot;][data-target=\&quot;#&quot; + element.id + &quot;\&quot;]&quot;)));
       var toggleList = [].slice.call(document.querySelectorAll(Selector.DATA_TOGGLE));
</PRE><PRE>       for (var i = 0, len = toggleList.length; i &lt; len; i++) {
         var elem = toggleList[i];
         var selector = Util.getSelectorFromElement(elem);
         var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
           return foundElem === element;
         });
</PRE><PRE>         if (selector !== null &amp;&amp; filterElement.length &gt; 0) {
           this._selector = selector;
</PRE><PRE>           this._triggerArray.push(elem);
         }
       }
</PRE><PRE>       this._parent = this._config.parent ? this._getParent() : null;
</PRE><PRE>       if (!this._config.parent) {
         this._addAriaAndCollapsedClass(this._element, this._triggerArray);
       }
</PRE><PRE>       if (this._config.toggle) {
         this.toggle();
       }
     } // Getters
</PRE><PRE>     var _proto = Collapse.prototype;
</PRE><PRE>     // Public
     _proto.toggle = function toggle() {
       if ($$$1(this._element).hasClass(ClassName.SHOW)) {
         this.hide();
       } else {
         this.show();
       }
     };
</PRE><PRE>     _proto.show = function show() {
       var _this = this;
</PRE><PRE>       if (this._isTransitioning || $$$1(this._element).hasClass(ClassName.SHOW)) {
         return;
       }
</PRE><PRE>       var actives;
       var activesData;
</PRE><PRE>       if (this._parent) {
         actives = [].slice.call(this._parent.querySelectorAll(Selector.ACTIVES)).filter(function (elem) {
           return elem.getAttribute('data-parent') === _this._config.parent;
         });
</PRE><PRE>         if (actives.length === 0) {
           actives = null;
         }
       }
</PRE><PRE>       if (actives) {
         activesData = $$$1(actives).not(this._selector).data(DATA_KEY);
</PRE><PRE>         if (activesData &amp;&amp; activesData._isTransitioning) {
           return;
         }
       }
</PRE><PRE>       var startEvent = $$$1.Event(Event.SHOW);
       $$$1(this._element).trigger(startEvent);
</PRE><PRE>       if (startEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       if (actives) {
         Collapse._jQueryInterface.call($$$1(actives).not(this._selector), 'hide');
</PRE><PRE>         if (!activesData) {
           $$$1(actives).data(DATA_KEY, null);
         }
       }
</PRE><PRE>       var dimension = this._getDimension();
</PRE><PRE>       $$$1(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
       this._element.style[dimension] = 0;
</PRE><PRE>       if (this._triggerArray.length) {
         $$$1(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
       }
</PRE><PRE>       this.setTransitioning(true);
</PRE><PRE>       var complete = function complete() {
         $$$1(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
         _this._element.style[dimension] = <I>;</I></PRE><PRE>         _this.setTransitioning(false);
</PRE><PRE>         $$$1(_this._element).trigger(Event.SHOWN);
       };
</PRE><PRE>       var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
       var scrollSize = &quot;scroll&quot; + capitalizedDimension;
       var transitionDuration = Util.getTransitionDurationFromElement(this._element);
       $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
       this._element.style[dimension] = this._element[scrollSize] + &quot;px&quot;;
     };
</PRE><PRE>     _proto.hide = function hide() {
       var _this2 = this;
</PRE><PRE>       if (this._isTransitioning || !$$$1(this._element).hasClass(ClassName.SHOW)) {
         return;
       }
</PRE><PRE>       var startEvent = $$$1.Event(Event.HIDE);
       $$$1(this._element).trigger(startEvent);
</PRE><PRE>       if (startEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       var dimension = this._getDimension();
</PRE><PRE>       this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + &quot;px&quot;;
       Util.reflow(this._element);
       $$$1(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);
       var triggerArrayLength = this._triggerArray.length;
</PRE><PRE>       if (triggerArrayLength &gt; 0) {
         for (var i = 0; i &lt; triggerArrayLength; i++) {
           var trigger = this._triggerArray[i];
           var selector = Util.getSelectorFromElement(trigger);
</PRE><PRE>           if (selector !== null) {
             var $elem = $$$1([].slice.call(document.querySelectorAll(selector)));
</PRE><PRE>             if (!$elem.hasClass(ClassName.SHOW)) {
               $$$1(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
             }
           }
         }
       }
</PRE><PRE>       this.setTransitioning(true);
</PRE><PRE>       var complete = function complete() {
         _this2.setTransitioning(false);
</PRE><PRE>         $$$1(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
       };
</PRE><PRE>       this._element.style[dimension] = <I>;</I>
       var transitionDuration = Util.getTransitionDurationFromElement(this._element);
       $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
     };
</PRE><PRE>     _proto.setTransitioning = function setTransitioning(isTransitioning) {
       this._isTransitioning = isTransitioning;
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       this._config = null;
       this._parent = null;
       this._element = null;
       this._triggerArray = null;
       this._isTransitioning = null;
     }; // Private
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, Default, config);
       config.toggle = Boolean(config.toggle); // Coerce string values
</PRE><PRE>       Util.typeCheckConfig(NAME, config, DefaultType);
       return config;
     };
</PRE><PRE>     _proto._getDimension = function _getDimension() {
       var hasWidth = $$$1(this._element).hasClass(Dimension.WIDTH);
       return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
     };
</PRE><PRE>     _proto._getParent = function _getParent() {
       var _this3 = this;
</PRE><PRE>       var parent = null;
</PRE><PRE>       if (Util.isElement(this._config.parent)) {
         parent = this._config.parent; // It's a jQuery object
</PRE><PRE>         if (typeof this._config.parent.jquery !== 'undefined') {
           parent = this._config.parent[0];
         }
       } else {
         parent = document.querySelector(this._config.parent);
       }
</PRE><PRE>       var selector = &quot;[data-toggle=\&quot;collapse\&quot;][data-parent=\&quot;&quot; + this._config.parent + &quot;\&quot;]&quot;;
       var children = [].slice.call(parent.querySelectorAll(selector));
       $$$1(children).each(function (i, element) {
         _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
       });
       return parent;
     };
</PRE><PRE>     _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
       if (element) {
         var isOpen = $$$1(element).hasClass(ClassName.SHOW);
</PRE><PRE>         if (triggerArray.length) {
           $$$1(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
         }
       }
     }; // Static
</PRE><PRE>     Collapse._getTargetFromElement = function _getTargetFromElement(element) {
       var selector = Util.getSelectorFromElement(element);
       return selector ? document.querySelector(selector) : null;
     };
</PRE><PRE>     Collapse._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var $this = $$$1(this);
         var data = $this.data(DATA_KEY);
</PRE><PRE>         var _config = _objectSpread({}, Default, $this.data(), typeof config === 'object' &amp;&amp; config ? config : {});
</PRE><PRE>         if (!data &amp;&amp; _config.toggle &amp;&amp; /show|hide/.test(config)) {
           _config.toggle = false;
         }
</PRE><PRE>         if (!data) {
           data = new Collapse(this, _config);
           $this.data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config]();
         }
       });
     };
</PRE><PRE>     _createClass(Collapse, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }]);
</PRE><PRE>     return Collapse;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
     // preventDefault only for &lt;a&gt; elements (which change the URL) not inside the collapsible element
     if (event.currentTarget.tagName === 'A') {
       event.preventDefault();
     }
</PRE><PRE>     var $trigger = $$$1(this);
     var selector = Util.getSelectorFromElement(this);
     var selectors = [].slice.call(document.querySelectorAll(selector));
     $$$1(selectors).each(function () {
       var $target = $$$1(this);
       var data = $target.data(DATA_KEY);
       var config = data ? 'toggle' : $trigger.data();
</PRE><PRE>       Collapse._jQueryInterface.call($target, config);
     });
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */</PRE><PRE>   $$$1.fn[NAME] = Collapse._jQueryInterface;
   $$$1.fn[NAME].Constructor = Collapse;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Collapse._jQueryInterface;
   };
</PRE><PRE>   return Collapse;
 }($);
</PRE><PRE> /**!
  * @fileOverview Kickass library to create and place poppers near their reference elements.
  * @version 1.14.3
  * @license
  * Copyright (c) 2016 Federico Zivolo and contributors
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the &quot;Software&quot;), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in all
  * copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  */
 var isBrowser = typeof window !== 'undefined' &amp;&amp; typeof document !== 'undefined';
</PRE><PRE> var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
 var timeoutDuration = 0;
 for (var i = 0; i &lt; longerTimeoutBrowsers.length; i += 1) {
   if (isBrowser &amp;&amp; navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) &gt;= 0) {
     timeoutDuration = 1;
     break;
   }
 }
</PRE><PRE> function microtaskDebounce(fn) {
   var called = false;
   return function () {
     if (called) {
       return;
     }
     called = true;
     window.Promise.resolve().then(function () {
       called = false;
       fn();
     });
   };
 }
</PRE><PRE> function taskDebounce(fn) {
   var scheduled = false;
   return function () {
     if (!scheduled) {
       scheduled = true;
       setTimeout(function () {
         scheduled = false;
         fn();
       }, timeoutDuration);
     }
   };
 }
</PRE><PRE> var supportsMicroTasks = isBrowser &amp;&amp; window.Promise;
</PRE><PRE> /**
 * Create a debounced version of a method, that's asynchronously deferred
 * but called in the minimum time possible.
 *
 * @method
 * @memberof Popper.Utils
 * @argument {Function} fn
 * @returns {Function}
 */
 var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
</PRE><PRE> /**
  * Check if the given variable is a function
  * @method
  * @memberof Popper.Utils
  * @argument {Any} functionToCheck - variable to check
  * @returns {Boolean} answer to: is a function?
  */
 function isFunction(functionToCheck) {
   var getType = {};
   return functionToCheck &amp;&amp; getType.toString.call(functionToCheck) === '[object Function]';
 }
</PRE><PRE> /**
  * Get CSS computed property of the given element
  * @method
  * @memberof Popper.Utils
  * @argument {Eement} element
  * @argument {String} property
  */
 function getStyleComputedProperty(element, property) {
   if (element.nodeType !== 1) {
     return [];
   }
   // NOTE: 1 DOM access here
   var css = getComputedStyle(element, null);
   return property ? css[property] : css;
 }
</PRE><PRE> /**
  * Returns the parentNode or the host of the element
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element
  * @returns {Element} parent
  */
 function getParentNode(element) {
   if (element.nodeName === 'HTML') {
     return element;
   }
   return element.parentNode || element.host;
 }
</PRE><PRE> /**
  * Returns the scrolling parent of the given element
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element
  * @returns {Element} scroll parent
  */
 function getScrollParent(element) {
   // Return body, `getScroll` will take care to get the correct `scrollTop` from it
   if (!element) {
     return document.body;
   }
</PRE><PRE>   switch (element.nodeName) {
     case 'HTML':
     case 'BODY':
       return element.ownerDocument.body;
     case '#document':
       return element.body;
   }
</PRE><PRE>   // Firefox want us to check `-x` and `-y` variations as well
</PRE><PRE>   var _getStyleComputedProp = getStyleComputedProperty(element),
       overflow = _getStyleComputedProp.overflow,
       overflowX = _getStyleComputedProp.overflowX,
       overflowY = _getStyleComputedProp.overflowY;
</PRE><PRE>   if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
     return element;
   }
</PRE><PRE>   return getScrollParent(getParentNode(element));
 }
</PRE><PRE> var isIE11 = isBrowser &amp;&amp; !!(window.MSInputMethodContext &amp;&amp; document.documentMode);
 var isIE10 = isBrowser &amp;&amp; /MSIE 10/.test(navigator.userAgent);
</PRE><PRE> /**
  * Determines if the browser is Internet Explorer
  * @method
  * @memberof Popper.Utils
  * @param {Number} version to check
  * @returns {Boolean} isIE
  */
 function isIE(version) {
   if (version === 11) {
     return isIE11;
   }
   if (version === 10) {
     return isIE10;
   }
   return isIE11 || isIE10;
 }
</PRE><PRE> /**
  * Returns the offset parent of the given element
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element
  * @returns {Element} offset parent
  */
 function getOffsetParent(element) {
   if (!element) {
     return document.documentElement;
   }
</PRE><PRE>   var noOffsetParent = isIE(10) ? document.body : null;
</PRE><PRE>   // NOTE: 1 DOM access here
   var offsetParent = element.offsetParent;
   // Skip hidden elements which don't have an offsetParent
   while (offsetParent === noOffsetParent &amp;&amp; element.nextElementSibling) {
     offsetParent = (element = element.nextElementSibling).offsetParent;
   }
</PRE><PRE>   var nodeName = offsetParent &amp;&amp; offsetParent.nodeName;
</PRE><PRE>   if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
     return element ? element.ownerDocument.documentElement : document.documentElement;
   }
</PRE><PRE>   // .offsetParent will return the closest TD or TABLE in case
   // no offsetParent is present, I hate this job...
   if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &amp;&amp; getStyleComputedProperty(offsetParent, 'position') === 'static') {
     return getOffsetParent(offsetParent);
   }
</PRE><PRE>   return offsetParent;
 }
</PRE><PRE> function isOffsetContainer(element) {
   var nodeName = element.nodeName;
</PRE><PRE>   if (nodeName === 'BODY') {
     return false;
   }
   return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
 }
</PRE><PRE> /**
  * Finds the root node (document, shadowDOM root) of the given element
  * @method
  * @memberof Popper.Utils
  * @argument {Element} node
  * @returns {Element} root node
  */
 function getRoot(node) {
   if (node.parentNode !== null) {
     return getRoot(node.parentNode);
   }
</PRE><PRE>   return node;
 }
</PRE><PRE> /**
  * Finds the offset parent common to the two provided nodes
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element1
  * @argument {Element} element2
  * @returns {Element} common offset parent
  */
 function findCommonOffsetParent(element1, element2) {
   // This check is needed to avoid errors in case one of the elements isn't defined for any reason
   if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
     return document.documentElement;
   }
</PRE><PRE>   // Here we make sure to give as &quot;start&quot; the element that comes first in the DOM
   var order = element1.compareDocumentPosition(element2) &amp; Node.DOCUMENT_POSITION_FOLLOWING;
   var start = order ? element1 : element2;
   var end = order ? element2 : element1;
</PRE><PRE>   // Get common ancestor container
   var range = document.createRange();
   range.setStart(start, 0);
   range.setEnd(end, 0);
   var commonAncestorContainer = range.commonAncestorContainer;
</PRE><PRE>   // Both nodes are inside #document
</PRE><PRE>   if (element1 !== commonAncestorContainer &amp;&amp; element2 !== commonAncestorContainer || start.contains(end)) {
     if (isOffsetContainer(commonAncestorContainer)) {
       return commonAncestorContainer;
     }
</PRE><PRE>     return getOffsetParent(commonAncestorContainer);
   }
</PRE><PRE>   // one of the nodes is inside shadowDOM, find which one
   var element1root = getRoot(element1);
   if (element1root.host) {
     return findCommonOffsetParent(element1root.host, element2);
   } else {
     return findCommonOffsetParent(element1, getRoot(element2).host);
   }
 }
</PRE><PRE> /**
  * Gets the scroll value of the given element in the given side (top and left)
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element
  * @argument {String} side `top` or `left`
  * @returns {number} amount of scrolled pixels
  */
 function getScroll(element) {
   var side = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 'top';
</PRE><PRE>   var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
   var nodeName = element.nodeName;
</PRE><PRE>   if (nodeName === 'BODY' || nodeName === 'HTML') {
     var html = element.ownerDocument.documentElement;
     var scrollingElement = element.ownerDocument.scrollingElement || html;
     return scrollingElement[upperSide];
   }
</PRE><PRE>   return element[upperSide];
 }
</PRE><PRE> /*
  * Sum or subtract the element scroll values (left and top) from a given rect object
  * @method
  * @memberof Popper.Utils
  * @param {Object} rect - Rect object you want to change
  * @param {HTMLElement} element - The element from the function reads the scroll values
  * @param {Boolean} subtract - set to true if you want to subtract the scroll values
  * @return {Object} rect - The modifier rect object
  */
 function includeScroll(rect, element) {
   var subtract = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : false;
</PRE><PRE>   var scrollTop = getScroll(element, 'top');
   var scrollLeft = getScroll(element, 'left');
   var modifier = subtract ? -1 : 1;
   rect.top += scrollTop * modifier;
   rect.bottom += scrollTop * modifier;
   rect.left += scrollLeft * modifier;
   rect.right += scrollLeft * modifier;
   return rect;
 }
</PRE><PRE> /*
  * Helper to detect borders of a given element
  * @method
  * @memberof Popper.Utils
  * @param {CSSStyleDeclaration} styles
  * Result of `getStyleComputedProperty` on the given element
  * @param {String} axis - `x` or `y`
  * @return {number} borders - The borders size of the given axis
  */
</PRE><PRE> function getBordersSize(styles, axis) {
   var sideA = axis === 'x' ? 'Left' : 'Top';
   var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
</PRE><PRE>   return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
 }
</PRE><PRE> function getSize(axis, body, html, computedStyle) {
   return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
 }
</PRE><PRE> function getWindowSizes() {
   var body = document.body;
   var html = document.documentElement;
   var computedStyle = isIE(10) &amp;&amp; getComputedStyle(html);
</PRE><PRE>   return {
     height: getSize('Height', body, html, computedStyle),
     width: getSize('Width', body, html, computedStyle)
   };
 }
</PRE><PRE> var classCallCheck = function (instance, Constructor) {
   if (!(instance instanceof Constructor)) {
     throw new TypeError(&quot;Cannot call a class as a function&quot;);
   }
 };
</PRE><PRE> var createClass = function () {
   function defineProperties(target, props) {
     for (var i = 0; i &lt; props.length; i++) {
       var descriptor = props[i];
       descriptor.enumerable = descriptor.enumerable || false;
       descriptor.configurable = true;
       if (&quot;value&quot; in descriptor) descriptor.writable = true;
       Object.defineProperty(target, descriptor.key, descriptor);
     }
   }
</PRE><PRE>   return function (Constructor, protoProps, staticProps) {
     if (protoProps) defineProperties(Constructor.prototype, protoProps);
     if (staticProps) defineProperties(Constructor, staticProps);
     return Constructor;
   };
 }();
</PRE><PRE> var defineProperty = function (obj, key, value) {
   if (key in obj) {
     Object.defineProperty(obj, key, {
       value: value,
       enumerable: true,
       configurable: true,
       writable: true
     });
   } else {
     obj[key] = value;
   }
</PRE><PRE>   return obj;
 };
</PRE><PRE> var _extends = Object.assign || function (target) {
   for (var i = 1; i &lt; arguments.length; i++) {
     var source = arguments[i];
</PRE><PRE>     for (var key in source) {
       if (Object.prototype.hasOwnProperty.call(source, key)) {
         target[key] = source[key];
       }
     }
   }
</PRE><PRE>   return target;
 };
</PRE><PRE> /**
  * Given element offsets, generate an output similar to getBoundingClientRect
  * @method
  * @memberof Popper.Utils
  * @argument {Object} offsets
  * @returns {Object} ClientRect like output
  */
 function getClientRect(offsets) {
   return _extends({}, offsets, {
     right: offsets.left + offsets.width,
     bottom: offsets.top + offsets.height
   });
 }
</PRE><PRE> /**
  * Get bounding client rect of given element
  * @method
  * @memberof Popper.Utils
  * @param {HTMLElement} element
  * @return {Object} client rect
  */
 function getBoundingClientRect(element) {
   var rect = {};
</PRE><PRE>   // IE10 10 FIX: Please, don't ask, the element isn't
   // considered in DOM in some circumstances...
   // This isn't reproducible in IE10 compatibility mode of IE11
   try {
     if (isIE(10)) {
       rect = element.getBoundingClientRect();
       var scrollTop = getScroll(element, 'top');
       var scrollLeft = getScroll(element, 'left');
       rect.top += scrollTop;
       rect.left += scrollLeft;
       rect.bottom += scrollTop;
       rect.right += scrollLeft;
     } else {
       rect = element.getBoundingClientRect();
     }
   } catch (e) {}
</PRE><PRE>   var result = {
     left: rect.left,
     top: rect.top,
     width: rect.right - rect.left,
     height: rect.bottom - rect.top
   };
</PRE><PRE>   // subtract scrollbar size from sizes
   var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
   var width = sizes.width || element.clientWidth || result.right - result.left;
   var height = sizes.height || element.clientHeight || result.bottom - result.top;
</PRE><PRE>   var horizScrollbar = element.offsetWidth - width;
   var vertScrollbar = element.offsetHeight - height;
</PRE><PRE>   // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
   // we make this check conditional for performance reasons
   if (horizScrollbar || vertScrollbar) {
     var styles = getStyleComputedProperty(element);
     horizScrollbar -= getBordersSize(styles, 'x');
     vertScrollbar -= getBordersSize(styles, 'y');
</PRE><PRE>     result.width -= horizScrollbar;
     result.height -= vertScrollbar;
   }
</PRE><PRE>   return getClientRect(result);
 }
</PRE><PRE> function getOffsetRectRelativeToArbitraryNode(children, parent) {
   var fixedPosition = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : false;
</PRE><PRE>   var isIE10 = isIE(10);
   var isHTML = parent.nodeName === 'HTML';
   var childrenRect = getBoundingClientRect(children);
   var parentRect = getBoundingClientRect(parent);
   var scrollParent = getScrollParent(children);
</PRE><PRE>   var styles = getStyleComputedProperty(parent);
   var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
   var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
</PRE><PRE>   // In cases where the parent is fixed, we must ignore negative scroll in offset calc
   if (fixedPosition &amp;&amp; parent.nodeName === 'HTML') {
     parentRect.top = Math.max(parentRect.top, 0);
     parentRect.left = Math.max(parentRect.left, 0);
   }
   var offsets = getClientRect({
     top: childrenRect.top - parentRect.top - borderTopWidth,
     left: childrenRect.left - parentRect.left - borderLeftWidth,
     width: childrenRect.width,
     height: childrenRect.height
   });
   offsets.marginTop = 0;
   offsets.marginLeft = 0;
</PRE><PRE>   // Subtract margins of documentElement in case it's being used as parent
   // we do this only on HTML because it's the only element that behaves
   // differently when margins are applied to it. The margins are included in
   // the box of the documentElement, in the other cases not.
   if (!isIE10 &amp;&amp; isHTML) {
     var marginTop = parseFloat(styles.marginTop, 10);
     var marginLeft = parseFloat(styles.marginLeft, 10);
</PRE><PRE>     offsets.top -= borderTopWidth - marginTop;
     offsets.bottom -= borderTopWidth - marginTop;
     offsets.left -= borderLeftWidth - marginLeft;
     offsets.right -= borderLeftWidth - marginLeft;
</PRE><PRE>     // Attach marginTop and marginLeft because in some circumstances we may need them
     offsets.marginTop = marginTop;
     offsets.marginLeft = marginLeft;
   }
</PRE><PRE>   if (isIE10 &amp;&amp; !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent &amp;&amp; scrollParent.nodeName !== 'BODY') {
     offsets = includeScroll(offsets, parent);
   }
</PRE><PRE>   return offsets;
 }
</PRE><PRE> function getViewportOffsetRectRelativeToArtbitraryNode(element) {
   var excludeScroll = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : false;
</PRE><PRE>   var html = element.ownerDocument.documentElement;
   var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
   var width = Math.max(html.clientWidth, window.innerWidth || 0);
   var height = Math.max(html.clientHeight, window.innerHeight || 0);
</PRE><PRE>   var scrollTop = !excludeScroll ? getScroll(html) : 0;
   var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
</PRE><PRE>   var offset = {
     top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
     left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
     width: width,
     height: height
   };
</PRE><PRE>   return getClientRect(offset);
 }
</PRE><PRE> /**
  * Check if the given element is fixed or is inside a fixed parent
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element
  * @argument {Element} customContainer
  * @returns {Boolean} answer to &quot;isFixed?&quot;
  */
 function isFixed(element) {
   var nodeName = element.nodeName;
   if (nodeName === 'BODY' || nodeName === 'HTML') {
     return false;
   }
   if (getStyleComputedProperty(element, 'position') === 'fixed') {
     return true;
   }
   return isFixed(getParentNode(element));
 }
</PRE><PRE> /**
  * Finds the first parent of an element that has a transformed property defined
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element
  * @returns {Element} first transformed parent or documentElement
  */
</PRE><PRE> function getFixedPositionOffsetParent(element) {
   // This check is needed to avoid errors in case one of the elements isn't defined for any reason
   if (!element || !element.parentElement || isIE()) {
     return document.documentElement;
   }
   var el = element.parentElement;
   while (el &amp;&amp; getStyleComputedProperty(el, 'transform') === 'none') {
     el = el.parentElement;
   }
   return el || document.documentElement;
 }
</PRE><PRE> /**
  * Computed the boundaries limits and return them
  * @method
  * @memberof Popper.Utils
  * @param {HTMLElement} popper
  * @param {HTMLElement} reference
  * @param {number} padding
  * @param {HTMLElement} boundariesElement - Element used to define the boundaries
  * @param {Boolean} fixedPosition - Is in fixed position mode
  * @returns {Object} Coordinates of the boundaries
  */
 function getBoundaries(popper, reference, padding, boundariesElement) {
   var fixedPosition = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : false;
</PRE><PRE>   // NOTE: 1 DOM access here
</PRE><PRE>   var boundaries = { top: 0, left: 0 };
   var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
</PRE><PRE>   // Handle viewport case
   if (boundariesElement === 'viewport') {
     boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
   } else {
     // Handle other cases based on DOM element used as boundaries
     var boundariesNode = void 0;
     if (boundariesElement === 'scrollParent') {
       boundariesNode = getScrollParent(getParentNode(reference));
       if (boundariesNode.nodeName === 'BODY') {
         boundariesNode = popper.ownerDocument.documentElement;
       }
     } else if (boundariesElement === 'window') {
       boundariesNode = popper.ownerDocument.documentElement;
     } else {
       boundariesNode = boundariesElement;
     }
</PRE><PRE>     var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
</PRE><PRE>     // In case of HTML, we need a different computation
     if (boundariesNode.nodeName === 'HTML' &amp;&amp; !isFixed(offsetParent)) {
       var _getWindowSizes = getWindowSizes(),
           height = _getWindowSizes.height,
           width = _getWindowSizes.width;
</PRE><PRE>       boundaries.top += offsets.top - offsets.marginTop;
       boundaries.bottom = height + offsets.top;
       boundaries.left += offsets.left - offsets.marginLeft;
       boundaries.right = width + offsets.left;
     } else {
       // for all the other DOM elements, this one is good
       boundaries = offsets;
     }
   }
</PRE><PRE>   // Add paddings
   boundaries.left += padding;
   boundaries.top += padding;
   boundaries.right -= padding;
   boundaries.bottom -= padding;
</PRE><PRE>   return boundaries;
 }
</PRE><PRE> function getArea(_ref) {
   var width = _ref.width,
       height = _ref.height;
</PRE><PRE>   return width * height;
 }
</PRE><PRE> /**
  * Utility used to transform the `auto` placement to the placement with more
  * available space.
  * @method
  * @memberof Popper.Utils
  * @argument {Object} data - The data object generated by update method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The data object, properly modified
  */
 function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
   var padding = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : 0;
</PRE><PRE>   if (placement.indexOf('auto') === -1) {
     return placement;
   }
</PRE><PRE>   var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
</PRE><PRE>   var rects = {
     top: {
       width: boundaries.width,
       height: refRect.top - boundaries.top
     },
     right: {
       width: boundaries.right - refRect.right,
       height: boundaries.height
     },
     bottom: {
       width: boundaries.width,
       height: boundaries.bottom - refRect.bottom
     },
     left: {
       width: refRect.left - boundaries.left,
       height: boundaries.height
     }
   };
</PRE><PRE>   var sortedAreas = Object.keys(rects).map(function (key) {
     return _extends({
       key: key
     }, rects[key], {
       area: getArea(rects[key])
     });
   }).sort(function (a, b) {
     return b.area - a.area;
   });
</PRE><PRE>   var filteredAreas = sortedAreas.filter(function (_ref2) {
     var width = _ref2.width,
         height = _ref2.height;
     return width &gt;= popper.clientWidth &amp;&amp; height &gt;= popper.clientHeight;
   });
</PRE><PRE>   var computedPlacement = filteredAreas.length &gt; 0 ? filteredAreas[0].key : sortedAreas[0].key;
</PRE><PRE>   var variation = placement.split('-')[1];
</PRE><PRE>   return computedPlacement + (variation ? '-' + variation : <I>);</I>
 }
</PRE><PRE> /**
  * Get offsets to the reference element
  * @method
  * @memberof Popper.Utils
  * @param {Object} state
  * @param {Element} popper - the popper element
  * @param {Element} reference - the reference element (the popper will be relative to this)
  * @param {Element} fixedPosition - is in fixed position mode
  * @returns {Object} An object containing the offsets which will be applied to the popper
  */
 function getReferenceOffsets(state, popper, reference) {
   var fixedPosition = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : null;
</PRE><PRE>   var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
   return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
 }
</PRE><PRE> /**
  * Get the outer sizes of the given element (offset size + margins)
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element
  * @returns {Object} object containing width and height properties
  */
 function getOuterSizes(element) {
   var styles = getComputedStyle(element);
   var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
   var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
   var result = {
     width: element.offsetWidth + y,
     height: element.offsetHeight + x
   };
   return result;
 }
</PRE><PRE> /**
  * Get the opposite placement of the given one
  * @method
  * @memberof Popper.Utils
  * @argument {String} placement
  * @returns {String} flipped placement
  */
 function getOppositePlacement(placement) {
   var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
   return placement.replace(/left|right|bottom|top/g, function (matched) {
     return hash[matched];
   });
 }
</PRE><PRE> /**
  * Get offsets to the popper
  * @method
  * @memberof Popper.Utils
  * @param {Object} position - CSS position the Popper will get applied
  * @param {HTMLElement} popper - the popper element
  * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
  * @param {String} placement - one of the valid placement options
  * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
  */
 function getPopperOffsets(popper, referenceOffsets, placement) {
   placement = placement.split('-')[0];
</PRE><PRE>   // Get popper node sizes
   var popperRect = getOuterSizes(popper);
</PRE><PRE>   // Add position, width and height to our offsets object
   var popperOffsets = {
     width: popperRect.width,
     height: popperRect.height
   };
</PRE><PRE>   // depending by the popper placement we have to compute its offsets slightly differently
   var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
   var mainSide = isHoriz ? 'top' : 'left';
   var secondarySide = isHoriz ? 'left' : 'top';
   var measurement = isHoriz ? 'height' : 'width';
   var secondaryMeasurement = !isHoriz ? 'height' : 'width';
</PRE><PRE>   popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
   if (placement === secondarySide) {
     popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
   } else {
     popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
   }
</PRE><PRE>   return popperOffsets;
 }
</PRE><PRE> /**
  * Mimics the `find` method of Array
  * @method
  * @memberof Popper.Utils
  * @argument {Array} arr
  * @argument prop
  * @argument value
  * @returns index or -1
  */
 function find(arr, check) {
   // use native find if supported
   if (Array.prototype.find) {
     return arr.find(check);
   }
</PRE><PRE>   // use `filter` to obtain the same behavior of `find`
   return arr.filter(check)[0];
 }
</PRE><PRE> /**
  * Return the index of the matching object
  * @method
  * @memberof Popper.Utils
  * @argument {Array} arr
  * @argument prop
  * @argument value
  * @returns index or -1
  */
 function findIndex(arr, prop, value) {
   // use native findIndex if supported
   if (Array.prototype.findIndex) {
     return arr.findIndex(function (cur) {
       return cur[prop] === value;
     });
   }
</PRE><PRE>   // use `find` + `indexOf` if `findIndex` isn't supported
   var match = find(arr, function (obj) {
     return obj[prop] === value;
   });
   return arr.indexOf(match);
 }
</PRE><PRE> /**
  * Loop trough the list of modifiers and run them in order,
  * each of them will then edit the data object.
  * @method
  * @memberof Popper.Utils
  * @param {dataObject} data
  * @param {Array} modifiers
  * @param {String} ends - Optional modifier name used as stopper
  * @returns {dataObject}
  */
 function runModifiers(modifiers, data, ends) {
   var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
</PRE><PRE>   modifiersToRun.forEach(function (modifier) {
     if (modifier['function']) {
       // eslint-disable-line dot-notation
       console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
     }
     var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
     if (modifier.enabled &amp;&amp; isFunction(fn)) {
       // Add properties to offsets to make them a complete clientRect object
       // we do this before each modifier to make sure the previous one doesn't
       // mess with these values
       data.offsets.popper = getClientRect(data.offsets.popper);
       data.offsets.reference = getClientRect(data.offsets.reference);
</PRE><PRE>       data = fn(data, modifier);
     }
   });
</PRE><PRE>   return data;
 }
</PRE><PRE> /**
  * Updates the position of the popper, computing the new offsets and applying
  * the new style.
  * Prefer `scheduleUpdate` over `update` because of performance reasons.
  * @method
  * @memberof Popper
  */
 function update() {
   // if popper is destroyed, don't perform any further update
   if (this.state.isDestroyed) {
     return;
   }
</PRE><PRE>   var data = {
     instance: this,
     styles: {},
     arrowStyles: {},
     attributes: {},
     flipped: false,
     offsets: {}
   };
</PRE><PRE>   // compute reference element offsets
   data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
</PRE><PRE>   // compute auto placement, store placement inside the data object,
   // modifiers will be able to edit `placement` if needed
   // and refer to originalPlacement to know the original value
   data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
</PRE><PRE>   // store the computed placement inside `originalPlacement`
   data.originalPlacement = data.placement;
</PRE><PRE>   data.positionFixed = this.options.positionFixed;
</PRE><PRE>   // compute the popper offsets
   data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
</PRE><PRE>   data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
</PRE><PRE>   // run the modifiers
   data = runModifiers(this.modifiers, data);
</PRE><PRE>   // the first `update` will call `onCreate` callback
   // the other ones will call `onUpdate` callback
   if (!this.state.isCreated) {
     this.state.isCreated = true;
     this.options.onCreate(data);
   } else {
     this.options.onUpdate(data);
   }
 }
</PRE><PRE> /**
  * Helper used to know if the given modifier is enabled.
  * @method
  * @memberof Popper.Utils
  * @returns {Boolean}
  */
 function isModifierEnabled(modifiers, modifierName) {
   return modifiers.some(function (_ref) {
     var name = _ref.name,
         enabled = _ref.enabled;
     return enabled &amp;&amp; name === modifierName;
   });
 }
</PRE><PRE> /**
  * Get the prefixed supported property name
  * @method
  * @memberof Popper.Utils
  * @argument {String} property (camelCase)
  * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
  */
 function getSupportedPropertyName(property) {
   var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
   var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
</PRE><PRE>   for (var i = 0; i &lt; prefixes.length; i++) {
     var prefix = prefixes[i];
     var toCheck = prefix ? <I> + prefix + upperProp : property;</I>
     if (typeof document.body.style[toCheck] !== 'undefined') {
       return toCheck;
     }
   }
   return null;
 }
</PRE><PRE> /**
  * Destroy the popper
  * @method
  * @memberof Popper
  */
 function destroy() {
   this.state.isDestroyed = true;
</PRE><PRE>   // touch DOM only if `applyStyle` modifier is enabled
   if (isModifierEnabled(this.modifiers, 'applyStyle')) {
     this.popper.removeAttribute('x-placement');
     this.popper.style.position = <I>;</I>
     this.popper.style.top = <I>;</I>
     this.popper.style.left = <I>;</I>
     this.popper.style.right = <I>;</I>
     this.popper.style.bottom = <I>;</I>
     this.popper.style.willChange = <I>;</I>
     this.popper.style[getSupportedPropertyName('transform')] = <I>;</I>
   }
</PRE><PRE>   this.disableEventListeners();
</PRE><PRE>   // remove the popper if user explicity asked for the deletion on destroy
   // do not use `remove` because IE11 doesn't support it
   if (this.options.removeOnDestroy) {
     this.popper.parentNode.removeChild(this.popper);
   }
   return this;
 }
</PRE><PRE> /**
  * Get the window associated with the element
  * @argument {Element} element
  * @returns {Window}
  */
 function getWindow(element) {
   var ownerDocument = element.ownerDocument;
   return ownerDocument ? ownerDocument.defaultView : window;
 }
</PRE><PRE> function attachToScrollParents(scrollParent, event, callback, scrollParents) {
   var isBody = scrollParent.nodeName === 'BODY';
   var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
   target.addEventListener(event, callback, { passive: true });
</PRE><PRE>   if (!isBody) {
     attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
   }
   scrollParents.push(target);
 }
</PRE><PRE> /**
  * Setup needed event listeners used to update the popper position
  * @method
  * @memberof Popper.Utils
  * @private
  */
 function setupEventListeners(reference, options, state, updateBound) {
   // Resize event listener on window
   state.updateBound = updateBound;
   getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });
</PRE><PRE>   // Scroll event listener on scroll parents
   var scrollElement = getScrollParent(reference);
   attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
   state.scrollElement = scrollElement;
   state.eventsEnabled = true;
</PRE><PRE>   return state;
 }
</PRE><PRE> /**
  * It will add resize/scroll events and start recalculating
  * position of the popper element when they are triggered.
  * @method
  * @memberof Popper
  */
 function enableEventListeners() {
   if (!this.state.eventsEnabled) {
     this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
   }
 }
</PRE><PRE> /**
  * Remove event listeners used to update the popper position
  * @method
  * @memberof Popper.Utils
  * @private
  */
 function removeEventListeners(reference, state) {
   // Remove resize event listener on window
   getWindow(reference).removeEventListener('resize', state.updateBound);
</PRE><PRE>   // Remove scroll event listener on scroll parents
   state.scrollParents.forEach(function (target) {
     target.removeEventListener('scroll', state.updateBound);
   });
</PRE><PRE>   // Reset state
   state.updateBound = null;
   state.scrollParents = [];
   state.scrollElement = null;
   state.eventsEnabled = false;
   return state;
 }
</PRE><PRE> /**
  * It will remove resize/scroll events and won't recalculate popper position
  * when they are triggered. It also won't trigger onUpdate callback anymore,
  * unless you call `update` method manually.
  * @method
  * @memberof Popper
  */
 function disableEventListeners() {
   if (this.state.eventsEnabled) {
     cancelAnimationFrame(this.scheduleUpdate);
     this.state = removeEventListeners(this.reference, this.state);
   }
 }
</PRE><PRE> /**
  * Tells if a given input is a number
  * @method
  * @memberof Popper.Utils
  * @param {*} input to check
  * @return {Boolean}
  */
 function isNumeric(n) {
   return n !== <I>&amp;&amp; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);</I>
 }
</PRE><PRE> /**
  * Set the style to the given popper
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element - Element to apply the style to
  * @argument {Object} styles
  * Object with a list of properties and values which will be applied to the element
  */
 function setStyles(element, styles) {
   Object.keys(styles).forEach(function (prop) {
     var unit = <I>;</I>
     // add unit if the value is numeric and is one of the following
     if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &amp;&amp; isNumeric(styles[prop])) {
       unit = 'px';
     }
     element.style[prop] = styles[prop] + unit;
   });
 }
</PRE><PRE> /**
  * Set the attributes to the given popper
  * @method
  * @memberof Popper.Utils
  * @argument {Element} element - Element to apply the attributes to
  * @argument {Object} styles
  * Object with a list of properties and values which will be applied to the element
  */
 function setAttributes(element, attributes) {
   Object.keys(attributes).forEach(function (prop) {
     var value = attributes[prop];
     if (value !== false) {
       element.setAttribute(prop, attributes[prop]);
     } else {
       element.removeAttribute(prop);
     }
   });
 }
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by `update` method
  * @argument {Object} data.styles - List of style properties - values to apply to popper element
  * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The same data object
  */
 function applyStyle(data) {
   // any property present in `data.styles` will be applied to the popper,
   // in this way we can make the 3rd party modifiers add custom styles to it
   // Be aware, modifiers could override the properties defined in the previous
   // lines of this modifier!
   setStyles(data.instance.popper, data.styles);
</PRE><PRE>   // any property present in `data.attributes` will be applied to the popper,
   // they will be set as HTML attributes of the element
   setAttributes(data.instance.popper, data.attributes);
</PRE><PRE>   // if arrowElement is defined and arrowStyles has some properties
   if (data.arrowElement &amp;&amp; Object.keys(data.arrowStyles).length) {
     setStyles(data.arrowElement, data.arrowStyles);
   }
</PRE><PRE>   return data;
 }
</PRE><PRE> /**
  * Set the x-placement attribute before everything else because it could be used
  * to add margins to the popper margins needs to be calculated to get the
  * correct popper offsets.
  * @method
  * @memberof Popper.modifiers
  * @param {HTMLElement} reference - The reference element used to position the popper
  * @param {HTMLElement} popper - The HTML element used as popper
  * @param {Object} options - Popper.js options
  */
 function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
   // compute reference element offsets
   var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
</PRE><PRE>   // compute auto placement, store placement inside the data object,
   // modifiers will be able to edit `placement` if needed
   // and refer to originalPlacement to know the original value
   var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
</PRE><PRE>   popper.setAttribute('x-placement', placement);
</PRE><PRE>   // Apply `position` to popper before anything else because
   // without the position applied we can't guarantee correct computations
   setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });
</PRE><PRE>   return options;
 }
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by `update` method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The data object, properly modified
  */
 function computeStyle(data, options) {
   var x = options.x,
       y = options.y;
   var popper = data.offsets.popper;
</PRE><PRE>   // Remove this legacy support in Popper.js v2
</PRE><PRE>   var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
     return modifier.name === 'applyStyle';
   }).gpuAcceleration;
   if (legacyGpuAccelerationOption !== undefined) {
     console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
   }
   var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
</PRE><PRE>   var offsetParent = getOffsetParent(data.instance.popper);
   var offsetParentRect = getBoundingClientRect(offsetParent);
</PRE><PRE>   // Styles
   var styles = {
     position: popper.position
   };
</PRE><PRE>   // Avoid blurry text by using full pixel integers.
   // For pixel-perfect positioning, top/bottom prefers rounded
   // values, while left/right prefers floored values.
   var offsets = {
     left: Math.floor(popper.left),
     top: Math.round(popper.top),
     bottom: Math.round(popper.bottom),
     right: Math.floor(popper.right)
   };
</PRE><PRE>   var sideA = x === 'bottom' ? 'top' : 'bottom';
   var sideB = y === 'right' ? 'left' : 'right';
</PRE><PRE>   // if gpuAcceleration is set to `true` and transform is supported,
   //  we use `translate3d` to apply the position to the popper we
   // automatically use the supported prefixed version if needed
   var prefixedProperty = getSupportedPropertyName('transform');
</PRE><PRE>   // now, let's make a step back and look at this code closely (wtf?)
   // If the content of the popper grows once it's been positioned, it
   // may happen that the popper gets misplaced because of the new content
   // overflowing its reference element
   // To avoid this problem, we provide two options (x and y), which allow
   // the consumer to define the offset origin.
   // If we position a popper on top of a reference element, we can set
   // `x` to `top` to make the popper grow towards its top instead of
   // its bottom.
   var left = void 0,
       top = void 0;
   if (sideA === 'bottom') {
     top = -offsetParentRect.height + offsets.bottom;
   } else {
     top = offsets.top;
   }
   if (sideB === 'right') {
     left = -offsetParentRect.width + offsets.right;
   } else {
     left = offsets.left;
   }
   if (gpuAcceleration &amp;&amp; prefixedProperty) {
     styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
     styles[sideA] = 0;
     styles[sideB] = 0;
     styles.willChange = 'transform';
   } else {
     // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
     var invertTop = sideA === 'bottom' ? -1 : 1;
     var invertLeft = sideB === 'right' ? -1 : 1;
     styles[sideA] = top * invertTop;
     styles[sideB] = left * invertLeft;
     styles.willChange = sideA + ', ' + sideB;
   }
</PRE><PRE>   // Attributes
   var attributes = {
     'x-placement': data.placement
   };
</PRE><PRE>   // Update `data` attributes, styles and arrowStyles
   data.attributes = _extends({}, attributes, data.attributes);
   data.styles = _extends({}, styles, data.styles);
   data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
</PRE><PRE>   return data;
 }
</PRE><PRE> /**
  * Helper used to know if the given modifier depends from another one.
  * It checks if the needed modifier is listed and enabled.
  * @method
  * @memberof Popper.Utils
  * @param {Array} modifiers - list of modifiers
  * @param {String} requestingName - name of requesting modifier
  * @param {String} requestedName - name of requested modifier
  * @returns {Boolean}
  */
 function isModifierRequired(modifiers, requestingName, requestedName) {
   var requesting = find(modifiers, function (_ref) {
     var name = _ref.name;
     return name === requestingName;
   });
</PRE><PRE>   var isRequired = !!requesting &amp;&amp; modifiers.some(function (modifier) {
     return modifier.name === requestedName &amp;&amp; modifier.enabled &amp;&amp; modifier.order &lt; requesting.order;
   });
</PRE><PRE>   if (!isRequired) {
     var _requesting = '`' + requestingName + '`';
     var requested = '`' + requestedName + '`';
     console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
   }
   return isRequired;
 }
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by update method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The data object, properly modified
  */
 function arrow(data, options) {
   var _data$offsets$arrow;
</PRE><PRE>   // arrow depends on keepTogether in order to work
   if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
     return data;
   }
</PRE><PRE>   var arrowElement = options.element;
</PRE><PRE>   // if arrowElement is a string, suppose it's a CSS selector
   if (typeof arrowElement === 'string') {
     arrowElement = data.instance.popper.querySelector(arrowElement);
</PRE><PRE>     // if arrowElement is not found, don't run the modifier
     if (!arrowElement) {
       return data;
     }
   } else {
     // if the arrowElement isn't a query selector we must check that the
     // provided DOM node is child of its popper node
     if (!data.instance.popper.contains(arrowElement)) {
       console.warn('WARNING: `arrow.element` must be child of its popper element!');
       return data;
     }
   }
</PRE><PRE>   var placement = data.placement.split('-')[0];
   var _data$offsets = data.offsets,
       popper = _data$offsets.popper,
       reference = _data$offsets.reference;
</PRE><PRE>   var isVertical = ['left', 'right'].indexOf(placement) !== -1;
</PRE><PRE>   var len = isVertical ? 'height' : 'width';
   var sideCapitalized = isVertical ? 'Top' : 'Left';
   var side = sideCapitalized.toLowerCase();
   var altSide = isVertical ? 'left' : 'top';
   var opSide = isVertical ? 'bottom' : 'right';
   var arrowElementSize = getOuterSizes(arrowElement)[len];
</PRE><PRE>   //
   // extends keepTogether behavior making sure the popper and its
   // reference have enough pixels in conjuction
   //
</PRE><PRE>   // top/left side
   if (reference[opSide] - arrowElementSize &lt; popper[side]) {
     data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
   }
   // bottom/right side
   if (reference[side] + arrowElementSize &gt; popper[opSide]) {
     data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
   }
   data.offsets.popper = getClientRect(data.offsets.popper);
</PRE><PRE>   // compute center of the popper
   var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
</PRE><PRE>   // Compute the sideValue using the updated popper offsets
   // take popper margin in account because we don't have this info available
   var css = getStyleComputedProperty(data.instance.popper);
   var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
   var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
   var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
</PRE><PRE>   // prevent arrowElement from being placed not contiguously to its popper
   sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
</PRE><PRE>   data.arrowElement = arrowElement;
   data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, <I>), _data$offsets$arrow);</I></PRE><PRE>   return data;
 }
</PRE><PRE> /**
  * Get the opposite placement variation of the given one
  * @method
  * @memberof Popper.Utils
  * @argument {String} placement variation
  * @returns {String} flipped placement variation
  */
 function getOppositeVariation(variation) {
   if (variation === 'end') {
     return 'start';
   } else if (variation === 'start') {
     return 'end';
   }
   return variation;
 }
</PRE><PRE> /**
  * List of accepted placements to use as values of the `placement` option.
  * Valid placements are:
  * - `auto`
  * - `top`
  * - `right`
  * - `bottom`
  * - `left`
  *
  * Each placement can have a variation from this list:
  * - `-start`
  * - `-end`
  *
  * Variations are interpreted easily if you think of them as the left to right
  * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
  * is right.
  * Vertically (`left` and `right`), `start` is top and `end` is bottom.
  *
  * Some valid examples are:
  * - `top-end` (on top of reference, right aligned)
  * - `right-start` (on right of reference, top aligned)
  * - `bottom` (on bottom, centered)
  * - `auto-right` (on the side with more space available, alignment depends by placement)
  *
  * @static
  * @type {Array}
  * @enum {String}
  * @readonly
  * @method placements
  * @memberof Popper
  */
 var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
</PRE><PRE> // Get rid of `auto` `auto-start` and `auto-end`
 var validPlacements = placements.slice(3);
</PRE><PRE> /**
  * Given an initial placement, returns all the subsequent placements
  * clockwise (or counter-clockwise).
  *
  * @method
  * @memberof Popper.Utils
  * @argument {String} placement - A valid placement (it accepts variations)
  * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
  * @returns {Array} placements including their variations
  */
 function clockwise(placement) {
   var counter = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : false;
</PRE><PRE>   var index = validPlacements.indexOf(placement);
   var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
   return counter ? arr.reverse() : arr;
 }
</PRE><PRE> var BEHAVIORS = {
   FLIP: 'flip',
   CLOCKWISE: 'clockwise',
   COUNTERCLOCKWISE: 'counterclockwise'
 };
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by update method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The data object, properly modified
  */
 function flip(data, options) {
   // if `inner` modifier is enabled, we can't use the `flip` modifier
   if (isModifierEnabled(data.instance.modifiers, 'inner')) {
     return data;
   }
</PRE><PRE>   if (data.flipped &amp;&amp; data.placement === data.originalPlacement) {
     // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
     return data;
   }
</PRE><PRE>   var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
</PRE><PRE>   var placement = data.placement.split('-')[0];
   var placementOpposite = getOppositePlacement(placement);
   var variation = data.placement.split('-')[1] || <I>;</I></PRE><PRE>   var flipOrder = [];
</PRE><PRE>   switch (options.behavior) {
     case BEHAVIORS.FLIP:
       flipOrder = [placement, placementOpposite];
       break;
     case BEHAVIORS.CLOCKWISE:
       flipOrder = clockwise(placement);
       break;
     case BEHAVIORS.COUNTERCLOCKWISE:
       flipOrder = clockwise(placement, true);
       break;
     default:
       flipOrder = options.behavior;
   }
</PRE><PRE>   flipOrder.forEach(function (step, index) {
     if (placement !== step || flipOrder.length === index + 1) {
       return data;
     }
</PRE><PRE>     placement = data.placement.split('-')[0];
     placementOpposite = getOppositePlacement(placement);
</PRE><PRE>     var popperOffsets = data.offsets.popper;
     var refOffsets = data.offsets.reference;
</PRE><PRE>     // using floor because the reference offsets may contain decimals we are not going to consider here
     var floor = Math.floor;
     var overlapsRef = placement === 'left' &amp;&amp; floor(popperOffsets.right) &gt; floor(refOffsets.left) || placement === 'right' &amp;&amp; floor(popperOffsets.left) &lt; floor(refOffsets.right) || placement === 'top' &amp;&amp; floor(popperOffsets.bottom) &gt; floor(refOffsets.top) || placement === 'bottom' &amp;&amp; floor(popperOffsets.top) &lt; floor(refOffsets.bottom);
</PRE><PRE>     var overflowsLeft = floor(popperOffsets.left) &lt; floor(boundaries.left);
     var overflowsRight = floor(popperOffsets.right) &gt; floor(boundaries.right);
     var overflowsTop = floor(popperOffsets.top) &lt; floor(boundaries.top);
     var overflowsBottom = floor(popperOffsets.bottom) &gt; floor(boundaries.bottom);
</PRE><PRE>     var overflowsBoundaries = placement === 'left' &amp;&amp; overflowsLeft || placement === 'right' &amp;&amp; overflowsRight || placement === 'top' &amp;&amp; overflowsTop || placement === 'bottom' &amp;&amp; overflowsBottom;
</PRE><PRE>     // flip the variation if required
     var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
     var flippedVariation = !!options.flipVariations &amp;&amp; (isVertical &amp;&amp; variation === 'start' &amp;&amp; overflowsLeft || isVertical &amp;&amp; variation === 'end' &amp;&amp; overflowsRight || !isVertical &amp;&amp; variation === 'start' &amp;&amp; overflowsTop || !isVertical &amp;&amp; variation === 'end' &amp;&amp; overflowsBottom);
</PRE><PRE>     if (overlapsRef || overflowsBoundaries || flippedVariation) {
       // this boolean to detect any flip loop
       data.flipped = true;
</PRE><PRE>       if (overlapsRef || overflowsBoundaries) {
         placement = flipOrder[index + 1];
       }
</PRE><PRE>       if (flippedVariation) {
         variation = getOppositeVariation(variation);
       }
</PRE><PRE>       data.placement = placement + (variation ? '-' + variation : <I>);</I></PRE><PRE>       // this object contains `position`, we want to preserve it along with
       // any additional property we may add in the future
       data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
</PRE><PRE>       data = runModifiers(data.instance.modifiers, data, 'flip');
     }
   });
   return data;
 }
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by update method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The data object, properly modified
  */
 function keepTogether(data) {
   var _data$offsets = data.offsets,
       popper = _data$offsets.popper,
       reference = _data$offsets.reference;
</PRE><PRE>   var placement = data.placement.split('-')[0];
   var floor = Math.floor;
   var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
   var side = isVertical ? 'right' : 'bottom';
   var opSide = isVertical ? 'left' : 'top';
   var measurement = isVertical ? 'width' : 'height';
</PRE><PRE>   if (popper[side] &lt; floor(reference[opSide])) {
     data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
   }
   if (popper[opSide] &gt; floor(reference[side])) {
     data.offsets.popper[opSide] = floor(reference[side]);
   }
</PRE><PRE>   return data;
 }
</PRE><PRE> /**
  * Converts a string containing value + unit into a px value number
  * @function
  * @memberof {modifiers~offset}
  * @private
  * @argument {String} str - Value + unit string
  * @argument {String} measurement - `height` or `width`
  * @argument {Object} popperOffsets
  * @argument {Object} referenceOffsets
  * @returns {Number|String}
  * Value in pixels, or original string if no values were extracted
  */
 function toValue(str, measurement, popperOffsets, referenceOffsets) {
   // separate value from unit
   var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
   var value = +split[1];
   var unit = split[2];
</PRE><PRE>   // If it's not a number it's an operator, I guess
   if (!value) {
     return str;
   }
</PRE><PRE>   if (unit.indexOf('%') === 0) {
     var element = void 0;
     switch (unit) {
       case '%p':
         element = popperOffsets;
         break;
       case '%':
       case '%r':
       default:
         element = referenceOffsets;
     }
</PRE><PRE>     var rect = getClientRect(element);
     return rect[measurement] / 100 * value;
   } else if (unit === 'vh' || unit === 'vw') {
     // if is a vh or vw, we calculate the size based on the viewport
     var size = void 0;
     if (unit === 'vh') {
       size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
     } else {
       size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
     }
     return size / 100 * value;
   } else {
     // if is an explicit pixel unit, we get rid of the unit and keep the value
     // if is an implicit unit, it's px, and we return just the value
     return value;
   }
 }
</PRE><PRE> /**
  * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
  * @function
  * @memberof {modifiers~offset}
  * @private
  * @argument {String} offset
  * @argument {Object} popperOffsets
  * @argument {Object} referenceOffsets
  * @argument {String} basePlacement
  * @returns {Array} a two cells array with x and y offsets in numbers
  */
 function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
   var offsets = [0, 0];
</PRE><PRE>   // Use height if placement is left or right and index is 0 otherwise use width
   // in this way the first offset will use an axis and the second one
   // will use the other one
   var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
</PRE><PRE>   // Split the offset string to obtain a list of values and operands
   // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
   var fragments = offset.split(/(\+|\-)/).map(function (frag) {
     return frag.trim();
   });
</PRE><PRE>   // Detect if the offset string contains a pair of values or a single one
   // they could be separated by comma or space
   var divider = fragments.indexOf(find(fragments, function (frag) {
     return frag.search(/,|\s/) !== -1;
   }));
</PRE><PRE>   if (fragments[divider] &amp;&amp; fragments[divider].indexOf(',') === -1) {
     console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
   }
</PRE><PRE>   // If divider is found, we divide the list of values and operands to divide
   // them by ofset X and Y.
   var splitRegex = /\s*,\s*|\s+/;
   var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
</PRE><PRE>   // Convert the values with units to absolute pixels to allow our computations
   ops = ops.map(function (op, index) {
     // Most of the units rely on the orientation of the popper
     var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
     var mergeWithPrevious = false;
     return op
     // This aggregates any `+` or `-` sign that aren't considered operators
     // e.g.: 10 + +5 =&gt; [10, +, +5]
     .reduce(function (a, b) {
       if (a[a.length - 1] === <I>&amp;&amp; ['+', '-'].indexOf(b) !== -1) {</I>
         a[a.length - 1] = b;
         mergeWithPrevious = true;
         return a;
       } else if (mergeWithPrevious) {
         a[a.length - 1] += b;
         mergeWithPrevious = false;
         return a;
       } else {
         return a.concat(b);
       }
     }, [])
     // Here we convert the string values into number values (in px)
     .map(function (str) {
       return toValue(str, measurement, popperOffsets, referenceOffsets);
     });
   });
</PRE><PRE>   // Loop trough the offsets arrays and execute the operations
   ops.forEach(function (op, index) {
     op.forEach(function (frag, index2) {
       if (isNumeric(frag)) {
         offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
       }
     });
   });
   return offsets;
 }
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by update method
  * @argument {Object} options - Modifiers configuration and options
  * @argument {Number|String} options.offset=0
  * The offset value as described in the modifier description
  * @returns {Object} The data object, properly modified
  */
 function offset(data, _ref) {
   var offset = _ref.offset;
   var placement = data.placement,
       _data$offsets = data.offsets,
       popper = _data$offsets.popper,
       reference = _data$offsets.reference;
</PRE><PRE>   var basePlacement = placement.split('-')[0];
</PRE><PRE>   var offsets = void 0;
   if (isNumeric(+offset)) {
     offsets = [+offset, 0];
   } else {
     offsets = parseOffset(offset, popper, reference, basePlacement);
   }
</PRE><PRE>   if (basePlacement === 'left') {
     popper.top += offsets[0];
     popper.left -= offsets[1];
   } else if (basePlacement === 'right') {
     popper.top += offsets[0];
     popper.left += offsets[1];
   } else if (basePlacement === 'top') {
     popper.left += offsets[0];
     popper.top -= offsets[1];
   } else if (basePlacement === 'bottom') {
     popper.left += offsets[0];
     popper.top += offsets[1];
   }
</PRE><PRE>   data.popper = popper;
   return data;
 }
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by `update` method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The data object, properly modified
  */
 function preventOverflow(data, options) {
   var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
</PRE><PRE>   // If offsetParent is the reference element, we really want to
   // go one step up and use the next offsetParent as reference to
   // avoid to make this modifier completely useless and look like broken
   if (data.instance.reference === boundariesElement) {
     boundariesElement = getOffsetParent(boundariesElement);
   }
</PRE><PRE>   // NOTE: DOM access here
   // resets the popper's position so that the document size can be calculated excluding
   // the size of the popper element itself
   var transformProp = getSupportedPropertyName('transform');
   var popperStyles = data.instance.popper.style; // assignment to help minification
   var top = popperStyles.top,
       left = popperStyles.left,
       transform = popperStyles[transformProp];
</PRE><PRE>   popperStyles.top = <I>;</I>
   popperStyles.left = <I>;</I>
   popperStyles[transformProp] = <I>;</I></PRE><PRE>   var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
</PRE><PRE>   // NOTE: DOM access here
   // restores the original style properties after the offsets have been computed
   popperStyles.top = top;
   popperStyles.left = left;
   popperStyles[transformProp] = transform;
</PRE><PRE>   options.boundaries = boundaries;
</PRE><PRE>   var order = options.priority;
   var popper = data.offsets.popper;
</PRE><PRE>   var check = {
     primary: function primary(placement) {
       var value = popper[placement];
       if (popper[placement] &lt; boundaries[placement] &amp;&amp; !options.escapeWithReference) {
         value = Math.max(popper[placement], boundaries[placement]);
       }
       return defineProperty({}, placement, value);
     },
     secondary: function secondary(placement) {
       var mainSide = placement === 'right' ? 'left' : 'top';
       var value = popper[mainSide];
       if (popper[placement] &gt; boundaries[placement] &amp;&amp; !options.escapeWithReference) {
         value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
       }
       return defineProperty({}, mainSide, value);
     }
   };
</PRE><PRE>   order.forEach(function (placement) {
     var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
     popper = _extends({}, popper, check[side](placement));
   });
</PRE><PRE>   data.offsets.popper = popper;
</PRE><PRE>   return data;
 }
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by `update` method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The data object, properly modified
  */
 function shift(data) {
   var placement = data.placement;
   var basePlacement = placement.split('-')[0];
   var shiftvariation = placement.split('-')[1];
</PRE><PRE>   // if shift shiftvariation is specified, run the modifier
   if (shiftvariation) {
     var _data$offsets = data.offsets,
         reference = _data$offsets.reference,
         popper = _data$offsets.popper;
</PRE><PRE>     var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
     var side = isVertical ? 'left' : 'top';
     var measurement = isVertical ? 'width' : 'height';
</PRE><PRE>     var shiftOffsets = {
       start: defineProperty({}, side, reference[side]),
       end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
     };
</PRE><PRE>     data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
   }
</PRE><PRE>   return data;
 }
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by update method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The data object, properly modified
  */
 function hide(data) {
   if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
     return data;
   }
</PRE><PRE>   var refRect = data.offsets.reference;
   var bound = find(data.instance.modifiers, function (modifier) {
     return modifier.name === 'preventOverflow';
   }).boundaries;
</PRE><PRE>   if (refRect.bottom &lt; bound.top || refRect.left &gt; bound.right || refRect.top &gt; bound.bottom || refRect.right &lt; bound.left) {
     // Avoid unnecessary DOM access if visibility hasn't changed
     if (data.hide === true) {
       return data;
     }
</PRE><PRE>     data.hide = true;
     data.attributes['x-out-of-boundaries'] = <I>;</I>
   } else {
     // Avoid unnecessary DOM access if visibility hasn't changed
     if (data.hide === false) {
       return data;
     }
</PRE><PRE>     data.hide = false;
     data.attributes['x-out-of-boundaries'] = false;
   }
</PRE><PRE>   return data;
 }
</PRE><PRE> /**
  * @function
  * @memberof Modifiers
  * @argument {Object} data - The data object generated by `update` method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {Object} The data object, properly modified
  */
 function inner(data) {
   var placement = data.placement;
   var basePlacement = placement.split('-')[0];
   var _data$offsets = data.offsets,
       popper = _data$offsets.popper,
       reference = _data$offsets.reference;
</PRE><PRE>   var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
</PRE><PRE>   var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
</PRE><PRE>   popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
</PRE><PRE>   data.placement = getOppositePlacement(placement);
   data.offsets.popper = getClientRect(popper);
</PRE><PRE>   return data;
 }
</PRE><PRE> /**
  * Modifier function, each modifier can have a function of this type assigned
  * to its `fn` property.
  * These functions will be called on each update, this means that you must
  * make sure they are performant enough to avoid performance bottlenecks.
  *
  * @function ModifierFn
  * @argument {dataObject} data - The data object generated by `update` method
  * @argument {Object} options - Modifiers configuration and options
  * @returns {dataObject} The data object, properly modified
  */
</PRE><PRE> /**
  * Modifiers are plugins used to alter the behavior of your poppers.
  * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
  * needed by the library.
  *
  * Usually you don't want to override the `order`, `fn` and `onLoad` props.
  * All the other properties are configurations that could be tweaked.
  * @namespace modifiers
  */
 var modifiers = {
   /**
    * Modifier used to shift the popper on the start or end of its reference
    * element.
    * It will read the variation of the `placement` property.
    * It can be one either `-end` or `-start`.
    * @memberof modifiers
    * @inner
    */
   shift: {
     /** @prop {number} order=100 - Index used to define the order of execution */
     order: 100,
     /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
     enabled: true,
     /** @prop {ModifierFn} */
     fn: shift
   },
</PRE><PRE>   /**
    * The `offset` modifier can shift your popper on both its axis.
    *
    * It accepts the following units:
    * - `px` or unitless, interpreted as pixels
    * - `%` or `%r`, percentage relative to the length of the reference element
    * - `%p`, percentage relative to the length of the popper element
    * - `vw`, CSS viewport width unit
    * - `vh`, CSS viewport height unit
    *
    * For length is intended the main axis relative to the placement of the popper.
    * This means that if the placement is `top` or `bottom`, the length will be the
    * `width`. In case of `left` or `right`, it will be the height.
    *
    * You can provide a single value (as `Number` or `String`), or a pair of values
    * as `String` divided by a comma or one (or more) white spaces.
    * The latter is a deprecated method because it leads to confusion and will be
    * removed in v2.
    * Additionally, it accepts additions and subtractions between different units.
    * Note that multiplications and divisions aren't supported.
    *
    * Valid examples are:
    * ```
    * 10
    * '10%'
    * '10, 10'
    * '10%, 10'
    * '10 + 10%'
    * '10 - 5vh + 3%'
    * '-10px + 5vh, 5px - 6%'
    * ```
    * &gt; **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
    * &gt; with their reference element, unfortunately, you will have to disable the `flip` modifier.
    * &gt; More on this [reading this issue](<A rel="nofollow" class="external free" href="https://github.com/FezVrasta/popper.js/issues/373">https://github.com/FezVrasta/popper.js/issues/373</A>)
    *
    * @memberof modifiers
    * @inner
    */
   offset: {
     /** @prop {number} order=200 - Index used to define the order of execution */
     order: 200,
     /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
     enabled: true,
     /** @prop {ModifierFn} */
     fn: offset,
     /** @prop {Number|String} offset=0
      * The offset value as described in the modifier description
      */
     offset: 0
   },
</PRE><PRE>   /**
    * Modifier used to prevent the popper from being positioned outside the boundary.
    *
    * An scenario exists where the reference itself is not within the boundaries.
    * We can say it has &quot;escaped the boundaries&quot; â€” or just &quot;escaped&quot;.
    * In this case we need to decide whether the popper should either:
    *
    * - detach from the reference and remain &quot;trapped&quot; in the boundaries, or
    * - if it should ignore the boundary and &quot;escape with its reference&quot;
    *
    * When `escapeWithReference` is set to`true` and reference is completely
    * outside its boundaries, the popper will overflow (or completely leave)
    * the boundaries in order to remain attached to the edge of the reference.
    *
    * @memberof modifiers
    * @inner
    */
   preventOverflow: {
     /** @prop {number} order=300 - Index used to define the order of execution */
     order: 300,
     /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
     enabled: true,
     /** @prop {ModifierFn} */
     fn: preventOverflow,
     /**
      * @prop {Array} [priority=['left','right','top','bottom']]
      * Popper will try to prevent overflow following these priorities by default,
      * then, it could overflow on the left and on top of the `boundariesElement`
      */
     priority: ['left', 'right', 'top', 'bottom'],
     /**
      * @prop {number} padding=5
      * Amount of pixel used to define a minimum distance between the boundaries
      * and the popper this makes sure the popper has always a little padding
      * between the edges of its container
      */
     padding: 5,
     /**
      * @prop {String|HTMLElement} boundariesElement='scrollParent'
      * Boundaries used by the modifier, can be `scrollParent`, `window`,
      * `viewport` or any DOM element.
      */
     boundariesElement: 'scrollParent'
   },
</PRE><PRE>   /**
    * Modifier used to make sure the reference and its popper stay near eachothers
    * without leaving any gap between the two. Expecially useful when the arrow is
    * enabled and you want to assure it to point to its reference element.
    * It cares only about the first axis, you can still have poppers with margin
    * between the popper and its reference element.
    * @memberof modifiers
    * @inner
    */
   keepTogether: {
     /** @prop {number} order=400 - Index used to define the order of execution */
     order: 400,
     /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
     enabled: true,
     /** @prop {ModifierFn} */
     fn: keepTogether
   },
</PRE><PRE>   /**
    * This modifier is used to move the `arrowElement` of the popper to make
    * sure it is positioned between the reference element and its popper element.
    * It will read the outer size of the `arrowElement` node to detect how many
    * pixels of conjuction are needed.
    *
    * It has no effect if no `arrowElement` is provided.
    * @memberof modifiers
    * @inner
    */
   arrow: {
     /** @prop {number} order=500 - Index used to define the order of execution */
     order: 500,
     /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
     enabled: true,
     /** @prop {ModifierFn} */
     fn: arrow,
     /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
     element: '[x-arrow]'
   },
</PRE><PRE>   /**
    * Modifier used to flip the popper's placement when it starts to overlap its
    * reference element.
    *
    * Requires the `preventOverflow` modifier before it in order to work.
    *
    * **NOTE:** this modifier will interrupt the current update cycle and will
    * restart it if it detects the need to flip the placement.
    * @memberof modifiers
    * @inner
    */
   flip: {
     /** @prop {number} order=600 - Index used to define the order of execution */
     order: 600,
     /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
     enabled: true,
     /** @prop {ModifierFn} */
     fn: flip,
     /**
      * @prop {String|Array} behavior='flip'
      * The behavior used to change the popper's placement. It can be one of
      * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
      * placements (with optional variations).
      */
     behavior: 'flip',
     /**
      * @prop {number} padding=5
      * The popper will flip if it hits the edges of the `boundariesElement`
      */
     padding: 5,
     /**
      * @prop {String|HTMLElement} boundariesElement='viewport'
      * The element which will define the boundaries of the popper position,
      * the popper will never be placed outside of the defined boundaries
      * (except if keepTogether is enabled)
      */
     boundariesElement: 'viewport'
   },
</PRE><PRE>   /**
    * Modifier used to make the popper flow toward the inner of the reference element.
    * By default, when this modifier is disabled, the popper will be placed outside
    * the reference element.
    * @memberof modifiers
    * @inner
    */
   inner: {
     /** @prop {number} order=700 - Index used to define the order of execution */
     order: 700,
     /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
     enabled: false,
     /** @prop {ModifierFn} */
     fn: inner
   },
</PRE><PRE>   /**
    * Modifier used to hide the popper when its reference element is outside of the
    * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
    * be used to hide with a CSS selector the popper when its reference is
    * out of boundaries.
    *
    * Requires the `preventOverflow` modifier before it in order to work.
    * @memberof modifiers
    * @inner
    */
   hide: {
     /** @prop {number} order=800 - Index used to define the order of execution */
     order: 800,
     /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
     enabled: true,
     /** @prop {ModifierFn} */
     fn: hide
   },
</PRE><PRE>   /**
    * Computes the style that will be applied to the popper element to gets
    * properly positioned.
    *
    * Note that this modifier will not touch the DOM, it just prepares the styles
    * so that `applyStyle` modifier can apply it. This separation is useful
    * in case you need to replace `applyStyle` with a custom implementation.
    *
    * This modifier has `850` as `order` value to maintain backward compatibility
    * with previous versions of Popper.js. Expect the modifiers ordering method
    * to change in future major versions of the library.
    *
    * @memberof modifiers
    * @inner
    */
   computeStyle: {
     /** @prop {number} order=850 - Index used to define the order of execution */
     order: 850,
     /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
     enabled: true,
     /** @prop {ModifierFn} */
     fn: computeStyle,
     /**
      * @prop {Boolean} gpuAcceleration=true
      * If true, it uses the CSS 3d transformation to position the popper.
      * Otherwise, it will use the `top` and `left` properties.
      */
     gpuAcceleration: true,
     /**
      * @prop {string} [x='bottom']
      * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
      * Change this if your popper should grow in a direction different from `bottom`
      */
     x: 'bottom',
     /**
      * @prop {string} [x='left']
      * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
      * Change this if your popper should grow in a direction different from `right`
      */
     y: 'right'
   },
</PRE><PRE>   /**
    * Applies the computed styles to the popper element.
    *
    * All the DOM manipulations are limited to this modifier. This is useful in case
    * you want to integrate Popper.js inside a framework or view library and you
    * want to delegate all the DOM manipulations to it.
    *
    * Note that if you disable this modifier, you must make sure the popper element
    * has its position set to `absolute` before Popper.js can do its work!
    *
    * Just disable this modifier and define you own to achieve the desired effect.
    *
    * @memberof modifiers
    * @inner
    */
   applyStyle: {
     /** @prop {number} order=900 - Index used to define the order of execution */
     order: 900,
     /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
     enabled: true,
     /** @prop {ModifierFn} */
     fn: applyStyle,
     /** @prop {Function} */
     onLoad: applyStyleOnLoad,
     /**
      * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
      * @prop {Boolean} gpuAcceleration=true
      * If true, it uses the CSS 3d transformation to position the popper.
      * Otherwise, it will use the `top` and `left` properties.
      */
     gpuAcceleration: undefined
   }
 };
</PRE><PRE> /**
  * The `dataObject` is an object containing all the informations used by Popper.js
  * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
  * @name dataObject
  * @property {Object} data.instance The Popper.js instance
  * @property {String} data.placement Placement applied to popper
  * @property {String} data.originalPlacement Placement originally defined on init
  * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
  * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
  * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
  * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
  * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
  * @property {Object} data.boundaries Offsets of the popper boundaries
  * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
  * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
  * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
  * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
  */
</PRE><PRE> /**
  * Default options provided to Popper.js constructor.
  * These can be overriden using the `options` argument of Popper.js.
  * To override an option, simply pass as 3rd argument an object with the same
  * structure of this object, example:
  * ```
  * new Popper(ref, pop, {
  *   modifiers: {
  *     preventOverflow: { enabled: false }
  *   }
  * })
  * ```
  * @type {Object}
  * @static
  * @memberof Popper
  */
 var Defaults = {
   /**
    * Popper's placement
    * @prop {Popper.placements} placement='bottom'
    */
   placement: 'bottom',
</PRE><PRE>   /**
    * Set this to true if you want popper to position it self in 'fixed' mode
    * @prop {Boolean} positionFixed=false
    */
   positionFixed: false,
</PRE><PRE>   /**
    * Whether events (resize, scroll) are initially enabled
    * @prop {Boolean} eventsEnabled=true
    */
   eventsEnabled: true,
</PRE><PRE>   /**
    * Set to true if you want to automatically remove the popper when
    * you call the `destroy` method.
    * @prop {Boolean} removeOnDestroy=false
    */
   removeOnDestroy: false,
</PRE><PRE>   /**
    * Callback called when the popper is created.
    * By default, is set to no-op.
    * Access Popper.js instance with `data.instance`.
    * @prop {onCreate}
    */
   onCreate: function onCreate() {},
</PRE><PRE>   /**
    * Callback called when the popper is updated, this callback is not called
    * on the initialization/creation of the popper, but only on subsequent
    * updates.
    * By default, is set to no-op.
    * Access Popper.js instance with `data.instance`.
    * @prop {onUpdate}
    */
   onUpdate: function onUpdate() {},
</PRE><PRE>   /**
    * List of modifiers used to modify the offsets before they are applied to the popper.
    * They provide most of the functionalities of Popper.js
    * @prop {modifiers}
    */
   modifiers: modifiers
 };
</PRE><PRE> /**
  * @callback onCreate
  * @param {dataObject} data
  */
</PRE><PRE> /**
  * @callback onUpdate
  * @param {dataObject} data
  */
</PRE><PRE> // Utils
 // Methods
 var Popper = function () {
   /**
    * Create a new Popper.js instance
    * @class Popper
    * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
    * @param {HTMLElement} popper - The HTML element used as popper.
    * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
    * @return {Object} instance - The generated Popper.js instance
    */
   function Popper(reference, popper) {
     var _this = this;
</PRE><PRE>     var options = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : {};
     classCallCheck(this, Popper);
</PRE><PRE>     this.scheduleUpdate = function () {
       return requestAnimationFrame(_this.update);
     };
</PRE><PRE>     // make update() debounced, so that it only runs at most once-per-tick
     this.update = debounce(this.update.bind(this));
</PRE><PRE>     // with {} we create a new object with the options inside it
     this.options = _extends({}, Popper.Defaults, options);
</PRE><PRE>     // init state
     this.state = {
       isDestroyed: false,
       isCreated: false,
       scrollParents: []
     };
</PRE><PRE>     // get reference and popper elements (allow jQuery wrappers)
     this.reference = reference &amp;&amp; reference.jquery ? reference[0] : reference;
     this.popper = popper &amp;&amp; popper.jquery ? popper[0] : popper;
</PRE><PRE>     // Deep merge modifiers options
     this.options.modifiers = {};
     Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
       _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
     });
</PRE><PRE>     // Refactoring modifiers' list (Object =&gt; Array)
     this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
       return _extends({
         name: name
       }, _this.options.modifiers[name]);
     })
     // sort the modifiers by order
     .sort(function (a, b) {
       return a.order - b.order;
     });
</PRE><PRE>     // modifiers have the ability to execute arbitrary code when Popper.js get inited
     // such code is executed in the same order of its modifier
     // they could add new properties to their options configuration
     // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
     this.modifiers.forEach(function (modifierOptions) {
       if (modifierOptions.enabled &amp;&amp; isFunction(modifierOptions.onLoad)) {
         modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
       }
     });
</PRE><PRE>     // fire the first update to position the popper in the right place
     this.update();
</PRE><PRE>     var eventsEnabled = this.options.eventsEnabled;
     if (eventsEnabled) {
       // setup event listeners, they will take care of update the position in specific situations
       this.enableEventListeners();
     }
</PRE><PRE>     this.state.eventsEnabled = eventsEnabled;
   }
</PRE><PRE>   // We can't use class properties because they don't get listed in the
   // class prototype and break stuff like Sinon stubs
</PRE><PRE>   createClass(Popper, [{
     key: 'update',
     value: function update$$1() {
       return update.call(this);
     }
   }, {
     key: 'destroy',
     value: function destroy$$1() {
       return destroy.call(this);
     }
   }, {
     key: 'enableEventListeners',
     value: function enableEventListeners$$1() {
       return enableEventListeners.call(this);
     }
   }, {
     key: 'disableEventListeners',
     value: function disableEventListeners$$1() {
       return disableEventListeners.call(this);
     }
</PRE><PRE>     /**
      * Schedule an update, it will run on the next UI update available
      * @method scheduleUpdate
      * @memberof Popper
      */
</PRE><PRE>     /**
      * Collection of utilities useful when writing custom modifiers.
      * Starting from version 1.7, this method is available only if you
      * include `popper-utils.js` before `popper.js`.
      *
      * **DEPRECATION**: This way to access PopperUtils is deprecated
      * and will be removed in v2! Use the PopperUtils module directly instead.
      * Due to the high instability of the methods contained in Utils, we can't
      * guarantee them to follow semver. Use them at your own risk!
      * @static
      * @private
      * @type {Object}
      * @deprecated since version 1.8
      * @member Utils
      * @memberof Popper
      */
</PRE><PRE>   }]);
   return Popper;
 }();
</PRE><PRE> /**
  * The `referenceObject` is an object that provides an interface compatible with Popper.js
  * and lets you use it as replacement of a real DOM node.
  * You can use this method to position a popper relatively to a set of coordinates
  * in case you don't have a DOM node to use as reference.
  *
  * ```
  * new Popper(referenceObject, popperNode);
  * ```
  *
  * NB: This feature isn't supported in Internet Explorer 10
  * @name referenceObject
  * @property {Function} data.getBoundingClientRect
  * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
  * @property {number} data.clientWidth
  * An ES6 getter that will return the width of the virtual reference element.
  * @property {number} data.clientHeight
  * An ES6 getter that will return the height of the virtual reference element.
  */
</PRE><PRE> Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
 Popper.placements = placements;
 Popper.Defaults = Defaults;
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): dropdown.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Dropdown = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'dropdown';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.dropdown';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key
</PRE><PRE>   var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key
</PRE><PRE>   var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key
</PRE><PRE>   var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key
</PRE><PRE>   var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key
</PRE><PRE>   var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)
</PRE><PRE>   var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + &quot;|&quot; + ARROW_DOWN_KEYCODE + &quot;|&quot; + ESCAPE_KEYCODE);
   var Event = {
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     CLICK: &quot;click&quot; + EVENT_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
     KEYDOWN_DATA_API: &quot;keydown&quot; + EVENT_KEY + DATA_API_KEY,
     KEYUP_DATA_API: &quot;keyup&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     DISABLED: 'disabled',
     SHOW: 'show',
     DROPUP: 'dropup',
     DROPRIGHT: 'dropright',
     DROPLEFT: 'dropleft',
     MENURIGHT: 'dropdown-menu-right',
     MENULEFT: 'dropdown-menu-left',
     POSITION_STATIC: 'position-static'
   };
   var Selector = {
     DATA_TOGGLE: '[data-toggle=&quot;dropdown&quot;]',
     FORM_CHILD: '.dropdown form',
     MENU: '.dropdown-menu',
     NAVBAR_NAV: '.navbar-nav',
     VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'
   };
   var AttachmentMap = {
     TOP: 'top-start',
     TOPEND: 'top-end',
     BOTTOM: 'bottom-start',
     BOTTOMEND: 'bottom-end',
     RIGHT: 'right-start',
     RIGHTEND: 'right-end',
     LEFT: 'left-start',
     LEFTEND: 'left-end'
   };
   var Default = {
     offset: 0,
     flip: true,
     boundary: 'scrollParent',
     reference: 'toggle',
     display: 'dynamic'
   };
   var DefaultType = {
     offset: '(number|string|function)',
     flip: 'boolean',
     boundary: '(string|element)',
     reference: '(string|element)',
     display: 'string'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Dropdown =
   /*#__PURE__*/
   function () {
     function Dropdown(element, config) {
       this._element = element;
       this._popper = null;
       this._config = this._getConfig(config);
       this._menu = this._getMenuElement();
       this._inNavbar = this._detectNavbar();
</PRE><PRE>       this._addEventListeners();
     } // Getters
</PRE><PRE>     var _proto = Dropdown.prototype;
</PRE><PRE>     // Public
     _proto.toggle = function toggle() {
       if (this._element.disabled || $$$1(this._element).hasClass(ClassName.DISABLED)) {
         return;
       }
</PRE><PRE>       var parent = Dropdown._getParentFromElement(this._element);
</PRE><PRE>       var isActive = $$$1(this._menu).hasClass(ClassName.SHOW);
</PRE><PRE>       Dropdown._clearMenus();
</PRE><PRE>       if (isActive) {
         return;
       }
</PRE><PRE>       var relatedTarget = {
         relatedTarget: this._element
       };
       var showEvent = $$$1.Event(Event.SHOW, relatedTarget);
       $$$1(parent).trigger(showEvent);
</PRE><PRE>       if (showEvent.isDefaultPrevented()) {
         return;
       } // Disable totally Popper.js for Dropdown in Navbar
</PRE><PRE>       if (!this._inNavbar) {
         /**
          * Check for Popper dependency
          * Popper - <A rel="nofollow" class="external free" href="https://popper.js.org">https://popper.js.org</A>
          */
         if (typeof Popper === 'undefined') {
           throw new TypeError('Bootstrap dropdown require Popper.js (<A rel="nofollow" class="external free" href="https://popper.js.org)'">https://popper.js.org)'</A>);
         }
</PRE><PRE>         var referenceElement = this._element;
</PRE><PRE>         if (this._config.reference === 'parent') {
           referenceElement = parent;
         } else if (Util.isElement(this._config.reference)) {
           referenceElement = this._config.reference; // Check if it's jQuery element
</PRE><PRE>           if (typeof this._config.reference.jquery !== 'undefined') {
             referenceElement = this._config.reference[0];
           }
         } // If boundary is not `scrollParent`, then set position to `static`
         // to allow the menu to &quot;escape&quot; the scroll parent's boundaries
         // <A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/issues/24251">https://github.com/twbs/bootstrap/issues/24251</A></PRE><PRE>         if (this._config.boundary !== 'scrollParent') {
           $$$1(parent).addClass(ClassName.POSITION_STATIC);
         }
</PRE><PRE>         this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());
       } // If this is a touch-enabled device we add extra
       // empty mouseover listeners to the body's immediate children;
       // only needed because of broken event delegation on iOS
       // <A rel="nofollow" class="external free" href="https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html">https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html</A></PRE><PRE>       if ('ontouchstart' in document.documentElement &amp;&amp; $$$1(parent).closest(Selector.NAVBAR_NAV).length === 0) {
         $$$1(document.body).children().on('mouseover', null, $$$1.noop);
       }
</PRE><PRE>       this._element.focus();
</PRE><PRE>       this._element.setAttribute('aria-expanded', true);
</PRE><PRE>       $$$1(this._menu).toggleClass(ClassName.SHOW);
       $$$1(parent).toggleClass(ClassName.SHOW).trigger($$$1.Event(Event.SHOWN, relatedTarget));
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       $$$1(this._element).off(EVENT_KEY);
       this._element = null;
       this._menu = null;
</PRE><PRE>       if (this._popper !== null) {
         this._popper.destroy();
</PRE><PRE>         this._popper = null;
       }
     };
</PRE><PRE>     _proto.update = function update() {
       this._inNavbar = this._detectNavbar();
</PRE><PRE>       if (this._popper !== null) {
         this._popper.scheduleUpdate();
       }
     }; // Private
</PRE><PRE>     _proto._addEventListeners = function _addEventListeners() {
       var _this = this;
</PRE><PRE>       $$$1(this._element).on(Event.CLICK, function (event) {
         event.preventDefault();
         event.stopPropagation();
</PRE><PRE>         _this.toggle();
       });
     };
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, this.constructor.Default, $$$1(this._element).data(), config);
       Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
       return config;
     };
</PRE><PRE>     _proto._getMenuElement = function _getMenuElement() {
       if (!this._menu) {
         var parent = Dropdown._getParentFromElement(this._element);
</PRE><PRE>         if (parent) {
           this._menu = parent.querySelector(Selector.MENU);
         }
       }
</PRE><PRE>       return this._menu;
     };
</PRE><PRE>     _proto._getPlacement = function _getPlacement() {
       var $parentDropdown = $$$1(this._element.parentNode);
       var placement = AttachmentMap.BOTTOM; // Handle dropup
</PRE><PRE>       if ($parentDropdown.hasClass(ClassName.DROPUP)) {
         placement = AttachmentMap.TOP;
</PRE><PRE>         if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
           placement = AttachmentMap.TOPEND;
         }
       } else if ($parentDropdown.hasClass(ClassName.DROPRIGHT)) {
         placement = AttachmentMap.RIGHT;
       } else if ($parentDropdown.hasClass(ClassName.DROPLEFT)) {
         placement = AttachmentMap.LEFT;
       } else if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
         placement = AttachmentMap.BOTTOMEND;
       }
</PRE><PRE>       return placement;
     };
</PRE><PRE>     _proto._detectNavbar = function _detectNavbar() {
       return $$$1(this._element).closest('.navbar').length &gt; 0;
     };
</PRE><PRE>     _proto._getPopperConfig = function _getPopperConfig() {
       var _this2 = this;
</PRE><PRE>       var offsetConf = {};
</PRE><PRE>       if (typeof this._config.offset === 'function') {
         offsetConf.fn = function (data) {
           data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets) || {});
           return data;
         };
       } else {
         offsetConf.offset = this._config.offset;
       }
</PRE><PRE>       var popperConfig = {
         placement: this._getPlacement(),
         modifiers: {
           offset: offsetConf,
           flip: {
             enabled: this._config.flip
           },
           preventOverflow: {
             boundariesElement: this._config.boundary
           }
         } // Disable Popper.js if we have a static display
</PRE><PRE>       };
</PRE><PRE>       if (this._config.display === 'static') {
         popperConfig.modifiers.applyStyle = {
           enabled: false
         };
       }
</PRE><PRE>       return popperConfig;
     }; // Static
</PRE><PRE>     Dropdown._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = typeof config === 'object' ? config : null;
</PRE><PRE>         if (!data) {
           data = new Dropdown(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config]();
         }
       });
     };
</PRE><PRE>     Dropdown._clearMenus = function _clearMenus(event) {
       if (event &amp;&amp; (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' &amp;&amp; event.which !== TAB_KEYCODE)) {
         return;
       }
</PRE><PRE>       var toggles = [].slice.call(document.querySelectorAll(Selector.DATA_TOGGLE));
</PRE><PRE>       for (var i = 0, len = toggles.length; i &lt; len; i++) {
         var parent = Dropdown._getParentFromElement(toggles[i]);
</PRE><PRE>         var context = $$$1(toggles[i]).data(DATA_KEY);
         var relatedTarget = {
           relatedTarget: toggles[i]
         };
</PRE><PRE>         if (event &amp;&amp; event.type === 'click') {
           relatedTarget.clickEvent = event;
         }
</PRE><PRE>         if (!context) {
           continue;
         }
</PRE><PRE>         var dropdownMenu = context._menu;
</PRE><PRE>         if (!$$$1(parent).hasClass(ClassName.SHOW)) {
           continue;
         }
</PRE><PRE>         if (event &amp;&amp; (event.type === 'click' &amp;&amp; /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' &amp;&amp; event.which === TAB_KEYCODE) &amp;&amp; $$$1.contains(parent, event.target)) {
           continue;
         }
</PRE><PRE>         var hideEvent = $$$1.Event(Event.HIDE, relatedTarget);
         $$$1(parent).trigger(hideEvent);
</PRE><PRE>         if (hideEvent.isDefaultPrevented()) {
           continue;
         } // If this is a touch-enabled device we remove the extra
         // empty mouseover listeners we added for iOS support
</PRE><PRE>         if ('ontouchstart' in document.documentElement) {
           $$$1(document.body).children().off('mouseover', null, $$$1.noop);
         }
</PRE><PRE>         toggles[i].setAttribute('aria-expanded', 'false');
         $$$1(dropdownMenu).removeClass(ClassName.SHOW);
         $$$1(parent).removeClass(ClassName.SHOW).trigger($$$1.Event(Event.HIDDEN, relatedTarget));
       }
     };
</PRE><PRE>     Dropdown._getParentFromElement = function _getParentFromElement(element) {
       var parent;
       var selector = Util.getSelectorFromElement(element);
</PRE><PRE>       if (selector) {
         parent = document.querySelector(selector);
       }
</PRE><PRE>       return parent || element.parentNode;
     }; // eslint-disable-next-line complexity
</PRE><PRE>     Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
       // If not input/textarea:
       //  - And not a key in REGEXP_KEYDOWN =&gt; not a dropdown command
       // If input/textarea:
       //  - If space key =&gt; not a dropdown command
       //  - If key is other than escape
       //    - If key is not up or down =&gt; not a dropdown command
       //    - If trigger inside the menu =&gt; not a dropdown command
       if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE &amp;&amp; (event.which !== ARROW_DOWN_KEYCODE &amp;&amp; event.which !== ARROW_UP_KEYCODE || $$$1(event.target).closest(Selector.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
         return;
       }
</PRE><PRE>       event.preventDefault();
       event.stopPropagation();
</PRE><PRE>       if (this.disabled || $$$1(this).hasClass(ClassName.DISABLED)) {
         return;
       }
</PRE><PRE>       var parent = Dropdown._getParentFromElement(this);
</PRE><PRE>       var isActive = $$$1(parent).hasClass(ClassName.SHOW);
</PRE><PRE>       if (!isActive &amp;&amp; (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive &amp;&amp; (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
         if (event.which === ESCAPE_KEYCODE) {
           var toggle = parent.querySelector(Selector.DATA_TOGGLE);
           $$$1(toggle).trigger('focus');
         }
</PRE><PRE>         $$$1(this).trigger('click');
         return;
       }
</PRE><PRE>       var items = [].slice.call(parent.querySelectorAll(Selector.VISIBLE_ITEMS));
</PRE><PRE>       if (items.length === 0) {
         return;
       }
</PRE><PRE>       var index = items.indexOf(event.target);
</PRE><PRE>       if (event.which === ARROW_UP_KEYCODE &amp;&amp; index &gt; 0) {
         // Up
         index--;
       }
</PRE><PRE>       if (event.which === ARROW_DOWN_KEYCODE &amp;&amp; index &lt; items.length - 1) {
         // Down
         index++;
       }
</PRE><PRE>       if (index &lt; 0) {
         index = 0;
       }
</PRE><PRE>       items[index].focus();
     };
</PRE><PRE>     _createClass(Dropdown, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }, {
       key: &quot;DefaultType&quot;,
       get: function get() {
         return DefaultType;
       }
     }]);
</PRE><PRE>     return Dropdown;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + &quot; &quot; + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
     event.preventDefault();
     event.stopPropagation();
</PRE><PRE>     Dropdown._jQueryInterface.call($$$1(this), 'toggle');
   }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
     e.stopPropagation();
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Dropdown._jQueryInterface;
   $$$1.fn[NAME].Constructor = Dropdown;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Dropdown._jQueryInterface;
   };
</PRE><PRE>   return Dropdown;
 }($, Popper);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): modal.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Modal = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'modal';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.modal';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key
</PRE><PRE>   var Default = {
     backdrop: true,
     keyboard: true,
     focus: true,
     show: true
   };
   var DefaultType = {
     backdrop: '(boolean|string)',
     keyboard: 'boolean',
     focus: 'boolean',
     show: 'boolean'
   };
   var Event = {
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
     RESIZE: &quot;resize&quot; + EVENT_KEY,
     CLICK_DISMISS: &quot;click.dismiss&quot; + EVENT_KEY,
     KEYDOWN_DISMISS: &quot;keydown.dismiss&quot; + EVENT_KEY,
     MOUSEUP_DISMISS: &quot;mouseup.dismiss&quot; + EVENT_KEY,
     MOUSEDOWN_DISMISS: &quot;mousedown.dismiss&quot; + EVENT_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
     BACKDROP: 'modal-backdrop',
     OPEN: 'modal-open',
     FADE: 'fade',
     SHOW: 'show'
   };
   var Selector = {
     DIALOG: '.modal-dialog',
     DATA_TOGGLE: '[data-toggle=&quot;modal&quot;]',
     DATA_DISMISS: '[data-dismiss=&quot;modal&quot;]',
     FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
     STICKY_CONTENT: '.sticky-top'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Modal =
   /*#__PURE__*/
   function () {
     function Modal(element, config) {
       this._config = this._getConfig(config);
       this._element = element;
       this._dialog = element.querySelector(Selector.DIALOG);
       this._backdrop = null;
       this._isShown = false;
       this._isBodyOverflowing = false;
       this._ignoreBackdropClick = false;
       this._scrollbarWidth = 0;
     } // Getters
</PRE><PRE>     var _proto = Modal.prototype;
</PRE><PRE>     // Public
     _proto.toggle = function toggle(relatedTarget) {
       return this._isShown ? this.hide() : this.show(relatedTarget);
     };
</PRE><PRE>     _proto.show = function show(relatedTarget) {
       var _this = this;
</PRE><PRE>       if (this._isTransitioning || this._isShown) {
         return;
       }
</PRE><PRE>       if ($$$1(this._element).hasClass(ClassName.FADE)) {
         this._isTransitioning = true;
       }
</PRE><PRE>       var showEvent = $$$1.Event(Event.SHOW, {
         relatedTarget: relatedTarget
       });
       $$$1(this._element).trigger(showEvent);
</PRE><PRE>       if (this._isShown || showEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       this._isShown = true;
</PRE><PRE>       this._checkScrollbar();
</PRE><PRE>       this._setScrollbar();
</PRE><PRE>       this._adjustDialog();
</PRE><PRE>       $$$1(document.body).addClass(ClassName.OPEN);
</PRE><PRE>       this._setEscapeEvent();
</PRE><PRE>       this._setResizeEvent();
</PRE><PRE>       $$$1(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
         return _this.hide(event);
       });
       $$$1(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
         $$$1(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {
           if ($$$1(event.target).is(_this._element)) {
             _this._ignoreBackdropClick = true;
           }
         });
       });
</PRE><PRE>       this._showBackdrop(function () {
         return _this._showElement(relatedTarget);
       });
     };
</PRE><PRE>     _proto.hide = function hide(event) {
       var _this2 = this;
</PRE><PRE>       if (event) {
         event.preventDefault();
       }
</PRE><PRE>       if (this._isTransitioning || !this._isShown) {
         return;
       }
</PRE><PRE>       var hideEvent = $$$1.Event(Event.HIDE);
       $$$1(this._element).trigger(hideEvent);
</PRE><PRE>       if (!this._isShown || hideEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       this._isShown = false;
       var transition = $$$1(this._element).hasClass(ClassName.FADE);
</PRE><PRE>       if (transition) {
         this._isTransitioning = true;
       }
</PRE><PRE>       this._setEscapeEvent();
</PRE><PRE>       this._setResizeEvent();
</PRE><PRE>       $$$1(document).off(Event.FOCUSIN);
       $$$1(this._element).removeClass(ClassName.SHOW);
       $$$1(this._element).off(Event.CLICK_DISMISS);
       $$$1(this._dialog).off(Event.MOUSEDOWN_DISMISS);
</PRE><PRE>       if (transition) {
         var transitionDuration = Util.getTransitionDurationFromElement(this._element);
         $$$1(this._element).one(Util.TRANSITION_END, function (event) {
           return _this2._hideModal(event);
         }).emulateTransitionEnd(transitionDuration);
       } else {
         this._hideModal();
       }
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       $$$1(window, document, this._element, this._backdrop).off(EVENT_KEY);
       this._config = null;
       this._element = null;
       this._dialog = null;
       this._backdrop = null;
       this._isShown = null;
       this._isBodyOverflowing = null;
       this._ignoreBackdropClick = null;
       this._scrollbarWidth = null;
     };
</PRE><PRE>     _proto.handleUpdate = function handleUpdate() {
       this._adjustDialog();
     }; // Private
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, Default, config);
       Util.typeCheckConfig(NAME, config, DefaultType);
       return config;
     };
</PRE><PRE>     _proto._showElement = function _showElement(relatedTarget) {
       var _this3 = this;
</PRE><PRE>       var transition = $$$1(this._element).hasClass(ClassName.FADE);
</PRE><PRE>       if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
         // Don't move modal's DOM position
         document.body.appendChild(this._element);
       }
</PRE><PRE>       this._element.style.display = 'block';
</PRE><PRE>       this._element.removeAttribute('aria-hidden');
</PRE><PRE>       this._element.scrollTop = 0;
</PRE><PRE>       if (transition) {
         Util.reflow(this._element);
       }
</PRE><PRE>       $$$1(this._element).addClass(ClassName.SHOW);
</PRE><PRE>       if (this._config.focus) {
         this._enforceFocus();
       }
</PRE><PRE>       var shownEvent = $$$1.Event(Event.SHOWN, {
         relatedTarget: relatedTarget
       });
</PRE><PRE>       var transitionComplete = function transitionComplete() {
         if (_this3._config.focus) {
           _this3._element.focus();
         }
</PRE><PRE>         _this3._isTransitioning = false;
         $$$1(_this3._element).trigger(shownEvent);
       };
</PRE><PRE>       if (transition) {
         var transitionDuration = Util.getTransitionDurationFromElement(this._element);
         $$$1(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
       } else {
         transitionComplete();
       }
     };
</PRE><PRE>     _proto._enforceFocus = function _enforceFocus() {
       var _this4 = this;
</PRE><PRE>       $$$1(document).off(Event.FOCUSIN) // Guard against infinite focus loop
       .on(Event.FOCUSIN, function (event) {
         if (document !== event.target &amp;&amp; _this4._element !== event.target &amp;&amp; $$$1(_this4._element).has(event.target).length === 0) {
           _this4._element.focus();
         }
       });
     };
</PRE><PRE>     _proto._setEscapeEvent = function _setEscapeEvent() {
       var _this5 = this;
</PRE><PRE>       if (this._isShown &amp;&amp; this._config.keyboard) {
         $$$1(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
           if (event.which === ESCAPE_KEYCODE) {
             event.preventDefault();
</PRE><PRE>             _this5.hide();
           }
         });
       } else if (!this._isShown) {
         $$$1(this._element).off(Event.KEYDOWN_DISMISS);
       }
     };
</PRE><PRE>     _proto._setResizeEvent = function _setResizeEvent() {
       var _this6 = this;
</PRE><PRE>       if (this._isShown) {
         $$$1(window).on(Event.RESIZE, function (event) {
           return _this6.handleUpdate(event);
         });
       } else {
         $$$1(window).off(Event.RESIZE);
       }
     };
</PRE><PRE>     _proto._hideModal = function _hideModal() {
       var _this7 = this;
</PRE><PRE>       this._element.style.display = 'none';
</PRE><PRE>       this._element.setAttribute('aria-hidden', true);
</PRE><PRE>       this._isTransitioning = false;
</PRE><PRE>       this._showBackdrop(function () {
         $$$1(document.body).removeClass(ClassName.OPEN);
</PRE><PRE>         _this7._resetAdjustments();
</PRE><PRE>         _this7._resetScrollbar();
</PRE><PRE>         $$$1(_this7._element).trigger(Event.HIDDEN);
       });
     };
</PRE><PRE>     _proto._removeBackdrop = function _removeBackdrop() {
       if (this._backdrop) {
         $$$1(this._backdrop).remove();
         this._backdrop = null;
       }
     };
</PRE><PRE>     _proto._showBackdrop = function _showBackdrop(callback) {
       var _this8 = this;
</PRE><PRE>       var animate = $$$1(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : <I>;</I></PRE><PRE>       if (this._isShown &amp;&amp; this._config.backdrop) {
         this._backdrop = document.createElement('div');
         this._backdrop.className = ClassName.BACKDROP;
</PRE><PRE>         if (animate) {
           this._backdrop.classList.add(animate);
         }
</PRE><PRE>         $$$1(this._backdrop).appendTo(document.body);
         $$$1(this._element).on(Event.CLICK_DISMISS, function (event) {
           if (_this8._ignoreBackdropClick) {
             _this8._ignoreBackdropClick = false;
             return;
           }
</PRE><PRE>           if (event.target !== event.currentTarget) {
             return;
           }
</PRE><PRE>           if (_this8._config.backdrop === 'static') {
             _this8._element.focus();
           } else {
             _this8.hide();
           }
         });
</PRE><PRE>         if (animate) {
           Util.reflow(this._backdrop);
         }
</PRE><PRE>         $$$1(this._backdrop).addClass(ClassName.SHOW);
</PRE><PRE>         if (!callback) {
           return;
         }
</PRE><PRE>         if (!animate) {
           callback();
           return;
         }
</PRE><PRE>         var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
         $$$1(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
       } else if (!this._isShown &amp;&amp; this._backdrop) {
         $$$1(this._backdrop).removeClass(ClassName.SHOW);
</PRE><PRE>         var callbackRemove = function callbackRemove() {
           _this8._removeBackdrop();
</PRE><PRE>           if (callback) {
             callback();
           }
         };
</PRE><PRE>         if ($$$1(this._element).hasClass(ClassName.FADE)) {
           var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
</PRE><PRE>           $$$1(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
         } else {
           callbackRemove();
         }
       } else if (callback) {
         callback();
       }
     }; // ----------------------------------------------------------------------
     // the following methods are used to handle overflowing modals
     // todo (fat): these should probably be refactored out of modal.js
     // ----------------------------------------------------------------------
</PRE><PRE>     _proto._adjustDialog = function _adjustDialog() {
       var isModalOverflowing = this._element.scrollHeight &gt; document.documentElement.clientHeight;
</PRE><PRE>       if (!this._isBodyOverflowing &amp;&amp; isModalOverflowing) {
         this._element.style.paddingLeft = this._scrollbarWidth + &quot;px&quot;;
       }
</PRE><PRE>       if (this._isBodyOverflowing &amp;&amp; !isModalOverflowing) {
         this._element.style.paddingRight = this._scrollbarWidth + &quot;px&quot;;
       }
     };
</PRE><PRE>     _proto._resetAdjustments = function _resetAdjustments() {
       this._element.style.paddingLeft = <I>;</I>
       this._element.style.paddingRight = <I>;</I>
     };
</PRE><PRE>     _proto._checkScrollbar = function _checkScrollbar() {
       var rect = document.body.getBoundingClientRect();
       this._isBodyOverflowing = rect.left + rect.right &lt; window.innerWidth;
       this._scrollbarWidth = this._getScrollbarWidth();
     };
</PRE><PRE>     _proto._setScrollbar = function _setScrollbar() {
       var _this9 = this;
</PRE><PRE>       if (this._isBodyOverflowing) {
         // Note: DOMNode.style.paddingRight returns the actual value or <I> if not set</I>
         //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
         var fixedContent = [].slice.call(document.querySelectorAll(Selector.FIXED_CONTENT));
         var stickyContent = [].slice.call(document.querySelectorAll(Selector.STICKY_CONTENT)); // Adjust fixed content padding
</PRE><PRE>         $$$1(fixedContent).each(function (index, element) {
           var actualPadding = element.style.paddingRight;
           var calculatedPadding = $$$1(element).css('padding-right');
           $$$1(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + &quot;px&quot;);
         }); // Adjust sticky content margin
</PRE><PRE>         $$$1(stickyContent).each(function (index, element) {
           var actualMargin = element.style.marginRight;
           var calculatedMargin = $$$1(element).css('margin-right');
           $$$1(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + &quot;px&quot;);
         }); // Adjust body padding
</PRE><PRE>         var actualPadding = document.body.style.paddingRight;
         var calculatedPadding = $$$1(document.body).css('padding-right');
         $$$1(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + &quot;px&quot;);
       }
     };
</PRE><PRE>     _proto._resetScrollbar = function _resetScrollbar() {
       // Restore fixed content padding
       var fixedContent = [].slice.call(document.querySelectorAll(Selector.FIXED_CONTENT));
       $$$1(fixedContent).each(function (index, element) {
         var padding = $$$1(element).data('padding-right');
         $$$1(element).removeData('padding-right');
         element.style.paddingRight = padding ? padding : <I>;</I>
       }); // Restore sticky content
</PRE><PRE>       var elements = [].slice.call(document.querySelectorAll(&quot;&quot; + Selector.STICKY_CONTENT));
       $$$1(elements).each(function (index, element) {
         var margin = $$$1(element).data('margin-right');
</PRE><PRE>         if (typeof margin !== 'undefined') {
           $$$1(element).css('margin-right', margin).removeData('margin-right');
         }
       }); // Restore body padding
</PRE><PRE>       var padding = $$$1(document.body).data('padding-right');
       $$$1(document.body).removeData('padding-right');
       document.body.style.paddingRight = padding ? padding : <I>;</I>
     };
</PRE><PRE>     _proto._getScrollbarWidth = function _getScrollbarWidth() {
       // thx d.walsh
       var scrollDiv = document.createElement('div');
       scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
       document.body.appendChild(scrollDiv);
       var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
       document.body.removeChild(scrollDiv);
       return scrollbarWidth;
     }; // Static
</PRE><PRE>     Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = _objectSpread({}, Default, $$$1(this).data(), typeof config === 'object' &amp;&amp; config ? config : {});
</PRE><PRE>         if (!data) {
           data = new Modal(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config](relatedTarget);
         } else if (_config.show) {
           data.show(relatedTarget);
         }
       });
     };
</PRE><PRE>     _createClass(Modal, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }]);
</PRE><PRE>     return Modal;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
     var _this10 = this;
</PRE><PRE>     var target;
     var selector = Util.getSelectorFromElement(this);
</PRE><PRE>     if (selector) {
       target = document.querySelector(selector);
     }
</PRE><PRE>     var config = $$$1(target).data(DATA_KEY) ? 'toggle' : _objectSpread({}, $$$1(target).data(), $$$1(this).data());
</PRE><PRE>     if (this.tagName === 'A' || this.tagName === 'AREA') {
       event.preventDefault();
     }
</PRE><PRE>     var $target = $$$1(target).one(Event.SHOW, function (showEvent) {
       if (showEvent.isDefaultPrevented()) {
         // Only register focus restorer if modal will actually get shown
         return;
       }
</PRE><PRE>       $target.one(Event.HIDDEN, function () {
         if ($$$1(_this10).is(':visible')) {
           _this10.focus();
         }
       });
     });
</PRE><PRE>     Modal._jQueryInterface.call($$$1(target), config, this);
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Modal._jQueryInterface;
   $$$1.fn[NAME].Constructor = Modal;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Modal._jQueryInterface;
   };
</PRE><PRE>   return Modal;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): tooltip.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Tooltip = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'tooltip';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.tooltip';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var CLASS_PREFIX = 'bs-tooltip';
   var BSCLS_PREFIX_REGEX = new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, 'g');
   var DefaultType = {
     animation: 'boolean',
     template: 'string',
     title: '(string|element|function)',
     trigger: 'string',
     delay: '(number|object)',
     html: 'boolean',
     selector: '(string|boolean)',
     placement: '(string|function)',
     offset: '(number|string)',
     container: '(string|element|boolean)',
     fallbackPlacement: '(string|array)',
     boundary: '(string|element)'
   };
   var AttachmentMap = {
     AUTO: 'auto',
     TOP: 'top',
     RIGHT: 'right',
     BOTTOM: 'bottom',
     LEFT: 'left'
   };
   var Default = {
     animation: true,
</PRE>
      template: '<DIV class="tooltip">' + '' + '</DIV>',
<PRE>     trigger: 'hover focus',
     title: <I>,</I>
     delay: 0,
     html: false,
     selector: false,
     placement: 'top',
     offset: 0,
     container: false,
     fallbackPlacement: 'flip',
     boundary: 'scrollParent'
   };
   var HoverState = {
     SHOW: 'show',
     OUT: 'out'
   };
   var Event = {
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     INSERTED: &quot;inserted&quot; + EVENT_KEY,
     CLICK: &quot;click&quot; + EVENT_KEY,
     FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
     FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
     MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
     MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
   };
   var ClassName = {
     FADE: 'fade',
     SHOW: 'show'
   };
   var Selector = {
     TOOLTIP: '.tooltip',
     TOOLTIP_INNER: '.tooltip-inner',
     ARROW: '.arrow'
   };
   var Trigger = {
     HOVER: 'hover',
     FOCUS: 'focus',
     CLICK: 'click',
     MANUAL: 'manual'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Tooltip =
   /*#__PURE__*/
   function () {
     function Tooltip(element, config) {
       /**
        * Check for Popper dependency
        * Popper - <A rel="nofollow" class="external free" href="https://popper.js.org">https://popper.js.org</A>
        */
       if (typeof Popper === 'undefined') {
         throw new TypeError('Bootstrap tooltips require Popper.js (<A rel="nofollow" class="external free" href="https://popper.js.org)'">https://popper.js.org)'</A>);
       } // private
</PRE><PRE>       this._isEnabled = true;
       this._timeout = 0;
       this._hoverState = <I>;</I>
       this._activeTrigger = {};
       this._popper = null; // Protected
</PRE><PRE>       this.element = element;
       this.config = this._getConfig(config);
       this.tip = null;
</PRE><PRE>       this._setListeners();
     } // Getters
</PRE><PRE>     var _proto = Tooltip.prototype;
</PRE><PRE>     // Public
     _proto.enable = function enable() {
       this._isEnabled = true;
     };
</PRE><PRE>     _proto.disable = function disable() {
       this._isEnabled = false;
     };
</PRE><PRE>     _proto.toggleEnabled = function toggleEnabled() {
       this._isEnabled = !this._isEnabled;
     };
</PRE><PRE>     _proto.toggle = function toggle(event) {
       if (!this._isEnabled) {
         return;
       }
</PRE><PRE>       if (event) {
         var dataKey = this.constructor.DATA_KEY;
         var context = $$$1(event.currentTarget).data(dataKey);
</PRE><PRE>         if (!context) {
           context = new this.constructor(event.currentTarget, this._getDelegateConfig());
           $$$1(event.currentTarget).data(dataKey, context);
         }
</PRE><PRE>         context._activeTrigger.click = !context._activeTrigger.click;
</PRE><PRE>         if (context._isWithActiveTrigger()) {
           context._enter(null, context);
         } else {
           context._leave(null, context);
         }
       } else {
         if ($$$1(this.getTipElement()).hasClass(ClassName.SHOW)) {
           this._leave(null, this);
</PRE><PRE>           return;
         }
</PRE><PRE>         this._enter(null, this);
       }
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       clearTimeout(this._timeout);
       $$$1.removeData(this.element, this.constructor.DATA_KEY);
       $$$1(this.element).off(this.constructor.EVENT_KEY);
       $$$1(this.element).closest('.modal').off('hide.bs.modal');
</PRE><PRE>       if (this.tip) {
         $$$1(this.tip).remove();
       }
</PRE><PRE>       this._isEnabled = null;
       this._timeout = null;
       this._hoverState = null;
       this._activeTrigger = null;
</PRE><PRE>       if (this._popper !== null) {
         this._popper.destroy();
       }
</PRE><PRE>       this._popper = null;
       this.element = null;
       this.config = null;
       this.tip = null;
     };
</PRE><PRE>     _proto.show = function show() {
       var _this = this;
</PRE><PRE>       if ($$$1(this.element).css('display') === 'none') {
         throw new Error('Please use show on visible elements');
       }
</PRE><PRE>       var showEvent = $$$1.Event(this.constructor.Event.SHOW);
</PRE><PRE>       if (this.isWithContent() &amp;&amp; this._isEnabled) {
         $$$1(this.element).trigger(showEvent);
         var isInTheDom = $$$1.contains(this.element.ownerDocument.documentElement, this.element);
</PRE><PRE>         if (showEvent.isDefaultPrevented() || !isInTheDom) {
           return;
         }
</PRE><PRE>         var tip = this.getTipElement();
         var tipId = Util.getUID(this.constructor.NAME);
         tip.setAttribute('id', tipId);
         this.element.setAttribute('aria-describedby', tipId);
         this.setContent();
</PRE><PRE>         if (this.config.animation) {
           $$$1(tip).addClass(ClassName.FADE);
         }
</PRE><PRE>         var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;
</PRE><PRE>         var attachment = this._getAttachment(placement);
</PRE><PRE>         this.addAttachmentClass(attachment);
         var container = this.config.container === false ? document.body : $$$1(document).find(this.config.container);
         $$$1(tip).data(this.constructor.DATA_KEY, this);
</PRE><PRE>         if (!$$$1.contains(this.element.ownerDocument.documentElement, this.tip)) {
           $$$1(tip).appendTo(container);
         }
</PRE><PRE>         $$$1(this.element).trigger(this.constructor.Event.INSERTED);
         this._popper = new Popper(this.element, tip, {
           placement: attachment,
           modifiers: {
             offset: {
               offset: this.config.offset
             },
             flip: {
               behavior: this.config.fallbackPlacement
             },
             arrow: {
               element: Selector.ARROW
             },
             preventOverflow: {
               boundariesElement: this.config.boundary
             }
           },
           onCreate: function onCreate(data) {
             if (data.originalPlacement !== data.placement) {
               _this._handlePopperPlacementChange(data);
             }
           },
           onUpdate: function onUpdate(data) {
             _this._handlePopperPlacementChange(data);
           }
         });
         $$$1(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra
         // empty mouseover listeners to the body's immediate children;
         // only needed because of broken event delegation on iOS
         // <A rel="nofollow" class="external free" href="https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html">https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html</A></PRE><PRE>         if ('ontouchstart' in document.documentElement) {
           $$$1(document.body).children().on('mouseover', null, $$$1.noop);
         }
</PRE><PRE>         var complete = function complete() {
           if (_this.config.animation) {
             _this._fixTransition();
           }
</PRE><PRE>           var prevHoverState = _this._hoverState;
           _this._hoverState = null;
           $$$1(_this.element).trigger(_this.constructor.Event.SHOWN);
</PRE><PRE>           if (prevHoverState === HoverState.OUT) {
             _this._leave(null, _this);
           }
         };
</PRE><PRE>         if ($$$1(this.tip).hasClass(ClassName.FADE)) {
           var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
           $$$1(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
         } else {
           complete();
         }
       }
     };
</PRE><PRE>     _proto.hide = function hide(callback) {
       var _this2 = this;
</PRE><PRE>       var tip = this.getTipElement();
       var hideEvent = $$$1.Event(this.constructor.Event.HIDE);
</PRE><PRE>       var complete = function complete() {
         if (_this2._hoverState !== HoverState.SHOW &amp;&amp; tip.parentNode) {
           tip.parentNode.removeChild(tip);
         }
</PRE><PRE>         _this2._cleanTipClass();
</PRE><PRE>         _this2.element.removeAttribute('aria-describedby');
</PRE><PRE>         $$$1(_this2.element).trigger(_this2.constructor.Event.HIDDEN);
</PRE><PRE>         if (_this2._popper !== null) {
           _this2._popper.destroy();
         }
</PRE><PRE>         if (callback) {
           callback();
         }
       };
</PRE><PRE>       $$$1(this.element).trigger(hideEvent);
</PRE><PRE>       if (hideEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       $$$1(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra
       // empty mouseover listeners we added for iOS support
</PRE><PRE>       if ('ontouchstart' in document.documentElement) {
         $$$1(document.body).children().off('mouseover', null, $$$1.noop);
       }
</PRE><PRE>       this._activeTrigger[Trigger.CLICK] = false;
       this._activeTrigger[Trigger.FOCUS] = false;
       this._activeTrigger[Trigger.HOVER] = false;
</PRE><PRE>       if ($$$1(this.tip).hasClass(ClassName.FADE)) {
         var transitionDuration = Util.getTransitionDurationFromElement(tip);
         $$$1(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
       } else {
         complete();
       }
</PRE><PRE>       this._hoverState = <I>;</I>
     };
</PRE><PRE>     _proto.update = function update() {
       if (this._popper !== null) {
         this._popper.scheduleUpdate();
       }
     }; // Protected
</PRE><PRE>     _proto.isWithContent = function isWithContent() {
       return Boolean(this.getTitle());
     };
</PRE><PRE>     _proto.addAttachmentClass = function addAttachmentClass(attachment) {
       $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
     };
</PRE><PRE>     _proto.getTipElement = function getTipElement() {
       this.tip = this.tip || $$$1(this.config.template)[0];
       return this.tip;
     };
</PRE><PRE>     _proto.setContent = function setContent() {
       var tip = this.getTipElement();
       this.setElementContent($$$1(tip.querySelectorAll(Selector.TOOLTIP_INNER)), this.getTitle());
       $$$1(tip).removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
     };
</PRE><PRE>     _proto.setElementContent = function setElementContent($element, content) {
       var html = this.config.html;
</PRE><PRE>       if (typeof content === 'object' &amp;&amp; (content.nodeType || content.jquery)) {
         // Content is a DOM node or a jQuery
         if (html) {
           if (!$$$1(content).parent().is($element)) {
             $element.empty().append(content);
           }
         } else {
           $element.text($$$1(content).text());
         }
       } else {
         $element[html ? 'html' : 'text'](content);
       }
     };
</PRE><PRE>     _proto.getTitle = function getTitle() {
       var title = this.element.getAttribute('data-original-title');
</PRE><PRE>       if (!title) {
         title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
       }
</PRE><PRE>       return title;
     }; // Private
</PRE><PRE>     _proto._getAttachment = function _getAttachment(placement) {
       return AttachmentMap[placement.toUpperCase()];
     };
</PRE><PRE>     _proto._setListeners = function _setListeners() {
       var _this3 = this;
</PRE><PRE>       var triggers = this.config.trigger.split(' ');
       triggers.forEach(function (trigger) {
         if (trigger === 'click') {
           $$$1(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
             return _this3.toggle(event);
           });
         } else if (trigger !== Trigger.MANUAL) {
           var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
           var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
           $$$1(_this3.element).on(eventIn, _this3.config.selector, function (event) {
             return _this3._enter(event);
           }).on(eventOut, _this3.config.selector, function (event) {
             return _this3._leave(event);
           });
         }
</PRE><PRE>         $$$1(_this3.element).closest('.modal').on('hide.bs.modal', function () {
           return _this3.hide();
         });
       });
</PRE><PRE>       if (this.config.selector) {
         this.config = _objectSpread({}, this.config, {
           trigger: 'manual',
           selector: 
         });
       } else {
         this._fixTitle();
       }
     };
</PRE><PRE>     _proto._fixTitle = function _fixTitle() {
       var titleType = typeof this.element.getAttribute('data-original-title');
</PRE><PRE>       if (this.element.getAttribute('title') || titleType !== 'string') {
         this.element.setAttribute('data-original-title', this.element.getAttribute('title') || <I>);</I>
         this.element.setAttribute('title', <I>);</I>
       }
     };
</PRE><PRE>     _proto._enter = function _enter(event, context) {
       var dataKey = this.constructor.DATA_KEY;
       context = context || $$$1(event.currentTarget).data(dataKey);
</PRE><PRE>       if (!context) {
         context = new this.constructor(event.currentTarget, this._getDelegateConfig());
         $$$1(event.currentTarget).data(dataKey, context);
       }
</PRE><PRE>       if (event) {
         context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
       }
</PRE><PRE>       if ($$$1(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
         context._hoverState = HoverState.SHOW;
         return;
       }
</PRE><PRE>       clearTimeout(context._timeout);
       context._hoverState = HoverState.SHOW;
</PRE><PRE>       if (!context.config.delay || !context.config.delay.show) {
         context.show();
         return;
       }
</PRE><PRE>       context._timeout = setTimeout(function () {
         if (context._hoverState === HoverState.SHOW) {
           context.show();
         }
       }, context.config.delay.show);
     };
</PRE><PRE>     _proto._leave = function _leave(event, context) {
       var dataKey = this.constructor.DATA_KEY;
       context = context || $$$1(event.currentTarget).data(dataKey);
</PRE><PRE>       if (!context) {
         context = new this.constructor(event.currentTarget, this._getDelegateConfig());
         $$$1(event.currentTarget).data(dataKey, context);
       }
</PRE><PRE>       if (event) {
         context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
       }
</PRE><PRE>       if (context._isWithActiveTrigger()) {
         return;
       }
</PRE><PRE>       clearTimeout(context._timeout);
       context._hoverState = HoverState.OUT;
</PRE><PRE>       if (!context.config.delay || !context.config.delay.hide) {
         context.hide();
         return;
       }
</PRE><PRE>       context._timeout = setTimeout(function () {
         if (context._hoverState === HoverState.OUT) {
           context.hide();
         }
       }, context.config.delay.hide);
     };
</PRE><PRE>     _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
       for (var trigger in this._activeTrigger) {
         if (this._activeTrigger[trigger]) {
           return true;
         }
       }
</PRE><PRE>       return false;
     };
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, this.constructor.Default, $$$1(this.element).data(), typeof config === 'object' &amp;&amp; config ? config : {});
</PRE><PRE>       if (typeof config.delay === 'number') {
         config.delay = {
           show: config.delay,
           hide: config.delay
         };
       }
</PRE><PRE>       if (typeof config.title === 'number') {
         config.title = config.title.toString();
       }
</PRE><PRE>       if (typeof config.content === 'number') {
         config.content = config.content.toString();
       }
</PRE><PRE>       Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
       return config;
     };
</PRE><PRE>     _proto._getDelegateConfig = function _getDelegateConfig() {
       var config = {};
</PRE><PRE>       if (this.config) {
         for (var key in this.config) {
           if (this.constructor.Default[key] !== this.config[key]) {
             config[key] = this.config[key];
           }
         }
       }
</PRE><PRE>       return config;
     };
</PRE><PRE>     _proto._cleanTipClass = function _cleanTipClass() {
       var $tip = $$$1(this.getTipElement());
       var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
</PRE><PRE>       if (tabClass !== null &amp;&amp; tabClass.length) {
         $tip.removeClass(tabClass.join(<I>));</I>
       }
     };
</PRE><PRE>     _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
       var popperInstance = popperData.instance;
       this.tip = popperInstance.popper;
</PRE><PRE>       this._cleanTipClass();
</PRE><PRE>       this.addAttachmentClass(this._getAttachment(popperData.placement));
     };
</PRE><PRE>     _proto._fixTransition = function _fixTransition() {
       var tip = this.getTipElement();
       var initConfigAnimation = this.config.animation;
</PRE><PRE>       if (tip.getAttribute('x-placement') !== null) {
         return;
       }
</PRE><PRE>       $$$1(tip).removeClass(ClassName.FADE);
       this.config.animation = false;
       this.hide();
       this.show();
       this.config.animation = initConfigAnimation;
     }; // Static
</PRE><PRE>     Tooltip._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = typeof config === 'object' &amp;&amp; config;
</PRE><PRE>         if (!data &amp;&amp; /dispose|hide/.test(config)) {
           return;
         }
</PRE><PRE>         if (!data) {
           data = new Tooltip(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config]();
         }
       });
     };
</PRE><PRE>     _createClass(Tooltip, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }, {
       key: &quot;NAME&quot;,
       get: function get() {
         return NAME;
       }
     }, {
       key: &quot;DATA_KEY&quot;,
       get: function get() {
         return DATA_KEY;
       }
     }, {
       key: &quot;Event&quot;,
       get: function get() {
         return Event;
       }
     }, {
       key: &quot;EVENT_KEY&quot;,
       get: function get() {
         return EVENT_KEY;
       }
     }, {
       key: &quot;DefaultType&quot;,
       get: function get() {
         return DefaultType;
       }
     }]);
</PRE><PRE>     return Tooltip;
   }();
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Tooltip._jQueryInterface;
   $$$1.fn[NAME].Constructor = Tooltip;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Tooltip._jQueryInterface;
   };
</PRE><PRE>   return Tooltip;
 }($, Popper);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): popover.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Popover = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'popover';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.popover';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var CLASS_PREFIX = 'bs-popover';
   var BSCLS_PREFIX_REGEX = new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, 'g');
</PRE><PRE>   var Default = _objectSpread({}, Tooltip.Default, {
     placement: 'right',
     trigger: 'click',
     content: <I>,</I></PRE>
      template: '<DIV class="popover">' + '' + '' + '</DIV>'
<PRE>   });
</PRE><PRE>   var DefaultType = _objectSpread({}, Tooltip.DefaultType, {
     content: '(string|element|function)'
   });
</PRE><PRE>   var ClassName = {
     FADE: 'fade',
     SHOW: 'show'
   };
   var Selector = {
     TITLE: '.popover-header',
     CONTENT: '.popover-body'
   };
   var Event = {
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     INSERTED: &quot;inserted&quot; + EVENT_KEY,
     CLICK: &quot;click&quot; + EVENT_KEY,
     FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
     FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
     MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
     MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Popover =
   /*#__PURE__*/
   function (_Tooltip) {
     _inheritsLoose(Popover, _Tooltip);
</PRE><PRE>     function Popover() {
       return _Tooltip.apply(this, arguments) || this;
     }
</PRE><PRE>     var _proto = Popover.prototype;
</PRE><PRE>     // Overrides
     _proto.isWithContent = function isWithContent() {
       return this.getTitle() || this._getContent();
     };
</PRE><PRE>     _proto.addAttachmentClass = function addAttachmentClass(attachment) {
       $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
     };
</PRE><PRE>     _proto.getTipElement = function getTipElement() {
       this.tip = this.tip || $$$1(this.config.template)[0];
       return this.tip;
     };
</PRE><PRE>     _proto.setContent = function setContent() {
       var $tip = $$$1(this.getTipElement()); // We use append for html objects to maintain js events
</PRE><PRE>       this.setElementContent($tip.find(Selector.TITLE), this.getTitle());
</PRE><PRE>       var content = this._getContent();
</PRE><PRE>       if (typeof content === 'function') {
         content = content.call(this.element);
       }
</PRE><PRE>       this.setElementContent($tip.find(Selector.CONTENT), content);
       $tip.removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
     }; // Private
</PRE><PRE>     _proto._getContent = function _getContent() {
       return this.element.getAttribute('data-content') || this.config.content;
     };
</PRE><PRE>     _proto._cleanTipClass = function _cleanTipClass() {
       var $tip = $$$1(this.getTipElement());
       var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
</PRE><PRE>       if (tabClass !== null &amp;&amp; tabClass.length &gt; 0) {
         $tip.removeClass(tabClass.join(<I>));</I>
       }
     }; // Static
</PRE><PRE>     Popover._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = typeof config === 'object' ? config : null;
</PRE><PRE>         if (!data &amp;&amp; /destroy|hide/.test(config)) {
           return;
         }
</PRE><PRE>         if (!data) {
           data = new Popover(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config]();
         }
       });
     };
</PRE><PRE>     _createClass(Popover, null, [{
       key: &quot;VERSION&quot;,
       // Getters
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }, {
       key: &quot;NAME&quot;,
       get: function get() {
         return NAME;
       }
     }, {
       key: &quot;DATA_KEY&quot;,
       get: function get() {
         return DATA_KEY;
       }
     }, {
       key: &quot;Event&quot;,
       get: function get() {
         return Event;
       }
     }, {
       key: &quot;EVENT_KEY&quot;,
       get: function get() {
         return EVENT_KEY;
       }
     }, {
       key: &quot;DefaultType&quot;,
       get: function get() {
         return DefaultType;
       }
     }]);
</PRE><PRE>     return Popover;
   }(Tooltip);
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Popover._jQueryInterface;
   $$$1.fn[NAME].Constructor = Popover;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Popover._jQueryInterface;
   };
</PRE><PRE>   return Popover;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): scrollspy.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var ScrollSpy = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'scrollspy';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.scrollspy';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var Default = {
     offset: 10,
     method: 'auto',
     target: 
   };
   var DefaultType = {
     offset: 'number',
     method: 'string',
     target: '(string|element)'
   };
   var Event = {
     ACTIVATE: &quot;activate&quot; + EVENT_KEY,
     SCROLL: &quot;scroll&quot; + EVENT_KEY,
     LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     DROPDOWN_ITEM: 'dropdown-item',
     DROPDOWN_MENU: 'dropdown-menu',
     ACTIVE: 'active'
   };
   var Selector = {
     DATA_SPY: '[data-spy=&quot;scroll&quot;]',
     ACTIVE: '.active',
     NAV_LIST_GROUP: '.nav, .list-group',
     NAV_LINKS: '.nav-link',
     NAV_ITEMS: '.nav-item',
     LIST_ITEMS: '.list-group-item',
     DROPDOWN: '.dropdown',
     DROPDOWN_ITEMS: '.dropdown-item',
     DROPDOWN_TOGGLE: '.dropdown-toggle'
   };
   var OffsetMethod = {
     OFFSET: 'offset',
     POSITION: 'position'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var ScrollSpy =
   /*#__PURE__*/
   function () {
     function ScrollSpy(element, config) {
       var _this = this;
</PRE><PRE>       this._element = element;
       this._scrollElement = element.tagName === 'BODY' ? window : element;
       this._config = this._getConfig(config);
       this._selector = this._config.target + &quot; &quot; + Selector.NAV_LINKS + &quot;,&quot; + (this._config.target + &quot; &quot; + Selector.LIST_ITEMS + &quot;,&quot;) + (this._config.target + &quot; &quot; + Selector.DROPDOWN_ITEMS);
       this._offsets = [];
       this._targets = [];
       this._activeTarget = null;
       this._scrollHeight = 0;
       $$$1(this._scrollElement).on(Event.SCROLL, function (event) {
         return _this._process(event);
       });
       this.refresh();
</PRE><PRE>       this._process();
     } // Getters
</PRE><PRE>     var _proto = ScrollSpy.prototype;
</PRE><PRE>     // Public
     _proto.refresh = function refresh() {
       var _this2 = this;
</PRE><PRE>       var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
       var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
       var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
       this._offsets = [];
       this._targets = [];
       this._scrollHeight = this._getScrollHeight();
       var targets = [].slice.call(document.querySelectorAll(this._selector));
       targets.map(function (element) {
         var target;
         var targetSelector = Util.getSelectorFromElement(element);
</PRE><PRE>         if (targetSelector) {
           target = document.querySelector(targetSelector);
         }
</PRE><PRE>         if (target) {
           var targetBCR = target.getBoundingClientRect();
</PRE><PRE>           if (targetBCR.width || targetBCR.height) {
             // TODO (fat): remove sketch reliance on jQuery position/offset
             return [$$$1(target)[offsetMethod]().top + offsetBase, targetSelector];
           }
         }
</PRE><PRE>         return null;
       }).filter(function (item) {
         return item;
       }).sort(function (a, b) {
         return a[0] - b[0];
       }).forEach(function (item) {
         _this2._offsets.push(item[0]);
</PRE><PRE>         _this2._targets.push(item[1]);
       });
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       $$$1(this._scrollElement).off(EVENT_KEY);
       this._element = null;
       this._scrollElement = null;
       this._config = null;
       this._selector = null;
       this._offsets = null;
       this._targets = null;
       this._activeTarget = null;
       this._scrollHeight = null;
     }; // Private
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, Default, typeof config === 'object' &amp;&amp; config ? config : {});
</PRE><PRE>       if (typeof config.target !== 'string') {
         var id = $$$1(config.target).attr('id');
</PRE><PRE>         if (!id) {
           id = Util.getUID(NAME);
           $$$1(config.target).attr('id', id);
         }
</PRE><PRE>         config.target = &quot;#&quot; + id;
       }
</PRE><PRE>       Util.typeCheckConfig(NAME, config, DefaultType);
       return config;
     };
</PRE><PRE>     _proto._getScrollTop = function _getScrollTop() {
       return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
     };
</PRE><PRE>     _proto._getScrollHeight = function _getScrollHeight() {
       return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
     };
</PRE><PRE>     _proto._getOffsetHeight = function _getOffsetHeight() {
       return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
     };
</PRE><PRE>     _proto._process = function _process() {
       var scrollTop = this._getScrollTop() + this._config.offset;
</PRE><PRE>       var scrollHeight = this._getScrollHeight();
</PRE><PRE>       var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
</PRE><PRE>       if (this._scrollHeight !== scrollHeight) {
         this.refresh();
       }
</PRE><PRE>       if (scrollTop &gt;= maxScroll) {
         var target = this._targets[this._targets.length - 1];
</PRE><PRE>         if (this._activeTarget !== target) {
           this._activate(target);
         }
</PRE><PRE>         return;
       }
</PRE><PRE>       if (this._activeTarget &amp;&amp; scrollTop &lt; this._offsets[0] &amp;&amp; this._offsets[0] &gt; 0) {
         this._activeTarget = null;
</PRE><PRE>         this._clear();
</PRE><PRE>         return;
       }
</PRE><PRE>       var offsetLength = this._offsets.length;
</PRE><PRE>       for (var i = offsetLength; i--;) {
         var isActiveTarget = this._activeTarget !== this._targets[i] &amp;&amp; scrollTop &gt;= this._offsets[i] &amp;&amp; (typeof this._offsets[i + 1] === 'undefined' || scrollTop &lt; this._offsets[i + 1]);
</PRE><PRE>         if (isActiveTarget) {
           this._activate(this._targets[i]);
         }
       }
     };
</PRE><PRE>     _proto._activate = function _activate(target) {
       this._activeTarget = target;
</PRE><PRE>       this._clear();
</PRE><PRE>       var queries = this._selector.split(','); // eslint-disable-next-line arrow-body-style
</PRE><PRE>       queries = queries.map(function (selector) {
         return selector + &quot;[data-target=\&quot;&quot; + target + &quot;\&quot;],&quot; + (selector + &quot;[href=\&quot;&quot; + target + &quot;\&quot;]&quot;);
       });
       var $link = $$$1([].slice.call(document.querySelectorAll(queries.join(','))));
</PRE><PRE>       if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
         $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
         $link.addClass(ClassName.ACTIVE);
       } else {
         // Set triggered link as active
         $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active
</PRE>
          // With both <UL> and &lt;nav&gt; markup a parent is the previous sibling of any nav ancestor

          $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + &quot;, &quot; + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item

          $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
        }

        $$$1(this._scrollElement).trigger(Event.ACTIVATE, {
          relatedTarget: target
        });
      };

      _proto._clear = function _clear() {
        var nodes = [].slice.call(document.querySelectorAll(this._selector));
        $$$1(nodes).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
      }; // Static


      ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $$$1(this).data(DATA_KEY);

          var _config = typeof config === 'object' &amp;&amp; config;

          if (!data) {
            data = new ScrollSpy(this, _config);
            $$$1(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
            }

            data[config]();
          }
        });
      };

      _createClass(ScrollSpy, null, [{
        key: &quot;VERSION&quot;,
        get: function get() {
          return VERSION;
        }
      }, {
        key: &quot;Default&quot;,
        get: function get() {
          return Default;
        }
      }]);

      return ScrollSpy;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(window).on(Event.LOAD_DATA_API, function () {
      var scrollSpys = [].slice.call(document.querySelectorAll(Selector.DATA_SPY));
      var scrollSpysLength = scrollSpys.length;

      for (var i = scrollSpysLength; i--;) {
        var $spy = $$$1(scrollSpys[i]);

        ScrollSpy._jQueryInterface.call($spy, $spy.data());
      }
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = ScrollSpy._jQueryInterface;
    $$$1.fn[NAME].Constructor = ScrollSpy;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return ScrollSpy._jQueryInterface;
    };

    return ScrollSpy;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.3): tab.js
   * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
   * --------------------------------------------------------------------------
   */

  var Tab = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'tab';
    var VERSION = '4.1.3';
    var DATA_KEY = 'bs.tab';
    var EVENT_KEY = &quot;.&quot; + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var Event = {
      HIDE: &quot;hide&quot; + EVENT_KEY,
      HIDDEN: &quot;hidden&quot; + EVENT_KEY,
      SHOW: &quot;show&quot; + EVENT_KEY,
      SHOWN: &quot;shown&quot; + EVENT_KEY,
      CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active',
      DISABLED: 'disabled',
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector = {
      DROPDOWN: '.dropdown',
      NAV_LIST_GROUP: '.nav, .list-group',
      ACTIVE: '.active',
      ACTIVE_UL: '&gt; li &gt; .active',
      DATA_TOGGLE: '[data-toggle=&quot;tab&quot;], [data-toggle=&quot;pill&quot;], [data-toggle=&quot;list&quot;]',
      DROPDOWN_TOGGLE: '.dropdown-toggle',
      DROPDOWN_ACTIVE_CHILD: '&gt; .dropdown-menu .active'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Tab =
    /*#__PURE__*/
    function () {
      function Tab(element) {
        this._element = element;
      } // Getters


      var _proto = Tab.prototype;

      // Public
      _proto.show = function show() {
        var _this = this;

        if (this._element.parentNode &amp;&amp; this._element.parentNode.nodeType === Node.ELEMENT_NODE &amp;&amp; $$$1(this._element).hasClass(ClassName.ACTIVE) || $$$1(this._element).hasClass(ClassName.DISABLED)) {
          return;
        }

        var target;
        var previous;
        var listElement = $$$1(this._element).closest(Selector.NAV_LIST_GROUP)[0];
        var selector = Util.getSelectorFromElement(this._element);

        if (listElement) {
          var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;
          previous = $$$1.makeArray($$$1(listElement).find(itemSelector));
          previous = previous[previous.length - 1];
        }

        var hideEvent = $$$1.Event(Event.HIDE, {
          relatedTarget: this._element
        });
        var showEvent = $$$1.Event(Event.SHOW, {
          relatedTarget: previous
        });

        if (previous) {
          $$$1(previous).trigger(hideEvent);
        }

        $$$1(this._element).trigger(showEvent);

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
          return;
        }

        if (selector) {
          target = document.querySelector(selector);
        }

        this._activate(this._element, listElement);

        var complete = function complete() {
          var hiddenEvent = $$$1.Event(Event.HIDDEN, {
            relatedTarget: _this._element
          });
          var shownEvent = $$$1.Event(Event.SHOWN, {
            relatedTarget: previous
          });
          $$$1(previous).trigger(hiddenEvent);
          $$$1(_this._element).trigger(shownEvent);
        };

        if (target) {
          this._activate(target, target.parentNode, complete);
        } else {
          complete();
        }
      };

      _proto.dispose = function dispose() {
        $$$1.removeData(this._element, DATA_KEY);
        this._element = null;
      }; // Private


      _proto._activate = function _activate(element, container, callback) {
        var _this2 = this;

        var activeElements;

        if (container.nodeName === 'UL') {
          activeElements = $$$1(container).find(Selector.ACTIVE_UL);
        } else {
          activeElements = $$$1(container).children(Selector.ACTIVE);
        }

        var active = activeElements[0];
        var isTransitioning = callback &amp;&amp; active &amp;&amp; $$$1(active).hasClass(ClassName.FADE);

        var complete = function complete() {
          return _this2._transitionComplete(element, active, callback);
        };

        if (active &amp;&amp; isTransitioning) {
          var transitionDuration = Util.getTransitionDurationFromElement(active);
          $$$1(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      };

      _proto._transitionComplete = function _transitionComplete(element, active, callback) {
        if (active) {
          $$$1(active).removeClass(ClassName.SHOW + &quot; &quot; + ClassName.ACTIVE);
          var dropdownChild = $$$1(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

          if (dropdownChild) {
            $$$1(dropdownChild).removeClass(ClassName.ACTIVE);
          }

          if (active.getAttribute('role') === 'tab') {
            active.setAttribute('aria-selected', false);
          }
        }

        $$$1(element).addClass(ClassName.ACTIVE);

        if (element.getAttribute('role') === 'tab') {
          element.setAttribute('aria-selected', true);
        }

        Util.reflow(element);
        $$$1(element).addClass(ClassName.SHOW);

        if (element.parentNode &amp;&amp; $$$1(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
          var dropdownElement = $$$1(element).closest(Selector.DROPDOWN)[0];

          if (dropdownElement) {
            var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector.DROPDOWN_TOGGLE));
            $$$1(dropdownToggleList).addClass(ClassName.ACTIVE);
          }

          element.setAttribute('aria-expanded', true);
        }

        if (callback) {
          callback();
        }
      }; // Static


      Tab._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $$$1(this);
          var data = $this.data(DATA_KEY);

          if (!data) {
            data = new Tab(this);
            $this.data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
            }

            data[config]();
          }
        });
      };

      _createClass(Tab, null, [{
        key: &quot;VERSION&quot;,
        get: function get() {
          return VERSION;
        }
      }]);

      return Tab;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      event.preventDefault();

      Tab._jQueryInterface.call($$$1(this), 'show');
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = Tab._jQueryInterface;
    $$$1.fn[NAME].Constructor = Tab;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Tab._jQueryInterface;
    };

    return Tab;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.3): index.js
   * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
   * --------------------------------------------------------------------------
   */

  (function ($$$1) {
    if (typeof $$$1 === 'undefined') {
      throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
    }

    var version = $$$1.fn.jquery.split(' ')[0].split('.');
    var minMajor = 1;
    var ltMajor = 2;
    var minMinor = 9;
    var minPatch = 1;
    var maxMajor = 4;

    if (version[0] &lt; ltMajor &amp;&amp; version[1] &lt; minMinor || version[0] === minMajor &amp;&amp; version[1] === minMinor &amp;&amp; version[2] &lt; minPatch || version[0] &gt;= maxMajor) {
      throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
    }
  })($);

  exports.Util = Util;
  exports.Alert = Alert;
  exports.Button = Button;
  exports.Carousel = Carousel;
  exports.Collapse = Collapse;
  exports.Dropdown = Dropdown;
  exports.Modal = Modal;
  exports.Popover = Popover;
  exports.Scrollspy = ScrollSpy;
  exports.Tab = Tab;
  exports.Tooltip = Tooltip;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=bootstrap.bundle.js.map</UL></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
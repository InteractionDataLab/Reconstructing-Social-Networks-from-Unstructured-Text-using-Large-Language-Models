<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Aalto-Helsinki_Templates_js_bootstrap_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Aalto-Helsinki/Templates/js/bootstrap.js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE> * Bootstrap v4.1.3 (<A rel="nofollow" class="external free" href="https://getbootstrap.com/">https://getbootstrap.com/</A>)
 * Copyright 2011-2018 The Bootstrap Authors (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/graphs/contributors">https://github.com/twbs/bootstrap/graphs/contributors</A>)
 * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
 */
</PRE><P>(function (global, factory) {
</P><PRE> typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? factory(exports, require('jquery'), require('popper.js')) :
 typeof define === 'function' &amp;&amp; define.amd ? define(['exports', 'jquery', 'popper.js'], factory) :
 (factory((global.bootstrap = {}),global.jQuery,global.Popper));
</PRE><P>}(this, (function (exports,$,Popper) { 'use strict';
</P><PRE> $ = $ &amp;&amp; $.hasOwnProperty('default') ? $['default'] : $;
 Popper = Popper &amp;&amp; Popper.hasOwnProperty('default') ? Popper['default'] : Popper;
</PRE><PRE> function _defineProperties(target, props) {
   for (var i = 0; i &lt; props.length; i++) {
     var descriptor = props[i];
     descriptor.enumerable = descriptor.enumerable || false;
     descriptor.configurable = true;
     if (&quot;value&quot; in descriptor) descriptor.writable = true;
     Object.defineProperty(target, descriptor.key, descriptor);
   }
 }
</PRE><PRE> function _createClass(Constructor, protoProps, staticProps) {
   if (protoProps) _defineProperties(Constructor.prototype, protoProps);
   if (staticProps) _defineProperties(Constructor, staticProps);
   return Constructor;
 }
</PRE><PRE> function _defineProperty(obj, key, value) {
   if (key in obj) {
     Object.defineProperty(obj, key, {
       value: value,
       enumerable: true,
       configurable: true,
       writable: true
     });
   } else {
     obj[key] = value;
   }
</PRE><PRE>   return obj;
 }
</PRE><PRE> function _objectSpread(target) {
   for (var i = 1; i &lt; arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
     var ownKeys = Object.keys(source);
</PRE><PRE>     if (typeof Object.getOwnPropertySymbols === 'function') {
       ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
         return Object.getOwnPropertyDescriptor(source, sym).enumerable;
       }));
     }
</PRE><PRE>     ownKeys.forEach(function (key) {
       _defineProperty(target, key, source[key]);
     });
   }
</PRE><PRE>   return target;
 }
</PRE><PRE> function _inheritsLoose(subClass, superClass) {
   subClass.prototype = Object.create(superClass.prototype);
   subClass.prototype.constructor = subClass;
   subClass.__proto__ = superClass;
 }
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): util.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Util = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Private TransitionEnd Helpers
    * ------------------------------------------------------------------------
    */
   var TRANSITION_END = 'transitionend';
   var MAX_UID = 1000000;
   var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (<A rel="nofollow" class="external free" href="https://goo.gl/pxwQGp">https://goo.gl/pxwQGp</A>)
</PRE><PRE>   function toType(obj) {
     return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
   }
</PRE><PRE>   function getSpecialTransitionEndEvent() {
     return {
       bindType: TRANSITION_END,
       delegateType: TRANSITION_END,
       handle: function handle(event) {
         if ($$$1(event.target).is(this)) {
           return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
         }
</PRE><PRE>         return undefined; // eslint-disable-line no-undefined
       }
     };
   }
</PRE><PRE>   function transitionEndEmulator(duration) {
     var _this = this;
</PRE><PRE>     var called = false;
     $$$1(this).one(Util.TRANSITION_END, function () {
       called = true;
     });
     setTimeout(function () {
       if (!called) {
         Util.triggerTransitionEnd(_this);
       }
     }, duration);
     return this;
   }
</PRE><PRE>   function setTransitionEndSupport() {
     $$$1.fn.emulateTransitionEnd = transitionEndEmulator;
     $$$1.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
   }
   /**
    * --------------------------------------------------------------------------
    * Public Util Api
    * --------------------------------------------------------------------------
    */
</PRE><PRE>   var Util = {
     TRANSITION_END: 'bsTransitionEnd',
     getUID: function getUID(prefix) {
       do {
         // eslint-disable-next-line no-bitwise
         prefix += ~~(Math.random() * MAX_UID); // &quot;~~&quot; acts like a faster Math.floor() here
       } while (document.getElementById(prefix));
</PRE><PRE>       return prefix;
     },
     getSelectorFromElement: function getSelectorFromElement(element) {
       var selector = element.getAttribute('data-target');
</PRE><PRE>       if (!selector || selector === '#') {
         selector = element.getAttribute('href') || <I>;</I>
       }
</PRE><PRE>       try {
         return document.querySelector(selector) ? selector : null;
       } catch (err) {
         return null;
       }
     },
     getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
       if (!element) {
         return 0;
       } // Get transition-duration of the element
</PRE><PRE>       var transitionDuration = $$$1(element).css('transition-duration');
       var floatTransitionDuration = parseFloat(transitionDuration); // Return 0 if element or transition duration is not found
</PRE><PRE>       if (!floatTransitionDuration) {
         return 0;
       } // If multiple durations are defined, take the first
</PRE><PRE>       transitionDuration = transitionDuration.split(',')[0];
       return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;
     },
     reflow: function reflow(element) {
       return element.offsetHeight;
     },
     triggerTransitionEnd: function triggerTransitionEnd(element) {
       $$$1(element).trigger(TRANSITION_END);
     },
     // TODO: Remove in v5
     supportsTransitionEnd: function supportsTransitionEnd() {
       return Boolean(TRANSITION_END);
     },
     isElement: function isElement(obj) {
       return (obj[0] || obj).nodeType;
     },
     typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
       for (var property in configTypes) {
         if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
           var expectedTypes = configTypes[property];
           var value = config[property];
           var valueType = value &amp;&amp; Util.isElement(value) ? 'element' : toType(value);
</PRE><PRE>           if (!new RegExp(expectedTypes).test(valueType)) {
             throw new Error(componentName.toUpperCase() + &quot;: &quot; + (&quot;Option \&quot;&quot; + property + &quot;\&quot; provided type \&quot;&quot; + valueType + &quot;\&quot; &quot;) + (&quot;but expected type \&quot;&quot; + expectedTypes + &quot;\&quot;.&quot;));
           }
         }
       }
     }
   };
   setTransitionEndSupport();
   return Util;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): alert.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Alert = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'alert';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.alert';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var Selector = {
     DISMISS: '[data-dismiss=&quot;alert&quot;]'
   };
   var Event = {
     CLOSE: &quot;close&quot; + EVENT_KEY,
     CLOSED: &quot;closed&quot; + EVENT_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     ALERT: 'alert',
     FADE: 'fade',
     SHOW: 'show'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Alert =
   /*#__PURE__*/
   function () {
     function Alert(element) {
       this._element = element;
     } // Getters
</PRE><PRE>     var _proto = Alert.prototype;
</PRE><PRE>     // Public
     _proto.close = function close(element) {
       var rootElement = this._element;
</PRE><PRE>       if (element) {
         rootElement = this._getRootElement(element);
       }
</PRE><PRE>       var customEvent = this._triggerCloseEvent(rootElement);
</PRE><PRE>       if (customEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       this._removeElement(rootElement);
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       this._element = null;
     }; // Private
</PRE><PRE>     _proto._getRootElement = function _getRootElement(element) {
       var selector = Util.getSelectorFromElement(element);
       var parent = false;
</PRE><PRE>       if (selector) {
         parent = document.querySelector(selector);
       }
</PRE><PRE>       if (!parent) {
         parent = $$$1(element).closest(&quot;.&quot; + ClassName.ALERT)[0];
       }
</PRE><PRE>       return parent;
     };
</PRE><PRE>     _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
       var closeEvent = $$$1.Event(Event.CLOSE);
       $$$1(element).trigger(closeEvent);
       return closeEvent;
     };
</PRE><PRE>     _proto._removeElement = function _removeElement(element) {
       var _this = this;
</PRE><PRE>       $$$1(element).removeClass(ClassName.SHOW);
</PRE><PRE>       if (!$$$1(element).hasClass(ClassName.FADE)) {
         this._destroyElement(element);
</PRE><PRE>         return;
       }
</PRE><PRE>       var transitionDuration = Util.getTransitionDurationFromElement(element);
       $$$1(element).one(Util.TRANSITION_END, function (event) {
         return _this._destroyElement(element, event);
       }).emulateTransitionEnd(transitionDuration);
     };
</PRE><PRE>     _proto._destroyElement = function _destroyElement(element) {
       $$$1(element).detach().trigger(Event.CLOSED).remove();
     }; // Static
</PRE><PRE>     Alert._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var $element = $$$1(this);
         var data = $element.data(DATA_KEY);
</PRE><PRE>         if (!data) {
           data = new Alert(this);
           $element.data(DATA_KEY, data);
         }
</PRE><PRE>         if (config === 'close') {
           data[config](this);
         }
       });
     };
</PRE><PRE>     Alert._handleDismiss = function _handleDismiss(alertInstance) {
       return function (event) {
         if (event) {
           event.preventDefault();
         }
</PRE><PRE>         alertInstance.close(this);
       };
     };
</PRE><PRE>     _createClass(Alert, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }]);
</PRE><PRE>     return Alert;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Alert._jQueryInterface;
   $$$1.fn[NAME].Constructor = Alert;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Alert._jQueryInterface;
   };
</PRE><PRE>   return Alert;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): button.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Button = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'button';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.button';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var ClassName = {
     ACTIVE: 'active',
     BUTTON: 'btn',
     FOCUS: 'focus'
   };
   var Selector = {
     DATA_TOGGLE_CARROT: '[data-toggle^=&quot;button&quot;]',
     DATA_TOGGLE: '[data-toggle=&quot;buttons&quot;]',
     INPUT: 'input',
     ACTIVE: '.active',
     BUTTON: '.btn'
   };
   var Event = {
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
     FOCUS_BLUR_DATA_API: &quot;focus&quot; + EVENT_KEY + DATA_API_KEY + &quot; &quot; + (&quot;blur&quot; + EVENT_KEY + DATA_API_KEY)
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Button =
   /*#__PURE__*/
   function () {
     function Button(element) {
       this._element = element;
     } // Getters
</PRE><PRE>     var _proto = Button.prototype;
</PRE><PRE>     // Public
     _proto.toggle = function toggle() {
       var triggerChangeEvent = true;
       var addAriaPressed = true;
       var rootElement = $$$1(this._element).closest(Selector.DATA_TOGGLE)[0];
</PRE><PRE>       if (rootElement) {
         var input = this._element.querySelector(Selector.INPUT);
</PRE><PRE>         if (input) {
           if (input.type === 'radio') {
             if (input.checked &amp;&amp; this._element.classList.contains(ClassName.ACTIVE)) {
               triggerChangeEvent = false;
             } else {
               var activeElement = rootElement.querySelector(Selector.ACTIVE);
</PRE><PRE>               if (activeElement) {
                 $$$1(activeElement).removeClass(ClassName.ACTIVE);
               }
             }
           }
</PRE><PRE>           if (triggerChangeEvent) {
             if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
               return;
             }
</PRE><PRE>             input.checked = !this._element.classList.contains(ClassName.ACTIVE);
             $$$1(input).trigger('change');
           }
</PRE><PRE>           input.focus();
           addAriaPressed = false;
         }
       }
</PRE><PRE>       if (addAriaPressed) {
         this._element.setAttribute('aria-pressed', !this._element.classList.contains(ClassName.ACTIVE));
       }
</PRE><PRE>       if (triggerChangeEvent) {
         $$$1(this._element).toggleClass(ClassName.ACTIVE);
       }
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       this._element = null;
     }; // Static
</PRE><PRE>     Button._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         if (!data) {
           data = new Button(this);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (config === 'toggle') {
           data[config]();
         }
       });
     };
</PRE><PRE>     _createClass(Button, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }]);
</PRE><PRE>     return Button;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
     event.preventDefault();
     var button = event.target;
</PRE><PRE>     if (!$$$1(button).hasClass(ClassName.BUTTON)) {
       button = $$$1(button).closest(Selector.BUTTON);
     }
</PRE><PRE>     Button._jQueryInterface.call($$$1(button), 'toggle');
   }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
     var button = $$$1(event.target).closest(Selector.BUTTON)[0];
     $$$1(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Button._jQueryInterface;
   $$$1.fn[NAME].Constructor = Button;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Button._jQueryInterface;
   };
</PRE><PRE>   return Button;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): carousel.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Carousel = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'carousel';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.carousel';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key
</PRE><PRE>   var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key
</PRE><PRE>   var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch
</PRE><PRE>   var Default = {
     interval: 5000,
     keyboard: true,
     slide: false,
     pause: 'hover',
     wrap: true
   };
   var DefaultType = {
     interval: '(number|boolean)',
     keyboard: 'boolean',
     slide: '(boolean|string)',
     pause: '(string|boolean)',
     wrap: 'boolean'
   };
   var Direction = {
     NEXT: 'next',
     PREV: 'prev',
     LEFT: 'left',
     RIGHT: 'right'
   };
   var Event = {
     SLIDE: &quot;slide&quot; + EVENT_KEY,
     SLID: &quot;slid&quot; + EVENT_KEY,
     KEYDOWN: &quot;keydown&quot; + EVENT_KEY,
     MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
     MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY,
     TOUCHEND: &quot;touchend&quot; + EVENT_KEY,
     LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     CAROUSEL: 'carousel',
     ACTIVE: 'active',
     SLIDE: 'slide',
     RIGHT: 'carousel-item-right',
     LEFT: 'carousel-item-left',
     NEXT: 'carousel-item-next',
     PREV: 'carousel-item-prev',
     ITEM: 'carousel-item'
   };
   var Selector = {
     ACTIVE: '.active',
     ACTIVE_ITEM: '.active.carousel-item',
     ITEM: '.carousel-item',
     NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
     INDICATORS: '.carousel-indicators',
     DATA_SLIDE: '[data-slide], [data-slide-to]',
     DATA_RIDE: '[data-ride=&quot;carousel&quot;]'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Carousel =
   /*#__PURE__*/
   function () {
     function Carousel(element, config) {
       this._items = null;
       this._interval = null;
       this._activeElement = null;
       this._isPaused = false;
       this._isSliding = false;
       this.touchTimeout = null;
       this._config = this._getConfig(config);
       this._element = $$$1(element)[0];
       this._indicatorsElement = this._element.querySelector(Selector.INDICATORS);
</PRE><PRE>       this._addEventListeners();
     } // Getters
</PRE><PRE>     var _proto = Carousel.prototype;
</PRE><PRE>     // Public
     _proto.next = function next() {
       if (!this._isSliding) {
         this._slide(Direction.NEXT);
       }
     };
</PRE><PRE>     _proto.nextWhenVisible = function nextWhenVisible() {
       // Don't call next when the page isn't visible
       // or the carousel or its parent isn't visible
       if (!document.hidden &amp;&amp; $$$1(this._element).is(':visible') &amp;&amp; $$$1(this._element).css('visibility') !== 'hidden') {
         this.next();
       }
     };
</PRE><PRE>     _proto.prev = function prev() {
       if (!this._isSliding) {
         this._slide(Direction.PREV);
       }
     };
</PRE><PRE>     _proto.pause = function pause(event) {
       if (!event) {
         this._isPaused = true;
       }
</PRE><PRE>       if (this._element.querySelector(Selector.NEXT_PREV)) {
         Util.triggerTransitionEnd(this._element);
         this.cycle(true);
       }
</PRE><PRE>       clearInterval(this._interval);
       this._interval = null;
     };
</PRE><PRE>     _proto.cycle = function cycle(event) {
       if (!event) {
         this._isPaused = false;
       }
</PRE><PRE>       if (this._interval) {
         clearInterval(this._interval);
         this._interval = null;
       }
</PRE><PRE>       if (this._config.interval &amp;&amp; !this._isPaused) {
         this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
       }
     };
</PRE><PRE>     _proto.to = function to(index) {
       var _this = this;
</PRE><PRE>       this._activeElement = this._element.querySelector(Selector.ACTIVE_ITEM);
</PRE><PRE>       var activeIndex = this._getItemIndex(this._activeElement);
</PRE><PRE>       if (index &gt; this._items.length - 1 || index &lt; 0) {
         return;
       }
</PRE><PRE>       if (this._isSliding) {
         $$$1(this._element).one(Event.SLID, function () {
           return _this.to(index);
         });
         return;
       }
</PRE><PRE>       if (activeIndex === index) {
         this.pause();
         this.cycle();
         return;
       }
</PRE><PRE>       var direction = index &gt; activeIndex ? Direction.NEXT : Direction.PREV;
</PRE><PRE>       this._slide(direction, this._items[index]);
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1(this._element).off(EVENT_KEY);
       $$$1.removeData(this._element, DATA_KEY);
       this._items = null;
       this._config = null;
       this._element = null;
       this._interval = null;
       this._isPaused = null;
       this._isSliding = null;
       this._activeElement = null;
       this._indicatorsElement = null;
     }; // Private
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, Default, config);
       Util.typeCheckConfig(NAME, config, DefaultType);
       return config;
     };
</PRE><PRE>     _proto._addEventListeners = function _addEventListeners() {
       var _this2 = this;
</PRE><PRE>       if (this._config.keyboard) {
         $$$1(this._element).on(Event.KEYDOWN, function (event) {
           return _this2._keydown(event);
         });
       }
</PRE><PRE>       if (this._config.pause === 'hover') {
         $$$1(this._element).on(Event.MOUSEENTER, function (event) {
           return _this2.pause(event);
         }).on(Event.MOUSELEAVE, function (event) {
           return _this2.cycle(event);
         });
</PRE><PRE>         if ('ontouchstart' in document.documentElement) {
           // If it's a touch-enabled device, mouseenter/leave are fired as
           // part of the mouse compatibility events on first tap - the carousel
           // would stop cycling until user tapped out of it;
           // here, we listen for touchend, explicitly pause the carousel
           // (as if it's the second time we tap on it, mouseenter compat event
           // is NOT fired) and after a timeout (to allow for mouse compatibility
           // events to fire) we explicitly restart cycling
           $$$1(this._element).on(Event.TOUCHEND, function () {
             _this2.pause();
</PRE><PRE>             if (_this2.touchTimeout) {
               clearTimeout(_this2.touchTimeout);
             }
</PRE><PRE>             _this2.touchTimeout = setTimeout(function (event) {
               return _this2.cycle(event);
             }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);
           });
         }
       }
     };
</PRE><PRE>     _proto._keydown = function _keydown(event) {
       if (/input|textarea/i.test(event.target.tagName)) {
         return;
       }
</PRE><PRE>       switch (event.which) {
         case ARROW_LEFT_KEYCODE:
           event.preventDefault();
           this.prev();
           break;
</PRE><PRE>         case ARROW_RIGHT_KEYCODE:
           event.preventDefault();
           this.next();
           break;
</PRE><PRE>         default:
       }
     };
</PRE><PRE>     _proto._getItemIndex = function _getItemIndex(element) {
       this._items = element &amp;&amp; element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector.ITEM)) : [];
       return this._items.indexOf(element);
     };
</PRE><PRE>     _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
       var isNextDirection = direction === Direction.NEXT;
       var isPrevDirection = direction === Direction.PREV;
</PRE><PRE>       var activeIndex = this._getItemIndex(activeElement);
</PRE><PRE>       var lastItemIndex = this._items.length - 1;
       var isGoingToWrap = isPrevDirection &amp;&amp; activeIndex === 0 || isNextDirection &amp;&amp; activeIndex === lastItemIndex;
</PRE><PRE>       if (isGoingToWrap &amp;&amp; !this._config.wrap) {
         return activeElement;
       }
</PRE><PRE>       var delta = direction === Direction.PREV ? -1 : 1;
       var itemIndex = (activeIndex + delta) % this._items.length;
       return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
     };
</PRE><PRE>     _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
       var targetIndex = this._getItemIndex(relatedTarget);
</PRE><PRE>       var fromIndex = this._getItemIndex(this._element.querySelector(Selector.ACTIVE_ITEM));
</PRE><PRE>       var slideEvent = $$$1.Event(Event.SLIDE, {
         relatedTarget: relatedTarget,
         direction: eventDirectionName,
         from: fromIndex,
         to: targetIndex
       });
       $$$1(this._element).trigger(slideEvent);
       return slideEvent;
     };
</PRE><PRE>     _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
       if (this._indicatorsElement) {
         var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector.ACTIVE));
         $$$1(indicators).removeClass(ClassName.ACTIVE);
</PRE><PRE>         var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];
</PRE><PRE>         if (nextIndicator) {
           $$$1(nextIndicator).addClass(ClassName.ACTIVE);
         }
       }
     };
</PRE><PRE>     _proto._slide = function _slide(direction, element) {
       var _this3 = this;
</PRE><PRE>       var activeElement = this._element.querySelector(Selector.ACTIVE_ITEM);
</PRE><PRE>       var activeElementIndex = this._getItemIndex(activeElement);
</PRE><PRE>       var nextElement = element || activeElement &amp;&amp; this._getItemByDirection(direction, activeElement);
</PRE><PRE>       var nextElementIndex = this._getItemIndex(nextElement);
</PRE><PRE>       var isCycling = Boolean(this._interval);
       var directionalClassName;
       var orderClassName;
       var eventDirectionName;
</PRE><PRE>       if (direction === Direction.NEXT) {
         directionalClassName = ClassName.LEFT;
         orderClassName = ClassName.NEXT;
         eventDirectionName = Direction.LEFT;
       } else {
         directionalClassName = ClassName.RIGHT;
         orderClassName = ClassName.PREV;
         eventDirectionName = Direction.RIGHT;
       }
</PRE><PRE>       if (nextElement &amp;&amp; $$$1(nextElement).hasClass(ClassName.ACTIVE)) {
         this._isSliding = false;
         return;
       }
</PRE><PRE>       var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
</PRE><PRE>       if (slideEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       if (!activeElement || !nextElement) {
         // Some weirdness is happening, so we bail
         return;
       }
</PRE><PRE>       this._isSliding = true;
</PRE><PRE>       if (isCycling) {
         this.pause();
       }
</PRE><PRE>       this._setActiveIndicatorElement(nextElement);
</PRE><PRE>       var slidEvent = $$$1.Event(Event.SLID, {
         relatedTarget: nextElement,
         direction: eventDirectionName,
         from: activeElementIndex,
         to: nextElementIndex
       });
</PRE><PRE>       if ($$$1(this._element).hasClass(ClassName.SLIDE)) {
         $$$1(nextElement).addClass(orderClassName);
         Util.reflow(nextElement);
         $$$1(activeElement).addClass(directionalClassName);
         $$$1(nextElement).addClass(directionalClassName);
         var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
         $$$1(activeElement).one(Util.TRANSITION_END, function () {
           $$$1(nextElement).removeClass(directionalClassName + &quot; &quot; + orderClassName).addClass(ClassName.ACTIVE);
           $$$1(activeElement).removeClass(ClassName.ACTIVE + &quot; &quot; + orderClassName + &quot; &quot; + directionalClassName);
           _this3._isSliding = false;
           setTimeout(function () {
             return $$$1(_this3._element).trigger(slidEvent);
           }, 0);
         }).emulateTransitionEnd(transitionDuration);
       } else {
         $$$1(activeElement).removeClass(ClassName.ACTIVE);
         $$$1(nextElement).addClass(ClassName.ACTIVE);
         this._isSliding = false;
         $$$1(this._element).trigger(slidEvent);
       }
</PRE><PRE>       if (isCycling) {
         this.cycle();
       }
     }; // Static
</PRE><PRE>     Carousel._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = _objectSpread({}, Default, $$$1(this).data());
</PRE><PRE>         if (typeof config === 'object') {
           _config = _objectSpread({}, _config, config);
         }
</PRE><PRE>         var action = typeof config === 'string' ? config : _config.slide;
</PRE><PRE>         if (!data) {
           data = new Carousel(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'number') {
           data.to(config);
         } else if (typeof action === 'string') {
           if (typeof data[action] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + action + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[action]();
         } else if (_config.interval) {
           data.pause();
           data.cycle();
         }
       });
     };
</PRE><PRE>     Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
       var selector = Util.getSelectorFromElement(this);
</PRE><PRE>       if (!selector) {
         return;
       }
</PRE><PRE>       var target = $$$1(selector)[0];
</PRE><PRE>       if (!target || !$$$1(target).hasClass(ClassName.CAROUSEL)) {
         return;
       }
</PRE><PRE>       var config = _objectSpread({}, $$$1(target).data(), $$$1(this).data());
</PRE><PRE>       var slideIndex = this.getAttribute('data-slide-to');
</PRE><PRE>       if (slideIndex) {
         config.interval = false;
       }
</PRE><PRE>       Carousel._jQueryInterface.call($$$1(target), config);
</PRE><PRE>       if (slideIndex) {
         $$$1(target).data(DATA_KEY).to(slideIndex);
       }
</PRE><PRE>       event.preventDefault();
     };
</PRE><PRE>     _createClass(Carousel, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }]);
</PRE><PRE>     return Carousel;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);
   $$$1(window).on(Event.LOAD_DATA_API, function () {
     var carousels = [].slice.call(document.querySelectorAll(Selector.DATA_RIDE));
</PRE><PRE>     for (var i = 0, len = carousels.length; i &lt; len; i++) {
       var $carousel = $$$1(carousels[i]);
</PRE><PRE>       Carousel._jQueryInterface.call($carousel, $carousel.data());
     }
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Carousel._jQueryInterface;
   $$$1.fn[NAME].Constructor = Carousel;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Carousel._jQueryInterface;
   };
</PRE><PRE>   return Carousel;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): collapse.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Collapse = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'collapse';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.collapse';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var Default = {
     toggle: true,
     parent: 
   };
   var DefaultType = {
     toggle: 'boolean',
     parent: '(string|element)'
   };
   var Event = {
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     SHOW: 'show',
     COLLAPSE: 'collapse',
     COLLAPSING: 'collapsing',
     COLLAPSED: 'collapsed'
   };
   var Dimension = {
     WIDTH: 'width',
     HEIGHT: 'height'
   };
   var Selector = {
     ACTIVES: '.show, .collapsing',
     DATA_TOGGLE: '[data-toggle=&quot;collapse&quot;]'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Collapse =
   /*#__PURE__*/
   function () {
     function Collapse(element, config) {
       this._isTransitioning = false;
       this._element = element;
       this._config = this._getConfig(config);
       this._triggerArray = $$$1.makeArray(document.querySelectorAll(&quot;[data-toggle=\&quot;collapse\&quot;][href=\&quot;#&quot; + element.id + &quot;\&quot;],&quot; + (&quot;[data-toggle=\&quot;collapse\&quot;][data-target=\&quot;#&quot; + element.id + &quot;\&quot;]&quot;)));
       var toggleList = [].slice.call(document.querySelectorAll(Selector.DATA_TOGGLE));
</PRE><PRE>       for (var i = 0, len = toggleList.length; i &lt; len; i++) {
         var elem = toggleList[i];
         var selector = Util.getSelectorFromElement(elem);
         var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
           return foundElem === element;
         });
</PRE><PRE>         if (selector !== null &amp;&amp; filterElement.length &gt; 0) {
           this._selector = selector;
</PRE><PRE>           this._triggerArray.push(elem);
         }
       }
</PRE><PRE>       this._parent = this._config.parent ? this._getParent() : null;
</PRE><PRE>       if (!this._config.parent) {
         this._addAriaAndCollapsedClass(this._element, this._triggerArray);
       }
</PRE><PRE>       if (this._config.toggle) {
         this.toggle();
       }
     } // Getters
</PRE><PRE>     var _proto = Collapse.prototype;
</PRE><PRE>     // Public
     _proto.toggle = function toggle() {
       if ($$$1(this._element).hasClass(ClassName.SHOW)) {
         this.hide();
       } else {
         this.show();
       }
     };
</PRE><PRE>     _proto.show = function show() {
       var _this = this;
</PRE><PRE>       if (this._isTransitioning || $$$1(this._element).hasClass(ClassName.SHOW)) {
         return;
       }
</PRE><PRE>       var actives;
       var activesData;
</PRE><PRE>       if (this._parent) {
         actives = [].slice.call(this._parent.querySelectorAll(Selector.ACTIVES)).filter(function (elem) {
           return elem.getAttribute('data-parent') === _this._config.parent;
         });
</PRE><PRE>         if (actives.length === 0) {
           actives = null;
         }
       }
</PRE><PRE>       if (actives) {
         activesData = $$$1(actives).not(this._selector).data(DATA_KEY);
</PRE><PRE>     if (activesData &amp;&amp; activesData._isTransitioning) {
           return;
         }
       }
</PRE><PRE>       var startEvent = $$$1.Event(Event.SHOW);
       $$$1(this._element).trigger(startEvent);
</PRE><PRE>       if (startEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       if (actives) {
         Collapse._jQueryInterface.call($$$1(actives).not(this._selector), 'hide');
</PRE><PRE>         if (!activesData) {
           $$$1(actives).data(DATA_KEY, null);
         }
       }
</PRE><PRE>       var dimension = this._getDimension();
</PRE><PRE>       $$$1(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
       this._element.style[dimension] = 0;
</PRE><PRE>       if (this._triggerArray.length) {
         $$$1(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
       }
</PRE><PRE>       this.setTransitioning(true);
</PRE><PRE>       var complete = function complete() {
         $$$1(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
         _this._element.style[dimension] = <I>;</I></PRE><PRE>         _this.setTransitioning(false);
</PRE><PRE>         $$$1(_this._element).trigger(Event.SHOWN);
       };
</PRE><PRE>       var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
       var scrollSize = &quot;scroll&quot; + capitalizedDimension;
       var transitionDuration = Util.getTransitionDurationFromElement(this._element);
       $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
       this._element.style[dimension] = this._element[scrollSize] + &quot;px&quot;;
     };
</PRE><PRE>     _proto.hide = function hide() {
       var _this2 = this;
</PRE><PRE>       if (this._isTransitioning || !$$$1(this._element).hasClass(ClassName.SHOW)) {
         return;
       }
</PRE><PRE>       var startEvent = $$$1.Event(Event.HIDE);
       $$$1(this._element).trigger(startEvent);
</PRE><PRE>       if (startEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       var dimension = this._getDimension();
</PRE><PRE>       this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + &quot;px&quot;;
       Util.reflow(this._element);
       $$$1(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);
       var triggerArrayLength = this._triggerArray.length;
</PRE><PRE>       if (triggerArrayLength &gt; 0) {
         for (var i = 0; i &lt; triggerArrayLength; i++) {
           var trigger = this._triggerArray[i];
           var selector = Util.getSelectorFromElement(trigger);
</PRE><PRE>           if (selector !== null) {
             var $elem = $$$1([].slice.call(document.querySelectorAll(selector)));
</PRE><PRE>             if (!$elem.hasClass(ClassName.SHOW)) {
               $$$1(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
             }
           }
         }
       }
</PRE><PRE>       this.setTransitioning(true);
</PRE><PRE>       var complete = function complete() {
         _this2.setTransitioning(false);
</PRE><PRE>         $$$1(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
       };
</PRE><PRE>       this._element.style[dimension] = <I>;</I>
       var transitionDuration = Util.getTransitionDurationFromElement(this._element);
       $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
     };
</PRE><PRE>     _proto.setTransitioning = function setTransitioning(isTransitioning) {
       this._isTransitioning = isTransitioning;
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       this._config = null;
       this._parent = null;
       this._element = null;
       this._triggerArray = null;
       this._isTransitioning = null;
     }; // Private
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, Default, config);
       config.toggle = Boolean(config.toggle); // Coerce string values
</PRE><PRE>       Util.typeCheckConfig(NAME, config, DefaultType);
       return config;
     };
</PRE><PRE>     _proto._getDimension = function _getDimension() {
       var hasWidth = $$$1(this._element).hasClass(Dimension.WIDTH);
       return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
     };
</PRE><PRE>     _proto._getParent = function _getParent() {
       var _this3 = this;
</PRE><PRE>       var parent = null;
</PRE><PRE>       if (Util.isElement(this._config.parent)) {
         parent = this._config.parent; // It's a jQuery object
</PRE><PRE>         if (typeof this._config.parent.jquery !== 'undefined') {
           parent = this._config.parent[0];
         }
       } else {
         parent = document.querySelector(this._config.parent);
       }
</PRE><PRE>       var selector = &quot;[data-toggle=\&quot;collapse\&quot;][data-parent=\&quot;&quot; + this._config.parent + &quot;\&quot;]&quot;;
       var children = [].slice.call(parent.querySelectorAll(selector));
       $$$1(children).each(function (i, element) {
         _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
       });
       return parent;
     };
</PRE><PRE>     _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
       if (element) {
         var isOpen = $$$1(element).hasClass(ClassName.SHOW);
</PRE><PRE>         if (triggerArray.length) {
           $$$1(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
         }
       }
     }; // Static
</PRE><PRE>     Collapse._getTargetFromElement = function _getTargetFromElement(element) {
       var selector = Util.getSelectorFromElement(element);
       return selector ? document.querySelector(selector) : null;
     };
</PRE><PRE>     Collapse._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var $this = $$$1(this);
         var data = $this.data(DATA_KEY);
</PRE><PRE>         var _config = _objectSpread({}, Default, $this.data(), typeof config === 'object' &amp;&amp; config ? config : {});
</PRE><PRE>         if (!data &amp;&amp; _config.toggle &amp;&amp; /show|hide/.test(config)) {
           _config.toggle = false;
         }
</PRE><PRE>         if (!data) {
           data = new Collapse(this, _config);
           $this.data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config]();
         }
       });
     };
</PRE><PRE>     _createClass(Collapse, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }]);
</PRE><PRE>     return Collapse;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
     // preventDefault only for &lt;a&gt; elements (which change the URL) not inside the collapsible element
     if (event.currentTarget.tagName === 'A') {
       event.preventDefault();
     }
</PRE><PRE>     var $trigger = $$$1(this);
     var selector = Util.getSelectorFromElement(this);
     var selectors = [].slice.call(document.querySelectorAll(selector));
     $$$1(selectors).each(function () {
       var $target = $$$1(this);
       var data = $target.data(DATA_KEY);
       var config = data ? 'toggle' : $trigger.data();
</PRE><PRE>       Collapse._jQueryInterface.call($target, config);
     });
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Collapse._jQueryInterface;
   $$$1.fn[NAME].Constructor = Collapse;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Collapse._jQueryInterface;
   };
</PRE><PRE>   return Collapse;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): dropdown.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Dropdown = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'dropdown';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.dropdown';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key
</PRE><PRE>   var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key
</PRE><PRE>   var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key
</PRE><PRE>   var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key
</PRE><PRE>   var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key
</PRE><PRE>   var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)
</PRE><PRE>   var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + &quot;|&quot; + ARROW_DOWN_KEYCODE + &quot;|&quot; + ESCAPE_KEYCODE);
   var Event = {
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     CLICK: &quot;click&quot; + EVENT_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY,
     KEYDOWN_DATA_API: &quot;keydown&quot; + EVENT_KEY + DATA_API_KEY,
     KEYUP_DATA_API: &quot;keyup&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     DISABLED: 'disabled',
     SHOW: 'show',
     DROPUP: 'dropup',
     DROPRIGHT: 'dropright',
     DROPLEFT: 'dropleft',
     MENURIGHT: 'dropdown-menu-right',
     MENULEFT: 'dropdown-menu-left',
     POSITION_STATIC: 'position-static'
   };
   var Selector = {
     DATA_TOGGLE: '[data-toggle=&quot;dropdown&quot;]',
     FORM_CHILD: '.dropdown form',
     MENU: '.dropdown-menu',
     NAVBAR_NAV: '.navbar-nav',
     VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'
   };
   var AttachmentMap = {
     TOP: 'top-start',
     TOPEND: 'top-end',
     BOTTOM: 'bottom-start',
     BOTTOMEND: 'bottom-end',
     RIGHT: 'right-start',
     RIGHTEND: 'right-end',
     LEFT: 'left-start',
     LEFTEND: 'left-end'
   };
   var Default = {
     offset: 0,
     flip: true,
     boundary: 'scrollParent',
     reference: 'toggle',
     display: 'dynamic'
   };
   var DefaultType = {
     offset: '(number|string|function)',
     flip: 'boolean',
     boundary: '(string|element)',
     reference: '(string|element)',
     display: 'string'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Dropdown =
   /*#__PURE__*/
   function () {
     function Dropdown(element, config) {
       this._element = element;
       this._popper = null;
       this._config = this._getConfig(config);
       this._menu = this._getMenuElement();
       this._inNavbar = this._detectNavbar();
</PRE><PRE>       this._addEventListeners();
     } // Getters
</PRE><PRE>     var _proto = Dropdown.prototype;
</PRE><PRE>     // Public
     _proto.toggle = function toggle() {
       if (this._element.disabled || $$$1(this._element).hasClass(ClassName.DISABLED)) {
         return;
       }
</PRE><PRE>       var parent = Dropdown._getParentFromElement(this._element);
</PRE><PRE>       var isActive = $$$1(this._menu).hasClass(ClassName.SHOW);
</PRE><PRE>       Dropdown._clearMenus();
</PRE><PRE>       if (isActive) {
         return;
       }
</PRE><PRE>       var relatedTarget = {
         relatedTarget: this._element
       };
       var showEvent = $$$1.Event(Event.SHOW, relatedTarget);
       $$$1(parent).trigger(showEvent);
</PRE><PRE>       if (showEvent.isDefaultPrevented()) {
         return;
       } // Disable totally Popper.js for Dropdown in Navbar
</PRE><PRE>       if (!this._inNavbar) {
         /**
          * Check for Popper dependency
          * Popper - <A rel="nofollow" class="external free" href="https://popper.js.org">https://popper.js.org</A>
          */
         if (typeof Popper === 'undefined') {
           throw new TypeError('Bootstrap dropdown require Popper.js (<A rel="nofollow" class="external free" href="https://popper.js.org)'">https://popper.js.org)'</A>);
         }
</PRE><PRE>         var referenceElement = this._element;
</PRE><PRE>         if (this._config.reference === 'parent') {
           referenceElement = parent;
         } else if (Util.isElement(this._config.reference)) {
           referenceElement = this._config.reference; // Check if it's jQuery element
</PRE><PRE>           if (typeof this._config.reference.jquery !== 'undefined') {
             referenceElement = this._config.reference[0];
           }
         } // If boundary is not `scrollParent`, then set position to `static`
         // to allow the menu to &quot;escape&quot; the scroll parent's boundaries
         // <A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/issues/24251">https://github.com/twbs/bootstrap/issues/24251</A></PRE><PRE>         if (this._config.boundary !== 'scrollParent') {
           $$$1(parent).addClass(ClassName.POSITION_STATIC);
         }
</PRE><PRE>         this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());
       } // If this is a touch-enabled device we add extra
       // empty mouseover listeners to the body's immediate children;
       // only needed because of broken event delegation on iOS
       // <A rel="nofollow" class="external free" href="https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html">https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html</A></PRE><PRE>       if ('ontouchstart' in document.documentElement &amp;&amp; $$$1(parent).closest(Selector.NAVBAR_NAV).length === 0) {
         $$$1(document.body).children().on('mouseover', null, $$$1.noop);
       }
</PRE><PRE>       this._element.focus();
</PRE><PRE>       this._element.setAttribute('aria-expanded', true);
</PRE><PRE>       $$$1(this._menu).toggleClass(ClassName.SHOW);
       $$$1(parent).toggleClass(ClassName.SHOW).trigger($$$1.Event(Event.SHOWN, relatedTarget));
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       $$$1(this._element).off(EVENT_KEY);
       this._element = null;
       this._menu = null;
</PRE><PRE>       if (this._popper !== null) {
         this._popper.destroy();
</PRE><PRE>         this._popper = null;
       }
     };
</PRE><PRE>     _proto.update = function update() {
       this._inNavbar = this._detectNavbar();
</PRE><PRE>       if (this._popper !== null) {
         this._popper.scheduleUpdate();
       }
     }; // Private
</PRE><PRE>     _proto._addEventListeners = function _addEventListeners() {
       var _this = this;
</PRE><PRE>       $$$1(this._element).on(Event.CLICK, function (event) {
         event.preventDefault();
         event.stopPropagation();
</PRE><PRE>         _this.toggle();
       });
     };
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, this.constructor.Default, $$$1(this._element).data(), config);
       Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
       return config;
     };
</PRE><PRE>     _proto._getMenuElement = function _getMenuElement() {
       if (!this._menu) {
         var parent = Dropdown._getParentFromElement(this._element);
</PRE><PRE>         if (parent) {
           this._menu = parent.querySelector(Selector.MENU);
         }
       }
</PRE><PRE>       return this._menu;
     };
</PRE><PRE>     _proto._getPlacement = function _getPlacement() {
       var $parentDropdown = $$$1(this._element.parentNode);
       var placement = AttachmentMap.BOTTOM; // Handle dropup
</PRE><PRE>       if ($parentDropdown.hasClass(ClassName.DROPUP)) {
         placement = AttachmentMap.TOP;
</PRE><PRE>         if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
           placement = AttachmentMap.TOPEND;
         }
       } else if ($parentDropdown.hasClass(ClassName.DROPRIGHT)) {
         placement = AttachmentMap.RIGHT;
       } else if ($parentDropdown.hasClass(ClassName.DROPLEFT)) {
         placement = AttachmentMap.LEFT;
       } else if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
         placement = AttachmentMap.BOTTOMEND;
       }
</PRE><PRE>       return placement;
     };
</PRE><PRE>     _proto._detectNavbar = function _detectNavbar() {
       return $$$1(this._element).closest('.navbar').length &gt; 0;
     };
</PRE><PRE>     _proto._getPopperConfig = function _getPopperConfig() {
       var _this2 = this;
</PRE><PRE>       var offsetConf = {};
</PRE><PRE>       if (typeof this._config.offset === 'function') {
         offsetConf.fn = function (data) {
           data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets) || {});
           return data;
         };
       } else {
         offsetConf.offset = this._config.offset;
       }
</PRE><PRE>       var popperConfig = {
         placement: this._getPlacement(),
         modifiers: {
           offset: offsetConf,
           flip: {
             enabled: this._config.flip
           },
           preventOverflow: {
             boundariesElement: this._config.boundary
           }
         } // Disable Popper.js if we have a static display
</PRE><PRE>       };
</PRE><PRE>       if (this._config.display === 'static') {
         popperConfig.modifiers.applyStyle = {
           enabled: false
         };
       }
</PRE><PRE>       return popperConfig;
     }; // Static
</PRE><PRE>     Dropdown._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = typeof config === 'object' ? config : null;
</PRE><PRE>         if (!data) {
           data = new Dropdown(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config]();
         }
       });
     };
</PRE><PRE>     Dropdown._clearMenus = function _clearMenus(event) {
       if (event &amp;&amp; (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' &amp;&amp; event.which !== TAB_KEYCODE)) {
         return;
       }
</PRE><PRE>       var toggles = [].slice.call(document.querySelectorAll(Selector.DATA_TOGGLE));
</PRE><PRE>       for (var i = 0, len = toggles.length; i &lt; len; i++) {
         var parent = Dropdown._getParentFromElement(toggles[i]);
</PRE><PRE>         var context = $$$1(toggles[i]).data(DATA_KEY);
         var relatedTarget = {
           relatedTarget: toggles[i]
         };
</PRE><PRE>         if (event &amp;&amp; event.type === 'click') {
           relatedTarget.clickEvent = event;
         }
</PRE><PRE>         if (!context) {
           continue;
         }
</PRE><PRE>         var dropdownMenu = context._menu;
</PRE><PRE>         if (!$$$1(parent).hasClass(ClassName.SHOW)) {
           continue;
         }
</PRE><PRE>         if (event &amp;&amp; (event.type === 'click' &amp;&amp; /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' &amp;&amp; event.which === TAB_KEYCODE) &amp;&amp; $$$1.contains(parent, event.target)) {
           continue;
         }
</PRE><PRE>         var hideEvent = $$$1.Event(Event.HIDE, relatedTarget);
         $$$1(parent).trigger(hideEvent);
</PRE><PRE>         if (hideEvent.isDefaultPrevented()) {
           continue;
         } // If this is a touch-enabled device we remove the extra
         // empty mouseover listeners we added for iOS support
</PRE><PRE>         if ('ontouchstart' in document.documentElement) {
           $$$1(document.body).children().off('mouseover', null, $$$1.noop);
         }
</PRE><PRE>         toggles[i].setAttribute('aria-expanded', 'false');
         $$$1(dropdownMenu).removeClass(ClassName.SHOW);
         $$$1(parent).removeClass(ClassName.SHOW).trigger($$$1.Event(Event.HIDDEN, relatedTarget));
       }
     };
</PRE><PRE>     Dropdown._getParentFromElement = function _getParentFromElement(element) {
       var parent;
       var selector = Util.getSelectorFromElement(element);
</PRE><PRE>       if (selector) {
         parent = document.querySelector(selector);
       }
</PRE><PRE>       return parent || element.parentNode;
     }; // eslint-disable-next-line complexity
</PRE><PRE>     Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
       // If not input/textarea:
       //  - And not a key in REGEXP_KEYDOWN =&gt; not a dropdown command
       // If input/textarea:
       //  - If space key =&gt; not a dropdown command
       //  - If key is other than escape
       //    - If key is not up or down =&gt; not a dropdown command
       //    - If trigger inside the menu =&gt; not a dropdown command
       if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE &amp;&amp; (event.which !== ARROW_DOWN_KEYCODE &amp;&amp; event.which !== ARROW_UP_KEYCODE || $$$1(event.target).closest(Selector.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
         return;
       }
</PRE><PRE>       event.preventDefault();
       event.stopPropagation();
</PRE><PRE>       if (this.disabled || $$$1(this).hasClass(ClassName.DISABLED)) {
         return;
       }
</PRE><PRE>       var parent = Dropdown._getParentFromElement(this);
</PRE><PRE>       var isActive = $$$1(parent).hasClass(ClassName.SHOW);
</PRE><PRE>       if (!isActive &amp;&amp; (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive &amp;&amp; (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
         if (event.which === ESCAPE_KEYCODE) {
           var toggle = parent.querySelector(Selector.DATA_TOGGLE);
           $$$1(toggle).trigger('focus');
         }
</PRE><PRE>         $$$1(this).trigger('click');
         return;
       }
</PRE><PRE>       var items = [].slice.call(parent.querySelectorAll(Selector.VISIBLE_ITEMS));
</PRE><PRE>       if (items.length === 0) {
         return;
       }
</PRE><PRE>       var index = items.indexOf(event.target);
</PRE><PRE>       if (event.which === ARROW_UP_KEYCODE &amp;&amp; index &gt; 0) {
         // Up
         index--;
       }
</PRE><PRE>       if (event.which === ARROW_DOWN_KEYCODE &amp;&amp; index &lt; items.length - 1) {
         // Down
         index++;
       }
</PRE><PRE>       if (index &lt; 0) {
         index = 0;
       }
</PRE><PRE>       items[index].focus();
     };
</PRE><PRE>     _createClass(Dropdown, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }, {
       key: &quot;DefaultType&quot;,
       get: function get() {
         return DefaultType;
       }
     }]);
</PRE><PRE>     return Dropdown;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + &quot; &quot; + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
     event.preventDefault();
     event.stopPropagation();
</PRE><PRE>     Dropdown._jQueryInterface.call($$$1(this), 'toggle');
   }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
     e.stopPropagation();
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Dropdown._jQueryInterface;
   $$$1.fn[NAME].Constructor = Dropdown;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Dropdown._jQueryInterface;
   };
</PRE><PRE>   return Dropdown;
 }($, Popper);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): modal.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Modal = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'modal';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.modal';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key
</PRE><PRE>   var Default = {
     backdrop: true,
     keyboard: true,
     focus: true,
     show: true
   };
   var DefaultType = {
     backdrop: '(boolean|string)',
     keyboard: 'boolean',
     focus: 'boolean',
     show: 'boolean'
   };
   var Event = {
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
     RESIZE: &quot;resize&quot; + EVENT_KEY,
     CLICK_DISMISS: &quot;click.dismiss&quot; + EVENT_KEY,
     KEYDOWN_DISMISS: &quot;keydown.dismiss&quot; + EVENT_KEY,
     MOUSEUP_DISMISS: &quot;mouseup.dismiss&quot; + EVENT_KEY,
     MOUSEDOWN_DISMISS: &quot;mousedown.dismiss&quot; + EVENT_KEY,
     CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
     BACKDROP: 'modal-backdrop',
     OPEN: 'modal-open',
     FADE: 'fade',
     SHOW: 'show'
   };
   var Selector = {
     DIALOG: '.modal-dialog',
     DATA_TOGGLE: '[data-toggle=&quot;modal&quot;]',
     DATA_DISMISS: '[data-dismiss=&quot;modal&quot;]',
     FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
     STICKY_CONTENT: '.sticky-top'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Modal =
   /*#__PURE__*/
   function () {
     function Modal(element, config) {
       this._config = this._getConfig(config);
       this._element = element;
       this._dialog = element.querySelector(Selector.DIALOG);
       this._backdrop = null;
       this._isShown = false;
       this._isBodyOverflowing = false;
       this._ignoreBackdropClick = false;
       this._scrollbarWidth = 0;
     } // Getters
</PRE><PRE>     var _proto = Modal.prototype;
</PRE><PRE>     // Public
     _proto.toggle = function toggle(relatedTarget) {
       return this._isShown ? this.hide() : this.show(relatedTarget);
     };
</PRE><PRE>     _proto.show = function show(relatedTarget) {
       var _this = this;
</PRE><PRE>       if (this._isTransitioning || this._isShown) {
         return;
       }
</PRE><PRE>       if ($$$1(this._element).hasClass(ClassName.FADE)) {
         this._isTransitioning = true;
       }
</PRE><PRE>       var showEvent = $$$1.Event(Event.SHOW, {
         relatedTarget: relatedTarget
       });
       $$$1(this._element).trigger(showEvent);
</PRE><PRE>       if (this._isShown || showEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       this._isShown = true;
</PRE><PRE>       this._checkScrollbar();
</PRE><PRE>       this._setScrollbar();
</PRE><PRE>       this._adjustDialog();
</PRE><PRE>       $$$1(document.body).addClass(ClassName.OPEN);
</PRE><PRE>       this._setEscapeEvent();
</PRE><PRE>       this._setResizeEvent();
</PRE><PRE>       $$$1(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
         return _this.hide(event);
       });
       $$$1(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
         $$$1(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {
           if ($$$1(event.target).is(_this._element)) {
             _this._ignoreBackdropClick = true;
           }
         });
       });
</PRE><PRE>       this._showBackdrop(function () {
         return _this._showElement(relatedTarget);
       });
     };
</PRE><PRE>     _proto.hide = function hide(event) {
       var _this2 = this;
</PRE><PRE>       if (event) {
         event.preventDefault();
       }
</PRE><PRE>       if (this._isTransitioning || !this._isShown) {
         return;
       }
</PRE><PRE>       var hideEvent = $$$1.Event(Event.HIDE);
       $$$1(this._element).trigger(hideEvent);
</PRE><PRE>       if (!this._isShown || hideEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       this._isShown = false;
       var transition = $$$1(this._element).hasClass(ClassName.FADE);
</PRE><PRE>       if (transition) {
         this._isTransitioning = true;
       }
</PRE><PRE>       this._setEscapeEvent();
</PRE><PRE>       this._setResizeEvent();
</PRE><PRE>       $$$1(document).off(Event.FOCUSIN);
       $$$1(this._element).removeClass(ClassName.SHOW);
       $$$1(this._element).off(Event.CLICK_DISMISS);
       $$$1(this._dialog).off(Event.MOUSEDOWN_DISMISS);
</PRE><PRE>       if (transition) {
         var transitionDuration = Util.getTransitionDurationFromElement(this._element);
         $$$1(this._element).one(Util.TRANSITION_END, function (event) {
           return _this2._hideModal(event);
         }).emulateTransitionEnd(transitionDuration);
       } else {
         this._hideModal();
       }
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       $$$1(window, document, this._element, this._backdrop).off(EVENT_KEY);
       this._config = null;
       this._element = null;
       this._dialog = null;
       this._backdrop = null;
       this._isShown = null;
       this._isBodyOverflowing = null;
       this._ignoreBackdropClick = null;
       this._scrollbarWidth = null;
     };
</PRE><PRE>     _proto.handleUpdate = function handleUpdate() {
       this._adjustDialog();
     }; // Private
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, Default, config);
       Util.typeCheckConfig(NAME, config, DefaultType);
       return config;
     };
</PRE><PRE>     _proto._showElement = function _showElement(relatedTarget) {
       var _this3 = this;
</PRE><PRE>       var transition = $$$1(this._element).hasClass(ClassName.FADE);
</PRE><PRE>       if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
         // Don't move modal's DOM position
         document.body.appendChild(this._element);
       }
</PRE><PRE>       this._element.style.display = 'block';
</PRE><PRE>       this._element.removeAttribute('aria-hidden');
</PRE><PRE>   this._element.scrollTop = 0;
</PRE><PRE>       if (transition) {
         Util.reflow(this._element);
       }
</PRE><PRE>       $$$1(this._element).addClass(ClassName.SHOW);
</PRE><PRE>       if (this._config.focus) {
         this._enforceFocus();
       }
</PRE><PRE>       var shownEvent = $$$1.Event(Event.SHOWN, {
         relatedTarget: relatedTarget
       });
</PRE><PRE>       var transitionComplete = function transitionComplete() {
         if (_this3._config.focus) {
           _this3._element.focus();
         }
</PRE><PRE>         _this3._isTransitioning = false;
         $$$1(_this3._element).trigger(shownEvent);
       };
</PRE><PRE>       if (transition) {
         var transitionDuration = Util.getTransitionDurationFromElement(this._element);
         $$$1(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
       } else {
         transitionComplete();
       }
     };
</PRE><PRE>     _proto._enforceFocus = function _enforceFocus() {
       var _this4 = this;
</PRE><PRE>       $$$1(document).off(Event.FOCUSIN) // Guard against infinite focus loop
       .on(Event.FOCUSIN, function (event) {
         if (document !== event.target &amp;&amp; _this4._element !== event.target &amp;&amp; $$$1(_this4._element).has(event.target).length === 0) {
           _this4._element.focus();
         }
       });
     };
</PRE><PRE>     _proto._setEscapeEvent = function _setEscapeEvent() {
       var _this5 = this;
</PRE><PRE>       if (this._isShown &amp;&amp; this._config.keyboard) {
         $$$1(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
           if (event.which === ESCAPE_KEYCODE) {
             event.preventDefault();
</PRE><PRE>             _this5.hide();
           }
         });
       } else if (!this._isShown) {
         $$$1(this._element).off(Event.KEYDOWN_DISMISS);
       }
     };
</PRE><PRE>     _proto._setResizeEvent = function _setResizeEvent() {
       var _this6 = this;
</PRE><PRE>       if (this._isShown) {
         $$$1(window).on(Event.RESIZE, function (event) {
           return _this6.handleUpdate(event);
         });
       } else {
         $$$1(window).off(Event.RESIZE);
       }
     };
</PRE><PRE>     _proto._hideModal = function _hideModal() {
       var _this7 = this;
</PRE><PRE>       this._element.style.display = 'none';
</PRE><PRE>       this._element.setAttribute('aria-hidden', true);
</PRE><PRE>       this._isTransitioning = false;
</PRE><PRE>       this._showBackdrop(function () {
         $$$1(document.body).removeClass(ClassName.OPEN);
</PRE><PRE>         _this7._resetAdjustments();
</PRE><PRE>         _this7._resetScrollbar();
</PRE><PRE>         $$$1(_this7._element).trigger(Event.HIDDEN);
       });
     };
</PRE><PRE>     _proto._removeBackdrop = function _removeBackdrop() {
       if (this._backdrop) {
         $$$1(this._backdrop).remove();
         this._backdrop = null;
       }
     };
</PRE><PRE>     _proto._showBackdrop = function _showBackdrop(callback) {
       var _this8 = this;
</PRE><PRE>       var animate = $$$1(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : <I>;</I></PRE><PRE>       if (this._isShown &amp;&amp; this._config.backdrop) {
         this._backdrop = document.createElement('div');
         this._backdrop.className = ClassName.BACKDROP;
</PRE><PRE>         if (animate) {
           this._backdrop.classList.add(animate);
         }
</PRE><PRE>         $$$1(this._backdrop).appendTo(document.body);
         $$$1(this._element).on(Event.CLICK_DISMISS, function (event) {
           if (_this8._ignoreBackdropClick) {
             _this8._ignoreBackdropClick = false;
             return;
           }
</PRE><PRE>           if (event.target !== event.currentTarget) {
             return;
           }
</PRE><PRE>           if (_this8._config.backdrop === 'static') {
             _this8._element.focus();
           } else {
             _this8.hide();
           }
         });
</PRE><PRE>         if (animate) {
           Util.reflow(this._backdrop);
         }
</PRE><PRE>         $$$1(this._backdrop).addClass(ClassName.SHOW);
</PRE><PRE>         if (!callback) {
           return;
         }
</PRE><PRE>         if (!animate) {
           callback();
           return;
         }
</PRE><PRE>         var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
         $$$1(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
       } else if (!this._isShown &amp;&amp; this._backdrop) {
         $$$1(this._backdrop).removeClass(ClassName.SHOW);
</PRE><PRE>         var callbackRemove = function callbackRemove() {
           _this8._removeBackdrop();
</PRE><PRE>           if (callback) {
             callback();
           }
         };
</PRE><PRE>         if ($$$1(this._element).hasClass(ClassName.FADE)) {
           var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
</PRE><PRE>           $$$1(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
         } else {
           callbackRemove();
         }
       } else if (callback) {
         callback();
       }
     }; // ----------------------------------------------------------------------
     // the following methods are used to handle overflowing modals
     // todo (fat): these should probably be refactored out of modal.js
     // ----------------------------------------------------------------------
</PRE><PRE>     _proto._adjustDialog = function _adjustDialog() {
       var isModalOverflowing = this._element.scrollHeight &gt; document.documentElement.clientHeight;
</PRE><PRE>       if (!this._isBodyOverflowing &amp;&amp; isModalOverflowing) {
         this._element.style.paddingLeft = this._scrollbarWidth + &quot;px&quot;;
       }
</PRE><PRE>       if (this._isBodyOverflowing &amp;&amp; !isModalOverflowing) {
         this._element.style.paddingRight = this._scrollbarWidth + &quot;px&quot;;
       }
     };</PRE><PRE>     _proto._resetAdjustments = function _resetAdjustments() {
       this._element.style.paddingLeft = <I>;</I>
       this._element.style.paddingRight = <I>;</I>
     };
</PRE><PRE>     _proto._checkScrollbar = function _checkScrollbar() {
       var rect = document.body.getBoundingClientRect();
       this._isBodyOverflowing = rect.left + rect.right &lt; window.innerWidth;
       this._scrollbarWidth = this._getScrollbarWidth();
     };
</PRE><PRE>     _proto._setScrollbar = function _setScrollbar() {
       var _this9 = this;
</PRE><PRE>       if (this._isBodyOverflowing) {
         // Note: DOMNode.style.paddingRight returns the actual value or <I> if not set</I>
         //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
         var fixedContent = [].slice.call(document.querySelectorAll(Selector.FIXED_CONTENT));
         var stickyContent = [].slice.call(document.querySelectorAll(Selector.STICKY_CONTENT)); // Adjust fixed content padding
</PRE><PRE>         $$$1(fixedContent).each(function (index, element) {
           var actualPadding = element.style.paddingRight;
           var calculatedPadding = $$$1(element).css('padding-right');
           $$$1(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + &quot;px&quot;);
         }); // Adjust sticky content margin
</PRE><PRE>         $$$1(stickyContent).each(function (index, element) {
           var actualMargin = element.style.marginRight;
           var calculatedMargin = $$$1(element).css('margin-right');
           $$$1(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + &quot;px&quot;);
         }); // Adjust body padding
</PRE><PRE>         var actualPadding = document.body.style.paddingRight;
         var calculatedPadding = $$$1(document.body).css('padding-right');
         $$$1(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + &quot;px&quot;);
       }
     };
</PRE><PRE>     _proto._resetScrollbar = function _resetScrollbar() {
       // Restore fixed content padding
       var fixedContent = [].slice.call(document.querySelectorAll(Selector.FIXED_CONTENT));
       $$$1(fixedContent).each(function (index, element) {
         var padding = $$$1(element).data('padding-right');
         $$$1(element).removeData('padding-right');
         element.style.paddingRight = padding ? padding : <I>;</I>
       }); // Restore sticky content
</PRE><PRE>       var elements = [].slice.call(document.querySelectorAll(&quot;&quot; + Selector.STICKY_CONTENT));
       $$$1(elements).each(function (index, element) {
         var margin = $$$1(element).data('margin-right');
</PRE><PRE>         if (typeof margin !== 'undefined') {
           $$$1(element).css('margin-right', margin).removeData('margin-right');
         }
       }); // Restore body padding
</PRE><PRE>       var padding = $$$1(document.body).data('padding-right');
       $$$1(document.body).removeData('padding-right');
       document.body.style.paddingRight = padding ? padding : <I>;</I>
     };
</PRE><PRE>     _proto._getScrollbarWidth = function _getScrollbarWidth() {
       // thx d.walsh
       var scrollDiv = document.createElement('div');
       scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
       document.body.appendChild(scrollDiv);
       var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
       document.body.removeChild(scrollDiv);
       return scrollbarWidth;
     }; // Static
</PRE><PRE>     Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = _objectSpread({}, Default, $$$1(this).data(), typeof config === 'object' &amp;&amp; config ? config : {});
</PRE><PRE>         if (!data) {
           data = new Modal(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config](relatedTarget);
         } else if (_config.show) {
           data.show(relatedTarget);
         }
       });
     };
</PRE><PRE>     _createClass(Modal, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }]);
</PRE><PRE>     return Modal;
   }();
   /**
    * ------------------------------------------------------------------------
    * Data Api implementation
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
     var _this10 = this;
</PRE><PRE>     var target;
     var selector = Util.getSelectorFromElement(this);
</PRE><PRE>     if (selector) {
       target = document.querySelector(selector);
     }
</PRE><PRE>     var config = $$$1(target).data(DATA_KEY) ? 'toggle' : _objectSpread({}, $$$1(target).data(), $$$1(this).data());
</PRE><PRE>     if (this.tagName === 'A' || this.tagName === 'AREA') {
       event.preventDefault();
     }
</PRE><PRE>     var $target = $$$1(target).one(Event.SHOW, function (showEvent) {
       if (showEvent.isDefaultPrevented()) {
         // Only register focus restorer if modal will actually get shown
         return;
       }
</PRE><PRE>       $target.one(Event.HIDDEN, function () {
         if ($$$1(_this10).is(':visible')) {
           _this10.focus();
         }
       });
     });
</PRE><PRE>     Modal._jQueryInterface.call($$$1(target), config, this);
   });
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Modal._jQueryInterface;
   $$$1.fn[NAME].Constructor = Modal;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Modal._jQueryInterface;
   };
</PRE><PRE>   return Modal;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): tooltip.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Tooltip = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'tooltip';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.tooltip';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var CLASS_PREFIX = 'bs-tooltip';
   var BSCLS_PREFIX_REGEX = new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, 'g');
   var DefaultType = {
     animation: 'boolean',
     template: 'string',
     title: '(string|element|function)',
     trigger: 'string',
     delay: '(number|object)',
     html: 'boolean',
     selector: '(string|boolean)',
     placement: '(string|function)',
     offset: '(number|string)',
     container: '(string|element|boolean)',
     fallbackPlacement: '(string|array)',
     boundary: '(string|element)'
   };
   var AttachmentMap = {
     AUTO: 'auto',
     TOP: 'top',
     RIGHT: 'right',
     BOTTOM: 'bottom',
     LEFT: 'left'
   };
   var Default = {
     animation: true,
</PRE>
      template: '<DIV class="tooltip">' + '' + '</DIV>',
<PRE>     trigger: 'hover focus',
     title: <I>,</I>
     delay: 0,
     html: false,
     selector: false,
     placement: 'top',
     offset: 0,
     container: false,
     fallbackPlacement: 'flip',
     boundary: 'scrollParent'
   };
   var HoverState = {
     SHOW: 'show',
     OUT: 'out'
   };
   var Event = {
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     INSERTED: &quot;inserted&quot; + EVENT_KEY,
     CLICK: &quot;click&quot; + EVENT_KEY,
     FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
     FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
     MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
     MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
   };
   var ClassName = {
     FADE: 'fade',
     SHOW: 'show'
   };
   var Selector = {
     TOOLTIP: '.tooltip',
     TOOLTIP_INNER: '.tooltip-inner',
     ARROW: '.arrow'
   };
   var Trigger = {
     HOVER: 'hover',
     FOCUS: 'focus',
     CLICK: 'click',
     MANUAL: 'manual'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Tooltip =
   /*#__PURE__*/
   function () {
     function Tooltip(element, config) {
       /**
        * Check for Popper dependency
        * Popper - <A rel="nofollow" class="external free" href="https://popper.js.org">https://popper.js.org</A>
        */
       if (typeof Popper === 'undefined') {
         throw new TypeError('Bootstrap tooltips require Popper.js (<A rel="nofollow" class="external free" href="https://popper.js.org)'">https://popper.js.org)'</A>);
       } // private
</PRE><PRE>       this._isEnabled = true;
       this._timeout = 0;
       this._hoverState = <I>;</I>
       this._activeTrigger = {};
       this._popper = null; // Protected
</PRE><PRE>       this.element = element;
       this.config = this._getConfig(config);
       this.tip = null;
</PRE><PRE>       this._setListeners();
     } // Getters
</PRE><PRE>     var _proto = Tooltip.prototype;
</PRE><PRE>     // Public
     _proto.enable = function enable() {
       this._isEnabled = true;
     };
</PRE><PRE>     _proto.disable = function disable() {
       this._isEnabled = false;
     };
</PRE><PRE>     _proto.toggleEnabled = function toggleEnabled() {
       this._isEnabled = !this._isEnabled;
     };
</PRE><PRE>     _proto.toggle = function toggle(event) {
       if (!this._isEnabled) {
         return;
       }
</PRE><PRE>       if (event) {
         var dataKey = this.constructor.DATA_KEY;
         var context = $$$1(event.currentTarget).data(dataKey);
</PRE><PRE>         if (!context) {
           context = new this.constructor(event.currentTarget, this._getDelegateConfig());
           $$$1(event.currentTarget).data(dataKey, context);
         }
</PRE><PRE>         context._activeTrigger.click = !context._activeTrigger.click;
</PRE><PRE>         if (context._isWithActiveTrigger()) {
           context._enter(null, context);
         } else {
           context._leave(null, context);
         }
       } else {
         if ($$$1(this.getTipElement()).hasClass(ClassName.SHOW)) {
           this._leave(null, this);
</PRE><PRE>           return;
         }
</PRE><PRE>         this._enter(null, this);
       }
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       clearTimeout(this._timeout);
       $$$1.removeData(this.element, this.constructor.DATA_KEY);
       $$$1(this.element).off(this.constructor.EVENT_KEY);
       $$$1(this.element).closest('.modal').off('hide.bs.modal');
</PRE><PRE>       if (this.tip) {
         $$$1(this.tip).remove();
       }
</PRE><PRE>       this._isEnabled = null;
       this._timeout = null;
       this._hoverState = null;
       this._activeTrigger = null;
</PRE><PRE>       if (this._popper !== null) {
         this._popper.destroy();
       }
</PRE><PRE>       this._popper = null;
       this.element = null;
       this.config = null;
       this.tip = null;
     };
</PRE><PRE>     _proto.show = function show() {
       var _this = this;
</PRE><PRE>     if ($$$1(this.element).css('display') === 'none') {
         throw new Error('Please use show on visible elements');
       }
</PRE><PRE>       var showEvent = $$$1.Event(this.constructor.Event.SHOW);
</PRE><PRE>       if (this.isWithContent() &amp;&amp; this._isEnabled) {
         $$$1(this.element).trigger(showEvent);
         var isInTheDom = $$$1.contains(this.element.ownerDocument.documentElement, this.element);
</PRE><PRE>         if (showEvent.isDefaultPrevented() || !isInTheDom) {
           return;
         }
</PRE><PRE>         var tip = this.getTipElement();
         var tipId = Util.getUID(this.constructor.NAME);
         tip.setAttribute('id', tipId);
         this.element.setAttribute('aria-describedby', tipId);
         this.setContent();
</PRE><PRE>         if (this.config.animation) {
           $$$1(tip).addClass(ClassName.FADE);
         }
</PRE><PRE>         var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;
</PRE><PRE>         var attachment = this._getAttachment(placement);
</PRE><PRE>         this.addAttachmentClass(attachment);
         var container = this.config.container === false ? document.body : $$$1(document).find(this.config.container);
         $$$1(tip).data(this.constructor.DATA_KEY, this);
</PRE><PRE>         if (!$$$1.contains(this.element.ownerDocument.documentElement, this.tip)) {
           $$$1(tip).appendTo(container);
         }
</PRE><PRE>         $$$1(this.element).trigger(this.constructor.Event.INSERTED);
         this._popper = new Popper(this.element, tip, {
           placement: attachment,
           modifiers: {
             offset: {
               offset: this.config.offset
             },
             flip: {
               behavior: this.config.fallbackPlacement
             },
             arrow: {
               element: Selector.ARROW
             },
             preventOverflow: {
               boundariesElement: this.config.boundary
             }
           },
           onCreate: function onCreate(data) {
             if (data.originalPlacement !== data.placement) {
               _this._handlePopperPlacementChange(data);
             }
           },
           onUpdate: function onUpdate(data) {
             _this._handlePopperPlacementChange(data);
           }
         });
         $$$1(tip).addClass(ClassName.SHOW); // If this is a touch-enabled device we add extra
         // empty mouseover listeners to the body's immediate children;
         // only needed because of broken event delegation on iOS
         // <A rel="nofollow" class="external free" href="https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html">https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html</A></PRE><PRE>         if ('ontouchstart' in document.documentElement) {
           $$$1(document.body).children().on('mouseover', null, $$$1.noop);
         }
</PRE><PRE>         var complete = function complete() {
           if (_this.config.animation) {
             _this._fixTransition();
           }
</PRE><PRE>           var prevHoverState = _this._hoverState;
           _this._hoverState = null;
           $$$1(_this.element).trigger(_this.constructor.Event.SHOWN);
</PRE><PRE>           if (prevHoverState === HoverState.OUT) {
             _this._leave(null, _this);
           }
         };
</PRE><PRE>         if ($$$1(this.tip).hasClass(ClassName.FADE)) {
           var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
           $$$1(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
         } else {
           complete();
         }
       }
     };
</PRE><PRE>     _proto.hide = function hide(callback) {
       var _this2 = this;
</PRE><PRE>       var tip = this.getTipElement();
       var hideEvent = $$$1.Event(this.constructor.Event.HIDE);
</PRE><PRE>       var complete = function complete() {
         if (_this2._hoverState !== HoverState.SHOW &amp;&amp; tip.parentNode) {
           tip.parentNode.removeChild(tip);
         }
</PRE><PRE>         _this2._cleanTipClass();
</PRE><PRE>         _this2.element.removeAttribute('aria-describedby');
</PRE><PRE>         $$$1(_this2.element).trigger(_this2.constructor.Event.HIDDEN);
</PRE><PRE>         if (_this2._popper !== null) {
           _this2._popper.destroy();
         }
</PRE><PRE>         if (callback) {
           callback();
         }
       };
</PRE><PRE>       $$$1(this.element).trigger(hideEvent);
</PRE><PRE>       if (hideEvent.isDefaultPrevented()) {
         return;
       }
</PRE><PRE>       $$$1(tip).removeClass(ClassName.SHOW); // If this is a touch-enabled device we remove the extra
       // empty mouseover listeners we added for iOS support
</PRE><PRE>       if ('ontouchstart' in document.documentElement) {
         $$$1(document.body).children().off('mouseover', null, $$$1.noop);
       }
</PRE><PRE>       this._activeTrigger[Trigger.CLICK] = false;
       this._activeTrigger[Trigger.FOCUS] = false;
       this._activeTrigger[Trigger.HOVER] = false;
</PRE><PRE>       if ($$$1(this.tip).hasClass(ClassName.FADE)) {
         var transitionDuration = Util.getTransitionDurationFromElement(tip);
         $$$1(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
       } else {
         complete();
       }
</PRE><PRE>       this._hoverState = <I>;</I>
     };
</PRE><PRE>     _proto.update = function update() {
       if (this._popper !== null) {
         this._popper.scheduleUpdate();
       }
     }; // Protected
</PRE><PRE>     _proto.isWithContent = function isWithContent() {
       return Boolean(this.getTitle());
     };
</PRE><PRE>     _proto.addAttachmentClass = function addAttachmentClass(attachment) {
       $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
     };
</PRE><PRE>     _proto.getTipElement = function getTipElement() {
       this.tip = this.tip || $$$1(this.config.template)[0];
       return this.tip;
     };
</PRE><PRE>     _proto.setContent = function setContent() {
       var tip = this.getTipElement();
       this.setElementContent($$$1(tip.querySelectorAll(Selector.TOOLTIP_INNER)), this.getTitle());
       $$$1(tip).removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
     };
</PRE><PRE>     _proto.setElementContent = function setElementContent($element, content) {
       var html = this.config.html;
</PRE><PRE>       if (typeof content === 'object' &amp;&amp; (content.nodeType || content.jquery)) {
         // Content is a DOM node or a jQuery
         if (html) {
           if (!$$$1(content).parent().is($element)) {
             $element.empty().append(content);
           }
         } else {
           $element.text($$$1(content).text());
         }
       } else {
         $element[html ? 'html' : 'text'](content);
       }
     };
</PRE><PRE>     _proto.getTitle = function getTitle() {
       var title = this.element.getAttribute('data-original-title');
</PRE><PRE>       if (!title) {
         title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
       }
</PRE><PRE>       return title;
     }; // Private
</PRE><PRE>     _proto._getAttachment = function _getAttachment(placement) {
       return AttachmentMap[placement.toUpperCase()];
     };
</PRE><PRE>     _proto._setListeners = function _setListeners() {
       var _this3 = this;
</PRE><PRE>       var triggers = this.config.trigger.split(' ');
       triggers.forEach(function (trigger) {
         if (trigger === 'click') {
           $$$1(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
             return _this3.toggle(event);
           });
         } else if (trigger !== Trigger.MANUAL) {
           var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
           var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
           $$$1(_this3.element).on(eventIn, _this3.config.selector, function (event) {
             return _this3._enter(event);
           }).on(eventOut, _this3.config.selector, function (event) {
             return _this3._leave(event);
           });
         }
</PRE><PRE>         $$$1(_this3.element).closest('.modal').on('hide.bs.modal', function () {
           return _this3.hide();
         });
       });
</PRE><PRE>       if (this.config.selector) {
         this.config = _objectSpread({}, this.config, {
           trigger: 'manual',
           selector: 
         });
       } else {
         this._fixTitle();
       }
     };
</PRE><PRE>     _proto._fixTitle = function _fixTitle() {
       var titleType = typeof this.element.getAttribute('data-original-title');
</PRE><PRE>       if (this.element.getAttribute('title') || titleType !== 'string') {
         this.element.setAttribute('data-original-title', this.element.getAttribute('title') || <I>);</I>
         this.element.setAttribute('title', <I>);</I>
       }
     };
</PRE><PRE>     _proto._enter = function _enter(event, context) {
       var dataKey = this.constructor.DATA_KEY;
       context = context || $$$1(event.currentTarget).data(dataKey);
</PRE><PRE>       if (!context) {
         context = new this.constructor(event.currentTarget, this._getDelegateConfig());
         $$$1(event.currentTarget).data(dataKey, context);
       }
</PRE><PRE>       if (event) {
         context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
       }
</PRE><PRE>       if ($$$1(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
         context._hoverState = HoverState.SHOW;
         return;
       }
</PRE><PRE>       clearTimeout(context._timeout);
       context._hoverState = HoverState.SHOW;
</PRE><PRE>       if (!context.config.delay || !context.config.delay.show) {
         context.show();
         return;
       }
</PRE><PRE>       context._timeout = setTimeout(function () {
         if (context._hoverState === HoverState.SHOW) {
           context.show();
         }
       }, context.config.delay.show);
     };
</PRE><PRE>     _proto._leave = function _leave(event, context) {
       var dataKey = this.constructor.DATA_KEY;
       context = context || $$$1(event.currentTarget).data(dataKey);
</PRE><PRE>       if (!context) {
         context = new this.constructor(event.currentTarget, this._getDelegateConfig());
         $$$1(event.currentTarget).data(dataKey, context);
       }
</PRE><PRE>       if (event) {
         context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
       }
</PRE><PRE>       if (context._isWithActiveTrigger()) {
         return;
       }
</PRE><PRE>       clearTimeout(context._timeout);
       context._hoverState = HoverState.OUT;
</PRE><PRE>       if (!context.config.delay || !context.config.delay.hide) {
         context.hide();
         return;
       }
</PRE><PRE>       context._timeout = setTimeout(function () {
         if (context._hoverState === HoverState.OUT) {
           context.hide();
         }
       }, context.config.delay.hide);
     };
</PRE><PRE>     _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
       for (var trigger in this._activeTrigger) {
         if (this._activeTrigger[trigger]) {
           return true;
         }
       }
</PRE><PRE>       return false;
     };
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, this.constructor.Default, $$$1(this.element).data(), typeof config === 'object' &amp;&amp; config ? config : {});
</PRE><PRE>       if (typeof config.delay === 'number') {
         config.delay = {
           show: config.delay,
           hide: config.delay
         };
       }
</PRE><PRE>       if (typeof config.title === 'number') {
         config.title = config.title.toString();
       }
</PRE><PRE>       if (typeof config.content === 'number') {
         config.content = config.content.toString();
       }
</PRE><PRE>       Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
       return config;
     };
</PRE><PRE>     _proto._getDelegateConfig = function _getDelegateConfig() {
       var config = {};
</PRE><PRE>       if (this.config) {
         for (var key in this.config) {
           if (this.constructor.Default[key] !== this.config[key]) {
             config[key] = this.config[key];
           }
         }
       }
</PRE><PRE>       return config;
     };
</PRE><PRE>     _proto._cleanTipClass = function _cleanTipClass() {
       var $tip = $$$1(this.getTipElement());
       var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
</PRE><PRE>       if (tabClass !== null &amp;&amp; tabClass.length) {
         $tip.removeClass(tabClass.join(<I>));</I>
       }
     };
</PRE><PRE>     _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
       var popperInstance = popperData.instance;
       this.tip = popperInstance.popper;
</PRE><PRE>       this._cleanTipClass();
</PRE><PRE>       this.addAttachmentClass(this._getAttachment(popperData.placement));
     };
</PRE><PRE>     _proto._fixTransition = function _fixTransition() {
       var tip = this.getTipElement();
       var initConfigAnimation = this.config.animation;
</PRE><PRE>       if (tip.getAttribute('x-placement') !== null) {
         return;
       }
</PRE><PRE>       $$$1(tip).removeClass(ClassName.FADE);
       this.config.animation = false;
       this.hide();
       this.show();
       this.config.animation = initConfigAnimation;
     }; // Static
</PRE><PRE>     Tooltip._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = typeof config === 'object' &amp;&amp; config;
</PRE><PRE>         if (!data &amp;&amp; /dispose|hide/.test(config)) {
           return;
         }
</PRE><PRE>         if (!data) {
           data = new Tooltip(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config]();
         }
       });
     };
</PRE><PRE>     _createClass(Tooltip, null, [{
       key: &quot;VERSION&quot;,
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }, {
       key: &quot;NAME&quot;,
       get: function get() {
         return NAME;
       }
     }, {
       key: &quot;DATA_KEY&quot;,
       get: function get() {
         return DATA_KEY;
       }
     }, {
       key: &quot;Event&quot;,
       get: function get() {
         return Event;
       }
     }, {
       key: &quot;EVENT_KEY&quot;,
       get: function get() {
         return EVENT_KEY;
       }
     }, {
       key: &quot;DefaultType&quot;,
       get: function get() {
         return DefaultType;
       }
     }]);
</PRE><PRE>     return Tooltip;
   }();
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Tooltip._jQueryInterface;
   $$$1.fn[NAME].Constructor = Tooltip;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Tooltip._jQueryInterface;
   };
</PRE><PRE>   return Tooltip;
 }($, Popper);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): popover.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var Popover = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'popover';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.popover';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var CLASS_PREFIX = 'bs-popover';
   var BSCLS_PREFIX_REGEX = new RegExp(&quot;(^|\\s)&quot; + CLASS_PREFIX + &quot;\\S+&quot;, 'g');
</PRE><PRE>   var Default = _objectSpread({}, Tooltip.Default, {
     placement: 'right',
     trigger: 'click',
     content: <I>,</I></PRE>
      template: '<DIV class="popover">' + '' + '' + '</DIV>'
<PRE>   });
</PRE><PRE>   var DefaultType = _objectSpread({}, Tooltip.DefaultType, {
     content: '(string|element|function)'
   });
</PRE><PRE>   var ClassName = {
     FADE: 'fade',
     SHOW: 'show'
   };
   var Selector = {
     TITLE: '.popover-header',
     CONTENT: '.popover-body'
   };
   var Event = {
     HIDE: &quot;hide&quot; + EVENT_KEY,
     HIDDEN: &quot;hidden&quot; + EVENT_KEY,
     SHOW: &quot;show&quot; + EVENT_KEY,
     SHOWN: &quot;shown&quot; + EVENT_KEY,
     INSERTED: &quot;inserted&quot; + EVENT_KEY,
     CLICK: &quot;click&quot; + EVENT_KEY,
     FOCUSIN: &quot;focusin&quot; + EVENT_KEY,
     FOCUSOUT: &quot;focusout&quot; + EVENT_KEY,
     MOUSEENTER: &quot;mouseenter&quot; + EVENT_KEY,
     MOUSELEAVE: &quot;mouseleave&quot; + EVENT_KEY
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var Popover =
   /*#__PURE__*/
   function (_Tooltip) {
     _inheritsLoose(Popover, _Tooltip);
</PRE><PRE>     function Popover() {
       return _Tooltip.apply(this, arguments) || this;
     }
</PRE><PRE>     var _proto = Popover.prototype;
</PRE><PRE>     // Overrides
     _proto.isWithContent = function isWithContent() {
       return this.getTitle() || this._getContent();
     };
</PRE><PRE>     _proto.addAttachmentClass = function addAttachmentClass(attachment) {
       $$$1(this.getTipElement()).addClass(CLASS_PREFIX + &quot;-&quot; + attachment);
     };
</PRE><PRE>     _proto.getTipElement = function getTipElement() {
       this.tip = this.tip || $$$1(this.config.template)[0];
       return this.tip;
     };
</PRE><PRE>     _proto.setContent = function setContent() {
       var $tip = $$$1(this.getTipElement()); // We use append for html objects to maintain js events
</PRE><PRE>       this.setElementContent($tip.find(Selector.TITLE), this.getTitle());
</PRE><PRE>       var content = this._getContent();
</PRE><PRE>       if (typeof content === 'function') {
         content = content.call(this.element);
       }
</PRE><PRE>       this.setElementContent($tip.find(Selector.CONTENT), content);
       $tip.removeClass(ClassName.FADE + &quot; &quot; + ClassName.SHOW);
     }; // Private
</PRE><PRE>     _proto._getContent = function _getContent() {
       return this.element.getAttribute('data-content') || this.config.content;
     };
</PRE><PRE>     _proto._cleanTipClass = function _cleanTipClass() {
       var $tip = $$$1(this.getTipElement());
       var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
</PRE><PRE>       if (tabClass !== null &amp;&amp; tabClass.length &gt; 0) {
         $tip.removeClass(tabClass.join(<I>));</I>
       }
     }; // Static
</PRE><PRE>     Popover._jQueryInterface = function _jQueryInterface(config) {
       return this.each(function () {
         var data = $$$1(this).data(DATA_KEY);
</PRE><PRE>         var _config = typeof config === 'object' ? config : null;
</PRE><PRE>         if (!data &amp;&amp; /destroy|hide/.test(config)) {
           return;
         }
</PRE><PRE>         if (!data) {
           data = new Popover(this, _config);
           $$$1(this).data(DATA_KEY, data);
         }
</PRE><PRE>         if (typeof config === 'string') {
           if (typeof data[config] === 'undefined') {
             throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
           }
</PRE><PRE>           data[config]();
         }
       });
     };
</PRE><PRE>     _createClass(Popover, null, [{
       key: &quot;VERSION&quot;,
       // Getters
       get: function get() {
         return VERSION;
       }
     }, {
       key: &quot;Default&quot;,
       get: function get() {
         return Default;
       }
     }, {
       key: &quot;NAME&quot;,
       get: function get() {
         return NAME;
       }
     }, {
       key: &quot;DATA_KEY&quot;,
       get: function get() {
         return DATA_KEY;
       }
     }, {
       key: &quot;Event&quot;,
       get: function get() {
         return Event;
       }
     }, {
       key: &quot;EVENT_KEY&quot;,
       get: function get() {
         return EVENT_KEY;
       }
     }, {
       key: &quot;DefaultType&quot;,
       get: function get() {
         return DefaultType;
       }
     }]);
</PRE><PRE>     return Popover;
   }(Tooltip);
   /**
    * ------------------------------------------------------------------------
    * jQuery
    * ------------------------------------------------------------------------
    */
</PRE><PRE>   $$$1.fn[NAME] = Popover._jQueryInterface;
   $$$1.fn[NAME].Constructor = Popover;
</PRE><PRE>   $$$1.fn[NAME].noConflict = function () {
     $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
     return Popover._jQueryInterface;
   };
</PRE><PRE>   return Popover;
 }($);
</PRE><PRE> /**
  * --------------------------------------------------------------------------
  * Bootstrap (v4.1.3): scrollspy.js
  * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
  * --------------------------------------------------------------------------
  */
</PRE><PRE> var ScrollSpy = function ($$$1) {
   /**
    * ------------------------------------------------------------------------
    * Constants
    * ------------------------------------------------------------------------
    */
   var NAME = 'scrollspy';
   var VERSION = '4.1.3';
   var DATA_KEY = 'bs.scrollspy';
   var EVENT_KEY = &quot;.&quot; + DATA_KEY;
   var DATA_API_KEY = '.data-api';
   var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
   var Default = {
     offset: 10,
     method: 'auto',
     target: 
   };
   var DefaultType = {
     offset: 'number',
     method: 'string',
     target: '(string|element)'
   };
   var Event = {
     ACTIVATE: &quot;activate&quot; + EVENT_KEY,
     SCROLL: &quot;scroll&quot; + EVENT_KEY,
     LOAD_DATA_API: &quot;load&quot; + EVENT_KEY + DATA_API_KEY
   };
   var ClassName = {
     DROPDOWN_ITEM: 'dropdown-item',
     DROPDOWN_MENU: 'dropdown-menu',
     ACTIVE: 'active'
   };
   var Selector = {
     DATA_SPY: '[data-spy=&quot;scroll&quot;]',
     ACTIVE: '.active',
     NAV_LIST_GROUP: '.nav, .list-group',
     NAV_LINKS: '.nav-link',
     NAV_ITEMS: '.nav-item',
     LIST_ITEMS: '.list-group-item',
     DROPDOWN: '.dropdown',
     DROPDOWN_ITEMS: '.dropdown-item',
     DROPDOWN_TOGGLE: '.dropdown-toggle'
   };
   var OffsetMethod = {
     OFFSET: 'offset',
     POSITION: 'position'
     /**
      * ------------------------------------------------------------------------
      * Class Definition
      * ------------------------------------------------------------------------
      */
</PRE><PRE>   };
</PRE><PRE>   var ScrollSpy =
   /*#__PURE__*/
   function () {
     function ScrollSpy(element, config) {
       var _this = this;
</PRE><PRE>       this._element = element;
       this._scrollElement = element.tagName === 'BODY' ? window : element;
       this._config = this._getConfig(config);
       this._selector = this._config.target + &quot; &quot; + Selector.NAV_LINKS + &quot;,&quot; + (this._config.target + &quot; &quot; + Selector.LIST_ITEMS + &quot;,&quot;) + (this._config.target + &quot; &quot; + Selector.DROPDOWN_ITEMS);
       this._offsets = [];
       this._targets = [];
       this._activeTarget = null;
       this._scrollHeight = 0;
       $$$1(this._scrollElement).on(Event.SCROLL, function (event) {
         return _this._process(event);
       });
       this.refresh();
</PRE><PRE>       this._process();
     } // Getters
</PRE><PRE>     var _proto = ScrollSpy.prototype;
</PRE><PRE>     // Public
     _proto.refresh = function refresh() {
       var _this2 = this;
</PRE><PRE>       var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
       var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
       var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
       this._offsets = [];
       this._targets = [];
       this._scrollHeight = this._getScrollHeight();
       var targets = [].slice.call(document.querySelectorAll(this._selector));
       targets.map(function (element) {
         var target;
         var targetSelector = Util.getSelectorFromElement(element);
</PRE><PRE>         if (targetSelector) {
           target = document.querySelector(targetSelector);
         }
</PRE><PRE>         if (target) {
           var targetBCR = target.getBoundingClientRect();
</PRE><PRE>           if (targetBCR.width || targetBCR.height) {
             // TODO (fat): remove sketch reliance on jQuery position/offset
             return [$$$1(target)[offsetMethod]().top + offsetBase, targetSelector];
           }
         }
</PRE><PRE>         return null;
       }).filter(function (item) {
         return item;
       }).sort(function (a, b) {
         return a[0] - b[0];
       }).forEach(function (item) {
         _this2._offsets.push(item[0]);
</PRE><PRE>         _this2._targets.push(item[1]);
       });
     };
</PRE><PRE>     _proto.dispose = function dispose() {
       $$$1.removeData(this._element, DATA_KEY);
       $$$1(this._scrollElement).off(EVENT_KEY);
       this._element = null;
       this._scrollElement = null;
       this._config = null;
       this._selector = null;
       this._offsets = null;
       this._targets = null;
       this._activeTarget = null;
       this._scrollHeight = null;
     }; // Private
</PRE><PRE>     _proto._getConfig = function _getConfig(config) {
       config = _objectSpread({}, Default, typeof config === 'object' &amp;&amp; config ? config : {});
</PRE><PRE>       if (typeof config.target !== 'string') {
         var id = $$$1(config.target).attr('id');
</PRE><PRE>         if (!id) {
           id = Util.getUID(NAME);
           $$$1(config.target).attr('id', id);
         }
</PRE><PRE>         config.target = &quot;#&quot; + id;
       }
</PRE><PRE>       Util.typeCheckConfig(NAME, config, DefaultType);
       return config;
     };
</PRE><PRE>     _proto._getScrollTop = function _getScrollTop() {
       return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
     };
</PRE><PRE>     _proto._getScrollHeight = function _getScrollHeight() {
       return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
     };
</PRE><PRE>     _proto._getOffsetHeight = function _getOffsetHeight() {
       return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
     };
</PRE><PRE>     _proto._process = function _process() {
       var scrollTop = this._getScrollTop() + this._config.offset;
</PRE><PRE>       var scrollHeight = this._getScrollHeight();
</PRE><PRE>       var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
</PRE><PRE>       if (this._scrollHeight !== scrollHeight) {
         this.refresh();
       }
</PRE><PRE>       if (scrollTop &gt;= maxScroll) {
         var target = this._targets[this._targets.length - 1];
</PRE><PRE>         if (this._activeTarget !== target) {
           this._activate(target);
         }
</PRE><PRE>         return;
       }
</PRE><PRE>       if (this._activeTarget &amp;&amp; scrollTop &lt; this._offsets[0] &amp;&amp; this._offsets[0] &gt; 0) {
         this._activeTarget = null;
</PRE><PRE>         this._clear();
</PRE><PRE>         return;
       }
</PRE><PRE>       var offsetLength = this._offsets.length;
</PRE><PRE>       for (var i = offsetLength; i--;) {
         var isActiveTarget = this._activeTarget !== this._targets[i] &amp;&amp; scrollTop &gt;= this._offsets[i] &amp;&amp; (typeof this._offsets[i + 1] === 'undefined' || scrollTop &lt; this._offsets[i + 1]);
</PRE><PRE>         if (isActiveTarget) {
           this._activate(this._targets[i]);
         }
       }
     };
</PRE><PRE>     _proto._activate = function _activate(target) {
       this._activeTarget = target;
</PRE><PRE>       this._clear();
</PRE><PRE>       var queries = this._selector.split(','); // eslint-disable-next-line arrow-body-style
</PRE><PRE>       queries = queries.map(function (selector) {
         return selector + &quot;[data-target=\&quot;&quot; + target + &quot;\&quot;],&quot; + (selector + &quot;[href=\&quot;&quot; + target + &quot;\&quot;]&quot;);
       });
       var $link = $$$1([].slice.call(document.querySelectorAll(queries.join(','))));
</PRE><PRE>       if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
         $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
         $link.addClass(ClassName.ACTIVE);
       } else {
         // Set triggered link as active
         $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active
</PRE>
          // With both <UL> and &lt;nav&gt; markup a parent is the previous sibling of any nav ancestor

          $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + &quot;, &quot; + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item

          $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
        }

        $$$1(this._scrollElement).trigger(Event.ACTIVATE, {
          relatedTarget: target
        });
      };

      _proto._clear = function _clear() {
        var nodes = [].slice.call(document.querySelectorAll(this._selector));
        $$$1(nodes).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
      }; // Static


      ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $$$1(this).data(DATA_KEY);

          var _config = typeof config === 'object' &amp;&amp; config;

          if (!data) {
            data = new ScrollSpy(this, _config);
            $$$1(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
            }

            data[config]();
          }
        });
      };

      _createClass(ScrollSpy, null, [{
        key: &quot;VERSION&quot;,
        get: function get() {
          return VERSION;
        }
      }, {
        key: &quot;Default&quot;,
        get: function get() {
          return Default;
        }
      }]);

      return ScrollSpy;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(window).on(Event.LOAD_DATA_API, function () {
      var scrollSpys = [].slice.call(document.querySelectorAll(Selector.DATA_SPY));
      var scrollSpysLength = scrollSpys.length;

      for (var i = scrollSpysLength; i--;) {
        var $spy = $$$1(scrollSpys[i]);

        ScrollSpy._jQueryInterface.call($spy, $spy.data());
      }
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = ScrollSpy._jQueryInterface;
    $$$1.fn[NAME].Constructor = ScrollSpy;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return ScrollSpy._jQueryInterface;
    };

    return ScrollSpy;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.3): tab.js
   * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
   * --------------------------------------------------------------------------
   */

  var Tab = function ($$$1) {
    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */
    var NAME = 'tab';
    var VERSION = '4.1.3';
    var DATA_KEY = 'bs.tab';
    var EVENT_KEY = &quot;.&quot; + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
    var Event = {
      HIDE: &quot;hide&quot; + EVENT_KEY,
      HIDDEN: &quot;hidden&quot; + EVENT_KEY,
      SHOW: &quot;show&quot; + EVENT_KEY,
      SHOWN: &quot;shown&quot; + EVENT_KEY,
      CLICK_DATA_API: &quot;click&quot; + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active',
      DISABLED: 'disabled',
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector = {
      DROPDOWN: '.dropdown',
      NAV_LIST_GROUP: '.nav, .list-group',
      ACTIVE: '.active',
      ACTIVE_UL: '&gt; li &gt; .active',
      DATA_TOGGLE: '[data-toggle=&quot;tab&quot;], [data-toggle=&quot;pill&quot;], [data-toggle=&quot;list&quot;]',
      DROPDOWN_TOGGLE: '.dropdown-toggle',
      DROPDOWN_ACTIVE_CHILD: '&gt; .dropdown-menu .active'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Tab =
    /*#__PURE__*/
    function () {
      function Tab(element) {
        this._element = element;
      } // Getters


      var _proto = Tab.prototype;

      // Public
      _proto.show = function show() {
        var _this = this;

        if (this._element.parentNode &amp;&amp; this._element.parentNode.nodeType === Node.ELEMENT_NODE &amp;&amp; $$$1(this._element).hasClass(ClassName.ACTIVE) || $$$1(this._element).hasClass(ClassName.DISABLED)) {
          return;
        }

        var target;
        var previous;
        var listElement = $$$1(this._element).closest(Selector.NAV_LIST_GROUP)[0];
        var selector = Util.getSelectorFromElement(this._element);

        if (listElement) {
          var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;
          previous = $$$1.makeArray($$$1(listElement).find(itemSelector));
          previous = previous[previous.length - 1];
        }

        var hideEvent = $$$1.Event(Event.HIDE, {
          relatedTarget: this._element
        });
        var showEvent = $$$1.Event(Event.SHOW, {
          relatedTarget: previous
        });

        if (previous) {
          $$$1(previous).trigger(hideEvent);
        }

        $$$1(this._element).trigger(showEvent);

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
          return;
        }

        if (selector) {
          target = document.querySelector(selector);
        }

        this._activate(this._element, listElement);

        var complete = function complete() {
          var hiddenEvent = $$$1.Event(Event.HIDDEN, {
            relatedTarget: _this._element
          });
          var shownEvent = $$$1.Event(Event.SHOWN, {
            relatedTarget: previous
          });
          $$$1(previous).trigger(hiddenEvent);
          $$$1(_this._element).trigger(shownEvent);
        };

        if (target) {
          this._activate(target, target.parentNode, complete);
        } else {
          complete();
        }
      };

      _proto.dispose = function dispose() {
        $$$1.removeData(this._element, DATA_KEY);
        this._element = null;
      }; // Private


      _proto._activate = function _activate(element, container, callback) {
        var _this2 = this;

        var activeElements;

        if (container.nodeName === 'UL') {
          activeElements = $$$1(container).find(Selector.ACTIVE_UL);
        } else {
          activeElements = $$$1(container).children(Selector.ACTIVE);
        }

        var active = activeElements[0];
        var isTransitioning = callback &amp;&amp; active &amp;&amp; $$$1(active).hasClass(ClassName.FADE);

        var complete = function complete() {
          return _this2._transitionComplete(element, active, callback);
        };

        if (active &amp;&amp; isTransitioning) {
          var transitionDuration = Util.getTransitionDurationFromElement(active);
          $$$1(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      };

      _proto._transitionComplete = function _transitionComplete(element, active, callback) {
        if (active) {
          $$$1(active).removeClass(ClassName.SHOW + &quot; &quot; + ClassName.ACTIVE);
          var dropdownChild = $$$1(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

          if (dropdownChild) {
            $$$1(dropdownChild).removeClass(ClassName.ACTIVE);
          }

          if (active.getAttribute('role') === 'tab') {
            active.setAttribute('aria-selected', false);
          }
        }

        $$$1(element).addClass(ClassName.ACTIVE);

        if (element.getAttribute('role') === 'tab') {
          element.setAttribute('aria-selected', true);
        }

        Util.reflow(element);
        $$$1(element).addClass(ClassName.SHOW);

        if (element.parentNode &amp;&amp; $$$1(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
          var dropdownElement = $$$1(element).closest(Selector.DROPDOWN)[0];

          if (dropdownElement) {
            var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector.DROPDOWN_TOGGLE));
            $$$1(dropdownToggleList).addClass(ClassName.ACTIVE);
          }

          element.setAttribute('aria-expanded', true);
        }

        if (callback) {
          callback();
        }
      }; // Static


      Tab._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $$$1(this);
          var data = $this.data(DATA_KEY);

          if (!data) {
            data = new Tab(this);
            $this.data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError(&quot;No method named \&quot;&quot; + config + &quot;\&quot;&quot;);
            }

            data[config]();
          }
        });
      };

      _createClass(Tab, null, [{
        key: &quot;VERSION&quot;,
        get: function get() {
          return VERSION;
        }
      }]);

      return Tab;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
      event.preventDefault();

      Tab._jQueryInterface.call($$$1(this), 'show');
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $$$1.fn[NAME] = Tab._jQueryInterface;
    $$$1.fn[NAME].Constructor = Tab;

    $$$1.fn[NAME].noConflict = function () {
      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
      return Tab._jQueryInterface;
    };

    return Tab;
  }($);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.1.3): index.js
   * Licensed under MIT (<A rel="nofollow" class="external free" href="https://github.com/twbs/bootstrap/blob/master/LICENSE">https://github.com/twbs/bootstrap/blob/master/LICENSE</A>)
   * --------------------------------------------------------------------------
   */

  (function ($$$1) {
    if (typeof $$$1 === 'undefined') {
      throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
    }

    var version = $$$1.fn.jquery.split(' ')[0].split('.');
    var minMajor = 1;
    var ltMajor = 2;
    var minMinor = 9;
    var minPatch = 1;
    var maxMajor = 4;

    if (version[0] &lt; ltMajor &amp;&amp; version[1] &lt; minMinor || version[0] === minMajor &amp;&amp; version[1] === minMinor &amp;&amp; version[2] &lt; minPatch || version[0] &gt;= maxMajor) {
      throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
    }
  })($);

  exports.Util = Util;
  exports.Alert = Alert;
  exports.Button = Button;
  exports.Carousel = Carousel;
  exports.Collapse = Collapse;
  exports.Dropdown = Dropdown;
  exports.Modal = Modal;
  exports.Popover = Popover;
  exports.Scrollspy = ScrollSpy;
  exports.Tab = Tab;
  exports.Tooltip = Tooltip;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=bootstrap.js.map</UL></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
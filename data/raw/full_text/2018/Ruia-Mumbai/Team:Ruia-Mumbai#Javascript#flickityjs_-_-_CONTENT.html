<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Ruia-Mumbai_Javascript_flickityjs skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Ruia-Mumbai/Javascript/flickityjs</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE>* Flickity PACKAGED v2.1.2
* Touch, responsive, flickable carousels
*
* Licensed GPLv3 for open source use
* or Flickity Commercial License for commercial use
*
* <A rel="nofollow" class="external free" href="https://flickity.metafizzy.co">https://flickity.metafizzy.co</A>
* Copyright 2015-2018 Metafizzy
*/
</PRE><P>/**
</P><PRE>* Bridget makes jQuery widgets
* v2.0.1
* MIT license
*/
</PRE><P>/* jshint browser: true, strict: true, undef: true, unused: true */
</P><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /*jshint strict: false */ /* globals define, module, require */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'jquery-bridget/jquery-bridget',[ 'jquery' ], function( jQuery ) {
     return factory( window, jQuery );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('jquery')
   );
 } else {
   // browser global
   window.jQueryBridget = factory(
     window,
     window.jQuery
   );
 }
</PRE><P>}( window, function factory( window, jQuery ) {
'use strict';
</P><P>// ----- utils ----- //
</P><P>var arraySlice = Array.prototype.slice;
</P><P>// helper function for logging errors
// $.error breaks jQuery chaining
var console = window.console;
var logError = typeof console == 'undefined' ? function() {} :
</P><PRE> function( message ) {
   console.error( message );
 };
</PRE><P>// ----- jQueryBridget ----- //
</P><P>function jQueryBridget( namespace, PluginClass, $ ) {
</P><PRE> $ = $ || jQuery || window.jQuery;
 if ( !$ ) {
   return;
 }
</PRE><PRE> // add option method -&gt; $().plugin('option', {...})
 if ( !PluginClass.prototype.option ) {
   // option setter
   PluginClass.prototype.option = function( opts ) {
     // bail out if not an object
     if ( !$.isPlainObject( opts ) ){
       return;
     }
     this.options = $.extend( true, this.options, opts );
   };
 }
</PRE><PRE> // make jQuery plugin
 $.fn[ namespace ] = function( arg0 /*, arg1 */ ) {
   if ( typeof arg0 == 'string' ) {
     // method call $().plugin( 'methodName', { options } )
     // shift arguments by 1
     var args = arraySlice.call( arguments, 1 );
     return methodCall( this, arg0, args );
   }
   // just $().plugin({ options })
   plainCall( this, arg0 );
   return this;
 };
</PRE><PRE> // $().plugin('methodName')
 function methodCall( $elems, methodName, args ) {
   var returnValue;
   var pluginMethodStr = '$().' + namespace + '(&quot;' + methodName + '&quot;)';
</PRE><PRE>   $elems.each( function( i, elem ) {
     // get instance
     var instance = $.data( elem, namespace );
     if ( !instance ) {
       logError( namespace + ' not initialized. Cannot call methods, i.e. ' +
         pluginMethodStr );
       return;
     }
</PRE><PRE>     var method = instance[ methodName ];
     if ( !method || methodName.charAt(0) == '_' ) {
       logError( pluginMethodStr + ' is not a valid method' );
       return;
     }
</PRE><PRE>     // apply method, get return value
     var value = method.apply( instance, args );
     // set return value if value is returned, use only first value
     returnValue = returnValue === undefined ? value : returnValue;
   });
</PRE><PRE>   return returnValue !== undefined ? returnValue : $elems;
 }
</PRE><PRE> function plainCall( $elems, options ) {
   $elems.each( function( i, elem ) {
     var instance = $.data( elem, namespace );
     if ( instance ) {
       // set options &amp; init
       instance.option( options );
       instance._init();
     } else {
       // initialize new instance
       instance = new PluginClass( elem, options );
       $.data( elem, namespace, instance );
     }
   });
 }
</PRE><PRE> updateJQuery( $ );
</PRE><P>}
</P><P>// ----- updateJQuery ----- //
</P><P>// set $.bridget for v1 backwards compatibility
function updateJQuery( $ ) {
</P><PRE> if ( !$ || ( $ &amp;&amp; $.bridget ) ) {
   return;
 }
 $.bridget = jQueryBridget;
</PRE><P>}
</P><P>updateJQuery( jQuery || window.jQuery );
</P><P>// -----  ----- //
</P><P>return jQueryBridget;
</P><P>}));
</P><P>/**
</P><PRE>* EvEmitter v1.1.0
* Lil' event emitter
* MIT License
*/
</PRE><P>/* jshint unused: true, undef: true, strict: true */
</P><P>( function( global, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */ /* globals define, module, window */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD - RequireJS
   define( 'ev-emitter/ev-emitter',factory );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS - Browserify, Webpack
   module.exports = factory();
 } else {
   // Browser globals
   global.EvEmitter = factory();
 }
</PRE><P>}( typeof window != 'undefined' ? window : this, function() {
</P><P>function EvEmitter() {}
</P><P>var proto = EvEmitter.prototype;
</P><P>proto.on = function( eventName, listener ) {
</P><PRE> if ( !eventName || !listener ) {
   return;
 }
 // set events hash
 var events = this._events = this._events || {};
 // set listeners array
 var listeners = events[ eventName ] = events[ eventName ] || [];
 // only add once
 if ( listeners.indexOf( listener ) == -1 ) {
   listeners.push( listener );
 }
</PRE><PRE> return this;
</PRE><P>};
</P><P>proto.once = function( eventName, listener ) {
</P><PRE> if ( !eventName || !listener ) {
   return;
 }
 // add event
 this.on( eventName, listener );
 // set once flag
 // set onceEvents hash
 var onceEvents = this._onceEvents = this._onceEvents || {};
 // set onceListeners object
 var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
 // set flag
 onceListeners[ listener ] = true;
</PRE><PRE> return this;
</PRE><P>};
</P><P>proto.off = function( eventName, listener ) {
</P><PRE> var listeners = this._events &amp;&amp; this._events[ eventName ];
 if ( !listeners || !listeners.length ) {
   return;
 }
 var index = listeners.indexOf( listener );
 if ( index != -1 ) {
   listeners.splice( index, 1 );
 }
</PRE><PRE> return this;
</PRE><P>};
</P><P>proto.emitEvent = function( eventName, args ) {
</P><PRE> var listeners = this._events &amp;&amp; this._events[ eventName ];
 if ( !listeners || !listeners.length ) {
   return;
 }
 // copy over to avoid interference if .off() in listener
 listeners = listeners.slice(0);
 args = args || [];
 // once stuff
 var onceListeners = this._onceEvents &amp;&amp; this._onceEvents[ eventName ];
</PRE><PRE> for ( var i=0; i &lt; listeners.length; i++ ) {
   var listener = listeners[i]
   var isOnce = onceListeners &amp;&amp; onceListeners[ listener ];
   if ( isOnce ) {
     // remove listener
     // remove before trigger to prevent recursion
     this.off( eventName, listener );
     // unset once flag
     delete onceListeners[ listener ];
   }
   // trigger listener
   listener.apply( this, args );
 }
</PRE><PRE> return this;
</PRE><P>};
</P><P>proto.allOff = function() {
</P><PRE> delete this._events;
 delete this._onceEvents;
</PRE><P>};
</P><P>return EvEmitter;
</P><P>}));
</P><P>/*!
</P><PRE>* getSize v2.0.3
* measure size of elements
* MIT license
*/
</PRE><P>/* jshint browser: true, strict: true, undef: true, unused: true */
/* globals console: false */
</P><P>( function( window, factory ) {
</P><PRE> /* jshint strict: false */ /* globals define, module */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'get-size/get-size',factory );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory();
 } else {
   // browser global
   window.getSize = factory();
 }
</PRE><P>})( window, function factory() {
'use strict';
</P><P>// -------------------------- helpers -------------------------- //
</P><P>// get a number from a string, not a percentage
function getStyleSize( value ) {
</P><PRE> var num = parseFloat( value );
 // not a percent like '100%', and a number
 var isValid = value.indexOf('%') == -1 &amp;&amp; !isNaN( num );
 return isValid &amp;&amp; num;
</PRE><P>}
</P><P>function noop() {}
</P><P>var logError = typeof console == 'undefined' ? noop :
</P><PRE> function( message ) {
   console.error( message );
 };
</PRE><P>// -------------------------- measurements -------------------------- //
</P><P>var measurements = [
</P><PRE> 'paddingLeft',
 'paddingRight',
 'paddingTop',
 'paddingBottom',
 'marginLeft',
 'marginRight',
 'marginTop',
 'marginBottom',
 'borderLeftWidth',
 'borderRightWidth',
 'borderTopWidth',
 'borderBottomWidth'
</PRE><P>];
</P><P>var measurementsLength = measurements.length;
</P><P>function getZeroSize() {
</P><PRE> var size = {
   width: 0,
   height: 0,
   innerWidth: 0,
   innerHeight: 0,
   outerWidth: 0,
   outerHeight: 0
 };
 for ( var i=0; i &lt; measurementsLength; i++ ) {
   var measurement = measurements[i];
   size[ measurement ] = 0;
 }
 return size;
</PRE><P>}
</P><P>// -------------------------- getStyle -------------------------- //
</P><P>/**
</P><PRE>* getStyle, get style of element, check for Firefox bug
* <A rel="nofollow" class="external free" href="https://bugzilla.mozilla.org/show_bug.cgi?id=548397">https://bugzilla.mozilla.org/show_bug.cgi?id=548397</A>
*/
</PRE><P>function getStyle( elem ) {
</P><PRE> var style = getComputedStyle( elem );
 if ( !style ) {
   logError( 'Style returned ' + style +
     '. Are you running this code in a hidden iframe on Firefox? ' +
     'See <A rel="nofollow" class="external free" href="https://bit.ly/getsizebug1'">https://bit.ly/getsizebug1'</A> );
 }
 return style;
</PRE><P>}
</P><P>// -------------------------- setup -------------------------- //
</P><P>var isSetup = false;
</P><P>var isBoxSizeOuter;
</P><P>/**
</P><PRE>* setup
* check isBoxSizerOuter
* do on first getSize() rather than on page load for Firefox bug
*/
</PRE><P>function setup() {
</P><PRE> // setup once
 if ( isSetup ) {
   return;
 }
 isSetup = true;
</PRE><PRE> // -------------------------- box sizing -------------------------- //
</PRE><PRE> /**
  * Chrome &amp; Safari measure the outer-width on style.width on border-box elems
  * IE11 &amp; Firefox&lt;29 measures the inner-width
  */
 var div = document.createElement('div');
 div.style.width = '200px';
 div.style.padding = '1px 2px 3px 4px';
 div.style.borderStyle = 'solid';
 div.style.borderWidth = '1px 2px 3px 4px';
 div.style.boxSizing = 'border-box';
</PRE><PRE> var body = document.body || document.documentElement;
 body.appendChild( div );
 var style = getStyle( div );
 // round value for browser zoom. desandro/masonry#928
 isBoxSizeOuter = Math.round( getStyleSize( style.width ) ) == 200;
 getSize.isBoxSizeOuter = isBoxSizeOuter;
</PRE><PRE> body.removeChild( div );
</PRE><P>}
</P><P>// -------------------------- getSize -------------------------- //
</P><P>function getSize( elem ) {
</P><PRE> setup();
</PRE><PRE> // use querySeletor if elem is string
 if ( typeof elem == 'string' ) {
   elem = document.querySelector( elem );
 }
</PRE><PRE> // do not proceed on non-objects
 if ( !elem || typeof elem != 'object' || !elem.nodeType ) {
   return;
 }
</PRE><PRE> var style = getStyle( elem );
</PRE><PRE> // if hidden, everything is 0
 if ( style.display == 'none' ) {
   return getZeroSize();
 }
</PRE><PRE> var size = {};
 size.width = elem.offsetWidth;
 size.height = elem.offsetHeight;
</PRE><PRE> var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';
</PRE><PRE> // get all measurements
 for ( var i=0; i &lt; measurementsLength; i++ ) {
   var measurement = measurements[i];
   var value = style[ measurement ];
   var num = parseFloat( value );
   // any 'auto', 'medium' value will be 0
   size[ measurement ] = !isNaN( num ) ? num : 0;
 }
</PRE><PRE> var paddingWidth = size.paddingLeft + size.paddingRight;
 var paddingHeight = size.paddingTop + size.paddingBottom;
 var marginWidth = size.marginLeft + size.marginRight;
 var marginHeight = size.marginTop + size.marginBottom;
 var borderWidth = size.borderLeftWidth + size.borderRightWidth;
 var borderHeight = size.borderTopWidth + size.borderBottomWidth;
</PRE><PRE> var isBorderBoxSizeOuter = isBorderBox &amp;&amp; isBoxSizeOuter;
</PRE><PRE> // overwrite width and height if we can get it from style
 var styleWidth = getStyleSize( style.width );
 if ( styleWidth !== false ) {
   size.width = styleWidth +
     // add padding and border unless it's already including it
     ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
 }
</PRE><PRE> var styleHeight = getStyleSize( style.height );
 if ( styleHeight !== false ) {
   size.height = styleHeight +
     // add padding and border unless it's already including it
     ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
 }
</PRE><PRE> size.innerWidth = size.width - ( paddingWidth + borderWidth );
 size.innerHeight = size.height - ( paddingHeight + borderHeight );
</PRE><PRE> size.outerWidth = size.width + marginWidth;
 size.outerHeight = size.height + marginHeight;
</PRE><PRE> return size;
</PRE><P>}
</P><P>return getSize;
</P><P>});
</P><P>/**
</P><PRE>* matchesSelector v2.0.2
* matchesSelector( element, '.selector' )
* MIT license
*/
</PRE><P>/*jshint browser: true, strict: true, undef: true, unused: true */
</P><P>( function( window, factory ) {
</P><PRE> /*global define: false, module: false */
 'use strict';
 // universal module definition
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'desandro-matches-selector/matches-selector',factory );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory();
 } else {
   // browser global
   window.matchesSelector = factory();
 }
</PRE><P>}( window, function factory() {
</P><PRE> 'use strict';
</PRE><PRE> var matchesMethod = ( function() {
   var ElemProto = window.Element.prototype;
   // check for the standard method name first
   if ( ElemProto.matches ) {
     return 'matches';
   }
   // check un-prefixed
   if ( ElemProto.matchesSelector ) {
     return 'matchesSelector';
   }
   // check vendor prefixes
   var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];
</PRE><PRE>   for ( var i=0; i &lt; prefixes.length; i++ ) {
     var prefix = prefixes[i];
     var method = prefix + 'MatchesSelector';
     if ( ElemProto[ method ] ) {
       return method;
     }
   }
 })();
</PRE><PRE> return function matchesSelector( elem, selector ) {
   return elem[ matchesMethod ]( selector );
 };
</PRE><P>}));
</P><P>/**
</P><PRE>* Fizzy UI utils v2.0.7
* MIT license
*/
</PRE><P>/*jshint browser: true, undef: true, unused: true, strict: true */
</P><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /*jshint strict: false */ /*globals define, module, require */
</PRE><PRE> if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'fizzy-ui-utils/utils',[
     'desandro-matches-selector/matches-selector'
   ], function( matchesSelector ) {
     return factory( window, matchesSelector );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('desandro-matches-selector')
   );
 } else {
   // browser global
   window.fizzyUIUtils = factory(
     window,
     window.matchesSelector
   );
 }
</PRE><P>}( window, function factory( window, matchesSelector ) {
</P><P>var utils = {};
</P><P>// ----- extend ----- //
</P><P>// extends objects
utils.extend = function( a, b ) {
</P><PRE> for ( var prop in b ) {
   a[ prop ] = b[ prop ];
 }
 return a;
</PRE><P>};
</P><P>// ----- modulo ----- //
</P><P>utils.modulo = function( num, div ) {
</P><PRE> return ( ( num % div ) + div ) % div;
</PRE><P>};
</P><P>// ----- makeArray ----- //
</P><P>var arraySlice = Array.prototype.slice;
</P><P>// turn element or nodeList into an array
utils.makeArray = function( obj ) {
</P><PRE> if ( Array.isArray( obj ) ) {
   // use object if already an array
   return obj;
 }
 // return empty array if undefined or null. #6
 if ( obj === null || obj === undefined ) {
   return [];
 }
</PRE><PRE> var isArrayLike = typeof obj == 'object' &amp;&amp; typeof obj.length == 'number';
 if ( isArrayLike ) {
   // convert nodeList to array
   return arraySlice.call( obj );
 }
</PRE><PRE> // array of single index
 return [ obj ];
</PRE><P>};
</P><P>// ----- removeFrom ----- //
</P><P>utils.removeFrom = function( ary, obj ) {
</P><PRE> var index = ary.indexOf( obj );
 if ( index != -1 ) {
   ary.splice( index, 1 );
 }
</PRE><P>};
</P><P>// ----- getParent ----- //
</P><P>utils.getParent = function( elem, selector ) {
</P><PRE> while ( elem.parentNode &amp;&amp; elem != document.body ) {
   elem = elem.parentNode;
   if ( matchesSelector( elem, selector ) ) {
     return elem;
   }
 }
</PRE><P>};
</P><P>// ----- getQueryElement ----- //
</P><P>// use element as selector string
utils.getQueryElement = function( elem ) {
</P><PRE> if ( typeof elem == 'string' ) {
   return document.querySelector( elem );
 }
 return elem;
</PRE><P>};
</P><P>// ----- handleEvent ----- //
</P><P>// enable .ontype to trigger from .addEventListener( elem, 'type' )
utils.handleEvent = function( event ) {
</P><PRE> var method = 'on' + event.type;
 if ( this[ method ] ) {
   this[ method ]( event );
 }
</PRE><P>};
</P><P>// ----- filterFindElements ----- //
</P><P>utils.filterFindElements = function( elems, selector ) {
</P><PRE> // make array of elems
 elems = utils.makeArray( elems );
 var ffElems = [];
</PRE><PRE> elems.forEach( function( elem ) {
   // check that elem is an actual element
   if ( !( elem instanceof HTMLElement ) ) {
     return;
   }
   // add elem if no selector
   if ( !selector ) {
     ffElems.push( elem );
     return;
   }
   // filter &amp; find items if we have a selector
   // filter
   if ( matchesSelector( elem, selector ) ) {
     ffElems.push( elem );
   }
   // find children
   var childElems = elem.querySelectorAll( selector );
   // concat childElems to filterFound array
   for ( var i=0; i &lt; childElems.length; i++ ) {
     ffElems.push( childElems[i] );
   }
 });
</PRE><PRE> return ffElems;
</PRE><P>};
</P><P>// ----- debounceMethod ----- //
</P><P>utils.debounceMethod = function( _class, methodName, threshold ) {
</P><PRE> threshold = threshold || 100;
 // original method
 var method = _class.prototype[ methodName ];
 var timeoutName = methodName + 'Timeout';
</PRE><PRE> _class.prototype[ methodName ] = function() {
   var timeout = this[ timeoutName ];
   clearTimeout( timeout );
</PRE><PRE>   var args = arguments;
   var _this = this;
   this[ timeoutName ] = setTimeout( function() {
     method.apply( _this, args );
     delete _this[ timeoutName ];
   }, threshold );
 };
</PRE><P>};
</P><P>// ----- docReady ----- //
</P><P>utils.docReady = function( callback ) {
</P><PRE> var readyState = document.readyState;
 if ( readyState == 'complete' || readyState == 'interactive' ) {
   // do async to allow for other scripts to run. metafizzy/flickity#441
   setTimeout( callback );
 } else {
   document.addEventListener( 'DOMContentLoaded', callback );
 }
</PRE><P>};
</P><P>// ----- htmlInit ----- //
</P><P>// <A rel="nofollow" class="external free" href="http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/">http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/</A>
utils.toDashed = function( str ) {
</P><PRE> return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
   return $1 + '-' + $2;
 }).toLowerCase();
</PRE><P>};
</P><P>var console = window.console;
/**
</P><PRE>* allow user to initialize classes via [data-namespace] or .js-namespace class
* htmlInit( Widget, 'widgetName' )
* options are parsed from data-namespace-options
*/
</PRE><P>utils.htmlInit = function( WidgetClass, namespace ) {
</P><PRE> utils.docReady( function() {
   var dashedNamespace = utils.toDashed( namespace );
   var dataAttr = 'data-' + dashedNamespace;
   var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );
   var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );
   var elems = utils.makeArray( dataAttrElems )
     .concat( utils.makeArray( jsDashElems ) );
   var dataOptionsAttr = dataAttr + '-options';
   var jQuery = window.jQuery;
</PRE><PRE>   elems.forEach( function( elem ) {
     var attr = elem.getAttribute( dataAttr ) ||
       elem.getAttribute( dataOptionsAttr );
     var options;
     try {
       options = attr &amp;&amp; JSON.parse( attr );
     } catch ( error ) {
       // log error, do not initialize
       if ( console ) {
         console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +
         ': ' + error );
       }
       return;
     }
     // initialize
     var instance = new WidgetClass( elem, options );
     // make available via $().data('namespace')
     if ( jQuery ) {
       jQuery.data( elem, namespace, instance );
     }
   });
</PRE><PRE> });
</PRE><P>};
</P><P>// -----  ----- //
</P><P>return utils;
</P><P>}));
</P><P>// Flickity.Cell
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/cell',[
     'get-size/get-size'
   ], function( getSize ) {
     return factory( window, getSize );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('get-size')
   );
 } else {
   // browser global
   window.Flickity = window.Flickity || {};
   window.Flickity.Cell = factory(
     window,
     window.getSize
   );
 }
</PRE><P>}( window, function factory( window, getSize ) {
</P><P>function Cell( elem, parent ) {
</P><PRE> this.element = elem;
 this.parent = parent;
</PRE><PRE> this.create();
</PRE><P>}
</P><P>var proto = Cell.prototype;
</P><P>proto.create = function() {
</P><PRE> this.element.style.position = 'absolute';
 this.element.setAttribute( 'aria-selected', 'false' );
 this.x = 0;
 this.shift = 0;
</PRE><P>};
</P><P>proto.destroy = function() {
</P><PRE> // reset style
 this.element.style.position = <I>;</I>
 var side = this.parent.originSide;
 this.element.removeAttribute('aria-selected');
 this.element.style[ side ] = <I>;</I></PRE><P>};
</P><P>proto.getSize = function() {
</P><PRE> this.size = getSize( this.element );
</PRE><P>};
</P><P>proto.setPosition = function( x ) {
</P><PRE> this.x = x;
 this.updateTarget();
 this.renderPosition( x );
</PRE><P>};
</P><P>// setDefaultTarget v1 method, backwards compatibility, remove in v3
proto.updateTarget = proto.setDefaultTarget = function() {
</P><PRE> var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';
 this.target = this.x + this.size[ marginProperty ] +
   this.size.width * this.parent.cellAlign;
</PRE><P>};
</P><P>proto.renderPosition = function( x ) {
</P><PRE> // render position of cell with in slider
 var side = this.parent.originSide;
 this.element.style[ side ] = this.parent.getPositionValue( x );
</PRE><P>};
</P><P>/**
</P><PRE>* @param {Integer} factor - 0, 1, or -1
</PRE><UL><LI>/</LI></UL><P>proto.wrapShift = function( shift ) {
</P><PRE> this.shift = shift;
 this.renderPosition( this.x + this.parent.slideableWidth * shift );
</PRE><P>};
</P><P>proto.remove = function() {
</P><PRE> this.element.parentNode.removeChild( this.element );
</PRE><P>};
</P><P>return Cell;
</P><P>}));
</P><P>// slide
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/slide',factory );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory();
 } else {
   // browser global
   window.Flickity = window.Flickity || {};
   window.Flickity.Slide = factory();
 }
</PRE><P>}( window, function factory() {
'use strict';
</P><P>function Slide( parent ) {
</P><PRE> this.parent = parent;
 this.isOriginLeft = parent.originSide == 'left';
 this.cells = [];
 this.outerWidth = 0;
 this.height = 0;
</PRE><P>}
</P><P>var proto = Slide.prototype;
</P><P>proto.addCell = function( cell ) {
</P><PRE> this.cells.push( cell );
 this.outerWidth += cell.size.outerWidth;
 this.height = Math.max( cell.size.outerHeight, this.height );
 // first cell stuff
 if ( this.cells.length == 1 ) {
   this.x = cell.x; // x comes from first cell
   var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';
   this.firstMargin = cell.size[ beginMargin ];
 }
</PRE><P>};
</P><P>proto.updateTarget = function() {
</P><PRE> var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';
 var lastCell = this.getLastCell();
 var lastMargin = lastCell ? lastCell.size[ endMargin ] : 0;
 var slideWidth = this.outerWidth - ( this.firstMargin + lastMargin );
 this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;
</PRE><P>};
</P><P>proto.getLastCell = function() {
</P><PRE> return this.cells[ this.cells.length - 1 ];
</PRE><P>};
</P><P>proto.select = function() {
</P><PRE> this.changeSelected( true );
</PRE><P>};
</P><P>proto.unselect = function() {
</P><PRE> this.changeSelected( false );
</PRE><P>};
</P><P>proto.changeSelected = function( isSelected ) {
</P><PRE> var classMethod = isSelected ? 'add' : 'remove';
 this.cells.forEach( function( cell ) {
   cell.element.classList[ classMethod ]('is-selected');
   cell.element.setAttribute( 'aria-selected', isSelected.toString() );
 });
</PRE><P>};
</P><P>proto.getCellElements = function() {
</P><PRE> return this.cells.map( function( cell ) {
   return cell.element;
 });
</PRE><P>};
</P><P>return Slide;
</P><P>}));
</P><P>// animate
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/animate',[
     'fizzy-ui-utils/utils'
   ], function( utils ) {
     return factory( window, utils );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('fizzy-ui-utils')
   );
 } else {
   // browser global
   window.Flickity = window.Flickity || {};
   window.Flickity.animatePrototype = factory(
     window,
     window.fizzyUIUtils
   );
 }
</PRE><P>}( window, function factory( window, utils ) {
</P><P>// -------------------------- animate -------------------------- //
</P><P>var proto = {};
</P><P>proto.startAnimation = function() {
</P><PRE> if ( this.isAnimating ) {
   return;
 }
</PRE><PRE> this.isAnimating = true;
 this.restingFrames = 0;
 this.animate();
</PRE><P>};
</P><P>proto.animate = function() {
</P><PRE> this.applyDragForce();
 this.applySelectedAttraction();
</PRE><PRE> var previousX = this.x;
</PRE><PRE> this.integratePhysics();
 this.positionSlider();
 this.settle( previousX );
 // animate next frame
 if ( this.isAnimating ) {
   var _this = this;
   requestAnimationFrame( function animateFrame() {
     _this.animate();
   });
 }
</PRE><P>};
</P><P>proto.positionSlider = function() {
</P><PRE> var x = this.x;
 // wrap position around
 if ( this.options.wrapAround &amp;&amp; this.cells.length &gt; 1 ) {
   x = utils.modulo( x, this.slideableWidth );
   x = x - this.slideableWidth;
   this.shiftWrapCells( x );
 }
</PRE><PRE> x = x + this.cursorPosition;
 // reverse if right-to-left and using transform
 x = this.options.rightToLeft ? -x : x;
 var value = this.getPositionValue( x );
 // use 3D tranforms for hardware acceleration on iOS
 // but use 2D when settled, for better font-rendering
 this.slider.style.transform = this.isAnimating ?
   'translate3d(' + value + ',0,0)' : 'translateX(' + value + ')';
</PRE><PRE> // scroll event
 var firstSlide = this.slides[0];
 if ( firstSlide ) {
   var positionX = -this.x - firstSlide.target;
   var progress = positionX / this.slidesWidth;
   this.dispatchEvent( 'scroll', null, [ progress, positionX ] );
 }
</PRE><P>};
</P><P>proto.positionSliderAtSelected = function() {
</P><PRE> if ( !this.cells.length ) {
   return;
 }
 this.x = -this.selectedSlide.target;
 this.velocity = 0; // stop wobble
 this.positionSlider();
</PRE><P>};
</P><P>proto.getPositionValue = function( position ) {
</P><PRE> if ( this.options.percentPosition ) {
   // percent position, round to 2 digits, like 12.34%
   return ( Math.round( ( position / this.size.innerWidth ) * 10000 ) * 0.01 )+ '%';
 } else {
   // pixel positioning
   return Math.round( position ) + 'px';
 }
</PRE><P>};
</P><P>proto.settle = function( previousX ) {
</P><PRE> // keep track of frames where x hasn't moved
 if ( !this.isPointerDown &amp;&amp; Math.round( this.x * 100 ) == Math.round( previousX * 100 ) ) {
   this.restingFrames++;
 }
 // stop animating if resting for 3 or more frames
 if ( this.restingFrames &gt; 2 ) {
   this.isAnimating = false;
   delete this.isFreeScrolling;
   // render position with translateX when settled
   this.positionSlider();
   this.dispatchEvent( 'settle', null, [ this.selectedIndex ] );
 }
</PRE><P>};
</P><P>proto.shiftWrapCells = function( x ) {
</P><PRE> // shift before cells
 var beforeGap = this.cursorPosition + x;
 this._shiftCells( this.beforeShiftCells, beforeGap, -1 );
 // shift after cells
 var afterGap = this.size.innerWidth - ( x + this.slideableWidth + this.cursorPosition );
 this._shiftCells( this.afterShiftCells, afterGap, 1 );
</PRE><P>};
</P><P>proto._shiftCells = function( cells, gap, shift ) {
</P><PRE> for ( var i=0; i &lt; cells.length; i++ ) {
   var cell = cells[i];
   var cellShift = gap &gt; 0 ? shift : 0;
   cell.wrapShift( cellShift );
   gap -= cell.size.outerWidth;
 }
</PRE><P>};
</P><P>proto._unshiftCells = function( cells ) {
</P><PRE> if ( !cells || !cells.length ) {
   return;
 }
 for ( var i=0; i &lt; cells.length; i++ ) {
   cells[i].wrapShift( 0 );
 }
</PRE><P>};
</P><P>// -------------------------- physics -------------------------- //
</P><P>proto.integratePhysics = function() {
</P><PRE> this.x += this.velocity;
 this.velocity *= this.getFrictionFactor();
</PRE><P>};
</P><P>proto.applyForce = function( force ) {
</P><PRE> this.velocity += force;
</PRE><P>};
</P><P>proto.getFrictionFactor = function() {
</P><PRE> return 1 - this.options[ this.isFreeScrolling ? 'freeScrollFriction' : 'friction' ];
</PRE><P>};
</P><P>proto.getRestingPosition = function() {
</P><PRE> // my thanks to Steven Wittens, who simplified this math greatly
 return this.x + this.velocity / ( 1 - this.getFrictionFactor() );
</PRE><P>};
</P><P>proto.applyDragForce = function() {
</P><PRE> if ( !this.isDraggable || !this.isPointerDown ) {
   return;
 }
 // change the position to drag position by applying force
 var dragVelocity = this.dragX - this.x;
 var dragForce = dragVelocity - this.velocity;
 this.applyForce( dragForce );
</PRE><P>};
</P><P>proto.applySelectedAttraction = function() {
</P><PRE> // do not attract if pointer down or no slides
 var dragDown = this.isDraggable &amp;&amp; this.isPointerDown;
 if ( dragDown || this.isFreeScrolling || !this.slides.length ) {
   return;
 }
 var distance = this.selectedSlide.target * -1 - this.x;
 var force = distance * this.options.selectedAttraction;
 this.applyForce( force );
</PRE><P>};
</P><P>return proto;
</P><P>}));
</P><P>// Flickity main
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/flickity',[
     'ev-emitter/ev-emitter',
     'get-size/get-size',
     'fizzy-ui-utils/utils',
     './cell',
     './slide',
     './animate'
   ], function( EvEmitter, getSize, utils, Cell, Slide, animatePrototype ) {
     return factory( window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('ev-emitter'),
     require('get-size'),
     require('fizzy-ui-utils'),
     require('./cell'),
     require('./slide'),
     require('./animate')
   );
 } else {
   // browser global
   var _Flickity = window.Flickity;
</PRE><PRE>   window.Flickity = factory(
     window,
     window.EvEmitter,
     window.getSize,
     window.fizzyUIUtils,
     _Flickity.Cell,
     _Flickity.Slide,
     _Flickity.animatePrototype
   );
 }
</PRE><P>}( window, function factory( window, EvEmitter, getSize,
</P><PRE> utils, Cell, Slide, animatePrototype ) {
</PRE><P>// vars
var jQuery = window.jQuery;
var getComputedStyle = window.getComputedStyle;
var console = window.console;
</P><P>function moveElements( elems, toElem ) {
</P><PRE> elems = utils.makeArray( elems );
 while ( elems.length ) {
   toElem.appendChild( elems.shift() );
 }
</PRE><P>}
</P><P>// -------------------------- Flickity -------------------------- //
</P><P>// globally unique identifiers
var GUID = 0;
// internal store of all Flickity intances
var instances = {};
</P><P>function Flickity( element, options ) {
</P><PRE> var queryElement = utils.getQueryElement( element );
 if ( !queryElement ) {
   if ( console ) {
     console.error( 'Bad element for Flickity: ' + ( queryElement || element ) );
   }
   return;
 }
 this.element = queryElement;
 // do not initialize twice on same element
 if ( this.element.flickityGUID ) {
   var instance = instances[ this.element.flickityGUID ];
   instance.option( options );
   return instance;
 }
</PRE><PRE> // add jQuery
 if ( jQuery ) {
   this.$element = jQuery( this.element );
 }
 // options
 this.options = utils.extend( {}, this.constructor.defaults );
 this.option( options );
</PRE><PRE> // kick things off
 this._create();
</PRE><P>}
</P><P>Flickity.defaults = {
</P><PRE> accessibility: true,
 // adaptiveHeight: false,
 cellAlign: 'center',
 // cellSelector: undefined,
 // contain: false,
 freeScrollFriction: 0.075, // friction when free-scrolling
 friction: 0.28, // friction when selecting
 namespaceJQueryEvents: true,
 // initialIndex: 0,
 percentPosition: true,
 resize: true,
 selectedAttraction: 0.025,
 setGallerySize: true
 // watchCSS: false,
 // wrapAround: false
</PRE><P>};
</P><P>// hash of methods triggered on _create()
Flickity.createMethods = [];
</P><P>var proto = Flickity.prototype;
// inherit EventEmitter
utils.extend( proto, EvEmitter.prototype );
</P><P>proto._create = function() {
</P><PRE> // add id for Flickity.data
 var id = this.guid = ++GUID;
 this.element.flickityGUID = id; // expando
 instances[ id ] = this; // associate via id
 // initial properties
 this.selectedIndex = 0;
 // how many frames slider has been in same position
 this.restingFrames = 0;
 // initial physics properties
 this.x = 0;
 this.velocity = 0;
 this.originSide = this.options.rightToLeft ? 'right' : 'left';
 // create viewport &amp; slider
 this.viewport = document.createElement('div');
 this.viewport.className = 'flickity-viewport';
 this._createSlider();
</PRE><PRE> if ( this.options.resize || this.options.watchCSS ) {
   window.addEventListener( 'resize', this );
 }
</PRE><PRE> // add listeners from on option
 for ( var eventName in this.options.on ) {
   var listener = this.options.on[ eventName ];
   this.on( eventName, listener );
 }
</PRE><PRE> Flickity.createMethods.forEach( function( method ) {
   this[ method ]();
 }, this );
</PRE><PRE> if ( this.options.watchCSS ) {
   this.watchCSS();
 } else {
   this.activate();
 }
</PRE><P>};
</P><P>/**
</P><PRE>* set options
* @param {Object} opts
*/
</PRE><P>proto.option = function( opts ) {
</P><PRE> utils.extend( this.options, opts );
</PRE><P>};
</P><P>proto.activate = function() {
</P><PRE> if ( this.isActive ) {
   return;
 }
 this.isActive = true;
 this.element.classList.add('flickity-enabled');
 if ( this.options.rightToLeft ) {
   this.element.classList.add('flickity-rtl');
 }
</PRE><PRE> this.getSize();
 // move initial cell elements so they can be loaded as cells
 var cellElems = this._filterFindCellElements( this.element.children );
 moveElements( cellElems, this.slider );
 this.viewport.appendChild( this.slider );
 this.element.appendChild( this.viewport );
 // get cells from children
 this.reloadCells();
</PRE><PRE> if ( this.options.accessibility ) {
   // allow element to focusable
   this.element.tabIndex = 0;
   // listen for key presses
   this.element.addEventListener( 'keydown', this );
 }
</PRE><PRE> this.emitEvent('activate');
</PRE><PRE> var index;
 var initialIndex = this.options.initialIndex;
 if ( this.isInitActivated ) {
   index = this.selectedIndex;
 } else if ( initialIndex !== undefined ) {
   index = this.cells[ initialIndex ] ? initialIndex : 0;
 } else {
   index = 0;
 }
 // select instantly
 this.select( index, false, true );
 // flag for initial activation, for using initialIndex
 this.isInitActivated = true;
 // ready event. #493
 this.dispatchEvent('ready');
</PRE><P>};
</P><P>// slider positions the cells
proto._createSlider = function() {
</P><PRE> // slider element does all the positioning
 var slider = document.createElement('div');
 slider.className = 'flickity-slider';
 slider.style[ this.originSide ] = 0;
 this.slider = slider;
</PRE><P>};
</P><P>proto._filterFindCellElements = function( elems ) {
</P><PRE> return utils.filterFindElements( elems, this.options.cellSelector );
</PRE><P>};
</P><P>// goes through all children
proto.reloadCells = function() {
</P><PRE> // collection of item elements
 this.cells = this._makeCells( this.slider.children );
 this.positionCells();
 this._getWrapShiftCells();
 this.setGallerySize();
</PRE><P>};
</P><P>/**
</P><PRE>* turn elements into Flickity.Cells
* @param {Array or NodeList or HTMLElement} elems
* @returns {Array} items - collection of new Flickity Cells
*/
</PRE><P>proto._makeCells = function( elems ) {
</P><PRE> var cellElems = this._filterFindCellElements( elems );
</PRE><PRE> // create new Flickity for collection
 var cells = cellElems.map( function( cellElem ) {
   return new Cell( cellElem, this );
 }, this );
</PRE><PRE> return cells;
</PRE><P>};
</P><P>proto.getLastCell = function() {
</P><PRE> return this.cells[ this.cells.length - 1 ];
</PRE><P>};
</P><P>proto.getLastSlide = function() {
</P><PRE> return this.slides[ this.slides.length - 1 ];
</PRE><P>};
</P><P>// positions all cells
proto.positionCells = function() {
</P><PRE> // size all cells
 this._sizeCells( this.cells );
 // position all cells
 this._positionCells( 0 );
</PRE><P>};
</P><P>/**
</P><PRE>* position certain cells
* @param {Integer} index - which cell to start with
*/
</PRE><P>proto._positionCells = function( index ) {
</P><PRE> index = index || 0;
 // also measure maxCellHeight
 // start 0 if positioning all cells
 this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;
 var cellX = 0;
 // get cellX
 if ( index &gt; 0 ) {
   var startCell = this.cells[ index - 1 ];
   cellX = startCell.x + startCell.size.outerWidth;
 }
 var len = this.cells.length;
 for ( var i=index; i &lt; len; i++ ) {
   var cell = this.cells[i];
   cell.setPosition( cellX );
   cellX += cell.size.outerWidth;
   this.maxCellHeight = Math.max( cell.size.outerHeight, this.maxCellHeight );
 }
 // keep track of cellX for wrap-around
 this.slideableWidth = cellX;
 // slides
 this.updateSlides();
 // contain slides target
 this._containSlides();
 // update slidesWidth
 this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;
</PRE><P>};
</P><P>/**
</P><PRE>* cell.getSize() on multiple cells
* @param {Array} cells
*/
</PRE><P>proto._sizeCells = function( cells ) {
</P><PRE> cells.forEach( function( cell ) {
   cell.getSize();
 });
</PRE><P>};
</P><P>// --------------------------  -------------------------- //
</P><P>proto.updateSlides = function() {
</P><PRE> this.slides = [];
 if ( !this.cells.length ) {
   return;
 }
</PRE><PRE> var slide = new Slide( this );
 this.slides.push( slide );
 var isOriginLeft = this.originSide == 'left';
 var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';
</PRE><PRE> var canCellFit = this._getCanCellFit();
</PRE><PRE> this.cells.forEach( function( cell, i ) {
   // just add cell if first cell in slide
   if ( !slide.cells.length ) {
     slide.addCell( cell );
     return;
   }
</PRE><PRE>   var slideWidth = ( slide.outerWidth - slide.firstMargin ) +
     ( cell.size.outerWidth - cell.size[ nextMargin ] );
</PRE><PRE>   if ( canCellFit.call( this, i, slideWidth ) ) {
     slide.addCell( cell );
   } else {
     // doesn't fit, new slide
     slide.updateTarget();
</PRE><PRE>     slide = new Slide( this );
     this.slides.push( slide );
     slide.addCell( cell );
   }
 }, this );
 // last slide
 slide.updateTarget();
 // update .selectedSlide
 this.updateSelectedSlide();
</PRE><P>};
</P><P>proto._getCanCellFit = function() {
</P><PRE> var groupCells = this.options.groupCells;
 if ( !groupCells ) {
   return function() {
     return false;
   };
 } else if ( typeof groupCells == 'number' ) {
   // group by number. 3 -&gt; [0,1,2], [3,4,5], ...
   var number = parseInt( groupCells, 10 );
   return function( i ) {
     return ( i % number ) !== 0;
   };
 }
 // default, group by width of slide
 // parse '75%
 var percentMatch = typeof groupCells == 'string' &amp;&amp;
   groupCells.match(/^(\d+)%$/);
 var percent = percentMatch ? parseInt( percentMatch[1], 10 ) / 100 : 1;
 return function( i, slideWidth ) {
   return slideWidth &lt;= ( this.size.innerWidth + 1 ) * percent;
 };
</PRE><P>};
</P><P>// alias _init for jQuery plugin .flickity()
proto._init =
proto.reposition = function() {
</P><PRE> this.positionCells();
 this.positionSliderAtSelected();
</PRE><P>};
</P><P>proto.getSize = function() {
</P><PRE> this.size = getSize( this.element );
 this.setCellAlign();
 this.cursorPosition = this.size.innerWidth * this.cellAlign;
</PRE><P>};
</P><P>var cellAlignShorthands = {
</P><PRE> // cell align, then based on origin side
 center: {
   left: 0.5,
   right: 0.5
 },
 left: {
   left: 0,
   right: 1
 },
 right: {
   right: 0,
   left: 1
 }
</PRE><P>};
</P><P>proto.setCellAlign = function() {
</P><PRE> var shorthand = cellAlignShorthands[ this.options.cellAlign ];
 this.cellAlign = shorthand ? shorthand[ this.originSide ] : this.options.cellAlign;
</PRE><P>};
</P><P>proto.setGallerySize = function() {
</P><PRE> if ( this.options.setGallerySize ) {
   var height = this.options.adaptiveHeight &amp;&amp; this.selectedSlide ?
     this.selectedSlide.height : this.maxCellHeight;
   this.viewport.style.height = height + 'px';
 }
</PRE><P>};
</P><P>proto._getWrapShiftCells = function() {
</P><PRE> // only for wrap-around
 if ( !this.options.wrapAround ) {
   return;
 }
 // unshift previous cells
 this._unshiftCells( this.beforeShiftCells );
 this._unshiftCells( this.afterShiftCells );
 // get before cells
 // initial gap
 var gapX = this.cursorPosition;
 var cellIndex = this.cells.length - 1;
 this.beforeShiftCells = this._getGapCells( gapX, cellIndex, -1 );
 // get after cells
 // ending gap between last cell and end of gallery viewport
 gapX = this.size.innerWidth - this.cursorPosition;
 // start cloning at first cell, working forwards
 this.afterShiftCells = this._getGapCells( gapX, 0, 1 );
</PRE><P>};
</P><P>proto._getGapCells = function( gapX, cellIndex, increment ) {
</P><PRE> // keep adding cells until the cover the initial gap
 var cells = [];
 while ( gapX &gt; 0 ) {
   var cell = this.cells[ cellIndex ];
   if ( !cell ) {
     break;
   }
   cells.push( cell );
   cellIndex += increment;
   gapX -= cell.size.outerWidth;
 }
 return cells;
</PRE><P>};
</P><P>// ----- contain ----- //
</P><P>// contain cell targets so no excess sliding
proto._containSlides = function() {
</P><PRE> if ( !this.options.contain || this.options.wrapAround || !this.cells.length ) {
   return;
 }
 var isRightToLeft = this.options.rightToLeft;
 var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';
 var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';
 var contentWidth = this.slideableWidth - this.getLastCell().size[ endMargin ];
 // content is less than gallery size
 var isContentSmaller = contentWidth &lt; this.size.innerWidth;
 // bounds
 var beginBound = this.cursorPosition + this.cells[0].size[ beginMargin ];
 var endBound = contentWidth - this.size.innerWidth * ( 1 - this.cellAlign );
 // contain each cell target
 this.slides.forEach( function( slide ) {
   if ( isContentSmaller ) {
     // all cells fit inside gallery
     slide.target = contentWidth * this.cellAlign;
   } else {
     // contain to bounds
     slide.target = Math.max( slide.target, beginBound );
     slide.target = Math.min( slide.target, endBound );
   }
 }, this );
</PRE><P>};
</P><P>// -----  ----- //
</P><P>/**
</P><PRE>* emits events via eventEmitter and jQuery events
* @param {String} type - name of event
* @param {Event} event - original event
* @param {Array} args - extra arguments
*/
</PRE><P>proto.dispatchEvent = function( type, event, args ) {
</P><PRE> var emitArgs = event ? [ event ].concat( args ) : args;
 this.emitEvent( type, emitArgs );
</PRE><PRE> if ( jQuery &amp;&amp; this.$element ) {
   // default trigger with type if no event
   type += this.options.namespaceJQueryEvents ? '.flickity' : <I>;</I>
   var $event = type;
   if ( event ) {
     // create jQuery event
     var jQEvent = jQuery.Event( event );
     jQEvent.type = type;
     $event = jQEvent;
   }
   this.$element.trigger( $event, args );
 }
</PRE><P>};
</P><P>// -------------------------- select -------------------------- //
</P><P>/**
</P><PRE>* @param {Integer} index - index of the slide
* @param {Boolean} isWrap - will wrap-around to last/first if at the end
* @param {Boolean} isInstant - will immediately set position at selected cell
*/
</PRE><P>proto.select = function( index, isWrap, isInstant ) {
</P><PRE> if ( !this.isActive ) {
   return;
 }
 index = parseInt( index, 10 );
 this._wrapSelect( index );
</PRE><PRE> if ( this.options.wrapAround || isWrap ) {
   index = utils.modulo( index, this.slides.length );
 }
 // bail if invalid index
 if ( !this.slides[ index ] ) {
   return;
 }
 var prevIndex = this.selectedIndex;
 this.selectedIndex = index;
 this.updateSelectedSlide();
 if ( isInstant ) {
   this.positionSliderAtSelected();
 } else {
   this.startAnimation();
 }
 if ( this.options.adaptiveHeight ) {
   this.setGallerySize();
 }
 // events
 this.dispatchEvent( 'select', null, [ index ] );
 // change event if new index
 if ( index != prevIndex ) {
   this.dispatchEvent( 'change', null, [ index ] );
 }
 // old v1 event name, remove in v3
 this.dispatchEvent('cellSelect');
</PRE><P>};
</P><P>// wraps position for wrapAround, to move to closest slide. #113
proto._wrapSelect = function( index ) {
</P><PRE> var len = this.slides.length;
 var isWrapping = this.options.wrapAround &amp;&amp; len &gt; 1;
 if ( !isWrapping ) {
   return index;
 }
 var wrapIndex = utils.modulo( index, len );
 // go to shortest
 var delta = Math.abs( wrapIndex - this.selectedIndex );
 var backWrapDelta = Math.abs( ( wrapIndex + len ) - this.selectedIndex );
 var forewardWrapDelta = Math.abs( ( wrapIndex - len ) - this.selectedIndex );
 if ( !this.isDragSelect &amp;&amp; backWrapDelta &lt; delta ) {
   index += len;
 } else if ( !this.isDragSelect &amp;&amp; forewardWrapDelta &lt; delta ) {
   index -= len;
 }
 // wrap position so slider is within normal area
 if ( index &lt; 0 ) {
   this.x -= this.slideableWidth;
 } else if ( index &gt;= len ) {
   this.x += this.slideableWidth;
 }
</PRE><P>};
</P><P>proto.previous = function( isWrap, isInstant ) {
</P><PRE> this.select( this.selectedIndex - 1, isWrap, isInstant );
</PRE><P>};
</P><P>proto.next = function( isWrap, isInstant ) {
</P><PRE> this.select( this.selectedIndex + 1, isWrap, isInstant );
</PRE><P>};
</P><P>proto.updateSelectedSlide = function() {
</P><PRE> var slide = this.slides[ this.selectedIndex ];
 // selectedIndex could be outside of slides, if triggered before resize()
 if ( !slide ) {
   return;
 }
 // unselect previous selected slide
 this.unselectSelectedSlide();
 // update new selected slide
 this.selectedSlide = slide;
 slide.select();
 this.selectedCells = slide.cells;
 this.selectedElements = slide.getCellElements();
 // HACK: selectedCell &amp; selectedElement is first cell in slide, backwards compatibility
 // Remove in v3?
 this.selectedCell = slide.cells[0];
 this.selectedElement = this.selectedElements[0];
</PRE><P>};
</P><P>proto.unselectSelectedSlide = function() {
</P><PRE> if ( this.selectedSlide ) {
   this.selectedSlide.unselect();
 }
</PRE><P>};
</P><P>/**
</P><PRE>* select slide from number or cell element
* @param {Element or Number} elem
*/
</PRE><P>proto.selectCell = function( value, isWrap, isInstant ) {
</P><PRE> // get cell
 var cell = this.queryCell( value );
 if ( !cell ) {
   return;
 }
</PRE><PRE> var index = this.getCellSlideIndex( cell );
 this.select( index, isWrap, isInstant );
</PRE><P>};
</P><P>proto.getCellSlideIndex = function( cell ) {
</P><PRE> // get index of slides that has cell
 for ( var i=0; i &lt; this.slides.length; i++ ) {
   var slide = this.slides[i];
   var index = slide.cells.indexOf( cell );
   if ( index != -1 ) {
     return i;
   }
 }
</PRE><P>};
</P><P>// -------------------------- get cells -------------------------- //
</P><P>/**
</P><PRE>* get Flickity.Cell, given an Element
* @param {Element} elem
* @returns {Flickity.Cell} item
*/
</PRE><P>proto.getCell = function( elem ) {
</P><PRE> // loop through cells to get the one that matches
 for ( var i=0; i &lt; this.cells.length; i++ ) {
   var cell = this.cells[i];
   if ( cell.element == elem ) {
     return cell;
   }
 }
</PRE><P>};
</P><P>/**
</P><PRE>* get collection of Flickity.Cells, given Elements
* @param {Element, Array, NodeList} elems
* @returns {Array} cells - Flickity.Cells
*/
</PRE><P>proto.getCells = function( elems ) {
</P><PRE> elems = utils.makeArray( elems );
 var cells = [];
 elems.forEach( function( elem ) {
   var cell = this.getCell( elem );
   if ( cell ) {
     cells.push( cell );
   }
 }, this );
 return cells;
</PRE><P>};
</P><P>/**
</P><PRE>* get cell elements
* @returns {Array} cellElems
*/
</PRE><P>proto.getCellElements = function() {
</P><PRE> return this.cells.map( function( cell ) {
   return cell.element;
 });
</PRE><P>};</P><P>/**
</P><PRE>* get parent cell from an element
* @param {Element} elem
* @returns {Flickit.Cell} cell
*/
</PRE><P>proto.getParentCell = function( elem ) {
</P><PRE> // first check if elem is cell
 var cell = this.getCell( elem );
 if ( cell ) {
   return cell;
 }
 // try to get parent cell elem
 elem = utils.getParent( elem, '.flickity-slider &gt; *' );
 return this.getCell( elem );
</PRE><P>};
</P><P>/**
</P><PRE>* get cells adjacent to a slide
* @param {Integer} adjCount - number of adjacent slides
* @param {Integer} index - index of slide to start
* @returns {Array} cells - array of Flickity.Cells
*/
</PRE><P>proto.getAdjacentCellElements = function( adjCount, index ) {
</P><PRE> if ( !adjCount ) {
   return this.selectedSlide.getCellElements();
 }
 index = index === undefined ? this.selectedIndex : index;
</PRE><PRE> var len = this.slides.length;
 if ( 1 + ( adjCount * 2 ) &gt;= len ) {
   return this.getCellElements();
 }
</PRE><PRE> var cellElems = [];
 for ( var i = index - adjCount; i &lt;= index + adjCount ; i++ ) {
   var slideIndex = this.options.wrapAround ? utils.modulo( i, len ) : i;
   var slide = this.slides[ slideIndex ];
   if ( slide ) {
     cellElems = cellElems.concat( slide.getCellElements() );
   }
 }
 return cellElems;
</PRE><P>};
</P><P>/**
</P><PRE>* select slide from number or cell element
* @param {Element, Selector String, or Number} selector
*/
</PRE><P>proto.queryCell = function( selector ) {
</P><PRE> if ( typeof selector == 'number' ) {
   // use number as index
   return this.cells[ selector ];
 }
 if ( typeof selector == 'string' ) {
   // use string as selector, get element
   selector = this.element.querySelector( selector );
 }
 // get cell from element
 return this.getCell( selector );
</PRE><P>};
</P><P>// -------------------------- events -------------------------- //
</P><P>proto.uiChange = function() {
</P><PRE> this.emitEvent('uiChange');
</PRE><P>};
</P><P>proto.childUIPointerDown = function( event ) {
</P><PRE> this.emitEvent( 'childUIPointerDown', [ event ] );
</PRE><P>};
</P><P>// ----- resize ----- //
</P><P>proto.onresize = function() {
</P><PRE> this.watchCSS();
 this.resize();
</PRE><P>};
</P><P>utils.debounceMethod( Flickity, 'onresize', 150 );
</P><P>proto.resize = function() {
</P><PRE> if ( !this.isActive ) {
   return;
 }
 this.getSize();
 // wrap values
 if ( this.options.wrapAround ) {
   this.x = utils.modulo( this.x, this.slideableWidth );
 }
 this.positionCells();
 this._getWrapShiftCells();
 this.setGallerySize();
 this.emitEvent('resize');
 // update selected index for group slides, instant
 // TODO: position can be lost between groups of various numbers
 var selectedElement = this.selectedElements &amp;&amp; this.selectedElements[0];
 this.selectCell( selectedElement, false, true );
</PRE><P>};
</P><P>// watches the :after property, activates/deactivates
proto.watchCSS = function() {
</P><PRE> var watchOption = this.options.watchCSS;
 if ( !watchOption ) {
   return;
 }
</PRE><PRE> var afterContent = getComputedStyle( this.element, ':after' ).content;
 // activate if :after { content: 'flickity' }
 if ( afterContent.indexOf('flickity') != -1 ) {
   this.activate();
 } else {
   this.deactivate();
 }
</PRE><P>};
</P><P>// ----- keydown ----- //
</P><P>// go previous/next if left/right keys pressed
proto.onkeydown = function( event ) {
</P><PRE> // only work if element is in focus
 var isNotFocused = document.activeElement &amp;&amp; document.activeElement != this.element;
 if ( !this.options.accessibility ||isNotFocused ) {
   return;
 }
</PRE><PRE> var handler = Flickity.keyboardHandlers[ event.keyCode ];
 if ( handler ) {
   handler.call( this );
 }
</PRE><P>};
</P><P>Flickity.keyboardHandlers = {
</P><PRE> // left arrow
 37: function() {
   var leftMethod = this.options.rightToLeft ? 'next' : 'previous';
   this.uiChange();
   this[ leftMethod ]();
 },
 // right arrow
 39: function() {
   var rightMethod = this.options.rightToLeft ? 'previous' : 'next';
   this.uiChange();
   this[ rightMethod ]();
 },
</PRE><P>};
</P><P>// ----- focus ----- //
</P><P>proto.focus = function() {
</P><PRE> // TODO remove scrollTo once focus options gets more support
 // <A rel="nofollow" class="external free" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Browser_compatibility">https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Browser_compatibility</A>
 var prevScrollY = window.pageYOffset;
 this.element.focus({ preventScroll: true });
 // hack to fix scroll jump after focus, #76
 if ( window.pageYOffset != prevScrollY ) {
   window.scrollTo( window.pageXOffset, prevScrollY );
 }
</PRE><P>};
</P><P>// -------------------------- destroy -------------------------- //
</P><P>// deactivate all Flickity functionality, but keep stuff available
proto.deactivate = function() {
</P><PRE> if ( !this.isActive ) {
   return;
 }
 this.element.classList.remove('flickity-enabled');
 this.element.classList.remove('flickity-rtl');
 this.unselectSelectedSlide();
 // destroy cells
 this.cells.forEach( function( cell ) {
   cell.destroy();
 });
 this.element.removeChild( this.viewport );
 // move child elements back into element
 moveElements( this.slider.children, this.element );
 if ( this.options.accessibility ) {
   this.element.removeAttribute('tabIndex');
   this.element.removeEventListener( 'keydown', this );
 }
 // set flags
 this.isActive = false;
 this.emitEvent('deactivate');
</PRE><P>};
</P><P>proto.destroy = function() {
</P><PRE> this.deactivate();
 window.removeEventListener( 'resize', this );
 this.emitEvent('destroy');
 if ( jQuery &amp;&amp; this.$element ) {
   jQuery.removeData( this.element, 'flickity' );
 }
 delete this.element.flickityGUID;
 delete instances[ this.guid ];
</PRE><P>};
</P><P>// -------------------------- prototype -------------------------- //
</P><P>utils.extend( proto, animatePrototype );
</P><P>// -------------------------- extras -------------------------- //
</P><P>/**
</P><PRE>* get Flickity instance from element
* @param {Element} elem
* @returns {Flickity}
*/
</PRE><P>Flickity.data = function( elem ) {
</P><PRE> elem = utils.getQueryElement( elem );
 var id = elem &amp;&amp; elem.flickityGUID;
 return id &amp;&amp; instances[ id ];
</PRE><P>};
</P><P>utils.htmlInit( Flickity, 'flickity' );
</P><P>if ( jQuery &amp;&amp; jQuery.bridget ) {
</P><PRE> jQuery.bridget( 'flickity', Flickity );
</PRE><P>}
</P><P>// set internal jQuery, for Webpack + jQuery v3, #478
Flickity.setJQuery = function( jq ) {
</P><PRE> jQuery = jq;
</PRE><P>};
</P><P>Flickity.Cell = Cell;
</P><P>return Flickity;
</P><P>}));
</P><P>/*!
</P><PRE>* Unipointer v2.3.0
* base class for doing one thing with pointer event
* MIT license
*/
</PRE><P>/*jshint browser: true, undef: true, unused: true, strict: true */
</P><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */ /*global define, module, require */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'unipointer/unipointer',[
     'ev-emitter/ev-emitter'
   ], function( EvEmitter ) {
     return factory( window, EvEmitter );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('ev-emitter')
   );
 } else {
   // browser global
   window.Unipointer = factory(
     window,
     window.EvEmitter
   );
 }
</PRE><P>}( window, function factory( window, EvEmitter ) {
</P><P>function noop() {}
</P><P>function Unipointer() {}
</P><P>// inherit EvEmitter
var proto = Unipointer.prototype = Object.create( EvEmitter.prototype );
</P><P>proto.bindStartEvent = function( elem ) {
</P><PRE> this._bindStartEvent( elem, true );
</PRE><P>};
</P><P>proto.unbindStartEvent = function( elem ) {
</P><PRE> this._bindStartEvent( elem, false );
</PRE><P>};
</P><P>/**
</P><PRE>* Add or remove start event
* @param {Boolean} isAdd - remove if falsey
*/
</PRE><P>proto._bindStartEvent = function( elem, isAdd ) {
</P><PRE> // munge isAdd, default to true
 isAdd = isAdd === undefined ? true : isAdd;
 var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';
</PRE><PRE> // default to mouse events
 var startEvent = 'mousedown';
 if ( window.PointerEvent ) {
   // Pointer Events
   startEvent = 'pointerdown';
 } else if ( 'ontouchstart' in window ) {
   // Touch Events. iOS Safari
   startEvent = 'touchstart';
 }
 elem[ bindMethod ]( startEvent, this );
</PRE><P>};
</P><P>// trigger handler methods for events
proto.handleEvent = function( event ) {
</P><PRE> var method = 'on' + event.type;
 if ( this[ method ] ) {
   this[ method ]( event );
 }
</PRE><P>};
</P><P>// returns the touch that we're keeping track of
proto.getTouch = function( touches ) {
</P><PRE> for ( var i=0; i &lt; touches.length; i++ ) {
   var touch = touches[i];
   if ( touch.identifier == this.pointerIdentifier ) {
     return touch;
   }
 }
</PRE><P>};
</P><P>// ----- start event ----- //
</P><P>proto.onmousedown = function( event ) {
</P><PRE> // dismiss clicks from right or middle buttons
 var button = event.button;
 if ( button &amp;&amp; ( button !== 0 &amp;&amp; button !== 1 ) ) {
   return;
 }
 this._pointerDown( event, event );
</PRE><P>};
</P><P>proto.ontouchstart = function( event ) {
</P><PRE> this._pointerDown( event, event.changedTouches[0] );
</PRE><P>};
</P><P>proto.onpointerdown = function( event ) {
</P><PRE> this._pointerDown( event, event );
</PRE><P>};
</P><P>/**
</P><PRE>* pointer start
* @param {Event} event
* @param {Event or Touch} pointer
*/
</PRE><P>proto._pointerDown = function( event, pointer ) {
</P><PRE> // dismiss right click and other pointers
 // button = 0 is okay, 1-4 not
 if ( event.button || this.isPointerDown ) {
   return;
 }
</PRE><PRE> this.isPointerDown = true;
 // save pointer identifier to match up touch events
 this.pointerIdentifier = pointer.pointerId !== undefined ?
   // pointerId for pointer events, touch.indentifier for touch events
   pointer.pointerId : pointer.identifier;
</PRE><PRE> this.pointerDown( event, pointer );
</PRE><P>};
</P><P>proto.pointerDown = function( event, pointer ) {
</P><PRE> this._bindPostStartEvents( event );
 this.emitEvent( 'pointerDown', [ event, pointer ] );
</PRE><P>};
</P><P>// hash of events to be bound after start event
var postStartEvents = {
</P><PRE> mousedown: [ 'mousemove', 'mouseup' ],
 touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],
 pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],
</PRE><P>};
</P><P>proto._bindPostStartEvents = function( event ) {
</P><PRE> if ( !event ) {
   return;
 }
 // get proper events to match start event
 var events = postStartEvents[ event.type ];
 // bind events to node
 events.forEach( function( eventName ) {
   window.addEventListener( eventName, this );
 }, this );
 // save these arguments
 this._boundPointerEvents = events;
</PRE><P>};
</P><P>proto._unbindPostStartEvents = function() {
</P><PRE> // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)
 if ( !this._boundPointerEvents ) {
   return;
 }
 this._boundPointerEvents.forEach( function( eventName ) {
   window.removeEventListener( eventName, this );
 }, this );
</PRE><PRE> delete this._boundPointerEvents;
</PRE><P>};
</P><P>// ----- move event ----- //
</P><P>proto.onmousemove = function( event ) {
</P><PRE> this._pointerMove( event, event );
</PRE><P>};
</P><P>proto.onpointermove = function( event ) {
</P><PRE> if ( event.pointerId == this.pointerIdentifier ) {
   this._pointerMove( event, event );
 }
</PRE><P>};
</P><P>proto.ontouchmove = function( event ) {
</P><PRE> var touch = this.getTouch( event.changedTouches );
 if ( touch ) {
   this._pointerMove( event, touch );
 }
</PRE><P>};
</P><P>/**
</P><PRE>* pointer move
* @param {Event} event
* @param {Event or Touch} pointer
* @private
*/
</PRE><P>proto._pointerMove = function( event, pointer ) {
</P><PRE> this.pointerMove( event, pointer );
</PRE><P>};
</P><P>// public
proto.pointerMove = function( event, pointer ) {
</P><PRE> this.emitEvent( 'pointerMove', [ event, pointer ] );
</PRE><P>};
</P><P>// ----- end event ----- //
</P><P>
proto.onmouseup = function( event ) {
</P><PRE> this._pointerUp( event, event );
</PRE><P>};
</P><P>proto.onpointerup = function( event ) {
</P><PRE> if ( event.pointerId == this.pointerIdentifier ) {
   this._pointerUp( event, event );
 }
</PRE><P>};
</P><P>proto.ontouchend = function( event ) {
</P><PRE> var touch = this.getTouch( event.changedTouches );
 if ( touch ) {
   this._pointerUp( event, touch );
 }
</PRE><P>};
</P><P>/**
</P><PRE>* pointer up
* @param {Event} event
* @param {Event or Touch} pointer
* @private
*/
</PRE><P>proto._pointerUp = function( event, pointer ) {
</P><PRE> this._pointerDone();
 this.pointerUp( event, pointer );
</PRE><P>};
</P><P>// public
proto.pointerUp = function( event, pointer ) {
</P><PRE> this.emitEvent( 'pointerUp', [ event, pointer ] );
</PRE><P>};
</P><P>// ----- pointer done ----- //
</P><P>// triggered on pointer up &amp; pointer cancel
proto._pointerDone = function() {
</P><PRE> this._pointerReset();
 this._unbindPostStartEvents();
 this.pointerDone();
</PRE><P>};
</P><P>proto._pointerReset = function() {
</P><PRE> // reset properties
 this.isPointerDown = false;
 delete this.pointerIdentifier;
</PRE><P>};
</P><P>proto.pointerDone = noop;
</P><P>// ----- pointer cancel ----- //
</P><P>proto.onpointercancel = function( event ) {
</P><PRE> if ( event.pointerId == this.pointerIdentifier ) {
   this._pointerCancel( event, event );
 }
</PRE><P>};
</P><P>proto.ontouchcancel = function( event ) {
</P><PRE> var touch = this.getTouch( event.changedTouches );
 if ( touch ) {
   this._pointerCancel( event, touch );
 }
</PRE><P>};
</P><P>/**
</P><PRE>* pointer cancel
* @param {Event} event
* @param {Event or Touch} pointer
* @private
*/
</PRE><P>proto._pointerCancel = function( event, pointer ) {
</P><PRE> this._pointerDone();
 this.pointerCancel( event, pointer );
</PRE><P>};
</P><P>// public
proto.pointerCancel = function( event, pointer ) {
</P><PRE> this.emitEvent( 'pointerCancel', [ event, pointer ] );
</PRE><P>};
</P><P>// -----  ----- //
</P><P>// utility function for getting x/y coords from event
Unipointer.getPointerPoint = function( pointer ) {
</P><PRE> return {
   x: pointer.pageX,
   y: pointer.pageY
 };
</PRE><P>};
</P><P>// -----  ----- //
</P><P>return Unipointer;
</P><P>}));
</P><P>/*!
</P><PRE>* Unidragger v2.3.0
* Draggable base class
* MIT license
*/
</PRE><P>/*jshint browser: true, unused: true, undef: true, strict: true */
</P><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /*jshint strict: false */ /*globals define, module, require */
</PRE><PRE> if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'unidragger/unidragger',[
     'unipointer/unipointer'
   ], function( Unipointer ) {
     return factory( window, Unipointer );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('unipointer')
   );
 } else {
   // browser global
   window.Unidragger = factory(
     window,
     window.Unipointer
   );
 }
</PRE><P>}( window, function factory( window, Unipointer ) {
</P><P>// -------------------------- Unidragger -------------------------- //
</P><P>function Unidragger() {}
</P><P>// inherit Unipointer &amp; EvEmitter
var proto = Unidragger.prototype = Object.create( Unipointer.prototype );
</P><P>// ----- bind start ----- //
</P><P>proto.bindHandles = function() {
</P><PRE> this._bindHandles( true );
</PRE><P>};
</P><P>proto.unbindHandles = function() {
</P><PRE> this._bindHandles( false );
</PRE><P>};
</P><P>/**
</P><PRE>* Add or remove start event
* @param {Boolean} isAdd
*/
</PRE><P>proto._bindHandles = function( isAdd ) {
</P><PRE> // munge isAdd, default to true
 isAdd = isAdd === undefined ? true : isAdd;
 // bind each handle
 var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';
 var touchAction = isAdd ? this._touchActionValue : <I>;</I>
 for ( var i=0; i &lt; this.handles.length; i++ ) {
   var handle = this.handles[i];
   this._bindStartEvent( handle, isAdd );
   handle[ bindMethod ]( 'click', this );
   // touch-action: none to override browser touch gestures. metafizzy/flickity#540
   if ( window.PointerEvent ) {
     handle.style.touchAction = touchAction;
   }
 }
</PRE><P>};
</P><P>// prototype so it can be overwriteable by Flickity
proto._touchActionValue = 'none';
</P><P>// ----- start event ----- //
</P><P>/**
</P><PRE>* pointer start
* @param {Event} event
* @param {Event or Touch} pointer
*/
</PRE><P>proto.pointerDown = function( event, pointer ) {
</P><PRE> var isOkay = this.okayPointerDown( event );
 if ( !isOkay ) {
   return;
 }
 // track start event position
 this.pointerDownPointer = pointer;
</PRE><PRE> event.preventDefault();
 this.pointerDownBlur();
 // bind move and end events
 this._bindPostStartEvents( event );
 this.emitEvent( 'pointerDown', [ event, pointer ] );
</PRE><P>};
</P><P>// nodes that have text fields
var cursorNodes = {
</P><PRE> TEXTAREA: true,
 INPUT: true,
 SELECT: true,
 OPTION: true,
</PRE><P>};
</P><P>// input types that do not have text fields
var clickTypes = {
</P><PRE> radio: true,
 checkbox: true,
 button: true,
 submit: true,
 image: true,
 file: true,
</PRE><P>};
</P><P>// dismiss inputs with text fields. flickity#403, flickity#404
proto.okayPointerDown = function( event ) {
</P><PRE> var isCursorNode = cursorNodes[ event.target.nodeName ];
 var isClickType = clickTypes[ event.target.type ];
 var isOkay = !isCursorNode || isClickType;
 if ( !isOkay ) {
   this._pointerReset();
 }
 return isOkay;
</PRE><P>};
</P><P>// kludge to blur previously focused input
proto.pointerDownBlur = function() {
</P><PRE> var focused = document.activeElement;
 // do not blur body for IE10, metafizzy/flickity#117
 var canBlur = focused &amp;&amp; focused.blur &amp;&amp; focused != document.body;
 if ( canBlur ) {
   focused.blur();
 }
</PRE><P>};
</P><P>// ----- move event ----- //
</P><P>/**
</P><PRE>* drag move
* @param {Event} event
* @param {Event or Touch} pointer
*/
</PRE><P>proto.pointerMove = function( event, pointer ) {
</P><PRE> var moveVector = this._dragPointerMove( event, pointer );
 this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );
 this._dragMove( event, pointer, moveVector );
</PRE><P>};
</P><P>// base pointer move logic
proto._dragPointerMove = function( event, pointer ) {
</P><PRE> var moveVector = {
   x: pointer.pageX - this.pointerDownPointer.pageX,
   y: pointer.pageY - this.pointerDownPointer.pageY
 };
 // start drag if pointer has moved far enough to start drag
 if ( !this.isDragging &amp;&amp; this.hasDragStarted( moveVector ) ) {
   this._dragStart( event, pointer );
 }
 return moveVector;
</PRE><P>};
</P><P>// condition if pointer has moved far enough to start drag
proto.hasDragStarted = function( moveVector ) {
</P><PRE> return Math.abs( moveVector.x ) &gt; 3 || Math.abs( moveVector.y ) &gt; 3;
</PRE><P>};
</P><P>// ----- end event ----- //
</P><P>/**
</P><PRE>* pointer up
* @param {Event} event
* @param {Event or Touch} pointer
*/
</PRE><P>proto.pointerUp = function( event, pointer ) {
</P><PRE> this.emitEvent( 'pointerUp', [ event, pointer ] );
 this._dragPointerUp( event, pointer );
</PRE><P>};
</P><P>proto._dragPointerUp = function( event, pointer ) {
</P><PRE> if ( this.isDragging ) {
   this._dragEnd( event, pointer );
 } else {
   // pointer didn't move enough for drag to start
   this._staticClick( event, pointer );
 }
</PRE><P>};
</P><P>// -------------------------- drag -------------------------- //
</P><P>// dragStart
proto._dragStart = function( event, pointer ) {
</P><PRE> this.isDragging = true;
 // prevent clicks
 this.isPreventingClicks = true;
 this.dragStart( event, pointer );
</PRE><P>};
</P><P>proto.dragStart = function( event, pointer ) {
</P><PRE> this.emitEvent( 'dragStart', [ event, pointer ] );
</PRE><P>};
</P><P>// dragMove
proto._dragMove = function( event, pointer, moveVector ) {
</P><PRE> // do not drag if not dragging yet
 if ( !this.isDragging ) {
   return;
 }
</PRE><PRE> this.dragMove( event, pointer, moveVector );
</PRE><P>};
</P><P>proto.dragMove = function( event, pointer, moveVector ) {
</P><PRE> event.preventDefault();
 this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );
</PRE><P>};
</P><P>// dragEnd
proto._dragEnd = function( event, pointer ) {
</P><PRE> // set flags
 this.isDragging = false;
 // re-enable clicking async
 setTimeout( function() {
   delete this.isPreventingClicks;
 }.bind( this ) );
</PRE><PRE> this.dragEnd( event, pointer );
</PRE><P>};
</P><P>proto.dragEnd = function( event, pointer ) {
</P><PRE> this.emitEvent( 'dragEnd', [ event, pointer ] );
</PRE><P>};
</P><P>// ----- onclick ----- //
</P><P>// handle all clicks and prevent clicks when dragging
proto.onclick = function( event ) {
</P><PRE> if ( this.isPreventingClicks ) {
   event.preventDefault();
 }
</PRE><P>};
</P><P>// ----- staticClick ----- //
</P><P>// triggered after pointer down &amp; up with no/tiny movement
proto._staticClick = function( event, pointer ) {
</P><PRE> // ignore emulated mouse up clicks
 if ( this.isIgnoringMouseUp &amp;&amp; event.type == 'mouseup' ) {
   return;
 }
</PRE><PRE> this.staticClick( event, pointer );
</PRE><PRE> // set flag for emulated clicks 300ms after touchend
 if ( event.type != 'mouseup' ) {
   this.isIgnoringMouseUp = true;
   // reset flag after 300ms
   setTimeout( function() {
     delete this.isIgnoringMouseUp;
   }.bind( this ), 400 );
 }
</PRE><P>};
</P><P>proto.staticClick = function( event, pointer ) {
</P><PRE> this.emitEvent( 'staticClick', [ event, pointer ] );
</PRE><P>};
</P><P>// ----- utils ----- //
</P><P>Unidragger.getPointerPoint = Unipointer.getPointerPoint;
</P><P>// -----  ----- //
</P><P>return Unidragger;
</P><P>}));
</P><P>// drag
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/drag',[
     './flickity',
     'unidragger/unidragger',
     'fizzy-ui-utils/utils'
   ], function( Flickity, Unidragger, utils ) {
     return factory( window, Flickity, Unidragger, utils );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('./flickity'),
     require('unidragger'),
     require('fizzy-ui-utils')
   );
 } else {
   // browser global
   window.Flickity = factory(
     window,
     window.Flickity,
     window.Unidragger,
     window.fizzyUIUtils
   );
 }
</PRE><P>}( window, function factory( window, Flickity, Unidragger, utils ) {
</P><P>// ----- defaults ----- //
</P><P>utils.extend( Flickity.defaults, {
</P><PRE> draggable: '&gt;1',
 dragThreshold: 3,
</PRE><P>});
</P><P>// ----- create ----- //
</P><P>Flickity.createMethods.push('_createDrag');
</P><P>// -------------------------- drag prototype -------------------------- //
</P><P>var proto = Flickity.prototype;
utils.extend( proto, Unidragger.prototype );
proto._touchActionValue = 'pan-y';
</P><P>// --------------------------  -------------------------- //
</P><P>var isTouch = 'createTouch' in document;
var isTouchmoveScrollCanceled = false;
</P><P>proto._createDrag = function() {
</P><PRE> this.on( 'activate', this.onActivateDrag );
 this.on( 'uiChange', this._uiChangeDrag );
 this.on( 'childUIPointerDown', this._childUIPointerDownDrag );
 this.on( 'deactivate', this.onDeactivateDrag );
 this.on( 'cellChange', this.updateDraggable );
 // TODO updateDraggable on resize? if groupCells &amp; slides change
 // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior
 // #457, RubaXa/Sortable#973
 if ( isTouch &amp;&amp; !isTouchmoveScrollCanceled ) {
   window.addEventListener( 'touchmove', function() {});
   isTouchmoveScrollCanceled = true;
 }
</PRE><P>};
</P><P>proto.onActivateDrag = function() {
</P><PRE> this.handles = [ this.viewport ];
 this.bindHandles();
 this.updateDraggable();
</PRE><P>};
</P><P>proto.onDeactivateDrag = function() {
</P><PRE> this.unbindHandles();
 this.element.classList.remove('is-draggable');
</PRE><P>};
</P><P>proto.updateDraggable = function() {
</P><PRE> // disable dragging if less than 2 slides. #278
 if ( this.options.draggable == '&gt;1' ) {
   this.isDraggable = this.slides.length &gt; 1;
 } else {
   this.isDraggable = this.options.draggable;
 }
 if ( this.isDraggable ) {
   this.element.classList.add('is-draggable');
 } else {
   this.element.classList.remove('is-draggable');
 }
</PRE><P>};
</P><P>// backwards compatibility
proto.bindDrag = function() {
</P><PRE> this.options.draggable = true;
 this.updateDraggable();
</PRE><P>};
</P><P>proto.unbindDrag = function() {
</P><PRE> this.options.draggable = false;
 this.updateDraggable();
</PRE><P>};
</P><P>proto._uiChangeDrag = function() {
</P><PRE> delete this.isFreeScrolling;
</PRE><P>};
</P><P>proto._childUIPointerDownDrag = function( event ) {
</P><PRE> // allow focus &amp; preventDefault even when not draggable
 // so child UI elements keep focus on carousel. #721
 event.preventDefault();
 this.pointerDownFocus( event );
</PRE><P>};
</P><P>// -------------------------- pointer events -------------------------- //
</P><P>proto.pointerDown = function( event, pointer ) {
</P><PRE> if ( !this.isDraggable ) {
   this._pointerDownDefault( event, pointer );
   return;
 }
 var isOkay = this.okayPointerDown( event );
 if ( !isOkay ) {
   return;
 }
</PRE><PRE> this._pointerDownPreventDefault( event );
 this.pointerDownFocus( event );
 // blur
 if ( document.activeElement != this.element ) {
   // do not blur if already focused
   this.pointerDownBlur();
 }
</PRE><PRE> // stop if it was moving
 this.dragX = this.x;
 this.viewport.classList.add('is-pointer-down');
 // track scrolling
 this.pointerDownScroll = getScrollPosition();
 window.addEventListener( 'scroll', this );
</PRE><PRE> this._pointerDownDefault( event, pointer );
</PRE><P>};
</P><P>// default pointerDown logic, used for staticClick
proto._pointerDownDefault = function( event, pointer ) {
</P><PRE> // track start event position
 this.pointerDownPointer = pointer;
 // bind move and end events
 this._bindPostStartEvents( event );
 this.dispatchEvent( 'pointerDown', event, [ pointer ] );
</PRE><P>};
</P><P>var focusNodes = {
</P><PRE> INPUT: true,
 TEXTAREA: true,
 SELECT: true,
</PRE><P>};
</P><P>proto.pointerDownFocus = function( event ) {
</P><PRE> var isFocusNode = focusNodes[ event.target.nodeName ];
 if ( !isFocusNode ) {
   this.focus();
 }
</PRE><P>};
</P><P>proto._pointerDownPreventDefault = function( event ) {
</P><PRE> var isTouchStart = event.type == 'touchstart';
 var isTouchPointer = event.pointerType == 'touch';
 var isFocusNode = focusNodes[ event.target.nodeName ];
 if ( !isTouchStart &amp;&amp; !isTouchPointer &amp;&amp; !isFocusNode ) {
   event.preventDefault();
 }
</PRE><P>};
</P><P>// ----- move ----- //
</P><P>proto.hasDragStarted = function( moveVector ) {
</P><PRE> return Math.abs( moveVector.x ) &gt; this.options.dragThreshold;
</PRE><P>};
</P><P>// ----- up ----- //
</P><P>proto.pointerUp = function( event, pointer ) {
</P><PRE> delete this.isTouchScrolling;
 this.viewport.classList.remove('is-pointer-down');
 this.dispatchEvent( 'pointerUp', event, [ pointer ] );
 this._dragPointerUp( event, pointer );
</PRE><P>};
</P><P>proto.pointerDone = function() {
</P><PRE> window.removeEventListener( 'scroll', this );
 delete this.pointerDownScroll;
</PRE><P>};
</P><P>// -------------------------- dragging -------------------------- //
</P><P>proto.dragStart = function( event, pointer ) {
</P><PRE> if ( !this.isDraggable ) {
   return;
 }
 this.dragStartPosition = this.x;
 this.startAnimation();
 window.removeEventListener( 'scroll', this );
 this.dispatchEvent( 'dragStart', event, [ pointer ] );
</PRE><P>};
</P><P>proto.pointerMove = function( event, pointer ) {
</P><PRE> var moveVector = this._dragPointerMove( event, pointer );
 this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );
 this._dragMove( event, pointer, moveVector );
</PRE><P>};
</P><P>proto.dragMove = function( event, pointer, moveVector ) {
</P><PRE> if ( !this.isDraggable ) {
   return;
 }
 event.preventDefault();
</PRE><PRE> this.previousDragX = this.dragX;
 // reverse if right-to-left
 var direction = this.options.rightToLeft ? -1 : 1;
 if ( this.options.wrapAround ) {
   // wrap around move. #589
   moveVector.x = moveVector.x % this.slideableWidth;
 }
 var dragX = this.dragStartPosition + moveVector.x * direction;
</PRE><PRE> if ( !this.options.wrapAround &amp;&amp; this.slides.length ) {
   // slow drag
   var originBound = Math.max( -this.slides[0].target, this.dragStartPosition );
   dragX = dragX &gt; originBound ? ( dragX + originBound ) * 0.5 : dragX;
   var endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );
   dragX = dragX &lt; endBound ? ( dragX + endBound ) * 0.5 : dragX;
 }
</PRE><PRE> this.dragX = dragX;
</PRE><PRE> this.dragMoveTime = new Date();
 this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );
</PRE><P>};
</P><P>proto.dragEnd = function( event, pointer ) {
</P><PRE> if ( !this.isDraggable ) {
   return;
 }
 if ( this.options.freeScroll ) {
   this.isFreeScrolling = true;
 }
 // set selectedIndex based on where flick will end up
 var index = this.dragEndRestingSelect();
</PRE><PRE> if ( this.options.freeScroll &amp;&amp; !this.options.wrapAround ) {
   // if free-scroll &amp; not wrap around
   // do not free-scroll if going outside of bounding slides
   // so bounding slides can attract slider, and keep it in bounds
   var restingX = this.getRestingPosition();
   this.isFreeScrolling = -restingX &gt; this.slides[0].target &amp;&amp;
     -restingX &lt; this.getLastSlide().target;
 } else if ( !this.options.freeScroll &amp;&amp; index == this.selectedIndex ) {
   // boost selection if selected index has not changed
   index += this.dragEndBoostSelect();
 }
 delete this.previousDragX;
 // apply selection
 // TODO refactor this, selecting here feels weird
 // HACK, set flag so dragging stays in correct direction
 this.isDragSelect = this.options.wrapAround;
 this.select( index );
 delete this.isDragSelect;
 this.dispatchEvent( 'dragEnd', event, [ pointer ] );
</PRE><P>};
</P><P>proto.dragEndRestingSelect = function() {
</P><PRE> var restingX = this.getRestingPosition();
 // how far away from selected slide
 var distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );
 // get closet resting going up and going down
 var positiveResting = this._getClosestResting( restingX, distance, 1 );
 var negativeResting = this._getClosestResting( restingX, distance, -1 );
 // use closer resting for wrap-around
 var index = positiveResting.distance &lt; negativeResting.distance ?
   positiveResting.index : negativeResting.index;
 return index;
</PRE><P>};
</P><P>/**
</P><PRE>* given resting X and distance to selected cell
* get the distance and index of the closest cell
* @param {Number} restingX - estimated post-flick resting position
* @param {Number} distance - distance to selected cell
* @param {Integer} increment - +1 or -1, going up or down
* @returns {Object} - { distance: {Number}, index: {Integer} }
*/
</PRE><P>proto._getClosestResting = function( restingX, distance, increment ) {
</P><PRE> var index = this.selectedIndex;
 var minDistance = Infinity;
 var condition = this.options.contain &amp;&amp; !this.options.wrapAround ?
   // if contain, keep going if distance is equal to minDistance
   function( d, md ) { return d &lt;= md; } : function( d, md ) { return d &lt; md; };
 while ( condition( distance, minDistance ) ) {
   // measure distance to next cell
   index += increment;
   minDistance = distance;
   distance = this.getSlideDistance( -restingX, index );
   if ( distance === null ) {
     break;
   }
   distance = Math.abs( distance );
 }
 return {
   distance: minDistance,
   // selected was previous index
   index: index - increment
 };
</PRE><P>};
</P><P>/**
</P><PRE>* measure distance between x and a slide target
* @param {Number} x
* @param {Integer} index - slide index
*/
</PRE><P>proto.getSlideDistance = function( x, index ) {
</P><PRE> var len = this.slides.length;
 // wrap around if at least 2 slides
 var isWrapAround = this.options.wrapAround &amp;&amp; len &gt; 1;
 var slideIndex = isWrapAround ? utils.modulo( index, len ) : index;
 var slide = this.slides[ slideIndex ];
 if ( !slide ) {
   return null;
 }
 // add distance for wrap-around slides
 var wrap = isWrapAround ? this.slideableWidth * Math.floor( index / len ) : 0;
 return x - ( slide.target + wrap );
</PRE><P>};
</P><P>proto.dragEndBoostSelect = function() {
</P><PRE> // do not boost if no previousDragX or dragMoveTime
 if ( this.previousDragX === undefined || !this.dragMoveTime ||
   // or if drag was held for 100 ms
   new Date() - this.dragMoveTime &gt; 100 ) {
   return 0;
 }
</PRE><PRE> var distance = this.getSlideDistance( -this.dragX, this.selectedIndex );
 var delta = this.previousDragX - this.dragX;
 if ( distance &gt; 0 &amp;&amp; delta &gt; 0 ) {
   // boost to next if moving towards the right, and positive velocity
   return 1;
 } else if ( distance &lt; 0 &amp;&amp; delta &lt; 0 ) {
   // boost to previous if moving towards the left, and negative velocity
   return -1;
 }
 return 0;
</PRE><P>};
</P><P>// ----- staticClick ----- //
</P><P>proto.staticClick = function( event, pointer ) {
</P><PRE> // get clickedCell, if cell was clicked
 var clickedCell = this.getParentCell( event.target );
 var cellElem = clickedCell &amp;&amp; clickedCell.element;
 var cellIndex = clickedCell &amp;&amp; this.cells.indexOf( clickedCell );
 this.dispatchEvent( 'staticClick', event, [ pointer, cellElem, cellIndex ] );
</PRE><P>};
</P><P>// ----- scroll ----- //
</P><P>proto.onscroll = function() {
</P><PRE> var scroll = getScrollPosition();
 var scrollMoveX = this.pointerDownScroll.x - scroll.x;
 var scrollMoveY = this.pointerDownScroll.y - scroll.y;
 // cancel click/tap if scroll is too much
 if ( Math.abs( scrollMoveX ) &gt; 3 || Math.abs( scrollMoveY ) &gt; 3 ) {
   this._pointerDone();
 }
</PRE><P>};
</P><P>// ----- utils ----- //
</P><P>function getScrollPosition() {
</P><PRE> return {
   x: window.pageXOffset,
   y: window.pageYOffset
 };
</PRE><P>}
</P><P>// -----  ----- //
</P><P>return Flickity;
</P><P>}));
</P><P>/*!
</P><PRE>* Tap listener v2.0.0
* listens to taps
* MIT license
*/
</PRE><P>/*jshint browser: true, unused: true, undef: true, strict: true */
</P><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /*jshint strict: false*/ /*globals define, module, require */
</PRE><PRE> if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'tap-listener/tap-listener',[
     'unipointer/unipointer'
   ], function( Unipointer ) {
     return factory( window, Unipointer );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('unipointer')
   );
 } else {
   // browser global
   window.TapListener = factory(
     window,
     window.Unipointer
   );
 }
</PRE><P>}( window, function factory( window, Unipointer ) {
</P><P>// --------------------------  TapListener -------------------------- //
</P><P>function TapListener( elem ) {
</P><PRE> this.bindTap( elem );
</PRE><P>}
</P><P>// inherit Unipointer &amp; EventEmitter
var proto = TapListener.prototype = Object.create( Unipointer.prototype );
</P><P>/**
</P><PRE>* bind tap event to element
* @param {Element} elem
*/
</PRE><P>proto.bindTap = function( elem ) {
</P><PRE> if ( !elem ) {
   return;
 }
 this.unbindTap();
 this.tapElement = elem;
 this._bindStartEvent( elem, true );
</PRE><P>};
</P><P>proto.unbindTap = function() {
</P><PRE> if ( !this.tapElement ) {
   return;
 }
 this._bindStartEvent( this.tapElement, true );
 delete this.tapElement;</PRE><P>};
</P><P>/**
</P><PRE>* pointer up
* @param {Event} event
* @param {Event or Touch} pointer
*/
</PRE><P>proto.pointerUp = function( event, pointer ) {
</P><PRE> // ignore emulated mouse up clicks
 if ( this.isIgnoringMouseUp &amp;&amp; event.type == 'mouseup' ) {
   return;
 }
</PRE><PRE> var pointerPoint = Unipointer.getPointerPoint( pointer );
 var boundingRect = this.tapElement.getBoundingClientRect();
 var scrollX = window.pageXOffset;
 var scrollY = window.pageYOffset;
 // calculate if pointer is inside tapElement
 var isInside = pointerPoint.x &gt;= boundingRect.left + scrollX &amp;&amp;
   pointerPoint.x &lt;= boundingRect.right + scrollX &amp;&amp;
   pointerPoint.y &gt;= boundingRect.top + scrollY &amp;&amp;
   pointerPoint.y &lt;= boundingRect.bottom + scrollY;
 // trigger callback if pointer is inside element
 if ( isInside ) {
   this.emitEvent( 'tap', [ event, pointer ] );
 }
</PRE><PRE> // set flag for emulated clicks 300ms after touchend
 if ( event.type != 'mouseup' ) {
   this.isIgnoringMouseUp = true;
   // reset flag after 300ms
   var _this = this;
   setTimeout( function() {
     delete _this.isIgnoringMouseUp;
   }, 400 );
 }
</PRE><P>};
</P><P>proto.destroy = function() {
</P><PRE> this.pointerDone();
 this.unbindTap();
</PRE><P>};
</P><P>// -----  ----- //
</P><P>return TapListener;
</P><P>}));
</P><P>// prev/next buttons
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/prev-next-button',[
     './flickity',
     'tap-listener/tap-listener',
     'fizzy-ui-utils/utils'
   ], function( Flickity, TapListener, utils ) {
     return factory( window, Flickity, TapListener, utils );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('./flickity'),
     require('tap-listener'),
     require('fizzy-ui-utils')
   );
 } else {
   // browser global
   factory(
     window,
     window.Flickity,
     window.TapListener,
     window.fizzyUIUtils
   );
 }
</PRE><P>}( window, function factory( window, Flickity, TapListener, utils ) {
'use strict';
</P><P>var svgURI = '<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg'">http://www.w3.org/2000/svg'</A>;
</P><P>// -------------------------- PrevNextButton -------------------------- //
</P><P>function PrevNextButton( direction, parent ) {
</P><PRE> this.direction = direction;
 this.parent = parent;
 this._create();
</PRE><P>}
</P><P>PrevNextButton.prototype = Object.create( TapListener.prototype );
</P><P>PrevNextButton.prototype._create = function() {
</P><PRE> // properties
 this.isEnabled = true;
 this.isPrevious = this.direction == -1;
 var leftDirection = this.parent.options.rightToLeft ? 1 : -1;
 this.isLeft = this.direction == leftDirection;
</PRE><PRE> var element = this.element = document.createElement('button');
 element.className = 'flickity-button flickity-prev-next-button';
 element.className += this.isPrevious ? ' previous' : ' next';
 // prevent button from submitting form <A rel="nofollow" class="external free" href="http://stackoverflow.com/a/10836076/182183">http://stackoverflow.com/a/10836076/182183</A>
 element.setAttribute( 'type', 'button' );
 // init as disabled
 this.disable();
</PRE><PRE> element.setAttribute( 'aria-label', this.isPrevious ? 'Previous' : 'Next' );
</PRE><PRE> // create arrow
 var svg = this.createSVG();
 element.appendChild( svg );
 // events
 this.on( 'tap', this.onTap );
 this.parent.on( 'select', this.update.bind( this ) );
 this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );
</PRE><P>};
</P><P>PrevNextButton.prototype.activate = function() {
</P><PRE> this.bindTap( this.element );
 // click events from keyboard
 this.element.addEventListener( 'click', this );
 // add to DOM
 this.parent.element.appendChild( this.element );
</PRE><P>};
</P><P>PrevNextButton.prototype.deactivate = function() {
</P><PRE> // remove from DOM
 this.parent.element.removeChild( this.element );
 // do regular TapListener destroy
 TapListener.prototype.destroy.call( this );
 // click events from keyboard
 this.element.removeEventListener( 'click', this );
</PRE><P>};
</P><P>PrevNextButton.prototype.createSVG = function() {
</P><PRE> var svg = document.createElementNS( svgURI, 'svg');
 svg.setAttribute( 'class', 'flickity-button-icon' );
 svg.setAttribute( 'viewBox', '0 0 100 100' );
 var path = document.createElementNS( svgURI, 'path');
 var pathMovements = getArrowMovements( this.parent.options.arrowShape );
 path.setAttribute( 'd', pathMovements );
 path.setAttribute( 'class', 'arrow' );
 // rotate arrow
 if ( !this.isLeft ) {
   path.setAttribute( 'transform', 'translate(100, 100) rotate(180) ' );
 }
 svg.appendChild( path );
 return svg;
</PRE><P>};
</P><P>// get SVG path movmement
function getArrowMovements( shape ) {
</P><PRE> // use shape as movement if string
 if ( typeof shape == 'string' ) {
   return shape;
 }
 // create movement string
 return 'M ' + shape.x0 + ',50' +
   ' L ' + shape.x1 + ',' + ( shape.y1 + 50 ) +
   ' L ' + shape.x2 + ',' + ( shape.y2 + 50 ) +
   ' L ' + shape.x3 + ',50 ' +
   ' L ' + shape.x2 + ',' + ( 50 - shape.y2 ) +
   ' L ' + shape.x1 + ',' + ( 50 - shape.y1 ) +
   ' Z';
</PRE><P>}
</P><P>PrevNextButton.prototype.onTap = function() {
</P><PRE> if ( !this.isEnabled ) {
   return;
 }
 this.parent.uiChange();
 var method = this.isPrevious ? 'previous' : 'next';
 this.parent[ method ]();
</PRE><P>};
</P><P>PrevNextButton.prototype.handleEvent = utils.handleEvent;
</P><P>PrevNextButton.prototype.onclick = function( event ) {
</P><PRE> // only allow clicks from keyboard
 var focused = document.activeElement;
 if ( focused &amp;&amp; focused == this.element ) {
   this.onTap( event, event );
 }
</PRE><P>};
</P><P>// -----  ----- //
</P><P>PrevNextButton.prototype.enable = function() {
</P><PRE> if ( this.isEnabled ) {
   return;
 }
 this.element.disabled = false;
 this.isEnabled = true;
</PRE><P>};
</P><P>PrevNextButton.prototype.disable = function() {
</P><PRE> if ( !this.isEnabled ) {
   return;
 }
 this.element.disabled = true;
 this.isEnabled = false;
</PRE><P>};
</P><P>PrevNextButton.prototype.update = function() {
</P><PRE> // index of first or last slide, if previous or next
 var slides = this.parent.slides;
 // enable is wrapAround and at least 2 slides
 if ( this.parent.options.wrapAround &amp;&amp; slides.length &gt; 1 ) {
   this.enable();
   return;
 }
 var lastIndex = slides.length ? slides.length - 1 : 0;
 var boundIndex = this.isPrevious ? 0 : lastIndex;
 var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';
 this[ method ]();
</PRE><P>};
</P><P>PrevNextButton.prototype.destroy = function() {
</P><PRE> this.deactivate();
</PRE><P>};
</P><P>// -------------------------- Flickity prototype -------------------------- //
</P><P>utils.extend( Flickity.defaults, {
</P><PRE> prevNextButtons: true,
 arrowShape: {
   x0: 10,
   x1: 60, y1: 50,
   x2: 70, y2: 40,
   x3: 30
 }
</PRE><P>});
</P><P>Flickity.createMethods.push('_createPrevNextButtons');
var proto = Flickity.prototype;
</P><P>proto._createPrevNextButtons = function() {
</P><PRE> if ( !this.options.prevNextButtons ) {
   return;
 }
</PRE><PRE> this.prevButton = new PrevNextButton( -1, this );
 this.nextButton = new PrevNextButton( 1, this );
</PRE><PRE> this.on( 'activate', this.activatePrevNextButtons );
</PRE><P>};
</P><P>proto.activatePrevNextButtons = function() {
</P><PRE> this.prevButton.activate();
 this.nextButton.activate();
 this.on( 'deactivate', this.deactivatePrevNextButtons );
</PRE><P>};
</P><P>proto.deactivatePrevNextButtons = function() {
</P><PRE> this.prevButton.deactivate();
 this.nextButton.deactivate();
 this.off( 'deactivate', this.deactivatePrevNextButtons );
</PRE><P>};
</P><P>// --------------------------  -------------------------- //
</P><P>Flickity.PrevNextButton = PrevNextButton;</P><P>return Flickity;
</P><P>}));
</P><P>// page dots
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/page-dots',[
     './flickity',
     'tap-listener/tap-listener',
     'fizzy-ui-utils/utils'
   ], function( Flickity, TapListener, utils ) {
     return factory( window, Flickity, TapListener, utils );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('./flickity'),
     require('tap-listener'),
     require('fizzy-ui-utils')
   );
 } else {
   // browser global
   factory(
     window,
     window.Flickity,
     window.TapListener,
     window.fizzyUIUtils
   );
 }
</PRE><P>}( window, function factory( window, Flickity, TapListener, utils ) {
</P><P>// -------------------------- PageDots -------------------------- //
</P><P>function PageDots( parent ) {
</P><PRE> this.parent = parent;
 this._create();
</PRE><P>}
</P><P>PageDots.prototype = new TapListener();
</P><P>PageDots.prototype._create = function() {
</P><PRE> // create holder element
 this.holder = document.createElement('ol');
 this.holder.className = 'flickity-page-dots';
 // create dots, array of elements
 this.dots = [];
 // events
 this.on( 'tap', this.onTap );
 this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );
</PRE><P>};
</P><P>PageDots.prototype.activate = function() {
</P><PRE> this.setDots();
 this.bindTap( this.holder );
 // add to DOM
 this.parent.element.appendChild( this.holder );
</PRE><P>};
</P><P>PageDots.prototype.deactivate = function() {
</P><PRE> // remove from DOM
 this.parent.element.removeChild( this.holder );
 TapListener.prototype.destroy.call( this );
</PRE><P>};
</P><P>PageDots.prototype.setDots = function() {
</P><PRE> // get difference between number of slides and number of dots
 var delta = this.parent.slides.length - this.dots.length;
 if ( delta &gt; 0 ) {
   this.addDots( delta );
 } else if ( delta &lt; 0 ) {
   this.removeDots( -delta );
 }
</PRE><P>};
</P><P>PageDots.prototype.addDots = function( count ) {
</P><PRE> var fragment = document.createDocumentFragment();
 var newDots = [];
 var length = this.dots.length;
 var max = length + count;
</PRE><PRE> for ( var i = length; i &lt; max; i++ ) {
   var dot = document.createElement('li');
   dot.className = 'dot';
   dot.setAttribute( 'aria-label', 'Page dot ' + ( i + 1 ) );
   fragment.appendChild( dot );
   newDots.push( dot );
 }
</PRE><PRE> this.holder.appendChild( fragment );
 this.dots = this.dots.concat( newDots );
</PRE><P>};
</P><P>PageDots.prototype.removeDots = function( count ) {
</P><PRE> // remove from this.dots collection
 var removeDots = this.dots.splice( this.dots.length - count, count );
 // remove from DOM
 removeDots.forEach( function( dot ) {
   this.holder.removeChild( dot );
 }, this );
</PRE><P>};
</P><P>PageDots.prototype.updateSelected = function() {
</P><PRE> // remove selected class on previous
 if ( this.selectedDot ) {
   this.selectedDot.className = 'dot';
   this.selectedDot.removeAttribute('aria-current');
 }
 // don't proceed if no dots
 if ( !this.dots.length ) {
   return;
 }
 this.selectedDot = this.dots[ this.parent.selectedIndex ];
 this.selectedDot.className = 'dot is-selected';
 this.selectedDot.setAttribute( 'aria-current', 'step' );
</PRE><P>};
</P><P>PageDots.prototype.onTap = function( event ) {
</P><PRE> var target = event.target;
 // only care about dot clicks
 if ( target.nodeName != 'LI' ) {
   return;
 }
</PRE><PRE> this.parent.uiChange();
 var index = this.dots.indexOf( target );
 this.parent.select( index );
</PRE><P>};
</P><P>PageDots.prototype.destroy = function() {
</P><PRE> this.deactivate();
</PRE><P>};
</P><P>Flickity.PageDots = PageDots;
</P><P>// -------------------------- Flickity -------------------------- //
</P><P>utils.extend( Flickity.defaults, {
</P><PRE> pageDots: true
</PRE><P>});
</P><P>Flickity.createMethods.push('_createPageDots');
</P><P>var proto = Flickity.prototype;
</P><P>proto._createPageDots = function() {
</P><PRE> if ( !this.options.pageDots ) {
   return;
 }
 this.pageDots = new PageDots( this );
 // events
 this.on( 'activate', this.activatePageDots );
 this.on( 'select', this.updateSelectedPageDots );
 this.on( 'cellChange', this.updatePageDots );
 this.on( 'resize', this.updatePageDots );
 this.on( 'deactivate', this.deactivatePageDots );
</PRE><P>};
</P><P>proto.activatePageDots = function() {
</P><PRE> this.pageDots.activate();
</PRE><P>};
</P><P>proto.updateSelectedPageDots = function() {
</P><PRE> this.pageDots.updateSelected();
</PRE><P>};
</P><P>proto.updatePageDots = function() {
</P><PRE> this.pageDots.setDots();
</PRE><P>};
</P><P>proto.deactivatePageDots = function() {
</P><PRE> this.pageDots.deactivate();
</PRE><P>};
</P><P>// -----  ----- //
</P><P>Flickity.PageDots = PageDots;
</P><P>return Flickity;
</P><P>}));
</P><P>// player &amp; autoPlay
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/player',[
     'ev-emitter/ev-emitter',
     'fizzy-ui-utils/utils',
     './flickity'
   ], function( EvEmitter, utils, Flickity ) {
     return factory( EvEmitter, utils, Flickity );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     require('ev-emitter'),
     require('fizzy-ui-utils'),
     require('./flickity')
   );
 } else {
   // browser global
   factory(
     window.EvEmitter,
     window.fizzyUIUtils,
     window.Flickity
   );
 }
</PRE><P>}( window, function factory( EvEmitter, utils, Flickity ) {
</P><P>// -------------------------- Player -------------------------- //
</P><P>function Player( parent ) {
</P><PRE> this.parent = parent;
 this.state = 'stopped';
 // visibility change event handler
 this.onVisibilityChange = this.visibilityChange.bind( this );
 this.onVisibilityPlay = this.visibilityPlay.bind( this );
</PRE><P>}
</P><P>Player.prototype = Object.create( EvEmitter.prototype );
</P><P>// start play
Player.prototype.play = function() {
</P><PRE> if ( this.state == 'playing' ) {
   return;
 }
 // do not play if page is hidden, start playing when page is visible
 var isPageHidden = document.hidden;
 if ( isPageHidden ) {
   document.addEventListener( 'visibilitychange', this.onVisibilityPlay );
   return;
 }
</PRE><PRE> this.state = 'playing';
 // listen to visibility change
 document.addEventListener( 'visibilitychange', this.onVisibilityChange );
 // start ticking
 this.tick();
</PRE><P>};
</P><P>Player.prototype.tick = function() {
</P><PRE> // do not tick if not playing
 if ( this.state != 'playing' ) {
   return;
 }
</PRE><PRE> var time = this.parent.options.autoPlay;
 // default to 3 seconds
 time = typeof time == 'number' ? time : 3000;
 var _this = this;
 // HACK: reset ticks if stopped and started within interval
 this.clear();
 this.timeout = setTimeout( function() {
   _this.parent.next( true );
   _this.tick();
 }, time );
</PRE><P>};
</P><P>Player.prototype.stop = function() {
</P><PRE> this.state = 'stopped';
 this.clear();
 // remove visibility change event
 document.removeEventListener( 'visibilitychange', this.onVisibilityChange );
</PRE><P>};
</P><P>Player.prototype.clear = function() {
</P><PRE> clearTimeout( this.timeout );
</PRE><P>};
</P><P>Player.prototype.pause = function() {
</P><PRE> if ( this.state == 'playing' ) {
   this.state = 'paused';
   this.clear();
 }
</PRE><P>};
</P><P>Player.prototype.unpause = function() {
</P><PRE> // re-start play if paused
 if ( this.state == 'paused' ) {
   this.play();
 }
</PRE><P>};
</P><P>// pause if page visibility is hidden, unpause if visible
Player.prototype.visibilityChange = function() {
</P><PRE> var isPageHidden = document.hidden;
 this[ isPageHidden ? 'pause' : 'unpause' ]();
</PRE><P>};
</P><P>Player.prototype.visibilityPlay = function() {
</P><PRE> this.play();
 document.removeEventListener( 'visibilitychange', this.onVisibilityPlay );
</PRE><P>};
</P><P>// -------------------------- Flickity -------------------------- //
</P><P>utils.extend( Flickity.defaults, {
</P><PRE> pauseAutoPlayOnHover: true
</PRE><P>});
</P><P>Flickity.createMethods.push('_createPlayer');
var proto = Flickity.prototype;
</P><P>proto._createPlayer = function() {
</P><PRE> this.player = new Player( this );
</PRE><PRE> this.on( 'activate', this.activatePlayer );
 this.on( 'uiChange', this.stopPlayer );
 this.on( 'pointerDown', this.stopPlayer );
 this.on( 'deactivate', this.deactivatePlayer );
</PRE><P>};
</P><P>proto.activatePlayer = function() {
</P><PRE> if ( !this.options.autoPlay ) {
   return;
 }
 this.player.play();
 this.element.addEventListener( 'mouseenter', this );
</PRE><P>};
</P><P>// Player API, don't hate the ... thanks I know where the door is
</P><P>proto.playPlayer = function() {
</P><PRE> this.player.play();
</PRE><P>};
</P><P>proto.stopPlayer = function() {
</P><PRE> this.player.stop();
</PRE><P>};
</P><P>proto.pausePlayer = function() {
</P><PRE> this.player.pause();
</PRE><P>};
</P><P>proto.unpausePlayer = function() {
</P><PRE> this.player.unpause();
</PRE><P>};
</P><P>proto.deactivatePlayer = function() {
</P><PRE> this.player.stop();
 this.element.removeEventListener( 'mouseenter', this );
</PRE><P>};
</P><P>// ----- mouseenter/leave ----- //
</P><P>// pause auto-play on hover
proto.onmouseenter = function() {
</P><PRE> if ( !this.options.pauseAutoPlayOnHover ) {
   return;
 }
 this.player.pause();
 this.element.addEventListener( 'mouseleave', this );
</PRE><P>};
</P><P>// resume auto-play on hover off
proto.onmouseleave = function() {
</P><PRE> this.player.unpause();
 this.element.removeEventListener( 'mouseleave', this );
</PRE><P>};
</P><P>// -----  ----- //
</P><P>Flickity.Player = Player;
</P><P>return Flickity;
</P><P>}));
</P><P>// add, remove cell
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/add-remove-cell',[
     './flickity',
     'fizzy-ui-utils/utils'
   ], function( Flickity, utils ) {
     return factory( window, Flickity, utils );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('./flickity'),
     require('fizzy-ui-utils')
   );
 } else {
   // browser global
   factory(
     window,
     window.Flickity,
     window.fizzyUIUtils
   );
 }
</PRE><P>}( window, function factory( window, Flickity, utils ) {
</P><P>// append cells to a document fragment
function getCellsFragment( cells ) {
</P><PRE> var fragment = document.createDocumentFragment();
 cells.forEach( function( cell ) {
   fragment.appendChild( cell.element );
 });
 return fragment;
</PRE><P>}
</P><P>// -------------------------- add/remove cell prototype -------------------------- //
</P><P>var proto = Flickity.prototype;
</P><P>/**
</P><PRE>* Insert, prepend, or append cells
* @param {Element, Array, NodeList} elems
* @param {Integer} index
*/
</PRE><P>proto.insert = function( elems, index ) {
</P><PRE> var cells = this._makeCells( elems );
 if ( !cells || !cells.length ) {
   return;
 }
 var len = this.cells.length;
 // default to append
 index = index === undefined ? len : index;
 // add cells with document fragment
 var fragment = getCellsFragment( cells );
 // append to slider
 var isAppend = index == len;
 if ( isAppend ) {
   this.slider.appendChild( fragment );
 } else {
   var insertCellElement = this.cells[ index ].element;
   this.slider.insertBefore( fragment, insertCellElement );
 }
 // add to this.cells
 if ( index === 0 ) {
   // prepend, add to start
   this.cells = cells.concat( this.cells );
 } else if ( isAppend ) {
   // append, add to end
   this.cells = this.cells.concat( cells );
 } else {
   // insert in this.cells
   var endCells = this.cells.splice( index, len - index );
   this.cells = this.cells.concat( cells ).concat( endCells );
 }
</PRE><PRE> this._sizeCells( cells );
 this.cellChange( index, true );
</PRE><P>};
</P><P>proto.append = function( elems ) {
</P><PRE> this.insert( elems, this.cells.length );
</PRE><P>};
</P><P>proto.prepend = function( elems ) {
</P><PRE> this.insert( elems, 0 );
</PRE><P>};
</P><P>/**
</P><PRE>* Remove cells
* @param {Element, Array, NodeList} elems
*/
</PRE><P>proto.remove = function( elems ) {
</P><PRE> var cells = this.getCells( elems );
 if ( !cells || !cells.length ) {
   return;
 }
</PRE><PRE> var minCellIndex = this.cells.length - 1;
 // remove cells from collection &amp; DOM
 cells.forEach( function( cell ) {
   cell.remove();
   var index = this.cells.indexOf( cell );
   minCellIndex = Math.min( index, minCellIndex );
   utils.removeFrom( this.cells, cell );
 }, this );
</PRE><PRE> this.cellChange( minCellIndex, true );
</PRE><P>};
</P><P>/**
</P><PRE>* logic to be run after a cell's size changes
* @param {Element} elem - cell's element
*/
</PRE><P>proto.cellSizeChange = function( elem ) {
</P><PRE> var cell = this.getCell( elem );
 if ( !cell ) {
   return;
 }
 cell.getSize();
</PRE><PRE> var index = this.cells.indexOf( cell );
 this.cellChange( index );
</PRE><P>};
</P><P>/**
</P><PRE>* logic any time a cell is changed: added, removed, or size changed
* @param {Integer} changedCellIndex - index of the changed cell, optional
*/
</PRE><P>proto.cellChange = function( changedCellIndex, isPositioningSlider ) {
</P><PRE> var prevSelectedElem = this.selectedElement;
 this._positionCells( changedCellIndex );
 this._getWrapShiftCells();
 this.setGallerySize();
 // update selectedIndex
 // try to maintain position &amp; select previous selected element
 var cell = this.getCell( prevSelectedElem );
 if ( cell ) {
   this.selectedIndex = this.getCellSlideIndex( cell );
 }
 this.selectedIndex = Math.min( this.slides.length - 1, this.selectedIndex );
</PRE><PRE> this.emitEvent( 'cellChange', [ changedCellIndex ] );
 // position slider
 this.select( this.selectedIndex );
 // do not position slider after lazy load
 if ( isPositioningSlider ) {
   this.positionSliderAtSelected();
 }
</PRE><P>};
</P><P>// -----  ----- //
</P><P>return Flickity;
</P><P>}));
</P><P>// lazyload
( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/lazyload',[
     './flickity',
     'fizzy-ui-utils/utils'
   ], function( Flickity, utils ) {
     return factory( window, Flickity, utils );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('./flickity'),
     require('fizzy-ui-utils')
   );
 } else {
   // browser global
   factory(
     window,
     window.Flickity,
     window.fizzyUIUtils
   );
 }
</PRE><P>}( window, function factory( window, Flickity, utils ) {
'use strict';
</P><P>Flickity.createMethods.push('_createLazyload');
var proto = Flickity.prototype;
</P><P>proto._createLazyload = function() {
</P><PRE> this.on( 'select', this.lazyLoad );
</PRE><P>};
</P><P>proto.lazyLoad = function() {
</P><PRE> var lazyLoad = this.options.lazyLoad;
 if ( !lazyLoad ) {
   return;
 }
 // get adjacent cells, use lazyLoad option for adjacent count
 var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;
 var cellElems = this.getAdjacentCellElements( adjCount );
 // get lazy images in those cells
 var lazyImages = [];
 cellElems.forEach( function( cellElem ) {
   var lazyCellImages = getCellLazyImages( cellElem );
   lazyImages = lazyImages.concat( lazyCellImages );
 });
 // load lazy images
 lazyImages.forEach( function( img ) {
   new LazyLoader( img, this );
 }, this );
</PRE><P>};
</P><P>function getCellLazyImages( cellElem ) {
</P><PRE> // check if cell element is lazy image
 if ( cellElem.nodeName == 'IMG' ) {
   var lazyloadAttr = cellElem.getAttribute('data-flickity-lazyload');
   var srcAttr = cellElem.getAttribute('data-flickity-lazyload-src');
   var srcsetAttr = cellElem.getAttribute('data-flickity-lazyload-srcset');
   if ( lazyloadAttr || srcAttr || srcsetAttr ) {
     return [ cellElem ];
   }
 }
 // select lazy images in cell
 var lazySelector = 'img[data-flickity-lazyload], ' +
   'img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]';
 var imgs = cellElem.querySelectorAll( lazySelector );
 return utils.makeArray( imgs );
</PRE><P>}
</P><P>// -------------------------- LazyLoader -------------------------- //
</P><P>/**
</P><PRE>* class to handle loading images
*/
</PRE><P>function LazyLoader( img, flickity ) {
</P><PRE> this.img = img;
 this.flickity = flickity;
 this.load();
</PRE><P>}
</P><P>LazyLoader.prototype.handleEvent = utils.handleEvent;
</P><P>LazyLoader.prototype.load = function() {
</P><PRE> this.img.addEventListener( 'load', this );
 this.img.addEventListener( 'error', this );
 // get src &amp; srcset
 var src = this.img.getAttribute('data-flickity-lazyload') ||
   this.img.getAttribute('data-flickity-lazyload-src');
 var srcset = this.img.getAttribute('data-flickity-lazyload-srcset');
 // set src &amp; serset
 this.img.src = src;
 if ( srcset ) {
   this.img.setAttribute( 'srcset', srcset );
 }
 // remove attr
 this.img.removeAttribute('data-flickity-lazyload');
 this.img.removeAttribute('data-flickity-lazyload-src');
 this.img.removeAttribute('data-flickity-lazyload-srcset');
</PRE><P>};
</P><P>LazyLoader.prototype.onload = function( event ) {
</P><PRE> this.complete( event, 'flickity-lazyloaded' );
</PRE><P>};
</P><P>LazyLoader.prototype.onerror = function( event ) {
</P><PRE> this.complete( event, 'flickity-lazyerror' );
</PRE><P>};
</P><P>LazyLoader.prototype.complete = function( event, className ) {
</P><PRE> // unbind events
 this.img.removeEventListener( 'load', this );
 this.img.removeEventListener( 'error', this );
</PRE><PRE> var cell = this.flickity.getParentCell( this.img );
 var cellElem = cell &amp;&amp; cell.element;
 this.flickity.cellSizeChange( cellElem );
</PRE><PRE> this.img.classList.add( className );
 this.flickity.dispatchEvent( 'lazyLoad', event, cellElem );
</PRE><P>};
</P><P>// -----  ----- //
</P><P>Flickity.LazyLoader = LazyLoader;
</P><P>return Flickity;
</P><P>}));
</P><P>/*!
</P><PRE>* Flickity v2.1.2
* Touch, responsive, flickable carousels
*
* Licensed GPLv3 for open source use
* or Flickity Commercial License for commercial use
*
* <A rel="nofollow" class="external free" href="https://flickity.metafizzy.co">https://flickity.metafizzy.co</A>
* Copyright 2015-2018 Metafizzy
*/
</PRE><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /* jshint strict: false */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity/js/index',[
     './flickity',
     './drag',
     './prev-next-button',
     './page-dots',
     './player',
     './add-remove-cell',
     './lazyload'
   ], factory );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     require('./flickity'),
     require('./drag'),
     require('./prev-next-button'),
     require('./page-dots'),
     require('./player'),
     require('./add-remove-cell'),
     require('./lazyload')
   );
 }
</PRE><P>})( window, function factory( Flickity ) {
</P><PRE> /*jshint strict: false*/
 return Flickity;
</PRE><P>});
</P><P>/*!
</P><PRE>* Flickity asNavFor v2.0.1
* enable asNavFor for Flickity
*/
</PRE><P>/*jshint browser: true, undef: true, unused: true, strict: true*/
</P><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /*jshint strict: false */ /*globals define, module, require */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'flickity-as-nav-for/as-nav-for',[
     'flickity/js/index',
     'fizzy-ui-utils/utils'
   ], factory );
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     require('flickity'),
     require('fizzy-ui-utils')
   );
 } else {
   // browser global
   window.Flickity = factory(
     window.Flickity,
     window.fizzyUIUtils
   );
 }
</PRE><P>}( window, function factory( Flickity, utils ) {
</P><P>// -------------------------- asNavFor prototype -------------------------- //
</P><P>// Flickity.defaults.asNavFor = null;
</P><P>Flickity.createMethods.push('_createAsNavFor');
</P><P>var proto = Flickity.prototype;
</P><P>proto._createAsNavFor = function() {
</P><PRE> this.on( 'activate', this.activateAsNavFor );
 this.on( 'deactivate', this.deactivateAsNavFor );
 this.on( 'destroy', this.destroyAsNavFor );
</PRE><PRE> var asNavForOption = this.options.asNavFor;
 if ( !asNavForOption ) {
   return;
 }
 // HACK do async, give time for other flickity to be initalized
 var _this = this;
 setTimeout( function initNavCompanion() {
   _this.setNavCompanion( asNavForOption );
 });
</PRE><P>};
</P><P>proto.setNavCompanion = function( elem ) {
</P><PRE> elem = utils.getQueryElement( elem );
 var companion = Flickity.data( elem );
 // stop if no companion or companion is self
 if ( !companion || companion == this ) {
   return;
 }
</PRE><PRE> this.navCompanion = companion;
 // companion select
 var _this = this;
 this.onNavCompanionSelect = function() {
   _this.navCompanionSelect();
 };
 companion.on( 'select', this.onNavCompanionSelect );
 // click
 this.on( 'staticClick', this.onNavStaticClick );
</PRE><PRE> this.navCompanionSelect( true );
</PRE><P>};
</P><P>proto.navCompanionSelect = function( isInstant ) {
</P><PRE> if ( !this.navCompanion ) {
   return;
 }
 // select slide that matches first cell of slide
 var selectedCell = this.navCompanion.selectedCells[0];
 var firstIndex = this.navCompanion.cells.indexOf( selectedCell );
 var lastIndex = firstIndex + this.navCompanion.selectedCells.length - 1;
 var selectIndex = Math.floor( lerp( firstIndex, lastIndex,
   this.navCompanion.cellAlign ) );
 this.selectCell( selectIndex, false, isInstant );
 // set nav selected class
 this.removeNavSelectedElements();
 // stop if companion has more cells than this one
 if ( selectIndex &gt;= this.cells.length ) {
   return;
 }
</PRE><PRE> var selectedCells = this.cells.slice( firstIndex, lastIndex + 1 );
 this.navSelectedElements = selectedCells.map( function( cell ) {
   return cell.element;
 });
 this.changeNavSelectedClass('add');
</PRE><P>};
</P><P>function lerp( a, b, t ) {
</P><PRE> return ( b - a ) * t + a;
</PRE><P>}
</P><P>proto.changeNavSelectedClass = function( method ) {
</P><PRE> this.navSelectedElements.forEach( function( navElem ) {
   navElem.classList[ method ]('is-nav-selected');
 });
</PRE><P>};
</P><P>proto.activateAsNavFor = function() {
</P><PRE> this.navCompanionSelect( true );
</PRE><P>};
</P><P>proto.removeNavSelectedElements = function() {
</P><PRE> if ( !this.navSelectedElements ) {
   return;
 }
 this.changeNavSelectedClass('remove');
 delete this.navSelectedElements;
</PRE><P>};
</P><P>proto.onNavStaticClick = function( event, pointer, cellElement, cellIndex ) {
</P><PRE> if ( typeof cellIndex == 'number' ) {
   this.navCompanion.selectCell( cellIndex );
 }
</PRE><P>};
</P><P>proto.deactivateAsNavFor = function() {
</P><PRE> this.removeNavSelectedElements();
</PRE><P>};
</P><P>proto.destroyAsNavFor = function() {
</P><PRE> if ( !this.navCompanion ) {
   return;
 }
 this.navCompanion.off( 'select', this.onNavCompanionSelect );
 this.off( 'staticClick', this.onNavStaticClick );
 delete this.navCompanion;
</PRE><P>};
</P><P>// -----  ----- //
</P><P>return Flickity;
</P><P>}));
</P><P>/*!
</P><PRE>* imagesLoaded v4.1.4
* JavaScript is all like &quot;You images are done yet or what?&quot;
* MIT License
*/
</PRE><P>( function( window, factory ) { 'use strict';
</P><PRE> // universal module definition
</PRE><PRE> /*global define: false, module: false, require: false */
</PRE><PRE> if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( 'imagesloaded/imagesloaded',[
     'ev-emitter/ev-emitter'
   ], function( EvEmitter ) {
     return factory( window, EvEmitter );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('ev-emitter')
   );
 } else {
   // browser global
   window.imagesLoaded = factory(
     window,
     window.EvEmitter
   );
 }
</PRE><P>})( typeof window !== 'undefined' ? window : this,
</P><P>// --------------------------  factory -------------------------- //
</P><P>function factory( window, EvEmitter ) {
</P><P>var $ = window.jQuery;
var console = window.console;
</P><P>// -------------------------- helpers -------------------------- //
</P><P>// extend objects
function extend( a, b ) {
</P><PRE> for ( var prop in b ) {
   a[ prop ] = b[ prop ];
 }
 return a;
</PRE><P>}
</P><P>var arraySlice = Array.prototype.slice;
</P><P>// turn element or nodeList into an array
function makeArray( obj ) {
</P><PRE> if ( Array.isArray( obj ) ) {
   // use object if already an array
   return obj;
 }
</PRE><PRE> var isArrayLike = typeof obj == 'object' &amp;&amp; typeof obj.length == 'number';
 if ( isArrayLike ) {
   // convert nodeList to array
   return arraySlice.call( obj );
 }
</PRE><PRE> // array of single index
 return [ obj ];
</PRE><P>}
</P><P>// -------------------------- imagesLoaded -------------------------- //
</P><P>/**
</P><PRE>* @param {Array, Element, NodeList, String} elem
* @param {Object or Function} options - if function, use as callback
* @param {Function} onAlways - callback function
*/
</PRE><P>function ImagesLoaded( elem, options, onAlways ) {
</P><PRE> // coerce ImagesLoaded() without new, to be new ImagesLoaded()
 if ( !( this instanceof ImagesLoaded ) ) {
   return new ImagesLoaded( elem, options, onAlways );
 }
 // use elem as selector string
 var queryElem = elem;
 if ( typeof elem == 'string' ) {
   queryElem = document.querySelectorAll( elem );
 }
 // bail if bad element
 if ( !queryElem ) {
   console.error( 'Bad element for imagesLoaded ' + ( queryElem || elem ) );
   return;
 }
</PRE><PRE> this.elements = makeArray( queryElem );
 this.options = extend( {}, this.options );
 // shift arguments if no options set
 if ( typeof options == 'function' ) {
   onAlways = options;
 } else {
   extend( this.options, options );
 }
</PRE><PRE> if ( onAlways ) {
   this.on( 'always', onAlways );
 }
</PRE><PRE> this.getImages();
</PRE><PRE> if ( $ ) {
   // add jQuery Deferred object
   this.jqDeferred = new $.Deferred();
 }
</PRE><PRE> // HACK check async to allow time to bind listeners
 setTimeout( this.check.bind( this ) );
</PRE><P>}
</P><P>ImagesLoaded.prototype = Object.create( EvEmitter.prototype );
</P><P>ImagesLoaded.prototype.options = {};
</P><P>ImagesLoaded.prototype.getImages = function() {
</P><PRE> this.images = [];
</PRE><PRE> // filter &amp; find items if we have an item selector
 this.elements.forEach( this.addElementImages, this );
</PRE><P>};
</P><P>/**
</P><PRE>* @param {Node} element
*/
</PRE><P>ImagesLoaded.prototype.addElementImages = function( elem ) {
</P><PRE> // filter siblings
 if ( elem.nodeName == 'IMG' ) {
   this.addImage( elem );
 }
 // get background image on element
 if ( this.options.background === true ) {
   this.addElementBackgroundImages( elem );
 }
</PRE><PRE> // find children
 // no non-element nodes, #143
 var nodeType = elem.nodeType;
 if ( !nodeType || !elementNodeTypes[ nodeType ] ) {
   return;
 }
 var childImgs = elem.querySelectorAll('img');
 // concat childElems to filterFound array
 for ( var i=0; i &lt; childImgs.length; i++ ) {
   var img = childImgs[i];
   this.addImage( img );
 }
</PRE><PRE> // get child background images
 if ( typeof this.options.background == 'string' ) {
   var children = elem.querySelectorAll( this.options.background );
   for ( i=0; i &lt; children.length; i++ ) {
     var child = children[i];
     this.addElementBackgroundImages( child );
   }
 }
</PRE><P>};
</P><P>var elementNodeTypes = {
</P><PRE> 1: true,
 9: true,
 11: true
</PRE><P>};
</P><P>ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
</P><PRE> var style = getComputedStyle( elem );
 if ( !style ) {
   // Firefox returns null if in a hidden iframe <A rel="nofollow" class="external free" href="https://bugzil.la/548397">https://bugzil.la/548397</A>
   return;
 }
 // get url inside url(&quot;...&quot;)
 var reURL = /url\((['&quot;])?(.*?)\1\)/gi;
 var matches = reURL.exec( style.backgroundImage );
 while ( matches !== null ) {
   var url = matches &amp;&amp; matches[2];
   if ( url ) {
     this.addBackground( url, elem );
   }
   matches = reURL.exec( style.backgroundImage );
 }
</PRE><P>};
</P><P>/**
</P><PRE>* @param {Image} img
*/
</PRE><P>ImagesLoaded.prototype.addImage = function( img ) {
</P><PRE> var loadingImage = new LoadingImage( img );
 this.images.push( loadingImage );
</PRE><P>};
</P><P>ImagesLoaded.prototype.addBackground = function( url, elem ) {
</P><PRE> var background = new Background( url, elem );
 this.images.push( background );
</PRE><P>};
</P><P>ImagesLoaded.prototype.check = function() {
</P><PRE> var _this = this;
 this.progressedCount = 0;
 this.hasAnyBroken = false;
 // complete if no images
 if ( !this.images.length ) {
   this.complete();
   return;
 }
</PRE><PRE> function onProgress( image, elem, message ) {
   // HACK - Chrome triggers event before object properties have changed. #83
   setTimeout( function() {
     _this.progress( image, elem, message );
   });
 }
</PRE><PRE> this.images.forEach( function( loadingImage ) {
   loadingImage.once( 'progress', onProgress );
   loadingImage.check();
 });
</PRE><P>};
</P><P>ImagesLoaded.prototype.progress = function( image, elem, message ) {
</P><PRE> this.progressedCount++;
 this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
 // progress event
 this.emitEvent( 'progress', [ this, image, elem ] );
 if ( this.jqDeferred &amp;&amp; this.jqDeferred.notify ) {
   this.jqDeferred.notify( this, image );
 }
 // check if completed
 if ( this.progressedCount == this.images.length ) {
   this.complete();
 }
</PRE><PRE> if ( this.options.debug &amp;&amp; console ) {
   console.log( 'progress: ' + message, image, elem );
 }
</PRE><P>};
</P><P>ImagesLoaded.prototype.complete = function() {
</P><PRE> var eventName = this.hasAnyBroken ? 'fail' : 'done';
 this.isComplete = true;
 this.emitEvent( eventName, [ this ] );
 this.emitEvent( 'always', [ this ] );
 if ( this.jqDeferred ) {
   var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
   this.jqDeferred[ jqMethod ]( this );
 }
</PRE><P>};
</P><P>// --------------------------  -------------------------- //
</P><P>function LoadingImage( img ) {
</P><PRE> this.img = img;
</PRE><P>}
</P><P>LoadingImage.prototype = Object.create( EvEmitter.prototype );
</P><P>LoadingImage.prototype.check = function() {
</P><PRE> // If complete is true and browser supports natural sizes,
 // try to check for image status manually.
 var isComplete = this.getIsImageComplete();
 if ( isComplete ) {
   // report based on naturalWidth
   this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
   return;
 }
</PRE><PRE> // If none of the checks above matched, simulate loading on detached element.
 this.proxyImage = new Image();
 this.proxyImage.addEventListener( 'load', this );
 this.proxyImage.addEventListener( 'error', this );
 // bind to image as well for Firefox. #191
 this.img.addEventListener( 'load', this );
 this.img.addEventListener( 'error', this );
 this.proxyImage.src = this.img.src;
</PRE><P>};
</P><P>LoadingImage.prototype.getIsImageComplete = function() {
</P><PRE> // check for non-zero, non-undefined naturalWidth
 // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
 return this.img.complete &amp;&amp; this.img.naturalWidth;
</PRE><P>};
</P><P>LoadingImage.prototype.confirm = function( isLoaded, message ) {
</P><PRE> this.isLoaded = isLoaded;
 this.emitEvent( 'progress', [ this, this.img, message ] );
</PRE><P>};
</P><P>// ----- events ----- //
</P><P>// trigger specified handler for event type
LoadingImage.prototype.handleEvent = function( event ) {
</P><PRE> var method = 'on' + event.type;
 if ( this[ method ] ) {
   this[ method ]( event );
 }
</PRE><P>};
</P><P>LoadingImage.prototype.onload = function() {
</P><PRE> this.confirm( true, 'onload' );
 this.unbindEvents();
</PRE><P>};
</P><P>LoadingImage.prototype.onerror = function() {
</P><PRE> this.confirm( false, 'onerror' );
 this.unbindEvents();
</PRE><P>};
</P><P>LoadingImage.prototype.unbindEvents = function() {
</P><PRE> this.proxyImage.removeEventListener( 'load', this );
 this.proxyImage.removeEventListener( 'error', this );
 this.img.removeEventListener( 'load', this );
 this.img.removeEventListener( 'error', this );
</PRE><P>};
</P><P>// -------------------------- Background -------------------------- //
</P><P>function Background( url, element ) {
</P><PRE> this.url = url;
 this.element = element;
 this.img = new Image();
</PRE><P>}
</P><P>// inherit LoadingImage prototype
Background.prototype = Object.create( LoadingImage.prototype );
</P><P>Background.prototype.check = function() {
</P><PRE> this.img.addEventListener( 'load', this );
 this.img.addEventListener( 'error', this );
 this.img.src = this.url;
 // check if image is already complete
 var isComplete = this.getIsImageComplete();
 if ( isComplete ) {
   this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
   this.unbindEvents();
 }
</PRE><P>};
</P><P>Background.prototype.unbindEvents = function() {
</P><PRE> this.img.removeEventListener( 'load', this );
 this.img.removeEventListener( 'error', this );
</PRE><P>};
</P><P>Background.prototype.confirm = function( isLoaded, message ) {
</P><PRE> this.isLoaded = isLoaded;
 this.emitEvent( 'progress', [ this, this.element, message ] );
</PRE><P>};
</P><P>// -------------------------- jQuery -------------------------- //
</P><P>ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
</P><PRE> jQuery = jQuery || window.jQuery;
 if ( !jQuery ) {
   return;
 }
 // set local variable
 $ = jQuery;
 // $().imagesLoaded()
 $.fn.imagesLoaded = function( options, callback ) {
   var instance = new ImagesLoaded( this, options, callback );
   return instance.jqDeferred.promise( $(this) );
 };
</PRE><P>};
// try making plugin
ImagesLoaded.makeJQueryPlugin();
</P><P>// --------------------------  -------------------------- //
</P><P>return ImagesLoaded;
</P><P>});
</P><P>/*!
</P><PRE>* Flickity imagesLoaded v2.0.0
* enables imagesLoaded option for Flickity
*/
</PRE><P>/*jshint browser: true, strict: true, undef: true, unused: true */
</P><P>( function( window, factory ) {
</P><PRE> // universal module definition
 /*jshint strict: false */ /*globals define, module, require */
 if ( typeof define == 'function' &amp;&amp; define.amd ) {
   // AMD
   define( [
     'flickity/js/index',
     'imagesloaded/imagesloaded'
   ], function( Flickity, imagesLoaded ) {
     return factory( window, Flickity, imagesLoaded );
   });
 } else if ( typeof module == 'object' &amp;&amp; module.exports ) {
   // CommonJS
   module.exports = factory(
     window,
     require('flickity'),
     require('imagesloaded')
   );
 } else {
   // browser global
   window.Flickity = factory(
     window,
     window.Flickity,
     window.imagesLoaded
   );
 }
</PRE><P>}( window, function factory( window, Flickity, imagesLoaded ) {
'use strict';
</P><P>Flickity.createMethods.push('_createImagesLoaded');
</P><P>var proto = Flickity.prototype;
</P><P>proto._createImagesLoaded = function() {
</P><PRE> this.on( 'activate', this.imagesLoaded );
</PRE><P>};
</P><P>proto.imagesLoaded = function() {
</P><PRE> if ( !this.options.imagesLoaded ) {
   return;
 }
 var _this = this;
 function onImagesLoadedProgress( instance, image ) {
   var cell = _this.getParentCell( image.img );
   _this.cellSizeChange( cell &amp;&amp; cell.element );
   if ( !_this.options.freeScroll ) {
     _this.positionSliderAtSelected();
   }
 }
 imagesLoaded( this.slider ).on( 'progress', onImagesLoadedProgress );
</PRE><P>};
</P><P>return Flickity;
</P><P>}));
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
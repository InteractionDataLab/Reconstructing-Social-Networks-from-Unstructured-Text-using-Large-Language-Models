<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Cornell_d3JS skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Cornell/d3JS</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>// <A rel="nofollow" class="external free" href="https://d3js.org">https://d3js.org</A> v5.7.0 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' &amp;&amp; define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';
</P><P>var version = &quot;5.7.0&quot;;
</P><P>function ascending(a, b) {
</P><PRE> return a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN;
</PRE><P>}
</P><P>function bisector(compare) {
</P><PRE> if (compare.length === 1) compare = ascendingComparator(compare);
 return {
   left: function(a, x, lo, hi) {
     if (lo == null) lo = 0;
     if (hi == null) hi = a.length;
     while (lo &lt; hi) {
       var mid = lo + hi &gt;&gt;&gt; 1;
       if (compare(a[mid], x) &lt; 0) lo = mid + 1;
       else hi = mid;
     }
     return lo;
   },
   right: function(a, x, lo, hi) {
     if (lo == null) lo = 0;
     if (hi == null) hi = a.length;
     while (lo &lt; hi) {
       var mid = lo + hi &gt;&gt;&gt; 1;
       if (compare(a[mid], x) &gt; 0) hi = mid;
       else lo = mid + 1;
     }
     return lo;
   }
 };
</PRE><P>}
</P><P>function ascendingComparator(f) {
</P><PRE> return function(d, x) {
   return ascending(f(d), x);
 };
</PRE><P>}
</P><P>var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
</P><P>function pairs(array, f) {
</P><PRE> if (f == null) f = pair;
 var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n &lt; 0 ? 0 : n);
 while (i &lt; n) pairs[i] = f(p, p = array[++i]);
 return pairs;
</PRE><P>}
</P><P>function pair(a, b) {
</P><PRE> return [a, b];
</PRE><P>}
</P><P>function cross(values0, values1, reduce) {
</P><PRE> var n0 = values0.length,
     n1 = values1.length,
     values = new Array(n0 * n1),
     i0,
     i1,
     i,
     value0;
</PRE><PRE> if (reduce == null) reduce = pair;
</PRE><PRE> for (i0 = i = 0; i0 &lt; n0; ++i0) {
   for (value0 = values0[i0], i1 = 0; i1 &lt; n1; ++i1, ++i) {
     values[i] = reduce(value0, values1[i1]);
   }
 }
</PRE><PRE> return values;
</PRE><P>}
</P><P>function descending(a, b) {
</P><PRE> return b &lt; a ? -1 : b &gt; a ? 1 : b &gt;= a ? 0 : NaN;
</PRE><P>}
</P><P>function number(x) {
</P><PRE> return x === null ? NaN : +x;
</PRE><P>}
</P><P>function variance(values, valueof) {
</P><PRE> var n = values.length,
     m = 0,
     i = -1,
     mean = 0,
     value,
     delta,
     sum = 0;
</PRE><PRE> if (valueof == null) {
   while (++i &lt; n) {
     if (!isNaN(value = number(values[i]))) {
       delta = value - mean;
       mean += delta / ++m;
       sum += delta * (value - mean);
     }
   }
 }
</PRE><PRE> else {
   while (++i &lt; n) {
     if (!isNaN(value = number(valueof(values[i], i, values)))) {
       delta = value - mean;
       mean += delta / ++m;
       sum += delta * (value - mean);
     }
   }
 }
</PRE><PRE> if (m &gt; 1) return sum / (m - 1);
</PRE><P>}
</P><P>function deviation(array, f) {
</P><PRE> var v = variance(array, f);
 return v ? Math.sqrt(v) : v;
</PRE><P>}
</P><P>function extent(values, valueof) {
</P><PRE> var n = values.length,
     i = -1,
     value,
     min,
     max;
</PRE><PRE> if (valueof == null) {
   while (++i &lt; n) { // Find the first comparable value.
     if ((value = values[i]) != null &amp;&amp; value &gt;= value) {
       min = max = value;
       while (++i &lt; n) { // Compare the remaining values.
         if ((value = values[i]) != null) {
           if (min &gt; value) min = value;
           if (max &lt; value) max = value;
         }
       }
     }
   }
 }
</PRE><PRE> else {
   while (++i &lt; n) { // Find the first comparable value.
     if ((value = valueof(values[i], i, values)) != null &amp;&amp; value &gt;= value) {
       min = max = value;
       while (++i &lt; n) { // Compare the remaining values.
         if ((value = valueof(values[i], i, values)) != null) {
           if (min &gt; value) min = value;
           if (max &lt; value) max = value;
         }
       }
     }
   }
 }
</PRE><PRE> return [min, max];
</PRE><P>}
</P><P>var array = Array.prototype;
</P><P>var slice = array.slice;
var map = array.map;
</P><P>function constant(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function identity(x) {
</P><PRE> return x;
</PRE><P>}
</P><P>function sequence(start, stop, step) {
</P><PRE> start = +start, stop = +stop, step = (n = arguments.length) &lt; 2 ? (stop = start, start = 0, 1) : n &lt; 3 ? 1 : +step;
</PRE><PRE> var i = -1,
     n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
     range = new Array(n);
</PRE><PRE> while (++i &lt; n) {
   range[i] = start + i * step;
 }
</PRE><PRE> return range;
</PRE><P>}
</P><P>var e10 = Math.sqrt(50),
</P><PRE>   e5 = Math.sqrt(10),
   e2 = Math.sqrt(2);
</PRE><P>function ticks(start, stop, count) {
</P><PRE> var reverse,
     i = -1,
     n,
     ticks,
     step;
</PRE><PRE> stop = +stop, start = +start, count = +count;
 if (start === stop &amp;&amp; count &gt; 0) return [start];
 if (reverse = stop &lt; start) n = start, start = stop, stop = n;
 if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];
</PRE><PRE> if (step &gt; 0) {
   start = Math.ceil(start / step);
   stop = Math.floor(stop / step);
   ticks = new Array(n = Math.ceil(stop - start + 1));
   while (++i &lt; n) ticks[i] = (start + i) * step;
 } else {
   start = Math.floor(start * step);
   stop = Math.ceil(stop * step);
   ticks = new Array(n = Math.ceil(start - stop + 1));
   while (++i &lt; n) ticks[i] = (start - i) / step;
 }
</PRE><PRE> if (reverse) ticks.reverse();
</PRE><PRE> return ticks;
</PRE><P>}
</P><P>function tickIncrement(start, stop, count) {
</P><PRE> var step = (stop - start) / Math.max(0, count),
     power = Math.floor(Math.log(step) / Math.LN10),
     error = step / Math.pow(10, power);
 return power &gt;= 0
     ? (error &gt;= e10 ? 10 : error &gt;= e5 ? 5 : error &gt;= e2 ? 2 : 1) * Math.pow(10, power)
     : -Math.pow(10, -power) / (error &gt;= e10 ? 10 : error &gt;= e5 ? 5 : error &gt;= e2 ? 2 : 1);
</PRE><P>}
</P><P>function tickStep(start, stop, count) {
</P><PRE> var step0 = Math.abs(stop - start) / Math.max(0, count),
     step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
     error = step0 / step1;
 if (error &gt;= e10) step1 *= 10;
 else if (error &gt;= e5) step1 *= 5;
 else if (error &gt;= e2) step1 *= 2;
 return stop &lt; start ? -step1 : step1;
</PRE><P>}
</P><P>function thresholdSturges(values) {
</P><PRE> return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
</PRE><P>}
</P><P>function histogram() {
</P><PRE> var value = identity,
     domain = extent,
     threshold = thresholdSturges;
</PRE><PRE> function histogram(data) {
   var i,
       n = data.length,
       x,
       values = new Array(n);
</PRE><PRE>   for (i = 0; i &lt; n; ++i) {
     values[i] = value(data[i], i, data);
   }
</PRE><PRE>   var xz = domain(values),
       x0 = xz[0],
       x1 = xz[1],
       tz = threshold(values, x0, x1);
</PRE><PRE>   // Convert number of thresholds into uniform thresholds.
   if (!Array.isArray(tz)) {
     tz = tickStep(x0, x1, tz);
     tz = sequence(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
   }
</PRE><PRE>   // Remove any thresholds outside the domain.
   var m = tz.length;
   while (tz[0] &lt;= x0) tz.shift(), --m;
   while (tz[m - 1] &gt; x1) tz.pop(), --m;
</PRE><PRE>   var bins = new Array(m + 1),
       bin;
</PRE><PRE>   // Initialize bins.
   for (i = 0; i &lt;= m; ++i) {
     bin = bins[i] = [];
     bin.x0 = i &gt; 0 ? tz[i - 1] : x0;
     bin.x1 = i &lt; m ? tz[i] : x1;
   }
</PRE><PRE>   // Assign data to bins by value, ignoring any outside the domain.
   for (i = 0; i &lt; n; ++i) {
     x = values[i];
     if (x0 &lt;= x &amp;&amp; x &lt;= x1) {
       bins[bisectRight(tz, x, 0, m)].push(data[i]);
     }
   }
</PRE><PRE>   return bins;
 }
</PRE><PRE> histogram.value = function(_) {
   return arguments.length ? (value = typeof _ === &quot;function&quot; ? _ : constant(_), histogram) : value;
 };
</PRE><PRE> histogram.domain = function(_) {
   return arguments.length ? (domain = typeof _ === &quot;function&quot; ? _ : constant([_[0], _[1]]), histogram) : domain;
 };
</PRE><PRE> histogram.thresholds = function(_) {
   return arguments.length ? (threshold = typeof _ === &quot;function&quot; ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
 };
</PRE><PRE> return histogram;
</PRE><P>}
</P><P>function threshold(values, p, valueof) {
</P><PRE> if (valueof == null) valueof = number;
 if (!(n = values.length)) return;
 if ((p = +p) &lt;= 0 || n &lt; 2) return +valueof(values[0], 0, values);
 if (p &gt;= 1) return +valueof(values[n - 1], n - 1, values);
 var n,
     i = (n - 1) * p,
     i0 = Math.floor(i),
     value0 = +valueof(values[i0], i0, values),
     value1 = +valueof(values[i0 + 1], i0 + 1, values);
 return value0 + (value1 - value0) * (i - i0);
</PRE><P>}
</P><P>function freedmanDiaconis(values, min, max) {
</P><PRE> values = map.call(values, number).sort(ascending);
 return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));
</PRE><P>}
</P><P>function scott(values, min, max) {
</P><PRE> return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
</PRE><P>}
</P><P>function max(values, valueof) {
</P><PRE> var n = values.length,
     i = -1,
     value,
     max;
</PRE><PRE> if (valueof == null) {
   while (++i &lt; n) { // Find the first comparable value.
     if ((value = values[i]) != null &amp;&amp; value &gt;= value) {
       max = value;
       while (++i &lt; n) { // Compare the remaining values.
         if ((value = values[i]) != null &amp;&amp; value &gt; max) {
           max = value;
         }
       }
     }
   }
 }
</PRE><PRE> else {
   while (++i &lt; n) { // Find the first comparable value.
     if ((value = valueof(values[i], i, values)) != null &amp;&amp; value &gt;= value) {
       max = value;
       while (++i &lt; n) { // Compare the remaining values.
         if ((value = valueof(values[i], i, values)) != null &amp;&amp; value &gt; max) {
           max = value;
         }
       }
     }
   }
 }
</PRE><PRE> return max;
</PRE><P>}
</P><P>function mean(values, valueof) {
</P><PRE> var n = values.length,
     m = n,
     i = -1,
     value,
     sum = 0;
</PRE><PRE> if (valueof == null) {
   while (++i &lt; n) {
     if (!isNaN(value = number(values[i]))) sum += value;
     else --m;
   }
 }
</PRE><PRE> else {
   while (++i &lt; n) {
     if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
     else --m;
   }
 }
</PRE><PRE> if (m) return sum / m;
</PRE><P>}
</P><P>function median(values, valueof) {
</P><PRE> var n = values.length,
     i = -1,
     value,
     numbers = [];
</PRE><PRE> if (valueof == null) {
   while (++i &lt; n) {
     if (!isNaN(value = number(values[i]))) {
       numbers.push(value);
     }
   }
 }
</PRE><PRE> else {
   while (++i &lt; n) {
     if (!isNaN(value = number(valueof(values[i], i, values)))) {
       numbers.push(value);
     }
   }
 }
</PRE><PRE> return threshold(numbers.sort(ascending), 0.5);
</PRE><P>}
</P><P>function merge(arrays) {
</P><PRE> var n = arrays.length,
     m,
     i = -1,
     j = 0,
     merged,
     array;
</PRE><PRE> while (++i &lt; n) j += arrays[i].length;
 merged = new Array(j);
</PRE><PRE> while (--n &gt;= 0) {
   array = arrays[n];
   m = array.length;
   while (--m &gt;= 0) {
     merged[--j] = array[m];
   }
 }
</PRE><PRE> return merged;
</PRE><P>}
</P><P>function min(values, valueof) {
</P><PRE> var n = values.length,
     i = -1,
     value,
     min;
</PRE><PRE> if (valueof == null) {
   while (++i &lt; n) { // Find the first comparable value.
     if ((value = values[i]) != null &amp;&amp; value &gt;= value) {
       min = value;
       while (++i &lt; n) { // Compare the remaining values.
         if ((value = values[i]) != null &amp;&amp; min &gt; value) {
           min = value;
         }
       }
     }
   }
 }
</PRE><PRE> else {
   while (++i &lt; n) { // Find the first comparable value.
     if ((value = valueof(values[i], i, values)) != null &amp;&amp; value &gt;= value) {
       min = value;
       while (++i &lt; n) { // Compare the remaining values.
         if ((value = valueof(values[i], i, values)) != null &amp;&amp; min &gt; value) {
           min = value;
         }
       }
     }
   }
 }
</PRE><PRE> return min;
</PRE><P>}
</P><P>function permute(array, indexes) {
</P><PRE> var i = indexes.length, permutes = new Array(i);
 while (i--) permutes[i] = array[indexes[i]];
 return permutes;
</PRE><P>}
</P><P>function scan(values, compare) {
</P><PRE> if (!(n = values.length)) return;
 var n,
     i = 0,
     j = 0,
     xi,
     xj = values[j];
</PRE><PRE> if (compare == null) compare = ascending;
</PRE><PRE> while (++i &lt; n) {
   if (compare(xi = values[i], xj) &lt; 0 || compare(xj, xj) !== 0) {
     xj = xi, j = i;
   }
 }
</PRE><PRE> if (compare(xj, xj) === 0) return j;
</PRE><P>}
</P><P>function shuffle(array, i0, i1) {
</P><PRE> var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
     t,
     i;
</PRE><PRE> while (m) {
   i = Math.random() * m-- | 0;
   t = array[m + i0];
   array[m + i0] = array[i + i0];
   array[i + i0] = t;
 }
</PRE><PRE> return array;
</PRE><P>}
</P><P>function sum(values, valueof) {
</P><PRE> var n = values.length,
     i = -1,
     value,
     sum = 0;
</PRE><PRE> if (valueof == null) {
   while (++i &lt; n) {
     if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
   }
 }
</PRE><PRE> else {
   while (++i &lt; n) {
     if (value = +valueof(values[i], i, values)) sum += value;
   }
 }
</PRE><PRE> return sum;
</PRE><P>}
</P><P>function transpose(matrix) {
</P><PRE> if (!(n = matrix.length)) return [];
 for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i &lt; m;) {
   for (var j = -1, n, row = transpose[i] = new Array(n); ++j &lt; n;) {
     row[j] = matrix[j][i];
   }
 }
 return transpose;
</PRE><P>}
</P><P>function length(d) {
</P><PRE> return d.length;
</PRE><P>}
</P><P>function zip() {
</P><PRE> return transpose(arguments);
</PRE><P>}
</P><P>var slice$1 = Array.prototype.slice;
</P><P>function identity$1(x) {
</P><PRE> return x;
</PRE><P>}
</P><P>var top = 1,
</P><PRE>   right = 2,
   bottom = 3,
   left = 4,
   epsilon = 1e-6;
</PRE><P>function translateX(x) {
</P><PRE> return &quot;translate(&quot; + (x + 0.5) + &quot;,0)&quot;;
</PRE><P>}
</P><P>function translateY(y) {
</P><PRE> return &quot;translate(0,&quot; + (y + 0.5) + &quot;)&quot;;
</PRE><P>}
</P><P>function number$1(scale) {
</P><PRE> return function(d) {
   return +scale(d);
 };
</PRE><P>}
</P><P>function center(scale) {
</P><PRE> var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
 if (scale.round()) offset = Math.round(offset);
 return function(d) {
   return +scale(d) + offset;
 };
</PRE><P>}
</P><P>function entering() {
</P><PRE> return !this.__axis;
</PRE><P>}
</P><P>function axis(orient, scale) {
</P><PRE> var tickArguments = [],
     tickValues = null,
     tickFormat = null,
     tickSizeInner = 6,
     tickSizeOuter = 6,
     tickPadding = 3,
     k = orient === top || orient === left ? -1 : 1,
     x = orient === left || orient === right ? &quot;x&quot; : &quot;y&quot;,
     transform = orient === top || orient === bottom ? translateX : translateY;
</PRE><PRE> function axis(context) {
   var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
       format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1) : tickFormat,
       spacing = Math.max(tickSizeInner, 0) + tickPadding,
       range = scale.range(),
       range0 = +range[0] + 0.5,
       range1 = +range[range.length - 1] + 0.5,
       position = (scale.bandwidth ? center : number$1)(scale.copy()),
       selection = context.selection ? context.selection() : context,
       path = selection.selectAll(&quot;.domain&quot;).data([null]),
       tick = selection.selectAll(&quot;.tick&quot;).data(values, scale).order(),
       tickExit = tick.exit(),
       tickEnter = tick.enter().append(&quot;g&quot;).attr(&quot;class&quot;, &quot;tick&quot;),
       line = tick.select(&quot;line&quot;),
       text = tick.select(&quot;text&quot;);
</PRE><PRE>   path = path.merge(path.enter().insert(&quot;path&quot;, &quot;.tick&quot;)
       .attr(&quot;class&quot;, &quot;domain&quot;)
       .attr(&quot;stroke&quot;, &quot;currentColor&quot;));
</PRE><PRE>   tick = tick.merge(tickEnter);
</PRE><PRE>   line = line.merge(tickEnter.append(&quot;line&quot;)
       .attr(&quot;stroke&quot;, &quot;currentColor&quot;)
       .attr(x + &quot;2&quot;, k * tickSizeInner));
</PRE><PRE>   text = text.merge(tickEnter.append(&quot;text&quot;)
       .attr(&quot;fill&quot;, &quot;currentColor&quot;)
       .attr(x, k * spacing)
       .attr(&quot;dy&quot;, orient === top ? &quot;0em&quot; : orient === bottom ? &quot;0.71em&quot; : &quot;0.32em&quot;));
</PRE><PRE>   if (context !== selection) {
     path = path.transition(context);
     tick = tick.transition(context);
     line = line.transition(context);
     text = text.transition(context);
</PRE><PRE>     tickExit = tickExit.transition(context)
         .attr(&quot;opacity&quot;, epsilon)
         .attr(&quot;transform&quot;, function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute(&quot;transform&quot;); });
</PRE><PRE>     tickEnter
         .attr(&quot;opacity&quot;, epsilon)
         .attr(&quot;transform&quot;, function(d) { var p = this.parentNode.__axis; return transform(p &amp;&amp; isFinite(p = p(d)) ? p : position(d)); });
   }
</PRE><PRE>   tickExit.remove();
</PRE><PRE>   path
       .attr(&quot;d&quot;, orient === left || orient == right
           ? (tickSizeOuter ? &quot;M&quot; + k * tickSizeOuter + &quot;,&quot; + range0 + &quot;H0.5V&quot; + range1 + &quot;H&quot; + k * tickSizeOuter : &quot;M0.5,&quot; + range0 + &quot;V&quot; + range1)
           : (tickSizeOuter ? &quot;M&quot; + range0 + &quot;,&quot; + k * tickSizeOuter + &quot;V0.5H&quot; + range1 + &quot;V&quot; + k * tickSizeOuter : &quot;M&quot; + range0 + &quot;,0.5H&quot; + range1));
</PRE><PRE>   tick
       .attr(&quot;opacity&quot;, 1)
       .attr(&quot;transform&quot;, function(d) { return transform(position(d)); });
</PRE><PRE>   line
       .attr(x + &quot;2&quot;, k * tickSizeInner);
</PRE><PRE>   text
       .attr(x, k * spacing)
       .text(format);
</PRE><PRE>   selection.filter(entering)
       .attr(&quot;fill&quot;, &quot;none&quot;)
       .attr(&quot;font-size&quot;, 10)
       .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
       .attr(&quot;text-anchor&quot;, orient === right ? &quot;start&quot; : orient === left ? &quot;end&quot; : &quot;middle&quot;);
</PRE><PRE>   selection
       .each(function() { this.__axis = position; });
 }
</PRE><PRE> axis.scale = function(_) {
   return arguments.length ? (scale = _, axis) : scale;
 };
</PRE><PRE> axis.ticks = function() {
   return tickArguments = slice$1.call(arguments), axis;
 };
</PRE><PRE> axis.tickArguments = function(_) {
   return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();
 };
</PRE><PRE> axis.tickValues = function(_) {
   return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues &amp;&amp; tickValues.slice();
 };
</PRE><PRE> axis.tickFormat = function(_) {
   return arguments.length ? (tickFormat = _, axis) : tickFormat;
 };
</PRE><PRE> axis.tickSize = function(_) {
   return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
 };
</PRE><PRE> axis.tickSizeInner = function(_) {
   return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
 };
</PRE><PRE> axis.tickSizeOuter = function(_) {
   return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
 };
</PRE><PRE> axis.tickPadding = function(_) {
   return arguments.length ? (tickPadding = +_, axis) : tickPadding;
 };
</PRE><PRE> return axis;
</PRE><P>}
</P><P>function axisTop(scale) {
</P><PRE> return axis(top, scale);
</PRE><P>}
</P><P>function axisRight(scale) {
</P><PRE> return axis(right, scale);
</PRE><P>}
</P><P>function axisBottom(scale) {
</P><PRE> return axis(bottom, scale);
</PRE><P>}
</P><P>function axisLeft(scale) {
</P><PRE> return axis(left, scale);
</PRE><P>}
</P><P>var noop = {value: function() {}};
</P><P>function dispatch() {
</P><PRE> for (var i = 0, n = arguments.length, _ = {}, t; i &lt; n; ++i) {
   if (!(t = arguments[i] + &quot;&quot;) || (t in _)) throw new Error(&quot;illegal type: &quot; + t);
   _[t] = [];
 }
 return new Dispatch(_);
</PRE><P>}
</P><P>function Dispatch(_) {
</P><PRE> this._ = _;
</PRE><P>}
</P><P>function parseTypenames(typenames, types) {
</P><PRE> return typenames.trim().split(/^|\s+/).map(function(t) {
   var name = &quot;&quot;, i = t.indexOf(&quot;.&quot;);
   if (i &gt;= 0) name = t.slice(i + 1), t = t.slice(0, i);
   if (t &amp;&amp; !types.hasOwnProperty(t)) throw new Error(&quot;unknown type: &quot; + t);
   return {type: t, name: name};
 });
</PRE><P>}
</P><P>Dispatch.prototype = dispatch.prototype = {
</P><PRE> constructor: Dispatch,
 on: function(typename, callback) {
   var _ = this._,
       T = parseTypenames(typename + &quot;&quot;, _),
       t,
       i = -1,
       n = T.length;
</PRE><PRE>   // If no callback was specified, return the callback of the given type and name.
   if (arguments.length &lt; 2) {
     while (++i &lt; n) if ((t = (typename = T[i]).type) &amp;&amp; (t = get(_[t], typename.name))) return t;
     return;
   }
</PRE><PRE>   // If a type was specified, set the callback for the given type and name.
   // Otherwise, if a null callback was specified, remove callbacks of the given name.
   if (callback != null &amp;&amp; typeof callback !== &quot;function&quot;) throw new Error(&quot;invalid callback: &quot; + callback);
   while (++i &lt; n) {
     if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
     else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
   }
</PRE><PRE>   return this;
 },
 copy: function() {
   var copy = {}, _ = this._;
   for (var t in _) copy[t] = _[t].slice();
   return new Dispatch(copy);
 },
 call: function(type, that) {
   if ((n = arguments.length - 2) &gt; 0) for (var args = new Array(n), i = 0, n, t; i &lt; n; ++i) args[i] = arguments[i + 2];
   if (!this._.hasOwnProperty(type)) throw new Error(&quot;unknown type: &quot; + type);
   for (t = this._[type], i = 0, n = t.length; i &lt; n; ++i) t[i].value.apply(that, args);
 },
 apply: function(type, that, args) {
   if (!this._.hasOwnProperty(type)) throw new Error(&quot;unknown type: &quot; + type);
   for (var t = this._[type], i = 0, n = t.length; i &lt; n; ++i) t[i].value.apply(that, args);
 }
</PRE><P>};
</P><P>function get(type, name) {
</P><PRE> for (var i = 0, n = type.length, c; i &lt; n; ++i) {
   if ((c = type[i]).name === name) {
     return c.value;
   }
 }
</PRE><P>}
</P><P>function set(type, name, callback) {
</P><PRE> for (var i = 0, n = type.length; i &lt; n; ++i) {
   if (type[i].name === name) {
     type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
     break;
   }
 }
 if (callback != null) type.push({name: name, value: callback});
 return type;
</PRE><P>}
</P><P>var xhtml = &quot;<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot;;
</P><P>var namespaces = {
</P><PRE> svg: &quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot;,
 xhtml: xhtml,
 xlink: &quot;<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xlink">http://www.w3.org/1999/xlink</A>&quot;,
 xml: &quot;<A rel="nofollow" class="external free" href="http://www.w3.org/XML/1998/namespace">http://www.w3.org/XML/1998/namespace</A>&quot;,
 xmlns: &quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/xmlns/">http://www.w3.org/2000/xmlns/</A>&quot;
</PRE><P>};
</P><P>function namespace(name) {
</P><PRE> var prefix = name += &quot;&quot;, i = prefix.indexOf(&quot;:&quot;);
 if (i &gt;= 0 &amp;&amp; (prefix = name.slice(0, i)) !== &quot;xmlns&quot;) name = name.slice(i + 1);
 return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
</PRE><P>}
</P><P>function creatorInherit(name) {
</P><PRE> return function() {
   var document = this.ownerDocument,
       uri = this.namespaceURI;
   return uri === xhtml &amp;&amp; document.documentElement.namespaceURI === xhtml
       ? document.createElement(name)
       : document.createElementNS(uri, name);
 };
</PRE><P>}
</P><P>function creatorFixed(fullname) {
</P><PRE> return function() {
   return this.ownerDocument.createElementNS(fullname.space, fullname.local);
 };
</PRE><P>}
</P><P>function creator(name) {
</P><PRE> var fullname = namespace(name);
 return (fullname.local
     ? creatorFixed
     : creatorInherit)(fullname);
</PRE><P>}
</P><P>function none() {}
</P><P>function selector(selector) {
</P><PRE> return selector == null ? none : function() {
   return this.querySelector(selector);
 };
</PRE><P>}
</P><P>function selection_select(select) {
</P><PRE> if (typeof select !== &quot;function&quot;) select = selector(select);
</PRE><PRE> for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j &lt; m; ++j) {
   for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i &lt; n; ++i) {
     if ((node = group[i]) &amp;&amp; (subnode = select.call(node, node.__data__, i, group))) {
       if (&quot;__data__&quot; in node) subnode.__data__ = node.__data__;
       subgroup[i] = subnode;
     }
   }
 }
</PRE><PRE> return new Selection(subgroups, this._parents);
</PRE><P>}
</P><P>function empty() {
</P><PRE> return [];
</PRE><P>}
</P><P>function selectorAll(selector) {
</P><PRE> return selector == null ? empty : function() {
   return this.querySelectorAll(selector);
 };
</PRE><P>}
</P><P>function selection_selectAll(select) {
</P><PRE> if (typeof select !== &quot;function&quot;) select = selectorAll(select);
</PRE><PRE> for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j &lt; m; ++j) {
   for (var group = groups[j], n = group.length, node, i = 0; i &lt; n; ++i) {
     if (node = group[i]) {
       subgroups.push(select.call(node, node.__data__, i, group));
       parents.push(node);
     }
   }
 }
</PRE><PRE> return new Selection(subgroups, parents);
</PRE><P>}
</P><P>var matcher = function(selector) {
</P><PRE> return function() {
   return this.matches(selector);
 };
</PRE><P>};
</P><P>if (typeof document !== &quot;undefined&quot;) {
</P><PRE> var element = document.documentElement;
 if (!element.matches) {
   var vendorMatches = element.webkitMatchesSelector
       || element.msMatchesSelector
       || element.mozMatchesSelector
       || element.oMatchesSelector;
   matcher = function(selector) {
     return function() {
       return vendorMatches.call(this, selector);
     };
   };
 }
</PRE><P>}
</P><P>var matcher$1 = matcher;
</P><P>function selection_filter(match) {
</P><PRE> if (typeof match !== &quot;function&quot;) match = matcher$1(match);
</PRE><PRE> for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j &lt; m; ++j) {
   for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i &lt; n; ++i) {
     if ((node = group[i]) &amp;&amp; match.call(node, node.__data__, i, group)) {
       subgroup.push(node);
     }
   }
 }
</PRE><PRE> return new Selection(subgroups, this._parents);
</PRE><P>}
</P><P>function sparse(update) {
</P><PRE> return new Array(update.length);
</PRE><P>}
</P><P>function selection_enter() {
</P><PRE> return new Selection(this._enter || this._groups.map(sparse), this._parents);
</PRE><P>}
</P><P>function EnterNode(parent, datum) {
</P><PRE> this.ownerDocument = parent.ownerDocument;
 this.namespaceURI = parent.namespaceURI;
 this._next = null;
 this._parent = parent;
 this.__data__ = datum;
</PRE><P>}
</P><P>EnterNode.prototype = {
</P><PRE> constructor: EnterNode,
 appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
 insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
 querySelector: function(selector) { return this._parent.querySelector(selector); },
 querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
</PRE><P>};
</P><P>function constant$1(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>var keyPrefix = &quot;$&quot;; // Protect against keys like “__proto__”.
</P><P>function bindIndex(parent, group, enter, update, exit, data) {
</P><PRE> var i = 0,
     node,
     groupLength = group.length,
     dataLength = data.length;
</PRE><PRE> // Put any non-null nodes that fit into update.
 // Put any null nodes into enter.
 // Put any remaining data into enter.
 for (; i &lt; dataLength; ++i) {
   if (node = group[i]) {
     node.__data__ = data[i];
     update[i] = node;
   } else {
     enter[i] = new EnterNode(parent, data[i]);
   }
 }
</PRE><PRE> // Put any non-null nodes that don’t fit into exit.
 for (; i &lt; groupLength; ++i) {
   if (node = group[i]) {
     exit[i] = node;
   }
 }
</PRE><P>}
</P><P>function bindKey(parent, group, enter, update, exit, data, key) {
</P><PRE> var i,
     node,
     nodeByKeyValue = {},
     groupLength = group.length,
     dataLength = data.length,
     keyValues = new Array(groupLength),
     keyValue;
</PRE><PRE> // Compute the key for each node.
 // If multiple nodes have the same key, the duplicates are added to exit.
 for (i = 0; i &lt; groupLength; ++i) {
   if (node = group[i]) {
     keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
     if (keyValue in nodeByKeyValue) {
       exit[i] = node;
     } else {
       nodeByKeyValue[keyValue] = node;
     }
   }
 }
</PRE><PRE> // Compute the key for each datum.
 // If there a node associated with this key, join and add it to update.
 // If there is not (or the key is a duplicate), add it to enter.
 for (i = 0; i &lt; dataLength; ++i) {
   keyValue = keyPrefix + key.call(parent, data[i], i, data);
   if (node = nodeByKeyValue[keyValue]) {
     update[i] = node;
     node.__data__ = data[i];
     nodeByKeyValue[keyValue] = null;
   } else {
     enter[i] = new EnterNode(parent, data[i]);
   }
 }
</PRE><PRE> // Add any remaining nodes that were not bound to data to exit.
 for (i = 0; i &lt; groupLength; ++i) {
   if ((node = group[i]) &amp;&amp; (nodeByKeyValue[keyValues[i]] === node)) {
     exit[i] = node;
   }
 }
</PRE><P>}
</P><P>function selection_data(value, key) {
</P><PRE> if (!value) {
   data = new Array(this.size()), j = -1;
   this.each(function(d) { data[++j] = d; });
   return data;
 }
</PRE><PRE> var bind = key ? bindKey : bindIndex,
     parents = this._parents,
     groups = this._groups;
</PRE><PRE> if (typeof value !== &quot;function&quot;) value = constant$1(value);
</PRE><PRE> for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j &lt; m; ++j) {
   var parent = parents[j],
       group = groups[j],
       groupLength = group.length,
       data = value.call(parent, parent &amp;&amp; parent.__data__, j, parents),
       dataLength = data.length,
       enterGroup = enter[j] = new Array(dataLength),
       updateGroup = update[j] = new Array(dataLength),
       exitGroup = exit[j] = new Array(groupLength);
</PRE><PRE>   bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
</PRE><PRE>   // Now connect the enter nodes to their following update node, such that
   // appendChild can insert the materialized enter node before this node,
   // rather than at the end of the parent node.
   for (var i0 = 0, i1 = 0, previous, next; i0 &lt; dataLength; ++i0) {
     if (previous = enterGroup[i0]) {
       if (i0 &gt;= i1) i1 = i0 + 1;
       while (!(next = updateGroup[i1]) &amp;&amp; ++i1 &lt; dataLength);
       previous._next = next || null;
     }
   }
 }
</PRE><PRE> update = new Selection(update, parents);
 update._enter = enter;
 update._exit = exit;
 return update;
</PRE><P>}
</P><P>function selection_exit() {
</P><PRE> return new Selection(this._exit || this._groups.map(sparse), this._parents);
</PRE><P>}
</P><P>function selection_merge(selection$$1) {
</P><PRE> for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j &lt; m; ++j) {
   for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i &lt; n; ++i) {
     if (node = group0[i] || group1[i]) {
       merge[i] = node;
     }
   }
 }
</PRE><PRE> for (; j &lt; m0; ++j) {
   merges[j] = groups0[j];
 }
</PRE><PRE> return new Selection(merges, this._parents);
</PRE><P>}
</P><P>function selection_order() {
</P><PRE> for (var groups = this._groups, j = -1, m = groups.length; ++j &lt; m;) {
   for (var group = groups[j], i = group.length - 1, next = group[i], node; --i &gt;= 0;) {
     if (node = group[i]) {
       if (next &amp;&amp; next !== node.nextSibling) next.parentNode.insertBefore(node, next);
       next = node;
     }
   }
 }
</PRE><PRE> return this;
</PRE><P>}
</P><P>function selection_sort(compare) {
</P><PRE> if (!compare) compare = ascending$1;
</PRE><PRE> function compareNode(a, b) {
   return a &amp;&amp; b ? compare(a.__data__, b.__data__) : !a - !b;
 }
</PRE><PRE> for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j &lt; m; ++j) {
   for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i &lt; n; ++i) {
     if (node = group[i]) {
       sortgroup[i] = node;
     }
   }
   sortgroup.sort(compareNode);
 }
</PRE><PRE> return new Selection(sortgroups, this._parents).order();
</PRE><P>}
</P><P>function ascending$1(a, b) {
</P><PRE> return a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN;
</PRE><P>}
</P><P>function selection_call() {
</P><PRE> var callback = arguments[0];
 arguments[0] = this;
 callback.apply(null, arguments);
 return this;
</PRE><P>}
</P><P>function selection_nodes() {
</P><PRE> var nodes = new Array(this.size()), i = -1;
 this.each(function() { nodes[++i] = this; });
 return nodes;
</PRE><P>}
</P><P>function selection_node() {
</P><PRE> for (var groups = this._groups, j = 0, m = groups.length; j &lt; m; ++j) {
   for (var group = groups[j], i = 0, n = group.length; i &lt; n; ++i) {
     var node = group[i];
     if (node) return node;
   }
 }
</PRE><PRE> return null;
</PRE><P>}
</P><P>function selection_size() {
</P><PRE> var size = 0;
 this.each(function() { ++size; });
 return size;
</PRE><P>}
</P><P>function selection_empty() {
</P><PRE> return !this.node();
</PRE><P>}
</P><P>function selection_each(callback) {
</P><PRE> for (var groups = this._groups, j = 0, m = groups.length; j &lt; m; ++j) {
   for (var group = groups[j], i = 0, n = group.length, node; i &lt; n; ++i) {
     if (node = group[i]) callback.call(node, node.__data__, i, group);
   }
 }
</PRE><PRE> return this;
</PRE><P>}
</P><P>function attrRemove(name) {
</P><PRE> return function() {
   this.removeAttribute(name);
 };
</PRE><P>}
</P><P>function attrRemoveNS(fullname) {
</P><PRE> return function() {
   this.removeAttributeNS(fullname.space, fullname.local);
 };
</PRE><P>}
</P><P>function attrConstant(name, value) {
</P><PRE> return function() {
   this.setAttribute(name, value);
 };
</PRE><P>}
</P><P>function attrConstantNS(fullname, value) {
</P><PRE> return function() {
   this.setAttributeNS(fullname.space, fullname.local, value);
 };
</PRE><P>}
</P><P>function attrFunction(name, value) {
</P><PRE> return function() {
   var v = value.apply(this, arguments);
   if (v == null) this.removeAttribute(name);
   else this.setAttribute(name, v);
 };
</PRE><P>}
</P><P>function attrFunctionNS(fullname, value) {
</P><PRE> return function() {
   var v = value.apply(this, arguments);
   if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
   else this.setAttributeNS(fullname.space, fullname.local, v);
 };
</PRE><P>}
</P><P>function selection_attr(name, value) {
</P><PRE> var fullname = namespace(name);
</PRE><PRE> if (arguments.length &lt; 2) {
   var node = this.node();
   return fullname.local
       ? node.getAttributeNS(fullname.space, fullname.local)
  : node.getAttribute(fullname);
 }
</PRE><PRE> return this.each((value == null
     ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === &quot;function&quot;
     ? (fullname.local ? attrFunctionNS : attrFunction)
     : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
</PRE><P>}
</P><P>function defaultView(node) {
</P><PRE> return (node.ownerDocument &amp;&amp; node.ownerDocument.defaultView) // node is a Node
     || (node.document &amp;&amp; node) // node is a Window
     || node.defaultView; // node is a Document
</PRE><P>}
</P><P>function styleRemove(name) {
</P><PRE> return function() {
   this.style.removeProperty(name);
 };
</PRE><P>}
</P><P>function styleConstant(name, value, priority) {
</P><PRE> return function() {
   this.style.setProperty(name, value, priority);
 };
</PRE><P>}
</P><P>function styleFunction(name, value, priority) {
</P><PRE> return function() {
   var v = value.apply(this, arguments);
   if (v == null) this.style.removeProperty(name);
   else this.style.setProperty(name, v, priority);
 };
</PRE><P>}
</P><P>function selection_style(name, value, priority) {
</P><PRE> return arguments.length &gt; 1
     ? this.each((value == null
           ? styleRemove : typeof value === &quot;function&quot;
           ? styleFunction
           : styleConstant)(name, value, priority == null ? &quot;&quot; : priority))
     : styleValue(this.node(), name);
</PRE><P>}
</P><P>function styleValue(node, name) {
</P><PRE> return node.style.getPropertyValue(name)
     || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
</PRE><P>}
</P><P>function propertyRemove(name) {
</P><PRE> return function() {
   delete this[name];
 };
</PRE><P>}
</P><P>function propertyConstant(name, value) {
</P><PRE> return function() {
   this[name] = value;
 };
</PRE><P>}
</P><P>function propertyFunction(name, value) {
</P><PRE> return function() {
   var v = value.apply(this, arguments);
   if (v == null) delete this[name];
   else this[name] = v;
 };
</PRE><P>}
</P><P>function selection_property(name, value) {
</P><PRE> return arguments.length &gt; 1
     ? this.each((value == null
         ? propertyRemove : typeof value === &quot;function&quot;
         ? propertyFunction
         : propertyConstant)(name, value))
     : this.node()[name];
</PRE><P>}
</P><P>function classArray(string) {
</P><PRE> return string.trim().split(/^|\s+/);
</PRE><P>}
</P><P>function classList(node) {
</P><PRE> return node.classList || new ClassList(node);
</PRE><P>}
</P><P>function ClassList(node) {
</P><PRE> this._node = node;
 this._names = classArray(node.getAttribute(&quot;class&quot;) || &quot;&quot;);
</PRE><P>}
</P><P>ClassList.prototype = {
</P><PRE> add: function(name) {
   var i = this._names.indexOf(name);
   if (i &lt; 0) {
     this._names.push(name);
     this._node.setAttribute(&quot;class&quot;, this._names.join(&quot; &quot;));
   }
 },
 remove: function(name) {
   var i = this._names.indexOf(name);
   if (i &gt;= 0) {
     this._names.splice(i, 1);
     this._node.setAttribute(&quot;class&quot;, this._names.join(&quot; &quot;));
   }
 },
 contains: function(name) {
   return this._names.indexOf(name) &gt;= 0;
 }
</PRE><P>};
</P><P>function classedAdd(node, names) {
</P><PRE> var list = classList(node), i = -1, n = names.length;
 while (++i &lt; n) list.add(names[i]);
</PRE><P>}
</P><P>function classedRemove(node, names) {
</P><PRE> var list = classList(node), i = -1, n = names.length;
 while (++i &lt; n) list.remove(names[i]);
</PRE><P>}
</P><P>function classedTrue(names) {
</P><PRE> return function() {
   classedAdd(this, names);
 };
</PRE><P>}
</P><P>function classedFalse(names) {
</P><PRE> return function() {
   classedRemove(this, names);
 };
</PRE><P>}
</P><P>function classedFunction(names, value) {
</P><PRE> return function() {
   (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
 };
</PRE><P>}
</P><P>function selection_classed(name, value) {
</P><PRE> var names = classArray(name + &quot;&quot;);
</PRE><PRE> if (arguments.length &lt; 2) {
   var list = classList(this.node()), i = -1, n = names.length;
   while (++i &lt; n) if (!list.contains(names[i])) return false;
   return true;
 }
</PRE><PRE> return this.each((typeof value === &quot;function&quot;
     ? classedFunction : value
     ? classedTrue
     : classedFalse)(names, value));
</PRE><P>}
</P><P>function textRemove() {
</P><PRE> this.textContent = &quot;&quot;;
</PRE><P>}
</P><P>function textConstant(value) {
</P><PRE> return function() {
   this.textContent = value;
 };
</PRE><P>}
</P><P>function textFunction(value) {
</P><PRE> return function() {
   var v = value.apply(this, arguments);
   this.textContent = v == null ? &quot;&quot; : v;
 };
</PRE><P>}
</P><P>function selection_text(value) {
</P><PRE> return arguments.length
     ? this.each(value == null
         ? textRemove : (typeof value === &quot;function&quot;
         ? textFunction
         : textConstant)(value))
     : this.node().textContent;
</PRE><P>}
</P><P>function htmlRemove() {
</P><PRE> this.innerHTML = &quot;&quot;;
</PRE><P>}
</P><P>function htmlConstant(value) {
</P><PRE> return function() {
   this.innerHTML = value;
 };
</PRE><P>}
</P><P>function htmlFunction(value) {
</P><PRE> return function() {
   var v = value.apply(this, arguments);
   this.innerHTML = v == null ? &quot;&quot; : v;
 };
</PRE><P>}
</P><P>function selection_html(value) {
</P><PRE> return arguments.length
     ? this.each(value == null
         ? htmlRemove : (typeof value === &quot;function&quot;
         ? htmlFunction
         : htmlConstant)(value))
     : this.node().innerHTML;
</PRE><P>}
</P><P>function raise() {
</P><PRE> if (this.nextSibling) this.parentNode.appendChild(this);
</PRE><P>}
</P><P>function selection_raise() {
</P><PRE> return this.each(raise);
</PRE><P>}
</P><P>function lower() {
</P><PRE> if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
</PRE><P>}
</P><P>function selection_lower() {
</P><PRE> return this.each(lower);
</PRE><P>}
</P><P>function selection_append(name) {
</P><PRE> var create = typeof name === &quot;function&quot; ? name : creator(name);
 return this.select(function() {
   return this.appendChild(create.apply(this, arguments));
 });
</PRE><P>}
</P><P>function constantNull() {
</P><PRE> return null;
</PRE><P>}
</P><P>function selection_insert(name, before) {
</P><PRE> var create = typeof name === &quot;function&quot; ? name : creator(name),
     select = before == null ? constantNull : typeof before === &quot;function&quot; ? before : selector(before);
 return this.select(function() {
   return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
 });
</PRE><P>}
</P><P>function remove() {
</P><PRE> var parent = this.parentNode;
 if (parent) parent.removeChild(this);
</PRE><P>}
</P><P>function selection_remove() {
</P><PRE> return this.each(remove);
</PRE><P>}
</P><P>function selection_cloneShallow() {
</P><PRE> return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
</PRE><P>}
</P><P>function selection_cloneDeep() {
</P><PRE> return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
</PRE><P>}
</P><P>function selection_clone(deep) {
</P><PRE> return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
</PRE><P>}
</P><P>function selection_datum(value) {
</P><PRE> return arguments.length
     ? this.property(&quot;__data__&quot;, value)
     : this.node().__data__;
</PRE><P>}
</P><P>var filterEvents = {};
</P><P>exports.event = null;
</P><P>if (typeof document !== &quot;undefined&quot;) {
</P><PRE> var element$1 = document.documentElement;
 if (!(&quot;onmouseenter&quot; in element$1)) {
   filterEvents = {mouseenter: &quot;mouseover&quot;, mouseleave: &quot;mouseout&quot;};
 }
</PRE><P>}
</P><P>function filterContextListener(listener, index, group) {
</P><PRE> listener = contextListener(listener, index, group);
 return function(event) {
   var related = event.relatedTarget;
   if (!related || (related !== this &amp;&amp; !(related.compareDocumentPosition(this) &amp; 8))) {
     listener.call(this, event);
   }
 };
</PRE><P>}
</P><P>function contextListener(listener, index, group) {
</P><PRE> return function(event1) {
   var event0 = exports.event; // Events can be reentrant (e.g., focus).
   exports.event = event1;
   try {
     listener.call(this, this.__data__, index, group);
   } finally {
     exports.event = event0;
   }
 };
</PRE><P>}
</P><P>function parseTypenames$1(typenames) {
</P><PRE> return typenames.trim().split(/^|\s+/).map(function(t) {
   var name = &quot;&quot;, i = t.indexOf(&quot;.&quot;);
   if (i &gt;= 0) name = t.slice(i + 1), t = t.slice(0, i);
   return {type: t, name: name};
 });
</PRE><P>}
</P><P>function onRemove(typename) {
</P><PRE> return function() {
   var on = this.__on;
   if (!on) return;
   for (var j = 0, i = -1, m = on.length, o; j &lt; m; ++j) {
     if (o = on[j], (!typename.type || o.type === typename.type) &amp;&amp; o.name === typename.name) {
       this.removeEventListener(o.type, o.listener, o.capture);
     } else {
       on[++i] = o;
     }
   }
   if (++i) on.length = i;
   else delete this.__on;
 };
</PRE><P>}
</P><P>function onAdd(typename, value, capture) {
</P><PRE> var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
 return function(d, i, group) {
   var on = this.__on, o, listener = wrap(value, i, group);
   if (on) for (var j = 0, m = on.length; j &lt; m; ++j) {
     if ((o = on[j]).type === typename.type &amp;&amp; o.name === typename.name) {
       this.removeEventListener(o.type, o.listener, o.capture);
       this.addEventListener(o.type, o.listener = listener, o.capture = capture);
       o.value = value;
       return;
     }
   }
   this.addEventListener(typename.type, listener, capture);
   o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
   if (!on) this.__on = [o];
   else on.push(o);
 };
</PRE><P>}
</P><P>function selection_on(typename, value, capture) {
</P><PRE> var typenames = parseTypenames$1(typename + &quot;&quot;), i, n = typenames.length, t;
</PRE><PRE> if (arguments.length &lt; 2) {
   var on = this.node().__on;
   if (on) for (var j = 0, m = on.length, o; j &lt; m; ++j) {
     for (i = 0, o = on[j]; i &lt; n; ++i) {
       if ((t = typenames[i]).type === o.type &amp;&amp; t.name === o.name) {
         return o.value;
       }
     }
   }
   return;
 }
</PRE><PRE> on = value ? onAdd : onRemove;
 if (capture == null) capture = false;
 for (i = 0; i &lt; n; ++i) this.each(on(typenames[i], value, capture));
 return this;
</PRE><P>}
</P><P>function customEvent(event1, listener, that, args) {
</P><PRE> var event0 = exports.event;
 event1.sourceEvent = exports.event;
 exports.event = event1;
 try {
   return listener.apply(that, args);
 } finally {
   exports.event = event0;
 }
</PRE><P>}
</P><P>function dispatchEvent(node, type, params) {
</P><PRE> var window = defaultView(node),
     event = window.CustomEvent;
</PRE><PRE> if (typeof event === &quot;function&quot;) {
   event = new event(type, params);
 } else {
   event = window.document.createEvent(&quot;Event&quot;);
   if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
   else event.initEvent(type, false, false);
 }
</PRE><PRE> node.dispatchEvent(event);
</PRE><P>}
</P><P>function dispatchConstant(type, params) {
</P><PRE> return function() {
   return dispatchEvent(this, type, params);
 };
</PRE><P>}
</P><P>function dispatchFunction(type, params) {
</P><PRE> return function() {
   return dispatchEvent(this, type, params.apply(this, arguments));
 };
</PRE><P>}
</P><P>function selection_dispatch(type, params) {
</P><PRE> return this.each((typeof params === &quot;function&quot;
     ? dispatchFunction
     : dispatchConstant)(type, params));
</PRE><P>}
</P><P>var root = [null];
</P><P>function Selection(groups, parents) {
</P><PRE> this._groups = groups;
 this._parents = parents;
</PRE><P>}
</P><P>function selection() {
</P><PRE> return new Selection(<A href="/wiki/index.php?title=Document.documentElement&amp;action=edit&amp;redlink=1" class="new" title="Document.documentElement (page does not exist)">document.documentElement</A>, root);
</PRE><P>}
</P><P>Selection.prototype = selection.prototype = {
</P><PRE> constructor: Selection,
 select: selection_select,
 selectAll: selection_selectAll,
 filter: selection_filter,
 data: selection_data,
 enter: selection_enter,
 exit: selection_exit,
 merge: selection_merge,
 order: selection_order,
 sort: selection_sort,
 call: selection_call,
 nodes: selection_nodes,
 node: selection_node,
 size: selection_size,
 empty: selection_empty,
 each: selection_each,
 attr: selection_attr,
 style: selection_style,
 property: selection_property,
 classed: selection_classed,
 text: selection_text,
 html: selection_html,
 raise: selection_raise,
 lower: selection_lower,
 append: selection_append,
 insert: selection_insert,
 remove: selection_remove,
 clone: selection_clone,
 datum: selection_datum,
 on: selection_on,
 dispatch: selection_dispatch
</PRE><P>};
</P><P>function select(selector) {
</P><PRE> return typeof selector === &quot;string&quot;
     ? new Selection(<A href="/wiki/index.php?title=Document.querySelector(selector)&amp;action=edit&amp;redlink=1" class="new" title="Document.querySelector(selector) (page does not exist)">document.querySelector(selector)</A>, [document.documentElement])
     : new Selection(<A href="/wiki/index.php?title=Selector&amp;action=edit&amp;redlink=1" class="new" title="Selector (page does not exist)">selector</A>, root);
</PRE><P>}
</P><P>function create(name) {
</P><PRE> return select(creator(name).call(document.documentElement));
</PRE><P>}
</P><P>var nextId = 0;
</P><P>function local() {
</P><PRE> return new Local;
</PRE><P>}
</P><P>function Local() {
</P><PRE> this._ = &quot;@&quot; + (++nextId).toString(36);
</PRE><P>}
</P><P>Local.prototype = local.prototype = {
</P><PRE> constructor: Local,
 get: function(node) {
   var id = this._;
   while (!(id in node)) if (!(node = node.parentNode)) return;
   return node[id];
 },
 set: function(node, value) {
   return node[this._] = value;
 },
 remove: function(node) {
   return this._ in node &amp;&amp; delete node[this._];
 },
 toString: function() {
   return this._;
 }
</PRE><P>};
</P><P>function sourceEvent() {
</P><PRE> var current = exports.event, source;
 while (source = current.sourceEvent) current = source;
 return current;
</PRE><P>}
</P><P>function point(node, event) {
</P><PRE> var svg = node.ownerSVGElement || node;
</PRE><PRE> if (svg.createSVGPoint) {
   var point = svg.createSVGPoint();
   point.x = event.clientX, point.y = event.clientY;
   point = point.matrixTransform(node.getScreenCTM().inverse());
   return [point.x, point.y];
 }
</PRE><PRE> var rect = node.getBoundingClientRect();
 return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
</PRE><P>}
</P><P>function mouse(node) {
</P><PRE> var event = sourceEvent();
 if (event.changedTouches) event = event.changedTouches[0];
 return point(node, event);
</PRE><P>}
</P><P>function selectAll(selector) {
</P><PRE> return typeof selector === &quot;string&quot;
     ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
     : new Selection([selector == null ? [] : selector], root);
</PRE><P>}
</P><P>function touch(node, touches, identifier) {
</P><PRE> if (arguments.length &lt; 3) identifier = touches, touches = sourceEvent().changedTouches;
</PRE><PRE> for (var i = 0, n = touches ? touches.length : 0, touch; i &lt; n; ++i) {
   if ((touch = touches[i]).identifier === identifier) {
     return point(node, touch);
   }
 }
</PRE><PRE> return null;
</PRE><P>}
</P><P>function touches(node, touches) {
</P><PRE> if (touches == null) touches = sourceEvent().touches;
</PRE><PRE> for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i &lt; n; ++i) {
   points[i] = point(node, touches[i]);
 }
</PRE><PRE> return points;
</PRE><P>}
</P><P>function nopropagation() {
</P><PRE> exports.event.stopImmediatePropagation();
</PRE><P>}
</P><P>function noevent() {
</P><PRE> exports.event.preventDefault();
 exports.event.stopImmediatePropagation();
</PRE><P>}
</P><P>function dragDisable(view) {
</P><PRE> var root = view.document.documentElement,
     selection$$1 = select(view).on(&quot;dragstart.drag&quot;, noevent, true);
 if (&quot;onselectstart&quot; in root) {
   selection$$1.on(&quot;selectstart.drag&quot;, noevent, true);
 } else {
   root.__noselect = root.style.MozUserSelect;
   root.style.MozUserSelect = &quot;none&quot;;
 }
</PRE><P>}
</P><P>function yesdrag(view, noclick) {
</P><PRE> var root = view.document.documentElement,
     selection$$1 = select(view).on(&quot;dragstart.drag&quot;, null);
 if (noclick) {
   selection$$1.on(&quot;click.drag&quot;, noevent, true);
   setTimeout(function() { selection$$1.on(&quot;click.drag&quot;, null); }, 0);
 }
 if (&quot;onselectstart&quot; in root) {
   selection$$1.on(&quot;selectstart.drag&quot;, null);
 } else {
   root.style.MozUserSelect = root.__noselect;
   delete root.__noselect;
 }
</PRE><P>}
</P><P>function constant$2(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
</P><PRE> this.target = target;
 this.type = type;
 this.subject = subject;
 this.identifier = id;
 this.active = active;
 this.x = x;
 this.y = y;
 this.dx = dx;
 this.dy = dy;
 this._ = dispatch;
</PRE><P>}
</P><P>DragEvent.prototype.on = function() {
</P><PRE> var value = this._.on.apply(this._, arguments);
 return value === this._ ? this : value;
</PRE><P>};
</P><P>// Ignore right-click, since that should open the context menu.
function defaultFilter() {
</P><PRE> return !exports.event.button;
</PRE><P>}
</P><P>function defaultContainer() {
</P><PRE> return this.parentNode;
</PRE><P>}
</P><P>function defaultSubject(d) {
</P><PRE> return d == null ? {x: exports.event.x, y: exports.event.y} : d;
</PRE><P>}
</P><P>function defaultTouchable() {
</P><PRE> return &quot;ontouchstart&quot; in this;
</PRE><P>}
</P><P>function drag() {
</P><PRE> var filter = defaultFilter,
     container = defaultContainer,
     subject = defaultSubject,
     touchable = defaultTouchable,
     gestures = {},
     listeners = dispatch(&quot;start&quot;, &quot;drag&quot;, &quot;end&quot;),
     active = 0,
     mousedownx,
     mousedowny,
     mousemoving,
     touchending,
     clickDistance2 = 0;
</PRE><PRE> function drag(selection$$1) {
   selection$$1
       .on(&quot;mousedown.drag&quot;, mousedowned)
     .filter(touchable)
       .on(&quot;touchstart.drag&quot;, touchstarted)
       .on(&quot;touchmove.drag&quot;, touchmoved)
       .on(&quot;touchend.drag touchcancel.drag&quot;, touchended)
       .style(&quot;touch-action&quot;, &quot;none&quot;)
       .style(&quot;-webkit-tap-highlight-color&quot;, &quot;rgba(0,0,0,0)&quot;);
 }
</PRE><PRE> function mousedowned() {
   if (touchending || !filter.apply(this, arguments)) return;
   var gesture = beforestart(&quot;mouse&quot;, container.apply(this, arguments), mouse, this, arguments);
   if (!gesture) return;
   select(exports.event.view).on(&quot;mousemove.drag&quot;, mousemoved, true).on(&quot;mouseup.drag&quot;, mouseupped, true);
   dragDisable(exports.event.view);
   nopropagation();
   mousemoving = false;
   mousedownx = exports.event.clientX;
   mousedowny = exports.event.clientY;
   gesture(&quot;start&quot;);
 }
</PRE><PRE> function mousemoved() {
   noevent();
   if (!mousemoving) {
     var dx = exports.event.clientX - mousedownx, dy = exports.event.clientY - mousedowny;
     mousemoving = dx * dx + dy * dy &gt; clickDistance2;
   }
   gestures.mouse(&quot;drag&quot;);
 }
</PRE><PRE> function mouseupped() {
   select(exports.event.view).on(&quot;mousemove.drag mouseup.drag&quot;, null);
   yesdrag(exports.event.view, mousemoving);
   noevent();
   gestures.mouse(&quot;end&quot;);
 }
</PRE><PRE> function touchstarted() {
   if (!filter.apply(this, arguments)) return;
   var touches$$1 = exports.event.changedTouches,
       c = container.apply(this, arguments),
       n = touches$$1.length, i, gesture;
</PRE><PRE>   for (i = 0; i &lt; n; ++i) {
     if (gesture = beforestart(touches$$1[i].identifier, c, touch, this, arguments)) {
       nopropagation();
       gesture(&quot;start&quot;);
     }
   }
 }
</PRE><PRE> function touchmoved() {
   var touches$$1 = exports.event.changedTouches,
       n = touches$$1.length, i, gesture;
</PRE><PRE>   for (i = 0; i &lt; n; ++i) {
     if (gesture = gestures[touches$$1[i].identifier]) {
       noevent();
       gesture(&quot;drag&quot;);
     }
   }
 }
</PRE><PRE> function touchended() {
   var touches$$1 = exports.event.changedTouches,
       n = touches$$1.length, i, gesture;
</PRE><PRE>   if (touchending) clearTimeout(touchending);
   touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
   for (i = 0; i &lt; n; ++i) {
     if (gesture = gestures[touches$$1[i].identifier]) {
       nopropagation();
       gesture(&quot;end&quot;);
     }
   }
 }
</PRE><PRE> function beforestart(id, container, point$$1, that, args) {
   var p = point$$1(container, id), s, dx, dy,
       sublisteners = listeners.copy();
</PRE><PRE>   if (!customEvent(new DragEvent(drag, &quot;beforestart&quot;, s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
     if ((exports.event.subject = s = subject.apply(that, args)) == null) return false;
     dx = s.x - p[0] || 0;
     dy = s.y - p[1] || 0;
     return true;
   })) return;
</PRE><PRE>   return function gesture(type) {
     var p0 = p, n;
     switch (type) {
       case &quot;start&quot;: gestures[id] = gesture, n = active++; break;
       case &quot;end&quot;: delete gestures[id], --active; // nobreak
       case &quot;drag&quot;: p = point$$1(container, id), n = active; break;
     }
     customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
   };
 }
</PRE><PRE> drag.filter = function(_) {
   return arguments.length ? (filter = typeof _ === &quot;function&quot; ? _ : constant$2(!!_), drag) : filter;
 };
</PRE><PRE> drag.container = function(_) {
   return arguments.length ? (container = typeof _ === &quot;function&quot; ? _ : constant$2(_), drag) : container;
 };
</PRE><PRE> drag.subject = function(_) {
   return arguments.length ? (subject = typeof _ === &quot;function&quot; ? _ : constant$2(_), drag) : subject;
 };
</PRE><PRE> drag.touchable = function(_) {
   return arguments.length ? (touchable = typeof _ === &quot;function&quot; ? _ : constant$2(!!_), drag) : touchable;
 };
</PRE><PRE> drag.on = function() {
   var value = listeners.on.apply(listeners, arguments);
   return value === listeners ? drag : value;
 };
</PRE><PRE> drag.clickDistance = function(_) {
   return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
 };
</PRE><PRE> return drag;
</PRE><P>}
</P><P>function define(constructor, factory, prototype) {
</P><PRE> constructor.prototype = factory.prototype = prototype;
 prototype.constructor = constructor;
</PRE><P>}
</P><P>function extend(parent, definition) {
</P><PRE> var prototype = Object.create(parent.prototype);
 for (var key in definition) prototype[key] = definition[key];
 return prototype;
</PRE><P>}
</P><P>function Color() {}
</P><P>var darker = 0.7;
var brighter = 1 / darker;
</P><P>var reI = &quot;\\s*([+-]?\\d+)\\s*&quot;,
</P><PRE>   reN = &quot;\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*&quot;,
   reP = &quot;\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*&quot;,
   reHex3 = /^#([0-9a-f]{3})$/,
   reHex6 = /^#([0-9a-f]{6})$/,
   reRgbInteger = new RegExp(&quot;^rgb\\(&quot; + [reI, reI, reI] + &quot;\\)$&quot;),
   reRgbPercent = new RegExp(&quot;^rgb\\(&quot; + [reP, reP, reP] + &quot;\\)$&quot;),
   reRgbaInteger = new RegExp(&quot;^rgba\\(&quot; + [reI, reI, reI, reN] + &quot;\\)$&quot;),
   reRgbaPercent = new RegExp(&quot;^rgba\\(&quot; + [reP, reP, reP, reN] + &quot;\\)$&quot;),
   reHslPercent = new RegExp(&quot;^hsl\\(&quot; + [reN, reP, reP] + &quot;\\)$&quot;),
   reHslaPercent = new RegExp(&quot;^hsla\\(&quot; + [reN, reP, reP, reN] + &quot;\\)$&quot;);
</PRE><P>var named = {
</P><PRE> aliceblue: 0xf0f8ff,
 antiquewhite: 0xfaebd7,
 aqua: 0x00ffff,
 aquamarine: 0x7fffd4,
 azure: 0xf0ffff,
 beige: 0xf5f5dc,
 bisque: 0xffe4c4,
 black: 0x000000,
 blanchedalmond: 0xffebcd,
 blue: 0x0000ff,
 blueviolet: 0x8a2be2,
 brown: 0xa52a2a,
 burlywood: 0xdeb887,
 cadetblue: 0x5f9ea0,
 chartreuse: 0x7fff00,
 chocolate: 0xd2691e,
 coral: 0xff7f50,
 cornflowerblue: 0x6495ed,
 cornsilk: 0xfff8dc,
 crimson: 0xdc143c,
 cyan: 0x00ffff,
 darkblue: 0x00008b,
 darkcyan: 0x008b8b,
 darkgoldenrod: 0xb8860b,
 darkgray: 0xa9a9a9,
 darkgreen: 0x006400,
 darkgrey: 0xa9a9a9,
 darkkhaki: 0xbdb76b,
 darkmagenta: 0x8b008b,
 darkolivegreen: 0x556b2f,
 darkorange: 0xff8c00,
 darkorchid: 0x9932cc,
 darkred: 0x8b0000,
 darksalmon: 0xe9967a,
 darkseagreen: 0x8fbc8f,
 darkslateblue: 0x483d8b,
 darkslategray: 0x2f4f4f,
 darkslategrey: 0x2f4f4f,
 darkturquoise: 0x00ced1,
 darkviolet: 0x9400d3,
 deeppink: 0xff1493,
 deepskyblue: 0x00bfff,
 dimgray: 0x696969,
 dimgrey: 0x696969,
 dodgerblue: 0x1e90ff,
 firebrick: 0xb22222,
 floralwhite: 0xfffaf0,
 forestgreen: 0x228b22,
 fuchsia: 0xff00ff,
 gainsboro: 0xdcdcdc,
 ghostwhite: 0xf8f8ff,
 gold: 0xffd700,
 goldenrod: 0xdaa520,
 gray: 0x808080,
 green: 0x008000,
 greenyellow: 0xadff2f,
 grey: 0x808080,
 honeydew: 0xf0fff0,
 hotpink: 0xff69b4,
 indianred: 0xcd5c5c,
 indigo: 0x4b0082,
 ivory: 0xfffff0,
 khaki: 0xf0e68c,
 lavender: 0xe6e6fa,
 lavenderblush: 0xfff0f5,
 lawngreen: 0x7cfc00,
 lemonchiffon: 0xfffacd,
 lightblue: 0xadd8e6,
 lightcoral: 0xf08080,
 lightcyan: 0xe0ffff,
 lightgoldenrodyellow: 0xfafad2,
 lightgray: 0xd3d3d3,
 lightgreen: 0x90ee90,
 lightgrey: 0xd3d3d3,
 lightpink: 0xffb6c1,
 lightsalmon: 0xffa07a,
 lightseagreen: 0x20b2aa,
 lightskyblue: 0x87cefa,
 lightslategray: 0x778899,
 lightslategrey: 0x778899,
 lightsteelblue: 0xb0c4de,
 lightyellow: 0xffffe0,
 lime: 0x00ff00,
 limegreen: 0x32cd32,
 linen: 0xfaf0e6,
 magenta: 0xff00ff,
 maroon: 0x800000,
 mediumaquamarine: 0x66cdaa,
 mediumblue: 0x0000cd,
 mediumorchid: 0xba55d3,
 mediumpurple: 0x9370db,
 mediumseagreen: 0x3cb371,
 mediumslateblue: 0x7b68ee,
 mediumspringgreen: 0x00fa9a,
 mediumturquoise: 0x48d1cc,
 mediumvioletred: 0xc71585,
 midnightblue: 0x191970,
 mintcream: 0xf5fffa,
 mistyrose: 0xffe4e1,
 moccasin: 0xffe4b5,
 navajowhite: 0xffdead,
 navy: 0x000080,
 oldlace: 0xfdf5e6,
 olive: 0x808000,
 olivedrab: 0x6b8e23,
 orange: 0xffa500,
 orangered: 0xff4500,
 orchid: 0xda70d6,
 palegoldenrod: 0xeee8aa,
 palegreen: 0x98fb98,
 paleturquoise: 0xafeeee,
 palevioletred: 0xdb7093,
 papayawhip: 0xffefd5,
 peachpuff: 0xffdab9,
 peru: 0xcd853f,
 pink: 0xffc0cb,
 plum: 0xdda0dd,
 powderblue: 0xb0e0e6,
 purple: 0x800080,
 rebeccapurple: 0x663399,
 red: 0xff0000,
 rosybrown: 0xbc8f8f,
 royalblue: 0x4169e1,
 saddlebrown: 0x8b4513,
 salmon: 0xfa8072,
 sandybrown: 0xf4a460,
 seagreen: 0x2e8b57,
 seashell: 0xfff5ee,
 sienna: 0xa0522d,
 silver: 0xc0c0c0,
 skyblue: 0x87ceeb,
 slateblue: 0x6a5acd,
 slategray: 0x708090,
 slategrey: 0x708090,
 snow: 0xfffafa,
 springgreen: 0x00ff7f,
 steelblue: 0x4682b4,
 tan: 0xd2b48c,
 teal: 0x008080,
 thistle: 0xd8bfd8,
 tomato: 0xff6347,
 turquoise: 0x40e0d0,
 violet: 0xee82ee,
 wheat: 0xf5deb3,
 white: 0xffffff,
 whitesmoke: 0xf5f5f5,
 yellow: 0xffff00,
 yellowgreen: 0x9acd32
</PRE><P>};
</P><P>define(Color, color, {
</P><PRE> displayable: function() {
   return this.rgb().displayable();
 },
 hex: function() {
   return this.rgb().hex();
 },
 toString: function() {
   return this.rgb() + &quot;&quot;;
 }
</PRE><P>});
</P><P>function color(format) {
</P><PRE> var m;
 format = (format + &quot;&quot;).trim().toLowerCase();
 return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m &gt;&gt; 8 &amp; 0xf) | (m &gt;&gt; 4 &amp; 0x0f0), (m &gt;&gt; 4 &amp; 0xf) | (m &amp; 0xf0), ((m &amp; 0xf) &lt;&lt; 4) | (m &amp; 0xf), 1)) // #f00
     : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
     : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
     : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
     : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
     : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
     : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
     : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
     : named.hasOwnProperty(format) ? rgbn(named[format])
     : format === &quot;transparent&quot; ? new Rgb(NaN, NaN, NaN, 0)
     : null;
</PRE><P>}
</P><P>function rgbn(n) {
</P><PRE> return new Rgb(n &gt;&gt; 16 &amp; 0xff, n &gt;&gt; 8 &amp; 0xff, n &amp; 0xff, 1);
</PRE><P>}
</P><P>function rgba(r, g, b, a) {
</P><PRE> if (a &lt;= 0) r = g = b = NaN;
 return new Rgb(r, g, b, a);
</PRE><P>}
</P><P>function rgbConvert(o) {
</P><PRE> if (!(o instanceof Color)) o = color(o);
 if (!o) return new Rgb;
 o = o.rgb();
 return new Rgb(o.r, o.g, o.b, o.opacity);
</PRE><P>}
</P><P>function rgb(r, g, b, opacity) {
</P><PRE> return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
</PRE><P>}
</P><P>function Rgb(r, g, b, opacity) {
</P><PRE> this.r = +r;
 this.g = +g;
 this.b = +b;
 this.opacity = +opacity;
</PRE><P>}
</P><P>define(Rgb, rgb, extend(Color, {
</P><PRE> brighter: function(k) {
   k = k == null ? brighter : Math.pow(brighter, k);
   return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
 },
 darker: function(k) {
   k = k == null ? darker : Math.pow(darker, k);
   return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
 },
 rgb: function() {
   return this;
 },
 displayable: function() {
   return (0 &lt;= this.r &amp;&amp; this.r &lt;= 255)
       &amp;&amp; (0 &lt;= this.g &amp;&amp; this.g &lt;= 255)
       &amp;&amp; (0 &lt;= this.b &amp;&amp; this.b &lt;= 255)
       &amp;&amp; (0 &lt;= this.opacity &amp;&amp; this.opacity &lt;= 1);
 },
 hex: function() {
   return &quot;#&quot; + hex(this.r) + hex(this.g) + hex(this.b);
 },
 toString: function() {
   var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
   return (a === 1 ? &quot;rgb(&quot; : &quot;rgba(&quot;)
       + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + &quot;, &quot;
       + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + &quot;, &quot;
       + Math.max(0, Math.min(255, Math.round(this.b) || 0))
       + (a === 1 ? &quot;)&quot; : &quot;, &quot; + a + &quot;)&quot;);
 }
</PRE><P>}));
</P><P>function hex(value) {
</P><PRE> value = Math.max(0, Math.min(255, Math.round(value) || 0));
 return (value &lt; 16 ? &quot;0&quot; : &quot;&quot;) + value.toString(16);
</PRE><P>}
</P><P>function hsla(h, s, l, a) {
</P><PRE> if (a &lt;= 0) h = s = l = NaN;
 else if (l &lt;= 0 || l &gt;= 1) h = s = NaN;
 else if (s &lt;= 0) h = NaN;
 return new Hsl(h, s, l, a);
</PRE><P>}
</P><P>function hslConvert(o) {
</P><PRE> if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
 if (!(o instanceof Color)) o = color(o);
 if (!o) return new Hsl;
 if (o instanceof Hsl) return o;
 o = o.rgb();
 var r = o.r / 255,
     g = o.g / 255,
     b = o.b / 255,
     min = Math.min(r, g, b),
     max = Math.max(r, g, b),
     h = NaN,
     s = max - min,
     l = (max + min) / 2;
 if (s) {
   if (r === max) h = (g - b) / s + (g &lt; b) * 6;
   else if (g === max) h = (b - r) / s + 2;
   else h = (r - g) / s + 4;
   s /= l &lt; 0.5 ? max + min : 2 - max - min;
   h *= 60;
 } else {
   s = l &gt; 0 &amp;&amp; l &lt; 1 ? 0 : h;
 }
 return new Hsl(h, s, l, o.opacity);
</PRE><P>}
</P><P>function hsl(h, s, l, opacity) {
</P><PRE> return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
</PRE><P>}
</P><P>function Hsl(h, s, l, opacity) {
</P><PRE> this.h = +h;
 this.s = +s;
 this.l = +l;
 this.opacity = +opacity;
</PRE><P>}
</P><P>define(Hsl, hsl, extend(Color, {
</P><PRE> brighter: function(k) {
   k = k == null ? brighter : Math.pow(brighter, k);
   return new Hsl(this.h, this.s, this.l * k, this.opacity);
 },
 darker: function(k) {
   k = k == null ? darker : Math.pow(darker, k);
   return new Hsl(this.h, this.s, this.l * k, this.opacity);
 },
 rgb: function() {
   var h = this.h % 360 + (this.h &lt; 0) * 360,
       s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
       l = this.l,
       m2 = l + (l &lt; 0.5 ? l : 1 - l) * s,
       m1 = 2 * l - m2;
   return new Rgb(
     hsl2rgb(h &gt;= 240 ? h - 240 : h + 120, m1, m2),
     hsl2rgb(h, m1, m2),
     hsl2rgb(h &lt; 120 ? h + 240 : h - 120, m1, m2),
     this.opacity
   );
 },
 displayable: function() {
   return (0 &lt;= this.s &amp;&amp; this.s &lt;= 1 || isNaN(this.s))
       &amp;&amp; (0 &lt;= this.l &amp;&amp; this.l &lt;= 1)
       &amp;&amp; (0 &lt;= this.opacity &amp;&amp; this.opacity &lt;= 1);
 }
</PRE><P>}));
</P><P>/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
</P><PRE> return (h &lt; 60 ? m1 + (m2 - m1) * h / 60
     : h &lt; 180 ? m2
     : h &lt; 240 ? m1 + (m2 - m1) * (240 - h) / 60
     : m1) * 255;
</PRE><P>}
</P><P>var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;
</P><P>// <A rel="nofollow" class="external free" href="https://beta.observablehq.com/@mbostock/lab-and-rgb">https://beta.observablehq.com/@mbostock/lab-and-rgb</A>
var K = 18,
</P><PRE>   Xn = 0.96422,
   Yn = 1,
   Zn = 0.82521,
   t0 = 4 / 29,
   t1 = 6 / 29,
   t2 = 3 * t1 * t1,
   t3 = t1 * t1 * t1;
</PRE><P>function labConvert(o) {
</P><PRE> if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
 if (o instanceof Hcl) {
   if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
   var h = o.h * deg2rad;
   return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
 }
 if (!(o instanceof Rgb)) o = rgbConvert(o);
 var r = rgb2lrgb(o.r),
     g = rgb2lrgb(o.g),
     b = rgb2lrgb(o.b),
     y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
 if (r === g &amp;&amp; g === b) x = z = y; else {
   x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
   z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
 }
 return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
</PRE><P>}
</P><P>function gray(l, opacity) {
</P><PRE> return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
</PRE><P>}
</P><P>function lab(l, a, b, opacity) {
</P><PRE> return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
</PRE><P>}
</P><P>function Lab(l, a, b, opacity) {
</P><PRE> this.l = +l;
 this.a = +a;
 this.b = +b;
 this.opacity = +opacity;
</PRE><P>}
</P><P>define(Lab, lab, extend(Color, {
</P><PRE> brighter: function(k) {
   return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
 },
 darker: function(k) {
   return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
 },
 rgb: function() {
   var y = (this.l + 16) / 116,
       x = isNaN(this.a) ? y : y + this.a / 500,
       z = isNaN(this.b) ? y : y - this.b / 200;
   x = Xn * lab2xyz(x);
   y = Yn * lab2xyz(y);
   z = Zn * lab2xyz(z);
   return new Rgb(
     lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
     lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
     lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
     this.opacity
   );
 }
</PRE><P>}));
</P><P>function xyz2lab(t) {
</P><PRE> return t &gt; t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
</PRE><P>}
</P><P>function lab2xyz(t) {
</P><PRE> return t &gt; t1 ? t * t * t : t2 * (t - t0);
</PRE><P>}
</P><P>function lrgb2rgb(x) {
</P><PRE> return 255 * (x &lt;= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
</PRE><P>}
</P><P>function rgb2lrgb(x) {
</P><PRE> return (x /= 255) &lt;= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
</PRE><P>}
</P><P>function hclConvert(o) {
</P><PRE> if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
 if (!(o instanceof Lab)) o = labConvert(o);
 if (o.a === 0 &amp;&amp; o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
 var h = Math.atan2(o.b, o.a) * rad2deg;
 return new Hcl(h &lt; 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
</PRE><P>}
</P><P>function lch(l, c, h, opacity) {
</P><PRE> return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
</PRE><P>}
</P><P>function hcl(h, c, l, opacity) {
</P><PRE> return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
</PRE><P>}
</P><P>function Hcl(h, c, l, opacity) {
</P><PRE> this.h = +h;
 this.c = +c;
 this.l = +l;
 this.opacity = +opacity;
</PRE><P>}
</P><P>define(Hcl, hcl, extend(Color, {
</P><PRE> brighter: function(k) {
   return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
 },
 darker: function(k) {
   return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
 },
 rgb: function() {
   return labConvert(this).rgb();
 }
</PRE><P>}));
</P><P>var A = -0.14861,
</P><PRE>   B = +1.78277,
   C = -0.29227,
   D = -0.90649,
   E = +1.97294,
   ED = E * D,
   EB = E * B,
   BC_DA = B * C - D * A;
</PRE><P>function cubehelixConvert(o) {
</P><PRE> if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
 if (!(o instanceof Rgb)) o = rgbConvert(o);
 var r = o.r / 255,
     g = o.g / 255,
     b = o.b / 255,
     l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
     bl = b - l,
     k = (E * (g - l) - C * bl) / D,
     s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
     h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
 return new Cubehelix(h &lt; 0 ? h + 360 : h, s, l, o.opacity);
</PRE><P>}
</P><P>function cubehelix(h, s, l, opacity) {
</P><PRE> return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
</PRE><P>}
</P><P>function Cubehelix(h, s, l, opacity) {</P><PRE> this.h = +h;
 this.s = +s;
 this.l = +l;
 this.opacity = +opacity;
</PRE><P>}
</P><P>define(Cubehelix, cubehelix, extend(Color, {
</P><PRE> brighter: function(k) {
   k = k == null ? brighter : Math.pow(brighter, k);
   return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
 },
 darker: function(k) {
   k = k == null ? darker : Math.pow(darker, k);
   return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
 },
 rgb: function() {
   var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
       l = +this.l,
       a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
       cosh = Math.cos(h),
       sinh = Math.sin(h);
   return new Rgb(
     255 * (l + a * (A * cosh + B * sinh)),
     255 * (l + a * (C * cosh + D * sinh)),
     255 * (l + a * (E * cosh)),
     this.opacity
   );
 }
</PRE><P>}));
</P><P>function basis(t1, v0, v1, v2, v3) {
</P><PRE> var t2 = t1 * t1, t3 = t2 * t1;
 return ((1 - 3 * t1 + 3 * t2 - t3) * v0
     + (4 - 6 * t2 + 3 * t3) * v1
     + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
     + t3 * v3) / 6;
</PRE><P>}
</P><P>function basis$1(values) {
</P><PRE> var n = values.length - 1;
 return function(t) {
   var i = t &lt;= 0 ? (t = 0) : t &gt;= 1 ? (t = 1, n - 1) : Math.floor(t * n),
       v1 = values[i],
       v2 = values[i + 1],
       v0 = i &gt; 0 ? values[i - 1] : 2 * v1 - v2,
       v3 = i &lt; n - 1 ? values[i + 2] : 2 * v2 - v1;
   return basis((t - i / n) * n, v0, v1, v2, v3);
 };
</PRE><P>}
</P><P>function basisClosed(values) {
</P><PRE> var n = values.length;
 return function(t) {
   var i = Math.floor(((t %= 1) &lt; 0 ? ++t : t) * n),
       v0 = values[(i + n - 1) % n],
       v1 = values[i % n],
       v2 = values[(i + 1) % n],
       v3 = values[(i + 2) % n];
   return basis((t - i / n) * n, v0, v1, v2, v3);
 };
</PRE><P>}
</P><P>function constant$3(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function linear(a, d) {
</P><PRE> return function(t) {
   return a + t * d;
 };
</PRE><P>}
</P><P>function exponential(a, b, y) {
</P><PRE> return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
   return Math.pow(a + t * b, y);
 };
</PRE><P>}
</P><P>function hue(a, b) {
</P><PRE> var d = b - a;
 return d ? linear(a, d &gt; 180 || d &lt; -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
</PRE><P>}
</P><P>function gamma(y) {
</P><PRE> return (y = +y) === 1 ? nogamma : function(a, b) {
   return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
 };
</PRE><P>}
</P><P>function nogamma(a, b) {
</P><PRE> var d = b - a;
 return d ? linear(a, d) : constant$3(isNaN(a) ? b : a);
</PRE><P>}
</P><P>var interpolateRgb = (function rgbGamma(y) {
</P><PRE> var color$$1 = gamma(y);
</PRE><PRE> function rgb$$1(start, end) {
   var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
       g = color$$1(start.g, end.g),
       b = color$$1(start.b, end.b),
       opacity = nogamma(start.opacity, end.opacity);
   return function(t) {
     start.r = r(t);
     start.g = g(t);
     start.b = b(t);
     start.opacity = opacity(t);
     return start + &quot;&quot;;
   };
 }
</PRE><PRE> rgb$$1.gamma = rgbGamma;
</PRE><PRE> return rgb$$1;
</PRE><P>})(1);
</P><P>function rgbSpline(spline) {
</P><PRE> return function(colors) {
   var n = colors.length,
       r = new Array(n),
       g = new Array(n),
       b = new Array(n),
       i, color$$1;
   for (i = 0; i &lt; n; ++i) {
     color$$1 = rgb(colors[i]);
     r[i] = color$$1.r || 0;
     g[i] = color$$1.g || 0;
     b[i] = color$$1.b || 0;
   }
   r = spline(r);
   g = spline(g);
   b = spline(b);
   color$$1.opacity = 1;
   return function(t) {
     color$$1.r = r(t);
     color$$1.g = g(t);
     color$$1.b = b(t);
     return color$$1 + &quot;&quot;;
   };
 };
</PRE><P>}
</P><P>var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);
</P><P>function array$1(a, b) {
</P><PRE> var nb = b ? b.length : 0,
     na = a ? Math.min(nb, a.length) : 0,
     x = new Array(na),
     c = new Array(nb),
     i;
</PRE><PRE> for (i = 0; i &lt; na; ++i) x[i] = interpolateValue(a[i], b[i]);
 for (; i &lt; nb; ++i) c[i] = b[i];
</PRE><PRE> return function(t) {
   for (i = 0; i &lt; na; ++i) c[i] = x[i](t);
   return c;
 };
</PRE><P>}
</P><P>function date(a, b) {
</P><PRE> var d = new Date;
 return a = +a, b -= a, function(t) {
   return d.setTime(a + b * t), d;
 };
</PRE><P>}
</P><P>function interpolateNumber(a, b) {
</P><PRE> return a = +a, b -= a, function(t) {
   return a + b * t;
 };
</PRE><P>}
</P><P>function object(a, b) {
</P><PRE> var i = {},
     c = {},
     k;
</PRE><PRE> if (a === null || typeof a !== &quot;object&quot;) a = {};
 if (b === null || typeof b !== &quot;object&quot;) b = {};
</PRE><PRE> for (k in b) {
   if (k in a) {
     i[k] = interpolateValue(a[k], b[k]);
   } else {
     c[k] = b[k];
   }
 }
</PRE><PRE> return function(t) {
   for (k in i) c[k] = i[k](t);
   return c;
 };
</PRE><P>}
</P><P>var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
</P><PRE>   reB = new RegExp(reA.source, &quot;g&quot;);
</PRE><P>function zero(b) {
</P><PRE> return function() {
   return b;
 };
</PRE><P>}
</P><P>function one(b) {
</P><PRE> return function(t) {
   return b(t) + &quot;&quot;;
 };
</PRE><P>}
</P><P>function interpolateString(a, b) {
</P><PRE> var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
     am, // current match in a
     bm, // current match in b
     bs, // string preceding current number in b, if any
     i = -1, // index in s
     s = [], // string constants and placeholders
     q = []; // number interpolators
</PRE><PRE> // Coerce inputs to strings.
 a = a + &quot;&quot;, b = b + &quot;&quot;;
</PRE><PRE> // Interpolate pairs of numbers in a &amp; b.
 while ((am = reA.exec(a))
     &amp;&amp; (bm = reB.exec(b))) {
   if ((bs = bm.index) &gt; bi) { // a string precedes the next number in b
     bs = b.slice(bi, bs);
     if (s[i]) s[i] += bs; // coalesce with previous string
     else s[++i] = bs;
   }
   if ((am = am[0]) === (bm = bm[0])) { // numbers in a &amp; b match
     if (s[i]) s[i] += bm; // coalesce with previous string
     else s[++i] = bm;
   } else { // interpolate non-matching numbers
     s[++i] = null;
     q.push({i: i, x: interpolateNumber(am, bm)});
   }
   bi = reB.lastIndex;
 }
</PRE><PRE> // Add remains of b.
 if (bi &lt; b.length) {
   bs = b.slice(bi);
   if (s[i]) s[i] += bs; // coalesce with previous string
   else s[++i] = bs;
 }
</PRE><PRE> // Special optimization for only a single match.
 // Otherwise, interpolate each of the numbers and rejoin the string.
 return s.length &lt; 2 ? (q[0]
     ? one(q[0].x)
     : zero(b))
     : (b = q.length, function(t) {
         for (var i = 0, o; i &lt; b; ++i) s[(o = q[i]).i] = o.x(t);
         return s.join(&quot;&quot;);
       });
</PRE><P>}
</P><P>function interpolateValue(a, b) {
</P><PRE> var t = typeof b, c;
 return b == null || t === &quot;boolean&quot; ? constant$3(b)
     : (t === &quot;number&quot; ? interpolateNumber
     : t === &quot;string&quot; ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
     : b instanceof color ? interpolateRgb
     : b instanceof Date ? date
     : Array.isArray(b) ? array$1
     : typeof b.valueOf !== &quot;function&quot; &amp;&amp; typeof b.toString !== &quot;function&quot; || isNaN(b) ? object
     : interpolateNumber)(a, b);
</PRE><P>}
</P><P>function discrete(range) {
</P><PRE> var n = range.length;
 return function(t) {
   return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
 };
</PRE><P>}
</P><P>function hue$1(a, b) {
</P><PRE> var i = hue(+a, +b);
 return function(t) {
   var x = i(t);
   return x - 360 * Math.floor(x / 360);
 };
</PRE><P>}
</P><P>function interpolateRound(a, b) {
</P><PRE> return a = +a, b -= a, function(t) {
   return Math.round(a + b * t);
 };
</PRE><P>}
</P><P>var degrees = 180 / Math.PI;
</P><P>var identity$2 = {
</P><PRE> translateX: 0,
 translateY: 0,
 rotate: 0,
 skewX: 0,
 scaleX: 1,
 scaleY: 1
</PRE><P>};
</P><P>function decompose(a, b, c, d, e, f) {
</P><PRE> var scaleX, scaleY, skewX;
 if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
 if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
 if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
 if (a * d &lt; b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
 return {
   translateX: e,
   translateY: f,
   rotate: Math.atan2(b, a) * degrees,
   skewX: Math.atan(skewX) * degrees,
   scaleX: scaleX,
   scaleY: scaleY
 };
</PRE><P>}
</P><P>var cssNode,
</P><PRE>   cssRoot,
   cssView,
   svgNode;
</PRE><P>function parseCss(value) {
</P><PRE> if (value === &quot;none&quot;) return identity$2;
 if (!cssNode) cssNode = document.createElement(&quot;DIV&quot;), cssRoot = document.documentElement, cssView = document.defaultView;
 cssNode.style.transform = value;
 value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue(&quot;transform&quot;);
 cssRoot.removeChild(cssNode);
 value = value.slice(7, -1).split(&quot;,&quot;);
 return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
</PRE><P>}
</P><P>function parseSvg(value) {
</P><PRE> if (value == null) return identity$2;
 if (!svgNode) svgNode = document.createElementNS(&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot;, &quot;g&quot;);
 svgNode.setAttribute(&quot;transform&quot;, value);
 if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
 value = value.matrix;
 return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
</PRE><P>}
</P><P>function interpolateTransform(parse, pxComma, pxParen, degParen) {
</P><PRE> function pop(s) {
   return s.length ? s.pop() + &quot; &quot; : &quot;&quot;;
 }
</PRE><PRE> function translate(xa, ya, xb, yb, s, q) {
   if (xa !== xb || ya !== yb) {
     var i = s.push(&quot;translate(&quot;, null, pxComma, null, pxParen);
     q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
   } else if (xb || yb) {
     s.push(&quot;translate(&quot; + xb + pxComma + yb + pxParen);
   }
 }
</PRE><PRE> function rotate(a, b, s, q) {
   if (a !== b) {
     if (a - b &gt; 180) b += 360; else if (b - a &gt; 180) a += 360; // shortest path
     q.push({i: s.push(pop(s) + &quot;rotate(&quot;, null, degParen) - 2, x: interpolateNumber(a, b)});
   } else if (b) {
     s.push(pop(s) + &quot;rotate(&quot; + b + degParen);
   }
 }
</PRE><PRE> function skewX(a, b, s, q) {
   if (a !== b) {
     q.push({i: s.push(pop(s) + &quot;skewX(&quot;, null, degParen) - 2, x: interpolateNumber(a, b)});
   } else if (b) {
     s.push(pop(s) + &quot;skewX(&quot; + b + degParen);
   }
 }
</PRE><PRE> function scale(xa, ya, xb, yb, s, q) {
   if (xa !== xb || ya !== yb) {
     var i = s.push(pop(s) + &quot;scale(&quot;, null, &quot;,&quot;, null, &quot;)&quot;);
     q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
   } else if (xb !== 1 || yb !== 1) {
     s.push(pop(s) + &quot;scale(&quot; + xb + &quot;,&quot; + yb + &quot;)&quot;);
   }
 }
</PRE><PRE> return function(a, b) {
   var s = [], // string constants and placeholders
       q = []; // number interpolators
   a = parse(a), b = parse(b);
   translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
   rotate(a.rotate, b.rotate, s, q);
   skewX(a.skewX, b.skewX, s, q);
   scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
   a = b = null; // gc
   return function(t) {
     var i = -1, n = q.length, o;
     while (++i &lt; n) s[(o = q[i]).i] = o.x(t);
     return s.join(&quot;&quot;);
   };
 };
</PRE><P>}
</P><P>var interpolateTransformCss = interpolateTransform(parseCss, &quot;px, &quot;, &quot;px)&quot;, &quot;deg)&quot;);
var interpolateTransformSvg = interpolateTransform(parseSvg, &quot;, &quot;, &quot;)&quot;, &quot;)&quot;);
</P><P>var rho = Math.SQRT2,
</P><PRE>   rho2 = 2,
   rho4 = 4,
   epsilon2 = 1e-12;
</PRE><P>function cosh(x) {
</P><PRE> return ((x = Math.exp(x)) + 1 / x) / 2;
</PRE><P>}
</P><P>function sinh(x) {
</P><PRE> return ((x = Math.exp(x)) - 1 / x) / 2;
</PRE><P>}
</P><P>function tanh(x) {
</P><PRE> return ((x = Math.exp(2 * x)) - 1) / (x + 1);
</PRE><P>}
</P><P>// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function interpolateZoom(p0, p1) {
</P><PRE> var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
     ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
     dx = ux1 - ux0,
     dy = uy1 - uy0,
     d2 = dx * dx + dy * dy,
     i,
     S;
</PRE><PRE> // Special case for u0 ≅ u1.
 if (d2 &lt; epsilon2) {
   S = Math.log(w1 / w0) / rho;
   i = function(t) {
     return [
       ux0 + t * dx,
       uy0 + t * dy,
       w0 * Math.exp(rho * t * S)
     ];
   };
 }
</PRE><PRE> // General case.
 else {
   var d1 = Math.sqrt(d2),
       b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
       b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
       r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
       r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
   S = (r1 - r0) / rho;
   i = function(t) {
     var s = t * S,
         coshr0 = cosh(r0),
         u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
     return [
       ux0 + u * dx,
       uy0 + u * dy,
       w0 * coshr0 / cosh(rho * s + r0)
     ];
   };
 }
</PRE><PRE> i.duration = S * 1000;
</PRE><PRE> return i;
</PRE><P>}
</P><P>function hsl$1(hue$$1) {
</P><PRE> return function(start, end) {
   var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h),
       s = nogamma(start.s, end.s),
       l = nogamma(start.l, end.l),
       opacity = nogamma(start.opacity, end.opacity);
   return function(t) {
     start.h = h(t);
     start.s = s(t);
     start.l = l(t);
     start.opacity = opacity(t);
     return start + &quot;&quot;;
   };
 }
</PRE><P>}
</P><P>var hsl$2 = hsl$1(hue);
var hslLong = hsl$1(nogamma);
</P><P>function lab$1(start, end) {
</P><PRE> var l = nogamma((start = lab(start)).l, (end = lab(end)).l),
     a = nogamma(start.a, end.a),
     b = nogamma(start.b, end.b),
     opacity = nogamma(start.opacity, end.opacity);
 return function(t) {
   start.l = l(t);
   start.a = a(t);
   start.b = b(t);
   start.opacity = opacity(t);
   return start + &quot;&quot;;
 };
</PRE><P>}
</P><P>function hcl$1(hue$$1) {
</P><PRE> return function(start, end) {
   var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h),
       c = nogamma(start.c, end.c),
       l = nogamma(start.l, end.l),
       opacity = nogamma(start.opacity, end.opacity);
   return function(t) {
     start.h = h(t);
     start.c = c(t);
     start.l = l(t);
     start.opacity = opacity(t);
     return start + &quot;&quot;;
   };
 }
</PRE><P>}
</P><P>var hcl$2 = hcl$1(hue);
var hclLong = hcl$1(nogamma);
</P><P>function cubehelix$1(hue$$1) {
</P><PRE> return (function cubehelixGamma(y) {
   y = +y;
</PRE><PRE>   function cubehelix$$1(start, end) {
     var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
         s = nogamma(start.s, end.s),
         l = nogamma(start.l, end.l),
         opacity = nogamma(start.opacity, end.opacity);
     return function(t) {
       start.h = h(t);
       start.s = s(t);
       start.l = l(Math.pow(t, y));
       start.opacity = opacity(t);
       return start + &quot;&quot;;
     };
   }
</PRE><PRE>   cubehelix$$1.gamma = cubehelixGamma;
</PRE><PRE>   return cubehelix$$1;
 })(1);
</PRE><P>}
</P><P>var cubehelix$2 = cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);
</P><P>function piecewise(interpolate, values) {
</P><PRE> var i = 0, n = values.length - 1, v = values[0], I = new Array(n &lt; 0 ? 0 : n);
 while (i &lt; n) I[i] = interpolate(v, v = values[++i]);
 return function(t) {
   var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
   return I[i](t - i);
 };
</PRE><P>}
</P><P>function quantize(interpolator, n) {
</P><PRE> var samples = new Array(n);
 for (var i = 0; i &lt; n; ++i) samples[i] = interpolator(i / (n - 1));
 return samples;
</PRE><P>}
</P><P>var frame = 0, // is an animation frame pending?
</P><PRE>   timeout = 0, // is a timeout pending?
   interval = 0, // are any timers active?
   pokeDelay = 1000, // how frequently we check for clock skew
   taskHead,
   taskTail,
   clockLast = 0,
   clockNow = 0,
   clockSkew = 0,
   clock = typeof performance === &quot;object&quot; &amp;&amp; performance.now ? performance : Date,
   setFrame = typeof window === &quot;object&quot; &amp;&amp; window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };
</PRE><P>function now() {
</P><PRE> return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
</PRE><P>}
</P><P>function clearNow() {
</P><PRE> clockNow = 0;
</PRE><P>}
</P><P>function Timer() {
</P><PRE> this._call =
 this._time =
 this._next = null;
</PRE><P>}
</P><P>Timer.prototype = timer.prototype = {
</P><PRE> constructor: Timer,
 restart: function(callback, delay, time) {
   if (typeof callback !== &quot;function&quot;) throw new TypeError(&quot;callback is not a function&quot;);
   time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
   if (!this._next &amp;&amp; taskTail !== this) {
     if (taskTail) taskTail._next = this;
     else taskHead = this;
     taskTail = this;
   }
   this._call = callback;
   this._time = time;
   sleep();
 },
 stop: function() {
   if (this._call) {
     this._call = null;
     this._time = Infinity;
     sleep();
   }
 }
</PRE><P>};
</P><P>function timer(callback, delay, time) {
</P><PRE> var t = new Timer;
 t.restart(callback, delay, time);
 return t;
</PRE><P>}
</P><P>function timerFlush() {
</P><PRE> now(); // Get the current time, if not already set.
 ++frame; // Pretend we’ve set an alarm, if we haven’t already.
 var t = taskHead, e;
 while (t) {
   if ((e = clockNow - t._time) &gt;= 0) t._call.call(null, e);
   t = t._next;
 }
 --frame;
</PRE><P>}
</P><P>function wake() {
</P><PRE> clockNow = (clockLast = clock.now()) + clockSkew;
 frame = timeout = 0;
 try {
   timerFlush();
 } finally {
   frame = 0;
   nap();
   clockNow = 0;
 }
</PRE><P>}
</P><P>function poke() {
</P><PRE> var now = clock.now(), delay = now - clockLast;
 if (delay &gt; pokeDelay) clockSkew -= delay, clockLast = now;
</PRE><P>}
</P><P>function nap() {
</P><PRE> var t0, t1 = taskHead, t2, time = Infinity;
 while (t1) {
   if (t1._call) {
     if (time &gt; t1._time) time = t1._time;
     t0 = t1, t1 = t1._next;
   } else {
     t2 = t1._next, t1._next = null;
     t1 = t0 ? t0._next = t2 : taskHead = t2;
   }
 }
 taskTail = t0;
 sleep(time);
</PRE><P>}
</P><P>function sleep(time) {
</P><PRE> if (frame) return; // Soonest alarm already set, or will be.
 if (timeout) timeout = clearTimeout(timeout);
 var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
 if (delay &gt; 24) {
   if (time &lt; Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
   if (interval) interval = clearInterval(interval);
 } else {
   if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
   frame = 1, setFrame(wake);
 }
</PRE><P>}
</P><P>function timeout$1(callback, delay, time) {
</P><PRE> var t = new Timer;
 delay = delay == null ? 0 : +delay;
 t.restart(function(elapsed) {
   t.stop();
   callback(elapsed + delay);
 }, delay, time);
 return t;
</PRE><P>}
</P><P>function interval$1(callback, delay, time) {
</P><PRE> var t = new Timer, total = delay;
 if (delay == null) return t.restart(callback, delay, time), t;
 delay = +delay, time = time == null ? now() : +time;
 t.restart(function tick(elapsed) {
   elapsed += total;
   t.restart(tick, total += delay, time);
   callback(elapsed);
 }, delay, time);
 return t;
</PRE><P>}
</P><P>var emptyOn = dispatch(&quot;start&quot;, &quot;end&quot;, &quot;interrupt&quot;);
var emptyTween = [];
</P><P>var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
</P><P>function schedule(node, name, id, index, group, timing) {
</P><PRE> var schedules = node.__transition;
 if (!schedules) node.__transition = {};
 else if (id in schedules) return;
 create$1(node, id, {
   name: name,
   index: index, // For context during callback.
   group: group, // For context during callback.
   on: emptyOn,
   tween: emptyTween,
   time: timing.time,
   delay: timing.delay,
   duration: timing.duration,
   ease: timing.ease,
   timer: null,
   state: CREATED
 });
</PRE><P>}
</P><P>function init(node, id) {
</P><PRE> var schedule = get$1(node, id);
 if (schedule.state &gt; CREATED) throw new Error(&quot;too late; already scheduled&quot;);
 return schedule;
</PRE><P>}
</P><P>function set$1(node, id) {
</P><PRE> var schedule = get$1(node, id);
 if (schedule.state &gt; STARTING) throw new Error(&quot;too late; already started&quot;);
 return schedule;
</PRE><P>}
</P><P>function get$1(node, id) {
</P><PRE> var schedule = node.__transition;
 if (!schedule || !(schedule = schedule[id])) throw new Error(&quot;transition not found&quot;);
 return schedule;
</PRE><P>}
</P><P>function create$1(node, id, self) {
</P><PRE> var schedules = node.__transition,
     tween;
</PRE><PRE> // Initialize the self timer when the transition is created.
 // Note the actual delay is not known until the first callback!
 schedules[id] = self;
 self.timer = timer(schedule, 0, self.time);
</PRE><PRE> function schedule(elapsed) {
   self.state = SCHEDULED;
   self.timer.restart(start, self.delay, self.time);
</PRE><PRE>   // If the elapsed delay is less than our first sleep, start immediately.
   if (self.delay &lt;= elapsed) start(elapsed - self.delay);
 }
</PRE><PRE> function start(elapsed) {
   var i, j, n, o;
</PRE><PRE>   // If the state is not SCHEDULED, then we previously errored on start.
   if (self.state !== SCHEDULED) return stop();
</PRE><PRE>   for (i in schedules) {
     o = schedules[i];
     if (o.name !== self.name) continue;
</PRE><PRE>     // While this element already has a starting transition during this frame,
     // defer starting an interrupting transition until that transition has a
     // chance to tick (and possibly end); see d3/d3-transition#54!
     if (o.state === STARTED) return timeout$1(start);
</PRE><PRE>     // Interrupt the active transition, if any.
     // Dispatch the interrupt event.
     if (o.state === RUNNING) {
       o.state = ENDED;
       o.timer.stop();
       o.on.call(&quot;interrupt&quot;, node, node.__data__, o.index, o.group);
       delete schedules[i];
     }
</PRE><PRE>     // Cancel any pre-empted transitions. No interrupt event is dispatched
     // because the cancelled transitions never started. Note that this also
     // removes this transition from the pending list!
     else if (+i &lt; id) {
       o.state = ENDED;
       o.timer.stop();
       delete schedules[i];
     }
   }
</PRE><PRE>   // Defer the first tick to end of the current frame; see d3/d3#1576.
   // Note the transition may be canceled after start and before the first tick!
   // Note this must be scheduled before the start event; see d3/d3-transition#16!
   // Assuming this is successful, subsequent callbacks go straight to tick.
   timeout$1(function() {
     if (self.state === STARTED) {
       self.state = RUNNING;
       self.timer.restart(tick, self.delay, self.time);
       tick(elapsed);
     }
   });
</PRE><PRE>   // Dispatch the start event.
   // Note this must be done before the tween are initialized.
   self.state = STARTING;
   self.on.call(&quot;start&quot;, node, node.__data__, self.index, self.group);
   if (self.state !== STARTING) return; // interrupted
   self.state = STARTED;
</PRE><PRE>   // Initialize the tween, deleting null tween.
   tween = new Array(n = self.tween.length);
   for (i = 0, j = -1; i &lt; n; ++i) {
     if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
       tween[++j] = o;
     }
   }
   tween.length = j + 1;
 }
</PRE><PRE> function tick(elapsed) {
   var t = elapsed &lt; self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
       i = -1,
       n = tween.length;
</PRE><PRE>   while (++i &lt; n) {
     tween[i].call(null, t);
   }
</PRE><PRE>   // Dispatch the end event.
   if (self.state === ENDING) {
     self.on.call(&quot;end&quot;, node, node.__data__, self.index, self.group);
     stop();
   }
 }
</PRE><PRE> function stop() {
   self.state = ENDED;
   self.timer.stop();
   delete schedules[id];
   for (var i in schedules) return; // eslint-disable-line no-unused-vars
   delete node.__transition;
 }
</PRE><P>}
</P><P>function interrupt(node, name) {
</P><PRE> var schedules = node.__transition,
     schedule$$1,
     active,
     empty = true,
     i;
</PRE><PRE> if (!schedules) return;
</PRE><PRE> name = name == null ? null : name + &quot;&quot;;
</PRE><PRE> for (i in schedules) {
   if ((schedule$$1 = schedules[i]).name !== name) { empty = false; continue; }
   active = schedule$$1.state &gt; STARTING &amp;&amp; schedule$$1.state &lt; ENDING;
   schedule$$1.state = ENDED;
   schedule$$1.timer.stop();
   if (active) schedule$$1.on.call(&quot;interrupt&quot;, node, node.__data__, schedule$$1.index, schedule$$1.group);
   delete schedules[i];
 }
</PRE><PRE> if (empty) delete node.__transition;
</PRE><P>}
</P><P>function selection_interrupt(name) {
</P><PRE> return this.each(function() {
   interrupt(this, name);
 });
</PRE><P>}
</P><P>function tweenRemove(id, name) {
</P><PRE> var tween0, tween1;
 return function() {
   var schedule$$1 = set$1(this, id),
       tween = schedule$$1.tween;
</PRE><PRE>   // If this node shared tween with the previous node,
   // just assign the updated shared tween and we’re done!
   // Otherwise, copy-on-write.
   if (tween !== tween0) {
     tween1 = tween0 = tween;
     for (var i = 0, n = tween1.length; i &lt; n; ++i) {
       if (tween1[i].name === name) {
         tween1 = tween1.slice();
         tween1.splice(i, 1);
         break;
       }
     }
   }
</PRE><PRE>   schedule$$1.tween = tween1;
 };
</PRE><P>}
</P><P>function tweenFunction(id, name, value) {
</P><PRE> var tween0, tween1;
 if (typeof value !== &quot;function&quot;) throw new Error;
 return function() {
   var schedule$$1 = set$1(this, id),
       tween = schedule$$1.tween;
</PRE><PRE>   // If this node shared tween with the previous node,
   // just assign the updated shared tween and we’re done!
   // Otherwise, copy-on-write.
   if (tween !== tween0) {
     tween1 = (tween0 = tween).slice();
     for (var t = {name: name, value: value}, i = 0, n = tween1.length; i &lt; n; ++i) {
       if (tween1[i].name === name) {
         tween1[i] = t;
         break;
       }
     }
     if (i === n) tween1.push(t);
   }
</PRE><PRE>   schedule$$1.tween = tween1;
 };
</PRE><P>}
</P><P>function transition_tween(name, value) {
</P><PRE> var id = this._id;
</PRE><PRE> name += &quot;&quot;;
</PRE><PRE> if (arguments.length &lt; 2) {
   var tween = get$1(this.node(), id).tween;
   for (var i = 0, n = tween.length, t; i &lt; n; ++i) {
     if ((t = tween[i]).name === name) {
       return t.value;
     }
   }
   return null;
 }
</PRE><PRE> return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
</PRE><P>}
</P><P>function tweenValue(transition, name, value) {
</P><PRE> var id = transition._id;
</PRE><PRE> transition.each(function() {
   var schedule$$1 = set$1(this, id);
   (schedule$$1.value || (schedule$$1.value = {}))[name] = value.apply(this, arguments);
 });
</PRE><PRE> return function(node) {
   return get$1(node, id).value[name];
 };
</PRE><P>}
</P><P>function interpolate(a, b) {
</P><PRE> var c;
 return (typeof b === &quot;number&quot; ? interpolateNumber
     : b instanceof color ? interpolateRgb
     : (c = color(b)) ? (b = c, interpolateRgb)
     : interpolateString)(a, b);
</PRE><P>}
</P><P>function attrRemove$1(name) {
</P><PRE> return function() {
   this.removeAttribute(name);
 };
</PRE><P>}
</P><P>function attrRemoveNS$1(fullname) {
</P><PRE> return function() {
   this.removeAttributeNS(fullname.space, fullname.local);
 };
</PRE><P>}
</P><P>function attrConstant$1(name, interpolate$$1, value1) {
</P><PRE> var value00,
     interpolate0;
 return function() {
   var value0 = this.getAttribute(name);
   return value0 === value1 ? null
       : value0 === value00 ? interpolate0
       : interpolate0 = interpolate$$1(value00 = value0, value1);
 };
</PRE><P>}
</P><P>function attrConstantNS$1(fullname, interpolate$$1, value1) {
</P><PRE> var value00,
     interpolate0;
 return function() {
   var value0 = this.getAttributeNS(fullname.space, fullname.local);
   return value0 === value1 ? null
       : value0 === value00 ? interpolate0
       : interpolate0 = interpolate$$1(value00 = value0, value1);
 };
</PRE><P>}
</P><P>function attrFunction$1(name, interpolate$$1, value) {
</P><PRE> var value00,
     value10,
     interpolate0;
 return function() {
   var value0, value1 = value(this);
   if (value1 == null) return void this.removeAttribute(name);
   value0 = this.getAttribute(name);
   return value0 === value1 ? null
       : value0 === value00 &amp;&amp; value1 === value10 ? interpolate0
       : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
 };
</PRE><P>}
</P><P>function attrFunctionNS$1(fullname, interpolate$$1, value) {
</P><PRE> var value00,
     value10,
     interpolate0;
 return function() {
   var value0, value1 = value(this);
   if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
   value0 = this.getAttributeNS(fullname.space, fullname.local);
   return value0 === value1 ? null
       : value0 === value00 &amp;&amp; value1 === value10 ? interpolate0
       : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
 };
</PRE><P>}
</P><P>function transition_attr(name, value) {
</P><PRE> var fullname = namespace(name), i = fullname === &quot;transform&quot; ? interpolateTransformSvg : interpolate;
 return this.attrTween(name, typeof value === &quot;function&quot;
     ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, &quot;attr.&quot; + name, value))
     : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
     : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + &quot;&quot;));
</PRE><P>}
</P><P>function attrTweenNS(fullname, value) {
</P><PRE> function tween() {
   var node = this, i = value.apply(node, arguments);
   return i &amp;&amp; function(t) {
     node.setAttributeNS(fullname.space, fullname.local, i(t));
   };
 }
 tween._value = value;
 return tween;
</PRE><P>}
</P><P>function attrTween(name, value) {
</P><PRE> function tween() {
   var node = this, i = value.apply(node, arguments);
   return i &amp;&amp; function(t) {
     node.setAttribute(name, i(t));
   };
 }
 tween._value = value;
 return tween;
</PRE><P>}
</P><P>function transition_attrTween(name, value) {
</P><PRE> var key = &quot;attr.&quot; + name;
 if (arguments.length &lt; 2) return (key = this.tween(key)) &amp;&amp; key._value;
 if (value == null) return this.tween(key, null);
 if (typeof value !== &quot;function&quot;) throw new Error;
 var fullname = namespace(name);
 return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
</PRE><P>}
</P><P>function delayFunction(id, value) {
</P><PRE> return function() {
   init(this, id).delay = +value.apply(this, arguments);
 };
</PRE><P>}
</P><P>function delayConstant(id, value) {
</P><PRE> return value = +value, function() {
   init(this, id).delay = value;
 };
</PRE><P>}
</P><P>function transition_delay(value) {
</P><PRE> var id = this._id;
</PRE><PRE> return arguments.length
     ? this.each((typeof value === &quot;function&quot;
         ? delayFunction
         : delayConstant)(id, value))
     : get$1(this.node(), id).delay;
</PRE><P>}
</P><P>function durationFunction(id, value) {
</P><PRE> return function() {
   set$1(this, id).duration = +value.apply(this, arguments);
 };
</PRE><P>}
</P><P>function durationConstant(id, value) {
</P><PRE> return value = +value, function() {
   set$1(this, id).duration = value;
 };
</PRE><P>}
</P><P>function transition_duration(value) {
</P><PRE> var id = this._id;
</PRE><PRE> return arguments.length
     ? this.each((typeof value === &quot;function&quot;
         ? durationFunction
         : durationConstant)(id, value))
     : get$1(this.node(), id).duration;
</PRE><P>}
</P><P>function easeConstant(id, value) {
</P><PRE> if (typeof value !== &quot;function&quot;) throw new Error;
 return function() {
   set$1(this, id).ease = value;
 };
</PRE><P>}
</P><P>function transition_ease(value) {
</P><PRE> var id = this._id;
</PRE><PRE> return arguments.length
     ? this.each(easeConstant(id, value))
     : get$1(this.node(), id).ease;
</PRE><P>}
</P><P>function transition_filter(match) {
</P><PRE> if (typeof match !== &quot;function&quot;) match = matcher$1(match);
</PRE><PRE> for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j &lt; m; ++j) {
   for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i &lt; n; ++i) {
     if ((node = group[i]) &amp;&amp; match.call(node, node.__data__, i, group)) {
       subgroup.push(node);
     }
   }
 }
</PRE><PRE> return new Transition(subgroups, this._parents, this._name, this._id);
</PRE><P>}
</P><P>function transition_merge(transition$$1) {
</P><PRE> if (transition$$1._id !== this._id) throw new Error;
</PRE><PRE> for (var groups0 = this._groups, groups1 = transition$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j &lt; m; ++j) {
   for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i &lt; n; ++i) {
     if (node = group0[i] || group1[i]) {
       merge[i] = node;
     }
   }
 }
</PRE><PRE> for (; j &lt; m0; ++j) {
   merges[j] = groups0[j];
 }
</PRE><PRE> return new Transition(merges, this._parents, this._name, this._id);
</PRE><P>}
</P><P>function start(name) {
</P><PRE> return (name + &quot;&quot;).trim().split(/^|\s+/).every(function(t) {
   var i = t.indexOf(&quot;.&quot;);
   if (i &gt;= 0) t = t.slice(0, i);
   return !t || t === &quot;start&quot;;
 });
</PRE><P>}
</P><P>function onFunction(id, name, listener) {
</P><PRE> var on0, on1, sit = start(name) ? init : set$1;
 return function() {
   var schedule$$1 = sit(this, id),
       on = schedule$$1.on;
</PRE><PRE>   // If this node shared a dispatch with the previous node,
   // just assign the updated shared dispatch and we’re done!
   // Otherwise, copy-on-write.
   if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
</PRE><PRE>   schedule$$1.on = on1;
 };
</PRE><P>}
</P><P>function transition_on(name, listener) {
</P><PRE> var id = this._id;
</PRE><PRE> return arguments.length &lt; 2
     ? get$1(this.node(), id).on.on(name)
     : this.each(onFunction(id, name, listener));
</PRE><P>}
</P><P>function removeFunction(id) {
</P><PRE> return function() {
   var parent = this.parentNode;
   for (var i in this.__transition) if (+i !== id) return;
   if (parent) parent.removeChild(this);
 };
</PRE><P>}
</P><P>function transition_remove() {
</P><PRE> return this.on(&quot;end.remove&quot;, removeFunction(this._id));
</PRE><P>}
</P><P>function transition_select(select$$1) {
</P><PRE> var name = this._name,
     id = this._id;
</PRE><PRE> if (typeof select$$1 !== &quot;function&quot;) select$$1 = selector(select$$1);
</PRE><PRE> for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j &lt; m; ++j) {
   for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i &lt; n; ++i) {
     if ((node = group[i]) &amp;&amp; (subnode = select$$1.call(node, node.__data__, i, group))) {
       if (&quot;__data__&quot; in node) subnode.__data__ = node.__data__;
       subgroup[i] = subnode;
       schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
     }
   }
 }
</PRE><PRE> return new Transition(subgroups, this._parents, name, id);
</PRE><P>}
</P><P>function transition_selectAll(select$$1) {
</P><PRE> var name = this._name,
     id = this._id;
</PRE><PRE> if (typeof select$$1 !== &quot;function&quot;) select$$1 = selectorAll(select$$1);
</PRE><PRE> for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j &lt; m; ++j) {
   for (var group = groups[j], n = group.length, node, i = 0; i &lt; n; ++i) {
     if (node = group[i]) {
       for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k &lt; l; ++k) {
         if (child = children[k]) {
           schedule(child, name, id, k, children, inherit);
         }
       }
       subgroups.push(children);
       parents.push(node);
     }
   }
 }
</PRE><PRE> return new Transition(subgroups, parents, name, id);
</PRE><P>}
</P><P>var Selection$1 = selection.prototype.constructor;
</P><P>function transition_selection() {
</P><PRE> return new Selection$1(this._groups, this._parents);
</PRE><P>}
</P><P>function styleRemove$1(name, interpolate$$1) {
</P><PRE> var value00,
     value10,
     interpolate0;
 return function() {
   var value0 = styleValue(this, name),
       value1 = (this.style.removeProperty(name), styleValue(this, name));
   return value0 === value1 ? null
       : value0 === value00 &amp;&amp; value1 === value10 ? interpolate0
       : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
 };
</PRE><P>}
</P><P>function styleRemoveEnd(name) {
</P><PRE> return function() {
   this.style.removeProperty(name);
 };
</PRE><P>}
</P><P>function styleConstant$1(name, interpolate$$1, value1) {
</P><PRE> var value00,
     interpolate0;
 return function() {
   var value0 = styleValue(this, name);
   return value0 === value1 ? null
       : value0 === value00 ? interpolate0
       : interpolate0 = interpolate$$1(value00 = value0, value1);
 };
</PRE><P>}
</P><P>function styleFunction$1(name, interpolate$$1, value) {
</P><PRE> var value00,
     value10,
     interpolate0;
 return function() {
   var value0 = styleValue(this, name),
       value1 = value(this);
   if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));
   return value0 === value1 ? null
       : value0 === value00 &amp;&amp; value1 === value10 ? interpolate0
       : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
 };
</PRE><P>}
</P><P>function transition_style(name, value, priority) {
</P><PRE> var i = (name += &quot;&quot;) === &quot;transform&quot; ? interpolateTransformCss : interpolate;
 return value == null ? this
         .styleTween(name, styleRemove$1(name, i))
         .on(&quot;end.style.&quot; + name, styleRemoveEnd(name))
     : this.styleTween(name, typeof value === &quot;function&quot;
         ? styleFunction$1(name, i, tweenValue(this, &quot;style.&quot; + name, value))
         : styleConstant$1(name, i, value + &quot;&quot;), priority);
</PRE><P>}
</P><P>function styleTween(name, value, priority) {
</P><PRE> function tween() {
   var node = this, i = value.apply(node, arguments);
   return i &amp;&amp; function(t) {
     node.style.setProperty(name, i(t), priority);
   };
 }
 tween._value = value;
 return tween;
</PRE><P>}
</P><P>function transition_styleTween(name, value, priority) {
</P><PRE> var key = &quot;style.&quot; + (name += &quot;&quot;);
 if (arguments.length &lt; 2) return (key = this.tween(key)) &amp;&amp; key._value;
 if (value == null) return this.tween(key, null);
 if (typeof value !== &quot;function&quot;) throw new Error;
 return this.tween(key, styleTween(name, value, priority == null ? &quot;&quot; : priority));
</PRE><P>}
</P><P>function textConstant$1(value) {
</P><PRE> return function() {
   this.textContent = value;
 };
</PRE><P>}
</P><P>function textFunction$1(value) {
</P><PRE> return function() {
   var value1 = value(this);
   this.textContent = value1 == null ? &quot;&quot; : value1;
 };
</PRE><P>}
</P><P>function transition_text(value) {
</P><PRE> return this.tween(&quot;text&quot;, typeof value === &quot;function&quot;
     ? textFunction$1(tweenValue(this, &quot;text&quot;, value))
     : textConstant$1(value == null ? &quot;&quot; : value + &quot;&quot;));
</PRE><P>}
</P><P>function transition_transition() {
</P><PRE> var name = this._name,
     id0 = this._id,
     id1 = newId();
</PRE><PRE> for (var groups = this._groups, m = groups.length, j = 0; j &lt; m; ++j) {
   for (var group = groups[j], n = group.length, node, i = 0; i &lt; n; ++i) {
     if (node = group[i]) {
       var inherit = get$1(node, id0);
       schedule(node, name, id1, i, group, {
         time: inherit.time + inherit.delay + inherit.duration,
         delay: 0,
         duration: inherit.duration,
         ease: inherit.ease
       });
     }
   }
 }
</PRE><PRE> return new Transition(groups, this._parents, name, id1);
</PRE><P>}
</P><P>var id = 0;
</P><P>function Transition(groups, parents, name, id) {
</P><PRE> this._groups = groups;
 this._parents = parents;
 this._name = name;
 this._id = id;
</PRE><P>}
</P><P>function transition(name) {
</P><PRE> return selection().transition(name);
</PRE><P>}
</P><P>function newId() {
</P><PRE> return ++id;
</PRE><P>}
</P><P>var selection_prototype = selection.prototype;
</P><P>Transition.prototype = transition.prototype = {
</P><PRE> constructor: Transition,
 select: transition_select,
 selectAll: transition_selectAll,
 filter: transition_filter,
 merge: transition_merge,
 selection: transition_selection,
 transition: transition_transition,
 call: selection_prototype.call,
 nodes: selection_prototype.nodes,
 node: selection_prototype.node,
 size: selection_prototype.size,
 empty: selection_prototype.empty,
 each: selection_prototype.each,
 on: transition_on,
 attr: transition_attr,
 attrTween: transition_attrTween,
 style: transition_style,
 styleTween: transition_styleTween,
 text: transition_text,
 remove: transition_remove,
 tween: transition_tween,
 delay: transition_delay,
 duration: transition_duration,
 ease: transition_ease
</PRE><P>};
</P><P>function linear$1(t) {
</P><PRE> return +t;
</PRE><P>}
</P><P>function quadIn(t) {
</P><PRE> return t * t;
</PRE><P>}
</P><P>function quadOut(t) {
</P><PRE> return t * (2 - t);
</PRE><P>}
</P><P>function quadInOut(t) {
</P><PRE> return ((t *= 2) &lt;= 1 ? t * t : --t * (2 - t) + 1) / 2;
</PRE><P>}
</P><P>function cubicIn(t) {
</P><PRE> return t * t * t;
</PRE><P>}
</P><P>function cubicOut(t) {
</P><PRE> return --t * t * t + 1;
</PRE><P>}
</P><P>function cubicInOut(t) {
</P><PRE> return ((t *= 2) &lt;= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
</PRE><P>}
</P><P>var exponent = 3;
</P><P>var polyIn = (function custom(e) {
</P><PRE> e = +e;
</PRE><PRE> function polyIn(t) {
   return Math.pow(t, e);
 }
</PRE><PRE> polyIn.exponent = custom;
</PRE><PRE> return polyIn;
</PRE><P>})(exponent);
</P><P>var polyOut = (function custom(e) {
</P><PRE> e = +e;
</PRE><PRE> function polyOut(t) {
   return 1 - Math.pow(1 - t, e);
 }
</PRE><PRE> polyOut.exponent = custom;
</PRE><PRE> return polyOut;
</PRE><P>})(exponent);
</P><P>var polyInOut = (function custom(e) {
</P><PRE> e = +e;
</PRE><PRE> function polyInOut(t) {
   return ((t *= 2) &lt;= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
 }
</PRE><PRE> polyInOut.exponent = custom;
</PRE><PRE> return polyInOut;
</PRE><P>})(exponent);
</P><P>var pi = Math.PI,
</P><PRE>   halfPi = pi / 2;
</PRE><P>function sinIn(t) {
</P><PRE> return 1 - Math.cos(t * halfPi);
</PRE><P>}
</P><P>function sinOut(t) {
</P><PRE> return Math.sin(t * halfPi);
</PRE><P>}
</P><P>function sinInOut(t) {
</P><PRE> return (1 - Math.cos(pi * t)) / 2;
</PRE><P>}
</P><P>function expIn(t) {
</P><PRE> return Math.pow(2, 10 * t - 10);
</PRE><P>}
</P><P>function expOut(t) {
</P><PRE> return 1 - Math.pow(2, -10 * t);
</PRE><P>}
</P><P>function expInOut(t) {
</P><PRE> return ((t *= 2) &lt;= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
</PRE><P>}
</P><P>function circleIn(t) {
</P><PRE> return 1 - Math.sqrt(1 - t * t);
</PRE><P>}
</P><P>function circleOut(t) {
</P><PRE> return Math.sqrt(1 - --t * t);
</PRE><P>}
</P><P>function circleInOut(t) {
</P><PRE> return ((t *= 2) &lt;= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
</PRE><P>}
</P><P>var b1 = 4 / 11,
</P><PRE>   b2 = 6 / 11,
   b3 = 8 / 11,
   b4 = 3 / 4,
   b5 = 9 / 11,
   b6 = 10 / 11,
   b7 = 15 / 16,
   b8 = 21 / 22,
   b9 = 63 / 64,
   b0 = 1 / b1 / b1;
</PRE><P>function bounceIn(t) {
</P><PRE> return 1 - bounceOut(1 - t);
</PRE><P>}
</P><P>function bounceOut(t) {
</P><PRE> return (t = +t) &lt; b1 ? b0 * t * t : t &lt; b3 ? b0 * (t -= b2) * t + b4 : t &lt; b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
</PRE><P>}
</P><P>function bounceInOut(t) {
</P><PRE> return ((t *= 2) &lt;= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
</PRE><P>}
</P><P>var overshoot = 1.70158;
</P><P>var backIn = (function custom(s) {
</P><PRE> s = +s;
</PRE><PRE> function backIn(t) {
   return t * t * ((s + 1) * t - s);
 }
</PRE><PRE> backIn.overshoot = custom;
</PRE><PRE> return backIn;
</PRE><P>})(overshoot);
</P><P>var backOut = (function custom(s) {
</P><PRE> s = +s;
</PRE><PRE> function backOut(t) {
   return --t * t * ((s + 1) * t + s) + 1;
 }
</PRE><PRE> backOut.overshoot = custom;
</PRE><PRE> return backOut;
</PRE><P>})(overshoot);
</P><P>var backInOut = (function custom(s) {
</P><PRE> s = +s;
</PRE><PRE> function backInOut(t) {
   return ((t *= 2) &lt; 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
 }
</PRE><PRE> backInOut.overshoot = custom;
</PRE><PRE> return backInOut;
</PRE><P>})(overshoot);
</P><P>var tau = 2 * Math.PI,
</P><PRE>   amplitude = 1,
   period = 0.3;
</PRE><P>var elasticIn = (function custom(a, p) {
</P><PRE> var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
</PRE><PRE> function elasticIn(t) {
   return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
 }
</PRE><PRE> elasticIn.amplitude = function(a) { return custom(a, p * tau); };
 elasticIn.period = function(p) { return custom(a, p); };
</PRE><PRE> return elasticIn;
</PRE><P>})(amplitude, period);
</P><P>var elasticOut = (function custom(a, p) {
</P><PRE> var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
</PRE><PRE> function elasticOut(t) {
   return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
 }
</PRE><PRE> elasticOut.amplitude = function(a) { return custom(a, p * tau); };
 elasticOut.period = function(p) { return custom(a, p); };
</PRE><PRE> return elasticOut;
</PRE><P>})(amplitude, period);
</P><P>var elasticInOut = (function custom(a, p) {
</P><PRE> var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
</PRE><PRE> function elasticInOut(t) {
   return ((t = t * 2 - 1) &lt; 0
       ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
       : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
 }
</PRE><PRE> elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
 elasticInOut.period = function(p) { return custom(a, p); };
</PRE><PRE> return elasticInOut;
</PRE><P>})(amplitude, period);
</P><P>var defaultTiming = {
</P><PRE> time: null, // Set on use.
 delay: 0,
 duration: 250,
 ease: cubicInOut
</PRE><P>};
</P><P>function inherit(node, id) {
</P><PRE> var timing;
 while (!(timing = node.__transition) || !(timing = timing[id])) {
   if (!(node = node.parentNode)) {
     return defaultTiming.time = now(), defaultTiming;
   }
 }
 return timing;
</PRE><P>}
</P><P>function selection_transition(name) {
</P><PRE> var id,
     timing;
</PRE><PRE> if (name instanceof Transition) {
   id = name._id, name = name._name;
 } else {
   id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + &quot;&quot;;
 }
</PRE><PRE> for (var groups = this._groups, m = groups.length, j = 0; j &lt; m; ++j) {
   for (var group = groups[j], n = group.length, node, i = 0; i &lt; n; ++i) {
     if (node = group[i]) {
       schedule(node, name, id, i, group, timing || inherit(node, id));
     }
   }
 }
</PRE><PRE> return new Transition(groups, this._parents, name, id);
</PRE><P>}
</P><P>selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
</P><P>var root$1 = [null];
</P><P>function active(node, name) {
</P><PRE> var schedules = node.__transition,
     schedule$$1,
     i;
</PRE><PRE> if (schedules) {
   name = name == null ? null : name + &quot;&quot;;
   for (i in schedules) {
     if ((schedule$$1 = schedules[i]).state &gt; SCHEDULED &amp;&amp; schedule$$1.name === name) {
       return new Transition(<A href="/wiki/index.php?title=Node&amp;action=edit&amp;redlink=1" class="new" title="Node (page does not exist)">node</A>, root$1, name, +i);
     }
   }
 }
</PRE><PRE> return null;
</PRE><P>}
</P><P>function constant$4(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function BrushEvent(target, type, selection) {
</P><PRE> this.target = target;
 this.type = type;
 this.selection = selection;
</PRE><P>}
</P><P>function nopropagation$1() {
</P><PRE> exports.event.stopImmediatePropagation();
</PRE><P>}
</P><P>function noevent$1() {
</P><PRE> exports.event.preventDefault();
 exports.event.stopImmediatePropagation();
</PRE><P>}
</P><P>var MODE_DRAG = {name: &quot;drag&quot;},
</P><PRE>   MODE_SPACE = {name: &quot;space&quot;},
   MODE_HANDLE = {name: &quot;handle&quot;},
   MODE_CENTER = {name: &quot;center&quot;};
</PRE><P>var X = {
</P><PRE> name: &quot;x&quot;,
 handles: [&quot;e&quot;, &quot;w&quot;].map(type),
 input: function(x, e) { return x &amp;&amp; [[x[0], e[0][1]], [x[1], e[1][1]]]; },
 output: function(xy) { return xy &amp;&amp; [xy[0][0], xy[1][0]]; }
</PRE><P>};
</P><P>var Y = {
</P><PRE> name: &quot;y&quot;,
 handles: [&quot;n&quot;, &quot;s&quot;].map(type),
 input: function(y, e) { return y &amp;&amp; [[e[0][0], y[0]], [e[1][0], y[1]]]; },
 output: function(xy) { return xy &amp;&amp; [xy[0][1], xy[1][1]]; }
</PRE><P>};
</P><P>var XY = {
</P><PRE> name: &quot;xy&quot;,
 handles: [&quot;n&quot;, &quot;e&quot;, &quot;s&quot;, &quot;w&quot;, &quot;nw&quot;, &quot;ne&quot;, &quot;se&quot;, &quot;sw&quot;].map(type),
 input: function(xy) { return xy; },
 output: function(xy) { return xy; }
</PRE><P>};
</P><P>var cursors = {
</P><PRE> overlay: &quot;crosshair&quot;,
 selection: &quot;move&quot;,
 n: &quot;ns-resize&quot;,
 e: &quot;ew-resize&quot;,
 s: &quot;ns-resize&quot;,
 w: &quot;ew-resize&quot;,
 nw: &quot;nwse-resize&quot;,
 ne: &quot;nesw-resize&quot;,
 se: &quot;nwse-resize&quot;,
 sw: &quot;nesw-resize&quot;
</PRE><P>};
</P><P>var flipX = {
</P><PRE> e: &quot;w&quot;,
 w: &quot;e&quot;,
 nw: &quot;ne&quot;,
 ne: &quot;nw&quot;,
 se: &quot;sw&quot;,
 sw: &quot;se&quot;
</PRE><P>};
</P><P>var flipY = {
</P><PRE> n: &quot;s&quot;,
 s: &quot;n&quot;,
 nw: &quot;sw&quot;,
 ne: &quot;se&quot;,
 se: &quot;ne&quot;,
 sw: &quot;nw&quot;
</PRE><P>};
</P><P>var signsX = {
</P><PRE> overlay: +1,
 selection: +1,
 n: null,
 e: +1,
 s: null,
 w: -1,
 nw: -1,
 ne: +1,
 se: +1,
 sw: -1
</PRE><P>};
</P><P>var signsY = {
</P><PRE> overlay: +1,
 selection: +1,
 n: -1,
 e: null,
 s: +1,
 w: null,
 nw: -1,
 ne: -1,
 se: +1,
 sw: +1
</PRE><P>};
</P><P>function type(t) {
</P><PRE> return {type: t};
</PRE><P>}
</P><P>// Ignore right-click, since that should open the context menu.
function defaultFilter$1() {
</P><PRE> return !exports.event.button;
</PRE><P>}
</P><P>function defaultExtent() {
</P><PRE> var svg = this.ownerSVGElement || this;
 return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
</PRE><P>}
</P><P>// Like d3.local, but with the name “__brush” rather than auto-generated.
function local$1(node) {
</P><PRE> while (!node.__brush) if (!(node = node.parentNode)) return;
 return node.__brush;
</PRE><P>}
</P><P>function empty$1(extent) {
</P><PRE> return extent[0][0] === extent[1][0]
     || extent[0][1] === extent[1][1];
</PRE><P>}
</P><P>function brushSelection(node) {
</P><PRE> var state = node.__brush;
 return state ? state.dim.output(state.selection) : null;
</PRE><P>}
</P><P>function brushX() {
</P><PRE> return brush$1(X);
</PRE><P>}
</P><P>function brushY() {
</P><PRE> return brush$1(Y);
</PRE><P>}
</P><P>function brush() {
</P><PRE> return brush$1(XY);
</PRE><P>}
</P><P>function brush$1(dim) {
</P><PRE> var extent = defaultExtent,
     filter = defaultFilter$1,
     listeners = dispatch(brush, &quot;start&quot;, &quot;brush&quot;, &quot;end&quot;),
     handleSize = 6,
     touchending;
</PRE><PRE> function brush(group) {
   var overlay = group
       .property(&quot;__brush&quot;, initialize)
     .selectAll(&quot;.overlay&quot;)
     .data([type(&quot;overlay&quot;)]);
</PRE><PRE>   overlay.enter().append(&quot;rect&quot;)
       .attr(&quot;class&quot;, &quot;overlay&quot;)
       .attr(&quot;pointer-events&quot;, &quot;all&quot;)
       .attr(&quot;cursor&quot;, cursors.overlay)
     .merge(overlay)
       .each(function() {
         var extent = local$1(this).extent;
         select(this)
             .attr(&quot;x&quot;, extent[0][0])
             .attr(&quot;y&quot;, extent[0][1])
             .attr(&quot;width&quot;, extent[1][0] - extent[0][0])
             .attr(&quot;height&quot;, extent[1][1] - extent[0][1]);
       });
</PRE><PRE>   group.selectAll(&quot;.selection&quot;)
     .data([type(&quot;selection&quot;)])
     .enter().append(&quot;rect&quot;)
       .attr(&quot;class&quot;, &quot;selection&quot;)
       .attr(&quot;cursor&quot;, cursors.selection)
       .attr(&quot;fill&quot;, &quot;#777&quot;)
       .attr(&quot;fill-opacity&quot;, 0.3)
       .attr(&quot;stroke&quot;, &quot;#fff&quot;)
       .attr(&quot;shape-rendering&quot;, &quot;crispEdges&quot;);
</PRE><PRE>   var handle = group.selectAll(&quot;.handle&quot;)
     .data(dim.handles, function(d) { return d.type; });
</PRE><PRE>   handle.exit().remove();
</PRE><PRE>   handle.enter().append(&quot;rect&quot;)
       .attr(&quot;class&quot;, function(d) { return &quot;handle handle--&quot; + d.type; })
       .attr(&quot;cursor&quot;, function(d) { return cursors[d.type]; });
</PRE><PRE>   group
       .each(redraw)
       .attr(&quot;fill&quot;, &quot;none&quot;)
       .attr(&quot;pointer-events&quot;, &quot;all&quot;)
       .style(&quot;-webkit-tap-highlight-color&quot;, &quot;rgba(0,0,0,0)&quot;)
       .on(&quot;mousedown.brush touchstart.brush&quot;, started);
 }
</PRE><PRE> brush.move = function(group, selection$$1) {
   if (group.selection) {
     group
         .on(&quot;start.brush&quot;, function() { emitter(this, arguments).beforestart().start(); })
         .on(&quot;interrupt.brush end.brush&quot;, function() { emitter(this, arguments).end(); })
         .tween(&quot;brush&quot;, function() {
           var that = this,
               state = that.__brush,
               emit = emitter(that, arguments),
               selection0 = state.selection,
               selection1 = dim.input(typeof selection$$1 === &quot;function&quot; ? selection$$1.apply(this, arguments) : selection$$1, state.extent),
               i = interpolateValue(selection0, selection1);
</PRE><PRE>           function tween(t) {
             state.selection = t === 1 &amp;&amp; empty$1(selection1) ? null : i(t);
             redraw.call(that);
             emit.brush();
           }
</PRE><PRE>           return selection0 &amp;&amp; selection1 ? tween : tween(1);
         });
   } else {
     group
         .each(function() {
           var that = this,
               args = arguments,
               state = that.__brush,
               selection1 = dim.input(typeof selection$$1 === &quot;function&quot; ? selection$$1.apply(that, args) : selection$$1, state.extent),
               emit = emitter(that, args).beforestart();
</PRE><PRE>           interrupt(that);
           state.selection = selection1 == null || empty$1(selection1) ? null : selection1;
           redraw.call(that);
           emit.start().brush().end();
         });
   }
 };
</PRE><PRE> function redraw() {
   var group = select(this),
       selection$$1 = local$1(this).selection;
</PRE><PRE>   if (selection$$1) {
     group.selectAll(&quot;.selection&quot;)
         .style(&quot;display&quot;, null)
         .attr(&quot;x&quot;, selection$$1[0][0])
         .attr(&quot;y&quot;, selection$$1[0][1])
         .attr(&quot;width&quot;, selection$$1[1][0] - selection$$1[0][0])
         .attr(&quot;height&quot;, selection$$1[1][1] - selection$$1[0][1]);
</PRE><PRE>     group.selectAll(&quot;.handle&quot;)
         .style(&quot;display&quot;, null)
         .attr(&quot;x&quot;, function(d) { return d.type[d.type.length - 1] === &quot;e&quot; ? selection$$1[1][0] - handleSize / 2 : selection$$1[0][0] - handleSize / 2; })
         .attr(&quot;y&quot;, function(d) { return d.type[0] === &quot;s&quot; ? selection$$1[1][1] - handleSize / 2 : selection$$1[0][1] - handleSize / 2; })
         .attr(&quot;width&quot;, function(d) { return d.type === &quot;n&quot; || d.type === &quot;s&quot; ? selection$$1[1][0] - selection$$1[0][0] + handleSize : handleSize; })
         .attr(&quot;height&quot;, function(d) { return d.type === &quot;e&quot; || d.type === &quot;w&quot; ? selection$$1[1][1] - selection$$1[0][1] + handleSize : handleSize; });
   }
</PRE><PRE>   else {
     group.selectAll(&quot;.selection,.handle&quot;)
         .style(&quot;display&quot;, &quot;none&quot;)
         .attr(&quot;x&quot;, null)
         .attr(&quot;y&quot;, null)
         .attr(&quot;width&quot;, null)
         .attr(&quot;height&quot;, null);
   }
 }
</PRE><PRE> function emitter(that, args) {
   return that.__brush.emitter || new Emitter(that, args);
 }
</PRE><PRE> function Emitter(that, args) {
   this.that = that;
   this.args = args;
   this.state = that.__brush;
   this.active = 0;
 }
</PRE><PRE> Emitter.prototype = {
   beforestart: function() {
     if (++this.active === 1) this.state.emitter = this, this.starting = true;
     return this;
   },
   start: function() {
     if (this.starting) this.starting = false, this.emit(&quot;start&quot;);
     return this;
   },
   brush: function() {
     this.emit(&quot;brush&quot;);
     return this;
   },
   end: function() {
     if (--this.active === 0) delete this.state.emitter, this.emit(&quot;end&quot;);
     return this;
   },
   emit: function(type) {
     customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
   }
 };
</PRE><PRE> function started() {
   if (exports.event.touches) { if (exports.event.changedTouches.length &lt; exports.event.touches.length) return noevent$1(); }
   else if (touchending) return;
   if (!filter.apply(this, arguments)) return;
</PRE><PRE>   var that = this,
       type = exports.event.target.__data__.type,
       mode = (exports.event.metaKey ? type = &quot;overlay&quot; : type) === &quot;selection&quot; ? MODE_DRAG : (exports.event.altKey ? MODE_CENTER : MODE_HANDLE),
       signX = dim === Y ? null : signsX[type],
       signY = dim === X ? null : signsY[type],
       state = local$1(that),
       extent = state.extent,
       selection$$1 = state.selection,
       W = extent[0][0], w0, w1,
       N = extent[0][1], n0, n1,
       E = extent[1][0], e0, e1,
       S = extent[1][1], s0, s1,
       dx,
       dy,
       moving,
       shifting = signX &amp;&amp; signY &amp;&amp; exports.event.shiftKey,
       lockX,
       lockY,
       point0 = mouse(that),
       point$$1 = point0,
       emit = emitter(that, arguments).beforestart();
</PRE><PRE>   if (type === &quot;overlay&quot;) {
     state.selection = selection$$1 = [
       [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
       [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
     ];
   } else {
     w0 = selection$$1[0][0];
     n0 = selection$$1[0][1];
     e0 = selection$$1[1][0];
     s0 = selection$$1[1][1];
   }
</PRE><PRE>   w1 = w0;
   n1 = n0;
   e1 = e0;
   s1 = s0;
</PRE><PRE>   var group = select(that)
       .attr(&quot;pointer-events&quot;, &quot;none&quot;);
</PRE><PRE>   var overlay = group.selectAll(&quot;.overlay&quot;)
       .attr(&quot;cursor&quot;, cursors[type]);
</PRE><PRE>   if (exports.event.touches) {
     group
         .on(&quot;touchmove.brush&quot;, moved, true)
         .on(&quot;touchend.brush touchcancel.brush&quot;, ended, true);
   } else {
     var view = select(exports.event.view)
         .on(&quot;keydown.brush&quot;, keydowned, true)
         .on(&quot;keyup.brush&quot;, keyupped, true)
         .on(&quot;mousemove.brush&quot;, moved, true)
         .on(&quot;mouseup.brush&quot;, ended, true);
</PRE><PRE>     dragDisable(exports.event.view);
   }
</PRE><PRE>   nopropagation$1();
   interrupt(that);
   redraw.call(that);
   emit.start();
</PRE><PRE>   function moved() {
     var point1 = mouse(that);
     if (shifting &amp;&amp; !lockX &amp;&amp; !lockY) {
       if (Math.abs(point1[0] - point$$1[0]) &gt; Math.abs(point1[1] - point$$1[1])) lockY = true;
       else lockX = true;
     }
     point$$1 = point1;
     moving = true;
     noevent$1();
     move();
   }
</PRE><PRE>   function move() {
     var t;
</PRE><PRE>     dx = point$$1[0] - point0[0];
     dy = point$$1[1] - point0[1];
</PRE><PRE>     switch (mode) {
       case MODE_SPACE:
       case MODE_DRAG: {
         if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
         if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
         break;
       }
       case MODE_HANDLE: {
         if (signX &lt; 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
         else if (signX &gt; 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
         if (signY &lt; 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
         else if (signY &gt; 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
         break;
       }
       case MODE_CENTER: {
         if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
         if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
         break;
       }
     }
</PRE><PRE>     if (e1 &lt; w1) {
       signX *= -1;
       t = w0, w0 = e0, e0 = t;
       t = w1, w1 = e1, e1 = t;
       if (type in flipX) overlay.attr(&quot;cursor&quot;, cursors[type = flipX[type]]);
     }
</PRE><PRE>     if (s1 &lt; n1) {
       signY *= -1;
       t = n0, n0 = s0, s0 = t;
       t = n1, n1 = s1, s1 = t;
       if (type in flipY) overlay.attr(&quot;cursor&quot;, cursors[type = flipY[type]]);
     }
</PRE><PRE>     if (state.selection) selection$$1 = state.selection; // May be set by brush.move!
     if (lockX) w1 = selection$$1[0][0], e1 = selection$$1[1][0];
     if (lockY) n1 = selection$$1[0][1], s1 = selection$$1[1][1];
</PRE><PRE>     if (selection$$1[0][0] !== w1
         || selection$$1[0][1] !== n1
         || selection$$1[1][0] !== e1
         || selection$$1[1][1] !== s1) {
       state.selection = [[w1, n1], [e1, s1]];
       redraw.call(that);
       emit.brush();
     }
   }
</PRE><PRE>   function ended() {
     nopropagation$1();
     if (exports.event.touches) {
       if (exports.event.touches.length) return;
       if (touchending) clearTimeout(touchending);
       touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
       group.on(&quot;touchmove.brush touchend.brush touchcancel.brush&quot;, null);
     } else {
       yesdrag(exports.event.view, moving);
       view.on(&quot;keydown.brush keyup.brush mousemove.brush mouseup.brush&quot;, null);
     }
     group.attr(&quot;pointer-events&quot;, &quot;all&quot;);
     overlay.attr(&quot;cursor&quot;, cursors.overlay);
     if (state.selection) selection$$1 = state.selection; // May be set by brush.move (on start)!
     if (empty$1(selection$$1)) state.selection = null, redraw.call(that);
     emit.end();
   }
</PRE><PRE>   function keydowned() {
     switch (exports.event.keyCode) {
       case 16: { // SHIFT
         shifting = signX &amp;&amp; signY;
         break;
       }
       case 18: { // ALT
         if (mode === MODE_HANDLE) {
           if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
           if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
           mode = MODE_CENTER;
           move();
         }
         break;
       }
       case 32: { // SPACE; takes priority over ALT
         if (mode === MODE_HANDLE || mode === MODE_CENTER) {
           if (signX &lt; 0) e0 = e1 - dx; else if (signX &gt; 0) w0 = w1 - dx;
           if (signY &lt; 0) s0 = s1 - dy; else if (signY &gt; 0) n0 = n1 - dy;
           mode = MODE_SPACE;
           overlay.attr(&quot;cursor&quot;, cursors.selection);
           move();
         }
         break;
       }
       default: return;
     }
     noevent$1();
   }
</PRE><PRE>   function keyupped() {
     switch (exports.event.keyCode) {
       case 16: { // SHIFT
         if (shifting) {
           lockX = lockY = shifting = false;
           move();
         }
         break;
       }
       case 18: { // ALT
         if (mode === MODE_CENTER) {
           if (signX &lt; 0) e0 = e1; else if (signX &gt; 0) w0 = w1;
           if (signY &lt; 0) s0 = s1; else if (signY &gt; 0) n0 = n1;
           mode = MODE_HANDLE;
           move();
         }
         break;
       }
       case 32: { // SPACE
         if (mode === MODE_SPACE) {
           if (exports.event.altKey) {
             if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
             if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
             mode = MODE_CENTER;
           } else {
             if (signX &lt; 0) e0 = e1; else if (signX &gt; 0) w0 = w1;
             if (signY &lt; 0) s0 = s1; else if (signY &gt; 0) n0 = n1;
             mode = MODE_HANDLE;
           }
           overlay.attr(&quot;cursor&quot;, cursors[type]);
           move();
         }
         break;
       }
       default: return;
     }
     noevent$1();
   }
 }
</PRE><PRE> function initialize() {
   var state = this.__brush || {selection: null};
   state.extent = extent.apply(this, arguments);
   state.dim = dim;
   return state;
 }
</PRE><PRE> brush.extent = function(_) {
   return arguments.length ? (extent = typeof _ === &quot;function&quot; ? _ : constant$4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
 };
</PRE><PRE> brush.filter = function(_) {
   return arguments.length ? (filter = typeof _ === &quot;function&quot; ? _ : constant$4(!!_), brush) : filter;
 };
</PRE><PRE> brush.handleSize = function(_) {
   return arguments.length ? (handleSize = +_, brush) : handleSize;
 };
</PRE><PRE> brush.on = function() {
   var value = listeners.on.apply(listeners, arguments);
   return value === listeners ? brush : value;
 };
</PRE><PRE> return brush;
</PRE><P>}
</P><P>var cos = Math.cos;
var sin = Math.sin;
var pi$1 = Math.PI;
var halfPi$1 = pi$1 / 2;
var tau$1 = pi$1 * 2;
var max$1 = Math.max;
</P><P>function compareValue(compare) {
</P><PRE> return function(a, b) {
   return compare(
     a.source.value + a.target.value,
     b.source.value + b.target.value
   );
 };
</PRE><P>}
</P><P>function chord() {
</P><PRE> var padAngle = 0,
     sortGroups = null,
     sortSubgroups = null,
     sortChords = null;
</PRE><PRE> function chord(matrix) {
   var n = matrix.length,
       groupSums = [],
       groupIndex = sequence(n),
       subgroupIndex = [],
       chords = [],
       groups = chords.groups = new Array(n),
       subgroups = new Array(n * n),
       k,
       x,
       x0,
       dx,
       i,
       j;
</PRE><PRE>   // Compute the sum.
   k = 0, i = -1; while (++i &lt; n) {
     x = 0, j = -1; while (++j &lt; n) {
       x += matrix[i][j];
     }
     groupSums.push(x);
     subgroupIndex.push(sequence(n));
     k += x;
   }
</PRE><PRE>   // Sort groups…
   if (sortGroups) groupIndex.sort(function(a, b) {
     return sortGroups(groupSums[a], groupSums[b]);
   });
</PRE><PRE>   // Sort subgroups…
   if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
     d.sort(function(a, b) {
       return sortSubgroups(matrix[i][a], matrix[i][b]);
     });
   });
</PRE><PRE>   // Convert the sum to scaling factor for [0, 2pi].
   // TODO Allow start and end angle to be specified?
   // TODO Allow padding to be specified as percentage?
   k = max$1(0, tau$1 - padAngle * n) / k;
   dx = k ? padAngle : tau$1 / n;
</PRE><PRE>   // Compute the start and end angle for each group and subgroup.
   // Note: Opera has a bug reordering object literal properties!
   x = 0, i = -1; while (++i &lt; n) {
     x0 = x, j = -1; while (++j &lt; n) {
       var di = groupIndex[i],
           dj = subgroupIndex[di][j],
           v = matrix[di][dj],
           a0 = x,
           a1 = x += v * k;
       subgroups[dj * n + di] = {
         index: di,
         subindex: dj,
         startAngle: a0,
         endAngle: a1,
         value: v
       };
     }
     groups[di] = {
       index: di,
       startAngle: x0,
       endAngle: x,
       value: groupSums[di]
     };
     x += dx;
   }
</PRE><PRE>   // Generate chords for each (non-empty) subgroup-subgroup link.
   i = -1; while (++i &lt; n) {
     j = i - 1; while (++j &lt; n) {
       var source = subgroups[j * n + i],
           target = subgroups[i * n + j];
       if (source.value || target.value) {
         chords.push(source.value &lt; target.value
             ? {source: target, target: source}
             : {source: source, target: target});
       }
     }
   }
</PRE><PRE>   return sortChords ? chords.sort(sortChords) : chords;
 }
</PRE><PRE> chord.padAngle = function(_) {
   return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
 };
</PRE><PRE> chord.sortGroups = function(_) {
   return arguments.length ? (sortGroups = _, chord) : sortGroups;
 };
</PRE><PRE> chord.sortSubgroups = function(_) {
   return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
 };
</PRE><PRE> chord.sortChords = function(_) {
   return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords &amp;&amp; sortChords._;
 };
</PRE><PRE> return chord;
</PRE><P>}
</P><P>var slice$2 = Array.prototype.slice;
</P><P>function constant$5(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>var pi$2 = Math.PI,
</P><PRE>   tau$2 = 2 * pi$2,
   epsilon$1 = 1e-6,
   tauEpsilon = tau$2 - epsilon$1;
</PRE><P>function Path() {
</P><PRE> this._x0 = this._y0 = // start of current subpath
 this._x1 = this._y1 = null; // end of current subpath
 this._ = &quot;&quot;;
</PRE><P>}
</P><P>function path() {
</P><PRE> return new Path;
</PRE><P>}
</P><P>Path.prototype = path.prototype = {
</P><PRE> constructor: Path,
 moveTo: function(x, y) {
   this._ += &quot;M&quot; + (this._x0 = this._x1 = +x) + &quot;,&quot; + (this._y0 = this._y1 = +y);
 },
 closePath: function() {
   if (this._x1 !== null) {
     this._x1 = this._x0, this._y1 = this._y0;
     this._ += &quot;Z&quot;;
   }
 },
 lineTo: function(x, y) {
   this._ += &quot;L&quot; + (this._x1 = +x) + &quot;,&quot; + (this._y1 = +y);
 },
 quadraticCurveTo: function(x1, y1, x, y) {
   this._ += &quot;Q&quot; + (+x1) + &quot;,&quot; + (+y1) + &quot;,&quot; + (this._x1 = +x) + &quot;,&quot; + (this._y1 = +y);
 },
 bezierCurveTo: function(x1, y1, x2, y2, x, y) {
   this._ += &quot;C&quot; + (+x1) + &quot;,&quot; + (+y1) + &quot;,&quot; + (+x2) + &quot;,&quot; + (+y2) + &quot;,&quot; + (this._x1 = +x) + &quot;,&quot; + (this._y1 = +y);
 },
 arcTo: function(x1, y1, x2, y2, r) {
   x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
   var x0 = this._x1,
       y0 = this._y1,
       x21 = x2 - x1,
       y21 = y2 - y1,
       x01 = x0 - x1,
       y01 = y0 - y1,
       l01_2 = x01 * x01 + y01 * y01;
</PRE><PRE>   // Is the radius negative? Error.
   if (r &lt; 0) throw new Error(&quot;negative radius: &quot; + r);
</PRE><PRE>   // Is this path empty? Move to (x1,y1).
   if (this._x1 === null) {
     this._ += &quot;M&quot; + (this._x1 = x1) + &quot;,&quot; + (this._y1 = y1);
   }
</PRE><PRE>   // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
   else if (!(l01_2 &gt; epsilon$1));
</PRE><PRE>   // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
   // Equivalently, is (x1,y1) coincident with (x2,y2)?
   // Or, is the radius zero? Line to (x1,y1).
   else if (!(Math.abs(y01 * x21 - y21 * x01) &gt; epsilon$1) || !r) {
     this._ += &quot;L&quot; + (this._x1 = x1) + &quot;,&quot; + (this._y1 = y1);
   }
</PRE><PRE>   // Otherwise, draw an arc!
   else {
     var x20 = x2 - x0,
         y20 = y2 - y0,
         l21_2 = x21 * x21 + y21 * y21,
         l20_2 = x20 * x20 + y20 * y20,
         l21 = Math.sqrt(l21_2),
         l01 = Math.sqrt(l01_2),
         l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
         t01 = l / l01,
         t21 = l / l21;
</PRE><PRE>     // If the start tangent is not coincident with (x0,y0), line to.
     if (Math.abs(t01 - 1) &gt; epsilon$1) {
       this._ += &quot;L&quot; + (x1 + t01 * x01) + &quot;,&quot; + (y1 + t01 * y01);
     }
</PRE><PRE>     this._ += &quot;A&quot; + r + &quot;,&quot; + r + &quot;,0,0,&quot; + (+(y01 * x20 &gt; x01 * y20)) + &quot;,&quot; + (this._x1 = x1 + t21 * x21) + &quot;,&quot; + (this._y1 = y1 + t21 * y21);
   }
 },
 arc: function(x, y, r, a0, a1, ccw) {
   x = +x, y = +y, r = +r;
   var dx = r * Math.cos(a0),
       dy = r * Math.sin(a0),
       x0 = x + dx,
       y0 = y + dy,
       cw = 1 ^ ccw,
       da = ccw ? a0 - a1 : a1 - a0;
</PRE><PRE>   // Is the radius negative? Error.
   if (r &lt; 0) throw new Error(&quot;negative radius: &quot; + r);
</PRE><PRE>   // Is this path empty? Move to (x0,y0).
   if (this._x1 === null) {
     this._ += &quot;M&quot; + x0 + &quot;,&quot; + y0;
   }
</PRE><PRE>   // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
   else if (Math.abs(this._x1 - x0) &gt; epsilon$1 || Math.abs(this._y1 - y0) &gt; epsilon$1) {
     this._ += &quot;L&quot; + x0 + &quot;,&quot; + y0;
   }
</PRE><PRE>   // Is this arc empty? We’re done.
   if (!r) return;
</PRE><PRE>   // Does the angle go the wrong way? Flip the direction.
   if (da &lt; 0) da = da % tau$2 + tau$2;
</PRE><PRE>   // Is this a complete circle? Draw two arcs to complete the circle.
   if (da &gt; tauEpsilon) {
     this._ += &quot;A&quot; + r + &quot;,&quot; + r + &quot;,0,1,&quot; + cw + &quot;,&quot; + (x - dx) + &quot;,&quot; + (y - dy) + &quot;A&quot; + r + &quot;,&quot; + r + &quot;,0,1,&quot; + cw + &quot;,&quot; + (this._x1 = x0) + &quot;,&quot; + (this._y1 = y0);
   }
</PRE><PRE>   // Is this arc non-empty? Draw an arc!
   else if (da &gt; epsilon$1) {
     this._ += &quot;A&quot; + r + &quot;,&quot; + r + &quot;,0,&quot; + (+(da &gt;= pi$2)) + &quot;,&quot; + cw + &quot;,&quot; + (this._x1 = x + r * Math.cos(a1)) + &quot;,&quot; + (this._y1 = y + r * Math.sin(a1));
   }
 },
 rect: function(x, y, w, h) {
   this._ += &quot;M&quot; + (this._x0 = this._x1 = +x) + &quot;,&quot; + (this._y0 = this._y1 = +y) + &quot;h&quot; + (+w) + &quot;v&quot; + (+h) + &quot;h&quot; + (-w) + &quot;Z&quot;;
 },
 toString: function() {
   return this._;
 }
</PRE><P>};
</P><P>function defaultSource(d) {
</P><PRE> return d.source;
</PRE><P>}
</P><P>function defaultTarget(d) {
</P><PRE> return d.target;
</PRE><P>}
</P><P>function defaultRadius(d) {
</P><PRE> return d.radius;
</PRE><P>}
</P><P>function defaultStartAngle(d) {
</P><PRE> return d.startAngle;
</PRE><P>}
</P><P>function defaultEndAngle(d) {
</P><PRE> return d.endAngle;
</PRE><P>}
</P><P>function ribbon() {
</P><PRE> var source = defaultSource,
     target = defaultTarget,
     radius = defaultRadius,
     startAngle = defaultStartAngle,
     endAngle = defaultEndAngle,
     context = null;
</PRE><PRE> function ribbon() {
   var buffer,
       argv = slice$2.call(arguments),
       s = source.apply(this, argv),
       t = target.apply(this, argv),
       sr = +radius.apply(this, (argv[0] = s, argv)),
       sa0 = startAngle.apply(this, argv) - halfPi$1,
       sa1 = endAngle.apply(this, argv) - halfPi$1,
       sx0 = sr * cos(sa0),
       sy0 = sr * sin(sa0),
       tr = +radius.apply(this, (argv[0] = t, argv)),
       ta0 = startAngle.apply(this, argv) - halfPi$1,
       ta1 = endAngle.apply(this, argv) - halfPi$1;
</PRE><PRE>   if (!context) context = buffer = path();
</PRE><PRE>   context.moveTo(sx0, sy0);
   context.arc(0, 0, sr, sa0, sa1);
   if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
     context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
     context.arc(0, 0, tr, ta0, ta1);
   }
   context.quadraticCurveTo(0, 0, sx0, sy0);
   context.closePath();
</PRE><PRE>   if (buffer) return context = null, buffer + &quot;&quot; || null;
 }
</PRE><PRE> ribbon.radius = function(_) {
   return arguments.length ? (radius = typeof _ === &quot;function&quot; ? _ : constant$5(+_), ribbon) : radius;
 };
</PRE><PRE> ribbon.startAngle = function(_) {
   return arguments.length ? (startAngle = typeof _ === &quot;function&quot; ? _ : constant$5(+_), ribbon) : startAngle;
 };
</PRE><PRE> ribbon.endAngle = function(_) {
   return arguments.length ? (endAngle = typeof _ === &quot;function&quot; ? _ : constant$5(+_), ribbon) : endAngle;
 };
</PRE><PRE> ribbon.source = function(_) {
   return arguments.length ? (source = _, ribbon) : source;
 };
</PRE><PRE> ribbon.target = function(_) {
   return arguments.length ? (target = _, ribbon) : target;
 };
</PRE><PRE> ribbon.context = function(_) {
   return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
 };
</PRE><PRE> return ribbon;
</PRE><P>}
</P><P>var prefix = &quot;$&quot;;
</P><P>function Map() {}
</P><P>Map.prototype = map$1.prototype = {
</P><PRE> constructor: Map,
 has: function(key) {
   return (prefix + key) in this;
 },
 get: function(key) {
   return this[prefix + key];
 },
 set: function(key, value) {
   this[prefix + key] = value;
   return this;
 },
 remove: function(key) {
   var property = prefix + key;
   return property in this &amp;&amp; delete this[property];
 },
 clear: function() {
   for (var property in this) if (property[0] === prefix) delete this[property];
 },
 keys: function() {
   var keys = [];
   for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
   return keys;
 },
 values: function() {
   var values = [];
   for (var property in this) if (property[0] === prefix) values.push(this[property]);
   return values;
 },
 entries: function() {
   var entries = [];
   for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
   return entries;
 },
 size: function() {
   var size = 0;
   for (var property in this) if (property[0] === prefix) ++size;
   return size;
 },
 empty: function() {
   for (var property in this) if (property[0] === prefix) return false;
   return true;
 },
 each: function(f) {
   for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
 }
</PRE><P>};
</P><P>function map$1(object, f) {
</P><PRE> var map = new Map;
</PRE><PRE> // Copy constructor.
 if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });
</PRE><PRE> // Index array by numeric index or specified key function.
 else if (Array.isArray(object)) {
   var i = -1,
       n = object.length,
       o;
</PRE><PRE>   if (f == null) while (++i &lt; n) map.set(i, object[i]);
   else while (++i &lt; n) map.set(f(o = object[i], i, object), o);
 }
</PRE><PRE> // Convert object to map.
 else if (object) for (var key in object) map.set(key, object[key]);
</PRE><PRE> return map;
</PRE><P>}
</P><P>function nest() {
</P><PRE> var keys = [],
     sortKeys = [],
     sortValues,
     rollup,
     nest;
</PRE><PRE> function apply(array, depth, createResult, setResult) {
   if (depth &gt;= keys.length) {
     if (sortValues != null) array.sort(sortValues);
     return rollup != null ? rollup(array) : array;
   }
</PRE><PRE>   var i = -1,
       n = array.length,
       key = keys[depth++],
       keyValue,
       value,
       valuesByKey = map$1(),
       values,
       result = createResult();
</PRE><PRE>   while (++i &lt; n) {
     if (values = valuesByKey.get(keyValue = key(value = array[i]) + &quot;&quot;)) {
       values.push(value);
     } else {
       valuesByKey.set(keyValue, [value]);
     }
   }
</PRE><PRE>   valuesByKey.each(function(values, key) {
     setResult(result, key, apply(values, depth, createResult, setResult));
   });
</PRE><PRE>   return result;
 }
</PRE><PRE> function entries(map, depth) {
   if (++depth &gt; keys.length) return map;
   var array, sortKey = sortKeys[depth - 1];
   if (rollup != null &amp;&amp; depth &gt;= keys.length) array = map.entries();
   else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
   return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
 }
</PRE><PRE> return nest = {
   object: function(array) { return apply(array, 0, createObject, setObject); },
   map: function(array) { return apply(array, 0, createMap, setMap); },
   entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
   key: function(d) { keys.push(d); return nest; },
   sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
   sortValues: function(order) { sortValues = order; return nest; },
   rollup: function(f) { rollup = f; return nest; }
 };
</PRE><P>}
</P><P>function createObject() {
</P><PRE> return {};
</PRE><P>}
</P><P>function setObject(object, key, value) {
</P><PRE> object[key] = value;
</PRE><P>}
</P><P>function createMap() {
</P><PRE> return map$1();
</PRE><P>}
</P><P>function setMap(map, key, value) {
</P><PRE> map.set(key, value);
</PRE><P>}
</P><P>function Set() {}
</P><P>var proto = map$1.prototype;
</P><P>Set.prototype = set$2.prototype = {
</P><PRE> constructor: Set,
 has: proto.has,
 add: function(value) {
   value += &quot;&quot;;
   this[prefix + value] = value;
   return this;
 },
 remove: proto.remove,
 clear: proto.clear,
 values: proto.keys,
 size: proto.size,
 empty: proto.empty,
 each: proto.each
</PRE><P>};
</P><P>function set$2(object, f) {
</P><PRE> var set = new Set;
</PRE><PRE> // Copy constructor.
 if (object instanceof Set) object.each(function(value) { set.add(value); });
</PRE><PRE> // Otherwise, assume it’s an array.
 else if (object) {
   var i = -1, n = object.length;
   if (f == null) while (++i &lt; n) set.add(object[i]);
   else while (++i &lt; n) set.add(f(object[i], i, object));
 }
</PRE><PRE> return set;
</PRE><P>}
</P><P>function keys(map) {
</P><PRE> var keys = [];
 for (var key in map) keys.push(key);
 return keys;
</PRE><P>}
</P><P>function values(map) {
</P><PRE> var values = [];
 for (var key in map) values.push(map[key]);
 return values;
</PRE><P>}
</P><P>function entries(map) {
</P><PRE> var entries = [];
 for (var key in map) entries.push({key: key, value: map[key]});
 return entries;
</PRE><P>}
</P><P>var array$2 = Array.prototype;
</P><P>var slice$3 = array$2.slice;
</P><P>function ascending$2(a, b) {
</P><PRE> return a - b;
</PRE><P>}
</P><P>function area(ring) {
</P><PRE> var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
 while (++i &lt; n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
 return area;
</PRE><P>}
</P><P>function constant$6(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function contains(ring, hole) {
</P><PRE> var i = -1, n = hole.length, c;
 while (++i &lt; n) if (c = ringContains(ring, hole[i])) return c;
 return 0;
</PRE><P>}
</P><P>function ringContains(ring, point) {
</P><PRE> var x = point[0], y = point[1], contains = -1;
 for (var i = 0, n = ring.length, j = n - 1; i &lt; n; j = i++) {
   var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
   if (segmentContains(pi, pj, point)) return 0;
   if (((yi &gt; y) !== (yj &gt; y)) &amp;&amp; ((x &lt; (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
 }
 return contains;
</PRE><P>}
</P><P>function segmentContains(a, b, c) {
</P><PRE> var i; return collinear(a, b, c) &amp;&amp; within(a[i = +(a[0] === b[0])], c[i], b[i]);
</PRE><P>}
</P><P>function collinear(a, b, c) {
</P><PRE> return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
</PRE><P>}
</P><P>function within(p, q, r) {
</P><PRE> return p &lt;= q &amp;&amp; q &lt;= r || r &lt;= q &amp;&amp; q &lt;= p;
</PRE><P>}
</P><P>function noop$1() {}
</P><P>var cases = [
</P><PRE> [],
 [[[1.0, 1.5], [0.5, 1.0]]],
 [[[1.5, 1.0], [1.0, 1.5]]],
 [[[1.5, 1.0], [0.5, 1.0]]],
 [[[1.0, 0.5], [1.5, 1.0]]],
 [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
 [[[1.0, 0.5], [1.0, 1.5]]],
 [[[1.0, 0.5], [0.5, 1.0]]],
 [[[0.5, 1.0], [1.0, 0.5]]],
 [[[1.0, 1.5], [1.0, 0.5]]],
 [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
 [[[1.5, 1.0], [1.0, 0.5]]],
 [[[0.5, 1.0], [1.5, 1.0]]],
 [[[1.0, 1.5], [1.5, 1.0]]],
 [[[0.5, 1.0], [1.0, 1.5]]],
 []
</PRE><P>];
</P><P>function contours() {
</P><PRE> var dx = 1,
     dy = 1,
     threshold$$1 = thresholdSturges,
     smooth = smoothLinear;
</PRE><PRE> function contours(values) {
   var tz = threshold$$1(values);
</PRE><PRE>   // Convert number of thresholds into uniform thresholds.
   if (!Array.isArray(tz)) {
     var domain = extent(values), start = domain[0], stop = domain[1];
     tz = tickStep(start, stop, tz);
     tz = sequence(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
   } else {
     tz = tz.slice().sort(ascending$2);
   }
</PRE><PRE>   return tz.map(function(value) {
     return contour(values, value);
   });
 }
</PRE><PRE> // Accumulate, smooth contour rings, assign holes to exterior rings.
 // Based on <A rel="nofollow" class="external free" href="https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js">https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js</A>
 function contour(values, value) {
   var polygons = [],
       holes = [];
</PRE><PRE>   isorings(values, value, function(ring) {
     smooth(ring, values, value);
     if (area(ring) &gt; 0) polygons.push([ring]);
     else holes.push(ring);
   });
</PRE><PRE>   holes.forEach(function(hole) {
     for (var i = 0, n = polygons.length, polygon; i &lt; n; ++i) {
       if (contains((polygon = polygons[i])[0], hole) !== -1) {
         polygon.push(hole);
         return;
       }
     }
   });
</PRE><PRE>   return {
     type: &quot;MultiPolygon&quot;,
     value: value,
     coordinates: polygons
   };
 }
</PRE><PRE> // Marching squares with isolines stitched into rings.
 // Based on <A rel="nofollow" class="external free" href="https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js">https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js</A>
 function isorings(values, value, callback) {
   var fragmentByStart = new Array,
       fragmentByEnd = new Array,
       x, y, t0, t1, t2, t3;
</PRE><PRE>   // Special case for the first row (y = -1, t2 = t3 = 0).
   x = y = -1;
   t1 = values[0] &gt;= value;
   cases[t1 &lt;&lt; 1].forEach(stitch);
   while (++x &lt; dx - 1) {
     t0 = t1, t1 = values[x + 1] &gt;= value;
     cases[t0 | t1 &lt;&lt; 1].forEach(stitch);
   }
   cases[t1 &lt;&lt; 0].forEach(stitch);
</PRE><PRE>   // General case for the intermediate rows.
   while (++y &lt; dy - 1) {
     x = -1;
     t1 = values[y * dx + dx] &gt;= value;
     t2 = values[y * dx] &gt;= value;
     cases[t1 &lt;&lt; 1 | t2 &lt;&lt; 2].forEach(stitch);
     while (++x &lt; dx - 1) {
       t0 = t1, t1 = values[y * dx + dx + x + 1] &gt;= value;
       t3 = t2, t2 = values[y * dx + x + 1] &gt;= value;
       cases[t0 | t1 &lt;&lt; 1 | t2 &lt;&lt; 2 | t3 &lt;&lt; 3].forEach(stitch);
     }
     cases[t1 | t2 &lt;&lt; 3].forEach(stitch);
   }
</PRE><PRE>   // Special case for the last row (y = dy - 1, t0 = t1 = 0).
   x = -1;
   t2 = values[y * dx] &gt;= value;
   cases[t2 &lt;&lt; 2].forEach(stitch);
   while (++x &lt; dx - 1) {
     t3 = t2, t2 = values[y * dx + x + 1] &gt;= value;
     cases[t2 &lt;&lt; 2 | t3 &lt;&lt; 3].forEach(stitch);
   }
   cases[t2 &lt;&lt; 3].forEach(stitch);
</PRE><PRE>   function stitch(line) {
     var start = [line[0][0] + x, line[0][1] + y],
         end = [line[1][0] + x, line[1][1] + y],
         startIndex = index(start),
         endIndex = index(end),
         f, g;
     if (f = fragmentByEnd[startIndex]) {
       if (g = fragmentByStart[endIndex]) {
         delete fragmentByEnd[f.end];
         delete fragmentByStart[g.start];
         if (f === g) {
           f.ring.push(end);
           callback(f.ring);
         } else {
           fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
         }
       } else {
         delete fragmentByEnd[f.end];
         f.ring.push(end);
         fragmentByEnd[f.end = endIndex] = f;
       }
     } else if (f = fragmentByStart[endIndex]) {
       if (g = fragmentByEnd[startIndex]) {
         delete fragmentByStart[f.start];
         delete fragmentByEnd[g.end];
         if (f === g) {
           f.ring.push(end);
           callback(f.ring);
         } else {
           fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
         }
       } else {
         delete fragmentByStart[f.start];
         f.ring.unshift(start);
         fragmentByStart[f.start = startIndex] = f;
       }
     } else {
       fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
     }
   }
 }
</PRE><PRE> function index(point) {
   return point[0] * 2 + point[1] * (dx + 1) * 4;
 }
</PRE><PRE> function smoothLinear(ring, values, value) {
   ring.forEach(function(point) {
     var x = point[0],
         y = point[1],
         xt = x | 0,
         yt = y | 0,
         v0,
         v1 = values[yt * dx + xt];
     if (x &gt; 0 &amp;&amp; x &lt; dx &amp;&amp; xt === x) {
       v0 = values[yt * dx + xt - 1];
       point[0] = x + (value - v0) / (v1 - v0) - 0.5;
     }
     if (y &gt; 0 &amp;&amp; y &lt; dy &amp;&amp; yt === y) {
       v0 = values[(yt - 1) * dx + xt];
       point[1] = y + (value - v0) / (v1 - v0) - 0.5;
     }
   });
 }
</PRE><PRE> contours.contour = contour;
</PRE><PRE> contours.size = function(_) {
   if (!arguments.length) return [dx, dy];
   var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
   if (!(_0 &gt; 0) || !(_1 &gt; 0)) throw new Error(&quot;invalid size&quot;);
   return dx = _0, dy = _1, contours;
 };
</PRE><PRE> contours.thresholds = function(_) {
   return arguments.length ? (threshold$$1 = typeof _ === &quot;function&quot; ? _ : Array.isArray(_) ? constant$6(slice$3.call(_)) : constant$6(_), contours) : threshold$$1;
 };
</PRE><PRE> contours.smooth = function(_) {
   return arguments.length ? (smooth = _ ? smoothLinear : noop$1, contours) : smooth === smoothLinear;
 };
</PRE><PRE> return contours;
</PRE><P>}
</P><P>// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
</P><PRE> var n = source.width,
     m = source.height,
     w = (r &lt;&lt; 1) + 1;
 for (var j = 0; j &lt; m; ++j) {
   for (var i = 0, sr = 0; i &lt; n + r; ++i) {
     if (i &lt; n) {
       sr += source.data[i + j * n];
     }
     if (i &gt;= r) {
       if (i &gt;= w) {
         sr -= source.data[i - w + j * n];
       }
       target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
     }
   }
 }
</PRE><P>}
</P><P>// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
</P><PRE> var n = source.width,
     m = source.height,
     w = (r &lt;&lt; 1) + 1;
 for (var i = 0; i &lt; n; ++i) {
   for (var j = 0, sr = 0; j &lt; m + r; ++j) {
     if (j &lt; m) {
       sr += source.data[i + j * n];
     }
     if (j &gt;= r) {
       if (j &gt;= w) {
         sr -= source.data[i + (j - w) * n];
       }
       target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
     }
   }
 }
</PRE><P>}
</P><P>function defaultX(d) {
</P><PRE> return d[0];
</PRE><P>}
</P><P>function defaultY(d) {
</P><PRE> return d[1];
</PRE><P>}
</P><P>function defaultWeight() {
</P><PRE> return 1;
</PRE><P>}
</P><P>function density() {
</P><PRE> var x = defaultX,
     y = defaultY,
     weight = defaultWeight,
     dx = 960,
     dy = 500,
     r = 20, // blur radius
     k = 2, // log2(grid cell size)
     o = r * 3, // grid offset, to pad for blur
     n = (dx + o * 2) &gt;&gt; k, // grid width
     m = (dy + o * 2) &gt;&gt; k, // grid height
     threshold$$1 = constant$6(20);
</PRE><PRE> function density(data) {
   var values0 = new Float32Array(n * m),
       values1 = new Float32Array(n * m);
</PRE><PRE>   data.forEach(function(d, i, data) {
     var xi = (+x(d, i, data) + o) &gt;&gt; k,
         yi = (+y(d, i, data) + o) &gt;&gt; k,
         wi = +weight(d, i, data);
     if (xi &gt;= 0 &amp;&amp; xi &lt; n &amp;&amp; yi &gt;= 0 &amp;&amp; yi &lt; m) {
       values0[xi + yi * n] += wi;
     }
   });
</PRE><PRE>   // TODO Optimize.
   blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r &gt;&gt; k);
   blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r &gt;&gt; k);
   blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r &gt;&gt; k);
   blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r &gt;&gt; k);
   blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r &gt;&gt; k);
   blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r &gt;&gt; k);
</PRE><PRE>   var tz = threshold$$1(values0);
</PRE><PRE>   // Convert number of thresholds into uniform thresholds.
   if (!Array.isArray(tz)) {
     var stop = max(values0);
     tz = tickStep(0, stop, tz);
     tz = sequence(0, Math.floor(stop / tz) * tz, tz);
     tz.shift();
   }
</PRE><PRE>   return contours()
       .thresholds(tz)
       .size([n, m])
     (values0)
       .map(transform);
 }
</PRE><PRE> function transform(geometry) {
   geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
   geometry.coordinates.forEach(transformPolygon);
   return geometry;
 }
</PRE><PRE> function transformPolygon(coordinates) {
   coordinates.forEach(transformRing);
 }
</PRE><PRE> function transformRing(coordinates) {
   coordinates.forEach(transformPoint);
 }
</PRE><PRE> // TODO Optimize.
 function transformPoint(coordinates) {
   coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
   coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
 }
</PRE><PRE> function resize() {
   o = r * 3;
   n = (dx + o * 2) &gt;&gt; k;
   m = (dy + o * 2) &gt;&gt; k;
   return density;
 }
</PRE><PRE> density.x = function(_) {
   return arguments.length ? (x = typeof _ === &quot;function&quot; ? _ : constant$6(+_), density) : x;
 };
</PRE><PRE> density.y = function(_) {
   return arguments.length ? (y = typeof _ === &quot;function&quot; ? _ : constant$6(+_), density) : y;
 };
</PRE><PRE> density.weight = function(_) {
   return arguments.length ? (weight = typeof _ === &quot;function&quot; ? _ : constant$6(+_), density) : weight;
 };
</PRE><PRE> density.size = function(_) {
   if (!arguments.length) return [dx, dy];
   var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
   if (!(_0 &gt;= 0) &amp;&amp; !(_0 &gt;= 0)) throw new Error(&quot;invalid size&quot;);
   return dx = _0, dy = _1, resize();
 };
</PRE><PRE> density.cellSize = function(_) {
   if (!arguments.length) return 1 &lt;&lt; k;
   if (!((_ = +_) &gt;= 1)) throw new Error(&quot;invalid cell size&quot;);
   return k = Math.floor(Math.log(_) / Math.LN2), resize();
 };
</PRE><PRE> density.thresholds = function(_) {
   return arguments.length ? (threshold$$1 = typeof _ === &quot;function&quot; ? _ : Array.isArray(_) ? constant$6(slice$3.call(_)) : constant$6(_), density) : threshold$$1;
 };
</PRE><PRE> density.bandwidth = function(_) {
   if (!arguments.length) return Math.sqrt(r * (r + 1));
   if (!((_ = +_) &gt;= 0)) throw new Error(&quot;invalid bandwidth&quot;);
   return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
 };
</PRE><PRE> return density;
</PRE><P>}
</P><P>var EOL = {},
</P><PRE>   EOF = {},
   QUOTE = 34,
   NEWLINE = 10,
   RETURN = 13;
</PRE><P>function objectConverter(columns) {
</P><PRE> return new Function(&quot;d&quot;, &quot;return {&quot; + columns.map(function(name, i) {
   return JSON.stringify(name) + &quot;: d[&quot; + i + &quot;]&quot;;
 }).join(&quot;,&quot;) + &quot;}&quot;);
</PRE><P>}
</P><P>function customConverter(columns, f) {
</P><PRE> var object = objectConverter(columns);
 return function(row, i) {
   return f(object(row), i, columns);
 };
</PRE><P>}
</P><P>// Compute unique columns in order of discovery.
function inferColumns(rows) {
</P><PRE> var columnSet = Object.create(null),
     columns = [];
</PRE><PRE> rows.forEach(function(row) {
   for (var column in row) {
     if (!(column in columnSet)) {
       columns.push(columnSet[column] = column);
     }
   }
 });
</PRE><PRE> return columns;
</PRE><P>}
</P><P>function dsvFormat(delimiter) {
</P><PRE> var reFormat = new RegExp(&quot;[\&quot;&quot; + delimiter + &quot;\n\r]&quot;),
     DELIMITER = delimiter.charCodeAt(0);
</PRE><PRE> function parse(text, f) {
   var convert, columns, rows = parseRows(text, function(row, i) {
     if (convert) return convert(row, i - 1);
     columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
   });
   rows.columns = columns || [];
   return rows;
 }
</PRE><PRE> function parseRows(text, f) {
   var rows = [], // output rows
       N = text.length,
       I = 0, // current character index
       n = 0, // current line number
       t, // current token
       eof = N &lt;= 0, // current token followed by EOF?
       eol = false; // current token followed by EOL?
</PRE><PRE>   // Strip the trailing newline.
   if (text.charCodeAt(N - 1) === NEWLINE) --N;
   if (text.charCodeAt(N - 1) === RETURN) --N;
</PRE><PRE>   function token() {
     if (eof) return EOF;
     if (eol) return eol = false, EOL;
</PRE><PRE>     // Unescape quotes.
     var i, j = I, c;
     if (text.charCodeAt(j) === QUOTE) {
       while (I++ &lt; N &amp;&amp; text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
       if ((i = I) &gt;= N) eof = true;
       else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
       else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
       return text.slice(j + 1, i - 1).replace(/&quot;&quot;/g, &quot;\&quot;&quot;);
     }
</PRE><PRE>     // Find next delimiter or newline.
     while (I &lt; N) {
       if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
       else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
       else if (c !== DELIMITER) continue;
       return text.slice(j, i);
     }
</PRE><PRE>     // Return last token before EOF.
     return eof = true, text.slice(j, N);
   }
</PRE><PRE>   while ((t = token()) !== EOF) {
     var row = [];
     while (t !== EOL &amp;&amp; t !== EOF) row.push(t), t = token();
     if (f &amp;&amp; (row = f(row, n++)) == null) continue;
     rows.push(row);
   }
</PRE><PRE>   return rows;
 }
</PRE><PRE> function format(rows, columns) {
   if (columns == null) columns = inferColumns(rows);
   return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
     return columns.map(function(column) {
       return formatValue(row[column]);
     }).join(delimiter);
   })).join(&quot;\n&quot;);
 }
</PRE><PRE> function formatRows(rows) {
   return rows.map(formatRow).join(&quot;\n&quot;);
 }
</PRE><PRE> function formatRow(row) {
   return row.map(formatValue).join(delimiter);
 }
</PRE><PRE> function formatValue(text) {
   return text == null ? &quot;&quot;
       : reFormat.test(text += &quot;&quot;) ? &quot;\&quot;&quot; + text.replace(/&quot;/g, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;
       : text;
 }
</PRE><PRE> return {
   parse: parse,
   parseRows: parseRows,
   format: format,
   formatRows: formatRows
 };
</PRE><P>}
</P><P>var csv = dsvFormat(&quot;,&quot;);
</P><P>var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;
</P><P>var tsv = dsvFormat(&quot;\t&quot;);
</P><P>var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;
</P><P>function responseBlob(response) {
</P><PRE> if (!response.ok) throw new Error(response.status + &quot; &quot; + response.statusText);
 return response.blob();
</PRE><P>}
</P><P>function blob(input, init) {
</P><PRE> return fetch(input, init).then(responseBlob);
</PRE><P>}
</P><P>function responseArrayBuffer(response) {
</P><PRE> if (!response.ok) throw new Error(response.status + &quot; &quot; + response.statusText);
 return response.arrayBuffer();
</PRE><P>}
</P><P>function buffer(input, init) {
</P><PRE> return fetch(input, init).then(responseArrayBuffer);
</PRE><P>}
</P><P>function responseText(response) {
</P><PRE> if (!response.ok) throw new Error(response.status + &quot; &quot; + response.statusText);
 return response.text();
</PRE><P>}
</P><P>function text(input, init) {
</P><PRE> return fetch(input, init).then(responseText);
</PRE><P>}
</P><P>function dsvParse(parse) {
</P><PRE> return function(input, init, row) {
   if (arguments.length === 2 &amp;&amp; typeof init === &quot;function&quot;) row = init, init = undefined;
   return text(input, init).then(function(response) {
     return parse(response, row);
   });
 };
</PRE><P>}
</P><P>function dsv(delimiter, input, init, row) {
</P><PRE> if (arguments.length === 3 &amp;&amp; typeof init === &quot;function&quot;) row = init, init = undefined;
 var format = dsvFormat(delimiter);
 return text(input, init).then(function(response) {
   return format.parse(response, row);
 });
</PRE><P>}
</P><P>var csv$1 = dsvParse(csvParse);
var tsv$1 = dsvParse(tsvParse);
</P><P>function image(input, init) {
</P><PRE> return new Promise(function(resolve, reject) {
   var image = new Image;
   for (var key in init) image[key] = init[key];
   image.onerror = reject;
   image.onload = function() { resolve(image); };
   image.src = input;
 });
</PRE><P>}
</P><P>function responseJson(response) {
</P><PRE> if (!response.ok) throw new Error(response.status + &quot; &quot; + response.statusText);
 return response.json();
</PRE><P>}
</P><P>function json(input, init) {
</P><PRE> return fetch(input, init).then(responseJson);
</PRE><P>}
</P><P>function parser(type) {
</P><PRE> return function(input, init)  {
   return text(input, init).then(function(text$$1) {
     return (new DOMParser).parseFromString(text$$1, type);
   });
 };
</PRE><P>}
</P><P>var xml = parser(&quot;application/xml&quot;);
</P><P>var html = parser(&quot;text/html&quot;);
</P><P>var svg = parser(&quot;image/svg+xml&quot;);
</P><P>function center$1(x, y) {
</P><PRE> var nodes;
</PRE><PRE> if (x == null) x = 0;
 if (y == null) y = 0;
</PRE><PRE> function force() {
   var i,
       n = nodes.length,
       node,
       sx = 0,
       sy = 0;
</PRE><PRE>   for (i = 0; i &lt; n; ++i) {
     node = nodes[i], sx += node.x, sy += node.y;
   }
</PRE><PRE>   for (sx = sx / n - x, sy = sy / n - y, i = 0; i &lt; n; ++i) {
     node = nodes[i], node.x -= sx, node.y -= sy;
   }
 }
</PRE><PRE> force.initialize = function(_) {
   nodes = _;
 };
</PRE><PRE> force.x = function(_) {
   return arguments.length ? (x = +_, force) : x;
 };
</PRE><PRE> force.y = function(_) {
   return arguments.length ? (y = +_, force) : y;
 };
</PRE><PRE> return force;
</PRE><P>}
</P><P>function constant$7(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function jiggle() {
</P><PRE> return (Math.random() - 0.5) * 1e-6;
</PRE><P>}
</P><P>function tree_add(d) {
</P><PRE> var x = +this._x.call(null, d),
     y = +this._y.call(null, d);
 return add(this.cover(x, y), x, y, d);
</PRE><P>}
</P><P>function add(tree, x, y, d) {
</P><PRE> if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points
</PRE><PRE> var parent,
     node = tree._root,
     leaf = {data: d},
     x0 = tree._x0,
     y0 = tree._y0,
     x1 = tree._x1,
     y1 = tree._y1,
     xm,
     ym,
     xp,
     yp,
     right,
     bottom,
     i,
     j;
</PRE><PRE> // If the tree is empty, initialize the root as a leaf.
 if (!node) return tree._root = leaf, tree;
</PRE><PRE> // Find the existing leaf for the new point, or add it.
 while (node.length) {
   if (right = x &gt;= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
   if (bottom = y &gt;= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
   if (parent = node, !(node = node[i = bottom &lt;&lt; 1 | right])) return parent[i] = leaf, tree;
 }
</PRE><PRE> // Is the new point is exactly coincident with the existing point?
 xp = +tree._x.call(null, node.data);
 yp = +tree._y.call(null, node.data);
 if (x === xp &amp;&amp; y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
</PRE><PRE> // Otherwise, split the leaf node until the old and new point are separated.
 do {
   parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
   if (right = x &gt;= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
   if (bottom = y &gt;= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
 } while ((i = bottom &lt;&lt; 1 | right) === (j = (yp &gt;= ym) &lt;&lt; 1 | (xp &gt;= xm)));
 return parent[j] = node, parent[i] = leaf, tree;
</PRE><P>}
</P><P>function addAll(data) {
</P><PRE> var d, i, n = data.length,
     x,
     y,
     xz = new Array(n),
     yz = new Array(n),
     x0 = Infinity,
     y0 = Infinity,
     x1 = -Infinity,
     y1 = -Infinity;
</PRE><PRE> // Compute the points and their extent.
 for (i = 0; i &lt; n; ++i) {
   if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
   xz[i] = x;
   yz[i] = y;
   if (x &lt; x0) x0 = x;
   if (x &gt; x1) x1 = x;
   if (y &lt; y0) y0 = y;
   if (y &gt; y1) y1 = y;
 }
</PRE><PRE> // If there were no (valid) points, inherit the existing extent.
 if (x1 &lt; x0) x0 = this._x0, x1 = this._x1;
 if (y1 &lt; y0) y0 = this._y0, y1 = this._y1;
</PRE><PRE> // Expand the tree to cover the new points.
 this.cover(x0, y0).cover(x1, y1);
</PRE><PRE> // Add the new points.
 for (i = 0; i &lt; n; ++i) {
   add(this, xz[i], yz[i], data[i]);
 }
</PRE><PRE> return this;
</PRE><P>}
</P><P>function tree_cover(x, y) {
</P><PRE> if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points
</PRE><PRE> var x0 = this._x0,
     y0 = this._y0,
     x1 = this._x1,
     y1 = this._y1;
</PRE><PRE> // If the quadtree has no extent, initialize them.
 // Integer extent are necessary so that if we later double the extent,
 // the existing quadrant boundaries don’t change due to floating point error!
 if (isNaN(x0)) {
   x1 = (x0 = Math.floor(x)) + 1;
   y1 = (y0 = Math.floor(y)) + 1;
 }
</PRE><PRE> // Otherwise, double repeatedly to cover.
 else if (x0 &gt; x || x &gt; x1 || y0 &gt; y || y &gt; y1) {
   var z = x1 - x0,
       node = this._root,
       parent,
       i;
</PRE><PRE>   switch (i = (y &lt; (y0 + y1) / 2) &lt;&lt; 1 | (x &lt; (x0 + x1) / 2)) {
     case 0: {
       do parent = new Array(4), parent[i] = node, node = parent;
       while (z *= 2, x1 = x0 + z, y1 = y0 + z, x &gt; x1 || y &gt; y1);
       break;
     }
     case 1: {
       do parent = new Array(4), parent[i] = node, node = parent;
       while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 &gt; x || y &gt; y1);
       break;
     }
     case 2: {
       do parent = new Array(4), parent[i] = node, node = parent;
       while (z *= 2, x1 = x0 + z, y0 = y1 - z, x &gt; x1 || y0 &gt; y);
       break;
     }
     case 3: {
       do parent = new Array(4), parent[i] = node, node = parent;
       while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 &gt; x || y0 &gt; y);
       break;
     }
   }
</PRE><PRE>   if (this._root &amp;&amp; this._root.length) this._root = node;
 }
</PRE><PRE> // If the quadtree covers the point already, just return.
 else return this;
</PRE><PRE> this._x0 = x0;
 this._y0 = y0;
 this._x1 = x1;
 this._y1 = y1;
 return this;
</PRE><P>}
</P><P>function tree_data() {
</P><PRE> var data = [];
 this.visit(function(node) {
   if (!node.length) do data.push(node.data); while (node = node.next)
 });
 return data;
</PRE><P>}
</P><P>function tree_extent(_) {
</P><PRE> return arguments.length
     ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
     : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
</PRE><P>}
</P><P>function Quad(node, x0, y0, x1, y1) {
</P><PRE> this.node = node;
 this.x0 = x0;
 this.y0 = y0;
 this.x1 = x1;
 this.y1 = y1;
</PRE><P>}
</P><P>function tree_find(x, y, radius) {
</P><PRE> var data,
     x0 = this._x0,
     y0 = this._y0,
     x1,
     y1,
     x2,
     y2,
     x3 = this._x1,
     y3 = this._y1,
     quads = [],
     node = this._root,
     q,
     i;
</PRE><PRE> if (node) quads.push(new Quad(node, x0, y0, x3, y3));
 if (radius == null) radius = Infinity;
 else {
   x0 = x - radius, y0 = y - radius;
   x3 = x + radius, y3 = y + radius;
   radius *= radius;
 }
</PRE><PRE> while (q = quads.pop()) {
</PRE><PRE>   // Stop searching if this quadrant can’t contain a closer node.
   if (!(node = q.node)
       || (x1 = q.x0) &gt; x3
       || (y1 = q.y0) &gt; y3
       || (x2 = q.x1) &lt; x0
       || (y2 = q.y1) &lt; y0) continue;
</PRE><PRE>   // Bisect the current quadrant.
   if (node.length) {
     var xm = (x1 + x2) / 2,
         ym = (y1 + y2) / 2;
</PRE><PRE>     quads.push(
       new Quad(node[3], xm, ym, x2, y2),
       new Quad(node[2], x1, ym, xm, y2),
       new Quad(node[1], xm, y1, x2, ym),
       new Quad(node[0], x1, y1, xm, ym)
     );
</PRE><PRE>     // Visit the closest quadrant first.
     if (i = (y &gt;= ym) &lt;&lt; 1 | (x &gt;= xm)) {
       q = quads[quads.length - 1];
       quads[quads.length - 1] = quads[quads.length - 1 - i];
       quads[quads.length - 1 - i] = q;
     }
   }
</PRE><PRE>   // Visit this point. (Visiting coincident points isn’t necessary!)
   else {
     var dx = x - +this._x.call(null, node.data),
         dy = y - +this._y.call(null, node.data),
         d2 = dx * dx + dy * dy;
     if (d2 &lt; radius) {
       var d = Math.sqrt(radius = d2);
       x0 = x - d, y0 = y - d;
       x3 = x + d, y3 = y + d;
       data = node.data;
     }
   }
 }
</PRE><PRE> return data;
</PRE><P>}
</P><P>function tree_remove(d) {
</P><PRE> if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points
</PRE><PRE> var parent,
     node = this._root,
     retainer,
     previous,
     next,
     x0 = this._x0,
     y0 = this._y0,
     x1 = this._x1,
     y1 = this._y1,
     x,
     y,
     xm,
     ym,
     right,
     bottom,
     i,
     j;
</PRE><PRE> // If the tree is empty, initialize the root as a leaf.
 if (!node) return this;
</PRE><PRE> // Find the leaf node for the point.
 // While descending, also retain the deepest parent with a non-removed sibling.
 if (node.length) while (true) {
   if (right = x &gt;= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
   if (bottom = y &gt;= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
   if (!(parent = node, node = node[i = bottom &lt;&lt; 1 | right])) return this;
   if (!node.length) break;
   if (parent[(i + 1) &amp; 3] || parent[(i + 2) &amp; 3] || parent[(i + 3) &amp; 3]) retainer = parent, j = i;
 }
</PRE><PRE> // Find the point to remove.
 while (node.data !== d) if (!(previous = node, node = node.next)) return this;
 if (next = node.next) delete node.next;
</PRE><PRE> // If there are multiple coincident points, remove just the point.
 if (previous) return (next ? previous.next = next : delete previous.next), this;
</PRE><PRE> // If this is the root point, remove it.
 if (!parent) return this._root = next, this;
</PRE><PRE> // Remove this leaf.
 next ? parent[i] = next : delete parent[i];
</PRE><PRE> // If the parent now contains exactly one leaf, collapse superfluous parents.
 if ((node = parent[0] || parent[1] || parent[2] || parent[3])
     &amp;&amp; node === (parent[3] || parent[2] || parent[1] || parent[0])
     &amp;&amp; !node.length) {
   if (retainer) retainer[j] = node;
   else this._root = node;
 }
</PRE><PRE> return this;
</PRE><P>}
</P><P>function removeAll(data) {
</P><PRE> for (var i = 0, n = data.length; i &lt; n; ++i) this.remove(data[i]);
 return this;
</PRE><P>}
</P><P>function tree_root() {
</P><PRE> return this._root;
</PRE><P>}
</P><P>function tree_size() {
</P><PRE> var size = 0;
 this.visit(function(node) {
   if (!node.length) do ++size; while (node = node.next)
 });
 return size;
</PRE><P>}
</P><P>function tree_visit(callback) {
</P><PRE> var quads = [], q, node = this._root, child, x0, y0, x1, y1;
 if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
 while (q = quads.pop()) {
   if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) &amp;&amp; node.length) {
     var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
     if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
     if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
     if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
     if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
   }
 }
 return this;
</PRE><P>}
</P><P>function tree_visitAfter(callback) {
</P><PRE> var quads = [], next = [], q;
 if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
 while (q = quads.pop()) {
   var node = q.node;
   if (node.length) {
     var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
     if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
     if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
     if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
     if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
   }
   next.push(q);
 }
 while (q = next.pop()) {
   callback(q.node, q.x0, q.y0, q.x1, q.y1);
 }
 return this;
</PRE><P>}
</P><P>function defaultX$1(d) {
</P><PRE> return d[0];
</PRE><P>}
</P><P>function tree_x(_) {
</P><PRE> return arguments.length ? (this._x = _, this) : this._x;
</PRE><P>}
</P><P>function defaultY$1(d) {
</P><PRE> return d[1];
</PRE><P>}
</P><P>function tree_y(_) {
</P><PRE> return arguments.length ? (this._y = _, this) : this._y;
</PRE><P>}
</P><P>function quadtree(nodes, x, y) {
</P><PRE> var tree = new Quadtree(x == null ? defaultX$1 : x, y == null ? defaultY$1 : y, NaN, NaN, NaN, NaN);
 return nodes == null ? tree : tree.addAll(nodes);
</PRE><P>}
</P><P>function Quadtree(x, y, x0, y0, x1, y1) {
</P><PRE> this._x = x;
 this._y = y;
 this._x0 = x0;
 this._y0 = y0;
 this._x1 = x1;
 this._y1 = y1;
 this._root = undefined;
</PRE><P>}
</P><P>function leaf_copy(leaf) {
</P><PRE> var copy = {data: leaf.data}, next = copy;
 while (leaf = leaf.next) next = next.next = {data: leaf.data};
 return copy;
</PRE><P>}
</P><P>var treeProto = quadtree.prototype = Quadtree.prototype;
</P><P>treeProto.copy = function() {
</P><PRE> var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
     node = this._root,
     nodes,
     child;
</PRE><PRE> if (!node) return copy;
</PRE><PRE> if (!node.length) return copy._root = leaf_copy(node), copy;
</PRE><PRE> nodes = [{source: node, target: copy._root = new Array(4)}];
 while (node = nodes.pop()) {
   for (var i = 0; i &lt; 4; ++i) {
     if (child = node.source[i]) {
       if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
       else node.target[i] = leaf_copy(child);
     }
   }
 }
</PRE><PRE> return copy;
</PRE><P>};
</P><P>treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;
</P><P>function x(d) {
</P><PRE> return d.x + d.vx;
</PRE><P>}
</P><P>function y(d) {
</P><PRE> return d.y + d.vy;
</PRE><P>}
</P><P>function collide(radius) {
</P><PRE> var nodes,
     radii,
     strength = 1,
     iterations = 1;
</PRE><PRE> if (typeof radius !== &quot;function&quot;) radius = constant$7(radius == null ? 1 : +radius);
</PRE><PRE> function force() {
   var i, n = nodes.length,
       tree,
       node,
       xi,
       yi,
       ri,
       ri2;
</PRE><PRE>   for (var k = 0; k &lt; iterations; ++k) {
     tree = quadtree(nodes, x, y).visitAfter(prepare);
     for (i = 0; i &lt; n; ++i) {
       node = nodes[i];
       ri = radii[node.index], ri2 = ri * ri;
       xi = node.x + node.vx;
       yi = node.y + node.vy;
       tree.visit(apply);
     }
   }
</PRE><PRE>   function apply(quad, x0, y0, x1, y1) {
     var data = quad.data, rj = quad.r, r = ri + rj;
     if (data) {
       if (data.index &gt; node.index) {
         var x = xi - data.x - data.vx,
             y = yi - data.y - data.vy,
             l = x * x + y * y;
         if (l &lt; r * r) {
           if (x === 0) x = jiggle(), l += x * x;
           if (y === 0) y = jiggle(), l += y * y;
           l = (r - (l = Math.sqrt(l))) / l * strength;
           node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
           node.vy += (y *= l) * r;
           data.vx -= x * (r = 1 - r);
           data.vy -= y * r;
         }
       }
       return;
     }
     return x0 &gt; xi + r || x1 &lt; xi - r || y0 &gt; yi + r || y1 &lt; yi - r;
   }
 }
</PRE><PRE> function prepare(quad) {
   if (quad.data) return quad.r = radii[quad.data.index];
   for (var i = quad.r = 0; i &lt; 4; ++i) {
     if (quad[i] &amp;&amp; quad[i].r &gt; quad.r) {
       quad.r = quad[i].r;
     }
   }
 }
</PRE><PRE> function initialize() {
   if (!nodes) return;
   var i, n = nodes.length, node;
   radii = new Array(n);
   for (i = 0; i &lt; n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
 }
</PRE><PRE> force.initialize = function(_) {
   nodes = _;
   initialize();
 };
</PRE><PRE> force.iterations = function(_) {
   return arguments.length ? (iterations = +_, force) : iterations;
 };
</PRE><PRE> force.strength = function(_) {
   return arguments.length ? (strength = +_, force) : strength;
 };
</PRE><PRE> force.radius = function(_) {
   return arguments.length ? (radius = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initialize(), force) : radius;
 };
</PRE><PRE> return force;
</PRE><P>}
</P><P>function index(d) {
</P><PRE> return d.index;
</PRE><P>}
</P><P>function find(nodeById, nodeId) {
</P><PRE> var node = nodeById.get(nodeId);
 if (!node) throw new Error(&quot;missing: &quot; + nodeId);
 return node;
</PRE><P>}
</P><P>function link(links) {
</P><PRE> var id = index,
     strength = defaultStrength,
     strengths,
     distance = constant$7(30),
     distances,
     nodes,
     count,
     bias,
     iterations = 1;
</PRE><PRE> if (links == null) links = [];
</PRE><PRE> function defaultStrength(link) {
   return 1 / Math.min(count[link.source.index], count[link.target.index]);
 }
</PRE><PRE> function force(alpha) {
   for (var k = 0, n = links.length; k &lt; iterations; ++k) {
     for (var i = 0, link, source, target, x, y, l, b; i &lt; n; ++i) {
       link = links[i], source = link.source, target = link.target;
       x = target.x + target.vx - source.x - source.vx || jiggle();
       y = target.y + target.vy - source.y - source.vy || jiggle();
       l = Math.sqrt(x * x + y * y);
       l = (l - distances[i]) / l * alpha * strengths[i];
       x *= l, y *= l;
       target.vx -= x * (b = bias[i]);
       target.vy -= y * b;
       source.vx += x * (b = 1 - b);
       source.vy += y * b;
     }
   }
 }
</PRE><PRE> function initialize() {
   if (!nodes) return;
</PRE><PRE>   var i,
       n = nodes.length,
       m = links.length,
       nodeById = map$1(nodes, id),
       link;
</PRE><PRE>   for (i = 0, count = new Array(n); i &lt; m; ++i) {
     link = links[i], link.index = i;
     if (typeof link.source !== &quot;object&quot;) link.source = find(nodeById, link.source);
     if (typeof link.target !== &quot;object&quot;) link.target = find(nodeById, link.target);
     count[link.source.index] = (count[link.source.index] || 0) + 1;
     count[link.target.index] = (count[link.target.index] || 0) + 1;
   }
</PRE><PRE>   for (i = 0, bias = new Array(m); i &lt; m; ++i) {
     link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
   }
</PRE><PRE>   strengths = new Array(m), initializeStrength();
   distances = new Array(m), initializeDistance();
 }
</PRE><PRE> function initializeStrength() {
   if (!nodes) return;
</PRE><PRE>   for (var i = 0, n = links.length; i &lt; n; ++i) {
     strengths[i] = +strength(links[i], i, links);
   }
 }
</PRE><PRE> function initializeDistance() {
   if (!nodes) return;
</PRE><PRE>   for (var i = 0, n = links.length; i &lt; n; ++i) {
     distances[i] = +distance(links[i], i, links);
   }
 }
</PRE><PRE> force.initialize = function(_) {
   nodes = _;
   initialize();
 };
</PRE><PRE> force.links = function(_) {
   return arguments.length ? (links = _, initialize(), force) : links;
 };
</PRE><PRE> force.id = function(_) {
   return arguments.length ? (id = _, force) : id;
 };
</PRE><PRE> force.iterations = function(_) {
   return arguments.length ? (iterations = +_, force) : iterations;
 };
</PRE><PRE> force.strength = function(_) {
   return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initializeStrength(), force) : strength;
 };
</PRE><PRE> force.distance = function(_) {
   return arguments.length ? (distance = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initializeDistance(), force) : distance;
 };
</PRE><PRE> return force;
</PRE><P>}
</P><P>function x$1(d) {
</P><PRE> return d.x;
</PRE><P>}
</P><P>function y$1(d) {
</P><PRE> return d.y;
</PRE><P>}
</P><P>var initialRadius = 10,
</P><PRE>   initialAngle = Math.PI * (3 - Math.sqrt(5));
</PRE><P>function simulation(nodes) {
</P><PRE> var simulation,
     alpha = 1,
     alphaMin = 0.001,
     alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
     alphaTarget = 0,
     velocityDecay = 0.6,
     forces = map$1(),
     stepper = timer(step),
     event = dispatch(&quot;tick&quot;, &quot;end&quot;);
</PRE><PRE> if (nodes == null) nodes = [];
</PRE><PRE> function step() {
   tick();
   event.call(&quot;tick&quot;, simulation);
   if (alpha &lt; alphaMin) {
     stepper.stop();
     event.call(&quot;end&quot;, simulation);
   }
 }
</PRE><PRE> function tick() {
   var i, n = nodes.length, node;
</PRE><PRE>   alpha += (alphaTarget - alpha) * alphaDecay;
</PRE><PRE>   forces.each(function(force) {
     force(alpha);
   });
</PRE><PRE>   for (i = 0; i &lt; n; ++i) {
     node = nodes[i];
     if (node.fx == null) node.x += node.vx *= velocityDecay;
     else node.x = node.fx, node.vx = 0;
     if (node.fy == null) node.y += node.vy *= velocityDecay;
     else node.y = node.fy, node.vy = 0;
   }
 }
</PRE><PRE> function initializeNodes() {
   for (var i = 0, n = nodes.length, node; i &lt; n; ++i) {
     node = nodes[i], node.index = i;
     if (isNaN(node.x) || isNaN(node.y)) {
       var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
       node.x = radius * Math.cos(angle);
       node.y = radius * Math.sin(angle);
     }
     if (isNaN(node.vx) || isNaN(node.vy)) {
       node.vx = node.vy = 0;
     }
   }
 }
</PRE><PRE> function initializeForce(force) {
   if (force.initialize) force.initialize(nodes);
   return force;
 }
</PRE><PRE> initializeNodes();
</PRE><PRE> return simulation = {
   tick: tick,
</PRE><PRE>   restart: function() {
     return stepper.restart(step), simulation;
   },
</PRE><PRE>   stop: function() {
     return stepper.stop(), simulation;
   },
</PRE><PRE>   nodes: function(_) {
     return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
   },
</PRE><PRE>   alpha: function(_) {
     return arguments.length ? (alpha = +_, simulation) : alpha;
   },
</PRE><PRE>   alphaMin: function(_) {
     return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
   },
</PRE><PRE>   alphaDecay: function(_) {
     return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
   },
</PRE><PRE>   alphaTarget: function(_) {
     return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
   },
</PRE><PRE>   velocityDecay: function(_) {
     return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
   },
</PRE><PRE>   force: function(name, _) {
     return arguments.length &gt; 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
   },
</PRE><PRE>   find: function(x, y, radius) {
     var i = 0,
         n = nodes.length,
         dx,
         dy,
         d2,
         node,
         closest;
</PRE><PRE>     if (radius == null) radius = Infinity;
     else radius *= radius;
</PRE><PRE>     for (i = 0; i &lt; n; ++i) {
       node = nodes[i];
       dx = x - node.x;
       dy = y - node.y;
       d2 = dx * dx + dy * dy;
       if (d2 &lt; radius) closest = node, radius = d2;
     }
</PRE><PRE>     return closest;
   },
</PRE><PRE>   on: function(name, _) {
     return arguments.length &gt; 1 ? (event.on(name, _), simulation) : event.on(name);
   }
 };
</PRE><P>}
</P><P>function manyBody() {
</P><PRE> var nodes,
     node,
     alpha,
     strength = constant$7(-30),
     strengths,
     distanceMin2 = 1,
     distanceMax2 = Infinity,
     theta2 = 0.81;
</PRE><PRE> function force(_) {
   var i, n = nodes.length, tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate);
   for (alpha = _, i = 0; i &lt; n; ++i) node = nodes[i], tree.visit(apply);
 }
</PRE><PRE> function initialize() {
   if (!nodes) return;
   var i, n = nodes.length, node;
   strengths = new Array(n);
   for (i = 0; i &lt; n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
 }
</PRE><PRE> function accumulate(quad) {
   var strength = 0, q, c, weight = 0, x, y, i;
</PRE><PRE>   // For internal nodes, accumulate forces from child quadrants.
   if (quad.length) {
     for (x = y = i = 0; i &lt; 4; ++i) {
       if ((q = quad[i]) &amp;&amp; (c = Math.abs(q.value))) {
         strength += q.value, weight += c, x += c * q.x, y += c * q.y;
       }
     }
     quad.x = x / weight;
     quad.y = y / weight;
   }
</PRE><PRE>   // For leaf nodes, accumulate forces from coincident quadrants.
   else {
     q = quad;
     q.x = q.data.x;
     q.y = q.data.y;
     do strength += strengths[q.data.index];
     while (q = q.next);
   }
</PRE><PRE>   quad.value = strength;
 }
</PRE><PRE> function apply(quad, x1, _, x2) {
   if (!quad.value) return true;
</PRE><PRE>   var x = quad.x - node.x,
       y = quad.y - node.y,
       w = x2 - x1,
       l = x * x + y * y;
</PRE><PRE>   // Apply the Barnes-Hut approximation if possible.
   // Limit forces for very close nodes; randomize direction if coincident.
   if (w * w / theta2 &lt; l) {
     if (l &lt; distanceMax2) {
       if (x === 0) x = jiggle(), l += x * x;
       if (y === 0) y = jiggle(), l += y * y;
       if (l &lt; distanceMin2) l = Math.sqrt(distanceMin2 * l);
       node.vx += x * quad.value * alpha / l;
       node.vy += y * quad.value * alpha / l;
     }
     return true;
   }
</PRE><PRE>   // Otherwise, process points directly.
   else if (quad.length || l &gt;= distanceMax2) return;
</PRE><PRE>   // Limit forces for very close nodes; randomize direction if coincident.
   if (quad.data !== node || quad.next) {
     if (x === 0) x = jiggle(), l += x * x;
     if (y === 0) y = jiggle(), l += y * y;
     if (l &lt; distanceMin2) l = Math.sqrt(distanceMin2 * l);
   }
</PRE><PRE>   do if (quad.data !== node) {
     w = strengths[quad.data.index] * alpha / l;
     node.vx += x * w;
     node.vy += y * w;
   } while (quad = quad.next);
 }
</PRE><PRE> force.initialize = function(_) {
   nodes = _;
   initialize();
 };
</PRE><PRE> force.strength = function(_) {
   return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initialize(), force) : strength;
 };
</PRE><PRE> force.distanceMin = function(_) {
   return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
 };
</PRE><PRE> force.distanceMax = function(_) {
   return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
 };
</PRE><PRE> force.theta = function(_) {
   return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
 };
</PRE><PRE> return force;
</PRE><P>}
</P><P>function radial(radius, x, y) {
</P><PRE> var nodes,
     strength = constant$7(0.1),
     strengths,
     radiuses;
</PRE><PRE> if (typeof radius !== &quot;function&quot;) radius = constant$7(+radius);
 if (x == null) x = 0;
 if (y == null) y = 0;
</PRE><PRE> function force(alpha) {
   for (var i = 0, n = nodes.length; i &lt; n; ++i) {
     var node = nodes[i],
         dx = node.x - x || 1e-6,
         dy = node.y - y || 1e-6,
         r = Math.sqrt(dx * dx + dy * dy),
         k = (radiuses[i] - r) * strengths[i] * alpha / r;
     node.vx += dx * k;
     node.vy += dy * k;
   }
 }
</PRE><PRE> function initialize() {
   if (!nodes) return;
   var i, n = nodes.length;
   strengths = new Array(n);
   radiuses = new Array(n);
   for (i = 0; i &lt; n; ++i) {
     radiuses[i] = +radius(nodes[i], i, nodes);
     strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
   }
 }
</PRE><PRE> force.initialize = function(_) {
   nodes = _, initialize();
 };
</PRE><PRE> force.strength = function(_) {
   return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initialize(), force) : strength;
 };
</PRE><PRE> force.radius = function(_) {
   return arguments.length ? (radius = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initialize(), force) : radius;
 };
</PRE><PRE> force.x = function(_) {
   return arguments.length ? (x = +_, force) : x;
 };
</PRE><PRE> force.y = function(_) {
   return arguments.length ? (y = +_, force) : y;
 };
</PRE><PRE> return force;
</PRE><P>}
</P><P>function x$2(x) {
</P><PRE> var strength = constant$7(0.1),
     nodes,
     strengths,
     xz;
</PRE><PRE> if (typeof x !== &quot;function&quot;) x = constant$7(x == null ? 0 : +x);
</PRE><PRE> function force(alpha) {
   for (var i = 0, n = nodes.length, node; i &lt; n; ++i) {
     node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
   }
 }
</PRE><PRE> function initialize() {
   if (!nodes) return;
   var i, n = nodes.length;
   strengths = new Array(n);
   xz = new Array(n);
   for (i = 0; i &lt; n; ++i) {
     strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
   }
 }
</PRE><PRE> force.initialize = function(_) {
   nodes = _;
   initialize();
 };
</PRE><PRE> force.strength = function(_) {
   return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initialize(), force) : strength;
 };
</PRE><PRE> force.x = function(_) {
   return arguments.length ? (x = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initialize(), force) : x;
 };
</PRE><PRE> return force;
</PRE><P>}
</P><P>function y$2(y) {
</P><PRE> var strength = constant$7(0.1),
     nodes,
     strengths,
     yz;
</PRE><PRE> if (typeof y !== &quot;function&quot;) y = constant$7(y == null ? 0 : +y);
</PRE><PRE> function force(alpha) {
   for (var i = 0, n = nodes.length, node; i &lt; n; ++i) {
     node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
   }
 }
</PRE><PRE> function initialize() {
   if (!nodes) return;
   var i, n = nodes.length;
   strengths = new Array(n);
   yz = new Array(n);
   for (i = 0; i &lt; n; ++i) {
     strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
   }
 }
</PRE><PRE> force.initialize = function(_) {
   nodes = _;
   initialize();
 };
</PRE><PRE> force.strength = function(_) {
   return arguments.length ? (strength = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initialize(), force) : strength;
 };
</PRE><PRE> force.y = function(_) {
   return arguments.length ? (y = typeof _ === &quot;function&quot; ? _ : constant$7(+_), initialize(), force) : y;
 };
</PRE><PRE> return force;
</PRE><P>}
</P><P>// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns [&quot;123&quot;, 0].
function formatDecimal(x, p) {
</P><PRE> if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(&quot;e&quot;)) &lt; 0) return null; // NaN, ±Infinity
 var i, coefficient = x.slice(0, i);
</PRE><PRE> // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
 // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
 return [
   coefficient.length &gt; 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
   +x.slice(i + 1)
 ];
</PRE><P>}
</P><P>function exponent$1(x) {
</P><PRE> return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
</PRE><P>}
</P><P>function formatGroup(grouping, thousands) {
</P><PRE> return function(value, width) {
   var i = value.length,
       t = [],
       j = 0,
       g = grouping[0],
       length = 0;
</PRE><PRE>   while (i &gt; 0 &amp;&amp; g &gt; 0) {
     if (length + g + 1 &gt; width) g = Math.max(1, width - length);
     t.push(value.substring(i -= g, i + g));
     if ((length += g + 1) &gt; width) break;
     g = grouping[j = (j + 1) % grouping.length];
   }
</PRE><PRE>   return t.reverse().join(thousands);
 };
</PRE><P>}
</P><P>function formatNumerals(numerals) {
</P><PRE> return function(value) {
   return value.replace(/[0-9]/g, function(i) {
     return numerals[+i];
   });
 };
</PRE><P>}
</P><P>// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([&lt;&gt;=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
</P><P>function formatSpecifier(specifier) {
</P><PRE> return new FormatSpecifier(specifier);
</PRE><P>}
</P><P>formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof
</P><P>function FormatSpecifier(specifier) {
</P><PRE> if (!(match = re.exec(specifier))) throw new Error(&quot;invalid format: &quot; + specifier);
 var match;
 this.fill = match[1] || &quot; &quot;;
 this.align = match[2] || &quot;&gt;&quot;;
 this.sign = match[3] || &quot;-&quot;;
 this.symbol = match[4] || &quot;&quot;;
 this.zero = !!match[5];
 this.width = match[6] &amp;&amp; +match[6];
 this.comma = !!match[7];
 this.precision = match[8] &amp;&amp; +match[8].slice(1);
 this.trim = !!match[9];
 this.type = match[10] || &quot;&quot;;
</PRE><P>}
</P><P>FormatSpecifier.prototype.toString = function() {
</P><PRE> return this.fill
     + this.align
     + this.sign
     + this.symbol
     + (this.zero ? &quot;0&quot; : &quot;&quot;)
     + (this.width == null ? &quot;&quot; : Math.max(1, this.width | 0))
     + (this.comma ? &quot;,&quot; : &quot;&quot;)
     + (this.precision == null ? &quot;&quot; : &quot;.&quot; + Math.max(0, this.precision | 0))
     + (this.trim ? &quot;~&quot; : &quot;&quot;)
     + this.type;
</PRE><P>};
</P><P>// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
</P><PRE> out: for (var n = s.length, i = 1, i0 = -1, i1; i &lt; n; ++i) {
   switch (s[i]) {
     case &quot;.&quot;: i0 = i1 = i; break;
     case &quot;0&quot;: if (i0 === 0) i0 = i; i1 = i; break;
     default: if (i0 &gt; 0) { if (!+s[i]) break out; i0 = 0; } break;
   }
 }
 return i0 &gt; 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
</PRE><P>}
</P><P>var prefixExponent;
</P><P>function formatPrefixAuto(x, p) {
</P><PRE> var d = formatDecimal(x, p);
 if (!d) return x + &quot;&quot;;
 var coefficient = d[0],
     exponent = d[1],
     i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
     n = coefficient.length;
 return i === n ? coefficient
     : i &gt; n ? coefficient + new Array(i - n + 1).join(&quot;0&quot;)
     : i &gt; 0 ? coefficient.slice(0, i) + &quot;.&quot; + coefficient.slice(i)
     : &quot;0.&quot; + new Array(1 - i).join(&quot;0&quot;) + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
</PRE><P>}
</P><P>function formatRounded(x, p) {
</P><PRE> var d = formatDecimal(x, p);
 if (!d) return x + &quot;&quot;;
 var coefficient = d[0],
     exponent = d[1];
 return exponent &lt; 0 ? &quot;0.&quot; + new Array(-exponent).join(&quot;0&quot;) + coefficient
     : coefficient.length &gt; exponent + 1 ? coefficient.slice(0, exponent + 1) + &quot;.&quot; + coefficient.slice(exponent + 1)
     : coefficient + new Array(exponent - coefficient.length + 2).join(&quot;0&quot;);
</PRE><P>}
</P><P>var formatTypes = {
</P><PRE> &quot;%&quot;: function(x, p) { return (x * 100).toFixed(p); },
 &quot;b&quot;: function(x) { return Math.round(x).toString(2); },
 &quot;c&quot;: function(x) { return x + &quot;&quot;; },
 &quot;d&quot;: function(x) { return Math.round(x).toString(10); },
 &quot;e&quot;: function(x, p) { return x.toExponential(p); },
 &quot;f&quot;: function(x, p) { return x.toFixed(p); },
 &quot;g&quot;: function(x, p) { return x.toPrecision(p); },
 &quot;o&quot;: function(x) { return Math.round(x).toString(8); },
 &quot;p&quot;: function(x, p) { return formatRounded(x * 100, p); },
 &quot;r&quot;: formatRounded,
 &quot;s&quot;: formatPrefixAuto,
 &quot;X&quot;: function(x) { return Math.round(x).toString(16).toUpperCase(); },
 &quot;x&quot;: function(x) { return Math.round(x).toString(16); }
</PRE><P>};
</P><P>function identity$3(x) {
</P><PRE> return x;
</PRE><P>}
</P><P>var prefixes = [&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;\xB5&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];
</P><P>function formatLocale(locale) {
</P><PRE> var group = locale.grouping &amp;&amp; locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,
     currency = locale.currency,
     decimal = locale.decimal,
     numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3,
     percent = locale.percent || &quot;%&quot;;
</PRE><PRE> function newFormat(specifier) {
   specifier = formatSpecifier(specifier);
</PRE><PRE>   var fill = specifier.fill,
       align = specifier.align,
       sign = specifier.sign,
       symbol = specifier.symbol,
       zero = specifier.zero,
       width = specifier.width,
       comma = specifier.comma,
       precision = specifier.precision,
       trim = specifier.trim,
       type = specifier.type;
</PRE><PRE>   // The &quot;n&quot; type is an alias for &quot;,g&quot;.
   if (type === &quot;n&quot;) comma = true, type = &quot;g&quot;;
</PRE><PRE>   // The &quot;&quot; type, and any invalid type, is an alias for &quot;.12~g&quot;.
   else if (!formatTypes[type]) precision == null &amp;&amp; (precision = 12), trim = true, type = &quot;g&quot;;
</PRE><PRE>   // If zero fill is specified, padding goes after sign and before digits.
   if (zero || (fill === &quot;0&quot; &amp;&amp; align === &quot;=&quot;)) zero = true, fill = &quot;0&quot;, align = &quot;=&quot;;
</PRE><PRE>   // Compute the prefix and suffix.
   // For SI-prefix, the suffix is lazily computed.
   var prefix = symbol === &quot;$&quot; ? currency[0] : symbol === &quot;#&quot; &amp;&amp; /[boxX]/.test(type) ? &quot;0&quot; + type.toLowerCase() : &quot;&quot;,
       suffix = symbol === &quot;$&quot; ? currency[1] : /[%p]/.test(type) ? percent : &quot;&quot;;
</PRE><PRE>   // What format function should we use?
   // Is this an integer type?
   // Can this type generate exponential notation?
   var formatType = formatTypes[type],
       maybeSuffix = /[defgprs%]/.test(type);
</PRE><PRE>   // Set the default precision if not specified,
   // or clamp the specified precision to the supported range.
   // For significant precision, it must be in [1, 21].
   // For fixed precision, it must be in [0, 20].
   precision = precision == null ? 6
       : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
       : Math.max(0, Math.min(20, precision));
</PRE><PRE>   function format(value) {
     var valuePrefix = prefix,
         valueSuffix = suffix,
         i, n, c;
</PRE><PRE>     if (type === &quot;c&quot;) {
       valueSuffix = formatType(value) + valueSuffix;
       value = &quot;&quot;;
     } else {
       value = +value;
</PRE><PRE>       // Perform the initial formatting.
       var valueNegative = value &lt; 0;
       value = formatType(Math.abs(value), precision);
</PRE><PRE>       // Trim insignificant zeros.
       if (trim) value = formatTrim(value);
</PRE><PRE>       // If a negative value rounds to zero during formatting, treat as positive.
       if (valueNegative &amp;&amp; +value === 0) valueNegative = false;
</PRE><PRE>       // Compute the prefix and suffix.
       valuePrefix = (valueNegative ? (sign === &quot;(&quot; ? sign : &quot;-&quot;) : sign === &quot;-&quot; || sign === &quot;(&quot; ? &quot;&quot; : sign) + valuePrefix;
       valueSuffix = (type === &quot;s&quot; ? prefixes[8 + prefixExponent / 3] : &quot;&quot;) + valueSuffix + (valueNegative &amp;&amp; sign === &quot;(&quot; ? &quot;)&quot; : &quot;&quot;);
</PRE><PRE>       // Break the formatted value into the integer “value” part that can be
       // grouped, and fractional or exponential “suffix” part that is not.
       if (maybeSuffix) {
         i = -1, n = value.length;
         while (++i &lt; n) {
           if (c = value.charCodeAt(i), 48 &gt; c || c &gt; 57) {
             valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
             value = value.slice(0, i);
             break;
           }
         }
       }
     }
</PRE><PRE>     // If the fill character is not &quot;0&quot;, grouping is applied before padding.
     if (comma &amp;&amp; !zero) value = group(value, Infinity);
</PRE><PRE>     // Compute the padding.
     var length = valuePrefix.length + value.length + valueSuffix.length,
         padding = length &lt; width ? new Array(width - length + 1).join(fill) : &quot;&quot;;
</PRE><PRE>     // If the fill character is &quot;0&quot;, grouping is applied after padding.
     if (comma &amp;&amp; zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = &quot;&quot;;
</PRE><PRE>     // Reconstruct the final output based on the desired alignment.
     switch (align) {
       case &quot;&lt;&quot;: value = valuePrefix + value + valueSuffix + padding; break;
       case &quot;=&quot;: value = valuePrefix + padding + value + valueSuffix; break;
       case &quot;^&quot;: value = padding.slice(0, length = padding.length &gt;&gt; 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
       default: value = padding + valuePrefix + value + valueSuffix; break;
     }
</PRE><PRE>     return numerals(value);
   }
</PRE><PRE>   format.toString = function() {
     return specifier + &quot;&quot;;
   };
</PRE><PRE>   return format;
 }
</PRE><PRE> function formatPrefix(specifier, value) {
   var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = &quot;f&quot;, specifier)),
       e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
       k = Math.pow(10, -e),
       prefix = prefixes[8 + e / 3];
   return function(value) {
     return f(k * value) + prefix;
   };
 }
</PRE><PRE> return {
   format: newFormat,
   formatPrefix: formatPrefix
 };
</PRE><P>}
</P><P>var locale;
</P><P>defaultLocale({
</P><PRE> decimal: &quot;.&quot;,
 thousands: &quot;,&quot;,
 grouping: [3],
 currency: [&quot;$&quot;, &quot;&quot;]
</PRE><P>});
</P><P>function defaultLocale(definition) {
</P><PRE> locale = formatLocale(definition);
 exports.format = locale.format;
 exports.formatPrefix = locale.formatPrefix;
 return locale;
</PRE><P>}
</P><P>function precisionFixed(step) {
</P><PRE> return Math.max(0, -exponent$1(Math.abs(step)));
</PRE><P>}
</P><P>function precisionPrefix(step, value) {
</P><PRE> return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
</PRE><P>}
</P><P>function precisionRound(step, max) {
</P><PRE> step = Math.abs(step), max = Math.abs(max) - step;
 return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
</PRE><P>}
</P><P>// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete &amp; Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// <A rel="nofollow" class="external free" href="http://geographiclib.sourceforge.net/">http://geographiclib.sourceforge.net/</A></P><P>function adder() {
</P><PRE> return new Adder;
</PRE><P>}
</P><P>function Adder() {
</P><PRE> this.reset();
</PRE><P>}
</P><P>Adder.prototype = {
</P><PRE> constructor: Adder,
 reset: function() {
   this.s = // rounded value
   this.t = 0; // exact error
 },
 add: function(y) {
   add$1(temp, y, this.t);
   add$1(this, temp.s, this.s);
   if (this.s) this.t += temp.t;
   else this.s = temp.t;
 },
 valueOf: function() {
   return this.s;
 }
</PRE><P>};
</P><P>var temp = new Adder;
</P><P>function add$1(adder, a, b) {
</P><PRE> var x = adder.s = a + b,
     bv = x - a,
     av = x - bv;
 adder.t = (a - av) + (b - bv);
</PRE><P>}
</P><P>var epsilon$2 = 1e-6;
var epsilon2$1 = 1e-12;
var pi$3 = Math.PI;
var halfPi$2 = pi$3 / 2;
var quarterPi = pi$3 / 4;
var tau$3 = pi$3 * 2;
</P><P>var degrees$1 = 180 / pi$3;
var radians = pi$3 / 180;
</P><P>var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos$1 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var log = Math.log;
var pow = Math.pow;
var sin$1 = Math.sin;
var sign = Math.sign || function(x) { return x &gt; 0 ? 1 : x &lt; 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;
</P><P>function acos(x) {
</P><PRE> return x &gt; 1 ? 0 : x &lt; -1 ? pi$3 : Math.acos(x);
</PRE><P>}
</P><P>function asin(x) {
</P><PRE> return x &gt; 1 ? halfPi$2 : x &lt; -1 ? -halfPi$2 : Math.asin(x);
</PRE><P>}
</P><P>function haversin(x) {
</P><PRE> return (x = sin$1(x / 2)) * x;
</PRE><P>}
</P><P>function noop$2() {}
</P><P>function streamGeometry(geometry, stream) {
</P><PRE> if (geometry &amp;&amp; streamGeometryType.hasOwnProperty(geometry.type)) {
   streamGeometryType[geometry.type](geometry, stream);
 }
</PRE><P>}
</P><P>var streamObjectType = {
</P><PRE> Feature: function(object, stream) {
   streamGeometry(object.geometry, stream);
 },
 FeatureCollection: function(object, stream) {
   var features = object.features, i = -1, n = features.length;
   while (++i &lt; n) streamGeometry(features[i].geometry, stream);
 }
</PRE><P>};
</P><P>var streamGeometryType = {
</P><PRE> Sphere: function(object, stream) {
   stream.sphere();
 },
 Point: function(object, stream) {
   object = object.coordinates;
   stream.point(object[0], object[1], object[2]);
 },
 MultiPoint: function(object, stream) {
   var coordinates = object.coordinates, i = -1, n = coordinates.length;
   while (++i &lt; n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
 },
 LineString: function(object, stream) {
   streamLine(object.coordinates, stream, 0);
 },
 MultiLineString: function(object, stream) {
   var coordinates = object.coordinates, i = -1, n = coordinates.length;
   while (++i &lt; n) streamLine(coordinates[i], stream, 0);
 },
 Polygon: function(object, stream) {
   streamPolygon(object.coordinates, stream);
 },
 MultiPolygon: function(object, stream) {
   var coordinates = object.coordinates, i = -1, n = coordinates.length;
   while (++i &lt; n) streamPolygon(coordinates[i], stream);
 },
 GeometryCollection: function(object, stream) {
   var geometries = object.geometries, i = -1, n = geometries.length;
   while (++i &lt; n) streamGeometry(geometries[i], stream);
 }
</PRE><P>};
</P><P>function streamLine(coordinates, stream, closed) {
</P><PRE> var i = -1, n = coordinates.length - closed, coordinate;
 stream.lineStart();
 while (++i &lt; n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
 stream.lineEnd();
</PRE><P>}
</P><P>function streamPolygon(coordinates, stream) {
</P><PRE> var i = -1, n = coordinates.length;
 stream.polygonStart();
 while (++i &lt; n) streamLine(coordinates[i], stream, 1);
 stream.polygonEnd();
</PRE><P>}
</P><P>function geoStream(object, stream) {
</P><PRE> if (object &amp;&amp; streamObjectType.hasOwnProperty(object.type)) {
   streamObjectType[object.type](object, stream);
 } else {
   streamGeometry(object, stream);
 }
</PRE><P>}
</P><P>var areaRingSum = adder();
</P><P>var areaSum = adder(),
</P><PRE>   lambda00,
   phi00,
   lambda0,
   cosPhi0,
   sinPhi0;
</PRE><P>var areaStream = {
</P><PRE> point: noop$2,
 lineStart: noop$2,
 lineEnd: noop$2,
 polygonStart: function() {
   areaRingSum.reset();
   areaStream.lineStart = areaRingStart;
   areaStream.lineEnd = areaRingEnd;
 },
 polygonEnd: function() {
   var areaRing = +areaRingSum;
   areaSum.add(areaRing &lt; 0 ? tau$3 + areaRing : areaRing);
   this.lineStart = this.lineEnd = this.point = noop$2;
 },
 sphere: function() {
   areaSum.add(tau$3);
 }
</PRE><P>};
</P><P>function areaRingStart() {
</P><PRE> areaStream.point = areaPointFirst;
</PRE><P>}
</P><P>function areaRingEnd() {
</P><PRE> areaPoint(lambda00, phi00);
</PRE><P>}
</P><P>function areaPointFirst(lambda, phi) {
</P><PRE> areaStream.point = areaPoint;
 lambda00 = lambda, phi00 = phi;
 lambda *= radians, phi *= radians;
 lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);
</PRE><P>}
</P><P>function areaPoint(lambda, phi) {
</P><PRE> lambda *= radians, phi *= radians;
 phi = phi / 2 + quarterPi; // half the angular distance from south pole
</PRE><PRE> // Spherical excess E for a spherical triangle with vertices: south pole,
 // previous point, current point.  Uses a formula derived from Cagnoli’s
 // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
 var dLambda = lambda - lambda0,
     sdLambda = dLambda &gt;= 0 ? 1 : -1,
     adLambda = sdLambda * dLambda,
     cosPhi = cos$1(phi),
     sinPhi = sin$1(phi),
     k = sinPhi0 * sinPhi,
     u = cosPhi0 * cosPhi + k * cos$1(adLambda),
     v = k * sdLambda * sin$1(adLambda);
 areaRingSum.add(atan2(v, u));
</PRE><PRE> // Advance the previous points.
 lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
</PRE><P>}
</P><P>function area$1(object) {
</P><PRE> areaSum.reset();
 geoStream(object, areaStream);
 return areaSum * 2;
</PRE><P>}
</P><P>function spherical(cartesian) {
</P><PRE> return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
</PRE><P>}
</P><P>function cartesian(spherical) {
</P><PRE> var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
 return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
</PRE><P>}
</P><P>function cartesianDot(a, b) {
</P><PRE> return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
</PRE><P>}
</P><P>function cartesianCross(a, b) {
</P><PRE> return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
</PRE><P>}
</P><P>// TODO return a
function cartesianAddInPlace(a, b) {
</P><PRE> a[0] += b[0], a[1] += b[1], a[2] += b[2];
</PRE><P>}
</P><P>function cartesianScale(vector, k) {
</P><PRE> return [vector[0] * k, vector[1] * k, vector[2] * k];
</PRE><P>}
</P><P>// TODO return d
function cartesianNormalizeInPlace(d) {
</P><PRE> var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
 d[0] /= l, d[1] /= l, d[2] /= l;
</PRE><P>}
</P><P>var lambda0$1, phi0, lambda1, phi1, // bounds
</P><PRE>   lambda2, // previous lambda-coordinate
   lambda00$1, phi00$1, // first point
   p0, // previous 3D point
   deltaSum = adder(),
   ranges,
   range;
</PRE><P>var boundsStream = {
</P><PRE> point: boundsPoint,
 lineStart: boundsLineStart,
 lineEnd: boundsLineEnd,
 polygonStart: function() {
   boundsStream.point = boundsRingPoint;
   boundsStream.lineStart = boundsRingStart;
   boundsStream.lineEnd = boundsRingEnd;
   deltaSum.reset();
   areaStream.polygonStart();
 },
 polygonEnd: function() {
   areaStream.polygonEnd();
   boundsStream.point = boundsPoint;
   boundsStream.lineStart = boundsLineStart;
   boundsStream.lineEnd = boundsLineEnd;
   if (areaRingSum &lt; 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
   else if (deltaSum &gt; epsilon$2) phi1 = 90;
   else if (deltaSum &lt; -epsilon$2) phi0 = -90;
   range[0] = lambda0$1, range[1] = lambda1;
 }
</PRE><P>};
</P><P>function boundsPoint(lambda, phi) {
</P><PRE> ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
 if (phi &lt; phi0) phi0 = phi;
 if (phi &gt; phi1) phi1 = phi;
</PRE><P>}
</P><P>function linePoint(lambda, phi) {
</P><PRE> var p = cartesian([lambda * radians, phi * radians]);
 if (p0) {
   var normal = cartesianCross(p0, p),
       equatorial = [normal[1], -normal[0], 0],
       inflection = cartesianCross(equatorial, normal);
   cartesianNormalizeInPlace(inflection);
   inflection = spherical(inflection);
   var delta = lambda - lambda2,
       sign$$1 = delta &gt; 0 ? 1 : -1,
       lambdai = inflection[0] * degrees$1 * sign$$1,
       phii,
       antimeridian = abs(delta) &gt; 180;
   if (antimeridian ^ (sign$$1 * lambda2 &lt; lambdai &amp;&amp; lambdai &lt; sign$$1 * lambda)) {
     phii = inflection[1] * degrees$1;
     if (phii &gt; phi1) phi1 = phii;
   } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 &lt; lambdai &amp;&amp; lambdai &lt; sign$$1 * lambda)) {
     phii = -inflection[1] * degrees$1;
     if (phii &lt; phi0) phi0 = phii;
   } else {
     if (phi &lt; phi0) phi0 = phi;
     if (phi &gt; phi1) phi1 = phi;
   }
   if (antimeridian) {
     if (lambda &lt; lambda2) {
       if (angle(lambda0$1, lambda) &gt; angle(lambda0$1, lambda1)) lambda1 = lambda;
     } else {
       if (angle(lambda, lambda1) &gt; angle(lambda0$1, lambda1)) lambda0$1 = lambda;
     }
   } else {
     if (lambda1 &gt;= lambda0$1) {
       if (lambda &lt; lambda0$1) lambda0$1 = lambda;
       if (lambda &gt; lambda1) lambda1 = lambda;
     } else {
       if (lambda &gt; lambda2) {
         if (angle(lambda0$1, lambda) &gt; angle(lambda0$1, lambda1)) lambda1 = lambda;
       } else {
         if (angle(lambda, lambda1) &gt; angle(lambda0$1, lambda1)) lambda0$1 = lambda;
       }
     }
   }
 } else {
   ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
 }
 if (phi &lt; phi0) phi0 = phi;
 if (phi &gt; phi1) phi1 = phi;
 p0 = p, lambda2 = lambda;
</PRE><P>}
</P><P>function boundsLineStart() {
</P><PRE> boundsStream.point = linePoint;
</PRE><P>}
</P><P>function boundsLineEnd() {
</P><PRE> range[0] = lambda0$1, range[1] = lambda1;
 boundsStream.point = boundsPoint;
 p0 = null;
</PRE><P>}
</P><P>function boundsRingPoint(lambda, phi) {
</P><PRE> if (p0) {
   var delta = lambda - lambda2;
   deltaSum.add(abs(delta) &gt; 180 ? delta + (delta &gt; 0 ? 360 : -360) : delta);
 } else {
   lambda00$1 = lambda, phi00$1 = phi;
 }
 areaStream.point(lambda, phi);
 linePoint(lambda, phi);
</PRE><P>}
</P><P>function boundsRingStart() {
</P><PRE> areaStream.lineStart();
</PRE><P>}
</P><P>function boundsRingEnd() {
</P><PRE> boundsRingPoint(lambda00$1, phi00$1);
 areaStream.lineEnd();
 if (abs(deltaSum) &gt; epsilon$2) lambda0$1 = -(lambda1 = 180);
 range[0] = lambda0$1, range[1] = lambda1;
 p0 = null;
</PRE><P>}
</P><P>// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function angle(lambda0, lambda1) {
</P><PRE> return (lambda1 -= lambda0) &lt; 0 ? lambda1 + 360 : lambda1;
</PRE><P>}
</P><P>function rangeCompare(a, b) {
</P><PRE> return a[0] - b[0];
</PRE><P>}
</P><P>function rangeContains(range, x) {
</P><PRE> return range[0] &lt;= range[1] ? range[0] &lt;= x &amp;&amp; x &lt;= range[1] : x &lt; range[0] || range[1] &lt; x;
</PRE><P>}
</P><P>function bounds(feature) {
</P><PRE> var i, n, a, b, merged, deltaMax, delta;
</PRE><PRE> phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
 ranges = [];
 geoStream(feature, boundsStream);
</PRE><PRE> // First, sort ranges by their minimum longitudes.
 if (n = ranges.length) {
   ranges.sort(rangeCompare);
</PRE><PRE>   // Then, merge any ranges that overlap.
   for (i = 1, a = ranges[0], merged = [a]; i &lt; n; ++i) {
     b = ranges[i];
     if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
       if (angle(a[0], b[1]) &gt; angle(a[0], a[1])) a[1] = b[1];
       if (angle(b[0], a[1]) &gt; angle(a[0], a[1])) a[0] = b[0];
     } else {
       merged.push(a = b);
     }
   }
</PRE><PRE>   // Finally, find the largest gap between the merged ranges.
   // The final bounding box will be the inverse of this gap.
   for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i &lt;= n; a = b, ++i) {
     b = merged[i];
     if ((delta = angle(a[1], b[0])) &gt; deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
   }
 }
</PRE><PRE> ranges = range = null;
</PRE><PRE> return lambda0$1 === Infinity || phi0 === Infinity
     ? [[NaN, NaN], [NaN, NaN]]
     : [[lambda0$1, phi0], [lambda1, phi1]];
</PRE><P>}
</P><P>var W0, W1,
</P><PRE>   X0, Y0, Z0,
   X1, Y1, Z1,
   X2, Y2, Z2,
   lambda00$2, phi00$2, // first point
   x0, y0, z0; // previous point
</PRE><P>var centroidStream = {
</P><PRE> sphere: noop$2,
 point: centroidPoint,
 lineStart: centroidLineStart,
 lineEnd: centroidLineEnd,
 polygonStart: function() {
   centroidStream.lineStart = centroidRingStart;
   centroidStream.lineEnd = centroidRingEnd;
 },
 polygonEnd: function() {
   centroidStream.lineStart = centroidLineStart;
   centroidStream.lineEnd = centroidLineEnd;
 }
</PRE><P>};
</P><P>// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
</P><PRE> lambda *= radians, phi *= radians;
 var cosPhi = cos$1(phi);
 centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
</PRE><P>}
</P><P>function centroidPointCartesian(x, y, z) {
</P><PRE> ++W0;
 X0 += (x - X0) / W0;
 Y0 += (y - Y0) / W0;
 Z0 += (z - Z0) / W0;
</PRE><P>}
</P><P>function centroidLineStart() {
</P><PRE> centroidStream.point = centroidLinePointFirst;
</PRE><P>}
</P><P>function centroidLinePointFirst(lambda, phi) {
</P><PRE> lambda *= radians, phi *= radians;
 var cosPhi = cos$1(phi);
 x0 = cosPhi * cos$1(lambda);
 y0 = cosPhi * sin$1(lambda);
 z0 = sin$1(phi);
 centroidStream.point = centroidLinePoint;
 centroidPointCartesian(x0, y0, z0);
</PRE><P>}
</P><P>function centroidLinePoint(lambda, phi) {
</P><PRE> lambda *= radians, phi *= radians;
 var cosPhi = cos$1(phi),
     x = cosPhi * cos$1(lambda),
     y = cosPhi * sin$1(lambda),
     z = sin$1(phi),
     w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
 W1 += w;
 X1 += w * (x0 + (x0 = x));
 Y1 += w * (y0 + (y0 = y));
 Z1 += w * (z0 + (z0 = z));
 centroidPointCartesian(x0, y0, z0);
</PRE><P>}
</P><P>function centroidLineEnd() {
</P><PRE> centroidStream.point = centroidPoint;
</PRE><P>}
</P><P>// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
</P><PRE> centroidStream.point = centroidRingPointFirst;
</PRE><P>}
</P><P>function centroidRingEnd() {
</P><PRE> centroidRingPoint(lambda00$2, phi00$2);
 centroidStream.point = centroidPoint;
</PRE><P>}
</P><P>function centroidRingPointFirst(lambda, phi) {
</P><PRE> lambda00$2 = lambda, phi00$2 = phi;
 lambda *= radians, phi *= radians;
 centroidStream.point = centroidRingPoint;
 var cosPhi = cos$1(phi);
 x0 = cosPhi * cos$1(lambda);
 y0 = cosPhi * sin$1(lambda);
 z0 = sin$1(phi);
 centroidPointCartesian(x0, y0, z0);
</PRE><P>}
</P><P>function centroidRingPoint(lambda, phi) {
</P><PRE> lambda *= radians, phi *= radians;
 var cosPhi = cos$1(phi),
     x = cosPhi * cos$1(lambda),
     y = cosPhi * sin$1(lambda),
     z = sin$1(phi),
     cx = y0 * z - z0 * y,
     cy = z0 * x - x0 * z,
     cz = x0 * y - y0 * x,
     m = sqrt(cx * cx + cy * cy + cz * cz),
     w = asin(m), // line weight = angle
     v = m &amp;&amp; -w / m; // area weight multiplier
 X2 += v * cx;
 Y2 += v * cy;
 Z2 += v * cz;
 W1 += w;
 X1 += w * (x0 + (x0 = x));
 Y1 += w * (y0 + (y0 = y));
 Z1 += w * (z0 + (z0 = z));
 centroidPointCartesian(x0, y0, z0);
</PRE><P>}
</P><P>function centroid(object) {
</P><PRE> W0 = W1 =
 X0 = Y0 = Z0 =
 X1 = Y1 = Z1 =
 X2 = Y2 = Z2 = 0;
 geoStream(object, centroidStream);
</PRE><PRE> var x = X2,
     y = Y2,
     z = Z2,
     m = x * x + y * y + z * z;
</PRE><PRE> // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
 if (m &lt; epsilon2$1) {
   x = X1, y = Y1, z = Z1;
   // If the feature has zero length, fall back to arithmetic mean of point vectors.
   if (W1 &lt; epsilon$2) x = X0, y = Y0, z = Z0;
   m = x * x + y * y + z * z;
   // If the feature still has an undefined ccentroid, then return.
   if (m &lt; epsilon2$1) return [NaN, NaN];
 }
</PRE><PRE> return [atan2(y, x) * degrees$1, asin(z / sqrt(m)) * degrees$1];
</PRE><P>}
</P><P>function constant$8(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function compose(a, b) {
</P><PRE> function compose(x, y) {
   return x = a(x, y), b(x[0], x[1]);
 }
</PRE><PRE> if (a.invert &amp;&amp; b.invert) compose.invert = function(x, y) {
   return x = b.invert(x, y), x &amp;&amp; a.invert(x[0], x[1]);
 };
</PRE><PRE> return compose;
</PRE><P>}
</P><P>function rotationIdentity(lambda, phi) {
</P><PRE> return [lambda &gt; pi$3 ? lambda - tau$3 : lambda &lt; -pi$3 ? lambda + tau$3 : lambda, phi];
</PRE><P>}
</P><P>rotationIdentity.invert = rotationIdentity;
</P><P>function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
</P><PRE> return (deltaLambda %= tau$3) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
   : rotationLambda(deltaLambda))
   : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
   : rotationIdentity);
</PRE><P>}
</P><P>function forwardRotationLambda(deltaLambda) {
</P><PRE> return function(lambda, phi) {
   return lambda += deltaLambda, [lambda &gt; pi$3 ? lambda - tau$3 : lambda &lt; -pi$3 ? lambda + tau$3 : lambda, phi];
 };
</PRE><P>}
</P><P>function rotationLambda(deltaLambda) {
</P><PRE> var rotation = forwardRotationLambda(deltaLambda);
 rotation.invert = forwardRotationLambda(-deltaLambda);
 return rotation;
</PRE><P>}
</P><P>function rotationPhiGamma(deltaPhi, deltaGamma) {
</P><PRE> var cosDeltaPhi = cos$1(deltaPhi),
     sinDeltaPhi = sin$1(deltaPhi),
     cosDeltaGamma = cos$1(deltaGamma),
     sinDeltaGamma = sin$1(deltaGamma);
</PRE><PRE> function rotation(lambda, phi) {
   var cosPhi = cos$1(phi),
       x = cos$1(lambda) * cosPhi,
       y = sin$1(lambda) * cosPhi,
       z = sin$1(phi),
       k = z * cosDeltaPhi + x * sinDeltaPhi;
   return [
     atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
     asin(k * cosDeltaGamma + y * sinDeltaGamma)
   ];
 }
</PRE><PRE> rotation.invert = function(lambda, phi) {
   var cosPhi = cos$1(phi),
       x = cos$1(lambda) * cosPhi,
       y = sin$1(lambda) * cosPhi,
       z = sin$1(phi),
       k = z * cosDeltaGamma - y * sinDeltaGamma;
   return [
     atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
     asin(k * cosDeltaPhi - x * sinDeltaPhi)
   ];
 };
</PRE><PRE> return rotation;
</PRE><P>}
</P><P>function rotation(rotate) {
</P><PRE> rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length &gt; 2 ? rotate[2] * radians : 0);
</PRE><PRE> function forward(coordinates) {
   coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
   return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
 }
</PRE><PRE> forward.invert = function(coordinates) {
   coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
   return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
 };
</PRE><PRE> return forward;
</PRE><P>}
</P><P>// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
</P><PRE> if (!delta) return;
 var cosRadius = cos$1(radius),
     sinRadius = sin$1(radius),
     step = direction * delta;
 if (t0 == null) {
   t0 = radius + direction * tau$3;
   t1 = radius - step / 2;
 } else {
   t0 = circleRadius(cosRadius, t0);
   t1 = circleRadius(cosRadius, t1);
   if (direction &gt; 0 ? t0 &lt; t1 : t0 &gt; t1) t0 += direction * tau$3;
 }
 for (var point, t = t0; direction &gt; 0 ? t &gt; t1 : t &lt; t1; t -= step) {
   point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
   stream.point(point[0], point[1]);
 }
</PRE><P>}
</P><P>// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
</P><PRE> point = cartesian(point), point[0] -= cosRadius;
 cartesianNormalizeInPlace(point);
 var radius = acos(-point[1]);
 return ((-point[2] &lt; 0 ? -radius : radius) + tau$3 - epsilon$2) % tau$3;
</PRE><P>}
</P><P>function circle() {
</P><PRE> var center = constant$8([0, 0]),
     radius = constant$8(90),
     precision = constant$8(6),
     ring,
     rotate,
     stream = {point: point};
</PRE><PRE> function point(x, y) {
   ring.push(x = rotate(x, y));
   x[0] *= degrees$1, x[1] *= degrees$1;
 }
</PRE><PRE> function circle() {
   var c = center.apply(this, arguments),
       r = radius.apply(this, arguments) * radians,
       p = precision.apply(this, arguments) * radians;
   ring = [];
   rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
   circleStream(stream, r, p, 1);
   c = {type: &quot;Polygon&quot;, coordinates: [ring]};
   ring = rotate = null;
   return c;
 }
</PRE><PRE> circle.center = function(_) {
   return arguments.length ? (center = typeof _ === &quot;function&quot; ? _ : constant$8([+_[0], +_[1]]), circle) : center;
 };
</PRE><PRE> circle.radius = function(_) {
   return arguments.length ? (radius = typeof _ === &quot;function&quot; ? _ : constant$8(+_), circle) : radius;
 };
</PRE><PRE> circle.precision = function(_) {
   return arguments.length ? (precision = typeof _ === &quot;function&quot; ? _ : constant$8(+_), circle) : precision;
 };
</PRE><PRE> return circle;
</PRE><P>}
</P><P>function clipBuffer() {
</P><PRE> var lines = [],
     line;
 return {
   point: function(x, y) {
     line.push([x, y]);
   },
   lineStart: function() {
     lines.push(line = []);
   },
   lineEnd: noop$2,
   rejoin: function() {
     if (lines.length &gt; 1) lines.push(lines.pop().concat(lines.shift()));
   },
   result: function() {
     var result = lines;
     lines = [];
     line = null;
     return result;
   }
 };
</PRE><P>}
</P><P>function pointEqual(a, b) {
</P><PRE> return abs(a[0] - b[0]) &lt; epsilon$2 &amp;&amp; abs(a[1] - b[1]) &lt; epsilon$2;
</PRE><P>}
</P><P>function Intersection(point, points, other, entry) {
</P><PRE> this.x = point;
 this.z = points;
 this.o = other; // another intersection
 this.e = entry; // is an entry?
 this.v = false; // visited
 this.n = this.p = null; // next &amp; previous
</PRE><P>}
</P><P>// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
</P><PRE> var subject = [],
     clip = [],
     i,
     n;
</PRE><PRE> segments.forEach(function(segment) {
   if ((n = segment.length - 1) &lt;= 0) return;
   var n, p0 = segment[0], p1 = segment[n], x;
</PRE><PRE>   // If the first and last points of a segment are coincident, then treat as a
   // closed ring. TODO if all rings are closed, then the winding order of the
   // exterior ring should be checked.
   if (pointEqual(p0, p1)) {
     stream.lineStart();
     for (i = 0; i &lt; n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
     stream.lineEnd();
     return;
   }
</PRE><PRE>   subject.push(x = new Intersection(p0, segment, null, true));
   clip.push(x.o = new Intersection(p0, null, x, false));
   subject.push(x = new Intersection(p1, segment, null, false));
   clip.push(x.o = new Intersection(p1, null, x, true));
 });
</PRE><PRE> if (!subject.length) return;
</PRE><PRE> clip.sort(compareIntersection);
 link$1(subject);
 link$1(clip);
</PRE><PRE> for (i = 0, n = clip.length; i &lt; n; ++i) {
   clip[i].e = startInside = !startInside;
 }
</PRE><PRE> var start = subject[0],
     points,
     point;
</PRE><PRE> while (1) {
   // Find first unvisited intersection.
   var current = start,
       isSubject = true;
   while (current.v) if ((current = current.n) === start) return;
   points = current.z;
   stream.lineStart();
   do {
     current.v = current.o.v = true;
     if (current.e) {
       if (isSubject) {
         for (i = 0, n = points.length; i &lt; n; ++i) stream.point((point = points[i])[0], point[1]);
       } else {
         interpolate(current.x, current.n.x, 1, stream);
       }
       current = current.n;
     } else {
       if (isSubject) {
         points = current.p.z;
         for (i = points.length - 1; i &gt;= 0; --i) stream.point((point = points[i])[0], point[1]);
       } else {
         interpolate(current.x, current.p.x, -1, stream);
       }
       current = current.p;
     }
     current = current.o;
     points = current.z;
     isSubject = !isSubject;
   } while (!current.v);
   stream.lineEnd();
 }
</PRE><P>}
</P><P>function link$1(array) {
</P><PRE> if (!(n = array.length)) return;
 var n,
     i = 0,
     a = array[0],
     b;
 while (++i &lt; n) {
   a.n = b = array[i];
   b.p = a;
   a = b;
 }
 a.n = b = array[0];
 b.p = a;
</PRE><P>}
</P><P>var sum$1 = adder();
</P><P>function polygonContains(polygon, point) {
</P><PRE> var lambda = point[0],
     phi = point[1],
     sinPhi = sin$1(phi),
     normal = [sin$1(lambda), -cos$1(lambda), 0],
     angle = 0,
     winding = 0;
</PRE><PRE> sum$1.reset();
</PRE><PRE> if (sinPhi === 1) phi = halfPi$2 + epsilon$2;
 else if (sinPhi === -1) phi = -halfPi$2 - epsilon$2;
</PRE><PRE> for (var i = 0, n = polygon.length; i &lt; n; ++i) {
   if (!(m = (ring = polygon[i]).length)) continue;
   var ring,
       m,
       point0 = ring[m - 1],
       lambda0 = point0[0],
       phi0 = point0[1] / 2 + quarterPi,
       sinPhi0 = sin$1(phi0),
       cosPhi0 = cos$1(phi0);
</PRE><PRE>   for (var j = 0; j &lt; m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
     var point1 = ring[j],
         lambda1 = point1[0],
         phi1 = point1[1] / 2 + quarterPi,
         sinPhi1 = sin$1(phi1),
         cosPhi1 = cos$1(phi1),
         delta = lambda1 - lambda0,
         sign$$1 = delta &gt;= 0 ? 1 : -1,
         absDelta = sign$$1 * delta,
         antimeridian = absDelta &gt; pi$3,
         k = sinPhi0 * sinPhi1;
</PRE><PRE>     sum$1.add(atan2(k * sign$$1 * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
     angle += antimeridian ? delta + sign$$1 * tau$3 : delta;
</PRE><PRE>     // Are the longitudes either side of the point’s meridian (lambda),
     // and are the latitudes smaller than the parallel (phi)?
     if (antimeridian ^ lambda0 &gt;= lambda ^ lambda1 &gt;= lambda) {
       var arc = cartesianCross(cartesian(point0), cartesian(point1));
       cartesianNormalizeInPlace(arc);
       var intersection = cartesianCross(normal, arc);
       cartesianNormalizeInPlace(intersection);
       var phiArc = (antimeridian ^ delta &gt;= 0 ? -1 : 1) * asin(intersection[2]);
       if (phi &gt; phiArc || phi === phiArc &amp;&amp; (arc[0] || arc[1])) {
         winding += antimeridian ^ delta &gt;= 0 ? 1 : -1;
       }
     }
   }
 }
</PRE><PRE> // First, determine whether the South pole is inside or outside:
 //
 // It is inside if:
 // * the polygon winds around it in a clockwise direction.
 // * the polygon does not (cumulatively) wind around it, but has a negative
 //   (counter-clockwise) area.
 //
 // Second, count the (signed) number of times a segment crosses a lambda
 // from the point to the South pole.  If it is zero, then the point is the
 // same side as the South pole.
</PRE><PRE> return (angle &lt; -epsilon$2 || angle &lt; epsilon$2 &amp;&amp; sum$1 &lt; -epsilon$2) ^ (winding &amp; 1);
</PRE><P>}
</P><P>function clip(pointVisible, clipLine, interpolate, start) {
</P><PRE> return function(sink) {
   var line = clipLine(sink),
       ringBuffer = clipBuffer(),
       ringSink = clipLine(ringBuffer),
       polygonStarted = false,
       polygon,
       segments,
       ring;
</PRE><PRE>   var clip = {
     point: point,
     lineStart: lineStart,
     lineEnd: lineEnd,
     polygonStart: function() {
       clip.point = pointRing;
       clip.lineStart = ringStart;
       clip.lineEnd = ringEnd;
       segments = [];
       polygon = [];
     },
     polygonEnd: function() {
       clip.point = point;
       clip.lineStart = lineStart;
       clip.lineEnd = lineEnd;
       segments = merge(segments);
       var startInside = polygonContains(polygon, start);
       if (segments.length) {
         if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
         clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
       } else if (startInside) {
         if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
         sink.lineStart();
         interpolate(null, null, 1, sink);
         sink.lineEnd();
       }
       if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
       segments = polygon = null;
     },
     sphere: function() {
       sink.polygonStart();
       sink.lineStart();
       interpolate(null, null, 1, sink);
       sink.lineEnd();
       sink.polygonEnd();
     }
   };
</PRE><PRE>   function point(lambda, phi) {
     if (pointVisible(lambda, phi)) sink.point(lambda, phi);
   }
</PRE><PRE>   function pointLine(lambda, phi) {
     line.point(lambda, phi);
   }
</PRE><PRE>   function lineStart() {
     clip.point = pointLine;
     line.lineStart();
   }
</PRE><PRE>   function lineEnd() {
     clip.point = point;
     line.lineEnd();
   }
</PRE><PRE>   function pointRing(lambda, phi) {
     ring.push([lambda, phi]);
     ringSink.point(lambda, phi);
   }
</PRE><PRE>   function ringStart() {
     ringSink.lineStart();
     ring = [];
   }
</PRE><PRE>   function ringEnd() {
     pointRing(ring[0][0], ring[0][1]);
     ringSink.lineEnd();
</PRE><PRE>     var clean = ringSink.clean(),
         ringSegments = ringBuffer.result(),
         i, n = ringSegments.length, m,
         segment,
         point;
</PRE><PRE>     ring.pop();
     polygon.push(ring);
     ring = null;
</PRE><PRE>     if (!n) return;
</PRE><PRE>     // No intersections.
     if (clean &amp; 1) {
       segment = ringSegments[0];
       if ((m = segment.length - 1) &gt; 0) {
         if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
         sink.lineStart();
         for (i = 0; i &lt; m; ++i) sink.point((point = segment[i])[0], point[1]);
         sink.lineEnd();
       }
       return;
     }
</PRE><PRE>     // Rejoin connected segments.
     // TODO reuse ringBuffer.rejoin()?
     if (n &gt; 1 &amp;&amp; clean &amp; 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
</PRE><PRE>     segments.push(ringSegments.filter(validSegment));
   }
</PRE><PRE>   return clip;
 };
</PRE><P>}
</P><P>function validSegment(segment) {
</P><PRE> return segment.length &gt; 1;
</PRE><P>}
</P><P>// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
</P><PRE> return ((a = a.x)[0] &lt; 0 ? a[1] - halfPi$2 - epsilon$2 : halfPi$2 - a[1])
      - ((b = b.x)[0] &lt; 0 ? b[1] - halfPi$2 - epsilon$2 : halfPi$2 - b[1]);
</PRE><P>}
</P><P>var clipAntimeridian = clip(
</P><PRE> function() { return true; },
 clipAntimeridianLine,
 clipAntimeridianInterpolate,
 [-pi$3, -halfPi$2]
</PRE><P>);
</P><P>// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
</P><PRE> var lambda0 = NaN,
     phi0 = NaN,
     sign0 = NaN,
     clean; // no intersections
</PRE><PRE> return {
   lineStart: function() {
     stream.lineStart();
     clean = 1;
   },
   point: function(lambda1, phi1) {
     var sign1 = lambda1 &gt; 0 ? pi$3 : -pi$3,
         delta = abs(lambda1 - lambda0);
     if (abs(delta - pi$3) &lt; epsilon$2) { // line crosses a pole
       stream.point(lambda0, phi0 = (phi0 + phi1) / 2 &gt; 0 ? halfPi$2 : -halfPi$2);
       stream.point(sign0, phi0);
       stream.lineEnd();
       stream.lineStart();
       stream.point(sign1, phi0);
       stream.point(lambda1, phi0);
       clean = 0;
     } else if (sign0 !== sign1 &amp;&amp; delta &gt;= pi$3) { // line crosses antimeridian
       if (abs(lambda0 - sign0) &lt; epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies
       if (abs(lambda1 - sign1) &lt; epsilon$2) lambda1 -= sign1 * epsilon$2;
       phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
       stream.point(sign0, phi0);
       stream.lineEnd();
       stream.lineStart();
       stream.point(sign1, phi0);
       clean = 0;
     }
     stream.point(lambda0 = lambda1, phi0 = phi1);
     sign0 = sign1;
   },
   lineEnd: function() {
     stream.lineEnd();
     lambda0 = phi0 = NaN;
   },
   clean: function() {
     return 2 - clean; // if intersections, rejoin first and last segments
   }
 };
</PRE><P>}
</P><P>function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
</P><PRE> var cosPhi0,
     cosPhi1,
     sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
 return abs(sinLambda0Lambda1) &gt; epsilon$2
     ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
         - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
         / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
     : (phi0 + phi1) / 2;
</PRE><P>}
</P><P>function clipAntimeridianInterpolate(from, to, direction, stream) {
</P><PRE> var phi;
 if (from == null) {
   phi = direction * halfPi$2;
   stream.point(-pi$3, phi);
   stream.point(0, phi);
   stream.point(pi$3, phi);
   stream.point(pi$3, 0);
   stream.point(pi$3, -phi);
   stream.point(0, -phi);
   stream.point(-pi$3, -phi);
   stream.point(-pi$3, 0);
   stream.point(-pi$3, phi);
 } else if (abs(from[0] - to[0]) &gt; epsilon$2) {
   var lambda = from[0] &lt; to[0] ? pi$3 : -pi$3;
   phi = direction * lambda / 2;
   stream.point(-lambda, phi);
   stream.point(0, phi);
   stream.point(lambda, phi);
 } else {
   stream.point(to[0], to[1]);
 }
</PRE><P>}
</P><P>function clipCircle(radius) {
</P><PRE> var cr = cos$1(radius),
     delta = 6 * radians,
     smallRadius = cr &gt; 0,
     notHemisphere = abs(cr) &gt; epsilon$2; // TODO optimise for this common case
</PRE><PRE> function interpolate(from, to, direction, stream) {
   circleStream(stream, radius, delta, direction, from, to);
 }
</PRE><PRE> function visible(lambda, phi) {
   return cos$1(lambda) * cos$1(phi) &gt; cr;
 }
</PRE><PRE> // Takes a line and cuts into visible segments. Return values used for polygon
 // clipping: 0 - there were intersections or the line was empty; 1 - no
 // intersections 2 - there were intersections, and the first and last segments
 // should be rejoined.
 function clipLine(stream) {
   var point0, // previous point
       c0, // code for previous point
       v0, // visibility of previous point
       v00, // visibility of first point
       clean; // no intersections
   return {
     lineStart: function() {
       v00 = v0 = false;
       clean = 1;
     },
     point: function(lambda, phi) {
       var point1 = [lambda, phi],
           point2,
           v = visible(lambda, phi),
           c = smallRadius
             ? v ? 0 : code(lambda, phi)
             : v ? code(lambda + (lambda &lt; 0 ? pi$3 : -pi$3), phi) : 0;
       if (!point0 &amp;&amp; (v00 = v0 = v)) stream.lineStart();
       // Handle degeneracies.
       // TODO ignore if not clipping polygons.
       if (v !== v0) {
         point2 = intersect(point0, point1);
         if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
           point1[0] += epsilon$2;
           point1[1] += epsilon$2;
           v = visible(point1[0], point1[1]);
         }
       }
       if (v !== v0) {
         clean = 0;
         if (v) {
           // outside going in
           stream.lineStart();
           point2 = intersect(point1, point0);
           stream.point(point2[0], point2[1]);
         } else {
           // inside going out
           point2 = intersect(point0, point1);
           stream.point(point2[0], point2[1]);
           stream.lineEnd();
         }
         point0 = point2;
       } else if (notHemisphere &amp;&amp; point0 &amp;&amp; smallRadius ^ v) {
         var t;
         // If the codes for two points are different, or are both zero,
         // and there this segment intersects with the small circle.
         if (!(c &amp; c0) &amp;&amp; (t = intersect(point1, point0, true))) {
           clean = 0;
           if (smallRadius) {
             stream.lineStart();
             stream.point(t[0][0], t[0][1]);
             stream.point(t[1][0], t[1][1]);
             stream.lineEnd();
           } else {
             stream.point(t[1][0], t[1][1]);
             stream.lineEnd();
             stream.lineStart();
             stream.point(t[0][0], t[0][1]);
           }
         }
       }
       if (v &amp;&amp; (!point0 || !pointEqual(point0, point1))) {
         stream.point(point1[0], point1[1]);
       }
       point0 = point1, v0 = v, c0 = c;
     },
     lineEnd: function() {
       if (v0) stream.lineEnd();
       point0 = null;
     },
     // Rejoin first and last segments if there were intersections and the first
     // and last points were visible.
     clean: function() {
       return clean | ((v00 &amp;&amp; v0) &lt;&lt; 1);
     }
   };
 }
</PRE><PRE> // Intersects the great circle between a and b with the clip circle.
 function intersect(a, b, two) {
   var pa = cartesian(a),
       pb = cartesian(b);
</PRE><PRE>   // We have two planes, n1.p = d1 and n2.p = d2.
   // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
   var n1 = [1, 0, 0], // normal
       n2 = cartesianCross(pa, pb),
       n2n2 = cartesianDot(n2, n2),
       n1n2 = n2[0], // cartesianDot(n1, n2),
       determinant = n2n2 - n1n2 * n1n2;
</PRE><PRE>   // Two polar points.
   if (!determinant) return !two &amp;&amp; a;
</PRE><PRE>   var c1 =  cr * n2n2 / determinant,
       c2 = -cr * n1n2 / determinant,
       n1xn2 = cartesianCross(n1, n2),
       A = cartesianScale(n1, c1),
       B = cartesianScale(n2, c2);
   cartesianAddInPlace(A, B);
</PRE><PRE>   // Solve |p(t)|^2 = 1.
   var u = n1xn2,
       w = cartesianDot(A, u),
       uu = cartesianDot(u, u),
       t2 = w * w - uu * (cartesianDot(A, A) - 1);
</PRE><PRE>   if (t2 &lt; 0) return;
</PRE><PRE>   var t = sqrt(t2),
       q = cartesianScale(u, (-w - t) / uu);
   cartesianAddInPlace(q, A);
   q = spherical(q);
</PRE><PRE>   if (!two) return q;
</PRE><PRE>   // Two intersection points.
   var lambda0 = a[0],
       lambda1 = b[0],
       phi0 = a[1],
       phi1 = b[1],
       z;
</PRE><PRE>   if (lambda1 &lt; lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
</PRE><PRE>   var delta = lambda1 - lambda0,
       polar = abs(delta - pi$3) &lt; epsilon$2,
       meridian = polar || delta &lt; epsilon$2;
</PRE><PRE>   if (!polar &amp;&amp; phi1 &lt; phi0) z = phi0, phi0 = phi1, phi1 = z;
</PRE><PRE>   // Check that the first point is between a and b.
   if (meridian
       ? polar
         ? phi0 + phi1 &gt; 0 ^ q[1] &lt; (abs(q[0] - lambda0) &lt; epsilon$2 ? phi0 : phi1)
         : phi0 &lt;= q[1] &amp;&amp; q[1] &lt;= phi1
       : delta &gt; pi$3 ^ (lambda0 &lt;= q[0] &amp;&amp; q[0] &lt;= lambda1)) {
     var q1 = cartesianScale(u, (-w + t) / uu);
     cartesianAddInPlace(q1, A);
     return [q, spherical(q1)];
   }
 }
</PRE><PRE> // Generates a 4-bit vector representing the location of a point relative to
 // the small circle's bounding box.
 function code(lambda, phi) {
   var r = smallRadius ? radius : pi$3 - radius,
       code = 0;
   if (lambda &lt; -r) code |= 1; // left
   else if (lambda &gt; r) code |= 2; // right
   if (phi &lt; -r) code |= 4; // below
   else if (phi &gt; r) code |= 8; // above
   return code;
 }
</PRE><PRE> return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$3, radius - pi$3]);
</PRE><P>}
</P><P>function clipLine(a, b, x0, y0, x1, y1) {
</P><PRE> var ax = a[0],
     ay = a[1],
     bx = b[0],
     by = b[1],
     t0 = 0,
     t1 = 1,
     dx = bx - ax,
     dy = by - ay,
     r;
</PRE><PRE> r = x0 - ax;
 if (!dx &amp;&amp; r &gt; 0) return;
 r /= dx;
 if (dx &lt; 0) {
   if (r &lt; t0) return;
   if (r &lt; t1) t1 = r;
 } else if (dx &gt; 0) {
   if (r &gt; t1) return;
   if (r &gt; t0) t0 = r;
 }
</PRE><PRE> r = x1 - ax;
 if (!dx &amp;&amp; r &lt; 0) return;
 r /= dx;
 if (dx &lt; 0) {
   if (r &gt; t1) return;
   if (r &gt; t0) t0 = r;
 } else if (dx &gt; 0) {
   if (r &lt; t0) return;
   if (r &lt; t1) t1 = r;
 }
</PRE><PRE> r = y0 - ay;
 if (!dy &amp;&amp; r &gt; 0) return;
 r /= dy;
 if (dy &lt; 0) {
   if (r &lt; t0) return;
   if (r &lt; t1) t1 = r;
 } else if (dy &gt; 0) {
   if (r &gt; t1) return;
   if (r &gt; t0) t0 = r;
 }
</PRE><PRE> r = y1 - ay;
 if (!dy &amp;&amp; r &lt; 0) return;
 r /= dy;
 if (dy &lt; 0) {
   if (r &gt; t1) return;
   if (r &gt; t0) t0 = r;
 } else if (dy &gt; 0) {
   if (r &lt; t0) return;
   if (r &lt; t1) t1 = r;
 }
</PRE><PRE> if (t0 &gt; 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
 if (t1 &lt; 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
 return true;
</PRE><P>}
</P><P>var clipMax = 1e9, clipMin = -clipMax;
</P><P>// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?
</P><P>function clipRectangle(x0, y0, x1, y1) {
</P><PRE> function visible(x, y) {
   return x0 &lt;= x &amp;&amp; x &lt;= x1 &amp;&amp; y0 &lt;= y &amp;&amp; y &lt;= y1;
 }
</PRE><PRE> function interpolate(from, to, direction, stream) {
   var a = 0, a1 = 0;
   if (from == null
       || (a = corner(from, direction)) !== (a1 = corner(to, direction))
       || comparePoint(from, to) &lt; 0 ^ direction &gt; 0) {
     do stream.point(a === 0 || a === 3 ? x0 : x1, a &gt; 1 ? y1 : y0);
     while ((a = (a + direction + 4) % 4) !== a1);
   } else {
     stream.point(to[0], to[1]);
   }
 }
</PRE><PRE> function corner(p, direction) {
   return abs(p[0] - x0) &lt; epsilon$2 ? direction &gt; 0 ? 0 : 3
       : abs(p[0] - x1) &lt; epsilon$2 ? direction &gt; 0 ? 2 : 1
       : abs(p[1] - y0) &lt; epsilon$2 ? direction &gt; 0 ? 1 : 0
       : direction &gt; 0 ? 3 : 2; // abs(p[1] - y1) &lt; epsilon
 }
</PRE><PRE> function compareIntersection(a, b) {
   return comparePoint(a.x, b.x);
 }
</PRE><PRE> function comparePoint(a, b) {
   var ca = corner(a, 1),
       cb = corner(b, 1);
   return ca !== cb ? ca - cb
       : ca === 0 ? b[1] - a[1]
       : ca === 1 ? a[0] - b[0]
       : ca === 2 ? a[1] - b[1]
       : b[0] - a[0];
 }
</PRE><PRE> return function(stream) {
   var activeStream = stream,
       bufferStream = clipBuffer(),
       segments,
       polygon,
       ring,
       x__, y__, v__, // first point
       x_, y_, v_, // previous point
       first,
       clean;
</PRE><PRE>   var clipStream = {
     point: point,
     lineStart: lineStart,
     lineEnd: lineEnd,
     polygonStart: polygonStart,
     polygonEnd: polygonEnd
   };
</PRE><PRE>   function point(x, y) {
     if (visible(x, y)) activeStream.point(x, y);
   }
</PRE><PRE>   function polygonInside() {
     var winding = 0;
</PRE><PRE>     for (var i = 0, n = polygon.length; i &lt; n; ++i) {
       for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j &lt; m; ++j) {
         a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
         if (a1 &lt;= y1) { if (b1 &gt; y1 &amp;&amp; (b0 - a0) * (y1 - a1) &gt; (b1 - a1) * (x0 - a0)) ++winding; }
         else { if (b1 &lt;= y1 &amp;&amp; (b0 - a0) * (y1 - a1) &lt; (b1 - a1) * (x0 - a0)) --winding; }
       }
     }
</PRE><PRE>     return winding;
   }
</PRE><PRE>   // Buffer geometry within a polygon and then clip it en masse.
   function polygonStart() {
     activeStream = bufferStream, segments = [], polygon = [], clean = true;
   }
</PRE><PRE>   function polygonEnd() {
     var startInside = polygonInside(),
         cleanInside = clean &amp;&amp; startInside,
         visible = (segments = merge(segments)).length;
     if (cleanInside || visible) {
       stream.polygonStart();
       if (cleanInside) {
         stream.lineStart();
         interpolate(null, null, 1, stream);
         stream.lineEnd();
       }
       if (visible) {
         clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
       }
       stream.polygonEnd();
     }
     activeStream = stream, segments = polygon = ring = null;
   }
</PRE><PRE>   function lineStart() {
     clipStream.point = linePoint;
     if (polygon) polygon.push(ring = []);
     first = true;
     v_ = false;
     x_ = y_ = NaN;
   }
</PRE><PRE>   // TODO rather than special-case polygons, simply handle them separately.
   // Ideally, coincident intersection points should be jittered to avoid
   // clipping issues.
   function lineEnd() {
     if (segments) {
       linePoint(x__, y__);
       if (v__ &amp;&amp; v_) bufferStream.rejoin();
       segments.push(bufferStream.result());
     }
     clipStream.point = point;
     if (v_) activeStream.lineEnd();
   }
</PRE><PRE>   function linePoint(x, y) {
     var v = visible(x, y);
     if (polygon) ring.push([x, y]);
     if (first) {
       x__ = x, y__ = y, v__ = v;
       first = false;
       if (v) {
         activeStream.lineStart();
         activeStream.point(x, y);
       }
     } else {
       if (v &amp;&amp; v_) activeStream.point(x, y);
       else {
         var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
             b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
         if (clipLine(a, b, x0, y0, x1, y1)) {
           if (!v_) {
             activeStream.lineStart();
             activeStream.point(a[0], a[1]);
           }
           activeStream.point(b[0], b[1]);
           if (!v) activeStream.lineEnd();
           clean = false;
         } else if (v) {
           activeStream.lineStart();
           activeStream.point(x, y);
           clean = false;
         }
       }
     }
     x_ = x, y_ = y, v_ = v;
   }
</PRE><PRE>   return clipStream;
 };
</PRE><P>}
</P><P>function extent$1() {
</P><PRE> var x0 = 0,
     y0 = 0,
     x1 = 960,
     y1 = 500,
     cache,
     cacheStream,
     clip;
</PRE><PRE> return clip = {
   stream: function(stream) {
     return cache &amp;&amp; cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
   },
   extent: function(_) {
     return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
   }
 };
</PRE><P>}
</P><P>var lengthSum = adder(),
</P><PRE>   lambda0$2,
   sinPhi0$1,
   cosPhi0$1;
</PRE><P>var lengthStream = {
</P><PRE> sphere: noop$2,
 point: noop$2,
 lineStart: lengthLineStart,
 lineEnd: noop$2,
 polygonStart: noop$2,
 polygonEnd: noop$2
</PRE><P>};
</P><P>function lengthLineStart() {
</P><PRE> lengthStream.point = lengthPointFirst;
 lengthStream.lineEnd = lengthLineEnd;
</PRE><P>}
</P><P>function lengthLineEnd() {
</P><PRE> lengthStream.point = lengthStream.lineEnd = noop$2;
</PRE><P>}
</P><P>function lengthPointFirst(lambda, phi) {
</P><PRE> lambda *= radians, phi *= radians;
 lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);
 lengthStream.point = lengthPoint;
</PRE><P>}
</P><P>function lengthPoint(lambda, phi) {
</P><PRE> lambda *= radians, phi *= radians;
 var sinPhi = sin$1(phi),
     cosPhi = cos$1(phi),
     delta = abs(lambda - lambda0$2),
     cosDelta = cos$1(delta),
     sinDelta = sin$1(delta),
     x = cosPhi * sinDelta,
     y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
     z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
 lengthSum.add(atan2(sqrt(x * x + y * y), z));
 lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
</PRE><P>}
</P><P>function length$1(object) {
</P><PRE> lengthSum.reset();
 geoStream(object, lengthStream);
 return +lengthSum;
</PRE><P>}
</P><P>var coordinates = [null, null],
</P><PRE>   object$1 = {type: &quot;LineString&quot;, coordinates: coordinates};
</PRE><P>function distance(a, b) {
</P><PRE> coordinates[0] = a;
 coordinates[1] = b;
 return length$1(object$1);
</PRE><P>}
</P><P>var containsObjectType = {
</P><PRE> Feature: function(object, point) {
   return containsGeometry(object.geometry, point);
 },
 FeatureCollection: function(object, point) {
   var features = object.features, i = -1, n = features.length;
   while (++i &lt; n) if (containsGeometry(features[i].geometry, point)) return true;
   return false;
 }
</PRE><P>};
</P><P>var containsGeometryType = {
</P><PRE> Sphere: function() {
   return true;
 },
 Point: function(object, point) {
   return containsPoint(object.coordinates, point);
 },
 MultiPoint: function(object, point) {
   var coordinates = object.coordinates, i = -1, n = coordinates.length;
   while (++i &lt; n) if (containsPoint(coordinates[i], point)) return true;
   return false;
 },
 LineString: function(object, point) {
   return containsLine(object.coordinates, point);
 },
 MultiLineString: function(object, point) {
   var coordinates = object.coordinates, i = -1, n = coordinates.length;
   while (++i &lt; n) if (containsLine(coordinates[i], point)) return true;
   return false;
 },
 Polygon: function(object, point) {
   return containsPolygon(object.coordinates, point);
 },
 MultiPolygon: function(object, point) {
   var coordinates = object.coordinates, i = -1, n = coordinates.length;
   while (++i &lt; n) if (containsPolygon(coordinates[i], point)) return true;
   return false;
 },
 GeometryCollection: function(object, point) {
   var geometries = object.geometries, i = -1, n = geometries.length;
   while (++i &lt; n) if (containsGeometry(geometries[i], point)) return true;
   return false;
 }
</PRE><P>};
</P><P>function containsGeometry(geometry, point) {
</P><PRE> return geometry &amp;&amp; containsGeometryType.hasOwnProperty(geometry.type)
     ? containsGeometryType[geometry.type](geometry, point)
     : false;
</PRE><P>}
</P><P>function containsPoint(coordinates, point) {
</P><PRE> return distance(coordinates, point) === 0;
</PRE><P>}
</P><P>function containsLine(coordinates, point) {
</P><PRE> var ab = distance(coordinates[0], coordinates[1]),
     ao = distance(coordinates[0], point),
     ob = distance(point, coordinates[1]);
 return ao + ob &lt;= ab + epsilon$2;
</PRE><P>}
</P><P>function containsPolygon(coordinates, point) {
</P><PRE> return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
</PRE><P>}
</P><P>function ringRadians(ring) {
</P><PRE> return ring = ring.map(pointRadians), ring.pop(), ring;
</PRE><P>}
</P><P>function pointRadians(point) {
</P><PRE> return [point[0] * radians, point[1] * radians];
</PRE><P>}
</P><P>function contains$1(object, point) {
</P><PRE> return (object &amp;&amp; containsObjectType.hasOwnProperty(object.type)
     ? containsObjectType[object.type]
     : containsGeometry)(object, point);
</PRE><P>}
</P><P>function graticuleX(y0, y1, dy) {
</P><PRE> var y = sequence(y0, y1 - epsilon$2, dy).concat(y1);
 return function(x) { return y.map(function(y) { return [x, y]; }); };
</PRE><P>}
</P><P>function graticuleY(x0, x1, dx) {
</P><PRE> var x = sequence(x0, x1 - epsilon$2, dx).concat(x1);
 return function(y) { return x.map(function(x) { return [x, y]; }); };
</PRE><P>}
</P><P>function graticule() {
</P><PRE> var x1, x0, X1, X0,
     y1, y0, Y1, Y0,
     dx = 10, dy = dx, DX = 90, DY = 360,
     x, y, X, Y,
     precision = 2.5;
</PRE><PRE> function graticule() {
   return {type: &quot;MultiLineString&quot;, coordinates: lines()};
 }
</PRE><PRE> function lines() {
   return sequence(ceil(X0 / DX) * DX, X1, DX).map(X)
       .concat(sequence(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
       .concat(sequence(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) &gt; epsilon$2; }).map(x))
       .concat(sequence(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) &gt; epsilon$2; }).map(y));
 }
</PRE><PRE> graticule.lines = function() {
   return lines().map(function(coordinates) { return {type: &quot;LineString&quot;, coordinates: coordinates}; });
 };
</PRE><PRE> graticule.outline = function() {
   return {
     type: &quot;Polygon&quot;,
     coordinates: [
       X(X0).concat(
       Y(Y1).slice(1),
       X(X1).reverse().slice(1),
       Y(Y0).reverse().slice(1))
     ]
   };
 };
</PRE><PRE> graticule.extent = function(_) {
   if (!arguments.length) return graticule.extentMinor();
   return graticule.extentMajor(_).extentMinor(_);
 };
</PRE><PRE> graticule.extentMajor = function(_) {
   if (!arguments.length) return [[X0, Y0], [X1, Y1]];
   X0 = +_[0][0], X1 = +_[1][0];
   Y0 = +_[0][1], Y1 = +_[1][1];
   if (X0 &gt; X1) _ = X0, X0 = X1, X1 = _;
   if (Y0 &gt; Y1) _ = Y0, Y0 = Y1, Y1 = _;
   return graticule.precision(precision);
 };
</PRE><PRE> graticule.extentMinor = function(_) {
   if (!arguments.length) return [[x0, y0], [x1, y1]];
   x0 = +_[0][0], x1 = +_[1][0];
   y0 = +_[0][1], y1 = +_[1][1];
   if (x0 &gt; x1) _ = x0, x0 = x1, x1 = _;
   if (y0 &gt; y1) _ = y0, y0 = y1, y1 = _;
   return graticule.precision(precision);
 };
</PRE><PRE> graticule.step = function(_) {
   if (!arguments.length) return graticule.stepMinor();
   return graticule.stepMajor(_).stepMinor(_);
 };
</PRE><PRE> graticule.stepMajor = function(_) {
   if (!arguments.length) return [DX, DY];
   DX = +_[0], DY = +_[1];
   return graticule;
 };
</PRE><PRE> graticule.stepMinor = function(_) {
   if (!arguments.length) return [dx, dy];
   dx = +_[0], dy = +_[1];
   return graticule;
 };
</PRE><PRE> graticule.precision = function(_) {
   if (!arguments.length) return precision;
   precision = +_;
   x = graticuleX(y0, y1, 90);
   y = graticuleY(x0, x1, precision);
   X = graticuleX(Y0, Y1, 90);
   Y = graticuleY(X0, X1, precision);
   return graticule;
 };
</PRE><PRE> return graticule
     .extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]])
     .extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
</PRE><P>}</P><P>function graticule10() {
</P><PRE> return graticule()();
</PRE><P>}
</P><P>function interpolate$1(a, b) {
</P><PRE> var x0 = a[0] * radians,
     y0 = a[1] * radians,
     x1 = b[0] * radians,
     y1 = b[1] * radians,
     cy0 = cos$1(y0),
     sy0 = sin$1(y0),
     cy1 = cos$1(y1),
     sy1 = sin$1(y1),
     kx0 = cy0 * cos$1(x0),
     ky0 = cy0 * sin$1(x0),
     kx1 = cy1 * cos$1(x1),
     ky1 = cy1 * sin$1(x1),
     d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
     k = sin$1(d);
</PRE><PRE> var interpolate = d ? function(t) {
   var B = sin$1(t *= d) / k,
       A = sin$1(d - t) / k,
       x = A * kx0 + B * kx1,
       y = A * ky0 + B * ky1,
       z = A * sy0 + B * sy1;
   return [
     atan2(y, x) * degrees$1,
     atan2(z, sqrt(x * x + y * y)) * degrees$1
   ];
 } : function() {
   return [x0 * degrees$1, y0 * degrees$1];
 };
</PRE><PRE> interpolate.distance = d;
</PRE><PRE> return interpolate;
</PRE><P>}
</P><P>function identity$4(x) {
</P><PRE> return x;
</PRE><P>}
</P><P>var areaSum$1 = adder(),
</P><PRE>   areaRingSum$1 = adder(),
   x00,
   y00,
   x0$1,
   y0$1;
</PRE><P>var areaStream$1 = {
</P><PRE> point: noop$2,
 lineStart: noop$2,
 lineEnd: noop$2,
 polygonStart: function() {
   areaStream$1.lineStart = areaRingStart$1;
   areaStream$1.lineEnd = areaRingEnd$1;
 },
 polygonEnd: function() {
   areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$2;
   areaSum$1.add(abs(areaRingSum$1));
   areaRingSum$1.reset();
 },
 result: function() {
   var area = areaSum$1 / 2;
   areaSum$1.reset();
   return area;
 }
</PRE><P>};
</P><P>function areaRingStart$1() {
</P><PRE> areaStream$1.point = areaPointFirst$1;
</PRE><P>}
</P><P>function areaPointFirst$1(x, y) {
</P><PRE> areaStream$1.point = areaPoint$1;
 x00 = x0$1 = x, y00 = y0$1 = y;
</PRE><P>}
</P><P>function areaPoint$1(x, y) {
</P><PRE> areaRingSum$1.add(y0$1 * x - x0$1 * y);
 x0$1 = x, y0$1 = y;
</PRE><P>}
</P><P>function areaRingEnd$1() {
</P><PRE> areaPoint$1(x00, y00);
</PRE><P>}
</P><P>var x0$2 = Infinity,
</P><PRE>   y0$2 = x0$2,
   x1 = -x0$2,
   y1 = x1;
</PRE><P>var boundsStream$1 = {
</P><PRE> point: boundsPoint$1,
 lineStart: noop$2,
 lineEnd: noop$2,
 polygonStart: noop$2,
 polygonEnd: noop$2,
 result: function() {
   var bounds = [[x0$2, y0$2], [x1, y1]];
   x1 = y1 = -(y0$2 = x0$2 = Infinity);
   return bounds;
 }
</PRE><P>};
</P><P>function boundsPoint$1(x, y) {
</P><PRE> if (x &lt; x0$2) x0$2 = x;
 if (x &gt; x1) x1 = x;
 if (y &lt; y0$2) y0$2 = y;
 if (y &gt; y1) y1 = y;
</PRE><P>}
</P><P>// TODO Enforce positive area for exterior, negative area for interior?
</P><P>var X0$1 = 0,
</P><PRE>   Y0$1 = 0,
   Z0$1 = 0,
   X1$1 = 0,
   Y1$1 = 0,
   Z1$1 = 0,
   X2$1 = 0,
   Y2$1 = 0,
   Z2$1 = 0,
   x00$1,
   y00$1,
   x0$3,
   y0$3;
</PRE><P>var centroidStream$1 = {
</P><PRE> point: centroidPoint$1,
 lineStart: centroidLineStart$1,
 lineEnd: centroidLineEnd$1,
 polygonStart: function() {
   centroidStream$1.lineStart = centroidRingStart$1;
   centroidStream$1.lineEnd = centroidRingEnd$1;
 },
 polygonEnd: function() {
   centroidStream$1.point = centroidPoint$1;
   centroidStream$1.lineStart = centroidLineStart$1;
   centroidStream$1.lineEnd = centroidLineEnd$1;
 },
 result: function() {
   var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
       : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
       : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
       : [NaN, NaN];
   X0$1 = Y0$1 = Z0$1 =
   X1$1 = Y1$1 = Z1$1 =
   X2$1 = Y2$1 = Z2$1 = 0;
   return centroid;
 }
</PRE><P>};
</P><P>function centroidPoint$1(x, y) {
</P><PRE> X0$1 += x;
 Y0$1 += y;
 ++Z0$1;
</PRE><P>}
</P><P>function centroidLineStart$1() {
</P><PRE> centroidStream$1.point = centroidPointFirstLine;
</PRE><P>}
</P><P>function centroidPointFirstLine(x, y) {
</P><PRE> centroidStream$1.point = centroidPointLine;
 centroidPoint$1(x0$3 = x, y0$3 = y);
</PRE><P>}
</P><P>function centroidPointLine(x, y) {
</P><PRE> var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
 X1$1 += z * (x0$3 + x) / 2;
 Y1$1 += z * (y0$3 + y) / 2;
 Z1$1 += z;
 centroidPoint$1(x0$3 = x, y0$3 = y);
</PRE><P>}
</P><P>function centroidLineEnd$1() {
</P><PRE> centroidStream$1.point = centroidPoint$1;
</PRE><P>}
</P><P>function centroidRingStart$1() {
</P><PRE> centroidStream$1.point = centroidPointFirstRing;
</PRE><P>}
</P><P>function centroidRingEnd$1() {
</P><PRE> centroidPointRing(x00$1, y00$1);
</PRE><P>}
</P><P>function centroidPointFirstRing(x, y) {
</P><PRE> centroidStream$1.point = centroidPointRing;
 centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
</PRE><P>}
</P><P>function centroidPointRing(x, y) {
</P><PRE> var dx = x - x0$3,
     dy = y - y0$3,
     z = sqrt(dx * dx + dy * dy);
</PRE><PRE> X1$1 += z * (x0$3 + x) / 2;
 Y1$1 += z * (y0$3 + y) / 2;
 Z1$1 += z;
</PRE><PRE> z = y0$3 * x - x0$3 * y;
 X2$1 += z * (x0$3 + x);
 Y2$1 += z * (y0$3 + y);
 Z2$1 += z * 3;
 centroidPoint$1(x0$3 = x, y0$3 = y);
</PRE><P>}
</P><P>function PathContext(context) {
</P><PRE> this._context = context;
</PRE><P>}
</P><P>PathContext.prototype = {
</P><PRE> _radius: 4.5,
 pointRadius: function(_) {
   return this._radius = _, this;
 },
 polygonStart: function() {
   this._line = 0;
 },
 polygonEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._point = 0;
 },
 lineEnd: function() {
   if (this._line === 0) this._context.closePath();
   this._point = NaN;
 },
 point: function(x, y) {
   switch (this._point) {
     case 0: {
       this._context.moveTo(x, y);
       this._point = 1;
       break;
     }
     case 1: {
       this._context.lineTo(x, y);
       break;
     }
     default: {
       this._context.moveTo(x + this._radius, y);
       this._context.arc(x, y, this._radius, 0, tau$3);
       break;
     }
   }
 },
 result: noop$2
</PRE><P>};
</P><P>var lengthSum$1 = adder(),
</P><PRE>   lengthRing,
   x00$2,
   y00$2,
   x0$4,
   y0$4;
</PRE><P>var lengthStream$1 = {
</P><PRE> point: noop$2,
 lineStart: function() {
   lengthStream$1.point = lengthPointFirst$1;
 },
 lineEnd: function() {
   if (lengthRing) lengthPoint$1(x00$2, y00$2);
   lengthStream$1.point = noop$2;
 },
 polygonStart: function() {
   lengthRing = true;
 },
 polygonEnd: function() {
   lengthRing = null;
 },
 result: function() {
   var length = +lengthSum$1;
   lengthSum$1.reset();
   return length;
 }
</PRE><P>};
</P><P>function lengthPointFirst$1(x, y) {
</P><PRE> lengthStream$1.point = lengthPoint$1;
 x00$2 = x0$4 = x, y00$2 = y0$4 = y;
</PRE><P>}
</P><P>function lengthPoint$1(x, y) {
</P><PRE> x0$4 -= x, y0$4 -= y;
 lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
 x0$4 = x, y0$4 = y;
</PRE><P>}
</P><P>function PathString() {
</P><PRE> this._string = [];
</PRE><P>}
</P><P>PathString.prototype = {
</P><PRE> _radius: 4.5,
 _circle: circle$1(4.5),
 pointRadius: function(_) {
   if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
   return this;
 },
 polygonStart: function() {
   this._line = 0;
 },
 polygonEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._point = 0;
 },
 lineEnd: function() {
   if (this._line === 0) this._string.push(&quot;Z&quot;);
   this._point = NaN;
 },
 point: function(x, y) {
   switch (this._point) {
     case 0: {
       this._string.push(&quot;M&quot;, x, &quot;,&quot;, y);
       this._point = 1;
       break;
     }
     case 1: {
       this._string.push(&quot;L&quot;, x, &quot;,&quot;, y);
       break;
     }
     default: {
       if (this._circle == null) this._circle = circle$1(this._radius);
       this._string.push(&quot;M&quot;, x, &quot;,&quot;, y, this._circle);
       break;
     }
   }
 },
 result: function() {
   if (this._string.length) {
     var result = this._string.join(&quot;&quot;);
     this._string = [];
     return result;
   } else {
     return null;
   }
 }
</PRE><P>};
</P><P>function circle$1(radius) {
</P><PRE> return &quot;m0,&quot; + radius
     + &quot;a&quot; + radius + &quot;,&quot; + radius + &quot; 0 1,1 0,&quot; + -2 * radius
     + &quot;a&quot; + radius + &quot;,&quot; + radius + &quot; 0 1,1 0,&quot; + 2 * radius
     + &quot;z&quot;;
</PRE><P>}
</P><P>function index$1(projection, context) {
</P><PRE> var pointRadius = 4.5,
     projectionStream,
     contextStream;
</PRE><PRE> function path(object) {
   if (object) {
     if (typeof pointRadius === &quot;function&quot;) contextStream.pointRadius(+pointRadius.apply(this, arguments));
     geoStream(object, projectionStream(contextStream));
   }
   return contextStream.result();
 }
</PRE><PRE> path.area = function(object) {
   geoStream(object, projectionStream(areaStream$1));
   return areaStream$1.result();
 };
</PRE><PRE> path.measure = function(object) {
   geoStream(object, projectionStream(lengthStream$1));
   return lengthStream$1.result();
 };
</PRE><PRE> path.bounds = function(object) {
   geoStream(object, projectionStream(boundsStream$1));
   return boundsStream$1.result();
 };
</PRE><PRE> path.centroid = function(object) {
   geoStream(object, projectionStream(centroidStream$1));
   return centroidStream$1.result();
 };
</PRE><PRE> path.projection = function(_) {
   return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;
 };
</PRE><PRE> path.context = function(_) {
   if (!arguments.length) return context;
   contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
   if (typeof pointRadius !== &quot;function&quot;) contextStream.pointRadius(pointRadius);
   return path;
 };
</PRE><PRE> path.pointRadius = function(_) {
   if (!arguments.length) return pointRadius;
   pointRadius = typeof _ === &quot;function&quot; ? _ : (contextStream.pointRadius(+_), +_);
   return path;
 };
</PRE><PRE> return path.projection(projection).context(context);
</PRE><P>}
</P><P>function transform(methods) {
</P><PRE> return {
   stream: transformer(methods)
 };
</PRE><P>}
</P><P>function transformer(methods) {
</P><PRE> return function(stream) {
   var s = new TransformStream;
   for (var key in methods) s[key] = methods[key];
   s.stream = stream;
   return s;
 };
</PRE><P>}
</P><P>function TransformStream() {}
</P><P>TransformStream.prototype = {
</P><PRE> constructor: TransformStream,
 point: function(x, y) { this.stream.point(x, y); },
 sphere: function() { this.stream.sphere(); },
 lineStart: function() { this.stream.lineStart(); },
 lineEnd: function() { this.stream.lineEnd(); },
 polygonStart: function() { this.stream.polygonStart(); },
 polygonEnd: function() { this.stream.polygonEnd(); }
</PRE><P>};
</P><P>function fit(projection, fitBounds, object) {
</P><PRE> var clip = projection.clipExtent &amp;&amp; projection.clipExtent();
 projection.scale(150).translate([0, 0]);
 if (clip != null) projection.clipExtent(null);
 geoStream(object, projection.stream(boundsStream$1));
 fitBounds(boundsStream$1.result());
 if (clip != null) projection.clipExtent(clip);
 return projection;
</PRE><P>}
</P><P>function fitExtent(projection, extent, object) {
</P><PRE> return fit(projection, function(b) {
   var w = extent[1][0] - extent[0][0],
       h = extent[1][1] - extent[0][1],
       k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
       x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
       y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
   projection.scale(150 * k).translate([x, y]);
 }, object);
</PRE><P>}
</P><P>function fitSize(projection, size, object) {
</P><PRE> return fitExtent(projection, [[0, 0], size], object);
</PRE><P>}
</P><P>function fitWidth(projection, width, object) {
</P><PRE> return fit(projection, function(b) {
   var w = +width,
       k = w / (b[1][0] - b[0][0]),
       x = (w - k * (b[1][0] + b[0][0])) / 2,
       y = -k * b[0][1];
   projection.scale(150 * k).translate([x, y]);
 }, object);
</PRE><P>}
</P><P>function fitHeight(projection, height, object) {
</P><PRE> return fit(projection, function(b) {
   var h = +height,
       k = h / (b[1][1] - b[0][1]),
       x = -k * b[0][0],
       y = (h - k * (b[1][1] + b[0][1])) / 2;
   projection.scale(150 * k).translate([x, y]);
 }, object);
</PRE><P>}
</P><P>var maxDepth = 16, // maximum depth of subdivision
</P><PRE>   cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)
</PRE><P>function resample(project, delta2) {
</P><PRE> return +delta2 ? resample$1(project, delta2) : resampleNone(project);
</PRE><P>}
</P><P>function resampleNone(project) {
</P><PRE> return transformer({
   point: function(x, y) {
     x = project(x, y);
     this.stream.point(x[0], x[1]);
   }
 });
</PRE><P>}
</P><P>function resample$1(project, delta2) {
</P><PRE> function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
   var dx = x1 - x0,
       dy = y1 - y0,
       d2 = dx * dx + dy * dy;
   if (d2 &gt; 4 * delta2 &amp;&amp; depth--) {
     var a = a0 + a1,
         b = b0 + b1,
         c = c0 + c1,
         m = sqrt(a * a + b * b + c * c),
         phi2 = asin(c /= m),
         lambda2 = abs(abs(c) - 1) &lt; epsilon$2 || abs(lambda0 - lambda1) &lt; epsilon$2 ? (lambda0 + lambda1) / 2 : atan2(b, a),
         p = project(lambda2, phi2),
         x2 = p[0],
         y2 = p[1],
         dx2 = x2 - x0,
         dy2 = y2 - y0,
         dz = dy * dx2 - dx * dy2;
     if (dz * dz / d2 &gt; delta2 // perpendicular projected distance
         || abs((dx * dx2 + dy * dy2) / d2 - 0.5) &gt; 0.3 // midpoint close to an end
         || a0 * a1 + b0 * b1 + c0 * c1 &lt; cosMinDistance) { // angular distance
       resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
       stream.point(x2, y2);
       resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
     }
   }
 }
 return function(stream) {
   var lambda00, x00, y00, a00, b00, c00, // first point
       lambda0, x0, y0, a0, b0, c0; // previous point
</PRE><PRE>   var resampleStream = {
     point: point,
     lineStart: lineStart,
     lineEnd: lineEnd,
     polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
     polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
   };
</PRE><PRE>   function point(x, y) {
     x = project(x, y);
     stream.point(x[0], x[1]);
   }
</PRE><PRE>   function lineStart() {
     x0 = NaN;
     resampleStream.point = linePoint;
     stream.lineStart();
   }
</PRE><PRE>   function linePoint(lambda, phi) {
     var c = cartesian([lambda, phi]), p = project(lambda, phi);
     resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
     stream.point(x0, y0);
   }
</PRE><PRE>   function lineEnd() {
     resampleStream.point = point;
     stream.lineEnd();
   }
</PRE><PRE>   function ringStart() {
     lineStart();
     resampleStream.point = ringPoint;
     resampleStream.lineEnd = ringEnd;
   }
</PRE><PRE>   function ringPoint(lambda, phi) {
     linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
     resampleStream.point = linePoint;
   }
</PRE><PRE>   function ringEnd() {
     resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
     resampleStream.lineEnd = lineEnd;
     lineEnd();
   }
</PRE><PRE>   return resampleStream;
 };
</PRE><P>}
</P><P>var transformRadians = transformer({
</P><PRE> point: function(x, y) {
   this.stream.point(x * radians, y * radians);
 }
</PRE><P>});
</P><P>function transformRotate(rotate) {
</P><PRE> return transformer({
   point: function(x, y) {
     var r = rotate(x, y);
     return this.stream.point(r[0], r[1]);
   }
 });
</PRE><P>}
</P><P>function scaleTranslate(k, dx, dy) {
</P><PRE> function transform$$1(x, y) {
   return [dx + k * x, dy - k * y];
 }
 transform$$1.invert = function(x, y) {
   return [(x - dx) / k, (dy - y) / k];
 };
 return transform$$1;
</PRE><P>}
</P><P>function scaleTranslateRotate(k, dx, dy, alpha) {
</P><PRE> var cosAlpha = cos$1(alpha),
     sinAlpha = sin$1(alpha),
     a = cosAlpha * k,
     b = sinAlpha * k,
     ai = cosAlpha / k,
     bi = sinAlpha / k,
     ci = (sinAlpha * dy - cosAlpha * dx) / k,
     fi = (sinAlpha * dx + cosAlpha * dy) / k;
 function transform$$1(x, y) {
   return [a * x - b * y + dx, dy - b * x - a * y];
 }
 transform$$1.invert = function(x, y) {
   return [ai * x - bi * y + ci, fi - bi * x - ai * y];
 };
 return transform$$1;
</PRE><P>}
</P><P>function projection(project) {
</P><PRE> return projectionMutator(function() { return project; })();
</PRE><P>}
</P><P>function projectionMutator(projectAt) {
</P><PRE> var project,
     k = 150, // scale
     x = 480, y = 250, // translate
     lambda = 0, phi = 0, // center
     deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
     alpha = 0, // post-rotate
     theta = null, preclip = clipAntimeridian, // pre-clip angle
     x0 = null, y0, x1, y1, postclip = identity$4, // post-clip extent
     delta2 = 0.5, // precision
     projectResample,
     projectTransform,
     projectRotateTransform,
     cache,
     cacheStream;
</PRE><PRE> function projection(point) {
   return projectRotateTransform(point[0] * radians, point[1] * radians);
 }
</PRE><PRE> function invert(point) {
   point = projectRotateTransform.invert(point[0], point[1]);
   return point &amp;&amp; [point[0] * degrees$1, point[1] * degrees$1];
 }
</PRE><PRE> projection.stream = function(stream) {
   return cache &amp;&amp; cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
 };
</PRE><PRE> projection.preclip = function(_) {
   return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
 };
</PRE><PRE> projection.postclip = function(_) {
   return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
 };
</PRE><PRE> projection.clipAngle = function(_) {
   return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;
 };
</PRE><PRE> projection.clipExtent = function(_) {
   return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
 };
</PRE><PRE> projection.scale = function(_) {
   return arguments.length ? (k = +_, recenter()) : k;
 };
</PRE><PRE> projection.translate = function(_) {
   return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
 };
</PRE><PRE> projection.center = function(_) {
   return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];
 };
</PRE><PRE> projection.rotate = function(_) {
   return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length &gt; 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
 };
</PRE><PRE> projection.angle = function(_) {
   return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees$1;
 };
</PRE><PRE> projection.precision = function(_) {
   return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
 };
</PRE><PRE> projection.fitExtent = function(extent, object) {
   return fitExtent(projection, extent, object);
 };
</PRE><PRE> projection.fitSize = function(size, object) {
   return fitSize(projection, size, object);
 };
</PRE><PRE> projection.fitWidth = function(width, object) {
   return fitWidth(projection, width, object);
 };
</PRE><PRE> projection.fitHeight = function(height, object) {
   return fitHeight(projection, height, object);
 };
</PRE><PRE> function recenter() {
   var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
       transform$$1 = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
   rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
   projectTransform = compose(project, transform$$1);
   projectRotateTransform = compose(rotate, projectTransform);
   projectResample = resample(projectTransform, delta2);
   return reset();
 }
</PRE><PRE> function reset() {
   cache = cacheStream = null;
   return projection;
 }
</PRE><PRE> return function() {
   project = projectAt.apply(this, arguments);
   projection.invert = project.invert &amp;&amp; invert;
   return recenter();
 };
</PRE><P>}
</P><P>function conicProjection(projectAt) {
</P><PRE> var phi0 = 0,
     phi1 = pi$3 / 3,
     m = projectionMutator(projectAt),
     p = m(phi0, phi1);
</PRE><PRE> p.parallels = function(_) {
   return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];
 };
</PRE><PRE> return p;
</PRE><P>}
</P><P>function cylindricalEqualAreaRaw(phi0) {
</P><PRE> var cosPhi0 = cos$1(phi0);
</PRE><PRE> function forward(lambda, phi) {
   return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
 }
</PRE><PRE> forward.invert = function(x, y) {
   return [x / cosPhi0, asin(y * cosPhi0)];
 };
</PRE><PRE> return forward;
</PRE><P>}
</P><P>function conicEqualAreaRaw(y0, y1) {
</P><PRE> var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;
</PRE><PRE> // Are the parallels symmetrical around the Equator?
 if (abs(n) &lt; epsilon$2) return cylindricalEqualAreaRaw(y0);
</PRE><PRE> var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;
</PRE><PRE> function project(x, y) {
   var r = sqrt(c - 2 * n * sin$1(y)) / n;
   return [r * sin$1(x *= n), r0 - r * cos$1(x)];
 }
</PRE><PRE> project.invert = function(x, y) {
   var r0y = r0 - y;
   return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
 };
</PRE><PRE> return project;
</PRE><P>}
</P><P>function conicEqualArea() {
</P><PRE> return conicProjection(conicEqualAreaRaw)
     .scale(155.424)
     .center([0, 33.6442]);
</PRE><P>}
</P><P>function albers() {
</P><PRE> return conicEqualArea()
     .parallels([29.5, 45.5])
     .scale(1070)
     .translate([480, 250])
     .rotate([96, 0])
     .center([-0.6, 38.7]);
</PRE><P>}
</P><P>// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
</P><PRE> var n = streams.length;
 return {
   point: function(x, y) { var i = -1; while (++i &lt; n) streams[i].point(x, y); },
   sphere: function() { var i = -1; while (++i &lt; n) streams[i].sphere(); },
   lineStart: function() { var i = -1; while (++i &lt; n) streams[i].lineStart(); },
   lineEnd: function() { var i = -1; while (++i &lt; n) streams[i].lineEnd(); },
   polygonStart: function() { var i = -1; while (++i &lt; n) streams[i].polygonStart(); },
   polygonEnd: function() { var i = -1; while (++i &lt; n) streams[i].polygonEnd(); }
 };
</PRE><P>}
</P><P>// A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// <A rel="nofollow" class="external free" href="http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers">http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers</A>
function albersUsa() {
</P><PRE> var cache,
     cacheStream,
     lower48 = albers(), lower48Point,
     alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
     hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
     point, pointStream = {point: function(x, y) { point = [x, y]; }};
</PRE><PRE> function albersUsa(coordinates) {
   var x = coordinates[0], y = coordinates[1];
   return point = null,
       (lower48Point.point(x, y), point)
       || (alaskaPoint.point(x, y), point)
       || (hawaiiPoint.point(x, y), point);
 }
</PRE><PRE> albersUsa.invert = function(coordinates) {
   var k = lower48.scale(),
       t = lower48.translate(),
       x = (coordinates[0] - t[0]) / k,
       y = (coordinates[1] - t[1]) / k;
   return (y &gt;= 0.120 &amp;&amp; y &lt; 0.234 &amp;&amp; x &gt;= -0.425 &amp;&amp; x &lt; -0.214 ? alaska
       : y &gt;= 0.166 &amp;&amp; y &lt; 0.234 &amp;&amp; x &gt;= -0.214 &amp;&amp; x &lt; -0.115 ? hawaii
       : lower48).invert(coordinates);
 };
</PRE><PRE> albersUsa.stream = function(stream) {
   return cache &amp;&amp; cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
 };
</PRE><PRE> albersUsa.precision = function(_) {
   if (!arguments.length) return lower48.precision();
   lower48.precision(_), alaska.precision(_), hawaii.precision(_);
   return reset();
 };
</PRE><PRE> albersUsa.scale = function(_) {
   if (!arguments.length) return lower48.scale();
   lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
   return albersUsa.translate(lower48.translate());
 };
</PRE><PRE> albersUsa.translate = function(_) {
   if (!arguments.length) return lower48.translate();
   var k = lower48.scale(), x = +_[0], y = +_[1];
</PRE><PRE>   lower48Point = lower48
       .translate(_)
       .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
       .stream(pointStream);
</PRE><PRE>   alaskaPoint = alaska
       .translate([x - 0.307 * k, y + 0.201 * k])
       .clipExtent([[x - 0.425 * k + epsilon$2, y + 0.120 * k + epsilon$2], [x - 0.214 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
       .stream(pointStream);
</PRE><PRE>   hawaiiPoint = hawaii
       .translate([x - 0.205 * k, y + 0.212 * k])
       .clipExtent([[x - 0.214 * k + epsilon$2, y + 0.166 * k + epsilon$2], [x - 0.115 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
       .stream(pointStream);
</PRE><PRE>   return reset();
 };
</PRE><PRE> albersUsa.fitExtent = function(extent, object) {
   return fitExtent(albersUsa, extent, object);
 };
</PRE><PRE> albersUsa.fitSize = function(size, object) {
   return fitSize(albersUsa, size, object);
 };
</PRE><PRE> albersUsa.fitWidth = function(width, object) {
   return fitWidth(albersUsa, width, object);
 };
</PRE><PRE> albersUsa.fitHeight = function(height, object) {
   return fitHeight(albersUsa, height, object);
 };
</PRE><PRE> function reset() {
   cache = cacheStream = null;
   return albersUsa;
 }
</PRE><PRE> return albersUsa.scale(1070);
</PRE><P>}
</P><P>function azimuthalRaw(scale) {
</P><PRE> return function(x, y) {
   var cx = cos$1(x),
       cy = cos$1(y),
       k = scale(cx * cy);
   return [
     k * cy * sin$1(x),
     k * sin$1(y)
   ];
 }
</PRE><P>}
</P><P>function azimuthalInvert(angle) {
</P><PRE> return function(x, y) {
   var z = sqrt(x * x + y * y),
       c = angle(z),
       sc = sin$1(c),
       cc = cos$1(c);
   return [
     atan2(x * sc, z * cc),
     asin(z &amp;&amp; y * sc / z)
   ];
 }
</PRE><P>}
</P><P>var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
</P><PRE> return sqrt(2 / (1 + cxcy));
</PRE><P>});
</P><P>azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
</P><PRE> return 2 * asin(z / 2);
</PRE><P>});
</P><P>function azimuthalEqualArea() {
</P><PRE> return projection(azimuthalEqualAreaRaw)
     .scale(124.75)
     .clipAngle(180 - 1e-3);
</PRE><P>}
</P><P>var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
</P><PRE> return (c = acos(c)) &amp;&amp; c / sin$1(c);
</PRE><P>});
</P><P>azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
</P><PRE> return z;
</PRE><P>});
</P><P>function azimuthalEquidistant() {
</P><PRE> return projection(azimuthalEquidistantRaw)
     .scale(79.4188)
     .clipAngle(180 - 1e-3);
</PRE><P>}
</P><P>function mercatorRaw(lambda, phi) {
</P><PRE> return [lambda, log(tan((halfPi$2 + phi) / 2))];
</PRE><P>}
</P><P>mercatorRaw.invert = function(x, y) {
</P><PRE> return [x, 2 * atan(exp(y)) - halfPi$2];
</PRE><P>};
</P><P>function mercator() {
</P><PRE> return mercatorProjection(mercatorRaw)
     .scale(961 / tau$3);
</PRE><P>}
</P><P>function mercatorProjection(project) {
</P><PRE> var m = projection(project),
     center = m.center,
     scale = m.scale,
     translate = m.translate,
     clipExtent = m.clipExtent,
     x0 = null, y0, x1, y1; // clip extent
</PRE><PRE> m.scale = function(_) {
   return arguments.length ? (scale(_), reclip()) : scale();
 };
</PRE><PRE> m.translate = function(_) {
   return arguments.length ? (translate(_), reclip()) : translate();
 };
</PRE><PRE> m.center = function(_) {
   return arguments.length ? (center(_), reclip()) : center();
 };
</PRE><PRE> m.clipExtent = function(_) {
   return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
 };
</PRE><PRE> function reclip() {
   var k = pi$3 * scale(),
       t = m(rotation(m.rotate()).invert([0, 0]));
   return clipExtent(x0 == null
       ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
       ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
       : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
 }
</PRE><PRE> return reclip();
</PRE><P>}
</P><P>function tany(y) {
</P><PRE> return tan((halfPi$2 + y) / 2);
</PRE><P>}
</P><P>function conicConformalRaw(y0, y1) {
</P><PRE> var cy0 = cos$1(y0),
     n = y0 === y1 ? sin$1(y0) : log(cy0 / cos$1(y1)) / log(tany(y1) / tany(y0)),
     f = cy0 * pow(tany(y0), n) / n;
</PRE><PRE> if (!n) return mercatorRaw;
</PRE><PRE> function project(x, y) {
   if (f &gt; 0) { if (y &lt; -halfPi$2 + epsilon$2) y = -halfPi$2 + epsilon$2; }
   else { if (y &gt; halfPi$2 - epsilon$2) y = halfPi$2 - epsilon$2; }
   var r = f / pow(tany(y), n);
   return [r * sin$1(n * x), f - r * cos$1(n * x)];
 }
</PRE><PRE> project.invert = function(x, y) {
   var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
   return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi$2];
 };
</PRE><PRE> return project;
</PRE><P>}
</P><P>function conicConformal() {
</P><PRE> return conicProjection(conicConformalRaw)
     .scale(109.5)
     .parallels([30, 30]);
</PRE><P>}
</P><P>function equirectangularRaw(lambda, phi) {
</P><PRE> return [lambda, phi];
</PRE><P>}
</P><P>equirectangularRaw.invert = equirectangularRaw;
</P><P>function equirectangular() {
</P><PRE> return projection(equirectangularRaw)
     .scale(152.63);
</PRE><P>}
</P><P>function conicEquidistantRaw(y0, y1) {
</P><PRE> var cy0 = cos$1(y0),
     n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
     g = cy0 / n + y0;
</PRE><PRE> if (abs(n) &lt; epsilon$2) return equirectangularRaw;
</PRE><PRE> function project(x, y) {
   var gy = g - y, nx = n * x;
   return [gy * sin$1(nx), g - gy * cos$1(nx)];
 }
</PRE><PRE> project.invert = function(x, y) {
   var gy = g - y;
   return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
 };
</PRE><PRE> return project;
</PRE><P>}
</P><P>function conicEquidistant() {
</P><PRE> return conicProjection(conicEquidistantRaw)
     .scale(131.154)
     .center([0, 13.9389]);
</PRE><P>}
</P><P>var A1 = 1.340264,
</P><PRE>   A2 = -0.081106,
   A3 = 0.000893,
   A4 = 0.003796,
   M = sqrt(3) / 2,
   iterations = 12;
</PRE><P>function equalEarthRaw(lambda, phi) {
</P><PRE> var l = asin(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
 return [
   lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
   l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
 ];
</PRE><P>}
</P><P>equalEarthRaw.invert = function(x, y) {
</P><PRE> var l = y, l2 = l * l, l6 = l2 * l2 * l2;
 for (var i = 0, delta, fy, fpy; i &lt; iterations; ++i) {
   fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
   fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
   l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
   if (abs(delta) &lt; epsilon2$1) break;
 }
 return [
   M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
   asin(sin$1(l) / M)
 ];
</PRE><P>};
</P><P>function equalEarth() {
</P><PRE> return projection(equalEarthRaw)
     .scale(177.158);
</PRE><P>}
</P><P>function gnomonicRaw(x, y) {
</P><PRE> var cy = cos$1(y), k = cos$1(x) * cy;
 return [cy * sin$1(x) / k, sin$1(y) / k];
</PRE><P>}
</P><P>gnomonicRaw.invert = azimuthalInvert(atan);
</P><P>function gnomonic() {
</P><PRE> return projection(gnomonicRaw)
     .scale(144.049)
     .clipAngle(60);
</PRE><P>}
</P><P>function scaleTranslate$1(kx, ky, tx, ty) {
</P><PRE> return kx === 1 &amp;&amp; ky === 1 &amp;&amp; tx === 0 &amp;&amp; ty === 0 ? identity$4 : transformer({
   point: function(x, y) {
     this.stream.point(x * kx + tx, y * ky + ty);
   }
 });
</PRE><P>}
</P><P>function identity$5() {
</P><PRE> var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity$4, // scale, translate and reflect
     x0 = null, y0, x1, y1, // clip extent
     postclip = identity$4,
     cache,
     cacheStream,
     projection;
</PRE><PRE> function reset() {
   cache = cacheStream = null;
   return projection;
 }
</PRE><PRE> return projection = {
   stream: function(stream) {
     return cache &amp;&amp; cacheStream === stream ? cache : cache = transform$$1(postclip(cacheStream = stream));
   },
   postclip: function(_) {
     return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
   },
   clipExtent: function(_) {
     return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
   },
   scale: function(_) {
     return arguments.length ? (transform$$1 = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;
   },
   translate: function(_) {
     return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
   },
   reflectX: function(_) {
     return arguments.length ? (transform$$1 = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx &lt; 0;
   },
   reflectY: function(_) {
     return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy &lt; 0;
   },
   fitExtent: function(extent, object) {
     return fitExtent(projection, extent, object);
   },
   fitSize: function(size, object) {
     return fitSize(projection, size, object);
   },
   fitWidth: function(width, object) {
     return fitWidth(projection, width, object);
   },
   fitHeight: function(height, object) {
     return fitHeight(projection, height, object);
   }
 };
</PRE><P>}
</P><P>function naturalEarth1Raw(lambda, phi) {
</P><PRE> var phi2 = phi * phi, phi4 = phi2 * phi2;
 return [
   lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
   phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
 ];
</PRE><P>}
</P><P>naturalEarth1Raw.invert = function(x, y) {
</P><PRE> var phi = y, i = 25, delta;
 do {
   var phi2 = phi * phi, phi4 = phi2 * phi2;
   phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
       (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
 } while (abs(delta) &gt; epsilon$2 &amp;&amp; --i &gt; 0);
 return [
   x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
   phi
 ];
</PRE><P>};
</P><P>function naturalEarth1() {
</P><PRE> return projection(naturalEarth1Raw)
     .scale(175.295);
</PRE><P>}
</P><P>function orthographicRaw(x, y) {
</P><PRE> return [cos$1(y) * sin$1(x), sin$1(y)];
</PRE><P>}
</P><P>orthographicRaw.invert = azimuthalInvert(asin);
</P><P>function orthographic() {
</P><PRE> return projection(orthographicRaw)
     .scale(249.5)
     .clipAngle(90 + epsilon$2);
</PRE><P>}
</P><P>function stereographicRaw(x, y) {
</P><PRE> var cy = cos$1(y), k = 1 + cos$1(x) * cy;
 return [cy * sin$1(x) / k, sin$1(y) / k];
</PRE><P>}
</P><P>stereographicRaw.invert = azimuthalInvert(function(z) {
</P><PRE> return 2 * atan(z);
</PRE><P>});
</P><P>function stereographic() {
</P><PRE> return projection(stereographicRaw)
     .scale(250)
     .clipAngle(142);
</PRE><P>}
</P><P>function transverseMercatorRaw(lambda, phi) {
</P><PRE> return [log(tan((halfPi$2 + phi) / 2)), -lambda];
</PRE><P>}
</P><P>transverseMercatorRaw.invert = function(x, y) {
</P><PRE> return [-y, 2 * atan(exp(x)) - halfPi$2];
</PRE><P>};
</P><P>function transverseMercator() {
</P><PRE> var m = mercatorProjection(transverseMercatorRaw),
     center = m.center,
     rotate = m.rotate;
</PRE><PRE> m.center = function(_) {
   return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
 };
</PRE><PRE> m.rotate = function(_) {
   return arguments.length ? rotate([_[0], _[1], _.length &gt; 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
 };
</PRE><PRE> return rotate([0, 0, 90])
     .scale(159.155);
</PRE><P>}
</P><P>function defaultSeparation(a, b) {
</P><PRE> return a.parent === b.parent ? 1 : 2;
</PRE><P>}
</P><P>function meanX(children) {
</P><PRE> return children.reduce(meanXReduce, 0) / children.length;
</PRE><P>}
</P><P>function meanXReduce(x, c) {
</P><PRE> return x + c.x;
</PRE><P>}
</P><P>function maxY(children) {
</P><PRE> return 1 + children.reduce(maxYReduce, 0);
</PRE><P>}
</P><P>function maxYReduce(y, c) {
</P><PRE> return Math.max(y, c.y);
</PRE><P>}
</P><P>function leafLeft(node) {
</P><PRE> var children;
 while (children = node.children) node = children[0];
 return node;
</PRE><P>}
</P><P>function leafRight(node) {
</P><PRE> var children;
 while (children = node.children) node = children[children.length - 1];
 return node;
</PRE><P>}
</P><P>function cluster() {
</P><PRE> var separation = defaultSeparation,
     dx = 1,
     dy = 1,
     nodeSize = false;
</PRE><PRE> function cluster(root) {
   var previousNode,
       x = 0;
</PRE><PRE>   // First walk, computing the initial x &amp; y values.
   root.eachAfter(function(node) {
     var children = node.children;
     if (children) {
       node.x = meanX(children);
       node.y = maxY(children);
     } else {
       node.x = previousNode ? x += separation(node, previousNode) : 0;
       node.y = 0;
       previousNode = node;
     }
   });
</PRE><PRE>   var left = leafLeft(root),
       right = leafRight(root),
       x0 = left.x - separation(left, right) / 2,
       x1 = right.x + separation(right, left) / 2;
</PRE><PRE>   // Second walk, normalizing x &amp; y to the desired size.
   return root.eachAfter(nodeSize ? function(node) {
     node.x = (node.x - root.x) * dx;
     node.y = (root.y - node.y) * dy;
   } : function(node) {
     node.x = (node.x - x0) / (x1 - x0) * dx;
     node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
   });
 }
</PRE><PRE> cluster.separation = function(x) {
   return arguments.length ? (separation = x, cluster) : separation;
 };
</PRE><PRE> cluster.size = function(x) {
   return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
 };
</PRE><PRE> cluster.nodeSize = function(x) {
   return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
 };
</PRE><PRE> return cluster;
</PRE><P>}
</P><P>function count(node) {
</P><PRE> var sum = 0,
     children = node.children,
     i = children &amp;&amp; children.length;
 if (!i) sum = 1;
 else while (--i &gt;= 0) sum += children[i].value;
 node.value = sum;
</PRE><P>}
</P><P>function node_count() {
</P><PRE> return this.eachAfter(count);
</PRE><P>}
</P><P>function node_each(callback) {
</P><PRE> var node = this, current, next = [node], children, i, n;
 do {
   current = next.reverse(), next = [];
   while (node = current.pop()) {
     callback(node), children = node.children;
     if (children) for (i = 0, n = children.length; i &lt; n; ++i) {
       next.push(children[i]);
     }
   }
 } while (next.length);
 return this;
</PRE><P>}
</P><P>function node_eachBefore(callback) {
</P><PRE> var node = this, nodes = [node], children, i;
 while (node = nodes.pop()) {
   callback(node), children = node.children;
   if (children) for (i = children.length - 1; i &gt;= 0; --i) {
     nodes.push(children[i]);
   }
 }
 return this;
</PRE><P>}
</P><P>function node_eachAfter(callback) {
</P><PRE> var node = this, nodes = [node], next = [], children, i, n;
 while (node = nodes.pop()) {
   next.push(node), children = node.children;
   if (children) for (i = 0, n = children.length; i &lt; n; ++i) {
     nodes.push(children[i]);
   }
 }
 while (node = next.pop()) {
   callback(node);
 }
 return this;
</PRE><P>}
</P><P>function node_sum(value) {
</P><PRE> return this.eachAfter(function(node) {
   var sum = +value(node.data) || 0,
       children = node.children,
       i = children &amp;&amp; children.length;
   while (--i &gt;= 0) sum += children[i].value;
   node.value = sum;
 });
</PRE><P>}
</P><P>function node_sort(compare) {
</P><PRE> return this.eachBefore(function(node) {
   if (node.children) {
     node.children.sort(compare);
   }
 });
</PRE><P>}
</P><P>function node_path(end) {
</P><PRE> var start = this,
     ancestor = leastCommonAncestor(start, end),
     nodes = [start];
 while (start !== ancestor) {
   start = start.parent;
   nodes.push(start);
 }
 var k = nodes.length;
 while (end !== ancestor) {
   nodes.splice(k, 0, end);
   end = end.parent;
 }
 return nodes;
</PRE><P>}
</P><P>function leastCommonAncestor(a, b) {
</P><PRE> if (a === b) return a;
 var aNodes = a.ancestors(),
     bNodes = b.ancestors(),
     c = null;
 a = aNodes.pop();
 b = bNodes.pop();
 while (a === b) {
   c = a;
   a = aNodes.pop();
   b = bNodes.pop();
 }
 return c;
</PRE><P>}
</P><P>function node_ancestors() {
</P><PRE> var node = this, nodes = [node];
 while (node = node.parent) {
   nodes.push(node);
 }
 return nodes;
</PRE><P>}
</P><P>function node_descendants() {
</P><PRE> var nodes = [];
 this.each(function(node) {
   nodes.push(node);
 });
 return nodes;
</PRE><P>}
</P><P>function node_leaves() {
</P><PRE> var leaves = [];
 this.eachBefore(function(node) {
   if (!node.children) {
     leaves.push(node);
   }
 });
 return leaves;
</PRE><P>}
</P><P>function node_links() {
</P><PRE> var root = this, links = [];
 root.each(function(node) {
   if (node !== root) { // Don’t include the root’s parent, if any.
     links.push({source: node.parent, target: node});
   }
 });
 return links;
</PRE><P>}
</P><P>function hierarchy(data, children) {
</P><PRE> var root = new Node(data),
     valued = +data.value &amp;&amp; (root.value = data.value),
     node,
     nodes = [root],
     child,
     childs,
     i,
     n;
</PRE><PRE> if (children == null) children = defaultChildren;
</PRE><PRE> while (node = nodes.pop()) {
   if (valued) node.value = +node.data.value;
   if ((childs = children(node.data)) &amp;&amp; (n = childs.length)) {
     node.children = new Array(n);
     for (i = n - 1; i &gt;= 0; --i) {
       nodes.push(child = node.children[i] = new Node(childs[i]));
       child.parent = node;
       child.depth = node.depth + 1;
     }
   }
 }
</PRE><PRE> return root.eachBefore(computeHeight);
</PRE><P>}
</P><P>function node_copy() {
</P><PRE> return hierarchy(this).eachBefore(copyData);
</PRE><P>}
</P><P>function defaultChildren(d) {
</P><PRE> return d.children;
</PRE><P>}
</P><P>function copyData(node) {
</P><PRE> node.data = node.data.data;
</PRE><P>}
</P><P>function computeHeight(node) {
</P><PRE> var height = 0;
 do node.height = height;
 while ((node = node.parent) &amp;&amp; (node.height &lt; ++height));
</PRE><P>}
</P><P>function Node(data) {
</P><PRE> this.data = data;
 this.depth =
 this.height = 0;
 this.parent = null;
</PRE><P>}
</P><P>Node.prototype = hierarchy.prototype = {
</P><PRE> constructor: Node,
 count: node_count,
 each: node_each,
 eachAfter: node_eachAfter,
 eachBefore: node_eachBefore,
 sum: node_sum,
 sort: node_sort,
 path: node_path,
 ancestors: node_ancestors,
 descendants: node_descendants,
 leaves: node_leaves,
 links: node_links,
 copy: node_copy
</PRE><P>};
</P><P>var slice$4 = Array.prototype.slice;
</P><P>function shuffle$1(array) {
</P><PRE> var m = array.length,
     t,
     i;
</PRE><PRE> while (m) {
   i = Math.random() * m-- | 0;
   t = array[m];
   array[m] = array[i];
   array[i] = t;
 }
</PRE><PRE> return array;
</PRE><P>}
</P><P>function enclose(circles) {
</P><PRE> var i = 0, n = (circles = shuffle$1(slice$4.call(circles))).length, B = [], p, e;
</PRE><PRE> while (i &lt; n) {
   p = circles[i];
   if (e &amp;&amp; enclosesWeak(e, p)) ++i;
   else e = encloseBasis(B = extendBasis(B, p)), i = 0;
 }
</PRE><PRE> return e;
</PRE><P>}
</P><P>function extendBasis(B, p) {
</P><PRE> var i, j;
</PRE><PRE> if (enclosesWeakAll(p, B)) return [p];
</PRE><PRE> // If we get here then B must have at least one element.
 for (i = 0; i &lt; B.length; ++i) {
   if (enclosesNot(p, B[i])
       &amp;&amp; enclosesWeakAll(encloseBasis2(B[i], p), B)) {
     return [B[i], p];
   }
 }
</PRE><PRE> // If we get here then B must have at least two elements.
 for (i = 0; i &lt; B.length - 1; ++i) {
   for (j = i + 1; j &lt; B.length; ++j) {
     if (enclosesNot(encloseBasis2(B[i], B[j]), p)
         &amp;&amp; enclosesNot(encloseBasis2(B[i], p), B[j])
         &amp;&amp; enclosesNot(encloseBasis2(B[j], p), B[i])
         &amp;&amp; enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
       return [B[i], B[j], p];
     }
   }
 }
</PRE><PRE> // If we get here then something is very wrong.
 throw new Error;
</PRE><P>}
</P><P>function enclosesNot(a, b) {
</P><PRE> var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
 return dr &lt; 0 || dr * dr &lt; dx * dx + dy * dy;
</PRE><P>}
</P><P>function enclosesWeak(a, b) {
</P><PRE> var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
 return dr &gt; 0 &amp;&amp; dr * dr &gt; dx * dx + dy * dy;
</PRE><P>}
</P><P>function enclosesWeakAll(a, B) {
</P><PRE> for (var i = 0; i &lt; B.length; ++i) {
   if (!enclosesWeak(a, B[i])) {
     return false;
   }
 }
 return true;
</PRE><P>}
</P><P>function encloseBasis(B) {
</P><PRE> switch (B.length) {
   case 1: return encloseBasis1(B[0]);
   case 2: return encloseBasis2(B[0], B[1]);
   case 3: return encloseBasis3(B[0], B[1], B[2]);
 }
</PRE><P>}
</P><P>function encloseBasis1(a) {
</P><PRE> return {
   x: a.x,
   y: a.y,
   r: a.r
 };
</PRE><P>}
</P><P>function encloseBasis2(a, b) {
</P><PRE> var x1 = a.x, y1 = a.y, r1 = a.r,
     x2 = b.x, y2 = b.y, r2 = b.r,
     x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
     l = Math.sqrt(x21 * x21 + y21 * y21);
 return {
   x: (x1 + x2 + x21 / l * r21) / 2,
   y: (y1 + y2 + y21 / l * r21) / 2,
   r: (l + r1 + r2) / 2
 };
</PRE><P>}
</P><P>function encloseBasis3(a, b, c) {
</P><PRE> var x1 = a.x, y1 = a.y, r1 = a.r,
     x2 = b.x, y2 = b.y, r2 = b.r,
     x3 = c.x, y3 = c.y, r3 = c.r,
     a2 = x1 - x2,
     a3 = x1 - x3,
     b2 = y1 - y2,
     b3 = y1 - y3,
     c2 = r2 - r1,
     c3 = r3 - r1,
     d1 = x1 * x1 + y1 * y1 - r1 * r1,
     d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
     d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
     ab = a3 * b2 - a2 * b3,
     xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
     xb = (b3 * c2 - b2 * c3) / ab,
     ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
     yb = (a2 * c3 - a3 * c2) / ab,
     A = xb * xb + yb * yb - 1,
     B = 2 * (r1 + xa * xb + ya * yb),
     C = xa * xa + ya * ya - r1 * r1,
     r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
 return {
   x: x1 + xa + xb * r,
   y: y1 + ya + yb * r,
   r: r
 };
</PRE><P>}
</P><P>function place(b, a, c) {
</P><PRE> var dx = b.x - a.x, x, a2,
     dy = b.y - a.y, y, b2,
     d2 = dx * dx + dy * dy;
 if (d2) {
   a2 = a.r + c.r, a2 *= a2;
   b2 = b.r + c.r, b2 *= b2;
   if (a2 &gt; b2) {
     x = (d2 + b2 - a2) / (2 * d2);
     y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
     c.x = b.x - x * dx - y * dy;
     c.y = b.y - x * dy + y * dx;
   } else {
     x = (d2 + a2 - b2) / (2 * d2);
     y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
     c.x = a.x + x * dx - y * dy;
     c.y = a.y + x * dy + y * dx;
   }
 } else {
   c.x = a.x + c.r;
   c.y = a.y;
 }
</PRE><P>}
</P><P>function intersects(a, b) {
</P><PRE> var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
 return dr &gt; 0 &amp;&amp; dr * dr &gt; dx * dx + dy * dy;
</PRE><P>}
</P><P>function score(node) {
</P><PRE> var a = node._,
     b = node.next._,
     ab = a.r + b.r,
     dx = (a.x * b.r + b.x * a.r) / ab,
     dy = (a.y * b.r + b.y * a.r) / ab;
 return dx * dx + dy * dy;
</PRE><P>}
</P><P>function Node$1(circle) {
</P><PRE> this._ = circle;
 this.next = null;
 this.previous = null;
</PRE><P>}
</P><P>function packEnclose(circles) {
</P><PRE> if (!(n = circles.length)) return 0;
</PRE><PRE> var a, b, c, n, aa, ca, i, j, k, sj, sk;
</PRE><PRE> // Place the first circle.
 a = circles[0], a.x = 0, a.y = 0;
 if (!(n &gt; 1)) return a.r;
</PRE><PRE> // Place the second circle.
 b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
 if (!(n &gt; 2)) return a.r + b.r;
</PRE><PRE> // Place the third circle.
 place(b, a, c = circles[2]);
</PRE><PRE> // Initialize the front-chain using the first three circles a, b and c.
 a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
 a.next = c.previous = b;
 b.next = a.previous = c;
 c.next = b.previous = a;
</PRE><PRE> // Attempt to place each remaining circle…
 pack: for (i = 3; i &lt; n; ++i) {
   place(a._, b._, c = circles[i]), c = new Node$1(c);
</PRE><PRE>   // Find the closest intersecting circle on the front-chain, if any.
   // “Closeness” is determined by linear distance along the front-chain.
   // “Ahead” or “behind” is likewise determined by linear distance.
   j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
   do {
     if (sj &lt;= sk) {
       if (intersects(j._, c._)) {
         b = j, a.next = b, b.previous = a, --i;
         continue pack;
       }
       sj += j._.r, j = j.next;
     } else {
       if (intersects(k._, c._)) {
         a = k, a.next = b, b.previous = a, --i;
         continue pack;
       }
       sk += k._.r, k = k.previous;
     }
   } while (j !== k.next);
</PRE><PRE>   // Success! Insert the new circle c between a and b.
   c.previous = a, c.next = b, a.next = b.previous = b = c;
</PRE><PRE>   // Compute the new closest circle pair to the centroid.
   aa = score(a);
   while ((c = c.next) !== b) {
     if ((ca = score(c)) &lt; aa) {
       a = c, aa = ca;
     }
   }
   b = a.next;
 }
</PRE><PRE> // Compute the enclosing circle of the front chain.
 a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);
</PRE><PRE> // Translate the circles to put the enclosing circle around the origin.
 for (i = 0; i &lt; n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;
</PRE><PRE> return c.r;
</PRE><P>}
</P><P>function siblings(circles) {
</P><PRE> packEnclose(circles);
 return circles;
</PRE><P>}
</P><P>function optional(f) {
</P><PRE> return f == null ? null : required(f);
</PRE><P>}
</P><P>function required(f) {
</P><PRE> if (typeof f !== &quot;function&quot;) throw new Error;
 return f;
</PRE><P>}
</P><P>function constantZero() {
</P><PRE> return 0;
</PRE><P>}
</P><P>function constant$9(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function defaultRadius$1(d) {
</P><PRE> return Math.sqrt(d.value);
</PRE><P>}
</P><P>function index$2() {
</P><PRE> var radius = null,
     dx = 1,
     dy = 1,
     padding = constantZero;
</PRE><PRE> function pack(root) {
   root.x = dx / 2, root.y = dy / 2;
   if (radius) {
     root.eachBefore(radiusLeaf(radius))
         .eachAfter(packChildren(padding, 0.5))
         .eachBefore(translateChild(1));
   } else {
     root.eachBefore(radiusLeaf(defaultRadius$1))
         .eachAfter(packChildren(constantZero, 1))
         .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
         .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
   }
   return root;
 }
</PRE><PRE> pack.radius = function(x) {
   return arguments.length ? (radius = optional(x), pack) : radius;
 };
</PRE><PRE> pack.size = function(x) {
   return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
 };
</PRE><PRE> pack.padding = function(x) {
   return arguments.length ? (padding = typeof x === &quot;function&quot; ? x : constant$9(+x), pack) : padding;
 };
</PRE><PRE> return pack;
</PRE><P>}
</P><P>function radiusLeaf(radius) {
</P><PRE> return function(node) {
   if (!node.children) {
     node.r = Math.max(0, +radius(node) || 0);
   }
 };
</PRE><P>}
</P><P>function packChildren(padding, k) {
</P><PRE> return function(node) {
   if (children = node.children) {
     var children,
         i,
         n = children.length,
         r = padding(node) * k || 0,
         e;
</PRE><PRE>     if (r) for (i = 0; i &lt; n; ++i) children[i].r += r;
     e = packEnclose(children);
     if (r) for (i = 0; i &lt; n; ++i) children[i].r -= r;
     node.r = e + r;
   }
 };
</PRE><P>}
</P><P>function translateChild(k) {
</P><PRE> return function(node) {
   var parent = node.parent;
   node.r *= k;
   if (parent) {
     node.x = parent.x + k * node.x;
     node.y = parent.y + k * node.y;
   }
 };
</PRE><P>}
</P><P>function roundNode(node) {
</P><PRE> node.x0 = Math.round(node.x0);
 node.y0 = Math.round(node.y0);
 node.x1 = Math.round(node.x1);
 node.y1 = Math.round(node.y1);
</PRE><P>}
</P><P>function treemapDice(parent, x0, y0, x1, y1) {
</P><PRE> var nodes = parent.children,
     node,
     i = -1,
     n = nodes.length,
     k = parent.value &amp;&amp; (x1 - x0) / parent.value;
</PRE><PRE> while (++i &lt; n) {
   node = nodes[i], node.y0 = y0, node.y1 = y1;
   node.x0 = x0, node.x1 = x0 += node.value * k;
 }
</PRE><P>}
</P><P>function partition() {
</P><PRE> var dx = 1,
     dy = 1,
     padding = 0,
     round = false;
</PRE><PRE> function partition(root) {
   var n = root.height + 1;
   root.x0 =
   root.y0 = padding;
   root.x1 = dx;
   root.y1 = dy / n;
   root.eachBefore(positionNode(dy, n));
   if (round) root.eachBefore(roundNode);
   return root;
 }
</PRE><PRE> function positionNode(dy, n) {
   return function(node) {
     if (node.children) {
       treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
     }
     var x0 = node.x0,
         y0 = node.y0,
         x1 = node.x1 - padding,
         y1 = node.y1 - padding;
     if (x1 &lt; x0) x0 = x1 = (x0 + x1) / 2;
     if (y1 &lt; y0) y0 = y1 = (y0 + y1) / 2;
     node.x0 = x0;
     node.y0 = y0;
     node.x1 = x1;
     node.y1 = y1;
   };
 }
</PRE><PRE> partition.round = function(x) {
   return arguments.length ? (round = !!x, partition) : round;
 };
</PRE><PRE> partition.size = function(x) {
   return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
 };
</PRE><PRE> partition.padding = function(x) {
   return arguments.length ? (padding = +x, partition) : padding;
 };
</PRE><PRE> return partition;
</PRE><P>}
</P><P>var keyPrefix$1 = &quot;$&quot;, // Protect against keys like “__proto__”.
</P><PRE>   preroot = {depth: -1},
   ambiguous = {};
</PRE><P>function defaultId(d) {
</P><PRE> return d.id;
</PRE><P>}
</P><P>function defaultParentId(d) {
</P><PRE> return d.parentId;
</PRE><P>}
</P><P>function stratify() {
</P><PRE> var id = defaultId,
     parentId = defaultParentId;
</PRE><PRE> function stratify(data) {
   var d,
       i,
       n = data.length,
       root,
       parent,
       node,
       nodes = new Array(n),
       nodeId,
       nodeKey,
       nodeByKey = {};
</PRE><PRE>   for (i = 0; i &lt; n; ++i) {
     d = data[i], node = nodes[i] = new Node(d);
     if ((nodeId = id(d, i, data)) != null &amp;&amp; (nodeId += &quot;&quot;)) {
       nodeKey = keyPrefix$1 + (node.id = nodeId);
       nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
     }
   }
</PRE><PRE> for (i = 0; i &lt; n; ++i) {
     node = nodes[i], nodeId = parentId(data[i], i, data);
     if (nodeId == null || !(nodeId += &quot;&quot;)) {
       if (root) throw new Error(&quot;multiple roots&quot;);
       root = node;
     } else {
       parent = nodeByKey[keyPrefix$1 + nodeId];
       if (!parent) throw new Error(&quot;missing: &quot; + nodeId);
       if (parent === ambiguous) throw new Error(&quot;ambiguous: &quot; + nodeId);
       if (parent.children) parent.children.push(node);
       else parent.children = [node];
       node.parent = parent;
     }
   }
</PRE><PRE>   if (!root) throw new Error(&quot;no root&quot;);
   root.parent = preroot;
   root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
   root.parent = null;
   if (n &gt; 0) throw new Error(&quot;cycle&quot;);
</PRE><PRE>   return root;
 }
</PRE><PRE> stratify.id = function(x) {
   return arguments.length ? (id = required(x), stratify) : id;
 };
</PRE><PRE> stratify.parentId = function(x) {
   return arguments.length ? (parentId = required(x), stratify) : parentId;
 };
</PRE><PRE> return stratify;
</PRE><P>}
</P><P>function defaultSeparation$1(a, b) {
</P><PRE> return a.parent === b.parent ? 1 : 2;
</PRE><P>}
</P><P>// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }
</P><P>// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
</P><PRE> var children = v.children;
 return children ? children[0] : v.t;
</PRE><P>}
</P><P>// This function works analogously to nextLeft.
function nextRight(v) {
</P><PRE> var children = v.children;
 return children ? children[children.length - 1] : v.t;
</PRE><P>}
</P><P>// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
</P><PRE> var change = shift / (wp.i - wm.i);
 wp.c -= change;
 wp.s += shift;
 wm.c += change;
 wp.z += shift;
 wp.m += shift;
</PRE><P>}
</P><P>// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
</P><PRE> var shift = 0,
     change = 0,
     children = v.children,
     i = children.length,
     w;
 while (--i &gt;= 0) {
   w = children[i];
   w.z += shift;
   w.m += shift;
   shift += w.s + (change += w.c);
 }
</PRE><P>}
</P><P>// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
</P><PRE> return vim.a.parent === v.parent ? vim.a : ancestor;
</PRE><P>}
</P><P>function TreeNode(node, i) {
</P><PRE> this._ = node;
 this.parent = null;
 this.children = null;
 this.A = null; // default ancestor
 this.a = this; // ancestor
 this.z = 0; // prelim
 this.m = 0; // mod
 this.c = 0; // change
 this.s = 0; // shift
 this.t = null; // thread
 this.i = i; // number
</PRE><P>}
</P><P>TreeNode.prototype = Object.create(Node.prototype);
</P><P>function treeRoot(root) {
</P><PRE> var tree = new TreeNode(root, 0),
     node,
     nodes = [tree],
     child,
     children,
     i,
     n;
</PRE><PRE> while (node = nodes.pop()) {
   if (children = node._.children) {
     node.children = new Array(n = children.length);
     for (i = n - 1; i &gt;= 0; --i) {
       nodes.push(child = node.children[i] = new TreeNode(children[i], i));
       child.parent = node;
     }
   }
 }
</PRE><PRE> (tree.parent = new TreeNode(null, 0)).children = [tree];
 return tree;
</PRE><P>}
</P><P>// Node-link tree diagram using the Reingold-Tilford &quot;tidy&quot; algorithm
function tree() {
</P><PRE> var separation = defaultSeparation$1,
     dx = 1,
     dy = 1,
     nodeSize = null;
</PRE><PRE> function tree(root) {
   var t = treeRoot(root);
</PRE><PRE>   // Compute the layout using Buchheim et al.’s algorithm.
   t.eachAfter(firstWalk), t.parent.m = -t.z;
   t.eachBefore(secondWalk);
</PRE><PRE>   // If a fixed node size is specified, scale x and y.
   if (nodeSize) root.eachBefore(sizeNode);
</PRE><PRE>   // If a fixed tree size is specified, scale x and y based on the extent.
   // Compute the left-most, right-most, and depth-most nodes for extents.
   else {
     var left = root,
         right = root,
         bottom = root;
     root.eachBefore(function(node) {
       if (node.x &lt; left.x) left = node;
       if (node.x &gt; right.x) right = node;
       if (node.depth &gt; bottom.depth) bottom = node;
     });
     var s = left === right ? 1 : separation(left, right) / 2,
         tx = s - left.x,
         kx = dx / (right.x + s + tx),
         ky = dy / (bottom.depth || 1);
     root.eachBefore(function(node) {
       node.x = (node.x + tx) * kx;
       node.y = node.depth * ky;
     });
   }
</PRE><PRE>   return root;
 }
</PRE><PRE> // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
 // applied recursively to the children of v, as well as the function
 // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
 // node v is placed to the midpoint of its outermost children.
 function firstWalk(v) {
   var children = v.children,
       siblings = v.parent.children,
       w = v.i ? siblings[v.i - 1] : null;
   if (children) {
     executeShifts(v);
     var midpoint = (children[0].z + children[children.length - 1].z) / 2;
     if (w) {
       v.z = w.z + separation(v._, w._);
       v.m = v.z - midpoint;
     } else {
       v.z = midpoint;
     }
   } else if (w) {
     v.z = w.z + separation(v._, w._);
   }
   v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
 }
</PRE><PRE> // Computes all real x-coordinates by summing up the modifiers recursively.
 function secondWalk(v) {
   v._.x = v.z + v.parent.m;
   v.m += v.parent.m;
 }
</PRE><PRE> // The core of the algorithm. Here, a new subtree is combined with the
 // previous subtrees. Threads are used to traverse the inside and outside
 // contours of the left and right subtree up to the highest common level. The
 // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
 // superscript o means outside and i means inside, the subscript - means left
 // subtree and + means right subtree. For summing up the modifiers along the
 // contour, we use respective variables si+, si-, so-, and so+. Whenever two
 // nodes of the inside contours conflict, we compute the left one of the
 // greatest uncommon ancestors using the function ANCESTOR and call MOVE
 // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
 // Finally, we add a new thread (if necessary).
 function apportion(v, w, ancestor) {
   if (w) {
     var vip = v,
         vop = v,
         vim = w,
         vom = vip.parent.children[0],
         sip = vip.m,
         sop = vop.m,
         sim = vim.m,
         som = vom.m,
         shift;
     while (vim = nextRight(vim), vip = nextLeft(vip), vim &amp;&amp; vip) {
       vom = nextLeft(vom);
       vop = nextRight(vop);
       vop.a = v;
       shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
       if (shift &gt; 0) {
         moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
         sip += shift;
         sop += shift;
       }
       sim += vim.m;
       sip += vip.m;
       som += vom.m;
       sop += vop.m;
     }
     if (vim &amp;&amp; !nextRight(vop)) {
       vop.t = vim;
       vop.m += sim - sop;
     }
     if (vip &amp;&amp; !nextLeft(vom)) {
       vom.t = vip;
       vom.m += sip - som;
       ancestor = v;
     }
   }
   return ancestor;
 }
</PRE><PRE> function sizeNode(node) {
   node.x *= dx;
   node.y = node.depth * dy;
 }
</PRE><PRE> tree.separation = function(x) {
   return arguments.length ? (separation = x, tree) : separation;
 };
</PRE><PRE> tree.size = function(x) {
   return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
 };
</PRE><PRE> tree.nodeSize = function(x) {
   return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
 };
</PRE><PRE> return tree;
</PRE><P>}
</P><P>function treemapSlice(parent, x0, y0, x1, y1) {
</P><PRE> var nodes = parent.children,
     node,
     i = -1,
     n = nodes.length,
     k = parent.value &amp;&amp; (y1 - y0) / parent.value;
</PRE><PRE> while (++i &lt; n) {
   node = nodes[i], node.x0 = x0, node.x1 = x1;
   node.y0 = y0, node.y1 = y0 += node.value * k;
 }
</PRE><P>}
</P><P>var phi = (1 + Math.sqrt(5)) / 2;
</P><P>function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
</P><PRE> var rows = [],
     nodes = parent.children,
     row,
     nodeValue,
     i0 = 0,
     i1 = 0,
     n = nodes.length,
     dx, dy,
     value = parent.value,
     sumValue,
     minValue,
     maxValue,
     newRatio,
     minRatio,
     alpha,
     beta;
</PRE><PRE> while (i0 &lt; n) {
   dx = x1 - x0, dy = y1 - y0;
</PRE><PRE>   // Find the next non-empty node.
   do sumValue = nodes[i1++].value; while (!sumValue &amp;&amp; i1 &lt; n);
   minValue = maxValue = sumValue;
   alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
   beta = sumValue * sumValue * alpha;
   minRatio = Math.max(maxValue / beta, beta / minValue);
</PRE><PRE>   // Keep adding nodes while the aspect ratio maintains or improves.
   for (; i1 &lt; n; ++i1) {
     sumValue += nodeValue = nodes[i1].value;
     if (nodeValue &lt; minValue) minValue = nodeValue;
     if (nodeValue &gt; maxValue) maxValue = nodeValue;
     beta = sumValue * sumValue * alpha;
     newRatio = Math.max(maxValue / beta, beta / minValue);
     if (newRatio &gt; minRatio) { sumValue -= nodeValue; break; }
     minRatio = newRatio;
   }
</PRE><PRE>   // Position and record the row orientation.
   rows.push(row = {value: sumValue, dice: dx &lt; dy, children: nodes.slice(i0, i1)});
   if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
   else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
   value -= sumValue, i0 = i1;
 }
</PRE><PRE> return rows;
</PRE><P>}
</P><P>var squarify = (function custom(ratio) {
</P><PRE> function squarify(parent, x0, y0, x1, y1) {
   squarifyRatio(ratio, parent, x0, y0, x1, y1);
 }
</PRE><PRE> squarify.ratio = function(x) {
   return custom((x = +x) &gt; 1 ? x : 1);
 };
</PRE><PRE> return squarify;
</PRE><P>})(phi);
</P><P>function index$3() {
</P><PRE> var tile = squarify,
     round = false,
     dx = 1,
     dy = 1,
     paddingStack = [0],
     paddingInner = constantZero,
     paddingTop = constantZero,
     paddingRight = constantZero,
     paddingBottom = constantZero,
     paddingLeft = constantZero;
</PRE><PRE> function treemap(root) {
   root.x0 =
   root.y0 = 0;
   root.x1 = dx;
   root.y1 = dy;
   root.eachBefore(positionNode);
   paddingStack = [0];
   if (round) root.eachBefore(roundNode);
   return root;
 }
</PRE><PRE> function positionNode(node) {
   var p = paddingStack[node.depth],
       x0 = node.x0 + p,
       y0 = node.y0 + p,
       x1 = node.x1 - p,
       y1 = node.y1 - p;
   if (x1 &lt; x0) x0 = x1 = (x0 + x1) / 2;
   if (y1 &lt; y0) y0 = y1 = (y0 + y1) / 2;
   node.x0 = x0;
   node.y0 = y0;
   node.x1 = x1;
   node.y1 = y1;
   if (node.children) {
     p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
     x0 += paddingLeft(node) - p;
     y0 += paddingTop(node) - p;
     x1 -= paddingRight(node) - p;
     y1 -= paddingBottom(node) - p;
     if (x1 &lt; x0) x0 = x1 = (x0 + x1) / 2;
     if (y1 &lt; y0) y0 = y1 = (y0 + y1) / 2;
     tile(node, x0, y0, x1, y1);
   }
 }
</PRE><PRE> treemap.round = function(x) {
   return arguments.length ? (round = !!x, treemap) : round;
 };
</PRE><PRE> treemap.size = function(x) {
   return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
 };
</PRE><PRE> treemap.tile = function(x) {
   return arguments.length ? (tile = required(x), treemap) : tile;
 };
</PRE><PRE> treemap.padding = function(x) {
   return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
 };
</PRE><PRE> treemap.paddingInner = function(x) {
   return arguments.length ? (paddingInner = typeof x === &quot;function&quot; ? x : constant$9(+x), treemap) : paddingInner;
 };
</PRE><PRE> treemap.paddingOuter = function(x) {
   return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
 };
</PRE><PRE> treemap.paddingTop = function(x) {
   return arguments.length ? (paddingTop = typeof x === &quot;function&quot; ? x : constant$9(+x), treemap) : paddingTop;
 };
</PRE><PRE> treemap.paddingRight = function(x) {
   return arguments.length ? (paddingRight = typeof x === &quot;function&quot; ? x : constant$9(+x), treemap) : paddingRight;
 };
</PRE><PRE> treemap.paddingBottom = function(x) {
   return arguments.length ? (paddingBottom = typeof x === &quot;function&quot; ? x : constant$9(+x), treemap) : paddingBottom;
 };
</PRE><PRE> treemap.paddingLeft = function(x) {
   return arguments.length ? (paddingLeft = typeof x === &quot;function&quot; ? x : constant$9(+x), treemap) : paddingLeft;
 };
</PRE><PRE> return treemap;
</PRE><P>}
</P><P>function binary(parent, x0, y0, x1, y1) {
</P><PRE> var nodes = parent.children,
     i, n = nodes.length,
     sum, sums = new Array(n + 1);
</PRE><PRE> for (sums[0] = sum = i = 0; i &lt; n; ++i) {
   sums[i + 1] = sum += nodes[i].value;
 }
</PRE><PRE> partition(0, n, parent.value, x0, y0, x1, y1);
</PRE><PRE> function partition(i, j, value, x0, y0, x1, y1) {
   if (i &gt;= j - 1) {
     var node = nodes[i];
     node.x0 = x0, node.y0 = y0;
     node.x1 = x1, node.y1 = y1;
     return;
   }
</PRE><PRE>   var valueOffset = sums[i],
       valueTarget = (value / 2) + valueOffset,
       k = i + 1,
       hi = j - 1;
</PRE><PRE>   while (k &lt; hi) {
     var mid = k + hi &gt;&gt;&gt; 1;
     if (sums[mid] &lt; valueTarget) k = mid + 1;
     else hi = mid;
   }
</PRE><PRE>   if ((valueTarget - sums[k - 1]) &lt; (sums[k] - valueTarget) &amp;&amp; i + 1 &lt; k) --k;
</PRE><PRE>   var valueLeft = sums[k] - valueOffset,
       valueRight = value - valueLeft;
</PRE><PRE>   if ((x1 - x0) &gt; (y1 - y0)) {
     var xk = (x0 * valueRight + x1 * valueLeft) / value;
     partition(i, k, valueLeft, x0, y0, xk, y1);
     partition(k, j, valueRight, xk, y0, x1, y1);
   } else {
     var yk = (y0 * valueRight + y1 * valueLeft) / value;
     partition(i, k, valueLeft, x0, y0, x1, yk);
     partition(k, j, valueRight, x0, yk, x1, y1);
   }
 }
</PRE><P>}
</P><P>function sliceDice(parent, x0, y0, x1, y1) {
</P><PRE> (parent.depth &amp; 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
</PRE><P>}
</P><P>var resquarify = (function custom(ratio) {
</P><PRE> function resquarify(parent, x0, y0, x1, y1) {
   if ((rows = parent._squarify) &amp;&amp; (rows.ratio === ratio)) {
     var rows,
         row,
         nodes,
         i,
         j = -1,
         n,
         m = rows.length,
         value = parent.value;
</PRE><PRE>     while (++j &lt; m) {
       row = rows[j], nodes = row.children;
       for (i = row.value = 0, n = nodes.length; i &lt; n; ++i) row.value += nodes[i].value;
       if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
       else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
       value -= row.value;
     }
   } else {
     parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
     rows.ratio = ratio;
   }
 }
</PRE><PRE> resquarify.ratio = function(x) {
   return custom((x = +x) &gt; 1 ? x : 1);
 };
</PRE><PRE> return resquarify;
</PRE><P>})(phi);
</P><P>function area$2(polygon) {
</P><PRE> var i = -1,
     n = polygon.length,
     a,
     b = polygon[n - 1],
     area = 0;
</PRE><PRE> while (++i &lt; n) {
   a = b;
   b = polygon[i];
   area += a[1] * b[0] - a[0] * b[1];
 }
</PRE><PRE> return area / 2;
</PRE><P>}
</P><P>function centroid$1(polygon) {
</P><PRE> var i = -1,
     n = polygon.length,
     x = 0,
     y = 0,
     a,
     b = polygon[n - 1],
     c,
     k = 0;
</PRE><PRE> while (++i &lt; n) {
   a = b;
   b = polygon[i];
   k += c = a[0] * b[1] - b[0] * a[1];
   x += (a[0] + b[0]) * c;
   y += (a[1] + b[1]) * c;
 }
</PRE><PRE> return k *= 3, [x / k, y / k];
</PRE><P>}
</P><P>// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function cross$1(a, b, c) {
</P><PRE> return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
</PRE><P>}
</P><P>function lexicographicOrder(a, b) {
</P><PRE> return a[0] - b[0] || a[1] - b[1];
</PRE><P>}
</P><P>// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length &gt;= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
</P><PRE> var n = points.length,
     indexes = [0, 1],
     size = 2;
</PRE><PRE> for (var i = 2; i &lt; n; ++i) {
   while (size &gt; 1 &amp;&amp; cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) &lt;= 0) --size;
   indexes[size++] = i;
 }
</PRE><PRE> return indexes.slice(0, size); // remove popped points
</PRE><P>}
</P><P>function hull(points) {
</P><PRE> if ((n = points.length) &lt; 3) return null;
</PRE><PRE> var i,
     n,
     sortedPoints = new Array(n),
     flippedPoints = new Array(n);
</PRE><PRE> for (i = 0; i &lt; n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
 sortedPoints.sort(lexicographicOrder);
 for (i = 0; i &lt; n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
</PRE><PRE> var upperIndexes = computeUpperHullIndexes(sortedPoints),
     lowerIndexes = computeUpperHullIndexes(flippedPoints);
</PRE><PRE> // Construct the hull polygon, removing possible duplicate endpoints.
 var skipLeft = lowerIndexes[0] === upperIndexes[0],
     skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
     hull = [];
</PRE><PRE> // Add upper hull in right-to-l order.
 // Then add lower hull in left-to-right order.
 for (i = upperIndexes.length - 1; i &gt;= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
 for (i = +skipLeft; i &lt; lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);
</PRE><PRE> return hull;
</PRE><P>}
</P><P>function contains$2(polygon, point) {
</P><PRE> var n = polygon.length,
     p = polygon[n - 1],
     x = point[0], y = point[1],
     x0 = p[0], y0 = p[1],
     x1, y1,
     inside = false;
</PRE><PRE> for (var i = 0; i &lt; n; ++i) {
   p = polygon[i], x1 = p[0], y1 = p[1];
   if (((y1 &gt; y) !== (y0 &gt; y)) &amp;&amp; (x &lt; (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
   x0 = x1, y0 = y1;
 }
</PRE><PRE> return inside;
</PRE><P>}
</P><P>function length$2(polygon) {
</P><PRE> var i = -1,
     n = polygon.length,
     b = polygon[n - 1],
     xa,
     ya,
     xb = b[0],
     yb = b[1],
     perimeter = 0;
</PRE><PRE> while (++i &lt; n) {
   xa = xb;
   ya = yb;
   b = polygon[i];
   xb = b[0];
   yb = b[1];
   xa -= xb;
   ya -= yb;
   perimeter += Math.sqrt(xa * xa + ya * ya);
 }
</PRE><PRE> return perimeter;
</PRE><P>}
</P><P>function defaultSource$1() {
</P><PRE> return Math.random();
</PRE><P>}
</P><P>var uniform = (function sourceRandomUniform(source) {
</P><PRE> function randomUniform(min, max) {
   min = min == null ? 0 : +min;
   max = max == null ? 1 : +max;
   if (arguments.length === 1) max = min, min = 0;
   else max -= min;
   return function() {
     return source() * max + min;
   };
 }
</PRE><PRE> randomUniform.source = sourceRandomUniform;
</PRE><PRE> return randomUniform;
</PRE><P>})(defaultSource$1);
</P><P>var normal = (function sourceRandomNormal(source) {
</P><PRE> function randomNormal(mu, sigma) {
   var x, r;
   mu = mu == null ? 0 : +mu;
   sigma = sigma == null ? 1 : +sigma;
   return function() {
     var y;
</PRE><PRE>     // If available, use the second previously-generated uniform random.
     if (x != null) y = x, x = null;
</PRE><PRE>     // Otherwise, generate a new x and y.
     else do {
       x = source() * 2 - 1;
       y = source() * 2 - 1;
       r = x * x + y * y;
     } while (!r || r &gt; 1);
</PRE><PRE>     return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
   };
 }
</PRE><PRE> randomNormal.source = sourceRandomNormal;
</PRE><PRE> return randomNormal;
</PRE><P>})(defaultSource$1);
</P><P>var logNormal = (function sourceRandomLogNormal(source) {
</P><PRE> function randomLogNormal() {
   var randomNormal = normal.source(source).apply(this, arguments);
   return function() {
     return Math.exp(randomNormal());
   };
 }
</PRE><PRE> randomLogNormal.source = sourceRandomLogNormal;
</PRE><PRE> return randomLogNormal;
</PRE><P>})(defaultSource$1);
</P><P>var irwinHall = (function sourceRandomIrwinHall(source) {
</P><PRE> function randomIrwinHall(n) {
   return function() {
     for (var sum = 0, i = 0; i &lt; n; ++i) sum += source();
     return sum;
   };
 }
</PRE><PRE> randomIrwinHall.source = sourceRandomIrwinHall;
</PRE><PRE> return randomIrwinHall;
</PRE><P>})(defaultSource$1);
</P><P>var bates = (function sourceRandomBates(source) {
</P><PRE> function randomBates(n) {
   var randomIrwinHall = irwinHall.source(source)(n);
   return function() {
     return randomIrwinHall() / n;
   };
 }
</PRE><PRE> randomBates.source = sourceRandomBates;
</PRE><PRE> return randomBates;
</PRE><P>})(defaultSource$1);
</P><P>var exponential$1 = (function sourceRandomExponential(source) {
</P><PRE> function randomExponential(lambda) {
   return function() {
     return -Math.log(1 - source()) / lambda;
   };
 }
</PRE><PRE> randomExponential.source = sourceRandomExponential;
</PRE><PRE> return randomExponential;
</PRE><P>})(defaultSource$1);
</P><P>var array$3 = Array.prototype;
</P><P>var map$2 = array$3.map;
var slice$5 = array$3.slice;
</P><P>var implicit = {name: &quot;implicit&quot;};
</P><P>function ordinal(range) {
</P><PRE> var index = map$1(),
     domain = [],
     unknown = implicit;
</PRE><PRE> range = range == null ? [] : slice$5.call(range);
</PRE><PRE> function scale(d) {
   var key = d + &quot;&quot;, i = index.get(key);
   if (!i) {
     if (unknown !== implicit) return unknown;
     index.set(key, i = domain.push(d));
   }
   return range[(i - 1) % range.length];
 }
</PRE><PRE> scale.domain = function(_) {
   if (!arguments.length) return domain.slice();
   domain = [], index = map$1();
   var i = -1, n = _.length, d, key;
   while (++i &lt; n) if (!index.has(key = (d = _[i]) + &quot;&quot;)) index.set(key, domain.push(d));
   return scale;
 };
</PRE><PRE> scale.range = function(_) {
   return arguments.length ? (range = slice$5.call(_), scale) : range.slice();
 };
</PRE><PRE> scale.unknown = function(_) {
   return arguments.length ? (unknown = _, scale) : unknown;
 };
</PRE><PRE> scale.copy = function() {
   return ordinal()
       .domain(domain)
       .range(range)
       .unknown(unknown);
 };
</PRE><PRE> return scale;
</PRE><P>}
</P><P>function band() {
</P><PRE> var scale = ordinal().unknown(undefined),
     domain = scale.domain,
     ordinalRange = scale.range,
     range$$1 = [0, 1],
     step,
     bandwidth,
     round = false,
     paddingInner = 0,
     paddingOuter = 0,
     align = 0.5;
</PRE><PRE> delete scale.unknown;
</PRE><PRE> function rescale() {
   var n = domain().length,
       reverse = range$$1[1] &lt; range$$1[0],
       start = range$$1[reverse - 0],
       stop = range$$1[1 - reverse];
   step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
   if (round) step = Math.floor(step);
   start += (stop - start - step * (n - paddingInner)) * align;
   bandwidth = step * (1 - paddingInner);
   if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
   var values = sequence(n).map(function(i) { return start + step * i; });
   return ordinalRange(reverse ? values.reverse() : values);
 }
</PRE><PRE> scale.domain = function(_) {
   return arguments.length ? (domain(_), rescale()) : domain();
 };
</PRE><PRE> scale.range = function(_) {
   return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
 };
</PRE><PRE> scale.rangeRound = function(_) {
   return range$$1 = [+_[0], +_[1]], round = true, rescale();
 };
</PRE><PRE> scale.bandwidth = function() {
   return bandwidth;
 };
</PRE><PRE> scale.step = function() {
   return step;
 };
</PRE><PRE> scale.round = function(_) {
   return arguments.length ? (round = !!_, rescale()) : round;
 };
</PRE><PRE> scale.padding = function(_) {
   return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
 };
</PRE><PRE> scale.paddingInner = function(_) {
   return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
 };
</PRE><PRE> scale.paddingOuter = function(_) {
   return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
 };
</PRE><PRE> scale.align = function(_) {
   return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
 };
</PRE><PRE> scale.copy = function() {
   return band()
       .domain(domain())
       .range(range$$1)
       .round(round)
       .paddingInner(paddingInner)
       .paddingOuter(paddingOuter)
       .align(align);
 };
</PRE><PRE> return rescale();
</PRE><P>}
</P><P>function pointish(scale) {
</P><PRE> var copy = scale.copy;
</PRE><PRE> scale.padding = scale.paddingOuter;
 delete scale.paddingInner;
 delete scale.paddingOuter;
</PRE><PRE> scale.copy = function() {
   return pointish(copy());
 };
</PRE><PRE> return scale;
</PRE><P>}
</P><P>function point$1() {
</P><PRE> return pointish(band().paddingInner(1));
</PRE><P>}
</P><P>function constant$a(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function number$2(x) {
</P><PRE> return +x;
</PRE><P>}
</P><P>var unit = [0, 1];
</P><P>function deinterpolateLinear(a, b) {
</P><PRE> return (b -= (a = +a))
     ? function(x) { return (x - a) / b; }
     : constant$a(b);
</PRE><P>}
</P><P>function deinterpolateClamp(deinterpolate) {
</P><PRE> return function(a, b) {
   var d = deinterpolate(a = +a, b = +b);
   return function(x) { return x &lt;= a ? 0 : x &gt;= b ? 1 : d(x); };
 };
</PRE><P>}
</P><P>function reinterpolateClamp(reinterpolate) {
</P><PRE> return function(a, b) {
   var r = reinterpolate(a = +a, b = +b);
   return function(t) { return t &lt;= 0 ? a : t &gt;= 1 ? b : r(t); };
 };
</PRE><P>}
</P><P>function bimap(domain, range, deinterpolate, reinterpolate) {
</P><PRE> var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
 if (d1 &lt; d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
 else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
 return function(x) { return r0(d0(x)); };
</PRE><P>}
</P><P>function polymap(domain, range, deinterpolate, reinterpolate) {
</P><PRE> var j = Math.min(domain.length, range.length) - 1,
     d = new Array(j),
     r = new Array(j),
     i = -1;
</PRE><PRE> // Reverse descending domains.
 if (domain[j] &lt; domain[0]) {
   domain = domain.slice().reverse();
   range = range.slice().reverse();
 }
</PRE><PRE> while (++i &lt; j) {
   d[i] = deinterpolate(domain[i], domain[i + 1]);
   r[i] = reinterpolate(range[i], range[i + 1]);
 }
</PRE><PRE> return function(x) {
   var i = bisectRight(domain, x, 1, j) - 1;
   return r[i](d[i](x));
 };
</PRE><P>}
</P><P>function copy(source, target) {
</P><PRE> return target
     .domain(source.domain())
     .range(source.range())
     .interpolate(source.interpolate())
     .clamp(source.clamp());
</PRE><P>}
</P><P>// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
</P><PRE> var domain = unit,
     range = unit,
     interpolate$$1 = interpolateValue,
     clamp = false,
     piecewise$$1,
     output,
     input;
</PRE><PRE> function rescale() {
   piecewise$$1 = Math.min(domain.length, range.length) &gt; 2 ? polymap : bimap;
   output = input = null;
   return scale;
 }
</PRE><PRE> function scale(x) {
   return (output || (output = piecewise$$1(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
 }
</PRE><PRE> scale.invert = function(y) {
   return (input || (input = piecewise$$1(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
 };
</PRE><PRE> scale.domain = function(_) {
   return arguments.length ? (domain = map$2.call(_, number$2), rescale()) : domain.slice();
 };
</PRE><PRE> scale.range = function(_) {
   return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();
 };
</PRE><PRE> scale.rangeRound = function(_) {
   return range = slice$5.call(_), interpolate$$1 = interpolateRound, rescale();
 };
</PRE><PRE> scale.clamp = function(_) {
   return arguments.length ? (clamp = !!_, rescale()) : clamp;
 };
</PRE><PRE> scale.interpolate = function(_) {
   return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
 };
</PRE><PRE> return rescale();
</PRE><P>}
</P><P>function tickFormat(domain, count, specifier) {
</P><PRE> var start = domain[0],
     stop = domain[domain.length - 1],
     step = tickStep(start, stop, count == null ? 10 : count),
     precision;
 specifier = formatSpecifier(specifier == null ? &quot;,f&quot; : specifier);
 switch (specifier.type) {
   case &quot;s&quot;: {
     var value = Math.max(Math.abs(start), Math.abs(stop));
     if (specifier.precision == null &amp;&amp; !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
     return exports.formatPrefix(specifier, value);
   }
   case &quot;&quot;:
   case &quot;e&quot;:
   case &quot;g&quot;:
   case &quot;p&quot;:
   case &quot;r&quot;: {
     if (specifier.precision == null &amp;&amp; !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === &quot;e&quot;);
     break;
   }
   case &quot;f&quot;:
   case &quot;%&quot;: {
     if (specifier.precision == null &amp;&amp; !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === &quot;%&quot;) * 2;
     break;
   }
 }
 return exports.format(specifier);
</PRE><P>}
</P><P>function linearish(scale) {
</P><PRE> var domain = scale.domain;
</PRE><PRE> scale.ticks = function(count) {
   var d = domain();
   return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
 };
</PRE><PRE> scale.tickFormat = function(count, specifier) {
   return tickFormat(domain(), count, specifier);
 };
</PRE><PRE> scale.nice = function(count) {
   if (count == null) count = 10;
</PRE><PRE>   var d = domain(),
       i0 = 0,
       i1 = d.length - 1,
       start = d[i0],
       stop = d[i1],
       step;
</PRE><PRE>   if (stop &lt; start) {
     step = start, start = stop, stop = step;
     step = i0, i0 = i1, i1 = step;
   }
</PRE><PRE>   step = tickIncrement(start, stop, count);
</PRE><PRE>   if (step &gt; 0) {
     start = Math.floor(start / step) * step;
     stop = Math.ceil(stop / step) * step;
     step = tickIncrement(start, stop, count);
   } else if (step &lt; 0) {
     start = Math.ceil(start * step) / step;
     stop = Math.floor(stop * step) / step;
     step = tickIncrement(start, stop, count);
   }
</PRE><PRE>   if (step &gt; 0) {
     d[i0] = Math.floor(start / step) * step;
     d[i1] = Math.ceil(stop / step) * step;
     domain(d);
   } else if (step &lt; 0) {
     d[i0] = Math.ceil(start * step) / step;
     d[i1] = Math.floor(stop * step) / step;
     domain(d);
   }
</PRE><PRE>   return scale;
 };
</PRE><PRE> return scale;
</PRE><P>}
</P><P>function linear$2() {
</P><PRE> var scale = continuous(deinterpolateLinear, interpolateNumber);
</PRE><PRE> scale.copy = function() {
   return copy(scale, linear$2());
 };
</PRE><PRE> return linearish(scale);
</PRE><P>}
</P><P>function identity$6() {
</P><PRE> var domain = [0, 1];
</PRE><PRE> function scale(x) {
   return +x;
 }
</PRE><PRE> scale.invert = scale;
</PRE><PRE> scale.domain = scale.range = function(_) {
   return arguments.length ? (domain = map$2.call(_, number$2), scale) : domain.slice();
 };
</PRE><PRE> scale.copy = function() {
   return identity$6().domain(domain);
 };
</PRE><PRE> return linearish(scale);
</PRE><P>}
</P><P>function nice(domain, interval) {
</P><PRE> domain = domain.slice();
</PRE><PRE> var i0 = 0,
     i1 = domain.length - 1,
     x0 = domain[i0],
     x1 = domain[i1],
     t;
</PRE><PRE> if (x1 &lt; x0) {
   t = i0, i0 = i1, i1 = t;
   t = x0, x0 = x1, x1 = t;
 }
</PRE><PRE> domain[i0] = interval.floor(x0);
 domain[i1] = interval.ceil(x1);
 return domain;
</PRE><P>}
</P><P>function deinterpolate(a, b) {
</P><PRE> return (b = Math.log(b / a))
     ? function(x) { return Math.log(x / a) / b; }
     : constant$a(b);
</PRE><P>}
</P><P>function reinterpolate(a, b) {
</P><PRE> return a &lt; 0
     ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
     : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
</PRE><P>}
</P><P>function pow10(x) {
</P><PRE> return isFinite(x) ? +(&quot;1e&quot; + x) : x &lt; 0 ? 0 : x;
</PRE><P>}
</P><P>function powp(base) {
</P><PRE> return base === 10 ? pow10
     : base === Math.E ? Math.exp
     : function(x) { return Math.pow(base, x); };
</PRE><P>}
</P><P>function logp(base) {
</P><PRE> return base === Math.E ? Math.log
     : base === 10 &amp;&amp; Math.log10
     || base === 2 &amp;&amp; Math.log2
     || (base = Math.log(base), function(x) { return Math.log(x) / base; });
</PRE><P>}
</P><P>function reflect(f) {
</P><PRE> return function(x) {
   return -f(-x);
 };
</PRE><P>}
</P><P>function log$1() {
</P><PRE> var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
     domain = scale.domain,
     base = 10,
     logs = logp(10),
     pows = powp(10);
</PRE><PRE> function rescale() {
   logs = logp(base), pows = powp(base);
   if (domain()[0] &lt; 0) logs = reflect(logs), pows = reflect(pows);
   return scale;
 }
</PRE><PRE> scale.base = function(_) {
   return arguments.length ? (base = +_, rescale()) : base;
 };
</PRE><PRE> scale.domain = function(_) {
   return arguments.length ? (domain(_), rescale()) : domain();
 };
</PRE><PRE> scale.ticks = function(count) {
   var d = domain(),
       u = d[0],
       v = d[d.length - 1],
       r;
</PRE><PRE>   if (r = v &lt; u) i = u, u = v, v = i;
</PRE><PRE>   var i = logs(u),
       j = logs(v),
       p,
       k,
       t,
       n = count == null ? 10 : +count,
       z = [];
</PRE><PRE>   if (!(base % 1) &amp;&amp; j - i &lt; n) {
     i = Math.round(i) - 1, j = Math.round(j) + 1;
     if (u &gt; 0) for (; i &lt; j; ++i) {
       for (k = 1, p = pows(i); k &lt; base; ++k) {
         t = p * k;
         if (t &lt; u) continue;
         if (t &gt; v) break;
         z.push(t);
       }
     } else for (; i &lt; j; ++i) {
       for (k = base - 1, p = pows(i); k &gt;= 1; --k) {
         t = p * k;
         if (t &lt; u) continue;
         if (t &gt; v) break;
         z.push(t);
       }
     }
   } else {
     z = ticks(i, j, Math.min(j - i, n)).map(pows);
   }
</PRE><PRE>   return r ? z.reverse() : z;
 };
</PRE><PRE> scale.tickFormat = function(count, specifier) {
   if (specifier == null) specifier = base === 10 ? &quot;.0e&quot; : &quot;,&quot;;
   if (typeof specifier !== &quot;function&quot;) specifier = exports.format(specifier);
   if (count === Infinity) return specifier;
   if (count == null) count = 10;
   var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
   return function(d) {
     var i = d / pows(Math.round(logs(d)));
     if (i * base &lt; base - 0.5) i *= base;
     return i &lt;= k ? specifier(d) : &quot;&quot;;
   };
 };
</PRE><PRE> scale.nice = function() {
   return domain(nice(domain(), {
     floor: function(x) { return pows(Math.floor(logs(x))); },
     ceil: function(x) { return pows(Math.ceil(logs(x))); }
   }));
 };
</PRE><PRE> scale.copy = function() {
   return copy(scale, log$1().base(base));
 };
</PRE><PRE> return scale;
</PRE><P>}
</P><P>function raise$1(x, exponent) {
</P><PRE> return x &lt; 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
</PRE><P>}
</P><P>function pow$1() {
</P><PRE> var exponent = 1,
     scale = continuous(deinterpolate, reinterpolate),
     domain = scale.domain;
</PRE><PRE> function deinterpolate(a, b) {
   return (b = raise$1(b, exponent) - (a = raise$1(a, exponent)))
       ? function(x) { return (raise$1(x, exponent) - a) / b; }
       : constant$a(b);
 }
</PRE><PRE> function reinterpolate(a, b) {
   b = raise$1(b, exponent) - (a = raise$1(a, exponent));
   return function(t) { return raise$1(a + b * t, 1 / exponent); };
 }
</PRE><PRE> scale.exponent = function(_) {
   return arguments.length ? (exponent = +_, domain(domain())) : exponent;
 };
</PRE><PRE> scale.copy = function() {
   return copy(scale, pow$1().exponent(exponent));
 };
</PRE><PRE> return linearish(scale);
</PRE><P>}
</P><P>function sqrt$1() {
</P><PRE> return pow$1().exponent(0.5);
</PRE><P>}
</P><P>function quantile$$1() {
</P><PRE> var domain = [],
     range = [],
     thresholds = [];
</PRE><PRE> function rescale() {
   var i = 0, n = Math.max(1, range.length);
   thresholds = new Array(n - 1);
   while (++i &lt; n) thresholds[i - 1] = threshold(domain, i / n);
   return scale;
 }
</PRE><PRE> function scale(x) {
   if (!isNaN(x = +x)) return range[bisectRight(thresholds, x)];
 }
</PRE><PRE> scale.invertExtent = function(y) {
   var i = range.indexOf(y);
   return i &lt; 0 ? [NaN, NaN] : [
     i &gt; 0 ? thresholds[i - 1] : domain[0],
     i &lt; thresholds.length ? thresholds[i] : domain[domain.length - 1]
   ];
 };
</PRE><PRE> scale.domain = function(_) {
   if (!arguments.length) return domain.slice();
   domain = [];
   for (var i = 0, n = _.length, d; i &lt; n; ++i) if (d = _[i], d != null &amp;&amp; !isNaN(d = +d)) domain.push(d);
   domain.sort(ascending);
   return rescale();
 };
</PRE><PRE> scale.range = function(_) {
   return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();
 };
</PRE><PRE> scale.quantiles = function() {
   return thresholds.slice();
 };
</PRE><PRE> scale.copy = function() {
   return quantile$$1()
       .domain(domain)
       .range(range);
 };
</PRE><PRE> return scale;
</PRE><P>}
</P><P>function quantize$1() {
</P><PRE> var x0 = 0,
     x1 = 1,
     n = 1,
     domain = [0.5],
     range = [0, 1];
</PRE><PRE> function scale(x) {
   if (x &lt;= x) return range[bisectRight(domain, x, 0, n)];
 }
</PRE><PRE> function rescale() {
   var i = -1;
   domain = new Array(n);
   while (++i &lt; n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
   return scale;
 }
</PRE><PRE> scale.domain = function(_) {
   return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
 };
</PRE><PRE> scale.range = function(_) {
   return arguments.length ? (n = (range = slice$5.call(_)).length - 1, rescale()) : range.slice();
 };
</PRE><PRE> scale.invertExtent = function(y) {
   var i = range.indexOf(y);
   return i &lt; 0 ? [NaN, NaN]
       : i &lt; 1 ? [x0, domain[0]]
       : i &gt;= n ? [domain[n - 1], x1]
       : [domain[i - 1], domain[i]];
 };
</PRE><PRE> scale.copy = function() {
   return quantize$1()
       .domain([x0, x1])
       .range(range);
 };
</PRE><PRE> return linearish(scale);
</PRE><P>}
</P><P>function threshold$1() {
</P><PRE> var domain = [0.5],
     range = [0, 1],
     n = 1;
</PRE><PRE> function scale(x) {
   if (x &lt;= x) return range[bisectRight(domain, x, 0, n)];
 }
</PRE><PRE> scale.domain = function(_) {
   return arguments.length ? (domain = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
 };
</PRE><PRE> scale.range = function(_) {
   return arguments.length ? (range = slice$5.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
 };
</PRE><PRE> scale.invertExtent = function(y) {
   var i = range.indexOf(y);
   return [domain[i - 1], domain[i]];
 };
</PRE><PRE> scale.copy = function() {
   return threshold$1()
       .domain(domain)
       .range(range);
 };
</PRE><PRE> return scale;
</PRE><P>}
</P><P>var t0$1 = new Date,
</P><PRE>   t1$1 = new Date;
</PRE><P>function newInterval(floori, offseti, count, field) {
</P><PRE> function interval(date) {
   return floori(date = new Date(+date)), date;
 }
</PRE><PRE> interval.floor = interval;
</PRE><PRE> interval.ceil = function(date) {
   return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
 };
</PRE><PRE> interval.round = function(date) {
   var d0 = interval(date),
       d1 = interval.ceil(date);
   return date - d0 &lt; d1 - date ? d0 : d1;
 };
</PRE><PRE> interval.offset = function(date, step) {
   return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
 };
</PRE><PRE> interval.range = function(start, stop, step) {
   var range = [], previous;
   start = interval.ceil(start);
   step = step == null ? 1 : Math.floor(step);
   if (!(start &lt; stop) || !(step &gt; 0)) return range; // also handles Invalid Date
   do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
   while (previous &lt; start &amp;&amp; start &lt; stop);
   return range;
 };
</PRE><PRE> interval.filter = function(test) {
   return newInterval(function(date) {
     if (date &gt;= date) while (floori(date), !test(date)) date.setTime(date - 1);
   }, function(date, step) {
     if (date &gt;= date) {
       if (step &lt; 0) while (++step &lt;= 0) {
         while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
       } else while (--step &gt;= 0) {
         while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
       }
     }
   });
 };
</PRE><PRE> if (count) {
   interval.count = function(start, end) {
     t0$1.setTime(+start), t1$1.setTime(+end);
     floori(t0$1), floori(t1$1);
     return Math.floor(count(t0$1, t1$1));
   };
</PRE><PRE>   interval.every = function(step) {
     step = Math.floor(step);
     return !isFinite(step) || !(step &gt; 0) ? null
         : !(step &gt; 1) ? interval
         : interval.filter(field
             ? function(d) { return field(d) % step === 0; }
             : function(d) { return interval.count(0, d) % step === 0; });
   };
 }
</PRE><PRE> return interval;
</PRE><P>}
</P><P>var millisecond = newInterval(function() {
</P><PRE> // noop
</PRE><P>}, function(date, step) {
</P><PRE> date.setTime(+date + step);
</PRE><P>}, function(start, end) {
</P><PRE> return end - start;
</PRE><P>});
</P><P>// An optimized implementation for this simple case.
millisecond.every = function(k) {
</P><PRE> k = Math.floor(k);
 if (!isFinite(k) || !(k &gt; 0)) return null;
 if (!(k &gt; 1)) return millisecond;
 return newInterval(function(date) {
   date.setTime(Math.floor(date / k) * k);
 }, function(date, step) {
   date.setTime(+date + step * k);
 }, function(start, end) {
   return (end - start) / k;
 });
</PRE><P>};
var milliseconds = millisecond.range;
</P><P>var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;
</P><P>var second = newInterval(function(date) {
</P><PRE> date.setTime(Math.floor(date / durationSecond) * durationSecond);
</PRE><P>}, function(date, step) {
</P><PRE> date.setTime(+date + step * durationSecond);
</PRE><P>}, function(start, end) {
</P><PRE> return (end - start) / durationSecond;
</PRE><P>}, function(date) {
</P><PRE> return date.getUTCSeconds();
</PRE><P>});
var seconds = second.range;
</P><P>var minute = newInterval(function(date) {
</P><PRE> date.setTime(Math.floor(date / durationMinute) * durationMinute);
</PRE><P>}, function(date, step) {
</P><PRE> date.setTime(+date + step * durationMinute);
</PRE><P>}, function(start, end) {
</P><PRE> return (end - start) / durationMinute;
</PRE><P>}, function(date) {
</P><PRE> return date.getMinutes();
</PRE><P>});
var minutes = minute.range;
</P><P>var hour = newInterval(function(date) {
</P><PRE> var offset = date.getTimezoneOffset() * durationMinute % durationHour;
 if (offset &lt; 0) offset += durationHour;
 date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
</PRE><P>}, function(date, step) {
</P><PRE> date.setTime(+date + step * durationHour);
</PRE><P>}, function(start, end) {
</P><PRE> return (end - start) / durationHour;
</PRE><P>}, function(date) {
</P><PRE> return date.getHours();
</PRE><P>});
var hours = hour.range;
</P><P>var day = newInterval(function(date) {
</P><PRE> date.setHours(0, 0, 0, 0);
</PRE><P>}, function(date, step) {
</P><PRE> date.setDate(date.getDate() + step);
</PRE><P>}, function(start, end) {
</P><PRE> return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
</PRE><P>}, function(date) {
</P><PRE> return date.getDate() - 1;
</PRE><P>});
var days = day.range;
</P><P>function weekday(i) {
</P><PRE> return newInterval(function(date) {
   date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
   date.setHours(0, 0, 0, 0);
 }, function(date, step) {
   date.setDate(date.getDate() + step * 7);
 }, function(start, end) {
   return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
 });
</PRE><P>}
</P><P>var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
</P><P>var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;
</P><P>var month = newInterval(function(date) {
</P><PRE> date.setDate(1);
 date.setHours(0, 0, 0, 0);
</PRE><P>}, function(date, step) {
</P><PRE> date.setMonth(date.getMonth() + step);
</PRE><P>}, function(start, end) {
</P><PRE> return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
</PRE><P>}, function(date) {
</P><PRE> return date.getMonth();
</PRE><P>});
var months = month.range;
</P><P>var year = newInterval(function(date) {
</P><PRE> date.setMonth(0, 1);
 date.setHours(0, 0, 0, 0);
</PRE><P>}, function(date, step) {
</P><PRE> date.setFullYear(date.getFullYear() + step);
</PRE><P>}, function(start, end) {
</P><PRE> return end.getFullYear() - start.getFullYear();
</PRE><P>}, function(date) {
</P><PRE> return date.getFullYear();
</PRE><P>});
</P><P>// An optimized implementation for this simple case.
year.every = function(k) {
</P><PRE> return !isFinite(k = Math.floor(k)) || !(k &gt; 0) ? null : newInterval(function(date) {
   date.setFullYear(Math.floor(date.getFullYear() / k) * k);
   date.setMonth(0, 1);
   date.setHours(0, 0, 0, 0);
 }, function(date, step) {
   date.setFullYear(date.getFullYear() + step * k);
 });
</PRE><P>};
var years = year.range;
</P><P>var utcMinute = newInterval(function(date) {
</P><PRE> date.setUTCSeconds(0, 0);
</PRE><P>}, function(date, step) {
</P><PRE> date.setTime(+date + step * durationMinute);
</PRE><P>}, function(start, end) {
</P><PRE> return (end - start) / durationMinute;</PRE><P>}, function(date) {
</P><PRE> return date.getUTCMinutes();
</PRE><P>});
var utcMinutes = utcMinute.range;
</P><P>var utcHour = newInterval(function(date) {
</P><PRE> date.setUTCMinutes(0, 0, 0);
</PRE><P>}, function(date, step) {
</P><PRE> date.setTime(+date + step * durationHour);
</PRE><P>}, function(start, end) {
</P><PRE> return (end - start) / durationHour;
</PRE><P>}, function(date) {
</P><PRE> return date.getUTCHours();
</PRE><P>});
var utcHours = utcHour.range;
</P><P>var utcDay = newInterval(function(date) {
</P><PRE> date.setUTCHours(0, 0, 0, 0);
</PRE><P>}, function(date, step) {
</P><PRE> date.setUTCDate(date.getUTCDate() + step);
</PRE><P>}, function(start, end) {
</P><PRE> return (end - start) / durationDay;
</PRE><P>}, function(date) {
</P><PRE> return date.getUTCDate() - 1;
</PRE><P>});
var utcDays = utcDay.range;
</P><P>function utcWeekday(i) {
</P><PRE> return newInterval(function(date) {
   date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
   date.setUTCHours(0, 0, 0, 0);
 }, function(date, step) {
   date.setUTCDate(date.getUTCDate() + step * 7);
 }, function(start, end) {
   return (end - start) / durationWeek;
 });
</PRE><P>}
</P><P>var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
</P><P>var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;
</P><P>var utcMonth = newInterval(function(date) {
</P><PRE> date.setUTCDate(1);
 date.setUTCHours(0, 0, 0, 0);
</PRE><P>}, function(date, step) {
</P><PRE> date.setUTCMonth(date.getUTCMonth() + step);
</PRE><P>}, function(start, end) {
</P><PRE> return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
</PRE><P>}, function(date) {
</P><PRE> return date.getUTCMonth();
</PRE><P>});
var utcMonths = utcMonth.range;
</P><P>var utcYear = newInterval(function(date) {
</P><PRE> date.setUTCMonth(0, 1);
 date.setUTCHours(0, 0, 0, 0);
</PRE><P>}, function(date, step) {
</P><PRE> date.setUTCFullYear(date.getUTCFullYear() + step);
</PRE><P>}, function(start, end) {
</P><PRE> return end.getUTCFullYear() - start.getUTCFullYear();
</PRE><P>}, function(date) {
</P><PRE> return date.getUTCFullYear();
</PRE><P>});
</P><P>// An optimized implementation for this simple case.
utcYear.every = function(k) {
</P><PRE> return !isFinite(k = Math.floor(k)) || !(k &gt; 0) ? null : newInterval(function(date) {
   date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
   date.setUTCMonth(0, 1);
   date.setUTCHours(0, 0, 0, 0);
 }, function(date, step) {
   date.setUTCFullYear(date.getUTCFullYear() + step * k);
 });
</PRE><P>};
var utcYears = utcYear.range;
</P><P>function localDate(d) {
</P><PRE> if (0 &lt;= d.y &amp;&amp; d.y &lt; 100) {
   var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
   date.setFullYear(d.y);
   return date;
 }
 return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
</PRE><P>}
</P><P>function utcDate(d) {
</P><PRE> if (0 &lt;= d.y &amp;&amp; d.y &lt; 100) {
   var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
   date.setUTCFullYear(d.y);
   return date;
 }
 return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
</PRE><P>}
</P><P>function newYear(y) {
</P><PRE> return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
</PRE><P>}
</P><P>function formatLocale$1(locale) {
</P><PRE> var locale_dateTime = locale.dateTime,
     locale_date = locale.date,
     locale_time = locale.time,
     locale_periods = locale.periods,
     locale_weekdays = locale.days,
     locale_shortWeekdays = locale.shortDays,
     locale_months = locale.months,
     locale_shortMonths = locale.shortMonths;
</PRE><PRE> var periodRe = formatRe(locale_periods),
     periodLookup = formatLookup(locale_periods),
     weekdayRe = formatRe(locale_weekdays),
     weekdayLookup = formatLookup(locale_weekdays),
     shortWeekdayRe = formatRe(locale_shortWeekdays),
     shortWeekdayLookup = formatLookup(locale_shortWeekdays),
     monthRe = formatRe(locale_months),
     monthLookup = formatLookup(locale_months),
     shortMonthRe = formatRe(locale_shortMonths),
     shortMonthLookup = formatLookup(locale_shortMonths);
</PRE><PRE> var formats = {
   &quot;a&quot;: formatShortWeekday,
   &quot;A&quot;: formatWeekday,
   &quot;b&quot;: formatShortMonth,
   &quot;B&quot;: formatMonth,
   &quot;c&quot;: null,
   &quot;d&quot;: formatDayOfMonth,
   &quot;e&quot;: formatDayOfMonth,
   &quot;f&quot;: formatMicroseconds,
   &quot;H&quot;: formatHour24,
   &quot;I&quot;: formatHour12,
   &quot;j&quot;: formatDayOfYear,
   &quot;L&quot;: formatMilliseconds,
   &quot;m&quot;: formatMonthNumber,
   &quot;M&quot;: formatMinutes,
   &quot;p&quot;: formatPeriod,
   &quot;Q&quot;: formatUnixTimestamp,
   &quot;s&quot;: formatUnixTimestampSeconds,
   &quot;S&quot;: formatSeconds,
   &quot;u&quot;: formatWeekdayNumberMonday,
   &quot;U&quot;: formatWeekNumberSunday,
   &quot;V&quot;: formatWeekNumberISO,
   &quot;w&quot;: formatWeekdayNumberSunday,
   &quot;W&quot;: formatWeekNumberMonday,
   &quot;x&quot;: null,
   &quot;X&quot;: null,
   &quot;y&quot;: formatYear,
   &quot;Y&quot;: formatFullYear,
   &quot;Z&quot;: formatZone,
   &quot;%&quot;: formatLiteralPercent
 };
</PRE><PRE> var utcFormats = {
   &quot;a&quot;: formatUTCShortWeekday,
   &quot;A&quot;: formatUTCWeekday,
   &quot;b&quot;: formatUTCShortMonth,
   &quot;B&quot;: formatUTCMonth,
   &quot;c&quot;: null,
   &quot;d&quot;: formatUTCDayOfMonth,
   &quot;e&quot;: formatUTCDayOfMonth,
   &quot;f&quot;: formatUTCMicroseconds,
   &quot;H&quot;: formatUTCHour24,
   &quot;I&quot;: formatUTCHour12,
   &quot;j&quot;: formatUTCDayOfYear,
   &quot;L&quot;: formatUTCMilliseconds,
   &quot;m&quot;: formatUTCMonthNumber,
   &quot;M&quot;: formatUTCMinutes,
   &quot;p&quot;: formatUTCPeriod,
   &quot;Q&quot;: formatUnixTimestamp,
   &quot;s&quot;: formatUnixTimestampSeconds,
   &quot;S&quot;: formatUTCSeconds,
   &quot;u&quot;: formatUTCWeekdayNumberMonday,
   &quot;U&quot;: formatUTCWeekNumberSunday,
   &quot;V&quot;: formatUTCWeekNumberISO,
   &quot;w&quot;: formatUTCWeekdayNumberSunday,
   &quot;W&quot;: formatUTCWeekNumberMonday,
   &quot;x&quot;: null,
   &quot;X&quot;: null,
   &quot;y&quot;: formatUTCYear,
   &quot;Y&quot;: formatUTCFullYear,
   &quot;Z&quot;: formatUTCZone,
   &quot;%&quot;: formatLiteralPercent
 };
</PRE><PRE> var parses = {
   &quot;a&quot;: parseShortWeekday,
   &quot;A&quot;: parseWeekday,
   &quot;b&quot;: parseShortMonth,
   &quot;B&quot;: parseMonth,
   &quot;c&quot;: parseLocaleDateTime,
   &quot;d&quot;: parseDayOfMonth,
   &quot;e&quot;: parseDayOfMonth,
   &quot;f&quot;: parseMicroseconds,
   &quot;H&quot;: parseHour24,
   &quot;I&quot;: parseHour24,
   &quot;j&quot;: parseDayOfYear,
   &quot;L&quot;: parseMilliseconds,
   &quot;m&quot;: parseMonthNumber,
   &quot;M&quot;: parseMinutes,
   &quot;p&quot;: parsePeriod,
   &quot;Q&quot;: parseUnixTimestamp,
   &quot;s&quot;: parseUnixTimestampSeconds,
   &quot;S&quot;: parseSeconds,
   &quot;u&quot;: parseWeekdayNumberMonday,
   &quot;U&quot;: parseWeekNumberSunday,
   &quot;V&quot;: parseWeekNumberISO,
   &quot;w&quot;: parseWeekdayNumberSunday,
   &quot;W&quot;: parseWeekNumberMonday,
   &quot;x&quot;: parseLocaleDate,
   &quot;X&quot;: parseLocaleTime,
   &quot;y&quot;: parseYear,
   &quot;Y&quot;: parseFullYear,
   &quot;Z&quot;: parseZone,
   &quot;%&quot;: parseLiteralPercent
 };
</PRE><PRE> // These recursive directive definitions must be deferred.
 formats.x = newFormat(locale_date, formats);
 formats.X = newFormat(locale_time, formats);
 formats.c = newFormat(locale_dateTime, formats);
 utcFormats.x = newFormat(locale_date, utcFormats);
 utcFormats.X = newFormat(locale_time, utcFormats);
 utcFormats.c = newFormat(locale_dateTime, utcFormats);
</PRE><PRE> function newFormat(specifier, formats) {
   return function(date) {
     var string = [],
         i = -1,
         j = 0,
         n = specifier.length,
         c,
         pad,
         format;
</PRE><PRE>     if (!(date instanceof Date)) date = new Date(+date);
</PRE><PRE>     while (++i &lt; n) {
       if (specifier.charCodeAt(i) === 37) {
         string.push(specifier.slice(j, i));
         if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
         else pad = c === &quot;e&quot; ? &quot; &quot; : &quot;0&quot;;
         if (format = formats[c]) c = format(date, pad);
         string.push(c);
         j = i + 1;
       }
     }
</PRE><PRE>     string.push(specifier.slice(j, i));
     return string.join(&quot;&quot;);
   };
 }
</PRE><PRE> function newParse(specifier, newDate) {
   return function(string) {
     var d = newYear(1900),
         i = parseSpecifier(d, specifier, string += &quot;&quot;, 0),
         week, day$$1;
     if (i != string.length) return null;
</PRE><PRE>     // If a UNIX timestamp is specified, return it.
     if (&quot;Q&quot; in d) return new Date(d.Q);
</PRE><PRE>     // The am-pm flag is 0 for AM, and 1 for PM.
     if (&quot;p&quot; in d) d.H = d.H % 12 + d.p * 12;
</PRE><PRE>     // Convert day-of-week and week-of-year to day-of-year.
     if (&quot;V&quot; in d) {
       if (d.V &lt; 1 || d.V &gt; 53) return null;
       if (!(&quot;w&quot; in d)) d.w = 1;
       if (&quot;Z&quot; in d) {
         week = utcDate(newYear(d.y)), day$$1 = week.getUTCDay();
         week = day$$1 &gt; 4 || day$$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
         week = utcDay.offset(week, (d.V - 1) * 7);
         d.y = week.getUTCFullYear();
         d.m = week.getUTCMonth();
         d.d = week.getUTCDate() + (d.w + 6) % 7;
       } else {
         week = newDate(newYear(d.y)), day$$1 = week.getDay();
         week = day$$1 &gt; 4 || day$$1 === 0 ? monday.ceil(week) : monday(week);
         week = day.offset(week, (d.V - 1) * 7);
         d.y = week.getFullYear();
         d.m = week.getMonth();
         d.d = week.getDate() + (d.w + 6) % 7;
       }
     } else if (&quot;W&quot; in d || &quot;U&quot; in d) {
       if (!(&quot;w&quot; in d)) d.w = &quot;u&quot; in d ? d.u % 7 : &quot;W&quot; in d ? 1 : 0;
       day$$1 = &quot;Z&quot; in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
       d.m = 0;
       d.d = &quot;W&quot; in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
     }
</PRE><PRE>     // If a time zone is specified, all fields are interpreted as UTC and then
     // offset according to the specified time zone.
     if (&quot;Z&quot; in d) {
       d.H += d.Z / 100 | 0;
       d.M += d.Z % 100;
       return utcDate(d);
     }
</PRE><PRE>     // Otherwise, all fields are in local time.
     return newDate(d);
   };
 }
</PRE><PRE> function parseSpecifier(d, specifier, string, j) {
   var i = 0,
       n = specifier.length,
       m = string.length,
       c,
       parse;
</PRE><PRE>   while (i &lt; n) {
     if (j &gt;= m) return -1;
     c = specifier.charCodeAt(i++);
     if (c === 37) {
       c = specifier.charAt(i++);
       parse = parses[c in pads ? specifier.charAt(i++) : c];
       if (!parse || ((j = parse(d, string, j)) &lt; 0)) return -1;
     } else if (c != string.charCodeAt(j++)) {
       return -1;
     }
   }
</PRE><PRE>   return j;
 }
</PRE><PRE> function parsePeriod(d, string, i) {
   var n = periodRe.exec(string.slice(i));
   return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
 }
</PRE><PRE> function parseShortWeekday(d, string, i) {
   var n = shortWeekdayRe.exec(string.slice(i));
   return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
 }
</PRE><PRE> function parseWeekday(d, string, i) {
   var n = weekdayRe.exec(string.slice(i));
   return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
 }
</PRE><PRE> function parseShortMonth(d, string, i) {
   var n = shortMonthRe.exec(string.slice(i));
   return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
 }
</PRE><PRE> function parseMonth(d, string, i) {
   var n = monthRe.exec(string.slice(i));
   return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
 }
</PRE><PRE> function parseLocaleDateTime(d, string, i) {
   return parseSpecifier(d, locale_dateTime, string, i);
 }
</PRE><PRE> function parseLocaleDate(d, string, i) {
   return parseSpecifier(d, locale_date, string, i);
 }
</PRE><PRE> function parseLocaleTime(d, string, i) {
   return parseSpecifier(d, locale_time, string, i);
 }
</PRE><PRE> function formatShortWeekday(d) {
   return locale_shortWeekdays[d.getDay()];
 }
</PRE><PRE> function formatWeekday(d) {
   return locale_weekdays[d.getDay()];
 }
</PRE><PRE> function formatShortMonth(d) {
   return locale_shortMonths[d.getMonth()];
 }
</PRE><PRE> function formatMonth(d) {
   return locale_months[d.getMonth()];
 }
</PRE><PRE> function formatPeriod(d) {
   return locale_periods[+(d.getHours() &gt;= 12)];
 }
</PRE><PRE> function formatUTCShortWeekday(d) {
   return locale_shortWeekdays[d.getUTCDay()];
 }
</PRE><PRE> function formatUTCWeekday(d) {
   return locale_weekdays[d.getUTCDay()];
 }
</PRE><PRE> function formatUTCShortMonth(d) {
   return locale_shortMonths[d.getUTCMonth()];
 }
</PRE><PRE> function formatUTCMonth(d) {
   return locale_months[d.getUTCMonth()];
 }
</PRE><PRE> function formatUTCPeriod(d) {
   return locale_periods[+(d.getUTCHours() &gt;= 12)];
 }
</PRE><PRE> return {
   format: function(specifier) {
     var f = newFormat(specifier += &quot;&quot;, formats);
     f.toString = function() { return specifier; };
     return f;
   },
   parse: function(specifier) {
     var p = newParse(specifier += &quot;&quot;, localDate);
     p.toString = function() { return specifier; };
     return p;
   },
   utcFormat: function(specifier) {
     var f = newFormat(specifier += &quot;&quot;, utcFormats);
     f.toString = function() { return specifier; };
     return f;
   },
   utcParse: function(specifier) {
     var p = newParse(specifier, utcDate);
     p.toString = function() { return specifier; };
     return p;
   }
 };
</PRE><P>}
</P><P>var pads = {&quot;-&quot;: &quot;&quot;, &quot;_&quot;: &quot; &quot;, &quot;0&quot;: &quot;0&quot;},
</P><PRE>   numberRe = /^\s*\d+/, // note: ignores next directive
   percentRe = /^%/,
   requoteRe = /[\\^$*+?|[\]().{}]/g;
</PRE><P>function pad(value, fill, width) {
</P><PRE> var sign = value &lt; 0 ? &quot;-&quot; : &quot;&quot;,
     string = (sign ? -value : value) + &quot;&quot;,
     length = string.length;
 return sign + (length &lt; width ? new Array(width - length + 1).join(fill) + string : string);
</PRE><P>}
</P><P>function requote(s) {
</P><PRE> return s.replace(requoteRe, &quot;\\$&amp;&quot;);
</PRE><P>}
</P><P>function formatRe(names) {
</P><PRE> return new RegExp(&quot;^(?:&quot; + names.map(requote).join(&quot;|&quot;) + &quot;)&quot;, &quot;i&quot;);
</PRE><P>}
</P><P>function formatLookup(names) {
</P><PRE> var map = {}, i = -1, n = names.length;
 while (++i &lt; n) map[names[i].toLowerCase()] = i;
 return map;
</PRE><P>}
</P><P>function parseWeekdayNumberSunday(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 1));
 return n ? (d.w = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseWeekdayNumberMonday(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 1));
 return n ? (d.u = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseWeekNumberSunday(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 2));
 return n ? (d.U = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseWeekNumberISO(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 2));
 return n ? (d.V = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseWeekNumberMonday(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 2));
 return n ? (d.W = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseFullYear(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 4));
 return n ? (d.y = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseYear(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 2));
 return n ? (d.y = +n[0] + (+n[0] &gt; 68 ? 1900 : 2000), i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseZone(d, string, i) {
</P><PRE> var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
 return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || &quot;00&quot;)), i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseMonthNumber(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 2));
 return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseDayOfMonth(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 2));
 return n ? (d.d = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseDayOfYear(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 3));
 return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseHour24(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 2));
 return n ? (d.H = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseMinutes(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 2));
 return n ? (d.M = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseSeconds(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 2));
 return n ? (d.S = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseMilliseconds(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 3));
 return n ? (d.L = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseMicroseconds(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i, i + 6));
 return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseLiteralPercent(d, string, i) {
</P><PRE> var n = percentRe.exec(string.slice(i, i + 1));
 return n ? i + n[0].length : -1;
</PRE><P>}
</P><P>function parseUnixTimestamp(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i));
 return n ? (d.Q = +n[0], i + n[0].length) : -1;
</PRE><P>}
</P><P>function parseUnixTimestampSeconds(d, string, i) {
</P><PRE> var n = numberRe.exec(string.slice(i));
 return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
</PRE><P>}
</P><P>function formatDayOfMonth(d, p) {
</P><PRE> return pad(d.getDate(), p, 2);
</PRE><P>}
</P><P>function formatHour24(d, p) {
</P><PRE> return pad(d.getHours(), p, 2);
</PRE><P>}
</P><P>function formatHour12(d, p) {
</P><PRE> return pad(d.getHours() % 12 || 12, p, 2);
</PRE><P>}
</P><P>function formatDayOfYear(d, p) {
</P><PRE> return pad(1 + day.count(year(d), d), p, 3);
</PRE><P>}
</P><P>function formatMilliseconds(d, p) {
</P><PRE> return pad(d.getMilliseconds(), p, 3);
</PRE><P>}
</P><P>function formatMicroseconds(d, p) {
</P><PRE> return formatMilliseconds(d, p) + &quot;000&quot;;
</PRE><P>}
</P><P>function formatMonthNumber(d, p) {
</P><PRE> return pad(d.getMonth() + 1, p, 2);
</PRE><P>}
</P><P>function formatMinutes(d, p) {
</P><PRE> return pad(d.getMinutes(), p, 2);
</PRE><P>}
</P><P>function formatSeconds(d, p) {
</P><PRE> return pad(d.getSeconds(), p, 2);
</PRE><P>}
</P><P>function formatWeekdayNumberMonday(d) {
</P><PRE> var day$$1 = d.getDay();
 return day$$1 === 0 ? 7 : day$$1;
</PRE><P>}
</P><P>function formatWeekNumberSunday(d, p) {
</P><PRE> return pad(sunday.count(year(d), d), p, 2);
</PRE><P>}
</P><P>function formatWeekNumberISO(d, p) {
</P><PRE> var day$$1 = d.getDay();
 d = (day$$1 &gt;= 4 || day$$1 === 0) ? thursday(d) : thursday.ceil(d);
 return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
</PRE><P>}
</P><P>function formatWeekdayNumberSunday(d) {
</P><PRE> return d.getDay();
</PRE><P>}
</P><P>function formatWeekNumberMonday(d, p) {
</P><PRE> return pad(monday.count(year(d), d), p, 2);
</PRE><P>}
</P><P>function formatYear(d, p) {
</P><PRE> return pad(d.getFullYear() % 100, p, 2);
</PRE><P>}
</P><P>function formatFullYear(d, p) {
</P><PRE> return pad(d.getFullYear() % 10000, p, 4);
</PRE><P>}
</P><P>function formatZone(d) {
</P><PRE> var z = d.getTimezoneOffset();
 return (z &gt; 0 ? &quot;-&quot; : (z *= -1, &quot;+&quot;))
     + pad(z / 60 | 0, &quot;0&quot;, 2)
     + pad(z % 60, &quot;0&quot;, 2);
</PRE><P>}
</P><P>function formatUTCDayOfMonth(d, p) {
</P><PRE> return pad(d.getUTCDate(), p, 2);
</PRE><P>}
</P><P>function formatUTCHour24(d, p) {
</P><PRE> return pad(d.getUTCHours(), p, 2);
</PRE><P>}
</P><P>function formatUTCHour12(d, p) {
</P><PRE> return pad(d.getUTCHours() % 12 || 12, p, 2);
</PRE><P>}
</P><P>function formatUTCDayOfYear(d, p) {
</P><PRE> return pad(1 + utcDay.count(utcYear(d), d), p, 3);
</PRE><P>}
</P><P>function formatUTCMilliseconds(d, p) {
</P><PRE> return pad(d.getUTCMilliseconds(), p, 3);
</PRE><P>}
</P><P>function formatUTCMicroseconds(d, p) {
</P><PRE> return formatUTCMilliseconds(d, p) + &quot;000&quot;;
</PRE><P>}
</P><P>function formatUTCMonthNumber(d, p) {
</P><PRE> return pad(d.getUTCMonth() + 1, p, 2);
</PRE><P>}
</P><P>function formatUTCMinutes(d, p) {
</P><PRE> return pad(d.getUTCMinutes(), p, 2);
</PRE><P>}
</P><P>function formatUTCSeconds(d, p) {
</P><PRE> return pad(d.getUTCSeconds(), p, 2);
</PRE><P>}
</P><P>function formatUTCWeekdayNumberMonday(d) {
</P><PRE> var dow = d.getUTCDay();
 return dow === 0 ? 7 : dow;
</PRE><P>}
</P><P>function formatUTCWeekNumberSunday(d, p) {
</P><PRE> return pad(utcSunday.count(utcYear(d), d), p, 2);
</PRE><P>}
</P><P>function formatUTCWeekNumberISO(d, p) {
</P><PRE> var day$$1 = d.getUTCDay();
 d = (day$$1 &gt;= 4 || day$$1 === 0) ? utcThursday(d) : utcThursday.ceil(d);
 return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
</PRE><P>}
</P><P>function formatUTCWeekdayNumberSunday(d) {
</P><PRE> return d.getUTCDay();
</PRE><P>}
</P><P>function formatUTCWeekNumberMonday(d, p) {
</P><PRE> return pad(utcMonday.count(utcYear(d), d), p, 2);
</PRE><P>}
</P><P>function formatUTCYear(d, p) {
</P><PRE> return pad(d.getUTCFullYear() % 100, p, 2);
</PRE><P>}
</P><P>function formatUTCFullYear(d, p) {
</P><PRE> return pad(d.getUTCFullYear() % 10000, p, 4);
</PRE><P>}
</P><P>function formatUTCZone() {
</P><PRE> return &quot;+0000&quot;;
</PRE><P>}
</P><P>function formatLiteralPercent() {
</P><PRE> return &quot;%&quot;;
</PRE><P>}
</P><P>function formatUnixTimestamp(d) {
</P><PRE> return +d;
</PRE><P>}
</P><P>function formatUnixTimestampSeconds(d) {
</P><PRE> return Math.floor(+d / 1000);
</PRE><P>}
</P><P>var locale$1;
</P><P>defaultLocale$1({
</P><PRE> dateTime: &quot;%x, %X&quot;,
 date: &quot;%-m/%-d/%Y&quot;,
 time: &quot;%-I:%M:%S %p&quot;,
 periods: [&quot;AM&quot;, &quot;PM&quot;],
 days: [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;],
 shortDays: [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;],
 months: [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;],
 shortMonths: [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]
</PRE><P>});
</P><P>function defaultLocale$1(definition) {
</P><PRE> locale$1 = formatLocale$1(definition);
 exports.timeFormat = locale$1.format;
 exports.timeParse = locale$1.parse;
 exports.utcFormat = locale$1.utcFormat;
 exports.utcParse = locale$1.utcParse;
 return locale$1;
</PRE><P>}
</P><P>var isoSpecifier = &quot;%Y-%m-%dT%H:%M:%S.%LZ&quot;;
</P><P>function formatIsoNative(date) {
</P><PRE> return date.toISOString();
</PRE><P>}
</P><P>var formatIso = Date.prototype.toISOString
</P><PRE> ? formatIsoNative
   : exports.utcFormat(isoSpecifier);
</PRE><P>function parseIsoNative(string) {
</P><PRE> var date = new Date(string);
 return isNaN(date) ? null : date;
</PRE><P>}
</P><P>var parseIso = +new Date(&quot;2000-01-01T00:00:00.000Z&quot;)
</P><PRE> ? parseIsoNative
   : exports.utcParse(isoSpecifier);
</PRE><P>var durationSecond$1 = 1000,
</P><PRE>   durationMinute$1 = durationSecond$1 * 60,
   durationHour$1 = durationMinute$1 * 60,
   durationDay$1 = durationHour$1 * 24,
   durationWeek$1 = durationDay$1 * 7,
   durationMonth = durationDay$1 * 30,
   durationYear = durationDay$1 * 365;
</PRE><P>function date$1(t) {
</P><PRE> return new Date(t);
</PRE><P>}
</P><P>function number$3(t) {
</P><PRE> return t instanceof Date ? +t : +new Date(+t);
</PRE><P>}
</P><P>function calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {
</P><PRE> var scale = continuous(deinterpolateLinear, interpolateNumber),
     invert = scale.invert,
     domain = scale.domain;
</PRE><PRE> var formatMillisecond = format(&quot;.%L&quot;),
     formatSecond = format(&quot;:%S&quot;),
     formatMinute = format(&quot;%I:%M&quot;),
     formatHour = format(&quot;%I %p&quot;),
     formatDay = format(&quot;%a %d&quot;),
     formatWeek = format(&quot;%b %d&quot;),
     formatMonth = format(&quot;%B&quot;),
     formatYear = format(&quot;%Y&quot;);
</PRE><PRE> var tickIntervals = [
   [second$$1,  1,      durationSecond$1],
   [second$$1,  5,  5 * durationSecond$1],
   [second$$1, 15, 15 * durationSecond$1],
   [second$$1, 30, 30 * durationSecond$1],
   [minute$$1,  1,      durationMinute$1],
   [minute$$1,  5,  5 * durationMinute$1],
   [minute$$1, 15, 15 * durationMinute$1],
   [minute$$1, 30, 30 * durationMinute$1],
   [  hour$$1,  1,      durationHour$1  ],
   [  hour$$1,  3,  3 * durationHour$1  ],
   [  hour$$1,  6,  6 * durationHour$1  ],
   [  hour$$1, 12, 12 * durationHour$1  ],
   [   day$$1,  1,      durationDay$1   ],
   [   day$$1,  2,  2 * durationDay$1   ],
   [  week,  1,      durationWeek$1  ],
   [ month$$1,  1,      durationMonth ],
   [ month$$1,  3,  3 * durationMonth ],
   [  year$$1,  1,      durationYear  ]
 ];
</PRE><PRE> function tickFormat(date$$1) {
   return (second$$1(date$$1) &lt; date$$1 ? formatMillisecond
       : minute$$1(date$$1) &lt; date$$1 ? formatSecond
       : hour$$1(date$$1) &lt; date$$1 ? formatMinute
       : day$$1(date$$1) &lt; date$$1 ? formatHour
       : month$$1(date$$1) &lt; date$$1 ? (week(date$$1) &lt; date$$1 ? formatDay : formatWeek)
       : year$$1(date$$1) &lt; date$$1 ? formatMonth
       : formatYear)(date$$1);
 }
</PRE><PRE> function tickInterval(interval, start, stop, step) {
   if (interval == null) interval = 10;
</PRE><PRE>   // If a desired tick count is specified, pick a reasonable tick interval
   // based on the extent of the domain and a rough estimate of tick size.
   // Otherwise, assume interval is already a time interval and use it.
   if (typeof interval === &quot;number&quot;) {
     var target = Math.abs(stop - start) / interval,
         i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);
     if (i === tickIntervals.length) {
       step = tickStep(start / durationYear, stop / durationYear, interval);
       interval = year$$1;
     } else if (i) {
       i = tickIntervals[target / tickIntervals[i - 1][2] &lt; tickIntervals[i][2] / target ? i - 1 : i];
       step = i[1];
       interval = i[0];
     } else {
       step = Math.max(tickStep(start, stop, interval), 1);
       interval = millisecond$$1;
     }
   }
</PRE><PRE>   return step == null ? interval : interval.every(step);
 }
</PRE><PRE> scale.invert = function(y) {
   return new Date(invert(y));
 };
</PRE><PRE> scale.domain = function(_) {
   return arguments.length ? domain(map$2.call(_, number$3)) : domain().map(date$1);
 };
</PRE><PRE> scale.ticks = function(interval, step) {
   var d = domain(),
       t0 = d[0],
       t1 = d[d.length - 1],
       r = t1 &lt; t0,
       t;
   if (r) t = t0, t0 = t1, t1 = t;
   t = tickInterval(interval, t0, t1, step);
   t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
   return r ? t.reverse() : t;
 };
</PRE><PRE> scale.tickFormat = function(count, specifier) {
   return specifier == null ? tickFormat : format(specifier);
 };
</PRE><PRE> scale.nice = function(interval, step) {
   var d = domain();
   return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
       ? domain(nice(d, interval))
       : scale;
 };
</PRE><PRE> scale.copy = function() {
   return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));
 };
</PRE><PRE> return scale;
</PRE><P>}
</P><P>function time() {
</P><PRE> return calendar(year, month, sunday, day, hour, minute, second, millisecond, exports.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
</PRE><P>}
</P><P>function utcTime() {
</P><PRE> return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, exports.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
</PRE><P>}
</P><P>function sequential(interpolator) {
</P><PRE> var x0 = 0,
     x1 = 1,
     k10 = 1,
     clamp = false;
</PRE><PRE> function scale(x) {
   var t = (x - x0) * k10;
   return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
 }
</PRE><PRE> scale.domain = function(_) {
   return arguments.length ? (x0 = +_[0], x1 = +_[1], k10 = x0 === x1 ? 0 : 1 / (x1 - x0), scale) : [x0, x1];
 };
</PRE><PRE> scale.clamp = function(_) {
   return arguments.length ? (clamp = !!_, scale) : clamp;
 };
</PRE><PRE> scale.interpolator = function(_) {
   return arguments.length ? (interpolator = _, scale) : interpolator;
 };
</PRE><PRE> scale.copy = function() {
   return sequential(interpolator).domain([x0, x1]).clamp(clamp);
 };
</PRE><PRE> return linearish(scale);
</PRE><P>}
</P><P>function diverging(interpolator) {
</P><PRE> var x0 = 0,
     x1 = 0.5,
     x2 = 1,
     k10 = 1,
     k21 = 1,
     clamp = false;
</PRE><PRE> function scale(x) {
   var t = 0.5 + ((x = +x) - x1) * (x &lt; x1 ? k10 : k21);
   return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
 }
</PRE><PRE> scale.domain = function(_) {
   return arguments.length ? (x0 = +_[0], x1 = +_[1], x2 = +_[2], k10 = x0 === x1 ? 0 : 0.5 / (x1 - x0), k21 = x1 === x2 ? 0 : 0.5 / (x2 - x1), scale) : [x0, x1, x2];
 };
</PRE><PRE> scale.clamp = function(_) {
   return arguments.length ? (clamp = !!_, scale) : clamp;
 };
</PRE><PRE> scale.interpolator = function(_) {
   return arguments.length ? (interpolator = _, scale) : interpolator;
 };
</PRE><PRE> scale.copy = function() {
   return diverging(interpolator).domain([x0, x1, x2]).clamp(clamp);
 };
</PRE><PRE> return linearish(scale);
</PRE><P>}
</P><P>function colors(specifier) {
</P><PRE> var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
 while (i &lt; n) colors[i] = &quot;#&quot; + specifier.slice(i * 6, ++i * 6);
 return colors;
</PRE><P>}
</P><P>var category10 = colors(&quot;1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf&quot;);
</P><P>var Accent = colors(&quot;7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666&quot;);
</P><P>var Dark2 = colors(&quot;1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666&quot;);
</P><P>var Paired = colors(&quot;a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928&quot;);
</P><P>var Pastel1 = colors(&quot;fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2&quot;);
</P><P>var Pastel2 = colors(&quot;b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc&quot;);
</P><P>var Set1 = colors(&quot;e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999&quot;);
</P><P>var Set2 = colors(&quot;66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3&quot;);
</P><P>var Set3 = colors(&quot;8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f&quot;);
</P><P>function ramp(scheme) {
</P><PRE> return rgbBasis(scheme[scheme.length - 1]);
</PRE><P>}
</P><P>var scheme = new Array(3).concat(
</P><PRE> &quot;d8b365f5f5f55ab4ac&quot;,
 &quot;a6611adfc27d80cdc1018571&quot;,
 &quot;a6611adfc27df5f5f580cdc1018571&quot;,
 &quot;8c510ad8b365f6e8c3c7eae55ab4ac01665e&quot;,
 &quot;8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e&quot;,
 &quot;8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e&quot;,
 &quot;8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e&quot;,
 &quot;5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30&quot;,
 &quot;5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30&quot;
</PRE><P>).map(colors);
</P><P>var BrBG = ramp(scheme);
</P><P>var scheme$1 = new Array(3).concat(
</P><PRE> &quot;af8dc3f7f7f77fbf7b&quot;,
 &quot;7b3294c2a5cfa6dba0008837&quot;,
 &quot;7b3294c2a5cff7f7f7a6dba0008837&quot;,
 &quot;762a83af8dc3e7d4e8d9f0d37fbf7b1b7837&quot;,
 &quot;762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837&quot;,
 &quot;762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837&quot;,
 &quot;762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837&quot;,
 &quot;40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b&quot;,
 &quot;40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b&quot;
</PRE><P>).map(colors);
</P><P>var PRGn = ramp(scheme$1);
</P><P>var scheme$2 = new Array(3).concat(
</P><PRE> &quot;e9a3c9f7f7f7a1d76a&quot;,
 &quot;d01c8bf1b6dab8e1864dac26&quot;,
 &quot;d01c8bf1b6daf7f7f7b8e1864dac26&quot;,
 &quot;c51b7de9a3c9fde0efe6f5d0a1d76a4d9221&quot;,
 &quot;c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221&quot;,
 &quot;c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221&quot;,
 &quot;c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221&quot;,
 &quot;8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419&quot;,
 &quot;8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419&quot;
</PRE><P>).map(colors);
</P><P>var PiYG = ramp(scheme$2);
</P><P>var scheme$3 = new Array(3).concat(
</P><PRE> &quot;998ec3f7f7f7f1a340&quot;,
 &quot;5e3c99b2abd2fdb863e66101&quot;,
 &quot;5e3c99b2abd2f7f7f7fdb863e66101&quot;,
 &quot;542788998ec3d8daebfee0b6f1a340b35806&quot;,
 &quot;542788998ec3d8daebf7f7f7fee0b6f1a340b35806&quot;,
 &quot;5427888073acb2abd2d8daebfee0b6fdb863e08214b35806&quot;,
 &quot;5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806&quot;,
 &quot;2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08&quot;,
 &quot;2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08&quot;
</PRE><P>).map(colors);
</P><P>var PuOr = ramp(scheme$3);
</P><P>var scheme$4 = new Array(3).concat(
</P><PRE> &quot;ef8a62f7f7f767a9cf&quot;,
 &quot;ca0020f4a58292c5de0571b0&quot;,
 &quot;ca0020f4a582f7f7f792c5de0571b0&quot;,
 &quot;b2182bef8a62fddbc7d1e5f067a9cf2166ac&quot;,
 &quot;b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac&quot;,
 &quot;b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac&quot;,
 &quot;b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac&quot;,
 &quot;67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061&quot;,
 &quot;67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061&quot;
</PRE><P>).map(colors);
</P><P>var RdBu = ramp(scheme$4);
</P><P>var scheme$5 = new Array(3).concat(
</P><PRE> &quot;ef8a62ffffff999999&quot;,
 &quot;ca0020f4a582bababa404040&quot;,
 &quot;ca0020f4a582ffffffbababa404040&quot;,
 &quot;b2182bef8a62fddbc7e0e0e09999994d4d4d&quot;,
 &quot;b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d&quot;,
 &quot;b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d&quot;,
 &quot;b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d&quot;,
 &quot;67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a&quot;,
 &quot;67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a&quot;
</PRE><P>).map(colors);
</P><P>var RdGy = ramp(scheme$5);
</P><P>var scheme$6 = new Array(3).concat(
</P><PRE> &quot;fc8d59ffffbf91bfdb&quot;,
 &quot;d7191cfdae61abd9e92c7bb6&quot;,
 &quot;d7191cfdae61ffffbfabd9e92c7bb6&quot;,
 &quot;d73027fc8d59fee090e0f3f891bfdb4575b4&quot;,
 &quot;d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4&quot;,
 &quot;d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4&quot;,
 &quot;d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4&quot;,
 &quot;a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695&quot;,
 &quot;a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695&quot;
</PRE><P>).map(colors);
</P><P>var RdYlBu = ramp(scheme$6);
</P><P>var scheme$7 = new Array(3).concat(
</P><PRE> &quot;fc8d59ffffbf91cf60&quot;,
 &quot;d7191cfdae61a6d96a1a9641&quot;,
 &quot;d7191cfdae61ffffbfa6d96a1a9641&quot;,
 &quot;d73027fc8d59fee08bd9ef8b91cf601a9850&quot;,
 &quot;d73027fc8d59fee08bffffbfd9ef8b91cf601a9850&quot;,
 &quot;d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850&quot;,
 &quot;d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850&quot;,
 &quot;a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837&quot;,
 &quot;a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837&quot;
</PRE><P>).map(colors);
</P><P>var RdYlGn = ramp(scheme$7);
</P><P>var scheme$8 = new Array(3).concat(
</P><PRE> &quot;fc8d59ffffbf99d594&quot;,
 &quot;d7191cfdae61abdda42b83ba&quot;,
 &quot;d7191cfdae61ffffbfabdda42b83ba&quot;,
 &quot;d53e4ffc8d59fee08be6f59899d5943288bd&quot;,
 &quot;d53e4ffc8d59fee08bffffbfe6f59899d5943288bd&quot;,
 &quot;d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd&quot;,
 &quot;d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd&quot;,
 &quot;9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2&quot;,
 &quot;9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2&quot;
</PRE><P>).map(colors);
</P><P>var Spectral = ramp(scheme$8);
</P><P>var scheme$9 = new Array(3).concat(
</P><PRE> &quot;e5f5f999d8c92ca25f&quot;,
 &quot;edf8fbb2e2e266c2a4238b45&quot;,
 &quot;edf8fbb2e2e266c2a42ca25f006d2c&quot;,
 &quot;edf8fbccece699d8c966c2a42ca25f006d2c&quot;,
 &quot;edf8fbccece699d8c966c2a441ae76238b45005824&quot;,
 &quot;f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824&quot;,
 &quot;f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b&quot;
</PRE><P>).map(colors);
</P><P>var BuGn = ramp(scheme$9);
</P><P>var scheme$a = new Array(3).concat(
</P><PRE> &quot;e0ecf49ebcda8856a7&quot;,
 &quot;edf8fbb3cde38c96c688419d&quot;,
 &quot;edf8fbb3cde38c96c68856a7810f7c&quot;,
 &quot;edf8fbbfd3e69ebcda8c96c68856a7810f7c&quot;,
 &quot;edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b&quot;,
 &quot;f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b&quot;,
 &quot;f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b&quot;
</PRE><P>).map(colors);
</P><P>var BuPu = ramp(scheme$a);
</P><P>var scheme$b = new Array(3).concat(
</P><PRE> &quot;e0f3dba8ddb543a2ca&quot;,
 &quot;f0f9e8bae4bc7bccc42b8cbe&quot;,
 &quot;f0f9e8bae4bc7bccc443a2ca0868ac&quot;,
 &quot;f0f9e8ccebc5a8ddb57bccc443a2ca0868ac&quot;,
 &quot;f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e&quot;,
 &quot;f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e&quot;,
 &quot;f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081&quot;
</PRE><P>).map(colors);
</P><P>var GnBu = ramp(scheme$b);
</P><P>var scheme$c = new Array(3).concat(
</P><PRE> &quot;fee8c8fdbb84e34a33&quot;,
 &quot;fef0d9fdcc8afc8d59d7301f&quot;,
 &quot;fef0d9fdcc8afc8d59e34a33b30000&quot;,
 &quot;fef0d9fdd49efdbb84fc8d59e34a33b30000&quot;,
 &quot;fef0d9fdd49efdbb84fc8d59ef6548d7301f990000&quot;,
 &quot;fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000&quot;,
 &quot;fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000&quot;
</PRE><P>).map(colors);
</P><P>var OrRd = ramp(scheme$c);
</P><P>var scheme$d = new Array(3).concat(
</P><PRE> &quot;ece2f0a6bddb1c9099&quot;,
 &quot;f6eff7bdc9e167a9cf02818a&quot;,
 &quot;f6eff7bdc9e167a9cf1c9099016c59&quot;,
 &quot;f6eff7d0d1e6a6bddb67a9cf1c9099016c59&quot;,
 &quot;f6eff7d0d1e6a6bddb67a9cf3690c002818a016450&quot;,
 &quot;fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450&quot;,
 &quot;fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636&quot;
</PRE><P>).map(colors);
</P><P>var PuBuGn = ramp(scheme$d);
</P><P>var scheme$e = new Array(3).concat(
</P><PRE> &quot;ece7f2a6bddb2b8cbe&quot;,
 &quot;f1eef6bdc9e174a9cf0570b0&quot;,
 &quot;f1eef6bdc9e174a9cf2b8cbe045a8d&quot;,
 &quot;f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d&quot;,
 &quot;f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b&quot;,
 &quot;fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b&quot;,
 &quot;fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858&quot;
</PRE><P>).map(colors);
</P><P>var PuBu = ramp(scheme$e);
</P><P>var scheme$f = new Array(3).concat(
</P><PRE> &quot;e7e1efc994c7dd1c77&quot;,
 &quot;f1eef6d7b5d8df65b0ce1256&quot;,
 &quot;f1eef6d7b5d8df65b0dd1c77980043&quot;,
 &quot;f1eef6d4b9dac994c7df65b0dd1c77980043&quot;,
 &quot;f1eef6d4b9dac994c7df65b0e7298ace125691003f&quot;,
 &quot;f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f&quot;,
 &quot;f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f&quot;
</PRE><P>).map(colors);
</P><P>var PuRd = ramp(scheme$f);
</P><P>var scheme$g = new Array(3).concat(
</P><PRE> &quot;fde0ddfa9fb5c51b8a&quot;,
 &quot;feebe2fbb4b9f768a1ae017e&quot;,
 &quot;feebe2fbb4b9f768a1c51b8a7a0177&quot;,
 &quot;feebe2fcc5c0fa9fb5f768a1c51b8a7a0177&quot;,
 &quot;feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177&quot;,
 &quot;fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177&quot;,
 &quot;fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a&quot;
</PRE><P>).map(colors);
</P><P>var RdPu = ramp(scheme$g);
</P><P>var scheme$h = new Array(3).concat(
</P><PRE> &quot;edf8b17fcdbb2c7fb8&quot;,
 &quot;ffffcca1dab441b6c4225ea8&quot;,
 &quot;ffffcca1dab441b6c42c7fb8253494&quot;,
 &quot;ffffccc7e9b47fcdbb41b6c42c7fb8253494&quot;,
 &quot;ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84&quot;,
 &quot;ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84&quot;,
 &quot;ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58&quot;
</PRE><P>).map(colors);
</P><P>var YlGnBu = ramp(scheme$h);
</P><P>var scheme$i = new Array(3).concat(
</P><PRE> &quot;f7fcb9addd8e31a354&quot;,
 &quot;ffffccc2e69978c679238443&quot;,
 &quot;ffffccc2e69978c67931a354006837&quot;,
 &quot;ffffccd9f0a3addd8e78c67931a354006837&quot;,
 &quot;ffffccd9f0a3addd8e78c67941ab5d238443005a32&quot;,
 &quot;ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32&quot;,
 &quot;ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529&quot;
</PRE><P>).map(colors);
</P><P>var YlGn = ramp(scheme$i);
</P><P>var scheme$j = new Array(3).concat(
</P><PRE> &quot;fff7bcfec44fd95f0e&quot;,
 &quot;ffffd4fed98efe9929cc4c02&quot;,
 &quot;ffffd4fed98efe9929d95f0e993404&quot;,
 &quot;ffffd4fee391fec44ffe9929d95f0e993404&quot;,
 &quot;ffffd4fee391fec44ffe9929ec7014cc4c028c2d04&quot;,
 &quot;ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04&quot;,
 &quot;ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506&quot;
</PRE><P>).map(colors);
</P><P>var YlOrBr = ramp(scheme$j);
</P><P>var scheme$k = new Array(3).concat(
</P><PRE> &quot;ffeda0feb24cf03b20&quot;,
 &quot;ffffb2fecc5cfd8d3ce31a1c&quot;,
 &quot;ffffb2fecc5cfd8d3cf03b20bd0026&quot;,
 &quot;ffffb2fed976feb24cfd8d3cf03b20bd0026&quot;,
 &quot;ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026&quot;,
 &quot;ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026&quot;,
 &quot;ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026&quot;
</PRE><P>).map(colors);
</P><P>var YlOrRd = ramp(scheme$k);
</P><P>var scheme$l = new Array(3).concat(
</P><PRE> &quot;deebf79ecae13182bd&quot;,
 &quot;eff3ffbdd7e76baed62171b5&quot;,
 &quot;eff3ffbdd7e76baed63182bd08519c&quot;,
 &quot;eff3ffc6dbef9ecae16baed63182bd08519c&quot;,
 &quot;eff3ffc6dbef9ecae16baed64292c62171b5084594&quot;,
 &quot;f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594&quot;,
 &quot;f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b&quot;
</PRE><P>).map(colors);
</P><P>var Blues = ramp(scheme$l);
</P><P>var scheme$m = new Array(3).concat(
</P><PRE> &quot;e5f5e0a1d99b31a354&quot;,
 &quot;edf8e9bae4b374c476238b45&quot;,
 &quot;edf8e9bae4b374c47631a354006d2c&quot;,
 &quot;edf8e9c7e9c0a1d99b74c47631a354006d2c&quot;,
 &quot;edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32&quot;,
 &quot;f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32&quot;,
 &quot;f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b&quot;
</PRE><P>).map(colors);
</P><P>var Greens = ramp(scheme$m);
</P><P>var scheme$n = new Array(3).concat(
</P><PRE> &quot;f0f0f0bdbdbd636363&quot;,
 &quot;f7f7f7cccccc969696525252&quot;,
 &quot;f7f7f7cccccc969696636363252525&quot;,
 &quot;f7f7f7d9d9d9bdbdbd969696636363252525&quot;,
 &quot;f7f7f7d9d9d9bdbdbd969696737373525252252525&quot;,
 &quot;fffffff0f0f0d9d9d9bdbdbd969696737373525252252525&quot;,
 &quot;fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000&quot;
</PRE><P>).map(colors);
</P><P>var Greys = ramp(scheme$n);
</P><P>var scheme$o = new Array(3).concat(
</P><PRE> &quot;efedf5bcbddc756bb1&quot;,
 &quot;f2f0f7cbc9e29e9ac86a51a3&quot;,
 &quot;f2f0f7cbc9e29e9ac8756bb154278f&quot;,
 &quot;f2f0f7dadaebbcbddc9e9ac8756bb154278f&quot;,
 &quot;f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486&quot;,
 &quot;fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486&quot;,
 &quot;fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d&quot;
</PRE><P>).map(colors);
</P><P>var Purples = ramp(scheme$o);
</P><P>var scheme$p = new Array(3).concat(
</P><PRE> &quot;fee0d2fc9272de2d26&quot;,
 &quot;fee5d9fcae91fb6a4acb181d&quot;,
 &quot;fee5d9fcae91fb6a4ade2d26a50f15&quot;,
 &quot;fee5d9fcbba1fc9272fb6a4ade2d26a50f15&quot;,
 &quot;fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d&quot;,
 &quot;fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d&quot;,
 &quot;fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d&quot;
</PRE><P>).map(colors);
</P><P>var Reds = ramp(scheme$p);
</P><P>var scheme$q = new Array(3).concat(
</P><PRE> &quot;fee6cefdae6be6550d&quot;,
 &quot;feeddefdbe85fd8d3cd94701&quot;,
 &quot;feeddefdbe85fd8d3ce6550da63603&quot;,
 &quot;feeddefdd0a2fdae6bfd8d3ce6550da63603&quot;,
 &quot;feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04&quot;,
 &quot;fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04&quot;,
 &quot;fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704&quot;
</PRE><P>).map(colors);
</P><P>var Oranges = ramp(scheme$q);
</P><P>var cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));
</P><P>var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
</P><P>var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
</P><P>var c = cubehelix();
</P><P>function rainbow(t) {
</P><PRE> if (t &lt; 0 || t &gt; 1) t -= Math.floor(t);
 var ts = Math.abs(t - 0.5);
 c.h = 360 * t - 100;
 c.s = 1.5 - 1.5 * ts;
 c.l = 0.8 - 0.9 * ts;
 return c + &quot;&quot;;
</PRE><P>}
</P><P>var c$1 = rgb(),
</P><PRE>   pi_1_3 = Math.PI / 3,
   pi_2_3 = Math.PI * 2 / 3;
</PRE><P>function sinebow(t) {
</P><PRE> var x;
 t = (0.5 - t) * Math.PI;
 c$1.r = 255 * (x = Math.sin(t)) * x;
 c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
 c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
 return c$1 + &quot;&quot;;
</PRE><P>}
</P><P>function ramp$1(range) {
</P><PRE> var n = range.length;
 return function(t) {
   return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
 };
</PRE><P>}
</P><P>var viridis = ramp$1(colors(&quot;44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725&quot;));
</P><P>var magma = ramp$1(colors(&quot;00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf&quot;));
</P><P>var inferno = ramp$1(colors(&quot;00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4&quot;));
</P><P>var plasma = ramp$1(colors(&quot;0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921&quot;));
</P><P>function constant$b(x) {
</P><PRE> return function constant() {
   return x;
 };
</PRE><P>}
</P><P>var abs$1 = Math.abs;
var atan2$1 = Math.atan2;
var cos$2 = Math.cos;
var max$2 = Math.max;
var min$1 = Math.min;
var sin$2 = Math.sin;
var sqrt$2 = Math.sqrt;
</P><P>var epsilon$3 = 1e-12;
var pi$4 = Math.PI;
var halfPi$3 = pi$4 / 2;
var tau$4 = 2 * pi$4;
</P><P>function acos$1(x) {
</P><PRE> return x &gt; 1 ? 0 : x &lt; -1 ? pi$4 : Math.acos(x);
</PRE><P>}
</P><P>function asin$1(x) {
</P><PRE> return x &gt;= 1 ? halfPi$3 : x &lt;= -1 ? -halfPi$3 : Math.asin(x);
</PRE><P>}
</P><P>function arcInnerRadius(d) {
</P><PRE> return d.innerRadius;
</PRE><P>}
</P><P>function arcOuterRadius(d) {
</P><PRE> return d.outerRadius;
</PRE><P>}
</P><P>function arcStartAngle(d) {
</P><PRE> return d.startAngle;
</PRE><P>}
</P><P>function arcEndAngle(d) {
</P><PRE> return d.endAngle;
</PRE><P>}
</P><P>function arcPadAngle(d) {
</P><PRE> return d &amp;&amp; d.padAngle; // Note: optional!
</PRE><P>}
</P><P>function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
</P><PRE> var x10 = x1 - x0, y10 = y1 - y0,
     x32 = x3 - x2, y32 = y3 - y2,
     t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
 return [x0 + t * x10, y0 + t * y10];
</PRE><P>}
</P><P>// Compute perpendicular offset line of length rc.
// <A rel="nofollow" class="external free" href="http://mathworld.wolfram.com/Circle-LineIntersection.html">http://mathworld.wolfram.com/Circle-LineIntersection.html</A>
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
</P><PRE> var x01 = x0 - x1,
     y01 = y0 - y1,
     lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),
     ox = lo * y01,
     oy = -lo * x01,
     x11 = x0 + ox,
     y11 = y0 + oy,
     x10 = x1 + ox,
     y10 = y1 + oy,
     x00 = (x11 + x10) / 2,
     y00 = (y11 + y10) / 2,
     dx = x10 - x11,
     dy = y10 - y11,
     d2 = dx * dx + dy * dy,
     r = r1 - rc,
     D = x11 * y10 - x10 * y11,
     d = (dy &lt; 0 ? -1 : 1) * sqrt$2(max$2(0, r * r * d2 - D * D)),
     cx0 = (D * dy - dx * d) / d2,
     cy0 = (-D * dx - dy * d) / d2,
     cx1 = (D * dy + dx * d) / d2,
     cy1 = (-D * dx + dy * d) / d2,
     dx0 = cx0 - x00,
     dy0 = cy0 - y00,
     dx1 = cx1 - x00,
     dy1 = cy1 - y00;
</PRE><PRE> // Pick the closer of the two intersection points.
 // TODO Is there a faster way to determine which intersection to use?
 if (dx0 * dx0 + dy0 * dy0 &gt; dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
</PRE><PRE> return {
   cx: cx0,
   cy: cy0,
   x01: -ox,
   y01: -oy,
   x11: cx0 * (r1 / r - 1),
   y11: cy0 * (r1 / r - 1)
 };
</PRE><P>}
</P><P>function arc() {
</P><PRE> var innerRadius = arcInnerRadius,
     outerRadius = arcOuterRadius,
     cornerRadius = constant$b(0),
     padRadius = null,
     startAngle = arcStartAngle,
     endAngle = arcEndAngle,
     padAngle = arcPadAngle,
     context = null;
</PRE><PRE> function arc() {
   var buffer,
       r,
       r0 = +innerRadius.apply(this, arguments),
       r1 = +outerRadius.apply(this, arguments),
       a0 = startAngle.apply(this, arguments) - halfPi$3,
       a1 = endAngle.apply(this, arguments) - halfPi$3,
       da = abs$1(a1 - a0),
       cw = a1 &gt; a0;
</PRE><PRE>   if (!context) context = buffer = path();
</PRE><PRE>   // Ensure that the outer radius is always larger than the inner radius.
   if (r1 &lt; r0) r = r1, r1 = r0, r0 = r;
</PRE><PRE>   // Is it a point?
   if (!(r1 &gt; epsilon$3)) context.moveTo(0, 0);
</PRE><PRE>   // Or is it a circle or annulus?
   else if (da &gt; tau$4 - epsilon$3) {
     context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
     context.arc(0, 0, r1, a0, a1, !cw);
     if (r0 &gt; epsilon$3) {
       context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
       context.arc(0, 0, r0, a1, a0, cw);
     }
   }
</PRE><PRE>   // Or is it a circular or annular sector?
   else {
     var a01 = a0,
         a11 = a1,
         a00 = a0,
         a10 = a1,
         da0 = da,
         da1 = da,
         ap = padAngle.apply(this, arguments) / 2,
         rp = (ap &gt; epsilon$3) &amp;&amp; (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),
         rc = min$1(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
         rc0 = rc,
         rc1 = rc,
         t0,
         t1;
</PRE><PRE>     // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
     if (rp &gt; epsilon$3) {
       var p0 = asin$1(rp / r0 * sin$2(ap)),
           p1 = asin$1(rp / r1 * sin$2(ap));
       if ((da0 -= p0 * 2) &gt; epsilon$3) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
       else da0 = 0, a00 = a10 = (a0 + a1) / 2;
       if ((da1 -= p1 * 2) &gt; epsilon$3) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
       else da1 = 0, a01 = a11 = (a0 + a1) / 2;
     }
</PRE><PRE>     var x01 = r1 * cos$2(a01),
         y01 = r1 * sin$2(a01),
         x10 = r0 * cos$2(a10),
         y10 = r0 * sin$2(a10);
</PRE><PRE>     // Apply rounded corners?
     if (rc &gt; epsilon$3) {
       var x11 = r1 * cos$2(a11),
           y11 = r1 * sin$2(a11),
           x00 = r0 * cos$2(a00),
           y00 = r0 * sin$2(a00);
</PRE><PRE>       // Restrict the corner radius according to the sector angle.
       if (da &lt; pi$4) {
         var oc = da0 &gt; epsilon$3 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
             ax = x01 - oc[0],
             ay = y01 - oc[1],
             bx = x11 - oc[0],
             by = y11 - oc[1],
             kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),
             lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);
         rc0 = min$1(rc, (r0 - lc) / (kc - 1));
         rc1 = min$1(rc, (r1 - lc) / (kc + 1));
       }
     }
</PRE><PRE>     // Is the sector collapsed to a line?
     if (!(da1 &gt; epsilon$3)) context.moveTo(x01, y01);
</PRE><PRE>     // Does the sector’s outer ring have rounded corners?
     else if (rc1 &gt; epsilon$3) {
       t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
       t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
</PRE><PRE>       context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
</PRE><PRE>       // Have the corners merged?
       if (rc1 &lt; rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);
</PRE><PRE>       // Otherwise, draw the two corners and the ring.
       else {
         context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
         context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
         context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
       }
     }
</PRE><PRE>     // Or is the outer ring just a circular arc?
     else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
</PRE><PRE>     // Is there no inner ring, and it’s a circular sector?
     // Or perhaps it’s an annular sector collapsed due to padding?
     if (!(r0 &gt; epsilon$3) || !(da0 &gt; epsilon$3)) context.lineTo(x10, y10);
</PRE><PRE>     // Does the sector’s inner ring (or point) have rounded corners?
     else if (rc0 &gt; epsilon$3) {
       t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
       t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
</PRE><PRE>       context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
</PRE><PRE>       // Have the corners merged?
       if (rc0 &lt; rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);
</PRE><PRE>       // Otherwise, draw the two corners and the ring.
       else {
         context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
         context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
         context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
       }
     }
</PRE><PRE>     // Or is the inner ring just a circular arc?
     else context.arc(0, 0, r0, a10, a00, cw);
   }
</PRE><PRE>   context.closePath();
</PRE><PRE>   if (buffer) return context = null, buffer + &quot;&quot; || null;
 }
</PRE><PRE> arc.centroid = function() {
   var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
       a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;
   return [cos$2(a) * r, sin$2(a) * r];
 };
</PRE><PRE> arc.innerRadius = function(_) {
   return arguments.length ? (innerRadius = typeof _ === &quot;function&quot; ? _ : constant$b(+_), arc) : innerRadius;
 };
</PRE><PRE> arc.outerRadius = function(_) {
   return arguments.length ? (outerRadius = typeof _ === &quot;function&quot; ? _ : constant$b(+_), arc) : outerRadius;
 };
</PRE><PRE> arc.cornerRadius = function(_) {
   return arguments.length ? (cornerRadius = typeof _ === &quot;function&quot; ? _ : constant$b(+_), arc) : cornerRadius;
 };
</PRE><PRE> arc.padRadius = function(_) {
   return arguments.length ? (padRadius = _ == null ? null : typeof _ === &quot;function&quot; ? _ : constant$b(+_), arc) : padRadius;
 };
</PRE><PRE> arc.startAngle = function(_) {
   return arguments.length ? (startAngle = typeof _ === &quot;function&quot; ? _ : constant$b(+_), arc) : startAngle;
 };
</PRE><PRE> arc.endAngle = function(_) {
   return arguments.length ? (endAngle = typeof _ === &quot;function&quot; ? _ : constant$b(+_), arc) : endAngle;
 };
</PRE><PRE> arc.padAngle = function(_) {
   return arguments.length ? (padAngle = typeof _ === &quot;function&quot; ? _ : constant$b(+_), arc) : padAngle;
 };
</PRE><PRE> arc.context = function(_) {
   return arguments.length ? ((context = _ == null ? null : _), arc) : context;
 };
</PRE><PRE> return arc;
</PRE><P>}
</P><P>function Linear(context) {
</P><PRE> this._context = context;
</PRE><P>}
</P><P>Linear.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._point = 0;
 },
 lineEnd: function() {
   if (this._line || (this._line !== 0 &amp;&amp; this._point === 1)) this._context.closePath();
   this._line = 1 - this._line;
 },
 point: function(x, y) {
   x = +x, y = +y;
   switch (this._point) {
     case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
     case 1: this._point = 2; // proceed
     default: this._context.lineTo(x, y); break;
   }
 }
</PRE><P>};
</P><P>function curveLinear(context) {
</P><PRE> return new Linear(context);
</PRE><P>}
</P><P>function x$3(p) {
</P><PRE> return p[0];
</PRE><P>}
</P><P>function y$3(p) {
</P><PRE> return p[1];
</PRE><P>}
</P><P>function line() {
</P><PRE> var x$$1 = x$3,
     y$$1 = y$3,
     defined = constant$b(true),
     context = null,
     curve = curveLinear,
     output = null;
</PRE><PRE> function line(data) {
   var i,
       n = data.length,
       d,
       defined0 = false,
       buffer;
</PRE><PRE>   if (context == null) output = curve(buffer = path());
</PRE><PRE>   for (i = 0; i &lt;= n; ++i) {
     if (!(i &lt; n &amp;&amp; defined(d = data[i], i, data)) === defined0) {
       if (defined0 = !defined0) output.lineStart();
       else output.lineEnd();
     }
     if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
   }
</PRE><PRE>   if (buffer) return output = null, buffer + &quot;&quot; || null;
 }
</PRE><PRE> line.x = function(_) {
   return arguments.length ? (x$$1 = typeof _ === &quot;function&quot; ? _ : constant$b(+_), line) : x$$1;
 };
</PRE><PRE> line.y = function(_) {
   return arguments.length ? (y$$1 = typeof _ === &quot;function&quot; ? _ : constant$b(+_), line) : y$$1;
 };
</PRE><PRE> line.defined = function(_) {
   return arguments.length ? (defined = typeof _ === &quot;function&quot; ? _ : constant$b(!!_), line) : defined;
 };
</PRE><PRE> line.curve = function(_) {
   return arguments.length ? (curve = _, context != null &amp;&amp; (output = curve(context)), line) : curve;
 };
</PRE><PRE> line.context = function(_) {
   return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
 };
</PRE><PRE> return line;
</PRE><P>}
</P><P>function area$3() {
</P><PRE> var x0 = x$3,
     x1 = null,
     y0 = constant$b(0),
     y1 = y$3,
     defined = constant$b(true),
     context = null,
     curve = curveLinear,
     output = null;
</PRE><PRE> function area(data) {
   var i,
       j,
       k,
       n = data.length,
       d,
       defined0 = false,
       buffer,
       x0z = new Array(n),
       y0z = new Array(n);
</PRE><PRE>   if (context == null) output = curve(buffer = path());
</PRE><PRE>   for (i = 0; i &lt;= n; ++i) {
     if (!(i &lt; n &amp;&amp; defined(d = data[i], i, data)) === defined0) {
       if (defined0 = !defined0) {
         j = i;
         output.areaStart();
         output.lineStart();
       } else {
         output.lineEnd();
         output.lineStart();
         for (k = i - 1; k &gt;= j; --k) {
           output.point(x0z[k], y0z[k]);
         }
         output.lineEnd();
         output.areaEnd();
       }
     }
     if (defined0) {
       x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
       output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
     }
   }
</PRE><PRE>   if (buffer) return output = null, buffer + &quot;&quot; || null;
 }
</PRE><PRE> function arealine() {
   return line().defined(defined).curve(curve).context(context);
 }
</PRE><PRE> area.x = function(_) {
   return arguments.length ? (x0 = typeof _ === &quot;function&quot; ? _ : constant$b(+_), x1 = null, area) : x0;
 };
</PRE><PRE> area.x0 = function(_) {
   return arguments.length ? (x0 = typeof _ === &quot;function&quot; ? _ : constant$b(+_), area) : x0;
 };
</PRE><PRE> area.x1 = function(_) {
   return arguments.length ? (x1 = _ == null ? null : typeof _ === &quot;function&quot; ? _ : constant$b(+_), area) : x1;
 };
</PRE><PRE> area.y = function(_) {
   return arguments.length ? (y0 = typeof _ === &quot;function&quot; ? _ : constant$b(+_), y1 = null, area) : y0;
 };
</PRE><PRE> area.y0 = function(_) {
   return arguments.length ? (y0 = typeof _ === &quot;function&quot; ? _ : constant$b(+_), area) : y0;
 };
</PRE><PRE> area.y1 = function(_) {
   return arguments.length ? (y1 = _ == null ? null : typeof _ === &quot;function&quot; ? _ : constant$b(+_), area) : y1;
 };
</PRE><PRE> area.lineX0 =
 area.lineY0 = function() {
   return arealine().x(x0).y(y0);
 };
</PRE><PRE> area.lineY1 = function() {
   return arealine().x(x0).y(y1);
 };
</PRE><PRE> area.lineX1 = function() {
   return arealine().x(x1).y(y0);
 };
</PRE><PRE> area.defined = function(_) {
   return arguments.length ? (defined = typeof _ === &quot;function&quot; ? _ : constant$b(!!_), area) : defined;
 };
</PRE><PRE> area.curve = function(_) {
   return arguments.length ? (curve = _, context != null &amp;&amp; (output = curve(context)), area) : curve;
 };
</PRE><PRE> area.context = function(_) {
   return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
 };
</PRE><PRE> return area;
</PRE><P>}
</P><P>function descending$1(a, b) {
</P><PRE> return b &lt; a ? -1 : b &gt; a ? 1 : b &gt;= a ? 0 : NaN;
</PRE><P>}
</P><P>function identity$7(d) {
</P><PRE> return d;
</PRE><P>}
</P><P>function pie() {
</P><PRE> var value = identity$7,
     sortValues = descending$1,
     sort = null,
     startAngle = constant$b(0),
     endAngle = constant$b(tau$4),
     padAngle = constant$b(0);
</PRE><PRE> function pie(data) {
   var i,
       n = data.length,
       j,
       k,
       sum = 0,
       index = new Array(n),
       arcs = new Array(n),
       a0 = +startAngle.apply(this, arguments),
       da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),
       a1,
       p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
       pa = p * (da &lt; 0 ? -1 : 1),
       v;
</PRE><PRE>   for (i = 0; i &lt; n; ++i) {
     if ((v = arcs[index[i] = i] = +value(data[i], i, data)) &gt; 0) {
       sum += v;
     }
   }
</PRE><PRE>   // Optionally sort the arcs by previously-computed values or by data.
   if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
   else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });
</PRE><PRE>   // Compute the arcs! They are stored in the original data's order.
   for (i = 0, k = sum ? (da - n * pa) / sum : 0; i &lt; n; ++i, a0 = a1) {
     j = index[i], v = arcs[j], a1 = a0 + (v &gt; 0 ? v * k : 0) + pa, arcs[j] = {
       data: data[j],
       index: i,
       value: v,
       startAngle: a0,
       endAngle: a1,
       padAngle: p
     };
   }
</PRE><PRE>   return arcs;
 }
</PRE><PRE> pie.value = function(_) {
   return arguments.length ? (value = typeof _ === &quot;function&quot; ? _ : constant$b(+_), pie) : value;
 };
</PRE><PRE> pie.sortValues = function(_) {
   return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
 };
</PRE><PRE> pie.sort = function(_) {
   return arguments.length ? (sort = _, sortValues = null, pie) : sort;
 };
</PRE><PRE> pie.startAngle = function(_) {
   return arguments.length ? (startAngle = typeof _ === &quot;function&quot; ? _ : constant$b(+_), pie) : startAngle;
 };
</PRE><PRE> pie.endAngle = function(_) {
   return arguments.length ? (endAngle = typeof _ === &quot;function&quot; ? _ : constant$b(+_), pie) : endAngle;
 };
</PRE><PRE> pie.padAngle = function(_) {
   return arguments.length ? (padAngle = typeof _ === &quot;function&quot; ? _ : constant$b(+_), pie) : padAngle;
 };
</PRE><PRE> return pie;
</PRE><P>}
</P><P>var curveRadialLinear = curveRadial(curveLinear);
</P><P>function Radial(curve) {
</P><PRE> this._curve = curve;
</PRE><P>}
</P><P>Radial.prototype = {
</P><PRE> areaStart: function() {
   this._curve.areaStart();
 },
 areaEnd: function() {
   this._curve.areaEnd();
 },
 lineStart: function() {
   this._curve.lineStart();
 },
 lineEnd: function() {
   this._curve.lineEnd();
 },
 point: function(a, r) {
   this._curve.point(r * Math.sin(a), r * -Math.cos(a));
 }
</PRE><P>};
</P><P>function curveRadial(curve) {
</P><PRE> function radial(context) {
   return new Radial(curve(context));
 }
</PRE><PRE> radial._curve = curve;
</PRE><PRE> return radial;
</PRE><P>}
</P><P>function lineRadial(l) {
</P><PRE> var c = l.curve;
</PRE><PRE> l.angle = l.x, delete l.x;
 l.radius = l.y, delete l.y;
</PRE><PRE> l.curve = function(_) {
   return arguments.length ? c(curveRadial(_)) : c()._curve;
 };
</PRE><PRE> return l;
</PRE><P>}
</P><P>function lineRadial$1() {
</P><PRE> return lineRadial(line().curve(curveRadialLinear));
</PRE><P>}
</P><P>function areaRadial() {
</P><PRE> var a = area$3().curve(curveRadialLinear),
     c = a.curve,
     x0 = a.lineX0,
     x1 = a.lineX1,
     y0 = a.lineY0,
     y1 = a.lineY1;
</PRE><PRE> a.angle = a.x, delete a.x;
 a.startAngle = a.x0, delete a.x0;
 a.endAngle = a.x1, delete a.x1;
 a.radius = a.y, delete a.y;
 a.innerRadius = a.y0, delete a.y0;
 a.outerRadius = a.y1, delete a.y1;
 a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
 a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
 a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
 a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;
</PRE><PRE> a.curve = function(_) {
   return arguments.length ? c(curveRadial(_)) : c()._curve;
 };
</PRE><PRE> return a;
</PRE><P>}
</P><P>function pointRadial(x, y) {
</P><PRE> return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
</PRE><P>}
</P><P>var slice$6 = Array.prototype.slice;
</P><P>function linkSource(d) {
</P><PRE> return d.source;
</PRE><P>}
</P><P>function linkTarget(d) {
</P><PRE> return d.target;
</PRE><P>}
</P><P>function link$2(curve) {
</P><PRE> var source = linkSource,
     target = linkTarget,
     x$$1 = x$3,
     y$$1 = y$3,
     context = null;
</PRE><PRE> function link() {
   var buffer, argv = slice$6.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
   if (!context) context = buffer = path();
   curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
   if (buffer) return context = null, buffer + &quot;&quot; || null;
 }
</PRE><PRE> link.source = function(_) {
   return arguments.length ? (source = _, link) : source;
 };
</PRE><PRE> link.target = function(_) {
   return arguments.length ? (target = _, link) : target;
 };
</PRE><PRE> link.x = function(_) {
   return arguments.length ? (x$$1 = typeof _ === &quot;function&quot; ? _ : constant$b(+_), link) : x$$1;
 };
</PRE><PRE> link.y = function(_) {
   return arguments.length ? (y$$1 = typeof _ === &quot;function&quot; ? _ : constant$b(+_), link) : y$$1;
 };
</PRE><PRE> link.context = function(_) {
   return arguments.length ? ((context = _ == null ? null : _), link) : context;
 };
</PRE><PRE> return link;
</PRE><P>}
</P><P>function curveHorizontal(context, x0, y0, x1, y1) {
</P><PRE> context.moveTo(x0, y0);
 context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
</PRE><P>}
</P><P>function curveVertical(context, x0, y0, x1, y1) {
</P><PRE> context.moveTo(x0, y0);
 context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
</PRE><P>}
</P><P>function curveRadial$1(context, x0, y0, x1, y1) {
</P><PRE> var p0 = pointRadial(x0, y0),
     p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
     p2 = pointRadial(x1, y0),
     p3 = pointRadial(x1, y1);
 context.moveTo(p0[0], p0[1]);
 context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
</PRE><P>}
</P><P>function linkHorizontal() {
</P><PRE> return link$2(curveHorizontal);
</PRE><P>}
</P><P>function linkVertical() {
</P><PRE> return link$2(curveVertical);
</PRE><P>}
</P><P>function linkRadial() {
</P><PRE> var l = link$2(curveRadial$1);
 l.angle = l.x, delete l.x;
 l.radius = l.y, delete l.y;
 return l;
</PRE><P>}
</P><P>var circle$2 = {
</P><PRE> draw: function(context, size) {
   var r = Math.sqrt(size / pi$4);
   context.moveTo(r, 0);
   context.arc(0, 0, r, 0, tau$4);
 }
</PRE><P>};
</P><P>var cross$2 = {
</P><PRE> draw: function(context, size) {
   var r = Math.sqrt(size / 5) / 2;
   context.moveTo(-3 * r, -r);
   context.lineTo(-r, -r);
   context.lineTo(-r, -3 * r);
   context.lineTo(r, -3 * r);
   context.lineTo(r, -r);
   context.lineTo(3 * r, -r);
   context.lineTo(3 * r, r);
   context.lineTo(r, r);
   context.lineTo(r, 3 * r);
   context.lineTo(-r, 3 * r);
   context.lineTo(-r, r);
   context.lineTo(-3 * r, r);
   context.closePath();
 }
</PRE><P>};
</P><P>var tan30 = Math.sqrt(1 / 3),
</P><PRE>   tan30_2 = tan30 * 2;
</PRE><P>var diamond = {
</P><PRE> draw: function(context, size) {
   var y = Math.sqrt(size / tan30_2),
       x = y * tan30;
   context.moveTo(0, -y);
   context.lineTo(x, 0);
   context.lineTo(0, y);
   context.lineTo(-x, 0);
   context.closePath();
 }
</PRE><P>};
</P><P>var ka = 0.89081309152928522810,
</P><PRE>   kr = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10),
   kx = Math.sin(tau$4 / 10) * kr,
   ky = -Math.cos(tau$4 / 10) * kr;
</PRE><P>var star = {
</P><PRE> draw: function(context, size) {
   var r = Math.sqrt(size * ka),
       x = kx * r,
       y = ky * r;
   context.moveTo(0, -r);
   context.lineTo(x, y);
   for (var i = 1; i &lt; 5; ++i) {
     var a = tau$4 * i / 5,
         c = Math.cos(a),
         s = Math.sin(a);
     context.lineTo(s * r, -c * r);
     context.lineTo(c * x - s * y, s * x + c * y);
   }
   context.closePath();
 }
</PRE><P>};
</P><P>var square = {
</P><PRE> draw: function(context, size) {
   var w = Math.sqrt(size),
       x = -w / 2;
   context.rect(x, x, w, w);
 }
</PRE><P>};
</P><P>var sqrt3 = Math.sqrt(3);
</P><P>var triangle = {
</P><PRE> draw: function(context, size) {
   var y = -Math.sqrt(size / (sqrt3 * 3));
   context.moveTo(0, y * 2);
   context.lineTo(-sqrt3 * y, -y);
   context.lineTo(sqrt3 * y, -y);
   context.closePath();
 }
</PRE><P>};
</P><P>var c$2 = -0.5,
</P><PRE>   s = Math.sqrt(3) / 2,
   k = 1 / Math.sqrt(12),
   a = (k / 2 + 1) * 3;
</PRE><P>var wye = {
</P><PRE> draw: function(context, size) {
   var r = Math.sqrt(size / a),
       x0 = r / 2,
       y0 = r * k,
       x1 = x0,
       y1 = r * k + r,
       x2 = -x1,
       y2 = y1;
   context.moveTo(x0, y0);
   context.lineTo(x1, y1);
   context.lineTo(x2, y2);
   context.lineTo(c$2 * x0 - s * y0, s * x0 + c$2 * y0);
   context.lineTo(c$2 * x1 - s * y1, s * x1 + c$2 * y1);
   context.lineTo(c$2 * x2 - s * y2, s * x2 + c$2 * y2);
   context.lineTo(c$2 * x0 + s * y0, c$2 * y0 - s * x0);
   context.lineTo(c$2 * x1 + s * y1, c$2 * y1 - s * x1);
   context.lineTo(c$2 * x2 + s * y2, c$2 * y2 - s * x2);
   context.closePath();
 }
</PRE><P>};
</P><P>var symbols = [
</P><PRE> circle$2,
 cross$2,
 diamond,
 square,
 star,
 triangle,
 wye
</PRE><P>];
</P><P>function symbol() {
</P><PRE> var type = constant$b(circle$2),
     size = constant$b(64),
     context = null;
</PRE><PRE> function symbol() {
   var buffer;
   if (!context) context = buffer = path();
   type.apply(this, arguments).draw(context, +size.apply(this, arguments));
   if (buffer) return context = null, buffer + &quot;&quot; || null;
 }
</PRE><PRE> symbol.type = function(_) {
   return arguments.length ? (type = typeof _ === &quot;function&quot; ? _ : constant$b(_), symbol) : type;
 };
</PRE><PRE> symbol.size = function(_) {
   return arguments.length ? (size = typeof _ === &quot;function&quot; ? _ : constant$b(+_), symbol) : size;
 };
</PRE><PRE> symbol.context = function(_) {
   return arguments.length ? (context = _ == null ? null : _, symbol) : context;
 };
</PRE><PRE> return symbol;
</PRE><P>}
</P><P>function noop$3() {}
</P><P>function point$2(that, x, y) {
</P><PRE> that._context.bezierCurveTo(
   (2 * that._x0 + that._x1) / 3,
   (2 * that._y0 + that._y1) / 3,
   (that._x0 + 2 * that._x1) / 3,
   (that._y0 + 2 * that._y1) / 3,
   (that._x0 + 4 * that._x1 + x) / 6,
   (that._y0 + 4 * that._y1 + y) / 6
 );
</PRE><P>}
</P><P>function Basis(context) {
</P><PRE>this._context = context;
</PRE><P>}
</P><P>Basis.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._x0 = this._x1 =
   this._y0 = this._y1 = NaN;
   this._point = 0;
 },
 lineEnd: function() {
   switch (this._point) {
     case 3: point$2(this, this._x1, this._y1); // proceed
     case 2: this._context.lineTo(this._x1, this._y1); break;
   }
   if (this._line || (this._line !== 0 &amp;&amp; this._point === 1)) this._context.closePath();
   this._line = 1 - this._line;
 },
 point: function(x, y) {
   x = +x, y = +y;
   switch (this._point) {
     case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
     case 1: this._point = 2; break;
     case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
     default: point$2(this, x, y); break;
   }
   this._x0 = this._x1, this._x1 = x;
   this._y0 = this._y1, this._y1 = y;
 }
</PRE><P>};
</P><P>function basis$2(context) {
</P><PRE> return new Basis(context);
</PRE><P>}
</P><P>function BasisClosed(context) {
</P><PRE> this._context = context;
</PRE><P>}
</P><P>BasisClosed.prototype = {
</P><PRE> areaStart: noop$3,
 areaEnd: noop$3,
 lineStart: function() {
   this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
   this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
   this._point = 0;
 },
 lineEnd: function() {
   switch (this._point) {
     case 1: {
       this._context.moveTo(this._x2, this._y2);
       this._context.closePath();
       break;
     }
     case 2: {
       this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
       this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
       this._context.closePath();
       break;
     }
     case 3: {
       this.point(this._x2, this._y2);
       this.point(this._x3, this._y3);
       this.point(this._x4, this._y4);
       break;
     }
   }
 },
 point: function(x, y) {
   x = +x, y = +y;
   switch (this._point) {
     case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
     case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
     case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
     default: point$2(this, x, y); break;
   }
   this._x0 = this._x1, this._x1 = x;
   this._y0 = this._y1, this._y1 = y;
 }
</PRE><P>};
</P><P>function basisClosed$1(context) {
</P><PRE> return new BasisClosed(context);
</PRE><P>}
</P><P>function BasisOpen(context) {
</P><PRE> this._context = context;
</PRE><P>}
</P><P>BasisOpen.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._x0 = this._x1 =
   this._y0 = this._y1 = NaN;
   this._point = 0;
 },
 lineEnd: function() {
   if (this._line || (this._line !== 0 &amp;&amp; this._point === 3)) this._context.closePath();
   this._line = 1 - this._line;
 },
 point: function(x, y) {
   x = +x, y = +y;
   switch (this._point) {
     case 0: this._point = 1; break;
     case 1: this._point = 2; break;
     case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
     case 3: this._point = 4; // proceed
     default: point$2(this, x, y); break;
   }
   this._x0 = this._x1, this._x1 = x;
   this._y0 = this._y1, this._y1 = y;
 }
</PRE><P>};
</P><P>function basisOpen(context) {
</P><PRE> return new BasisOpen(context);
</PRE><P>}
</P><P>function Bundle(context, beta) {
</P><PRE> this._basis = new Basis(context);
 this._beta = beta;
</PRE><P>}
</P><P>Bundle.prototype = {
</P><PRE> lineStart: function() {
   this._x = [];
   this._y = [];
   this._basis.lineStart();
 },
 lineEnd: function() {
   var x = this._x,
       y = this._y,
       j = x.length - 1;
</PRE><PRE>   if (j &gt; 0) {
     var x0 = x[0],
         y0 = y[0],
         dx = x[j] - x0,
         dy = y[j] - y0,
         i = -1,
         t;
</PRE><PRE>     while (++i &lt;= j) {
       t = i / j;
       this._basis.point(
         this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
         this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
       );
     }
   }
</PRE><PRE>   this._x = this._y = null;
   this._basis.lineEnd();
 },
 point: function(x, y) {
   this._x.push(+x);
   this._y.push(+y);
 }
</PRE><P>};
</P><P>var bundle = (function custom(beta) {
</P><PRE> function bundle(context) {
   return beta === 1 ? new Basis(context) : new Bundle(context, beta);
 }
</PRE><PRE> bundle.beta = function(beta) {
   return custom(+beta);
 };
</PRE><PRE> return bundle;
</PRE><P>})(0.85);
</P><P>function point$3(that, x, y) {
</P><PRE> that._context.bezierCurveTo(
   that._x1 + that._k * (that._x2 - that._x0),
   that._y1 + that._k * (that._y2 - that._y0),
   that._x2 + that._k * (that._x1 - x),
   that._y2 + that._k * (that._y1 - y),
   that._x2,
   that._y2
 );
</PRE><P>}
</P><P>function Cardinal(context, tension) {
</P><PRE> this._context = context;
 this._k = (1 - tension) / 6;
</PRE><P>}
</P><P>Cardinal.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._x0 = this._x1 = this._x2 =
   this._y0 = this._y1 = this._y2 = NaN;
   this._point = 0;
 },
 lineEnd: function() {
   switch (this._point) {
     case 2: this._context.lineTo(this._x2, this._y2); break;
     case 3: point$3(this, this._x1, this._y1); break;
   }
   if (this._line || (this._line !== 0 &amp;&amp; this._point === 1)) this._context.closePath();
   this._line = 1 - this._line;
 },
 point: function(x, y) {
   x = +x, y = +y;
   switch (this._point) {
     case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
     case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
     case 2: this._point = 3; // proceed
     default: point$3(this, x, y); break;
   }
   this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
   this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
 }
</PRE><P>};
</P><P>var cardinal = (function custom(tension) {
</P><PRE> function cardinal(context) {
   return new Cardinal(context, tension);
 }
</PRE><PRE> cardinal.tension = function(tension) {
   return custom(+tension);
 };
</PRE><PRE> return cardinal;
</PRE><P>})(0);
</P><P>function CardinalClosed(context, tension) {
</P><PRE> this._context = context;
 this._k = (1 - tension) / 6;
</PRE><P>}
</P><P>CardinalClosed.prototype = {
</P><PRE> areaStart: noop$3,
 areaEnd: noop$3,
 lineStart: function() {
   this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
   this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
   this._point = 0;
 },
 lineEnd: function() {
   switch (this._point) {
     case 1: {
       this._context.moveTo(this._x3, this._y3);
       this._context.closePath();
       break;
     }
     case 2: {
       this._context.lineTo(this._x3, this._y3);
       this._context.closePath();
       break;
     }
     case 3: {
       this.point(this._x3, this._y3);
       this.point(this._x4, this._y4);
       this.point(this._x5, this._y5);
       break;
     }
   }
 },
 point: function(x, y) {
   x = +x, y = +y;
   switch (this._point) {
     case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
     case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
     case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
     default: point$3(this, x, y); break;
   }
   this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
   this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
 }
</PRE><P>};
</P><P>var cardinalClosed = (function custom(tension) {
</P><PRE> function cardinal$$1(context) {
   return new CardinalClosed(context, tension);
 }
</PRE><PRE> cardinal$$1.tension = function(tension) {
   return custom(+tension);
 };
</PRE><PRE> return cardinal$$1;
</PRE><P>})(0);
</P><P>function CardinalOpen(context, tension) {
</P><PRE> this._context = context;
 this._k = (1 - tension) / 6;
</PRE><P>}
</P><P>CardinalOpen.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._x0 = this._x1 = this._x2 =
   this._y0 = this._y1 = this._y2 = NaN;
   this._point = 0;
 },
 lineEnd: function() {
   if (this._line || (this._line !== 0 &amp;&amp; this._point === 3)) this._context.closePath();
   this._line = 1 - this._line;
 },
 point: function(x, y) {
   x = +x, y = +y;
   switch (this._point) {
     case 0: this._point = 1; break;
     case 1: this._point = 2; break;
     case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
     case 3: this._point = 4; // proceed
     default: point$3(this, x, y); break;
   }
   this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
   this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
 }
</PRE><P>};
</P><P>var cardinalOpen = (function custom(tension) {
</P><PRE> function cardinal$$1(context) {
   return new CardinalOpen(context, tension);
 }
</PRE><PRE> cardinal$$1.tension = function(tension) {
   return custom(+tension);
 };
</PRE><PRE> return cardinal$$1;
</PRE><P>})(0);
</P><P>function point$4(that, x, y) {
</P><PRE> var x1 = that._x1,
     y1 = that._y1,
     x2 = that._x2,
     y2 = that._y2;
</PRE><PRE> if (that._l01_a &gt; epsilon$3) {
   var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
       n = 3 * that._l01_a * (that._l01_a + that._l12_a);
   x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
   y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
 }
</PRE><PRE> if (that._l23_a &gt; epsilon$3) {
   var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
       m = 3 * that._l23_a * (that._l23_a + that._l12_a);
   x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
   y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
 }
</PRE><PRE> that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
</PRE><P>}
</P><P>function CatmullRom(context, alpha) {
</P><PRE> this._context = context;
 this._alpha = alpha;
</PRE><P>}
</P><P>CatmullRom.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._x0 = this._x1 = this._x2 =
   this._y0 = this._y1 = this._y2 = NaN;
   this._l01_a = this._l12_a = this._l23_a =
   this._l01_2a = this._l12_2a = this._l23_2a =
   this._point = 0;
 },
 lineEnd: function() {
   switch (this._point) {
     case 2: this._context.lineTo(this._x2, this._y2); break;
     case 3: this.point(this._x2, this._y2); break;
   }
   if (this._line || (this._line !== 0 &amp;&amp; this._point === 1)) this._context.closePath();
   this._line = 1 - this._line;
 },
 point: function(x, y) {
   x = +x, y = +y;
</PRE><PRE>   if (this._point) {
     var x23 = this._x2 - x,
         y23 = this._y2 - y;
     this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
   }
</PRE><PRE>   switch (this._point) {
     case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
     case 1: this._point = 2; break;
     case 2: this._point = 3; // proceed
     default: point$4(this, x, y); break;
   }
</PRE><PRE>   this._l01_a = this._l12_a, this._l12_a = this._l23_a;
   this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
   this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
   this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
 }
</PRE><P>};
</P><P>var catmullRom = (function custom(alpha) {
</P><PRE> function catmullRom(context) {
   return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
 }
</PRE><PRE> catmullRom.alpha = function(alpha) {
   return custom(+alpha);
 };
</PRE><PRE> return catmullRom;
</PRE><P>})(0.5);
</P><P>function CatmullRomClosed(context, alpha) {
</P><PRE> this._context = context;
 this._alpha = alpha;
</PRE><P>}
</P><P>CatmullRomClosed.prototype = {
</P><PRE> areaStart: noop$3,
 areaEnd: noop$3,
 lineStart: function() {
   this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
   this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
   this._l01_a = this._l12_a = this._l23_a =
   this._l01_2a = this._l12_2a = this._l23_2a =
   this._point = 0;
 },
 lineEnd: function() {
   switch (this._point) {
     case 1: {
       this._context.moveTo(this._x3, this._y3);
       this._context.closePath();
       break;
     }
     case 2: {
       this._context.lineTo(this._x3, this._y3);
       this._context.closePath();
       break;
     }
     case 3: {
       this.point(this._x3, this._y3);
       this.point(this._x4, this._y4);
       this.point(this._x5, this._y5);
       break;
     }
   }
 },
 point: function(x, y) {
   x = +x, y = +y;
</PRE><PRE>   if (this._point) {
     var x23 = this._x2 - x,
         y23 = this._y2 - y;
     this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
   }
</PRE><PRE>   switch (this._point) {
     case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
     case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
     case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
     default: point$4(this, x, y); break;
   }
</PRE><PRE>   this._l01_a = this._l12_a, this._l12_a = this._l23_a;
   this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
   this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
   this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
 }
</PRE><P>};
</P><P>var catmullRomClosed = (function custom(alpha) {
</P><PRE> function catmullRom$$1(context) {
   return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
 }
</PRE><PRE> catmullRom$$1.alpha = function(alpha) {
   return custom(+alpha);
 };
</PRE><PRE> return catmullRom$$1;
</PRE><P>})(0.5);
</P><P>function CatmullRomOpen(context, alpha) {
</P><PRE> this._context = context;
 this._alpha = alpha;
</PRE><P>}
</P><P>CatmullRomOpen.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._x0 = this._x1 = this._x2 =
   this._y0 = this._y1 = this._y2 = NaN;
   this._l01_a = this._l12_a = this._l23_a =
   this._l01_2a = this._l12_2a = this._l23_2a =
   this._point = 0;
 },
 lineEnd: function() {
   if (this._line || (this._line !== 0 &amp;&amp; this._point === 3)) this._context.closePath();
   this._line = 1 - this._line;
 },
 point: function(x, y) {
   x = +x, y = +y;
</PRE><PRE>   if (this._point) {
     var x23 = this._x2 - x,
         y23 = this._y2 - y;
     this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
   }
</PRE><PRE>   switch (this._point) {
     case 0: this._point = 1; break;
     case 1: this._point = 2; break;
     case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
     case 3: this._point = 4; // proceed
     default: point$4(this, x, y); break;
   }
</PRE><PRE>   this._l01_a = this._l12_a, this._l12_a = this._l23_a;
   this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
   this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
   this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
 }
</PRE><P>};
</P><P>var catmullRomOpen = (function custom(alpha) {
</P><PRE> function catmullRom$$1(context) {
   return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
 }
</PRE><PRE> catmullRom$$1.alpha = function(alpha) {
   return custom(+alpha);
 };
</PRE><PRE> return catmullRom$$1;
</PRE><P>})(0.5);
</P><P>function LinearClosed(context) {
</P><PRE> this._context = context;
</PRE><P>}
</P><P>LinearClosed.prototype = {
</P><PRE> areaStart: noop$3,
 areaEnd: noop$3,
 lineStart: function() {
   this._point = 0;
 },
 lineEnd: function() {
   if (this._point) this._context.closePath();
 },
 point: function(x, y) {
   x = +x, y = +y;
   if (this._point) this._context.lineTo(x, y);
   else this._point = 1, this._context.moveTo(x, y);
 }
</PRE><P>};
</P><P>function linearClosed(context) {
</P><PRE> return new LinearClosed(context);
</PRE><P>}
</P><P>function sign$1(x) {
</P><PRE> return x &lt; 0 ? -1 : 1;
</PRE><P>}
</P><P>// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
</P><PRE> var h0 = that._x1 - that._x0,
     h1 = x2 - that._x1,
     s0 = (that._y1 - that._y0) / (h0 || h1 &lt; 0 &amp;&amp; -0),
     s1 = (y2 - that._y1) / (h1 || h0 &lt; 0 &amp;&amp; -0),
     p = (s0 * h1 + s1 * h0) / (h0 + h1);
 return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
</PRE><P>}
</P><P>// Calculate a one-sided slope.
function slope2(that, t) {
</P><PRE> var h = that._x1 - that._x0;
 return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
</PRE><P>}
</P><P>// According to <A rel="nofollow" class="external free" href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations">https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations</A>
// &quot;you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1&quot;.
function point$5(that, t0, t1) {
</P><PRE> var x0 = that._x0,
     y0 = that._y0,
     x1 = that._x1,
     y1 = that._y1,
     dx = (x1 - x0) / 3;
 that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
</PRE><P>}
</P><P>function MonotoneX(context) {
</P><PRE> this._context = context;
</PRE><P>}
</P><P>MonotoneX.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._x0 = this._x1 =
   this._y0 = this._y1 =
   this._t0 = NaN;
   this._point = 0;
 },
 lineEnd: function() {
   switch (this._point) {
     case 2: this._context.lineTo(this._x1, this._y1); break;
     case 3: point$5(this, this._t0, slope2(this, this._t0)); break;
   }
   if (this._line || (this._line !== 0 &amp;&amp; this._point === 1)) this._context.closePath();
   this._line = 1 - this._line;
 },
 point: function(x, y) {
   var t1 = NaN;
</PRE><PRE>   x = +x, y = +y;
   if (x === this._x1 &amp;&amp; y === this._y1) return; // Ignore coincident points.
   switch (this._point) {
     case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
     case 1: this._point = 2; break;
     case 2: this._point = 3; point$5(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
     default: point$5(this, this._t0, t1 = slope3(this, x, y)); break;
   }
</PRE><PRE>   this._x0 = this._x1, this._x1 = x;
   this._y0 = this._y1, this._y1 = y;
   this._t0 = t1;
 }
</PRE><P>};
</P><P>function MonotoneY(context) {
</P><PRE> this._context = new ReflectContext(context);
</PRE><P>}
</P><P>(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
</P><PRE> MonotoneX.prototype.point.call(this, y, x);
</PRE><P>};
</P><P>function ReflectContext(context) {
</P><PRE> this._context = context;
</PRE><P>}
</P><P>ReflectContext.prototype = {
</P><PRE> moveTo: function(x, y) { this._context.moveTo(y, x); },
 closePath: function() { this._context.closePath(); },
 lineTo: function(x, y) { this._context.lineTo(y, x); },
 bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
</PRE><P>};
</P><P>function monotoneX(context) {
</P><PRE> return new MonotoneX(context);
</PRE><P>}
</P><P>function monotoneY(context) {
</P><PRE> return new MonotoneY(context);
</PRE><P>}
</P><P>function Natural(context) {
</P><PRE> this._context = context;
</PRE><P>}
</P><P>Natural.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._x = [];
   this._y = [];
 },
 lineEnd: function() {
   var x = this._x,
       y = this._y,
       n = x.length;
</PRE><PRE>   if (n) {
     this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
     if (n === 2) {
       this._context.lineTo(x[1], y[1]);
     } else {
       var px = controlPoints(x),
           py = controlPoints(y);
       for (var i0 = 0, i1 = 1; i1 &lt; n; ++i0, ++i1) {
         this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
       }
     }
   }
</PRE><PRE>   if (this._line || (this._line !== 0 &amp;&amp; n === 1)) this._context.closePath();
   this._line = 1 - this._line;
   this._x = this._y = null;
 },
 point: function(x, y) {
   this._x.push(+x);
   this._y.push(+y);
 }
</PRE><P>};
</P><P>// See <A rel="nofollow" class="external free" href="https://www.particleincell.com/2012/bezier-splines/">https://www.particleincell.com/2012/bezier-splines/</A> for derivation.
function controlPoints(x) {
</P><PRE> var i,
     n = x.length - 1,
     m,
     a = new Array(n),
     b = new Array(n),
     r = new Array(n);
 a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
 for (i = 1; i &lt; n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
 a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
 for (i = 1; i &lt; n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
 a[n - 1] = r[n - 1] / b[n - 1];
 for (i = n - 2; i &gt;= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
 b[n - 1] = (x[n] + a[n - 1]) / 2;
 for (i = 0; i &lt; n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
 return [a, b];
</PRE><P>}
</P><P>function natural(context) {
</P><PRE> return new Natural(context);
</PRE><P>}
</P><P>function Step(context, t) {
</P><PRE> this._context = context;
 this._t = t;
</PRE><P>}
</P><P>Step.prototype = {
</P><PRE> areaStart: function() {
   this._line = 0;
 },
 areaEnd: function() {
   this._line = NaN;
 },
 lineStart: function() {
   this._x = this._y = NaN;
   this._point = 0;
 },
 lineEnd: function() {
   if (0 &lt; this._t &amp;&amp; this._t &lt; 1 &amp;&amp; this._point === 2) this._context.lineTo(this._x, this._y);
   if (this._line || (this._line !== 0 &amp;&amp; this._point === 1)) this._context.closePath();
   if (this._line &gt;= 0) this._t = 1 - this._t, this._line = 1 - this._line;
 },
 point: function(x, y) {
   x = +x, y = +y;
   switch (this._point) {
     case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
     case 1: this._point = 2; // proceed
     default: {
       if (this._t &lt;= 0) {
         this._context.lineTo(this._x, y);
         this._context.lineTo(x, y);
       } else {
         var x1 = this._x * (1 - this._t) + x * this._t;
         this._context.lineTo(x1, this._y);
         this._context.lineTo(x1, y);
       }
       break;
     }
   }
   this._x = x, this._y = y;
 }
</PRE><P>};
</P><P>function step(context) {
</P><PRE> return new Step(context, 0.5);
</PRE><P>}
</P><P>function stepBefore(context) {
</P><PRE> return new Step(context, 0);
</PRE><P>}
</P><P>function stepAfter(context) {
</P><PRE> return new Step(context, 1);
</PRE><P>}
</P><P>function none$1(series, order) {
</P><PRE> if (!((n = series.length) &gt; 1)) return;
 for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i &lt; n; ++i) {
   s0 = s1, s1 = series[order[i]];
   for (j = 0; j &lt; m; ++j) {
     s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
   }
 }
</PRE><P>}
</P><P>function none$2(series) {
</P><PRE> var n = series.length, o = new Array(n);
 while (--n &gt;= 0) o[n] = n;
 return o;
</PRE><P>}
</P><P>function stackValue(d, key) {
</P><PRE> return d[key];
</PRE><P>}
</P><P>function stack() {
</P><PRE> var keys = constant$b([]),
     order = none$2,
     offset = none$1,
     value = stackValue;
</PRE><PRE> function stack(data) {
   var kz = keys.apply(this, arguments),
       i,
       m = data.length,
       n = kz.length,
       sz = new Array(n),
       oz;
</PRE><PRE>   for (i = 0; i &lt; n; ++i) {
     for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j &lt; m; ++j) {
       si[j] = sij = [0, +value(data[j], ki, j, data)];
       sij.data = data[j];
     }
     si.key = ki;
   }
</PRE><PRE>   for (i = 0, oz = order(sz); i &lt; n; ++i) {
     sz[oz[i]].index = i;
   }
</PRE><PRE>   offset(sz, oz);
   return sz;
 }
</PRE><PRE> stack.keys = function(_) {
   return arguments.length ? (keys = typeof _ === &quot;function&quot; ? _ : constant$b(slice$6.call(_)), stack) : keys;
 };
</PRE><PRE> stack.value = function(_) {
   return arguments.length ? (value = typeof _ === &quot;function&quot; ? _ : constant$b(+_), stack) : value;
 };
</PRE><PRE> stack.order = function(_) {
   return arguments.length ? (order = _ == null ? none$2 : typeof _ === &quot;function&quot; ? _ : constant$b(slice$6.call(_)), stack) : order;
 };
</PRE><PRE> stack.offset = function(_) {
   return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
 };
</PRE><PRE> return stack;
</PRE><P>}
</P><P>function expand(series, order) {
</P><PRE> if (!((n = series.length) &gt; 0)) return;
 for (var i, n, j = 0, m = series[0].length, y; j &lt; m; ++j) {
   for (y = i = 0; i &lt; n; ++i) y += series[i][j][1] || 0;
   if (y) for (i = 0; i &lt; n; ++i) series[i][j][1] /= y;
 }
 none$1(series, order);
</PRE><P>}
</P><P>function diverging$1(series, order) {
</P><PRE> if (!((n = series.length) &gt; 1)) return;
 for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j &lt; m; ++j) {
   for (yp = yn = 0, i = 0; i &lt; n; ++i) {
     if ((dy = (d = series[order[i]][j])[1] - d[0]) &gt;= 0) {
       d[0] = yp, d[1] = yp += dy;
     } else if (dy &lt; 0) {
       d[1] = yn, d[0] = yn += dy;
     } else {
       d[0] = yp;
     }
   }
 }
</PRE><P>}
</P><P>function silhouette(series, order) {
</P><PRE> if (!((n = series.length) &gt; 0)) return;
 for (var j = 0, s0 = series[order[0]], n, m = s0.length; j &lt; m; ++j) {
   for (var i = 0, y = 0; i &lt; n; ++i) y += series[i][j][1] || 0;
   s0[j][1] += s0[j][0] = -y / 2;
 }
 none$1(series, order);
</PRE><P>}
</P><P>function wiggle(series, order) {
</P><PRE> if (!((n = series.length) &gt; 0) || !((m = (s0 = series[order[0]]).length) &gt; 0)) return;
 for (var y = 0, j = 1, s0, m, n; j &lt; m; ++j) {
   for (var i = 0, s1 = 0, s2 = 0; i &lt; n; ++i) {
     var si = series[order[i]],
         sij0 = si[j][1] || 0,
         sij1 = si[j - 1][1] || 0,
         s3 = (sij0 - sij1) / 2;
     for (var k = 0; k &lt; i; ++k) {
       var sk = series[order[k]],
           skj0 = sk[j][1] || 0,
           skj1 = sk[j - 1][1] || 0;
       s3 += skj0 - skj1;
     }
     s1 += sij0, s2 += s3 * sij0;
   }
   s0[j - 1][1] += s0[j - 1][0] = y;
   if (s1) y -= s2 / s1;
 }
 s0[j - 1][1] += s0[j - 1][0] = y;
 none$1(series, order);
</PRE><P>}
</P><P>function ascending$3(series) {
</P><PRE> var sums = series.map(sum$2);
 return none$2(series).sort(function(a, b) { return sums[a] - sums[b]; });
</PRE><P>}
</P><P>function sum$2(series) {
</P><PRE> var s = 0, i = -1, n = series.length, v;
 while (++i &lt; n) if (v = +series[i][1]) s += v;
 return s;
</PRE><P>}
</P><P>function descending$2(series) {
</P><PRE> return ascending$3(series).reverse();
</PRE><P>}
</P><P>function insideOut(series) {
</P><PRE> var n = series.length,
     i,
     j,
     sums = series.map(sum$2),
     order = none$2(series).sort(function(a, b) { return sums[b] - sums[a]; }),
     top = 0,
     bottom = 0,
     tops = [],
     bottoms = [];
</PRE><PRE> for (i = 0; i &lt; n; ++i) {
   j = order[i];
   if (top &lt; bottom) {
     top += sums[j];
     tops.push(j);
   } else {
     bottom += sums[j];
     bottoms.push(j);
   }
 }
</PRE><PRE> return bottoms.reverse().concat(tops);
</PRE><P>}
</P><P>function reverse(series) {
</P><PRE> return none$2(series).reverse();
</PRE><P>}
</P><P>function constant$c(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function x$4(d) {
</P><PRE> return d[0];
</PRE><P>}
</P><P>function y$4(d) {
</P><PRE> return d[1];
</PRE><P>}
</P><P>function RedBlackTree() {
</P><PRE> this._ = null; // root node
</PRE><P>}
</P><P>function RedBlackNode(node) {
</P><PRE> node.U = // parent node
 node.C = // color - true for red, false for black
 node.L = // left node
 node.R = // right node
 node.P = // previous node
 node.N = null; // next node
</PRE><P>}
</P><P>RedBlackTree.prototype = {
</P><PRE> constructor: RedBlackTree,
</PRE><PRE> insert: function(after, node) {
   var parent, grandpa, uncle;
</PRE><PRE>   if (after) {
     node.P = after;
     node.N = after.N;
     if (after.N) after.N.P = node;
     after.N = node;
     if (after.R) {
       after = after.R;
       while (after.L) after = after.L;
       after.L = node;
     } else {
       after.R = node;
     }
     parent = after;
   } else if (this._) {
     after = RedBlackFirst(this._);
     node.P = null;
     node.N = after;
     after.P = after.L = node;
     parent = after;
   } else {
     node.P = node.N = null;
     this._ = node;
     parent = null;
   }
   node.L = node.R = null;
   node.U = parent;
   node.C = true;
</PRE><PRE>   after = node;
   while (parent &amp;&amp; parent.C) {
     grandpa = parent.U;
     if (parent === grandpa.L) {
       uncle = grandpa.R;
       if (uncle &amp;&amp; uncle.C) {
         parent.C = uncle.C = false;
         grandpa.C = true;
         after = grandpa;
       } else {
         if (after === parent.R) {
           RedBlackRotateLeft(this, parent);
           after = parent;
           parent = after.U;
         }
         parent.C = false;
         grandpa.C = true;
         RedBlackRotateRight(this, grandpa);
       }
     } else {
       uncle = grandpa.L;
       if (uncle &amp;&amp; uncle.C) {
         parent.C = uncle.C = false;
         grandpa.C = true;
         after = grandpa;
       } else {
         if (after === parent.L) {
           RedBlackRotateRight(this, parent);
           after = parent;
           parent = after.U;
         }
         parent.C = false;
         grandpa.C = true;
         RedBlackRotateLeft(this, grandpa);
       }
     }
     parent = after.U;
   }
   this._.C = false;
 },
</PRE><PRE> remove: function(node) {
   if (node.N) node.N.P = node.P;
   if (node.P) node.P.N = node.N;
   node.N = node.P = null;
</PRE><PRE>   var parent = node.U,
       sibling,
       left = node.L,
       right = node.R,
       next,
       red;
</PRE><PRE>   if (!left) next = right;
   else if (!right) next = left;
   else next = RedBlackFirst(right);
</PRE><PRE>   if (parent) {
     if (parent.L === node) parent.L = next;
     else parent.R = next;
   } else {
     this._ = next;
   }
</PRE><PRE>   if (left &amp;&amp; right) {
     red = next.C;
     next.C = node.C;
     next.L = left;
     left.U = next;
     if (next !== right) {
       parent = next.U;
       next.U = node.U;
       node = next.R;
       parent.L = node;
       next.R = right;
       right.U = next;
     } else {
       next.U = parent;
       parent = next;
       node = next.R;
     }
   } else {
     red = node.C;
     node = next;
   }
</PRE><PRE>   if (node) node.U = parent;
   if (red) return;
   if (node &amp;&amp; node.C) { node.C = false; return; }
</PRE><PRE>   do {
     if (node === this._) break;
     if (node === parent.L) {
       sibling = parent.R;
       if (sibling.C) {
         sibling.C = false;
         parent.C = true;
         RedBlackRotateLeft(this, parent);
         sibling = parent.R;
       }
       if ((sibling.L &amp;&amp; sibling.L.C)
           || (sibling.R &amp;&amp; sibling.R.C)) {
         if (!sibling.R || !sibling.R.C) {
           sibling.L.C = false;
           sibling.C = true;
           RedBlackRotateRight(this, sibling);
           sibling = parent.R;
         }
         sibling.C = parent.C;
         parent.C = sibling.R.C = false;
         RedBlackRotateLeft(this, parent);
         node = this._;
         break;
       }
     } else {
       sibling = parent.L;
       if (sibling.C) {
         sibling.C = false;
         parent.C = true;
         RedBlackRotateRight(this, parent);
         sibling = parent.L;
       }
       if ((sibling.L &amp;&amp; sibling.L.C)
         || (sibling.R &amp;&amp; sibling.R.C)) {
         if (!sibling.L || !sibling.L.C) {
           sibling.R.C = false;
           sibling.C = true;
           RedBlackRotateLeft(this, sibling);
           sibling = parent.L;
         }
         sibling.C = parent.C;
         parent.C = sibling.L.C = false;
         RedBlackRotateRight(this, parent);
         node = this._;
         break;
       }
     }
     sibling.C = true;
     node = parent;
     parent = parent.U;
   } while (!node.C);
</PRE><PRE>   if (node) node.C = false;
 }
</PRE><P>};
</P><P>function RedBlackRotateLeft(tree, node) {
</P><PRE> var p = node,
     q = node.R,
     parent = p.U;
</PRE><PRE> if (parent) {
   if (parent.L === p) parent.L = q;
   else parent.R = q;
 } else {
   tree._ = q;
 }
</PRE><PRE> q.U = parent;
 p.U = q;
 p.R = q.L;
 if (p.R) p.R.U = p;
 q.L = p;
</PRE><P>}
</P><P>function RedBlackRotateRight(tree, node) {
</P><PRE> var p = node,
     q = node.L,
     parent = p.U;
</PRE><PRE> if (parent) {
   if (parent.L === p) parent.L = q;
   else parent.R = q;
 } else {
   tree._ = q;
 }
</PRE><PRE> q.U = parent;
 p.U = q;
 p.L = q.R;
 if (p.L) p.L.U = p;
 q.R = p;
</PRE><P>}
</P><P>function RedBlackFirst(node) {
</P><PRE> while (node.L) node = node.L;
 return node;
</PRE><P>}
</P><P>function createEdge(left, right, v0, v1) {
</P><PRE> var edge = [null, null],
     index = edges.push(edge) - 1;
 edge.left = left;
 edge.right = right;
 if (v0) setEdgeEnd(edge, left, right, v0);
 if (v1) setEdgeEnd(edge, right, left, v1);
 cells[left.index].halfedges.push(index);
 cells[right.index].halfedges.push(index);
 return edge;
</PRE><P>}
</P><P>function createBorderEdge(left, v0, v1) {
</P><PRE> var edge = [v0, v1];
 edge.left = left;
 return edge;
</PRE><P>}
</P><P>function setEdgeEnd(edge, left, right, vertex) {
</P><PRE> if (!edge[0] &amp;&amp; !edge[1]) {
   edge[0] = vertex;
   edge.left = left;
   edge.right = right;
 } else if (edge.left === right) {
   edge[1] = vertex;
 } else {
   edge[0] = vertex;
 }
</PRE><P>}
</P><P>// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
</P><PRE> var a = edge[0],
     b = edge[1],
     ax = a[0],
     ay = a[1],
     bx = b[0],
     by = b[1],
     t0 = 0,
     t1 = 1,
     dx = bx - ax,
     dy = by - ay,
     r;
</PRE><PRE> r = x0 - ax;
 if (!dx &amp;&amp; r &gt; 0) return;
 r /= dx;
 if (dx &lt; 0) {
   if (r &lt; t0) return;
   if (r &lt; t1) t1 = r;
 } else if (dx &gt; 0) {
   if (r &gt; t1) return;
   if (r &gt; t0) t0 = r;
 }
</PRE><PRE> r = x1 - ax;
 if (!dx &amp;&amp; r &lt; 0) return;
 r /= dx;
 if (dx &lt; 0) {
   if (r &gt; t1) return;
   if (r &gt; t0) t0 = r;
 } else if (dx &gt; 0) {
   if (r &lt; t0) return;
   if (r &lt; t1) t1 = r;
 }
</PRE><PRE> r = y0 - ay;
 if (!dy &amp;&amp; r &gt; 0) return;
 r /= dy;
 if (dy &lt; 0) {
   if (r &lt; t0) return;
   if (r &lt; t1) t1 = r;
 } else if (dy &gt; 0) {
   if (r &gt; t1) return;
   if (r &gt; t0) t0 = r;
 }
</PRE><PRE> r = y1 - ay;
 if (!dy &amp;&amp; r &lt; 0) return;
 r /= dy;
 if (dy &lt; 0) {
   if (r &gt; t1) return;
   if (r &gt; t0) t0 = r;
 } else if (dy &gt; 0) {
   if (r &lt; t0) return;
   if (r &lt; t1) t1 = r;
 }
</PRE><PRE> if (!(t0 &gt; 0) &amp;&amp; !(t1 &lt; 1)) return true; // TODO Better check?
</PRE><PRE> if (t0 &gt; 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
 if (t1 &lt; 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
 return true;
</PRE><P>}
</P><P>function connectEdge(edge, x0, y0, x1, y1) {
</P><PRE> var v1 = edge[1];
 if (v1) return true;
</PRE><PRE> var v0 = edge[0],
     left = edge.left,
     right = edge.right,
     lx = left[0],
     ly = left[1],
     rx = right[0],
     ry = right[1],
     fx = (lx + rx) / 2,
     fy = (ly + ry) / 2,
     fm,
     fb;
</PRE><PRE> if (ry === ly) {
   if (fx &lt; x0 || fx &gt;= x1) return;
   if (lx &gt; rx) {
     if (!v0) v0 = [fx, y0];
     else if (v0[1] &gt;= y1) return;
     v1 = [fx, y1];
   } else {
     if (!v0) v0 = [fx, y1];
     else if (v0[1] &lt; y0) return;
     v1 = [fx, y0];
   }
 } else {
   fm = (lx - rx) / (ry - ly);
   fb = fy - fm * fx;
   if (fm &lt; -1 || fm &gt; 1) {
     if (lx &gt; rx) {
       if (!v0) v0 = [(y0 - fb) / fm, y0];
       else if (v0[1] &gt;= y1) return;
       v1 = [(y1 - fb) / fm, y1];
     } else {
       if (!v0) v0 = [(y1 - fb) / fm, y1];
       else if (v0[1] &lt; y0) return;
       v1 = [(y0 - fb) / fm, y0];
     }
   } else {
     if (ly &lt; ry) {
       if (!v0) v0 = [x0, fm * x0 + fb];
       else if (v0[0] &gt;= x1) return;
       v1 = [x1, fm * x1 + fb];
     } else {
       if (!v0) v0 = [x1, fm * x1 + fb];
       else if (v0[0] &lt; x0) return;
       v1 = [x0, fm * x0 + fb];
     }
   }
 }
</PRE><PRE> edge[0] = v0;
 edge[1] = v1;
 return true;
</PRE><P>}
</P><P>function clipEdges(x0, y0, x1, y1) {
</P><PRE> var i = edges.length,
     edge;
</PRE><PRE> while (i--) {
   if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
       || !clipEdge(edge, x0, y0, x1, y1)
       || !(Math.abs(edge[0][0] - edge[1][0]) &gt; epsilon$4
           || Math.abs(edge[0][1] - edge[1][1]) &gt; epsilon$4)) {
     delete edges[i];
   }
 }
</PRE><P>}
</P><P>function createCell(site) {
</P><PRE> return cells[site.index] = {
   site: site,
   halfedges: []
 };
</PRE><P>}
</P><P>function cellHalfedgeAngle(cell, edge) {
</P><PRE> var site = cell.site,
     va = edge.left,
     vb = edge.right;
 if (site === vb) vb = va, va = site;
 if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
 if (site === va) va = edge[1], vb = edge[0];
 else va = edge[0], vb = edge[1];
 return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
</PRE><P>}
</P><P>function cellHalfedgeStart(cell, edge) {
</P><PRE> return edge[+(edge.left !== cell.site)];
</PRE><P>}
</P><P>function cellHalfedgeEnd(cell, edge) {
</P><PRE> return edge[+(edge.left === cell.site)];
</PRE><P>}
</P><P>function sortCellHalfedges() {
</P><PRE> for (var i = 0, n = cells.length, cell, halfedges, j, m; i &lt; n; ++i) {
   if ((cell = cells[i]) &amp;&amp; (m = (halfedges = cell.halfedges).length)) {
     var index = new Array(m),
         array = new Array(m);
     for (j = 0; j &lt; m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
     index.sort(function(i, j) { return array[j] - array[i]; });
     for (j = 0; j &lt; m; ++j) array[j] = halfedges[index[j]];
     for (j = 0; j &lt; m; ++j) halfedges[j] = array[j];
   }
 }
</PRE><P>}
</P><P>function clipCells(x0, y0, x1, y1) {
</P><PRE> var nCells = cells.length,
     iCell,
     cell,
     site,
     iHalfedge,
     halfedges,
     nHalfedges,
     start,
     startX,
     startY,
     end,
     endX,
     endY,
     cover = true;
</PRE><PRE> for (iCell = 0; iCell &lt; nCells; ++iCell) {
   if (cell = cells[iCell]) {
     site = cell.site;
     halfedges = cell.halfedges;
     iHalfedge = halfedges.length;
</PRE><PRE>     // Remove any dangling clipped edges.
     while (iHalfedge--) {
       if (!edges[halfedges[iHalfedge]]) {
         halfedges.splice(iHalfedge, 1);
       }
     }
</PRE><PRE>     // Insert any border edges as necessary.
     iHalfedge = 0, nHalfedges = halfedges.length;
     while (iHalfedge &lt; nHalfedges) {
       end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
       start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
       if (Math.abs(endX - startX) &gt; epsilon$4 || Math.abs(endY - startY) &gt; epsilon$4) {
         halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
             Math.abs(endX - x0) &lt; epsilon$4 &amp;&amp; y1 - endY &gt; epsilon$4 ? [x0, Math.abs(startX - x0) &lt; epsilon$4 ? startY : y1]
             : Math.abs(endY - y1) &lt; epsilon$4 &amp;&amp; x1 - endX &gt; epsilon$4 ? [Math.abs(startY - y1) &lt; epsilon$4 ? startX : x1, y1]
             : Math.abs(endX - x1) &lt; epsilon$4 &amp;&amp; endY - y0 &gt; epsilon$4 ? [x1, Math.abs(startX - x1) &lt; epsilon$4 ? startY : y0]
             : Math.abs(endY - y0) &lt; epsilon$4 &amp;&amp; endX - x0 &gt; epsilon$4 ? [Math.abs(startY - y0) &lt; epsilon$4 ? startX : x0, y0]
             : null)) - 1);
         ++nHalfedges;
       }
     }
</PRE><PRE>     if (nHalfedges) cover = false;
   }
 }
</PRE><PRE> // If there weren’t any edges, have the closest site cover the extent.
 // It doesn’t matter which corner of the extent we measure!
 if (cover) {
   var dx, dy, d2, dc = Infinity;
</PRE><PRE>   for (iCell = 0, cover = null; iCell &lt; nCells; ++iCell) {
     if (cell = cells[iCell]) {
       site = cell.site;
       dx = site[0] - x0;
       dy = site[1] - y0;
       d2 = dx * dx + dy * dy;
       if (d2 &lt; dc) dc = d2, cover = cell;
     }
   }
</PRE><PRE>   if (cover) {
     var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
     cover.halfedges.push(
       edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
       edges.push(createBorderEdge(site, v01, v11)) - 1,
       edges.push(createBorderEdge(site, v11, v10)) - 1,
       edges.push(createBorderEdge(site, v10, v00)) - 1
     );
   }
 }
</PRE><PRE> // Lastly delete any cells with no edges; these were entirely clipped.
 for (iCell = 0; iCell &lt; nCells; ++iCell) {
   if (cell = cells[iCell]) {
     if (!cell.halfedges.length) {
       delete cells[iCell];
     }
   }
 }
</PRE><P>}
</P><P>var circlePool = [];
</P><P>var firstCircle;
</P><P>function Circle() {
</P><PRE> RedBlackNode(this);
 this.x =
 this.y =
 this.arc =
 this.site =
 this.cy = null;
</PRE><P>}
</P><P>function attachCircle(arc) {
</P><PRE> var lArc = arc.P,
     rArc = arc.N;
</PRE><PRE> if (!lArc || !rArc) return;
</PRE><PRE> var lSite = lArc.site,
     cSite = arc.site,
     rSite = rArc.site;
</PRE><PRE> if (lSite === rSite) return;
</PRE><PRE> var bx = cSite[0],
     by = cSite[1],
     ax = lSite[0] - bx,
     ay = lSite[1] - by,
     cx = rSite[0] - bx,
     cy = rSite[1] - by;
</PRE><PRE> var d = 2 * (ax * cy - ay * cx);
 if (d &gt;= -epsilon2$2) return;
</PRE><PRE> var ha = ax * ax + ay * ay,
     hc = cx * cx + cy * cy,
     x = (cy * ha - ay * hc) / d,
     y = (ax * hc - cx * ha) / d;
</PRE><PRE> var circle = circlePool.pop() || new Circle;
 circle.arc = arc;
 circle.site = cSite;
 circle.x = x + bx;
 circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom
</PRE><PRE> arc.circle = circle;
</PRE><PRE> var before = null,
     node = circles._;
</PRE><PRE> while (node) {
   if (circle.y &lt; node.y || (circle.y === node.y &amp;&amp; circle.x &lt;= node.x)) {
     if (node.L) node = node.L;
     else { before = node.P; break; }
   } else {
     if (node.R) node = node.R;
     else { before = node; break; }
   }
 }
</PRE><PRE> circles.insert(before, circle);
 if (!before) firstCircle = circle;
</PRE><P>}
</P><P>function detachCircle(arc) {
</P><PRE> var circle = arc.circle;
 if (circle) {
   if (!circle.P) firstCircle = circle.N;
   circles.remove(circle);
   circlePool.push(circle);
   RedBlackNode(circle);
   arc.circle = null;
 }
</PRE><P>}
</P><P>var beachPool = [];
</P><P>function Beach() {
</P><PRE> RedBlackNode(this);
 this.edge =
 this.site =
 this.circle = null;
</PRE><P>}
</P><P>function createBeach(site) {
</P><PRE> var beach = beachPool.pop() || new Beach;
 beach.site = site;
 return beach;
</PRE><P>}
</P><P>function detachBeach(beach) {
</P><PRE> detachCircle(beach);
 beaches.remove(beach);
 beachPool.push(beach);
 RedBlackNode(beach);
</PRE><P>}
</P><P>function removeBeach(beach) {
</P><PRE> var circle = beach.circle,
     x = circle.x,
     y = circle.cy,
     vertex = [x, y],
     previous = beach.P,
     next = beach.N,
     disappearing = [beach];
</PRE><PRE> detachBeach(beach);
</PRE><PRE> var lArc = previous;
 while (lArc.circle
     &amp;&amp; Math.abs(x - lArc.circle.x) &lt; epsilon$4
     &amp;&amp; Math.abs(y - lArc.circle.cy) &lt; epsilon$4) {
   previous = lArc.P;
   disappearing.unshift(lArc);
   detachBeach(lArc);
   lArc = previous;
 }
</PRE><PRE> disappearing.unshift(lArc);
 detachCircle(lArc);
</PRE><PRE> var rArc = next;
 while (rArc.circle
     &amp;&amp; Math.abs(x - rArc.circle.x) &lt; epsilon$4
     &amp;&amp; Math.abs(y - rArc.circle.cy) &lt; epsilon$4) {
   next = rArc.N;
   disappearing.push(rArc);
   detachBeach(rArc);
   rArc = next;
 }
</PRE><PRE> disappearing.push(rArc);
 detachCircle(rArc);
</PRE><PRE> var nArcs = disappearing.length,
     iArc;
 for (iArc = 1; iArc &lt; nArcs; ++iArc) {
   rArc = disappearing[iArc];
   lArc = disappearing[iArc - 1];
   setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
 }
</PRE><PRE> lArc = disappearing[0];
 rArc = disappearing[nArcs - 1];
 rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
</PRE><PRE> attachCircle(lArc);
 attachCircle(rArc);
</PRE><P>}
</P><P>function addBeach(site) {
</P><PRE> var x = site[0],
     directrix = site[1],
     lArc,
     rArc,
     dxl,
     dxr,
     node = beaches._;
</PRE><PRE> while (node) {
   dxl = leftBreakPoint(node, directrix) - x;
   if (dxl &gt; epsilon$4) node = node.L; else {
     dxr = x - rightBreakPoint(node, directrix);
     if (dxr &gt; epsilon$4) {
       if (!node.R) {
         lArc = node;
         break;
       }
       node = node.R;
     } else {
       if (dxl &gt; -epsilon$4) {
         lArc = node.P;
         rArc = node;
       } else if (dxr &gt; -epsilon$4) {
         lArc = node;
         rArc = node.N;
       } else {
         lArc = rArc = node;
       }
       break;
     }
   }
 }
</PRE><PRE> createCell(site);
 var newArc = createBeach(site);
 beaches.insert(lArc, newArc);
</PRE><PRE> if (!lArc &amp;&amp; !rArc) return;
</PRE><PRE> if (lArc === rArc) {
   detachCircle(lArc);
   rArc = createBeach(lArc.site);
   beaches.insert(newArc, rArc);
   newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
   attachCircle(lArc);
   attachCircle(rArc);
   return;
 }
</PRE><PRE> if (!rArc) { // &amp;&amp; lArc
   newArc.edge = createEdge(lArc.site, newArc.site);
   return;
 }
</PRE><PRE> // else lArc !== rArc
 detachCircle(lArc);
 detachCircle(rArc);
</PRE><PRE> var lSite = lArc.site,
     ax = lSite[0],
     ay = lSite[1],
     bx = site[0] - ax,
     by = site[1] - ay,
     rSite = rArc.site,
     cx = rSite[0] - ax,
     cy = rSite[1] - ay,
     d = 2 * (bx * cy - by * cx),
     hb = bx * bx + by * by,
     hc = cx * cx + cy * cy,
     vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
</PRE><PRE> setEdgeEnd(rArc.edge, lSite, rSite, vertex);
 newArc.edge = createEdge(lSite, site, null, vertex);
 rArc.edge = createEdge(site, rSite, null, vertex);
 attachCircle(lArc);
 attachCircle(rArc);
</PRE><P>}
</P><P>function leftBreakPoint(arc, directrix) {
</P><PRE> var site = arc.site,
     rfocx = site[0],
     rfocy = site[1],
     pby2 = rfocy - directrix;
</PRE><PRE> if (!pby2) return rfocx;
</PRE><PRE> var lArc = arc.P;
 if (!lArc) return -Infinity;
</PRE><PRE> site = lArc.site;
 var lfocx = site[0],
     lfocy = site[1],
     plby2 = lfocy - directrix;
</PRE><PRE> if (!plby2) return lfocx;
</PRE><PRE> var hl = lfocx - rfocx,
     aby2 = 1 / pby2 - 1 / plby2,
     b = hl / plby2;
</PRE><PRE> if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
</PRE><PRE> return (rfocx + lfocx) / 2;
</PRE><P>}
</P><P>function rightBreakPoint(arc, directrix) {
</P><PRE> var rArc = arc.N;
 if (rArc) return leftBreakPoint(rArc, directrix);
 var site = arc.site;
 return site[1] === directrix ? site[0] : Infinity;
</PRE><P>}
</P><P>var epsilon$4 = 1e-6;
var epsilon2$2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;
</P><P>function triangleArea(a, b, c) {
</P><PRE> return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
</PRE><P>}
</P><P>function lexicographic(a, b) {
</P><PRE> return b[1] - a[1]
     || b[0] - a[0];
</PRE><P>}
</P><P>function Diagram(sites, extent) {
</P><PRE> var site = sites.sort(lexicographic).pop(),
     x,
     y,
     circle;
</PRE><PRE> edges = [];
 cells = new Array(sites.length);
 beaches = new RedBlackTree;
 circles = new RedBlackTree;
</PRE><PRE> while (true) {
   circle = firstCircle;
   if (site &amp;&amp; (!circle || site[1] &lt; circle.y || (site[1] === circle.y &amp;&amp; site[0] &lt; circle.x))) {
     if (site[0] !== x || site[1] !== y) {
       addBeach(site);
       x = site[0], y = site[1];
     }
     site = sites.pop();
   } else if (circle) {
     removeBeach(circle.arc);
   } else {
     break;
   }
 }
</PRE><PRE> sortCellHalfedges();
</PRE><PRE> if (extent) {
   var x0 = +extent[0][0],
       y0 = +extent[0][1],
       x1 = +extent[1][0],
       y1 = +extent[1][1];
   clipEdges(x0, y0, x1, y1);
   clipCells(x0, y0, x1, y1);
 }
</PRE><PRE> this.edges = edges;
 this.cells = cells;
</PRE><PRE> beaches =
 circles =
 edges =
 cells = null;
</PRE><P>}
</P><P>Diagram.prototype = {
</P><PRE> constructor: Diagram,
</PRE><PRE> polygons: function() {
   var edges = this.edges;
</PRE><PRE>   return this.cells.map(function(cell) {
     var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
     polygon.data = cell.site.data;
     return polygon;
   });
 },
</PRE><PRE> triangles: function() {
   var triangles = [],
       edges = this.edges;
</PRE><PRE>   this.cells.forEach(function(cell, i) {
     if (!(m = (halfedges = cell.halfedges).length)) return;
     var site = cell.site,
         halfedges,
         j = -1,
         m,
         s0,
         e1 = edges[halfedges[m - 1]],
         s1 = e1.left === site ? e1.right : e1.left;
</PRE><PRE>     while (++j &lt; m) {
       s0 = s1;
       e1 = edges[halfedges[j]];
       s1 = e1.left === site ? e1.right : e1.left;
       if (s0 &amp;&amp; s1 &amp;&amp; i &lt; s0.index &amp;&amp; i &lt; s1.index &amp;&amp; triangleArea(site, s0, s1) &lt; 0) {
         triangles.push([site.data, s0.data, s1.data]);
       }
     }
   });
</PRE><PRE>   return triangles;
 },
</PRE><PRE> links: function() {
   return this.edges.filter(function(edge) {
     return edge.right;
   }).map(function(edge) {
     return {
       source: edge.left.data,
       target: edge.right.data
     };
   });
 },
</PRE><PRE> find: function(x, y, radius) {
   var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
</PRE><PRE>   // Use the previously-found cell, or start with an arbitrary one.
   while (!(cell = that.cells[i1])) if (++i1 &gt;= n) return null;
   var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;
</PRE><PRE>   // Traverse the half-edges to find a closer cell, if any.
   do {
     cell = that.cells[i0 = i1], i1 = null;
     cell.halfedges.forEach(function(e) {
       var edge = that.edges[e], v = edge.left;
       if ((v === cell.site || !v) &amp;&amp; !(v = edge.right)) return;
       var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
       if (v2 &lt; d2) d2 = v2, i1 = v.index;
     });
   } while (i1 !== null);
</PRE><PRE>   that._found = i0;
</PRE><PRE>   return radius == null || d2 &lt;= radius * radius ? cell.site : null;
 }
</PRE><P>};
</P><P>function voronoi() {
</P><PRE> var x$$1 = x$4,
     y$$1 = y$4,
     extent = null;
</PRE><PRE> function voronoi(data) {
   return new Diagram(data.map(function(d, i) {
     var s = [Math.round(x$$1(d, i, data) / epsilon$4) * epsilon$4, Math.round(y$$1(d, i, data) / epsilon$4) * epsilon$4];
     s.index = i;
     s.data = d;
     return s;
   }), extent);
 }
</PRE><PRE> voronoi.polygons = function(data) {
   return voronoi(data).polygons();
 };
</PRE><PRE> voronoi.links = function(data) {
   return voronoi(data).links();
 };
</PRE><PRE> voronoi.triangles = function(data) {
   return voronoi(data).triangles();
 };
</PRE><PRE> voronoi.x = function(_) {
   return arguments.length ? (x$$1 = typeof _ === &quot;function&quot; ? _ : constant$c(+_), voronoi) : x$$1;
 };
</PRE><PRE> voronoi.y = function(_) {
   return arguments.length ? (y$$1 = typeof _ === &quot;function&quot; ? _ : constant$c(+_), voronoi) : y$$1;
 };
</PRE><PRE> voronoi.extent = function(_) {
   return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent &amp;&amp; [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
 };
</PRE><PRE> voronoi.size = function(_) {
   return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent &amp;&amp; [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
 };
</PRE><PRE> return voronoi;
</PRE><P>}
</P><P>function constant$d(x) {
</P><PRE> return function() {
   return x;
 };
</PRE><P>}
</P><P>function ZoomEvent(target, type, transform) {
</P><PRE> this.target = target;
 this.type = type;
 this.transform = transform;
</PRE><P>}
</P><P>function Transform(k, x, y) {
</P><PRE> this.k = k;
 this.x = x;
 this.y = y;
</PRE><P>}
</P><P>Transform.prototype = {
</P><PRE> constructor: Transform,
 scale: function(k) {
   return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
 },
 translate: function(x, y) {
   return x === 0 &amp; y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
 },
 apply: function(point) {
   return [point[0] * this.k + this.x, point[1] * this.k + this.y];
 },
 applyX: function(x) {
   return x * this.k + this.x;
 },
 applyY: function(y) {
   return y * this.k + this.y;
 },
 invert: function(location) {
   return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
 },
 invertX: function(x) {
   return (x - this.x) / this.k;
 },
 invertY: function(y) {
   return (y - this.y) / this.k;
 },
 rescaleX: function(x) {
   return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
 },
 rescaleY: function(y) {
   return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
 },
 toString: function() {
   return &quot;translate(&quot; + this.x + &quot;,&quot; + this.y + &quot;) scale(&quot; + this.k + &quot;)&quot;;
 }
</PRE><P>};
</P><P>var identity$8 = new Transform(1, 0, 0);
</P><P>transform$1.prototype = Transform.prototype;
</P><P>function transform$1(node) {
</P><PRE> return node.__zoom || identity$8;
</PRE><P>}
</P><P>function nopropagation$2() {
</P><PRE> exports.event.stopImmediatePropagation();
</PRE><P>}
</P><P>function noevent$2() {
</P><PRE> exports.event.preventDefault();
 exports.event.stopImmediatePropagation();
</PRE><P>}
</P><P>// Ignore right-click, since that should open the context menu.
function defaultFilter$2() {
</P><PRE> return !exports.event.button;
</PRE><P>}
</P><P>function defaultExtent$1() {
</P><PRE> var e = this, w, h;
 if (e instanceof SVGElement) {
   e = e.ownerSVGElement || e;
   w = e.width.baseVal.value;
   h = e.height.baseVal.value;
 } else {
   w = e.clientWidth;
   h = e.clientHeight;
 }
 return [[0, 0], [w, h]];
</PRE><P>}
</P><P>function defaultTransform() {
</P><PRE> return this.__zoom || identity$8;
</PRE><P>}
</P><P>function defaultWheelDelta() {
</P><PRE> return -exports.event.deltaY * (exports.event.deltaMode ? 120 : 1) / 500;
</PRE><P>}
</P><P>function defaultTouchable$1() {
</P><PRE> return &quot;ontouchstart&quot; in this;
</PRE><P>}
</P><P>function defaultConstrain(transform, extent, translateExtent) {
</P><PRE> var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
     dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
     dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
     dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
 return transform.translate(
   dx1 &gt; dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
   dy1 &gt; dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
 );
</PRE><P>}
</P><P>function zoom() {
</P><PRE> var filter = defaultFilter$2,
     extent = defaultExtent$1,
     constrain = defaultConstrain,
     wheelDelta = defaultWheelDelta,
     touchable = defaultTouchable$1,
     scaleExtent = [0, Infinity],
     translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
     duration = 250,
     interpolate = interpolateZoom,
     gestures = [],
     listeners = dispatch(&quot;start&quot;, &quot;zoom&quot;, &quot;end&quot;),
     touchstarting,
     touchending,
     touchDelay = 500,
     wheelDelay = 150,
     clickDistance2 = 0;
</PRE><PRE> function zoom(selection$$1) {
   selection$$1
       .property(&quot;__zoom&quot;, defaultTransform)
       .on(&quot;wheel.zoom&quot;, wheeled)
       .on(&quot;mousedown.zoom&quot;, mousedowned)
       .on(&quot;dblclick.zoom&quot;, dblclicked)
     .filter(touchable)
       .on(&quot;touchstart.zoom&quot;, touchstarted)
       .on(&quot;touchmove.zoom&quot;, touchmoved)
       .on(&quot;touchend.zoom touchcancel.zoom&quot;, touchended)
       .style(&quot;touch-action&quot;, &quot;none&quot;)
       .style(&quot;-webkit-tap-highlight-color&quot;, &quot;rgba(0,0,0,0)&quot;);
 }
</PRE><PRE> zoom.transform = function(collection, transform) {
   var selection$$1 = collection.selection ? collection.selection() : collection;
   selection$$1.property(&quot;__zoom&quot;, defaultTransform);
   if (collection !== selection$$1) {
     schedule(collection, transform);
   } else {
     selection$$1.interrupt().each(function() {
       gesture(this, arguments)
           .start()
           .zoom(null, typeof transform === &quot;function&quot; ? transform.apply(this, arguments) : transform)
           .end();
     });
   }
 };
</PRE><PRE> zoom.scaleBy = function(selection$$1, k) {
   zoom.scaleTo(selection$$1, function() {
     var k0 = this.__zoom.k,
         k1 = typeof k === &quot;function&quot; ? k.apply(this, arguments) : k;
     return k0 * k1;
   });
 };
</PRE><PRE> zoom.scaleTo = function(selection$$1, k) {
   zoom.transform(selection$$1, function() {
     var e = extent.apply(this, arguments),
         t0 = this.__zoom,
         p0 = centroid(e),
         p1 = t0.invert(p0),
         k1 = typeof k === &quot;function&quot; ? k.apply(this, arguments) : k;
     return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
   });
 };
</PRE><PRE> zoom.translateBy = function(selection$$1, x, y) {
   zoom.transform(selection$$1, function() {
     return constrain(this.__zoom.translate(
       typeof x === &quot;function&quot; ? x.apply(this, arguments) : x,
       typeof y === &quot;function&quot; ? y.apply(this, arguments) : y
     ), extent.apply(this, arguments), translateExtent);
   });
 };
</PRE><PRE> zoom.translateTo = function(selection$$1, x, y) {
   zoom.transform(selection$$1, function() {
     var e = extent.apply(this, arguments),
         t = this.__zoom,
         p = centroid(e);
     return constrain(identity$8.translate(p[0], p[1]).scale(t.k).translate(
       typeof x === &quot;function&quot; ? -x.apply(this, arguments) : -x,
       typeof y === &quot;function&quot; ? -y.apply(this, arguments) : -y
     ), e, translateExtent);
   });
 };
</PRE><PRE> function scale(transform, k) {
   k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
   return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
 }
</PRE><PRE> function translate(transform, p0, p1) {
   var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
   return x === transform.x &amp;&amp; y === transform.y ? transform : new Transform(transform.k, x, y);
 }
</PRE><PRE> function centroid(extent) {
   return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
 }
</PRE><PRE> function schedule(transition$$1, transform, center) {
   transition$$1
       .on(&quot;start.zoom&quot;, function() { gesture(this, arguments).start(); })
       .on(&quot;interrupt.zoom end.zoom&quot;, function() { gesture(this, arguments).end(); })
       .tween(&quot;zoom&quot;, function() {
         var that = this,
             args = arguments,
             g = gesture(that, args),
             e = extent.apply(that, args),
             p = center || centroid(e),
             w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
             a = that.__zoom,
             b = typeof transform === &quot;function&quot; ? transform.apply(that, args) : transform,
             i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
         return function(t) {
           if (t === 1) t = b; // Avoid rounding error on end.
           else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
           g.zoom(null, t);
         };
       });
 }
</PRE><PRE> function gesture(that, args) {
   for (var i = 0, n = gestures.length, g; i &lt; n; ++i) {
     if ((g = gestures[i]).that === that) {
       return g;
     }
   }
   return new Gesture(that, args);
 }
</PRE><PRE> function Gesture(that, args) {
   this.that = that;
   this.args = args;
   this.index = -1;
   this.active = 0;
   this.extent = extent.apply(that, args);
 }
</PRE><PRE> Gesture.prototype = {
   start: function() {
     if (++this.active === 1) {
       this.index = gestures.push(this) - 1;
       this.emit(&quot;start&quot;);
     }
     return this;
   },
   zoom: function(key, transform) {
     if (this.mouse &amp;&amp; key !== &quot;mouse&quot;) this.mouse[1] = transform.invert(this.mouse[0]);
     if (this.touch0 &amp;&amp; key !== &quot;touch&quot;) this.touch0[1] = transform.invert(this.touch0[0]);
     if (this.touch1 &amp;&amp; key !== &quot;touch&quot;) this.touch1[1] = transform.invert(this.touch1[0]);
     this.that.__zoom = transform;
     this.emit(&quot;zoom&quot;);
     return this;
   },
   end: function() {
     if (--this.active === 0) {
       gestures.splice(this.index, 1);
       this.index = -1;
       this.emit(&quot;end&quot;);
     }
     return this;
   },
   emit: function(type) {
     customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
   }
 };
</PRE><PRE> function wheeled() {
   if (!filter.apply(this, arguments)) return;
   var g = gesture(this, arguments),
       t = this.__zoom,
       k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
       p = mouse(this);
</PRE><PRE>   // If the mouse is in the same location as before, reuse it.
   // If there were recent wheel events, reset the wheel idle timeout.
   if (g.wheel) {
     if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
       g.mouse[1] = t.invert(g.mouse[0] = p);
     }
     clearTimeout(g.wheel);
   }
</PRE><PRE>   // If this wheel event won’t trigger a transform change, ignore it.
   else if (t.k === k) return;
</PRE><PRE>   // Otherwise, capture the mouse point and location at the start.
   else {
     g.mouse = [p, t.invert(p)];
     interrupt(this);
     g.start();
   }
</PRE><PRE>   noevent$2();
   g.wheel = setTimeout(wheelidled, wheelDelay);
   g.zoom(&quot;mouse&quot;, constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
</PRE><PRE>   function wheelidled() {
     g.wheel = null;
     g.end();
   }
 }
</PRE><PRE> function mousedowned() {
   if (touchending || !filter.apply(this, arguments)) return;
   var g = gesture(this, arguments),
       v = select(exports.event.view).on(&quot;mousemove.zoom&quot;, mousemoved, true).on(&quot;mouseup.zoom&quot;, mouseupped, true),
       p = mouse(this),
       x0 = exports.event.clientX,
       y0 = exports.event.clientY;
</PRE><PRE>   dragDisable(exports.event.view);
   nopropagation$2();
   g.mouse = [p, this.__zoom.invert(p)];
   interrupt(this);
   g.start();
</PRE><PRE>   function mousemoved() {
     noevent$2();
     if (!g.moved) {
       var dx = exports.event.clientX - x0, dy = exports.event.clientY - y0;
       g.moved = dx * dx + dy * dy &gt; clickDistance2;
     }
     g.zoom(&quot;mouse&quot;, constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));
   }
</PRE><PRE>   function mouseupped() {
     v.on(&quot;mousemove.zoom mouseup.zoom&quot;, null);
     yesdrag(exports.event.view, g.moved);
     noevent$2();
     g.end();
   }
 }
</PRE><PRE> function dblclicked() {
   if (!filter.apply(this, arguments)) return;
   var t0 = this.__zoom,
       p0 = mouse(this),
       p1 = t0.invert(p0),
       k1 = t0.k * (exports.event.shiftKey ? 0.5 : 2),
       t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);
</PRE><PRE>   noevent$2();
   if (duration &gt; 0) select(this).transition().duration(duration).call(schedule, t1, p0);
   else select(this).call(zoom.transform, t1);
 }
</PRE><PRE> function touchstarted() {
   if (!filter.apply(this, arguments)) return;
   var g = gesture(this, arguments),
       touches$$1 = exports.event.changedTouches,
       started,
       n = touches$$1.length, i, t, p;
</PRE><PRE>   nopropagation$2();
   for (i = 0; i &lt; n; ++i) {
     t = touches$$1[i], p = touch(this, touches$$1, t.identifier);
     p = [p, this.__zoom.invert(p), t.identifier];
     if (!g.touch0) g.touch0 = p, started = true;
     else if (!g.touch1) g.touch1 = p;
   }
</PRE><PRE>   // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
   if (touchstarting) {
     touchstarting = clearTimeout(touchstarting);
     if (!g.touch1) {
       g.end();
       p = select(this).on(&quot;dblclick.zoom&quot;);
       if (p) p.apply(this, arguments);
       return;
     }
   }
</PRE><PRE>   if (started) {
     touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
     interrupt(this);
     g.start();
   }
 }
</PRE><PRE> function touchmoved() {
   var g = gesture(this, arguments),
       touches$$1 = exports.event.changedTouches,
       n = touches$$1.length, i, t, p, l;
</PRE><PRE>   noevent$2();
   if (touchstarting) touchstarting = clearTimeout(touchstarting);
   for (i = 0; i &lt; n; ++i) {
     t = touches$$1[i], p = touch(this, touches$$1, t.identifier);
     if (g.touch0 &amp;&amp; g.touch0[2] === t.identifier) g.touch0[0] = p;
     else if (g.touch1 &amp;&amp; g.touch1[2] === t.identifier) g.touch1[0] = p;
   }
   t = g.that.__zoom;
   if (g.touch1) {
     var p0 = g.touch0[0], l0 = g.touch0[1],
         p1 = g.touch1[0], l1 = g.touch1[1],
         dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
         dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
     t = scale(t, Math.sqrt(dp / dl));
     p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
     l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
   }
   else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
   else return;
   g.zoom(&quot;touch&quot;, constrain(translate(t, p, l), g.extent, translateExtent));
 }
</PRE><PRE> function touchended() {
   var g = gesture(this, arguments),
       touches$$1 = exports.event.changedTouches,
       n = touches$$1.length, i, t;
</PRE><PRE>   nopropagation$2();
   if (touchending) clearTimeout(touchending);
   touchending = setTimeout(function() { touchending = null; }, touchDelay);
   for (i = 0; i &lt; n; ++i) {
     t = touches$$1[i];
     if (g.touch0 &amp;&amp; g.touch0[2] === t.identifier) delete g.touch0;
     else if (g.touch1 &amp;&amp; g.touch1[2] === t.identifier) delete g.touch1;
   }
   if (g.touch1 &amp;&amp; !g.touch0) g.touch0 = g.touch1, delete g.touch1;
   if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
   else g.end();
 }
</PRE><PRE> zoom.wheelDelta = function(_) {
   return arguments.length ? (wheelDelta = typeof _ === &quot;function&quot; ? _ : constant$d(+_), zoom) : wheelDelta;
 };
</PRE><PRE> zoom.filter = function(_) {
   return arguments.length ? (filter = typeof _ === &quot;function&quot; ? _ : constant$d(!!_), zoom) : filter;
 };
</PRE><PRE> zoom.touchable = function(_) {
   return arguments.length ? (touchable = typeof _ === &quot;function&quot; ? _ : constant$d(!!_), zoom) : touchable;
 };
</PRE><PRE> zoom.extent = function(_) {
   return arguments.length ? (extent = typeof _ === &quot;function&quot; ? _ : constant$d([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
 };
</PRE><PRE> zoom.scaleExtent = function(_) {
   return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
 };
</PRE><PRE> zoom.translateExtent = function(_) {
   return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
 };
</PRE><PRE> zoom.constrain = function(_) {
   return arguments.length ? (constrain = _, zoom) : constrain;
 };
</PRE><PRE> zoom.duration = function(_) {
   return arguments.length ? (duration = +_, zoom) : duration;
 };
</PRE><PRE> zoom.interpolate = function(_) {
   return arguments.length ? (interpolate = _, zoom) : interpolate;
 };
</PRE><PRE> zoom.on = function() {
   var value = listeners.on.apply(listeners, arguments);
   return value === listeners ? zoom : value;
 };
</PRE><PRE> zoom.clickDistance = function(_) {
   return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
 };
</PRE><PRE> return zoom;
</PRE><P>}
</P><P>exports.version = version;
exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = thresholdSturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = threshold;
exports.range = sequence;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;
exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;
exports.brush = brush;
exports.brushX = brushX;
exports.brushY = brushY;
exports.brushSelection = brushSelection;
exports.chord = chord;
exports.ribbon = ribbon;
exports.nest = nest;
exports.set = set$2;
exports.map = map$1;
exports.keys = keys;
exports.values = values;
exports.entries = entries;
exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.lch = lch;
exports.gray = gray;
exports.cubehelix = cubehelix;
exports.contours = contours;
exports.contourDensity = density;
exports.dispatch = dispatch;
exports.drag = drag;
exports.dragDisable = dragDisable;
exports.dragEnable = yesdrag;
exports.dsvFormat = dsvFormat;
exports.csvParse = csvParse;
exports.csvParseRows = csvParseRows;
exports.csvFormat = csvFormat;
exports.csvFormatRows = csvFormatRows;
exports.tsvParse = tsvParse;
exports.tsvParseRows = tsvParseRows;
exports.tsvFormat = tsvFormat;
exports.tsvFormatRows = tsvFormatRows;
exports.easeLinear = linear$1;
exports.easeQuad = quadInOut;
exports.easeQuadIn = quadIn;
exports.easeQuadOut = quadOut;
exports.easeQuadInOut = quadInOut;
exports.easeCubic = cubicInOut;
exports.easeCubicIn = cubicIn;
exports.easeCubicOut = cubicOut;
exports.easeCubicInOut = cubicInOut;
exports.easePoly = polyInOut;
exports.easePolyIn = polyIn;
exports.easePolyOut = polyOut;
exports.easePolyInOut = polyInOut;
exports.easeSin = sinInOut;
exports.easeSinIn = sinIn;
exports.easeSinOut = sinOut;
exports.easeSinInOut = sinInOut;
exports.easeExp = expInOut;
exports.easeExpIn = expIn;
exports.easeExpOut = expOut;
exports.easeExpInOut = expInOut;
exports.easeCircle = circleInOut;
exports.easeCircleIn = circleIn;
exports.easeCircleOut = circleOut;
exports.easeCircleInOut = circleInOut;
exports.easeBounce = bounceOut;
exports.easeBounceIn = bounceIn;
exports.easeBounceOut = bounceOut;
exports.easeBounceInOut = bounceInOut;
exports.easeBack = backInOut;
exports.easeBackIn = backIn;
exports.easeBackOut = backOut;
exports.easeBackInOut = backInOut;
exports.easeElastic = elasticOut;
exports.easeElasticIn = elasticIn;
exports.easeElasticOut = elasticOut;
exports.easeElasticInOut = elasticInOut;
exports.blob = blob;
exports.buffer = buffer;
exports.dsv = dsv;
exports.csv = csv$1;
exports.tsv = tsv$1;
exports.image = image;
exports.json = json;
exports.text = text;
exports.xml = xml;
exports.html = html;
exports.svg = svg;
exports.forceCenter = center$1;
exports.forceCollide = collide;
exports.forceLink = link;
exports.forceManyBody = manyBody;
exports.forceRadial = radial;
exports.forceSimulation = simulation;
exports.forceX = x$2;
exports.forceY = y$2;
exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;
exports.geoArea = area$1;
exports.geoBounds = bounds;
exports.geoCentroid = centroid;
exports.geoCircle = circle;
exports.geoClipAntimeridian = clipAntimeridian;
exports.geoClipCircle = clipCircle;
exports.geoClipExtent = extent$1;
exports.geoClipRectangle = clipRectangle;
exports.geoContains = contains$1;
exports.geoDistance = distance;
exports.geoGraticule = graticule;
exports.geoGraticule10 = graticule10;
exports.geoInterpolate = interpolate$1;
exports.geoLength = length$1;
exports.geoPath = index$1;
exports.geoAlbers = albers;
exports.geoAlbersUsa = albersUsa;
exports.geoAzimuthalEqualArea = azimuthalEqualArea;
exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
exports.geoAzimuthalEquidistant = azimuthalEquidistant;
exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
exports.geoConicConformal = conicConformal;
exports.geoConicConformalRaw = conicConformalRaw;
exports.geoConicEqualArea = conicEqualArea;
exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
exports.geoConicEquidistant = conicEquidistant;
exports.geoConicEquidistantRaw = conicEquidistantRaw;
exports.geoEqualEarth = equalEarth;
exports.geoEqualEarthRaw = equalEarthRaw;
exports.geoEquirectangular = equirectangular;
exports.geoEquirectangularRaw = equirectangularRaw;
exports.geoGnomonic = gnomonic;
exports.geoGnomonicRaw = gnomonicRaw;
exports.geoIdentity = identity$5;
exports.geoProjection = projection;
exports.geoProjectionMutator = projectionMutator;
exports.geoMercator = mercator;
exports.geoMercatorRaw = mercatorRaw;
exports.geoNaturalEarth1 = naturalEarth1;
exports.geoNaturalEarth1Raw = naturalEarth1Raw;
exports.geoOrthographic = orthographic;
exports.geoOrthographicRaw = orthographicRaw;
exports.geoStereographic = stereographic;
exports.geoStereographicRaw = stereographicRaw;
exports.geoTransverseMercator = transverseMercator;
exports.geoTransverseMercatorRaw = transverseMercatorRaw;
exports.geoRotation = rotation;
exports.geoStream = geoStream;
exports.geoTransform = transform;
exports.cluster = cluster;
exports.hierarchy = hierarchy;
exports.pack = index$2;
exports.packSiblings = siblings;
exports.packEnclose = enclose;
exports.partition = partition;
exports.stratify = stratify;
exports.tree = tree;
exports.treemap = index$3;
exports.treemapBinary = binary;
exports.treemapDice = treemapDice;
exports.treemapSlice = treemapSlice;
exports.treemapSliceDice = sliceDice;
exports.treemapSquarify = squarify;
exports.treemapResquarify = resquarify;
exports.interpolate = interpolateValue;
exports.interpolateArray = array$1;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateDiscrete = discrete;
exports.interpolateHue = hue$1;
exports.interpolateNumber = interpolateNumber;
exports.interpolateObject = object;
exports.interpolateRound = interpolateRound;
exports.interpolateString = interpolateString;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = interpolateZoom;
exports.interpolateRgb = interpolateRgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$2;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab$1;
exports.interpolateHcl = hcl$2;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$2;
exports.interpolateCubehelixLong = cubehelixLong;
exports.piecewise = piecewise;
exports.quantize = quantize;
exports.path = path;
exports.polygonArea = area$2;
exports.polygonCentroid = centroid$1;
exports.polygonHull = hull;
exports.polygonContains = contains$2;
exports.polygonLength = length$2;
exports.quadtree = quadtree;
exports.randomUniform = uniform;
exports.randomNormal = normal;
exports.randomLogNormal = logNormal;
exports.randomBates = bates;
exports.randomIrwinHall = irwinHall;
exports.randomExponential = exponential$1;
exports.scaleBand = band;
exports.scalePoint = point$1;
exports.scaleIdentity = identity$6;
exports.scaleLinear = linear$2;
exports.scaleLog = log$1;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow$1;
exports.scaleSqrt = sqrt$1;
exports.scaleQuantile = quantile$$1;
exports.scaleQuantize = quantize$1;
exports.scaleThreshold = threshold$1;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.scaleSequential = sequential;
exports.scaleDiverging = diverging;
exports.schemeCategory10 = category10;
exports.schemeAccent = Accent;
exports.schemeDark2 = Dark2;
exports.schemePaired = Paired;
exports.schemePastel1 = Pastel1;
exports.schemePastel2 = Pastel2;
exports.schemeSet1 = Set1;
exports.schemeSet2 = Set2;
exports.schemeSet3 = Set3;
exports.interpolateBrBG = BrBG;
exports.schemeBrBG = scheme;
exports.interpolatePRGn = PRGn;
exports.schemePRGn = scheme$1;
exports.interpolatePiYG = PiYG;
exports.schemePiYG = scheme$2;
exports.interpolatePuOr = PuOr;
exports.schemePuOr = scheme$3;
exports.interpolateRdBu = RdBu;
exports.schemeRdBu = scheme$4;
exports.interpolateRdGy = RdGy;
exports.schemeRdGy = scheme$5;
exports.interpolateRdYlBu = RdYlBu;
exports.schemeRdYlBu = scheme$6;
exports.interpolateRdYlGn = RdYlGn;
exports.schemeRdYlGn = scheme$7;
exports.interpolateSpectral = Spectral;
exports.schemeSpectral = scheme$8;
exports.interpolateBuGn = BuGn;
exports.schemeBuGn = scheme$9;
exports.interpolateBuPu = BuPu;
exports.schemeBuPu = scheme$a;
exports.interpolateGnBu = GnBu;
exports.schemeGnBu = scheme$b;
exports.interpolateOrRd = OrRd;
exports.schemeOrRd = scheme$c;
exports.interpolatePuBuGn = PuBuGn;
exports.schemePuBuGn = scheme$d;
exports.interpolatePuBu = PuBu;
exports.schemePuBu = scheme$e;
exports.interpolatePuRd = PuRd;
exports.schemePuRd = scheme$f;
exports.interpolateRdPu = RdPu;
exports.schemeRdPu = scheme$g;
exports.interpolateYlGnBu = YlGnBu;
exports.schemeYlGnBu = scheme$h;
exports.interpolateYlGn = YlGn;
exports.schemeYlGn = scheme$i;
exports.interpolateYlOrBr = YlOrBr;
exports.schemeYlOrBr = scheme$j;
exports.interpolateYlOrRd = YlOrRd;
exports.schemeYlOrRd = scheme$k;
exports.interpolateBlues = Blues;
exports.schemeBlues = scheme$l;
exports.interpolateGreens = Greens;
exports.schemeGreens = scheme$m;
exports.interpolateGreys = Greys;
exports.schemeGreys = scheme$n;
exports.interpolatePurples = Purples;
exports.schemePurples = scheme$o;
exports.interpolateReds = Reds;
exports.schemeReds = scheme$p;
exports.interpolateOranges = Oranges;
exports.schemeOranges = scheme$q;
exports.interpolateCubehelixDefault = cubehelix$3;
exports.interpolateRainbow = rainbow;
exports.interpolateWarm = warm;
exports.interpolateCool = cool;
exports.interpolateSinebow = sinebow;
exports.interpolateViridis = viridis;
exports.interpolateMagma = magma;
exports.interpolateInferno = inferno;
exports.interpolatePlasma = plasma;
exports.create = create;
exports.creator = creator;
exports.local = local;
exports.matcher = matcher$1;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.clientPoint = point;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;
exports.customEvent = customEvent;
exports.arc = arc;
exports.area = area$3;
exports.line = line;
exports.pie = pie;
exports.areaRadial = areaRadial;
exports.radialArea = areaRadial;
exports.lineRadial = lineRadial$1;
exports.radialLine = lineRadial$1;
exports.pointRadial = pointRadial;
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;
exports.symbol = symbol;
exports.symbols = symbols;
exports.symbolCircle = circle$2;
exports.symbolCross = cross$2;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.curveBasisClosed = basisClosed$1;
exports.curveBasisOpen = basisOpen;
exports.curveBasis = basis$2;
exports.curveBundle = bundle;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCardinal = cardinal;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveCatmullRom = catmullRom;
exports.curveLinearClosed = linearClosed;
exports.curveLinear = curveLinear;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.stack = stack;
exports.stackOffsetExpand = expand;
exports.stackOffsetDiverging = diverging$1;
exports.stackOffsetNone = none$1;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAscending = ascending$3;
exports.stackOrderDescending = descending$2;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$2;
exports.stackOrderReverse = reverse;
exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;
exports.timeFormatDefaultLocale = defaultLocale$1;
exports.timeFormatLocale = formatLocale$1;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;
exports.now = now;
exports.timer = timer;
exports.timerFlush = timerFlush;
exports.timeout = timeout$1;
exports.interval = interval$1;
exports.transition = transition;
exports.active = active;
exports.interrupt = interrupt;
exports.voronoi = voronoi;
exports.zoom = zoom;
exports.zoomTransform = transform$1;
exports.zoomIdentity = identity$8;
</P><P>Object.defineProperty(exports, '__esModule', { value: true });
</P><P>})));
</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
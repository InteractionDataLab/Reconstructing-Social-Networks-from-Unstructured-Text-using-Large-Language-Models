<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Groningen_js_materialize_js skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Groningen/js/materialize.js</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>/*!
</P><PRE>* Materialize v1.0.0 (<A rel="nofollow" class="external free" href="http://materializecss.com">http://materializecss.com</A>)
* Copyright 2014-2017 Materialize
* MIT License (<A rel="nofollow" class="external free" href="https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE">https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE</A>)
*/
</PRE><P>var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (&quot;value&quot; in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
</P><P>var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
</P><P>function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(&quot;this hasn't been initialised - super() hasn't been called&quot;); } return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self; }
</P><P>function _inherits(subClass, superClass) { if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) { throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
</P><P>function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }
</P><P>/*! cash-dom 1.3.5, <A rel="nofollow" class="external free" href="https://github.com/kenwheeler/cash">https://github.com/kenwheeler/cash</A> @license MIT */
(function (factory) {
</P><PRE> window.cash = factory();
</PRE><P>})(function () {
</P><PRE> var doc = document,
     win = window,
     ArrayProto = Array.prototype,
     slice = ArrayProto.slice,
     filter = ArrayProto.filter,
     push = ArrayProto.push;
</PRE><PRE> var noop = function () {},
     isFunction = function (item) {
   // @see <A rel="nofollow" class="external free" href="https://crbug.com/568448">https://crbug.com/568448</A>
   return typeof item === typeof noop &amp;&amp; item.call;
 },
     isString = function (item) {
   return typeof item === typeof &quot;&quot;;
 };
</PRE><PRE> var idMatch = /^#[\w-]*$/,
     classMatch = /^\.[\w-]*$/,
     htmlMatch = /&lt;.+&gt;/,
     singlet = /^\w+$/;
</PRE><PRE> function find(selector, context) {
   context = context || doc;
   var elems = classMatch.test(selector) ? context.getElementsByClassName(selector.slice(1)) : singlet.test(selector) ? context.getElementsByTagName(selector) : context.querySelectorAll(selector);
   return elems;
 }
</PRE><PRE> var frag;
 function parseHTML(str) {
   if (!frag) {
     frag = doc.implementation.createHTMLDocument(null);
     var base = frag.createElement(&quot;base&quot;);
     base.href = doc.location.href;
     frag.head.appendChild(base);
   }
</PRE><PRE>   frag.body.innerHTML = str;
</PRE><PRE>   return frag.body.childNodes;
 }
</PRE><PRE> function onReady(fn) {
   if (doc.readyState !== &quot;loading&quot;) {
     fn();
   } else {
     doc.addEventListener(&quot;DOMContentLoaded&quot;, fn);
   }
 }
</PRE><PRE> function Init(selector, context) {
   if (!selector) {
     return this;
   }
</PRE><PRE>   // If already a cash collection, don't do any further processing
   if (selector.cash &amp;&amp; selector !== win) {
     return selector;
   }
</PRE><PRE>   var elems = selector,
       i = 0,
       length;
</PRE><PRE>   if (isString(selector)) {
     elems = idMatch.test(selector) ?
     // If an ID use the faster getElementById check
     doc.getElementById(selector.slice(1)) : htmlMatch.test(selector) ?
     // If HTML, parse it into real elements
     parseHTML(selector) :
     // else use `find`
     find(selector, context);
</PRE><PRE>     // If function, use as shortcut for DOM ready
   } else if (isFunction(selector)) {
     onReady(selector);return this;
   }
</PRE><PRE>   if (!elems) {
     return this;
   }
</PRE><PRE>   // If a single DOM element is passed in or received via ID, return the single element
   if (elems.nodeType || elems === win) {
     this[0] = elems;
     this.length = 1;
   } else {
     // Treat like an array and loop through each item.
     length = this.length = elems.length;
     for (; i &lt; length; i++) {
       this[i] = elems[i];
     }
   }
</PRE><PRE>   return this;
 }
</PRE><PRE> function cash(selector, context) {
   return new Init(selector, context);
 }
</PRE><PRE> var fn = cash.fn = cash.prototype = Init.prototype = { // jshint ignore:line
   cash: true,
   length: 0,
   push: push,
   splice: ArrayProto.splice,
   map: ArrayProto.map,
   init: Init
 };
</PRE><PRE> Object.defineProperty(fn, &quot;constructor&quot;, { value: cash });
</PRE><PRE> cash.parseHTML = parseHTML;
 cash.noop = noop;
 cash.isFunction = isFunction;
 cash.isString = isString;
</PRE><PRE> cash.extend = fn.extend = function (target) {
   target = target || {};
</PRE><PRE>   var args = slice.call(arguments),
       length = args.length,
       i = 1;
</PRE><PRE>   if (args.length === 1) {
     target = this;
     i = 0;
   }
</PRE><PRE>   for (; i &lt; length; i++) {
     if (!args[i]) {
       continue;
     }
     for (var key in args[i]) {
       if (args[i].hasOwnProperty(key)) {
         target[key] = args[i][key];
       }
     }
   }
</PRE><PRE>   return target;
 };
</PRE><PRE> function each(collection, callback) {
   var l = collection.length,
       i = 0;
</PRE><PRE>   for (; i &lt; l; i++) {
     if (callback.call(collection[i], collection[i], i, collection) === false) {
       break;
     }
   }
 }
</PRE><PRE> function matches(el, selector) {
   var m = el &amp;&amp; (el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector || el.oMatchesSelector);
   return !!m &amp;&amp; m.call(el, selector);
 }
</PRE><PRE> function getCompareFunction(selector) {
   return (
     /* Use browser's `matches` function if string */
     isString(selector) ? matches :
     /* Match a cash element */
     selector.cash ? function (el) {
       return selector.is(el);
     } :
     /* Direct comparison */
     function (el, selector) {
       return el === selector;
     }
   );
 }
</PRE><PRE> function unique(collection) {
   return cash(slice.call(collection).filter(function (item, index, self) {
     return self.indexOf(item) === index;
   }));
 }
</PRE><PRE> cash.extend({
   merge: function (first, second) {
     var len = +second.length,
         i = first.length,
         j = 0;
</PRE><PRE>     for (; j &lt; len; i++, j++) {
       first[i] = second[j];
     }
</PRE><PRE>     first.length = i;
     return first;
   },
</PRE><PRE>   each: each,
   matches: matches,
   unique: unique,
   isArray: Array.isArray,
   isNumeric: function (n) {
     return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
   }
</PRE><PRE> });
</PRE><PRE> var uid = cash.uid = &quot;_cash&quot; + Date.now();
</PRE><PRE> function getDataCache(node) {
   return node[uid] = node[uid] || {};
 }
</PRE><PRE> function setData(node, key, value) {
   return getDataCache(node)[key] = value;
 }
</PRE><PRE> function getData(node, key) {
   var c = getDataCache(node);
   if (c[key] === undefined) {
     c[key] = node.dataset ? node.dataset[key] : cash(node).attr(&quot;data-&quot; + key);
   }
   return c[key];
 }
</PRE><PRE> function removeData(node, key) {
   var c = getDataCache(node);
   if (c) {
     delete c[key];
   } else if (node.dataset) {
     delete node.dataset[key];
   } else {
     cash(node).removeAttr(&quot;data-&quot; + name);
   }
 }
</PRE><PRE> fn.extend({
   data: function (name, value) {
     if (isString(name)) {
       return value === undefined ? getData(this[0], name) : this.each(function (v) {
         return setData(v, name, value);
       });
     }
</PRE><PRE>     for (var key in name) {
       this.data(key, name[key]);
     }
</PRE><PRE>     return this;
   },
</PRE><PRE>   removeData: function (key) {
     return this.each(function (v) {
       return removeData(v, key);
     });
   }
</PRE><PRE> });
</PRE><PRE> var notWhiteMatch = /\S+/g;
</PRE><PRE> function getClasses(c) {
   return isString(c) &amp;&amp; c.match(notWhiteMatch);
 }
</PRE><PRE> function hasClass(v, c) {
   return v.classList ? v.classList.contains(c) : new RegExp(&quot;(^| )&quot; + c + &quot;( |$)&quot;, &quot;gi&quot;).test(v.className);
 }
</PRE><PRE> function addClass(v, c, spacedName) {
   if (v.classList) {
     v.classList.add(c);
   } else if (spacedName.indexOf(&quot; &quot; + c + &quot; &quot;)) {
     v.className += &quot; &quot; + c;
   }
 }
</PRE><PRE> function removeClass(v, c) {
   if (v.classList) {
     v.classList.remove(c);
   } else {
     v.className = v.className.replace(c, &quot;&quot;);
   }
 }
</PRE><PRE> fn.extend({
   addClass: function (c) {
     var classes = getClasses(c);
</PRE><PRE>     return classes ? this.each(function (v) {
       var spacedName = &quot; &quot; + v.className + &quot; &quot;;
       each(classes, function (c) {
         addClass(v, c, spacedName);
       });
     }) : this;
   },
</PRE><PRE>   attr: function (name, value) {
     if (!name) {
       return undefined;
     }
</PRE><PRE>     if (isString(name)) {
       if (value === undefined) {
         return this[0] ? this[0].getAttribute ? this[0].getAttribute(name) : this[0][name] : undefined;
       }
</PRE><PRE>       return this.each(function (v) {
         if (v.setAttribute) {
           v.setAttribute(name, value);
         } else {
           v[name] = value;
         }
       });
     }
</PRE><PRE>     for (var key in name) {
       this.attr(key, name[key]);
     }
</PRE><PRE>     return this;
   },
</PRE><PRE>   hasClass: function (c) {
     var check = false,
         classes = getClasses(c);
     if (classes &amp;&amp; classes.length) {
       this.each(function (v) {
         check = hasClass(v, classes[0]);
         return !check;
       });
     }
     return check;
   },
</PRE><PRE>   prop: function (name, value) {
     if (isString(name)) {
       return value === undefined ? this[0][name] : this.each(function (v) {
         v[name] = value;
       });
     }
</PRE><PRE>     for (var key in name) {
       this.prop(key, name[key]);
     }
</PRE><PRE>     return this;
   },
</PRE><PRE>   removeAttr: function (name) {
     return this.each(function (v) {
       if (v.removeAttribute) {
         v.removeAttribute(name);
       } else {
         delete v[name];
       }
     });
   },
</PRE><PRE>   removeClass: function (c) {
     if (!arguments.length) {
       return this.attr(&quot;class&quot;, &quot;&quot;);
     }
     var classes = getClasses(c);
     return classes ? this.each(function (v) {
       each(classes, function (c) {
         removeClass(v, c);
       });
     }) : this;
   },
</PRE><PRE>   removeProp: function (name) {
     return this.each(function (v) {
       delete v[name];
     });
   },
</PRE><PRE>   toggleClass: function (c, state) {
     if (state !== undefined) {
       return this[state ? &quot;addClass&quot; : &quot;removeClass&quot;](c);
     }
     var classes = getClasses(c);
     return classes ? this.each(function (v) {
       var spacedName = &quot; &quot; + v.className + &quot; &quot;;
       each(classes, function (c) {
         if (hasClass(v, c)) {
           removeClass(v, c);
         } else {
           addClass(v, c, spacedName);
         }
       });
     }) : this;
   } });
</PRE><PRE> fn.extend({
   add: function (selector, context) {
     return unique(cash.merge(this, cash(selector, context)));
   },
</PRE><PRE>   each: function (callback) {
     each(this, callback);
     return this;
   },
</PRE><PRE>   eq: function (index) {
     return cash(this.get(index));
   },
</PRE><PRE>   filter: function (selector) {
     if (!selector) {
       return this;
     }
</PRE><PRE>     var comparator = isFunction(selector) ? selector : getCompareFunction(selector);
</PRE><PRE>     return cash(filter.call(this, function (e) {
       return comparator(e, selector);
     }));
   },
</PRE><PRE>   first: function () {
     return this.eq(0);
   },
</PRE><PRE>   get: function (index) {
     if (index === undefined) {
       return slice.call(this);
     }
     return index &lt; 0 ? this[index + this.length] : this[index];
   },
</PRE><PRE>   index: function (elem) {
     var child = elem ? cash(elem)[0] : this[0],
         collection = elem ? this : cash(child).parent().children();
     return slice.call(collection).indexOf(child);
   },
</PRE><PRE>   last: function () {
     return this.eq(-1);
   }
</PRE><PRE> });
</PRE><PRE> var camelCase = function () {
   var camelRegex = /(?:^\w|[A-Z]|\b\w)/g,
       whiteSpace = /[\s-_]+/g;
   return function (str) {
     return str.replace(camelRegex, function (letter, index) {
       return letter[index === 0 ? &quot;toLowerCase&quot; : &quot;toUpperCase&quot;]();
     }).replace(whiteSpace, &quot;&quot;);
   };
 }();
</PRE><PRE> var getPrefixedProp = function () {
   var cache = {},
       doc = document,
       div = doc.createElement(&quot;div&quot;),
       style = div.style;
</PRE><PRE>   return function (prop) {
     prop = camelCase(prop);
     if (cache[prop]) {
       return cache[prop];
     }
</PRE><PRE>     var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
         prefixes = [&quot;webkit&quot;, &quot;moz&quot;, &quot;ms&quot;, &quot;o&quot;],
         props = (prop + &quot; &quot; + prefixes.join(ucProp + &quot; &quot;) + ucProp).split(&quot; &quot;);
</PRE><PRE>     each(props, function (p) {
       if (p in style) {
         cache[p] = prop = cache[prop] = p;
         return false;
       }
     });
</PRE><PRE>     return cache[prop];
   };
 }();
</PRE><PRE> cash.prefixedProp = getPrefixedProp;
 cash.camelCase = camelCase;
</PRE><PRE> fn.extend({
   css: function (prop, value) {
     if (isString(prop)) {
       prop = getPrefixedProp(prop);
       return arguments.length &gt; 1 ? this.each(function (v) {
         return v.style[prop] = value;
       }) : win.getComputedStyle(this[0])[prop];
     }
</PRE><PRE>     for (var key in prop) {
       this.css(key, prop[key]);
     }
</PRE><PRE>     return this;
   }
</PRE><PRE> });
</PRE><PRE> function compute(el, prop) {
   return parseInt(win.getComputedStyle(el[0], null)[prop], 10) || 0;
 }
</PRE><PRE> each([&quot;Width&quot;, &quot;Height&quot;], function (v) {
   var lower = v.toLowerCase();
</PRE><PRE>   fn[lower] = function () {
     return this[0].getBoundingClientRect()[lower];
   };
</PRE><PRE>   fn[&quot;inner&quot; + v] = function () {
     return this[0][&quot;client&quot; + v];
   };
</PRE><PRE>   fn[&quot;outer&quot; + v] = function (margins) {
     return this[0][&quot;offset&quot; + v] + (margins ? compute(this, &quot;margin&quot; + (v === &quot;Width&quot; ? &quot;Left&quot; : &quot;Top&quot;)) + compute(this, &quot;margin&quot; + (v === &quot;Width&quot; ? &quot;Right&quot; : &quot;Bottom&quot;)) : 0);
   };
 });
</PRE><PRE> function registerEvent(node, eventName, callback) {
   var eventCache = getData(node, &quot;_cashEvents&quot;) || setData(node, &quot;_cashEvents&quot;, {});
   eventCache[eventName] = eventCache[eventName] || [];
   eventCache[eventName].push(callback);
   node.addEventListener(eventName, callback);
 }
</PRE><PRE> function removeEvent(node, eventName, callback) {
   var events = getData(node, &quot;_cashEvents&quot;),
       eventCache = events &amp;&amp; events[eventName],
       index;
</PRE><PRE>   if (!eventCache) {
     return;
   }
</PRE><PRE>   if (callback) {
     node.removeEventListener(eventName, callback);
     index = eventCache.indexOf(callback);
     if (index &gt;= 0) {
       eventCache.splice(index, 1);
     }
   } else {
     each(eventCache, function (event) {
       node.removeEventListener(eventName, event);
     });
     eventCache = [];
   }
 }
</PRE><PRE> fn.extend({
   off: function (eventName, callback) {
     return this.each(function (v) {
       return removeEvent(v, eventName, callback);
     });
   },
</PRE><PRE>   on: function (eventName, delegate, callback, runOnce) {
     // jshint ignore:line
     var originalCallback;
     if (!isString(eventName)) {
       for (var key in eventName) {
         this.on(key, delegate, eventName[key]);
       }
       return this;
     }
</PRE><PRE>     if (isFunction(delegate)) {
       callback = delegate;
       delegate = null;
     }
</PRE><PRE>     if (eventName === &quot;ready&quot;) {
       onReady(callback);
       return this;
     }
</PRE><PRE>     if (delegate) {
       originalCallback = callback;
       callback = function (e) {
         var t = e.target;
         while (!matches(t, delegate)) {
           if (t === this || t === null) {
             return t = false;
           }
</PRE><PRE>           t = t.parentNode;
         }
</PRE><PRE>         if (t) {
           originalCallback.call(t, e);
         }
       };
     }
</PRE><PRE>     return this.each(function (v) {
       var finalCallback = callback;
       if (runOnce) {
         finalCallback = function () {
           callback.apply(this, arguments);
           removeEvent(v, eventName, finalCallback);
         };
       }
       registerEvent(v, eventName, finalCallback);
     });
   },
</PRE><PRE>   one: function (eventName, delegate, callback) {
     return this.on(eventName, delegate, callback, true);
   },
</PRE><PRE>   ready: onReady,
</PRE><PRE>   /**
    * Modified
    * Triggers browser event
    * @param String eventName
    * @param Object data - Add properties to event object
    */
   trigger: function (eventName, data) {
     if (document.createEvent) {
       var evt = document.createEvent('HTMLEvents');
       evt.initEvent(eventName, true, false);
       evt = this.extend(evt, data);
       return this.each(function (v) {
         return v.dispatchEvent(evt);
       });
     }
   }
</PRE><PRE> });
</PRE><PRE> function encode(name, value) {
   return &quot;&amp;&quot; + encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value).replace(/%20/g, &quot;+&quot;);
 }
</PRE><PRE> function getSelectMultiple_(el) {
   var values = [];
   each(el.options, function (o) {
     if (o.selected) {
       values.push(o.value);
     }
   });
   return values.length ? values : null;
 }
</PRE><PRE> function getSelectSingle_(el) {
   var selectedIndex = el.selectedIndex;
   return selectedIndex &gt;= 0 ? el.options[selectedIndex].value : null;
 }
</PRE><PRE> function getValue(el) {
   var type = el.type;
   if (!type) {
     return null;
   }
   switch (type.toLowerCase()) {
     case &quot;select-one&quot;:
       return getSelectSingle_(el);
     case &quot;select-multiple&quot;:
       return getSelectMultiple_(el);
     case &quot;radio&quot;:
       return el.checked ? el.value : null;
     case &quot;checkbox&quot;:
       return el.checked ? el.value : null;
     default:
       return el.value ? el.value : null;
   }
 }
</PRE><PRE> fn.extend({
   serialize: function () {
     var query = &quot;&quot;;
</PRE><PRE>     each(this[0].elements || this, function (el) {
       if (el.disabled || el.tagName === &quot;FIELDSET&quot;) {
         return;
       }
       var name = el.name;
       switch (el.type.toLowerCase()) {
         case &quot;file&quot;:
         case &quot;reset&quot;:
         case &quot;submit&quot;:
         case &quot;button&quot;:
           break;
         case &quot;select-multiple&quot;:
           var values = getValue(el);
           if (values !== null) {
             each(values, function (value) {
               query += encode(name, value);
             });
           }
           break;
         default:
           var value = getValue(el);
           if (value !== null) {
             query += encode(name, value);
           }
       }
     });
</PRE><PRE>     return query.substr(1);
   },
</PRE><PRE>   val: function (value) {
     if (value === undefined) {
       return getValue(this[0]);
     }
</PRE><PRE>     return this.each(function (v) {
       return v.value = value;
     });
   }
</PRE><PRE> });
</PRE><PRE> function insertElement(el, child, prepend) {
   if (prepend) {
     var first = el.childNodes[0];
     el.insertBefore(child, first);
   } else {
     el.appendChild(child);
   }
 }
</PRE><PRE> function insertContent(parent, child, prepend) {
   var str = isString(child);
</PRE><PRE>   if (!str &amp;&amp; child.length) {
     each(child, function (v) {
       return insertContent(parent, v, prepend);
     });
     return;
   }
</PRE><PRE>   each(parent, str ? function (v) {
     return v.insertAdjacentHTML(prepend ? &quot;afterbegin&quot; : &quot;beforeend&quot;, child);
   } : function (v, i) {
     return insertElement(v, i === 0 ? child : child.cloneNode(true), prepend);
   });
 }
</PRE><PRE> fn.extend({
   after: function (selector) {
     cash(selector).insertAfter(this);
     return this;
   },
</PRE><PRE>   append: function (content) {
     insertContent(this, content);
     return this;
   },
</PRE><PRE>   appendTo: function (parent) {
     insertContent(cash(parent), this);
     return this;
   },
</PRE><PRE>   before: function (selector) {
     cash(selector).insertBefore(this);
     return this;
   },
</PRE><PRE>   clone: function () {
     return cash(this.map(function (v) {
       return v.cloneNode(true);
     }));
   },
</PRE><PRE>   empty: function () {
     this.html(&quot;&quot;);
     return this;
   },
</PRE><PRE>   html: function (content) {
     if (content === undefined) {
       return this[0].innerHTML;
     }
     var source = content.nodeType ? content[0].outerHTML : content;
     return this.each(function (v) {
       return v.innerHTML = source;
     });
   },
</PRE><PRE>   insertAfter: function (selector) {
     var _this = this;
</PRE><PRE>     cash(selector).each(function (el, i) {
       var parent = el.parentNode,
           sibling = el.nextSibling;
       _this.each(function (v) {
         parent.insertBefore(i === 0 ? v : v.cloneNode(true), sibling);
       });
     });
</PRE><PRE>     return this;
   },
</PRE><PRE>   insertBefore: function (selector) {
     var _this2 = this;
     cash(selector).each(function (el, i) {
       var parent = el.parentNode;
       _this2.each(function (v) {
         parent.insertBefore(i === 0 ? v : v.cloneNode(true), el);
       });
     });
     return this;
   },
</PRE><PRE>   prepend: function (content) {
     insertContent(this, content, true);
     return this;
   },
</PRE><PRE>   prependTo: function (parent) {
     insertContent(cash(parent), this, true);
     return this;
   },
</PRE><PRE>   remove: function () {
     return this.each(function (v) {
       if (!!v.parentNode) {
         return v.parentNode.removeChild(v);
       }
     });
   },
</PRE><PRE>   text: function (content) {
     if (content === undefined) {
       return this[0].textContent;
     }
     return this.each(function (v) {
       return v.textContent = content;
     });
   }
</PRE><PRE> });
</PRE><PRE> var docEl = doc.documentElement;
</PRE><PRE> fn.extend({
   position: function () {
     var el = this[0];
     return {
       left: el.offsetLeft,
       top: el.offsetTop
     };
   },
</PRE><PRE>   offset: function () {
     var rect = this[0].getBoundingClientRect();
     return {
       top: rect.top + win.pageYOffset - docEl.clientTop,
       left: rect.left + win.pageXOffset - docEl.clientLeft
     };
   },
</PRE><PRE>   offsetParent: function () {
     return cash(this[0].offsetParent);
   }
</PRE><PRE> });
</PRE><PRE> fn.extend({
   children: function (selector) {
     var elems = [];
     this.each(function (el) {
       push.apply(elems, el.children);
     });
     elems = unique(elems);
</PRE><PRE>     return !selector ? elems : elems.filter(function (v) {
       return matches(v, selector);
     });
   },
</PRE><PRE>   closest: function (selector) {
     if (!selector || this.length &lt; 1) {
       return cash();
     }
     if (this.is(selector)) {
       return this.filter(selector);
     }
     return this.parent().closest(selector);
   },
</PRE><PRE>   is: function (selector) {
     if (!selector) {
       return false;
     }
</PRE><PRE>     var match = false,
         comparator = getCompareFunction(selector);
</PRE><PRE>     this.each(function (el) {
       match = comparator(el, selector);
       return !match;
     });
</PRE><PRE>     return match;
   },
</PRE><PRE>   find: function (selector) {
     if (!selector || selector.nodeType) {
       return cash(selector &amp;&amp; this.has(selector).length ? selector : null);
     }
</PRE><PRE>     var elems = [];
     this.each(function (el) {
       push.apply(elems, find(selector, el));
     });
</PRE><PRE>     return unique(elems);
   },
</PRE><PRE>   has: function (selector) {
     var comparator = isString(selector) ? function (el) {
       return find(selector, el).length !== 0;
     } : function (el) {
       return el.contains(selector);
     };
</PRE><PRE>     return this.filter(comparator);
   },
</PRE><PRE>   next: function () {
     return cash(this[0].nextElementSibling);
   },
</PRE><PRE>   not: function (selector) {
     if (!selector) {
       return this;
     }
</PRE><PRE>     var comparator = getCompareFunction(selector);
</PRE><PRE>     return this.filter(function (el) {
       return !comparator(el, selector);
     });
   },
</PRE><PRE>   parent: function () {
     var result = [];
</PRE><PRE>     this.each(function (item) {
       if (item &amp;&amp; item.parentNode) {
         result.push(item.parentNode);
       }
     });
</PRE><PRE>     return unique(result);
   },
</PRE><PRE>   parents: function (selector) {
     var last,
         result = [];
</PRE><PRE>     this.each(function (item) {
       last = item;
</PRE><PRE>       while (last &amp;&amp; last.parentNode &amp;&amp; last !== doc.body.parentNode) {
         last = last.parentNode;
</PRE><PRE>         if (!selector || selector &amp;&amp; matches(last, selector)) {
           result.push(last);
         }
       }
     });
</PRE><PRE>     return unique(result);
   },
</PRE><PRE>   prev: function () {
     return cash(this[0].previousElementSibling);
   },
</PRE><PRE>   siblings: function (selector) {
     var collection = this.parent().children(selector),
         el = this[0];
</PRE><PRE>     return collection.filter(function (i) {
       return i !== el;
     });
   }
</PRE><PRE> });
</PRE><PRE> return cash;
</PRE><P>});
</P><P>var Component = function () {
</P><PRE> /**
  * Generic constructor for all components
  * @constructor
  * @param {Element} el
  * @param {Object} options
  */
 function Component(classDef, el, options) {
   _classCallCheck(this, Component);
</PRE><PRE>   // Display error if el is valid HTML Element
   if (!(el instanceof Element)) {
     console.error(Error(el + ' is not an HTML Element'));
   }
</PRE><PRE>   // If exists, destroy and reinitialize in child
   var ins = classDef.getInstance(el);
   if (!!ins) {
     ins.destroy();
   }
</PRE><PRE>   this.el = el;
   this.$el = cash(el);
 }
</PRE><PRE> /**
  * Initializes components
  * @param {class} classDef
  * @param {Element | NodeList | jQuery} els
  * @param {Object} options
  */
</PRE><PRE> _createClass(Component, null, [{
   key: &quot;init&quot;,
   value: function init(classDef, els, options) {
     var instances = null;
     if (els instanceof Element) {
       instances = new classDef(els, options);
     } else if (!!els &amp;&amp; (els.jquery || els.cash || els instanceof NodeList)) {
       var instancesArr = [];
       for (var i = 0; i &lt; els.length; i++) {
         instancesArr.push(new classDef(els[i], options));
       }
       instances = instancesArr;
     }
</PRE><PRE>     return instances;
   }
 }]);
</PRE><PRE> return Component;
</PRE><P>}();
</P><DL><DT> // Required for Meteor package, the use of window prevents export by Meteor</DT></DL><P>(function (window) {
</P><PRE> if (window.Package) {
   M = {};
 } else {
   window.M = {};
 }
</PRE><PRE> // Check for jQuery
 M.jQueryLoaded = !!window.jQuery;
</PRE><P>})(window);
</P><P>// AMD
if (typeof define === 'function' &amp;&amp; define.amd) {
</P><PRE> define('M', [], function () {
   return M;
 });
</PRE><PRE> // Common JS
</PRE><P>} else if (typeof exports !== 'undefined' &amp;&amp; !exports.nodeType) {
</P><PRE> if (typeof module !== 'undefined' &amp;&amp; !module.nodeType &amp;&amp; module.exports) {
   exports = module.exports = M;
 }
 exports.default = M;
</PRE><P>}
</P><P>M.version = '1.0.0';
</P><P>M.keys = {
</P><PRE> TAB: 9,
 ENTER: 13,
 ESC: 27,
 ARROW_UP: 38,
 ARROW_DOWN: 40
</PRE><P>};
</P><P>/**
</P><PRE>* TabPress Keydown handler
*/
</PRE><P>M.tabPressed = false;
M.keyDown = false;
var docHandleKeydown = function (e) {
</P><PRE> M.keyDown = true;
 if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) {
   M.tabPressed = true;
 }
</PRE><P>};
var docHandleKeyup = function (e) {
</P><PRE> M.keyDown = false;
 if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) {
   M.tabPressed = false;
 }
</PRE><P>};
var docHandleFocus = function (e) {
</P><PRE> if (M.keyDown) {
   document.body.classList.add('keyboard-focused');
 }
</PRE><P>};
var docHandleBlur = function (e) {
</P><PRE> document.body.classList.remove('keyboard-focused');
</PRE><P>};
document.addEventListener('keydown', docHandleKeydown, true);
document.addEventListener('keyup', docHandleKeyup, true);
document.addEventListener('focus', docHandleFocus, true);
document.addEventListener('blur', docHandleBlur, true);
</P><P>/**
</P><PRE>* Initialize jQuery wrapper for plugin
* @param {Class} plugin  javascript class
* @param {string} pluginName  jQuery plugin name
* @param {string} classRef  Class reference name
*/
</PRE><P>M.initializeJqueryWrapper = function (plugin, pluginName, classRef) {
</P><PRE> jQuery.fn[pluginName] = function (methodOrOptions) {
   // Call plugin method if valid method name is passed in
   if (plugin.prototype[methodOrOptions]) {
     var params = Array.prototype.slice.call(arguments, 1);
</PRE><PRE>     // Getter methods
     if (methodOrOptions.slice(0, 3) === 'get') {
       var instance = this.first()[0][classRef];
       return instance[methodOrOptions].apply(instance, params);
     }
</PRE><PRE>     // Void methods
     return this.each(function () {
       var instance = this[classRef];
       instance[methodOrOptions].apply(instance, params);
     });
</PRE><PRE>     // Initialize plugin if options or no argument is passed in
   } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {
     plugin.init(this, arguments[0]);
     return this;
   }
</PRE><PRE>   // Return error if an unrecognized  method name is passed in
   jQuery.error(&quot;Method &quot; + methodOrOptions + &quot; does not exist on jQuery.&quot; + pluginName);
 };
</PRE><P>};
</P><P>/**
</P><PRE>* Automatically initialize components
* @param {Element} context  DOM Element to search within for components
*/
</PRE><P>M.AutoInit = function (context) {
</P><PRE> // Use document.body if no context is given
 var root = !!context ? context : document.body;
</PRE><PRE> var registry = {
   Autocomplete: root.querySelectorAll('.autocomplete:not(.no-autoinit)'),
   Carousel: root.querySelectorAll('.carousel:not(.no-autoinit)'),
   Chips: root.querySelectorAll('.chips:not(.no-autoinit)'),
   Collapsible: root.querySelectorAll('.collapsible:not(.no-autoinit)'),
   Datepicker: root.querySelectorAll('.datepicker:not(.no-autoinit)'),
   Dropdown: root.querySelectorAll('.dropdown-trigger:not(.no-autoinit)'),
   Materialbox: root.querySelectorAll('.materialboxed:not(.no-autoinit)'),
   Modal: root.querySelectorAll('.modal:not(.no-autoinit)'),
   Parallax: root.querySelectorAll('.parallax:not(.no-autoinit)'),
   Pushpin: root.querySelectorAll('.pushpin:not(.no-autoinit)'),
   ScrollSpy: root.querySelectorAll('.scrollspy:not(.no-autoinit)'),
   FormSelect: root.querySelectorAll('select:not(.no-autoinit)'),
   Sidenav: root.querySelectorAll('.sidenav:not(.no-autoinit)'),
   Tabs: root.querySelectorAll('.tabs:not(.no-autoinit)'),
   TapTarget: root.querySelectorAll('.tap-target:not(.no-autoinit)'),
   Timepicker: root.querySelectorAll('.timepicker:not(.no-autoinit)'),
   Tooltip: root.querySelectorAll('.tooltipped:not(.no-autoinit)'),
   FloatingActionButton: root.querySelectorAll('.fixed-action-btn:not(.no-autoinit)')
 };
</PRE><PRE> for (var pluginName in registry) {
   var plugin = M[pluginName];
   plugin.init(registry[pluginName]);
 }
</PRE><P>};
</P><P>/**
</P><PRE>* Generate approximated selector string for a jQuery object
* @param {jQuery} obj  jQuery object to be parsed
* @returns {string}
*/
</PRE><P>M.objectSelectorString = function (obj) {
</P><PRE> var tagStr = obj.prop('tagName') || <I>;</I>
 var idStr = obj.attr('id') || <I>;</I>
 var classStr = obj.attr('class') || <I>;</I>
 return (tagStr + idStr + classStr).replace(/\s/g, <I>);</I></PRE><P>};
</P><P>// Unique Random ID
M.guid = function () {
</P><PRE> function s4() {
   return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
 }
 return function () {
   return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
 };
</PRE><P>}();
</P><P>/**
</P><PRE>* Escapes hash from special characters
* @param {string} hash  String returned from this.hash
* @returns {string}
*/
</PRE><P>M.escapeHash = function (hash) {
</P><PRE> return hash.replace(/(:|\.|\[|\]|,|=|\/)/g, '\\$1');
</PRE><P>};
</P><P>M.elementOrParentIsFixed = function (element) {
</P><PRE> var $element = $(element);
 var $checkElements = $element.add($element.parents());
 var isFixed = false;
 $checkElements.each(function () {
   if ($(this).css('position') === 'fixed') {
     isFixed = true;
     return false;
   }
 });
 return isFixed;
</PRE><P>};
</P><P>/**
</P><PRE>* @typedef {Object} Edges
* @property {Boolean} top  If the top edge was exceeded
* @property {Boolean} right  If the right edge was exceeded
* @property {Boolean} bottom  If the bottom edge was exceeded
* @property {Boolean} left  If the left edge was exceeded
*/
</PRE><P>/**
</P><PRE>* @typedef {Object} Bounding
* @property {Number} left  left offset coordinate
* @property {Number} top  top offset coordinate
* @property {Number} width
* @property {Number} height
*/
</PRE><P>/**
</P><PRE>* Escapes hash from special characters
* @param {Element} container  Container element that acts as the boundary
* @param {Bounding} bounding  element bounding that is being checked
* @param {Number} offset  offset from edge that counts as exceeding
* @returns {Edges}
*/
</PRE><P>M.checkWithinContainer = function (container, bounding, offset) {
</P><PRE> var edges = {
   top: false,
   right: false,
   bottom: false,
   left: false
 };
</PRE><PRE> var containerRect = container.getBoundingClientRect();
 // If body element is smaller than viewport, use viewport height instead.
 var containerBottom = container === document.body ? Math.max(containerRect.bottom, window.innerHeight) : containerRect.bottom;
</PRE><PRE> var scrollLeft = container.scrollLeft;
 var scrollTop = container.scrollTop;
</PRE><PRE> var scrolledX = bounding.left - scrollLeft;
 var scrolledY = bounding.top - scrollTop;
</PRE><PRE> // Check for container and viewport for each edge
 if (scrolledX &lt; containerRect.left + offset || scrolledX &lt; offset) {
   edges.left = true;
 }
</PRE><PRE> if (scrolledX + bounding.width &gt; containerRect.right - offset || scrolledX + bounding.width &gt; window.innerWidth - offset) {
   edges.right = true;
 }
</PRE><PRE> if (scrolledY &lt; containerRect.top + offset || scrolledY &lt; offset) {
   edges.top = true;
 }
</PRE><PRE> if (scrolledY + bounding.height &gt; containerBottom - offset || scrolledY + bounding.height &gt; window.innerHeight - offset) {
   edges.bottom = true;
 }
</PRE><PRE> return edges;
</PRE><P>};
</P><P>M.checkPossibleAlignments = function (el, container, bounding, offset) {
</P><PRE> var canAlign = {
   top: true,
   right: true,
   bottom: true,
   left: true,
   spaceOnTop: null,
   spaceOnRight: null,
   spaceOnBottom: null,
   spaceOnLeft: null
 };
</PRE><PRE> var containerAllowsOverflow = getComputedStyle(container).overflow === 'visible';
 var containerRect = container.getBoundingClientRect();
 var containerHeight = Math.min(containerRect.height, window.innerHeight);
 var containerWidth = Math.min(containerRect.width, window.innerWidth);
 var elOffsetRect = el.getBoundingClientRect();
</PRE><PRE> var scrollLeft = container.scrollLeft;
 var scrollTop = container.scrollTop;
</PRE><PRE> var scrolledX = bounding.left - scrollLeft;
 var scrolledYTopEdge = bounding.top - scrollTop;
 var scrolledYBottomEdge = bounding.top + elOffsetRect.height - scrollTop;
</PRE><PRE> // Check for container and viewport for left
 canAlign.spaceOnRight = !containerAllowsOverflow ? containerWidth - (scrolledX + bounding.width) : window.innerWidth - (elOffsetRect.left + bounding.width);
 if (canAlign.spaceOnRight &lt; 0) {
   canAlign.left = false;
 }
</PRE><PRE> // Check for container and viewport for Right
 canAlign.spaceOnLeft = !containerAllowsOverflow ? scrolledX - bounding.width + elOffsetRect.width : elOffsetRect.right - bounding.width;
 if (canAlign.spaceOnLeft &lt; 0) {
   canAlign.right = false;
 }
</PRE><PRE> // Check for container and viewport for Top
 canAlign.spaceOnBottom = !containerAllowsOverflow ? containerHeight - (scrolledYTopEdge + bounding.height + offset) : window.innerHeight - (elOffsetRect.top + bounding.height + offset);
 if (canAlign.spaceOnBottom &lt; 0) {
   canAlign.top = false;
 }
</PRE><PRE> // Check for container and viewport for Bottom
 canAlign.spaceOnTop = !containerAllowsOverflow ? scrolledYBottomEdge - (bounding.height - offset) : elOffsetRect.bottom - (bounding.height + offset);
 if (canAlign.spaceOnTop &lt; 0) {
   canAlign.bottom = false;
 }
</PRE><PRE> return canAlign;
</PRE><P>};
</P><P>M.getOverflowParent = function (element) {
</P><PRE> if (element == null) {
   return null;
 }
</PRE><PRE> if (element === document.body || getComputedStyle(element).overflow !== 'visible') {
   return element;
 }
</PRE><PRE> return M.getOverflowParent(element.parentElement);
</PRE><P>};
</P><P>/**
</P><PRE>* Gets id of component from a trigger
* @param {Element} trigger  trigger
* @returns {string}
*/
</PRE><P>M.getIdFromTrigger = function (trigger) {
</P><PRE> var id = trigger.getAttribute('data-target');
 if (!id) {
   id = trigger.getAttribute('href');
   if (id) {
     id = id.slice(1);
   } else {
     id = <I>;</I>
   }
 }
 return id;
</PRE><P>};
</P><P>/**
</P><PRE>* Multi browser support for document scroll top
* @returns {Number}
*/
</PRE><P>M.getDocumentScrollTop = function () {
</P><PRE> return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
</PRE><P>};
</P><P>/**
</P><PRE>* Multi browser support for document scroll left
* @returns {Number}
*/
</PRE><P>M.getDocumentScrollLeft = function () {
</P><PRE> return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
</PRE><P>};
</P><P>/**
</P><PRE>* @typedef {Object} Edges
* @property {Boolean} top  If the top edge was exceeded
* @property {Boolean} right  If the right edge was exceeded
* @property {Boolean} bottom  If the bottom edge was exceeded
* @property {Boolean} left  If the left edge was exceeded
*/
</PRE><P>/**
</P><PRE>* @typedef {Object} Bounding
* @property {Number} left  left offset coordinate
* @property {Number} top  top offset coordinate
* @property {Number} width
* @property {Number} height
*/
</PRE><P>/**
</P><PRE>* Get time in ms
* @license <A rel="nofollow" class="external free" href="https://raw.github.com/jashkenas/underscore/master/LICENSE">https://raw.github.com/jashkenas/underscore/master/LICENSE</A>
* @type {function}
* @return {number}
*/
</PRE><P>var getTime = Date.now || function () {
</P><PRE> return new Date().getTime();
</PRE><P>};
</P><P>/**
</P><PRE>* Returns a function, that, when invoked, will only be triggered at most once
* during a given window of time. Normally, the throttled function will run
* as much as it can, without ever going more than once per `wait` duration;
* but if you'd like to disable the execution on the leading edge, pass
* `{leading: false}`. To disable execution on the trailing edge, ditto.
* @license <A rel="nofollow" class="external free" href="https://raw.github.com/jashkenas/underscore/master/LICENSE">https://raw.github.com/jashkenas/underscore/master/LICENSE</A>
* @param {function} func
* @param {number} wait
* @param {Object=} options
* @returns {Function}
*/
</PRE><P>M.throttle = function (func, wait, options) {
</P><PRE> var context = void 0,
     args = void 0,
     result = void 0;
 var timeout = null;
 var previous = 0;
 options || (options = {});
 var later = function () {
   previous = options.leading === false ? 0 : getTime();
   timeout = null;
   result = func.apply(context, args);
   context = args = null;
 };
 return function () {
   var now = getTime();
   if (!previous &amp;&amp; options.leading === false) previous = now;
   var remaining = wait - (now - previous);
   context = this;
   args = arguments;
   if (remaining &lt;= 0) {
     clearTimeout(timeout);
     timeout = null;
     previous = now;
     result = func.apply(context, args);
     context = args = null;
   } else if (!timeout &amp;&amp; options.trailing !== false) {
     timeout = setTimeout(later, remaining);
   }
   return result;
 };
</PRE><P>};
</P><DL><DT> /*</DT></DL><PRE> v2.2.0
 2017 Julian Garnier
 Released under the MIT license
 */
</PRE><P>var $jscomp = { scope: {} };$jscomp.defineProperty = &quot;function&quot; == typeof Object.defineProperties ? Object.defineProperty : function (e, r, p) {
</P><PRE> if (p.get || p.set) throw new TypeError(&quot;ES3 does not support getters and setters.&quot;);e != Array.prototype &amp;&amp; e != Object.prototype &amp;&amp; (e[r] = p.value);
</PRE><P>};$jscomp.getGlobal = function (e) {
</P><PRE> return &quot;undefined&quot; != typeof window &amp;&amp; window === e ? e : &quot;undefined&quot; != typeof global &amp;&amp; null != global ? global : e;
</PRE><P>};$jscomp.global = $jscomp.getGlobal(this);$jscomp.SYMBOL_PREFIX = &quot;jscomp_symbol_&quot;;
$jscomp.initSymbol = function () {
</P><PRE> $jscomp.initSymbol = function () {};$jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
</PRE><P>};$jscomp.symbolCounter_ = 0;$jscomp.Symbol = function (e) {
</P><PRE> return $jscomp.SYMBOL_PREFIX + (e || &quot;&quot;) + $jscomp.symbolCounter_++;
</PRE><P>};
$jscomp.initSymbolIterator = function () {
</P><PRE> $jscomp.initSymbol();var e = $jscomp.global.Symbol.iterator;e || (e = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol(&quot;iterator&quot;));&quot;function&quot; != typeof Array.prototype[e] &amp;&amp; $jscomp.defineProperty(Array.prototype, e, { configurable: !0, writable: !0, value: function () {
     return $jscomp.arrayIterator(this);
   } });$jscomp.initSymbolIterator = function () {};
</PRE><P>};$jscomp.arrayIterator = function (e) {
</P><PRE> var r = 0;return $jscomp.iteratorPrototype(function () {
   return r &lt; e.length ? { done: !1, value: e[r++] } : { done: !0 };
 });
</PRE><P>};
$jscomp.iteratorPrototype = function (e) {
</P><PRE> $jscomp.initSymbolIterator();e = { next: e };e[$jscomp.global.Symbol.iterator] = function () {
   return this;
 };return e;
</PRE><P>};$jscomp.array = $jscomp.array || {};$jscomp.iteratorFromArray = function (e, r) {
</P><PRE> $jscomp.initSymbolIterator();e instanceof String &amp;&amp; (e += &quot;&quot;);var p = 0,
     m = { next: function () {
     if (p &lt; e.length) {
       var u = p++;return { value: r(u, e[u]), done: !1 };
     }m.next = function () {
       return { done: !0, value: void 0 };
     };return m.next();
   } };m[Symbol.iterator] = function () {
   return m;
 };return m;
</PRE><P>};
$jscomp.polyfill = function (e, r, p, m) {
</P><PRE> if (r) {
   p = $jscomp.global;e = e.split(&quot;.&quot;);for (m = 0; m &lt; e.length - 1; m++) {
     var u = e[m];u in p || (p[u] = {});p = p[u];
   }e = e[e.length - 1];m = p[e];r = r(m);r != m &amp;&amp; null != r &amp;&amp; $jscomp.defineProperty(p, e, { configurable: !0, writable: !0, value: r });
 }
</PRE><P>};$jscomp.polyfill(&quot;Array.prototype.keys&quot;, function (e) {
</P><PRE> return e ? e : function () {
   return $jscomp.iteratorFromArray(this, function (e) {
     return e;
   });
 };
</PRE><P>}, &quot;es6-impl&quot;, &quot;es3&quot;);var $jscomp$this = this;
(function (r) {
</P><PRE> M.anime = r();
</PRE><P>})(function () {
</P><PRE> function e(a) {
   if (!h.col(a)) try {
     return document.querySelectorAll(a);
   } catch (c) {}
 }function r(a, c) {
   for (var d = a.length, b = 2 &lt;= arguments.length ? arguments[1] : void 0, f = [], n = 0; n &lt; d; n++) {
     if (n in a) {
       var k = a[n];c.call(b, k, n, a) &amp;&amp; f.push(k);
     }
   }return f;
 }function p(a) {
   return a.reduce(function (a, d) {
     return a.concat(h.arr(d) ? p(d) : d);
   }, []);
 }function m(a) {
   if (h.arr(a)) return a;
   h.str(a) &amp;&amp; (a = e(a) || a);return a instanceof NodeList || a instanceof HTMLCollection ? [].slice.call(a) : [a];
 }function u(a, c) {
   return a.some(function (a) {
     return a === c;
   });
 }function C(a) {
   var c = {},
       d;for (d in a) {
     c[d] = a[d];
   }return c;
 }function D(a, c) {
   var d = C(a),
       b;for (b in a) {
     d[b] = c.hasOwnProperty(b) ? c[b] : a[b];
   }return d;
 }function z(a, c) {
   var d = C(a),
       b;for (b in c) {
     d[b] = h.und(a[b]) ? c[b] : a[b];
   }return d;
 }function T(a) {
   a = a.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (a, c, d, k) {
     return c + c + d + d + k + k;
   });var c = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
   a = parseInt(c[1], 16);var d = parseInt(c[2], 16),
       c = parseInt(c[3], 16);return &quot;rgba(&quot; + a + &quot;,&quot; + d + &quot;,&quot; + c + &quot;,1)&quot;;
 }function U(a) {
   function c(a, c, b) {
     0 &gt; b &amp;&amp; (b += 1);1 &lt; b &amp;&amp; --b;return b &lt; 1 / 6 ? a + 6 * (c - a) * b : .5 &gt; b ? c : b &lt; 2 / 3 ? a + (c - a) * (2 / 3 - b) * 6 : a;
   }var d = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(a) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(a);a = parseInt(d[1]) / 360;var b = parseInt(d[2]) / 100,
       f = parseInt(d[3]) / 100,
       d = d[4] || 1;if (0 == b) f = b = a = f;else {
     var n = .5 &gt; f ? f * (1 + b) : f + b - f * b,
         k = 2 * f - n,
         f = c(k, n, a + 1 / 3),
         b = c(k, n, a);a = c(k, n, a - 1 / 3);
   }return &quot;rgba(&quot; + 255 * f + &quot;,&quot; + 255 * b + &quot;,&quot; + 255 * a + &quot;,&quot; + d + &quot;)&quot;;
 }function y(a) {
   if (a = /([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(a)) return a[2];
 }function V(a) {
   if (-1 &lt; a.indexOf(&quot;translate&quot;) || &quot;perspective&quot; === a) return &quot;px&quot;;if (-1 &lt; a.indexOf(&quot;rotate&quot;) || -1 &lt; a.indexOf(&quot;skew&quot;)) return &quot;deg&quot;;
 }function I(a, c) {
   return h.fnc(a) ? a(c.target, c.id, c.total) : a;
 }function E(a, c) {
   if (c in a.style) return getComputedStyle(a).getPropertyValue(c.replace(/([a-z])([A-Z])/g, &quot;$1-$2&quot;).toLowerCase()) || &quot;0&quot;;
 }function J(a, c) {
   if (h.dom(a) &amp;&amp; u(W, c)) return &quot;transform&quot;;if (h.dom(a) &amp;&amp; (a.getAttribute(c) || h.svg(a) &amp;&amp; a[c])) return &quot;attribute&quot;;if (h.dom(a) &amp;&amp; &quot;transform&quot; !== c &amp;&amp; E(a, c)) return &quot;css&quot;;if (null != a[c]) return &quot;object&quot;;
 }function X(a, c) {
   var d = V(c),
       d = -1 &lt; c.indexOf(&quot;scale&quot;) ? 1 : 0 + d;a = a.style.transform;if (!a) return d;for (var b = [], f = [], n = [], k = /(\w+)\((.+?)\)/g; b = k.exec(a);) {
     f.push(b[1]), n.push(b[2]);
   }a = r(n, function (a, b) {
     return f[b] === c;
   });return a.length ? a[0] : d;
 }function K(a, c) {
   switch (J(a, c)) {case &quot;transform&quot;:
       return X(a, c);case &quot;css&quot;:
       return E(a, c);case &quot;attribute&quot;:
       return a.getAttribute(c);}return a[c] || 0;
 }function L(a, c) {
   var d = /^(\*=|\+=|-=)/.exec(a);if (!d) return a;var b = y(a) || 0;c = parseFloat(c);a = parseFloat(a.replace(d[0], &quot;&quot;));switch (d[0][0]) {case &quot;+&quot;:
       return c + a + b;case &quot;-&quot;:
       return c - a + b;case &quot;*&quot;:
       return c * a + b;}
 }function F(a, c) {
   return Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
 }function M(a) {
   a = a.points;for (var c = 0, d, b = 0; b &lt; a.numberOfItems; b++) {
     var f = a.getItem(b);0 &lt; b &amp;&amp; (c += F(d, f));d = f;
   }return c;
 }function N(a) {
   if (a.getTotalLength) return a.getTotalLength();switch (a.tagName.toLowerCase()) {case &quot;circle&quot;:
       return 2 * Math.PI * a.getAttribute(&quot;r&quot;);case &quot;rect&quot;:
       return 2 * a.getAttribute(&quot;width&quot;) + 2 * a.getAttribute(&quot;height&quot;);case &quot;line&quot;:
       return F({ x: a.getAttribute(&quot;x1&quot;), y: a.getAttribute(&quot;y1&quot;) }, { x: a.getAttribute(&quot;x2&quot;), y: a.getAttribute(&quot;y2&quot;) });case &quot;polyline&quot;:
       return M(a);case &quot;polygon&quot;:
       var c = a.points;return M(a) + F(c.getItem(c.numberOfItems - 1), c.getItem(0));}
 }function Y(a, c) {
   function d(b) {
     b = void 0 === b ? 0 : b;return a.el.getPointAtLength(1 &lt;= c + b ? c + b : 0);
   }var b = d(),
       f = d(-1),
       n = d(1);switch (a.property) {case &quot;x&quot;:
       return b.x;case &quot;y&quot;:
       return b.y;
     case &quot;angle&quot;:
       return 180 * Math.atan2(n.y - f.y, n.x - f.x) / Math.PI;}
 }function O(a, c) {
   var d = /-?\d*\.?\d+/g,
       b;b = h.pth(a) ? a.totalLength : a;if (h.col(b)) {
     if (h.rgb(b)) {
       var f = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(b);b = f ? &quot;rgba(&quot; + f[1] + &quot;,1)&quot; : b;
     } else b = h.hex(b) ? T(b) : h.hsl(b) ? U(b) : void 0;
   } else f = (f = y(b)) ? b.substr(0, b.length - f.length) : b, b = c &amp;&amp; !/\s/g.test(b) ? f + c : f;b += &quot;&quot;;return { original: b, numbers: b.match(d) ? b.match(d).map(Number) : [0], strings: h.str(a) || c ? b.split(d) : [] };
 }function P(a) {
   a = a ? p(h.arr(a) ? a.map(m) : m(a)) : [];return r(a, function (a, d, b) {
     return b.indexOf(a) === d;
   });
 }function Z(a) {
   var c = P(a);return c.map(function (a, b) {
     return { target: a, id: b, total: c.length };
   });
 }function aa(a, c) {
   var d = C(c);if (h.arr(a)) {
     var b = a.length;2 !== b || h.obj(a[0]) ? h.fnc(c.duration) || (d.duration = c.duration / b) : a = { value: a };
   }return m(a).map(function (a, b) {
     b = b ? 0 : c.delay;a = h.obj(a) &amp;&amp; !h.pth(a) ? a : { value: a };h.und(a.delay) &amp;&amp; (a.delay = b);return a;
   }).map(function (a) {
     return z(a, d);
   });
 }function ba(a, c) {
   var d = {},
       b;for (b in a) {
     var f = I(a[b], c);h.arr(f) &amp;&amp; (f = f.map(function (a) {
       return I(a, c);
     }), 1 === f.length &amp;&amp; (f = f[0]));d[b] = f;
   }d.duration = parseFloat(d.duration);d.delay = parseFloat(d.delay);return d;
 }function ca(a) {
   return h.arr(a) ? A.apply(this, a) : Q[a];
 }function da(a, c) {
   var d;return a.tweens.map(function (b) {
     b = ba(b, c);var f = b.value,
         e = K(c.target, a.name),
         k = d ? d.to.original : e,
         k = h.arr(f) ? f[0] : k,
         w = L(h.arr(f) ? f[1] : f, k),
         e = y(w) || y(k) || y(e);b.from = O(k, e);b.to = O(w, e);b.start = d ? d.end : a.offset;b.end = b.start + b.delay + b.duration;b.easing = ca(b.easing);b.elasticity = (1E3 - Math.min(Math.max(b.elasticity, 1), 999)) / 1E3;b.isPath = h.pth(f);b.isColor = h.col(b.from.original);b.isColor &amp;&amp; (b.round = 1);return d = b;
   });
 }function ea(a, c) {
   return r(p(a.map(function (a) {
     return c.map(function (b) {
       var c = J(a.target, b.name);if (c) {
         var d = da(b, a);b = { type: c, property: b.name, animatable: a, tweens: d, duration: d[d.length - 1].end, delay: d[0].delay };
       } else b = void 0;return b;
     });
   })), function (a) {
     return !h.und(a);
   });
 }function R(a, c, d, b) {
   var f = &quot;delay&quot; === a;return c.length ? (f ? Math.min : Math.max).apply(Math, c.map(function (b) {
     return b[a];
   })) : f ? b.delay : d.offset + b.delay + b.duration;
 }function fa(a) {
   var c = D(ga, a),
       d = D(S, a),
       b = Z(a.targets),
       f = [],
       e = z(c, d),
       k;for (k in a) {
     e.hasOwnProperty(k) || &quot;targets&quot; === k || f.push({ name: k, offset: e.offset, tweens: aa(a[k], d) });
   }a = ea(b, f);return z(c, { children: [], animatables: b, animations: a, duration: R(&quot;duration&quot;, a, c, d), delay: R(&quot;delay&quot;, a, c, d) });
 }function q(a) {
   function c() {
     return window.Promise &amp;&amp; new Promise(function (a) {
       return p = a;
     });
   }function d(a) {
     return g.reversed ? g.duration - a : a;
   }function b(a) {
     for (var b = 0, c = {}, d = g.animations, f = d.length; b &lt; f;) {
       var e = d[b],
           k = e.animatable,
           h = e.tweens,
           n = h.length - 1,
           l = h[n];n &amp;&amp; (l = r(h, function (b) {
         return a &lt; b.end;
       })[0] || l);for (var h = Math.min(Math.max(a - l.start - l.delay, 0), l.duration) / l.duration, w = isNaN(h) ? 1 : l.easing(h, l.elasticity), h = l.to.strings, p = l.round, n = [], m = void 0, m = l.to.numbers.length, t = 0; t &lt; m; t++) {
         var x = void 0,
             x = l.to.numbers[t],
             q = l.from.numbers[t],
             x = l.isPath ? Y(l.value, w * x) : q + w * (x - q);p &amp;&amp; (l.isColor &amp;&amp; 2 &lt; t || (x = Math.round(x * p) / p));n.push(x);
       }if (l = h.length) for (m = h[0], w = 0; w &lt; l; w++) {
         p = h[w + 1], t = n[w], isNaN(t) || (m = p ? m + (t + p) : m + (t + &quot; &quot;));
       } else m = n[0];ha[e.type](k.target, e.property, m, c, k.id);e.currentValue = m;b++;
     }if (b = Object.keys(c).length) for (d = 0; d &lt; b; d++) {
       H || (H = E(document.body, &quot;transform&quot;) ? &quot;transform&quot; : &quot;-webkit-transform&quot;), g.animatables[d].target.style[H] = c[d].join(&quot; &quot;);
     }g.currentTime = a;g.progress = a / g.duration * 100;
   }function f(a) {
     if (g[a]) g[a](g);
   }function e() {
     g.remaining &amp;&amp; !0 !== g.remaining &amp;&amp; g.remaining--;
   }function k(a) {
     var k = g.duration,
         n = g.offset,
         w = n + g.delay,
         r = g.currentTime,
         x = g.reversed,
         q = d(a);if (g.children.length) {
       var u = g.children,
           v = u.length;
       if (q &gt;= g.currentTime) for (var G = 0; G &lt; v; G++) {
         u[G].seek(q);
       } else for (; v--;) {
         u[v].seek(q);
       }
     }if (q &gt;= w || !k) g.began || (g.began = !0, f(&quot;begin&quot;)), f(&quot;run&quot;);if (q &gt; n &amp;&amp; q &lt; k) b(q);else if (q &lt;= n &amp;&amp; 0 !== r &amp;&amp; (b(0), x &amp;&amp; e()), q &gt;= k &amp;&amp; r !== k || !k) b(k), x || e();f(&quot;update&quot;);a &gt;= k &amp;&amp; (g.remaining ? (t = h, &quot;alternate&quot; === g.direction &amp;&amp; (g.reversed = !g.reversed)) : (g.pause(), g.completed || (g.completed = !0, f(&quot;complete&quot;), &quot;Promise&quot; in window &amp;&amp; (p(), m = c()))), l = 0);
   }a = void 0 === a ? {} : a;var h,
       t,
       l = 0,
       p = null,
       m = c(),
       g = fa(a);g.reset = function () {
     var a = g.direction,
         c = g.loop;g.currentTime = 0;g.progress = 0;g.paused = !0;g.began = !1;g.completed = !1;g.reversed = &quot;reverse&quot; === a;g.remaining = &quot;alternate&quot; === a &amp;&amp; 1 === c ? 2 : c;b(0);for (a = g.children.length; a--;) {
       g.children[a].reset();
     }
   };g.tick = function (a) {
     h = a;t || (t = h);k((l + h - t) * q.speed);
   };g.seek = function (a) {
     k(d(a));
   };g.pause = function () {
     var a = v.indexOf(g);-1 &lt; a &amp;&amp; v.splice(a, 1);g.paused = !0;
   };g.play = function () {
     g.paused &amp;&amp; (g.paused = !1, t = 0, l = d(g.currentTime), v.push(g), B || ia());
   };g.reverse = function () {
     g.reversed = !g.reversed;t = 0;l = d(g.currentTime);
   };g.restart = function () {
     g.pause();
     g.reset();g.play();
   };g.finished = m;g.reset();g.autoplay &amp;&amp; g.play();return g;
 }var ga = { update: void 0, begin: void 0, run: void 0, complete: void 0, loop: 1, direction: &quot;normal&quot;, autoplay: !0, offset: 0 },
     S = { duration: 1E3, delay: 0, easing: &quot;easeOutElastic&quot;, elasticity: 500, round: 0 },
     W = &quot;translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective&quot;.split(&quot; &quot;),
     H,
     h = { arr: function (a) {
     return Array.isArray(a);
   }, obj: function (a) {
     return -1 &lt; Object.prototype.toString.call(a).indexOf(&quot;Object&quot;);
   },
   pth: function (a) {
     return h.obj(a) &amp;&amp; a.hasOwnProperty(&quot;totalLength&quot;);
   }, svg: function (a) {
     return a instanceof SVGElement;
   }, dom: function (a) {
     return a.nodeType || h.svg(a);
   }, str: function (a) {
     return &quot;string&quot; === typeof a;
   }, fnc: function (a) {
     return &quot;function&quot; === typeof a;
   }, und: function (a) {
     return &quot;undefined&quot; === typeof a;
   }, hex: function (a) {
     return (/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a)
     );
   }, rgb: function (a) {
     return (/^rgb/.test(a)
     );
   }, hsl: function (a) {
     return (/^hsl/.test(a)
     );
   }, col: function (a) {
     return h.hex(a) || h.rgb(a) || h.hsl(a);
   } },
     A = function () {
   function a(a, d, b) {
     return (((1 - 3 * b + 3 * d) * a + (3 * b - 6 * d)) * a + 3 * d) * a;
   }return function (c, d, b, f) {
     if (0 &lt;= c &amp;&amp; 1 &gt;= c &amp;&amp; 0 &lt;= b &amp;&amp; 1 &gt;= b) {
       var e = new Float32Array(11);if (c !== d || b !== f) for (var k = 0; 11 &gt; k; ++k) {
         e[k] = a(.1 * k, c, b);
       }return function (k) {
         if (c === d &amp;&amp; b === f) return k;if (0 === k) return 0;if (1 === k) return 1;for (var h = 0, l = 1; 10 !== l &amp;&amp; e[l] &lt;= k; ++l) {
           h += .1;
         }--l;var l = h + (k - e[l]) / (e[l + 1] - e[l]) * .1,
             n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c;if (.001 &lt;= n) {
           for (h = 0; 4 &gt; h; ++h) {
             n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c;if (0 === n) break;var m = a(l, c, b) - k,
                 l = l - m / n;
           }k = l;
         } else if (0 === n) k = l;else {
           var l = h,
               h = h + .1,
               g = 0;do {
             m = l + (h - l) / 2, n = a(m, c, b) - k, 0 &lt; n ? h = m : l = m;
           } while (1e-7 &lt; Math.abs(n) &amp;&amp; 10 &gt; ++g);k = m;
         }return a(k, d, f);
       };
     }
   };
 }(),
     Q = function () {
   function a(a, b) {
     return 0 === a || 1 === a ? a : -Math.pow(2, 10 * (a - 1)) * Math.sin(2 * (a - 1 - b / (2 * Math.PI) * Math.asin(1)) * Math.PI / b);
   }var c = &quot;Quad Cubic Quart Quint Sine Expo Circ Back Elastic&quot;.split(&quot; &quot;),
       d = { In: [[.55, .085, .68, .53], [.55, .055, .675, .19], [.895, .03, .685, .22], [.755, .05, .855, .06], [.47, 0, .745, .715], [.95, .05, .795, .035], [.6, .04, .98, .335], [.6, -.28, .735, .045], a], Out: [[.25, .46, .45, .94], [.215, .61, .355, 1], [.165, .84, .44, 1], [.23, 1, .32, 1], [.39, .575, .565, 1], [.19, 1, .22, 1], [.075, .82, .165, 1], [.175, .885, .32, 1.275], function (b, c) {
       return 1 - a(1 - b, c);
     }], InOut: [[.455, .03, .515, .955], [.645, .045, .355, 1], [.77, 0, .175, 1], [.86, 0, .07, 1], [.445, .05, .55, .95], [1, 0, 0, 1], [.785, .135, .15, .86], [.68, -.55, .265, 1.55], function (b, c) {
       return .5 &gt; b ? a(2 * b, c) / 2 : 1 - a(-2 * b + 2, c) / 2;
     }] },
       b = { linear: A(.25, .25, .75, .75) },
       f = {},
       e;for (e in d) {
     f.type = e, d[f.type].forEach(function (a) {
       return function (d, f) {
         b[&quot;ease&quot; + a.type + c[f]] = h.fnc(d) ? d : A.apply($jscomp$this, d);
       };
     }(f)), f = { type: f.type };
   }return b;
 }(),
     ha = { css: function (a, c, d) {
     return a.style[c] = d;
   }, attribute: function (a, c, d) {
     return a.setAttribute(c, d);
   }, object: function (a, c, d) {
     return a[c] = d;
   }, transform: function (a, c, d, b, f) {
     b[f] || (b[f] = []);b[f].push(c + &quot;(&quot; + d + &quot;)&quot;);
   } },
     v = [],
     B = 0,
     ia = function () {
   function a() {
     B = requestAnimationFrame(c);
   }function c(c) {
     var b = v.length;if (b) {
       for (var d = 0; d &lt; b;) {
         v[d] &amp;&amp; v[d].tick(c), d++;
       }a();
     } else cancelAnimationFrame(B), B = 0;
   }return a;
 }();q.version = &quot;2.2.0&quot;;q.speed = 1;q.running = v;q.remove = function (a) {
   a = P(a);for (var c = v.length; c--;) {
     for (var d = v[c], b = d.animations, f = b.length; f--;) {
       u(a, b[f].animatable.target) &amp;&amp; (b.splice(f, 1), b.length || d.pause());
     }
   }
 };q.getValue = K;q.path = function (a, c) {
   var d = h.str(a) ? e(a)[0] : a,
       b = c || 100;return function (a) {
     return { el: d, property: a, totalLength: N(d) * (b / 100) };
   };
 };q.setDashoffset = function (a) {
   var c = N(a);a.setAttribute(&quot;stroke-dasharray&quot;, c);return c;
 };q.bezier = A;q.easings = Q;q.timeline = function (a) {
   var c = q(a);c.pause();c.duration = 0;c.add = function (d) {
     c.children.forEach(function (a) {
       a.began = !0;a.completed = !0;
     });m(d).forEach(function (b) {
       var d = z(b, D(S, a || {}));d.targets = d.targets || a.targets;b = c.duration;var e = d.offset;d.autoplay = !1;d.direction = c.direction;d.offset = h.und(e) ? b : L(e, b);c.began = !0;c.completed = !0;c.seek(d.offset);d = q(d);d.began = !0;d.completed = !0;d.duration &gt; b &amp;&amp; (c.duration = d.duration);c.children.push(d);
     });c.seek(0);c.reset();c.autoplay &amp;&amp; c.restart();return c;
   };return c;
 };q.random = function (a, c) {
   return Math.floor(Math.random() * (c - a + 1)) + a;
 };return q;
</PRE><P>});
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   accordion: true,
   onOpenStart: undefined,
   onOpenEnd: undefined,
   onCloseStart: undefined,
   onCloseEnd: undefined,
   inDuration: 300,
   outDuration: 300
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Collapsible = function (_Component) {
   _inherits(Collapsible, _Component);
</PRE><PRE>   /**
    * Construct Collapsible instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Collapsible(el, options) {
     _classCallCheck(this, Collapsible);
</PRE><PRE>     var _this3 = _possibleConstructorReturn(this, (Collapsible.__proto__ || Object.getPrototypeOf(Collapsible)).call(this, Collapsible, el, options));
</PRE><PRE>     _this3.el.M_Collapsible = _this3;
</PRE><PRE>     /**
      * Options for the collapsible
      * @member Collapsible#options
      * @prop {Boolean} [accordion=false] - Type of the collapsible
      * @prop {Function} onOpenStart - Callback function called before collapsible is opened
      * @prop {Function} onOpenEnd - Callback function called after collapsible is opened
      * @prop {Function} onCloseStart - Callback function called before collapsible is closed
      * @prop {Function} onCloseEnd - Callback function called after collapsible is closed
      * @prop {Number} inDuration - Transition in duration in milliseconds.
      * @prop {Number} outDuration - Transition duration in milliseconds.
      */
     _this3.options = $.extend({}, Collapsible.defaults, options);
</PRE><PRE>     // Setup tab indices
     _this3.$headers = _this3.$el.children('li').children('.collapsible-header');
     _this3.$headers.attr('tabindex', 0);
</PRE><PRE>     _this3._setupEventHandlers();
</PRE><PRE>     // Open first active
     var $activeBodies = _this3.$el.children('li.active').children('.collapsible-body');
     if (_this3.options.accordion) {
       // Handle Accordion
       $activeBodies.first().css('display', 'block');
     } else {
       // Handle Expandables
       $activeBodies.css('display', 'block');
     }
     return _this3;
   }
</PRE><PRE>   _createClass(Collapsible, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this.el.M_Collapsible = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       var _this4 = this;
</PRE><PRE>       this._handleCollapsibleClickBound = this._handleCollapsibleClick.bind(this);
       this._handleCollapsibleKeydownBound = this._handleCollapsibleKeydown.bind(this);
       this.el.addEventListener('click', this._handleCollapsibleClickBound);
       this.$headers.each(function (header) {
         header.addEventListener('keydown', _this4._handleCollapsibleKeydownBound);
       });
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       var _this5 = this;
</PRE><PRE>       this.el.removeEventListener('click', this._handleCollapsibleClickBound);
       this.$headers.each(function (header) {
         header.removeEventListener('keydown', _this5._handleCollapsibleKeydownBound);
       });
     }
</PRE><PRE>     /**
      * Handle Collapsible Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleCollapsibleClick&quot;,
     value: function _handleCollapsibleClick(e) {
       var $header = $(e.target).closest('.collapsible-header');
       if (e.target &amp;&amp; $header.length) {
         var $collapsible = $header.closest('.collapsible');
         if ($collapsible[0] === this.el) {
           var $collapsibleLi = $header.closest('li');
           var $collapsibleLis = $collapsible.children('li');
           var isActive = $collapsibleLi[0].classList.contains('active');
           var index = $collapsibleLis.index($collapsibleLi);
</PRE><PRE>           if (isActive) {
             this.close(index);
           } else {
             this.open(index);
           }
         }
       }
     }
</PRE><PRE>     /**
      * Handle Collapsible Keydown
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleCollapsibleKeydown&quot;,
     value: function _handleCollapsibleKeydown(e) {
       if (e.keyCode === 13) {
         this._handleCollapsibleClickBound(e);
       }
     }
</PRE><PRE>     /**
      * Animate in collapsible slide
      * @param {Number} index - 0th index of slide
      */
</PRE><PRE>   }, {
     key: &quot;_animateIn&quot;,
     value: function _animateIn(index) {
       var _this6 = this;
</PRE><PRE>       var $collapsibleLi = this.$el.children('li').eq(index);
       if ($collapsibleLi.length) {
         var $body = $collapsibleLi.children('.collapsible-body');
</PRE><PRE>         anim.remove($body[0]);
         $body.css({
           display: 'block',
           overflow: 'hidden',
           height: 0,
           paddingTop: <I>,</I>
           paddingBottom: 
         });
</PRE><PRE>         var pTop = $body.css('padding-top');
         var pBottom = $body.css('padding-bottom');
         var finalHeight = $body[0].scrollHeight;
         $body.css({
           paddingTop: 0,
           paddingBottom: 0
         });
</PRE><PRE>         anim({
           targets: $body[0],
           height: finalHeight,
           paddingTop: pTop,
           paddingBottom: pBottom,
           duration: this.options.inDuration,
           easing: 'easeInOutCubic',
           complete: function (anim) {
             $body.css({
               overflow: <I>,</I>
               paddingTop: <I>,</I>
               paddingBottom: <I>,</I>
               height: 
             });
</PRE><PRE>             // onOpenEnd callback
             if (typeof _this6.options.onOpenEnd === 'function') {
               _this6.options.onOpenEnd.call(_this6, $collapsibleLi[0]);
             }
           }
         });
       }
     }
</PRE><PRE>     /**
      * Animate out collapsible slide
      * @param {Number} index - 0th index of slide to open
      */
</PRE><PRE>   }, {
     key: &quot;_animateOut&quot;,
     value: function _animateOut(index) {
       var _this7 = this;
</PRE><PRE>       var $collapsibleLi = this.$el.children('li').eq(index);
       if ($collapsibleLi.length) {
         var $body = $collapsibleLi.children('.collapsible-body');
         anim.remove($body[0]);
         $body.css('overflow', 'hidden');
         anim({
           targets: $body[0],
           height: 0,
           paddingTop: 0,
           paddingBottom: 0,
           duration: this.options.outDuration,
           easing: 'easeInOutCubic',
           complete: function () {
             $body.css({
               height: <I>,</I>
               overflow: <I>,</I>
               padding: <I>,</I>
               display: 
             });
</PRE><PRE>             // onCloseEnd callback
             if (typeof _this7.options.onCloseEnd === 'function') {
               _this7.options.onCloseEnd.call(_this7, $collapsibleLi[0]);
             }
           }
         });
       }
     }
</PRE><PRE>     /**
      * Open Collapsible
      * @param {Number} index - 0th index of slide
      */
</PRE><PRE>   }, {
     key: &quot;open&quot;,
     value: function open(index) {
       var _this8 = this;
</PRE><PRE>       var $collapsibleLi = this.$el.children('li').eq(index);
       if ($collapsibleLi.length &amp;&amp; !$collapsibleLi[0].classList.contains('active')) {
         // onOpenStart callback
         if (typeof this.options.onOpenStart === 'function') {
           this.options.onOpenStart.call(this, $collapsibleLi[0]);
         }
</PRE><PRE>         // Handle accordion behavior
         if (this.options.accordion) {
           var $collapsibleLis = this.$el.children('li');
           var $activeLis = this.$el.children('li.active');
           $activeLis.each(function (el) {
             var index = $collapsibleLis.index($(el));
             _this8.close(index);
           });
         }
</PRE><PRE>         // Animate in
         $collapsibleLi[0].classList.add('active');
         this._animateIn(index);
       }
     }
</PRE><PRE>     /**
      * Close Collapsible
      * @param {Number} index - 0th index of slide
      */
</PRE><PRE>   }, {
     key: &quot;close&quot;,
     value: function close(index) {
       var $collapsibleLi = this.$el.children('li').eq(index);
       if ($collapsibleLi.length &amp;&amp; $collapsibleLi[0].classList.contains('active')) {
         // onCloseStart callback
         if (typeof this.options.onCloseStart === 'function') {
           this.options.onCloseStart.call(this, $collapsibleLi[0]);
         }
</PRE><PRE>         // Animate out
         $collapsibleLi[0].classList.remove('active');
         this._animateOut(index);
       }
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Collapsible.__proto__ || Object.getPrototypeOf(Collapsible), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Collapsible;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Collapsible;
 }(Component);
</PRE><PRE> M.Collapsible = Collapsible;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Collapsible, 'collapsible', 'M_Collapsible');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   alignment: 'left',
   autoFocus: true,
   constrainWidth: true,
   container: null,
   coverTrigger: true,
   closeOnClick: true,
   hover: false,
   inDuration: 150,
   outDuration: 250,
   onOpenStart: null,
   onOpenEnd: null,
   onCloseStart: null,
   onCloseEnd: null,
   onItemClick: null
 };
</PRE><PRE> /**
  * @class
  */
</PRE><PRE> var Dropdown = function (_Component2) {
   _inherits(Dropdown, _Component2);
</PRE><PRE>   function Dropdown(el, options) {
     _classCallCheck(this, Dropdown);
</PRE><PRE>   var _this9 = _possibleConstructorReturn(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).call(this, Dropdown, el, options));
</PRE><PRE>     _this9.el.M_Dropdown = _this9;
     Dropdown._dropdowns.push(_this9);
</PRE><PRE>     _this9.id = M.getIdFromTrigger(el);
     _this9.dropdownEl = document.getElementById(_this9.id);
     _this9.$dropdownEl = $(_this9.dropdownEl);
</PRE><PRE>     /**
      * Options for the dropdown
      * @member Dropdown#options
      * @prop {String} [alignment='left'] - Edge which the dropdown is aligned to
      * @prop {Boolean} [autoFocus=true] - Automatically focus dropdown el for keyboard
      * @prop {Boolean} [constrainWidth=true] - Constrain width to width of the button
      * @prop {Element} container - Container element to attach dropdown to (optional)
      * @prop {Boolean} [coverTrigger=true] - Place dropdown over trigger
      * @prop {Boolean} [closeOnClick=true] - Close on click of dropdown item
      * @prop {Boolean} [hover=false] - Open dropdown on hover
      * @prop {Number} [inDuration=150] - Duration of open animation in ms
      * @prop {Number} [outDuration=250] - Duration of close animation in ms
      * @prop {Function} onOpenStart - Function called when dropdown starts opening
      * @prop {Function} onOpenEnd - Function called when dropdown finishes opening
      * @prop {Function} onCloseStart - Function called when dropdown starts closing
      * @prop {Function} onCloseEnd - Function called when dropdown finishes closing
      */
     _this9.options = $.extend({}, Dropdown.defaults, options);
</PRE><PRE>     /**
      * Describes open/close state of dropdown
      * @type {Boolean}
      */
     _this9.isOpen = false;
</PRE><PRE>     /**
      * Describes if dropdown content is scrollable
      * @type {Boolean}
      */
     _this9.isScrollable = false;
</PRE><PRE>     /**
      * Describes if touch moving on dropdown content
      * @type {Boolean}
      */
     _this9.isTouchMoving = false;
</PRE><PRE>     _this9.focusedIndex = -1;
     _this9.filterQuery = [];
</PRE><PRE>     // Move dropdown-content after dropdown-trigger
     if (!!_this9.options.container) {
       $(_this9.options.container).append(_this9.dropdownEl);
     } else {
       _this9.$el.after(_this9.dropdownEl);
     }
</PRE><PRE>     _this9._makeDropdownFocusable();
     _this9._resetFilterQueryBound = _this9._resetFilterQuery.bind(_this9);
     _this9._handleDocumentClickBound = _this9._handleDocumentClick.bind(_this9);
     _this9._handleDocumentTouchmoveBound = _this9._handleDocumentTouchmove.bind(_this9);
     _this9._handleDropdownClickBound = _this9._handleDropdownClick.bind(_this9);
     _this9._handleDropdownKeydownBound = _this9._handleDropdownKeydown.bind(_this9);
     _this9._handleTriggerKeydownBound = _this9._handleTriggerKeydown.bind(_this9);
     _this9._setupEventHandlers();
     return _this9;
   }
</PRE><PRE>   _createClass(Dropdown, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._resetDropdownStyles();
       this._removeEventHandlers();
       Dropdown._dropdowns.splice(Dropdown._dropdowns.indexOf(this), 1);
       this.el.M_Dropdown = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       // Trigger keydown handler
       this.el.addEventListener('keydown', this._handleTriggerKeydownBound);
</PRE><PRE>       // Item click handler
       this.dropdownEl.addEventListener('click', this._handleDropdownClickBound);
</PRE><PRE>       // Hover event handlers
       if (this.options.hover) {
         this._handleMouseEnterBound = this._handleMouseEnter.bind(this);
         this.el.addEventListener('mouseenter', this._handleMouseEnterBound);
         this._handleMouseLeaveBound = this._handleMouseLeave.bind(this);
         this.el.addEventListener('mouseleave', this._handleMouseLeaveBound);
         this.dropdownEl.addEventListener('mouseleave', this._handleMouseLeaveBound);
</PRE><PRE>         // Click event handlers
       } else {
         this._handleClickBound = this._handleClick.bind(this);
         this.el.addEventListener('click', this._handleClickBound);
       }
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('keydown', this._handleTriggerKeydownBound);
       this.dropdownEl.removeEventListener('click', this._handleDropdownClickBound);
</PRE><PRE>       if (this.options.hover) {
         this.el.removeEventListener('mouseenter', this._handleMouseEnterBound);
         this.el.removeEventListener('mouseleave', this._handleMouseLeaveBound);
         this.dropdownEl.removeEventListener('mouseleave', this._handleMouseLeaveBound);
       } else {
         this.el.removeEventListener('click', this._handleClickBound);
       }
     }
   }, {
     key: &quot;_setupTemporaryEventHandlers&quot;,
     value: function _setupTemporaryEventHandlers() {
       // Use capture phase event handler to prevent click
       document.body.addEventListener('click', this._handleDocumentClickBound, true);
       document.body.addEventListener('touchend', this._handleDocumentClickBound);
       document.body.addEventListener('touchmove', this._handleDocumentTouchmoveBound);
       this.dropdownEl.addEventListener('keydown', this._handleDropdownKeydownBound);
     }
   }, {
     key: &quot;_removeTemporaryEventHandlers&quot;,
     value: function _removeTemporaryEventHandlers() {
       // Use capture phase event handler to prevent click
       document.body.removeEventListener('click', this._handleDocumentClickBound, true);
       document.body.removeEventListener('touchend', this._handleDocumentClickBound);
       document.body.removeEventListener('touchmove', this._handleDocumentTouchmoveBound);
       this.dropdownEl.removeEventListener('keydown', this._handleDropdownKeydownBound);
     }
   }, {
     key: &quot;_handleClick&quot;,
     value: function _handleClick(e) {
       e.preventDefault();
       this.open();
     }
   }, {
     key: &quot;_handleMouseEnter&quot;,
     value: function _handleMouseEnter() {
       this.open();
     }
   }, {
     key: &quot;_handleMouseLeave&quot;,
     value: function _handleMouseLeave(e) {
       var toEl = e.toElement || e.relatedTarget;
       var leaveToDropdownContent = !!$(toEl).closest('.dropdown-content').length;
       var leaveToActiveDropdownTrigger = false;
</PRE><PRE>       var $closestTrigger = $(toEl).closest('.dropdown-trigger');
       if ($closestTrigger.length &amp;&amp; !!$closestTrigger[0].M_Dropdown &amp;&amp; $closestTrigger[0].M_Dropdown.isOpen) {
         leaveToActiveDropdownTrigger = true;
       }
</PRE><PRE>       // Close hover dropdown if mouse did not leave to either active dropdown-trigger or dropdown-content
       if (!leaveToActiveDropdownTrigger &amp;&amp; !leaveToDropdownContent) {
         this.close();
       }
     }
   }, {
     key: &quot;_handleDocumentClick&quot;,
     value: function _handleDocumentClick(e) {
       var _this10 = this;
</PRE><PRE>       var $target = $(e.target);
       if (this.options.closeOnClick &amp;&amp; $target.closest('.dropdown-content').length &amp;&amp; !this.isTouchMoving) {
         // isTouchMoving to check if scrolling on mobile.
         setTimeout(function () {
           _this10.close();
         }, 0);
       } else if ($target.closest('.dropdown-trigger').length || !$target.closest('.dropdown-content').length) {
         setTimeout(function () {
           _this10.close();
         }, 0);
       }
       this.isTouchMoving = false;
     }
   }, {
     key: &quot;_handleTriggerKeydown&quot;,
     value: function _handleTriggerKeydown(e) {
       // ARROW DOWN OR ENTER WHEN SELECT IS CLOSED - open Dropdown
       if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ENTER) &amp;&amp; !this.isOpen) {
         e.preventDefault();
         this.open();
       }
     }
</PRE><PRE>     /**
      * Handle Document Touchmove
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleDocumentTouchmove&quot;,
     value: function _handleDocumentTouchmove(e) {
       var $target = $(e.target);
       if ($target.closest('.dropdown-content').length) {
         this.isTouchMoving = true;
       }
     }
</PRE><PRE>     /**
      * Handle Dropdown Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleDropdownClick&quot;,
     value: function _handleDropdownClick(e) {
       // onItemClick callback
       if (typeof this.options.onItemClick === 'function') {
         var itemEl = $(e.target).closest('li')[0];
         this.options.onItemClick.call(this, itemEl);
       }
     }
</PRE><PRE>     /**
      * Handle Dropdown Keydown
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleDropdownKeydown&quot;,
     value: function _handleDropdownKeydown(e) {
       if (e.which === M.keys.TAB) {
         e.preventDefault();
         this.close();
</PRE><PRE>         // Navigate down dropdown list
       } else if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) &amp;&amp; this.isOpen) {
         e.preventDefault();
         var direction = e.which === M.keys.ARROW_DOWN ? 1 : -1;
         var newFocusedIndex = this.focusedIndex;
         var foundNewIndex = false;
         do {
           newFocusedIndex = newFocusedIndex + direction;
</PRE><PRE>           if (!!this.dropdownEl.children[newFocusedIndex] &amp;&amp; this.dropdownEl.children[newFocusedIndex].tabIndex !== -1) {
             foundNewIndex = true;
             break;
           }
         } while (newFocusedIndex &lt; this.dropdownEl.children.length &amp;&amp; newFocusedIndex &gt;= 0);
</PRE><PRE>         if (foundNewIndex) {
           this.focusedIndex = newFocusedIndex;
           this._focusFocusedItem();
         }
</PRE><PRE>         // ENTER selects choice on focused item
       } else if (e.which === M.keys.ENTER &amp;&amp; this.isOpen) {
         // Search for &lt;a&gt; and &lt;button&gt;
         var focusedElement = this.dropdownEl.children[this.focusedIndex];
         var $activatableElement = $(focusedElement).find('a, button').first();
</PRE><PRE>         // Click a or button tag if exists, otherwise click li tag
         if (!!$activatableElement.length) {
           $activatableElement[0].click();
         } else if (!!focusedElement) {
           focusedElement.click();
         }
</PRE><PRE>         // Close dropdown on ESC
       } else if (e.which === M.keys.ESC &amp;&amp; this.isOpen) {
         e.preventDefault();
         this.close();
       }
</PRE><PRE>       // CASE WHEN USER TYPE LETTERS
       var letter = String.fromCharCode(e.which).toLowerCase(),
           nonLetters = [9, 13, 27, 38, 40];
       if (letter &amp;&amp; nonLetters.indexOf(e.which) === -1) {
         this.filterQuery.push(letter);
</PRE><PRE>         var string = this.filterQuery.join(<I>),</I>
             newOptionEl = $(this.dropdownEl).find('li').filter(function (el) {
           return $(el).text().toLowerCase().indexOf(string) === 0;
         })[0];
</PRE><PRE>         if (newOptionEl) {
           this.focusedIndex = $(newOptionEl).index();
           this._focusFocusedItem();
         }
       }
</PRE><PRE>       this.filterTimeout = setTimeout(this._resetFilterQueryBound, 1000);
     }
</PRE><PRE>     /**
      * Setup dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_resetFilterQuery&quot;,
     value: function _resetFilterQuery() {
       this.filterQuery = [];
     }
   }, {
     key: &quot;_resetDropdownStyles&quot;,
     value: function _resetDropdownStyles() {
       this.$dropdownEl.css({
         display: <I>,</I>
         width: <I>,</I>
         height: <I>,</I>
         left: <I>,</I>
         top: <I>,</I>
         'transform-origin': <I>,</I>
         transform: <I>,</I>
         opacity: 
       });
     }
   }, {
     key: &quot;_makeDropdownFocusable&quot;,
     value: function _makeDropdownFocusable() {
       // Needed for arrow key navigation
       this.dropdownEl.tabIndex = 0;
</PRE><PRE>       // Only set tabindex if it hasn't been set by user
       $(this.dropdownEl).children().each(function (el) {
         if (!el.getAttribute('tabindex')) {
           el.setAttribute('tabindex', 0);
         }
       });
     }
   }, {
     key: &quot;_focusFocusedItem&quot;,
     value: function _focusFocusedItem() {
       if (this.focusedIndex &gt;= 0 &amp;&amp; this.focusedIndex &lt; this.dropdownEl.children.length &amp;&amp; this.options.autoFocus) {
         this.dropdownEl.children[this.focusedIndex].focus();
       }
     }
   }, {
     key: &quot;_getDropdownPosition&quot;,
     value: function _getDropdownPosition() {
       var offsetParentBRect = this.el.offsetParent.getBoundingClientRect();
       var triggerBRect = this.el.getBoundingClientRect();
       var dropdownBRect = this.dropdownEl.getBoundingClientRect();
</PRE><PRE>       var idealHeight = dropdownBRect.height;
       var idealWidth = dropdownBRect.width;
       var idealXPos = triggerBRect.left - dropdownBRect.left;
       var idealYPos = triggerBRect.top - dropdownBRect.top;
</PRE><PRE>       var dropdownBounds = {
         left: idealXPos,
         top: idealYPos,
         height: idealHeight,
         width: idealWidth
       };
</PRE><PRE>       // Countainer here will be closest ancestor with overflow: hidden
       var closestOverflowParent = !!this.dropdownEl.offsetParent ? this.dropdownEl.offsetParent : this.dropdownEl.parentNode;
</PRE><PRE>       var alignments = M.checkPossibleAlignments(this.el, closestOverflowParent, dropdownBounds, this.options.coverTrigger ? 0 : triggerBRect.height);
</PRE><PRE>       var verticalAlignment = 'top';
       var horizontalAlignment = this.options.alignment;
       idealYPos += this.options.coverTrigger ? 0 : triggerBRect.height;
</PRE><PRE>       // Reset isScrollable
       this.isScrollable = false;
</PRE><PRE>       if (!alignments.top) {
         if (alignments.bottom) {
           verticalAlignment = 'bottom';
         } else {
           this.isScrollable = true;
</PRE><PRE>// Determine which side has most space and cutoff at correct height
           if (alignments.spaceOnTop &gt; alignments.spaceOnBottom) {
             verticalAlignment = 'bottom';
             idealHeight += alignments.spaceOnTop;
             idealYPos -= alignments.spaceOnTop;
           } else {
             idealHeight += alignments.spaceOnBottom;
           }
         }
       }
</PRE><PRE>       // If preferred horizontal alignment is possible
       if (!alignments[horizontalAlignment]) {
         var oppositeAlignment = horizontalAlignment === 'left' ? 'right' : 'left';
         if (alignments[oppositeAlignment]) {
           horizontalAlignment = oppositeAlignment;
         } else {
           // Determine which side has most space and cutoff at correct height
           if (alignments.spaceOnLeft &gt; alignments.spaceOnRight) {
             horizontalAlignment = 'right';
             idealWidth += alignments.spaceOnLeft;
             idealXPos -= alignments.spaceOnLeft;
           } else {
             horizontalAlignment = 'left';
             idealWidth += alignments.spaceOnRight;
           }
         }
       }
</PRE><PRE>       if (verticalAlignment === 'bottom') {
         idealYPos = idealYPos - dropdownBRect.height + (this.options.coverTrigger ? triggerBRect.height : 0);
       }
       if (horizontalAlignment === 'right') {
         idealXPos = idealXPos - dropdownBRect.width + triggerBRect.width;
       }
       return {
         x: idealXPos,
         y: idealYPos,
         verticalAlignment: verticalAlignment,
         horizontalAlignment: horizontalAlignment,
         height: idealHeight,
         width: idealWidth
       };
     }
</PRE><PRE>     /**
      * Animate in dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_animateIn&quot;,
     value: function _animateIn() {
       var _this11 = this;
</PRE><PRE>       anim.remove(this.dropdownEl);
       anim({
         targets: this.dropdownEl,
         opacity: {
           value: [0, 1],
           easing: 'easeOutQuad'
         },
         scaleX: [0.3, 1],
         scaleY: [0.3, 1],
         duration: this.options.inDuration,
         easing: 'easeOutQuint',
         complete: function (anim) {
           if (_this11.options.autoFocus) {
             _this11.dropdownEl.focus();
           }
</PRE><PRE>           // onOpenEnd callback
           if (typeof _this11.options.onOpenEnd === 'function') {
             _this11.options.onOpenEnd.call(_this11, _this11.el);
           }
         }
       });
     }
</PRE><PRE>     /**
      * Animate out dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_animateOut&quot;,
     value: function _animateOut() {
       var _this12 = this;
</PRE><PRE>       anim.remove(this.dropdownEl);
       anim({
         targets: this.dropdownEl,
         opacity: {
           value: 0,
           easing: 'easeOutQuint'
         },
         scaleX: 0.3,
         scaleY: 0.3,
         duration: this.options.outDuration,
         easing: 'easeOutQuint',
         complete: function (anim) {
           _this12._resetDropdownStyles();
</PRE><PRE>           // onCloseEnd callback
           if (typeof _this12.options.onCloseEnd === 'function') {
             _this12.options.onCloseEnd.call(_this12, _this12.el);
           }
         }
       });
     }
</PRE><PRE>     /**
      * Place dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_placeDropdown&quot;,
     value: function _placeDropdown() {
       // Set width before calculating positionInfo
       var idealWidth = this.options.constrainWidth ? this.el.getBoundingClientRect().width : this.dropdownEl.getBoundingClientRect().width;
       this.dropdownEl.style.width = idealWidth + 'px';
</PRE><PRE>       var positionInfo = this._getDropdownPosition();
       this.dropdownEl.style.left = positionInfo.x + 'px';
       this.dropdownEl.style.top = positionInfo.y + 'px';
       this.dropdownEl.style.height = positionInfo.height + 'px';
       this.dropdownEl.style.width = positionInfo.width + 'px';
       this.dropdownEl.style.transformOrigin = (positionInfo.horizontalAlignment === 'left' ? '0' : '100%') + &quot; &quot; + (positionInfo.verticalAlignment === 'top' ? '0' : '100%');
     }
</PRE><PRE>     /**
      * Open Dropdown
      */
</PRE><PRE>   }, {
     key: &quot;open&quot;,
     value: function open() {
       if (this.isOpen) {
         return;
       }
       this.isOpen = true;
</PRE><PRE>       // onOpenStart callback
       if (typeof this.options.onOpenStart === 'function') {
         this.options.onOpenStart.call(this, this.el);
       }
</PRE><PRE>       // Reset styles
       this._resetDropdownStyles();
       this.dropdownEl.style.display = 'block';
</PRE><PRE>       this._placeDropdown();
       this._animateIn();
       this._setupTemporaryEventHandlers();
     }
</PRE><PRE>     /**
      * Close Dropdown
      */
</PRE><PRE>   }, {
     key: &quot;close&quot;,
     value: function close() {
       if (!this.isOpen) {
         return;
       }
       this.isOpen = false;
       this.focusedIndex = -1;
</PRE><PRE>       // onCloseStart callback
       if (typeof this.options.onCloseStart === 'function') {
         this.options.onCloseStart.call(this, this.el);
       }
</PRE><PRE>       this._animateOut();
       this._removeTemporaryEventHandlers();
</PRE><PRE>       if (this.options.autoFocus) {
         this.el.focus();
       }
     }
</PRE><PRE>     /**
      * Recalculate dimensions
      */
</PRE><PRE>   }, {
     key: &quot;recalculateDimensions&quot;,
     value: function recalculateDimensions() {
       if (this.isOpen) {
         this.$dropdownEl.css({
           width: <I>,</I>
           height: <I>,</I>
           left: <I>,</I>
           top: <I>,</I>
           'transform-origin': 
         });
         this._placeDropdown();
       }
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Dropdown.__proto__ || Object.getPrototypeOf(Dropdown), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Dropdown;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Dropdown;
 }(Component);
</PRE><PRE> /**
  * @static
  * @memberof Dropdown
  */
</PRE><PRE> Dropdown._dropdowns = [];
</PRE><PRE> M.Dropdown = Dropdown;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Dropdown, 'dropdown', 'M_Dropdown');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   opacity: 0.5,
   inDuration: 250,
   outDuration: 250,
   onOpenStart: null,
   onOpenEnd: null,
   onCloseStart: null,
   onCloseEnd: null,
   preventScrolling: true,
   dismissible: true,
   startingTop: '4%',
   endingTop: '10%'
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Modal = function (_Component3) {
   _inherits(Modal, _Component3);
</PRE><PRE>   /**
    * Construct Modal instance and set up overlay
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Modal(el, options) {
     _classCallCheck(this, Modal);
</PRE><PRE>     var _this13 = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, Modal, el, options));
</PRE><PRE>     _this13.el.M_Modal = _this13;
</PRE><PRE>     /**
      * Options for the modal
      * @member Modal#options
      * @prop {Number} [opacity=0.5] - Opacity of the modal overlay
      * @prop {Number} [inDuration=250] - Length in ms of enter transition
      * @prop {Number} [outDuration=250] - Length in ms of exit transition
      * @prop {Function} onOpenStart - Callback function called before modal is opened
      * @prop {Function} onOpenEnd - Callback function called after modal is opened
      * @prop {Function} onCloseStart - Callback function called before modal is closed
      * @prop {Function} onCloseEnd - Callback function called after modal is closed
      * @prop {Boolean} [dismissible=true] - Allow modal to be dismissed by keyboard or overlay click
      * @prop {String} [startingTop='4%'] - startingTop
      * @prop {String} [endingTop='10%'] - endingTop
      */
     _this13.options = $.extend({}, Modal.defaults, options);
</PRE><PRE>     /**
      * Describes open/close state of modal
      * @type {Boolean}
      */
     _this13.isOpen = false;
</PRE><PRE>     _this13.id = _this13.$el.attr('id');
     _this13._openingTrigger = undefined;
</PRE>
      _this13.$overlay = $('');
<PRE>     _this13.el.tabIndex = 0;
     _this13._nthModalOpened = 0;
</PRE><PRE>     Modal._count++;
     _this13._setupEventHandlers();
     return _this13;
   }
</PRE><PRE>   _createClass(Modal, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       Modal._count--;
       this._removeEventHandlers();
       this.el.removeAttribute('style');
       this.$overlay.remove();
       this.el.M_Modal = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleOverlayClickBound = this._handleOverlayClick.bind(this);
       this._handleModalCloseClickBound = this._handleModalCloseClick.bind(this);
</PRE><PRE>       if (Modal._count === 1) {
         document.body.addEventListener('click', this._handleTriggerClick);
       }
       this.$overlay[0].addEventListener('click', this._handleOverlayClickBound);
       this.el.addEventListener('click', this._handleModalCloseClickBound);
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       if (Modal._count === 0) {
         document.body.removeEventListener('click', this._handleTriggerClick);
       }
       this.$overlay[0].removeEventListener('click', this._handleOverlayClickBound);
       this.el.removeEventListener('click', this._handleModalCloseClickBound);
     }
</PRE><PRE>     /**
      * Handle Trigger Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleTriggerClick&quot;,
     value: function _handleTriggerClick(e) {
       var $trigger = $(e.target).closest('.modal-trigger');
       if ($trigger.length) {
         var modalId = M.getIdFromTrigger($trigger[0]);
         var modalInstance = document.getElementById(modalId).M_Modal;
         if (modalInstance) {
           modalInstance.open($trigger);
         }
         e.preventDefault();
       }
     }
</PRE><PRE>     /**
      * Handle Overlay Click
      */
</PRE><PRE>   }, {
     key: &quot;_handleOverlayClick&quot;,
     value: function _handleOverlayClick() {
       if (this.options.dismissible) {
         this.close();
       }
     }
</PRE><PRE>     /**
      * Handle Modal Close Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleModalCloseClick&quot;,
     value: function _handleModalCloseClick(e) {
       var $closeTrigger = $(e.target).closest('.modal-close');
       if ($closeTrigger.length) {
         this.close();
       }
     }
</PRE><PRE>     /**
      * Handle Keydown
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleKeydown&quot;,
     value: function _handleKeydown(e) {
       // ESC key
       if (e.keyCode === 27 &amp;&amp; this.options.dismissible) {
         this.close();
       }
     }
</PRE><PRE>     /**
      * Handle Focus
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleFocus&quot;,
     value: function _handleFocus(e) {
       // Only trap focus if this modal is the last model opened (prevents loops in nested modals).
       if (!this.el.contains(e.target) &amp;&amp; this._nthModalOpened === Modal._modalsOpen) {
         this.el.focus();
       }
     }
</PRE><PRE>     /**
      * Animate in modal
      */
</PRE><PRE>   }, {
     key: &quot;_animateIn&quot;,
     value: function _animateIn() {
       var _this14 = this;
</PRE><PRE>       // Set initial styles
       $.extend(this.el.style, {
         display: 'block',
         opacity: 0
       });
       $.extend(this.$overlay[0].style, {
         display: 'block',
         opacity: 0
       });
</PRE><PRE>       // Animate overlay
       anim({
         targets: this.$overlay[0],
         opacity: this.options.opacity,
         duration: this.options.inDuration,
         easing: 'easeOutQuad'
       });
</PRE><PRE>       // Define modal animation options
       var enterAnimOptions = {
         targets: this.el,
         duration: this.options.inDuration,
         easing: 'easeOutCubic',
         // Handle modal onOpenEnd callback
         complete: function () {
           if (typeof _this14.options.onOpenEnd === 'function') {
             _this14.options.onOpenEnd.call(_this14, _this14.el, _this14._openingTrigger);
           }
         }
       };
</PRE><PRE>       // Bottom sheet animation
       if (this.el.classList.contains('bottom-sheet')) {
         $.extend(enterAnimOptions, {
           bottom: 0,
           opacity: 1
         });
         anim(enterAnimOptions);
</PRE><PRE>         // Normal modal animation
       } else {
         $.extend(enterAnimOptions, {
           top: [this.options.startingTop, this.options.endingTop],
           opacity: 1,
           scaleX: [0.8, 1],
           scaleY: [0.8, 1]
         });
         anim(enterAnimOptions);
       }
     }
</PRE><PRE>     /**
      * Animate out modal
      */
</PRE><PRE>   }, {
     key: &quot;_animateOut&quot;,
     value: function _animateOut() {
       var _this15 = this;
</PRE><PRE>       // Animate overlay
       anim({
         targets: this.$overlay[0],
         opacity: 0,
         duration: this.options.outDuration,
         easing: 'easeOutQuart'
       });
</PRE><PRE>       // Define modal animation options
       var exitAnimOptions = {
         targets: this.el,
         duration: this.options.outDuration,
         easing: 'easeOutCubic',
         // Handle modal ready callback
         complete: function () {
           _this15.el.style.display = 'none';
           _this15.$overlay.remove();
</PRE><PRE>           // Call onCloseEnd callback
           if (typeof _this15.options.onCloseEnd === 'function') {
             _this15.options.onCloseEnd.call(_this15, _this15.el);
           }
         }
       };
</PRE><PRE>       // Bottom sheet animation
       if (this.el.classList.contains('bottom-sheet')) {
         $.extend(exitAnimOptions, {
           bottom: '-100%',
           opacity: 0
         });
         anim(exitAnimOptions);
</PRE><PRE>         // Normal modal animation
       } else {
         $.extend(exitAnimOptions, {
           top: [this.options.endingTop, this.options.startingTop],
           opacity: 0,
           scaleX: 0.8,
           scaleY: 0.8
         });
         anim(exitAnimOptions);
       }
     }
</PRE><PRE>     /**
      * Open Modal
      * @param {cash} [$trigger]
      */
</PRE><PRE>   }, {
     key: &quot;open&quot;,
     value: function open($trigger) {
       if (this.isOpen) {
         return;
       }
</PRE><PRE>       this.isOpen = true;
       Modal._modalsOpen++;
       this._nthModalOpened = Modal._modalsOpen;
</PRE><PRE>       // Set Z-Index based on number of currently open modals
       this.$overlay[0].style.zIndex = 1000 + Modal._modalsOpen * 2;
       this.el.style.zIndex = 1000 + Modal._modalsOpen * 2 + 1;
</PRE><PRE>       // Set opening trigger, undefined indicates modal was opened by javascript
       this._openingTrigger = !!$trigger ? $trigger[0] : undefined;
</PRE><PRE>       // onOpenStart callback
       if (typeof this.options.onOpenStart === 'function') {
         this.options.onOpenStart.call(this, this.el, this._openingTrigger);
       }
</PRE><PRE>       if (this.options.preventScrolling) {
         document.body.style.overflow = 'hidden';
       }
</PRE><PRE>       this.el.classList.add('open');
       this.el.insertAdjacentElement('afterend', this.$overlay[0]);
</PRE><PRE>       if (this.options.dismissible) {
         this._handleKeydownBound = this._handleKeydown.bind(this);
         this._handleFocusBound = this._handleFocus.bind(this);
         document.addEventListener('keydown', this._handleKeydownBound);
         document.addEventListener('focus', this._handleFocusBound, true);
       }
</PRE><PRE>       anim.remove(this.el);
       anim.remove(this.$overlay[0]);
       this._animateIn();
</PRE><PRE>       // Focus modal
       this.el.focus();
</PRE><PRE>       return this;
     }
</PRE><PRE>     /**
      * Close Modal
      */
</PRE><PRE>   }, {
     key: &quot;close&quot;,
     value: function close() {
       if (!this.isOpen) {
         return;
       }
</PRE><PRE>       this.isOpen = false;
       Modal._modalsOpen--;
       this._nthModalOpened = 0;
</PRE><PRE>       // Call onCloseStart callback
       if (typeof this.options.onCloseStart === 'function') {
         this.options.onCloseStart.call(this, this.el);
       }
</PRE><PRE>       this.el.classList.remove('open');
</PRE><PRE>       // Enable body scrolling only if there are no more modals open.
       if (Modal._modalsOpen === 0) {
         document.body.style.overflow = <I>;</I>
       }
</PRE><PRE>       if (this.options.dismissible) {
         document.removeEventListener('keydown', this._handleKeydownBound);
         document.removeEventListener('focus', this._handleFocusBound, true);
       }
</PRE><PRE>       anim.remove(this.el);
       anim.remove(this.$overlay[0]);
       this._animateOut();
       return this;
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Modal.__proto__ || Object.getPrototypeOf(Modal), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Modal;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Modal;
 }(Component);
</PRE><PRE> /**
  * @static
  * @memberof Modal
  */
</PRE><PRE> Modal._modalsOpen = 0;
</PRE><PRE> /**
  * @static
  * @memberof Modal
  */
 Modal._count = 0;
</PRE><PRE> M.Modal = Modal;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Modal, 'modal', 'M_Modal');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   inDuration: 275,
   outDuration: 200,
   onOpenStart: null,
   onOpenEnd: null,
   onCloseStart: null,
   onCloseEnd: null
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Materialbox = function (_Component4) {
   _inherits(Materialbox, _Component4);
</PRE><PRE>   /**
    * Construct Materialbox instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Materialbox(el, options) {
     _classCallCheck(this, Materialbox);
</PRE><PRE>     var _this16 = _possibleConstructorReturn(this, (Materialbox.__proto__ || Object.getPrototypeOf(Materialbox)).call(this, Materialbox, el, options));
</PRE><PRE>     _this16.el.M_Materialbox = _this16;
</PRE><PRE>     /**
      * Options for the modal
      * @member Materialbox#options
      * @prop {Number} [inDuration=275] - Length in ms of enter transition
      * @prop {Number} [outDuration=200] - Length in ms of exit transition
      * @prop {Function} onOpenStart - Callback function called before materialbox is opened
      * @prop {Function} onOpenEnd - Callback function called after materialbox is opened
      * @prop {Function} onCloseStart - Callback function called before materialbox is closed
      * @prop {Function} onCloseEnd - Callback function called after materialbox is closed
      */
     _this16.options = $.extend({}, Materialbox.defaults, options);
</PRE><PRE>     _this16.overlayActive = false;
     _this16.doneAnimating = true;
</PRE>
      _this16.placeholder = $('').addClass('material-placeholder');
<PRE>     _this16.originalWidth = 0;
     _this16.originalHeight = 0;
     _this16.originInlineStyles = _this16.$el.attr('style');
     _this16.caption = _this16.el.getAttribute('data-caption') || <I>;</I></PRE><PRE>     // Wrap
     _this16.$el.before(_this16.placeholder);
     _this16.placeholder.append(_this16.$el);
</PRE><PRE>     _this16._setupEventHandlers();
     return _this16;
   }
</PRE><PRE>   _createClass(Materialbox, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this.el.M_Materialbox = undefined;
</PRE><PRE>       // Unwrap image
       $(this.placeholder).after(this.el).remove();
</PRE><PRE>       this.$el.removeAttr('style');
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleMaterialboxClickBound = this._handleMaterialboxClick.bind(this);
       this.el.addEventListener('click', this._handleMaterialboxClickBound);
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('click', this._handleMaterialboxClickBound);
     }
</PRE><PRE>     /**
      * Handle Materialbox Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleMaterialboxClick&quot;,
     value: function _handleMaterialboxClick(e) {
       // If already modal, return to original
       if (this.doneAnimating === false || this.overlayActive &amp;&amp; this.doneAnimating) {
         this.close();
       } else {
         this.open();
       }
     }
</PRE><PRE>     /**
      * Handle Window Scroll
      */
</PRE><PRE>   }, {
     key: &quot;_handleWindowScroll&quot;,
     value: function _handleWindowScroll() {
       if (this.overlayActive) {
         this.close();
       }
     }
</PRE><PRE>     /**
      * Handle Window Resize
      */
</PRE><PRE> }, {
     key: &quot;_handleWindowResize&quot;,
     value: function _handleWindowResize() {
       if (this.overlayActive) {
         this.close();
       }
     }
</PRE><PRE>     /**
      * Handle Window Resize
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleWindowEscape&quot;,
     value: function _handleWindowEscape(e) {
       // ESC key
       if (e.keyCode === 27 &amp;&amp; this.doneAnimating &amp;&amp; this.overlayActive) {
         this.close();
       }
     }
</PRE><PRE>     /**
      * Find ancestors with overflow: hidden; and make visible
      */
</PRE><PRE>   }, {
     key: &quot;_makeAncestorsOverflowVisible&quot;,
     value: function _makeAncestorsOverflowVisible() {
       this.ancestorsChanged = $();
       var ancestor = this.placeholder[0].parentNode;
       while (ancestor !== null &amp;&amp; !$(ancestor).is(document)) {
         var curr = $(ancestor);
         if (curr.css('overflow') !== 'visible') {
           curr.css('overflow', 'visible');
           if (this.ancestorsChanged === undefined) {
             this.ancestorsChanged = curr;
           } else {
             this.ancestorsChanged = this.ancestorsChanged.add(curr);
           }
         }
         ancestor = ancestor.parentNode;
       }
     }
</PRE><PRE>     /**
      * Animate image in
      */
</PRE><PRE>   }, {
     key: &quot;_animateImageIn&quot;,
     value: function _animateImageIn() {
       var _this17 = this;
</PRE><PRE>       var animOptions = {
         targets: this.el,
         height: [this.originalHeight, this.newHeight],
         width: [this.originalWidth, this.newWidth],
         left: M.getDocumentScrollLeft() + this.windowWidth / 2 - this.placeholder.offset().left - this.newWidth / 2,
         top: M.getDocumentScrollTop() + this.windowHeight / 2 - this.placeholder.offset().top - this.newHeight / 2,
         duration: this.options.inDuration,
         easing: 'easeOutQuad',
         complete: function () {
           _this17.doneAnimating = true;
</PRE><PRE>           // onOpenEnd callback
           if (typeof _this17.options.onOpenEnd === 'function') {
             _this17.options.onOpenEnd.call(_this17, _this17.el);
           }
         }
       };
</PRE><PRE>       // Override max-width or max-height if needed
       this.maxWidth = this.$el.css('max-width');
       this.maxHeight = this.$el.css('max-height');
       if (this.maxWidth !== 'none') {
         animOptions.maxWidth = this.newWidth;
       }
       if (this.maxHeight !== 'none') {
         animOptions.maxHeight = this.newHeight;
       }
</PRE><PRE>       anim(animOptions);
     }
</PRE><PRE>     /**
      * Animate image out
      */
</PRE><PRE>   }, {
     key: &quot;_animateImageOut&quot;,
     value: function _animateImageOut() {
       var _this18 = this;
</PRE><PRE>       var animOptions = {
         targets: this.el,
         width: this.originalWidth,
         height: this.originalHeight,
         left: 0,
         top: 0,
         duration: this.options.outDuration,
         easing: 'easeOutQuad',
         complete: function () {
           _this18.placeholder.css({
             height: <I>,</I>
             width: <I>,</I>
             position: <I>,</I>
             top: <I>,</I>
             left: 
           });
</PRE><PRE>           // Revert to width or height attribute
           if (_this18.attrWidth) {
             _this18.$el.attr('width', _this18.attrWidth);
           }
           if (_this18.attrHeight) {
             _this18.$el.attr('height', _this18.attrHeight);
           }
</PRE><PRE>           _this18.$el.removeAttr('style');
           _this18.originInlineStyles &amp;&amp; _this18.$el.attr('style', _this18.originInlineStyles);
</PRE><PRE>           // Remove class
           _this18.$el.removeClass('active');
           _this18.doneAnimating = true;
</PRE><PRE>           // Remove overflow overrides on ancestors
           if (_this18.ancestorsChanged.length) {
             _this18.ancestorsChanged.css('overflow', <I>);</I>
           }
</PRE><PRE>           // onCloseEnd callback
           if (typeof _this18.options.onCloseEnd === 'function') {
             _this18.options.onCloseEnd.call(_this18, _this18.el);
           }
         }
       };
</PRE><PRE>       anim(animOptions);
     }
</PRE><PRE>     /**
      * Update open and close vars
      */
</PRE><PRE>   }, {
     key: &quot;_updateVars&quot;,
     value: function _updateVars() {
       this.windowWidth = window.innerWidth;
       this.windowHeight = window.innerHeight;
       this.caption = this.el.getAttribute('data-caption') || <I>;</I>
     }
</PRE><PRE>     /**
      * Open Materialbox
      */
</PRE><PRE>   }, {
     key: &quot;open&quot;,
     value: function open() {
       var _this19 = this;
</PRE><PRE>       this._updateVars();
       this.originalWidth = this.el.getBoundingClientRect().width;
       this.originalHeight = this.el.getBoundingClientRect().height;
</PRE><PRE>       // Set states
       this.doneAnimating = false;
       this.$el.addClass('active');
       this.overlayActive = true;
</PRE><PRE>       // onOpenStart callback
       if (typeof this.options.onOpenStart === 'function') {
         this.options.onOpenStart.call(this, this.el);
       }
</PRE><PRE>       // Set positioning for placeholder
       this.placeholder.css({
         width: this.placeholder[0].getBoundingClientRect().width + 'px',
         height: this.placeholder[0].getBoundingClientRect().height + 'px',
         position: 'relative',
         top: 0,
         left: 0
       });
</PRE><PRE>       this._makeAncestorsOverflowVisible();
</PRE><PRE>       // Set css on origin
       this.$el.css({
         position: 'absolute',
         'z-index': 1000,
         'will-change': 'left, top, width, height'
       });
</PRE><PRE>       // Change from width or height attribute to css
       this.attrWidth = this.$el.attr('width');
       this.attrHeight = this.$el.attr('height');
       if (this.attrWidth) {
         this.$el.css('width', this.attrWidth + 'px');
         this.$el.removeAttr('width');
       }
       if (this.attrHeight) {
         this.$el.css('width', this.attrHeight + 'px');
         this.$el.removeAttr('height');
       }
</PRE><PRE>       // Add overlay
</PRE>
        this.$overlay = $('').css({
<PRE>         opacity: 0
       }).one('click', function () {
         if (_this19.doneAnimating) {
           _this19.close();
         }
       });
</PRE><PRE>       // Put before in origin image to preserve z-index layering.
       this.$el.before(this.$overlay);
</PRE><PRE>       // Set dimensions if needed
       var overlayOffset = this.$overlay[0].getBoundingClientRect();
       this.$overlay.css({
         width: this.windowWidth + 'px',
         height: this.windowHeight + 'px',
         left: -1 * overlayOffset.left + 'px',
         top: -1 * overlayOffset.top + 'px'
       });
</PRE><PRE>       anim.remove(this.el);
       anim.remove(this.$overlay[0]);
</PRE><PRE>       // Animate Overlay
       anim({
         targets: this.$overlay[0],
         opacity: 1,
         duration: this.options.inDuration,
         easing: 'easeOutQuad'
       });
</PRE><PRE>       // Add and animate caption if it exists
       if (this.caption !== <I>) {</I>
         if (this.$photocaption) {
           anim.remove(this.$photoCaption[0]);
         }
</PRE>
          this.$photoCaption = $('');
<PRE>         this.$photoCaption.text(this.caption);
         $('body').append(this.$photoCaption);
         this.$photoCaption.css({ display: 'inline' });
</PRE><PRE>         anim({
           targets: this.$photoCaption[0],
           opacity: 1,
           duration: this.options.inDuration,
           easing: 'easeOutQuad'
         });
       }
</PRE><PRE>       // Resize Image
       var ratio = 0;
       var widthPercent = this.originalWidth / this.windowWidth;
       var heightPercent = this.originalHeight / this.windowHeight;
       this.newWidth = 0;
       this.newHeight = 0;
</PRE><PRE>       if (widthPercent &gt; heightPercent) {
         ratio = this.originalHeight / this.originalWidth;
         this.newWidth = this.windowWidth * 0.9;
         this.newHeight = this.windowWidth * 0.9 * ratio;
       } else {
         ratio = this.originalWidth / this.originalHeight;
         this.newWidth = this.windowHeight * 0.9 * ratio;
         this.newHeight = this.windowHeight * 0.9;
       }
</PRE><PRE>       this._animateImageIn();
</PRE><PRE>       // Handle Exit triggers
       this._handleWindowScrollBound = this._handleWindowScroll.bind(this);
       this._handleWindowResizeBound = this._handleWindowResize.bind(this);
       this._handleWindowEscapeBound = this._handleWindowEscape.bind(this);
</PRE><PRE>       window.addEventListener('scroll', this._handleWindowScrollBound);
       window.addEventListener('resize', this._handleWindowResizeBound);
       window.addEventListener('keyup', this._handleWindowEscapeBound);
     }
</PRE><PRE>     /**
      * Close Materialbox
      */
</PRE><PRE>   }, {
     key: &quot;close&quot;,
     value: function close() {
       var _this20 = this;
</PRE><PRE>       this._updateVars();
       this.doneAnimating = false;
</PRE><PRE>       // onCloseStart callback
       if (typeof this.options.onCloseStart === 'function') {
         this.options.onCloseStart.call(this, this.el);
       }
</PRE><PRE>       anim.remove(this.el);
       anim.remove(this.$overlay[0]);
</PRE><PRE>       if (this.caption !== <I>) {</I>
         anim.remove(this.$photoCaption[0]);
       }
</PRE><PRE>       // disable exit handlers
       window.removeEventListener('scroll', this._handleWindowScrollBound);
       window.removeEventListener('resize', this._handleWindowResizeBound);
       window.removeEventListener('keyup', this._handleWindowEscapeBound);
</PRE><PRE>       anim({
         targets: this.$overlay[0],
         opacity: 0,
         duration: this.options.outDuration,
         easing: 'easeOutQuad',
         complete: function () {
           _this20.overlayActive = false;
           _this20.$overlay.remove();
         }
       });
</PRE><PRE>       this._animateImageOut();
</PRE><PRE>       // Remove Caption + reset css settings on image
       if (this.caption !== <I>) {</I>
         anim({
           targets: this.$photoCaption[0],
           opacity: 0,
           duration: this.options.outDuration,
           easing: 'easeOutQuad',
           complete: function () {
             _this20.$photoCaption.remove();
           }
         });
       }
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Materialbox.__proto__ || Object.getPrototypeOf(Materialbox), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Materialbox;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Materialbox;
 }(Component);
</PRE><PRE> M.Materialbox = Materialbox;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Materialbox, 'materialbox', 'M_Materialbox');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   responsiveThreshold: 0 // breakpoint for swipeable
 };
</PRE><PRE> var Parallax = function (_Component5) {
   _inherits(Parallax, _Component5);
</PRE><PRE>   function Parallax(el, options) {
     _classCallCheck(this, Parallax);
</PRE><PRE>     var _this21 = _possibleConstructorReturn(this, (Parallax.__proto__ || Object.getPrototypeOf(Parallax)).call(this, Parallax, el, options));
</PRE><PRE>     _this21.el.M_Parallax = _this21;
</PRE><PRE>     /**
      * Options for the Parallax
      * @member Parallax#options
      * @prop {Number} responsiveThreshold
      */
     _this21.options = $.extend({}, Parallax.defaults, options);
     _this21._enabled = window.innerWidth &gt; _this21.options.responsiveThreshold;
</PRE><PRE>     _this21.$img = _this21.$el.find('img').first();
     _this21.$img.each(function () {
       var el = this;
       if (el.complete) $(el).trigger('load');
     });
</PRE><PRE>     _this21._updateParallax();
     _this21._setupEventHandlers();
     _this21._setupStyles();
</PRE><PRE>     Parallax._parallaxes.push(_this21);
     return _this21;
   }
</PRE><PRE>   _createClass(Parallax, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       Parallax._parallaxes.splice(Parallax._parallaxes.indexOf(this), 1);
       this.$img[0].style.transform = <I>;</I>
       this._removeEventHandlers();
</PRE><PRE>       this.$el[0].M_Parallax = undefined;
     }
   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleImageLoadBound = this._handleImageLoad.bind(this);
       this.$img[0].addEventListener('load', this._handleImageLoadBound);
</PRE><PRE>       if (Parallax._parallaxes.length === 0) {
         Parallax._handleScrollThrottled = M.throttle(Parallax._handleScroll, 5);
         window.addEventListener('scroll', Parallax._handleScrollThrottled);
</PRE><PRE>         Parallax._handleWindowResizeThrottled = M.throttle(Parallax._handleWindowResize, 5);
         window.addEventListener('resize', Parallax._handleWindowResizeThrottled);
       }
     }
   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.$img[0].removeEventListener('load', this._handleImageLoadBound);
</PRE><PRE>       if (Parallax._parallaxes.length === 0) {
         window.removeEventListener('scroll', Parallax._handleScrollThrottled);
         window.removeEventListener('resize', Parallax._handleWindowResizeThrottled);
       }
     }
   }, {
     key: &quot;_setupStyles&quot;,
     value: function _setupStyles() {
       this.$img[0].style.opacity = 1;
     }
   }, {
     key: &quot;_handleImageLoad&quot;,
     value: function _handleImageLoad() {
       this._updateParallax();
     }
   }, {
     key: &quot;_updateParallax&quot;,
     value: function _updateParallax() {
       var containerHeight = this.$el.height() &gt; 0 ? this.el.parentNode.offsetHeight : 500;
       var imgHeight = this.$img[0].offsetHeight;
       var parallaxDist = imgHeight - containerHeight;
       var bottom = this.$el.offset().top + containerHeight;
       var top = this.$el.offset().top;
       var scrollTop = M.getDocumentScrollTop();
       var windowHeight = window.innerHeight;
       var windowBottom = scrollTop + windowHeight;
       var percentScrolled = (windowBottom - top) / (containerHeight + windowHeight);
       var parallax = parallaxDist * percentScrolled;
</PRE><PRE>       if (!this._enabled) {
         this.$img[0].style.transform = <I>;</I>
       } else if (bottom &gt; scrollTop &amp;&amp; top &lt; scrollTop + windowHeight) {
         this.$img[0].style.transform = &quot;translate3D(-50%, &quot; + parallax + &quot;px, 0)&quot;;
       }
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Parallax.__proto__ || Object.getPrototypeOf(Parallax), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Parallax;
     }
   }, {
     key: &quot;_handleScroll&quot;,
     value: function _handleScroll() {
       for (var i = 0; i &lt; Parallax._parallaxes.length; i++) {
         var parallaxInstance = Parallax._parallaxes[i];
         parallaxInstance._updateParallax.call(parallaxInstance);
       }
     }
   }, {
     key: &quot;_handleWindowResize&quot;,
     value: function _handleWindowResize() {
       for (var i = 0; i &lt; Parallax._parallaxes.length; i++) {
         var parallaxInstance = Parallax._parallaxes[i];
         parallaxInstance._enabled = window.innerWidth &gt; parallaxInstance.options.responsiveThreshold;
       }
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Parallax;
 }(Component);
</PRE><PRE> /**
  * @static
  * @memberof Parallax
  */
</PRE><PRE> Parallax._parallaxes = [];
</PRE><PRE> M.Parallax = Parallax;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Parallax, 'parallax', 'M_Parallax');
 }
</PRE><P>})(cash);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   duration: 300,
   onShow: null,
   swipeable: false,
   responsiveThreshold: Infinity // breakpoint for swipeable
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Tabs = function (_Component6) {
   _inherits(Tabs, _Component6);
</PRE><PRE>   /**
    * Construct Tabs instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Tabs(el, options) {
     _classCallCheck(this, Tabs);
</PRE><PRE>     var _this22 = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, Tabs, el, options));
</PRE><PRE>     _this22.el.M_Tabs = _this22;
</PRE><PRE>     /**
      * Options for the Tabs
      * @member Tabs#options
      * @prop {Number} duration
      * @prop {Function} onShow
      * @prop {Boolean} swipeable
      * @prop {Number} responsiveThreshold
      */
     _this22.options = $.extend({}, Tabs.defaults, options);
</PRE><PRE>     // Setup
     _this22.$tabLinks = _this22.$el.children('li.tab').children('a');
     _this22.index = 0;
     _this22._setupActiveTabLink();
</PRE><PRE>     // Setup tabs content
     if (_this22.options.swipeable) {
       _this22._setupSwipeableTabs();
     } else {
       _this22._setupNormalTabs();
     }
</PRE><PRE>     // Setup tabs indicator after content to ensure accurate widths
     _this22._setTabsAndTabWidth();
     _this22._createIndicator();
</PRE><PRE>     _this22._setupEventHandlers();
     return _this22;
   }
</PRE><PRE>   _createClass(Tabs, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this._indicator.parentNode.removeChild(this._indicator);
</PRE><PRE>       if (this.options.swipeable) {
         this._teardownSwipeableTabs();
       } else {
         this._teardownNormalTabs();
       }
</PRE><PRE>       this.$el[0].M_Tabs = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleWindowResizeBound = this._handleWindowResize.bind(this);
       window.addEventListener('resize', this._handleWindowResizeBound);
</PRE><PRE>       this._handleTabClickBound = this._handleTabClick.bind(this);
       this.el.addEventListener('click', this._handleTabClickBound);
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       window.removeEventListener('resize', this._handleWindowResizeBound);
       this.el.removeEventListener('click', this._handleTabClickBound);
     }
</PRE><PRE>     /**
      * Handle window Resize
      */
</PRE><PRE>   }, {
     key: &quot;_handleWindowResize&quot;,
     value: function _handleWindowResize() {
       this._setTabsAndTabWidth();
</PRE><PRE>       if (this.tabWidth !== 0 &amp;&amp; this.tabsWidth !== 0) {
         this._indicator.style.left = this._calcLeftPos(this.$activeTabLink) + 'px';
         this._indicator.style.right = this._calcRightPos(this.$activeTabLink) + 'px';
       }
     }
</PRE><PRE>     /**
      * Handle tab click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleTabClick&quot;,
     value: function _handleTabClick(e) {
       var _this23 = this;
</PRE><PRE>       var tab = $(e.target).closest('li.tab');
       var tabLink = $(e.target).closest('a');
</PRE><PRE>       // Handle click on tab link only
       if (!tabLink.length || !tabLink.parent().hasClass('tab')) {
         return;
       }
</PRE><PRE>       if (tab.hasClass('disabled')) {
         e.preventDefault();
         return;
       }
</PRE><PRE>       // Act as regular link if target attribute is specified.
       if (!!tabLink.attr('target')) {
         return;
       }
</PRE><PRE>       // Make the old tab inactive.
       this.$activeTabLink.removeClass('active');
       var $oldContent = this.$content;
</PRE><PRE>       // Update the variables with the new link and content
       this.$activeTabLink = tabLink;
       this.$content = $(M.escapeHash(tabLink[0].hash));
       this.$tabLinks = this.$el.children('li.tab').children('a');
</PRE><PRE>       // Make the tab active.
       this.$activeTabLink.addClass('active');
       var prevIndex = this.index;
       this.index = Math.max(this.$tabLinks.index(tabLink), 0);
</PRE><PRE>       // Swap content
       if (this.options.swipeable) {
         if (this._tabsCarousel) {
           this._tabsCarousel.set(this.index, function () {
             if (typeof _this23.options.onShow === 'function') {
               _this23.options.onShow.call(_this23, _this23.$content[0]);
             }
           });
         }
       } else {
         if (this.$content.length) {
           this.$content[0].style.display = 'block';
           this.$content.addClass('active');
           if (typeof this.options.onShow === 'function') {
             this.options.onShow.call(this, this.$content[0]);
           }
</PRE><PRE>           if ($oldContent.length &amp;&amp; !$oldContent.is(this.$content)) {
             $oldContent[0].style.display = 'none';
             $oldContent.removeClass('active');
           }
         }
       }
</PRE><PRE>       // Update widths after content is swapped (scrollbar bugfix)
       this._setTabsAndTabWidth();
</PRE><PRE>       // Update indicator
       this._animateIndicator(prevIndex);
</PRE><PRE>       // Prevent the anchor's default click action
       e.preventDefault();
     }
</PRE><PRE>     /**
      * Generate elements for tab indicator.
      */
</PRE><PRE>   }, {
     key: &quot;_createIndicator&quot;,
     value: function _createIndicator() {
       var _this24 = this;
</PRE><PRE>       var indicator = document.createElement('li');
       indicator.classList.add('indicator');
</PRE><PRE>       this.el.appendChild(indicator);
       this._indicator = indicator;
</PRE><PRE>       setTimeout(function () {
         _this24._indicator.style.left = _this24._calcLeftPos(_this24.$activeTabLink) + 'px';
         _this24._indicator.style.right = _this24._calcRightPos(_this24.$activeTabLink) + 'px';
       }, 0);
     }
</PRE><PRE>     /**
      * Setup first active tab link.
      */
</PRE><PRE>   }, {
     key: &quot;_setupActiveTabLink&quot;,
     value: function _setupActiveTabLink() {
       // If the location.hash matches one of the links, use that as the active tab.
       this.$activeTabLink = $(this.$tabLinks.filter('[href=&quot;' + location.hash + '&quot;]'));
</PRE><PRE>       // If no match is found, use the first link or any with class 'active' as the initial active tab.
       if (this.$activeTabLink.length === 0) {
         this.$activeTabLink = this.$el.children('li.tab').children('a.active').first();
       }
       if (this.$activeTabLink.length === 0) {
         this.$activeTabLink = this.$el.children('li.tab').children('a').first();
       }
</PRE><PRE>       this.$tabLinks.removeClass('active');
       this.$activeTabLink[0].classList.add('active');
</PRE><PRE>       this.index = Math.max(this.$tabLinks.index(this.$activeTabLink), 0);
</PRE><PRE>       if (this.$activeTabLink.length) {
         this.$content = $(M.escapeHash(this.$activeTabLink[0].hash));
         this.$content.addClass('active');
       }
     }
</PRE><PRE>     /**
      * Setup swipeable tabs
      */
</PRE><PRE>   }, {
     key: &quot;_setupSwipeableTabs&quot;,
     value: function _setupSwipeableTabs() {
       var _this25 = this;
</PRE><PRE>       // Change swipeable according to responsive threshold
       if (window.innerWidth &gt; this.options.responsiveThreshold) {
         this.options.swipeable = false;
       }
</PRE><PRE>       var $tabsContent = $();
       this.$tabLinks.each(function (link) {
         var $currContent = $(M.escapeHash(link.hash));
         $currContent.addClass('carousel-item');
         $tabsContent = $tabsContent.add($currContent);
       });
</PRE>
        var $tabsWrapper = $('');
<PRE>       $tabsContent.first().before($tabsWrapper);
       $tabsWrapper.append($tabsContent);
       $tabsContent[0].style.display = <I>;</I></PRE><PRE>       // Keep active tab index to set initial carousel slide
       var activeTabIndex = this.$activeTabLink.closest('.tab').index();
</PRE><PRE>       this._tabsCarousel = M.Carousel.init($tabsWrapper[0], {
         fullWidth: true,
         noWrap: true,
         onCycleTo: function (item) {
           var prevIndex = _this25.index;
           _this25.index = $(item).index();
           _this25.$activeTabLink.removeClass('active');
           _this25.$activeTabLink = _this25.$tabLinks.eq(_this25.index);
           _this25.$activeTabLink.addClass('active');
           _this25._animateIndicator(prevIndex);
           if (typeof _this25.options.onShow === 'function') {
             _this25.options.onShow.call(_this25, _this25.$content[0]);
           }
         }
       });
</PRE><PRE>       // Set initial carousel slide to active tab
       this._tabsCarousel.set(activeTabIndex);
     }
</PRE><PRE>     /**
      * Teardown normal tabs.
      */
</PRE><PRE>   }, {
     key: &quot;_teardownSwipeableTabs&quot;,
     value: function _teardownSwipeableTabs() {
       var $tabsWrapper = this._tabsCarousel.$el;
       this._tabsCarousel.destroy();
</PRE><PRE>       // Unwrap
       $tabsWrapper.after($tabsWrapper.children());
       $tabsWrapper.remove();
     }
</PRE><PRE>     /**
      * Setup normal tabs.
      */
</PRE><PRE>   }, {
     key: &quot;_setupNormalTabs&quot;,
     value: function _setupNormalTabs() {
       // Hide Tabs Content
       this.$tabLinks.not(this.$activeTabLink).each(function (link) {
         if (!!link.hash) {
           var $currContent = $(M.escapeHash(link.hash));
           if ($currContent.length) {
             $currContent[0].style.display = 'none';
           }
         }
       });
     }
</PRE><PRE>     /**
      * Teardown normal tabs.
      */
</PRE><PRE>   }, {
     key: &quot;_teardownNormalTabs&quot;,
     value: function _teardownNormalTabs() {
       // show Tabs Content
       this.$tabLinks.each(function (link) {
         if (!!link.hash) {
           var $currContent = $(M.escapeHash(link.hash));
           if ($currContent.length) {
             $currContent[0].style.display = <I>;</I>
           }
         }
       });
     }
</PRE><PRE>     /**
      * set tabs and tab width
      */
</PRE><PRE>   }, {
     key: &quot;_setTabsAndTabWidth&quot;,
     value: function _setTabsAndTabWidth() {
       this.tabsWidth = this.$el.width();
       this.tabWidth = Math.max(this.tabsWidth, this.el.scrollWidth) / this.$tabLinks.length;
     }
</PRE><PRE>     /**
      * Finds right attribute for indicator based on active tab.
      * @param {cash} el
      */
</PRE><PRE>   }, {
     key: &quot;_calcRightPos&quot;,
     value: function _calcRightPos(el) {
       return Math.ceil(this.tabsWidth - el.position().left - el[0].getBoundingClientRect().width);
     }
</PRE><PRE>     /**
      * Finds left attribute for indicator based on active tab.
      * @param {cash} el
      */
</PRE><PRE>   }, {
     key: &quot;_calcLeftPos&quot;,
     value: function _calcLeftPos(el) {
       return Math.floor(el.position().left);
     }
   }, {
     key: &quot;updateTabIndicator&quot;,
     value: function updateTabIndicator() {
       this._setTabsAndTabWidth();
       this._animateIndicator(this.index);
     }
</PRE><PRE>     /**
      * Animates Indicator to active tab.
      * @param {Number} prevIndex
      */
</PRE><PRE>   }, {
     key: &quot;_animateIndicator&quot;,
     value: function _animateIndicator(prevIndex) {
       var leftDelay = 0,
           rightDelay = 0;
</PRE><PRE>       if (this.index - prevIndex &gt;= 0) {
         leftDelay = 90;
       } else {
         rightDelay = 90;
       }
</PRE><PRE>       // Animate
       var animOptions = {
         targets: this._indicator,
         left: {
           value: this._calcLeftPos(this.$activeTabLink),
           delay: leftDelay
         },
         right: {
           value: this._calcRightPos(this.$activeTabLink),
           delay: rightDelay
         },
         duration: this.options.duration,
         easing: 'easeOutQuad'
       };
       anim.remove(this._indicator);
       anim(animOptions);
     }
</PRE><PRE>     /**
      * Select tab.
      * @param {String} tabId
      */
</PRE><PRE>   }, {
     key: &quot;select&quot;,
     value: function select(tabId) {
       var tab = this.$tabLinks.filter('[href=&quot;#' + tabId + '&quot;]');
       if (tab.length) {
         tab.trigger('click');
       }
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Tabs.__proto__ || Object.getPrototypeOf(Tabs), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Tabs;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Tabs;
 }(Component);
</PRE><PRE> M.Tabs = Tabs;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Tabs, 'tabs', 'M_Tabs');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   exitDelay: 200,
   enterDelay: 0,
   html: null,
   margin: 5,
   inDuration: 250,
   outDuration: 200,
   position: 'bottom',
   transitionMovement: 10
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Tooltip = function (_Component7) {
   _inherits(Tooltip, _Component7);
</PRE><PRE>   /**
    * Construct Tooltip instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Tooltip(el, options) {
     _classCallCheck(this, Tooltip);
</PRE><PRE>     var _this26 = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, Tooltip, el, options));
</PRE><PRE>     _this26.el.M_Tooltip = _this26;
     _this26.options = $.extend({}, Tooltip.defaults, options);
</PRE><PRE>     _this26.isOpen = false;
     _this26.isHovered = false;
     _this26.isFocused = false;
     _this26._appendTooltipEl();
     _this26._setupEventHandlers();
     return _this26;
   }
</PRE><PRE>   _createClass(Tooltip, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       $(this.tooltipEl).remove();
       this._removeEventHandlers();
       this.el.M_Tooltip = undefined;
     }
   }, {
     key: &quot;_appendTooltipEl&quot;,
     value: function _appendTooltipEl() {
       var tooltipEl = document.createElement('div');
       tooltipEl.classList.add('material-tooltip');
       this.tooltipEl = tooltipEl;
</PRE><PRE>       var tooltipContentEl = document.createElement('div');
       tooltipContentEl.classList.add('tooltip-content');
       tooltipContentEl.innerHTML = this.options.html;
       tooltipEl.appendChild(tooltipContentEl);
       document.body.appendChild(tooltipEl);
     }
   }, {
     key: &quot;_updateTooltipContent&quot;,
     value: function _updateTooltipContent() {
       this.tooltipEl.querySelector('.tooltip-content').innerHTML = this.options.html;
     }
   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleMouseEnterBound = this._handleMouseEnter.bind(this);
       this._handleMouseLeaveBound = this._handleMouseLeave.bind(this);
       this._handleFocusBound = this._handleFocus.bind(this);
       this._handleBlurBound = this._handleBlur.bind(this);
       this.el.addEventListener('mouseenter', this._handleMouseEnterBound);
       this.el.addEventListener('mouseleave', this._handleMouseLeaveBound);
       this.el.addEventListener('focus', this._handleFocusBound, true);
       this.el.addEventListener('blur', this._handleBlurBound, true);
     }
   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('mouseenter', this._handleMouseEnterBound);
       this.el.removeEventListener('mouseleave', this._handleMouseLeaveBound);
       this.el.removeEventListener('focus', this._handleFocusBound, true);
       this.el.removeEventListener('blur', this._handleBlurBound, true);
     }
   }, {
     key: &quot;open&quot;,
     value: function open(isManual) {
       if (this.isOpen) {
         return;
       }
       isManual = isManual === undefined ? true : undefined; // Default value true
       this.isOpen = true;
       // Update tooltip content with HTML attribute options
       this.options = $.extend({}, this.options, this._getAttributeOptions());
       this._updateTooltipContent();
       this._setEnterDelayTimeout(isManual);
     }
   }, {
     key: &quot;close&quot;,
     value: function close() {
       if (!this.isOpen) {
         return;
       }
</PRE><PRE>       this.isHovered = false;
       this.isFocused = false;
       this.isOpen = false;
       this._setExitDelayTimeout();
     }
</PRE><PRE>     /**
      * Create timeout which delays when the tooltip closes
      */
</PRE><PRE>   }, {
     key: &quot;_setExitDelayTimeout&quot;,
     value: function _setExitDelayTimeout() {
       var _this27 = this;
</PRE><PRE>       clearTimeout(this._exitDelayTimeout);
</PRE><PRE>       this._exitDelayTimeout = setTimeout(function () {
         if (_this27.isHovered || _this27.isFocused) {
           return;
         }
</PRE><PRE>         _this27._animateOut();
       }, this.options.exitDelay);
     }
</PRE><PRE>     /**
      * Create timeout which delays when the toast closes
      */
</PRE><PRE>   }, {
     key: &quot;_setEnterDelayTimeout&quot;,
     value: function _setEnterDelayTimeout(isManual) {
       var _this28 = this;
</PRE><PRE>       clearTimeout(this._enterDelayTimeout);
</PRE><PRE>       this._enterDelayTimeout = setTimeout(function () {
         if (!_this28.isHovered &amp;&amp; !_this28.isFocused &amp;&amp; !isManual) {
           return;
         }
</PRE><PRE>         _this28._animateIn();
       }, this.options.enterDelay);
     }
   }, {
     key: &quot;_positionTooltip&quot;,
     value: function _positionTooltip() {
       var origin = this.el,
           tooltip = this.tooltipEl,
           originHeight = origin.offsetHeight,
           originWidth = origin.offsetWidth,
           tooltipHeight = tooltip.offsetHeight,
           tooltipWidth = tooltip.offsetWidth,
           newCoordinates = void 0,
           margin = this.options.margin,
           targetTop = void 0,
           targetLeft = void 0;
</PRE><PRE>       this.xMovement = 0, this.yMovement = 0;
</PRE><PRE>       targetTop = origin.getBoundingClientRect().top + M.getDocumentScrollTop();
       targetLeft = origin.getBoundingClientRect().left + M.getDocumentScrollLeft();
</PRE><PRE>       if (this.options.position === 'top') {
         targetTop += -tooltipHeight - margin;
         targetLeft += originWidth / 2 - tooltipWidth / 2;
         this.yMovement = -this.options.transitionMovement;
       } else if (this.options.position === 'right') {
         targetTop += originHeight / 2 - tooltipHeight / 2;
         targetLeft += originWidth + margin;
         this.xMovement = this.options.transitionMovement;
       } else if (this.options.position === 'left') {
         targetTop += originHeight / 2 - tooltipHeight / 2;
         targetLeft += -tooltipWidth - margin;
         this.xMovement = -this.options.transitionMovement;
       } else {
         targetTop += originHeight + margin;
         targetLeft += originWidth / 2 - tooltipWidth / 2;
         this.yMovement = this.options.transitionMovement;
       }
</PRE><PRE>       newCoordinates = this._repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
       $(tooltip).css({
         top: newCoordinates.y + 'px',
         left: newCoordinates.x + 'px'
       });
     }
   }, {
     key: &quot;_repositionWithinScreen&quot;,
     value: function _repositionWithinScreen(x, y, width, height) {
       var scrollLeft = M.getDocumentScrollLeft();
       var scrollTop = M.getDocumentScrollTop();
       var newX = x - scrollLeft;
       var newY = y - scrollTop;
</PRE><PRE>       var bounding = {
         left: newX,
         top: newY,
         width: width,
         height: height
       };
</PRE><PRE>       var offset = this.options.margin + this.options.transitionMovement;
       var edges = M.checkWithinContainer(document.body, bounding, offset);
</PRE><PRE>       if (edges.left) {
         newX = offset;
       } else if (edges.right) {
         newX -= newX + width - window.innerWidth;
       }
</PRE><PRE>       if (edges.top) {
         newY = offset;
       } else if (edges.bottom) {
         newY -= newY + height - window.innerHeight;
       }
</PRE><PRE>       return {
         x: newX + scrollLeft,
         y: newY + scrollTop
       };
     }
   }, {
     key: &quot;_animateIn&quot;,
     value: function _animateIn() {
       this._positionTooltip();
       this.tooltipEl.style.visibility = 'visible';
       anim.remove(this.tooltipEl);
       anim({
         targets: this.tooltipEl,
         opacity: 1,
         translateX: this.xMovement,
         translateY: this.yMovement,
         duration: this.options.inDuration,
         easing: 'easeOutCubic'
       });
     }
   }, {
     key: &quot;_animateOut&quot;,
     value: function _animateOut() {
       anim.remove(this.tooltipEl);
       anim({
         targets: this.tooltipEl,
         opacity: 0,
         translateX: 0,
         translateY: 0,
         duration: this.options.outDuration,
         easing: 'easeOutCubic'
       });
     }
   }, {
     key: &quot;_handleMouseEnter&quot;,
     value: function _handleMouseEnter() {
       this.isHovered = true;
       this.isFocused = false; // Allows close of tooltip when opened by focus.
       this.open(false);
     }
   }, {
     key: &quot;_handleMouseLeave&quot;,
     value: function _handleMouseLeave() {
       this.isHovered = false;
       this.isFocused = false; // Allows close of tooltip when opened by focus.
       this.close();
     }
   }, {
     key: &quot;_handleFocus&quot;,
     value: function _handleFocus() {
       if (M.tabPressed) {
         this.isFocused = true;
         this.open(false);
       }
     }
   }, {
     key: &quot;_handleBlur&quot;,
     value: function _handleBlur() {
       this.isFocused = false;
       this.close();
     }
   }, {
     key: &quot;_getAttributeOptions&quot;,
     value: function _getAttributeOptions() {
       var attributeOptions = {};
       var tooltipTextOption = this.el.getAttribute('data-tooltip');
       var positionOption = this.el.getAttribute('data-position');
</PRE><PRE>       if (tooltipTextOption) {
         attributeOptions.html = tooltipTextOption;
       }
</PRE><PRE>       if (positionOption) {
         attributeOptions.position = positionOption;
       }
       return attributeOptions;
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Tooltip.__proto__ || Object.getPrototypeOf(Tooltip), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Tooltip;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Tooltip;
 }(Component);
</PRE><PRE> M.Tooltip = Tooltip;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Tooltip, 'tooltip', 'M_Tooltip');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT> /*!</DT></DL><PRE> * Waves v0.6.4
 * <A rel="nofollow" class="external free" href="http://fian.my.id/Waves">http://fian.my.id/Waves</A>
 *
 * Copyright 2014 Alfiana E. Sibuea and other contributors
 * Released under the MIT license
 * <A rel="nofollow" class="external free" href="https://github.com/fians/Waves/blob/master/LICENSE">https://github.com/fians/Waves/blob/master/LICENSE</A>
 */
</PRE><DL><DT>(function (window) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var Waves = Waves || {};
 var $$ = document.querySelectorAll.bind(document);
</PRE><PRE> // Find exact position of element
 function isWindow(obj) {
   return obj !== null &amp;&amp; obj === obj.window;
 }
</PRE><PRE> function getWindow(elem) {
   return isWindow(elem) ? elem : elem.nodeType === 9 &amp;&amp; elem.defaultView;
 }
</PRE><PRE> function offset(elem) {
   var docElem,
       win,
       box = { top: 0, left: 0 },
       doc = elem &amp;&amp; elem.ownerDocument;
</PRE><PRE>   docElem = doc.documentElement;
</PRE><PRE>   if (typeof elem.getBoundingClientRect !== typeof undefined) {
     box = elem.getBoundingClientRect();
   }
   win = getWindow(doc);
   return {
     top: box.top + win.pageYOffset - docElem.clientTop,
     left: box.left + win.pageXOffset - docElem.clientLeft
   };
 }
</PRE><PRE> function convertStyle(obj) {
   var style = <I>;</I></PRE><PRE>   for (var a in obj) {
     if (obj.hasOwnProperty(a)) {
       style += a + ':' + obj[a] + ';';
     }
   }
</PRE><PRE>   return style;
 }
</PRE><PRE> var Effect = {
</PRE><PRE>   // Effect delay
   duration: 750,
</PRE><PRE>   show: function (e, element) {
</PRE><PRE>     // Disable right click
     if (e.button === 2) {
       return false;
     }
</PRE><PRE>     var el = element || this;
</PRE><PRE>     // Create ripple
     var ripple = document.createElement('div');
     ripple.className = 'waves-ripple';
     el.appendChild(ripple);
</PRE><PRE>     // Get click coordinate and element witdh
     var pos = offset(el);
     var relativeY = e.pageY - pos.top;
     var relativeX = e.pageX - pos.left;
     var scale = 'scale(' + el.clientWidth / 100 * 10 + ')';
</PRE><PRE>     // Support for touch devices
     if ('touches' in e) {
       relativeY = e.touches[0].pageY - pos.top;
       relativeX = e.touches[0].pageX - pos.left;
     }
</PRE><PRE>     // Attach data to element
     ripple.setAttribute('data-hold', Date.now());
     ripple.setAttribute('data-scale', scale);
     ripple.setAttribute('data-x', relativeX);
     ripple.setAttribute('data-y', relativeY);
</PRE><PRE>     // Set ripple position
     var rippleStyle = {
       'top': relativeY + 'px',
       'left': relativeX + 'px'
     };
</PRE><PRE>     ripple.className = ripple.className + ' waves-notransition';
     ripple.setAttribute('style', convertStyle(rippleStyle));
     ripple.className = ripple.className.replace('waves-notransition', <I>);</I></PRE><PRE>     // Scale the ripple
     rippleStyle['-webkit-transform'] = scale;
     rippleStyle['-moz-transform'] = scale;
     rippleStyle['-ms-transform'] = scale;
     rippleStyle['-o-transform'] = scale;
     rippleStyle.transform = scale;
     rippleStyle.opacity = '1';
</PRE><PRE>     rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';
     rippleStyle['-moz-transition-duration'] = Effect.duration + 'ms';
     rippleStyle['-o-transition-duration'] = Effect.duration + 'ms';
     rippleStyle['transition-duration'] = Effect.duration + 'ms';
</PRE><PRE>     rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
     rippleStyle['-moz-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
     rippleStyle['-o-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
     rippleStyle['transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
</PRE><PRE>     ripple.setAttribute('style', convertStyle(rippleStyle));
   },
</PRE><PRE>   hide: function (e) {
     TouchHandler.touchup(e);
</PRE><PRE>     var el = this;
     var width = el.clientWidth * 1.4;
</PRE><PRE>     // Get first ripple
     var ripple = null;
     var ripples = el.getElementsByClassName('waves-ripple');
     if (ripples.length &gt; 0) {
       ripple = ripples[ripples.length - 1];
     } else {
       return false;
     }
</PRE><PRE>     var relativeX = ripple.getAttribute('data-x');
     var relativeY = ripple.getAttribute('data-y');
     var scale = ripple.getAttribute('data-scale');
</PRE><PRE>     // Get delay beetween mousedown and mouse leave
     var diff = Date.now() - Number(ripple.getAttribute('data-hold'));
     var delay = 350 - diff;
</PRE><PRE>     if (delay &lt; 0) {
       delay = 0;
     }
</PRE><PRE>     // Fade out ripple after delay
     setTimeout(function () {
       var style = {
         'top': relativeY + 'px',
         'left': relativeX + 'px',
         'opacity': '0',
</PRE><PRE>         // Duration
         '-webkit-transition-duration': Effect.duration + 'ms',
         '-moz-transition-duration': Effect.duration + 'ms',
         '-o-transition-duration': Effect.duration + 'ms',
         'transition-duration': Effect.duration + 'ms',
         '-webkit-transform': scale,
         '-moz-transform': scale,
         '-ms-transform': scale,
         '-o-transform': scale,
         'transform': scale
       };
</PRE><PRE>       ripple.setAttribute('style', convertStyle(style));
</PRE><PRE>       setTimeout(function () {
         try {
           el.removeChild(ripple);
         } catch (e) {
           return false;
         }
       }, Effect.duration);
     }, delay);
   },
</PRE><PRE>   // Little hack to make &lt;input&gt; can perform waves effect
   wrapInput: function (elements) {
     for (var a = 0; a &lt; elements.length; a++) {
       var el = elements[a];
</PRE><PRE>       if (el.tagName.toLowerCase() === 'input') {
         var parent = el.parentNode;
</PRE><PRE>         // If input already have parent just pass through
         if (parent.tagName.toLowerCase() === 'i' &amp;&amp; parent.className.indexOf('waves-effect') !== -1) {
           continue;
         }
</PRE><PRE>         // Put element class and style to the specified parent
         var wrapper = document.createElement('i');
         wrapper.className = el.className + ' waves-input-wrapper';
</PRE><PRE>         var elementStyle = el.getAttribute('style');
</PRE><PRE>         if (!elementStyle) {
           elementStyle = <I>;</I>
         }
</PRE><PRE>         wrapper.setAttribute('style', elementStyle);
</PRE><PRE>         el.className = 'waves-button-input';
         el.removeAttribute('style');
</PRE><PRE>         // Put element as child
         parent.replaceChild(wrapper, el);
         wrapper.appendChild(el);
       }
     }
   }
 };
</PRE><PRE> /**
  * Disable mousedown event for 500ms during and after touch
  */
 var TouchHandler = {
   /* uses an integer rather than bool so there's no issues with
    * needing to clear timeouts if another touch event occurred
    * within the 500ms. Cannot mouseup between touchstart and
    * touchend, nor in the 500ms after touchend. */
   touches: 0,
   allowEvent: function (e) {
     var allow = true;
</PRE><PRE>     if (e.type === 'touchstart') {
       TouchHandler.touches += 1; //push
     } else if (e.type === 'touchend' || e.type === 'touchcancel') {
       setTimeout(function () {
         if (TouchHandler.touches &gt; 0) {
           TouchHandler.touches -= 1; //pop after 500ms
         }
       }, 500);
     } else if (e.type === 'mousedown' &amp;&amp; TouchHandler.touches &gt; 0) {
       allow = false;
     }
</PRE><PRE>     return allow;
   },
   touchup: function (e) {
     TouchHandler.allowEvent(e);
   }
 };
</PRE><PRE> /**
  * Delegated click handler for .waves-effect element.
  * returns null when .waves-effect element not in &quot;click tree&quot;
  */
 function getWavesEffectElement(e) {
   if (TouchHandler.allowEvent(e) === false) {
     return null;
   }
</PRE><PRE>   var element = null;
   var target = e.target || e.srcElement;
</PRE><PRE>   while (target.parentNode !== null) {
     if (!(target instanceof SVGElement) &amp;&amp; target.className.indexOf('waves-effect') !== -1) {
       element = target;
       break;
     }
     target = target.parentNode;
   }
   return element;
 }
</PRE><PRE> /**
  * Bubble the click and show effect if .waves-effect elem was found
  */
 function showEffect(e) {
   var element = getWavesEffectElement(e);
</PRE><PRE>   if (element !== null) {
     Effect.show(e, element);
</PRE><PRE>     if ('ontouchstart' in window) {
       element.addEventListener('touchend', Effect.hide, false);
       element.addEventListener('touchcancel', Effect.hide, false);
     }
</PRE><PRE>     element.addEventListener('mouseup', Effect.hide, false);
     element.addEventListener('mouseleave', Effect.hide, false);
     element.addEventListener('dragend', Effect.hide, false);
   }
 }
</PRE><PRE> Waves.displayEffect = function (options) {
   options = options || {};
</PRE><PRE>   if ('duration' in options) {
     Effect.duration = options.duration;
   }
</PRE><PRE>   //Wrap input inside <I> tag
   Effect.wrapInput($$('.waves-effect'));
</I></PRE><PRE>   if ('ontouchstart' in window) {
     document.body.addEventListener('touchstart', showEffect, false);
   }
</PRE><PRE>   document.body.addEventListener('mousedown', showEffect, false);
 };
</PRE><PRE> /**
  * Attach Waves to an input element (or any element which doesn't
  * bubble mouseup/mousedown events).
  *   Intended to be used with dynamically loaded forms/inputs, or
  * where the user doesn't want a delegated click handler.
  */
 Waves.attach = function (element) {
   //FUTURE: automatically add waves classes and allow users
   // to specify them with an options param? Eg. light/classic/button
   if (element.tagName.toLowerCase() === 'input') {
     Effect.wrapInput([element]);
     element = element.parentNode;
   }
</PRE><PRE>   if ('ontouchstart' in window) {
     element.addEventListener('touchstart', showEffect, false);
   }
</PRE><PRE>   element.addEventListener('mousedown', showEffect, false);
 };
</PRE><PRE> window.Waves = Waves;
</PRE><PRE> document.addEventListener('DOMContentLoaded', function () {
   Waves.displayEffect();
 }, false);
</PRE><P>})(window);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   html: <I>,</I>
   displayLength: 4000,
   inDuration: 300,
   outDuration: 375,
   classes: <I>,</I>completeCallback: null,
   activationPercent: 0.8
 };
</PRE><PRE> var Toast = function () {
   function Toast(options) {
     _classCallCheck(this, Toast);
</PRE><PRE>     /**
      * Options for the toast
      * @member Toast#options
      */
     this.options = $.extend({}, Toast.defaults, options);
     this.message = this.options.html;
</PRE><PRE>     /**
      * Describes current pan state toast
      * @type {Boolean}
      */
     this.panning = false;
</PRE><PRE>     /**
      * Time remaining until toast is removed
      */
     this.timeRemaining = this.options.displayLength;
</PRE><PRE>     if (Toast._toasts.length === 0) {
       Toast._createContainer();
     }
</PRE><PRE>     // Create new toast
     Toast._toasts.push(this);
     var toastElement = this._createToast();
     toastElement.M_Toast = this;
     this.el = toastElement;
     this.$el = $(toastElement);
     this._animateIn();
     this._setTimer();
   }
</PRE><PRE>   _createClass(Toast, [{
     key: &quot;_createToast&quot;,
</PRE><PRE>     /**
      * Create toast and append it to toast container
      */
     value: function _createToast() {
       var toast = document.createElement('div');
       toast.classList.add('toast');
</PRE><PRE>       // Add custom classes onto toast
       if (!!this.options.classes.length) {
         $(toast).addClass(this.options.classes);
       }
</PRE><PRE>       // Set content
       if (typeof HTMLElement === 'object' ? this.message instanceof HTMLElement : this.message &amp;&amp; typeof this.message === 'object' &amp;&amp; this.message !== null &amp;&amp; this.message.nodeType === 1 &amp;&amp; typeof this.message.nodeName === 'string') {
         toast.appendChild(this.message);
</PRE><PRE>         // Check if it is jQuery object
       } else if (!!this.message.jquery) {
         $(toast).append(this.message[0]);
</PRE><PRE>         // Insert as html;
       } else {
         toast.innerHTML = this.message;
       }
</PRE><PRE>       // Append toasft
       Toast._container.appendChild(toast);
       return toast;
     }
</PRE><PRE>     /**
      * Animate in toast
      */
</PRE><PRE>   }, {
     key: &quot;_animateIn&quot;,
     value: function _animateIn() {
       // Animate toast in
       anim({
         targets: this.el,
         top: 0,
         opacity: 1,
         duration: this.options.inDuration,
         easing: 'easeOutCubic'
       });
     }
</PRE><PRE>     /**
      * Create setInterval which automatically removes toast when timeRemaining &gt;= 0
      * has been reached
      */
</PRE><PRE>   }, {
     key: &quot;_setTimer&quot;,
     value: function _setTimer() {
       var _this29 = this;
</PRE><PRE>       if (this.timeRemaining !== Infinity) {
         this.counterInterval = setInterval(function () {
           // If toast is not being dragged, decrease its time remaining
           if (!_this29.panning) {
             _this29.timeRemaining -= 20;
           }
</PRE><PRE>           // Animate toast out
           if (_this29.timeRemaining &lt;= 0) {
             _this29.dismiss();
           }
         }, 20);
       }
     }
</PRE><PRE>     /**
      * Dismiss toast with animation
      */
</PRE><PRE>   }, {
     key: &quot;dismiss&quot;,
     value: function dismiss() {
       var _this30 = this;
</PRE><PRE>       window.clearInterval(this.counterInterval);
       var activationDistance = this.el.offsetWidth * this.options.activationPercent;
</PRE><PRE>       if (this.wasSwiped) {
         this.el.style.transition = 'transform .05s, opacity .05s';
         this.el.style.transform = &quot;translateX(&quot; + activationDistance + &quot;px)&quot;;
         this.el.style.opacity = 0;
       }
</PRE><PRE>       anim({
         targets: this.el,
         opacity: 0,
         marginTop: -40,
         duration: this.options.outDuration,
         easing: 'easeOutExpo',
         complete: function () {
           // Call the optional callback
           if (typeof _this30.options.completeCallback === 'function') {
             _this30.options.completeCallback();
           }
           // Remove toast from DOM
           _this30.$el.remove();
           Toast._toasts.splice(Toast._toasts.indexOf(_this30), 1);
           if (Toast._toasts.length === 0) {
             Toast._removeContainer();
           }
         }
       });
     }
   }], [{
     key: &quot;getInstance&quot;,
</PRE><PRE>     /**
      * Get Instance
      */
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Toast;
     }
</PRE><PRE>     /**
      * Append toast container and add event handlers
      */
</PRE><PRE>   }, {
     key: &quot;_createContainer&quot;,
     value: function _createContainer() {
       var container = document.createElement('div');
       container.setAttribute('id', 'toast-container');
</PRE><PRE>       // Add event handler
       container.addEventListener('touchstart', Toast._onDragStart);
       container.addEventListener('touchmove', Toast._onDragMove);
       container.addEventListener('touchend', Toast._onDragEnd);
</PRE><PRE>       container.addEventListener('mousedown', Toast._onDragStart);
       document.addEventListener('mousemove', Toast._onDragMove);
       document.addEventListener('mouseup', Toast._onDragEnd);
</PRE><PRE>       document.body.appendChild(container);
       Toast._container = container;
     }
</PRE><PRE>     /**
      * Remove toast container and event handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeContainer&quot;,
     value: function _removeContainer() {
       // Add event handler
       document.removeEventListener('mousemove', Toast._onDragMove);
       document.removeEventListener('mouseup', Toast._onDragEnd);
</PRE><PRE>       $(Toast._container).remove();
       Toast._container = null;
     }
</PRE><PRE>     /**
      * Begin drag handler
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_onDragStart&quot;,
     value: function _onDragStart(e) {
       if (e.target &amp;&amp; $(e.target).closest('.toast').length) {
         var $toast = $(e.target).closest('.toast');
         var toast = $toast[0].M_Toast;
         toast.panning = true;
         Toast._draggedToast = toast;
         toast.el.classList.add('panning');
         toast.el.style.transition = <I>;</I>
         toast.startingXPos = Toast._xPos(e);
         toast.time = Date.now();
         toast.xPos = Toast._xPos(e);
       }
     }
</PRE><PRE>     /**
      * Drag move handler
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_onDragMove&quot;,
     value: function _onDragMove(e) {
       if (!!Toast._draggedToast) {
         e.preventDefault();
         var toast = Toast._draggedToast;
         toast.deltaX = Math.abs(toast.xPos - Toast._xPos(e));
         toast.xPos = Toast._xPos(e);
         toast.velocityX = toast.deltaX / (Date.now() - toast.time);
         toast.time = Date.now();
</PRE><PRE>         var totalDeltaX = toast.xPos - toast.startingXPos;
         var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;
         toast.el.style.transform = &quot;translateX(&quot; + totalDeltaX + &quot;px)&quot;;
         toast.el.style.opacity = 1 - Math.abs(totalDeltaX / activationDistance);
       }
     }
</PRE><PRE>     /**
      * End drag handler
      */
</PRE><PRE>   }, {
     key: &quot;_onDragEnd&quot;,
     value: function _onDragEnd() {
       if (!!Toast._draggedToast) {
         var toast = Toast._draggedToast;
         toast.panning = false;
         toast.el.classList.remove('panning');
</PRE><PRE>         var totalDeltaX = toast.xPos - toast.startingXPos;
         var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;
         var shouldBeDismissed = Math.abs(totalDeltaX) &gt; activationDistance || toast.velocityX &gt; 1;
</PRE><PRE>         // Remove toast
         if (shouldBeDismissed) {
           toast.wasSwiped = true;
           toast.dismiss();
</PRE><PRE>           // Animate toast back to original position
         } else {
           toast.el.style.transition = 'transform .2s, opacity .2s';
           toast.el.style.transform = <I>;</I>
           toast.el.style.opacity = <I>;</I>
         }
         Toast._draggedToast = null;
       }
     }
</PRE><PRE>     /**
      * Get x position of mouse or touch event
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_xPos&quot;,
     value: function _xPos(e) {
       if (e.targetTouches &amp;&amp; e.targetTouches.length &gt;= 1) {
         return e.targetTouches[0].clientX;
       }
       // mouse event
       return e.clientX;
     }
</PRE><PRE>     /**
      * Remove all toasts
      */
</PRE><PRE>   }, {
     key: &quot;dismissAll&quot;,
     value: function dismissAll() {
       for (var toastIndex in Toast._toasts) {
         Toast._toasts[toastIndex].dismiss();
       }
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Toast;
 }();
</PRE><PRE> /**
  * @static
  * @memberof Toast
  * @type {Array.&lt;Toast&gt;}
  */
</PRE><PRE> Toast._toasts = [];
</PRE><PRE> /**
  * @static
  * @memberof Toast
  */
 Toast._container = null;
</PRE><PRE> /**
  * @static
  * @memberof Toast
  * @type {Toast}
  */
 Toast._draggedToast = null;
</PRE><PRE> M.Toast = Toast;
 M.toast = function (options) {
   return new Toast(options);
 };
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   edge: 'left',
   draggable: true,
   inDuration: 250,
   outDuration: 200,
   onOpenStart: null,
   onOpenEnd: null,
   onCloseStart: null,
   onCloseEnd: null,
   preventScrolling: true
 };
</PRE><PRE> /**
  * @class
  */
</PRE><PRE> var Sidenav = function (_Component8) {
   _inherits(Sidenav, _Component8);
</PRE><PRE>   /**
    * Construct Sidenav instance and set up overlay
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Sidenav(el, options) {
     _classCallCheck(this, Sidenav);
</PRE><PRE>     var _this31 = _possibleConstructorReturn(this, (Sidenav.__proto__ || Object.getPrototypeOf(Sidenav)).call(this, Sidenav, el, options));
</PRE><PRE>     _this31.el.M_Sidenav = _this31;
     _this31.id = _this31.$el.attr('id');
</PRE><PRE>     /**
      * Options for the Sidenav
      * @member Sidenav#options
      * @prop {String} [edge='left'] - Side of screen on which Sidenav appears
      * @prop {Boolean} [draggable=true] - Allow swipe gestures to open/close Sidenav
      * @prop {Number} [inDuration=250] - Length in ms of enter transition
      * @prop {Number} [outDuration=200] - Length in ms of exit transition
      * @prop {Function} onOpenStart - Function called when sidenav starts entering
      * @prop {Function} onOpenEnd - Function called when sidenav finishes entering
      * @prop {Function} onCloseStart - Function called when sidenav starts exiting
      * @prop {Function} onCloseEnd - Function called when sidenav finishes exiting
      */
     _this31.options = $.extend({}, Sidenav.defaults, options);
</PRE><PRE>     /**
      * Describes open/close state of Sidenav
      * @type {Boolean}
      */
     _this31.isOpen = false;
</PRE><PRE>     /**
      * Describes if Sidenav is fixed
      * @type {Boolean}
      */
     _this31.isFixed = _this31.el.classList.contains('sidenav-fixed');
</PRE><PRE>     /**
      * Describes if Sidenav is being draggeed
      * @type {Boolean}
      */
     _this31.isDragged = false;
</PRE><PRE>     // Window size variables for window resize checks
     _this31.lastWindowWidth = window.innerWidth;
     _this31.lastWindowHeight = window.innerHeight;
</PRE><PRE>     _this31._createOverlay();
     _this31._createDragTarget();
     _this31._setupEventHandlers();
     _this31._setupClasses();
     _this31._setupFixed();
</PRE><PRE>     Sidenav._sidenavs.push(_this31);
     return _this31;
   }
</PRE><PRE>   _createClass(Sidenav, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this._enableBodyScrolling();
       this._overlay.parentNode.removeChild(this._overlay);
       this.dragTarget.parentNode.removeChild(this.dragTarget);
       this.el.M_Sidenav = undefined;
       this.el.style.transform = <I>;</I></PRE><PRE>       var index = Sidenav._sidenavs.indexOf(this);
       if (index &gt;= 0) {
         Sidenav._sidenavs.splice(index, 1);
       }
     }
   }, {
     key: &quot;_createOverlay&quot;,
     value: function _createOverlay() {
       var overlay = document.createElement('div');
       this._closeBound = this.close.bind(this);
       overlay.classList.add('sidenav-overlay');
</PRE><PRE>       overlay.addEventListener('click', this._closeBound);
</PRE><PRE>       document.body.appendChild(overlay);
       this._overlay = overlay;
     }
   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       if (Sidenav._sidenavs.length === 0) {
         document.body.addEventListener('click', this._handleTriggerClick);
       }
</PRE><PRE>       this._handleDragTargetDragBound = this._handleDragTargetDrag.bind(this);
       this._handleDragTargetReleaseBound = this._handleDragTargetRelease.bind(this);
       this._handleCloseDragBound = this._handleCloseDrag.bind(this);
       this._handleCloseReleaseBound = this._handleCloseRelease.bind(this);
       this._handleCloseTriggerClickBound = this._handleCloseTriggerClick.bind(this);
</PRE><PRE>       this.dragTarget.addEventListener('touchmove', this._handleDragTargetDragBound);
       this.dragTarget.addEventListener('touchend', this._handleDragTargetReleaseBound);
       this._overlay.addEventListener('touchmove', this._handleCloseDragBound);
       this._overlay.addEventListener('touchend', this._handleCloseReleaseBound);
       this.el.addEventListener('touchmove', this._handleCloseDragBound);
       this.el.addEventListener('touchend', this._handleCloseReleaseBound);
       this.el.addEventListener('click', this._handleCloseTriggerClickBound);
</PRE><PRE>       // Add resize for side nav fixed
       if (this.isFixed) {
         this._handleWindowResizeBound = this._handleWindowResize.bind(this);
         window.addEventListener('resize', this._handleWindowResizeBound);
       }
     }
   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       if (Sidenav._sidenavs.length === 1) {
         document.body.removeEventListener('click', this._handleTriggerClick);
       }
</PRE><PRE>       this.dragTarget.removeEventListener('touchmove', this._handleDragTargetDragBound);
       this.dragTarget.removeEventListener('touchend', this._handleDragTargetReleaseBound);
       this._overlay.removeEventListener('touchmove', this._handleCloseDragBound);
       this._overlay.removeEventListener('touchend', this._handleCloseReleaseBound);
       this.el.removeEventListener('touchmove', this._handleCloseDragBound);
       this.el.removeEventListener('touchend', this._handleCloseReleaseBound);
       this.el.removeEventListener('click', this._handleCloseTriggerClickBound);
</PRE><PRE>       // Remove resize for side nav fixed
       if (this.isFixed) {
         window.removeEventListener('resize', this._handleWindowResizeBound);
       }
     }
</PRE><PRE>     /**
      * Handle Trigger Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleTriggerClick&quot;,
     value: function _handleTriggerClick(e) {
       var $trigger = $(e.target).closest('.sidenav-trigger');
       if (e.target &amp;&amp; $trigger.length) {
         var sidenavId = M.getIdFromTrigger($trigger[0]);
</PRE><PRE>         var sidenavInstance = document.getElementById(sidenavId).M_Sidenav;
         if (sidenavInstance) {
           sidenavInstance.open($trigger);
         }
         e.preventDefault();
       }
     }
</PRE><PRE>     /**
      * Set variables needed at the beggining of drag
      * and stop any current transition.
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_startDrag&quot;,
     value: function _startDrag(e) {
       var clientX = e.targetTouches[0].clientX;
       this.isDragged = true;
       this._startingXpos = clientX;
       this._xPos = this._startingXpos;
       this._time = Date.now();
       this._width = this.el.getBoundingClientRect().width;
       this._overlay.style.display = 'block';
       this._initialScrollTop = this.isOpen ? this.el.scrollTop : M.getDocumentScrollTop();
       this._verticallyScrolling = false;
       anim.remove(this.el);
       anim.remove(this._overlay);
     }
</PRE><PRE>     /**
      * Set variables needed at each drag move update tick
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_dragMoveUpdate&quot;,
     value: function _dragMoveUpdate(e) {
       var clientX = e.targetTouches[0].clientX;
       var currentScrollTop = this.isOpen ? this.el.scrollTop : M.getDocumentScrollTop();
       this.deltaX = Math.abs(this._xPos - clientX);
       this._xPos = clientX;
       this.velocityX = this.deltaX / (Date.now() - this._time);
       this._time = Date.now();
       if (this._initialScrollTop !== currentScrollTop) {
         this._verticallyScrolling = true;
       }
     }
</PRE><PRE>     /**
      * Handles Dragging of Sidenav
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleDragTargetDrag&quot;,
     value: function _handleDragTargetDrag(e) {
       // Check if draggable
       if (!this.options.draggable || this._isCurrentlyFixed() || this._verticallyScrolling) {
         return;
       }
</PRE><PRE>       // If not being dragged, set initial drag start variables
       if (!this.isDragged) {
         this._startDrag(e);
       }
</PRE><PRE>       // Run touchmove updates
       this._dragMoveUpdate(e);
</PRE><PRE>       // Calculate raw deltaX
       var totalDeltaX = this._xPos - this._startingXpos;
</PRE><PRE>       // dragDirection is the attempted user drag direction
       var dragDirection = totalDeltaX &gt; 0 ? 'right' : 'left';
</PRE><PRE>       // Don't allow totalDeltaX to exceed Sidenav width or be dragged in the opposite direction
       totalDeltaX = Math.min(this._width, Math.abs(totalDeltaX));
       if (this.options.edge === dragDirection) {
         totalDeltaX = 0;
       }
</PRE><PRE>       /**
        * transformX is the drag displacement
        * transformPrefix is the initial transform placement
        * Invert values if Sidenav is right edge
        */
       var transformX = totalDeltaX;
       var transformPrefix = 'translateX(-100%)';
       if (this.options.edge === 'right') {
         transformPrefix = 'translateX(100%)';
         transformX = -transformX;
       }
</PRE><PRE>       // Calculate open/close percentage of sidenav, with open = 1 and close = 0
       this.percentOpen = Math.min(1, totalDeltaX / this._width);
</PRE><PRE>       // Set transform and opacity styles
       this.el.style.transform = transformPrefix + &quot; translateX(&quot; + transformX + &quot;px)&quot;;
       this._overlay.style.opacity = this.percentOpen;
     }
</PRE><PRE>     /**
      * Handle Drag Target Release
      */
</PRE><PRE>   }, {
     key: &quot;_handleDragTargetRelease&quot;,
     value: function _handleDragTargetRelease() {
       if (this.isDragged) {
         if (this.percentOpen &gt; 0.2) {
           this.open();
         } else {
           this._animateOut();
         }
</PRE><PRE>         this.isDragged = false;
         this._verticallyScrolling = false;
       }
     }
</PRE><PRE>     /**
      * Handle Close Drag
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleCloseDrag&quot;,
     value: function _handleCloseDrag(e) {
       if (this.isOpen) {
         // Check if draggable
         if (!this.options.draggable || this._isCurrentlyFixed() || this._verticallyScrolling) {
           return;
         }
</PRE><PRE>         // If not being dragged, set initial drag start variables
         if (!this.isDragged) {
           this._startDrag(e);
         }
</PRE><PRE>         // Run touchmove updates
         this._dragMoveUpdate(e);
</PRE><PRE>         // Calculate raw deltaX
         var totalDeltaX = this._xPos - this._startingXpos;
</PRE><PRE>         // dragDirection is the attempted user drag direction
         var dragDirection = totalDeltaX &gt; 0 ? 'right' : 'left';
</PRE><PRE>         // Don't allow totalDeltaX to exceed Sidenav width or be dragged in the opposite direction
         totalDeltaX = Math.min(this._width, Math.abs(totalDeltaX));
         if (this.options.edge !== dragDirection) {
           totalDeltaX = 0;
         }
</PRE><PRE>         var transformX = -totalDeltaX;
         if (this.options.edge === 'right') {
           transformX = -transformX;
         }
</PRE><PRE>         // Calculate open/close percentage of sidenav, with open = 1 and close = 0
         this.percentOpen = Math.min(1, 1 - totalDeltaX / this._width);
</PRE><PRE>         // Set transform and opacity styles
         this.el.style.transform = &quot;translateX(&quot; + transformX + &quot;px)&quot;;
         this._overlay.style.opacity = this.percentOpen;
       }
     }
</PRE><PRE>     /**
      * Handle Close Release
      */
</PRE><PRE>   }, {
     key: &quot;_handleCloseRelease&quot;,
     value: function _handleCloseRelease() {
       if (this.isOpen &amp;&amp; this.isDragged) {
         if (this.percentOpen &gt; 0.8) {
           this._animateIn();
         } else {
           this.close();
         }
</PRE><PRE>         this.isDragged = false;
         this._verticallyScrolling = false;
       }
     }
</PRE><PRE>     /**
      * Handles closing of Sidenav when element with class .sidenav-close
      */
</PRE><PRE>   }, {
     key: &quot;_handleCloseTriggerClick&quot;,
     value: function _handleCloseTriggerClick(e) {
       var $closeTrigger = $(e.target).closest('.sidenav-close');
       if ($closeTrigger.length &amp;&amp; !this._isCurrentlyFixed()) {
         this.close();
       }
     }
</PRE><PRE>     /**
      * Handle Window Resize
      */
</PRE><PRE>   }, {
     key: &quot;_handleWindowResize&quot;,
     value: function _handleWindowResize() {
       // Only handle horizontal resizes
       if (this.lastWindowWidth !== window.innerWidth) {
         if (window.innerWidth &gt; 992) {
           this.open();
         } else {
           this.close();
         }
       }
</PRE><PRE>       this.lastWindowWidth = window.innerWidth;
       this.lastWindowHeight = window.innerHeight;
     }
   }, {
     key: &quot;_setupClasses&quot;,
     value: function _setupClasses() {
       if (this.options.edge === 'right') {
         this.el.classList.add('right-aligned');
         this.dragTarget.classList.add('right-aligned');
       }
     }
   }, {
     key: &quot;_removeClasses&quot;,
     value: function _removeClasses() {
       this.el.classList.remove('right-aligned');
       this.dragTarget.classList.remove('right-aligned');
     }
   }, {
     key: &quot;_setupFixed&quot;,
     value: function _setupFixed() {
       if (this._isCurrentlyFixed()) {
         this.open();
       }
     }
   }, {
     key: &quot;_isCurrentlyFixed&quot;,
     value: function _isCurrentlyFixed() {
       return this.isFixed &amp;&amp; window.innerWidth &gt; 992;
     }
   }, {
     key: &quot;_createDragTarget&quot;,
     value: function _createDragTarget() {
       var dragTarget = document.createElement('div');
       dragTarget.classList.add('drag-target');
       document.body.appendChild(dragTarget);
       this.dragTarget = dragTarget;
     }
   }, {
     key: &quot;_preventBodyScrolling&quot;,
     value: function _preventBodyScrolling() {
       var body = document.body;
       body.style.overflow = 'hidden';
     }
   }, {
     key: &quot;_enableBodyScrolling&quot;,
     value: function _enableBodyScrolling() {
       var body = document.body;
       body.style.overflow = <I>;</I>
     }
   }, {
     key: &quot;open&quot;,
     value: function open() {
       if (this.isOpen === true) {
         return;
       }
</PRE><PRE>       this.isOpen = true;
</PRE><PRE>       // Run onOpenStart callback
       if (typeof this.options.onOpenStart === 'function') {
         this.options.onOpenStart.call(this, this.el);
       }
</PRE><PRE>       // Handle fixed Sidenav
       if (this._isCurrentlyFixed()) {
         anim.remove(this.el);
         anim({
           targets: this.el,
           translateX: 0,
           duration: 0,
           easing: 'easeOutQuad'
         });
         this._enableBodyScrolling();
         this._overlay.style.display = 'none';
</PRE><PRE>         // Handle non-fixed Sidenav
       } else {
         if (this.options.preventScrolling) {
           this._preventBodyScrolling();
         }
</PRE><PRE>         if (!this.isDragged || this.percentOpen != 1) {
           this._animateIn();
         }
       }
     }
   }, {
     key: &quot;close&quot;,
     value: function close() {
       if (this.isOpen === false) {
         return;
       }
</PRE><PRE>       this.isOpen = false;
</PRE><PRE>       // Run onCloseStart callback
       if (typeof this.options.onCloseStart === 'function') {
         this.options.onCloseStart.call(this, this.el);
       }
</PRE><PRE>       // Handle fixed Sidenav
       if (this._isCurrentlyFixed()) {
         var transformX = this.options.edge === 'left' ? '-105%' : '105%';
         this.el.style.transform = &quot;translateX(&quot; + transformX + &quot;)&quot;;
</PRE><PRE>         // Handle non-fixed Sidenav
       } else {
         this._enableBodyScrolling();
</PRE><PRE>         if (!this.isDragged || this.percentOpen != 0) {
           this._animateOut();
         } else {
           this._overlay.style.display = 'none';
         }
       }
     }
   }, {
     key: &quot;_animateIn&quot;,
     value: function _animateIn() {
       this._animateSidenavIn();
       this._animateOverlayIn();
     }
   }, {
     key: &quot;_animateSidenavIn&quot;,
     value: function _animateSidenavIn() {
       var _this32 = this;
</PRE><PRE>       var slideOutPercent = this.options.edge === 'left' ? -1 : 1;
       if (this.isDragged) {
         slideOutPercent = this.options.edge === 'left' ? slideOutPercent + this.percentOpen : slideOutPercent - this.percentOpen;
       }
</PRE><PRE>       anim.remove(this.el);
       anim({
         targets: this.el,
         translateX: [slideOutPercent * 100 + &quot;%&quot;, 0],
         duration: this.options.inDuration,
         easing: 'easeOutQuad',
         complete: function () {
           // Run onOpenEnd callback
           if (typeof _this32.options.onOpenEnd === 'function') {
             _this32.options.onOpenEnd.call(_this32, _this32.el);
           }
         }
       });
     }
   }, {
     key: &quot;_animateOverlayIn&quot;,
     value: function _animateOverlayIn() {
       var start = 0;
       if (this.isDragged) {
         start = this.percentOpen;
       } else {
         $(this._overlay).css({
           display: 'block'
         });
       }
</PRE><PRE>       anim.remove(this._overlay);
       anim({
         targets: this._overlay,
         opacity: [start, 1],
         duration: this.options.inDuration,
         easing: 'easeOutQuad'
       });
     }
   }, {
     key: &quot;_animateOut&quot;,
     value: function _animateOut() {
       this._animateSidenavOut();
       this._animateOverlayOut();
     }
   }, {
     key: &quot;_animateSidenavOut&quot;,
     value: function _animateSidenavOut() {
       var _this33 = this;
</PRE><PRE>       var endPercent = this.options.edge === 'left' ? -1 : 1;
       var slideOutPercent = 0;
       if (this.isDragged) {
         slideOutPercent = this.options.edge === 'left' ? endPercent + this.percentOpen : endPercent - this.percentOpen;
       }
</PRE><PRE>       anim.remove(this.el);
       anim({
         targets: this.el,
         translateX: [slideOutPercent * 100 + &quot;%&quot;, endPercent * 105 + &quot;%&quot;],
         duration: this.options.outDuration,
         easing: 'easeOutQuad',
         complete: function () {
           // Run onOpenEnd callback
           if (typeof _this33.options.onCloseEnd === 'function') {
             _this33.options.onCloseEnd.call(_this33, _this33.el);
           }
         }
       });
     }
   }, {
     key: &quot;_animateOverlayOut&quot;,
     value: function _animateOverlayOut() {
       var _this34 = this;
</PRE><PRE>       anim.remove(this._overlay);
       anim({
         targets: this._overlay,
         opacity: 0,
         duration: this.options.outDuration,
         easing: 'easeOutQuad',
         complete: function () {
           $(_this34._overlay).css('display', 'none');
         }
       });
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Sidenav.__proto__ || Object.getPrototypeOf(Sidenav), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Sidenav;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Sidenav;
 }(Component);
</PRE><PRE> /**
  * @static
  * @memberof Sidenav
  * @type {Array.&lt;Sidenav&gt;}
  */
</PRE><PRE> Sidenav._sidenavs = [];
</PRE><PRE> M.Sidenav = Sidenav;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Sidenav, 'sidenav', 'M_Sidenav');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   throttle: 100,
   scrollOffset: 200, // offset - 200 allows elements near bottom of page to scroll
   activeClass: 'active',
   getActiveElement: function (id) {
     return 'a[href=&quot;#' + id + '&quot;]';
   }
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var ScrollSpy = function (_Component9) {
   _inherits(ScrollSpy, _Component9);
</PRE><PRE>   /**
    * Construct ScrollSpy instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function ScrollSpy(el, options) {
     _classCallCheck(this, ScrollSpy);
</PRE><PRE>     var _this35 = _possibleConstructorReturn(this, (ScrollSpy.__proto__ || Object.getPrototypeOf(ScrollSpy)).call(this, ScrollSpy, el, options));
</PRE><PRE>     _this35.el.M_ScrollSpy = _this35;
</PRE><PRE>     /**
      * Options for the modal
      * @member Modal#options
      * @prop {Number} [throttle=100] - Throttle of scroll handler
      * @prop {Number} [scrollOffset=200] - Offset for centering element when scrolled to
      * @prop {String} [activeClass='active'] - Class applied to active elements
      * @prop {Function} [getActiveElement] - Used to find active element
      */
     _this35.options = $.extend({}, ScrollSpy.defaults, options);
</PRE><PRE>     // setup
     ScrollSpy._elements.push(_this35);
     ScrollSpy._count++;
     ScrollSpy._increment++;
     _this35.tickId = -1;
     _this35.id = ScrollSpy._increment;
     _this35._setupEventHandlers();
     _this35._handleWindowScroll();
     return _this35;
   }
</PRE><PRE>   _createClass(ScrollSpy, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       ScrollSpy._elements.splice(ScrollSpy._elements.indexOf(this), 1);
       ScrollSpy._elementsInView.splice(ScrollSpy._elementsInView.indexOf(this), 1);
       ScrollSpy._visibleElements.splice(ScrollSpy._visibleElements.indexOf(this.$el), 1);
       ScrollSpy._count--;
       this._removeEventHandlers();
       $(this.options.getActiveElement(this.$el.attr('id'))).removeClass(this.options.activeClass);
       this.el.M_ScrollSpy = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       var throttledResize = M.throttle(this._handleWindowScroll, 200);
       this._handleThrottledResizeBound = throttledResize.bind(this);
       this._handleWindowScrollBound = this._handleWindowScroll.bind(this);
       if (ScrollSpy._count === 1) {
         window.addEventListener('scroll', this._handleWindowScrollBound);
         window.addEventListener('resize', this._handleThrottledResizeBound);
         document.body.addEventListener('click', this._handleTriggerClick);
       }
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       if (ScrollSpy._count === 0) {
         window.removeEventListener('scroll', this._handleWindowScrollBound);
         window.removeEventListener('resize', this._handleThrottledResizeBound);
         document.body.removeEventListener('click', this._handleTriggerClick);
       }
     }
</PRE><PRE>     /**
      * Handle Trigger Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleTriggerClick&quot;,
     value: function _handleTriggerClick(e) {
       var $trigger = $(e.target);
       for (var i = ScrollSpy._elements.length - 1; i &gt;= 0; i--) {
         var scrollspy = ScrollSpy._elements[i];
         if ($trigger.is('a[href=&quot;#' + scrollspy.$el.attr('id') + '&quot;]')) {
           e.preventDefault();
           var offset = scrollspy.$el.offset().top + 1;
</PRE><PRE>           anim({
             targets: [document.documentElement, document.body],
             scrollTop: offset - scrollspy.options.scrollOffset,
             duration: 400,
             easing: 'easeOutCubic'
           });
           break;
         }
       }
     }
</PRE><PRE>     /**
      * Handle Window Scroll
      */
</PRE><PRE>   }, {
     key: &quot;_handleWindowScroll&quot;,
     value: function _handleWindowScroll() {
       // unique tick id
       ScrollSpy._ticks++;
</PRE><PRE>       // viewport rectangle
       var top = M.getDocumentScrollTop(),
           left = M.getDocumentScrollLeft(),
           right = left + window.innerWidth,
           bottom = top + window.innerHeight;
</PRE><PRE>       // determine which elements are in view
       var intersections = ScrollSpy._findElements(top, right, bottom, left);
       for (var i = 0; i &lt; intersections.length; i++) {
         var scrollspy = intersections[i];
         var lastTick = scrollspy.tickId;
         if (lastTick &lt; 0) {
           // entered into view
           scrollspy._enter();
         }
</PRE><PRE>         // update tick id
         scrollspy.tickId = ScrollSpy._ticks;
       }
</PRE><PRE>       for (var _i = 0; _i &lt; ScrollSpy._elementsInView.length; _i++) {
         var _scrollspy = ScrollSpy._elementsInView[_i];
         var _lastTick = _scrollspy.tickId;
         if (_lastTick &gt;= 0 &amp;&amp; _lastTick !== ScrollSpy._ticks) {
           // exited from view
           _scrollspy._exit();
           _scrollspy.tickId = -1;
         }
       }
</PRE><PRE>       // remember elements in view for next tick
       ScrollSpy._elementsInView = intersections;
     }
</PRE><PRE>     /**
      * Find elements that are within the boundary
      * @param {number} top
      * @param {number} right
      * @param {number} bottom
      * @param {number} left
      * @return {Array.&lt;ScrollSpy&gt;}   A collection of elements
      */
</PRE><PRE>   }, {
     key: &quot;_enter&quot;,
     value: function _enter() {
       ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function (value) {
         return value.height() != 0;
       });
</PRE><PRE>       if (ScrollSpy._visibleElements[0]) {
         $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).removeClass(this.options.activeClass);
         if (ScrollSpy._visibleElements[0][0].M_ScrollSpy &amp;&amp; this.id &lt; ScrollSpy._visibleElements[0][0].M_ScrollSpy.id) {
           ScrollSpy._visibleElements.unshift(this.$el);
         } else {
           ScrollSpy._visibleElements.push(this.$el);
         }
       } else {
         ScrollSpy._visibleElements.push(this.$el);
       }
</PRE><PRE>       $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).addClass(this.options.activeClass);
     }
   }, {
     key: &quot;_exit&quot;,
     value: function _exit() {
       var _this36 = this;
</PRE><PRE>       ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function (value) {
         return value.height() != 0;
       });
</PRE><PRE>       if (ScrollSpy._visibleElements[0]) {
         $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).removeClass(this.options.activeClass);
</PRE><PRE>         ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function (el) {
           return el.attr('id') != _this36.$el.attr('id');
         });
         if (ScrollSpy._visibleElements[0]) {
           // Check if empty
           $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).addClass(this.options.activeClass);
         }
       }
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(ScrollSpy.__proto__ || Object.getPrototypeOf(ScrollSpy), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_ScrollSpy;
     }
   }, {
     key: &quot;_findElements&quot;,
     value: function _findElements(top, right, bottom, left) {
       var hits = [];
       for (var i = 0; i &lt; ScrollSpy._elements.length; i++) {
         var scrollspy = ScrollSpy._elements[i];
         var currTop = top + scrollspy.options.scrollOffset || 200;
</PRE><PRE>         if (scrollspy.$el.height() &gt; 0) {
           var elTop = scrollspy.$el.offset().top,
               elLeft = scrollspy.$el.offset().left,
               elRight = elLeft + scrollspy.$el.width(),
               elBottom = elTop + scrollspy.$el.height();
</PRE><PRE>           var isIntersect = !(elLeft &gt; right || elRight &lt; left || elTop &gt; bottom || elBottom &lt; currTop);
</PRE><PRE>           if (isIntersect) {
             hits.push(scrollspy);
           }
         }
       }
       return hits;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return ScrollSpy;
 }(Component);
</PRE><PRE> /**
  * @static
  * @memberof ScrollSpy
  * @type {Array.&lt;ScrollSpy&gt;}
  */
</PRE><PRE> ScrollSpy._elements = [];
</PRE><PRE> /**
  * @static
  * @memberof ScrollSpy
  * @type {Array.&lt;ScrollSpy&gt;}
  */
 ScrollSpy._elementsInView = [];
</PRE><PRE> /**
  * @static
  * @memberof ScrollSpy
  * @type {Array.&lt;cash&gt;}
  */
 ScrollSpy._visibleElements = [];
</PRE><PRE> /**
  * @static
  * @memberof ScrollSpy
  */
 ScrollSpy._count = 0;
</PRE><PRE> /**
  * @static
  * @memberof ScrollSpy
  */
 ScrollSpy._increment = 0;
</PRE><PRE> /**
  * @static
  * @memberof ScrollSpy
  */
 ScrollSpy._ticks = 0;
</PRE><PRE> M.ScrollSpy = ScrollSpy;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(ScrollSpy, 'scrollSpy', 'M_ScrollSpy');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   data: {}, // Autocomplete data set
   limit: Infinity, // Limit of results the autocomplete shows
   onAutocomplete: null, // Callback for when autocompleted
   minLength: 1, // Min characters before autocomplete starts
   sortFunction: function (a, b, inputString) {
     // Sort function for sorting autocomplete results
     return a.indexOf(inputString) - b.indexOf(inputString);
   }
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Autocomplete = function (_Component10) {
   _inherits(Autocomplete, _Component10);
</PRE><PRE>   /**
    * Construct Autocomplete instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Autocomplete(el, options) {
     _classCallCheck(this, Autocomplete);
</PRE><PRE>     var _this37 = _possibleConstructorReturn(this, (Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call(this, Autocomplete, el, options));
</PRE><PRE>     _this37.el.M_Autocomplete = _this37;
</PRE><PRE>     /**
      * Options for the autocomplete
      * @member Autocomplete#options
      * @prop {Number} duration
      * @prop {Number} dist
      * @prop {number} shift
      * @prop {number} padding
      * @prop {Boolean} fullWidth
      * @prop {Boolean} indicators
      * @prop {Boolean} noWrap
      * @prop {Function} onCycleTo
      */
     _this37.options = $.extend({}, Autocomplete.defaults, options);
</PRE><PRE>     // Setup
     _this37.isOpen = false;
     _this37.count = 0;
     _this37.activeIndex = -1;
     _this37.oldVal;
     _this37.$inputField = _this37.$el.closest('.input-field');
     _this37.$active = $();
     _this37._mousedown = false;
     _this37._setupDropdown();
</PRE><PRE>     _this37._setupEventHandlers();
     return _this37;
   }
</PRE><PRE>   _createClass(Autocomplete, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this._removeDropdown();
       this.el.M_Autocomplete = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleInputBlurBound = this._handleInputBlur.bind(this);
       this._handleInputKeyupAndFocusBound = this._handleInputKeyupAndFocus.bind(this);
       this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
       this._handleInputClickBound = this._handleInputClick.bind(this);
       this._handleContainerMousedownAndTouchstartBound = this._handleContainerMousedownAndTouchstart.bind(this);
       this._handleContainerMouseupAndTouchendBound = this._handleContainerMouseupAndTouchend.bind(this);
</PRE><PRE>       this.el.addEventListener('blur', this._handleInputBlurBound);
       this.el.addEventListener('keyup', this._handleInputKeyupAndFocusBound);
       this.el.addEventListener('focus', this._handleInputKeyupAndFocusBound);
       this.el.addEventListener('keydown', this._handleInputKeydownBound);
       this.el.addEventListener('click', this._handleInputClickBound);
       this.container.addEventListener('mousedown', this._handleContainerMousedownAndTouchstartBound);
       this.container.addEventListener('mouseup', this._handleContainerMouseupAndTouchendBound);
</PRE><PRE>       if (typeof window.ontouchstart !== 'undefined') {
         this.container.addEventListener('touchstart', this._handleContainerMousedownAndTouchstartBound);
         this.container.addEventListener('touchend', this._handleContainerMouseupAndTouchendBound);
       }
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('blur', this._handleInputBlurBound);
       this.el.removeEventListener('keyup', this._handleInputKeyupAndFocusBound);
       this.el.removeEventListener('focus', this._handleInputKeyupAndFocusBound);
       this.el.removeEventListener('keydown', this._handleInputKeydownBound);
       this.el.removeEventListener('click', this._handleInputClickBound);
       this.container.removeEventListener('mousedown', this._handleContainerMousedownAndTouchstartBound);
       this.container.removeEventListener('mouseup', this._handleContainerMouseupAndTouchendBound);
</PRE><PRE>       if (typeof window.ontouchstart !== 'undefined') {
         this.container.removeEventListener('touchstart', this._handleContainerMousedownAndTouchstartBound);
         this.container.removeEventListener('touchend', this._handleContainerMouseupAndTouchendBound);
       }
     }
</PRE><PRE>     /**
      * Setup dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_setupDropdown&quot;,
     value: function _setupDropdown() {
       var _this38 = this;
</PRE><PRE>       this.container = document.createElement('ul');
       this.container.id = &quot;autocomplete-options-&quot; + M.guid();
       $(this.container).addClass('autocomplete-content dropdown-content');
       this.$inputField.append(this.container);
       this.el.setAttribute('data-target', this.container.id);
</PRE><PRE>       this.dropdown = M.Dropdown.init(this.el, {
         autoFocus: false,
         closeOnClick: false,
         coverTrigger: false,
         onItemClick: function (itemEl) {
           _this38.selectOption($(itemEl));
         }
       });
</PRE><PRE>       // Sketchy removal of dropdown click handler
       this.el.removeEventListener('click', this.dropdown._handleClickBound);
     }
</PRE><PRE>     /**
      * Remove dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_removeDropdown&quot;,
     value: function _removeDropdown() {
       this.container.parentNode.removeChild(this.container);
     }
</PRE><PRE>     /**
      * Handle Input Blur
      */
</PRE><PRE>   }, {
     key: &quot;_handleInputBlur&quot;,
     value: function _handleInputBlur() {
       if (!this._mousedown) {
         this.close();
         this._resetAutocomplete();
       }
     }
</PRE><PRE>     /**
      * Handle Input Keyup and Focus
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleInputKeyupAndFocus&quot;,
     value: function _handleInputKeyupAndFocus(e) {
       if (e.type === 'keyup') {
         Autocomplete._keydown = false;
       }
</PRE><PRE>       this.count = 0;
       var val = this.el.value.toLowerCase();
</PRE><PRE>       // Don't capture enter or arrow key usage.
       if (e.keyCode === 13 || e.keyCode === 38 || e.keyCode === 40) {
         return;
       }
</PRE><PRE>       // Check if the input isn't empty
       // Check if focus triggered by tab
       if (this.oldVal !== val &amp;&amp; (M.tabPressed || e.type !== 'focus')) {
         this.open();
       }
</PRE><PRE>       // Update oldVal
       this.oldVal = val;
     }
</PRE><PRE>     /**
      * Handle Input Keydown
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleInputKeydown&quot;,
     value: function _handleInputKeydown(e) {
       Autocomplete._keydown = true;
</PRE><PRE>       // Arrow keys and enter key usage
       var keyCode = e.keyCode,
           liElement = void 0,
           numItems = $(this.container).children('li').length;
</PRE><PRE>       // select element on Enter
       if (keyCode === M.keys.ENTER &amp;&amp; this.activeIndex &gt;= 0) {
         liElement = $(this.container).children('li').eq(this.activeIndex);
         if (liElement.length) {
           this.selectOption(liElement);
           e.preventDefault();
         }
         return;
       }
</PRE><PRE>       // Capture up and down key
       if (keyCode === M.keys.ARROW_UP || keyCode === M.keys.ARROW_DOWN) {
         e.preventDefault();
</PRE><PRE>         if (keyCode === M.keys.ARROW_UP &amp;&amp; this.activeIndex &gt; 0) {
           this.activeIndex--;
         }
</PRE><PRE>         if (keyCode === M.keys.ARROW_DOWN &amp;&amp; this.activeIndex &lt; numItems - 1) {
           this.activeIndex++;
         }
</PRE><PRE>         this.$active.removeClass('active');
         if (this.activeIndex &gt;= 0) {
           this.$active = $(this.container).children('li').eq(this.activeIndex);
           this.$active.addClass('active');
         }
       }
     }
</PRE><PRE>     /**
      * Handle Input Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleInputClick&quot;,
     value: function _handleInputClick(e) {
       this.open();
     }
</PRE><PRE>     /**
      * Handle Container Mousedown and Touchstart
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleContainerMousedownAndTouchstart&quot;,
     value: function _handleContainerMousedownAndTouchstart(e) {
       this._mousedown = true;
     }
</PRE><PRE>     /**
      * Handle Container Mouseup and Touchend
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleContainerMouseupAndTouchend&quot;,
     value: function _handleContainerMouseupAndTouchend(e) {
       this._mousedown = false;
     }
</PRE><PRE>     /**
      * Highlight partial match
      */
</PRE><PRE>   }, {
     key: &quot;_highlight&quot;,
     value: function _highlight(string, $el) {
       var img = $el.find('img');
       var matchStart = $el.text().toLowerCase().indexOf(<I> + string.toLowerCase() + </I>),
           matchEnd = matchStart + string.length - 1,
           beforeMatch = $el.text().slice(0, matchStart),
           matchText = $el.text().slice(matchStart, matchEnd + 1),
           afterMatch = $el.text().slice(matchEnd + 1);
       $el.html(&quot;<SPAN>&quot; + beforeMatch + &quot;<SPAN class="highlight">&quot; + matchText + &quot;</SPAN>&quot; + afterMatch + &quot;</SPAN>&quot;);
       if (img.length) {
         $el.prepend(img);
       }
     }
</PRE><PRE>     /**
      * Reset current element position
      */
</PRE><PRE>   }, {
     key: &quot;_resetCurrentElement&quot;,
     value: function _resetCurrentElement() {
       this.activeIndex = -1;
       this.$active.removeClass('active');
     }
</PRE><PRE>     /**
      * Reset autocomplete elements
      */
</PRE><PRE>   }, {
     key: &quot;_resetAutocomplete&quot;,
     value: function _resetAutocomplete() {
       $(this.container).empty();
       this._resetCurrentElement();
       this.oldVal = null;
       this.isOpen = false;
       this._mousedown = false;
     }
</PRE><PRE>     /**
      * Select autocomplete option
      * @param {Element} el  Autocomplete option list item element
      */
</PRE><PRE>   }, {
     key: &quot;selectOption&quot;,
     value: function selectOption(el) {
       var text = el.text().trim();
       this.el.value = text;
       this.$el.trigger('change');
       this._resetAutocomplete();
       this.close();
</PRE><PRE>       // Handle onAutocomplete callback.
       if (typeof this.options.onAutocomplete === 'function') {
         this.options.onAutocomplete.call(this, text);
       }
     }
</PRE><PRE>     /**
      * Render dropdown content
      * @param {Object} data  data set
      * @param {String} val  current input value
      */
</PRE><PRE>   }, {
     key: &quot;_renderDropdown&quot;,
     value: function _renderDropdown(data, val) {
       var _this39 = this;
</PRE><PRE>       this._resetAutocomplete();
</PRE><PRE>       var matchingData = [];
</PRE><PRE>       // Gather all matching data
       for (var key in data) {
         if (data.hasOwnProperty(key) &amp;&amp; key.toLowerCase().indexOf(val) !== -1) {
           // Break if past limit
           if (this.count &gt;= this.options.limit) {
             break;
           }
</PRE><PRE>           var entry = {
             data: data[key],
             key: key
           };
           matchingData.push(entry);
</PRE><PRE>           this.count++;
         }
       }
</PRE><PRE>       // Sort
       if (this.options.sortFunction) {
         var sortFunctionBound = function (a, b) {
           return _this39.options.sortFunction(a.key.toLowerCase(), b.key.toLowerCase(), val.toLowerCase());
         };
         matchingData.sort(sortFunctionBound);
       }
</PRE><PRE>       // Render
       for (var i = 0; i &lt; matchingData.length; i++) {
         var _entry = matchingData[i];
</PRE>
          var $autocompleteOption = $('');
<PRE>         if (!!_entry.data) {
           $autocompleteOption.append(&quot;&lt;img src=\&quot;&quot; + _entry.data + &quot;\&quot; class=\&quot;right circle\&quot;&gt;<SPAN>&quot; + _entry.key + &quot;</SPAN>&quot;);
         } else {
           $autocompleteOption.append('<SPAN>' + _entry.key + '</SPAN>');
         }
</PRE><PRE>         $(this.container).append($autocompleteOption);
         this._highlight(val, $autocompleteOption);
       }
     }
</PRE><PRE>     /**
      * Open Autocomplete Dropdown
      */
</PRE><PRE>   }, {
     key: &quot;open&quot;,
     value: function open() {
       var val = this.el.value.toLowerCase();
</PRE><PRE>       this._resetAutocomplete();
</PRE><PRE>       if (val.length &gt;= this.options.minLength) {
         this.isOpen = true;
         this._renderDropdown(this.options.data, val);
       }
</PRE><PRE>       // Open dropdown
       if (!this.dropdown.isOpen) {
         this.dropdown.open();
       } else {
         // Recalculate dropdown when its already open
         this.dropdown.recalculateDimensions();
       }
     }
</PRE><PRE>     /**
      * Close Autocomplete Dropdown
      */
</PRE><PRE>   }, {
     key: &quot;close&quot;,
     value: function close() {
       this.dropdown.close();
     }
</PRE><PRE>     /**
      * Update Data
      * @param {Object} data
      */
</PRE><PRE>   }, {
     key: &quot;updateData&quot;,
     value: function updateData(data) {
       var val = this.el.value.toLowerCase();
       this.options.data = data;
</PRE><PRE>       if (this.isOpen) {
         this._renderDropdown(data, val);
       }
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Autocomplete;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Autocomplete;
 }(Component);
</PRE><PRE> /**
  * @static
  * @memberof Autocomplete
  */
</PRE><PRE> Autocomplete._keydown = false;
</PRE><PRE> M.Autocomplete = Autocomplete;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Autocomplete, 'autocomplete', 'M_Autocomplete');
 }
</PRE><P>})(cash);
</P><DL><DT>(function ($) {</DT></DL><PRE> // Function to update labels of text fields
 M.updateTextFields = function () {
   var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea';
   $(input_selector).each(function (element, index) {
     var $this = $(this);
     if (element.value.length &gt; 0 || $(element).is(':focus') || element.autofocus || $this.attr('placeholder') !== null) {
       $this.siblings('label').addClass('active');
     } else if (element.validity) {
       $this.siblings('label').toggleClass('active', element.validity.badInput === true);
     } else {
       $this.siblings('label').removeClass('active');
     }
   });
 };
</PRE><PRE> M.validate_field = function (object) {
   var hasLength = object.attr('data-length') !== null;
   var lenAttr = parseInt(object.attr('data-length'));
   var len = object[0].value.length;
</PRE><PRE>   if (len === 0 &amp;&amp; object[0].validity.badInput === false &amp;&amp; !object.is(':required')) {
     if (object.hasClass('validate')) {
       object.removeClass('valid');
       object.removeClass('invalid');
     }
   } else {
     if (object.hasClass('validate')) {
       // Check for character counter attributes
       if (object.is(':valid') &amp;&amp; hasLength &amp;&amp; len &lt;= lenAttr || object.is(':valid') &amp;&amp; !hasLength) {
         object.removeClass('invalid');
         object.addClass('valid');
       } else {
         object.removeClass('valid');
         object.addClass('invalid');
       }
     }
   }
 };
</PRE><PRE> M.textareaAutoResize = function ($textarea) {
   // Wrap if native element
   if ($textarea instanceof Element) {
     $textarea = $($textarea);
   }
</PRE><PRE>   if (!$textarea.length) {
     console.error('No textarea element found');
     return;
   }
</PRE><PRE>   // Textarea Auto Resize
   var hiddenDiv = $('.hiddendiv').first();
   if (!hiddenDiv.length) {
</PRE>
      hiddenDiv = $('');
<PRE>     $('body').append(hiddenDiv);
   }
</PRE><PRE>   // Set font properties of hiddenDiv
   var fontFamily = $textarea.css('font-family');
   var fontSize = $textarea.css('font-size');
   var lineHeight = $textarea.css('line-height');
</PRE><PRE>   // Firefox can't handle padding shorthand.
   var paddingTop = $textarea.css('padding-top');
   var paddingRight = $textarea.css('padding-right');
   var paddingBottom = $textarea.css('padding-bottom');
   var paddingLeft = $textarea.css('padding-left');
</PRE><PRE>   if (fontSize) {
     hiddenDiv.css('font-size', fontSize);
   }
   if (fontFamily) {
     hiddenDiv.css('font-family', fontFamily);
   }
   if (lineHeight) {
     hiddenDiv.css('line-height', lineHeight);
   }
   if (paddingTop) {
     hiddenDiv.css('padding-top', paddingTop);
   }
   if (paddingRight) {
     hiddenDiv.css('padding-right', paddingRight);
   }
   if (paddingBottom) {
     hiddenDiv.css('padding-bottom', paddingBottom);
   }
   if (paddingLeft) {
     hiddenDiv.css('padding-left', paddingLeft);
   }
</PRE><PRE>   // Set original-height, if none
   if (!$textarea.data('original-height')) {
     $textarea.data('original-height', $textarea.height());
   }
</PRE><PRE>   if ($textarea.attr('wrap') === 'off') {
     hiddenDiv.css('overflow-wrap', 'normal').css('white-space', 'pre');
   }
</PRE><PRE>   hiddenDiv.text($textarea[0].value + '\n');
   var content = hiddenDiv.html().replace(/\n/g, '');
   hiddenDiv.html(content);
</PRE><PRE>   // When textarea is hidden, width goes crazy.
   // Approximate with half of window size
</PRE><PRE>   if ($textarea[0].offsetWidth &gt; 0 &amp;&amp; $textarea[0].offsetHeight &gt; 0) {
     hiddenDiv.css('width', $textarea.width() + 'px');
   } else {
     hiddenDiv.css('width', window.innerWidth / 2 + 'px');
   }
</PRE><PRE>   /**
    * Resize if the new height is greater than the
    * original height of the textarea
    */
   if ($textarea.data('original-height') &lt;= hiddenDiv.innerHeight()) {
     $textarea.css('height', hiddenDiv.innerHeight() + 'px');
   } else if ($textarea[0].value.length &lt; $textarea.data('previous-length')) {
     /**
      * In case the new height is less than original height, it
      * means the textarea has less text than before
      * So we set the height to the original one
      */
     $textarea.css('height', $textarea.data('original-height') + 'px');
   }
   $textarea.data('previous-length', $textarea[0].value.length);
 };
</PRE><PRE> $(document).ready(function () {
   // Text based inputs
   var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea';
</PRE><PRE>   // Add active if form auto complete
   $(document).on('change', input_selector, function () {
     if (this.value.length !== 0 || $(this).attr('placeholder') !== null) {
       $(this).siblings('label').addClass('active');
     }
     M.validate_field($(this));
   });
</PRE><PRE>   // Add active if input element has been pre-populated on document ready
   $(document).ready(function () {
     M.updateTextFields();
   });
</PRE><PRE>   // HTML DOM FORM RESET handling
   $(document).on('reset', function (e) {
     var formReset = $(e.target);
     if (formReset.is('form')) {
       formReset.find(input_selector).removeClass('valid').removeClass('invalid');
       formReset.find(input_selector).each(function (e) {
         if (this.value.length) {
           $(this).siblings('label').removeClass('active');
         }
       });
</PRE><PRE>       // Reset select (after native reset)
       setTimeout(function () {
         formReset.find('select').each(function () {
           // check if initialized
           if (this.M_FormSelect) {
             $(this).trigger('change');
           }
         });
       }, 0);
     }
   });
</PRE><PRE>   /**
    * Add active when element has focus
    * @param {Event} e
    */
   document.addEventListener('focus', function (e) {
     if ($(e.target).is(input_selector)) {
       $(e.target).siblings('label, .prefix').addClass('active');
     }
   }, true);
</PRE><PRE>   /**
    * Remove active when element is blurred
    * @param {Event} e
    */
   document.addEventListener('blur', function (e) {
     var $inputElement = $(e.target);
     if ($inputElement.is(input_selector)) {
       var selector = '.prefix';
</PRE><PRE>       if ($inputElement[0].value.length === 0 &amp;&amp; $inputElement[0].validity.badInput !== true &amp;&amp; $inputElement.attr('placeholder') === null) {
         selector += ', label';
       }
       $inputElement.siblings(selector).removeClass('active');
       M.validate_field($inputElement);
     }
   }, true);
</PRE><PRE>   // Radio and Checkbox focus class
   var radio_checkbox = 'input[type=radio], input[type=checkbox]';
   $(document).on('keyup', radio_checkbox, function (e) {
     // TAB, check if tabbing to radio or checkbox.
     if (e.which === M.keys.TAB) {
       $(this).addClass('tabbed');
       var $this = $(this);
       $this.one('blur', function (e) {
         $(this).removeClass('tabbed');
       });
       return;
     }
   });
</PRE><PRE>   var text_area_selector = '.materialize-textarea';
   $(text_area_selector).each(function () {
     var $textarea = $(this);
     /**
      * Resize textarea on document load after storing
      * the original height and the original length
      */
     $textarea.data('original-height', $textarea.height());
     $textarea.data('previous-length', this.value.length);
     M.textareaAutoResize($textarea);
   });
</PRE><PRE>   $(document).on('keyup', text_area_selector, function () {
     M.textareaAutoResize($(this));
   });
   $(document).on('keydown', text_area_selector, function () {
     M.textareaAutoResize($(this));
   });
</PRE><PRE>   // File Input Path
   $(document).on('change', '.file-field input[type=&quot;file&quot;]', function () {
     var file_field = $(this).closest('.file-field');
     var path_input = file_field.find('input.file-path');
     var files = $(this)[0].files;
     var file_names = [];
     for (var i = 0; i &lt; files.length; i++) {
       file_names.push(files[i].name);
     }
     path_input[0].value = file_names.join(', ');
     path_input.trigger('change');
   });
 }); // End of $(document).ready
</PRE><P>})(cash);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   indicators: true,
   height: 400,
   duration: 500,
   interval: 6000
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Slider = function (_Component11) {
   _inherits(Slider, _Component11);
</PRE><PRE>   /**
    * Construct Slider instance and set up overlay
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Slider(el, options) {
     _classCallCheck(this, Slider);
</PRE><PRE>     var _this40 = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, Slider, el, options));
</PRE><PRE>     _this40.el.M_Slider = _this40;
</PRE><PRE>     /**
      * Options for the modal
      * @member Slider#options
      * @prop {Boolean} [indicators=true] - Show indicators
      * @prop {Number} [height=400] - height of slider
      * @prop {Number} [duration=500] - Length in ms of slide transition
      * @prop {Number} [interval=6000] - Length in ms of slide interval
      */
     _this40.options = $.extend({}, Slider.defaults, options);
</PRE><PRE>     // setup
     _this40.$slider = _this40.$el.find('.slides');
     _this40.$slides = _this40.$slider.children('li');
     _this40.activeIndex = _this40.$slides.filter(function (item) {
       return $(item).hasClass('active');
     }).first().index();
     if (_this40.activeIndex != -1) {
       _this40.$active = _this40.$slides.eq(_this40.activeIndex);
     }
</PRE><PRE>     _this40._setSliderHeight();
</PRE><PRE>     // Set initial positions of captions
     _this40.$slides.find('.caption').each(function (el) {
       _this40._animateCaptionIn(el, 0);
     });
</PRE><PRE>     // Move img src into background-image
     _this40.$slides.find('img').each(function (el) {
       var placeholderBase64 = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
       if ($(el).attr('src') !== placeholderBase64) {
         $(el).css('background-image', 'url(&quot;' + $(el).attr('src') + '&quot;)');
         $(el).attr('src', placeholderBase64);
       }
     });
</PRE><PRE>     _this40._setupIndicators();
</PRE><PRE>     // Show active slide
     if (_this40.$active) {
       _this40.$active.css('display', 'block');
     } else {
       _this40.$slides.first().addClass('active');
       anim({
         targets: _this40.$slides.first()[0],
         opacity: 1,
         duration: _this40.options.duration,
         easing: 'easeOutQuad'
       });
</PRE><PRE>       _this40.activeIndex = 0;
       _this40.$active = _this40.$slides.eq(_this40.activeIndex);
</PRE><PRE>       // Update indicators
       if (_this40.options.indicators) {
         _this40.$indicators.eq(_this40.activeIndex).addClass('active');
       }
     }
</PRE><PRE>     // Adjust height to current slide
     _this40.$active.find('img').each(function (el) {
       anim({
         targets: _this40.$active.find('.caption')[0],
         opacity: 1,
         translateX: 0,
         translateY: 0,
         duration: _this40.options.duration,
         easing: 'easeOutQuad'
       });
     });
</PRE><PRE>     _this40._setupEventHandlers();
</PRE><PRE>     // auto scroll
     _this40.start();
     return _this40;
   }
</PRE><PRE>   _createClass(Slider, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this.pause();
       this._removeIndicators();
       this._removeEventHandlers();
       this.el.M_Slider = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       var _this41 = this;
</PRE><PRE>       this._handleIntervalBound = this._handleInterval.bind(this);
       this._handleIndicatorClickBound = this._handleIndicatorClick.bind(this);
</PRE><PRE>       if (this.options.indicators) {
         this.$indicators.each(function (el) {
           el.addEventListener('click', _this41._handleIndicatorClickBound);
         });
       }
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       var _this42 = this;
</PRE><PRE>       if (this.options.indicators) {
         this.$indicators.each(function (el) {
           el.removeEventListener('click', _this42._handleIndicatorClickBound);
         });
       }
     }
</PRE><PRE>     /**
      * Handle indicator click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleIndicatorClick&quot;,
     value: function _handleIndicatorClick(e) {
       var currIndex = $(e.target).index();
       this.set(currIndex);
     }
</PRE><PRE>     /**
      * Handle Interval
      */
</PRE><PRE>   }, {
     key: &quot;_handleInterval&quot;,
     value: function _handleInterval() {
       var newActiveIndex = this.$slider.find('.active').index();
       if (this.$slides.length === newActiveIndex + 1) newActiveIndex = 0;
       // loop to start
       else newActiveIndex += 1;
</PRE><PRE>       this.set(newActiveIndex);
     }
</PRE><PRE>     /**
      * Animate in caption
      * @param {Element} caption
      * @param {Number} duration
      */
</PRE><PRE>   }, {
     key: &quot;_animateCaptionIn&quot;,
     value: function _animateCaptionIn(caption, duration) {
       var animOptions = {
         targets: caption,
         opacity: 0,
         duration: duration,
         easing: 'easeOutQuad'
       };
</PRE><PRE>       if ($(caption).hasClass('center-align')) {
         animOptions.translateY = -100;
       } else if ($(caption).hasClass('right-align')) {
         animOptions.translateX = 100;
       } else if ($(caption).hasClass('left-align')) {
         animOptions.translateX = -100;
       }
</PRE><PRE>       anim(animOptions);
     }
</PRE><PRE>     /**
      * Set height of slider
      */
</PRE><PRE>   }, {
     key: &quot;_setSliderHeight&quot;,
     value: function _setSliderHeight() {
       // If fullscreen, do nothing
       if (!this.$el.hasClass('fullscreen')) {
         if (this.options.indicators) {
           // Add height if indicators are present
           this.$el.css('height', this.options.height + 40 + 'px');
         } else {
           this.$el.css('height', this.options.height + 'px');
         }
         this.$slider.css('height', this.options.height + 'px');
       }
     }
</PRE><PRE>     /**
      * Setup indicators
      */
</PRE><PRE>   }, {
     key: &quot;_setupIndicators&quot;,
     value: function _setupIndicators() {
       var _this43 = this;
</PRE><PRE>       if (this.options.indicators) {
</PRE>
          this.$indicators = $('');
<PRE>         this.$slides.each(function (el, index) {
</PRE>
            var $indicator = $('');
<PRE>           _this43.$indicators.append($indicator[0]);
         });
         this.$el.append(this.$indicators[0]);
         this.$indicators = this.$indicators.children('li.indicator-item');
       }
     }
</PRE><PRE>     /**
      * Remove indicators
      */
</PRE><PRE>   }, {
     key: &quot;_removeIndicators&quot;,
     value: function _removeIndicators() {
       this.$el.find('ul.indicators').remove();
     }
</PRE><PRE>     /**
      * Cycle to nth item
      * @param {Number} index
      */
</PRE><PRE>   }, {
     key: &quot;set&quot;,
     value: function set(index) {
       var _this44 = this;
</PRE><PRE>       // Wrap around indices.
       if (index &gt;= this.$slides.length) index = 0;else if (index &lt; 0) index = this.$slides.length - 1;
</PRE><PRE>       // Only do if index changes
       if (this.activeIndex != index) {
         this.$active = this.$slides.eq(this.activeIndex);
         var $caption = this.$active.find('.caption');
         this.$active.removeClass('active');
</PRE><PRE>         anim({
           targets: this.$active[0],
           opacity: 0,
           duration: this.options.duration,
           easing: 'easeOutQuad',
           complete: function () {
             _this44.$slides.not('.active').each(function (el) {
               anim({
                 targets: el,
                 opacity: 0,
                 translateX: 0,
                 translateY: 0,
                 duration: 0,
                 easing: 'easeOutQuad'
               });
             });
           }
         });
</PRE><PRE>         this._animateCaptionIn($caption[0], this.options.duration);
</PRE><PRE>         // Update indicators
         if (this.options.indicators) {
           this.$indicators.eq(this.activeIndex).removeClass('active');
           this.$indicators.eq(index).addClass('active');
         }
</PRE><PRE>         anim({
           targets: this.$slides.eq(index)[0],
           opacity: 1,
           duration: this.options.duration,
           easing: 'easeOutQuad'
         });
</PRE><PRE>         anim({
           targets: this.$slides.eq(index).find('.caption')[0],
           opacity: 1,
           translateX: 0,
           translateY: 0,
           duration: this.options.duration,
           delay: this.options.duration,
           easing: 'easeOutQuad'
         });
</PRE><PRE>         this.$slides.eq(index).addClass('active');
         this.activeIndex = index;
</PRE><PRE>         // Reset interval
         this.start();
       }
     }
</PRE><PRE>     /**
      * Pause slider interval
      */
</PRE><PRE>   }, {
     key: &quot;pause&quot;,
     value: function pause() {
       clearInterval(this.interval);
     }
</PRE><PRE>     /**
      * Start slider interval
      */
</PRE><PRE>   }, {
     key: &quot;start&quot;,
     value: function start() {
       clearInterval(this.interval);
       this.interval = setInterval(this._handleIntervalBound, this.options.duration + this.options.interval);
     }
</PRE><PRE>     /**
      * Move to next slide
      */
</PRE><PRE>   }, {
     key: &quot;next&quot;,
     value: function next() {
       var newIndex = this.activeIndex + 1;
</PRE><PRE>       // Wrap around indices.
       if (newIndex &gt;= this.$slides.length) newIndex = 0;else if (newIndex &lt; 0) newIndex = this.$slides.length - 1;
</PRE><PRE>       this.set(newIndex);
     }
</PRE><PRE>     /**
      * Move to previous slide
      */
</PRE><PRE>   }, {
     key: &quot;prev&quot;,
     value: function prev() {
       var newIndex = this.activeIndex - 1;
</PRE><PRE>       // Wrap around indices.
       if (newIndex &gt;= this.$slides.length) newIndex = 0;else if (newIndex &lt; 0) newIndex = this.$slides.length - 1;
</PRE><PRE>       this.set(newIndex);
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Slider.__proto__ || Object.getPrototypeOf(Slider), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Slider;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Slider;
 }(Component);
</PRE><PRE> M.Slider = Slider;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Slider, 'slider', 'M_Slider');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> $(document).on('click', '.card', function (e) {
   if ($(this).children('.card-reveal').length) {
     var $card = $(e.target).closest('.card');
     if ($card.data('initialOverflow') === undefined) {
       $card.data('initialOverflow', $card.css('overflow') === undefined ? <I> : $card.css('overflow'));</I>
     }
     var $cardReveal = $(this).find('.card-reveal');
     if ($(e.target).is($('.card-reveal .card-title')) || $(e.target).is($('.card-reveal .card-title i'))) {
       // Make Reveal animate down and display none
       anim({
         targets: $cardReveal[0],
         translateY: 0,
         duration: 225,
         easing: 'easeInOutQuad',
         complete: function (anim) {
           var el = anim.animatables[0].target;
           $(el).css({ display: 'none' });
           $card.css('overflow', $card.data('initialOverflow'));
         }
       });
     } else if ($(e.target).is($('.card .activator')) || $(e.target).is($('.card .activator i'))) {
       $card.css('overflow', 'hidden');
       $cardReveal.css({ display: 'block' });
       anim({
         targets: $cardReveal[0],
         translateY: '-100%',
         duration: 300,
         easing: 'easeInOutQuad'
       });
     }
   }
 });
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   data: [],
   placeholder: <I>,</I>
   secondaryPlaceholder: <I>,</I>
   autocompleteOptions: {},
   limit: Infinity,
   onChipAdd: null,
   onChipSelect: null,
   onChipDelete: null
 };
</PRE><PRE> /**
  * @typedef {Object} chip
  * @property {String} tag  chip tag string
  * @property {String} [image]  chip avatar image string
  */
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Chips = function (_Component12) {
   _inherits(Chips, _Component12);
</PRE><PRE>   /**
    * Construct Chips instance and set up overlay
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Chips(el, options) {
     _classCallCheck(this, Chips);
</PRE><PRE>     var _this45 = _possibleConstructorReturn(this, (Chips.__proto__ || Object.getPrototypeOf(Chips)).call(this, Chips, el, options));
</PRE><PRE>     _this45.el.M_Chips = _this45;
</PRE><PRE>     /**
      * Options for the modal
      * @member Chips#options
      * @prop {Array} data
      * @prop {String} placeholder
      * @prop {String} secondaryPlaceholder
      * @prop {Object} autocompleteOptions
      */
     _this45.options = $.extend({}, Chips.defaults, options);
</PRE><PRE>     _this45.$el.addClass('chips input-field');
     _this45.chipsData = [];
     _this45.$chips = $();
     _this45._setupInput();
     _this45.hasAutocomplete = Object.keys(_this45.options.autocompleteOptions).length &gt; 0;
</PRE><PRE>     // Set input id
     if (!_this45.$input.attr('id')) {
       _this45.$input.attr('id', M.guid());
     }
</PRE><PRE>     // Render initial chips
     if (_this45.options.data.length) {
       _this45.chipsData = _this45.options.data;
       _this45._renderChips(_this45.chipsData);
     }
</PRE><PRE>     // Setup autocomplete if needed
     if (_this45.hasAutocomplete) {
       _this45._setupAutocomplete();
     }
</PRE><PRE>     _this45._setPlaceholder();
     _this45._setupLabel();
     _this45._setupEventHandlers();
     return _this45;
   }
</PRE><PRE>   _createClass(Chips, [{
     key: &quot;getData&quot;,
</PRE><PRE>     /**
      * Get Chips Data
      */
     value: function getData() {
       return this.chipsData;
     }
</PRE><PRE>     /**
      * Teardown component
      */
</PRE><PRE>   }, {
     key: &quot;destroy&quot;,
     value: function destroy() {
       this._removeEventHandlers();
       this.$chips.remove();
       this.el.M_Chips = undefined;
     }
</PRE><PRE>/**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleChipClickBound = this._handleChipClick.bind(this);
       this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
       this._handleInputFocusBound = this._handleInputFocus.bind(this);
       this._handleInputBlurBound = this._handleInputBlur.bind(this);
</PRE><PRE>       this.el.addEventListener('click', this._handleChipClickBound);
       document.addEventListener('keydown', Chips._handleChipsKeydown);
       document.addEventListener('keyup', Chips._handleChipsKeyup);
       this.el.addEventListener('blur', Chips._handleChipsBlur, true);
       this.$input[0].addEventListener('focus', this._handleInputFocusBound);
       this.$input[0].addEventListener('blur', this._handleInputBlurBound);
       this.$input[0].addEventListener('keydown', this._handleInputKeydownBound);
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('click', this._handleChipClickBound);
       document.removeEventListener('keydown', Chips._handleChipsKeydown);
       document.removeEventListener('keyup', Chips._handleChipsKeyup);
       this.el.removeEventListener('blur', Chips._handleChipsBlur, true);
       this.$input[0].removeEventListener('focus', this._handleInputFocusBound);
       this.$input[0].removeEventListener('blur', this._handleInputBlurBound);
       this.$input[0].removeEventListener('keydown', this._handleInputKeydownBound);
     }
</PRE><PRE>     /**
      * Handle Chip Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleChipClick&quot;,
     value: function _handleChipClick(e) {
       var $chip = $(e.target).closest('.chip');
       var clickedClose = $(e.target).is('.close');
       if ($chip.length) {
         var index = $chip.index();
         if (clickedClose) {
           // delete chip
           this.deleteChip(index);
           this.$input[0].focus();
         } else {
           // select chip
           this.selectChip(index);
         }
</PRE><PRE>         // Default handle click to focus on input
       } else {
         this.$input[0].focus();
       }
     }
</PRE><PRE>     /**
      * Handle Chips Keydown
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleInputFocus&quot;,
</PRE><PRE>     /**
      * Handle Input Focus
      */
     value: function _handleInputFocus() {
       this.$el.addClass('focus');
     }
</PRE><PRE>     /**
      * Handle Input Blur
      */
</PRE><PRE>   }, {
     key: &quot;_handleInputBlur&quot;,
     value: function _handleInputBlur() {
       this.$el.removeClass('focus');
     }
</PRE><PRE>     /**
      * Handle Input Keydown
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleInputKeydown&quot;,
     value: function _handleInputKeydown(e) {
       Chips._keydown = true;
</PRE><PRE>       // enter
       if (e.keyCode === 13) {
         // Override enter if autocompleting.
         if (this.hasAutocomplete &amp;&amp; this.autocomplete &amp;&amp; this.autocomplete.isOpen) {
           return;
         }
</PRE><PRE>         e.preventDefault();
         this.addChip({
           tag: this.$input[0].value
         });
         this.$input[0].value = <I>;</I></PRE><PRE>         // delete or left
       } else if ((e.keyCode === 8 || e.keyCode === 37) &amp;&amp; this.$input[0].value === <I>&amp;&amp; this.chipsData.length) {</I>
         e.preventDefault();
         this.selectChip(this.chipsData.length - 1);
       }
     }
</PRE><PRE>     /**
      * Render Chip
      * @param {chip} chip
      * @return {Element}
      */
</PRE><PRE>   }, {
     key: &quot;_renderChip&quot;,
     value: function _renderChip(chip) {
       if (!chip.tag) {
         return;
       }
</PRE><PRE>       var renderedChip = document.createElement('div');
       var closeIcon = document.createElement('i');
       renderedChip.classList.add('chip');
       renderedChip.textContent = chip.tag;
       renderedChip.setAttribute('tabindex', 0);
       $(closeIcon).addClass('material-icons close');
       closeIcon.textContent = 'close';
</PRE><PRE>       // attach image if needed
       if (chip.image) {
         var img = document.createElement('img');
         img.setAttribute('src', chip.image);
         renderedChip.insertBefore(img, renderedChip.firstChild);
       }
</PRE><PRE>       renderedChip.appendChild(closeIcon);
       return renderedChip;
     }
</PRE><PRE>     /**
      * Render Chips
      */
</PRE><PRE>   }, {
     key: &quot;_renderChips&quot;,
     value: function _renderChips() {
       this.$chips.remove();
       for (var i = 0; i &lt; this.chipsData.length; i++) {
         var chipEl = this._renderChip(this.chipsData[i]);
         this.$el.append(chipEl);
         this.$chips.add(chipEl);
       }
</PRE><PRE>       // move input to end
       this.$el.append(this.$input[0]);
     }
</PRE><PRE>     /**
      * Setup Autocomplete
      */
</PRE><PRE>   }, {
     key: &quot;_setupAutocomplete&quot;,
     value: function _setupAutocomplete() {
       var _this46 = this;
</PRE><PRE>       this.options.autocompleteOptions.onAutocomplete = function (val) {
         _this46.addChip({
           tag: val
         });
         _this46.$input[0].value = <I>;</I>
         _this46.$input[0].focus();
       };
</PRE><PRE>       this.autocomplete = M.Autocomplete.init(this.$input[0], this.options.autocompleteOptions);
     }
</PRE><PRE>     /**
      * Setup Input
      */
</PRE><PRE>   }, {
     key: &quot;_setupInput&quot;,
     value: function _setupInput() {
       this.$input = this.$el.find('input');
       if (!this.$input.length) {
         this.$input = $('&lt;input&gt;&lt;/input&gt;');
         this.$el.append(this.$input);
       }
</PRE><PRE>       this.$input.addClass('input');
     }
</PRE><PRE>     /**
      * Setup Label
      */
</PRE><PRE>   }, {
     key: &quot;_setupLabel&quot;,
     value: function _setupLabel() {
       this.$label = this.$el.find('label');
       if (this.$label.length) {
         this.$label.setAttribute('for', this.$input.attr('id'));
       }
     }
</PRE><PRE>     /**
      * Set placeholder
      */
</PRE><PRE>   }, {
     key: &quot;_setPlaceholder&quot;,
     value: function _setPlaceholder() {
       if (this.chipsData !== undefined &amp;&amp; !this.chipsData.length &amp;&amp; this.options.placeholder) {
         $(this.$input).prop('placeholder', this.options.placeholder);
       } else if ((this.chipsData === undefined || !!this.chipsData.length) &amp;&amp; this.options.secondaryPlaceholder) {
         $(this.$input).prop('placeholder', this.options.secondaryPlaceholder);
       }
     }
</PRE><PRE>     /**
      * Check if chip is valid
      * @param {chip} chip
      */
</PRE><PRE>   }, {
     key: &quot;_isValid&quot;,
     value: function _isValid(chip) {
       if (chip.hasOwnProperty('tag') &amp;&amp; chip.tag !== <I>) {</I>
         var exists = false;
         for (var i = 0; i &lt; this.chipsData.length; i++) {
           if (this.chipsData[i].tag === chip.tag) {
             exists = true;
             break;
           }
         }
         return !exists;
       }
</PRE><PRE>       return false;
     }
</PRE><PRE>     /**
      * Add chip
      * @param {chip} chip
      */
</PRE><PRE>   }, {
     key: &quot;addChip&quot;,
     value: function addChip(chip) {
       if (!this._isValid(chip) || this.chipsData.length &gt;= this.options.limit) {
         return;
       }
</PRE><PRE>       var renderedChip = this._renderChip(chip);
       this.$chips.add(renderedChip);
       this.chipsData.push(chip);
       $(this.$input).before(renderedChip);
       this._setPlaceholder();
</PRE><PRE>       // fire chipAdd callback
       if (typeof this.options.onChipAdd === 'function') {
         this.options.onChipAdd.call(this, this.$el, renderedChip);
       }
     }
</PRE><PRE>     /**
      * Delete chip
      * @param {Number} chip
      */
</PRE><PRE>   }, {
     key: &quot;deleteChip&quot;,
     value: function deleteChip(chipIndex) {
       var $chip = this.$chips.eq(chipIndex);
       this.$chips.eq(chipIndex).remove();
       this.$chips = this.$chips.filter(function (el) {
         return $(el).index() &gt;= 0;
       });
       this.chipsData.splice(chipIndex, 1);
       this._setPlaceholder();
</PRE><PRE>       // fire chipDelete callback
       if (typeof this.options.onChipDelete === 'function') {
         this.options.onChipDelete.call(this, this.$el, $chip[0]);
       }
     }
</PRE><PRE>     /**
      * Select chip
      * @param {Number} chip
      */
</PRE><PRE>   }, {
     key: &quot;selectChip&quot;,
     value: function selectChip(chipIndex) {
       var $chip = this.$chips.eq(chipIndex);
       this._selectedChip = $chip;
       $chip[0].focus();
</PRE><PRE>       // fire chipSelect callback
       if (typeof this.options.onChipSelect === 'function') {
         this.options.onChipSelect.call(this, this.$el, $chip[0]);
       }
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Chips.__proto__ || Object.getPrototypeOf(Chips), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Chips;
     }
   }, {
     key: &quot;_handleChipsKeydown&quot;,
     value: function _handleChipsKeydown(e) {
       Chips._keydown = true;
</PRE><PRE>       var $chips = $(e.target).closest('.chips');
       var chipsKeydown = e.target &amp;&amp; $chips.length;
</PRE><PRE>       // Don't handle keydown inputs on input and textarea
       if ($(e.target).is('input, textarea') || !chipsKeydown) {
         return;
       }
</PRE><PRE>       var currChips = $chips[0].M_Chips;
</PRE><PRE>       // backspace and delete
       if (e.keyCode === 8 || e.keyCode === 46) {
         e.preventDefault();
</PRE><PRE>         var selectIndex = currChips.chipsData.length;
         if (currChips._selectedChip) {
           var index = currChips._selectedChip.index();
           currChips.deleteChip(index);
           currChips._selectedChip = null;
</PRE><PRE>           // Make sure selectIndex doesn't go negative
           selectIndex = Math.max(index - 1, 0);
         }
</PRE><PRE>         if (currChips.chipsData.length) {
           currChips.selectChip(selectIndex);
         }
</PRE><PRE>         // left arrow key
       } else if (e.keyCode === 37) {
         if (currChips._selectedChip) {
           var _selectIndex = currChips._selectedChip.index() - 1;
           if (_selectIndex &lt; 0) {
             return;
           }
           currChips.selectChip(_selectIndex);
         }
</PRE><PRE>         // right arrow key
       } else if (e.keyCode === 39) {
         if (currChips._selectedChip) {
           var _selectIndex2 = currChips._selectedChip.index() + 1;
</PRE><PRE>           if (_selectIndex2 &gt;= currChips.chipsData.length) {
             currChips.$input[0].focus();
           } else {
             currChips.selectChip(_selectIndex2);
           }
         }
       }
     }
</PRE><PRE>     /**
      * Handle Chips Keyup
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleChipsKeyup&quot;,
     value: function _handleChipsKeyup(e) {
       Chips._keydown = false;
     }
</PRE><PRE>     /**
      * Handle Chips Blur
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleChipsBlur&quot;,
     value: function _handleChipsBlur(e) {
       if (!Chips._keydown) {
         var $chips = $(e.target).closest('.chips');
         var currChips = $chips[0].M_Chips;
</PRE><PRE>         currChips._selectedChip = null;
       }
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Chips;
 }(Component);
</PRE><PRE> /**
  * @static
  * @memberof Chips
  */
</PRE><PRE> Chips._keydown = false;
</PRE><PRE> M.Chips = Chips;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Chips, 'chips', 'M_Chips');
 }
</PRE><PRE> $(document).ready(function () {
   // Handle removal of static chips.
   $(document.body).on('click', '.chip .close', function () {
     var $chips = $(this).closest('.chips');
     if ($chips.length &amp;&amp; $chips[0].M_Chips) {
       return;
     }
     $(this).closest('.chip').remove();
   });
 });
</PRE><P>})(cash);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   top: 0,
   bottom: Infinity,
   offset: 0,
   onPositionChange: null
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Pushpin = function (_Component13) {
   _inherits(Pushpin, _Component13);
</PRE><PRE>   /**
    * Construct Pushpin instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Pushpin(el, options) {
     _classCallCheck(this, Pushpin);
</PRE><PRE>     var _this47 = _possibleConstructorReturn(this, (Pushpin.__proto__ || Object.getPrototypeOf(Pushpin)).call(this, Pushpin, el, options));
</PRE><PRE>     _this47.el.M_Pushpin = _this47;
</PRE><PRE>     /**
      * Options for the modal
      * @member Pushpin#options
      */
     _this47.options = $.extend({}, Pushpin.defaults, options);
</PRE><PRE>     _this47.originalOffset = _this47.el.offsetTop;
     Pushpin._pushpins.push(_this47);
     _this47._setupEventHandlers();
     _this47._updatePosition();
     return _this47;
   }
</PRE><PRE>   _createClass(Pushpin, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this.el.style.top = null;
       this._removePinClasses();
       this._removeEventHandlers();
</PRE><PRE>       // Remove pushpin Inst
       var index = Pushpin._pushpins.indexOf(this);
       Pushpin._pushpins.splice(index, 1);
     }
   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       document.addEventListener('scroll', Pushpin._updateElements);
     }
   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       document.removeEventListener('scroll', Pushpin._updateElements);
     }
   }, {
     key: &quot;_updatePosition&quot;,
     value: function _updatePosition() {
       var scrolled = M.getDocumentScrollTop() + this.options.offset;
</PRE><PRE>       if (this.options.top &lt;= scrolled &amp;&amp; this.options.bottom &gt;= scrolled &amp;&amp; !this.el.classList.contains('pinned')) {
         this._removePinClasses();
         this.el.style.top = this.options.offset + &quot;px&quot;;
         this.el.classList.add('pinned');
</PRE><PRE>         // onPositionChange callback
         if (typeof this.options.onPositionChange === 'function') {
           this.options.onPositionChange.call(this, 'pinned');
         }
       }
</PRE><PRE>       // Add pin-top (when scrolled position is above top)
       if (scrolled &lt; this.options.top &amp;&amp; !this.el.classList.contains('pin-top')) {
         this._removePinClasses();
         this.el.style.top = 0;
         this.el.classList.add('pin-top');
</PRE><PRE>         // onPositionChange callback
         if (typeof this.options.onPositionChange === 'function') {
           this.options.onPositionChange.call(this, 'pin-top');
         }
       }
</PRE><PRE>       // Add pin-bottom (when scrolled position is below bottom)
       if (scrolled &gt; this.options.bottom &amp;&amp; !this.el.classList.contains('pin-bottom')) {
         this._removePinClasses();
         this.el.classList.add('pin-bottom');
         this.el.style.top = this.options.bottom - this.originalOffset + &quot;px&quot;;
</PRE><PRE>         // onPositionChange callback
         if (typeof this.options.onPositionChange === 'function') {
           this.options.onPositionChange.call(this, 'pin-bottom');
         }
       }
     }
   }, {
     key: &quot;_removePinClasses&quot;,
     value: function _removePinClasses() {
       // IE 11 bug (can't remove multiple classes in one line)
       this.el.classList.remove('pin-top');
       this.el.classList.remove('pinned');
       this.el.classList.remove('pin-bottom');
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Pushpin.__proto__ || Object.getPrototypeOf(Pushpin), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Pushpin;
     }
   }, {
     key: &quot;_updateElements&quot;,
     value: function _updateElements() {
       for (var elIndex in Pushpin._pushpins) {
         var pInstance = Pushpin._pushpins[elIndex];
         pInstance._updatePosition();
       }
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Pushpin;
 }(Component);
</PRE><PRE> /**
  * @static
  * @memberof Pushpin
  */
</PRE><PRE> Pushpin._pushpins = [];
</PRE><PRE> M.Pushpin = Pushpin;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Pushpin, 'pushpin', 'M_Pushpin');
 }
</PRE><P>})(cash);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   direction: 'top',
   hoverEnabled: true,
   toolbarEnabled: false
 };
</PRE><PRE> $.fn.reverse = [].reverse;
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var FloatingActionButton = function (_Component14) {
   _inherits(FloatingActionButton, _Component14);
</PRE><PRE>   /**
    * Construct FloatingActionButton instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function FloatingActionButton(el, options) {
     _classCallCheck(this, FloatingActionButton);
</PRE><PRE>     var _this48 = _possibleConstructorReturn(this, (FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton)).call(this, FloatingActionButton, el, options));
</PRE><PRE>     _this48.el.M_FloatingActionButton = _this48;
</PRE><PRE>     /**
      * Options for the fab
      * @member FloatingActionButton#options
      * @prop {Boolean} [direction] - Direction fab menu opens
      * @prop {Boolean} [hoverEnabled=true] - Enable hover vs click
      * @prop {Boolean} [toolbarEnabled=false] - Enable toolbar transition
      */
     _this48.options = $.extend({}, FloatingActionButton.defaults, options);
</PRE><PRE>     _this48.isOpen = false;
     _this48.$anchor = _this48.$el.children('a').first();
     _this48.$menu = _this48.$el.children('ul').first();
     _this48.$floatingBtns = _this48.$el.find('ul .btn-floating');
     _this48.$floatingBtnsReverse = _this48.$el.find('ul .btn-floating').reverse();
     _this48.offsetY = 0;
     _this48.offsetX = 0;
</PRE><PRE>     _this48.$el.addClass(&quot;direction-&quot; + _this48.options.direction);
     if (_this48.options.direction === 'top') {
       _this48.offsetY = 40;
     } else if (_this48.options.direction === 'right') {
       _this48.offsetX = -40;
     } else if (_this48.options.direction === 'bottom') {
       _this48.offsetY = -40;
     } else {
       _this48.offsetX = 40;
     }
     _this48._setupEventHandlers();
     return _this48;
   }
</PRE><PRE>   _createClass(FloatingActionButton, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this.el.M_FloatingActionButton = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleFABClickBound = this._handleFABClick.bind(this);
       this._handleOpenBound = this.open.bind(this);
       this._handleCloseBound = this.close.bind(this);
</PRE><PRE>       if (this.options.hoverEnabled &amp;&amp; !this.options.toolbarEnabled) {
         this.el.addEventListener('mouseenter', this._handleOpenBound);
         this.el.addEventListener('mouseleave', this._handleCloseBound);
       } else {
         this.el.addEventListener('click', this._handleFABClickBound);
       }
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       if (this.options.hoverEnabled &amp;&amp; !this.options.toolbarEnabled) {
         this.el.removeEventListener('mouseenter', this._handleOpenBound);
         this.el.removeEventListener('mouseleave', this._handleCloseBound);
       } else {
         this.el.removeEventListener('click', this._handleFABClickBound);
       }
     }
</PRE><PRE>     /**
      * Handle FAB Click
      */
</PRE><PRE>   }, {
     key: &quot;_handleFABClick&quot;,
     value: function _handleFABClick() {
       if (this.isOpen) {
         this.close();
       } else {
         this.open();
       }
     }
</PRE><PRE>     /**
      * Handle Document Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleDocumentClick&quot;,
     value: function _handleDocumentClick(e) {
       if (!$(e.target).closest(this.$menu).length) {
         this.close();
       }
     }
</PRE><PRE>     /**
      * Open FAB
      */
</PRE><PRE>   }, {
     key: &quot;open&quot;,
     value: function open() {
       if (this.isOpen) {
         return;
       }
</PRE><PRE>       if (this.options.toolbarEnabled) {
         this._animateInToolbar();
       } else {
         this._animateInFAB();
       }
       this.isOpen = true;
     }
</PRE><PRE>     /**
      * Close FAB
      */
</PRE><PRE>   }, {
     key: &quot;close&quot;,
     value: function close() {
       if (!this.isOpen) {
         return;
       }
</PRE><PRE>       if (this.options.toolbarEnabled) {
         window.removeEventListener('scroll', this._handleCloseBound, true);
         document.body.removeEventListener('click', this._handleDocumentClickBound, true);
         this._animateOutToolbar();
       } else {
         this._animateOutFAB();
       }
       this.isOpen = false;
     }
</PRE><PRE>     /**
      * Classic FAB Menu open
      */
</PRE><PRE>   }, {
     key: &quot;_animateInFAB&quot;,
     value: function _animateInFAB() {
       var _this49 = this;
</PRE><PRE>       this.$el.addClass('active');
</PRE><PRE>       var time = 0;
       this.$floatingBtnsReverse.each(function (el) {
         anim({
           targets: el,
           opacity: 1,
           scale: [0.4, 1],
           translateY: [_this49.offsetY, 0],
           translateX: [_this49.offsetX, 0],
           duration: 275,
           delay: time,
           easing: 'easeInOutQuad'
         });
         time += 40;
       });
     }
</PRE><PRE>     /**
      * Classic FAB Menu close
      */
</PRE><PRE>   }, {
     key: &quot;_animateOutFAB&quot;,
     value: function _animateOutFAB() {
       var _this50 = this;
</PRE><PRE>       this.$floatingBtnsReverse.each(function (el) {
         anim.remove(el);
         anim({
           targets: el,
           opacity: 0,
           scale: 0.4,
           translateY: _this50.offsetY,
           translateX: _this50.offsetX,
           duration: 175,
           easing: 'easeOutQuad',
           complete: function () {
             _this50.$el.removeClass('active');
           }
         });
       });
     }
</PRE><PRE>     /**
      * Toolbar transition Menu open
      */
</PRE><PRE>   }, {
     key: &quot;_animateInToolbar&quot;,
     value: function _animateInToolbar() {
       var _this51 = this;
</PRE><PRE>       var scaleFactor = void 0;
       var windowWidth = window.innerWidth;
       var windowHeight = window.innerHeight;
       var btnRect = this.el.getBoundingClientRect();
</PRE>
        var backdrop = $('');
<PRE>       var fabColor = this.$anchor.css('background-color');
       this.$anchor.append(backdrop);
</PRE><PRE>       this.offsetX = btnRect.left - windowWidth / 2 + btnRect.width / 2;
       this.offsetY = windowHeight - btnRect.bottom;
       scaleFactor = windowWidth / backdrop[0].clientWidth;
       this.btnBottom = btnRect.bottom;
       this.btnLeft = btnRect.left;
       this.btnWidth = btnRect.width;
</PRE><PRE>       // Set initial state
       this.$el.addClass('active');
       this.$el.css({
         'text-align': 'center',
         width: '100%',
         bottom: 0,
         left: 0,
         transform: 'translateX(' + this.offsetX + 'px)',
         transition: 'none'
       });
       this.$anchor.css({
         transform: 'translateY(' + -this.offsetY + 'px)',
         transition: 'none'
       });
       backdrop.css({
         'background-color': fabColor
       });
</PRE><PRE>       setTimeout(function () {
         _this51.$el.css({
           transform: <I>,</I>
           transition: 'transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s'
         });
         _this51.$anchor.css({
           overflow: 'visible',
           transform: <I>,</I>
           transition: 'transform .2s'
         });
</PRE><PRE>         setTimeout(function () {
           _this51.$el.css({
             overflow: 'hidden',
             'background-color': fabColor
           });
           backdrop.css({
             transform: 'scale(' + scaleFactor + ')',
             transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'
           });
           _this51.$menu.children('li').children('a').css({
             opacity: 1
           });
</PRE><PRE>           // Scroll to close.
           _this51._handleDocumentClickBound = _this51._handleDocumentClick.bind(_this51);
           window.addEventListener('scroll', _this51._handleCloseBound, true);
           document.body.addEventListener('click', _this51._handleDocumentClickBound, true);
         }, 100);
       }, 0);
     }
</PRE><PRE>     /**
      * Toolbar transition Menu close
      */
</PRE><PRE>   }, {
     key: &quot;_animateOutToolbar&quot;,
     value: function _animateOutToolbar() {
       var _this52 = this;
</PRE><PRE>       var windowWidth = window.innerWidth;
       var windowHeight = window.innerHeight;
       var backdrop = this.$el.find('.fab-backdrop');
       var fabColor = this.$anchor.css('background-color');
</PRE><PRE>       this.offsetX = this.btnLeft - windowWidth / 2 + this.btnWidth / 2;
       this.offsetY = windowHeight - this.btnBottom;
</PRE><PRE>       // Hide backdrop
       this.$el.removeClass('active');
       this.$el.css({
         'background-color': 'transparent',
         transition: 'none'
       });
       this.$anchor.css({
         transition: 'none'
       });
       backdrop.css({
         transform: 'scale(0)',
         'background-color': fabColor
       });
       this.$menu.children('li').children('a').css({
         opacity: 
       });
</PRE><PRE>       setTimeout(function () {
         backdrop.remove();
</PRE><PRE>         // Set initial state.
         _this52.$el.css({
           'text-align': <I>,</I>
           width: <I>,</I>
           bottom: <I>,</I>
           left: <I>,</I>
           overflow: <I>,</I>
           'background-color': <I>,</I>
           transform: 'translate3d(' + -_this52.offsetX + 'px,0,0)'
         });
         _this52.$anchor.css({
           overflow: <I>,</I>
           transform: 'translate3d(0,' + _this52.offsetY + 'px,0)'
         });
</PRE><PRE>         setTimeout(function () {
           _this52.$el.css({
             transform: 'translate3d(0,0,0)',
             transition: 'transform .2s'
           });
           _this52.$anchor.css({
             transform: 'translate3d(0,0,0)',
             transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'
           });
         }, 20);
       }, 200);
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_FloatingActionButton;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return FloatingActionButton;
 }(Component);
</PRE><PRE> M.FloatingActionButton = FloatingActionButton;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(FloatingActionButton, 'floatingActionButton', 'M_FloatingActionButton');
 }
</PRE><P>})(cash, M.anime);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   // Close when date is selected
   autoClose: false,
</PRE><PRE>   // the default output format for the input field value
   format: 'mmm dd, yyyy',
</PRE><PRE>   // Used to create date object from current input string
   parse: null,
</PRE><PRE>   // The initial date to view when first opened
   defaultDate: null,
</PRE><PRE>   // Make the `defaultDate` the initial selected value
   setDefaultDate: false,
</PRE><PRE>   disableWeekends: false,
</PRE><PRE>   disableDayFn: null,
</PRE><PRE>   // First day of week (0: Sunday, 1: Monday etc)
   firstDay: 0,
</PRE><PRE>   // The earliest date that can be selected
   minDate: null,
   // Thelatest date that can be selected
   maxDate: null,
</PRE><PRE>   // Number of years either side, or array of upper/lower range
   yearRange: 10,
</PRE><PRE>   // used internally (don't config outside)
   minYear: 0,
   maxYear: 9999,
   minMonth: undefined,
   maxMonth: undefined,
</PRE><PRE>   startRange: null,
   endRange: null,
</PRE><PRE>   isRTL: false,
</PRE><PRE>   // Render the month after year in the calendar title
   showMonthAfterYear: false,
</PRE><PRE>   // Render days of the calendar grid that fall in the next or previous month
   showDaysInNextAndPreviousMonths: false,
</PRE><PRE>   // Specify a DOM element to render the calendar in
   container: null,
</PRE><PRE>   // Show clear button
   showClearBtn: false,
</PRE><PRE>   // internationalization
   i18n: {
     cancel: 'Cancel',
     clear: 'Clear',
     done: 'Ok',
     previousMonth: '‹',
     nextMonth: '›',
     months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
     monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
     weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
     weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
     weekdaysAbbrev: ['S', 'M', 'T', 'W', 'T', 'F', 'S']
   },
</PRE><PRE>   // events array
   events: [],
</PRE><PRE>   // callback function
   onSelect: null,
   onOpen: null,
   onClose: null,
   onDraw: null
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Datepicker = function (_Component15) {
   _inherits(Datepicker, _Component15);
</PRE><PRE>   /**
    * Construct Datepicker instance and set up overlay
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Datepicker(el, options) {
     _classCallCheck(this, Datepicker);
</PRE><PRE>     var _this53 = _possibleConstructorReturn(this, (Datepicker.__proto__ || Object.getPrototypeOf(Datepicker)).call(this, Datepicker, el, options));
</PRE><PRE>     _this53.el.M_Datepicker = _this53;
</PRE><PRE>     _this53.options = $.extend({}, Datepicker.defaults, options);
</PRE><PRE>     // make sure i18n defaults are not lost when only few i18n option properties are passed
     if (!!options &amp;&amp; options.hasOwnProperty('i18n') &amp;&amp; typeof options.i18n === 'object') {
       _this53.options.i18n = $.extend({}, Datepicker.defaults.i18n, options.i18n);
     }
</PRE><PRE>     // Remove time component from minDate and maxDate options
     if (_this53.options.minDate) _this53.options.minDate.setHours(0, 0, 0, 0);
     if (_this53.options.maxDate) _this53.options.maxDate.setHours(0, 0, 0, 0);
</PRE><PRE>     _this53.id = M.guid();
</PRE><PRE>     _this53._setupVariables();
     _this53._insertHTMLIntoDOM();
     _this53._setupModal();
</PRE><PRE>     _this53._setupEventHandlers();
</PRE><PRE>     if (!_this53.options.defaultDate) {
       _this53.options.defaultDate = new Date(Date.parse(_this53.el.value));
     }
</PRE><PRE>     var defDate = _this53.options.defaultDate;
     if (Datepicker._isDate(defDate)) {
       if (_this53.options.setDefaultDate) {
         _this53.setDate(defDate, true);
         _this53.setInputValue();
       } else {
         _this53.gotoDate(defDate);
       }
     } else {
       _this53.gotoDate(new Date());
     }
</PRE><PRE>     /**
      * Describes open/close state of datepicker
      * @type {Boolean}
      */
     _this53.isOpen = false;
     return _this53;
   }
</PRE><PRE>   _createClass(Datepicker, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this.modal.destroy();
       $(this.modalEl).remove();
       this.destroySelects();
       this.el.M_Datepicker = undefined;
     }
   }, {
     key: &quot;destroySelects&quot;,
     value: function destroySelects() {
       var oldYearSelect = this.calendarEl.querySelector('.orig-select-year');
       if (oldYearSelect) {
         M.FormSelect.getInstance(oldYearSelect).destroy();
       }
       var oldMonthSelect = this.calendarEl.querySelector('.orig-select-month');
       if (oldMonthSelect) {
         M.FormSelect.getInstance(oldMonthSelect).destroy();
       }
     }
   }, {
     key: &quot;_insertHTMLIntoDOM&quot;,
     value: function _insertHTMLIntoDOM() {
       if (this.options.showClearBtn) {
         $(this.clearBtn).css({ visibility: <I> });</I>
         this.clearBtn.innerHTML = this.options.i18n.clear;
       }
</PRE><PRE>       this.doneBtn.innerHTML = this.options.i18n.done;
       this.cancelBtn.innerHTML = this.options.i18n.cancel;
</PRE><PRE>       if (this.options.container) {
         this.$modalEl.appendTo(this.options.container);
       } else {
         this.$modalEl.insertBefore(this.el);
       }
     }
   }, {
     key: &quot;_setupModal&quot;,
     value: function _setupModal() {
       var _this54 = this;
</PRE><PRE>       this.modalEl.id = 'modal-' + this.id;
       this.modal = M.Modal.init(this.modalEl, {
         onCloseEnd: function () {
           _this54.isOpen = false;
         }
       });
     }
   }, {
     key: &quot;toString&quot;,
     value: function toString(format) {
       var _this55 = this;
</PRE><PRE>       format = format || this.options.format;
       if (!Datepicker._isDate(this.date)) {
         return <I>;</I>
       }
</PRE><PRE>       var formatArray = format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);
       var formattedDate = formatArray.map(function (label) {
         if (_this55.formats[label]) {
           return _this55.formats[label]();
         }
</PRE><PRE>         return label;
       }).join(<I>);</I>
       return formattedDate;
     }
   }, {
     key: &quot;setDate&quot;,
     value: function setDate(date, preventOnSelect) {
       if (!date) {
         this.date = null;
         this._renderDateDisplay();
         return this.draw();
       }
       if (typeof date === 'string') {
         date = new Date(Date.parse(date));
       }
       if (!Datepicker._isDate(date)) {
         return;
       }
</PRE><PRE>       var min = this.options.minDate,
           max = this.options.maxDate;
</PRE><PRE>       if (Datepicker._isDate(min) &amp;&amp; date &lt; min) {
         date = min;
       } else if (Datepicker._isDate(max) &amp;&amp; date &gt; max) {
         date = max;
       }
</PRE><PRE>       this.date = new Date(date.getTime());
</PRE><PRE>       this._renderDateDisplay();
</PRE><PRE>       Datepicker._setToStartOfDay(this.date);
       this.gotoDate(this.date);
</PRE><PRE>       if (!preventOnSelect &amp;&amp; typeof this.options.onSelect === 'function') {
         this.options.onSelect.call(this, this.date);
       }
     }
   }, {
     key: &quot;setInputValue&quot;,
     value: function setInputValue() {
       this.el.value = this.toString();
       this.$el.trigger('change', { firedBy: this });
     }
   }, {
     key: &quot;_renderDateDisplay&quot;,
     value: function _renderDateDisplay() {
       var displayDate = Datepicker._isDate(this.date) ? this.date : new Date();
       var i18n = this.options.i18n;
       var day = i18n.weekdaysShort[displayDate.getDay()];
       var month = i18n.monthsShort[displayDate.getMonth()];
       var date = displayDate.getDate();
       this.yearTextEl.innerHTML = displayDate.getFullYear();
       this.dateTextEl.innerHTML = day + &quot;, &quot; + month + &quot; &quot; + date;
     }
</PRE><PRE>     /**
      * change view to a specific date
      */
</PRE><PRE>   }, {
     key: &quot;gotoDate&quot;,
     value: function gotoDate(date) {
       var newCalendar = true;
</PRE><PRE>       if (!Datepicker._isDate(date)) {
         return;
       }
</PRE><PRE>       if (this.calendars) {
         var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
             lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1),
             visibleDate = date.getTime();
         // get the end of the month
         lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
         lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
         newCalendar = visibleDate &lt; firstVisibleDate.getTime() || lastVisibleDate.getTime() &lt; visibleDate;
       }
</PRE><PRE>       if (newCalendar) {
         this.calendars = [{
           month: date.getMonth(),
           year: date.getFullYear()
         }];
       }
</PRE><PRE>       this.adjustCalendars();
     }
   }, {
     key: &quot;adjustCalendars&quot;,
     value: function adjustCalendars() {
       this.calendars[0] = this.adjustCalendar(this.calendars[0]);
       this.draw();
     }
   }, {
     key: &quot;adjustCalendar&quot;,
     value: function adjustCalendar(calendar) {
       if (calendar.month &lt; 0) {
         calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
         calendar.month += 12;
       }
       if (calendar.month &gt; 11) {
         calendar.year += Math.floor(Math.abs(calendar.month) / 12);
         calendar.month -= 12;
       }
       return calendar;
     }
   }, {
     key: &quot;nextMonth&quot;,
     value: function nextMonth() {
       this.calendars[0].month++;
       this.adjustCalendars();
     }
   }, {
     key: &quot;prevMonth&quot;,
     value: function prevMonth() {
       this.calendars[0].month--;
       this.adjustCalendars();
     }
   }, {
     key: &quot;render&quot;,
     value: function render(year, month, randId) {
       var opts = this.options,
           now = new Date(),
           days = Datepicker._getDaysInMonth(year, month),
           before = new Date(year, month, 1).getDay(),
           data = [],
           row = [];
       Datepicker._setToStartOfDay(now);
       if (opts.firstDay &gt; 0) {
         before -= opts.firstDay;
         if (before &lt; 0) {
           before += 7;
         }
       }
       var previousMonth = month === 0 ? 11 : month - 1,
           nextMonth = month === 11 ? 0 : month + 1,
           yearOfPreviousMonth = month === 0 ? year - 1 : year,
           yearOfNextMonth = month === 11 ? year + 1 : year,
           daysInPreviousMonth = Datepicker._getDaysInMonth(yearOfPreviousMonth, previousMonth);
       var cells = days + before,
           after = cells;
       while (after &gt; 7) {
         after -= 7;
       }
       cells += 7 - after;
       var isWeekSelected = false;
       for (var i = 0, r = 0; i &lt; cells; i++) {
         var day = new Date(year, month, 1 + (i - before)),
             isSelected = Datepicker._isDate(this.date) ? Datepicker._compareDates(day, this.date) : false,
             isToday = Datepicker._compareDates(day, now),
             hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
             isEmpty = i &lt; before || i &gt;= days + before,
             dayNumber = 1 + (i - before),
             monthNumber = month,
             yearNumber = year,
             isStartRange = opts.startRange &amp;&amp; Datepicker._compareDates(opts.startRange, day),
             isEndRange = opts.endRange &amp;&amp; Datepicker._compareDates(opts.endRange, day),
             isInRange = opts.startRange &amp;&amp; opts.endRange &amp;&amp; opts.startRange &lt; day &amp;&amp; day &lt; opts.endRange,
             isDisabled = opts.minDate &amp;&amp; day &lt; opts.minDate || opts.maxDate &amp;&amp; day &gt; opts.maxDate || opts.disableWeekends &amp;&amp; Datepicker._isWeekend(day) || opts.disableDayFn &amp;&amp; opts.disableDayFn(day);
</PRE><PRE>         if (isEmpty) {
           if (i &lt; before) {
             dayNumber = daysInPreviousMonth + dayNumber;
             monthNumber = previousMonth;
             yearNumber = yearOfPreviousMonth;
           } else {
             dayNumber = dayNumber - days;
             monthNumber = nextMonth;
             yearNumber = yearOfNextMonth;
           }
         }
</PRE><PRE>         var dayConfig = {
           day: dayNumber,
           month: monthNumber,
           year: yearNumber,
           hasEvent: hasEvent,
           isSelected: isSelected,
           isToday: isToday,
           isDisabled: isDisabled,
           isEmpty: isEmpty,
           isStartRange: isStartRange,
           isEndRange: isEndRange,
           isInRange: isInRange,
           showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths
         };
</PRE><PRE>         row.push(this.renderDay(dayConfig));
</PRE><PRE>         if (++r === 7) {
           data.push(this.renderRow(row, opts.isRTL, isWeekSelected));
           row = [];
           r = 0;
           isWeekSelected = false;
         }
       }
       return this.renderTable(opts, data, randId);
     }
   }, {
     key: &quot;renderDay&quot;,
     value: function renderDay(opts) {
       var arr = [];
       var ariaSelected = 'false';
       if (opts.isEmpty) {
         if (opts.showDaysInNextAndPreviousMonths) {
           arr.push('is-outside-current-month');
           arr.push('is-selection-disabled');
         } else {
           return '&lt;td class=&quot;is-empty&quot;&gt;&lt;/td&gt;';
         }
       }
       if (opts.isDisabled) {
         arr.push('is-disabled');
       }
</PRE><PRE>       if (opts.isToday) {
         arr.push('is-today');
       }
       if (opts.isSelected) {
         arr.push('is-selected');
         ariaSelected = 'true';
       }
       if (opts.hasEvent) {
         arr.push('has-event');
       }
       if (opts.isInRange) {
         arr.push('is-inrange');
       }
       if (opts.isStartRange) {
         arr.push('is-startrange');
       }
       if (opts.isEndRange) {
         arr.push('is-endrange');
       }
       return &quot;&lt;td data-day=\&quot;&quot; + opts.day + &quot;\&quot; class=\&quot;&quot; + arr.join(' ') + &quot;\&quot; aria-selected=\&quot;&quot; + ariaSelected + &quot;\&quot;&gt;&quot; + (&quot;&lt;button class=\&quot;datepicker-day-button\&quot; type=\&quot;button\&quot; data-year=\&quot;&quot; + opts.year + &quot;\&quot; data-month=\&quot;&quot; + opts.month + &quot;\&quot; data-day=\&quot;&quot; + opts.day + &quot;\&quot;&gt;&quot; + opts.day + &quot;&lt;/button&gt;&quot;) + '&lt;/td&gt;';
     }
   }, {
     key: &quot;renderRow&quot;,
     value: function renderRow(days, isRTL, isRowSelected) {
       return '&lt;tr class=&quot;datepicker-row' + (isRowSelected ? ' is-selected' : <I>) + '&quot;&gt;' + (isRTL ? days.reverse() : days).join(</I>) + '&lt;/tr&gt;';
     }
   }, {
     key: &quot;renderTable&quot;,
     value: function renderTable(opts, data, randId) {
</PRE>
        return '<DIV class="datepicker-table-wrapper"><TABLE cellpadding="0" cellspacing="0" class="datepicker-table">' + this.renderHead(opts) + this.renderBody(data) + '</TABLE></DIV>';
<PRE>     }
   }, {
     key: &quot;renderHead&quot;,
     value: function renderHead(opts) {
       var i = void 0,
           arr = [];
       for (i = 0; i &lt; 7; i++) {
         arr.push(&quot;&lt;th scope=\&quot;col\&quot;&gt;<ABBR>&quot; + this.renderDayName(opts, i, true) + &quot;</ABBR>&lt;/th&gt;&quot;);
       }
       return '&lt;thead&gt;&lt;tr&gt;' + (opts.isRTL ? arr.reverse() : arr).join(<I>) + '&lt;/tr&gt;&lt;/thead&gt;';</I>
     }
   }, {
     key: &quot;renderBody&quot;,
     value: function renderBody(rows) {
       return '&lt;tbody&gt;' + rows.join(<I>) + '&lt;/tbody&gt;';</I>
     }
   }, {
     key: &quot;renderTitle&quot;,
     value: function renderTitle(instance, c, year, month, refYear, randId) {
       var i = void 0,
           j = void 0,
           arr = void 0,
           opts = this.options,
           isMinYear = year === opts.minYear,
           isMaxYear = year === opts.maxYear,
</PRE>
            html = '<DIV id=".27_.2B_randId_.2B_.27" class="datepicker-controls">',
<PRE>           monthHtml = void 0,
           yearHtml = void 0,
           prev = true,
           next = true;
</PRE><PRE>       for (arr = [], i = 0; i &lt; 12; i++) {
         arr.push('&lt;option value=&quot;' + (year === refYear ? i - c : 12 + i - c) + '&quot;' + (i === month ? ' selected=&quot;selected&quot;' : <I>) + (isMinYear &amp;&amp; i &lt; opts.minMonth || isMaxYear &amp;&amp; i &gt; opts.maxMonth ? 'disabled=&quot;disabled&quot;' : </I>) + '&gt;' + opts.i18n.months[i] + '&lt;/option&gt;');
       }
</PRE><PRE>       monthHtml = '&lt;select class=&quot;datepicker-select orig-select-month&quot; tabindex=&quot;-1&quot;&gt;' + arr.join(<I>) + '&lt;/select&gt;';</I></PRE><PRE>       if ($.isArray(opts.yearRange)) {
         i = opts.yearRange[0];
         j = opts.yearRange[1] + 1;
       } else {
         i = year - opts.yearRange;
         j = 1 + year + opts.yearRange;
       }
</PRE><PRE>       for (arr = []; i &lt; j &amp;&amp; i &lt;= opts.maxYear; i++) {
         if (i &gt;= opts.minYear) {
           arr.push(&quot;&lt;option value=\&quot;&quot; + i + &quot;\&quot; &quot; + (i === year ? 'selected=&quot;selected&quot;' : <I>) + &quot;&gt;&quot; + i + &quot;&lt;/option&gt;&quot;);</I>
         }
       }
</PRE><PRE>       yearHtml = &quot;&lt;select class=\&quot;datepicker-select orig-select-year\&quot; tabindex=\&quot;-1\&quot;&gt;&quot; + arr.join(<I>) + &quot;&lt;/select&gt;&quot;;</I></PRE><PRE>       var leftArrow = '&lt;svg fill=&quot;#000000&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot;&gt;&lt;path d=&quot;M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z&quot;/&gt;&lt;path d=&quot;M0-.5h24v24H0z&quot; fill=&quot;none&quot;/&gt;&lt;/svg&gt;';
       html += &quot;&lt;button class=\&quot;month-prev&quot; + (prev ? <I> : ' is-disabled') + &quot;\&quot; type=\&quot;button\&quot;&gt;&quot; + leftArrow + &quot;&lt;/button&gt;&quot;;</I></PRE>
        html += '<DIV class="selects-container">';
<PRE>       if (opts.showMonthAfterYear) {
         html += yearHtml + monthHtml;
       } else {
         html += monthHtml + yearHtml;
       }
</PRE>
        html += '</DIV>';
<PRE>       if (isMinYear &amp;&amp; (month === 0 || opts.minMonth &gt;= month)) {
         prev = false;
       }
</PRE><PRE>       if (isMaxYear &amp;&amp; (month === 11 || opts.maxMonth &lt;= month)) {
         next = false;
       }
</PRE><PRE>       var rightArrow = '&lt;svg fill=&quot;#000000&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot;&gt;&lt;path d=&quot;M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z&quot;/&gt;&lt;path d=&quot;M0-.25h24v24H0z&quot; fill=&quot;none&quot;/&gt;&lt;/svg&gt;';
       html += &quot;&lt;button class=\&quot;month-next&quot; + (next ? <I> : ' is-disabled') + &quot;\&quot; type=\&quot;button\&quot;&gt;&quot; + rightArrow + &quot;&lt;/button&gt;&quot;;</I></PRE>
        return html += '</DIV>';
<PRE>     }
</PRE><PRE>     /**
      * refresh the HTML
      */
</PRE><PRE>   }, {
     key: &quot;draw&quot;,
     value: function draw(force) {
       if (!this.isOpen &amp;&amp; !force) {
         return;
       }
       var opts = this.options,
           minYear = opts.minYear,
           maxYear = opts.maxYear,
           minMonth = opts.minMonth,
           maxMonth = opts.maxMonth,
           html = <I>,</I>
           randId = void 0;
</PRE><PRE>       if (this._y &lt;= minYear) {
         this._y = minYear;
         if (!isNaN(minMonth) &amp;&amp; this._m &lt; minMonth) {
           this._m = minMonth;
         }
       }
       if (this._y &gt;= maxYear) {
         this._y = maxYear;
         if (!isNaN(maxMonth) &amp;&amp; this._m &gt; maxMonth) {
           this._m = maxMonth;
         }
       }
</PRE><PRE>       randId = 'datepicker-title-' + Math.random().toString(36).replace(/[^a-z]+/g, <I>).substr(0, 2);</I></PRE><PRE>       for (var c = 0; c &lt; 1; c++) {
         this._renderDateDisplay();
         html += this.renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId);
       }
</PRE><PRE>       this.destroySelects();
</PRE><PRE>       this.calendarEl.innerHTML = html;
</PRE><PRE>       // Init Materialize Select
       var yearSelect = this.calendarEl.querySelector('.orig-select-year');
       var monthSelect = this.calendarEl.querySelector('.orig-select-month');
       M.FormSelect.init(yearSelect, {
         classes: 'select-year',
         dropdownOptions: { container: document.body, constrainWidth: false }
       });
       M.FormSelect.init(monthSelect, {
         classes: 'select-month',
         dropdownOptions: { container: document.body, constrainWidth: false }
       });
</PRE><PRE>       // Add change handlers for select
       yearSelect.addEventListener('change', this._handleYearChange.bind(this));
       monthSelect.addEventListener('change', this._handleMonthChange.bind(this));
</PRE><PRE>       if (typeof this.options.onDraw === 'function') {
         this.options.onDraw(this);
       }
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
       this._handleInputClickBound = this._handleInputClick.bind(this);
       this._handleInputChangeBound = this._handleInputChange.bind(this);
       this._handleCalendarClickBound = this._handleCalendarClick.bind(this);
       this._finishSelectionBound = this._finishSelection.bind(this);
       this._handleMonthChange = this._handleMonthChange.bind(this);
       this._closeBound = this.close.bind(this);
</PRE><PRE>       this.el.addEventListener('click', this._handleInputClickBound);
       this.el.addEventListener('keydown', this._handleInputKeydownBound);
       this.el.addEventListener('change', this._handleInputChangeBound);
       this.calendarEl.addEventListener('click', this._handleCalendarClickBound);
       this.doneBtn.addEventListener('click', this._finishSelectionBound);
       this.cancelBtn.addEventListener('click', this._closeBound);
</PRE><PRE>       if (this.options.showClearBtn) {
         this._handleClearClickBound = this._handleClearClick.bind(this);
         this.clearBtn.addEventListener('click', this._handleClearClickBound);
       }
     }
   }, {
     key: &quot;_setupVariables&quot;,
     value: function _setupVariables() {
       var _this56 = this;
</PRE><PRE>       this.$modalEl = $(Datepicker._template);
       this.modalEl = this.$modalEl[0];
</PRE><PRE>       this.calendarEl = this.modalEl.querySelector('.datepicker-calendar');
</PRE><PRE>       this.yearTextEl = this.modalEl.querySelector('.year-text');
       this.dateTextEl = this.modalEl.querySelector('.date-text');
       if (this.options.showClearBtn) {
         this.clearBtn = this.modalEl.querySelector('.datepicker-clear');
       }
       this.doneBtn = this.modalEl.querySelector('.datepicker-done');
       this.cancelBtn = this.modalEl.querySelector('.datepicker-cancel');
</PRE><PRE>       this.formats = {
         d: function () {
           return _this56.date.getDate();
         },
         dd: function () {
           var d = _this56.date.getDate();
           return (d &lt; 10 ? '0' : <I>) + d;</I>
         },
         ddd: function () {
           return _this56.options.i18n.weekdaysShort[_this56.date.getDay()];
         },
         dddd: function () {
           return _this56.options.i18n.weekdays[_this56.date.getDay()];
         },
         m: function () {
           return _this56.date.getMonth() + 1;
         },
         mm: function () {
           var m = _this56.date.getMonth() + 1;
           return (m &lt; 10 ? '0' : <I>) + m;</I>
         },
         mmm: function () {
           return _this56.options.i18n.monthsShort[_this56.date.getMonth()];
         },
         mmmm: function () {
           return _this56.options.i18n.months[_this56.date.getMonth()];
         },
         yy: function () {
           return (<I> + _this56.date.getFullYear()).slice(2);</I>
         },
         yyyy: function () {
           return _this56.date.getFullYear();
         }
       };
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('click', this._handleInputClickBound);
       this.el.removeEventListener('keydown', this._handleInputKeydownBound);
       this.el.removeEventListener('change', this._handleInputChangeBound);
       this.calendarEl.removeEventListener('click', this._handleCalendarClickBound);
     }
   }, {
     key: &quot;_handleInputClick&quot;,
     value: function _handleInputClick() {
       this.open();
     }
   }, {
     key: &quot;_handleInputKeydown&quot;,
     value: function _handleInputKeydown(e) {
       if (e.which === M.keys.ENTER) {
         e.preventDefault();
         this.open();
       }
     }
   }, {
     key: &quot;_handleCalendarClick&quot;,
     value: function _handleCalendarClick(e) {
       if (!this.isOpen) {
         return;
       }
</PRE><PRE>       var $target = $(e.target);
       if (!$target.hasClass('is-disabled')) {
         if ($target.hasClass('datepicker-day-button') &amp;&amp; !$target.hasClass('is-empty') &amp;&amp; !$target.parent().hasClass('is-disabled')) {
           this.setDate(new Date(e.target.getAttribute('data-year'), e.target.getAttribute('data-month'), e.target.getAttribute('data-day')));
           if (this.options.autoClose) {
             this._finishSelection();
           }
         } else if ($target.closest('.month-prev').length) {
           this.prevMonth();
         } else if ($target.closest('.month-next').length) {
           this.nextMonth();
         }
       }
     }
   }, {
     key: &quot;_handleClearClick&quot;,
     value: function _handleClearClick() {
       this.date = null;
       this.setInputValue();
       this.close();
     }
   }, {
     key: &quot;_handleMonthChange&quot;,
     value: function _handleMonthChange(e) {
       this.gotoMonth(e.target.value);
     }
   }, {
     key: &quot;_handleYearChange&quot;,
     value: function _handleYearChange(e) {
       this.gotoYear(e.target.value);
     }
</PRE><PRE>     /**
      * change view to a specific month (zero-index, e.g. 0: January)
      */
</PRE><PRE>   }, {
     key: &quot;gotoMonth&quot;,
     value: function gotoMonth(month) {
       if (!isNaN(month)) {
         this.calendars[0].month = parseInt(month, 10);
         this.adjustCalendars();
       }
     }
</PRE><PRE>     /**
      * change view to a specific full year (e.g. &quot;2012&quot;)
      */
</PRE><PRE>   }, {
     key: &quot;gotoYear&quot;,
     value: function gotoYear(year) {
       if (!isNaN(year)) {
         this.calendars[0].year = parseInt(year, 10);
         this.adjustCalendars();
       }
     }
   }, {
     key: &quot;_handleInputChange&quot;,
     value: function _handleInputChange(e) {
       var date = void 0;
</PRE><PRE>       // Prevent change event from being fired when triggered by the plugin
       if (e.firedBy === this) {
         return;
       }
       if (this.options.parse) {
         date = this.options.parse(this.el.value, this.options.format);
       } else {
         date = new Date(Date.parse(this.el.value));
       }
</PRE><PRE>       if (Datepicker._isDate(date)) {
         this.setDate(date);
       }
     }
   }, {
     key: &quot;renderDayName&quot;,
     value: function renderDayName(opts, day, abbr) {
       day += opts.firstDay;
       while (day &gt;= 7) {
         day -= 7;
       }
       return abbr ? opts.i18n.weekdaysAbbrev[day] : opts.i18n.weekdays[day];
     }
</PRE><PRE>     /**
      * Set input value to the selected date and close Datepicker
      */
</PRE><PRE>   }, {
     key: &quot;_finishSelection&quot;,
     value: function _finishSelection() {
       this.setInputValue();
       this.close();
     }
</PRE><PRE>     /**
      * Open Datepicker
      */
</PRE><PRE>   }, {
     key: &quot;open&quot;,
     value: function open() {
       if (this.isOpen) {
         return;
       }
</PRE><PRE>       this.isOpen = true;
       if (typeof this.options.onOpen === 'function') {
         this.options.onOpen.call(this);
       }
       this.draw();
       this.modal.open();
       return this;
     }
</PRE><PRE>     /**
      * Close Datepicker
      */
</PRE><PRE>   }, {
     key: &quot;close&quot;,
     value: function close() {
       if (!this.isOpen) {
         return;
       }
</PRE><PRE>       this.isOpen = false;
       if (typeof this.options.onClose === 'function') {
         this.options.onClose.call(this);
       }
       this.modal.close();
       return this;
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Datepicker.__proto__ || Object.getPrototypeOf(Datepicker), &quot;init&quot;, this).call(this, this, els, options);
     }
   }, {
     key: &quot;_isDate&quot;,
     value: function _isDate(obj) {
       return (/Date/.test(Object.prototype.toString.call(obj)) &amp;&amp; !isNaN(obj.getTime())
       );
     }
   }, {
     key: &quot;_isWeekend&quot;,
     value: function _isWeekend(date) {
       var day = date.getDay();
       return day === 0 || day === 6;
     }
   }, {
     key: &quot;_setToStartOfDay&quot;,
     value: function _setToStartOfDay(date) {
       if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);
     }
   }, {
     key: &quot;_getDaysInMonth&quot;,
     value: function _getDaysInMonth(year, month) {
       return [31, Datepicker._isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
     }
   }, {
     key: &quot;_isLeapYear&quot;,
     value: function _isLeapYear(year) {
       // solution by Matti Virkkunen: <A rel="nofollow" class="external free" href="http://stackoverflow.com/a/4881951">http://stackoverflow.com/a/4881951</A>
       return year % 4 === 0 &amp;&amp; year % 100 !== 0 || year % 400 === 0;
     }
   }, {
     key: &quot;_compareDates&quot;,
     value: function _compareDates(a, b) {
       // weak date comparison (use setToStartOfDay(date) to ensure correct result)
       return a.getTime() === b.getTime();
     }
   }, {
     key: &quot;_setToStartOfDay&quot;,
     value: function _setToStartOfDay(date) {
       if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Datepicker;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Datepicker;
 }(Component);
</PRE>
  Datepicker._template = ['<DIV class="modal datepicker-modal">', '<DIV class="modal-content datepicker-container">', '<DIV class="datepicker-date-display">', '', '', '</DIV>', '<DIV class="datepicker-calendar-container">', '', '<DIV class="datepicker-footer">', '&lt;button class=&quot;btn-flat datepicker-clear waves-effect&quot; style=&quot;visibility: hidden;&quot; type=&quot;button&quot;&gt;&lt;/button&gt;', '<DIV class="confirmation-btns">', '&lt;button class=&quot;btn-flat datepicker-cancel waves-effect&quot; type=&quot;button&quot;&gt;&lt;/button&gt;', '&lt;button class=&quot;btn-flat datepicker-done waves-effect&quot; type=&quot;button&quot;&gt;&lt;/button&gt;', '</DIV>', '</DIV>', '</DIV>', '</DIV>', '</DIV>'].join(<I>);</I><PRE> M.Datepicker = Datepicker;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Datepicker, 'datepicker', 'M_Datepicker');
 }
</PRE><P>})(cash);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   dialRadius: 135,
   outerRadius: 105,
   innerRadius: 70,
   tickRadius: 20,
   duration: 350,
   container: null,
   defaultTime: 'now', // default time, 'now' or '13:14' e.g.
   fromNow: 0, // Millisecond offset from the defaultTime
   showClearBtn: false,
</PRE><PRE>   // internationalization
   i18n: {
     cancel: 'Cancel',
     clear: 'Clear',
     done: 'Ok'
   },
</PRE><PRE>   autoClose: false, // auto close when minute is selected
   twelveHour: true, // change to 12 hour AM/PM clock from 24 hour
   vibrate: true, // vibrate the device when dragging clock hand
</PRE><PRE>   // Callbacks
   onOpenStart: null,
   onOpenEnd: null,
   onCloseStart: null,
   onCloseEnd: null,
   onSelect: null
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Timepicker = function (_Component16) {
   _inherits(Timepicker, _Component16);
</PRE><PRE>   function Timepicker(el, options) {
     _classCallCheck(this, Timepicker);
</PRE><PRE>     var _this57 = _possibleConstructorReturn(this, (Timepicker.__proto__ || Object.getPrototypeOf(Timepicker)).call(this, Timepicker, el, options));
</PRE><PRE>     _this57.el.M_Timepicker = _this57;
</PRE><PRE>     _this57.options = $.extend({}, Timepicker.defaults, options);
</PRE><PRE>     _this57.id = M.guid();
     _this57._insertHTMLIntoDOM();
     _this57._setupModal();
     _this57._setupVariables();
     _this57._setupEventHandlers();
</PRE><PRE>     _this57._clockSetup();
     _this57._pickerSetup();
     return _this57;
   }
</PRE><PRE>   _createClass(Timepicker, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this.modal.destroy();
       $(this.modalEl).remove();
       this.el.M_Timepicker = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
       this._handleInputClickBound = this._handleInputClick.bind(this);
       this._handleClockClickStartBound = this._handleClockClickStart.bind(this);
       this._handleDocumentClickMoveBound = this._handleDocumentClickMove.bind(this);
       this._handleDocumentClickEndBound = this._handleDocumentClickEnd.bind(this);
</PRE><PRE>       this.el.addEventListener('click', this._handleInputClickBound);
       this.el.addEventListener('keydown', this._handleInputKeydownBound);
       this.plate.addEventListener('mousedown', this._handleClockClickStartBound);
       this.plate.addEventListener('touchstart', this._handleClockClickStartBound);
</PRE><PRE>       $(this.spanHours).on('click', this.showView.bind(this, 'hours'));
       $(this.spanMinutes).on('click', this.showView.bind(this, 'minutes'));
     }
   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('click', this._handleInputClickBound);
       this.el.removeEventListener('keydown', this._handleInputKeydownBound);
     }
   }, {
     key: &quot;_handleInputClick&quot;,
     value: function _handleInputClick() {
       this.open();
     }
   }, {
     key: &quot;_handleInputKeydown&quot;,
     value: function _handleInputKeydown(e) {
       if (e.which === M.keys.ENTER) {
         e.preventDefault();
         this.open();
       }
     }
   }, {
     key: &quot;_handleClockClickStart&quot;,
     value: function _handleClockClickStart(e) {
       e.preventDefault();
       var clockPlateBR = this.plate.getBoundingClientRect();
       var offset = { x: clockPlateBR.left, y: clockPlateBR.top };
</PRE><PRE>       this.x0 = offset.x + this.options.dialRadius;
       this.y0 = offset.y + this.options.dialRadius;
       this.moved = false;
       var clickPos = Timepicker._Pos(e);
       this.dx = clickPos.x - this.x0;
       this.dy = clickPos.y - this.y0;
</PRE><PRE>       // Set clock hands
       this.setHand(this.dx, this.dy, false);
</PRE><PRE>       // Mousemove on document
       document.addEventListener('mousemove', this._handleDocumentClickMoveBound);
       document.addEventListener('touchmove', this._handleDocumentClickMoveBound);
</PRE><PRE>       // Mouseup on document
       document.addEventListener('mouseup', this._handleDocumentClickEndBound);
       document.addEventListener('touchend', this._handleDocumentClickEndBound);
     }
   }, {
     key: &quot;_handleDocumentClickMove&quot;,
     value: function _handleDocumentClickMove(e) {
       e.preventDefault();
       var clickPos = Timepicker._Pos(e);
       var x = clickPos.x - this.x0;
       var y = clickPos.y - this.y0;
       this.moved = true;
       this.setHand(x, y, false, true);
     }
   }, {
     key: &quot;_handleDocumentClickEnd&quot;,
     value: function _handleDocumentClickEnd(e) {
       var _this58 = this;
</PRE><PRE>       e.preventDefault();
       document.removeEventListener('mouseup', this._handleDocumentClickEndBound);
       document.removeEventListener('touchend', this._handleDocumentClickEndBound);
       var clickPos = Timepicker._Pos(e);
       var x = clickPos.x - this.x0;
       var y = clickPos.y - this.y0;
       if (this.moved &amp;&amp; x === this.dx &amp;&amp; y === this.dy) {
         this.setHand(x, y);
       }
</PRE><PRE>       if (this.currentView === 'hours') {
         this.showView('minutes', this.options.duration / 2);
       } else if (this.options.autoClose) {
         $(this.minutesView).addClass('timepicker-dial-out');
         setTimeout(function () {
           _this58.done();
         }, this.options.duration / 2);
       }
</PRE><PRE>       if (typeof this.options.onSelect === 'function') {
         this.options.onSelect.call(this, this.hours, this.minutes);
       }
</PRE><PRE>       // Unbind mousemove event
       document.removeEventListener('mousemove', this._handleDocumentClickMoveBound);
       document.removeEventListener('touchmove', this._handleDocumentClickMoveBound);
     }
   }, {
     key: &quot;_insertHTMLIntoDOM&quot;,
     value: function _insertHTMLIntoDOM() {
       this.$modalEl = $(Timepicker._template);
       this.modalEl = this.$modalEl[0];
       this.modalEl.id = 'modal-' + this.id;
</PRE><PRE>       // Append popover to input by default
       var containerEl = document.querySelector(this.options.container);
       if (this.options.container &amp;&amp; !!containerEl) {
         this.$modalEl.appendTo(containerEl);
       } else {
         this.$modalEl.insertBefore(this.el);
       }
     }
   }, {
     key: &quot;_setupModal&quot;,
     value: function _setupModal() {
       var _this59 = this;
</PRE><PRE>       this.modal = M.Modal.init(this.modalEl, {
         onOpenStart: this.options.onOpenStart,
         onOpenEnd: this.options.onOpenEnd,
         onCloseStart: this.options.onCloseStart,
         onCloseEnd: function () {
           if (typeof _this59.options.onCloseEnd === 'function') {
             _this59.options.onCloseEnd.call(_this59);
           }
           _this59.isOpen = false;
         }
       });
     }
   }, {
     key: &quot;_setupVariables&quot;,
     value: function _setupVariables() {
       this.currentView = 'hours';
       this.vibrate = navigator.vibrate ? 'vibrate' : navigator.webkitVibrate ? 'webkitVibrate' : null;
</PRE><PRE>       this._canvas = this.modalEl.querySelector('.timepicker-canvas');
       this.plate = this.modalEl.querySelector('.timepicker-plate');
</PRE><PRE>       this.hoursView = this.modalEl.querySelector('.timepicker-hours');
       this.minutesView = this.modalEl.querySelector('.timepicker-minutes');
       this.spanHours = this.modalEl.querySelector('.timepicker-span-hours');
       this.spanMinutes = this.modalEl.querySelector('.timepicker-span-minutes');
       this.spanAmPm = this.modalEl.querySelector('.timepicker-span-am-pm');
       this.footer = this.modalEl.querySelector('.timepicker-footer');
       this.amOrPm = 'PM';
     }
   }, {
     key: &quot;_pickerSetup&quot;,
     value: function _pickerSetup() {
       var $clearBtn = $(&quot;&lt;button class=\&quot;btn-flat timepicker-clear waves-effect\&quot; style=\&quot;visibility: hidden;\&quot; type=\&quot;button\&quot; tabindex=\&quot;&quot; + (this.options.twelveHour ? '3' : '1') + &quot;\&quot;&gt;&quot; + this.options.i18n.clear + &quot;&lt;/button&gt;&quot;).appendTo(this.footer).on('click', this.clear.bind(this));
       if (this.options.showClearBtn) {
         $clearBtn.css({ visibility: <I> });</I>
       }
</PRE>
        var confirmationBtnsContainer = $('');
<PRE>       $('&lt;button class=&quot;btn-flat timepicker-close waves-effect&quot; type=&quot;button&quot; tabindex=&quot;' + (this.options.twelveHour ? '3' : '1') + '&quot;&gt;' + this.options.i18n.cancel + '&lt;/button&gt;').appendTo(confirmationBtnsContainer).on('click', this.close.bind(this));
       $('&lt;button class=&quot;btn-flat timepicker-close waves-effect&quot; type=&quot;button&quot; tabindex=&quot;' + (this.options.twelveHour ? '3' : '1') + '&quot;&gt;' + this.options.i18n.done + '&lt;/button&gt;').appendTo(confirmationBtnsContainer).on('click', this.done.bind(this));
       confirmationBtnsContainer.appendTo(this.footer);
     }
   }, {
     key: &quot;_clockSetup&quot;,
     value: function _clockSetup() {
       if (this.options.twelveHour) {
</PRE>
          this.$amBtn = $('<DIV class="am-btn">AM</DIV>');
          this.$pmBtn = $('<DIV class="pm-btn">PM</DIV>');
<PRE>         this.$amBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);
         this.$pmBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);
       }
</PRE><PRE>       this._buildHoursView();
       this._buildMinutesView();
       this._buildSVGClock();
     }
   }, {
     key: &quot;_buildSVGClock&quot;,
     value: function _buildSVGClock() {
       // Draw clock hands and others
       var dialRadius = this.options.dialRadius;
       var tickRadius = this.options.tickRadius;
       var diameter = dialRadius * 2;
</PRE><PRE>       var svg = Timepicker._createSVGEl('svg');
       svg.setAttribute('class', 'timepicker-svg');
       svg.setAttribute('width', diameter);
       svg.setAttribute('height', diameter);
       var g = Timepicker._createSVGEl('g');
       g.setAttribute('transform', 'translate(' + dialRadius + ',' + dialRadius + ')');
       var bearing = Timepicker._createSVGEl('circle');
       bearing.setAttribute('class', 'timepicker-canvas-bearing');
       bearing.setAttribute('cx', 0);
       bearing.setAttribute('cy', 0);
       bearing.setAttribute('r', 4);
       var hand = Timepicker._createSVGEl('line');
       hand.setAttribute('x1', 0);
       hand.setAttribute('y1', 0);
       var bg = Timepicker._createSVGEl('circle');
       bg.setAttribute('class', 'timepicker-canvas-bg');
       bg.setAttribute('r', tickRadius);
       g.appendChild(hand);
       g.appendChild(bg);
       g.appendChild(bearing);
       svg.appendChild(g);
       this._canvas.appendChild(svg);
</PRE><PRE>       this.hand = hand;
       this.bg = bg;
       this.bearing = bearing;
       this.g = g;
     }
   }, {
     key: &quot;_buildHoursView&quot;,
     value: function _buildHoursView() {
</PRE>
        var $tick = $('');
<PRE>       // Hours view
       if (this.options.twelveHour) {
         for (var i = 1; i &lt; 13; i += 1) {
           var tick = $tick.clone();
           var radian = i / 6 * Math.PI;
           var radius = this.options.outerRadius;
           tick.css({
             left: this.options.dialRadius + Math.sin(radian) * radius - this.options.tickRadius + 'px',
             top: this.options.dialRadius - Math.cos(radian) * radius - this.options.tickRadius + 'px'
           });
           tick.html(i === 0 ? '00' : i);
           this.hoursView.appendChild(tick[0]);
           // tick.on(mousedownEvent, mousedown);
         }
       } else {
         for (var _i2 = 0; _i2 &lt; 24; _i2 += 1) {
           var _tick = $tick.clone();
           var _radian = _i2 / 6 * Math.PI;
           var inner = _i2 &gt; 0 &amp;&amp; _i2 &lt; 13;
           var _radius = inner ? this.options.innerRadius : this.options.outerRadius;
           _tick.css({
             left: this.options.dialRadius + Math.sin(_radian) * _radius - this.options.tickRadius + 'px',
             top: this.options.dialRadius - Math.cos(_radian) * _radius - this.options.tickRadius + 'px'
           });
           _tick.html(_i2 === 0 ? '00' : _i2);
           this.hoursView.appendChild(_tick[0]);
           // tick.on(mousedownEvent, mousedown);
         }
       }
     }
   }, {
     key: &quot;_buildMinutesView&quot;,
     value: function _buildMinutesView() {
</PRE>
        var $tick = $('');
<PRE>       // Minutes view
       for (var i = 0; i &lt; 60; i += 5) {
         var tick = $tick.clone();
         var radian = i / 30 * Math.PI;
         tick.css({
           left: this.options.dialRadius + Math.sin(radian) * this.options.outerRadius - this.options.tickRadius + 'px',
           top: this.options.dialRadius - Math.cos(radian) * this.options.outerRadius - this.options.tickRadius + 'px'
         });
         tick.html(Timepicker._addLeadingZero(i));
         this.minutesView.appendChild(tick[0]);
       }
     }
   }, {
     key: &quot;_handleAmPmClick&quot;,
     value: function _handleAmPmClick(e) {
       var $btnClicked = $(e.target);
       this.amOrPm = $btnClicked.hasClass('am-btn') ? 'AM' : 'PM';
       this._updateAmPmView();
     }
   }, {
     key: &quot;_updateAmPmView&quot;,
     value: function _updateAmPmView() {
       if (this.options.twelveHour) {
         this.$amBtn.toggleClass('text-primary', this.amOrPm === 'AM');
         this.$pmBtn.toggleClass('text-primary', this.amOrPm === 'PM');
       }
     }
   }, {
     key: &quot;_updateTimeFromInput&quot;,
     value: function _updateTimeFromInput() {
       // Get the time
       var value = ((this.el.value || this.options.defaultTime || <I>) + </I>).split(':');
       if (this.options.twelveHour &amp;&amp; !(typeof value[1] === 'undefined')) {
         if (value[1].toUpperCase().indexOf('AM') &gt; 0) {
           this.amOrPm = 'AM';
         } else {
           this.amOrPm = 'PM';
         }
         value[1] = value[1].replace('AM', <I>).replace('PM', </I>);
       }
       if (value[0] === 'now') {
         var now = new Date(+new Date() + this.options.fromNow);
         value = [now.getHours(), now.getMinutes()];
         if (this.options.twelveHour) {
           this.amOrPm = value[0] &gt;= 12 &amp;&amp; value[0] &lt; 24 ? 'PM' : 'AM';
         }
       }
       this.hours = +value[0] || 0;
       this.minutes = +value[1] || 0;
       this.spanHours.innerHTML = this.hours;
       this.spanMinutes.innerHTML = Timepicker._addLeadingZero(this.minutes);
</PRE><PRE>       this._updateAmPmView();
     }
   }, {
     key: &quot;showView&quot;,
     value: function showView(view, delay) {
       if (view === 'minutes' &amp;&amp; $(this.hoursView).css('visibility') === 'visible') {
         // raiseCallback(this.options.beforeHourSelect);
       }
       var isHours = view === 'hours',
           nextView = isHours ? this.hoursView : this.minutesView,
           hideView = isHours ? this.minutesView : this.hoursView;
       this.currentView = view;
</PRE><PRE>       $(this.spanHours).toggleClass('text-primary', isHours);
       $(this.spanMinutes).toggleClass('text-primary', !isHours);
</PRE><PRE>       // Transition view
       hideView.classList.add('timepicker-dial-out');
       $(nextView).css('visibility', 'visible').removeClass('timepicker-dial-out');
</PRE><PRE>       // Reset clock hand
       this.resetClock(delay);
</PRE><PRE>       // After transitions ended
       clearTimeout(this.toggleViewTimer);
       this.toggleViewTimer = setTimeout(function () {
         $(hideView).css('visibility', 'hidden');
       }, this.options.duration);
     }
   }, {
     key: &quot;resetClock&quot;,
     value: function resetClock(delay) {
       var view = this.currentView,
           value = this[view],
           isHours = view === 'hours',
           unit = Math.PI / (isHours ? 6 : 30),
           radian = value * unit,
           radius = isHours &amp;&amp; value &gt; 0 &amp;&amp; value &lt; 13 ? this.options.innerRadius : this.options.outerRadius,
           x = Math.sin(radian) * radius,
           y = -Math.cos(radian) * radius,
           self = this;
</PRE><PRE>       if (delay) {
         $(this.canvas).addClass('timepicker-canvas-out');
         setTimeout(function () {
           $(self.canvas).removeClass('timepicker-canvas-out');
           self.setHand(x, y);
         }, delay);
       } else {
         this.setHand(x, y);
       }
     }
   }, {
     key: &quot;setHand&quot;,
     value: function setHand(x, y, roundBy5) {
       var _this60 = this;
</PRE><PRE>       var radian = Math.atan2(x, -y),
           isHours = this.currentView === 'hours',
           unit = Math.PI / (isHours || roundBy5 ? 6 : 30),
           z = Math.sqrt(x * x + y * y),
           inner = isHours &amp;&amp; z &lt; (this.options.outerRadius + this.options.innerRadius) / 2,
           radius = inner ? this.options.innerRadius : this.options.outerRadius;
</PRE><PRE>       if (this.options.twelveHour) {
         radius = this.options.outerRadius;
       }
</PRE><PRE>       // Radian should in range [0, 2PI]
       if (radian &lt; 0) {
         radian = Math.PI * 2 + radian;
       }
</PRE><PRE>       // Get the round value
       var value = Math.round(radian / unit);
</PRE><PRE>       // Get the round radian
       radian = value * unit;
</PRE><PRE>       // Correct the hours or minutes
       if (this.options.twelveHour) {
         if (isHours) {
           if (value === 0) value = 12;
         } else {
           if (roundBy5) value *= 5;
           if (value === 60) value = 0;
         }
       } else {
         if (isHours) {
           if (value === 12) {
             value = 0;
           }
           value = inner ? value === 0 ? 12 : value : value === 0 ? 0 : value + 12;
         } else {
           if (roundBy5) {
             value *= 5;
           }
           if (value === 60) {
             value = 0;
           }
         }
       }
</PRE><PRE>       // Once hours or minutes changed, vibrate the device
       if (this[this.currentView] !== value) {
         if (this.vibrate &amp;&amp; this.options.vibrate) {
           // Do not vibrate too frequently
           if (!this.vibrateTimer) {
             navigator[this.vibrate](10);
             this.vibrateTimer = setTimeout(function () {
               _this60.vibrateTimer = null;
             }, 100);
           }
         }
       }
</PRE><PRE>       this[this.currentView] = value;
       if (isHours) {
         this['spanHours'].innerHTML = value;
       } else {
         this['spanMinutes'].innerHTML = Timepicker._addLeadingZero(value);
       }
</PRE><PRE>       // Set clock hand and others' position
       var cx1 = Math.sin(radian) * (radius - this.options.tickRadius),
           cy1 = -Math.cos(radian) * (radius - this.options.tickRadius),
           cx2 = Math.sin(radian) * radius,
           cy2 = -Math.cos(radian) * radius;
       this.hand.setAttribute('x2', cx1);
       this.hand.setAttribute('y2', cy1);
       this.bg.setAttribute('cx', cx2);
       this.bg.setAttribute('cy', cy2);
     }
   }, {
     key: &quot;open&quot;,
     value: function open() {
       if (this.isOpen) {
         return;
       }
</PRE><PRE>       this.isOpen = true;
       this._updateTimeFromInput();
       this.showView('hours');
</PRE><PRE>       this.modal.open();
     }
   }, {
     key: &quot;close&quot;,
     value: function close() {
       if (!this.isOpen) {
         return;
       }
</PRE><PRE>       this.isOpen = false;
       this.modal.close();
     }
</PRE><PRE>     /**
      * Finish timepicker selection.
      */
</PRE><PRE>   }, {
     key: &quot;done&quot;,
     value: function done(e, clearValue) {
       // Set input value
       var last = this.el.value;
       var value = clearValue ? <I> : Timepicker._addLeadingZero(this.hours) + ':' + Timepicker._addLeadingZero(this.minutes);</I>
       this.time = value;
       if (!clearValue &amp;&amp; this.options.twelveHour) {
         value = value + &quot; &quot; + this.amOrPm;
       }
       this.el.value = value;
</PRE><PRE>       // Trigger change event
       if (value !== last) {
         this.$el.trigger('change');
       }
</PRE><PRE>       this.close();
       this.el.focus();
     }
   }, {
     key: &quot;clear&quot;,
     value: function clear() {
       this.done(null, true);
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Timepicker.__proto__ || Object.getPrototypeOf(Timepicker), &quot;init&quot;, this).call(this, this, els, options);
     }
   }, {
     key: &quot;_addLeadingZero&quot;,
     value: function _addLeadingZero(num) {
       return (num &lt; 10 ? '0' : <I>) + num;</I>
     }
   }, {
     key: &quot;_createSVGEl&quot;,
     value: function _createSVGEl(name) {
       var svgNS = '<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg'">http://www.w3.org/2000/svg'</A>;
       return document.createElementNS(svgNS, name);
     }
</PRE><PRE>     /**
      * @typedef {Object} Point
      * @property {number} x The X Coordinate
      * @property {number} y The Y Coordinate
      */
</PRE><PRE>     /**
      * Get x position of mouse or touch event
      * @param {Event} e
      * @return {Point} x and y location
      */
</PRE><PRE>   }, {
     key: &quot;_Pos&quot;,
     value: function _Pos(e) {
       if (e.targetTouches &amp;&amp; e.targetTouches.length &gt;= 1) {
         return { x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY };
       }
       // mouse event
       return { x: e.clientX, y: e.clientY };
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Timepicker;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Timepicker;
 }(Component);
</PRE>
  Timepicker._template = ['<DIV class="modal timepicker-modal">', '<DIV class="modal-content timepicker-container">', '<DIV class="timepicker-digital-display">', '<DIV class="timepicker-text-container">', '<DIV class="timepicker-display-column">', '', ':', '', '</DIV>', '<DIV class="timepicker-display-column timepicker-display-am-pm">', '', '</DIV>', '</DIV>', '</DIV>', '<DIV class="timepicker-analog-display">', '<DIV class="timepicker-plate">', '', '', '', '</DIV>', '', '</DIV>', '</DIV>', '</DIV>'].join(<I>);</I><PRE> M.Timepicker = Timepicker;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Timepicker, 'timepicker', 'M_Timepicker');
 }
</PRE><P>})(cash);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {};
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var CharacterCounter = function (_Component17) {
   _inherits(CharacterCounter, _Component17);
</PRE><PRE>   /**
    * Construct CharacterCounter instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function CharacterCounter(el, options) {
     _classCallCheck(this, CharacterCounter);
</PRE><PRE>     var _this61 = _possibleConstructorReturn(this, (CharacterCounter.__proto__ || Object.getPrototypeOf(CharacterCounter)).call(this, CharacterCounter, el, options));
</PRE><PRE>     _this61.el.M_CharacterCounter = _this61;
</PRE><PRE>     /**
      * Options for the character counter
      */
     _this61.options = $.extend({}, CharacterCounter.defaults, options);
</PRE><PRE>     _this61.isInvalid = false;
     _this61.isValidLength = false;
     _this61._setupCounter();
     _this61._setupEventHandlers();
     return _this61;
   }
</PRE><PRE>   _createClass(CharacterCounter, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this.el.CharacterCounter = undefined;
       this._removeCounter();
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleUpdateCounterBound = this.updateCounter.bind(this);
</PRE><PRE>       this.el.addEventListener('focus', this._handleUpdateCounterBound, true);
       this.el.addEventListener('input', this._handleUpdateCounterBound, true);
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('focus', this._handleUpdateCounterBound, true);
       this.el.removeEventListener('input', this._handleUpdateCounterBound, true);
     }
</PRE><PRE>     /**
      * Setup counter element
      */
</PRE><PRE>   }, {
     key: &quot;_setupCounter&quot;,
     value: function _setupCounter() {
       this.counterEl = document.createElement('span');
       $(this.counterEl).addClass('character-counter').css({
         float: 'right',
         'font-size': '12px',
         height: 1
       });
</PRE><PRE>       this.$el.parent().append(this.counterEl);
     }
</PRE><PRE>     /**
      * Remove counter element
      */
</PRE><PRE>   }, {
     key: &quot;_removeCounter&quot;,
     value: function _removeCounter() {
       $(this.counterEl).remove();
     }
</PRE><PRE>     /**
      * Update counter
      */
</PRE><PRE>   }, {
     key: &quot;updateCounter&quot;,
     value: function updateCounter() {
       var maxLength = +this.$el.attr('data-length'),
           actualLength = this.el.value.length;
       this.isValidLength = actualLength &lt;= maxLength;
       var counterString = actualLength;
</PRE><PRE>       if (maxLength) {
         counterString += '/' + maxLength;
         this._validateInput();
       }
</PRE><PRE>       $(this.counterEl).html(counterString);
     }
</PRE><PRE>     /**
      * Add validation classes
      */
</PRE><PRE>   }, {
     key: &quot;_validateInput&quot;,
     value: function _validateInput() {
       if (this.isValidLength &amp;&amp; this.isInvalid) {
         this.isInvalid = false;
         this.$el.removeClass('invalid');
       } else if (!this.isValidLength &amp;&amp; !this.isInvalid) {
         this.isInvalid = true;
         this.$el.removeClass('valid');
         this.$el.addClass('invalid');
       }
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(CharacterCounter.__proto__ || Object.getPrototypeOf(CharacterCounter), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_CharacterCounter;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return CharacterCounter;
 }(Component);
</PRE><PRE> M.CharacterCounter = CharacterCounter;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(CharacterCounter, 'characterCounter', 'M_CharacterCounter');
 }
</PRE><P>})(cash);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   duration: 200, // ms
   dist: -100, // zoom scale TODO: make this more intuitive as an option
   shift: 0, // spacing for center image
   padding: 0, // Padding between non center items
   numVisible: 5, // Number of visible items in carousel
   fullWidth: false, // Change to full width styles
   indicators: false, // Toggle indicators
   noWrap: false, // Don't wrap around and cycle through items.
   onCycleTo: null // Callback for when a new slide is cycled to.
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Carousel = function (_Component18) {
   _inherits(Carousel, _Component18);
</PRE><PRE>   /**
    * Construct Carousel instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Carousel(el, options) {
     _classCallCheck(this, Carousel);
</PRE><PRE>     var _this62 = _possibleConstructorReturn(this, (Carousel.__proto__ || Object.getPrototypeOf(Carousel)).call(this, Carousel, el, options));
</PRE><PRE>     _this62.el.M_Carousel = _this62;
</PRE><PRE>     /**
      * Options for the carousel
      * @member Carousel#options
      * @prop {Number} duration
      * @prop {Number} dist
      * @prop {Number} shift
      * @prop {Number} padding
      * @prop {Number} numVisible
      * @prop {Boolean} fullWidth
      * @prop {Boolean} indicators
      * @prop {Boolean} noWrap
      * @prop {Function} onCycleTo
      */
     _this62.options = $.extend({}, Carousel.defaults, options);
</PRE><PRE>     // Setup
     _this62.hasMultipleSlides = _this62.$el.find('.carousel-item').length &gt; 1;
     _this62.showIndicators = _this62.options.indicators &amp;&amp; _this62.hasMultipleSlides;
     _this62.noWrap = _this62.options.noWrap || !_this62.hasMultipleSlides;
     _this62.pressed = false;
     _this62.dragged = false;
     _this62.offset = _this62.target = 0;
     _this62.images = [];
     _this62.itemWidth = _this62.$el.find('.carousel-item').first().innerWidth();
     _this62.itemHeight = _this62.$el.find('.carousel-item').first().innerHeight();
     _this62.dim = _this62.itemWidth * 2 + _this62.options.padding || 1; // Make sure dim is non zero for divisions.
     _this62._autoScrollBound = _this62._autoScroll.bind(_this62);
     _this62._trackBound = _this62._track.bind(_this62);
</PRE><PRE>     // Full Width carousel setup
     if (_this62.options.fullWidth) {
       _this62.options.dist = 0;
       _this62._setCarouselHeight();
</PRE><PRE>       // Offset fixed items when indicators.
       if (_this62.showIndicators) {
         _this62.$el.find('.carousel-fixed-item').addClass('with-indicators');
       }
     }
</PRE><PRE>     // Iterate through slides
</PRE>
      _this62.$indicators = $('');
<PRE>     _this62.$el.find('.carousel-item').each(function (el, i) {
       _this62.images.push(el);
       if (_this62.showIndicators) {
</PRE>
          var $indicator = $('');
<PRE>         // Add active to first by default.
         if (i === 0) {
           $indicator[0].classList.add('active');
         }
</PRE><PRE>         _this62.$indicators.append($indicator);
       }
     });
     if (_this62.showIndicators) {
       _this62.$el.append(_this62.$indicators);
     }
     _this62.count = _this62.images.length;
</PRE><PRE>     // Cap numVisible at count
     _this62.options.numVisible = Math.min(_this62.count, _this62.options.numVisible);
</PRE><PRE>     // Setup cross browser string
     _this62.xform = 'transform';
     ['webkit', 'Moz', 'O', 'ms'].every(function (prefix) {
       var e = prefix + 'Transform';
       if (typeof document.body.style[e] !== 'undefined') {
         _this62.xform = e;
         return false;
       }
       return true;
     });
</PRE><PRE>     _this62._setupEventHandlers();
     _this62._scroll(_this62.offset);
     return _this62;
   }
</PRE><PRE>   _createClass(Carousel, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this.el.M_Carousel = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       var _this63 = this;
</PRE><PRE>       this._handleCarouselTapBound = this._handleCarouselTap.bind(this);
       this._handleCarouselDragBound = this._handleCarouselDrag.bind(this);
       this._handleCarouselReleaseBound = this._handleCarouselRelease.bind(this);
       this._handleCarouselClickBound = this._handleCarouselClick.bind(this);
</PRE><PRE>       if (typeof window.ontouchstart !== 'undefined') {
         this.el.addEventListener('touchstart', this._handleCarouselTapBound);
         this.el.addEventListener('touchmove', this._handleCarouselDragBound);
         this.el.addEventListener('touchend', this._handleCarouselReleaseBound);
       }
</PRE><PRE>       this.el.addEventListener('mousedown', this._handleCarouselTapBound);
       this.el.addEventListener('mousemove', this._handleCarouselDragBound);
       this.el.addEventListener('mouseup', this._handleCarouselReleaseBound);
       this.el.addEventListener('mouseleave', this._handleCarouselReleaseBound);
       this.el.addEventListener('click', this._handleCarouselClickBound);
</PRE><PRE>       if (this.showIndicators &amp;&amp; this.$indicators) {
         this._handleIndicatorClickBound = this._handleIndicatorClick.bind(this);
         this.$indicators.find('.indicator-item').each(function (el, i) {
           el.addEventListener('click', _this63._handleIndicatorClickBound);
         });
       }
</PRE><PRE>       // Resize
       var throttledResize = M.throttle(this._handleResize, 200);
       this._handleThrottledResizeBound = throttledResize.bind(this);
</PRE><PRE>       window.addEventListener('resize', this._handleThrottledResizeBound);
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       var _this64 = this;
</PRE><PRE>       if (typeof window.ontouchstart !== 'undefined') {
         this.el.removeEventListener('touchstart', this._handleCarouselTapBound);
         this.el.removeEventListener('touchmove', this._handleCarouselDragBound);
         this.el.removeEventListener('touchend', this._handleCarouselReleaseBound);
       }
       this.el.removeEventListener('mousedown', this._handleCarouselTapBound);
       this.el.removeEventListener('mousemove', this._handleCarouselDragBound);
       this.el.removeEventListener('mouseup', this._handleCarouselReleaseBound);
       this.el.removeEventListener('mouseleave', this._handleCarouselReleaseBound);
       this.el.removeEventListener('click', this._handleCarouselClickBound);
</PRE><PRE>       if (this.showIndicators &amp;&amp; this.$indicators) {
         this.$indicators.find('.indicator-item').each(function (el, i) {
           el.removeEventListener('click', _this64._handleIndicatorClickBound);
         });
       }
</PRE><PRE>       window.removeEventListener('resize', this._handleThrottledResizeBound);
     }
</PRE><PRE>     /**
      * Handle Carousel Tap
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleCarouselTap&quot;,
     value: function _handleCarouselTap(e) {
       // Fixes firefox draggable image bug
       if (e.type === 'mousedown' &amp;&amp; $(e.target).is('img')) {
         e.preventDefault();
       }
       this.pressed = true;
       this.dragged = false;
       this.verticalDragged = false;
       this.reference = this._xpos(e);
       this.referenceY = this._ypos(e);
</PRE><PRE>       this.velocity = this.amplitude = 0;
       this.frame = this.offset;
       this.timestamp = Date.now();
       clearInterval(this.ticker);
       this.ticker = setInterval(this._trackBound, 100);
     }
</PRE><PRE>     /**
      * Handle Carousel Drag
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleCarouselDrag&quot;,
     value: function _handleCarouselDrag(e) {
       var x = void 0,
           y = void 0,
           delta = void 0,
           deltaY = void 0;
       if (this.pressed) {
         x = this._xpos(e);
         y = this._ypos(e);
         delta = this.reference - x;
         deltaY = Math.abs(this.referenceY - y);
         if (deltaY &lt; 30 &amp;&amp; !this.verticalDragged) {
           // If vertical scrolling don't allow dragging.
           if (delta &gt; 2 || delta &lt; -2) {
             this.dragged = true;
             this.reference = x;
             this._scroll(this.offset + delta);
           }
         } else if (this.dragged) {
           // If dragging don't allow vertical scroll.
           e.preventDefault();
           e.stopPropagation();
           return false;
         } else {
           // Vertical scrolling.
           this.verticalDragged = true;
         }
       }
</PRE><PRE>       if (this.dragged) {
         // If dragging don't allow vertical scroll.
         e.preventDefault();
         e.stopPropagation();
         return false;
       }
     }
</PRE><PRE>     /**
      * Handle Carousel Release
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleCarouselRelease&quot;,
     value: function _handleCarouselRelease(e) {
       if (this.pressed) {
         this.pressed = false;
       } else {
         return;
       }
</PRE><PRE>       clearInterval(this.ticker);
       this.target = this.offset;
       if (this.velocity &gt; 10 || this.velocity &lt; -10) {
         this.amplitude = 0.9 * this.velocity;
         this.target = this.offset + this.amplitude;
       }
       this.target = Math.round(this.target / this.dim) * this.dim;
</PRE><PRE>       // No wrap of items.
       if (this.noWrap) {
         if (this.target &gt;= this.dim * (this.count - 1)) {
           this.target = this.dim * (this.count - 1);
         } else if (this.target &lt; 0) {
           this.target = 0;
         }
       }
       this.amplitude = this.target - this.offset;
       this.timestamp = Date.now();
       requestAnimationFrame(this._autoScrollBound);
</PRE><PRE>       if (this.dragged) {
         e.preventDefault();
         e.stopPropagation();
       }
       return false;
     }
</PRE><PRE>     /**
      * Handle Carousel CLick
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleCarouselClick&quot;,
     value: function _handleCarouselClick(e) {
       // Disable clicks if carousel was dragged.
       if (this.dragged) {
         e.preventDefault();
         e.stopPropagation();
         return false;
       } else if (!this.options.fullWidth) {
         var clickedIndex = $(e.target).closest('.carousel-item').index();
         var diff = this._wrap(this.center) - clickedIndex;
</PRE><PRE>         // Disable clicks if carousel was shifted by click
         if (diff !== 0) {
           e.preventDefault();
           e.stopPropagation();
         }
         this._cycleTo(clickedIndex);
       }
     }
</PRE><PRE>     /**
      * Handle Indicator CLick
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleIndicatorClick&quot;,
     value: function _handleIndicatorClick(e) {
       e.stopPropagation();
</PRE><PRE>       var indicator = $(e.target).closest('.indicator-item');
       if (indicator.length) {
         this._cycleTo(indicator.index());
       }
     }
</PRE><PRE>     /**
      * Handle Throttle Resize
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleResize&quot;,
     value: function _handleResize(e) {
       if (this.options.fullWidth) {
         this.itemWidth = this.$el.find('.carousel-item').first().innerWidth();
         this.imageHeight = this.$el.find('.carousel-item.active').height();
         this.dim = this.itemWidth * 2 + this.options.padding;
         this.offset = this.center * 2 * this.itemWidth;
         this.target = this.offset;
         this._setCarouselHeight(true);
       } else {
         this._scroll();
       }
     }
</PRE><PRE>     /**
      * Set carousel height based on first slide
      * @param {Booleam} imageOnly - true for image slides
      */
</PRE><PRE>   }, {
     key: &quot;_setCarouselHeight&quot;,
     value: function _setCarouselHeight(imageOnly) {
       var _this65 = this;
</PRE><PRE>       var firstSlide = this.$el.find('.carousel-item.active').length ? this.$el.find('.carousel-item.active').first() : this.$el.find('.carousel-item').first();
       var firstImage = firstSlide.find('img').first();
       if (firstImage.length) {
         if (firstImage[0].complete) {
           // If image won't trigger the load event
           var imageHeight = firstImage.height();
           if (imageHeight &gt; 0) {
             this.$el.css('height', imageHeight + 'px');
           } else {
             // If image still has no height, use the natural dimensions to calculate
             var naturalWidth = firstImage[0].naturalWidth;
             var naturalHeight = firstImage[0].naturalHeight;
             var adjustedHeight = this.$el.width() / naturalWidth * naturalHeight;
             this.$el.css('height', adjustedHeight + 'px');
           }
         } else {
           // Get height when image is loaded normally
           firstImage.one('load', function (el, i) {
             _this65.$el.css('height', el.offsetHeight + 'px');
           });
         }
       } else if (!imageOnly) {
         var slideHeight = firstSlide.height();
         this.$el.css('height', slideHeight + 'px');
       }
     }
</PRE><PRE>     /**
      * Get x position from event
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_xpos&quot;,
     value: function _xpos(e) {
       // touch event
       if (e.targetTouches &amp;&amp; e.targetTouches.length &gt;= 1) {
         return e.targetTouches[0].clientX;
       }
</PRE><PRE>       // mouse event
       return e.clientX;
     }
</PRE><PRE>     /**
      * Get y position from event
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_ypos&quot;,
     value: function _ypos(e) {
       // touch event
       if (e.targetTouches &amp;&amp; e.targetTouches.length &gt;= 1) {
         return e.targetTouches[0].clientY;
       }
</PRE><PRE>       // mouse event
       return e.clientY;
     }
</PRE><PRE>     /**
      * Wrap index
      * @param {Number} x
      */
</PRE><PRE>   }, {
     key: &quot;_wrap&quot;,
     value: function _wrap(x) {
       return x &gt;= this.count ? x % this.count : x &lt; 0 ? this._wrap(this.count + x % this.count) : x;
     }
</PRE><PRE>     /**
      * Tracks scrolling information
      */
</PRE><PRE>   }, {
     key: &quot;_track&quot;,
     value: function _track() {
       var now = void 0,
           elapsed = void 0,
           delta = void 0,
           v = void 0;
</PRE><PRE>       now = Date.now();
       elapsed = now - this.timestamp;
       this.timestamp = now;
       delta = this.offset - this.frame;
       this.frame = this.offset;
</PRE><PRE>       v = 1000 * delta / (1 + elapsed);
       this.velocity = 0.8 * v + 0.2 * this.velocity;
     }
</PRE><PRE>     /**
      * Auto scrolls to nearest carousel item.
      */
</PRE><PRE>   }, {
     key: &quot;_autoScroll&quot;,
     value: function _autoScroll() {
       var elapsed = void 0,
           delta = void 0;
</PRE><PRE>       if (this.amplitude) {
         elapsed = Date.now() - this.timestamp;
         delta = this.amplitude * Math.exp(-elapsed / this.options.duration);
         if (delta &gt; 2 || delta &lt; -2) {
           this._scroll(this.target - delta);
           requestAnimationFrame(this._autoScrollBound);
         } else {
           this._scroll(this.target);
         }
       }
     }
</PRE><PRE>     /**
      * Scroll to target
      * @param {Number} x
      */
</PRE><PRE>   }, {
     key: &quot;_scroll&quot;,
     value: function _scroll(x) {
       var _this66 = this;
</PRE><PRE>       // Track scrolling state
       if (!this.$el.hasClass('scrolling')) {
         this.el.classList.add('scrolling');
       }
       if (this.scrollingTimeout != null) {
         window.clearTimeout(this.scrollingTimeout);
       }
       this.scrollingTimeout = window.setTimeout(function () {
         _this66.$el.removeClass('scrolling');
       }, this.options.duration);
</PRE><PRE>       // Start actual scroll
       var i = void 0,
           half = void 0,
           delta = void 0,
           dir = void 0,
           tween = void 0,
           el = void 0,
           alignment = void 0,
           zTranslation = void 0,
           tweenedOpacity = void 0,
           centerTweenedOpacity = void 0;
       var lastCenter = this.center;
       var numVisibleOffset = 1 / this.options.numVisible;
</PRE><PRE>       this.offset = typeof x === 'number' ? x : this.offset;
       this.center = Math.floor((this.offset + this.dim / 2) / this.dim);
       delta = this.offset - this.center * this.dim;
       dir = delta &lt; 0 ? 1 : -1;
       tween = -dir * delta * 2 / this.dim;
       half = this.count &gt;&gt; 1;
</PRE><PRE>       if (this.options.fullWidth) {
         alignment = 'translateX(0)';
         centerTweenedOpacity = 1;
       } else {
         alignment = 'translateX(' + (this.el.clientWidth - this.itemWidth) / 2 + 'px) ';
         alignment += 'translateY(' + (this.el.clientHeight - this.itemHeight) / 2 + 'px)';
         centerTweenedOpacity = 1 - numVisibleOffset * tween;
       }
</PRE><PRE>       // Set indicator active
       if (this.showIndicators) {
         var diff = this.center % this.count;
         var activeIndicator = this.$indicators.find('.indicator-item.active');
         if (activeIndicator.index() !== diff) {
           activeIndicator.removeClass('active');
           this.$indicators.find('.indicator-item').eq(diff)[0].classList.add('active');
         }
       }
</PRE><PRE>       // center
       // Don't show wrapped items.
       if (!this.noWrap || this.center &gt;= 0 &amp;&amp; this.center &lt; this.count) {
         el = this.images[this._wrap(this.center)];
</PRE><PRE>         // Add active class to center item.
         if (!$(el).hasClass('active')) {
           this.$el.find('.carousel-item').removeClass('active');
           el.classList.add('active');
         }
         var transformString = alignment + &quot; translateX(&quot; + -delta / 2 + &quot;px) translateX(&quot; + dir * this.options.shift * tween * i + &quot;px) translateZ(&quot; + this.options.dist * tween + &quot;px)&quot;;
         this._updateItemStyle(el, centerTweenedOpacity, 0, transformString);
       }
</PRE><PRE>       for (i = 1; i &lt;= half; ++i) {
         // right side
         if (this.options.fullWidth) {
           zTranslation = this.options.dist;
           tweenedOpacity = i === half &amp;&amp; delta &lt; 0 ? 1 - tween : 1;
         } else {
           zTranslation = this.options.dist * (i * 2 + tween * dir);
           tweenedOpacity = 1 - numVisibleOffset * (i * 2 + tween * dir);
         }
         // Don't show wrapped items.
         if (!this.noWrap || this.center + i &lt; this.count) {
           el = this.images[this._wrap(this.center + i)];
           var _transformString = alignment + &quot; translateX(&quot; + (this.options.shift + (this.dim * i - delta) / 2) + &quot;px) translateZ(&quot; + zTranslation + &quot;px)&quot;;
           this._updateItemStyle(el, tweenedOpacity, -i, _transformString);
         }
</PRE><PRE>         // left side
         if (this.options.fullWidth) {
           zTranslation = this.options.dist;
           tweenedOpacity = i === half &amp;&amp; delta &gt; 0 ? 1 - tween : 1;
         } else {
           zTranslation = this.options.dist * (i * 2 - tween * dir);
           tweenedOpacity = 1 - numVisibleOffset * (i * 2 - tween * dir);
         }
         // Don't show wrapped items.
         if (!this.noWrap || this.center - i &gt;= 0) {
           el = this.images[this._wrap(this.center - i)];
           var _transformString2 = alignment + &quot; translateX(&quot; + (-this.options.shift + (-this.dim * i - delta) / 2) + &quot;px) translateZ(&quot; + zTranslation + &quot;px)&quot;;
           this._updateItemStyle(el, tweenedOpacity, -i, _transformString2);
         }
       }
</PRE><PRE>       // center
       // Don't show wrapped items.
       if (!this.noWrap || this.center &gt;= 0 &amp;&amp; this.center &lt; this.count) {
         el = this.images[this._wrap(this.center)];
         var _transformString3 = alignment + &quot; translateX(&quot; + -delta / 2 + &quot;px) translateX(&quot; + dir * this.options.shift * tween + &quot;px) translateZ(&quot; + this.options.dist * tween + &quot;px)&quot;;
         this._updateItemStyle(el, centerTweenedOpacity, 0, _transformString3);
       }
</PRE><PRE>       // onCycleTo callback
       var $currItem = this.$el.find('.carousel-item').eq(this._wrap(this.center));
       if (lastCenter !== this.center &amp;&amp; typeof this.options.onCycleTo === 'function') {
         this.options.onCycleTo.call(this, $currItem[0], this.dragged);
       }
</PRE><PRE>       // One time callback
       if (typeof this.oneTimeCallback === 'function') {
         this.oneTimeCallback.call(this, $currItem[0], this.dragged);
         this.oneTimeCallback = null;
       }
     }
</PRE><PRE>     /**
      * Cycle to target
      * @param {Element} el
      * @param {Number} opacity
      * @param {Number} zIndex
      * @param {String} transform
      */
</PRE><PRE>   }, {
     key: &quot;_updateItemStyle&quot;,
     value: function _updateItemStyle(el, opacity, zIndex, transform) {
       el.style[this.xform] = transform;
       el.style.zIndex = zIndex;
       el.style.opacity = opacity;
       el.style.visibility = 'visible';
     }
</PRE><PRE>     /**
      * Cycle to target
      * @param {Number} n
      * @param {Function} callback
      */
</PRE><PRE>   }, {
     key: &quot;_cycleTo&quot;,
     value: function _cycleTo(n, callback) {
       var diff = this.center % this.count - n;
</PRE><PRE>       // Account for wraparound.
       if (!this.noWrap) {
         if (diff &lt; 0) {
           if (Math.abs(diff + this.count) &lt; Math.abs(diff)) {
             diff += this.count;
           }
         } else if (diff &gt; 0) {
           if (Math.abs(diff - this.count) &lt; diff) {
             diff -= this.count;
           }
         }
       }
</PRE><PRE>       this.target = this.dim * Math.round(this.offset / this.dim);
       // Next
       if (diff &lt; 0) {
         this.target += this.dim * Math.abs(diff);
</PRE><PRE>         // Prev
       } else if (diff &gt; 0) {
         this.target -= this.dim * diff;
       }
</PRE><PRE>       // Set one time callback
       if (typeof callback === 'function') {
         this.oneTimeCallback = callback;
       }
</PRE><PRE>       // Scroll
       if (this.offset !== this.target) {
         this.amplitude = this.target - this.offset;
         this.timestamp = Date.now();
         requestAnimationFrame(this._autoScrollBound);
       }
     }
</PRE><PRE>     /**
      * Cycle to next item
      * @param {Number} [n]
      */
</PRE><PRE>   }, {
     key: &quot;next&quot;,
     value: function next(n) {
       if (n === undefined || isNaN(n)) {
         n = 1;
       }
</PRE><PRE>       var index = this.center + n;
       if (index &gt;= this.count || index &lt; 0) {
         if (this.noWrap) {
           return;
         }
</PRE><PRE>         index = this._wrap(index);
       }
       this._cycleTo(index);
     }
</PRE><PRE>     /**
      * Cycle to previous item
      * @param {Number} [n]
      */
</PRE><PRE>   }, {
     key: &quot;prev&quot;,
     value: function prev(n) {
       if (n === undefined || isNaN(n)) {
         n = 1;
       }
</PRE><PRE>var index = this.center - n;
       if (index &gt;= this.count || index &lt; 0) {
         if (this.noWrap) {
           return;
         }
</PRE><PRE>         index = this._wrap(index);
       }
</PRE><PRE>       this._cycleTo(index);
     }
</PRE><PRE>     /**
      * Cycle to nth item
      * @param {Number} [n]
      * @param {Function} callback
      */
</PRE><PRE>   }, {
     key: &quot;set&quot;,
     value: function set(n, callback) {
       if (n === undefined || isNaN(n)) {
         n = 0;
       }
</PRE><PRE>       if (n &gt; this.count || n &lt; 0) {
         if (this.noWrap) {
           return;
         }
</PRE><PRE>         n = this._wrap(n);
       }
</PRE><PRE>       this._cycleTo(n, callback);
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Carousel.__proto__ || Object.getPrototypeOf(Carousel), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Carousel;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Carousel;
 }(Component);
</PRE><PRE> M.Carousel = Carousel;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Carousel, 'carousel', 'M_Carousel');
 }
</PRE><P>})(cash);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   onOpen: undefined,
   onClose: undefined
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var TapTarget = function (_Component19) {
   _inherits(TapTarget, _Component19);
</PRE><PRE>   /**
    * Construct TapTarget instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function TapTarget(el, options) {
     _classCallCheck(this, TapTarget);
</PRE><PRE>     var _this67 = _possibleConstructorReturn(this, (TapTarget.__proto__ || Object.getPrototypeOf(TapTarget)).call(this, TapTarget, el, options));
</PRE><PRE>     _this67.el.M_TapTarget = _this67;
</PRE><PRE>     /**
      * Options for the select
      * @member TapTarget#options
      * @prop {Function} onOpen - Callback function called when feature discovery is opened
      * @prop {Function} onClose - Callback function called when feature discovery is closed
      */
     _this67.options = $.extend({}, TapTarget.defaults, options);
</PRE><PRE>     _this67.isOpen = false;
</PRE><PRE>     // setup
     _this67.$origin = $('#' + _this67.$el.attr('data-target'));
     _this67._setup();
</PRE><PRE>     _this67._calculatePositioning();
     _this67._setupEventHandlers();
     return _this67;
   }
</PRE><PRE>   _createClass(TapTarget, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this.el.TapTarget = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleDocumentClickBound = this._handleDocumentClick.bind(this);
       this._handleTargetClickBound = this._handleTargetClick.bind(this);
       this._handleOriginClickBound = this._handleOriginClick.bind(this);
</PRE><PRE>       this.el.addEventListener('click', this._handleTargetClickBound);
       this.originEl.addEventListener('click', this._handleOriginClickBound);
</PRE><PRE>       // Resize
       var throttledResize = M.throttle(this._handleResize, 200);
       this._handleThrottledResizeBound = throttledResize.bind(this);
</PRE><PRE>       window.addEventListener('resize', this._handleThrottledResizeBound);
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('click', this._handleTargetClickBound);
       this.originEl.removeEventListener('click', this._handleOriginClickBound);
       window.removeEventListener('resize', this._handleThrottledResizeBound);
     }
</PRE><PRE>     /**
      * Handle Target Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleTargetClick&quot;,
     value: function _handleTargetClick(e) {
       this.open();
     }
</PRE><PRE>     /**
      * Handle Origin Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleOriginClick&quot;,
     value: function _handleOriginClick(e) {
       this.close();
     }
</PRE><PRE>     /**
      * Handle Resize
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleResize&quot;,
     value: function _handleResize(e) {
       this._calculatePositioning();
     }
</PRE><PRE>     /**
      * Handle Resize
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleDocumentClick&quot;,
     value: function _handleDocumentClick(e) {
       if (!$(e.target).closest('.tap-target-wrapper').length) {
         this.close();
         e.preventDefault();
         e.stopPropagation();
       }
     }
</PRE><PRE>     /**
      * Setup Tap Target
      */
</PRE><PRE>   }, {
     key: &quot;_setup&quot;,
     value: function _setup() {
       // Creating tap target
       this.wrapper = this.$el.parent()[0];
       this.waveEl = $(this.wrapper).find('.tap-target-wave')[0];
       this.originEl = $(this.wrapper).find('.tap-target-origin')[0];
       this.contentEl = this.$el.find('.tap-target-content')[0];
</PRE><PRE>       // Creating wrapper
       if (!$(this.wrapper).hasClass('.tap-target-wrapper')) {
         this.wrapper = document.createElement('div');
         this.wrapper.classList.add('tap-target-wrapper');
         this.$el.before($(this.wrapper));
         this.wrapper.append(this.el);
       }
</PRE><PRE>       // Creating content
       if (!this.contentEl) {
         this.contentEl = document.createElement('div');
         this.contentEl.classList.add('tap-target-content');
         this.$el.append(this.contentEl);
       }
</PRE><PRE>       // Creating foreground wave
       if (!this.waveEl) {
         this.waveEl = document.createElement('div');
         this.waveEl.classList.add('tap-target-wave');
</PRE><PRE>         // Creating origin
         if (!this.originEl) {
           this.originEl = this.$origin.clone(true, true);
           this.originEl.addClass('tap-target-origin');
           this.originEl.removeAttr('id');
           this.originEl.removeAttr('style');
           this.originEl = this.originEl[0];
           this.waveEl.append(this.originEl);
         }
</PRE><PRE>         this.wrapper.append(this.waveEl);
       }
     }
</PRE><PRE>     /**
      * Calculate positioning
      */
</PRE><PRE>   }, {
     key: &quot;_calculatePositioning&quot;,
     value: function _calculatePositioning() {
       // Element or parent is fixed position?
       var isFixed = this.$origin.css('position') === 'fixed';
       if (!isFixed) {
         var parents = this.$origin.parents();
         for (var i = 0; i &lt; parents.length; i++) {
           isFixed = $(parents[i]).css('position') == 'fixed';
           if (isFixed) {
             break;
           }
         }
       }
</PRE><PRE>       // Calculating origin
       var originWidth = this.$origin.outerWidth();
       var originHeight = this.$origin.outerHeight();
       var originTop = isFixed ? this.$origin.offset().top - M.getDocumentScrollTop() : this.$origin.offset().top;
       var originLeft = isFixed ? this.$origin.offset().left - M.getDocumentScrollLeft() : this.$origin.offset().left;
</PRE><PRE>       // Calculating screen
       var windowWidth = window.innerWidth;
       var windowHeight = window.innerHeight;
       var centerX = windowWidth / 2;
       var centerY = windowHeight / 2;
       var isLeft = originLeft &lt;= centerX;
       var isRight = originLeft &gt; centerX;
       var isTop = originTop &lt;= centerY;
       var isBottom = originTop &gt; centerY;
       var isCenterX = originLeft &gt;= windowWidth * 0.25 &amp;&amp; originLeft &lt;= windowWidth * 0.75;
</PRE><PRE>       // Calculating tap target
       var tapTargetWidth = this.$el.outerWidth();
       var tapTargetHeight = this.$el.outerHeight();
       var tapTargetTop = originTop + originHeight / 2 - tapTargetHeight / 2;
       var tapTargetLeft = originLeft + originWidth / 2 - tapTargetWidth / 2;
       var tapTargetPosition = isFixed ? 'fixed' : 'absolute';
</PRE><PRE>       // Calculating content
       var tapTargetTextWidth = isCenterX ? tapTargetWidth : tapTargetWidth / 2 + originWidth;
       var tapTargetTextHeight = tapTargetHeight / 2;
       var tapTargetTextTop = isTop ? tapTargetHeight / 2 : 0;
       var tapTargetTextBottom = 0;
       var tapTargetTextLeft = isLeft &amp;&amp; !isCenterX ? tapTargetWidth / 2 - originWidth : 0;
       var tapTargetTextRight = 0;
       var tapTargetTextPadding = originWidth;
       var tapTargetTextAlign = isBottom ? 'bottom' : 'top';
</PRE><PRE>       // Calculating wave
       var tapTargetWaveWidth = originWidth &gt; originHeight ? originWidth * 2 : originWidth * 2;
       var tapTargetWaveHeight = tapTargetWaveWidth;
       var tapTargetWaveTop = tapTargetHeight / 2 - tapTargetWaveHeight / 2;
       var tapTargetWaveLeft = tapTargetWidth / 2 - tapTargetWaveWidth / 2;
</PRE><PRE>       // Setting tap target
       var tapTargetWrapperCssObj = {};
       tapTargetWrapperCssObj.top = isTop ? tapTargetTop + 'px' : <I>;</I>
       tapTargetWrapperCssObj.right = isRight ? windowWidth - tapTargetLeft - tapTargetWidth + 'px' : <I>;</I>
       tapTargetWrapperCssObj.bottom = isBottom ? windowHeight - tapTargetTop - tapTargetHeight + 'px' : <I>;</I>
       tapTargetWrapperCssObj.left = isLeft ? tapTargetLeft + 'px' : <I>;</I>
       tapTargetWrapperCssObj.position = tapTargetPosition;
       $(this.wrapper).css(tapTargetWrapperCssObj);
</PRE><PRE>       // Setting content
       $(this.contentEl).css({
         width: tapTargetTextWidth + 'px',
         height: tapTargetTextHeight + 'px',
         top: tapTargetTextTop + 'px',
         right: tapTargetTextRight + 'px',
         bottom: tapTargetTextBottom + 'px',
         left: tapTargetTextLeft + 'px',
         padding: tapTargetTextPadding + 'px',
         verticalAlign: tapTargetTextAlign
       });
</PRE><PRE>       // Setting wave
       $(this.waveEl).css({
         top: tapTargetWaveTop + 'px',
         left: tapTargetWaveLeft + 'px',
         width: tapTargetWaveWidth + 'px',
         height: tapTargetWaveHeight + 'px'
       });
     }
</PRE><PRE>     /**
      * Open TapTarget
      */
</PRE><PRE>   }, {
     key: &quot;open&quot;,
     value: function open() {
       if (this.isOpen) {
         return;
       }
</PRE><PRE>       // onOpen callback
       if (typeof this.options.onOpen === 'function') {
         this.options.onOpen.call(this, this.$origin[0]);
       }
</PRE><PRE>       this.isOpen = true;
       this.wrapper.classList.add('open');
</PRE><PRE>       document.body.addEventListener('click', this._handleDocumentClickBound, true);
       document.body.addEventListener('touchend', this._handleDocumentClickBound);
     }
</PRE><PRE>     /**
      * Close Tap Target
      */
</PRE><PRE>   }, {
     key: &quot;close&quot;,
     value: function close() {
       if (!this.isOpen) {
         return;
       }
</PRE><PRE>       // onClose callback
       if (typeof this.options.onClose === 'function') {
         this.options.onClose.call(this, this.$origin[0]);
       }
</PRE><PRE>       this.isOpen = false;
       this.wrapper.classList.remove('open');
</PRE><PRE>       document.body.removeEventListener('click', this._handleDocumentClickBound, true);
       document.body.removeEventListener('touchend', this._handleDocumentClickBound);
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(TapTarget.__proto__ || Object.getPrototypeOf(TapTarget), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_TapTarget;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return TapTarget;
 }(Component);
</PRE><PRE> M.TapTarget = TapTarget;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(TapTarget, 'tapTarget', 'M_TapTarget');
 }
</PRE><P>})(cash);
</P><DL><DT>(function ($) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {
   classes: <I>,</I>
   dropdownOptions: {}
 };
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var FormSelect = function (_Component20) {
   _inherits(FormSelect, _Component20);
</PRE><PRE>   /**
    * Construct FormSelect instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function FormSelect(el, options) {
     _classCallCheck(this, FormSelect);
</PRE><PRE>     // Don't init if browser default version
     var _this68 = _possibleConstructorReturn(this, (FormSelect.__proto__ || Object.getPrototypeOf(FormSelect)).call(this, FormSelect, el, options));
</PRE><PRE>     if (_this68.$el.hasClass('browser-default')) {
       return _possibleConstructorReturn(_this68);
     }
</PRE><PRE>     _this68.el.M_FormSelect = _this68;
</PRE><PRE>     /**
      * Options for the select
      * @member FormSelect#options
      */
     _this68.options = $.extend({}, FormSelect.defaults, options);
</PRE><PRE>     _this68.isMultiple = _this68.$el.prop('multiple');
</PRE><PRE>     // Setup
     _this68.el.tabIndex = -1;
     _this68._keysSelected = {};
     _this68._valueDict = {}; // Maps key to original and generated option element.
     _this68._setupDropdown();
</PRE><PRE>     _this68._setupEventHandlers();
     return _this68;
   }
</PRE><PRE>   _createClass(FormSelect, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this._removeDropdown();
       this.el.M_FormSelect = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       var _this69 = this;
</PRE><PRE>       this._handleSelectChangeBound = this._handleSelectChange.bind(this);
       this._handleOptionClickBound = this._handleOptionClick.bind(this);
       this._handleInputClickBound = this._handleInputClick.bind(this);
</PRE><PRE>       $(this.dropdownOptions).find('li:not(.optgroup)').each(function (el) {
         el.addEventListener('click', _this69._handleOptionClickBound);
       });
       this.el.addEventListener('change', this._handleSelectChangeBound);
       this.input.addEventListener('click', this._handleInputClickBound);
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       var _this70 = this;
</PRE><PRE>       $(this.dropdownOptions).find('li:not(.optgroup)').each(function (el) {
         el.removeEventListener('click', _this70._handleOptionClickBound);
       });
       this.el.removeEventListener('change', this._handleSelectChangeBound);
       this.input.removeEventListener('click', this._handleInputClickBound);
     }
</PRE><PRE>     /**
      * Handle Select Change
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleSelectChange&quot;,
     value: function _handleSelectChange(e) {
       this._setValueToInput();
     }
</PRE><PRE>     /**
      * Handle Option Click
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleOptionClick&quot;,
     value: function _handleOptionClick(e) {
       e.preventDefault();
       var option = $(e.target).closest('li')[0];
       var key = option.id;
       if (!$(option).hasClass('disabled') &amp;&amp; !$(option).hasClass('optgroup') &amp;&amp; key.length) {
         var selected = true;
</PRE><PRE>         if (this.isMultiple) {
           // Deselect placeholder option if still selected.
           var placeholderOption = $(this.dropdownOptions).find('li.disabled.selected');
           if (placeholderOption.length) {
             placeholderOption.removeClass('selected');
             placeholderOption.find('input[type=&quot;checkbox&quot;]').prop('checked', false);
             this._toggleEntryFromArray(placeholderOption[0].id);
           }
           selected = this._toggleEntryFromArray(key);
         } else {
           $(this.dropdownOptions).find('li').removeClass('selected');
           $(option).toggleClass('selected', selected);
         }
</PRE><PRE>         // Set selected on original select option
         // Only trigger if selected state changed
         var prevSelected = $(this._valueDict[key].el).prop('selected');
         if (prevSelected !== selected) {
           $(this._valueDict[key].el).prop('selected', selected);
           this.$el.trigger('change');
         }
       }
</PRE><PRE>       e.stopPropagation();
     }
</PRE><PRE>     /**
      * Handle Input Click
      */
</PRE><PRE>   }, {
     key: &quot;_handleInputClick&quot;,
     value: function _handleInputClick() {
       if (this.dropdown &amp;&amp; this.dropdown.isOpen) {
         this._setValueToInput();
         this._setSelectedStates();
       }
     }
</PRE><PRE>     /**
      * Setup dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_setupDropdown&quot;,
     value: function _setupDropdown() {
       var _this71 = this;
</PRE><PRE>       this.wrapper = document.createElement('div');
       $(this.wrapper).addClass('select-wrapper ' + this.options.classes);
       this.$el.before($(this.wrapper));
       this.wrapper.appendChild(this.el);
</PRE><PRE>       if (this.el.disabled) {
         this.wrapper.classList.add('disabled');
       }
</PRE><PRE>       // Create dropdown
       this.$selectOptions = this.$el.children('option, optgroup');
       this.dropdownOptions = document.createElement('ul');
       this.dropdownOptions.id = &quot;select-options-&quot; + M.guid();
       $(this.dropdownOptions).addClass('dropdown-content select-dropdown ' + (this.isMultiple ? 'multiple-select-dropdown' : <I>));</I></PRE><PRE>       // Create dropdown structure.
       if (this.$selectOptions.length) {
         this.$selectOptions.each(function (el) {
           if ($(el).is('option')) {
             // Direct descendant option.
             var optionEl = void 0;
             if (_this71.isMultiple) {
               optionEl = _this71._appendOptionWithIcon(_this71.$el, el, 'multiple');
             } else {
               optionEl = _this71._appendOptionWithIcon(_this71.$el, el);
             }
</PRE><PRE>             _this71._addOptionToValueDict(el, optionEl);
           } else if ($(el).is('optgroup')) {
             // Optgroup.
             var selectOptions = $(el).children('option');
</PRE>
              $(_this71.dropdownOptions).append($('<LI class="optgroup"><SPAN>' + el.getAttribute('label') + '</SPAN></LI>')[0]);
<PRE>             selectOptions.each(function (el) {
               var optionEl = _this71._appendOptionWithIcon(_this71.$el, el, 'optgroup-option');
               _this71._addOptionToValueDict(el, optionEl);
             });
           }
         });
       }
</PRE><PRE>       this.$el.after(this.dropdownOptions);
</PRE><PRE>       // Add input dropdown
       this.input = document.createElement('input');
       $(this.input).addClass('select-dropdown dropdown-trigger');
       this.input.setAttribute('type', 'text');
       this.input.setAttribute('readonly', 'true');
       this.input.setAttribute('data-target', this.dropdownOptions.id);
       if (this.el.disabled) {
         $(this.input).prop('disabled', 'true');
       }
</PRE><PRE>       this.$el.before(this.input);
       this._setValueToInput();
</PRE><PRE>       // Add caret
       var dropdownIcon = $('&lt;svg class=&quot;caret&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;24&quot; xmlns=&quot;<A rel="nofollow" class="external free" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot;&gt;&lt;path d=&quot;M7 10l5 5 5-5z&quot;/&gt;&lt;path d=&quot;M0 0h24v24H0z&quot; fill=&quot;none&quot;/&gt;&lt;/svg&gt;');
       this.$el.before(dropdownIcon[0]);
</PRE><PRE>       // Initialize dropdown
       if (!this.el.disabled) {
         var dropdownOptions = $.extend({}, this.options.dropdownOptions);
</PRE><PRE>         // Add callback for centering selected option when dropdown content is scrollable
         dropdownOptions.onOpenEnd = function (el) {
           var selectedOption = $(_this71.dropdownOptions).find('.selected').first();
</PRE><PRE>           if (selectedOption.length) {
             // Focus selected option in dropdown
             M.keyDown = true;
             _this71.dropdown.focusedIndex = selectedOption.index();
             _this71.dropdown._focusFocusedItem();
             M.keyDown = false;
</PRE><PRE>             // Handle scrolling to selected option
             if (_this71.dropdown.isScrollable) {
               var scrollOffset = selectedOption[0].getBoundingClientRect().top - _this71.dropdownOptions.getBoundingClientRect().top; // scroll to selected option
               scrollOffset -= _this71.dropdownOptions.clientHeight / 2; // center in dropdown
               _this71.dropdownOptions.scrollTop = scrollOffset;
             }
           }
         };
</PRE><PRE>         if (this.isMultiple) {
           dropdownOptions.closeOnClick = false;
         }
         this.dropdown = M.Dropdown.init(this.input, dropdownOptions);
       }
</PRE><PRE>       // Add initial selections
       this._setSelectedStates();
     }
</PRE><PRE>     /**
      * Add option to value dict
      * @param {Element} el  original option element
      * @param {Element} optionEl  generated option element
      */
</PRE><PRE>   }, {
     key: &quot;_addOptionToValueDict&quot;,
     value: function _addOptionToValueDict(el, optionEl) {
       var index = Object.keys(this._valueDict).length;
       var key = this.dropdownOptions.id + index;
       var obj = {};
       optionEl.id = key;
</PRE><PRE>       obj.el = el;
       obj.optionEl = optionEl;
       this._valueDict[key] = obj;
     }
</PRE><PRE>     /**
      * Remove dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_removeDropdown&quot;,
     value: function _removeDropdown() {
       $(this.wrapper).find('.caret').remove();
       $(this.input).remove();
       $(this.dropdownOptions).remove();
       $(this.wrapper).before(this.$el);
       $(this.wrapper).remove();
     }
</PRE><PRE>     /**
      * Setup dropdown
      * @param {Element} select  select element
      * @param {Element} option  option element from select
      * @param {String} type
      * @return {Element}  option element added
      */
</PRE><PRE>   }, {
     key: &quot;_appendOptionWithIcon&quot;,
     value: function _appendOptionWithIcon(select, option, type) {
       // Add disabled attr if disabled
       var disabledClass = option.disabled ? 'disabled ' : <I>;</I>
       var optgroupClass = type === 'optgroup-option' ? 'optgroup-option ' : <I>;</I>
       var multipleCheckbox = this.isMultiple ? &quot;&lt;label&gt;&lt;input type=\&quot;checkbox\&quot;&quot; + disabledClass + &quot;\&quot;/&gt;<SPAN>&quot; + option.innerHTML + &quot;</SPAN>&lt;/label&gt;&quot; : option.innerHTML;
</PRE>
        var liEl = $('');
<PRE>       var spanEl = $('');
       spanEl.html(multipleCheckbox);
       liEl.addClass(disabledClass + &quot; &quot; + optgroupClass);
       liEl.append(spanEl);
</PRE><PRE>       // add icons
       var iconUrl = option.getAttribute('data-icon');
       if (!!iconUrl) {
         var imgEl = $(&quot;&lt;img alt=\&quot;\&quot; src=\&quot;&quot; + iconUrl + &quot;\&quot;&gt;&quot;);
         liEl.prepend(imgEl);
       }
</PRE><PRE>       // Check for multiple type.
       $(this.dropdownOptions).append(liEl[0]);
       return liEl[0];
     }
</PRE><PRE>     /**
      * Toggle entry from option
      * @param {String} key  Option key
      * @return {Boolean}  if entry was added or removed
      */
</PRE><PRE>   }, {
     key: &quot;_toggleEntryFromArray&quot;,
     value: function _toggleEntryFromArray(key) {
       var notAdded = !this._keysSelected.hasOwnProperty(key);
       var $optionLi = $(this._valueDict[key].optionEl);
</PRE><PRE>       if (notAdded) {
         this._keysSelected[key] = true;
       } else {
         delete this._keysSelected[key];
       }
</PRE><PRE>       $optionLi.toggleClass('selected', notAdded);
</PRE><PRE>       // Set checkbox checked value
       $optionLi.find('input[type=&quot;checkbox&quot;]').prop('checked', notAdded);
</PRE><PRE>       // use notAdded instead of true (to detect if the option is selected or not)
       $optionLi.prop('selected', notAdded);
</PRE><PRE>       return notAdded;
     }
</PRE><PRE>     /**
      * Set text value to input
      */
</PRE><PRE>   }, {
     key: &quot;_setValueToInput&quot;,
     value: function _setValueToInput() {
       var values = [];
       var options = this.$el.find('option');
</PRE><PRE>       options.each(function (el) {
         if ($(el).prop('selected')) {
           var text = $(el).text();
           values.push(text);
         }
       });
</PRE><PRE>       if (!values.length) {
         var firstDisabled = this.$el.find('option:disabled').eq(0);
         if (firstDisabled.length &amp;&amp; firstDisabled[0].value === <I>) {</I>
           values.push(firstDisabled.text());
         }
       }
</PRE><PRE>       this.input.value = values.join(', ');
     }
</PRE><PRE>     /**
      * Set selected state of dropdown to match actual select element
      */
</PRE><PRE>   }, {
     key: &quot;_setSelectedStates&quot;,
     value: function _setSelectedStates() {
       this._keysSelected = {};
</PRE><PRE>       for (var key in this._valueDict) {
         var option = this._valueDict[key];
         var optionIsSelected = $(option.el).prop('selected');
         $(option.optionEl).find('input[type=&quot;checkbox&quot;]').prop('checked', optionIsSelected);
         if (optionIsSelected) {
           this._activateOption($(this.dropdownOptions), $(option.optionEl));
           this._keysSelected[key] = true;
         } else {
           $(option.optionEl).removeClass('selected');
         }
       }
     }
</PRE><PRE>     /**
      * Make option as selected and scroll to selected position
      * @param {jQuery} collection  Select options jQuery element
      * @param {Element} newOption  element of the new option
      */
</PRE><PRE>   }, {
     key: &quot;_activateOption&quot;,
     value: function _activateOption(collection, newOption) {
       if (newOption) {
         if (!this.isMultiple) {
           collection.find('li.selected').removeClass('selected');
         }
         var option = $(newOption);
         option.addClass('selected');
       }
     }
</PRE><PRE>     /**
      * Get Selected Values
      * @return {Array}  Array of selected values
      */
</PRE><PRE>   }, {
     key: &quot;getSelectedValues&quot;,
     value: function getSelectedValues() {
       var selectedValues = [];
       for (var key in this._keysSelected) {
         selectedValues.push(this._valueDict[key].el.value);
       }
       return selectedValues;
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(FormSelect.__proto__ || Object.getPrototypeOf(FormSelect), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_FormSelect;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return FormSelect;
 }(Component);
</PRE><PRE> M.FormSelect = FormSelect;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(FormSelect, 'formSelect', 'M_FormSelect');
 }
</PRE><P>})(cash);
</P><DL><DT>(function ($, anim) {</DT></DL><PRE> 'use strict';
</PRE><PRE> var _defaults = {};
</PRE><PRE> /**
  * @class
  *
  */
</PRE><PRE> var Range = function (_Component21) {
   _inherits(Range, _Component21);
</PRE><PRE>   /**
    * Construct Range instance
    * @constructor
    * @param {Element} el
    * @param {Object} options
    */
   function Range(el, options) {
     _classCallCheck(this, Range);
</PRE><PRE>     var _this72 = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, Range, el, options));
</PRE><PRE>     _this72.el.M_Range = _this72;
</PRE><PRE>     /**
      * Options for the range
      * @member Range#options
      */
     _this72.options = $.extend({}, Range.defaults, options);
</PRE><PRE>     _this72._mousedown = false;
</PRE><PRE>     // Setup
     _this72._setupThumb();
</PRE><PRE>     _this72._setupEventHandlers();
     return _this72;
   }
</PRE><PRE>   _createClass(Range, [{
     key: &quot;destroy&quot;,
</PRE><PRE>     /**
      * Teardown component
      */
     value: function destroy() {
       this._removeEventHandlers();
       this._removeThumb();
       this.el.M_Range = undefined;
     }
</PRE><PRE>     /**
      * Setup Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_setupEventHandlers&quot;,
     value: function _setupEventHandlers() {
       this._handleRangeChangeBound = this._handleRangeChange.bind(this);
       this._handleRangeMousedownTouchstartBound = this._handleRangeMousedownTouchstart.bind(this);
       this._handleRangeInputMousemoveTouchmoveBound = this._handleRangeInputMousemoveTouchmove.bind(this);
       this._handleRangeMouseupTouchendBound = this._handleRangeMouseupTouchend.bind(this);
       this._handleRangeBlurMouseoutTouchleaveBound = this._handleRangeBlurMouseoutTouchleave.bind(this);
</PRE><PRE>       this.el.addEventListener('change', this._handleRangeChangeBound);
</PRE><PRE>       this.el.addEventListener('mousedown', this._handleRangeMousedownTouchstartBound);
       this.el.addEventListener('touchstart', this._handleRangeMousedownTouchstartBound);
</PRE><PRE>       this.el.addEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);
       this.el.addEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);
       this.el.addEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);
</PRE><PRE>       this.el.addEventListener('mouseup', this._handleRangeMouseupTouchendBound);
       this.el.addEventListener('touchend', this._handleRangeMouseupTouchendBound);
</PRE><PRE>       this.el.addEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);
       this.el.addEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);
       this.el.addEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);
     }
</PRE><PRE>     /**
      * Remove Event Handlers
      */
</PRE><PRE>   }, {
     key: &quot;_removeEventHandlers&quot;,
     value: function _removeEventHandlers() {
       this.el.removeEventListener('change', this._handleRangeChangeBound);
</PRE><PRE>       this.el.removeEventListener('mousedown', this._handleRangeMousedownTouchstartBound);
       this.el.removeEventListener('touchstart', this._handleRangeMousedownTouchstartBound);
</PRE><PRE>       this.el.removeEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);
       this.el.removeEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);
       this.el.removeEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);
</PRE><PRE>       this.el.removeEventListener('mouseup', this._handleRangeMouseupTouchendBound);
       this.el.removeEventListener('touchend', this._handleRangeMouseupTouchendBound);
</PRE><PRE>       this.el.removeEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);
       this.el.removeEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);
       this.el.removeEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);
     }
</PRE><PRE>     /**
      * Handle Range Change
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleRangeChange&quot;,
     value: function _handleRangeChange() {
       $(this.value).html(this.$el.val());
</PRE><PRE>       if (!$(this.thumb).hasClass('active')) {
         this._showRangeBubble();
       }
</PRE><PRE>       var offsetLeft = this._calcRangeOffset();
       $(this.thumb).addClass('active').css('left', offsetLeft + 'px');
     }
</PRE><PRE>     /**
      * Handle Range Mousedown and Touchstart
      * @param {Event} e
      */
</PRE><PRE>   }, {
     key: &quot;_handleRangeMousedownTouchstart&quot;,
     value: function _handleRangeMousedownTouchstart(e) {
       // Set indicator value
       $(this.value).html(this.$el.val());
</PRE><PRE>       this._mousedown = true;
       this.$el.addClass('active');
</PRE><PRE>       if (!$(this.thumb).hasClass('active')) {
         this._showRangeBubble();
       }
</PRE><PRE>       if (e.type !== 'input') {
         var offsetLeft = this._calcRangeOffset();
         $(this.thumb).addClass('active').css('left', offsetLeft + 'px');
       }
     }
</PRE><PRE>     /**
      * Handle Range Input, Mousemove and Touchmove
      */
</PRE><PRE>   }, {
     key: &quot;_handleRangeInputMousemoveTouchmove&quot;,
     value: function _handleRangeInputMousemoveTouchmove() {
       if (this._mousedown) {
         if (!$(this.thumb).hasClass('active')) {
           this._showRangeBubble();
         }
</PRE><PRE>         var offsetLeft = this._calcRangeOffset();
         $(this.thumb).addClass('active').css('left', offsetLeft + 'px');
         $(this.value).html(this.$el.val());
       }
     }
</PRE><PRE>     /**
      * Handle Range Mouseup and Touchend
      */
</PRE><PRE>   }, {
     key: &quot;_handleRangeMouseupTouchend&quot;,
     value: function _handleRangeMouseupTouchend() {
       this._mousedown = false;
       this.$el.removeClass('active');
     }
</PRE><PRE>     /**
      * Handle Range Blur, Mouseout and Touchleave
      */
</PRE><PRE>   }, {
     key: &quot;_handleRangeBlurMouseoutTouchleave&quot;,
     value: function _handleRangeBlurMouseoutTouchleave() {
       if (!this._mousedown) {
         var paddingLeft = parseInt(this.$el.css('padding-left'));
         var marginLeft = 7 + paddingLeft + 'px';
</PRE><PRE>         if ($(this.thumb).hasClass('active')) {
           anim.remove(this.thumb);
           anim({
             targets: this.thumb,
             height: 0,
             width: 0,
             top: 10,
             easing: 'easeOutQuad',
             marginLeft: marginLeft,
             duration: 100
           });
         }
         $(this.thumb).removeClass('active');
       }
     }
</PRE><PRE>     /**
      * Setup dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_setupThumb&quot;,
     value: function _setupThumb() {
       this.thumb = document.createElement('span');
       this.value = document.createElement('span');
       $(this.thumb).addClass('thumb');
       $(this.value).addClass('value');
       $(this.thumb).append(this.value);
       this.$el.after(this.thumb);
     }
</PRE><PRE>     /**
      * Remove dropdown
      */
</PRE><PRE>   }, {
     key: &quot;_removeThumb&quot;,
     value: function _removeThumb() {
       $(this.thumb).remove();
     }
</PRE><PRE>     /**
      * morph thumb into bubble
      */
</PRE><PRE>   }, {
     key: &quot;_showRangeBubble&quot;,
     value: function _showRangeBubble() {
       var paddingLeft = parseInt($(this.thumb).parent().css('padding-left'));
       var marginLeft = -7 + paddingLeft + 'px'; // TODO: fix magic number?
       anim.remove(this.thumb);
       anim({
         targets: this.thumb,
         height: 30,
         width: 30,
         top: -30,
         marginLeft: marginLeft,
         duration: 300,
         easing: 'easeOutQuint'
       });
     }
</PRE><PRE>     /**
      * Calculate the offset of the thumb
      * @return {Number}  offset in pixels
      */
</PRE><PRE>   }, {
     key: &quot;_calcRangeOffset&quot;,
     value: function _calcRangeOffset() {
       var width = this.$el.width() - 15;
       var max = parseFloat(this.$el.attr('max')) || 100; // Range default max
       var min = parseFloat(this.$el.attr('min')) || 0; // Range default min
       var percent = (parseFloat(this.$el.val()) - min) / (max - min);
       return percent * width;
     }
   }], [{
     key: &quot;init&quot;,
     value: function init(els, options) {
       return _get(Range.__proto__ || Object.getPrototypeOf(Range), &quot;init&quot;, this).call(this, this, els, options);
     }
</PRE><PRE>     /**
      * Get Instance
      */
</PRE><PRE>   }, {
     key: &quot;getInstance&quot;,
     value: function getInstance(el) {
       var domElem = !!el.jquery ? el[0] : el;
       return domElem.M_Range;
     }
   }, {
     key: &quot;defaults&quot;,
     get: function () {
       return _defaults;
     }
   }]);
</PRE><PRE>   return Range;
 }(Component);
</PRE><PRE> M.Range = Range;
</PRE><PRE> if (M.jQueryLoaded) {
   M.initializeJqueryWrapper(Range, 'range', 'M_Range');
 }
</PRE><PRE> Range.init($('input[type=range]'));
</PRE><P>})(cash, M.anime);</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
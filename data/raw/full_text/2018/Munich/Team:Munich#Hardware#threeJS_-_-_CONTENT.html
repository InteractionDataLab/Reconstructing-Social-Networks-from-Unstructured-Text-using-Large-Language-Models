<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Munich_Hardware_threeJS skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Munich/Hardware/threeJS</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P>(function (global, factory) {
	typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' &amp;&amp; define.amd ? define(['exports'], factory) :
	(factory((global.THREE = {})));
}(this, (function (exports) { 'use strict';
</P><P>	// Polyfills
</P><P>	if ( Number.EPSILON === undefined ) {
</P><P>		Number.EPSILON = Math.pow( 2, - 52 );
</P><P>	}
</P><P>	if ( Number.isInteger === undefined ) {
</P><P>		// Missing in IE
		// <A rel="nofollow" class="external free" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger</A></P><P>		Number.isInteger = function ( value ) {
</P><P>			return typeof value === 'number' &amp;&amp; isFinite( value ) &amp;&amp; Math.floor( value ) === value;
</P><P>		};
</P><P>	}
</P><P>	//
</P><P>	if ( Math.sign === undefined ) {
</P><P>		// <A rel="nofollow" class="external free" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign</A></P><P>		Math.sign = function ( x ) {
</P><P>			return ( x &lt; 0 ) ? - 1 : ( x &gt; 0 ) ? 1 : + x;
</P><P>		};
</P><P>	}
</P><P>	if ( 'name' in Function.prototype === false ) {
</P><P>		// Missing in IE
		// <A rel="nofollow" class="external free" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name</A></P><P>		Object.defineProperty( Function.prototype, 'name', {
</P><P>			get: function () {
</P><P>				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];
</P><P>			}
</P><P>		} );
</P><P>	}
</P><P>	if ( Object.assign === undefined ) {
</P><P>		// Missing in IE
		// <A rel="nofollow" class="external free" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</A></P><P>		( function () {
</P><P>			Object.assign = function ( target ) {
</P><P>				if ( target === undefined || target === null ) {
</P><P>					throw new TypeError( 'Cannot convert undefined or null to object' );
</P><P>				}
</P><P>				var output = Object( target );
</P><P>				for ( var index = 1; index &lt; arguments.length; index ++ ) {
</P><P>					var source = arguments[ index ];
</P><P>					if ( source !== undefined &amp;&amp; source !== null ) {
</P><P>						for ( var nextKey in source ) {
</P><P>							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {
</P><P>								output[ nextKey ] = source[ nextKey ];
</P><P>							}
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>				return output;
</P><P>			};
</P><P>		} )();
</P><P>	}
</P><P>	/**
	 * <A rel="nofollow" class="external free" href="https://github.com/mrdoob/eventdispatcher.js/">https://github.com/mrdoob/eventdispatcher.js/</A>
	 */
</P><P>	function EventDispatcher() {}
</P><P>	Object.assign( EventDispatcher.prototype, {
</P><P>		addEventListener: function ( type, listener ) {
</P><P>			if ( this._listeners === undefined ) this._listeners = {};
</P><P>			var listeners = this._listeners;
</P><P>			if ( listeners[ type ] === undefined ) {
</P><P>				listeners[ type ] = [];
</P><P>			}
</P><P>			if ( listeners[ type ].indexOf( listener ) === - 1 ) {
</P><P>				listeners[ type ].push( listener );
</P><P>			}
</P><P>		},
</P><P>		hasEventListener: function ( type, listener ) {
</P><P>			if ( this._listeners === undefined ) return false;
</P><P>			var listeners = this._listeners;
</P><P>			return listeners[ type ] !== undefined &amp;&amp; listeners[ type ].indexOf( listener ) !== - 1;
</P><P>		},
</P><P>		removeEventListener: function ( type, listener ) {
</P><P>			if ( this._listeners === undefined ) return;
</P><P>			var listeners = this._listeners;
			var listenerArray = listeners[ type ];
</P><P>			if ( listenerArray !== undefined ) {
</P><P>				var index = listenerArray.indexOf( listener );
</P><P>				if ( index !== - 1 ) {
</P><P>					listenerArray.splice( index, 1 );
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		dispatchEvent: function ( event ) {
</P><P>			if ( this._listeners === undefined ) return;
</P><P>			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];
</P><P>			if ( listenerArray !== undefined ) {
</P><P>				event.target = this;
</P><P>				var array = listenerArray.slice( 0 );
</P><P>				for ( var i = 0, l = array.length; i &lt; l; i ++ ) {
</P><P>					array[ i ].call( this, event );
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	var REVISION = '97';
	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RedFormat = 1028;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	var _Math = {
</P><P>		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,
</P><P>		generateUUID: ( function () {
</P><P>			// <A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136">http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136</A></P><P>			var lut = [];
</P><P>			for ( var i = 0; i &lt; 256; i ++ ) {
</P><P>				lut[ i ] = ( i &lt; 16 ? '0' : <I> ) + ( i ).toString( 16 );</I></P><P>			}
</P><P>			return function generateUUID() {
</P><P>				var d0 = Math.random() * 0xffffffff | 0;
				var d1 = Math.random() * 0xffffffff | 0;
				var d2 = Math.random() * 0xffffffff | 0;
				var d3 = Math.random() * 0xffffffff | 0;
				var uuid = lut[ d0 &amp; 0xff ] + lut[ d0 &gt;&gt; 8 &amp; 0xff ] + lut[ d0 &gt;&gt; 16 &amp; 0xff ] + lut[ d0 &gt;&gt; 24 &amp; 0xff ] + '-' +
					lut[ d1 &amp; 0xff ] + lut[ d1 &gt;&gt; 8 &amp; 0xff ] + '-' + lut[ d1 &gt;&gt; 16 &amp; 0x0f | 0x40 ] + lut[ d1 &gt;&gt; 24 &amp; 0xff ] + '-' +
					lut[ d2 &amp; 0x3f | 0x80 ] + lut[ d2 &gt;&gt; 8 &amp; 0xff ] + '-' + lut[ d2 &gt;&gt; 16 &amp; 0xff ] + lut[ d2 &gt;&gt; 24 &amp; 0xff ] +
					lut[ d3 &amp; 0xff ] + lut[ d3 &gt;&gt; 8 &amp; 0xff ] + lut[ d3 &gt;&gt; 16 &amp; 0xff ] + lut[ d3 &gt;&gt; 24 &amp; 0xff ];
</P><P>				// .toUpperCase() here flattens concatenated strings to save heap memory space.
				return uuid.toUpperCase();
</P><P>			};
</P><P>		} )(),
</P><P>		clamp: function ( value, min, max ) {
</P><P>			return Math.max( min, Math.min( max, value ) );
</P><P>		},
</P><P>		// compute euclidian modulo of m % n
		// <A rel="nofollow" class="external free" href="https://en.wikipedia.org/wiki/Modulo_operation">https://en.wikipedia.org/wiki/Modulo_operation</A></P><P>		euclideanModulo: function ( n, m ) {
</P><P>			return ( ( n % m ) + m ) % m;
</P><P>		},
</P><P>		// Linear mapping from range &lt;a1, a2&gt; to range &lt;b1, b2&gt;</P><P>		mapLinear: function ( x, a1, a2, b1, b2 ) {
</P><P>			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
</P><P>		},
</P><P>		// <A rel="nofollow" class="external free" href="https://en.wikipedia.org/wiki/Linear_interpolation">https://en.wikipedia.org/wiki/Linear_interpolation</A></P><P>		lerp: function ( x, y, t ) {
</P><P>			return ( 1 - t ) * x + t * y;
</P><P>		},
</P><P>		// <A rel="nofollow" class="external free" href="http://en.wikipedia.org/wiki/Smoothstep">http://en.wikipedia.org/wiki/Smoothstep</A></P><P>		smoothstep: function ( x, min, max ) {
</P><P>			if ( x &lt;= min ) return 0;
			if ( x &gt;= max ) return 1;
</P><P>			x = ( x - min ) / ( max - min );
</P><P>			return x * x * ( 3 - 2 * x );
</P><P>		},
</P><P>		smootherstep: function ( x, min, max ) {
</P><P>			if ( x &lt;= min ) return 0;
			if ( x &gt;= max ) return 1;
</P><P>			x = ( x - min ) / ( max - min );
</P><P>			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
</P><P>		},
</P><P>		// Random integer from &lt;low, high&gt; interval
</P><P>		randInt: function ( low, high ) {
</P><P>			return low + Math.floor( Math.random() * ( high - low + 1 ) );
</P><P>		},
</P><P>		// Random float from &lt;low, high&gt; interval
</P><P>		randFloat: function ( low, high ) {</P><P>			return low + Math.random() * ( high - low );
</P><P>		},
</P><P>		// Random float from &lt;-range/2, range/2&gt; interval
</P><P>		randFloatSpread: function ( range ) {
</P><P>			return range * ( 0.5 - Math.random() );
</P><P>		},
</P><P>		degToRad: function ( degrees ) {
</P><P>			return degrees * _Math.DEG2RAD;
</P><P>		},
</P><P>		radToDeg: function ( radians ) {
</P><P>			return radians * _Math.RAD2DEG;
</P><P>		},
</P><P>		isPowerOfTwo: function ( value ) {
</P><P>			return ( value &amp; ( value - 1 ) ) === 0 &amp;&amp; value !== 0;
</P><P>		},
</P><P>		ceilPowerOfTwo: function ( value ) {
</P><P>			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );
</P><P>		},
</P><P>		floorPowerOfTwo: function ( value ) {
</P><P>			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );
</P><P>		}
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author philogb / <A rel="nofollow" class="external free" href="http://blog.thejit.org/">http://blog.thejit.org/</A>
	 * @author egraether / <A rel="nofollow" class="external free" href="http://egraether.com/">http://egraether.com/</A>
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 */
</P><P>	function Vector2( x, y ) {
</P><P>		this.x = x || 0;
		this.y = y || 0;
</P><P>	}
</P><P>	Object.defineProperties( Vector2.prototype, {
</P><P>		&quot;width&quot;: {
</P><P>			get: function () {
</P><P>				return this.x;
</P><P>			},
</P><P>			set: function ( value ) {
</P><P>				this.x = value;
</P><P>			}
</P><P>		},
</P><P>		&quot;height&quot;: {
</P><P>			get: function () {
</P><P>				return this.y;
</P><P>			},
</P><P>			set: function ( value ) {
</P><P>				this.y = value;
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Vector2.prototype, {
</P><P>		isVector2: true,
</P><P>		set: function ( x, y ) {
</P><P>			this.x = x;
			this.y = y;
</P><P>			return this;
</P><P>		},
</P><P>	setScalar: function ( scalar ) {
</P><P>			this.x = scalar;
			this.y = scalar;
</P><P>			return this;
</P><P>		},
</P><P>		setX: function ( x ) {
</P><P>			this.x = x;
</P><P>			return this;
</P><P>		},
</P><P>		setY: function ( y ) {
</P><P>			this.y = y;
</P><P>			return this;
</P><P>		},
</P><P>		setComponent: function ( index, value ) {
</P><P>			switch ( index ) {
</P><P>				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		getComponent: function ( index ) {
</P><P>			switch ( index ) {
</P><P>				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );
</P><P>			}
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.x, this.y );
</P><P>		},
</P><P>		copy: function ( v ) {
</P><P>			this.x = v.x;
			this.y = v.y;
</P><P>			return this;
</P><P>		},
</P><P>		add: function ( v, w ) {
</P><P>			if ( w !== undefined ) {
</P><P>				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
</P><P>			}
</P><P>			this.x += v.x;
			this.y += v.y;
</P><P>			return this;
</P><P>		},
</P><P>		addScalar: function ( s ) {
</P><P>			this.x += s;
			this.y += s;
</P><P>			return this;
</P><P>		},
</P><P>		addVectors: function ( a, b ) {
</P><P>			this.x = a.x + b.x;
			this.y = a.y + b.y;
</P><P>			return this;
</P><P>		},
</P><P>		addScaledVector: function ( v, s ) {
</P><P>			this.x += v.x * s;
			this.y += v.y * s;
</P><P>			return this;
</P><P>		},
</P><P>		sub: function ( v, w ) {
</P><P>			if ( w !== undefined ) {
</P><P>				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
</P><P>			}
</P><P>			this.x -= v.x;
			this.y -= v.y;
</P><P>			return this;
</P><P>		},
</P><P>		subScalar: function ( s ) {
</P><P>this.x -= s;
			this.y -= s;
</P><P>			return this;
</P><P>		},
</P><P>		subVectors: function ( a, b ) {
</P><P>			this.x = a.x - b.x;
			this.y = a.y - b.y;
</P><P>			return this;
</P><P>		},
</P><P>		multiply: function ( v ) {
</P><P>			this.x *= v.x;
			this.y *= v.y;
</P><P>			return this;
</P><P>		},
</P><P>		multiplyScalar: function ( scalar ) {
</P><P>			this.x *= scalar;
			this.y *= scalar;
</P><P>			return this;
</P><P>		},
</P><P>		divide: function ( v ) {
</P><P>			this.x /= v.x;
			this.y /= v.y;
</P><P>			return this;
</P><P>		},
</P><P>		divideScalar: function ( scalar ) {
</P><P>			return this.multiplyScalar( 1 / scalar );
</P><P>		},
</P><P>		applyMatrix3: function ( m ) {
</P><P>			var x = this.x, y = this.y;
			var e = m.elements;
</P><P>			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];
</P><P>			return this;
</P><P>		},
</P><P>		min: function ( v ) {
</P><P>			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
</P><P>			return this;
</P><P>		},
</P><P>		max: function ( v ) {
</P><P>			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
</P><P>			return this;
</P><P>		},
</P><P>		clamp: function ( min, max ) {
</P><P>			// assumes min &lt; max, componentwise
</P><P>			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
</P><P>			return this;
</P><P>		},
</P><P>		clampScalar: function () {
</P><P>			var min = new Vector2();
			var max = new Vector2();
</P><P>			return function clampScalar( minVal, maxVal ) {
</P><P>				min.set( minVal, minVal );
				max.set( maxVal, maxVal );
</P><P>				return this.clamp( min, max );
</P><P>			};
</P><P>		}(),
</P><P>		clampLength: function ( min, max ) {
</P><P>			var length = this.length();
</P><P>			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
</P><P>		},
</P><P>		floor: function () {
</P><P>			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
</P><P>			return this;
</P><P>		},
</P><P>		ceil: function () {
</P><P>			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
</P><P>			return this;
</P><P>		},
</P><P>		round: function () {
</P><P>			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
</P><P>			return this;
</P><P>		},
</P><P>		roundToZero: function () {
</P><P>			this.x = ( this.x &lt; 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y &lt; 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
</P><P>			return this;
</P><P>		},
</P><P>		negate: function () {
</P><P>			this.x = - this.x;
			this.y = - this.y;
</P><P>			return this;
</P><P>		},
</P><P>		dot: function ( v ) {
</P><P>			return this.x * v.x + this.y * v.y;
</P><P>		},
</P><P>		cross: function ( v ) {
</P><P>			return this.x * v.y - this.y * v.x;
</P><P>		},
</P><P>		lengthSq: function () {
</P><P>			return this.x * this.x + this.y * this.y;
</P><P>		},
</P><P>		length: function () {
</P><P>			return Math.sqrt( this.x * this.x + this.y * this.y );
</P><P>		},
</P><P>		manhattanLength: function () {
</P><P>			return Math.abs( this.x ) + Math.abs( this.y );
</P><P>		},
</P><P>		normalize: function () {
</P><P>			return this.divideScalar( this.length() || 1 );
</P><P>		},
</P><P>		angle: function () {
</P><P>			// computes the angle in radians with respect to the positive x-axis
</P><P>			var angle = Math.atan2( this.y, this.x );
</P><P>			if ( angle &lt; 0 ) angle += 2 * Math.PI;
</P><P>			return angle;
</P><P>		},
</P><P>		distanceTo: function ( v ) {
</P><P>			return Math.sqrt( this.distanceToSquared( v ) );
</P><P>		},
</P><P>		distanceToSquared: function ( v ) {
</P><P>			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
</P><P>		},
</P><P>		manhattanDistanceTo: function ( v ) {
</P><P>			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
</P><P>		},
</P><P>		setLength: function ( length ) {
</P><P>			return this.normalize().multiplyScalar( length );
</P><P>		},
</P><P>		lerp: function ( v, alpha ) {</P><P>			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
</P><P>			return this;
</P><P>		},
</P><P>		lerpVectors: function ( v1, v2, alpha ) {
</P><P>			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
</P><P>		},
</P><P>		equals: function ( v ) {
</P><P>			return ( ( v.x === this.x ) &amp;&amp; ( v.y === this.y ) );
</P><P>		},
</P><P>		fromArray: function ( array, offset ) {
</P><P>			if ( offset === undefined ) offset = 0;
</P><P>			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
</P><P>			return this;
</P><P>		},
</P><P>		toArray: function ( array, offset ) {
</P><P>			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
</P><P>			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
</P><P>			return array;
</P><P>		},
</P><P>		fromBufferAttribute: function ( attribute, index, offset ) {
</P><P>			if ( offset !== undefined ) {
</P><P>				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );
</P><P>			}
</P><P>			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
</P><P>			return this;
</P><P>		},
</P><P>		rotateAround: function ( center, angle ) {
</P><P>			var c = Math.cos( angle ), s = Math.sin( angle );
</P><P>			var x = this.x - center.x;
			var y = this.y - center.y;
</P><P>			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author supereggbert / <A rel="nofollow" class="external free" href="http://www.paulbrunt.co.uk/">http://www.paulbrunt.co.uk/</A>
	 * @author philogb / <A rel="nofollow" class="external free" href="http://blog.thejit.org/">http://blog.thejit.org/</A>
	 * @author jordi_ros / <A rel="nofollow" class="external free" href="http://plattsoft.com">http://plattsoft.com</A>
	 * @author D1plo1d / <A rel="nofollow" class="external free" href="http://github.com/D1plo1d">http://github.com/D1plo1d</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author timknip / <A rel="nofollow" class="external free" href="http://www.floorplanner.com/">http://www.floorplanner.com/</A>
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function Matrix4() {
</P><P>		this.elements = [
</P><P>			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
</P><P>		];
</P><P>		if ( arguments.length &gt; 0 ) {
</P><P>			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
</P><P>		}
</P><P>	}
</P><P>	Object.assign( Matrix4.prototype, {
</P><P>		isMatrix4: true,
</P><P>		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
</P><P>			var te = this.elements;
</P><P>			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
</P><P>			return this;
</P><P>		},
</P><P>		identity: function () {
</P><P>			this.set(
</P><P>				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
</P><P>			);
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new Matrix4().fromArray( this.elements );
</P><P>		},
</P><P>		copy: function ( m ) {
</P><P>			var te = this.elements;
			var me = m.elements;
</P><P>			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];
</P><P>			return this;
</P><P>		},
</P><P>		copyPosition: function ( m ) {
</P><P>			var te = this.elements, me = m.elements;
</P><P>			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];
</P><P>			return this;
</P><P>		},
</P><P>		extractBasis: function ( xAxis, yAxis, zAxis ) {
</P><P>			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );
</P><P>			return this;
</P><P>		},
</P><P>		makeBasis: function ( xAxis, yAxis, zAxis ) {
</P><P>			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);
</P><P>			return this;
</P><P>		},
</P><P>		extractRotation: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function extractRotation( m ) {
</P><P>				// this method does not support reflection matrices
</P><P>				var te = this.elements;
				var me = m.elements;
</P><P>				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();
</P><P>				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
				te[ 3 ] = 0;
</P><P>				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
				te[ 7 ] = 0;
</P><P>				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
				te[ 11 ] = 0;
</P><P>				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		makeRotationFromEuler: function ( euler ) {
</P><P>			if ( ! ( euler &amp;&amp; euler.isEuler ) ) {
</P><P>				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
</P><P>			}
</P><P>			var te = this.elements;
</P><P>			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
</P><P>			if ( euler.order === 'XYZ' ) {
</P><P>				var ae = a * e, af = a * f, be = b * e, bf = b * f;
</P><P>				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;
</P><P>				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;
</P><P>				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;
</P><P>			} else if ( euler.order === 'YXZ' ) {
</P><P>				var ce = c * e, cf = c * f, de = d * e, df = d * f;
</P><P>				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;
</P><P>				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;
</P><P>				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;
</P><P>			} else if ( euler.order === 'ZXY' ) {
</P><P>				var ce = c * e, cf = c * f, de = d * e, df = d * f;
</P><P>				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;
</P><P>				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;
</P><P>				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;
</P><P>			} else if ( euler.order === 'ZYX' ) {
</P><P>				var ae = a * e, af = a * f, be = b * e, bf = b * f;
</P><P>				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;
</P><P>				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;
</P><P>				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;
</P><P>			} else if ( euler.order === 'YZX' ) {
</P><P>				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
</P><P>				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;
</P><P>				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;
</P><P>				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;
</P><P>			} else if ( euler.order === 'XZY' ) {
</P><P>				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
</P><P>				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;
</P><P>				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;
</P><P>				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;
</P><P>			}
</P><P>			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
</P><P>			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
</P><P>			return this;
</P><P>		},
</P><P>		makeRotationFromQuaternion: function () {
</P><P>			var zero = new Vector3( 0, 0, 0 );
			var one = new Vector3( 1, 1, 1 );
</P><P>			return function makeRotationFromQuaternion( q ) {
</P><P>				return this.compose( zero, q, one );
</P><P>			};
</P><P>		}(),
</P><P>		lookAt: function () {
</P><P>			var x = new Vector3();
			var y = new Vector3();
			var z = new Vector3();
</P><P>			return function lookAt( eye, target, up ) {
</P><P>				var te = this.elements;
</P><P>				z.subVectors( eye, target );
</P><P>				if ( z.lengthSq() === 0 ) {
</P><P>					// eye and target are in the same position
</P><P>					z.z = 1;
</P><P>				}
</P><P>				z.normalize();
				x.crossVectors( up, z );
</P><P>				if ( x.lengthSq() === 0 ) {
</P><P>					// up and z are parallel
</P><P>					if ( Math.abs( up.z ) === 1 ) {
</P><P>						z.x += 0.0001;
</P><P>					} else {
</P><P>						z.z += 0.0001;
</P><P>					}
</P><P>					z.normalize();
					x.crossVectors( up, z );
</P><P>				}
</P><P>				x.normalize();
				y.crossVectors( z, x );
</P><P>				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		multiply: function ( m, n ) {
</P><P>			if ( n !== undefined ) {
</P><P>				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
</P><P>			}
</P><P>			return this.multiplyMatrices( this, m );
</P><P>		},
</P><P>		premultiply: function ( m ) {
</P><P>			return this.multiplyMatrices( m, this );
</P><P>		},
</P><P>		multiplyMatrices: function ( a, b ) {
</P><P>			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
</P><P>			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
</P><P>			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
</P><P>			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
</P><P>			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
</P><P>			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
</P><P>			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
</P><P>			return this;
</P><P>		},
</P><P>		multiplyScalar: function ( s ) {
</P><P>			var te = this.elements;
</P><P>			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
</P><P>			return this;
</P><P>		},
</P><P>		applyToBufferAttribute: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function applyToBufferAttribute( attribute ) {
</P><P>				for ( var i = 0, l = attribute.count; i &lt; l; i ++ ) {
</P><P>					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );
</P><P>					v1.applyMatrix4( this );
</P><P>					attribute.setXYZ( i, v1.x, v1.y, v1.z );
</P><P>				}
</P><P>				return attribute;
</P><P>			};
</P><P>		}(),
</P><P>		determinant: function () {
</P><P>			var te = this.elements;
</P><P>			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
</P><P>			//TODO: make this more efficient
			//( based on <A rel="nofollow" class="external free" href="http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm">http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm</A> )
</P><P>			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)
</P><P>			);
</P><P>		},
</P><P>		transpose: function () {
</P><P>			var te = this.elements;
			var tmp;
</P><P>			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
</P><P>			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
</P><P>			return this;
</P><P>		},
</P><P>		setPosition: function ( v ) {
</P><P>			var te = this.elements;
</P><P>			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;
</P><P>			return this;
</P><P>		},
</P><P>		getInverse: function ( m, throwOnDegenerate ) {
</P><P>			// based on <A rel="nofollow" class="external free" href="http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm">http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm</A>
			var te = this.elements,
				me = m.elements,
</P><P>				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
</P><P>				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
</P><P>			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
</P><P>			if ( det === 0 ) {
</P><P>				var msg = &quot;THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0&quot;;
</P><P>				if ( throwOnDegenerate === true ) {
</P><P>					throw new Error( msg );
</P><P>				} else {
</P><P>					console.warn( msg );
</P><P>				}
</P><P>				return this.identity();
</P><P>			}
</P><P>			var detInv = 1 / det;
</P><P>			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
</P><P>			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
</P><P>			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
</P><P>			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
</P><P>			return this;
</P><P>		},
</P><P>		scale: function ( v ) {
</P><P>			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
</P><P>			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
</P><P>			return this;
</P><P>		},
</P><P>		getMaxScaleOnAxis: function () {
</P><P>			var te = this.elements;
</P><P>			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
</P><P>			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
</P><P>		},
</P><P>		makeTranslation: function ( x, y, z ) {
</P><P>			this.set(
</P><P>				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
</P><P>			);
</P><P>			return this;
</P><P>		},
</P><P>		makeRotationX: function ( theta ) {
</P><P>			var c = Math.cos( theta ), s = Math.sin( theta );
</P><P>			this.set(
</P><P>				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1
</P><P>			);
</P><P>			return this;
</P><P>		},
</P><P>		makeRotationY: function ( theta ) {
</P><P>			var c = Math.cos( theta ), s = Math.sin( theta );
</P><P>			this.set(
</P><P>				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1
</P><P>			);
</P><P>			return this;
</P><P>		},
</P><P>		makeRotationZ: function ( theta ) {
</P><P>			var c = Math.cos( theta ), s = Math.sin( theta );
</P><P>			this.set(
</P><P>				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
</P><P>			);
</P><P>			return this;
</P><P>		},
</P><P>		makeRotationAxis: function ( axis, angle ) {
</P><P>			// Based on <A rel="nofollow" class="external free" href="http://www.gamedev.net/reference/articles/article1199.asp">http://www.gamedev.net/reference/articles/article1199.asp</A></P><P>			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
</P><P>			this.set(
</P><P>				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
</P><P>			);
</P><P>			 return this;
</P><P>		},
</P><P>		makeScale: function ( x, y, z ) {
</P><P>			this.set(
</P><P>				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
</P><P>			);
</P><P>			return this;
</P><P>		},
</P><P>		makeShear: function ( x, y, z ) {
</P><P>			this.set(
</P><P>				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1
</P><P>			);
</P><P>			return this;
</P><P>		},
</P><P>		compose: function ( position, quaternion, scale ) {
</P><P>			var te = this.elements;
</P><P>			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
</P><P>			var sx = scale.x, sy = scale.y, sz = scale.z;
</P><P>		        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		        te[ 1 ] = ( xy + wz ) * sx;
		        te[ 2 ] = ( xz - wy ) * sx;
		        te[ 3 ] = 0;
</P><P>		        te[ 4 ] = ( xy - wz ) * sy;
		        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		        te[ 6 ] = ( yz + wx ) * sy;
		        te[ 7 ] = 0;
</P><P>		        te[ 8 ] = ( xz + wy ) * sz;
		        te[ 9 ] = ( yz - wx ) * sz;
		        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		        te[ 11 ] = 0;
</P><P>		        te[ 12 ] = position.x;
		        te[ 13 ] = position.y;
		        te[ 14 ] = position.z;
		        te[ 15 ] = 1;
</P><P>		        return this;
</P><P>		},
</P><P>		decompose: function () {
</P><P>			var vector = new Vector3();
			var matrix = new Matrix4();
</P><P>			return function decompose( position, quaternion, scale ) {
</P><P>				var te = this.elements;
</P><P>				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
</P><P>				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det &lt; 0 ) sx = - sx;
</P><P>				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];
</P><P>				// scale the rotation part
				matrix.copy( this );
</P><P>				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;
</P><P>				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;
</P><P>				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;
</P><P>				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;
</P><P>				quaternion.setFromRotationMatrix( matrix );
</P><P>				scale.x = sx;
				scale.y = sy;
				scale.z = sz;
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		makePerspective: function ( left, right, top, bottom, near, far ) {
</P><P>			if ( far === undefined ) {
</P><P>				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );
</P><P>			}
</P><P>			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
</P><P>			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
</P><P>			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
</P><P>			return this;
</P><P>		},
</P><P>		makeOrthographic: function ( left, right, top, bottom, near, far ) {
</P><P>			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );
</P><P>			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;
</P><P>			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
</P><P>			return this;
</P><P>		},
</P><P>		equals: function ( matrix ) {
</P><P>			var te = this.elements;
			var me = matrix.elements;
</P><P>			for ( var i = 0; i &lt; 16; i ++ ) {
</P><P>				if ( te[ i ] !== me[ i ] ) return false;
</P><P>			}
</P><P>			return true;
</P><P>		},
</P><P>		fromArray: function ( array, offset ) {
</P><P>			if ( offset === undefined ) offset = 0;
</P><P>			for ( var i = 0; i &lt; 16; i ++ ) {
</P><P>				this.elements[ i ] = array[ i + offset ];
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		toArray: function ( array, offset ) {
</P><P>			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
</P><P>			var te = this.elements;
</P><P>			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];
</P><P>			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
</P><P>			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];
</P><P>			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];
</P><P>			return array;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 */
</P><P>	function Quaternion( x, y, z, w ) {
</P><P>		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;
</P><P>	}
</P><P>	Object.assign( Quaternion, {
</P><P>		slerp: function ( qa, qb, qm, t ) {
</P><P>			return qm.copy( qa ).slerp( qb, t );
</P><P>		},
</P><P>		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
</P><P>			// fuzz-free, array-based Quaternion SLERP operation
</P><P>			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],
</P><P>				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];
</P><P>			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
</P><P>				var s = 1 - t,
</P><P>					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
</P><P>					dir = ( cos &gt;= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;
</P><P>				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin &gt; Number.EPSILON ) {
</P><P>					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );
</P><P>					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;
</P><P>				}
</P><P>				var tDir = t * dir;
</P><P>				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;
</P><P>				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {
</P><P>					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
</P><P>					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
</P><P>				}
</P><P>			}
</P><P>			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
</P><P>		}
</P><P>	} );
</P><P>	Object.defineProperties( Quaternion.prototype, {
</P><P>		x: {
</P><P>			get: function () {
</P><P>				return this._x;
</P><P>			},
</P><P>			set: function ( value ) {
</P><P>				this._x = value;
				this.onChangeCallback();
</P><P>			}
</P><P>		},
</P><P>		y: {
</P><P>			get: function () {
</P><P>				return this._y;
</P><P>			},
</P><P>			set: function ( value ) {
</P><P>				this._y = value;
				this.onChangeCallback();
</P><P>			}
</P><P>		},
</P><P>		z: {
</P><P>			get: function () {
</P><P>				return this._z;
</P><P>			},
</P><P>		set: function ( value ) {
</P><P>				this._z = value;
				this.onChangeCallback();
</P><P>			}
</P><P>		},
</P><P>		w: {
</P><P>			get: function () {
</P><P>				return this._w;
</P><P>			},
</P><P>			set: function ( value ) {
</P><P>				this._w = value;
				this.onChangeCallback();
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Quaternion.prototype, {
</P><P>		isQuaternion: true,
</P><P>		set: function ( x, y, z, w ) {
</P><P>			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor( this._x, this._y, this._z, this._w );
</P><P>		},
</P><P>		copy: function ( quaternion ) {
</P><P>			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		setFromEuler: function ( euler, update ) {
</P><P>			if ( ! ( euler &amp;&amp; euler.isEuler ) ) {
</P><P>				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
</P><P>			}
</P><P>			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
</P><P>			// <A rel="nofollow" class="external free" href="http://www.mathworks.com/matlabcentral/fileexchange/">http://www.mathworks.com/matlabcentral/fileexchange/</A>
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
</P><P>			var cos = Math.cos;
			var sin = Math.sin;
</P><P>			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );
</P><P>			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );
</P><P>			if ( order === 'XYZ' ) {
</P><P>				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
</P><P>			} else if ( order === 'YXZ' ) {
</P><P>				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
</P><P>			} else if ( order === 'ZXY' ) {
</P><P>				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
</P><P>			} else if ( order === 'ZYX' ) {
</P><P>				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
</P><P>			} else if ( order === 'YZX' ) {
</P><P>				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
</P><P>			} else if ( order === 'XZY' ) {
</P><P>				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
</P><P>			}
</P><P>			if ( update !== false ) this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		setFromAxisAngle: function ( axis, angle ) {
</P><P>			// <A rel="nofollow" class="external free" href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm">http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm</A></P><P>			// assumes axis is normalized
</P><P>			var halfAngle = angle / 2, s = Math.sin( halfAngle );
</P><P>			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		setFromRotationMatrix: function ( m ) {
</P><P>			// <A rel="nofollow" class="external free" href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm">http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm</A></P><P>			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
</P><P>			var te = m.elements,
</P><P>				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
</P><P>				trace = m11 + m22 + m33,
				s;
</P><P>			if ( trace &gt; 0 ) {
</P><P>				s = 0.5 / Math.sqrt( trace + 1.0 );
</P><P>				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
</P><P>			} else if ( m11 &gt; m22 &amp;&amp; m11 &gt; m33 ) {
</P><P>				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
</P><P>				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;
</P><P>			} else if ( m22 &gt; m33 ) {
</P><P>				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
</P><P>				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;
</P><P>			} else {
</P><P>				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
</P><P>				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
</P><P>			}
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		setFromUnitVectors: function () {
</P><P>			// assumes direction vectors vFrom and vTo are normalized
</P><P>			var v1 = new Vector3();
			var r;
</P><P>			var EPS = 0.000001;
</P><P>			return function setFromUnitVectors( vFrom, vTo ) {
</P><P>				if ( v1 === undefined ) v1 = new Vector3();
</P><P>				r = vFrom.dot( vTo ) + 1;
</P><P>				if ( r &lt; EPS ) {
</P><P>					r = 0;
</P><P>					if ( Math.abs( vFrom.x ) &gt; Math.abs( vFrom.z ) ) {
</P><P>						v1.set( - vFrom.y, vFrom.x, 0 );
</P><P>					} else {
</P><P>						v1.set( 0, - vFrom.z, vFrom.y );
</P><P>					}
</P><P>				} else {
</P><P>					v1.crossVectors( vFrom, vTo );
</P><P>				}
</P><P>				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;
</P><P>				return this.normalize();
</P><P>			};
</P><P>		}(),
</P><P>		angleTo: function ( q ) {
</P><P>			return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );
</P><P>		},
</P><P>		rotateTowards: function ( q, step ) {
</P><P>			var angle = this.angleTo( q );
</P><P>			if ( angle === 0 ) return this;
</P><P>			var t = Math.min( 1, step / angle );
</P><P>			this.slerp( q, t );
</P><P>			return this;
</P><P>		},
</P><P>		inverse: function () {
</P><P>			// quaternion is assumed to have unit length
</P><P>			return this.conjugate();
</P><P>		},
</P><P>		conjugate: function () {
</P><P>			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		dot: function ( v ) {
</P><P>			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
</P><P>		},
</P><P>		lengthSq: function () {
</P><P>			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
</P><P>		},
</P><P>		length: function () {
</P><P>			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
</P><P>		},
</P><P>		normalize: function () {
</P><P>			var l = this.length();
</P><P>			if ( l === 0 ) {
</P><P>				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
</P><P>			} else {
</P><P>				l = 1 / l;
</P><P>				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
</P><P>			}
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		multiply: function ( q, p ) {
</P><P>			if ( p !== undefined ) {
</P><P>				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
</P><P>			}
</P><P>			return this.multiplyQuaternions( this, q );
</P><P>		},
</P><P>		premultiply: function ( q ) {
</P><P>			return this.multiplyQuaternions( q, this );
</P><P>		},
</P><P>		multiplyQuaternions: function ( a, b ) {
</P><P>			// from <A rel="nofollow" class="external free" href="http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm">http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm</A></P><P>			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
</P><P>			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		slerp: function ( qb, t ) {
</P><P>			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );
</P><P>			var x = this._x, y = this._y, z = this._z, w = this._w;
</P><P>			// <A rel="nofollow" class="external free" href="http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/">http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/</A></P><P>			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
</P><P>			if ( cosHalfTheta &lt; 0 ) {
</P><P>				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;
</P><P>				cosHalfTheta = - cosHalfTheta;
</P><P>			} else {
</P><P>				this.copy( qb );
</P><P>			}
</P><P>			if ( cosHalfTheta &gt;= 1.0 ) {
</P><P>				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
</P><P>				return this;
</P><P>			}
</P><P>			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
</P><P>			if ( sqrSinHalfTheta &lt;= Number.EPSILON ) {
</P><P>				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;
</P><P>				return this.normalize();
</P><P>			}
</P><P>			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
</P><P>			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		equals: function ( quaternion ) {
</P><P>			return ( quaternion._x === this._x ) &amp;&amp; ( quaternion._y === this._y ) &amp;&amp; ( quaternion._z === this._z ) &amp;&amp; ( quaternion._w === this._w );
</P><P>		},
</P><P>		fromArray: function ( array, offset ) {
</P><P>			if ( offset === undefined ) offset = 0;
</P><P>			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		toArray: function ( array, offset ) {
</P><P>			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
</P><P>			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;
</P><P>			return array;
</P><P>		},
</P><P>		onChange: function ( callback ) {
</P><P>			this.onChangeCallback = callback;
</P><P>			return this;
</P><P>		},
</P><P>		onChangeCallback: function () {}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author kile / <A rel="nofollow" class="external free" href="http://kile.stravaganza.org/">http://kile.stravaganza.org/</A>
	 * @author philogb / <A rel="nofollow" class="external free" href="http://blog.thejit.org/">http://blog.thejit.org/</A>
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author egraether / <A rel="nofollow" class="external free" href="http://egraether.com/">http://egraether.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function Vector3( x, y, z ) {
</P><P>		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
</P><P>	}
</P><P>	Object.assign( Vector3.prototype, {
</P><P>		isVector3: true,
</P><P>		set: function ( x, y, z ) {
</P><P>			this.x = x;
			this.y = y;
			this.z = z;
</P><P>			return this;
</P><P>		},
</P><P>		setScalar: function ( scalar ) {
</P><P>			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
</P><P>			return this;
</P><P>		},
</P><P>		setX: function ( x ) {
</P><P>			this.x = x;
</P><P>			return this;
</P><P>		},
</P><P>		setY: function ( y ) {
</P><P>			this.y = y;
</P><P>			return this;
</P><P>		},
</P><P>		setZ: function ( z ) {
</P><P>			this.z = z;
</P><P>			return this;
</P><P>		},
</P><P>		setComponent: function ( index, value ) {
</P><P>			switch ( index ) {
</P><P>				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		getComponent: function ( index ) {
</P><P>			switch ( index ) {
</P><P>				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );
</P><P>			}
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.x, this.y, this.z );
</P><P>		},
</P><P>		copy: function ( v ) {
</P><P>			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
</P><P>			return this;
</P><P>		},
</P><P>		add: function ( v, w ) {
</P><P>			if ( w !== undefined ) {
</P><P>				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
</P><P>			}
</P><P>			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
</P><P>			return this;
</P><P>		},
</P><P>		addScalar: function ( s ) {
</P><P>			this.x += s;
			this.y += s;
			this.z += s;
</P><P>			return this;
</P><P>		},
</P><P>		addVectors: function ( a, b ) {
</P><P>			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
</P><P>			return this;
</P><P>		},
</P><P>		addScaledVector: function ( v, s ) {
</P><P>			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
</P><P>			return this;
</P><P>		},
</P><P>		sub: function ( v, w ) {
</P><P>			if ( w !== undefined ) {
</P><P>				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
</P><P>			}
</P><P>			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
</P><P>			return this;
</P><P>		},
</P><P>		subScalar: function ( s ) {
</P><P>			this.x -= s;
			this.y -= s;
			this.z -= s;
</P><P>			return this;
</P><P>		},
</P><P>		subVectors: function ( a, b ) {
</P><P>			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
</P><P>			return this;
</P><P>		},
</P><P>		multiply: function ( v, w ) {
</P><P>			if ( w !== undefined ) {
</P><P>				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
</P><P>			}
</P><P>			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
</P><P>			return this;
</P><P>		},
</P><P>		multiplyScalar: function ( scalar ) {
</P><P>			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
</P><P>			return this;
</P><P>		},
</P><P>		multiplyVectors: function ( a, b ) {
</P><P>			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
</P><P>			return this;
</P><P>		},
</P><P>		applyEuler: function () {
</P><P>			var quaternion = new Quaternion();
</P><P>			return function applyEuler( euler ) {
</P><P>				if ( ! ( euler &amp;&amp; euler.isEuler ) ) {
</P><P>					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
</P><P>				}
</P><P>				return this.applyQuaternion( quaternion.setFromEuler( euler ) );
</P><P>			};
</P><P>		}(),
</P><P>		applyAxisAngle: function () {
</P><P>			var quaternion = new Quaternion();
</P><P>			return function applyAxisAngle( axis, angle ) {
</P><P>				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
</P><P>			};
</P><P>		}(),
</P><P>		applyMatrix3: function ( m ) {
</P><P>			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
</P><P>			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
</P><P>			return this;
</P><P>		},
</P><P>		applyMatrix4: function ( m ) {
</P><P>			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
</P><P>			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );
</P><P>			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;
</P><P>			return this;
</P><P>		},
</P><P>		applyQuaternion: function ( q ) {
</P><P>			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
</P><P>			// calculate quat * vector
</P><P>			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;
</P><P>			// calculate result * inverse quat
</P><P>			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
</P><P>			return this;
</P><P>		},
</P><P>		project: function ( camera ) {
</P><P>			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );
</P><P>		},
</P><P>		unproject: function () {
</P><P>			var matrix = new Matrix4();
</P><P>			return function unproject( camera ) {
</P><P>				return this.applyMatrix4( matrix.getInverse( camera.projectionMatrix ) ).applyMatrix4( camera.matrixWorld );
</P><P>			};
</P><P>		}(),
</P><P>		transformDirection: function ( m ) {
</P><P>			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
</P><P>			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
</P><P>			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
</P><P>			return this.normalize();
</P><P>		},
</P><P>		divide: function ( v ) {
</P><P>			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
</P><P>			return this;
</P><P>		},
</P><P>		divideScalar: function ( scalar ) {
</P><P>			return this.multiplyScalar( 1 / scalar );
</P><P>		},
</P><P>		min: function ( v ) {
</P><P>			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
</P><P>			return this;
</P><P>		},
</P><P>		max: function ( v ) {
</P><P>			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
</P><P>			return this;
</P><P>		},
</P><P>		clamp: function ( min, max ) {
</P><P>			// assumes min &lt; max, componentwise
</P><P>			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
</P><P>			return this;
</P><P>		},
</P><P>		clampScalar: function () {
</P><P>			var min = new Vector3();
			var max = new Vector3();
</P><P>			return function clampScalar( minVal, maxVal ) {
</P><P>				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );
</P><P>				return this.clamp( min, max );
</P><P>			};
</P><P>		}(),
</P><P>		clampLength: function ( min, max ) {
</P><P>			var length = this.length();
</P><P>			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
</P><P>		},
</P><P>		floor: function () {
</P><P>			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
</P><P>			return this;
</P><P>		},
</P><P>		ceil: function () {
</P><P>			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
</P><P>			return this;
</P><P>		},
</P><P>		round: function () {
</P><P>			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
</P><P>			return this;
</P><P>		},
</P><P>		roundToZero: function () {
</P><P>			this.x = ( this.x &lt; 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y &lt; 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z &lt; 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
</P><P>			return this;
</P><P>		},
</P><P>		negate: function () {
</P><P>			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
</P><P>			return this;
</P><P>		},
</P><P>		dot: function ( v ) {
</P><P>			return this.x * v.x + this.y * v.y + this.z * v.z;
</P><P>		},
</P><P>		// TODO lengthSquared?
</P><P>		lengthSq: function () {
</P><P>			return this.x * this.x + this.y * this.y + this.z * this.z;
</P><P>		},
</P><P>		length: function () {
</P><P>			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
</P><P>		},
</P><P>		manhattanLength: function () {
</P><P>			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
</P><P>		},
</P><P>		normalize: function () {
</P><P>			return this.divideScalar( this.length() || 1 );
</P><P>		},
</P><P>		setLength: function ( length ) {
</P><P>			return this.normalize().multiplyScalar( length );
</P><P>		},
</P><P>		lerp: function ( v, alpha ) {
</P><P>			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
</P><P>			return this;
</P><P>		},
</P><P>		lerpVectors: function ( v1, v2, alpha ) {
</P><P>			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
</P><P>		},
</P><P>		cross: function ( v, w ) {
</P><P>			if ( w !== undefined ) {
</P><P>				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
</P><P>			}
</P><P>			return this.crossVectors( this, v );
</P><P>		},
</P><P>		crossVectors: function ( a, b ) {
</P><P>			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;
</P><P>			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
</P><P>			return this;
</P><P>		},
</P><P>		projectOnVector: function ( vector ) {
</P><P>			var scalar = vector.dot( this ) / vector.lengthSq();
</P><P>			return this.copy( vector ).multiplyScalar( scalar );
</P><P>		},
</P><P>		projectOnPlane: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function projectOnPlane( planeNormal ) {
</P><P>				v1.copy( this ).projectOnVector( planeNormal );
</P><P>				return this.sub( v1 );
</P><P>			};
</P><P>		}(),
</P><P>		reflect: function () {
</P><P>			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
</P><P>			var v1 = new Vector3();
</P><P>			return function reflect( normal ) {
</P><P>				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
</P><P>			};
</P><P>		}(),
</P><P>		angleTo: function ( v ) {
</P><P>			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
</P><P>			// clamp, to handle numerical problems
</P><P>			return Math.acos( _Math.clamp( theta, - 1, 1 ) );
</P><P>		},
</P><P>		distanceTo: function ( v ) {
</P><P>			return Math.sqrt( this.distanceToSquared( v ) );
</P><P>		},
</P><P>		distanceToSquared: function ( v ) {
</P><P>			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
</P><P>			return dx * dx + dy * dy + dz * dz;
</P><P>		},
</P><P>		manhattanDistanceTo: function ( v ) {
</P><P>			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
</P><P>		},
</P><P>		setFromSpherical: function ( s ) {
</P><P>			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );
</P><P>		},
</P><P>		setFromSphericalCoords: function ( radius, phi, theta ) {
</P><P>			var sinPhiRadius = Math.sin( phi ) * radius;
</P><P>			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );
</P><P>			return this;
</P><P>		},
</P><P>		setFromCylindrical: function ( c ) {
</P><P>			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );
</P><P>		},
</P><P>		setFromCylindricalCoords: function ( radius, theta, y ) {
</P><P>			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );
</P><P>			return this;
</P><P>		},
</P><P>		setFromMatrixPosition: function ( m ) {
</P><P>			var e = m.elements;
</P><P>			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];
</P><P>			return this;
</P><P>		},
</P><P>		setFromMatrixScale: function ( m ) {
</P><P>			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();
</P><P>			this.x = sx;
			this.y = sy;
			this.z = sz;
</P><P>			return this;
</P><P>		},
</P><P>		setFromMatrixColumn: function ( m, index ) {
</P><P>			return this.fromArray( m.elements, index * 4 );
</P><P>		},
</P><P>		equals: function ( v ) {
</P><P>			return ( ( v.x === this.x ) &amp;&amp; ( v.y === this.y ) &amp;&amp; ( v.z === this.z ) );
</P><P>		},
</P><P>		fromArray: function ( array, offset ) {
</P><P>			if ( offset === undefined ) offset = 0;
</P><P>			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
</P><P>			return this;
</P><P>		},
</P><P>		toArray: function ( array, offset ) {
</P><P>			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
</P><P>			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
</P><P>			return array;
</P><P>		},
</P><P>		fromBufferAttribute: function ( attribute, index, offset ) {
</P><P>			if ( offset !== undefined ) {
</P><P>				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );
</P><P>			}
</P><P>			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 * @author tschw
	 */
</P><P>	function Matrix3() {
</P><P>		this.elements = [
</P><P>			1, 0, 0,
			0, 1, 0,
			0, 0, 1
</P><P>		];
</P><P>		if ( arguments.length &gt; 0 ) {
</P><P>			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
</P><P>		}
</P><P>	}
</P><P>	Object.assign( Matrix3.prototype, {
</P><P>		isMatrix3: true,
</P><P>		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
</P><P>			var te = this.elements;
</P><P>			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
</P><P>			return this;
</P><P>		},
</P><P>		identity: function () {
</P><P>			this.set(
</P><P>				1, 0, 0,
				0, 1, 0,
				0, 0, 1
</P><P>			);
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().fromArray( this.elements );
</P><P>		},
</P><P>		copy: function ( m ) {
</P><P>			var te = this.elements;
			var me = m.elements;
</P><P>			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];
</P><P>			return this;
</P><P>		},
</P><P>		setFromMatrix4: function ( m ) {
</P><P>			var me = m.elements;
</P><P>			this.set(
</P><P>				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]
</P><P>			);
</P><P>			return this;
</P><P>		},
</P><P>		applyToBufferAttribute: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function applyToBufferAttribute( attribute ) {
</P><P>				for ( var i = 0, l = attribute.count; i &lt; l; i ++ ) {
</P><P>					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );
</P><P>					v1.applyMatrix3( this );
</P><P>					attribute.setXYZ( i, v1.x, v1.y, v1.z );
</P><P>				}
</P><P>				return attribute;
</P><P>			};
</P><P>		}(),
</P><P>		multiply: function ( m ) {
</P><P>			return this.multiplyMatrices( this, m );
</P><P>		},
</P><P>		premultiply: function ( m ) {
</P><P>			return this.multiplyMatrices( m, this );
</P><P>		},
</P><P>		multiplyMatrices: function ( a, b ) {
</P><P>			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
</P><P>			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];
</P><P>			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];
</P><P>			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;
</P><P>			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;
</P><P>			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;
</P><P>			return this;
</P><P>		},
</P><P>		multiplyScalar: function ( s ) {
</P><P>			var te = this.elements;
</P><P>			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
</P><P>			return this;
</P><P>		},
</P><P>		determinant: function () {
</P><P>			var te = this.elements;
</P><P>			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
</P><P>			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
</P><P>		},
</P><P>		getInverse: function ( matrix, throwOnDegenerate ) {
</P><P>			if ( matrix &amp;&amp; matrix.isMatrix4 ) {
</P><P>				console.error( &quot;THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.&quot; );
</P><P>			}
</P><P>			var me = matrix.elements,
				te = this.elements,
</P><P>				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
</P><P>				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,
</P><P>				det = n11 * t11 + n21 * t12 + n31 * t13;
</P><P>			if ( det === 0 ) {
</P><P>				var msg = &quot;THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0&quot;;
</P><P>				if ( throwOnDegenerate === true ) {
</P><P>					throw new Error( msg );
</P><P>				} else {
</P><P>					console.warn( msg );
</P><P>				}
</P><P>				return this.identity();
</P><P>			}
</P><P>			var detInv = 1 / det;
</P><P>			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
</P><P>			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
</P><P>			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
</P><P>			return this;
</P><P>		},
</P><P>		transpose: function () {
</P><P>			var tmp, m = this.elements;
</P><P>			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
</P><P>			return this;
</P><P>		},
</P><P>		getNormalMatrix: function ( matrix4 ) {
</P><P>			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
</P><P>		},
</P><P>		transposeIntoArray: function ( r ) {
</P><P>			var m = this.elements;
</P><P>			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
</P><P>			return this;
</P><P>		},
</P><P>		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {
</P><P>			var c = Math.cos( rotation );
			var s = Math.sin( rotation );
</P><P>			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);
</P><P>		},
</P><P>		scale: function ( sx, sy ) {
</P><P>			var te = this.elements;
</P><P>			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;
</P><P>			return this;
</P><P>		},
</P><P>		rotate: function ( theta ) {
</P><P>			var c = Math.cos( theta );
			var s = Math.sin( theta );
</P><P>			var te = this.elements;
</P><P>			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];
</P><P>			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;
</P><P>			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;
</P><P>			return this;
</P><P>		},
</P><P>		translate: function ( tx, ty ) {
</P><P>			var te = this.elements;
</P><P>			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];
</P><P>			return this;
</P><P>		},
</P><P>		equals: function ( matrix ) {
</P><P>			var te = this.elements;
			var me = matrix.elements;
</P><P>			for ( var i = 0; i &lt; 9; i ++ ) {
</P><P>				if ( te[ i ] !== me[ i ] ) return false;
</P><P>			}
</P><P>			return true;
</P><P>		},
</P><P>		fromArray: function ( array, offset ) {
</P><P>			if ( offset === undefined ) offset = 0;
</P><P>			for ( var i = 0; i &lt; 9; i ++ ) {
</P><P>				this.elements[ i ] = array[ i + offset ];
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		toArray: function ( array, offset ) {
</P><P>			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
</P><P>			var te = this.elements;
</P><P>			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
</P><P>			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
</P><P>			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];
</P><P>			return array;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author szimek / <A rel="nofollow" class="external free" href="https://github.com/szimek/">https://github.com/szimek/</A>
	 */
</P><P>	var ImageUtils = {
</P><P>		getDataURL: function ( image ) {
</P><P>			var canvas;
</P><P>			if ( image instanceof HTMLCanvasElement ) {
</P><P>				canvas = image;
</P><P>			} else {
</P><P>				canvas = document.createElementNS( '<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml'">http://www.w3.org/1999/xhtml'</A>, 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;
</P><P>				var context = canvas.getContext( '2d' );
</P><P>				if ( image instanceof ImageData ) {
</P><P>					context.putImageData( image, 0, 0 );
</P><P>				} else {
</P><P>					context.drawImage( image, 0, 0, image.width, image.height );
</P><P>				}
</P><P>			}
</P><P>			if ( canvas.width &gt; 2048 || canvas.height &gt; 2048 ) {
</P><P>				return canvas.toDataURL( 'image/jpeg', 0.6 );
</P><P>			} else {
</P><P>				return canvas.toDataURL( 'image/png' );
</P><P>			}
</P><P>		}
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author szimek / <A rel="nofollow" class="external free" href="https://github.com/szimek/">https://github.com/szimek/</A>
	 */
</P><P>	var textureId = 0;
</P><P>	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
</P><P>		Object.defineProperty( this, 'id', { value: textureId ++ } );
</P><P>		this.uuid = _Math.generateUUID();
</P><P>		this.name = <I>;</I></P><P>		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];
</P><P>		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
</P><P>		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
</P><P>		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
</P><P>		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
</P><P>		this.format = format !== undefined ? format : RGBAFormat;
		this.type = type !== undefined ? type : UnsignedByteType;
</P><P>		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;
</P><P>		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();
</P><P>		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see <A rel="nofollow" class="external free" href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml">http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml</A>)
</P><P>		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;
</P><P>		this.version = 0;
		this.onUpdate = null;
</P><P>	}
</P><P>	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;
</P><P>	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
</P><P>		constructor: Texture,
</P><P>		isTexture: true,
</P><P>		updateMatrix: function () {
</P><P>			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			this.name = source.name;
</P><P>			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );
</P><P>			this.mapping = source.mapping;
</P><P>			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
</P><P>			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
</P><P>			this.anisotropy = source.anisotropy;
</P><P>			this.format = source.format;
			this.type = source.type;
</P><P>			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;
</P><P>			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );
</P><P>			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
</P><P>			return this;
</P><P>		},
</P><P>		toJSON: function ( meta ) {
</P><P>			var isRootObject = ( meta === undefined || typeof meta === 'string' );
</P><P>			if ( ! isRootObject &amp;&amp; meta.textures[ this.uuid ] !== undefined ) {
</P><P>				return meta.textures[ this.uuid ];
</P><P>			}
</P><P>			var output = {
</P><P>				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
</P><P>				uuid: this.uuid,
				name: this.name,
</P><P>				mapping: this.mapping,
</P><P>				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,
</P><P>				wrap: [ this.wrapS, this.wrapT ],
</P><P>				format: this.format,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
</P><P>				flipY: this.flipY
</P><P>			};
</P><P>			if ( this.image !== undefined ) {
</P><P>				// TODO: Move to THREE.Image
</P><P>				var image = this.image;
</P><P>				if ( image.uuid === undefined ) {
</P><P>					image.uuid = _Math.generateUUID(); // UGH
</P><P>				}
</P><P>				if ( ! isRootObject &amp;&amp; meta.images[ image.uuid ] === undefined ) {
</P><P>					var url;
</P><P>					if ( Array.isArray( image ) ) {
</P><P>						// process array of images e.g. CubeTexture
</P><P>						url = [];
</P><P>						for ( var i = 0, l = image.length; i &lt; l; i ++ ) {
</P><P>							url.push( ImageUtils.getDataURL( image[ i ] ) );
</P><P>						}
</P><P>					} else {
</P><P>						// process single image
</P><P>						url = ImageUtils.getDataURL( image );
</P><P>					}
</P><P>					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};
</P><P>				}
</P><P>				output.image = image.uuid;
</P><P>			}
</P><P>			if ( ! isRootObject ) {
</P><P>				meta.textures[ this.uuid ] = output;
</P><P>			}
</P><P>			return output;
</P><P>		},
</P><P>		dispose: function () {
</P><P>			this.dispatchEvent( { type: 'dispose' } );
</P><P>		},
</P><P>		transformUv: function ( uv ) {
</P><P>			if ( this.mapping !== UVMapping ) return uv;
</P><P>			uv.applyMatrix3( this.matrix );
</P><P>			if ( uv.x &lt; 0 || uv.x &gt; 1 ) {
</P><P>				switch ( this.wrapS ) {
</P><P>					case RepeatWrapping:
</P><P>						uv.x = uv.x - Math.floor( uv.x );
						break;
</P><P>					case ClampToEdgeWrapping:
</P><P>						uv.x = uv.x &lt; 0 ? 0 : 1;
						break;
</P><P>					case MirroredRepeatWrapping:
</P><P>						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
</P><P>							uv.x = Math.ceil( uv.x ) - uv.x;
</P><P>						} else {
</P><P>							uv.x = uv.x - Math.floor( uv.x );
</P><P>						}
						break;
</P><P>				}
</P><P>			}
</P><P>			if ( uv.y &lt; 0 || uv.y &gt; 1 ) {
</P><P>				switch ( this.wrapT ) {
</P><P>					case RepeatWrapping:
</P><P>						uv.y = uv.y - Math.floor( uv.y );
						break;
</P><P>					case ClampToEdgeWrapping:
</P><P>						uv.y = uv.y &lt; 0 ? 0 : 1;
						break;
</P><P>					case MirroredRepeatWrapping:
</P><P>						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
</P><P>							uv.y = Math.ceil( uv.y ) - uv.y;
</P><P>						} else {
</P><P>							uv.y = uv.y - Math.floor( uv.y );
</P><P>						}
						break;
</P><P>				}
</P><P>			}
</P><P>			if ( this.flipY ) {
</P><P>				uv.y = 1 - uv.y;
</P><P>			}
</P><P>			return uv;
</P><P>		}
</P><P>	} );
</P><P>	Object.defineProperty( Texture.prototype, &quot;needsUpdate&quot;, {
</P><P>		set: function ( value ) {
</P><P>			if ( value === true ) this.version ++;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author supereggbert / <A rel="nofollow" class="external free" href="http://www.paulbrunt.co.uk/">http://www.paulbrunt.co.uk/</A>
	 * @author philogb / <A rel="nofollow" class="external free" href="http://blog.thejit.org/">http://blog.thejit.org/</A>
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author egraether / <A rel="nofollow" class="external free" href="http://egraether.com/">http://egraether.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function Vector4( x, y, z, w ) {
</P><P>		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
</P><P>	}
</P><P>	Object.assign( Vector4.prototype, {
</P><P>		isVector4: true,
</P><P>		set: function ( x, y, z, w ) {
</P><P>			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
</P><P>			return this;
</P><P>		},
</P><P>		setScalar: function ( scalar ) {
</P><P>			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
</P><P>			return this;
</P><P>		},
</P><P>		setX: function ( x ) {
</P><P>			this.x = x;
</P><P>			return this;
</P><P>		},
</P><P>		setY: function ( y ) {
</P><P>			this.y = y;
</P><P>			return this;
</P><P>		},
</P><P>		setZ: function ( z ) {
</P><P>			this.z = z;
</P><P>			return this;
</P><P>		},
</P><P>		setW: function ( w ) {
</P><P>			this.w = w;
</P><P>			return this;
</P><P>		},
</P><P>		setComponent: function ( index, value ) {
</P><P>			switch ( index ) {
</P><P>				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		getComponent: function ( index ) {
</P><P>			switch ( index ) {
</P><P>				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );
</P><P>			}
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.x, this.y, this.z, this.w );
</P><P>		},
</P><P>		copy: function ( v ) {
</P><P>			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;
</P><P>			return this;
</P><P>		},
</P><P>		add: function ( v, w ) {
</P><P>			if ( w !== undefined ) {
</P><P>				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
</P><P>			}
</P><P>			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
</P><P>			return this;
</P><P>		},
</P><P>		addScalar: function ( s ) {
</P><P>			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
</P><P>			return this;
</P><P>		},
</P><P>		addVectors: function ( a, b ) {
</P><P>			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
</P><P>			return this;
</P><P>		},
</P><P>		addScaledVector: function ( v, s ) {
</P><P>			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
</P><P>			return this;
</P><P>		},
</P><P>		sub: function ( v, w ) {
</P><P>			if ( w !== undefined ) {
</P><P>				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
</P><P>			}
</P><P>			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
</P><P>			return this;
</P><P>		},
</P><P>		subScalar: function ( s ) {
</P><P>			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
</P><P>			return this;
</P><P>		},
</P><P>		subVectors: function ( a, b ) {
</P><P>			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
</P><P>			return this;
</P><P>		},
</P><P>		multiplyScalar: function ( scalar ) {
</P><P>			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
</P><P>			return this;
</P><P>		},
</P><P>		applyMatrix4: function ( m ) {
</P><P>			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;
</P><P>			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
</P><P>			return this;
</P><P>		},
</P><P>		divideScalar: function ( scalar ) {
</P><P>			return this.multiplyScalar( 1 / scalar );
</P><P>		},
</P><P>		setAxisAngleFromQuaternion: function ( q ) {
</P><P>			// <A rel="nofollow" class="external free" href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm">http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm</A></P><P>			// q is assumed to be normalized
</P><P>			this.w = 2 * Math.acos( q.w );
</P><P>			var s = Math.sqrt( 1 - q.w * q.w );
</P><P>			if ( s &lt; 0.0001 ) {
</P><P>				this.x = 1;
				this.y = 0;
				this.z = 0;
</P><P>			} else {
</P><P>				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		setAxisAngleFromRotationMatrix: function ( m ) {
</P><P>			// <A rel="nofollow" class="external free" href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm">http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm</A></P><P>			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
</P><P>			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
</P><P>				te = m.elements,
</P><P>				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
</P><P>			if ( ( Math.abs( m12 - m21 ) &lt; epsilon ) &amp;&amp;
			     ( Math.abs( m13 - m31 ) &lt; epsilon ) &amp;&amp;
			     ( Math.abs( m23 - m32 ) &lt; epsilon ) ) {
</P><P>				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
</P><P>				if ( ( Math.abs( m12 + m21 ) &lt; epsilon2 ) &amp;&amp;
				     ( Math.abs( m13 + m31 ) &lt; epsilon2 ) &amp;&amp;
				     ( Math.abs( m23 + m32 ) &lt; epsilon2 ) &amp;&amp;
				     ( Math.abs( m11 + m22 + m33 - 3 ) &lt; epsilon2 ) ) {
</P><P>					// this singularity is identity matrix so angle = 0
</P><P>					this.set( 1, 0, 0, 0 );
</P><P>					return this; // zero angle, arbitrary axis
</P><P>				}
</P><P>				// otherwise this singularity is angle = 180
</P><P>				angle = Math.PI;
</P><P>				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;
</P><P>				if ( ( xx &gt; yy ) &amp;&amp; ( xx &gt; zz ) ) {
</P><P>					// m11 is the largest diagonal term
</P><P>					if ( xx &lt; epsilon ) {
</P><P>						x = 0;
						y = 0.707106781;
						z = 0.707106781;
</P><P>					} else {
</P><P>						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;
</P><P>					}
</P><P>				} else if ( yy &gt; zz ) {
</P><P>					// m22 is the largest diagonal term
</P><P>					if ( yy &lt; epsilon ) {
</P><P>						x = 0.707106781;
						y = 0;
						z = 0.707106781;
</P><P>					} else {
</P><P>						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;
</P><P>					}
</P><P>				} else {
</P><P>					// m33 is the largest diagonal term so base result on this
</P><P>					if ( zz &lt; epsilon ) {
</P><P>						x = 0.707106781;
						y = 0.707106781;
						z = 0;
</P><P>					} else {
</P><P>						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;
</P><P>					}
</P><P>				}
</P><P>				this.set( x, y, z, angle );
</P><P>				return this; // return 180 deg rotation
</P><P>			}
</P><P>			// as we have reached here there are no singularities so we can handle normally
</P><P>			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
</P><P>			if ( Math.abs( s ) &lt; 0.001 ) s = 1;
</P><P>			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
</P><P>			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
</P><P>			return this;
</P><P>		},
</P><P>		min: function ( v ) {
</P><P>			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );
</P><P>			return this;
</P><P>		},
</P><P>		max: function ( v ) {
</P><P>			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );
</P><P>			return this;
</P><P>	},
</P><P>		clamp: function ( min, max ) {
</P><P>			// assumes min &lt; max, componentwise
</P><P>			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );
</P><P>			return this;
</P><P>		},
</P><P>		clampScalar: function () {
</P><P>			var min, max;
</P><P>			return function clampScalar( minVal, maxVal ) {
</P><P>				if ( min === undefined ) {
</P><P>					min = new Vector4();
					max = new Vector4();
</P><P>				}
</P><P>				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );
</P><P>				return this.clamp( min, max );
</P><P>			};
</P><P>		}(),
</P><P>		clampLength: function ( min, max ) {
</P><P>			var length = this.length();
</P><P>			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
</P><P>		},
</P><P>		floor: function () {
</P><P>			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );
</P><P>			return this;
</P><P>		},
</P><P>		ceil: function () {
</P><P>			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );
</P><P>			return this;
</P><P>		},
</P><P>		round: function () {
</P><P>			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );
</P><P>			return this;
</P><P>		},
</P><P>		roundToZero: function () {
</P><P>			this.x = ( this.x &lt; 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y &lt; 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z &lt; 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w &lt; 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
</P><P>			return this;
</P><P>		},
</P><P>		negate: function () {
</P><P>			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;
</P><P>			return this;
</P><P>		},
</P><P>		dot: function ( v ) {
</P><P>			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
</P><P>		},
</P><P>		lengthSq: function () {
</P><P>			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
</P><P>		},
</P><P>		length: function () {
</P><P>			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
</P><P>		},
</P><P>		manhattanLength: function () {
</P><P>			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
</P><P>		},
</P><P>		normalize: function () {
</P><P>			return this.divideScalar( this.length() || 1 );
</P><P>		},
</P><P>		setLength: function ( length ) {
</P><P>			return this.normalize().multiplyScalar( length );
</P><P>		},
</P><P>		lerp: function ( v, alpha ) {
</P><P>			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;
</P><P>			return this;
</P><P>		},
</P><P>		lerpVectors: function ( v1, v2, alpha ) {
</P><P>			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
</P><P>		},
</P><P>		equals: function ( v ) {
</P><P>			return ( ( v.x === this.x ) &amp;&amp; ( v.y === this.y ) &amp;&amp; ( v.z === this.z ) &amp;&amp; ( v.w === this.w ) );
</P><P>		},
</P><P>		fromArray: function ( array, offset ) {
</P><P>			if ( offset === undefined ) offset = 0;
</P><P>			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];
</P><P>			return this;
</P><P>		},
</P><P>		toArray: function ( array, offset ) {
</P><P>			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
</P><P>			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;
</P><P>			return array;
</P><P>		},
</P><P>		fromBufferAttribute: function ( attribute, index, offset ) {
</P><P>			if ( offset !== undefined ) {
</P><P>				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );
</P><P>			}
</P><P>			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author szimek / <A rel="nofollow" class="external free" href="https://github.com/szimek/">https://github.com/szimek/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author Marius Kintel / <A rel="nofollow" class="external free" href="https://github.com/kintel">https://github.com/kintel</A>
	 */
</P><P>	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {
</P><P>		this.width = width;
		this.height = height;
</P><P>		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;
</P><P>		this.viewport = new Vector4( 0, 0, width, height );
</P><P>		options = options || {};
</P><P>		if ( options.minFilter === undefined ) options.minFilter = LinearFilter;
</P><P>		this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
</P><P>		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : true;
</P><P>		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
</P><P>	}
</P><P>	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
</P><P>		constructor: WebGLRenderTarget,
</P><P>		isWebGLRenderTarget: true,
</P><P>		setSize: function ( width, height ) {
</P><P>			if ( this.width !== width || this.height !== height ) {
</P><P>				this.width = width;
				this.height = height;
</P><P>				this.dispose();
</P><P>			}
</P><P>			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			this.width = source.width;
			this.height = source.height;
</P><P>			this.viewport.copy( source.viewport );
</P><P>			this.texture = source.texture.clone();
</P><P>			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
</P><P>			return this;
</P><P>		},
</P><P>		dispose: function () {
</P><P>			this.dispatchEvent( { type: 'dispose' } );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com">http://alteredqualia.com</A>
	 */
</P><P>	function WebGLRenderTargetCube( width, height, options ) {
</P><P>		WebGLRenderTarget.call( this, width, height, options );
</P><P>		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
		this.activeMipMapLevel = 0;
</P><P>	}
</P><P>	WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
</P><P>	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
</P><P>		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
</P><P>		this.image = { data: data, width: width, height: height };
</P><P>		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
</P><P>		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
</P><P>	}
</P><P>	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;
</P><P>	DataTexture.prototype.isDataTexture = true;
</P><P>	/**
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function Box3( min, max ) {
</P><P>		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );
</P><P>	}
</P><P>	Object.assign( Box3.prototype, {
</P><P>		isBox3: true,
</P><P>		set: function ( min, max ) {
</P><P>			this.min.copy( min );
			this.max.copy( max );
</P><P>			return this;
</P><P>		},
</P><P>		setFromArray: function ( array ) {
</P><P>			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;
</P><P>			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;
</P><P>			for ( var i = 0, l = array.length; i &lt; l; i += 3 ) {
</P><P>				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];
</P><P>				if ( x &lt; minX ) minX = x;
				if ( y &lt; minY ) minY = y;
				if ( z &lt; minZ ) minZ = z;
</P><P>				if ( x &gt; maxX ) maxX = x;
				if ( y &gt; maxY ) maxY = y;
				if ( z &gt; maxZ ) maxZ = z;
</P><P>			}
</P><P>			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );
</P><P>			return this;
</P><P>		},
</P><P>		setFromBufferAttribute: function ( attribute ) {
</P><P>			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;
</P><P>			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;
</P><P>			for ( var i = 0, l = attribute.count; i &lt; l; i ++ ) {
</P><P>				var x = attribute.getX( i );
				var y = attribute.getY( i );
				var z = attribute.getZ( i );
</P><P>				if ( x &lt; minX ) minX = x;
				if ( y &lt; minY ) minY = y;
				if ( z &lt; minZ ) minZ = z;
</P><P>				if ( x &gt; maxX ) maxX = x;
				if ( y &gt; maxY ) maxY = y;
				if ( z &gt; maxZ ) maxZ = z;
</P><P>			}
</P><P>			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );
</P><P>			return this;
</P><P>		},
</P><P>		setFromPoints: function ( points ) {
</P><P>			this.makeEmpty();
</P><P>			for ( var i = 0, il = points.length; i &lt; il; i ++ ) {
</P><P>				this.expandByPoint( points[ i ] );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		setFromCenterAndSize: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function setFromCenterAndSize( center, size ) {
</P><P>				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
</P><P>				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		setFromObject: function ( object ) {
</P><P>			this.makeEmpty();
</P><P>			return this.expandByObject( object );
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( box ) {
</P><P>			this.min.copy( box.min );
			this.max.copy( box.max );
</P><P>			return this;
</P><P>		},
</P><P>		makeEmpty: function () {
</P><P>			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;
</P><P>			return this;
</P><P>		},
</P><P>		isEmpty: function () {
</P><P>			// this is a more robust check for empty than ( volume &lt;= 0 ) because volume can get positive with two negative axes
</P><P>			return ( this.max.x &lt; this.min.x ) || ( this.max.y &lt; this.min.y ) || ( this.max.z &lt; this.min.z );
</P><P>		},
</P><P>		getCenter: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Box3: .getCenter() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
</P><P>		},
</P><P>		getSize: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Box3: .getSize() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );
</P><P>		},
</P><P>		expandByPoint: function ( point ) {
</P><P>			this.min.min( point );
			this.max.max( point );
</P><P>			return this;
</P><P>		},
</P><P>		expandByVector: function ( vector ) {
</P><P>			this.min.sub( vector );
			this.max.add( vector );
</P><P>			return this;
</P><P>		},
</P><P>		expandByScalar: function ( scalar ) {
</P><P>			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
</P><P>			return this;
</P><P>		},
</P><P>		expandByObject: function () {
</P><P>			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
</P><P>			var scope, i, l;
</P><P>			var v1 = new Vector3();
</P><P>			function traverse( node ) {
</P><P>				var geometry = node.geometry;
</P><P>				if ( geometry !== undefined ) {
</P><P>					if ( geometry.isGeometry ) {
</P><P>						var vertices = geometry.vertices;
</P><P>						for ( i = 0, l = vertices.length; i &lt; l; i ++ ) {
</P><P>							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );
</P><P>							scope.expandByPoint( v1 );
</P><P>						}
</P><P>					} else if ( geometry.isBufferGeometry ) {
</P><P>						var attribute = geometry.attributes.position;
</P><P>						if ( attribute !== undefined ) {
</P><P>							for ( i = 0, l = attribute.count; i &lt; l; i ++ ) {
</P><P>								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );
</P><P>								scope.expandByPoint( v1 );
</P><P>							}
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			return function expandByObject( object ) {
</P><P>				scope = this;
</P><P>				object.updateMatrixWorld( true );
</P><P>				object.traverse( traverse );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		containsPoint: function ( point ) {
</P><P>			return point.x &lt; this.min.x || point.x &gt; this.max.x ||
				point.y &lt; this.min.y || point.y &gt; this.max.y ||
				point.z &lt; this.min.z || point.z &gt; this.max.z ? false : true;
</P><P>		},
</P><P>		containsBox: function ( box ) {
</P><P>			return this.min.x &lt;= box.min.x &amp;&amp; box.max.x &lt;= this.max.x &amp;&amp;
				this.min.y &lt;= box.min.y &amp;&amp; box.max.y &lt;= this.max.y &amp;&amp;
				this.min.z &lt;= box.min.z &amp;&amp; box.max.z &lt;= this.max.z;
</P><P>		},
</P><P>		getParameter: function ( point, target ) {
</P><P>			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Box3: .getParameter() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);
</P><P>		},
</P><P>		intersectsBox: function ( box ) {
</P><P>			// using 6 splitting planes to rule out intersections.
			return box.max.x &lt; this.min.x || box.min.x &gt; this.max.x ||
				box.max.y &lt; this.min.y || box.min.y &gt; this.max.y ||
				box.max.z &lt; this.min.z || box.min.z &gt; this.max.z ? false : true;
</P><P>		},
</P><P>		intersectsSphere: ( function () {
</P><P>			var closestPoint = new Vector3();
</P><P>			return function intersectsSphere( sphere ) {
</P><P>				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );
</P><P>				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) &lt;= ( sphere.radius * sphere.radius );
</P><P>			};
</P><P>		} )(),
</P><P>		intersectsPlane: function ( plane ) {
</P><P>			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
</P><P>			var min, max;
</P><P>			if ( plane.normal.x &gt; 0 ) {
</P><P>				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
</P><P>			} else {
</P><P>				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
</P><P>			}
</P><P>			if ( plane.normal.y &gt; 0 ) {
</P><P>				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
</P><P>			} else {
</P><P>				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
</P><P>			}
</P><P>			if ( plane.normal.z &gt; 0 ) {
</P><P>				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
</P><P>			} else {
</P><P>				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
</P><P>			}
</P><P>			return ( min &lt;= - plane.constant &amp;&amp; max &gt;= - plane.constant );
</P><P>		},
</P><P>		intersectsTriangle: ( function () {
</P><P>			// triangle centered vertices
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();
</P><P>			// triangle edge vectors
			var f0 = new Vector3();
			var f1 = new Vector3();
			var f2 = new Vector3();
</P><P>			var testAxis = new Vector3();
</P><P>			var center = new Vector3();
			var extents = new Vector3();
</P><P>			var triangleNormal = new Vector3();
</P><P>			function satForAxes( axes ) {
</P><P>				var i, j;
</P><P>				for ( i = 0, j = axes.length - 3; i &lt;= j; i += 3 ) {
</P><P>					testAxis.fromArray( axes, i );
					// project the aabb onto the seperating axis
					var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
					// project all 3 vertices of the triangle onto the seperating axis
					var p0 = v0.dot( testAxis );
					var p1 = v1.dot( testAxis );
					var p2 = v2.dot( testAxis );
					// actual test, basically see if either of the most extreme of the triangle points intersects r
					if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) &gt; r ) {
</P><P>						// points of the projected triangle are outside the projected half-length of the aabb
						// the axis is seperating and we can exit
						return false;
</P><P>					}
</P><P>				}
</P><P>				return true;
</P><P>			}
</P><P>			return function intersectsTriangle( triangle ) {
</P><P>				if ( this.isEmpty() ) {
</P><P>					return false;
</P><P>				}
</P><P>				// compute box center and extents
				this.getCenter( center );
				extents.subVectors( this.max, center );
</P><P>				// translate triangle to aabb origin
				v0.subVectors( triangle.a, center );
				v1.subVectors( triangle.b, center );
				v2.subVectors( triangle.c, center );
</P><P>				// compute edge vectors for triangle
				f0.subVectors( v1, v0 );
				f1.subVectors( v2, v1 );
				f2.subVectors( v0, v2 );
</P><P>				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
				var axes = [
					0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
					f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
					- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
				];
				if ( ! satForAxes( axes ) ) {
</P><P>					return false;
</P><P>				}
</P><P>				// test 3 face normals from the aabb
				axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
				if ( ! satForAxes( axes ) ) {
</P><P>					return false;
</P><P>				}
</P><P>				// finally testing the face normal of the triangle
				// use already existing triangle edge vectors here
				triangleNormal.crossVectors( f0, f1 );
				axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
				return satForAxes( axes );
</P><P>			};
</P><P>		} )(),
</P><P>		clampPoint: function ( point, target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return target.copy( point ).clamp( this.min, this.max );
</P><P>		},
</P><P>		distanceToPoint: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function distanceToPoint( point ) {
</P><P>				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
</P><P>			};
</P><P>		}(),
</P><P>		getBoundingSphere: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function getBoundingSphere( target ) {
</P><P>				if ( target === undefined ) {
</P><P>					console.warn( 'THREE.Box3: .getBoundingSphere() target is now required' );
					target = new Sphere();
</P><P>				}
</P><P>				this.getCenter( target.center );
</P><P>				target.radius = this.getSize( v1 ).length() * 0.5;
</P><P>				return target;
</P><P>			};
</P><P>		}(),
</P><P>		intersect: function ( box ) {
</P><P>			this.min.max( box.min );
			this.max.min( box.max );
</P><P>			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();
</P><P>			return this;
</P><P>		},
</P><P>		union: function ( box ) {
</P><P>			this.min.min( box.min );
			this.max.max( box.max );
</P><P>			return this;
</P><P>		},
</P><P>		applyMatrix4: function () {
</P><P>			var points = [
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3()
			];
</P><P>			return function applyMatrix4( matrix ) {
</P><P>				// transform of empty box is an empty box.
				if ( this.isEmpty() ) return this;
</P><P>				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111
</P><P>				this.setFromPoints( points );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		translate: function ( offset ) {
</P><P>			this.min.add( offset );
			this.max.add( offset );
</P><P>			return this;
</P><P>		},
</P><P>		equals: function ( box ) {
</P><P>			return box.min.equals( this.min ) &amp;&amp; box.max.equals( this.max );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function Sphere( center, radius ) {
</P><P>		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;
</P><P>	}
</P><P>	Object.assign( Sphere.prototype, {
</P><P>		set: function ( center, radius ) {
</P><P>			this.center.copy( center );
			this.radius = radius;
</P><P>			return this;
</P><P>		},
</P><P>		setFromPoints: function () {
</P><P>			var box = new Box3();
</P><P>			return function setFromPoints( points, optionalCenter ) {
</P><P>				var center = this.center;
</P><P>				if ( optionalCenter !== undefined ) {
</P><P>					center.copy( optionalCenter );
</P><P>				} else {
</P><P>					box.setFromPoints( points ).getCenter( center );
</P><P>				}
</P><P>				var maxRadiusSq = 0;
</P><P>				for ( var i = 0, il = points.length; i &lt; il; i ++ ) {
</P><P>					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
</P><P>				}
</P><P>				this.radius = Math.sqrt( maxRadiusSq );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( sphere ) {
</P><P>			this.center.copy( sphere.center );
			this.radius = sphere.radius;
</P><P>			return this;
</P><P>		},
</P><P>		empty: function () {
</P><P>			return ( this.radius &lt;= 0 );
</P><P>		},
</P><P>		containsPoint: function ( point ) {
</P><P>			return ( point.distanceToSquared( this.center ) &lt;= ( this.radius * this.radius ) );
</P><P>		},
</P><P>		distanceToPoint: function ( point ) {
</P><P>			return ( point.distanceTo( this.center ) - this.radius );
</P><P>		},
</P><P>		intersectsSphere: function ( sphere ) {
</P><P>			var radiusSum = this.radius + sphere.radius;
</P><P>			return sphere.center.distanceToSquared( this.center ) &lt;= ( radiusSum * radiusSum );
</P><P>		},
</P><P>		intersectsBox: function ( box ) {
</P><P>			return box.intersectsSphere( this );
</P><P>		},
</P><P>		intersectsPlane: function ( plane ) {
</P><P>			return Math.abs( plane.distanceToPoint( this.center ) ) &lt;= this.radius;
</P><P>		},
</P><P>		clampPoint: function ( point, target ) {
</P><P>			var deltaLengthSq = this.center.distanceToSquared( point );
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			target.copy( point );
</P><P>			if ( deltaLengthSq &gt; ( this.radius * this.radius ) ) {
</P><P>				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );
</P><P>			}
</P><P>			return target;
</P><P>		},
</P><P>		getBoundingBox: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
				target = new Box3();
</P><P>			}
</P><P>			target.set( this.center, this.center );
			target.expandByScalar( this.radius );
</P><P>			return target;
</P><P>		},
</P><P>		applyMatrix4: function ( matrix ) {
</P><P>			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
</P><P>			return this;
</P><P>		},
</P><P>		translate: function ( offset ) {
</P><P>			this.center.add( offset );
</P><P>			return this;
</P><P>		},
</P><P>		equals: function ( sphere ) {
</P><P>			return sphere.center.equals( this.center ) &amp;&amp; ( sphere.radius === this.radius );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 */
</P><P>	function Plane( normal, constant ) {
</P><P>		// normal is assumed to be normalized
</P><P>		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;
</P><P>	}
</P><P>	Object.assign( Plane.prototype, {
</P><P>		set: function ( normal, constant ) {
</P><P>			this.normal.copy( normal );
			this.constant = constant;
</P><P>			return this;
</P><P>		},
</P><P>		setComponents: function ( x, y, z, w ) {
</P><P>			this.normal.set( x, y, z );
			this.constant = w;
</P><P>			return this;
</P><P>		},
</P><P>		setFromNormalAndCoplanarPoint: function ( normal, point ) {
</P><P>			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );
</P><P>			return this;
</P><P>		},
</P><P>		setFromCoplanarPoints: function () {
</P><P>			var v1 = new Vector3();
			var v2 = new Vector3();
</P><P>			return function setFromCoplanarPoints( a, b, c ) {
</P><P>				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
</P><P>				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
</P><P>				this.setFromNormalAndCoplanarPoint( normal, a );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( plane ) {
</P><P>			this.normal.copy( plane.normal );
			this.constant = plane.constant;
</P><P>			return this;
</P><P>		},
</P><P>		normalize: function () {
</P><P>			// Note: will lead to a divide by zero if the plane is invalid.
</P><P>			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;
</P><P>			return this;
</P><P>		},
</P><P>		negate: function () {
</P><P>			this.constant *= - 1;
			this.normal.negate();
</P><P>			return this;
</P><P>		},
</P><P>		distanceToPoint: function ( point ) {
</P><P>			return this.normal.dot( point ) + this.constant;
</P><P>		},
</P><P>		distanceToSphere: function ( sphere ) {
</P><P>			return this.distanceToPoint( sphere.center ) - sphere.radius;
</P><P>		},
</P><P>		projectPoint: function ( point, target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );
</P><P>		},
</P><P>		intersectLine: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function intersectLine( line, target ) {
</P><P>				if ( target === undefined ) {
</P><P>					console.warn( 'THREE.Plane: .intersectLine() target is now required' );
					target = new Vector3();
</P><P>				}
</P><P>				var direction = line.delta( v1 );
</P><P>				var denominator = this.normal.dot( direction );
</P><P>				if ( denominator === 0 ) {
</P><P>					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {
</P><P>						return target.copy( line.start );
</P><P>					}
</P><P>					// Unsure if this is the correct method to handle this case.
					return undefined;
</P><P>				}
</P><P>				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
</P><P>				if ( t &lt; 0 || t &gt; 1 ) {
</P><P>					return undefined;
</P><P>				}
</P><P>				return target.copy( direction ).multiplyScalar( t ).add( line.start );
</P><P>			};
</P><P>		}(),
</P><P>		intersectsLine: function ( line ) {
</P><P>			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
</P><P>			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );
</P><P>			return ( startSign &lt; 0 &amp;&amp; endSign &gt; 0 ) || ( endSign &lt; 0 &amp;&amp; startSign &gt; 0 );
</P><P>		},
</P><P>		intersectsBox: function ( box ) {
</P><P>			return box.intersectsPlane( this );
</P><P>		},
</P><P>		intersectsSphere: function ( sphere ) {
</P><P>			return sphere.intersectsPlane( this );
</P><P>		},
</P><P>		coplanarPoint: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return target.copy( this.normal ).multiplyScalar( - this.constant );
</P><P>		},
</P><P>		applyMatrix4: function () {
</P><P>			var v1 = new Vector3();
			var m1 = new Matrix3();
</P><P>			return function applyMatrix4( matrix, optionalNormalMatrix ) {
</P><P>				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
</P><P>				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );
</P><P>				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
</P><P>				this.constant = - referencePoint.dot( normal );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		translate: function ( offset ) {
</P><P>			this.constant -= offset.dot( this.normal );
</P><P>			return this;
</P><P>		},
</P><P>		equals: function ( plane ) {
</P><P>			return plane.normal.equals( this.normal ) &amp;&amp; ( plane.constant === this.constant );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 */
</P><P>	function Frustum( p0, p1, p2, p3, p4, p5 ) {
</P><P>		this.planes = [
</P><P>			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()
</P><P>		];
</P><P>	}
</P><P>	Object.assign( Frustum.prototype, {
</P><P>		set: function ( p0, p1, p2, p3, p4, p5 ) {
</P><P>			var planes = this.planes;
</P><P>			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( frustum ) {
</P><P>			var planes = this.planes;
</P><P>			for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>				planes[ i ].copy( frustum.planes[ i ] );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		setFromMatrix: function ( m ) {
</P><P>			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
</P><P>			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
</P><P>			return this;
</P><P>		},
</P><P>		intersectsObject: function () {
</P><P>			var sphere = new Sphere();
</P><P>			return function intersectsObject( object ) {
</P><P>				var geometry = object.geometry;
</P><P>				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();
</P><P>				sphere.copy( geometry.boundingSphere )
					.applyMatrix4( object.matrixWorld );
</P><P>				return this.intersectsSphere( sphere );
</P><P>			};
</P><P>		}(),
</P><P>		intersectsSprite: function () {
</P><P>			var sphere = new Sphere();
</P><P>			return function intersectsSprite( sprite ) {
</P><P>				sphere.center.set( 0, 0, 0 );
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4( sprite.matrixWorld );
</P><P>				return this.intersectsSphere( sphere );
</P><P>			};
</P><P>		}(),
</P><P>		intersectsSphere: function ( sphere ) {
</P><P>			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;
</P><P>			for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>				var distance = planes[ i ].distanceToPoint( center );
</P><P>				if ( distance &lt; negRadius ) {
</P><P>					return false;
</P><P>				}
</P><P>			}
</P><P>			return true;
</P><P>		},
</P><P>		intersectsBox: function () {
</P><P>			var p = new Vector3();
</P><P>			return function intersectsBox( box ) {
</P><P>				var planes = this.planes;
</P><P>				for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>					var plane = planes[ i ];
</P><P>					// corner at max distance
</P><P>					p.x = plane.normal.x &gt; 0 ? box.max.x : box.min.x;
					p.y = plane.normal.y &gt; 0 ? box.max.y : box.min.y;
					p.z = plane.normal.z &gt; 0 ? box.max.z : box.min.z;
</P><P>					if ( plane.distanceToPoint( p ) &lt; 0 ) {
</P><P>						return false;
</P><P>					}
</P><P>				}
</P><P>				return true;
</P><P>			};
</P><P>		}(),
</P><P>		containsPoint: function ( point ) {
</P><P>			var planes = this.planes;
</P><P>			for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>				if ( planes[ i ].distanceToPoint( point ) &lt; 0 ) {
</P><P>					return false;
</P><P>				}
</P><P>			}
</P><P>			return true;
</P><P>		}
</P><P>	} );
</P><P>	var alphamap_fragment = &quot;#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n&quot;;
</P><P>	var alphamap_pars_fragment = &quot;#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n&quot;;
</P><P>	var alphatest_fragment = &quot;#ifdef ALPHATEST\n\tif ( diffuseColor.a &lt; ALPHATEST ) discard;\n#endif\n&quot;;
</P><P>	var aomap_fragment = &quot;#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) &amp;&amp; defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n&quot;;
</P><P>	var aomap_pars_fragment = &quot;#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif&quot;;
</P><P>	var begin_vertex = &quot;\nvec3 transformed = vec3( position );\n&quot;;
</P><P>	var beginnormal_vertex = &quot;\nvec3 objectNormal = vec3( normal );\n&quot;;
</P><P>	var bsdfs = &quot;float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance &gt; 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance &gt; 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x &gt; 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) &lt; 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n&quot;;
</P><P>	var bumpmap_pars_fragment = &quot;#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n&quot;;
</P><P>	var clipping_planes_fragment = &quot;#if NUM_CLIPPING_PLANES &gt; 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) &gt; plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES &lt; NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i &lt; NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) &gt; plane.w ) &amp;&amp; clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n&quot;;
</P><P>	var clipping_planes_pars_fragment = &quot;#if NUM_CLIPPING_PLANES &gt; 0\n\t#if ! defined( PHYSICAL ) &amp;&amp; ! defined( PHONG ) &amp;&amp; ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n&quot;;
</P><P>	var clipping_planes_pars_vertex = &quot;#if NUM_CLIPPING_PLANES &gt; 0 &amp;&amp; ! defined( PHYSICAL ) &amp;&amp; ! defined( PHONG ) &amp;&amp; ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n&quot;;
</P><P>	var clipping_planes_vertex = &quot;#if NUM_CLIPPING_PLANES &gt; 0 &amp;&amp; ! defined( PHYSICAL ) &amp;&amp; ! defined( PHONG ) &amp;&amp; ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n&quot;;
</P><P>	var color_fragment = &quot;#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif&quot;;
</P><P>	var color_pars_fragment = &quot;#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n&quot;;
</P><P>	var color_pars_vertex = &quot;#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif&quot;;
</P><P>	var color_vertex = &quot;#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif&quot;;
</P><P>	var common = &quot;#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n&quot;;
</P><P>	var cube_uv_reflection_fragment = &quot;#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x &gt; absDirection.z ) {\n\t\tif(absDirection.x &gt; absDirection.y )\n\t\t\tface = direction.x &gt; 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y &gt; 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z &gt; absDirection.y )\n\t\t\tface = direction.z &gt; 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y &gt; 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel &gt; cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes &amp;&amp; (scale &lt; a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes &amp;&amp; (offset.y &lt; 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes &amp;&amp; (offset.y &lt; 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes &amp;&amp; (offset.y &lt; 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes &amp;&amp; (offset.y &lt; 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes &amp;&amp; (offset.y &lt; 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes &amp;&amp; (offset.y &lt; 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 &gt; 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n&quot;;
</P><P>	var defaultnormal_vertex = &quot;vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n&quot;;
</P><P>	var displacementmap_pars_vertex = &quot;#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n&quot;;
</P><P>	var displacementmap_vertex = &quot;#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n&quot;;
</P><P>	var emissivemap_fragment = &quot;#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n&quot;;
</P><P>	var emissivemap_pars_fragment = &quot;#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n&quot;;
</P><P>	var encodings_fragment = &quot;  gl_FragColor = linearToOutputTexel( gl_FragColor );\n&quot;;
</P><P>	var encodings_pars_fragment = &quot;\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n&quot;;
</P><P>	var envmap_fragment = &quot;#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n&quot;;
</P><P>	var envmap_pars_fragment = &quot;#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) &amp;&amp; ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n&quot;;
</P><P>	var envmap_pars_vertex = &quot;#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n&quot;;
</P><P>	var envmap_vertex = &quot;#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n&quot;;
</P><P>	var fog_vertex = &quot;#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif\n&quot;;
</P><P>	var fog_pars_vertex = &quot;#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif\n&quot;;
</P><P>	var fog_fragment = &quot;#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n&quot;;
</P><P>	var fog_pars_fragment = &quot;#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n&quot;;
</P><P>	var gradientmap_pars_fragment = &quot;#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x &lt; 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n&quot;;
</P><P>	var lightmap_fragment = &quot;#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n&quot;;
</P><P>	var lightmap_pars_fragment = &quot;#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif&quot;;
</P><P>	var lights_lambert_vertex = &quot;vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS &gt; 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS &gt; 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS &gt; 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS &gt; 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n&quot;;
</P><P>	var lights_pars_begin = &quot;uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS &gt; 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS &gt; 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS &gt; 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos &gt; spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS &gt; 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS &gt; 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n&quot;;
</P><P>	var envmap_physical_pars_fragment = &quot;#if defined( USE_ENVMAP ) &amp;&amp; defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n&quot;;
</P><P>	var lights_phong_fragment = &quot;BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n&quot;;
</P><P>	var lights_phong_pars_fragment = &quot;varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n&quot;;
</P><P>	var lights_physical_fragment = &quot;PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n&quot;;
</P><P>	var lights_physical_pars_fragment = &quot;struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS &gt; 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n&quot;;
</P><P>	var lights_fragment_begin = &quot;\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS &gt; 0 ) &amp;&amp; defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS &gt; 0 ) &amp;&amp; defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS &gt; 0 ) &amp;&amp; defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS &gt; 0 ) &amp;&amp; defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS &gt; 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i &lt; NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n&quot;;
</P><P>	var lights_fragment_maps = &quot;#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) &amp;&amp; defined( PHYSICAL ) &amp;&amp; defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) &amp;&amp; defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n&quot;;
</P><P>	var lights_fragment_end = &quot;#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n&quot;;
</P><P>	var logdepthbuf_fragment = &quot;#if defined( USE_LOGDEPTHBUF ) &amp;&amp; defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif&quot;;
</P><P>	var logdepthbuf_pars_fragment = &quot;#if defined( USE_LOGDEPTHBUF ) &amp;&amp; defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n&quot;;
</P><P>	var logdepthbuf_pars_vertex = &quot;#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n&quot;;
</P><P>	var logdepthbuf_vertex = &quot;#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n&quot;;
</P><P>	var map_fragment = &quot;#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n&quot;;
</P><P>	var map_pars_fragment = &quot;#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n&quot;;
</P><P>	var map_particle_fragment = &quot;#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n&quot;;
</P><P>	var map_particle_pars_fragment = &quot;#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n&quot;;
</P><P>	var metalnessmap_fragment = &quot;float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n&quot;;
</P><P>	var metalnessmap_pars_fragment = &quot;#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif&quot;;
</P><P>	var morphnormal_vertex = &quot;#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n&quot;;
</P><P>	var morphtarget_pars_vertex = &quot;#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif&quot;;
</P><P>	var morphtarget_vertex = &quot;#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n&quot;;
</P><P>	var normal_fragment_begin = &quot;#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n&quot;;
</P><P>	var normal_fragment_maps = &quot;#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n&quot;;
</P><P>	var normalmap_pars_fragment = &quot;#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n&quot;;
</P><P>	var packing = &quot;vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n&quot;;
</P><P>	var premultiplied_alpha_fragment = &quot;#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n&quot;;
</P><P>	var project_vertex = &quot;vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n&quot;;
</P><P>	var dithering_fragment = &quot;#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n&quot;;
</P><P>	var dithering_pars_fragment = &quot;#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n&quot;;
</P><P>	var roughnessmap_fragment = &quot;float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n&quot;;
</P><P>	var roughnessmap_pars_fragment = &quot;#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif&quot;;
</P><P>	var shadowmap_pars_fragment = &quot;#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS &gt; 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS &gt; 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS &gt; 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x &gt;= 0.0, shadowCoord.x &lt;= 1.0, shadowCoord.y &gt;= 0.0, shadowCoord.y &lt;= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z &lt;= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z &gt;= almostOne ) {\n\t\t\tif ( v.z &gt; 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x &gt;= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y &gt;= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n&quot;;
</P><P>	var shadowmap_pars_vertex = &quot;#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS &gt; 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS &gt; 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS &gt; 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n&quot;;
</P><P>	var shadowmap_vertex = &quot;#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS &gt; 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS &gt; 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS &gt; 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n&quot;;
</P><P>	var shadowmask_pars_fragment = &quot;float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS &gt; 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS &gt; 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS &gt; 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i &lt; NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n&quot;;
</P><P>	var skinbase_vertex = &quot;#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif&quot;;
</P><P>	var skinning_pars_vertex = &quot;#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n&quot;;
</P><P>	var skinning_vertex = &quot;#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n&quot;;
</P><P>	var skinnormal_vertex = &quot;#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n&quot;;
</P><P>	var specularmap_fragment = &quot;float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif&quot;;
</P><P>	var specularmap_pars_fragment = &quot;#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif&quot;;
</P><P>	var tonemapping_fragment = &quot;#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n&quot;;
</P><P>	var tonemapping_pars_fragment = &quot;#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n&quot;;
</P><P>	var uv_pars_fragment = &quot;#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif&quot;;
</P><P>	var uv_pars_vertex = &quot;#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n&quot;;
</P><P>	var uv_vertex = &quot;#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif&quot;;
</P><P>	var uv2_pars_fragment = &quot;#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif&quot;;
</P><P>	var uv2_pars_vertex = &quot;#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif&quot;;
</P><P>	var uv2_vertex = &quot;#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif&quot;;
</P><P>	var worldpos_vertex = &quot;#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n&quot;;
</P><P>	var background_frag = &quot;uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n}\n&quot;;
</P><P>	var background_vert = &quot;varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4( position, 1.0 );\n\tgl_Position.z = 1.0;\n}\n&quot;;
</P><P>	var cube_frag = &quot;uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n&quot;;
</P><P>	var cube_vert = &quot;varying vec3 vWorldPosition;\n#include &lt;common&gt;\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\tgl_Position.z = gl_Position.w;\n}\n&quot;;
</P><P>	var depth_frag = &quot;#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() {\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include &lt;map_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n&quot;;
</P><P>	var depth_vert = &quot;#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include &lt;beginnormal_vertex&gt;\n\t\t#include &lt;morphnormal_vertex&gt;\n\t\t#include &lt;skinnormal_vertex&gt;\n\t#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n}\n&quot;;
</P><P>	var distanceRGBA_frag = &quot;#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main () {\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include &lt;map_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n&quot;;
</P><P>	var distanceRGBA_vert = &quot;#define DISTANCE\nvarying vec3 vWorldPosition;\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include &lt;beginnormal_vertex&gt;\n\t\t#include &lt;morphnormal_vertex&gt;\n\t\t#include &lt;skinnormal_vertex&gt;\n\t#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\tvWorldPosition = worldPosition.xyz;\n}\n&quot;;
</P><P>	var equirect_frag = &quot;uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include &lt;common&gt;\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n&quot;;
</P><P>	var equirect_vert = &quot;varying vec3 vWorldPosition;\n#include &lt;common&gt;\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;project_vertex&gt;\n}\n&quot;;
</P><P>	var linedashed_frag = &quot;uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include &lt;common&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() {\n\t#include &lt;clipping_planes_fragment&gt;\n\tif ( mod( vLineDistance, totalSize ) &gt; dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n}\n&quot;;
</P><P>	var linedashed_vert = &quot;uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include &lt;common&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;color_vertex&gt;\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n}\n&quot;;
</P><P>	var meshbasic_frag = &quot;uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include &lt;common&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;uv2_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;aomap_pars_fragment&gt;\n#include &lt;lightmap_pars_fragment&gt;\n#include &lt;envmap_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;specularmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() {\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;specularmap_fragment&gt;\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include &lt;aomap_fragment&gt;\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include &lt;envmap_fragment&gt;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n}\n&quot;;
</P><P>	var meshbasic_vert = &quot;#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;uv2_pars_vertex&gt;\n#include &lt;envmap_pars_vertex&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;uv2_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#ifdef USE_ENVMAP\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;envmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n}\n&quot;;
</P><P>	var meshlambert_frag = &quot;uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;dithering_pars_fragment&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;uv2_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;aomap_pars_fragment&gt;\n#include &lt;lightmap_pars_fragment&gt;\n#include &lt;emissivemap_pars_fragment&gt;\n#include &lt;envmap_pars_fragment&gt;\n#include &lt;bsdfs&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;shadowmap_pars_fragment&gt;\n#include &lt;shadowmask_pars_fragment&gt;\n#include &lt;specularmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() {\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;specularmap_fragment&gt;\n\t#include &lt;emissivemap_fragment&gt;\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include &lt;lightmap_fragment&gt;\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include &lt;aomap_fragment&gt;\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include &lt;envmap_fragment&gt;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;dithering_fragment&gt;\n}\n&quot;;
</P><P>	var meshlambert_vert = &quot;#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;uv2_pars_vertex&gt;\n#include &lt;envmap_pars_vertex&gt;\n#include &lt;bsdfs&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;shadowmap_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;uv2_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;envmap_vertex&gt;\n\t#include &lt;lights_lambert_vertex&gt;\n\t#include &lt;shadowmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n}\n&quot;;
</P><P>	var meshmatcap_frag = &quot;#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include &lt;common&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;bumpmap_pars_fragment&gt;\n#include &lt;normalmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() {\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;normal_fragment_begin&gt;\n\t#include &lt;normal_fragment_maps&gt;\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\tvec4 matcapColor = texture2D( matcap, uv );\n\tmatcapColor = matcapTexelToLinear( matcapColor );\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n}\n&quot;;
</P><P>	var meshmatcap_vert = &quot;#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n\tvViewPosition = - mvPosition.xyz;\n}\n&quot;;
</P><P>	var meshphong_frag = &quot;#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;dithering_pars_fragment&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;uv2_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;aomap_pars_fragment&gt;\n#include &lt;lightmap_pars_fragment&gt;\n#include &lt;emissivemap_pars_fragment&gt;\n#include &lt;envmap_pars_fragment&gt;\n#include &lt;gradientmap_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;bsdfs&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;lights_phong_pars_fragment&gt;\n#include &lt;shadowmap_pars_fragment&gt;\n#include &lt;bumpmap_pars_fragment&gt;\n#include &lt;normalmap_pars_fragment&gt;\n#include &lt;specularmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() {\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;specularmap_fragment&gt;\n\t#include &lt;normal_fragment_begin&gt;\n\t#include &lt;normal_fragment_maps&gt;\n\t#include &lt;emissivemap_fragment&gt;\n\t#include &lt;lights_phong_fragment&gt;\n\t#include &lt;lights_fragment_begin&gt;\n\t#include &lt;lights_fragment_maps&gt;\n\t#include &lt;lights_fragment_end&gt;\n\t#include &lt;aomap_fragment&gt;\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include &lt;envmap_fragment&gt;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;dithering_fragment&gt;\n}\n&quot;;
</P><P>	var meshphong_vert = &quot;#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;uv2_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;envmap_pars_vertex&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;shadowmap_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;uv2_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\tvViewPosition = - mvPosition.xyz;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;envmap_vertex&gt;\n\t#include &lt;shadowmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n}\n&quot;;
</P><P>	var meshphysical_frag = &quot;#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;dithering_pars_fragment&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;uv2_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;alphamap_pars_fragment&gt;\n#include &lt;aomap_pars_fragment&gt;\n#include &lt;lightmap_pars_fragment&gt;\n#include &lt;emissivemap_pars_fragment&gt;\n#include &lt;bsdfs&gt;\n#include &lt;cube_uv_reflection_fragment&gt;\n#include &lt;envmap_pars_fragment&gt;\n#include &lt;envmap_physical_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;lights_physical_pars_fragment&gt;\n#include &lt;shadowmap_pars_fragment&gt;\n#include &lt;bumpmap_pars_fragment&gt;\n#include &lt;normalmap_pars_fragment&gt;\n#include &lt;roughnessmap_pars_fragment&gt;\n#include &lt;metalnessmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() {\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphamap_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\t#include &lt;roughnessmap_fragment&gt;\n\t#include &lt;metalnessmap_fragment&gt;\n\t#include &lt;normal_fragment_begin&gt;\n\t#include &lt;normal_fragment_maps&gt;\n\t#include &lt;emissivemap_fragment&gt;\n\t#include &lt;lights_physical_fragment&gt;\n\t#include &lt;lights_fragment_begin&gt;\n\t#include &lt;lights_fragment_maps&gt;\n\t#include &lt;lights_fragment_end&gt;\n\t#include &lt;aomap_fragment&gt;\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;dithering_fragment&gt;\n}\n&quot;;
</P><P>	var meshphysical_vert = &quot;#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;uv2_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;shadowmap_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;uv2_vertex&gt;\n\t#include &lt;color_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\tvViewPosition = - mvPosition.xyz;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;shadowmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n}\n&quot;;
</P><P>	var normal_frag = &quot;#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) &amp;&amp; ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include &lt;packing&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;bumpmap_pars_fragment&gt;\n#include &lt;normalmap_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\nvoid main() {\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;normal_fragment_begin&gt;\n\t#include &lt;normal_fragment_maps&gt;\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n&quot;;
</P><P>	var normal_vert = &quot;#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) &amp;&amp; ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include &lt;uv_pars_vertex&gt;\n#include &lt;displacementmap_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;skinning_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\nvoid main() {\n\t#include &lt;uv_vertex&gt;\n\t#include &lt;beginnormal_vertex&gt;\n\t#include &lt;morphnormal_vertex&gt;\n\t#include &lt;skinbase_vertex&gt;\n\t#include &lt;skinnormal_vertex&gt;\n\t#include &lt;defaultnormal_vertex&gt;\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;skinning_vertex&gt;\n\t#include &lt;displacementmap_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;logdepthbuf_vertex&gt;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) &amp;&amp; ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n&quot;;
</P><P>	var points_frag = &quot;uniform vec3 diffuse;\nuniform float opacity;\n#include &lt;common&gt;\n#include &lt;color_pars_fragment&gt;\n#include &lt;map_particle_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() {\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_particle_fragment&gt;\n\t#include &lt;color_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include &lt;premultiplied_alpha_fragment&gt;\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n}\n&quot;;
</P><P>	var points_vert = &quot;uniform float size;\nuniform float scale;\n#include &lt;common&gt;\n#include &lt;color_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;morphtarget_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;color_vertex&gt;\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;morphtarget_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n}\n&quot;;
</P><P>	var shadow_frag = &quot;uniform vec3 color;\nuniform float opacity;\n#include &lt;common&gt;\n#include &lt;packing&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;bsdfs&gt;\n#include &lt;lights_pars_begin&gt;\n#include &lt;shadowmap_pars_fragment&gt;\n#include &lt;shadowmask_pars_fragment&gt;\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include &lt;fog_fragment&gt;\n}\n&quot;;
</P><P>	var shadow_vert = &quot;#include &lt;fog_pars_vertex&gt;\n#include &lt;shadowmap_pars_vertex&gt;\nvoid main() {\n\t#include &lt;begin_vertex&gt;\n\t#include &lt;project_vertex&gt;\n\t#include &lt;worldpos_vertex&gt;\n\t#include &lt;shadowmap_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n}\n&quot;;
</P><P>	var sprite_frag = &quot;uniform vec3 diffuse;\nuniform float opacity;\n#include &lt;common&gt;\n#include &lt;uv_pars_fragment&gt;\n#include &lt;map_pars_fragment&gt;\n#include &lt;fog_pars_fragment&gt;\n#include &lt;logdepthbuf_pars_fragment&gt;\n#include &lt;clipping_planes_pars_fragment&gt;\nvoid main() {\n\t#include &lt;clipping_planes_fragment&gt;\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include &lt;logdepthbuf_fragment&gt;\n\t#include &lt;map_fragment&gt;\n\t#include &lt;alphatest_fragment&gt;\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include &lt;tonemapping_fragment&gt;\n\t#include &lt;encodings_fragment&gt;\n\t#include &lt;fog_fragment&gt;\n}\n&quot;;
</P><P>	var sprite_vert = &quot;uniform float rotation;\nuniform vec2 center;\n#include &lt;common&gt;\n#include &lt;uv_pars_vertex&gt;\n#include &lt;fog_pars_vertex&gt;\n#include &lt;logdepthbuf_pars_vertex&gt;\n#include &lt;clipping_planes_pars_vertex&gt;\nvoid main() {\n\t#include &lt;uv_vertex&gt;\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include &lt;logdepthbuf_vertex&gt;\n\t#include &lt;clipping_planes_vertex&gt;\n\t#include &lt;fog_vertex&gt;\n}\n&quot;;
</P><P>	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,
</P><P>		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};
</P><P>	/**
	 * Uniform Utilities
	 */
</P><P>	var UniformsUtils = {
</P><P>		merge: function ( uniforms ) {
</P><P>			var merged = {};
</P><P>			for ( var u = 0; u &lt; uniforms.length; u ++ ) {
</P><P>				var tmp = this.clone( uniforms[ u ] );
</P><P>				for ( var p in tmp ) {
</P><P>					merged[ p ] = tmp[ p ];
</P><P>				}
</P><P>			}
</P><P>			return merged;
</P><P>		},
</P><P>		clone: function ( uniforms_src ) {
</P><P>			var uniforms_dst = {};
</P><P>			for ( var u in uniforms_src ) {
</P><P>				uniforms_dst[ u ] = {};
</P><P>				for ( var p in uniforms_src[ u ] ) {
</P><P>					var parameter_src = uniforms_src[ u ][ p ];
</P><P>					if ( parameter_src &amp;&amp; ( parameter_src.isColor ||
						parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
						parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
						parameter_src.isTexture ) ) {
</P><P>						uniforms_dst[ u ][ p ] = parameter_src.clone();
</P><P>					} else if ( Array.isArray( parameter_src ) ) {
</P><P>						uniforms_dst[ u ][ p ] = parameter_src.slice();
</P><P>					} else {
</P><P>						uniforms_dst[ u ][ p ] = parameter_src;
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			return uniforms_dst;
</P><P>		}
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
</P><P>	function Color( r, g, b ) {
</P><P>		if ( g === undefined &amp;&amp; b === undefined ) {
</P><P>			// r is THREE.Color, hex or string
			return this.set( r );
</P><P>		}
</P><P>		return this.setRGB( r, g, b );
</P><P>	}
</P><P>	Object.assign( Color.prototype, {
</P><P>		isColor: true,
</P><P>		r: 1, g: 1, b: 1,
</P><P>		set: function ( value ) {
</P><P>			if ( value &amp;&amp; value.isColor ) {
</P><P>				this.copy( value );
</P><P>			} else if ( typeof value === 'number' ) {
</P><P>				this.setHex( value );
</P><P>			} else if ( typeof value === 'string' ) {
</P><P>				this.setStyle( value );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		setScalar: function ( scalar ) {
</P><P>			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
</P><P>			return this;
</P><P>		},
</P><P>		setHex: function ( hex ) {
</P><P>			hex = Math.floor( hex );
</P><P>			this.r = ( hex &gt;&gt; 16 &amp; 255 ) / 255;
			this.g = ( hex &gt;&gt; 8 &amp; 255 ) / 255;
			this.b = ( hex &amp; 255 ) / 255;
</P><P>			return this;
</P><P>		},
</P><P>		setRGB: function ( r, g, b ) {
</P><P>			this.r = r;
			this.g = g;
			this.b = b;
</P><P>			return this;
</P><P>		},
</P><P>		setHSL: function () {
</P><P>			function hue2rgb( p, q, t ) {
</P><P>				if ( t &lt; 0 ) t += 1;
				if ( t &gt; 1 ) t -= 1;
				if ( t &lt; 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t &lt; 1 / 2 ) return q;
				if ( t &lt; 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;
</P><P>			}
</P><P>			return function setHSL( h, s, l ) {
</P><P>				// h,s,l ranges are in 0.0 - 1.0
				h = _Math.euclideanModulo( h, 1 );
				s = _Math.clamp( s, 0, 1 );
				l = _Math.clamp( l, 0, 1 );
</P><P>				if ( s === 0 ) {
</P><P>					this.r = this.g = this.b = l;
</P><P>				} else {
</P><P>					var p = l &lt;= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;
</P><P>					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );
</P><P>				}
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		setStyle: function ( style ) {
</P><P>			function handleAlpha( string ) {
</P><P>				if ( string === undefined ) return;
</P><P>				if ( parseFloat( string ) &lt; 1 ) {
</P><P>					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
</P><P>				}
</P><P>			}
</P><P>
			var m;
</P><P>			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
</P><P>				// rgb / hsl
</P><P>				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];
</P><P>				switch ( name ) {
</P><P>					case 'rgb':
					case 'rgba':
</P><P>						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
</P><P>							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
</P><P>							handleAlpha( color[ 5 ] );
</P><P>							return this;
</P><P>						}
</P><P>						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
</P><P>							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
</P><P>							handleAlpha( color[ 5 ] );
</P><P>							return this;
</P><P>						}
</P><P>						break;
</P><P>					case 'hsl':
					case 'hsla':
</P><P>						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
</P><P>							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;
</P><P>							handleAlpha( color[ 5 ] );
</P><P>							return this.setHSL( h, s, l );
</P><P>						}
</P><P>						break;
</P><P>				}
</P><P>			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
</P><P>				// hex color
</P><P>				var hex = m[ 1 ];
				var size = hex.length;
</P><P>				if ( size === 3 ) {
</P><P>					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
</P><P>					return this;
</P><P>				} else if ( size === 6 ) {
</P><P>					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
</P><P>					return this;
</P><P>				}
</P><P>			}
</P><P>			if ( style &amp;&amp; style.length &gt; 0 ) {
</P><P>				// color keywords
				var hex = ColorKeywords[ style ];
</P><P>				if ( hex !== undefined ) {
</P><P>					// red
					this.setHex( hex );
</P><P>				} else {
</P><P>					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );
</P><P>				}
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.r, this.g, this.b );
</P><P>		},
</P><P>		copy: function ( color ) {
</P><P>			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
</P><P>			return this;
</P><P>		},
</P><P>		copyGammaToLinear: function ( color, gammaFactor ) {
</P><P>			if ( gammaFactor === undefined ) gammaFactor = 2.0;
</P><P>			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );
</P><P>			return this;
</P><P>		},
</P><P>		copyLinearToGamma: function ( color, gammaFactor ) {
</P><P>			if ( gammaFactor === undefined ) gammaFactor = 2.0;
</P><P>			var safeInverse = ( gammaFactor &gt; 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
</P><P>			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );
</P><P>			return this;
</P><P>		},
</P><P>		convertGammaToLinear: function ( gammaFactor ) {
</P><P>			this.copyGammaToLinear( this, gammaFactor );
</P><P>			return this;
</P><P>		},
</P><P>		convertLinearToGamma: function ( gammaFactor ) {
</P><P>			this.copyLinearToGamma( this, gammaFactor );
</P><P>			return this;
</P><P>		},
</P><P>		copySRGBToLinear: function () {
</P><P>			function SRGBToLinear( c ) {
</P><P>				return ( c &lt; 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );
</P><P>			}
</P><P>			return function copySRGBToLinear( color ) {
</P><P>				this.r = SRGBToLinear( color.r );
				this.g = SRGBToLinear( color.g );
				this.b = SRGBToLinear( color.b );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		copyLinearToSRGB: function () {
</P><P>			function LinearToSRGB( c ) {
</P><P>				return ( c &lt; 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;
</P><P>			}
</P><P>			return function copyLinearToSRGB( color ) {
</P><P>				this.r = LinearToSRGB( color.r );
				this.g = LinearToSRGB( color.g );
				this.b = LinearToSRGB( color.b );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		convertSRGBToLinear: function () {
</P><P>			this.copySRGBToLinear( this );
</P><P>			return this;
</P><P>		},
</P><P>		convertLinearToSRGB: function () {
</P><P>			this.copyLinearToSRGB( this );
</P><P>			return this;
</P><P>		},
</P><P>		getHex: function () {
</P><P>			return ( this.r * 255 ) &lt;&lt; 16 ^ ( this.g * 255 ) &lt;&lt; 8 ^ ( this.b * 255 ) &lt;&lt; 0;
</P><P>		},
</P><P>		getHexString: function () {
</P><P>			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
</P><P>		},
</P><P>		getHSL: function ( target ) {
</P><P>			// h,s,l ranges are in 0.0 - 1.0
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Color: .getHSL() target is now required' );
				target = { h: 0, s: 0, l: 0 };
</P><P>			}
</P><P>			var r = this.r, g = this.g, b = this.b;
</P><P>			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );
</P><P>			var hue, saturation;
			var lightness = ( min + max ) / 2.0;
</P><P>			if ( min === max ) {
</P><P>				hue = 0;
				saturation = 0;
</P><P>			} else {
</P><P>				var delta = max - min;
</P><P>				saturation = lightness &lt;= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
</P><P>				switch ( max ) {
</P><P>					case r: hue = ( g - b ) / delta + ( g &lt; b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;
</P><P>				}
</P><P>				hue /= 6;
</P><P>			}
</P><P>target.h = hue;
			target.s = saturation;
			target.l = lightness;
</P><P>			return target;
</P><P>		},
</P><P>		getStyle: function () {
</P><P>			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
</P><P>		},
</P><P>		offsetHSL: function () {
</P><P>			var hsl = {};
</P><P>			return function ( h, s, l ) {
</P><P>				this.getHSL( hsl );
</P><P>				hsl.h += h; hsl.s += s; hsl.l += l;
</P><P>				this.setHSL( hsl.h, hsl.s, hsl.l );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		add: function ( color ) {
</P><P>			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
</P><P>			return this;
</P><P>		},
</P><P>		addColors: function ( color1, color2 ) {
</P><P>			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
</P><P>			return this;
</P><P>		},
</P><P>		addScalar: function ( s ) {
</P><P>			this.r += s;
			this.g += s;
			this.b += s;
</P><P>			return this;
</P><P>		},
</P><P>		sub: function ( color ) {
</P><P>			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );
</P><P>			return this;
</P><P>		},
</P><P>		multiply: function ( color ) {
</P><P>			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
</P><P>			return this;
</P><P>		},
</P><P>		multiplyScalar: function ( s ) {
</P><P>			this.r *= s;
			this.g *= s;
			this.b *= s;
</P><P>			return this;
</P><P>		},
</P><P>		lerp: function ( color, alpha ) {
</P><P>			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;
</P><P>			return this;
</P><P>		},
</P><P>		lerpHSL: function () {
</P><P>			var hslA = { h: 0, s: 0, l: 0 };
			var hslB = { h: 0, s: 0, l: 0 };
</P><P>			return function lerpHSL( color, alpha ) {
</P><P>				this.getHSL( hslA );
				color.getHSL( hslB );
</P><P>				var h = _Math.lerp( hslA.h, hslB.h, alpha );
				var s = _Math.lerp( hslA.s, hslB.s, alpha );
				var l = _Math.lerp( hslA.l, hslB.l, alpha );
</P><P>				this.setHSL( h, s, l );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		equals: function ( c ) {
</P><P>			return ( c.r === this.r ) &amp;&amp; ( c.g === this.g ) &amp;&amp; ( c.b === this.b );
</P><P>		},
</P><P>		fromArray: function ( array, offset ) {
</P><P>			if ( offset === undefined ) offset = 0;
</P><P>			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];
</P><P>			return this;
</P><P>		},
</P><P>		toArray: function ( array, offset ) {
</P><P>			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
</P><P>			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;
</P><P>			return array;
</P><P>		},
</P><P>		toJSON: function () {
</P><P>			return this.getHex();
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * Uniforms library for shared webgl shaders
	 */
</P><P>	var UniformsLib = {
</P><P>		common: {
</P><P>			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
</P><P>			map: { value: null },
			uvTransform: { value: new Matrix3() },
</P><P>			alphaMap: { value: null },
</P><P>		},
</P><P>		specularmap: {
</P><P>			specularMap: { value: null },
</P><P>		},
</P><P>		envmap: {
</P><P>			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }
</P><P>		},
</P><P>		aomap: {
</P><P>			aoMap: { value: null },
			aoMapIntensity: { value: 1 }
</P><P>		},
</P><P>		lightmap: {
</P><P>			lightMap: { value: null },
			lightMapIntensity: { value: 1 }
</P><P>		},
</P><P>		emissivemap: {
</P><P>			emissiveMap: { value: null }
</P><P>		},
</P><P>		bumpmap: {
</P><P>			bumpMap: { value: null },
			bumpScale: { value: 1 }
</P><P>		},
</P><P>		normalmap: {
</P><P>			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }
</P><P>		},
</P><P>		displacementmap: {
</P><P>			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }
</P><P>		},
</P><P>		roughnessmap: {
</P><P>			roughnessMap: { value: null }
</P><P>		},
</P><P>		metalnessmap: {
</P><P>			metalnessMap: { value: null }
</P><P>		},
</P><P>		gradientmap: {
</P><P>			gradientMap: { value: null }
</P><P>		},
</P><P>		fog: {
</P><P>			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }
</P><P>		},
</P><P>		lights: {
</P><P>			ambientLightColor: { value: [] },
</P><P>			directionalLights: { value: [], properties: {
				direction: {},
				color: {},
</P><P>				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },
</P><P>			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },
</P><P>			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {},
</P><P>				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },
</P><P>			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },
</P><P>			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {},
</P><P>				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },
</P><P>			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },
</P><P>			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },
</P><P>			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }
</P><P>		},
</P><P>		points: {
</P><P>			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }
</P><P>		},
</P><P>		sprite: {
</P><P>			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }
</P><P>		}
</P><P>	};
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 */
</P><P>	var ShaderLib = {
</P><P>		basic: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),
</P><P>			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
</P><P>		},
</P><P>		lambert: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),
</P><P>			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
</P><P>		},
</P><P>		phong: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),
</P><P>			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
</P><P>		},
</P><P>		standard: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),
</P><P>			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
</P><P>		},
</P><P>		matcap: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),
</P><P>			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
</P><P>		},
</P><P>		points: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.points,
				UniformsLib.fog
			] ),
</P><P>			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
</P><P>		},
</P><P>		dashed: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),
</P><P>			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
</P><P>		},
</P><P>		depth: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),
</P><P>			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
</P><P>		},
</P><P>		normal: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),
</P><P>			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag
</P><P>		},
</P><P>		sprite: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),
</P><P>			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
</P><P>		},
</P><P>		background: {
</P><P>			uniforms: {
				t2D: { value: null },
			},
</P><P>			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
</P><P>		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
</P><P>		cube: {
</P><P>			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},
</P><P>			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
</P><P>		},
</P><P>		equirect: {
</P><P>			uniforms: {
				tEquirect: { value: null },
			},
</P><P>			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
</P><P>		},
</P><P>		distanceRGBA: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),
</P><P>			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
</P><P>		},
</P><P>		shadow: {
</P><P>			uniforms: UniformsUtils.merge( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),
</P><P>			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
</P><P>		}
</P><P>	};
</P><P>	ShaderLib.physical = {
</P><P>		uniforms: UniformsUtils.merge( [
			ShaderLib.standard.uniforms,
			{
				clearCoat: { value: 0 },
				clearCoatRoughness: { value: 0 }
			}
		] ),
</P><P>		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLAnimation() {
</P><P>		var context = null;
		var isAnimating = false;
		var animationLoop = null;
</P><P>		function onAnimationFrame( time, frame ) {
</P><P>			if ( isAnimating === false ) return;
</P><P>			animationLoop( time, frame );
</P><P>			context.requestAnimationFrame( onAnimationFrame );
</P><P>		}
</P><P>		return {
</P><P>			start: function () {
</P><P>				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;
</P><P>				context.requestAnimationFrame( onAnimationFrame );
</P><P>				isAnimating = true;
</P><P>			},
</P><P>			stop: function () {
</P><P>				isAnimating = false;
</P><P>			},
</P><P>			setAnimationLoop: function ( callback ) {
</P><P>				animationLoop = callback;
</P><P>			},
</P><P>			setContext: function ( value ) {
</P><P>				context = value;
</P><P>			}
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLAttributes( gl ) {
</P><P>		var buffers = new WeakMap();
</P><P>		function createBuffer( attribute, bufferType ) {
</P><P>			var array = attribute.array;
			var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
</P><P>			var buffer = gl.createBuffer();
</P><P>			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );
</P><P>			attribute.onUploadCallback();
</P><P>			var type = gl.FLOAT;
</P><P>			if ( array instanceof Float32Array ) {
</P><P>				type = gl.FLOAT;
</P><P>			} else if ( array instanceof Float64Array ) {
</P><P>				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );
</P><P>			} else if ( array instanceof Uint16Array ) {
</P><P>				type = gl.UNSIGNED_SHORT;
</P><P>			} else if ( array instanceof Int16Array ) {
</P><P>				type = gl.SHORT;
</P><P>			} else if ( array instanceof Uint32Array ) {
</P><P>				type = gl.UNSIGNED_INT;
</P><P>			} else if ( array instanceof Int32Array ) {
</P><P>				type = gl.INT;
</P><P>			} else if ( array instanceof Int8Array ) {
</P><P>				type = gl.BYTE;
</P><P>			} else if ( array instanceof Uint8Array ) {
</P><P>				type = gl.UNSIGNED_BYTE;
</P><P>			}
</P><P>			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};
</P><P>		}
</P><P>		function updateBuffer( buffer, attribute, bufferType ) {
</P><P>			var array = attribute.array;
			var updateRange = attribute.updateRange;
</P><P>			gl.bindBuffer( bufferType, buffer );
</P><P>			if ( attribute.dynamic === false ) {
</P><P>				gl.bufferData( bufferType, array, gl.STATIC_DRAW );
</P><P>			} else if ( updateRange.count === - 1 ) {
</P><P>				// Not using update ranges
</P><P>				gl.bufferSubData( bufferType, 0, array );
</P><P>			} else if ( updateRange.count === 0 ) {
</P><P>				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
</P><P>			} else {
</P><P>				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );
</P><P>				updateRange.count = - 1; // reset range
</P><P>			}
</P><P>		}
</P><P>		//
</P><P>		function get( attribute ) {
</P><P>			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
</P><P>			return buffers.get( attribute );
</P><P>		}
</P><P>		function remove( attribute ) {
</P><P>			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
</P><P>			var data = buffers.get( attribute );
</P><P>			if ( data ) {
</P><P>				gl.deleteBuffer( data.buffer );
</P><P>				buffers.delete( attribute );
</P><P>			}
</P><P>		}
</P><P>		function update( attribute, bufferType ) {
</P><P>			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
</P><P>			var data = buffers.get( attribute );
</P><P>			if ( data === undefined ) {
</P><P>				buffers.set( attribute, createBuffer( attribute, bufferType ) );
</P><P>			} else if ( data.version &lt; attribute.version ) {
</P><P>				updateBuffer( data.buffer, attribute, bufferType );
</P><P>				data.version = attribute.version;
</P><P>			}
</P><P>		}
</P><P>		return {
</P><P>			get: get,
			remove: remove,
			update: update
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function Face3( a, b, c, normal, color, materialIndex ) {
</P><P>		this.a = a;
		this.b = b;
		this.c = c;
</P><P>		this.normal = ( normal &amp;&amp; normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];
</P><P>		this.color = ( color &amp;&amp; color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];
</P><P>		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
</P><P>	}
</P><P>	Object.assign( Face3.prototype, {
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			this.a = source.a;
			this.b = source.b;
			this.c = source.c;
</P><P>			this.normal.copy( source.normal );
			this.color.copy( source.color );
</P><P>			this.materialIndex = source.materialIndex;
</P><P>			for ( var i = 0, il = source.vertexNormals.length; i &lt; il; i ++ ) {
</P><P>				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
</P><P>			}
</P><P>			for ( var i = 0, il = source.vertexColors.length; i &lt; il; i ++ ) {
</P><P>				this.vertexColors[ i ] = source.vertexColors[ i ].clone();
</P><P>			}
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob /<A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 */
</P><P>	function Euler( x, y, z, order ) {
</P><P>		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;
</P><P>	}
</P><P>	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
</P><P>	Euler.DefaultOrder = 'XYZ';
</P><P>	Object.defineProperties( Euler.prototype, {
</P><P>		x: {
</P><P>			get: function () {
</P><P>				return this._x;
</P><P>			},
</P><P>			set: function ( value ) {
</P><P>				this._x = value;
				this.onChangeCallback();
</P><P>			}
</P><P>		},
</P><P>		y: {
</P><P>			get: function () {
</P><P>				return this._y;
</P><P>			},
</P><P>			set: function ( value ) {
</P><P>				this._y = value;
				this.onChangeCallback();
</P><P>			}
</P><P>		},
</P><P>		z: {
</P><P>			get: function () {
</P><P>				return this._z;
</P><P>			},
</P><P>			set: function ( value ) {
</P><P>				this._z = value;
				this.onChangeCallback();
</P><P>			}
</P><P>		},
</P><P>		order: {
</P><P>			get: function () {
</P><P>				return this._order;
</P><P>			},
</P><P>			set: function ( value ) {
</P><P>				this._order = value;
				this.onChangeCallback();
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Euler.prototype, {
</P><P>		isEuler: true,
</P><P>		set: function ( x, y, z, order ) {
</P><P>			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor( this._x, this._y, this._z, this._order );
</P><P>		},
</P><P>		copy: function ( euler ) {
</P><P>			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		setFromRotationMatrix: function ( m, order, update ) {
</P><P>			var clamp = _Math.clamp;
</P><P>			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
</P><P>			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
</P><P>			order = order || this._order;
</P><P>			if ( order === 'XYZ' ) {
</P><P>				this._y = Math.asin( clamp( m13, - 1, 1 ) );
</P><P>				if ( Math.abs( m13 ) &lt; 0.99999 ) {
</P><P>					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
</P><P>				} else {
</P><P>					this._x = Math.atan2( m32, m22 );
					this._z = 0;
</P><P>				}
</P><P>			} else if ( order === 'YXZ' ) {
</P><P>				this._x = Math.asin( - clamp( m23, - 1, 1 ) );
</P><P>				if ( Math.abs( m23 ) &lt; 0.99999 ) {
</P><P>					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
</P><P>				} else {
</P><P>					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
</P><P>				}
</P><P>			} else if ( order === 'ZXY' ) {
</P><P>				this._x = Math.asin( clamp( m32, - 1, 1 ) );
</P><P>				if ( Math.abs( m32 ) &lt; 0.99999 ) {
</P><P>					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
</P><P>				} else {
</P><P>					this._y = 0;
					this._z = Math.atan2( m21, m11 );
</P><P>				}
</P><P>			} else if ( order === 'ZYX' ) {
</P><P>				this._y = Math.asin( - clamp( m31, - 1, 1 ) );
</P><P>				if ( Math.abs( m31 ) &lt; 0.99999 ) {
</P><P>					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
</P><P>				} else {
</P><P>					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
</P><P>				}
</P><P>			} else if ( order === 'YZX' ) {
</P><P>				this._z = Math.asin( clamp( m21, - 1, 1 ) );
</P><P>				if ( Math.abs( m21 ) &lt; 0.99999 ) {
</P><P>					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
</P><P>				} else {
</P><P>					this._x = 0;
					this._y = Math.atan2( m13, m33 );
</P><P>				}
</P><P>			} else if ( order === 'XZY' ) {
</P><P>				this._z = Math.asin( - clamp( m12, - 1, 1 ) );
</P><P>				if ( Math.abs( m12 ) &lt; 0.99999 ) {
</P><P>					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
</P><P>				} else {
</P><P>					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
</P><P>				}
</P><P>			} else {
</P><P>				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
</P><P>			}
</P><P>			this._order = order;
</P><P>			if ( update !== false ) this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		setFromQuaternion: function () {
</P><P>			var matrix = new Matrix4();
</P><P>			return function setFromQuaternion( q, order, update ) {
</P><P>				matrix.makeRotationFromQuaternion( q );
</P><P>				return this.setFromRotationMatrix( matrix, order, update );
</P><P>			};
</P><P>		}(),
</P><P>		setFromVector3: function ( v, order ) {
</P><P>			return this.set( v.x, v.y, v.z, order || this._order );
</P><P>		},
</P><P>		reorder: function () {
</P><P>			// WARNING: this discards revolution information -bhouston
</P><P>			var q = new Quaternion();
</P><P>			return function reorder( newOrder ) {
</P><P>				q.setFromEuler( this );
</P><P>				return this.setFromQuaternion( q, newOrder );
</P><P>			};
</P><P>		}(),
</P><P>		equals: function ( euler ) {
</P><P>			return ( euler._x === this._x ) &amp;&amp; ( euler._y === this._y ) &amp;&amp; ( euler._z === this._z ) &amp;&amp; ( euler._order === this._order );
</P><P>		},
</P><P>		fromArray: function ( array ) {
</P><P>			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
</P><P>			this.onChangeCallback();
</P><P>			return this;
</P><P>		},
</P><P>		toArray: function ( array, offset ) {
</P><P>			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
</P><P>			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;
</P><P>			return array;
</P><P>		},
</P><P>		toVector3: function ( optionalResult ) {
</P><P>			if ( optionalResult ) {
</P><P>				return optionalResult.set( this._x, this._y, this._z );
</P><P>			} else {
</P><P>				return new Vector3( this._x, this._y, this._z );
</P><P>			}
</P><P>		},
</P><P>		onChange: function ( callback ) {
</P><P>			this.onChangeCallback = callback;
</P><P>			return this;
</P><P>		},
</P><P>		onChangeCallback: function () {}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function Layers() {
</P><P>		this.mask = 1 | 0;
</P><P>	}
</P><P>	Object.assign( Layers.prototype, {
</P><P>		set: function ( channel ) {
</P><P>			this.mask = 1 &lt;&lt; channel | 0;
</P><P>		},
</P><P>		enable: function ( channel ) {
</P><P>			this.mask |= 1 &lt;&lt; channel | 0;
</P><P>		},
</P><P>		toggle: function ( channel ) {
</P><P>			this.mask ^= 1 &lt;&lt; channel | 0;
</P><P>		},
</P><P>		disable: function ( channel ) {
</P><P>			this.mask &amp;= ~ ( 1 &lt;&lt; channel | 0 );
</P><P>		},
</P><P>		test: function ( layers ) {
</P><P>			return ( this.mask &amp; layers.mask ) !== 0;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 * @author elephantatwork / www.elephantatwork.ch
	 */
</P><P>	var object3DId = 0;
</P><P>	function Object3D() {
</P><P>		Object.defineProperty( this, 'id', { value: object3DId ++ } );
</P><P>		this.uuid = _Math.generateUUID();
</P><P>		this.name = <I>;</I>
		this.type = 'Object3D';
</P><P>		this.parent = null;
		this.children = [];
</P><P>		this.up = Object3D.DefaultUp.clone();
</P><P>		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );
</P><P>		function onRotationChange() {
</P><P>			quaternion.setFromEuler( rotation, false );
</P><P>		}
</P><P>		function onQuaternionChange() {
</P><P>			rotation.setFromQuaternion( quaternion, undefined, false );
</P><P>		}
</P><P>		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );
</P><P>		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );
</P><P>		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();
</P><P>		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;
</P><P>		this.layers = new Layers();
		this.visible = true;
</P><P>		this.castShadow = false;
		this.receiveShadow = false;
</P><P>		this.frustumCulled = true;
		this.renderOrder = 0;
</P><P>		this.userData = {};
</P><P>	}
</P><P>	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;
</P><P>	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
</P><P>		constructor: Object3D,
</P><P>		isObject3D: true,
</P><P>		onBeforeRender: function () {},
		onAfterRender: function () {},
</P><P>		applyMatrix: function ( matrix ) {
</P><P>			this.matrix.multiplyMatrices( matrix, this.matrix );
</P><P>			this.matrix.decompose( this.position, this.quaternion, this.scale );
</P><P>		},
</P><P>		applyQuaternion: function ( q ) {
</P><P>			this.quaternion.premultiply( q );
</P><P>			return this;
</P><P>		},
</P><P>		setRotationFromAxisAngle: function ( axis, angle ) {
</P><P>			// assumes axis is normalized
</P><P>			this.quaternion.setFromAxisAngle( axis, angle );
</P><P>		},
</P><P>		setRotationFromEuler: function ( euler ) {
</P><P>			this.quaternion.setFromEuler( euler, true );
</P><P>		},
</P><P>		setRotationFromMatrix: function ( m ) {
</P><P>			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
</P><P>			this.quaternion.setFromRotationMatrix( m );
</P><P>		},
</P><P>		setRotationFromQuaternion: function ( q ) {
</P><P>			// assumes q is normalized
</P><P>			this.quaternion.copy( q );
</P><P>		},
</P><P>		rotateOnAxis: function () {
</P><P>			// rotate object on axis in object space
			// axis is assumed to be normalized
</P><P>			var q1 = new Quaternion();
</P><P>			return function rotateOnAxis( axis, angle ) {
</P><P>				q1.setFromAxisAngle( axis, angle );
</P><P>				this.quaternion.multiply( q1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		rotateOnWorldAxis: function () {
</P><P>			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent
</P><P>			var q1 = new Quaternion();
</P><P>			return function rotateOnWorldAxis( axis, angle ) {
</P><P>				q1.setFromAxisAngle( axis, angle );
</P><P>				this.quaternion.premultiply( q1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		rotateX: function () {
</P><P>			var v1 = new Vector3( 1, 0, 0 );
</P><P>			return function rotateX( angle ) {
</P><P>				return this.rotateOnAxis( v1, angle );
</P><P>			};
</P><P>		}(),
</P><P>		rotateY: function () {
</P><P>			var v1 = new Vector3( 0, 1, 0 );
</P><P>			return function rotateY( angle ) {
</P><P>				return this.rotateOnAxis( v1, angle );
</P><P>			};
</P><P>		}(),
</P><P>		rotateZ: function () {
</P><P>			var v1 = new Vector3( 0, 0, 1 );
</P><P>			return function rotateZ( angle ) {
</P><P>				return this.rotateOnAxis( v1, angle );
</P><P>			};
</P><P>		}(),
</P><P>		translateOnAxis: function () {
</P><P>			// translate object by distance along axis in object space
			// axis is assumed to be normalized
</P><P>			var v1 = new Vector3();
</P><P>			return function translateOnAxis( axis, distance ) {
</P><P>				v1.copy( axis ).applyQuaternion( this.quaternion );
</P><P>				this.position.add( v1.multiplyScalar( distance ) );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		translateX: function () {
</P><P>			var v1 = new Vector3( 1, 0, 0 );
</P><P>			return function translateX( distance ) {
</P><P>				return this.translateOnAxis( v1, distance );
</P><P>			};
</P><P>		}(),
</P><P>		translateY: function () {
</P><P>			var v1 = new Vector3( 0, 1, 0 );
</P><P>			return function translateY( distance ) {
</P><P>				return this.translateOnAxis( v1, distance );
</P><P>			};
</P><P>		}(),
</P><P>		translateZ: function () {
</P><P>			var v1 = new Vector3( 0, 0, 1 );
</P><P>			return function translateZ( distance ) {
</P><P>				return this.translateOnAxis( v1, distance );
</P><P>			};
</P><P>		}(),
</P><P>		localToWorld: function ( vector ) {
</P><P>			return vector.applyMatrix4( this.matrixWorld );
</P><P>		},
</P><P>		worldToLocal: function () {
</P><P>			var m1 = new Matrix4();
</P><P>			return function worldToLocal( vector ) {
</P><P>				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
</P><P>			};
</P><P>		}(),
</P><P>		lookAt: function () {
</P><P>			// This method does not support objects having non-uniformly-scaled parent(s)
</P><P>			var q1 = new Quaternion();
			var m1 = new Matrix4();
			var target = new Vector3();
			var position = new Vector3();
</P><P>			return function lookAt( x, y, z ) {
</P><P>				if ( x.isVector3 ) {
</P><P>					target.copy( x );
</P><P>				} else {
</P><P>					target.set( x, y, z );
</P><P>				}
</P><P>				var parent = this.parent;
</P><P>				this.updateWorldMatrix( true, false );
</P><P>				position.setFromMatrixPosition( this.matrixWorld );
</P><P>				if ( this.isCamera ) {
</P><P>					m1.lookAt( position, target, this.up );
</P><P>				} else {
</P><P>					m1.lookAt( target, position, this.up );
</P><P>				}
</P><P>				this.quaternion.setFromRotationMatrix( m1 );
</P><P>				if ( parent ) {
</P><P>					m1.extractRotation( parent.matrixWorld );
					q1.setFromRotationMatrix( m1 );
					this.quaternion.premultiply( q1.inverse() );
</P><P>				}
</P><P>			};
</P><P>		}(),
</P><P>		add: function ( object ) {
</P><P>			if ( arguments.length &gt; 1 ) {
</P><P>				for ( var i = 0; i &lt; arguments.length; i ++ ) {
</P><P>					this.add( arguments[ i ] );
</P><P>				}
</P><P>				return this;
</P><P>			}
</P><P>			if ( object === this ) {
</P><P>				console.error( &quot;THREE.Object3D.add: object can't be added as a child of itself.&quot;, object );
				return this;
</P><P>			}
</P><P>			if ( ( object &amp;&amp; object.isObject3D ) ) {
</P><P>				if ( object.parent !== null ) {
</P><P>					object.parent.remove( object );
</P><P>				}
</P><P>				object.parent = this;
				object.dispatchEvent( { type: 'added' } );
</P><P>				this.children.push( object );
</P><P>			} else {
</P><P>				console.error( &quot;THREE.Object3D.add: object not an instance of THREE.Object3D.&quot;, object );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		remove: function ( object ) {
</P><P>			if ( arguments.length &gt; 1 ) {
</P><P>				for ( var i = 0; i &lt; arguments.length; i ++ ) {
</P><P>					this.remove( arguments[ i ] );
</P><P>				}
</P><P>				return this;
</P><P>			}
</P><P>			var index = this.children.indexOf( object );
</P><P>			if ( index !== - 1 ) {
</P><P>				object.parent = null;
</P><P>				object.dispatchEvent( { type: 'removed' } );
</P><P>				this.children.splice( index, 1 );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		getObjectById: function ( id ) {
</P><P>			return this.getObjectByProperty( 'id', id );
</P><P>		},
</P><P>		getObjectByName: function ( name ) {
</P><P>			return this.getObjectByProperty( 'name', name );
</P><P>		},
</P><P>		getObjectByProperty: function ( name, value ) {
</P><P>			if ( this[ name ] === value ) return this;
</P><P>			for ( var i = 0, l = this.children.length; i &lt; l; i ++ ) {
</P><P>				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );
</P><P>				if ( object !== undefined ) {
</P><P>					return object;
</P><P>				}
</P><P>			}
</P><P>			return undefined;
</P><P>		},
</P><P>		getWorldPosition: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			this.updateMatrixWorld( true );
</P><P>			return target.setFromMatrixPosition( this.matrixWorld );
</P><P>		},
</P><P>		getWorldQuaternion: function () {
</P><P>			var position = new Vector3();
			var scale = new Vector3();
</P><P>			return function getWorldQuaternion( target ) {
</P><P>				if ( target === undefined ) {
</P><P>					console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
					target = new Quaternion();
</P><P>				}
</P><P>				this.updateMatrixWorld( true );
</P><P>				this.matrixWorld.decompose( position, target, scale );
</P><P>				return target;
</P><P>			};
</P><P>		}(),
</P><P>		getWorldScale: function () {
</P><P>			var position = new Vector3();
			var quaternion = new Quaternion();
</P><P>			return function getWorldScale( target ) {
</P><P>				if ( target === undefined ) {
</P><P>					console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
					target = new Vector3();
</P><P>				}
</P><P>				this.updateMatrixWorld( true );
</P><P>				this.matrixWorld.decompose( position, quaternion, target );
</P><P>				return target;
</P><P>			};
</P><P>		}(),
</P><P>		getWorldDirection: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			this.updateMatrixWorld( true );
</P><P>			var e = this.matrixWorld.elements;
</P><P>			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();
</P><P>		},
</P><P>		raycast: function () {},
</P><P>		traverse: function ( callback ) {
</P><P>			callback( this );
</P><P>			var children = this.children;
</P><P>			for ( var i = 0, l = children.length; i &lt; l; i ++ ) {
</P><P>				children[ i ].traverse( callback );
</P><P>			}
</P><P>		},
</P><P>		traverseVisible: function ( callback ) {
</P><P>			if ( this.visible === false ) return;
</P><P>			callback( this );
</P><P>			var children = this.children;
</P><P>			for ( var i = 0, l = children.length; i &lt; l; i ++ ) {
</P><P>				children[ i ].traverseVisible( callback );
</P><P>			}
</P><P>		},
</P><P>		traverseAncestors: function ( callback ) {
</P><P>			var parent = this.parent;
</P><P>			if ( parent !== null ) {
</P><P>				callback( parent );
</P><P>				parent.traverseAncestors( callback );
</P><P>			}
</P><P>		},
</P><P>		updateMatrix: function () {
</P><P>			this.matrix.compose( this.position, this.quaternion, this.scale );
</P><P>			this.matrixWorldNeedsUpdate = true;
</P><P>		},
</P><P>		updateMatrixWorld: function ( force ) {
</P><P>			if ( this.matrixAutoUpdate ) this.updateMatrix();
</P><P>			if ( this.matrixWorldNeedsUpdate || force ) {
</P><P>				if ( this.parent === null ) {
</P><P>					this.matrixWorld.copy( this.matrix );
</P><P>				} else {
</P><P>					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
</P><P>				}
</P><P>				this.matrixWorldNeedsUpdate = false;
</P><P>				force = true;
</P><P>			}
</P><P>			// update children
</P><P>			var children = this.children;
</P><P>			for ( var i = 0, l = children.length; i &lt; l; i ++ ) {
</P><P>				children[ i ].updateMatrixWorld( force );
</P><P>			}
</P><P>		},
</P><P>		updateWorldMatrix: function ( updateParents, updateChildren ) {
</P><P>			var parent = this.parent;
</P><P>			if ( updateParents === true &amp;&amp; parent !== null ) {
</P><P>				parent.updateWorldMatrix( true, false );
</P><P>			}
</P><P>			if ( this.matrixAutoUpdate ) this.updateMatrix();
</P><P>			if ( this.parent === null ) {
</P><P>				this.matrixWorld.copy( this.matrix );
</P><P>			} else {
</P><P>				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
</P><P>			}
</P><P>			// update children
</P><P>			if ( updateChildren === true ) {
</P><P>				var children = this.children;
</P><P>				for ( var i = 0, l = children.length; i &lt; l; i ++ ) {
</P><P>					children[ i ].updateWorldMatrix( false, true );
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		toJSON: function ( meta ) {
</P><P>			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );
</P><P>			var output = {};
</P><P>			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {
</P><P>				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {}
				};
</P><P>				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
</P><P>			}
</P><P>			// standard Object3D serialization
</P><P>			var object = {};
</P><P>			object.uuid = this.uuid;
			object.type = this.type;
</P><P>			if ( this.name !== <I> ) object.name = this.name;</I>
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
</P><P>			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
</P><P>			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;
</P><P>			//
</P><P>			function serialize( library, element ) {
</P><P>				if ( library[ element.uuid ] === undefined ) {
</P><P>					library[ element.uuid ] = element.toJSON( meta );
</P><P>				}
</P><P>				return element.uuid;
</P><P>			}
</P><P>			if ( this.isMesh || this.isLine || this.isPoints ) {
</P><P>				object.geometry = serialize( meta.geometries, this.geometry );
</P><P>				var parameters = this.geometry.parameters;
</P><P>				if ( parameters !== undefined &amp;&amp; parameters.shapes !== undefined ) {
</P><P>					var shapes = parameters.shapes;
</P><P>					if ( Array.isArray( shapes ) ) {
</P><P>						for ( var i = 0, l = shapes.length; i &lt; l; i ++ ) {
</P><P>							var shape = shapes[ i ];
</P><P>							serialize( meta.shapes, shape );
</P><P>						}
</P><P>					} else {
</P><P>						serialize( meta.shapes, shapes );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			if ( this.material !== undefined ) {
</P><P>				if ( Array.isArray( this.material ) ) {
</P><P>					var uuids = [];
</P><P>					for ( var i = 0, l = this.material.length; i &lt; l; i ++ ) {
</P><P>						uuids.push( serialize( meta.materials, this.material[ i ] ) );
</P><P>					}
</P><P>					object.material = uuids;
</P><P>				} else {
</P><P>					object.material = serialize( meta.materials, this.material );
</P><P>				}
</P><P>			}
</P><P>			//
</P><P>			if ( this.children.length &gt; 0 ) {
</P><P>				object.children = [];
</P><P>				for ( var i = 0; i &lt; this.children.length; i ++ ) {
</P><P>					object.children.push( this.children[ i ].toJSON( meta ).object );
</P><P>				}
</P><P>			}
</P><P>			if ( isRootObject ) {
</P><P>				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes = extractFromCache( meta.shapes );
</P><P>				if ( geometries.length &gt; 0 ) output.geometries = geometries;
				if ( materials.length &gt; 0 ) output.materials = materials;
				if ( textures.length &gt; 0 ) output.textures = textures;
				if ( images.length &gt; 0 ) output.images = images;
				if ( shapes.length &gt; 0 ) output.shapes = shapes;
</P><P>			}
</P><P>			output.object = object;</P><P>			return output;
</P><P>			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {
</P><P>				var values = [];
				for ( var key in cache ) {
</P><P>					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
</P><P>				}
				return values;
</P><P>			}
</P><P>		},
</P><P>		clone: function ( recursive ) {
</P><P>			return new this.constructor().copy( this, recursive );
</P><P>		},
</P><P>		copy: function ( source, recursive ) {
</P><P>			if ( recursive === undefined ) recursive = true;
</P><P>			this.name = source.name;
</P><P>			this.up.copy( source.up );
</P><P>			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );
</P><P>			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );
</P><P>			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
</P><P>			this.layers.mask = source.layers.mask;
			this.visible = source.visible;
</P><P>			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
</P><P>			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
</P><P>			this.userData = JSON.parse( JSON.stringify( source.userData ) );
</P><P>			if ( recursive === true ) {
</P><P>				for ( var i = 0; i &lt; source.children.length; i ++ ) {
</P><P>					var child = source.children[ i ];
					this.add( child.clone() );
</P><P>				}
</P><P>			}
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author kile / <A rel="nofollow" class="external free" href="http://kile.stravaganza.org/">http://kile.stravaganza.org/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 */
</P><P>	var geometryId = 0; // Geometry uses even numbers as Id
</P><P>	function Geometry() {
</P><P>		Object.defineProperty( this, 'id', { value: geometryId += 2 } );
</P><P>		this.uuid = _Math.generateUUID();
</P><P>		this.name = <I>;</I>
		this.type = 'Geometry';
</P><P>		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
</P><P>		this.morphTargets = [];
		this.morphNormals = [];
</P><P>		this.skinWeights = [];
		this.skinIndices = [];
</P><P>		this.lineDistances = [];
</P><P>		this.boundingBox = null;
		this.boundingSphere = null;
</P><P>		// update flags
</P><P>		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;
</P><P>	}
</P><P>	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
</P><P>		constructor: Geometry,
</P><P>		isGeometry: true,
</P><P>		applyMatrix: function ( matrix ) {
</P><P>			var normalMatrix = new Matrix3().getNormalMatrix( matrix );
</P><P>			for ( var i = 0, il = this.vertices.length; i &lt; il; i ++ ) {
</P><P>				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );
</P><P>			}
</P><P>			for ( var i = 0, il = this.faces.length; i &lt; il; i ++ ) {
</P><P>				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();
</P><P>				for ( var j = 0, jl = face.vertexNormals.length; j &lt; jl; j ++ ) {
</P><P>					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
</P><P>				}
</P><P>			}
</P><P>			if ( this.boundingBox !== null ) {
</P><P>				this.computeBoundingBox();
</P><P>			}
</P><P>			if ( this.boundingSphere !== null ) {
</P><P>				this.computeBoundingSphere();
</P><P>			}
</P><P>			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;
</P><P>			return this;
</P><P>		},
</P><P>		rotateX: function () {
</P><P>			// rotate geometry around world x-axis
</P><P>			var m1 = new Matrix4();
</P><P>			return function rotateX( angle ) {
</P><P>				m1.makeRotationX( angle );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		rotateY: function () {
</P><P>			// rotate geometry around world y-axis
</P><P>			var m1 = new Matrix4();
</P><P>			return function rotateY( angle ) {
</P><P>				m1.makeRotationY( angle );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		rotateZ: function () {
</P><P>			// rotate geometry around world z-axis
</P><P>			var m1 = new Matrix4();
</P><P>			return function rotateZ( angle ) {
</P><P>				m1.makeRotationZ( angle );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		translate: function () {
</P><P>			// translate geometry
</P><P>			var m1 = new Matrix4();
</P><P>			return function translate( x, y, z ) {
</P><P>				m1.makeTranslation( x, y, z );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		scale: function () {
</P><P>			// scale geometry
</P><P>			var m1 = new Matrix4();
</P><P>			return function scale( x, y, z ) {
</P><P>				m1.makeScale( x, y, z );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		lookAt: function () {
</P><P>			var obj = new Object3D();
</P><P>			return function lookAt( vector ) {
</P><P>				obj.lookAt( vector );
</P><P>				obj.updateMatrix();
</P><P>				this.applyMatrix( obj.matrix );
</P><P>			};
</P><P>		}(),
</P><P>		fromBufferGeometry: function ( geometry ) {
</P><P>			var scope = this;
</P><P>			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;
</P><P>			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
</P><P>			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
</P><P>			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];
</P><P>			for ( var i = 0, j = 0; i &lt; positions.length; i += 3, j += 2 ) {
</P><P>				scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );
</P><P>				if ( normals !== undefined ) {
</P><P>					tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
</P><P>				}
</P><P>				if ( colors !== undefined ) {
</P><P>					scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
</P><P>				}
</P><P>				if ( uvs !== undefined ) {
</P><P>					tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );
</P><P>				}
</P><P>				if ( uvs2 !== undefined ) {
</P><P>					tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
</P><P>				}
</P><P>			}
</P><P>			function addFace( a, b, c, materialIndex ) {
</P><P>				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
</P><P>				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );
</P><P>				scope.faces.push( face );
</P><P>				if ( uvs !== undefined ) {
</P><P>					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
</P><P>				}
</P><P>				if ( uvs2 !== undefined ) {
</P><P>					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
</P><P>				}
</P><P>			}
</P><P>			var groups = geometry.groups;
</P><P>			if ( groups.length &gt; 0 ) {
</P><P>				for ( var i = 0; i &lt; groups.length; i ++ ) {
</P><P>					var group = groups[ i ];
</P><P>					var start = group.start;
					var count = group.count;
</P><P>					for ( var j = start, jl = start + count; j &lt; jl; j += 3 ) {
</P><P>						if ( indices !== undefined ) {
</P><P>							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );
</P><P>						} else {
</P><P>							addFace( j, j + 1, j + 2, group.materialIndex );
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			} else {
</P><P>				if ( indices !== undefined ) {
</P><P>					for ( var i = 0; i &lt; indices.length; i += 3 ) {
</P><P>						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
</P><P>					}
</P><P>				} else {
</P><P>					for ( var i = 0; i &lt; positions.length / 3; i += 3 ) {
</P><P>						addFace( i, i + 1, i + 2 );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			this.computeFaceNormals();
</P><P>			if ( geometry.boundingBox !== null ) {
</P><P>				this.boundingBox = geometry.boundingBox.clone();
</P><P>			}
</P><P>			if ( geometry.boundingSphere !== null ) {
</P><P>				this.boundingSphere = geometry.boundingSphere.clone();
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		center: function () {
</P><P>			var offset = new Vector3();
</P><P>			return function center() {
</P><P>				this.computeBoundingBox();
</P><P>				this.boundingBox.getCenter( offset ).negate();
</P><P>				this.translate( offset.x, offset.y, offset.z );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		normalize: function () {
</P><P>			this.computeBoundingSphere();
</P><P>			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;
</P><P>			var s = radius === 0 ? 1 : 1.0 / radius;
</P><P>			var matrix = new Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);
</P><P>			this.applyMatrix( matrix );
</P><P>			return this;
</P><P>		},
</P><P>		computeFaceNormals: function () {
</P><P>			var cb = new Vector3(), ab = new Vector3();
</P><P>			for ( var f = 0, fl = this.faces.length; f &lt; fl; f ++ ) {
</P><P>				var face = this.faces[ f ];
</P><P>				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];
</P><P>				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
</P><P>				cb.normalize();
</P><P>				face.normal.copy( cb );
</P><P>			}
</P><P>		},
</P><P>		computeVertexNormals: function ( areaWeighted ) {
</P><P>			if ( areaWeighted === undefined ) areaWeighted = true;
</P><P>			var v, vl, f, fl, face, vertices;
</P><P>			vertices = new Array( this.vertices.length );
</P><P>			for ( v = 0, vl = this.vertices.length; v &lt; vl; v ++ ) {
</P><P>				vertices[ v ] = new Vector3();
</P><P>			}
</P><P>			if ( areaWeighted ) {
</P><P>				// vertex normals weighted by triangle areas
				// <A rel="nofollow" class="external free" href="http://www.iquilezles.org/www/articles/normals/normals.htm">http://www.iquilezles.org/www/articles/normals/normals.htm</A></P><P>				var vA, vB, vC;
				var cb = new Vector3(), ab = new Vector3();
</P><P>				for ( f = 0, fl = this.faces.length; f &lt; fl; f ++ ) {
</P><P>					face = this.faces[ f ];
</P><P>					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];
</P><P>					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
</P><P>					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );
</P><P>				}
</P><P>			} else {
</P><P>				this.computeFaceNormals();
</P><P>				for ( f = 0, fl = this.faces.length; f &lt; fl; f ++ ) {
</P><P>					face = this.faces[ f ];
</P><P>					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );
</P><P>				}
</P><P>			}
</P><P>			for ( v = 0, vl = this.vertices.length; v &lt; vl; v ++ ) {
</P><P>				vertices[ v ].normalize();
</P><P>			}
</P><P>			for ( f = 0, fl = this.faces.length; f &lt; fl; f ++ ) {
</P><P>				face = this.faces[ f ];
</P><P>				var vertexNormals = face.vertexNormals;
</P><P>				if ( vertexNormals.length === 3 ) {
</P><P>					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );
</P><P>				} else {
</P><P>					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();
</P><P>				}
</P><P>			}
</P><P>			if ( this.faces.length &gt; 0 ) {
</P><P>				this.normalsNeedUpdate = true;
</P><P>			}
</P><P>		},
</P><P>		computeFlatVertexNormals: function () {
</P><P>			var f, fl, face;
</P><P>			this.computeFaceNormals();
</P><P>			for ( f = 0, fl = this.faces.length; f &lt; fl; f ++ ) {
</P><P>				face = this.faces[ f ];
</P><P>				var vertexNormals = face.vertexNormals;
</P><P>				if ( vertexNormals.length === 3 ) {
</P><P>					vertexNormals[ 0 ].copy( face.normal );
					vertexNormals[ 1 ].copy( face.normal );
					vertexNormals[ 2 ].copy( face.normal );
</P><P>				} else {
</P><P>					vertexNormals[ 0 ] = face.normal.clone();
					vertexNormals[ 1 ] = face.normal.clone();
					vertexNormals[ 2 ] = face.normal.clone();
</P><P>				}
</P><P>			}
</P><P>			if ( this.faces.length &gt; 0 ) {
</P><P>				this.normalsNeedUpdate = true;
</P><P>			}
</P><P>		},
</P><P>		computeMorphNormals: function () {
</P><P>			var i, il, f, fl, face;
</P><P>			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)
</P><P>			for ( f = 0, fl = this.faces.length; f &lt; fl; f ++ ) {
</P><P>				face = this.faces[ f ];
</P><P>				if ( ! face.__originalFaceNormal ) {
</P><P>					face.__originalFaceNormal = face.normal.clone();
</P><P>				} else {
</P><P>					face.__originalFaceNormal.copy( face.normal );
</P><P>				}
</P><P>				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
</P><P>				for ( i = 0, il = face.vertexNormals.length; i &lt; il; i ++ ) {
</P><P>					if ( ! face.__originalVertexNormals[ i ] ) {
</P><P>						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
</P><P>					} else {
</P><P>						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			// use temp geometry to compute face and vertex normals for each morph
</P><P>			var tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;
</P><P>			for ( i = 0, il = this.morphTargets.length; i &lt; il; i ++ ) {
</P><P>				// create on first access
</P><P>				if ( ! this.morphNormals[ i ] ) {
</P><P>					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];
</P><P>					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
</P><P>					var faceNormal, vertexNormals;
</P><P>					for ( f = 0, fl = this.faces.length; f &lt; fl; f ++ ) {
</P><P>						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
</P><P>						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );
</P><P>					}
</P><P>				}
</P><P>				var morphNormals = this.morphNormals[ i ];
</P><P>				// set vertices to morph target
</P><P>				tmpGeo.vertices = this.morphTargets[ i ].vertices;
</P><P>				// compute morph normals
</P><P>				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();
</P><P>				// store morph normals
</P><P>				var faceNormal, vertexNormals;
</P><P>				for ( f = 0, fl = this.faces.length; f &lt; fl; f ++ ) {
</P><P>					face = this.faces[ f ];
</P><P>					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];
</P><P>					faceNormal.copy( face.normal );
</P><P>					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );
</P><P>				}
</P><P>			}
</P><P>			// restore original normals
</P><P>			for ( f = 0, fl = this.faces.length; f &lt; fl; f ++ ) {
</P><P>				face = this.faces[ f ];
</P><P>				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
</P><P>			}
</P><P>		},
</P><P>		computeBoundingBox: function () {
</P><P>			if ( this.boundingBox === null ) {
</P><P>				this.boundingBox = new Box3();
</P><P>			}
</P><P>			this.boundingBox.setFromPoints( this.vertices );
</P><P>		},
</P><P>		computeBoundingSphere: function () {
</P><P>			if ( this.boundingSphere === null ) {
</P><P>				this.boundingSphere = new Sphere();
</P><P>			}
</P><P>			this.boundingSphere.setFromPoints( this.vertices );
</P><P>		},
</P><P>		merge: function ( geometry, matrix, materialIndexOffset ) {
</P><P>			if ( ! ( geometry &amp;&amp; geometry.isGeometry ) ) {
</P><P>				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;
</P><P>			}
</P><P>			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;
</P><P>			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
</P><P>			if ( matrix !== undefined ) {
</P><P>				normalMatrix = new Matrix3().getNormalMatrix( matrix );
</P><P>			}
</P><P>			// vertices
</P><P>			for ( var i = 0, il = vertices2.length; i &lt; il; i ++ ) {
</P><P>				var vertex = vertices2[ i ];
</P><P>				var vertexCopy = vertex.clone();
</P><P>				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
</P><P>				vertices1.push( vertexCopy );
</P><P>			}
</P><P>			// colors
</P><P>			for ( var i = 0, il = colors2.length; i &lt; il; i ++ ) {
</P><P>				colors1.push( colors2[ i ].clone() );
</P><P>			}
</P><P>			// faces
</P><P>			for ( i = 0, il = faces2.length; i &lt; il; i ++ ) {
</P><P>				var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;
</P><P>				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );
</P><P>				if ( normalMatrix !== undefined ) {
</P><P>					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
</P><P>				}
</P><P>				for ( var j = 0, jl = faceVertexNormals.length; j &lt; jl; j ++ ) {
</P><P>					normal = faceVertexNormals[ j ].clone();
</P><P>					if ( normalMatrix !== undefined ) {
</P><P>						normal.applyMatrix3( normalMatrix ).normalize();
</P><P>					}
</P><P>					faceCopy.vertexNormals.push( normal );
</P><P>				}
</P><P>				faceCopy.color.copy( face.color );
</P><P>				for ( var j = 0, jl = faceVertexColors.length; j &lt; jl; j ++ ) {
</P><P>					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );
</P><P>				}
</P><P>				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
</P><P>				faces1.push( faceCopy );
</P><P>			}
</P><P>			// uvs
</P><P>			for ( i = 0, il = uvs2.length; i &lt; il; i ++ ) {
</P><P>				var uv = uvs2[ i ], uvCopy = [];
</P><P>				if ( uv === undefined ) {
</P><P>					continue;
</P><P>				}
</P><P>				for ( var j = 0, jl = uv.length; j &lt; jl; j ++ ) {
</P><P>					uvCopy.push( uv[ j ].clone() );
</P><P>				}
</P><P>				uvs1.push( uvCopy );
</P><P>			}
</P><P>		},
</P><P>		mergeMesh: function ( mesh ) {
</P><P>			if ( ! ( mesh &amp;&amp; mesh.isMesh ) ) {
</P><P>				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;
</P><P>			}
</P><P>			if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();
</P><P>			this.merge( mesh.geometry, mesh.matrix );
</P><P>		},
</P><P>		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */
</P><P>		mergeVertices: function () {
</P><P>			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];
</P><P>			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;
</P><P>			for ( i = 0, il = this.vertices.length; i &lt; il; i ++ ) {
</P><P>				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
</P><P>				if ( verticesMap[ key ] === undefined ) {
</P><P>					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;
</P><P>				} else {
</P><P>					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];
</P><P>				}
</P><P>			}
</P><P>
			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];
</P><P>			for ( i = 0, il = this.faces.length; i &lt; il; i ++ ) {
</P><P>				face = this.faces[ i ];
</P><P>				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
</P><P>				indices = [ face.a, face.b, face.c ];
</P><P>				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n &lt; 3; n ++ ) {
</P><P>					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
</P><P>						faceIndicesToRemove.push( i );
						break;
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			for ( i = faceIndicesToRemove.length - 1; i &gt;= 0; i -- ) {
</P><P>				var idx = faceIndicesToRemove[ i ];
</P><P>				this.faces.splice( idx, 1 );
</P><P>				for ( j = 0, jl = this.faceVertexUvs.length; j &lt; jl; j ++ ) {
</P><P>					this.faceVertexUvs[ j ].splice( idx, 1 );
</P><P>				}
</P><P>			}
</P><P>			// Use unique set of vertices
</P><P>			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
</P><P>		},
</P><P>		setFromPoints: function ( points ) {
</P><P>			this.vertices = [];
</P><P>			for ( var i = 0, l = points.length; i &lt; l; i ++ ) {
</P><P>				var point = points[ i ];
				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		sortFacesByMaterialIndex: function () {
</P><P>			var faces = this.faces;
			var length = faces.length;
</P><P>			// tag faces
</P><P>			for ( var i = 0; i &lt; length; i ++ ) {
</P><P>				faces[ i ]._id = i;
</P><P>			}
</P><P>			// sort faces
</P><P>			function materialIndexSort( a, b ) {
</P><P>				return a.materialIndex - b.materialIndex;
</P><P>			}
</P><P>			faces.sort( materialIndexSort );
</P><P>			// sort uvs
</P><P>			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];
</P><P>			var newUvs1, newUvs2;
</P><P>			if ( uvs1 &amp;&amp; uvs1.length === length ) newUvs1 = [];
			if ( uvs2 &amp;&amp; uvs2.length === length ) newUvs2 = [];
</P><P>			for ( var i = 0; i &lt; length; i ++ ) {
</P><P>				var id = faces[ i ]._id;
</P><P>				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
</P><P>			}
</P><P>			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
</P><P>		},
</P><P>		toJSON: function () {
</P><P>			var data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};
</P><P>			// standard Geometry serialization
</P><P>			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== <I> ) data.name = this.name;</I></P><P>			if ( this.parameters !== undefined ) {
</P><P>				var parameters = this.parameters;
</P><P>				for ( var key in parameters ) {
</P><P>					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
</P><P>				}
</P><P>				return data;
</P><P>			}
</P><P>			var vertices = [];
</P><P>			for ( var i = 0; i &lt; this.vertices.length; i ++ ) {
</P><P>				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>			}
</P><P>			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};
</P><P>			for ( var i = 0; i &lt; this.faces.length; i ++ ) {
</P><P>				var face = this.faces[ i ];
</P><P>				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() &gt; 0;
				var hasFaceVertexNormal = face.vertexNormals.length &gt; 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length &gt; 0;
</P><P>				var faceType = 0;
</P><P>				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );
</P><P>				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );
</P><P>				if ( hasFaceVertexUv ) {
</P><P>					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
</P><P>					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);
</P><P>				}
</P><P>				if ( hasFaceNormal ) {
</P><P>					faces.push( getNormalIndex( face.normal ) );
</P><P>				}
</P><P>				if ( hasFaceVertexNormal ) {
</P><P>					var vertexNormals = face.vertexNormals;
</P><P>					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);
</P><P>				}
</P><P>				if ( hasFaceColor ) {
</P><P>					faces.push( getColorIndex( face.color ) );
</P><P>				}
</P><P>				if ( hasFaceVertexColor ) {
</P><P>					var vertexColors = face.vertexColors;
</P><P>					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);
</P><P>				}
</P><P>			}
</P><P>			function setBit( value, position, enabled ) {
</P><P>				return enabled ? value | ( 1 &lt;&lt; position ) : value &amp; ( ~ ( 1 &lt;&lt; position ) );
</P><P>			}
</P><P>			function getNormalIndex( normal ) {
</P><P>				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
</P><P>				if ( normalsHash[ hash ] !== undefined ) {
</P><P>					return normalsHash[ hash ];
</P><P>				}
</P><P>				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );
</P><P>				return normalsHash[ hash ];
</P><P>			}
</P><P>			function getColorIndex( color ) {
</P><P>				var hash = color.r.toString() + color.g.toString() + color.b.toString();
</P><P>				if ( colorsHash[ hash ] !== undefined ) {
</P><P>					return colorsHash[ hash ];
</P><P>				}
</P><P>				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );
</P><P>				return colorsHash[ hash ];
</P><P>			}
</P><P>			function getUvIndex( uv ) {
</P><P>				var hash = uv.x.toString() + uv.y.toString();
</P><P>				if ( uvsHash[ hash ] !== undefined ) {
</P><P>					return uvsHash[ hash ];
</P><P>				}
</P><P>				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );
</P><P>				return uvsHash[ hash ];
</P><P>			}
</P><P>			data.data = {};
</P><P>			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length &gt; 0 ) data.data.colors = colors;
			if ( uvs.length &gt; 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;
</P><P>			return data;
</P><P>		},
</P><P>		clone: function () {
</P><P>			/*
			 // Handle primitives
</P><P>			 var parameters = this.parameters;
</P><P>			 if ( parameters !== undefined ) {
</P><P>			 var values = [];
</P><P>			 for ( var key in parameters ) {
</P><P>			 values.push( parameters[ key ] );
</P><P>			 }
</P><P>			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;
</P><P>			 }
</P><P>			 return new this.constructor().copy( this );
			 */
</P><P>			return new Geometry().copy( this );
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			var i, il, j, jl, k, kl;
</P><P>			// reset
</P><P>			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;
</P><P>			// name
</P><P>			this.name = source.name;
</P><P>			// vertices
</P><P>			var vertices = source.vertices;
</P><P>			for ( i = 0, il = vertices.length; i &lt; il; i ++ ) {
</P><P>				this.vertices.push( vertices[ i ].clone() );
</P><P>			}
</P><P>			// colors
</P><P>			var colors = source.colors;
</P><P>			for ( i = 0, il = colors.length; i &lt; il; i ++ ) {
</P><P>				this.colors.push( colors[ i ].clone() );
</P><P>			}
</P><P>			// faces
</P><P>			var faces = source.faces;
</P><P>			for ( i = 0, il = faces.length; i &lt; il; i ++ ) {
</P><P>				this.faces.push( faces[ i ].clone() );
</P><P>			}
</P><P>			// face vertex uvs
</P><P>			for ( i = 0, il = source.faceVertexUvs.length; i &lt; il; i ++ ) {
</P><P>				var faceVertexUvs = source.faceVertexUvs[ i ];
</P><P>				if ( this.faceVertexUvs[ i ] === undefined ) {
</P><P>					this.faceVertexUvs[ i ] = [];
</P><P>				}
</P><P>				for ( j = 0, jl = faceVertexUvs.length; j &lt; jl; j ++ ) {
</P><P>					var uvs = faceVertexUvs[ j ], uvsCopy = [];
</P><P>					for ( k = 0, kl = uvs.length; k &lt; kl; k ++ ) {
</P><P>						var uv = uvs[ k ];
</P><P>						uvsCopy.push( uv.clone() );
</P><P>					}
</P><P>					this.faceVertexUvs[ i ].push( uvsCopy );
</P><P>				}
</P><P>			}
</P><P>			// morph targets
</P><P>			var morphTargets = source.morphTargets;
</P><P>			for ( i = 0, il = morphTargets.length; i &lt; il; i ++ ) {
</P><P>				var morphTarget = {};
				morphTarget.name = morphTargets[ i ].name;
</P><P>				// vertices
</P><P>				if ( morphTargets[ i ].vertices !== undefined ) {
</P><P>					morphTarget.vertices = [];
</P><P>					for ( j = 0, jl = morphTargets[ i ].vertices.length; j &lt; jl; j ++ ) {
</P><P>						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );
</P><P>					}
</P><P>				}
</P><P>				// normals
</P><P>				if ( morphTargets[ i ].normals !== undefined ) {
</P><P>					morphTarget.normals = [];
</P><P>					for ( j = 0, jl = morphTargets[ i ].normals.length; j &lt; jl; j ++ ) {
</P><P>						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );
</P><P>					}
</P><P>				}
</P><P>				this.morphTargets.push( morphTarget );
</P><P>			}
</P><P>			// morph normals
</P><P>			var morphNormals = source.morphNormals;
</P><P>			for ( i = 0, il = morphNormals.length; i &lt; il; i ++ ) {
</P><P>				var morphNormal = {};
</P><P>				// vertex normals
</P><P>				if ( morphNormals[ i ].vertexNormals !== undefined ) {
</P><P>					morphNormal.vertexNormals = [];
</P><P>					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j &lt; jl; j ++ ) {
</P><P>						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
						var destVertexNormal = {};
</P><P>						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();
</P><P>						morphNormal.vertexNormals.push( destVertexNormal );
</P><P>					}
</P><P>				}
</P><P>				// face normals
</P><P>				if ( morphNormals[ i ].faceNormals !== undefined ) {
</P><P>					morphNormal.faceNormals = [];
</P><P>					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j &lt; jl; j ++ ) {
</P><P>						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );
</P><P>					}
</P><P>				}
</P><P>				this.morphNormals.push( morphNormal );
</P><P>			}
</P><P>			// skin weights
</P><P>			var skinWeights = source.skinWeights;
</P><P>			for ( i = 0, il = skinWeights.length; i &lt; il; i ++ ) {
</P><P>				this.skinWeights.push( skinWeights[ i ].clone() );
</P><P>			}
</P><P>			// skin indices
</P><P>			var skinIndices = source.skinIndices;
</P><P>			for ( i = 0, il = skinIndices.length; i &lt; il; i ++ ) {
</P><P>				this.skinIndices.push( skinIndices[ i ].clone() );
</P><P>			}
</P><P>			// line distances
</P><P>			var lineDistances = source.lineDistances;
</P><P>			for ( i = 0, il = lineDistances.length; i &lt; il; i ++ ) {
</P><P>				this.lineDistances.push( lineDistances[ i ] );
</P><P>			}
</P><P>			// bounding box
</P><P>			var boundingBox = source.boundingBox;
</P><P>			if ( boundingBox !== null ) {
</P><P>				this.boundingBox = boundingBox.clone();
</P><P>			}
</P><P>			// bounding sphere
</P><P>			var boundingSphere = source.boundingSphere;
</P><P>			if ( boundingSphere !== null ) {
</P><P>				this.boundingSphere = boundingSphere.clone();
</P><P>			}
</P><P>			// update flags
</P><P>			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;
</P><P>			return this;
</P><P>		},
</P><P>		dispose: function () {
</P><P>			this.dispatchEvent( { type: 'dispose' } );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function BufferAttribute( array, itemSize, normalized ) {
</P><P>		if ( Array.isArray( array ) ) {
</P><P>			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
</P><P>		}
</P><P>		this.name = <I>;</I></P><P>		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;
</P><P>		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
</P><P>		this.version = 0;
</P><P>	}
</P><P>	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {
</P><P>		set: function ( value ) {
</P><P>			if ( value === true ) this.version ++;
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( BufferAttribute.prototype, {
</P><P>		isBufferAttribute: true,
</P><P>		onUploadCallback: function () {},
</P><P>		setArray: function ( array ) {
</P><P>			if ( Array.isArray( array ) ) {
</P><P>				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
</P><P>			}
</P><P>			this.count = array !== undefined ? array.length / this.itemSize : 0;
			this.array = array;
</P><P>			return this;
</P><P>		},
</P><P>		setDynamic: function ( value ) {
</P><P>			this.dynamic = value;
</P><P>			return this;
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;
</P><P>			this.dynamic = source.dynamic;
</P><P>			return this;
</P><P>		},
</P><P>		copyAt: function ( index1, attribute, index2 ) {
</P><P>			index1 *= this.itemSize;
			index2 *= attribute.itemSize;
</P><P>			for ( var i = 0, l = this.itemSize; i &lt; l; i ++ ) {
</P><P>				this.array[ index1 + i ] = attribute.array[ index2 + i ];
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		copyArray: function ( array ) {
</P><P>			this.array.set( array );
</P><P>			return this;
</P><P>},
</P><P>		copyColorsArray: function ( colors ) {
</P><P>			var array = this.array, offset = 0;
</P><P>			for ( var i = 0, l = colors.length; i &lt; l; i ++ ) {
</P><P>				var color = colors[ i ];
</P><P>				if ( color === undefined ) {
</P><P>					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();
</P><P>				}
</P><P>				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		copyVector2sArray: function ( vectors ) {
</P><P>			var array = this.array, offset = 0;
</P><P>			for ( var i = 0, l = vectors.length; i &lt; l; i ++ ) {
</P><P>				var vector = vectors[ i ];
</P><P>				if ( vector === undefined ) {
</P><P>					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();
</P><P>				}
</P><P>				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		copyVector3sArray: function ( vectors ) {
</P><P>			var array = this.array, offset = 0;
</P><P>			for ( var i = 0, l = vectors.length; i &lt; l; i ++ ) {
</P><P>				var vector = vectors[ i ];
</P><P>				if ( vector === undefined ) {
</P><P>					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();
</P><P>				}
</P><P>				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		copyVector4sArray: function ( vectors ) {
</P><P>			var array = this.array, offset = 0;
</P><P>			for ( var i = 0, l = vectors.length; i &lt; l; i ++ ) {
</P><P>				var vector = vectors[ i ];
</P><P>				if ( vector === undefined ) {
</P><P>					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();
</P><P>				}
</P><P>				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		set: function ( value, offset ) {
</P><P>			if ( offset === undefined ) offset = 0;
</P><P>			this.array.set( value, offset );
</P><P>			return this;
</P><P>		},
</P><P>		getX: function ( index ) {
</P><P>			return this.array[ index * this.itemSize ];
</P><P>		},
</P><P>		setX: function ( index, x ) {
</P><P>			this.array[ index * this.itemSize ] = x;
</P><P>			return this;
</P><P>		},
</P><P>		getY: function ( index ) {
</P><P>			return this.array[ index * this.itemSize + 1 ];
</P><P>		},
</P><P>		setY: function ( index, y ) {
</P><P>			this.array[ index * this.itemSize + 1 ] = y;
</P><P>			return this;
</P><P>		},
</P><P>		getZ: function ( index ) {
</P><P>			return this.array[ index * this.itemSize + 2 ];
</P><P>		},
</P><P>		setZ: function ( index, z ) {
</P><P>			this.array[ index * this.itemSize + 2 ] = z;
</P><P>			return this;
</P><P>		},
</P><P>		getW: function ( index ) {
</P><P>			return this.array[ index * this.itemSize + 3 ];
</P><P>		},
</P><P>		setW: function ( index, w ) {
</P><P>			this.array[ index * this.itemSize + 3 ] = w;
</P><P>			return this;
</P><P>		},
</P><P>		setXY: function ( index, x, y ) {
</P><P>			index *= this.itemSize;
</P><P>			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
</P><P>			return this;
</P><P>		},
</P><P>		setXYZ: function ( index, x, y, z ) {
</P><P>			index *= this.itemSize;
</P><P>			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
</P><P>			return this;
</P><P>		},
</P><P>		setXYZW: function ( index, x, y, z, w ) {
</P><P>			index *= this.itemSize;
</P><P>			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;
</P><P>			return this;
</P><P>		},
</P><P>		onUpload: function ( callback ) {
</P><P>			this.onUploadCallback = callback;
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.array, this.itemSize ).copy( this );
</P><P>		}
</P><P>	} );
</P><P>	//
</P><P>	function Int8BufferAttribute( array, itemSize, normalized ) {
</P><P>		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );
</P><P>	}
</P><P>	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
</P><P>
	function Uint8BufferAttribute( array, itemSize, normalized ) {
</P><P>		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );
</P><P>	}
</P><P>	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
</P><P>
	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {
</P><P>		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );
</P><P>	}
</P><P>	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
</P><P>
	function Int16BufferAttribute( array, itemSize, normalized ) {
</P><P>		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );
</P><P>	}
</P><P>	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
</P><P>
	function Uint16BufferAttribute( array, itemSize, normalized ) {
</P><P>		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );
</P><P>	}
</P><P>	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
</P><P>
	function Int32BufferAttribute( array, itemSize, normalized ) {
</P><P>		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );
</P><P>	}
</P><P>	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
</P><P>
	function Uint32BufferAttribute( array, itemSize, normalized ) {
</P><P>		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );
</P><P>	}
</P><P>	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
</P><P>
	function Float32BufferAttribute( array, itemSize, normalized ) {
</P><P>		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );
</P><P>	}
</P><P>	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
</P><P>
	function Float64BufferAttribute( array, itemSize, normalized ) {
</P><P>		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );
</P><P>	}
</P><P>	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function DirectGeometry() {
</P><P>		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];
</P><P>		this.groups = [];
</P><P>		this.morphTargets = {};
</P><P>		this.skinWeights = [];
		this.skinIndices = [];
</P><P>		// this.lineDistances = [];
</P><P>		this.boundingBox = null;
		this.boundingSphere = null;
</P><P>		// update flags
</P><P>		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;
</P><P>	}
</P><P>	Object.assign( DirectGeometry.prototype, {
</P><P>		computeGroups: function ( geometry ) {
</P><P>			var group;
			var groups = [];
			var materialIndex = undefined;
</P><P>			var faces = geometry.faces;
</P><P>			for ( var i = 0; i &lt; faces.length; i ++ ) {
</P><P>				var face = faces[ i ];
</P><P>				// materials
</P><P>				if ( face.materialIndex !== materialIndex ) {
</P><P>					materialIndex = face.materialIndex;
</P><P>					if ( group !== undefined ) {
</P><P>						group.count = ( i * 3 ) - group.start;
						groups.push( group );
</P><P>					}
</P><P>					group = {
						start: i * 3,
						materialIndex: materialIndex
					};
</P><P>				}
</P><P>			}
</P><P>			if ( group !== undefined ) {
</P><P>				group.count = ( i * 3 ) - group.start;
				groups.push( group );
</P><P>			}
</P><P>			this.groups = groups;
</P><P>		},
</P><P>		fromGeometry: function ( geometry ) {
</P><P>			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;
</P><P>			var hasFaceVertexUv = faceVertexUvs[ 0 ] &amp;&amp; faceVertexUvs[ 0 ].length &gt; 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] &amp;&amp; faceVertexUvs[ 1 ].length &gt; 0;
</P><P>			// morphs
</P><P>			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;
</P><P>			var morphTargetsPosition;
</P><P>			if ( morphTargetsLength &gt; 0 ) {
</P><P>				morphTargetsPosition = [];
</P><P>				for ( var i = 0; i &lt; morphTargetsLength; i ++ ) {
</P><P>					morphTargetsPosition[ i ] = {
						name: morphTargets[ i ].name,
					 	data: []
					};
</P><P>				}
</P><P>				this.morphTargets.position = morphTargetsPosition;
</P><P>			}
</P><P>			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;
</P><P>			var morphTargetsNormal;
</P><P>			if ( morphNormalsLength &gt; 0 ) {
</P><P>				morphTargetsNormal = [];
</P><P>				for ( var i = 0; i &lt; morphNormalsLength; i ++ ) {
</P><P>					morphTargetsNormal[ i ] = {
						name: morphNormals[ i ].name,
					 	data: []
					};
</P><P>				}
</P><P>				this.morphTargets.normal = morphTargetsNormal;
</P><P>			}
</P><P>			// skins
</P><P>			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;
</P><P>			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;
</P><P>			//
</P><P>			if ( vertices.length &gt; 0 &amp;&amp; faces.length === 0 ) {
</P><P>				console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );
</P><P>			}
</P><P>			for ( var i = 0; i &lt; faces.length; i ++ ) {
</P><P>				var face = faces[ i ];
</P><P>				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
</P><P>				var vertexNormals = face.vertexNormals;
</P><P>				if ( vertexNormals.length === 3 ) {
</P><P>					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
</P><P>				} else {
</P><P>					var normal = face.normal;
</P><P>					this.normals.push( normal, normal, normal );
</P><P>				}
</P><P>				var vertexColors = face.vertexColors;
</P><P>				if ( vertexColors.length === 3 ) {
</P><P>					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
</P><P>				} else {
</P><P>					var color = face.color;
</P><P>					this.colors.push( color, color, color );
</P><P>				}
</P><P>				if ( hasFaceVertexUv === true ) {
</P><P>					var vertexUvs = faceVertexUvs[ 0 ][ i ];
</P><P>					if ( vertexUvs !== undefined ) {
</P><P>						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
</P><P>					} else {
</P><P>						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
</P><P>						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );
</P><P>					}
</P><P>				}
</P><P>				if ( hasFaceVertexUv2 === true ) {
</P><P>					var vertexUvs = faceVertexUvs[ 1 ][ i ];
</P><P>					if ( vertexUvs !== undefined ) {
</P><P>						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
</P><P>					} else {
</P><P>						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
</P><P>						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );
</P><P>					}
</P><P>				}
</P><P>				// morphs
</P><P>				for ( var j = 0; j &lt; morphTargetsLength; j ++ ) {
</P><P>					var morphTarget = morphTargets[ j ].vertices;
</P><P>					morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
</P><P>				}
</P><P>				for ( var j = 0; j &lt; morphNormalsLength; j ++ ) {
</P><P>					var morphNormal = morphNormals[ j ].vertexNormals[ i ];
</P><P>					morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );
</P><P>				}
</P><P>				// skins
</P><P>				if ( hasSkinIndices ) {
</P><P>					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
</P><P>				}
</P><P>				if ( hasSkinWeights ) {
</P><P>					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
</P><P>				}
</P><P>			}
</P><P>			this.computeGroups( geometry );
</P><P>			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function arrayMax( array ) {
</P><P>		if ( array.length === 0 ) return - Infinity;
</P><P>		var max = array[ 0 ];
</P><P>		for ( var i = 1, l = array.length; i &lt; l; ++ i ) {
</P><P>			if ( array[ i ] &gt; max ) max = array[ i ];
</P><P>		}
</P><P>		return max;
</P><P>	}
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id
</P><P>	function BufferGeometry() {
</P><P>		Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );
</P><P>		this.uuid = _Math.generateUUID();
</P><P>		this.name = <I>;</I>
		this.type = 'BufferGeometry';
</P><P>		this.index = null;
		this.attributes = {};
</P><P>		this.morphAttributes = {};
</P><P>		this.groups = [];
</P><P>		this.boundingBox = null;
		this.boundingSphere = null;
</P><P>		this.drawRange = { start: 0, count: Infinity };
</P><P>		this.userData = {};
</P><P>	}
</P><P>	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
</P><P>		constructor: BufferGeometry,
</P><P>		isBufferGeometry: true,
</P><P>		getIndex: function () {
</P><P>			return this.index;
</P><P>		},
</P><P>		setIndex: function ( index ) {
</P><P>			if ( Array.isArray( index ) ) {
</P><P>				this.index = new ( arrayMax( index ) &gt; 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );
</P><P>			} else {
</P><P>				this.index = index;
</P><P>			}
</P><P>		},
</P><P>		addAttribute: function ( name, attribute ) {
</P><P>			if ( ! ( attribute &amp;&amp; attribute.isBufferAttribute ) &amp;&amp; ! ( attribute &amp;&amp; attribute.isInterleavedBufferAttribute ) ) {
</P><P>				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
</P><P>				return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
</P><P>			}
</P><P>			if ( name === 'index' ) {
</P><P>				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );
</P><P>				return this;
</P><P>			}
</P><P>			this.attributes[ name ] = attribute;
</P><P>			return this;
</P><P>		},
</P><P>		getAttribute: function ( name ) {
</P><P>			return this.attributes[ name ];
</P><P>		},
</P><P>		removeAttribute: function ( name ) {
</P><P>			delete this.attributes[ name ];
</P><P>			return this;
</P><P>		},
</P><P>		addGroup: function ( start, count, materialIndex ) {
</P><P>			this.groups.push( {
</P><P>				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0
</P><P>			} );
</P><P>		},
</P><P>		clearGroups: function () {
</P><P>			this.groups = [];
</P><P>		},
</P><P>		setDrawRange: function ( start, count ) {
</P><P>			this.drawRange.start = start;
			this.drawRange.count = count;
</P><P>		},
</P><P>		applyMatrix: function ( matrix ) {
</P><P>			var position = this.attributes.position;
</P><P>			if ( position !== undefined ) {
</P><P>				matrix.applyToBufferAttribute( position );
				position.needsUpdate = true;
</P><P>			}
</P><P>			var normal = this.attributes.normal;
</P><P>			if ( normal !== undefined ) {
</P><P>				var normalMatrix = new Matrix3().getNormalMatrix( matrix );
</P><P>				normalMatrix.applyToBufferAttribute( normal );
				normal.needsUpdate = true;
</P><P>			}
</P><P>			if ( this.boundingBox !== null ) {
</P><P>				this.computeBoundingBox();
</P><P>			}
</P><P>			if ( this.boundingSphere !== null ) {
</P><P>				this.computeBoundingSphere();
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		rotateX: function () {
</P><P>			// rotate geometry around world x-axis
</P><P>			var m1 = new Matrix4();
</P><P>			return function rotateX( angle ) {
</P><P>				m1.makeRotationX( angle );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		rotateY: function () {
</P><P>			// rotate geometry around world y-axis
</P><P>			var m1 = new Matrix4();
</P><P>			return function rotateY( angle ) {
</P><P>				m1.makeRotationY( angle );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		rotateZ: function () {
</P><P>			// rotate geometry around world z-axis
</P><P>			var m1 = new Matrix4();
</P><P>			return function rotateZ( angle ) {
</P><P>				m1.makeRotationZ( angle );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		translate: function () {
</P><P>			// translate geometry
</P><P>			var m1 = new Matrix4();
</P><P>			return function translate( x, y, z ) {
</P><P>				m1.makeTranslation( x, y, z );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		scale: function () {
</P><P>			// scale geometry
</P><P>			var m1 = new Matrix4();
</P><P>			return function scale( x, y, z ) {
</P><P>				m1.makeScale( x, y, z );
</P><P>				this.applyMatrix( m1 );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		lookAt: function () {
</P><P>			var obj = new Object3D();
</P><P>			return function lookAt( vector ) {
</P><P>				obj.lookAt( vector );
</P><P>				obj.updateMatrix();
</P><P>				this.applyMatrix( obj.matrix );
</P><P>			};
</P><P>		}(),
</P><P>		center: function () {
</P><P>			var offset = new Vector3();
</P><P>			return function center() {
</P><P>				this.computeBoundingBox();
</P><P>				this.boundingBox.getCenter( offset ).negate();
</P><P>				this.translate( offset.x, offset.y, offset.z );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		setFromObject: function ( object ) {
</P><P>			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
</P><P>			var geometry = object.geometry;
</P><P>			if ( object.isPoints || object.isLine ) {
</P><P>				var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
				var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );
</P><P>				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
</P><P>				if ( geometry.lineDistances &amp;&amp; geometry.lineDistances.length === geometry.vertices.length ) {
</P><P>					var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );
</P><P>					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
</P><P>				}
</P><P>				if ( geometry.boundingSphere !== null ) {
</P><P>					this.boundingSphere = geometry.boundingSphere.clone();
</P><P>				}
</P><P>				if ( geometry.boundingBox !== null ) {
</P><P>					this.boundingBox = geometry.boundingBox.clone();
</P><P>				}
</P><P>			} else if ( object.isMesh ) {
</P><P>				if ( geometry &amp;&amp; geometry.isGeometry ) {
</P><P>					this.fromGeometry( geometry );
</P><P>				}
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		setFromPoints: function ( points ) {
</P><P>			var position = [];
</P><P>			for ( var i = 0, l = points.length; i &lt; l; i ++ ) {
</P><P>				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );
</P><P>			}
</P><P>			this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );
</P><P>			return this;
</P><P>		},
</P><P>		updateFromObject: function ( object ) {
</P><P>			var geometry = object.geometry;
</P><P>			if ( object.isMesh ) {
</P><P>				var direct = geometry.__directGeometry;
</P><P>				if ( geometry.elementsNeedUpdate === true ) {
</P><P>					direct = undefined;
					geometry.elementsNeedUpdate = false;
</P><P>				}
</P><P>				if ( direct === undefined ) {
</P><P>					return this.fromGeometry( geometry );
</P><P>				}
</P><P>				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
</P><P>				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;
</P><P>				geometry = direct;
</P><P>			}
</P><P>			var attribute;
</P><P>			if ( geometry.verticesNeedUpdate === true ) {
</P><P>				attribute = this.attributes.position;
</P><P>				if ( attribute !== undefined ) {
</P><P>					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;
</P><P>				}
</P><P>				geometry.verticesNeedUpdate = false;
</P><P>			}
</P><P>			if ( geometry.normalsNeedUpdate === true ) {
</P><P>				attribute = this.attributes.normal;
</P><P>				if ( attribute !== undefined ) {
</P><P>					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;
</P><P>	}
</P><P>				geometry.normalsNeedUpdate = false;
</P><P>			}
</P><P>			if ( geometry.colorsNeedUpdate === true ) {
</P><P>				attribute = this.attributes.color;
</P><P>				if ( attribute !== undefined ) {
</P><P>					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;
</P><P>				}
</P><P>				geometry.colorsNeedUpdate = false;
</P><P>			}
</P><P>			if ( geometry.uvsNeedUpdate ) {
</P><P>				attribute = this.attributes.uv;
</P><P>				if ( attribute !== undefined ) {
</P><P>					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;
</P><P>				}
</P><P>				geometry.uvsNeedUpdate = false;
</P><P>			}
</P><P>			if ( geometry.lineDistancesNeedUpdate ) {
</P><P>				attribute = this.attributes.lineDistance;
</P><P>				if ( attribute !== undefined ) {
</P><P>					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;
</P><P>				}
</P><P>				geometry.lineDistancesNeedUpdate = false;
</P><P>			}
</P><P>			if ( geometry.groupsNeedUpdate ) {
</P><P>				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;
</P><P>				geometry.groupsNeedUpdate = false;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		fromGeometry: function ( geometry ) {
</P><P>			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );
</P><P>			return this.fromDirectGeometry( geometry.__directGeometry );
</P><P>		},
</P><P>		fromDirectGeometry: function ( geometry ) {
</P><P>			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
</P><P>			if ( geometry.normals.length &gt; 0 ) {
</P><P>				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
</P><P>			}
</P><P>			if ( geometry.colors.length &gt; 0 ) {
</P><P>				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
</P><P>			}
</P><P>			if ( geometry.uvs.length &gt; 0 ) {
</P><P>				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
</P><P>			}
</P><P>			if ( geometry.uvs2.length &gt; 0 ) {
</P><P>				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
</P><P>			}
</P><P>			// groups
</P><P>			this.groups = geometry.groups;
</P><P>			// morphs
</P><P>			for ( var name in geometry.morphTargets ) {
</P><P>				var array = [];
				var morphTargets = geometry.morphTargets[ name ];
</P><P>				for ( var i = 0, l = morphTargets.length; i &lt; l; i ++ ) {
</P><P>					var morphTarget = morphTargets[ i ];
</P><P>					var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
					attribute.name = morphTarget.name;
</P><P>					array.push( attribute.copyVector3sArray( morphTarget.data ) );
</P><P>				}
</P><P>				this.morphAttributes[ name ] = array;
</P><P>			}
</P><P>			// skinning
</P><P>			if ( geometry.skinIndices.length &gt; 0 ) {
</P><P>				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
</P><P>			}
</P><P>			if ( geometry.skinWeights.length &gt; 0 ) {
</P><P>				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
</P><P>			}
</P><P>			//
</P><P>			if ( geometry.boundingSphere !== null ) {
</P><P>				this.boundingSphere = geometry.boundingSphere.clone();
</P><P>			}
</P><P>			if ( geometry.boundingBox !== null ) {
</P><P>				this.boundingBox = geometry.boundingBox.clone();
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		computeBoundingBox: function () {
</P><P>			if ( this.boundingBox === null ) {
</P><P>				this.boundingBox = new Box3();
</P><P>			}
</P><P>			var position = this.attributes.position;
</P><P>			if ( position !== undefined ) {
</P><P>				this.boundingBox.setFromBufferAttribute( position );
</P><P>			} else {
</P><P>				this.boundingBox.makeEmpty();
</P><P>			}
</P><P>			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
</P><P>				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The &quot;position&quot; attribute is likely to have NaN values.', this );
</P><P>			}
</P><P>		},
</P><P>		computeBoundingSphere: function () {
</P><P>			var box = new Box3();
			var vector = new Vector3();
</P><P>			return function computeBoundingSphere() {
</P><P>				if ( this.boundingSphere === null ) {
</P><P>					this.boundingSphere = new Sphere();
</P><P>				}
</P><P>				var position = this.attributes.position;
</P><P>				if ( position ) {
</P><P>					var center = this.boundingSphere.center;
</P><P>					box.setFromBufferAttribute( position );
					box.getCenter( center );
</P><P>					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
</P><P>					var maxRadiusSq = 0;
</P><P>					for ( var i = 0, il = position.count; i &lt; il; i ++ ) {
</P><P>						vector.x = position.getX( i );
						vector.y = position.getY( i );
						vector.z = position.getZ( i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
</P><P>					}
</P><P>					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
</P><P>					if ( isNaN( this.boundingSphere.radius ) ) {
</P><P>						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The &quot;position&quot; attribute is likely to have NaN values.', this );
</P><P>					}
</P><P>				}
</P><P>			};
</P><P>		}(),
</P><P>		computeFaceNormals: function () {
</P><P>			// backwards compatibility
</P><P>		},
</P><P>		computeVertexNormals: function () {
</P><P>			var index = this.index;
			var attributes = this.attributes;
</P><P>			if ( attributes.position ) {
</P><P>				var positions = attributes.position.array;
</P><P>				if ( attributes.normal === undefined ) {
</P><P>					this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );
</P><P>				} else {
</P><P>					// reset existing normals to zero
</P><P>					var array = attributes.normal.array;
</P><P>					for ( var i = 0, il = array.length; i &lt; il; i ++ ) {
</P><P>						array[ i ] = 0;
</P><P>					}
</P><P>				}
</P><P>				var normals = attributes.normal.array;
</P><P>				var vA, vB, vC;
				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();
</P><P>				// indexed elements
</P><P>				if ( index ) {
</P><P>					var indices = index.array;
</P><P>					for ( var i = 0, il = index.count; i &lt; il; i += 3 ) {
</P><P>						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;
</P><P>						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );
</P><P>						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
</P><P>						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;
</P><P>						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;
</P><P>						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;
</P><P>					}
</P><P>				} else {
</P><P>					// non-indexed elements (unconnected triangle soup)
</P><P>					for ( var i = 0, il = positions.length; i &lt; il; i += 9 ) {
</P><P>						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );
</P><P>						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
</P><P>						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;
</P><P>						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;
</P><P>						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;
</P><P>					}
</P><P>				}
</P><P>				this.normalizeNormals();
</P><P>				attributes.normal.needsUpdate = true;
</P><P>			}
</P><P>		},
</P><P>		merge: function ( geometry, offset ) {
</P><P>			if ( ! ( geometry &amp;&amp; geometry.isBufferGeometry ) ) {
</P><P>				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;
</P><P>			}
</P><P>			if ( offset === undefined ) {
</P><P>				offset = 0;
</P><P>				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);
</P><P>			}
</P><P>			var attributes = this.attributes;
</P><P>			for ( var key in attributes ) {
</P><P>				if ( geometry.attributes[ key ] === undefined ) continue;
</P><P>				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;
</P><P>				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;
</P><P>				var attributeSize = attribute2.itemSize;
</P><P>				for ( var i = 0, j = attributeSize * offset; i &lt; attributeArray2.length; i ++, j ++ ) {
</P><P>					attributeArray1[ j ] = attributeArray2[ i ];
</P><P>				}
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		normalizeNormals: function () {
</P><P>			var vector = new Vector3();
</P><P>			return function normalizeNormals() {
</P><P>				var normals = this.attributes.normal;
</P><P>				for ( var i = 0, il = normals.count; i &lt; il; i ++ ) {
</P><P>					vector.x = normals.getX( i );
					vector.y = normals.getY( i );
					vector.z = normals.getZ( i );
</P><P>					vector.normalize();
</P><P>					normals.setXYZ( i, vector.x, vector.y, vector.z );
</P><P>				}
</P><P>			};
</P><P>		}(),
</P><P>		toNonIndexed: function () {
</P><P>	if ( this.index === null ) {
</P><P>				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;
</P><P>			}
</P><P>			var geometry2 = new BufferGeometry();
</P><P>			var indices = this.index.array;
			var attributes = this.attributes;
</P><P>			for ( var name in attributes ) {
</P><P>				var attribute = attributes[ name ];
</P><P>				var array = attribute.array;
				var itemSize = attribute.itemSize;
</P><P>				var array2 = new array.constructor( indices.length * itemSize );
</P><P>				var index = 0, index2 = 0;
</P><P>				for ( var i = 0, l = indices.length; i &lt; l; i ++ ) {
</P><P>					index = indices[ i ] * itemSize;
</P><P>					for ( var j = 0; j &lt; itemSize; j ++ ) {
</P><P>						array2[ index2 ++ ] = array[ index ++ ];
</P><P>					}
</P><P>				}
</P><P>				geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );
</P><P>			}
</P><P>			var groups = this.groups;
</P><P>			for ( var i = 0, l = groups.length; i &lt; l; i ++ ) {
</P><P>				var group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );
</P><P>			}
</P><P>			return geometry2;
</P><P>		},
</P><P>		toJSON: function () {
</P><P>			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};
</P><P>			// standard BufferGeometry serialization
</P><P>			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== <I> ) data.name = this.name;</I>
			if ( Object.keys( this.userData ).length &gt; 0 ) data.userData = this.userData;
</P><P>			if ( this.parameters !== undefined ) {
</P><P>				var parameters = this.parameters;
</P><P>				for ( var key in parameters ) {
</P><P>					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
</P><P>				}
</P><P>				return data;
</P><P>			}
</P><P>			data.data = { attributes: {} };
</P><P>			var index = this.index;
</P><P>			if ( index !== null ) {
</P><P>				var array = Array.prototype.slice.call( index.array );
</P><P>				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};
</P><P>			}
</P><P>			var attributes = this.attributes;
</P><P>			for ( var key in attributes ) {
</P><P>				var attribute = attributes[ key ];
</P><P>				var array = Array.prototype.slice.call( attribute.array );
</P><P>				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array,
					normalized: attribute.normalized
				};
</P><P>			}
</P><P>			var groups = this.groups;
</P><P>			if ( groups.length &gt; 0 ) {
</P><P>				data.data.groups = JSON.parse( JSON.stringify( groups ) );
</P><P>			}
</P><P>			var boundingSphere = this.boundingSphere;
</P><P>			if ( boundingSphere !== null ) {
</P><P>				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
</P><P>			}
</P><P>			return data;
</P><P>		},
</P><P>		clone: function () {
</P><P>			/*
			 // Handle primitives
</P><P>			 var parameters = this.parameters;
</P><P>			 if ( parameters !== undefined ) {
</P><P>			 var values = [];
</P><P>			 for ( var key in parameters ) {
</P><P>			 values.push( parameters[ key ] );
</P><P>			 }
</P><P>			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;
</P><P>			 }
</P><P>			 return new this.constructor().copy( this );
			 */
</P><P>			return new BufferGeometry().copy( this );
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			var name, i, l;
</P><P>			// reset
</P><P>			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;
</P><P>			// name
</P><P>			this.name = source.name;
</P><P>			// index
</P><P>			var index = source.index;
</P><P>			if ( index !== null ) {
</P><P>				this.setIndex( index.clone() );
</P><P>			}
</P><P>			// attributes
</P><P>			var attributes = source.attributes;
</P><P>			for ( name in attributes ) {
</P><P>				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );
</P><P>			}
</P><P>			// morph attributes
</P><P>			var morphAttributes = source.morphAttributes;
</P><P>			for ( name in morphAttributes ) {
</P><P>				var array = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
</P><P>				for ( i = 0, l = morphAttribute.length; i &lt; l; i ++ ) {
</P><P>					array.push( morphAttribute[ i ].clone() );
</P><P>				}
</P><P>				this.morphAttributes[ name ] = array;
</P><P>			}
</P><P>			// groups
</P><P>			var groups = source.groups;
</P><P>			for ( i = 0, l = groups.length; i &lt; l; i ++ ) {
</P><P>				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );
</P><P>			}
</P><P>			// bounding box
</P><P>			var boundingBox = source.boundingBox;
</P><P>			if ( boundingBox !== null ) {
</P><P>				this.boundingBox = boundingBox.clone();
</P><P>			}
</P><P>			// bounding sphere
</P><P>			var boundingSphere = source.boundingSphere;
</P><P>			if ( boundingSphere !== null ) {
</P><P>				this.boundingSphere = boundingSphere.clone();
</P><P>			}
</P><P>			// draw range
</P><P>			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;
</P><P>			// user data
</P><P>			this.userData = source.userData;
</P><P>			return this;
</P><P>		},
</P><P>		dispose: function () {
</P><P>			this.dispatchEvent( { type: 'dispose' } );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// BoxGeometry
</P><P>	function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'BoxGeometry';
</P><P>		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
</P><P>		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();
</P><P>	}
</P><P>	BoxGeometry.prototype = Object.create( Geometry.prototype );
	BoxGeometry.prototype.constructor = BoxGeometry;
</P><P>	// BoxBufferGeometry
</P><P>	function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'BoxBufferGeometry';
</P><P>		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
</P><P>		var scope = this;
</P><P>		width = width || 1;
		height = height || 1;
		depth = depth || 1;
</P><P>		// segments
</P><P>		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		// helper variables
</P><P>		var numberOfVertices = 0;
		var groupStart = 0;
</P><P>		// build each side of the box geometry
</P><P>		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
</P><P>			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;
</P><P>			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;
</P><P>			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;
</P><P>			var vertexCounter = 0;
			var groupCount = 0;
</P><P>			var ix, iy;
</P><P>			var vector = new Vector3();
</P><P>			// generate vertices, normals and uvs
</P><P>			for ( iy = 0; iy &lt; gridY1; iy ++ ) {
</P><P>				var y = iy * segmentHeight - heightHalf;
</P><P>				for ( ix = 0; ix &lt; gridX1; ix ++ ) {
</P><P>					var x = ix * segmentWidth - widthHalf;
</P><P>					// set values to correct vector component
</P><P>					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;
</P><P>					// now apply vector to vertex buffer
</P><P>					vertices.push( vector.x, vector.y, vector.z );
</P><P>					// set values to correct vector component
</P><P>					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth &gt; 0 ? 1 : - 1;
</P><P>					// now apply vector to normal buffer
</P><P>					normals.push( vector.x, vector.y, vector.z );
</P><P>					// uvs
</P><P>					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );
</P><P>					// counters
</P><P>					vertexCounter += 1;
</P><P>				}
</P><P>			}
</P><P>			// indices
</P><P>			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment
</P><P>			for ( iy = 0; iy &lt; gridY; iy ++ ) {
</P><P>				for ( ix = 0; ix &lt; gridX; ix ++ ) {
</P><P>					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;
</P><P>					// faces
</P><P>					indices.push( a, b, d );
					indices.push( b, c, d );
</P><P>					// increase counter
</P><P>					groupCount += 6;
</P><P>				}
</P><P>			}
</P><P>			// add a group to the geometry. this will ensure multi material support
</P><P>			scope.addGroup( groupStart, groupCount, materialIndex );
</P><P>			// calculate new start value for groups
</P><P>			groupStart += groupCount;
</P><P>			// update total number of vertices
</P><P>			numberOfVertices += vertexCounter;
</P><P>		}
</P><P>	}
</P><P>	BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// PlaneGeometry
</P><P>	function PlaneGeometry( width, height, widthSegments, heightSegments ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'PlaneGeometry';
</P><P>		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
</P><P>		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
		this.mergeVertices();
</P><P>	}
</P><P>	PlaneGeometry.prototype = Object.create( Geometry.prototype );
	PlaneGeometry.prototype.constructor = PlaneGeometry;
</P><P>	// PlaneBufferGeometry
</P><P>	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'PlaneBufferGeometry';
</P><P>		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
</P><P>		width = width || 1;
		height = height || 1;
</P><P>		var width_half = width / 2;
		var height_half = height / 2;
</P><P>		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;
</P><P>		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;
</P><P>		var segment_width = width / gridX;
		var segment_height = height / gridY;
</P><P>		var ix, iy;
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		// generate vertices, normals and uvs
</P><P>		for ( iy = 0; iy &lt; gridY1; iy ++ ) {
</P><P>			var y = iy * segment_height - height_half;
</P><P>			for ( ix = 0; ix &lt; gridX1; ix ++ ) {
</P><P>				var x = ix * segment_width - width_half;
</P><P>				vertices.push( x, - y, 0 );
</P><P>				normals.push( 0, 0, 1 );
</P><P>				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );
</P><P>			}
</P><P>		}
</P><P>		// indices
</P><P>		for ( iy = 0; iy &lt; gridY; iy ++ ) {
</P><P>			for ( ix = 0; ix &lt; gridX; ix ++ ) {
</P><P>				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;
</P><P>				// faces
</P><P>				indices.push( a, b, d );
				indices.push( b, c, d );
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>	}
</P><P>	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	var materialId = 0;
</P><P>	function Material() {
</P><P>		Object.defineProperty( this, 'id', { value: materialId ++ } );
</P><P>		this.uuid = _Math.generateUUID();
</P><P>		this.name = <I>;</I>
		this.type = 'Material';
</P><P>		this.fog = true;
		this.lights = true;
</P><P>		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
</P><P>		this.opacity = 1;
		this.transparent = false;
</P><P>		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
</P><P>		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
</P><P>		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;
</P><P>		this.shadowSide = null;
</P><P>		this.colorWrite = true;
</P><P>		this.precision = null; // override the renderer's default precision for this material
</P><P>		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
</P><P>		this.dithering = false;
</P><P>		this.alphaTest = 0;
		this.premultipliedAlpha = false;
</P><P>		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
</P><P>		this.visible = true;
</P><P>		this.userData = {};
</P><P>		this.needsUpdate = true;
</P><P>	}
</P><P>	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
</P><P>		constructor: Material,
</P><P>		isMaterial: true,
</P><P>		onBeforeCompile: function () {},
</P><P>		setValues: function ( values ) {
</P><P>			if ( values === undefined ) return;
</P><P>			for ( var key in values ) {
</P><P>				var newValue = values[ key ];
</P><P>				if ( newValue === undefined ) {
</P><P>					console.warn( &quot;THREE.Material: '&quot; + key + &quot;' parameter is undefined.&quot; );
					continue;
</P><P>				}
</P><P>				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {
</P><P>					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;
</P><P>				}
</P><P>				var currentValue = this[ key ];
</P><P>				if ( currentValue === undefined ) {
</P><P>					console.warn( &quot;THREE.&quot; + this.type + &quot;: '&quot; + key + &quot;' is not a property of this material.&quot; );
					continue;
</P><P>				}
</P><P>				if ( currentValue &amp;&amp; currentValue.isColor ) {
</P><P>					currentValue.set( newValue );
</P><P>				} else if ( ( currentValue &amp;&amp; currentValue.isVector3 ) &amp;&amp; ( newValue &amp;&amp; newValue.isVector3 ) ) {
</P><P>					currentValue.copy( newValue );
</P><P>				} else if ( key === 'overdraw' ) {
</P><P>					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );
</P><P>				} else {
</P><P>					this[ key ] = newValue;
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		toJSON: function ( meta ) {
</P><P>			var isRoot = ( meta === undefined || typeof meta === 'string' );
</P><P>			if ( isRoot ) {
</P><P>				meta = {
					textures: {},
					images: {}
				};
</P><P>			}
</P><P>			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};
</P><P>			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
</P><P>			if ( this.name !== <I> ) data.name = this.name;</I></P><P>			if ( this.color &amp;&amp; this.color.isColor ) data.color = this.color.getHex();
</P><P>			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;
</P><P>			if ( this.emissive &amp;&amp; this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;
</P><P>			if ( this.specular &amp;&amp; this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
			if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;
</P><P>			if ( this.map &amp;&amp; this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap &amp;&amp; this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap &amp;&amp; this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
</P><P>			if ( this.aoMap &amp;&amp; this.aoMap.isTexture ) {
</P><P>				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
</P><P>			}
</P><P>			if ( this.bumpMap &amp;&amp; this.bumpMap.isTexture ) {
</P><P>				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;
</P><P>			}
</P><P>			if ( this.normalMap &amp;&amp; this.normalMap.isTexture ) {
</P><P>				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
</P><P>			}
</P><P>			if ( this.displacementMap &amp;&amp; this.displacementMap.isTexture ) {
</P><P>				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
</P><P>			}
</P><P>			if ( this.roughnessMap &amp;&amp; this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap &amp;&amp; this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
</P><P>			if ( this.emissiveMap &amp;&amp; this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap &amp;&amp; this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
</P><P>			if ( this.envMap &amp;&amp; this.envMap.isTexture ) {
</P><P>				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap</P><P>				if ( this.combine !== undefined ) data.combine = this.combine;
				if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
</P><P>			}
</P><P>			if ( this.gradientMap &amp;&amp; this.gradientMap.isTexture ) {
</P><P>				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;
</P><P>			}
</P><P>			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
</P><P>			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;
</P><P>			if ( this.opacity &lt; 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;
</P><P>			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
</P><P>			// rotation (SpriteMaterial)
			if ( this.rotation !== 0 ) data.rotation = this.rotation;
</P><P>			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;
</P><P>			if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;
</P><P>			if ( this.dithering === true ) data.dithering = true;
</P><P>			if ( this.alphaTest &gt; 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
</P><P>			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth &gt; 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
</P><P>			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.skinning === true ) data.skinning = true;
</P><P>			if ( this.visible === false ) data.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
</P><P>			// TODO: Copied from Object3D.toJSON
</P><P>			function extractFromCache( cache ) {
</P><P>				var values = [];
</P><P>				for ( var key in cache ) {
</P><P>					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
</P><P>				}
</P><P>				return values;
</P><P>			}
</P><P>			if ( isRoot ) {
</P><P>				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
</P><P>				if ( textures.length &gt; 0 ) data.textures = textures;
				if ( images.length &gt; 0 ) data.images = images;
</P><P>			}
</P><P>			return data;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			this.name = source.name;
</P><P>			this.fog = source.fog;
			this.lights = source.lights;
</P><P>			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;
</P><P>			this.opacity = source.opacity;
			this.transparent = source.transparent;
</P><P>			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
</P><P>			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
</P><P>			this.colorWrite = source.colorWrite;
</P><P>			this.precision = source.precision;
</P><P>			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
</P><P>			this.dithering = source.dithering;
</P><P>			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;
</P><P>			this.overdraw = source.overdraw;
</P><P>			this.visible = source.visible;
			this.userData = JSON.parse( JSON.stringify( source.userData ) );
</P><P>			this.clipShadows = source.clipShadows;
			this.clipIntersection = source.clipIntersection;
</P><P>			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;
</P><P>			if ( srcPlanes !== null ) {
</P><P>				var n = srcPlanes.length;
				dstPlanes = new Array( n );
</P><P>				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();
</P><P>			}
</P><P>			this.clippingPlanes = dstPlanes;
</P><P>			this.shadowSide = source.shadowSide;
</P><P>			return this;
</P><P>		},
</P><P>		dispose: function () {
</P><P>			this.dispatchEvent( { type: 'dispose' } );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 *
	 * parameters = {
	 *  defines: { &quot;label&quot; : &quot;value&quot; },
	 *  uniforms: { &quot;parameter1&quot;: { value: 1.0 }, &quot;parameter2&quot;: { value2: 2 } },
	 *
	 *  fragmentShader: &lt;string&gt;,
	 *  vertexShader: &lt;string&gt;,
	 *
	 *  wireframe: &lt;boolean&gt;,
	 *  wireframeLinewidth: &lt;float&gt;,
	 *
	 *  lights: &lt;bool&gt;,
	 *
	 *  skinning: &lt;bool&gt;,
	 *  morphTargets: &lt;bool&gt;,
	 *  morphNormals: &lt;bool&gt;
	 * }
	 */
</P><P>	function ShaderMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'ShaderMaterial';
</P><P>		this.defines = {};
		this.uniforms = {};
</P><P>		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
</P><P>		this.linewidth = 1;
</P><P>		this.wireframe = false;
		this.wireframeLinewidth = 1;
</P><P>		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes
</P><P>		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals
</P><P>		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};
</P><P>		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};
</P><P>		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;
</P><P>		if ( parameters !== undefined ) {
</P><P>			if ( parameters.attributes !== undefined ) {
</P><P>				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
</P><P>			}
</P><P>			this.setValues( parameters );
</P><P>		}
</P><P>	}
</P><P>	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;
</P><P>	ShaderMaterial.prototype.isShaderMaterial = true;
</P><P>	ShaderMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
</P><P>		this.uniforms = UniformsUtils.clone( source.uniforms );
</P><P>		this.defines = Object.assign( {}, source.defines );
</P><P>		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
</P><P>		this.lights = source.lights;
		this.clipping = source.clipping;
</P><P>		this.skinning = source.skinning;
</P><P>		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
</P><P>		this.extensions = source.extensions;
</P><P>		return this;
</P><P>	};
</P><P>	ShaderMaterial.prototype.toJSON = function ( meta ) {
</P><P>		var data = Material.prototype.toJSON.call( this, meta );
</P><P>		data.uniforms = {};
</P><P>		for ( var name in this.uniforms ) {
</P><P>			var uniform = this.uniforms[ name ];
			var value = uniform.value;
</P><P>			if ( value.isTexture ) {
</P><P>				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};
</P><P>			} else if ( value.isColor ) {
</P><P>				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};
</P><P>			} else if ( value.isVector2 ) {
</P><P>				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};
</P><P>			} else if ( value.isVector3 ) {
</P><P>				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};
</P><P>			} else if ( value.isVector4 ) {
</P><P>				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};
</P><P>			} else if ( value.isMatrix4 ) {
</P><P>				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};
</P><P>			} else {
</P><P>				data.uniforms[ name ] = {
					value: value
				};
</P><P>				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
</P><P>			}
</P><P>		}
</P><P>		if ( Object.keys( this.defines ).length &gt; 0 ) data.defines = this.defines;
</P><P>		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
</P><P>		return data;
</P><P>	};
</P><P>	/**
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 */
</P><P>	function Ray( origin, direction ) {
</P><P>		this.origin = ( origin !== undefined ) ? origin : new Vector3();
		this.direction = ( direction !== undefined ) ? direction : new Vector3();
</P><P>	}
</P><P>	Object.assign( Ray.prototype, {
</P><P>		set: function ( origin, direction ) {
</P><P>			this.origin.copy( origin );
			this.direction.copy( direction );
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( ray ) {
</P><P>			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );
</P><P>			return this;
</P><P>		},
</P><P>		at: function ( t, target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Ray: .at() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );
</P><P>		},
</P><P>		lookAt: function ( v ) {
</P><P>			this.direction.copy( v ).sub( this.origin ).normalize();
</P><P>			return this;
</P><P>		},
</P><P>		recast: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function recast( t ) {
</P><P>				this.origin.copy( this.at( t, v1 ) );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		closestPointToPoint: function ( point, target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			target.subVectors( point, this.origin );
</P><P>			var directionDistance = target.dot( this.direction );
</P><P>			if ( directionDistance &lt; 0 ) {
</P><P>				return target.copy( this.origin );
</P><P>			}
</P><P>			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
</P><P>		},
</P><P>		distanceToPoint: function ( point ) {
</P><P>			return Math.sqrt( this.distanceSqToPoint( point ) );
</P><P>		},
</P><P>		distanceSqToPoint: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function distanceSqToPoint( point ) {
</P><P>				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
</P><P>				// point behind the ray
</P><P>				if ( directionDistance &lt; 0 ) {
</P><P>					return this.origin.distanceToSquared( point );
</P><P>				}
</P><P>				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
</P><P>				return v1.distanceToSquared( point );
</P><P>			};
</P><P>		}(),
</P><P>		distanceSqToSegment: function () {
</P><P>			var segCenter = new Vector3();
			var segDir = new Vector3();
			var diff = new Vector3();
</P><P>			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
</P><P>				// from <A rel="nofollow" class="external free" href="http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h">http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h</A>
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment
</P><P>				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );
</P><P>				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;
</P><P>				if ( det &gt; 0 ) {
</P><P>					// The ray and segment are not parallel.
</P><P>					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;
</P><P>					if ( s0 &gt;= 0 ) {
</P><P>						if ( s1 &gt;= - extDet ) {
</P><P>							if ( s1 &lt;= extDet ) {
</P><P>								// region 0
								// Minimum at interior points of ray and segment.
</P><P>								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
</P><P>							} else {
</P><P>								// region 1
</P><P>								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
</P><P>							}
</P><P>						} else {
</P><P>							// region 5
</P><P>							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
</P><P>						}
</P><P>					} else {
</P><P>						if ( s1 &lt;= - extDet ) {
</P><P>							// region 4
</P><P>							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 &gt; 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
</P><P>						} else if ( s1 &lt;= extDet ) {
</P><P>							// region 3
</P><P>							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;
</P><P>						} else {
</P><P>							// region 2
</P><P>							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 &gt; 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
</P><P>						}
</P><P>					}
</P><P>				} else {
</P><P>					// Ray and segment are parallel.
</P><P>					s1 = ( a01 &gt; 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
</P><P>				}
</P><P>				if ( optionalPointOnRay ) {
</P><P>					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
</P><P>				}
</P><P>				if ( optionalPointOnSegment ) {
</P><P>					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
</P><P>				}
</P><P>				return sqrDist;
</P><P>			};
</P><P>		}(),
</P><P>		intersectSphere: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function intersectSphere( sphere, target ) {
</P><P>				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;
</P><P>				if ( d2 &gt; radius2 ) return null;
</P><P>				var thc = Math.sqrt( radius2 - d2 );
</P><P>				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;
</P><P>				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;
</P><P>				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 &lt; 0 &amp;&amp; t1 &lt; 0 ) return null;
</P><P>				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 &lt; 0 ) return this.at( t1, target );
</P><P>				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, target );
</P><P>			};
</P><P>		}(),
</P><P>		intersectsSphere: function ( sphere ) {
</P><P>			return this.distanceSqToPoint( sphere.center ) &lt;= ( sphere.radius * sphere.radius );
</P><P>		},
</P><P>		distanceToPlane: function ( plane ) {
</P><P>			var denominator = plane.normal.dot( this.direction );
</P><P>			if ( denominator === 0 ) {
</P><P>				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {
</P><P>					return 0;
</P><P>				}
</P><P>				// Null is preferable to undefined since undefined means.... it is undefined
</P><P>				return null;
</P><P>			}
</P><P>			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
</P><P>			// Return if the ray never intersects the plane
</P><P>			return t &gt;= 0 ? t : null;
</P><P>		},
</P><P>		intersectPlane: function ( plane, target ) {
</P><P>			var t = this.distanceToPlane( plane );
</P><P>			if ( t === null ) {
</P><P>				return null;
</P><P>			}
</P><P>			return this.at( t, target );
</P><P>		},
</P><P>		intersectsPlane: function ( plane ) {
</P><P>			// check if the ray lies on the plane first
</P><P>			var distToPoint = plane.distanceToPoint( this.origin );
</P><P>			if ( distToPoint === 0 ) {
</P><P>				return true;
</P><P>			}
</P><P>			var denominator = plane.normal.dot( this.direction );
</P><P>			if ( denominator * distToPoint &lt; 0 ) {
</P><P>				return true;
</P><P>			}
</P><P>			// ray origin is behind the plane (and is pointing behind it)
</P><P>			return false;
</P><P>		},
</P><P>		intersectBox: function ( box, target ) {
</P><P>			var tmin, tmax, tymin, tymax, tzmin, tzmax;
</P><P>			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;
</P><P>			var origin = this.origin;
</P><P>			if ( invdirx &gt;= 0 ) {
</P><P>				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;
</P><P>			} else {
</P><P>				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
</P><P>			}
</P><P>			if ( invdiry &gt;= 0 ) {
</P><P>				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;
</P><P>			} else {
</P><P>				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
</P><P>			}
</P><P>			if ( ( tmin &gt; tymax ) || ( tymin &gt; tmax ) ) return null;
</P><P>			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN
</P><P>			if ( tymin &gt; tmin || tmin !== tmin ) tmin = tymin;
</P><P>			if ( tymax &lt; tmax || tmax !== tmax ) tmax = tymax;
</P><P>			if ( invdirz &gt;= 0 ) {
</P><P>				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;
</P><P>			} else {
</P><P>				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
</P><P>			}
</P><P>			if ( ( tmin &gt; tzmax ) || ( tzmin &gt; tmax ) ) return null;
</P><P>			if ( tzmin &gt; tmin || tmin !== tmin ) tmin = tzmin;
</P><P>			if ( tzmax &lt; tmax || tmax !== tmax ) tmax = tzmax;
</P><P>			//return point closest to the ray (positive side)
</P><P>			if ( tmax &lt; 0 ) return null;
</P><P>			return this.at( tmin &gt;= 0 ? tmin : tmax, target );
</P><P>		},
</P><P>		intersectsBox: ( function () {
</P><P>			var v = new Vector3();
</P><P>			return function intersectsBox( box ) {
</P><P>				return this.intersectBox( box, v ) !== null;
</P><P>			};
</P><P>		} )(),
</P><P>		intersectTriangle: function () {
</P><P>			// Compute the offset origin, edges, and normal.
			var diff = new Vector3();
			var edge1 = new Vector3();
			var edge2 = new Vector3();
			var normal = new Vector3();
</P><P>			return function intersectTriangle( a, b, c, backfaceCulling, target ) {
</P><P>				// from <A rel="nofollow" class="external free" href="http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h">http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h</A></P><P>				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );
</P><P>				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;
</P><P>				if ( DdN &gt; 0 ) {
</P><P>					if ( backfaceCulling ) return null;
					sign = 1;
</P><P>				} else if ( DdN &lt; 0 ) {
</P><P>					sign = - 1;
					DdN = - DdN;
</P><P>				} else {
</P><P>					return null;
</P><P>				}
</P><P>				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
</P><P>				// b1 &lt; 0, no intersection
				if ( DdQxE2 &lt; 0 ) {
</P><P>					return null;
</P><P>				}
</P><P>				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
</P><P>				// b2 &lt; 0, no intersection
				if ( DdE1xQ &lt; 0 ) {
</P><P>					return null;
</P><P>				}
</P><P>				// b1+b2 &gt; 1, no intersection
				if ( DdQxE2 + DdE1xQ &gt; DdN ) {
</P><P>				return null;
</P><P>				}
</P><P>				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );
</P><P>				// t &lt; 0, no intersection
				if ( QdN &lt; 0 ) {
</P><P>					return null;
</P><P>				}
</P><P>				// Ray intersects triangle.
				return this.at( QdN / DdN, target );
</P><P>			};
</P><P>		}(),
</P><P>		applyMatrix4: function ( matrix4 ) {
</P><P>			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );
</P><P>			return this;
</P><P>		},
</P><P>		equals: function ( ray ) {
</P><P>			return ray.origin.equals( this.origin ) &amp;&amp; ray.direction.equals( this.direction );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function Triangle( a, b, c ) {
</P><P>		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();
</P><P>	}
</P><P>	Object.assign( Triangle, {
</P><P>		getNormal: function () {
</P><P>			var v0 = new Vector3();
</P><P>			return function getNormal( a, b, c, target ) {
</P><P>				if ( target === undefined ) {
</P><P>					console.warn( 'THREE.Triangle: .getNormal() target is now required' );
					target = new Vector3();
</P><P>				}
</P><P>				target.subVectors( c, b );
				v0.subVectors( a, b );
				target.cross( v0 );
</P><P>				var targetLengthSq = target.lengthSq();
				if ( targetLengthSq &gt; 0 ) {
</P><P>					return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );
</P><P>				}
</P><P>				return target.set( 0, 0, 0 );
</P><P>			};
</P><P>		}(),
</P><P>		// static/instance method to calculate barycentric coordinates
		// based on: <A rel="nofollow" class="external free" href="http://www.blackpawn.com/texts/pointinpoly/default.html">http://www.blackpawn.com/texts/pointinpoly/default.html</A>
		getBarycoord: function () {
</P><P>			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();
</P><P>			return function getBarycoord( point, a, b, c, target ) {
</P><P>				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );
</P><P>				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );
</P><P>				var denom = ( dot00 * dot11 - dot01 * dot01 );
</P><P>				if ( target === undefined ) {
</P><P>					console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
					target = new Vector3();
</P><P>				}
</P><P>				// collinear or singular triangle
				if ( denom === 0 ) {
</P><P>					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return target.set( - 2, - 1, - 1 );
</P><P>				}
</P><P>				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
</P><P>				// barycentric coordinates must always sum to 1
				return target.set( 1 - u - v, v, u );
</P><P>			};
</P><P>		}(),
</P><P>		containsPoint: function () {
</P><P>			var v1 = new Vector3();
</P><P>			return function containsPoint( point, a, b, c ) {
</P><P>				Triangle.getBarycoord( point, a, b, c, v1 );
</P><P>				return ( v1.x &gt;= 0 ) &amp;&amp; ( v1.y &gt;= 0 ) &amp;&amp; ( ( v1.x + v1.y ) &lt;= 1 );
</P><P>			};
</P><P>		}(),
</P><P>		getUV: function () {
</P><P>			var barycoord = new Vector3();
</P><P>			return function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {
</P><P>				this.getBarycoord( point, p1, p2, p3, barycoord );
</P><P>				target.set( 0, 0 );
				target.addScaledVector( uv1, barycoord.x );
				target.addScaledVector( uv2, barycoord.y );
				target.addScaledVector( uv3, barycoord.z );
</P><P>				return target;
</P><P>			};
</P><P>		}()
</P><P>	} );
</P><P>	Object.assign( Triangle.prototype, {
</P><P>		set: function ( a, b, c ) {
</P><P>			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );
</P><P>			return this;
</P><P>		},
</P><P>		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
</P><P>			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( triangle ) {
</P><P>			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );
</P><P>			return this;
</P><P>		},
</P><P>		getArea: function () {
</P><P>			var v0 = new Vector3();
			var v1 = new Vector3();
</P><P>			return function getArea() {
</P><P>				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );
</P><P>				return v0.cross( v1 ).length() * 0.5;
</P><P>			};
</P><P>		}(),
</P><P>		getMidpoint: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
</P><P>		},
</P><P>		getNormal: function ( target ) {
</P><P>			return Triangle.getNormal( this.a, this.b, this.c, target );
</P><P>		},
</P><P>		getPlane: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return target.setFromCoplanarPoints( this.a, this.b, this.c );
</P><P>		},
</P><P>		getBarycoord: function ( point, target ) {
</P><P>			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );
</P><P>		},
</P><P>		containsPoint: function ( point ) {
</P><P>			return Triangle.containsPoint( point, this.a, this.b, this.c );
</P><P>		},
</P><P>		getUV: function ( point, uv1, uv2, uv3, result ) {
</P><P>			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );
</P><P>		},
</P><P>		intersectsBox: function ( box ) {
</P><P>			return box.intersectsTriangle( this );
</P><P>		},
</P><P>		closestPointToPoint: function () {
</P><P>			var vab = new Vector3();
			var vac = new Vector3();
			var vbc = new Vector3();
			var vap = new Vector3();
			var vbp = new Vector3();
			var vcp = new Vector3();
</P><P>			return function closestPointToPoint( p, target ) {
</P><P>				if ( target === undefined ) {
</P><P>					console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
					target = new Vector3();
</P><P>				}
</P><P>				var a = this.a, b = this.b, c = this.c;
				var v, w;
</P><P>				// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
				// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
				// under the accompanying license; see chapter 5.1.5 for detailed explanation.
				// basically, we're distinguishing which of the voronoi regions of the triangle
				// the point lies in with the minimum amount of redundant computation.
</P><P>				vab.subVectors( b, a );
				vac.subVectors( c, a );
				vap.subVectors( p, a );
				var d1 = vab.dot( vap );
				var d2 = vac.dot( vap );
				if ( d1 &lt;= 0 &amp;&amp; d2 &lt;= 0 ) {
</P><P>					// vertex region of A; barycentric coords (1, 0, 0)
					return target.copy( a );
</P><P>				}
</P><P>				vbp.subVectors( p, b );
				var d3 = vab.dot( vbp );
				var d4 = vac.dot( vbp );
				if ( d3 &gt;= 0 &amp;&amp; d4 &lt;= d3 ) {
</P><P>					// vertex region of B; barycentric coords (0, 1, 0)
					return target.copy( b );
</P><P>				}
</P><P>				var vc = d1 * d4 - d3 * d2;
				if ( vc &lt;= 0 &amp;&amp; d1 &gt;= 0 &amp;&amp; d3 &lt;= 0 ) {
</P><P>					v = d1 / ( d1 - d3 );
					// edge region of AB; barycentric coords (1-v, v, 0)
					return target.copy( a ).addScaledVector( vab, v );
</P><P>				}
</P><P>				vcp.subVectors( p, c );
				var d5 = vab.dot( vcp );
				var d6 = vac.dot( vcp );
				if ( d6 &gt;= 0 &amp;&amp; d5 &lt;= d6 ) {
</P><P>					// vertex region of C; barycentric coords (0, 0, 1)
					return target.copy( c );
</P><P>				}
</P><P>				var vb = d5 * d2 - d1 * d6;
				if ( vb &lt;= 0 &amp;&amp; d2 &gt;= 0 &amp;&amp; d6 &lt;= 0 ) {
</P><P>					w = d2 / ( d2 - d6 );
					// edge region of AC; barycentric coords (1-w, 0, w)
					return target.copy( a ).addScaledVector( vac, w );
</P><P>				}
</P><P>				var va = d3 * d6 - d5 * d4;
				if ( va &lt;= 0 &amp;&amp; ( d4 - d3 ) &gt;= 0 &amp;&amp; ( d5 - d6 ) &gt;= 0 ) {
</P><P>					vbc.subVectors( c, b );
					w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
					// edge region of BC; barycentric coords (0, 1-w, w)
					return target.copy( b ).addScaledVector( vbc, w ); // edge region of BC
</P><P>				}
</P><P>				// face region
				var denom = 1 / ( va + vb + vc );
				// u = va * denom
				v = vb * denom;
				w = vc * denom;
				return target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );
</P><P>			};
</P><P>		}(),
</P><P>		equals: function ( triangle ) {
</P><P>			return triangle.a.equals( this.a ) &amp;&amp; triangle.b.equals( this.b ) &amp;&amp; triangle.c.equals( this.c );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 *
	 * parameters = {
	 *  color: &lt;hex&gt;,
	 *  opacity: &lt;float&gt;,
	 *  map: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  lightMap: new THREE.Texture( &lt;Image&gt; ),
	 *  lightMapIntensity: &lt;float&gt;
	 *
	 *  aoMap: new THREE.Texture( &lt;Image&gt; ),
	 *  aoMapIntensity: &lt;float&gt;
	 *
	 *  specularMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  alphaMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: &lt;float&gt;,
	 *  refractionRatio: &lt;float&gt;,
	 *
	 *  depthTest: &lt;bool&gt;,
	 *  depthWrite: &lt;bool&gt;,
	 *
	 *  wireframe: &lt;boolean&gt;,
	 *  wireframeLinewidth: &lt;float&gt;,
	 *
	 *  skinning: &lt;bool&gt;,
	 *  morphTargets: &lt;bool&gt;
	 * }
	 */
</P><P>	function MeshBasicMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'MeshBasicMaterial';
</P><P>		this.color = new Color( 0xffffff ); // emissive
</P><P>		this.map = null;
</P><P>		this.lightMap = null;
		this.lightMapIntensity = 1.0;
</P><P>		this.aoMap = null;
		this.aoMapIntensity = 1.0;
</P><P>		this.specularMap = null;
</P><P>		this.alphaMap = null;
</P><P>		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
</P><P>		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
</P><P>		this.skinning = false;
		this.morphTargets = false;
</P><P>		this.lights = false;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	MeshBasicMaterial.prototype = Object.create( Material.prototype );
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
</P><P>	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
</P><P>	MeshBasicMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.color.copy( source.color );
</P><P>		this.map = source.map;
</P><P>		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
</P><P>		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
</P><P>		this.specularMap = source.specularMap;
</P><P>		this.alphaMap = source.alphaMap;
</P><P>		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
</P><P>		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
</P><P>		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author jonobr1 / <A rel="nofollow" class="external free" href="http://jonobr1.com/">http://jonobr1.com/</A>
	 */
</P><P>	function Mesh( geometry, material ) {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Mesh';
</P><P>		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );
</P><P>		this.drawMode = TrianglesDrawMode;
</P><P>		this.updateMorphTargets();
</P><P>	}
</P><P>	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Mesh,
</P><P>		isMesh: true,
</P><P>		setDrawMode: function ( value ) {
</P><P>			this.drawMode = value;
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			Object3D.prototype.copy.call( this, source );
</P><P>			this.drawMode = source.drawMode;
</P><P>			if ( source.morphTargetInfluences !== undefined ) {
</P><P>				this.morphTargetInfluences = source.morphTargetInfluences.slice();
</P><P>			}
</P><P>			if ( source.morphTargetDictionary !== undefined ) {
</P><P>				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		updateMorphTargets: function () {
</P><P>			var geometry = this.geometry;
			var m, ml, name;
</P><P>			if ( geometry.isBufferGeometry ) {
</P><P>				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );
</P><P>				if ( keys.length &gt; 0 ) {
</P><P>					var morphAttribute = morphAttributes[ keys[ 0 ] ];
</P><P>					if ( morphAttribute !== undefined ) {
</P><P>						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};
</P><P>						for ( m = 0, ml = morphAttribute.length; m &lt; ml; m ++ ) {
</P><P>							name = morphAttribute[ m ].name || String( m );
</P><P>							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			} else {
</P><P>				var morphTargets = geometry.morphTargets;
</P><P>				if ( morphTargets !== undefined &amp;&amp; morphTargets.length &gt; 0 ) {
</P><P>					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};
</P><P>					for ( m = 0, ml = morphTargets.length; m &lt; ml; m ++ ) {
</P><P>						name = morphTargets[ m ].name || String( m );
</P><P>						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		raycast: ( function () {
</P><P>			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();
</P><P>			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();
</P><P>			var tempA = new Vector3();
			var tempB = new Vector3();
			var tempC = new Vector3();
</P><P>			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();
</P><P>			var intersectionPoint = new Vector3();
			var intersectionPointWorld = new Vector3();
</P><P>			function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {
</P><P>				var intersect;
</P><P>				if ( material.side === BackSide ) {
</P><P>					intersect = ray.intersectTriangle( pC, pB, pA, true, point );
</P><P>				} else {
</P><P>					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );
</P><P>				}
</P><P>				if ( intersect === null ) return null;
</P><P>				intersectionPointWorld.copy( point );
				intersectionPointWorld.applyMatrix4( object.matrixWorld );
</P><P>				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
</P><P>				if ( distance &lt; raycaster.near || distance &gt; raycaster.far ) return null;
</P><P>				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};
</P><P>			}
</P><P>			function checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {
</P><P>				vA.fromBufferAttribute( position, a );
				vB.fromBufferAttribute( position, b );
				vC.fromBufferAttribute( position, c );
</P><P>				var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );
</P><P>				if ( intersection ) {
</P><P>					if ( uv ) {
</P><P>						uvA.fromBufferAttribute( uv, a );
						uvB.fromBufferAttribute( uv, b );
						uvC.fromBufferAttribute( uv, c );
</P><P>						intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );
</P><P>					}
</P><P>					var face = new Face3( a, b, c );
					Triangle.getNormal( vA, vB, vC, face.normal );
</P><P>					intersection.face = face;
</P><P>				}
</P><P>				return intersection;
</P><P>			}
</P><P>			return function raycast( raycaster, intersects ) {
</P><P>				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;
</P><P>				if ( material === undefined ) return;
</P><P>				// Checking boundingSphere distance to ray
</P><P>				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
</P><P>				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
</P><P>				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
</P><P>				//
</P><P>				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
</P><P>				// Check boundingBox before continuing
</P><P>				if ( geometry.boundingBox !== null ) {
</P><P>					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
</P><P>				}
</P><P>				var intersection;
</P><P>				if ( geometry.isBufferGeometry ) {
</P><P>					var a, b, c;
					var index = geometry.index;
					var position = geometry.attributes.position;
					var uv = geometry.attributes.uv;
					var groups = geometry.groups;
					var drawRange = geometry.drawRange;
					var i, j, il, jl;
					var group, groupMaterial;
					var start, end;
</P><P>					if ( index !== null ) {
</P><P>						// indexed buffer geometry
</P><P>						if ( Array.isArray( material ) ) {
</P><P>							for ( i = 0, il = groups.length; i &lt; il; i ++ ) {
</P><P>								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];
</P><P>								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );
</P><P>								for ( j = start, jl = end; j &lt; jl; j += 3 ) {
</P><P>									a = index.getX( j );
									b = index.getX( j + 1 );
									c = index.getX( j + 2 );
</P><P>									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );
</P><P>									if ( intersection ) {
</P><P>										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
										intersects.push( intersection );
</P><P>									}
</P><P>								}
</P><P>							}
</P><P>						} else {
</P><P>							start = Math.max( 0, drawRange.start );
							end = Math.min( index.count, ( drawRange.start + drawRange.count ) );
</P><P>							for ( i = start, il = end; i &lt; il; i += 3 ) {
</P><P>								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );
</P><P>								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );
</P><P>								if ( intersection ) {
</P><P>									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
									intersects.push( intersection );
</P><P>								}
</P><P>							}
</P><P>						}
</P><P>					} else if ( position !== undefined ) {
</P><P>						// non-indexed buffer geometry
</P><P>						if ( Array.isArray( material ) ) {
</P><P>							for ( i = 0, il = groups.length; i &lt; il; i ++ ) {
</P><P>								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];
</P><P>								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );
</P><P>								for ( j = start, jl = end; j &lt; jl; j += 3 ) {
</P><P>									a = j;
									b = j + 1;
									c = j + 2;
</P><P>									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );
</P><P>									if ( intersection ) {
</P><P>										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
										intersects.push( intersection );
</P><P>									}
</P><P>								}
</P><P>							}
</P><P>						} else {
</P><P>							start = Math.max( 0, drawRange.start );
							end = Math.min( position.count, ( drawRange.start + drawRange.count ) );
</P><P>							for ( i = start, il = end; i &lt; il; i += 3 ) {
</P><P>								a = i;
								b = i + 1;
								c = i + 2;
</P><P>								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );
</P><P>								if ( intersection ) {
</P><P>									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
									intersects.push( intersection );
</P><P>								}
</P><P>							}
</P><P>						}
</P><P>					}
</P><P>				} else if ( geometry.isGeometry ) {
</P><P>					var fvA, fvB, fvC;
					var isMultiMaterial = Array.isArray( material );
</P><P>					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var uvs;
</P><P>					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length &gt; 0 ) uvs = faceVertexUvs;
</P><P>					for ( var f = 0, fl = faces.length; f &lt; fl; f ++ ) {
</P><P>						var face = faces[ f ];
						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;
</P><P>						if ( faceMaterial === undefined ) continue;
</P><P>						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];
</P><P>						if ( faceMaterial.morphTargets === true ) {
</P><P>							var morphTargets = geometry.morphTargets;
							var morphInfluences = this.morphTargetInfluences;
</P><P>							vA.set( 0, 0, 0 );
							vB.set( 0, 0, 0 );
							vC.set( 0, 0, 0 );
</P><P>							for ( var t = 0, tl = morphTargets.length; t &lt; tl; t ++ ) {
</P><P>								var influence = morphInfluences[ t ];
</P><P>								if ( influence === 0 ) continue;
</P><P>								var targets = morphTargets[ t ].vertices;
</P><P>								vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
								vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
								vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
</P><P>							}
</P><P>							vA.add( fvA );
							vB.add( fvB );
							vC.add( fvC );
</P><P>							fvA = vA;
							fvB = vB;
							fvC = vC;
</P><P>						}
</P><P>						intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
</P><P>						if ( intersection ) {
</P><P>							if ( uvs &amp;&amp; uvs[ f ] ) {
</P><P>								var uvs_f = uvs[ f ];
								uvA.copy( uvs_f[ 0 ] );
								uvB.copy( uvs_f[ 1 ] );
								uvC.copy( uvs_f[ 2 ] );
</P><P>								intersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );
</P><P>							}
</P><P>							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			};
</P><P>		}() ),
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.geometry, this.material ).copy( this );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {
</P><P>		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;
</P><P>		var planeMesh;
		var boxMesh;
</P><P>		function render( renderList, scene, camera, forceClear ) {
</P><P>			var background = scene.background;
</P><P>			if ( background === null ) {
</P><P>				setClear( clearColor, clearAlpha );
</P><P>			} else if ( background &amp;&amp; background.isColor ) {
</P><P>				setClear( background, 1 );
				forceClear = true;
</P><P>			}
</P><P>			if ( renderer.autoClear || forceClear ) {
</P><P>				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
</P><P>			}
</P><P>			if ( background &amp;&amp; background.isCubeTexture ) {
</P><P>				if ( boxMesh === undefined ) {
</P><P>					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							uniforms: UniformsUtils.clone( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: true,
							depthWrite: false,
							fog: false
						} )
					);
</P><P>					boxMesh.geometry.removeAttribute( 'normal' );
					boxMesh.geometry.removeAttribute( 'uv' );
</P><P>					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {
</P><P>						this.matrixWorld.copyPosition( camera.matrixWorld );
</P><P>					};
</P><P>					objects.update( boxMesh );
</P><P>				}
</P><P>				boxMesh.material.uniforms.tCube.value = background;
</P><P>				renderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );
</P><P>			} else if ( background &amp;&amp; background.isTexture ) {
</P><P>				if ( planeMesh === undefined ) {
</P><P>					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new ShaderMaterial( {
							uniforms: UniformsUtils.clone( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: true,
							depthWrite: false,
							fog: false
						} )
					);
</P><P>					planeMesh.geometry.removeAttribute( 'normal' );
</P><P>					objects.update( planeMesh );
</P><P>				}
</P><P>				planeMesh.material.uniforms.t2D.value = background;
</P><P>				renderList.push( planeMesh, planeMesh.geometry, planeMesh.material, 0, null );
</P><P>			}
</P><P>		}
</P><P>		function setClear( color, alpha ) {
</P><P>			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );
</P><P>		}
</P><P>		return {
</P><P>			getClearColor: function () {
</P><P>				return clearColor;
</P><P>			},
			setClearColor: function ( color, alpha ) {
</P><P>				clearColor.set( color );
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear( clearColor, clearAlpha );
</P><P>			},
			getClearAlpha: function () {
</P><P>				return clearAlpha;
</P><P>			},
			setClearAlpha: function ( alpha ) {
</P><P>				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );
</P><P>			},
			render: render
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {
</P><P>		var mode;
</P><P>		function setMode( value ) {
</P><P>			mode = value;
</P><P>		}
</P><P>		function render( start, count ) {
</P><P>			gl.drawArrays( mode, start, count );
</P><P>			info.update( count, mode );
</P><P>		}
</P><P>		function renderInstances( geometry, start, count ) {
</P><P>			var extension;
</P><P>			if ( capabilities.isWebGL2 ) {
</P><P>				extension = gl;
</P><P>			} else {
</P><P>				extension = extensions.get( 'ANGLE_instanced_arrays' );
</P><P>				if ( extension === null ) {
</P><P>					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
</P><P>				}
</P><P>			}
</P><P>			extension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );
</P><P>			info.update( count, mode, geometry.maxInstancedCount );
</P><P>		}
</P><P>		//
</P><P>		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLCapabilities( gl, extensions, parameters ) {
</P><P>		var maxAnisotropy;
</P><P>		function getMaxAnisotropy() {
</P><P>			if ( maxAnisotropy !== undefined ) return maxAnisotropy;
</P><P>			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
</P><P>			if ( extension !== null ) {
</P><P>				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
</P><P>			} else {
</P><P>				maxAnisotropy = 0;
</P><P>			}
</P><P>			return maxAnisotropy;
</P><P>		}
</P><P>		function getMaxPrecision( precision ) {
</P><P>			if ( precision === 'highp' ) {
</P><P>				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision &gt; 0 &amp;&amp;
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision &gt; 0 ) {
</P><P>					return 'highp';
</P><P>				}
</P><P>				precision = 'mediump';
</P><P>			}
</P><P>			if ( precision === 'mediump' ) {
</P><P>				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision &gt; 0 &amp;&amp;
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision &gt; 0 ) {
</P><P>					return 'mediump';
</P><P>				}
</P><P>			}
</P><P>			return 'lowp';
</P><P>		}
</P><P>		var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' &amp;&amp; gl instanceof WebGL2RenderingContext;
</P><P>		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );
</P><P>		if ( maxPrecision !== precision ) {
</P><P>			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;
</P><P>		}
</P><P>		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
</P><P>		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
</P><P>		var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
</P><P>		var vertexTextures = maxVertexTextures &gt; 0;
		var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures &amp;&amp; floatFragmentTextures;
</P><P>		return {
</P><P>			isWebGL2: isWebGL2,
</P><P>			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,
</P><P>			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
</P><P>			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,
</P><P>			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,
</P><P>			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author tschw
	 */
</P><P>	function WebGLClipping() {
</P><P>		var scope = this,
</P><P>			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,
</P><P>			plane = new Plane(),
			viewNormalMatrix = new Matrix3(),
</P><P>			uniform = { value: null, needsUpdate: false };
</P><P>		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;
</P><P>		this.init = function ( planes, enableLocalClipping, camera ) {
</P><P>			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;
</P><P>			localClippingEnabled = enableLocalClipping;
</P><P>			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;
</P><P>			return enabled;
</P><P>		};
</P><P>		this.beginShadows = function () {
</P><P>			renderingShadows = true;
			projectPlanes( null );
</P><P>		};
</P><P>		this.endShadows = function () {
</P><P>			renderingShadows = false;
			resetGlobalState();
</P><P>		};
</P><P>		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {
</P><P>			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows &amp;&amp; ! clipShadows ) {
</P><P>				// there's no local clipping
</P><P>				if ( renderingShadows ) {
</P><P>					// there's no global clipping
</P><P>					projectPlanes( null );
</P><P>				} else {
</P><P>					resetGlobalState();
</P><P>				}
</P><P>			} else {
</P><P>				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,
</P><P>					dstArray = cache.clippingState || null;
</P><P>				uniform.value = dstArray; // ensure unique state
</P><P>				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );
</P><P>				for ( var i = 0; i !== lGlobal; ++ i ) {
</P><P>					dstArray[ i ] = globalState[ i ];
</P><P>				}
</P><P>				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
</P><P>			}
</P><P>
		};
</P><P>		function resetGlobalState() {
</P><P>			if ( uniform.value !== globalState ) {
</P><P>				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes &gt; 0;
</P><P>			}
</P><P>			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
</P><P>		}
</P><P>		function projectPlanes( planes, camera, dstOffset, skipTransform ) {
</P><P>			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;
</P><P>			if ( nPlanes !== 0 ) {
</P><P>				dstArray = uniform.value;
</P><P>				if ( skipTransform !== true || dstArray === null ) {
</P><P>					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;
</P><P>					viewNormalMatrix.getNormalMatrix( viewMatrix );
</P><P>					if ( dstArray === null || dstArray.length &lt; flatSize ) {
</P><P>						dstArray = new Float32Array( flatSize );
</P><P>					}
</P><P>					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {
</P><P>						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );
</P><P>						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;
</P><P>					}
</P><P>				}
</P><P>				uniform.value = dstArray;
				uniform.needsUpdate = true;
</P><P>			}
</P><P>			scope.numPlanes = nPlanes;
</P><P>			return dstArray;
</P><P>		}
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLExtensions( gl ) {
</P><P>		var extensions = {};
</P><P>		return {
</P><P>			get: function ( name ) {
</P><P>				if ( extensions[ name ] !== undefined ) {
</P><P>					return extensions[ name ];
</P><P>				}
</P><P>				var extension;
</P><P>				switch ( name ) {
</P><P>					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;
</P><P>					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;
</P><P>					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;
</P><P>					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;
</P><P>					default:
						extension = gl.getExtension( name );
</P><P>				}
</P><P>				if ( extension === null ) {
</P><P>					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
</P><P>				}
</P><P>				extensions[ name ] = extension;
</P><P>				return extension;
</P><P>			}
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLGeometries( gl, attributes, info ) {
</P><P>		var geometries = {};
		var wireframeAttributes = {};
</P><P>		function onGeometryDispose( event ) {
</P><P>			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];
</P><P>			if ( buffergeometry.index !== null ) {
</P><P>				attributes.remove( buffergeometry.index );
</P><P>			}
</P><P>			for ( var name in buffergeometry.attributes ) {
</P><P>				attributes.remove( buffergeometry.attributes[ name ] );
</P><P>			}
</P><P>			geometry.removeEventListener( 'dispose', onGeometryDispose );
</P><P>			delete geometries[ geometry.id ];
</P><P>			var attribute = wireframeAttributes[ buffergeometry.id ];
</P><P>			if ( attribute ) {
</P><P>				attributes.remove( attribute );
				delete wireframeAttributes[ buffergeometry.id ];
</P><P>			}
</P><P>			//
</P><P>			info.memory.geometries --;
</P><P>		}
</P><P>		function get( object, geometry ) {
</P><P>			var buffergeometry = geometries[ geometry.id ];
</P><P>			if ( buffergeometry ) return buffergeometry;
</P><P>			geometry.addEventListener( 'dispose', onGeometryDispose );
</P><P>			if ( geometry.isBufferGeometry ) {
</P><P>				buffergeometry = geometry;
</P><P>			} else if ( geometry.isGeometry ) {
</P><P>				if ( geometry._bufferGeometry === undefined ) {
</P><P>					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );
</P><P>				}
</P><P>				buffergeometry = geometry._bufferGeometry;
</P><P>			}
</P><P>			geometries[ geometry.id ] = buffergeometry;
</P><P>			info.memory.geometries ++;
</P><P>			return buffergeometry;
</P><P>		}
</P><P>		function update( geometry ) {
</P><P>			var index = geometry.index;
			var geometryAttributes = geometry.attributes;
</P><P>			if ( index !== null ) {
</P><P>				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );
</P><P>			}
</P><P>			for ( var name in geometryAttributes ) {
</P><P>				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );
</P><P>			}
</P><P>			// morph targets
</P><P>			var morphAttributes = geometry.morphAttributes;
</P><P>			for ( var name in morphAttributes ) {
</P><P>				var array = morphAttributes[ name ];
</P><P>				for ( var i = 0, l = array.length; i &lt; l; i ++ ) {
</P><P>					attributes.update( array[ i ], gl.ARRAY_BUFFER );
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		function getWireframeAttribute( geometry ) {
</P><P>			var attribute = wireframeAttributes[ geometry.id ];
</P><P>			if ( attribute ) return attribute;
</P><P>			var indices = [];
</P><P>			var geometryIndex = geometry.index;
			var geometryAttributes = geometry.attributes;
</P><P>			// console.time( 'wireframe' );
</P><P>			if ( geometryIndex !== null ) {
</P><P>				var array = geometryIndex.array;
</P><P>				for ( var i = 0, l = array.length; i &lt; l; i += 3 ) {
</P><P>					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];
</P><P>					indices.push( a, b, b, c, c, a );
</P><P>				}
</P><P>			} else {
</P><P>				var array = geometryAttributes.position.array;
</P><P>				for ( var i = 0, l = ( array.length / 3 ) - 1; i &lt; l; i += 3 ) {
</P><P>					var a = i + 0;
					var b = i + 1;
					var c = i + 2;
</P><P>					indices.push( a, b, b, c, c, a );
</P><P>				}
</P><P>			}
</P><P>			// console.timeEnd( 'wireframe' );
</P><P>			attribute = new ( arrayMax( indices ) &gt; 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
</P><P>			attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );
</P><P>			wireframeAttributes[ geometry.id ] = attribute;
</P><P>			return attribute;
</P><P>		}
</P><P>		return {
</P><P>			get: get,
			update: update,
</P><P>			getWireframeAttribute: getWireframeAttribute
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {
</P><P>		var mode;
</P><P>		function setMode( value ) {
</P><P>			mode = value;
</P><P>		}
</P><P>		var type, bytesPerElement;
</P><P>		function setIndex( value ) {
</P><P>			type = value.type;
			bytesPerElement = value.bytesPerElement;
</P><P>		}
</P><P>		function render( start, count ) {
</P><P>			gl.drawElements( mode, count, type, start * bytesPerElement );
</P><P>			info.update( count, mode );
</P><P>		}
</P><P>		function renderInstances( geometry, start, count ) {
</P><P>			var extension;
</P><P>			if ( capabilities.isWebGL2 ) {
</P><P>				extension = gl;
</P><P>			} else {
</P><P>				var extension = extensions.get( 'ANGLE_instanced_arrays' );
</P><P>				if ( extension === null ) {
</P><P>					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
</P><P>				}
</P><P>			}
</P><P>			extension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );
</P><P>			info.update( count, mode, geometry.maxInstancedCount );
</P><P>		}
</P><P>		//
</P><P>		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
</P><P>	}
</P><P>	/**
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	function WebGLInfo( gl ) {
</P><P>		var memory = {
			geometries: 0,
			textures: 0
		};
</P><P>		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};
</P><P>		function update( count, mode, instanceCount ) {
</P><P>			instanceCount = instanceCount || 1;
</P><P>			render.calls ++;
</P><P>			switch ( mode ) {
</P><P>				case gl.TRIANGLES:
					render.triangles += instanceCount * ( count / 3 );
					break;
</P><P>				case gl.TRIANGLE_STRIP:
				case gl.TRIANGLE_FAN:
					render.triangles += instanceCount * ( count - 2 );
					break;
</P><P>				case gl.LINES:
					render.lines += instanceCount * ( count / 2 );
					break;
</P><P>				case gl.LINE_STRIP:
					render.lines += instanceCount * ( count - 1 );
					break;
</P><P>				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;
</P><P>				case gl.POINTS:
					render.points += instanceCount * count;
					break;
</P><P>				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;
</P><P>			}
</P><P>		}
</P><P>		function reset() {
</P><P>			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
</P><P>		}
</P><P>		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function absNumericalSort( a, b ) {
</P><P>		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );
</P><P>	}
</P><P>	function WebGLMorphtargets( gl ) {
</P><P>		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );
</P><P>		function update( object, geometry, material, program ) {
</P><P>			var objectInfluences = object.morphTargetInfluences;
</P><P>			var length = objectInfluences.length;
</P><P>			var influences = influencesList[ geometry.id ];
</P><P>			if ( influences === undefined ) {
</P><P>				// initialise list
</P><P>				influences = [];
</P><P>				for ( var i = 0; i &lt; length; i ++ ) {
</P><P>					influences[ i ] = [ i, 0 ];
</P><P>				}
</P><P>				influencesList[ geometry.id ] = influences;
</P><P>			}
</P><P>			var morphTargets = material.morphTargets &amp;&amp; geometry.morphAttributes.position;
			var morphNormals = material.morphNormals &amp;&amp; geometry.morphAttributes.normal;
</P><P>			// Remove current morphAttributes
</P><P>			for ( var i = 0; i &lt; length; i ++ ) {
</P><P>				var influence = influences[ i ];
</P><P>				if ( influence[ 1 ] !== 0 ) {
</P><P>					if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
					if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );
</P><P>				}
</P><P>			}
</P><P>			// Collect influences
</P><P>			for ( var i = 0; i &lt; length; i ++ ) {
</P><P>				var influence = influences[ i ];
</P><P>				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];
</P><P>			}
</P><P>			influences.sort( absNumericalSort );
</P><P>			// Add morphAttributes
</P><P>			for ( var i = 0; i &lt; 8; i ++ ) {
</P><P>				var influence = influences[ i ];
</P><P>				if ( influence ) {
</P><P>					var index = influence[ 0 ];
					var value = influence[ 1 ];
</P><P>					if ( value ) {
</P><P>						if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
						if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );
</P><P>						morphInfluences[ i ] = value;
						continue;
</P><P>					}
</P><P>				}
</P><P>				morphInfluences[ i ] = 0;
</P><P>			}
</P><P>			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );
</P><P>		}
</P><P>		return {
</P><P>			update: update
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLObjects( geometries, info ) {
</P><P>		var updateList = {};
</P><P>		function update( object ) {
</P><P>			var frame = info.render.frame;
</P><P>			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );
</P><P>			// Update once per frame
</P><P>			if ( updateList[ buffergeometry.id ] !== frame ) {
</P><P>				if ( geometry.isGeometry ) {
</P><P>					buffergeometry.updateFromObject( object );
</P><P>				}
</P><P>				geometries.update( buffergeometry );
</P><P>				updateList[ buffergeometry.id ] = frame;
</P><P>			}
</P><P>			return buffergeometry;
</P><P>		}
</P><P>		function dispose() {
</P><P>			updateList = {};
</P><P>		}
</P><P>		return {
</P><P>			update: update,
			dispose: dispose
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
</P><P>		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
</P><P>		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
</P><P>		this.flipY = false;
</P><P>	}
</P><P>	CubeTexture.prototype = Object.create( Texture.prototype );
	CubeTexture.prototype.constructor = CubeTexture;
</P><P>	CubeTexture.prototype.isCubeTexture = true;
</P><P>	Object.defineProperty( CubeTexture.prototype, 'images', {
</P><P>		get: function () {
</P><P>			return this.image;
</P><P>		},
</P><P>		set: function ( value ) {
</P><P>			this.image = value;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author Artur Trzesiok
	 */
</P><P>	function DataTexture3D( data, width, height, depth ) {
</P><P>		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	var texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839
</P><P>		Texture.call( this, null );
</P><P>		this.image = { data: data, width: width, height: height, depth: depth };
</P><P>		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;
</P><P>		this.generateMipmaps = false;
		this.flipY = false;
</P><P>	}
</P><P>	DataTexture3D.prototype = Object.create( Texture.prototype );
	DataTexture3D.prototype.constructor = DataTexture3D;
	DataTexture3D.prototype.isDataTexture3D = true;
</P><P>	/**
	 * @author tschw
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */
</P><P>	var emptyTexture = new Texture();
	var emptyTexture3d = new DataTexture3D();
	var emptyCubeTexture = new CubeTexture();
</P><P>	// --- Base for inner nodes (including the root) ---
</P><P>	function UniformContainer() {
</P><P>		this.seq = [];
		this.map = {};
</P><P>	}
</P><P>	// --- Utilities ---
</P><P>	// Array Caches (provide typed arrays for temporary by size)
</P><P>	var arrayCacheF32 = [];
	var arrayCacheI32 = [];
</P><P>	// Float32Array caches used for uploading Matrix uniforms
</P><P>	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );
	var mat2array = new Float32Array( 4 );
</P><P>	// Flattening for arrays of vectors and matrices
</P><P>	function flatten( array, nBlocks, blockSize ) {
</P><P>		var firstElem = array[ 0 ];
</P><P>		if ( firstElem &lt;= 0 || firstElem &gt; 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see <A rel="nofollow" class="external free" href="http://jacksondunstan.com/articles/983">http://jacksondunstan.com/articles/983</A></P><P>		var n = nBlocks * blockSize,
			r = arrayCacheF32[ n ];
</P><P>		if ( r === undefined ) {
</P><P>			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;
</P><P>		}
</P><P>		if ( nBlocks !== 0 ) {
</P><P>			firstElem.toArray( r, 0 );
</P><P>			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {
</P><P>				offset += blockSize;
				array[ i ].toArray( r, offset );
</P><P>			}
</P><P>		}
</P><P>		return r;
</P><P>	}
</P><P>	function arraysEqual( a, b ) {
</P><P>		if ( a.length !== b.length ) return false;
</P><P>		for ( var i = 0, l = a.length; i &lt; l; i ++ ) {
</P><P>			if ( a[ i ] !== b[ i ] ) return false;
</P><P>		}
</P><P>		return true;
</P><P>	}
</P><P>	function copyArray( a, b ) {
</P><P>		for ( var i = 0, l = b.length; i &lt; l; i ++ ) {
</P><P>			a[ i ] = b[ i ];
</P><P>		}
</P><P>	}
</P><P>	// Texture unit allocation
</P><P>	function allocTexUnits( renderer, n ) {
</P><P>		var r = arrayCacheI32[ n ];
</P><P>		if ( r === undefined ) {
</P><P>			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;
</P><P>		}
</P><P>		for ( var i = 0; i !== n; ++ i )
			r[ i ] = renderer.allocTextureUnit();
</P><P>		return r;
</P><P>	}
</P><P>	// --- Setters ---
</P><P>	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
</P><P>	// Single scalar
</P><P>	function setValue1f( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( cache[ 0 ] === v ) return;
</P><P>		gl.uniform1f( this.addr, v );
</P><P>		cache[ 0 ] = v;
</P><P>	}
</P><P>	function setValue1i( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( cache[ 0 ] === v ) return;
</P><P>		gl.uniform1i( this.addr, v );
</P><P>		cache[ 0 ] = v;
</P><P>	}
</P><P>	// Single float vector (from flat array or THREE.VectorN)
</P><P>	function setValue2fv( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( v.x !== undefined ) {
</P><P>			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {
</P><P>				gl.uniform2f( this.addr, v.x, v.y );
</P><P>				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
</P><P>			}
</P><P>		} else {
</P><P>			if ( arraysEqual( cache, v ) ) return;
</P><P>			gl.uniform2fv( this.addr, v );
</P><P>			copyArray( cache, v );
</P><P>		}
</P><P>	}
</P><P>	function setValue3fv( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( v.x !== undefined ) {
</P><P>			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {
</P><P>				gl.uniform3f( this.addr, v.x, v.y, v.z );
</P><P>				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
</P><P>			}
</P><P>		} else if ( v.r !== undefined ) {
</P><P>			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {
</P><P>				gl.uniform3f( this.addr, v.r, v.g, v.b );
</P><P>				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;
</P><P>			}
</P><P>		} else {
</P><P>			if ( arraysEqual( cache, v ) ) return;
</P><P>			gl.uniform3fv( this.addr, v );
</P><P>			copyArray( cache, v );
</P><P>		}
</P><P>	}
</P><P>	function setValue4fv( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( v.x !== undefined ) {
</P><P>			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {
</P><P>				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
</P><P>				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;
</P><P>			}
</P><P>		} else {
</P><P>			if ( arraysEqual( cache, v ) ) return;
</P><P>			gl.uniform4fv( this.addr, v );
</P><P>			copyArray( cache, v );
</P><P>		}
</P><P>	}
</P><P>	// Single matrix (from flat array or MatrixN)
</P><P>	function setValue2fm( gl, v ) {
</P><P>		var cache = this.cache;
		var elements = v.elements;
</P><P>		if ( elements === undefined ) {
</P><P>			if ( arraysEqual( cache, v ) ) return;
</P><P>			gl.uniformMatrix2fv( this.addr, false, v );
</P><P>			copyArray( cache, v );
</P><P>		} else {
</P><P>			if ( arraysEqual( cache, elements ) ) return;
</P><P>			mat2array.set( elements );
</P><P>			gl.uniformMatrix2fv( this.addr, false, mat2array );
</P><P>			copyArray( cache, elements );
</P><P>		}
</P><P>	}
</P><P>	function setValue3fm( gl, v ) {
</P><P>		var cache = this.cache;
		var elements = v.elements;
</P><P>		if ( elements === undefined ) {
</P><P>			if ( arraysEqual( cache, v ) ) return;
</P><P>			gl.uniformMatrix3fv( this.addr, false, v );
</P><P>			copyArray( cache, v );
</P><P>		} else {
</P><P>			if ( arraysEqual( cache, elements ) ) return;
</P><P>			mat3array.set( elements );
</P><P>			gl.uniformMatrix3fv( this.addr, false, mat3array );
</P><P>			copyArray( cache, elements );
</P><P>		}
</P><P>	}
</P><P>	function setValue4fm( gl, v ) {
</P><P>		var cache = this.cache;
		var elements = v.elements;
</P><P>		if ( elements === undefined ) {
</P><P>			if ( arraysEqual( cache, v ) ) return;
</P><P>			gl.uniformMatrix4fv( this.addr, false, v );
</P><P>			copyArray( cache, v );
</P><P>		} else {
</P><P>			if ( arraysEqual( cache, elements ) ) return;
</P><P>			mat4array.set( elements );
</P><P>			gl.uniformMatrix4fv( this.addr, false, mat4array );
</P><P>			copyArray( cache, elements );
</P><P>		}
</P><P>	}
</P><P>	// Single texture (2D / Cube)
</P><P>	function setValueT1( gl, v, renderer ) {
</P><P>		var cache = this.cache;
		var unit = renderer.allocTextureUnit();
</P><P>		if ( cache[ 0 ] !== unit ) {
</P><P>			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;
</P><P>		}
</P><P>		renderer.setTexture2D( v || emptyTexture, unit );
</P><P>	}
</P><P>	function setValueT3D1( gl, v, renderer ) {
</P><P>		var cache = this.cache;
		var unit = renderer.allocTextureUnit();
</P><P>		if ( cache[ 0 ] !== unit ) {
</P><P>			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;
</P><P>		}
</P><P>		renderer.setTexture3D( v || emptyTexture3d, unit );
</P><P>	}
</P><P>	function setValueT6( gl, v, renderer ) {
</P><P>		var cache = this.cache;
		var unit = renderer.allocTextureUnit();
</P><P>		if ( cache[ 0 ] !== unit ) {
</P><P>			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;
</P><P>		}
</P><P>		renderer.setTextureCube( v || emptyCubeTexture, unit );
</P><P>	}
</P><P>	// Integer / Boolean vectors or arrays thereof (always flat arrays)
</P><P>	function setValue2iv( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( arraysEqual( cache, v ) ) return;
</P><P>		gl.uniform2iv( this.addr, v );
</P><P>		copyArray( cache, v );
</P><P>	}
</P><P>	function setValue3iv( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( arraysEqual( cache, v ) ) return;
</P><P>		gl.uniform3iv( this.addr, v );
</P><P>		copyArray( cache, v );
</P><P>	}
</P><P>	function setValue4iv( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( arraysEqual( cache, v ) ) return;
</P><P>		gl.uniform4iv( this.addr, v );
</P><P>		copyArray( cache, v );
</P><P>	}
</P><P>	// Helper to pick the right setter for the singular case
</P><P>	function getSingularSetter( type ) {
</P><P>		switch ( type ) {
</P><P>			case 0x1406: return setValue1f; // FLOAT
			case 0x8b50: return setValue2fv; // _VEC2
			case 0x8b51: return setValue3fv; // _VEC3
			case 0x8b52: return setValue4fv; // _VEC4
</P><P>			case 0x8b5a: return setValue2fm; // _MAT2
			case 0x8b5b: return setValue3fm; // _MAT3
			case 0x8b5c: return setValue4fm; // _MAT4
</P><P>			case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
			case 0x8B5F: return setValueT3D1; // SAMPLER_3D
			case 0x8b60: return setValueT6; // SAMPLER_CUBE
</P><P>			case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
</P><P>		}
</P><P>	}
</P><P>	// Array of scalars
</P><P>	function setValue1fv( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( arraysEqual( cache, v ) ) return;
</P><P>		gl.uniform1fv( this.addr, v );
</P><P>		copyArray( cache, v );
</P><P>	}
	function setValue1iv( gl, v ) {
</P><P>		var cache = this.cache;
</P><P>		if ( arraysEqual( cache, v ) ) return;
</P><P>		gl.uniform1iv( this.addr, v );
</P><P>		copyArray( cache, v );
</P><P>	}
</P><P>	// Array of vectors (flat or from THREE classes)
</P><P>	function setValueV2a( gl, v ) {
</P><P>		var cache = this.cache;
		var data = flatten( v, this.size, 2 );
</P><P>		if ( arraysEqual( cache, data ) ) return;
</P><P>		gl.uniform2fv( this.addr, data );
</P><P>		this.updateCache( data );
</P><P>	}
</P><P>	function setValueV3a( gl, v ) {
</P><P>		var cache = this.cache;
		var data = flatten( v, this.size, 3 );
</P><P>		if ( arraysEqual( cache, data ) ) return;
</P><P>		gl.uniform3fv( this.addr, data );
</P><P>		this.updateCache( data );
</P><P>	}
</P><P>	function setValueV4a( gl, v ) {
</P><P>		var cache = this.cache;
		var data = flatten( v, this.size, 4 );
</P><P>		if ( arraysEqual( cache, data ) ) return;
</P><P>		gl.uniform4fv( this.addr, data );
</P><P>		this.updateCache( data );
</P><P>	}
</P><P>	// Array of matrices (flat or from THREE clases)
</P><P>	function setValueM2a( gl, v ) {
</P><P>		var cache = this.cache;
		var data = flatten( v, this.size, 4 );
</P><P>		if ( arraysEqual( cache, data ) ) return;
</P><P>		gl.uniformMatrix2fv( this.addr, false, data );
</P><P>		this.updateCache( data );
</P><P>	}
</P><P>	function setValueM3a( gl, v ) {
</P><P>		var cache = this.cache;
		var data = flatten( v, this.size, 9 );
</P><P>		if ( arraysEqual( cache, data ) ) return;
</P><P>		gl.uniformMatrix3fv( this.addr, false, data );
</P><P>		this.updateCache( data );
</P><P>	}
</P><P>	function setValueM4a( gl, v ) {
</P><P>		var cache = this.cache;
		var data = flatten( v, this.size, 16 );
</P><P>		if ( arraysEqual( cache, data ) ) return;
</P><P>		gl.uniformMatrix4fv( this.addr, false, data );
</P><P>		this.updateCache( data );
</P><P>	}
</P><P>	// Array of textures (2D / Cube)
</P><P>	function setValueT1a( gl, v, renderer ) {
</P><P>		var cache = this.cache;
		var n = v.length;
</P><P>		var units = allocTexUnits( renderer, n );
</P><P>		if ( arraysEqual( cache, units ) === false ) {
</P><P>			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );
</P><P>		}
</P><P>		for ( var i = 0; i !== n; ++ i ) {
</P><P>			renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );
</P><P>		}
</P><P>	}
</P><P>	function setValueT6a( gl, v, renderer ) {
</P><P>		var cache = this.cache;
		var n = v.length;
</P><P>		var units = allocTexUnits( renderer, n );
</P><P>		if ( arraysEqual( cache, units ) === false ) {
</P><P>			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );
</P><P>		}
</P><P>		for ( var i = 0; i !== n; ++ i ) {
</P><P>			renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );
</P><P>		}
</P><P>	}
</P><P>	// Helper to pick the right setter for a pure (bottom-level) array
</P><P>	function getPureArraySetter( type ) {
</P><P>		switch ( type ) {
</P><P>			case 0x1406: return setValue1fv; // FLOAT
			case 0x8b50: return setValueV2a; // _VEC2
			case 0x8b51: return setValueV3a; // _VEC3
			case 0x8b52: return setValueV4a; // _VEC4
</P><P>			case 0x8b5a: return setValueM2a; // _MAT2
			case 0x8b5b: return setValueM3a; // _MAT3
			case 0x8b5c: return setValueM4a; // _MAT4
</P><P>			case 0x8b5e: return setValueT1a; // SAMPLER_2D
			case 0x8b60: return setValueT6a; // SAMPLER_CUBE
</P><P>			case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
</P><P>		}
</P><P>	}
</P><P>	// --- Uniform Classes ---
</P><P>	function SingleUniform( id, activeInfo, addr ) {
</P><P>		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );
</P><P>		// this.path = activeInfo.name; // DEBUG
</P><P>	}
</P><P>	function PureArrayUniform( id, activeInfo, addr ) {
</P><P>		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );
</P><P>		// this.path = activeInfo.name; // DEBUG
</P><P>	}
</P><P>	PureArrayUniform.prototype.updateCache = function ( data ) {
</P><P>		var cache = this.cache;
</P><P>		if ( data instanceof Float32Array &amp;&amp; cache.length !== data.length ) {
</P><P>			this.cache = new Float32Array( data.length );
</P><P>		}
</P><P>		copyArray( cache, data );
</P><P>	};
</P><P>	function StructuredUniform( id ) {
</P><P>		this.id = id;
</P><P>		UniformContainer.call( this ); // mix-in
</P><P>	}
</P><P>	StructuredUniform.prototype.setValue = function ( gl, value, renderer ) {
</P><P>		var seq = this.seq;
</P><P>		for ( var i = 0, n = seq.length; i !== n; ++ i ) {
</P><P>			var u = seq[ i ];
			u.setValue( gl, value[ u.id ], renderer );
</P><P>		}
</P><P>	};
</P><P>	// --- Top-level ---
</P><P>	// Parser - builds up the property tree from the path strings
</P><P>	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
</P><P>	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.
</P><P>	function addUniform( container, uniformObject ) {
</P><P>		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;
</P><P>	}
</P><P>	function parseUniform( activeInfo, addr, container ) {
</P><P>		var path = activeInfo.name,
			pathLength = path.length;
</P><P>		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;
</P><P>		while ( true ) {
</P><P>			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex,
</P><P>				id = match[ 1 ],
				idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];
</P><P>			if ( idIsIndex ) id = id | 0; // convert to integer
</P><P>			if ( subscript === undefined || subscript === '[' &amp;&amp; matchEnd + 2 === pathLength ) {
</P><P>				// bare name or &quot;pure&quot; bottom-level array &quot;[0]&quot; suffix
</P><P>				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );
</P><P>				break;
</P><P>			} else {
</P><P>				// step into inner node / create it in case it doesn't exist
</P><P>				var map = container.map, next = map[ id ];
</P><P>				if ( next === undefined ) {
</P><P>					next = new StructuredUniform( id );
					addUniform( container, next );
</P><P>				}
</P><P>				container = next;
</P><P>			}
</P><P>		}
</P><P>	}
</P><P>	// Root Container
</P><P>	function WebGLUniforms( gl, program, renderer ) {
</P><P>		UniformContainer.call( this );
</P><P>		this.renderer = renderer;
</P><P>		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
</P><P>		for ( var i = 0; i &lt; n; ++ i ) {
</P><P>			var info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );
</P><P>			parseUniform( info, addr, this );
</P><P>		}
</P><P>	}
</P><P>	WebGLUniforms.prototype.setValue = function ( gl, name, value ) {
</P><P>		var u = this.map[ name ];
</P><P>		if ( u !== undefined ) u.setValue( gl, value, this.renderer );
</P><P>	};
</P><P>	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {
</P><P>	var v = object[ name ];
</P><P>		if ( v !== undefined ) this.setValue( gl, name, v );
</P><P>	};
</P><P>
	// Static interface
</P><P>	WebGLUniforms.upload = function ( gl, seq, values, renderer ) {
</P><P>		for ( var i = 0, n = seq.length; i !== n; ++ i ) {
</P><P>			var u = seq[ i ],
				v = values[ u.id ];
</P><P>			if ( v.needsUpdate !== false ) {
</P><P>				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, renderer );
</P><P>			}
</P><P>		}
</P><P>	};
</P><P>	WebGLUniforms.seqWithValue = function ( seq, values ) {
</P><P>		var r = [];
</P><P>		for ( var i = 0, n = seq.length; i !== n; ++ i ) {
</P><P>			var u = seq[ i ];
			if ( u.id in values ) r.push( u );
</P><P>		}
</P><P>		return r;
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function addLineNumbers( string ) {
</P><P>		var lines = string.split( '\n' );
</P><P>		for ( var i = 0; i &lt; lines.length; i ++ ) {
</P><P>			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
</P><P>		}
</P><P>		return lines.join( '\n' );
</P><P>	}
</P><P>	function WebGLShader( gl, type, string ) {
</P><P>		var shader = gl.createShader( type );
</P><P>		gl.shaderSource( shader, string );
		gl.compileShader( shader );
</P><P>		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
</P><P>			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
</P><P>		}
</P><P>		if ( gl.getShaderInfoLog( shader ) !== <I> ) {</I></P><P>			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
</P><P>		}
</P><P>		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
</P><P>		return shader;
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	var programIdCount = 0;
</P><P>	function getEncodingComponents( encoding ) {
</P><P>		switch ( encoding ) {
</P><P>			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );
</P><P>		}
</P><P>	}
</P><P>	function getTexelDecodingFunction( functionName, encoding ) {
</P><P>		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';
</P><P>	}
</P><P>	function getTexelEncodingFunction( functionName, encoding ) {
</P><P>		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';
</P><P>	}
</P><P>	function getToneMappingFunction( functionName, toneMapping ) {
</P><P>		var toneMappingName;
</P><P>		switch ( toneMapping ) {
</P><P>			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;
</P><P>			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;
</P><P>			case Uncharted2ToneMapping:
				toneMappingName = 'Uncharted2';
				break;
</P><P>			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;
</P><P>			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );
</P><P>		}
</P><P>		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
</P><P>	}
</P><P>	function generateExtensions( extensions, parameters, rendererExtensions ) {
</P><P>		extensions = extensions || {};
</P><P>		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap &amp;&amp; ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : <I>,</I>
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) &amp;&amp; rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : <I>,</I>
			( extensions.drawBuffers ) &amp;&amp; rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : <I>,</I>
			( extensions.shaderTextureLOD || parameters.envMap ) &amp;&amp; rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : 
		];
</P><P>		return chunks.filter( filterEmptyLine ).join( '\n' );
</P><P>	}
</P><P>	function generateDefines( defines ) {
</P><P>		var chunks = [];
</P><P>		for ( var name in defines ) {
</P><P>			var value = defines[ name ];
</P><P>			if ( value === false ) continue;
</P><P>			chunks.push( '#define ' + name + ' ' + value );
</P><P>		}
</P><P>		return chunks.join( '\n' );
</P><P>	}
</P><P>	function fetchAttributeLocations( gl, program ) {
</P><P>		var attributes = {};
</P><P>		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
</P><P>		for ( var i = 0; i &lt; n; i ++ ) {
</P><P>			var info = gl.getActiveAttrib( program, i );
			var name = info.name;
</P><P>			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
</P><P>			attributes[ name ] = gl.getAttribLocation( program, name );
</P><P>		}
</P><P>		return attributes;
</P><P>	}
</P><P>	function filterEmptyLine( string ) {
</P><P>		return string !== <I>;</I></P><P>	}
</P><P>	function replaceLightNums( string, parameters ) {
</P><P>		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
</P><P>	}
</P><P>	function replaceClippingPlaneNums( string, parameters ) {
</P><P>		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );
</P><P>	}
</P><P>	function parseIncludes( string ) {
</P><P>		var pattern = /^[ \t]*#include +&lt;([\w\d./]+)&gt;/gm;
</P><P>		function replace( match, include ) {
</P><P>			var replace = ShaderChunk[ include ];
</P><P>			if ( replace === undefined ) {
</P><P>				throw new Error( 'Can not resolve #include &lt;' + include + '&gt;' );
</P><P>			}
</P><P>			return parseIncludes( replace );
</P><P>		}
</P><P>		return string.replace( pattern, replace );
</P><P>	}
</P><P>	function unrollLoops( string ) {
</P><P>		var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i &lt; (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
</P><P>		function replace( match, start, end, snippet ) {
</P><P>			var unroll = <I>;</I></P><P>			for ( var i = parseInt( start ); i &lt; parseInt( end ); i ++ ) {
</P><P>				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
</P><P>			}
</P><P>			return unroll;
</P><P>		}
</P><P>		return string.replace( pattern, replace );
</P><P>	}
</P><P>	function WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities ) {
</P><P>		var gl = renderer.context;
</P><P>		var defines = material.defines;
</P><P>		var vertexShader = shader.vertexShader;
		var fragmentShader = shader.fragmentShader;
</P><P>		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
</P><P>		if ( parameters.shadowMapType === PCFShadowMap ) {
</P><P>			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
</P><P>		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {
</P><P>			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
</P><P>		}
</P><P>		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
</P><P>		if ( parameters.envMap ) {
</P><P>			switch ( material.envMap.mapping ) {
</P><P>				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;
</P><P>				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;
</P><P>				case EquirectangularReflectionMapping:
				case EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;
</P><P>				case SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;
</P><P>			}
</P><P>			switch ( material.envMap.mapping ) {
</P><P>				case CubeRefractionMapping:
				case EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;
</P><P>			}
</P><P>			switch ( material.combine ) {
</P><P>				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;
</P><P>				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;
</P><P>				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;
</P><P>			}
</P><P>		}
</P><P>		var gammaFactorDefine = ( renderer.gammaFactor &gt; 0 ) ? renderer.gammaFactor : 1.0;
</P><P>		// console.log( 'building new program ' );
</P><P>		//
</P><P>		var customExtensions = capabilities.isWebGL2 ? <I> : generateExtensions( material.extensions, parameters, extensions );</I></P><P>		var customDefines = generateDefines( defines );
</P><P>		//
</P><P>		var program = gl.createProgram();
</P><P>		var prefixVertex, prefixFragment;
</P><P>		if ( material.isRawShaderMaterial ) {
</P><P>			prefixVertex = [
</P><P>				customDefines
</P><P>			].filter( filterEmptyLine ).join( '\n' );
</P><P>			if ( prefixVertex.length &gt; 0 ) {
</P><P>				prefixVertex += '\n';
</P><P>			}
</P><P>			prefixFragment = [
</P><P>				customExtensions,
				customDefines
</P><P>			].filter( filterEmptyLine ).join( '\n' );
</P><P>			if ( prefixFragment.length &gt; 0 ) {
</P><P>				prefixFragment += '\n';
</P><P>			}
</P><P>		} else {
</P><P>			prefixVertex = [
</P><P>				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',
</P><P>				'#define SHADER_NAME ' + shader.name,
</P><P>				customDefines,
</P><P>				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : <I>,</I></P><P>				'#define GAMMA_FACTOR ' + gammaFactorDefine,
</P><P>				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog &amp;&amp; parameters.fog ) ? '#define USE_FOG' : <I>,</I>
				( parameters.useFog &amp;&amp; parameters.fogExp ) ? '#define FOG_EXP2' : <I>,</I></P><P>				parameters.map ? '#define USE_MAP' : <I>,</I>
				parameters.envMap ? '#define USE_ENVMAP' : <I>,</I>
				parameters.envMap ? '#define ' + envMapModeDefine : <I>,</I>
				parameters.lightMap ? '#define USE_LIGHTMAP' : <I>,</I>
				parameters.aoMap ? '#define USE_AOMAP' : <I>,</I>
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : <I>,</I>
				parameters.bumpMap ? '#define USE_BUMPMAP' : <I>,</I>
				parameters.normalMap ? '#define USE_NORMALMAP' : <I>,</I>
				( parameters.normalMap &amp;&amp; parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : <I>,</I>
				parameters.displacementMap &amp;&amp; parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : <I>,</I>
				parameters.specularMap ? '#define USE_SPECULARMAP' : <I>,</I>
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : <I>,</I>
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : <I>,</I>
				parameters.alphaMap ? '#define USE_ALPHAMAP' : <I>,</I>
				parameters.vertexColors ? '#define USE_COLOR' : <I>,</I></P><P>				parameters.flatShading ? '#define FLAT_SHADED' : <I>,</I></P><P>				parameters.skinning ? '#define USE_SKINNING' : <I>,</I>
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : <I>,</I></P><P>				parameters.morphTargets ? '#define USE_MORPHTARGETS' : <I>,</I>
				parameters.morphNormals &amp;&amp; parameters.flatShading === false ? '#define USE_MORPHNORMALS' : <I>,</I>
				parameters.doubleSided ? '#define DOUBLE_SIDED' : <I>,</I>
				parameters.flipSided ? '#define FLIP_SIDED' : <I>,</I></P><P>				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : <I>,</I>
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : <I>,</I></P><P>				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : <I>,</I></P><P>				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : <I>,</I>
				parameters.logarithmicDepthBuffer &amp;&amp; ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : <I>,</I></P><P>				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
</P><P>				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',
</P><P>				'#ifdef USE_COLOR',
</P><P>				'	attribute vec3 color;',
</P><P>				'#endif',
</P><P>				'#ifdef USE_MORPHTARGETS',
</P><P>				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',
</P><P>				'	#ifdef USE_MORPHNORMALS',
</P><P>				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',
</P><P>				'	#else',
</P><P>				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',
</P><P>				'	#endif',
</P><P>				'#endif',
</P><P>				'#ifdef USE_SKINNING',
</P><P>				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',
</P><P>				'#endif',
</P><P>				'\n'
</P><P>			].filter( filterEmptyLine ).join( '\n' );
</P><P>			prefixFragment = [
</P><P>				customExtensions,
</P><P>				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',
</P><P>				'#define SHADER_NAME ' + shader.name,
</P><P>				customDefines,
</P><P>				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? <I> : '.0' ) : </I>, // add '.0' if integer
</P><P>				'#define GAMMA_FACTOR ' + gammaFactorDefine,
</P><P>				( parameters.useFog &amp;&amp; parameters.fog ) ? '#define USE_FOG' : <I>,</I>
				( parameters.useFog &amp;&amp; parameters.fogExp ) ? '#define FOG_EXP2' : <I>,</I></P><P>				parameters.map ? '#define USE_MAP' : <I>,</I>
				parameters.envMap ? '#define USE_ENVMAP' : <I>,</I>
				parameters.envMap ? '#define ' + envMapTypeDefine : <I>,</I>
				parameters.envMap ? '#define ' + envMapModeDefine : <I>,</I>
				parameters.envMap ? '#define ' + envMapBlendingDefine : <I>,</I>
				parameters.lightMap ? '#define USE_LIGHTMAP' : <I>,</I>
				parameters.aoMap ? '#define USE_AOMAP' : <I>,</I>
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : <I>,</I>
				parameters.bumpMap ? '#define USE_BUMPMAP' : <I>,</I>
				parameters.normalMap ? '#define USE_NORMALMAP' : <I>,</I>
				( parameters.normalMap &amp;&amp; parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : <I>,</I>
				parameters.specularMap ? '#define USE_SPECULARMAP' : <I>,</I>
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : <I>,</I>
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : <I>,</I>
				parameters.alphaMap ? '#define USE_ALPHAMAP' : <I>,</I>
				parameters.vertexColors ? '#define USE_COLOR' : <I>,</I></P><P>				parameters.gradientMap ? '#define USE_GRADIENTMAP' : <I>,</I></P><P>				parameters.flatShading ? '#define FLAT_SHADED' : <I>,</I></P><P>				parameters.doubleSided ? '#define DOUBLE_SIDED' : <I>,</I>
				parameters.flipSided ? '#define FLIP_SIDED' : <I>,</I></P><P>				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : <I>,</I>
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : <I>,</I></P><P>				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : <I>,</I></P><P>				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : <I>,</I></P><P>				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : <I>,</I>
				parameters.logarithmicDepthBuffer &amp;&amp; ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : <I>,</I></P><P>				parameters.envMap &amp;&amp; ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : <I>,</I></P><P>				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
</P><P>				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : <I>,</I>
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : <I>, // this code is required here because it is used by the toneMapping() function defined below</I>
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : <I>,</I></P><P>				parameters.dithering ? '#define DITHERING' : <I>,</I></P><P>				( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?
					ShaderChunk[ 'encodings_pars_fragment' ] : <I>, // this code is required here because it is used by the various encoding/decoding function defined below</I>
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : <I>,</I>
				parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : <I>,</I>
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : <I>,</I>
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : <I>,</I>
				parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : <I>,</I></P><P>				parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : <I>,</I></P><P>				'\n'
</P><P>			].filter( filterEmptyLine ).join( '\n' );
</P><P>		}
</P><P>		vertexShader = parseIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );
</P><P>		fragmentShader = parseIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );
</P><P>		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );
</P><P>		if ( capabilities.isWebGL2 &amp;&amp; ! material.isRawShaderMaterial ) {
</P><P>			var isGLSL3ShaderMaterial = false;
</P><P>			var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
</P><P>			if ( material.isShaderMaterial &amp;&amp;
				vertexShader.match( versionRegex ) !== null &amp;&amp;
				fragmentShader.match( versionRegex ) !== null ) {
</P><P>				isGLSL3ShaderMaterial = true;
</P><P>				vertexShader = vertexShader.replace( versionRegex, <I> );</I>
				fragmentShader = fragmentShader.replace( versionRegex, <I> );</I></P><P>			}
</P><P>			// GLSL 3.0 conversion
			prefixVertex = [
				'#version 300 es\n',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;
</P><P>			prefixFragment = [
				'#version 300 es\n',
				'#define varying in',
				isGLSL3ShaderMaterial ? <I> : 'out highp vec4 pc_fragColor;',</I>
				isGLSL3ShaderMaterial ? <I> : '#define gl_FragColor pc_fragColor',</I>
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;
</P><P>		}
</P><P>		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;
</P><P>		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );
</P><P>		var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
</P><P>		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );
</P><P>		// Force a particular attribute to index 0.
</P><P>		if ( material.index0AttributeName !== undefined ) {
</P><P>			gl.bindAttribLocation( program, 0, material.index0AttributeName );
</P><P>		} else if ( parameters.morphTargets === true ) {
</P><P>			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );
</P><P>		}
</P><P>		gl.linkProgram( program );
</P><P>		var programLog = gl.getProgramInfoLog( program ).trim();
		var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();
</P><P>		var runnable = true;
		var haveDiagnostics = true;
</P><P>		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
</P><P>		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
</P><P>			runnable = false;
</P><P>			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
</P><P>		} else if ( programLog !== <I> ) {</I></P><P>			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
</P><P>		} else if ( vertexLog === <I> || fragmentLog === </I> ) {
</P><P>			haveDiagnostics = false;
</P><P>		}
</P><P>		if ( haveDiagnostics ) {
</P><P>			this.diagnostics = {
</P><P>				runnable: runnable,
				material: material,
</P><P>				programLog: programLog,
</P><P>				vertexShader: {
</P><P>					log: vertexLog,
					prefix: prefixVertex
</P><P>				},
</P><P>				fragmentShader: {
</P><P>					log: fragmentLog,
					prefix: prefixFragment
</P><P>				}
</P><P>			};
</P><P>		}
</P><P>		// clean up
</P><P>		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );
</P><P>		// set up caching for uniform locations
</P><P>		var cachedUniforms;
</P><P>		this.getUniforms = function () {
</P><P>			if ( cachedUniforms === undefined ) {
</P><P>				cachedUniforms = new WebGLUniforms( gl, program, renderer );
</P><P>			}
</P><P>			return cachedUniforms;
</P><P>		};
</P><P>		// set up caching for attribute locations
</P><P>		var cachedAttributes;
</P><P>		this.getAttributes = function () {
</P><P>			if ( cachedAttributes === undefined ) {
</P><P>				cachedAttributes = fetchAttributeLocations( gl, program );
</P><P>			}
</P><P>			return cachedAttributes;
</P><P>		};
</P><P>		// free resource
</P><P>		this.destroy = function () {
</P><P>			gl.deleteProgram( program );
			this.program = undefined;
</P><P>		};
</P><P>		// DEPRECATED
</P><P>		Object.defineProperties( this, {
</P><P>			uniforms: {
				get: function () {
</P><P>					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();
</P><P>				}
			},
</P><P>			attributes: {
				get: function () {
</P><P>					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();
</P><P>				}
			}
</P><P>		} );
</P><P>
		//
</P><P>		this.name = shader.name;
		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;
</P><P>		return this;
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLPrograms( renderer, extensions, capabilities ) {
</P><P>		var programs = [];
</P><P>		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};
</P><P>		var parameterNames = [
			&quot;precision&quot;, &quot;supportsVertexTextures&quot;, &quot;map&quot;, &quot;mapEncoding&quot;, &quot;matcapEncoding&quot;, &quot;envMap&quot;, &quot;envMapMode&quot;, &quot;envMapEncoding&quot;,
			&quot;lightMap&quot;, &quot;aoMap&quot;, &quot;emissiveMap&quot;, &quot;emissiveMapEncoding&quot;, &quot;bumpMap&quot;, &quot;normalMap&quot;, &quot;objectSpaceNormalMap&quot;, &quot;displacementMap&quot;, &quot;specularMap&quot;,
			&quot;roughnessMap&quot;, &quot;metalnessMap&quot;, &quot;gradientMap&quot;,
			&quot;alphaMap&quot;, &quot;combine&quot;, &quot;vertexColors&quot;, &quot;fog&quot;, &quot;useFog&quot;, &quot;fogExp&quot;,
			&quot;flatShading&quot;, &quot;sizeAttenuation&quot;, &quot;logarithmicDepthBuffer&quot;, &quot;skinning&quot;,
			&quot;maxBones&quot;, &quot;useVertexTexture&quot;, &quot;morphTargets&quot;, &quot;morphNormals&quot;,
			&quot;maxMorphTargets&quot;, &quot;maxMorphNormals&quot;, &quot;premultipliedAlpha&quot;,
			&quot;numDirLights&quot;, &quot;numPointLights&quot;, &quot;numSpotLights&quot;, &quot;numHemiLights&quot;, &quot;numRectAreaLights&quot;,
			&quot;shadowMapEnabled&quot;, &quot;shadowMapType&quot;, &quot;toneMapping&quot;, 'physicallyCorrectLights',
			&quot;alphaTest&quot;, &quot;doubleSided&quot;, &quot;flipSided&quot;, &quot;numClippingPlanes&quot;, &quot;numClipIntersection&quot;, &quot;depthPacking&quot;, &quot;dithering&quot;
		];
</P><P>
		function allocateBones( object ) {
</P><P>			var skeleton = object.skeleton;
			var bones = skeleton.bones;
</P><P>			if ( capabilities.floatVertexTextures ) {
</P><P>				return 1024;
</P><P>			} else {
</P><P>				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)
</P><P>				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
</P><P>				var maxBones = Math.min( nVertexMatrices, bones.length );
</P><P>				if ( maxBones &lt; bones.length ) {
</P><P>					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;
</P><P>				}
</P><P>				return maxBones;
</P><P>			}
</P><P>		}
</P><P>		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {
</P><P>			var encoding;
</P><P>			if ( ! map ) {
</P><P>				encoding = LinearEncoding;
</P><P>			} else if ( map.isTexture ) {
</P><P>				encoding = map.encoding;
</P><P>			} else if ( map.isWebGLRenderTarget ) {
</P><P>				console.warn( &quot;THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.&quot; );
				encoding = map.texture.encoding;
</P><P>			}
</P><P>			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if ( encoding === LinearEncoding &amp;&amp; gammaOverrideLinear ) {
</P><P>				encoding = GammaEncoding;
</P><P>			}
</P><P>			return encoding;
</P><P>		}
</P><P>		this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {
</P><P>			var shaderID = shaderIDs[ material.type ];
</P><P>			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
</P><P>			var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
			var precision = capabilities.precision;
</P><P>			if ( material.precision !== null ) {
</P><P>				precision = capabilities.getMaxPrecision( material.precision );
</P><P>				if ( precision !== material.precision ) {
</P><P>					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
</P><P>				}
</P><P>			}
</P><P>			var currentRenderTarget = renderer.getRenderTarget();
</P><P>			var parameters = {
</P><P>				shaderID: shaderID,
</P><P>				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
				matcap: !! material.matcap,
				matcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),
				envMap: !! material.envMap,
				envMapMode: material.envMap &amp;&amp; material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
				envMapCubeUV: ( !! material.envMap ) &amp;&amp; ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,
</P><P>				gradientMap: !! material.gradientMap,
</P><P>				combine: material.combine,
</P><P>				vertexColors: material.vertexColors,
</P><P>				fog: !! fog,
				useFog: material.fog,
				fogExp: ( fog &amp;&amp; fog.isFogExp2 ),
</P><P>				flatShading: material.flatShading,
</P><P>				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
</P><P>				skinning: material.skinning &amp;&amp; maxBones &gt; 0,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures,
</P><P>				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,
</P><P>				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
</P><P>				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,
</P><P>				dithering: material.dithering,
</P><P>				shadowMapEnabled: renderer.shadowMap.enabled &amp;&amp; object.receiveShadow &amp;&amp; shadows.length &gt; 0,
				shadowMapType: renderer.shadowMap.type,
</P><P>				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,
</P><P>				premultipliedAlpha: material.premultipliedAlpha,
</P><P>				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,
</P><P>				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false
</P><P>			};
</P><P>			return parameters;
</P><P>		};
</P><P>		this.getProgramCode = function ( material, parameters ) {
</P><P>			var array = [];
</P><P>			if ( parameters.shaderID ) {
</P><P>				array.push( parameters.shaderID );
</P><P>			} else {
</P><P>				array.push( material.fragmentShader );
				array.push( material.vertexShader );
</P><P>			}
</P><P>			if ( material.defines !== undefined ) {
</P><P>				for ( var name in material.defines ) {
</P><P>					array.push( name );
					array.push( material.defines[ name ] );
</P><P>				}
</P><P>			}
</P><P>			for ( var i = 0; i &lt; parameterNames.length; i ++ ) {
</P><P>				array.push( parameters[ parameterNames[ i ] ] );
</P><P>			}
</P><P>			array.push( material.onBeforeCompile.toString() );
</P><P>			array.push( renderer.gammaOutput );
</P><P>			return array.join();
</P><P>		};
</P><P>		this.acquireProgram = function ( material, shader, parameters, code ) {
</P><P>			var program;
</P><P>			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p &lt; pl; p ++ ) {
</P><P>				var programInfo = programs[ p ];
</P><P>				if ( programInfo.code === code ) {
</P><P>					program = programInfo;
					++ program.usedTimes;
</P><P>					break;
</P><P>				}
</P><P>			}
</P><P>			if ( program === undefined ) {
</P><P>				program = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities );
				programs.push( program );
</P><P>			}
</P><P>			return program;
</P><P>		};
</P><P>		this.releaseProgram = function ( program ) {
</P><P>			if ( -- program.usedTimes === 0 ) {
</P><P>				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();
</P><P>				// Free WebGL resources
				program.destroy();
</P><P>			}
</P><P>		};
</P><P>		// Exposed for resource monitoring &amp; error feedback via renderer.info:
		this.programs = programs;
</P><P>	}
</P><P>	/**
	 * @author fordacious / fordacious.github.io
	 */
</P><P>	function WebGLProperties() {
</P><P>		var properties = new WeakMap();
</P><P>		function get( object ) {
</P><P>			var map = properties.get( object );
</P><P>			if ( map === undefined ) {
</P><P>		map = {};
				properties.set( object, map );
</P><P>			}
</P><P>			return map;
</P><P>		}
</P><P>		function remove( object ) {
</P><P>			properties.delete( object );
</P><P>		}
</P><P>		function update( object, key, value ) {
</P><P>			properties.get( object )[ key ] = value;
</P><P>		}
</P><P>		function dispose() {
</P><P>			properties = new WeakMap();
</P><P>		}
</P><P>		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function painterSortStable( a, b ) {
</P><P>		if ( a.renderOrder !== b.renderOrder ) {
</P><P>			return a.renderOrder - b.renderOrder;
</P><P>		} else if ( a.program &amp;&amp; b.program &amp;&amp; a.program !== b.program ) {
</P><P>			return a.program.id - b.program.id;
</P><P>		} else if ( a.material.id !== b.material.id ) {
</P><P>			return a.material.id - b.material.id;
</P><P>		} else if ( a.z !== b.z ) {
</P><P>			return a.z - b.z;
</P><P>		} else {
</P><P>			return a.id - b.id;
</P><P>		}
</P><P>	}
</P><P>	function reversePainterSortStable( a, b ) {
</P><P>		if ( a.renderOrder !== b.renderOrder ) {
</P><P>			return a.renderOrder - b.renderOrder;
</P><P>		} if ( a.z !== b.z ) {
</P><P>			return b.z - a.z;
</P><P>		} else {
</P><P>			return a.id - b.id;
</P><P>		}
</P><P>	}
</P><P>
	function WebGLRenderList() {
</P><P>		var renderItems = [];
		var renderItemsIndex = 0;
</P><P>		var opaque = [];
		var transparent = [];
</P><P>		function init() {
</P><P>			renderItemsIndex = 0;
</P><P>			opaque.length = 0;
			transparent.length = 0;
</P><P>		}
</P><P>		function push( object, geometry, material, z, group ) {
</P><P>			var renderItem = renderItems[ renderItemsIndex ];
</P><P>			if ( renderItem === undefined ) {
</P><P>				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: material.program,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};
</P><P>				renderItems[ renderItemsIndex ] = renderItem;
</P><P>			} else {
</P><P>				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
</P><P>			}
</P><P>
			( material.transparent === true ? transparent : opaque ).push( renderItem );
</P><P>			renderItemsIndex ++;
</P><P>		}
</P><P>		function sort() {
</P><P>			if ( opaque.length &gt; 1 ) opaque.sort( painterSortStable );
			if ( transparent.length &gt; 1 ) transparent.sort( reversePainterSortStable );
</P><P>		}
</P><P>		return {
			opaque: opaque,
			transparent: transparent,
</P><P>			init: init,
			push: push,
</P><P>			sort: sort
		};
</P><P>	}
</P><P>	function WebGLRenderLists() {
</P><P>		var lists = {};
</P><P>		function get( scene, camera ) {
</P><P>			var hash = scene.id + ',' + camera.id;
			var list = lists[ hash ];
</P><P>			if ( list === undefined ) {
</P><P>				// console.log( 'THREE.WebGLRenderLists:', hash );
</P><P>				list = new WebGLRenderList();
				lists[ hash ] = list;
</P><P>			}
</P><P>			return list;
</P><P>		}
</P><P>		function dispose() {
</P><P>			lists = {};
</P><P>		}
</P><P>		return {
			get: get,
			dispose: dispose
		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function UniformsCache() {
</P><P>		var lights = {};
</P><P>		return {
</P><P>			get: function ( light ) {
</P><P>				if ( lights[ light.id ] !== undefined ) {
</P><P>					return lights[ light.id ];
</P><P>				}
</P><P>				var uniforms;
</P><P>				switch ( light.type ) {
</P><P>					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color(),
</P><P>							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;
</P><P>					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,
</P><P>							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;
</P><P>					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0,
</P><P>							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;
</P><P>					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;
</P><P>					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
							// TODO (abelnation): set RectAreaLight shadow uniforms
						};
						break;
</P><P>				}
</P><P>				lights[ light.id ] = uniforms;
</P><P>				return uniforms;
</P><P>			}
</P><P>		};
</P><P>	}
</P><P>	var count = 0;
</P><P>	function WebGLLights() {
</P><P>		var cache = new UniformsCache();
</P><P>		var state = {
</P><P>			id: count ++,
</P><P>			hash: {
				stateID: - 1,
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,
				shadowsLength: - 1
			},
</P><P>			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
</P><P>		};
</P><P>		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();
</P><P>		function setup( lights, shadows, camera ) {
</P><P>	var r = 0, g = 0, b = 0;
</P><P>			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;
</P><P>			var viewMatrix = camera.matrixWorldInverse;
</P><P>			for ( var i = 0, l = lights.length; i &lt; l; i ++ ) {
</P><P>				var light = lights[ i ];
</P><P>				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;
</P><P>				var shadowMap = ( light.shadow &amp;&amp; light.shadow.map ) ? light.shadow.map.texture : null;
</P><P>				if ( light.isAmbientLight ) {
</P><P>					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
</P><P>				} else if ( light.isDirectionalLight ) {
</P><P>					var uniforms = cache.get( light );
</P><P>					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );
</P><P>					uniforms.shadow = light.castShadow;
</P><P>					if ( light.castShadow ) {
</P><P>						var shadow = light.shadow;
</P><P>						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
</P><P>					}
</P><P>					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					state.directional[ directionalLength ] = uniforms;
</P><P>					directionalLength ++;
</P><P>				} else if ( light.isSpotLight ) {
</P><P>					var uniforms = cache.get( light );
</P><P>					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
</P><P>					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;
</P><P>					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );
</P><P>					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;
</P><P>					uniforms.shadow = light.castShadow;
</P><P>					if ( light.castShadow ) {
</P><P>						var shadow = light.shadow;
</P><P>						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
</P><P>					}
</P><P>					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					state.spot[ spotLength ] = uniforms;
</P><P>					spotLength ++;
</P><P>				} else if ( light.isRectAreaLight ) {
</P><P>					var uniforms = cache.get( light );
</P><P>					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
</P><P>					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );
</P><P>					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
</P><P>					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );
</P><P>					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );
</P><P>					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );
</P><P>					// TODO (abelnation): RectAreaLight distance?
					// uniforms.distance = distance;
</P><P>					state.rectArea[ rectAreaLength ] = uniforms;
</P><P>					rectAreaLength ++;
</P><P>				} else if ( light.isPointLight ) {
</P><P>					var uniforms = cache.get( light );
</P><P>					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
</P><P>					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;
</P><P>					uniforms.shadow = light.castShadow;
</P><P>					if ( light.castShadow ) {
</P><P>						var shadow = light.shadow;
</P><P>						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
						uniforms.shadowCameraNear = shadow.camera.near;
						uniforms.shadowCameraFar = shadow.camera.far;
</P><P>					}
</P><P>					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
					state.point[ pointLength ] = uniforms;
</P><P>					pointLength ++;
</P><P>				} else if ( light.isHemisphereLight ) {
</P><P>					var uniforms = cache.get( light );
</P><P>					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();
</P><P>					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
</P><P>					state.hemi[ hemiLength ] = uniforms;
</P><P>					hemiLength ++;
</P><P>				}
</P><P>			}
</P><P>			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;
</P><P>			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;
</P><P>			state.hash.stateID = state.id;
			state.hash.directionalLength = directionalLength;
			state.hash.pointLength = pointLength;
			state.hash.spotLength = spotLength;
			state.hash.rectAreaLength = rectAreaLength;
			state.hash.hemiLength = hemiLength;
			state.hash.shadowsLength = shadows.length;
</P><P>		}
</P><P>		return {
			setup: setup,
			state: state
		};
</P><P>	}
</P><P>	/**
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	function WebGLRenderState() {
</P><P>		var lights = new WebGLLights();
</P><P>		var lightsArray = [];
		var shadowsArray = [];
</P><P>		function init() {
</P><P>			lightsArray.length = 0;
			shadowsArray.length = 0;
</P><P>		}
</P><P>		function pushLight( light ) {
</P><P>			lightsArray.push( light );
</P><P>		}
</P><P>		function pushShadow( shadowLight ) {
</P><P>			shadowsArray.push( shadowLight );
</P><P>		}
</P><P>		function setupLights( camera ) {
</P><P>			lights.setup( lightsArray, shadowsArray, camera );
</P><P>		}
</P><P>		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
</P><P>			lights: lights
		};
</P><P>		return {
			init: init,
			state: state,
			setupLights: setupLights,
</P><P>			pushLight: pushLight,
			pushShadow: pushShadow
		};
</P><P>	}
</P><P>	function WebGLRenderStates() {
</P><P>		var renderStates = {};
</P><P>		function get( scene, camera ) {
</P><P>			var renderState;
</P><P>			if ( renderStates[ scene.id ] === undefined ) {
</P><P>				renderState = new WebGLRenderState();
				renderStates[ scene.id ] = {};
				renderStates[ scene.id ][ camera.id ] = renderState;
</P><P>			} else {
</P><P>				if ( renderStates[ scene.id ][ camera.id ] === undefined ) {
</P><P>					renderState = new WebGLRenderState();
					renderStates[ scene.id ][ camera.id ] = renderState;
</P><P>				} else {
</P><P>					renderState = renderStates[ scene.id ][ camera.id ];
</P><P>				}
</P><P>			}
</P><P>			return renderState;
</P><P>		}
</P><P>		function dispose() {
</P><P>			renderStates = {};
</P><P>		}
</P><P>		return {
			get: get,
			dispose: dispose
		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author bhouston /<A rel="nofollow" class="external free" href="https://clara.io">https://clara.io</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 *
	 * parameters = {
	 *
	 *  opacity: &lt;float&gt;,
	 *
	 *  map: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  alphaMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  displacementMap: new THREE.Texture( &lt;Image&gt; ),
	 *  displacementScale: &lt;float&gt;,
	 *  displacementBias: &lt;float&gt;,
	 *
	 *  wireframe: &lt;boolean&gt;,
	 *  wireframeLinewidth: &lt;float&gt;
	 * }
	 */
</P><P>	function MeshDepthMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'MeshDepthMaterial';
</P><P>		this.depthPacking = BasicDepthPacking;
</P><P>		this.skinning = false;
		this.morphTargets = false;
</P><P>		this.map = null;
</P><P>		this.alphaMap = null;
</P><P>		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
</P><P>		this.wireframe = false;
		this.wireframeLinewidth = 1;
</P><P>		this.fog = false;
		this.lights = false;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
</P><P>	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
</P><P>	MeshDepthMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.depthPacking = source.depthPacking;
</P><P>		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
</P><P>		this.map = source.map;
</P><P>		this.alphaMap = source.alphaMap;
</P><P>		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
</P><P>		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 *
	 * parameters = {
	 *
	 *  referencePosition: &lt;float&gt;,
	 *  nearDistance: &lt;float&gt;,
	 *  farDistance: &lt;float&gt;,
	 *
	 *  skinning: &lt;bool&gt;,
	 *  morphTargets: &lt;bool&gt;,
	 *
	 *  map: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  alphaMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  displacementMap: new THREE.Texture( &lt;Image&gt; ),
	 *  displacementScale: &lt;float&gt;,
	 *  displacementBias: &lt;float&gt;
	 *
	 * }
	 */
</P><P>	function MeshDistanceMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'MeshDistanceMaterial';
</P><P>		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;
</P><P>		this.skinning = false;
		this.morphTargets = false;
</P><P>		this.map = null;
</P><P>		this.alphaMap = null;
</P><P>		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
</P><P>		this.fog = false;
		this.lights = false;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
</P><P>	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
</P><P>	MeshDistanceMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;
</P><P>		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
</P><P>		this.map = source.map;
</P><P>		this.alphaMap = source.alphaMap;
</P><P>		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {
</P><P>		var _frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),
</P><P>			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),
</P><P>			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),
</P><P>			_MorphingFlag = 1,
			_SkinningFlag = 2,
</P><P>			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
</P><P>			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),
</P><P>			_materialCache = {};
</P><P>		var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
</P><P>		var cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];
</P><P>		var cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];
</P><P>		var cube2DViewPorts = [
			new Vector4(), new Vector4(), new Vector4(),
			new Vector4(), new Vector4(), new Vector4()
		];
</P><P>		// init
</P><P>		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
</P><P>			var useMorphing = ( i &amp; _MorphingFlag ) !== 0;
			var useSkinning = ( i &amp; _SkinningFlag ) !== 0;
</P><P>			var depthMaterial = new MeshDepthMaterial( {
</P><P>				depthPacking: RGBADepthPacking,
</P><P>				morphTargets: useMorphing,
				skinning: useSkinning
</P><P>			} );
</P><P>			_depthMaterials[ i ] = depthMaterial;
</P><P>			//
</P><P>			var distanceMaterial = new MeshDistanceMaterial( {
</P><P>				morphTargets: useMorphing,
				skinning: useSkinning
</P><P>			} );
</P><P>			_distanceMaterials[ i ] = distanceMaterial;
</P><P>		}
</P><P>		//
</P><P>		var scope = this;
</P><P>	this.enabled = false;
</P><P>		this.autoUpdate = true;
		this.needsUpdate = false;
</P><P>		this.type = PCFShadowMap;
</P><P>		this.render = function ( lights, scene, camera ) {
</P><P>			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false &amp;&amp; scope.needsUpdate === false ) return;
</P><P>			if ( lights.length === 0 ) return;
</P><P>			// TODO Clean up (needed in case of contextlost)
			var _gl = _renderer.context;
			var _state = _renderer.state;
</P><P>			// Set GL state for depth map.
			_state.disable( _gl.BLEND );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );
</P><P>			// render depth map
</P><P>			var faceCount;
</P><P>			for ( var i = 0, il = lights.length; i &lt; il; i ++ ) {
</P><P>				var light = lights[ i ];
				var shadow = light.shadow;
				var isPointLight = light &amp;&amp; light.isPointLight;
</P><P>				if ( shadow === undefined ) {
</P><P>					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;
</P><P>				}
</P><P>				var shadowCamera = shadow.camera;
</P><P>				_shadowMapSize.copy( shadow.mapSize );
				_shadowMapSize.min( _maxShadowMapSize );
</P><P>				if ( isPointLight ) {
</P><P>					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;
</P><P>					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction
</P><P>					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
</P><P>					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;
</P><P>				}
</P><P>				if ( shadow.map === null ) {
</P><P>					var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
</P><P>					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + &quot;.shadowMap&quot;;
</P><P>					shadowCamera.updateProjectionMatrix();
</P><P>				}
</P><P>				if ( shadow.isSpotLightShadow ) {
</P><P>					shadow.update( light );
</P><P>				}
</P><P>				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;
</P><P>				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );
</P><P>				if ( isPointLight ) {
</P><P>					faceCount = 6;
</P><P>					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position
</P><P>					shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );
</P><P>				} else {
</P><P>					faceCount = 1;
</P><P>					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();
</P><P>					// compute shadow matrix
</P><P>					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);
</P><P>					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
</P><P>				}
</P><P>				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();
</P><P>				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not
</P><P>				for ( var face = 0; face &lt; faceCount; face ++ ) {
</P><P>					if ( isPointLight ) {
</P><P>						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						shadowCamera.updateMatrixWorld();
</P><P>						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );
</P><P>					}
</P><P>					// update camera matrices and frustum
</P><P>					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );
</P><P>					// set object matrices &amp; frustum culling
</P><P>					renderObject( scene, camera, shadowCamera, isPointLight );
</P><P>				}
</P><P>			}
</P><P>			scope.needsUpdate = false;
</P><P>		};
</P><P>		function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {
</P><P>			var geometry = object.geometry;
</P><P>			var result = null;
</P><P>			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;
</P><P>			if ( isPointLight ) {
</P><P>				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;
</P><P>			}
</P><P>			if ( ! customMaterial ) {
</P><P>				var useMorphing = false;
</P><P>				if ( material.morphTargets ) {
</P><P>					if ( geometry &amp;&amp; geometry.isBufferGeometry ) {
</P><P>						useMorphing = geometry.morphAttributes &amp;&amp; geometry.morphAttributes.position &amp;&amp; geometry.morphAttributes.position.length &gt; 0;
</P><P>					} else if ( geometry &amp;&amp; geometry.isGeometry ) {
</P><P>						useMorphing = geometry.morphTargets &amp;&amp; geometry.morphTargets.length &gt; 0;
</P><P>					}
</P><P>				}
</P><P>				if ( object.isSkinnedMesh &amp;&amp; material.skinning === false ) {
</P><P>					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );
</P><P>				}
</P><P>				var useSkinning = object.isSkinnedMesh &amp;&amp; material.skinning;
</P><P>				var variantIndex = 0;
</P><P>				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;
</P><P>				result = materialVariants[ variantIndex ];
</P><P>			} else {
</P><P>				result = customMaterial;
</P><P>			}
</P><P>			if ( _renderer.localClippingEnabled &amp;&amp;
					material.clipShadows === true &amp;&amp;
					material.clippingPlanes.length !== 0 ) {
</P><P>				// in this case we need a unique material instance reflecting the
				// appropriate state
</P><P>				var keyA = result.uuid, keyB = material.uuid;
</P><P>				var materialsForVariant = _materialCache[ keyA ];
</P><P>				if ( materialsForVariant === undefined ) {
</P><P>					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;
</P><P>				}
</P><P>				var cachedMaterial = materialsForVariant[ keyB ];
</P><P>				if ( cachedMaterial === undefined ) {
</P><P>					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;
</P><P>				}
</P><P>				result = cachedMaterial;
</P><P>			}
</P><P>			result.visible = material.visible;
			result.wireframe = material.wireframe;
</P><P>			result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];
</P><P>			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;
</P><P>			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;
</P><P>			if ( isPointLight &amp;&amp; result.isMeshDistanceMaterial ) {
</P><P>				result.referencePosition.copy( lightPositionWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
</P><P>			}
</P><P>			return result;
</P><P>		}
</P><P>		function renderObject( object, camera, shadowCamera, isPointLight ) {
</P><P>			if ( object.visible === false ) return;
</P><P>			var visible = object.layers.test( camera.layers );
</P><P>			if ( visible &amp;&amp; ( object.isMesh || object.isLine || object.isPoints ) ) {
</P><P>				if ( object.castShadow &amp;&amp; ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {
</P><P>					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
</P><P>					var geometry = _objects.update( object );
					var material = object.material;
</P><P>					if ( Array.isArray( material ) ) {
</P><P>						var groups = geometry.groups;
</P><P>						for ( var k = 0, kl = groups.length; k &lt; kl; k ++ ) {
</P><P>							var group = groups[ k ];
							var groupMaterial = material[ group.materialIndex ];
</P><P>							if ( groupMaterial &amp;&amp; groupMaterial.visible ) {
</P><P>								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
</P><P>							}
</P><P>						}
</P><P>					} else if ( material.visible ) {
</P><P>						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			var children = object.children;
</P><P>			for ( var i = 0, l = children.length; i &lt; l; i ++ ) {
</P><P>				renderObject( children[ i ], camera, shadowCamera, isPointLight );
</P><P>			}
</P><P>		}
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLState( gl, extensions, utils, capabilities ) {
</P><P>		function ColorBuffer() {
</P><P>			var locked = false;
</P><P>			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );
</P><P>			return {
</P><P>				setMask: function ( colorMask ) {
</P><P>					if ( currentColorMask !== colorMask &amp;&amp; ! locked ) {
</P><P>						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;
</P><P>					}
</P><P>				},
</P><P>				setLocked: function ( lock ) {
</P><P>					locked = lock;
</P><P>				},
</P><P>				setClear: function ( r, g, b, a, premultipliedAlpha ) {
</P><P>					if ( premultipliedAlpha === true ) {
</P><P>						r *= a; g *= a; b *= a;
</P><P>					}
</P><P>					color.set( r, g, b, a );
</P><P>					if ( currentColorClear.equals( color ) === false ) {
</P><P>						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );
</P><P>					}
</P><P>				},
</P><P>				reset: function () {
</P><P>					locked = false;
</P><P>					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state
</P><P>				}
</P><P>			};
</P><P>		}
</P><P>		function DepthBuffer() {
</P><P>			var locked = false;
</P><P>			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;
</P><P>			return {
</P><P>				setTest: function ( depthTest ) {
</P><P>					if ( depthTest ) {
</P><P>						enable( gl.DEPTH_TEST );
</P><P>					} else {
</P><P>						disable( gl.DEPTH_TEST );
</P><P>					}
</P><P>				},
</P><P>				setMask: function ( depthMask ) {
</P><P>					if ( currentDepthMask !== depthMask &amp;&amp; ! locked ) {
</P><P>						gl.depthMask( depthMask );
						currentDepthMask = depthMask;
</P><P>					}
</P><P>				},
</P><P>				setFunc: function ( depthFunc ) {
</P><P>					if ( currentDepthFunc !== depthFunc ) {
</P><P>						if ( depthFunc ) {
</P><P>							switch ( depthFunc ) {
</P><P>								case NeverDepth:
</P><P>									gl.depthFunc( gl.NEVER );
									break;
</P><P>								case AlwaysDepth:
</P><P>									gl.depthFunc( gl.ALWAYS );
									break;
</P><P>								case LessDepth:
</P><P>									gl.depthFunc( gl.LESS );
									break;
</P><P>								case LessEqualDepth:
</P><P>									gl.depthFunc( gl.LEQUAL );
									break;
</P><P>								case EqualDepth:
</P><P>									gl.depthFunc( gl.EQUAL );
									break;
</P><P>								case GreaterEqualDepth:
</P><P>									gl.depthFunc( gl.GEQUAL );
									break;
</P><P>								case GreaterDepth:
</P><P>									gl.depthFunc( gl.GREATER );
									break;
</P><P>								case NotEqualDepth:
</P><P>									gl.depthFunc( gl.NOTEQUAL );
									break;
</P><P>								default:
</P><P>									gl.depthFunc( gl.LEQUAL );
</P><P>							}
</P><P>						} else {
</P><P>							gl.depthFunc( gl.LEQUAL );
</P><P>						}
</P><P>						currentDepthFunc = depthFunc;
</P><P>					}
</P><P>				},
</P><P>				setLocked: function ( lock ) {
</P><P>					locked = lock;
</P><P>				},
</P><P>				setClear: function ( depth ) {
</P><P>					if ( currentDepthClear !== depth ) {
</P><P>						gl.clearDepth( depth );
						currentDepthClear = depth;
</P><P>					}
</P><P>				},
</P><P>				reset: function () {
</P><P>					locked = false;
</P><P>					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
</P><P>				}
</P><P>			};
</P><P>		}
</P><P>		function StencilBuffer() {
</P><P>			var locked = false;
</P><P>			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;
</P><P>			return {
</P><P>				setTest: function ( stencilTest ) {
</P><P>					if ( stencilTest ) {
</P><P>						enable( gl.STENCIL_TEST );
</P><P>					} else {
</P><P>						disable( gl.STENCIL_TEST );
</P><P>					}
</P><P>				},
</P><P>				setMask: function ( stencilMask ) {
</P><P>					if ( currentStencilMask !== stencilMask &amp;&amp; ! locked ) {
</P><P>						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;
</P><P>					}
</P><P>				},
</P><P>				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {
</P><P>					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef 	!== stencilRef 	||
					     currentStencilFuncMask !== stencilMask ) {
</P><P>						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );
</P><P>						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
</P><P>					}
</P><P>				},
</P><P>				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {
</P><P>					if ( currentStencilFail	 !== stencilFail 	||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {
</P><P>						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );
</P><P>						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
</P><P>					}
</P><P>				},
</P><P>				setLocked: function ( lock ) {
</P><P>					locked = lock;
</P><P>				},
</P><P>				setClear: function ( stencil ) {
</P><P>					if ( currentStencilClear !== stencil ) {
</P><P>						gl.clearStencil( stencil );
						currentStencilClear = stencil;
</P><P>					}
</P><P>				},
</P><P>				reset: function () {
</P><P>					locked = false;
</P><P>					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
</P><P>				}
</P><P>			};
</P><P>		}
</P><P>		//
</P><P>		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();
</P><P>		var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );
</P><P>		var enabledCapabilities = {};
</P><P>		var compressedTextureFormats = null;
</P><P>		var currentProgram = null;
</P><P>		var currentBlendingEnabled = null;
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;
</P><P>		var currentFlipSided = null;
		var currentCullFace = null;
</P><P>		var currentLineWidth = null;
</P><P>		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;
</P><P>		var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );
</P><P>		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter( gl.VERSION );
</P><P>		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {
</P><P>			version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version &gt;= 1.0 );
</P><P>		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {
</P><P>			version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version &gt;= 2.0 );
</P><P>		}
</P><P>		var currentTextureSlot = null;
		var currentBoundTextures = {};
</P><P>		var currentScissor = new Vector4();
		var currentViewport = new Vector4();
</P><P>		function createTexture( type, target, count ) {
</P><P>			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();
</P><P>			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
</P><P>			for ( var i = 0; i &lt; count; i ++ ) {
</P><P>				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );
</P><P>			}
</P><P>			return texture;
</P><P>		}
</P><P>		var emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
</P><P>		// init
</P><P>		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );
</P><P>		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );
</P><P>		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );
</P><P>		setBlending( NoBlending );
</P><P>		//
</P><P>		function initAttributes() {
</P><P>			for ( var i = 0, l = newAttributes.length; i &lt; l; i ++ ) {
</P><P>				newAttributes[ i ] = 0;
</P><P>			}
</P><P>		}
</P><P>		function enableAttribute( attribute ) {
</P><P>			enableAttributeAndDivisor( attribute, 0 );
</P><P>		}
</P><P>		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {
</P><P>			newAttributes[ attribute ] = 1;
</P><P>			if ( enabledAttributes[ attribute ] === 0 ) {
</P><P>				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
</P><P>			}
</P><P>			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
</P><P>				var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );
</P><P>				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;
</P><P>			}
</P><P>		}
</P><P>		function disableUnusedAttributes() {
</P><P>			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {
</P><P>				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
</P><P>					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		function enable( id ) {
</P><P>			if ( enabledCapabilities[ id ] !== true ) {
</P><P>				gl.enable( id );
				enabledCapabilities[ id ] = true;
</P><P>			}
</P><P>		}
</P><P>		function disable( id ) {
</P><P>			if ( enabledCapabilities[ id ] !== false ) {
</P><P>				gl.disable( id );
				enabledCapabilities[ id ] = false;
</P><P>			}
</P><P>		}
</P><P>		function getCompressedTextureFormats() {
</P><P>			if ( compressedTextureFormats === null ) {
</P><P>				compressedTextureFormats = [];
</P><P>				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
				     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {
</P><P>					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
</P><P>					for ( var i = 0; i &lt; formats.length; i ++ ) {
</P><P>						compressedTextureFormats.push( formats[ i ] );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			return compressedTextureFormats;
</P><P>		}
</P><P>		function useProgram( program ) {
</P><P>			if ( currentProgram !== program ) {
</P><P>				gl.useProgram( program );
</P><P>				currentProgram = program;
</P><P>				return true;
</P><P>			}
</P><P>			return false;
</P><P>		}
</P><P>		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
</P><P>			if ( blending === NoBlending ) {
</P><P>				if ( currentBlendingEnabled ) {
</P><P>					disable( gl.BLEND );
					currentBlendingEnabled = false;
</P><P>				}
</P><P>				return;
</P><P>			}
</P><P>			if ( ! currentBlendingEnabled ) {
</P><P>				enable( gl.BLEND );
				currentBlendingEnabled = true;
</P><P>			}
</P><P>			if ( blending !== CustomBlending ) {
</P><P>				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {
</P><P>					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {
</P><P>						gl.blendEquation( gl.FUNC_ADD );
</P><P>						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
</P><P>					}
</P><P>					if ( premultipliedAlpha ) {
</P><P>						switch ( blending ) {
</P><P>							case NormalBlending:
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;
</P><P>							case AdditiveBlending:
								gl.blendFunc( gl.ONE, gl.ONE );
								break;
</P><P>							case SubtractiveBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
								break;
</P><P>							case MultiplyBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
								break;
</P><P>							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;
</P><P>						}
</P><P>					} else {
</P><P>						switch ( blending ) {
</P><P>							case NormalBlending:
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;
</P><P>							case AdditiveBlending:
								gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
								break;
</P><P>							case SubtractiveBlending:
								gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
								break;
</P><P>							case MultiplyBlending:
								gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
								break;
</P><P>							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;
</P><P>						}
</P><P>					}
</P><P>					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
</P><P>					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
</P><P>				}
</P><P>				return;
</P><P>			}
</P><P>			// custom blending
</P><P>			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;
</P><P>			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
</P><P>				gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );
</P><P>				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
</P><P>			}
</P><P>			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
</P><P>				gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );
</P><P>currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
</P><P>			}
</P><P>			currentBlending = blending;
			currentPremultipledAlpha = null;
</P><P>		}
</P><P>		function setMaterial( material, frontFaceCW ) {
</P><P>			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );
</P><P>			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;
</P><P>			setFlipSided( flipSided );
</P><P>			( material.blending === NormalBlending &amp;&amp; material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
</P><P>			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );
</P><P>			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
</P><P>		}
</P><P>		//
</P><P>		function setFlipSided( flipSided ) {
</P><P>			if ( currentFlipSided !== flipSided ) {
</P><P>				if ( flipSided ) {
</P><P>					gl.frontFace( gl.CW );
</P><P>				} else {
</P><P>					gl.frontFace( gl.CCW );
</P><P>				}
</P><P>				currentFlipSided = flipSided;
</P><P>			}
</P><P>		}
</P><P>		function setCullFace( cullFace ) {
</P><P>			if ( cullFace !== CullFaceNone ) {
</P><P>				enable( gl.CULL_FACE );
</P><P>				if ( cullFace !== currentCullFace ) {
</P><P>					if ( cullFace === CullFaceBack ) {
</P><P>						gl.cullFace( gl.BACK );
</P><P>					} else if ( cullFace === CullFaceFront ) {
</P><P>						gl.cullFace( gl.FRONT );
</P><P>					} else {
</P><P>						gl.cullFace( gl.FRONT_AND_BACK );
</P><P>					}
</P><P>				}
</P><P>			} else {
</P><P>				disable( gl.CULL_FACE );
</P><P>			}
</P><P>			currentCullFace = cullFace;
</P><P>		}
</P><P>		function setLineWidth( width ) {
</P><P>			if ( width !== currentLineWidth ) {
</P><P>				if ( lineWidthAvailable ) gl.lineWidth( width );
</P><P>				currentLineWidth = width;
</P><P>			}
</P><P>		}
</P><P>		function setPolygonOffset( polygonOffset, factor, units ) {
</P><P>			if ( polygonOffset ) {
</P><P>				enable( gl.POLYGON_OFFSET_FILL );
</P><P>				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
</P><P>					gl.polygonOffset( factor, units );
</P><P>					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
</P><P>				}
</P><P>			} else {
</P><P>				disable( gl.POLYGON_OFFSET_FILL );
</P><P>			}
</P><P>		}
</P><P>		function setScissorTest( scissorTest ) {
</P><P>			if ( scissorTest ) {
</P><P>				enable( gl.SCISSOR_TEST );
</P><P>			} else {
</P><P>				disable( gl.SCISSOR_TEST );
</P><P>			}
</P><P>		}
</P><P>		// texture
</P><P>		function activeTexture( webglSlot ) {
</P><P>			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
</P><P>			if ( currentTextureSlot !== webglSlot ) {
</P><P>				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;
</P><P>			}
</P><P>		}
</P><P>		function bindTexture( webglType, webglTexture ) {
</P><P>			if ( currentTextureSlot === null ) {
</P><P>				activeTexture();
</P><P>			}
</P><P>			var boundTexture = currentBoundTextures[ currentTextureSlot ];
</P><P>			if ( boundTexture === undefined ) {
</P><P>				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;
</P><P>			}
</P><P>			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
</P><P>				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
</P><P>				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
</P><P>			}
</P><P>		}
</P><P>		function compressedTexImage2D() {
</P><P>			try {
</P><P>				gl.compressedTexImage2D.apply( gl, arguments );
</P><P>			} catch ( error ) {
</P><P>				console.error( 'THREE.WebGLState:', error );
</P><P>			}
</P><P>		}
</P><P>		function texImage2D() {
</P><P>			try {
</P><P>				gl.texImage2D.apply( gl, arguments );
</P><P>			} catch ( error ) {
</P><P>				console.error( 'THREE.WebGLState:', error );
</P><P>			}
</P><P>		}
</P><P>		function texImage3D() {
</P><P>			try {
</P><P>				gl.texImage3D.apply( gl, arguments );
</P><P>			} catch ( error ) {
</P><P>				console.error( 'THREE.WebGLState:', error );
</P><P>			}
</P><P>		}
</P><P>		//
</P><P>		function scissor( scissor ) {
</P><P>			if ( currentScissor.equals( scissor ) === false ) {
</P><P>				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );
</P><P>			}
</P><P>		}
</P><P>		function viewport( viewport ) {
</P><P>			if ( currentViewport.equals( viewport ) === false ) {
</P><P>				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );
</P><P>			}
</P><P>		}
</P><P>		//
</P><P>		function reset() {
</P><P>			for ( var i = 0; i &lt; enabledAttributes.length; i ++ ) {
</P><P>				if ( enabledAttributes[ i ] === 1 ) {
</P><P>					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
</P><P>				}
</P><P>			}
</P><P>			enabledCapabilities = {};
</P><P>			compressedTextureFormats = null;
</P><P>			currentTextureSlot = null;
			currentBoundTextures = {};
</P><P>			currentProgram = null;
</P><P>			currentBlending = null;
</P><P>			currentFlipSided = null;
			currentCullFace = null;
</P><P>			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
</P><P>		}
</P><P>		return {
</P><P>			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},
</P><P>			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			enableAttributeAndDivisor: enableAttributeAndDivisor,
			disableUnusedAttributes: disableUnusedAttributes,
			enable: enable,
			disable: disable,
			getCompressedTextureFormats: getCompressedTextureFormats,
</P><P>			useProgram: useProgram,
</P><P>			setBlending: setBlending,
			setMaterial: setMaterial,
</P><P>			setFlipSided: setFlipSided,
			setCullFace: setCullFace,
</P><P>			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,
</P><P>			setScissorTest: setScissorTest,
</P><P>			activeTexture: activeTexture,
			bindTexture: bindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,
</P><P>			scissor: scissor,
			viewport: viewport,
</P><P>			reset: reset
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {
</P><P>		var _videoTextures = {};
		var _canvas;
</P><P>		//
</P><P>		function clampToMaxSize( image, maxSize ) {
</P><P>			if ( image.width &gt; maxSize || image.height &gt; maxSize ) {
</P><P>				if ( 'data' in image ) {
</P><P>					console.warn( 'THREE.WebGLRenderer: image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );
					return;
</P><P>				}
</P><P>				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.
</P><P>				var scale = maxSize / Math.max( image.width, image.height );
</P><P>				var canvas = document.createElementNS( '<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml'">http://www.w3.org/1999/xhtml'</A>, 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );
</P><P>				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
</P><P>				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height );
</P><P>				return canvas;
</P><P>			}
</P><P>			return image;
</P><P>		}
</P><P>		function isPowerOfTwo( image ) {
</P><P>			return _Math.isPowerOfTwo( image.width ) &amp;&amp; _Math.isPowerOfTwo( image.height );
</P><P>		}
</P><P>		function makePowerOfTwo( image ) {
</P><P>			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {
</P><P>				if ( _canvas === undefined ) _canvas = document.createElementNS( '<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml'">http://www.w3.org/1999/xhtml'</A>, 'canvas' );
</P><P>				_canvas.width = _Math.floorPowerOfTwo( image.width );
				_canvas.height = _Math.floorPowerOfTwo( image.height );
</P><P>				var context = _canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, _canvas.width, _canvas.height );
</P><P>				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + _canvas.width + 'x' + _canvas.height );
</P><P>				return _canvas;
</P><P>			}
</P><P>			return image;
</P><P>		}
</P><P>		function textureNeedsPowerOfTwo( texture ) {
</P><P>			if ( capabilities.isWebGL2 ) return false;
</P><P>			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter &amp;&amp; texture.minFilter !== LinearFilter );
</P><P>		}
</P><P>		function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {
</P><P>			return texture.generateMipmaps &amp;&amp; isPowerOfTwo &amp;&amp;
				texture.minFilter !== NearestFilter &amp;&amp; texture.minFilter !== LinearFilter;
</P><P>		}
</P><P>		function generateMipmap( target, texture, width, height ) {
</P><P>			_gl.generateMipmap( target );
</P><P>			var textureProperties = properties.get( texture );
</P><P>			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
			textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;
</P><P>		}
</P><P>		function getInternalFormat( glFormat, glType ) {
</P><P>			if ( ! capabilities.isWebGL2 ) return glFormat;
</P><P>			if ( glFormat === _gl.RED ) {
</P><P>				if ( glType === _gl.FLOAT ) return _gl.R32F;
				if ( glType === _gl.HALF_FLOAT ) return _gl.R16F;
				if ( glType === _gl.UNSIGNED_BYTE ) return _gl.R8;
</P><P>			}
</P><P>			if ( glFormat === _gl.RGB ) {
</P><P>				if ( glType === _gl.FLOAT ) return _gl.RGB32F;
				if ( glType === _gl.HALF_FLOAT ) return _gl.RGB16F;
				if ( glType === _gl.UNSIGNED_BYTE ) return _gl.RGB8;
</P><P>			}
</P><P>			if ( glFormat === _gl.RGBA ) {
</P><P>				if ( glType === _gl.FLOAT ) return _gl.RGBA32F;
				if ( glType === _gl.HALF_FLOAT ) return _gl.RGBA16F;
				if ( glType === _gl.UNSIGNED_BYTE ) return _gl.RGBA8;
</P><P>			}
</P><P>			return glFormat;
</P><P>		}
</P><P>		// Fallback filters for non-power-of-2 textures
</P><P>		function filterFallback( f ) {
</P><P>			if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {
</P><P>				return _gl.NEAREST;
</P><P>			}
</P><P>			return _gl.LINEAR;
</P><P>		}
</P><P>		//
</P><P>		function onTextureDispose( event ) {
</P><P>			var texture = event.target;
</P><P>			texture.removeEventListener( 'dispose', onTextureDispose );
</P><P>			deallocateTexture( texture );
</P><P>			if ( texture.isVideoTexture ) {
</P><P>				delete _videoTextures[ texture.id ];
</P><P>			}
</P><P>			info.memory.textures --;
</P><P>		}
</P><P>		function onRenderTargetDispose( event ) {
</P><P>			var renderTarget = event.target;
</P><P>			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
</P><P>			deallocateRenderTarget( renderTarget );
</P><P>			info.memory.textures --;
</P><P>		}
</P><P>		//
</P><P>		function deallocateTexture( texture ) {
</P><P>			var textureProperties = properties.get( texture );
</P><P>			if ( texture.image &amp;&amp; textureProperties.__image__webglTextureCube ) {
</P><P>				// cube texture
</P><P>				_gl.deleteTexture( textureProperties.__image__webglTextureCube );
</P><P>			} else {
</P><P>				// 2D texture
</P><P>				if ( textureProperties.__webglInit === undefined ) return;
</P><P>				_gl.deleteTexture( textureProperties.__webglTexture );
</P><P>			}
</P><P>			// remove all webgl properties
			properties.remove( texture );
</P><P>		}
</P><P>		function deallocateRenderTarget( renderTarget ) {
</P><P>			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
</P><P>			if ( ! renderTarget ) return;
</P><P>			if ( textureProperties.__webglTexture !== undefined ) {
</P><P>				_gl.deleteTexture( textureProperties.__webglTexture );
</P><P>			}
</P><P>			if ( renderTarget.depthTexture ) {
</P><P>				renderTarget.depthTexture.dispose();
</P><P>			}
</P><P>			if ( renderTarget.isWebGLRenderTargetCube ) {
</P><P>				for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
</P><P>				}
</P><P>			} else {
</P><P>				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
</P><P>			}
</P><P>			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );
</P><P>		}
</P><P>		//
</P><P>		function setTexture2D( texture, slot ) {
</P><P>			var textureProperties = properties.get( texture );
</P><P>			if ( texture.isVideoTexture ) updateVideoTexture( texture );
</P><P>			if ( texture.version &gt; 0 &amp;&amp; textureProperties.__version !== texture.version ) {
</P><P>				var image = texture.image;
</P><P>				if ( image === undefined ) {
</P><P>					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );
</P><P>				} else if ( image.complete === false ) {
</P><P>					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );
</P><P>				} else {
</P><P>					uploadTexture( textureProperties, texture, slot );
					return;
</P><P>				}
</P><P>			}
</P><P>			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
</P><P>		}
</P><P>		function setTexture3D( texture, slot ) {
</P><P>			var textureProperties = properties.get( texture );
</P><P>			if ( texture.version &gt; 0 &amp;&amp; textureProperties.__version !== texture.version ) {
</P><P>				uploadTexture( textureProperties, texture, slot );
				return;
</P><P>			}
</P><P>			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture );
</P><P>		}
</P><P>
		function setTextureCube( texture, slot ) {
</P><P>			var textureProperties = properties.get( texture );
</P><P>			if ( texture.image.length === 6 ) {
</P><P>				if ( texture.version &gt; 0 &amp;&amp; textureProperties.__version !== texture.version ) {
</P><P>					if ( ! textureProperties.__image__webglTextureCube ) {
</P><P>						texture.addEventListener( 'dispose', onTextureDispose );
</P><P>						textureProperties.__image__webglTextureCube = _gl.createTexture();
</P><P>						info.memory.textures ++;
</P><P>					}
</P><P>					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
</P><P>					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
</P><P>					var isCompressed = ( texture &amp;&amp; texture.isCompressedTexture );
					var isDataTexture = ( texture.image[ 0 ] &amp;&amp; texture.image[ 0 ].isDataTexture );
</P><P>					var cubeImage = [];
</P><P>					for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>						if ( ! isCompressed &amp;&amp; ! isDataTexture ) {
</P><P>							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
</P><P>						} else {
</P><P>							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
</P><P>						}
</P><P>					}
</P><P>					var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = utils.convert( texture.format ),
						glType = utils.convert( texture.type ),
						glInternalFormat = getInternalFormat( glFormat, glType );
</P><P>					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );
</P><P>					for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>						if ( ! isCompressed ) {
</P><P>							if ( isDataTexture ) {
</P><P>								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
</P><P>							} else {
</P><P>								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );
</P><P>							}
</P><P>						} else {
</P><P>							var mipmap, mipmaps = cubeImage[ i ].mipmaps;
</P><P>							for ( var j = 0, jl = mipmaps.length; j &lt; jl; j ++ ) {
</P><P>								mipmap = mipmaps[ j ];
</P><P>								if ( texture.format !== RGBAFormat &amp;&amp; texture.format !== RGBFormat ) {
</P><P>									if ( state.getCompressedTextureFormats().indexOf( glFormat ) &gt; - 1 ) {
</P><P>										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );
</P><P>									} else {
</P><P>										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );
</P><P>									}
</P><P>								} else {
</P><P>									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
</P><P>								}
</P><P>							}
</P><P>						}
</P><P>					}
</P><P>					if ( ! isCompressed ) {
</P><P>						textureProperties.__maxMipLevel = 0;
</P><P>					} else {
</P><P>						textureProperties.__maxMipLevel = mipmaps.length - 1;
</P><P>					}
</P><P>					if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {
</P><P>						// We assume images for cube map have the same size.
						generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, image.width, image.height );
</P><P>					}
</P><P>					textureProperties.__version = texture.version;
</P><P>					if ( texture.onUpdate ) texture.onUpdate( texture );
</P><P>				} else {
</P><P>					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		function setTextureCubeDynamic( texture, slot ) {
</P><P>			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
</P><P>		}
</P><P>		function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {
</P><P>			var extension;
</P><P>			if ( isPowerOfTwoImage ) {
</P><P>				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );
</P><P>				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );
</P><P>			} else {
</P><P>				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
</P><P>				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {
</P><P>					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );
</P><P>				}
</P><P>				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
</P><P>				if ( texture.minFilter !== NearestFilter &amp;&amp; texture.minFilter !== LinearFilter ) {
</P><P>					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );
</P><P>				}
</P><P>			}
</P><P>			extension = extensions.get( 'EXT_texture_filter_anisotropic' );
</P><P>			if ( extension ) {
</P><P>				if ( texture.type === FloatType &amp;&amp; extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType &amp;&amp; ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;
</P><P>				if ( texture.anisotropy &gt; 1 || properties.get( texture ).__currentAnisotropy ) {
</P><P>					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		function uploadTexture( textureProperties, texture, slot ) {
</P><P>			var textureType;
</P><P>			if ( texture.isDataTexture3D ) {
</P><P>				textureType = _gl.TEXTURE_3D;
</P><P>			} else {
</P><P>				textureType = _gl.TEXTURE_2D;
</P><P>			}
</P><P>
			if ( textureProperties.__webglInit === undefined ) {
</P><P>				textureProperties.__webglInit = true;
</P><P>				texture.addEventListener( 'dispose', onTextureDispose );
</P><P>				textureProperties.__webglTexture = _gl.createTexture();
</P><P>				info.memory.textures ++;
</P><P>			}
			state.activeTexture( _gl.TEXTURE0 + slot );
</P><P>
			state.bindTexture( textureType, textureProperties.__webglTexture );
</P><P>			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
</P><P>			var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
</P><P>			if ( textureNeedsPowerOfTwo( texture ) &amp;&amp; isPowerOfTwo( image ) === false ) {
</P><P>				image = makePowerOfTwo( image );
</P><P>			}
</P><P>			var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( glFormat, glType );
</P><P>			setTextureParameters( textureType, texture, isPowerOfTwoImage );
</P><P>			var mipmap, mipmaps = texture.mipmaps;
</P><P>			if ( texture.isDepthTexture ) {
</P><P>				// populate depth texture with dummy data
</P><P>				glInternalFormat = _gl.DEPTH_COMPONENT;
</P><P>				if ( texture.type === FloatType ) {
</P><P>					if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
					glInternalFormat = _gl.DEPTH_COMPONENT32F;
</P><P>				} else if ( capabilities.isWebGL2 ) {
</P><P>					// WebGL 2.0 requires signed internalformat for glTexImage2D
					glInternalFormat = _gl.DEPTH_COMPONENT16;
</P><P>				}
</P><P>				if ( texture.format === DepthFormat &amp;&amp; glInternalFormat === _gl.DEPTH_COMPONENT ) {
</P><P>					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (<A rel="nofollow" class="external free" href="https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/">https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/</A>)
					if ( texture.type !== UnsignedShortType &amp;&amp; texture.type !== UnsignedIntType ) {
</P><P>						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );
</P><P>						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );
</P><P>					}
</P><P>				}
</P><P>				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (<A rel="nofollow" class="external free" href="https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/">https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/</A>)
				if ( texture.format === DepthStencilFormat ) {
</P><P>					glInternalFormat = _gl.DEPTH_STENCIL;
</P><P>					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (<A rel="nofollow" class="external free" href="https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/">https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/</A>)
					if ( texture.type !== UnsignedInt248Type ) {
</P><P>						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );
</P><P>						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );
</P><P>					}
</P><P>				}
</P><P>				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );
</P><P>			} else if ( texture.isDataTexture ) {
</P><P>				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
</P><P>				if ( mipmaps.length &gt; 0 &amp;&amp; isPowerOfTwoImage ) {
</P><P>					for ( var i = 0, il = mipmaps.length; i &lt; il; i ++ ) {
</P><P>						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
</P><P>					}
</P><P>					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
</P><P>				} else {
</P><P>					state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;
</P><P>				}
</P><P>			} else if ( texture.isCompressedTexture ) {
</P><P>				for ( var i = 0, il = mipmaps.length; i &lt; il; i ++ ) {
</P><P>					mipmap = mipmaps[ i ];
</P><P>					if ( texture.format !== RGBAFormat &amp;&amp; texture.format !== RGBFormat ) {
</P><P>						if ( state.getCompressedTextureFormats().indexOf( glFormat ) &gt; - 1 ) {
</P><P>							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );
</P><P>					} else {
</P><P>							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );
</P><P>						}
</P><P>					} else {
</P><P>						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
</P><P>					}
</P><P>				}
</P><P>				textureProperties.__maxMipLevel = mipmaps.length - 1;
</P><P>			} else if ( texture.isDataTexture3D ) {
</P><P>				state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;
</P><P>			} else {
</P><P>				// regular Texture (image, video, canvas)
</P><P>				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
</P><P>				if ( mipmaps.length &gt; 0 &amp;&amp; isPowerOfTwoImage ) {
</P><P>					for ( var i = 0, il = mipmaps.length; i &lt; il; i ++ ) {
</P><P>						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );
</P><P>					}
</P><P>					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
</P><P>				} else {
</P><P>					state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;
</P><P>				}
</P><P>			}
</P><P>			if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {
</P><P>				generateMipmap( _gl.TEXTURE_2D, texture, image.width, image.height );
</P><P>			}
</P><P>			textureProperties.__version = texture.version;
</P><P>			if ( texture.onUpdate ) texture.onUpdate( texture );
</P><P>		}
</P><P>		// Render targets
</P><P>		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {
</P><P>			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			var glInternalFormat = getInternalFormat( glFormat, glType );
			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
</P><P>		}
</P><P>		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget ) {
</P><P>			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
</P><P>			if ( renderTarget.depthBuffer &amp;&amp; ! renderTarget.stencilBuffer ) {
</P><P>				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
</P><P>			} else if ( renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer ) {
</P><P>				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
</P><P>			} else {
</P><P>				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
</P><P>			}
</P><P>			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
</P><P>		}
</P><P>		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {
</P><P>			var isCube = ( renderTarget &amp;&amp; renderTarget.isWebGLRenderTargetCube );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );
</P><P>			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
</P><P>			if ( ! ( renderTarget.depthTexture &amp;&amp; renderTarget.depthTexture.isDepthTexture ) ) {
</P><P>				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );
</P><P>			}
</P><P>			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {
</P><P>				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
</P><P>			}
</P><P>			setTexture2D( renderTarget.depthTexture, 0 );
</P><P>			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
</P><P>			if ( renderTarget.depthTexture.format === DepthFormat ) {
</P><P>				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
</P><P>			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {
</P><P>				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
</P><P>			} else {
</P><P>				throw new Error( 'Unknown depthTexture format' );
</P><P>			}
</P><P>		}
</P><P>		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {
</P><P>			var renderTargetProperties = properties.get( renderTarget );
</P><P>			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
</P><P>			if ( renderTarget.depthTexture ) {
</P><P>				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );
</P><P>				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
</P><P>			} else {
</P><P>				if ( isCube ) {
</P><P>					renderTargetProperties.__webglDepthbuffer = [];
</P><P>					for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
</P><P>					}
</P><P>				} else {
</P><P>					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
</P><P>				}
</P><P>			}
</P><P>			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
</P><P>		}
</P><P>		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {
</P><P>			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
</P><P>			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
</P><P>			textureProperties.__webglTexture = _gl.createTexture();
</P><P>			info.memory.textures ++;
</P><P>			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
</P><P>			// Setup framebuffer
</P><P>			if ( isCube ) {
</P><P>				renderTargetProperties.__webglFramebuffer = [];
</P><P>				for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
</P><P>				}
</P><P>			} else {
</P><P>				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
</P><P>			}
</P><P>			// Setup color buffer
</P><P>			if ( isCube ) {
</P><P>				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
</P><P>				for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
</P><P>				}
</P><P>				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) {
</P><P>					generateMipmap( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height );
</P><P>				}
</P><P>				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
</P><P>			} else {
</P><P>				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );
</P><P>				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) {
</P><P>					generateMipmap( _gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height );
</P><P>				}
</P><P>				state.bindTexture( _gl.TEXTURE_2D, null );
</P><P>			}
</P><P>			// Setup depth and stencil buffers
</P><P>			if ( renderTarget.depthBuffer ) {
</P><P>				setupDepthRenderbuffer( renderTarget );
</P><P>			}
</P><P>		}
</P><P>		function updateRenderTargetMipmap( renderTarget ) {
</P><P>			var texture = renderTarget.texture;
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
</P><P>			if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {
</P><P>				var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				var webglTexture = properties.get( texture ).__webglTexture;
</P><P>				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );
</P><P>			}
</P><P>		}
</P><P>		function updateVideoTexture( texture ) {
</P><P>			var id = texture.id;
			var frame = info.render.frame;
</P><P>			// Check the last frame we updated the VideoTexture
</P><P>			if ( _videoTextures[ id ] !== frame ) {
</P><P>				_videoTextures[ id ] = frame;
				texture.update();
</P><P>			}
</P><P>		}
</P><P>		this.setTexture2D = setTexture2D;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
</P><P>	}
</P><P>	/**
	 * @author thespite / <A rel="nofollow" class="external free" href="http://www.twitter.com/thespite">http://www.twitter.com/thespite</A>
	 */
</P><P>	function WebGLUtils( gl, extensions, capabilities ) {
</P><P>		function convert( p ) {
</P><P>			var extension;
</P><P>			if ( p === RepeatWrapping ) return gl.REPEAT;
			if ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;
			if ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;
</P><P>			if ( p === NearestFilter ) return gl.NEAREST;
			if ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;
			if ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;
</P><P>			if ( p === LinearFilter ) return gl.LINEAR;
			if ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;
			if ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;
</P><P>			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;
</P><P>			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;
</P><P>			if ( p === HalfFloatType ) {
</P><P>				if ( capabilities.isWebGL2 ) return gl.HALF_FLOAT;
</P><P>				extension = extensions.get( 'OES_texture_half_float' );
</P><P>				if ( extension !== null ) return extension.HALF_FLOAT_OES;
</P><P>			}
</P><P>			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBFormat ) return gl.RGB;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === LuminanceFormat ) return gl.LUMINANCE;
			if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;
			if ( p === RedFormat ) return gl.RED;
</P><P>			if ( p === AddEquation ) return gl.FUNC_ADD;
			if ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;
			if ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;
</P><P>			if ( p === ZeroFactor ) return gl.ZERO;
			if ( p === OneFactor ) return gl.ONE;
			if ( p === SrcColorFactor ) return gl.SRC_COLOR;
			if ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;
			if ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;
			if ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;
			if ( p === DstAlphaFactor ) return gl.DST_ALPHA;
			if ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;
</P><P>			if ( p === DstColorFactor ) return gl.DST_COLOR;
			if ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;
			if ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;
</P><P>			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {
</P><P>				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
</P><P>				if ( extension !== null ) {
</P><P>					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
</P><P>				}
</P><P>			}
</P><P>			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {
</P><P>				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
</P><P>				if ( extension !== null ) {
</P><P>					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
</P><P>				}
</P><P>			}
</P><P>			if ( p === RGB_ETC1_Format ) {
</P><P>				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
</P><P>				if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
</P><P>			}
</P><P>			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {
</P><P>				extension = extensions.get( 'WEBGL_compressed_texture_astc' );
</P><P>				if ( extension !== null ) {
</P><P>					return p;
</P><P>				}
</P><P>			}
</P><P>			if ( p === MinEquation || p === MaxEquation ) {
</P><P>				if ( capabilities.isWebGL2 ) {
</P><P>					if ( p === MinEquation ) return gl.MIN;
					if ( p === MaxEquation ) return gl.MAX;
</P><P>				}
</P><P>				extension = extensions.get( 'EXT_blend_minmax' );
</P><P>				if ( extension !== null ) {
</P><P>					if ( p === MinEquation ) return extension.MIN_EXT;
					if ( p === MaxEquation ) return extension.MAX_EXT;
</P><P>				}
</P><P>			}
</P><P>			if ( p === UnsignedInt248Type ) {
</P><P>				if ( capabilities.isWebGL2 ) return gl.UNSIGNED_INT_24_8;
</P><P>				extension = extensions.get( 'WEBGL_depth_texture' );
</P><P>				if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;
</P><P>			}
</P><P>			return 0;
</P><P>		}
</P><P>		return { convert: convert };
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function Group() {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Group';
</P><P>	}
</P><P>	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Group,
</P><P>		isGroup: true
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	*/
</P><P>	function Camera() {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Camera';
</P><P>		this.matrixWorldInverse = new Matrix4();
</P><P>		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();
</P><P>	}
</P><P>	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Camera,
</P><P>		isCamera: true,
</P><P>		copy: function ( source, recursive ) {
</P><P>			Object3D.prototype.copy.call( this, source, recursive );
</P><P>			this.matrixWorldInverse.copy( source.matrixWorldInverse );
</P><P>			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );
</P><P>			return this;
</P><P>		},
</P><P>		getWorldDirection: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			this.updateMatrixWorld( true );
</P><P>			var e = this.matrixWorld.elements;
</P><P>			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();
</P><P>		},
</P><P>		updateMatrixWorld: function ( force ) {
</P><P>			Object3D.prototype.updateMatrixWorld.call( this, force );
</P><P>			this.matrixWorldInverse.getInverse( this.matrixWorld );
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author greggman / <A rel="nofollow" class="external free" href="http://games.greggman.com/">http://games.greggman.com/</A>
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 * @author tschw
	 */
</P><P>	function PerspectiveCamera( fov, aspect, near, far ) {
</P><P>		Camera.call( this );
</P><P>		this.type = 'PerspectiveCamera';
</P><P>		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;
</P><P>		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;
</P><P>		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;
</P><P>		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)
</P><P>		this.updateProjectionMatrix();
</P><P>	}
</P><P>	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
</P><P>		constructor: PerspectiveCamera,
</P><P>		isPerspectiveCamera: true,
</P><P>		copy: function ( source, recursive ) {
</P><P>			Camera.prototype.copy.call( this, source, recursive );
</P><P>			this.fov = source.fov;
			this.zoom = source.zoom;
</P><P>			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
</P><P>			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );
</P><P>			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
</P><P>			return this;
</P><P>		},
</P><P>		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {
</P><P>			// see <A rel="nofollow" class="external free" href="http://www.bobatkins.com/photography/technical/field_of_view.html">http://www.bobatkins.com/photography/technical/field_of_view.html</A>
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
</P><P>			this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();
</P><P>		},
</P><P>		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {
</P><P>			var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );
</P><P>			return 0.5 * this.getFilmHeight() / vExtentSlope;
</P><P>		},
</P><P>		getEffectiveFOV: function () {
</P><P>			return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );
</P><P>		},
</P><P>		getFilmWidth: function () {
</P><P>			// film not completely covered in portrait format (aspect &lt; 1)
			return this.filmGauge * Math.min( this.aspect, 1 );
</P><P>		},
</P><P>		getFilmHeight: function () {
</P><P>			// film not completely covered in landscape format (aspect &gt; 1)
			return this.filmGauge / Math.max( this.aspect, 1 );
</P><P>		},
</P><P>		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
</P><P>			this.aspect = fullWidth / fullHeight;
</P><P>			if ( this.view === null ) {
</P><P>				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
</P><P>			}
</P><P>			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
</P><P>			this.updateProjectionMatrix();
</P><P>		},
</P><P>		clearViewOffset: function () {
</P><P>			if ( this.view !== null ) {
</P><P>				this.view.enabled = false;
</P><P>			}
</P><P>			this.updateProjectionMatrix();
</P><P>		},
</P><P>		updateProjectionMatrix: function () {
</P><P>			var near = this.near,
				top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;
</P><P>			if ( this.view !== null &amp;&amp; this.view.enabled ) {
</P><P>				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;
</P><P>				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
</P><P>			}
</P><P>			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
</P><P>			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
</P><P>			this.projectionMatrixInverse.getInverse( this.projectionMatrix );
</P><P>		},
</P><P>		toJSON: function ( meta ) {
</P><P>			var data = Object3D.prototype.toJSON.call( this, meta );
</P><P>			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
</P><P>			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
</P><P>			data.object.aspect = this.aspect;
</P><P>			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
</P><P>			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
</P><P>			return data;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function ArrayCamera( array ) {
</P><P>		PerspectiveCamera.call( this );
</P><P>		this.cameras = array || [];
</P><P>	}
</P><P>	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {
</P><P>		constructor: ArrayCamera,
</P><P>		isArrayCamera: true
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebVRManager( renderer ) {
</P><P>		var scope = this;
</P><P>		var device = null;
		var frameData = null;
</P><P>		var poseTarget = null;
</P><P>		var controllers = [];
		var standingMatrix = new Matrix4();
		var standingMatrixInverse = new Matrix4();
</P><P>		var frameOfReferenceType = 'stage';
</P><P>		if ( typeof window !== 'undefined' &amp;&amp; 'VRFrameData' in window ) {
</P><P>			frameData = new window.VRFrameData();
			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );
</P><P>		}
</P><P>		var matrixWorldInverse = new Matrix4();
		var tempQuaternion = new Quaternion();
		var tempPosition = new Vector3();
</P><P>		var cameraL = new PerspectiveCamera();
		cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
		cameraL.layers.enable( 1 );
</P><P>		var cameraR = new PerspectiveCamera();
		cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
		cameraR.layers.enable( 2 );
</P><P>		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );
</P><P>		//
</P><P>		function isPresenting() {
</P><P>			return device !== null &amp;&amp; device.isPresenting === true;
</P><P>		}
</P><P>		var currentSize, currentPixelRatio;
</P><P>		function onVRDisplayPresentChange() {
</P><P>			if ( isPresenting() ) {
</P><P>				var eyeParameters = device.getEyeParameters( 'left' );
				var renderWidth = eyeParameters.renderWidth;
				var renderHeight = eyeParameters.renderHeight;
</P><P>				currentPixelRatio = renderer.getPixelRatio();
				currentSize = renderer.getSize();
</P><P>				renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );
</P><P>				animation.start();
</P><P>			} else {
</P><P>				if ( scope.enabled ) {
</P><P>					renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );
</P><P>				}
</P><P>				animation.stop();
</P><P>			}
</P><P>		}
</P><P>		//
</P><P>		var triggers = [];
</P><P>		function findGamepad( id ) {
</P><P>			var gamepads = navigator.getGamepads &amp;&amp; navigator.getGamepads();
</P><P>			for ( var i = 0, j = 0, l = gamepads.length; i &lt; l; i ++ ) {
</P><P>				var gamepad = gamepads[ i ];
</P><P>				if ( gamepad &amp;&amp; ( gamepad.id === 'Daydream Controller' ||
					gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||
					gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||
					gamepad.id.startsWith( 'Spatial Controller' ) ) ) {
</P><P>					if ( j === id ) return gamepad;
</P><P>					j ++;
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		function updateControllers() {
</P><P>			for ( var i = 0; i &lt; controllers.length; i ++ ) {
</P><P>				var controller = controllers[ i ];
</P><P>				var gamepad = findGamepad( i );
</P><P>				if ( gamepad !== undefined &amp;&amp; gamepad.pose !== undefined ) {
</P><P>					if ( gamepad.pose === null ) return;
</P><P>					//  Pose
</P><P>					var pose = gamepad.pose;
</P><P>					if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );
</P><P>					if ( pose.position !== null ) controller.position.fromArray( pose.position );
					if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );
					controller.matrix.compose( controller.position, controller.quaternion, controller.scale );
					controller.matrix.premultiply( standingMatrix );
					controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );
					controller.matrixWorldNeedsUpdate = true;
					controller.visible = true;
</P><P>					//  Trigger
</P><P>					var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;
</P><P>					if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {
</P><P>						triggers[ i ] = gamepad.buttons[ buttonId ].pressed;
</P><P>						if ( triggers[ i ] === true ) {
</P><P>							controller.dispatchEvent( { type: 'selectstart' } );
</P><P>						} else {
</P><P>							controller.dispatchEvent( { type: 'selectend' } );
							controller.dispatchEvent( { type: 'select' } );
</P><P>						}
</P><P>					}
</P><P>				} else {
</P><P>					controller.visible = false;
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		//
</P><P>		this.enabled = false;
</P><P>		this.getController = function ( id ) {
</P><P>			var controller = controllers[ id ];
</P><P>			if ( controller === undefined ) {
</P><P>				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;
</P><P>				controllers[ id ] = controller;
</P><P>			}
</P><P>			return controller;
</P><P>		};
</P><P>		this.getDevice = function () {
</P><P>			return device;
</P><P>		};
</P><P>		this.setDevice = function ( value ) {
</P><P>			if ( value !== undefined ) device = value;
</P><P>			animation.setContext( value );
</P><P>		};
</P><P>		this.setFrameOfReferenceType = function ( value ) {
</P><P>			frameOfReferenceType = value;
</P><P>		};
</P><P>		this.setPoseTarget = function ( object ) {
</P><P>			if ( object !== undefined ) poseTarget = object;
</P><P>		};
</P><P>		this.getCamera = function ( camera ) {
</P><P>			var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;
</P><P>			if ( device === null ) {
</P><P>				camera.position.set( 0, userHeight, 0 );
				return camera;
</P><P>			}
</P><P>			device.depthNear = camera.near;
			device.depthFar = camera.far;
</P><P>			device.getFrameData( frameData );
</P><P>			//
</P><P>			if ( frameOfReferenceType === 'stage' ) {
</P><P>				var stageParameters = device.stageParameters;
</P><P>				if ( stageParameters ) {
</P><P>					standingMatrix.fromArray( stageParameters.sittingToStandingTransform );
</P><P>				} else {
</P><P>					standingMatrix.makeTranslation( 0, userHeight, 0 );
</P><P>				}
</P><P>			}
</P><P>
			var pose = frameData.pose;
			var poseObject = poseTarget !== null ? poseTarget : camera;
</P><P>			// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
			poseObject.matrix.copy( standingMatrix );
			poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );
</P><P>			if ( pose.orientation !== null ) {
</P><P>				tempQuaternion.fromArray( pose.orientation );
				poseObject.quaternion.multiply( tempQuaternion );
</P><P>			}
</P><P>			if ( pose.position !== null ) {
</P><P>				tempQuaternion.setFromRotationMatrix( standingMatrix );
				tempPosition.fromArray( pose.position );
				tempPosition.applyQuaternion( tempQuaternion );
				poseObject.position.add( tempPosition );
</P><P>			}
</P><P>			poseObject.updateMatrixWorld();
</P><P>			if ( device.isPresenting === false ) return camera;
</P><P>			//
</P><P>			cameraL.near = camera.near;
			cameraR.near = camera.near;
</P><P>			cameraL.far = camera.far;
			cameraR.far = camera.far;
</P><P>			cameraVR.matrixWorld.copy( camera.matrixWorld );
			cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );
</P><P>			cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
			cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );
</P><P>			// TODO (mrdoob) Double check this code
</P><P>			standingMatrixInverse.getInverse( standingMatrix );
</P><P>			if ( frameOfReferenceType === 'stage' ) {
</P><P>				cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
				cameraR.matrixWorldInverse.multiply( standingMatrixInverse );
</P><P>			}
</P><P>			var parent = poseObject.parent;
</P><P>			if ( parent !== null ) {
</P><P>				matrixWorldInverse.getInverse( parent.matrixWorld );
</P><P>				cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
				cameraR.matrixWorldInverse.multiply( matrixWorldInverse );
</P><P>			}
</P><P>			// envMap and Mirror needs camera.matrixWorld
</P><P>			cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
			cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );
</P><P>			cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
			cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );
</P><P>			// HACK (mrdoob)
			// <A rel="nofollow" class="external free" href="https://github.com/w3c/webvr/issues/203">https://github.com/w3c/webvr/issues/203</A></P><P>			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );
</P><P>			//
</P><P>			var layers = device.getLayers();
</P><P>			if ( layers.length ) {
</P><P>				var layer = layers[ 0 ];
</P><P>				if ( layer.leftBounds !== null &amp;&amp; layer.leftBounds.length === 4 ) {
</P><P>					cameraL.bounds.fromArray( layer.leftBounds );
</P><P>				}
</P><P>				if ( layer.rightBounds !== null &amp;&amp; layer.rightBounds.length === 4 ) {
</P><P>					cameraR.bounds.fromArray( layer.rightBounds );
</P><P>				}
</P><P>			}
</P><P>			updateControllers();
</P><P>			return cameraVR;
</P><P>		};
</P><P>		this.getStandingMatrix = function () {
</P><P>			return standingMatrix;
</P><P>		};
</P><P>		this.isPresenting = isPresenting;
</P><P>		// Animation Loop
</P><P>		var animation = new WebGLAnimation();
</P><P>		this.setAnimationLoop = function ( callback ) {
</P><P>			animation.setAnimationLoop( callback );
</P><P>		};
</P><P>		this.submitFrame = function () {
</P><P>			if ( isPresenting() ) device.submitFrame();
</P><P>		};
</P><P>		this.dispose = function () {
</P><P>			if ( typeof window !== 'undefined' ) {
</P><P>				window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );
</P><P>			}
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function WebXRManager( renderer ) {
</P><P>		var gl = renderer.context;
</P><P>		var device = null;
		var session = null;
</P><P>		var frameOfReference = null;
		var frameOfReferenceType = 'stage';
</P><P>		var pose = null;
</P><P>		var controllers = [];
		var inputSources = [];
</P><P>		function isPresenting() {
</P><P>			return session !== null &amp;&amp; frameOfReference !== null;
</P><P>		}
</P><P>		//
</P><P>		var cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();
</P><P>		var cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();
</P><P>		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );
</P><P>		//
</P><P>		this.enabled = false;
</P><P>		this.getController = function ( id ) {
</P><P>			var controller = controllers[ id ];
</P><P>			if ( controller === undefined ) {
</P><P>				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;
</P><P>				controllers[ id ] = controller;
</P><P>			}
</P><P>			return controller;
</P><P>		};
</P><P>		this.getDevice = function () {
</P><P>			return device;
</P><P>		};
</P><P>		this.setDevice = function ( value ) {
</P><P>			if ( value !== undefined ) device = value;
			if ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value );
</P><P>		};
</P><P>		//
</P><P>		function onSessionEvent( event ) {
</P><P>			var controller = controllers[ inputSources.indexOf( event.inputSource ) ];
			if ( controller ) controller.dispatchEvent( { type: event.type } );
</P><P>		}
</P><P>		function onSessionEnd() {
</P><P>			renderer.setFramebuffer( null );
			animation.stop();
</P><P>		}
</P><P>		this.setFrameOfReferenceType = function ( value ) {
</P><P>			frameOfReferenceType = value;
</P><P>		};
</P><P>		this.setSession = function ( value ) {
</P><P>			session = value;
</P><P>			if ( session !== null ) {
</P><P>				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
</P><P>				session.baseLayer = new XRWebGLLayer( session, gl );
				session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) {
</P><P>					frameOfReference = value;
</P><P>					renderer.setFramebuffer( session.baseLayer.framebuffer );
</P><P>					animation.setContext( session );
					animation.start();
</P><P>				} );
</P><P>				//
</P><P>				inputSources = session.getInputSources();
</P><P>				session.addEventListener( 'inputsourceschange', function () {
</P><P>					inputSources = session.getInputSources();
					console.log( inputSources );
</P><P>				} );
</P><P>			}
</P><P>		};
</P><P>		function updateCamera( camera, parent ) {
</P><P>			if ( parent === null ) {
</P><P>				camera.matrixWorld.copy( camera.matrix );
</P><P>			} else {
</P><P>				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );
</P><P>			}
</P><P>			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
</P><P>		}
</P><P>		this.getCamera = function ( camera ) {
</P><P>			if ( isPresenting() ) {
</P><P>				var parent = camera.parent;
				var cameras = cameraVR.cameras;
</P><P>				// apply camera.parent to cameraVR
</P><P>				updateCamera( cameraVR, parent );
</P><P>				for ( var i = 0; i &lt; cameras.length; i ++ ) {
</P><P>					updateCamera( cameras[ i ], parent );
</P><P>				}
</P><P>				// update camera and its children
</P><P>				camera.matrixWorld.copy( cameraVR.matrixWorld );
</P><P>				var children = camera.children;
</P><P>				for ( var i = 0, l = children.length; i &lt; l; i ++ ) {
</P><P>					children[ i ].updateMatrixWorld( true );
</P><P>				}
</P><P>				return cameraVR;
</P><P>			}
</P><P>			return camera;
</P><P>		};
</P><P>		this.isPresenting = isPresenting;
</P><P>		// Animation Loop
</P><P>		var onAnimationFrameCallback = null;
</P><P>		function onAnimationFrame( time, frame ) {
</P><P>			pose = frame.getDevicePose( frameOfReference );
</P><P>			if ( pose !== null ) {
</P><P>				var layer = session.baseLayer;
				var views = frame.views;
</P><P>				for ( var i = 0; i &lt; views.length; i ++ ) {
</P><P>					var view = views[ i ];
					var viewport = layer.getViewport( view );
					var viewMatrix = pose.getViewMatrix( view );
</P><P>					var camera = cameraVR.cameras[ i ];
					camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );
</P><P>					if ( i === 0 ) {
</P><P>						cameraVR.matrix.copy( camera.matrix );
</P><P>						// HACK (mrdoob)
						// <A rel="nofollow" class="external free" href="https://github.com/w3c/webvr/issues/203">https://github.com/w3c/webvr/issues/203</A></P><P>						cameraVR.projectionMatrix.copy( camera.projectionMatrix );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			//
</P><P>			for ( var i = 0; i &lt; controllers.length; i ++ ) {
</P><P>				var controller = controllers[ i ];
</P><P>				var inputSource = inputSources[ i ];
</P><P>				if ( inputSource ) {
</P><P>					var inputPose = frame.getInputPose( inputSource, frameOfReference );
</P><P>					if ( inputPose !== null ) {
</P><P>						if ( 'targetRay' in inputPose ) {
</P><P>							controller.matrix.elements = inputPose.targetRay.transformMatrix;
</P><P>						} else if ( 'pointerMatrix' in inputPose ) {
</P><P>							// DEPRECATED
</P><P>							controller.matrix.elements = inputPose.pointerMatrix;
</P><P>						}
</P><P>						controller.matrix.decompose( controller.position, controller.rotation, controller.scale );
						controller.visible = true;
</P><P>						continue;
</P><P>					}
</P><P>				}
</P><P>				controller.visible = false;
</P><P>			}
</P><P>			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );
</P><P>		}
</P><P>		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );
</P><P>		this.setAnimationLoop = function ( callback ) {
</P><P>			onAnimationFrameCallback = callback;
</P><P>		};
</P><P>		this.dispose = function () {};
</P><P>		// DEPRECATED
</P><P>		this.getStandingMatrix = function () {
</P><P>			console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );
			return new THREE.Matrix4();
</P><P>		};
</P><P>		this.submitFrame = function () {};
</P><P>	}
</P><P>	/**
	 * @author supereggbert / <A rel="nofollow" class="external free" href="http://www.paulbrunt.co.uk/">http://www.paulbrunt.co.uk/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author szimek / <A rel="nofollow" class="external free" href="https://github.com/szimek/">https://github.com/szimek/</A>
	 * @author tschw
	 */
</P><P>	function WebGLRenderer( parameters ) {
</P><P>		console.log( 'THREE.WebGLRenderer', REVISION );
</P><P>		parameters = parameters || {};
</P><P>		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( '<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml'">http://www.w3.org/1999/xhtml'</A>, 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,
</P><P>			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';
</P><P>		var currentRenderList = null;
		var currentRenderState = null;
</P><P>		// public properties
</P><P>		this.domElement = _canvas;
		this.context = null;
</P><P>		// clearing
</P><P>		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
</P><P>		// scene graph
</P><P>		this.sortObjects = true;
</P><P>		// user-defined clipping
</P><P>		this.clippingPlanes = [];
		this.localClippingEnabled = false;
</P><P>		// physically based shading
</P><P>		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;
</P><P>		// physical lights
</P><P>		this.physicallyCorrectLights = false;
</P><P>		// tone mapping
</P><P>		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;
</P><P>		// morphs
</P><P>		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
</P><P>		// internal properties
</P><P>		var _this = this,
</P><P>			_isContextLost = false,
</P><P>			// internal state cache
</P><P>			_framebuffer = null,
</P><P>			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,
</P><P>			// geometry and program caching
</P><P>			_currentGeometryProgram = {
				geometry: null,
				program: null,
				wireframe: false
			},
</P><P>			_currentCamera = null,
			_currentArrayCamera = null,
</P><P>			_currentViewport = new Vector4(),
			_currentScissor = new Vector4(),
			_currentScissorTest = null,
</P><P>			//
</P><P>			_usedTextureUnits = 0,
</P><P>			//
</P><P>			_width = _canvas.width,
			_height = _canvas.height,
</P><P>			_pixelRatio = 1,
</P><P>			_viewport = new Vector4( 0, 0, _width, _height ),
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,
</P><P>			// frustum
</P><P>			_frustum = new Frustum(),
</P><P>			// clipping
</P><P>			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,
</P><P>			// camera matrices cache
</P><P>			_projScreenMatrix = new Matrix4(),
</P><P>			_vector3 = new Vector3();
</P><P>		function getTargetPixelRatio() {
</P><P>			return _currentRenderTarget === null ? _pixelRatio : 1;
</P><P>		}
</P><P>		// initialize
</P><P>		var _gl;
</P><P>		try {
</P><P>			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference
			};
</P><P>			// event listeners must be registered before WebGL context is created, see #12753
</P><P>			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
</P><P>			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );
</P><P>			if ( _gl === null ) {
</P><P>				if ( _canvas.getContext( 'webgl' ) !== null ) {
</P><P>					throw new Error( 'Error creating WebGL context with your selected attributes.' );
</P><P>				} else {
</P><P>					throw new Error( 'Error creating WebGL context.' );
</P><P>				}
</P><P>			}
</P><P>			// Some experimental-webgl implementations do not have getShaderPrecisionFormat
</P><P>			if ( _gl.getShaderPrecisionFormat === undefined ) {
</P><P>				_gl.getShaderPrecisionFormat = function () {
</P><P>					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
</P><P>				};
</P><P>			}
</P><P>		} catch ( error ) {
</P><P>			console.error( 'THREE.WebGLRenderer: ' + error.message );
</P><P>		}
</P><P>		var extensions, capabilities, state, info;
		var properties, textures, attributes, geometries, objects;
		var programCache, renderLists, renderStates;
</P><P>		var background, morphtargets, bufferRenderer, indexedBufferRenderer;
</P><P>		var utils;
</P><P>		function initGLContext() {
</P><P>			extensions = new WebGLExtensions( _gl );
</P><P>			capabilities = new WebGLCapabilities( _gl, extensions, parameters );
</P><P>			if ( ! capabilities.isWebGL2 ) {
</P><P>				extensions.get( 'WEBGL_depth_texture' );
				extensions.get( 'OES_texture_float' );
				extensions.get( 'OES_texture_half_float' );
				extensions.get( 'OES_texture_half_float_linear' );
				extensions.get( 'OES_standard_derivatives' );
				extensions.get( 'OES_element_index_uint' );
				extensions.get( 'ANGLE_instanced_arrays' );
</P><P>			}
</P><P>			extensions.get( 'OES_texture_float_linear' );
</P><P>			utils = new WebGLUtils( _gl, extensions, capabilities );
</P><P>			state = new WebGLState( _gl, extensions, utils, capabilities );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
</P><P>			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			attributes = new WebGLAttributes( _gl );
			geometries = new WebGLGeometries( _gl, attributes, info );
			objects = new WebGLObjects( geometries, info );
			morphtargets = new WebGLMorphtargets( _gl );
			programCache = new WebGLPrograms( _this, extensions, capabilities );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates();
</P><P>			background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );
</P><P>			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );
</P><P>			info.programs = programCache.programs;
</P><P>			_this.context = _gl;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;
</P><P>		}
</P><P>		initGLContext();
</P><P>		// vr
</P><P>		var vr = null;
</P><P>		if ( typeof navigator !== 'undefined' ) {
</P><P>			vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );
</P><P>		}
</P><P>		this.vr = vr;
</P><P>		// shadow map
</P><P>		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );
</P><P>		this.shadowMap = shadowMap;
</P><P>		// API
</P><P>		this.getContext = function () {
</P><P>			return _gl;
</P><P>		};
</P><P>		this.getContextAttributes = function () {
</P><P>			return _gl.getContextAttributes();
</P><P>		};
</P><P>		this.forceContextLoss = function () {
</P><P>			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();
</P><P>		};
</P><P>		this.forceContextRestore = function () {
</P><P>			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();
</P><P>		};
</P><P>		this.getPixelRatio = function () {
</P><P>			return _pixelRatio;
</P><P>		};
</P><P>		this.setPixelRatio = function ( value ) {
</P><P>			if ( value === undefined ) return;
</P><P>			_pixelRatio = value;
</P><P>			this.setSize( _width, _height, false );
</P><P>		};
</P><P>		this.getSize = function () {
</P><P>			return {
				width: _width,
				height: _height
			};
</P><P>		};
</P><P>		this.setSize = function ( width, height, updateStyle ) {
</P><P>			if ( vr.isPresenting() ) {
</P><P>				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;
</P><P>			}
</P><P>			_width = width;
			_height = height;
</P><P>			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;
</P><P>			if ( updateStyle !== false ) {
</P><P>				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
</P><P>			}
</P><P>			this.setViewport( 0, 0, width, height );
</P><P>		};
</P><P>		this.getDrawingBufferSize = function () {
</P><P>			return {
				width: _width * _pixelRatio,
				height: _height * _pixelRatio
			};
</P><P>		};
</P><P>		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {
</P><P>			_width = width;
			_height = height;
</P><P>			_pixelRatio = pixelRatio;
</P><P>			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;
</P><P>			this.setViewport( 0, 0, width, height );
</P><P>		};
</P><P>		this.getCurrentViewport = function () {
</P><P>			return _currentViewport;
</P><P>		};
</P><P>		this.setViewport = function ( x, y, width, height ) {
</P><P>			_viewport.set( x, _height - y - height, width, height );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
</P><P>		};
</P><P>		this.setScissor = function ( x, y, width, height ) {
</P><P>			_scissor.set( x, _height - y - height, width, height );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
</P><P>		};
</P><P>		this.setScissorTest = function ( boolean ) {
</P><P>			state.setScissorTest( _scissorTest = boolean );
</P><P>		};
</P><P>		// Clearing
</P><P>		this.getClearColor = function () {
</P><P>			return background.getClearColor();
</P><P>		};
</P><P>		this.setClearColor = function () {
</P><P>			background.setClearColor.apply( background, arguments );
</P><P>		};
</P><P>		this.getClearAlpha = function () {
</P><P>			return background.getClearAlpha();
</P><P>		};
</P><P>		this.setClearAlpha = function () {
</P><P>			background.setClearAlpha.apply( background, arguments );
</P><P>		};
</P><P>		this.clear = function ( color, depth, stencil ) {
</P><P>			var bits = 0;
</P><P>			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
</P><P>			_gl.clear( bits );
</P><P>		};
</P><P>		this.clearColor = function () {
</P><P>			this.clear( true, false, false );
</P><P>		};
</P><P>		this.clearDepth = function () {
</P><P>			this.clear( false, true, false );
</P><P>		};
</P><P>		this.clearStencil = function () {
</P><P>			this.clear( false, false, true );
</P><P>		};
</P><P>		//
</P><P>		this.dispose = function () {
</P><P>			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
</P><P>			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			objects.dispose();
</P><P>			vr.dispose();
</P><P>			animation.stop();
</P><P>		};
</P><P>		// Events
</P><P>		function onContextLost( event ) {
</P><P>			event.preventDefault();
</P><P>			console.log( 'THREE.WebGLRenderer: Context Lost.' );
</P><P>			_isContextLost = true;
</P><P>		}
</P><P>		function onContextRestore( /* event */ ) {
</P><P>			console.log( 'THREE.WebGLRenderer: Context Restored.' );
</P><P>			_isContextLost = false;
</P><P>			initGLContext();
</P><P>		}
</P><P>		function onMaterialDispose( event ) {
</P><P>			var material = event.target;
</P><P>			material.removeEventListener( 'dispose', onMaterialDispose );
</P><P>			deallocateMaterial( material );
</P><P>		}
</P><P>		// Buffer deallocation
</P><P>		function deallocateMaterial( material ) {
</P><P>			releaseMaterialProgramReference( material );
</P><P>			properties.remove( material );
</P><P>		}
</P><P>
		function releaseMaterialProgramReference( material ) {
</P><P>			var programInfo = properties.get( material ).program;
</P><P>			material.program = undefined;
</P><P>			if ( programInfo !== undefined ) {
</P><P>				programCache.releaseProgram( programInfo );
</P><P>			}
</P><P>		}
</P><P>		// Buffer rendering
</P><P>		function renderObjectImmediate( object, program ) {
</P><P>			object.render( function ( object ) {
</P><P>				_this.renderBufferImmediate( object, program );
</P><P>			} );
</P><P>		}
</P><P>		this.renderBufferImmediate = function ( object, program ) {
</P><P>			state.initAttributes();
</P><P>			var buffers = properties.get( object );
</P><P>			if ( object.hasPositions &amp;&amp; ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals &amp;&amp; ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs &amp;&amp; ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors &amp;&amp; ! buffers.color ) buffers.color = _gl.createBuffer();
</P><P>			var programAttributes = program.getAttributes();
</P><P>			if ( object.hasPositions ) {
</P><P>				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
</P><P>				state.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );
</P><P>			}
</P><P>			if ( object.hasNormals ) {
</P><P>				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
</P><P>				state.enableAttribute( programAttributes.normal );
				_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );
</P><P>			}
</P><P>			if ( object.hasUvs ) {
</P><P>				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
</P><P>				state.enableAttribute( programAttributes.uv );
				_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );
</P><P>			}
</P><P>			if ( object.hasColors ) {
</P><P>				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
</P><P>				state.enableAttribute( programAttributes.color );
				_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );
</P><P>			}
</P><P>			state.disableUnusedAttributes();
</P><P>			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
</P><P>			object.count = 0;
</P><P>		};
</P><P>		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
</P><P>			var frontFaceCW = ( object.isMesh &amp;&amp; object.normalMatrix.determinant() &lt; 0 );
</P><P>			state.setMaterial( material, frontFaceCW );
</P><P>			var program = setProgram( camera, fog, material, object );
</P><P>			var updateBuffers = false;
</P><P>			if ( _currentGeometryProgram.geometry !== geometry.id ||
				_currentGeometryProgram.program !== program.id ||
				_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {
</P><P>				_currentGeometryProgram.geometry = geometry.id;
				_currentGeometryProgram.program = program.id;
				_currentGeometryProgram.wireframe = material.wireframe === true;
				updateBuffers = true;
</P><P>			}
</P><P>			if ( object.morphTargetInfluences ) {
</P><P>				morphtargets.update( object, geometry, material, program );
</P><P>				updateBuffers = true;
</P><P>			}
</P><P>			//
</P><P>			var index = geometry.index;
			var position = geometry.attributes.position;
			var rangeFactor = 1;
</P><P>			if ( material.wireframe === true ) {
</P><P>				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;
</P><P>			}
</P><P>			var attribute;
			var renderer = bufferRenderer;
</P><P>			if ( index !== null ) {
</P><P>				attribute = attributes.get( index );
</P><P>				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );
</P><P>			}
</P><P>			if ( updateBuffers ) {
</P><P>				setupVertexAttributes( material, program, geometry );
</P><P>				if ( index !== null ) {
</P><P>					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );
</P><P>				}
</P><P>			}
</P><P>			//
</P><P>			var dataCount = Infinity;
</P><P>			if ( index !== null ) {
</P><P>				dataCount = index.count;
</P><P>			} else if ( position !== undefined ) {
</P><P>				dataCount = position.count;
</P><P>			}
</P><P>			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;
</P><P>			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;
</P><P>			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
</P><P>			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
</P><P>			if ( drawCount === 0 ) return;
</P><P>			//
</P><P>			if ( object.isMesh ) {
</P><P>				if ( material.wireframe === true ) {
</P><P>					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );
</P><P>				} else {
</P><P>					switch ( object.drawMode ) {
</P><P>						case TrianglesDrawMode:
							renderer.setMode( _gl.TRIANGLES );
							break;
</P><P>						case TriangleStripDrawMode:
							renderer.setMode( _gl.TRIANGLE_STRIP );
							break;
</P><P>						case TriangleFanDrawMode:
							renderer.setMode( _gl.TRIANGLE_FAN );
							break;
</P><P>					}
</P><P>				}
</P><P>
			} else if ( object.isLine ) {
</P><P>				var lineWidth = material.linewidth;
</P><P>				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
</P><P>				state.setLineWidth( lineWidth * getTargetPixelRatio() );
</P><P>				if ( object.isLineSegments ) {
</P><P>					renderer.setMode( _gl.LINES );
</P><P>				} else if ( object.isLineLoop ) {
</P><P>					renderer.setMode( _gl.LINE_LOOP );
</P><P>				} else {
</P><P>					renderer.setMode( _gl.LINE_STRIP );
</P><P>				}
</P><P>			} else if ( object.isPoints ) {
</P><P>				renderer.setMode( _gl.POINTS );
</P><P>			} else if ( object.isSprite ) {
</P><P>				renderer.setMode( _gl.TRIANGLES );
</P><P>			}
</P><P>			if ( geometry &amp;&amp; geometry.isInstancedBufferGeometry ) {
</P><P>				if ( geometry.maxInstancedCount &gt; 0 ) {
</P><P>					renderer.renderInstances( geometry, drawStart, drawCount );
</P><P>				}
</P><P>			} else {
</P><P>renderer.render( drawStart, drawCount );
</P><P>			}
</P><P>		};
</P><P>		function setupVertexAttributes( material, program, geometry ) {
</P><P>			if ( geometry &amp;&amp; geometry.isInstancedBufferGeometry &amp; ! capabilities.isWebGL2 ) {
</P><P>				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {
</P><P>					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
</P><P>				}
</P><P>			}
</P><P>			state.initAttributes();
</P><P>			var geometryAttributes = geometry.attributes;
</P><P>			var programAttributes = program.getAttributes();
</P><P>			var materialDefaultAttributeValues = material.defaultAttributeValues;
</P><P>			for ( var name in programAttributes ) {
</P><P>				var programAttribute = programAttributes[ name ];
</P><P>				if ( programAttribute &gt;= 0 ) {
</P><P>					var geometryAttribute = geometryAttributes[ name ];
</P><P>					if ( geometryAttribute !== undefined ) {
</P><P>						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;
</P><P>						var attribute = attributes.get( geometryAttribute );
</P><P>						// TODO Attribute may not be available on context restore
</P><P>						if ( attribute === undefined ) continue;
</P><P>						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;
</P><P>						if ( geometryAttribute.isInterleavedBufferAttribute ) {
</P><P>							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;
</P><P>							if ( data &amp;&amp; data.isInstancedInterleavedBuffer ) {
</P><P>								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );
</P><P>								if ( geometry.maxInstancedCount === undefined ) {
</P><P>									geometry.maxInstancedCount = data.meshPerAttribute * data.count;
</P><P>								}
</P><P>							} else {
</P><P>								state.enableAttribute( programAttribute );
</P><P>							}
</P><P>							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );
</P><P>						} else {
</P><P>							if ( geometryAttribute.isInstancedBufferAttribute ) {
</P><P>								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );
</P><P>								if ( geometry.maxInstancedCount === undefined ) {
</P><P>									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
</P><P>								}
</P><P>							} else {
</P><P>								state.enableAttribute( programAttribute );
</P><P>							}
</P><P>							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );
</P><P>						}
</P><P>					} else if ( materialDefaultAttributeValues !== undefined ) {
</P><P>						var value = materialDefaultAttributeValues[ name ];
</P><P>						if ( value !== undefined ) {
</P><P>							switch ( value.length ) {
</P><P>								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;
</P><P>								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;
</P><P>								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;
</P><P>								default:
									_gl.vertexAttrib1fv( programAttribute, value );
</P><P>							}
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			state.disableUnusedAttributes();
</P><P>		}
</P><P>		// Compile
</P><P>		this.compile = function ( scene, camera ) {
</P><P>			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();
</P><P>			scene.traverse( function ( object ) {
</P><P>				if ( object.isLight ) {
</P><P>					currentRenderState.pushLight( object );
</P><P>					if ( object.castShadow ) {
</P><P>						currentRenderState.pushShadow( object );
</P><P>					}
</P><P>				}
</P><P>			} );
</P><P>			currentRenderState.setupLights( camera );
</P><P>			scene.traverse( function ( object ) {
</P><P>				if ( object.material ) {
</P><P>					if ( Array.isArray( object.material ) ) {
</P><P>						for ( var i = 0; i &lt; object.material.length; i ++ ) {
</P><P>							initMaterial( object.material[ i ], scene.fog, object );
</P><P>						}
</P><P>					} else {
</P><P>						initMaterial( object.material, scene.fog, object );
</P><P>					}
</P><P>				}
</P><P>			} );
</P><P>		};
</P><P>		// Animation Loop
</P><P>		var onAnimationFrameCallback = null;
</P><P>		function onAnimationFrame( time ) {
</P><P>			if ( vr.isPresenting() ) return;
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );
</P><P>		}
</P><P>		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );
</P><P>		if ( typeof window !== 'undefined' ) animation.setContext( window );
</P><P>		this.setAnimationLoop = function ( callback ) {
</P><P>			onAnimationFrameCallback = callback;
			vr.setAnimationLoop( callback );
</P><P>			animation.start();
</P><P>		};
</P><P>		// Rendering
</P><P>		this.render = function ( scene, camera, renderTarget, forceClear ) {
</P><P>			if ( ! ( camera &amp;&amp; camera.isCamera ) ) {
</P><P>				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
</P><P>			}
</P><P>			if ( _isContextLost ) return;
</P><P>			// reset caching for this frame
</P><P>			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;
			_currentMaterialId = - 1;
			_currentCamera = null;
</P><P>			// update scene graph
</P><P>			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
</P><P>			// update camera matrices and frustum
</P><P>			if ( camera.parent === null ) camera.updateMatrixWorld();
</P><P>			if ( vr.enabled ) {
</P><P>				camera = vr.getCamera( camera );
</P><P>			}
</P><P>			//
</P><P>			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();
</P><P>			scene.onBeforeRender( _this, scene, camera, renderTarget );
</P><P>			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
</P><P>			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
</P><P>			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();
</P><P>			projectObject( scene, camera, _this.sortObjects );
</P><P>			if ( _this.sortObjects === true ) {
</P><P>				currentRenderList.sort();
</P><P>			}
</P><P>			//
</P><P>			if ( _clippingEnabled ) _clipping.beginShadows();
</P><P>			var shadowsArray = currentRenderState.state.shadowsArray;
</P><P>			shadowMap.render( shadowsArray, scene, camera );
</P><P>			currentRenderState.setupLights( camera );
</P><P>			if ( _clippingEnabled ) _clipping.endShadows();
</P><P>			//
</P><P>			if ( this.info.autoReset ) this.info.reset();
</P><P>			if ( renderTarget === undefined ) {
</P><P>				renderTarget = null;
</P><P>			}
</P><P>			this.setRenderTarget( renderTarget );
</P><P>			//
</P><P>			background.render( currentRenderList, scene, camera, forceClear );
</P><P>			// render scene
</P><P>			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;
</P><P>			if ( scene.overrideMaterial ) {
</P><P>				var overrideMaterial = scene.overrideMaterial;
</P><P>				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );
</P><P>			} else {
</P><P>				// opaque pass (front-to-back order)
</P><P>				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );
</P><P>				// transparent pass (back-to-front order)
</P><P>				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );
</P><P>			}
</P><P>			// Generate mipmap if we're using any kind of mipmap filtering
</P><P>			if ( renderTarget ) {
</P><P>				textures.updateRenderTargetMipmap( renderTarget );
</P><P>			}
</P><P>			// Ensure depth buffer writing is enabled so it can be cleared on next render
</P><P>			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );
</P><P>			state.setPolygonOffset( false );
</P><P>			scene.onAfterRender( _this, scene, camera );
</P><P>			if ( vr.enabled ) {
</P><P>				vr.submitFrame();
</P><P>			}
</P><P>			// _gl.finish();
</P><P>			currentRenderList = null;
			currentRenderState = null;
</P><P>		};
</P><P>		/*
		// TODO Duplicated code (Frustum)
</P><P>		var _sphere = new Sphere();
</P><P>		function isObjectViewable( object ) {
</P><P>			var geometry = object.geometry;
</P><P>			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();
</P><P>			_sphere.copy( geometry.boundingSphere ).
			applyMatrix4( object.matrixWorld );
</P><P>			return isSphereViewable( _sphere );
</P><P>		}
</P><P>		function isSpriteViewable( sprite ) {
</P><P>			_sphere.center.set( 0, 0, 0 );
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4( sprite.matrixWorld );
</P><P>			return isSphereViewable( _sphere );
</P><P>		}
</P><P>		function isSphereViewable( sphere ) {
</P><P>			if ( ! _frustum.intersectsSphere( sphere ) ) return false;
</P><P>			var numPlanes = _clipping.numPlanes;
</P><P>			if ( numPlanes === 0 ) return true;
</P><P>			var planes = _this.clippingPlanes,
</P><P>				center = sphere.center,
				negRad = - sphere.radius,
				i = 0;
</P><P>			do {
</P><P>				// out when deeper than radius in the negative halfspace
				if ( planes[ i ].distanceToPoint( center ) &lt; negRad ) return false;
</P><P>			} while ( ++ i !== numPlanes );
</P><P>			return true;
</P><P>		}
		*/
</P><P>		function projectObject( object, camera, sortObjects ) {
</P><P>			if ( object.visible === false ) return;
</P><P>			var visible = object.layers.test( camera.layers );
</P><P>			if ( visible ) {
</P><P>				if ( object.isLight ) {
</P><P>					currentRenderState.pushLight( object );
</P><P>					if ( object.castShadow ) {
</P><P>						currentRenderState.pushShadow( object );
</P><P>					}
</P><P>				} else if ( object.isSprite ) {
</P><P>					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {
</P><P>						if ( sortObjects ) {
</P><P>							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );
</P><P>						}
</P><P>						var geometry = objects.update( object );
						var material = object.material;
</P><P>						currentRenderList.push( object, geometry, material, _vector3.z, null );
</P><P>					}
</P><P>				} else if ( object.isImmediateRenderObject ) {
</P><P>					if ( sortObjects ) {
</P><P>						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );
</P><P>					}
</P><P>					currentRenderList.push( object, null, object.material, _vector3.z, null );
</P><P>				} else if ( object.isMesh || object.isLine || object.isPoints ) {
</P><P>					if ( object.isSkinnedMesh ) {
</P><P>						object.skeleton.update();
</P><P>					}
</P><P>					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {
</P><P>						if ( sortObjects ) {
</P><P>							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );
</P><P>						}
</P><P>						var geometry = objects.update( object );
						var material = object.material;
</P><P>						if ( Array.isArray( material ) ) {
</P><P>							var groups = geometry.groups;
</P><P>							for ( var i = 0, l = groups.length; i &lt; l; i ++ ) {
</P><P>								var group = groups[ i ];
								var groupMaterial = material[ group.materialIndex ];
</P><P>								if ( groupMaterial &amp;&amp; groupMaterial.visible ) {
</P><P>									currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );
</P><P>								}
</P><P>							}
</P><P>						} else if ( material.visible ) {
</P><P>							currentRenderList.push( object, geometry, material, _vector3.z, null );
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			var children = object.children;
</P><P>			for ( var i = 0, l = children.length; i &lt; l; i ++ ) {
</P><P>				projectObject( children[ i ], camera, sortObjects );
</P><P>			}
</P><P>		}
</P><P>		function renderObjects( renderList, scene, camera, overrideMaterial ) {
</P><P>			for ( var i = 0, l = renderList.length; i &lt; l; i ++ ) {
</P><P>				var renderItem = renderList[ i ];
</P><P>				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;
</P><P>				if ( camera.isArrayCamera ) {
</P><P>					_currentArrayCamera = camera;
</P><P>					var cameras = camera.cameras;
</P><P>					for ( var j = 0, jl = cameras.length; j &lt; jl; j ++ ) {
</P><P>						var camera2 = cameras[ j ];
</P><P>						if ( object.layers.test( camera2.layers ) ) {
</P><P>							if ( 'viewport' in camera2 ) { // XR
</P><P>								state.viewport( _currentViewport.copy( camera2.viewport ) );
</P><P>							} else {
</P><P>								var bounds = camera2.bounds;
</P><P>								var x = bounds.x * _width;
								var y = bounds.y * _height;
								var width = bounds.z * _width;
								var height = bounds.w * _height;
</P><P>								state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );
</P><P>							}
</P><P>							currentRenderState.setupLights( camera2 );
</P><P>							renderObject( object, scene, camera2, geometry, material, group );
</P><P>						}
</P><P>					}
</P><P>				} else {
</P><P>					_currentArrayCamera = null;
</P><P>					renderObject( object, scene, camera, geometry, material, group );
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		function renderObject( object, scene, camera, geometry, material, group ) {
</P><P>			object.onBeforeRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );
</P><P>			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
</P><P>			if ( object.isImmediateRenderObject ) {
</P><P>				state.setMaterial( material );
</P><P>				var program = setProgram( camera, scene.fog, material, object );
</P><P>				_currentGeometryProgram.geometry = null;
				_currentGeometryProgram.program = null;
				_currentGeometryProgram.wireframe = false;
</P><P>				renderObjectImmediate( object, program );
</P><P>			} else {
</P><P>				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );
</P><P>			}
</P><P>			object.onAfterRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );
</P><P>		}
</P><P>		function initMaterial( material, fog, object ) {
</P><P>			var materialProperties = properties.get( material );
</P><P>			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;
</P><P>			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;
</P><P>			var parameters = programCache.getParameters(
				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );
</P><P>			var code = programCache.getProgramCode( material, parameters );
</P><P>			var program = materialProperties.program;
			var programChange = true;
</P><P>			if ( program === undefined ) {
</P><P>				// new material
				material.addEventListener( 'dispose', onMaterialDispose );
</P><P>			} else if ( program.code !== code ) {
</P><P>				// changed glsl or parameters
				releaseMaterialProgramReference( material );
</P><P>			} else if ( lightsHash.stateID !== lightsStateHash.stateID ||
				lightsHash.directionalLength !== lightsStateHash.directionalLength ||
				lightsHash.pointLength !== lightsStateHash.pointLength ||
				lightsHash.spotLength !== lightsStateHash.spotLength ||
				lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
				lightsHash.hemiLength !== lightsStateHash.hemiLength ||
				lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {
</P><P>				lightsHash.stateID = lightsStateHash.stateID;
				lightsHash.directionalLength = lightsStateHash.directionalLength;
				lightsHash.pointLength = lightsStateHash.pointLength;
				lightsHash.spotLength = lightsStateHash.spotLength;
				lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
				lightsHash.hemiLength = lightsStateHash.hemiLength;
				lightsHash.shadowsLength = lightsStateHash.shadowsLength;
</P><P>				programChange = false;
</P><P>			} else if ( parameters.shaderID !== undefined ) {
</P><P>				// same glsl and uniform list
				return;
</P><P>			} else {
</P><P>				// only rebuild uniform list
				programChange = false;
</P><P>			}
</P><P>			if ( programChange ) {
</P><P>				if ( parameters.shaderID ) {
</P><P>					var shader = ShaderLib[ parameters.shaderID ];
</P><P>					materialProperties.shader = {
						name: material.type,
						uniforms: UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};
</P><P>				} else {
</P><P>					materialProperties.shader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};
</P><P>				}
</P><P>				material.onBeforeCompile( materialProperties.shader, _this );
</P><P>				// Computing code again as onBeforeCompile may have changed the shaders
				code = programCache.getProgramCode( material, parameters );
</P><P>				program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );
</P><P>				materialProperties.program = program;
				material.program = program;
</P><P>			}
</P><P>			var programAttributes = program.getAttributes();
</P><P>			if ( material.morphTargets ) {
</P><P>				material.numSupportedMorphTargets = 0;
</P><P>				for ( var i = 0; i &lt; _this.maxMorphTargets; i ++ ) {
</P><P>					if ( programAttributes[ 'morphTarget' + i ] &gt;= 0 ) {
</P><P>						material.numSupportedMorphTargets ++;
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			if ( material.morphNormals ) {
</P><P>				material.numSupportedMorphNormals = 0;
</P><P>				for ( var i = 0; i &lt; _this.maxMorphNormals; i ++ ) {
</P><P>					if ( programAttributes[ 'morphNormal' + i ] &gt;= 0 ) {
</P><P>						material.numSupportedMorphNormals ++;
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			var uniforms = materialProperties.shader.uniforms;
</P><P>			if ( ! material.isShaderMaterial &amp;&amp;
				! material.isRawShaderMaterial ||
				material.clipping === true ) {
</P><P>				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;
</P><P>			}
</P><P>			materialProperties.fog = fog;
</P><P>			// store the light setup it was created for
			if ( lightsHash === undefined ) {
</P><P>				materialProperties.lightsHash = lightsHash = {};
</P><P>			}
</P><P>			lightsHash.stateID = lightsStateHash.stateID;
			lightsHash.directionalLength = lightsStateHash.directionalLength;
			lightsHash.pointLength = lightsStateHash.pointLength;
			lightsHash.spotLength = lightsStateHash.spotLength;
			lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
			lightsHash.hemiLength = lightsStateHash.hemiLength;
			lightsHash.shadowsLength = lightsStateHash.shadowsLength;
</P><P>			if ( material.lights ) {
</P><P>				// wire up the material to this renderer's lighting state
</P><P>				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.hemisphereLights.value = lights.state.hemi;
</P><P>				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms
</P><P>			}
</P><P>			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
</P><P>			materialProperties.uniformsList = uniformsList;
</P><P>		}
</P><P>		function setProgram( camera, fog, material, object ) {
</P><P>			_usedTextureUnits = 0;
</P><P>			var materialProperties = properties.get( material );
			var lights = currentRenderState.state.lights;
</P><P>			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;
</P><P>			if ( _clippingEnabled ) {
</P><P>				if ( _localClippingEnabled || camera !== _currentCamera ) {
</P><P>					var useCache =
						camera === _currentCamera &amp;&amp;
						material.id === _currentMaterialId;
</P><P>					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache );
</P><P>				}
</P><P>			}
</P><P>			if ( material.needsUpdate === false ) {
</P><P>				if ( materialProperties.program === undefined ) {
</P><P>					material.needsUpdate = true;
</P><P>				} else if ( material.fog &amp;&amp; materialProperties.fog !== fog ) {
</P><P>					material.needsUpdate = true;
</P><P>				} else if ( material.lights &amp;&amp; ( lightsHash.stateID !== lightsStateHash.stateID ||
					lightsHash.directionalLength !== lightsStateHash.directionalLength ||
					lightsHash.pointLength !== lightsStateHash.pointLength ||
					lightsHash.spotLength !== lightsStateHash.spotLength ||
					lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
					lightsHash.hemiLength !== lightsStateHash.hemiLength ||
					lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {
</P><P>					material.needsUpdate = true;
</P><P>				} else if ( materialProperties.numClippingPlanes !== undefined &amp;&amp;
					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
					materialProperties.numIntersection !== _clipping.numIntersection ) ) {
</P><P>					material.needsUpdate = true;
</P><P>				}
</P><P>			}
</P><P>			if ( material.needsUpdate ) {
</P><P>				initMaterial( material, fog, object );
				material.needsUpdate = false;
</P><P>			}
</P><P>			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;
</P><P>			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.shader.uniforms;
</P><P>			if ( state.useProgram( program.program ) ) {
</P><P>				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
</P><P>			}
</P><P>			if ( material.id !== _currentMaterialId ) {
</P><P>				_currentMaterialId = material.id;
</P><P>				refreshMaterial = true;
</P><P>			}
</P><P>			if ( refreshProgram || _currentCamera !== camera ) {
</P><P>				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
</P><P>				if ( capabilities.logarithmicDepthBuffer ) {
</P><P>					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
</P><P>				}
</P><P>				if ( _currentCamera !== camera ) {
</P><P>					_currentCamera = camera;
</P><P>					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:
</P><P>					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done
</P><P>				}
</P><P>				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
</P><P>				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {
</P><P>					var uCamPos = p_uniforms.map.cameraPosition;
</P><P>					if ( uCamPos !== undefined ) {
</P><P>						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );
</P><P>					}
</P><P>				}
</P><P>				if ( material.isMeshPhongMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.skinning ) {
</P><P>					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
</P><P>				}
</P><P>			}
</P><P>			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen
</P><P>			if ( material.skinning ) {
</P><P>				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
</P><P>				var skeleton = object.skeleton;
</P><P>				if ( skeleton ) {
</P><P>					var bones = skeleton.bones;
</P><P>					if ( capabilities.floatVertexTextures ) {
</P><P>						if ( skeleton.boneTexture === undefined ) {
</P><P>							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=&gt; column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
</P><P>
							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = _Math.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );
</P><P>							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values
</P><P>							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
							boneTexture.needsUpdate = true;
</P><P>							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;
</P><P>						}
</P><P>						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );
</P><P>					} else {
</P><P>						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			if ( refreshMaterial ) {
</P><P>				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );
</P><P>				if ( material.lights ) {
</P><P>					// the current material requires lighting info
</P><P>					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
</P><P>					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
</P><P>				}
</P><P>				// refresh uniforms common to several materials
</P><P>				if ( fog &amp;&amp; material.fog ) {
</P><P>					refreshUniformsFog( m_uniforms, fog );
</P><P>				}
</P><P>				if ( material.isMeshBasicMaterial ) {
</P><P>					refreshUniformsCommon( m_uniforms, material );
</P><P>				} else if ( material.isMeshLambertMaterial ) {
</P><P>					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsLambert( m_uniforms, material );
</P><P>				} else if ( material.isMeshPhongMaterial ) {
</P><P>					refreshUniformsCommon( m_uniforms, material );
</P><P>					if ( material.isMeshToonMaterial ) {
</P><P>					refreshUniformsToon( m_uniforms, material );
</P><P>					} else {
</P><P>						refreshUniformsPhong( m_uniforms, material );
</P><P>					}
</P><P>				} else if ( material.isMeshStandardMaterial ) {
</P><P>					refreshUniformsCommon( m_uniforms, material );
</P><P>					if ( material.isMeshPhysicalMaterial ) {
</P><P>						refreshUniformsPhysical( m_uniforms, material );
</P><P>					} else {
</P><P>						refreshUniformsStandard( m_uniforms, material );
</P><P>					}
</P><P>				} else if ( material.isMeshMatcapMaterial ) {
</P><P>					refreshUniformsCommon( m_uniforms, material );
</P><P>					refreshUniformsMatcap( m_uniforms, material );
</P><P>				} else if ( material.isMeshDepthMaterial ) {
</P><P>					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDepth( m_uniforms, material );
</P><P>				} else if ( material.isMeshDistanceMaterial ) {
</P><P>					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDistance( m_uniforms, material );
</P><P>				} else if ( material.isMeshNormalMaterial ) {
</P><P>					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsNormal( m_uniforms, material );
</P><P>				} else if ( material.isLineBasicMaterial ) {
</P><P>					refreshUniformsLine( m_uniforms, material );
</P><P>					if ( material.isLineDashedMaterial ) {
</P><P>						refreshUniformsDash( m_uniforms, material );
</P><P>					}
</P><P>				} else if ( material.isPointsMaterial ) {
</P><P>					refreshUniformsPoints( m_uniforms, material );
</P><P>				} else if ( material.isSpriteMaterial ) {
</P><P>					refreshUniformsSprites( m_uniforms, material );
</P><P>				} else if ( material.isShadowMaterial ) {
</P><P>					m_uniforms.color.value = material.color;
					m_uniforms.opacity.value = material.opacity;
</P><P>				}
</P><P>				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation
</P><P>				if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
				if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
</P><P>				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );
</P><P>			}
</P><P>			if ( material.isShaderMaterial &amp;&amp; material.uniformsNeedUpdate === true ) {
</P><P>				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );
				material.uniformsNeedUpdate = false;
</P><P>			}
</P><P>			if ( material.isSpriteMaterial ) {
</P><P>				p_uniforms.setValue( _gl, 'center', object.center );
</P><P>			}
</P><P>			// common matrices
</P><P>			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
</P><P>			return program;
</P><P>		}
</P><P>		// Uniforms (refresh uniforms objects)
</P><P>		function refreshUniformsCommon( uniforms, material ) {
</P><P>			uniforms.opacity.value = material.opacity;
</P><P>			if ( material.color ) {
</P><P>				uniforms.diffuse.value = material.color;
</P><P>			}
</P><P>			if ( material.emissive ) {
</P><P>				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
</P><P>			}
</P><P>			if ( material.map ) {
</P><P>				uniforms.map.value = material.map;
</P><P>			}
</P><P>			if ( material.alphaMap ) {
</P><P>				uniforms.alphaMap.value = material.alphaMap;
</P><P>			}
</P><P>			if ( material.specularMap ) {
</P><P>				uniforms.specularMap.value = material.specularMap;
</P><P>			}
</P><P>			if ( material.envMap ) {
</P><P>				uniforms.envMap.value = material.envMap;
</P><P>				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap &amp;&amp; material.envMap.isCubeTexture ) ) ? 1 : - 1;
</P><P>				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;
</P><P>				uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;
</P><P>			}
</P><P>			if ( material.lightMap ) {
</P><P>				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
</P><P>			}
</P><P>			if ( material.aoMap ) {
</P><P>				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
</P><P>			}
</P><P>			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map
</P><P>			var uvScaleMap;
</P><P>			if ( material.map ) {
</P><P>				uvScaleMap = material.map;
</P><P>			} else if ( material.specularMap ) {
</P><P>				uvScaleMap = material.specularMap;
</P><P>			} else if ( material.displacementMap ) {
</P><P>				uvScaleMap = material.displacementMap;
</P><P>			} else if ( material.normalMap ) {
</P><P>				uvScaleMap = material.normalMap;
</P><P>			} else if ( material.bumpMap ) {
</P><P>				uvScaleMap = material.bumpMap;
</P><P>			} else if ( material.roughnessMap ) {
</P><P>				uvScaleMap = material.roughnessMap;
</P><P>			} else if ( material.metalnessMap ) {
</P><P>				uvScaleMap = material.metalnessMap;
</P><P>			} else if ( material.alphaMap ) {
</P><P>				uvScaleMap = material.alphaMap;
</P><P>			} else if ( material.emissiveMap ) {
</P><P>				uvScaleMap = material.emissiveMap;
</P><P>			}
</P><P>			if ( uvScaleMap !== undefined ) {
</P><P>				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {
</P><P>					uvScaleMap = uvScaleMap.texture;
</P><P>				}
</P><P>				if ( uvScaleMap.matrixAutoUpdate === true ) {
</P><P>					uvScaleMap.updateMatrix();
</P><P>				}
</P><P>				uniforms.uvTransform.value.copy( uvScaleMap.matrix );
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsLine( uniforms, material ) {
</P><P>	uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
</P><P>		}
</P><P>		function refreshUniformsDash( uniforms, material ) {
</P><P>			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
</P><P>		}
</P><P>		function refreshUniformsPoints( uniforms, material ) {
</P><P>			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;
</P><P>			uniforms.map.value = material.map;
</P><P>			if ( material.map !== null ) {
</P><P>				if ( material.map.matrixAutoUpdate === true ) {
</P><P>					material.map.updateMatrix();
</P><P>				}
</P><P>				uniforms.uvTransform.value.copy( material.map.matrix );
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsSprites( uniforms, material ) {
</P><P>			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;
			uniforms.map.value = material.map;
</P><P>			if ( material.map !== null ) {
</P><P>				if ( material.map.matrixAutoUpdate === true ) {
</P><P>					material.map.updateMatrix();
</P><P>				}
</P><P>				uniforms.uvTransform.value.copy( material.map.matrix );
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsFog( uniforms, fog ) {
</P><P>			uniforms.fogColor.value = fog.color;
</P><P>			if ( fog.isFog ) {
</P><P>				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
</P><P>			} else if ( fog.isFogExp2 ) {
</P><P>				uniforms.fogDensity.value = fog.density;
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsLambert( uniforms, material ) {
</P><P>			if ( material.emissiveMap ) {
</P><P>				uniforms.emissiveMap.value = material.emissiveMap;
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsPhong( uniforms, material ) {
</P><P>			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
</P><P>			if ( material.emissiveMap ) {
</P><P>				uniforms.emissiveMap.value = material.emissiveMap;
</P><P>			}
</P><P>			if ( material.bumpMap ) {
</P><P>				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
</P><P>			}
</P><P>			if ( material.normalMap ) {
</P><P>				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();
</P><P>			}
</P><P>			if ( material.displacementMap ) {
</P><P>				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsToon( uniforms, material ) {
</P><P>			refreshUniformsPhong( uniforms, material );
</P><P>			if ( material.gradientMap ) {
</P><P>				uniforms.gradientMap.value = material.gradientMap;
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsStandard( uniforms, material ) {
</P><P>			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;
</P><P>			if ( material.roughnessMap ) {
</P><P>				uniforms.roughnessMap.value = material.roughnessMap;
</P><P>			}
</P><P>			if ( material.metalnessMap ) {
</P><P>				uniforms.metalnessMap.value = material.metalnessMap;
</P><P>			}
</P><P>			if ( material.emissiveMap ) {
</P><P>				uniforms.emissiveMap.value = material.emissiveMap;
</P><P>			}
</P><P>			if ( material.bumpMap ) {
</P><P>				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
</P><P>			}
</P><P>			if ( material.normalMap ) {
</P><P>				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();
</P><P>			}
</P><P>			if ( material.displacementMap ) {
</P><P>				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
</P><P>			}
</P><P>			if ( material.envMap ) {
</P><P>				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsPhysical( uniforms, material ) {
</P><P>			refreshUniformsStandard( uniforms, material );
</P><P>			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common
</P><P>			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
</P><P>		}
</P><P>		function refreshUniformsMatcap( uniforms, material ) {
</P><P>			if ( material.matcap ) {
</P><P>				uniforms.matcap.value = material.matcap;
</P><P>			}
</P><P>			if ( material.bumpMap ) {
</P><P>				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
</P><P>			}
</P><P>			if ( material.normalMap ) {
</P><P>				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();
</P><P>			}
</P><P>			if ( material.displacementMap ) {
</P><P>				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsDepth( uniforms, material ) {
</P><P>			if ( material.displacementMap ) {
</P><P>				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
</P><P>			}
</P><P>		}
</P><P>		function refreshUniformsDistance( uniforms, material ) {
</P><P>			if ( material.displacementMap ) {
</P><P>				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
</P><P>			}
</P><P>			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
</P><P>		}
</P><P>		function refreshUniformsNormal( uniforms, material ) {
</P><P>			if ( material.bumpMap ) {
</P><P>				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
</P><P>			}
</P><P>			if ( material.normalMap ) {
</P><P>				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();
</P><P>			}
</P><P>			if ( material.displacementMap ) {
</P><P>				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
</P><P>			}
</P><P>		}
</P><P>		// If uniforms are marked as clean, they don't need to be loaded to the GPU.
</P><P>		function markUniformsLightsNeedsUpdate( uniforms, value ) {
</P><P>			uniforms.ambientLightColor.needsUpdate = value;
</P><P>			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
</P><P>		}
</P><P>		// Textures
</P><P>		function allocTextureUnit() {
</P><P>			var textureUnit = _usedTextureUnits;
</P><P>			if ( textureUnit &gt;= capabilities.maxTextures ) {
</P><P>				console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
</P><P>			}
</P><P>			_usedTextureUnits += 1;
</P><P>			return textureUnit;
</P><P>		}
</P><P>		this.allocTextureUnit = allocTextureUnit;
</P><P>		// this.setTexture2D = setTexture2D;
		this.setTexture2D = ( function () {
</P><P>			var warned = false;
</P><P>			// backwards compatibility: peel texture.texture
			return function setTexture2D( texture, slot ) {
</P><P>				if ( texture &amp;&amp; texture.isWebGLRenderTarget ) {
</P><P>					if ( ! warned ) {
</P><P>						console.warn( &quot;THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.&quot; );
						warned = true;
</P><P>					}
</P><P>					texture = texture.texture;
</P><P>				}
</P><P>				textures.setTexture2D( texture, slot );
</P><P>			};
</P><P>		}() );
</P><P>		this.setTexture3D = ( function () {
</P><P>			// backwards compatibility: peel texture.texture
			return function setTexture3D( texture, slot ) {
</P><P>				textures.setTexture3D( texture, slot );
</P><P>			};
</P><P>		}() );
</P><P>		this.setTexture = ( function () {
</P><P>			var warned = false;
</P><P>			return function setTexture( texture, slot ) {
</P><P>				if ( ! warned ) {
</P><P>					console.warn( &quot;THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.&quot; );
					warned = true;
</P><P>				}
</P><P>				textures.setTexture2D( texture, slot );
</P><P>			};
</P><P>		}() );
</P><P>		this.setTextureCube = ( function () {
</P><P>			var warned = false;
</P><P>			return function setTextureCube( texture, slot ) {
</P><P>				// backwards compatibility: peel texture.texture
				if ( texture &amp;&amp; texture.isWebGLRenderTargetCube ) {
</P><P>					if ( ! warned ) {
</P><P>						console.warn( &quot;THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.&quot; );
						warned = true;
</P><P>					}
</P><P>					texture = texture.texture;
</P><P>				}
</P><P>				// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if ( ( texture &amp;&amp; texture.isCubeTexture ) ||
					( Array.isArray( texture.image ) &amp;&amp; texture.image.length === 6 ) ) {
</P><P>					// CompressedTexture can have Array in image :/
</P><P>					// this function alone should take care of cube textures
					textures.setTextureCube( texture, slot );
</P><P>				} else {
</P><P>					// assumed: texture property of THREE.WebGLRenderTargetCube
</P><P>					textures.setTextureCubeDynamic( texture, slot );
</P><P>				}
</P><P>			};
</P><P>		}() );
</P><P>		//
</P><P>		this.setFramebuffer = function ( value ) {
</P><P>			_framebuffer = value;
</P><P>		};
</P><P>		this.getRenderTarget = function () {
</P><P>			return _currentRenderTarget;
</P><P>		};
</P><P>		this.setRenderTarget = function ( renderTarget ) {
</P><P>			_currentRenderTarget = renderTarget;
</P><P>			if ( renderTarget &amp;&amp; properties.get( renderTarget ).__webglFramebuffer === undefined ) {
</P><P>				textures.setupRenderTarget( renderTarget );
</P><P>			}
</P><P>			var framebuffer = _framebuffer;
			var isCube = false;
</P><P>			if ( renderTarget ) {
</P><P>				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;
</P><P>				if ( renderTarget.isWebGLRenderTargetCube ) {
</P><P>					framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
					isCube = true;
</P><P>				} else {
</P><P>					framebuffer = __webglFramebuffer;
</P><P>				}
</P><P>				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;
</P><P>			} else {
</P><P>				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;
</P><P>			}
</P><P>			if ( _currentFramebuffer !== framebuffer ) {
</P><P>				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;
</P><P>			}
</P><P>			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );
</P><P>			if ( isCube ) {
</P><P>				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );
</P><P>			}
</P><P>		};
</P><P>		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
</P><P>			if ( ! ( renderTarget &amp;&amp; renderTarget.isWebGLRenderTarget ) ) {
</P><P>				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;
</P><P>			}
</P><P>			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
</P><P>			if ( framebuffer ) {
</P><P>				var restore = false;
</P><P>				if ( framebuffer !== _currentFramebuffer ) {
</P><P>					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
</P><P>					restore = true;
</P><P>				}
</P><P>				try {
</P><P>					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;
</P><P>					if ( textureFormat !== RGBAFormat &amp;&amp; utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
</P><P>						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;
</P><P>					}
</P><P>					if ( textureType !== UnsignedByteType &amp;&amp; utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &amp;&amp; // IE11, Edge and Chrome Mac &lt; 52 (#9513)
						! ( textureType === FloatType &amp;&amp; ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) &amp;&amp; // Chrome Mac &gt;= 52 and Firefox
						! ( textureType === HalfFloatType &amp;&amp; ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {
</P><P>						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;
</P><P>					}
</P><P>					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
</P><P>						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
</P><P>						if ( ( x &gt;= 0 &amp;&amp; x &lt;= ( renderTarget.width - width ) ) &amp;&amp; ( y &gt;= 0 &amp;&amp; y &lt;= ( renderTarget.height - height ) ) ) {
</P><P>							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );
</P><P>						}
</P><P>					} else {
</P><P>						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
</P><P>					}
</P><P>				} finally {
</P><P>					if ( restore ) {
</P><P>						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>		};
</P><P>		this.copyFramebufferToTexture = function ( position, texture, level ) {
</P><P>			var width = texture.image.width;
			var height = texture.image.height;
			var glFormat = utils.convert( texture.format );
</P><P>			this.setTexture2D( texture, 0 );
</P><P>			_gl.copyTexImage2D( _gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0 );
</P><P>		};
</P><P>		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {
</P><P>			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert( dstTexture.format );
			var glType = utils.convert( dstTexture.type );
</P><P>			this.setTexture2D( dstTexture, 0 );
</P><P>			if ( srcTexture.isDataTexture ) {
</P><P>				_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );
</P><P>			} else {
</P><P>				_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );
</P><P>			}
</P><P>		};
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function FogExp2( color, density ) {
</P><P>		this.name = <I>;</I></P><P>		this.color = new Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;
</P><P>	}
</P><P>	FogExp2.prototype.isFogExp2 = true;
</P><P>	FogExp2.prototype.clone = function () {
</P><P>		return new FogExp2( this.color, this.density );
</P><P>	};
</P><P>	FogExp2.prototype.toJSON = function ( /* meta */ ) {
</P><P>		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function Fog( color, near, far ) {
</P><P>		this.name = <I>;</I></P><P>		this.color = new Color( color );
</P><P>		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;
</P><P>	}
</P><P>	Fog.prototype.isFog = true;
</P><P>	Fog.prototype.clone = function () {
</P><P>		return new Fog( this.color, this.near, this.far );
</P><P>	};
</P><P>	Fog.prototype.toJSON = function ( /* meta */ ) {
</P><P>		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function Scene() {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Scene';
</P><P>		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;
</P><P>		this.autoUpdate = true; // checked by the renderer
</P><P>	}
</P><P>	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Scene,
</P><P>		copy: function ( source, recursive ) {
</P><P>			Object3D.prototype.copy.call( this, source, recursive );
</P><P>			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
</P><P>			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
</P><P>			return this;
</P><P>		},
</P><P>		toJSON: function ( meta ) {
</P><P>			var data = Object3D.prototype.toJSON.call( this, meta );
</P><P>			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
</P><P>			return data;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author benaadams / <A rel="nofollow" class="external free" href="https://twitter.com/ben_a_adams">https://twitter.com/ben_a_adams</A>
	 */
</P><P>	function InterleavedBuffer( array, stride ) {
</P><P>		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;
</P><P>		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
</P><P>		this.version = 0;
</P><P>	}
</P><P>	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {
</P><P>		set: function ( value ) {
</P><P>			if ( value === true ) this.version ++;
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( InterleavedBuffer.prototype, {
</P><P>		isInterleavedBuffer: true,
</P><P>		onUploadCallback: function () {},
</P><P>		setArray: function ( array ) {
</P><P>			if ( Array.isArray( array ) ) {
</P><P>				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
</P><P>			}
</P><P>			this.count = array !== undefined ? array.length / this.stride : 0;
			this.array = array;
</P><P>			return this;
</P><P>		},
</P><P>		setDynamic: function ( value ) {
</P><P>			this.dynamic = value;
</P><P>			return this;
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.dynamic = source.dynamic;
</P><P>			return this;
</P><P>		},
</P><P>		copyAt: function ( index1, attribute, index2 ) {
</P><P>			index1 *= this.stride;
			index2 *= attribute.stride;
</P><P>			for ( var i = 0, l = this.stride; i &lt; l; i ++ ) {
</P><P>				this.array[ index1 + i ] = attribute.array[ index2 + i ];
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		set: function ( value, offset ) {
</P><P>			if ( offset === undefined ) offset = 0;
</P><P>			this.array.set( value, offset );
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		onUpload: function ( callback ) {
</P><P>			this.onUploadCallback = callback;
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author benaadams / <A rel="nofollow" class="external free" href="https://twitter.com/ben_a_adams">https://twitter.com/ben_a_adams</A>
	 */
</P><P>	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {
</P><P>		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;
</P><P>		this.normalized = normalized === true;
</P><P>	}
</P><P>	Object.defineProperties( InterleavedBufferAttribute.prototype, {
</P><P>		count: {
</P><P>			get: function () {
</P><P>				return this.data.count;
</P><P>			}
</P><P>		},
</P><P>		array: {
</P><P>			get: function () {
</P><P>				return this.data.array;
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( InterleavedBufferAttribute.prototype, {
</P><P>		isInterleavedBufferAttribute: true,
</P><P>		setX: function ( index, x ) {
</P><P>			this.data.array[ index * this.data.stride + this.offset ] = x;
</P><P>			return this;
</P><P>		},
</P><P>		setY: function ( index, y ) {
</P><P>			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
</P><P>			return this;
</P><P>		},
</P><P>		setZ: function ( index, z ) {
</P><P>			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
</P><P>			return this;
</P><P>		},
</P><P>		setW: function ( index, w ) {
</P><P>			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
</P><P>			return this;
</P><P>		},
</P><P>		getX: function ( index ) {
</P><P>			return this.data.array[ index * this.data.stride + this.offset ];
</P><P>		},
</P><P>		getY: function ( index ) {
</P><P>			return this.data.array[ index * this.data.stride + this.offset + 1 ];
</P><P>		},
</P><P>		getZ: function ( index ) {
</P><P>			return this.data.array[ index * this.data.stride + this.offset + 2 ];
</P><P>		},
</P><P>		getW: function ( index ) {
</P><P>			return this.data.array[ index * this.data.stride + this.offset + 3 ];
</P><P>		},
</P><P>		setXY: function ( index, x, y ) {
</P><P>			index = index * this.data.stride + this.offset;
</P><P>			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
</P><P>			return this;
</P><P>		},
</P><P>		setXYZ: function ( index, x, y, z ) {
</P><P>			index = index * this.data.stride + this.offset;
</P><P>			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
</P><P>			return this;
</P><P>		},
</P><P>		setXYZW: function ( index, x, y, z, w ) {
</P><P>			index = index * this.data.stride + this.offset;
</P><P>			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 *
	 * parameters = {
	 *  color: &lt;hex&gt;,
	 *  map: new THREE.Texture( &lt;Image&gt; ),
	 *  rotation: &lt;float&gt;,
	 *  sizeAttenuation: &lt;bool&gt;
	 * }
	 */
</P><P>	function SpriteMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'SpriteMaterial';
</P><P>		this.color = new Color( 0xffffff );
		this.map = null;
</P><P>		this.rotation = 0;
</P><P>		this.sizeAttenuation = true;
</P><P>		this.lights = false;
		this.transparent = true;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	SpriteMaterial.prototype = Object.create( Material.prototype );
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;
</P><P>	SpriteMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.color.copy( source.color );
		this.map = source.map;
</P><P>		this.rotation = source.rotation;
</P><P>		this.sizeAttenuation = source.sizeAttenuation;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	var geometry;
</P><P>	function Sprite( material ) {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Sprite';
</P><P>		if ( geometry === undefined ) {
</P><P>			geometry = new BufferGeometry();
</P><P>			var float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );
</P><P>			var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );
</P><P>			geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			geometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			geometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );
</P><P>		}
</P><P>		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();
</P><P>		this.center = new Vector2( 0.5, 0.5 );
</P><P>	}
</P><P>	Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Sprite,
</P><P>		isSprite: true,
</P><P>		raycast: ( function () {
</P><P>			var intersectPoint = new Vector3();
			var worldScale = new Vector3();
			var mvPosition = new Vector3();
</P><P>			var alignedPosition = new Vector2();
			var rotatedPosition = new Vector2();
			var viewWorldMatrix = new Matrix4();
</P><P>			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();
</P><P>			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();
</P><P>			function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {
</P><P>				// compute position in camera space
				alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );
</P><P>				// to check if rotation is not zero
				if ( sin !== undefined ) {
</P><P>					rotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );
					rotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );
</P><P>				} else {
</P><P>					rotatedPosition.copy( alignedPosition );
</P><P>				}
</P><P>
				vertexPosition.copy( mvPosition );
				vertexPosition.x += rotatedPosition.x;
				vertexPosition.y += rotatedPosition.y;
</P><P>				// transform to world space
				vertexPosition.applyMatrix4( viewWorldMatrix );
</P><P>			}
</P><P>			return function raycast( raycaster, intersects ) {
</P><P>				worldScale.setFromMatrixScale( this.matrixWorld );
				viewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );
				mvPosition.setFromMatrixPosition( this.modelViewMatrix );
</P><P>				var rotation = this.material.rotation;
				var sin, cos;
				if ( rotation !== 0 ) {
</P><P>					cos = Math.cos( rotation );
					sin = Math.sin( rotation );
</P><P>				}
</P><P>				var center = this.center;
</P><P>				transformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
</P><P>				uvA.set( 0, 0 );
				uvB.set( 1, 0 );
				uvC.set( 1, 1 );
</P><P>				// check first triangle
				var intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );
</P><P>				if ( intersect === null ) {
</P><P>					// check second triangle
					transformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
					uvB.set( 0, 1 );
</P><P>					intersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );
					if ( intersect === null ) {
</P><P>						return;
</P><P>					}
</P><P>				}
</P><P>				var distance = raycaster.ray.origin.distanceTo( intersectPoint );
</P><P>				if ( distance &lt; raycaster.near || distance &gt; raycaster.far ) return;
</P><P>				intersects.push( {
</P><P>					distance: distance,
					point: intersectPoint.clone(),
					uv: Triangle.getUV( intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() ),
					face: null,
					object: this
</P><P>				} );
</P><P>			};
</P><P>		}() ),
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.material ).copy( this );
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			Object3D.prototype.copy.call( this, source );
</P><P>			if ( source.center !== undefined ) this.center.copy( source.center );
</P><P>			return this;
</P><P>		}
</P><P>
	} );
</P><P>	/**
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function LOD() {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'LOD';
</P><P>		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );
</P><P>	}
</P><P>	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: LOD,
</P><P>		copy: function ( source ) {
</P><P>			Object3D.prototype.copy.call( this, source, false );
</P><P>			var levels = source.levels;
</P><P>			for ( var i = 0, l = levels.length; i &lt; l; i ++ ) {
</P><P>				var level = levels[ i ];
</P><P>				this.addLevel( level.object.clone(), level.distance );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		addLevel: function ( object, distance ) {
</P><P>			if ( distance === undefined ) distance = 0;
</P><P>			distance = Math.abs( distance );
</P><P>			var levels = this.levels;
</P><P>			for ( var l = 0; l &lt; levels.length; l ++ ) {
</P><P>				if ( distance &lt; levels[ l ].distance ) {
</P><P>					break;
</P><P>				}
</P><P>			}
</P><P>			levels.splice( l, 0, { distance: distance, object: object } );
</P><P>			this.add( object );
</P><P>		},
</P><P>		getObjectForDistance: function ( distance ) {
</P><P>			var levels = this.levels;
</P><P>			for ( var i = 1, l = levels.length; i &lt; l; i ++ ) {
</P><P>				if ( distance &lt; levels[ i ].distance ) {
</P><P>					break;
</P><P>				}
</P><P>			}
</P><P>			return levels[ i - 1 ].object;
</P><P>		},
</P><P>		raycast: ( function () {
</P><P>			var matrixPosition = new Vector3();
</P><P>			return function raycast( raycaster, intersects ) {
</P><P>				matrixPosition.setFromMatrixPosition( this.matrixWorld );
</P><P>				var distance = raycaster.ray.origin.distanceTo( matrixPosition );
</P><P>				this.getObjectForDistance( distance ).raycast( raycaster, intersects );
</P><P>			};
</P><P>		}() ),
</P><P>		update: function () {
</P><P>			var v1 = new Vector3();
			var v2 = new Vector3();
</P><P>			return function update( camera ) {
</P><P>				var levels = this.levels;
</P><P>				if ( levels.length &gt; 1 ) {
</P><P>					v1.setFromMatrixPosition( camera.matrixWorld );
					v2.setFromMatrixPosition( this.matrixWorld );
</P><P>					var distance = v1.distanceTo( v2 );
</P><P>					levels[ 0 ].object.visible = true;
</P><P>					for ( var i = 1, l = levels.length; i &lt; l; i ++ ) {
</P><P>						if ( distance &gt;= levels[ i ].distance ) {
</P><P>							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;
</P><P>						} else {
</P><P>							break;
</P><P>						}
</P><P>					}
</P><P>					for ( ; i &lt; l; i ++ ) {
</P><P>						levels[ i ].object.visible = false;
</P><P>					}
</P><P>				}
</P><P>			};
</P><P>		}(),
</P><P>		toJSON: function ( meta ) {
</P><P>			var data = Object3D.prototype.toJSON.call( this, meta );
</P><P>			data.object.levels = [];
</P><P>			var levels = this.levels;
</P><P>			for ( var i = 0, l = levels.length; i &lt; l; i ++ ) {
</P><P>				var level = levels[ i ];
</P><P>				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );
</P><P>			}
</P><P>			return data;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author michael guerrero / <A rel="nofollow" class="external free" href="http://realitymeltdown.com">http://realitymeltdown.com</A>
	 * @author ikerr / <A rel="nofollow" class="external free" href="http://verold.com">http://verold.com</A>
	 */
</P><P>	function Skeleton( bones, boneInverses ) {
</P><P>		// copy the bone array
</P><P>		bones = bones || [];
</P><P>		this.bones = bones.slice( 0 );
		this.boneMatrices = new Float32Array( this.bones.length * 16 );
</P><P>		// use the supplied bone inverses or calculate the inverses
</P><P>		if ( boneInverses === undefined ) {
</P><P>			this.calculateInverses();
</P><P>		} else {
</P><P>			if ( this.bones.length === boneInverses.length ) {
</P><P>				this.boneInverses = boneInverses.slice( 0 );
</P><P>	} else {
</P><P>				console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );
</P><P>				this.boneInverses = [];
</P><P>				for ( var i = 0, il = this.bones.length; i &lt; il; i ++ ) {
</P><P>					this.boneInverses.push( new Matrix4() );
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>	}
</P><P>	Object.assign( Skeleton.prototype, {
</P><P>		calculateInverses: function () {
</P><P>			this.boneInverses = [];
</P><P>			for ( var i = 0, il = this.bones.length; i &lt; il; i ++ ) {
</P><P>				var inverse = new Matrix4();
</P><P>				if ( this.bones[ i ] ) {
</P><P>					inverse.getInverse( this.bones[ i ].matrixWorld );
</P><P>				}
</P><P>				this.boneInverses.push( inverse );
</P><P>			}
</P><P>		},
</P><P>		pose: function () {
</P><P>			var bone, i, il;
</P><P>			// recover the bind-time world matrices
</P><P>			for ( i = 0, il = this.bones.length; i &lt; il; i ++ ) {
</P><P>				bone = this.bones[ i ];
</P><P>				if ( bone ) {
</P><P>					bone.matrixWorld.getInverse( this.boneInverses[ i ] );
</P><P>				}
</P><P>			}
</P><P>			// compute the local matrices, positions, rotations and scales
</P><P>			for ( i = 0, il = this.bones.length; i &lt; il; i ++ ) {
</P><P>				bone = this.bones[ i ];
</P><P>				if ( bone ) {
</P><P>					if ( bone.parent &amp;&amp; bone.parent.isBone ) {
</P><P>						bone.matrix.getInverse( bone.parent.matrixWorld );
						bone.matrix.multiply( bone.matrixWorld );
</P><P>					} else {
</P><P>						bone.matrix.copy( bone.matrixWorld );
</P><P>					}
</P><P>					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		update: ( function () {
</P><P>			var offsetMatrix = new Matrix4();
			var identityMatrix = new Matrix4();
</P><P>			return function update() {
</P><P>				var bones = this.bones;
				var boneInverses = this.boneInverses;
				var boneMatrices = this.boneMatrices;
				var boneTexture = this.boneTexture;
</P><P>				// flatten bone matrices to array
</P><P>				for ( var i = 0, il = bones.length; i &lt; il; i ++ ) {
</P><P>	// compute the offset between the current and the original transform
</P><P>					var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;
</P><P>					offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
					offsetMatrix.toArray( boneMatrices, i * 16 );
</P><P>				}
</P><P>				if ( boneTexture !== undefined ) {
</P><P>					boneTexture.needsUpdate = true;
</P><P>				}
</P><P>			};
</P><P>		} )(),
</P><P>		clone: function () {
</P><P>			return new Skeleton( this.bones, this.boneInverses );
</P><P>		},
</P><P>		getBoneByName: function ( name ) {
</P><P>			for ( var i = 0, il = this.bones.length; i &lt; il; i ++ ) {
</P><P>				var bone = this.bones[ i ];
</P><P>				if ( bone.name === name ) {
</P><P>					return bone;
</P><P>				}
</P><P>			}
</P><P>			return undefined;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author ikerr / <A rel="nofollow" class="external free" href="http://verold.com">http://verold.com</A>
	 */
</P><P>	function Bone() {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Bone';
</P><P>	}
</P><P>	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Bone,
</P><P>		isBone: true
</P><P>	} );
</P><P>	/**
	 * @author mikael emtinger / <A rel="nofollow" class="external free" href="http://gomo.se/">http://gomo.se/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author ikerr / <A rel="nofollow" class="external free" href="http://verold.com">http://verold.com</A>
	 */
</P><P>	function SkinnedMesh( geometry, material ) {
</P><P>		Mesh.call( this, geometry, material );
</P><P>		this.type = 'SkinnedMesh';
</P><P>		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();</P><P>		var bones = this.initBones();
		var skeleton = new Skeleton( bones );
</P><P>		this.bind( skeleton, this.matrixWorld );
</P><P>		this.normalizeSkinWeights();
</P><P>	}
</P><P>	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {
</P><P>		constructor: SkinnedMesh,
</P><P>		isSkinnedMesh: true,
</P><P>		initBones: function () {
</P><P>			var bones = [], bone, gbone;
			var i, il;
</P><P>			if ( this.geometry &amp;&amp; this.geometry.bones !== undefined ) {
</P><P>				// first, create array of 'Bone' objects from geometry data
</P><P>				for ( i = 0, il = this.geometry.bones.length; i &lt; il; i ++ ) {
</P><P>					gbone = this.geometry.bones[ i ];
</P><P>					// create new 'Bone' object
</P><P>					bone = new Bone();
					bones.push( bone );
</P><P>					// apply values
</P><P>					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
</P><P>				}
</P><P>				// second, create bone hierarchy
</P><P>				for ( i = 0, il = this.geometry.bones.length; i &lt; il; i ++ ) {
</P><P>					gbone = this.geometry.bones[ i ];
</P><P>					if ( ( gbone.parent !== - 1 ) &amp;&amp; ( gbone.parent !== null ) &amp;&amp; ( bones[ gbone.parent ] !== undefined ) ) {
</P><P>						// subsequent bones in the hierarchy
</P><P>						bones[ gbone.parent ].add( bones[ i ] );
</P><P>					} else {
</P><P>						// topmost bone, immediate child of the skinned mesh
</P><P>						this.add( bones[ i ] );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			// now the bones are part of the scene graph and children of the skinned mesh.
			// let's update the corresponding matrices
</P><P>			this.updateMatrixWorld( true );
</P><P>			return bones;
</P><P>		},
</P><P>		bind: function ( skeleton, bindMatrix ) {
</P><P>			this.skeleton = skeleton;
</P><P>			if ( bindMatrix === undefined ) {
</P><P>				this.updateMatrixWorld( true );
</P><P>				this.skeleton.calculateInverses();
</P><P>				bindMatrix = this.matrixWorld;
</P><P>			}
</P><P>			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.getInverse( bindMatrix );
</P><P>		},
</P><P>		pose: function () {
</P><P>			this.skeleton.pose();
</P><P>		},
</P><P>		normalizeSkinWeights: function () {
</P><P>			var scale, i;
</P><P>			if ( this.geometry &amp;&amp; this.geometry.isGeometry ) {
</P><P>				for ( i = 0; i &lt; this.geometry.skinWeights.length; i ++ ) {
</P><P>					var sw = this.geometry.skinWeights[ i ];
</P><P>					scale = 1.0 / sw.manhattanLength();
</P><P>					if ( scale !== Infinity ) {
</P><P>						sw.multiplyScalar( scale );
</P><P>					} else {
</P><P>						sw.set( 1, 0, 0, 0 ); // do something reasonable
</P><P>					}
</P><P>				}
</P><P>			} else if ( this.geometry &amp;&amp; this.geometry.isBufferGeometry ) {
</P><P>				var vec = new Vector4();
</P><P>				var skinWeight = this.geometry.attributes.skinWeight;
</P><P>				for ( i = 0; i &lt; skinWeight.count; i ++ ) {
</P><P>					vec.x = skinWeight.getX( i );
					vec.y = skinWeight.getY( i );
					vec.z = skinWeight.getZ( i );
					vec.w = skinWeight.getW( i );
</P><P>					scale = 1.0 / vec.manhattanLength();
</P><P>					if ( scale !== Infinity ) {
</P><P>						vec.multiplyScalar( scale );
</P><P>					} else {
</P><P>						vec.set( 1, 0, 0, 0 ); // do something reasonable
</P><P>					}
</P><P>					skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		updateMatrixWorld: function ( force ) {
</P><P>			Mesh.prototype.updateMatrixWorld.call( this, force );
</P><P>			if ( this.bindMode === 'attached' ) {
</P><P>				this.bindMatrixInverse.getInverse( this.matrixWorld );
</P><P>			} else if ( this.bindMode === 'detached' ) {
</P><P>				this.bindMatrixInverse.getInverse( this.bindMatrix );
</P><P>			} else {
</P><P>				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );
</P><P>			}
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.geometry, this.material ).copy( this );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 *
	 * parameters = {
	 *  color: &lt;hex&gt;,
	 *  opacity: &lt;float&gt;,
	 *
	 *  linewidth: &lt;float&gt;,
	 *  linecap: &quot;round&quot;,
	 *  linejoin: &quot;round&quot;
	 * }
	 */
</P><P>	function LineBasicMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'LineBasicMaterial';
</P><P>		this.color = new Color( 0xffffff );
</P><P>		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
</P><P>		this.lights = false;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	LineBasicMaterial.prototype = Object.create( Material.prototype );
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;
</P><P>	LineBasicMaterial.prototype.isLineBasicMaterial = true;
</P><P>	LineBasicMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.color.copy( source.color );
</P><P>		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function Line( geometry, material, mode ) {
</P><P>		if ( mode === 1 ) {
</P><P>			console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );
</P><P>		}
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Line';
</P><P>		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );
</P><P>	}
</P><P>	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Line,
</P><P>		isLine: true,
</P><P>		computeLineDistances: ( function () {
</P><P>			var start = new Vector3();
			var end = new Vector3();
</P><P>			return function computeLineDistances() {
</P><P>				var geometry = this.geometry;
</P><P>				if ( geometry.isBufferGeometry ) {
</P><P>					// we assume non-indexed geometry
</P><P>					if ( geometry.index === null ) {
</P><P>						var positionAttribute = geometry.attributes.position;
						var lineDistances = [ 0 ];
</P><P>						for ( var i = 1, l = positionAttribute.count; i &lt; l; i ++ ) {
</P><P>							start.fromBufferAttribute( positionAttribute, i - 1 );
							end.fromBufferAttribute( positionAttribute, i );
</P><P>							lineDistances[ i ] = lineDistances[ i - 1 ];
							lineDistances[ i ] += start.distanceTo( end );
</P><P>						}
</P><P>						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );
</P><P>					} else {
</P><P>						console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );
</P><P>					}
</P><P>				} else if ( geometry.isGeometry ) {
</P><P>					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;
</P><P>					lineDistances[ 0 ] = 0;
</P><P>					for ( var i = 1, l = vertices.length; i &lt; l; i ++ ) {
</P><P>						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );
</P><P>					}
</P><P>				}
</P><P>				return this;
</P><P>			};
</P><P>		}() ),
</P><P>		raycast: ( function () {
</P><P>			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();
</P><P>			return function raycast( raycaster, intersects ) {
</P><P>				var precision = raycaster.linePrecision;
</P><P>				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
</P><P>				// Checking boundingSphere distance to ray
</P><P>				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
</P><P>				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += precision;
</P><P>				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
</P><P>				//
</P><P>				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
</P><P>				var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localPrecisionSq = localPrecision * localPrecision;
</P><P>				var vStart = new Vector3();
				var vEnd = new Vector3();
				var interSegment = new Vector3();
				var interRay = new Vector3();
				var step = ( this &amp;&amp; this.isLineSegments ) ? 2 : 1;
</P><P>				if ( geometry.isBufferGeometry ) {
</P><P>					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;
</P><P>					if ( index !== null ) {
</P><P>						var indices = index.array;
</P><P>						for ( var i = 0, l = indices.length - 1; i &lt; l; i += step ) {
</P><P>							var a = indices[ i ];
							var b = indices[ i + 1 ];
</P><P>							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );
</P><P>							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
</P><P>							if ( distSq &gt; localPrecisionSq ) continue;
</P><P>							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
</P><P>							var distance = raycaster.ray.origin.distanceTo( interRay );
</P><P>							if ( distance &lt; raycaster.near || distance &gt; raycaster.far ) continue;
</P><P>							intersects.push( {
</P><P>								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
</P><P>							} );
</P><P>						}
</P><P>					} else {
</P><P>						for ( var i = 0, l = positions.length / 3 - 1; i &lt; l; i += step ) {
</P><P>							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );
</P><P>							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
</P><P>							if ( distSq &gt; localPrecisionSq ) continue;
</P><P>							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
</P><P>							var distance = raycaster.ray.origin.distanceTo( interRay );
</P><P>							if ( distance &lt; raycaster.near || distance &gt; raycaster.far ) continue;
</P><P>							intersects.push( {
</P><P>								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
</P><P>							} );
</P><P>						}
</P><P>					}
</P><P>				} else if ( geometry.isGeometry ) {
</P><P>					var vertices = geometry.vertices;
					var nbVertices = vertices.length;
</P><P>					for ( var i = 0; i &lt; nbVertices - 1; i += step ) {
</P><P>						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
</P><P>						if ( distSq &gt; localPrecisionSq ) continue;
</P><P>						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
</P><P>						var distance = raycaster.ray.origin.distanceTo( interRay );
</P><P>						if ( distance &lt; raycaster.near || distance &gt; raycaster.far ) continue;
</P><P>						intersects.push( {
</P><P>							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
</P><P>						} );
</P><P>					}
</P><P>				}
</P><P>			};
</P><P>		}() ),
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.geometry, this.material ).copy( this );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function LineSegments( geometry, material ) {
</P><P>		Line.call( this, geometry, material );
</P><P>		this.type = 'LineSegments';
</P><P>	}
</P><P>	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {
</P><P>		constructor: LineSegments,
</P><P>		isLineSegments: true,
</P><P>		computeLineDistances: ( function () {
</P><P>			var start = new Vector3();
			var end = new Vector3();
</P><P>			return function computeLineDistances() {
</P><P>				var geometry = this.geometry;
</P><P>				if ( geometry.isBufferGeometry ) {
</P><P>					// we assume non-indexed geometry
</P><P>					if ( geometry.index === null ) {
</P><P>						var positionAttribute = geometry.attributes.position;
						var lineDistances = [];
</P><P>						for ( var i = 0, l = positionAttribute.count; i &lt; l; i += 2 ) {
</P><P>							start.fromBufferAttribute( positionAttribute, i );
							end.fromBufferAttribute( positionAttribute, i + 1 );
</P><P>							lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
							lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );
</P><P>						}
</P><P>						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );
</P><P>					} else {
</P><P>						console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );
</P><P>					}
</P><P>				} else if ( geometry.isGeometry ) {
</P><P>					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;
</P><P>					for ( var i = 0, l = vertices.length; i &lt; l; i += 2 ) {
</P><P>						start.copy( vertices[ i ] );
						end.copy( vertices[ i + 1 ] );
</P><P>						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );
</P><P>					}
</P><P>				}
</P><P>				return this;
</P><P>			};
</P><P>		}() )
</P><P>	} );
</P><P>	/**
	 * @author mgreter / <A rel="nofollow" class="external free" href="http://github.com/mgreter">http://github.com/mgreter</A>
	 */
</P><P>	function LineLoop( geometry, material ) {
</P><P>		Line.call( this, geometry, material );
</P><P>		this.type = 'LineLoop';
</P><P>	}
</P><P>	LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {
</P><P>		constructor: LineLoop,
</P><P>		isLineLoop: true,
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 *
	 * parameters = {
	 *  color: &lt;hex&gt;,
	 *  opacity: &lt;float&gt;,
	 *  map: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  size: &lt;float&gt;,
	 *  sizeAttenuation: &lt;bool&gt;
	 *
	 *  morphTargets: &lt;bool&gt;
	 * }
	 */
</P><P>	function PointsMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'PointsMaterial';
</P><P>		this.color = new Color( 0xffffff );
</P><P>		this.map = null;
</P><P>		this.size = 1;
		this.sizeAttenuation = true;
</P><P>		this.morphTargets = false;
</P><P>		this.lights = false;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	PointsMaterial.prototype = Object.create( Material.prototype );
	PointsMaterial.prototype.constructor = PointsMaterial;
</P><P>	PointsMaterial.prototype.isPointsMaterial = true;
</P><P>	PointsMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.color.copy( source.color );
</P><P>		this.map = source.map;
</P><P>		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
</P><P>		this.morphTargets = source.morphTargets;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function Points( geometry, material ) {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Points';
</P><P>		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );
</P><P>	}
</P><P>	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Points,
</P><P>		isPoints: true,
</P><P>		raycast: ( function () {
</P><P>			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();
</P><P>			return function raycast( raycaster, intersects ) {
</P><P>				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;
</P><P>				// Checking boundingSphere distance to ray
</P><P>				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
</P><P>				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += threshold;
</P><P>				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
</P><P>				//
</P><P>				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
</P><P>				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;
				var position = new Vector3();
				var intersectPoint = new Vector3();
</P><P>				function testPoint( point, index ) {
</P><P>					var rayPointDistanceSq = ray.distanceSqToPoint( point );
</P><P>					if ( rayPointDistanceSq &lt; localThresholdSq ) {
</P><P>						ray.closestPointToPoint( point, intersectPoint );
						intersectPoint.applyMatrix4( matrixWorld );
</P><P>						var distance = raycaster.ray.origin.distanceTo( intersectPoint );
</P><P>						if ( distance &lt; raycaster.near || distance &gt; raycaster.far ) return;
</P><P>						intersects.push( {
</P><P>							distance: distance,
							distanceToRay: Math.sqrt( rayPointDistanceSq ),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object
</P><P>						} );
</P><P>					}
</P><P>				}
</P><P>				if ( geometry.isBufferGeometry ) {
</P><P>					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;
</P><P>					if ( index !== null ) {
</P><P>						var indices = index.array;
</P><P>						for ( var i = 0, il = indices.length; i &lt; il; i ++ ) {
</P><P>							var a = indices[ i ];
</P><P>							position.fromArray( positions, a * 3 );
</P><P>							testPoint( position, a );
</P><P>						}
</P><P>					} else {
</P><P>						for ( var i = 0, l = positions.length / 3; i &lt; l; i ++ ) {
</P><P>							position.fromArray( positions, i * 3 );
</P><P>							testPoint( position, i );
</P><P>						}
</P><P>					}
</P><P>				} else {
</P><P>					var vertices = geometry.vertices;
</P><P>					for ( var i = 0, l = vertices.length; i &lt; l; i ++ ) {
</P><P>						testPoint( vertices[ i ], i );
</P><P>					}
</P><P>				}
</P><P>			};
</P><P>		}() ),
</P><P>		clone: function () {
</P><P>			return new this.constructor( this.geometry, this.material ).copy( this );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
</P><P>		Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
</P><P>		this.generateMipmaps = false;
</P><P>	}
</P><P>	VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {
</P><P>		constructor: VideoTexture,
</P><P>		isVideoTexture: true,
</P><P>		update: function () {
</P><P>			var video = this.image;
</P><P>			if ( video.readyState &gt;= video.HAVE_CURRENT_DATA ) {
</P><P>				this.needsUpdate = true;
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
</P><P>		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
</P><P>		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;
</P><P>		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )
</P><P>		this.flipY = false;
</P><P>		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files
</P><P>		this.generateMipmaps = false;
</P><P>	}
</P><P>	CompressedTexture.prototype = Object.create( Texture.prototype );
	CompressedTexture.prototype.constructor = CompressedTexture;
</P><P>	CompressedTexture.prototype.isCompressedTexture = true;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
</P><P>		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
</P><P>		this.needsUpdate = true;
</P><P>	}
</P><P>	CanvasTexture.prototype = Object.create( Texture.prototype );
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;
</P><P>	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */
</P><P>	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {
</P><P>		format = format !== undefined ? format : DepthFormat;
</P><P>		if ( format !== DepthFormat &amp;&amp; format !== DepthStencilFormat ) {
</P><P>			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );
</P><P>		}
</P><P>		if ( type === undefined &amp;&amp; format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined &amp;&amp; format === DepthStencilFormat ) type = UnsignedInt248Type;
</P><P>		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
</P><P>		this.image = { width: width, height: height };
</P><P>		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
</P><P>		this.flipY = false;
		this.generateMipmaps	= false;
</P><P>	}
</P><P>	DepthTexture.prototype = Object.create( Texture.prototype );
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	function WireframeGeometry( geometry ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'WireframeGeometry';
</P><P>		// buffer
</P><P>		var vertices = [];
</P><P>		// helper variables
</P><P>		var i, j, l, o, ol;
		var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
		var vertex;
</P><P>		// different logic for Geometry and BufferGeometry
</P><P>		if ( geometry &amp;&amp; geometry.isGeometry ) {
</P><P>			// create a data structure that contains all edges without duplicates
</P><P>			var faces = geometry.faces;
</P><P>			for ( i = 0, l = faces.length; i &lt; l; i ++ ) {
</P><P>				var face = faces[ i ];
</P><P>				for ( j = 0; j &lt; 3; j ++ ) {
</P><P>					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
					edge[ 1 ] = Math.max( edge1, edge2 );
</P><P>					key = edge[ 0 ] + ',' + edge[ 1 ];
</P><P>					if ( edges[ key ] === undefined ) {
</P><P>						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			// generate vertices
</P><P>			for ( key in edges ) {
</P><P>				e = edges[ key ];
</P><P>				vertex = geometry.vertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>				vertex = geometry.vertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>			}
</P><P>		} else if ( geometry &amp;&amp; geometry.isBufferGeometry ) {
</P><P>			var position, indices, groups;
			var group, start, count;
			var index1, index2;
</P><P>			vertex = new Vector3();
</P><P>			if ( geometry.index !== null ) {
</P><P>				// indexed BufferGeometry
</P><P>				position = geometry.attributes.position;
				indices = geometry.index;
				groups = geometry.groups;
</P><P>				if ( groups.length === 0 ) {
</P><P>					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];
</P><P>				}
</P><P>				// create a data structure that contains all eges without duplicates
</P><P>				for ( o = 0, ol = groups.length; o &lt; ol; ++ o ) {
</P><P>					group = groups[ o ];
</P><P>					start = group.start;
					count = group.count;
</P><P>					for ( i = start, l = ( start + count ); i &lt; l; i += 3 ) {
</P><P>						for ( j = 0; j &lt; 3; j ++ ) {
</P><P>							edge1 = indices.getX( i + j );
							edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );
</P><P>							key = edge[ 0 ] + ',' + edge[ 1 ];
</P><P>							if ( edges[ key ] === undefined ) {
</P><P>								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
</P><P>							}
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>				// generate vertices
</P><P>				for ( key in edges ) {
</P><P>					e = edges[ key ];
</P><P>					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>				}
</P><P>			} else {
</P><P>				// non-indexed BufferGeometry
</P><P>				position = geometry.attributes.position;
</P><P>				for ( i = 0, l = ( position.count / 3 ); i &lt; l; i ++ ) {
</P><P>					for ( j = 0; j &lt; 3; j ++ ) {
</P><P>						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
</P><P>						index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>						index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
</P><P>	}
</P><P>	WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
	WireframeGeometry.prototype.constructor = WireframeGeometry;
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="https://github.com/zz85">https://github.com/zz85</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout <A rel="nofollow" class="external free" href="http://prideout.net/blog/?p=44">http://prideout.net/blog/?p=44</A>
	 */
</P><P>	// ParametricGeometry
</P><P>	function ParametricGeometry( func, slices, stacks ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'ParametricGeometry';
</P><P>		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};
</P><P>		this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
		this.mergeVertices();
</P><P>	}
</P><P>	ParametricGeometry.prototype = Object.create( Geometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;
</P><P>	// ParametricBufferGeometry
</P><P>	function ParametricBufferGeometry( func, slices, stacks ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'ParametricBufferGeometry';
</P><P>		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		var EPS = 0.00001;
</P><P>		var normal = new Vector3();
</P><P>		var p0 = new Vector3(), p1 = new Vector3();
		var pu = new Vector3(), pv = new Vector3();
</P><P>		var i, j;
</P><P>		if ( func.length &lt; 3 ) {
</P><P>			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );
</P><P>		}
</P><P>		// generate vertices, normals and uvs
</P><P>		var sliceCount = slices + 1;
</P><P>		for ( i = 0; i &lt;= stacks; i ++ ) {
</P><P>			var v = i / stacks;
</P><P>			for ( j = 0; j &lt;= slices; j ++ ) {
</P><P>				var u = j / slices;
</P><P>				// vertex
</P><P>				func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );
</P><P>				// normal
</P><P>				// approximate tangent vectors via finite differences
</P><P>				if ( u - EPS &gt;= 0 ) {
</P><P>					func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );
</P><P>				} else {
</P><P>					func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );
</P><P>				}
</P><P>				if ( v - EPS &gt;= 0 ) {
</P><P>					func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );
</P><P>				} else {
</P><P>					func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );
</P><P>				}
</P><P>				// cross product of tangent vectors returns surface normal
</P><P>				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );
</P><P>				// uv
</P><P>				uvs.push( u, v );
</P><P>			}
</P><P>		}
</P><P>		// generate indices
</P><P>		for ( i = 0; i &lt; stacks; i ++ ) {
</P><P>			for ( j = 0; j &lt; slices; j ++ ) {
</P><P>				var a = i * sliceCount + j;
				var b = i * sliceCount + j + 1;
				var c = ( i + 1 ) * sliceCount + j + 1;
				var d = ( i + 1 ) * sliceCount + j;
</P><P>				// faces one and two
</P><P>				indices.push( a, b, d );
				indices.push( b, c, d );
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>	}
</P><P>	ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
</P><P>	/**
	 * @author clockworkgeek / <A rel="nofollow" class="external free" href="https://github.com/clockworkgeek">https://github.com/clockworkgeek</A>
	 * @author timothypratley / <A rel="nofollow" class="external free" href="https://github.com/timothypratley">https://github.com/timothypratley</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// PolyhedronGeometry
</P><P>	function PolyhedronGeometry( vertices, indices, radius, detail ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'PolyhedronGeometry';
</P><P>		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};
</P><P>		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
		this.mergeVertices();
</P><P>	}
</P><P>	PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
</P><P>	// PolyhedronBufferGeometry
</P><P>	function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'PolyhedronBufferGeometry';
</P><P>		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};
</P><P>		radius = radius || 1;
		detail = detail || 0;
</P><P>		// default buffer data
</P><P>		var vertexBuffer = [];
		var uvBuffer = [];
</P><P>		// the subdivision creates the vertex buffer data
</P><P>		subdivide( detail );
</P><P>		// all vertices should lie on a conceptual sphere with a given radius
</P><P>		appplyRadius( radius );
</P><P>		// finally, create the uv data
</P><P>		generateUVs();
</P><P>		// build non-indexed geometry
</P><P>		this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
</P><P>		if ( detail === 0 ) {
</P><P>			this.computeVertexNormals(); // flat normals
</P><P>		} else {
</P><P>			this.normalizeNormals(); // smooth normals
</P><P>		}
</P><P>		// helper functions
</P><P>		function subdivide( detail ) {
</P><P>			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();
</P><P>			// iterate over all faces and apply a subdivison with the given detail value
</P><P>			for ( var i = 0; i &lt; indices.length; i += 3 ) {
</P><P>				// get the vertices of the face
</P><P>				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );
</P><P>				// perform subdivision
</P><P>				subdivideFace( a, b, c, detail );
</P><P>			}
</P><P>		}
</P><P>		function subdivideFace( a, b, c, detail ) {
</P><P>			var cols = Math.pow( 2, detail );
</P><P>			// we use this multidimensional array as a data structure for creating the subdivision
</P><P>			var v = [];
</P><P>			var i, j;
</P><P>			// construct all of the vertices for this subdivision
</P><P>			for ( i = 0; i &lt;= cols; i ++ ) {
</P><P>				v[ i ] = [];
</P><P>				var aj = a.clone().lerp( c, i / cols );
				var bj = b.clone().lerp( c, i / cols );
</P><P>				var rows = cols - i;
</P><P>				for ( j = 0; j &lt;= rows; j ++ ) {
</P><P>					if ( j === 0 &amp;&amp; i === cols ) {
</P><P>						v[ i ][ j ] = aj;
</P><P>					} else {
</P><P>v[ i ][ j ] = aj.clone().lerp( bj, j / rows );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			// construct all of the faces
</P><P>			for ( i = 0; i &lt; cols; i ++ ) {
</P><P>				for ( j = 0; j &lt; 2 * ( cols - i ) - 1; j ++ ) {
</P><P>					var k = Math.floor( j / 2 );
</P><P>					if ( j % 2 === 0 ) {
</P><P>						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );
</P><P>					} else {
</P><P>						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		function appplyRadius( radius ) {
</P><P>			var vertex = new Vector3();
</P><P>			// iterate over the entire buffer and apply the radius to each vertex
</P><P>			for ( var i = 0; i &lt; vertexBuffer.length; i += 3 ) {
</P><P>				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];
</P><P>				vertex.normalize().multiplyScalar( radius );
</P><P>				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;
</P><P>			}
</P><P>		}
</P><P>		function generateUVs() {
</P><P>			var vertex = new Vector3();
</P><P>			for ( var i = 0; i &lt; vertexBuffer.length; i += 3 ) {
</P><P>				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];
</P><P>				var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				var v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );
</P><P>			}
</P><P>			correctUVs();
</P><P>			correctSeam();
</P><P>		}
</P><P>		function correctSeam() {
</P><P>			// handle case when face straddles the seam, see #3269
</P><P>			for ( var i = 0; i &lt; uvBuffer.length; i += 6 ) {
</P><P>				// uv data of a single face
</P><P>				var x0 = uvBuffer[ i + 0 ];
				var x1 = uvBuffer[ i + 2 ];
				var x2 = uvBuffer[ i + 4 ];
</P><P>				var max = Math.max( x0, x1, x2 );
				var min = Math.min( x0, x1, x2 );
</P><P>				// 0.9 is somewhat arbitrary
</P><P>				if ( max &gt; 0.9 &amp;&amp; min &lt; 0.1 ) {
</P><P>					if ( x0 &lt; 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 &lt; 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 &lt; 0.2 ) uvBuffer[ i + 4 ] += 1;
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		function pushVertex( vertex ) {
</P><P>			vertexBuffer.push( vertex.x, vertex.y, vertex.z );
</P><P>		}
</P><P>		function getVertexByIndex( index, vertex ) {
</P><P>			var stride = index * 3;
</P><P>			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];
</P><P>		}
</P><P>		function correctUVs() {
</P><P>			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();
</P><P>			var centroid = new Vector3();
</P><P>			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();
</P><P>			for ( var i = 0, j = 0; i &lt; vertexBuffer.length; i += 9, j += 6 ) {
</P><P>				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );
</P><P>				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );
</P><P>				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );
</P><P>				var azi = azimuth( centroid );
</P><P>				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );
</P><P>			}
</P><P>		}
</P><P>		function correctUV( uv, stride, vector, azimuth ) {
</P><P>			if ( ( azimuth &lt; 0 ) &amp;&amp; ( uv.x === 1 ) ) {
</P><P>				uvBuffer[ stride ] = uv.x - 1;
</P><P>			}
</P><P>			if ( ( vector.x === 0 ) &amp;&amp; ( vector.z === 0 ) ) {
</P><P>				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;
</P><P>			}
</P><P>		}
</P><P>		// Angle around the Y axis, counter-clockwise when looking from above.
</P><P>		function azimuth( vector ) {
</P><P>			return Math.atan2( vector.z, - vector.x );
</P><P>		}
</P><P>
		// Angle above the XZ plane.
</P><P>		function inclination( vector ) {
</P><P>			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
</P><P>		}
</P><P>	}
</P><P>	PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
</P><P>	/**
	 * @author timothypratley / <A rel="nofollow" class="external free" href="https://github.com/timothypratley">https://github.com/timothypratley</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// TetrahedronGeometry
</P><P>	function TetrahedronGeometry( radius, detail ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'TetrahedronGeometry';
</P><P>		this.parameters = {
			radius: radius,
			detail: detail
		};
</P><P>		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();
</P><P>	}
</P><P>	TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
</P><P>	// TetrahedronBufferGeometry
</P><P>	function TetrahedronBufferGeometry( radius, detail ) {
</P><P>		var vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];
</P><P>		var indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];
</P><P>		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
</P><P>		this.type = 'TetrahedronBufferGeometry';
</P><P>		this.parameters = {
			radius: radius,
			detail: detail
		};
</P><P>	}
</P><P>	TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
</P><P>	/**
	 * @author timothypratley / <A rel="nofollow" class="external free" href="https://github.com/timothypratley">https://github.com/timothypratley</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// OctahedronGeometry
</P><P>	function OctahedronGeometry( radius, detail ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'OctahedronGeometry';
</P><P>		this.parameters = {
			radius: radius,
			detail: detail
		};
</P><P>		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();
</P><P>	}
</P><P>	OctahedronGeometry.prototype = Object.create( Geometry.prototype );
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;
</P><P>	// OctahedronBufferGeometry
</P><P>	function OctahedronBufferGeometry( radius, detail ) {
</P><P>		var vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];
</P><P>		var indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];
</P><P>		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
</P><P>		this.type = 'OctahedronBufferGeometry';
</P><P>		this.parameters = {
			radius: radius,
			detail: detail
		};
</P><P>	}
</P><P>	OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
</P><P>	/**
	 * @author timothypratley / <A rel="nofollow" class="external free" href="https://github.com/timothypratley">https://github.com/timothypratley</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// IcosahedronGeometry
</P><P>	function IcosahedronGeometry( radius, detail ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'IcosahedronGeometry';
</P><P>		this.parameters = {
			radius: radius,
			detail: detail
		};
</P><P>		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();
</P><P>	}
</P><P>	IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
</P><P>	// IcosahedronBufferGeometry
</P><P>	function IcosahedronBufferGeometry( radius, detail ) {
</P><P>		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
</P><P>		var vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];
</P><P>		var indices = [
			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];
</P><P>		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
</P><P>		this.type = 'IcosahedronBufferGeometry';
</P><P>		this.parameters = {
			radius: radius,
			detail: detail
		};
</P><P>	}
</P><P>	IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
</P><P>	/**
	 * @author Abe Pazos / <A rel="nofollow" class="external free" href="https://hamoid.com">https://hamoid.com</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// DodecahedronGeometry
</P><P>	function DodecahedronGeometry( radius, detail ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'DodecahedronGeometry';
</P><P>		this.parameters = {
			radius: radius,
			detail: detail
		};
</P><P>		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();
</P><P>	}
</P><P>	DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
</P><P>	// DodecahedronBufferGeometry
</P><P>	function DodecahedronBufferGeometry( radius, detail ) {
</P><P>		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;
</P><P>		var vertices = [
</P><P>			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,
</P><P>			// (0, ±1/φ, ±φ)
			 0, - r, - t, 0, - r, t,
			 0, r, - t, 0, r, t,
</P><P>			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			 r, - t, 0, r, t, 0,
</P><P>			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];
</P><P>		var indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];
</P><P>		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
</P><P>		this.type = 'DodecahedronBufferGeometry';
</P><P>		this.parameters = {
			radius: radius,
			detail: detail
		};
</P><P>	}
</P><P>	DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
</P><P>	/**
	 * @author oosmoxiecode / <A rel="nofollow" class="external free" href="https://github.com/oosmoxiecode">https://github.com/oosmoxiecode</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="https://github.com/WestLangley">https://github.com/WestLangley</A>
	 * @author zz85 / <A rel="nofollow" class="external free" href="https://github.com/zz85">https://github.com/zz85</A>
	 * @author miningold / <A rel="nofollow" class="external free" href="https://github.com/miningold">https://github.com/miningold</A>
	 * @author jonobr1 / <A rel="nofollow" class="external free" href="https://github.com/jonobr1">https://github.com/jonobr1</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 *
	 */
</P><P>	// TubeGeometry
</P><P>	function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'TubeGeometry';
</P><P>		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};
</P><P>		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );
</P><P>		var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );
</P><P>		// expose internals
</P><P>		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;
</P><P>		// create geometry
</P><P>		this.fromBufferGeometry( bufferGeometry );
		this.mergeVertices();
</P><P>	}
</P><P>	TubeGeometry.prototype = Object.create( Geometry.prototype );
	TubeGeometry.prototype.constructor = TubeGeometry;
</P><P>	// TubeBufferGeometry
</P><P>	function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'TubeBufferGeometry';
</P><P>		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};
</P><P>		tubularSegments = tubularSegments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
</P><P>		var frames = path.computeFrenetFrames( tubularSegments, closed );
</P><P>		// expose internals
</P><P>		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;
</P><P>		// helper variables
</P><P>		var vertex = new Vector3();
		var normal = new Vector3();
		var uv = new Vector2();
		var P = new Vector3();
</P><P>		var i, j;
</P><P>		// buffer
</P><P>		var vertices = [];
		var normals = [];
		var uvs = [];
		var indices = [];
</P><P>		// create buffer data
</P><P>		generateBufferData();
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>		// functions
</P><P>		function generateBufferData() {
</P><P>			for ( i = 0; i &lt; tubularSegments; i ++ ) {
</P><P>				generateSegment( i );
</P><P>			}
</P><P>			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
</P><P>			generateSegment( ( closed === false ) ? tubularSegments : 0 );
</P><P>			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries
</P><P>			generateUVs();
</P><P>			// finally create faces
</P><P>			generateIndices();
</P><P>		}
</P><P>		function generateSegment( i ) {
</P><P>			// we use getPointAt to sample evenly distributed points from the given path
</P><P>			P = path.getPointAt( i / tubularSegments, P );
</P><P>			// retrieve corresponding normal and binormal
</P><P>			var N = frames.normals[ i ];
			var B = frames.binormals[ i ];
</P><P>			// generate normals and vertices for the current segment
</P><P>			for ( j = 0; j &lt;= radialSegments; j ++ ) {
</P><P>				var v = j / radialSegments * Math.PI * 2;
</P><P>				var sin = Math.sin( v );
				var cos = - Math.cos( v );
</P><P>				// normal
</P><P>				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();
</P><P>				normals.push( normal.x, normal.y, normal.z );
</P><P>				// vertex
</P><P>				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;
</P><P>				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>			}
</P><P>		}
</P><P>		function generateIndices() {
</P><P>			for ( j = 1; j &lt;= tubularSegments; j ++ ) {
</P><P>				for ( i = 1; i &lt;= radialSegments; i ++ ) {
</P><P>					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
</P><P>					// faces
</P><P>					indices.push( a, b, d );
					indices.push( b, c, d );
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		function generateUVs() {
</P><P>			for ( i = 0; i &lt;= tubularSegments; i ++ ) {
</P><P>				for ( j = 0; j &lt;= radialSegments; j ++ ) {
</P><P>					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;
</P><P>					uvs.push( uv.x, uv.y );
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>	}
</P><P>	TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
</P><P>	/**
	 * @author oosmoxiecode
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 *
	 * based on <A rel="nofollow" class="external free" href="http://www.blackpawn.com/texts/pqtorus/">http://www.blackpawn.com/texts/pqtorus/</A>
	 */
</P><P>	// TorusKnotGeometry
</P><P>	function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'TorusKnotGeometry';
</P><P>		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};
</P><P>		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );
</P><P>		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();
</P><P>	}
</P><P>	TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
</P><P>	// TorusKnotBufferGeometry
</P><P>	function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'TorusKnotBufferGeometry';
</P><P>		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};
</P><P>		radius = radius || 1;
		tube = tube || 0.4;
		tubularSegments = Math.floor( tubularSegments ) || 64;
		radialSegments = Math.floor( radialSegments ) || 8;
		p = p || 2;
		q = q || 3;
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		// helper variables
</P><P>		var i, j;
</P><P>		var vertex = new Vector3();
		var normal = new Vector3();
</P><P>		var P1 = new Vector3();
		var P2 = new Vector3();
</P><P>		var B = new Vector3();
		var T = new Vector3();
		var N = new Vector3();
</P><P>		// generate vertices, normals and uvs
</P><P>		for ( i = 0; i &lt;= tubularSegments; ++ i ) {
</P><P>			// the radian &quot;u&quot; is used to calculate the position on the torus curve of the current tubular segement
</P><P>			var u = i / tubularSegments * p * Math.PI * 2;
</P><P>			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special &quot;coordinate space&quot;, which is necessary to calculate the correct vertex positions
</P><P>			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );
</P><P>			// calculate orthonormal basis
</P><P>			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );
</P><P>			// normalize B, N. T can be ignored, we don't use it
</P><P>			B.normalize();
			N.normalize();
</P><P>			for ( j = 0; j &lt;= radialSegments; ++ j ) {
</P><P>				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
</P><P>				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos( v );
				var cy = tube * Math.sin( v );
</P><P>				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
</P><P>				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );
</P><P>				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
</P><P>				normal.subVectors( vertex, P1 ).normalize();
</P><P>				normals.push( normal.x, normal.y, normal.z );
</P><P>				// uv
</P><P>				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );
</P><P>			}
</P><P>		}
</P><P>		// generate indices
</P><P>		for ( j = 1; j &lt;= tubularSegments; j ++ ) {
</P><P>			for ( i = 1; i &lt;= radialSegments; i ++ ) {
</P><P>				// indices
</P><P>				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
</P><P>				// faces
</P><P>				indices.push( a, b, d );
				indices.push( b, c, d );
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>		// this function calculates the current position on the torus curve
</P><P>		function calculatePositionOnCurve( u, p, q, radius, position ) {
</P><P>			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = q / p * u;
			var cs = Math.cos( quOverP );
</P><P>			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;
</P><P>		}
</P><P>	}
</P><P>	TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
</P><P>	/**
	 * @author oosmoxiecode
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// TorusGeometry
</P><P>	function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'TorusGeometry';
</P><P>		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
</P><P>		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
		this.mergeVertices();
</P><P>	}
</P><P>	TorusGeometry.prototype = Object.create( Geometry.prototype );
	TorusGeometry.prototype.constructor = TorusGeometry;
</P><P>	// TorusBufferGeometry
</P><P>	function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'TorusBufferGeometry';
</P><P>		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
</P><P>		radius = radius || 1;
		tube = tube || 0.4;
		radialSegments = Math.floor( radialSegments ) || 8;
		tubularSegments = Math.floor( tubularSegments ) || 6;
		arc = arc || Math.PI * 2;
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		// helper variables
</P><P>		var center = new Vector3();
		var vertex = new Vector3();
		var normal = new Vector3();
</P><P>		var j, i;
</P><P>		// generate vertices, normals and uvs
</P><P>		for ( j = 0; j &lt;= radialSegments; j ++ ) {
</P><P>			for ( i = 0; i &lt;= tubularSegments; i ++ ) {
</P><P>				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;
</P><P>				// vertex
</P><P>				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );
</P><P>				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>				// normal
</P><P>				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();
</P><P>				normals.push( normal.x, normal.y, normal.z );
</P><P>				// uv
</P><P>				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );
</P><P>			}
</P><P>		}
</P><P>		// generate indices
</P><P>		for ( j = 1; j &lt;= radialSegments; j ++ ) {
</P><P>			for ( i = 1; i &lt;= tubularSegments; i ++ ) {
</P><P>				// indices
</P><P>				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;
</P><P>				// faces
</P><P>				indices.push( a, b, d );
				indices.push( b, c, d );
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>	}
</P><P>	TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
</P><P>	/**
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 * Port from <A rel="nofollow" class="external free" href="https://github.com/mapbox/earcut">https://github.com/mapbox/earcut</A> (v2.1.2)
	 */
</P><P>	var Earcut = {
</P><P>		triangulate: function ( data, holeIndices, dim ) {
</P><P>			dim = dim || 2;
</P><P>			var hasHoles = holeIndices &amp;&amp; holeIndices.length,
				outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
				outerNode = linkedList( data, 0, outerLen, dim, true ),
				triangles = [];
</P><P>			if ( ! outerNode ) return triangles;
</P><P>			var minX, minY, maxX, maxY, x, y, invSize;
</P><P>			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );
</P><P>			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
</P><P>			if ( data.length &gt; 80 * dim ) {
</P><P>				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];
</P><P>				for ( var i = dim; i &lt; outerLen; i += dim ) {
</P><P>					x = data[ i ];
					y = data[ i + 1 ];
					if ( x &lt; minX ) minX = x;
					if ( y &lt; minY ) minY = y;
					if ( x &gt; maxX ) maxX = x;
					if ( y &gt; maxY ) maxY = y;
</P><P>				}
</P><P>				// minX, minY and invSize are later used to transform coords into integers for z-order calculation
</P><P>				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;
</P><P>			}
</P><P>			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );
</P><P>			return triangles;
</P><P>		}
</P><P>	};
</P><P>	// create a circular doubly linked list from polygon points in the specified winding order
</P><P>	function linkedList( data, start, end, dim, clockwise ) {
</P><P>		var i, last;
</P><P>		if ( clockwise === ( signedArea( data, start, end, dim ) &gt; 0 ) ) {
</P><P>			for ( i = start; i &lt; end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );
</P><P>		} else {
</P><P>			for ( i = end - dim; i &gt;= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );
</P><P>		}
</P><P>		if ( last &amp;&amp; equals( last, last.next ) ) {
</P><P>			removeNode( last );
			last = last.next;
</P><P>		}
</P><P>		return last;
</P><P>	}
</P><P>	// eliminate colinear or duplicate points
</P><P>	function filterPoints( start, end ) {
</P><P>		if ( ! start ) return start;
		if ( ! end ) end = start;
</P><P>		var p = start, again;
</P><P>		do {
</P><P>			again = false;
</P><P>			if ( ! p.steiner &amp;&amp; ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {
</P><P>				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;
</P><P>			} else {
</P><P>				p = p.next;
</P><P>			}
</P><P>		} while ( again || p !== end );
</P><P>		return end;
</P><P>	}
</P><P>	// main ear slicing loop which triangulates a polygon (given as a linked list)
</P><P>	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {
</P><P>		if ( ! ear ) return;
</P><P>		// interlink polygon nodes in z-order
</P><P>		if ( ! pass &amp;&amp; invSize ) indexCurve( ear, minX, minY, invSize );
</P><P>		var stop = ear, prev, next;
</P><P>		// iterate through ears, slicing them one by one
</P><P>		while ( ear.prev !== ear.next ) {
</P><P>			prev = ear.prev;
			next = ear.next;
</P><P>			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {
</P><P>				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );
</P><P>				removeNode( ear );
</P><P>				// skipping the next vertice leads to less sliver triangles
				ear = next.next;
				stop = next.next;
</P><P>				continue;
</P><P>			}
</P><P>			ear = next;
</P><P>			// if we looped through the whole remaining polygon and can't find any more ears
</P><P>			if ( ear === stop ) {
</P><P>				// try filtering points and slicing again
</P><P>				if ( ! pass ) {
</P><P>					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );
</P><P>					// if this didn't work, try curing all small self-intersections locally
</P><P>				} else if ( pass === 1 ) {
</P><P>					ear = cureLocalIntersections( ear, triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );
</P><P>					// as a last resort, try splitting the remaining polygon into two
</P><P>				} else if ( pass === 2 ) {
</P><P>					splitEarcut( ear, triangles, dim, minX, minY, invSize );
</P><P>				}
</P><P>				break;
</P><P>			}
</P><P>		}
</P><P>	}
</P><P>	// check whether a polygon node forms a valid ear with adjacent nodes
</P><P>	function isEar( ear ) {
</P><P>		var a = ear.prev,
			b = ear,
			c = ear.next;
</P><P>		if ( area( a, b, c ) &gt;= 0 ) return false; // reflex, can't be an ear
</P><P>		// now make sure we don't have other points inside the potential ear
		var p = ear.next.next;
</P><P>		while ( p !== ear.prev ) {
</P><P>			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &amp;&amp; area( p.prev, p, p.next ) &gt;= 0 ) {
</P><P>				return false;
</P><P>			}
</P><P>			p = p.next;
</P><P>		}
</P><P>		return true;
</P><P>	}
</P><P>	function isEarHashed( ear, minX, minY, invSize ) {
</P><P>		var a = ear.prev,
			b = ear,
			c = ear.next;
</P><P>		if ( area( a, b, c ) &gt;= 0 ) return false; // reflex, can't be an ear
</P><P>		// triangle bbox; min &amp; max are calculated like this for speed
</P><P>		var minTX = a.x &lt; b.x ? ( a.x &lt; c.x ? a.x : c.x ) : ( b.x &lt; c.x ? b.x : c.x ),
			minTY = a.y &lt; b.y ? ( a.y &lt; c.y ? a.y : c.y ) : ( b.y &lt; c.y ? b.y : c.y ),
			maxTX = a.x &gt; b.x ? ( a.x &gt; c.x ? a.x : c.x ) : ( b.x &gt; c.x ? b.x : c.x ),
			maxTY = a.y &gt; b.y ? ( a.y &gt; c.y ? a.y : c.y ) : ( b.y &gt; c.y ? b.y : c.y );
</P><P>		// z-order range for the current triangle bbox;
</P><P>		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );
</P><P>		// first look for points inside the triangle in increasing z-order
</P><P>		var p = ear.nextZ;
</P><P>		while ( p &amp;&amp; p.z &lt;= maxZ ) {
</P><P>			if ( p !== ear.prev &amp;&amp; p !== ear.next &amp;&amp;
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &amp;&amp;
					area( p.prev, p, p.next ) &gt;= 0 ) return false;
			p = p.nextZ;
</P><P>		}
</P><P>		// then look for points in decreasing z-order
</P><P>		p = ear.prevZ;
</P><P>		while ( p &amp;&amp; p.z &gt;= minZ ) {
</P><P>			if ( p !== ear.prev &amp;&amp; p !== ear.next &amp;&amp;
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &amp;&amp;
					area( p.prev, p, p.next ) &gt;= 0 ) return false;
</P><P>			p = p.prevZ;
</P><P>		}
</P><P>		return true;
</P><P>	}
</P><P>	// go through all polygon nodes and cure small local self-intersections
</P><P>	function cureLocalIntersections( start, triangles, dim ) {
</P><P>		var p = start;
</P><P>		do {
</P><P>			var a = p.prev, b = p.next.next;
</P><P>			if ( ! equals( a, b ) &amp;&amp; intersects( a, p, p.next, b ) &amp;&amp; locallyInside( a, b ) &amp;&amp; locallyInside( b, a ) ) {
</P><P>				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );
</P><P>				// remove two nodes involved
</P><P>				removeNode( p );
				removeNode( p.next );
</P><P>				p = start = b;
</P><P>			}
</P><P>			p = p.next;
</P><P>		} while ( p !== start );
</P><P>		return p;
</P><P>	}
</P><P>	// try splitting polygon into two and triangulate them independently
</P><P>	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {
</P><P>		// look for a valid diagonal that divides the polygon into two
</P><P>		var a = start;
</P><P>		do {
</P><P>			var b = a.next.next;
</P><P>			while ( b !== a.prev ) {
</P><P>				if ( a.i !== b.i &amp;&amp; isValidDiagonal( a, b ) ) {
</P><P>					// split the polygon in two by the diagonal
</P><P>					var c = splitPolygon( a, b );
</P><P>					// filter colinear points around the cuts
</P><P>					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );
</P><P>					// run earcut on each half
</P><P>					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;
</P><P>				}
</P><P>				b = b.next;
</P><P>			}
</P><P>			a = a.next;
</P><P>		} while ( a !== start );
</P><P>	}
</P><P>	// link every hole into the outer loop, producing a single-ring polygon without holes
</P><P>	function eliminateHoles( data, holeIndices, outerNode, dim ) {
</P><P>		var queue = [], i, len, start, end, list;
</P><P>		for ( i = 0, len = holeIndices.length; i &lt; len; i ++ ) {
</P><P>			start = holeIndices[ i ] * dim;
			end = i &lt; len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );
</P><P>		}
</P><P>		queue.sort( compareX );
</P><P>		// process holes from left to right
</P><P>		for ( i = 0; i &lt; queue.length; i ++ ) {
</P><P>			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );
</P><P>		}
</P><P>		return outerNode;
</P><P>	}
</P><P>	function compareX( a, b ) {
</P><P>		return a.x - b.x;
</P><P>	}
</P><P>	// find a bridge between vertices that connects hole with an outer ring and and link it
</P><P>	function eliminateHole( hole, outerNode ) {
</P><P>		outerNode = findHoleBridge( hole, outerNode );
</P><P>		if ( outerNode ) {
</P><P>			var b = splitPolygon( outerNode, hole );
</P><P>			filterPoints( b, b.next );
</P><P>		}
</P><P>	}
</P><P>	// David Eberly's algorithm for finding a bridge between hole and outer polygon
</P><P>	function findHoleBridge( hole, outerNode ) {
</P><P>		var p = outerNode,
			hx = hole.x,
			hy = hole.y,
			qx = - Infinity,
			m;
</P><P>		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point
</P><P>		do {
</P><P>			if ( hy &lt;= p.y &amp;&amp; hy &gt;= p.next.y &amp;&amp; p.next.y !== p.y ) {
</P><P>				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
</P><P>				if ( x &lt;= hx &amp;&amp; x &gt; qx ) {
</P><P>					qx = x;
</P><P>					if ( x === hx ) {
</P><P>						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;
</P><P>					}
</P><P>					m = p.x &lt; p.next.x ? p : p.next;
</P><P>				}
</P><P>			}
</P><P>			p = p.next;
</P><P>		} while ( p !== outerNode );
</P><P>		if ( ! m ) return null;
</P><P>		if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint
</P><P>		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point
</P><P>		var stop = m,
			mx = m.x,
			my = m.y,
			tanMin = Infinity,
			tan;
</P><P>		p = m.next;
</P><P>		while ( p !== stop ) {
</P><P>			if ( hx &gt;= p.x &amp;&amp; p.x &gt;= mx &amp;&amp; hx !== p.x &amp;&amp;
							pointInTriangle( hy &lt; my ? hx : qx, hy, mx, my, hy &lt; my ? qx : hx, hy, p.x, p.y ) ) {
</P><P>				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential
</P><P>				if ( ( tan &lt; tanMin || ( tan === tanMin &amp;&amp; p.x &gt; m.x ) ) &amp;&amp; locallyInside( p, hole ) ) {
</P><P>					m = p;
					tanMin = tan;
</P><P>				}
</P><P>			}
</P><P>			p = p.next;
</P><P>		}
</P><P>		return m;
</P><P>	}
</P><P>	// interlink polygon nodes in z-order
</P><P>	function indexCurve( start, minX, minY, invSize ) {
</P><P>		var p = start;
</P><P>		do {
</P><P>			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
</P><P>		} while ( p !== start );
</P><P>		p.prevZ.nextZ = null;
		p.prevZ = null;
</P><P>		sortLinked( p );
</P><P>	}
</P><P>	// Simon Tatham's linked list merge sort algorithm
	// <A rel="nofollow" class="external free" href="http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html">http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html</A></P><P>	function sortLinked( list ) {
</P><P>		var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
</P><P>		do {
</P><P>			p = list;
			list = null;
			tail = null;
			numMerges = 0;
</P><P>			while ( p ) {
</P><P>				numMerges ++;
				q = p;
				pSize = 0;
</P><P>				for ( i = 0; i &lt; inSize; i ++ ) {
</P><P>					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;
</P><P>				}
</P><P>				qSize = inSize;
</P><P>				while ( pSize &gt; 0 || ( qSize &gt; 0 &amp;&amp; q ) ) {
</P><P>					if ( pSize !== 0 &amp;&amp; ( qSize === 0 || ! q || p.z &lt;= q.z ) ) {
</P><P>						e = p;
						p = p.nextZ;
						pSize --;
</P><P>					} else {
</P><P>						e = q;
						q = q.nextZ;
						qSize --;
</P><P>					}
</P><P>					if ( tail ) tail.nextZ = e;
					else list = e;
</P><P>					e.prevZ = tail;
					tail = e;
</P><P>				}
</P><P>				p = q;
</P><P>			}
</P><P>			tail.nextZ = null;
			inSize *= 2;
</P><P>		} while ( numMerges &gt; 1 );
</P><P>		return list;
</P><P>	}
</P><P>	// z-order of a point given coords and inverse of the longer side of data bbox
</P><P>	function zOrder( x, y, minX, minY, invSize ) {
</P><P>		// coords are transformed into non-negative 15-bit integer range
</P><P>		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;
</P><P>		x = ( x | ( x &lt;&lt; 8 ) ) &amp; 0x00FF00FF;
		x = ( x | ( x &lt;&lt; 4 ) ) &amp; 0x0F0F0F0F;
		x = ( x | ( x &lt;&lt; 2 ) ) &amp; 0x33333333;
		x = ( x | ( x &lt;&lt; 1 ) ) &amp; 0x55555555;
</P><P>		y = ( y | ( y &lt;&lt; 8 ) ) &amp; 0x00FF00FF;
		y = ( y | ( y &lt;&lt; 4 ) ) &amp; 0x0F0F0F0F;
		y = ( y | ( y &lt;&lt; 2 ) ) &amp; 0x33333333;
		y = ( y | ( y &lt;&lt; 1 ) ) &amp; 0x55555555;
</P><P>		return x | ( y &lt;&lt; 1 );
</P><P>	}
</P><P>	// find the leftmost node of a polygon ring
</P><P>	function getLeftmost( start ) {
</P><P>		var p = start, leftmost = start;
</P><P>		do {
</P><P>			if ( p.x &lt; leftmost.x ) leftmost = p;
			p = p.next;
</P><P>		} while ( p !== start );
</P><P>		return leftmost;
</P><P>	}
</P><P>	// check if a point lies within a convex triangle
</P><P>	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {
</P><P>		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) &gt;= 0 &amp;&amp;
		 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) &gt;= 0 &amp;&amp;
		 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) &gt;= 0;
</P><P>	}
</P><P>	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
</P><P>	function isValidDiagonal( a, b ) {
</P><P>		return a.next.i !== b.i &amp;&amp; a.prev.i !== b.i &amp;&amp; ! intersectsPolygon( a, b ) &amp;&amp;
			locallyInside( a, b ) &amp;&amp; locallyInside( b, a ) &amp;&amp; middleInside( a, b );
</P><P>	}
</P><P>	// signed area of a triangle
</P><P>	function area( p, q, r ) {
</P><P>		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );
</P><P>	}
</P><P>	// check if two points are equal
</P><P>	function equals( p1, p2 ) {
</P><P>		return p1.x === p2.x &amp;&amp; p1.y === p2.y;
</P><P>	}
</P><P>	// check if two segments intersect
</P><P>	function intersects( p1, q1, p2, q2 ) {
</P><P>		if ( ( equals( p1, q1 ) &amp;&amp; equals( p2, q2 ) ) ||
				( equals( p1, q2 ) &amp;&amp; equals( p2, q1 ) ) ) return true;
</P><P>		return area( p1, q1, p2 ) &gt; 0 !== area( p1, q1, q2 ) &gt; 0 &amp;&amp;
					 area( p2, q2, p1 ) &gt; 0 !== area( p2, q2, q1 ) &gt; 0;
</P><P>	}
</P><P>	// check if a polygon diagonal intersects any polygon segments
</P><P>	function intersectsPolygon( a, b ) {
</P><P>		var p = a;
</P><P>		do {
</P><P>			if ( p.i !== a.i &amp;&amp; p.next.i !== a.i &amp;&amp; p.i !== b.i &amp;&amp; p.next.i !== b.i &amp;&amp;
							intersects( p, p.next, a, b ) ) {
</P><P>				return true;
</P><P>			}
</P><P>			p = p.next;
</P><P>		} while ( p !== a );
</P><P>		return false;
</P><P>	}
</P><P>	// check if a polygon diagonal is locally inside the polygon
</P><P>	function locallyInside( a, b ) {
</P><P>		return area( a.prev, a, a.next ) &lt; 0 ?
			area( a, b, a.next ) &gt;= 0 &amp;&amp; area( a, a.prev, b ) &gt;= 0 :
			area( a, b, a.prev ) &lt; 0 || area( a, a.next, b ) &lt; 0;
</P><P>	}
</P><P>	// check if the middle point of a polygon diagonal is inside the polygon
</P><P>	function middleInside( a, b ) {
</P><P>		var p = a,
			inside = false,
			px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;
</P><P>		do {
</P><P>			if ( ( ( p.y &gt; py ) !== ( p.next.y &gt; py ) ) &amp;&amp; p.next.y !== p.y &amp;&amp;
							( px &lt; ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {
</P><P>				inside = ! inside;
</P><P>			}
</P><P>			p = p.next;
</P><P>		} while ( p !== a );
</P><P>		return inside;
</P><P>	}
</P><P>	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
</P><P>	function splitPolygon( a, b ) {
</P><P>		var a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;
</P><P>		a.next = b;
		b.prev = a;
</P><P>		a2.next = an;
		an.prev = a2;
</P><P>		b2.next = a2;
		a2.prev = b2;
</P><P>		bp.next = b2;
		b2.prev = bp;
</P><P>		return b2;
</P><P>	}
</P><P>	// create a node and optionally link it with previous one (in a circular doubly linked list)
</P><P>	function insertNode( i, x, y, last ) {
</P><P>		var p = new Node( i, x, y );
</P><P>		if ( ! last ) {
</P><P>			p.prev = p;
			p.next = p;
</P><P>		} else {
</P><P>			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
</P><P>		}
</P><P>		return p;
</P><P>	}
</P><P>	function removeNode( p ) {
</P><P>		p.next.prev = p.prev;
		p.prev.next = p.next;
</P><P>		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;
</P><P>	}
</P><P>	function Node( i, x, y ) {
</P><P>		// vertice index in coordinates array
		this.i = i;
</P><P>		// vertex coordinates
		this.x = x;
		this.y = y;
</P><P>		// previous and next vertice nodes in a polygon ring
		this.prev = null;
		this.next = null;
</P><P>		// z-order curve value
		this.z = null;
</P><P>		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;
</P><P>		// indicates whether this is a steiner point
		this.steiner = false;
</P><P>	}
</P><P>	function signedArea( data, start, end, dim ) {
</P><P>		var sum = 0;
</P><P>		for ( var i = start, j = end - dim; i &lt; end; i += dim ) {
</P><P>			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;
</P><P>		}
</P><P>		return sum;
</P><P>	}
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 */
</P><P>	var ShapeUtils = {
</P><P>		// calculate area of the contour polygon
</P><P>		area: function ( contour ) {
</P><P>			var n = contour.length;
			var a = 0.0;
</P><P>			for ( var p = n - 1, q = 0; q &lt; n; p = q ++ ) {
</P><P>				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
</P><P>			}
</P><P>			return a * 0.5;
</P><P>		},
</P><P>		isClockWise: function ( pts ) {
</P><P>			return ShapeUtils.area( pts ) &lt; 0;
</P><P>		},
</P><P>		triangulateShape: function ( contour, holes ) {
</P><P>			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			var holeIndices = []; // array of hole indices
			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
</P><P>			removeDupEndPts( contour );
			addContour( vertices, contour );
</P><P>			//
</P><P>			var holeIndex = contour.length;
</P><P>			holes.forEach( removeDupEndPts );
</P><P>			for ( var i = 0; i &lt; holes.length; i ++ ) {
</P><P>				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );
</P><P>			}
</P><P>			//
</P><P>			var triangles = Earcut.triangulate( vertices, holeIndices );
</P><P>			//
</P><P>			for ( var i = 0; i &lt; triangles.length; i += 3 ) {
</P><P>				faces.push( triangles.slice( i, i + 3 ) );
</P><P>			}
</P><P>			return faces;
</P><P>		}
</P><P>	};
</P><P>	function removeDupEndPts( points ) {
</P><P>		var l = points.length;
</P><P>		if ( l &gt; 2 &amp;&amp; points[ l - 1 ].equals( points[ 0 ] ) ) {
</P><P>			points.pop();
</P><P>		}
</P><P>	}
</P><P>	function addContour( vertices, contour ) {
</P><P>		for ( var i = 0; i &lt; contour.length; i ++ ) {
</P><P>			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );
</P><P>		}
</P><P>	}
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: &lt;int&gt;, // number of points on the curves
	 *  steps: &lt;int&gt;, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: &lt;float&gt;, // Depth to extrude the shape
	 *
	 *  bevelEnabled: &lt;bool&gt;, // turn on bevel
	 *  bevelThickness: &lt;float&gt;, // how deep into the original shape bevel goes
	 *  bevelSize: &lt;float&gt;, // how far from shape outline is bevel
	 *  bevelSegments: &lt;int&gt;, // number of bevel layers
	 *
	 *  extrudePath: &lt;THREE.Curve&gt; // curve to extrude shape along
	 *
	 *  UVGenerator: &lt;Object&gt; // object that provides UV generator functions
	 *
	 * }
	 */
</P><P>	// ExtrudeGeometry
</P><P>	function ExtrudeGeometry( shapes, options ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'ExtrudeGeometry';
</P><P>		this.parameters = {
			shapes: shapes,
			options: options
		};
</P><P>		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
		this.mergeVertices();
</P><P>	}
</P><P>	ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
</P><P>	ExtrudeGeometry.prototype.toJSON = function () {
</P><P>		var data = Geometry.prototype.toJSON.call( this );
</P><P>		var shapes = this.parameters.shapes;
		var options = this.parameters.options;
</P><P>		return toJSON( shapes, options, data );
</P><P>	};
</P><P>	// ExtrudeBufferGeometry
</P><P>	function ExtrudeBufferGeometry( shapes, options ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'ExtrudeBufferGeometry';
</P><P>		this.parameters = {
			shapes: shapes,
			options: options
		};
</P><P>		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
</P><P>		var scope = this;
</P><P>		var verticesArray = [];
		var uvArray = [];
</P><P>		for ( var i = 0, l = shapes.length; i &lt; l; i ++ ) {
</P><P>			var shape = shapes[ i ];
			addShape( shape );
</P><P>		}
</P><P>		// build geometry
</P><P>		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );
</P><P>		this.computeVertexNormals();
</P><P>		// functions
</P><P>		function addShape( shape ) {
</P><P>			var placeholder = [];
</P><P>			// options
</P><P>			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			var steps = options.steps !== undefined ? options.steps : 1;
			var depth = options.depth !== undefined ? options.depth : 100;
</P><P>			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
</P><P>			var extrudePath = options.extrudePath;
</P><P>			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
</P><P>			// deprecated options
</P><P>			if ( options.amount !== undefined ) {
</P><P>				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;
</P><P>			}
</P><P>			//
</P><P>			var extrudePts, extrudeByPath = false;
			var splineTube, binormal, normal, position2;
</P><P>			if ( extrudePath ) {
</P><P>				extrudePts = extrudePath.getSpacedPoints( steps );
</P><P>				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion
</P><P>				// SETUP TNB variables
</P><P>				// TODO1 - have a .isClosed in spline?
</P><P>				splineTube = extrudePath.computeFrenetFrames( steps, false );
</P><P>				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
</P><P>				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();
</P><P>			}
</P><P>			// Safeguards if bevels are not enabled
</P><P>			if ( ! bevelEnabled ) {
</P><P>				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
</P><P>			}
</P><P>			// Variables initialization
</P><P>			var ahole, h, hl; // looping of holes
</P><P>			var shapePoints = shape.extractPoints( curveSegments );
</P><P>			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;
</P><P>			var reverse = ! ShapeUtils.isClockWise( vertices );
</P><P>			if ( reverse ) {
</P><P>				vertices = vertices.reverse();
</P><P>				// Maybe we should also check if holes are in the opposite direction, just to be safe ...
</P><P>				for ( h = 0, hl = holes.length; h &lt; hl; h ++ ) {
</P><P>					ahole = holes[ h ];
</P><P>					if ( ShapeUtils.isClockWise( ahole ) ) {
</P><P>						holes[ h ] = ahole.reverse();
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>
			var faces = ShapeUtils.triangulateShape( vertices, holes );
</P><P>			/* Vertices */
</P><P>			var contour = vertices; // vertices has all points but contour has only points of circumference
</P><P>			for ( h = 0, hl = holes.length; h &lt; hl; h ++ ) {
</P><P>				ahole = holes[ h ];
</P><P>				vertices = vertices.concat( ahole );
</P><P>			}
</P><P>
			function scalePt2( pt, vec, size ) {
</P><P>				if ( ! vec ) console.error( &quot;THREE.ExtrudeGeometry: vec does not exist&quot; );
</P><P>				return vec.clone().multiplyScalar( size ).add( pt );
</P><P>			}
</P><P>			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;
</P><P>
			// Find directions for point movement
</P><P>
			function getBevelVec( inPt, inPrev, inNext ) {
</P><P>				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.
</P><P>				var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
</P><P>				// good reading for geometry algorithms (here: line-line intersection)
				// <A rel="nofollow" class="external free" href="http://geomalgorithms.com/a05-_intersect-1.html">http://geomalgorithms.com/a05-_intersect-1.html</A></P><P>				var v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;
</P><P>				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
</P><P>				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
</P><P>				if ( Math.abs( collinear0 ) &gt; Number.EPSILON ) {
</P><P>					// not collinear
</P><P>					// length of vectors for normalizing
</P><P>					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
</P><P>					// shift adjacent points by unit vectors to the left
</P><P>					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
</P><P>					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
</P><P>					// scaling factor for v_prev to intersection point
</P><P>					var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );
</P><P>					// vector from inPt to intersection point
</P><P>					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
</P><P>					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq &lt;= 2 ) {
</P><P>						return new Vector2( v_trans_x, v_trans_y );
</P><P>					} else {
</P><P>						shrink_by = Math.sqrt( v_trans_lensq / 2 );
</P><P>					}
</P><P>				} else {
</P><P>					// handle special case of collinear edges
</P><P>					var direction_eq = false; // assumes: opposite
					if ( v_prev_x &gt; Number.EPSILON ) {
</P><P>						if ( v_next_x &gt; Number.EPSILON ) {
</P><P>							direction_eq = true;
</P><P>						}
</P><P>					} else {
</P><P>						if ( v_prev_x &lt; - Number.EPSILON ) {
</P><P>							if ( v_next_x &lt; - Number.EPSILON ) {
</P><P>								direction_eq = true;
</P><P>							}
</P><P>						} else {
</P><P>							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
</P><P>								direction_eq = true;
</P><P>							}
</P><P>						}
</P><P>					}
</P><P>					if ( direction_eq ) {
</P><P>						// console.log(&quot;Warning: lines are a straight sequence&quot;);
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );
</P><P>					} else {
</P><P>						// console.log(&quot;Warning: lines are a straight spike&quot;);
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );
</P><P>					}
</P><P>				}
</P><P>				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
</P><P>			}
</P><P>
			var contourMovements = [];
</P><P>			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i &lt; il; i ++, j ++, k ++ ) {
</P><P>				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
</P><P>				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)
</P><P>				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
</P><P>			}
</P><P>			var holesMovements = [],
				oneHoleMovements, verticesMovements = contourMovements.concat();
</P><P>			for ( h = 0, hl = holes.length; h &lt; hl; h ++ ) {
</P><P>				ahole = holes[ h ];
</P><P>				oneHoleMovements = [];
</P><P>	for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i &lt; il; i ++, j ++, k ++ ) {
</P><P>					if ( j === il ) j = 0;
					if ( k === il ) k = 0;
</P><P>					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
</P><P>				}
</P><P>				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );
</P><P>			}
</P><P>
			// Loop bevelSegments, 1 for the front, 1 for the back
</P><P>			for ( b = 0; b &lt; bevelSegments; b ++ ) {
</P><P>				//for ( b = bevelSegments; b &gt; 0; b -- ) {
</P><P>				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
</P><P>				// contract shape
</P><P>				for ( i = 0, il = contour.length; i &lt; il; i ++ ) {
</P><P>					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
</P><P>					v( vert.x, vert.y, - z );
</P><P>				}
</P><P>				// expand holes
</P><P>				for ( h = 0, hl = holes.length; h &lt; hl; h ++ ) {
</P><P>					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
</P><P>					for ( i = 0, il = ahole.length; i &lt; il; i ++ ) {
</P><P>						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
</P><P>						v( vert.x, vert.y, - z );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			bs = bevelSize;
</P><P>			// Back facing vertices
</P><P>			for ( i = 0; i &lt; vlen; i ++ ) {
</P><P>				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
</P><P>				if ( ! extrudeByPath ) {
</P><P>					v( vert.x, vert.y, 0 );
</P><P>				} else {
</P><P>					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
</P><P>					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
</P><P>					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
</P><P>					v( position2.x, position2.y, position2.z );
</P><P>				}
</P><P>			}
</P><P>			// Add stepped vertices...
			// Including front facing vertices
</P><P>			var s;
</P><P>			for ( s = 1; s &lt;= steps; s ++ ) {
</P><P>				for ( i = 0; i &lt; vlen; i ++ ) {
</P><P>					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
</P><P>					if ( ! extrudeByPath ) {
</P><P>						v( vert.x, vert.y, depth / steps * s );
</P><P>					} else {
</P><P>						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
</P><P>						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
</P><P>						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
</P><P>						v( position2.x, position2.y, position2.z );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>
			// Add bevel segments planes
</P><P>			//for ( b = 1; b &lt;= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b &gt;= 0; b -- ) {
</P><P>				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
</P><P>				// contract shape
</P><P>				for ( i = 0, il = contour.length; i &lt; il; i ++ ) {
</P><P>					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );
</P><P>				}
</P><P>				// expand holes
</P><P>				for ( h = 0, hl = holes.length; h &lt; hl; h ++ ) {
</P><P>					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
</P><P>					for ( i = 0, il = ahole.length; i &lt; il; i ++ ) {
</P><P>						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
</P><P>						if ( ! extrudeByPath ) {
</P><P>							v( vert.x, vert.y, depth + z );
</P><P>						} else {
</P><P>							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			/* Faces */
</P><P>			// Top and bottom faces
</P><P>			buildLidFaces();
</P><P>			// Sides faces
</P><P>			buildSideFaces();
</P><P>
			/////  Internal functions
</P><P>			function buildLidFaces() {
</P><P>				var start = verticesArray.length / 3;
</P><P>				if ( bevelEnabled ) {
</P><P>					var layer = 0; // steps + 1
					var offset = vlen * layer;
</P><P>					// Bottom faces
</P><P>					for ( i = 0; i &lt; flen; i ++ ) {
</P><P>						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
</P><P>					}
</P><P>					layer = steps + bevelSegments * 2;
					offset = vlen * layer;
</P><P>					// Top faces
</P><P>					for ( i = 0; i &lt; flen; i ++ ) {
</P><P>						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
</P><P>					}
</P><P>				} else {
</P><P>					// Bottom faces
</P><P>					for ( i = 0; i &lt; flen; i ++ ) {
</P><P>						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );
</P><P>					}
</P><P>					// Top faces
</P><P>					for ( i = 0; i &lt; flen; i ++ ) {
</P><P>						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
</P><P>					}
</P><P>				}
</P><P>				scope.addGroup( start, verticesArray.length / 3 - start, 0 );
</P><P>			}
</P><P>			// Create faces for the z-sides of the shape
</P><P>			function buildSideFaces() {
</P><P>				var start = verticesArray.length / 3;
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;
</P><P>				for ( h = 0, hl = holes.length; h &lt; hl; h ++ ) {
</P><P>					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );
</P><P>					//, true
					layeroffset += ahole.length;
</P><P>				}
</P><P>
				scope.addGroup( start, verticesArray.length / 3 - start, 1 );
</P><P>
			}
</P><P>			function sidewalls( contour, layeroffset ) {
</P><P>				var j, k;
				i = contour.length;
</P><P>				while ( -- i &gt;= 0 ) {
</P><P>					j = i;
					k = i - 1;
					if ( k &lt; 0 ) k = contour.length - 1;
</P><P>					//console.log('b', i,j, i-1, k,vertices.length);
</P><P>					var s = 0,
						sl = steps + bevelSegments * 2;
</P><P>					for ( s = 0; s &lt; sl; s ++ ) {
</P><P>						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );
</P><P>						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;
</P><P>						f4( a, b, c, d );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			function v( x, y, z ) {
</P><P>				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );
</P><P>			}
</P><P>
			function f3( a, b, c ) {
</P><P>				addVertex( a );
				addVertex( b );
				addVertex( c );
</P><P>				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
</P><P>				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
</P><P>			}
</P><P>			function f4( a, b, c, d ) {
</P><P>				addVertex( a );
				addVertex( b );
				addVertex( d );
</P><P>				addVertex( b );
				addVertex( c );
				addVertex( d );
</P><P>
				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
</P><P>				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );
</P><P>				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );
</P><P>			}
</P><P>			function addVertex( index ) {
</P><P>				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );
</P><P>			}
</P><P>
			function addUV( vector2 ) {
</P><P>				uvArray.push( vector2.x );
				uvArray.push( vector2.y );
</P><P>			}
</P><P>		}
</P><P>	}
</P><P>	ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
</P><P>	ExtrudeBufferGeometry.prototype.toJSON = function () {
</P><P>		var data = BufferGeometry.prototype.toJSON.call( this );
</P><P>		var shapes = this.parameters.shapes;
		var options = this.parameters.options;
</P><P>		return toJSON( shapes, options, data );
</P><P>	};
</P><P>	//
</P><P>	var WorldUVGenerator = {
</P><P>		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {
</P><P>			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
</P><P>			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];
</P><P>		},
</P><P>		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {
</P><P>			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var a_z = vertices[ indexA * 3 + 2 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var b_z = vertices[ indexB * 3 + 2 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
			var c_z = vertices[ indexC * 3 + 2 ];
			var d_x = vertices[ indexD * 3 ];
			var d_y = vertices[ indexD * 3 + 1 ];
			var d_z = vertices[ indexD * 3 + 2 ];
</P><P>			if ( Math.abs( a_y - b_y ) &lt; 0.01 ) {
</P><P>				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];
</P><P>			} else {
</P><P>				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];
</P><P>			}
</P><P>		}
	};
</P><P>	function toJSON( shapes, options, data ) {
</P><P>		//
</P><P>		data.shapes = [];
</P><P>		if ( Array.isArray( shapes ) ) {
</P><P>			for ( var i = 0, l = shapes.length; i &lt; l; i ++ ) {
</P><P>				var shape = shapes[ i ];
</P><P>				data.shapes.push( shape.uuid );
</P><P>			}
</P><P>		} else {
</P><P>			data.shapes.push( shapes.uuid );
</P><P>		}
</P><P>		//
</P><P>		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();
</P><P>		return data;
</P><P>	}
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: &lt;THREE.Font&gt;, // font
	 *
	 *  size: &lt;float&gt;, // size of the text
	 *  height: &lt;float&gt;, // thickness to extrude text
	 *  curveSegments: &lt;int&gt;, // number of points on the curves
	 *
	 *  bevelEnabled: &lt;bool&gt;, // turn on bevel
	 *  bevelThickness: &lt;float&gt;, // how deep into text bevel goes
	 *  bevelSize: &lt;float&gt; // how far from text outline is bevel
	 * }
	 */
</P><P>	// TextGeometry
</P><P>	function TextGeometry( text, parameters ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'TextGeometry';
</P><P>		this.parameters = {
			text: text,
			parameters: parameters
		};
</P><P>		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
		this.mergeVertices();
</P><P>	}
</P><P>	TextGeometry.prototype = Object.create( Geometry.prototype );
	TextGeometry.prototype.constructor = TextGeometry;
</P><P>	// TextBufferGeometry
</P><P>	function TextBufferGeometry( text, parameters ) {
</P><P>		parameters = parameters || {};
</P><P>		var font = parameters.font;
</P><P>		if ( ! ( font &amp;&amp; font.isFont ) ) {
</P><P>			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new Geometry();
</P><P>		}
</P><P>		var shapes = font.generateShapes( text, parameters.size );
</P><P>		// translate parameters to ExtrudeGeometry API
</P><P>		parameters.depth = parameters.height !== undefined ? parameters.height : 50;
</P><P>		// defaults
</P><P>		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
</P><P>		ExtrudeBufferGeometry.call( this, shapes, parameters );
</P><P>		this.type = 'TextBufferGeometry';
</P><P>	}
</P><P>	TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author benaadams / <A rel="nofollow" class="external free" href="https://twitter.com/ben_a_adams">https://twitter.com/ben_a_adams</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// SphereGeometry
</P><P>	function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'SphereGeometry';
</P><P>		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
		this.mergeVertices();
</P><P>	}
</P><P>	SphereGeometry.prototype = Object.create( Geometry.prototype );
	SphereGeometry.prototype.constructor = SphereGeometry;
</P><P>	// SphereBufferGeometry
</P><P>	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'SphereBufferGeometry';
</P><P>		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>		radius = radius || 1;
</P><P>		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
</P><P>		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
</P><P>		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
</P><P>		var thetaEnd = thetaStart + thetaLength;
</P><P>		var ix, iy;
</P><P>		var index = 0;
		var grid = [];
</P><P>		var vertex = new Vector3();
		var normal = new Vector3();
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		// generate vertices, normals and uvs
</P><P>		for ( iy = 0; iy &lt;= heightSegments; iy ++ ) {
</P><P>			var verticesRow = [];
</P><P>			var v = iy / heightSegments;
</P><P>			for ( ix = 0; ix &lt;= widthSegments; ix ++ ) {
</P><P>				var u = ix / widthSegments;
</P><P>				// vertex
</P><P>				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
</P><P>				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>				// normal
</P><P>				normal.set( vertex.x, vertex.y, vertex.z ).normalize();
				normals.push( normal.x, normal.y, normal.z );
</P><P>				// uv
</P><P>				uvs.push( u, 1 - v );
</P><P>				verticesRow.push( index ++ );
</P><P>			}
</P><P>			grid.push( verticesRow );
</P><P>		}
</P><P>		// indices
</P><P>		for ( iy = 0; iy &lt; heightSegments; iy ++ ) {
</P><P>			for ( ix = 0; ix &lt; widthSegments; ix ++ ) {
</P><P>				var a = grid[ iy ][ ix + 1 ];
				var b = grid[ iy ][ ix ];
				var c = grid[ iy + 1 ][ ix ];
				var d = grid[ iy + 1 ][ ix + 1 ];
</P><P>				if ( iy !== 0 || thetaStart &gt; 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd &lt; Math.PI ) indices.push( b, c, d );
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>	}
</P><P>	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
</P><P>	/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// RingGeometry
</P><P>	function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'RingGeometry';
</P><P>		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
		this.mergeVertices();
</P><P>	}
</P><P>	RingGeometry.prototype = Object.create( Geometry.prototype );
	RingGeometry.prototype.constructor = RingGeometry;
</P><P>	// RingBufferGeometry
</P><P>	function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'RingBufferGeometry';
</P><P>		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>		innerRadius = innerRadius || 0.5;
		outerRadius = outerRadius || 1;
</P><P>		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
</P><P>		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		// some helper variables
</P><P>		var segment;
		var radius = innerRadius;
		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		var vertex = new Vector3();
		var uv = new Vector2();
		var j, i;
</P><P>		// generate vertices, normals and uvs
</P><P>		for ( j = 0; j &lt;= phiSegments; j ++ ) {
</P><P>			for ( i = 0; i &lt;= thetaSegments; i ++ ) {
</P><P>				// values are generate from the inside of the ring to the outside
</P><P>				segment = thetaStart + i / thetaSegments * thetaLength;
</P><P>				// vertex
</P><P>				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
</P><P>				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>				// normal
</P><P>				normals.push( 0, 0, 1 );
</P><P>				// uv
</P><P>				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;
</P><P>				uvs.push( uv.x, uv.y );
</P><P>			}
</P><P>			// increase the radius for next row of vertices
</P><P>			radius += radiusStep;
</P><P>		}
</P><P>		// indices
</P><P>		for ( j = 0; j &lt; phiSegments; j ++ ) {
</P><P>			var thetaSegmentLevel = j * ( thetaSegments + 1 );
</P><P>			for ( i = 0; i &lt; thetaSegments; i ++ ) {
</P><P>				segment = i + thetaSegmentLevel;
</P><P>				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;
</P><P>				// faces
</P><P>				indices.push( a, b, d );
				indices.push( b, c, d );
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>	}
</P><P>	RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="https://github.com/zz85">https://github.com/zz85</A>
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// LatheGeometry
</P><P>	function LatheGeometry( points, segments, phiStart, phiLength ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'LatheGeometry';
</P><P>		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
</P><P>		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();
</P><P>	}
</P><P>	LatheGeometry.prototype = Object.create( Geometry.prototype );
	LatheGeometry.prototype.constructor = LatheGeometry;
</P><P>	// LatheBufferGeometry
</P><P>	function LatheBufferGeometry( points, segments, phiStart, phiLength ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'LatheBufferGeometry';
</P><P>		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
</P><P>		segments = Math.floor( segments ) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;
</P><P>		// clamp phiLength so it's in range of [ 0, 2PI ]
</P><P>		phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );
</P><P>
		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var uvs = [];
</P><P>		// helper variables
</P><P>		var base;
		var inverseSegments = 1.0 / segments;
		var vertex = new Vector3();
		var uv = new Vector2();
		var i, j;
</P><P>		// generate vertices and uvs
</P><P>		for ( i = 0; i &lt;= segments; i ++ ) {
</P><P>			var phi = phiStart + i * inverseSegments * phiLength;
</P><P>			var sin = Math.sin( phi );
			var cos = Math.cos( phi );
</P><P>			for ( j = 0; j &lt;= ( points.length - 1 ); j ++ ) {
</P><P>				// vertex
</P><P>				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;
</P><P>				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>				// uv
</P><P>				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );
</P><P>				uvs.push( uv.x, uv.y );
</P><P>
			}
</P><P>		}
</P><P>		// indices
</P><P>		for ( i = 0; i &lt; segments; i ++ ) {
</P><P>			for ( j = 0; j &lt; ( points.length - 1 ); j ++ ) {
</P><P>				base = j + i * points.length;
</P><P>				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;
</P><P>				// faces
</P><P>				indices.push( a, b, d );
				indices.push( b, c, d );
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>		// generate normals
</P><P>		this.computeVertexNormals();
</P><P>		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).
</P><P>		if ( phiLength === Math.PI * 2 ) {
</P><P>			var normals = this.attributes.normal.array;
			var n1 = new Vector3();
			var n2 = new Vector3();
			var n = new Vector3();
</P><P>			// this is the buffer offset for the last line of vertices
</P><P>			base = segments * points.length * 3;
</P><P>			for ( i = 0, j = 0; i &lt; points.length; i ++, j += 3 ) {
</P><P>				// select the normal of the vertex in the first line
</P><P>				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];
</P><P>				// select the normal of the vertex in the last line
</P><P>				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];
</P><P>				// average normals
</P><P>				n.addVectors( n1, n2 ).normalize();
</P><P>				// assign the new values to both normals
</P><P>				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;
</P><P>			}
</P><P>		}
</P><P>	}
</P><P>	LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
</P><P>	/**
	 * @author jonobr1 / <A rel="nofollow" class="external free" href="http://jonobr1.com">http://jonobr1.com</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// ShapeGeometry
</P><P>	function ShapeGeometry( shapes, curveSegments ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'ShapeGeometry';
</P><P>		if ( typeof curveSegments === 'object' ) {
</P><P>			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );
</P><P>			curveSegments = curveSegments.curveSegments;
</P><P>		}
</P><P>		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};
</P><P>		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
		this.mergeVertices();
</P><P>	}
</P><P>	ShapeGeometry.prototype = Object.create( Geometry.prototype );
	ShapeGeometry.prototype.constructor = ShapeGeometry;
</P><P>	ShapeGeometry.prototype.toJSON = function () {
</P><P>		var data = Geometry.prototype.toJSON.call( this );
</P><P>		var shapes = this.parameters.shapes;
</P><P>		return toJSON$1( shapes, data );
</P><P>	};
</P><P>	// ShapeBufferGeometry
</P><P>	function ShapeBufferGeometry( shapes, curveSegments ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'ShapeBufferGeometry';
</P><P>		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};
</P><P>		curveSegments = curveSegments || 12;
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		// helper variables
</P><P>		var groupStart = 0;
		var groupCount = 0;
</P><P>		// allow single and array values for &quot;shapes&quot; parameter
</P><P>		if ( Array.isArray( shapes ) === false ) {
</P><P>			addShape( shapes );
</P><P>		} else {
</P><P>			for ( var i = 0; i &lt; shapes.length; i ++ ) {
</P><P>				addShape( shapes[ i ] );
</P><P>				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support
</P><P>				groupStart += groupCount;
				groupCount = 0;
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>
		// helper functions
</P><P>		function addShape( shape ) {
</P><P>			var i, l, shapeHole;
</P><P>			var indexOffset = vertices.length / 3;
			var points = shape.extractPoints( curveSegments );
</P><P>			var shapeVertices = points.shape;
			var shapeHoles = points.holes;
</P><P>			// check direction of vertices
</P><P>			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {
</P><P>				shapeVertices = shapeVertices.reverse();
</P><P>				// also check if holes are in the opposite direction
</P><P>				for ( i = 0, l = shapeHoles.length; i &lt; l; i ++ ) {
</P><P>					shapeHole = shapeHoles[ i ];
</P><P>					if ( ShapeUtils.isClockWise( shapeHole ) === true ) {
</P><P>						shapeHoles[ i ] = shapeHole.reverse();
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );
</P><P>			// join vertices of inner and outer paths to a single array
</P><P>			for ( i = 0, l = shapeHoles.length; i &lt; l; i ++ ) {
</P><P>				shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );
</P><P>			}
</P><P>			// vertices, normals, uvs
</P><P>			for ( i = 0, l = shapeVertices.length; i &lt; l; i ++ ) {
</P><P>				var vertex = shapeVertices[ i ];
</P><P>				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs
</P><P>			}
</P><P>			// incides
</P><P>			for ( i = 0, l = faces.length; i &lt; l; i ++ ) {
</P><P>				var face = faces[ i ];
</P><P>				var a = face[ 0 ] + indexOffset;
				var b = face[ 1 ] + indexOffset;
				var c = face[ 2 ] + indexOffset;
</P><P>				indices.push( a, b, c );
				groupCount += 3;
</P><P>			}
</P><P>		}
</P><P>	}
</P><P>	ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
</P><P>	ShapeBufferGeometry.prototype.toJSON = function () {
</P><P>		var data = BufferGeometry.prototype.toJSON.call( this );
</P><P>		var shapes = this.parameters.shapes;
</P><P>		return toJSON$1( shapes, data );
</P><P>	};
</P><P>	//
</P><P>	function toJSON$1( shapes, data ) {
</P><P>		data.shapes = [];
</P><P>		if ( Array.isArray( shapes ) ) {
</P><P>			for ( var i = 0, l = shapes.length; i &lt; l; i ++ ) {
</P><P>				var shape = shapes[ i ];
</P><P>				data.shapes.push( shape.uuid );
</P><P>			}
</P><P>		} else {
</P><P>			data.shapes.push( shapes.uuid );
</P><P>		}
</P><P>		return data;
</P><P>	}
</P><P>	/**
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	function EdgesGeometry( geometry, thresholdAngle ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'EdgesGeometry';
</P><P>		this.parameters = {
			thresholdAngle: thresholdAngle
		};
</P><P>		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
</P><P>		// buffer
</P><P>		var vertices = [];
</P><P>		// helper variables
</P><P>		var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
		var edge = [ 0, 0 ], edges = {}, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
</P><P>		// prepare source geometry
</P><P>		var geometry2;
</P><P>		if ( geometry.isBufferGeometry ) {
</P><P>			geometry2 = new Geometry();
			geometry2.fromBufferGeometry( geometry );
</P><P>		} else {
</P><P>			geometry2 = geometry.clone();
</P><P>		}
</P><P>		geometry2.mergeVertices();
		geometry2.computeFaceNormals();
</P><P>		var sourceVertices = geometry2.vertices;
		var faces = geometry2.faces;
</P><P>		// now create a data structure where each entry represents an edge with its adjoining faces
</P><P>		for ( var i = 0, l = faces.length; i &lt; l; i ++ ) {
</P><P>			var face = faces[ i ];
</P><P>			for ( var j = 0; j &lt; 3; j ++ ) {
</P><P>				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 );
				edge[ 1 ] = Math.max( edge1, edge2 );
</P><P>				key = edge[ 0 ] + ',' + edge[ 1 ];
</P><P>				if ( edges[ key ] === undefined ) {
</P><P>					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };
</P><P>				} else {
</P><P>					edges[ key ].face2 = i;
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		// generate vertices
</P><P>		for ( key in edges ) {
</P><P>			var e = edges[ key ];
</P><P>			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
</P><P>			if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) &lt;= thresholdDot ) {
</P><P>				var vertex = sourceVertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>				vertex = sourceVertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>			}
</P><P>		}
</P><P>		// build geometry
</P><P>		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
</P><P>	}
</P><P>	EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
	EdgesGeometry.prototype.constructor = EdgesGeometry;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	// CylinderGeometry
</P><P>	function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'CylinderGeometry';
</P><P>		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();
</P><P>	}
</P><P>	CylinderGeometry.prototype = Object.create( Geometry.prototype );
	CylinderGeometry.prototype.constructor = CylinderGeometry;
</P><P>	// CylinderBufferGeometry
</P><P>	function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'CylinderBufferGeometry';
</P><P>		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>		var scope = this;
</P><P>		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;
</P><P>		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;
</P><P>		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		// helper variables
</P><P>		var index = 0;
		var indexArray = [];
		var halfHeight = height / 2;
		var groupStart = 0;
</P><P>		// generate geometry
</P><P>		generateTorso();
</P><P>		if ( openEnded === false ) {
</P><P>			if ( radiusTop &gt; 0 ) generateCap( true );
			if ( radiusBottom &gt; 0 ) generateCap( false );
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>		function generateTorso() {
</P><P>			var x, y;
			var normal = new Vector3();
			var vertex = new Vector3();
</P><P>			var groupCount = 0;
</P><P>			// this will be used to calculate the normal
			var slope = ( radiusBottom - radiusTop ) / height;
</P><P>			// generate vertices, normals and uvs
</P><P>			for ( y = 0; y &lt;= heightSegments; y ++ ) {
</P><P>				var indexRow = [];
</P><P>				var v = y / heightSegments;
</P><P>				// calculate the radius of the current row
</P><P>				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
</P><P>				for ( x = 0; x &lt;= radialSegments; x ++ ) {
</P><P>					var u = x / radialSegments;
</P><P>					var theta = u * thetaLength + thetaStart;
</P><P>					var sinTheta = Math.sin( theta );
					var cosTheta = Math.cos( theta );
</P><P>					// vertex
</P><P>					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>					// normal
</P><P>					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );
</P><P>					// uv
</P><P>					uvs.push( u, 1 - v );
</P><P>					// save index of vertex in respective row
</P><P>					indexRow.push( index ++ );
</P><P>				}
</P><P>				// now save vertices of the row in our index array
</P><P>				indexArray.push( indexRow );
</P><P>			}
</P><P>// generate indices
</P><P>			for ( x = 0; x &lt; radialSegments; x ++ ) {
</P><P>				for ( y = 0; y &lt; heightSegments; y ++ ) {
</P><P>					// we use the index array to access the correct indices
</P><P>					var a = indexArray[ y ][ x ];
					var b = indexArray[ y + 1 ][ x ];
					var c = indexArray[ y + 1 ][ x + 1 ];
					var d = indexArray[ y ][ x + 1 ];
</P><P>					// faces
</P><P>					indices.push( a, b, d );
					indices.push( b, c, d );
</P><P>					// update group counter
</P><P>					groupCount += 6;
</P><P>				}
</P><P>			}
</P><P>			// add a group to the geometry. this will ensure multi material support
</P><P>			scope.addGroup( groupStart, groupCount, 0 );
</P><P>			// calculate new start value for groups
</P><P>			groupStart += groupCount;
</P><P>		}
</P><P>		function generateCap( top ) {
</P><P>			var x, centerIndexStart, centerIndexEnd;
</P><P>			var uv = new Vector2();
			var vertex = new Vector3();
</P><P>			var groupCount = 0;
</P><P>			var radius = ( top === true ) ? radiusTop : radiusBottom;
			var sign = ( top === true ) ? 1 : - 1;
</P><P>			// save the index of the first center vertex
			centerIndexStart = index;
</P><P>			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment
</P><P>			for ( x = 1; x &lt;= radialSegments; x ++ ) {
</P><P>				// vertex
</P><P>				vertices.push( 0, halfHeight * sign, 0 );
</P><P>				// normal
</P><P>				normals.push( 0, sign, 0 );
</P><P>				// uv
</P><P>				uvs.push( 0.5, 0.5 );
</P><P>				// increase index
</P><P>				index ++;
</P><P>			}
</P><P>			// save the index of the last center vertex
</P><P>			centerIndexEnd = index;
</P><P>			// now we generate the surrounding vertices, normals and uvs
</P><P>			for ( x = 0; x &lt;= radialSegments; x ++ ) {
</P><P>				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;
</P><P>				var cosTheta = Math.cos( theta );
				var sinTheta = Math.sin( theta );
</P><P>	// vertex
</P><P>				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>				// normal
</P><P>				normals.push( 0, sign, 0 );
</P><P>				// uv
</P><P>				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );
</P><P>				// increase index
</P><P>				index ++;
</P><P>			}
</P><P>			// generate indices
</P><P>			for ( x = 0; x &lt; radialSegments; x ++ ) {
</P><P>				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;
</P><P>				if ( top === true ) {
</P><P>					// face top
</P><P>					indices.push( i, i + 1, c );
</P><P>				} else {
</P><P>					// face bottom
</P><P>					indices.push( i + 1, i, c );
</P><P>				}
</P><P>				groupCount += 3;
</P><P>			}
</P><P>			// add a group to the geometry. this will ensure multi material support
</P><P>			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );
</P><P>			// calculate new start value for groups
</P><P>			groupStart += groupCount;
</P><P>		}
</P><P>	}
</P><P>	CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
</P><P>	/**
	 * @author abelnation / <A rel="nofollow" class="external free" href="http://github.com/abelnation">http://github.com/abelnation</A>
	 */
</P><P>	// ConeGeometry
</P><P>	function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
</P><P>		CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
</P><P>		this.type = 'ConeGeometry';
</P><P>		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>	}
</P><P>	ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
	ConeGeometry.prototype.constructor = ConeGeometry;
</P><P>	// ConeBufferGeometry
</P><P>	function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
</P><P>		CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
</P><P>		this.type = 'ConeBufferGeometry';
</P><P>		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>	}
</P><P>	ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
</P><P>	/**
	 * @author benaadams / <A rel="nofollow" class="external free" href="https://twitter.com/ben_a_adams">https://twitter.com/ben_a_adams</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 * @author hughes
	 */
</P><P>	// CircleGeometry
</P><P>	function CircleGeometry( radius, segments, thetaStart, thetaLength ) {
</P><P>		Geometry.call( this );
</P><P>		this.type = 'CircleGeometry';
</P><P>		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
		this.mergeVertices();
</P><P>	}
</P><P>	CircleGeometry.prototype = Object.create( Geometry.prototype );
	CircleGeometry.prototype.constructor = CircleGeometry;
</P><P>	// CircleBufferGeometry
</P><P>	function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'CircleBufferGeometry';
</P><P>		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
</P><P>		radius = radius || 1;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;
</P><P>		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
</P><P>		// buffers
</P><P>		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
</P><P>		// helper variables
</P><P>		var i, s;
		var vertex = new Vector3();
		var uv = new Vector2();
</P><P>		// center point
</P><P>		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );
</P><P>		for ( s = 0, i = 3; s &lt;= segments; s ++, i += 3 ) {
</P><P>			var segment = thetaStart + s / segments * thetaLength;
</P><P>			// vertex
</P><P>			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );
</P><P>			vertices.push( vertex.x, vertex.y, vertex.z );
</P><P>			// normal
</P><P>			normals.push( 0, 0, 1 );
</P><P>			// uvs
</P><P>			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;
</P><P>			uvs.push( uv.x, uv.y );
</P><P>		}
</P><P>		// indices
</P><P>		for ( i = 1; i &lt;= segments; i ++ ) {
</P><P>			indices.push( i, i + 1, 0 );
</P><P>		}
</P><P>		// build geometry
</P><P>		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
</P><P>	}
</P><P>	CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
</P><P>	var Geometries = /*#__PURE__*/Object.freeze({
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextBufferGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxBufferGeometry
	});
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 *
	 * parameters = {
	 *  color: &lt;THREE.Color&gt;
	 * }
	 */
</P><P>	function ShadowMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'ShadowMaterial';
</P><P>		this.color = new Color( 0x000000 );
		this.transparent = true;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	ShadowMaterial.prototype = Object.create( Material.prototype );
	ShadowMaterial.prototype.constructor = ShadowMaterial;
</P><P>	ShadowMaterial.prototype.isShadowMaterial = true;
</P><P>	ShadowMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.color.copy( source.color );
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function RawShaderMaterial( parameters ) {
</P><P>		ShaderMaterial.call( this, parameters );
</P><P>		this.type = 'RawShaderMaterial';
</P><P>	}
</P><P>	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;
</P><P>	RawShaderMaterial.prototype.isRawShaderMaterial = true;
</P><P>	/**
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 *
	 * parameters = {
	 *  color: &lt;hex&gt;,
	 *  roughness: &lt;float&gt;,
	 *  metalness: &lt;float&gt;,
	 *  opacity: &lt;float&gt;,
	 *
	 *  map: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  lightMap: new THREE.Texture( &lt;Image&gt; ),
	 *  lightMapIntensity: &lt;float&gt;
	 *
	 *  aoMap: new THREE.Texture( &lt;Image&gt; ),
	 *  aoMapIntensity: &lt;float&gt;
	 *
	 *  emissive: &lt;hex&gt;,
	 *  emissiveIntensity: &lt;float&gt;
	 *  emissiveMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  bumpMap: new THREE.Texture( &lt;Image&gt; ),
	 *  bumpScale: &lt;float&gt;,
	 *
	 *  normalMap: new THREE.Texture( &lt;Image&gt; ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: &lt;Vector2&gt;,
	 *
	 *  displacementMap: new THREE.Texture( &lt;Image&gt; ),
	 *  displacementScale: &lt;float&gt;,
	 *  displacementBias: &lt;float&gt;,
	 *
	 *  roughnessMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  metalnessMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  alphaMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: &lt;float&gt;
	 *
	 *  refractionRatio: &lt;float&gt;,
	 *
	 *  wireframe: &lt;boolean&gt;,
	 *  wireframeLinewidth: &lt;float&gt;,
	 *
	 *  skinning: &lt;bool&gt;,
	 *  morphTargets: &lt;bool&gt;,
	 *  morphNormals: &lt;bool&gt;
	 * }
	 */
</P><P>	function MeshStandardMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.defines = { 'STANDARD': <I> };</I></P><P>		this.type = 'MeshStandardMaterial';
</P><P>		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;
</P><P>		this.map = null;
</P><P>		this.lightMap = null;
		this.lightMapIntensity = 1.0;
</P><P>		this.aoMap = null;
		this.aoMapIntensity = 1.0;
</P><P>		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
</P><P>		this.bumpMap = null;
		this.bumpScale = 1;
</P><P>		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );
</P><P>		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
</P><P>		this.roughnessMap = null;
</P><P>		this.metalnessMap = null;
</P><P>		this.alphaMap = null;
</P><P>		this.envMap = null;
		this.envMapIntensity = 1.0;
</P><P>		this.refractionRatio = 0.98;
</P><P>		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
</P><P>		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
</P><P>	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
</P><P>	MeshStandardMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.defines = { 'STANDARD': <I> };</I></P><P>		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;
</P><P>		this.map = source.map;
</P><P>		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
</P><P>		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
</P><P>		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
</P><P>		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
</P><P>		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );
</P><P>		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
</P><P>		this.roughnessMap = source.roughnessMap;
</P><P>		this.metalnessMap = source.metalnessMap;
</P><P>		this.alphaMap = source.alphaMap;
</P><P>		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;
</P><P>		this.refractionRatio = source.refractionRatio;
</P><P>		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
</P><P>		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 *
	 * parameters = {
	 *  reflectivity: &lt;float&gt;
	 * }
	 */
</P><P>	function MeshPhysicalMaterial( parameters ) {
</P><P>		MeshStandardMaterial.call( this );
</P><P>		this.defines = { 'PHYSICAL': <I> };</I></P><P>		this.type = 'MeshPhysicalMaterial';
</P><P>		this.reflectivity = 0.5; // maps to F0 = 0.04
</P><P>		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
</P><P>	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
</P><P>	MeshPhysicalMaterial.prototype.copy = function ( source ) {
</P><P>		MeshStandardMaterial.prototype.copy.call( this, source );
</P><P>		this.defines = { 'PHYSICAL': <I> };</I></P><P>		this.reflectivity = source.reflectivity;
</P><P>		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 *
	 * parameters = {
	 *  color: &lt;hex&gt;,
	 *  specular: &lt;hex&gt;,
	 *  shininess: &lt;float&gt;,
	 *  opacity: &lt;float&gt;,
	 *
	 *  map: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  lightMap: new THREE.Texture( &lt;Image&gt; ),
	 *  lightMapIntensity: &lt;float&gt;
	 *
	 *  aoMap: new THREE.Texture( &lt;Image&gt; ),
	 *  aoMapIntensity: &lt;float&gt;
	 *
	 *  emissive: &lt;hex&gt;,
	 *  emissiveIntensity: &lt;float&gt;
	 *  emissiveMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  bumpMap: new THREE.Texture( &lt;Image&gt; ),
	 *  bumpScale: &lt;float&gt;,
	 *
	 *  normalMap: new THREE.Texture( &lt;Image&gt; ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: &lt;Vector2&gt;,
	 *
	 *  displacementMap: new THREE.Texture( &lt;Image&gt; ),
	 *  displacementScale: &lt;float&gt;,
	 *  displacementBias: &lt;float&gt;,
	 *
	 *  specularMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  alphaMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: &lt;float&gt;,
	 *  refractionRatio: &lt;float&gt;,
	 *
	 *  wireframe: &lt;boolean&gt;,
	 *  wireframeLinewidth: &lt;float&gt;,
	 *
	 *  skinning: &lt;bool&gt;,
	 *  morphTargets: &lt;bool&gt;,
	 *  morphNormals: &lt;bool&gt;
	 * }
	 */
</P><P>	function MeshPhongMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'MeshPhongMaterial';
</P><P>		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;
</P><P>		this.map = null;
</P><P>		this.lightMap = null;
		this.lightMapIntensity = 1.0;
</P><P>		this.aoMap = null;
		this.aoMapIntensity = 1.0;
</P><P>		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
</P><P>		this.bumpMap = null;
		this.bumpScale = 1;
</P><P>		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );
</P><P>		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
</P><P>		this.specularMap = null;
</P><P>		this.alphaMap = null;
</P><P>		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
</P><P>		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
</P><P>		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	MeshPhongMaterial.prototype = Object.create( Material.prototype );
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
</P><P>	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
</P><P>	MeshPhongMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;
</P><P>		this.map = source.map;
</P><P>		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
</P><P>		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
</P><P>		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
</P><P>		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
</P><P>		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );
</P><P>		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
</P><P>		this.specularMap = source.specularMap;
</P><P>		this.alphaMap = source.alphaMap;
</P><P>		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
</P><P>		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
</P><P>		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author takahirox / <A rel="nofollow" class="external free" href="http://github.com/takahirox">http://github.com/takahirox</A>
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( &lt;Image&gt; )
	 * }
	 */
</P><P>	function MeshToonMaterial( parameters ) {
</P><P>		MeshPhongMaterial.call( this );
</P><P>		this.defines = { 'TOON': <I> };</I></P><P>		this.type = 'MeshToonMaterial';
</P><P>		this.gradientMap = null;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;
</P><P>	MeshToonMaterial.prototype.isMeshToonMaterial = true;
</P><P>	MeshToonMaterial.prototype.copy = function ( source ) {
</P><P>		MeshPhongMaterial.prototype.copy.call( this, source );
</P><P>		this.gradientMap = source.gradientMap;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 *
	 * parameters = {
	 *  opacity: &lt;float&gt;,
	 *
	 *  bumpMap: new THREE.Texture( &lt;Image&gt; ),
	 *  bumpScale: &lt;float&gt;,
	 *
	 *  normalMap: new THREE.Texture( &lt;Image&gt; ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: &lt;Vector2&gt;,
	 *
	 *  displacementMap: new THREE.Texture( &lt;Image&gt; ),
	 *  displacementScale: &lt;float&gt;,
	 *  displacementBias: &lt;float&gt;,
	 *
	 *  wireframe: &lt;boolean&gt;,
	 *  wireframeLinewidth: &lt;float&gt;
	 *
	 *  skinning: &lt;bool&gt;,
	 *  morphTargets: &lt;bool&gt;,
	 *  morphNormals: &lt;bool&gt;
	 * }
	 */
</P><P>	function MeshNormalMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'MeshNormalMaterial';
</P><P>		this.bumpMap = null;
		this.bumpScale = 1;
</P><P>		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );
</P><P>		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
</P><P>		this.wireframe = false;
		this.wireframeLinewidth = 1;
</P><P>		this.fog = false;
		this.lights = false;
</P><P>		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	MeshNormalMaterial.prototype = Object.create( Material.prototype );
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
</P><P>	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
</P><P>	MeshNormalMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
</P><P>		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );
</P><P>		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
</P><P>		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
</P><P>		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 *
	 * parameters = {
	 *  color: &lt;hex&gt;,
	 *  opacity: &lt;float&gt;,
	 *
	 *  map: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  lightMap: new THREE.Texture( &lt;Image&gt; ),
	 *  lightMapIntensity: &lt;float&gt;
	 *
	 *  aoMap: new THREE.Texture( &lt;Image&gt; ),
	 *  aoMapIntensity: &lt;float&gt;
	 *
	 *  emissive: &lt;hex&gt;,
	 *  emissiveIntensity: &lt;float&gt;
	 *  emissiveMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  specularMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  alphaMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: &lt;float&gt;,
	 *  refractionRatio: &lt;float&gt;,
	 *
	 *  wireframe: &lt;boolean&gt;,
	 *  wireframeLinewidth: &lt;float&gt;,
	 *
	 *  skinning: &lt;bool&gt;,
	 *  morphTargets: &lt;bool&gt;,
	 *  morphNormals: &lt;bool&gt;
	 * }
	 */
</P><P>	function MeshLambertMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.type = 'MeshLambertMaterial';
</P><P>		this.color = new Color( 0xffffff ); // diffuse
</P><P>		this.map = null;
</P><P>		this.lightMap = null;
		this.lightMapIntensity = 1.0;
</P><P>		this.aoMap = null;
		this.aoMapIntensity = 1.0;
</P><P>		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
</P><P>		this.specularMap = null;
</P><P>		this.alphaMap = null;
</P><P>		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
</P><P>		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
</P><P>		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	MeshLambertMaterial.prototype = Object.create( Material.prototype );
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
</P><P>	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
</P><P>	MeshLambertMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.color.copy( source.color );
</P><P>		this.map = source.map;
</P><P>		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
</P><P>		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
</P><P>		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
</P><P>		this.specularMap = source.specularMap;
</P><P>		this.alphaMap = source.alphaMap;
</P><P>		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
</P><P>		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
</P><P>		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 *
	 * parameters = {
	 *  color: &lt;hex&gt;,
	 *  opacity: &lt;float&gt;,
	 *
	 *  matcap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  map: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  bumpMap: new THREE.Texture( &lt;Image&gt; ),
	 *  bumpScale: &lt;float&gt;,
	 *
	 *  normalMap: new THREE.Texture( &lt;Image&gt; ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: &lt;Vector2&gt;,
	 *
	 *  displacementMap: new THREE.Texture( &lt;Image&gt; ),
	 *  displacementScale: &lt;float&gt;,
	 *  displacementBias: &lt;float&gt;,
	 *
	 *  alphaMap: new THREE.Texture( &lt;Image&gt; ),
	 *
	 *  skinning: &lt;bool&gt;,
	 *  morphTargets: &lt;bool&gt;,
	 *  morphNormals: &lt;bool&gt;
	 * }
	 */
</P><P>	function MeshMatcapMaterial( parameters ) {
</P><P>		Material.call( this );
</P><P>		this.defines = { 'MATCAP': <I> };</I></P><P>		this.type = 'MeshMatcapMaterial';
</P><P>		this.color = new Color( 0xffffff ); // diffuse
</P><P>		this.matcap = null;
</P><P>		this.map = null;
</P><P>		this.bumpMap = null;
		this.bumpScale = 1;
</P><P>		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );
</P><P>		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
</P><P>		this.alphaMap = null;
</P><P>		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
</P><P>		this.lights = false;
</P><P>		this.setValues( parameters );
</P><P>		// a matcap is required
</P><P>		if ( this.matcap === null ) {
</P><P>			var canvas = document.createElement( 'canvas' );
			canvas.width = 1;
			canvas.height = 1;
</P><P>			var context = canvas.getContext( '2d' );
</P><P>			context.fillStyle = '#fff';
			context.fillRect( 0, 0, 1, 1 );
</P><P>			this.matcap = new THREE.CanvasTexture( canvas );
</P><P>		}
</P><P>	}
</P><P>	MeshMatcapMaterial.prototype = Object.create( Material.prototype );
	MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
</P><P>	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
</P><P>	MeshMatcapMaterial.prototype.copy = function ( source ) {
</P><P>		Material.prototype.copy.call( this, source );
</P><P>		this.defines = { 'MATCAP': <I> };</I></P><P>		this.color.copy( source.color );
</P><P>		this.matcap = source.matcap;
</P><P>		this.map = source.map;
</P><P>		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
</P><P>		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );
</P><P>		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
</P><P>		this.alphaMap = source.alphaMap;
</P><P>		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 *
	 * parameters = {
	 *  color: &lt;hex&gt;,
	 *  opacity: &lt;float&gt;,
	 *
	 *  linewidth: &lt;float&gt;,
	 *
	 *  scale: &lt;float&gt;,
	 *  dashSize: &lt;float&gt;,
	 *  gapSize: &lt;float&gt;
	 * }
	 */
</P><P>	function LineDashedMaterial( parameters ) {
</P><P>		LineBasicMaterial.call( this );
</P><P>		this.type = 'LineDashedMaterial';
</P><P>		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
</P><P>		this.setValues( parameters );
</P><P>	}
</P><P>	LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;
</P><P>	LineDashedMaterial.prototype.isLineDashedMaterial = true;
</P><P>	LineDashedMaterial.prototype.copy = function ( source ) {
</P><P>		LineBasicMaterial.prototype.copy.call( this, source );
</P><P>		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
</P><P>		return this;
</P><P>	};
</P><P>	var Materials = /*#__PURE__*/Object.freeze({
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	var Cache = {
</P><P>		enabled: false,
</P><P>		files: {},
</P><P>		add: function ( key, file ) {
</P><P>			if ( this.enabled === false ) return;
</P><P>			// console.log( 'THREE.Cache', 'Adding key:', key );
</P><P>			this.files[ key ] = file;
</P><P>		},
</P><P>		get: function ( key ) {
</P><P>			if ( this.enabled === false ) return;
</P><P>			// console.log( 'THREE.Cache', 'Checking key:', key );
</P><P>			return this.files[ key ];
</P><P>		},
</P><P>		remove: function ( key ) {
</P><P>			delete this.files[ key ];
</P><P>		},
</P><P>		clear: function () {
</P><P>			this.files = {};
</P><P>		}
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function LoadingManager( onLoad, onProgress, onError ) {
</P><P>		var scope = this;
</P><P>		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;
</P><P>		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor
</P><P>		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
</P><P>		this.itemStart = function ( url ) {
</P><P>			itemsTotal ++;
</P><P>			if ( isLoading === false ) {
</P><P>				if ( scope.onStart !== undefined ) {
</P><P>					scope.onStart( url, itemsLoaded, itemsTotal );
</P><P>				}
</P><P>			}
</P><P>			isLoading = true;
</P><P>		};
</P><P>		this.itemEnd = function ( url ) {
</P><P>			itemsLoaded ++;
</P><P>			if ( scope.onProgress !== undefined ) {
</P><P>				scope.onProgress( url, itemsLoaded, itemsTotal );
</P><P>			}
</P><P>			if ( itemsLoaded === itemsTotal ) {
</P><P>				isLoading = false;
</P><P>				if ( scope.onLoad !== undefined ) {
</P><P>					scope.onLoad();
</P><P>				}
</P><P>			}
</P><P>		};
</P><P>		this.itemError = function ( url ) {
</P><P>			if ( scope.onError !== undefined ) {
</P><P>				scope.onError( url );
</P><P>			}
</P><P>		};
</P><P>		this.resolveURL = function ( url ) {
</P><P>			if ( urlModifier ) {
</P><P>				return urlModifier( url );
</P><P>			}
</P><P>			return url;
</P><P>		};
</P><P>		this.setURLModifier = function ( transform ) {
</P><P>			urlModifier = transform;
			return this;
</P><P>		};
</P><P>	}
</P><P>	var DefaultLoadingManager = new LoadingManager();
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	var loading = {};
</P><P>	function FileLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>	}
</P><P>	Object.assign( FileLoader.prototype, {
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			if ( url === undefined ) url = <I>;</I></P><P>			if ( this.path !== undefined ) url = this.path + url;
</P><P>			url = this.manager.resolveURL( url );
</P><P>			var scope = this;
</P><P>			var cached = Cache.get( url );
</P><P>			if ( cached !== undefined ) {
</P><P>				scope.manager.itemStart( url );
</P><P>				setTimeout( function () {
</P><P>					if ( onLoad ) onLoad( cached );
</P><P>					scope.manager.itemEnd( url );
</P><P>				}, 0 );
</P><P>				return cached;
</P><P>			}
</P><P>			// Check if request is duplicate
</P><P>			if ( loading[ url ] !== undefined ) {
</P><P>				loading[ url ].push( {
</P><P>					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
</P><P>				} );
</P><P>				return;
</P><P>			}
</P><P>			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );
</P><P>			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {
</P><P>				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];
				var data = dataUriRegexResult[ 3 ];
</P><P>				data = window.decodeURIComponent( data );
</P><P>				if ( isBase64 ) data = window.atob( data );
</P><P>				try {
</P><P>					var response;
					var responseType = ( this.responseType || <I> ).toLowerCase();</I></P><P>					switch ( responseType ) {
</P><P>						case 'arraybuffer':
						case 'blob':
</P><P>							var view = new Uint8Array( data.length );
</P><P>							for ( var i = 0; i &lt; data.length; i ++ ) {
</P><P>								view[ i ] = data.charCodeAt( i );
</P><P>							}
</P><P>							if ( responseType === 'blob' ) {
</P><P>								response = new Blob( [ view.buffer ], { type: mimeType } );
</P><P>							} else {
</P><P>								response = view.buffer;
</P><P>							}
</P><P>							break;
</P><P>						case 'document':
</P><P>							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );
</P><P>							break;
</P><P>						case 'json':
</P><P>							response = JSON.parse( data );
</P><P>							break;
</P><P>						default: // 'text' or other
</P><P>							response = data;
</P><P>							break;
</P><P>					}
</P><P>					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {
</P><P>						if ( onLoad ) onLoad( response );
</P><P>						scope.manager.itemEnd( url );
</P><P>					}, 0 );
</P><P>				} catch ( error ) {
</P><P>					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {
</P><P>						if ( onError ) onError( error );
</P><P>						scope.manager.itemEnd( url );
						scope.manager.itemError( url );
</P><P>					}, 0 );
</P><P>				}
</P><P>			} else {
</P><P>				// Initialise array for duplicate requests
</P><P>				loading[ url ] = [];
</P><P>				loading[ url ].push( {
</P><P>					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
</P><P>				} );
</P><P>				var request = new XMLHttpRequest();
</P><P>				request.open( 'GET', url, true );
</P><P>				request.addEventListener( 'load', function ( event ) {
</P><P>					var response = this.response;
</P><P>					Cache.add( url, response );
</P><P>					var callbacks = loading[ url ];
</P><P>					delete loading[ url ];
</P><P>					if ( this.status === 200 || this.status === 0 ) {
</P><P>						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.
</P><P>						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );
</P><P>						for ( var i = 0, il = callbacks.length; i &lt; il; i ++ ) {
</P><P>							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );
</P><P>						}
</P><P>						scope.manager.itemEnd( url );
</P><P>					} else {
</P><P>						for ( var i = 0, il = callbacks.length; i &lt; il; i ++ ) {
</P><P>							var callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );
</P><P>						}
</P><P>						scope.manager.itemEnd( url );
						scope.manager.itemError( url );
</P><P>					}
</P><P>				}, false );
</P><P>				request.addEventListener( 'progress', function ( event ) {
</P><P>					var callbacks = loading[ url ];
</P><P>					for ( var i = 0, il = callbacks.length; i &lt; il; i ++ ) {
</P><P>						var callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );
</P><P>					}
</P><P>				}, false );
</P><P>				request.addEventListener( 'error', function ( event ) {
</P><P>					var callbacks = loading[ url ];
</P><P>					delete loading[ url ];
</P><P>					for ( var i = 0, il = callbacks.length; i &lt; il; i ++ ) {
</P><P>						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );
</P><P>					}
</P><P>					scope.manager.itemEnd( url );
					scope.manager.itemError( url );
</P><P>				}, false );
</P><P>				request.addEventListener( 'abort', function ( event ) {
</P><P>					var callbacks = loading[ url ];
</P><P>					delete loading[ url ];
</P><P>					for ( var i = 0, il = callbacks.length; i &lt; il; i ++ ) {
</P><P>						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );
</P><P>					}
</P><P>					scope.manager.itemEnd( url );
					scope.manager.itemError( url );
</P><P>				}, false );
</P><P>				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
</P><P>				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );
</P><P>				for ( var header in this.requestHeader ) {
</P><P>					request.setRequestHeader( header, this.requestHeader[ header ] );
</P><P>				}
</P><P>				request.send( null );
</P><P>			}
</P><P>			scope.manager.itemStart( url );
</P><P>			return request;
</P><P>		},
</P><P>		setPath: function ( value ) {
</P><P>			this.path = value;
			return this;
</P><P>		},
</P><P>		setResponseType: function ( value ) {
</P><P>			this.responseType = value;
			return this;
</P><P>		},
</P><P>		setWithCredentials: function ( value ) {
</P><P>			this.withCredentials = value;
			return this;
</P><P>		},
</P><P>		setMimeType: function ( value ) {
</P><P>			this.mimeType = value;
			return this;
</P><P>		},
</P><P>		setRequestHeader: function ( value ) {
</P><P>			this.requestHeader = value;
			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */
</P><P>	function CompressedTextureLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>		// override in sub classes
		this._parser = null;
</P><P>	}
</P><P>	Object.assign( CompressedTextureLoader.prototype, {
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			var scope = this;
</P><P>			var images = [];
</P><P>			var texture = new CompressedTexture();
			texture.image = images;
</P><P>			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
</P><P>			function loadTexture( i ) {
</P><P>				loader.load( url[ i ], function ( buffer ) {
</P><P>					var texDatas = scope._parser( buffer, true );
</P><P>					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
</P><P>					loaded += 1;
</P><P>					if ( loaded === 6 ) {
</P><P>						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = LinearFilter;
</P><P>						texture.format = texDatas.format;
						texture.needsUpdate = true;
</P><P>						if ( onLoad ) onLoad( texture );
</P><P>					}
</P><P>				}, onProgress, onError );
</P><P>			}
</P><P>			if ( Array.isArray( url ) ) {
</P><P>				var loaded = 0;
</P><P>				for ( var i = 0, il = url.length; i &lt; il; ++ i ) {
</P><P>					loadTexture( i );
</P><P>				}
</P><P>			} else {
</P><P>				// compressed cubemap texture stored in a single DDS file
</P><P>				loader.load( url, function ( buffer ) {
</P><P>					var texDatas = scope._parser( buffer, true );
</P><P>					if ( texDatas.isCubemap ) {
</P><P>						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
</P><P>						for ( var f = 0; f &lt; faces; f ++ ) {
</P><P>							images[ f ] = { mipmaps: [] };
</P><P>							for ( var i = 0; i &lt; texDatas.mipmapCount; i ++ ) {
</P><P>								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;
</P><P>							}
</P><P>						}
</P><P>					} else {
</P><P>						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
</P><P>					}
</P><P>					if ( texDatas.mipmapCount === 1 ) {
</P><P>						texture.minFilter = LinearFilter;
</P><P>					}
</P><P>					texture.format = texDatas.format;
					texture.needsUpdate = true;
</P><P>					if ( onLoad ) onLoad( texture );
</P><P>				}, onProgress, onError );
</P><P>			}
</P><P>			return texture;
</P><P>		},
</P><P>		setPath: function ( value ) {
</P><P>			this.path = value;
			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author Nikos M. / <A rel="nofollow" class="external free" href="https://github.com/foo123/">https://github.com/foo123/</A>
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */
</P><P>	function DataTextureLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>		// override in sub classes
		this._parser = null;
</P><P>	}
</P><P>	Object.assign( DataTextureLoader.prototype, {
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			var scope = this;
</P><P>			var texture = new DataTexture();
</P><P>			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
</P><P>			loader.load( url, function ( buffer ) {
</P><P>				var texData = scope._parser( buffer );
</P><P>				if ( ! texData ) return;
</P><P>				if ( undefined !== texData.image ) {
</P><P>					texture.image = texData.image;
</P><P>				} else if ( undefined !== texData.data ) {
</P><P>					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
</P><P>				}
</P><P>				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
</P><P>				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
</P><P>				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
</P><P>				if ( undefined !== texData.format ) {
</P><P>					texture.format = texData.format;
</P><P>				}
				if ( undefined !== texData.type ) {
</P><P>					texture.type = texData.type;
</P><P>				}
</P><P>				if ( undefined !== texData.mipmaps ) {
</P><P>					texture.mipmaps = texData.mipmaps;
</P><P>				}
</P><P>				if ( 1 === texData.mipmapCount ) {
</P><P>					texture.minFilter = LinearFilter;
</P><P>				}
</P><P>				texture.needsUpdate = true;
</P><P>				if ( onLoad ) onLoad( texture, texData );
</P><P>			}, onProgress, onError );
</P><P>
			return texture;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>
	function ImageLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>	}
</P><P>	Object.assign( ImageLoader.prototype, {
</P><P>		crossOrigin: 'anonymous',
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			if ( url === undefined ) url = <I>;</I></P><P>			if ( this.path !== undefined ) url = this.path + url;
</P><P>			url = this.manager.resolveURL( url );
</P><P>			var scope = this;
</P><P>			var cached = Cache.get( url );
</P><P>			if ( cached !== undefined ) {
</P><P>				scope.manager.itemStart( url );
</P><P>				setTimeout( function () {
</P><P>					if ( onLoad ) onLoad( cached );
</P><P>					scope.manager.itemEnd( url );
</P><P>				}, 0 );
</P><P>				return cached;
</P><P>			}
</P><P>			var image = document.createElementNS( '<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml'">http://www.w3.org/1999/xhtml'</A>, 'img' );
</P><P>			function onImageLoad() {
</P><P>				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );
</P><P>				Cache.add( url, this );
</P><P>				if ( onLoad ) onLoad( this );
</P><P>				scope.manager.itemEnd( url );
</P><P>			}
</P><P>			function onImageError( event ) {
</P><P>				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );
</P><P>				if ( onError ) onError( event );
</P><P>				scope.manager.itemEnd( url );
				scope.manager.itemError( url );
</P><P>			}
</P><P>			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );
</P><P>			if ( url.substr( 0, 5 ) !== 'data:' ) {
</P><P>				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
</P><P>			}
</P><P>			scope.manager.itemStart( url );
</P><P>			image.src = url;
</P><P>			return image;
</P><P>		},
</P><P>		setCrossOrigin: function ( value ) {
</P><P>			this.crossOrigin = value;
			return this;
</P><P>		},
</P><P>		setPath: function ( value ) {
</P><P>			this.path = value;
			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>
	function CubeTextureLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>	}
</P><P>	Object.assign( CubeTextureLoader.prototype, {
</P><P>		crossOrigin: 'anonymous',
</P><P>		load: function ( urls, onLoad, onProgress, onError ) {
</P><P>			var texture = new CubeTexture();
</P><P>			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
</P><P>			var loaded = 0;
</P><P>			function loadTexture( i ) {
</P><P>				loader.load( urls[ i ], function ( image ) {
</P><P>					texture.images[ i ] = image;
</P><P>					loaded ++;
</P><P>					if ( loaded === 6 ) {
</P><P>						texture.needsUpdate = true;
</P><P>						if ( onLoad ) onLoad( texture );
</P><P>					}
</P><P>				}, undefined, onError );
</P><P>			}
</P><P>			for ( var i = 0; i &lt; urls.length; ++ i ) {
</P><P>				loadTexture( i );
</P><P>			}
</P><P>			return texture;
</P><P>		},
</P><P>		setCrossOrigin: function ( value ) {
</P><P>			this.crossOrigin = value;
			return this;
</P><P>		},
</P><P>		setPath: function ( value ) {
</P><P>			this.path = value;
			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>
	function TextureLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>	}
</P><P>	Object.assign( TextureLoader.prototype, {
</P><P>		crossOrigin: 'anonymous',
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			var texture = new Texture();
</P><P>			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
</P><P>			loader.load( url, function ( image ) {
</P><P>				texture.image = image;
</P><P>				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.jpe?g$/i ) &gt; 0 || url.search( /^data\:image\/jpeg/ ) === 0;
</P><P>				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;
</P><P>				if ( onLoad !== undefined ) {
</P><P>					onLoad( texture );
</P><P>				}
</P><P>			}, onProgress, onError );
</P><P>			return texture;
</P><P>		},
</P><P>		setCrossOrigin: function ( value ) {
</P><P>			this.crossOrigin = value;
			return this;
</P><P>		},
</P><P>		setPath: function ( value ) {
</P><P>			this.path = value;
			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/
</P><P>	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/
</P><P>	function Curve() {
</P><P>		this.type = 'Curve';
</P><P>		this.arcLengthDivisions = 200;
</P><P>	}
</P><P>	Object.assign( Curve.prototype, {
</P><P>		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]
</P><P>		getPoint: function ( /* t, optionalTarget */ ) {
</P><P>			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;
</P><P>		},
</P><P>		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]
</P><P>		getPointAt: function ( u, optionalTarget ) {
</P><P>			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );
</P><P>		},
</P><P>		// Get sequence of points using getPoint( t )
</P><P>		getPoints: function ( divisions ) {
</P><P>			if ( divisions === undefined ) divisions = 5;
</P><P>			var points = [];
</P><P>			for ( var d = 0; d &lt;= divisions; d ++ ) {
</P><P>				points.push( this.getPoint( d / divisions ) );
</P><P>			}
</P><P>			return points;
</P><P>		},
</P><P>		// Get sequence of points using getPointAt( u )
</P><P>		getSpacedPoints: function ( divisions ) {
</P><P>			if ( divisions === undefined ) divisions = 5;
</P><P>			var points = [];
</P><P>			for ( var d = 0; d &lt;= divisions; d ++ ) {
</P><P>				points.push( this.getPointAt( d / divisions ) );
</P><P>			}
</P><P>			return points;
</P><P>		},
</P><P>		// Get total curve arc length
</P><P>		getLength: function () {
</P><P>			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];
</P><P>		},
</P><P>		// Get list of cumulative segment lengths
</P><P>		getLengths: function ( divisions ) {
</P><P>			if ( divisions === undefined ) divisions = this.arcLengthDivisions;
</P><P>			if ( this.cacheArcLengths &amp;&amp;
				( this.cacheArcLengths.length === divisions + 1 ) &amp;&amp;
				! this.needsUpdate ) {
</P><P>				return this.cacheArcLengths;
</P><P>			}
</P><P>			this.needsUpdate = false;
</P><P>			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;
</P><P>			cache.push( 0 );
</P><P>			for ( p = 1; p &lt;= divisions; p ++ ) {
</P><P>				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;
</P><P>			}
</P><P>			this.cacheArcLengths = cache;
</P><P>			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
</P><P>		},
</P><P>		updateArcLengths: function () {
</P><P>			this.needsUpdate = true;
			this.getLengths();
</P><P>		},
</P><P>		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
</P><P>		getUtoTmapping: function ( u, distance ) {
</P><P>			var arcLengths = this.getLengths();
</P><P>			var i = 0, il = arcLengths.length;
</P><P>			var targetArcLength; // The targeted u distance value to get
</P><P>			if ( distance ) {
</P><P>				targetArcLength = distance;
</P><P>			} else {
</P><P>				targetArcLength = u * arcLengths[ il - 1 ];
</P><P>			}
</P><P>			// binary search for the index with largest value smaller than target u distance
</P><P>			var low = 0, high = il - 1, comparison;
</P><P>			while ( low &lt;= high ) {
</P><P>				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
</P><P>				comparison = arcLengths[ i ] - targetArcLength;
</P><P>				if ( comparison &lt; 0 ) {
</P><P>					low = i + 1;
</P><P>				} else if ( comparison &gt; 0 ) {
</P><P>					high = i - 1;
</P><P>				} else {
</P><P>					high = i;
					break;
</P><P>					// DONE
</P><P>				}
</P><P>			}
</P><P>			i = high;
</P><P>			if ( arcLengths[ i ] === targetArcLength ) {
</P><P>				return i / ( il - 1 );
</P><P>			}
</P><P>			// we could get finer grain at lengths, or use simple interpolation between two points
</P><P>			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];
</P><P>			var segmentLength = lengthAfter - lengthBefore;
</P><P>			// determine where we are between the 'before' and 'after' points
</P><P>			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
</P><P>			// add that fractional amount to t
</P><P>			var t = ( i + segmentFraction ) / ( il - 1 );
</P><P>			return t;
</P><P>		},
</P><P>		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation
</P><P>		getTangent: function ( t ) {
</P><P>			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;
</P><P>			// Capping in case of danger
</P><P>			if ( t1 &lt; 0 ) t1 = 0;
			if ( t2 &gt; 1 ) t2 = 1;
</P><P>			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );
</P><P>			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();
</P><P>		},
</P><P>		getTangentAt: function ( u ) {
</P><P>			var t = this.getUtoTmapping( u );
			return this.getTangent( t );
</P><P>		},
</P><P>		computeFrenetFrames: function ( segments, closed ) {
</P><P>			// see <A rel="nofollow" class="external free" href="http://www.cs.indiana.edu/pub/techreports/TR425.pdf">http://www.cs.indiana.edu/pub/techreports/TR425.pdf</A></P><P>			var normal = new Vector3();
</P><P>			var tangents = [];
			var normals = [];
			var binormals = [];
</P><P>			var vec = new Vector3();
			var mat = new Matrix4();
</P><P>			var i, u, theta;
</P><P>			// compute the tangent vectors for each segment on the curve
</P><P>			for ( i = 0; i &lt;= segments; i ++ ) {
</P><P>				u = i / segments;
</P><P>				tangents[ i ] = this.getTangentAt( u );
				tangents[ i ].normalize();
</P><P>			}
</P><P>			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component
</P><P>			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );
</P><P>			if ( tx &lt;= min ) {
</P><P>				min = tx;
				normal.set( 1, 0, 0 );
</P><P>			}
</P><P>			if ( ty &lt;= min ) {
</P><P>				min = ty;
				normal.set( 0, 1, 0 );
</P><P>			}
</P><P>			if ( tz &lt;= min ) {
</P><P>				normal.set( 0, 0, 1 );
</P><P>			}
</P><P>			vec.crossVectors( tangents[ 0 ], normal ).normalize();
</P><P>			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
</P><P>
			// compute the slowly-varying normal and binormal vectors for each segment on the curve
</P><P>			for ( i = 1; i &lt;= segments; i ++ ) {
</P><P>				normals[ i ] = normals[ i - 1 ].clone();
</P><P>				binormals[ i ] = binormals[ i - 1 ].clone();
</P><P>				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
</P><P>				if ( vec.length() &gt; Number.EPSILON ) {
</P><P>					vec.normalize();
</P><P>					theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
</P><P>					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
</P><P>				}
</P><P>				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
</P><P>			}
</P><P>			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
</P><P>			if ( closed === true ) {
</P><P>				theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;
</P><P>				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) &gt; 0 ) {
</P><P>					theta = - theta;
</P><P>				}
</P><P>				for ( i = 1; i &lt;= segments; i ++ ) {
</P><P>					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
</P><P>				}
</P><P>			}
</P><P>			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			this.arcLengthDivisions = source.arcLengthDivisions;
</P><P>			return this;
</P><P>		},
</P><P>		toJSON: function () {
</P><P>			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};
</P><P>			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;
</P><P>			return data;
</P><P>		},
</P><P>		fromJSON: function ( json ) {
</P><P>			this.arcLengthDivisions = json.arcLengthDivisions;
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
</P><P>		Curve.call( this );
</P><P>		this.type = 'EllipseCurve';
</P><P>		this.aX = aX || 0;
		this.aY = aY || 0;
</P><P>		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;
</P><P>		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;
</P><P>		this.aClockwise = aClockwise || false;
</P><P>		this.aRotation = aRotation || 0;
</P><P>	}
</P><P>	EllipseCurve.prototype = Object.create( Curve.prototype );
	EllipseCurve.prototype.constructor = EllipseCurve;
</P><P>	EllipseCurve.prototype.isEllipseCurve = true;
</P><P>	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {
</P><P>		var point = optionalTarget || new Vector2();
</P><P>		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) &lt; Number.EPSILON;
</P><P>		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle &lt; 0 ) deltaAngle += twoPi;
		while ( deltaAngle &gt; twoPi ) deltaAngle -= twoPi;
</P><P>		if ( deltaAngle &lt; Number.EPSILON ) {
</P><P>			if ( samePoints ) {
</P><P>				deltaAngle = 0;
</P><P>			} else {
</P><P>				deltaAngle = twoPi;
</P><P>			}
</P><P>		}
</P><P>		if ( this.aClockwise === true &amp;&amp; ! samePoints ) {
</P><P>			if ( deltaAngle === twoPi ) {
</P><P>				deltaAngle = - twoPi;
</P><P>			} else {
</P><P>				deltaAngle = deltaAngle - twoPi;
</P><P>			}
</P><P>		}
</P><P>		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );
</P><P>		if ( this.aRotation !== 0 ) {
</P><P>			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );
</P><P>			var tx = x - this.aX;
			var ty = y - this.aY;
</P><P>			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;
</P><P>		}
</P><P>		return point.set( x, y );
</P><P>	};
</P><P>	EllipseCurve.prototype.copy = function ( source ) {
</P><P>		Curve.prototype.copy.call( this, source );
</P><P>		this.aX = source.aX;
		this.aY = source.aY;
</P><P>		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;
</P><P>		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;
</P><P>		this.aClockwise = source.aClockwise;
</P><P>		this.aRotation = source.aRotation;
</P><P>		return this;
</P><P>	};
</P><P>
	EllipseCurve.prototype.toJSON = function () {
</P><P>		var data = Curve.prototype.toJSON.call( this );
</P><P>		data.aX = this.aX;
		data.aY = this.aY;
</P><P>		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;
</P><P>		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;
</P><P>		data.aClockwise = this.aClockwise;
</P><P>		data.aRotation = this.aRotation;
</P><P>		return data;
</P><P>	};
</P><P>	EllipseCurve.prototype.fromJSON = function ( json ) {
</P><P>		Curve.prototype.fromJSON.call( this, json );
</P><P>		this.aX = json.aX;
		this.aY = json.aY;
</P><P>		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;
</P><P>		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;
</P><P>		this.aClockwise = json.aClockwise;
</P><P>		this.aRotation = json.aRotation;
</P><P>		return this;
</P><P>	};
</P><P>	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
</P><P>		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
</P><P>		this.type = 'ArcCurve';
</P><P>	}
</P><P>	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
	ArcCurve.prototype.constructor = ArcCurve;
</P><P>	ArcCurve.prototype.isArcCurve = true;
</P><P>	/**
	 * @author zz85 <A rel="nofollow" class="external free" href="https://github.com/zz85">https://github.com/zz85</A>
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * <A rel="nofollow" class="external free" href="http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf">http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf</A>
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */
</P><P>
	/*
	Based on an optimized c++ solution in
	 - <A rel="nofollow" class="external free" href="http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/">http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/</A>
	 - <A rel="nofollow" class="external free" href="http://ideone.com/NoEbVM">http://ideone.com/NoEbVM</A></P><P>	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/
</P><P>	function CubicPoly() {
</P><P>		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
</P><P>		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {
</P><P>			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
</P><P>		}
</P><P>		return {
</P><P>			initCatmullRom: function ( x0, x1, x2, x3, tension ) {
</P><P>				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
</P><P>			},
</P><P>			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {
</P><P>				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
</P><P>				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;
</P><P>				init( x1, x2, t1, t2 );
</P><P>			},
</P><P>			calc: function ( t ) {
</P><P>				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
</P><P>			}
</P><P>		};
</P><P>	}
</P><P>	//
</P><P>	var tmp = new Vector3();
	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
</P><P>	function CatmullRomCurve3( points, closed, curveType, tension ) {
</P><P>		Curve.call( this );
</P><P>		this.type = 'CatmullRomCurve3';
</P><P>		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;
</P><P>	}
</P><P>	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
</P><P>	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
</P><P>	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {
</P><P>		var point = optionalTarget || new Vector3();
</P><P>		var points = this.points;
		var l = points.length;
</P><P>		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		var intPoint = Math.floor( p );
		var weight = p - intPoint;
</P><P>		if ( this.closed ) {
</P><P>			intPoint += intPoint &gt; 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;
</P><P>		} else if ( weight === 0 &amp;&amp; intPoint === l - 1 ) {
</P><P>			intPoint = l - 2;
			weight = 1;
</P><P>		}
</P><P>		var p0, p1, p2, p3; // 4 points
</P><P>		if ( this.closed || intPoint &gt; 0 ) {
</P><P>			p0 = points[ ( intPoint - 1 ) % l ];
</P><P>		} else {
</P><P>			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;
</P><P>		}
</P><P>		p1 = points[ intPoint % l ];
		p2 = points[ ( intPoint + 1 ) % l ];
</P><P>		if ( this.closed || intPoint + 2 &lt; l ) {
</P><P>			p3 = points[ ( intPoint + 2 ) % l ];
</P><P>		} else {
</P><P>			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;
</P><P>		}
</P><P>		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {
</P><P>			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
</P><P>			// safety check for repeated points
			if ( dt1 &lt; 1e-4 ) dt1 = 1.0;
			if ( dt0 &lt; 1e-4 ) dt0 = dt1;
			if ( dt2 &lt; 1e-4 ) dt2 = dt1;
</P><P>			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
</P><P>		} else if ( this.curveType === 'catmullrom' ) {
</P><P>			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );
</P><P>		}
</P><P>		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);
</P><P>		return point;
</P><P>	};
</P><P>	CatmullRomCurve3.prototype.copy = function ( source ) {
</P><P>		Curve.prototype.copy.call( this, source );
</P><P>		this.points = [];
</P><P>for ( var i = 0, l = source.points.length; i &lt; l; i ++ ) {
</P><P>			var point = source.points[ i ];
</P><P>			this.points.push( point.clone() );
</P><P>		}
</P><P>		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;
</P><P>		return this;
</P><P>	};
</P><P>	CatmullRomCurve3.prototype.toJSON = function () {
</P><P>		var data = Curve.prototype.toJSON.call( this );
</P><P>		data.points = [];
</P><P>		for ( var i = 0, l = this.points.length; i &lt; l; i ++ ) {
</P><P>			var point = this.points[ i ];
			data.points.push( point.toArray() );
</P><P>		}
</P><P>		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;
</P><P>		return data;
</P><P>	};
</P><P>	CatmullRomCurve3.prototype.fromJSON = function ( json ) {
</P><P>		Curve.prototype.fromJSON.call( this, json );
</P><P>		this.points = [];
</P><P>		for ( var i = 0, l = json.points.length; i &lt; l; i ++ ) {
</P><P>			var point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );
</P><P>		}
</P><P>		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 *
	 * Bezier Curves formulas obtained from
	 * <A rel="nofollow" class="external free" href="http://en.wikipedia.org/wiki/Bézier_curve">http://en.wikipedia.org/wiki/Bézier_curve</A>
	 */
</P><P>	function CatmullRom( t, p0, p1, p2, p3 ) {
</P><P>		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
</P><P>	}
</P><P>	//
</P><P>	function QuadraticBezierP0( t, p ) {
</P><P>		var k = 1 - t;
		return k * k * p;
</P><P>	}
</P><P>	function QuadraticBezierP1( t, p ) {
</P><P>		return 2 * ( 1 - t ) * t * p;
</P><P>	}
</P><P>	function QuadraticBezierP2( t, p ) {
</P><P>		return t * t * p;
</P><P>	}
</P><P>	function QuadraticBezier( t, p0, p1, p2 ) {
</P><P>		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );
</P><P>	}
</P><P>	//
</P><P>	function CubicBezierP0( t, p ) {
</P><P>		var k = 1 - t;
		return k * k * k * p;
</P><P>	}
</P><P>	function CubicBezierP1( t, p ) {
</P><P>		var k = 1 - t;
		return 3 * k * k * t * p;
</P><P>	}
</P><P>	function CubicBezierP2( t, p ) {
</P><P>		return 3 * ( 1 - t ) * t * t * p;
</P><P>	}
</P><P>	function CubicBezierP3( t, p ) {
</P><P>		return t * t * t * p;
</P><P>	}
</P><P>	function CubicBezier( t, p0, p1, p2, p3 ) {
</P><P>		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );
</P><P>	}
</P><P>	function CubicBezierCurve( v0, v1, v2, v3 ) {
</P><P>		Curve.call( this );
</P><P>		this.type = 'CubicBezierCurve';
</P><P>		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();
</P><P>	}
</P><P>	CubicBezierCurve.prototype = Object.create( Curve.prototype );
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;
</P><P>	CubicBezierCurve.prototype.isCubicBezierCurve = true;
</P><P>	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {
</P><P>		var point = optionalTarget || new Vector2();
</P><P>		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
</P><P>		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);
</P><P>		return point;
</P><P>	};
</P><P>	CubicBezierCurve.prototype.copy = function ( source ) {
</P><P>		Curve.prototype.copy.call( this, source );
</P><P>		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );
</P><P>		return this;
</P><P>	};
</P><P>	CubicBezierCurve.prototype.toJSON = function () {
</P><P>		var data = Curve.prototype.toJSON.call( this );
</P><P>		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
</P><P>		return data;
</P><P>	};
</P><P>	CubicBezierCurve.prototype.fromJSON = function ( json ) {
</P><P>		Curve.prototype.fromJSON.call( this, json );
</P><P>		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );
</P><P>		return this;
</P><P>	};
</P><P>	function CubicBezierCurve3( v0, v1, v2, v3 ) {
</P><P>		Curve.call( this );
</P><P>		this.type = 'CubicBezierCurve3';
</P><P>		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();
</P><P>	}
</P><P>	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
</P><P>	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
</P><P>	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {
</P><P>		var point = optionalTarget || new Vector3();
</P><P>		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
</P><P>		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);
</P><P>		return point;
</P><P>	};
</P><P>	CubicBezierCurve3.prototype.copy = function ( source ) {
</P><P>		Curve.prototype.copy.call( this, source );
</P><P>		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );
</P><P>		return this;
</P><P>	};
</P><P>	CubicBezierCurve3.prototype.toJSON = function () {
</P><P>		var data = Curve.prototype.toJSON.call( this );
</P><P>		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
</P><P>		return data;
</P><P>	};
</P><P>	CubicBezierCurve3.prototype.fromJSON = function ( json ) {
</P><P>		Curve.prototype.fromJSON.call( this, json );
</P><P>		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );
</P><P>		return this;
</P><P>	};
</P><P>	function LineCurve( v1, v2 ) {
</P><P>		Curve.call( this );
</P><P>		this.type = 'LineCurve';
</P><P>		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
</P><P>	}
</P><P>	LineCurve.prototype = Object.create( Curve.prototype );
	LineCurve.prototype.constructor = LineCurve;
</P><P>	LineCurve.prototype.isLineCurve = true;
</P><P>	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {
</P><P>		var point = optionalTarget || new Vector2();
</P><P>		if ( t === 1 ) {
</P><P>			point.copy( this.v2 );
</P><P>		} else {
</P><P>			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );
</P><P>		}
</P><P>		return point;
</P><P>	};
</P><P>	// Line curve is linear, so we can overwrite default getPointAt
</P><P>	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {
</P><P>		return this.getPoint( u, optionalTarget );
</P><P>	};
</P><P>	LineCurve.prototype.getTangent = function ( /* t */ ) {
</P><P>		var tangent = this.v2.clone().sub( this.v1 );
</P><P>		return tangent.normalize();
</P><P>	};
</P><P>	LineCurve.prototype.copy = function ( source ) {
</P><P>		Curve.prototype.copy.call( this, source );
</P><P>		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
</P><P>		return this;
</P><P>	};
</P><P>	LineCurve.prototype.toJSON = function () {
</P><P>		var data = Curve.prototype.toJSON.call( this );
</P><P>		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
</P><P>		return data;
</P><P>	};
</P><P>	LineCurve.prototype.fromJSON = function ( json ) {
</P><P>		Curve.prototype.fromJSON.call( this, json );
</P><P>		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
</P><P>		return this;
</P><P>	};
</P><P>	function LineCurve3( v1, v2 ) {
</P><P>		Curve.call( this );
</P><P>		this.type = 'LineCurve3';
</P><P>		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
</P><P>	}
</P><P>	LineCurve3.prototype = Object.create( Curve.prototype );
	LineCurve3.prototype.constructor = LineCurve3;
</P><P>	LineCurve3.prototype.isLineCurve3 = true;
</P><P>	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {
</P><P>		var point = optionalTarget || new Vector3();
</P><P>		if ( t === 1 ) {
</P><P>			point.copy( this.v2 );
</P><P>		} else {
</P><P>			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );
</P><P>		}
</P><P>		return point;
</P><P>	};
</P><P>	// Line curve is linear, so we can overwrite default getPointAt
</P><P>	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {
</P><P>		return this.getPoint( u, optionalTarget );
</P><P>	};
</P><P>	LineCurve3.prototype.copy = function ( source ) {
</P><P>		Curve.prototype.copy.call( this, source );
</P><P>		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
</P><P>		return this;
</P><P>	};
</P><P>	LineCurve3.prototype.toJSON = function () {
</P><P>		var data = Curve.prototype.toJSON.call( this );
</P><P>		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
</P><P>		return data;
</P><P>	};
</P><P>	LineCurve3.prototype.fromJSON = function ( json ) {
</P><P>		Curve.prototype.fromJSON.call( this, json );
</P><P>		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
</P><P>		return this;
</P><P>	};
</P><P>	function QuadraticBezierCurve( v0, v1, v2 ) {
</P><P>		Curve.call( this );
</P><P>		this.type = 'QuadraticBezierCurve';
</P><P>		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
</P><P>	}
</P><P>	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
</P><P>	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
</P><P>	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {
</P><P>		var point = optionalTarget || new Vector2();
</P><P>		var v0 = this.v0, v1 = this.v1, v2 = this.v2;
</P><P>		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);
</P><P>		return point;
</P><P>	};
</P><P>	QuadraticBezierCurve.prototype.copy = function ( source ) {
</P><P>		Curve.prototype.copy.call( this, source );
</P><P>		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
</P><P>		return this;
</P><P>	};
</P><P>	QuadraticBezierCurve.prototype.toJSON = function () {
</P><P>		var data = Curve.prototype.toJSON.call( this );
</P><P>		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
</P><P>		return data;
</P><P>	};
</P><P>	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {
</P><P>		Curve.prototype.fromJSON.call( this, json );
</P><P>		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
</P><P>		return this;
</P><P>	};
</P><P>	function QuadraticBezierCurve3( v0, v1, v2 ) {
</P><P>		Curve.call( this );
</P><P>		this.type = 'QuadraticBezierCurve3';
</P><P>		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
</P><P>	}
</P><P>	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
</P><P>	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
</P><P>	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {
</P><P>		var point = optionalTarget || new Vector3();
</P><P>		var v0 = this.v0, v1 = this.v1, v2 = this.v2;
</P><P>		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);
</P><P>		return point;
</P><P>	};
</P><P>	QuadraticBezierCurve3.prototype.copy = function ( source ) {
</P><P>		Curve.prototype.copy.call( this, source );
</P><P>		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
</P><P>		return this;
</P><P>	};
</P><P>	QuadraticBezierCurve3.prototype.toJSON = function () {
</P><P>		var data = Curve.prototype.toJSON.call( this );
</P><P>		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
</P><P>		return data;
</P><P>	};
</P><P>	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {
</P><P>		Curve.prototype.fromJSON.call( this, json );
</P><P>		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
</P><P>		return this;
</P><P>	};
</P><P>	function SplineCurve( points /* array of Vector2 */ ) {
</P><P>		Curve.call( this );
</P><P>		this.type = 'SplineCurve';
</P><P>		this.points = points || [];
</P><P>	}
</P><P>	SplineCurve.prototype = Object.create( Curve.prototype );
	SplineCurve.prototype.constructor = SplineCurve;
</P><P>	SplineCurve.prototype.isSplineCurve = true;
</P><P>	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {
</P><P>		var point = optionalTarget || new Vector2();
</P><P>		var points = this.points;
		var p = ( points.length - 1 ) * t;
</P><P>		var intPoint = Math.floor( p );
		var weight = p - intPoint;
</P><P>		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint &gt; points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint &gt; points.length - 3 ? points.length - 1 : intPoint + 2 ];
</P><P>		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);
</P><P>		return point;
</P><P>	};
</P><P>	SplineCurve.prototype.copy = function ( source ) {
</P><P>		Curve.prototype.copy.call( this, source );
</P><P>		this.points = [];
</P><P>		for ( var i = 0, l = source.points.length; i &lt; l; i ++ ) {
</P><P>			var point = source.points[ i ];
</P><P>			this.points.push( point.clone() );
</P><P>		}
</P><P>		return this;
</P><P>	};
</P><P>	SplineCurve.prototype.toJSON = function () {
</P><P>		var data = Curve.prototype.toJSON.call( this );
</P><P>		data.points = [];
</P><P>		for ( var i = 0, l = this.points.length; i &lt; l; i ++ ) {
</P><P>			var point = this.points[ i ];
			data.points.push( point.toArray() );
</P><P>		}
</P><P>		return data;
</P><P>	};
</P><P>	SplineCurve.prototype.fromJSON = function ( json ) {
</P><P>		Curve.prototype.fromJSON.call( this, json );
</P><P>		this.points = [];
</P><P>		for ( var i = 0, l = json.points.length; i &lt; l; i ++ ) {
</P><P>			var point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );
</P><P>		}
</P><P>		return this;
</P><P>	};
</P><P>	var Curves = /*#__PURE__*/Object.freeze({
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 *
	 **/
</P><P>	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
</P><P>	function CurvePath() {
</P><P>		Curve.call( this );
</P><P>		this.type = 'CurvePath';
</P><P>		this.curves = [];
		this.autoClose = false; // Automatically closes the path
</P><P>	}
</P><P>	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {
</P><P>		constructor: CurvePath,
</P><P>		add: function ( curve ) {
</P><P>			this.curves.push( curve );
</P><P>		},
</P><P>		closePath: function () {
</P><P>			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
</P><P>			if ( ! startPoint.equals( endPoint ) ) {
</P><P>				this.curves.push( new LineCurve( endPoint, startPoint ) );
</P><P>			}
</P><P>		},
</P><P>		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
</P><P>		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')
</P><P>		getPoint: function ( t ) {
</P><P>			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;
</P><P>			// To think about boundaries points.
</P><P>			while ( i &lt; curveLengths.length ) {
</P><P>				if ( curveLengths[ i ] &gt;= d ) {
</P><P>					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];
</P><P>					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
</P><P>					return curve.getPointAt( u );
</P><P>				}
</P><P>				i ++;
</P><P>			}
</P><P>			return null;
</P><P>			// loop where sum != 0, sum &gt; d , sum+1 &lt;d
</P><P>		},
</P><P>		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength
</P><P>		getLength: function () {
</P><P>			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];
</P><P>		},
</P><P>		// cacheLengths must be recalculated.
		updateArcLengths: function () {
</P><P>			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
</P><P>		},
</P><P>		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.
</P><P>		getCurveLengths: function () {
</P><P>			// We use cache values if curves and cache array are same length
</P><P>			if ( this.cacheLengths &amp;&amp; this.cacheLengths.length === this.curves.length ) {
</P><P>				return this.cacheLengths;
</P><P>			}
</P><P>			// Get length of sub-curve
			// Push sums into cached array
</P><P>			var lengths = [], sums = 0;
</P><P>			for ( var i = 0, l = this.curves.length; i &lt; l; i ++ ) {
</P><P>				sums += this.curves[ i ].getLength();
				lengths.push( sums );
</P><P>			}
</P><P>			this.cacheLengths = lengths;
</P><P>			return lengths;
</P><P>		},
</P><P>		getSpacedPoints: function ( divisions ) {
</P><P>			if ( divisions === undefined ) divisions = 40;
</P><P>			var points = [];
</P><P>			for ( var i = 0; i &lt;= divisions; i ++ ) {
</P><P>				points.push( this.getPoint( i / divisions ) );
</P><P>			}
</P><P>			if ( this.autoClose ) {
</P><P>				points.push( points[ 0 ] );
</P><P>			}
</P><P>			return points;
</P><P>		},
</P><P>		getPoints: function ( divisions ) {
</P><P>			divisions = divisions || 12;
</P><P>			var points = [], last;
</P><P>			for ( var i = 0, curves = this.curves; i &lt; curves.length; i ++ ) {
</P><P>				var curve = curves[ i ];
				var resolution = ( curve &amp;&amp; curve.isEllipseCurve ) ? divisions * 2
					: ( curve &amp;&amp; ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
						: ( curve &amp;&amp; curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;
</P><P>				var pts = curve.getPoints( resolution );
</P><P>				for ( var j = 0; j &lt; pts.length; j ++ ) {
</P><P>					var point = pts[ j ];
</P><P>					if ( last &amp;&amp; last.equals( point ) ) continue; // ensures no consecutive points are duplicates
</P><P>					points.push( point );
					last = point;
</P><P>				}
</P><P>			}
</P><P>			if ( this.autoClose &amp;&amp; points.length &gt; 1 &amp;&amp; ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {
</P><P>				points.push( points[ 0 ] );
</P><P>			}
</P><P>			return points;
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			Curve.prototype.copy.call( this, source );
</P><P>			this.curves = [];
</P><P>			for ( var i = 0, l = source.curves.length; i &lt; l; i ++ ) {
</P><P>				var curve = source.curves[ i ];
</P><P>				this.curves.push( curve.clone() );
</P><P>			}
</P><P>			this.autoClose = source.autoClose;
</P><P>			return this;
</P><P>		},
</P><P>		toJSON: function () {
</P><P>			var data = Curve.prototype.toJSON.call( this );
</P><P>			data.autoClose = this.autoClose;
			data.curves = [];
</P><P>			for ( var i = 0, l = this.curves.length; i &lt; l; i ++ ) {
</P><P>				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );
</P><P>			}
</P><P>			return data;
</P><P>		},
</P><P>		fromJSON: function ( json ) {
</P><P>			Curve.prototype.fromJSON.call( this, json );
</P><P>			this.autoClose = json.autoClose;
			this.curves = [];
</P><P>			for ( var i = 0, l = json.curves.length; i &lt; l; i ++ ) {
</P><P>				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );
</P><P>			}
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 * Creates free form 2d path using series of points, lines or curves.
	 **/
</P><P>	function Path( points ) {
</P><P>		CurvePath.call( this );
</P><P>		this.type = 'Path';
</P><P>		this.currentPoint = new Vector2();
</P><P>		if ( points ) {
</P><P>			this.setFromPoints( points );
</P><P>		}
</P><P>	}
</P><P>	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {
</P><P>		constructor: Path,
</P><P>		setFromPoints: function ( points ) {
</P><P>			this.moveTo( points[ 0 ].x, points[ 0 ].y );
</P><P>			for ( var i = 1, l = points.length; i &lt; l; i ++ ) {
</P><P>				this.lineTo( points[ i ].x, points[ i ].y );
</P><P>			}
</P><P>		},
</P><P>		moveTo: function ( x, y ) {
</P><P>			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?
</P><P>		},
</P><P>		lineTo: function ( x, y ) {
</P><P>			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );
</P><P>			this.currentPoint.set( x, y );
</P><P>		},
</P><P>		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
</P><P>			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);
</P><P>			this.curves.push( curve );
</P><P>			this.currentPoint.set( aX, aY );
</P><P>		},
</P><P>		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
</P><P>			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);
</P><P>			this.curves.push( curve );
</P><P>			this.currentPoint.set( aX, aY );
</P><P>		},
</P><P>		splineThru: function ( pts /*Array of Vector*/ ) {
</P><P>			var npts = [ this.currentPoint.clone() ].concat( pts );
</P><P>			var curve = new SplineCurve( npts );
			this.curves.push( curve );
</P><P>			this.currentPoint.copy( pts[ pts.length - 1 ] );
</P><P>		},
</P><P>		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
</P><P>			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
</P><P>			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );
</P><P>		},
</P><P>		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
</P><P>			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
</P><P>		},
</P><P>		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
</P><P>			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
</P><P>			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
</P><P>		},
</P><P>		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
</P><P>			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
</P><P>			if ( this.curves.length &gt; 0 ) {
</P><P>				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );
</P><P>				if ( ! firstPoint.equals( this.currentPoint ) ) {
</P><P>					this.lineTo( firstPoint.x, firstPoint.y );
</P><P>				}
</P><P>			}
</P><P>			this.curves.push( curve );
</P><P>			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			CurvePath.prototype.copy.call( this, source );
</P><P>			this.currentPoint.copy( source.currentPoint );
</P><P>			return this;
</P><P>		},
</P><P>		toJSON: function () {
</P><P>			var data = CurvePath.prototype.toJSON.call( this );
</P><P>			data.currentPoint = this.currentPoint.toArray();
</P><P>			return data;
</P><P>		},
</P><P>		fromJSON: function ( json ) {
</P><P>			CurvePath.prototype.fromJSON.call( this, json );
</P><P>			this.currentPoint.fromArray( json.currentPoint );
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 * Defines a 2d shape plane using paths.
	 **/
</P><P>	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
</P><P>	function Shape( points ) {
</P><P>		Path.call( this, points );
</P><P>		this.uuid = _Math.generateUUID();
</P><P>		this.type = 'Shape';
</P><P>		this.holes = [];
</P><P>	}
</P><P>	Shape.prototype = Object.assign( Object.create( Path.prototype ), {
</P><P>		constructor: Shape,
</P><P>		getPointsHoles: function ( divisions ) {
</P><P>			var holesPts = [];
</P><P>			for ( var i = 0, l = this.holes.length; i &lt; l; i ++ ) {
</P><P>				holesPts[ i ] = this.holes[ i ].getPoints( divisions );
</P><P>			}
</P><P>			return holesPts;
</P><P>		},
</P><P>		// get points of shape and holes (keypoints based on segments parameter)
</P><P>		extractPoints: function ( divisions ) {
</P><P>			return {
</P><P>				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )
</P><P>			};
</P><P>		},
</P><P>		copy: function ( source ) {
</P><P>			Path.prototype.copy.call( this, source );
</P><P>			this.holes = [];
</P><P>			for ( var i = 0, l = source.holes.length; i &lt; l; i ++ ) {
</P><P>				var hole = source.holes[ i ];
</P><P>				this.holes.push( hole.clone() );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		toJSON: function () {
</P><P>			var data = Path.prototype.toJSON.call( this );
</P><P>			data.uuid = this.uuid;
			data.holes = [];
</P><P>			for ( var i = 0, l = this.holes.length; i &lt; l; i ++ ) {
</P><P>				var hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );
</P><P>			}
</P><P>			return data;
</P><P>		},
</P><P>		fromJSON: function ( json ) {
</P><P>			Path.prototype.fromJSON.call( this, json );
</P><P>			this.uuid = json.uuid;
			this.holes = [];
</P><P>			for ( var i = 0, l = json.holes.length; i &lt; l; i ++ ) {
</P><P>				var hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );
</P><P>			}
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function Light( color, intensity ) {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Light';
</P><P>		this.color = new Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;
</P><P>		this.receiveShadow = undefined;
</P><P>	}
</P><P>	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Light,
</P><P>		isLight: true,
</P><P>		copy: function ( source ) {
</P><P>			Object3D.prototype.copy.call( this, source );
</P><P>			this.color.copy( source.color );
			this.intensity = source.intensity;
</P><P>			return this;
</P><P>		},
</P><P>		toJSON: function ( meta ) {
</P><P>			var data = Object3D.prototype.toJSON.call( this, meta );
</P><P>			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
</P><P>			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
</P><P>			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
</P><P>			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
</P><P>			return data;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function HemisphereLight( skyColor, groundColor, intensity ) {
</P><P>		Light.call( this, skyColor, intensity );
</P><P>		this.type = 'HemisphereLight';
</P><P>		this.castShadow = undefined;
</P><P>		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();
</P><P>		this.groundColor = new Color( groundColor );
</P><P>	}
</P><P>	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {
</P><P>		constructor: HemisphereLight,
</P><P>		isHemisphereLight: true,
</P><P>		copy: function ( source ) {
</P><P>			Light.prototype.copy.call( this, source );
</P><P>			this.groundColor.copy( source.groundColor );
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function LightShadow( camera ) {
</P><P>		this.camera = camera;
</P><P>		this.bias = 0;
		this.radius = 1;
</P><P>		this.mapSize = new Vector2( 512, 512 );
</P><P>		this.map = null;
		this.matrix = new Matrix4();
</P><P>	}
</P><P>	Object.assign( LightShadow.prototype, {
</P><P>		copy: function ( source ) {
</P><P>			this.camera = source.camera.clone();
</P><P>			this.bias = source.bias;
			this.radius = source.radius;
</P><P>			this.mapSize.copy( source.mapSize );
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		toJSON: function () {
</P><P>			var object = {};
</P><P>			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();
</P><P>			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;
</P><P>			return object;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function SpotLightShadow() {
</P><P>		LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );
</P><P>	}
</P><P>	SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
</P><P>		constructor: SpotLightShadow,
</P><P>		isSpotLightShadow: true,
</P><P>		update: function ( light ) {
</P><P>			var camera = this.camera;
</P><P>			var fov = _Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;
</P><P>			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {
</P><P>				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function SpotLight( color, intensity, distance, angle, penumbra, decay ) {
</P><P>		Light.call( this, color, intensity );
</P><P>		this.type = 'SpotLight';
</P><P>		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();
</P><P>		this.target = new Object3D();
</P><P>		Object.defineProperty( this, 'power', {
			get: function () {
</P><P>				// intensity = power per solid angle.
				// ref: equation (17) from <A rel="nofollow" class="external free" href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf</A>
				return this.intensity * Math.PI;
</P><P>			},
			set: function ( power ) {
</P><P>				// intensity = power per solid angle.
				// ref: equation (17) from <A rel="nofollow" class="external free" href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf</A>
				this.intensity = power / Math.PI;
</P><P>			}
		} );
</P><P>		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
</P><P>		this.shadow = new SpotLightShadow();
</P><P>	}
</P><P>	SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {
</P><P>		constructor: SpotLight,
</P><P>		isSpotLight: true,
</P><P>		copy: function ( source ) {
</P><P>			Light.prototype.copy.call( this, source );
</P><P>			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
</P><P>			this.target = source.target.clone();
</P><P>			this.shadow = source.shadow.clone();
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>
	function PointLight( color, intensity, distance, decay ) {
</P><P>		Light.call( this, color, intensity );
</P><P>		this.type = 'PointLight';
</P><P>		Object.defineProperty( this, 'power', {
			get: function () {
</P><P>				// intensity = power per solid angle.
				// ref: equation (15) from <A rel="nofollow" class="external free" href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf</A>
				return this.intensity * 4 * Math.PI;
</P><P>			},
			set: function ( power ) {
</P><P>				// intensity = power per solid angle.
				// ref: equation (15) from <A rel="nofollow" class="external free" href="https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf">https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf</A>
				this.intensity = power / ( 4 * Math.PI );
</P><P>			}
		} );
</P><P>		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
</P><P>		this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );
</P><P>	}
</P><P>	PointLight.prototype = Object.assign( Object.create( Light.prototype ), {
</P><P>		constructor: PointLight,
</P><P>		isPointLight: true,
</P><P>		copy: function ( source ) {
</P><P>			Light.prototype.copy.call( this, source );
</P><P>			this.distance = source.distance;
			this.decay = source.decay;
</P><P>			this.shadow = source.shadow.clone();
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author arose / <A rel="nofollow" class="external free" href="http://github.com/arose">http://github.com/arose</A>
	 */
</P><P>	function OrthographicCamera( left, right, top, bottom, near, far ) {
</P><P>		Camera.call( this );
</P><P>		this.type = 'OrthographicCamera';
</P><P>		this.zoom = 1;
		this.view = null;
</P><P>		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
</P><P>		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;
</P><P>		this.updateProjectionMatrix();
</P><P>	}
</P><P>	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
</P><P>		constructor: OrthographicCamera,
</P><P>		isOrthographicCamera: true,
</P><P>		copy: function ( source, recursive ) {
</P><P>			Camera.prototype.copy.call( this, source, recursive );
</P><P>			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
</P><P>			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );
</P><P>			return this;
</P><P>		},
</P><P>		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
</P><P>			if ( this.view === null ) {
</P><P>				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
</P><P>			}
</P><P>			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
</P><P>			this.updateProjectionMatrix();
</P><P>		},
</P><P>		clearViewOffset: function () {
</P><P>			if ( this.view !== null ) {
</P><P>				this.view.enabled = false;
</P><P>			}
</P><P>			this.updateProjectionMatrix();
</P><P>		},
</P><P>		updateProjectionMatrix: function () {
</P><P>			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;
</P><P>			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;
</P><P>			if ( this.view !== null &amp;&amp; this.view.enabled ) {
</P><P>				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
				var scaleW = ( this.right - this.left ) / this.view.width;
				var scaleH = ( this.top - this.bottom ) / this.view.height;
</P><P>				left += scaleW * ( this.view.offsetX / zoomW );
				right = left + scaleW * ( this.view.width / zoomW );
				top -= scaleH * ( this.view.offsetY / zoomH );
				bottom = top - scaleH * ( this.view.height / zoomH );
</P><P>			}
</P><P>			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
</P><P>			this.projectionMatrixInverse.getInverse( this.projectionMatrix );
</P><P>		},
</P><P>		toJSON: function ( meta ) {
</P><P>			var data = Object3D.prototype.toJSON.call( this, meta );
</P><P>			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
</P><P>			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
</P><P>			return data;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function DirectionalLightShadow( ) {
</P><P>		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
</P><P>	}
</P><P>	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
</P><P>		constructor: DirectionalLightShadow
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function DirectionalLight( color, intensity ) {
</P><P>		Light.call( this, color, intensity );
</P><P>		this.type = 'DirectionalLight';
</P><P>		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();
</P><P>		this.target = new Object3D();
</P><P>		this.shadow = new DirectionalLightShadow();
</P><P>	}
</P><P>	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {
</P><P>		constructor: DirectionalLight,
</P><P>		isDirectionalLight: true,
</P><P>		copy: function ( source ) {
</P><P>			Light.prototype.copy.call( this, source );
</P><P>			this.target = source.target.clone();
</P><P>			this.shadow = source.shadow.clone();
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function AmbientLight( color, intensity ) {
</P><P>		Light.call( this, color, intensity );
</P><P>		this.type = 'AmbientLight';
</P><P>		this.castShadow = undefined;
</P><P>	}
</P><P>	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {
</P><P>		constructor: AmbientLight,
</P><P>		isAmbientLight: true
</P><P>	} );
</P><P>	/**
	 * @author abelnation / <A rel="nofollow" class="external free" href="http://github.com/abelnation">http://github.com/abelnation</A>
	 */
</P><P>	function RectAreaLight( color, intensity, width, height ) {
</P><P>		Light.call( this, color, intensity );
</P><P>		this.type = 'RectAreaLight';
</P><P>		this.width = ( width !== undefined ) ? width : 10;
		this.height = ( height !== undefined ) ? height : 10;
</P><P>	}
</P><P>	RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {
</P><P>		constructor: RectAreaLight,
</P><P>		isRectAreaLight: true,
</P><P>		copy: function ( source ) {
</P><P>			Light.prototype.copy.call( this, source );
</P><P>			this.width = source.width;
			this.height = source.height;
</P><P>			return this;
</P><P>		},
</P><P>		toJSON: function ( meta ) {
</P><P>			var data = Light.prototype.toJSON.call( this, meta );
</P><P>			data.object.width = this.width;
			data.object.height = this.height;
</P><P>			return data;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author tschw
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 */
</P><P>	var AnimationUtils = {
</P><P>		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {
</P><P>			if ( AnimationUtils.isTypedArray( array ) ) {
</P><P>				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );
</P><P>			}
</P><P>			return array.slice( from, to );
</P><P>		},
</P><P>		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {
</P><P>			if ( ! array || // let 'undefined' and 'null' pass
					! forceClone &amp;&amp; array.constructor === type ) return array;
</P><P>			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
</P><P>				return new type( array ); // create typed array
</P><P>			}
</P><P>			return Array.prototype.slice.call( array ); // create Array
</P><P>		},
</P><P>		isTypedArray: function ( object ) {
</P><P>			return ArrayBuffer.isView( object ) &amp;&amp;
					! ( object instanceof DataView );
</P><P>		},
</P><P>		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {
</P><P>			function compareTime( i, j ) {
</P><P>				return times[ i ] - times[ j ];
</P><P>			}
</P><P>			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
</P><P>			result.sort( compareTime );
</P><P>			return result;
</P><P>		},
</P><P>		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {
</P><P>			var nValues = values.length;
			var result = new values.constructor( nValues );
</P><P>			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
</P><P>				var srcOffset = order[ i ] * stride;
</P><P>				for ( var j = 0; j !== stride; ++ j ) {
</P><P>					result[ dstOffset ++ ] = values[ srcOffset + j ];
</P><P>				}
</P><P>			}
</P><P>			return result;
</P><P>		},
</P><P>		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {
</P><P>			var i = 1, key = jsonKeys[ 0 ];
</P><P>			while ( key !== undefined &amp;&amp; key[ valuePropertyName ] === undefined ) {
</P><P>				key = jsonKeys[ i ++ ];
</P><P>			}
</P><P>			if ( key === undefined ) return; // no data
</P><P>			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data
</P><P>			if ( Array.isArray( value ) ) {
</P><P>				do {
</P><P>					value = key[ valuePropertyName ];
</P><P>					if ( value !== undefined ) {
</P><P>						times.push( key.time );
						values.push.apply( values, value ); // push all elements
</P><P>					}
</P><P>					key = jsonKeys[ i ++ ];
</P><P>				} while ( key !== undefined );
</P><P>			} else if ( value.toArray !== undefined ) {
</P><P>				// ...assume THREE.Math-ish
</P><P>				do {
</P><P>					value = key[ valuePropertyName ];
</P><P>					if ( value !== undefined ) {
</P><P>						times.push( key.time );
						value.toArray( values, values.length );
</P><P>					}
</P><P>					key = jsonKeys[ i ++ ];
</P><P>				} while ( key !== undefined );
</P><P>			} else {
</P><P>				// otherwise push as-is
</P><P>				do {
</P><P>					value = key[ valuePropertyName ];
</P><P>					if ( value !== undefined ) {
</P><P>						times.push( key.time );
						values.push( value );
</P><P>					}
</P><P>					key = jsonKeys[ i ++ ];
</P><P>				} while ( key !== undefined );
</P><P>			}
</P><P>		}
</P><P>	};
</P><P>	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		<A rel="nofollow" class="external free" href="http://www.oodesign.com/template-method-pattern.html">http://www.oodesign.com/template-method-pattern.html</A>
	 *
	 * @author tschw
	 */
</P><P>	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
</P><P>		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;
</P><P>		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;
</P><P>	}
</P><P>	Object.assign( Interpolant.prototype, {
</P><P>		evaluate: function ( t ) {
</P><P>			var pp = this.parameterPositions,
				i1 = this._cachedIndex,
</P><P>				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];
</P><P>			validate_interval: {
</P><P>				seek: {
</P><P>					var right;
</P><P>					linear_scan: {
</P><P>						//- See <A rel="nofollow" class="external free" href="http://jsperf.com/comparison-to-undefined/3">http://jsperf.com/comparison-to-undefined/3</A>
						//- slower code:
						//-
						//- 				if ( t &gt;= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t &lt; t1 ) ) {
</P><P>							for ( var giveUpAt = i1 + 2; ; ) {
</P><P>								if ( t1 === undefined ) {
</P><P>									if ( t &lt; t0 ) break forward_scan;
</P><P>									// after end
</P><P>									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );
</P><P>								}
</P><P>								if ( i1 === giveUpAt ) break; // this loop
</P><P>								t0 = t1;
								t1 = pp[ ++ i1 ];
</P><P>								if ( t &lt; t1 ) {
</P><P>									// we have arrived at the sought interval
									break seek;
</P><P>								}
</P><P>							}
</P><P>							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;
</P><P>						}
</P><P>						//- slower code:
						//-					if ( t &lt; t0 || t0 === undefined ) {
						if ( ! ( t &gt;= t0 ) ) {
</P><P>							// looping?
</P><P>							var t1global = pp[ 1 ];
</P><P>							if ( t &lt; t1global ) {
</P><P>								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;
</P><P>							}
</P><P>							// linear reverse scan
</P><P>							for ( var giveUpAt = i1 - 2; ; ) {
</P><P>								if ( t0 === undefined ) {
</P><P>									// before start
</P><P>									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );
</P><P>								}
</P><P>								if ( i1 === giveUpAt ) break; // this loop
</P><P>								t1 = t0;
								t0 = pp[ -- i1 - 1 ];
</P><P>								if ( t &gt;= t0 ) {
</P><P>									// we have arrived at the sought interval
									break seek;
</P><P>								}
</P><P>							}
</P><P>							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;
</P><P>						}
</P><P>						// the interval is valid
</P><P>						break validate_interval;
</P><P>					} // linear scan
</P><P>					// binary search
</P><P>					while ( i1 &lt; right ) {
</P><P>						var mid = ( i1 + right ) &gt;&gt;&gt; 1;
</P><P>						if ( t &lt; pp[ mid ] ) {
</P><P>							right = mid;
</P><P>						} else {
</P><P>							i1 = mid + 1;
</P><P>						}
</P><P>					}
</P><P>					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];
</P><P>					// check boundary cases, again
</P><P>					if ( t0 === undefined ) {
</P><P>						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );
</P><P>					}
</P><P>					if ( t1 === undefined ) {
</P><P>						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );
</P><P>					}
</P><P>				} // seek
</P><P>				this._cachedIndex = i1;
</P><P>				this.intervalChanged_( i1, t0, t1 );
</P><P>			} // validate_interval
</P><P>			return this.interpolate_( i1, t0, t, t1 );
</P><P>		},
</P><P>		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.
</P><P>		// --- Protected interface
</P><P>		DefaultSettings_: {},
</P><P>		getSettings_: function () {
</P><P>			return this.settings || this.DefaultSettings_;
</P><P>		},
</P><P>		copySampleValue_: function ( index ) {
</P><P>			// copies a sample value to the result buffer
</P><P>			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;
</P><P>			for ( var i = 0; i !== stride; ++ i ) {
</P><P>				result[ i ] = values[ offset + i ];
</P><P>			}
</P><P>			return result;
</P><P>		},
</P><P>		// Template methods for derived classes:
</P><P>		interpolate_: function ( /* i1, t0, t, t1 */ ) {
</P><P>			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer
</P><P>		},
</P><P>		intervalChanged_: function ( /* i1, t0, t1 */ ) {
</P><P>			// empty
</P><P>		}
</P><P>	} );
</P><P>	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( Interpolant.prototype, {
</P><P>		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,
</P><P>		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,
</P><P>	} );
</P><P>	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */
</P><P>	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
</P><P>		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
</P><P>		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;
</P><P>	}
</P><P>	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
</P><P>		constructor: CubicInterpolant,
</P><P>		DefaultSettings_: {
</P><P>			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
</P><P>		},
</P><P>		intervalChanged_: function ( i1, t0, t1 ) {
</P><P>			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,
</P><P>				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];
</P><P>			if ( tPrev === undefined ) {
</P><P>				switch ( this.getSettings_().endingStart ) {
</P><P>					case ZeroSlopeEnding:
</P><P>						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
</P><P>						break;
</P><P>					case WrapAroundEnding:
</P><P>						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
</P><P>						break;
</P><P>					default: // ZeroCurvatureEnding
</P><P>						// f<I>(t0) = 0 a.k.a. Natural Spline</I>
						iPrev = i1;
						tPrev = t1;
</P><P>				}
</P><P>			}
</P><P>			if ( tNext === undefined ) {
</P><P>				switch ( this.getSettings_().endingEnd ) {
</P><P>					case ZeroSlopeEnding:
</P><P>						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
</P><P>						break;
</P><P>					case WrapAroundEnding:
</P><P>						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];
</P><P>						break;
</P><P>					default: // ZeroCurvatureEnding
</P><P>						// f<I>(tN) = 0, a.k.a. Natural Spline</I>
						iNext = i1 - 1;
						tNext = t0;
</P><P>				}
</P><P>			}
</P><P>			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;
</P><P>			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
</P><P>		},
</P><P>		interpolate_: function ( i1, t0, t, t1 ) {
</P><P>			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
</P><P>				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,
</P><P>				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;
</P><P>			// evaluate polynomials
</P><P>			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;
</P><P>			// combine data linearly
</P><P>			for ( var i = 0; i !== stride; ++ i ) {
</P><P>				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];
</P><P>			}
</P><P>			return result;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author tschw
	 */
</P><P>	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
</P><P>		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
</P><P>	}
</P><P>	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
</P><P>		constructor: LinearInterpolant,
</P><P>		interpolate_: function ( i1, t0, t, t1 ) {
</P><P>			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
</P><P>				offset1 = i1 * stride,
				offset0 = offset1 - stride,
</P><P>				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;
</P><P>			for ( var i = 0; i !== stride; ++ i ) {
</P><P>				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;
</P><P>			}
</P><P>			return result;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */
</P><P>	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
</P><P>		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
</P><P>	}
</P><P>	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
</P><P>		constructor: DiscreteInterpolant,
</P><P>		interpolate_: function ( i1 /*, t0, t, t1 */ ) {
</P><P>			return this.copySampleValue_( i1 - 1 );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	function KeyframeTrack( name, times, values, interpolation ) {
</P><P>		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );
</P><P>		this.name = name;
</P><P>		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );
</P><P>		this.setInterpolation( interpolation || this.DefaultInterpolation );
</P><P>	}
</P><P>	// Static methods
</P><P>	Object.assign( KeyframeTrack, {
</P><P>		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):
</P><P>		toJSON: function ( track ) {
</P><P>			var trackType = track.constructor;
</P><P>			var json;
</P><P>			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {
</P><P>				json = trackType.toJSON( track );
</P><P>			} else {
</P><P>				// by default, we assume the data can be serialized as-is
				json = {
</P><P>					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )
</P><P>				};
</P><P>				var interpolation = track.getInterpolation();
</P><P>				if ( interpolation !== track.DefaultInterpolation ) {
</P><P>					json.interpolation = interpolation;
</P><P>				}
</P><P>			}
</P><P>			json.type = track.ValueTypeName; // mandatory
</P><P>			return json;
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( KeyframeTrack.prototype, {
</P><P>		constructor: KeyframeTrack,
</P><P>		TimeBufferType: Float32Array,
</P><P>		ValueBufferType: Float32Array,
</P><P>		DefaultInterpolation: InterpolateLinear,
</P><P>		InterpolantFactoryMethodDiscrete: function ( result ) {
</P><P>			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );
</P><P>		},
</P><P>		InterpolantFactoryMethodLinear: function ( result ) {
</P><P>			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );
</P><P>		},
</P><P>		InterpolantFactoryMethodSmooth: function ( result ) {
</P><P>			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );
</P><P>		},
</P><P>		setInterpolation: function ( interpolation ) {
</P><P>			var factoryMethod;
</P><P>			switch ( interpolation ) {
</P><P>				case InterpolateDiscrete:
</P><P>					factoryMethod = this.InterpolantFactoryMethodDiscrete;
</P><P>					break;
</P><P>				case InterpolateLinear:
</P><P>					factoryMethod = this.InterpolantFactoryMethodLinear;
</P><P>					break;
</P><P>				case InterpolateSmooth:
</P><P>					factoryMethod = this.InterpolantFactoryMethodSmooth;
</P><P>					break;
</P><P>			}
</P><P>			if ( factoryMethod === undefined ) {
</P><P>				var message = &quot;unsupported interpolation for &quot; +
					this.ValueTypeName + &quot; keyframe track named &quot; + this.name;
</P><P>				if ( this.createInterpolant === undefined ) {
</P><P>					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {
</P><P>						this.setInterpolation( this.DefaultInterpolation );
</P><P>					} else {
</P><P>						throw new Error( message ); // fatal, in this case
</P><P>					}
</P><P>				}
</P><P>				console.warn( 'THREE.KeyframeTrack:', message );
				return this;
</P><P>			}
</P><P>			this.createInterpolant = factoryMethod;
</P><P>			return this;
</P><P>		},
</P><P>		getInterpolation: function () {
</P><P>			switch ( this.createInterpolant ) {
</P><P>				case this.InterpolantFactoryMethodDiscrete:
</P><P>					return InterpolateDiscrete;
</P><P>				case this.InterpolantFactoryMethodLinear:
</P><P>					return InterpolateLinear;
</P><P>				case this.InterpolantFactoryMethodSmooth:
</P><P>					return InterpolateSmooth;
</P><P>			}
</P><P>		},
</P><P>		getValueSize: function () {
</P><P>			return this.values.length / this.times.length;
</P><P>		},
</P><P>		// move all keyframes either forwards or backwards in time
		shift: function ( timeOffset ) {
</P><P>			if ( timeOffset !== 0.0 ) {
</P><P>				var times = this.times;
</P><P>				for ( var i = 0, n = times.length; i !== n; ++ i ) {
</P><P>					times[ i ] += timeOffset;
</P><P>				}
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		// scale all keyframe times by a factor (useful for frame &lt;-&gt; seconds conversions)
		scale: function ( timeScale ) {
</P><P>			if ( timeScale !== 1.0 ) {
</P><P>				var times = this.times;
</P><P>				for ( var i = 0, n = times.length; i !== n; ++ i ) {
</P><P>					times[ i ] *= timeScale;
</P><P>				}
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function ( startTime, endTime ) {
</P><P>			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;
</P><P>			while ( from !== nKeys &amp;&amp; times[ from ] &lt; startTime ) {
</P><P>				++ from;
</P><P>			}
</P><P>			while ( to !== - 1 &amp;&amp; times[ to ] &gt; endTime ) {
</P><P>				-- to;
</P><P>			}
</P><P>			++ to; // inclusive -&gt; exclusive bound
</P><P>			if ( from !== 0 || to !== nKeys ) {
</P><P>				// empty tracks are forbidden, so keep at least one keyframe
				if ( from &gt;= to ) to = Math.max( to, 1 ), from = to - 1;
</P><P>				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function () {
</P><P>			var valid = true;
</P><P>			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {
</P><P>				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;
</P><P>			}
</P><P>			var times = this.times,
				values = this.values,
</P><P>				nKeys = times.length;
</P><P>			if ( nKeys === 0 ) {
</P><P>				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;
</P><P>			}
</P><P>			var prevTime = null;
</P><P>			for ( var i = 0; i !== nKeys; i ++ ) {
</P><P>				var currTime = times[ i ];
</P><P>				if ( typeof currTime === 'number' &amp;&amp; isNaN( currTime ) ) {
</P><P>					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;
</P><P>				}
</P><P>				if ( prevTime !== null &amp;&amp; prevTime &gt; currTime ) {
</P><P>					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;
</P><P>				}
</P><P>				prevTime = currTime;
</P><P>			}
</P><P>			if ( values !== undefined ) {
</P><P>				if ( AnimationUtils.isTypedArray( values ) ) {
</P><P>					for ( var i = 0, n = values.length; i !== n; ++ i ) {
</P><P>						var value = values[ i ];
</P><P>						if ( isNaN( value ) ) {
</P><P>							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			return valid;
</P><P>		},
</P><P>		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --&gt; (0,0,1,1,0,0)
		optimize: function () {
</P><P>			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),
</P><P>				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
</P><P>				writeIndex = 1,
				lastIndex = times.length - 1;
</P><P>			for ( var i = 1; i &lt; lastIndex; ++ i ) {
</P><P>				var keep = false;
</P><P>				var time = times[ i ];
				var timeNext = times[ i + 1 ];
</P><P>				// remove adjacent keyframes scheduled at the same time
</P><P>				if ( time !== timeNext &amp;&amp; ( i !== 1 || time !== time[ 0 ] ) ) {
</P><P>					if ( ! smoothInterpolation ) {
</P><P>						// remove unnecessary keyframes same as their neighbors
</P><P>						var offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;
</P><P>						for ( var j = 0; j !== stride; ++ j ) {
</P><P>							var value = values[ offset + j ];
</P><P>							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {
</P><P>								keep = true;
								break;
</P><P>							}
</P><P>						}
</P><P>					} else {
</P><P>						keep = true;
</P><P>					}
</P><P>				}
</P><P>				// in-place compaction
</P><P>				if ( keep ) {
</P><P>					if ( i !== writeIndex ) {
</P><P>						times[ writeIndex ] = times[ i ];
</P><P>						var readOffset = i * stride,
							writeOffset = writeIndex * stride;
</P><P>						for ( var j = 0; j !== stride; ++ j ) {
</P><P>							values[ writeOffset + j ] = values[ readOffset + j ];
</P><P>						}
</P><P>					}
</P><P>					++ writeIndex;
</P><P>				}
</P><P>			}
</P><P>			// flush last keyframe (compaction looks ahead)
</P><P>			if ( lastIndex &gt; 0 ) {
</P><P>				times[ writeIndex ] = times[ lastIndex ];
</P><P>				for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {
</P><P>					values[ writeOffset + j ] = values[ readOffset + j ];
</P><P>				}
</P><P>				++ writeIndex;
</P><P>			}
</P><P>			if ( writeIndex !== times.length ) {
</P><P>				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );
</P><P>			}
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	function BooleanKeyframeTrack( name, times, values ) {
</P><P>		KeyframeTrack.call( this, name, times, values );
</P><P>	}
</P><P>	BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
</P><P>		constructor: BooleanKeyframeTrack,
</P><P>		ValueTypeName: 'bool',
		ValueBufferType: Array,
</P><P>		DefaultInterpolation: InterpolateDiscrete,
</P><P>		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined
</P><P>		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes &quot;firstValue ^ isOdd( index )&quot;.
</P><P>	} );
</P><P>	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	function ColorKeyframeTrack( name, times, values, interpolation ) {
</P><P>		KeyframeTrack.call( this, name, times, values, interpolation );
</P><P>	}
</P><P>	ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
</P><P>		constructor: ColorKeyframeTrack,
</P><P>		ValueTypeName: 'color'
</P><P>		// ValueBufferType is inherited
</P><P>		// DefaultInterpolation is inherited
</P><P>		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.
</P><P>	} );
</P><P>	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	function NumberKeyframeTrack( name, times, values, interpolation ) {
</P><P>		KeyframeTrack.call( this, name, times, values, interpolation );
</P><P>	}
</P><P>	NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
</P><P>		constructor: NumberKeyframeTrack,
</P><P>		ValueTypeName: 'number'
</P><P>		// ValueBufferType is inherited
</P><P>		// DefaultInterpolation is inherited
</P><P>	} );
</P><P>	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */
</P><P>	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
</P><P>		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
</P><P>	}
</P><P>	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
</P><P>		constructor: QuaternionLinearInterpolant,
</P><P>		interpolate_: function ( i1, t0, t, t1 ) {
</P><P>			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
</P><P>				offset = i1 * stride,
</P><P>				alpha = ( t - t0 ) / ( t1 - t0 );
</P><P>			for ( var end = offset + stride; offset !== end; offset += 4 ) {
</P><P>				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );
</P><P>			}
</P><P>			return result;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	function QuaternionKeyframeTrack( name, times, values, interpolation ) {
</P><P>		KeyframeTrack.call( this, name, times, values, interpolation );
</P><P>	}
</P><P>	QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
</P><P>		constructor: QuaternionKeyframeTrack,
</P><P>		ValueTypeName: 'quaternion',
</P><P>		// ValueBufferType is inherited
</P><P>		DefaultInterpolation: InterpolateLinear,
</P><P>		InterpolantFactoryMethodLinear: function ( result ) {
</P><P>			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );
</P><P>		},
</P><P>		InterpolantFactoryMethodSmooth: undefined // not yet implemented
</P><P>	} );
</P><P>	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	function StringKeyframeTrack( name, times, values, interpolation ) {
</P><P>		KeyframeTrack.call( this, name, times, values, interpolation );
</P><P>	}
</P><P>	StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
</P><P>		constructor: StringKeyframeTrack,
</P><P>		ValueTypeName: 'string',
		ValueBufferType: Array,
</P><P>		DefaultInterpolation: InterpolateDiscrete,
</P><P>		InterpolantFactoryMethodLinear: undefined,
</P><P>		InterpolantFactoryMethodSmooth: undefined
</P><P>	} );
</P><P>	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	function VectorKeyframeTrack( name, times, values, interpolation ) {
</P><P>		KeyframeTrack.call( this, name, times, values, interpolation );
</P><P>	}
</P><P>	VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
</P><P>		constructor: VectorKeyframeTrack,
</P><P>		ValueTypeName: 'vector'
</P><P>		// ValueBufferType is inherited
</P><P>		// DefaultInterpolation is inherited
</P><P>	} );
</P><P>	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 */
</P><P>	function AnimationClip( name, duration, tracks ) {
</P><P>		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : - 1;
</P><P>		this.uuid = _Math.generateUUID();
</P><P>		// this means it should figure out its duration by scanning the tracks
		if ( this.duration &lt; 0 ) {
</P><P>			this.resetDuration();
</P><P>		}
</P><P>	}
</P><P>	function getTrackTypeForValueTypeName( typeName ) {
</P><P>		switch ( typeName.toLowerCase() ) {
</P><P>			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
</P><P>				return NumberKeyframeTrack;
</P><P>			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
</P><P>				return VectorKeyframeTrack;
</P><P>			case 'color':
</P><P>				return ColorKeyframeTrack;
</P><P>			case 'quaternion':
</P><P>				return QuaternionKeyframeTrack;
</P><P>			case 'bool':
			case 'boolean':
</P><P>				return BooleanKeyframeTrack;
</P><P>			case 'string':
</P><P>				return StringKeyframeTrack;
</P><P>		}
</P><P>		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );
</P><P>	}
</P><P>	function parseKeyframeTrack( json ) {
</P><P>		if ( json.type === undefined ) {
</P><P>			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );
</P><P>		}
</P><P>		var trackType = getTrackTypeForValueTypeName( json.type );
</P><P>		if ( json.times === undefined ) {
</P><P>			var times = [], values = [];
</P><P>			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
</P><P>			json.times = times;
			json.values = values;
</P><P>		}
</P><P>		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {
</P><P>			return trackType.parse( json );
</P><P>		} else {
</P><P>			// by default, we assume a constructor compatible with the base
			return new trackType( json.name, json.times, json.values, json.interpolation );
</P><P>		}
</P><P>	}
</P><P>	Object.assign( AnimationClip, {
</P><P>		parse: function ( json ) {
</P><P>			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );
</P><P>			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
</P><P>				tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );
</P><P>			}
</P><P>			return new AnimationClip( json.name, json.duration, tracks );
</P><P>		},
</P><P>		toJSON: function ( clip ) {
</P><P>			var tracks = [],
				clipTracks = clip.tracks;
</P><P>			var json = {
</P><P>				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid
</P><P>			};
</P><P>			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
</P><P>				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );
</P><P>			}
</P><P>			return json;
</P><P>		},
</P><P>		CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {
</P><P>			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];
</P><P>			for ( var i = 0; i &lt; numMorphTargets; i ++ ) {
</P><P>				var times = [];
				var values = [];
</P><P>				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );
</P><P>				values.push( 0, 1, 0 );
</P><P>				var order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );
</P><P>				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop &amp;&amp; times[ 0 ] === 0 ) {
</P><P>					times.push( numMorphTargets );
					values.push( values[ 0 ] );
</P><P>				}
</P><P>				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );
</P><P>			}
</P><P>			return new AnimationClip( name, - 1, tracks );
</P><P>		},
</P><P>		findByName: function ( objectOrClipArray, name ) {
</P><P>			var clipArray = objectOrClipArray;
</P><P>			if ( ! Array.isArray( objectOrClipArray ) ) {
</P><P>				var o = objectOrClipArray;
				clipArray = o.geometry &amp;&amp; o.geometry.animations || o.animations;
</P><P>			}
</P><P>			for ( var i = 0; i &lt; clipArray.length; i ++ ) {
</P><P>				if ( clipArray[ i ].name === name ) {
</P><P>					return clipArray[ i ];
</P><P>				}
</P><P>			}
</P><P>			return null;
</P><P>		},
</P><P>		CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {
</P><P>			var animationToMorphTargets = {};
</P><P>			// tested with <A rel="nofollow" class="external free" href="https://regex101.com/">https://regex101.com/</A> on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;
</P><P>			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i &lt; il; i ++ ) {
</P><P>				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );
</P><P>				if ( parts &amp;&amp; parts.length &gt; 1 ) {
</P><P>					var name = parts[ 1 ];
</P><P>					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {
</P><P>						animationToMorphTargets[ name ] = animationMorphTargets = [];
</P><P>					}
</P><P>					animationMorphTargets.push( morphTarget );
</P><P>				}
</P><P>			}
</P><P>			var clips = [];
</P><P>			for ( var name in animationToMorphTargets ) {
</P><P>				clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );
</P><P>			}
</P><P>			return clips;
</P><P>		},
</P><P>		// parse the animation.hierarchy format
		parseAnimation: function ( animation, bones ) {
</P><P>			if ( ! animation ) {
</P><P>				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;
</P><P>			}
</P><P>			var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {
</P><P>				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {
</P><P>					var times = [];
					var values = [];
</P><P>					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );
</P><P>					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {
</P><P>						destTracks.push( new trackType( trackName, times, values ) );
</P><P>					}
</P><P>				}
</P><P>			};
</P><P>			var tracks = [];
</P><P>			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || - 1;
			var fps = animation.fps || 30;
</P><P>			var hierarchyTracks = animation.hierarchy || [];
</P><P>			for ( var h = 0; h &lt; hierarchyTracks.length; h ++ ) {
</P><P>				var animationKeys = hierarchyTracks[ h ].keys;
</P><P>				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;
</P><P>				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {
</P><P>					// figure out all morph targets used in this track
					var morphTargetNames = {};
</P><P>					for ( var k = 0; k &lt; animationKeys.length; k ++ ) {
</P><P>						if ( animationKeys[ k ].morphTargets ) {
</P><P>							for ( var m = 0; m &lt; animationKeys[ k ].morphTargets.length; m ++ ) {
</P><P>								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;
</P><P>							}
</P><P>						}
</P><P>					}
</P><P>					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {
</P><P>						var times = [];
						var values = [];
</P><P>						for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {
</P><P>							var animationKey = animationKeys[ k ];
</P><P>							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );
</P><P>						}
</P><P>						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
</P><P>					}
</P><P>					duration = morphTargetNames.length * ( fps || 1.0 );
</P><P>				} else {
</P><P>					// ...assume skeletal animation
</P><P>					var boneName = '.bones[' + bones[ h ].name + ']';
</P><P>					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );
</P><P>					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );
</P><P>					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );
</P><P>				}
</P><P>			}
</P><P>			if ( tracks.length === 0 ) {
</P><P>				return null;
</P><P>			}
</P><P>			var clip = new AnimationClip( clipName, duration, tracks );
</P><P>			return clip;
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( AnimationClip.prototype, {
</P><P>		resetDuration: function () {
</P><P>			var tracks = this.tracks, duration = 0;
</P><P>			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
</P><P>				var track = this.tracks[ i ];
</P><P>				duration = Math.max( duration, track.times[ track.times.length - 1 ] );
</P><P>			}
</P><P>			this.duration = duration;
</P><P>			return this;
</P><P>		},
</P><P>		trim: function () {
</P><P>			for ( var i = 0; i &lt; this.tracks.length; i ++ ) {
</P><P>				this.tracks[ i ].trim( 0, this.duration );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		validate: function () {
</P><P>			var valid = true;
</P><P>			for ( var i = 0; i &lt; this.tracks.length; i ++ ) {
</P><P>				valid = valid &amp;&amp; this.tracks[ i ].validate();
</P><P>			}
</P><P>			return valid;
</P><P>		},
</P><P>		optimize: function () {
</P><P>			for ( var i = 0; i &lt; this.tracks.length; i ++ ) {
</P><P>				this.tracks[ i ].optimize();
</P><P>			}
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function MaterialLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.textures = {};
</P><P>	}
</P><P>	Object.assign( MaterialLoader.prototype, {
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			var scope = this;
</P><P>			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {
</P><P>				onLoad( scope.parse( JSON.parse( text ) ) );
</P><P>			}, onProgress, onError );
</P><P>		},
</P><P>		setTextures: function ( value ) {
</P><P>			this.textures = value;
</P><P>		},
</P><P>		parse: function ( json ) {
</P><P>			var textures = this.textures;
</P><P>			function getTexture( name ) {
</P><P>				if ( textures[ name ] === undefined ) {
</P><P>					console.warn( 'THREE.MaterialLoader: Undefined texture', name );
</P><P>				}
</P><P>				return textures[ name ];
</P><P>			}
</P><P>			var material = new Materials[ json.type ]();
</P><P>			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
			if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.combine !== undefined ) material.combine = json.combine;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
</P><P>			if ( json.rotation !== undefined ) material.rotation = json.rotation;
</P><P>			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;
</P><P>			if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
			if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;
</P><P>			if ( json.skinning !== undefined ) material.skinning = json.skinning;
			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
			if ( json.dithering !== undefined ) material.dithering = json.dithering;
</P><P>			if ( json.visible !== undefined ) material.visible = json.visible;
			if ( json.userData !== undefined ) material.userData = json.userData;
</P><P>			// Shader Material
</P><P>			if ( json.uniforms !== undefined ) {
</P><P>				for ( var name in json.uniforms ) {
</P><P>					var uniform = json.uniforms[ name ];
</P><P>					material.uniforms[ name ] = {};
</P><P>					switch ( uniform.type ) {
</P><P>						case 't':
							material.uniforms[ name ].value = getTexture( uniform.value );
							break;
</P><P>						case 'c':
							material.uniforms[ name ].value = new Color().setHex( uniform.value );
							break;
</P><P>						case 'v2':
							material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
							break;
</P><P>						case 'v3':
							material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
							break;
</P><P>						case 'v4':
							material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
							break;
</P><P>						case 'm4':
							material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
							break;
</P><P>						default:
							material.uniforms[ name ].value = uniform.value;
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			if ( json.defines !== undefined ) material.defines = json.defines;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
</P><P>			// Deprecated
</P><P>			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading
</P><P>			// for PointsMaterial
</P><P>			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
</P><P>			// maps
</P><P>			if ( json.map !== undefined ) material.map = getTexture( json.map );
</P><P>			if ( json.alphaMap !== undefined ) {
</P><P>				material.alphaMap = getTexture( json.alphaMap );
				material.transparent = true;
</P><P>			}
</P><P>			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
</P><P>			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
			if ( json.normalScale !== undefined ) {
</P><P>				var normalScale = json.normalScale;
</P><P>				if ( Array.isArray( normalScale ) === false ) {
</P><P>					// Blender exporter used to export a scalar. See #7459
</P><P>					normalScale = [ normalScale, normalScale ];
</P><P>				}
</P><P>				material.normalScale = new Vector2().fromArray( normalScale );
</P><P>			}
</P><P>			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
</P><P>			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );
</P><P>			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
</P><P>			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
</P><P>			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
			if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;
</P><P>			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
</P><P>	if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
</P><P>			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
</P><P>			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );
</P><P>			return material;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function BufferGeometryLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>	}
</P><P>	Object.assign( BufferGeometryLoader.prototype, {
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			var scope = this;
</P><P>			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {
</P><P>				onLoad( scope.parse( JSON.parse( text ) ) );
</P><P>			}, onProgress, onError );
</P><P>		},
</P><P>		parse: function ( json ) {
</P><P>			var geometry = new BufferGeometry();
</P><P>			var index = json.data.index;
</P><P>			if ( index !== undefined ) {
</P><P>				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );
</P><P>			}
</P><P>			var attributes = json.data.attributes;
</P><P>			for ( var key in attributes ) {
</P><P>				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
</P><P>				geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );
</P><P>			}
</P><P>			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
</P><P>			if ( groups !== undefined ) {
</P><P>				for ( var i = 0, n = groups.length; i !== n; ++ i ) {
</P><P>var group = groups[ i ];
</P><P>					geometry.addGroup( group.start, group.count, group.materialIndex );
</P><P>				}
</P><P>			}
</P><P>			var boundingSphere = json.data.boundingSphere;
</P><P>			if ( boundingSphere !== undefined ) {
</P><P>				var center = new Vector3();
</P><P>				if ( boundingSphere.center !== undefined ) {
</P><P>					center.fromArray( boundingSphere.center );
</P><P>				}
</P><P>				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );
</P><P>			}
</P><P>			return geometry;
</P><P>		}
</P><P>	} );
</P><P>	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function Loader() {}
</P><P>	Loader.Handlers = {
</P><P>		handlers: [],
</P><P>		add: function ( regex, loader ) {
</P><P>			this.handlers.push( regex, loader );
</P><P>		},
</P><P>		get: function ( file ) {
</P><P>			var handlers = this.handlers;
</P><P>			for ( var i = 0, l = handlers.length; i &lt; l; i += 2 ) {
</P><P>				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];
</P><P>				if ( regex.test( file ) ) {
</P><P>					return loader;
</P><P>				}
</P><P>			}
</P><P>			return null;
</P><P>		}
</P><P>	};
</P><P>	Object.assign( Loader.prototype, {
</P><P>		crossOrigin: 'anonymous',
</P><P>		onLoadStart: function () {},
</P><P>		onLoadProgress: function () {},
</P><P>		onLoadComplete: function () {},
</P><P>		initMaterials: function ( materials, texturePath, crossOrigin ) {
</P><P>			var array = [];
</P><P>			for ( var i = 0; i &lt; materials.length; ++ i ) {
</P><P>				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
</P><P>			}
</P><P>			return array;
</P><P>		},
</P><P>		createMaterial: ( function () {
</P><P>			var BlendingMode = {
				NoBlending: NoBlending,
				NormalBlending: NormalBlending,
				AdditiveBlending: AdditiveBlending,
				SubtractiveBlending: SubtractiveBlending,
				MultiplyBlending: MultiplyBlending,
				CustomBlending: CustomBlending
			};
</P><P>			var color = new Color();
			var textureLoader = new TextureLoader();
			var materialLoader = new MaterialLoader();
</P><P>			return function createMaterial( m, texturePath, crossOrigin ) {
</P><P>				// convert from old material format
</P><P>				var textures = {};
</P><P>				function loadTexture( path, repeat, offset, wrap, anisotropy ) {
</P><P>					var fullPath = texturePath + path;
					var loader = Loader.Handlers.get( fullPath );
</P><P>					var texture;
</P><P>					if ( loader !== null ) {
</P><P>						texture = loader.load( fullPath );
</P><P>					} else {
</P><P>						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );
</P><P>					}
</P><P>					if ( repeat !== undefined ) {
</P><P>						texture.repeat.fromArray( repeat );
</P><P>						if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;
</P><P>					}
</P><P>					if ( offset !== undefined ) {
</P><P>						texture.offset.fromArray( offset );
</P><P>					}
</P><P>					if ( wrap !== undefined ) {
</P><P>						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;
</P><P>						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;
</P><P>					}
</P><P>					if ( anisotropy !== undefined ) {
</P><P>						texture.anisotropy = anisotropy;
</P><P>					}
</P><P>					var uuid = _Math.generateUUID();
</P><P>					textures[ uuid ] = texture;
</P><P>					return uuid;
</P><P>				}
</P><P>				//
</P><P>				var json = {
					uuid: _Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};
</P><P>				for ( var name in m ) {
</P><P>					var value = m[ name ];
</P><P>					switch ( name ) {
</P><P>						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = BlendingMode[ value ];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = value;
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = BackSide;
							break;
						case 'doubleSided':
							json.side = DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = VertexColors;
							if ( value === 'face' ) json.vertexColors = FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;
</P><P>					}
</P><P>				}
</P><P>				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
</P><P>				if ( json.opacity &lt; 1 ) json.transparent = true;
</P><P>				materialLoader.setTextures( textures );
</P><P>				return materialLoader.parse( json );
</P><P>			};
</P><P>		} )()
</P><P>	} );
</P><P>	/**
	 * @author Don McCurdy / <A rel="nofollow" class="external free" href="https://www.donmccurdy.com">https://www.donmccurdy.com</A>
	 */
</P><P>	var LoaderUtils = {
</P><P>		decodeText: function ( array ) {
</P><P>			if ( typeof TextDecoder !== 'undefined' ) {
</P><P>				return new TextDecoder().decode( array );
</P><P>			}
</P><P>			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a &quot;maximum call stack size exceeded&quot; error for large arrays.
</P><P>			var s = <I>;</I></P><P>			for ( var i = 0, il = array.length; i &lt; il; i ++ ) {
</P><P>				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );
</P><P>			}
</P><P>			// Merges multi-byte utf-8 characters.
			return decodeURIComponent( escape( s ) );
</P><P>		},
</P><P>		extractUrlBase: function ( url ) {
</P><P>			var index = url.lastIndexOf( '/' );
</P><P>			if ( index === - 1 ) return './';
</P><P>			return url.substr( 0, index + 1 );
</P><P>		}
</P><P>	};
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function JSONLoader( manager ) {
</P><P>		if ( typeof manager === 'boolean' ) {
</P><P>			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;
</P><P>		}
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>		this.withCredentials = false;
</P><P>	}
</P><P>	Object.assign( JSONLoader.prototype, {
</P><P>		crossOrigin: 'anonymous',
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			var scope = this;
</P><P>			var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;
</P><P>			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {
</P><P>				var json = JSON.parse( text );
				var metadata = json.metadata;
</P><P>				if ( metadata !== undefined ) {
</P><P>					var type = metadata.type;
</P><P>					if ( type !== undefined ) {
</P><P>						if ( type.toLowerCase() === 'object' ) {
</P><P>							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
							return;
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>				var object = scope.parse( json, path );
				onLoad( object.geometry, object.materials );
</P><P>			}, onProgress, onError );
</P><P>		},
</P><P>		setPath: function ( value ) {
</P><P>			this.path = value;
			return this;
</P><P>		},
</P><P>		setResourcePath: function ( value ) {
</P><P>			this.resourcePath = value;
			return this;
</P><P>		},
</P><P>		setCrossOrigin: function ( value ) {
</P><P>			this.crossOrigin = value;
			return this;
</P><P>		},
</P><P>		parse: ( function () {
</P><P>			function parseModel( json, geometry ) {
</P><P>				function isBitSet( value, position ) {
</P><P>					return value &amp; ( 1 &lt;&lt; position );
</P><P>				}
</P><P>				var i, j, fi,
</P><P>					offset, zLength,
</P><P>					colorIndex, normalIndex, uvIndex, materialIndex,
</P><P>					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,
</P><P>					vertex, face, faceA, faceB, hex, normal,
</P><P>					uvLayer, uv, u, v,
</P><P>					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,
</P><P>					scale = json.scale,
</P><P>					nUvLayers = 0;
</P><P>
				if ( json.uvs !== undefined ) {
</P><P>					// disregard empty arrays
</P><P>					for ( i = 0; i &lt; json.uvs.length; i ++ ) {
</P><P>						if ( json.uvs[ i ].length ) nUvLayers ++;
</P><P>					}
</P><P>					for ( i = 0; i &lt; nUvLayers; i ++ ) {
</P><P>						geometry.faceVertexUvs[ i ] = [];
</P><P>					}
</P><P>				}
</P><P>				offset = 0;
				zLength = vertices.length;
</P><P>				while ( offset &lt; zLength ) {
</P><P>					vertex = new Vector3();
</P><P>					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;
</P><P>					geometry.vertices.push( vertex );
</P><P>				}
</P><P>				offset = 0;
				zLength = faces.length;
</P><P>				while ( offset &lt; zLength ) {
</P><P>					type = faces[ offset ++ ];
</P><P>					isQuad = isBitSet( type, 0 );
					hasMaterial = isBitSet( type, 1 );
					hasFaceVertexUv = isBitSet( type, 3 );
					hasFaceNormal = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor = isBitSet( type, 6 );
					hasFaceVertexColor = isBitSet( type, 7 );
</P><P>					// console.log(&quot;type&quot;, type, &quot;bits&quot;, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
</P><P>					if ( isQuad ) {
</P><P>						faceA = new Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];
</P><P>						faceB = new Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];
</P><P>						offset += 4;
</P><P>						if ( hasMaterial ) {
</P><P>							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;
</P><P>						}
</P><P>						// to get face &lt;=&gt; uv index correspondence
</P><P>						fi = geometry.faces.length;
</P><P>						if ( hasFaceVertexUv ) {
</P><P>							for ( i = 0; i &lt; nUvLayers; i ++ ) {
</P><P>								uvLayer = json.uvs[ i ];
</P><P>								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
</P><P>								for ( j = 0; j &lt; 4; j ++ ) {
</P><P>									uvIndex = faces[ offset ++ ];
</P><P>									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
</P><P>									uv = new Vector2( u, v );
</P><P>									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
</P><P>								}
</P><P>							}
</P><P>						}
</P><P>						if ( hasFaceNormal ) {
</P><P>							normalIndex = faces[ offset ++ ] * 3;
</P><P>							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
</P><P>							faceB.normal.copy( faceA.normal );
</P><P>						}
</P><P>						if ( hasFaceVertexNormal ) {
</P><P>							for ( i = 0; i &lt; 4; i ++ ) {
</P><P>								normalIndex = faces[ offset ++ ] * 3;
</P><P>								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
</P><P>
								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );
</P><P>							}
</P><P>						}
</P><P>
						if ( hasFaceColor ) {
</P><P>							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];
</P><P>							faceA.color.setHex( hex );
							faceB.color.setHex( hex );
</P><P>						}
</P><P>
						if ( hasFaceVertexColor ) {
</P><P>							for ( i = 0; i &lt; 4; i ++ ) {
</P><P>								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];
</P><P>								if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );
</P><P>							}
</P><P>						}
</P><P>						geometry.faces.push( faceA );
						geometry.faces.push( faceB );
</P><P>					} else {
</P><P>						face = new Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];
</P><P>						if ( hasMaterial ) {
</P><P>							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;
</P><P>						}
</P><P>						// to get face &lt;=&gt; uv index correspondence
</P><P>						fi = geometry.faces.length;
</P><P>						if ( hasFaceVertexUv ) {
</P><P>							for ( i = 0; i &lt; nUvLayers; i ++ ) {
</P><P>								uvLayer = json.uvs[ i ];
</P><P>								geometry.faceVertexUvs[ i ][ fi ] = [];
</P><P>								for ( j = 0; j &lt; 3; j ++ ) {
</P><P>									uvIndex = faces[ offset ++ ];
</P><P>									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];
</P><P>									uv = new Vector2( u, v );
</P><P>									geometry.faceVertexUvs[ i ][ fi ].push( uv );
</P><P>								}
</P><P>							}
</P><P>						}
</P><P>						if ( hasFaceNormal ) {
</P><P>							normalIndex = faces[ offset ++ ] * 3;
</P><P>							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);
</P><P>						}
</P><P>						if ( hasFaceVertexNormal ) {
</P><P>							for ( i = 0; i &lt; 3; i ++ ) {
</P><P>								normalIndex = faces[ offset ++ ] * 3;
</P><P>								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
</P><P>								face.vertexNormals.push( normal );
</P><P>							}
</P><P>						}
</P><P>
						if ( hasFaceColor ) {
</P><P>							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );
</P><P>						}
</P><P>
						if ( hasFaceVertexColor ) {
</P><P>							for ( i = 0; i &lt; 3; i ++ ) {
</P><P>								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new Color( colors[ colorIndex ] ) );
</P><P>							}
</P><P>						}
</P><P>						geometry.faces.push( face );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			function parseSkin( json, geometry ) {
</P><P>				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
</P><P>				if ( json.skinWeights ) {
</P><P>					for ( var i = 0, l = json.skinWeights.length; i &lt; l; i += influencesPerVertex ) {
</P><P>						var x = json.skinWeights[ i ];
						var y = ( influencesPerVertex &gt; 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex &gt; 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex &gt; 3 ) ? json.skinWeights[ i + 3 ] : 0;
</P><P>						geometry.skinWeights.push( new Vector4( x, y, z, w ) );
</P><P>					}
</P><P>				}
</P><P>				if ( json.skinIndices ) {
</P><P>					for ( var i = 0, l = json.skinIndices.length; i &lt; l; i += influencesPerVertex ) {
</P><P>						var a = json.skinIndices[ i ];
						var b = ( influencesPerVertex &gt; 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex &gt; 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex &gt; 3 ) ? json.skinIndices[ i + 3 ] : 0;
</P><P>						geometry.skinIndices.push( new Vector4( a, b, c, d ) );
</P><P>					}
</P><P>				}
</P><P>				geometry.bones = json.bones;
</P><P>				if ( geometry.bones &amp;&amp; geometry.bones.length &gt; 0 &amp;&amp; ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
</P><P>					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
</P><P>				}
</P><P>			}
</P><P>			function parseMorphing( json, geometry ) {
</P><P>				var scale = json.scale;
</P><P>				if ( json.morphTargets !== undefined ) {
</P><P>					for ( var i = 0, l = json.morphTargets.length; i &lt; l; i ++ ) {
</P><P>						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];
</P><P>						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;
</P><P>						for ( var v = 0, vl = srcVertices.length; v &lt; vl; v += 3 ) {
</P><P>							var vertex = new Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;
</P><P>							dstVertices.push( vertex );
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>				if ( json.morphColors !== undefined &amp;&amp; json.morphColors.length &gt; 0 ) {
</P><P>					console.warn( 'THREE.JSONLoader: &quot;morphColors&quot; no longer supported. Using them as face colors.' );
</P><P>					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;
</P><P>					for ( var i = 0, l = faces.length; i &lt; l; i ++ ) {
</P><P>						faces[ i ].color.fromArray( morphColors, i * 3 );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			function parseAnimations( json, geometry ) {
</P><P>				var outputAnimations = [];
</P><P>				// parse old style Bone/Hierarchy animations
				var animations = [];
</P><P>				if ( json.animation !== undefined ) {
</P><P>					animations.push( json.animation );
</P><P>				}
</P><P>				if ( json.animations !== undefined ) {
</P><P>					if ( json.animations.length ) {
</P><P>						animations = animations.concat( json.animations );
</P><P>					} else {
</P><P>						animations.push( json.animations );
</P><P>					}
</P><P>				}
</P><P>				for ( var i = 0; i &lt; animations.length; i ++ ) {
</P><P>					var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
					if ( clip ) outputAnimations.push( clip );
</P><P>				}
</P><P>				// parse implicit morph animations
				if ( geometry.morphTargets ) {
</P><P>					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );
</P><P>				}
</P><P>				if ( outputAnimations.length &gt; 0 ) geometry.animations = outputAnimations;
</P><P>			}
</P><P>			return function parse( json, path ) {
</P><P>				if ( json.data !== undefined ) {
</P><P>					// Geometry 4.0 spec
					json = json.data;
</P><P>				}
</P><P>				if ( json.scale !== undefined ) {
</P><P>					json.scale = 1.0 / json.scale;
</P><P>				} else {
</P><P>					json.scale = 1.0;
</P><P>				}
</P><P>				var geometry = new Geometry();
</P><P>				parseModel( json, geometry );
				parseSkin( json, geometry );
				parseMorphing( json, geometry );
				parseAnimations( json, geometry );
</P><P>				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();
</P><P>				if ( json.materials === undefined || json.materials.length === 0 ) {
</P><P>					return { geometry: geometry };
</P><P>				} else {
</P><P>					var materials = Loader.prototype.initMaterials( json.materials, this.resourcePath || path, this.crossOrigin );
</P><P>					return { geometry: geometry, materials: materials };
</P><P>				}
</P><P>			};
</P><P>		} )()
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function ObjectLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.texturePath = <I>;</I></P><P>	}
</P><P>	Object.assign( ObjectLoader.prototype, {
</P><P>		crossOrigin: 'anonymous',
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			if ( this.texturePath === <I> ) {</I></P><P>				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
</P><P>			}
</P><P>			var scope = this;
</P><P>			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {
</P><P>				var json = null;
</P><P>				try {
</P><P>					json = JSON.parse( text );
</P><P>				} catch ( error ) {
</P><P>					if ( onError !== undefined ) onError( error );
</P><P>					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );
</P><P>					return;
</P><P>				}
</P><P>				var metadata = json.metadata;
</P><P>				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {
</P><P>					console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
					return;
</P><P>				}
</P><P>				scope.parse( json, onLoad );
</P><P>			}, onProgress, onError );
</P><P>		},
</P><P>		setTexturePath: function ( value ) {
</P><P>			this.texturePath = value;
			return this;
</P><P>		},
</P><P>		setCrossOrigin: function ( value ) {
</P><P>			this.crossOrigin = value;
			return this;
</P><P>		},
</P><P>		parse: function ( json, onLoad ) {
</P><P>			var shapes = this.parseShape( json.shapes );
			var geometries = this.parseGeometries( json.geometries, shapes );
</P><P>			var images = this.parseImages( json.images, function () {
</P><P>				if ( onLoad !== undefined ) onLoad( object );
</P><P>			} );
</P><P>			var textures = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
</P><P>			var object = this.parseObject( json.object, geometries, materials );
</P><P>			if ( json.animations ) {
</P><P>				object.animations = this.parseAnimations( json.animations );
</P><P>			}
</P><P>			if ( json.images === undefined || json.images.length === 0 ) {
</P><P>				if ( onLoad !== undefined ) onLoad( object );
</P><P>			}
</P><P>			return object;
</P><P>		},
</P><P>		parseShape: function ( json ) {
</P><P>			var shapes = {};
</P><P>			if ( json !== undefined ) {
</P><P>				for ( var i = 0, l = json.length; i &lt; l; i ++ ) {
</P><P>					var shape = new Shape().fromJSON( json[ i ] );
</P><P>					shapes[ shape.uuid ] = shape;
</P><P>				}
</P><P>			}
</P><P>			return shapes;
</P><P>		},
</P><P>		parseGeometries: function ( json, shapes ) {
</P><P>			var geometries = {};
</P><P>			if ( json !== undefined ) {
</P><P>				var geometryLoader = new JSONLoader();
				var bufferGeometryLoader = new BufferGeometryLoader();
</P><P>				for ( var i = 0, l = json.length; i &lt; l; i ++ ) {
</P><P>					var geometry;
					var data = json[ i ];
</P><P>					switch ( data.type ) {
</P><P>						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);
</P><P>							break;
</P><P>						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible
</P><P>							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);
</P><P>							break;
</P><P>						case 'CircleGeometry':
						case 'CircleBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);
</P><P>							break;
</P><P>						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);
</P><P>							break;
</P><P>						case 'ConeGeometry':
						case 'ConeBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);
</P><P>							break;
</P><P>						case 'SphereGeometry':
						case 'SphereBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
</P><P>							break;
</P><P>						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.radius,
								data.detail
							);
</P><P>							break;
</P><P>						case 'RingGeometry':
						case 'RingBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);
</P><P>							break;
</P><P>						case 'TorusGeometry':
						case 'TorusBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);
</P><P>							break;
</P><P>						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);
</P><P>							break;
</P><P>						case 'LatheGeometry':
						case 'LatheBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);
</P><P>							break;
</P><P>						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':
</P><P>							geometry = new Geometries[ data.type ](
								data.vertices,
								data.indices,
								data.radius,
								data.details
							);
</P><P>							break;
</P><P>						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':
</P><P>							var geometryShapes = [];
</P><P>							for ( var j = 0, jl = data.shapes.length; j &lt; jl; j ++ ) {
</P><P>								var shape = shapes[ data.shapes[ j ] ];
</P><P>								geometryShapes.push( shape );
</P><P>							}
</P><P>							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.curveSegments
							);
</P><P>							break;
</P><P>
						case 'ExtrudeGeometry':
						case 'ExtrudeBufferGeometry':
</P><P>							var geometryShapes = [];
</P><P>							for ( var j = 0, jl = data.shapes.length; j &lt; jl; j ++ ) {
</P><P>								var shape = shapes[ data.shapes[ j ] ];
</P><P>								geometryShapes.push( shape );
</P><P>							}
</P><P>							var extrudePath = data.options.extrudePath;
</P><P>							if ( extrudePath !== undefined ) {
</P><P>								data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );
</P><P>							}
</P><P>							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.options
							);
</P><P>							break;
</P><P>						case 'BufferGeometry':
</P><P>							geometry = bufferGeometryLoader.parse( data );
</P><P>							break;
</P><P>						case 'Geometry':
</P><P>							geometry = geometryLoader.parse( data, this.texturePath ).geometry;
</P><P>							break;
</P><P>						default:
</P><P>							console.warn( 'THREE.ObjectLoader: Unsupported geometry type &quot;' + data.type + '&quot;' );
</P><P>							continue;
</P><P>					}
</P><P>					geometry.uuid = data.uuid;
</P><P>					if ( data.name !== undefined ) geometry.name = data.name;
					if ( geometry.isBufferGeometry === true &amp;&amp; data.userData !== undefined ) geometry.userData = data.userData;
</P><P>					geometries[ data.uuid ] = geometry;
</P><P>				}
</P><P>			}
</P><P>			return geometries;
</P><P>		},
</P><P>		parseMaterials: function ( json, textures ) {
</P><P>			var materials = {};
</P><P>			if ( json !== undefined ) {
</P><P>				var loader = new MaterialLoader();
				loader.setTextures( textures );
</P><P>				for ( var i = 0, l = json.length; i &lt; l; i ++ ) {
</P><P>					var data = json[ i ];
</P><P>					if ( data.type === 'MultiMaterial' ) {
</P><P>						// Deprecated
</P><P>						var array = [];
</P><P>						for ( var j = 0; j &lt; data.materials.length; j ++ ) {
</P><P>							array.push( loader.parse( data.materials[ j ] ) );
</P><P>						}
</P><P>						materials[ data.uuid ] = array;
</P><P>					} else {
</P><P>						materials[ data.uuid ] = loader.parse( data );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			return materials;
</P><P>		},
</P><P>		parseAnimations: function ( json ) {
</P><P>			var animations = [];
</P><P>			for ( var i = 0; i &lt; json.length; i ++ ) {
</P><P>				var data = json[ i ];
</P><P>				var clip = AnimationClip.parse( data );
</P><P>				if ( data.uuid !== undefined ) clip.uuid = data.uuid;
</P><P>				animations.push( clip );
</P><P>			}
</P><P>			return animations;
</P><P>		},
</P><P>		parseImages: function ( json, onLoad ) {
</P><P>			var scope = this;
			var images = {};
</P><P>			function loadImage( url ) {
</P><P>				scope.manager.itemStart( url );
</P><P>				return loader.load( url, function () {
</P><P>					scope.manager.itemEnd( url );
</P><P>				}, undefined, function () {
</P><P>					scope.manager.itemEnd( url );
					scope.manager.itemError( url );
</P><P>				} );
</P><P>			}
</P><P>			if ( json !== undefined &amp;&amp; json.length &gt; 0 ) {
</P><P>				var manager = new LoadingManager( onLoad );
</P><P>				var loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );
</P><P>				for ( var i = 0, il = json.length; i &lt; il; i ++ ) {
</P><P>					var image = json[ i ];
					var url = image.url;
</P><P>					if ( Array.isArray( url ) ) {
</P><P>						// load array of images e.g CubeTexture
</P><P>						images[ image.uuid ] = [];
</P><P>						for ( var j = 0, jl = url.length; j &lt; jl; j ++ ) {
</P><P>							var currentUrl = url[ j ];
</P><P>							var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.texturePath + currentUrl;
</P><P>							images[ image.uuid ].push( loadImage( path ) );
</P><P>						}
</P><P>					} else {
</P><P>						// load single image
</P><P>						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
</P><P>						images[ image.uuid ] = loadImage( path );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			return images;
</P><P>		},
</P><P>		parseTextures: function ( json, images ) {
</P><P>			function parseConstant( value, type ) {
</P><P>				if ( typeof value === 'number' ) return value;
</P><P>				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
</P><P>				return type[ value ];
</P><P>			}
</P><P>			var textures = {};
</P><P>			if ( json !== undefined ) {
</P><P>				for ( var i = 0, l = json.length; i &lt; l; i ++ ) {
</P><P>					var data = json[ i ];
</P><P>					if ( data.image === undefined ) {
</P><P>						console.warn( 'THREE.ObjectLoader: No &quot;image&quot; specified for', data.uuid );
</P><P>					}
</P><P>					if ( images[ data.image ] === undefined ) {
</P><P>						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
</P><P>					}
</P><P>					var texture;
</P><P>					if ( Array.isArray( images[ data.image ] ) ) {
</P><P>						texture = new CubeTexture( images[ data.image ] );
</P><P>					} else {
</P><P>						texture = new Texture( images[ data.image ] );
</P><P>					}
</P><P>					texture.needsUpdate = true;
</P><P>					texture.uuid = data.uuid;
</P><P>					if ( data.name !== undefined ) texture.name = data.name;
</P><P>					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );
</P><P>					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;
</P><P>					if ( data.wrap !== undefined ) {
</P><P>						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );
</P><P>					}
</P><P>					if ( data.format !== undefined ) texture.format = data.format;
</P><P>					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
</P><P>					if ( data.flipY !== undefined ) texture.flipY = data.flipY;
</P><P>					textures[ data.uuid ] = texture;
</P><P>				}
</P><P>			}
</P><P>			return textures;
</P><P>		},
</P><P>		parseObject: function ( data, geometries, materials ) {
</P><P>			var object;
</P><P>			function getGeometry( name ) {
</P><P>				if ( geometries[ name ] === undefined ) {
</P><P>					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
</P><P>				}
</P><P>				return geometries[ name ];
</P><P>			}
</P><P>			function getMaterial( name ) {
</P><P>				if ( name === undefined ) return undefined;
</P><P>				if ( Array.isArray( name ) ) {
</P><P>					var array = [];
</P><P>					for ( var i = 0, l = name.length; i &lt; l; i ++ ) {
</P><P>						var uuid = name[ i ];
</P><P>						if ( materials[ uuid ] === undefined ) {
</P><P>							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );
</P><P>						}
</P><P>						array.push( materials[ uuid ] );
</P><P>					}
</P><P>					return array;
</P><P>				}
</P><P>				if ( materials[ name ] === undefined ) {
</P><P>					console.warn( 'THREE.ObjectLoader: Undefined material', name );
</P><P>				}
</P><P>				return materials[ name ];
</P><P>			}
</P><P>			switch ( data.type ) {
</P><P>				case 'Scene':
</P><P>					object = new Scene();
</P><P>					if ( data.background !== undefined ) {
</P><P>						if ( Number.isInteger( data.background ) ) {
</P><P>							object.background = new Color( data.background );
</P><P>						}
</P><P>					}
</P><P>					if ( data.fog !== undefined ) {
</P><P>						if ( data.fog.type === 'Fog' ) {
</P><P>							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );
</P><P>						} else if ( data.fog.type === 'FogExp2' ) {
</P><P>							object.fog = new FogExp2( data.fog.color, data.fog.density );
</P><P>						}
</P><P>					}
</P><P>					break;
</P><P>				case 'PerspectiveCamera':
</P><P>					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
</P><P>					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
</P><P>					break;
</P><P>				case 'OrthographicCamera':
</P><P>					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
</P><P>					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
</P><P>					break;
</P><P>				case 'AmbientLight':
</P><P>					object = new AmbientLight( data.color, data.intensity );
</P><P>					break;
</P><P>				case 'DirectionalLight':
</P><P>					object = new DirectionalLight( data.color, data.intensity );
</P><P>					break;
</P><P>				case 'PointLight':
</P><P>					object = new PointLight( data.color, data.intensity, data.distance, data.decay );
</P><P>					break;
</P><P>				case 'RectAreaLight':
</P><P>					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );
</P><P>					break;
</P><P>				case 'SpotLight':
</P><P>					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
</P><P>					break;
</P><P>				case 'HemisphereLight':
</P><P>					object = new HemisphereLight( data.color, data.groundColor, data.intensity );
</P><P>					break;
</P><P>				case 'SkinnedMesh':
</P><P>					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );
</P><P>				case 'Mesh':
</P><P>					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );
</P><P>					if ( geometry.bones &amp;&amp; geometry.bones.length &gt; 0 ) {
</P><P>						object = new SkinnedMesh( geometry, material );
</P><P>					} else {
</P><P>						object = new Mesh( geometry, material );
</P><P>					}
</P><P>					break;
</P><P>				case 'LOD':
</P><P>					object = new LOD();
</P><P>					break;
</P><P>				case 'Line':
</P><P>					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
</P><P>					break;
</P><P>				case 'LineLoop':
</P><P>					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );
</P><P>					break;
</P><P>				case 'LineSegments':
</P><P>					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );
</P><P>					break;
</P><P>				case 'PointCloud':
				case 'Points':
</P><P>					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );
</P><P>					break;
</P><P>				case 'Sprite':
</P><P>					object = new Sprite( getMaterial( data.material ) );
</P><P>					break;
</P><P>				case 'Group':
</P><P>					object = new Group();
</P><P>					break;
</P><P>				default:
</P><P>					object = new Object3D();
</P><P>			}
</P><P>			object.uuid = data.uuid;
</P><P>			if ( data.name !== undefined ) object.name = data.name;
</P><P>			if ( data.matrix !== undefined ) {
</P><P>				object.matrix.fromArray( data.matrix );
</P><P>				if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );
</P><P>			} else {
</P><P>				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
</P><P>			}
</P><P>			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
</P><P>			if ( data.shadow ) {
</P><P>				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );
</P><P>			}
</P><P>			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
			if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
			if ( data.userData !== undefined ) object.userData = data.userData;
			if ( data.layers !== undefined ) object.layers.mask = data.layers;
</P><P>			if ( data.children !== undefined ) {
</P><P>				var children = data.children;
</P><P>				for ( var i = 0; i &lt; children.length; i ++ ) {
</P><P>					object.add( this.parseObject( children[ i ], geometries, materials ) );
</P><P>				}
</P><P>			}
</P><P>			if ( data.type === 'LOD' ) {
</P><P>				var levels = data.levels;
</P><P>				for ( var l = 0; l &lt; levels.length; l ++ ) {
</P><P>					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );
</P><P>					if ( child !== undefined ) {
</P><P>						object.addLevel( child, level.distance );
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			return object;
</P><P>		}
</P><P>	} );
</P><P>	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		SphericalReflectionMapping: SphericalReflectionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};
</P><P>	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};
</P><P>	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter
	};
</P><P>	/**
	 * @author thespite / <A rel="nofollow" class="external free" href="http://clicktorelease.com/">http://clicktorelease.com/</A>
	 */
</P><P>
	function ImageBitmapLoader( manager ) {
</P><P>		if ( typeof createImageBitmap === 'undefined' ) {
</P><P>			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );
</P><P>		}
</P><P>		if ( typeof fetch === 'undefined' ) {
</P><P>			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );
</P><P>		}
</P><P>		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.options = undefined;
</P><P>	}
</P><P>	ImageBitmapLoader.prototype = {
</P><P>		constructor: ImageBitmapLoader,
</P><P>		setOptions: function setOptions( options ) {
</P><P>			this.options = options;
</P><P>			return this;
</P><P>		},
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			if ( url === undefined ) url = <I>;</I></P><P>			if ( this.path !== undefined ) url = this.path + url;
</P><P>			url = this.manager.resolveURL( url );
</P><P>			var scope = this;
</P><P>			var cached = Cache.get( url );
</P><P>			if ( cached !== undefined ) {
</P><P>				scope.manager.itemStart( url );
</P><P>				setTimeout( function () {
</P><P>					if ( onLoad ) onLoad( cached );
</P><P>					scope.manager.itemEnd( url );
</P><P>				}, 0 );
</P><P>				return cached;
</P><P>			}
</P><P>			fetch( url ).then( function ( res ) {
</P><P>				return res.blob();
</P><P>			} ).then( function ( blob ) {
</P><P>				return createImageBitmap( blob, scope.options );
</P><P>			} ).then( function ( imageBitmap ) {
</P><P>				Cache.add( url, imageBitmap );
</P><P>				if ( onLoad ) onLoad( imageBitmap );
</P><P>				scope.manager.itemEnd( url );
</P><P>			} ).catch( function ( e ) {
</P><P>				if ( onError ) onError( e );
</P><P>				scope.manager.itemEnd( url );
				scope.manager.itemError( url );
</P><P>			} );
</P><P>		},
</P><P>		setCrossOrigin: function ( /* value */ ) {
</P><P>			return this;
</P><P>		},
</P><P>		setPath: function ( value ) {
</P><P>			this.path = value;
			return this;
</P><P>		}
</P><P>	};
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 * minimal class for proxing functions to Path. Replaces old &quot;extractSubpaths()&quot;
	 **/
</P><P>	function ShapePath() {
</P><P>		this.type = 'ShapePath';
</P><P>		this.color = new Color();
</P><P>		this.subPaths = [];
		this.currentPath = null;
</P><P>	}
</P><P>	Object.assign( ShapePath.prototype, {
</P><P>		moveTo: function ( x, y ) {
</P><P>			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );
</P><P>		},
</P><P>		lineTo: function ( x, y ) {
</P><P>			this.currentPath.lineTo( x, y );
</P><P>		},
</P><P>		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
</P><P>			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
</P><P>		},
</P><P>		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
</P><P>			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
</P><P>		},
</P><P>		splineThru: function ( pts ) {
</P><P>			this.currentPath.splineThru( pts );
</P><P>		},
</P><P>		toShapes: function ( isCCW, noHoles ) {
</P><P>			function toShapesNoHoles( inSubpaths ) {
</P><P>				var shapes = [];
</P><P>				for ( var i = 0, l = inSubpaths.length; i &lt; l; i ++ ) {
</P><P>					var tmpPath = inSubpaths[ i ];
</P><P>					var tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
</P><P>					shapes.push( tmpShape );
</P><P>				}
</P><P>				return shapes;
</P><P>			}
</P><P>			function isPointInsidePolygon( inPt, inPolygon ) {
</P><P>				var polyLen = inPolygon.length;
</P><P>				// inPt on polygon contour =&gt; immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q &lt; polyLen; p = q ++ ) {
</P><P>					var edgeLowPt = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];
</P><P>					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;
</P><P>					if ( Math.abs( edgeDy ) &gt; Number.EPSILON ) {
</P><P>						// not parallel
						if ( edgeDy &lt; 0 ) {
</P><P>							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
</P><P>						}
						if ( ( inPt.y &lt; edgeLowPt.y ) || ( inPt.y &gt; edgeHighPt.y ) ) 		continue;
</P><P>						if ( inPt.y === edgeLowPt.y ) {
</P><P>							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt =&gt; doesn't count !!!
</P><P>						} else {
</P><P>							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge &lt; 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt
</P><P>						}
</P><P>					} else {
</P><P>						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x &lt;= inPt.x ) &amp;&amp; ( inPt.x &lt;= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x &lt;= inPt.x ) &amp;&amp; ( inPt.x &lt;= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;
</P><P>					}
</P><P>				}
</P><P>				return	inside;
</P><P>			}
</P><P>			var isClockWise = ShapeUtils.isClockWise;
</P><P>			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];
</P><P>			if ( noHoles === true )	return	toShapesNoHoles( subPaths );
</P><P>
			var solid, tmpPath, tmpShape, shapes = [];
</P><P>			if ( subPaths.length === 1 ) {
</P><P>				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;
</P><P>			}
</P><P>			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;
</P><P>			// console.log(&quot;Holes first&quot;, holesFirst);
</P><P>			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;
</P><P>			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];
</P><P>			for ( var i = 0, l = subPaths.length; i &lt; l; i ++ ) {
</P><P>				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;
</P><P>				if ( solid ) {
</P><P>					if ( ( ! holesFirst ) &amp;&amp; ( newShapes[ mainIdx ] ) )	mainIdx ++;
</P><P>					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;
</P><P>					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];
</P><P>					//console.log('cw', i);
</P><P>				} else {
</P><P>					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
</P><P>					//console.log('ccw', i);
</P><P>				}
</P><P>			}
</P><P>			// only Holes? -&gt; probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
</P><P>
			if ( newShapes.length &gt; 1 ) {
</P><P>				var ambiguous = false;
				var toChange = [];
</P><P>				for ( var sIdx = 0, sLen = newShapes.length; sIdx &lt; sLen; sIdx ++ ) {
</P><P>					betterShapeHoles[ sIdx ] = [];
</P><P>				}
</P><P>				for ( var sIdx = 0, sLen = newShapes.length; sIdx &lt; sLen; sIdx ++ ) {
</P><P>					var sho = newShapeHoles[ sIdx ];
</P><P>					for ( var hIdx = 0; hIdx &lt; sho.length; hIdx ++ ) {
</P><P>						var ho = sho[ hIdx ];
						var hole_unassigned = true;
</P><P>						for ( var s2Idx = 0; s2Idx &lt; newShapes.length; s2Idx ++ ) {
</P><P>							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
</P><P>								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {
</P><P>									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );
</P><P>								} else {
</P><P>									ambiguous = true;
</P><P>								}
</P><P>							}
</P><P>						}
						if ( hole_unassigned ) {
</P><P>							betterShapeHoles[ sIdx ].push( ho );
</P><P>						}
</P><P>					}
</P><P>				}
				// console.log(&quot;ambiguous: &quot;, ambiguous);
				if ( toChange.length &gt; 0 ) {
</P><P>					// console.log(&quot;to change: &quot;, toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
</P><P>				}
</P><P>			}
</P><P>			var tmpHoles;
</P><P>			for ( var i = 0, il = newShapes.length; i &lt; il; i ++ ) {
</P><P>				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];
</P><P>				for ( var j = 0, jl = tmpHoles.length; j &lt; jl; j ++ ) {
</P><P>					tmpShape.holes.push( tmpHoles[ j ].h );
</P><P>				}
</P><P>			}
</P><P>			//console.log(&quot;shape&quot;, shapes);
</P><P>			return shapes;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://www.lab4games.net/zz85/blog">http://www.lab4games.net/zz85/blog</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>
	function Font( data ) {
</P><P>		this.type = 'Font';
</P><P>		this.data = data;
</P><P>	}
</P><P>	Object.assign( Font.prototype, {
</P><P>		isFont: true,
</P><P>		generateShapes: function ( text, size ) {
</P><P>			if ( size === undefined ) size = 100;
</P><P>			var shapes = [];
			var paths = createPaths( text, size, this.data );
</P><P>			for ( var p = 0, pl = paths.length; p &lt; pl; p ++ ) {
</P><P>				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
</P><P>			}
</P><P>			return shapes;
</P><P>		}
</P><P>	} );
</P><P>	function createPaths( text, size, data ) {
</P><P>		var chars = Array.from ? Array.from( text ) : String( text ).split( <I> ); // see #13988</I>
		var scale = size / data.resolution;
		var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;
</P><P>		var paths = [];
</P><P>		var offsetX = 0, offsetY = 0;
</P><P>		for ( var i = 0; i &lt; chars.length; i ++ ) {
</P><P>			var char = chars[ i ];
</P><P>			if ( char === '\n' ) {
</P><P>				offsetX = 0;
				offsetY -= line_height;
</P><P>			} else {
</P><P>				var ret = createPath( char, scale, offsetX, offsetY, data );
				offsetX += ret.offsetX;
				paths.push( ret.path );
</P><P>			}
</P><P>		}
</P><P>		return paths;
</P><P>	}
</P><P>	function createPath( char, scale, offsetX, offsetY, data ) {
</P><P>		var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];
</P><P>		if ( ! glyph ) return;
</P><P>		var path = new ShapePath();
</P><P>		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
</P><P>		if ( glyph.o ) {
</P><P>			var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
</P><P>			for ( var i = 0, l = outline.length; i &lt; l; ) {
</P><P>				var action = outline[ i ++ ];
</P><P>				switch ( action ) {
</P><P>					case 'm': // moveTo
</P><P>						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;
</P><P>						path.moveTo( x, y );
</P><P>						break;
</P><P>					case 'l': // lineTo
</P><P>						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;
</P><P>						path.lineTo( x, y );
</P><P>						break;
</P><P>					case 'q': // quadraticCurveTo
</P><P>						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
</P><P>						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
</P><P>						break;
</P><P>					case 'b': // bezierCurveTo
</P><P>						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
						cpx2 = outline[ i ++ ] * scale + offsetX;
						cpy2 = outline[ i ++ ] * scale + offsetY;
</P><P>						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
</P><P>						break;
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		return { offsetX: glyph.ha * scale, path: path };
</P><P>	}
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function FontLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>	}
</P><P>	Object.assign( FontLoader.prototype, {
</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			var scope = this;
</P><P>			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {
</P><P>				var json;
</P><P>				try {
</P><P>					json = JSON.parse( text );
</P><P>				} catch ( e ) {
</P><P>					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse( text.substring( 65, text.length - 2 ) );
</P><P>				}
</P><P>				var font = scope.parse( json );
</P><P>				if ( onLoad ) onLoad( font );
</P><P>			}, onProgress, onError );
</P><P>		},
</P><P>		parse: function ( json ) {
</P><P>			return new Font( json );
</P><P>		},
</P><P>		setPath: function ( value ) {
</P><P>			this.path = value;
			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	var context;
</P><P>	var AudioContext = {
</P><P>		getContext: function () {
</P><P>			if ( context === undefined ) {
</P><P>				context = new ( window.AudioContext || window.webkitAudioContext )();
</P><P>			}
</P><P>			return context;
</P><P>		},
</P><P>		setContext: function ( value ) {
</P><P>			context = value;
</P><P>		}
</P><P>	};
</P><P>	/**
	 * @author Reece Aaron Lecrivain / <A rel="nofollow" class="external free" href="http://reecenotes.com/">http://reecenotes.com/</A>
	 */
</P><P>	function AudioLoader( manager ) {
</P><P>		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
</P><P>	}
</P><P>	Object.assign( AudioLoader.prototype, {</P><P>		load: function ( url, onLoad, onProgress, onError ) {
</P><P>			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.load( url, function ( buffer ) {
</P><P>				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				var bufferCopy = buffer.slice( 0 );
</P><P>				var context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {
</P><P>					onLoad( audioBuffer );
</P><P>				} );
</P><P>			}, onProgress, onError );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function StereoCamera() {
</P><P>		this.type = 'StereoCamera';
</P><P>		this.aspect = 1;
</P><P>		this.eyeSep = 0.064;
</P><P>		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;
</P><P>		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;
</P><P>	}
</P><P>	Object.assign( StereoCamera.prototype, {
</P><P>		update: ( function () {
</P><P>			var instance, focus, fov, aspect, near, far, zoom, eyeSep;
</P><P>			var eyeRight = new Matrix4();
			var eyeLeft = new Matrix4();
</P><P>			return function update( camera ) {
</P><P>				var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
</P><P>				if ( needsUpdate ) {
</P><P>					instance = this;
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
					zoom = camera.zoom;
</P><P>					// Off-axis stereoscopic effect based on
					// <A rel="nofollow" class="external free" href="http://paulbourke.net/stereographics/stereorender/">http://paulbourke.net/stereographics/stereorender/</A></P><P>					var projectionMatrix = camera.projectionMatrix.clone();
					eyeSep = this.eyeSep / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
					var xmin, xmax;
</P><P>					// translate xOffset
</P><P>					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;
</P><P>					// for left eye
</P><P>					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;
</P><P>					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
</P><P>					this.cameraL.projectionMatrix.copy( projectionMatrix );
</P><P>					// for right eye
</P><P>					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;
</P><P>					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
</P><P>					this.cameraR.projectionMatrix.copy( projectionMatrix );
</P><P>				}
</P><P>				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
</P><P>			};
</P><P>		} )()
</P><P>	} );
</P><P>	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function CubeCamera( near, far, cubeResolution ) {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'CubeCamera';
</P><P>		var fov = 90, aspect = 1;
</P><P>		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );
</P><P>		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );
</P><P>		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );
</P><P>		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );
</P><P>		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );
</P><P>		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );
</P><P>		var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
</P><P>		this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
		this.renderTarget.texture.name = &quot;CubeCamera&quot;;
</P><P>		this.update = function ( renderer, scene ) {
</P><P>			if ( this.parent === null ) this.updateMatrixWorld();
</P><P>			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;
</P><P>			renderTarget.texture.generateMipmaps = false;
</P><P>			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );
</P><P>			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );
</P><P>			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );
</P><P>			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );
</P><P>			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );
</P><P>			renderTarget.texture.generateMipmaps = generateMipmaps;
</P><P>			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );
</P><P>			renderer.setRenderTarget( null );
</P><P>		};
</P><P>		this.clear = function ( renderer, color, depth, stencil ) {
</P><P>			var renderTarget = this.renderTarget;
</P><P>			for ( var i = 0; i &lt; 6; i ++ ) {
</P><P>				renderTarget.activeCubeFace = i;
				renderer.setRenderTarget( renderTarget );
</P><P>				renderer.clear( color, depth, stencil );
</P><P>			}
</P><P>			renderer.setRenderTarget( null );
</P><P>		};
</P><P>	}
</P><P>	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function AudioListener() {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'AudioListener';
</P><P>		this.context = AudioContext.getContext();
</P><P>		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );
</P><P>		this.filter = null;
</P><P>	}
</P><P>	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: AudioListener,
</P><P>		getInput: function () {
</P><P>			return this.gain;
</P><P>		},
</P><P>		removeFilter: function ( ) {
</P><P>			if ( this.filter !== null ) {
</P><P>				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		getFilter: function () {
</P><P>			return this.filter;
</P><P>		},
</P><P>		setFilter: function ( value ) {
</P><P>			if ( this.filter !== null ) {
</P><P>				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
</P><P>			} else {
</P><P>				this.gain.disconnect( this.context.destination );
</P><P>			}
</P><P>			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );
</P><P>			return this;
</P><P>		},
</P><P>		getMasterVolume: function () {
</P><P>			return this.gain.gain.value;
</P><P>		},
</P><P>		setMasterVolume: function ( value ) {
</P><P>			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );
</P><P>			return this;
</P><P>		},
</P><P>		updateMatrixWorld: ( function () {
</P><P>			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();
</P><P>			var orientation = new Vector3();
</P><P>			return function updateMatrixWorld( force ) {
</P><P>				Object3D.prototype.updateMatrixWorld.call( this, force );
</P><P>				var listener = this.context.listener;
				var up = this.up;
</P><P>				this.matrixWorld.decompose( position, quaternion, scale );
</P><P>				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
</P><P>				if ( listener.positionX ) {
</P><P>					listener.positionX.setValueAtTime( position.x, this.context.currentTime );
					listener.positionY.setValueAtTime( position.y, this.context.currentTime );
					listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
					listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
					listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
					listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
					listener.upX.setValueAtTime( up.x, this.context.currentTime );
					listener.upY.setValueAtTime( up.y, this.context.currentTime );
					listener.upZ.setValueAtTime( up.z, this.context.currentTime );
</P><P>				} else {
</P><P>					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
</P><P>				}
</P><P>			};
</P><P>		} )()
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author Reece Aaron Lecrivain / <A rel="nofollow" class="external free" href="http://reecenotes.com/">http://reecenotes.com/</A>
	 */
</P><P>	function Audio( listener ) {
</P><P>		Object3D.call( this );
</P><P>		this.type = 'Audio';
</P><P>		this.context = listener.context;
</P><P>		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );
</P><P>		this.autoplay = false;
</P><P>		this.buffer = null;
		this.loop = false;
		this.startTime = 0;
		this.offset = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';
</P><P>		this.filters = [];
</P><P>	}
</P><P>	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {
</P><P>		constructor: Audio,
</P><P>		getOutput: function () {
</P><P>			return this.gain;
</P><P>		},
</P><P>		setNodeSource: function ( audioNode ) {
</P><P>			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
</P><P>			return this;
</P><P>		},
</P><P>		setMediaElementSource: function ( mediaElement ) {
</P><P>			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();
</P><P>			return this;
</P><P>		},
</P><P>		setBuffer: function ( audioBuffer ) {
</P><P>			this.buffer = audioBuffer;
			this.sourceType = 'buffer';
</P><P>			if ( this.autoplay ) this.play();
</P><P>			return this;
</P><P>		},
</P><P>		play: function () {
</P><P>			if ( this.isPlaying === true ) {
</P><P>				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;
</P><P>			}
</P><P>			if ( this.hasPlaybackControl === false ) {
</P><P>				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
</P><P>			}
</P><P>			var source = this.context.createBufferSource();
</P><P>			source.buffer = this.buffer;
			source.loop = this.loop;
			source.onended = this.onEnded.bind( this );
			source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
			this.startTime = this.context.currentTime;
			source.start( this.startTime, this.offset );
</P><P>			this.isPlaying = true;
</P><P>			this.source = source;
</P><P>			return this.connect();
</P><P>		},
</P><P>		pause: function () {
</P><P>			if ( this.hasPlaybackControl === false ) {
</P><P>				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
</P><P>			}
</P><P>			if ( this.isPlaying === true ) {
</P><P>				this.source.stop();
				this.source.onended = null;
				this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
				this.isPlaying = false;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		stop: function () {
</P><P>			if ( this.hasPlaybackControl === false ) {
</P><P>				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
</P><P>			}
</P><P>			this.source.stop();
			this.source.onended = null;
			this.offset = 0;
			this.isPlaying = false;
</P><P>			return this;
</P><P>		},
</P><P>		connect: function () {
</P><P>			if ( this.filters.length &gt; 0 ) {
</P><P>				this.source.connect( this.filters[ 0 ] );
</P><P>				for ( var i = 1, l = this.filters.length; i &lt; l; i ++ ) {
</P><P>					this.filters[ i - 1 ].connect( this.filters[ i ] );
</P><P>				}
</P><P>				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );
</P><P>			} else {
</P><P>				this.source.connect( this.getOutput() );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		disconnect: function () {
</P><P>			if ( this.filters.length &gt; 0 ) {
</P><P>				this.source.disconnect( this.filters[ 0 ] );
</P><P>				for ( var i = 1, l = this.filters.length; i &lt; l; i ++ ) {
</P><P>					this.filters[ i - 1 ].disconnect( this.filters[ i ] );
</P><P>				}
</P><P>				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );
</P><P>			} else {
</P><P>				this.source.disconnect( this.getOutput() );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		getFilters: function () {
</P><P>			return this.filters;
</P><P>		},
</P><P>		setFilters: function ( value ) {
</P><P>			if ( ! value ) value = [];
</P><P>			if ( this.isPlaying === true ) {
</P><P>				this.disconnect();
				this.filters = value;
				this.connect();
</P><P>			} else {
</P><P>				this.filters = value;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		getFilter: function () {
</P><P>	return this.getFilters()[ 0 ];
</P><P>		},
</P><P>		setFilter: function ( filter ) {
</P><P>			return this.setFilters( filter ? [ filter ] : [] );
</P><P>		},
</P><P>		setPlaybackRate: function ( value ) {
</P><P>			if ( this.hasPlaybackControl === false ) {
</P><P>				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
</P><P>			}
</P><P>			this.playbackRate = value;
</P><P>			if ( this.isPlaying === true ) {
</P><P>				this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		getPlaybackRate: function () {
</P><P>			return this.playbackRate;
</P><P>		},
</P><P>		onEnded: function () {
</P><P>			this.isPlaying = false;
</P><P>		},
</P><P>		getLoop: function () {
</P><P>			if ( this.hasPlaybackControl === false ) {
</P><P>				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;
</P><P>			}
</P><P>			return this.loop;
</P><P>		},
</P><P>		setLoop: function ( value ) {
</P><P>			if ( this.hasPlaybackControl === false ) {
</P><P>				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
</P><P>			}
</P><P>			this.loop = value;
</P><P>			if ( this.isPlaying === true ) {
</P><P>				this.source.loop = this.loop;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		getVolume: function () {
</P><P>			return this.gain.gain.value;
</P><P>		},
</P><P>		setVolume: function ( value ) {
</P><P>			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function PositionalAudio( listener ) {
</P><P>		Audio.call( this, listener );
</P><P>		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );
</P><P>	}
</P><P>	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {
</P><P>		constructor: PositionalAudio,
</P><P>		getOutput: function () {
</P><P>			return this.panner;
</P><P>		},
</P><P>		getRefDistance: function () {
</P><P>			return this.panner.refDistance;
</P><P>		},
</P><P>		setRefDistance: function ( value ) {
</P><P>			this.panner.refDistance = value;
</P><P>			return this;
</P><P>		},
</P><P>		getRolloffFactor: function () {
</P><P>			return this.panner.rolloffFactor;
</P><P>		},
</P><P>		setRolloffFactor: function ( value ) {
</P><P>			this.panner.rolloffFactor = value;
</P><P>			return this;
</P><P>		},
</P><P>		getDistanceModel: function () {
</P><P>			return this.panner.distanceModel;
</P><P>		},
</P><P>		setDistanceModel: function ( value ) {
</P><P>			this.panner.distanceModel = value;
</P><P>			return this;
</P><P>		},
</P><P>		getMaxDistance: function () {
</P><P>			return this.panner.maxDistance;
</P><P>		},
</P><P>		setMaxDistance: function ( value ) {
</P><P>			this.panner.maxDistance = value;
</P><P>			return this;
</P><P>		},
</P><P>		setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {
</P><P>			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;
</P><P>			return this;
</P><P>		},
</P><P>		updateMatrixWorld: ( function () {
</P><P>			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();
</P><P>			var orientation = new Vector3();
</P><P>			return function updateMatrixWorld( force ) {
</P><P>				Object3D.prototype.updateMatrixWorld.call( this, force );
</P><P>				var panner = this.panner;
				this.matrixWorld.decompose( position, quaternion, scale );
</P><P>				orientation.set( 0, 0, 1 ).applyQuaternion( quaternion );
</P><P>				panner.setPosition( position.x, position.y, position.z );
				panner.setOrientation( orientation.x, orientation.y, orientation.z );
</P><P>			};
</P><P>		} )()
</P><P>
	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function AudioAnalyser( audio, fftSize ) {
</P><P>		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
</P><P>		this.data = new Uint8Array( this.analyser.frequencyBinCount );
</P><P>		audio.getOutput().connect( this.analyser );
</P><P>	}
</P><P>	Object.assign( AudioAnalyser.prototype, {
</P><P>		getFrequencyData: function () {
</P><P>			this.analyser.getByteFrequencyData( this.data );
</P><P>			return this.data;
</P><P>		},
</P><P>		getAverageFrequency: function () {
</P><P>			var value = 0, data = this.getFrequencyData();
</P><P>			for ( var i = 0; i &lt; data.length; i ++ ) {
</P><P>				value += data[ i ];
</P><P>			}
</P><P>			return value / data.length;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	function PropertyMixer( binding, typeName, valueSize ) {
</P><P>		this.binding = binding;
		this.valueSize = valueSize;
</P><P>		var bufferType = Float64Array,
			mixFunction;
</P><P>		switch ( typeName ) {
</P><P>			case 'quaternion':
				mixFunction = this._slerp;
				break;
</P><P>			case 'string':
			case 'bool':
				bufferType = Array;
				mixFunction = this._select;
				break;
</P><P>			default:
				mixFunction = this._lerp;
</P><P>		}
</P><P>		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
</P><P>		this._mixBufferRegion = mixFunction;
</P><P>		this.cumulativeWeight = 0;
</P><P>		this.useCount = 0;
		this.referenceCount = 0;
</P><P>	}
</P><P>	Object.assign( PropertyMixer.prototype, {
</P><P>		// accumulate data in the 'incoming' region into 'accu<I>'
		accumulate: function ( accuIndex, weight ) {
</I></P><P>			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
</P><P>			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,
</P><P>				currentWeight = this.cumulativeWeight;
</P><P>			if ( currentWeight === 0 ) {
</P><P>				// accuN := incoming * weight
</P><P>				for ( var i = 0; i !== stride; ++ i ) {
</P><P>					buffer[ offset + i ] = buffer[ i ];
</P><P>				}
</P><P>				currentWeight = weight;
</P><P>			} else {
</P><P>				// accuN := accuN + incoming * weight
</P><P>				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );
</P><P>			}
</P><P>			this.cumulativeWeight = currentWeight;
</P><P>		},
</P><P>		// apply the state of 'accu&lt;i&gt;' to the binding when accus differ
		apply: function ( accuIndex ) {
</P><P>			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,
</P><P>				weight = this.cumulativeWeight,
</P><P>				binding = this.binding;
</P><P>			this.cumulativeWeight = 0;
</P><P>			if ( weight &lt; 1 ) {
</P><P>				// accuN := accuN + original * ( 1 - cumulativeWeight )
</P><P>				var originalValueOffset = stride * 3;
</P><P>				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );
</P><P>			}
</P><P>			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
</P><P>				if ( buffer[ i ] !== buffer[ i + stride ] ) {
</P><P>					// value has changed -&gt; update scene graph
</P><P>					binding.setValue( buffer, offset );
					break;
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function () {
</P><P>			var binding = this.binding;
</P><P>			var buffer = this.buffer,
				stride = this.valueSize,
</P><P>				originalValueOffset = stride * 3;
</P><P>			binding.getValue( buffer, originalValueOffset );
</P><P>			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
</P><P>				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
</P><P>			}
</P><P>			this.cumulativeWeight = 0;
</P><P>		},
</P><P>		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function () {
</P><P>			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );
</P><P>		},
</P><P>
		// mix functions
</P><P>		_select: function ( buffer, dstOffset, srcOffset, t, stride ) {
</P><P>			if ( t &gt;= 0.5 ) {
</P><P>				for ( var i = 0; i !== stride; ++ i ) {
</P><P>					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		_slerp: function ( buffer, dstOffset, srcOffset, t ) {
</P><P>			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );
</P><P>		},
</P><P>		_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {
</P><P>			var s = 1 - t;
</P><P>			for ( var i = 0; i !== stride; ++ i ) {
</P><P>				var j = dstOffset + i;
</P><P>				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	// Characters [].:/ are reserved for track binding syntax.
	var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
</P><P>	function Composite( targetGroup, path, optionalParsedPath ) {
</P><P>		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );
</P><P>		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );
</P><P>	}
</P><P>	Object.assign( Composite.prototype, {
</P><P>		getValue: function ( array, offset ) {
</P><P>			this.bind(); // bind all binding
</P><P>			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];
</P><P>			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );
</P><P>		},
</P><P>		setValue: function ( array, offset ) {
</P><P>			var bindings = this._bindings;
</P><P>			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {
</P><P>				bindings[ i ].setValue( array, offset );
</P><P>			}
</P><P>		},
</P><P>		bind: function () {
</P><P>			var bindings = this._bindings;
</P><P>			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {
</P><P>				bindings[ i ].bind();
</P><P>			}
</P><P>		},
</P><P>		unbind: function () {
</P><P>			var bindings = this._bindings;
</P><P>			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {
</P><P>				bindings[ i ].unbind();
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>
	function PropertyBinding( rootNode, path, parsedPath ) {
</P><P>		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );
</P><P>		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;
</P><P>		this.rootNode = rootNode;
</P><P>	}
</P><P>	Object.assign( PropertyBinding, {
</P><P>		Composite: Composite,
</P><P>		create: function ( root, path, parsedPath ) {
</P><P>			if ( ! ( root &amp;&amp; root.isAnimationObjectGroup ) ) {
</P><P>				return new PropertyBinding( root, path, parsedPath );
</P><P>			} else {
</P><P>				return new PropertyBinding.Composite( root, path, parsedPath );
</P><P>			}
</P><P>		},
</P><P>		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: ( function () {
</P><P>			var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );
</P><P>			return function sanitizeNodeName( name ) {
</P><P>				return name.replace( /\s/g, '_' ).replace( reservedRe, <I> );</I></P><P>			};
</P><P>		}() ),
</P><P>		parseTrackName: function () {
</P><P>			// Attempts to allow node names from any language. ES5's `\w` regexp matches
			// only latin characters, and the unicode \p{L} is not yet supported. So
			// instead, we exclude reserved characters and match everything else.
			var wordChar = '[^' + RESERVED_CHARS_RE + ']';
			var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\.', <I> ) + ']';</I></P><P>			// Parent directories, delimited by '/' or ':'. Currently unused, but must
			// be matched to parse the rest of the track name.
			var directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', wordChar );
</P><P>			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
			var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );
</P><P>			// Object on target node, and accessor. May not contain reserved
			// characters. Accessor may contain any character except closing bracket.
			var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', wordChar );
</P><P>			// Property and accessor. May not contain reserved characters. Accessor may
			// contain any non-bracket characters.
			var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', wordChar );
</P><P>			var trackRe = new RegExp( 
				+ '^'
				+ directoryRe
				+ nodeRe
				+ objectRe
				+ propertyRe
				+ '$'
			);
</P><P>			var supportedObjectNames = [ 'material', 'materials', 'bones' ];
</P><P>			return function parseTrackName( trackName ) {
</P><P>				var matches = trackRe.exec( trackName );
</P><P>				if ( ! matches ) {
</P><P>					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );
</P><P>				}
</P><P>				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ], // required
					propertyIndex: matches[ 6 ]
				};
</P><P>				var lastDot = results.nodeName &amp;&amp; results.nodeName.lastIndexOf( '.' );
</P><P>				if ( lastDot !== undefined &amp;&amp; lastDot !== - 1 ) {
</P><P>					var objectName = results.nodeName.substring( lastDot + 1 );
</P><P>					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {
</P><P>						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;
</P><P>					}
</P><P>				}
</P><P>				if ( results.propertyName === null || results.propertyName.length === 0 ) {
</P><P>					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );
</P><P>				}
</P><P>				return results;
</P><P>			};
</P><P>		}(),
</P><P>		findNode: function ( root, nodeName ) {
</P><P>			if ( ! nodeName || nodeName === &quot;&quot; || nodeName === &quot;root&quot; || nodeName === &quot;.&quot; || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {
</P><P>				return root;
</P><P>			}
</P><P>			// search into skeleton bones.
			if ( root.skeleton ) {
</P><P>				var bone = root.skeleton.getBoneByName( nodeName );
</P><P>				if ( bone !== undefined ) {
</P><P>					return bone;
</P><P>				}
</P><P>			}
</P><P>			// search into node subtree.
			if ( root.children ) {
</P><P>				var searchNodeSubtree = function ( children ) {
</P><P>					for ( var i = 0; i &lt; children.length; i ++ ) {
</P><P>						var childNode = children[ i ];
</P><P>						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
</P><P>							return childNode;
</P><P>						}
</P><P>						var result = searchNodeSubtree( childNode.children );
</P><P>						if ( result ) return result;
</P><P>					}
</P><P>					return null;
</P><P>				};
</P><P>				var subTreeNode = searchNodeSubtree( root.children );
</P><P>				if ( subTreeNode ) {
</P><P>					return subTreeNode;
</P><P>				}
</P><P>			}
</P><P>			return null;
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( PropertyBinding.prototype, { // prototype, continued
</P><P>		// these are used to &quot;bind&quot; a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},
</P><P>		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},
</P><P>		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},
</P><P>		GetterByBindingType: [
</P><P>			function getValue_direct( buffer, offset ) {
</P><P>				buffer[ offset ] = this.node[ this.propertyName ];
</P><P>			},
</P><P>			function getValue_array( buffer, offset ) {
</P><P>				var source = this.resolvedProperty;
</P><P>				for ( var i = 0, n = source.length; i !== n; ++ i ) {
</P><P>					buffer[ offset ++ ] = source[ i ];
</P><P>				}
</P><P>			},
</P><P>			function getValue_arrayElement( buffer, offset ) {
</P><P>				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
</P><P>			},
</P><P>			function getValue_toArray( buffer, offset ) {
</P><P>				this.resolvedProperty.toArray( buffer, offset );
</P><P>			}
</P><P>		],
</P><P>		SetterByBindingTypeAndVersioning: [
</P><P>			[
				// Direct
</P><P>				function setValue_direct( buffer, offset ) {
</P><P>					this.targetObject[ this.propertyName ] = buffer[ offset ];
</P><P>				},
</P><P>				function setValue_direct_setNeedsUpdate( buffer, offset ) {
</P><P>					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
</P><P>				},
</P><P>				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
</P><P>					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
</P><P>				}
</P><P>			], [
</P><P>				// EntireArray
</P><P>				function setValue_array( buffer, offset ) {
</P><P>					var dest = this.resolvedProperty;
</P><P>					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
</P><P>						dest[ i ] = buffer[ offset ++ ];
</P><P>					}
</P><P>				},
</P><P>				function setValue_array_setNeedsUpdate( buffer, offset ) {
</P><P>					var dest = this.resolvedProperty;
</P><P>					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
</P><P>						dest[ i ] = buffer[ offset ++ ];
</P><P>					}
</P><P>					this.targetObject.needsUpdate = true;
</P><P>				},
</P><P>				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
</P><P>					var dest = this.resolvedProperty;
</P><P>					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
</P><P>						dest[ i ] = buffer[ offset ++ ];
</P><P>					}
</P><P>					this.targetObject.matrixWorldNeedsUpdate = true;
</P><P>				}
</P><P>			], [
</P><P>				// ArrayElement
</P><P>				function setValue_arrayElement( buffer, offset ) {
</P><P>					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
</P><P>				},
</P><P>				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
</P><P>					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
</P><P>				},
</P><P>				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
</P><P>					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
</P><P>				}
</P><P>			], [
</P><P>				// HasToFromArray
</P><P>				function setValue_fromArray( buffer, offset ) {
</P><P>					this.resolvedProperty.fromArray( buffer, offset );
</P><P>				},
</P><P>				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
</P><P>					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;
</P><P>				},
</P><P>				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
</P><P>					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;
</P><P>				}
</P><P>			]
</P><P>		],
</P><P>		getValue: function getValue_unbound( targetArray, offset ) {
</P><P>			this.bind();
			this.getValue( targetArray, offset );
</P><P>			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.
</P><P>		},
</P><P>		setValue: function getValue_unbound( sourceArray, offset ) {
</P><P>			this.bind();
			this.setValue( sourceArray, offset );
</P><P>		},
</P><P>		// create getter / setter pair for a property in the scene graph
		bind: function () {
</P><P>			var targetObject = this.node,
				parsedPath = this.parsedPath,
</P><P>				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;
</P><P>			if ( ! targetObject ) {
</P><P>				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;
</P><P>				this.node = targetObject;
</P><P>			}
</P><P>			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;
</P><P>			// ensure there is a value node
			if ( ! targetObject ) {
</P><P>				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;
</P><P>			}
</P><P>			if ( objectName ) {
</P><P>				var objectIndex = parsedPath.objectIndex;
</P><P>				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {
</P><P>					case 'materials':
</P><P>						if ( ! targetObject.material ) {
</P><P>							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;
</P><P>						}
</P><P>						if ( ! targetObject.material.materials ) {
</P><P>							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;
</P><P>						}
</P><P>						targetObject = targetObject.material.materials;
</P><P>						break;
</P><P>					case 'bones':
</P><P>						if ( ! targetObject.skeleton ) {
</P><P>							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;
</P><P>						}
</P><P>						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.
</P><P>						targetObject = targetObject.skeleton.bones;
</P><P>						// support resolving morphTarget names into indices.
						for ( var i = 0; i &lt; targetObject.length; i ++ ) {
</P><P>							if ( targetObject[ i ].name === objectIndex ) {
</P><P>								objectIndex = i;
								break;
</P><P>							}
</P><P>						}
</P><P>						break;
</P><P>					default:
</P><P>						if ( targetObject[ objectName ] === undefined ) {
</P><P>							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;
</P><P>						}
</P><P>						targetObject = targetObject[ objectName ];
</P><P>				}
</P><P>
				if ( objectIndex !== undefined ) {
</P><P>					if ( targetObject[ objectIndex ] === undefined ) {
</P><P>						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;
</P><P>					}
</P><P>					targetObject = targetObject[ objectIndex ];
</P><P>				}
</P><P>			}
</P><P>			// resolve property
			var nodeProperty = targetObject[ propertyName ];
</P><P>			if ( nodeProperty === undefined ) {
</P><P>				var nodeName = parsedPath.nodeName;
</P><P>				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;
</P><P>			}
</P><P>			// determine versioning scheme
			var versioning = this.Versioning.None;
</P><P>			this.targetObject = targetObject;
</P><P>			if ( targetObject.needsUpdate !== undefined ) { // material
</P><P>				versioning = this.Versioning.NeedsUpdate;
</P><P>			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
</P><P>				versioning = this.Versioning.MatrixWorldNeedsUpdate;
</P><P>			}
</P><P>			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;
</P><P>			if ( propertyIndex !== undefined ) {
</P><P>				// access a sub element of the property array (only primitives are supported right now)
</P><P>				if ( propertyName === &quot;morphTargetInfluences&quot; ) {
</P><P>					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
</P><P>					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {
</P><P>						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;
</P><P>					}
</P><P>					if ( targetObject.geometry.isBufferGeometry ) {
</P><P>						if ( ! targetObject.geometry.morphAttributes ) {
</P><P>							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;
</P><P>						}
</P><P>						for ( var i = 0; i &lt; this.node.geometry.morphAttributes.position.length; i ++ ) {
</P><P>							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {
</P><P>								propertyIndex = i;
								break;
</P><P>							}
</P><P>						}
</P><P>
					} else {
</P><P>						if ( ! targetObject.geometry.morphTargets ) {
</P><P>							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
							return;
</P><P>						}
</P><P>						for ( var i = 0; i &lt; this.node.geometry.morphTargets.length; i ++ ) {
</P><P>							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {
</P><P>								propertyIndex = i;
								break;
</P><P>							}
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>				bindingType = this.BindingType.ArrayElement;
</P><P>				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
</P><P>			} else if ( nodeProperty.fromArray !== undefined &amp;&amp; nodeProperty.toArray !== undefined ) {
</P><P>				// must use copy for Object3D.Euler/Quaternion
</P><P>				bindingType = this.BindingType.HasFromToArray;
</P><P>				this.resolvedProperty = nodeProperty;
</P><P>			} else if ( Array.isArray( nodeProperty ) ) {
</P><P>				bindingType = this.BindingType.EntireArray;
</P><P>				this.resolvedProperty = nodeProperty;
</P><P>			} else {
</P><P>				this.propertyName = propertyName;
</P><P>			}
</P><P>			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
</P><P>		},
</P><P>		unbind: function () {
</P><P>			this.node = null;
</P><P>			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
</P><P>		}
</P><P>	} );
</P><P>	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( PropertyBinding.prototype, {
</P><P>		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,
</P><P>	} );
</P><P>	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */
</P><P>	function AnimationObjectGroup() {
</P><P>		this.uuid = _Math.generateUUID();
</P><P>		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );
</P><P>		this.nCachedObjects_ = 0;			// threshold
		// note: read by PropertyBinding.Composite
</P><P>		var indices = {};
		this._indicesByUUID = indices;		// for bookkeeping
</P><P>		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
</P><P>			indices[ arguments[ i ].uuid ] = i;
</P><P>		}
</P><P>		this._paths = [];					// inside: string
		this._parsedPaths = [];				// inside: { we don't care, here }
		this._bindings = []; 				// inside: Array&lt; PropertyBinding &gt;
		this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays
</P><P>		var scope = this;
</P><P>		this.stats = {
</P><P>			objects: {
				get total() {
</P><P>					return scope._objects.length;
</P><P>				},
				get inUse() {
</P><P>					return this.total - scope.nCachedObjects_;
</P><P>				}
			},
			get bindingsPerObject() {
</P><P>				return scope._bindings.length;
</P><P>			}
</P><P>		};
</P><P>	}
</P><P>	Object.assign( AnimationObjectGroup.prototype, {
</P><P>		isAnimationObjectGroup: true,
</P><P>		add: function () {
</P><P>			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length,
				knownObject = undefined;
</P><P>			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
</P><P>				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
</P><P>				if ( index === undefined ) {
</P><P>					// unknown object -&gt; add it to the ACTIVE region
</P><P>					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );
</P><P>					// accounting is done, now do the same for all bindings
</P><P>					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
</P><P>						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );
</P><P>					}
</P><P>				} else if ( index &lt; nCachedObjects ) {
</P><P>					knownObject = objects[ index ];
</P><P>					// move existing object to the ACTIVE region
</P><P>					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];
</P><P>					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;
</P><P>					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;
</P><P>					// accounting is done, now do the same for all bindings
</P><P>					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
</P><P>						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];
</P><P>						bindingsForPath[ index ] = lastCached;
</P><P>						if ( binding === undefined ) {
</P><P>							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
</P><P>							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );
</P><P>						}
</P><P>						bindingsForPath[ firstActiveIndex ] = binding;
</P><P>					}
</P><P>				} else if ( objects[ index ] !== knownObject ) {
</P><P>					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
							'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );
</P><P>				} // else the object is already where we want it to be
</P><P>			} // for arguments
</P><P>			this.nCachedObjects_ = nCachedObjects;
</P><P>		},
</P><P>		remove: function () {
</P><P>			var objects = this._objects,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
</P><P>			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
</P><P>				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
</P><P>				if ( index !== undefined &amp;&amp; index &gt;= nCachedObjects ) {
</P><P>					// move existing object into the CACHED region
</P><P>					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];
</P><P>					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;
</P><P>					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;
</P><P>					// accounting is done, now do the same for all bindings
</P><P>					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
</P><P>						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];
</P><P>						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;
</P><P>					}
</P><P>				}
</P><P>			} // for arguments
</P><P>			this.nCachedObjects_ = nCachedObjects;
</P><P>		},
</P><P>		// remove &amp; forget
		uncache: function () {
</P><P>			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
</P><P>			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
</P><P>				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
</P><P>				if ( index !== undefined ) {
</P><P>					delete indicesByUUID[ uuid ];
</P><P>					if ( index &lt; nCachedObjects ) {
</P><P>						// object is cached, shrink the CACHED region
</P><P>						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
</P><P>						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;
</P><P>						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();
</P><P>						// accounting is done, now do the same for all bindings
</P><P>						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
</P><P>							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];
</P><P>							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();
</P><P>						}
</P><P>					} else {
</P><P>						// object is active, just swap with the last and pop
</P><P>						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
</P><P>						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();
</P><P>						// accounting is done, now do the same for all bindings
</P><P>						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
</P><P>							var bindingsForPath = bindings[ j ];
</P><P>							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();
</P><P>						}
</P><P>					} // cached or active
</P><P>				} // if object is known
</P><P>			} // for arguments
</P><P>			this.nCachedObjects_ = nCachedObjects;
</P><P>		},
</P><P>		// Internal interface used by befriended PropertyBinding.Composite:
</P><P>		subscribe_: function ( path, parsedPath ) {
</P><P>// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
</P><P>			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;
</P><P>			if ( index !== undefined ) return bindings[ index ];
</P><P>			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );
</P><P>			index = bindings.length;
</P><P>			indicesByPath[ path ] = index;
</P><P>			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );
</P><P>			for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {
</P><P>				var object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );
</P><P>			}
</P><P>			return bindingsForPath;
</P><P>		},
</P><P>		unsubscribe_: function ( path ) {
</P><P>			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
</P><P>			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];
</P><P>			if ( index !== undefined ) {
</P><P>				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];
</P><P>				indicesByPath[ lastBindingsPath ] = index;
</P><P>				bindings[ index ] = lastBindings;
				bindings.pop();
</P><P>				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();
</P><P>				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 *
	 */
</P><P>	function AnimationAction( mixer, clip, localRoot ) {
</P><P>		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;
</P><P>		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );
</P><P>		var interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};
</P><P>		for ( var i = 0; i !== nTracks; ++ i ) {
</P><P>			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;
</P><P>		}
</P><P>		this._interpolantSettings = interpolantSettings;
</P><P>		this._interpolants = interpolants;	// bound by the mixer
</P><P>		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );
</P><P>		this._cacheIndex = null;			// for the memory manager
		this._byClipCacheIndex = null;		// for the memory manager
</P><P>		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;
</P><P>		this.loop = LoopRepeat;
		this._loopCount = - 1;
</P><P>		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;
</P><P>		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;
</P><P>		this.timeScale = 1;
		this._effectiveTimeScale = 1;
</P><P>		this.weight = 1;
		this._effectiveWeight = 1;
</P><P>		this.repetitions = Infinity; 		// no. of repetitions when looping
</P><P>		this.paused = false;				// true -&gt; zero effective time scale
		this.enabled = true;				// false -&gt; zero effective weight
</P><P>		this.clampWhenFinished 	= false;	// keep feeding the last frame?
</P><P>		this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd		= true;		// clips for start, loop and end
</P><P>	}
</P><P>	Object.assign( AnimationAction.prototype, {
</P><P>		// State &amp; Scheduling
</P><P>		play: function () {
</P><P>			this._mixer._activateAction( this );
</P><P>			return this;
</P><P>		},
</P><P>		stop: function () {
</P><P>			this._mixer._deactivateAction( this );
</P><P>			return this.reset();
</P><P>		},
</P><P>		reset: function () {
</P><P>			this.paused = false;
			this.enabled = true;
</P><P>			this.time = 0;			// restart clip
			this._loopCount = - 1;	// forget previous loops
			this._startTime = null;	// forget scheduling
</P><P>			return this.stopFading().stopWarping();
</P><P>		},
</P><P>		isRunning: function () {
</P><P>			return this.enabled &amp;&amp; ! this.paused &amp;&amp; this.timeScale !== 0 &amp;&amp;
					this._startTime === null &amp;&amp; this._mixer._isActiveAction( this );
</P><P>		},
</P><P>		// return true when play has been called
		isScheduled: function () {
</P><P>			return this._mixer._isActiveAction( this );
</P><P>		},
</P><P>		startAt: function ( time ) {
</P><P>			this._startTime = time;
</P><P>			return this;
</P><P>		},
</P><P>		setLoop: function ( mode, repetitions ) {
</P><P>			this.loop = mode;
			this.repetitions = repetitions;
</P><P>			return this;
</P><P>		},
</P><P>		// Weight
</P><P>		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function ( weight ) {
</P><P>			this.weight = weight;
</P><P>			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;
</P><P>			return this.stopFading();
</P><P>		},
</P><P>		// return the weight considering fading and .enabled
		getEffectiveWeight: function () {
</P><P>			return this._effectiveWeight;
</P><P>		},
</P><P>		fadeIn: function ( duration ) {
</P><P>			return this._scheduleFading( duration, 0, 1 );
</P><P>		},
</P><P>		fadeOut: function ( duration ) {
</P><P>			return this._scheduleFading( duration, 1, 0 );
</P><P>		},
</P><P>		crossFadeFrom: function ( fadeOutAction, duration, warp ) {
</P><P>			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );
</P><P>			if ( warp ) {
</P><P>				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,
</P><P>					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;
</P><P>				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		crossFadeTo: function ( fadeInAction, duration, warp ) {
</P><P>			return fadeInAction.crossFadeFrom( this, duration, warp );
</P><P>		},
</P><P>		stopFading: function () {
</P><P>			var weightInterpolant = this._weightInterpolant;
</P><P>			if ( weightInterpolant !== null ) {
</P><P>				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		// Time Scale Control
</P><P>		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function ( timeScale ) {
</P><P>			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;
</P><P>			return this.stopWarping();
</P><P>		},
</P><P>		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function () {
</P><P>			return this._effectiveTimeScale;
</P><P>		},
</P><P>		setDuration: function ( duration ) {
</P><P>			this.timeScale = this._clip.duration / duration;
</P><P>			return this.stopWarping();
</P><P>		},
</P><P>		syncWith: function ( action ) {
</P><P>			this.time = action.time;
			this.timeScale = action.timeScale;
</P><P>			return this.stopWarping();
</P><P>		},
</P><P>		halt: function ( duration ) {
</P><P>			return this.warp( this._effectiveTimeScale, 0, duration );
</P><P>		},
</P><P>		warp: function ( startTimeScale, endTimeScale, duration ) {
</P><P>			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,
</P><P>				timeScale = this.timeScale;
</P><P>			if ( interpolant === null ) {
</P><P>				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
</P><P>			}
</P><P>			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
</P><P>			times[ 0 ] = now;
			times[ 1 ] = now + duration;
</P><P>			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;
</P><P>			return this;
</P><P>		},
</P><P>		stopWarping: function () {
</P><P>			var timeScaleInterpolant = this._timeScaleInterpolant;
</P><P>			if ( timeScaleInterpolant !== null ) {
</P><P>				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		// Object Accessors
</P><P>		getMixer: function () {
</P><P>			return this._mixer;
</P><P>		},
</P><P>		getClip: function () {
</P><P>			return this._clip;
</P><P>		},
</P><P>		getRoot: function () {
</P><P>			return this._localRoot || this._mixer._root;
</P><P>		},
</P><P>		// Interna
</P><P>		_update: function ( time, deltaTime, timeDirection, accuIndex ) {
</P><P>			// called by the mixer
</P><P>			if ( ! this.enabled ) {
</P><P>				// call ._updateWeight() to update ._effectiveWeight
</P><P>				this._updateWeight( time );
				return;
</P><P>			}
</P><P>			var startTime = this._startTime;
</P><P>			if ( startTime !== null ) {
</P><P>				// check for scheduled start of action
</P><P>				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning &lt; 0 || timeDirection === 0 ) {
</P><P>					return; // yet to come / don't decide when delta = 0
</P><P>				}
</P><P>				// start
</P><P>				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;
</P><P>			}
</P><P>			// apply time scale and advance time
</P><P>			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );
</P><P>			// note: _updateTime may disable the action resulting in
			// an effective weight of 0
</P><P>			var weight = this._updateWeight( time );
</P><P>			if ( weight &gt; 0 ) {
</P><P>				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;
</P><P>				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
</P><P>					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		_updateWeight: function ( time ) {
</P><P>			var weight = 0;
</P><P>			if ( this.enabled ) {
</P><P>				weight = this.weight;
				var interpolant = this._weightInterpolant;
</P><P>				if ( interpolant !== null ) {
</P><P>					var interpolantValue = interpolant.evaluate( time )[ 0 ];
</P><P>					weight *= interpolantValue;
</P><P>					if ( time &gt; interpolant.parameterPositions[ 1 ] ) {
</P><P>						this.stopFading();
</P><P>						if ( interpolantValue === 0 ) {
</P><P>							// faded out, disable
							this.enabled = false;
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			this._effectiveWeight = weight;
			return weight;
</P><P>		},
</P><P>		_updateTimeScale: function ( time ) {
</P><P>			var timeScale = 0;
</P><P>			if ( ! this.paused ) {
</P><P>				timeScale = this.timeScale;
</P><P>				var interpolant = this._timeScaleInterpolant;
</P><P>				if ( interpolant !== null ) {
</P><P>					var interpolantValue = interpolant.evaluate( time )[ 0 ];
</P><P>					timeScale *= interpolantValue;
</P><P>					if ( time &gt; interpolant.parameterPositions[ 1 ] ) {
</P><P>						this.stopWarping();
</P><P>						if ( timeScale === 0 ) {
</P><P>							// motion has halted, pause
							this.paused = true;
</P><P>						} else {
</P><P>							// warp done - apply final time scale
							this.timeScale = timeScale;
</P><P>						}
</P><P>					}
</P><P>				}
</P><P>			}
</P><P>			this._effectiveTimeScale = timeScale;
			return timeScale;
</P><P>		},
</P><P>		_updateTime: function ( deltaTime ) {
</P><P>			var time = this.time + deltaTime;
			var duration = this._clip.duration;
			var loop = this.loop;
			var loopCount = this._loopCount;
</P><P>			var pingPong = ( loop === LoopPingPong );
</P><P>			if ( deltaTime === 0 ) {
</P><P>				if ( loopCount === - 1 ) return time;
</P><P>				return ( pingPong &amp;&amp; ( loopCount &amp; 1 ) === 1 ) ? duration - time : time;
</P><P>			}
</P><P>			if ( loop === LoopOnce ) {
</P><P>				if ( loopCount === - 1 ) {
</P><P>					// just started
</P><P>					this._loopCount = 0;
					this._setEndings( true, true, false );
</P><P>				}
</P><P>				handle_stop: {
</P><P>					if ( time &gt;= duration ) {
</P><P>						time = duration;
</P><P>					} else if ( time &lt; 0 ) {
</P><P>						time = 0;
</P><P>					} else break handle_stop;
</P><P>					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;
</P><P>					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime &lt; 0 ? - 1 : 1
					} );
</P><P>				}
</P><P>			} else { // repetitive Repeat or PingPong
</P><P>				if ( loopCount === - 1 ) {
</P><P>					// just started
</P><P>					if ( deltaTime &gt;= 0 ) {
</P><P>						loopCount = 0;
</P><P>						this._setEndings( true, this.repetitions === 0, pingPong );
</P><P>					} else {
</P><P>						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
</P><P>						this._setEndings( this.repetitions === 0, true, pingPong );
</P><P>					}
</P><P>				}
</P><P>				if ( time &gt;= duration || time &lt; 0 ) {
</P><P>					// wrap around
</P><P>					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;
</P><P>					loopCount += Math.abs( loopDelta );
</P><P>					var pending = this.repetitions - loopCount;
</P><P>					if ( pending &lt;= 0 ) {
</P><P>						// have to stop (switch state, clamp time, fire event)
</P><P>						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;
</P><P>						time = deltaTime &gt; 0 ? duration : 0;
</P><P>						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime &gt; 0 ? 1 : - 1
						} );
</P><P>					} else {
</P><P>						// keep running
</P><P>						if ( pending === 1 ) {
</P><P>							// entering the last round
</P><P>							var atStart = deltaTime &lt; 0;
							this._setEndings( atStart, ! atStart, pingPong );
</P><P>						} else {
</P><P>							this._setEndings( false, false, pingPong );
</P><P>						}
</P><P>						this._loopCount = loopCount;
</P><P>						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );
</P><P>					}
</P><P>				}
</P><P>				if ( pingPong &amp;&amp; ( loopCount &amp; 1 ) === 1 ) {
</P><P>					// invert time for the &quot;pong round&quot;
</P><P>					this.time = time;
					return duration - time;
</P><P>				}
</P><P>			}
</P><P>			this.time = time;
			return time;
</P><P>		},
</P><P>		_setEndings: function ( atStart, atEnd, pingPong ) {
</P><P>			var settings = this._interpolantSettings;
</P><P>			if ( pingPong ) {
</P><P>				settings.endingStart 	= ZeroSlopeEnding;
				settings.endingEnd		= ZeroSlopeEnding;
</P><P>			} else {
</P><P>				// assuming for LoopOnce atStart == atEnd == true
</P><P>				if ( atStart ) {
</P><P>					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
</P><P>				} else {
</P><P>					settings.endingStart = WrapAroundEnding;
</P><P>				}
</P><P>				if ( atEnd ) {
</P><P>					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
</P><P>				} else {
</P><P>					settings.endingEnd 	 = WrapAroundEnding;
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		_scheduleFading: function ( duration, weightNow, weightThen ) {
</P><P>			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;
</P><P>			if ( interpolant === null ) {
</P><P>				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
</P><P>			}
</P><P>			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
</P><P>			times[ 0 ] = now; 				values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;	values[ 1 ] = weightThen;
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author David Sarno / <A rel="nofollow" class="external free" href="http://lighthaus.us/">http://lighthaus.us/</A>
	 * @author tschw
	 */
</P><P>	function AnimationMixer( root ) {
</P><P>		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
</P><P>		this.time = 0;
</P><P>		this.timeScale = 1.0;
</P><P>	}
</P><P>	AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
</P><P>		constructor: AnimationMixer,
</P><P>		_bindAction: function ( action, prototypeAction ) {
</P><P>			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];
</P><P>			if ( bindingsByName === undefined ) {
</P><P>				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;
</P><P>			}
</P><P>			for ( var i = 0; i !== nTracks; ++ i ) {
</P><P>				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];
</P><P>				if ( binding !== undefined ) {
</P><P>					bindings[ i ] = binding;
</P><P>				} else {
</P><P>					binding = bindings[ i ];
</P><P>					if ( binding !== undefined ) {
</P><P>						// existing binding, make sure the cache knows
</P><P>						if ( binding._cacheIndex === null ) {
</P><P>							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );
</P><P>						}
</P><P>						continue;
</P><P>					}
</P><P>					var path = prototypeAction &amp;&amp; prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;
</P><P>					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );
</P><P>					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );
</P><P>					bindings[ i ] = binding;
</P><P>				}
</P><P>				interpolants[ i ].resultBuffer = binding.buffer;
</P><P>			}
</P><P>		},
</P><P>		_activateAction: function ( action ) {
</P><P>			if ( ! this._isActiveAction( action ) ) {
</P><P>				if ( action._cacheIndex === null ) {
</P><P>					// this action has been forgotten by the cache, but the user
					// appears to be still using it -&gt; rebind
</P><P>					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];
</P><P>					this._bindAction( action,
						actionsForClip &amp;&amp; actionsForClip.knownActions[ 0 ] );
</P><P>					this._addInactiveAction( action, clipUuid, rootUuid );
</P><P>				}
</P><P>				var bindings = action._propertyBindings;
</P><P>				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
</P><P>					var binding = bindings[ i ];
</P><P>					if ( binding.useCount ++ === 0 ) {
</P><P>						this._lendBinding( binding );
						binding.saveOriginalState();
</P><P>					}
</P><P>				}
</P><P>				this._lendAction( action );
</P><P>			}
</P><P>		},
</P><P>		_deactivateAction: function ( action ) {
</P><P>			if ( this._isActiveAction( action ) ) {
</P><P>				var bindings = action._propertyBindings;
</P><P>				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
</P><P>					var binding = bindings[ i ];
</P><P>					if ( -- binding.useCount === 0 ) {
</P><P>						binding.restoreOriginalState();
						this._takeBackBinding( binding );
</P><P>					}
</P><P>				}
</P><P>				this._takeBackAction( action );
</P><P>			}
</P><P>		},
</P><P>		// Memory manager
</P><P>		_initMemoryManager: function () {
</P><P>			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;
</P><P>			this._actionsByClip = {};
			// inside:
			// {
			// 		knownActions: Array&lt; AnimationAction &gt;	- used as prototypes
			// 		actionByRoot: AnimationAction			- lookup
			// }
</P><P>
			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;
</P><P>			this._bindingsByRootAndName = {}; // inside: Map&lt; name, PropertyMixer &gt;</P><P>
			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;
</P><P>			var scope = this;
</P><P>			this.stats = {
</P><P>				actions: {
					get total() {
</P><P>						return scope._actions.length;
</P><P>					},
					get inUse() {
</P><P>						return scope._nActiveActions;
</P><P>					}
				},
				bindings: {
					get total() {
</P><P>						return scope._bindings.length;
</P><P>					},
					get inUse() {
</P><P>						return scope._nActiveBindings;
</P><P>					}
				},
				controlInterpolants: {
					get total() {
</P><P>						return scope._controlInterpolants.length;
</P><P>					},
					get inUse() {
</P><P>						return scope._nActiveControlInterpolants;
</P><P>					}
				}
</P><P>			};
</P><P>		},
</P><P>		// Memory management for AnimationAction objects
</P><P>		_isActiveAction: function ( action ) {
</P><P>			var index = action._cacheIndex;
			return index !== null &amp;&amp; index &lt; this._nActiveActions;
</P><P>		},
</P><P>		_addInactiveAction: function ( action, clipUuid, rootUuid ) {
</P><P>			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];
</P><P>			if ( actionsForClip === undefined ) {
</P><P>				actionsForClip = {
</P><P>					knownActions: [ action ],
					actionByRoot: {}
</P><P>				};
</P><P>				action._byClipCacheIndex = 0;
</P><P>				actionsByClip[ clipUuid ] = actionsForClip;
</P><P>			} else {
</P><P>				var knownActions = actionsForClip.knownActions;
</P><P>				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );
</P><P>			}
</P><P>			action._cacheIndex = actions.length;
			actions.push( action );
</P><P>			actionsForClip.actionByRoot[ rootUuid ] = action;
</P><P>		},
</P><P>		_removeInactiveAction: function ( action ) {
</P><P>			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;
</P><P>			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();
</P><P>			action._cacheIndex = null;
</P><P>
			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,
</P><P>				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],
</P><P>				byClipCacheIndex = action._byClipCacheIndex;
</P><P>			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();
</P><P>			action._byClipCacheIndex = null;
</P><P>
			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;
</P><P>			delete actionByRoot[ rootUuid ];
</P><P>			if ( knownActionsForClip.length === 0 ) {
</P><P>				delete actionsByClip[ clipUuid ];
</P><P>			}
</P><P>			this._removeInactiveBindingsForAction( action );
</P><P>		},
</P><P>		_removeInactiveBindingsForAction: function ( action ) {
</P><P>			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
</P><P>				var binding = bindings[ i ];
</P><P>				if ( -- binding.referenceCount === 0 ) {
</P><P>					this._removeInactiveBinding( binding );
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		_lendAction: function ( action ) {
</P><P>			// [ active actions |  inactive actions  ]
			// [  active actions &gt;| inactive actions ]
			//                 s        a
			//                  &lt;-swap-&gt;
			//                 a        s
</P><P>			var actions = this._actions,
				prevIndex = action._cacheIndex,
</P><P>				lastActiveIndex = this._nActiveActions ++,
</P><P>				firstInactiveAction = actions[ lastActiveIndex ];
</P><P>			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;
</P><P>			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;
</P><P>		},
</P><P>		_takeBackAction: function ( action ) {
</P><P>			// [  active actions  | inactive actions ]
			// [ active actions |&lt; inactive actions  ]
			//        a        s
			//         &lt;-swap-&gt;
			//        s        a
</P><P>			var actions = this._actions,
				prevIndex = action._cacheIndex,
</P><P>				firstInactiveIndex = -- this._nActiveActions,
</P><P>				lastActiveAction = actions[ firstInactiveIndex ];
</P><P>			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;
</P><P>			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;
</P><P>		},
</P><P>		// Memory management for PropertyMixer objects
</P><P>		_addInactiveBinding: function ( binding, rootUuid, trackName ) {
</P><P>			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
</P><P>				bindings = this._bindings;
</P><P>			if ( bindingByName === undefined ) {
</P><P>				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;
</P><P>			}
</P><P>			bindingByName[ trackName ] = binding;
</P><P>			binding._cacheIndex = bindings.length;
			bindings.push( binding );
</P><P>		},
</P><P>		_removeInactiveBinding: function ( binding ) {
</P><P>			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
</P><P>				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;
</P><P>			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();
</P><P>			delete bindingByName[ trackName ];
</P><P>			remove_empty_map: {
</P><P>				for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars
</P><P>				delete bindingsByRoot[ rootUuid ];
</P><P>			}
</P><P>		},
</P><P>		_lendBinding: function ( binding ) {
</P><P>			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
</P><P>				lastActiveIndex = this._nActiveBindings ++,
</P><P>				firstInactiveBinding = bindings[ lastActiveIndex ];
</P><P>			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;
</P><P>			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;
</P><P>		},
</P><P>		_takeBackBinding: function ( binding ) {
</P><P>			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
</P><P>				firstInactiveIndex = -- this._nActiveBindings,
</P><P>				lastActiveBinding = bindings[ firstInactiveIndex ];
</P><P>			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;
</P><P>			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;
</P><P>		},
</P><P>
		// Memory management of Interpolants for weight and time scale
</P><P>		_lendControlInterpolant: function () {
</P><P>			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];
</P><P>			if ( interpolant === undefined ) {
</P><P>				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );
</P><P>				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;
</P><P>			}
</P><P>			return interpolant;
</P><P>		},
</P><P>		_takeBackControlInterpolant: function ( interpolant ) {
</P><P>			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,
</P><P>				firstInactiveIndex = -- this._nActiveControlInterpolants,
</P><P>				lastActiveInterpolant = interpolants[ firstInactiveIndex ];
</P><P>			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;
</P><P>			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;
</P><P>		},
</P><P>		_controlInterpolantsResultBuffer: new Float32Array( 1 ),
</P><P>		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function ( clip, optionalRoot ) {
</P><P>			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
</P><P>				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,
</P><P>				clipUuid = clipObject !== null ? clipObject.uuid : clip,
</P><P>				actionsForClip = this._actionsByClip[ clipUuid ],
				prototypeAction = null;
</P><P>			if ( actionsForClip !== undefined ) {
</P><P>				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];
</P><P>				if ( existingAction !== undefined ) {
</P><P>					return existingAction;
</P><P>				}
</P><P>				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];
</P><P>				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;
</P><P>			}
</P><P>			// clip must be known when specified via string
			if ( clipObject === null ) return null;
</P><P>			// allocate all resources required to run it
			var newAction = new AnimationAction( this, clipObject, optionalRoot );
</P><P>			this._bindAction( newAction, prototypeAction );
</P><P>			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );
</P><P>			return newAction;
</P><P>		},
</P><P>		// get an existing action
		existingAction: function ( clip, optionalRoot ) {
</P><P>			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
</P><P>				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,
</P><P>				clipUuid = clipObject ? clipObject.uuid : clip,
</P><P>				actionsForClip = this._actionsByClip[ clipUuid ];
</P><P>			if ( actionsForClip !== undefined ) {
</P><P>				return actionsForClip.actionByRoot[ rootUuid ] || null;
</P><P>			}
</P><P>			return null;
</P><P>		},
</P><P>		// deactivates all previously scheduled actions
		stopAllAction: function () {
</P><P>			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;
</P><P>			this._nActiveActions = 0;
			this._nActiveBindings = 0;
</P><P>			for ( var i = 0; i !== nActions; ++ i ) {
</P><P>				actions[ i ].reset();
</P><P>			}
</P><P>			for ( var i = 0; i !== nBindings; ++ i ) {
</P><P>				bindings[ i ].useCount = 0;
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		// advance the time and update apply the animation
		update: function ( deltaTime ) {
</P><P>			deltaTime *= this.timeScale;
</P><P>			var actions = this._actions,
				nActions = this._nActiveActions,
</P><P>				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),
</P><P>				accuIndex = this._accuIndex ^= 1;
</P><P>			// run active actions
</P><P>			for ( var i = 0; i !== nActions; ++ i ) {
</P><P>				var action = actions[ i ];
</P><P>				action._update( time, deltaTime, timeDirection, accuIndex );
</P><P>			}
</P><P>			// update scene graph
</P><P>			var bindings = this._bindings,
				nBindings = this._nActiveBindings;
</P><P>			for ( var i = 0; i !== nBindings; ++ i ) {
</P><P>				bindings[ i ].apply( accuIndex );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		// return this mixer's root target object
		getRoot: function () {
</P><P>			return this._root;
</P><P>		},
</P><P>		// free all resources specific to a particular clip
		uncacheClip: function ( clip ) {
</P><P>			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];
</P><P>			if ( actionsForClip !== undefined ) {
</P><P>				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
</P><P>				var actionsToRemove = actionsForClip.knownActions;
</P><P>				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
</P><P>					var action = actionsToRemove[ i ];
</P><P>					this._deactivateAction( action );
</P><P>					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];
</P><P>					action._cacheIndex = null;
					action._byClipCacheIndex = null;
</P><P>					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();
</P><P>					this._removeInactiveBindingsForAction( action );
</P><P>				}
</P><P>				delete actionsByClip[ clipUuid ];
</P><P>			}
</P><P>		},
</P><P>		// free all resources specific to a particular root target object
		uncacheRoot: function ( root ) {
</P><P>			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;
</P><P>			for ( var clipUuid in actionsByClip ) {
</P><P>				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];
</P><P>				if ( action !== undefined ) {
</P><P>					this._deactivateAction( action );
					this._removeInactiveAction( action );
</P><P>				}
</P><P>			}
</P><P>			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];
</P><P>			if ( bindingByName !== undefined ) {
</P><P>				for ( var trackName in bindingByName ) {
</P><P>					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );
</P><P>				}
</P><P>			}
</P><P>		},
</P><P>		// remove a targeted clip from the cache
		uncacheAction: function ( clip, optionalRoot ) {
</P><P>			var action = this.existingAction( clip, optionalRoot );
</P><P>			if ( action !== null ) {
</P><P>				this._deactivateAction( action );
				this._removeInactiveAction( action );
</P><P>			}
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function Uniform( value ) {
</P><P>		if ( typeof value === 'string' ) {
</P><P>			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];
</P><P>		}
</P><P>		this.value = value;
</P><P>	}
</P><P>	Uniform.prototype.clone = function () {
</P><P>		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );
</P><P>	};
</P><P>	/**
	 * @author benaadams / <A rel="nofollow" class="external free" href="https://twitter.com/ben_a_adams">https://twitter.com/ben_a_adams</A>
	 */
</P><P>	function InstancedBufferGeometry() {
</P><P>		BufferGeometry.call( this );
</P><P>		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;
</P><P>	}
</P><P>	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {
</P><P>		constructor: InstancedBufferGeometry,
</P><P>		isInstancedBufferGeometry: true,
</P><P>		copy: function ( source ) {
</P><P>			BufferGeometry.prototype.copy.call( this, source );
</P><P>			this.maxInstancedCount = source.maxInstancedCount;
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author benaadams / <A rel="nofollow" class="external free" href="https://twitter.com/ben_a_adams">https://twitter.com/ben_a_adams</A>
	 */
</P><P>	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {
</P><P>		InterleavedBuffer.call( this, array, stride );
</P><P>		this.meshPerAttribute = meshPerAttribute || 1;
</P><P>	}
</P><P>	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {
</P><P>		constructor: InstancedInterleavedBuffer,
</P><P>		isInstancedInterleavedBuffer: true,
</P><P>		copy: function ( source ) {
</P><P>			InterleavedBuffer.prototype.copy.call( this, source );
</P><P>			this.meshPerAttribute = source.meshPerAttribute;
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author benaadams / <A rel="nofollow" class="external free" href="https://twitter.com/ben_a_adams">https://twitter.com/ben_a_adams</A>
	 */
</P><P>	function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {
</P><P>		if ( typeof ( normalized ) === 'number' ) {
</P><P>			meshPerAttribute = normalized;
</P><P>			normalized = false;
</P><P>			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );
</P><P>		}
</P><P>		BufferAttribute.call( this, array, itemSize, normalized );
</P><P>		this.meshPerAttribute = meshPerAttribute || 1;
</P><P>	}
</P><P>	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {
</P><P>		constructor: InstancedBufferAttribute,
</P><P>		isInstancedBufferAttribute: true,
</P><P>		copy: function ( source ) {
</P><P>			BufferAttribute.prototype.copy.call( this, source );
</P><P>			this.meshPerAttribute = source.meshPerAttribute;
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io/">http://clara.io/</A>
	 * @author stephomi / <A rel="nofollow" class="external free" href="http://stephaneginier.com/">http://stephaneginier.com/</A>
	 */
</P><P>	function Raycaster( origin, direction, near, far ) {
</P><P>		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)
</P><P>		this.near = near || 0;
		this.far = far || Infinity;
</P><P>		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};
</P><P>		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {
</P><P>					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;
</P><P>				}
			}
		} );
</P><P>	}
</P><P>	function ascSort( a, b ) {
</P><P>		return a.distance - b.distance;
</P><P>	}
</P><P>	function intersectObject( object, raycaster, intersects, recursive ) {
</P><P>		if ( object.visible === false ) return;
</P><P>		object.raycast( raycaster, intersects );
</P><P>		if ( recursive === true ) {
</P><P>			var children = object.children;
</P><P>			for ( var i = 0, l = children.length; i &lt; l; i ++ ) {
</P><P>				intersectObject( children[ i ], raycaster, intersects, true );
</P><P>			}
</P><P>		}
</P><P>	}
</P><P>	Object.assign( Raycaster.prototype, {
</P><P>		linePrecision: 1,
</P><P>		set: function ( origin, direction ) {
</P><P>			// direction is assumed to be normalized (for accurate distance calculations)
</P><P>			this.ray.set( origin, direction );
</P><P>		},
</P><P>		setFromCamera: function ( coords, camera ) {
</P><P>			if ( ( camera &amp;&amp; camera.isPerspectiveCamera ) ) {
</P><P>				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
</P><P>			} else if ( ( camera &amp;&amp; camera.isOrthographicCamera ) ) {
</P><P>				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
</P><P>			} else {
</P><P>				console.error( 'THREE.Raycaster: Unsupported camera type.' );
</P><P>			}
</P><P>		},
</P><P>		intersectObject: function ( object, recursive, optionalTarget ) {
</P><P>			var intersects = optionalTarget || [];
</P><P>			intersectObject( object, this, intersects, recursive );
</P><P>			intersects.sort( ascSort );
</P><P>			return intersects;
</P><P>		},
</P><P>		intersectObjects: function ( objects, recursive, optionalTarget ) {
</P><P>			var intersects = optionalTarget || [];
</P><P>			if ( Array.isArray( objects ) === false ) {
</P><P>				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;
</P><P>			}
</P><P>			for ( var i = 0, l = objects.length; i &lt; l; i ++ ) {
</P><P>				intersectObject( objects[ i ], this, intersects, recursive );
</P><P>			}
</P><P>			intersects.sort( ascSort );
</P><P>			return intersects;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function Clock( autoStart ) {
</P><P>		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
</P><P>		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
</P><P>		this.running = false;
</P><P>	}
</P><P>	Object.assign( Clock.prototype, {
</P><P>		start: function () {
</P><P>			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732
</P><P>			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
</P><P>		},
</P><P>		stop: function () {
</P><P>			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
</P><P>		},
</P><P>		getElapsedTime: function () {
</P><P>			this.getDelta();
			return this.elapsedTime;
</P><P>		},
</P><P>		getDelta: function () {
</P><P>			var diff = 0;
</P><P>			if ( this.autoStart &amp;&amp; ! this.running ) {
</P><P>				this.start();
				return 0;
</P><P>			}
</P><P>			if ( this.running ) {
</P><P>				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();
</P><P>				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;
</P><P>				this.elapsedTime += diff;
</P><P>			}
</P><P>			return diff;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 *
	 * Ref: <A rel="nofollow" class="external free" href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">https://en.wikipedia.org/wiki/Spherical_coordinate_system</A>
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axiz.
	 */
</P><P>	function Spherical( radius, phi, theta ) {
</P><P>		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
		this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle
</P><P>		return this;
</P><P>	}
</P><P>	Object.assign( Spherical.prototype, {
</P><P>		set: function ( radius, phi, theta ) {
</P><P>			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( other ) {
</P><P>			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;
</P><P>			return this;
</P><P>		},
</P><P>		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {
</P><P>			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
</P><P>			return this;
</P><P>		},
</P><P>		setFromVector3: function ( v ) {
</P><P>			return this.setFromCartesianCoords( v.x, v.y, v.z );
</P><P>		},
</P><P>		setFromCartesianCoords: function ( x, y, z ) {
</P><P>			this.radius = Math.sqrt( x * x + y * y + z * z );
</P><P>			if ( this.radius === 0 ) {
</P><P>				this.theta = 0;
				this.phi = 0;
</P><P>			} else {
</P><P>				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );
</P><P>			}
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 *
	 * Ref: <A rel="nofollow" class="external free" href="https://en.wikipedia.org/wiki/Cylindrical_coordinate_system">https://en.wikipedia.org/wiki/Cylindrical_coordinate_system</A>
	 *
	 */
</P><P>	function Cylindrical( radius, theta, y ) {
</P><P>		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane
</P><P>		return this;
</P><P>	}
</P><P>	Object.assign( Cylindrical.prototype, {
</P><P>		set: function ( radius, theta, y ) {
</P><P>			this.radius = radius;
			this.theta = theta;
			this.y = y;
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( other ) {
</P><P>			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;
</P><P>			return this;
</P><P>		},
</P><P>		setFromVector3: function ( v ) {
</P><P>			return this.setFromCartesianCoords( v.x, v.y, v.z );
</P><P>		},
</P><P>		setFromCartesianCoords: function ( x, y, z ) {
</P><P>			this.radius = Math.sqrt( x * x + z * z );
			this.theta = Math.atan2( x, z );
			this.y = y;
</P><P>			return this;
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 */
</P><P>	function Box2( min, max ) {
</P><P>		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );
</P><P>	}
</P><P>	Object.assign( Box2.prototype, {
</P><P>		set: function ( min, max ) {
</P><P>			this.min.copy( min );
			this.max.copy( max );
</P><P>			return this;
</P><P>		},
</P><P>		setFromPoints: function ( points ) {
</P><P>			this.makeEmpty();
</P><P>			for ( var i = 0, il = points.length; i &lt; il; i ++ ) {
</P><P>				this.expandByPoint( points[ i ] );
</P><P>			}
</P><P>			return this;
</P><P>		},
</P><P>		setFromCenterAndSize: function () {
</P><P>			var v1 = new Vector2();
</P><P>			return function setFromCenterAndSize( center, size ) {
</P><P>				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
</P><P>				return this;
</P><P>			};
</P><P>		}(),
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( box ) {
</P><P>			this.min.copy( box.min );
			this.max.copy( box.max );
</P><P>			return this;
</P><P>		},
</P><P>		makeEmpty: function () {
</P><P>			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;
</P><P>			return this;
</P><P>		},
</P><P>		isEmpty: function () {
</P><P>			// this is a more robust check for empty than ( volume &lt;= 0 ) because volume can get positive with two negative axes
</P><P>			return ( this.max.x &lt; this.min.x ) || ( this.max.y &lt; this.min.y );
</P><P>		},
</P><P>		getCenter: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Box2: .getCenter() target is now required' );
				target = new Vector2();
</P><P>			}
</P><P>			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
</P><P>		},
</P><P>		getSize: function ( target ) {
</P><P>			if ( target === undefined ) {</P><P>				console.warn( 'THREE.Box2: .getSize() target is now required' );
				target = new Vector2();
</P><P>			}
</P><P>			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );
</P><P>		},
</P><P>		expandByPoint: function ( point ) {
</P><P>			this.min.min( point );
			this.max.max( point );
</P><P>			return this;
</P><P>		},
</P><P>		expandByVector: function ( vector ) {
</P><P>			this.min.sub( vector );
			this.max.add( vector );
</P><P>			return this;
</P><P>		},
</P><P>		expandByScalar: function ( scalar ) {
</P><P>			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
</P><P>			return this;
</P><P>		},
</P><P>		containsPoint: function ( point ) {
</P><P>			return point.x &lt; this.min.x || point.x &gt; this.max.x ||
				point.y &lt; this.min.y || point.y &gt; this.max.y ? false : true;
</P><P>		},
</P><P>		containsBox: function ( box ) {
</P><P>			return this.min.x &lt;= box.min.x &amp;&amp; box.max.x &lt;= this.max.x &amp;&amp;
				this.min.y &lt;= box.min.y &amp;&amp; box.max.y &lt;= this.max.y;
</P><P>		},
</P><P>		getParameter: function ( point, target ) {
</P><P>			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Box2: .getParameter() target is now required' );
				target = new Vector2();
</P><P>			}
</P><P>			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);
</P><P>		},
</P><P>		intersectsBox: function ( box ) {
</P><P>			// using 4 splitting planes to rule out intersections
</P><P>			return box.max.x &lt; this.min.x || box.min.x &gt; this.max.x ||
				box.max.y &lt; this.min.y || box.min.y &gt; this.max.y ? false : true;
</P><P>		},
</P><P>		clampPoint: function ( point, target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Box2: .clampPoint() target is now required' );
				target = new Vector2();
</P><P>			}
</P><P>			return target.copy( point ).clamp( this.min, this.max );
</P><P>		},
</P><P>		distanceToPoint: function () {
</P><P>			var v1 = new Vector2();
</P><P>			return function distanceToPoint( point ) {
</P><P>				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
</P><P>			};
</P><P>		}(),
</P><P>		intersect: function ( box ) {
</P><P>			this.min.max( box.min );
			this.max.min( box.max );
</P><P>			return this;
</P><P>		},
</P><P>		union: function ( box ) {
</P><P>			this.min.min( box.min );
			this.max.max( box.max );
</P><P>			return this;
</P><P>		},
</P><P>		translate: function ( offset ) {
</P><P>			this.min.add( offset );
			this.max.add( offset );
</P><P>			return this;
</P><P>		},
</P><P>		equals: function ( box ) {
</P><P>			return box.min.equals( this.min ) &amp;&amp; box.max.equals( this.max );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 */
</P><P>	function Line3( start, end ) {
</P><P>		this.start = ( start !== undefined ) ? start : new Vector3();
		this.end = ( end !== undefined ) ? end : new Vector3();
</P><P>	}
</P><P>	Object.assign( Line3.prototype, {
</P><P>		set: function ( start, end ) {
</P><P>			this.start.copy( start );
			this.end.copy( end );
</P><P>			return this;
</P><P>		},
</P><P>		clone: function () {
</P><P>			return new this.constructor().copy( this );
</P><P>		},
</P><P>		copy: function ( line ) {
</P><P>			this.start.copy( line.start );
			this.end.copy( line.end );
</P><P>			return this;
</P><P>		},
</P><P>		getCenter: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Line3: .getCenter() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
</P><P>		},
</P><P>		delta: function ( target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Line3: .delta() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return target.subVectors( this.end, this.start );
</P><P>		},
</P><P>		distanceSq: function () {
</P><P>			return this.start.distanceToSquared( this.end );
</P><P>		},
</P><P>		distance: function () {
</P><P>			return this.start.distanceTo( this.end );
</P><P>		},
</P><P>		at: function ( t, target ) {
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Line3: .at() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return this.delta( target ).multiplyScalar( t ).add( this.start );
</P><P>		},
</P><P>		closestPointToPointParameter: function () {
</P><P>			var startP = new Vector3();
			var startEnd = new Vector3();
</P><P>			return function closestPointToPointParameter( point, clampToLine ) {
</P><P>				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );
</P><P>				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );
</P><P>				var t = startEnd_startP / startEnd2;
</P><P>				if ( clampToLine ) {
</P><P>					t = _Math.clamp( t, 0, 1 );
</P><P>				}
</P><P>				return t;
</P><P>			};
</P><P>		}(),
</P><P>		closestPointToPoint: function ( point, clampToLine, target ) {
</P><P>			var t = this.closestPointToPointParameter( point, clampToLine );
</P><P>			if ( target === undefined ) {
</P><P>				console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
				target = new Vector3();
</P><P>			}
</P><P>			return this.delta( target ).multiplyScalar( t ).add( this.start );
</P><P>		},
</P><P>		applyMatrix4: function ( matrix ) {
</P><P>			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );
</P><P>			return this;
</P><P>		},
</P><P>		equals: function ( line ) {
</P><P>			return line.start.equals( this.start ) &amp;&amp; line.end.equals( this.end );
</P><P>		}
</P><P>	} );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 */
</P><P>	function ImmediateRenderObject( material ) {
</P><P>		Object3D.call( this );
</P><P>		this.material = material;
		this.render = function ( /* renderCallback */ ) {};
</P><P>	}
</P><P>	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
</P><P>	ImmediateRenderObject.prototype.isImmediateRenderObject = true;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function VertexNormalsHelper( object, size, hex, linewidth ) {
</P><P>		this.object = object;
</P><P>		this.size = ( size !== undefined ) ? size : 1;
</P><P>		var color = ( hex !== undefined ) ? hex : 0xff0000;
</P><P>		var width = ( linewidth !== undefined ) ? linewidth : 1;
</P><P>		//
</P><P>		var nNormals = 0;
</P><P>		var objGeometry = this.object.geometry;
</P><P>		if ( objGeometry &amp;&amp; objGeometry.isGeometry ) {
</P><P>			nNormals = objGeometry.faces.length * 3;
</P><P>		} else if ( objGeometry &amp;&amp; objGeometry.isBufferGeometry ) {
</P><P>			nNormals = objGeometry.attributes.normal.count;
</P><P>		}
</P><P>		//
</P><P>		var geometry = new BufferGeometry();
</P><P>		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
</P><P>		geometry.addAttribute( 'position', positions );
</P><P>		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
</P><P>		//
</P><P>		this.matrixAutoUpdate = false;
</P><P>		this.update();
</P><P>	}
</P><P>	VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
</P><P>	VertexNormalsHelper.prototype.update = ( function () {
</P><P>		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();
</P><P>		return function update() {
</P><P>			var keys = [ 'a', 'b', 'c' ];
</P><P>			this.object.updateMatrixWorld( true );
</P><P>			normalMatrix.getNormalMatrix( this.object.matrixWorld );
</P><P>			var matrixWorld = this.object.matrixWorld;
</P><P>			var position = this.geometry.attributes.position;
</P><P>			//
</P><P>			var objGeometry = this.object.geometry;
</P><P>			if ( objGeometry &amp;&amp; objGeometry.isGeometry ) {
</P><P>				var vertices = objGeometry.vertices;
</P><P>				var faces = objGeometry.faces;
</P><P>				var idx = 0;
</P><P>				for ( var i = 0, l = faces.length; i &lt; l; i ++ ) {
</P><P>					var face = faces[ i ];
</P><P>					for ( var j = 0, jl = face.vertexNormals.length; j &lt; jl; j ++ ) {
</P><P>						var vertex = vertices[ face[ keys[ j ] ] ];
</P><P>						var normal = face.vertexNormals[ j ];
</P><P>						v1.copy( vertex ).applyMatrix4( matrixWorld );
</P><P>						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
</P><P>						position.setXYZ( idx, v1.x, v1.y, v1.z );
</P><P>						idx = idx + 1;
</P><P>						position.setXYZ( idx, v2.x, v2.y, v2.z );
</P><P>						idx = idx + 1;
</P><P>					}
</P><P>				}
</P><P>			} else if ( objGeometry &amp;&amp; objGeometry.isBufferGeometry ) {
</P><P>				var objPos = objGeometry.attributes.position;
</P><P>				var objNorm = objGeometry.attributes.normal;
</P><P>				var idx = 0;
</P><P>				// for simplicity, ignore index and drawcalls, and render every normal
</P><P>				for ( var j = 0, jl = objPos.count; j &lt; jl; j ++ ) {
</P><P>					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
</P><P>					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
</P><P>					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
</P><P>					position.setXYZ( idx, v1.x, v1.y, v1.z );
</P><P>					idx = idx + 1;
</P><P>					position.setXYZ( idx, v2.x, v2.y, v2.z );
</P><P>					idx = idx + 1;
</P><P>				}
</P><P>			}
</P><P>			position.needsUpdate = true;
</P><P>		};
</P><P>	}() );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function SpotLightHelper( light, color ) {
</P><P>		Object3D.call( this );
</P><P>		this.light = light;
		this.light.updateMatrixWorld();
</P><P>		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
</P><P>		this.color = color;
</P><P>		var geometry = new BufferGeometry();
</P><P>		var positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];
</P><P>		for ( var i = 0, j = 1, l = 32; i &lt; l; i ++, j ++ ) {
</P><P>			var p1 = ( i / l ) * Math.PI * 2;
			var p2 = ( j / l ) * Math.PI * 2;
</P><P>			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);
</P><P>		}
</P><P>		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
</P><P>		var material = new LineBasicMaterial( { fog: false } );
</P><P>		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );
</P><P>		this.update();
</P><P>	}
</P><P>	SpotLightHelper.prototype = Object.create( Object3D.prototype );
	SpotLightHelper.prototype.constructor = SpotLightHelper;
</P><P>	SpotLightHelper.prototype.dispose = function () {
</P><P>		this.cone.geometry.dispose();
		this.cone.material.dispose();
</P><P>	};
</P><P>	SpotLightHelper.prototype.update = function () {
</P><P>		var vector = new Vector3();
		var vector2 = new Vector3();
</P><P>		return function update() {
</P><P>			this.light.updateMatrixWorld();
</P><P>			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );
</P><P>			this.cone.scale.set( coneWidth, coneWidth, coneLength );
</P><P>			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );
</P><P>			this.cone.lookAt( vector2.sub( vector ) );
</P><P>			if ( this.color !== undefined ) {
</P><P>				this.cone.material.color.set( this.color );
</P><P>			} else {
</P><P>				this.cone.material.color.copy( this.light.color );
</P><P>			}
</P><P>		};
</P><P>	}();
</P><P>	/**
	 * @author Sean Griffin / <A rel="nofollow" class="external free" href="http://twitter.com/sgrif">http://twitter.com/sgrif</A>
	 * @author Michael Guerrero / <A rel="nofollow" class="external free" href="http://realitymeltdown.com">http://realitymeltdown.com</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author ikerr / <A rel="nofollow" class="external free" href="http://verold.com">http://verold.com</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	function getBoneList( object ) {
</P><P>		var boneList = [];
</P><P>		if ( object &amp;&amp; object.isBone ) {
</P><P>			boneList.push( object );
</P><P>		}
</P><P>		for ( var i = 0; i &lt; object.children.length; i ++ ) {
</P><P>			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );
</P><P>		}
</P><P>		return boneList;
</P><P>	}
</P><P>	function SkeletonHelper( object ) {
</P><P>		var bones = getBoneList( object );
</P><P>		var geometry = new BufferGeometry();
</P><P>		var vertices = [];
		var colors = [];
</P><P>		var color1 = new Color( 0, 0, 1 );
		var color2 = new Color( 0, 1, 0 );
</P><P>		for ( var i = 0; i &lt; bones.length; i ++ ) {
</P><P>			var bone = bones[ i ];
</P><P>			if ( bone.parent &amp;&amp; bone.parent.isBone ) {
</P><P>				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );
</P><P>			}
</P><P>		}
</P><P>		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
</P><P>		var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );
</P><P>		LineSegments.call( this, geometry, material );
</P><P>		this.root = object;
		this.bones = bones;
</P><P>		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
</P><P>	}
</P><P>	SkeletonHelper.prototype = Object.create( LineSegments.prototype );
	SkeletonHelper.prototype.constructor = SkeletonHelper;
</P><P>	SkeletonHelper.prototype.updateMatrixWorld = function () {
</P><P>		var vector = new Vector3();
</P><P>		var boneMatrix = new Matrix4();
		var matrixWorldInv = new Matrix4();
</P><P>		return function updateMatrixWorld( force ) {
</P><P>			var bones = this.bones;
</P><P>			var geometry = this.geometry;
			var position = geometry.getAttribute( 'position' );
</P><P>			matrixWorldInv.getInverse( this.root.matrixWorld );
</P><P>			for ( var i = 0, j = 0; i &lt; bones.length; i ++ ) {
</P><P>				var bone = bones[ i ];
</P><P>				if ( bone.parent &amp;&amp; bone.parent.isBone ) {
</P><P>					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j, vector.x, vector.y, vector.z );
</P><P>					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j + 1, vector.x, vector.y, vector.z );
</P><P>					j += 2;
</P><P>				}
</P><P>			}
</P><P>			geometry.getAttribute( 'position' ).needsUpdate = true;
</P><P>			Object3D.prototype.updateMatrixWorld.call( this, force );
</P><P>		};
</P><P>	}();
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function PointLightHelper( light, sphereSize, color ) {
</P><P>		this.light = light;
		this.light.updateMatrixWorld();
</P><P>		this.color = color;
</P><P>		var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
		var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
</P><P>		Mesh.call( this, geometry, material );
</P><P>		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;
</P><P>		this.update();
</P><P>
		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
</P><P>		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
</P><P>		var d = light.distance;
</P><P>		if ( d === 0.0 ) {
</P><P>			this.lightDistance.visible = false;
</P><P>		} else {
</P><P>			this.lightDistance.scale.set( d, d, d );
</P><P>		}
</P><P>		this.add( this.lightDistance );
		*/
</P><P>	}
</P><P>	PointLightHelper.prototype = Object.create( Mesh.prototype );
	PointLightHelper.prototype.constructor = PointLightHelper;
</P><P>	PointLightHelper.prototype.dispose = function () {
</P><P>		this.geometry.dispose();
		this.material.dispose();
</P><P>	};
</P><P>	PointLightHelper.prototype.update = function () {
</P><P>		if ( this.color !== undefined ) {
</P><P>			this.material.color.set( this.color );
</P><P>		} else {
</P><P>			this.material.color.copy( this.light.color );
</P><P>		}
</P><P>		/*
		var d = this.light.distance;
</P><P>		if ( d === 0.0 ) {
</P><P>			this.lightDistance.visible = false;
</P><P>		} else {
</P><P>			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
</P><P>		}
		*/
</P><P>	};
</P><P>	/**
	 * @author abelnation / <A rel="nofollow" class="external free" href="http://github.com/abelnation">http://github.com/abelnation</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="http://github.com/Mugen87">http://github.com/Mugen87</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function RectAreaLightHelper( light, color ) {
</P><P>		Object3D.call( this );
</P><P>		this.light = light;
		this.light.updateMatrixWorld();
</P><P>		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
</P><P>		this.color = color;
</P><P>		var material = new LineBasicMaterial( { fog: false } );
</P><P>		var geometry = new BufferGeometry();
</P><P>		geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );
</P><P>		this.line = new Line( geometry, material );
		this.add( this.line );
</P><P>
		this.update();
</P><P>	}
</P><P>	RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
</P><P>	RectAreaLightHelper.prototype.dispose = function () {
</P><P>		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();
</P><P>	};
</P><P>	RectAreaLightHelper.prototype.update = function () {
</P><P>		// calculate new dimensions of the helper
</P><P>		var hx = this.light.width * 0.5;
		var hy = this.light.height * 0.5;
</P><P>		var position = this.line.geometry.attributes.position;
		var array = position.array;
</P><P>		// update vertices
</P><P>		array[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;
		array[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;
		array[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;
		array[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
		array[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;
</P><P>		position.needsUpdate = true;
</P><P>		if ( this.color !== undefined ) {
</P><P>			this.line.material.color.set( this.color );
</P><P>		} else {
</P><P>			this.line.material.color.copy( this.light.color );
</P><P>		}
</P><P>	};
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 */
</P><P>	function HemisphereLightHelper( light, size, color ) {
</P><P>		Object3D.call( this );
</P><P>		this.light = light;
		this.light.updateMatrixWorld();
</P><P>		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
</P><P>		this.color = color;
</P><P>		var geometry = new OctahedronBufferGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );
</P><P>		this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
		if ( this.color === undefined ) this.material.vertexColors = VertexColors;
</P><P>		var position = geometry.getAttribute( 'position' );
		var colors = new Float32Array( position.count * 3 );
</P><P>		geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );
</P><P>		this.add( new Mesh( geometry, this.material ) );
</P><P>		this.update();
</P><P>	}
</P><P>	HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
</P><P>	HemisphereLightHelper.prototype.dispose = function () {
</P><P>		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();
</P><P>	};
</P><P>	HemisphereLightHelper.prototype.update = function () {
</P><P>		var vector = new Vector3();
</P><P>		var color1 = new Color();
		var color2 = new Color();
</P><P>		return function update() {
</P><P>			var mesh = this.children[ 0 ];
</P><P>			if ( this.color !== undefined ) {
</P><P>				this.material.color.set( this.color );
</P><P>			} else {
</P><P>				var colors = mesh.geometry.getAttribute( 'color' );
</P><P>				color1.copy( this.light.color );
				color2.copy( this.light.groundColor );
</P><P>				for ( var i = 0, l = colors.count; i &lt; l; i ++ ) {
</P><P>					var color = ( i &lt; ( l / 2 ) ) ? color1 : color2;
</P><P>					colors.setXYZ( i, color.r, color.g, color.b );
</P><P>				}
</P><P>				colors.needsUpdate = true;
</P><P>			}
</P><P>			mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
</P><P>		};
</P><P>	}();
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function GridHelper( size, divisions, color1, color2 ) {
</P><P>		size = size || 10;
		divisions = divisions || 10;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
</P><P>		var center = divisions / 2;
		var step = size / divisions;
		var halfSize = size / 2;
</P><P>		var vertices = [], colors = [];
</P><P>		for ( var i = 0, j = 0, k = - halfSize; i &lt;= divisions; i ++, k += step ) {
</P><P>			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );
</P><P>			var color = i === center ? color1 : color2;
</P><P>			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
</P><P>		}
</P><P>		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
</P><P>		var material = new LineBasicMaterial( { vertexColors: VertexColors } );
</P><P>		LineSegments.call( this, geometry, material );
</P><P>	}
</P><P>	GridHelper.prototype = Object.create( LineSegments.prototype );
	GridHelper.prototype.constructor = GridHelper;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="http://github.com/Mugen87">http://github.com/Mugen87</A>
	 * @author Hectate / <A rel="nofollow" class="external free" href="http://www.github.com/Hectate">http://www.github.com/Hectate</A>
	 */
</P><P>	function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {
</P><P>		radius = radius || 10;
		radials = radials || 16;
		circles = circles || 8;
		divisions = divisions || 64;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
</P><P>		var vertices = [];
		var colors = [];
</P><P>		var x, z;
		var v, i, j, r, color;
</P><P>		// create the radials
</P><P>		for ( i = 0; i &lt;= radials; i ++ ) {
</P><P>			v = ( i / radials ) * ( Math.PI * 2 );
</P><P>			x = Math.sin( v ) * radius;
			z = Math.cos( v ) * radius;
</P><P>			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );
</P><P>			color = ( i &amp; 1 ) ? color1 : color2;
</P><P>			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );
</P><P>		}
</P><P>		// create the circles
</P><P>		for ( i = 0; i &lt;= circles; i ++ ) {
</P><P>			color = ( i &amp; 1 ) ? color1 : color2;
</P><P>			r = radius - ( radius / circles * i );
</P><P>			for ( j = 0; j &lt; divisions; j ++ ) {
</P><P>				// first vertex
</P><P>				v = ( j / divisions ) * ( Math.PI * 2 );
</P><P>				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;
</P><P>				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );
</P><P>				// second vertex
</P><P>				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );
</P><P>				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;
</P><P>				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );
</P><P>			}
</P><P>		}
</P><P>		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
</P><P>		var material = new LineBasicMaterial( { vertexColors: VertexColors } );
</P><P>		LineSegments.call( this, geometry, material );
</P><P>	}
</P><P>	PolarGridHelper.prototype = Object.create( LineSegments.prototype );
	PolarGridHelper.prototype.constructor = PolarGridHelper;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function FaceNormalsHelper( object, size, hex, linewidth ) {
</P><P>		// FaceNormalsHelper only supports THREE.Geometry
</P><P>		this.object = object;
</P><P>		this.size = ( size !== undefined ) ? size : 1;
</P><P>		var color = ( hex !== undefined ) ? hex : 0xffff00;
</P><P>		var width = ( linewidth !== undefined ) ? linewidth : 1;
</P><P>		//
</P><P>		var nNormals = 0;
</P><P>		var objGeometry = this.object.geometry;
</P><P>		if ( objGeometry &amp;&amp; objGeometry.isGeometry ) {
</P><P>			nNormals = objGeometry.faces.length;
</P><P>		} else {
</P><P>			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
</P><P>		}
</P><P>		//
</P><P>		var geometry = new BufferGeometry();
</P><P>		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
</P><P>		geometry.addAttribute( 'position', positions );
</P><P>		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
</P><P>		//
</P><P>		this.matrixAutoUpdate = false;
		this.update();
</P><P>	}
</P><P>	FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
</P><P>	FaceNormalsHelper.prototype.update = ( function () {
</P><P>		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();
</P><P>		return function update() {
</P><P>			this.object.updateMatrixWorld( true );
</P><P>			normalMatrix.getNormalMatrix( this.object.matrixWorld );
</P><P>			var matrixWorld = this.object.matrixWorld;
</P><P>			var position = this.geometry.attributes.position;
</P><P>			//
</P><P>			var objGeometry = this.object.geometry;
</P><P>			var vertices = objGeometry.vertices;
</P><P>			var faces = objGeometry.faces;
</P><P>			var idx = 0;
</P><P>			for ( var i = 0, l = faces.length; i &lt; l; i ++ ) {
</P><P>				var face = faces[ i ];
</P><P>				var normal = face.normal;
</P><P>				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );
</P><P>				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
</P><P>				position.setXYZ( idx, v1.x, v1.y, v1.z );
</P><P>				idx = idx + 1;
</P><P>				position.setXYZ( idx, v2.x, v2.y, v2.z );
</P><P>				idx = idx + 1;
</P><P>			}
</P><P>			position.needsUpdate = true;
</P><P>		};
</P><P>	}() );
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function DirectionalLightHelper( light, size, color ) {
</P><P>		Object3D.call( this );
</P><P>		this.light = light;
		this.light.updateMatrixWorld();
</P><P>		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
</P><P>		this.color = color;
</P><P>		if ( size === undefined ) size = 1;
</P><P>		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );
</P><P>		var material = new LineBasicMaterial( { fog: false } );
</P><P>		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );
</P><P>		geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );
</P><P>		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );
</P><P>		this.update();
</P><P>	}
</P><P>	DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
</P><P>	DirectionalLightHelper.prototype.dispose = function () {
</P><P>		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
</P><P>	};
</P><P>	DirectionalLightHelper.prototype.update = function () {
</P><P>		var v1 = new Vector3();
		var v2 = new Vector3();
		var v3 = new Vector3();
</P><P>		return function update() {
</P><P>			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );
</P><P>			this.lightPlane.lookAt( v3 );
</P><P>			if ( this.color !== undefined ) {
</P><P>				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );
</P><P>			} else {
</P><P>				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );
</P><P>			}
</P><P>			this.targetLine.lookAt( v3 );
			this.targetLine.scale.z = v3.length();
</P><P>		};
</P><P>	}();
</P><P>	/**
	 * @author alteredq / <A rel="nofollow" class="external free" href="http://alteredqualia.com/">http://alteredqualia.com/</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="https://github.com/Mugen87">https://github.com/Mugen87</A>
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		<A rel="nofollow" class="external free" href="http://evanw.github.com/lightgl.js/tests/shadowmap.html">http://evanw.github.com/lightgl.js/tests/shadowmap.html</A>
	 */
</P><P>	function CameraHelper( camera ) {
</P><P>		var geometry = new BufferGeometry();
		var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );
</P><P>		var vertices = [];
		var colors = [];
</P><P>		var pointMap = {};
</P><P>		// colors
</P><P>		var colorFrustum = new Color( 0xffaa00 );
		var colorCone = new Color( 0xff0000 );
		var colorUp = new Color( 0x00aaff );
		var colorTarget = new Color( 0xffffff );
		var colorCross = new Color( 0x333333 );
</P><P>		// near
</P><P>		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );
</P><P>		// far
</P><P>		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );
</P><P>		// sides
</P><P>		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );
</P><P>		// cone
</P><P>		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );
</P><P>		// up
</P><P>		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );
</P><P>		// target
</P><P>		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );
</P><P>		// cross
</P><P>		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );
</P><P>		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );
</P><P>		function addLine( a, b, color ) {
</P><P>			addPoint( a, color );
			addPoint( b, color );
</P><P>		}
</P><P>		function addPoint( id, color ) {
</P><P>			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );
</P><P>			if ( pointMap[ id ] === undefined ) {
</P><P>				pointMap[ id ] = [];
</P><P>			}
</P><P>			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );
</P><P>		}
</P><P>		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
</P><P>		LineSegments.call( this, geometry, material );
</P><P>		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();
</P><P>		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;
</P><P>		this.pointMap = pointMap;
</P><P>		this.update();
</P><P>	}
</P><P>	CameraHelper.prototype = Object.create( LineSegments.prototype );
	CameraHelper.prototype.constructor = CameraHelper;
</P><P>	CameraHelper.prototype.update = function () {
</P><P>		var geometry, pointMap;
</P><P>		var vector = new Vector3();
		var camera = new Camera();
</P><P>		function setPoint( point, x, y, z ) {
</P><P>			vector.set( x, y, z ).unproject( camera );
</P><P>			var points = pointMap[ point ];
</P><P>			if ( points !== undefined ) {
</P><P>				var position = geometry.getAttribute( 'position' );
</P><P>				for ( var i = 0, l = points.length; i &lt; l; i ++ ) {
</P><P>					position.setXYZ( points[ i ], vector.x, vector.y, vector.z );
</P><P>				}
</P><P>			}
</P><P>		}
</P><P>		return function update() {
</P><P>			geometry = this.geometry;
			pointMap = this.pointMap;
</P><P>			var w = 1, h = 1;
</P><P>			// we need just camera projection matrix
			// world matrix must be identity
</P><P>			camera.projectionMatrix.copy( this.camera.projectionMatrix );
</P><P>			// center / target
</P><P>			setPoint( 'c', 0, 0, - 1 );
			setPoint( 't', 0, 0, 1 );
</P><P>			// near
</P><P>			setPoint( 'n1', - w, - h, - 1 );
			setPoint( 'n2', w, - h, - 1 );
			setPoint( 'n3', - w, h, - 1 );
			setPoint( 'n4', w, h, - 1 );
</P><P>			// far
</P><P>			setPoint( 'f1', - w, - h, 1 );
			setPoint( 'f2', w, - h, 1 );
			setPoint( 'f3', - w, h, 1 );
			setPoint( 'f4', w, h, 1 );
</P><P>			// up
</P><P>			setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', 0, h * 2, - 1 );
</P><P>			// cross
</P><P>			setPoint( 'cf1', - w, 0, 1 );
			setPoint( 'cf2', w, 0, 1 );
			setPoint( 'cf3', 0, - h, 1 );
			setPoint( 'cf4', 0, h, 1 );
</P><P>			setPoint( 'cn1', - w, 0, - 1 );
			setPoint( 'cn2', w, 0, - 1 );
			setPoint( 'cn3', 0, - h, - 1 );
			setPoint( 'cn4', 0, h, - 1 );
</P><P>			geometry.getAttribute( 'position' ).needsUpdate = true;
</P><P>		};
</P><P>	}();
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 * @author Mugen87 / <A rel="nofollow" class="external free" href="http://github.com/Mugen87">http://github.com/Mugen87</A>
	 */
</P><P>	function BoxHelper( object, color ) {
</P><P>		this.object = object;
</P><P>		if ( color === undefined ) color = 0xffff00;
</P><P>		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );
</P><P>		var geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
</P><P>		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
</P><P>		this.matrixAutoUpdate = false;
</P><P>		this.update();
</P><P>	}
</P><P>	BoxHelper.prototype = Object.create( LineSegments.prototype );
	BoxHelper.prototype.constructor = BoxHelper;
</P><P>	BoxHelper.prototype.update = ( function () {
</P><P>		var box = new Box3();
</P><P>		return function update( object ) {
</P><P>			if ( object !== undefined ) {
</P><P>				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );
</P><P>			}
</P><P>			if ( this.object !== undefined ) {
</P><P>				box.setFromObject( this.object );
</P><P>			}
</P><P>			if ( box.isEmpty() ) return;
</P><P>			var min = box.min;
			var max = box.max;
</P><P>			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/
</P><P>			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/
</P><P>			var position = this.geometry.attributes.position;
			var array = position.array;
</P><P>			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
</P><P>			position.needsUpdate = true;
</P><P>			this.geometry.computeBoundingSphere();
</P><P>		};
</P><P>	} )();
</P><P>	BoxHelper.prototype.setFromObject = function ( object ) {
</P><P>		this.object = object;
		this.update();
</P><P>		return this;
</P><P>	};
</P><P>	/**
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function Box3Helper( box, hex ) {
</P><P>		this.type = 'Box3Helper';
</P><P>		this.box = box;
</P><P>		var color = ( hex !== undefined ) ? hex : 0xffff00;
</P><P>		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
</P><P>		var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];
</P><P>		var geometry = new BufferGeometry();
</P><P>		geometry.setIndex( new BufferAttribute( indices, 1 ) );
</P><P>		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
</P><P>		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
</P><P>		this.geometry.computeBoundingSphere();
</P><P>	}
</P><P>	Box3Helper.prototype = Object.create( LineSegments.prototype );
	Box3Helper.prototype.constructor = Box3Helper;
</P><P>	Box3Helper.prototype.updateMatrixWorld = function ( force ) {
</P><P>		var box = this.box;
</P><P>		if ( box.isEmpty() ) return;
</P><P>		box.getCenter( this.position );
</P><P>		box.getSize( this.scale );
</P><P>		this.scale.multiplyScalar( 0.5 );
</P><P>		Object3D.prototype.updateMatrixWorld.call( this, force );
</P><P>	};
</P><P>	/**
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 */
</P><P>	function PlaneHelper( plane, size, hex ) {
</P><P>		this.type = 'PlaneHelper';
</P><P>		this.plane = plane;
</P><P>		this.size = ( size === undefined ) ? 1 : size;
</P><P>		var color = ( hex !== undefined ) ? hex : 0xffff00;
</P><P>		var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];
</P><P>		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();
</P><P>		Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );
</P><P>		//
</P><P>		var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];
</P><P>		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();
</P><P>		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );
</P><P>	}
</P><P>	PlaneHelper.prototype = Object.create( Line.prototype );
	PlaneHelper.prototype.constructor = PlaneHelper;
</P><P>	PlaneHelper.prototype.updateMatrixWorld = function ( force ) {
</P><P>		var scale = - this.plane.constant;
</P><P>		if ( Math.abs( scale ) &lt; 1e-8 ) scale = 1e-8; // sign does not matter
</P><P>		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );
</P><P>		this.children[ 0 ].material.side = ( scale &lt; 0 ) ? BackSide : FrontSide; // renderer flips side when determinant &lt; 0; flipping not wanted here
</P><P>		this.lookAt( this.plane.normal );
</P><P>		Object3D.prototype.updateMatrixWorld.call( this, force );
</P><P>	};
</P><P>	/**
	 * @author WestLangley / <A rel="nofollow" class="external free" href="http://github.com/WestLangley">http://github.com/WestLangley</A>
	 * @author zz85 / <A rel="nofollow" class="external free" href="http://github.com/zz85">http://github.com/zz85</A>
	 * @author bhouston / <A rel="nofollow" class="external free" href="http://clara.io">http://clara.io</A>
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */
</P><P>	var lineGeometry, coneGeometry;
</P><P>	function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
</P><P>		// dir is assumed to be normalized
</P><P>		Object3D.call( this );
</P><P>		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
</P><P>		if ( lineGeometry === undefined ) {
</P><P>			lineGeometry = new BufferGeometry();
			lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );
</P><P>			coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
			coneGeometry.translate( 0, - 0.5, 0 );
</P><P>		}
</P><P>		this.position.copy( origin );
</P><P>		this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );
</P><P>		this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );
</P><P>		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );
</P><P>	}
</P><P>	ArrowHelper.prototype = Object.create( Object3D.prototype );
	ArrowHelper.prototype.constructor = ArrowHelper;
</P><P>	ArrowHelper.prototype.setDirection = ( function () {
</P><P>		var axis = new Vector3();
		var radians;
</P><P>		return function setDirection( dir ) {
</P><P>			// dir is assumed to be normalized
</P><P>			if ( dir.y &gt; 0.99999 ) {
</P><P>				this.quaternion.set( 0, 0, 0, 1 );
</P><P>			} else if ( dir.y &lt; - 0.99999 ) {
</P><P>				this.quaternion.set( 1, 0, 0, 0 );
</P><P>			} else {
</P><P>				axis.set( dir.z, 0, - dir.x ).normalize();
</P><P>				radians = Math.acos( dir.y );
</P><P>				this.quaternion.setFromAxisAngle( axis, radians );
</P><P>			}
</P><P>		};
</P><P>	}() );
</P><P>	ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
</P><P>		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
</P><P>		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();
</P><P>		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();
</P><P>	};
</P><P>	ArrowHelper.prototype.setColor = function ( color ) {
</P><P>		this.line.material.color.copy( color );
		this.cone.material.color.copy( color );
</P><P>	};
</P><P>	/**
	 * @author sroucheray / <A rel="nofollow" class="external free" href="http://sroucheray.org/">http://sroucheray.org/</A>
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function AxesHelper( size ) {
</P><P>		size = size || 1;
</P><P>		var vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];
</P><P>		var colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];
</P><P>		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
</P><P>		var material = new LineBasicMaterial( { vertexColors: VertexColors } );
</P><P>		LineSegments.call( this, geometry, material );
</P><P>	}
</P><P>	AxesHelper.prototype = Object.create( LineSegments.prototype );
	AxesHelper.prototype.constructor = AxesHelper;
</P><P>	/**
	 * @author mrdoob / <A rel="nofollow" class="external free" href="http://mrdoob.com/">http://mrdoob.com/</A>
	 */
</P><P>	function Face4( a, b, c, d, normal, color, materialIndex ) {
</P><P>		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new Face3( a, b, c, normal, color, materialIndex );
</P><P>	}
</P><P>	var LineStrip = 0;
</P><P>	var LinePieces = 1;
</P><P>	function MeshFaceMaterial( materials ) {
</P><P>		console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
		return materials;
</P><P>	}
</P><P>	function MultiMaterial( materials ) {
</P><P>		if ( materials === undefined ) materials = [];
</P><P>		console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
		materials.isMultiMaterial = true;
		materials.materials = materials;
		materials.clone = function () {
</P><P>			return materials.slice();
</P><P>		};
		return materials;
</P><P>	}
</P><P>	function PointCloud( geometry, material ) {
</P><P>		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new Points( geometry, material );
</P><P>	}
</P><P>	function Particle( material ) {
</P><P>		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
		return new Sprite( material );
</P><P>	}
</P><P>	function ParticleSystem( geometry, material ) {
</P><P>		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new Points( geometry, material );
</P><P>	}
</P><P>	function PointCloudMaterial( parameters ) {
</P><P>		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );
</P><P>	}
</P><P>	function ParticleBasicMaterial( parameters ) {
</P><P>		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );
</P><P>	}
</P><P>	function ParticleSystemMaterial( parameters ) {
</P><P>		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );
</P><P>	}
</P><P>	function Vertex( x, y, z ) {
</P><P>		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		return new Vector3( x, y, z );
</P><P>	}
</P><P>	//
</P><P>	function DynamicBufferAttribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new BufferAttribute( array, itemSize ).setDynamic( true );
</P><P>	}
</P><P>	function Int8Attribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
		return new Int8BufferAttribute( array, itemSize );
</P><P>	}
</P><P>	function Uint8Attribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
		return new Uint8BufferAttribute( array, itemSize );
</P><P>	}
</P><P>	function Uint8ClampedAttribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
		return new Uint8ClampedBufferAttribute( array, itemSize );
</P><P>	}
</P><P>	function Int16Attribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
		return new Int16BufferAttribute( array, itemSize );
</P><P>	}
</P><P>	function Uint16Attribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
		return new Uint16BufferAttribute( array, itemSize );
</P><P>	}
</P><P>	function Int32Attribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
		return new Int32BufferAttribute( array, itemSize );
</P><P>	}
</P><P>	function Uint32Attribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
		return new Uint32BufferAttribute( array, itemSize );
</P><P>	}
</P><P>	function Float32Attribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
		return new Float32BufferAttribute( array, itemSize );
</P><P>	}
</P><P>	function Float64Attribute( array, itemSize ) {
</P><P>		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
		return new Float64BufferAttribute( array, itemSize );
</P><P>	}
</P><P>	//
</P><P>	Curve.create = function ( construct, getPoint ) {
</P><P>		console.log( 'THREE.Curve.create() has been deprecated' );
</P><P>		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;
</P><P>		return construct;
</P><P>	};
</P><P>	//
</P><P>	Object.assign( CurvePath.prototype, {
</P><P>		createPointsGeometry: function ( divisions ) {
</P><P>			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
</P><P>			// generate geometry from path points (for Line or Points objects)
</P><P>			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );
</P><P>		},
</P><P>		createSpacedPointsGeometry: function ( divisions ) {
</P><P>			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
</P><P>			// generate geometry from equidistant sampling along the path
</P><P>			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );
</P><P>		},
</P><P>		createGeometry: function ( points ) {
</P><P>			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
</P><P>			var geometry = new Geometry();
</P><P>			for ( var i = 0, l = points.length; i &lt; l; i ++ ) {
</P><P>				var point = points[ i ];
				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
</P><P>			}
</P><P>			return geometry;
</P><P>		}
</P><P>	} );
</P><P>	//
</P><P>	Object.assign( Path.prototype, {
</P><P>		fromPoints: function ( points ) {
</P><P>			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
			this.setFromPoints( points );
</P><P>		}
</P><P>	} );
</P><P>	//
</P><P>	function ClosedSplineCurve3( points ) {
</P><P>		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
</P><P>		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;
</P><P>	}
</P><P>	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
</P><P>	//
</P><P>	function SplineCurve3( points ) {
</P><P>		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
</P><P>		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
</P><P>	}
</P><P>	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
</P><P>	//
</P><P>	function Spline( points ) {
</P><P>		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );
</P><P>		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
</P><P>	}
</P><P>	Spline.prototype = Object.create( CatmullRomCurve3.prototype );
</P><P>	Object.assign( Spline.prototype, {
</P><P>		initFromArray: function ( /* a */ ) {
</P><P>			console.error( 'THREE.Spline: .initFromArray() has been removed.' );
</P><P>		},
		getControlPointsArray: function ( /* optionalTarget */ ) {
</P><P>			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );
</P><P>		},
		reparametrizeByArcLength: function ( /* samplingCoef */ ) {
</P><P>			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );
</P><P>		}
</P><P>	} );
</P><P>	//
</P><P>	function AxisHelper( size ) {
</P><P>		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
		return new AxesHelper( size );
</P><P>	}
</P><P>	function BoundingBoxHelper( object, color ) {
</P><P>		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
		return new BoxHelper( object, color );
</P><P>	}
</P><P>	function EdgesHelper( object, hex ) {
</P><P>		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
		return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
</P><P>	}
</P><P>	GridHelper.prototype.setColors = function () {
</P><P>		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );
</P><P>	};
</P><P>	SkeletonHelper.prototype.update = function () {
</P><P>		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );
</P><P>	};
</P><P>	function WireframeHelper( object, hex ) {
</P><P>		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
		return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
</P><P>	}
</P><P>	//
</P><P>	Object.assign( Loader.prototype, {
</P><P>		extractUrlBase: function ( url ) {
</P><P>			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
			return LoaderUtils.extractUrlBase( url );
</P><P>		}
</P><P>	} );
</P><P>	function XHRLoader( manager ) {
</P><P>		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
		return new FileLoader( manager );
</P><P>	}
</P><P>	function BinaryTextureLoader( manager ) {
</P><P>		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
		return new DataTextureLoader( manager );
</P><P>	}
</P><P>	Object.assign( JSONLoader.prototype, {
</P><P>		setTexturePath: function ( value ) {
</P><P>			console.warn( 'THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath().' );
			return this.setResourcePath( value );
</P><P>		}
</P><P>	} );
</P><P>	//
</P><P>	Object.assign( Box2.prototype, {
</P><P>		center: function ( optionalTarget ) {
</P><P>			console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );
</P><P>		},
		empty: function () {
</P><P>			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
</P><P>		},
		isIntersectionBox: function ( box ) {
</P><P>			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
</P><P>		},
		size: function ( optionalTarget ) {
</P><P>			console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );
</P><P>		}
	} );
</P><P>	Object.assign( Box3.prototype, {
</P><P>		center: function ( optionalTarget ) {
</P><P>			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );
</P><P>		},
		empty: function () {
</P><P>			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
</P><P>		},
		isIntersectionBox: function ( box ) {
</P><P>			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
</P><P>		},
		isIntersectionSphere: function ( sphere ) {
</P><P>			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );
</P><P>		},
		size: function ( optionalTarget ) {
</P><P>			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );
</P><P>		}
	} );
</P><P>	Line3.prototype.center = function ( optionalTarget ) {
</P><P>		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );
</P><P>	};
</P><P>	Object.assign( _Math, {
</P><P>		random16: function () {
</P><P>			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();
</P><P>		},
</P><P>		nearestPowerOfTwo: function ( value ) {
</P><P>			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
			return _Math.floorPowerOfTwo( value );
</P><P>		},
</P><P>		nextPowerOfTwo: function ( value ) {
</P><P>			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
			return _Math.ceilPowerOfTwo( value );
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Matrix3.prototype, {
</P><P>		flattenToArrayOffset: function ( array, offset ) {
</P><P>			console.warn( &quot;THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.&quot; );
			return this.toArray( array, offset );
</P><P>		},
		multiplyVector3: function ( vector ) {
</P><P>			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );
</P><P>		},
		multiplyVector3Array: function ( /* a */ ) {
</P><P>			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );
</P><P>		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {
</P><P>			console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );
</P><P>		},
		applyToVector3Array: function ( /* array, offset, length */ ) {
</P><P>			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Matrix4.prototype, {
</P><P>		extractPosition: function ( m ) {
</P><P>			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );
</P><P>		},
		flattenToArrayOffset: function ( array, offset ) {
</P><P>			console.warn( &quot;THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.&quot; );
			return this.toArray( array, offset );
</P><P>		},
		getPosition: function () {
</P><P>			var v1;
</P><P>			return function getPosition() {
</P><P>				if ( v1 === undefined ) v1 = new Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
				return v1.setFromMatrixColumn( this, 3 );
</P><P>			};
</P><P>		}(),
		setRotationFromQuaternion: function ( q ) {
</P><P>			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );
</P><P>		},
		multiplyToArray: function () {
</P><P>			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );
</P><P>		},
		multiplyVector3: function ( vector ) {
</P><P>			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
</P><P>		},
		multiplyVector4: function ( vector ) {
</P><P>			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
</P><P>		},
		multiplyVector3Array: function ( /* a */ ) {
</P><P>			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );
</P><P>		},
		rotateAxis: function ( v ) {
</P><P>			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );
</P><P>		},
		crossVector: function ( vector ) {
</P><P>			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
</P><P>		},
		translate: function () {
</P><P>			console.error( 'THREE.Matrix4: .translate() has been removed.' );
</P><P>		},
		rotateX: function () {
</P><P>			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
</P><P>		},
		rotateY: function () {
</P><P>			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
</P><P>		},
		rotateZ: function () {
</P><P>			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
</P><P>		},
		rotateByAxis: function () {
</P><P>			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
</P><P>		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {
</P><P>			console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );
</P><P>		},
		applyToVector3Array: function ( /* array, offset, length */ ) {
</P><P>			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );
</P><P>		},
		makeFrustum: function ( left, right, bottom, top, near, far ) {
</P><P>			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
			return this.makePerspective( left, right, top, bottom, near, far );
</P><P>		}
</P><P>	} );
</P><P>	Plane.prototype.isIntersectionLine = function ( line ) {
</P><P>		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );
</P><P>	};
</P><P>	Quaternion.prototype.multiplyVector3 = function ( vector ) {
</P><P>		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );
</P><P>	};
</P><P>	Object.assign( Ray.prototype, {
</P><P>		isIntersectionBox: function ( box ) {
</P><P>			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
</P><P>		},
		isIntersectionPlane: function ( plane ) {
</P><P>			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );
</P><P>		},
		isIntersectionSphere: function ( sphere ) {
</P><P>			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Triangle.prototype, {
</P><P>		area: function () {
</P><P>			console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
			return this.getArea();
</P><P>		},
		barycoordFromPoint: function ( point, target ) {
</P><P>			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return this.getBarycoord( point, target );
</P><P>		},
		midpoint: function ( target ) {
</P><P>			console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
			return this.getMidpoint( target );
</P><P>		},
		normal: function ( target ) {
</P><P>			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return this.getNormal( target );
</P><P>		},
		plane: function ( target ) {
</P><P>			console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
			return this.getPlane( target );
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Triangle, {
</P><P>		barycoordFromPoint: function ( point, a, b, c, target ) {
</P><P>			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return Triangle.getBarycoord( point, a, b, c, target );
</P><P>		},
		normal: function ( a, b, c, target ) {
</P><P>			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return Triangle.getNormal( a, b, c, target );
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Shape.prototype, {
</P><P>		extractAllPoints: function ( divisions ) {
</P><P>			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
			return this.extractPoints( divisions );
</P><P>		},
		extrude: function ( options ) {
</P><P>			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
			return new ExtrudeGeometry( this, options );
</P><P>		},
		makeGeometry: function ( options ) {
</P><P>			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
			return new ShapeGeometry( this, options );
</P><P>		}
</P><P>} );
</P><P>	Object.assign( Vector2.prototype, {
</P><P>		fromAttribute: function ( attribute, index, offset ) {
</P><P>			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );
</P><P>		},
		distanceToManhattan: function ( v ) {
</P><P>			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );
</P><P>		},
		lengthManhattan: function () {
</P><P>			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Vector3.prototype, {
</P><P>		setEulerFromRotationMatrix: function () {
</P><P>			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
</P><P>		},
		setEulerFromQuaternion: function () {
</P><P>			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
</P><P>		},
		getPositionFromMatrix: function ( m ) {
</P><P>			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );
</P><P>		},
		getScaleFromMatrix: function ( m ) {
</P><P>			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );
</P><P>		},
		getColumnFromMatrix: function ( index, matrix ) {
</P><P>			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );
</P><P>		},
		applyProjection: function ( m ) {
</P><P>			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
			return this.applyMatrix4( m );
</P><P>		},
		fromAttribute: function ( attribute, index, offset ) {
</P><P>			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );
</P><P>		},
		distanceToManhattan: function ( v ) {
</P><P>			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );
</P><P>		},
		lengthManhattan: function () {
</P><P>			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Vector4.prototype, {
</P><P>		fromAttribute: function ( attribute, index, offset ) {
</P><P>			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );
</P><P>		},
		lengthManhattan: function () {
</P><P>			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();
</P><P>		}
</P><P>	} );
</P><P>	//
</P><P>	Object.assign( Geometry.prototype, {
</P><P>		computeTangents: function () {
</P><P>			console.error( 'THREE.Geometry: .computeTangents() has been removed.' );
</P><P>		},
		computeLineDistances: function () {
</P><P>			console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( Object3D.prototype, {
</P><P>		getChildByName: function ( name ) {
</P><P>			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );
</P><P>		},
		renderDepth: function () {
</P><P>			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
</P><P>		},
		translate: function ( distance, axis ) {
</P><P>			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );
</P><P>		},
		getWorldRotation: function () {
</P><P>			console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );
</P><P>		}
</P><P>	} );
</P><P>	Object.defineProperties( Object3D.prototype, {
</P><P>		eulerOrder: {
			get: function () {
</P><P>				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;
</P><P>			}
		},
		useQuaternion: {
			get: function () {
</P><P>				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
</P><P>			},
			set: function () {
</P><P>				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
</P><P>			}
		}
</P><P>	} );
</P><P>	Object.defineProperties( LOD.prototype, {
</P><P>		objects: {
			get: function () {
</P><P>				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;
</P><P>			}
		}
</P><P>	} );
</P><P>	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {
</P><P>		get: function () {
</P><P>			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
</P><P>		},
		set: function () {
</P><P>			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
</P><P>		}
</P><P>	} );
</P><P>	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {
</P><P>		get: function () {
</P><P>			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;
</P><P>		},
		set: function ( value ) {
</P><P>			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;
</P><P>		}
</P><P>	} );
</P><P>	//
</P><P>	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {
</P><P>		console.warn( &quot;THREE.PerspectiveCamera.setLens is deprecated. &quot; +
				&quot;Use .setFocalLength and .filmGauge for a photographic setup.&quot; );
</P><P>		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );
</P><P>	};
</P><P>	//
</P><P>	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {
</P><P>				console.warn( 'THREE.Light: .onlyShadow has been removed.' );
</P><P>			}
		},
		shadowCameraFov: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;
</P><P>			}
		},
		shadowCameraLeft: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;
</P><P>			}
		},
		shadowCameraRight: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;
</P><P>			}
		},
		shadowCameraTop: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;
</P><P>			}
		},
		shadowCameraBottom: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;
</P><P>			}
		},
		shadowCameraNear: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;
</P><P>			}
		},
		shadowCameraFar: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;
</P><P>			}
		},
		shadowCameraVisible: {
			set: function () {
</P><P>				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
</P><P>			}
		},
		shadowBias: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;
</P><P>			}
		},
		shadowDarkness: {
			set: function () {
</P><P>				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
</P><P>			}
		},
		shadowMapWidth: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;
</P><P>			}
		},
		shadowMapHeight: {
			set: function ( value ) {
</P><P>				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;
</P><P>			}
		}
	} );
</P><P>	//
</P><P>	Object.defineProperties( BufferAttribute.prototype, {
</P><P>		length: {
			get: function () {
</P><P>				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;
</P><P>			}
		},
		copyIndicesArray: function ( /* indices */ ) {
</P><P>			console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );
</P><P>		}
</P><P>	} );
</P><P>	Object.assign( BufferGeometry.prototype, {
</P><P>		addIndex: function ( index ) {
</P><P>			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );
</P><P>		},
		addDrawCall: function ( start, count, indexOffset ) {
</P><P>			if ( indexOffset !== undefined ) {
</P><P>				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
</P><P>			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );
</P><P>		},
		clearDrawCalls: function () {
</P><P>			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();
</P><P>		},
		computeTangents: function () {
</P><P>			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
</P><P>		},
		computeOffsets: function () {
</P><P>			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
</P><P>		}
</P><P>	} );
</P><P>	Object.defineProperties( BufferGeometry.prototype, {
</P><P>		drawcalls: {
			get: function () {
</P><P>				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;
</P><P>			}
		},
		offsets: {
			get: function () {
</P><P>				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;
</P><P>			}
		}
</P><P>	} );
</P><P>	//
</P><P>	Object.assign( ExtrudeBufferGeometry.prototype, {
</P><P>		getArrays: function () {
</P><P>			console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );
</P><P>		},
</P><P>		addShapeList: function () {
</P><P>			console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );
</P><P>		},
</P><P>		addShape: function () {
</P><P>			console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );
</P><P>		}
</P><P>	} );
</P><P>	//
</P><P>	Object.defineProperties( Uniform.prototype, {
</P><P>		dynamic: {
			set: function () {
</P><P>				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
</P><P>			}
		},
		onUpdate: {
			value: function () {
</P><P>				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
				return this;
</P><P>			}
		}
</P><P>	} );
</P><P>	//
</P><P>	Object.defineProperties( Material.prototype, {
</P><P>		wrapAround: {
			get: function () {
</P><P>				console.warn( 'THREE.Material: .wrapAround has been removed.' );
</P><P>			},
			set: function () {
</P><P>				console.warn( 'THREE.Material: .wrapAround has been removed.' );
</P><P>			}
		},
		wrapRGB: {
			get: function () {
</P><P>				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();
</P><P>			}
		},
</P><P>		shading: {
			get: function () {
</P><P>				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );
</P><P>			}
		}
</P><P>	} );
</P><P>	Object.defineProperties( MeshPhongMaterial.prototype, {
</P><P>		metal: {
			get: function () {
</P><P>				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;
</P><P>			},
			set: function () {
</P><P>				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
</P><P>			}
		}
</P><P>	} );
</P><P>	Object.defineProperties( ShaderMaterial.prototype, {
</P><P>		derivatives: {
			get: function () {
</P><P>				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;
</P><P>			}
		}
</P><P>	} );
</P><P>	//
</P><P>	Object.assign( WebGLRenderer.prototype, {
</P><P>		clearTarget: function ( renderTarget, color, depth, stencil ) {
</P><P>			console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );
</P><P>		},
</P><P>		animate: function ( callback ) {
</P><P>			console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
			this.setAnimationLoop( callback );
</P><P>		},
</P><P>		getCurrentRenderTarget: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
			return this.getRenderTarget();
</P><P>		},
</P><P>		getMaxAnisotropy: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
			return this.capabilities.getMaxAnisotropy();
</P><P>		},
</P><P>		getPrecision: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
			return this.capabilities.precision;
</P><P>		},
</P><P>		resetGLState: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
			return this.state.reset();
</P><P>		},
</P><P>		supportsFloatTextures: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );
</P><P>		},
		supportsHalfFloatTextures: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );
</P><P>		},
		supportsStandardDerivatives: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );
</P><P>		},
		supportsCompressedTextureS3TC: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
</P><P>		},
		supportsCompressedTexturePVRTC: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
</P><P>		},
		supportsBlendMinMax: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );
</P><P>		},
		supportsVertexTextures: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
			return this.capabilities.vertexTextures;
</P><P>		},
		supportsInstancedArrays: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );
</P><P>		},
		enableScissorTest: function ( boolean ) {
</P><P>			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );
</P><P>		},
		initMaterial: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
</P><P>		},
		addPrePlugin: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
</P><P>		},
		addPostPlugin: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
</P><P>		},
		updateShadowMap: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
</P><P>		},
		setFaceCulling: function () {
</P><P>			console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );
</P><P>		}
</P><P>	} );
</P><P>	Object.defineProperties( WebGLRenderer.prototype, {
</P><P>		shadowMapEnabled: {
			get: function () {
</P><P>				return this.shadowMap.enabled;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;
</P><P>			}
		},
		shadowMapType: {
			get: function () {
</P><P>				return this.shadowMap.type;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;
</P><P>			}
		},
		shadowMapCullFace: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;
</P><P>			},
			set: function ( /* value */ ) {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
</P><P>			}
		}
	} );
</P><P>	Object.defineProperties( WebGLShadowMap.prototype, {
</P><P>		cullFace: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;
</P><P>			},
			set: function ( /* cullFace */ ) {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
</P><P>			}
		},
		renderReverseSided: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;
</P><P>			},
			set: function () {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
</P><P>			}
		},
		renderSingleSided: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;
</P><P>			},
			set: function () {
</P><P>				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
</P><P>			}
		}
</P><P>	} );
</P><P>	//
</P><P>	Object.defineProperties( WebGLRenderTarget.prototype, {
</P><P>		wrapS: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;
</P><P>			}
		},
		wrapT: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;
</P><P>			}
		},
		magFilter: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;
</P><P>			}
		},
		minFilter: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;
</P><P>			}
		},
		anisotropy: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;
</P><P>			}
		},
		offset: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;
</P><P>			}
		},
		repeat: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;
</P><P>			}
		},
		format: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;
</P><P>			}
		},
		type: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;
</P><P>			}
		},
		generateMipmaps: {
			get: function () {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;
</P><P>			},
			set: function ( value ) {
</P><P>				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;
</P><P>			}
		}
</P><P>	} );
</P><P>	//
</P><P>	Object.defineProperties( WebVRManager.prototype, {
</P><P>		standing: {
			set: function ( /* value */ ) {
</P><P>				console.warn( 'THREE.WebVRManager: .standing has been removed.' );
</P><P>			}
		},
		userHeight: {
			set: function ( /* value */ ) {
</P><P>				console.warn( 'THREE.WebVRManager: .userHeight has been removed.' );
</P><P>			}
		}
</P><P>	} );
</P><P>	//
</P><P>	Audio.prototype.load = function ( file ) {
</P><P>		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {
</P><P>			scope.setBuffer( buffer );
</P><P>		} );
		return this;
</P><P>	};
</P><P>	AudioAnalyser.prototype.getData = function () {
</P><P>		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();
</P><P>	};
</P><P>	//
</P><P>	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {
</P><P>		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );
</P><P>	};
</P><P>	//
</P><P>	var GeometryUtils = {
</P><P>		merge: function ( geometry1, geometry2, materialIndexOffset ) {
</P><P>			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
			var matrix;
</P><P>			if ( geometry2.isMesh ) {
</P><P>				geometry2.matrixAutoUpdate &amp;&amp; geometry2.updateMatrix();
</P><P>				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;
</P><P>			}
</P><P>			geometry1.merge( geometry2, matrix, materialIndexOffset );
</P><P>		},
</P><P>		center: function ( geometry ) {
</P><P>			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();
</P><P>		}
</P><P>	};
</P><P>	ImageUtils.crossOrigin = undefined;
</P><P>	ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {
</P><P>		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
</P><P>		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );
</P><P>		var texture = loader.load( url, onLoad, undefined, onError );
</P><P>		if ( mapping ) texture.mapping = mapping;
</P><P>		return texture;
</P><P>	};
</P><P>	ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {
</P><P>		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
</P><P>		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );
</P><P>		var texture = loader.load( urls, onLoad, undefined, onError );
</P><P>		if ( mapping ) texture.mapping = mapping;
</P><P>		return texture;
</P><P>	};
</P><P>	ImageUtils.loadCompressedTexture = function () {
</P><P>		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
</P><P>	};
</P><P>	ImageUtils.loadCompressedTextureCube = function () {
</P><P>		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
</P><P>	};
</P><P>	//
</P><P>	function Projector() {
</P><P>		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
</P><P>		this.projectVector = function ( vector, camera ) {
</P><P>			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );
</P><P>		};
</P><P>		this.unprojectVector = function ( vector, camera ) {
</P><P>			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );
</P><P>		};
</P><P>		this.pickingRay = function () {
</P><P>			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
</P><P>		};
</P><P>	}
</P><P>	//
</P><P>	function CanvasRenderer() {
</P><P>		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
</P><P>		this.domElement = document.createElementNS( '<A rel="nofollow" class="external free" href="http://www.w3.org/1999/xhtml'">http://www.w3.org/1999/xhtml'</A>, 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};
</P><P>	}
</P><P>	//
</P><P>	var SceneUtils = {
</P><P>		createMultiMaterialObject: function ( /* geometry, materials */ ) {
</P><P>			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );
</P><P>		},
</P><P>		detach: function ( /* child, parent, scene */ ) {
</P><P>			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );
</P><P>		},
</P><P>		attach: function ( /* child, scene, parent */ ) {
</P><P>			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );
</P><P>		}
</P><P>	};
</P><P>	//
</P><P>	function LensFlare() {
</P><P>		console.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );
</P><P>	}
</P><P>	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.ShaderLib = ShaderLib;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.FogExp2 = FogExp2;
	exports.Fog = Fog;
	exports.Scene = Scene;
	exports.Sprite = Sprite;
	exports.LOD = LOD;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Skeleton = Skeleton;
	exports.Bone = Bone;
	exports.Mesh = Mesh;
	exports.LineSegments = LineSegments;
	exports.LineLoop = LineLoop;
	exports.Line = Line;
	exports.Points = Points;
	exports.Group = Group;
	exports.VideoTexture = VideoTexture;
	exports.DataTexture = DataTexture;
	exports.DataTexture3D = DataTexture3D;
	exports.CompressedTexture = CompressedTexture;
	exports.CubeTexture = CubeTexture;
	exports.CanvasTexture = CanvasTexture;
	exports.DepthTexture = DepthTexture;
	exports.Texture = Texture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.DataTextureLoader = DataTextureLoader;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.TextureLoader = TextureLoader;
	exports.ObjectLoader = ObjectLoader;
	exports.MaterialLoader = MaterialLoader;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.LoadingManager = LoadingManager;
	exports.JSONLoader = JSONLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.FontLoader = FontLoader;
	exports.FileLoader = FileLoader;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.Cache = Cache;
	exports.AudioLoader = AudioLoader;
	exports.SpotLightShadow = SpotLightShadow;
	exports.SpotLight = SpotLight;
	exports.PointLight = PointLight;
	exports.RectAreaLight = RectAreaLight;
	exports.HemisphereLight = HemisphereLight;
	exports.DirectionalLightShadow = DirectionalLightShadow;
	exports.DirectionalLight = DirectionalLight;
	exports.AmbientLight = AmbientLight;
	exports.LightShadow = LightShadow;
	exports.Light = Light;
	exports.StereoCamera = StereoCamera;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.OrthographicCamera = OrthographicCamera;
	exports.CubeCamera = CubeCamera;
	exports.ArrayCamera = ArrayCamera;
	exports.Camera = Camera;
	exports.AudioListener = AudioListener;
	exports.PositionalAudio = PositionalAudio;
	exports.AudioContext = AudioContext;
	exports.AudioAnalyser = AudioAnalyser;
	exports.Audio = Audio;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.PropertyMixer = PropertyMixer;
	exports.PropertyBinding = PropertyBinding;
	exports.KeyframeTrack = KeyframeTrack;
	exports.AnimationUtils = AnimationUtils;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationClip = AnimationClip;
	exports.Uniform = Uniform;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.BufferGeometry = BufferGeometry;
	exports.Geometry = Geometry;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.Face3 = Face3;
	exports.Object3D = Object3D;
	exports.Raycaster = Raycaster;
	exports.Layers = Layers;
	exports.EventDispatcher = EventDispatcher;
	exports.Clock = Clock;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.LinearInterpolant = LinearInterpolant;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.CubicInterpolant = CubicInterpolant;
	exports.Interpolant = Interpolant;
	exports.Triangle = Triangle;
	exports.Math = _Math;
	exports.Spherical = Spherical;
	exports.Cylindrical = Cylindrical;
	exports.Plane = Plane;
	exports.Frustum = Frustum;
	exports.Sphere = Sphere;
	exports.Ray = Ray;
	exports.Matrix4 = Matrix4;
	exports.Matrix3 = Matrix3;
	exports.Box3 = Box3;
	exports.Box2 = Box2;
	exports.Line3 = Line3;
	exports.Euler = Euler;
	exports.Vector4 = Vector4;
	exports.Vector3 = Vector3;
	exports.Vector2 = Vector2;
	exports.Quaternion = Quaternion;
	exports.Color = Color;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.VertexNormalsHelper = VertexNormalsHelper;
	exports.SpotLightHelper = SpotLightHelper;
	exports.SkeletonHelper = SkeletonHelper;
	exports.PointLightHelper = PointLightHelper;
	exports.RectAreaLightHelper = RectAreaLightHelper;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.GridHelper = GridHelper;
	exports.PolarGridHelper = PolarGridHelper;
	exports.FaceNormalsHelper = FaceNormalsHelper;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.CameraHelper = CameraHelper;
	exports.BoxHelper = BoxHelper;
	exports.Box3Helper = Box3Helper;
	exports.PlaneHelper = PlaneHelper;
	exports.ArrowHelper = ArrowHelper;
	exports.AxesHelper = AxesHelper;
	exports.Shape = Shape;
	exports.Path = Path;
	exports.ShapePath = ShapePath;
	exports.Font = Font;
	exports.CurvePath = CurvePath;
	exports.Curve = Curve;
	exports.ImageUtils = ImageUtils;
	exports.ShapeUtils = ShapeUtils;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.ParametricBufferGeometry = ParametricBufferGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.TubeBufferGeometry = TubeBufferGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusBufferGeometry = TorusBufferGeometry;
	exports.TextGeometry = TextGeometry;
	exports.TextBufferGeometry = TextBufferGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.SphereBufferGeometry = SphereBufferGeometry;
	exports.RingGeometry = RingGeometry;
	exports.RingBufferGeometry = RingBufferGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneBufferGeometry = PlaneBufferGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.LatheBufferGeometry = LatheBufferGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapeBufferGeometry = ShapeBufferGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
	exports.EdgesGeometry = EdgesGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.ConeBufferGeometry = ConeBufferGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.CylinderBufferGeometry = CylinderBufferGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.CircleBufferGeometry = CircleBufferGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxBufferGeometry = BoxBufferGeometry;
	exports.ShadowMaterial = ShadowMaterial;
	exports.SpriteMaterial = SpriteMaterial;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.ShaderMaterial = ShaderMaterial;
	exports.PointsMaterial = PointsMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.Material = Material;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.BufferAttribute = BufferAttribute;
	exports.ArcCurve = ArcCurve;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.EllipseCurve = EllipseCurve;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.SplineCurve = SplineCurve;
	exports.REVISION = REVISION;
	exports.MOUSE = MOUSE;
	exports.CullFaceNone = CullFaceNone;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
	exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
	exports.BasicShadowMap = BasicShadowMap;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.FrontSide = FrontSide;
	exports.BackSide = BackSide;
	exports.DoubleSide = DoubleSide;
	exports.FlatShading = FlatShading;
	exports.SmoothShading = SmoothShading;
	exports.NoColors = NoColors;
	exports.FaceColors = FaceColors;
	exports.VertexColors = VertexColors;
	exports.NoBlending = NoBlending;
	exports.NormalBlending = NormalBlending;
	exports.AdditiveBlending = AdditiveBlending;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.MultiplyBlending = MultiplyBlending;
	exports.CustomBlending = CustomBlending;
	exports.AddEquation = AddEquation;
	exports.SubtractEquation = SubtractEquation;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.MinEquation = MinEquation;
	exports.MaxEquation = MaxEquation;
	exports.ZeroFactor = ZeroFactor;
	exports.OneFactor = OneFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.NeverDepth = NeverDepth;
	exports.AlwaysDepth = AlwaysDepth;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.EqualDepth = EqualDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterDepth = GreaterDepth;
	exports.NotEqualDepth = NotEqualDepth;
	exports.MultiplyOperation = MultiplyOperation;
	exports.MixOperation = MixOperation;
	exports.AddOperation = AddOperation;
	exports.NoToneMapping = NoToneMapping;
	exports.LinearToneMapping = LinearToneMapping;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
	exports.CineonToneMapping = CineonToneMapping;
	exports.UVMapping = UVMapping;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.SphericalReflectionMapping = SphericalReflectionMapping;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.LinearFilter = LinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.UnsignedByteType = UnsignedByteType;
	exports.ByteType = ByteType;
	exports.ShortType = ShortType;
	exports.UnsignedShortType = UnsignedShortType;
	exports.IntType = IntType;
	exports.UnsignedIntType = UnsignedIntType;
	exports.FloatType = FloatType;
	exports.HalfFloatType = HalfFloatType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.AlphaFormat = AlphaFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBAFormat = RGBAFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.RGBEFormat = RGBEFormat;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.RedFormat = RedFormat;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.LoopOnce = LoopOnce;
	exports.LoopRepeat = LoopRepeat;
	exports.LoopPingPong = LoopPingPong;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.LinearEncoding = LinearEncoding;
	exports.sRGBEncoding = sRGBEncoding;
	exports.GammaEncoding = GammaEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBDEncoding = RGBDEncoding;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.CubeGeometry = BoxGeometry;
	exports.Face4 = Face4;
	exports.LineStrip = LineStrip;
	exports.LinePieces = LinePieces;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MultiMaterial = MultiMaterial;
	exports.PointCloud = PointCloud;
	exports.Particle = Particle;
	exports.ParticleSystem = ParticleSystem;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Vertex = Vertex;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Int16Attribute = Int16Attribute;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float64Attribute = Float64Attribute;
	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
	exports.SplineCurve3 = SplineCurve3;
	exports.Spline = Spline;
	exports.AxisHelper = AxisHelper;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.EdgesHelper = EdgesHelper;
	exports.WireframeHelper = WireframeHelper;
	exports.XHRLoader = XHRLoader;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.GeometryUtils = GeometryUtils;
	exports.Projector = Projector;
	exports.CanvasRenderer = CanvasRenderer;
	exports.SceneUtils = SceneUtils;
	exports.LensFlare = LensFlare;
</P><P>	Object.defineProperty(exports, '__esModule', { value: true });
</P><P>})));</P></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
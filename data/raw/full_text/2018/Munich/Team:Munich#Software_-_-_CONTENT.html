<HTML lang="en" dir="ltr" class="client-nojs">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Team_Munich_Software skin-igem action-view"><DIV id="globalWrapper"><DIV id="content" class="mw-body" role="main"><DIV id="top_title"><H1 id="firstHeading" class="firstHeading"><SPAN dir="auto">Team:Munich/Software</SPAN></H1></DIV><DIV id="HQ_page"><DIV id="bodyContent"><DIV id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><P><TITLE>Phactory</TITLE></P><H5 class="d-inline ml-3">Phactory</H5><DIV class="collapse navbar-collapse justify-content-around" id="collapsibleNavbar"><UL class="navbar-nav"><LI id="homeButton" class="nav-item mx-3"><A class="nav-link" href="https://2018.igem.org/Team:Munich">HOME</A></LI><LI class="nav-item dropdown mx-3"><A class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
                            TEAM
                        </A><DIV class="dropdown-menu"><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Team">Team Members</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Collaborations">Collaborations</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Sponsors">Sponsors</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Attributions">Attributions</A></DIV></LI><LI class="nav-item dropdown mx-3"><A class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
                            PROJECT
                        </A><DIV class="dropdown-menu"><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Description">Description</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Design">Design</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Notebook">Notebook</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Protocols">Protocols</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/InterLab">InterLab</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Model">Model</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Results">Results</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Demonstrate">Demonstrate</A></DIV></LI><LI class="nav-item dropdown mx-3"><A class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
                            PARTS
                        </A><DIV class="dropdown-menu"><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Parts">Parts Overview</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Basic_Part">Basic Parts</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Improve">Improved Parts</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Composite_Part">Composite Parts</A></DIV></LI><LI class="nav-item mx-3"><A class="nav-link" href="https://2018.igem.org/Team:Munich/Safety">SAFETY</A></LI><LI class="nav-item dropdown mx-3"><A class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
                            HUMAN PRACTICES
                        </A><DIV class="dropdown-menu"><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Human_Practices">Human Practices</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Public_Engagement">Education &amp; Engagement</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Oracoli">Oracoli</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/European_Meetup">European Meetup</A></DIV></LI><LI class="nav-item dropdown mx-3"><A class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
                            AWARDS
                        </A><DIV class="dropdown-menu"><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Applied_Design">Applied Design</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Entrepreneurship">Entrepreneurship</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Hardware">Hardware</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Measurement">Measurement</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Model">Model</A><A class="dropdown-item" href="https://2018.igem.org/Team:Munich/Software">Software</A></DIV></LI><LI class="nav-item mx-3"><A class="nav-link" href="https://igem.org/2018_Judging_Form?team=Munich" target="_blank">JUDGING FORM ⇗</A></LI></UL></DIV><DIV class="pictureTitle container-fluid text-center mb-0 align-items-center text-light"><DIV class="display-2 mb-0">
        Software
    </DIV></DIV><DIV class="phaContainer"><MAIN class="post-content"><H1>sequ-into</H1><H2>Quality Control - Third Generation Sequencing Style</H2><DIV class="row"><DIV class="col-12"><P>
                    Phactory gives an alternative method to produce bacteriophages for therapytic usage, which meets
                    the good manufactering pratice.
                    A critacal point is the quallity of the bacteriophage DNA, which we could drastically improve up to
                    96%.
                    This was only possible through iterative engineering
                    cycles and many parts of our project fitting seamlessly together.
                </P><P>
                    With that said, any protocol optimization can only be as sophisticated as the quality control and
                    feedback loop is fine.
                    Furthermore, manufacturing at a certain quality standard can only ever be sustainable with the
                    corresponding quality controls in place. Allowing effortless testing, with clear results at the
                    earliest instant of time.
                </P><P>
                    To achieve that, we implemented sequ-into.
                </P><P>
                    Sequ-into, in the context of our project, detects contaminations in third generation sequencing
                    data in a highly sensitive manner. Our app brings wetlab sequencing experiments in close proximity
                    to
                    drylab analysis and is therefore the ideal feedback tool for the crucial quality control in
                    Phactory.
                </P><P>
                    Please find our git repository <A href="https://github.com/igemsoftware2018/igem_munich_2018">here</A>
                    and our IGEM Judging release <A href="https://github.com/igemsoftware2018/igem_munich_2018/releases/tag/1.0.0">here</A>.
                </P></DIV></DIV><H2>About sequ-into</H2><DIV class="row"><DIV class="col-12"><P>
                    Sequ-into is a cross-platform desktop application with a straightforward user experience, created
                    by the fusion of an intuitive
                    graphical interface with state-of-the-art long-read alignment software.
                </P><P>
                    Reads originating from unwanted sources are detected and summarized by a comprehensive statistical
                    overview,
                    but can also be filtered and exported in standardized FASTQ-format to facilitate custom evaluation
                    of experimental findings.
                    Additionally, it might be unclear whether a sequencing experiment produced reads of the intended
                    target. Therefore the filtering
                    we implemented also allows for a positive selection.
                </P></DIV></DIV><DIV class="card mt-2"><DIV class="card-header" id="headingFour" style="background-color: #018DCD;"><H5 class="mb-0"><BUTTON class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour"><SPAN class="text-white font-weight-bold">Why is sequ-into an notable addition to your third
                            generation sequencing routine?</SPAN></BUTTON></H5></DIV><DIV id="collapseFour" class="collapse" aria-labelledby="headingFour" data-parent="#accordion"><DIV class="card-body"><DIV class="row mt-2"><P>
                            Third generation sequencing techniques rapidly evolved as a common practice in molecular
                            biology. Great advances have been made in terms of feasibility, cost, throughput, and
                            read-length. However, sample contamination still poses a big issue: it complicates correct,
                            high-quality downstream analysis of sequencing data and usage in medical applications.
                        </P><BLOCKQUOTE class="quote-card blue-card"><P>
                                … our run times aren’t fixed, unlike the other systems. Some people even have what they
                                are looking for after a few minutes in real time, with success criteria not being based
                                on total yield and an en-run analysis.
                            </P><CITE>
                                Clive G. Brown, CTO of Oxford Nanopore
                            </CITE></BLOCKQUOTE><P>
                            This raises a simple question: How do you check if you have what we are looking for in a
                            quick and easy manner?
                        </P><P>
                            The question could also be rephrased to: Is our sequencing run contaminated? In contrast to
                            Illumina sequencing, in long read third generation sequencing (e.g PacBio or minION), there
                            is always the possibility to abort a sequencing procedure, redo the library preparation and
                            continue using the same chip. Especially when sequencing prokaryotic(-like) material, huge
                            contaminations of the sample are possible. These could either be human DNA/RNA from the
                            library prep, ribosomal RNA due to rRNA depletion not working, or even contamination from
                            other organisms (host organism for phages, etc.).
                        </P><P>
                            Thus the earlier such contaminations are detected, the better the sequencing chip can be
                            conserved for future use. Therefore we implemented sequ-into.
                        </P><P>
                            Especially since the library preparation and the sequencing are often in the hands of
                            trained life scientists, while the down-stream analysis on the other hand is performed by
                            trained computer scientists, there is often a gap in the workflow. Sequ-into aims to close
                            that gap as a convenient cross-platform tool, fusing an intuitive graphical-user-interface
                            with state-of-the-art long-read alignment software.
                        </P></DIV></DIV></DIV></DIV><DIV class="card mt-2"><DIV class="card-header" id="heading2" style="background-color: #018DCD;"><H5 class="mb-0"><BUTTON class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapse2" aria-expanded="false" aria-controls="collapse2"><SPAN class="text-white font-weight-bold">What can sequ-into help you with and what not?</SPAN></BUTTON></H5></DIV><DIV id="collapse2" class="collapse" aria-labelledby="heading2" data-parent="#accordion"><DIV class="card-body"><DIV class="row mt-2"><P>Sequ-into is not an application for a thorough interpretive analysis of your sequencing
                            data.
                        </P><P>
                            It can, however, be a very helpful addition to your sequencing lab routine. As it is easy
                            to install and to use without much prior knowledge necessary, it is ideal for the very
                            first assessment of your sequencing files.
                        </P><P>
                            In particular it allows you to quickly tell whether your sequenced reads represent what you
                            aimed for to sequence or if your reads in fact stem from an unwanted source. Thus allowing
                            for a fast reaction during long sequencing experiments and early alterations in your
                            protocol in the laboratory prior to sequencing.
                        </P><P>
                            Later on, you might want to further investigate your sequencing data. Here, the extraction
                            function of sequ-into offers the possibility to save reads of a wanted source or unwanted
                            sources separately. Even the filtering by many possible contaminations at once is possible.
                            All this while GraphMap, the tool we employed for this in the background, is highly
                            sensitive and specialized for the utilization with third generation sequencing techniques.
                        </P></DIV></DIV></DIV></DIV><H2>How to use sequ-into</H2><DIV class="row"><DIV class="col-12 col-md-12"><P>
                    The philosophy behind sequ-into is to to bring a sophisticated bioinformatic tool as close
                    to the wetlab as possible.
                </P><P>
                    We wanted to set the entry point to use our software as low as possible.
                    Therefore we created an introductory <A href="https://www.youtube.com/watch?v=kJvXKR10pBE">YouTube</A>
                    video, that shows the installation on a Mac OS System.
                    It furthermore is an deatiled introduction of the whole functionality of sequ-into - which is the
                    same on Windows and Unix Systems, the interpretation of the results and usage of the read-filtering
                    option.
                </P><P>
                    The user will also find comprehensive information on the installation, employed packages and
                    structure of sequ-into on our <A href="https://sequ-into.readthedocs.io/en/latest/index.html">
                        documentation</A>.
                </P></DIV></DIV><DIV class="row"><DIV class="col-12"><FIGCAPTION class="figure-caption">Download the app <A href="https://github.com/igemsoftware2018/igem_munich_2018/releases/tag/1.0.0">here</A>.</FIGCAPTION></DIV></DIV><DIV class="card mt-2"><DIV class="card-header" id="heading3" style="background-color: #018DCD;"><H5 class="mb-0"><BUTTON class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapse3" aria-expanded="false" aria-controls="collapse3"><SPAN class="text-white font-weight-bold">User Guide</SPAN></BUTTON></H5></DIV><DIV id="collapse3" class="collapse" aria-labelledby="heading3" data-parent="#accordion"><DIV class="card-body"><DIV class="row mt-2"><H3>How to get sequ-into?
                        </H3><P>You can use sequ-into on a Mac OS, Linux as well as on a Windows System. Please
                                    follow the respective
                                    instructions in our <A href="https://sequ-into.readthedocs.io/en/latest/install.html#installguide">Installation
                                        guide</A>.
                                </P><H3>Get started
                                </H3><H4>Step 1: Read files
                                </H4><P>FastQ, as well as Fast5, are suitable formats for evaluating your sequencing data
                                    with sequ-into.
                                </P><P>In the first step, you can choose which files you would like to seek into. Each
                                    chosen file or folder will
                                    be handled separately. This is also true if you upload them twice.
                                </P><P>If you wish to examine certain reads together, e.g. because they stem from the same
                                    experiment, make sure to
                                    save them in a folder and upload that folder via Choose Directory. In order to
                                    analyze a single file,
                                    upload it via Choose File.
                                </P><P>As soon as you have chosen your files an output directory will be generated. You
                                    will find a temp folder
                                    where your read files reside. You can change that output directory and folder name
                                    at the bottom of the
                                    page if you click on the text field.
                                </P><P>After that, click Next to proceed.

                                </P><H3>Step 2: Reference files
                                </H3><P>To check what your sequencing files truly consist of you need a reference against
                                    which the reads will be
                                    mapped.
                                </P><P>That reference might be a possible contamination, such as E. Coli, or a targeted
                                    known genome of what you
                                    intended to sequence. Of course, you can also use shorter sequences instead of a
                                    whole genome as a
                                    reference. For details on possible technical limitations, please see <A href="https://github.com/isovic/graphmap">GraphMap</A>
                                    and
                                    <A href="https://www.nature.com/articles/ncomms11307">Nature
                                        Communications</A>.
                                </P><P>Mapping is possible against RNA as well as against DNA sequences, as long as they
                                    are in the FastA Format.
                                    You can find sequences for example on <A href="https://www.ncbi.nlm.nih.gov/genome/?term=">NCBI</A>
                                    .
                                </P><P>Click on Choose Reference to choose your reference files. You can select as many
                                    files as you wish. These
                                    files will still be present after you used Reset, but are deleted when you close
                                    the application.

                                </P><P>If you work with certain references repeatedly they can also be saved in the app so
                                    that they are available
                                    every time even after you closed sequ-into. Simply Save Contaminants. Your own
                                    references can always be
                                    deleted from sequ-into later on, just click the trash can to do so.
                                </P><P><STRONG>Keep in mind that calculation time increases with file size and file
                                        quantity!</STRONG> Consider
                                    using the switches behind each reference to turn them off if you don’t need them
                                    for your current run. They
                                    will still be available after you used Reset.
                                </P><P>After that, click Start to run the calculations.
                                </P><H3>Step 3: Results
                                </H3><P>The Results consist of two sections: a statistical overview on how your reads mapped
                                    to the reference(s) and
                                    the filter to extract and save only those reads you need for your downstream
                                    analysis.

                                </P><H3>Section 1:
                                </H3><P>For each combination of FastQ (file/directory) with FastA you will find one table
                                    and three plots.

                                </P><P>The table includes read and base frequencies in the reference FastA file. For reads,
                                    you receive the
                                    information about aligned or not aligned reads. It is not always sufficient enough
                                    to rely only on reads in
                                    the further analysis. The different read sizes can cause the wrong interpretation
                                    of the data: three
                                    contaminated reads of length 50 bp or 5000 bp make a big difference despite the
                                    fact that there is three of
                                    them in both cases. For making proper conclusions about the data it is useful to
                                    take a look on the bases
                                    as well. For bases, it is important to note that there are two different
                                    definitions: alignment bases and
                                    aligned bases.

                                </P><P>Aligned reads consist out of bases. These bases are called the aligned bases. On the
                                    other hand, the bases
                                    that are indeed aligned, means mapped to the base in the reference and are not
                                    skipped, are called
                                    alignment bases.

                                </P><P>To support the statistical information in the table visually we also added two pie
                                    charts that correspond to
                                    the relative and absolute values in the table. These two plots will help you to
                                    gain information about the
                                    number of bases and reads that were found in a reference file and make a conclusion
                                    about the possibility
                                    of contamination.
                                </P><P>
                                    Additionally, there is a bar plot representing the distribution of the read length
                                    in the FastQ file you
                                    uploaded. This chart could be used for evaluation of the quality of sequencing or
                                    even be helpful by
                                    evolving theories about files with filtered reads. For your сonvenience <STRONG>all
                                        plots are saved in the
                                        output directory</STRONG> specified in Step 1.
                                </P><H3>Section 2:
                                </H3><P>In the section below you will find a filter which you can optionally use to extract
                                    and save distinguish
                                    parts of the read FastQ file: reads that were mapped to the reference (aligned
                                    switch) and those which were
                                    not (not aligned switch), in other words possibly contaminated reads and reads that
                                    can be used for
                                    downstream analysis (in case the reference FastA file you used is a possible
                                    contaminant. If you added the
                                    FastA file of the organism you expect to sequence, not aligned reads are
                                    contamination).

                                </P><P>
                                    If you uploaded multiple references files one more filter will appear (All
                                    references): filter of reads
                                    that are aligned to <STRONG>all</STRONG> references or reads that are aligned to
                                    <STRONG>none</STRONG> of
                                    the references.
                                </P><P>With this filter, it is possible to refine sequencing data and consequently, achieve
                                    preferable results by
                                    downstream analysis. It can also give you a hint about the origin of the possible
                                    contamination, as the
                                    reads that are not mapped to the expected organism can be checked with <A href="https://blast.ncbi.nlm.nih.gov/Blast.cgi">BLAST</A>.
                                </P><P>Once again all files will be saved in your output directory specified in Step 1.
                              </P></DIV></DIV></DIV></DIV><H2>How sequ-into works</H2><DIV class="row"><DIV class="col-12"><P>
                    We brought together a straightforward intuitive interface built with <A href="https://electronjs.org">Electron</A>
                    and <A href="https://reactjs.org">React</A>, that gives the
                    user easy access to the state-of-the-art long read alignment tool <A href="https://www.nature.com/articles/ncomms11307">GraphMap</A>
                    which itself is highly specialized for nanopore sequencing.
                </P><P>
                    To make this possible we run a python script in the background that relies on <A href="https://htseq.readthedocs.io/en/release_0.10.0/">HTSeq</A>
                    as
                    infrastructure for
                    high-throughput data and <A href="https://pysam.readthedocs.io/en/latest/">pysam</A> to handle the genomic
                    data sets.
                </P></DIV></DIV><DIV class="card mt-2"><DIV class="card-header" id="heading7" style="background-color: #018DCD;"><H5 class="mb-0"><BUTTON class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapse7" aria-expanded="false" aria-controls="collapse7"><SPAN class="text-white font-weight-bold">Sequ-Into In Detail</SPAN></BUTTON></H5></DIV><DIV id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordion"><DIV class="card-body"><DIV class="row mt-2"><DIV class="row"><DIV class="col-12"><P>Sequ-into has the aim of bringing the sequencing data analysis and the laboratory
                                    protocol optimization in
                                    close proximity.
                                </P><P>While highly specialized tools and pipelines for third generation sequencing data
                                    analysis are available,
                                    they often are not handy nor convenient to use as a first assessment right after or
                                    during the sequencing
                                    run.
                                </P><P>As a possible solution we brought together a straightforward intuitive interface
                                    built with <A href="https://electronjs.org/">Electron</A>
                                    and <A href="https://reactjs.org/">React</A>
                                    , that gives the user easy access to the state-of-the-art long read alignment tool
                                    <A href="https://www.nature.com/articles/ncomms11307">GraphMap</A>
                                    which itself is highly specialized for nanopore sequencing.
                                </P><P>To make this possible we run a python script in the background that relies on <A href="https://htseq.readthedocs.io/en/release_0.10.0/">HTSeq</A>
                                    as infrastructure for high-throughput data and <A href="https://pysam.readthedocs.io/en/latest/">pysam</A>
                                    to handle the genomic data sets.
                                </P><H3>What does sequ-into do?
                                </H3><P>In order to be able to draw conclusions of the sequencing quality in general and the
                                    composition of the data
                                    - in terms of contaminations versus the true sequencing traget - the reads are
                                    mapped to references. The
                                    reference being either a possible contamination, leaving your desired reads
                                    unaligned, or your target
                                    sequence, meaning your designated reads are the ones that did align. The
                                    distribution of read length from
                                    the original files and the results of these alignments are then elucidated in a
                                    statistical overview and
                                    employed to separate those reads you aimed for from those that were sequenced
                                    involuntary.
                                </P><H3>How does sequ-into achieve this?
                                </H3><H3>From a Typescript interface to functionality
                                </H3><P>The user interface of sequ-into is based on Electron and React and written in
                                    Typescript. However, the
                                    functionality of our app depends on a python script (<A href="https://sequ-into.readthedocs.io/en/latest/methods.html#contamtool-py">ContamTool.py</A>)
                                    in the background, that must be called according to the users request.
                                </P><H4>
                                    Read Files
                                </H4><P>
                                    Sequ-into is able to deal with both, the FastQ as well as the Fast5 format. If the
                                    latter is used, we
                                    extract the base called sequences and convert them into the FastQ format.

                                </P><P>Thanks to the fact that the Fast5 format is in fact <A href="https://support.hdfgroup.org/HDF5/">HDF5</A>,
                                    a
                                    file format that can contain an unlimited variety of datatypes while allowing for
                                    input/output of complex
                                    data, it was possible to manipulate the files with the <A href="https://www.h5py.org/">h5py</A>
                                    python
                                    interface efficiently. To prevent excessive runtimes of our app, there is currently
                                    a processing limit of
                                    1000 reads per Fast5 file.
                                </P></DIV></DIV><CODE>
                                        return OrderedDict([
                                        (Fast5TYPE.BASECALL_2D, '/Analyses/Basecall_2D_%03d/'),
                                        (Fast5TYPE.BASECALL_1D_COMPL, '/Analyses/Basecall_1D_%03d/'),
                                        (Fast5TYPE.BASECALL_1D, '/Analyses/Basecall_1D_%03d/'),
                                        (Fast5TYPE.BASECALL_RNN_1D, '/Analyses/Basecall_RNN_1D_%03d/'),
                                        (Fast5TYPE.BARCODING, '/Analyses/Barcoding_%03d/'),
                                        (Fast5TYPE.PRE_BASECALL, '/Analyses/EventDetection_%03d/')
                                    ])</CODE><DIV class="row"><DIV class="col-12"><P>
                                    After acquiring the sequenced data meant to be analyzed, sequ-into handles each
                                    uploaded file/folder as a
                                    separated call. In the case of a folder, sequ-into searches for each file in that
                                    directory down to the
                                    deepest level of the directory tree.
                                </P></DIV></DIV><CODE>
                                        self.state.inputFiles.forEach(element =&gt; {
                                            var stats = fs.lstatSync(element.path)
                                            if (stats.isDirectory()){
                                                var allFilesInDir = fs.readdirSync(element.path);
                                                processFilesForElement[element.path] = [];
                                                allFilesInDir.forEach((myFile:any) =&gt; {
                                                    if(myFile.toUpperCase().endsWith(&quot;FASTQ&quot;) || myFile.toUpperCase().endsWith(&quot;FQ&quot;)){
                                                        var pathToFile = self.normalizePath(path.join(element.path, myFile));                                              processFilesForElement[element.path].push(pathToFile)
                                                    }
                                                });
                                                if (processFilesForElement[element.path].length == 0){
                                                   self.extractReadsForFolder(element.path);
                                                }
                                            }else{
                                                processFilesForElement[element.path] = [self.normalizePath(element.path)];
                                            }
                                        });</CODE><DIV class="row"><DIV class="col-12"><P>All files that are pooled in a folder are handled as one file in the further steps
                                    (ContamTool.py),
                                    resulting in a combined analysis of all the files in that folder.

                                </P><H4>Reference Files

                                </H4><P>The next step is to acquire the FastA files that are used as a reference for the
                                    alignment. As the user
                                    might have similar requests repeatedly, it is possible to save reference files in
                                    the app itself. To make
                                    these files available even after the app is closed, we use a <A href="https://www.json.org/">JSON</A>
                                    file
                                    to store their paths internally together with our default genome of <I>Escherichia
                                        coli K-12 MG1655</I>.

                                </P><H4>Cross Plattform Compatibility</H4><P>Now that the required data is accessible, the python script (<A href="https://sequ-into.readthedocs.io/en/latest/methods.html#contamtool-py">ContamTool.py</A>)
                                    handling the alignment, calculation and plotting can be called.
                                </P><P>As the <A href="https://sequ-into.readthedocs.io/en/latest/methods.html#alignment-tool">alignment-tool</A>
                                    we employed in our python script runs asynchron but since we have to make several
                                    calls for the
                                    functionality of sequ-into, one for each file per reference, we call the python
                                    script sequential.

                                </P></DIV></DIV><CODE style="width: 100%">
                                        child = spawnSync(
                                            program,
                                            programArgs,
                                                {
                                                    cwd: process.cwd(),
                                                    env: process.env,
                                                    stdio: 'pipe',
                                                    encoding: 'utf-8',
                                                    shell: useShell
                                                })</CODE><DIV class="row"><DIV class="col-12"><P>
                                    To facilitate this on every platform sequ-into formulates the call command
                                    accordingly.

                                </P><P>For a Unix system, this is simply:

                                </P></DIV></DIV><CODE style="width: 100%">
                                        var splitted_command = command.split(&quot; &quot;);
                                        program = &quot;python3&quot;;
                                        programArgs = splitted_command;
                                        useShell = true;</CODE><DIV class="row"><DIV class="col-12"><P>For Mac OS, the explicit PATH variable containing the location of the programs must
                                    be added manually:

                                </P></DIV></DIV><CODE style="width: 100%">
                                        var np = shellPath.sync();
                                        process.env.PATH = np;</CODE><DIV class="row"><DIV class="col-12"><P>On Windows, however, it is necessary to make the call WSL compatible:
                                </P></DIV></DIV><CODE style="width: 100%">
                                        var splitCmd = [&quot;-i&quot;, &quot;-c&quot;, &quot;python3 &quot; + command];
                                        program = &quot;bash&quot;;
                                        programArgs = splitCmd;
                                        useShell = false;</CODE><DIV class="row"><DIV class="col-12"><H4>Script Output

                                </H4><P>The output of each python call - that is for each file per reference - is collected
                                    via another JSON file
                                    data structure. More details <A href="https://sequ-into.readthedocs.io/en/latest/methods.html#here">here</A>.

                                </P><H3>ContamTool.py

                                </H3><P>As mentioned above the functionality of sequ-into depends on the python script
                                    ContamTool.py which assesses
                                    the input read files, coordinates the alignment, interprets the alignment results
                                    and allows for read
                                    extraction according to the gained knowledge.

                                </P><H4>Read File Handling

                                </H4><P>All files that are pooled in a folder are handled as one FastQ file in the further
                                    steps to make the
                                    combined analysis possible.

                                </P></DIV></DIV><CODE style="width: 100%">
                                        fastqFile = os.path.join(output_dir, prefix + &quot;complete.fastq&quot;)
                                        os.system(&quot;cat &quot; + ' '.join(read_file) + &quot; &gt; &quot; + fastqFile)</CODE><DIV class="row"><DIV class="col-12"><P><A href="https://htseq.readthedocs.io/en/release_0.10.0/">HTSeq</A> allows for an
                                    efficient iteration over
                                    all reads from the now single input file.
                                </P></DIV></DIV><CODE style="width: 100%">
                                            reads = HTSeq.FastqReader(read_file)
                                            for read in reads:
                                                    ...</CODE><DIV class="row"><DIV class="col-12"><H4>Calling the Alignment Tool GraphMap

                                </H4><P>The idea behind sequ-into that enables finding possible contaminations and deciding
                                    if a certain target was
                                    sequenced, respectively, is to map the raw reads from the sequencing files against
                                    a reference. Thus
                                    allowing to split the original joint read file into two categories: the reads that
                                    aligned to the reference
                                    and those that did not.

                                </P><P>Nanopore sequencing data, however, comes with certain obstacles that complicate
                                    alignments. On the one hand,
                                    because of Nanopores high-throughput nature, the data size means that alignment
                                    algorithms commonly used
                                    are too slow - something that was overcome only with a tradeoff to lower
                                    sensitivity. On the other hand,
                                    the variable error profile of ONT MinION sequencers made parameter tuning mandatory
                                    to gain high
                                    sensitivity and precision. What makes sequ-into a reliable tool nevertheless, is
                                    GraphMap. This mapping
                                    algorithm is specifically designed to analyse nanopore sequencing reads, while it
                                    handles potentially
                                    high-error rates robustly and aligns long reads with speed and high precision
                                    thanks to a fast graph
                                    traversal. (<A href="https://www.nature.com/articles/ncomms11307">Nature 2016,
                                        Sovic et al.</A>)

                                </P><P>For each reference, GraphMap is called with the input read file, generating a <A href="https://samtools.github.io/hts-specs/SAMv1.pdf">Sequence
                                        Alignment Map</A>.

                                </P></DIV></DIV><CODE style="width: 100%">
                                        for file in cont_file:
                                        sam_file_name = os.path.split(file)[1][:-6]+&quot;.sam&quot;
                                        samFile = os.path.join(output_dir,prefix + sam_file_name)
                                        os.system(&quot;graphmap align -r &quot;+file+&quot; -d &quot;+read_file+&quot; -o &quot;+samFile)</CODE><DIV class="row"><DIV class="col-12"><H3>Evaluating the GraphMap Output</H3><P>With the pysam interface it is now easy to count the features of interest directly
                                    from the corresponding
                                    sam file for each reference:
                                </P></DIV></DIV><CODE style="width: 100%">
                                        for aln in samFile:
                                        totalBases += len(aln.seq)
                                        totalReads += 1
                                        if not aln.is_unmapped:
                                                alignmentBases += aln.alen
                                                alignedLength += len(aln.seq)
                                                alignedReads += 1</CODE><DIV class="row"><DIV class="col-12"><P>ContamTool.py Output

                                </P><P>The read file is assest for each reference. ContamTool.py produces three images per
                                    reference from the
                                    generated data. A read length distribution of the original FastQ file/ files and
                                    two pie charts showing the
                                    percentage of aligned and not aligned reads or bases. The collected data, as well
                                    as the paths to the
                                    images are dumped in a JSON file for easy handling in the further steps.

                                </P></DIV></DIV><CODE style="width: 100%">
                                        {
                                            &quot;/pathToReference/ecoli_k12_mg1655.fasta&quot;:
                                                {
                                                    &quot;totalReads&quot;: 7,
                                                    &quot;alignedReads&quot;: 0,                              &quot;totalBases&quot;: 62387,
                                                    &quot;alignmentBases&quot;: 0,
                                                    &quot;alignedLength&quot;: 0,
                                                    &quot;idAlignedReads&quot;: [],
                                                    &quot;idNotAlignedReads&quot;: [&quot;c9a72623-c55c-4464-ac5e-d1e70cea8466&quot;, &quot;4b57cb5c-0c3d-4650-9d57-c94cf4aea2ef&quot;, ...],
                                                    &quot;readLengthPlot&quot;: &quot;/outputPath/file2_ecoli_k12_mg1655_ref1_ref2_reads_length.png&quot;,
                                                    &quot;readsPie&quot;: &quot;/outputPath/file2_ecoli_k12_mg1655_ref1_ref2_read_pie.png&quot;,
                                                    &quot;basesPie&quot;: &quot;/outputPath/file2_ecoli_k12_mg1655_ref1_ref2_bases_pie.png&quot;,
                                                    &quot;refs&quot;: [&quot;/pathToReference/ecoli_k12_mg1655.fasta&quot;]},
                                            &quot;/pathToReference/ref1.fasta&quot;:
                                                {
                                                    &quot;totalReads&quot;: 7,
                                                    &quot;alignedReads&quot;: 0,
                                                    ...},
                                            &quot;/pathToReference/ref2.fasta&quot;:
                                                {
                                                    &quot;totalReads&quot;: 7,
                                                    &quot;alignedReads&quot;: 0,
                                                    ...}</CODE><DIV class="row"><DIV class="col-12"><H4>Extracting Read Files

                                </H4><P>Besides the contamination evaluation, sequ-into furthermore allows for a separation
                                    of the reads into the
                                    ones that aligned to the reference versus the ones that that did not align. It
                                    generates new FastQ files
                                    according to the users inquiry which can then be used in a more elaborate
                                    downstream analysis. One notable
                                    possibility that sequ-into offers, is the extraction of reads against several
                                    references at once. Exporting
                                    only those reads in the end that represent the intersection (red) of reads aligned
                                    against all references
                                    or none, according to set theory.

                                </P></DIV></DIV></DIV></DIV></DIV></DIV><H2>Sequencing Results</H2><DIV class="row"><DIV class="col-12"><P>
                    We have found two main results with our app.
                </P><P>
                    First, using our tool the wetlab part of our project could reduce the amount of
                    contamination significantly to less than 2% of the reads as one can see in the
                    following plots. This was a valuable step for Phactory as high contamination levels impair phage
                    assembly in a TX/TL system.
                </P></DIV></DIV><DIV class="row"><DIV class="col-12 col-md-6"><FIGURE class="figure"><FIGCAPTION class="figure-caption">Shown is the percentage of reads of the 3S sequencing
                        experiment that did not align against the 3S phage genome across different purification
                        protocols.</FIGCAPTION></FIGURE></DIV><DIV class="col-12 col-md-6"><FIGURE class="figure"><FIGCAPTION class="figure-caption">Shown is the percentage of reads of the 3S sequencing
                        experiment that did align against the E. Coli genome, across different purification
                        protocols. </FIGCAPTION></FIGURE></DIV></DIV><DIV class="row"><DIV class="col-12"><P>
                    Second, we noticed that running Sequ-Into on only a very first subset of the
                    sequenced reads is sufficient to get an upper bound of the expected contamination.
                    Thus only using the first 1000 reads of a sequencing experiment is enough to
                    determine how well the library preparation worked.
                    Moreover we noticed that the contamination usually has a lower average read length,
                    and is higher in the very beginning of each sequencing experiment.
                    On the first sight this seems to be surprising. Possible explanations are secondary
                    structure effects of longer reads, making the longer reads drop down faster than
                    shorter reads.
                </P></DIV></DIV><DIV class="row"><DIV class="col-12 col-md-6"><FIGURE class="figure"><FIGCAPTION class="figure-caption">More non-target reads sequenced in the first 10%
                                of the sequencing time of each experiment.</FIGCAPTION></FIGURE></DIV><DIV class="col-12 col-md-6"><FIGURE class="figure"><FIGCAPTION class="figure-caption">Also in the first x sequenced reads.</FIGCAPTION></FIGURE></DIV></DIV><DIV class="row"><DIV class="col-12"><P>
                    For more details on how our software influenced Phactory: Please visit <A href="https://2018.igem.org/Team:Munich/Measurement#title_3">Measurement</A>
                    and <A href="https://2018.igem.org/Team:Munich/Results#title_3">Data Analysis</A></P></DIV></DIV><H2>References</H2><DIV id="phareferences" class="row"><DIV class="col-12"><OL><LI><A href="https://www.nature.com/articles/ncomms11307"> Sovic, I., Šikić, M., Wilm, A., Fenlon,
                            S.N., Chen, S.L., &amp; Nagarajan, N. (2016). Fast and sensitive mapping of nanopore sequencing
                            reads with GraphMap. Nature communications, 7, 11307.</A></LI><LI><A href="https://doi.org/10.1093/bfgp/elr035"> Zhenyu Li, Yanxiang Chen, Desheng Mu, Jianying
                            Yuan, Yujian Shi, Hao Zhang, Jun Gan, Nan Li, Xuesong Hu, Binghang Liu, Bicheng Yang, Wei
                            Fan; Comparison of the two major classes of assembly algorithms: overlap–layout–consensus
                            and de-bruijn-graph, Briefings in Functional Genomics, Volume 11, Issue 1, 1 January 2012,
                            Pages 25–37.
                        </A></LI><LI><A href="https://doi.org/10.1093/bioinformatics/btu638"> Simon Anders, Paul Theodor Pyl,
                            Wolfgang Huber
                            HTSeq — A Python framework to work with high-throughput sequencing data
                            Bioinformatics (2014)</A></LI><LI><A href="https://github.com/irath96/electron-react-typescript-boilerplate">
                            electron-react-typescript-boilerplate by iRath96</A></LI></OL></DIV></DIV></MAIN></DIV></DIV></DIV></DIV></DIV></DIV></BODY></HTML>
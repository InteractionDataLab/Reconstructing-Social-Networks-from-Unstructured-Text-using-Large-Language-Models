<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Cambridge_luminanceSourceCode"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:Cambridge/luminanceSourceCode">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Cambridge/luminanceSourceCode&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Cambridge/luminanceSourceCode&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Cambridge/luminanceSourceCode&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Cambridge/luminanceSourceCode" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Cambridge/luminanceSourceCode</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2010.igem.org</H3><DIV id="wrap"><DIV id="left"><UL id="accmenu"><LI><A class="head" href="#"> Introduction</A></LI><LI><A href="/Team:Cambridge">Home</A></LI><LI><A href="/Team:Cambridge/TheTeam">Meet the Team</A></LI><LI><A href="/Team:Cambridge/Photos">Photo Gallery</A></LI><LI><A href="/Team:Cambridge/Videos">Videos</A></LI><LI><A href="/Team:Cambridge/BioBricks">Parts submitted</A></LI></UL><LI><A class="head" href="#">Project Firefly</A></LI><LI><A href="/Team:Cambridge/Bioluminescence">Introduction</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Background_Firefly">Background</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Colour">Coloured outputs</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Luciferin_Regeneration">Luciferin recovery</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Firefly_Modelling">Modelling</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Firefly_Characterisation">Characterisation</A></LI><LI><A class="head" href="#">Project Vibrio</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Bacterial_Luciferases">Introduction</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Background">Background</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/G28">The LuxBrick</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Bacterial_Codon_optimisation">Codon optimisation</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Vibrio_Modelling">Modelling</A></LI><LI><A href="/Team:Cambridge/Bioluminescence/Vibrio_Characterisation">Characterisation</A></LI><LI><A class="head" href="#">Tools</A></LI><LI><A href="/Team:Cambridge/Tools/Gibson">Gibthon</A></LI><LI><A href="/Team:Cambridge/Tools/GenBank">BioBrick → GenBank</A></LI><LI><A href="/Team:Cambridge/Tools/Ligate">Ligation Calculator</A></LI><LI><A href="/Team:Cambridge/Tools/Eglometer">The E.glometer</A></LI><LI><A class="head" href="#">Gibson Assembly</A></LI><LI><A href="/Team:Cambridge/Gibson/Introduction">Introduction</A></LI><LI><A href="/Team:Cambridge/Gibson/Mechanism">How it works</A></LI><LI><A href="/Team:Cambridge/Gibson/Protocol">Protocol</A></LI><LI><A href="/Team:Cambridge/Gibson/RFC">RFC</A></LI><LI><A class="head" href="#">Considerations</A></LI><LI><A href="/Team:Cambridge/Human_Practices">Human Practices</A></LI><LI><A href="/Team:Cambridge/Safety">Safety</A></LI><LI><A class="head" href="#">Future applications</A></LI><LI><A href="/Team:Cambridge/Tools/microMeasure">Biosensors</A></LI><LI><A href="/Team:Cambridge/Tools/Lighting">Lighting</A></LI><LI><A class="head" href="/Team:Cambridge/Notebook/Week1">Notebook</A></LI><LI><A href="/Team:Cambridge/Notebook/Summary">Summary</A></LI><LI><A href="/Team:Cambridge/Notebook/Week1">Week 1</A></LI><LI><A href="/Team:Cambridge/Notebook/Week2">Week 2</A></LI><LI><A href="/Team:Cambridge/Notebook/Week3">Week 3</A></LI><LI><A href="/Team:Cambridge/Notebook/Week4">Week 4</A></LI><LI><A href="/Team:Cambridge/Notebook/Week5">Week 5</A></LI><LI><A href="/Team:Cambridge/Notebook/Week6">Week 6</A></LI><LI><A href="/Team:Cambridge/Notebook/Week7">Week 7</A></LI><LI><A href="/Team:Cambridge/Notebook/Week8">Week 8</A></LI><LI><A href="/Team:Cambridge/Notebook/Week9">Week 9</A></LI><LI><A href="/Team:Cambridge/Notebook/Week10">Week 10</A></LI><LI><A href="/Team:Cambridge/Notebook/Week11">Week 11</A></LI><LI><A href="/Team:Cambridge/Notebook/Week12">Week 12</A></LI><LI><A href="/Team:Cambridge/Notebook/FurtherWork">Beyond Week 12</A></LI><LI><A href="/Team:Cambridge/Protocols">Protocols</A></LI><LI><A href="/Team:Cambridge/Partners" class="head">Our Partners</A></LI><LI><A href="/Team:Cambridge/Partners">Sponsors</A></LI><LI><A href="/Team:Cambridge/iGEM_Teams">iGEM Teams</A></LI><LI><A href="/Team:Cambridge/Departments">University</A></LI><LI><A href="/Team:Cambridge/Publicity">Publicity</A></LI></DIV><DIV id="right"><DIV style="width:730px; background-color:#96d446;" class="secheader">Source Code for Luminance calculator</DIV><DIV class="contwrap"><P>This program calculates the conversion factor between your total radiant output intensity and your luminance output intensity.
</P><P>To use this program:
</P><UL><LI>create a new folder
</LI><LI>save the source code below into a file called LuminanceCalculator.cc
</LI><LI>save the data under scotopic into a file called scotopic.dat
</LI><LI>save the data under photopic into a file called photopic.dat
</LI><LI>create your own spectra file by inputting the (x<SUB>i</SUB>,f(x<SUB>i</SUB>)) coordinates of the spectral distribution file, no spaces just carriage returns i.e. in the format:
</LI></UL><P>x<SUB>1</SUB></P><P>f(x<SUB>1</SUB>)
</P><P>x<SUB>2</SUB></P><P>f(x<SUB>2</SUB>)
</P><P>...
</P><P>x<SUB>2</SUB></P><P>f(x<SUB>2</SUB>)
</P><UL><LI>10 values is usually enough, but more would be better. x should be in nanometre (nm) f(x) should be in SI
</LI><LI>save the above as spectra.dat
</LI><LI>open a terminal
</LI><LI>navigate to the folder which all of the above are in
</LI><LI>compile using the command: g++ LuminanceCalculator.cc -o LuminanceCalculator.cc
</LI><LI>run the program
</LI></UL><H1><SPAN class="mw-headline" id="Source_Code">Source Code</SPAN></H1><OL><LI>include &lt;iostream&gt;</LI><LI>include &lt;vector&gt;</LI><LI>include &lt;fstream&gt;</LI><LI>include &lt;math.h&gt;</LI></OL><OL><LI>ifndef __mjdmatrix_h
</LI><LI>define __mjdmatrix_h
</LI><LI>include &lt;iostream&gt;</LI></OL><P>using namespace std;
// generic object (class) definition of matrix:
template &lt;class D&gt; class matrix{
</P><PRE> // NOTE: maxsize determines available memory storage, but
 // actualsize determines the actual size of the stored matrix in use
 // at a particular time.
 int maxsize;  // max number of rows (same as max number of columns)
 int actualsize;  // actual size (rows, or columns) of the stored matrix
 D* data;      // where the data contents of the matrix are stored
 void allocate()   {
   delete[] data;
   data = new D [maxsize*maxsize];
   };
 matrix() {};                  // private ctor's
 matrix(int newmaxsize) {matrix(newmaxsize,newmaxsize);};
</PRE><P>
public: 
</P><P>void print()
{
	for(int i=0; i&lt;maxsize; i++){
	for(int j=0; j&lt;maxsize; j++){
</P><P>	cout &lt;&lt; getvalue(i,j) &lt;&lt; &quot;  &quot;;
	}
	cout &lt;&lt; endl;
	}
</P><P>};
</P><P>
D getvalue(int row, int column){return data[ row * maxsize + column ];};
</P><PRE> matrix(int newmaxsize, int newactualsize)  { // the only public ctor
   if (newmaxsize &lt;= 0) newmaxsize = 5;
   maxsize = newmaxsize; 
   if ((newactualsize &lt;= newmaxsize)&amp;&amp;(newactualsize&gt;0))
     actualsize = newactualsize;
   else 
     actualsize = newmaxsize;
   // since allocate() will first call delete[] on data:
   data = 0;
   allocate();
   };
 ~matrix() { delete[] data; };
</PRE><PRE> void comparetoidentity()  {
   int worstdiagonal = 0;
   D maxunitydeviation = 0.0;
   D currentunitydeviation;
   for ( int i = 0; i &lt; actualsize; i++ )  {
     currentunitydeviation = data[i*maxsize+i] - 1.;
     if ( currentunitydeviation &lt; 0.0) currentunitydeviation *= -1.;
     if ( currentunitydeviation &gt; maxunitydeviation )  {
          maxunitydeviation = currentunitydeviation;
          worstdiagonal = i;
          }
     }
   int worstoffdiagonalrow = 0;
   int worstoffdiagonalcolumn = 0;
   D maxzerodeviation = 0.0;
   D currentzerodeviation ;
   for ( int i = 0; i &lt; actualsize; i++ )  {
     for ( int j = 0; j &lt; actualsize; j++ )  {
       if ( i == j ) continue;  // we look only at non-diagonal terms
       currentzerodeviation = data[i*maxsize+j];
       if ( currentzerodeviation &lt; 0.0) currentzerodeviation *= -1.0;
       if ( currentzerodeviation &gt; maxzerodeviation )  {
         maxzerodeviation = currentzerodeviation;
         worstoffdiagonalrow = i;
         worstoffdiagonalcolumn = j;
         }
</PRE><PRE>       }
     }
   cout &lt;&lt; &quot;Worst diagonal value deviation from unity: &quot; 
      &lt;&lt; maxunitydeviation &lt;&lt; &quot; at row/column &quot; &lt;&lt; worstdiagonal &lt;&lt; endl;
   cout &lt;&lt; &quot;Worst off-diagonal value deviation from zero: &quot; 
      &lt;&lt; maxzerodeviation &lt;&lt; &quot; at row = &quot; &lt;&lt; worstoffdiagonalrow 
      &lt;&lt; &quot;, column = &quot; &lt;&lt; worstoffdiagonalcolumn &lt;&lt; endl;
 }
</PRE><PRE> void settoproduct(matrix&amp; left, matrix&amp; right)  {
   actualsize = left.getactualsize();
   if ( maxsize &lt; left.getactualsize() )   {
     maxsize = left.getactualsize();
     allocate();
     }
   for ( int i = 0; i &lt; actualsize; i++ )
     for ( int j = 0; j &lt; actualsize; j++ )  {
       D sum = 0.0;
       D leftvalue, rightvalue;
       bool success;
       for (int c = 0; c &lt; actualsize; c++)  {
           left.getvalue(i,c,leftvalue,success);
           right.getvalue(c,j,rightvalue,success);
           sum += leftvalue * rightvalue;
           }
       setvalue(i,j,sum);
       }
   }
</PRE><PRE> void copymatrix(matrix&amp;  source)  {
   actualsize = source.getactualsize();
   if ( maxsize &lt; source.getactualsize() )  {
     maxsize = source.getactualsize();
     allocate();
     }
   for ( int i = 0; i &lt; actualsize; i++ )
     for ( int j = 0; j &lt; actualsize; j++ )  {
       D value;
       bool success;
       source.getvalue(i,j,value,success);
       data[i*maxsize+j] = value;
       }
   };
</PRE><PRE> void setactualsize(int newactualsize) {
   if ( newactualsize &gt; maxsize )
     {
       maxsize = newactualsize ; // * 2;  // wastes memory but saves
                                     // time otherwise required for
                                     // operation new[]
       allocate();
     }
   if (newactualsize &gt;= 0) actualsize = newactualsize;
   };
</PRE><PRE> int getactualsize() { return actualsize; };
</PRE><PRE> void getvalue(int row, int column, D&amp; returnvalue, bool&amp; success)   {
   if ( (row&gt;=maxsize) || (column&gt;=maxsize) 
     || (row&lt;0) || (column&lt;0) )
     {  success = false;
        return;    }
   returnvalue = data[ row * maxsize + column ];
   success = true;
   };
</PRE><PRE> bool setvalue(int row, int column, D newvalue)  {
   if ( (row &gt;= maxsize) || (column &gt;= maxsize) 
       || (row&lt;0) || (column&lt;0) ) return false;
   data[ row * maxsize + column ] = newvalue;
   return true;
   };
</PRE><PRE> void invert()  {
   if (actualsize &lt;= 0) return;  // sanity check
   if (actualsize == 1) return;  // must be of dimension &gt;= 2
   for (int i=1; i &lt; actualsize; i++) data[i] /= data[0]; // normalize row 0
   for (int i=1; i &lt; actualsize; i++)  { 
     for (int j=i; j &lt; actualsize; j++)  { // do a column of L
       D sum = 0.0;
       for (int k = 0; k &lt; i; k++)  
           sum += data[j*maxsize+k] * data[k*maxsize+i];
       data[j*maxsize+i] -= sum;
       }
     if (i == actualsize-1) continue;
     for (int j=i+1; j &lt; actualsize; j++)  {  // do a row of U
       D sum = 0.0;
       for (int k = 0; k &lt; i; k++)
           sum += data[i*maxsize+k]*data[k*maxsize+j];
       data[i*maxsize+j] = 
          (data[i*maxsize+j]-sum) / data[i*maxsize+i];
       }
     }
   for ( int i = 0; i &lt; actualsize; i++ )  // invert L
     for ( int j = i; j &lt; actualsize; j++ )  {
       D x = 1.0;
       if ( i != j ) {
         x = 0.0;
         for ( int k = i; k &lt; j; k++ ) 
             x -= data[j*maxsize+k]*data[k*maxsize+i];
         }
       data[j*maxsize+i] = x / data[j*maxsize+j];
       }
   for ( int i = 0; i &lt; actualsize; i++ )   // invert U
     for ( int j = i; j &lt; actualsize; j++ )  {
       if ( i == j ) continue;
       D sum = 0.0;
       for ( int k = i; k &lt; j; k++ )
           sum += data[k*maxsize+j]*( (i==k) ? 1.0 : data[i*maxsize+k] );
       data[i*maxsize+j] = -sum;
       }
   for ( int i = 0; i &lt; actualsize; i++ )   // final inversion
     for ( int j = 0; j &lt; actualsize; j++ )  {
       D sum = 0.0;
       for ( int k = ((i&gt;j)?i:j); k &lt; actualsize; k++ )  
           sum += ((j==k)?1.0:data[j*maxsize+k])*data[k*maxsize+i];
       data[j*maxsize+i] = sum;
       }
   };
</PRE><P>};
</P><OL><LI>endif
</LI></OL><P>using namespace std;
</P><P>class Function
{
	private:
	vector &lt;double&gt; wavelength;
	vector &lt;double&gt; function;
	vector &lt;double&gt; lambda;
</P><P>	double RBF(double, double);
	double sigma;
	double width;
	int SIZE;
</P><P>	public:
	void getData(const char*);
	void findLambda(double);
	void fix();
</P><P>	double size(){return wavelength.size();}
	double lat(int i){return lambda.at(i);}
	double wat(int i){return wavelength.at(i);}
	double fat(int i){return function.at(i);}
	void wequals(int i, double value){wavelength.at(i)=value;}
	void fequals(int i, double value){function.at(i)=value;}
</P><P>	void eraseBeginning(int);
	void erase(int);
</P><P>	void print();
	void print(double,double,double);
	void printStore();
</P><P>	double value(double);
</P><P>};
</P><P>double X(double j, double a, double h) {return a+j*h;}
double H(double a,double b,double n) {return (b-a)/n;}
</P><P>double integral (double a, double b, Function);
</P><P>void runProgram(char*,char*);
</P><P>double luminousFlux(Function, Function);
</P><OL><LI>define MINI 400
</LI><LI>define MAXI 750
</LI></OL><OL><LI>define CONSTANT 0.7
</LI><LI>define N 10000
</LI></OL><OL><LI>ifndef SPECTRA
</LI><LI>define SPECTRA &quot;spectra.dat&quot;
</LI><LI>endif
</LI></OL><P>
int main()
{
	char b;
	cout &lt;&lt; &quot;This program will tell you the conversion factor between Radiance and Luminance for your chosen object with known radiation spectrum&quot; &lt;&lt; endl;
</P><PRE>	cout &lt;&lt; endl &lt;&lt; &quot;Do you want scotopic (low light) [s] or photopic (normal light) [p] Luminance?&quot; &lt;&lt; endl;
</PRE><P>	while(b!='p'&amp;&amp;b!='s'){cout &lt;&lt; &quot;please input s or p&quot; &lt;&lt; endl; cin &gt;&gt; b;}
	cout &lt;&lt; endl;
</P><P>	if(b=='s')
	runProgram(&quot;scotopic.dat&quot;,SPECTRA);
	if(b=='p')
	runProgram(&quot;photopic.dat&quot;,SPECTRA);
</P><P>	return 0;
}
</P><P>
void runProgram(char* lumFile, char* specFile)
{
	Function luminosity, spectra;
</P><P>	cout &lt;&lt; &quot;Getting luminosity data...&quot; &lt;&lt; endl;
	luminosity.getData(lumFile);
	cout &lt;&lt; &quot;Calculating luminosity function...&quot; &lt;&lt; endl;
	luminosity.findLambda(CONSTANT);
</P><P>	cout &lt;&lt; &quot;Getting spectral data...&quot; &lt;&lt; endl;
	spectra.getData(specFile);
	cout &lt;&lt; &quot;Calculating spectral function...&quot; &lt;&lt; endl;
	spectra.findLambda(CONSTANT);
</P><P>	
	cout &lt;&lt; &quot;Calculating luminous flux...&quot; &lt;&lt; endl;
	double x=luminousFlux(luminosity,spectra) ;
</P><P>
	cout &lt;&lt; &quot;Conversion Factor is: &quot; &lt;&lt; x &lt;&lt; endl &lt;&lt; endl;
}
</P><P>
void testData(char* data,double CONST, char* output)
{
	Function a;
	a.getData(data);
	a.findLambda(CONST);
</P><P>	ofstream fout(output);
</P><P>	if(!fout)
	{cout &lt;&lt; &quot;Could not open file &quot; &lt;&lt; output &lt;&lt; &quot; program terminated.&quot; &lt;&lt; endl; fout.close(); return;}
</P><P>	for(double i=MINI; i&lt;=MAXI ; i+=0.1)
	fout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; a.value(i) &lt;&lt; endl;
</P><P>//	for(double i=0; i&lt;a.size() ; i++)
//	cout &lt;&lt; a.wat(i) &lt;&lt; &quot;\t&quot; &lt;&lt; a.fat(i)&lt;&lt;&quot;\t&quot; &lt;&lt; a.lat(i)&lt;&lt; endl;
</P><P>
	fout.close();
</P><P>}
</P><P>
double luminousFlux(Function x, Function y)
{
	double sum1=0, sum2=0;
	int a=400,b=750;
	double h=H(a,b,N);
</P><P>
	for(double j=1; j&lt;=(N/2)-1;j++)
	{sum1+=x.value(X(2*j,a,h))*y.value(X(2*j,a,h));}
</P><P>	for(double j=1; j&lt;=N/2; j++)
	{sum2+=x.value(X(2*j-1,a,h))*y.value(X(2*j-1,a,h));}
</P><P>	return 683.002*((h/3)*( x.value(a)*y.value(a)+ 2*sum1 + 4*sum2 + x.value(b)*y.value(b) ))/integral(a,b,y);
</P><P>
}
</P><P>double integral (double a, double b, Function func)
{
	double sum1=0, sum2=0;
	double h=H(a,b,N);
</P><P>	for(double j=1; j&lt;=(N/2)-1;j++)
	{sum1+=func.value( X( 2*j , a , h ) );}
</P><P>	for(double j=1; j&lt;=N/2; j++)
	{sum2+=func.value( X( (2*j)-1 , a , h ) );}
</P><P>	return (h/3)* ( func.value(a)+ 2*sum1 + 4*sum2 + func.value(b) );
}
</P><P>//.............................................................................................................
</P><P>void Function::getData(const char* a)
{
	double num;	
</P><P>	SIZE=200;
</P><P>	ifstream fin(a);
	if(!fin)
	{cout &lt;&lt; &quot;Could not open file &quot; &lt;&lt; a &lt;&lt; &quot; program terminated.&quot; &lt;&lt; endl; fin.close(); return;}
</P><P>	fin &gt;&gt; num;
	for (int i=0; !fin.eof(); i++ ) 
	{
	if(!(i%2)){ wavelength.push_back(num); fin &gt;&gt; num;}
	else { function.push_back(num); fin &gt;&gt; num;}
	}
</P><P>	fin.close();
</P><P>	int total=wavelength.size();
	vector &lt;double&gt; tempwavelength;
	vector &lt;double&gt; tempfunction; 
</P><P>	
	if(total&gt;SIZE){
	 for(int i=0; i&lt;wavelength.size(); i++) {
	  if(i%(total/SIZE)==0){
		tempwavelength.push_back(wavelength.at(i));
		tempfunction.push_back(function.at(i));
	}}
	wavelength.clear(); function.clear();
	for(int i=0; i&lt;tempwavelength.size(); i++) { 
		wavelength.push_back(tempwavelength.at(i));
		function.push_back(tempfunction.at(i));
	}
	}
</P><P>	width=(wavelength.back()-wavelength.front())/wavelength.size();
</P><P>}
</P><P>void Function::print(double min, double max, double increment)
{
	for(double i=min; i&lt;=max ; i+=increment)
	cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; value(i) &lt;&lt; endl;
}
</P><P>void Function::printStore()
{
	for(double i=0; i&lt;wavelength.size() ; i++)
	cout &lt;&lt; wavelength.at(i) &lt;&lt; &quot;\t&quot; &lt;&lt; function.at(i) &lt;&lt; endl;
</P><P>}
</P><P>void Function::print()
{
	for(int i=0; i&lt;wavelength.size(); i++)
	{
		cout &lt;&lt; wavelength.at(i) &lt;&lt; &quot;\t&quot; &lt;&lt; function.at(i) &lt;&lt; endl;
	}
</P><P>}
</P><P>double Function::RBF(double a, double b)
{
	return exp(-(a-b)*(a-b)/(2*sigma*sigma));
	//return fabs(a-b);
	//return 1/sqrt(1+sigma*(a-b)*(a-b));
}
</P><P>void Function::findLambda(double CONST)
{	
	sigma=width*CONST;
</P><P>	int M=wavelength.size();
</P><PRE> matrix &lt;double&gt; PHI(M,M);
 matrix &lt;double&gt; lamb(M,1);
 matrix &lt;double&gt; func(M,1);  
</PRE><P>	for (int i=0; i&lt;M; i++) {
	func.setvalue(i,1,function.at(i));
	for (int j=0; j&lt;M; j++) {
	PHI.setvalue(i,j,RBF(wavelength.at(i),wavelength.at(j)));
</P><P>	}}
</P><P>	PHI.invert(); lamb.settoproduct(PHI,func);
</P><P>
	double value;bool success;
</P><P>	for(int i=0; i&lt;M; i++){lambda.push_back(lamb.getvalue(i,1));}
}
</P><P>double Function::value(double x)
{
	double sum=0;
	for(int i=0; i&lt;wavelength.size(); i++) sum+=lambda.at(i)*RBF(x,wavelength.at(i));
</P><P>	return sum;
}
</P><P>void Function::fix()
{
	for(int i=0; i&lt;wavelength.size(); i++){
	 for(int j=0;j&lt;i; j++){
		if(wavelength.at(i)==wavelength.at(j)) {wavelength.erase(wavelength.begin()+j); function.erase(function.begin()+j); j=j-1;}
	}}
</P><P>}
</P><P>
void Function::eraseBeginning(int i)
{
	i/=2;
	function.erase(function.begin(), function.begin()+i);
	wavelength.erase(wavelength.begin(),wavelength.begin()+i);
}
</P><H1><SPAN class="mw-headline" id="Photopic">Photopic</SPAN></H1><P>380
</P><P>3.9000e-005
</P><P>385
</P><P>6.4000e-005
</P><P>390
</P><P>1.2000e-004
</P><P>395
</P><P>2.1700e-004
</P><P>400
</P><P>3.9600e-004
</P><P>405
</P><P>6.4000e-004
</P><P>410
</P><P>1.2100e-003
</P><P>415
</P><P>2.1800e-003
</P><P>420
</P><P>4.0000e-003
</P><P>425
</P><P>7.3000e-003
</P><P>430
</P><P>1.1600e-002
</P><P>435
</P><P>1.6840e-002
</P><P>440
</P><P>2.3000e-002
</P><P>445
</P><P>2.9800e-002
</P><P>450
</P><P>3.8000e-002
</P><P>455
</P><P>4.8000e-002
</P><P>460
</P><P>6.0000e-002
</P><P>465
</P><P>7.3900e-002
</P><P>470
</P><P>9.0980e-002
</P><P>475
</P><P>1.1260e-001
</P><P>480
</P><P>1.3902e-001
</P><P>485
</P><P>1.6930e-001
</P><P>490
</P><P>2.0802e-001
</P><P>495
</P><P>2.5860e-001
</P><P>500
</P><P>3.2300e-001
</P><P>505
</P><P>4.0730e-001
</P><P>510
</P><P>5.0300e-001
</P><P>515
</P><P>6.0820e-001
</P><P>520
</P><P>7.1000e-001
</P><P>525
</P><P>7.9320e-001
</P><P>530
</P><P>8.6200e-001
</P><P>535
</P><P>9.1485e-001
</P><P>540
</P><P>9.5400e-001
</P><P>545
</P><P>9.8030e-001
</P><P>550
</P><P>9.9495e-001
</P><P>555
</P><P>1.0000e+000
</P><P>560
</P><P>9.9500e-001
</P><P>565
</P><P>9.7860e-001
</P><P>570
</P><P>9.5200e-001
</P><P>575
</P><P>9.1540e-001
</P><P>580
</P><P>8.7000e-001
</P><P>585
</P><P>8.1630e-001
</P><P>590
</P><P>7.5700e-001
</P><P>595
</P><P>6.9490e-001
</P><P>600
</P><P>6.3100e-001
</P><P>605
</P><P>5.6680e-001
</P><P>610
</P><P>5.0300e-001
</P><P>615
</P><P>4.4120e-001
</P><P>620
</P><P>3.8100e-001
</P><P>625
</P><P>3.2100e-001
</P><P>630
</P><P>2.6500e-001
</P><P>635
</P><P>2.1700e-001
</P><P>640
</P><P>1.7500e-001
</P><P>645
</P><P>1.3820e-001
</P><P>650
</P><P>1.0700e-001
</P><P>655
</P><P>8.1600e-002
</P><P>660
</P><P>6.1000e-002
</P><P>665
</P><P>4.4580e-002
</P><P>670
</P><P>3.2000e-002
</P><P>675
</P><P>2.3200e-002
</P><P>680
</P><P>1.7000e-002
</P><P>685
</P><P>1.1920e-002
</P><P>690
</P><P>8.2100e-003
</P><P>695
</P><P>5.7230e-003
</P><P>700
</P><P>4.1020e-003
</P><P>705
</P><P>2.9290e-003
</P><P>710
</P><P>2.0910e-003
</P><P>715
</P><P>1.4840e-003
</P><P>720
</P><P>1.0470e-003
</P><P>725
</P><P>7.4000e-004
</P><P>730
</P><P>5.2000e-004
</P><H1><SPAN class="mw-headline" id="Scotopic">Scotopic</SPAN></H1><P>380
</P><P>5.890e-004
</P><P>385
</P><P>1.108e-003
</P><P>390
</P><P>2.209e-003
</P><P>395
</P><P>4.530e-003
</P><P>400
</P><P>9.290e-003
</P><P>405
</P><P>1.852e-002
</P><P>410
</P><P>3.484e-002
</P><P>415
</P><P>6.040e-002
</P><P>420
</P><P>9.660e-002
</P><P>425
</P><P>1.436e-001
</P><P>430
</P><P>1.998e-001
</P><P>435
</P><P>2.625e-001
</P><P>440
</P><P>3.281e-001
</P><P>445
</P><P>3.931e-001
</P><P>450
</P><P>4.550e-001
</P><P>455
</P><P>5.130e-001
</P><P>460
</P><P>5.670e-001
</P><P>465
</P><P>6.200e-001
</P><P>470
</P><P>6.760e-001
</P><P>475
</P><P>7.340e-001
</P><P>480
</P><P>7.930e-001
</P><P>485
</P><P>8.510e-001
</P><P>490
</P><P>9.040e-001
</P><P>495
</P><P>9.490e-001
</P><P>500
</P><P>9.820e-001
</P><P>505
</P><P>9.980e-001
</P><P>510
</P><P>9.970e-001
</P><P>515
</P><P>9.750e-001
</P><P>520
</P><P>9.350e-001
</P><P>525
</P><P>8.800e-001
</P><P>530
</P><P>8.110e-001
</P><P>535
</P><P>7.330e-001
</P><P>540
</P><P>6.500e-001
</P><P>545
</P><P>5.640e-001
</P><P>550
</P><P>4.810e-001
</P><P>555
</P><P>4.020e-001
</P><P>560
</P><P>3.288e-001
</P><P>565
</P><P>2.639e-001
</P><P>570
</P><P>2.076e-001
</P><P>575
</P><P>1.602e-001
</P><P>580
</P><P>1.212e-001
</P><P>585
</P><P>8.990e-002
</P><P>590
</P><P>6.550e-002
</P><P>595
</P><P>4.690e-002
</P><P>600
</P><P>3.315e-002
</P><P>605
</P><P>2.312e-002
</P><P>610
</P><P>1.593e-002
</P><P>615
</P><P>1.088e-002
</P><P>620
</P><P>7.370e-003
</P><P>625
</P><P>4.970e-003
</P><P>630
</P><P>3.335e-003
</P><P>635
</P><P>2.235e-003
</P><P>640
</P><P>1.497e-003
</P><P>645
</P><P>1.005e-003
</P><P>650
</P><P>6.770e-004
</P><P>655
</P><P>4.590e-004
</P><P>660
</P><P>3.129e-004
</P><P>665
</P><P>2.146e-004
</P><P>670
</P><P>1.480e-004
</P><P>675
</P><P>1.026e-004
</P><P>680
</P><P>7.150e-005
</P><P>685
</P><P>5.010e-005
</P><P>690
</P><P>3.533e-005
</P><P>695
</P><P>2.501e-005
</P><P>700
</P><P>1.780e-005
</P><P>705
</P><P>1.273e-005
</P><P>710
</P><P>9.140e-006
</P><P>715
</P><P>6.600e-006
</P><P>720
</P><P>4.780e-006
</P><P>725
</P><P>3.482e-006
</P><P>730
</P><P>2.546e-006
</P><P>735
</P><P>1.870e-006
</P><P>740
</P><P>1.379e-006
</P><P>745
</P><P>1.022e-006
</P><P>750
</P><P>7.600e-007
</P><P>755
</P><P>5.670e-007
</P><P>760
</P><P>4.250e-007
</P><P>765
</P><P>3.196e-007
</P><P>770
</P><P>2.413e-007
</P><P>775
</P><P>1.829e-007
</P><P>780
</P><P>1.390e-007
</P></DIV></DIV></DIV><DIV class="printfooter">
Retrieved from &quot;<A href="http://2010.igem.org/Team:Cambridge/luminanceSourceCode">http://2010.igem.org/Team:Cambridge/luminanceSourceCode</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Cambridge/luminanceSourceCode" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Cambridge/luminanceSourceCode" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Cambridge/luminanceSourceCode&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Cambridge/luminanceSourceCode&amp;oldid=165548" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2010.igem.org:Privacy_policy" title="2010.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2010.igem.org:General_disclaimer" title="2010.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
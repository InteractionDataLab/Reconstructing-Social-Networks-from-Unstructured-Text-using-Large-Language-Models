<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_USTC_Software_Simulation"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:USTC_Software/Simulation">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:USTC_Software/Simulation&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:USTC_Software/Simulation&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:USTC_Software/Simulation&amp;action=history">History               </A></LI><LI style="color:#808080;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:USTC_Software/Simulation" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform">Â </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:USTC Software/Simulation</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2010.igem.org</H3><DIV id="main_wrapper"><DIV id="header"><DIV id="navigation"><DIV id="menu" style="position:static"><UL><LI id="mainHome"><A class="aMain" href="https://2010.igem.org/Team:USTC_Software/home">Home</A></LI><LI id="mainProject"><A class="aProject" href="https://2010.igem.org/Team:USTC_Software/Features">Project</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/Features">Introduction</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/User_Interface">User Interface Design</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/MoDeL">MoDeL</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/Simulation">Algorithm</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/resources">Resources</A></LI></UL><LI id="mainModel"><A class="aModel" href="https://2010.igem.org/Team:USTC_Software/MoDeL">MoDeL</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/MoDeL">One-Minute Introduction</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/model_features">Features</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/model_lang">Standardization</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/model_future">Future Work</A></LI><LI id="mainDemo"><A class="aDemo" href="https://2010.igem.org/Team:USTC_Software/downloads">Demo</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/downloads">Overview of Demos</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/Transfer function of Part:BBa_F2620">pLux-LuxR repression system</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/Toggle-Switch">Toggle-Switch</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/Repressilator">Repressilator</A></LI><LI id="mainNotebook"><A class="aNotebook" href="https://2010.igem.org/Team:USTC_Software/notebook">Notebook</A></LI><LI id="mainHumanPractice"><A class="aHumanPractice" href="https://2010.igem.org/Team:USTC_Software/human_practice">Human Practice</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/human_practice">The C Project</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/safety">Safety</A></LI><LI id="mainTeam"><A class="aTeam" href="https://2010.igem.org/Team:USTC_Software/team">Team</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/team">Overview</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/Students">Students</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/Instructors">Instructors</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/iGEM Teams">Collaboration</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/attribution">Attribution &amp; Contributions</A></LI><LI><A href="https://2010.igem.org/Team:USTC_Software/acknowledgments">Acknowledgments</A></LI></DIV></DIV></DIV></DIV><TABLE id="toc" class="toc"><TBODY><TR><TD><DIV id="toctitle"><H2>Contents</H2></DIV><UL><LI class="toclevel-1 tocsection-1"><A href="#Introduction"><SPAN class="tocnumber">1</SPAN><SPAN class="toctext">Introduction</SPAN></A></LI><LI class="toclevel-1 tocsection-2"><A href="#Algorithm_flow_chart"><SPAN class="tocnumber">2</SPAN><SPAN class="toctext">Algorithm flow chart</SPAN></A></LI><LI class="toclevel-1 tocsection-3"><A href="#Special_reactions_and_volume_strategy"><SPAN class="tocnumber">3</SPAN><SPAN class="toctext">Special reactions and volume strategy</SPAN></A></LI><LI class="toclevel-1 tocsection-4"><A href="#Chain_Sorting_and_Weighting_Scheme"><SPAN class="tocnumber">4</SPAN><SPAN class="toctext">Chain Sorting and Weighting Scheme</SPAN></A></LI><LI class="toclevel-1 tocsection-5"><A href="#Structural_pattern_match_of_template_species"><SPAN class="tocnumber">5</SPAN><SPAN class="toctext">Structural pattern match of template species</SPAN></A></LI><LI class="toclevel-1 tocsection-6"><A href="#Generation_of_products_based_on_reaction_templates"><SPAN class="tocnumber">6</SPAN><SPAN class="toctext">Generation of products based on reaction templates</SPAN></A></LI></UL></TD></TR></TBODY></TABLE><H1><SPAN class="mw-headline" id="Introduction">Introduction</SPAN></H1><P>
We design and develop a software tool, <I>iGame</I>, which supports database written in <I>MoDeL</I> format, to perform task of automatic modeling. Actually, automatic modeling is a database-dependent network-searching-and-developing process from the initial conditions. Besides the database, users are required to provide initial environment condition, such as initial plasmids with biobrick parts. <I>iGame</I> will generate the network of the biological system in <I>SBML</I> standard. Please refer to <A href="https://2010.igem.org/Team:USTC_Software/" class="external text" rel="nofollow"><FONT size="5"><I>User_Interface user interface</I></FONT></A> to know more about input and output of <I>iGame</I>.
</P><P><FONT size="+1"><B>Algorithms for automatic modeling will be shown in the following sections</B></FONT>. An overview is as follow:
</P><UL><LI>Section <FONT color="red"><I>Algorithm flow chart</I></FONT> gives an overall description of the general framework of our algorithms; 
</LI><LI>Section <FONT color="red"><I>Special reactions and volume strategy</I></FONT> tells details about the methods and strategies our program utilizes to handle with some special reactions; 
</LI><LI>Section <FONT color="red"><I>Chain Sorting and Weighting Scheme</I></FONT> provides details of sorting as well as weighting scheme and their functions; 
</LI><LI>Section <FONT color="red"><I>Structural pattern match of template species</I></FONT> provides details of the core algorithm of <I>iGame</I>: how to find matchings between template species defined in database and species existed in the bio-system; 
</LI><LI>Section <FONT color="red"><I>Generation of products based on reaction templates</I></FONT> describes the <I>mix-trim-split</I> method to generate products.
</LI></UL><H1><SPAN class="mw-headline" id="Algorithm_flow_chart">Algorithm flow chart</SPAN></H1><TABLE><TBODY><TR><TD>Before stating our own algorithm, we will first make an analysis about the difference and difficulty brought by introducing a new language system. The general algorithm idea is common: find out all species and reactions between them. Ignoring the efficiency of program, the most obvious method is doing the following recursively until no more species is generated:
<UL><LI>find reactions between species have been found and generate products as new species
</LI></UL><P>Similar idea applies to our program. Some modifications must be made because in other software tools, reaction-searching is name-based. However, in our program, it is structure-based. Matching of species name is much easier than that of <I>Chain-Node</I> structure, which is featured as the most important part of our program. In addition, process of products generating is not as easy as just creating a new species with specific name, too. Their structures are required to be constructed under rules defined in <I>MoDeL</I> at the same time. The species matching and products generating modules are essential to implement our automatic modeling idea. 
</P><P>To complete the final systemn network from initial conditions, we break up the task to several parts:
</P><UL><LI><B>Setup initial conditions and environmental parameters read from the input file;</B></LI></UL><UL><LI><B>Species produced are inserted into a list in the order of time. For each species, we search the database to find template species which could be matched to this species in structural pattern. If not found, then go for the next species;</B></LI></UL><UL><LI><B>For each template species found matching, we continue to search template reactions containing this template species as a reactant or modifier or both. Only forward or reverse reaction is handled, never for both at the same time;</B></LI></UL><UL><LI><B>For each template reaction found possible to occur, we search in the species list for possible species which could be instances of templates of other reactants and modifiers. If not found, then go for next reaction;</B></LI></UL><UL><LI><B>For each possible combination of reactants and modifiers, if the reaction parameter conditions are satisfied for given constraints, we generate the structure of products based on the <I>transfer</I> table and structural templates of products. And then add this new reaction to the reaction list.</B></LI></UL><UL><LI><B>Go to step 2 until the end of the species list;</B></LI></UL><P>In the following, we will focus on the step (2), (3) and (5). Our algorithms are totally different with that of other software tools since we design them for the purpose of proving the feasibility of <B>MoDeL</B> for synthetic biology. They are kind of complicated because the complexity of biological systems require so.
</P></TD><TD><DIV class="thumb tright"><DIV class="thumbinner" style="width:302px;"><DIV class="thumbcaption">Figure 1: Algorithm Flow Chart</DIV></DIV></DIV></TD></TR></TBODY></TABLE><H1><SPAN class="mw-headline" id="Special_reactions_and_volume_strategy">Special reactions and volume strategy</SPAN></H1><P>
Transcription and translation reactions are not supported by <I>MoDeL</I> reaction definitions; they are handled specially in the core program. We use pseudo first-order reaction to model both transcription and translation reactions. The rate constant k is the value of <I>forwardPromoterEfficiency</I>/<I>reversePromoterEfficiency</I> for transcriptions and <I>forwardRbsEfficiency</I>/<I>reverseRbsEfficiency</I> for translations defined for each part in the database. It means number of mRNAs per DNA per second for transcriptions and number of proteins per mRNA per second for translations. A transcription will not end at a terminator with termination efficiency less than 100% (values are stored in attribute <I>forwardTerminatorEfficiency</I>/<I>reverseTerminatorEfficiency</I>): RNA polymerase will pass over and continue transcription. For translation reactions, the prerequisite condition is that the part next to RBS along the 5' to 3' direction must have non-zero attribute value <I>forwardStartCodon</I>/<I>reverseStartCodon</I>. Opposite to transcriptions, translation reactions would stop if one part with non-zero attribute value <I>forwardStopCodon</I>/<I>reverseStopCodon</I> is encountered.
</P><P>Volume strategy is a special method to solve problems introduced by diffusion reactions. Consider a transport reaction S1-&gt;S2 in which the species S1 is moved from the first compartment with volume V1, to the second with volume V2. The rate constant is k but the rate law is not k*[S1]*V1, because the concentration conversion is needed. The correct expression is N*k*[S1]*V1. The volume strategy just uses N*V1 instead of V1 as the volume of the first compartment. To have a general definition, the volume of a compartment is defined as V*N1*N2, where:
</P><UL><LI>V is the volume of the compartment itself;
</LI><LI>N1 is the number of compartments located in its outside compartment;
</LI><LI>N2 is the total number of its outside compartment
</LI></UL><H1><SPAN class="mw-headline" id="Chain_Sorting_and_Weighting_Scheme">Chain Sorting and Weighting Scheme</SPAN></H1><P>
Chains in our <I>Chain-Node</I> model should not have any order since there are no natural ways to sort them. One chain is not
preferred to another, since in a complex of multiple chains, which are connected via binding interaction of binding bites on their own, all chains are equivalent. However, a chain-sorting program is a prerequisite for implementations of many other functions, such as comparison of two <I>Chain-Node</I> structures, or pattern matching of template species to those in the system.
</P><P>Sorting is always performed under some rules. Since there are no natural options, we design one to generate the unique order for a list of chains. The rule we developed is something like that for comparing two strings: compare the first part of two chains by their <I>partReference</I> and <I>partType</I> in alphabet order and if equal, then compare the next until there are differences or to the end of either chain. At this stage, besides <I>partReference</I> and <I>partType</I>, two parts are considered equal if both are in bound states or not. There are some exceptions for DNA molecule: since dsDNA has both forward and reverse directions, comparison between its forward and reverse chain is also needed. 
</P><P>If all chains are different in the first stage of sorting, we have already obtain the unique order of the chain list. However, it is not always so: equal chains in the above sorting may be equivalent or not. It is due to the assumption that two bound parts are taken as equal if both have same <I>partReference</I>and <I>partType</I> attribute values. Though the above sorting strategy takes binding positions into consideration, it ignores the binding details of those parts: the details are hidden in the nodes of all trees. Hence, similar to the chain sorting, we need to find another strategy to sort nodes as well as trees. Our weighting scheme will be first introduced below. 
</P><P>Assume the chains are sorted already. Each part will be assigned a weight based on its position in the chain list. The weight of the jth part on the ith chain is (i,j). For example, the first part on the first chain posses a weight (0,0) (in <I>C</I> style, counting number from zero). After assignment of parts' weight, we turn to weights of the nodes in trees. Since leaf nodes in trees are actually the representation of parts in bound state on chains, the weight of each leaf node could be inherited from the weight of its corresponding part. For parent node, its weight equals to the maximum of weights of all its children nodes (we define a weight (i, j) is greater than another (i',j') if i &lt; i' or i = i' while j &lt; j'). The recursive definition of nodes' weight of trees makes it possible to sort all children of each node, which is a prerequisite for generating Huffman codes (see below). And then the tree order in the forest could be uniquely determined by sorting the root node of each tree.
</P><DIV class="thumb tright"><DIV class="thumbinner" style="width:402px;"><DIV class="thumbcaption">Exchange of the first and second chain. The tree structures are different before and after exchange: the two chains are not equivalent.</DIV></DIV></DIV><P>Back to the question above, if two chains are equal in the first stage sorting, which should be arranged in front of the other? The answer could be obtained by exchanging them. The exchange will change the parts' weight on both chains and thus the weight of some nodes of the trees and subsequently the tree and forest structure. If the forest structure is not changed, the two chains are equivalent, which means that it makes no difference to arrange either chain in front of the other. If the forest structure has changed, we must find some ways to determine which tree structure is preferred and based on this to arrange them. We know each tree could be uniquely converted to a binary tree by taking the first child of each node as the left child and its siblings as its right child. The Huffman algorithm is used to generate the Huffman code of each node in the binary tree. Since the Huffman code of each node represents its path to the root node, we can restore the tree structure from the Huffman codes of all leaf nodes. Hence, the Huffman codes of leaf nodes could uniquely determine a tree structure. With help of Huffman codes, it is simple to compare the forest structure after and before exchange of both chains.
</P><P>To go further, we must define the preference of each forest structure due to exchange of chains: compare each node of the first tree by their Huffman codes and weights in the same way as comparison of strings and if equal, compare the next until difference appears or to the end of either forest. If one is less than another, it has higher priority. With this definition, the order of those equal chains in the first-stage sorting is determined by the one which generates the forest strucuture with highest priority among all possibilities. By performing this algorithm for all groups of equal chains obtained from the first-stage sorting, we could find both the unique order of the chains and the groups of equivalent chains (exchange of the order fo several chains in the same equivalent group will not change the forest structure). The figure illustrates this idea graphically.
</P><P>It is easy to compare two structures with help of chain sorting. We only need to compare first the chain list in order, chain by chain, and if equal, compare both associated forest structures. If two structures are same, the comparison must be equal since chains and trees are all in their unique order. If the comparison is equal, they must be the same structures since we could uniquely generate a Chain-Node structure from the chains as well as its associated forest structure.
</P><H1><SPAN class="mw-headline" id="Structural_pattern_match_of_template_species">Structural pattern match of template species</SPAN></H1><P><B>We assume that if a combination of species in the species list could be structurally matched to reactants and modifiers templates defined within a reaction, they are possible to react with each other in the way as the reaction template describes</B>. Hence, it is important to find such matchings between species in the species list and template ones defined in the database. We will first give the basic idea and then some modifications.
</P><DIV class="thumb tright"><DIV class="thumbinner" style="width:402px;"><DIV class="thumbcaption">Blocks of <I>ST</I> and <I>NST</I> part on a template chain</DIV></DIV></DIV><DIV class="thumb tright"><DIV class="thumbinner" style="width:402px;"><DIV class="thumbcaption">Combinations of <I>NST</I> block matchings form a region restriction for <I>ST</I> part blocks</DIV></DIV></DIV><DIV class="thumb tright"><DIV class="thumbinner" style="width:402px;"><DIV class="thumbcaption">The template <I>ST</I> block contains 3 <I>ANY</I> parts. If the first <I>ANY</I> part is matched A and B, the task is reduced to match the next 2 <I>ANY</I> parts to C, D, E, F, and G. All matchings could be found by recursively performing this algorithm.</DIV></DIV></DIV><DIV class="thumb tright"><DIV class="thumbinner" style="width:402px;"><DIV class="thumbcaption">Removing unmatched chains and associated trees of the species. It should have same structure with template species after replacing <I>ST</I> part with matchings if it has the same structural pattern with the template one.</DIV></DIV></DIV><P>
The basic idea is simple. We first consider the structural pattern matching between one chain and a chain template. There are two kind of parts on a chain template: <I>substituent</I>-type part (<I>ST</I>) and non-<I>substituent</I>-type part (<I>NST</I>). The whole template chain could be separated into blocks of <I>ST</I> parts and <I>NST</I> parts. Then we could break down the task to the matching of each small block. For each <I>NST</I> type block, we find all its matching regions on the chain to be matched and there may be more than one regions. Each of the combinations of all <I>NST</I> blocks forms a <I>NST</I> frame and restricts the matching regions of <I>ST</I> blocks. Therefore, the task is reduced to find matchings of each <I>ST</I> part block within a restricted region on the chain to be matched. At the present version of <I>MoDeL</I>, there are 6 <I>ST</I> part: <I>ANY</I>, <I>ANYUB</I>, <I>NZ</I>, <I>NZUB</I>, <I>ONE</I> and <I>ONEUB</I>. A general algorithm for all 6 type part is designed and we will illustrate this via an example. Consider a <I>ST</I> block with all <I>ANY</I> type parts (we use <I>X</I> to indicate <I>ANY</I> type part in the figures). We find matchings of the first part of the block. There may be many possible matchings because part of type <I>ANY</I> implies arbitrary matching of parts on one chain in <I>MoDeL</I> definitions. For each matching found, we deal with the next, and do the same thing recursively until the end of the template or matching fails. An easy example is shown in the figure to illustrate this simple idea.
</P><P>After all possible matchings for each chain in the template have been found, we could choose any one from each to form a combination. In each combination, matchings of different chains should not be the same. For example, there are two chains in the template, T1 and T2, and three chains, C1, C2 and C3 in the species. If T1 has one matching to C1 and one to C2 and T2 has one to C2 and one to C3, the possible matchings are (T1,T2)-&gt;(C1, C2), (T1,T2)-&gt;(C1,C3) and (T1,T2)-&gt;(T2,T3). (T1,T2)-&gt;(C2,C2) is not allowed. The general matching relations could be written as (n1,n2,n3...)-&gt;(m1,m2,m3...), where (n1,n2,n3...) represents chains in the template and (m1,m2,m3...) represents the chains matched in the species for (n1,n2,n3...) respectively. However, it is only  part of the matching relation because details, such as the matching positions of parts in the template, are ignored.  The next question is: how to validate each matching?
</P><P>As defined in <I>Chain-Node</I> model, details of distribution of binding are stored in the forest. Matching of chains could not solely determine the overall match -- whether the template and the species have the same structural pattern. However, it is not easy to compare tree structure directly. We designed an algorithm to do this based on the principle: <B>If the template and species have the same structural pattern, it must be possible to isolate the template from the species after replacing the <I>ST</I> part with its matchings</B>. We first replace the <I>ST</I> part of the template with its matchings in the species. And then, we remove the chains which are not matched and the associated trees -- containing leaf nodes whose corresponding parts are on those chains. If the species after removing has the same <I>Chain-Node</I> structure with the template after replacing, the template and the species have the same structural pattern and in brief, the template could be matched to the species. We also illustrate this idea in figures.
</P><P>However, there is one problem of this algorithm. Consider a LacI dimer template, whose <I>Chain-Node</I> model has two chains with one part on each and one tree with 2 leaf nodes. And there is also a LacI dimer species, it has the same structural pattern with the template. The matching should be (T1,T2)-&gt;(C1,C2) and (T1,T2)-&gt;(C2,C1) according to the algorithm described above. However, there is indeed one matching since the two matchings are the same. The underlying reason is that the two chains of the template are equivalent: it makes no difference to the tree structure (Huffman code of each node) if they are exchanged. Hence, several equivalent chains should be matched to a certain set of chains in the species only once.
</P><P>The algorithm of species matching is of the most importance since it provides technical support for structure-based description of species and reactions. It costs most of the running time. We will try to increase the efficiency of the codes of this part. 
</P><H1><SPAN class="mw-headline" id="Generation_of_products_based_on_reaction_templates">Generation of products based on reaction templates</SPAN></H1><P>
Within <I>MoDeL</I> definitions, product templates are composed of both <I>ST</I> parts and <I>NST</I> parts. The <I>ST</I> parts are all transfered from reactants or modifiers. A transfer table is defined in each reaction template to label where does each <I>ST</I> part comes from and goes to. It seems to be very easy to generate <I>Chain-Node</I> structure of products from reactants and mod modifiers based on the transfer table. However, it doesn't.
</P><P>Consider first a template reaction with one reactant, X-A-B-Y, where A and B are both <I>NST</I> parts and X and Y are both <I>ST</I> parts with type <I>ANY</I>. If it could be digested by a certain enzyme, the products should be X-A and B-Y. In the real biological system, if there is a species with structure C-A-B-C, where the first part C and the last C binds to form a tree node. If we try to digest the A-B bond, the species would not be split into two pieces as expected because the two products are connected by the tree node. To generate the structure of products correctly, we design a three-step <I>mix-trim-split</I> algorithm to solve this problem.
</P><DIV class="thumb tright"><DIV class="thumbinner" style="width:402px;"><DIV class="thumbcaption">Mixing, trimming and splitting: three-step algorithm to generate products.</DIV></DIV></DIV><P>The first step is to <I>mix</I> reactants and products. The mixture includes all chains of reactants except for those which are matched to the templates as well as all trees. It also includes all chains and trees of products. And now we have a mixed species with chains and trees from different sources. It is worth noting that chains and trees of modifiers will not be added into the mixture. The next step is to <I>trim</I> the trees. Trees with leaf nodes that are not defined in chains will be removed from the forest. The last step is to <I>split</I> the products out from the mixture. This is because the mixture may not be one standalone complex. For example, it may have two unbound and uncorrelated chains. In other words, some chains that are not connected with others via tree nodes should not be incorporated into other species. The final standalone split species are real products in the system.
</P><P>We provide an example to illustrate the product-generating procedure. The reactant has two chains, A-B-C and D-E-F. A, B, C bind with D, E, F, respectively. The products are A and C. First we <I>mix</I> chains and trees. Chain A-B-C will not appear in the mixture. Since node B does not appear in mixed chains, tree with nodes B and E will be removed in the <I>trim</I> process. Because part C and F, A and D, are both bound to nodes, the final product should contain A and B both after <I>split</I> processing.
</P><P>In the example above, there is only one product finally though two product templates are defined in database. What compartment does the product locate in if the two product templates locate in different compartments? A reasonable solution is to halve the quantities of the product and add it into both compartments. Another problem is that the corresponding reverse reaction would never be found because it fails to match two templates to only one species. The source of the two problems is essentially the same: how to describe intra-molecular reactions in framework of <I>MoDeL</I> language definitions. At present, it is not supported. However, supporting intra-molecular reactions is one of our future plans to refine our <I>MoDeL</I> language.
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2010.igem.org/Team:USTC_Software/Simulation">http://2010.igem.org/Team:USTC_Software/Simulation</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:USTC_Software/Simulation" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:USTC_Software/Simulation" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:USTC_Software/Simulation&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:USTC_Software/Simulation&amp;oldid=191529" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2010.igem.org:Privacy_policy" title="2010.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2010.igem.org:General_disclaimer" title="2010.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Hong_Kong_HKUST_human_practice_start-up_kit_database_js_vendor_list_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Hong Kong HKUST/human practice/start-up kit/database/js/vendor/list.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><DL><DT>(function(){
</DT></DL><P>/**
</P><PRE>* Require the given path.
*
* @param {String} path
* @return {Object} exports
* @api public
*/
</PRE><P>function require(path, parent, orig) {
</P><PRE> var resolved = require.resolve(path);
</PRE><PRE> // lookup failed
 if (null == resolved) {
   orig = orig || path;
   parent = parent || 'root';
   var err = new Error('Failed to require &quot;' + orig + '&quot; from &quot;' + parent + '&quot;');
   err.path = orig;
   err.parent = parent;
   err.require = true;
   throw err;
 }
</PRE><PRE> var module = require.modules[resolved];
</PRE><PRE> // perform real require()
 // by invoking the module's
 // registered function
 if (!module._resolving &amp;&amp; !module.exports) {
   var mod = {};
   mod.exports = {};
   mod.client = mod.component = true;
   module._resolving = true;
   module.call(this, mod.exports, require.relative(resolved), mod);
   delete module._resolving;
   module.exports = mod.exports;
 }
</PRE><PRE> return module.exports;
</PRE><P>}
</P><P>/**
</P><PRE>* Registered modules.
*/
</PRE><P>require.modules = {};
</P><P>/**
</P><PRE>* Registered aliases.
*/
</PRE><P>require.aliases = {};
</P><P>/**
</P><PRE>* Resolve `path`.
*
* Lookup:
*
*   - PATH/index.js
*   - PATH.js
*   - PATH
*
* @param {String} path
* @return {String} path or null
* @api private
*/
</PRE><P>require.resolve = function(path) {
</P><PRE> if (path.charAt(0) === '/') path = path.slice(1);
</PRE><PRE> var paths = [
   path,
   path + '.js',
   path + '.json',
   path + '/index.js',
   path + '/index.json'
 ];
</PRE><PRE> for (var i = 0; i &lt; paths.length; i++) {
   var path = paths[i];
   if (require.modules.hasOwnProperty(path)) return path;
   if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
 }
</PRE><P>};
</P><P>/**
</P><PRE>* Normalize `path` relative to the current path.
*
* @param {String} curr
* @param {String} path
* @return {String}
* @api private
*/
</PRE><P>require.normalize = function(curr, path) {
</P><PRE> var segs = [];
</PRE><PRE> if ('.' != path.charAt(0)) return path;
</PRE><PRE> curr = curr.split('/');
 path = path.split('/');
</PRE><PRE> for (var i = 0; i &lt; path.length; ++i) {
   if ('..' == path[i]) {
     curr.pop();
   } else if ('.' != path[i] &amp;&amp;<I> != path[i]) {</I>
     segs.push(path[i]);
   }
 }
</PRE><PRE> return curr.concat(segs).join('/');
</PRE><P>};
</P><P>/**
</P><PRE>* Register module at `path` with callback `definition`.
*
* @param {String} path
* @param {Function} definition
* @api private
*/
</PRE><P>require.register = function(path, definition) {
</P><PRE> require.modules[path] = definition;
</PRE><P>};
</P><P>/**
</P><PRE>* Alias a module definition.
*
* @param {String} from
* @param {String} to
* @api private
*/
</PRE><P>require.alias = function(from, to) {
</P><PRE> if (!require.modules.hasOwnProperty(from)) {
   throw new Error('Failed to alias &quot;' + from + '&quot;, it does not exist');
 }
 require.aliases[to] = from;
</PRE><P>};
</P><P>/**
</P><PRE>* Return a require function relative to the `parent` path.
*
* @param {String} parent
* @return {Function}
* @api private
*/
</PRE><P>require.relative = function(parent) {
</P><PRE> var p = require.normalize(parent, '..');
</PRE><PRE> /**
  * lastIndexOf helper.
  */
</PRE><PRE> function lastIndexOf(arr, obj) {
   var i = arr.length;
   while (i--) {
     if (arr[i] === obj) return i;
   }
   return -1;
 }
</PRE><PRE> /**
  * The relative require() itself.
  */
</PRE><PRE> function localRequire(path) {
   var resolved = localRequire.resolve(path);
   return require(resolved, parent, path);
 }
</PRE><PRE> /**
  * Resolve relative to the parent.
  */
</PRE><PRE> localRequire.resolve = function(path) {
   var c = path.charAt(0);
   if ('/' == c) return path.slice(1);
   if ('.' == c) return require.normalize(p, path);
</PRE><PRE>   // resolve deps by returning
   // the dep in the nearest &quot;deps&quot;
   // directory
   var segs = parent.split('/');
   var i = lastIndexOf(segs, 'deps') + 1;
   if (!i) i = 0;
   path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
   return path;
 };
</PRE><PRE> /**
  * Check if module is defined at `path`.
  */
</PRE><PRE> localRequire.exists = function(path) {
   return require.modules.hasOwnProperty(localRequire.resolve(path));
 };
</PRE><PRE> return localRequire;
</PRE><P>};
require.register(&quot;component-classes/index.js&quot;, function(exports, require, module){
/**
</P><PRE>* Module dependencies.
*/
</PRE><P>var index = require('indexof');
</P><P>/**
</P><PRE>* Whitespace regexp.
*/
</PRE><P>var re = /\s+/;
</P><P>/**
</P><PRE>* toString reference.
*/
</PRE><P>var toString = Object.prototype.toString;
</P><P>/**
</P><PRE>* Wrap `el` in a `ClassList`.
*
* @param {Element} el
* @return {ClassList}
* @api public
*/
</PRE><P>module.exports = function(el){
</P><PRE> return new ClassList(el);
</PRE><P>};
</P><P>/**
</P><PRE>* Initialize a new ClassList for `el`.
*
* @param {Element} el
* @api private
*/
</PRE><P>function ClassList(el) {
</P><PRE> if (!el) throw new Error('A DOM element reference is required');
 this.el = el;
 this.list = el.classList;
</PRE><P>}
</P><P>/**
</P><PRE>* Add class `name` if not already present.
*
* @param {String} name
* @return {ClassList}
* @api public
*/
</PRE><P>ClassList.prototype.add = function(name){
</P><PRE> // classList
 if (this.list) {
   this.list.add(name);
   return this;
 }
</PRE><PRE> // fallback
 var arr = this.array();
 var i = index(arr, name);
 if (!~i) arr.push(name);
 this.el.className = arr.join(' ');
 return this;
</PRE><P>};
</P><P>/**
</P><PRE>* Remove class `name` when present, or
* pass a regular expression to remove
* any which match.
*
* @param {String|RegExp} name
* @return {ClassList}
* @api public
*/
</PRE><P>ClassList.prototype.remove = function(name){
</P><PRE> if ('[object RegExp]' == toString.call(name)) {
   return this.removeMatching(name);
 }
</PRE><PRE> // classList
 if (this.list) {
   this.list.remove(name);
   return this;
 }
</PRE><PRE> // fallback
 var arr = this.array();
 var i = index(arr, name);
 if (~i) arr.splice(i, 1);
 this.el.className = arr.join(' ');
 return this;
</PRE><P>};
</P><P>/**
</P><PRE>* Remove all classes matching `re`.
*
* @param {RegExp} re
* @return {ClassList}
* @api private
*/
</PRE><P>ClassList.prototype.removeMatching = function(re){
</P><PRE> var arr = this.array();
 for (var i = 0; i &lt; arr.length; i++) {
   if (re.test(arr[i])) {
     this.remove(arr[i]);
   }
 }
 return this;
</PRE><P>};
</P><P>/**
</P><PRE>* Toggle class `name`, can force state via `force`.
*
* For browsers that support classList, but do not support `force` yet,
* the mistake will be detected and corrected.
*
* @param {String} name
* @param {Boolean} force
* @return {ClassList}
* @api public
*/
</PRE><P>ClassList.prototype.toggle = function(name, force){
</P><PRE> // classList
 if (this.list) {
   if (&quot;undefined&quot; !== typeof force) {
     if (force !== this.list.toggle(name, force)) {
       this.list.toggle(name); // toggle again to correct
     }
   } else {
     this.list.toggle(name);
   }
   return this;
 }
</PRE><PRE> // fallback
 if (&quot;undefined&quot; !== typeof force) {
   if (!force) {
     this.remove(name);
   } else {
     this.add(name);
   }
 } else {
   if (this.has(name)) {
     this.remove(name);
   } else {
     this.add(name);
   }
 }
</PRE><PRE> return this;
</PRE><P>};
</P><P>/**
</P><PRE>* Return an array of classes.
*
* @return {Array}
* @api public
*/
</PRE><P>ClassList.prototype.array = function(){
</P><PRE> var str = this.el.className.replace(/^\s+|\s+$/g, <I>);</I>
 var arr = str.split(re);
 if (<I> === arr[0]) arr.shift();</I>
 return arr;
</PRE><P>};
</P><P>/**
</P><PRE>* Check if class `name` is present.
*
* @param {String} name
* @return {ClassList}
* @api public
*/
</PRE><P>ClassList.prototype.has =
ClassList.prototype.contains = function(name){
</P><PRE> return this.list
   ? this.list.contains(name)
   : !! ~index(this.array(), name);
</PRE><P>};
</P><P>});
require.register(&quot;segmentio-extend/index.js&quot;, function(exports, require, module){
</P><P>module.exports = function extend (object) {
</P><PRE>   // Takes an unlimited number of extenders.
   var args = Array.prototype.slice.call(arguments, 1);
</PRE><PRE>   // For each extender, copy their properties on our object.
   for (var i = 0, source; source = args[i]; i++) {
       if (!source) continue;
       for (var property in source) {
           object[property] = source[property];
       }
   }
</PRE><PRE>   return object;
</PRE><P>};
});
require.register(&quot;component-indexof/index.js&quot;, function(exports, require, module){
module.exports = function(arr, obj){
</P><PRE> if (arr.indexOf) return arr.indexOf(obj);
 for (var i = 0; i &lt; arr.length; ++i) {
   if (arr[i] === obj) return i;
 }
 return -1;
</PRE><P>};
});
require.register(&quot;component-event/index.js&quot;, function(exports, require, module){
var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
</P><PRE>   unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
   prefix = bind !== 'addEventListener' ? 'on' : <I>;</I></PRE><P>/**
</P><PRE>* Bind `el` event `type` to `fn`.
*
* @param {Element} el
* @param {String} type
* @param {Function} fn
* @param {Boolean} capture
* @return {Function}
* @api public
*/
</PRE><P>exports.bind = function(el, type, fn, capture){
</P><PRE> el[bind](prefix + type, fn, capture || false);
 return fn;
</PRE><P>};
</P><P>/**
</P><PRE>* Unbind `el` event `type`'s callback `fn`.
*
* @param {Element} el
* @param {String} type
* @param {Function} fn
* @param {Boolean} capture
* @return {Function}
* @api public
*/
</PRE><P>exports.unbind = function(el, type, fn, capture){
</P><PRE> el[unbind](prefix + type, fn, capture || false);
 return fn;
</PRE><P>};
});
require.register(&quot;timoxley-to-array/index.js&quot;, function(exports, require, module){
/**
</P><PRE>* Convert an array-like object into an `Array`.
* If `collection` is already an `Array`, then will return a clone of `collection`.
*
* @param {Array | Mixed} collection An `Array` or array-like object to convert e.g. `arguments` or `NodeList`
* @return {Array} Naive conversion of `collection` to a new `Array`.
* @api public
*/
</PRE><P>module.exports = function toArray(collection) {
</P><PRE> if (typeof collection === 'undefined') return []
 if (collection === null) return [null]
 if (collection === window) return [window]
 if (typeof collection === 'string') return [collection]
 if (isArray(collection)) return collection
 if (typeof collection.length != 'number') return [collection]
 if (typeof collection === 'function' &amp;&amp; collection instanceof Function) return [collection]
</PRE><PRE> var arr = []
 for (var i = 0; i &lt; collection.length; i++) {
   if (Object.prototype.hasOwnProperty.call(collection, i) || i in collection) {
     arr.push(collection[i])
   }
 }
 if (!arr.length) return []
 return arr
</PRE><P>}
</P><P>function isArray(arr) {
</P><PRE> return Object.prototype.toString.call(arr) === &quot;[object Array]&quot;;
</PRE><P>}
</P><P>});
require.register(&quot;javve-events/index.js&quot;, function(exports, require, module){
var events = require('event'),
</P><PRE> toArray = require('to-array');
</PRE><P>/**
</P><PRE>* Bind `el` event `type` to `fn`.
*
* @param {Element} el, NodeList, HTMLCollection or Array
* @param {String} type
* @param {Function} fn
* @param {Boolean} capture
* @api public
*/
</PRE><P>exports.bind = function(el, type, fn, capture){
</P><PRE> el = toArray(el);
 for ( var i = 0; i &lt; el.length; i++ ) {
   events.bind(el[i], type, fn, capture);
 }
</PRE><P>};
</P><P>/**
</P><PRE>* Unbind `el` event `type`'s callback `fn`.
*
* @param {Element} el, NodeList, HTMLCollection or Array
* @param {String} type
* @param {Function} fn
* @param {Boolean} capture
* @api public
*/
</PRE><P>exports.unbind = function(el, type, fn, capture){
</P><PRE> el = toArray(el);
 for ( var i = 0; i &lt; el.length; i++ ) {
   events.unbind(el[i], type, fn, capture);
 }
</PRE><P>};
</P><P>});
require.register(&quot;javve-get-by-class/index.js&quot;, function(exports, require, module){
/**
</P><PRE>* Find all elements with class `className` inside `container`.
* Use `single = true` to increase performance in older browsers
* when only one element is needed.
*
* @param {String} className
* @param {Element} container
* @param {Boolean} single
* @api public
*/
</PRE><P>module.exports = (function() {
</P><PRE> if (document.getElementsByClassName) {
   return function(container, className, single) {
     if (single) {
       return container.getElementsByClassName(className)[0];
     } else {
       return container.getElementsByClassName(className);
     }
   };
 } else if (document.querySelector) {
   return function(container, className, single) {
     className = '.' + className;
     if (single) {
       return container.querySelector(className);
     } else {
       return container.querySelectorAll(className);
     }
   };
 } else {
   return function(container, className, single) {
     var classElements = [],
       tag = '*';
     if (container == null) {
       container = document;
     }
     var els = container.getElementsByTagName(tag);
     var elsLen = els.length;
     var pattern = new RegExp(&quot;(^|\\s)&quot;+className+&quot;(\\s|$)&quot;);
     for (var i = 0, j = 0; i &lt; elsLen; i++) {
       if ( pattern.test(els[i].className) ) {
         if (single) {
           return els[i];
         } else {
           classElements[j] = els[i];
           j++;
         }
       }
     }
     return classElements;
   };
 }
</PRE><P>})();
</P><P>});
require.register(&quot;javve-get-attribute/index.js&quot;, function(exports, require, module){
/**
</P><PRE>* Return the value for `attr` at `element`.
*
* @param {Element} el
* @param {String} attr
* @api public
*/
</PRE><P>module.exports = function(el, attr) {
</P><PRE> var result = (el.getAttribute &amp;&amp; el.getAttribute(attr)) || null;
 if( !result ) {
   var attrs = el.attributes;
   var length = attrs.length;
   for(var i = 0; i &lt; length; i++) {
     if (attr[i] !== undefined) {
       if(attr[i].nodeName === attr) {
         result = attr[i].nodeValue;
       }
     }
   }
 }
 return result;
</PRE><P>}
});
require.register(&quot;javve-natural-sort/index.js&quot;, function(exports, require, module){
/*
</P><PRE>* Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
* Author: Jim Palmer (based on chunking idea from Dave Koelle)
*/
</PRE><P>module.exports = function(a, b, options) {
</P><PRE> var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi,
   sre = /(^[ ]*|[ ]*$)/g,
   dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
   hre = /^0x[0-9a-f]+$/i,
   ore = /^0/,
   options = options || {},
   i = function(s) { return options.insensitive &amp;&amp; (<I>+s).toLowerCase() || </I>+s },
   // convert all to strings strip whitespace
   x = i(a).replace(sre, <I>) || </I>,
   y = i(b).replace(sre, <I>) || </I>,
   // chunk/tokenize
   xN = x.replace(re, '\0$1\0').replace(/\0$/,<I>).replace(/^\0/,</I>).split('\0'),
   yN = y.replace(re, '\0$1\0').replace(/\0$/,<I>).replace(/^\0/,</I>).split('\0'),
   // numeric, hex or date detection
   xD = parseInt(x.match(hre)) || (xN.length != 1 &amp;&amp; x.match(dre) &amp;&amp; Date.parse(x)),
   yD = parseInt(y.match(hre)) || xD &amp;&amp; y.match(dre) &amp;&amp; Date.parse(y) || null,
   oFxNcL, oFyNcL,
   mult = options.desc ? -1 : 1;
 // first try and sort Hex codes or Dates
 if (yD)
   if ( xD &lt; yD ) return -1 * mult;
   else if ( xD &gt; yD ) return 1 * mult;
 // natural sorting through split numeric strings and default strings
 for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc &lt; numS; cLoc++) {
   // find floats not starting with '0', string or 0 if not defined (Clint Priest)
   oFxNcL = !(xN[cLoc] || <I>).match(ore) &amp;&amp; parseFloat(xN[cLoc]) || xN[cLoc] || 0;</I>
   oFyNcL = !(yN[cLoc] || <I>).match(ore) &amp;&amp; parseFloat(yN[cLoc]) || yN[cLoc] || 0;</I>
   // handle numeric vs string comparison - number &lt; string - (Kyle Adams)
   if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
   // rely on string comparison if different types - i.e. '02' &lt; 2 != '02' &lt; '2'
   else if (typeof oFxNcL !== typeof oFyNcL) {
     oFxNcL += <I>;</I>
     oFyNcL += <I>;</I>
   }
   if (oFxNcL &lt; oFyNcL) return -1 * mult;
   if (oFxNcL &gt; oFyNcL) return 1 * mult;
 }
 return 0;
</PRE><P>};
</P><P>/*
var defaultSort = getSortFunction();
</P><P>module.exports = function(a, b, options) {
</P><PRE> if (arguments.length == 1) {
   options = a;
   return getSortFunction(options);
 } else {
   return defaultSort(a,b);
 }
</PRE><P>}
</P><UL><LI>/
</LI></UL><P>});
require.register(&quot;javve-to-string/index.js&quot;, function(exports, require, module){
module.exports = function(s) {
</P><PRE>   s = (s === undefined) ? &quot;&quot; : s;
   s = (s === null) ? &quot;&quot; : s;
   s = s.toString();
   return s;
</PRE><P>};
</P><P>});
require.register(&quot;component-type/index.js&quot;, function(exports, require, module){
/**
</P><PRE>* toString ref.
*/
</PRE><P>var toString = Object.prototype.toString;
</P><P>/**
</P><PRE>* Return the type of `val`.
*
* @param {Mixed} val
* @return {String}
* @api public
*/
</PRE><P>module.exports = function(val){
</P><PRE> switch (toString.call(val)) {
   case '[object Date]': return 'date';
   case '[object RegExp]': return 'regexp';
   case '[object Arguments]': return 'arguments';
   case '[object Array]': return 'array';
   case '[object Error]': return 'error';
 }
</PRE><PRE> if (val === null) return 'null';
 if (val === undefined) return 'undefined';
 if (val !== val) return 'nan';
 if (val &amp;&amp; val.nodeType === 1) return 'element';
</PRE><PRE> return typeof val.valueOf();
</PRE><P>};
</P><P>});
require.register(&quot;list.js/index.js&quot;, function(exports, require, module){
/*
ListJS with beta 1.0.0
By Jonny Strömberg (www.jonnystromberg.com, www.listjs.com)
</P><UL><LI>/
</LI></UL><P>(function( window, undefined ) {
&quot;use strict&quot;;
</P><P>var document = window.document,
</P><PRE>   getByClass = require('get-by-class'),
   extend = require('extend'),
   indexOf = require('indexof');
</PRE><P>var List = function(id, options, values) {
</P><PRE>   var self = this,
</PRE><P>		init,
</P><PRE>       Item = require('./src/item')(self),
       addAsync = require('./src/add-async')(self),
       parse = require('./src/parse')(self);
</PRE><PRE>   init = {
       start: function() {
           self.listClass      = &quot;list&quot;;
           self.searchClass    = &quot;search&quot;;
           self.sortClass      = &quot;sort&quot;;
           self.page           = 200;
           self.i              = 1;
           self.items          = [];
           self.visibleItems   = [];
           self.matchingItems  = [];
           self.searched       = false;
           self.filtered       = false;
           self.handlers       = { 'updated': [] };
           self.plugins        = {};
           self.helpers        = {
               getByClass: getByClass,
               extend: extend,
               indexOf: indexOf
           };
</PRE><PRE>           extend(self, options);
</PRE><PRE>           self.listContainer = (typeof(id) === 'string') ? document.getElementById(id) : id;
           if (!self.listContainer) { return; }
           self.list           = getByClass(self.listContainer, self.listClass, true);
</PRE><PRE>           self.templater      = require('./src/templater')(self);
           self.search         = require('./src/search')(self);
           self.filter         = require('./src/filter')(self);
           self.sort           = require('./src/sort')(self);
</PRE><PRE>           this.items();
           self.update();
           this.plugins();
       },
       items: function() {
           parse(self.list);
           if (values !== undefined) {
               self.add(values);
           }
       },
       plugins: function() {
           for (var i = 0; i &lt; self.plugins.length; i++) {
               var plugin = self.plugins[i];
               self[plugin.name] = plugin;
               plugin.init(self);
           }
       }
   };
</PRE><PRE>   /*
   * Add object to list
   */
   this.add = function(values, callback) {
       if (callback) {
           addAsync(values, callback);
           return;
       }
       var added = [],
           notCreate = false;
       if (values[0] === undefined){
           values = [values];
       }
       for (var i = 0, il = values.length; i &lt; il; i++) {
           var item = null;
           if (values[i] instanceof Item) {
               item = values[i];
               item.reload();
           } else {
               notCreate = (self.items.length &gt; self.page) ? true : false;
               item = new Item(values[i], undefined, notCreate);
           }
           self.items.push(item);
           added.push(item);
       }
       self.update();
       return added;
   };
</PRE><P>	this.show = function(i, page) {
		this.i = i;
		this.page = page;
		self.update();
</P><PRE>       return self;
</PRE><P>	};
</P><PRE>   /* Removes object from list.
   * Loops through the list and removes objects where
   * property &quot;valuename&quot; === value
   */
   this.remove = function(valueName, value, options) {
       var found = 0;
       for (var i = 0, il = self.items.length; i &lt; il; i++) {
           if (self.items[i].values()[valueName] == value) {
               self.templater.remove(self.items[i], options);
               self.items.splice(i,1);
               il--;
               i--;
               found++;
           }
       }
       self.update();
       return found;
   };
</PRE><PRE>   /* Gets the objects in the list which
   * property &quot;valueName&quot; === value
   */
   this.get = function(valueName, value) {
       var matchedItems = [];
       for (var i = 0, il = self.items.length; i &lt; il; i++) {
           var item = self.items[i];
           if (item.values()[valueName] == value) {
               matchedItems.push(item);
           }
       }
       return matchedItems;
   };
</PRE><PRE>   /*
   * Get size of the list
   */
   this.size = function() {
       return self.items.length;
   };
</PRE><PRE>   /*
   * Removes all items from the list
   */
   this.clear = function() {
       self.templater.clear();
       self.items = [];
       return self;
   };
</PRE><PRE>   this.on = function(event, callback) {
       self.handlers[event].push(callback);
       return self;
   };
</PRE><PRE>   this.off = function(event, callback) {
       var e = self.handlers[event];
       var index = indexOf(e, callback);
       if (index &gt; -1) {
           e.splice(index, 1);
       }
       return self;
   };
</PRE><PRE>   this.trigger = function(event) {
       var i = self.handlers[event].length;
       while(i--) {
           self.handlers[event][i](self);
       }
       return self;
   };
</PRE><PRE>   this.reset = {
       filter: function() {
           var is = self.items,
               il = is.length;
           while (il--) {
               is[il].filtered = false;
           }
           return self;
       },
       search: function() {
           var is = self.items,
               il = is.length;
           while (il--) {
               is[il].found = false;
           }
           return self;
       }
   };
</PRE><PRE>   this.update = function() {
       var is = self.items,
</PRE><P>			il = is.length;
</P><PRE>       self.visibleItems = [];
       self.matchingItems = [];
       self.templater.clear();
       for (var i = 0; i &lt; il; i++) {
           if (is[i].matching() &amp;&amp; ((self.matchingItems.length+1) &gt;= self.i &amp;&amp; self.visibleItems.length &lt; self.page)) {
               is[i].show();
               self.visibleItems.push(is[i]);
               self.matchingItems.push(is[i]);
</PRE><P>			} else if (is[i].matching()) {
</P><PRE>               self.matchingItems.push(is[i]);
               is[i].hide();
</PRE><P>			} else {
</P><PRE>               is[i].hide();
</PRE><P>			}
</P><PRE>       }
       self.trigger('updated');
       return self;
   };
</PRE><PRE>   init.start();
</PRE><P>};
</P><P>module.exports = List;
</P><P>})(window);
</P><P>});
require.register(&quot;list.js/src/search.js&quot;, function(exports, require, module){
var events = require('events'),
</P><PRE>   getByClass = require('get-by-class'),
   toString = require('to-string');
</PRE><P>module.exports = function(list) {
</P><PRE>   var item,
       text,
       columns,
       searchString,
       customSearch;
</PRE><PRE>   var prepare = {
       resetList: function() {
           list.i = 1;
           list.templater.clear();
           customSearch = undefined;
       },
       setOptions: function(args) {
           if (args.length == 2 &amp;&amp; args[1] instanceof Array) {
               columns = args[1];
           } else if (args.length == 2 &amp;&amp; typeof(args[1]) == &quot;function&quot;) {
               customSearch = args[1];
           } else if (args.length == 3) {
               columns = args[1];
               customSearch = args[2];
           }
       },
       setColumns: function() {
           columns = (columns === undefined) ? prepare.toArray(list.items[0].values()) : columns;
       },
       setSearchString: function(s) {
           s = toString(s).toLowerCase();
           s = s.replace(/[-[\]{}()*+?.,\\^$|#]/g, &quot;\\$&amp;&quot;); // Escape regular expression characters
           searchString = s;
       },
       toArray: function(values) {
           var tmpColumn = [];
           for (var name in values) {
               tmpColumn.push(name);
           }
           return tmpColumn;
       }
   };
   var search = {
       list: function() {
           for (var k = 0, kl = list.items.length; k &lt; kl; k++) {
               search.item(list.items[k]);
           }
       },
       item: function(item) {
           item.found = false;
           for (var j = 0, jl = columns.length; j &lt; jl; j++) {
               if (search.values(item.values(), columns[j])) {
                   item.found = true;
                   return;
               }
           }
       },
       values: function(values, column) {
           if (values.hasOwnProperty(column)) {
               text = toString(values[column]).toLowerCase();
               if ((searchString !== &quot;&quot;) &amp;&amp; (text.search(searchString) &gt; -1)) {
                   return true;
               }
           }
           return false;
       },
       reset: function() {
           list.reset.search();
           list.searched = false;
       }
   };
</PRE><PRE>   var searchMethod = function(str) {
       list.trigger('searchStart');
</PRE><PRE>       prepare.resetList();
       prepare.setSearchString(str);
       prepare.setOptions(arguments); // str, cols|searchFunction, searchFunction
       prepare.setColumns();
</PRE><PRE>       if (searchString === &quot;&quot; ) {
           search.reset();
       } else {
           list.searched = true;
           if (customSearch) {
               customSearch(searchString, columns);
           } else {
               search.list();
           }
       }
</PRE><PRE>       list.update();
       list.trigger('searchComplete');
       return list.visibleItems;
   };
</PRE><PRE>   list.handlers.searchStart = list.handlers.searchStart || [];
   list.handlers.searchComplete = list.handlers.searchComplete || [];
</PRE><PRE>   events.bind(getByClass(list.listContainer, list.searchClass), 'keyup', function(e) {
       var target = e.target || e.srcElement, // IE have srcElement
           alreadyCleared = (target.value === &quot;&quot; &amp;&amp; !list.searched);
       if (!alreadyCleared) { // If oninput already have resetted the list, do nothing
           searchMethod(target.value);
       }
   });
</PRE><PRE>   // Used to detect click on HTML5 clear button
   events.bind(getByClass(list.listContainer, list.searchClass), 'input', function(e) {
       var target = e.target || e.srcElement;
       if (target.value === &quot;&quot;) {
           searchMethod(<I>);</I>
       }
   });
</PRE><PRE>   list.helpers.toString = toString;
   return searchMethod;
</PRE><P>};
</P><P>});
require.register(&quot;list.js/src/sort.js&quot;, function(exports, require, module){
var naturalSort = require('natural-sort'),
</P><PRE>   classes = require('classes'),
   events = require('events'),
   getByClass = require('get-by-class'),
   getAttribute = require('get-attribute');
</PRE><P>module.exports = function(list) {
</P><PRE>   list.sortFunction = list.sortFunction || function(itemA, itemB, options) {
       options.desc = options.order == &quot;desc&quot; ? true : false; // Natural sort uses this format
       return naturalSort(itemA.values()[options.valueName], itemB.values()[options.valueName], options);
   };
</PRE><PRE>   var buttons = {
       els: undefined,
       clear: function() {
           for (var i = 0, il = buttons.els.length; i &lt; il; i++) {
               classes(buttons.els[i]).remove('asc');
               classes(buttons.els[i]).remove('desc');
           }
       },
       getOrder: function(btn) {
           var predefinedOrder = getAttribute(btn, 'data-order');
           if (predefinedOrder == &quot;asc&quot; || predefinedOrder == &quot;desc&quot;) {
               return predefinedOrder;
           } else if (classes(btn).has('desc')) {
               return &quot;asc&quot;;
           } else if (classes(btn).has('asc')) {
               return &quot;desc&quot;;
           } else {
               return &quot;asc&quot;;
           }
       },
       getInSensitive: function(btn, options) {
           var insensitive = getAttribute(btn, 'data-insensitive');
           if (insensitive === &quot;true&quot;) {
               options.insensitive = true;
           } else {
               options.insensitive = false;
           }
       },
       setOrder: function(options) {
           for (var i = 0, il = buttons.els.length; i &lt; il; i++) {
               var btn = buttons.els[i];
               if (getAttribute(btn, 'data-sort') !== options.valueName) {
                   continue;
               }
               var predefinedOrder = getAttribute(btn, 'data-order');
               if (predefinedOrder == &quot;asc&quot; || predefinedOrder == &quot;desc&quot;) {
                   if (predefinedOrder == options.order) {
                       classes(btn).add(options.order);
                   }
               } else {
                   classes(btn).add(options.order);
               }
           }
       }
   };
   var sort = function() {
       list.trigger('sortStart');
       options = {};
</PRE><PRE>       var target = arguments[0].currentTarget || arguments[0].srcElement || undefined;
</PRE><PRE>       if (target) {
           options.valueName = getAttribute(target, 'data-sort');
           buttons.getInSensitive(target, options);
           options.order = buttons.getOrder(target);
       } else {
           options = arguments[1] || options;
           options.valueName = arguments[0];
           options.order = options.order || &quot;asc&quot;;
           options.insensitive = (typeof options.insensitive == &quot;undefined&quot;) ? true : options.insensitive;
       }
       buttons.clear();
       buttons.setOrder(options);
</PRE><PRE>       options.sortFunction = options.sortFunction || list.sortFunction;
       list.items.sort(function(a, b) {
           return options.sortFunction(a, b, options);
       });
       list.update();
       list.trigger('sortComplete');
   };
</PRE><PRE>   // Add handlers
   list.handlers.sortStart = list.handlers.sortStart || [];
   list.handlers.sortComplete = list.handlers.sortComplete || [];
</PRE><PRE>   buttons.els = getByClass(list.listContainer, list.sortClass);
   events.bind(buttons.els, 'click', sort);
   list.on('searchStart', buttons.clear);
   list.on('filterStart', buttons.clear);
</PRE><PRE>   // Helpers
   list.helpers.classes = classes;
   list.helpers.naturalSort = naturalSort;
   list.helpers.events = events;
   list.helpers.getAttribute = getAttribute;
</PRE><PRE>   return sort;
</PRE><P>};
</P><P>});
require.register(&quot;list.js/src/item.js&quot;, function(exports, require, module){
module.exports = function(list) {
</P><PRE>   return function(initValues, element, notCreate) {
       var item = this;
</PRE><PRE>       this._values = {};
</PRE><PRE>       this.found = false; // Show if list.searched == true and this.found == true
       this.filtered = false;// Show if list.filtered == true and this.filtered == true
</PRE><PRE>       var init = function(initValues, element, notCreate) {
           if (element === undefined) {
               if (notCreate) {
                   item.values(initValues, notCreate);
               } else {
                   item.values(initValues);
               }
           } else {
               item.elm = element;
               var values = list.templater.get(item, initValues);
               item.values(values);
           }
       };
       this.values = function(newValues, notCreate) {
           if (newValues !== undefined) {
               for(var name in newValues) {
                   item._values[name] = newValues[name];
               }
               if (notCreate !== true) {
                   list.templater.set(item, item.values());
               }
           } else {
               return item._values;
           }
       };
       this.show = function() {
           list.templater.show(item);
       };
       this.hide = function() {
           list.templater.hide(item);
       };
       this.matching = function() {
           return (
               (list.filtered &amp;&amp; list.searched &amp;&amp; item.found &amp;&amp; item.filtered) ||
               (list.filtered &amp;&amp; !list.searched &amp;&amp; item.filtered) ||
               (!list.filtered &amp;&amp; list.searched &amp;&amp; item.found) ||
               (!list.filtered &amp;&amp; !list.searched)
           );
       };
       this.visible = function() {
           return (item.elm.parentNode == list.list) ? true : false;
       };
       init(initValues, element, notCreate);
   };
</PRE><P>};
</P><P>});
require.register(&quot;list.js/src/templater.js&quot;, function(exports, require, module){
var getByClass = require('get-by-class');
</P><P>var Templater = function(list) {
</P><PRE>   var itemSource = getItemSource(list.item),
       templater = this;
</PRE><PRE>   function getItemSource(item) {
       if (item === undefined) {
           var nodes = list.list.childNodes,
               items = [];
</PRE><PRE>           for (var i = 0, il = nodes.length; i &lt; il; i++) {
               // Only textnodes have a data attribute
               if (nodes[i].data === undefined) {
                   return nodes[i];
               }
           }
           return null;
       } else if (item.indexOf(&quot;&lt;&quot;) !== -1) { // Try create html element of list, do not work for tables!!
           var div = document.createElement('div');
           div.innerHTML = item;
           return div.firstChild;
       } else {
           return document.getElementById(list.item);
       }
   }
</PRE><PRE>   /* Get values from element */
   this.get = function(item, valueNames) {
       templater.create(item);
       var values = {};
       for(var i = 0, il = valueNames.length; i &lt; il; i++) {
           var elm = getByClass(item.elm, valueNames[i], true);
           values[valueNames[i]] = elm ? elm.innerHTML : &quot;&quot;;
       }
       return values;
   };
</PRE><PRE>   /* Sets values at element */
   this.set = function(item, values) {
       if (!templater.create(item)) {
           for(var v in values) {
               if (values.hasOwnProperty(v)) {
                   // TODO speed up if possible
                   var elm = getByClass(item.elm, v, true);
                   if (elm) {
                       /* src attribute for image tag &amp; text for other tags */
                       if (elm.tagName === &quot;IMG&quot; &amp;&amp; values[v] !== &quot;&quot;) {
                           elm.src = values[v];
                       } else {
                           elm.innerHTML = values[v];
                       }
                   }
               }
           }
       }
   };
</PRE><PRE>   this.create = function(item) {
       if (item.elm !== undefined) {
           return false;
       }
       /* If item source does not exists, use the first item in list as
       source for new items */
       var newItem = itemSource.cloneNode(true);
       newItem.removeAttribute('id');
       item.elm = newItem;
       templater.set(item, item.values());
       return true;
   };
   this.remove = function(item) {
       list.list.removeChild(item.elm);
   };
   this.show = function(item) {
       templater.create(item);
       list.list.appendChild(item.elm);
   };
   this.hide = function(item) {
       if (item.elm !== undefined &amp;&amp; item.elm.parentNode === list.list) {
           list.list.removeChild(item.elm);
       }
   };
   this.clear = function() {
       /* .innerHTML = <I>; fucks up IE */</I>
       if (list.list.hasChildNodes()) {
           while (list.list.childNodes.length &gt;= 1)
           {
               list.list.removeChild(list.list.firstChild);
           }
       }
   };
</PRE><P>};
</P><P>module.exports = function(list) {
</P><PRE>   return new Templater(list);
</PRE><P>};
</P><P>});
require.register(&quot;list.js/src/filter.js&quot;, function(exports, require, module){
module.exports = function(list) {
</P><PRE>   // Add handlers
   list.handlers.filterStart = list.handlers.filterStart || [];
   list.handlers.filterComplete = list.handlers.filterComplete || [];
</PRE><PRE>   return function(filterFunction) {
       list.trigger('filterStart');
       list.i = 1; // Reset paging
       list.reset.filter();
       if (filterFunction === undefined) {
           list.filtered = false;
       } else {
           list.filtered = true;
           var is = list.items;
           for (var i = 0, il = is.length; i &lt; il; i++) {
               var item = is[i];
               if (filterFunction(item)) {
                   item.filtered = true;
               } else {
                   item.filtered = false;
               }
           }
       }
       list.update();
       list.trigger('filterComplete');
       return list.visibleItems;
   };
</PRE><P>};
</P><P>});
require.register(&quot;list.js/src/add-async.js&quot;, function(exports, require, module){
module.exports = function(list) {
</P><PRE>   return function(values, callback, items) {
       var valuesToAdd = values.splice(0, 100);
       items = items || [];
       items = items.concat(list.add(valuesToAdd));
       if (values.length &gt; 0) {
           setTimeout(function() {
               addAsync(values, callback, items);
           }, 10);
       } else {
           list.update();
           callback(items);
       }
   };
</PRE><P>};
});
require.register(&quot;list.js/src/parse.js&quot;, function(exports, require, module){
module.exports = function(list) {
</P><PRE>   var Item = require('./item')(list);
</PRE><PRE>   var getChildren = function(parent) {
       var nodes = parent.childNodes,
           items = [];
       for (var i = 0, il = nodes.length; i &lt; il; i++) {
           // Only textnodes have a data attribute
           if (nodes[i].data === undefined) {
               items.push(nodes[i]);
           }
       }
       return items;
   };
</PRE><PRE>   var parse = function(itemElements, valueNames) {
       for (var i = 0, il = itemElements.length; i &lt; il; i++) {
           list.items.push(new Item(valueNames, itemElements[i]));
       }
   };
   var parseAsync = function(itemElements, valueNames) {
       var itemsToIndex = itemElements.splice(0, 100); // TODO: If &lt; 100 items, what happens in IE etc?
       parse(itemsToIndex, valueNames);
       if (itemElements.length &gt; 0) {
           setTimeout(function() {
               init.items.indexAsync(itemElements, valueNames);
           }, 10);
       } else {
           list.update();
           // TODO: Add indexed callback
       }
   };
</PRE><PRE>   return function() {
       var itemsToIndex = getChildren(list.list),
           valueNames = list.valueNames;
</PRE><PRE>       if (list.indexAsync) {
           parseAsync(itemsToIndex, valueNames);
       } else {
           parse(itemsToIndex, valueNames);
       }
   };
</PRE><P>};
</P><P>});
</P><P>
require.alias(&quot;component-classes/index.js&quot;, &quot;list.js/deps/classes/index.js&quot;);
require.alias(&quot;component-classes/index.js&quot;, &quot;classes/index.js&quot;);
require.alias(&quot;component-indexof/index.js&quot;, &quot;component-classes/deps/indexof/index.js&quot;);
</P><P>require.alias(&quot;segmentio-extend/index.js&quot;, &quot;list.js/deps/extend/index.js&quot;);
require.alias(&quot;segmentio-extend/index.js&quot;, &quot;extend/index.js&quot;);
</P><P>require.alias(&quot;component-indexof/index.js&quot;, &quot;list.js/deps/indexof/index.js&quot;);
require.alias(&quot;component-indexof/index.js&quot;, &quot;indexof/index.js&quot;);
</P><P>require.alias(&quot;javve-events/index.js&quot;, &quot;list.js/deps/events/index.js&quot;);
require.alias(&quot;javve-events/index.js&quot;, &quot;events/index.js&quot;);
require.alias(&quot;component-event/index.js&quot;, &quot;javve-events/deps/event/index.js&quot;);
</P><P>require.alias(&quot;timoxley-to-array/index.js&quot;, &quot;javve-events/deps/to-array/index.js&quot;);
</P><P>require.alias(&quot;javve-get-by-class/index.js&quot;, &quot;list.js/deps/get-by-class/index.js&quot;);
require.alias(&quot;javve-get-by-class/index.js&quot;, &quot;get-by-class/index.js&quot;);
</P><P>require.alias(&quot;javve-get-attribute/index.js&quot;, &quot;list.js/deps/get-attribute/index.js&quot;);
require.alias(&quot;javve-get-attribute/index.js&quot;, &quot;get-attribute/index.js&quot;);
</P><P>require.alias(&quot;javve-natural-sort/index.js&quot;, &quot;list.js/deps/natural-sort/index.js&quot;);
require.alias(&quot;javve-natural-sort/index.js&quot;, &quot;natural-sort/index.js&quot;);
</P><P>require.alias(&quot;javve-to-string/index.js&quot;, &quot;list.js/deps/to-string/index.js&quot;);
require.alias(&quot;javve-to-string/index.js&quot;, &quot;list.js/deps/to-string/index.js&quot;);
require.alias(&quot;javve-to-string/index.js&quot;, &quot;to-string/index.js&quot;);
require.alias(&quot;javve-to-string/index.js&quot;, &quot;javve-to-string/index.js&quot;);
require.alias(&quot;component-type/index.js&quot;, &quot;list.js/deps/type/index.js&quot;);
require.alias(&quot;component-type/index.js&quot;, &quot;type/index.js&quot;);
if (typeof exports == &quot;object&quot;) {
</P><PRE> module.exports = require(&quot;list.js&quot;);
</PRE><P>} else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) {
</P><PRE> define(function(){ return require(&quot;list.js&quot;); });
</PRE><P>} else {
</P><PRE> this[&quot;List&quot;] = require(&quot;list.js&quot;);
</PRE><P>}})();
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js">http://2014.igem.org/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/list.js&amp;oldid=127727" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>
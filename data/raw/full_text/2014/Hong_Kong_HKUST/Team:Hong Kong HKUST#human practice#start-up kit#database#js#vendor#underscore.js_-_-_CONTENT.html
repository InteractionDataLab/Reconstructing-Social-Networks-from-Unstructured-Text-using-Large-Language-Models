<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
<style type="text/css">
A:before { content:' '; } 
A:after { content:' '; } 
SPAN:before { content:' '; } 
SPAN:after { content:' '; } 
</style>
<BODY class="mediawiki  ltr ns-0 ns-subject page-Team_Hong_Kong_HKUST_human_practice_start-up_kit_database_js_vendor_underscore_js"><DIV id="globalWrapper"><DIV id="top-section"><DIV id="p-logo"><A href="/Main_Page" title="Main Page">&quot;
	    </A></DIV><DIV id="menubar" class="left-menu noprint"><UL><LI class="selected"><A href="/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js">Page               </A></LI><LI class="new"><A href="/wiki/index.php?title=Talk:Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js&amp;action=edit&amp;redlink=1">Discussion               </A></LI><LI><A href="/wiki/index.php?title=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js&amp;action=edit">View source               </A></LI><LI><A href="/wiki/index.php?title=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js&amp;action=history">History               </A></LI><LI style="color:white;cursor:default">teams</LI></UL></DIV><DIV class="right-menu noprint" id="menubar"><UL><LI id="pt-login"><A href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</A></LI></UL></DIV><DIV id="search-controls" class="noprint"><FORM action="/Special:Search" id="searchform"> </FORM></DIV></DIV><DIV id="content"><H1 class="firstHeading">Team:Hong Kong HKUST/human practice/start-up kit/database/js/vendor/underscore.js</H1><DIV id="bodyContent"><H3 id="siteSub" class="noprint">From 2014.igem.org</H3><P>//     Underscore.js 1.6.0
//     <A href="http://underscorejs.org" class="external free" rel="nofollow">http://underscorejs.org</A>
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors
//     Underscore may be freely distributed under the MIT license.
</P><P>(function() {
</P><PRE> // Baseline setup
 // --------------
</PRE><PRE> // Establish the root object, `window` in the browser, or `exports` on the server.
 var root = this;
</PRE><PRE> // Save the previous value of the `_` variable.
 var previousUnderscore = root._;
</PRE><PRE> // Establish the object that gets returned to break out of a loop iteration.
 var breaker = {};
</PRE><PRE> // Save bytes in the minified (but not gzipped) version:
 var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
</PRE><PRE> // Create quick reference variables for speed access to core prototypes.
 var
   push             = ArrayProto.push,
   slice            = ArrayProto.slice,
   concat           = ArrayProto.concat,
   toString         = ObjProto.toString,
   hasOwnProperty   = ObjProto.hasOwnProperty;
</PRE><PRE> // All **ECMAScript 5** native function implementations that we hope to use
 // are declared here.
 var
   nativeForEach      = ArrayProto.forEach,
   nativeMap          = ArrayProto.map,
   nativeReduce       = ArrayProto.reduce,
   nativeReduceRight  = ArrayProto.reduceRight,
   nativeFilter       = ArrayProto.filter,
   nativeEvery        = ArrayProto.every,
   nativeSome         = ArrayProto.some,
   nativeIndexOf      = ArrayProto.indexOf,
   nativeLastIndexOf  = ArrayProto.lastIndexOf,
   nativeIsArray      = Array.isArray,
   nativeKeys         = Object.keys,
   nativeBind         = FuncProto.bind;
</PRE><PRE> // Create a safe reference to the Underscore object for use below.
 var _ = function(obj) {
   if (obj instanceof _) return obj;
   if (!(this instanceof _)) return new _(obj);
   this._wrapped = obj;
 };
</PRE><PRE> // Export the Underscore object for **Node.js**, with
 // backwards-compatibility for the old `require()` API. If we're in
 // the browser, add `_` as a global object via a string identifier,
 // for Closure Compiler &quot;advanced&quot; mode.
 if (typeof exports !== 'undefined') {
   if (typeof module !== 'undefined' &amp;&amp; module.exports) {
     exports = module.exports = _;
   }
   exports._ = _;
 } else {
   root._ = _;
 }
</PRE><PRE> // Current version.
 _.VERSION = '1.6.0';
</PRE><PRE> // Collection Functions
 // --------------------
</PRE><PRE> // The cornerstone, an `each` implementation, aka `forEach`.
 // Handles objects with the built-in `forEach`, arrays, and raw objects.
 // Delegates to **ECMAScript 5**'s native `forEach` if available.
 var each = _.each = _.forEach = function(obj, iterator, context) {
   if (obj == null) return obj;
   if (nativeForEach &amp;&amp; obj.forEach === nativeForEach) {
     obj.forEach(iterator, context);
   } else if (obj.length === +obj.length) {
     for (var i = 0, length = obj.length; i &lt; length; i++) {
       if (iterator.call(context, obj[i], i, obj) === breaker) return;
     }
   } else {
     var keys = _.keys(obj);
     for (var i = 0, length = keys.length; i &lt; length; i++) {
       if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
     }
   }
   return obj;
 };
</PRE><PRE> // Return the results of applying the iterator to each element.
 // Delegates to **ECMAScript 5**'s native `map` if available.
 _.map = _.collect = function(obj, iterator, context) {
   var results = [];
   if (obj == null) return results;
   if (nativeMap &amp;&amp; obj.map === nativeMap) return obj.map(iterator, context);
   each(obj, function(value, index, list) {
     results.push(iterator.call(context, value, index, list));
   });
   return results;
 };
</PRE><PRE> var reduceError = 'Reduce of empty array with no initial value';
</PRE><PRE> // **Reduce** builds up a single result from a list of values, aka `inject`,
 // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
 _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
   var initial = arguments.length &gt; 2;
   if (obj == null) obj = [];
   if (nativeReduce &amp;&amp; obj.reduce === nativeReduce) {
     if (context) iterator = _.bind(iterator, context);
     return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
   }
   each(obj, function(value, index, list) {
     if (!initial) {
       memo = value;
       initial = true;
     } else {
       memo = iterator.call(context, memo, value, index, list);
     }
   });
   if (!initial) throw new TypeError(reduceError);
   return memo;
 };
</PRE><PRE> // The right-associative version of reduce, also known as `foldr`.
 // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
 _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
   var initial = arguments.length &gt; 2;
   if (obj == null) obj = [];
   if (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) {
     if (context) iterator = _.bind(iterator, context);
     return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
   }
   var length = obj.length;
   if (length !== +length) {
     var keys = _.keys(obj);
     length = keys.length;
   }
   each(obj, function(value, index, list) {
     index = keys ? keys[--length] : --length;
     if (!initial) {
       memo = obj[index];
       initial = true;
     } else {
       memo = iterator.call(context, memo, obj[index], index, list);
     }
   });
   if (!initial) throw new TypeError(reduceError);
   return memo;
 };
</PRE><PRE> // Return the first value which passes a truth test. Aliased as `detect`.
 _.find = _.detect = function(obj, predicate, context) {
   var result;
   any(obj, function(value, index, list) {
     if (predicate.call(context, value, index, list)) {
       result = value;
       return true;
     }
   });
   return result;
 };
</PRE><PRE> // Return all the elements that pass a truth test.
 // Delegates to **ECMAScript 5**'s native `filter` if available.
 // Aliased as `select`.
 _.filter = _.select = function(obj, predicate, context) {
   var results = [];
   if (obj == null) return results;
   if (nativeFilter &amp;&amp; obj.filter === nativeFilter) return obj.filter(predicate, context);
   each(obj, function(value, index, list) {
     if (predicate.call(context, value, index, list)) results.push(value);
   });
   return results;
 };
</PRE><PRE> // Return all the elements for which a truth test fails.
 _.reject = function(obj, predicate, context) {
   return _.filter(obj, function(value, index, list) {
     return !predicate.call(context, value, index, list);
   }, context);
 };
</PRE><PRE> // Determine whether all of the elements match a truth test.
 // Delegates to **ECMAScript 5**'s native `every` if available.
 // Aliased as `all`.
 _.every = _.all = function(obj, predicate, context) {
   predicate || (predicate = _.identity);
   var result = true;
   if (obj == null) return result;
   if (nativeEvery &amp;&amp; obj.every === nativeEvery) return obj.every(predicate, context);
   each(obj, function(value, index, list) {
     if (!(result = result &amp;&amp; predicate.call(context, value, index, list))) return breaker;
   });
   return !!result;
 };
</PRE><PRE> // Determine if at least one element in the object matches a truth test.
 // Delegates to **ECMAScript 5**'s native `some` if available.
 // Aliased as `any`.
 var any = _.some = _.any = function(obj, predicate, context) {
   predicate || (predicate = _.identity);
   var result = false;
   if (obj == null) return result;
   if (nativeSome &amp;&amp; obj.some === nativeSome) return obj.some(predicate, context);
   each(obj, function(value, index, list) {
     if (result || (result = predicate.call(context, value, index, list))) return breaker;
   });
   return !!result;
 };
</PRE><PRE> // Determine if the array or object contains a given value (using `===`).
 // Aliased as `include`.
 _.contains = _.include = function(obj, target) {
   if (obj == null) return false;
   if (nativeIndexOf &amp;&amp; obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
   return any(obj, function(value) {
     return value === target;
   });
 };
</PRE><PRE> // Invoke a method (with arguments) on every item in a collection.
 _.invoke = function(obj, method) {
   var args = slice.call(arguments, 2);
   var isFunc = _.isFunction(method);
   return _.map(obj, function(value) {
     return (isFunc ? method : value[method]).apply(value, args);
   });
 };
</PRE><PRE> // Convenience version of a common use case of `map`: fetching a property.
 _.pluck = function(obj, key) {
   return _.map(obj, _.property(key));
 };
</PRE><PRE> // Convenience version of a common use case of `filter`: selecting only objects
 // containing specific `key:value` pairs.
 _.where = function(obj, attrs) {
   return _.filter(obj, _.matches(attrs));
 };
</PRE><PRE> // Convenience version of a common use case of `find`: getting the first object
 // containing specific `key:value` pairs.
 _.findWhere = function(obj, attrs) {
   return _.find(obj, _.matches(attrs));
 };
</PRE><PRE> // Return the maximum element or (element-based computation).
 // Can't optimize arrays of integers longer than 65,535 elements.
 // See [WebKit Bug 80797](<A href="https://bugs.webkit.org/show_bug.cgi?id=80797" class="external free" rel="nofollow">https://bugs.webkit.org/show_bug.cgi?id=80797</A>)
 _.max = function(obj, iterator, context) {
   if (!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0] &amp;&amp; obj.length &lt; 65535) {
     return Math.max.apply(Math, obj);
   }
   var result = -Infinity, lastComputed = -Infinity;
   each(obj, function(value, index, list) {
     var computed = iterator ? iterator.call(context, value, index, list) : value;
     if (computed &gt; lastComputed) {
       result = value;
       lastComputed = computed;
     }
   });
   return result;
 };
</PRE><PRE> // Return the minimum element (or element-based computation).
 _.min = function(obj, iterator, context) {
   if (!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0] &amp;&amp; obj.length &lt; 65535) {
     return Math.min.apply(Math, obj);
   }
   var result = Infinity, lastComputed = Infinity;
   each(obj, function(value, index, list) {
     var computed = iterator ? iterator.call(context, value, index, list) : value;
     if (computed &lt; lastComputed) {
       result = value;
       lastComputed = computed;
     }
   });
   return result;
 };
</PRE><PRE> // Shuffle an array, using the modern version of the
 // [Fisher-Yates shuffle](<A href="http://en.wikipedia.org/wiki/Fisher–Yates_shuffle" class="external free" rel="nofollow">http://en.wikipedia.org/wiki/Fisher–Yates_shuffle</A>).
 _.shuffle = function(obj) {
   var rand;
   var index = 0;
   var shuffled = [];
   each(obj, function(value) {
     rand = _.random(index++);
     shuffled[index - 1] = shuffled[rand];
     shuffled[rand] = value;
   });
   return shuffled;
 };
</PRE><PRE> // Sample **n** random values from a collection.
 // If **n** is not specified, returns a single random element.
 // The internal `guard` argument allows it to work with `map`.
 _.sample = function(obj, n, guard) {
   if (n == null || guard) {
     if (obj.length !== +obj.length) obj = _.values(obj);
     return obj[_.random(obj.length - 1)];
   }
   return _.shuffle(obj).slice(0, Math.max(0, n));
 };
</PRE><PRE> // An internal function to generate lookup iterators.
 var lookupIterator = function(value) {
   if (value == null) return _.identity;
   if (_.isFunction(value)) return value;
   return _.property(value);
 };
</PRE><PRE> // Sort the object's values by a criterion produced by an iterator.
 _.sortBy = function(obj, iterator, context) {
   iterator = lookupIterator(iterator);
   return _.pluck(_.map(obj, function(value, index, list) {
     return {
       value: value,
       index: index,
       criteria: iterator.call(context, value, index, list)
     };
   }).sort(function(left, right) {
     var a = left.criteria;
     var b = right.criteria;
     if (a !== b) {
       if (a &gt; b || a === void 0) return 1;
       if (a &lt; b || b === void 0) return -1;
     }
     return left.index - right.index;
   }), 'value');
 };
</PRE><PRE> // An internal function used for aggregate &quot;group by&quot; operations.
 var group = function(behavior) {
   return function(obj, iterator, context) {
     var result = {};
     iterator = lookupIterator(iterator);
     each(obj, function(value, index) {
       var key = iterator.call(context, value, index, obj);
       behavior(result, key, value);
     });
     return result;
   };
 };
</PRE><PRE> // Groups the object's values by a criterion. Pass either a string attribute
 // to group by, or a function that returns the criterion.
 _.groupBy = group(function(result, key, value) {
   _.has(result, key) ? result[key].push(value) : result[key] = [value];
 });
</PRE><PRE> // Indexes the object's values by a criterion, similar to `groupBy`, but for
 // when you know that your index values will be unique.
 _.indexBy = group(function(result, key, value) {
   result[key] = value;
 });
</PRE><PRE> // Counts instances of an object that group by a certain criterion. Pass
 // either a string attribute to count by, or a function that returns the
 // criterion.
 _.countBy = group(function(result, key) {
   _.has(result, key) ? result[key]++ : result[key] = 1;
 });
</PRE><PRE> // Use a comparator function to figure out the smallest index at which
 // an object should be inserted so as to maintain order. Uses binary search.
 _.sortedIndex = function(array, obj, iterator, context) {
   iterator = lookupIterator(iterator);
   var value = iterator.call(context, obj);
   var low = 0, high = array.length;
   while (low &lt; high) {
     var mid = (low + high) &gt;&gt;&gt; 1;
     iterator.call(context, array[mid]) &lt; value ? low = mid + 1 : high = mid;
   }
   return low;
 };
</PRE><PRE> // Safely create a real, live array from anything iterable.
 _.toArray = function(obj) {
   if (!obj) return [];
   if (_.isArray(obj)) return slice.call(obj);
   if (obj.length === +obj.length) return _.map(obj, _.identity);
   return _.values(obj);
 };
</PRE><PRE> // Return the number of elements in an object.
 _.size = function(obj) {
   if (obj == null) return 0;
   return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
 };
</PRE><PRE> // Array Functions
 // ---------------
</PRE><PRE> // Get the first element of an array. Passing **n** will return the first N
 // values in the array. Aliased as `head` and `take`. The **guard** check
 // allows it to work with `_.map`.
 _.first = _.head = _.take = function(array, n, guard) {
   if (array == null) return void 0;
   if ((n == null) || guard) return array[0];
   if (n &lt; 0) return [];
   return slice.call(array, 0, n);
 };
</PRE><PRE> // Returns everything but the last entry of the array. Especially useful on
 // the arguments object. Passing **n** will return all the values in
 // the array, excluding the last N. The **guard** check allows it to work with
 // `_.map`.
 _.initial = function(array, n, guard) {
   return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
 };
</PRE><PRE> // Get the last element of an array. Passing **n** will return the last N
 // values in the array. The **guard** check allows it to work with `_.map`.
 _.last = function(array, n, guard) {
   if (array == null) return void 0;
   if ((n == null) || guard) return array[array.length - 1];
   return slice.call(array, Math.max(array.length - n, 0));
 };
</PRE><PRE> // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
 // Especially useful on the arguments object. Passing an **n** will return
 // the rest N values in the array. The **guard**
 // check allows it to work with `_.map`.
 _.rest = _.tail = _.drop = function(array, n, guard) {
   return slice.call(array, (n == null) || guard ? 1 : n);
 };
</PRE><PRE> // Trim out all falsy values from an array.
 _.compact = function(array) {
   return _.filter(array, _.identity);
 };
</PRE><PRE> // Internal implementation of a recursive `flatten` function.
 var flatten = function(input, shallow, output) {
   if (shallow &amp;&amp; _.every(input, _.isArray)) {
     return concat.apply(output, input);
   }
   each(input, function(value) {
     if (_.isArray(value) || _.isArguments(value)) {
       shallow ? push.apply(output, value) : flatten(value, shallow, output);
     } else {
       output.push(value);
     }
   });
   return output;
 };
</PRE><PRE> // Flatten out an array, either recursively (by default), or just one level.
 _.flatten = function(array, shallow) {
   return flatten(array, shallow, []);
 };
</PRE><PRE> // Return a version of the array that does not contain the specified value(s).
 _.without = function(array) {
   return _.difference(array, slice.call(arguments, 1));
 };
</PRE><PRE> // Split an array into two arrays: one whose elements all satisfy the given
 // predicate, and one whose elements all do not satisfy the predicate.
 _.partition = function(array, predicate) {
   var pass = [], fail = [];
   each(array, function(elem) {
     (predicate(elem) ? pass : fail).push(elem);
   });
   return [pass, fail];
 };
</PRE><PRE> // Produce a duplicate-free version of the array. If the array has already
 // been sorted, you have the option of using a faster algorithm.
 // Aliased as `unique`.
 _.uniq = _.unique = function(array, isSorted, iterator, context) {
   if (_.isFunction(isSorted)) {
     context = iterator;
     iterator = isSorted;
     isSorted = false;
   }
   var initial = iterator ? _.map(array, iterator, context) : array;
   var results = [];
   var seen = [];
   each(initial, function(value, index) {
     if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
       seen.push(value);
       results.push(array[index]);
     }
   });
   return results;
 };
</PRE><PRE> // Produce an array that contains the union: each distinct element from all of
 // the passed-in arrays.
 _.union = function() {
   return _.uniq(_.flatten(arguments, true));
 };
</PRE><PRE> // Produce an array that contains every item shared between all the
 // passed-in arrays.
 _.intersection = function(array) {
   var rest = slice.call(arguments, 1);
   return _.filter(_.uniq(array), function(item) {
     return _.every(rest, function(other) {
       return _.contains(other, item);
     });
   });
 };
</PRE><PRE> // Take the difference between one array and a number of other arrays.
 // Only the elements present in just the first array will remain.
 _.difference = function(array) {
   var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
   return _.filter(array, function(value){ return !_.contains(rest, value); });
 };
</PRE><PRE> // Zip together multiple lists into a single array -- elements that share
 // an index go together.
 _.zip = function() {
   var length = _.max(_.pluck(arguments, 'length').concat(0));
   var results = new Array(length);
   for (var i = 0; i &lt; length; i++) {
     results[i] = _.pluck(arguments, <I> + i);</I>
   }
   return results;
 };
</PRE><PRE> // Converts lists into objects. Pass either a single array of `[key, value]`
 // pairs, or two parallel arrays of the same length -- one of keys, and one of
 // the corresponding values.
 _.object = function(list, values) {
   if (list == null) return {};
   var result = {};
   for (var i = 0, length = list.length; i &lt; length; i++) {
     if (values) {
       result[list[i]] = values[i];
     } else {
       result[list[i][0]] = list[i][1];
     }
   }
   return result;
 };
</PRE><PRE> // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
 // we need this function. Return the position of the first occurrence of an
 // item in an array, or -1 if the item is not included in the array.
 // Delegates to **ECMAScript 5**'s native `indexOf` if available.
 // If the array is large and already in sort order, pass `true`
 // for **isSorted** to use binary search.
 _.indexOf = function(array, item, isSorted) {
   if (array == null) return -1;
   var i = 0, length = array.length;
   if (isSorted) {
     if (typeof isSorted == 'number') {
       i = (isSorted &lt; 0 ? Math.max(0, length + isSorted) : isSorted);
     } else {
       i = _.sortedIndex(array, item);
       return array[i] === item ? i : -1;
     }
   }
   if (nativeIndexOf &amp;&amp; array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
   for (; i &lt; length; i++) if (array[i] === item) return i;
   return -1;
 };
</PRE><PRE> // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
 _.lastIndexOf = function(array, item, from) {
   if (array == null) return -1;
   var hasIndex = from != null;
   if (nativeLastIndexOf &amp;&amp; array.lastIndexOf === nativeLastIndexOf) {
     return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
   }
   var i = (hasIndex ? from : array.length);
   while (i--) if (array[i] === item) return i;
   return -1;
 };
</PRE><PRE> // Generate an integer Array containing an arithmetic progression. A port of
 // the native Python `range()` function. See
 // [the Python documentation](<A href="http://docs.python.org/library/functions.html#range" class="external free" rel="nofollow">http://docs.python.org/library/functions.html#range</A>).
 _.range = function(start, stop, step) {
   if (arguments.length &lt;= 1) {
     stop = start || 0;
     start = 0;
   }
   step = arguments[2] || 1;
</PRE><PRE>   var length = Math.max(Math.ceil((stop - start) / step), 0);
   var idx = 0;
   var range = new Array(length);
</PRE><PRE>   while(idx &lt; length) {
     range[idx++] = start;
     start += step;
   }
</PRE><PRE>   return range;
 };
</PRE><PRE> // Function (ahem) Functions
 // ------------------
</PRE><PRE> // Reusable constructor function for prototype setting.
 var ctor = function(){};
</PRE><PRE> // Create a function bound to a given object (assigning `this`, and arguments,
 // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
 // available.
 _.bind = function(func, context) {
   var args, bound;
   if (nativeBind &amp;&amp; func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
   if (!_.isFunction(func)) throw new TypeError;
   args = slice.call(arguments, 2);
   return bound = function() {
     if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
     ctor.prototype = func.prototype;
     var self = new ctor;
     ctor.prototype = null;
     var result = func.apply(self, args.concat(slice.call(arguments)));
     if (Object(result) === result) return result;
     return self;
   };
 };
</PRE><PRE> // Partially apply a function by creating a version that has had some of its
 // arguments pre-filled, without changing its dynamic `this` context. _ acts
 // as a placeholder, allowing any combination of arguments to be pre-filled.
 _.partial = function(func) {
   var boundArgs = slice.call(arguments, 1);
   return function() {
     var position = 0;
     var args = boundArgs.slice();
     for (var i = 0, length = args.length; i &lt; length; i++) {
       if (args[i] === _) args[i] = arguments[position++];
     }
     while (position &lt; arguments.length) args.push(arguments[position++]);
     return func.apply(this, args);
   };
 };
</PRE><PRE> // Bind a number of an object's methods to that object. Remaining arguments
 // are the method names to be bound. Useful for ensuring that all callbacks
 // defined on an object belong to it.
 _.bindAll = function(obj) {
   var funcs = slice.call(arguments, 1);
   if (funcs.length === 0) throw new Error('bindAll must be passed function names');
   each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
   return obj;
 };
</PRE><PRE> // Memoize an expensive function by storing its results.
 _.memoize = function(func, hasher) {
   var memo = {};
   hasher || (hasher = _.identity);
   return function() {
     var key = hasher.apply(this, arguments);
     return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
   };
 };
</PRE><PRE> // Delays a function for the given number of milliseconds, and then calls
 // it with the arguments supplied.
 _.delay = function(func, wait) {
   var args = slice.call(arguments, 2);
   return setTimeout(function(){ return func.apply(null, args); }, wait);
 };
</PRE><PRE> // Defers a function, scheduling it to run after the current call stack has
 // cleared.
 _.defer = function(func) {
   return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
 };
</PRE><PRE> // Returns a function, that, when invoked, will only be triggered at most once
 // during a given window of time. Normally, the throttled function will run
 // as much as it can, without ever going more than once per `wait` duration;
 // but if you'd like to disable the execution on the leading edge, pass
 // `{leading: false}`. To disable execution on the trailing edge, ditto.
 _.throttle = function(func, wait, options) {
   var context, args, result;
   var timeout = null;
   var previous = 0;
   options || (options = {});
   var later = function() {
     previous = options.leading === false ? 0 : _.now();
     timeout = null;
     result = func.apply(context, args);
     context = args = null;
   };
   return function() {
     var now = _.now();
     if (!previous &amp;&amp; options.leading === false) previous = now;
     var remaining = wait - (now - previous);
     context = this;
     args = arguments;
     if (remaining &lt;= 0) {
       clearTimeout(timeout);
       timeout = null;
       previous = now;
       result = func.apply(context, args);
       context = args = null;
     } else if (!timeout &amp;&amp; options.trailing !== false) {
       timeout = setTimeout(later, remaining);
     }
     return result;
   };
 };
</PRE><PRE> // Returns a function, that, as long as it continues to be invoked, will not
 // be triggered. The function will be called after it stops being called for
 // N milliseconds. If `immediate` is passed, trigger the function on the
 // leading edge, instead of the trailing.
 _.debounce = function(func, wait, immediate) {
   var timeout, args, context, timestamp, result;
</PRE><PRE>   var later = function() {
     var last = _.now() - timestamp;
     if (last &lt; wait) {
       timeout = setTimeout(later, wait - last);
     } else {
       timeout = null;
       if (!immediate) {
         result = func.apply(context, args);
         context = args = null;
       }
     }
   };
</PRE><PRE>   return function() {
     context = this;
     args = arguments;
     timestamp = _.now();
     var callNow = immediate &amp;&amp; !timeout;
     if (!timeout) {
       timeout = setTimeout(later, wait);
     }
     if (callNow) {
       result = func.apply(context, args);
       context = args = null;
     }
</PRE><PRE>     return result;
   };
 };
</PRE><PRE> // Returns a function that will be executed at most one time, no matter how
 // often you call it. Useful for lazy initialization.
 _.once = function(func) {
   var ran = false, memo;
   return function() {
     if (ran) return memo;
     ran = true;
     memo = func.apply(this, arguments);
     func = null;
     return memo;
   };
 };
</PRE><PRE> // Returns the first function passed as an argument to the second,
 // allowing you to adjust arguments, run code before and after, and
 // conditionally execute the original function.
 _.wrap = function(func, wrapper) {
   return _.partial(wrapper, func);
 };
</PRE><PRE> // Returns a function that is the composition of a list of functions, each
 // consuming the return value of the function that follows.
 _.compose = function() {
   var funcs = arguments;
   return function() {
     var args = arguments;
     for (var i = funcs.length - 1; i &gt;= 0; i--) {
       args = [funcs[i].apply(this, args)];
     }
     return args[0];
   };
 };
</PRE><PRE> // Returns a function that will only be executed after being called N times.
 _.after = function(times, func) {
   return function() {
     if (--times &lt; 1) {
       return func.apply(this, arguments);
     }
   };
 };
</PRE><PRE> // Object Functions
 // ----------------
</PRE><PRE> // Retrieve the names of an object's properties.
 // Delegates to **ECMAScript 5**'s native `Object.keys`
 _.keys = function(obj) {
   if (!_.isObject(obj)) return [];
   if (nativeKeys) return nativeKeys(obj);
   var keys = [];
   for (var key in obj) if (_.has(obj, key)) keys.push(key);
   return keys;
 };
</PRE><PRE> // Retrieve the values of an object's properties.
 _.values = function(obj) {
   var keys = _.keys(obj);
   var length = keys.length;
   var values = new Array(length);
   for (var i = 0; i &lt; length; i++) {
     values[i] = obj[keys[i]];
   }
   return values;
 };
</PRE><PRE> // Convert an object into a list of `[key, value]` pairs.
 _.pairs = function(obj) {
   var keys = _.keys(obj);
   var length = keys.length;
   var pairs = new Array(length);
   for (var i = 0; i &lt; length; i++) {
     pairs[i] = [keys[i], obj[keys[i]]];
   }
   return pairs;
 };
</PRE><PRE> // Invert the keys and values of an object. The values must be serializable.
 _.invert = function(obj) {
   var result = {};
   var keys = _.keys(obj);
   for (var i = 0, length = keys.length; i &lt; length; i++) {
     result[obj[keys[i]]] = keys[i];
   }
   return result;
 };
</PRE><PRE> // Return a sorted list of the function names available on the object.
 // Aliased as `methods`
 _.functions = _.methods = function(obj) {
   var names = [];
   for (var key in obj) {
     if (_.isFunction(obj[key])) names.push(key);
   }
   return names.sort();
 };
</PRE><PRE> // Extend a given object with all the properties in passed-in object(s).
 _.extend = function(obj) {
   each(slice.call(arguments, 1), function(source) {
     if (source) {
       for (var prop in source) {
         obj[prop] = source[prop];
       }
     }
   });
   return obj;
 };
</PRE><PRE> // Return a copy of the object only containing the whitelisted properties.
 _.pick = function(obj) {
   var copy = {};
   var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
   each(keys, function(key) {
     if (key in obj) copy[key] = obj[key];
   });
   return copy;
 };
</PRE><PRE>  // Return a copy of the object without the blacklisted properties.
 _.omit = function(obj) {
   var copy = {};
   var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
   for (var key in obj) {
     if (!_.contains(keys, key)) copy[key] = obj[key];
   }
   return copy;
 };
</PRE><PRE> // Fill in a given object with default properties.
 _.defaults = function(obj) {
   each(slice.call(arguments, 1), function(source) {
     if (source) {
       for (var prop in source) {
         if (obj[prop] === void 0) obj[prop] = source[prop];
       }
     }
   });
   return obj;
 };
</PRE><PRE> // Create a (shallow-cloned) duplicate of an object.
 _.clone = function(obj) {
   if (!_.isObject(obj)) return obj;
   return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
 };
</PRE><PRE> // Invokes interceptor with the obj, and then returns obj.
 // The primary purpose of this method is to &quot;tap into&quot; a method chain, in
 // order to perform operations on intermediate results within the chain.
 _.tap = function(obj, interceptor) {
   interceptor(obj);
   return obj;
 };
</PRE><PRE> // Internal recursive comparison function for `isEqual`.
 var eq = function(a, b, aStack, bStack) {
   // Identical objects are equal. `0 === -0`, but they aren't identical.
   // See the [Harmony `egal` proposal](<A href="http://wiki.ecmascript.org/doku.php?id=harmony:egal" class="external free" rel="nofollow">http://wiki.ecmascript.org/doku.php?id=harmony:egal</A>).
   if (a === b) return a !== 0 || 1 / a == 1 / b;
   // A strict comparison is necessary because `null == undefined`.
   if (a == null || b == null) return a === b;
   // Unwrap any wrapped objects.
   if (a instanceof _) a = a._wrapped;
   if (b instanceof _) b = b._wrapped;
   // Compare `<A href="/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1" class="new" title="Class (page does not exist)">Class</A>` names.
   var className = toString.call(a);
   if (className != toString.call(b)) return false;
   switch (className) {
     // Strings, numbers, dates, and booleans are compared by value.
     case '[object String]':
       // Primitives and their corresponding object wrappers are equivalent; thus, `&quot;5&quot;` is
       // equivalent to `new String(&quot;5&quot;)`.
       return a == String(b);
     case '[object Number]':
       // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
       // other numeric values.
       return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
     case '[object Date]':
     case '[object Boolean]':
       // Coerce dates and booleans to numeric primitive values. Dates are compared by their
       // millisecond representations. Note that invalid dates with millisecond representations
       // of `NaN` are not equivalent.
       return +a == +b;
     // RegExps are compared by their source patterns and flags.
     case '[object RegExp]':
       return a.source == b.source &amp;&amp;
              a.global == b.global &amp;&amp;
              a.multiline == b.multiline &amp;&amp;
              a.ignoreCase == b.ignoreCase;
   }
   if (typeof a != 'object' || typeof b != 'object') return false;
   // Assume equality for cyclic structures. The algorithm for detecting cyclic
   // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
   var length = aStack.length;
   while (length--) {
     // Linear search. Performance is inversely proportional to the number of
     // unique nested structures.
     if (aStack[length] == a) return bStack[length] == b;
   }
   // Objects with different constructors are not equivalent, but `Object`s
   // from different frames are.
   var aCtor = a.constructor, bCtor = b.constructor;
   if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; (aCtor instanceof aCtor) &amp;&amp;
                            _.isFunction(bCtor) &amp;&amp; (bCtor instanceof bCtor))
                       &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) {
     return false;
   }
   // Add the first object to the stack of traversed objects.
   aStack.push(a);
   bStack.push(b);
   var size = 0, result = true;
   // Recursively compare objects and arrays.
   if (className == '[object Array]') {
     // Compare array lengths to determine if a deep comparison is necessary.
     size = a.length;
     result = size == b.length;
     if (result) {
       // Deep compare the contents, ignoring non-numeric properties.
       while (size--) {
         if (!(result = eq(a[size], b[size], aStack, bStack))) break;
       }
     }
   } else {
     // Deep compare objects.
     for (var key in a) {
       if (_.has(a, key)) {
         // Count the expected number of properties.
         size++;
         // Deep compare each member.
         if (!(result = _.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) break;
       }
     }
     // Ensure that both objects contain the same number of properties.
     if (result) {
       for (key in b) {
         if (_.has(b, key) &amp;&amp; !(size--)) break;
       }
       result = !size;
     }
   }
   // Remove the first object from the stack of traversed objects.
   aStack.pop();
   bStack.pop();
   return result;
 };
</PRE><PRE> // Perform a deep comparison to check if two objects are equal.
 _.isEqual = function(a, b) {
   return eq(a, b, [], []);
 };
</PRE><PRE> // Is a given array, string, or object empty?
 // An &quot;empty&quot; object has no enumerable own-properties.
 _.isEmpty = function(obj) {
   if (obj == null) return true;
   if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
   for (var key in obj) if (_.has(obj, key)) return false;
   return true;
 };
</PRE><PRE> // Is a given value a DOM element?
 _.isElement = function(obj) {
   return !!(obj &amp;&amp; obj.nodeType === 1);
 };
</PRE><PRE> // Is a given value an array?
 // Delegates to ECMA5's native Array.isArray
 _.isArray = nativeIsArray || function(obj) {
   return toString.call(obj) == '[object Array]';
 };
</PRE><PRE> // Is a given variable an object?
 _.isObject = function(obj) {
   return obj === Object(obj);
 };
</PRE><PRE> // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
 each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
   _['is' + name] = function(obj) {
     return toString.call(obj) == '[object ' + name + ']';
   };
 });
</PRE><PRE> // Define a fallback version of the method in browsers (ahem, IE), where
 // there isn't any inspectable &quot;Arguments&quot; type.
 if (!_.isArguments(arguments)) {
   _.isArguments = function(obj) {
     return !!(obj &amp;&amp; _.has(obj, 'callee'));
   };
 }
</PRE><PRE> // Optimize `isFunction` if appropriate.
 if (typeof (/./) !== 'function') {
   _.isFunction = function(obj) {
     return typeof obj === 'function';
   };
 }
</PRE><PRE> // Is a given object a finite number?
 _.isFinite = function(obj) {
   return isFinite(obj) &amp;&amp; !isNaN(parseFloat(obj));
 };
</PRE><PRE> // Is the given value `NaN`? (NaN is the only number which does not equal itself).
 _.isNaN = function(obj) {
   return _.isNumber(obj) &amp;&amp; obj != +obj;
 };
</PRE><PRE> // Is a given value a boolean?
 _.isBoolean = function(obj) {
   return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
 };
</PRE><PRE> // Is a given value equal to null?
 _.isNull = function(obj) {
   return obj === null;
 };
</PRE><PRE> // Is a given variable undefined?
 _.isUndefined = function(obj) {
   return obj === void 0;
 };
</PRE><PRE> // Shortcut function for checking if an object has a given property directly
 // on itself (in other words, not on a prototype).
 _.has = function(obj, key) {
   return hasOwnProperty.call(obj, key);
 };
</PRE><PRE> // Utility Functions
 // -----------------
</PRE><PRE> // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
 // previous owner. Returns a reference to the Underscore object.
 _.noConflict = function() {
   root._ = previousUnderscore;
   return this;
 };
</PRE><PRE> // Keep the identity function around for default iterators.
 _.identity = function(value) {
   return value;
 };
</PRE><PRE> _.constant = function(value) {
   return function () {
     return value;
   };
 };
</PRE><PRE> _.property = function(key) {
   return function(obj) {
     return obj[key];
   };
 };
</PRE><PRE> // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
 _.matches = function(attrs) {
   return function(obj) {
     if (obj === attrs) return true; //avoid comparing an object to itself.
     for (var key in attrs) {
       if (attrs[key] !== obj[key])
         return false;
     }
     return true;
   }
 };
</PRE><PRE> // Run a function **n** times.
 _.times = function(n, iterator, context) {
   var accum = Array(Math.max(0, n));
   for (var i = 0; i &lt; n; i++) accum[i] = iterator.call(context, i);
   return accum;
 };
</PRE><PRE> // Return a random integer between min and max (inclusive).
 _.random = function(min, max) {
   if (max == null) {
     max = min;
     min = 0;
   }
   return min + Math.floor(Math.random() * (max - min + 1));
 };
</PRE><PRE> // A (possibly faster) way to get the current timestamp as an integer.
 _.now = Date.now || function() { return new Date().getTime(); };
</PRE><PRE> // List of HTML entities for escaping.
 var entityMap = {
   escape: {
     '&amp;': '&amp;',
     '&lt;': '&lt;',
     '&gt;': '&gt;',
     '&quot;': '&quot;',
     &quot;'&quot;: '''
   }
 };
 entityMap.unescape = _.invert(entityMap.escape);
</PRE><PRE> // Regexes containing the keys and values listed immediately above.
 var entityRegexes = {
   escape:   new RegExp('[' + _.keys(entityMap.escape).join(<I>) + ']', 'g'),</I>
   unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
 };
</PRE><PRE> // Functions for escaping and unescaping strings to/from HTML interpolation.
 _.each(['escape', 'unescape'], function(method) {
   _[method] = function(string) {
     if (string == null) return <I>;</I>
     return (<I> + string).replace(entityRegexes[method], function(match) {</I>
       return entityMap[method][match];
     });
   };
 });
</PRE><PRE> // If the value of the named `property` is a function then invoke it with the
 // `object` as context; otherwise, return it.
 _.result = function(object, property) {
   if (object == null) return void 0;
   var value = object[property];
   return _.isFunction(value) ? value.call(object) : value;
 };
</PRE><PRE> // Add your own custom functions to the Underscore object.
 _.mixin = function(obj) {
   each(_.functions(obj), function(name) {
     var func = _[name] = obj[name];
     _.prototype[name] = function() {
       var args = [this._wrapped];
       push.apply(args, arguments);
       return result.call(this, func.apply(_, args));
     };
   });
 };
</PRE><PRE> // Generate a unique integer id (unique within the entire client session).
 // Useful for temporary DOM ids.
 var idCounter = 0;
 _.uniqueId = function(prefix) {
   var id = ++idCounter + <I>;</I>
   return prefix ? prefix + id : id;
 };
</PRE><PRE> // By default, Underscore uses ERB-style template delimiters, change the
 // following template settings to use alternative delimiters.
 _.templateSettings = {
   evaluate    : /&lt;%([\s\S]+?)%&gt;/g,
   interpolate : /&lt;%=([\s\S]+?)%&gt;/g,
   escape      : /&lt;%-([\s\S]+?)%&gt;/g
 };
</PRE><PRE> // When customizing `templateSettings`, if you don't want to define an
 // interpolation, evaluation or escaping regex, we need one that is
 // guaranteed not to match.
 var noMatch = /(.)^/;
</PRE><PRE> // Certain characters need to be escaped so that they can be put into a
 // string literal.
 var escapes = {
   &quot;'&quot;:      &quot;'&quot;,
   '\\':     '\\',
   '\r':     'r',
   '\n':     'n',
   '\t':     't',
   '\u2028': 'u2028',
   '\u2029': 'u2029'
 };
</PRE><PRE> var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
</PRE><PRE> // JavaScript micro-templating, similar to John Resig's implementation.
 // Underscore templating handles arbitrary delimiters, preserves whitespace,
 // and correctly escapes quotes within interpolated code.
 _.template = function(text, data, settings) {
   var render;
   settings = _.defaults({}, settings, _.templateSettings);
</PRE><PRE>   // Combine delimiters into one regular expression via alternation.
   var matcher = new RegExp([
     (settings.escape || noMatch).source,
     (settings.interpolate || noMatch).source,
     (settings.evaluate || noMatch).source
   ].join('|') + '|$', 'g');
</PRE><PRE>   // Compile the template source, escaping string literals appropriately.
   var index = 0;
   var source = &quot;__p+='&quot;;
   text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
     source += text.slice(index, offset)
       .replace(escaper, function(match) { return '\\' + escapes[match]; });
</PRE><PRE>     if (escape) {
       source += &quot;'+\n((__t=(&quot; + escape + &quot;))==null?<I>:_.escape(__t))+\n'&quot;;</I>
     }
     if (interpolate) {
       source += &quot;'+\n((__t=(&quot; + interpolate + &quot;))==null?<I>:__t)+\n'&quot;;</I>
     }
     if (evaluate) {
       source += &quot;';\n&quot; + evaluate + &quot;\n__p+='&quot;;
     }
     index = offset + match.length;
     return match;
   });
   source += &quot;';\n&quot;;
</PRE><PRE>   // If a variable is not specified, place data values in local scope.
   if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
</PRE><PRE>   source = &quot;var __t,__p=<I>,__j=Array.prototype.join,&quot; +</I>
     &quot;print=function(){__p+=__j.call(arguments,<I>);};\n&quot; +</I>
     source + &quot;return __p;\n&quot;;
</PRE><PRE>   try {
     render = new Function(settings.variable || 'obj', '_', source);
   } catch (e) {
     e.source = source;
     throw e;
   }
</PRE><PRE>   if (data) return render(data, _);
   var template = function(data) {
     return render.call(this, data, _);
   };
</PRE><PRE>   // Provide the compiled function source as a convenience for precompilation.
   template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
</PRE><PRE>   return template;
 };
</PRE><PRE> // Add a &quot;chain&quot; function, which will delegate to the wrapper.
 _.chain = function(obj) {
   return _(obj).chain();
 };
</PRE><PRE> // OOP
 // ---------------
 // If Underscore is called as a function, it returns a wrapped object that
 // can be used OO-style. This wrapper holds altered versions of all the
 // underscore functions. Wrapped objects may be chained.
</PRE><PRE> // Helper function to continue chaining intermediate results.
 var result = function(obj) {
   return this._chain ? _(obj).chain() : obj;
 };
</PRE><PRE> // Add all of the Underscore functions to the wrapper object.
 _.mixin(_);
</PRE><PRE> // Add all mutator Array functions to the wrapper.
 each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
   var method = ArrayProto[name];
   _.prototype[name] = function() {
     var obj = this._wrapped;
     method.apply(obj, arguments);
     if ((name == 'shift' || name == 'splice') &amp;&amp; obj.length === 0) delete obj[0];
     return result.call(this, obj);
   };
 });
</PRE><PRE> // Add all accessor Array functions to the wrapper.
 each(['concat', 'join', 'slice'], function(name) {
   var method = ArrayProto[name];
   _.prototype[name] = function() {
     return result.call(this, method.apply(this._wrapped, arguments));
   };
 });
</PRE><PRE> _.extend(_.prototype, {
</PRE><PRE>   // Start chaining a wrapped Underscore object.
   chain: function() {
     this._chain = true;
     return this;
   },
</PRE><PRE>   // Extracts the result from a wrapped and chained object.
   value: function() {
     return this._wrapped;
   }
</PRE><PRE> });
</PRE><PRE> // AMD registration happens at the end for compatibility with AMD loaders
 // that may not enforce next-turn semantics on modules. Even though general
 // practice for AMD registration is to be anonymous, underscore registers
 // as a named module because, like jQuery, it is a base library that is
 // popular enough to be bundled in a third party lib, but not be part of
 // an AMD load request. Those cases could generate an error when an
 // anonymous define() is called outside of a loader request.
 if (typeof define === 'function' &amp;&amp; define.amd) {
   define('underscore', [], function() {
     return _;
   });
 }
</PRE><P>}).call(this);
</P><DIV class="printfooter">
Retrieved from &quot;<A href="http://2014.igem.org/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js">http://2014.igem.org/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js</A>&quot;</DIV></DIV></DIV><DIV id="footer-box" class="noprint"><DIV id="footer"><UL id="f-list"><LI id="t-recentchanges"><A href="/Special:RecentChanges" title="Recent changes">Recent changes</A></LI><LI id="t-whatlinkshere"><A href="/Special:WhatLinksHere/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js" title="List of all wiki pages that link here [j]" accesskey="j">What links here</A></LI><LI id="t-recentchangeslinked"><A href="/Special:RecentChangesLinked/Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</A></LI><LI id="t-specialpages"><A href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</A></LI><LI><A href="/Special:Preferences">My preferences</A></LI></UL></DIV><DIV id="footer"><UL id="f-list"><LI id="t-print"><A href="/wiki/index.php?title=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</A></LI><LI id="t-permalink"><A href="/wiki/index.php?title=Team:Hong_Kong_HKUST/human_practice/start-up_kit/database/js/vendor/underscore.js&amp;oldid=127726" title="Permanent link to this revision of the page">Permanent link</A></LI><LI id="privacy"><A href="/2014.igem.org:Privacy_policy" title="2014.igem.org:Privacy policy">Privacy policy</A></LI><LI id="disclaimer"><A href="/2014.igem.org:General_disclaimer" title="2014.igem.org:General disclaimer">Disclaimers</A></LI></UL></DIV></DIV></DIV></BODY></HTML>